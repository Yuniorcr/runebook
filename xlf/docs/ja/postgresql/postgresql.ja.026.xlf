<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="postgresql">
    <body>
      <group id="postgresql">
        <trans-unit id="13bf3c4060b6a548c1c5420c5acc0dd3edcdfdfa" translate="yes" xml:space="preserve">
          <source>When tar format mode is used, the write-ahead log files will be written to the &lt;code&gt;base.tar&lt;/code&gt; file.</source>
          <target state="translated">tar形式モードが使用されている場合、先行書き込みログファイルは &lt;code&gt;base.tar&lt;/code&gt; ファイルに書き込まれます。</target>
        </trans-unit>
        <trans-unit id="f11ae7cfc9d8e7c9709340ffb2024d1b68d62efb" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;runtime-config-replication#GUC-HOT-STANDBY&quot;&gt;hot_standby&lt;/a&gt; parameter is set to true on a standby server, it will begin accepting connections once the recovery has brought the system to a consistent state. All such connections are strictly read-only; not even temporary tables may be written.</source>
          <target state="translated">とき&lt;a href=&quot;runtime-config-replication#GUC-HOT-STANDBY&quot;&gt;hot_standbyの&lt;/a&gt;パラメータは、スタンバイサーバー上のtrueに設定されている回復が一貫性のある状態にシステムをもたらしていたら、それは接続を受け入れ始めます。このような接続はすべて厳密に読み取り専用です。一時テーブルでさえ書けないかもしれません。</target>
        </trans-unit>
        <trans-unit id="7959e96ecaba15e9d39e3fc41cafc94b8dcfae7f" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;CONSTRAINT&lt;/code&gt; option is specified, this command creates a &lt;em&gt;constraint trigger&lt;/em&gt;. This is the same as a regular trigger except that the timing of the trigger firing can be adjusted using &lt;a href=&quot;sql-set-constraints&quot;&gt;SET CONSTRAINTS&lt;/a&gt;. Constraint triggers must be &lt;code&gt;AFTER ROW&lt;/code&gt; triggers on plain tables (not foreign tables). They can be fired either at the end of the statement causing the triggering event, or at the end of the containing transaction; in the latter case they are said to be &lt;em&gt;deferred&lt;/em&gt;. A pending deferred-trigger firing can also be forced to happen immediately by using &lt;code&gt;SET CONSTRAINTS&lt;/code&gt;. Constraint triggers are expected to raise an exception when the constraints they implement are violated.</source>
          <target state="translated">とき &lt;code&gt;CONSTRAINT&lt;/code&gt; のオプションを指定すると、このコマンドは、作成&lt;em&gt;制約トリガを&lt;/em&gt;。これは、トリガーの発火のタイミングが&lt;a href=&quot;sql-set-constraints&quot;&gt;SET CONSTRAINTS&lt;/a&gt;を使用して調整できることを除いて、通常のトリガーと同じです。制約トリガーは、（外部テーブルではなく）プレーンテーブルの &lt;code&gt;AFTER ROW&lt;/code&gt; トリガーである必要があります。これらは、トリガーイベントを引き起こしているステートメントの最後、または含まれているトランザクションの最後に起動できます。後者の場合、それらは&lt;em&gt;延期さ&lt;/em&gt;れると言われています。 &lt;code&gt;SET CONSTRAINTS&lt;/code&gt; を使用すると、保留中の遅延トリガーの発火を強制的にすぐに実行することもできます。制約トリガーは、それらが実装する制約に違反すると、例外を発生させることが期待されています。</target>
        </trans-unit>
        <trans-unit id="df5c7d4a7ad0b452626a13ac455de82c0906adea" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;SELECT&lt;/code&gt; is one arm of a &lt;code&gt;UNION&lt;/code&gt; (or &lt;code&gt;INTERSECT&lt;/code&gt; or &lt;code&gt;EXCEPT&lt;/code&gt;) construct, or when it appears within &lt;code&gt;INSERT ... SELECT&lt;/code&gt;, this rule is not applied since rules given in preceding sections take precedence. The type of an unspecified-type literal can be taken from the other &lt;code&gt;UNION&lt;/code&gt; arm in the first case, or from the destination column in the second case.</source>
          <target state="translated">場合 &lt;code&gt;SELECT&lt;/code&gt; は、の一方のアームである &lt;code&gt;UNION&lt;/code&gt; （または &lt;code&gt;INTERSECT&lt;/code&gt; または &lt;code&gt;EXCEPT&lt;/code&gt; ）構築物、又はそれの中に表示されたときに &lt;code&gt;INSERT ... SELECT&lt;/code&gt; 節の前に与えられたルールが優先するので、このルールが適用されません。 unspecified-typeリテラルのタイプは、最初のケースでは他の &lt;code&gt;UNION&lt;/code&gt; アームから、または2番目のケースでは宛先列から取得できます。</target>
        </trans-unit>
        <trans-unit id="7f2ffb48d56de0e4aaa18bb9efa3e04da4e9e279" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;WHERE&lt;/code&gt; clause is present, a &lt;em&gt;partial index&lt;/em&gt; is created. A partial index is an index that contains entries for only a portion of a table, usually a portion that is more useful for indexing than the rest of the table. For example, if you have a table that contains both billed and unbilled orders where the unbilled orders take up a small fraction of the total table and yet that is an often used section, you can improve performance by creating an index on just that portion. Another possible application is to use &lt;code&gt;WHERE&lt;/code&gt; with &lt;code&gt;UNIQUE&lt;/code&gt; to enforce uniqueness over a subset of a table. See &lt;a href=&quot;indexes-partial&quot;&gt;Section 11.8&lt;/a&gt; for more discussion.</source>
          <target state="translated">ときに &lt;code&gt;WHERE&lt;/code&gt; 句が存在している、&lt;em&gt;部分インデックスが&lt;/em&gt;作成されます。部分インデックスは、テーブルの一部のみのエントリを含むインデックスです。通常、残りのテーブルよりもインデックス作成に役立つ部分です。たとえば、請求済みの注文と未請求の注文の両方を含むテーブルがあり、未請求の注文がテーブル全体のほんの一部を占めるが、それが頻繁に使用されるセクションである場合、その部分にのみインデックスを作成することでパフォーマンスを向上できます。別の可能なアプリケーションは、 &lt;code&gt;UNIQUE&lt;/code&gt; で &lt;code&gt;WHERE&lt;/code&gt; を使用して、テーブルのサブセットに対して一意性を適用することです。詳細については、&lt;a href=&quot;indexes-partial&quot;&gt;セクション11.8&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="4116b168926d645beb5cdf62d04cc02528b0adbd" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;\aset&lt;/code&gt; command is used, all combined SQL queries (separated by &lt;code&gt;\;&lt;/code&gt;) have their columns stored into variables named after column names, and prefixed with &lt;code&gt;prefix&lt;/code&gt; if provided. If a query returns no row, no assignment is made and the variable can be tested for existence to detect this. If a query returns more than one row, the last value is kept.</source>
          <target state="translated">When the &lt;code&gt;\aset&lt;/code&gt; command is used, all combined SQL queries (separated by &lt;code&gt;\;&lt;/code&gt; ) have their columns stored into variables named after column names, and prefixed with &lt;code&gt;prefix&lt;/code&gt; if provided. If a query returns no row, no assignment is made and the variable can be tested for existence to detect this. If a query returns more than one row, the last value is kept.</target>
        </trans-unit>
        <trans-unit id="438baff021646797a12e7710aeb9b4212d4a00b5" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;\gset&lt;/code&gt; command is used, the preceding SQL query is expected to return one row, the columns of which are stored into variables named after column names, and prefixed with &lt;code&gt;prefix&lt;/code&gt; if provided.</source>
          <target state="translated">When the &lt;code&gt;\gset&lt;/code&gt; command is used, the preceding SQL query is expected to return one row, the columns of which are stored into variables named after column names, and prefixed with &lt;code&gt;prefix&lt;/code&gt; if provided.</target>
        </trans-unit>
        <trans-unit id="8c185ac9497904ca6d14d82c8dc0a0e1690d4901" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;ampredlocks&lt;/code&gt; flag is not set, any scan using that index access method within a serializable transaction will acquire a nonblocking predicate lock on the full index. This will generate a read-write conflict with the insert of any tuple into that index by a concurrent serializable transaction. If certain patterns of read-write conflicts are detected among a set of concurrent serializable transactions, one of those transactions may be canceled to protect data integrity. When the flag is set, it indicates that the index access method implements finer-grained predicate locking, which will tend to reduce the frequency of such transaction cancellations.</source>
          <target state="translated">&lt;code&gt;ampredlocks&lt;/code&gt; フラグが設定されていない場合、シリアル化可能なトランザクション内でそのインデックスアクセスメソッドを使用するスキャンは、完全なインデックスで非ブロッキング述語ロックを取得します。これにより、同時直列化可能トランザクションによるそのインデックスへのタプルの挿入と読み取り/書き込みの競合が発生します。読み取り/書き込みの競合の特定のパターンが、一連の同時シリアル化可能なトランザクション間で検出された場合、データの整合性を保護するために、それらのトランザクションの1つがキャンセルされることがあります。フラグが設定されている場合、それは、インデックスアクセスメソッドがよりきめの細かい述語ロックを実装することを示します。これにより、そのようなトランザクションのキャンセルの頻度が減少する傾向があります。</target>
        </trans-unit>
        <trans-unit id="32c110466857121d054324f74c8a38f9bb5212e4" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;border&lt;/code&gt; setting is greater than zero, the &lt;code&gt;linestyle&lt;/code&gt; option also determines the characters with which the border lines are drawn. Plain ASCII characters work everywhere, but Unicode characters look nicer on displays that recognize them.</source>
          <target state="translated">ときに &lt;code&gt;border&lt;/code&gt; 設定がゼロよりも大きい場合、 &lt;code&gt;linestyle&lt;/code&gt; オプションも境界線が描画されると文字を決定します。プレーンASCII文字はどこでも機能しますが、Unicode文字はそれらを認識するディスプレイで見栄えがよくなります。</target>
        </trans-unit>
        <trans-unit id="00d6a0dfb20c2e25ada6bca76d0486b409be8ef1" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;pager&lt;/code&gt; option is &lt;code&gt;off&lt;/code&gt;, the pager program is not used. When the &lt;code&gt;pager&lt;/code&gt; option is &lt;code&gt;on&lt;/code&gt;, the pager is used when appropriate, i.e., when the output is to a terminal and will not fit on the screen. The &lt;code&gt;pager&lt;/code&gt; option can also be set to &lt;code&gt;always&lt;/code&gt;, which causes the pager to be used for all terminal output regardless of whether it fits on the screen. &lt;code&gt;\pset pager&lt;/code&gt; without a &lt;code&gt;value&lt;/code&gt; toggles pager use on and off.</source>
          <target state="translated">ときに &lt;code&gt;pager&lt;/code&gt; オプションは &lt;code&gt;off&lt;/code&gt; 、ページャプログラムが使用されていません。ときに &lt;code&gt;pager&lt;/code&gt; オプションがある &lt;code&gt;on&lt;/code&gt; 、ページャは、適切な場合に使用されている、すなわち、出力は端末にあると、画面に収まらないとき。 &lt;code&gt;pager&lt;/code&gt; オプションもに設定することができ &lt;code&gt;always&lt;/code&gt; 関係なく、それが画面に収まるかどうかのすべての端末出力に使用するページャを引き起こします。 &lt;code&gt;value&lt;/code&gt; ない &lt;code&gt;\pset pager&lt;/code&gt; は、ページャーの使用のオンとオフを切り替えます。</target>
        </trans-unit>
        <trans-unit id="81a140433737ca4c23a575624ce695fcc511dede" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;pg_buffercache&lt;/code&gt; view is accessed, internal buffer manager locks are taken for long enough to copy all the buffer state data that the view will display. This ensures that the view produces a consistent set of results, while not blocking normal buffer activity longer than necessary. Nonetheless there could be some impact on database performance if this view is read often.</source>
          <target state="translated">場合 &lt;code&gt;pg_buffercache&lt;/code&gt; のビューにアクセスし、内部バッファ・マネージャ・ロックは、ビューが表示されたすべてのバッファ状態データをコピーするために十分な長さのために採取されます。これにより、ビューは一貫した一連の結果を生成し、必要以上に通常のバッファアクティビティをブロックしなくなります。それでも、このビューが頻繁に読み込まれると、データベースのパフォーマンスに影響を与える可能性があります。</target>
        </trans-unit>
        <trans-unit id="cd60a2856753e705f8fe475e92d422e142a5a733" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;pg_prepared_xacts&lt;/code&gt; view is accessed, the internal transaction manager data structures are momentarily locked, and a copy is made for the view to display. This ensures that the view produces a consistent set of results, while not blocking normal operations longer than necessary. Nonetheless there could be some impact on database performance if this view is frequently accessed.</source>
          <target state="translated">とき &lt;code&gt;pg_prepared_xacts&lt;/code&gt; のビューがアクセスされ、内部トランザクション管理データ構造が一時的にロックされ、コピーがディスプレイに表示のために作られています。これにより、ビューは一貫した結果セットを生成し、必要以上に通常の操作をブロックしなくなります。それでも、このビューに頻繁にアクセスすると、データベースのパフォーマンスに影響が出る可能性があります。</target>
        </trans-unit>
        <trans-unit id="7ee8be71b9dbdb6fe9839b8abd30a5d0ca45b722" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;text&lt;/code&gt; format is used, the data read or written is a text file with one line per table row. Columns in a row are separated by the delimiter character. The column values themselves are strings generated by the output function, or acceptable to the input function, of each attribute's data type. The specified null string is used in place of columns that are null. &lt;code&gt;COPY FROM&lt;/code&gt; will raise an error if any line of the input file contains more or fewer columns than are expected.</source>
          <target state="translated">&lt;code&gt;text&lt;/code&gt; 形式を使用する場合、読み書きされるデータは、テーブル行ごとに1行のテキストファイルです。行の列は区切り文字で区切られます。列の値自体は、各属性のデータ型の、出力関数によって生成された、または入力関数で受け入れ可能な文字列です。指定されたnull文字列は、nullの列の代わりに使用されます。入力ファイルのいずれかの行に予想よりも多いまたは少ない列が含まれている場合、 &lt;code&gt;COPY FROM&lt;/code&gt; はエラーを発生させます。</target>
        </trans-unit>
        <trans-unit id="1c4c47cbbcff114da7b14a508ba7d65a0b19eac7" translate="yes" xml:space="preserve">
          <source>When the &lt;em&gt;&lt;code&gt;heapallindexed&lt;/code&gt;&lt;/em&gt; argument to verification functions is &lt;code&gt;true&lt;/code&gt;, an additional phase of verification is performed against the table associated with the target index relation. This consists of a &amp;ldquo;dummy&amp;rdquo;&lt;code&gt;CREATE INDEX&lt;/code&gt; operation, which checks for the presence of all hypothetical new index tuples against a temporary, in-memory summarizing structure (this is built when needed during the basic first phase of verification). The summarizing structure &amp;ldquo;fingerprints&amp;rdquo; every tuple found within the target index. The high level principle behind &lt;em&gt;&lt;code&gt;heapallindexed&lt;/code&gt;&lt;/em&gt; verification is that a new index that is equivalent to the existing, target index must only have entries that can be found in the existing structure.</source>
          <target state="translated">場合&lt;em&gt; &lt;code&gt;heapallindexed&lt;/code&gt; &lt;/em&gt;検証関数の引数が &lt;code&gt;true&lt;/code&gt; 、検証の追加的な位相は、目標指標関係に関連付けられたテーブルに対して実行されます。これは、一時的なメモリ内の集計構造（これは検証の基本的な最初のフェーズで必要なときに構築されます）に対してすべての架空の新しいインデックスタプルの存在をチェックする「ダミー」の &lt;code&gt;CREATE INDEX&lt;/code&gt; 操作で構成されます。要約構造は、ターゲットインデックス内で見つかったすべてのタプルを「フィンガープリント」します。&lt;em&gt; &lt;code&gt;heapallindexed&lt;/code&gt; &lt;/em&gt;検証の背後にある高レベルの原則は、既存のターゲットインデックスと同等の新しいインデックスには、既存の構造内にあるエントリのみが含まれている必要があるということです。</target>
        </trans-unit>
        <trans-unit id="40b2d91686c90899997e62b0858a7f4eb03cb150" translate="yes" xml:space="preserve">
          <source>When the backup is in tar format, the target directory may be specified as &lt;code&gt;-&lt;/code&gt; (dash), causing the tar file to be written to &lt;code&gt;stdout&lt;/code&gt;.</source>
          <target state="translated">When the backup is in tar format, the target directory may be specified as &lt;code&gt;-&lt;/code&gt; (dash), causing the tar file to be written to &lt;code&gt;stdout&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a4898e6eb712c6c928410a4432225d77730464bb" translate="yes" xml:space="preserve">
          <source>When the backup is in tar mode, and the directory is specified as &lt;code&gt;-&lt;/code&gt; (dash), the tar file will be written to &lt;code&gt;stdout&lt;/code&gt;.</source>
          <target state="translated">バックアップがtarモードで、ディレクトリが &lt;code&gt;-&lt;/code&gt; （ダッシュ）として指定されている場合、tarファイルは &lt;code&gt;stdout&lt;/code&gt; に書き込まれます。</target>
        </trans-unit>
        <trans-unit id="2bf62b247e8d0c8ddb36cb4a11374b1155c5b650" translate="yes" xml:space="preserve">
          <source>When the client application uses the &amp;ldquo;extended query&amp;rdquo; protocol to issue a &lt;code&gt;FETCH&lt;/code&gt; command, the Bind protocol message specifies whether data is to be retrieved in text or binary format. This choice overrides the way that the cursor is defined. The concept of a binary cursor as such is thus obsolete when using extended query protocol &amp;mdash; any cursor can be treated as either text or binary.</source>
          <target state="translated">クライアントアプリケーションが「拡張クエリ」プロトコルを使用して &lt;code&gt;FETCH&lt;/code&gt; コマンドを発行する場合、Bindプロトコルメッセージは、データをテキスト形式で取得するかバイナリ形式で取得するかを指定します。この選択は、カーソルの定義方法をオーバーライドします。したがって、拡張クエリプロトコルを使用する場合、バイナリカーソル自体の概念は廃止されます。どのカーソルもテキストまたはバイナリとして扱うことができます。</target>
        </trans-unit>
        <trans-unit id="cef2bc6393c8c4a9107edf2302ecf0f071877452" translate="yes" xml:space="preserve">
          <source>When the connection to the server is lost, do not retry in a loop, just exit.</source>
          <target state="translated">サーバーへの接続が切れた場合は、ループで再試行せずに終了してください。</target>
        </trans-unit>
        <trans-unit id="c8229aa8ad36a0b0c5e6146511e976844f24d945" translate="yes" xml:space="preserve">
          <source>When the database generates SQL, force all identifiers to be quoted, even if they are not (currently) keywords. This will affect the output of &lt;code&gt;EXPLAIN&lt;/code&gt; as well as the results of functions like &lt;code&gt;pg_get_viewdef&lt;/code&gt;. See also the &lt;code&gt;--quote-all-identifiers&lt;/code&gt; option of &lt;a href=&quot;app-pgdump&quot;&gt;pg_dump&lt;/a&gt; and &lt;a href=&quot;app-pg-dumpall&quot;&gt;pg_dumpall&lt;/a&gt;.</source>
          <target state="translated">データベースがSQLを生成するとき、識別子が（現在）キーワードでなくても、すべての識別子を強制的に引用符で囲みます。これは &lt;code&gt;EXPLAIN&lt;/code&gt; の出力と &lt;code&gt;pg_get_viewdef&lt;/code&gt; のような関数の結果に影響します。&lt;a href=&quot;app-pgdump&quot;&gt;pg_dump&lt;/a&gt;および&lt;a href=&quot;app-pg-dumpall&quot;&gt;pg_dumpall&lt;/a&gt;の &lt;code&gt;--quote-all-identifiers&lt;/code&gt; オプションも参照してください。</target>
        </trans-unit>
        <trans-unit id="ea2bc8f44657321dd80c423b48806c42005dbc7a" translate="yes" xml:space="preserve">
          <source>When the database system has to perform an ordering or a character classification, it uses the collation of the input expression. This happens, for example, with &lt;code&gt;ORDER BY&lt;/code&gt; clauses and function or operator calls such as &lt;code&gt;&amp;lt;&lt;/code&gt;. The collation to apply for an &lt;code&gt;ORDER BY&lt;/code&gt; clause is simply the collation of the sort key. The collation to apply for a function or operator call is derived from the arguments, as described below. In addition to comparison operators, collations are taken into account by functions that convert between lower and upper case letters, such as &lt;code&gt;lower&lt;/code&gt;, &lt;code&gt;upper&lt;/code&gt;, and &lt;code&gt;initcap&lt;/code&gt;; by pattern matching operators; and by &lt;code&gt;to_char&lt;/code&gt; and related functions.</source>
          <target state="translated">データベースシステムが順序付けまたは文字分類を実行する必要がある場合、入力式の照合を使用します。これは、たとえば、 &lt;code&gt;ORDER BY&lt;/code&gt; 句や &lt;code&gt;&amp;lt;&lt;/code&gt; などの関数または演算子の呼び出しで発生します。 &lt;code&gt;ORDER BY&lt;/code&gt; 句に適用する照合順序は、単にソートキーの照合順序です。関数または演算子の呼び出しに適用する照合は、以下で説明するように、引数から取得されます。比較演算子に加えて、照合は、 &lt;code&gt;lower&lt;/code&gt; 、 &lt;code&gt;upper&lt;/code&gt; 、 &lt;code&gt;initcap&lt;/code&gt; などの大文字と小文字を変換する関数によって考慮されます。パターンマッチング演算子;そして &lt;code&gt;to_char&lt;/code&gt; と関連する関数によって。</target>
        </trans-unit>
        <trans-unit id="cf20c03f9a438d0f6675629396820f040d752814" translate="yes" xml:space="preserve">
          <source>When the defaults aren't quite right, you can save yourself some typing by setting the environment variables &lt;code&gt;PGDATABASE&lt;/code&gt;, &lt;code&gt;PGHOST&lt;/code&gt;, &lt;code&gt;PGPORT&lt;/code&gt; and/or &lt;code&gt;PGUSER&lt;/code&gt; to appropriate values. (For additional environment variables, see &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-envars.html&quot;&gt;Section 33.14&lt;/a&gt;.) It is also convenient to have a &lt;code&gt;~/.pgpass&lt;/code&gt; file to avoid regularly having to type in passwords. See &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-pgpass.html&quot;&gt;Section 33.15&lt;/a&gt; for more information.</source>
          <target state="translated">デフォルトが適切でない場合は、環境変数 &lt;code&gt;PGDATABASE&lt;/code&gt; 、 &lt;code&gt;PGHOST&lt;/code&gt; 、 &lt;code&gt;PGPORT&lt;/code&gt; 、および/または &lt;code&gt;PGUSER&lt;/code&gt; を適切な値に設定することで、入力を減らすことができます。 （追加の環境変数については、&lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-envars.html&quot;&gt;セクション33.14を&lt;/a&gt;参照してください。）また、パスワードを定期的に入力する必要がないように &lt;code&gt;~/.pgpass&lt;/code&gt; ファイルを用意すると便利です。詳細は&lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-pgpass.html&quot;&gt;項33.15&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="6f26c72fbc997c040dd4a76409d282497125e57c" translate="yes" xml:space="preserve">
          <source>When the defaults aren't quite right, you can save yourself some typing by setting the environment variables &lt;code&gt;PGDATABASE&lt;/code&gt;, &lt;code&gt;PGHOST&lt;/code&gt;, &lt;code&gt;PGPORT&lt;/code&gt; and/or &lt;code&gt;PGUSER&lt;/code&gt; to appropriate values. (For additional environment variables, see &lt;a href=&quot;https://www.postgresql.org/docs/13/libpq-envars.html&quot;&gt;Section 33.14&lt;/a&gt;.) It is also convenient to have a &lt;code&gt;~/.pgpass&lt;/code&gt; file to avoid regularly having to type in passwords. See &lt;a href=&quot;https://www.postgresql.org/docs/13/libpq-pgpass.html&quot;&gt;Section 33.15&lt;/a&gt; for more information.</source>
          <target state="translated">When the defaults aren't quite right, you can save yourself some typing by setting the environment variables &lt;code&gt;PGDATABASE&lt;/code&gt; , &lt;code&gt;PGHOST&lt;/code&gt; , &lt;code&gt;PGPORT&lt;/code&gt; and/or &lt;code&gt;PGUSER&lt;/code&gt; to appropriate values. (For additional environment variables, see &lt;a href=&quot;https://www.postgresql.org/docs/13/libpq-envars.html&quot;&gt;Section 33.14&lt;/a&gt;.) It is also convenient to have a &lt;code&gt;~/.pgpass&lt;/code&gt; file to avoid regularly having to type in passwords. See &lt;a href=&quot;https://www.postgresql.org/docs/13/libpq-pgpass.html&quot;&gt;Section 33.15&lt;/a&gt; for more information.</target>
        </trans-unit>
        <trans-unit id="58644d348761a861122023ab84e086a5de61b1bd" translate="yes" xml:space="preserve">
          <source>When the input value is +/-Infinity, &lt;code&gt;extract&lt;/code&gt; returns +/-Infinity for monotonically-increasing fields (&lt;code&gt;epoch&lt;/code&gt;, &lt;code&gt;julian&lt;/code&gt;, &lt;code&gt;year&lt;/code&gt;, &lt;code&gt;isoyear&lt;/code&gt;, &lt;code&gt;decade&lt;/code&gt;, &lt;code&gt;century&lt;/code&gt;, and &lt;code&gt;millennium&lt;/code&gt;). For other fields, NULL is returned. PostgreSQL versions before 9.6 returned zero for all cases of infinite input.</source>
          <target state="translated">入力値がある場合には+/-インフィニティ、 &lt;code&gt;extract&lt;/code&gt; 戻り+/-単調増加フィールドのインフィニティ（ &lt;code&gt;epoch&lt;/code&gt; 、 &lt;code&gt;julian&lt;/code&gt; 、 &lt;code&gt;year&lt;/code&gt; 、 &lt;code&gt;isoyear&lt;/code&gt; 、 &lt;code&gt;decade&lt;/code&gt; 、 &lt;code&gt;century&lt;/code&gt; 、そして &lt;code&gt;millennium&lt;/code&gt; ）。その他のフィールドの場合、NULLが返されます。 9.6より前のバージョンのPostgreSQLは、無限入力のすべてのケースでゼロを返しました。</target>
        </trans-unit>
        <trans-unit id="ca7b95a2bfd76e66a3b9a3c283932ae7ceb9d1f3" translate="yes" xml:space="preserve">
          <source>When the input value is of type &lt;code&gt;timestamp with time zone&lt;/code&gt;, the truncation is performed with respect to a particular time zone; for example, truncation to &lt;code&gt;day&lt;/code&gt; produces a value that is midnight in that zone. By default, truncation is done with respect to the current &lt;a href=&quot;runtime-config-client#GUC-TIMEZONE&quot;&gt;TimeZone&lt;/a&gt; setting, but the optional &lt;code&gt;time_zone&lt;/code&gt; argument can be provided to specify a different time zone. The time zone name can be specified in any of the ways described in &lt;a href=&quot;datatype-datetime#DATATYPE-TIMEZONES&quot;&gt;Section 8.5.3&lt;/a&gt;.</source>
          <target state="translated">入力値のタイプが &lt;code&gt;timestamp with time zone&lt;/code&gt; 場合、切り捨ては特定のタイムゾーンに対して実行されます。例えば、への切り捨て &lt;code&gt;day&lt;/code&gt; そのゾーンで深夜の値を生成します。デフォルトでは、現在の&lt;a href=&quot;runtime-config-client#GUC-TIMEZONE&quot;&gt;TimeZone&lt;/a&gt;設定に基づいて切り捨てが行われますが、オプションの &lt;code&gt;time_zone&lt;/code&gt; 引数を指定して、別のタイムゾーンを指定できます。タイムゾーン名は、&lt;a href=&quot;datatype-datetime#DATATYPE-TIMEZONES&quot;&gt;8.5.3項&lt;/a&gt;で説明する方法のいずれかで指定できます。</target>
        </trans-unit>
        <trans-unit id="b9861851aff8e3d639ce4f8c2222c534c2772377" translate="yes" xml:space="preserve">
          <source>When the last argument begins with &lt;code&gt;|&lt;/code&gt;, the entire remainder of the line is taken to be the &lt;code&gt;command&lt;/code&gt; to execute, and neither variable interpolation nor backquote expansion are performed in it. The rest of the line is simply passed literally to the shell.</source>
          <target state="translated">When the last argument begins with &lt;code&gt;|&lt;/code&gt; , the entire remainder of the line is taken to be the &lt;code&gt;command&lt;/code&gt; to execute, and neither variable interpolation nor backquote expansion are performed in it. The rest of the line is simply passed literally to the shell.</target>
        </trans-unit>
        <trans-unit id="fb992423a64d9af4e9c24a6d03361c5985029c38" translate="yes" xml:space="preserve">
          <source>When the node at the top of the parallel portion of the plan is &lt;code&gt;Gather Merge&lt;/code&gt; rather than &lt;code&gt;Gather&lt;/code&gt;, it indicates that each process executing the parallel portion of the plan is producing tuples in sorted order, and that the leader is performing an order-preserving merge. In contrast, &lt;code&gt;Gather&lt;/code&gt; reads tuples from the workers in whatever order is convenient, destroying any sort order that may have existed.</source>
          <target state="translated">計画の平行部の上部のノードである場合 &lt;code&gt;Gather Merge&lt;/code&gt; なく &lt;code&gt;Gather&lt;/code&gt; 、それは計画の並列部分を実行する各プロセスは、ソート順でタプルを生成していること、およびリーダー順序保存マージを行っていることを示し。対照的に、 &lt;code&gt;Gather&lt;/code&gt; は、ワーカーから都合のよい順序でタプルを読み取り、存在していた可能性のある並べ替え順序を破棄します。</target>
        </trans-unit>
        <trans-unit id="3c8d54f7450d49b82cd5a8da77194f4c25e5cdb1" translate="yes" xml:space="preserve">
          <source>When the operating system sends a write request to the storage hardware, there is little it can do to make sure the data has arrived at a truly non-volatile storage area. Rather, it is the administrator's responsibility to make certain that all storage components ensure integrity for both data and file-system metadata. Avoid disk controllers that have non-battery-backed write caches. At the drive level, disable write-back caching if the drive cannot guarantee the data will be written before shutdown. If you use SSDs, be aware that many of these do not honor cache flush commands by default. You can test for reliable I/O subsystem behavior using &lt;a href=&quot;https://brad.livejournal.com/2116715.html&quot;&gt;&lt;code&gt;diskchecker.pl&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">オペレーティングシステムがストレージハードウェアに書き込み要求を送信するとき、データが本当に不揮発性のストレージ領域に到着したことを確認するためにできることはほとんどありません。むしろ、すべてのストレージコンポーネントがデータとファイルシステムメタデータの両方の整合性を保証することを確認するのは、管理者の責任です。バッテリバックアップされていない書き込みキャッシュを持つディスクコントローラは避けてください。シャットダウン前にドライブがデータの書き込みを保証できない場合は、ドライブレベルでライトバックキャッシュを無効にします。 SSDを使用する場合、これらの多くはデフォルトでキャッシュフラッシュコマンドを受け入れないことに注意してください。&lt;a href=&quot;https://brad.livejournal.com/2116715.html&quot;&gt; &lt;code&gt;diskchecker.pl&lt;/code&gt; &lt;/a&gt;を使用して、信頼性の高いI / Oサブシステムの動作をテストできます。</target>
        </trans-unit>
        <trans-unit id="2d33bb04f73c12f42af37757660638f7bf07dd0c" translate="yes" xml:space="preserve">
          <source>When the optimizer determines that parallel query is the fastest execution strategy for a particular query, it will create a query plan which includes a &lt;em&gt;Gather&lt;/em&gt; or &lt;em&gt;Gather Merge&lt;/em&gt; node. Here is a simple example:</source>
          <target state="translated">オプティマイザーは、並列クエリが特定のクエリの最速の実行戦略であると判断すると、&lt;em&gt;Gather&lt;/em&gt;ノードまたは&lt;em&gt;Gather Merge&lt;/em&gt;ノードを含むクエリプランを作成します。以下に簡単な例を示します。</target>
        </trans-unit>
        <trans-unit id="01b643d7a7954ad91561b8c24a008664f59d15dd" translate="yes" xml:space="preserve">
          <source>When the option list is surrounded by parentheses, the options can be written in any order. The parenthesized syntax was added in PostgreSQL 11; the unparenthesized syntax is deprecated.</source>
          <target state="translated">オプションリストが括弧で囲まれている場合、オプションは任意の順序で記述することができます。括弧付き構文はPostgreSQL 11で追加されました。</target>
        </trans-unit>
        <trans-unit id="abee5df8a890efa75529bd092cf02d64e5f74e41" translate="yes" xml:space="preserve">
          <source>When the option list is surrounded by parentheses, the options can be written in any order. Without parentheses, options must be specified in exactly the order shown above. The parenthesized syntax was added in PostgreSQL 9.0; the unparenthesized syntax is deprecated.</source>
          <target state="translated">オプションリストが括弧で囲まれている場合、オプションはどのような順序でも記述できます。括弧がない場合、オプションは上記の順序で正確に指定しなければなりません。括弧付き構文はPostgreSQL 9.0で追加されました。</target>
        </trans-unit>
        <trans-unit id="0e9dc738f4097cde58c9e8bf1cce2f13a3e0faff" translate="yes" xml:space="preserve">
          <source>When the query executor is running a statement using &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt;, individual operations are timed as well as showing a summary. The overhead of your system can be checked by counting rows with the psql program:</source>
          <target state="translated">クエリエグゼキュータが &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; を使用してステートメントを実行しているとき、個々の操作は時間を計られるとともに要約を表示します。システムのオーバーヘッドは、psqlプログラムで行を数えることで確認できます。</target>
        </trans-unit>
        <trans-unit id="a4efc71382094156bb1e14ebb8922c4bbfee26e8" translate="yes" xml:space="preserve">
          <source>When the query involves more than two relations, the final result must be built up by a tree of join steps, each with two inputs. The planner examines different possible join sequences to find the cheapest one.</source>
          <target state="translated">クエリに2つ以上の関係が含まれる場合、最終的な結果は、2つの入力を持つ結合ステップのツリーによって構築されなければなりません。プランナーは、さまざまな可能性のある結合シーケンスを調べて、最も安価なものを見つけます。</target>
        </trans-unit>
        <trans-unit id="f91c3e21cf6bd9480dad3eeeece86758f55a90e3" translate="yes" xml:space="preserve">
          <source>When the query involves outer joins, the planner has less freedom than it does for plain (inner) joins. For example, consider:</source>
          <target state="translated">クエリが外側の結合を含む場合、プランナは単純な(内側の)結合よりも自由度が低くなります。例えば、次のように考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="53d57a11c26095ca3bee53a6ad82668d9cd1b948" translate="yes" xml:space="preserve">
          <source>When the replication client of pg_receivewal is configured on the server as a synchronous standby, then using a replication slot will report the flush position to the server, but only when a WAL file is closed. Therefore, that configuration will cause transactions on the primary to wait for a long time and effectively not work satisfactorily. The option &lt;code&gt;--synchronous&lt;/code&gt; (see below) must be specified in addition to make this work correctly.</source>
          <target state="translated">pg_receivewalのレプリケーションクライアントがサーバー上で同期スタンバイとして構成されている場合、レプリケーションスロットを使用するとフラッシュ位置がサーバーに報告されますが、これはWALファイルが閉じられている場合のみです。したがって、その構成では、プライマリのトランザクションが長時間待機し、効果的に十分に機能しなくなります。これを正しく機能させるには、オプション &lt;code&gt;--synchronous&lt;/code&gt; （下記を参照）を指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="6e97e877617ee50758f9c1ed0038c82401b37ff4" translate="yes" xml:space="preserve">
          <source>When the server finds an entry in the &lt;code&gt;pg_pltemplate&lt;/code&gt; catalog for the given language name, it will use the catalog data even if the command includes language parameters. This behavior simplifies loading of old dump files, which are likely to contain out-of-date information about language support functions.</source>
          <target state="translated">サーバーは、指定された言語名の &lt;code&gt;pg_pltemplate&lt;/code&gt; カタログでエントリを見つけると、コマンドに言語パラメーターが含まれていても、カタログデータを使用します。この動作により、言語サポート関数に関する古い情報が含まれている可能性が高い古いダンプファイルの読み込みが簡略化されます。</target>
        </trans-unit>
        <trans-unit id="826ce26725107a5df987e11185041fdbac70af26" translate="yes" xml:space="preserve">
          <source>When the standby is started and &lt;code&gt;primary_conninfo&lt;/code&gt; is set correctly, the standby will connect to the primary after replaying all WAL files available in the archive. If the connection is established successfully, you will see a &lt;code&gt;walreceiver&lt;/code&gt; in the standby, and a corresponding &lt;code&gt;walsender&lt;/code&gt; process in the primary.</source>
          <target state="translated">When the standby is started and &lt;code&gt;primary_conninfo&lt;/code&gt; is set correctly, the standby will connect to the primary after replaying all WAL files available in the archive. If the connection is established successfully, you will see a &lt;code&gt;walreceiver&lt;/code&gt; in the standby, and a corresponding &lt;code&gt;walsender&lt;/code&gt; process in the primary.</target>
        </trans-unit>
        <trans-unit id="5acf91c2009ea693cf720914c5dcc7ec25263a3f" translate="yes" xml:space="preserve">
          <source>When the standby is started and &lt;code&gt;primary_conninfo&lt;/code&gt; is set correctly, the standby will connect to the primary after replaying all WAL files available in the archive. If the connection is established successfully, you will see a walreceiver process in the standby, and a corresponding walsender process in the primary.</source>
          <target state="translated">スタンバイが開始され、 &lt;code&gt;primary_conninfo&lt;/code&gt; が正しく設定されている場合、スタンバイは、アーカイブで使用可能なすべてのWALファイルを再生した後、プライマリに接続します。接続が正常に確立されると、スタンバイにwalreceiverプロセス、プライマリに対応するwalsenderプロセスが表示されます。</target>
        </trans-unit>
        <trans-unit id="eedf68c3267fbf09aabeff8e3149a2fc6e02e4a5" translate="yes" xml:space="preserve">
          <source>When the system is forced to combine multiple page-level predicate locks into a single relation-level predicate lock because the predicate lock table is short of memory, an increase in the rate of serialization failures may occur. You can avoid this by increasing &lt;a href=&quot;runtime-config-locks#GUC-MAX-PRED-LOCKS-PER-TRANSACTION&quot;&gt;max_pred_locks_per_transaction&lt;/a&gt;, &lt;a href=&quot;runtime-config-locks#GUC-MAX-PRED-LOCKS-PER-RELATION&quot;&gt;max_pred_locks_per_relation&lt;/a&gt;, and/or &lt;a href=&quot;runtime-config-locks#GUC-MAX-PRED-LOCKS-PER-PAGE&quot;&gt;max_pred_locks_per_page&lt;/a&gt;.</source>
          <target state="translated">述語ロックテーブルのメモリが不足しているために、システムが複数のページレベルの述語ロックを単一のリレーションレベルの述語ロックに結合するように強制されると、シリアル化の失敗率が増加する可能性があります。&lt;a href=&quot;runtime-config-locks#GUC-MAX-PRED-LOCKS-PER-TRANSACTION&quot;&gt;max_pred_locks_per_transaction&lt;/a&gt;、&lt;a href=&quot;runtime-config-locks#GUC-MAX-PRED-LOCKS-PER-RELATION&quot;&gt;max_pred_locks_per_relation&lt;/a&gt;、または&lt;a href=&quot;runtime-config-locks#GUC-MAX-PRED-LOCKS-PER-PAGE&quot;&gt;max_pred_locks_per_pageを&lt;/a&gt;増やすことで、これを回避できます。</target>
        </trans-unit>
        <trans-unit id="1e5d69b735badff5a43514c3f20c29f9fa27a5a4" translate="yes" xml:space="preserve">
          <source>When the target server is started for the first time after running pg_rewind, it will go into recovery mode and replay all WAL generated in the source server after the point of divergence. If some of the WAL was no longer available in the source server when pg_rewind was run, and therefore could not be copied by the pg_rewind session, it must be made available when the target server is started. This can be done by creating a &lt;code&gt;recovery.signal&lt;/code&gt; file in the target data directory and configuring suitable &lt;a href=&quot;runtime-config-wal#GUC-RESTORE-COMMAND&quot;&gt;restore_command&lt;/a&gt; in &lt;code&gt;postgresql.conf&lt;/code&gt;.</source>
          <target state="translated">ターゲットサーバーがpg_rewindの実行後に初めて起動されると、回復モードになり、分岐点の後でソースサーバーで生成されたすべてのWALを再生します。 pg_rewindの実行時にソースサーバーでWALの一部が利用できなくなったため、pg_rewindセッションでWALをコピーできなかった場合は、ターゲットサーバーの起動時に利用可能にする必要があります。これは、作成することによって行うことができます &lt;code&gt;recovery.signal&lt;/code&gt; 対象のデータディレクトリ内のファイルを、適切な設定&lt;a href=&quot;runtime-config-wal#GUC-RESTORE-COMMAND&quot;&gt;を行うrestore_commandを&lt;/a&gt;して &lt;code&gt;postgresql.conf&lt;/code&gt; の。</target>
        </trans-unit>
        <trans-unit id="46d8ca3256e28b3a76b80a636c768a65a62af8f1" translate="yes" xml:space="preserve">
          <source>When the token is a number or number field:</source>
          <target state="translated">トークンが数字または数字フィールドの場合。</target>
        </trans-unit>
        <trans-unit id="13de437cb552624377cc1efe8012608874203a3b" translate="yes" xml:space="preserve">
          <source>When there are &lt;code&gt;OUT&lt;/code&gt; or &lt;code&gt;INOUT&lt;/code&gt; parameters, the &lt;code&gt;RETURNS&lt;/code&gt; clause can be omitted. If present, it must agree with the result type implied by the output parameters: &lt;code&gt;RECORD&lt;/code&gt; if there are multiple output parameters, or the same type as the single output parameter.</source>
          <target state="translated">ある場合 &lt;code&gt;OUT&lt;/code&gt; または &lt;code&gt;INOUT&lt;/code&gt; パラメータ、 &lt;code&gt;RETURNS&lt;/code&gt; の句は省略することができます。存在する場合は、出力パラメーターによって暗黙的に示される結果タイプと一致する必要があります。複数の出力パラメーターがある場合は &lt;code&gt;RECORD&lt;/code&gt; 、または単一の出力パラメーターと同じタイプです。</target>
        </trans-unit>
        <trans-unit id="3cbc021b4d99bd0fb8948c27e6c55ec68fedb0d0" translate="yes" xml:space="preserve">
          <source>When there are multiple queries in the &lt;code&gt;WITH&lt;/code&gt; clause, &lt;code&gt;RECURSIVE&lt;/code&gt; should be written only once, immediately after &lt;code&gt;WITH&lt;/code&gt;. It applies to all queries in the &lt;code&gt;WITH&lt;/code&gt; clause, though it has no effect on queries that do not use recursion or forward references.</source>
          <target state="translated">When there are multiple queries in the &lt;code&gt;WITH&lt;/code&gt; clause, &lt;code&gt;RECURSIVE&lt;/code&gt; should be written only once, immediately after &lt;code&gt;WITH&lt;/code&gt; . It applies to all queries in the &lt;code&gt;WITH&lt;/code&gt; clause, though it has no effect on queries that do not use recursion or forward references.</target>
        </trans-unit>
        <trans-unit id="086da7e4c8252cf99eea2a26d212bfca20a89638" translate="yes" xml:space="preserve">
          <source>When there are no &lt;code&gt;GIN_MAYBE&lt;/code&gt; values in the &lt;code&gt;check&lt;/code&gt; vector, a &lt;code&gt;GIN_MAYBE&lt;/code&gt; return value is the equivalent of setting the &lt;code&gt;recheck&lt;/code&gt; flag in the Boolean &lt;code&gt;consistent&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;check&lt;/code&gt; ベクトルに &lt;code&gt;GIN_MAYBE&lt;/code&gt; 値がない場合、 &lt;code&gt;GIN_MAYBE&lt;/code&gt; の戻り値は、ブール型 &lt;code&gt;consistent&lt;/code&gt; 関数で &lt;code&gt;recheck&lt;/code&gt; フラグを設定することと同じです。</target>
        </trans-unit>
        <trans-unit id="6d0ae32f2046467b15848b335dcbaffbcaf195f8" translate="yes" xml:space="preserve">
          <source>When this command is used, the preceding SQL query is expected to return one row, the columns of which are stored into variables named after column names, and prefixed with &lt;code&gt;prefix&lt;/code&gt; if provided.</source>
          <target state="translated">このコマンドを使用すると、前述のSQLクエリは1行を返すことが期待され、その列は列名にちなんで名付けられた変数に格納され、 &lt;code&gt;prefix&lt;/code&gt; が提供されている場合はプレフィックスが付けられます。</target>
        </trans-unit>
        <trans-unit id="d01a63b618f24f934c421a450096ebe3b2d3fb7a" translate="yes" xml:space="preserve">
          <source>When this feature is enabled, freed space at the end of a relation cannot be released to the operating system, since that could remove information needed to detect the &amp;ldquo;snapshot too old&amp;rdquo; condition. All space allocated to a relation remains associated with that relation for reuse only within that relation unless explicitly freed (for example, with &lt;code&gt;VACUUM FULL&lt;/code&gt;).</source>
          <target state="translated">この機能を有効にすると、「スナップショットが古すぎる」状態を検出するために必要な情報が削除される可能性があるため、関係の最後にある空き領域をオペレーティングシステムに解放できません。リレーションに割り当てられたすべてのスペースは、明示的に解放されない限り（たとえば、 &lt;code&gt;VACUUM FULL&lt;/code&gt; で）、リレーション内でのみ再利用できるように関連付けられたままです。</target>
        </trans-unit>
        <trans-unit id="edeb5910da7722ed71fd344bba96eef32a3f6641" translate="yes" xml:space="preserve">
          <source>When this happens, the range will be summarized normally during the next regular vacuum of the table.</source>
          <target state="translated">そうなると、次のテーブルの定期的なバキュームの間に、その範囲が普通にまとめられてしまいます。</target>
        </trans-unit>
        <trans-unit id="e4570af0f67cc29537d90c659afba5db93e8b7f0" translate="yes" xml:space="preserve">
          <source>When this is enabled, the backup will start by enumerating the size of the entire database, and then go back and send the actual contents. This may make the backup take slightly longer, and in particular it will take longer before the first data is sent.</source>
          <target state="translated">これを有効にすると、バックアップはデータベース全体のサイズを列挙することから始まり、その後、実際の内容に戻って送信されます。これにより、バックアップに若干の時間がかかる場合があり、特に最初のデータが送信されるまでに時間がかかります。</target>
        </trans-unit>
        <trans-unit id="ba484c59ded97840ba63ed48a33d5adcad782f3b" translate="yes" xml:space="preserve">
          <source>When this option is used, PostgreSQL will build the index without taking any locks that prevent concurrent inserts, updates, or deletes on the table; whereas a standard index build locks out writes (but not reads) on the table until it's done. There are several caveats to be aware of when using this option &amp;mdash; see &lt;a href=&quot;sql-createindex#SQL-CREATEINDEX-CONCURRENTLY&quot;&gt;Building Indexes Concurrently&lt;/a&gt; below.</source>
          <target state="translated">When this option is used, PostgreSQL will build the index without taking any locks that prevent concurrent inserts, updates, or deletes on the table; whereas a standard index build locks out writes (but not reads) on the table until it's done. There are several caveats to be aware of when using this option &amp;mdash; see &lt;a href=&quot;sql-createindex#SQL-CREATEINDEX-CONCURRENTLY&quot;&gt;Building Indexes Concurrently&lt;/a&gt; below.</target>
        </trans-unit>
        <trans-unit id="28c1776ab93887297f059584c258d507675ecdfe" translate="yes" xml:space="preserve">
          <source>When this option is used, PostgreSQL will build the index without taking any locks that prevent concurrent inserts, updates, or deletes on the table; whereas a standard index build locks out writes (but not reads) on the table until it's done. There are several caveats to be aware of when using this option &amp;mdash; see &lt;a href=&quot;sql-createindex#SQL-CREATEINDEX-CONCURRENTLY&quot;&gt;Building Indexes Concurrently&lt;/a&gt;.</source>
          <target state="translated">このオプションを使用すると、PostgreSQLは、テーブルの同時挿入、更新、または削除を防止するロックを取得せずにインデックスを構築します。一方、標準のインデックスビルドは、完了するまでテーブルへの書き込みをロックします（読み取りはロックしません）。このオプションを使用する場合は、いくつかの注意点があります。「&lt;a href=&quot;sql-createindex#SQL-CREATEINDEX-CONCURRENTLY&quot;&gt;インデックスの同時作成&lt;/a&gt;」を参照してください。</target>
        </trans-unit>
        <trans-unit id="9cfbc756ec0e3884dc8a6bdc957bf776447f05d6" translate="yes" xml:space="preserve">
          <source>When this option is used, PostgreSQL will rebuild the index without taking any locks that prevent concurrent inserts, updates, or deletes on the table; whereas a standard index rebuild locks out writes (but not reads) on the table until it's done. There are several caveats to be aware of when using this option &amp;mdash; see &lt;a href=&quot;sql-reindex#SQL-REINDEX-CONCURRENTLY&quot;&gt;Rebuilding Indexes Concurrently&lt;/a&gt; below.</source>
          <target state="translated">When this option is used, PostgreSQL will rebuild the index without taking any locks that prevent concurrent inserts, updates, or deletes on the table; whereas a standard index rebuild locks out writes (but not reads) on the table until it's done. There are several caveats to be aware of when using this option &amp;mdash; see &lt;a href=&quot;sql-reindex#SQL-REINDEX-CONCURRENTLY&quot;&gt;Rebuilding Indexes Concurrently&lt;/a&gt; below.</target>
        </trans-unit>
        <trans-unit id="469c5b3c25ebc28298d0a68f767fa4e6b9232f83" translate="yes" xml:space="preserve">
          <source>When this option is used, PostgreSQL will rebuild the index without taking any locks that prevent concurrent inserts, updates, or deletes on the table; whereas a standard index rebuild locks out writes (but not reads) on the table until it's done. There are several caveats to be aware of when using this option &amp;mdash; see &lt;a href=&quot;sql-reindex#SQL-REINDEX-CONCURRENTLY&quot;&gt;Rebuilding Indexes Concurrently&lt;/a&gt;.</source>
          <target state="translated">このオプションを使用すると、PostgreSQLは、テーブルの同時挿入、更新、または削除を防止するロックを取得せずにインデックスを再構築します。一方、標準のインデックスの再構築では、完了するまでテーブルへの書き込みがロックされます（読み取りはロックされません）。このオプションを使用する場合は、いくつかの注意点があります。「&lt;a href=&quot;sql-reindex#SQL-REINDEX-CONCURRENTLY&quot;&gt;インデックスの再構築を同時に行う&lt;/a&gt;」を参照してください。</target>
        </trans-unit>
        <trans-unit id="8c3757e4ca86742c07911d6404be9ee33ce2c815" translate="yes" xml:space="preserve">
          <source>When this option is used, psql will connect to the database &lt;code&gt;postgres&lt;/code&gt;, unless a different database is named on the command line (option &lt;code&gt;-d&lt;/code&gt; or non-option argument, possibly via a service entry, but not via an environment variable).</source>
          <target state="translated">このオプションを使用すると、コマンドラインで別のデータベースが指定されていない限り、psqlはデータベース &lt;code&gt;postgres&lt;/code&gt; に接続します（オプション &lt;code&gt;-d&lt;/code&gt; または非オプション引数、おそらくサービスエントリを介して、ただし環境変数を介して）。</target>
        </trans-unit>
        <trans-unit id="2bc222201723d0a9f83d166df5e42c7cf99836b6" translate="yes" xml:space="preserve">
          <source>When this option is used, the database named with &lt;code&gt;-d&lt;/code&gt; is used only to issue the initial &lt;code&gt;DROP DATABASE&lt;/code&gt; and &lt;code&gt;CREATE DATABASE&lt;/code&gt; commands. All data is restored into the database name that appears in the archive.</source>
          <target state="translated">このオプションを使用すると、 &lt;code&gt;-d&lt;/code&gt; で指定されたデータベースは、最初の &lt;code&gt;DROP DATABASE&lt;/code&gt; &lt;code&gt;CREATE DATABASE&lt;/code&gt; コマンドとCREATE DATABASEコマンドを発行するためにのみ使用されます。すべてのデータは、アーカイブに表示されるデータベース名に復元されます。</target>
        </trans-unit>
        <trans-unit id="3390cee1b88ac1d254da2a22a816a53421d2e870" translate="yes" xml:space="preserve">
          <source>When this parameter allows it for a particular table, the planner compares query conditions with the table's &lt;code&gt;CHECK&lt;/code&gt; constraints, and omits scanning tables for which the conditions contradict the constraints. For example:</source>
          <target state="translated">このパラメーターが特定のテーブルに対して許可する場合、プランナーはクエリ条件をテーブルの &lt;code&gt;CHECK&lt;/code&gt; 制約と比較し、条件が制約と矛盾するスキャンテーブルを省略します。例えば：</target>
        </trans-unit>
        <trans-unit id="70be33b4f92d88452bcc535d531cf8223b72afbc" translate="yes" xml:space="preserve">
          <source>When this parameter is &lt;code&gt;on&lt;/code&gt;, the PostgreSQL server compresses a full page image written to WAL when &lt;a href=&quot;runtime-config-wal#GUC-FULL-PAGE-WRITES&quot;&gt;full_page_writes&lt;/a&gt; is on or during a base backup. A compressed page image will be decompressed during WAL replay. The default value is &lt;code&gt;off&lt;/code&gt;. Only superusers can change this setting.</source>
          <target state="translated">このパラメーターが &lt;code&gt;on&lt;/code&gt; の場合、PostgreSQLサーバーは、&lt;a href=&quot;runtime-config-wal#GUC-FULL-PAGE-WRITES&quot;&gt;full_page_writes&lt;/a&gt;がonまたはベースバックアップ中に、WALに書き込まれたフルページイメージを圧縮します。圧縮されたページ画像は、WAL再生中に解凍されます。デフォルト値は &lt;code&gt;off&lt;/code&gt; です。この設定を変更できるのはスーパーユーザーだけです。</target>
        </trans-unit>
        <trans-unit id="095a2e6ccc43e3049250993f0343788b4a6a861a" translate="yes" xml:space="preserve">
          <source>When this parameter is &lt;code&gt;on&lt;/code&gt;, the PostgreSQL server writes the entire content of each disk page to WAL during the first modification of that page after a checkpoint, even for non-critical modifications of so-called hint bits.</source>
          <target state="translated">このパラメーターが &lt;code&gt;on&lt;/code&gt; の場合、PostgreSQLサーバーは、いわゆるヒントビットの重要でない変更であっても、チェックポイント後のページの最初の変更中に各ディスクページのコンテンツ全体をWALに書き込みます。</target>
        </trans-unit>
        <trans-unit id="ff47b09b0654ad59cedec7d15e17e9fba55f3e2b" translate="yes" xml:space="preserve">
          <source>When this parameter is on, &lt;code&gt;sepgsql&lt;/code&gt; functions in permissive mode, even if SELinux in general is working in enforcing mode. This parameter is primarily useful for testing purposes.</source>
          <target state="translated">このパラメータがオンの場合、一般にSELinuxが強制モードで動作している場合でも、 &lt;code&gt;sepgsql&lt;/code&gt; はパーミッシブモードで機能します。このパラメーターは、主にテスト目的で役立ちます。</target>
        </trans-unit>
        <trans-unit id="b664e492ac1b6b5bd7bf06b57282c7f341a60102" translate="yes" xml:space="preserve">
          <source>When this parameter is on, per-plan-node timing occurs for all statements executed, whether or not they run long enough to actually get logged. This can have an extremely negative impact on performance. Turning off &lt;code&gt;auto_explain.log_timing&lt;/code&gt; ameliorates the performance cost, at the price of obtaining less information.</source>
          <target state="translated">このパラメーターがオンの場合、実際にログが記録されるのに十分長く実行されているかどうかに関係なく、実行されたすべてのステートメントに対して計画ノードごとのタイミングが発生します。これは、パフォーマンスに非常に悪影響を及ぼす可能性があります。 &lt;code&gt;auto_explain.log_timing&lt;/code&gt; をオフにすると、取得する情報が少なくなる代わりに、パフォーマンスコストが改善されます。</target>
        </trans-unit>
        <trans-unit id="d4e134d46721d701b088fe76d2d53da371f96514" translate="yes" xml:space="preserve">
          <source>When this parameter is on, the PostgreSQL server writes the entire content of each disk page to WAL during the first modification of that page after a checkpoint. This is needed because a page write that is in process during an operating system crash might be only partially completed, leading to an on-disk page that contains a mix of old and new data. The row-level change data normally stored in WAL will not be enough to completely restore such a page during post-crash recovery. Storing the full page image guarantees that the page can be correctly restored, but at the price of increasing the amount of data that must be written to WAL. (Because WAL replay always starts from a checkpoint, it is sufficient to do this during the first change of each page after a checkpoint. Therefore, one way to reduce the cost of full-page writes is to increase the checkpoint interval parameters.)</source>
          <target state="translated">このパラメータがオンの場合、PostgreSQLサーバはチェックポイント後のページの最初の変更時に、各ディスクページの内容全体をWALに書き込みます。これは、オペレーティングシステムのクラッシュ時に処理中のページ書き込みが部分的にしか完了せず、古いデータと新しいデータが混在したディスク上のページが作成される可能性があるために必要となります。通常WALに格納されている行レベルの変更データだけでは、クラッシュ後の復旧時にそのようなページを完全に復元するには十分ではありません。完全なページ イメージを保存することで、ページが正しく復元されることが保証されますが、その代償として、WAL に書き込む必要のあるデータ量が増加します。(WALの再生は常にチェックポイントから始まるので、チェックポイント後の各ページの最初の変更時にこれを行えば十分である。したがって、フルページ書き込みのコストを削減する一つの方法は、チェックポイント間隔パラメータを増加させることである)。</target>
        </trans-unit>
        <trans-unit id="5a1902b314fccc53fa419bb9d1c5d0a54674b4cd" translate="yes" xml:space="preserve">
          <source>When this variable is set to &lt;code&gt;on&lt;/code&gt; and a backslash command queries the database, the query is first shown. This feature helps you to study PostgreSQL internals and provide similar functionality in your own programs. (To select this behavior on program start-up, use the switch &lt;code&gt;-E&lt;/code&gt;.) If you set this variable to the value &lt;code&gt;noexec&lt;/code&gt;, the queries are just shown but are not actually sent to the server and executed. The default value is &lt;code&gt;off&lt;/code&gt;.</source>
          <target state="translated">この変数が &lt;code&gt;on&lt;/code&gt; に設定されており、バックスラッシュコマンドがデータベースにクエリを実行すると、クエリが最初に表示されます。この機能は、PostgreSQLの内部を調べ、独自のプログラムで同様の機能を提供するのに役立ちます。（プログラムの起動時にこの動作を選択するには、スイッチ &lt;code&gt;-E&lt;/code&gt; を使用します。）この変数を値 &lt;code&gt;noexec&lt;/code&gt; に設定すると、クエリは表示されるだけですが、実際にはサーバーに送信されず、実行されません。デフォルト値は &lt;code&gt;off&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="0a31ece5bfbb183043ca04edf566185c4d24f24d" translate="yes" xml:space="preserve">
          <source>When throttling is active, the transaction latency reported at the end of the run is calculated from the scheduled start times, so it includes the time each transaction had to wait for the previous transaction to finish. The wait time is called the schedule lag time, and its average and maximum are also reported separately. The transaction latency with respect to the actual transaction start time, i.e. the time spent executing the transaction in the database, can be computed by subtracting the schedule lag time from the reported latency.</source>
          <target state="translated">スロットリングがアクティブな場合、ランの最後に報告されるトランザクションの待ち時間は、スケジュールされた開始時間から計算されるので、各トランザクションが前のトランザクションが終了するのを待たなければならなかった時間が含まれます。この待ち時間はスケジュール遅延時間と呼ばれ、その平均値と最大値も別々に報告される。実際のトランザクション開始時間、すなわちデータベースでのトランザクションの実行に費やされた時間に関す るトランザクション・レイテンシは、報告されたレイテンシからスケジュール・ラグ時間を差し引くことで計算できる。</target>
        </trans-unit>
        <trans-unit id="bf9d744865a36adaaaa98eb0ce0a8d0e8d495ea9" translate="yes" xml:space="preserve">
          <source>When throttling is active, the transaction latency reported at the end of the run is calculated from the scheduled start times, so it includes the time each transaction had to wait for the previous transaction to finish. The wait time is called the schedule lag time, and its average and maximum are also reported separately. The transaction latency with respect to the actual transaction start time, i.e., the time spent executing the transaction in the database, can be computed by subtracting the schedule lag time from the reported latency.</source>
          <target state="translated">スロットリングがアクティブな場合、ランの最後に報告されるトランザクションの待ち時間は、スケジュールされた開始時間から計算されるので、各トランザクションが前のトランザクションが終了するのを待たなければならなかった時間が含まれます。この待ち時間はスケジュール遅延時間と呼ばれ、その平均値と最大値も別々に報告される。実際のトランザクション開始時間、すなわちデータベース内のトランザクションの実行に費やされた時間に関す るトランザクション・レイテンシは、報告されたレイテンシからスケジュール・ラグ時間を差し引くことで計算できる。</target>
        </trans-unit>
        <trans-unit id="62a5ce62fea33e48d7ca4dcdb6fc1d49b58833f9" translate="yes" xml:space="preserve">
          <source>When throttling is used (&lt;code&gt;--rate=...&lt;/code&gt;), transactions that lag behind schedule by more than &lt;code&gt;limit&lt;/code&gt; ms, and thus have no hope of meeting the latency limit, are not sent to the server at all. They are counted and reported separately as &lt;em&gt;skipped&lt;/em&gt;.</source>
          <target state="translated">スロットルが使用されている場合（ &lt;code&gt;--rate=...&lt;/code&gt; ）、 &lt;code&gt;limit&lt;/code&gt; msを超えてスケ​​ジュールより遅れ、したがってレイテンシ制限を満たす見込みがないトランザクションは、サーバーにまったく送信されません。&lt;em&gt;スキップ&lt;/em&gt;されたものとしてカウントされ、個別に報告されます。</target>
        </trans-unit>
        <trans-unit id="b0431d629c5fa2195a09522dc9eddb52b7d7ef5d" translate="yes" xml:space="preserve">
          <source>When to JIT?</source>
          <target state="translated">JITをするタイミングは?</target>
        </trans-unit>
        <trans-unit id="c212a8c30b6a166bd84fdfc048fb956853e7ba65" translate="yes" xml:space="preserve">
          <source>When two arrays with an equal number of dimensions are concatenated, the result retains the lower bound subscript of the left-hand operand's outer dimension. The result is an array comprising every element of the left-hand operand followed by every element of the right-hand operand. For example:</source>
          <target state="translated">同じ次元数の2つの配列が連結されている場合,結果は左辺のオペランドの外側の次元の下界の添え字を保持します.結果は,左辺のオペランドの各要素の後に右辺のオペランドの各要素が続く配列となります.例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="75c057cb6b39ec5ed6fcfc1f9fbef6e3ffe333d8" translate="yes" xml:space="preserve">
          <source>When two or more &lt;a href=&quot;glossary#GLOSSARY-DATABASE&quot;&gt;databases&lt;/a&gt; are linked via &lt;a href=&quot;glossary#GLOSSARY-REPLICATION&quot;&gt;replication&lt;/a&gt;, the &lt;a href=&quot;glossary#GLOSSARY-SERVER&quot;&gt;server&lt;/a&gt; that is considered the authoritative source of information is called the &lt;em&gt;primary&lt;/em&gt;, also known as a &lt;em&gt;master&lt;/em&gt;.</source>
          <target state="translated">When two or more &lt;a href=&quot;glossary#GLOSSARY-DATABASE&quot;&gt;databases&lt;/a&gt; are linked via &lt;a href=&quot;glossary#GLOSSARY-REPLICATION&quot;&gt;replication&lt;/a&gt;, the &lt;a href=&quot;glossary#GLOSSARY-SERVER&quot;&gt;server&lt;/a&gt; that is considered the authoritative source of information is called the &lt;em&gt;primary&lt;/em&gt;, also known as a &lt;em&gt;master&lt;/em&gt;.</target>
        </trans-unit>
        <trans-unit id="a09c4eb9b4b598594720766db600d02893739065" translate="yes" xml:space="preserve">
          <source>When used as a standalone program all WAL files logically preceding the &lt;code&gt;oldestkeptwalfile&lt;/code&gt; will be removed from &lt;code&gt;archivelocation&lt;/code&gt;. In this mode, if you specify a &lt;code&gt;.partial&lt;/code&gt; or &lt;code&gt;.backup&lt;/code&gt; file name, then only the file prefix will be used as the &lt;code&gt;oldestkeptwalfile&lt;/code&gt;. This treatment of &lt;code&gt;.backup&lt;/code&gt; file name allows you to remove all WAL files archived prior to a specific base backup without error. For example, the following example will remove all files older than WAL file name &lt;code&gt;000000010000003700000010&lt;/code&gt;:</source>
          <target state="translated">スタンドアロンプ​​ログラムとして使用すると、論理的に &lt;code&gt;oldestkeptwalfile&lt;/code&gt; の前にあるすべてのWALファイルが &lt;code&gt;archivelocation&lt;/code&gt; から削除されます。このモードでは、 &lt;code&gt;.partial&lt;/code&gt; または &lt;code&gt;.backup&lt;/code&gt; ファイル名を指定すると、ファイルのプレフィックスのみが &lt;code&gt;oldestkeptwalfile&lt;/code&gt; として使用されます。この &lt;code&gt;.backup&lt;/code&gt; ファイル名の扱いにより、特定のベースバックアップの前にアーカイブされたすべてのWALファイルをエラーなしで削除できます。たとえば、次の例では、WALファイル名 &lt;code&gt;000000010000003700000010&lt;/code&gt; より古いファイルをすべて削除します。</target>
        </trans-unit>
        <trans-unit id="54ce62d903f7c6555c73f41594c6b595d712ec4b" translate="yes" xml:space="preserve">
          <source>When used in exclusive mode, this function writes a backup label file (&lt;code&gt;backup_label&lt;/code&gt;) and, if there are any links in the &lt;code&gt;pg_tblspc/&lt;/code&gt; directory, a tablespace map file (&lt;code&gt;tablespace_map&lt;/code&gt;) into the database cluster's data directory, then performs a checkpoint, and then returns the backup's starting write-ahead log location. (The user can ignore this result value, but it is provided in case it is useful.) When used in non-exclusive mode, the contents of these files are instead returned by the &lt;code&gt;pg_stop_backup&lt;/code&gt; function, and should be copied to the backup area by the user.</source>
          <target state="translated">When used in exclusive mode, this function writes a backup label file ( &lt;code&gt;backup_label&lt;/code&gt; ) and, if there are any links in the &lt;code&gt;pg_tblspc/&lt;/code&gt; directory, a tablespace map file ( &lt;code&gt;tablespace_map&lt;/code&gt; ) into the database cluster's data directory, then performs a checkpoint, and then returns the backup's starting write-ahead log location. (The user can ignore this result value, but it is provided in case it is useful.) When used in non-exclusive mode, the contents of these files are instead returned by the &lt;code&gt;pg_stop_backup&lt;/code&gt; function, and should be copied to the backup area by the user.</target>
        </trans-unit>
        <trans-unit id="b4f92bbabc1b26d77780494bcd623901f19d77be" translate="yes" xml:space="preserve">
          <source>When used with one of the archive file formats and combined with pg_restore, pg_dump provides a flexible archival and transfer mechanism. pg_dump can be used to backup an entire database, then pg_restore can be used to examine the archive and/or select which parts of the database are to be restored. The most flexible output file formats are the &amp;ldquo;custom&amp;rdquo; format (&lt;code&gt;-Fc&lt;/code&gt;) and the &amp;ldquo;directory&amp;rdquo; format (&lt;code&gt;-Fd&lt;/code&gt;). They allow for selection and reordering of all archived items, support parallel restoration, and are compressed by default. The &amp;ldquo;directory&amp;rdquo; format is the only format that supports parallel dumps.</source>
          <target state="translated">いずれかのアーカイブファイル形式で使用し、pg_restoreと組み合わせると、pg_dumpは柔軟なアーカイブおよび転送メカニズムを提供します。 pg_dumpを使用してデータベース全体をバックアップし、次にpg_restoreを使用してアーカイブを検査したり、データベースのどの部分を復元するかを選択したりできます。最も柔軟な出力ファイル形式は、「カスタム」形式（ &lt;code&gt;-Fc&lt;/code&gt; ）と「ディレクトリ」形式（ &lt;code&gt;-Fd&lt;/code&gt; ）です。それらはすべてのアーカイブ済みアイテムの選択と並べ替えを可能にし、並行復元をサポートし、デフォルトで圧縮されます。 「ディレクトリ」形式は、並列ダンプをサポートする唯一の形式です。</target>
        </trans-unit>
        <trans-unit id="7fe14a6b317961785cf4d152bc27d49064bcda5a" translate="yes" xml:space="preserve">
          <source>When used within &lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-CLEANUP-COMMAND&quot;&gt;archive_cleanup_command&lt;/a&gt;, all WAL files logically preceding the value of the &lt;code&gt;%r&lt;/code&gt; argument will be removed from &lt;code&gt;archivelocation&lt;/code&gt;. This minimizes the number of files that need to be retained, while preserving crash-restart capability. Use of this parameter is appropriate if the &lt;code&gt;archivelocation&lt;/code&gt; is a transient staging area for this particular standby server, but &lt;em&gt;not&lt;/em&gt; when the &lt;code&gt;archivelocation&lt;/code&gt; is intended as a long-term WAL archive area, or when multiple standby servers are recovering from the same archive location.</source>
          <target state="translated">&lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-CLEANUP-COMMAND&quot;&gt;archive_cleanup_command&lt;/a&gt;内で使用すると、論理的に &lt;code&gt;%r&lt;/code&gt; 引数の値の前にあるすべてのWALファイルが &lt;code&gt;archivelocation&lt;/code&gt; から削除されます。これにより、クラッシュの再起動機能を維持しながら、保持する必要のあるファイルの数を最小限に抑えることができます。場合は、このパラメータを使用することは適切で &lt;code&gt;archivelocation&lt;/code&gt; 、この特定のスタンバイ・サーバのための過渡的なステージング領域ですが、&lt;em&gt;ない&lt;/em&gt;とき &lt;code&gt;archivelocation&lt;/code&gt; 長期WALアーカイブ領域として意図され、または複数のスタンバイサーバが同じアーカイブ場所から回復しているとき。</target>
        </trans-unit>
        <trans-unit id="7051b09dcb61945ea4e0d3beb1e52e65c9014732" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;COPY FROM&lt;/code&gt;, any data item that matches this string will be stored as a null value, so you should make sure that you use the same string as you used with &lt;code&gt;COPY TO&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;COPY FROM&lt;/code&gt; を使用する場合、この文字列に一致するデータ項目はすべてnull値として格納されるため、 &lt;code&gt;COPY TO&lt;/code&gt; で使用したのと同じ文字列を使用するようにしてください。</target>
        </trans-unit>
        <trans-unit id="f8b5d7a27b46e73dc32c1b851c7dfef0ad7fe8a0" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;LIMIT&lt;/code&gt;, it is a good idea to use an &lt;code&gt;ORDER BY&lt;/code&gt; clause that constrains the result rows into a unique order. Otherwise you will get an unpredictable subset of the query's rows &amp;mdash; you might be asking for the tenth through twentieth rows, but tenth through twentieth in what ordering? You don't know what ordering unless you specify &lt;code&gt;ORDER BY&lt;/code&gt;.</source>
          <target state="translated">使用する場合は &lt;code&gt;LIMIT&lt;/code&gt; を、使用することをお勧めします &lt;code&gt;ORDER BY&lt;/code&gt; 一意な順序に結果の行を制約句。そうしないと、クエリの行の予測できないサブセットが表示されます。10番目から20番目までの行を要求しているかもしれませんが、10番目から20番目までの順序は何ですか。 &lt;code&gt;ORDER BY&lt;/code&gt; を指定しない限り、どのような順序付けかはわかりません。</target>
        </trans-unit>
        <trans-unit id="481c23a58e8db851baee87afbfd06f8aa525bda9" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;LIMIT&lt;/code&gt;, it is important to use an &lt;code&gt;ORDER BY&lt;/code&gt; clause that constrains the result rows into a unique order. Otherwise you will get an unpredictable subset of the query's rows. You might be asking for the tenth through twentieth rows, but tenth through twentieth in what ordering? The ordering is unknown, unless you specified &lt;code&gt;ORDER BY&lt;/code&gt;.</source>
          <target state="translated">使用する場合は &lt;code&gt;LIMIT&lt;/code&gt; を、使用することが重要である &lt;code&gt;ORDER BY&lt;/code&gt; 一意な順序に結果の行を制約句。そうしないと、クエリの行の予測できないサブセットが取得されます。10行目から20行目までを求めているかもしれませんが、10から20行目はどのような順序ですか？ &lt;code&gt;ORDER BY&lt;/code&gt; を指定しない限り、順序は不明です。</target>
        </trans-unit>
        <trans-unit id="f85dc3be9cb7f009d076c5eedd8386addcb8b584" translate="yes" xml:space="preserve">
          <source>When using Kerberos authentication, SSPI works the same way GSSAPI does; see &lt;a href=&quot;gssapi-auth&quot;&gt;Section 20.6&lt;/a&gt; for details.</source>
          <target state="translated">Kerberos認証を使用する場合、SSPIはGSSAPIと同じように機能します。詳細は&lt;a href=&quot;gssapi-auth&quot;&gt;項20.6&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="dc80b0e9ed4294e8911057b0a0a50261a196de62" translate="yes" xml:space="preserve">
          <source>When using POSIX semaphores, the number of semaphores needed is the same as for System V, that is one semaphore per allowed connection (&lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;max_connections&lt;/a&gt;), allowed autovacuum worker process (&lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-MAX-WORKERS&quot;&gt;autovacuum_max_workers&lt;/a&gt;) and allowed background process (&lt;a href=&quot;runtime-config-resource#GUC-MAX-WORKER-PROCESSES&quot;&gt;max_worker_processes&lt;/a&gt;). On the platforms where this option is preferred, there is no specific kernel limit on the number of POSIX semaphores.</source>
          <target state="translated">POSIXセマフォを使用する場合、必要なセマフォの数はSystem Vの場合と同じです。つまり、許可された接続（&lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;max_connections&lt;/a&gt;）、許可されたautovacuumワーカープロセス（&lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-MAX-WORKERS&quot;&gt;autovacuum_max_workers&lt;/a&gt;）および許可されたバックグラウンドプロセス（&lt;a href=&quot;runtime-config-resource#GUC-MAX-WORKER-PROCESSES&quot;&gt;max_worker_processes&lt;/a&gt;）ごとに1つのセマフォです。このオプションが推奨されるプラットフォームでは、POSIXセマフォの数に特定のカーネル制限はありません。</target>
        </trans-unit>
        <trans-unit id="8579cb5fcd4b92d72b4fadb397cff9f7dbbdad05" translate="yes" xml:space="preserve">
          <source>When using RADIUS authentication, an Access Request message will be sent to the configured RADIUS server. This request will be of type &lt;code&gt;Authenticate Only&lt;/code&gt;, and include parameters for &lt;code&gt;user name&lt;/code&gt;, &lt;code&gt;password&lt;/code&gt; (encrypted) and &lt;code&gt;NAS Identifier&lt;/code&gt;. The request will be encrypted using a secret shared with the server. The RADIUS server will respond to this request with either &lt;code&gt;Access Accept&lt;/code&gt; or &lt;code&gt;Access Reject&lt;/code&gt;. There is no support for RADIUS accounting.</source>
          <target state="translated">When using RADIUS authentication, an Access Request message will be sent to the configured RADIUS server. This request will be of type &lt;code&gt;Authenticate Only&lt;/code&gt; , and include parameters for &lt;code&gt;user name&lt;/code&gt; , &lt;code&gt;password&lt;/code&gt; (encrypted) and &lt;code&gt;NAS Identifier&lt;/code&gt; . The request will be encrypted using a secret shared with the server. The RADIUS server will respond to this request with either &lt;code&gt;Access Accept&lt;/code&gt; or &lt;code&gt;Access Reject&lt;/code&gt; . There is no support for RADIUS accounting.</target>
        </trans-unit>
        <trans-unit id="0d87a93d2de1be22dab32dcbbc5446297da3c6d5" translate="yes" xml:space="preserve">
          <source>When using RADIUS authentication, an Access Request message will be sent to the configured RADIUS server. This request will be of type &lt;code&gt;Authenticate Only&lt;/code&gt;, and include parameters for &lt;code&gt;user name&lt;/code&gt;, &lt;code&gt;password&lt;/code&gt; (encrypted) and &lt;code&gt;NAS Identifier&lt;/code&gt;. The request will be encrypted using a secret shared with the server. The RADIUS server will respond to this server with either &lt;code&gt;Access Accept&lt;/code&gt; or &lt;code&gt;Access Reject&lt;/code&gt;. There is no support for RADIUS accounting.</source>
          <target state="translated">RADIUS認証を使用すると、構成されたRADIUSサーバーにアクセス要求メッセージが送信されます。この要求のタイプは &lt;code&gt;Authenticate Only&lt;/code&gt; であり、 &lt;code&gt;user name&lt;/code&gt; 、 &lt;code&gt;password&lt;/code&gt; （暗号化）、 &lt;code&gt;NAS Identifier&lt;/code&gt; パラメーターが含まれます。リクエストは、サーバーと共有されるシークレットを使用して暗号化されます。 RADIUSサーバーは、このサーバーに &lt;code&gt;Access Accept&lt;/code&gt; または &lt;code&gt;Access Reject&lt;/code&gt; のいずれかで応答します。 RADIUSアカウンティングはサポートされていません。</target>
        </trans-unit>
        <trans-unit id="df1ce6f4ba5a71b98d3f24da1f9c50898361216d" translate="yes" xml:space="preserve">
          <source>When using System V semaphores, PostgreSQL uses one semaphore per allowed connection (&lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;max_connections&lt;/a&gt;), allowed autovacuum worker process (&lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-MAX-WORKERS&quot;&gt;autovacuum_max_workers&lt;/a&gt;) and allowed background process (&lt;a href=&quot;runtime-config-resource#GUC-MAX-WORKER-PROCESSES&quot;&gt;max_worker_processes&lt;/a&gt;), in sets of 16. Each such set will also contain a 17th semaphore which contains a &amp;ldquo;magic number&amp;rdquo;, to detect collision with semaphore sets used by other applications. The maximum number of semaphores in the system is set by &lt;code&gt;SEMMNS&lt;/code&gt;, which consequently must be at least as high as &lt;code&gt;max_connections&lt;/code&gt; plus &lt;code&gt;autovacuum_max_workers&lt;/code&gt; plus &lt;code&gt;max_wal_senders&lt;/code&gt;, plus &lt;code&gt;max_worker_processes&lt;/code&gt;, plus one extra for each 16 allowed connections plus workers (see the formula in &lt;a href=&quot;kernel-resources#SYSVIPC-PARAMETERS&quot;&gt;Table 18.1&lt;/a&gt;). The parameter &lt;code&gt;SEMMNI&lt;/code&gt; determines the limit on the number of semaphore sets that can exist on the system at one time. Hence this parameter must be at least &lt;code&gt;ceil((max_connections + autovacuum_max_workers + max_wal_senders + max_worker_processes + 5) / 16)&lt;/code&gt;. Lowering the number of allowed connections is a temporary workaround for failures, which are usually confusingly worded &amp;ldquo;No space left on device&amp;rdquo;, from the function &lt;code&gt;semget&lt;/code&gt;.</source>
          <target state="translated">System Vセマフォを使用する場合、PostgreSQLは許可された接続（&lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;max_connections&lt;/a&gt;）、許可された自動バキュームワーカープロセス（&lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-MAX-WORKERS&quot;&gt;autovacuum_max_workers&lt;/a&gt;）、および許可されたバックグラウンドプロセス（&lt;a href=&quot;runtime-config-resource#GUC-MAX-WORKER-PROCESSES&quot;&gt;max_worker_processes&lt;/a&gt;）ごとに1つのセマフォを16のセットで使用します。このような各セットには、「他のアプリケーションで使用されているセマフォセットとの衝突を検出するための「マジックナンバー」。システム内のセマフォの最大数は &lt;code&gt;SEMMNS&lt;/code&gt; によって設定されるため、少なくとも &lt;code&gt;max_connections&lt;/code&gt; + &lt;code&gt;autovacuum_max_workers&lt;/code&gt; + &lt;code&gt;max_wal_senders&lt;/code&gt; + &lt;code&gt;max_worker_processes&lt;/code&gt; と同じ数にする必要があります。、さらに16の許可された接続ごとに1つの追加とワーカー（&lt;a href=&quot;kernel-resources#SYSVIPC-PARAMETERS&quot;&gt;表18.1の&lt;/a&gt;式を参照）。 &lt;code&gt;SEMMNI&lt;/code&gt; パラメータは、システムに同時に存在できるセマフォセットの数の制限を決定します。したがって、このパラメーターは少なくとも &lt;code&gt;ceil((max_connections + autovacuum_max_workers + max_wal_senders + max_worker_processes + 5) / 16)&lt;/code&gt; でなければなりません。許可される接続の数を減らすことは、障害の一時的な回避策です。これは通常、関数 &lt;code&gt;semget&lt;/code&gt; から「デバイスにスペースが残っていません」と紛らわしい言葉で呼ばれます。</target>
        </trans-unit>
        <trans-unit id="c8382eef968bcd1841af0a45f03df20722ebed18" translate="yes" xml:space="preserve">
          <source>When using a replication setup with tools which perform direct copies of relation file blocks (for example &lt;a href=&quot;app-pgrewind&quot;&gt;pg_rewind&lt;/a&gt;), enabling or disabling checksums can lead to page corruptions in the shape of incorrect checksums if the operation is not done consistently across all nodes. When enabling or disabling checksums in a replication setup, it is thus recommended to stop all the clusters before switching them all consistently. Destroying all standbys, performing the operation on the primary and finally recreating the standbys from scratch is also safe.</source>
          <target state="translated">リレーションファイルブロックの直接コピーを実行するツール（&lt;a href=&quot;app-pgrewind&quot;&gt;pg_rewindなど&lt;/a&gt;）でレプリケーションセットアップを使用する場合、チェックサムを有効または無効にすると、操作がすべてのノードで一貫して行われていない場合、誤ったチェックサムの形でページが破損する可能性があります。したがって、レプリケーション設定でチェックサムを有効または無効にする場合は、すべてを一貫して切り替える前に、すべてのクラスターを停止することをお勧めします。すべてのスタンバイを破棄し、プライマリで操作を実行し、最後にスタンバイを最初から再作成することも安全です。</target>
        </trans-unit>
        <trans-unit id="eac93956f94fd1f4ae45bb87df2631e194bcbe28" translate="yes" xml:space="preserve">
          <source>When using a separate column to store the &lt;code&gt;tsvector&lt;/code&gt; representation of your documents, it is necessary to create a trigger to update the &lt;code&gt;tsvector&lt;/code&gt; column when the document content columns change. Two built-in trigger functions are available for this, or you can write your own.</source>
          <target state="translated">別の列を使用してドキュメントの &lt;code&gt;tsvector&lt;/code&gt; 表現を格納する場合、ドキュメントコンテンツの列が変更されたときに &lt;code&gt;tsvector&lt;/code&gt; 列を更新するトリガーを作成する必要があります。これには2つの組み込みトリガー関数を使用できますが、独自に作成することもできます。</target>
        </trans-unit>
        <trans-unit id="9150f1a85447666f80a11e9912230df80685449c" translate="yes" xml:space="preserve">
          <source>When using an &lt;code&gt;archive_command&lt;/code&gt; script, it's desirable to enable &lt;a href=&quot;runtime-config-logging#GUC-LOGGING-COLLECTOR&quot;&gt;logging_collector&lt;/a&gt;. Any messages written to stderr from the script will then appear in the database server log, allowing complex configurations to be diagnosed easily if they fail.</source>
          <target state="translated">&lt;code&gt;archive_command&lt;/code&gt; スクリプトを使用するときは、&lt;a href=&quot;runtime-config-logging#GUC-LOGGING-COLLECTOR&quot;&gt;logging_collector&lt;/a&gt;を有効にすることが望ましいです。スクリプトからstderrに書き込まれたメッセージはすべてデータベースサーバーログに表示されるため、複雑な構成が失敗した場合に簡単に診断できます。</target>
        </trans-unit>
        <trans-unit id="953b500ebbfdd4983d6d154f36b232db63c79506" translate="yes" xml:space="preserve">
          <source>When using an external authentication system such as Ident or GSSAPI, the name of the operating system user that initiated the connection might not be the same as the database user (role) that is to be used. In this case, a user name map can be applied to map the operating system user name to a database user. To use user name mapping, specify &lt;code&gt;map&lt;/code&gt;=&lt;code&gt;map-name&lt;/code&gt; in the options field in &lt;code&gt;pg_hba.conf&lt;/code&gt;. This option is supported for all authentication methods that receive external user names. Since different mappings might be needed for different connections, the name of the map to be used is specified in the &lt;code&gt;map-name&lt;/code&gt; parameter in &lt;code&gt;pg_hba.conf&lt;/code&gt; to indicate which map to use for each individual connection.</source>
          <target state="translated">IdentやGSSAPIなどの外部認証システムを使用する場合、接続を開始したオペレーティングシステムユーザーの名前は、使用されるデータベースユーザー（ロール）と同じでない場合があります。この場合、ユーザー名マップを適用して、オペレーティングシステムのユーザー名をデータベースユーザーにマップできます。ユーザー名マッピングを使用するには、 &lt;code&gt;pg_hba.conf&lt;/code&gt; のオプションフィールドで &lt;code&gt;map&lt;/code&gt; = &lt;code&gt;map-name&lt;/code&gt; を指定します。このオプションは、外部ユーザー名を受け取るすべての認証方法でサポートされています。異なる接続には異なるマッピングが必要になる場合があるため、使用する &lt;code&gt;map-name&lt;/code&gt; は、個々の接続ごとに使用するマップを示すために、 &lt;code&gt;pg_hba.conf&lt;/code&gt; のmap-nameパラメーターで指定されます。</target>
        </trans-unit>
        <trans-unit id="492838d017254285805f7e847c1bb4763dffb265" translate="yes" xml:space="preserve">
          <source>When using binary mode to pass query parameters to the server and query results back to the client, no encoding conversion is performed, so the situation is different. In this case, an encoding declaration in the XML data will be observed, and if it is absent, the data will be assumed to be in UTF-8 (as required by the XML standard; note that PostgreSQL does not support UTF-16). On output, data will have an encoding declaration specifying the client encoding, unless the client encoding is UTF-8, in which case it will be omitted.</source>
          <target state="translated">バイナリモードを使用してクエリパラメータをサーバに渡し、クエリ結果をクライアントに返す場合、エンコーディング変換は行われませんので、状況は異なります。この場合、XMLデータ内の符号化宣言が観測され、それがない場合はUTF-8(XML標準で要求されている)とみなされます(PostgreSQLはUTF-16をサポートしていないことに注意してください)。PostgreSQLはUTF-16をサポートしていないことに注意してください。出力時には、クライアントのエンコーディングを指定するエンコーディング宣言があります。</target>
        </trans-unit>
        <trans-unit id="5c43830d30560b418ee227f739bdeb1afbb63531" translate="yes" xml:space="preserve">
          <source>When using collations provided by &lt;code&gt;libc&lt;/code&gt; and PostgreSQL was built with the GNU C library, the C library's version is used as a collation version. Since collation definitions typically change only with GNU C library releases, this provides some defense against corruption, but it is not completely reliable.</source>
          <target state="translated">When using collations provided by &lt;code&gt;libc&lt;/code&gt; and PostgreSQL was built with the GNU C library, the C library's version is used as a collation version. Since collation definitions typically change only with GNU C library releases, this provides some defense against corruption, but it is not completely reliable.</target>
        </trans-unit>
        <trans-unit id="56607247aff04e4e074b7797ef04095046172c94" translate="yes" xml:space="preserve">
          <source>When using collations provided by the ICU library, the ICU-specific version of the collator is recorded in the system catalog when the collation object is created. When the collation is used, the current version is checked against the recorded version, and a warning is issued when there is a mismatch, for example:</source>
          <target state="translated">ICU ライブラリで提供されている照合順序を使用する場合、照合順序オブジェクトの作成時に、ICU固有の照合順序のバージョンがシステムカタログに記録される。照合を使用する際には、現在のバージョンと記録されているバージョンが照合され、不一致があった場合などに警告が表示されます。</target>
        </trans-unit>
        <trans-unit id="de5896493e8d94d607ede6725d8b75b29f2f0f82" translate="yes" xml:space="preserve">
          <source>When using cost-based vacuuming, appropriate values for &lt;code&gt;vacuum_cost_delay&lt;/code&gt; are usually quite small, perhaps less than 1 millisecond. While &lt;code&gt;vacuum_cost_delay&lt;/code&gt; can be set to fractional-millisecond values, such delays may not be measured accurately on older platforms. On such platforms, increasing &lt;code&gt;VACUUM&lt;/code&gt;'s throttled resource consumption above what you get at 1ms will require changing the other vacuum cost parameters. You should, nonetheless, keep &lt;code&gt;vacuum_cost_delay&lt;/code&gt; as small as your platform will consistently measure; large delays are not helpful.</source>
          <target state="translated">コストベースのバキューム処理を使用する場合、 &lt;code&gt;vacuum_cost_delay&lt;/code&gt; の適切な値は通常非常に小さく、おそらく1ミリ秒未満です。ながら &lt;code&gt;vacuum_cost_delay&lt;/code&gt; 小数ミリ秒の値に設定することができ、このような遅延は、古いプラットフォーム上で正確に測定することはできません。そのようなプラットフォームでは、 &lt;code&gt;VACUUM&lt;/code&gt; の調整されたリソース消費を1msで得られる以上に増やすには、他のバキュームコストパラメーターを変更する必要があります。それでもなお、 &lt;code&gt;vacuum_cost_delay&lt;/code&gt; は、プラットフォームが常に測定するのと同じくらい小さく保つ必要があります。大きな遅延は役に立ちません。</target>
        </trans-unit>
        <trans-unit id="75aee5f97d42018467b21311d706aa5a647707a9" translate="yes" xml:space="preserve">
          <source>When using exclusive backup mode, it is absolutely imperative to ensure that &lt;code&gt;pg_stop_backup&lt;/code&gt; completes successfully at the end of the backup. Even if the backup itself fails, for example due to lack of disk space, failure to call &lt;code&gt;pg_stop_backup&lt;/code&gt; will leave the server in backup mode indefinitely, causing future backups to fail and increasing the risk of a restart failure during the time that &lt;code&gt;backup_label&lt;/code&gt; exists.</source>
          <target state="translated">排他バックアップモードを使用する場合、 &lt;code&gt;pg_stop_backup&lt;/code&gt; がバックアップの最後に正常に完了するようにすることが絶対に不可欠です。たとえば、ディスク領域の不足が原因でバックアップ自体が失敗した場合でも、 &lt;code&gt;pg_stop_backup&lt;/code&gt; の呼び出しに失敗すると、サーバーが無期限にバックアップモードのままになり、将来のバックアップが失敗し、 &lt;code&gt;backup_label&lt;/code&gt; が存在する間に再起動が失敗するリスクが高まります。</target>
        </trans-unit>
        <trans-unit id="ec73be80732f41a040847bc00566e73f63c25a96" translate="yes" xml:space="preserve">
          <source>When using link mode, standby servers can be quickly upgraded using rsync. To accomplish this, from a directory on the primary server that is above the old and new database cluster directories, run this on the &lt;em&gt;primary&lt;/em&gt; for each standby server:</source>
          <target state="translated">リンクモードを使用する場合、スタンバイサーバーはrsyncを使用してすばやくアップグレードできます。これを行うには、新旧のデータベースクラスターディレクトリの上にあるプライマリサーバーのディレクトリから、各スタンバイサーバーの&lt;em&gt;プライマリ&lt;/em&gt;でこれを実行します。</target>
        </trans-unit>
        <trans-unit id="7d1e98ef020032cfb9faf29c2d74acac7b1c192c" translate="yes" xml:space="preserve">
          <source>When using multiple &lt;code&gt;INSERT&lt;/code&gt;s, turn off autocommit and just do one commit at the end. (In plain SQL, this means issuing &lt;code&gt;BEGIN&lt;/code&gt; at the start and &lt;code&gt;COMMIT&lt;/code&gt; at the end. Some client libraries might do this behind your back, in which case you need to make sure the library does it when you want it done.) If you allow each insertion to be committed separately, PostgreSQL is doing a lot of work for each row that is added. An additional benefit of doing all insertions in one transaction is that if the insertion of one row were to fail then the insertion of all rows inserted up to that point would be rolled back, so you won't be stuck with partially loaded data.</source>
          <target state="translated">複数の &lt;code&gt;INSERT&lt;/code&gt; を使用する場合は、自動コミットをオフにして、最後に1回だけコミットしてください。 （プレーンSQLでは、これは最初に &lt;code&gt;BEGIN&lt;/code&gt; を発行し、最後に &lt;code&gt;COMMIT&lt;/code&gt; を発行することを意味します。一部のクライアントライブラリは、これを背後で実行する場合があります。その場合、必要なときにライブラリが実行することを確認する必要があります。）各挿入は個別にコミットされるため、PostgreSQLは追加された各行に対して多くの作業を行っています。 1つのトランザクションですべての挿入を実行することの追加の利点は、1つの行の挿入が失敗した場合に、その時点までに挿入されたすべての行の挿入がロールバックされるため、部分的にロードされたデータで立ち往生しないことです。</target>
        </trans-unit>
        <trans-unit id="8692847b55239c8542d72c31d947ca1f69e8f98c" translate="yes" xml:space="preserve">
          <source>When using pg_receivewal instead of &lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-COMMAND&quot;&gt;archive_command&lt;/a&gt; as the main WAL backup method, it is strongly recommended to use replication slots. Otherwise, the server is free to recycle or remove write-ahead log files before they are backed up, because it does not have any information, either from &lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-COMMAND&quot;&gt;archive_command&lt;/a&gt; or the replication slots, about how far the WAL stream has been archived. Note, however, that a replication slot will fill up the server's disk space if the receiver does not keep up with fetching the WAL data.</source>
          <target state="translated">メインのWALバックアップ方法として、&lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-COMMAND&quot;&gt;archive_commandの&lt;/a&gt;代わりにpg_receivewal を使用する場合、レプリケーションスロットを使用することを強くお勧めします。それ以外の場合は、WALストリームがアーカイブされた距離に関する情報が&lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-COMMAND&quot;&gt;archive_command&lt;/a&gt;またはレプリケーションスロットから得られないため、バックアップ前に、サーバーは先読みログファイルを自由にリサイクルまたは削除できます。ただし、レシーバーがWALデータのフェッチに追いついていない場合、レプリケーションスロットがサーバーのディスク領域をいっぱいにすることに注意してください。</target>
        </trans-unit>
        <trans-unit id="7805e078bb69ca14f943ca44e9ff4b57cc0c775e" translate="yes" xml:space="preserve">
          <source>When using search+bind mode, the search can be performed using a single attribute specified with &lt;code&gt;ldapsearchattribute&lt;/code&gt;, or using a custom search filter specified with &lt;code&gt;ldapsearchfilter&lt;/code&gt;. Specifying &lt;code&gt;ldapsearchattribute=foo&lt;/code&gt; is equivalent to specifying &lt;code&gt;ldapsearchfilter=&quot;(foo=$username)&quot;&lt;/code&gt;. If neither option is specified the default is &lt;code&gt;ldapsearchattribute=uid&lt;/code&gt;.</source>
          <target state="translated">検索+バインドモードを使用する場合、検索はして指定された単一の属性を用いて行うことができる &lt;code&gt;ldapsearchattribute&lt;/code&gt; を、またはで指定されたカスタム検索フィルタ使用 &lt;code&gt;ldapsearchfilter&lt;/code&gt; を。指定 &lt;code&gt;ldapsearchattribute=foo&lt;/code&gt; が指定するのと同じです &lt;code&gt;ldapsearchfilter=&quot;(foo=$username)&quot;&lt;/code&gt; 。どちらのオプションも指定されていない場合、デフォルトは &lt;code&gt;ldapsearchattribute=uid&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="135e97cd9c471619bb69517b95ef6da4e4340a4c" translate="yes" xml:space="preserve">
          <source>When using static log file names, the server might fail to reopen the log file if the max open file limit is reached or a file table overflow occurs. In this case, log messages are sent to the old log file until a successful log rotation. If logrotate is configured to compress the log file and delete it, the server may lose the messages logged in this time frame. To avoid this issue, you can configure the logging collector to dynamically assign log file names and use a &lt;code&gt;prerotate&lt;/code&gt; script to ignore open log files.</source>
          <target state="translated">When using static log file names, the server might fail to reopen the log file if the max open file limit is reached or a file table overflow occurs. In this case, log messages are sent to the old log file until a successful log rotation. If logrotate is configured to compress the log file and delete it, the server may lose the messages logged in this time frame. To avoid this issue, you can configure the logging collector to dynamically assign log file names and use a &lt;code&gt;prerotate&lt;/code&gt; script to ignore open log files.</target>
        </trans-unit>
        <trans-unit id="ccf2c531c08aa10ba699a8b190067e047b3e70bf" translate="yes" xml:space="preserve">
          <source>When using static log file names, the server might fail to reopen the log file if the max open file limit is reached or a file table overflow occurs. In this case, log messages are sent to the old log file until a successful log rotation. If logrotate is configured to compress the log file and delete it, the server may lose the messages logged in this timeframe. To avoid this issue, you can configure the logging collector to dynamically assign log file names and use a &lt;code&gt;prerotate&lt;/code&gt; script to ignore open log files.</source>
          <target state="translated">静的ログファイル名を使用する場合、最大オープンファイル制限に達したり、ファイルテーブルのオーバーフローが発生したりすると、サーバーはログファイルを再度開くことができない場合があります。この場合、ログのローテーションが成功するまで、ログメッセージは古いログファイルに送信されます。logrotateがログファイルを圧縮して削除するように構成されている場合、サーバーはこの時間枠に記録されたメッセージを失う可能性があります。この問題を回避するには、ログコレクターを構成してログファイル名を動的に割り当て、 &lt;code&gt;prerotate&lt;/code&gt; スクリプトを使用して開いているログファイルを無視します。</target>
        </trans-unit>
        <trans-unit id="ddcdbf5154b4eb280778c5288af6f89414cb4462" translate="yes" xml:space="preserve">
          <source>When using systemd, you can use the following service unit file (e.g., at &lt;code&gt;/etc/systemd/system/postgresql.service&lt;/code&gt;):</source>
          <target state="translated">systemdを使用する場合、次のサービスユニットファイルを使用できます（例： &lt;code&gt;/etc/systemd/system/postgresql.service&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="aa4f4b5954d77c90199a922670870bbe00993316" translate="yes" xml:space="preserve">
          <source>When using the &lt;a href=&quot;https://www.postgresql.org/docs/12/dblink.html&quot;&gt;dblink&lt;/a&gt; module, a foreign server's name can be used as an argument of the &lt;a href=&quot;https://www.postgresql.org/docs/12/contrib-dblink-connect.html&quot;&gt;dblink_connect&lt;/a&gt; function to indicate the connection parameters. It is necessary to have the &lt;code&gt;USAGE&lt;/code&gt; privilege on the foreign server to be able to use it in this way.</source>
          <target state="translated">&lt;a href=&quot;https://www.postgresql.org/docs/12/dblink.html&quot;&gt;dblink&lt;/a&gt;モジュールを使用する場合、外部サーバーの名前を&lt;a href=&quot;https://www.postgresql.org/docs/12/contrib-dblink-connect.html&quot;&gt;dblink_connect&lt;/a&gt;関数の引数として使用して、接続パラメーターを示すことができます。この方法で使用するには、外部サーバーに対する &lt;code&gt;USAGE&lt;/code&gt; 特権が必要です。</target>
        </trans-unit>
        <trans-unit id="2a1340434fcccdcd8d13b6480e2a087b4c7cd975" translate="yes" xml:space="preserve">
          <source>When using the &lt;a href=&quot;https://www.postgresql.org/docs/13/dblink.html&quot;&gt;dblink&lt;/a&gt; module, a foreign server's name can be used as an argument of the &lt;a href=&quot;https://www.postgresql.org/docs/13/contrib-dblink-connect.html&quot;&gt;dblink_connect&lt;/a&gt; function to indicate the connection parameters. It is necessary to have the &lt;code&gt;USAGE&lt;/code&gt; privilege on the foreign server to be able to use it in this way.</source>
          <target state="translated">When using the &lt;a href=&quot;https://www.postgresql.org/docs/13/dblink.html&quot;&gt;dblink&lt;/a&gt; module, a foreign server's name can be used as an argument of the &lt;a href=&quot;https://www.postgresql.org/docs/13/contrib-dblink-connect.html&quot;&gt;dblink_connect&lt;/a&gt; function to indicate the connection parameters. It is necessary to have the &lt;code&gt;USAGE&lt;/code&gt; privilege on the foreign server to be able to use it in this way.</target>
        </trans-unit>
        <trans-unit id="bd246a1d45857b9944b119a71ad8342fdd069e69" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;ROWS FROM( ... )&lt;/code&gt; syntax, if one of the functions requires a column definition list, it's preferred to put the column definition list after the function call inside &lt;code&gt;ROWS FROM( ... )&lt;/code&gt;. A column definition list can be placed after the &lt;code&gt;ROWS FROM( ... )&lt;/code&gt; construct only if there's just a single function and no &lt;code&gt;WITH ORDINALITY&lt;/code&gt; clause.</source>
          <target state="translated">&lt;code&gt;ROWS FROM( ... )&lt;/code&gt; 構文を使用するときに、いずれかの関数で列定義リストが必要な場合は、 &lt;code&gt;ROWS FROM( ... )&lt;/code&gt; 内の関数呼び出しの後に列定義リストを配置することをお勧めします。列定義リストは、関数が1つだけで &lt;code&gt;WITH ORDINALITY&lt;/code&gt; 句がない場合にのみ、 &lt;code&gt;ROWS FROM( ... )&lt;/code&gt; 構文の後に配置できます。</target>
        </trans-unit>
        <trans-unit id="98b68f1005505d22ba3f1b802a0a0796977dd397" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;extensions&lt;/code&gt; option, &lt;em&gt;it is the user's responsibility&lt;/em&gt; that the listed extensions exist and behave identically on both the local and remote servers. Otherwise, remote queries may fail or behave unexpectedly.</source>
          <target state="translated">&lt;code&gt;extensions&lt;/code&gt; オプションを使用する場合、リストされた拡張が存在し、ローカルサーバーとリモートサーバーの両方で同じように動作する&lt;em&gt;のはユーザーの責任&lt;/em&gt;です。そうしないと、リモートクエリが失敗するか、予期しない動作をする可能性があります。</target>
        </trans-unit>
        <trans-unit id="e797775100fdafb459cefc34e37395f8e226c9b6" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;libc&lt;/code&gt; collation provider, the locale must be applicable to the current database encoding. See &lt;a href=&quot;sql-createdatabase&quot;&gt;CREATE DATABASE&lt;/a&gt; for the precise rules.</source>
          <target state="translated">&lt;code&gt;libc&lt;/code&gt; 照合プロバイダーを使用する場合、ロケールは現在のデータベースエンコーディングに適用できる必要があります。正確な規則については、&lt;a href=&quot;sql-createdatabase&quot;&gt;CREATE DATABASE&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="33347a458dabb91eee87e22ef8743db48a2953ba" translate="yes" xml:space="preserve">
          <source>When using the statistics to monitor collected data, it is important to realize that the information does not update instantaneously. Each individual server process transmits new statistical counts to the collector just before going idle; so a query or transaction still in progress does not affect the displayed totals. Also, the collector itself emits a new report at most once per &lt;code&gt;PGSTAT_STAT_INTERVAL&lt;/code&gt; milliseconds (500 ms unless altered while building the server). So the displayed information lags behind actual activity. However, current-query information collected by &lt;code&gt;track_activities&lt;/code&gt; is always up-to-date.</source>
          <target state="translated">統計を使用して収集されたデータを監視する場合、情報が瞬時に更新されないことを理解することが重要です。個々のサーバープロセスはそれぞれ、アイドルになる直前に新しい統計カウントをコレクターに送信します。そのため、まだ進行中のクエリまたはトランザクションは、表示される合計に影響しません。また、コレクター自体は、 &lt;code&gt;PGSTAT_STAT_INTERVAL&lt;/code&gt; ミリ秒（サーバーの構築中に変更されない限り500ミリ秒）ごとに最大1回、新しいレポートを発行します。そのため、表示される情報は実際のアクティビティよりも遅れています。ただし、 &lt;code&gt;track_activities&lt;/code&gt; によって収集された現在のクエリ情報は常に最新です。</target>
        </trans-unit>
        <trans-unit id="869040936f3cd63714aedfeb674cbbcb51ecde9f" translate="yes" xml:space="preserve">
          <source>When using this option together with &lt;a href=&quot;runtime-config-logging#GUC-LOG-STATEMENT&quot;&gt;log_statement&lt;/a&gt;, the text of statements that are logged because of &lt;code&gt;log_statement&lt;/code&gt; will not be repeated in the duration log message. If you are not using syslog, it is recommended that you log the PID or session ID using &lt;a href=&quot;runtime-config-logging#GUC-LOG-LINE-PREFIX&quot;&gt;log_line_prefix&lt;/a&gt; so that you can link the statement message to the later duration message using the process ID or session ID.</source>
          <target state="translated">一緒にこのオプションを使用する場合&lt;a href=&quot;runtime-config-logging#GUC-LOG-STATEMENT&quot;&gt;log_statement&lt;/a&gt;、理由のログに記録されている文のテキスト &lt;code&gt;log_statement&lt;/code&gt; は持続ログメッセージの中で繰り返されることはありません。 syslogを使用していない場合は、&lt;a href=&quot;runtime-config-logging#GUC-LOG-LINE-PREFIX&quot;&gt;log_line_prefix&lt;/a&gt;を使用してPIDまたはセッションIDをログに記録し、プロセスIDまたはセッションIDを使用してステートメントメッセージを後の期間メッセージにリンクできるようにすることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="f56584dae166e0f5d41c03bae8959fb67da882b7" translate="yes" xml:space="preserve">
          <source>When using this technique, it will avoid creating an unnecessary burden for application programmers if the application software goes through a framework which automatically retries transactions which are rolled back with a serialization failure. It may be a good idea to set &lt;code&gt;default_transaction_isolation&lt;/code&gt; to &lt;code&gt;serializable&lt;/code&gt;. It would also be wise to take some action to ensure that no other transaction isolation level is used, either inadvertently or to subvert integrity checks, through checks of the transaction isolation level in triggers.</source>
          <target state="translated">この手法を使用すると、アプリケーションソフトウェアが、シリアライゼーションエラーでロールバックされたトランザクションを自動的に再試行するフレームワークを通過する場合に、アプリケーションプログラマーに不必要な負担をかけないようにします。 &lt;code&gt;default_transaction_isolation&lt;/code&gt; を &lt;code&gt;serializable&lt;/code&gt; に設定することをお勧めします。また、トリガーのトランザクション分離レベルのチェックを通じて、他のトランザクション分離レベルが誤って使用されたり、整合性チェックを覆したりしないように、何らかのアクションをとることも賢明です。</target>
        </trans-unit>
        <trans-unit id="a2c852145ce2448ef43e1a7c8c990a843033f4d6" translate="yes" xml:space="preserve">
          <source>When verifying checksums, every file in the cluster is scanned. When enabling checksums, every file in the cluster is rewritten in-place. Disabling checksums only updates the file &lt;code&gt;pg_control&lt;/code&gt;.</source>
          <target state="translated">When verifying checksums, every file in the cluster is scanned. When enabling checksums, every file in the cluster is rewritten in-place. Disabling checksums only updates the file &lt;code&gt;pg_control&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3e33ed6ffb66e09afb90b2aa31b40f235c917227" translate="yes" xml:space="preserve">
          <source>When verifying checksums, every file in the cluster is scanned. When enabling checksums, every file in the cluster is rewritten. Disabling checksums only updates the file &lt;code&gt;pg_control&lt;/code&gt;.</source>
          <target state="translated">チェックサムを検証するとき、クラスター内のすべてのファイルがスキャンされます。チェックサムを有効にすると、クラスター内のすべてのファイルが書き換えられます。チェックサムを無効にすると、ファイル &lt;code&gt;pg_control&lt;/code&gt; のみが更新されます。</target>
        </trans-unit>
        <trans-unit id="fda53778d06f68bfde32b3023f6347b2be67790d" translate="yes" xml:space="preserve">
          <source>When waiting, &lt;code&gt;pg_ctl&lt;/code&gt; repeatedly checks the server's PID file, sleeping for a short amount of time between checks. Startup is considered complete when the PID file indicates that the server is ready to accept connections. Shutdown is considered complete when the server removes the PID file. &lt;code&gt;pg_ctl&lt;/code&gt; returns an exit code based on the success of the startup or shutdown.</source>
          <target state="translated">待機中、 &lt;code&gt;pg_ctl&lt;/code&gt; はサーバーのPIDファイルを繰り返しチェックし、チェックとチェックの間の短い時間スリープします。サーバーが接続を受け入れる準備ができていることをPIDファイルが示している場合、起動は完了したと見なされます。サーバーがPIDファイルを削除すると、シャットダウンは完了したと見なされます。 &lt;code&gt;pg_ctl&lt;/code&gt; は、起動またはシャットダウンの成功に基づいて終了コードを返します。</target>
        </trans-unit>
        <trans-unit id="319a6ac32ba7d37c93ad8b3aed41a7b25d9cd283" translate="yes" xml:space="preserve">
          <source>When we speak of inheriting the locale from the execution environment, this means the following on most operating systems: For a given locale category, say the collation, the following environment variables are consulted in this order until one is found to be set: &lt;code&gt;LC_ALL&lt;/code&gt;, &lt;code&gt;LC_COLLATE&lt;/code&gt; (or the variable corresponding to the respective category), &lt;code&gt;LANG&lt;/code&gt;. If none of these environment variables are set then the locale defaults to &lt;code&gt;C&lt;/code&gt;.</source>
          <target state="translated">実行環境からロケールを継承するとは、ほとんどのオペレーティングシステムで次のことを意味します。特定のロケールカテゴリ（照合など）では、設定が見つかるまで、次の環境変数がこの順序で調べられ &lt;code&gt;LC_ALL&lt;/code&gt; ：LC_ALL、 &lt;code&gt;LC_COLLATE&lt;/code&gt; （またはそれぞれのカテゴリに対応する変数）、 &lt;code&gt;LANG&lt;/code&gt; 。これらの環境変数が設定されていない場合、ロケールはデフォルトで &lt;code&gt;C&lt;/code&gt; になります。</target>
        </trans-unit>
        <trans-unit id="09870d0ba2815a6a474afa8adde88701322779a5" translate="yes" xml:space="preserve">
          <source>When we write</source>
          <target state="translated">書くときは</target>
        </trans-unit>
        <trans-unit id="5f55fad869d686971a61de9989dadab77ae5eb95" translate="yes" xml:space="preserve">
          <source>When working with an inner tuple having unlabeled nodes, it is an error for &lt;code&gt;choose&lt;/code&gt; to return &lt;code&gt;spgAddNode&lt;/code&gt;, since the set of nodes is supposed to be fixed in such cases.</source>
          <target state="translated">ラベル付けされていないノードを持つ内部タプルを操作する場合、ノードのセットはそのような場合に修正されることになっているため、 &lt;code&gt;spgAddNode&lt;/code&gt; を返すことを &lt;code&gt;choose&lt;/code&gt; するとエラーになります。</target>
        </trans-unit>
        <trans-unit id="513c84ce8934fc59619703510a7a572aaca0c319" translate="yes" xml:space="preserve">
          <source>When working with multiple tables, it can also be useful to ask for all the columns of a particular table:</source>
          <target state="translated">複数のテーブルを扱う際には、特定のテーブルのすべての列を求めるのも便利です。</target>
        </trans-unit>
        <trans-unit id="3f387116d6a98de65f13445ebf4c25f94df15576" translate="yes" xml:space="preserve">
          <source>When working with non-SQL-standard operator names, you will usually need to separate adjacent operators with spaces to avoid ambiguity. For example, if you have defined a left unary operator named &lt;code&gt;@&lt;/code&gt;, you cannot write &lt;code&gt;X*@Y&lt;/code&gt;; you must write &lt;code&gt;X* @Y&lt;/code&gt; to ensure that PostgreSQL reads it as two operator names not one.</source>
          <target state="translated">非SQL標準の演算子名を使用する場合、曖昧さを避けるために、隣接する演算子をスペースで区切る必要があります。たとえば、 &lt;code&gt;@&lt;/code&gt; という名前の左単項演算子を定義した場合、 &lt;code&gt;X*@Y&lt;/code&gt; 書くことはできません。 &lt;code&gt;X* @Y&lt;/code&gt; を記述して、PostgreSQLがそれを1つではなく2つの演算子名として読み取るようにする必要があります。</target>
        </trans-unit>
        <trans-unit id="ec3a2849e7e7665d1ef0586b393970fa38e06c50" translate="yes" xml:space="preserve">
          <source>When working with recursive queries it is important to be sure that the recursive part of the query will eventually return no tuples, or else the query will loop indefinitely. Sometimes, using &lt;code&gt;UNION&lt;/code&gt; instead of &lt;code&gt;UNION ALL&lt;/code&gt; can accomplish this by discarding rows that duplicate previous output rows. However, often a cycle does not involve output rows that are completely duplicate: it may be necessary to check just one or a few fields to see if the same point has been reached before. The standard method for handling such situations is to compute an array of the already-visited values. For example, consider the following query that searches a table &lt;code&gt;graph&lt;/code&gt; using a &lt;code&gt;link&lt;/code&gt; field:</source>
          <target state="translated">再帰クエリを使用する場合、クエリの再帰部分が最終的にタプルを返さないことを確認することが重要です。そうしないと、クエリが無限にループします。時には、使用して &lt;code&gt;UNION&lt;/code&gt; の代わりに &lt;code&gt;UNION ALL&lt;/code&gt; は、前回の出力行を複製する行を破棄することによって、これを達成することができます。ただし、多くの場合、サイクルには完全に重複する出力行は含まれません。同じポイントに以前に到達したかどうかを確認するために、1つまたはいくつかのフィールドのみをチェックする必要がある場合があります。このような状況を処理するための標準的な方法は、すでにアクセスした値の配列を計算することです。たとえば、 &lt;code&gt;link&lt;/code&gt; フィールドを使用してテーブル &lt;code&gt;graph&lt;/code&gt; を検索する次のクエリを考えてみます。</target>
        </trans-unit>
        <trans-unit id="e5718cfeb2fe2d91286009aaf2e77c006f835bbe" translate="yes" xml:space="preserve">
          <source>When writing an interval constant with a &lt;code&gt;fields&lt;/code&gt; specification, or when assigning a string to an interval column that was defined with a &lt;code&gt;fields&lt;/code&gt; specification, the interpretation of unmarked quantities depends on the &lt;code&gt;fields&lt;/code&gt;. For example &lt;code&gt;INTERVAL '1' YEAR&lt;/code&gt; is read as 1 year, whereas &lt;code&gt;INTERVAL '1'&lt;/code&gt; means 1 second. Also, field values &amp;ldquo;to the right&amp;rdquo; of the least significant field allowed by the &lt;code&gt;fields&lt;/code&gt; specification are silently discarded. For example, writing &lt;code&gt;INTERVAL '1 day 2:03:04' HOUR TO MINUTE&lt;/code&gt; results in dropping the seconds field, but not the day field.</source>
          <target state="translated">間隔を一定に書き込む際 &lt;code&gt;fields&lt;/code&gt; で定義された間隔の列に文字列を割り当てるとき仕様、または &lt;code&gt;fields&lt;/code&gt; 仕様、マークされていない量の解釈は、に依存する &lt;code&gt;fields&lt;/code&gt; 。たとえば、 &lt;code&gt;INTERVAL '1' YEAR&lt;/code&gt; は1年として読み取られますが、 &lt;code&gt;INTERVAL '1'&lt;/code&gt; は1秒を意味します。また、 &lt;code&gt;fields&lt;/code&gt; 仕様で許可されている最下位フィールドの「右側」のフィールド値は、通知なく破棄されます。たとえば、 &lt;code&gt;INTERVAL '1 day 2:03:04' HOUR TO MINUTE&lt;/code&gt; と入力すると、秒フィールドは削除されますが、日フィールドは削除されません。</target>
        </trans-unit>
        <trans-unit id="988ef8be5d9c8af4c97d0fc59910f990922134e4" translate="yes" xml:space="preserve">
          <source>When you create a table and you realize that you made a mistake, or the requirements of the application change, you can drop the table and create it again. But this is not a convenient option if the table is already filled with data, or if the table is referenced by other database objects (for instance a foreign key constraint). Therefore PostgreSQL provides a family of commands to make modifications to existing tables. Note that this is conceptually distinct from altering the data contained in the table: here we are interested in altering the definition, or structure, of the table.</source>
          <target state="translated">テーブルを作成していて、間違いを犯したことに気づいたり、アプリケーションの要件が変更されたりした場合、そのテーブルを削除して再度作成することができます。しかし、テーブルが既にデータで埋め尽くされている場合や、テーブルが他のデータベースオブジェクト(例えば外部キー制約)から参照されている場合には、これは便利なオプションではありません。そこでPostgreSQLでは、既存のテーブルを変更するためのコマンド群を提供しています。これは、テーブルに含まれるデータを変更することとは概念的に異なることに注意してください。</target>
        </trans-unit>
        <trans-unit id="63a09c13346cb20d8d1dd7186def1b2a2f01cbc1" translate="yes" xml:space="preserve">
          <source>When you create complex database structures involving many tables with foreign key constraints, views, triggers, functions, etc. you implicitly create a net of dependencies between the objects. For instance, a table with a foreign key constraint depends on the table it references.</source>
          <target state="translated">外部キー制約、ビュー、トリガ、関数などを持つ多くのテーブルを含む複雑なデータベース構造を作成する場合、オブジェクト間に暗黙のうちに依存関係のネットを作成します。例えば、外部キー制約を持つテーブルは、それが参照するテーブルに依存します。</target>
        </trans-unit>
        <trans-unit id="b9a5344aa581794cb8d710e210bdb65e511f2134" translate="yes" xml:space="preserve">
          <source>When you create many interrelated tables it is wise to choose a consistent naming pattern for the tables and columns. For instance, there is a choice of using singular or plural nouns for table names, both of which are favored by some theorist or other.</source>
          <target state="translated">多くの相互に関連した表を作成するときは、表と列に一貫した命名パターンを選択するのが賢明です。例えば、テーブル名には単数形または複数形の名詞を使用することができます。</target>
        </trans-unit>
        <trans-unit id="593e96c33f6f0aab676c4ca184c4ca854f13bc97" translate="yes" xml:space="preserve">
          <source>When you insert invalid numbers in a table using the weak mode, the number will be inserted with the corrected check digit, but it will be displayed with an exclamation mark (&lt;code&gt;!&lt;/code&gt;) at the end, for example &lt;code&gt;0-11-000322-5!&lt;/code&gt;. This invalid marker can be checked with the &lt;code&gt;is_valid&lt;/code&gt; function and cleared with the &lt;code&gt;make_valid&lt;/code&gt; function.</source>
          <target state="translated">ウィークモードを使用してテーブルに無効な数値を挿入すると、数値は修正されたチェックデジットとともに挿入されますが、末尾に感嘆符（ &lt;code&gt;!&lt;/code&gt; ）が表示されます（例： &lt;code&gt;0-11-000322-5!&lt;/code&gt; )。。この無効なマーカーは、 &lt;code&gt;is_valid&lt;/code&gt; 関数で確認し、make_valid関数でクリア &lt;code&gt;make_valid&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="1bf59c49779a368d436367de404fed33cad74dcd" translate="yes" xml:space="preserve">
          <source>When you query JSON data, the path expression may not match the actual JSON data structure. An attempt to access a non-existent member of an object or element of an array results in a structural error. SQL/JSON path expressions have two modes of handling structural errors:</source>
          <target state="translated">JSON データをクエリすると、パス式が実際の JSON データ構造と一致しない場合があります。オブジェクトの存在しないメンバーや配列の要素にアクセスしようとすると、構造エラーが発生します。SQL/JSONパス式には、構造エラーを処理するための2つのモードがあります。</target>
        </trans-unit>
        <trans-unit id="d3780caf73c39bd4ac2d31b375fc0dd6e1923bd0" translate="yes" xml:space="preserve">
          <source>When you write the argument of a sequence function as an unadorned literal string, it becomes a constant of type &lt;code&gt;regclass&lt;/code&gt;. Since this is really just an OID, it will track the originally identified sequence despite later renaming, schema reassignment, etc. This &amp;ldquo;early binding&amp;rdquo; behavior is usually desirable for sequence references in column defaults and views. But sometimes you might want &amp;ldquo;late binding&amp;rdquo; where the sequence reference is resolved at run time. To get late-binding behavior, force the constant to be stored as a &lt;code&gt;text&lt;/code&gt; constant instead of &lt;code&gt;regclass&lt;/code&gt;:</source>
          <target state="translated">シーケンス関数の引数を修飾されていないリテラル文字列として書き込むと、それは &lt;code&gt;regclass&lt;/code&gt; 型の定数になります。これは実際には単なるOIDであるため、後で名前を変更したり、スキーマを再割り当てしたりしても、最初に識別されたシーケンスを追跡します。ただし、実行時にシーケンス参照が解決される「遅延バインディング」が必要になる場合があります。遅延バインディング動作を取得するには、定数を &lt;code&gt;regclass&lt;/code&gt; ではなく &lt;code&gt;text&lt;/code&gt; 定数として強制的に保存します。</target>
        </trans-unit>
        <trans-unit id="0deb417e3efe2ecd61376860b861e35f77f81d08" translate="yes" xml:space="preserve">
          <source>Whenever &lt;code&gt;ANALYZE&lt;/code&gt; is running, the &lt;code&gt;pg_stat_progress_analyze&lt;/code&gt; view will contain a row for each backend that is currently running that command. The tables below describe the information that will be reported and provide information about how to interpret it.</source>
          <target state="translated">Whenever &lt;code&gt;ANALYZE&lt;/code&gt; is running, the &lt;code&gt;pg_stat_progress_analyze&lt;/code&gt; view will contain a row for each backend that is currently running that command. The tables below describe the information that will be reported and provide information about how to interpret it.</target>
        </trans-unit>
        <trans-unit id="2507ec70331a5deab93cd40d826b1bdba44ecbc3" translate="yes" xml:space="preserve">
          <source>Whenever &lt;code&gt;CLUSTER&lt;/code&gt; or &lt;code&gt;VACUUM FULL&lt;/code&gt; is running, the &lt;code&gt;pg_stat_progress_cluster&lt;/code&gt; view will contain a row for each backend that is currently running either command. The tables below describe the information that will be reported and provide information about how to interpret it.</source>
          <target state="translated">&lt;code&gt;CLUSTER&lt;/code&gt; または &lt;code&gt;VACUUM FULL&lt;/code&gt; が実行されている場合は常に、 &lt;code&gt;pg_stat_progress_cluster&lt;/code&gt; ビューには、現在いずれかのコマンドを実行している各バックエンドの行が含まれます。以下の表は、報告される情報とその解釈方法に関する情報を示しています。</target>
        </trans-unit>
        <trans-unit id="51b73a7d0ff3b39db66ff19d5f58e0f20613bb45" translate="yes" xml:space="preserve">
          <source>Whenever &lt;code&gt;CREATE INDEX&lt;/code&gt; or &lt;code&gt;REINDEX&lt;/code&gt; is running, the &lt;code&gt;pg_stat_progress_create_index&lt;/code&gt; view will contain one row for each backend that is currently creating indexes. The tables below describe the information that will be reported and provide information about how to interpret it.</source>
          <target state="translated">&lt;code&gt;CREATE INDEX&lt;/code&gt; または &lt;code&gt;REINDEX&lt;/code&gt; が実行されているときは常に、 &lt;code&gt;pg_stat_progress_create_index&lt;/code&gt; ビューには、現在インデックスを作成しているバックエンドごとに1行が含まれます。以下の表は、報告される情報とその解釈方法に関する情報を示しています。</target>
        </trans-unit>
        <trans-unit id="0da2e4c266065ef5b47dc244d1142646be363723" translate="yes" xml:space="preserve">
          <source>Whenever &lt;code&gt;VACUUM&lt;/code&gt; is running, the &lt;code&gt;pg_stat_progress_vacuum&lt;/code&gt; view will contain one row for each backend (including autovacuum worker processes) that is currently vacuuming. The tables below describe the information that will be reported and provide information about how to interpret it. Progress for &lt;code&gt;VACUUM FULL&lt;/code&gt; commands is reported via &lt;code&gt;pg_stat_progress_cluster&lt;/code&gt; because both &lt;code&gt;VACUUM FULL&lt;/code&gt; and &lt;code&gt;CLUSTER&lt;/code&gt; rewrite the table, while regular &lt;code&gt;VACUUM&lt;/code&gt; only modifies it in place. See &lt;a href=&quot;progress-reporting#CLUSTER-PROGRESS-REPORTING&quot;&gt;Section 27.4.3&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;VACUUM&lt;/code&gt; が実行されているときは常に、 &lt;code&gt;pg_stat_progress_vacuum&lt;/code&gt; ビューには、現在バキュームされているバックエンド（autovacuumワーカープロセスを含む）ごとに1行が含まれます。以下の表は、報告される情報とその解釈方法について説明しています。進捗状況のために &lt;code&gt;VACUUM FULL&lt;/code&gt; コマンドで報告され &lt;code&gt;pg_stat_progress_cluster&lt;/code&gt; 両方のために &lt;code&gt;VACUUM FULL&lt;/code&gt; および &lt;code&gt;CLUSTER&lt;/code&gt; は、テーブルを書き換える定期ながら、 &lt;code&gt;VACUUM&lt;/code&gt; は唯一の場所でそれを修正します。&lt;a href=&quot;progress-reporting#CLUSTER-PROGRESS-REPORTING&quot;&gt;セクション27.4.3を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="3fb8592a09f7a3ed7d4104db7d0d68ac3ee490fb" translate="yes" xml:space="preserve">
          <source>Whenever &lt;code&gt;VACUUM&lt;/code&gt; is running, the &lt;code&gt;pg_stat_progress_vacuum&lt;/code&gt; view will contain one row for each backend (including autovacuum worker processes) that is currently vacuuming. The tables below describe the information that will be reported and provide information about how to interpret it. Progress for &lt;code&gt;VACUUM FULL&lt;/code&gt; commands is reported via &lt;code&gt;pg_stat_progress_cluster&lt;/code&gt; because both &lt;code&gt;VACUUM FULL&lt;/code&gt; and &lt;code&gt;CLUSTER&lt;/code&gt; rewrite the table, while regular &lt;code&gt;VACUUM&lt;/code&gt; only modifies it in place. See &lt;a href=&quot;progress-reporting#CLUSTER-PROGRESS-REPORTING&quot;&gt;Section 27.4.4&lt;/a&gt;.</source>
          <target state="translated">Whenever &lt;code&gt;VACUUM&lt;/code&gt; is running, the &lt;code&gt;pg_stat_progress_vacuum&lt;/code&gt; view will contain one row for each backend (including autovacuum worker processes) that is currently vacuuming. The tables below describe the information that will be reported and provide information about how to interpret it. Progress for &lt;code&gt;VACUUM FULL&lt;/code&gt; commands is reported via &lt;code&gt;pg_stat_progress_cluster&lt;/code&gt; because both &lt;code&gt;VACUUM FULL&lt;/code&gt; and &lt;code&gt;CLUSTER&lt;/code&gt; rewrite the table, while regular &lt;code&gt;VACUUM&lt;/code&gt; only modifies it in place. See &lt;a href=&quot;progress-reporting#CLUSTER-PROGRESS-REPORTING&quot;&gt;Section 27.4.4&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="48d664025546cdeafdfe0701b9fa38130d919c75" translate="yes" xml:space="preserve">
          <source>Whenever &lt;code&gt;VACUUM&lt;/code&gt; scans any part of a table, it will replace any multixact ID it encounters which is older than &lt;a href=&quot;runtime-config-client#GUC-VACUUM-MULTIXACT-FREEZE-MIN-AGE&quot;&gt;vacuum_multixact_freeze_min_age&lt;/a&gt; by a different value, which can be the zero value, a single transaction ID, or a newer multixact ID. For each table, &lt;code&gt;pg_class&lt;/code&gt;.&lt;code&gt;relminmxid&lt;/code&gt; stores the oldest possible multixact ID still appearing in any tuple of that table. If this value is older than &lt;a href=&quot;runtime-config-client#GUC-VACUUM-MULTIXACT-FREEZE-TABLE-AGE&quot;&gt;vacuum_multixact_freeze_table_age&lt;/a&gt;, an aggressive vacuum is forced. As discussed in the previous section, an aggressive vacuum means that only those pages which are known to be all-frozen will be skipped. &lt;code&gt;mxid_age()&lt;/code&gt; can be used on &lt;code&gt;pg_class&lt;/code&gt;.&lt;code&gt;relminmxid&lt;/code&gt; to find its age.</source>
          <target state="translated">&lt;code&gt;VACUUM&lt;/code&gt; がテーブルの任意の部分をスキャンするときは常に、&lt;a href=&quot;runtime-config-client#GUC-VACUUM-MULTIXACT-FREEZE-MIN-AGE&quot;&gt;vacuum_multixact_freeze_min_age&lt;/a&gt;より古い、検出されたmultixact IDを、ゼロ値、単一のトランザクションID、または新しいmultixact IDなどの異なる値に置き換えます。テーブルごとに、 &lt;code&gt;pg_class&lt;/code&gt; 。 &lt;code&gt;relminmxid&lt;/code&gt; は、そのテーブルの任意のタプルにまだ表示されている可能な最も古いmultixact IDを格納します。この値が&lt;a href=&quot;runtime-config-client#GUC-VACUUM-MULTIXACT-FREEZE-TABLE-AGE&quot;&gt;vacuum_multixact_freeze_table_age&lt;/a&gt;よりも古い場合、強力なバキュームが強制されます。前のセクションで説明したように、アグレッシブなバキュームとは、すべて凍結されていることがわかっているページのみがスキップされることを意味します。 &lt;code&gt;mxid_age()&lt;/code&gt; は &lt;code&gt;pg_class&lt;/code&gt; で使用できます。 &lt;code&gt;relminmxid&lt;/code&gt; その年齢を見つける。</target>
        </trans-unit>
        <trans-unit id="5f844cc225201cbe85cbdde3d905d07e347e61a8" translate="yes" xml:space="preserve">
          <source>Whenever PostgreSQL needs to combine rows from multiple sources into a single result set, it uses an &lt;code&gt;Append&lt;/code&gt; or &lt;code&gt;MergeAppend&lt;/code&gt; plan node. This commonly happens when implementing &lt;code&gt;UNION ALL&lt;/code&gt; or when scanning a partitioned table. Such nodes can be used in parallel plans just as they can in any other plan. However, in a parallel plan, the planner may instead use a &lt;code&gt;Parallel Append&lt;/code&gt; node.</source>
          <target state="translated">PostgreSQLは、複数のソースからの行を単一の結果セットに組み合わせる必要がある場合は常に、 &lt;code&gt;Append&lt;/code&gt; または &lt;code&gt;MergeAppend&lt;/code&gt; プランノードを使用します。これは通常、 &lt;code&gt;UNION ALL&lt;/code&gt; を実装するとき、または分割テーブルをスキャンするときに発生します。このようなノードは、他のプランと同様に、並列プランで使用できます。ただし、並列プランでは、プランナは代わりに &lt;code&gt;Parallel Append&lt;/code&gt; ノードを使用できます。</target>
        </trans-unit>
        <trans-unit id="85e82d59ea38cfaea7777dbbbcc2b327247984a8" translate="yes" xml:space="preserve">
          <source>Whenever a command is executed, psql also polls for asynchronous notification events generated by &lt;a href=&quot;sql-listen&quot;&gt;LISTEN&lt;/a&gt; and &lt;a href=&quot;sql-notify&quot;&gt;NOTIFY&lt;/a&gt;.</source>
          <target state="translated">コマンドが実行されるたびに、psqlは&lt;a href=&quot;sql-listen&quot;&gt;LISTEN&lt;/a&gt;および&lt;a href=&quot;sql-notify&quot;&gt;NOTIFY&lt;/a&gt;によって生成された非同期通知イベントもポーリングします。</target>
        </trans-unit>
        <trans-unit id="fe283c15f98e1d6878cfeeadd5bbfd6c5078c552" translate="yes" xml:space="preserve">
          <source>Whenever a user-defined type is created, PostgreSQL automatically creates an associated array type, whose name consists of the element type's name prepended with an underscore, and truncated if necessary to keep it less than &lt;code&gt;NAMEDATALEN&lt;/code&gt; bytes long. (If the name so generated collides with an existing type name, the process is repeated until a non-colliding name is found.) This implicitly-created array type is variable length and uses the built-in input and output functions &lt;code&gt;array_in&lt;/code&gt; and &lt;code&gt;array_out&lt;/code&gt;. The array type tracks any changes in its element type's owner or schema, and is dropped if the element type is.</source>
          <target state="translated">ユーザー定義型が作成されるたびに、PostgreSQLは関連付けられた配列型を自動的に作成します。その名前は、要素型の名前の前に下線を付けたもので、 &lt;code&gt;NAMEDATALEN&lt;/code&gt; バイト未満に保つ必要がある場合は切り捨てられます。 （そのように生成された名前が既存のタイプ名と衝突する場合、衝突しない名前が見つかるまでこのプロセスが繰り返されます。）この暗黙的に作成された配列タイプは可変長であり、組み込みの入出力関数 &lt;code&gt;array_in&lt;/code&gt; および &lt;code&gt;array_out&lt;/code&gt; を使用します。配列型は、その要素型の所有者またはスキーマの変更を追跡し、要素型がそうである場合は削除されます。</target>
        </trans-unit>
        <trans-unit id="7c3ae7e94c74ecafe04f858b486a7a8022aa32dd" translate="yes" xml:space="preserve">
          <source>Whenever an application like pg_basebackup is taking a base backup, the &lt;code&gt;pg_stat_progress_basebackup&lt;/code&gt; view will contain a row for each WAL sender process that is currently running the &lt;code&gt;BASE_BACKUP&lt;/code&gt; replication command and streaming the backup. The tables below describe the information that will be reported and provide information about how to interpret it.</source>
          <target state="translated">Whenever an application like pg_basebackup is taking a base backup, the &lt;code&gt;pg_stat_progress_basebackup&lt;/code&gt; view will contain a row for each WAL sender process that is currently running the &lt;code&gt;BASE_BACKUP&lt;/code&gt; replication command and streaming the backup. The tables below describe the information that will be reported and provide information about how to interpret it.</target>
        </trans-unit>
        <trans-unit id="c317e2f18ac74c5065186374d831c55658598512" translate="yes" xml:space="preserve">
          <source>Whenever more than this amount of data has been written by a single backend, attempt to force the OS to issue these writes to the underlying storage. Doing so will limit the amount of dirty data in the kernel's page cache, reducing the likelihood of stalls when an &lt;code&gt;fsync&lt;/code&gt; is issued at the end of a checkpoint, or when the OS writes data back in larger batches in the background. Often that will result in greatly reduced transaction latency, but there also are some cases, especially with workloads that are bigger than &lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt;shared_buffers&lt;/a&gt;, but smaller than the OS's page cache, where performance might degrade. This setting may have no effect on some platforms. If this value is specified without units, it is taken as blocks, that is &lt;code&gt;BLCKSZ&lt;/code&gt; bytes, typically 8kB. The valid range is between &lt;code&gt;0&lt;/code&gt;, which disables forced writeback, and &lt;code&gt;2MB&lt;/code&gt;. The default is &lt;code&gt;0&lt;/code&gt;, i.e., no forced writeback. (If &lt;code&gt;BLCKSZ&lt;/code&gt; is not 8kB, the maximum value scales proportionally to it.)</source>
          <target state="translated">この量を超えるデータが単一のバックエンドによって書き込まれた場合は常に、OSがこれらの書き込みを基盤となるストレージに発行するように強制しようとします。そうすることで、カーネルのページキャッシュ内のダーティデータの量が制限され、チェックポイントの最後に &lt;code&gt;fsync&lt;/code&gt; が発行されたとき、またはOSがバックグラウンドでより大きなバッチでデータを書き戻したときに、ストールの可能性が減少します。多くの場合、これによりトランザクションのレイテンシが大幅に削減されますが、特に、&lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt;shared_buffers&lt;/a&gt;よりも大きく、OSのページキャッシュよりも小さいワークロードでは、パフォーマンスが低下する場合もあります。この設定は、一部のプラットフォームでは効果がない場合があります。この値が単位なしで指定された場合、それはブロック、つまり &lt;code&gt;BLCKSZ&lt;/code&gt; と見なされますバイト、通常8kB。有効な範囲は、 &lt;code&gt;0&lt;/code&gt; （強制ライトバックを無効にする）と &lt;code&gt;2MB&lt;/code&gt; の間です。デフォルトは &lt;code&gt;0&lt;/code&gt; 、つまり強制的な書き戻しはありません。 （ &lt;code&gt;BLCKSZ&lt;/code&gt; が8kBでない場合、最大値はそれに比例してスケーリングされます。）</target>
        </trans-unit>
        <trans-unit id="de89b6016c756123d6b9441e22d55848a32a9ab3" translate="yes" xml:space="preserve">
          <source>Whenever more than this amount of data has been written by the background writer, attempt to force the OS to issue these writes to the underlying storage. Doing so will limit the amount of dirty data in the kernel's page cache, reducing the likelihood of stalls when an &lt;code&gt;fsync&lt;/code&gt; is issued at the end of a checkpoint, or when the OS writes data back in larger batches in the background. Often that will result in greatly reduced transaction latency, but there also are some cases, especially with workloads that are bigger than &lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt;shared_buffers&lt;/a&gt;, but smaller than the OS's page cache, where performance might degrade. This setting may have no effect on some platforms. If this value is specified without units, it is taken as blocks, that is &lt;code&gt;BLCKSZ&lt;/code&gt; bytes, typically 8kB. The valid range is between &lt;code&gt;0&lt;/code&gt;, which disables forced writeback, and &lt;code&gt;2MB&lt;/code&gt;. The default is &lt;code&gt;512kB&lt;/code&gt; on Linux, &lt;code&gt;0&lt;/code&gt; elsewhere. (If &lt;code&gt;BLCKSZ&lt;/code&gt; is not 8kB, the default and maximum values scale proportionally to it.) This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">この量を超えるデータがバックグラウンドライターによって書き込まれた場合は常に、OSに強制的にこれらの書き込みを基盤となるストレージに発行させてください。そうすることで、カーネルのページキャッシュ内のダーティデータの量が制限され、チェックポイントの最後に &lt;code&gt;fsync&lt;/code&gt; が発行されたとき、またはOSがバックグラウンドでより大きなバッチでデータを書き戻したときに、ストールの可能性が減少します。多くの場合、これによりトランザクションのレイテンシが大幅に削減されますが、特に、&lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt;shared_buffers&lt;/a&gt;よりも大きく、OSのページキャッシュよりも小さいワークロードでは、パフォーマンスが低下する場合もあります。この設定は、一部のプラットフォームでは効果がない場合があります。この値が単位なしで指定された場合、それはブロック、つまり &lt;code&gt;BLCKSZ&lt;/code&gt; と見なされますバイト、通常8kB。有効な範囲は、 &lt;code&gt;0&lt;/code&gt; （強制ライトバックを無効にする）と &lt;code&gt;2MB&lt;/code&gt; の間です。Linuxではデフォルトは &lt;code&gt;512kB&lt;/code&gt; 、それ以外では &lt;code&gt;0&lt;/code&gt; です。 （ &lt;code&gt;BLCKSZ&lt;/code&gt; が8kBでない場合、デフォルト値と最大値はそれに比例します。）このパラメーターは、 &lt;code&gt;postgresql.conf&lt;/code&gt; ファイルまたはサーバーのコマンドラインでのみ設定できます。</target>
        </trans-unit>
        <trans-unit id="41035af23763d236bc43d7713084261d3a812120" translate="yes" xml:space="preserve">
          <source>Whenever more than this amount of data has been written while performing a checkpoint, attempt to force the OS to issue these writes to the underlying storage. Doing so will limit the amount of dirty data in the kernel's page cache, reducing the likelihood of stalls when an &lt;code&gt;fsync&lt;/code&gt; is issued at the end of the checkpoint, or when the OS writes data back in larger batches in the background. Often that will result in greatly reduced transaction latency, but there also are some cases, especially with workloads that are bigger than &lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt;shared_buffers&lt;/a&gt;, but smaller than the OS's page cache, where performance might degrade. This setting may have no effect on some platforms. If this value is specified without units, it is taken as blocks, that is &lt;code&gt;BLCKSZ&lt;/code&gt; bytes, typically 8kB. The valid range is between &lt;code&gt;0&lt;/code&gt;, which disables forced writeback, and &lt;code&gt;2MB&lt;/code&gt;. The default is &lt;code&gt;256kB&lt;/code&gt; on Linux, &lt;code&gt;0&lt;/code&gt; elsewhere. (If &lt;code&gt;BLCKSZ&lt;/code&gt; is not 8kB, the default and maximum values scale proportionally to it.) This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">チェックポイントの実行中に、この量を超えるデータが書き込まれた場合は、OSに強制的にこれらの書き込みを基盤となるストレージに発行させてください。そうすることで、カーネルのページキャッシュ内のダーティデータの量が制限され、チェックポイントの最後に &lt;code&gt;fsync&lt;/code&gt; が発行されたとき、またはOSがバックグラウンドで大きなバッチでデータを書き戻したときに停止する可能性が低くなります。多くの場合、これによりトランザクションのレイテンシが大幅に削減されますが、特に、&lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt;shared_buffers&lt;/a&gt;よりも大きく、OSのページキャッシュよりも小さいワークロードでは、パフォーマンスが低下する場合もあります。この設定は、一部のプラットフォームでは効果がない場合があります。この値が単位なしで指定された場合、それはブロック、つまり &lt;code&gt;BLCKSZ&lt;/code&gt; と見なされますバイト、通常8kB。有効な範囲は、 &lt;code&gt;0&lt;/code&gt; （強制ライトバックを無効にする）と &lt;code&gt;2MB&lt;/code&gt; の間です。Linuxではデフォルトは &lt;code&gt;256kB&lt;/code&gt; 、それ以外では &lt;code&gt;0&lt;/code&gt; です。 （ &lt;code&gt;BLCKSZ&lt;/code&gt; が8kBでない場合、デフォルト値と最大値はそれに比例します。）このパラメーターは、 &lt;code&gt;postgresql.conf&lt;/code&gt; ファイルまたはサーバーのコマンドラインでのみ設定できます。</target>
        </trans-unit>
        <trans-unit id="103203b2b9af3babb0455dacf44200f8d0e1dba1" translate="yes" xml:space="preserve">
          <source>Whenever pg_basebackup is taking a base backup, the server's &lt;code&gt;pg_stat_progress_basebackup&lt;/code&gt; view will report the progress of the backup. See &lt;a href=&quot;progress-reporting#BASEBACKUP-PROGRESS-REPORTING&quot;&gt;Section 27.4.5&lt;/a&gt; for details.</source>
          <target state="translated">Whenever pg_basebackup is taking a base backup, the server's &lt;code&gt;pg_stat_progress_basebackup&lt;/code&gt; view will report the progress of the backup. See &lt;a href=&quot;progress-reporting#BASEBACKUP-PROGRESS-REPORTING&quot;&gt;Section 27.4.5&lt;/a&gt; for details.</target>
        </trans-unit>
        <trans-unit id="cafdfe0e40c272ef5695922c2a975f51df9e1cea" translate="yes" xml:space="preserve">
          <source>Whenever the &lt;code&gt;pattern&lt;/code&gt; parameter is omitted completely, the &lt;code&gt;\d&lt;/code&gt; commands display all objects that are visible in the current schema search path &amp;mdash; this is equivalent to using &lt;code&gt;*&lt;/code&gt; as the pattern. (An object is said to be &lt;em&gt;visible&lt;/em&gt; if its containing schema is in the search path and no object of the same kind and name appears earlier in the search path. This is equivalent to the statement that the object can be referenced by name without explicit schema qualification.) To see all objects in the database regardless of visibility, use &lt;code&gt;*.*&lt;/code&gt; as the pattern.</source>
          <target state="translated">&lt;code&gt;pattern&lt;/code&gt; パラメータが完全に省略されている場合は常に、 &lt;code&gt;\d&lt;/code&gt; コマンドは現在のスキーマ検索パスに表示されているすべてのオブジェクトを表示します。これは &lt;code&gt;*&lt;/code&gt; をパターンとして使用することと同じです。 （オブジェクトを含むスキーマが検索パスにあり、同じ種類と名前のオブジェクトが検索パスの前にない場合、オブジェクトは&lt;em&gt;可視で&lt;/em&gt;あると言います。これは、明示的なスキーマなしでオブジェクトを名前で参照できるというステートメントと同等です修飾。）可視性に関係なくデータベース内のすべてのオブジェクトを表示するには、パターンとして &lt;code&gt;*.*&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="2dffd7d6d50f37b1f139649fc2afe46f33411c06" translate="yes" xml:space="preserve">
          <source>Whenever the command &lt;code&gt;NOTIFY channel&lt;/code&gt; is invoked, either by this session or another one connected to the same database, all the sessions currently listening on that notification channel are notified, and each will in turn notify its connected client application.</source>
          <target state="translated">このセッションまたは同じデータベースに接続されている別のセッションのいずれかによってコマンド &lt;code&gt;NOTIFY channel&lt;/code&gt; が呼び出されると、その通知チャネルで現在リッスンしているすべてのセッションが通知され、それぞれが接続されているクライアントアプリケーションに通知します。</target>
        </trans-unit>
        <trans-unit id="464c9a84b9274c416e8217076cf62d6ce77919b2" translate="yes" xml:space="preserve">
          <source>Whenever the role subsequently starts a new session, the specified value becomes the session default, overriding whatever setting is present in &lt;code&gt;postgresql.conf&lt;/code&gt; or has been received from the &lt;code&gt;postgres&lt;/code&gt; command line. This only happens at login time; executing &lt;a href=&quot;sql-set-role&quot;&gt;SET ROLE&lt;/a&gt; or &lt;a href=&quot;sql-set-session-authorization&quot;&gt;SET SESSION AUTHORIZATION&lt;/a&gt; does not cause new configuration values to be set. Settings set for all databases are overridden by database-specific settings attached to a role. Settings for specific databases or specific roles override settings for all roles.</source>
          <target state="translated">その後、ロールが新しいセッションを開始するたびに、指定された値がセッションのデフォルトになり、 &lt;code&gt;postgresql.conf&lt;/code&gt; に存在する設定または &lt;code&gt;postgres&lt;/code&gt; コマンドラインから受け取った設定を上書きします。これはログイン時にのみ発生します。&lt;a href=&quot;sql-set-role&quot;&gt;SET ROLE&lt;/a&gt;または&lt;a href=&quot;sql-set-session-authorization&quot;&gt;SET SESSION AUTHORIZATIONを&lt;/a&gt;実行しても、新しい構成値は設定されません。すべてのデータベースに設定された設定は、ロールにアタッチされたデータベース固有の設定によって上書きされます。特定のデータベースまたは特定のロールの設定は、すべてのロールの設定を上書きします。</target>
        </trans-unit>
        <trans-unit id="1cb07a399aec26555c15e193c16effe1e79f48af" translate="yes" xml:space="preserve">
          <source>Whenever you create a table, a composite type is also automatically created, with the same name as the table, to represent the table's row type. For example, had we said:</source>
          <target state="translated">テーブルを作成すると、テーブルと同じ名前の複合型も自動的に作成され、テーブルの行の型を表します。例えば、私たちが言っていたのは</target>
        </trans-unit>
        <trans-unit id="72417af150626f41547b564cc2af3102889d282f" translate="yes" xml:space="preserve">
          <source>Whenever you have significantly altered the distribution of data within a table, running &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt; is strongly recommended. This includes bulk loading large amounts of data into the table. Running &lt;code&gt;ANALYZE&lt;/code&gt; (or &lt;code&gt;VACUUM ANALYZE&lt;/code&gt;) ensures that the planner has up-to-date statistics about the table. With no statistics or obsolete statistics, the planner might make poor decisions during query planning, leading to poor performance on any tables with inaccurate or nonexistent statistics. Note that if the autovacuum daemon is enabled, it might run &lt;code&gt;ANALYZE&lt;/code&gt; automatically; see &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-STATISTICS&quot;&gt;Section 24.1.3&lt;/a&gt; and &lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;Section 24.1.6&lt;/a&gt; for more information.</source>
          <target state="translated">テーブル内のデータの分布を大幅に変更した場合は、&lt;a href=&quot;sql-analyze&quot;&gt;ANALYZEを&lt;/a&gt;実行することを強くお勧めします。これには、テーブルへの大量のデータの一括読み込みが含まれます。実行 &lt;code&gt;ANALYZE&lt;/code&gt; （または &lt;code&gt;VACUUM ANALYZE&lt;/code&gt; は）プランナがテーブルに関する最新の統計情報を持っていることを保証します。統計がないか古い統計があると、プランナはクエリの計画中に誤った決定を下し、統計が不正確または存在しないテーブルのパフォーマンスが低下する可能性があります。 autovacuumデーモンが有効になっている場合、 &lt;code&gt;ANALYZE&lt;/code&gt; が自動的に実行される可能性があることに注意してください。詳細は、&lt;a href=&quot;routine-vacuuming#VACUUM-FOR-STATISTICS&quot;&gt;セクション24.1.3&lt;/a&gt;および&lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;セクション24.1.6&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="70267c330cb08a0ff5a2a298e316262a59a144c4" translate="yes" xml:space="preserve">
          <source>Where interoperability with other systems is a concern, for some data types, it may be necessary to use data type formatting functions (such as those in &lt;a href=&quot;functions-formatting&quot;&gt;Section 9.8&lt;/a&gt;) explicitly to produce the standard mappings.</source>
          <target state="translated">他のシステムとの相互運用性が懸念される場合、一部のデータ型では、標準のマッピングを作成するためにデータ型フォーマット関数（&lt;a href=&quot;functions-formatting&quot;&gt;セクション9.8の&lt;/a&gt;関数など）を明示的に使用する必要がある場合があります。</target>
        </trans-unit>
        <trans-unit id="de87765a2f74958f3598da9f1ae5cd4df124304a" translate="yes" xml:space="preserve">
          <source>Where the command omits database name, user, host, or port, the new connection can reuse values from the previous connection. By default, values from the previous connection are reused except when processing a &lt;code&gt;conninfo&lt;/code&gt; string. Passing a first argument of &lt;code&gt;-reuse-previous=on&lt;/code&gt; or &lt;code&gt;-reuse-previous=off&lt;/code&gt; overrides that default. When the command neither specifies nor reuses a particular parameter, the libpq default is used. Specifying any of &lt;code&gt;dbname&lt;/code&gt;, &lt;code&gt;username&lt;/code&gt;, &lt;code&gt;host&lt;/code&gt; or &lt;code&gt;port&lt;/code&gt; as &lt;code&gt;-&lt;/code&gt; is equivalent to omitting that parameter. If &lt;code&gt;hostaddr&lt;/code&gt; was specified in the original connection's &lt;code&gt;conninfo&lt;/code&gt;, that address is reused for the new connection (disregarding any other host specification).</source>
          <target state="translated">コマンドがデータベース名、ユーザー、ホスト、またはポートを省略している場合、新しい接続は以前の接続の値を再利用できます。デフォルトでは、 &lt;code&gt;conninfo&lt;/code&gt; 文字列を処理する場合を除いて、以前の接続の値が再利用されます。 &lt;code&gt;-reuse-previous=on&lt;/code&gt; または &lt;code&gt;-reuse-previous=off&lt;/code&gt; の最初の引数を渡すと、そのデフォルトが上書きされます。コマンドが特定のパラメーターを指定も再利用もしない場合、libpqのデフォルトが使用されます。 &lt;code&gt;dbname&lt;/code&gt; 、 &lt;code&gt;username&lt;/code&gt; 、 &lt;code&gt;host&lt;/code&gt; または &lt;code&gt;port&lt;/code&gt; のいずれかを &lt;code&gt;-&lt;/code&gt; として指定することは、そのパラメーターを省略することと同じです。元の接続の &lt;code&gt;conninfo&lt;/code&gt; で &lt;code&gt;hostaddr&lt;/code&gt; が指定されていた場合、そのアドレスは新しい接続に再利用されます（他のホスト指定は無視されます）。</target>
        </trans-unit>
        <trans-unit id="f9b1968453a400f5fd07425f7b52ed24d9c6b52b" translate="yes" xml:space="preserve">
          <source>Where the current standard provides a family of XML data types to hold &amp;ldquo;document&amp;rdquo; or &amp;ldquo;content&amp;rdquo; in untyped or XML Schema-typed variants, and a type &lt;code&gt;XML(SEQUENCE)&lt;/code&gt; to hold arbitrary pieces of XML content, PostgreSQL provides the single &lt;code&gt;xml&lt;/code&gt; type, which can hold &amp;ldquo;document&amp;rdquo; or &amp;ldquo;content&amp;rdquo;. There is no equivalent of the standard's &amp;ldquo;sequence&amp;rdquo; type.</source>
          <target state="translated">現在の標準が、型なしまたはXMLスキーマ型のバリアントで「ドキュメント」または「コンテンツ」を保持するXMLデータ型のファミリーと、XMLコンテンツの任意の部分を保持する &lt;code&gt;XML(SEQUENCE)&lt;/code&gt; 型を提供する場合、PostgreSQLは単一の &lt;code&gt;xml&lt;/code&gt; 型を提供します、「ドキュメント」または「コンテンツ」を保持できます。標準の「シーケンス」タイプに相当するものはありません。</target>
        </trans-unit>
        <trans-unit id="9be0ce89e49423198dedc7c03fd710b9a77c7468" translate="yes" xml:space="preserve">
          <source>Whereas &lt;code&gt;pgstattuple&lt;/code&gt; always performs a full-table scan and returns an exact count of live and dead tuples (and their sizes) and free space, &lt;code&gt;pgstattuple_approx&lt;/code&gt; tries to avoid the full-table scan and returns exact dead tuple statistics along with an approximation of the number and size of live tuples and free space.</source>
          <target state="translated">一方 &lt;code&gt;pgstattuple&lt;/code&gt; は常にフルテーブルスキャンとリターンの正確なライブや死んだタプルの数（とそのサイズ）と空き領域、実行 &lt;code&gt;pgstattuple_approx&lt;/code&gt; の数の近似値と一緒にフルテーブルスキャンおよびリターン正確な死者のタプル統計を回避しようとしますライブタプルと空き容量のサイズ。</target>
        </trans-unit>
        <trans-unit id="9ec341d8bc6b0b4825eb80f0ff91c4f3ae8eee3b" translate="yes" xml:space="preserve">
          <source>Whether &lt;code&gt;aggfinalfn&lt;/code&gt; modifies the transition state value: &lt;code&gt;r&lt;/code&gt; if it is read-only, &lt;code&gt;s&lt;/code&gt; if the &lt;code&gt;aggtransfn&lt;/code&gt; cannot be applied after the &lt;code&gt;aggfinalfn&lt;/code&gt;, or &lt;code&gt;w&lt;/code&gt; if it writes on the value</source>
          <target state="translated">か &lt;code&gt;aggfinalfn&lt;/code&gt; 修正遷移状態値： &lt;code&gt;r&lt;/code&gt; それは読み取り専用の場合、 &lt;code&gt;s&lt;/code&gt; の場合 &lt;code&gt;aggtransfn&lt;/code&gt; の後に適用することができない &lt;code&gt;aggfinalfn&lt;/code&gt; 、または &lt;code&gt;w&lt;/code&gt; の場合には値を書き込みます。</target>
        </trans-unit>
        <trans-unit id="b63ddfd6a1548ba35d00a888f441158a5e09419b" translate="yes" xml:space="preserve">
          <source>Whether an RE is greedy or not is determined by the following rules:</source>
          <target state="translated">REが欲張りかどうかは、以下のルールで決まります。</target>
        </trans-unit>
        <trans-unit id="a052d21cc109877e0a34f6fceb8177147b8e054e" translate="yes" xml:space="preserve">
          <source>Whether the sequence cycles</source>
          <target state="translated">シーケンスサイクルの有無</target>
        </trans-unit>
        <trans-unit id="099ca603e257bb42c8d0080a36e8a200732df4c1" translate="yes" xml:space="preserve">
          <source>Whether to convert &lt;code&gt;\n&lt;/code&gt; into &lt;code&gt;\r\n&lt;/code&gt; when encrypting and &lt;code&gt;\r\n&lt;/code&gt; to &lt;code&gt;\n&lt;/code&gt; when decrypting. RFC 4880 specifies that text data should be stored using &lt;code&gt;\r\n&lt;/code&gt; line-feeds. Use this to get fully RFC-compliant behavior.</source>
          <target state="translated">暗号化時に &lt;code&gt;\n&lt;/code&gt; を &lt;code&gt;\r\n&lt;/code&gt; 、復号化時に &lt;code&gt;\r\n&lt;/code&gt; を &lt;code&gt;\n&lt;/code&gt; に変換するかどうか。 RFC 4880では、テキストデータは &lt;code&gt;\r\n&lt;/code&gt; 改行を使用して保存するように規定されています。これを使用して、完全にRFC準拠の動作を取得します。</target>
        </trans-unit>
        <trans-unit id="6a913bec72a9d1cd9190d3ca3274a90d4c381b09" translate="yes" xml:space="preserve">
          <source>Whether to convert textual data from database internal encoding to UTF-8 and back. If your database already is UTF-8, no conversion will be done, but the message will be tagged as UTF-8. Without this option it will not be.</source>
          <target state="translated">データベースの内部エンコーディングからテキストデータをUTF-8に変換して戻すかどうか。データベースが既にUTF-8の場合、変換は行われませんが、メッセージはUTF-8としてタグ付けされます。このオプションがない場合は、変換されません。</target>
        </trans-unit>
        <trans-unit id="5d0908bbd26e431175b3928caa067e2b55410af7" translate="yes" xml:space="preserve">
          <source>Which S2K algorithm to use.</source>
          <target state="translated">どのS2Kアルゴリズムを使うか。</target>
        </trans-unit>
        <trans-unit id="1b435ac17c99f4ed78933b5d05d5b47d3dfdd820" translate="yes" xml:space="preserve">
          <source>Which cipher algorithm to use.</source>
          <target state="translated">どの暗号アルゴリズムを使うか</target>
        </trans-unit>
        <trans-unit id="4215d6c5a786cf08cc1b93732554ac25c2ba7716" translate="yes" xml:space="preserve">
          <source>Which cipher to use for encrypting separate session key.</source>
          <target state="translated">別々のセッション鍵を暗号化するためにどの暗号を使用するか。</target>
        </trans-unit>
        <trans-unit id="8c9643312802b96a36d211d4bd8a2d4fbec5df7d" translate="yes" xml:space="preserve">
          <source>Which compression algorithm to use. Only available if PostgreSQL was built with zlib.</source>
          <target state="translated">どの圧縮アルゴリズムを使用するか。PostgreSQLがzlibで構築されている場合のみ利用可能です。</target>
        </trans-unit>
        <trans-unit id="36178694d36e0d8b9b4d6953d14f4cb84f698946" translate="yes" xml:space="preserve">
          <source>Which digest algorithm to use in S2K calculation.</source>
          <target state="translated">S2Kの計算で使用するダイジェストアルゴリズムはどれか。</target>
        </trans-unit>
        <trans-unit id="5b9d8c9d7eb5636216a755086b48fa5a8cd067ff" translate="yes" xml:space="preserve">
          <source>Which one of these you use is mainly a matter of style. The &lt;code&gt;JOIN&lt;/code&gt; syntax in the &lt;code&gt;FROM&lt;/code&gt; clause is probably not as portable to other SQL database management systems, even though it is in the SQL standard. For outer joins there is no choice: they must be done in the &lt;code&gt;FROM&lt;/code&gt; clause. The &lt;code&gt;ON&lt;/code&gt; or &lt;code&gt;USING&lt;/code&gt; clause of an outer join is &lt;em&gt;not&lt;/em&gt; equivalent to a &lt;code&gt;WHERE&lt;/code&gt; condition, because it results in the addition of rows (for unmatched input rows) as well as the removal of rows in the final result.</source>
          <target state="translated">これらのどれを使用するかは、主にスタイルの問題です。 &lt;code&gt;FROM&lt;/code&gt; 句の &lt;code&gt;JOIN&lt;/code&gt; 構文は、SQL標準に含まれていても、他のSQLデータベース管理システムに移植することはおそらくできません。外部結合の場合、選択肢はありません &lt;code&gt;FROM&lt;/code&gt; 句で行う必要があります。外部結合の &lt;code&gt;ON&lt;/code&gt; 句または &lt;code&gt;USING&lt;/code&gt; 句は &lt;code&gt;WHERE&lt;/code&gt; 条件と同等ではあり&lt;em&gt;ません。&lt;/em&gt;これにより、（一致しない入力行の）行が追加され、最終結果の行が削除されるためです。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f207dff92fd241726ec3f780d5ff085d75648337" translate="yes" xml:space="preserve">
          <source>Which particular operators exist and whether they are unary or binary depends on what operators have been defined by the system or the user. &lt;a href=&quot;https://www.postgresql.org/docs/12/functions.html&quot;&gt;Chapter 9&lt;/a&gt; describes the built-in operators.</source>
          <target state="translated">存在する特定の演算子と、それらが単項か二項かは、システムまたはユーザーが定義した演算子によって異なります。&lt;a href=&quot;https://www.postgresql.org/docs/12/functions.html&quot;&gt;第9章で&lt;/a&gt;は、組み込み演算子について説明します。</target>
        </trans-unit>
        <trans-unit id="6b60d8de1898a75db9c84423bdbee981b013228e" translate="yes" xml:space="preserve">
          <source>Which particular operators exist and whether they are unary or binary depends on what operators have been defined by the system or the user. &lt;a href=&quot;https://www.postgresql.org/docs/13/functions.html&quot;&gt;Chapter 9&lt;/a&gt; describes the built-in operators.</source>
          <target state="translated">Which particular operators exist and whether they are unary or binary depends on what operators have been defined by the system or the user. &lt;a href=&quot;https://www.postgresql.org/docs/13/functions.html&quot;&gt;Chapter 9&lt;/a&gt; describes the built-in operators.</target>
        </trans-unit>
        <trans-unit id="8189028b5d12d59cd50147d702e5a513253a68c3" translate="yes" xml:space="preserve">
          <source>Which row(s) to update</source>
          <target state="translated">どの行を更新するか</target>
        </trans-unit>
        <trans-unit id="a8a5e55dc1620d200691892efc7a7c676cbd8264" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;CREATE INDEX&lt;/code&gt; with the &lt;code&gt;CONCURRENTLY&lt;/code&gt; option supports parallel builds without special restrictions, only the first table scan is actually performed in parallel.</source>
          <target state="translated">一方で &lt;code&gt;CREATE INDEX&lt;/code&gt; し &lt;code&gt;CONCURRENTLY&lt;/code&gt; オプションがサポート平行な特別な制限なしで構築し、最初のテーブルスキャンが実際に並行して行われます。</target>
        </trans-unit>
        <trans-unit id="714b73638a1ef948dee8dfe7820683df70955357" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;UNIQUE&lt;/code&gt; is a natural constraint for scalar values, it is usually unsuitable for range types. Instead, an exclusion constraint is often more appropriate (see &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-EXCLUDE&quot;&gt;CREATE TABLE ... CONSTRAINT ... EXCLUDE&lt;/a&gt;). Exclusion constraints allow the specification of constraints such as &amp;ldquo;non-overlapping&amp;rdquo; on a range type. For example:</source>
          <target state="translated">一方で &lt;code&gt;UNIQUE&lt;/code&gt; は、スカラー値のための自然な制約である、それはレンジタイプのため、通常は不向きです。代わりに、多くの場合、除外制約がより適切です（&lt;a href=&quot;sql-createtable#SQL-CREATETABLE-EXCLUDE&quot;&gt;CREATE TABLE ... CONSTRAINT ... EXCLUDEを&lt;/a&gt;参照）。除外制約により、範囲タイプの「重複しない」などの制約を指定できます。例えば：</target>
        </trans-unit>
        <trans-unit id="4a9577e86cf0dfccc12f0ecf60188a3b6040e454" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;pg_resetwal&lt;/code&gt; will set the WAL starting address beyond the latest existing WAL segment file, some segment size changes can cause previous WAL file names to be reused. It is recommended to use &lt;code&gt;-l&lt;/code&gt; together with this option to manually set the WAL starting address if WAL file name overlap will cause problems with your archiving strategy.</source>
          <target state="translated">一方で &lt;code&gt;pg_resetwal&lt;/code&gt; は最新の既存のWALセグメントファイルを超えたWAL開始アドレスを設定しますが、いくつかのセグメントサイズの変更は、以前のWALファイル名が再利用されることがあります。WALファイル名の重複によりアーカイブ戦略に問題が発生する場合は、このオプションと &lt;code&gt;-l&lt;/code&gt; を併用してWALの開始アドレスを手動で設定することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="01708a73847573f321d3d2da0f455cb9f949df75" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;to_date&lt;/code&gt; will reject a mixture of Gregorian and ISO week-numbering date fields, &lt;code&gt;to_char&lt;/code&gt; will not, since output format specifications like &lt;code&gt;YYYY-MM-DD (IYYY-IDDD)&lt;/code&gt; can be useful. But avoid writing something like &lt;code&gt;IYYY-MM-DD&lt;/code&gt;; that would yield surprising results near the start of the year. (See &lt;a href=&quot;functions-datetime#FUNCTIONS-DATETIME-EXTRACT&quot;&gt;Section 9.9.1&lt;/a&gt; for more information.)</source>
          <target state="translated">一方で &lt;code&gt;to_date&lt;/code&gt; グレゴリオ暦とISO週番号日付フィールドの混合物を拒絶する、 &lt;code&gt;to_char&lt;/code&gt; 関数は、出力形式以降のような仕様ではないでしょう &lt;code&gt;YYYY-MM-DD (IYYY-IDDD)&lt;/code&gt; 便利です。ただし、 &lt;code&gt;IYYY-MM-DD&lt;/code&gt; などの記述は避けてください。それは年の初め近くに驚くべき結果をもたらすでしょう。（詳細については、&lt;a href=&quot;functions-datetime#FUNCTIONS-DATETIME-EXTRACT&quot;&gt;セクション9.9.1&lt;/a&gt;を参照してください。）</target>
        </trans-unit>
        <trans-unit id="e362e9f328b5aa2d887a4c59191ea1b7f9721dc4" translate="yes" xml:space="preserve">
          <source>While C-style block comments are passed to the server for processing and removal, SQL-standard comments are removed by psql.</source>
          <target state="translated">Cスタイルのブロックコメントは処理と削除のためにサーバに渡されますが、SQL標準のコメントはpsqlによって削除されます。</target>
        </trans-unit>
        <trans-unit id="5d725442e0975d9459afb2abfae7302730928d6f" translate="yes" xml:space="preserve">
          <source>While PostgreSQL's Serializable transaction isolation level only allows concurrent transactions to commit if it can prove there is a serial order of execution that would produce the same effect, it doesn't always prevent errors from being raised that would not occur in true serial execution. In particular, it is possible to see unique constraint violations caused by conflicts with overlapping Serializable transactions even after explicitly checking that the key isn't present before attempting to insert it. This can be avoided by making sure that &lt;em&gt;all&lt;/em&gt; Serializable transactions that insert potentially conflicting keys explicitly check if they can do so first. For example, imagine an application that asks the user for a new key and then checks that it doesn't exist already by trying to select it first, or generates a new key by selecting the maximum existing key and adding one. If some Serializable transactions insert new keys directly without following this protocol, unique constraints violations might be reported even in cases where they could not occur in a serial execution of the concurrent transactions.</source>
          <target state="translated">PostgreSQLのSerializableトランザクション分離レベルでは、同じ効果を生み出す実行のシリアル順序があることが証明できる場合にのみ、同時トランザクションのコミットが許可されますが、実際のシリアル実行では発生しないエラーの発生を必ずしも防ぐわけではありません。特に、挿入しようとする前にキーが存在しないことを明示的にチェックした後でも、重複するSerializableトランザクションとの競合によって引き起こされる一意の制約違反を確認できます。これは、&lt;em&gt;すべての&lt;/em&gt;競合する可能性のあるキーを挿入するシリアライズ可能なトランザクションは、最初に可能かどうかを明示的にチェックします。たとえば、ユーザーに新しいキーを要求し、最初にそれを選択して既存のものではないことを確認するアプリケーション、または最大の既存のキーを選択して追加することによって新しいキーを生成するアプリケーションを想像してください。一部のSerializableトランザクションがこのプロトコルに従わずに新しいキーを直接挿入する場合、同時トランザクションのシリアル実行で発生しなかった場合でも、一意の制約違反が報告されることがあります。</target>
        </trans-unit>
        <trans-unit id="594dab457c5441b59c42227020751df6f6f62a48" translate="yes" xml:space="preserve">
          <source>While XQuery/XPath provides all of the types defined in XML Schema and many operators and functions over those types, XPath 1.0 has only node-sets and the three atomic types &lt;code&gt;boolean&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, and &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">XQuery / XPathはXMLスキーマで定義されたすべてのタイプとそれらのタイプに対する多くの演算子と関数を提供しますが、XPath 1.0にはノードセットと3つのアトミックタイプ &lt;code&gt;boolean&lt;/code&gt; 、 &lt;code&gt;double&lt;/code&gt; 、および &lt;code&gt;string&lt;/code&gt; しかありません。</target>
        </trans-unit>
        <trans-unit id="4a627fd0ca096f765ec57a0f53e97d18839b3a4e" translate="yes" xml:space="preserve">
          <source>While a &lt;code&gt;LIKE&lt;/code&gt; clause exists in the SQL standard, many of the options that PostgreSQL accepts for it are not in the standard, and some of the standard's options are not implemented by PostgreSQL.</source>
          <target state="translated">一方で &lt;code&gt;LIKE&lt;/code&gt; の句は、SQL標準で存在する、PostgreSQLはそれを受け入れることのオプションの多くは、標準ではなく、標準のオプションのいくつかはPostgreSQLで実装されていません。</target>
        </trans-unit>
        <trans-unit id="bcdd2fd3f430f1ca01d2b3670c0f594bdee786bb" translate="yes" xml:space="preserve">
          <source>While a Repeatable Read transaction has a stable view of the data throughout its execution, there is a subtle issue with using MVCC snapshots for data consistency checks, involving something known as &lt;em&gt;read/write conflicts&lt;/em&gt;. If one transaction writes data and a concurrent transaction attempts to read the same data (whether before or after the write), it cannot see the work of the other transaction. The reader then appears to have executed first regardless of which started first or which committed first. If that is as far as it goes, there is no problem, but if the reader also writes data which is read by a concurrent transaction there is now a transaction which appears to have run before either of the previously mentioned transactions. If the transaction which appears to have executed last actually commits first, it is very easy for a cycle to appear in a graph of the order of execution of the transactions. When such a cycle appears, integrity checks will not work correctly without some help.</source>
          <target state="translated">反復可能読み取りトランザクションは、その実行全体を通じてデータの安定したビューを持っていますが、データの整合性チェックにMVCCスナップショットを使用すると、&lt;em&gt;読み取り/書き込みの競合と&lt;/em&gt;呼ばれるものを含む、微妙な問題があります&lt;em&gt;&lt;/em&gt;。 1つのトランザクションがデータを書き込み、並行トランザクションが同じデータを読み取ろうとした場合（書き込みの前でも後でも）、他のトランザクションの動作を確認できません。リーダーは、どちらが最初に開始されたか、どちらが最初にコミットされたかに関係なく、最初に実行されたように見えます。それが可能な限り問題はありませんが、同時トランザクションによって読み取られるデータもリーダーが書き込む場合は、前述のトランザクションの前に実行されたように見えるトランザクションがあります。最後に実行されたように見えるトランザクションが実際に最初にコミットする場合、トランザクションの実行順序のグラフにサイクルが現れるのは非常に簡単です。このようなサイクルが発生した場合、整合性チェックは何らかの助けなしでは正しく機能しません。</target>
        </trans-unit>
        <trans-unit id="6a87fa7f9afe44920c1e825c81201c0429df3a1c" translate="yes" xml:space="preserve">
          <source>While a self-signed certificate can be used for testing, a certificate signed by a certificate authority (CA) (usually an enterprise-wide root CA) should be used in production.</source>
          <target state="translated">自己署名証明書はテストに使用することができますが、証明書局(CA)(通常は企業全体のルートCA)が署名した証明書を本番で使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="cdc31b216171332e350cb9df34dfb0418ab3630e" translate="yes" xml:space="preserve">
          <source>While designing your archiving setup, consider what will happen if the archive command fails repeatedly because some aspect requires operator intervention or the archive runs out of space. For example, this could occur if you write to tape without an autochanger; when the tape fills, nothing further can be archived until the tape is swapped. You should ensure that any error condition or request to a human operator is reported appropriately so that the situation can be resolved reasonably quickly. The &lt;code&gt;pg_wal/&lt;/code&gt; directory will continue to fill with WAL segment files until the situation is resolved. (If the file system containing &lt;code&gt;pg_wal/&lt;/code&gt; fills up, PostgreSQL will do a PANIC shutdown. No committed transactions will be lost, but the database will remain offline until you free some space.)</source>
          <target state="translated">アーカイブのセットアップを設計するときは、いくつかの側面でオペレーターの介入が必要になるか、アーカイブのスペースが不足するため、archiveコマンドが繰り返し失敗した場合にどうなるかを検討してください。たとえば、オートチェンジャなしでテープに書き込む場合に発生する可能性があります。テープがいっぱいになると、テープが交換されるまで、これ以上アーカイブできません。状況を合理的に迅速に解決できるように、エラー状態やオペレーターへの要求が適切に報告されるようにする必要があります。 &lt;code&gt;pg_wal/&lt;/code&gt; ディレクトリには、状況が解決されるまで、WALセグメントファイルに記入していきます。 （ &lt;code&gt;pg_wal/&lt;/code&gt; を含むファイルシステムがいっぱいになると、PostgreSQLはPANICシャットダウンを実行します。コミットされたトランザクションは失われませんが、データベースは空き容量ができるまでオフラインのままです。）</target>
        </trans-unit>
        <trans-unit id="ed48d255fcc854a30e92ea66bfc2714ea9b2abf4" translate="yes" xml:space="preserve">
          <source>While forcing data to the disk platters periodically might seem like a simple operation, it is not. Because disk drives are dramatically slower than main memory and CPUs, several layers of caching exist between the computer's main memory and the disk platters. First, there is the operating system's buffer cache, which caches frequently requested disk blocks and combines disk writes. Fortunately, all operating systems give applications a way to force writes from the buffer cache to disk, and PostgreSQL uses those features. (See the &lt;a href=&quot;runtime-config-wal#GUC-WAL-SYNC-METHOD&quot;&gt;wal_sync_method&lt;/a&gt; parameter to adjust how this is done.)</source>
          <target state="translated">定期的にデータをディスクプラッタに強制することは、単純な操作のように思えるかもしれませんが、そうではありません。ディスクドライブはメインメモリやCPUよりも劇的に遅いため、コンピューターのメインメモリとディスクプラッターの間にいくつかのキャッシュ層が存在します。まず、オペレーティングシステムのバッファキャッシュがあります。これは、頻繁に要求されるディスクブロックをキャッシュし、ディスクの書き込みを組み合わせます。幸い、すべてのオペレーティングシステムは、アプリケーションにバッファキャッシュからディスクへの書き込みを強制する方法を提供し、PostgreSQLはそれらの機能を使用します。 （これがどのように行われるかを調整するには、&lt;a href=&quot;runtime-config-wal#GUC-WAL-SYNC-METHOD&quot;&gt;wal_sync_method&lt;/a&gt;パラメーターを参照してください。）</target>
        </trans-unit>
        <trans-unit id="ae2f9725af5b866105aef02d826c3c21674b82a5" translate="yes" xml:space="preserve">
          <source>While it is possible to obtain information about which processes block which other processes by joining &lt;code&gt;pg_locks&lt;/code&gt; against itself, this is very difficult to get right in detail. Such a query would have to encode knowledge about which lock modes conflict with which others. Worse, the &lt;code&gt;pg_locks&lt;/code&gt; view does not expose information about which processes are ahead of which others in lock wait queues, nor information about which processes are parallel workers running on behalf of which other client sessions. It is better to use the &lt;code&gt;pg_blocking_pids()&lt;/code&gt; function (see &lt;a href=&quot;functions-info#FUNCTIONS-INFO-SESSION-TABLE&quot;&gt;Table 9.63&lt;/a&gt;) to identify which process(es) a waiting process is blocked behind.</source>
          <target state="translated">&lt;code&gt;pg_locks&lt;/code&gt; をそれ自体に対して結合することにより、どのプロセスが他のどのプロセスをブロックするかについての情報を取得することは可能ですが、これを詳細に理解することは非常に困難です。このようなクエリでは、どのロックモードが他のどのロックモードと競合するかについての知識をエンコードする必要があります。さらに悪いことに、 &lt;code&gt;pg_locks&lt;/code&gt; ビューは、どのプロセスがロック待機キュー内の他のプロセスよりも進んでいるか、どのプロセスが他のどのクライアントセッションに代わって実行されている並列ワーカーであるかについての情報を公開しません。 &lt;code&gt;pg_blocking_pids()&lt;/code&gt; 関数（&lt;a href=&quot;functions-info#FUNCTIONS-INFO-SESSION-TABLE&quot;&gt;表9.63を&lt;/a&gt;参照）を使用して、待機中のプロセスがブロックされているプロセスを特定することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="17d114999ab92dc3c41f0deae7314e26f77d91d6" translate="yes" xml:space="preserve">
          <source>While most regular-expression searches can be executed very quickly, regular expressions can be contrived that take arbitrary amounts of time and memory to process. Be wary of accepting regular-expression search patterns from hostile sources. If you must do so, it is advisable to impose a statement timeout.</source>
          <target state="translated">ほとんどの正規表現検索は非常に速く実行できますが、正規表現は処理に任意の量の時間とメモリを必要とすることがあります。敵対的なソースから正規表現検索パターンを受け入れることには注意が必要です。どうしてもそうしなければならない場合は、文のタイムアウトを課すことをお勧めします。</target>
        </trans-unit>
        <trans-unit id="4544bbaee7531ef45a0e42c59e09a0908293364f" translate="yes" xml:space="preserve">
          <source>While most timezone abbreviations represent fixed offsets from UTC, there are some that have historically varied in value (see &lt;a href=&quot;datetime-config-files&quot;&gt;Section B.4&lt;/a&gt; for more information). In such cases this view presents their current meaning.</source>
          <target state="translated">ほとんどのタイムゾーン省略形はUTCからの固定オフセットを表しますが、値が歴史的に変化しているものもあります（詳細については、&lt;a href=&quot;datetime-config-files&quot;&gt;セクションB.4&lt;/a&gt;を参照）。このような場合、このビューは現在の意味を示します。</target>
        </trans-unit>
        <trans-unit id="eb000322f7d40100b6e53cb7562cee4c2935cc07" translate="yes" xml:space="preserve">
          <source>While multiple databases can be created within a single cluster, it is advised to consider carefully whether the benefits outweigh the risks and limitations. In particular, the impact that having a shared WAL (see &lt;a href=&quot;https://www.postgresql.org/docs/13/wal.html&quot;&gt;Chapter 29&lt;/a&gt;) has on backup and recovery options. While individual databases in the cluster are isolated when considered from the user's perspective, they are closely bound from the database administrator's point-of-view.</source>
          <target state="translated">While multiple databases can be created within a single cluster, it is advised to consider carefully whether the benefits outweigh the risks and limitations. In particular, the impact that having a shared WAL (see &lt;a href=&quot;https://www.postgresql.org/docs/13/wal.html&quot;&gt;Chapter 29&lt;/a&gt;) has on backup and recovery options. While individual databases in the cluster are isolated when considered from the user's perspective, they are closely bound from the database administrator's point-of-view.</target>
        </trans-unit>
        <trans-unit id="64e20acb9a4d1b2d1994838c4133180e7c30312a" translate="yes" xml:space="preserve">
          <source>While not required, it is recommended that you continue to follow this old convention of naming cast implementation functions after the target data type. Many users are used to being able to cast data types using a function-style notation, that is &lt;code&gt;typename&lt;/code&gt;(&lt;code&gt;x&lt;/code&gt;). This notation is in fact nothing more nor less than a call of the cast implementation function; it is not specially treated as a cast. If your conversion functions are not named to support this convention then you will have surprised users. Since PostgreSQL allows overloading of the same function name with different argument types, there is no difficulty in having multiple conversion functions from different types that all use the target type's name.</source>
          <target state="translated">必須ではありませんが、キャストの実装関数にターゲットデータ型の後に名前を付けるというこの古い規則に従うことをお勧めします。多くのユーザーは、関数名表記（ &lt;code&gt;typename&lt;/code&gt; （ &lt;code&gt;x&lt;/code&gt; ））を使用してデータ型をキャストできることに慣れています。この表記は、実際にはキャスト実装関数の呼び出しにすぎません。それは特別にキャストとして扱われません。この変換をサポートするように変換関数の名前が付けられていない場合、ユーザーを驚かせることになります。 PostgreSQLでは、引数の型が異なる同じ関数名をオーバーロードできるため、ターゲット型の名前をすべて使用する異なる型からの複数の変換関数を作成することは困難ではありません。</target>
        </trans-unit>
        <trans-unit id="9e3fedf4b54ce85919b4142394d398f5b611a696" translate="yes" xml:space="preserve">
          <source>While policies will be applied for explicit queries against tables in the database, they are not applied when the system is performing internal referential integrity checks or validating constraints. This means there are indirect ways to determine that a given value exists. An example of this is attempting to insert a duplicate value into a column that is a primary key or has a unique constraint. If the insert fails then the user can infer that the value already exists. (This example assumes that the user is permitted by policy to insert records which they are not allowed to see.) Another example is where a user is allowed to insert into a table which references another, otherwise hidden table. Existence can be determined by the user inserting values into the referencing table, where success would indicate that the value exists in the referenced table. These issues can be addressed by carefully crafting policies to prevent users from being able to insert, delete, or update records at all which might possibly indicate a value they are not otherwise able to see, or by using generated values (e.g., surrogate keys) instead of keys with external meanings.</source>
          <target state="translated">ポリシーは、データベース内のテーブルに対する明示的な問い合わせには適用されますが、システムが内部参照整合性チェックや制約の検証を行っている場合には適用されません。つまり、与えられた値が存在することを判断する間接的な方法があるということです。この例として、主キーまたは一意の制約を持つ列に重複した値を挿入しようとした場合があります。挿入に失敗した場合、ユーザーはその値がすでに存在していることを推測できます。(この例では、ユーザーがポリシーによって、閲覧を許可されていないレコードの挿入を許可されていることを想定しています)。もう一つの例は、ユーザーが別のテーブルを参照しているテーブルへの挿入を許可されている場合です。存在は、ユーザが参照先のテーブルに値を挿入することで判断することができ、成功すれば、値が参照先のテーブルに存在することを示します。これらの問題は、ユーザが見えない値を示す可能性のあるレコードを挿入、削除、更新できないようにポリシーを慎重に作成したり、外部の意味を持つキーの代わりに生成された値(サロゲートキーなど)を使用したりすることで解決できます。</target>
        </trans-unit>
        <trans-unit id="5fbe4c0896d37fe14f081d1ac25be59617f075b0" translate="yes" xml:space="preserve">
          <source>While recovery is paused no further database changes are applied. If in hot standby, all new queries will see the same consistent snapshot of the database, and no further query conflicts will be generated until recovery is resumed.</source>
          <target state="translated">リカバリが一時停止されている間は、それ以上のデータベース変更は適用されません。ホットスタンバイの場合、すべての新しいクエリはデータベースの同じ一貫したスナップショットを表示し、回復が再開されるまでは、それ以上のクエリの競合は発生しません。</target>
        </trans-unit>
        <trans-unit id="67bee53c255823e86d8c23b4190b410627254abc" translate="yes" xml:space="preserve">
          <source>While rows can be moved from local partitions to a foreign-table partition (provided the foreign data wrapper supports tuple routing), they cannot be moved from a foreign-table partition to another partition.</source>
          <target state="translated">ローカルパーティションから外部テーブルパーティションに行を移動させることはできますが(外部データラッパーがタプルルーティングをサポートしている場合)、外部テーブルパーティションから別のパーティションに行を移動させることはできません。</target>
        </trans-unit>
        <trans-unit id="7158e641e335f398bdfc35c274f36a1760cfa0bc" translate="yes" xml:space="preserve">
          <source>While running pg_dump, one should examine the output for any warnings (printed on standard error), especially in light of the limitations listed below.</source>
          <target state="translated">pg_dumpを実行している間は、特に以下に列挙する制限事項を考慮して、警告(標準エラーで表示される)が出力されていないか調べなければなりません。</target>
        </trans-unit>
        <trans-unit id="891b0584891eb2794e238a1971ed31f1c215e841" translate="yes" xml:space="preserve">
          <source>While that doesn't look all that bad by itself, it's still oversimplified. A far more complicated sub-select would be needed to select the right OID if there are multiple tables named &lt;code&gt;mytable&lt;/code&gt; in different schemas. The &lt;code&gt;regclass&lt;/code&gt; input converter handles the table lookup according to the schema path setting, and so it does the &amp;ldquo;right thing&amp;rdquo; automatically. Similarly, casting a table's OID to &lt;code&gt;regclass&lt;/code&gt; is handy for symbolic display of a numeric OID.</source>
          <target state="translated">それだけではそれほど悪くはありませんが、単純化しすぎです。異なるスキーマに &lt;code&gt;mytable&lt;/code&gt; という名前のテーブルが複数ある場合、正しいOIDを選択するには、はるかに複雑な副選択が必要になります。 &lt;code&gt;regclass&lt;/code&gt; データ入力コンバータハンドルテーブルスキーマパスの設定に応じて、ルックアップ、それが自動的に「正しいこと」を行いますので。同様に、テーブルのOIDを &lt;code&gt;regclass&lt;/code&gt; にキャストすると、数値OIDの記号表示に便利です。</target>
        </trans-unit>
        <trans-unit id="d982cd814f64616912cda4d88166e9a69d28b85b" translate="yes" xml:space="preserve">
          <source>While that particular example might seem silly, related cases that don't obviously involve constants can occur in queries executed within functions, since the values of function arguments and local variables can be inserted into queries as constants for planning purposes. Within PL/pgSQL functions, for example, using an &lt;code&gt;IF&lt;/code&gt;-&lt;code&gt;THEN&lt;/code&gt;-&lt;code&gt;ELSE&lt;/code&gt; statement to protect a risky computation is much safer than just nesting it in a &lt;code&gt;CASE&lt;/code&gt; expression.</source>
          <target state="translated">その特定の例はばかげているように見えるかもしれませんが、関数の引数とローカル変数の値は計画目的で定数としてクエリに挿入できるため、関数内で実行されるクエリで明らかに定数を含まない関連ケースが発生する可能性があります。たとえば、PL / pgSQL関数内では、 &lt;code&gt;IF&lt;/code&gt; - &lt;code&gt;THEN&lt;/code&gt; - &lt;code&gt;ELSE&lt;/code&gt; ステートメントを使用して危険な計算を保護する方が、 &lt;code&gt;CASE&lt;/code&gt; 式で単にネストするよりもはるかに安全です。</target>
        </trans-unit>
        <trans-unit id="cfcd6cf6959e988635a363ac7fbe48c4622cc9ea" translate="yes" xml:space="preserve">
          <source>While the built-in declarative partitioning is suitable for most common use cases, there are some circumstances where a more flexible approach may be useful. Partitioning can be implemented using table inheritance, which allows for several features not supported by declarative partitioning, such as:</source>
          <target state="translated">組み込みの宣言的パーティショニングはほとんどの一般的なユースケースに適していますが、より柔軟なアプローチが有用な場合もあります。パーティショニングはテーブル継承を使って実装することができます。</target>
        </trans-unit>
        <trans-unit id="f761cf19de1d987297c4bdb87e576a9e8ef5e265" translate="yes" xml:space="preserve">
          <source>While the default index for future &lt;a href=&quot;sql-cluster&quot;&gt;CLUSTER&lt;/a&gt; operations is retained, &lt;code&gt;REFRESH MATERIALIZED VIEW&lt;/code&gt; does not order the generated rows based on this property. If you want the data to be ordered upon generation, you must use an &lt;code&gt;ORDER BY&lt;/code&gt; clause in the backing query.</source>
          <target state="translated">今後の&lt;a href=&quot;sql-cluster&quot;&gt;CLUSTER&lt;/a&gt;操作のデフォルトのインデックスは保持されますが、 &lt;code&gt;REFRESH MATERIALIZED VIEW&lt;/code&gt; は、このプロパティに基づいて生成された行を並べ替えません。生成時にデータを並べ &lt;code&gt;ORDER BY&lt;/code&gt; 場合は、バッキングクエリでORDER BY句を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="89bb80c5dc369e5a7b8dcef839df901e5b397bf5" translate="yes" xml:space="preserve">
          <source>While the details of the new type's internal representation are only known to the I/O functions and other functions you create to work with the type, there are several properties of the internal representation that must be declared to PostgreSQL. Foremost of these is &lt;code&gt;internallength&lt;/code&gt;. Base data types can be fixed-length, in which case &lt;code&gt;internallength&lt;/code&gt; is a positive integer, or variable-length, indicated by setting &lt;code&gt;internallength&lt;/code&gt; to &lt;code&gt;VARIABLE&lt;/code&gt;. (Internally, this is represented by setting &lt;code&gt;typlen&lt;/code&gt; to -1.) The internal representation of all variable-length types must start with a 4-byte integer giving the total length of this value of the type. (Note that the length field is often encoded, as described in &lt;a href=&quot;storage-toast&quot;&gt;Section 68.2&lt;/a&gt;; it's unwise to access it directly.)</source>
          <target state="translated">新しい型の内部表現の詳細は、その型を操作するために作成するI / O関数と他の関数だけが知っていますが、PostgreSQLに宣言する必要がある内部表現のいくつかのプロパティがあります。これらの最も重要なものは &lt;code&gt;internallength&lt;/code&gt; です。基本データ型は固定長にすることができます。この場合、 &lt;code&gt;internallength&lt;/code&gt; は正の整数、または &lt;code&gt;internallength&lt;/code&gt; を &lt;code&gt;VARIABLE&lt;/code&gt; に設定することによって示される可変長にすることができます。 （内部的には、 &lt;code&gt;typlen&lt;/code&gt; を-1に設定することで表されます。）すべての可変長型の内部表現は、型のこの値の全長を表す4バイトの整数で始まる必要があります。 （長さフィールドは、&lt;a href=&quot;storage-toast&quot;&gt;セクション68.2&lt;/a&gt; ; 直接アクセスするのは賢明ではありません。）</target>
        </trans-unit>
        <trans-unit id="e2a6eda1b3f1244604b394ad1d7fc00d1fb05fef" translate="yes" xml:space="preserve">
          <source>While the example below uses a constant JSON value, typical use would be to reference a &lt;code&gt;json&lt;/code&gt; or &lt;code&gt;jsonb&lt;/code&gt; column laterally from another table in the query's &lt;code&gt;FROM&lt;/code&gt; clause. Writing &lt;code&gt;json_populate_record&lt;/code&gt; in the &lt;code&gt;FROM&lt;/code&gt; clause is good practice, since all of the extracted columns are available for use without duplicate function calls.</source>
          <target state="translated">While the example below uses a constant JSON value, typical use would be to reference a &lt;code&gt;json&lt;/code&gt; or &lt;code&gt;jsonb&lt;/code&gt; column laterally from another table in the query's &lt;code&gt;FROM&lt;/code&gt; clause. Writing &lt;code&gt;json_populate_record&lt;/code&gt; in the &lt;code&gt;FROM&lt;/code&gt; clause is good practice, since all of the extracted columns are available for use without duplicate function calls.</target>
        </trans-unit>
        <trans-unit id="915068b5c9a0a4207ecd95ee0a72471b7e35a59c" translate="yes" xml:space="preserve">
          <source>While the examples for these functions use constants, the typical use would be to reference a table in the &lt;code&gt;FROM&lt;/code&gt; clause and use one of its &lt;code&gt;json&lt;/code&gt; or &lt;code&gt;jsonb&lt;/code&gt; columns as an argument to the function. Extracted key values can then be referenced in other parts of the query, like &lt;code&gt;WHERE&lt;/code&gt; clauses and target lists. Extracting multiple values in this way can improve performance over extracting them separately with per-key operators.</source>
          <target state="translated">これらの関数の例では定数を使用していますが、一般的な使用法は、 &lt;code&gt;FROM&lt;/code&gt; 句でテーブルを参照し、 &lt;code&gt;json&lt;/code&gt; または &lt;code&gt;jsonb&lt;/code&gt; 列のいずれかを関数の引数として使用することです。抽出されたキー値は、 &lt;code&gt;WHERE&lt;/code&gt; 句やターゲットリストなど、クエリの他の部分で参照できます。この方法で複数の値を抽出すると、キーごとの演算子で個別に抽出するよりもパフォーマンスが向上します。</target>
        </trans-unit>
        <trans-unit id="5c45fc673d90d93e24f91fea428d0f8a94bae39e" translate="yes" xml:space="preserve">
          <source>While the input strings &lt;code&gt;now&lt;/code&gt;, &lt;code&gt;today&lt;/code&gt;, &lt;code&gt;tomorrow&lt;/code&gt;, and &lt;code&gt;yesterday&lt;/code&gt; are fine to use in interactive SQL commands, they can have surprising behavior when the command is saved to be executed later, for example in prepared statements, views, and function definitions. The string can be converted to a specific time value that continues to be used long after it becomes stale. Use one of the SQL functions instead in such contexts. For example, &lt;code&gt;CURRENT_DATE + 1&lt;/code&gt; is safer than &lt;code&gt;'tomorrow'::date&lt;/code&gt;.</source>
          <target state="translated">While the input strings &lt;code&gt;now&lt;/code&gt; , &lt;code&gt;today&lt;/code&gt; , &lt;code&gt;tomorrow&lt;/code&gt; , and &lt;code&gt;yesterday&lt;/code&gt; are fine to use in interactive SQL commands, they can have surprising behavior when the command is saved to be executed later, for example in prepared statements, views, and function definitions. The string can be converted to a specific time value that continues to be used long after it becomes stale. Use one of the SQL functions instead in such contexts. For example, &lt;code&gt;CURRENT_DATE + 1&lt;/code&gt; is safer than &lt;code&gt;'tomorrow'::date&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0c09c1945f14d262f5a989a6b1b7f78a8869fb1b" translate="yes" xml:space="preserve">
          <source>While the server is running, it is not possible for a malicious user to take the place of the normal database server. However, when the server is down, it is possible for a local user to spoof the normal server by starting their own server. The spoof server could read passwords and queries sent by clients, but could not return any data because the &lt;code&gt;PGDATA&lt;/code&gt; directory would still be secure because of directory permissions. Spoofing is possible because any user can start a database server; a client cannot identify an invalid server unless it is specially configured.</source>
          <target state="translated">サーバーの実行中は、悪意のあるユーザーが通常のデータベースサーバーの代わりをすることはできません。ただし、サーバーがダウンしている場合、ローカルユーザーが独自のサーバーを起動して通常のサーバーを偽装する可能性があります。スプーフィングサーバーは、クライアントから送信されたパスワードとクエリを読み取ることができましたが、 &lt;code&gt;PGDATA&lt;/code&gt; ディレクトリはディレクトリのアクセス許可のために引き続き安全であるため、データを返すことができませんでした。すべてのユーザーがデータベースサーバーを起動できるため、なりすましが可能です。特別に構成されていない限り、クライアントは無効なサーバーを識別できません。</target>
        </trans-unit>
        <trans-unit id="a8b90c7536148bdec5e290019a51b2379ecb8d63" translate="yes" xml:space="preserve">
          <source>While the server is running, its PID is stored in the file &lt;code&gt;postmaster.pid&lt;/code&gt; in the data directory. This is used to prevent multiple server instances from running in the same data directory and can also be used for shutting down the server.</source>
          <target state="translated">サーバーの実行中、そのPIDはデータディレクトリのファイル &lt;code&gt;postmaster.pid&lt;/code&gt; に保存されます。これは、複数のサーバーインスタンスが同じデータディレクトリで実行されるのを防ぐために使用され、サーバーのシャットダウンにも使用できます。</target>
        </trans-unit>
        <trans-unit id="a03c807444bf3594110c4d388ec7b0a59f62a431" translate="yes" xml:space="preserve">
          <source>While the standard syntax for specifying string constants is usually convenient, it can be difficult to understand when the desired string contains many single quotes or backslashes, since each of those must be doubled. To allow more readable queries in such situations, PostgreSQL provides another way, called &amp;ldquo;dollar quoting&amp;rdquo;, to write string constants. A dollar-quoted string constant consists of a dollar sign (&lt;code&gt;$&lt;/code&gt;), an optional &amp;ldquo;tag&amp;rdquo; of zero or more characters, another dollar sign, an arbitrary sequence of characters that makes up the string content, a dollar sign, the same tag that began this dollar quote, and a dollar sign. For example, here are two different ways to specify the string &amp;ldquo;Dianne's horse&amp;rdquo; using dollar quoting:</source>
          <target state="translated">文字列定数を指定するための標準的な構文は通常便利ですが、目的の文字列に多数の単一引用符またはバックスラッシュが含まれていると、それぞれを二重にする必要があるため、理解しにくい場合があります。そのような状況でより読みやすいクエリを可能にするために、PostgreSQLは「ドル引用」と呼ばれる文字列定数を書き込む別の方法を提供しています。ドルで囲まれた文字列定数は、ドル記号（ &lt;code&gt;$&lt;/code&gt; ）、0個以上の文字のオプションの「タグ」、別のドル記号、文字列の内容を構成する任意の文字シーケンス、ドル記号、同じタグで構成されますこのドル相場とドル記号が始まりました。たとえば、ドル引用符を使用して文字列「ダイアンの馬」を指定するには、次の2つの方法があります。</target>
        </trans-unit>
        <trans-unit id="97a03d15b6274d3b06d93b14cfe041b66ef2af72" translate="yes" xml:space="preserve">
          <source>While this function is more complex than the single-month case, it doesn't need to be updated as often, since branches can be added in advance of being needed.</source>
          <target state="translated">この機能は単月の場合よりも複雑ですが、必要になる前にブランチを追加することができるので、それほど頻繁に更新する必要はありません。</target>
        </trans-unit>
        <trans-unit id="eb917c6d1ba7f34837342b8b023d8fdc99add536" translate="yes" xml:space="preserve">
          <source>While this is the only way to convert character strings into XML values according to the SQL standard, the PostgreSQL-specific syntaxes:</source>
          <target state="translated">SQL標準に従って文字列をXML値に変換する唯一の方法ではありますが、PostgreSQL固有の構文を使用しています。</target>
        </trans-unit>
        <trans-unit id="13b118c29b5eac33252cf8f05a41900068035eae" translate="yes" xml:space="preserve">
          <source>While transition table names for &lt;code&gt;AFTER&lt;/code&gt; triggers are specified using the &lt;code&gt;REFERENCING&lt;/code&gt; clause in the standard way, the row variables used in &lt;code&gt;FOR EACH ROW&lt;/code&gt; triggers may not be specified in a &lt;code&gt;REFERENCING&lt;/code&gt; clause. They are available in a manner that is dependent on the language in which the trigger function is written, but is fixed for any one language. Some languages effectively behave as though there is a &lt;code&gt;REFERENCING&lt;/code&gt; clause containing &lt;code&gt;OLD ROW AS OLD NEW ROW AS NEW&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;AFTER&lt;/code&gt; トリガーの遷移テーブル名は、 &lt;code&gt;REFERENCING&lt;/code&gt; 句を使用して標準的な方法で指定されますが、 &lt;code&gt;FOR EACH ROW&lt;/code&gt; トリガーで使用される行変数は、 &lt;code&gt;REFERENCING&lt;/code&gt; 句で指定されない場合があります。これらは、トリガー関数が記述されている言語に依存する方法で使用できますが、いずれか1つの言語に固定されています。一部の言語は、 &lt;code&gt;OLD ROW AS OLD NEW ROW AS NEW&lt;/code&gt; を含む &lt;code&gt;REFERENCING&lt;/code&gt; 句があるかのように効果的に動作します。</target>
        </trans-unit>
        <trans-unit id="0775e3a82644839414e547fda3c53cda5989eee1" translate="yes" xml:space="preserve">
          <source>While turning off &lt;code&gt;fsync&lt;/code&gt; is often a performance benefit, this can result in unrecoverable data corruption in the event of a power failure or system crash. Thus it is only advisable to turn off &lt;code&gt;fsync&lt;/code&gt; if you can easily recreate your entire database from external data.</source>
          <target state="translated">&lt;code&gt;fsync&lt;/code&gt; をオフにするとパフォーマンスが向上することがよくありますが、電源障害やシステムクラッシュが発生した場合に、データが破損して回復不能になる可能性があります。したがって、オフにする唯一の賢明である &lt;code&gt;fsync&lt;/code&gt; 使用すると、簡単に外部のデータからデータベース全体を再作成することができます。</target>
        </trans-unit>
        <trans-unit id="5d9f7345f5e4a9cecb1d3a73e9e82a30d0080279" translate="yes" xml:space="preserve">
          <source>White space (i.e., spaces, tabs, and newlines) can be used freely in SQL commands. That means you can type the command aligned differently than above, or even all on one line. Two dashes (&amp;ldquo;&lt;code&gt;--&lt;/code&gt;&amp;rdquo;) introduce comments. Whatever follows them is ignored up to the end of the line. SQL is case insensitive about key words and identifiers, except when identifiers are double-quoted to preserve the case (not done above).</source>
          <target state="translated">空白（スペース、タブ、改行）は、SQLコマンドで自由に使用できます。つまり、上記とは異なる方法で整列したコマンドを入力することも、すべてを1行で入力することもできます。2つのダッシュ（「 &lt;code&gt;--&lt;/code&gt; 」）はコメントを示します。それらに続くものはすべて、行の終わりまで無視されます。SQLは、大文字と小文字を区別するために識別子が二重引用符で囲まれている場合（上記では行われません）を除き、キーワードと識別子について大文字と小文字を区別しません。</target>
        </trans-unit>
        <trans-unit id="58bd91fff64a844973a8238af97e34efc8a5c324" translate="yes" xml:space="preserve">
          <source>White space is ignored on input, so &lt;code&gt;[(x),(y)]&lt;/code&gt; is the same as &lt;code&gt;[ ( x ), ( y ) ]&lt;/code&gt;.</source>
          <target state="translated">ホワイトスペースは、入力時には無視されるので、 &lt;code&gt;[(x),(y)]&lt;/code&gt; 同じである &lt;code&gt;[ ( x ), ( y ) ]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ac41fe428645044123abfe95a020b4d162465d70" translate="yes" xml:space="preserve">
          <source>Whitespace is allowed before and after the range value, but any whitespace between the parentheses or brackets is taken as part of the lower or upper bound value. (Depending on the element type, it might or might not be significant.)</source>
          <target state="translated">範囲値の前後には空白が許されていますが、括弧や括弧の間の空白は、下界値や上界値の一部として扱われます。(要素の種類によっては、重要である場合と重要でない場合があります)。</target>
        </trans-unit>
        <trans-unit id="78d976901748b052cce834685b15a7dd1749e3bc" translate="yes" xml:space="preserve">
          <source>Whitespace of the same width as the most recent output of &lt;code&gt;PROMPT1&lt;/code&gt;. This can be used as a &lt;code&gt;PROMPT2&lt;/code&gt; setting, so that multi-line statements are aligned with the first line, but there is no visible secondary prompt.</source>
          <target state="translated">&lt;code&gt;PROMPT1&lt;/code&gt; の最新の出力と同じ幅の空白。これは &lt;code&gt;PROMPT2&lt;/code&gt; 設定として使用できるため、複数行のステートメントは最初の行に揃えられますが、表示される2次プロンプトはありません。</target>
        </trans-unit>
        <trans-unit id="3cc40c3d855977fc828d35a4c20284c43f252dc0" translate="yes" xml:space="preserve">
          <source>Why would you want to use the weak mode? Well, it could be that you have a huge collection of ISBN numbers, and that there are so many of them that for weird reasons some have the wrong check digit (perhaps the numbers were scanned from a printed list and the OCR got the numbers wrong, perhaps the numbers were manually captured... who knows). Anyway, the point is you might want to clean the mess up, but you still want to be able to have all the numbers in your database and maybe use an external tool to locate the invalid numbers in the database so you can verify the information and validate it more easily; so for example you'd want to select all the invalid numbers in the table.</source>
          <target state="translated">なぜ弱いモードを使いたいのですか?まあ、それはあなたがISBN番号の膨大なコレクションを持っている可能性がありますし、奇妙な理由でいくつかのチェックデジットが間違っている(おそらく番号は印刷されたリストからスキャンされ、OCRは番号を間違っていた、おそらく番号は手動でキャプチャされた...誰が知っている)それらの非常に多くがあります。とにかく、ポイントは、あなたが混乱をクリーンアップしたいかもしれないということですが、あなたはまだあなたのデータベース内のすべての番号を持つことができるようにしたいと思いますし、おそらく外部ツールを使用してデータベース内の無効な番号を見つけるために、情報を検証し、より簡単にそれを検証することができます。</target>
        </trans-unit>
        <trans-unit id="70a7ce99eb76502ad0a6210d94039f0b40c3419d" translate="yes" xml:space="preserve">
          <source>Wildcard array element accessor that returns all array elements.</source>
          <target state="translated">すべての配列要素を返すワイルドカード配列要素アクセサ。</target>
        </trans-unit>
        <trans-unit id="cd2106ae04d09a5386f20710a015aa4219dc3f6c" translate="yes" xml:space="preserve">
          <source>Wildcard member accessor that returns the values of all members located at the top level of the current object.</source>
          <target state="translated">現在のオブジェクトの最上位レベルにあるすべてのメンバの値を返すワイルドカード・メンバ・アクセサ。</target>
        </trans-unit>
        <trans-unit id="68fe8f958724479a101c0326f7607d389d321758" translate="yes" xml:space="preserve">
          <source>Window Functions</source>
          <target state="translated">ウィンドウ機能</target>
        </trans-unit>
        <trans-unit id="927627d12746803cbdee2462dc2d4d29bab17c5e" translate="yes" xml:space="preserve">
          <source>Window function (routine)</source>
          <target state="translated">ウィンドウ関数(ルーチン</target>
        </trans-unit>
        <trans-unit id="01267df331f99498a90196b34760cb7aa229a46d" translate="yes" xml:space="preserve">
          <source>Window function calls are permitted only in the &lt;code&gt;SELECT&lt;/code&gt; list and the &lt;code&gt;ORDER BY&lt;/code&gt; clause of the query.</source>
          <target state="translated">ウィンドウ関数の呼び出しは、クエリの &lt;code&gt;SELECT&lt;/code&gt; リストと &lt;code&gt;ORDER BY&lt;/code&gt; 句でのみ許可されます。</target>
        </trans-unit>
        <trans-unit id="c367a920e4a4ea3efbe3a1a798085a3a023e6741" translate="yes" xml:space="preserve">
          <source>Window functions are described in detail in &lt;a href=&quot;tutorial-window&quot;&gt;Section 3.5&lt;/a&gt;, &lt;a href=&quot;sql-expressions#SYNTAX-WINDOW-FUNCTIONS&quot;&gt;Section 4.2.8&lt;/a&gt;, and &lt;a href=&quot;queries-table-expressions#QUERIES-WINDOW&quot;&gt;Section 7.2.5&lt;/a&gt;.</source>
          <target state="translated">ウィンドウ関数は、に詳細に記載されている&lt;a href=&quot;tutorial-window&quot;&gt;セクション3.5&lt;/a&gt;、&lt;a href=&quot;sql-expressions#SYNTAX-WINDOW-FUNCTIONS&quot;&gt;セクション4.2.8&lt;/a&gt;、および&lt;a href=&quot;queries-table-expressions#QUERIES-WINDOW&quot;&gt;セクション7.2.5&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5f451b621911f3a41da7c18da4aff7cdb55589c1" translate="yes" xml:space="preserve">
          <source>Window functions are permitted only in the &lt;code&gt;SELECT&lt;/code&gt; list and the &lt;code&gt;ORDER BY&lt;/code&gt; clause of the query. They are forbidden elsewhere, such as in &lt;code&gt;GROUP BY&lt;/code&gt;, &lt;code&gt;HAVING&lt;/code&gt; and &lt;code&gt;WHERE&lt;/code&gt; clauses. This is because they logically execute after the processing of those clauses. Also, window functions execute after non-window aggregate functions. This means it is valid to include an aggregate function call in the arguments of a window function, but not vice versa.</source>
          <target state="translated">ウィンドウ関数は、クエリの &lt;code&gt;SELECT&lt;/code&gt; リストと &lt;code&gt;ORDER BY&lt;/code&gt; 句でのみ許可されます。 &lt;code&gt;GROUP BY&lt;/code&gt; 、 &lt;code&gt;HAVING&lt;/code&gt; 、 &lt;code&gt;WHERE&lt;/code&gt; 句など、他の場所では禁止されています。これは、これらの句の処理後に論理的に実行されるためです。また、ウィンドウ関数は非ウィンドウ集約関数の後に実行されます。つまり、ウィンドウ関数の引数に集約関数呼び出しを含めることは有効ですが、その逆はできません。</target>
        </trans-unit>
        <trans-unit id="79e789d251d694ff69667eed3b6a1eef1b73bc73" translate="yes" xml:space="preserve">
          <source>Window: cume_dist</source>
          <target state="translated">ウィンドウ:cume_dist</target>
        </trans-unit>
        <trans-unit id="1e7f6a60bbd5fd2e82c3412bbb88bea212c4bdb7" translate="yes" xml:space="preserve">
          <source>Window: dense_rank</source>
          <target state="translated">ウィンドウ:dense_rank</target>
        </trans-unit>
        <trans-unit id="08d36b418003a8b9c0e9b2dd2a6f2bff70e5a8ac" translate="yes" xml:space="preserve">
          <source>Window: first_value</source>
          <target state="translated">ウィンドウ:first_value</target>
        </trans-unit>
        <trans-unit id="b5f178a106cd7cba1da80bdc71ec514eea37f26d" translate="yes" xml:space="preserve">
          <source>Window: lag</source>
          <target state="translated">ウィンドウ:ラグ</target>
        </trans-unit>
        <trans-unit id="fabaa17e6490da4ec5451b3b47ee388b70cf91b0" translate="yes" xml:space="preserve">
          <source>Window: last_value</source>
          <target state="translated">ウィンドウ:last_value</target>
        </trans-unit>
        <trans-unit id="994efd60b559fadbd405573c301089b7cf18f884" translate="yes" xml:space="preserve">
          <source>Window: lead</source>
          <target state="translated">窓:鉛</target>
        </trans-unit>
        <trans-unit id="757db4a854089f2de8d98fd39c8889ef5116458d" translate="yes" xml:space="preserve">
          <source>Window: nth_value</source>
          <target state="translated">ウィンドウ:nth_value</target>
        </trans-unit>
        <trans-unit id="e7f90d6e0544bf0f16ab443f5e02ee4cd6fe42bc" translate="yes" xml:space="preserve">
          <source>Window: ntile</source>
          <target state="translated">窓:ntile</target>
        </trans-unit>
        <trans-unit id="bb901cf4a6350aa408d137094086445ef7a0cf50" translate="yes" xml:space="preserve">
          <source>Window: percent_rank</source>
          <target state="translated">ウィンドウ:percent_rank</target>
        </trans-unit>
        <trans-unit id="c0ecbc78e1223c489bcdc839303f81579d301dbd" translate="yes" xml:space="preserve">
          <source>Window: rank</source>
          <target state="translated">窓:ランク</target>
        </trans-unit>
        <trans-unit id="31c13454a2137d228d57d97a95bb16f2559129e2" translate="yes" xml:space="preserve">
          <source>Window: row_number</source>
          <target state="translated">ウィンドウ:行番号</target>
        </trans-unit>
        <trans-unit id="afb3a4bfc7eab0371f71e7828e71cca0cb17b3c3" translate="yes" xml:space="preserve">
          <source>Windows CP1250</source>
          <target state="translated">ウィンドウズCP1250</target>
        </trans-unit>
        <trans-unit id="9a2c00b8e44a047e41a03f1caab3a7b4b6689695" translate="yes" xml:space="preserve">
          <source>Windows CP1251</source>
          <target state="translated">ウィンドウズCP1251</target>
        </trans-unit>
        <trans-unit id="ee9d69428625d1ff5f15b6e3dcde936a0fd1f094" translate="yes" xml:space="preserve">
          <source>Windows CP1252</source>
          <target state="translated">Windows CP1252</target>
        </trans-unit>
        <trans-unit id="cc78a0c32f91f66c55ae633ccbcefebb486eb07a" translate="yes" xml:space="preserve">
          <source>Windows CP1253</source>
          <target state="translated">ウィンドウズCP1253</target>
        </trans-unit>
        <trans-unit id="5f231ed423cb65bf660816b30028087f1a8e8ce5" translate="yes" xml:space="preserve">
          <source>Windows CP1254</source>
          <target state="translated">ウィンドウズCP1254</target>
        </trans-unit>
        <trans-unit id="a23b534f177679e438c10751dd8cd9af7ceda942" translate="yes" xml:space="preserve">
          <source>Windows CP1255</source>
          <target state="translated">ウィンドウズCP1255</target>
        </trans-unit>
        <trans-unit id="6790dc03b7d5b6e6f32fcb36c60e23323fb868ac" translate="yes" xml:space="preserve">
          <source>Windows CP1256</source>
          <target state="translated">ウィンドウズCP1256</target>
        </trans-unit>
        <trans-unit id="2de6d342a6a1f91fe73d1aed1c38e985a216e16e" translate="yes" xml:space="preserve">
          <source>Windows CP1257</source>
          <target state="translated">ウィンドウズCP1257</target>
        </trans-unit>
        <trans-unit id="640bb2a94fe66a43ea03427875c71fa7af756764" translate="yes" xml:space="preserve">
          <source>Windows CP1258</source>
          <target state="translated">ウィンドウズCP1258</target>
        </trans-unit>
        <trans-unit id="e95532249be79aa59a141ea1dc6d988132a7c104" translate="yes" xml:space="preserve">
          <source>Windows CP866</source>
          <target state="translated">ウィンドウズシーピー866</target>
        </trans-unit>
        <trans-unit id="69925dc2d1afa064badeb7131e0815ad04126da3" translate="yes" xml:space="preserve">
          <source>Windows CP874</source>
          <target state="translated">ウィンドウズシーピー874</target>
        </trans-unit>
        <trans-unit id="c6d589f8c6c9e727468855e6a54c0d6dfb5cce47" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--create&lt;/code&gt;, pg_restore also restores the database's comment if any, and any configuration variable settings that are specific to this database, that is, any &lt;code&gt;ALTER DATABASE ... SET ...&lt;/code&gt; and &lt;code&gt;ALTER ROLE ... IN DATABASE ... SET ...&lt;/code&gt; commands that mention this database. Access privileges for the database itself are also restored, unless &lt;code&gt;--no-acl&lt;/code&gt; is specified.</source>
          <target state="translated">&lt;code&gt;--create&lt;/code&gt; 、pg_restoreのもあれば、データベースのコメントを復元し、このデータベースに固有のすべての構成変数の設定、任意の、あること &lt;code&gt;ALTER DATABASE ... SET ...&lt;/code&gt; と &lt;code&gt;ALTER ROLE ... IN DATABASE ... SET ...&lt;/code&gt; このデータベースに言及するSET ...コマンド。 &lt;code&gt;--no-acl&lt;/code&gt; が指定されていない限り、データベース自体のアクセス権限も復元されます。</target>
        </trans-unit>
        <trans-unit id="8fdece12f1fb080c2dbfd8709cabeca4afb1d172" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--create&lt;/code&gt;, the output also includes the database's comment if any, and any configuration variable settings that are specific to this database, that is, any &lt;code&gt;ALTER DATABASE ... SET ...&lt;/code&gt; and &lt;code&gt;ALTER ROLE ... IN DATABASE ... SET ...&lt;/code&gt; commands that mention this database. Access privileges for the database itself are also dumped, unless &lt;code&gt;--no-acl&lt;/code&gt; is specified.</source>
          <target state="translated">&lt;code&gt;--create&lt;/code&gt; 、出力もあれば、データベースのコメントが含まれており、このデータベースに固有のすべての構成変数の設定、任意の、あること &lt;code&gt;ALTER DATABASE ... SET ...&lt;/code&gt; と &lt;code&gt;ALTER ROLE ... IN DATABASE ... SET ...&lt;/code&gt; このデータベースに言及するSET ...コマンド。 &lt;code&gt;--no-acl&lt;/code&gt; が指定されていない限り、データベース自体へのアクセス権限もダンプされます。</target>
        </trans-unit>
        <trans-unit id="f1abf8b357cf8a269c4c68a487360b4810c28399" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;G&lt;/code&gt; (server-side data generation), only small queries are sent from the &lt;code&gt;pgbench&lt;/code&gt; client and then data is actually generated in the server. No significant bandwidth is required for this variant, but the server will do more work. Using &lt;code&gt;G&lt;/code&gt; causes logging not to print any progress message while generating data.</source>
          <target state="translated">&lt;code&gt;G&lt;/code&gt; （サーバ側データ生成）、わずかなクエリがから送信された &lt;code&gt;pgbench&lt;/code&gt; は、クライアントと、データは、実際のサーバで生成されます。このバリアントには大きな帯域幅は必要ありませんが、サーバーはより多くの作業を行います。 &lt;code&gt;G&lt;/code&gt; を使用すると、データの生成中にログが進行状況メッセージを出力しなくなります。</target>
        </trans-unit>
        <trans-unit id="dc8bd1c0f7d38dd3394b226a28acc604884d1615" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;g&lt;/code&gt; (client-side data generation), data is generated in &lt;code&gt;pgbench&lt;/code&gt; client and then sent to the server. This uses the client/server bandwidth extensively through a &lt;code&gt;COPY&lt;/code&gt;. Using &lt;code&gt;g&lt;/code&gt; causes logging to print one message every 100,000 rows while generating data for the &lt;code&gt;pgbench_accounts&lt;/code&gt; table.</source>
          <target state="translated">&lt;code&gt;g&lt;/code&gt; （クライアント側データ生成）、データが生成される &lt;code&gt;pgbench&lt;/code&gt; は、クライアントと、サーバに送信されます。これは、 &lt;code&gt;COPY&lt;/code&gt; を介してクライアント/サーバー帯域幅を広範囲に使用します。 &lt;code&gt;g&lt;/code&gt; を使用すると、 &lt;code&gt;pgbench_accounts&lt;/code&gt; テーブルのデータを生成している間、ロギングは100,000行ごとに1つのメッセージを出力します。</target>
        </trans-unit>
        <trans-unit id="f453a9fafc8b310f8a3de3fda65ed4c38e9ca283" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;join_collapse_limit&lt;/code&gt; = 1, this forces the planner to join A to B before joining them to other tables, but doesn't constrain its choices otherwise. In this example, the number of possible join orders is reduced by a factor of 5.</source>
          <target state="translated">&lt;code&gt;join_collapse_limit&lt;/code&gt; は、この力はプランナが他のテーブルにそれらを結合する前にBにAを結合するために、= 1、それ以外の選択肢を制限しません。この例では、可能な結合順序の数が5分の1に減少しています。</target>
        </trans-unit>
        <trans-unit id="fe49ef2ae18f846d2f24144892dcb7436b22edbb" translate="yes" xml:space="preserve">
          <source>With ICU, it is not sensible to enumerate all possible locale names. ICU uses a particular naming system for locales, but there are many more ways to name a locale than there are actually distinct locales. &lt;code&gt;initdb&lt;/code&gt; uses the ICU APIs to extract a set of distinct locales to populate the initial set of collations. Collations provided by ICU are created in the SQL environment with names in BCP 47 language tag format, with a &amp;ldquo;private use&amp;rdquo; extension &lt;code&gt;-x-icu&lt;/code&gt; appended, to distinguish them from libc locales.</source>
          <target state="translated">ICUでは、すべての可能なロケール名を列挙することは賢明ではありません。 ICUはロケールに特定のネーミングシステムを使用しますが、実際に異なるロケールよりも、ロケールに名前を付ける方法はたくさんあります。 &lt;code&gt;initdb&lt;/code&gt; は、ICU APIを使用して一連の異なるロケールを抽出し、最初の照合セットを生成します。 ICUによって提供される照合は、BCP 47言語タグ形式の名前でSQL環境で作成され、libcロケールと区別するために「私用」拡張 &lt;code&gt;-x-icu&lt;/code&gt; が追加されます。</target>
        </trans-unit>
        <trans-unit id="cc0ce6e945d75c0e017cd4582a6ce07fb85c72b6" translate="yes" xml:space="preserve">
          <source>With OpenSSL</source>
          <target state="translated">OpenSSLを使って</target>
        </trans-unit>
        <trans-unit id="2a51bd6ec05106a3703acb2d25cff0f482de5c76" translate="yes" xml:space="preserve">
          <source>With SQL-based replication middleware, a program intercepts every SQL query and sends it to one or all servers. Each server operates independently. Read-write queries must be sent to all servers, so that every server receives any changes. But read-only queries can be sent to just one server, allowing the read workload to be distributed among them.</source>
          <target state="translated">SQLベースのレプリケーションミドルウェアでは、プログラムがすべてのSQLクエリをインターセプトし、1台またはすべてのサーバーに送信します。各サーバは独立して動作します。読み書き可能なクエリは、すべてのサーバに送信しなければならないため、すべてのサーバが変更を受け取ることになります。しかし、読み取り専用のクエリは1つのサーバーに送信することができるので、読み取り作業負荷をサーバー間で分散させることができます。</target>
        </trans-unit>
        <trans-unit id="8fa1343fb87dfb28347c1e7e66e33ba69c59c2ca" translate="yes" xml:space="preserve">
          <source>With SSL support compiled in, the PostgreSQL server can be started with SSL enabled by setting the parameter &lt;a href=&quot;runtime-config-connection#GUC-SSL&quot;&gt;ssl&lt;/a&gt; to &lt;code&gt;on&lt;/code&gt; in &lt;code&gt;postgresql.conf&lt;/code&gt;. The server will listen for both normal and SSL connections on the same TCP port, and will negotiate with any connecting client on whether to use SSL. By default, this is at the client's option; see &lt;a href=&quot;auth-pg-hba-conf&quot;&gt;Section 20.1&lt;/a&gt; about how to set up the server to require use of SSL for some or all connections.</source>
          <target state="translated">SSLサポートが&lt;a href=&quot;runtime-config-connection#GUC-SSL&quot;&gt;組み込ま&lt;/a&gt;れ &lt;code&gt;on&lt;/code&gt; 、 &lt;code&gt;postgresql.conf&lt;/code&gt; でパラメーターsslをonに設定することにより、SSLを有効にしてPostgreSQLサーバーを起動できます。サーバーは同じTCPポートで通常の接続とSSL接続の両方をリッスンし、SSLを使用するかどうかについて接続しているクライアントと交渉します。デフォルトでは、これはクライアントのオプションです。一部またはすべての接続でSSLの使用を要求するようにサーバーを設定する方法については、&lt;a href=&quot;auth-pg-hba-conf&quot;&gt;セクション20.1を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="1d13ab27fd57668592221b667df2e40b0bb1e2e4" translate="yes" xml:space="preserve">
          <source>With a cluster distributed across multiple geographic locations, using different values per location brings more flexibility in the cluster management. A smaller value is useful for faster failure detection with a standby having a low-latency network connection, and a larger value helps in judging better the health of a standby if located on a remote location, with a high-latency network connection.</source>
          <target state="translated">クラスタが複数の地理的な場所に分散している場合、場所ごとに異なる値を使用することで、クラスタ管理の柔軟性が向上します。値を小さくすると、低レイテンシのネットワーク接続を持つ待機機の障害検出を迅速に行うことができ、値を大きくすると、高レイテンシのネットワーク接続を持つ遠隔地に位置する待機機の健全性をより良く判断することができます。</target>
        </trans-unit>
        <trans-unit id="2817eb5fe50b4283e89c69a97c63500ae24da2d7" translate="yes" xml:space="preserve">
          <source>With a parameter, turns displaying of how long each SQL statement takes on or off. Without a parameter, toggles the display between on and off. The display is in milliseconds; intervals longer than 1 second are also shown in minutes:seconds format, with hours and days fields added if needed.</source>
          <target state="translated">パラメータを指定すると、各SQL文の表示時間のオン/オフを切り替えます。パラメータを指定しない場合は、表示のオンとオフを切り替えます。表示はミリ秒単位で表示され、1秒以上の間隔は分:秒形式で表示され、必要に応じて時と日のフィールドが追加されます。</target>
        </trans-unit>
        <trans-unit id="862b8683e39578b4e7d997552333b9aad19243ce" translate="yes" xml:space="preserve">
          <source>With constraint exclusion enabled, this &lt;code&gt;SELECT&lt;/code&gt; will not scan &lt;code&gt;child1000&lt;/code&gt; at all, improving performance.</source>
          <target state="translated">制約の除外を有効にすると、この &lt;code&gt;SELECT&lt;/code&gt; は &lt;code&gt;child1000&lt;/code&gt; をまったくスキャンしないため、パフォーマンスが向上します。</target>
        </trans-unit>
        <trans-unit id="281288184f75c730f93254833c37347e0fc29fe4" translate="yes" xml:space="preserve">
          <source>With data warehouse type workloads, it can make sense to use a larger number of partitions than with an OLTP type workload. Generally, in data warehouses, query planning time is less of a concern as the majority of processing time is spent during query execution. With either of these two types of workload, it is important to make the right decisions early, as re-partitioning large quantities of data can be painfully slow. Simulations of the intended workload are often beneficial for optimizing the partitioning strategy. Never assume that more partitions are better than fewer partitions and vice-versa.</source>
          <target state="translated">データウェアハウスタイプのワークロードでは、OLTPタイプのワークロードよりも多くのパーティションを使用することが理にかなっている場合があります。一般的に、データウェアハウスでは、クエリの実行中に処理時間の大部分が費やされるため、クエリの計画時間はあまり気になりません。これら 2 つのタイプのワークロードでは、大量のデータの再パーティション化に時間がかかるため、早期に適切な判断を下すことが重要です。パーティショニング戦略を最適化するためには、意図したワークロードのシミュレーションが有益であることがよくあります。パーティションの数が多い方が少ないよりも良いと決めつけてはいけませんし、逆もまた然りです。</target>
        </trans-unit>
        <trans-unit id="3766650cc974cf1ed93fe99df3e842788c554914" translate="yes" xml:space="preserve">
          <source>With no advance preparation, the system would have to scan the entire &lt;code&gt;test1&lt;/code&gt; table, row by row, to find all matching entries. If there are many rows in &lt;code&gt;test1&lt;/code&gt; and only a few rows (perhaps zero or one) that would be returned by such a query, this is clearly an inefficient method. But if the system has been instructed to maintain an index on the &lt;code&gt;id&lt;/code&gt; column, it can use a more efficient method for locating matching rows. For instance, it might only have to walk a few levels deep into a search tree.</source>
          <target state="translated">事前の準備がなければ、システムは &lt;code&gt;test1&lt;/code&gt; テーブル全体を行ごとにスキャンして、一致するすべてのエントリを見つける必要があります。 &lt;code&gt;test1&lt;/code&gt; に多くの行があり、そのようなクエリによって返される行が数行（おそらく0または1）しかない場合、これは明らかに非効率的な方法です。しかし、システムが &lt;code&gt;id&lt;/code&gt; 列のインデックスを維持するように指示されている場合、一致する行を見つけるために、より効率的な方法を使用できます。たとえば、検索ツリーの深さを数レベルだけ歩く必要がある場合があります。</target>
        </trans-unit>
        <trans-unit id="d718f6eccff45185b0a45095de6fde081eea1bba" translate="yes" xml:space="preserve">
          <source>With no argument, escapes to a sub-shell; psql resumes when the sub-shell exits. With an argument, executes the shell command &lt;code&gt;command&lt;/code&gt;.</source>
          <target state="translated">引数なしで、サブシェルにエスケープします。サブシェルが終了すると、psqlが再開します。引数を指定して、シェルコマンド &lt;code&gt;command&lt;/code&gt; を実行します。</target>
        </trans-unit>
        <trans-unit id="9514950fe011b56b473f75097880ade2b163bceb" translate="yes" xml:space="preserve">
          <source>With statement-based replication middleware, a program intercepts every SQL query and sends it to one or all servers. Each server operates independently. Read-write queries must be sent to all servers, so that every server receives any changes. But read-only queries can be sent to just one server, allowing the read workload to be distributed among them.</source>
          <target state="translated">ステートメントベースのレプリケーションミドルウェアを使用すると、プログラムはすべてのSQLクエリをインターセプトし、それを1つまたはすべてのサーバに送信します。各サーバは独立して動作します。読み書き可能なクエリは、すべてのサーバに送信しなければならないので、すべてのサーバが変更を受け取ることになります。しかし、読み取り専用のクエリは1つのサーバーに送信することができ、読み取り作業負荷をサーバー間で分散させることができます。</target>
        </trans-unit>
        <trans-unit id="4094d09ba0d0f0a9849aa3ea46bb7d77a767e980" translate="yes" xml:space="preserve">
          <source>With synchronous replication options specified at the application level (on the primary) we can offer synchronous replication for the most important changes, without slowing down the bulk of the total workload. Application level options are an important and practical tool for allowing the benefits of synchronous replication for high performance applications.</source>
          <target state="translated">アプリケーションレベル(プライマリ)で同期レプリケーションオプションを指定することで、全体のワークロードの大部分を減速させることなく、最も重要な変更に対しても同期レプリケーションを提供することができます。アプリケーションレベルのオプションは、ハイパフォーマンスアプリケーションで同期レプリケーションのメリットを享受するための重要かつ実用的なツールです。</target>
        </trans-unit>
        <trans-unit id="e625f82083935e0517f3c7cf1a804070d41f41f5" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;--aggregate-interval&lt;/code&gt; option, a different format is used for the log files:</source>
          <target state="translated">&lt;code&gt;--aggregate-interval&lt;/code&gt; オプション、異なるフォーマットは、ログファイル用に使用されます。</target>
        </trans-unit>
        <trans-unit id="21c13395c6ff50aca429bd803e2b410319037881" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;-l&lt;/code&gt; option (but without the &lt;code&gt;--aggregate-interval&lt;/code&gt; option), pgbench writes information about each transaction to a log file. The log file will be named &lt;code&gt;prefix.nnn&lt;/code&gt;, where &lt;code&gt;prefix&lt;/code&gt; defaults to &lt;code&gt;pgbench_log&lt;/code&gt;, and &lt;code&gt;nnn&lt;/code&gt; is the PID of the pgbench process. The prefix can be changed by using the &lt;code&gt;--log-prefix&lt;/code&gt; option. If the &lt;code&gt;-j&lt;/code&gt; option is 2 or higher, so that there are multiple worker threads, each will have its own log file. The first worker will use the same name for its log file as in the standard single worker case. The additional log files for the other workers will be named &lt;code&gt;prefix.nnn.mmm&lt;/code&gt;, where &lt;code&gt;mmm&lt;/code&gt; is a sequential number for each worker starting with 1.</source>
          <target state="translated">&lt;code&gt;-l&lt;/code&gt; オプション（しかしなし &lt;code&gt;--aggregate-interval&lt;/code&gt; オプション）、pgbenchは、ログファイルに各トランザクションに関する情報を書き込みます。ログファイルの名前は &lt;code&gt;prefix.nnn&lt;/code&gt; です。ここで、 &lt;code&gt;prefix&lt;/code&gt; のデフォルトは &lt;code&gt;pgbench_log&lt;/code&gt; で、 &lt;code&gt;nnn&lt;/code&gt; はpgbenchプロセスのPIDです。プレフィックスは &lt;code&gt;--log-prefix&lt;/code&gt; オプションを使用して変更できます。場合は &lt;code&gt;-j&lt;/code&gt; オプションが2以上であるので、複数のワーカースレッドがあることを、それぞれが独自のログファイルを持っています。最初のワーカーは、標準の単一ワーカーの場合と同じ名前をログファイルに使用します。他のワーカーの追加のログファイルには、 &lt;code&gt;prefix.nnn.mmm&lt;/code&gt; という名前が付けられます。 &lt;code&gt;mmm&lt;/code&gt; は、1から始まる各ワーカーの連番です。</target>
        </trans-unit>
        <trans-unit id="dea12aa8ce2a4f9481a6f03ad5ce52c7d1882b2a" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;-r&lt;/code&gt; option, pgbench collects the elapsed transaction time of each statement executed by every client. It then reports an average of those values, referred to as the latency for each statement, after the benchmark has finished.</source>
          <target state="translated">&lt;code&gt;-r&lt;/code&gt; オプション、pgbenchは、すべてのクライアントで実行される各文の経過、取引時間を収集します。次に、ベンチマークが終了した後、各ステートメントのレイテンシと呼ばれるこれらの値の平均を報告します。</target>
        </trans-unit>
        <trans-unit id="b0d0adcb9fc8fc9dddac0cfadc06d179ba840172" translate="yes" xml:space="preserve">
          <source>With the default setting of &lt;code&gt;Accept&lt;/code&gt; = &lt;code&gt;true&lt;/code&gt;, it is only useful to place a &lt;code&gt;simple&lt;/code&gt; dictionary at the end of a list of dictionaries, since it will never pass on any token to a following dictionary. Conversely, &lt;code&gt;Accept&lt;/code&gt; = &lt;code&gt;false&lt;/code&gt; is only useful when there is at least one following dictionary.</source>
          <target state="translated">&lt;code&gt;Accept&lt;/code&gt; = &lt;code&gt;true&lt;/code&gt; のデフォルト設定では、次のディクショナリにトークンを渡さないため、ディクショナリのリストの最後に &lt;code&gt;simple&lt;/code&gt; ディクショナリを配置することのみが役立ちます。逆に、 &lt;code&gt;Accept&lt;/code&gt; = &lt;code&gt;false&lt;/code&gt; は、少なくとも1つの後続の辞書がある場合にのみ役立ちます。</target>
        </trans-unit>
        <trans-unit id="1679a02524be37201556be412a6d701fa1ad4ae3" translate="yes" xml:space="preserve">
          <source>With the tools discussed so far you can create fully functional tables. The remainder of this chapter is concerned with adding features to the table definition to ensure data integrity, security, or convenience. If you are eager to fill your tables with data now you can skip ahead to &lt;a href=&quot;https://www.postgresql.org/docs/12/dml.html&quot;&gt;Chapter 6&lt;/a&gt; and read the rest of this chapter later.</source>
          <target state="translated">これまでに説明したツールを使用すると、完全に機能するテーブルを作成できます。この章の残りの部分では、テーブルの定義に機能を追加して、データの整合性、セキュリティ、または利便性を確保する方法について説明します。テーブルにデータを入力したい場合は、&lt;a href=&quot;https://www.postgresql.org/docs/12/dml.html&quot;&gt;第6章に&lt;/a&gt;進んで、この章の残りの部分を後で読むことができます。</target>
        </trans-unit>
        <trans-unit id="65bded40379a6ac67a03a08a9d131c48acd1a16a" translate="yes" xml:space="preserve">
          <source>With the tools discussed so far you can create fully functional tables. The remainder of this chapter is concerned with adding features to the table definition to ensure data integrity, security, or convenience. If you are eager to fill your tables with data now you can skip ahead to &lt;a href=&quot;https://www.postgresql.org/docs/13/dml.html&quot;&gt;Chapter 6&lt;/a&gt; and read the rest of this chapter later.</source>
          <target state="translated">これまでに説明したツールを使用すると、完全に機能するテーブルを作成できます。この章の残りの部分では、テーブル定義に機能を追加して、データの整合性、セキュリティ、または利便性を確保します。テーブルにデータを入力したい場合は、&lt;a href=&quot;https://www.postgresql.org/docs/13/dml.html&quot;&gt;第6章に&lt;/a&gt;スキップして、この章の残りの部分を後で読むことができます。</target>
        </trans-unit>
        <trans-unit id="37674f638cca87d9f8a3c6dc8d132c3743ff6b7c" translate="yes" xml:space="preserve">
          <source>With this parameter enabled, you can still create ordinary global users. Simply append &lt;code&gt;@&lt;/code&gt; when specifying the user name in the client, e.g. &lt;code&gt;joe@&lt;/code&gt;. The &lt;code&gt;@&lt;/code&gt; will be stripped off before the user name is looked up by the server.</source>
          <target state="translated">このパラメーターを有効にしても、通常のグローバルユーザーを作成できます。クライアントでユーザー名を指定するときは、 &lt;code&gt;@&lt;/code&gt; を追加するだけです（例： &lt;code&gt;joe@&lt;/code&gt; 。 &lt;code&gt;@&lt;/code&gt; は、ユーザー名がサーバーによって検索される前に剥離することになります。</target>
        </trans-unit>
        <trans-unit id="5c255d5e2ff800e00e81014aac8b22d43990196d" translate="yes" xml:space="preserve">
          <source>With this parameter enabled, you can still create ordinary global users. Simply append &lt;code&gt;@&lt;/code&gt; when specifying the user name in the client, e.g., &lt;code&gt;joe@&lt;/code&gt;. The &lt;code&gt;@&lt;/code&gt; will be stripped off before the user name is looked up by the server.</source>
          <target state="translated">このパラメーターを有効にしても、通常のグローバルユーザーを作成できます。クライアントでユーザー名を指定するときは、 &lt;code&gt;@&lt;/code&gt; を追加するだけです（例： &lt;code&gt;joe@&lt;/code&gt; 。 &lt;code&gt;@&lt;/code&gt; は、ユーザー名がサーバーによって検索される前に剥離することになります。</target>
        </trans-unit>
        <trans-unit id="de39e9b44ca28bac2cf5d078925f7311c5e84abb" translate="yes" xml:space="preserve">
          <source>With this preparation, a backup can be taken using a script like the following:</source>
          <target state="translated">この準備があれば、以下のようなスクリプトを使ってバックアップを取ることができます。</target>
        </trans-unit>
        <trans-unit id="d7d93925105d3192c92e0036610fccacd28a3de6" translate="yes" xml:space="preserve">
          <source>Within &lt;code&gt;condition&lt;/code&gt; and &lt;code&gt;command&lt;/code&gt;, the special table names &lt;code&gt;NEW&lt;/code&gt; and &lt;code&gt;OLD&lt;/code&gt; can be used to refer to values in the referenced table. &lt;code&gt;NEW&lt;/code&gt; is valid in &lt;code&gt;ON INSERT&lt;/code&gt; and &lt;code&gt;ON UPDATE&lt;/code&gt; rules to refer to the new row being inserted or updated. &lt;code&gt;OLD&lt;/code&gt; is valid in &lt;code&gt;ON UPDATE&lt;/code&gt; and &lt;code&gt;ON DELETE&lt;/code&gt; rules to refer to the existing row being updated or deleted.</source>
          <target state="translated">&lt;code&gt;condition&lt;/code&gt; および &lt;code&gt;command&lt;/code&gt; 内では、 &lt;code&gt;NEW&lt;/code&gt; および &lt;code&gt;OLD&lt;/code&gt; という特別なテーブル名を使用して、参照されるテーブルの値を参照できます。 &lt;code&gt;NEW&lt;/code&gt; は、 &lt;code&gt;ON INSERT&lt;/code&gt; および &lt;code&gt;ON UPDATE&lt;/code&gt; ルールで有効であり、挿入または更新される新しい行を参照します。 &lt;code&gt;OLD&lt;/code&gt; は、更新または削除される既存の行を参照する &lt;code&gt;ON UPDATE&lt;/code&gt; および &lt;code&gt;ON DELETE&lt;/code&gt; ルールで有効です。</target>
        </trans-unit>
        <trans-unit id="b7c7983937789ea59f666ccaa3b6dc10f18e4489" translate="yes" xml:space="preserve">
          <source>Within a &lt;code&gt;tsquery&lt;/code&gt;, the &lt;code&gt;&amp;amp;&lt;/code&gt; (AND) operator specifies that both its arguments must appear in the document to have a match. Similarly, the &lt;code&gt;|&lt;/code&gt; (OR) operator specifies that at least one of its arguments must appear, while the &lt;code&gt;!&lt;/code&gt; (NOT) operator specifies that its argument must &lt;em&gt;not&lt;/em&gt; appear in order to have a match. For example, the query &lt;code&gt;fat &amp;amp; ! rat&lt;/code&gt; matches documents that contain &lt;code&gt;fat&lt;/code&gt; but not &lt;code&gt;rat&lt;/code&gt;.</source>
          <target state="translated">内 &lt;code&gt;tsquery&lt;/code&gt; 、 &lt;code&gt;&amp;amp;&lt;/code&gt; （AND）演算子の両方を指定その引数が試合を持っているために、文書に表示されなければならないこと。同様に、 &lt;code&gt;|&lt;/code&gt; （OR）演算子は、引数の少なくとも1つが出現する必要があることを指定しますが、 &lt;code&gt;!&lt;/code&gt; （NOT）演算子は、一致させるためにその引数が出現してはなら&lt;em&gt;ない&lt;/em&gt;ことを指定します。たとえば、クエリ &lt;code&gt;fat &amp;amp; ! rat&lt;/code&gt; は、 &lt;code&gt;fat&lt;/code&gt; を含むが、 &lt;code&gt;rat&lt;/code&gt; を含まないドキュメントに一致します。</target>
        </trans-unit>
        <trans-unit id="f2368cc4cb5a919d014b1e03cda4cf0d9819b781" translate="yes" xml:space="preserve">
          <source>Within a bracket expression, a collating element (a character, a multiple-character sequence that collates as if it were a single character, or a collating-sequence name for either) enclosed in &lt;code&gt;[.&lt;/code&gt; and &lt;code&gt;.]&lt;/code&gt; stands for the sequence of characters of that collating element. The sequence is treated as a single element of the bracket expression's list. This allows a bracket expression containing a multiple-character collating element to match more than one character, e.g., if the collating sequence includes a &lt;code&gt;ch&lt;/code&gt; collating element, then the RE &lt;code&gt;[[.ch.]]*c&lt;/code&gt; matches the first five characters of &lt;code&gt;chchcc&lt;/code&gt;.</source>
          <target state="translated">ブラケット式内で、 &lt;code&gt;[.&lt;/code&gt; 囲まれた照合要素（文字、単一文字であるかのように照合する複数文字シーケンス、またはいずれかの照合シーケンス名）。 and &lt;code&gt;.]&lt;/code&gt; は、その照合要素の文字シーケンスを表します。シーケンスは、ブラケット式のリストの単一の要素として扱われます。これにより、複数文字の照合要素を含むブラケット式が複数の文字に一致することができます。たとえば、照合シーケンスに &lt;code&gt;ch&lt;/code&gt; 照合要素が含まれている場合、RE &lt;code&gt;[[.ch.]]*c&lt;/code&gt; は &lt;code&gt;chchcc&lt;/code&gt; の最初の5文字に一致します。</target>
        </trans-unit>
        <trans-unit id="5e1fe750b2061555e551fa7ddfd0d60d1ac81517" translate="yes" xml:space="preserve">
          <source>Within a bracket expression, a collating element enclosed in &lt;code&gt;[=&lt;/code&gt; and &lt;code&gt;=]&lt;/code&gt; is an &lt;em&gt;equivalence class&lt;/em&gt;, standing for the sequences of characters of all collating elements equivalent to that one, including itself. (If there are no other equivalent collating elements, the treatment is as if the enclosing delimiters were &lt;code&gt;[.&lt;/code&gt; and &lt;code&gt;.]&lt;/code&gt;.) For example, if &lt;code&gt;o&lt;/code&gt; and &lt;code&gt;^&lt;/code&gt; are the members of an equivalence class, then &lt;code&gt;[[=o=]]&lt;/code&gt;, &lt;code&gt;[[=^=]]&lt;/code&gt;, and &lt;code&gt;[o^]&lt;/code&gt; are all synonymous. An equivalence class cannot be an endpoint of a range.</source>
          <target state="translated">ブラケット式内では、 &lt;code&gt;[=&lt;/code&gt; と &lt;code&gt;=]&lt;/code&gt; で囲まれた照合要素は&lt;em&gt;等価クラスであり&lt;/em&gt;、それ自体を含む、それに対応するすべての照合要素の文字のシーケンスを表します。 （同等の照合要素が他にない場合、囲まれた区切り文字が &lt;code&gt;[.&lt;/code&gt; および &lt;code&gt;.]&lt;/code&gt; かのように処理されます。）たとえば、 &lt;code&gt;o&lt;/code&gt; と &lt;code&gt;^&lt;/code&gt; が同値クラスのメンバーである場合、 &lt;code&gt;[[=o=]]&lt;/code&gt; 、 &lt;code&gt;[[=^=]]&lt;/code&gt; と &lt;code&gt;[o^]&lt;/code&gt; はすべて同義です。同値クラスを範囲のエンドポイントにすることはできません。</target>
        </trans-unit>
        <trans-unit id="abb82d076f25a7be9aee0f56365d178b74a1a2ff" translate="yes" xml:space="preserve">
          <source>Within a bracket expression, the name of a character class enclosed in &lt;code&gt;[:&lt;/code&gt; and &lt;code&gt;:]&lt;/code&gt; stands for the list of all characters belonging to that class. A character class cannot be used as an endpoint of a range. The POSIX standard defines these character class names: &lt;code&gt;alnum&lt;/code&gt; (letters and numeric digits), &lt;code&gt;alpha&lt;/code&gt; (letters), &lt;code&gt;blank&lt;/code&gt; (space and tab), &lt;code&gt;cntrl&lt;/code&gt; (control characters), &lt;code&gt;digit&lt;/code&gt; (numeric digits), &lt;code&gt;graph&lt;/code&gt; (printable characters except space), &lt;code&gt;lower&lt;/code&gt; (lower-case letters), &lt;code&gt;print&lt;/code&gt; (printable characters including space), &lt;code&gt;punct&lt;/code&gt; (punctuation), &lt;code&gt;space&lt;/code&gt; (any white space), &lt;code&gt;upper&lt;/code&gt; (upper-case letters), and &lt;code&gt;xdigit&lt;/code&gt; (hexadecimal digits). The behavior of these standard character classes is generally consistent across platforms for characters in the 7-bit ASCII set. Whether a given non-ASCII character is considered to belong to one of these classes depends on the &lt;em&gt;collation&lt;/em&gt; that is used for the regular-expression function or operator (see &lt;a href=&quot;collation&quot;&gt;Section 23.2&lt;/a&gt;), or by default on the database's &lt;code&gt;LC_CTYPE&lt;/code&gt; locale setting (see &lt;a href=&quot;locale&quot;&gt;Section 23.1&lt;/a&gt;). The classification of non-ASCII characters can vary across platforms even in similarly-named locales. (But the &lt;code&gt;C&lt;/code&gt; locale never considers any non-ASCII characters to belong to any of these classes.) In addition to these standard character classes, PostgreSQL defines the &lt;code&gt;ascii&lt;/code&gt; character class, which contains exactly the 7-bit ASCII set.</source>
          <target state="translated">ブラケット式内では、 &lt;code&gt;[:&lt;/code&gt; と &lt;code&gt;:]&lt;/code&gt; で囲まれた文字クラスの名前は、そのクラスに属するすべての文字のリストを表します。文字クラスは範囲のエンドポイントとして使用できません。 POSIX標準では、これらの文字クラス名を定義しています &lt;code&gt;alnum&lt;/code&gt; （文字と数字）、 &lt;code&gt;alpha&lt;/code&gt; （文字）、 &lt;code&gt;blank&lt;/code&gt; （スペースとタブ）、 &lt;code&gt;cntrl&lt;/code&gt; （制御文字）、 &lt;code&gt;digit&lt;/code&gt; （数字）、 &lt;code&gt;graph&lt;/code&gt; （スペース以外の印刷可能な文字）、 &lt;code&gt;lower&lt;/code&gt; （小文字）、 &lt;code&gt;print&lt;/code&gt; （スペースを含む印刷可能文字）、 &lt;code&gt;punct&lt;/code&gt; （句読点）、 &lt;code&gt;space&lt;/code&gt; （任意の空白）、 &lt;code&gt;upper&lt;/code&gt; （大文字）、および &lt;code&gt;xdigit&lt;/code&gt; （16進数）。これらの標準文字クラスの動作は、7ビットASCIIセットの文字のプラットフォーム間で一般的に一貫しています。特定の非ASCII文字がこれらのクラスのいずれかに属していると見なされるかどうかは、正規表現関数または演算子に使用される&lt;em&gt;照合順序&lt;/em&gt;（&lt;a href=&quot;collation&quot;&gt;セクション23.2を&lt;/a&gt;参照）、またはデフォルトでデータベースの &lt;code&gt;LC_CTYPE&lt;/code&gt; ロケール設定（&lt;a href=&quot;locale&quot;&gt;セクション23.1を&lt;/a&gt;参照）に依存します。）。非ASCII文字の分類は、同様の名前のロケールであっても、プラットフォームによって異なる場合があります。 （しかし、 &lt;code&gt;C&lt;/code&gt; ロケールは、非ASCII文字がこれらのクラスのいずれかに属しているとは決して見なしません。）これらの標準文字クラスに加えて、PostgreSQLは、7ビットASCIIセットを正確に含む &lt;code&gt;ascii&lt;/code&gt; 文字クラスを定義します。</target>
        </trans-unit>
        <trans-unit id="d35bef27a0203dd6547cf96a8cb6d957c5595d5c" translate="yes" xml:space="preserve">
          <source>Within a pattern, &lt;code&gt;*&lt;/code&gt; matches any sequence of characters (including no characters) and &lt;code&gt;?&lt;/code&gt; matches any single character. (This notation is comparable to Unix shell file name patterns.) For example, &lt;code&gt;\dt int*&lt;/code&gt; displays tables whose names begin with &lt;code&gt;int&lt;/code&gt;. But within double quotes, &lt;code&gt;*&lt;/code&gt; and &lt;code&gt;?&lt;/code&gt; lose these special meanings and are just matched literally.</source>
          <target state="translated">パターン内では、 &lt;code&gt;*&lt;/code&gt; は任意の文字シーケンス（文字なしを含む）と一致し、 &lt;code&gt;?&lt;/code&gt; 任意の1文字と一致します。（この表記は、Unixシェルのファイル名パターンに相当します。）たとえば、 &lt;code&gt;\dt int*&lt;/code&gt; は、名前が &lt;code&gt;int&lt;/code&gt; で始まるテーブルを表示します。ただし、二重引用符内では、 &lt;code&gt;*&lt;/code&gt; および &lt;code&gt;?&lt;/code&gt; これらの特別な意味を失い、文字通り一致します。</target>
        </trans-unit>
        <trans-unit id="323b9b12ce6cec030c2782c77172b386cffa6487" translate="yes" xml:space="preserve">
          <source>Within an argument, text that is enclosed in backquotes (&lt;code&gt;`&lt;/code&gt;) is taken as a command line that is passed to the shell. The output of the command (with any trailing newline removed) replaces the backquoted text. Within the text enclosed in backquotes, no special quoting or other processing occurs, except that appearances of &lt;code&gt;:variable_name&lt;/code&gt; where &lt;code&gt;variable_name&lt;/code&gt; is a psql variable name are replaced by the variable's value. Also, appearances of &lt;code&gt;:'variable_name'&lt;/code&gt; are replaced by the variable's value suitably quoted to become a single shell command argument. (The latter form is almost always preferable, unless you are very sure of what is in the variable.) Because carriage return and line feed characters cannot be safely quoted on all platforms, the &lt;code&gt;:'variable_name'&lt;/code&gt; form prints an error message and does not substitute the variable value when such characters appear in the value.</source>
          <target state="translated">引数内では、バッククォート（ &lt;code&gt;`&lt;/code&gt; ）で囲まれたテキストが、シェルに渡されるコマンドラインとして解釈されます。コマンドの出力（末尾の改行が削除されている）は、バッククォートされたテキストを置き換えます。バッククォートで囲まれたテキスト内では、 &lt;code&gt;:variable_name&lt;/code&gt; （ &lt;code&gt;variable_name&lt;/code&gt; はpsql変数名）の出現が変数の値で置き換えられることを除いて、特別なクォートやその他の処理は行われません。また、 &lt;code&gt;:'variable_name'&lt;/code&gt; の出現単一のシェルコマンド引数になるように適切に引用された変数の値に置き換えられます。 （変数の内容が明確でない限り、ほとんどの場合後者の形式が推奨されます。）すべてのプラットフォームで復帰文字と改行文字を安全に引用できないため、 &lt;code&gt;:'variable_name'&lt;/code&gt; 形式はエラーメッセージを出力しません。そのような文字が値に現れる場合、変数値を置き換えます。</target>
        </trans-unit>
        <trans-unit id="02446a7929ab10f300f87f18642a172ae6a7fbfe" translate="yes" xml:space="preserve">
          <source>Within any particular database, only collations that use that database's encoding are of interest. Other entries in &lt;code&gt;pg_collation&lt;/code&gt; are ignored. Thus, a stripped collation name such as &lt;code&gt;de_DE&lt;/code&gt; can be considered unique within a given database even though it would not be unique globally. Use of the stripped collation names is recommended, since it will make one less thing you need to change if you decide to change to another database encoding. Note however that the &lt;code&gt;default&lt;/code&gt;, &lt;code&gt;C&lt;/code&gt;, and &lt;code&gt;POSIX&lt;/code&gt; collations can be used regardless of the database encoding.</source>
          <target state="translated">特定のデータベース内では、そのデータベースのエンコーディングを使用する照合のみが対象です。 &lt;code&gt;pg_collation&lt;/code&gt; 他のエントリは無視されます。したがって、 &lt;code&gt;de_DE&lt;/code&gt; などの除去された照合名は、グローバルに一意でなくても、特定のデータベース内で一意と見なすことができます。別のデータベースエンコーディングに変更する場合、変更する必要のあることが1つ少なくなるため、ストリップされた照合名を使用することをお勧めします。ただし、 &lt;code&gt;default&lt;/code&gt; 、 &lt;code&gt;C&lt;/code&gt; 、および &lt;code&gt;POSIX&lt;/code&gt; 照合は、データベースのエンコードに関係なく使用できることに注意してください。</target>
        </trans-unit>
        <trans-unit id="4a80b578691f1b5a7af0065fe86a5cb4aa2ce86a" translate="yes" xml:space="preserve">
          <source>Within bracket expressions, &lt;code&gt;\d&lt;/code&gt;, &lt;code&gt;\s&lt;/code&gt;, and &lt;code&gt;\w&lt;/code&gt; lose their outer brackets, and &lt;code&gt;\D&lt;/code&gt;, &lt;code&gt;\S&lt;/code&gt;, and &lt;code&gt;\W&lt;/code&gt; are illegal. (So, for example, &lt;code&gt;[a-c\d]&lt;/code&gt; is equivalent to &lt;code&gt;[a-c[:digit:]]&lt;/code&gt;. Also, &lt;code&gt;[a-c\D]&lt;/code&gt;, which is equivalent to &lt;code&gt;[a-c^[:digit:]]&lt;/code&gt;, is illegal.)</source>
          <target state="translated">ブラケット式内では、 &lt;code&gt;\d&lt;/code&gt; 、 &lt;code&gt;\s&lt;/code&gt; 、および &lt;code&gt;\w&lt;/code&gt; は外側のブラケットを失い、 &lt;code&gt;\D&lt;/code&gt; 、 &lt;code&gt;\S&lt;/code&gt; 、および &lt;code&gt;\W&lt;/code&gt; は無効です。 （たとえば、 &lt;code&gt;[a-c\d]&lt;/code&gt; は &lt;code&gt;[a-c[:digit:]]&lt;/code&gt; ]と同等です。また、 &lt;code&gt;[a-c\D]&lt;/code&gt; は &lt;code&gt;[a-c^[:digit:]]&lt;/code&gt; と同等であり、不正です。）</target>
        </trans-unit>
        <trans-unit id="2542957abf2f09b64545fb48b800de1036c8c62f" translate="yes" xml:space="preserve">
          <source>Within each FSM page is a binary tree, stored in an array with one byte per node. Each leaf node represents a heap page, or a lower level FSM page. In each non-leaf node, the higher of its children's values is stored. The maximum value in the leaf nodes is therefore stored at the root.</source>
          <target state="translated">各 FSM ページ内には、ノードごとに 1 バイトの配列に格納されたバイナリツリーがあります。各リーフノードはヒープページ、または下位レベルのFSMページを表します。各非リーフノードでは、その子ノードの値のうち高い方の値が格納されます。したがって、リーフノードの最大値はルートに格納されます。</target>
        </trans-unit>
        <trans-unit id="eb8d6e1ae92682e55948b9d998dc41d07bd4d9ee" translate="yes" xml:space="preserve">
          <source>Within each catalog row, write comma-separated &lt;code&gt;key&lt;/code&gt;&lt;code&gt;=&amp;gt;&lt;/code&gt;&lt;code&gt;value&lt;/code&gt; pairs. The allowed &lt;code&gt;key&lt;/code&gt;s are the names of the catalog's columns, plus the metadata keys &lt;code&gt;oid&lt;/code&gt;, &lt;code&gt;oid_symbol&lt;/code&gt;, &lt;code&gt;array_type_oid&lt;/code&gt;, and &lt;code&gt;descr&lt;/code&gt;. (The use of &lt;code&gt;oid&lt;/code&gt; and &lt;code&gt;oid_symbol&lt;/code&gt; is described in &lt;a href=&quot;system-catalog-initial-data#SYSTEM-CATALOG-OID-ASSIGNMENT&quot;&gt;Section 69.2.2&lt;/a&gt; below, while &lt;code&gt;array_type_oid&lt;/code&gt; is described in &lt;a href=&quot;system-catalog-initial-data#SYSTEM-CATALOG-AUTO-ARRAY-TYPES&quot;&gt;Section 69.2.4&lt;/a&gt;. &lt;code&gt;descr&lt;/code&gt; supplies a description string for the object, which will be inserted into &lt;code&gt;pg_description&lt;/code&gt; or &lt;code&gt;pg_shdescription&lt;/code&gt; as appropriate.) While the metadata keys are optional, the catalog's defined columns must all be provided, except when the catalog's &lt;code&gt;.h&lt;/code&gt; file specifies a default value for the column. (In the example above, the &lt;code&gt;datdba&lt;/code&gt; field has been omitted because &lt;code&gt;pg_database.h&lt;/code&gt; supplies a suitable default value for it.)</source>
          <target state="translated">各カタログ行内に、カンマ区切りの &lt;code&gt;key&lt;/code&gt; &lt;code&gt;=&amp;gt;&lt;/code&gt; &lt;code&gt;value&lt;/code&gt; ペアを記述します。許可される &lt;code&gt;key&lt;/code&gt; は、カタログの列の名前と、メタデータキー &lt;code&gt;oid&lt;/code&gt; 、 &lt;code&gt;oid_symbol&lt;/code&gt; 、 &lt;code&gt;array_type_oid&lt;/code&gt; 、および &lt;code&gt;descr&lt;/code&gt; です。 （の使用 &lt;code&gt;oid&lt;/code&gt; と &lt;code&gt;oid_symbol&lt;/code&gt; がに記載されている&lt;a href=&quot;system-catalog-initial-data#SYSTEM-CATALOG-OID-ASSIGNMENT&quot;&gt;セクション69.2.2&lt;/a&gt;ながら、以下 &lt;code&gt;array_type_oid&lt;/code&gt; がに記載されている&lt;a href=&quot;system-catalog-initial-data#SYSTEM-CATALOG-AUTO-ARRAY-TYPES&quot;&gt;セクション69.2.4&lt;/a&gt;。 &lt;code&gt;descr&lt;/code&gt; 中に挿入されるオブジェクトの説明文字列を供給する &lt;code&gt;pg_description&lt;/code&gt; または &lt;code&gt;pg_shdescription&lt;/code&gt; メタデータキーはオプションですが、カタログの &lt;code&gt;.h&lt;/code&gt; ファイルで列のデフォルト値が指定されている場合を除き、カタログで定義されている列をすべて指定する必要があります。（上記の例では、 &lt;code&gt;pg_database.h&lt;/code&gt; が適切なデフォルト値を提供するため、 &lt;code&gt;datdba&lt;/code&gt; フィールドは省略されています。）</target>
        </trans-unit>
        <trans-unit id="3b70f85093aa93c4bd37783889d55ab04e575f61" translate="yes" xml:space="preserve">
          <source>Within each pair of curly braces, the metadata fields &lt;code&gt;oid&lt;/code&gt;, &lt;code&gt;oid_symbol&lt;/code&gt;, &lt;code&gt;array_type_oid&lt;/code&gt;, and &lt;code&gt;descr&lt;/code&gt; (if present) come first, in that order, then the catalog's own fields appear in their defined order.</source>
          <target state="translated">中括弧の各ペア内で、メタデータフィールド &lt;code&gt;oid&lt;/code&gt; 、 &lt;code&gt;oid_symbol&lt;/code&gt; 、 &lt;code&gt;array_type_oid&lt;/code&gt; 、および &lt;code&gt;descr&lt;/code&gt; （存在する場合）がこの順序で最初に来て、次にカタログの独自のフィールドが定義された順序で表示されます。</target>
        </trans-unit>
        <trans-unit id="7877c1484b515b178eb13d5365bc7aee43c3498f" translate="yes" xml:space="preserve">
          <source>Within larger commands, &lt;code&gt;VALUES&lt;/code&gt; is syntactically allowed anywhere that &lt;code&gt;SELECT&lt;/code&gt; is. Because it is treated like a &lt;code&gt;SELECT&lt;/code&gt; by the grammar, it is possible to use the &lt;code&gt;ORDER BY&lt;/code&gt;, &lt;code&gt;LIMIT&lt;/code&gt; (or equivalently &lt;code&gt;FETCH FIRST&lt;/code&gt;), and &lt;code&gt;OFFSET&lt;/code&gt; clauses with a &lt;code&gt;VALUES&lt;/code&gt; command.</source>
          <target state="translated">より大きなコマンド内では、 &lt;code&gt;VALUES&lt;/code&gt; は構文的に &lt;code&gt;SELECT&lt;/code&gt; のどこにでも許可されます。文法では &lt;code&gt;SELECT&lt;/code&gt; のように扱われるため、 &lt;code&gt;VALUES&lt;/code&gt; コマンドで &lt;code&gt;ORDER BY&lt;/code&gt; 、 &lt;code&gt;LIMIT&lt;/code&gt; （または同等の &lt;code&gt;FETCH FIRST&lt;/code&gt; ）、および &lt;code&gt;OFFSET&lt;/code&gt; 句を使用できます。</target>
        </trans-unit>
        <trans-unit id="85b2c20b975865db54e88c092240735063656bf9" translate="yes" xml:space="preserve">
          <source>Without a &lt;code&gt;table_and_columns&lt;/code&gt; list, &lt;code&gt;ANALYZE&lt;/code&gt; processes every table and materialized view in the current database that the current user has permission to analyze. With a list, &lt;code&gt;ANALYZE&lt;/code&gt; processes only those table(s). It is further possible to give a list of column names for a table, in which case only the statistics for those columns are collected.</source>
          <target state="translated">&lt;code&gt;table_and_columns&lt;/code&gt; リストがない場合、 &lt;code&gt;ANALYZE&lt;/code&gt; は、現在のユーザーが分析する権限を持つ現在のデータベース内のすべてのテーブルとマテリアライズドビューを処理します。 &lt;code&gt;ANALYZE&lt;/code&gt; はリストを使用して、それらのテーブルのみを処理します。さらに、テーブルの列名のリストを指定することもできます。その場合、それらの列の統計のみが収集されます。</target>
        </trans-unit>
        <trans-unit id="0bd2342b55fa6fe36f0fd7dea1e8abcfbe35286d" translate="yes" xml:space="preserve">
          <source>Without a &lt;code&gt;table_and_columns&lt;/code&gt; list, &lt;code&gt;VACUUM&lt;/code&gt; processes every table and materialized view in the current database that the current user has permission to vacuum. With a list, &lt;code&gt;VACUUM&lt;/code&gt; processes only those table(s).</source>
          <target state="translated">&lt;code&gt;table_and_columns&lt;/code&gt; リストがない場合、 &lt;code&gt;VACUUM&lt;/code&gt; は、現在のユーザーがバキュームする権限を持つ現在のデータベース内のすべてのテーブルとマテリアライズドビューを処理します。リストを使用すると、 &lt;code&gt;VACUUM&lt;/code&gt; はそれらのテーブルのみを処理します。</target>
        </trans-unit>
        <trans-unit id="2564642da39c57e6f0da0af32cec7b221b00e6cf" translate="yes" xml:space="preserve">
          <source>Without a qualification, &lt;code&gt;DELETE&lt;/code&gt; will remove &lt;em&gt;all&lt;/em&gt; rows from the given table, leaving it empty. The system will not request confirmation before doing this!</source>
          <target state="translated">修飾がない場合、 &lt;code&gt;DELETE&lt;/code&gt; は指定されたテーブルから&lt;em&gt;すべての&lt;/em&gt;行を削除し、空のままにします。システムはこれを行う前に確認を要求しません！</target>
        </trans-unit>
        <trans-unit id="63fcdcc5d8356bd3ccce31a7a0f56d4a3af85303" translate="yes" xml:space="preserve">
          <source>Without functional-dependency statistics, the planner would assume that the two &lt;code&gt;WHERE&lt;/code&gt; conditions are independent, and would multiply their selectivities together to arrive at a much-too-small row count estimate. With such statistics, the planner recognizes that the &lt;code&gt;WHERE&lt;/code&gt; conditions are redundant and does not underestimate the row count.</source>
          <target state="translated">機能依存の統計がない場合、プランナは2つの &lt;code&gt;WHERE&lt;/code&gt; 条件が独立していると想定し、選択性を掛け合わせて、行数の見積もりが少なすぎます。このような統計により、プランナは &lt;code&gt;WHERE&lt;/code&gt; 条件が冗長であることを認識し、行数を過小評価しません。</target>
        </trans-unit>
        <trans-unit id="dc783547ace7f2e9e22e7b50a67f3d97784d6474" translate="yes" xml:space="preserve">
          <source>Without partition pruning, the above query would scan each of the partitions of the &lt;code&gt;measurement&lt;/code&gt; table. With partition pruning enabled, the planner will examine the definition of each partition and prove that the partition need not be scanned because it could not contain any rows meeting the query's &lt;code&gt;WHERE&lt;/code&gt; clause. When the planner can prove this, it excludes (&lt;em&gt;prunes&lt;/em&gt;) the partition from the query plan.</source>
          <target state="translated">パーティションプルーニングを使用しない場合、上記のクエリは &lt;code&gt;measurement&lt;/code&gt; テーブルの各パーティションをスキャンします。パーティションプルーニングを有効にすると、プランナは各パーティションの定義を調べ、クエリの &lt;code&gt;WHERE&lt;/code&gt; 句を満たす行を含めることができないため、パーティションをスキャンする必要がないことを証明します。プランナーがこれを証明できる場合、クエリプランからパーティションを除外（&lt;em&gt;プルーニング&lt;/em&gt;）します。</target>
        </trans-unit>
        <trans-unit id="23034486b72d6e700160ee9f0facdf636985eee4" translate="yes" xml:space="preserve">
          <source>Without quotes, &lt;code&gt;to_tsquery&lt;/code&gt; will generate a syntax error for tokens that are not separated by an AND, OR, or FOLLOWED BY operator.</source>
          <target state="translated">引用符がないと、 &lt;code&gt;to_tsquery&lt;/code&gt; は、AND、OR、またはFOLLOWED BY演算子で区切られていないトークンの構文エラーを生成します。</target>
        </trans-unit>
        <trans-unit id="8d1c012acaa571247fa7393ff98695c754cfacba" translate="yes" xml:space="preserve">
          <source>Without the extra parentheses, this will generate a syntax error.</source>
          <target state="translated">余分な括弧がない場合は、構文エラーが発生します。</target>
        </trans-unit>
        <trans-unit id="3003268a98f289ec381313920f30367739bc175f" translate="yes" xml:space="preserve">
          <source>Without the third rule, it is possible for an index reader to see an index entry just before it is removed by &lt;code&gt;VACUUM&lt;/code&gt;, and then to arrive at the corresponding heap entry after that was removed by &lt;code&gt;VACUUM&lt;/code&gt;. This creates no serious problems if that item number is still unused when the reader reaches it, since an empty item slot will be ignored by &lt;code&gt;heap_fetch()&lt;/code&gt;. But what if a third backend has already re-used the item slot for something else? When using an MVCC-compliant snapshot, there is no problem because the new occupant of the slot is certain to be too new to pass the snapshot test. However, with a non-MVCC-compliant snapshot (such as &lt;code&gt;SnapshotAny&lt;/code&gt;), it would be possible to accept and return a row that does not in fact match the scan keys. We could defend against this scenario by requiring the scan keys to be rechecked against the heap row in all cases, but that is too expensive. Instead, we use a pin on an index page as a proxy to indicate that the reader might still be &amp;ldquo;in flight&amp;rdquo; from the index entry to the matching heap entry. Making &lt;code&gt;ambulkdelete&lt;/code&gt; block on such a pin ensures that &lt;code&gt;VACUUM&lt;/code&gt; cannot delete the heap entry before the reader is done with it. This solution costs little in run time, and adds blocking overhead only in the rare cases where there actually is a conflict.</source>
          <target state="translated">インデックスリーダーは、それがすることによって除去される直前にインデックスエントリを参照するための第3のルールなしで、それが可能で &lt;code&gt;VACUUM&lt;/code&gt; 、その後それはによって除去した後、対応するヒープ・エントリに到達する &lt;code&gt;VACUUM&lt;/code&gt; 。空の項目スロットは &lt;code&gt;heap_fetch()&lt;/code&gt; によって無視されるため、リーダーが到達したときにその項目番号がまだ使用されていなくても、重大な問題は発生しません。しかし、3番目のバックエンドがすでにアイテムスロットを別のものに再利用している場合はどうでしょうか。 MVCC準拠のスナップショットを使用する場合、スロットの新しい占有者はスナップショットテストに合格するには新しすぎることが確実であるため、問題はありません。ただし、MVCCに準拠していないスナップショット（ &lt;code&gt;SnapshotAny&lt;/code&gt; など））、実際にはスキャンキーと一致しない行を受け入れて返すことが可能です。スキャンキーをすべての場合にヒープ行に対して再チェックするように要求することで、このシナリオを防ぐことができますが、それではコストがかかりすぎます。代わりに、インデックスページのピンをプロキシとして使用して、リーダーがインデックスエントリから一致するヒープエントリにまだ「移動中」である可能性があることを示します。そのようなピンで &lt;code&gt;ambulkdelete&lt;/code&gt; ブロックを作成すると、リーダーがそれを完了する前に、 &lt;code&gt;VACUUM&lt;/code&gt; がヒープエントリを削除できないことが保証されます。このソリューションの実行コストはほとんどなく、実際に競合が発生するまれなケースでのみブロッキングオーバーヘッドが追加されます。</target>
        </trans-unit>
        <trans-unit id="fdba0729d7141c4dc983525f28420a370b378b16" translate="yes" xml:space="preserve">
          <source>Without this clause, it is an error to specify an explicit value (other than &lt;code&gt;DEFAULT&lt;/code&gt;) for an identity column defined as &lt;code&gt;GENERATED ALWAYS&lt;/code&gt;. This clause overrides that restriction.</source>
          <target state="translated">この句がないと、 &lt;code&gt;GENERATED ALWAYS&lt;/code&gt; として定義されているID列に明示的な値（ &lt;code&gt;DEFAULT&lt;/code&gt; 以外）を指定するとエラーになります。この句はその制限を上書きします。</target>
        </trans-unit>
        <trans-unit id="77f4e928561a920783857c04bc4af1f2750cf7f5" translate="yes" xml:space="preserve">
          <source>Without this option, the backup will start by enumerating the size of the entire database, and then go back and send the actual contents. This may make the backup take slightly longer, and in particular it will take longer before the first data is sent. This option is useful to avoid such estimation time if it's too long.</source>
          <target state="translated">このオプションがない場合、バックアップはデータベース全体のサイズを列挙することから始まり、その後、実際の内容に戻って送信されます。このため、バックアップに若干の時間がかかり、特に最初のデータが送信されるまでに時間がかかることがあります。このオプションは、このような推定時間が長すぎる場合に回避するのに便利です。</target>
        </trans-unit>
        <trans-unit id="5de5c631615b4050dbf3abcb11bda852949d1d49" translate="yes" xml:space="preserve">
          <source>Word, all ASCII letters</source>
          <target state="translated">ワード、すべてのASCII文字</target>
        </trans-unit>
        <trans-unit id="cd638519c2bb50f94881c41d59edcf0f4b988187" translate="yes" xml:space="preserve">
          <source>Word, all letters</source>
          <target state="translated">ワード、すべての文字</target>
        </trans-unit>
        <trans-unit id="d929261f89fb5edc0a55361dccd5a42cfafc1e28" translate="yes" xml:space="preserve">
          <source>Word, letters and digits</source>
          <target state="translated">単語、文字、数字</target>
        </trans-unit>
        <trans-unit id="1c821c5f35490070199526bcafeccdc95331fb80" translate="yes" xml:space="preserve">
          <source>Work is still needed to improve the genetic algorithm parameter settings. In file &lt;code&gt;src/backend/optimizer/geqo/geqo_main.c&lt;/code&gt;, routines &lt;code&gt;gimme_pool_size&lt;/code&gt; and &lt;code&gt;gimme_number_generations&lt;/code&gt;, we have to find a compromise for the parameter settings to satisfy two competing demands:</source>
          <target state="translated">遺伝的アルゴリズムのパラメーター設定を改善するための作業がまだ必要です。ファイル &lt;code&gt;src/backend/optimizer/geqo/geqo_main.c&lt;/code&gt; 、ルーチン &lt;code&gt;gimme_pool_size&lt;/code&gt; および &lt;code&gt;gimme_number_generations&lt;/code&gt; で、2つの競合する要求を満たすためにパラメーター設定の妥協点を見つける必要があります。</target>
        </trans-unit>
        <trans-unit id="3ae6871c604e1194dadbdf1baf868fa3278d7cc4" translate="yes" xml:space="preserve">
          <source>Write Ahead Log</source>
          <target state="translated">ライトアヘッドログ</target>
        </trans-unit>
        <trans-unit id="3f9793b6786fb282a995505c49ca5c8dab4849b1" translate="yes" xml:space="preserve">
          <source>Write a message to the server log if checkpoints caused by the filling of WAL segment files happen closer together than this amount of time (which suggests that &lt;code&gt;max_wal_size&lt;/code&gt; ought to be raised). If this value is specified without units, it is taken as seconds. The default is 30 seconds (&lt;code&gt;30s&lt;/code&gt;). Zero disables the warning. No warnings will be generated if &lt;code&gt;checkpoint_timeout&lt;/code&gt; is less than &lt;code&gt;checkpoint_warning&lt;/code&gt;. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">WALセグメントファイルの書き込みによって発生したチェックポイントがこの時間よりも近く発生した場合は、サーバーログにメッセージを書き込みます（ &lt;code&gt;max_wal_size&lt;/code&gt; を大きくする必要があることを示しています）。この値が単位なしで指定された場合、秒として取得されます。デフォルトは30秒（ &lt;code&gt;30s&lt;/code&gt; ）です。ゼロは警告を無効にします。どんな警告は生成されません &lt;code&gt;checkpoint_timeout&lt;/code&gt; より少ない &lt;code&gt;checkpoint_warning&lt;/code&gt; 。このパラメーターは、 &lt;code&gt;postgresql.conf&lt;/code&gt; ファイルまたはサーバーのコマンドラインでのみ設定できます。</target>
        </trans-unit>
        <trans-unit id="79f29b256742ae32a7ee610c6c80dec55fe4bb44" translate="yes" xml:space="preserve">
          <source>Write all query output into file &lt;code&gt;filename&lt;/code&gt;, in addition to the normal output destination.</source>
          <target state="translated">通常の出力先に加えて、すべてのクエリ出力をファイル &lt;code&gt;filename&lt;/code&gt; に書き込みます。</target>
        </trans-unit>
        <trans-unit id="ced9f94f9040a73c60549d122b831459c11a3fbf" translate="yes" xml:space="preserve">
          <source>Write information about each transaction to a log file. See below for details.</source>
          <target state="translated">各トランザクションの情報をログファイルに書き込みます。詳細は以下を参照してください。</target>
        </trans-unit>
        <trans-unit id="e33b6c1a70b5c50c6203011bb22d6394a5061934" translate="yes" xml:space="preserve">
          <source>Write received and decoded transaction data into this file. Use &lt;code&gt;-&lt;/code&gt; for stdout.</source>
          <target state="translated">受信およびデコードされたトランザクションデータをこのファイルに書き込みます。stdoutには &lt;code&gt;-&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="660438e8219803d5c64d3c38fd0601dbee576ac1" translate="yes" xml:space="preserve">
          <source>Write the output as plain files, with the same layout as the current data directory and tablespaces. When the cluster has no additional tablespaces, the whole database will be placed in the target directory. If the cluster contains additional tablespaces, the main data directory will be placed in the target directory, but all other tablespaces will be placed in the same absolute path as they have on the server.</source>
          <target state="translated">現在のデータディレクトリとテーブルスペースと同じレイアウトで、出力をプレーンファイルとして書き込みます。クラスタに追加のテーブルスペースがない場合、データベース全体がターゲットディレクトリに配置されます。クラスタに追加のテーブルスペースがある場合、メインデータディレクトリはターゲットディレクトリに配置されますが、他のすべてのテーブルスペースはサーバ上のものと同じ絶対パスに配置されます。</target>
        </trans-unit>
        <trans-unit id="6b1ff15d67ddd19c1531e3e1b72239d7b15119da" translate="yes" xml:space="preserve">
          <source>Write the output as plain files, with the same layout as the source server's data directory and tablespaces. When the cluster has no additional tablespaces, the whole database will be placed in the target directory. If the cluster contains additional tablespaces, the main data directory will be placed in the target directory, but all other tablespaces will be placed in the same absolute path as they have on the source server.</source>
          <target state="translated">出力は、ソースサーバのデータディレクトリとテーブルスペースと同じレイアウトで、プレーンファイルとして書き出します。クラスタに追加のテーブルスペースがない場合、データベース全体がターゲットディレクトリに配置されます。クラスタに追加のテーブルスペースがある場合は、メインデータディレクトリはターゲットディレクトリに配置されますが、他のすべてのテーブルスペースはソースサーバ上のものと同じ絶対パスに配置されます。</target>
        </trans-unit>
        <trans-unit id="bbc92c3f4b6de8494f22f127e95dec8313f91169" translate="yes" xml:space="preserve">
          <source>Write the output as tar files in the target directory. The main data directory will be written to a file named &lt;code&gt;base.tar&lt;/code&gt;, and all other tablespaces will be named after the tablespace OID.</source>
          <target state="translated">出力をtarファイルとしてターゲットディレクトリに書き込みます。メインデータディレクトリは &lt;code&gt;base.tar&lt;/code&gt; という名前のファイルに書き込まれ、他のすべてのテーブルスペースはテーブルスペースOIDに基づいて名前が付けられます。</target>
        </trans-unit>
        <trans-unit id="a1016f820515616448d3af03f5c6cb584f20f3bd" translate="yes" xml:space="preserve">
          <source>Write the output as tar files in the target directory. The main data directory's contents will be written to a file named &lt;code&gt;base.tar&lt;/code&gt;, and each other tablespace will be written to a separate tar file named after that tablespace's OID.</source>
          <target state="translated">出力をtarファイルとしてターゲットディレクトリに書き込みます。メインデータディレクトリの内容は &lt;code&gt;base.tar&lt;/code&gt; という名前のファイルに書き込まれ、他の各テーブルスペースはそのテーブルスペースのOIDにちなんで名付けられた個別のtarファイルに書き込まれます。</target>
        </trans-unit>
        <trans-unit id="12aba288e98df3f05ebad1cf7143b1a4df822af8" translate="yes" xml:space="preserve">
          <source>Write, or append to, a text file</source>
          <target state="translated">テキストファイルへの書き込み、または追加</target>
        </trans-unit>
        <trans-unit id="73694598d4f6dd9ae50f65c44a8d5357103fbda0" translate="yes" xml:space="preserve">
          <source>Write-Ahead Log</source>
          <target state="translated">ライトアヘッドログ</target>
        </trans-unit>
        <trans-unit id="32219ea741aab08cd4b2cc75491ff92cd882b3c1" translate="yes" xml:space="preserve">
          <source>Write-Ahead Log Shipping</source>
          <target state="translated">ライトアヘッドログ出荷</target>
        </trans-unit>
        <trans-unit id="bd375d03897609b092749de9e582ed65e566d377" translate="yes" xml:space="preserve">
          <source>Write-ahead log</source>
          <target state="translated">ライトアヘッドログ</target>
        </trans-unit>
        <trans-unit id="aab8077ca2cb9e3834b524a783525c97b082b885" translate="yes" xml:space="preserve">
          <source>Write-heavy workloads that don't benefit from deduplication due to having few or no duplicate values in indexes will incur a small, fixed performance penalty (unless deduplication is explicitly disabled). The &lt;code&gt;deduplicate_items&lt;/code&gt; storage parameter can be used to disable deduplication within individual indexes. There is never any performance penalty with read-only workloads, since reading posting list tuples is at least as efficient as reading the standard tuple representation. Disabling deduplication isn't usually helpful.</source>
          <target state="translated">インデックスに重複する値がほとんどないかまったくないために重複排除の恩恵を受けない書き込みの多いワークロードでは、パフォーマンスがわずかに固定されてペナルティが発生します（重複排除が明示的に無効にされていない場合）。 &lt;code&gt;deduplicate_items&lt;/code&gt; の格納パラメータは、個々のインデックス内の重複排除を無効に使用することができます。投稿リストのタプルを読み取ることは、少なくとも標準のタプル表現を読み取ることと同じくらい効率的であるため、読み取り専用ワークロードでパフォーマンスが低下することはありません。通常、重複排除を無効にすることは役に立ちません。</target>
        </trans-unit>
        <trans-unit id="674bcf8c81a59458958b21d0660da76f6ba332b5" translate="yes" xml:space="preserve">
          <source>Writes the current query buffer to the file &lt;code&gt;filename&lt;/code&gt; or pipes it to the shell command &lt;code&gt;command&lt;/code&gt;. If the current query buffer is empty, the most recently executed query is written instead.</source>
          <target state="translated">現在のクエリバッファをファイル &lt;code&gt;filename&lt;/code&gt; に書き込むか、それをシェルコマンド &lt;code&gt;command&lt;/code&gt; にパイプします。現在のクエリバッファが空の場合、最後に実行されたクエリが代わりに書き込まれます。</target>
        </trans-unit>
        <trans-unit id="b84228914215a42dbe6fe7e926dad3ab9b4cf367" translate="yes" xml:space="preserve">
          <source>Writes the generated LLVM IR out to the file system, inside &lt;a href=&quot;runtime-config-file-locations#GUC-DATA-DIRECTORY&quot;&gt;data_directory&lt;/a&gt;. This is only useful for working on the internals of the JIT implementation. The default setting is &lt;code&gt;off&lt;/code&gt;. This parameter can only be changed by a superuser.</source>
          <target state="translated">生成されたLLVM IRを&lt;a href=&quot;runtime-config-file-locations#GUC-DATA-DIRECTORY&quot;&gt;data_directory&lt;/a&gt;内のファイルシステムに書き込みます。これは、JIT実装の内部で作業する場合にのみ役立ちます。デフォルト設定は &lt;code&gt;off&lt;/code&gt; です。このパラメーターはスーパーユーザーのみが変更できます。</target>
        </trans-unit>
        <trans-unit id="682768582621701d8f61b9c4bbc3b649ebde2e19" translate="yes" xml:space="preserve">
          <source>Writes, or appends to, a text file.</source>
          <target state="translated">テキストファイルへの書き込み、または追加を行います。</target>
        </trans-unit>
        <trans-unit id="d5af6404c7f764d57f9d5c62315cdf9f310e1309" translate="yes" xml:space="preserve">
          <source>Writing &lt;code&gt;*&lt;/code&gt; is not necessary, since this behavior is always the default. However, this syntax is still supported for compatibility with older releases where the default could be changed.</source>
          <target state="translated">この動作は常にデフォルトであるため、 &lt;code&gt;*&lt;/code&gt; を記述する必要はありません。ただし、この構文は、デフォルトを変更できる古いリリースとの互換性のために引き続きサポートされています。</target>
        </trans-unit>
        <trans-unit id="6151e701c60f047c7b832b2686813d1310a12fca" translate="yes" xml:space="preserve">
          <source>Writing &lt;code&gt;ALL&lt;/code&gt; in place of a specific privilege grants all privileges that are relevant for the object type.</source>
          <target state="translated">特定の特権の代わりに &lt;code&gt;ALL&lt;/code&gt; を書き込むと、オブジェクトタイプに関連するすべての特権が付与されます。</target>
        </trans-unit>
        <trans-unit id="f43277b6f1b770dadde2ceed80f27334202f924f" translate="yes" xml:space="preserve">
          <source>Writing &lt;code&gt;SECURITY DEFINER&lt;/code&gt; Functions Safely</source>
          <target state="translated">書き込み &lt;code&gt;SECURITY DEFINER&lt;/code&gt; の安全機能を</target>
        </trans-unit>
        <trans-unit id="ffbf328be37b139670f7ef37c6af175473c5c705" translate="yes" xml:space="preserve">
          <source>Writing a custom application, using one of the several available language bindings. These possibilities are discussed further in &lt;a href=&quot;https://www.postgresql.org/docs/12/client-interfaces.html&quot;&gt;Part IV&lt;/a&gt;.</source>
          <target state="translated">使用可能ないくつかの言語バインディングの1つを使用して、カスタムアプリケーションを作成します。これらの可能性については、&lt;a href=&quot;https://www.postgresql.org/docs/12/client-interfaces.html&quot;&gt;パートIVで&lt;/a&gt;さらに説明します。</target>
        </trans-unit>
        <trans-unit id="d2f9ec6d7e0edde20b9de31e1198d1816d564790" translate="yes" xml:space="preserve">
          <source>Writing a custom application, using one of the several available language bindings. These possibilities are discussed further in &lt;a href=&quot;https://www.postgresql.org/docs/13/client-interfaces.html&quot;&gt;Part IV&lt;/a&gt;.</source>
          <target state="translated">利用可能ないくつかの言語バインディングの1つを使用して、カスタムアプリケーションを作成します。これらの可能性については、&lt;a href=&quot;https://www.postgresql.org/docs/13/client-interfaces.html&quot;&gt;パートIVで&lt;/a&gt;詳しく説明します。</target>
        </trans-unit>
        <trans-unit id="de5165fc57d1f9a5e5c5994fec1932df3a128a9e" translate="yes" xml:space="preserve">
          <source>Writing the actual numeric value of any OID in C code is considered very bad form; always use a macro, instead. Direct references to &lt;code&gt;pg_proc&lt;/code&gt; OIDs are common enough that there's a special mechanism to create the necessary macros automatically; see &lt;code&gt;src/backend/utils/Gen_fmgrtab.pl&lt;/code&gt;. Similarly &amp;mdash; but, for historical reasons, not done the same way &amp;mdash; there's an automatic method for creating macros for &lt;code&gt;pg_type&lt;/code&gt; OIDs. &lt;code&gt;oid_symbol&lt;/code&gt; entries are therefore not necessary in those two catalogs. Likewise, macros for the &lt;code&gt;pg_class&lt;/code&gt; OIDs of system catalogs and indexes are set up automatically. For all other system catalogs, you have to manually specify any macros you need via &lt;code&gt;oid_symbol&lt;/code&gt; entries.</source>
          <target state="translated">CコードでOIDの実際の数値を書き込むことは、非常に悪い形式と見なされます。代わりに、常にマクロを使用してください。 &lt;code&gt;pg_proc&lt;/code&gt; OID への直接参照は十分に一般的であり、必要なマクロを自動的に作成する特別なメカニズムがあります。 &lt;code&gt;src/backend/utils/Gen_fmgrtab.pl&lt;/code&gt; を参照してください。同様に、しかし、歴史的な理由により、同じ方法で行われていません &lt;code&gt;pg_type&lt;/code&gt; OIDのマクロを作成するための自動メソッドがあります。したがって、これらの2つのカタログでは、 &lt;code&gt;oid_symbol&lt;/code&gt; エントリは必要ありません。同様に、システムカタログとインデックスの &lt;code&gt;pg_class&lt;/code&gt; OIDのマクロは自動的に設定されます。他のすべてのシステムカタログでは、 &lt;code&gt;oid_symbol&lt;/code&gt; エントリを介して必要なマクロを手動で指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="c032adc1ff629c9b66f22749ad667e6beadf144b" translate="yes" xml:space="preserve">
          <source>X</source>
          <target state="translated">X</target>
        </trans-unit>
        <trans-unit id="d5409f1461aa5b5298ee6d5c93002f7a27e50654" translate="yes" xml:space="preserve">
          <source>XID</source>
          <target state="translated">XID</target>
        </trans-unit>
        <trans-unit id="70fc167721857c5174dbbe545fe597100e840cd6" translate="yes" xml:space="preserve">
          <source>XID for VACUUM operation moving a row version</source>
          <target state="translated">行のバージョンを移動するVACUUM操作のためのXID</target>
        </trans-unit>
        <trans-unit id="c0aa9ef764d832b80428d756a731a94251b0e3a1" translate="yes" xml:space="preserve">
          <source>XML</source>
          <target state="translated">XML</target>
        </trans-unit>
        <trans-unit id="6dbc2e3a95bd424284a60fab71bfd99ecc6aa480" translate="yes" xml:space="preserve">
          <source>XML Functions</source>
          <target state="translated">XML 関数</target>
        </trans-unit>
        <trans-unit id="677fbcd727fb96243fff280b768de17534da204d" translate="yes" xml:space="preserve">
          <source>XML Limits and Conformance to SQL/XML</source>
          <target state="translated">XMLの限界とSQL/XMLへの適合性</target>
        </trans-unit>
        <trans-unit id="be1200e7280e074bb09cc29b489d7736fa9c3b13" translate="yes" xml:space="preserve">
          <source>XML Type</source>
          <target state="translated">XMLタイプ</target>
        </trans-unit>
        <trans-unit id="72f6e6e18c4cf2cdf2736a3171665401b5f531b0" translate="yes" xml:space="preserve">
          <source>XML data</source>
          <target state="translated">エックスエムエルデータ</target>
        </trans-unit>
        <trans-unit id="9bc2b7976718250ab1463410139c7c00b0f2e7ce" translate="yes" xml:space="preserve">
          <source>XML declarations, if present, are combined as follows. If all argument values have the same XML version declaration, that version is used in the result, else no version is used. If all argument values have the standalone declaration value &amp;ldquo;yes&amp;rdquo;, then that value is used in the result. If all argument values have a standalone declaration value and at least one is &amp;ldquo;no&amp;rdquo;, then that is used in the result. Else the result will have no standalone declaration. If the result is determined to require a standalone declaration but no version declaration, a version declaration with version 1.0 will be used because XML requires an XML declaration to contain a version declaration. Encoding declarations are ignored and removed in all cases.</source>
          <target state="translated">XML宣言がある場合は、次のように結合されます。すべての引数値に同じXMLバージョン宣言がある場合、そのバージョンが結果で使用されます。それ以外の場合、バージョンは使用されません。すべての引数値にスタンドアロン宣言値「yes」がある場合、その値が結果で使用されます。すべての引数値にスタンドアロンの宣言値があり、少なくとも1つが「いいえ」の場合、その値が結果で使用されます。それ以外の場合、結果にはスタンドアロン宣言はありません。結果がスタンドアロン宣言を必要とするがバージョン宣言を必要としないと判断された場合、XMLはバージョン宣言を含むためにXML宣言を必要とするため、バージョン1.0のバージョン宣言が使用されます。エンコーディング宣言は無視され、すべてのケースで削除されます。</target>
        </trans-unit>
        <trans-unit id="93db77a518a3a65df06b8910ae3df05493323aa8" translate="yes" xml:space="preserve">
          <source>XML entity</source>
          <target state="translated">エックスエムエルじったい</target>
        </trans-unit>
        <trans-unit id="41d948a6e01de6c3d4845c4fb6a9cd77bb4a345f" translate="yes" xml:space="preserve">
          <source>XML format is left as an exercise for the reader.</source>
          <target state="translated">XML形式は読者のための演習として残しています。</target>
        </trans-unit>
        <trans-unit id="c648229e46576f92e57966e5bb6a169947ab07af" translate="yes" xml:space="preserve">
          <source>XML tag</source>
          <target state="translated">エックスエムエルタグ</target>
        </trans-unit>
        <trans-unit id="b7b6740d5d3d1f4067adb9c002cd0cc814ec4855" translate="yes" xml:space="preserve">
          <source>XML: IS DOCUMENT</source>
          <target state="translated">XMLを使用しています。は文書です。</target>
        </trans-unit>
        <trans-unit id="863fe78f50c66a6f7d93b18bf787a5d0aa670b5c" translate="yes" xml:space="preserve">
          <source>XML: IS NOT DOCUMENT</source>
          <target state="translated">XMLを使用しています。は文書ではありません。</target>
        </trans-unit>
        <trans-unit id="708b35917f64aea4aecf43902f9f6861b388f0a3" translate="yes" xml:space="preserve">
          <source>XML: XMLEXISTS</source>
          <target state="translated">XMLを使用しています。XMLEXISTS</target>
        </trans-unit>
        <trans-unit id="7aea648b2b4e07c316d48e040a2dfe07aea119ed" translate="yes" xml:space="preserve">
          <source>XML: xml_is_well_formed</source>
          <target state="translated">XML:xml_is_well_formed</target>
        </trans-unit>
        <trans-unit id="3eca7373df1b8e0c5ed4c506c73dcc360d0c1000" translate="yes" xml:space="preserve">
          <source>XML: xmlagg</source>
          <target state="translated">XML:xmlagg</target>
        </trans-unit>
        <trans-unit id="31986b6f48c236780bb28b6f7a97cd2e7fe2fbbc" translate="yes" xml:space="preserve">
          <source>XML: xmlcomment</source>
          <target state="translated">XML:xmlコメント</target>
        </trans-unit>
        <trans-unit id="3336319324aa48adbaa76e0cbbf9934042dd41f7" translate="yes" xml:space="preserve">
          <source>XML: xmlconcat</source>
          <target state="translated">XML:xmlconcat</target>
        </trans-unit>
        <trans-unit id="c269b1860c6e177984dcd77f1f2f9180f500a7b1" translate="yes" xml:space="preserve">
          <source>XML: xmlelement</source>
          <target state="translated">XML:xmlelement</target>
        </trans-unit>
        <trans-unit id="f6f6cd60dad73c2efa2b22421846170fa537daf4" translate="yes" xml:space="preserve">
          <source>XML: xmlforest</source>
          <target state="translated">XML:xmlforest</target>
        </trans-unit>
        <trans-unit id="b4c3ab3b44e0a9d5e8cf4d618e5fb213a70446ae" translate="yes" xml:space="preserve">
          <source>XML: xmlpi</source>
          <target state="translated">XML:xmlpi</target>
        </trans-unit>
        <trans-unit id="2cb9abaad07f3be72c6b803b64719f6ad9373b8b" translate="yes" xml:space="preserve">
          <source>XML: xmlroot</source>
          <target state="translated">XML:xmlroot</target>
        </trans-unit>
        <trans-unit id="fe1c1afeea56eb4d61a6d5854b178d21b29bd194" translate="yes" xml:space="preserve">
          <source>XML: xmltable</source>
          <target state="translated">XML:xmltable</target>
        </trans-unit>
        <trans-unit id="943bcc21921946abacf747784b147601338c43bb" translate="yes" xml:space="preserve">
          <source>XML: xpath</source>
          <target state="translated">XML:xpath</target>
        </trans-unit>
        <trans-unit id="112eb0200c63c2f0de87632cdeab3a1c8a706831" translate="yes" xml:space="preserve">
          <source>XML: xpath_exists</source>
          <target state="translated">XML:xpath_exists</target>
        </trans-unit>
        <trans-unit id="a417f6430ccc4b644617c160b0d4f1b2c80cd5e2" translate="yes" xml:space="preserve">
          <source>XPath 1.0 blurs the distinction between &lt;em&gt;value comparisons&lt;/em&gt; and &lt;em&gt;general comparisons&lt;/em&gt; as XQuery/XPath define them. Both &lt;code&gt;sale/@hatsize = 7&lt;/code&gt; and &lt;code&gt;sale/@customer = &quot;alice&quot;&lt;/code&gt; are existentially quantified comparisons, true if there is any &lt;code&gt;sale&lt;/code&gt; with the given value for the attribute, but &lt;code&gt;sale/@taxable = false()&lt;/code&gt; is a value comparison to the &lt;em&gt;effective boolean value&lt;/em&gt; of a whole node-set. It is true only if no &lt;code&gt;sale&lt;/code&gt; has a &lt;code&gt;taxable&lt;/code&gt; attribute at all.</source>
          <target state="translated">XPath 1.0は、XQuery / XPathで定義される&lt;em&gt;ため&lt;/em&gt;、&lt;em&gt;値の比較&lt;/em&gt;と&lt;em&gt;一般的な比較&lt;/em&gt;の違いを曖昧にします。 &lt;code&gt;sale/@hatsize = 7&lt;/code&gt; と &lt;code&gt;sale/@customer = &quot;alice&quot;&lt;/code&gt; はどちらも実存的に定量化された比較であり、属性に指定 &lt;code&gt;sale&lt;/code&gt; れた値を持つ販売がある場合はtrueですが、 &lt;code&gt;sale/@taxable = false()&lt;/code&gt; はノードセット全体の&lt;em&gt;有効なブール値&lt;/em&gt;。これは、 &lt;code&gt;taxable&lt;/code&gt; 属性を持つ &lt;code&gt;sale&lt;/code&gt; がまったくない場合にのみ当てはまります。</target>
        </trans-unit>
        <trans-unit id="f37617c0d5dc43deba6ebd523a1e7daa408818b2" translate="yes" xml:space="preserve">
          <source>XPath 1.0 does not specify an order for nodes in a node-set, so code that relies on a particular order of the results will be implementation-dependent. Details can be found in &lt;a href=&quot;xml-limits-conformance#XML-XPATH-1-SPECIFICS&quot;&gt;Section D.3.1.2&lt;/a&gt;.</source>
          <target state="translated">XPath 1.0はノードセット内のノードの順序を指定しないため、結果の特定の順序に依存するコードは実装に依存します。詳細は、&lt;a href=&quot;xml-limits-conformance#XML-XPATH-1-SPECIFICS&quot;&gt;D.3.1.2項を参照してください&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ccec9b819d48fea6e95ee65b1f2c2363e5212016" translate="yes" xml:space="preserve">
          <source>XPath 1.0 has no conditional operator. An XQuery/XPath expression such as &lt;code&gt;if ( hat ) then hat/@size else &quot;no hat&quot;&lt;/code&gt; has no XPath 1.0 equivalent.</source>
          <target state="translated">XPath 1.0には条件演算子はありません。 &lt;code&gt;if ( hat ) then hat/@size else &quot;no hat&quot;&lt;/code&gt; ようなXQuery / XPath式には、「帽子なし」には同等のXPath 1.0がありません。</target>
        </trans-unit>
        <trans-unit id="575a5727a0aaf2dc929963572ab31f3a07d3b31b" translate="yes" xml:space="preserve">
          <source>XPath 1.0 has no ordering comparison operator for strings. Both &lt;code&gt;&quot;cat&quot; &amp;lt; &quot;dog&quot;&lt;/code&gt; and &lt;code&gt;&quot;cat&quot; &amp;gt; &quot;dog&quot;&lt;/code&gt; are false, because each is a numeric comparison of two &lt;code&gt;NaN&lt;/code&gt;s. In contrast, &lt;code&gt;=&lt;/code&gt; and &lt;code&gt;!=&lt;/code&gt; do compare the strings as strings.</source>
          <target state="translated">XPath 1.0には、文字列の順序付け比較演算子はありません。 &lt;code&gt;&quot;cat&quot; &amp;lt; &quot;dog&quot;&lt;/code&gt; および &lt;code&gt;&quot;cat&quot; &amp;gt; &quot;dog&quot;&lt;/code&gt; はどちらもfalseです。これは、それぞれが2つの &lt;code&gt;NaN&lt;/code&gt; の数値比較であるためです。対照的に、 &lt;code&gt;=&lt;/code&gt; と &lt;code&gt;!=&lt;/code&gt; は文字列を文字列として比較します。</target>
        </trans-unit>
        <trans-unit id="8c4149ee47a54aa2c037b2786d8549ef1627ad8e" translate="yes" xml:space="preserve">
          <source>XQuery allows declaration and use of local functions.</source>
          <target state="translated">XQueryでは、ローカル関数の宣言と使用が可能です。</target>
        </trans-unit>
        <trans-unit id="818970bcffceb4be8cc185fddd03719babd24f42" translate="yes" xml:space="preserve">
          <source>XQuery character class elements using &lt;code&gt;\p{UnicodeProperty}&lt;/code&gt; or the inverse &lt;code&gt;\P{UnicodeProperty}&lt;/code&gt; are not supported.</source>
          <target state="translated">&lt;code&gt;\p{UnicodeProperty}&lt;/code&gt; またはその逆の &lt;code&gt;\P{UnicodeProperty}&lt;/code&gt; を使用するXQuery文字クラス要素はサポートされていません。</target>
        </trans-unit>
        <trans-unit id="6f9675f91b1bee552c1436f5af897518b9d66036" translate="yes" xml:space="preserve">
          <source>XQuery character class shorthands &lt;code&gt;\c&lt;/code&gt;, &lt;code&gt;\C&lt;/code&gt;, &lt;code&gt;\i&lt;/code&gt;, and &lt;code&gt;\I&lt;/code&gt; are not supported.</source>
          <target state="translated">XQuery文字クラスの省略形 &lt;code&gt;\c&lt;/code&gt; 、 &lt;code&gt;\C&lt;/code&gt; 、 &lt;code&gt;\i&lt;/code&gt; 、および &lt;code&gt;\I&lt;/code&gt; はサポートされていません。</target>
        </trans-unit>
        <trans-unit id="e05d40877e991191e09256daf83989a5f47e5557" translate="yes" xml:space="preserve">
          <source>XQuery character class subtraction is not supported. An example of this feature is using the following to match only English consonants: &lt;code&gt;[a-z-[aeiou]]&lt;/code&gt;.</source>
          <target state="translated">XQuery文字クラスの減算はサポートされていません。この機能の例として、英語の子音のみを照合するために &lt;code&gt;[a-z-[aeiou]]&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="d7ba7fb2ffaaf928a3568f9854442e7071379dc9" translate="yes" xml:space="preserve">
          <source>XQuery does not have lookahead or lookbehind constraints, nor any of the constraint escapes described in &lt;a href=&quot;functions-matching#POSIX-CONSTRAINT-ESCAPES-TABLE&quot;&gt;Table 9.21&lt;/a&gt;.</source>
          <target state="translated">XQueryには、先読みまたは後読み制約がなく、&lt;a href=&quot;functions-matching#POSIX-CONSTRAINT-ESCAPES-TABLE&quot;&gt;表9.21で&lt;/a&gt;説明されている制約エスケープもありません。</target>
        </trans-unit>
        <trans-unit id="fb9c8b3c7792b9cf1dc2ef58684f3e70a06da1d2" translate="yes" xml:space="preserve">
          <source>XQuery does not have lookahead or lookbehind constraints, nor any of the constraint escapes described in &lt;a href=&quot;functions-matching#POSIX-CONSTRAINT-ESCAPES-TABLE&quot;&gt;Table 9.22&lt;/a&gt;.</source>
          <target state="translated">XQueryには、先読み制約または後読み制約はなく、&lt;a href=&quot;functions-matching#POSIX-CONSTRAINT-ESCAPES-TABLE&quot;&gt;表9.22で&lt;/a&gt;説明されている制約エスケープもありません。</target>
        </trans-unit>
        <trans-unit id="41577214ab7c5c54db475c958675a49fbb00b4a6" translate="yes" xml:space="preserve">
          <source>XQuery does not support the &lt;code&gt;[:name:]&lt;/code&gt; syntax for character classes within bracket expressions.</source>
          <target state="translated">XQueryは、ブラケット式内の文字クラスの &lt;code&gt;[:name:]&lt;/code&gt; 構文をサポートしていません。</target>
        </trans-unit>
        <trans-unit id="2e0c3c6ff5da1ba3d8311b799d1cf51c7385d7c2" translate="yes" xml:space="preserve">
          <source>XQuery expressions can construct and return new XML nodes, in addition to all possible XPath values. XPath can create and return values of the atomic types (numbers, strings, and so on) but can only return XML nodes that were already present in documents supplied as input to the expression.</source>
          <target state="translated">XQuery 式は、可能なすべての XPath 値に加えて、新しい XML ノードを構築して返すことができます。XPath は、アトミック型 (数値、文字列など)の値を作成して返すことができますが、式の入力として供給されたドキュメントに既に存在していた XML ノードのみを返すことができます。</target>
        </trans-unit>
        <trans-unit id="7d07dea26dd7592af4147bb1ae9d21c709ece2a7" translate="yes" xml:space="preserve">
          <source>XQuery has control constructs for iteration, sorting, and grouping.</source>
          <target state="translated">XQueryには、反復、ソート、およびグループ化のための制御構文があります。</target>
        </trans-unit>
        <trans-unit id="9add350a4eb532be8a2c9c9d393be8bd03cceb66" translate="yes" xml:space="preserve">
          <source>XQuery's &lt;code&gt;s&lt;/code&gt; (allow dot to match newline) and &lt;code&gt;m&lt;/code&gt; (allow &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;$&lt;/code&gt; to match at newlines) flags provide access to the same behaviors as POSIX's &lt;code&gt;n&lt;/code&gt;, &lt;code&gt;p&lt;/code&gt; and &lt;code&gt;w&lt;/code&gt; flags, but they do &lt;em&gt;not&lt;/em&gt; match the behavior of POSIX's &lt;code&gt;s&lt;/code&gt; and &lt;code&gt;m&lt;/code&gt; flags. Note in particular that dot-matches-newline is the default behavior in POSIX but not XQuery.</source>
          <target state="translated">XQueryの &lt;code&gt;s&lt;/code&gt; （ドットが改行に一致することを許可）および &lt;code&gt;m&lt;/code&gt; （ &lt;code&gt;^&lt;/code&gt; および &lt;code&gt;$&lt;/code&gt; が改行に一致することを許可する）フラグは、POSIXの &lt;code&gt;n&lt;/code&gt; 、 &lt;code&gt;p&lt;/code&gt; および &lt;code&gt;w&lt;/code&gt; フラグと同じ動作にアクセスできますが、POSIXの &lt;code&gt;s&lt;/code&gt; および &lt;code&gt;m&lt;/code&gt; フラグの動作に一致しませ&lt;em&gt;ん&lt;/em&gt;。特に、dot-matches-newlineはPOSIXのデフォルトの動作ですが、XQueryではありません。</target>
        </trans-unit>
        <trans-unit id="0fbdf61430816231b42e0b59499fabbec39b5ae3" translate="yes" xml:space="preserve">
          <source>XQuery's &lt;code&gt;x&lt;/code&gt; (ignore whitespace in pattern) flag is noticeably different from POSIX's expanded-mode flag. POSIX's &lt;code&gt;x&lt;/code&gt; flag also allows &lt;code&gt;#&lt;/code&gt; to begin a comment in the pattern, and POSIX will not ignore a whitespace character after a backslash.</source>
          <target state="translated">XQueryの &lt;code&gt;x&lt;/code&gt; （パターン内の空白を無視する）フラグは、POSIXの拡張モードフラグとは著しく異なります。POSIXの &lt;code&gt;x&lt;/code&gt; フラグを使用すると、 &lt;code&gt;#&lt;/code&gt; でパターン内のコメントを開始することもできます。POSIXは、バックスラッシュの後の空白文字を無視しません。</target>
        </trans-unit>
        <trans-unit id="23eb4d3f4155395a74e9d534f97ff4c1908f5aac" translate="yes" xml:space="preserve">
          <source>Y</source>
          <target state="translated">Y</target>
        </trans-unit>
        <trans-unit id="cb29757e458776404c0d0c4f5c75b0740d559b1c" translate="yes" xml:space="preserve">
          <source>Year and day of year: for example &lt;code&gt;to_date('2006-291', 'IYYY-IDDD')&lt;/code&gt; also returns &lt;code&gt;2006-10-19&lt;/code&gt;.</source>
          <target state="translated">年と日：たとえば、 &lt;code&gt;to_date('2006-291', 'IYYY-IDDD')&lt;/code&gt; も &lt;code&gt;2006-10-19&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="fc5a18c267810c3dc6c5d4fdd0b02c9e146fd0f1" translate="yes" xml:space="preserve">
          <source>Year, week number, and weekday: for example &lt;code&gt;to_date('2006-42-4', 'IYYY-IW-ID')&lt;/code&gt; returns the date &lt;code&gt;2006-10-19&lt;/code&gt;. If you omit the weekday it is assumed to be 1 (Monday).</source>
          <target state="translated">年、週番号、および曜日：たとえば、 &lt;code&gt;to_date('2006-42-4', 'IYYY-IW-ID')&lt;/code&gt; は、日付 &lt;code&gt;2006-10-19&lt;/code&gt; を返します。平日を省略すると、1（月曜日）と見なされます。</target>
        </trans-unit>
        <trans-unit id="7abdb2567a06fc713cd1d6b57e90f634441b367e" translate="yes" xml:space="preserve">
          <source>Year-Month Interval</source>
          <target state="translated">年月間隔</target>
        </trans-unit>
        <trans-unit id="96f997bcecb36502ed4b296a795f72aff9d6bfe7" translate="yes" xml:space="preserve">
          <source>Years</source>
          <target state="translated">Years</target>
        </trans-unit>
        <trans-unit id="3cfd5c7e576642a9c9f3bbe4db929041cea0177f" translate="yes" xml:space="preserve">
          <source>Years in the 1900s are in the second millennium. The third millennium started January 1, 2001.</source>
          <target state="translated">1900年代の年は第二千年紀。第三千年紀は2001年1月1日に始まりました。</target>
        </trans-unit>
        <trans-unit id="5397e0583f14f6c88de06b1ef28f460a1fb5b0ae" translate="yes" xml:space="preserve">
          <source>Yes</source>
          <target state="translated">Yes</target>
        </trans-unit>
        <trans-unit id="6dd15150afde3fb668c9c37b5570c9f350a42483" translate="yes" xml:space="preserve">
          <source>You can (and, for most purposes, probably should) increase the number of rows by using the &lt;code&gt;-s&lt;/code&gt; (scale factor) option. The &lt;code&gt;-F&lt;/code&gt; (fillfactor) option might also be used at this point.</source>
          <target state="translated">&lt;code&gt;-s&lt;/code&gt; （スケールファクター）オプションを使用すると、行の数を増やすことができます（ほとんどの場合、おそらくそうする必要があります）。 &lt;code&gt;-F&lt;/code&gt; （フィルファクタ）オプションもこの時点で使用される可能性があります。</target>
        </trans-unit>
        <trans-unit id="145c00d5953681c62f21c82b058caafeee2a8310" translate="yes" xml:space="preserve">
          <source>You can adapt this module to your needs by changing the source code. For example, you can use &lt;a href=&quot;https://sourceforge.net/projects/cracklib/&quot;&gt;CrackLib&lt;/a&gt; to check passwords &amp;mdash; this only requires uncommenting two lines in the &lt;code&gt;Makefile&lt;/code&gt; and rebuilding the module. (We cannot include CrackLib by default for license reasons.) Without CrackLib, the module enforces a few simple rules for password strength, which you can modify or extend as you see fit.</source>
          <target state="translated">ソースコードを変更することにより、このモジュールをニーズに適合させることができます。たとえば、&lt;a href=&quot;https://sourceforge.net/projects/cracklib/&quot;&gt;CrackLib&lt;/a&gt;を使用してパスワードをチェックできます&amp;mdash;これには、 &lt;code&gt;Makefile&lt;/code&gt; の 2行のコメントを外してモジュールを再構築するだけです。（ライセンス上の理由から、デフォルトでCrackLibを含めることはできません。）CrackLibがない場合、モジュールはパスワードの強度に関するいくつかの単純なルールを適用します。必要に応じて変更または拡張できます。</target>
        </trans-unit>
        <trans-unit id="28dae3ce662983a3720ca411f5e625f764893bf1" translate="yes" xml:space="preserve">
          <source>You can add whitespace before a left brace or after a right brace. You can also add whitespace before or after any individual item string. In all of these cases the whitespace will be ignored. However, whitespace within double-quoted elements, or surrounded on both sides by non-whitespace characters of an element, is not ignored.</source>
          <target state="translated">左中括弧の前や右中括弧の後に空白を追加することができます。また、個々の項目文字列の前後に空白を追加することもできます。これらすべての場合、空白は無視されます。し か し 、 二重引用符で囲まれた要素内の空白や、 要素の両側で空白以外のキ ャ ラ ク タ で囲まれた空白は無視 さ れません。</target>
        </trans-unit>
        <trans-unit id="569893ff6c39724a565a145b8a3ad3a0b9606463" translate="yes" xml:space="preserve">
          <source>You can adjust the ordering of a B-tree index by including the options &lt;code&gt;ASC&lt;/code&gt;, &lt;code&gt;DESC&lt;/code&gt;, &lt;code&gt;NULLS FIRST&lt;/code&gt;, and/or &lt;code&gt;NULLS LAST&lt;/code&gt; when creating the index; for example:</source>
          <target state="translated">インデックスの作成時にオプション &lt;code&gt;ASC&lt;/code&gt; 、 &lt;code&gt;DESC&lt;/code&gt; 、 &lt;code&gt;NULLS FIRST&lt;/code&gt; 、または &lt;code&gt;NULLS LAST&lt;/code&gt; を含めることにより、Bツリーインデックスの順序を調整できます。例えば：</target>
        </trans-unit>
        <trans-unit id="4b7d9d02889a217be36bf8f71750c721f9d62b3a" translate="yes" xml:space="preserve">
          <source>You can also control the order in which rows are processed by window functions using &lt;code&gt;ORDER BY&lt;/code&gt; within &lt;code&gt;OVER&lt;/code&gt;. (The window &lt;code&gt;ORDER BY&lt;/code&gt; does not even have to match the order in which the rows are output.) Here is an example:</source>
          <target state="translated">&lt;code&gt;OVER&lt;/code&gt; 内で &lt;code&gt;ORDER BY&lt;/code&gt; を使用して、ウィンドウ関数によって行が処理される順序を制御することもできます。（ウィンドウ &lt;code&gt;ORDER BY&lt;/code&gt; は、行が出力される順序と一致する必要さえありません。）以下に例を示します。</target>
        </trans-unit>
        <trans-unit id="d8031e0a82c5477e58a31c17656bff548035b193" translate="yes" xml:space="preserve">
          <source>You can also create databases with other names. PostgreSQL allows you to create any number of databases at a given site. Database names must have an alphabetic first character and are limited to 63 bytes in length. A convenient choice is to create a database with the same name as your current user name. Many tools assume that database name as the default, so it can save you some typing. To create that database, simply type:</source>
          <target state="translated">他の名前でデータベースを作成することもできます。PostgreSQLでは、任意のサイトに任意の数のデータベースを作成することができます。データベース名はアルファベットの最初の文字でなければならず、長さは63バイトに制限されています。便利な選択は、現在のユーザ名と同じ名前でデータベースを作成することです。多くのツールはこのデータベース名をデフォルトとしているので、入力の手間が省けます。そのデータベースを作成するには、単に次のように入力します。</target>
        </trans-unit>
        <trans-unit id="2855332ddeec7909c633615734e0f09916910215" translate="yes" xml:space="preserve">
          <source>You can also define constraints on the column at the same time, using the usual syntax:</source>
          <target state="translated">また、通常の構文を使用して、列の制約を同時に定義することもできます。</target>
        </trans-unit>
        <trans-unit id="ee1e40e96d3d99c788ff89c86039beb4c7ae5ad3" translate="yes" xml:space="preserve">
          <source>You can also force the insertion of invalid numbers even when not in the weak mode, by appending the &lt;code&gt;!&lt;/code&gt; character at the end of the number.</source>
          <target state="translated">&lt;code&gt;!&lt;/code&gt; を追加することで、ウィークモードでない場合でも無効な数値を強制的に挿入することもできます。番号の終わりの文字。</target>
        </trans-unit>
        <trans-unit id="e92dd9f79aa93357545022991d035db8fa3c697a" translate="yes" xml:space="preserve">
          <source>You can also give the constraint a separate name. This clarifies error messages and allows you to refer to the constraint when you need to change it. The syntax is:</source>
          <target state="translated">制約に別の名前を付けることもできます。これにより、エラーメッセージが明確になり、制約を変更する必要がある場合に制約を参照できるようになります。構文は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="5c0e733bb8f77339cb0554d27f0faf1999d777b7" translate="yes" xml:space="preserve">
          <source>You can also nest filter expressions within each other:</source>
          <target state="translated">また、フィルタ式を互いに入れ子にすることもできます。</target>
        </trans-unit>
        <trans-unit id="540c7cc55f43958519f25aa973c9e5a2c6dcb66b" translate="yes" xml:space="preserve">
          <source>You can also search an array using the &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; operator, which checks whether the left operand overlaps with the right operand. For instance:</source>
          <target state="translated">&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 演算子を使用して配列を検索することもできます。これは、左のオペランドが右のオペランドとオーバーラップするかどうかをチェックします。例えば：</target>
        </trans-unit>
        <trans-unit id="7317ad78770ade20f7fc205d1692cc3871b32860" translate="yes" xml:space="preserve">
          <source>You can also search for specific values in an array using the &lt;code&gt;array_position&lt;/code&gt; and &lt;code&gt;array_positions&lt;/code&gt; functions. The former returns the subscript of the first occurrence of a value in an array; the latter returns an array with the subscripts of all occurrences of the value in the array. For example:</source>
          <target state="translated">また、使用して、配列内の特定の値を検索することができ &lt;code&gt;array_position&lt;/code&gt; と &lt;code&gt;array_positions&lt;/code&gt; 機能を。前者は、配列内の最初の値の添え字を返します。後者は、配列内の値のすべての出現の添え字を持つ配列を返します。例えば：</target>
        </trans-unit>
        <trans-unit id="72011efb5669336e4615ad697b69c64d57f8e812" translate="yes" xml:space="preserve">
          <source>You can also shorten the above command to:</source>
          <target state="translated">上記のコマンドを短くすることもできます。</target>
        </trans-unit>
        <trans-unit id="362c18912cf35df18fb18daa4743d6a04f75f78b" translate="yes" xml:space="preserve">
          <source>You can also write &lt;code&gt;all&lt;/code&gt; to match any IP address, &lt;code&gt;samehost&lt;/code&gt; to match any of the server's own IP addresses, or &lt;code&gt;samenet&lt;/code&gt; to match any address in any subnet that the server is directly connected to.</source>
          <target state="translated">&lt;code&gt;all&lt;/code&gt; を書き込んで任意のIPアドレスと &lt;code&gt;samehost&lt;/code&gt; たり、samehostを書き込んでサーバーの任意のIPアドレスと一致させたり、 &lt;code&gt;samenet&lt;/code&gt; を書き込んでサーバーが直接接続しているサブネット内の任意のアドレスと一致させたりすることもできます。</target>
        </trans-unit>
        <trans-unit id="81719f677a0ec0af21aab7f90315c40b111bfbd1" translate="yes" xml:space="preserve">
          <source>You can also write the table name with a trailing &lt;code&gt;*&lt;/code&gt; to explicitly specify that descendant tables are included:</source>
          <target state="translated">末尾に &lt;code&gt;*&lt;/code&gt; を付けてテーブル名を記述して、子孫テーブルが含まれることを明示的に指定することもできます。</target>
        </trans-unit>
        <trans-unit id="5703517ac040c492127e1fb49e5ced3da0debc99" translate="yes" xml:space="preserve">
          <source>You can ask for all fields of a composite value by writing &lt;code&gt;.*&lt;/code&gt;:</source>
          <target state="translated">あなたは書き込むことによって、複合値のすべてのフィールドを求めることができます &lt;code&gt;.*&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="3fc07d5e0044a9e8829c097c35614fb4ad2ee919" translate="yes" xml:space="preserve">
          <source>You can assign your own name for a foreign key constraint, in the usual way.</source>
          <target state="translated">通常の方法で、外部キー制約に自分の名前を割り当てることができます。</target>
        </trans-unit>
        <trans-unit id="78537f8a74bec7b625797355864a6e8b33eb27d6" translate="yes" xml:space="preserve">
          <source>You can assign your own name for a unique constraint, in the usual way:</source>
          <target state="translated">固有の制約には、通常の方法で自分の名前を割り当てることができます。</target>
        </trans-unit>
        <trans-unit id="2e4029bdb8227766d867d39118fde7beadbd5eab" translate="yes" xml:space="preserve">
          <source>You can avoid always having to write out a &lt;code&gt;FROM&lt;/code&gt; clause to define the output columns, by setting up a custom crosstab function that has the desired output row type wired into its definition. This is described in the next section. Another possibility is to embed the required &lt;code&gt;FROM&lt;/code&gt; clause in a view definition.</source>
          <target state="translated">必要な出力行タイプを定義に配線したカスタムクロス集計関数を設定することにより、出力列を定義するために常に &lt;code&gt;FROM&lt;/code&gt; 句を書き出す必要を回避できます。これについては、次のセクションで説明します。別の可能性は、必要な &lt;code&gt;FROM&lt;/code&gt; 句をビュー定義に埋め込むことです。</target>
        </trans-unit>
        <trans-unit id="91ab32b5c2f6769faecc52b84a69c2005aae2685" translate="yes" xml:space="preserve">
          <source>You can change default privileges only for objects that will be created by yourself or by roles that you are a member of. The privileges can be set globally (i.e., for all objects created in the current database), or just for objects created in specified schemas.</source>
          <target state="translated">デフォルトの権限は、自分自身または自分がメンバーであるロールによって作成されるオブジェクトに対してのみ変更することができます。権限は、グローバルに(つまり、現在のデータベースに作成されたすべてのオブジェクトに対して)設定することも、指定されたスキーマに作成されたオブジェクトに対してのみ設定することもできます。</target>
        </trans-unit>
        <trans-unit id="564b000e3befed57b182cb04e1dbb1e1574bf5b5" translate="yes" xml:space="preserve">
          <source>You can change default privileges only for objects that will be created by yourself or by roles that you are a member of. The privileges can be set globally (i.e., for all objects created in the current database), or just for objects created in specified schemas. Default privileges that are specified per-schema are added to whatever the global default privileges are for the particular object type.</source>
          <target state="translated">デフォルトの権限は、自分自身または自分がメンバーであるロールによって作成されるオブジェクトに対してのみ変更することができます。権限は、グローバルに(つまり、現在のデータベースに作成されたすべてのオブジェクトに対して)設定することも、指定されたスキーマに作成されたオブジェクトに対してのみ設定することもできます。スキーマごとに指定されたデフォルト権限は、特定のオブジェクトタイプのグローバルなデフォルト権限に追加されます。</target>
        </trans-unit>
        <trans-unit id="9ce7b82cbd1c40e5d5b3f5f38a6fd3d98a532714" translate="yes" xml:space="preserve">
          <source>You can combine these approaches by setting up logrotate to collect log files produced by PostgreSQL built-in logging collector. In this case, the logging collector defines the names and location of the log files, while logrotate periodically archives these files. When initiating log rotation, logrotate must ensure that the application sends further output to the new file. This is commonly done with a &lt;code&gt;postrotate&lt;/code&gt; script that sends a &lt;code&gt;SIGHUP&lt;/code&gt; signal to the application, which then reopens the log file. In PostgreSQL, you can run &lt;code&gt;pg_ctl&lt;/code&gt; with the &lt;code&gt;logrotate&lt;/code&gt; option instead. When the server receives this command, the server either switches to a new log file or reopens the existing file, depending on the logging configuration (see &lt;a href=&quot;runtime-config-logging#RUNTIME-CONFIG-LOGGING-WHERE&quot;&gt;Section 19.8.1&lt;/a&gt;).</source>
          <target state="translated">これらのアプローチを組み合わせるには、logrotateを設定して、PostgreSQLの組み込みロギングコレクターによって生成されたログファイルを収集します。この場合、ログ収集機能はログファイルの名前と場所を定義し、logrotateはこれらのファイルを定期的にアーカイブします。ログローテーションを開始する場合、logrotateは、アプリケーションが新しいファイルにさらに出力を送信するようにする必要があります。これは通常、アプリケーションに &lt;code&gt;SIGHUP&lt;/code&gt; シグナルを送信する &lt;code&gt;postrotate&lt;/code&gt; スクリプトで行われ、その後、ログファイルが再度開かれます。 PostgreSQLでは、代わりに &lt;code&gt;logrotate&lt;/code&gt; オプションを指定して &lt;code&gt;pg_ctl&lt;/code&gt; を実行できます。サーバーがこのコマンドを受信すると、サーバーは、ログの構成に応じて、新しいログファイルに切り替えるか、既存のファイルを再度開きます（を参照）。&lt;a href=&quot;runtime-config-logging#RUNTIME-CONFIG-LOGGING-WHERE&quot;&gt;セクション19.8.1&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="5b0f94e4408c19791436a634fd6c150fbb5fd164" translate="yes" xml:space="preserve">
          <source>You can construct an empty array, but since it's impossible to have an array with no type, you must explicitly cast your empty array to the desired type. For example:</source>
          <target state="translated">空の配列を作成することもできますが、型を持たない配列を持つことは不可能なので、空の配列を明示的に希望の型にキャストしなければなりません。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="769ef112866ecb5c170f43630a2adb624d294a3a" translate="yes" xml:space="preserve">
          <source>You can convert an epoch value back to a time stamp with &lt;code&gt;to_timestamp&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;to_timestamp&lt;/code&gt; でエポック値をタイムスタンプに戻すことができます：</target>
        </trans-unit>
        <trans-unit id="6ea1e38b69360026f2565a2133b9cc41f674fbe6" translate="yes" xml:space="preserve">
          <source>You can create a new table by specifying the table name, along with all column names and their types:</source>
          <target state="translated">すべてのカラム名とその種類とともにテーブル名を指定することで、新しいテーブルを作成することができます。</target>
        </trans-unit>
        <trans-unit id="2293b489a80bd69ba669dbf459fa76acfff7a213" translate="yes" xml:space="preserve">
          <source>You can create a replication slot like this:</source>
          <target state="translated">このようにレプリケーションスロットを作成することができます。</target>
        </trans-unit>
        <trans-unit id="e3025b62033e69c38fff841b12fa1dec6f73605a" translate="yes" xml:space="preserve">
          <source>You can create predefined functions to avoid having to write out the result column names and types in each query. See the examples in the previous section. The underlying C function for this form of &lt;code&gt;crosstab&lt;/code&gt; is named &lt;code&gt;crosstab_hash&lt;/code&gt;.</source>
          <target state="translated">事前定義された関数を作成して、各クエリで結果の列名と型を書き出す必要をなくすことができます。前のセクションの例を参照してください。この形式の &lt;code&gt;crosstab&lt;/code&gt; の基礎となるC関数の名前は &lt;code&gt;crosstab_hash&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="05fb579365a5f238d0a6df67c0b79ce59d0a29c6" translate="yes" xml:space="preserve">
          <source>You can create the illusion of an updatable view by defining &lt;code&gt;ON INSERT&lt;/code&gt;, &lt;code&gt;ON UPDATE&lt;/code&gt;, and &lt;code&gt;ON DELETE&lt;/code&gt; rules (or any subset of those that's sufficient for your purposes) to replace update actions on the view with appropriate updates on other tables. If you want to support &lt;code&gt;INSERT RETURNING&lt;/code&gt; and so on, then be sure to put a suitable &lt;code&gt;RETURNING&lt;/code&gt; clause into each of these rules.</source>
          <target state="translated">&lt;code&gt;ON INSERT&lt;/code&gt; 、 &lt;code&gt;ON UPDATE&lt;/code&gt; 、および &lt;code&gt;ON DELETE&lt;/code&gt; ルール（または目的に十分なサブセット）を定義して、ビューの更新アクションを他のテーブルの適切な更新に置き換えることにより、更新可能なビューの錯覚を作成できます。 &lt;code&gt;INSERT RETURNING&lt;/code&gt; などをサポートする場合は、これらの各ルールに適切な &lt;code&gt;RETURNING&lt;/code&gt; 句を必ず追加してください。</target>
        </trans-unit>
        <trans-unit id="a0fd26f2da3bc0e528eb70dd91043a00be53f7e3" translate="yes" xml:space="preserve">
          <source>You can define a cast as an &lt;em&gt;I/O conversion cast&lt;/em&gt; by using the &lt;code&gt;WITH INOUT&lt;/code&gt; syntax. An I/O conversion cast is performed by invoking the output function of the source data type, and passing the resulting string to the input function of the target data type. In many common cases, this feature avoids the need to write a separate cast function for conversion. An I/O conversion cast acts the same as a regular function-based cast; only the implementation is different.</source>
          <target state="translated">&lt;code&gt;WITH INOUT&lt;/code&gt; 構文を使用して、&lt;em&gt;キャストをI / O変換&lt;/em&gt;キャストとして定義できます。I / O変換キャストは、ソースデータ型の出力関数を呼び出し、結果の文字列をターゲットデータ型の入力関数に渡すことによって実行されます。多くの一般的なケースでは、この機能により、変換のために別個のキャスト関数を作成する必要がなくなります。I / O変換キャストは、通常の関数ベースのキャストと同じように機能します。実装のみが異なります。</target>
        </trans-unit>
        <trans-unit id="986b5339acb3c76e9d88ad629ad134c8af474edf" translate="yes" xml:space="preserve">
          <source>You can display tables in different ways by using the &lt;code&gt;\pset&lt;/code&gt; command:</source>
          <target state="translated">&lt;code&gt;\pset&lt;/code&gt; コマンドを使用すると、さまざまな方法でテーブルを表示できます。</target>
        </trans-unit>
        <trans-unit id="16683852e12279f72c19abb8cc240108de7e38a2" translate="yes" xml:space="preserve">
          <source>You can do the same thing more verbosely with an explicitly named composite type:</source>
          <target state="translated">明示的に名前を付けた複合型を使えば、より冗長に同じことができます。</target>
        </trans-unit>
        <trans-unit id="647bf3e05906b80225fe1b4782288902652983a3" translate="yes" xml:space="preserve">
          <source>You can easily display index sizes, too:</source>
          <target state="translated">インデックスサイズも簡単に表示できます。</target>
        </trans-unit>
        <trans-unit id="a376faf67a062024c4f071a8c440875731b4314a" translate="yes" xml:space="preserve">
          <source>You can enter this into &lt;code&gt;psql&lt;/code&gt; with the line breaks. &lt;code&gt;psql&lt;/code&gt; will recognize that the command is not terminated until the semicolon.</source>
          <target state="translated">これを改行して &lt;code&gt;psql&lt;/code&gt; に入力できます。 &lt;code&gt;psql&lt;/code&gt; は、コマンドがセミコロンになるまで終了しないことを認識します。</target>
        </trans-unit>
        <trans-unit id="b7e2b6740f842ed6fc3ff802c0860722cdf6db76" translate="yes" xml:space="preserve">
          <source>You can even omit the schema name, in which case the schema name will be the same as the user name. See &lt;a href=&quot;ddl-schemas#DDL-SCHEMAS-PATTERNS&quot;&gt;Section 5.9.6&lt;/a&gt; for how this can be useful.</source>
          <target state="translated">スキーマ名を省略することもできます。その場合、スキーマ名はユーザー名と同じになります。これがどのように役立つかについては、&lt;a href=&quot;ddl-schemas#DDL-SCHEMAS-PATTERNS&quot;&gt;セクション5.9.6&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="cc36ec902ca8c0ca398f503d160c7bcb9cae5a08" translate="yes" xml:space="preserve">
          <source>You can grant membership to other group roles, too (since there isn't really any distinction between group roles and non-group roles). The database will not let you set up circular membership loops. Also, it is not permitted to grant membership in a role to &lt;code&gt;PUBLIC&lt;/code&gt;.</source>
          <target state="translated">他のグループの役割にメンバーシップを付与することもできます（グループの役割と非グループの役割の間に実際の違いはないため）。データベースでは、循環メンバーシップループを設定できません。また、ロールのメンバーシップを &lt;code&gt;PUBLIC&lt;/code&gt; に付与することもできません。</target>
        </trans-unit>
        <trans-unit id="1855de10627c59aa70817e07d54ec85b68d5f2a6" translate="yes" xml:space="preserve">
          <source>You can have any number of standby servers, but if you use streaming replication, make sure you set &lt;code&gt;max_wal_senders&lt;/code&gt; high enough in the primary to allow them to be connected simultaneously.</source>
          <target state="translated">スタンバイサーバーはいくつでも設定できますが、ストリーミングレプリケーションを使用する場合は、プライマリで &lt;code&gt;max_wal_senders&lt;/code&gt; を十分に高く設定して、同時に接続できるようにしてください。</target>
        </trans-unit>
        <trans-unit id="fd1cb07de1f7e656292c8ca30e0d8e6b56ad41dd" translate="yes" xml:space="preserve">
          <source>You can insert multiple rows in a single command:</source>
          <target state="translated">1つのコマンドで複数の行を挿入することができます。</target>
        </trans-unit>
        <trans-unit id="42ba202e5611e6787a856f8be8ec1439c95a1b90" translate="yes" xml:space="preserve">
          <source>You can list the columns in a different order if you wish or even omit some columns, e.g., if the precipitation is unknown:</source>
          <target state="translated">必要に応じて別の順序で列をリストアップしたり、降水量が不明な場合などに列を省略したりすることができます。</target>
        </trans-unit>
        <trans-unit id="3d6ecf73216b6b457189a453d966978eb4171c2e" translate="yes" xml:space="preserve">
          <source>You can monitor disk space in three ways: using the SQL functions listed in &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-DBSIZE&quot;&gt;Table 9.89&lt;/a&gt;, using the &lt;a href=&quot;https://www.postgresql.org/docs/12/oid2name.html&quot;&gt;oid2name&lt;/a&gt; module, or using manual inspection of the system catalogs. The SQL functions are the easiest to use and are generally recommended. The remainder of this section shows how to do it by inspection of the system catalogs.</source>
          <target state="translated">&lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-DBSIZE&quot;&gt;表9.89&lt;/a&gt;にリストされているSQL関数を使用する、&lt;a href=&quot;https://www.postgresql.org/docs/12/oid2name.html&quot;&gt;oid2name&lt;/a&gt;モジュールを使用する、またはシステムカタログを手動で検査するという3つの方法でディスク領域を監視できます。 SQL関数は最も使いやすく、一般的に推奨されています。このセクションの残りの部分では、システムカタログを調べてその方法を示します。</target>
        </trans-unit>
        <trans-unit id="fc43586ff2149aed2e36a6059af6a439ca36056f" translate="yes" xml:space="preserve">
          <source>You can monitor disk space in three ways: using the SQL functions listed in &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-DBSIZE&quot;&gt;Table 9.90&lt;/a&gt;, using the &lt;a href=&quot;https://www.postgresql.org/docs/13/oid2name.html&quot;&gt;oid2name&lt;/a&gt; module, or using manual inspection of the system catalogs. The SQL functions are the easiest to use and are generally recommended. The remainder of this section shows how to do it by inspection of the system catalogs.</source>
          <target state="translated">ディスク容量は、&lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-DBSIZE&quot;&gt;表9.90&lt;/a&gt;にリストされているSQL関数を使用する、&lt;a href=&quot;https://www.postgresql.org/docs/13/oid2name.html&quot;&gt;oid2name&lt;/a&gt;モジュールを使用する、またはシステムカタログを手動で検査するという3つの方法で監視できます。SQL関数は最も使いやすく、一般的に推奨されています。このセクションの残りの部分では、システムカタログを調べてそれを行う方法を示します。</target>
        </trans-unit>
        <trans-unit id="d41216c0546ef7a2b57fe5526f609434095e7579" translate="yes" xml:space="preserve">
          <source>You can reduce the width of the output by explicitly specifying which columns you want to see:</source>
          <target state="translated">見たい列を明示的に指定することで、出力の幅を小さくすることができます。</target>
        </trans-unit>
        <trans-unit id="8331a990fbd5bf29d20b7859a75677eec31adfb9" translate="yes" xml:space="preserve">
          <source>You can request that duplicate rows be removed from the result of a query:</source>
          <target state="translated">クエリの結果から重複した行を削除するように要求することができます。</target>
        </trans-unit>
        <trans-unit id="3fcea913f233f38e0ca5df494ac39fe2b0977a56" translate="yes" xml:space="preserve">
          <source>You can request that the results of a query be returned in sorted order:</source>
          <target state="translated">クエリの結果をソートされた順序で返すように要求することができます。</target>
        </trans-unit>
        <trans-unit id="7eb5aec5733f23b6d31556d97f7864bf4f3ef3fd" translate="yes" xml:space="preserve">
          <source>You can retrieve a list of WAL sender processes via the &lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-REPLICATION-VIEW&quot;&gt;&lt;code&gt;pg_stat_replication&lt;/code&gt;&lt;/a&gt; view. Large differences between &lt;code&gt;pg_current_wal_lsn&lt;/code&gt; and the view's &lt;code&gt;sent_lsn&lt;/code&gt; field might indicate that the master server is under heavy load, while differences between &lt;code&gt;sent_lsn&lt;/code&gt; and &lt;code&gt;pg_last_wal_receive_lsn&lt;/code&gt; on the standby might indicate network delay, or that the standby is under heavy load.</source>
          <target state="translated">&lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-REPLICATION-VIEW&quot;&gt; &lt;code&gt;pg_stat_replication&lt;/code&gt; &lt;/a&gt;ビューを介して、WAL送信者プロセスのリストを取得できます。 &lt;code&gt;pg_current_wal_lsn&lt;/code&gt; とビューの &lt;code&gt;sent_lsn&lt;/code&gt; フィールドの大きな違いは、マスターサーバーに大きな負荷がかかっていることを示している可能性があり、スタンバイの &lt;code&gt;sent_lsn&lt;/code&gt; と &lt;code&gt;pg_last_wal_receive_lsn&lt;/code&gt; の違いは、ネットワーク遅延またはスタンバイに大きな負荷がかかっていることを示している可能性があります。</target>
        </trans-unit>
        <trans-unit id="fa31e230282587f91ce67696a7ae247357fc3c92" translate="yes" xml:space="preserve">
          <source>You can retrieve a list of WAL sender processes via the &lt;a href=&quot;monitoring-stats#PG-STAT-REPLICATION-VIEW&quot;&gt;pg_stat_replication&lt;/a&gt; view. Large differences between &lt;code&gt;pg_current_wal_lsn&lt;/code&gt; and the view's &lt;code&gt;sent_lsn&lt;/code&gt; field might indicate that the master server is under heavy load, while differences between &lt;code&gt;sent_lsn&lt;/code&gt; and &lt;code&gt;pg_last_wal_receive_lsn&lt;/code&gt; on the standby might indicate network delay, or that the standby is under heavy load.</source>
          <target state="translated">&lt;a href=&quot;monitoring-stats#PG-STAT-REPLICATION-VIEW&quot;&gt;pg_stat_replication&lt;/a&gt;ビューを介してWAL送信者プロセスのリストを取得できます。 &lt;code&gt;pg_current_wal_lsn&lt;/code&gt; とビューの &lt;code&gt;sent_lsn&lt;/code&gt; フィールドの大きな違いは、マスターサーバーの負荷が高いことを示している可能性があります。一方、スタンバイの &lt;code&gt;sent_lsn&lt;/code&gt; と &lt;code&gt;pg_last_wal_receive_lsn&lt;/code&gt; の違いは、ネットワークの遅延を示しているか、スタンバイの負荷が高い可能性があります。</target>
        </trans-unit>
        <trans-unit id="8d913910be5bfeaa10ff530630e730b9ef488370" translate="yes" xml:space="preserve">
          <source>You can see all available cursors by querying the &lt;a href=&quot;view-pg-cursors&quot;&gt;&lt;code&gt;pg_cursors&lt;/code&gt;&lt;/a&gt; system view.</source>
          <target state="translated">&lt;a href=&quot;view-pg-cursors&quot;&gt; &lt;code&gt;pg_cursors&lt;/code&gt; &lt;/a&gt;システムビューをクエリすることにより、使用可能なすべてのカーソルを表示できます。</target>
        </trans-unit>
        <trans-unit id="3d1e44f9701af9c1191f1ae4aa31b23f502dc3b9" translate="yes" xml:space="preserve">
          <source>You can see all prepared statements available in the session by querying the &lt;a href=&quot;view-pg-prepared-statements&quot;&gt;&lt;code&gt;pg_prepared_statements&lt;/code&gt;&lt;/a&gt; system view.</source>
          <target state="translated">&lt;a href=&quot;view-pg-prepared-statements&quot;&gt; &lt;code&gt;pg_prepared_statements&lt;/code&gt; &lt;/a&gt;システムビューをクエリすることにより、セッションで使用可能なすべての準備済みステートメントを確認できます。</target>
        </trans-unit>
        <trans-unit id="a1851e47d03f25069a58e8ba84744ebf9f76c67c" translate="yes" xml:space="preserve">
          <source>You can specify a non-default encoding at database creation time, provided that the encoding is compatible with the selected locale:</source>
          <target state="translated">データベース作成時に、選択したロケールと互換性のあるエンコーディングであれば、デフォルト以外のエンコーディングを指定することができます。</target>
        </trans-unit>
        <trans-unit id="429c21ef7f32890bc18b9fd73f1ebb90743874ca" translate="yes" xml:space="preserve">
          <source>You can unlisten something you were not listening for; no warning or error will appear.</source>
          <target state="translated">聞いていなかったものを聞くことができ、警告やエラーは表示されません。</target>
        </trans-unit>
        <trans-unit id="0f0825c19fa74c86ea4fde39915a5f442a1301c8" translate="yes" xml:space="preserve">
          <source>You can update existing rows using the &lt;code&gt;UPDATE&lt;/code&gt; command. Suppose you discover the temperature readings are all off by 2 degrees after November 28. You can correct the data as follows:</source>
          <target state="translated">&lt;code&gt;UPDATE&lt;/code&gt; コマンドを使用して、既存の行を更新できます。11月28日以降、温度測定値がすべて2度ずれていることに気付いたとします。次のようにデータを修正できます。</target>
        </trans-unit>
        <trans-unit id="e9d9d610480d842b7b4dae95f084d8c480dea21a" translate="yes" xml:space="preserve">
          <source>You can update more than one column in an &lt;code&gt;UPDATE&lt;/code&gt; command by listing more than one assignment in the &lt;code&gt;SET&lt;/code&gt; clause. For example:</source>
          <target state="translated">&lt;code&gt;SET&lt;/code&gt; 句で複数の割り当てをリストすることにより、 &lt;code&gt;UPDATE&lt;/code&gt; コマンドで複数の列を更新できます。例えば：</target>
        </trans-unit>
        <trans-unit id="afbd81cf7abf6e1ee5aed73e857469d9b19d9be7" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;pg_restore -j&lt;/code&gt; to restore a dump in parallel. This will work for any archive of either the &quot;custom&quot; or the &quot;directory&quot; archive mode, whether or not it has been created with &lt;code&gt;pg_dump -j&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pg_restore -j&lt;/code&gt; を使用して、並行してダンプを復元できます。これは、 &lt;code&gt;pg_dump -j&lt;/code&gt; で作成されたかどうかに関係なく、「カスタム」または「ディレクトリ」アーカイブモードのアーカイブで機能します。</target>
        </trans-unit>
        <trans-unit id="e548ce622037cda7095c1bcbf3f92886d139cb4c" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;pg_walfile_name_offset&lt;/code&gt; to extract the corresponding write-ahead log file name and byte offset from a &lt;code&gt;pg_lsn&lt;/code&gt; value. For example:</source>
          <target state="translated">あなたは使用することができます &lt;code&gt;pg_walfile_name_offset&lt;/code&gt; をからのオフセットに対応する先行書き込みログファイル名とバイトを抽出するために &lt;code&gt;pg_lsn&lt;/code&gt; の値を。例えば：</target>
        </trans-unit>
        <trans-unit id="7b820c01225164f2d5b985f5de0dcbc0100e250a" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;pg_walfile_name_offset&lt;/code&gt; to extract the corresponding write-ahead log file name and byte offset from the results of any of the above functions. For example:</source>
          <target state="translated">&lt;code&gt;pg_walfile_name_offset&lt;/code&gt; を使用して、上記の関数の結果から対応する先行書き込みログファイル名とバイトオフセットを抽出できます。例えば：</target>
        </trans-unit>
        <trans-unit id="c69d101f435a1744fb1dd6c3be27758cb46e4777" translate="yes" xml:space="preserve">
          <source>You can use data-modifying statements (&lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, or &lt;code&gt;DELETE&lt;/code&gt;) in &lt;code&gt;WITH&lt;/code&gt;. This allows you to perform several different operations in the same query. An example is:</source>
          <target state="translated">&lt;code&gt;WITH&lt;/code&gt; でデータ変更ステートメント（ &lt;code&gt;INSERT&lt;/code&gt; 、 &lt;code&gt;UPDATE&lt;/code&gt; 、または &lt;code&gt;DELETE&lt;/code&gt; ）を使用できます。これにより、同じクエリでいくつかの異なる操作を実行できます。例は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="0ab93f9848617cd1c9b0e1e4c6fbe5e015dc7f2a" translate="yes" xml:space="preserve">
          <source>You can use several filter expressions in sequence, if required. For example, the following expression selects start times of all segments that contain locations with relevant coordinates and high heart rate values:</source>
          <target state="translated">必要に応じて、複数のフィルタ式を連続して使用することができます。例えば、以下の式は、関連する座標と高い心拍数値を持つ位置を含むすべてのセグメントの開始時刻を選択します。</target>
        </trans-unit>
        <trans-unit id="4aecc1927f70a57ed9583d45287b1db5300bd7af" translate="yes" xml:space="preserve">
          <source>You can use several filter expressions on the same nesting level, if required. For example, the following expression selects all segments that contain locations with relevant coordinates and high heart rate values:</source>
          <target state="translated">必要に応じて、同じネスティングレベルで複数のフィルタ式を使用することができます。例えば、以下の式は、関連する座標と心拍数の高い値を持つ場所を含むすべてのセグメントを選択します。</target>
        </trans-unit>
        <trans-unit id="cfeaa68d3d1e02bb6f35ba750e012709276d477e" translate="yes" xml:space="preserve">
          <source>You can use the &lt;a href=&quot;btree-gist&quot;&gt;&lt;code&gt;btree_gist&lt;/code&gt;&lt;/a&gt; extension to define exclusion constraints on plain scalar data types, which can then be combined with range exclusions for maximum flexibility. For example, after &lt;code&gt;btree_gist&lt;/code&gt; is installed, the following constraint will reject overlapping ranges only if the meeting room numbers are equal:</source>
          <target state="translated">&lt;a href=&quot;btree-gist&quot;&gt; &lt;code&gt;btree_gist&lt;/code&gt; &lt;/a&gt;拡張を使用して、プレーンスカラーデータ型に除外制約を定義できます。これを範囲の除外と組み合わせて最大の柔軟性を得ることができます。たとえば、 &lt;code&gt;btree_gist&lt;/code&gt; がインストールされた後、次の制約は、会議室の番号が等しい場合にのみ、重複する範囲を拒否します。</target>
        </trans-unit>
        <trans-unit id="002e817c446bf19265c623a41f235f06765b50f1" translate="yes" xml:space="preserve">
          <source>You can verify what the command will do using rsync's &lt;code&gt;--dry-run&lt;/code&gt; option. While rsync must be run on the primary for at least one standby, it is possible to run rsync on an upgraded standby to upgrade other standbys, as long as the upgraded standby has not been started.</source>
          <target state="translated">rsyncの &lt;code&gt;--dry-run&lt;/code&gt; オプションを使用して、コマンドの動作を確認できます。少なくとも1つのスタンバイのプライマリでrsyncを実行する必要がありますが、アップグレードされたスタンバイが起動されていない限り、アップグレードされたスタンバイでrsyncを実行して他のスタンバイをアップグレードすることができます。</target>
        </trans-unit>
        <trans-unit id="92d48e271b4c23101cd376b3231b8d00d43b6839" translate="yes" xml:space="preserve">
          <source>You can write expressions, not just simple column references, in the select list. For example, you can do:</source>
          <target state="translated">セレクトリストでは、単純な列参照だけでなく、式を書くことができます。例えば、次のようなことができます。</target>
        </trans-unit>
        <trans-unit id="0b204489972744de11c0eeded07bbc813914aafd" translate="yes" xml:space="preserve">
          <source>You can:</source>
          <target state="translated">あなたはできる</target>
        </trans-unit>
        <trans-unit id="de82188f9fe7e2d788196205280b0985f84081cc" translate="yes" xml:space="preserve">
          <source>You cannot drop the &lt;code&gt;NOT NULL&lt;/code&gt; constraint on a partition's column if the constraint is present in the parent table.</source>
          <target state="translated">制約が親テーブルに存在する場合、パーティションの列の &lt;code&gt;NOT NULL&lt;/code&gt; 制約は削除できません。</target>
        </trans-unit>
        <trans-unit id="093c2a9d5eef8843d884253372bdbca71ca3f136" translate="yes" xml:space="preserve">
          <source>You cannot execute the &lt;code&gt;DROP DATABASE&lt;/code&gt; command while connected to the victim database. You can, however, be connected to any other database, including the &lt;code&gt;template1&lt;/code&gt; database. &lt;code&gt;template1&lt;/code&gt; would be the only option for dropping the last user database of a given cluster.</source>
          <target state="translated">犠牲データベースに接続している間は、 &lt;code&gt;DROP DATABASE&lt;/code&gt; コマンドを実行できません。ただし、 &lt;code&gt;template1&lt;/code&gt; データベースを含む他のデータベースに接続できます。 &lt;code&gt;template1&lt;/code&gt; は、特定のクラスターの最後のユーザーデータベースを削除するための唯一のオプションです。</target>
        </trans-unit>
        <trans-unit id="7a936475d5b2fe8219655a01b86bcd035950ef3f" translate="yes" xml:space="preserve">
          <source>You could also have set up port forwarding as</source>
          <target state="translated">としてポートフォワーディングを設定することもできました。</target>
        </trans-unit>
        <trans-unit id="b8854264af301815bd4c143e497bc4039dd4ee05" translate="yes" xml:space="preserve">
          <source>You could also have set up the port forwarding as</source>
          <target state="translated">のようにポートフォワーディングを設定してもよかったのではないでしょうか。</target>
        </trans-unit>
        <trans-unit id="00192154b86c5479e232f9339dfec14280fa9591" translate="yes" xml:space="preserve">
          <source>You could also have used &lt;code&gt;COPY&lt;/code&gt; to load large amounts of data from flat-text files. This is usually faster because the &lt;code&gt;COPY&lt;/code&gt; command is optimized for this application while allowing less flexibility than &lt;code&gt;INSERT&lt;/code&gt;. An example would be:</source>
          <target state="translated">&lt;code&gt;COPY&lt;/code&gt; を使用して、フラットテキストファイルから大量のデータをロードすることもできます。 &lt;code&gt;COPY&lt;/code&gt; コマンドはこのアプリケーション用に最適化されている一方で、 &lt;code&gt;INSERT&lt;/code&gt; よりも柔軟性が低いため、これは通常高速です。例は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="db5bb918efb1956e14366be6e4e8492955095b0f" translate="yes" xml:space="preserve">
          <source>You do not need to constrain the join order completely in order to cut search time, because it's OK to use &lt;code&gt;JOIN&lt;/code&gt; operators within items of a plain &lt;code&gt;FROM&lt;/code&gt; list. For example, consider:</source>
          <target state="translated">プレーンな &lt;code&gt;FROM&lt;/code&gt; リストのアイテム内で &lt;code&gt;JOIN&lt;/code&gt; 演算子を使用しても問題ないため、検索時間を短縮するために結合順序を完全に制約する必要はありません。たとえば、次のことを考慮してください。</target>
        </trans-unit>
        <trans-unit id="cb9759ceb3a93faeeed42501a60a856539a7fb24" translate="yes" xml:space="preserve">
          <source>You do not want to use the third form when specifying a &lt;code&gt;DEFAULT&lt;/code&gt; clause while creating a table. The system will convert &lt;code&gt;now&lt;/code&gt; to a &lt;code&gt;timestamp&lt;/code&gt; as soon as the constant is parsed, so that when the default value is needed, the time of the table creation would be used! The first two forms will not be evaluated until the default value is used, because they are function calls. Thus they will give the desired behavior of defaulting to the time of row insertion.</source>
          <target state="translated">テーブルの作成中に &lt;code&gt;DEFAULT&lt;/code&gt; 句を指定する場合は、3番目の形式を使用しないでください。システムが変換されます &lt;code&gt;now&lt;/code&gt; まで &lt;code&gt;timestamp&lt;/code&gt; とすぐに定数が解析されると、そのデフォルト値が必要なときに、テーブル作成の時間が使用されることに！最初の2つの形式は関数呼び出しであるため、デフォルト値が使用されるまで評価されません。したがって、それらは行挿入時のデフォルトの望ましい動作を提供します。</target>
        </trans-unit>
        <trans-unit id="82ae0883f7a2deb13919a7b51525df4e84881170" translate="yes" xml:space="preserve">
          <source>You have altered a storage parameter (such as fillfactor) for an index, and wish to ensure that the change has taken full effect.</source>
          <target state="translated">インデックスのストレージ・パラメータ(フィルファクターなど)を変更したので、その変更が完全に反映されていることを確認したいと思います。</target>
        </trans-unit>
        <trans-unit id="9105126c4b98c9abf43cead14144e7c73642eea6" translate="yes" xml:space="preserve">
          <source>You have to adapt &lt;code&gt;compressed_data_type&lt;/code&gt; to the specific type you're converting to in order to compress your leaf nodes, of course.</source>
          <target state="translated">あなたは適応する必要があり &lt;code&gt;compressed_data_type&lt;/code&gt; をあなたはもちろん、あなたのリーフノードを圧縮するためにに変換している特定のタイプに。</target>
        </trans-unit>
        <trans-unit id="c6ec9a715c152149c664d288cf7e25e03ec9494f" translate="yes" xml:space="preserve">
          <source>You may decide to use multiple columns in the partition key for range partitioning, if desired. Of course, this will often result in a larger number of partitions, each of which is individually smaller. On the other hand, using fewer columns may lead to a coarser-grained partitioning criteria with smaller number of partitions. A query accessing the partitioned table will have to scan fewer partitions if the conditions involve some or all of these columns. For example, consider a table range partitioned using columns &lt;code&gt;lastname&lt;/code&gt; and &lt;code&gt;firstname&lt;/code&gt; (in that order) as the partition key.</source>
          <target state="translated">必要に応じて、範囲パーティション化のためにパーティションキーで複数の列を使用することもできます。もちろん、これによりパーティションの数が多くなり、それぞれが個別に小さくなります。一方、使用する列の数が少ないと、パーティション数が少なくなり、より粗いパーティション分割基準になる可能性があります。条件にこれらの列の一部またはすべてが含まれる場合、パーティションテーブルにアクセスするクエリは、より少ないパーティションをスキャンする必要があります。たとえば、列の &lt;code&gt;lastname&lt;/code&gt; &lt;code&gt;firstname&lt;/code&gt; とファーストネームをこの順序でパーティションキーとして使用してパーティション分割されたテーブル範囲について考えてみます。</target>
        </trans-unit>
        <trans-unit id="cf47ba3690a812065d027e7932a77588e377659a" translate="yes" xml:space="preserve">
          <source>You might also want to configure your kernel to lock System V shared memory into RAM and prevent it from being paged out to swap. This can be accomplished using the &lt;code&gt;sysctl&lt;/code&gt; setting &lt;code&gt;kern.ipc.shm_use_phys&lt;/code&gt;.</source>
          <target state="translated">また、System V共有メモリをRAMにロックし、スワップのためにページアウトされないようにカーネルを構成することもできます。これは、 &lt;code&gt;sysctl&lt;/code&gt; 設定 &lt;code&gt;kern.ipc.shm_use_phys&lt;/code&gt; を使用して実行できます。</target>
        </trans-unit>
        <trans-unit id="0a62a7a5cf401923b709acdb0497028fe1fd4d2f" translate="yes" xml:space="preserve">
          <source>You might be tempted to create a large set of non-overlapping partial indexes, for example</source>
          <target state="translated">重複しない部分インデックスの大規模なセットを作成したくなるかもしれません。</target>
        </trans-unit>
        <trans-unit id="118dd6812b30292a1fcd4d319831dc8ec3a9335e" translate="yes" xml:space="preserve">
          <source>You might instead use this approach to naming the files descriptively:</source>
          <target state="translated">代わりに、この方法を使ってファイルを記述的に命名することもできます。</target>
        </trans-unit>
        <trans-unit id="149e9ef120e49f8ae119951c604cd065ab893c33" translate="yes" xml:space="preserve">
          <source>You might prefer to remove the &lt;code&gt;sepgsql-regtest&lt;/code&gt; policy entirely:</source>
          <target state="translated">&lt;code&gt;sepgsql-regtest&lt;/code&gt; ポリシーを完全に削除することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="a34411202b4ded0e9449c6d67415d0bad4541f5b" translate="yes" xml:space="preserve">
          <source>You might reasonably ask why there is an &lt;code&gt;ELEMENT&lt;/code&gt; option, if the system makes the correct array type automatically. The only case where it's useful to use &lt;code&gt;ELEMENT&lt;/code&gt; is when you are making a fixed-length type that happens to be internally an array of a number of identical things, and you want to allow these things to be accessed directly by subscripting, in addition to whatever operations you plan to provide for the type as a whole. For example, type &lt;code&gt;point&lt;/code&gt; is represented as just two floating-point numbers, which can be accessed using &lt;code&gt;point[0]&lt;/code&gt; and &lt;code&gt;point[1]&lt;/code&gt;. Note that this facility only works for fixed-length types whose internal form is exactly a sequence of identical fixed-length fields. A subscriptable variable-length type must have the generalized internal representation used by &lt;code&gt;array_in&lt;/code&gt; and &lt;code&gt;array_out&lt;/code&gt;. For historical reasons (i.e., this is clearly wrong but it's far too late to change it), subscripting of fixed-length array types starts from zero, rather than from one as for variable-length arrays.</source>
          <target state="translated">システムが正しい配列タイプを自動的に作成する場合、 &lt;code&gt;ELEMENT&lt;/code&gt; オプションがある理由を合理的に尋ねる場合があります。 &lt;code&gt;ELEMENT&lt;/code&gt; を使用すると便利な唯一のケースは、たまたま内部で複数の同一のものの配列である固定長の型を作成していて、これらに加えて添え字で直接アクセスできるようにする場合です。タイプ全体に対して提供する予定の操作。たとえば、 &lt;code&gt;point&lt;/code&gt; タイプは2つの浮動小数点数として表され、 &lt;code&gt;point[0]&lt;/code&gt; および &lt;code&gt;point[1]&lt;/code&gt; を使用してアクセスできます。。この機能は、内部形式がまったく同じ固定長フィールドのシーケンスである固定長型に対してのみ機能することに注意してください。添え字可能な可変長型には、 &lt;code&gt;array_in&lt;/code&gt; および &lt;code&gt;array_out&lt;/code&gt; で使用される一般化された内部表現が必要です。歴史的な理由（つまり、これは明らかに間違っているが、変更するには遅すぎる）のため、固定長配列型の添え字付けは、可変長配列の場合の1ではなく、0から始まります。</target>
        </trans-unit>
        <trans-unit id="e76fa113e33e26d7d8bdc7061b1bdc78af7c35cf" translate="yes" xml:space="preserve">
          <source>You might want to reset &lt;code&gt;parallel_workers&lt;/code&gt; after setting it as part of tuning an index build. This avoids inadvertent changes to query plans, since &lt;code&gt;parallel_workers&lt;/code&gt; affects &lt;em&gt;all&lt;/em&gt; parallel table scans.</source>
          <target state="translated">インデックスビルドのチューニングの一部として設定 &lt;code&gt;parallel_workers&lt;/code&gt; 後、parallel_workersをリセットすることができます。これにより、 &lt;code&gt;parallel_workers&lt;/code&gt; が&lt;em&gt;すべての&lt;/em&gt;並列テーブルスキャンに影響を与えるため、クエリプランへの不注意な変更を回避できます。</target>
        </trans-unit>
        <trans-unit id="16c3ec0adfcebb8df4d8276a101b477163d7255e" translate="yes" xml:space="preserve">
          <source>You might wonder why bother providing all four options, when two options together with the possibility of backward scan would cover all the variants of &lt;code&gt;ORDER BY&lt;/code&gt;. In single-column indexes the options are indeed redundant, but in multicolumn indexes they can be useful. Consider a two-column index on &lt;code&gt;(x, y)&lt;/code&gt;: this can satisfy &lt;code&gt;ORDER BY x, y&lt;/code&gt; if we scan forward, or &lt;code&gt;ORDER BY x DESC, y DESC&lt;/code&gt; if we scan backward. But it might be that the application frequently needs to use &lt;code&gt;ORDER BY x ASC, y DESC&lt;/code&gt;. There is no way to get that ordering from a plain index, but it is possible if the index is defined as &lt;code&gt;(x ASC, y DESC)&lt;/code&gt; or &lt;code&gt;(x DESC, y ASC)&lt;/code&gt;.</source>
          <target state="translated">2つのオプションと逆方向スキャンの可能性が &lt;code&gt;ORDER BY&lt;/code&gt; のすべてのバリアントをカバーするのに、なぜ4つのオプションすべてを提供する必要があるのか​​疑問に思われるかもしれません。単一列のインデックスでは、オプションは確かに冗長ですが、複数列のインデックスでは便利です。 &lt;code&gt;(x, y)&lt;/code&gt; 2列のインデックスについて考えます。これは &lt;code&gt;ORDER BY x, y&lt;/code&gt; 順方向にスキャンする場合はORDER BY x、y、逆方向にスキャンする場合は &lt;code&gt;ORDER BY x DESC, y DESC&lt;/code&gt; を満たすことができます。ただし、アプリケーションで &lt;code&gt;ORDER BY x ASC, y DESC&lt;/code&gt; 頻繁に使用する必要がある場合もあります。プレーンインデックスからその順序を取得する方法はありませんが、インデックスが &lt;code&gt;(x ASC, y DESC)&lt;/code&gt; または &lt;code&gt;(x DESC, y ASC)&lt;/code&gt; として定義されている場合は可能です。</target>
        </trans-unit>
        <trans-unit id="a96b7a75456662c5aa3c61f0b2bf6c8181936405" translate="yes" xml:space="preserve">
          <source>You must be a superuser to use &lt;code&gt;ALTER OPERATOR FAMILY&lt;/code&gt;. (This restriction is made because an erroneous operator family definition could confuse or even crash the server.)</source>
          <target state="translated">&lt;code&gt;ALTER OPERATOR FAMILY&lt;/code&gt; を使用するには、スーパーユーザーである必要があります。（この制限は、誤ったオペレーターファミリー定義がサーバーを混乱させたり、場合によってはクラッシュさせる可能性があるためです。）</target>
        </trans-unit>
        <trans-unit id="f2c54ba09d5b62548914418dced24b83c29f8192" translate="yes" xml:space="preserve">
          <source>You must be a superuser to use &lt;code&gt;ALTER TEXT SEARCH PARSER&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ALTER TEXT SEARCH PARSER&lt;/code&gt; を使用するには、スーパーユーザーである必要があります。</target>
        </trans-unit>
        <trans-unit id="b1c6e4d091898d0c808adc78af3decbefdf7c390" translate="yes" xml:space="preserve">
          <source>You must be a superuser to use &lt;code&gt;ALTER TEXT SEARCH TEMPLATE&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ALTER TEXT SEARCH TEMPLATE&lt;/code&gt; を使用するには、スーパーユーザーである必要があります。</target>
        </trans-unit>
        <trans-unit id="4112b2d8f8d95b2e2b447d1ab817d0a272e11d27" translate="yes" xml:space="preserve">
          <source>You must be a superuser to use &lt;code&gt;CREATE TEXT SEARCH PARSER&lt;/code&gt;. (This restriction is made because an erroneous text search parser definition could confuse or even crash the server.)</source>
          <target state="translated">&lt;code&gt;CREATE TEXT SEARCH PARSER&lt;/code&gt; を使用するには、スーパーユーザーである必要があります。（この制限は、誤ったテキスト検索パーサー定義がサーバーを混乱させたり、場合によってはクラッシュさせる可能性があるためです。）</target>
        </trans-unit>
        <trans-unit id="6ab7f85ecb54195b79adfabb967e5f95ee6fb3b3" translate="yes" xml:space="preserve">
          <source>You must be a superuser to use &lt;code&gt;CREATE TEXT SEARCH TEMPLATE&lt;/code&gt;. This restriction is made because an erroneous text search template definition could confuse or even crash the server. The reason for separating templates from dictionaries is that a template encapsulates the &amp;ldquo;unsafe&amp;rdquo; aspects of defining a dictionary. The parameters that can be set when defining a dictionary are safe for unprivileged users to set, and so creating a dictionary need not be a privileged operation.</source>
          <target state="translated">&lt;code&gt;CREATE TEXT SEARCH TEMPLATE&lt;/code&gt; を使用するには、スーパーユーザーである必要があります。この制限が行われるのは、誤ったテキスト検索テンプレート定義がサーバーを混乱させたり、場合によってはクラッシュさせる可能性があるためです。テンプレートをディクショナリから分離する理由は、テンプレートがディクショナリ定義の「安全でない」側面をカプセル化するためです。辞書を定義するときに設定できるパラメーターは、権限のないユーザーが設定しても安全であるため、辞書の作成は権限のある操作である必要はありません。</target>
        </trans-unit>
        <trans-unit id="d6ba0fbc9ee76ec30e6a734cc139602ed5f74a38" translate="yes" xml:space="preserve">
          <source>You must be superuser to alter an event trigger.</source>
          <target state="translated">イベントトリガーを変更するには、スーパーユーザーである必要があります。</target>
        </trans-unit>
        <trans-unit id="d2778f188a2bae6cf3e02c68a508357eae34c9bc" translate="yes" xml:space="preserve">
          <source>You must be the owner of a table to create a statistics object reading it. Once created, however, the ownership of the statistics object is independent of the underlying table(s).</source>
          <target state="translated">読み取る統計オブジェクトを作成するには、テーブルの所有者でなければなりません。しかし、一度作成された統計オブジェクトの所有権は、基礎となるテーブルとは独立しています。</target>
        </trans-unit>
        <trans-unit id="b18eb66aae7b37aaff80a2a943d09edee67a5cd6" translate="yes" xml:space="preserve">
          <source>You must be the owner of a table to create or change policies for it.</source>
          <target state="translated">テーブルのポリシーを作成または変更するには、テーブルの所有者でなければなりません。</target>
        </trans-unit>
        <trans-unit id="dd98593a661bbd8265aa519e6846bcf6a1a65a93" translate="yes" xml:space="preserve">
          <source>You must be the owner of a table to create or change rules for it.</source>
          <target state="translated">テーブルのルールを作成または変更するには、テーブルの所有者でなければなりません。</target>
        </trans-unit>
        <trans-unit id="fb2285ad531d2e07d6d7c86c0203500d7139806c" translate="yes" xml:space="preserve">
          <source>You must be the owner of the configuration to use &lt;code&gt;ALTER TEXT SEARCH CONFIGURATION&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ALTER TEXT SEARCH CONFIGURATION&lt;/code&gt; を使用するには、構成の所有者である必要があります。</target>
        </trans-unit>
        <trans-unit id="90b9a22d759305d6fe1fa47e1f5ffd11756e94a9" translate="yes" xml:space="preserve">
          <source>You must be the owner of the dictionary to use &lt;code&gt;ALTER TEXT SEARCH DICTIONARY&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ALTER TEXT SEARCH DICTIONARY&lt;/code&gt; を使用するには、辞書の所有者である必要があります。</target>
        </trans-unit>
        <trans-unit id="1e259c4dd1968568dc3fb80e1b6efb5689d6bdb9" translate="yes" xml:space="preserve">
          <source>You must have &lt;code&gt;INSERT&lt;/code&gt; privilege on a table in order to insert into it. If &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; is present, &lt;code&gt;UPDATE&lt;/code&gt; privilege on the table is also required.</source>
          <target state="translated">テーブルに挿入するには、テーブルに対する &lt;code&gt;INSERT&lt;/code&gt; 特権が必要です。 &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; が存在する場合は、テーブルに対する &lt;code&gt;UPDATE&lt;/code&gt; 特権も必要です。</target>
        </trans-unit>
        <trans-unit id="bb31803ee937f757ae783b41d67981c9d86f3e9e" translate="yes" xml:space="preserve">
          <source>You must have &lt;code&gt;SELECT&lt;/code&gt; privilege on each column used in a &lt;code&gt;SELECT&lt;/code&gt; command. The use of &lt;code&gt;FOR NO KEY UPDATE&lt;/code&gt;, &lt;code&gt;FOR UPDATE&lt;/code&gt;, &lt;code&gt;FOR SHARE&lt;/code&gt; or &lt;code&gt;FOR KEY SHARE&lt;/code&gt; requires &lt;code&gt;UPDATE&lt;/code&gt; privilege as well (for at least one column of each table so selected).</source>
          <target state="translated">&lt;code&gt;SELECT&lt;/code&gt; コマンドで使用される各列に対する &lt;code&gt;SELECT&lt;/code&gt; 特権が必要です。使用 &lt;code&gt;FOR NO KEY UPDATE&lt;/code&gt; 、 &lt;code&gt;FOR UPDATE&lt;/code&gt; 、 &lt;code&gt;FOR SHARE&lt;/code&gt; または &lt;code&gt;FOR KEY SHARE&lt;/code&gt; が必要 &lt;code&gt;UPDATE&lt;/code&gt; の（そのように選択された各テーブルの少なくとも一つの列のため）ならびに特権。</target>
        </trans-unit>
        <trans-unit id="d02911fbcb07608d5d71771e387bdf240b881b98" translate="yes" xml:space="preserve">
          <source>You must have select privilege on the table whose values are read by &lt;code&gt;COPY TO&lt;/code&gt;, and insert privilege on the table into which values are inserted by &lt;code&gt;COPY FROM&lt;/code&gt;. It is sufficient to have column privileges on the column(s) listed in the command.</source>
          <target state="translated">&lt;code&gt;COPY TO&lt;/code&gt; によって値が読み取られる表に対する選択権限、および &lt;code&gt;COPY FROM&lt;/code&gt; によって値が挿入される表に対する挿入権限が必要です。コマンドにリストされている列に対する列特権があれば十分です。</target>
        </trans-unit>
        <trans-unit id="f7e79121fed35518353fce9ebea22091560488e8" translate="yes" xml:space="preserve">
          <source>You must have the &lt;code&gt;DELETE&lt;/code&gt; privilege on the table to delete from it, as well as the &lt;code&gt;SELECT&lt;/code&gt; privilege for any table in the &lt;code&gt;USING&lt;/code&gt; clause or whose values are read in the &lt;code&gt;condition&lt;/code&gt;.</source>
          <target state="translated">あなたは持っている必要があります &lt;code&gt;DELETE&lt;/code&gt; それから削除するには、テーブル上の特権と、 &lt;code&gt;SELECT&lt;/code&gt; で任意のテーブルの特権を &lt;code&gt;USING&lt;/code&gt; か、その値が読み込まれる句 &lt;code&gt;condition&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4a1c02ef145014df727c0bbfa9c3ff89cf785dd1" translate="yes" xml:space="preserve">
          <source>You must have the &lt;code&gt;TRUNCATE&lt;/code&gt; privilege on a table to truncate it.</source>
          <target state="translated">テーブルをトランケートするには、テーブル &lt;code&gt;TRUNCATE&lt;/code&gt; 権限が必要です。</target>
        </trans-unit>
        <trans-unit id="77a7a29185db04a6a9d2e4452098a88fd3c7b7ea" translate="yes" xml:space="preserve">
          <source>You must have the &lt;code&gt;UPDATE&lt;/code&gt; privilege on the table, or at least on the column(s) that are listed to be updated. You must also have the &lt;code&gt;SELECT&lt;/code&gt; privilege on any column whose values are read in the &lt;code&gt;expressions&lt;/code&gt; or &lt;code&gt;condition&lt;/code&gt;.</source>
          <target state="translated">テーブル、または少なくとも更新対象としてリストされている列に対する &lt;code&gt;UPDATE&lt;/code&gt; 特権が必要です。 &lt;code&gt;expressions&lt;/code&gt; または &lt;code&gt;condition&lt;/code&gt; で値が読み取られる列に対する &lt;code&gt;SELECT&lt;/code&gt; 特権も必要です。</target>
        </trans-unit>
        <trans-unit id="d6be4ee2e09272568e1f74da88776799e39f34a3" translate="yes" xml:space="preserve">
          <source>You must own the aggregate function to use &lt;code&gt;ALTER AGGREGATE&lt;/code&gt;. To change the schema of an aggregate function, you must also have &lt;code&gt;CREATE&lt;/code&gt; privilege on the new schema. To alter the owner, you must also be a direct or indirect member of the new owning role, and that role must have &lt;code&gt;CREATE&lt;/code&gt; privilege on the aggregate function's schema. (These restrictions enforce that altering the owner doesn't do anything you couldn't do by dropping and recreating the aggregate function. However, a superuser can alter ownership of any aggregate function anyway.)</source>
          <target state="translated">&lt;code&gt;ALTER AGGREGATE&lt;/code&gt; を使用するには、集約関数を所有している必要があります。集約関数のスキーマを変更するには、新しいスキーマに対する &lt;code&gt;CREATE&lt;/code&gt; 特権も必要です。所有者を変更するには、新しい所有者の役割の直接または間接のメンバーである必要もあり、その役割には集約関数のスキーマに対する &lt;code&gt;CREATE&lt;/code&gt; 特権が必要です。 （これらの制限により、所有者を変更しても、集計関数を削除して再作成することで実行できなかったことが実行されないことが強制されます。ただし、スーパーユーザーはとにかく集計関数の所有権を変更できます。）</target>
        </trans-unit>
        <trans-unit id="a5408e4e6a9f4b7999bf20809f4af3f8dff4cea5" translate="yes" xml:space="preserve">
          <source>You must own the collation to use &lt;code&gt;ALTER COLLATION&lt;/code&gt;. To alter the owner, you must also be a direct or indirect member of the new owning role, and that role must have &lt;code&gt;CREATE&lt;/code&gt; privilege on the collation's schema. (These restrictions enforce that altering the owner doesn't do anything you couldn't do by dropping and recreating the collation. However, a superuser can alter ownership of any collation anyway.)</source>
          <target state="translated">&lt;code&gt;ALTER COLLATION&lt;/code&gt; を使用するには、照合を所有している必要があります。所有者を変更するには、新しい所有ロールの直接または間接のメンバーである必要もあり、そのロールには照合順序のスキーマに対する &lt;code&gt;CREATE&lt;/code&gt; 特権が必要です。 （これらの制限により、所有者を変更しても、照合順序を削除して再作成することで実行できなかったことが実行されないことが強制されます。ただし、スーパーユーザーは任意の照合順序の所有権を変更できます。）</target>
        </trans-unit>
        <trans-unit id="d3b0175f69dcf313a89dcb0b18357a030f315c24" translate="yes" xml:space="preserve">
          <source>You must own the conversion to use &lt;code&gt;ALTER CONVERSION&lt;/code&gt;. To alter the owner, you must also be a direct or indirect member of the new owning role, and that role must have &lt;code&gt;CREATE&lt;/code&gt; privilege on the conversion's schema. (These restrictions enforce that altering the owner doesn't do anything you couldn't do by dropping and recreating the conversion. However, a superuser can alter ownership of any conversion anyway.)</source>
          <target state="translated">&lt;code&gt;ALTER CONVERSION&lt;/code&gt; を使用するには、変換を所有している必要があります。所有者を変更するには、新しい所有ロールの直接または間接のメンバーである必要もあり、そのロールには変換のスキーマに対する &lt;code&gt;CREATE&lt;/code&gt; 特権が必要です。 （これらの制限により、所有者を変更しても、変換を削除して再作成することで実行できなかったことが実行されなくなります。ただし、スーパーユーザーは、変換の所有権を変更できます。）</target>
        </trans-unit>
        <trans-unit id="b3c900b3d4c912ff5e4ebc53ea79d5d20107d085" translate="yes" xml:space="preserve">
          <source>You must own the domain to use &lt;code&gt;ALTER DOMAIN&lt;/code&gt;. To change the schema of a domain, you must also have &lt;code&gt;CREATE&lt;/code&gt; privilege on the new schema. To alter the owner, you must also be a direct or indirect member of the new owning role, and that role must have &lt;code&gt;CREATE&lt;/code&gt; privilege on the domain's schema. (These restrictions enforce that altering the owner doesn't do anything you couldn't do by dropping and recreating the domain. However, a superuser can alter ownership of any domain anyway.)</source>
          <target state="translated">&lt;code&gt;ALTER DOMAIN&lt;/code&gt; を使用するには、ドメインを所有している必要があります。ドメインのスキーマを変更するには、新しいスキーマに対する &lt;code&gt;CREATE&lt;/code&gt; 特権も必要です。所有者を変更するには、新しい所有者の役割の直接または間接のメンバーである必要もあり、その役割にはドメインのスキーマに対する &lt;code&gt;CREATE&lt;/code&gt; 特権が必要です。（これらの制限により、所有者を変更しても、ドメインを削除して再作成することで実行できなかったことが実行されなくなります。ただし、スーパーユーザーは、とにかくドメインの所有権を変更できます。）</target>
        </trans-unit>
        <trans-unit id="cb1bc5a4738dcb26a0f29902f3cbbe388057acc0" translate="yes" xml:space="preserve">
          <source>You must own the extension to use &lt;code&gt;ALTER EXTENSION&lt;/code&gt;. The &lt;code&gt;ADD&lt;/code&gt;/&lt;code&gt;DROP&lt;/code&gt; forms require ownership of the added/dropped object as well.</source>
          <target state="translated">&lt;code&gt;ALTER EXTENSION&lt;/code&gt; を使用するには、拡張機能を所有している必要があります。 &lt;code&gt;ADD&lt;/code&gt; / &lt;code&gt;DROP&lt;/code&gt; の形態は、追加/ドロップされたオブジェクトの所有権も同様に必要とします。</target>
        </trans-unit>
        <trans-unit id="a6dffb3cd3b426a1dfeb4f3d4a34d04b92502381" translate="yes" xml:space="preserve">
          <source>You must own the extension to use &lt;code&gt;DROP EXTENSION&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;DROP EXTENSION&lt;/code&gt; を使用するには、拡張機能を所有している必要があります。</target>
        </trans-unit>
        <trans-unit id="9424f801bf04776e94b23d25a246b419d9f806fc" translate="yes" xml:space="preserve">
          <source>You must own the function to use &lt;code&gt;ALTER FUNCTION&lt;/code&gt;. To change a function's schema, you must also have &lt;code&gt;CREATE&lt;/code&gt; privilege on the new schema. To alter the owner, you must also be a direct or indirect member of the new owning role, and that role must have &lt;code&gt;CREATE&lt;/code&gt; privilege on the function's schema. (These restrictions enforce that altering the owner doesn't do anything you couldn't do by dropping and recreating the function. However, a superuser can alter ownership of any function anyway.)</source>
          <target state="translated">&lt;code&gt;ALTER FUNCTION&lt;/code&gt; を使用するには、関数を所有している必要があります。関数のスキーマを変更するには、新しいスキーマに対する &lt;code&gt;CREATE&lt;/code&gt; 権限も必要です。所有者を変更するには、新しい所有ロールの直接または間接のメンバーである必要があり、そのロールには関数のスキーマに対する &lt;code&gt;CREATE&lt;/code&gt; 特権が必要です。 （これらの制限により、所有者を変更しても、関数を削除して再作成することで実行できなかったことが実行されないことが強制されます。ただし、スーパーユーザーは、任意の関数の所有権を変更できます。）</target>
        </trans-unit>
        <trans-unit id="2c5eaf93b84b8e16b7b4075e87568743bd5c26dc" translate="yes" xml:space="preserve">
          <source>You must own the large object to use &lt;code&gt;ALTER LARGE OBJECT&lt;/code&gt;. To alter the owner, you must also be a direct or indirect member of the new owning role. (However, a superuser can alter any large object anyway.) Currently, the only functionality is to assign a new owner, so both restrictions always apply.</source>
          <target state="translated">&lt;code&gt;ALTER LARGE OBJECT&lt;/code&gt; を使用するには、ラージオブジェクトを所有している必要があります。所有者を変更するには、新しい所有ロールの直接または間接のメンバーである必要もあります。 （ただし、スーパーユーザーはいずれにしてもラージオブジェクトを変更できます。）現在、唯一の機能は新しい所有者を割り当てることであるため、両方の制限が常に適用されます。</target>
        </trans-unit>
        <trans-unit id="c749af14eff465f32f3ae73b6015d4eb8f90f209" translate="yes" xml:space="preserve">
          <source>You must own the materialized view to use &lt;code&gt;ALTER MATERIALIZED VIEW&lt;/code&gt;. To change a materialized view's schema, you must also have &lt;code&gt;CREATE&lt;/code&gt; privilege on the new schema. To alter the owner, you must also be a direct or indirect member of the new owning role, and that role must have &lt;code&gt;CREATE&lt;/code&gt; privilege on the materialized view's schema. (These restrictions enforce that altering the owner doesn't do anything you couldn't do by dropping and recreating the materialized view. However, a superuser can alter ownership of any view anyway.)</source>
          <target state="translated">&lt;code&gt;ALTER MATERIALIZED VIEW&lt;/code&gt; を使用するには、マテリアライズドビューを所有している必要があります。マテリアライズドビューのスキーマを変更するには、新しいスキーマに対する &lt;code&gt;CREATE&lt;/code&gt; 権限も必要です。所有者を変更するには、新しい所有ロールの直接または間接のメンバーである必要もあり、そのロールにはマテリアライズドビューのスキーマに対する &lt;code&gt;CREATE&lt;/code&gt; 特権が必要です。 （これらの制限により、所有者を変更しても、マテリアライズドビューを削除して再作成することでは実行できなかったことが実行されないことが強制されます。ただし、スーパーユーザーはとにかくビューの所有権を変更できます。）</target>
        </trans-unit>
        <trans-unit id="c551fec90f0914ad71d1aabc9e18e3244b6d6bf8" translate="yes" xml:space="preserve">
          <source>You must own the operator class to use &lt;code&gt;ALTER OPERATOR CLASS&lt;/code&gt;. To alter the owner, you must also be a direct or indirect member of the new owning role, and that role must have &lt;code&gt;CREATE&lt;/code&gt; privilege on the operator class's schema. (These restrictions enforce that altering the owner doesn't do anything you couldn't do by dropping and recreating the operator class. However, a superuser can alter ownership of any operator class anyway.)</source>
          <target state="translated">&lt;code&gt;ALTER OPERATOR CLASS&lt;/code&gt; を使用するには、演算子クラスを所有している必要があります。所有者を変更するには、新しい所有ロールの直接または間接のメンバーである必要もあり、そのロールには演算子クラスのスキーマに対する &lt;code&gt;CREATE&lt;/code&gt; 特権が必要です。 （これらの制限により、所有者を変更しても、演算子クラスを削除して再作成することで実行できなかったことが実行されなくなります。ただし、スーパーユーザーは、任意の演算子クラスの所有権を変更できます。）</target>
        </trans-unit>
        <trans-unit id="289cb9ff5358010db129ab37edd147b9711820ba" translate="yes" xml:space="preserve">
          <source>You must own the operator to use &lt;code&gt;ALTER OPERATOR&lt;/code&gt;. To alter the owner, you must also be a direct or indirect member of the new owning role, and that role must have &lt;code&gt;CREATE&lt;/code&gt; privilege on the operator's schema. (These restrictions enforce that altering the owner doesn't do anything you couldn't do by dropping and recreating the operator. However, a superuser can alter ownership of any operator anyway.)</source>
          <target state="translated">&lt;code&gt;ALTER OPERATOR&lt;/code&gt; を使用するには、演算子を所有している必要があります。所有者を変更するには、新しい所有ロールの直接または間接のメンバーである必要もあり、そのロールにはオペレーターのスキーマに対する &lt;code&gt;CREATE&lt;/code&gt; 特権が必要です。 （これらの制限により、所有者を変更しても、オペレーターをドロップして再作成することで実行できなかったことが実行されなくなります。ただし、スーパーユーザーは、とにかく任意のオペレーターの所有権を変更できます。）</target>
        </trans-unit>
        <trans-unit id="aa32bd3d71baaa7969581d0d0f33bf13710aaa54" translate="yes" xml:space="preserve">
          <source>You must own the procedure to use &lt;code&gt;ALTER PROCEDURE&lt;/code&gt;. To change a procedure's schema, you must also have &lt;code&gt;CREATE&lt;/code&gt; privilege on the new schema. To alter the owner, you must also be a direct or indirect member of the new owning role, and that role must have &lt;code&gt;CREATE&lt;/code&gt; privilege on the procedure's schema. (These restrictions enforce that altering the owner doesn't do anything you couldn't do by dropping and recreating the procedure. However, a superuser can alter ownership of any procedure anyway.)</source>
          <target state="translated">&lt;code&gt;ALTER PROCEDURE&lt;/code&gt; を使用するには、プロシージャを所有している必要があります。プロシージャのスキーマを変更するには、新しいスキーマに対する &lt;code&gt;CREATE&lt;/code&gt; 権限も必要です。所有者を変更するには、新しい所有ロールの直接または間接のメンバーである必要があり、そのロールにはプロシージャのスキーマに対する &lt;code&gt;CREATE&lt;/code&gt; 特権が必要です。 （これらの制限により、所有者を変更しても、プロシージャを削除して再作成することで実行できなかったことが実行されないことが強制されます。ただし、スーパーユーザーはいずれにしても、プロシージャの所有権を変更できます。）</target>
        </trans-unit>
        <trans-unit id="8c5dd2c9f09fa4613a78c896a4d8ff93764043b0" translate="yes" xml:space="preserve">
          <source>You must own the publication to use &lt;code&gt;ALTER PUBLICATION&lt;/code&gt;. To alter the owner, you must also be a direct or indirect member of the new owning role. The new owner must have &lt;code&gt;CREATE&lt;/code&gt; privilege on the database. Also, the new owner of a &lt;code&gt;FOR ALL TABLES&lt;/code&gt; publication must be a superuser. However, a superuser can change the ownership of a publication while circumventing these restrictions.</source>
          <target state="translated">&lt;code&gt;ALTER PUBLICATION&lt;/code&gt; を使用するには、パブリケーションを所有している必要があります。所有者を変更するには、新しい所有ロールの直接または間接のメンバーである必要もあります。新しい所有者には、データベースに対する &lt;code&gt;CREATE&lt;/code&gt; 特権が必要です。また、 &lt;code&gt;FOR ALL TABLES&lt;/code&gt; パブリケーションの新しい所有者はスーパーユーザーである必要があります。ただし、スーパーユーザーは、これらの制限を回避しながら、パブリケーションの所有権を変更できます。</target>
        </trans-unit>
        <trans-unit id="0ebd09d1ba00b2c43b82e29c8fd88f155f0cc3ea" translate="yes" xml:space="preserve">
          <source>You must own the schema to use &lt;code&gt;ALTER SCHEMA&lt;/code&gt;. To rename a schema you must also have the &lt;code&gt;CREATE&lt;/code&gt; privilege for the database. To alter the owner, you must also be a direct or indirect member of the new owning role, and you must have the &lt;code&gt;CREATE&lt;/code&gt; privilege for the database. (Note that superusers have all these privileges automatically.)</source>
          <target state="translated">&lt;code&gt;ALTER SCHEMA&lt;/code&gt; を使用するには、スキーマを所有している必要があります。スキーマの名前を変更するには、データベースに対する &lt;code&gt;CREATE&lt;/code&gt; 特権も必要です。所有者を変更するには、新しい所有者ロールの直接または間接のメンバーである必要があり、データベースに対する &lt;code&gt;CREATE&lt;/code&gt; 特権を持っている必要があります。 （スーパーユーザーはこれらすべての特権を自動的に持つことに注意してください。）</target>
        </trans-unit>
        <trans-unit id="06321f48b26cbb2ac459fd0a6dc711be8eab0c9e" translate="yes" xml:space="preserve">
          <source>You must own the sequence to use &lt;code&gt;ALTER SEQUENCE&lt;/code&gt;. To change a sequence's schema, you must also have &lt;code&gt;CREATE&lt;/code&gt; privilege on the new schema. To alter the owner, you must also be a direct or indirect member of the new owning role, and that role must have &lt;code&gt;CREATE&lt;/code&gt; privilege on the sequence's schema. (These restrictions enforce that altering the owner doesn't do anything you couldn't do by dropping and recreating the sequence. However, a superuser can alter ownership of any sequence anyway.)</source>
          <target state="translated">&lt;code&gt;ALTER SEQUENCE&lt;/code&gt; を使用するには、シーケンスを所有している必要があります。シーケンスのスキーマを変更するには、新しいスキーマに対する &lt;code&gt;CREATE&lt;/code&gt; 特権も必要です。所有者を変更するには、新しい所有ロールの直接または間接のメンバーである必要もあり、そのロールにはシーケンスのスキーマに対する &lt;code&gt;CREATE&lt;/code&gt; 特権が必要です。 （これらの制限により、所有者を変更しても、シーケンスを削除して再作成することで実行できなかったことが実行されなくなります。ただし、スーパーユーザーは、とにかく任意のシーケンスの所有権を変更できます。）</target>
        </trans-unit>
        <trans-unit id="43effe8f1154a0915e8a351241bc95aed6ecd629" translate="yes" xml:space="preserve">
          <source>You must own the statistics object to use &lt;code&gt;ALTER STATISTICS&lt;/code&gt;. To change a statistics object's schema, you must also have &lt;code&gt;CREATE&lt;/code&gt; privilege on the new schema. To alter the owner, you must also be a direct or indirect member of the new owning role, and that role must have &lt;code&gt;CREATE&lt;/code&gt; privilege on the statistics object's schema. (These restrictions enforce that altering the owner doesn't do anything you couldn't do by dropping and recreating the statistics object. However, a superuser can alter ownership of any statistics object anyway.)</source>
          <target state="translated">&lt;code&gt;ALTER STATISTICS&lt;/code&gt; を使用するには、統計オブジェクトを所有している必要があります。統計オブジェクトのスキーマを変更するには、新しいスキーマに対する &lt;code&gt;CREATE&lt;/code&gt; 特権も必要です。所有者を変更するには、新しい所有ロールの直接または間接のメンバーである必要もあり、そのロールには統計オブジェクトのスキーマに対する &lt;code&gt;CREATE&lt;/code&gt; 特権が必要です。 （これらの制限により、所有者を変更しても、統計オブジェクトを削除して再作成することではできなかったことが実行されなくなります。ただし、スーパーユーザーは、統計オブジェクトの所有権を変更できます。）</target>
        </trans-unit>
        <trans-unit id="407b57125ead1fe2313dbe8d95fd59c9276cf527" translate="yes" xml:space="preserve">
          <source>You must own the subscription to use &lt;code&gt;ALTER SUBSCRIPTION&lt;/code&gt;. To alter the owner, you must also be a direct or indirect member of the new owning role. The new owner has to be a superuser. (Currently, all subscription owners must be superusers, so the owner checks will be bypassed in practice. But this might change in the future.)</source>
          <target state="translated">&lt;code&gt;ALTER SUBSCRIPTION&lt;/code&gt; を使用するには、サブスクリプションを所有している必要があります。所有者を変更するには、新しい所有ロールの直接または間接のメンバーである必要もあります。新しい所有者はスーパーユーザーでなければなりません。 （現在、すべてのサブスクリプション所有者はスーパーユーザーである必要があるため、実際には所有者チェックはバイパスされます。ただし、これは将来変更される可能性があります。）</target>
        </trans-unit>
        <trans-unit id="fcf405f07e7e1cd6574b23914c55360281a218b4" translate="yes" xml:space="preserve">
          <source>You must own the table on which the trigger acts to be allowed to change its properties.</source>
          <target state="translated">トリガーのプロパティを変更できるようにするには、そのトリガーが作用するテーブルを所有する必要があります。</target>
        </trans-unit>
        <trans-unit id="b3ea6ee180cd5e6ed5b2a16c0c2bbd450f2133e6" translate="yes" xml:space="preserve">
          <source>You must own the table to use &lt;code&gt;ALTER FOREIGN TABLE&lt;/code&gt;. To change the schema of a foreign table, you must also have &lt;code&gt;CREATE&lt;/code&gt; privilege on the new schema. To alter the owner, you must also be a direct or indirect member of the new owning role, and that role must have &lt;code&gt;CREATE&lt;/code&gt; privilege on the table's schema. (These restrictions enforce that altering the owner doesn't do anything you couldn't do by dropping and recreating the table. However, a superuser can alter ownership of any table anyway.) To add a column or alter a column type, you must also have &lt;code&gt;USAGE&lt;/code&gt; privilege on the data type.</source>
          <target state="translated">&lt;code&gt;ALTER FOREIGN TABLE&lt;/code&gt; を使用するには、テーブルを所有している必要があります。外部テーブルのスキーマを変更するには、新しいスキーマに対する &lt;code&gt;CREATE&lt;/code&gt; 権限も必要です。所有者を変更するには、新しい所有ロールの直接または間接のメンバーである必要もあり、そのロールにはテーブルのスキーマに対する &lt;code&gt;CREATE&lt;/code&gt; 特権が必要です。 （これらの制限により、所有者を変更しても、テーブルを削除して再作成することでは実行できなかったことが実行されなくなります。ただし、スーパーユーザーは、任意のテーブルの所有権を変更できます。）列を追加したり、列のタイプを変更したりするには、また、データ型に対する &lt;code&gt;USAGE&lt;/code&gt; 特権も持っています。</target>
        </trans-unit>
        <trans-unit id="0ec11d641723946e6db98f0517abce2857c0ddb6" translate="yes" xml:space="preserve">
          <source>You must own the table to use &lt;code&gt;ALTER TABLE&lt;/code&gt;. To change the schema or tablespace of a table, you must also have &lt;code&gt;CREATE&lt;/code&gt; privilege on the new schema or tablespace. To add the table as a new child of a parent table, you must own the parent table as well. Also, to attach a table as a new partition of the table, you must own the table being attached. To alter the owner, you must also be a direct or indirect member of the new owning role, and that role must have &lt;code&gt;CREATE&lt;/code&gt; privilege on the table's schema. (These restrictions enforce that altering the owner doesn't do anything you couldn't do by dropping and recreating the table. However, a superuser can alter ownership of any table anyway.) To add a column or alter a column type or use the &lt;code&gt;OF&lt;/code&gt; clause, you must also have &lt;code&gt;USAGE&lt;/code&gt; privilege on the data type.</source>
          <target state="translated">&lt;code&gt;ALTER TABLE&lt;/code&gt; を使用するには、テーブルを所有している必要があります。テーブルのスキーマまたはテーブルスペースを変更するには、新しいスキーマまたはテーブルスペースに対する &lt;code&gt;CREATE&lt;/code&gt; 権限も必要です。テーブルを親テーブルの新しい子として追加するには、親テーブルも所有している必要があります。また、テーブルをテーブルの新しいパーティションとしてアタッチするには、アタッチされるテーブルを所有している必要があります。所有者を変更するには、新しい所有ロールの直接または間接のメンバーである必要もあり、そのロールにはテーブルのスキーマに対する &lt;code&gt;CREATE&lt;/code&gt; 特権が必要です。 （これらの制限により、所有者を変更しても、テーブルを削除して再作成することでは実行できなかったことが実行されなくなります。ただし、スーパーユーザーは、任意のテーブルの所有権を変更できます。）列を追加したり、列のタイプを変更したり、 &lt;code&gt;OF&lt;/code&gt; 句では、データ型に対する &lt;code&gt;USAGE&lt;/code&gt; 権限も必要です。</target>
        </trans-unit>
        <trans-unit id="b208c35edf5cc5dc00f7bfea3242b7d2ef5016a5" translate="yes" xml:space="preserve">
          <source>You must own the tablespace to change the definition of a tablespace. To alter the owner, you must also be a direct or indirect member of the new owning role. (Note that superusers have these privileges automatically.)</source>
          <target state="translated">テーブルスペースの定義を変更するには、テーブルスペースを所有する必要があります。所有者を変更するには、新しい所有者ロールの直接または間接的なメンバーである必要があります。(スーパーユーザは自動的にこれらの権限を持っていることに注意してください)。</target>
        </trans-unit>
        <trans-unit id="bb0b957526a357fbf1b5dba72d0747095b82b01d" translate="yes" xml:space="preserve">
          <source>You must own the type to use &lt;code&gt;ALTER TYPE&lt;/code&gt;. To change the schema of a type, you must also have &lt;code&gt;CREATE&lt;/code&gt; privilege on the new schema. To alter the owner, you must also be a direct or indirect member of the new owning role, and that role must have &lt;code&gt;CREATE&lt;/code&gt; privilege on the type's schema. (These restrictions enforce that altering the owner doesn't do anything you couldn't do by dropping and recreating the type. However, a superuser can alter ownership of any type anyway.) To add an attribute or alter an attribute type, you must also have &lt;code&gt;USAGE&lt;/code&gt; privilege on the attribute's data type.</source>
          <target state="translated">&lt;code&gt;ALTER TYPE&lt;/code&gt; を使用するには、型を所有している必要があります。型のスキーマを変更するには、新しいスキーマに対する &lt;code&gt;CREATE&lt;/code&gt; 特権も必要です。所有者を変更するには、新しい所有ロールの直接または間接のメンバーである必要があり、そのロールには型のスキーマに対する &lt;code&gt;CREATE&lt;/code&gt; 特権が必要です。（これらの制限により、所有者を変更しても、型を削除して再作成することでできないことは何も行われません。ただし、スーパーユーザーはとにかく任意の型の所有権を変更できます。）属性を追加または属性型を変更するには、属性のデータ型に対する &lt;code&gt;USAGE&lt;/code&gt; 特権もあります。</target>
        </trans-unit>
        <trans-unit id="43a595550cf8e4892a3f9ade890ea91fd323c045" translate="yes" xml:space="preserve">
          <source>You must own the type to use &lt;code&gt;ALTER TYPE&lt;/code&gt;. To change the schema of a type, you must also have &lt;code&gt;CREATE&lt;/code&gt; privilege on the new schema. To alter the owner, you must also be a direct or indirect member of the new owning role, and that role must have &lt;code&gt;CREATE&lt;/code&gt; privilege on the type's schema. (These restrictions enforce that altering the owner doesn't do anything you couldn't do by dropping and recreating the type. However, a superuser can alter ownership of any type anyway.) To add an attribute or alter an attribute type, you must also have &lt;code&gt;USAGE&lt;/code&gt; privilege on the data type.</source>
          <target state="translated">&lt;code&gt;ALTER TYPE&lt;/code&gt; を使用するには、タイプを所有している必要があります。タイプのスキーマを変更するには、新しいスキーマに対する &lt;code&gt;CREATE&lt;/code&gt; 権限も必要です。所有者を変更するには、新しい所有者の役割の直接または間接のメンバーである必要もあり、その役割には、型のスキーマに対する &lt;code&gt;CREATE&lt;/code&gt; 特権が必要です。（これらの制限により、所有者を変更しても、タイプを削除して再作成することで実行できなかったことが実行されなくなります。ただし、スーパーユーザーは、任意のタイプの所有権を変更できます。）属性を追加したり、属性タイプを変更したりするには、また、データ型に対する &lt;code&gt;USAGE&lt;/code&gt; 特権も持っています。</target>
        </trans-unit>
        <trans-unit id="fcbfaecbde4a2455af73d870203e3398469ff416" translate="yes" xml:space="preserve">
          <source>You must own the view to use &lt;code&gt;ALTER VIEW&lt;/code&gt;. To change a view's schema, you must also have &lt;code&gt;CREATE&lt;/code&gt; privilege on the new schema. To alter the owner, you must also be a direct or indirect member of the new owning role, and that role must have &lt;code&gt;CREATE&lt;/code&gt; privilege on the view's schema. (These restrictions enforce that altering the owner doesn't do anything you couldn't do by dropping and recreating the view. However, a superuser can alter ownership of any view anyway.)</source>
          <target state="translated">&lt;code&gt;ALTER VIEW&lt;/code&gt; を使用するには、ビューを所有している必要があります。ビューのスキーマを変更するには、新しいスキーマに対する &lt;code&gt;CREATE&lt;/code&gt; 特権も必要です。所有者を変更するには、新しい所有ロールの直接または間接のメンバーである必要があり、そのロールにはビューのスキーマに対する &lt;code&gt;CREATE&lt;/code&gt; 特権が必要です。（これらの制限により、所有者を変更しても、ビューを削除して再作成することで実行できなかったことが行われることはありません。ただし、スーパーユーザーはとにかくビューの所有権を変更できます。）</target>
        </trans-unit>
        <trans-unit id="4911aa708898e67357c9d052b13bb6ead7673cb0" translate="yes" xml:space="preserve">
          <source>You need to reboot for the changes to take effect. See also &lt;a href=&quot;http://sunsite.uakom.sk/sunworldonline/swol-09-1997/swol-09-insidesolaris.html&quot;&gt;http://sunsite.uakom.sk/sunworldonline/swol-09-1997/swol-09-insidesolaris.html&lt;/a&gt; for information on shared memory under older versions of Solaris.</source>
          <target state="translated">変更を有効にするには、再起動する必要があります。古いバージョンのSolarisでの共有メモリについては、&lt;a href=&quot;http://sunsite.uakom.sk/sunworldonline/swol-09-1997/swol-09-insidesolaris.html&quot;&gt;http：//sunsite.uakom.sk/sunworldonline/swol-09-1997/swol-09-insidesolaris.html&lt;/a&gt;も参照してください。</target>
        </trans-unit>
        <trans-unit id="fab91ed3926641d5859d776177b64f5776bb444d" translate="yes" xml:space="preserve">
          <source>You need to use &lt;code&gt;dearmor()&lt;/code&gt; on these keys before giving them to the PGP functions. Or if you can handle binary data, you can drop &lt;code&gt;-a&lt;/code&gt; from the command.</source>
          <target state="translated">これらのキーをPGP関数に渡す前に、それらに &lt;code&gt;dearmor()&lt;/code&gt; を使用する必要があります。または、バイナリデータを処理できる場合は、コマンドから &lt;code&gt;-a&lt;/code&gt; を削除できます。</target>
        </trans-unit>
        <trans-unit id="329e6d57552f34bb2c8cbc84c71a4150ac977a8a" translate="yes" xml:space="preserve">
          <source>You probably want to start up &lt;code&gt;psql&lt;/code&gt; to try the examples in this tutorial. It can be activated for the &lt;code&gt;mydb&lt;/code&gt; database by typing the command:</source>
          <target state="translated">このチュートリアルの例を試すには、おそらく &lt;code&gt;psql&lt;/code&gt; を起動する必要があります。次のコマンドを入力して、 &lt;code&gt;mydb&lt;/code&gt; データベースに対してアクティブ化できます。</target>
        </trans-unit>
        <trans-unit id="6e22ef5923c1fd5594bbdb16bda1e16d0fcc7df3" translate="yes" xml:space="preserve">
          <source>You should also consider setting &lt;code&gt;hot_standby_feedback&lt;/code&gt; on standby server(s) as an alternative to using this parameter.</source>
          <target state="translated">このパラメーターを使用する代わりに、スタンバイサーバーで &lt;code&gt;hot_standby_feedback&lt;/code&gt; を設定することも検討してください。</target>
        </trans-unit>
        <trans-unit id="abf0f469a9c924ec822fbdcdda37276bcd973b00" translate="yes" xml:space="preserve">
          <source>You should at this point be wondering how the input and output functions can be declared to have results or arguments of the new type, when they have to be created before the new type can be created. The answer is that the type should first be defined as a &lt;em&gt;shell type&lt;/em&gt;, which is a placeholder type that has no properties except a name and an owner. This is done by issuing the command &lt;code&gt;CREATE TYPE name&lt;/code&gt;, with no additional parameters. Then the C I/O functions can be defined referencing the shell type. Finally, &lt;code&gt;CREATE TYPE&lt;/code&gt; with a full definition replaces the shell entry with a complete, valid type definition, after which the new type can be used normally.</source>
          <target state="translated">この時点で、新しい型を作成する前にそれらを作成する必要があるときに、入出力関数が新しい型の結果または引数を持つように宣言する方法を疑問に思うはずです。答えは、タイプは最初に&lt;em&gt;シェルタイプ&lt;/em&gt;として定義する必要があるということです。これは、名前と所有者以外のプロパティを持たないプレースホルダータイプです。これは、追加パラメーターなしでコマンド &lt;code&gt;CREATE TYPE name&lt;/code&gt; を発行することによって行われます。次に、シェルタイプを参照してCI / O関数を定義できます。最後に、完全な定義を持つ &lt;code&gt;CREATE TYPE&lt;/code&gt; は、シェルエントリを完全な有効な型定義に置き換えます。その後、新しい型を通常どおり使用できます。</target>
        </trans-unit>
        <trans-unit id="62998832a31a93f392b8c5c32a45b2a0ab95bec2" translate="yes" xml:space="preserve">
          <source>You should consider that the network bandwidth must be higher than the rate of generation of WAL data.</source>
          <target state="translated">ネットワーク帯域はWALデータの生成率よりも高くなければならないと考えるべきです。</target>
        </trans-unit>
        <trans-unit id="43179d16a3a417045be109f728f3b3a1fb7c1178" translate="yes" xml:space="preserve">
          <source>You should remember that DTrace scripts need to be carefully written and debugged, otherwise the trace information collected might be meaningless. In most cases where problems are found it is the instrumentation that is at fault, not the underlying system. When discussing information found using dynamic tracing, be sure to enclose the script used to allow that too to be checked and discussed.</source>
          <target state="translated">DTrace スクリプトは慎重に書いてデバッグする必要があることを覚えておいてください。問題が発見されたほとんどのケースでは、障害が発生しているのは計測器であり、基礎となるシステムではありません。ダイナミックトレースを使用して発見された情報を議論する場合は、それもチェックして議論できるように、使用したスクリプトを必ず同封してください。</target>
        </trans-unit>
        <trans-unit id="3bf69a6d0ffb8bac8b279e39a485a02a700714e9" translate="yes" xml:space="preserve">
          <source>You should take care that the data types specified for a probe's parameters match the data types of the variables used in the macro. Otherwise, you will get compilation errors.</source>
          <target state="translated">プローブのパラメータに指定されたデータ型が、マクロで使用される変数のデータ型と一致するように注意する必要があります。そうしないとコンパイルエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="d04a892bbd8087c24b67b0ef9b1ba084ecd5f255" translate="yes" xml:space="preserve">
          <source>You should, however, omit from the backup the files within the cluster's &lt;code&gt;pg_wal/&lt;/code&gt; subdirectory. This slight adjustment is worthwhile because it reduces the risk of mistakes when restoring. This is easy to arrange if &lt;code&gt;pg_wal/&lt;/code&gt; is a symbolic link pointing to someplace outside the cluster directory, which is a common setup anyway for performance reasons. You might also want to exclude &lt;code&gt;postmaster.pid&lt;/code&gt; and &lt;code&gt;postmaster.opts&lt;/code&gt;, which record information about the running postmaster, not about the postmaster which will eventually use this backup. (These files can confuse pg_ctl.)</source>
          <target state="translated">ただし、クラスターの &lt;code&gt;pg_wal/&lt;/code&gt; サブディレクトリ内のファイルはバックアップから除外する必要があります。このわずかな調整は、復元時のミスのリスクを減らすため、価値があります。 &lt;code&gt;pg_wal/&lt;/code&gt; がクラスターディレクトリの外部のどこかを指すシンボリックリンクである場合、これは簡単に調整できます。これはいずれにしても、パフォーマンス上の理由から一般的な設定です。また、最終的にこのバックアップを使用するポストマスターに関する情報ではなく、実行中のポストマスターに関する情報を記録する &lt;code&gt;postmaster.pid&lt;/code&gt; および &lt;code&gt;postmaster.opts&lt;/code&gt; を除外することもできます。 （これらのファイルはpg_ctlを混乱させる可能性があります。）</target>
        </trans-unit>
        <trans-unit id="f688c2bcf87c6522b972dcd5d1a0d98122829c3b" translate="yes" xml:space="preserve">
          <source>You use the &lt;a href=&quot;sql-delete&quot;&gt;DELETE&lt;/a&gt; command to remove rows; the syntax is very similar to the &lt;code&gt;UPDATE&lt;/code&gt; command. For instance, to remove all rows from the products table that have a price of 10, use:</source>
          <target state="translated">行を削除するには、&lt;a href=&quot;sql-delete&quot;&gt;DELETE&lt;/a&gt;コマンドを使用します。構文は、 &lt;code&gt;UPDATE&lt;/code&gt; コマンドと非常によく似ています。たとえば、価格が10のすべての行を製品テーブルから削除するには、次のようにします。</target>
        </trans-unit>
        <trans-unit id="c8d44004f1a1375d285a996132364e5a09cd0aa9" translate="yes" xml:space="preserve">
          <source>You usually only need to set this parameter in complex re-recovery situations, where you need to return to a state that itself was reached after a point-in-time recovery. See &lt;a href=&quot;continuous-archiving#BACKUP-TIMELINES&quot;&gt;Section 25.3.5&lt;/a&gt; for discussion.</source>
          <target state="translated">通常、このパラメーターを設定する必要があるのは、ポイントインタイムリカバリーの後に到達した状態に戻る必要がある複雑な再リカバリー状況のみです。議論については&lt;a href=&quot;continuous-archiving#BACKUP-TIMELINES&quot;&gt;項25.3.5&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="1c0b4770f607d09fa317c5dc06f4c40416fa8fa6" translate="yes" xml:space="preserve">
          <source>You will encounter this style of abbreviating quite frequently.</source>
          <target state="translated">このような略し方には、かなりの頻度で遭遇することになります。</target>
        </trans-unit>
        <trans-unit id="f2689ccc464a2d160017022cb703ee291e2f949e" translate="yes" xml:space="preserve">
          <source>You will sometimes need to add parentheses when using combinations of binary and unary operators. For instance:</source>
          <target state="translated">二項演算子と単項演算子の組み合わせを使用する際には、括弧を追加する必要がある場合があります。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="4f96b903666683fcb600721163b7537153b2acf3" translate="yes" xml:space="preserve">
          <source>You will then need to use gunzip during recovery:</source>
          <target state="translated">その後、回復中にgunzipを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="76a9773cd5b34137343c2a3db898da05e9e5088f" translate="yes" xml:space="preserve">
          <source>You will usually want to increase &lt;code&gt;kern.ipc.semmni&lt;/code&gt; and &lt;code&gt;kern.ipc.semmns&lt;/code&gt;, as NetBSD's default settings for these are uncomfortably small.</source>
          <target state="translated">NetBSDのデフォルト設定は不快なほど小さい &lt;code&gt;kern.ipc.semmns&lt;/code&gt; 、通常、 &lt;code&gt;kern.ipc.semmni&lt;/code&gt; とkern.ipc.semmnsを増やしたいでしょう。</target>
        </trans-unit>
        <trans-unit id="4d7dd316d288d7dc8cab74686babd6da0f71907c" translate="yes" xml:space="preserve">
          <source>You will usually want to increase &lt;code&gt;kern.seminfo.semmni&lt;/code&gt; and &lt;code&gt;kern.seminfo.semmns&lt;/code&gt;, as OpenBSD's default settings for these are uncomfortably small.</source>
          <target state="translated">OpenBSDのデフォルト設定が不快に小さいため、通常、 &lt;code&gt;kern.seminfo.semmni&lt;/code&gt; と &lt;code&gt;kern.seminfo.semmns&lt;/code&gt; を増やしたいと思うでしょう。</target>
        </trans-unit>
        <trans-unit id="2609a6d5763d68ee7a0a0d2d4b45f307e6ae5ffd" translate="yes" xml:space="preserve">
          <source>Zero-Column Tables</source>
          <target state="translated">ゼロカラムテーブル</target>
        </trans-unit>
        <trans-unit id="30c11554a2b9e71795733af27503dd2000ac35f9" translate="yes" xml:space="preserve">
          <source>Zipfian-distributed random integer in &lt;code&gt;[lb, ub]&lt;/code&gt;, see below</source>
          <target state="translated">&lt;code&gt;[lb, ub]&lt;/code&gt; ジップフィアン分布ランダム整数、以下を参照</target>
        </trans-unit>
        <trans-unit id="329669d49d5a7c00789e68977fd4b07da1d077c8" translate="yes" xml:space="preserve">
          <source>[ &lt;code&gt;ENCRYPTED&lt;/code&gt; ] &lt;code&gt;PASSWORD&lt;/code&gt; '&lt;code&gt;password&lt;/code&gt;'&lt;code&gt;PASSWORD NULL&lt;/code&gt;</source>
          <target state="translated">[ &lt;code&gt;ENCRYPTED&lt;/code&gt; ] &lt;code&gt;PASSWORD&lt;/code&gt; ' &lt;code&gt;password&lt;/code&gt; ' &lt;code&gt;PASSWORD NULL&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="689b11d9bddde6c1d7ee8e5eb112418a0978460f" translate="yes" xml:space="preserve">
          <source>[(x1,y1),...]</source>
          <target state="translated">[(x1,y1),...]</target>
        </trans-unit>
        <trans-unit id="56bed60529c445af77ea7362851c52890ef3de9a" translate="yes" xml:space="preserve">
          <source>[a, b] is entirely to the left of [c, d]. That is, [a, b] &amp;lt;&amp;lt; [c, d] is true if b &amp;lt; c and false otherwise.</source>
          <target state="translated">[a、b]は完全に[c、d]の左側にあります。つまり、[a、b] &amp;lt;&amp;lt; [c、d]は、b &amp;lt;cの場合はtrue、それ以外の場合はfalseです。</target>
        </trans-unit>
        <trans-unit id="46347467de76083a1f3b3ab7c5a273c56dcfd8f4" translate="yes" xml:space="preserve">
          <source>[a, b] is entirely to the right of [c, d]. That is, [a, b] &amp;gt;&amp;gt; [c, d] is true if a &amp;gt; d and false otherwise.</source>
          <target state="translated">[a、b]は完全に[c、d]の右側にあります。つまり、[a、b] &amp;gt;&amp;gt; [c、d]は、a&amp;gt; dの場合はtrue、それ以外の場合はfalseです。</target>
        </trans-unit>
        <trans-unit id="038cf8dbb178850257e9230060d8fcef7ddfb5a0" translate="yes" xml:space="preserve">
          <source>[elma04]</source>
          <target state="translated">[elma04]</target>
        </trans-unit>
        <trans-unit id="2b5f5b947ce4c4c7f099a0a2d735357e09310b58" translate="yes" xml:space="preserve">
          <source>[fong]</source>
          <target state="translated">[fong]</target>
        </trans-unit>
        <trans-unit id="5c07a6ad2db9480747f4d609fb47951588166180" translate="yes" xml:space="preserve">
          <source>a &lt;em&gt;bracket expression&lt;/em&gt;, matching any one of the &lt;code&gt;chars&lt;/code&gt; (see &lt;a href=&quot;functions-matching#POSIX-BRACKET-EXPRESSIONS&quot;&gt;Section 9.7.3.2&lt;/a&gt; for more detail)</source>
          <target state="translated">大&lt;em&gt;括弧式&lt;/em&gt;、いずれかの &lt;code&gt;chars&lt;/code&gt; と一致（詳細は&lt;a href=&quot;functions-matching#POSIX-BRACKET-EXPRESSIONS&quot;&gt;9.7.3.2項を&lt;/a&gt;参照）</target>
        </trans-unit>
        <trans-unit id="5c2a04f8a25082f47f2b1b62420d51d9e2586092" translate="yes" xml:space="preserve">
          <source>a closed path?</source>
          <target state="translated">閉ざされた道?</target>
        </trans-unit>
        <trans-unit id="4f837508b52bb0f6f0c188e3d8239bb66f7f30b3" translate="yes" xml:space="preserve">
          <source>a label beginning with the case-insensitive prefix &lt;code&gt;sport&lt;/code&gt;</source>
          <target state="translated">大文字と小文字を区別しない接頭辞 &lt;code&gt;sport&lt;/code&gt; で始まるラベル</target>
        </trans-unit>
        <trans-unit id="8b52f02d3dbf1419017e235881c6561ac7603288" translate="yes" xml:space="preserve">
          <source>a sequence of 0 or 1 matches of the atom</source>
          <target state="translated">原子の0または1マッチのシーケンス</target>
        </trans-unit>
        <trans-unit id="c789ac60ffb3a4856f62a0cc113a4a9eb99a3e78" translate="yes" xml:space="preserve">
          <source>a sequence of 0 or more matches of the atom</source>
          <target state="translated">原子の0以上の一致したシーケンス</target>
        </trans-unit>
        <trans-unit id="37235ff249a4a2dc93bed2d89eba1468f3102441" translate="yes" xml:space="preserve">
          <source>a sequence of 1 or more matches of the atom</source>
          <target state="translated">原子の1以上の一致したシーケンス</target>
        </trans-unit>
        <trans-unit id="f4d6892681b0f2c2f68672a4ea2ebea56a26fb7c" translate="yes" xml:space="preserve">
          <source>a sequence of &lt;code&gt;m&lt;/code&gt; or more matches of the atom</source>
          <target state="translated">アトムの &lt;code&gt;m&lt;/code&gt; 以上の一致のシーケンス</target>
        </trans-unit>
        <trans-unit id="d6eb7a7a662e02de4e455a3d9cb22b1e5cbc9fd0" translate="yes" xml:space="preserve">
          <source>a sequence of &lt;code&gt;m&lt;/code&gt; through &lt;code&gt;n&lt;/code&gt; (inclusive) matches of the atom; &lt;code&gt;m&lt;/code&gt; cannot exceed &lt;code&gt;n&lt;/code&gt;</source>
          <target state="translated">アトムの &lt;code&gt;m&lt;/code&gt; から &lt;code&gt;n&lt;/code&gt; （包括的）マッチのシーケンス。 &lt;code&gt;m&lt;/code&gt; は &lt;code&gt;n&lt;/code&gt; を超えることはできません</target>
        </trans-unit>
        <trans-unit id="8a1befdcf13a2caa739dbb24cca880bbc955a58b" translate="yes" xml:space="preserve">
          <source>a sequence of exactly &lt;code&gt;m&lt;/code&gt; matches of the atom</source>
          <target state="translated">原子のちょうど &lt;code&gt;m&lt;/code&gt; 個の一致のシーケンス</target>
        </trans-unit>
        <trans-unit id="42e244f289cb2901a2850fc0e292f5c6110aec21" translate="yes" xml:space="preserve">
          <source>a single lexeme with the &lt;code&gt;TSL_FILTER&lt;/code&gt; flag set, to replace the original token with a new token to be passed to subsequent dictionaries (a dictionary that does this is called a &lt;em&gt;filtering dictionary&lt;/em&gt;)</source>
          <target state="translated">&lt;code&gt;TSL_FILTER&lt;/code&gt; フラグが設定された単一の語彙素。元のトークンを後続のディクショナリに渡す新しいトークンで置き換えます（これを行うディクショナリは、&lt;em&gt;フィルタリングディクショナリ&lt;/em&gt;と呼ばれ&lt;em&gt;ます&lt;/em&gt;）</target>
        </trans-unit>
        <trans-unit id="39c985af6407cb40e9f21b877cb2f14f1ab7445e" translate="yes" xml:space="preserve">
          <source>a white-space character or &lt;code&gt;#&lt;/code&gt; preceded by &lt;code&gt;\&lt;/code&gt; is retained</source>
          <target state="translated">空白文字または &lt;code&gt;#&lt;/code&gt; の前にある &lt;code&gt;\&lt;/code&gt; が保持されます</target>
        </trans-unit>
        <trans-unit id="c79c0a316e1b5d5dfe7325f52987831549fe62de" translate="yes" xml:space="preserve">
          <source>abbreviated capitalized day name (3 chars in English, localized lengths vary)</source>
          <target state="translated">短縮型大文字日名</target>
        </trans-unit>
        <trans-unit id="264cda486a8f189eb4b75e086f6d14582addebc5" translate="yes" xml:space="preserve">
          <source>abbreviated capitalized month name (3 chars in English, localized lengths vary)</source>
          <target state="translated">短縮型大文字月名</target>
        </trans-unit>
        <trans-unit id="ece4f8ac5a0911464c77304a7d93e8b052502ee1" translate="yes" xml:space="preserve">
          <source>abbreviated display format as text</source>
          <target state="translated">テキスト省略表示形式</target>
        </trans-unit>
        <trans-unit id="88b965dacddbd5c3be3568170a1a398601e53a48" translate="yes" xml:space="preserve">
          <source>abbreviated lower case day name (3 chars in English, localized lengths vary)</source>
          <target state="translated">省略形小文字日名</target>
        </trans-unit>
        <trans-unit id="9186b18dd65f270c46192797d4cb755071c05c1e" translate="yes" xml:space="preserve">
          <source>abbreviated lower case month name (3 chars in English, localized lengths vary)</source>
          <target state="translated">短縮形月名</target>
        </trans-unit>
        <trans-unit id="a3f61c541f5db806cb405bf2892b6722718fec31" translate="yes" xml:space="preserve">
          <source>abbreviated upper case day name (3 chars in English, localized lengths vary)</source>
          <target state="translated">省略形大文字日名</target>
        </trans-unit>
        <trans-unit id="7577f3a97383fa6c0292570407f15fbf40857e56" translate="yes" xml:space="preserve">
          <source>abbreviated upper case month name (3 chars in English, localized lengths vary)</source>
          <target state="translated">省略形大文字月名</target>
        </trans-unit>
        <trans-unit id="33f31413199ddb62fc17b8f2bed78e9d010e94da" translate="yes" xml:space="preserve">
          <source>absolute value</source>
          <target state="translated">絶対値</target>
        </trans-unit>
        <trans-unit id="de8436d989e265b7b258d6602654167f651db67b" translate="yes" xml:space="preserve">
          <source>access method operator classes</source>
          <target state="translated">アクセスメソッド演算子クラス</target>
        </trans-unit>
        <trans-unit id="639212fb06d8ccc51f13d82301ca6b66a2deb947" translate="yes" xml:space="preserve">
          <source>access method operator families</source>
          <target state="translated">アクセスメソッド演算子族</target>
        </trans-unit>
        <trans-unit id="a5886a24a9cd7f64cdec22dc5f1b0dad9949c443" translate="yes" xml:space="preserve">
          <source>access method operators</source>
          <target state="translated">アクセスメソッド演算子</target>
        </trans-unit>
        <trans-unit id="cce1015f8d299b67b710b93d76b497f49fa98565" translate="yes" xml:space="preserve">
          <source>access method support functions</source>
          <target state="translated">アクセスメソッド支援機能</target>
        </trans-unit>
        <trans-unit id="b9cfb8c8675bb466671371ec06207e1c430329f4" translate="yes" xml:space="preserve">
          <source>adding affix</source>
          <target state="translated">加筆</target>
        </trans-unit>
        <trans-unit id="c3805175370d19c334b59f45b87343b9f2b7f5e1" translate="yes" xml:space="preserve">
          <source>addition</source>
          <target state="translated">addition</target>
        </trans-unit>
        <trans-unit id="9118866496dfbc2e597505390a41e74349ab5152" translate="yes" xml:space="preserve">
          <source>addition, subtraction</source>
          <target state="translated">足し算引き算</target>
        </trans-unit>
        <trans-unit id="aaf09a4b156ac6da8c98f72704c7cee1497e7d6f" translate="yes" xml:space="preserve">
          <source>additional foreign table information</source>
          <target state="translated">追加の外部テーブル情報</target>
        </trans-unit>
        <trans-unit id="1a32619c4b1c2c834145f692705708f779bed83a" translate="yes" xml:space="preserve">
          <source>additional index information</source>
          <target state="translated">追加索引情報</target>
        </trans-unit>
        <trans-unit id="de48f56b01bcd91fd19904d21fc567f7aeb73b16" translate="yes" xml:space="preserve">
          <source>address of the local connection</source>
          <target state="translated">ローカル接続アドレス</target>
        </trans-unit>
        <trans-unit id="95dd78f31f2d2267d2022e6763c1fb744bbf23ea" translate="yes" xml:space="preserve">
          <source>address of the remote connection</source>
          <target state="translated">リモート接続のアドレス</target>
        </trans-unit>
        <trans-unit id="0e18d863cc787a1080e11d6aad8c84c3d163b704" translate="yes" xml:space="preserve">
          <source>adminpack</source>
          <target state="translated">adminpack</target>
        </trans-unit>
        <trans-unit id="bccf7370fc6bc7e65ebb00bcd447b407dc6e3ec1" translate="yes" xml:space="preserve">
          <source>aggregate functions</source>
          <target state="translated">集計機能</target>
        </trans-unit>
        <trans-unit id="5707e56794034492e28fb802f0929edc22148ae3" translate="yes" xml:space="preserve">
          <source>aggregates name/value pairs as a JSON object; values can be null, but not names</source>
          <target state="translated">名前と値のペアをJSONオブジェクトとして集約します。</target>
        </trans-unit>
        <trans-unit id="100b0a2fce8f87a6bf417e59568b60def0dd95ed" translate="yes" xml:space="preserve">
          <source>aggregates values, including nulls, as a JSON array</source>
          <target state="translated">NULLを含む値をJSON配列として集約します。</target>
        </trans-unit>
        <trans-unit id="27428a051111f05b13f941652832e7ba4a594fed" translate="yes" xml:space="preserve">
          <source>alert (bell) character, as in C</source>
          <target state="translated">警鐘</target>
        </trans-unit>
        <trans-unit id="8a97bf0012dbebc5bcefd88a6e6ca0df50de1524" translate="yes" xml:space="preserve">
          <source>alias for &lt;code&gt;hash_murmur2()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;hash_murmur2()&lt;/code&gt; のエイリアス</target>
        </trans-unit>
        <trans-unit id="e3acb7916bd347d132eed28f72c60ded2aae1942" translate="yes" xml:space="preserve">
          <source>all other native and user-defined operators</source>
          <target state="translated">他のすべてのネイティブおよびユーザー定義の演算子</target>
        </trans-unit>
        <trans-unit id="15100289fd2a2926dbfc0362c8c82f216aafdb18" translate="yes" xml:space="preserve">
          <source>amcheck</source>
          <target state="translated">amcheck</target>
        </trans-unit>
        <trans-unit id="663bae22b8d6ed1b0c5424f47e75478c4fc96f3e" translate="yes" xml:space="preserve">
          <source>an array of lexemes if the input token is known to the dictionary (notice that one token can produce more than one lexeme)</source>
          <target state="translated">入力トークンが辞書に既知である場合は、辞書の配列 (1つのトークンが複数の語彙を生成できることに注意してください)</target>
        </trans-unit>
        <trans-unit id="232a7414ddb1870267de0ac5d074d426c7090d4d" translate="yes" xml:space="preserve">
          <source>an empty array if the dictionary knows the token, but it is a stop word</source>
          <target state="translated">辞書がトークンを知っていても、それがストップワードの場合は空の配列。</target>
        </trans-unit>
        <trans-unit id="4a50c2a4d787c9ec20847e24d511e5f7edd971bf" translate="yes" xml:space="preserve">
          <source>an integer between &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;10&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;1&lt;/code&gt; から &lt;code&gt;10&lt;/code&gt; までの整数</target>
        </trans-unit>
        <trans-unit id="0b6686e81b37171a7ea6080018ce0ae5e675c63c" translate="yes" xml:space="preserve">
          <source>an open path?</source>
          <target state="translated">開かれた道?</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="195ca7bc7f18fd5ef1b0e2c3a54dd46b02d4927d" translate="yes" xml:space="preserve">
          <source>and &lt;code&gt;frame_exclusion&lt;/code&gt; can be one of</source>
          <target state="translated">そして、 &lt;code&gt;frame_exclusion&lt;/code&gt; は</target>
        </trans-unit>
        <trans-unit id="b061bc6b05f4e30ad67fd83ca835fa19bda9bb24" translate="yes" xml:space="preserve">
          <source>and &lt;code&gt;mode&lt;/code&gt; is one of:</source>
          <target state="translated">そして &lt;code&gt;mode&lt;/code&gt; 次のいずれかです。</target>
        </trans-unit>
        <trans-unit id="dfcc9edf53bd479c53a758f8cd20ae723fac9500" translate="yes" xml:space="preserve">
          <source>and &lt;code&gt;padding&lt;/code&gt; is one of:</source>
          <target state="translated">そして、 &lt;code&gt;padding&lt;/code&gt; 次のいずれかです。</target>
        </trans-unit>
        <trans-unit id="1f043826d65c29cd9d06435f4c3f4c44886caf1f" translate="yes" xml:space="preserve">
          <source>and &lt;code&gt;psql&lt;/code&gt; will quit and return you to your command shell. (For more internal commands, type &lt;code&gt;\?&lt;/code&gt; at the &lt;code&gt;psql&lt;/code&gt; prompt.) The full capabilities of &lt;code&gt;psql&lt;/code&gt; are documented in &lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt;. In this tutorial we will not use these features explicitly, but you can use them yourself when it is helpful.</source>
          <target state="translated">そして、 &lt;code&gt;psql&lt;/code&gt; は終了し、コマンドシェルに戻ります。（他の内部コマンド、種類について &lt;code&gt;\?&lt;/code&gt; で &lt;code&gt;psql&lt;/code&gt; のプロンプトが表示されます。）の全機能 &lt;code&gt;psql&lt;/code&gt; はに記載されてい&lt;a href=&quot;app-psql&quot;&gt;PSQL&lt;/a&gt;。このチュートリアルでは、これらの機能を明示的に使用しませんが、役立つ場合は自分で使用できます。</target>
        </trans-unit>
        <trans-unit id="3badfcd96666510617917bc44cf260ce650da948" translate="yes" xml:space="preserve">
          <source>and &lt;code&gt;t2&lt;/code&gt;:</source>
          <target state="translated">そして &lt;code&gt;t2&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="64f54598fc8b10700b447590aedbe9802f2cf914" translate="yes" xml:space="preserve">
          <source>and Collations</source>
          <target state="translated">と照合</target>
        </trans-unit>
        <trans-unit id="097ca12344ffcd3926b70cf91232fc017a3d35e9" translate="yes" xml:space="preserve">
          <source>and ORDER BY</source>
          <target state="translated">で、次のように並び替えます。</target>
        </trans-unit>
        <trans-unit id="a41a99f30db5c8c73bb765ef058446c9ffe876c5" translate="yes" xml:space="preserve">
          <source>and all the dependent objects will be removed, as will any objects that depend on them, recursively. In this case, it doesn't remove the orders table, it only removes the foreign key constraint. It stops there because nothing depends on the foreign key constraint. (If you want to check what &lt;code&gt;DROP ... CASCADE&lt;/code&gt; will do, run &lt;code&gt;DROP&lt;/code&gt; without &lt;code&gt;CASCADE&lt;/code&gt; and read the &lt;code&gt;DETAIL&lt;/code&gt; output.)</source>
          <target state="translated">そして、依存するすべてのオブジェクトは、それらに依存するオブジェクトと同様に、再帰的に削除されます。この場合、ordersテーブルは削除されず、外部キー制約のみが削除されます。外部キー制約に何も依存しないため、そこで停止します。 （あなたが何を確認したい場合は &lt;code&gt;DROP ... CASCADE&lt;/code&gt; 、実行行います &lt;code&gt;DROP&lt;/code&gt; をすることなく、 &lt;code&gt;CASCADE&lt;/code&gt; と読み &lt;code&gt;DETAIL&lt;/code&gt; 出力を。）</target>
        </trans-unit>
        <trans-unit id="91ded08e1c2fb163ac112ff991a147382d928feb" translate="yes" xml:space="preserve">
          <source>and can appear anywhere a &lt;code&gt;SELECT&lt;/code&gt; can. For example, you can use it as part of a &lt;code&gt;UNION&lt;/code&gt;, or attach a &lt;code&gt;sort_specification&lt;/code&gt; (&lt;code&gt;ORDER BY&lt;/code&gt;, &lt;code&gt;LIMIT&lt;/code&gt;, and/or &lt;code&gt;OFFSET&lt;/code&gt;) to it. &lt;code&gt;VALUES&lt;/code&gt; is most commonly used as the data source in an &lt;code&gt;INSERT&lt;/code&gt; command, and next most commonly as a subquery.</source>
          <target state="translated">&lt;code&gt;SELECT&lt;/code&gt; ができる場所ならどこにでも置くことができます。たとえば、それを &lt;code&gt;UNION&lt;/code&gt; の一部として使用したり、 &lt;code&gt;sort_specification&lt;/code&gt; （ &lt;code&gt;ORDER BY&lt;/code&gt; 、 &lt;code&gt;LIMIT&lt;/code&gt; 、または &lt;code&gt;OFFSET&lt;/code&gt; 、あるいはその両方）をアタッチしたりできます。 &lt;code&gt;VALUES&lt;/code&gt; は &lt;code&gt;INSERT&lt;/code&gt; コマンドのデータソースとして最も一般的に使用され、次に最も一般的にはサブクエリとして使用されます。</target>
        </trans-unit>
        <trans-unit id="463a6cd589d2223d499014d12a55159d1281075e" translate="yes" xml:space="preserve">
          <source>and her transaction is in &lt;code&gt;READ COMMITTED&lt;/code&gt; mode, it is possible for her to see &amp;ldquo;secret from mallory&amp;rdquo;. That happens if her transaction reaches the &lt;code&gt;information&lt;/code&gt; row just after &lt;code&gt;alice&lt;/code&gt;'s does. It blocks waiting for &lt;code&gt;alice&lt;/code&gt;'s transaction to commit, then fetches the updated row contents thanks to the &lt;code&gt;FOR UPDATE&lt;/code&gt; clause. However, it does &lt;em&gt;not&lt;/em&gt; fetch an updated row for the implicit &lt;code&gt;SELECT&lt;/code&gt; from &lt;code&gt;users&lt;/code&gt;, because that sub-&lt;code&gt;SELECT&lt;/code&gt; did not have &lt;code&gt;FOR UPDATE&lt;/code&gt;; instead the &lt;code&gt;users&lt;/code&gt; row is read with the snapshot taken at the start of the query. Therefore, the policy expression tests the old value of &lt;code&gt;mallory&lt;/code&gt;'s privilege level and allows her to see the updated row.</source>
          <target state="translated">彼女のトランザクションが &lt;code&gt;READ COMMITTED&lt;/code&gt; モードになっていると、「マロリーからの秘密」を見ることができます。これは、 &lt;code&gt;alice&lt;/code&gt; の直後に彼女のトランザクションが &lt;code&gt;information&lt;/code&gt; 行に到達した場合に発生します。 &lt;code&gt;FOR UPDATE&lt;/code&gt; 句のおかげで、 &lt;code&gt;alice&lt;/code&gt; のトランザクションがコミットするのを待ってブロックし、更新された行の内容をフェッチします。ただし、そのサブ &lt;code&gt;SELECT&lt;/code&gt; には &lt;code&gt;FOR UPDATE&lt;/code&gt; がないため、 &lt;code&gt;users&lt;/code&gt; からの暗黙の &lt;code&gt;SELECT&lt;/code&gt; の更新された行&lt;em&gt;は&lt;/em&gt;フェッチされませ&lt;em&gt;ん&lt;/em&gt;。代わりに &lt;code&gt;users&lt;/code&gt; &lt;em&gt;&lt;/em&gt;行は、クエリの開始時に取得されたスナップショットで読み取られます。したがって、ポリシー式は &lt;code&gt;mallory&lt;/code&gt; の特権レベルの古い値をテストし、更新された行を表示できるようにします。</target>
        </trans-unit>
        <trans-unit id="2ddf7473848fa4907e6ee0ff26623f75dfed1f01" translate="yes" xml:space="preserve">
          <source>and next has zero to two labels before</source>
          <target state="translated">の前に0から2つのラベルがあります。</target>
        </trans-unit>
        <trans-unit id="d723326824a3836a81d727940bbbaebfea441ace" translate="yes" xml:space="preserve">
          <source>and obtains the result 300, which it inserts in a new row with &lt;code&gt;class&lt;/code&gt;&lt;code&gt;= 1&lt;/code&gt;. Then both transactions try to commit. If either transaction were running at the Repeatable Read isolation level, both would be allowed to commit; but since there is no serial order of execution consistent with the result, using Serializable transactions will allow one transaction to commit and will roll the other back with this message:</source>
          <target state="translated">そして結果300を取得し、それを &lt;code&gt;class&lt;/code&gt; &lt;code&gt;= 1&lt;/code&gt; 新しい行に挿入します。次に、両方のトランザクションがコミットを試みます。どちらかのトランザクションが反復可能読み取り分離レベルで実行されている場合、両方のコミットが許可されます。しかし、結果と一致する実行のシリアル順がないため、Serializableトランザクションを使用すると、1つのトランザクションをコミットでき、次のメッセージで他のトランザクションをロールバックします。</target>
        </trans-unit>
        <trans-unit id="abd292e64f5762adf92489151f65db3a2d25c4cf" translate="yes" xml:space="preserve">
          <source>and overriding the collation of a function or operator call that has locale-sensitive results, for example:</source>
          <target state="translated">を使用して、例えばロケールセンシティブな結果を持つ関数や演算子呼び出しの照合をオーバーライドすることができます。</target>
        </trans-unit>
        <trans-unit id="4472b3d78f22b89c61f97b762041a5148f6b86b3" translate="yes" xml:space="preserve">
          <source>and the application issues many queries of the form:</source>
          <target state="translated">とアプリケーションは、フォームの多くのクエリを発行します。</target>
        </trans-unit>
        <trans-unit id="519bfeab6436137fc4443c937b4e2a57a5222950" translate="yes" xml:space="preserve">
          <source>and then ends with a label beginning with &lt;code&gt;Russ&lt;/code&gt; or exactly matching &lt;code&gt;Spain&lt;/code&gt;.</source>
          <target state="translated">次に、 &lt;code&gt;Russ&lt;/code&gt; で始まるラベル、または &lt;code&gt;Spain&lt;/code&gt; と完全に一致するラベルで終わります。</target>
        </trans-unit>
        <trans-unit id="da0d7e15413e88d505f96b30393006166f82a571" translate="yes" xml:space="preserve">
          <source>and then insert the &lt;code&gt;NOT&lt;/code&gt; key word where desired.</source>
          <target state="translated">次に、必要な場所に &lt;code&gt;NOT&lt;/code&gt; キーワードを挿入します。</target>
        </trans-unit>
        <trans-unit id="f550ff82765c7c77442e312860d5c5a6aa4ec136" translate="yes" xml:space="preserve">
          <source>and then inserts the result (30) as the &lt;code&gt;value&lt;/code&gt; in a new row with &lt;code&gt;class&lt;/code&gt;&lt;code&gt;= 2&lt;/code&gt;. Concurrently, serializable transaction B computes:</source>
          <target state="translated">次に、結果（30）を &lt;code&gt;value&lt;/code&gt; として、 &lt;code&gt;class&lt;/code&gt; &lt;code&gt;= 2&lt;/code&gt; 新しい行に挿入します。同時に、シリアライズ可能なトランザクションBは以下を計算します。</target>
        </trans-unit>
        <trans-unit id="d17266916c8a994f2881eb849993c9875639d0c1" translate="yes" xml:space="preserve">
          <source>and then run pg_upgrade with quoted directories, e.g.:</source>
          <target state="translated">そして、引用符で囲まれたディレクトリを指定してpg_upgradeを実行します。</target>
        </trans-unit>
        <trans-unit id="146d654592d3bdf49836fb607a26abdff8dc565f" translate="yes" xml:space="preserve">
          <source>and these representations for the &amp;ldquo;false&amp;rdquo; state:</source>
          <target state="translated">「偽」状態のこれらの表現：</target>
        </trans-unit>
        <trans-unit id="a5230bf3ac1fc697c044aa12dc9e2fb2c6ea3dcf" translate="yes" xml:space="preserve">
          <source>and:</source>
          <target state="translated">and:</target>
        </trans-unit>
        <trans-unit id="c5fe0200d1c7a5139bd18fd22268c4ca8bf45e90" translate="yes" xml:space="preserve">
          <source>any</source>
          <target state="translated">any</target>
        </trans-unit>
        <trans-unit id="f0d8476cddfcece7be214ceeeb87fed56a99c5be" translate="yes" xml:space="preserve">
          <source>any OID column</source>
          <target state="translated">任意のOID列</target>
        </trans-unit>
        <trans-unit id="776b72d37856a0495e69540bbde0cf0ff74423cc" translate="yes" xml:space="preserve">
          <source>any array type</source>
          <target state="translated">任意の配列型</target>
        </trans-unit>
        <trans-unit id="c8fdfd5cb246da542aaeb9979987b47c98e64395" translate="yes" xml:space="preserve">
          <source>any non-array type</source>
          <target state="translated">任意の非配列型</target>
        </trans-unit>
        <trans-unit id="72433658efe8a2e649ce354eaceeb1954b3d6706" translate="yes" xml:space="preserve">
          <source>any numeric, string, date/time, network, or enum type, or arrays of these types</source>
          <target state="translated">任意の数値、文字列、日付/時刻、ネットワーク、列挙型、またはこれらの型の配列</target>
        </trans-unit>
        <trans-unit id="1d1ab32371b3accbfb7ecab87204e63142da53d2" translate="yes" xml:space="preserve">
          <source>any range type</source>
          <target state="translated">任意範囲型</target>
        </trans-unit>
        <trans-unit id="17b1f448b91caed36d022289e6bc4c20cb8cb1bf" translate="yes" xml:space="preserve">
          <source>any sortable type</source>
          <target state="translated">任意のソート可能型</target>
        </trans-unit>
        <trans-unit id="fc497c9667b2d21c95e0422a7a79489a554110d8" translate="yes" xml:space="preserve">
          <source>append an element to the beginning of an array</source>
          <target state="translated">配列の先頭に要素を追加する</target>
        </trans-unit>
        <trans-unit id="8510099a899e6e19ffcdc41786dd5bee38c2a170" translate="yes" xml:space="preserve">
          <source>append an element to the end of an array</source>
          <target state="translated">配列の末尾に要素を追加する</target>
        </trans-unit>
        <trans-unit id="9a48ebf2c2867a717af59a3d046f96e76db2e70a" translate="yes" xml:space="preserve">
          <source>are also of interest, an additional index could be created that supports the &lt;code&gt;&quot;y&quot;&lt;/code&gt; collation, like this:</source>
          <target state="translated">次のように、 &lt;code&gt;&quot;y&quot;&lt;/code&gt; 照合をサポートする追加のインデックスを作成することもできます。</target>
        </trans-unit>
        <trans-unit id="aa4b0695d2fd6cd9abbff5f407b06b97863d61bd" translate="yes" xml:space="preserve">
          <source>are the addresses from the same family?</source>
          <target state="translated">のアドレスは同系列のものでしょうか?</target>
        </trans-unit>
        <trans-unit id="0ae7b878964a32c5aa151b7336192d99e50b6fa5" translate="yes" xml:space="preserve">
          <source>are valid values, which follow the ISO 8601 standard. In addition, the common format:</source>
          <target state="translated">は、ISO 8601規格に準拠した有効な値です。さらに、共通フォーマット</target>
        </trans-unit>
        <trans-unit id="699e8ae92ca31d0753b1eacb9fbc3f555d78fbd6" translate="yes" xml:space="preserve">
          <source>area</source>
          <target state="translated">area</target>
        </trans-unit>
        <trans-unit id="b572d4fbffd87db31a54fcc4b02fd6c33f9b05c2" translate="yes" xml:space="preserve">
          <source>array concatenation (right array added to the end of left one)</source>
          <target state="translated">配列連結</target>
        </trans-unit>
        <trans-unit id="1f16a17f620eb69917c63399a0983d0af0fc74f5" translate="yes" xml:space="preserve">
          <source>array element selection</source>
          <target state="translated">配列要素選択</target>
        </trans-unit>
        <trans-unit id="195b3de97f0176b7d1d976b97a073f956d949127" translate="yes" xml:space="preserve">
          <source>array of sort expression's type</source>
          <target state="translated">ソート式の型の配列</target>
        </trans-unit>
        <trans-unit id="a9cce9638686dc89b3132c8f4d5d6e72457ed9a4" translate="yes" xml:space="preserve">
          <source>array of the argument type</source>
          <target state="translated">引数型の配列</target>
        </trans-unit>
        <trans-unit id="c368852a549cff62f53f0d0deed89bc97c0d743b" translate="yes" xml:space="preserve">
          <source>array-to-array concatenation</source>
          <target state="translated">配列間連結</target>
        </trans-unit>
        <trans-unit id="f88f7ee63beb76da63ba7e7001aa8cd4317f04f4" translate="yes" xml:space="preserve">
          <source>array-to-element concatenation</source>
          <target state="translated">配列間要素連結</target>
        </trans-unit>
        <trans-unit id="2c4cd6638cd2c3a0b7a8372b993390a30fda1d5e" translate="yes" xml:space="preserve">
          <source>as a more complicated example. Of course, you could wrap all of this in a view for convenience.</source>
          <target state="translated">をもっと複雑な例として挙げてみました。もちろん、便宜的にすべてをビューで包んでもいいのですが。</target>
        </trans-unit>
        <trans-unit id="c3946fc8e2b3dea5bb756fef7515425b6a069b26" translate="yes" xml:space="preserve">
          <source>as above, but the match is not noted for reporting (a &amp;ldquo;non-capturing&amp;rdquo; set of parentheses) (AREs only)</source>
          <target state="translated">上記と同じですが、レポートでは一致は示されません（「非キャプチャ」括弧のセット）（AREのみ）。</target>
        </trans-unit>
        <trans-unit id="44737fbeead1f9bddc0c69fc725d8ac03c45707a" translate="yes" xml:space="preserve">
          <source>as an index-only scan; and this is very attractive if &lt;code&gt;f()&lt;/code&gt; is an expensive-to-compute function. However, PostgreSQL's planner is currently not very smart about such cases. It considers a query to be potentially executable by index-only scan only when all &lt;em&gt;columns&lt;/em&gt; needed by the query are available from the index. In this example, &lt;code&gt;x&lt;/code&gt; is not needed except in the context &lt;code&gt;f(x)&lt;/code&gt;, but the planner does not notice that and concludes that an index-only scan is not possible. If an index-only scan seems sufficiently worthwhile, this can be worked around by adding &lt;code&gt;x&lt;/code&gt; as an included column, for example</source>
          <target state="translated">インデックスのみのスキャンとして。そして、 &lt;code&gt;f()&lt;/code&gt; が計算にコストがかかる関数である場合、これは非常に魅力的です。ただし、PostgreSQLのプランナーは現在、このようなケースについてあまり賢くありません。クエリで必要なすべての&lt;em&gt;列&lt;/em&gt;がインデックスから利用できる場合にのみ、クエリはインデックスのみのスキャンで実行可能であると見なされます。この例では、コンテキスト &lt;code&gt;f(x)&lt;/code&gt; を除いて &lt;code&gt;x&lt;/code&gt; は必要ありませんが、プランナはそれに気づかず、インデックスのみのスキャンは不可能であると結論付けます。インデックスのみのスキャンが十分に価値があると思われる場合は、たとえば、 &lt;code&gt;x&lt;/code&gt; を組み込み列として追加することで回避できます。</target>
        </trans-unit>
        <trans-unit id="8fcfdc695e360dde8446f7425d95888b6550157a" translate="yes" xml:space="preserve">
          <source>as if the query were</source>
          <target state="translated">クエリが</target>
        </trans-unit>
        <trans-unit id="a7261a75560cee1649f6ecc0f31279f94dba2bcf" translate="yes" xml:space="preserve">
          <source>assign &lt;code&gt;weight&lt;/code&gt; to each element of &lt;code&gt;vector&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;vector&lt;/code&gt; 各要素に &lt;code&gt;weight&lt;/code&gt; を割り当てる</target>
        </trans-unit>
        <trans-unit id="5f3de199d97e97e8e060913f33b95d03a4f06c7e" translate="yes" xml:space="preserve">
          <source>assign &lt;code&gt;weight&lt;/code&gt; to elements of &lt;code&gt;vector&lt;/code&gt; that are listed in &lt;code&gt;lexemes&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;lexemes&lt;/code&gt; リストされている &lt;code&gt;vector&lt;/code&gt; 要素に &lt;code&gt;weight&lt;/code&gt; を割り当てる</target>
        </trans-unit>
        <trans-unit id="43ede3444dff3e595fe1c6f01b6c9f4950cb71df" translate="yes" xml:space="preserve">
          <source>at least 1000 (The default is often 32767; do not change unless necessary)</source>
          <target state="translated">少なくとも 1000 (デフォルトは 32767 であることが多いので、必要がない限り変更しないでください)</target>
        </trans-unit>
        <trans-unit id="5439e16ae06517bfbf55405bc08c2e92863bf5ea" translate="yes" xml:space="preserve">
          <source>at least 17</source>
          <target state="translated">少なくても十七</target>
        </trans-unit>
        <trans-unit id="443e099bc3b684e0db01a5fa2add4d3ea2882a4a" translate="yes" xml:space="preserve">
          <source>at least 1kB, but the default is usually much higher</source>
          <target state="translated">最低でも1kBですが、デフォルトではもっと高い値になっています。</target>
        </trans-unit>
        <trans-unit id="b54a445594f650278b14b942cc8d8778f01c797e" translate="yes" xml:space="preserve">
          <source>at least &lt;code&gt;ceil((max_connections + autovacuum_max_workers + max_wal_senders + max_worker_processes + 5) / 16)&lt;/code&gt; plus room for other applications</source>
          <target state="translated">少なくとも &lt;code&gt;ceil((max_connections + autovacuum_max_workers + max_wal_senders + max_worker_processes + 5) / 16)&lt;/code&gt; と他のアプリケーション用のスペース</target>
        </trans-unit>
        <trans-unit id="72b7c9e2eb3bd23a8fd3c8e377b81389e5a528cf" translate="yes" xml:space="preserve">
          <source>auth_delay</source>
          <target state="translated">auth_delay</target>
        </trans-unit>
        <trans-unit id="ad397fd87c3e39210986b3c99c01e01ebcf26995" translate="yes" xml:space="preserve">
          <source>authorization identifier membership relationships</source>
          <target state="translated">承認識別子会員関係</target>
        </trans-unit>
        <trans-unit id="d2896d216ff2416211d2a0e36e3d0a7b13db82ff" translate="yes" xml:space="preserve">
          <source>authorization identifiers (roles)</source>
          <target state="translated">承認識別子</target>
        </trans-unit>
        <trans-unit id="b483ffa7f9b4926c39834e971e056d9afed0e3b7" translate="yes" xml:space="preserve">
          <source>auto_explain</source>
          <target state="translated">auto_explain</target>
        </trans-unit>
        <trans-unit id="3286d9c6ac632aa037945fb31c0e37f0dd633546" translate="yes" xml:space="preserve">
          <source>autoincrementing eight-byte integer</source>
          <target state="translated">じどうインクリメントはちバイト整数</target>
        </trans-unit>
        <trans-unit id="1e4abd38ff5fb04fd9cc6e1989de0864a83533bd" translate="yes" xml:space="preserve">
          <source>autoincrementing four-byte integer</source>
          <target state="translated">自動インクリメント四バイト整数</target>
        </trans-unit>
        <trans-unit id="2162f05f39e1f496096d2494f2a79d5030c2b804" translate="yes" xml:space="preserve">
          <source>autoincrementing integer</source>
          <target state="translated">自動インクリメント整数</target>
        </trans-unit>
        <trans-unit id="954cc0f6e210f639b3c9f9351202ace47d52913a" translate="yes" xml:space="preserve">
          <source>autoincrementing two-byte integer</source>
          <target state="translated">自動インクリメント2バイト整数</target>
        </trans-unit>
        <trans-unit id="8d3a645cd2a324f0617182d92fe36ab22475ce17" translate="yes" xml:space="preserve">
          <source>available extensions</source>
          <target state="translated">利用可能な拡張子</target>
        </trans-unit>
        <trans-unit id="0cc0f41b2e69a6e8bf4387c1a1ce9ef5e7d390b0" translate="yes" xml:space="preserve">
          <source>available versions of extensions</source>
          <target state="translated">利用可能な拡張機能のバージョン</target>
        </trans-unit>
        <trans-unit id="9a6de5e0d48d7fb642bda1b378500dd99c53f1dd" translate="yes" xml:space="preserve">
          <source>average of the dependent variable (&lt;code&gt;sum(Y)/N&lt;/code&gt;)</source>
          <target state="translated">従属変数の平均（ &lt;code&gt;sum(Y)/N&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="f20b015e8a66fb8ce9b0949ef84f41895f7b022b" translate="yes" xml:space="preserve">
          <source>average of the independent variable (&lt;code&gt;sum(X)/N&lt;/code&gt;)</source>
          <target state="translated">独立変数の平均（ &lt;code&gt;sum(X)/N&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="3853072116a861ff4c871d3e96a9cac7da78b7d2" translate="yes" xml:space="preserve">
          <source>backslash</source>
          <target state="translated">backslash</target>
        </trans-unit>
        <trans-unit id="4930eb3f60df3a6a61e8d44178feb2b8f820a153" translate="yes" xml:space="preserve">
          <source>backspace</source>
          <target state="translated">backspace</target>
        </trans-unit>
        <trans-unit id="66cdf1600430f705cc4d8f5e11204829f8383256" translate="yes" xml:space="preserve">
          <source>backspace, as in C</source>
          <target state="translated">のように、バックスペース</target>
        </trans-unit>
        <trans-unit id="7f0d7679eb22f81f891057708c71dfb599a38184" translate="yes" xml:space="preserve">
          <source>base 10 logarithm</source>
          <target state="translated">10基対数</target>
        </trans-unit>
        <trans-unit id="b749c20d2998dde8c54f69e19a74da9a0e84fc42" translate="yes" xml:space="preserve">
          <source>base frequency of this MCV item</source>
          <target state="translated">このMCV項目の基準周波数</target>
        </trans-unit>
        <trans-unit id="8095e159699116466e36cbafd09e1d845f29f2b9" translate="yes" xml:space="preserve">
          <source>base64</source>
          <target state="translated">base64</target>
        </trans-unit>
        <trans-unit id="9965fcf7de748d3c770146162736f22b09a2ffad" translate="yes" xml:space="preserve">
          <source>because &lt;code&gt;postgres&lt;/code&gt; gets stemmed to &lt;code&gt;postgr&lt;/code&gt;:</source>
          <target state="translated">ため &lt;code&gt;postgres&lt;/code&gt; に茎ます &lt;code&gt;postgr&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="af23afc243510d2615878774b81457104ad38f78" translate="yes" xml:space="preserve">
          <source>because a repeatable read transaction cannot modify or lock rows changed by other transactions after the repeatable read transaction began.</source>
          <target state="translated">なぜなら、繰り返し可能な読み取りトランザクションは、繰り返し可能な読み取りトランザクションの開始後に他のトランザクションによって変更された行を変更したり、ロックしたりすることができないからです。</target>
        </trans-unit>
        <trans-unit id="cbcbd26ed5be476f354422d6b658763c38b229f1" translate="yes" xml:space="preserve">
          <source>because in absence of a column list the primary key of the referenced table is used as the referenced column(s).</source>
          <target state="translated">なぜなら、カラムリストがない場合は、参照されるテーブルの主キーが参照されるカラムとして使用されるからです。</target>
        </trans-unit>
        <trans-unit id="2d96d3c2be8f36cf4d125d8a4ee9c4468f5d1613" translate="yes" xml:space="preserve">
          <source>because it attempts to apply a collation to the result of the &lt;code&gt;&amp;gt;&lt;/code&gt; operator, which is of the non-collatable data type &lt;code&gt;boolean&lt;/code&gt;.</source>
          <target state="translated">これは、照合不可能なデータ型 &lt;code&gt;boolean&lt;/code&gt; である &lt;code&gt;&amp;gt;&lt;/code&gt; 演算子の結果に照合を適用しようとするためです。</target>
        </trans-unit>
        <trans-unit id="5d39b947f257995ccfde497491739ecd566455f0" translate="yes" xml:space="preserve">
          <source>because the parser has no idea &amp;mdash; until it is too late &amp;mdash; that &lt;code&gt;!&lt;/code&gt; is defined as a postfix operator, not an infix one. To get the desired behavior in this case, you must write:</source>
          <target state="translated">パーサーは何も知らないからです&amp;mdash;手遅れになるまで&amp;mdash;それは &lt;code&gt;!&lt;/code&gt; は後置演算子ではなく後置演算子として定義されます。この場合に望ましい動作を得るには、次のように記述する必要があります。</target>
        </trans-unit>
        <trans-unit id="dc3a884c6b37262fcaf12532a1f9c235ecbf4b6d" translate="yes" xml:space="preserve">
          <source>because the server will reject the file if its permissions are more liberal than this. For more details on how to create your server private key and certificate, refer to the OpenSSL documentation.</source>
          <target state="translated">これよりも自由なパーミッションであれば、サーバはファイルを拒否してしまうからです。サーバの秘密鍵と証明書の作成方法の詳細については、OpenSSL のドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="bd03a44af506549f106aba97d42f455d1fa7455f" translate="yes" xml:space="preserve">
          <source>begins with the label &lt;code&gt;Top&lt;/code&gt;</source>
          <target state="translated">ラベル &lt;code&gt;Top&lt;/code&gt; で始まる</target>
        </trans-unit>
        <trans-unit id="709634051471385aada32356842983beeff4b065" translate="yes" xml:space="preserve">
          <source>between</source>
          <target state="translated">between</target>
        </trans-unit>
        <trans-unit id="2ec6bc31b898e16ec539ddbd405a5a171a3df210" translate="yes" xml:space="preserve">
          <source>between, after sorting the comparison values</source>
          <target state="translated">の間で、比較値をソートした後</target>
        </trans-unit>
        <trans-unit id="5f9c9d32d71f1ef8b8014c350a5f8aec50c577ec" translate="yes" xml:space="preserve">
          <source>bigint</source>
          <target state="translated">bigint</target>
        </trans-unit>
        <trans-unit id="77277e00630649e46e2738e754d21819c7bc1bf5" translate="yes" xml:space="preserve">
          <source>bigserial</source>
          <target state="translated">bigserial</target>
        </trans-unit>
        <trans-unit id="e52bf437dfb9f0dadee4cb21fac3d9c8ada93bb1" translate="yes" xml:space="preserve">
          <source>binary JSON data, decomposed</source>
          <target state="translated">バイナリ JSON データ、分解された</target>
        </trans-unit>
        <trans-unit id="02ab455c076e6f4b354b1446757e9a4b0a79445f" translate="yes" xml:space="preserve">
          <source>binary data (&amp;ldquo;byte array&amp;rdquo;)</source>
          <target state="translated">バイナリデータ（「バイト配列」）</target>
        </trans-unit>
        <trans-unit id="892a67172f0a564c168e95647e62558366e70470" translate="yes" xml:space="preserve">
          <source>bit varying</source>
          <target state="translated">ビット変動</target>
        </trans-unit>
        <trans-unit id="4ba5b46e332d373dfdfa248036598eb70f831d32" translate="yes" xml:space="preserve">
          <source>bitwise AND</source>
          <target state="translated">ビットアンド</target>
        </trans-unit>
        <trans-unit id="898900a45561d4f119a2ed52510f1ace0fda7e60" translate="yes" xml:space="preserve">
          <source>bitwise NOT</source>
          <target state="translated">ビットひてい</target>
        </trans-unit>
        <trans-unit id="7d5bb4d1e43ddd2b7554d5d7d0b44fa8e15c9b68" translate="yes" xml:space="preserve">
          <source>bitwise OR</source>
          <target state="translated">ビット論理和</target>
        </trans-unit>
        <trans-unit id="8f0757e0ba4c22c9e209a79597f6b1dc188081e0" translate="yes" xml:space="preserve">
          <source>bitwise XOR</source>
          <target state="translated">ビット単位XOR</target>
        </trans-unit>
        <trans-unit id="e8be396aab93c1fef2fc7e54326638d41fd49ba3" translate="yes" xml:space="preserve">
          <source>bitwise shift left</source>
          <target state="translated">ビットシフト左</target>
        </trans-unit>
        <trans-unit id="ee3a57994d0683b1945f1e65426a85e401e290c1" translate="yes" xml:space="preserve">
          <source>bitwise shift right</source>
          <target state="translated">ビットシフト右</target>
        </trans-unit>
        <trans-unit id="5812e2b7356193b66b6555bd2fa41ed3da124f67" translate="yes" xml:space="preserve">
          <source>bloom</source>
          <target state="translated">bloom</target>
        </trans-unit>
        <trans-unit id="48647474b89fa8f56ed6bda0f8148a17b51b97bd" translate="yes" xml:space="preserve">
          <source>boolean</source>
          <target state="translated">boolean</target>
        </trans-unit>
        <trans-unit id="65fc5cc5f306627f2ee258292e0df90691c67af1" translate="yes" xml:space="preserve">
          <source>both date and time (no time zone)</source>
          <target state="translated">両日</target>
        </trans-unit>
        <trans-unit id="a27279f9f262e5ba8cd291de1630ce7357a275c8" translate="yes" xml:space="preserve">
          <source>both date and time, with time zone</source>
          <target state="translated">日付と時間の両方、タイムゾーンを含む</target>
        </trans-unit>
        <trans-unit id="33ca9adbe02fe4b2c1b14995a225396cc073c647" translate="yes" xml:space="preserve">
          <source>both of which sort by the first output column. Note that an output column name has to stand alone, that is, it cannot be used in an expression &amp;mdash; for example, this is &lt;em&gt;not&lt;/em&gt; correct:</source>
          <target state="translated">どちらも最初の出力列でソートされます。出力列名はスタンドアロンでなければならないことに注意してください。つまり、式で使用することはできません。たとえば、これは正しくあり&lt;em&gt;ません&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="8cde009a0af187221e6f6dd025a6cf362c599c99" translate="yes" xml:space="preserve">
          <source>box diagonal to line segment</source>
          <target state="translated">線分に対する箱の対角線</target>
        </trans-unit>
        <trans-unit id="6f5d0d15c57b74089e23ebb9522965d12a29230c" translate="yes" xml:space="preserve">
          <source>box to 4-point polygon</source>
          <target state="translated">ボックスから4点多角形へ</target>
        </trans-unit>
        <trans-unit id="96b6dbd46e1f666fe3c50b034ebe2000e41de085" translate="yes" xml:space="preserve">
          <source>box to circle</source>
          <target state="translated">円箱</target>
        </trans-unit>
        <trans-unit id="1ca211a26e16f8cade4a85971d5852f1c33fff52" translate="yes" xml:space="preserve">
          <source>boxes to bounding box</source>
          <target state="translated">ボックスからバウンディングボックスへ</target>
        </trans-unit>
        <trans-unit id="7e65a745a42ef9c805310b0bccb5bfa33fa4d8e9" translate="yes" xml:space="preserve">
          <source>broadcast address for network</source>
          <target state="translated">ネットワークブロードキャストアドレス</target>
        </trans-unit>
        <trans-unit id="7e429fb710b1bd41375b836cf8242f042f2393a6" translate="yes" xml:space="preserve">
          <source>btree_gin</source>
          <target state="translated">btree_gin</target>
        </trans-unit>
        <trans-unit id="d4fc5c2b17c1dc2564aad5782a24ec87dbb33485" translate="yes" xml:space="preserve">
          <source>btree_gist</source>
          <target state="translated">btree_gist</target>
        </trans-unit>
        <trans-unit id="59d8e37e115d9900867db7d20d223db479f6ea75" translate="yes" xml:space="preserve">
          <source>build an &lt;code&gt;aclitem&lt;/code&gt; from input</source>
          <target state="translated">入力から &lt;code&gt;aclitem&lt;/code&gt; を構築する</target>
        </trans-unit>
        <trans-unit id="0c70d21c53edbb94215b7aa66f5ea7d3aa0b789c" translate="yes" xml:space="preserve">
          <source>built-in logical repl., pglogical</source>
          <target state="translated">内蔵論理補充、pglogical</target>
        </trans-unit>
        <trans-unit id="6310070850ba6f8f16435b6767ef6e3d84d1b51c" translate="yes" xml:space="preserve">
          <source>built-in logical replication, pglogical</source>
          <target state="translated">組み込みの論理レプリケーション、pglogical</target>
        </trans-unit>
        <trans-unit id="0a4f60411d00d9bc19c78893536c661c6bb4cbb3" translate="yes" xml:space="preserve">
          <source>built-in streaming repl.</source>
          <target state="translated">ビルトインストリーミングレプリ</target>
        </trans-unit>
        <trans-unit id="0b8c9efbbdae1b8096b4be992666e1f2306047c9" translate="yes" xml:space="preserve">
          <source>built-in streaming replication</source>
          <target state="translated">ビルトインストリーミングレプリケーション</target>
        </trans-unit>
        <trans-unit id="d9b843a298d5353ed2a7fe506917dc36463cf904" translate="yes" xml:space="preserve">
          <source>but not all type names can be used in this way; see &lt;a href=&quot;sql-expressions#SQL-SYNTAX-TYPE-CASTS&quot;&gt;Section 4.2.9&lt;/a&gt; for details.</source>
          <target state="translated">ただし、すべての型名をこのように使用できるわけではありません。詳細については、&lt;a href=&quot;sql-expressions#SQL-SYNTAX-TYPE-CASTS&quot;&gt;セクション4.2.9&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="f09f88b6f29fee99798bea8929b062956fb7df58" translate="yes" xml:space="preserve">
          <source>but real-world usage will involve including it in a text search configuration as described in &lt;a href=&quot;https://www.postgresql.org/docs/12/textsearch.html&quot;&gt;Chapter 12&lt;/a&gt;. That might look like this:</source>
          <target state="translated">ただし、実際の使用方法では、&lt;a href=&quot;https://www.postgresql.org/docs/12/textsearch.html&quot;&gt;第12章で&lt;/a&gt;説明するように、テキスト検索構成に含める必要があります。次のようになります。</target>
        </trans-unit>
        <trans-unit id="931bb3d7295a22ba60e407c439a2751b6a2e54c6" translate="yes" xml:space="preserve">
          <source>but real-world usage will involve including it in a text search configuration as described in &lt;a href=&quot;https://www.postgresql.org/docs/13/textsearch.html&quot;&gt;Chapter 12&lt;/a&gt;. That might look like this:</source>
          <target state="translated">ただし、実際の使用法では、&lt;a href=&quot;https://www.postgresql.org/docs/13/textsearch.html&quot;&gt;第12章で&lt;/a&gt;説明されているようにテキスト検索構成に含める必要があります。これは次のようになります。</target>
        </trans-unit>
        <trans-unit id="47b8dd0ef1d9374c938682dcc12763e6b91b0511" translate="yes" xml:space="preserve">
          <source>but that approach is less flexible, and often less efficient as well.</source>
          <target state="translated">しかし、そのアプローチは柔軟性が低く、効率的ではないことが多いです。</target>
        </trans-unit>
        <trans-unit id="777c2dee3f742dec7bfd8f0986b9928f96755335" translate="yes" xml:space="preserve">
          <source>but then the database server will see the connection as coming in on its &lt;code&gt;foo.com&lt;/code&gt; bind address, which is not opened by the default setting &lt;code&gt;listen_addresses = 'localhost'&lt;/code&gt;. This is usually not what you want.</source>
          <target state="translated">ただし、データベースサーバーは、接続が &lt;code&gt;foo.com&lt;/code&gt; バインドアドレスで着信していると見なします。このバインドアドレスは、デフォルト設定の &lt;code&gt;listen_addresses = 'localhost'&lt;/code&gt; 開かれていません。これは通常あなたが望むものではありません。</target>
        </trans-unit>
        <trans-unit id="ee2c835e71e434c69308497a09a58270d6b3eddb" translate="yes" xml:space="preserve">
          <source>but then the database server will see the connection as coming in on its &lt;code&gt;foo.com&lt;/code&gt; interface, which is not opened by the default setting &lt;code&gt;listen_addresses = 'localhost'&lt;/code&gt;. This is usually not what you want.</source>
          <target state="translated">ただし、データベースサーバーは、接続が &lt;code&gt;foo.com&lt;/code&gt; インターフェースで受信されていると認識します。これは、デフォルト設定の &lt;code&gt;listen_addresses = 'localhost'&lt;/code&gt; 開かれません。これは通常、あなたが望むものではありません。</target>
        </trans-unit>
        <trans-unit id="254eff7ff12131042b7e5d6791570b4b68f6d612" translate="yes" xml:space="preserve">
          <source>but these queries could not:</source>
          <target state="translated">が、これらのクエリではできませんでした。</target>
        </trans-unit>
        <trans-unit id="f051e659481b1bdec5c2a7ae3f0ba578a9c5a900" translate="yes" xml:space="preserve">
          <source>but this does:</source>
          <target state="translated">しかし、これはそうです。</target>
        </trans-unit>
        <trans-unit id="0b6affe425ac3cac0ecdcc4b798bd2ce34e6c9ad" translate="yes" xml:space="preserve">
          <source>but this will not work since the aggregate &lt;code&gt;max&lt;/code&gt; cannot be used in the &lt;code&gt;WHERE&lt;/code&gt; clause. (This restriction exists because the &lt;code&gt;WHERE&lt;/code&gt; clause determines which rows will be included in the aggregate calculation; so obviously it has to be evaluated before aggregate functions are computed.) However, as is often the case the query can be restated to accomplish the desired result, here by using a &lt;em&gt;subquery&lt;/em&gt;:</source>
          <target state="translated">ただし、集計 &lt;code&gt;max&lt;/code&gt; は &lt;code&gt;WHERE&lt;/code&gt; 句で使用できないため、これは機能しません。（この制限が存在するのは、 &lt;code&gt;WHERE&lt;/code&gt; 句が集計計算に含める行を決定するためです。したがって、集計関数が計算される前に評価する必要があるのは明らかです。）ただし、よくあることですが、目的の結果を達成するためにクエリを再表現することができます。 、ここでは&lt;em&gt;サブクエリ&lt;/em&gt;を使用して：</target>
        </trans-unit>
        <trans-unit id="b94da3599274cc93c9ee4f4d4dce4fea875b2503" translate="yes" xml:space="preserve">
          <source>but:</source>
          <target state="translated">but:</target>
        </trans-unit>
        <trans-unit id="ca4a2057bd9e261b071397023cf198c3db0688ef" translate="yes" xml:space="preserve">
          <source>calendar date (year, month, day)</source>
          <target state="translated">暦日</target>
        </trans-unit>
        <trans-unit id="3f5ae5c8becacd92f5b89cba285014d49fe90e2c" translate="yes" xml:space="preserve">
          <source>can also be used.</source>
          <target state="translated">を使用することもできます。</target>
        </trans-unit>
        <trans-unit id="4a9f2d676dd4658059a5f07359111b9cc42edcba" translate="yes" xml:space="preserve">
          <source>can be increased by recompiling PostgreSQL</source>
          <target state="translated">は、PostgreSQLを再コンパイルすることで増加させることができます。</target>
        </trans-unit>
        <trans-unit id="07b307ab5d0c778628385e3d5dbb950c4bbe7a5d" translate="yes" xml:space="preserve">
          <source>can be used too, but at present this is just for &lt;em&gt;pro forma&lt;/em&gt; compliance with the SQL standard. If you write a database name, it must be the same as the database you are connected to.</source>
          <target state="translated">も使用できますが、現時点では、これはSQL標準への&lt;em&gt;プロフォーマ&lt;/em&gt;準拠のためのものです。データベース名を書き込む場合は、接続先のデータベースと同じでなければなりません。</target>
        </trans-unit>
        <trans-unit id="45514644f4621795d582e24c02cb7cf058d26351" translate="yes" xml:space="preserve">
          <source>can equivalently be written as:</source>
          <target state="translated">等価的には次のように書くことができます。</target>
        </trans-unit>
        <trans-unit id="6e9f192b79a14968d26f70ab1aa8e21b65e3df64" translate="yes" xml:space="preserve">
          <source>carriage return</source>
          <target state="translated">キャリッジリターン</target>
        </trans-unit>
        <trans-unit id="def334c5877ea4f63b5575fa4cc2f60305278d07" translate="yes" xml:space="preserve">
          <source>carriage return, as in C</source>
          <target state="translated">キャリッジリターン</target>
        </trans-unit>
        <trans-unit id="f99b34b4fa1fea2ca07ad8897d13ba6b1206cc37" translate="yes" xml:space="preserve">
          <source>case-insensitive matching (see &lt;a href=&quot;functions-matching#POSIX-MATCHING-RULES&quot;&gt;Section 9.7.3.5&lt;/a&gt;) (overrides operator type)</source>
          <target state="translated">大文字と小文字を区別しないマッチング（&lt;a href=&quot;functions-matching#POSIX-MATCHING-RULES&quot;&gt;セクション9.7.3.5を&lt;/a&gt;参照）（演算子タイプをオーバーライドします）</target>
        </trans-unit>
        <trans-unit id="3e82d968dc00f833dad374e757a334e4a040c90c" translate="yes" xml:space="preserve">
          <source>case-sensitive matching (overrides operator type)</source>
          <target state="translated">大文字小文字を区別する一致</target>
        </trans-unit>
        <trans-unit id="5bf41021d1e013cdbe5336b032060b46fb810232" translate="yes" xml:space="preserve">
          <source>cast &lt;code&gt;ltree&lt;/code&gt; to &lt;code&gt;text&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ltree&lt;/code&gt; を &lt;code&gt;text&lt;/code&gt; キャストする</target>
        </trans-unit>
        <trans-unit id="ed1123013c2bd604bb0d461547480f74dc473e37" translate="yes" xml:space="preserve">
          <source>cast &lt;code&gt;text&lt;/code&gt; to &lt;code&gt;ltree&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ltree&lt;/code&gt; に &lt;code&gt;text&lt;/code&gt; をキャストする</target>
        </trans-unit>
        <trans-unit id="a283f70188863d91855937695daa6c350cfcf558" translate="yes" xml:space="preserve">
          <source>cast to double</source>
          <target state="translated">打ち込む</target>
        </trans-unit>
        <trans-unit id="34472e7f0cad05f2b2dd139e2a7581cfa2e2f29a" translate="yes" xml:space="preserve">
          <source>cast to int</source>
          <target state="translated">ちゅうすうにキャスト</target>
        </trans-unit>
        <trans-unit id="542ab67ef49ce56f684a8718e87598af02f5d74b" translate="yes" xml:space="preserve">
          <source>casts (data type conversions)</source>
          <target state="translated">キャスト(データ型変換</target>
        </trans-unit>
        <trans-unit id="305047e96ec089021660ee5965f893ac80268731" translate="yes" xml:space="preserve">
          <source>center</source>
          <target state="translated">center</target>
        </trans-unit>
        <trans-unit id="1c324c54487e53c22fd01ca907a0c848c8a583d9" translate="yes" xml:space="preserve">
          <source>center and radius to circle</source>
          <target state="translated">円への中心半径</target>
        </trans-unit>
        <trans-unit id="81a86dca1152d33417863c0f5f4e6cf2b16480a6" translate="yes" xml:space="preserve">
          <source>center of box</source>
          <target state="translated">箱の中心</target>
        </trans-unit>
        <trans-unit id="2ec0ff924735c49e81d70e8e2c7d6dfe9d7d60bc" translate="yes" xml:space="preserve">
          <source>center of circle</source>
          <target state="translated">えんしん</target>
        </trans-unit>
        <trans-unit id="525b6f618cb47140c2374dbe02a53765c3c85c24" translate="yes" xml:space="preserve">
          <source>center of line segment</source>
          <target state="translated">線分の中心</target>
        </trans-unit>
        <trans-unit id="33d628e71b8e6a1a2c384ae970e47570fc0b9a61" translate="yes" xml:space="preserve">
          <source>center of polygon</source>
          <target state="translated">多角形の中心</target>
        </trans-unit>
        <trans-unit id="21957663c4fb58419a0c98a3724294cbfdbf1a7f" translate="yes" xml:space="preserve">
          <source>century (2 digits) (the twenty-first century starts on 2001-01-01)</source>
          <target state="translated">世紀</target>
        </trans-unit>
        <trans-unit id="370ecf2ad70a13142bf3174e9abe256169452bd0" translate="yes" xml:space="preserve">
          <source>certificates revoked by certificate authorities</source>
          <target state="translated">しょうめいしょうきょしょうめいしょ</target>
        </trans-unit>
        <trans-unit id="932784433f85ba8abc6f12c517aaf96068258f16" translate="yes" xml:space="preserve">
          <source>channel names that the session is currently listening on</source>
          <target state="translated">セッションが現在聞いているチャンネル名</target>
        </trans-unit>
        <trans-unit id="f0db3fa401aea04b711d6f1f3630552eaaee8e59" translate="yes" xml:space="preserve">
          <source>character</source>
          <target state="translated">character</target>
        </trans-unit>
        <trans-unit id="d0eb7b3b4e386ffe76f12fc6f7502ffde2a5b1ca" translate="yes" xml:space="preserve">
          <source>character varying</source>
          <target state="translated">性格変化</target>
        </trans-unit>
        <trans-unit id="eea64a15c7c41d6cf7da5318bba35b0dfa86b13f" translate="yes" xml:space="preserve">
          <source>check clusters only, don't change any data</source>
          <target state="translated">クラスタのみをチェックし、データを変更しない</target>
        </trans-unit>
        <trans-unit id="a29a96de4ab639d87155b423113f741d6b399fca" translate="yes" xml:space="preserve">
          <source>check constraints, unique constraints, primary key constraints, foreign key constraints</source>
          <target state="translated">チェック制約、一意制約、主キー制約、外部キー制約</target>
        </trans-unit>
        <trans-unit id="4b91f9d8b975eee622772ea62a86896ef4ef61ce" translate="yes" xml:space="preserve">
          <source>checks that client certificate is signed by a trusted certificate authority</source>
          <target state="translated">クライアント証明書が信頼できる証明書局によって署名されていることを確認します。</target>
        </trans-unit>
        <trans-unit id="00b7b8118efde44c546b69243ec15b21cd64c9d9" translate="yes" xml:space="preserve">
          <source>circle</source>
          <target state="translated">circle</target>
        </trans-unit>
        <trans-unit id="bfac9bc25b5fb8f2fa83ccb26e83e30c35a3a06c" translate="yes" xml:space="preserve">
          <source>circle on a plane</source>
          <target state="translated">平面上の円</target>
        </trans-unit>
        <trans-unit id="fe2bd0ef7b1249d0169c74005f37ca2fd5a93734" translate="yes" xml:space="preserve">
          <source>circle to 12-point polygon</source>
          <target state="translated">円から12点多角形</target>
        </trans-unit>
        <trans-unit id="ddf50c7158a693b8ba86924c5d88bec2f50e83aa" translate="yes" xml:space="preserve">
          <source>circle to &lt;code&gt;npts&lt;/code&gt;-point polygon</source>
          <target state="translated">円から &lt;code&gt;npts&lt;/code&gt; ポイントのポリゴン</target>
        </trans-unit>
        <trans-unit id="ad3b153d9429c109e68ce6ced77c4260d4c34577" translate="yes" xml:space="preserve">
          <source>circle to box</source>
          <target state="translated">円から箱へ</target>
        </trans-unit>
        <trans-unit id="e241ce9d9ce43d18211ad61727ab59139118a131" translate="yes" xml:space="preserve">
          <source>citext</source>
          <target state="translated">citext</target>
        </trans-unit>
        <trans-unit id="751266a7fa555fd650fe60f7bd15324008f60eaf" translate="yes" xml:space="preserve">
          <source>client certificate must not be on this list</source>
          <target state="translated">クライアント証明書をこのリストに入れてはいけません。</target>
        </trans-unit>
        <trans-unit id="12c22af93332ba93d2c7d1b12c8c3a6239448f8b" translate="yes" xml:space="preserve">
          <source>client character set representation</source>
          <target state="translated">クライアント文字集合表現</target>
        </trans-unit>
        <trans-unit id="fe3b3f96eb8a29aa95ee6742e5391daa5a853668" translate="yes" xml:space="preserve">
          <source>closed geometric path on a plane</source>
          <target state="translated">平面上の閉じた幾何学的経路</target>
        </trans-unit>
        <trans-unit id="9d2a05384389e39e55a9fb33419864a52dc20579" translate="yes" xml:space="preserve">
          <source>cluster's install user name; environment variable &lt;code&gt;PGUSER&lt;/code&gt;</source>
          <target state="translated">クラスタのインストールユーザー名。環境変数 &lt;code&gt;PGUSER&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="39f2375a466659e991122be876571fa32e1c3224" translate="yes" xml:space="preserve">
          <source>clusterdb</source>
          <target state="translated">clusterdb</target>
        </trans-unit>
        <trans-unit id="823fd4756652ecc890aa45a56776dffb0e59f612" translate="yes" xml:space="preserve">
          <source>clusterdb &amp;mdash; cluster a PostgreSQL database</source>
          <target state="translated">clusterdb &amp;mdash; PostgreSQLデータベースをクラスター化する</target>
        </trans-unit>
        <trans-unit id="d5bb141c39226c781b730bc7a91ab0f06285e4f0" translate="yes" xml:space="preserve">
          <source>clusterdb accepts the following command-line arguments:</source>
          <target state="translated">clusterdbは以下のコマンドライン引数を受け付けます。</target>
        </trans-unit>
        <trans-unit id="cf3ac3c5cfb26bd0e1f0c4ae38487d9d7c314d08" translate="yes" xml:space="preserve">
          <source>clusterdb also accepts the following command-line arguments for connection parameters:</source>
          <target state="translated">clusterdb は接続パラメータとして以下のコマンドライン引数も受け付けます。</target>
        </trans-unit>
        <trans-unit id="e2fe317f2e4ea451e21fc774dc0d79619e64edfd" translate="yes" xml:space="preserve">
          <source>clusterdb is a utility for reclustering tables in a PostgreSQL database. It finds tables that have previously been clustered, and clusters them again on the same index that was last used. Tables that have never been clustered are not affected.</source>
          <target state="translated">clusterdbはPostgreSQLデータベース内のテーブルを再クラスタ化するためのユーティリティです。以前にクラスタ化されたテーブルを見つけ、最後に使用されたのと同じインデックスで再度クラスタ化します。クラスタ化されたことのないテーブルは影響を受けません。</target>
        </trans-unit>
        <trans-unit id="fd2735ad5e6a19ac7e1140a224c1c24a97fc9e17" translate="yes" xml:space="preserve">
          <source>clusterdb is a wrapper around the SQL command &lt;a href=&quot;sql-cluster&quot;&gt;CLUSTER&lt;/a&gt;. There is no effective difference between clustering databases via this utility and via other methods for accessing the server.</source>
          <target state="translated">clusterdbは、SQLコマンド&lt;a href=&quot;sql-cluster&quot;&gt;CLUSTERの&lt;/a&gt;ラッパーです。このユーティリティとサーバーにアクセスするための他の方法によるデータベースのクラスタリングの間に効果的な違いはありません。</target>
        </trans-unit>
        <trans-unit id="1f1784fa738e6d5473ab5f43d736a5f44fb259b0" translate="yes" xml:space="preserve">
          <source>collation name</source>
          <target state="translated">照合名</target>
        </trans-unit>
        <trans-unit id="bea494244f54b23f44820cb069f810bb4eca7c7b" translate="yes" xml:space="preserve">
          <source>collations (locale information)</source>
          <target state="translated">スナック</target>
        </trans-unit>
        <trans-unit id="f6e81a8e1f0b533eb70f9ceeb98b3f99d57e7764" translate="yes" xml:space="preserve">
          <source>column default values</source>
          <target state="translated">列のデフォルト値</target>
        </trans-unit>
        <trans-unit id="fe7f2cdd0d102e4f8a30abbef55f21da4b2ba7d9" translate="yes" xml:space="preserve">
          <source>columns per index</source>
          <target state="translated">インデックスあたりの列</target>
        </trans-unit>
        <trans-unit id="ff07f44a4127edb55f44386b09eae02d54daca39" translate="yes" xml:space="preserve">
          <source>columns per table</source>
          <target state="translated">テーブルあたりの列</target>
        </trans-unit>
        <trans-unit id="f34c9877f2bf68c0333fc87b9e95a52bc11e5b67" translate="yes" xml:space="preserve">
          <source>comments on shared objects</source>
          <target state="translated">共有オブジェクトに対するコメント</target>
        </trans-unit>
        <trans-unit id="7b66eba0b67c3b9e73cc97b3d1b94a251d742d90" translate="yes" xml:space="preserve">
          <source>comparison operators</source>
          <target state="translated">比較演算子</target>
        </trans-unit>
        <trans-unit id="8154454006381d49284649c66b2403f81afb118d" translate="yes" xml:space="preserve">
          <source>compile-time configuration parameters</source>
          <target state="translated">コンパイル時設定パラメータ</target>
        </trans-unit>
        <trans-unit id="55a34178d77f1c51b211c756f759f8cf161a23d4" translate="yes" xml:space="preserve">
          <source>concatenate &lt;code&gt;hstore&lt;/code&gt;s</source>
          <target state="translated">CONCATENATE &lt;code&gt;hstore&lt;/code&gt; の S</target>
        </trans-unit>
        <trans-unit id="8e1ad14ad4374d48d20d7479ab315932269fbff4" translate="yes" xml:space="preserve">
          <source>concatenate &lt;code&gt;ltree&lt;/code&gt; paths</source>
          <target state="translated">&lt;code&gt;ltree&lt;/code&gt; パスを連結する</target>
        </trans-unit>
        <trans-unit id="29b58ef42868498f9fead6297c0c68588c926edf" translate="yes" xml:space="preserve">
          <source>concatenate &lt;code&gt;tsvector&lt;/code&gt;s</source>
          <target state="translated">CONCATENATE &lt;code&gt;tsvector&lt;/code&gt; 秒</target>
        </trans-unit>
        <trans-unit id="2c4447d1d44ee3c074941b8c08ca342d23d066f6" translate="yes" xml:space="preserve">
          <source>concatenate two arrays</source>
          <target state="translated">つなぎ合わせる</target>
        </trans-unit>
        <trans-unit id="22d0551615cf0d8546cc1c9c81d271b5e72e2fda" translate="yes" xml:space="preserve">
          <source>concatenates array elements using supplied delimiter and optional null string</source>
          <target state="translated">指定された区切り文字とオプションのヌル文字列を用いて配列の要素を連結します。</target>
        </trans-unit>
        <trans-unit id="5c93b563298b75fc6d2f4fcfedc5ca6dd370b747" translate="yes" xml:space="preserve">
          <source>concatenation</source>
          <target state="translated">concatenation</target>
        </trans-unit>
        <trans-unit id="5fff9a64a91f5155fd20f1f5322675919eba1779" translate="yes" xml:space="preserve">
          <source>concatenation of non-null XML values (see also &lt;a href=&quot;functions-xml#FUNCTIONS-XML-XMLAGG&quot;&gt;Section 9.14.1.7&lt;/a&gt;)</source>
          <target state="translated">null以外のXML値の連結（&lt;a href=&quot;functions-xml#FUNCTIONS-XML-XMLAGG&quot;&gt;セクション9.14.1.7&lt;/a&gt;も参照）</target>
        </trans-unit>
        <trans-unit id="cab21417f26804f2821e9cba7ec02b3d22bb0dcb" translate="yes" xml:space="preserve">
          <source>condition that has a format similar to the format of regular expressions.</source>
          <target state="translated">条件は、正規表現のフォーマットに似たフォーマットを持つものです。</target>
        </trans-unit>
        <trans-unit id="bdd9e092f915a4d94a6a2f20a48a3e86b741db40" translate="yes" xml:space="preserve">
          <source>configuration load time</source>
          <target state="translated">構成負荷時間</target>
        </trans-unit>
        <trans-unit id="d1fa507954b44038b5d98dbdafb2b36374cc6386" translate="yes" xml:space="preserve">
          <source>constrained by maximum relations per database</source>
          <target state="translated">データベースごとの最大関係に制約される</target>
        </trans-unit>
        <trans-unit id="242491a8bd7940610b5e65d571dcdb5c72e647a2" translate="yes" xml:space="preserve">
          <source>construct an &lt;code&gt;hstore&lt;/code&gt; from a record or row</source>
          <target state="translated">レコードまたは行から &lt;code&gt;hstore&lt;/code&gt; を構築します</target>
        </trans-unit>
        <trans-unit id="c929167cb94b880f0746653e53959fc18c0bf793" translate="yes" xml:space="preserve">
          <source>construct an &lt;code&gt;hstore&lt;/code&gt; from an array, which may be either a key/value array, or a two-dimensional array</source>
          <target state="translated">キー/値配列または2次元配列のいずれかである配列から &lt;code&gt;hstore&lt;/code&gt; を構築します</target>
        </trans-unit>
        <trans-unit id="bbd40f04098912d0ba742a8bc5af223e27c7adda" translate="yes" xml:space="preserve">
          <source>construct an &lt;code&gt;hstore&lt;/code&gt; from separate key and value arrays</source>
          <target state="translated">個別のキーと値の配列から &lt;code&gt;hstore&lt;/code&gt; を構築します</target>
        </trans-unit>
        <trans-unit id="3cc74499a516b13f15e51d5c826818942c36a609" translate="yes" xml:space="preserve">
          <source>construct host mask for network</source>
          <target state="translated">ネットワーク用のホストマスクを構築する</target>
        </trans-unit>
        <trans-unit id="b01b9cfc44c043d7e34a6cc2f5c24aa8c879193c" translate="yes" xml:space="preserve">
          <source>construct netmask for network</source>
          <target state="translated">ネットワーク用ネットマスクを構築する</target>
        </trans-unit>
        <trans-unit id="14dd4fbbe8eed4db88e77a3d9dee637dfc2d10c4" translate="yes" xml:space="preserve">
          <source>construct point</source>
          <target state="translated">構成点</target>
        </trans-unit>
        <trans-unit id="b75f26d172a89e83c2261d72cb9d9e1b5ef7769c" translate="yes" xml:space="preserve">
          <source>contained &amp;mdash; &lt;code&gt;true&lt;/code&gt; if left array is contained in right array</source>
          <target state="translated">contains &amp;mdash; 左の配列が右の配列に含まれている場合は &lt;code&gt;true&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="caeb909ae4ff4ee25a0ff0d476946ed256f2aee1" translate="yes" xml:space="preserve">
          <source>contains</source>
          <target state="translated">contains</target>
        </trans-unit>
        <trans-unit id="0957a97cac9a10ebe40f435c740cc3345b2efc3f" translate="yes" xml:space="preserve">
          <source>contains &amp;mdash; &lt;code&gt;true&lt;/code&gt; if left array contains right array</source>
          <target state="translated">contains &amp;mdash; 左の配列に右の配列が含まれる場合は &lt;code&gt;true&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="007f7efed9b7619cf2555d2be05833ff839d3962" translate="yes" xml:space="preserve">
          <source>contains element</source>
          <target state="translated">含み要素</target>
        </trans-unit>
        <trans-unit id="e74dd6ca81a7e2eecc18f2ec9e65ec0ea5be7ef4" translate="yes" xml:space="preserve">
          <source>contains or equals</source>
          <target state="translated">含む</target>
        </trans-unit>
        <trans-unit id="ce904d2429dea4c4cd6a0c965103aaf0e346da09" translate="yes" xml:space="preserve">
          <source>contains or is contained by</source>
          <target state="translated">含む</target>
        </trans-unit>
        <trans-unit id="e75b7119f1d5d414ff82917ba2603bf9e5b45df6" translate="yes" xml:space="preserve">
          <source>contains range</source>
          <target state="translated">含む範囲</target>
        </trans-unit>
        <trans-unit id="19f826ba869b2fee68bf1f114b8e677ae0c0d856" translate="yes" xml:space="preserve">
          <source>continuous percentile: returns a value corresponding to the specified fraction in the ordering, interpolating between adjacent input items if needed</source>
          <target state="translated">連続パーセンタイル:必要に応じて隣接する入力項目間を補間し、指定された分数に対応する値を返します。</target>
        </trans-unit>
        <trans-unit id="36c18c788db3f3304d051679f1b40f05f59e4471" translate="yes" xml:space="preserve">
          <source>convert &lt;code&gt;hstore&lt;/code&gt; to array of alternating keys and values</source>
          <target state="translated">&lt;code&gt;hstore&lt;/code&gt; を交互のキーと値の配列に変換します</target>
        </trans-unit>
        <trans-unit id="a10418c81af1657f4831a46624d04836bc50be5c" translate="yes" xml:space="preserve">
          <source>convert &lt;code&gt;hstore&lt;/code&gt; to two-dimensional key/value array</source>
          <target state="translated">&lt;code&gt;hstore&lt;/code&gt; を2次元のキー/値配列に変換します</target>
        </trans-unit>
        <trans-unit id="602cf0e08612bf183b6a1d481640a135b45b733b" translate="yes" xml:space="preserve">
          <source>convert &lt;code&gt;tsvector&lt;/code&gt; to array of lexemes</source>
          <target state="translated">&lt;code&gt;tsvector&lt;/code&gt; を語彙素の配列に変換する</target>
        </trans-unit>
        <trans-unit id="6d582c6dfa728d8842a0e41ff985c05950fcac9e" translate="yes" xml:space="preserve">
          <source>convert array of lexemes to &lt;code&gt;tsvector&lt;/code&gt;</source>
          <target state="translated">語彙素の配列を &lt;code&gt;tsvector&lt;/code&gt; に変換する</target>
        </trans-unit>
        <trans-unit id="042e1227ee9efe77eb7cf25e971dd091316797bb" translate="yes" xml:space="preserve">
          <source>convert integer to string</source>
          <target state="translated">整数を文字列に変換する</target>
        </trans-unit>
        <trans-unit id="8883e03ee79e5b7ca0bcc6c68d4b71517843c875" translate="yes" xml:space="preserve">
          <source>convert interval to string</source>
          <target state="translated">間隔を文字列に変換する</target>
        </trans-unit>
        <trans-unit id="2c348d29e84f0505a741faf5cd29979ee0784eb6" translate="yes" xml:space="preserve">
          <source>convert numeric to string</source>
          <target state="translated">数値を文字列に変換する</target>
        </trans-unit>
        <trans-unit id="e58b5696e1ecb535182f8da0e55ea16d3ba9714b" translate="yes" xml:space="preserve">
          <source>convert path to closed</source>
          <target state="translated">パスを閉じた状態に変換</target>
        </trans-unit>
        <trans-unit id="e8c6b63ef451acece45e4a2472ed3246d96680fa" translate="yes" xml:space="preserve">
          <source>convert path to open</source>
          <target state="translated">パスをオープンに変換</target>
        </trans-unit>
        <trans-unit id="b4e06a2b81ef98774ce30290d2c91fbe2ee0a163" translate="yes" xml:space="preserve">
          <source>convert real/double precision to string</source>
          <target state="translated">実数/倍精度を文字列に変換</target>
        </trans-unit>
        <trans-unit id="16630f62d1ae61b7816445e29898565307e22a6f" translate="yes" xml:space="preserve">
          <source>convert string to date</source>
          <target state="translated">文字列を日付に変換する</target>
        </trans-unit>
        <trans-unit id="77457ad94d28223c821b4d450456f45b1fe1f3c5" translate="yes" xml:space="preserve">
          <source>convert string to numeric</source>
          <target state="translated">文字列を数値化する</target>
        </trans-unit>
        <trans-unit id="d592ee6202ef0abdfa519a7ee4c6978379812ba5" translate="yes" xml:space="preserve">
          <source>convert string to time stamp</source>
          <target state="translated">文字列をタイムスタンプに変換する</target>
        </trans-unit>
        <trans-unit id="7554307f0c7cf7f9b6e803a9465e3e2cd2090bfa" translate="yes" xml:space="preserve">
          <source>convert text to &lt;code&gt;ltree&lt;/code&gt; and concatenate</source>
          <target state="translated">テキストを &lt;code&gt;ltree&lt;/code&gt; に変換して連結する</target>
        </trans-unit>
        <trans-unit id="176526ef5504731e3313035b22ba3c0b5c8f498b" translate="yes" xml:space="preserve">
          <source>convert time stamp to string</source>
          <target state="translated">タイムスタンプを文字列に変換する</target>
        </trans-unit>
        <trans-unit id="a3d85881749badcc411aff88ce02fb6973926ade" translate="yes" xml:space="preserve">
          <source>converts the integer constant 42 to type &lt;code&gt;float8&lt;/code&gt; by invoking a previously specified function, in this case &lt;code&gt;float8(int4)&lt;/code&gt;. (If no suitable cast has been defined, the conversion fails.)</source>
          <target state="translated">以前に指定された関数 &lt;code&gt;float8(int4)&lt;/code&gt; この場合はfloat8（int4））を呼び出すことにより、整数定数42を &lt;code&gt;float8&lt;/code&gt; 型に変換します。（適切なキャストが定義されていない場合、変換は失敗します。）</target>
        </trans-unit>
        <trans-unit id="9156629cfbed20d63d58fec30d0c098f0e19d25d" translate="yes" xml:space="preserve">
          <source>copy files to the &lt;code&gt;$SHAREDIR/tsearch_data&lt;/code&gt; directory</source>
          <target state="translated">&lt;code&gt;$SHAREDIR/tsearch_data&lt;/code&gt; ディレクトリにファイルをコピーする</target>
        </trans-unit>
        <trans-unit id="6f5d0356cf2bf7c83124fef63669f30215a05eee" translate="yes" xml:space="preserve">
          <source>correlation coefficient</source>
          <target state="translated">相関係数</target>
        </trans-unit>
        <trans-unit id="76b5d4c037174657db2ef3d6849098ed26c598c7" translate="yes" xml:space="preserve">
          <source>cosine</source>
          <target state="translated">cosine</target>
        </trans-unit>
        <trans-unit id="92c39d6b13445a5705c2f7b251a21f0fb971660d" translate="yes" xml:space="preserve">
          <source>cotangent</source>
          <target state="translated">cotangent</target>
        </trans-unit>
        <trans-unit id="e3b7cc2c1242a390854b610b0efc253303b2b6fd" translate="yes" xml:space="preserve">
          <source>could be used as input to pg_restore and would only restore items 10 and 6, in that order:</source>
          <target state="translated">はpg_restoreへの入力として使用することができ、項目10と6のみをこの順番でリストアします。</target>
        </trans-unit>
        <trans-unit id="fa3275b435c87e20aa8f38ceb77beb1839950e18" translate="yes" xml:space="preserve">
          <source>could handle these queries as index-only scans, because &lt;code&gt;y&lt;/code&gt; can be obtained from the index without visiting the heap.</source>
          <target state="translated">ヒープにアクセスせずにインデックスから &lt;code&gt;y&lt;/code&gt; を取得できるため、これらのクエリをインデックスのみのスキャンとして処理できます。</target>
        </trans-unit>
        <trans-unit id="6d4415f60a15671f449844424b8af6b0eb46e52d" translate="yes" xml:space="preserve">
          <source>could use the index, because the comparison will by default use the collation of the column. However, this index cannot accelerate queries that involve some other collation. So if queries of the form, say,</source>
          <target state="translated">比較はデフォルトでカラムの照合を使用するため、このインデックスを使用することができます。しかし、このインデックスは他の照合を含むクエリを加速することはできません。そのため、以下のような形式のクエリを実行した場合には、インデックスを使用することができます。</target>
        </trans-unit>
        <trans-unit id="0bac556c5d3bb14c1fede879eb302b107d254487" translate="yes" xml:space="preserve">
          <source>createdb</source>
          <target state="translated">createdb</target>
        </trans-unit>
        <trans-unit id="6b407470937a987ede5e1a0f6201cc8aa6dfebd1" translate="yes" xml:space="preserve">
          <source>createdb &amp;mdash; create a new PostgreSQL database</source>
          <target state="translated">createdb &amp;mdash;新しいPostgreSQLデータベースを作成する</target>
        </trans-unit>
        <trans-unit id="ddafc0b5a0df99cf7efa3a37dabf9dc9fc318b1d" translate="yes" xml:space="preserve">
          <source>createdb accepts the following command-line arguments:</source>
          <target state="translated">createdbは以下のコマンドライン引数を受け付けます。</target>
        </trans-unit>
        <trans-unit id="bbf7672a9395c4080a0583f706be79ec1c196ff7" translate="yes" xml:space="preserve">
          <source>createdb also accepts the following command-line arguments for connection parameters:</source>
          <target state="translated">createdbは、接続パラメータとして以下のコマンドライン引数も受け付けます。</target>
        </trans-unit>
        <trans-unit id="9470bae91f4b1b94fa4d30d94087484824b0dc48" translate="yes" xml:space="preserve">
          <source>createdb creates a new PostgreSQL database.</source>
          <target state="translated">createdbは新しいPostgreSQLデータベースを作成します。</target>
        </trans-unit>
        <trans-unit id="048a808c9479ad0cf4813cdc85239ab9acdb44e2" translate="yes" xml:space="preserve">
          <source>createdb is a wrapper around the SQL command &lt;a href=&quot;sql-createdatabase&quot;&gt;CREATE DATABASE&lt;/a&gt;. There is no effective difference between creating databases via this utility and via other methods for accessing the server.</source>
          <target state="translated">createdbはSQLコマンド&lt;a href=&quot;sql-createdatabase&quot;&gt;CREATE DATABASEの&lt;/a&gt;ラッパーです。このユーティリティを使用してデータベースを作成する場合と、サーバーにアクセスするための他の方法を使用する場合とで、効果的な違いはありません。</target>
        </trans-unit>
        <trans-unit id="df58b9eb4912cb4f51a557c31f280002a97c1cba" translate="yes" xml:space="preserve">
          <source>createuser</source>
          <target state="translated">createuser</target>
        </trans-unit>
        <trans-unit id="b3fcd1b75b88d9bb09cc16243ed746793c22b9e2" translate="yes" xml:space="preserve">
          <source>createuser &amp;mdash; define a new PostgreSQL user account</source>
          <target state="translated">createuser &amp;mdash;新しいPostgreSQLユーザーアカウントを定義する</target>
        </trans-unit>
        <trans-unit id="d10ac2835716c1122f4b67809fce50fe94a29e90" translate="yes" xml:space="preserve">
          <source>createuser accepts the following command-line arguments:</source>
          <target state="translated">createuserは以下のコマンドライン引数を受け付けます。</target>
        </trans-unit>
        <trans-unit id="6a28423b7c898a6be61a407aeecb01d59a5820bb" translate="yes" xml:space="preserve">
          <source>createuser also accepts the following command-line arguments for connection parameters:</source>
          <target state="translated">createuserは、接続パラメータとして以下のコマンドライン引数も受け付けます。</target>
        </trans-unit>
        <trans-unit id="d2a84b3f8857986e6dd89f160acf7f9e638227ea" translate="yes" xml:space="preserve">
          <source>createuser creates a new PostgreSQL user (or more precisely, a role). Only superusers and users with &lt;code&gt;CREATEROLE&lt;/code&gt; privilege can create new users, so createuser must be invoked by someone who can connect as a superuser or a user with &lt;code&gt;CREATEROLE&lt;/code&gt; privilege.</source>
          <target state="translated">createuserは新しいPostgreSQLユーザー（より正確にはロール）を作成します。スーパーユーザーと &lt;code&gt;CREATEROLE&lt;/code&gt; 特権を持つユーザーだけが新しいユーザーを作成できるため、スーパーユーザーまたは &lt;code&gt;CREATEROLE&lt;/code&gt; 特権を持つユーザーとして接続できるユーザーがcreateuserを呼び出す必要があります。</target>
        </trans-unit>
        <trans-unit id="3e447ff571994f9f3e3ba25c8d7ecf9fb22fbb73" translate="yes" xml:space="preserve">
          <source>createuser is a wrapper around the SQL command &lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLE&lt;/a&gt;. There is no effective difference between creating users via this utility and via other methods for accessing the server.</source>
          <target state="translated">createuserは、SQLコマンド&lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLEの&lt;/a&gt;ラッパーです。このユーティリティを使用してユーザーを作成する場合と、サーバーにアクセスするための他の方法を使用する場合で、効果的な違いはありません。</target>
        </trans-unit>
        <trans-unit id="55f7d1f71091501a0205fba94258266031264150" translate="yes" xml:space="preserve">
          <source>cube</source>
          <target state="translated">cube</target>
        </trans-unit>
        <trans-unit id="a7b0a72c320ec18ab3059928fd9784a02afb8268" translate="yes" xml:space="preserve">
          <source>cube root</source>
          <target state="translated">立方根</target>
        </trans-unit>
        <trans-unit id="12f7353964de624d3d4543c138e1761bcfdc57f8" translate="yes" xml:space="preserve">
          <source>cumulative distribution: (number of partition rows preceding or peer with current row) / total partition rows</source>
          <target state="translated">累積分布。(現在の行に先行するパーティションの行数または現在の行とのピア)/パーティションの総行数</target>
        </trans-unit>
        <trans-unit id="64607b5d8e4412896465575375d94f0725abe039" translate="yes" xml:space="preserve">
          <source>currency amount</source>
          <target state="translated">通貨額</target>
        </trans-unit>
        <trans-unit id="b81619f92b172ce2f6fa0a84df042cb5fd37a50f" translate="yes" xml:space="preserve">
          <source>currency symbol (uses locale)</source>
          <target state="translated">通貨記号</target>
        </trans-unit>
        <trans-unit id="4f4406b4ea462b2d1ce31fff99c629ac6a9ecade" translate="yes" xml:space="preserve">
          <source>current TID of this or newer row version</source>
          <target state="translated">この行または新しい行のバージョンの現在のTID</target>
        </trans-unit>
        <trans-unit id="ccae96815d506bcc8eb6b9e7ef48a9c48d733f5f" translate="yes" xml:space="preserve">
          <source>current nesting level of PostgreSQL triggers (0 if not called, directly or indirectly, from inside a trigger)</source>
          <target state="translated">PostgreSQLトリガの現在の入れ子レベル (トリガ内部から直接または間接的に呼び出されない場合は0)</target>
        </trans-unit>
        <trans-unit id="779b51a546eca5f4d60da79d0ec7ada57a18e13f" translate="yes" xml:space="preserve">
          <source>current scale factor</source>
          <target state="translated">カレントスケールファクター</target>
        </trans-unit>
        <trans-unit id="056ca10ef8889b41faa742d26656a471608732e4" translate="yes" xml:space="preserve">
          <source>current transaction's start time</source>
          <target state="translated">現在のトランザクションの開始時刻</target>
        </trans-unit>
        <trans-unit id="3ccfd1fb04d76ca6fa36faf318d4bbbe6e019e62" translate="yes" xml:space="preserve">
          <source>current user is a superuser</source>
          <target state="translated">現ユーザがスーパーユーザ</target>
        </trans-unit>
        <trans-unit id="e76746f9f64ea77f86d57b4affc2e26c70e97db1" translate="yes" xml:space="preserve">
          <source>current user is the server owner and mapping is for &lt;code&gt;PUBLIC&lt;/code&gt;</source>
          <target state="translated">現在のユーザーはサーバーの所有者であり、マッピングは &lt;code&gt;PUBLIC&lt;/code&gt; 用です</target>
        </trans-unit>
        <trans-unit id="56acd550331e29f863c4189d4f0d3e7d6050a758" translate="yes" xml:space="preserve">
          <source>current user is the user being mapped, and owns the server or holds &lt;code&gt;USAGE&lt;/code&gt; privilege on it</source>
          <target state="translated">現在のユーザーは、マップされているユーザーであり、サーバーを所有しているか、サーバーの &lt;code&gt;USAGE&lt;/code&gt; 特権を持っています</target>
        </trans-unit>
        <trans-unit id="251e17f62ca5a0bad33a4794560b84bff241ddd2" translate="yes" xml:space="preserve">
          <source>dartmouth.edu/~sting/sw/imath</source>
          <target state="translated">dartmouth.edu/~sting/sw/imath</target>
        </trans-unit>
        <trans-unit id="248361612d1d3c64585c3817d26796e95c11dece" translate="yes" xml:space="preserve">
          <source>data pages for large objects</source>
          <target state="translated">ラージオブジェクト用データページ</target>
        </trans-unit>
        <trans-unit id="c429160164cb02d0618b1e822bdab4bf43fbb586" translate="yes" xml:space="preserve">
          <source>data type name</source>
          <target state="translated">データ型名</target>
        </trans-unit>
        <trans-unit id="1bd41877f2856c4d7b5bc551b1c51509f9f61a5b" translate="yes" xml:space="preserve">
          <source>data types</source>
          <target state="translated">データ型</target>
        </trans-unit>
        <trans-unit id="9dbbcafe5430392decd61d26126df6cde3ef6b46" translate="yes" xml:space="preserve">
          <source>database creation</source>
          <target state="translated">データベース作成</target>
        </trans-unit>
        <trans-unit id="564babd5efa4c177e7fbceca3d3d19ecd02f9665" translate="yes" xml:space="preserve">
          <source>database roles</source>
          <target state="translated">データベースの役割</target>
        </trans-unit>
        <trans-unit id="4167ac168b132ec514ae402ff3cd6a698a1a72b2" translate="yes" xml:space="preserve">
          <source>database size</source>
          <target state="translated">データベースサイズ</target>
        </trans-unit>
        <trans-unit id="9ac69b495c64616d7b51aad907a1b0a02e1e82e1" translate="yes" xml:space="preserve">
          <source>database users</source>
          <target state="translated">データベース利用者</target>
        </trans-unit>
        <trans-unit id="cb7adbeff69aceed0bcbedf307c65b93eee9ad75" translate="yes" xml:space="preserve">
          <source>databases within this database cluster</source>
          <target state="translated">このデータベースクラスタ内のデータベース</target>
        </trans-unit>
        <trans-unit id="d202efb306923275367bde19b04202628d0810f8" translate="yes" xml:space="preserve">
          <source>date (no time of day)</source>
          <target state="translated">日にち</target>
        </trans-unit>
        <trans-unit id="1b3873d4c20bb95e93889a9abb13b9714bb3aebb" translate="yes" xml:space="preserve">
          <source>date and time (no time zone)</source>
          <target state="translated">にちじ</target>
        </trans-unit>
        <trans-unit id="eec85f3a0d545b904948082d0843118f704b1d8d" translate="yes" xml:space="preserve">
          <source>date and time, including time zone</source>
          <target state="translated">日付と時間(時間帯を含む</target>
        </trans-unit>
        <trans-unit id="a8317cc31a263bf0df643e148f49a9ce920f53ce" translate="yes" xml:space="preserve">
          <source>day of ISO 8601 week-numbering year (001&amp;ndash;371; day 1 of the year is Monday of the first ISO week)</source>
          <target state="translated">ISO 8601週番号年の日（001〜371;年の1日目は最初のISO週の月曜日）</target>
        </trans-unit>
        <trans-unit id="d2d8e3721b3534cc276e29fdaeef31b7178dcae1" translate="yes" xml:space="preserve">
          <source>day of ISO 8601 week-numbering year (001-371; day 1 of the year is Monday of the first ISO week)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="090f8b3f331eb935f525922409bffea8e09b7d95" translate="yes" xml:space="preserve">
          <source>day of month (01&amp;ndash;31)</source>
          <target state="translated">曜日（01&amp;ndash;31）</target>
        </trans-unit>
        <trans-unit id="0ad17a3576b304f060bc744adbfaf1cfd97c0b9f" translate="yes" xml:space="preserve">
          <source>day of month (01-31)</source>
          <target state="translated">月日</target>
        </trans-unit>
        <trans-unit id="469af68e3866ca6a9deafcaeae3928c434d4b3e1" translate="yes" xml:space="preserve">
          <source>day of the week, Sunday (&lt;code&gt;1&lt;/code&gt;) to Saturday (&lt;code&gt;7&lt;/code&gt;)</source>
          <target state="translated">曜日、日曜日（ &lt;code&gt;1&lt;/code&gt; ）から土曜日（ &lt;code&gt;7&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="0edf11eeeb832dd1b17b8e28879ed7531aa362ac" translate="yes" xml:space="preserve">
          <source>day of year (001&amp;ndash;366)</source>
          <target state="translated">曜日（001〜366）</target>
        </trans-unit>
        <trans-unit id="8a71c2096de47fbc8680000b32ef705fe832913e" translate="yes" xml:space="preserve">
          <source>day of year (001-366)</source>
          <target state="translated">年日</target>
        </trans-unit>
        <trans-unit id="700a54df2e790245f9dcd527f33cd998af18e65f" translate="yes" xml:space="preserve">
          <source>dblink_build_sql_update</source>
          <target state="translated">dblink_build_sql_update</target>
        </trans-unit>
        <trans-unit id="a03c4c4da450b6b78f166172cdfad6685ad457cd" translate="yes" xml:space="preserve">
          <source>de-summarize the page range covering the given block, if summarized</source>
          <target state="translated">指定されたブロックをカバーするページ範囲を、要約されている場合は要約を解除します。</target>
        </trans-unit>
        <trans-unit id="cbb374265aa2a00ae1a935c1b66a5a8765c5a8db" translate="yes" xml:space="preserve">
          <source>decimal point</source>
          <target state="translated">しょうすうてん</target>
        </trans-unit>
        <trans-unit id="f0dcabf47a6adda5ccdca5499ec11830a3bb794d" translate="yes" xml:space="preserve">
          <source>decimal point (uses locale)</source>
          <target state="translated">小数点</target>
        </trans-unit>
        <trans-unit id="d9f9f3ca28421c771e69ddc796196abbfc38261a" translate="yes" xml:space="preserve">
          <source>decompile internal form of an expression, assuming that any Vars in it refer to the relation indicated by the second parameter</source>
          <target state="translated">式の内部形式を逆コンパイルします。式の中のVarsが2番目のパラメータで示された関係を参照していると仮定します。</target>
        </trans-unit>
        <trans-unit id="5d0f59b9287cc99be12e3adc0a5ed8bb3aa30762" translate="yes" xml:space="preserve">
          <source>default privileges for object types</source>
          <target state="translated">オブジェクトタイプのデフォルト特権</target>
        </trans-unit>
        <trans-unit id="7ab389d535d69add8b20d71d3316df0764149116" translate="yes" xml:space="preserve">
          <source>degrees to radians</source>
          <target state="translated">度対ラジアン</target>
        </trans-unit>
        <trans-unit id="76a1d7b09f9d708126885250c26d9a7c5662a26e" translate="yes" xml:space="preserve">
          <source>delete XID stamp</source>
          <target state="translated">削除エックスアイディースタンプ</target>
        </trans-unit>
        <trans-unit id="4e7d874e194c57e56c6808bda722d6e762a82d75" translate="yes" xml:space="preserve">
          <source>delete key from left operand</source>
          <target state="translated">左オペランドからの削除キー</target>
        </trans-unit>
        <trans-unit id="5994ddb3d5afc39677fe0d3e53b41199d5e46887" translate="yes" xml:space="preserve">
          <source>delete keys from left operand</source>
          <target state="translated">左のオペランドからキーを削除します。</target>
        </trans-unit>
        <trans-unit id="e872e58a377017a736cf1e1ab4ff236790275777" translate="yes" xml:space="preserve">
          <source>delete matching pairs from left operand</source>
          <target state="translated">左のオペランドからマッチするペアを削除します。</target>
        </trans-unit>
        <trans-unit id="eae96a435f5bdb0c81e63fb0c70854998629b631" translate="yes" xml:space="preserve">
          <source>delete pair with matching key</source>
          <target state="translated">キーが一致したペアの削除</target>
        </trans-unit>
        <trans-unit id="b1c7a2750dfb5f36480871a2e5c6e4567af9e887" translate="yes" xml:space="preserve">
          <source>delete pairs matching those in the second argument</source>
          <target state="translated">第2引数のペアを削除する</target>
        </trans-unit>
        <trans-unit id="3efddac41d9ff2c5cb13d8732824f2be0263e5fa" translate="yes" xml:space="preserve">
          <source>delete pairs with matching keys</source>
          <target state="translated">キーが一致するペアの削除</target>
        </trans-unit>
        <trans-unit id="1039b55fb5734d3d36060d3f7c0dffed078f3f5d" translate="yes" xml:space="preserve">
          <source>dependencies between database objects</source>
          <target state="translated">データベースオブジェクト間の依存関係</target>
        </trans-unit>
        <trans-unit id="bcf260757062336d168e0b854a6bfec054320982" translate="yes" xml:space="preserve">
          <source>dependencies on shared objects</source>
          <target state="translated">共有オブジェクトへの依存性</target>
        </trans-unit>
        <trans-unit id="643b64fb4c981ee959710c294a989bd23751dfb6" translate="yes" xml:space="preserve">
          <source>depending on your system. If you are certain that no conflicting server is running, you can remove the lock file mentioned in the message and try again.</source>
          <target state="translated">はシステムによって異なります。競合するサーバーが実行されていないことが確認できた場合は、メッセージに記載されているロックファイルを削除して、もう一度試してみてください。</target>
        </trans-unit>
        <trans-unit id="74b0f36995620769c56ddd2cbff3cada94967a2b" translate="yes" xml:space="preserve">
          <source>deprecated synonym for &lt;code&gt;@@&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;@@&lt;/code&gt; の非推奨の同義語</target>
        </trans-unit>
        <trans-unit id="bfeb202c643a0ab0c62a61acbeda3c7ce92fcd15" translate="yes" xml:space="preserve">
          <source>descriptions or comments on database objects</source>
          <target state="translated">データベースオブジェクトに関する記述やコメント</target>
        </trans-unit>
        <trans-unit id="13c1d29555b21e921b0a3aedc5e4ff745b633b81" translate="yes" xml:space="preserve">
          <source>diameter of circle</source>
          <target state="translated">円の直径</target>
        </trans-unit>
        <trans-unit id="ff9ccbf023e1d5c01856ab64c92fc6a9f9161e07" translate="yes" xml:space="preserve">
          <source>dict_int</source>
          <target state="translated">dict_int</target>
        </trans-unit>
        <trans-unit id="08bafab9b334b62e4fc9fb37bf107442495772df" translate="yes" xml:space="preserve">
          <source>dict_xsyn</source>
          <target state="translated">dict_xsyn</target>
        </trans-unit>
        <trans-unit id="48d53c6e22192bbaaff43be3456d5f6f5d82da6f" translate="yes" xml:space="preserve">
          <source>difference</source>
          <target state="translated">difference</target>
        </trans-unit>
        <trans-unit id="85ee40d69e337d51248f4aebee5d12dd412aef01" translate="yes" xml:space="preserve">
          <source>digit position (can be dropped if insignificant)</source>
          <target state="translated">桁位置</target>
        </trans-unit>
        <trans-unit id="a724a4d536d891e4bd851b3b127513c5cac870e7" translate="yes" xml:space="preserve">
          <source>digit position (will not be dropped, even if insignificant)</source>
          <target state="translated">桁位置</target>
        </trans-unit>
        <trans-unit id="58e4fb37fdcbe481209c5e401fac9ed4117d48b5" translate="yes" xml:space="preserve">
          <source>directory to use for postmaster sockets during upgrade; default is current working directory; environment variable &lt;code&gt;PGSOCKETDIR&lt;/code&gt;</source>
          <target state="translated">アップグレード中にpostmasterソケットに使用するディレクトリ。デフォルトは現在の作業ディレクトリです。環境変数 &lt;code&gt;PGSOCKETDIR&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="302710649278eb0883ce3392069d7e99b6dfb8f9" translate="yes" xml:space="preserve">
          <source>dirty read</source>
          <target state="translated">ダーティーリード</target>
        </trans-unit>
        <trans-unit id="24d5fc5c766af09ab08d7bfd916da7e70bb52c5e" translate="yes" xml:space="preserve">
          <source>discrete percentile: returns the first input value whose position in the ordering equals or exceeds the specified fraction</source>
          <target state="translated">離散パーセンタイル:指定された分数以上の位置にある最初の入力値を返します。</target>
        </trans-unit>
        <trans-unit id="2090e17cbce163da2ce919466e3fd2175625ec32" translate="yes" xml:space="preserve">
          <source>disk blocks</source>
          <target state="translated">ディスクブロック</target>
        </trans-unit>
        <trans-unit id="c96264e7d87a9178b70f95d33581e0839e385c5a" translate="yes" xml:space="preserve">
          <source>display a query match</source>
          <target state="translated">クエリマッチを表示する</target>
        </trans-unit>
        <trans-unit id="7a1ad48b2e1eb83707513d8a4c172844610b0eac" translate="yes" xml:space="preserve">
          <source>display version information, then exit</source>
          <target state="translated">バージョン情報を表示して終了</target>
        </trans-unit>
        <trans-unit id="314b330f1a69b0d1e908c495db3cf5b21621f484" translate="yes" xml:space="preserve">
          <source>division (integer division truncates the result)</source>
          <target state="translated">除算</target>
        </trans-unit>
        <trans-unit id="030d8c79e8db0778a98b5c136a1d9a70816df62e" translate="yes" xml:space="preserve">
          <source>division (integer truncates the results)</source>
          <target state="translated">割り算</target>
        </trans-unit>
        <trans-unit id="4cb6cafbb6abf82018a9534f90701e2e42fca638" translate="yes" xml:space="preserve">
          <source>does &lt;code&gt;hstore&lt;/code&gt; contain all specified keys?</source>
          <target state="translated">ん &lt;code&gt;hstore&lt;/code&gt; のは、指定されたすべてのキーが含まれていますか？</target>
        </trans-unit>
        <trans-unit id="bafd763d733c6d384cfadd48039c1c94b64a5057" translate="yes" xml:space="preserve">
          <source>does &lt;code&gt;hstore&lt;/code&gt; contain any of the specified keys?</source>
          <target state="translated">ん &lt;code&gt;hstore&lt;/code&gt; のは、指定されたキーのいずれかを含みますか？</target>
        </trans-unit>
        <trans-unit id="16f67fbb1f9b0ce89c412fa9f9c91ed03c52ef42" translate="yes" xml:space="preserve">
          <source>does &lt;code&gt;hstore&lt;/code&gt; contain key?</source>
          <target state="translated">ん &lt;code&gt;hstore&lt;/code&gt; のは、キーが含まれていますか？</target>
        </trans-unit>
        <trans-unit id="6d66dc3d673440da44d129cf30dafe0627587c75" translate="yes" xml:space="preserve">
          <source>does &lt;code&gt;hstore&lt;/code&gt; contain non-&lt;code&gt;NULL&lt;/code&gt; value for key?</source>
          <target state="translated">ん &lt;code&gt;hstore&lt;/code&gt; のは、非含まれている &lt;code&gt;NULL&lt;/code&gt; のキーの値を？</target>
        </trans-unit>
        <trans-unit id="c33f0d5d452e89fd44dcdef1104e34e2460df71f" translate="yes" xml:space="preserve">
          <source>does &lt;code&gt;ltree&lt;/code&gt; array contain any path matching any &lt;code&gt;lquery&lt;/code&gt;?</source>
          <target state="translated">ん &lt;code&gt;ltree&lt;/code&gt; は、アレイは、任意の一致するすべてのパス含ま &lt;code&gt;lquery&lt;/code&gt; に？</target>
        </trans-unit>
        <trans-unit id="1c53b57b8ca3d240b9dc88085af96b6dbab6fa68" translate="yes" xml:space="preserve">
          <source>does &lt;code&gt;ltree&lt;/code&gt; match &lt;code&gt;lquery&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;ltree&lt;/code&gt; はlqueryと一致し &lt;code&gt;lquery&lt;/code&gt; か？</target>
        </trans-unit>
        <trans-unit id="3648ad67b9d0438df764a00aa33a91ea0f51da62" translate="yes" xml:space="preserve">
          <source>does &lt;code&gt;ltree&lt;/code&gt; match &lt;code&gt;ltxtquery&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;ltree&lt;/code&gt; はltxtqueryと一致し &lt;code&gt;ltxtquery&lt;/code&gt; か？</target>
        </trans-unit>
        <trans-unit id="bee15116149fbb94972f0f1f0a198543b5d86fe4" translate="yes" xml:space="preserve">
          <source>does &lt;code&gt;ltree&lt;/code&gt; match any &lt;code&gt;lquery&lt;/code&gt; in array?</source>
          <target state="translated">ん &lt;code&gt;ltree&lt;/code&gt; はは任意の一致 &lt;code&gt;lquery&lt;/code&gt; 配列では？</target>
        </trans-unit>
        <trans-unit id="6daa1a6ed3cacf7a57ce4c941eea23a2076c5480" translate="yes" xml:space="preserve">
          <source>does &lt;em&gt;not&lt;/em&gt; mean you've run out of disk space. It means your kernel's limit on the number of System V semaphores is smaller than the number PostgreSQL wants to create. As above, you might be able to work around the problem by starting the server with a reduced number of allowed connections (&lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;max_connections&lt;/a&gt;), but you'll eventually want to increase the kernel limit.</source>
          <target state="translated">ディスク容量が&lt;em&gt;足りなくなった&lt;/em&gt;わけではありませ&lt;em&gt;ん&lt;/em&gt;。これは、カーネルのSystem Vセマフォの数の制限が、PostgreSQLが作成する数よりも少ないことを意味します。上記のように、許可された接続数（&lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;max_connections&lt;/a&gt;）を減らしてサーバーを起動することで問題を回避できる可能性がありますが、最終的にはカーネルの制限を増やす必要があります。</target>
        </trans-unit>
        <trans-unit id="64868bbf0f6334a11707f036779fce59caac51fe" translate="yes" xml:space="preserve">
          <source>does array contain a descendant of &lt;code&gt;ltree&lt;/code&gt;?</source>
          <target state="translated">配列には &lt;code&gt;ltree&lt;/code&gt; の子孫が含まれていますか？</target>
        </trans-unit>
        <trans-unit id="a301dc21d55ea9fa1daaf587093b7b700878a61f" translate="yes" xml:space="preserve">
          <source>does array contain an ancestor of &lt;code&gt;ltree&lt;/code&gt;?</source>
          <target state="translated">配列には &lt;code&gt;ltree&lt;/code&gt; の祖先が含まれていますか？</target>
        </trans-unit>
        <trans-unit id="567bff233f20cf454c16349c2b002f100e4644d2" translate="yes" xml:space="preserve">
          <source>does array contain any path matching &lt;code&gt;lquery&lt;/code&gt;?</source>
          <target state="translated">配列には &lt;code&gt;lquery&lt;/code&gt; に一致するパスが含まれていますか？</target>
        </trans-unit>
        <trans-unit id="7d7b1ca647e0b44d6a318e89c4b79d80dec00662" translate="yes" xml:space="preserve">
          <source>does array contain any path matching &lt;code&gt;ltxtquery&lt;/code&gt;?</source>
          <target state="translated">配列には &lt;code&gt;ltxtquery&lt;/code&gt; に一致するパスが含まれていますか？</target>
        </trans-unit>
        <trans-unit id="d0e93f199be58627d5290fb7e295a3883e34de0e" translate="yes" xml:space="preserve">
          <source>does current user have privilege for any column of table</source>
          <target state="translated">現在のユーザがテーブルのどの列に対しても特権を持っているか</target>
        </trans-unit>
        <trans-unit id="923f34e72b54c44d587b74dfe716fb9e7a0b69f3" translate="yes" xml:space="preserve">
          <source>does current user have privilege for column</source>
          <target state="translated">現在のユーザがカラムの権限を持っているか</target>
        </trans-unit>
        <trans-unit id="8eebefcd3db5e0fd1f67f23a742c8cbdb52ca488" translate="yes" xml:space="preserve">
          <source>does current user have privilege for database</source>
          <target state="translated">現在のユーザがデータベースの権限を持っているか</target>
        </trans-unit>
        <trans-unit id="d5d20390d72f10839e55e755a41622b4e83aaad2" translate="yes" xml:space="preserve">
          <source>does current user have privilege for foreign server</source>
          <target state="translated">現在のユーザが外国のサーバの権限を持っているか</target>
        </trans-unit>
        <trans-unit id="76e06765244ec4f69ad0edf35314e91668644688" translate="yes" xml:space="preserve">
          <source>does current user have privilege for foreign-data wrapper</source>
          <target state="translated">現在のユーザが外部データラッパーの権限を持っているか?</target>
        </trans-unit>
        <trans-unit id="14cf9981a77c04be078c13991b9209c61e42b19f" translate="yes" xml:space="preserve">
          <source>does current user have privilege for function</source>
          <target state="translated">現在のユーザが関数の権限を持っているか</target>
        </trans-unit>
        <trans-unit id="e53afcf7f590b1f341c771ee932c34274218fee2" translate="yes" xml:space="preserve">
          <source>does current user have privilege for language</source>
          <target state="translated">現在のユーザは言語の権限を持っているか</target>
        </trans-unit>
        <trans-unit id="d392178c73923ceb61788ee59e66cfc98b85b093" translate="yes" xml:space="preserve">
          <source>does current user have privilege for role</source>
          <target state="translated">現在のユーザがロールの権限を持っているか</target>
        </trans-unit>
        <trans-unit id="3ce043cb41e01186d5429925060d21732a8a9b01" translate="yes" xml:space="preserve">
          <source>does current user have privilege for schema</source>
          <target state="translated">現在のユーザがスキーマの権限を持っているか</target>
        </trans-unit>
        <trans-unit id="44e2c7a7969b5280a9ac5e18312a1a719915e5c8" translate="yes" xml:space="preserve">
          <source>does current user have privilege for sequence</source>
          <target state="translated">現在のユーザがシーケンスの権限を持っているか</target>
        </trans-unit>
        <trans-unit id="a8553aada6aa07a63b9fb14a123e6eb5d6132d87" translate="yes" xml:space="preserve">
          <source>does current user have privilege for table</source>
          <target state="translated">現在のユーザがテーブルの権限を持っているか</target>
        </trans-unit>
        <trans-unit id="aa74612a59a28280141be932e93980e9b80f16c8" translate="yes" xml:space="preserve">
          <source>does current user have privilege for tablespace</source>
          <target state="translated">現在のユーザがテーブルスペースの権限を持っているか</target>
        </trans-unit>
        <trans-unit id="dd7e9d6b9c5d3197cefad7a4260eb463901b4b09" translate="yes" xml:space="preserve">
          <source>does current user have privilege for type</source>
          <target state="translated">現在のユーザが型の権限を持っているか</target>
        </trans-unit>
        <trans-unit id="65119e338c802227733d23f560577b1f92332234" translate="yes" xml:space="preserve">
          <source>does current user have row level security active for table</source>
          <target state="translated">現在のユーザがテーブルの行レベルのセキュリティを有効にしているか</target>
        </trans-unit>
        <trans-unit id="b12d604405828eb6355ba772e8353d7dff5c090e" translate="yes" xml:space="preserve">
          <source>does left operand contain right?</source>
          <target state="translated">左のオペランドには右のオペランドが含まれていますか?</target>
        </trans-unit>
        <trans-unit id="756c9771ba43bfeb3fc0b27733143e509011767d" translate="yes" xml:space="preserve">
          <source>does not contradict common sense, neither does the intersection</source>
          <target state="translated">は常識に反するものではなく、どちらの交点も</target>
        </trans-unit>
        <trans-unit id="b36715a10925245466a61b1c713e5e53614f7d3c" translate="yes" xml:space="preserve">
          <source>does not extend to the left of</source>
          <target state="translated">の左にはみ出しません。</target>
        </trans-unit>
        <trans-unit id="7d4052eb9215bde986d065d712fe5d1ea63cb4dd" translate="yes" xml:space="preserve">
          <source>does not extend to the right of</source>
          <target state="translated">の権利には及ばない。</target>
        </trans-unit>
        <trans-unit id="f7f46d46a353213d12fe0e106cd32be9a96a313c" translate="yes" xml:space="preserve">
          <source>does not result in an error, because the &lt;code&gt;||&lt;/code&gt; operator does not care about collations: its result is the same regardless of the collation.</source>
          <target state="translated">&lt;code&gt;||&lt;/code&gt; であるため、エラーにはなりません。演算子は照合を気にしません。その結果は、照合に関係なく同じです。</target>
        </trans-unit>
        <trans-unit id="75e4c1b191e5aba3fca713359bb284f3bba53197" translate="yes" xml:space="preserve">
          <source>does user have privilege for any column of table</source>
          <target state="translated">ユーザはテーブルのどの列に対しても特権を持っているか</target>
        </trans-unit>
        <trans-unit id="3e3a02344dffd3279b448eb7d8ae2788f7b6be07" translate="yes" xml:space="preserve">
          <source>does user have privilege for column</source>
          <target state="translated">ユーザがカラムの権限を持っているか</target>
        </trans-unit>
        <trans-unit id="e98b58c4f0fc14060c4884df933960d9628f8716" translate="yes" xml:space="preserve">
          <source>does user have privilege for database</source>
          <target state="translated">ユーザがデータベースの権限を持っているか</target>
        </trans-unit>
        <trans-unit id="765c96c7f8619408b3a2ef1d6a65be4c1cacb9c9" translate="yes" xml:space="preserve">
          <source>does user have privilege for foreign server</source>
          <target state="translated">ユーザは外国のサーバの権限を持っているか</target>
        </trans-unit>
        <trans-unit id="a1aad5c71dcb9de7b0ebfe1791764c821ee31f90" translate="yes" xml:space="preserve">
          <source>does user have privilege for foreign-data wrapper</source>
          <target state="translated">ユーザが外部データラッパーの権限を持っているか?</target>
        </trans-unit>
        <trans-unit id="c225f178288924737bfa6e4b6a297dd843498dd4" translate="yes" xml:space="preserve">
          <source>does user have privilege for function</source>
          <target state="translated">ユーザは関数の特権を持っているか</target>
        </trans-unit>
        <trans-unit id="d470907c424695bcabb45adae12569de1bad3b0d" translate="yes" xml:space="preserve">
          <source>does user have privilege for language</source>
          <target state="translated">ユーザーは言語の特権を持っていますか?</target>
        </trans-unit>
        <trans-unit id="a0ba62c173d0bc0e7a46899574360820b2bc2f9f" translate="yes" xml:space="preserve">
          <source>does user have privilege for role</source>
          <target state="translated">ユーザーはロールの権限を持っているか</target>
        </trans-unit>
        <trans-unit id="bed67dbbf088b4b1ffec5c7180d7d0ec267b5df8" translate="yes" xml:space="preserve">
          <source>does user have privilege for schema</source>
          <target state="translated">ユーザーはスキーマの権限を持っていますか?</target>
        </trans-unit>
        <trans-unit id="fda3d32d403e4d198f5f4e5703028831a30fe866" translate="yes" xml:space="preserve">
          <source>does user have privilege for sequence</source>
          <target state="translated">ユーザがシーケンスの権限を持っているか</target>
        </trans-unit>
        <trans-unit id="0b3c10883f54a4a3a8e9b7a17c728cb3f9c09b6a" translate="yes" xml:space="preserve">
          <source>does user have privilege for table</source>
          <target state="translated">ユーザがテーブルの権限を持っているか</target>
        </trans-unit>
        <trans-unit id="d616ba1bcc2173d55dc3b40b681e7e2c83c7625d" translate="yes" xml:space="preserve">
          <source>does user have privilege for tablespace</source>
          <target state="translated">ユーザがテーブルスペースの権限を持っているか</target>
        </trans-unit>
        <trans-unit id="f37310ea7053667a4967493d91089148515177e4" translate="yes" xml:space="preserve">
          <source>does user have privilege for type</source>
          <target state="translated">タイプの特権を持っていますか?</target>
        </trans-unit>
        <trans-unit id="bdb36bb22deb169275b3094ba9005a29eeddd195" translate="yes" xml:space="preserve">
          <source>double</source>
          <target state="translated">double</target>
        </trans-unit>
        <trans-unit id="f70c61055e7cd930e448a61146df9dcec538dae5" translate="yes" xml:space="preserve">
          <source>double if any &lt;code&gt;a&lt;/code&gt; is double, else integer</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; がdoubleの場合はdouble、それ以外の場合はinteger</target>
        </trans-unit>
        <trans-unit id="a9d7d2a5b010ce1408927d410711b2b9b2dcf630" translate="yes" xml:space="preserve">
          <source>double precision</source>
          <target state="translated">倍精度</target>
        </trans-unit>
        <trans-unit id="7bd1b3d84f60bc411ebad0e502e786bfb5dff6b4" translate="yes" xml:space="preserve">
          <source>double precision floating-point number (8 bytes)</source>
          <target state="translated">倍精度浮動小数点数(8バイト</target>
        </trans-unit>
        <trans-unit id="2b0e335cd50db4422abd071d794ce8250a0af460" translate="yes" xml:space="preserve">
          <source>download dictionary configuration files. OpenOffice extension files have the &lt;code&gt;.oxt&lt;/code&gt; extension. It is necessary to extract &lt;code&gt;.aff&lt;/code&gt; and &lt;code&gt;.dic&lt;/code&gt; files, change extensions to &lt;code&gt;.affix&lt;/code&gt; and &lt;code&gt;.dict&lt;/code&gt;. For some dictionary files it is also needed to convert characters to the UTF-8 encoding with commands (for example, for a Norwegian language dictionary):</source>
          <target state="translated">辞書構成ファイルをダウンロードします。OpenOffice拡張ファイルの拡張子は &lt;code&gt;.oxt&lt;/code&gt; です。 &lt;code&gt;.aff&lt;/code&gt; および &lt;code&gt;.dic&lt;/code&gt; ファイルを抽出し、拡張子を &lt;code&gt;.affix&lt;/code&gt; および &lt;code&gt;.dict&lt;/code&gt; に変更する必要があります。一部の辞書ファイルでは、コマンドを使用して文字をUTF-8エンコーディングに変換する必要もあります（たとえば、ノルウェー語の辞書の場合）。</target>
        </trans-unit>
        <trans-unit id="6cbe8eee2be1493251c74aba3d14ce090704c314" translate="yes" xml:space="preserve">
          <source>dropdb</source>
          <target state="translated">dropdb</target>
        </trans-unit>
        <trans-unit id="da2f55f30903093b88b2abe2ff1d8c8878785d4d" translate="yes" xml:space="preserve">
          <source>dropdb &amp;mdash; remove a PostgreSQL database</source>
          <target state="translated">dropdb &amp;mdash; PostgreSQLデータベースを削除する</target>
        </trans-unit>
        <trans-unit id="cee0a709ed144356dd15d656bc6b22fb78c87ab6" translate="yes" xml:space="preserve">
          <source>dropdb accepts the following command-line arguments:</source>
          <target state="translated">dropdbは以下のコマンドライン引数を受け付けます。</target>
        </trans-unit>
        <trans-unit id="6f5dc55cde4d56805bce8487bd823396755fbd8f" translate="yes" xml:space="preserve">
          <source>dropdb also accepts the following command-line arguments for connection parameters:</source>
          <target state="translated">dropdbは、接続パラメータとして以下のコマンドライン引数も受け付けています。</target>
        </trans-unit>
        <trans-unit id="b2c63240befa5a55623102754bbe3f06e330117d" translate="yes" xml:space="preserve">
          <source>dropdb destroys an existing PostgreSQL database. The user who executes this command must be a database superuser or the owner of the database.</source>
          <target state="translated">dropdbは既存のPostgreSQLデータベースを破壊します。このコマンドを実行するユーザは、データベースのスーパーユーザかデータベースの所有者でなければなりません。</target>
        </trans-unit>
        <trans-unit id="5fdb4e6dd14831ab684970c9656f06e02410c343" translate="yes" xml:space="preserve">
          <source>dropdb is a wrapper around the SQL command &lt;a href=&quot;sql-dropdatabase&quot;&gt;DROP DATABASE&lt;/a&gt;. There is no effective difference between dropping databases via this utility and via other methods for accessing the server.</source>
          <target state="translated">dropdbは、SQLコマンド&lt;a href=&quot;sql-dropdatabase&quot;&gt;DROP DATABASEの&lt;/a&gt;ラッパーです。このユーティリティを使用してデータベースを削除する場合と、サーバーにアクセスするための他の方法を使用する場合とで、効果的な違いはありません。</target>
        </trans-unit>
        <trans-unit id="61f8d2eb809b42145cb0c2cc59455f90ae6b39d4" translate="yes" xml:space="preserve">
          <source>dropuser</source>
          <target state="translated">dropuser</target>
        </trans-unit>
        <trans-unit id="3d4f5569f58e7a7d09eb7133d2210c8728567a77" translate="yes" xml:space="preserve">
          <source>dropuser &amp;mdash; remove a PostgreSQL user account</source>
          <target state="translated">dropuser &amp;mdash; PostgreSQLユーザーアカウントを削除する</target>
        </trans-unit>
        <trans-unit id="1077aba6c2b30bf419021fbb806b212443ec339c" translate="yes" xml:space="preserve">
          <source>dropuser accepts the following command-line arguments:</source>
          <target state="translated">dropuserは以下のコマンドライン引数を受け付けます。</target>
        </trans-unit>
        <trans-unit id="2671207f049e22f4b10b3fd2b9765935cf20ee06" translate="yes" xml:space="preserve">
          <source>dropuser also accepts the following command-line arguments for connection parameters:</source>
          <target state="translated">dropuserは、接続パラメータとして以下のコマンドライン引数も受け付けています。</target>
        </trans-unit>
        <trans-unit id="c9d1416783a863b7c532e14663d3712fc1f90804" translate="yes" xml:space="preserve">
          <source>dropuser is a wrapper around the SQL command &lt;a href=&quot;sql-droprole&quot;&gt;DROP ROLE&lt;/a&gt;. There is no effective difference between dropping users via this utility and via other methods for accessing the server.</source>
          <target state="translated">dropuserは、SQLコマンド&lt;a href=&quot;sql-droprole&quot;&gt;DROP ROLEの&lt;/a&gt;ラッパーです。このユーティリティとサーバーにアクセスする他の方法でユーザーを削除することには、効果的な違いはありません。</target>
        </trans-unit>
        <trans-unit id="4c08c2e0100e4eb26441eea8482accbff764a871" translate="yes" xml:space="preserve">
          <source>dropuser removes an existing PostgreSQL user. Only superusers and users with the &lt;code&gt;CREATEROLE&lt;/code&gt; privilege can remove PostgreSQL users. (To remove a superuser, you must yourself be a superuser.)</source>
          <target state="translated">dropuserは既存のPostgreSQLユーザーを削除します。スーパーユーザーと &lt;code&gt;CREATEROLE&lt;/code&gt; 特権を持つユーザーのみがPostgreSQLユーザーを削除できます。（スーパーユーザーを削除するには、自分がスーパーユーザーである必要があります。）</target>
        </trans-unit>
        <trans-unit id="2d1c3f7cb60beb3d49e3f4e046f5ea896f8b0a5d" translate="yes" xml:space="preserve">
          <source>earlier than all other time stamps</source>
          <target state="translated">いち早く</target>
        </trans-unit>
        <trans-unit id="d00152028f9066049bf52b54717487fea14124ea" translate="yes" xml:space="preserve">
          <source>earthdistance</source>
          <target state="translated">earthdistance</target>
        </trans-unit>
        <trans-unit id="d13f9c0d833baac358fedb3d5d5130ba389408d4" translate="yes" xml:space="preserve">
          <source>ecpg</source>
          <target state="translated">ecpg</target>
        </trans-unit>
        <trans-unit id="ee8426e3ae205f6a4fbf14400afc72dbe65a18e6" translate="yes" xml:space="preserve">
          <source>ecpg &amp;mdash; embedded SQL C preprocessor</source>
          <target state="translated">ecpg &amp;mdash;埋め込みSQL Cプリプロセッサ</target>
        </trans-unit>
        <trans-unit id="431fd257c42ba97d31ee98637d51749f58818b72" translate="yes" xml:space="preserve">
          <source>element is contained by</source>
          <target state="translated">要素は</target>
        </trans-unit>
        <trans-unit id="7fd8de61bf0672691fbb98aab87cd593aeaf89f4" translate="yes" xml:space="preserve">
          <source>element-to-array concatenation</source>
          <target state="translated">要素配列連結</target>
        </trans-unit>
        <trans-unit id="ab2afe87d80f8f35bf989060afa3c6ac12a43886" translate="yes" xml:space="preserve">
          <source>enable verbose internal logging</source>
          <target state="translated">内部ログの詳細化を有効にする</target>
        </trans-unit>
        <trans-unit id="7cbe751985c35402c31394cb0929695fc5649328" translate="yes" xml:space="preserve">
          <source>encoding conversion information</source>
          <target state="translated">符号化変換情報</target>
        </trans-unit>
        <trans-unit id="1671ca77906f61454bce6768a91e2e8e821e8948" translate="yes" xml:space="preserve">
          <source>enum label and value definitions</source>
          <target state="translated">列挙ラベルと値の定義</target>
        </trans-unit>
        <trans-unit id="f57b2d312d9efe8fe993c8eb1f3e19d41ad04030" translate="yes" xml:space="preserve">
          <source>equal</source>
          <target state="translated">equal</target>
        </trans-unit>
        <trans-unit id="44040a02784585bdd6249b4edd2dd94238188e6f" translate="yes" xml:space="preserve">
          <source>equal, treating null like an ordinary value</source>
          <target state="translated">等しく、ヌルを通常の値のように扱います。</target>
        </trans-unit>
        <trans-unit id="80b2f559a14748525776894e12e1216b49b5b558" translate="yes" xml:space="preserve">
          <source>equals</source>
          <target state="translated">equals</target>
        </trans-unit>
        <trans-unit id="f18bd7a51999b2b1d95efa4274723b39e0ac6b39" translate="yes" xml:space="preserve">
          <source>equivalent to &lt;code&gt;bool_and&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;bool_and&lt;/code&gt; と同等</target>
        </trans-unit>
        <trans-unit id="a4232efd7b52fa7af1f07ed9b444c78b5cec9a81" translate="yes" xml:space="preserve">
          <source>equivalent to &lt;code&gt;current_user&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;current_user&lt;/code&gt; と同等</target>
        </trans-unit>
        <trans-unit id="65b09de7c4f948564eb4e9f8a8c8ad7481598866" translate="yes" xml:space="preserve">
          <source>era indicator (with periods)</source>
          <target state="translated">じだいしじ</target>
        </trans-unit>
        <trans-unit id="24e96aa5ab5679037b391de37b4ce482d43684f1" translate="yes" xml:space="preserve">
          <source>era indicator (without periods)</source>
          <target state="translated">じだいしじ</target>
        </trans-unit>
        <trans-unit id="cdecabe1520a398e4e46deff9d55b19bed6d6457" translate="yes" xml:space="preserve">
          <source>escape</source>
          <target state="translated">escape</target>
        </trans-unit>
        <trans-unit id="be464074e84929b3edb1afc53993489c2a50213d" translate="yes" xml:space="preserve">
          <source>even though there will really be zero rows satisfying this query. Functional dependency statistics do not provide enough information to conclude that, however.</source>
          <target state="translated">を満たす行は実際にはゼロであるにもかかわらず、このクエリを満足させることはできません。しかし、機能依存性統計では、その結論を出すのに十分な情報は得られません。</target>
        </trans-unit>
        <trans-unit id="b2fe05583b44066ff5424d20e6314b48bc6e0ea7" translate="yes" xml:space="preserve">
          <source>even though they had no intention of ever using &lt;code&gt;y&lt;/code&gt; as part of a &lt;code&gt;WHERE&lt;/code&gt; clause. This works fine as long as the extra columns are trailing columns; making them be leading columns is unwise for the reasons explained in &lt;a href=&quot;indexes-multicolumn&quot;&gt;Section 11.3&lt;/a&gt;. However, this method doesn't support the case where you want the index to enforce uniqueness on the key column(s).</source>
          <target state="translated">彼らは &lt;code&gt;WHERE&lt;/code&gt; 句の一部として &lt;code&gt;y&lt;/code&gt; を使用するつもりはありませんでした。追加の列が後続列である限り、これは正常に機能します。&lt;a href=&quot;indexes-multicolumn&quot;&gt;セクション11.3で&lt;/a&gt;説明する理由により、それらを先行列にすることは賢明ではありません。ただし、このメソッドは、インデックスでキー列に一意性を強制する場合をサポートしていません。</target>
        </trans-unit>
        <trans-unit id="7833e7d391c504aee68e45dea9634b1c53821bff" translate="yes" xml:space="preserve">
          <source>event triggers</source>
          <target state="translated">イベントトリガー</target>
        </trans-unit>
        <trans-unit id="f5caa8594147ec7c253638db4988e8f1141145c5" translate="yes" xml:space="preserve">
          <source>eventlog</source>
          <target state="translated">eventlog</target>
        </trans-unit>
        <trans-unit id="a1369004de61926651324b802d6bf7dde40d8308" translate="yes" xml:space="preserve">
          <source>exact numeric of selectable precision</source>
          <target state="translated">選択可能精度の正確な数値</target>
        </trans-unit>
        <trans-unit id="910088c467ddca75f7465dd40037d50a4b1024d5" translate="yes" xml:space="preserve">
          <source>exactly one of &lt;code&gt;A&lt;/code&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;code&gt;B&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt;&lt;code&gt;=&lt;/code&gt;&lt;code&gt;B&lt;/code&gt;, and &lt;code&gt;B&lt;/code&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;code&gt;A&lt;/code&gt; is true (&lt;em&gt;trichotomy law&lt;/em&gt;)</source>
          <target state="translated">正確に一つの &lt;code&gt;A&lt;/code&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;code&gt;B&lt;/code&gt; 、 &lt;code&gt;A&lt;/code&gt; &lt;code&gt;=&lt;/code&gt; &lt;code&gt;B&lt;/code&gt; 、及び &lt;code&gt;B&lt;/code&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;code&gt;A&lt;/code&gt; が真である（&lt;em&gt;trichotomy法&lt;/em&gt;）</target>
        </trans-unit>
        <trans-unit id="98585ed8f50402fa8abbe3b11d352d8c7b352517" translate="yes" xml:space="preserve">
          <source>expand a &lt;code&gt;tsvector&lt;/code&gt; to a set of rows</source>
          <target state="translated">拡大 &lt;code&gt;tsvector&lt;/code&gt; 行のセットに</target>
        </trans-unit>
        <trans-unit id="f1b33fd39221d674e864b833837123f8c9c566a5" translate="yes" xml:space="preserve">
          <source>expand an array to a set of rows</source>
          <target state="translated">配列を行の集合に展開する</target>
        </trans-unit>
        <trans-unit id="b4177b3fdd9f1dcef4246133756c7d4295ee3473" translate="yes" xml:space="preserve">
          <source>expand multiple arrays (possibly of different types) to a set of rows. This is only allowed in the FROM clause; see &lt;a href=&quot;queries-table-expressions#QUERIES-TABLEFUNCTIONS&quot;&gt;Section 7.2.1.4&lt;/a&gt;</source>
          <target state="translated">複数の配列（タイプが異なる可能性があります）を行のセットに拡張します。これはFROM句でのみ許可されます。&lt;a href=&quot;queries-table-expressions#QUERIES-TABLEFUNCTIONS&quot;&gt;セクション7.2.1.4を&lt;/a&gt;参照</target>
        </trans-unit>
        <trans-unit id="4500e56b5a24d60ce7b2499c19162fb567e578b4" translate="yes" xml:space="preserve">
          <source>expanded syntax (see below)</source>
          <target state="translated">拡張構文</target>
        </trans-unit>
        <trans-unit id="51a433a570f5960fccaccfbfa93909e78f841178" translate="yes" xml:space="preserve">
          <source>exponent for scientific notation</source>
          <target state="translated">かがくひょうきほうしすう</target>
        </trans-unit>
        <trans-unit id="dc606218848a18d5c34862a175d29c1fe03c13d9" translate="yes" xml:space="preserve">
          <source>exponential</source>
          <target state="translated">exponential</target>
        </trans-unit>
        <trans-unit id="1e78ce1a1f32081b3133e35ca2ce8f4369be90ee" translate="yes" xml:space="preserve">
          <source>exponentially-distributed random integer in &lt;code&gt;[lb, ub]&lt;/code&gt;, see below</source>
          <target state="translated">&lt;code&gt;[lb, ub]&lt;/code&gt; 指数分布ランダム整数、以下を参照</target>
        </trans-unit>
        <trans-unit id="1d422390c5a3d1333fb7f5d97621fa0f6e7f0d6c" translate="yes" xml:space="preserve">
          <source>exponentiation</source>
          <target state="translated">exponentiation</target>
        </trans-unit>
        <trans-unit id="0db5a9a232a6935699542e335a56a8df9f43d2e9" translate="yes" xml:space="preserve">
          <source>exponentiation (associates left to right)</source>
          <target state="translated">しょうすう</target>
        </trans-unit>
        <trans-unit id="5d7f1bff34ea278c6c5a2fc91295c8a87607dc57" translate="yes" xml:space="preserve">
          <source>extended planner statistics</source>
          <target state="translated">拡張プランナー統計</target>
        </trans-unit>
        <trans-unit id="cc65f5c101ab8b09f58273801d736b9e9677d0e8" translate="yes" xml:space="preserve">
          <source>extended planner statistics (built statistics)</source>
          <target state="translated">拡張プランナー統計</target>
        </trans-unit>
        <trans-unit id="6d557d048a3b2c532f56398c201f9c70fcd3184e" translate="yes" xml:space="preserve">
          <source>extended planner statistics (definition)</source>
          <target state="translated">拡張プランナー統計</target>
        </trans-unit>
        <trans-unit id="b56ba1d1de71303ba9e7ac7e6d37ccee335d2140" translate="yes" xml:space="preserve">
          <source>external node identifier</source>
          <target state="translated">外部ノード識別子</target>
        </trans-unit>
        <trans-unit id="8cea632a3c2f5380e27bf9754368859382f731f4" translate="yes" xml:space="preserve">
          <source>extract IP address and netmask length as text</source>
          <target state="translated">IP アドレスとネットマスクの長さをテキストとして抽出</target>
        </trans-unit>
        <trans-unit id="1adf6634d9f5912d39aae24816f962b74dbd1d3d" translate="yes" xml:space="preserve">
          <source>extract IP address as text</source>
          <target state="translated">IPアドレスをテキストとして抽出する</target>
        </trans-unit>
        <trans-unit id="52224bb43ff5437ccb717a45646600f74c89bca0" translate="yes" xml:space="preserve">
          <source>extract a subset of an &lt;code&gt;hstore&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;hstore&lt;/code&gt; のサブセットを抽出する</target>
        </trans-unit>
        <trans-unit id="6a0f78ab60fe16f14c77cc85e268514510fb939e" translate="yes" xml:space="preserve">
          <source>extract family of address; &lt;code&gt;4&lt;/code&gt; for IPv4, &lt;code&gt;6&lt;/code&gt; for IPv6</source>
          <target state="translated">アドレスのファミリを抽出します。 &lt;code&gt;4&lt;/code&gt; IPv4の場合、 &lt;code&gt;6&lt;/code&gt; IPv6の</target>
        </trans-unit>
        <trans-unit id="63b60e17da1c01c315490ec61d92c6ae1b9cfac1" translate="yes" xml:space="preserve">
          <source>extract netmask length</source>
          <target state="translated">ネットマスク長を抽出</target>
        </trans-unit>
        <trans-unit id="8eb7d749717b314ca4b624308f167fb8f0536c57" translate="yes" xml:space="preserve">
          <source>extract network part of address</source>
          <target state="translated">アドレスのネットワーク部分を抽出</target>
        </trans-unit>
        <trans-unit id="cf2f15ec5a30d6402b8a8b59c0f122369583dbf1" translate="yes" xml:space="preserve">
          <source>f(x) = PHI(2.0 * parameter * (x - mu) / (max - min + 1)) / (2.0 * PHI(parameter) - 1)</source>
          <target state="translated">f(x)=PHI(2.0*パラメータ*(x-mu)/(max-min+1)/(2.0*PHI(パラメータ)-1)</target>
        </trans-unit>
        <trans-unit id="d8ecaf8c657a2b137edff4403d3015c673733131" translate="yes" xml:space="preserve">
          <source>f(x) = exp(-parameter * (x - min) / (max - min + 1)) / (1 - exp(-parameter))</source>
          <target state="translated">f(x)=exp(-パラメータ*(x-min)/(max-min+1)/(1-exp(-パラメータ))</target>
        </trans-unit>
        <trans-unit id="2bd70faaff2dc3145c4f93d20179cef8d5fd1bdd" translate="yes" xml:space="preserve">
          <source>factorial</source>
          <target state="translated">factorial</target>
        </trans-unit>
        <trans-unit id="30d4e08f4264897498d5f939d1ac8e6b0526d163" translate="yes" xml:space="preserve">
          <source>factorial (prefix operator)</source>
          <target state="translated">階乗演算子</target>
        </trans-unit>
        <trans-unit id="519c2566cb819aa98f00c389f875acd6c2f82fd8" translate="yes" xml:space="preserve">
          <source>field size</source>
          <target state="translated">フィールドサイズ</target>
        </trans-unit>
        <trans-unit id="3a88b38ae3a3604d3f1af4ad93ba5fe6fb9f87bc" translate="yes" xml:space="preserve">
          <source>file_fdw</source>
          <target state="translated">file_fdw</target>
        </trans-unit>
        <trans-unit id="983401d0e918dc765c97b567a565058e6af554ed" translate="yes" xml:space="preserve">
          <source>fill mode (suppress leading zeroes and padding blanks)</source>
          <target state="translated">塗りつぶしモード (先頭のゼロと空白のパディングを抑制)</target>
        </trans-unit>
        <trans-unit id="a5e4a7072f8551b572a1cee1a88417461488e2a7" translate="yes" xml:space="preserve">
          <source>fill mode (suppress trailing zeroes and padding blanks)</source>
          <target state="translated">塗りつぶしモード (末尾のゼロと空白のパディングを抑制)</target>
        </trans-unit>
        <trans-unit id="32003507876dacdf67e2131262acee891800afea" translate="yes" xml:space="preserve">
          <source>first array entry that is a descendant of &lt;code&gt;ltree&lt;/code&gt;; NULL if none</source>
          <target state="translated">&lt;code&gt;ltree&lt;/code&gt; の子孫である最初の配列エントリ。ない場合はNULL</target>
        </trans-unit>
        <trans-unit id="515013b791f433a9eae1982ebea0e32381eccb14" translate="yes" xml:space="preserve">
          <source>first array entry that is an ancestor of &lt;code&gt;ltree&lt;/code&gt;; NULL if none</source>
          <target state="translated">&lt;code&gt;ltree&lt;/code&gt; の祖先である最初の配列エントリ。ない場合はNULL</target>
        </trans-unit>
        <trans-unit id="5a3fdedfab8428272c62bd9bbab1aa027083b860" translate="yes" xml:space="preserve">
          <source>first array entry that matches &lt;code&gt;lquery&lt;/code&gt;; NULL if none</source>
          <target state="translated">&lt;code&gt;lquery&lt;/code&gt; に一致する最初の配列エントリ。ない場合はNULL</target>
        </trans-unit>
        <trans-unit id="086d1f932d7df2500f28084d6285586dd205f44c" translate="yes" xml:space="preserve">
          <source>first array entry that matches &lt;code&gt;ltxtquery&lt;/code&gt;; NULL if none</source>
          <target state="translated">&lt;code&gt;ltxtquery&lt;/code&gt; に一致する最初の配列エントリ。ない場合はNULL</target>
        </trans-unit>
        <trans-unit id="25970e09bd0194f53db323fdee569ecc5ee9d06a" translate="yes" xml:space="preserve">
          <source>fixed format global option (see usage notes)</source>
          <target state="translated">固定フォーマットグローバルオプション(使用上の注意を参照)。</target>
        </trans-unit>
        <trans-unit id="f6a11edd2a4d248a530de4d7e132bac84862a375" translate="yes" xml:space="preserve">
          <source>fixed-length bit string</source>
          <target state="translated">固定長ビット列</target>
        </trans-unit>
        <trans-unit id="dcb97d9db2463758f31c0de9d3bce9df50408dfb" translate="yes" xml:space="preserve">
          <source>fixed-length character string</source>
          <target state="translated">固定長文字列</target>
        </trans-unit>
        <trans-unit id="223f2208f7d4b1043c7e491f40e2e2d8ed03ae8b" translate="yes" xml:space="preserve">
          <source>fixed-length, blank padded</source>
          <target state="translated">定尺</target>
        </trans-unit>
        <trans-unit id="42f81371a9d58223349ec7034da245db8ada9ccd" translate="yes" xml:space="preserve">
          <source>flag (name of the affix class)</source>
          <target state="translated">フラグ</target>
        </trans-unit>
        <trans-unit id="b0163776e81d6187e8b5cfa662418933736608b6" translate="yes" xml:space="preserve">
          <source>flags identifying &lt;code&gt;NULL&lt;/code&gt; values</source>
          <target state="translated">&lt;code&gt;NULL&lt;/code&gt; 値を識別するフラグ</target>
        </trans-unit>
        <trans-unit id="93d9feb10aec6e36f31762cbd4d5259b39c8aceb" translate="yes" xml:space="preserve">
          <source>foreign server definitions</source>
          <target state="translated">がいこくサーバー定義</target>
        </trans-unit>
        <trans-unit id="0d25df728aebb140e50bd8e011aaf8a6c6258f90" translate="yes" xml:space="preserve">
          <source>foreign-data wrapper definitions</source>
          <target state="translated">外部データラッパー定義</target>
        </trans-unit>
        <trans-unit id="cacfbd40505fff5a97d7effce15468bbc881b94d" translate="yes" xml:space="preserve">
          <source>form feed</source>
          <target state="translated">フォームフィード</target>
        </trans-unit>
        <trans-unit id="e03c80c93af95df14136862d42780c28c008d0cd" translate="yes" xml:space="preserve">
          <source>form feed, as in C</source>
          <target state="translated">のように、フォームフィード</target>
        </trans-unit>
        <trans-unit id="170f5a3f34787c6aab8fa71dfbca18211e9264aa" translate="yes" xml:space="preserve">
          <source>fraction of the asynchronous notification queue currently occupied (0-1)</source>
          <target state="translated">現在使用されている非同期通知キューの割合 (0-1)</target>
        </trans-unit>
        <trans-unit id="b5b60b504526b12a5eff5f8bd8a0e84a7249041e" translate="yes" xml:space="preserve">
          <source>frequency of this MCV item</source>
          <target state="translated">本MCV項目の頻度</target>
        </trans-unit>
        <trans-unit id="0fd4434dbd8cb20c8f7359b16e3d296dc62d764e" translate="yes" xml:space="preserve">
          <source>from the SQL environment, or:</source>
          <target state="translated">をSQL環境から取得するか</target>
        </trans-unit>
        <trans-unit id="ba98c5a979f1d430811c4a4f29ea3a0721cf65fc" translate="yes" xml:space="preserve">
          <source>from the shell.</source>
          <target state="translated">殻の中から</target>
        </trans-unit>
        <trans-unit id="280f7dd2055e25f7e89bbec785c710da22de8e5a" translate="yes" xml:space="preserve">
          <source>from the shell. Only the superuser is allowed to create a database for someone else (that is, for a role you are not a member of).</source>
          <target state="translated">をシェルから実行します。スーパーユーザだけが他の誰かのためにデータベースを作成することができます(つまり、あなたがメンバーではないロールのために)。</target>
        </trans-unit>
        <trans-unit id="15af0e8bf417a69fca0c301e28c0685d91c4b491" translate="yes" xml:space="preserve">
          <source>full capitalized day name (blank-padded to 9 chars)</source>
          <target state="translated">全角英数字の日名</target>
        </trans-unit>
        <trans-unit id="c4a997d97658b2cf2b8d26ebdf86435fc5ee3692" translate="yes" xml:space="preserve">
          <source>full capitalized month name (blank-padded to 9 chars)</source>
          <target state="translated">完全大文字の月名(9文字に空白を追加)</target>
        </trans-unit>
        <trans-unit id="5a16a10dfdd5e4a2703b7455bf1f1425a37e5980" translate="yes" xml:space="preserve">
          <source>full lower case day name (blank-padded to 9 chars)</source>
          <target state="translated">完全な小文字の曜日名(9文字に空白でパッドされたもの</target>
        </trans-unit>
        <trans-unit id="f00512a393e028490b88f3aa5ebbe3549d7e487f" translate="yes" xml:space="preserve">
          <source>full lower case month name (blank-padded to 9 chars)</source>
          <target state="translated">完全な小文字の月名 (9文字に空白でパッドされた)</target>
        </trans-unit>
        <trans-unit id="42477234123d86e358924810115cf7e4102d895a" translate="yes" xml:space="preserve">
          <source>full upper case day name (blank-padded to 9 chars)</source>
          <target state="translated">完全な大文字の曜日名(9文字に空白でパッドされています</target>
        </trans-unit>
        <trans-unit id="6d1edcedc94dd056218887a634de10777f3b1f06" translate="yes" xml:space="preserve">
          <source>full upper case month name (blank-padded to 9 chars)</source>
          <target state="translated">完全な大文字の月名(9文字に空白でパッドされたもの</target>
        </trans-unit>
        <trans-unit id="1105c0cc10eb74d7fc4c164ddb5ce386bb49d61b" translate="yes" xml:space="preserve">
          <source>function name</source>
          <target state="translated">関数名</target>
        </trans-unit>
        <trans-unit id="79337461ae50346a3c64aedc6576d26f07d2da99" translate="yes" xml:space="preserve">
          <source>function to merge two elements</source>
          <target state="translated">ふたつの要素をマージする関数</target>
        </trans-unit>
        <trans-unit id="381ba103b087ce725ad29d6fb3167623521eab03" translate="yes" xml:space="preserve">
          <source>function with argument types</source>
          <target state="translated">引数型付き関数</target>
        </trans-unit>
        <trans-unit id="d68671ea551cf0ba52601309c38f48f032157b66" translate="yes" xml:space="preserve">
          <source>functions and operators for processing and creating JSON data</source>
          <target state="translated">JSONデータを処理・作成するための関数と演算子</target>
        </trans-unit>
        <trans-unit id="2b9a1162c90a10eaa1c1d22357b7148a2281502d" translate="yes" xml:space="preserve">
          <source>functions and procedures</source>
          <target state="translated">きのうてつづき</target>
        </trans-unit>
        <trans-unit id="eb3a477dc4afde1f163053db118d49c3a03b5564" translate="yes" xml:space="preserve">
          <source>further limited by tuple size fitting on a single page; see note below</source>
          <target state="translated">一枚のページにタプルサイズがフィットすることでさらに制限されています;下記の注意事項を参照してください。</target>
        </trans-unit>
        <trans-unit id="a52bca9149e86a7c11c1c387784ebae5aaedd68c" translate="yes" xml:space="preserve">
          <source>fuzzystrmatch</source>
          <target state="translated">fuzzystrmatch</target>
        </trans-unit>
        <trans-unit id="8c0aaf10dcd6bcacc121f7b404cf2264a1048fdc" translate="yes" xml:space="preserve">
          <source>generation of ancestors at a time t</source>
          <target state="translated">祖代</target>
        </trans-unit>
        <trans-unit id="e9092fbeebad65d675ea2563bb6ea87d206977be" translate="yes" xml:space="preserve">
          <source>generation of descendants at a time t</source>
          <target state="translated">世代</target>
        </trans-unit>
        <trans-unit id="8f26ec92a3e06fc1bd67c0ec5e3b881f007ba31d" translate="yes" xml:space="preserve">
          <source>geometric path on a plane</source>
          <target state="translated">平面上の幾何学的経路</target>
        </trans-unit>
        <trans-unit id="5ae39128635d531b866a9705ccff8372c2803a08" translate="yes" xml:space="preserve">
          <source>geometric point on a plane</source>
          <target state="translated">平面上の点</target>
        </trans-unit>
        <trans-unit id="3c5902d9d1907e1e688e601d8dea2602b582cd8e" translate="yes" xml:space="preserve">
          <source>get &lt;code&gt;CREATE INDEX&lt;/code&gt; command for index</source>
          <target state="translated">インデックスの &lt;code&gt;CREATE INDEX&lt;/code&gt; コマンドを取得する</target>
        </trans-unit>
        <trans-unit id="a3ec23c0e08fffde0bbe5f680221fb2baaef5bd5" translate="yes" xml:space="preserve">
          <source>get &lt;code&gt;CREATE INDEX&lt;/code&gt; command for index, or definition of just one index column when &lt;em&gt;&lt;code&gt;column_no&lt;/code&gt;&lt;/em&gt; is not zero</source>
          <target state="translated">インデックスの &lt;code&gt;CREATE INDEX&lt;/code&gt; コマンドを取得するか、&lt;em&gt; &lt;code&gt;column_no&lt;/code&gt; &lt;/em&gt;がゼロでない場合は1つのインデックス列のみを定義します</target>
        </trans-unit>
        <trans-unit id="196b69b47830d30e71241d4bd8b0fab2ca945d23" translate="yes" xml:space="preserve">
          <source>get &lt;code&gt;CREATE RULE&lt;/code&gt; command for rule</source>
          <target state="translated">ルールの &lt;code&gt;CREATE RULE&lt;/code&gt; コマンドを取得する</target>
        </trans-unit>
        <trans-unit id="2bd218c54320163748989ae51ee788d92b994ad7" translate="yes" xml:space="preserve">
          <source>get &lt;code&gt;CREATE STATISTICS&lt;/code&gt; command for extended statistics object</source>
          <target state="translated">拡張統計オブジェクトの &lt;code&gt;CREATE STATISTICS&lt;/code&gt; コマンドを取得する</target>
        </trans-unit>
        <trans-unit id="2dce21084875e338db2211be806cce40af161367" translate="yes" xml:space="preserve">
          <source>get &lt;code&gt;CREATE [ CONSTRAINT ] TRIGGER&lt;/code&gt; command for trigger</source>
          <target state="translated">トリガーの &lt;code&gt;CREATE [ CONSTRAINT ] TRIGGER&lt;/code&gt; コマンドを取得</target>
        </trans-unit>
        <trans-unit id="af0a1a4c510167b0be953ce464e30ebb21bbb406" translate="yes" xml:space="preserve">
          <source>get &lt;code&gt;RETURNS&lt;/code&gt; clause for function (returns null for a procedure)</source>
          <target state="translated">関数の &lt;code&gt;RETURNS&lt;/code&gt; 句を取得します（プロシージャの場合はnullを返します）</target>
        </trans-unit>
        <trans-unit id="22f30c887b27700ca538951254039e1464d1cdd5" translate="yes" xml:space="preserve">
          <source>get &lt;code&gt;aclitem&lt;/code&gt; array as tuples</source>
          <target state="translated">タプルとして &lt;code&gt;aclitem&lt;/code&gt; 配列を取得する</target>
        </trans-unit>
        <trans-unit id="937dcfc31310a1d87c64ad58c35d643c3dbb2cef" translate="yes" xml:space="preserve">
          <source>get &lt;code&gt;hstore&lt;/code&gt; as a &lt;code&gt;json&lt;/code&gt; value, but attempt to distinguish numerical and Boolean values so they are unquoted in the JSON</source>
          <target state="translated">GET &lt;code&gt;hstore&lt;/code&gt; のよう &lt;code&gt;json&lt;/code&gt; 値が、彼らはJSONに引用符で囲まれて、数値やブール値を区別しようと</target>
        </trans-unit>
        <trans-unit id="fe0b67a6cd7df0e277a3dcb3562abb8976f3d94c" translate="yes" xml:space="preserve">
          <source>get &lt;code&gt;hstore&lt;/code&gt; as a &lt;code&gt;json&lt;/code&gt; value, converting all non-null values to JSON strings</source>
          <target state="translated">&lt;code&gt;hstore&lt;/code&gt; を &lt;code&gt;json&lt;/code&gt; 値として取得し、null以外のすべての値をJSON文字列に変換します</target>
        </trans-unit>
        <trans-unit id="6ae7444ae534490ab8b85dfd69c23426f2b097e0" translate="yes" xml:space="preserve">
          <source>get &lt;code&gt;hstore&lt;/code&gt; as a &lt;code&gt;jsonb&lt;/code&gt; value, but attempt to distinguish numerical and Boolean values so they are unquoted in the JSON</source>
          <target state="translated">&lt;code&gt;hstore&lt;/code&gt; を &lt;code&gt;jsonb&lt;/code&gt; 値として取得しますが、数値とブール値を区別して、JSONで引用符で囲まれないようにします</target>
        </trans-unit>
        <trans-unit id="e18937d566312b9c933716239bd0a1b2cab0e0bf" translate="yes" xml:space="preserve">
          <source>get &lt;code&gt;hstore&lt;/code&gt; as a &lt;code&gt;jsonb&lt;/code&gt; value, converting all non-null values to JSON strings</source>
          <target state="translated">&lt;code&gt;hstore&lt;/code&gt; を &lt;code&gt;jsonb&lt;/code&gt; 値として取得し、null以外のすべての値をJSON文字列に変換します</target>
        </trans-unit>
        <trans-unit id="9d860c2d98eb0770214f44f458048681c29c6293" translate="yes" xml:space="preserve">
          <source>get &lt;code&gt;hstore&lt;/code&gt;'s keys and values as a set</source>
          <target state="translated">&lt;code&gt;hstore&lt;/code&gt; のキーと値をセットとして取得します</target>
        </trans-unit>
        <trans-unit id="8b81abcbdffa1d36be6f3db92afd0c712b05149f" translate="yes" xml:space="preserve">
          <source>get &lt;code&gt;hstore&lt;/code&gt;'s keys and values as a two-dimensional array</source>
          <target state="translated">&lt;code&gt;hstore&lt;/code&gt; のキーと値を2次元配列として取得します</target>
        </trans-unit>
        <trans-unit id="7732475b39d72d6d44dd2efd78c07a49212ac801" translate="yes" xml:space="preserve">
          <source>get &lt;code&gt;hstore&lt;/code&gt;'s keys and values as an array of alternating keys and values</source>
          <target state="translated">&lt;code&gt;hstore&lt;/code&gt; のキーと値を、交互のキーと値の配列として取得します</target>
        </trans-unit>
        <trans-unit id="3f21a27616331d2636099cf4cc88b18f8e29a805" translate="yes" xml:space="preserve">
          <source>get &lt;code&gt;hstore&lt;/code&gt;'s keys as a set</source>
          <target state="translated">&lt;code&gt;hstore&lt;/code&gt; のキーをセットとして取得します</target>
        </trans-unit>
        <trans-unit id="dc9a8f1f8f4ef349c79e43b0211eead30fe502f3" translate="yes" xml:space="preserve">
          <source>get &lt;code&gt;hstore&lt;/code&gt;'s keys as an array</source>
          <target state="translated">&lt;code&gt;hstore&lt;/code&gt; のキーを配列として取得します</target>
        </trans-unit>
        <trans-unit id="536f1dece096291af39df61eb1a0b2a7eaf9983d" translate="yes" xml:space="preserve">
          <source>get &lt;code&gt;hstore&lt;/code&gt;'s values as a set</source>
          <target state="translated">&lt;code&gt;hstore&lt;/code&gt; の値をセットとして取得します</target>
        </trans-unit>
        <trans-unit id="5251a2aba056bba63a67d56fc4203ed79712e3e4" translate="yes" xml:space="preserve">
          <source>get &lt;code&gt;hstore&lt;/code&gt;'s values as an array</source>
          <target state="translated">&lt;code&gt;hstore&lt;/code&gt; の値を配列として取得します</target>
        </trans-unit>
        <trans-unit id="ad8730c72dc5b463ea8cac770153712d6576278e" translate="yes" xml:space="preserve">
          <source>get &lt;code&gt;xmax&lt;/code&gt; of snapshot</source>
          <target state="translated">スナップショットの &lt;code&gt;xmax&lt;/code&gt; を取得</target>
        </trans-unit>
        <trans-unit id="3ed704a6f174339573cf0c434a1db7a555f66cec" translate="yes" xml:space="preserve">
          <source>get &lt;code&gt;xmin&lt;/code&gt; of snapshot</source>
          <target state="translated">スナップショットの &lt;code&gt;xmin&lt;/code&gt; を取得</target>
        </trans-unit>
        <trans-unit id="337b585e11d46bb402f4a4cec72193fc16d86d74" translate="yes" xml:space="preserve">
          <source>get SQL name of a data type</source>
          <target state="translated">データ型のSQL名を取得</target>
        </trans-unit>
        <trans-unit id="c2ee42154b8befeb7b402a3997c784dac4cdd3a2" translate="yes" xml:space="preserve">
          <source>get address of a database object from its external representation</source>
          <target state="translated">外部表現からデータベースオブジェクトのアドレスを取得します。</target>
        </trans-unit>
        <trans-unit id="05dd67a0eb2fea988f4c7bff60b25d5bcfd72760" translate="yes" xml:space="preserve">
          <source>get argument list of function's or procedure's definition (with default values)</source>
          <target state="translated">関数やプロシージャの定義の引数リストを取得します。</target>
        </trans-unit>
        <trans-unit id="c519a3e8267da358402769c054226a03635c67ee" translate="yes" xml:space="preserve">
          <source>get argument list to identify a function or procedure (without default values)</source>
          <target state="translated">関数や手続きを識別するための引数リストを取得します (デフォルト値はありません)</target>
        </trans-unit>
        <trans-unit id="6b32a6038832e813790af0776307cf7b231fbb8e" translate="yes" xml:space="preserve">
          <source>get comment for a database object</source>
          <target state="translated">データベースオブジェクトのコメントを取得する</target>
        </trans-unit>
        <trans-unit id="362276384bf1063fb473a3d69cd61ec994e9c173" translate="yes" xml:space="preserve">
          <source>get comment for a database object (&lt;em&gt;deprecated&lt;/em&gt;)</source>
          <target state="translated">データベースオブジェクトのコメントを取得（&lt;em&gt;非推奨&lt;/em&gt;）</target>
        </trans-unit>
        <trans-unit id="fb86807e0f1bd4d25c9ec5a1d13bea140bc18075" translate="yes" xml:space="preserve">
          <source>get comment for a shared database object</source>
          <target state="translated">共有データベースオブジェクトのコメントを取得します</target>
        </trans-unit>
        <trans-unit id="ff9969c90af75d2566e6867dd12ee5fce7632f50" translate="yes" xml:space="preserve">
          <source>get comment for a table column</source>
          <target state="translated">テーブルカラムのコメントを取得する</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
