<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="postgresql">
    <body>
      <group id="postgresql">
        <trans-unit id="99c46fa0bf1c41a332643fa4668a817dafffd6e4" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;planner/optimizer&lt;/em&gt; takes the (rewritten) query tree and creates a &lt;em&gt;query plan&lt;/em&gt; that will be the input to the &lt;em&gt;executor&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;プランナー/オプティマイザは、&lt;/em&gt;（書き換えられた）問い合わせツリーを受け取り、作成し&lt;em&gt;たクエリプラン&lt;/em&gt;に入力される&lt;em&gt;executorを&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="f0bfc85eac5f506c4396fe64f83cd201f163702b" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;rewrite system&lt;/em&gt; takes the query tree created by the parser stage and looks for any &lt;em&gt;rules&lt;/em&gt; (stored in the &lt;em&gt;system catalogs&lt;/em&gt;) to apply to the query tree. It performs the transformations given in the &lt;em&gt;rule bodies&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;書き換えシステムは&lt;/em&gt;任意のためのパーサステージとルックスで作成されたクエリツリーかかる&lt;em&gt;ルール&lt;/em&gt;（に保存されている&lt;em&gt;システムカタログを&lt;/em&gt;問い合わせツリーに適用します）。&lt;em&gt;ルール本体で&lt;/em&gt;指定された変換を実行します。</target>
        </trans-unit>
        <trans-unit id="daa9a547059ab18709c7d9a8b34e0eb273fde26d" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;transformation process&lt;/em&gt; does modifications and augmentations to the data structures returned by the parser.</source>
          <target state="translated">&lt;em&gt;変換プロセスは、&lt;/em&gt;パーサによって返されたデータ構造に修正及びオーグメンテーションを行います。</target>
        </trans-unit>
        <trans-unit id="6005c8d6a8d942aa977decf6b60a95978aaf5aab" translate="yes" xml:space="preserve">
          <source>The API for constructing generic WAL records is defined in &lt;code&gt;access/generic_xlog.h&lt;/code&gt; and implemented in &lt;code&gt;access/transam/generic_xlog.c&lt;/code&gt;.</source>
          <target state="translated">一般的なWALレコードを作成するためのAPIは、 &lt;code&gt;access/generic_xlog.h&lt;/code&gt; で定義され、access / transam / generic_xlog.cに実装されてい &lt;code&gt;access/transam/generic_xlog.c&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aaa78d1712bc527d8b8229b7cb39f829dcef0b7a" translate="yes" xml:space="preserve">
          <source>The B-tree operator family this entry sorts according to, if an ordering operator; zero if a search operator</source>
          <target state="translated">このエントリのB-tree演算子ファミリーは、順序付け演算子の場合はソートします。</target>
        </trans-unit>
        <trans-unit id="4717590c35f3a3113f7d473dbe7410d944c8d2f4" translate="yes" xml:space="preserve">
          <source>The BRIN interface has a high level of abstraction, requiring the access method implementer only to implement the semantics of the data type being accessed. The BRIN layer itself takes care of concurrency, logging and searching the index structure.</source>
          <target state="translated">BRINインタフェースは抽象度が高く、アクセス・メソッドの実装者は、アクセスされるデータ型のセマンティクスのみを実装する必要があります。BRIN層自体は、同時実行、ロギング、インデックス構造の検索を行います。</target>
        </trans-unit>
        <trans-unit id="12f1f91360cdc7254651ab3db114c105bbc973aa" translate="yes" xml:space="preserve">
          <source>The BRIN operator classes included in the standard distribution are documented in &lt;a href=&quot;brin-builtin-opclasses#BRIN-BUILTIN-OPCLASSES-TABLE&quot;&gt;Table 67.1&lt;/a&gt;. For more information see &lt;a href=&quot;https://www.postgresql.org/docs/12/brin.html&quot;&gt;Chapter 67&lt;/a&gt;.</source>
          <target state="translated">標準配布に含まれるBRIN演算子クラスは、&lt;a href=&quot;brin-builtin-opclasses#BRIN-BUILTIN-OPCLASSES-TABLE&quot;&gt;表67.1に&lt;/a&gt;記載されています。詳細については、&lt;a href=&quot;https://www.postgresql.org/docs/12/brin.html&quot;&gt;第67章を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="81c19a64f78d13b55febf5112697413cfeeb5aad" translate="yes" xml:space="preserve">
          <source>The BRIN operator classes included in the standard distribution are documented in &lt;a href=&quot;brin-builtin-opclasses#BRIN-BUILTIN-OPCLASSES-TABLE&quot;&gt;Table 67.1&lt;/a&gt;. For more information see &lt;a href=&quot;https://www.postgresql.org/docs/13/brin.html&quot;&gt;Chapter 67&lt;/a&gt;.</source>
          <target state="translated">標準ディストリビューションに含まれるBRINオペレータークラスは、&lt;a href=&quot;brin-builtin-opclasses#BRIN-BUILTIN-OPCLASSES-TABLE&quot;&gt;表67.1に&lt;/a&gt;記載されています。詳細については、&lt;a href=&quot;https://www.postgresql.org/docs/13/brin.html&quot;&gt;第67章を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="f61d2e62e5b85bf8f1a9692cb79be49a20ae4934" translate="yes" xml:space="preserve">
          <source>The DNS names or IP addresses of the RADIUS servers to connect to. This parameter is required.</source>
          <target state="translated">接続先のRADIUSサーバーのDNS名またはIPアドレス。このパラメータは必須です。</target>
        </trans-unit>
        <trans-unit id="05d73c5606dbc5d228281af7029fd60e51759995" translate="yes" xml:space="preserve">
          <source>The Double Metaphone system computes two &amp;ldquo;sounds like&amp;rdquo; strings for a given input string &amp;mdash; a &amp;ldquo;primary&amp;rdquo; and an &amp;ldquo;alternate&amp;rdquo;. In most cases they are the same, but for non-English names especially they can be a bit different, depending on pronunciation. These functions compute the primary and alternate codes:</source>
          <target state="translated">Double Metaphoneシステムは、特定の入力文字列に対して「プライマリ」と「代替」の2つの「サウンドのような」文字列を計算します。ほとんどの場合、それらは同じですが、英語以外の名前の場合、特に発音によっては少し異なる場合があります。これらの関数は、プライマリコードと代替コードを計算します。</target>
        </trans-unit>
        <trans-unit id="c8af7d6c825c894dd0eb03ecb26fae46fecd94c6" translate="yes" xml:space="preserve">
          <source>The Free Space Map is organized as a tree of FSM pages. The bottom level FSM pages store the free space available on each heap (or index) page, using one byte to represent each such page. The upper levels aggregate information from the lower levels.</source>
          <target state="translated">フリースペースマップは、FSM ページのツリーとして構成されています。最下層の FSM ページは、各ヒープ(またはインデックス)ページで利用可能な空き領域を格納し、各ページを表すために 1 バイトを使用します。上位レベルは下位レベルの情報を集約します。</target>
        </trans-unit>
        <trans-unit id="30fb294fef92ba7b2398333f6fd38e60940f0136" translate="yes" xml:space="preserve">
          <source>The GEQO module allows the PostgreSQL query optimizer to support large join queries effectively through non-exhaustive search.</source>
          <target state="translated">GEQOモジュールは、PostgreSQLの問い合わせオプティマイザが非網羅的な検索によって大規模な結合問い合わせを効果的にサポートすることを可能にします。</target>
        </trans-unit>
        <trans-unit id="9943a2120bd9e8c3e6721e67541600ca21fe96fa" translate="yes" xml:space="preserve">
          <source>The GEQO module approaches the query optimization problem as though it were the well-known traveling salesman problem (TSP). Possible query plans are encoded as integer strings. Each string represents the join order from one relation of the query to the next. For example, the join tree</source>
          <target state="translated">GEQOモジュールは、よく知られた巡回セールスマン問題(TSP)のように問い合わせ最適化問題にアプローチします。可能な問い合わせプランは整数の文字列としてエンコードされています。各文字列は、クエリのある関係から次の関係への結合順序を表します。例えば、結合木</target>
        </trans-unit>
        <trans-unit id="a13542c5aa9b5acc83ba91d19d31a9262ad99881" translate="yes" xml:space="preserve">
          <source>The GEQO planning process uses the standard planner code to generate plans for scans of individual relations. Then join plans are developed using the genetic approach. As shown above, each candidate join plan is represented by a sequence in which to join the base relations. In the initial stage, the GEQO code simply generates some possible join sequences at random. For each join sequence considered, the standard planner code is invoked to estimate the cost of performing the query using that join sequence. (For each step of the join sequence, all three possible join strategies are considered; and all the initially-determined relation scan plans are available. The estimated cost is the cheapest of these possibilities.) Join sequences with lower estimated cost are considered &amp;ldquo;more fit&amp;rdquo; than those with higher cost. The genetic algorithm discards the least fit candidates. Then new candidates are generated by combining genes of more-fit candidates &amp;mdash; that is, by using randomly-chosen portions of known low-cost join sequences to create new sequences for consideration. This process is repeated until a preset number of join sequences have been considered; then the best one found at any time during the search is used to generate the finished plan.</source>
          <target state="translated">GEQOの計画プロセスでは、標準の計画者コードを使用して、個々の関係のスキャンの計画を生成します。次に、遺伝的アプローチを使用して結合計画が作成されます。上記のように、各結合計画の候補は、基本関係を結合する順序で表されます。最初の段階では、GEQOコードは単にいくつかの可能な結合シーケンスをランダムに生成します。考慮される各結合シーケンスについて、標準のプランナーコードが呼び出され、その結合シーケンスを使用してクエリを実行するコストを見積もります。 （結合シーケンスの各ステップでは、3つの可能な結合戦略すべてが考慮されます。最初に決定されたすべての関係スキャンプランが利用可能です。推定コストは、これらの可能性の中で最も安価です。）推定コストが低い結合シーケンスは、「詳細コストが高いものよりもフィットします。遺伝的アルゴリズムは、最も適合度の低い候補を破棄します。次に、より適した候補の遺伝子を組み合わせて新しい候補を生成します。つまり、既知の低コストの結合シーケンスのランダムに選択された部分を使用して、検討用の新しいシーケンスを作成します。このプロセスは、事前設定された数の結合シーケンスが考慮されるまで繰り返されます。次に、検索中にいつでも見つかった最良のものを使用して、完成した計画を生成します。</target>
        </trans-unit>
        <trans-unit id="12d46a50018559dae87055222c8f226b8336aa38" translate="yes" xml:space="preserve">
          <source>The GIN implementation in PostgreSQL is primarily maintained by Teodor Sigaev and Oleg Bartunov. There is more information about GIN on their &lt;a href=&quot;http://www.sai.msu.su/~megera/wiki/Gin&quot;&gt;website&lt;/a&gt;.</source>
          <target state="translated">PostgreSQLのGIN実装は、主にTeodor SigaevとOleg Bartunovによって保守されています。彼らの&lt;a href=&quot;http://www.sai.msu.su/~megera/wiki/Gin&quot;&gt;ウェブサイトに&lt;/a&gt; GINに関する詳細情報があります。</target>
        </trans-unit>
        <trans-unit id="c2e1dce9027c2870a4be78df483750ab0dd368b7" translate="yes" xml:space="preserve">
          <source>The GIN interface has a high level of abstraction, requiring the access method implementer only to implement the semantics of the data type being accessed. The GIN layer itself takes care of concurrency, logging and searching the tree structure.</source>
          <target state="translated">GIN インターフェースは抽象度が高く、アクセスメソッドの実装者はアクセスされるデータ型のセマンティクスのみを実装する必要があります。GIN レイヤー自体は、同時実行、ロギング、ツリー構造の検索を行います。</target>
        </trans-unit>
        <trans-unit id="47e8892c842e09af9d1e34fe3c02e2f04b0f5d8f" translate="yes" xml:space="preserve">
          <source>The GNU Privacy Handbook.</source>
          <target state="translated">GNUプライバシーハンドブック。</target>
        </trans-unit>
        <trans-unit id="3d32f64c87806d58fdb89cae3ce39c10adecb6af" translate="yes" xml:space="preserve">
          <source>The High Precision Event Timer (HPET) is the preferred timer on systems where it's available and TSC is not accurate. The timer chip itself is programmable to allow up to 100 nanosecond resolution, but you may not see that much accuracy in your system clock.</source>
          <target state="translated">高精度イベントタイマー(HPET)は、使用可能でTSCが正確でないシステムで好まれるタイマーです。タイマーチップ自体は、最大100ナノ秒の分解能を可能にするようにプログラム可能ですが、システムクロックの精度はそれほど高くないかもしれません。</target>
        </trans-unit>
        <trans-unit id="daab10f496a1f89a75df255f2cd5f238cad28e22" translate="yes" xml:space="preserve">
          <source>The IP network address types, &lt;code&gt;cidr&lt;/code&gt; and &lt;code&gt;inet&lt;/code&gt;, support the usual comparison operators shown in &lt;a href=&quot;functions-comparison#FUNCTIONS-COMPARISON-OP-TABLE&quot;&gt;Table 9.1&lt;/a&gt; as well as the specialized operators and functions shown in &lt;a href=&quot;functions-net#CIDR-INET-OPERATORS-TABLE&quot;&gt;Table 9.38&lt;/a&gt; and &lt;a href=&quot;functions-net#CIDR-INET-FUNCTIONS-TABLE&quot;&gt;Table 9.39&lt;/a&gt;.</source>
          <target state="translated">IPネットワークアドレスタイプの &lt;code&gt;cidr&lt;/code&gt; と &lt;code&gt;inet&lt;/code&gt; は、&lt;a href=&quot;functions-comparison#FUNCTIONS-COMPARISON-OP-TABLE&quot;&gt;表9.1に&lt;/a&gt;示す通常の比較演算子と、&lt;a href=&quot;functions-net#CIDR-INET-OPERATORS-TABLE&quot;&gt;表9.38&lt;/a&gt;および&lt;a href=&quot;functions-net#CIDR-INET-FUNCTIONS-TABLE&quot;&gt;表9.39に&lt;/a&gt;示す特殊な演算子と関数をサポートします。</target>
        </trans-unit>
        <trans-unit id="db1ae3a20afea53927e5a775df1db6e7daba0537" translate="yes" xml:space="preserve">
          <source>The ISO 8601 week-numbering year that the date falls in (not applicable to intervals)</source>
          <target state="translated">日付が属するISO 8601の週番付年(間隔には適用されない</target>
        </trans-unit>
        <trans-unit id="a2f552c0c2f33843207363b12ed183813abd32ee" translate="yes" xml:space="preserve">
          <source>The Identification Protocol is not intended as an authorization or access control protocol.</source>
          <target state="translated">識別プロトコルは、認可またはアクセス制御プロトコルとして意図されたものではありません。</target>
        </trans-unit>
        <trans-unit id="34d3089a14d3fce4ff8f4421c9f8177fa0b6d74c" translate="yes" xml:space="preserve">
          <source>The Institute of Automatic Control at the University of Mining and Technology, in Freiberg, Germany, encountered some problems when it wanted to use PostgreSQL as the backend for a decision support knowledge based system for the maintenance of an electrical power grid. The DBMS needed to handle large join queries for the inference machine of the knowledge based system. The number of joins in these queries made using the normal query optimizer infeasible.</source>
          <target state="translated">ドイツのフライベルクにある鉱山工科大学の自動制御研究所では、電力網のメンテナンスのための意思決定支援知識ベースシステムのバックエンドとしてPostgreSQLを使用しようとした際に、いくつかの問題に遭遇しました。DBMSは、知識ベースのシステムの推論マシンのために大規模な結合クエリを処理する必要がありました。これらのクエリの結合数が多いため、通常のクエリオプティマイザを使用することができませんでした。</target>
        </trans-unit>
        <trans-unit id="aa9845a0dd3274b254c00b6f19f94269db7f2403" translate="yes" xml:space="preserve">
          <source>The Ispell dictionary template supports &lt;em&gt;morphological dictionaries&lt;/em&gt;, which can normalize many different linguistic forms of a word into the same lexeme. For example, an English Ispell dictionary can match all declensions and conjugations of the search term &lt;code&gt;bank&lt;/code&gt;, e.g., &lt;code&gt;banking&lt;/code&gt;, &lt;code&gt;banked&lt;/code&gt;, &lt;code&gt;banks&lt;/code&gt;, &lt;code&gt;banks'&lt;/code&gt;, and &lt;code&gt;bank's&lt;/code&gt;.</source>
          <target state="translated">Ispell辞書テンプレートは、&lt;em&gt;形態辞書を&lt;/em&gt;サポートしています。これは、単語のさまざまな言語形式を同じ語彙素に正規化できます。例えば、英語Ispellの辞書は、すべての曲用と検索語の活用一致させることができ &lt;code&gt;bank&lt;/code&gt; 、例えば、 &lt;code&gt;banking&lt;/code&gt; 、 &lt;code&gt;banked&lt;/code&gt; 、 &lt;code&gt;banks&lt;/code&gt; 、 &lt;code&gt;banks'&lt;/code&gt; 、および &lt;code&gt;bank's&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="282b226a01a92e56fbbd4540780287fee9277216" translate="yes" xml:space="preserve">
          <source>The Julian calendar was introduced by Julius Caesar in 45 BC. It was in common use in the Western world until the year 1582, when countries started changing to the Gregorian calendar. In the Julian calendar, the tropical year is approximated as 365 1/4 days = 365.25 days. This gives an error of about 1 day in 128 years.</source>
          <target state="translated">ユリウス暦は、紀元前45年にユリウス・シーザーによって導入されました。それは、各国がグレゴリオ暦に変更し始めた1582年まで、西欧世界で一般的に使用されていました。ユリウス暦では、熱帯の年は365 1/4日=365.25日と近似しています。これは128年で約1日の誤差を与えます。</target>
        </trans-unit>
        <trans-unit id="2e4c29ef7c0e6bc4328db2d150be07eebedb7c84" translate="yes" xml:space="preserve">
          <source>The LSN at which replay must begin on the indicated timeline in order to make use of this backup. The LSN is stored in the format normally used by PostgreSQL; that is, it is a string consisting of two strings of hexadecimal characters, each with a length of between 1 and 8, separated by a slash.</source>
          <target state="translated">このバックアップを利用するために、指定されたタイムライン上で再生を開始しなければならないLSN。LSNはPostgreSQLで通常使用される形式で格納されます。つまり、スラッシュで区切られた長さ1から8までの16進数文字の2つの文字列からなる文字列です。</target>
        </trans-unit>
        <trans-unit id="3cde8e59b22c9d6c409e59a264cd6d5133433aa8" translate="yes" xml:space="preserve">
          <source>The Locking Clause</source>
          <target state="translated">ロック条項</target>
        </trans-unit>
        <trans-unit id="813d5e4d57613a4c405c690aaab6fce9270d1bf4" translate="yes" xml:space="preserve">
          <source>The MAC address types, &lt;code&gt;macaddr&lt;/code&gt; and &lt;code&gt;macaddr8&lt;/code&gt;, support the usual comparison operators shown in &lt;a href=&quot;functions-comparison#FUNCTIONS-COMPARISON-OP-TABLE&quot;&gt;Table 9.1&lt;/a&gt; as well as the specialized functions shown in &lt;a href=&quot;functions-net#MACADDR-FUNCTIONS-TABLE&quot;&gt;Table 9.40&lt;/a&gt;. In addition, they support the bitwise logical operators &lt;code&gt;~&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt; and &lt;code&gt;|&lt;/code&gt; (NOT, AND and OR), just as shown above for IP addresses.</source>
          <target state="translated">MACアドレスタイプの &lt;code&gt;macaddr&lt;/code&gt; と &lt;code&gt;macaddr8&lt;/code&gt; は、&lt;a href=&quot;functions-comparison#FUNCTIONS-COMPARISON-OP-TABLE&quot;&gt;表9.1に&lt;/a&gt;示す通常の比較演算子と、&lt;a href=&quot;functions-net#MACADDR-FUNCTIONS-TABLE&quot;&gt;表9.40に&lt;/a&gt;示す特殊な関数をサポートしています。さらに、ビット単位の論理演算子 &lt;code&gt;~&lt;/code&gt; 、 &lt;code&gt;&amp;amp;&lt;/code&gt; 、および &lt;code&gt;|&lt;/code&gt; をサポートします。（NOT、AND、OR）、上記のIPアドレスの場合と同じです。</target>
        </trans-unit>
        <trans-unit id="3aaa9a5d10023ba2866dd37afda193155af0f247" translate="yes" xml:space="preserve">
          <source>The MCV list gives the planner more detailed information about the specific values that commonly appear in the table, as well as an upper bound on the selectivities of combinations of values that do not appear in the table, allowing it to generate better estimates in both cases.</source>
          <target state="translated">MCVリストは、表によく現れる特定の値についてのより詳細な情報と、表に現れない値の組み合わせの選択性の上限をプランナーに与え、両方のケースでより良い推定値を生成することを可能にします。</target>
        </trans-unit>
        <trans-unit id="55e485d087fdc5b4b841601869e3bb93e6bf3639" translate="yes" xml:space="preserve">
          <source>The MD5 Message-Digest Algorithm.</source>
          <target state="translated">MD5メッセージダイジェストアルゴリズム。</target>
        </trans-unit>
        <trans-unit id="2127ad6c429aa49a235fd761eacdf2db8d6f6769" translate="yes" xml:space="preserve">
          <source>The Nagios plugin check_pgsql will work, because the simple information it checks for exists. The check_postgres monitoring script will also work, though some reported values could give different or confusing results. For example, last vacuum time will not be maintained, since no vacuum occurs on the standby. Vacuums running on the primary do still send their changes to the standby.</source>
          <target state="translated">Nagiosプラグインcheck_pgsqlは、チェックする単純な情報が存在するので、動作します。check_postgresモニタリングスクリプトも動作しますが、いくつかの報告された値が異なったり、混乱を招く結果を与える可能性があります。例えば、スタンバイではバキュームが発生しないため、最後のバキューム時間は維持されません。プライマリ上で実行されているバキュームは、その変更をスタンバイに送信します。</target>
        </trans-unit>
        <trans-unit id="5e71865447d6bc9ea383afd7d76b7761f19aa1b6" translate="yes" xml:space="preserve">
          <source>The OID alias types do not completely follow transaction isolation rules. The planner also treats them as simple constants, which may result in sub-optimal planning.</source>
          <target state="translated">OIDエイリアス型は、トランザクション分離ルールに完全に従っていません。また、プランナはそれらを単純な定数として扱い、その結果、最適ではないプランニングになるかもしれません。</target>
        </trans-unit>
        <trans-unit id="31161126282561c5d74d32ce529fddd65e0a76bd" translate="yes" xml:space="preserve">
          <source>The OID alias types have no operations of their own except for specialized input and output routines. These routines are able to accept and display symbolic names for system objects, rather than the raw numeric value that type &lt;code&gt;oid&lt;/code&gt; would use. The alias types allow simplified lookup of OID values for objects. For example, to examine the &lt;code&gt;pg_attribute&lt;/code&gt; rows related to a table &lt;code&gt;mytable&lt;/code&gt;, one could write:</source>
          <target state="translated">OIDエイリアス型には、特殊な入出力ルーチンを除いて、独自の操作はありません。これらのルーチンは、タイプ &lt;code&gt;oid&lt;/code&gt; が使用する生の数値ではなく、システムオブジェクトのシンボル名を受け入れて表示できます。エイリアスタイプを使用すると、オブジェクトのOID値を簡単に検索できます。たとえば、テーブル &lt;code&gt;mytable&lt;/code&gt; に関連する &lt;code&gt;pg_attribute&lt;/code&gt; 行を調べるには、次のように書くことができます。</target>
        </trans-unit>
        <trans-unit id="1f728998e1513edf5bb0f58e995427e26f8967db" translate="yes" xml:space="preserve">
          <source>The OID of the &lt;code&gt;pg_class&lt;/code&gt; entry for the default partition of this partitioned table, or zero if this partitioned table does not have a default partition.</source>
          <target state="translated">このパーティションテーブルのデフォルトパーティションの &lt;code&gt;pg_class&lt;/code&gt; エントリのOID 、またはこのパーティションテーブルにデフォルトパーティションがない場合はゼロ。</target>
        </trans-unit>
        <trans-unit id="0e41c17d955ca3267fc3e0f5f9ba923e41ea0513" translate="yes" xml:space="preserve">
          <source>The OID of the &lt;code&gt;pg_class&lt;/code&gt; entry for the table this index is for</source>
          <target state="translated">このインデックスが対象とするテーブルの &lt;code&gt;pg_class&lt;/code&gt; エントリのOID</target>
        </trans-unit>
        <trans-unit id="071dd0d457f9f27d9bee0d2e3ff6291a6f564862" translate="yes" xml:space="preserve">
          <source>The OID of the &lt;code&gt;pg_class&lt;/code&gt; entry for this index</source>
          <target state="translated">このインデックスの &lt;code&gt;pg_class&lt;/code&gt; エントリのOID</target>
        </trans-unit>
        <trans-unit id="f5a48c524de61d425315c3640ed2f8c5273484e3" translate="yes" xml:space="preserve">
          <source>The OID of the &lt;code&gt;pg_class&lt;/code&gt; entry for this partitioned table</source>
          <target state="translated">このパーティションテーブルの &lt;code&gt;pg_class&lt;/code&gt; エントリのOID</target>
        </trans-unit>
        <trans-unit id="eda438d49a92e642ba61a005c3405da4f9f1c62a" translate="yes" xml:space="preserve">
          <source>The OID of the &lt;code&gt;pg_class&lt;/code&gt; entry for this sequence</source>
          <target state="translated">このシーケンスの &lt;code&gt;pg_class&lt;/code&gt; エントリのOID</target>
        </trans-unit>
        <trans-unit id="303197c3c31b1c60eee9019793731af72e0dc006" translate="yes" xml:space="preserve">
          <source>The OID of the &lt;code&gt;pg_ts_config&lt;/code&gt; entry owning this map entry</source>
          <target state="translated">このマップエントリを所有する &lt;code&gt;pg_ts_config&lt;/code&gt; エントリのOID</target>
        </trans-unit>
        <trans-unit id="f8bdb5895be29901070dfef3e22b4e60f7c2d267" translate="yes" xml:space="preserve">
          <source>The OID of the &lt;code&gt;pg_type&lt;/code&gt; entry owning this enum value</source>
          <target state="translated">この列挙値を所有する &lt;code&gt;pg_type&lt;/code&gt; エントリのOID</target>
        </trans-unit>
        <trans-unit id="a977c33ead1b2b309c764b95248966dbf41f0217" translate="yes" xml:space="preserve">
          <source>The OID of the child table</source>
          <target state="translated">子テーブルのOID</target>
        </trans-unit>
        <trans-unit id="fcb128bef4bb51d558b2cbbe176487c983a3358d" translate="yes" xml:space="preserve">
          <source>The OID of the child table or index</source>
          <target state="translated">子テーブルまたはインデックスのOID</target>
        </trans-unit>
        <trans-unit id="5ebd50be09b18866cd4d57833179194c831f037b" translate="yes" xml:space="preserve">
          <source>The OID of the data type that corresponds to this table's row type, if any (zero for indexes, which have no &lt;code&gt;pg_type&lt;/code&gt; entry)</source>
          <target state="translated">このテーブルの行タイプに対応するデータタイプのOID（ある場合）（ &lt;code&gt;pg_type&lt;/code&gt; エントリのないインデックスの場合はゼロ）</target>
        </trans-unit>
        <trans-unit id="b8b4662cb4e6288ca284849c4be148da66825b82" translate="yes" xml:space="preserve">
          <source>The OID of the database the dependent object is in, or zero for a shared object</source>
          <target state="translated">依存オブジェクトが存在するデータベースのOID、共有オブジェクトの場合はゼロ。</target>
        </trans-unit>
        <trans-unit id="898b60ec7f694b0fc006eda8e50f6b63d49620a6" translate="yes" xml:space="preserve">
          <source>The OID of the database the setting is applicable to, or zero if not database-specific</source>
          <target state="translated">設定が適用されるデータベースの OID。</target>
        </trans-unit>
        <trans-unit id="61af788beaa116f1b955c318390c380729eb624f" translate="yes" xml:space="preserve">
          <source>The OID of the database this slot is associated with, or null. Only logical slots have an associated database.</source>
          <target state="translated">このスロットが関連付けられているデータベースのOID、またはnullです。論理スロットのみが関連付けられたデータベースを持ちます。</target>
        </trans-unit>
        <trans-unit id="dffe34cbcb64c59bdcb3677d3a1fd7a1a7165871" translate="yes" xml:space="preserve">
          <source>The OID of the foreign server that contains this mapping</source>
          <target state="translated">このマッピングを含む外部サーバーの OID</target>
        </trans-unit>
        <trans-unit id="5048d68506cd122e63f767db512f5ebd84d67ed5" translate="yes" xml:space="preserve">
          <source>The OID of the function to use to perform this cast. Zero is stored if the cast method doesn't require a function.</source>
          <target state="translated">このキャストを実行するために使用する関数のOID。キャストメソッドが関数を必要としない場合はゼロが格納されます。</target>
        </trans-unit>
        <trans-unit id="59c37f70d3d21e1cf2530f6e69c1cd78c664862f" translate="yes" xml:space="preserve">
          <source>The OID of the function to use when converting output from the procedural language (e.g., return values) to the data type. Zero is stored if this operation is not supported.</source>
          <target state="translated">手続き言語からの出力(戻り値など)をデータ型に変換する際に使用する関数のOID。この操作がサポートされていない場合は0が格納されます。</target>
        </trans-unit>
        <trans-unit id="b438ec49041a86ff7da5085d6d696fab9858a564" translate="yes" xml:space="preserve">
          <source>The OID of the function to use when converting the data type for input to the procedural language (e.g., function parameters). Zero is stored if this operation is not supported.</source>
          <target state="translated">手続き言語への入力用データ型(関数パラメータなど)を変換する際に使用する関数のOID。この操作がサポートされていない場合は0が格納される。</target>
        </trans-unit>
        <trans-unit id="8427c56037bb672e3eaf5c784fadd5373d00c50d" translate="yes" xml:space="preserve">
          <source>The OID of the large object.</source>
          <target state="translated">ラージオブジェクトのOID。</target>
        </trans-unit>
        <trans-unit id="aa257a5cc909f035b6b365a8de79171496abef73" translate="yes" xml:space="preserve">
          <source>The OID of the namespace associated with this entry, or 0 if none</source>
          <target state="translated">このエントリに関連付けられた名前空間のOID。</target>
        </trans-unit>
        <trans-unit id="3c9f55892a56c80828f11ba8da0cec8b6667ea0f" translate="yes" xml:space="preserve">
          <source>The OID of the namespace for this object, if applicable; otherwise NULL.</source>
          <target state="translated">該当する場合は、このオブジェクトの名前空間の OID。</target>
        </trans-unit>
        <trans-unit id="6544239c27c8b98d678c4d86cd8cf2fb4a45d909" translate="yes" xml:space="preserve">
          <source>The OID of the namespace that contains this collation</source>
          <target state="translated">この照合を含むネームスペースの OID</target>
        </trans-unit>
        <trans-unit id="67632f7b86c5d28c986c07563f79e9f57ab7488a" translate="yes" xml:space="preserve">
          <source>The OID of the namespace that contains this configuration</source>
          <target state="translated">この構成を含むネームスペースの OID</target>
        </trans-unit>
        <trans-unit id="f78b68f0e0d540debab34518ee53138dd78afc9d" translate="yes" xml:space="preserve">
          <source>The OID of the namespace that contains this constraint</source>
          <target state="translated">この制約を含むネームスペースの OID。</target>
        </trans-unit>
        <trans-unit id="26651bac2ebe9b8df63182bb4f09e8b29d4375b5" translate="yes" xml:space="preserve">
          <source>The OID of the namespace that contains this conversion</source>
          <target state="translated">この変換を含む名前空間のOID</target>
        </trans-unit>
        <trans-unit id="58fcc7c98890e8c2834e53212732cd77ac260148" translate="yes" xml:space="preserve">
          <source>The OID of the namespace that contains this dictionary</source>
          <target state="translated">この辞書を含む名前空間の OID</target>
        </trans-unit>
        <trans-unit id="0ffa036dc5da9392b5ff92b8de19382988ae095b" translate="yes" xml:space="preserve">
          <source>The OID of the namespace that contains this function</source>
          <target state="translated">この関数を含むネームスペースの OID</target>
        </trans-unit>
        <trans-unit id="4836cfb15733aecb9038935daa22b144847fa0b0" translate="yes" xml:space="preserve">
          <source>The OID of the namespace that contains this operator</source>
          <target state="translated">この演算子を含むネームスペースの OID</target>
        </trans-unit>
        <trans-unit id="bd2956b2c54813a0f702f1bbd1860a3130d1cd13" translate="yes" xml:space="preserve">
          <source>The OID of the namespace that contains this parser</source>
          <target state="translated">このパーサを含むネームスペースの OID</target>
        </trans-unit>
        <trans-unit id="4fa4ff9a62cc6b391718b0f0a2fcbd7ba489a8a1" translate="yes" xml:space="preserve">
          <source>The OID of the namespace that contains this relation</source>
          <target state="translated">このリレーションを含むネームスペースの OID</target>
        </trans-unit>
        <trans-unit id="f3b00f8f6b6908679ca83ef8448db4669f9c3f2b" translate="yes" xml:space="preserve">
          <source>The OID of the namespace that contains this statistics object</source>
          <target state="translated">この統計情報オブジェクトを含むネームスペースの OID</target>
        </trans-unit>
        <trans-unit id="0eccd6202b6e25a82e3cb731c01941486b802fde" translate="yes" xml:space="preserve">
          <source>The OID of the namespace that contains this template</source>
          <target state="translated">このテンプレートを含むネームスペースの OID</target>
        </trans-unit>
        <trans-unit id="2ad5e85b9c67d0c9e6855e2f98983c857e3e9cc9" translate="yes" xml:space="preserve">
          <source>The OID of the namespace that contains this type</source>
          <target state="translated">この型を含む名前空間の OID</target>
        </trans-unit>
        <trans-unit id="4da576b45acb3f961f666fac031b8e0b7887d94a" translate="yes" xml:space="preserve">
          <source>The OID of the object this description pertains to</source>
          <target state="translated">この記述が対象とするオブジェクトの OID</target>
        </trans-unit>
        <trans-unit id="92fb8b43568522d54e99e8435ff353f995d4d31c" translate="yes" xml:space="preserve">
          <source>The OID of the object this security label pertains to</source>
          <target state="translated">このセキュリティラベルが属するオブジェクトの OID</target>
        </trans-unit>
        <trans-unit id="0002c6e72af222de4cb8c506a6f1bc7c20ab1dc4" translate="yes" xml:space="preserve">
          <source>The OID of the parent table</source>
          <target state="translated">親テーブルのOID</target>
        </trans-unit>
        <trans-unit id="2b333512ca9c37807a07a256f4818991b100a615" translate="yes" xml:space="preserve">
          <source>The OID of the parent table or index</source>
          <target state="translated">親テーブルまたはインデックスのOID</target>
        </trans-unit>
        <trans-unit id="d5ffd02286699ef3905e8a972c66ee4bb2835bfc" translate="yes" xml:space="preserve">
          <source>The OID of the role associated with this entry</source>
          <target state="translated">このエントリに関連付けられたロールのOID</target>
        </trans-unit>
        <trans-unit id="c0915654e58b310d5210b25d19abfd7806a843de" translate="yes" xml:space="preserve">
          <source>The OID of the role the setting is applicable to, or zero if not role-specific</source>
          <target state="translated">設定が適用されるロールのOID。</target>
        </trans-unit>
        <trans-unit id="c9f3ec9e29e6e5e35e198f85cfeb26802f0a6d99" translate="yes" xml:space="preserve">
          <source>The OID of the specific dependent object</source>
          <target state="translated">特定の依存オブジェクトのOID</target>
        </trans-unit>
        <trans-unit id="b9087659abb5a8df685a282e464694231a05c905" translate="yes" xml:space="preserve">
          <source>The OID of the specific object</source>
          <target state="translated">特定のオブジェクトのOID</target>
        </trans-unit>
        <trans-unit id="9442b82a85ff19f9d0307346795cdb1c1390d555" translate="yes" xml:space="preserve">
          <source>The OID of the specific referenced object</source>
          <target state="translated">特定の参照オブジェクトのOID</target>
        </trans-unit>
        <trans-unit id="3b6fda1c623aa2d59a074893167f643c66f63048" translate="yes" xml:space="preserve">
          <source>The OID of the system catalog the dependent object is in</source>
          <target state="translated">依存オブジェクトが存在するシステムカタログの OID</target>
        </trans-unit>
        <trans-unit id="45c628ea8dfbe9deffe2a6beca65b182150c549a" translate="yes" xml:space="preserve">
          <source>The OID of the system catalog the object is in</source>
          <target state="translated">オブジェクトが入っているシステムカタログのOID</target>
        </trans-unit>
        <trans-unit id="651df0c1a82da14b1a69c5c748c986ddebc8aa71" translate="yes" xml:space="preserve">
          <source>The OID of the system catalog the referenced object is in</source>
          <target state="translated">参照されているオブジェクトが存在するシステムカタログのOID</target>
        </trans-unit>
        <trans-unit id="b623975e8da0f35427faa44f2916bd8169911114" translate="yes" xml:space="preserve">
          <source>The OID of the system catalog the referenced object is in (must be a shared catalog)</source>
          <target state="translated">参照されるオブジェクトが存在するシステムカタログのOID(共有カタログでなければなりません</target>
        </trans-unit>
        <trans-unit id="d29abf904f17279c11d42dc4f5568269360fdcb9" translate="yes" xml:space="preserve">
          <source>The OID of the system catalog this object appears in</source>
          <target state="translated">このオブジェクトが表示されているシステムカタログのOID</target>
        </trans-unit>
        <trans-unit id="067e884e18cd2aa571279cd559f882f0cf4ff2a1" translate="yes" xml:space="preserve">
          <source>The OID of the table containing this row. This column is particularly handy for queries that select from inheritance hierarchies (see &lt;a href=&quot;ddl-inherit&quot;&gt;Section 5.10&lt;/a&gt;), since without it, it's difficult to tell which individual table a row came from. The &lt;code&gt;tableoid&lt;/code&gt; can be joined against the &lt;code&gt;oid&lt;/code&gt; column of &lt;code&gt;pg_class&lt;/code&gt; to obtain the table name.</source>
          <target state="translated">この行を含むテーブルのOID。この列は、継承階層から選択するクエリ（&lt;a href=&quot;ddl-inherit&quot;&gt;セクション5.10を&lt;/a&gt;参照）で特に便利です。これがないと、行がどのテーブルからのものであるかを区別することが難しいためです。 &lt;code&gt;tableoid&lt;/code&gt; とは反対に接合することができる &lt;code&gt;oid&lt;/code&gt; のカラム &lt;code&gt;pg_class&lt;/code&gt; テーブル名を取得します。</target>
        </trans-unit>
        <trans-unit id="6a0b9e6d63b6cf8a833e5a7e3f6047bb0a93a945" translate="yes" xml:space="preserve">
          <source>The OID of the text search dictionary to consult</source>
          <target state="translated">参照するテキスト検索辞書のOID</target>
        </trans-unit>
        <trans-unit id="b6ba84785ad334e01b83ec445d3dda1ac4ac96bb" translate="yes" xml:space="preserve">
          <source>The OID of the text search parser for this configuration</source>
          <target state="translated">この設定のテキスト検索パーサの OID</target>
        </trans-unit>
        <trans-unit id="a117213bd13a98b62f97b549d2037dd5baede006" translate="yes" xml:space="preserve">
          <source>The OID of the text search template for this dictionary</source>
          <target state="translated">この辞書のテキスト検索テンプレートのOID</target>
        </trans-unit>
        <trans-unit id="58df61b40061f6a6618e8266483da7f989d95f26" translate="yes" xml:space="preserve">
          <source>The OIDs for &lt;code&gt;pg_enum&lt;/code&gt; rows follow a special rule: even-numbered OIDs are guaranteed to be ordered in the same way as the sort ordering of their enum type. That is, if two even OIDs belong to the same enum type, the smaller OID must have the smaller &lt;code&gt;enumsortorder&lt;/code&gt; value. Odd-numbered OID values need bear no relationship to the sort order. This rule allows the enum comparison routines to avoid catalog lookups in many common cases. The routines that create and alter enum types attempt to assign even OIDs to enum values whenever possible.</source>
          <target state="translated">&lt;code&gt;pg_enum&lt;/code&gt; 行のOID は特別な規則に従います。偶数のOIDは、列挙型の並べ替え順序と同じ方法で順序付けされることが保証されています。つまり、2つの偶数OIDが同じ列挙型に属している場合、OIDが小さいほど、 &lt;code&gt;enumsortorder&lt;/code&gt; 値も小さくなければなりません。奇数番号のOID値は、ソート順とは無関係である必要があります。このルールにより、enum比較ルーチンは、多くの一般的なケースでカタログ参照を回避できます。列挙型を作成および変更するルーチンは、可能な場合はいつでもOIDを列挙値に割り当てようとします。</target>
        </trans-unit>
        <trans-unit id="362f3646de7e2bebf05ad74a6325f7165ac1988c" translate="yes" xml:space="preserve">
          <source>The OpenSSL default order for &lt;code&gt;HIGH&lt;/code&gt; is problematic because it orders 3DES higher than AES128. This is wrong because 3DES offers less security than AES128, and it is also much slower. &lt;code&gt;+3DES&lt;/code&gt; reorders it after all other &lt;code&gt;HIGH&lt;/code&gt; and &lt;code&gt;MEDIUM&lt;/code&gt; ciphers.</source>
          <target state="translated">&lt;code&gt;HIGH&lt;/code&gt; のOpenSSLのデフォルトの順序は、AES128よりも3DES高いため、問題があります。3DESはAES128よりもセキュリティが低く、速度も非常に遅いため、これは誤りです。 &lt;code&gt;+3DES&lt;/code&gt; は、他のすべての &lt;code&gt;HIGH&lt;/code&gt; および &lt;code&gt;MEDIUM&lt;/code&gt; 暗号の後にそれを並べ替えます。</target>
        </trans-unit>
        <trans-unit id="b73c1bd60aad8104323371d01b1ec1a8338ede73" translate="yes" xml:space="preserve">
          <source>The Oversized-Attribute Storage Technique</source>
          <target state="translated">特大属性収納術</target>
        </trans-unit>
        <trans-unit id="e0b1bfcde4d47951e13640eda18c565a127fb8e6" translate="yes" xml:space="preserve">
          <source>The POSIX pattern language is described in much greater detail below.</source>
          <target state="translated">POSIXパターン言語については、以下に詳しく説明します。</target>
        </trans-unit>
        <trans-unit id="153ece47c4d9b24a5da118c8706404d098e93a76" translate="yes" xml:space="preserve">
          <source>The PostgreSQL &lt;code&gt;xml&lt;/code&gt; data type can only hold a value in &lt;code&gt;DOCUMENT&lt;/code&gt; or &lt;code&gt;CONTENT&lt;/code&gt; form. An XQuery/XPath expression context item must be a single XML node or atomic value, but XPath 1.0 further restricts it to be only an XML node, and has no node type allowing &lt;code&gt;CONTENT&lt;/code&gt;. The upshot is that a well-formed &lt;code&gt;DOCUMENT&lt;/code&gt; is the only form of XML value that PostgreSQL can supply as an XPath context item.</source>
          <target state="translated">PostgreSQL &lt;code&gt;xml&lt;/code&gt; データ型は、 &lt;code&gt;DOCUMENT&lt;/code&gt; または &lt;code&gt;CONTENT&lt;/code&gt; 形式の値のみを保持できます。XQuery / XPath式のコンテキストアイテムは単一のXMLノードまたはアトミック値である必要がありますが、XPath 1.0ではさらに、XMLノードのみに制限され、 &lt;code&gt;CONTENT&lt;/code&gt; を許可するノードタイプがありません。結局のところ、整形式の &lt;code&gt;DOCUMENT&lt;/code&gt; は、PostgreSQLがXPathコンテキスト項目として提供できるXML値の唯一の形式であるということです。</target>
        </trans-unit>
        <trans-unit id="8019e62373b33be0ae1394da9ad186299d75d149" translate="yes" xml:space="preserve">
          <source>The PostgreSQL concept of tablespaces is not part of the standard. Hence, the clause &lt;code&gt;TABLESPACE&lt;/code&gt; is an extension.</source>
          <target state="translated">PostgreSQLのテーブルスペースの概念は、標準の一部ではありません。したがって、 &lt;code&gt;TABLESPACE&lt;/code&gt; 節は拡張です。</target>
        </trans-unit>
        <trans-unit id="36ca8d540410a034c5a8f32708649004d256e17f" translate="yes" xml:space="preserve">
          <source>The PostgreSQL concept of tablespaces is not part of the standard. Hence, the clauses &lt;code&gt;TABLESPACE&lt;/code&gt; and &lt;code&gt;USING INDEX TABLESPACE&lt;/code&gt; are extensions.</source>
          <target state="translated">PostgreSQLのテーブルスペースの概念は、標準の一部ではありません。したがって、句 &lt;code&gt;TABLESPACE&lt;/code&gt; および &lt;code&gt;USING INDEX TABLESPACE&lt;/code&gt; は拡張です。</target>
        </trans-unit>
        <trans-unit id="74677c1410d0f3c49eba1a7361732a37abea01cf" translate="yes" xml:space="preserve">
          <source>The PostgreSQL formatting functions provide a powerful set of tools for converting various data types (date/time, integer, floating point, numeric) to formatted strings and for converting from formatted strings to specific data types. &lt;a href=&quot;functions-formatting#FUNCTIONS-FORMATTING-TABLE&quot;&gt;Table 9.24&lt;/a&gt; lists them. These functions all follow a common calling convention: the first argument is the value to be formatted and the second argument is a template that defines the output or input format.</source>
          <target state="translated">PostgreSQLのフォーマット関数は、さまざまなデータ型（日付/時刻、整数、浮動小数点、数値）をフォーマットされた文字列に変換したり、フォーマットされた文字列から特定のデータ型に変換したりするための強力なツールセットを提供します。&lt;a href=&quot;functions-formatting#FUNCTIONS-FORMATTING-TABLE&quot;&gt;表9.24&lt;/a&gt;にそれらを示します。これらの関数はすべて共通の呼び出し規約に従います。最初の引数はフォーマットされる値で、2番目の引数は出力または入力フォーマットを定義するテンプレートです。</target>
        </trans-unit>
        <trans-unit id="d0224dd17eece7d6f08f80bf4f5c518add98b147" translate="yes" xml:space="preserve">
          <source>The PostgreSQL formatting functions provide a powerful set of tools for converting various data types (date/time, integer, floating point, numeric) to formatted strings and for converting from formatted strings to specific data types. &lt;a href=&quot;functions-formatting#FUNCTIONS-FORMATTING-TABLE&quot;&gt;Table 9.25&lt;/a&gt; lists them. These functions all follow a common calling convention: the first argument is the value to be formatted and the second argument is a template that defines the output or input format.</source>
          <target state="translated">PostgreSQLフォーマット関数は、さまざまなデータ型（日付/時刻、整数、浮動小数点、数値）をフォーマット済み文字列に変換し、フォーマット済み文字列から特定のデータ型に変換するための強力なツールセットを提供します。&lt;a href=&quot;functions-formatting#FUNCTIONS-FORMATTING-TABLE&quot;&gt;表9.25&lt;/a&gt;にそれらを示します。これらの関数はすべて、共通の呼び出し規約に従います。最初の引数はフォーマットされる値であり、2番目の引数は出力または入力フォーマットを定義するテンプレートです。</target>
        </trans-unit>
        <trans-unit id="477d95f901512677a235f7ee46a8f81ecd4001b6" translate="yes" xml:space="preserve">
          <source>The PostgreSQL operator catalog has several entries for the infix operator &lt;code&gt;&amp;lt;@&lt;/code&gt;, but the only two that could possibly accept an integer array on the left-hand side are array inclusion (&lt;code&gt;anyarray&lt;/code&gt;&lt;code&gt;&amp;lt;@&lt;/code&gt;&lt;code&gt;anyarray&lt;/code&gt;) and range inclusion (&lt;code&gt;anyelement&lt;/code&gt;&lt;code&gt;&amp;lt;@&lt;/code&gt;&lt;code&gt;anyrange&lt;/code&gt;). Since none of these polymorphic pseudo-types (see &lt;a href=&quot;datatype-pseudo&quot;&gt;Section 8.21&lt;/a&gt;) are considered preferred, the parser cannot resolve the ambiguity on that basis. However, &lt;a href=&quot;typeconv-oper#OP-RESOL-LAST-UNKNOWN&quot;&gt;Step 3.f&lt;/a&gt; tells it to assume that the unknown-type literal is of the same type as the other input, that is, integer array. Now only one of the two operators can match, so array inclusion is selected. (Had range inclusion been selected, we would have gotten an error, because the string does not have the right format to be a range literal.)</source>
          <target state="translated">PostgreSQL演算子カタログには、中置演算子 &lt;code&gt;&amp;lt;@&lt;/code&gt; のエントリがいくつかありますが、左側の整数配列を受け入れる可能性があるのは、配列の包含（ &lt;code&gt;anyarray&lt;/code&gt; &lt;code&gt;&amp;lt;@&lt;/code&gt; &lt;code&gt;anyarray&lt;/code&gt; ）と範囲の包含（ &lt;code&gt;anyelement&lt;/code&gt; &lt;code&gt;&amp;lt;@&lt;/code&gt; &lt;code&gt;anyrange&lt;/code&gt; ）の2つだけです。これらのポリモーフィックな疑似タイプ（&lt;a href=&quot;datatype-pseudo&quot;&gt;8.21節を&lt;/a&gt;参照）はどれも優先とは見なされないため、パーサーはあいまいさをそれに基づいて解決できません。ただし、&lt;a href=&quot;typeconv-oper#OP-RESOL-LAST-UNKNOWN&quot;&gt;ステップ3.f&lt;/a&gt;不明なタイプのリテラルが他の入力と同じタイプ、つまり整数配列であると想定するように指示します。これで、2つの演算子のうち1つだけが一致できるため、配列の包含が選択されます。（範囲の包含が選択されていると、文字列が範囲リテラルになる正しい形式を持たないため、エラーが発生します。）</target>
        </trans-unit>
        <trans-unit id="7623f7756c9bed57d74564163e6b686074d22548" translate="yes" xml:space="preserve">
          <source>The PostgreSQL operator catalog has several entries for the prefix operator &lt;code&gt;@&lt;/code&gt;, all of which implement absolute-value operations for various numeric data types. One of these entries is for type &lt;code&gt;float8&lt;/code&gt;, which is the preferred type in the numeric category. Therefore, PostgreSQL will use that entry when faced with an &lt;code&gt;unknown&lt;/code&gt; input:</source>
          <target state="translated">PostgreSQL演算子カタログには、プレフィックス演算子 &lt;code&gt;@&lt;/code&gt; のエントリがいくつかあります。これらのエントリはすべて、さまざまな数値データ型の絶対値演算を実装しています。これらのエントリの1つは、数値カテゴリで推奨される型である &lt;code&gt;float8&lt;/code&gt; 型用です。したがって、PostgreSQLは &lt;code&gt;unknown&lt;/code&gt; 入力に直面したときにそのエントリを使用します。</target>
        </trans-unit>
        <trans-unit id="0de6cec8150a5ca1beb884d1dae8f1be83758f61" translate="yes" xml:space="preserve">
          <source>The PostgreSQL query planner relies on statistical information about the contents of tables in order to generate good plans for queries. These statistics are gathered by the &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt; command, which can be invoked by itself or as an optional step in &lt;code&gt;VACUUM&lt;/code&gt;. It is important to have reasonably accurate statistics, otherwise poor choices of plans might degrade database performance.</source>
          <target state="translated">PostgreSQLクエリプランナーは、クエリの適切なプランを生成するために、テーブルの内容に関する統計情報に依存しています。これらの統計は&lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt;コマンドによって収集されます。ANALYZEコマンドは、単独で、または &lt;code&gt;VACUUM&lt;/code&gt; のオプションのステップとして呼び出すことができます。適度に正確な統計を取得することが重要です。そうしないと、計画の選択が不十分なためにデータベースのパフォーマンスが低下する可能性があります。</target>
        </trans-unit>
        <trans-unit id="091f965ebb32941711ea5df90e349daf215494b9" translate="yes" xml:space="preserve">
          <source>The PostgreSQL rule system allows one to define an alternative action to be performed on insertions, updates, or deletions in database tables. Roughly speaking, a rule causes additional commands to be executed when a given command on a given table is executed. Alternatively, an &lt;code&gt;INSTEAD&lt;/code&gt; rule can replace a given command by another, or cause a command not to be executed at all. Rules are used to implement SQL views as well. It is important to realize that a rule is really a command transformation mechanism, or command macro. The transformation happens before the execution of the command starts. If you actually want an operation that fires independently for each physical row, you probably want to use a trigger, not a rule. More information about the rules system is in &lt;a href=&quot;https://www.postgresql.org/docs/12/rules.html&quot;&gt;Chapter 40&lt;/a&gt;.</source>
          <target state="translated">PostgreSQLルールシステムを使用すると、データベーステーブルの挿入、更新、または削除時に実行する代替アクションを定義できます。大まかに言えば、ルールは、特定のテーブルで特定のコマンドが実行されるときに追加のコマンドを実行させます。または、 &lt;code&gt;INSTEAD&lt;/code&gt; ルールは、特定のコマンドを別のコマンドで置き換えるか、コマンドをまったく実行しないようにすることができます。ルールは、SQLビューの実装にも使用されます。ルールは、実際にはコマンド変換メカニズム、つまりコマンドマクロであることを理解することが重要です。変換は、コマンドの実行が開始する前に行われます。物理的な行ごとに個別に起動する操作が実際に必要な場合は、ルールではなくトリガーを使用することをお勧めします。ルールシステムの詳細については、&lt;a href=&quot;https://www.postgresql.org/docs/12/rules.html&quot;&gt;第40章を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="0e154a2cce3e777e6a59136969a3016037e9c1d8" translate="yes" xml:space="preserve">
          <source>The PostgreSQL rule system allows one to define an alternative action to be performed on insertions, updates, or deletions in database tables. Roughly speaking, a rule causes additional commands to be executed when a given command on a given table is executed. Alternatively, an &lt;code&gt;INSTEAD&lt;/code&gt; rule can replace a given command by another, or cause a command not to be executed at all. Rules are used to implement SQL views as well. It is important to realize that a rule is really a command transformation mechanism, or command macro. The transformation happens before the execution of the command starts. If you actually want an operation that fires independently for each physical row, you probably want to use a trigger, not a rule. More information about the rules system is in &lt;a href=&quot;https://www.postgresql.org/docs/13/rules.html&quot;&gt;Chapter 40&lt;/a&gt;.</source>
          <target state="translated">PostgreSQLルールシステムを使用すると、データベーステーブルの挿入、更新、または削除に対して実行される代替アクションを定義できます。大まかに言えば、ルールにより、特定のテーブルで特定のコマンドが実行されると、追加のコマンドが実行されます。または、 &lt;code&gt;INSTEAD&lt;/code&gt; ルールを使用して、特定のコマンドを別のコマンドに置き換えたり、コマンドをまったく実行しないようにすることもできます。ルールは、SQLビューの実装にも使用されます。ルールは実際にはコマンド変換メカニズム、つまりコマンドマクロであることを理解することが重要です。変換は、コマンドの実行が開始される前に行われます。物理行ごとに個別に起動する操作が実際に必要な場合は、ルールではなくトリガーを使用することをお勧めします。ルールシステムの詳細については、&lt;a href=&quot;https://www.postgresql.org/docs/13/rules.html&quot;&gt;第40章を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="10a690ef1ea7666469e6c355dbc334d6d1d70eb6" translate="yes" xml:space="preserve">
          <source>The PostgreSQL scanner/parser divides lexical elements into five fundamental categories: integers, non-integer numbers, strings, identifiers, and key words. Constants of most non-numeric types are first classified as strings. The SQL language definition allows specifying type names with strings, and this mechanism can be used in PostgreSQL to start the parser down the correct path. For example, the query:</source>
          <target state="translated">PostgreSQLスキャナ/パーサは、字句要素を整数、非整数、文字列、識別子、キーワードの5つの基本的なカテゴリに分類します。ほとんどの非数値型の定数は最初に文字列として分類されます。SQL言語の定義では、文字列で型名を指定することができ、PostgreSQLではこのメカニズムを使用してパーサを正しい経路で開始することができます。例えば、クエリ。</target>
        </trans-unit>
        <trans-unit id="b6aed6106f2d7424b2bbb821dba77f382392bc5d" translate="yes" xml:space="preserve">
          <source>The PostgreSQL server can handle multiple concurrent connections from clients. To achieve this it starts (&amp;ldquo;forks&amp;rdquo;) a new process for each connection. From that point on, the client and the new server process communicate without intervention by the original &lt;code&gt;postgres&lt;/code&gt; process. Thus, the master server process is always running, waiting for client connections, whereas client and associated server processes come and go. (All of this is of course invisible to the user. We only mention it here for completeness.)</source>
          <target state="translated">PostgreSQLサーバーは、クライアントからの複数の同時接続を処理できます。これを実現するために、接続ごとに新しいプロセスを開始（「フォーク」）します。その時点から、クライアントと新しいサーバープロセスは、元の &lt;code&gt;postgres&lt;/code&gt; プロセスの介入なしに通信します。したがって、マスターサーバープロセスは常に実行され、クライアント接続を待機しますが、クライアントと関連するサーバープロセスは行き来します。 （もちろん、これらはすべてユーザーには見えません。ここでは、完全を期すためにのみ言及しています。）</target>
        </trans-unit>
        <trans-unit id="7af0f9ca01829c95b3c4cfa20671b04ccaa7a1b4" translate="yes" xml:space="preserve">
          <source>The PostgreSQL server uses one process per connection so you should provide for at least as many processes as allowed connections, in addition to what you need for the rest of your system. This is usually not a problem but if you run several servers on one machine things might get tight.</source>
          <target state="translated">PostgreSQLサーバは1つの接続につき1つのプロセスを使用しますので、システムの残りの部分に必要な数に加えて、少なくとも許可された接続数だけのプロセスを用意しなければなりません。これは通常問題ではありませんが、1台のマシン上で複数のサーバを実行している場合、窮屈になるかもしれません。</target>
        </trans-unit>
        <trans-unit id="929274b54effcc47ded1784455530166b7871347" translate="yes" xml:space="preserve">
          <source>The PostgreSQL server will listen for both normal and GSSAPI-encrypted connections on the same TCP port, and will negotiate with any connecting client on whether to use GSSAPI for encryption (and for authentication). By default, this decision is up to the client (which means it can be downgraded by an attacker); see &lt;a href=&quot;auth-pg-hba-conf&quot;&gt;Section 20.1&lt;/a&gt; about setting up the server to require the use of GSSAPI for some or all connections.</source>
          <target state="translated">PostgreSQLサーバーは、同じTCPポートで通常の接続とGSSAPIで暗号化された接続の両方をリッスンし、暗号化（および認証）にGSSAPIを使用するかどうかについて接続しているクライアントと交渉します。デフォルトでは、この決定はクライアント次第です（つまり、攻撃者によってダウングレードされる可能性があります）。一部またはすべての接続でGSSAPIの使用を要求するようにサーバーを設定する方法については、&lt;a href=&quot;auth-pg-hba-conf&quot;&gt;セクション20.1を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="c912054f27c4ee7b0f1b38b55011027ea73de0d0" translate="yes" xml:space="preserve">
          <source>The PostgreSQL server will listen for both normal and GSSAPI-encrypted connections on the same TCP port, and will negotiate with any connecting client whether to use GSSAPI for encryption (and for authentication). By default, this decision is up to the client (which means it can be downgraded by an attacker); see &lt;a href=&quot;auth-pg-hba-conf&quot;&gt;Section 20.1&lt;/a&gt; about setting up the server to require the use of GSSAPI for some or all connections.</source>
          <target state="translated">PostgreSQLサーバーは、同じTCPポートで通常の接続とGSSAPIで暗号化された接続の両方をリッスンし、GSSAPIを暗号化（および認証）に使用するかどうかを接続しているクライアントとネゴシエートします。デフォルトでは、この決定はクライアント次第です（つまり、攻撃者によってダウングレードされる可能性があります）。一部またはすべての接続にGSSAPIの使用を要求するサーバーの設定については、&lt;a href=&quot;auth-pg-hba-conf&quot;&gt;セクション20.1を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="f4cf80f6b7604fb8b47859e4bbfb35130b5f3d5d" translate="yes" xml:space="preserve">
          <source>The PostgreSQL source distribution includes several examples of index methods implemented using GiST. The core system currently provides text search support (indexing for &lt;code&gt;tsvector&lt;/code&gt; and &lt;code&gt;tsquery&lt;/code&gt;) as well as R-Tree equivalent functionality for some of the built-in geometric data types (see &lt;code&gt;src/backend/access/gist/gistproc.c&lt;/code&gt;). The following &lt;code&gt;contrib&lt;/code&gt; modules also contain GiST operator classes:</source>
          <target state="translated">PostgreSQLソース配布には、GiSTを使用して実装されたインデックスメソッドのいくつかの例が含まれています。コアシステムは現在、テキスト検索サポート（ &lt;code&gt;tsvector&lt;/code&gt; および &lt;code&gt;tsquery&lt;/code&gt; のインデックス作成）と、一部の組み込みのジオメトリックデータタイプ（ &lt;code&gt;src/backend/access/gist/gistproc.c&lt;/code&gt; を参照）のRツリー同等の機能を提供しています。次の &lt;code&gt;contrib&lt;/code&gt; モジュールには、GiST演算子クラスも含まれています。</target>
        </trans-unit>
        <trans-unit id="f0456fd311416d751f4442303736e9783a5f29ea" translate="yes" xml:space="preserve">
          <source>The PostgreSQL source distribution includes several examples of index operator classes for SP-GiST, as described in &lt;a href=&quot;spgist-builtin-opclasses#SPGIST-BUILTIN-OPCLASSES-TABLE&quot;&gt;Table 65.1&lt;/a&gt;. Look into &lt;code&gt;src/backend/access/spgist/&lt;/code&gt; and &lt;code&gt;src/backend/utils/adt/&lt;/code&gt; to see the code.</source>
          <target state="translated">PostgreSQLのソースディストリビューションには、&lt;a href=&quot;spgist-builtin-opclasses#SPGIST-BUILTIN-OPCLASSES-TABLE&quot;&gt;表65.1&lt;/a&gt;に示すように、SP-GiSTのインデックス演算子クラスのいくつかの例が含まれています。見 &lt;code&gt;src/backend/access/spgist/&lt;/code&gt; および &lt;code&gt;src/backend/utils/adt/&lt;/code&gt; コードを表示します。</target>
        </trans-unit>
        <trans-unit id="da6bb87f4fbef7ca2cd7285a5ff15baca5680b91" translate="yes" xml:space="preserve">
          <source>The PostgreSQL type system contains a number of special-purpose entries that are collectively called &lt;em&gt;pseudo-types&lt;/em&gt;. A pseudo-type cannot be used as a column data type, but it can be used to declare a function's argument or result type. Each of the available pseudo-types is useful in situations where a function's behavior does not correspond to simply taking or returning a value of a specific SQL data type. &lt;a href=&quot;datatype-pseudo#DATATYPE-PSEUDOTYPES-TABLE&quot;&gt;Table 8.27&lt;/a&gt; lists the existing pseudo-types.</source>
          <target state="translated">PostgreSQLの型システムには、まとめて&lt;em&gt;疑似型&lt;/em&gt;と呼ばれる特別な目的のエントリがいくつか含まれてい&lt;em&gt;ます&lt;/em&gt;。疑似型は列のデータ型として使用できませんが、関数の引数または結果の型を宣言するために使用できます。使用可能な各疑似型は、関数の動作が特定のSQLデータ型の値を単に取得または返すことに対応していない状況で役立ちます。&lt;a href=&quot;datatype-pseudo#DATATYPE-PSEUDOTYPES-TABLE&quot;&gt;表8.27&lt;/a&gt;に、既存の疑似タイプを示します。</target>
        </trans-unit>
        <trans-unit id="3627ccc448cafae762325bbb25d1d00e8338b2f1" translate="yes" xml:space="preserve">
          <source>The PostgreSQL-specific functions &lt;code&gt;xpath()&lt;/code&gt; and &lt;code&gt;xpath_exists()&lt;/code&gt; query XML documents using the XPath language. PostgreSQL also provides XPath-only variants of the standard functions &lt;code&gt;XMLEXISTS&lt;/code&gt; and &lt;code&gt;XMLTABLE&lt;/code&gt;, which officially use the XQuery language. For all of these functions, PostgreSQL relies on the libxml2 library, which provides only XPath 1.0.</source>
          <target state="translated">PostgreSQL固有の関数 &lt;code&gt;xpath()&lt;/code&gt; および &lt;code&gt;xpath_exists()&lt;/code&gt; は、XPath言語を使用してXMLドキュメントをクエリします。 PostgreSQLは、XQuery言語を公式に使用する標準関数 &lt;code&gt;XMLEXISTS&lt;/code&gt; および &lt;code&gt;XMLTABLE&lt;/code&gt; の XPathのみのバリアントも提供します。これらすべての関数について、PostgreSQLはXPath 1.0のみを提供するlibxml2ライブラリに依存しています。</target>
        </trans-unit>
        <trans-unit id="efd965ec5103a44f1272738f66a9e9d5dd0aabd5" translate="yes" xml:space="preserve">
          <source>The ROW keyword is actually optional as long as you have more than one field in the expression, so these can be simplified to:</source>
          <target state="translated">ROWキーワードは、式の中に複数のフィールドがある限り、実際にはオプションですので、これらは簡略化できます。</target>
        </trans-unit>
        <trans-unit id="4adee7e95f5294837cef6adde9f546d2e1f9b70f" translate="yes" xml:space="preserve">
          <source>The Repeatable Read isolation level is implemented using a technique known in academic database literature and in some other database products as &lt;em&gt;Snapshot Isolation&lt;/em&gt;. Differences in behavior and performance may be observed when compared with systems that use a traditional locking technique that reduces concurrency. Some other systems may even offer Repeatable Read and Snapshot Isolation as distinct isolation levels with different behavior. The permitted phenomena that distinguish the two techniques were not formalized by database researchers until after the SQL standard was developed, and are outside the scope of this manual. For a full treatment, please see &lt;a href=&quot;https://www.postgresql.org/docs/13/biblio.html#BERENSON95&quot;&gt;[berenson95]&lt;/a&gt;.</source>
          <target state="translated">反復可能読み取り分離レベルは、学術データベースの文献や他のいくつかのデータベース製品で&lt;em&gt;スナップショット分離&lt;/em&gt;として知られている手法を使用して実装されます。同時実行性を減らす従来のロック技術を使用するシステムと比較すると、動作とパフォーマンスの違いが観察される場合があります。他の一部のシステムでは、動作が異なる個別の分離レベルとして、繰り返し可能な読み取りおよびスナップショット分離を提供する場合もあります。 2つの手法を区別する許可された現象は、SQL標準が開発されるまでデータベース研究者によって形式化されておらず、このマニュアルの範囲外です。完全な治療法については、&lt;a href=&quot;https://www.postgresql.org/docs/13/biblio.html#BERENSON95&quot;&gt;[berenson95]&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="091f62aabb99c30a476910bd3ba420fa9f860db6" translate="yes" xml:space="preserve">
          <source>The Repeatable Read mode provides a rigorous guarantee that each transaction sees a completely stable view of the database. However, this view will not necessarily always be consistent with some serial (one at a time) execution of concurrent transactions of the same level. For example, even a read only transaction at this level may see a control record updated to show that a batch has been completed but &lt;em&gt;not&lt;/em&gt; see one of the detail records which is logically part of the batch because it read an earlier revision of the control record. Attempts to enforce business rules by transactions running at this isolation level are not likely to work correctly without careful use of explicit locks to block conflicting transactions.</source>
          <target state="translated">反復可能読み取りモードは、各トランザクションがデータベースの完全に安定したビューを見ることを厳密に保証します。ただし、このビューは、同じレベルの同時トランザクションのいくつかの（一度に1つの）逐次実行と常に一貫しているとは限りません。たとえば、このレベルの読み取り専用トランザクションでも、バッチが完了したことを示すように更新された制御レコードが表示されますが、制御レコードの以前のリビジョンを読み取ったため、論理的にバッチの一部である詳細レコードの1つは表示され&lt;em&gt;ません。&lt;/em&gt;。この分離レベルで実行されているトランザクションによってビジネスルールを適用しようとすると、競合するトランザクションをブロックする明示的なロックを注意深く使用しないと、正しく機能しない可能性があります。</target>
        </trans-unit>
        <trans-unit id="bebce75022660ba392e40784c2cdda41c615a64f" translate="yes" xml:space="preserve">
          <source>The SCRAM specification dictates that the password is also in UTF-8, and is processed with the &lt;em&gt;SASLprep&lt;/em&gt; algorithm. PostgreSQL, however, does not require UTF-8 to be used for the password. When a user's password is set, it is processed with SASLprep as if it was in UTF-8, regardless of the actual encoding used. However, if it is not a legal UTF-8 byte sequence, or it contains UTF-8 byte sequences that are prohibited by the SASLprep algorithm, the raw password will be used without SASLprep processing, instead of throwing an error. This allows the password to be normalized when it is in UTF-8, but still allows a non-UTF-8 password to be used, and doesn't require the system to know which encoding the password is in.</source>
          <target state="translated">SCRAM仕様では、パスワードもUTF-8であり、&lt;em&gt;SASLprep&lt;/em&gt;アルゴリズムで処理されることが&lt;em&gt;規定&lt;/em&gt;されて&lt;em&gt;い&lt;/em&gt;ます。ただし、PostgreSQLでは、パスワードにUTF-8を使用する必要はありません。ユーザーのパスワードが設定されると、実際に使用されているエンコードに関係なく、UTF-8であるかのようにSASLprepで処理されます。ただし、正当なUTF-8バイトシーケンスではない場合、またはSASLprepアルゴリズムで禁止されているUTF-8バイトシーケンスが含まれている場合、エラーをスローする代わりに、SASLprep処理なしで未加工パスワードが使用されます。これにより、UTF-8のパスワードを正規化できますが、UTF-8以外のパスワードを使用することもできます。また、システムがパスワードのエンコーディングを知っている必要はありません。</target>
        </trans-unit>
        <trans-unit id="0e7a1522eba0328b9be11871eb393a000b642ba7" translate="yes" xml:space="preserve">
          <source>The SP-GiST core can override the results of the operator class's &lt;code&gt;picksplit&lt;/code&gt; function when &lt;code&gt;picksplit&lt;/code&gt; fails to divide the supplied leaf values into at least two node categories. When this happens, the new inner tuple is created with multiple nodes that each have the same label (if any) that &lt;code&gt;picksplit&lt;/code&gt; gave to the one node it did use, and the leaf values are divided at random among these equivalent nodes. The &lt;code&gt;allTheSame&lt;/code&gt; flag is set on the inner tuple to warn the &lt;code&gt;choose&lt;/code&gt; and &lt;code&gt;inner_consistent&lt;/code&gt; functions that the tuple does not have the node set that they might otherwise expect.</source>
          <target state="translated">指定されたリーフ値を &lt;code&gt;picksplit&lt;/code&gt; が少なくとも2つのノードカテゴリに分割できない場合、SP-GiSTコアは演算子クラスの &lt;code&gt;picksplit&lt;/code&gt; 関数の結果をオーバーライドできます。これが発生した場合、新しい内部タプルは、 &lt;code&gt;picksplit&lt;/code&gt; が使用した1つのノードに与えた同じラベル（存在する場合）を持つ複数のノードで作成され、リーフ値はこれらの同等のノード間でランダムに分割されます。 &lt;code&gt;allTheSame&lt;/code&gt; のフラグは警告するために、内側のタプルに設定されている &lt;code&gt;choose&lt;/code&gt; と &lt;code&gt;inner_consistent&lt;/code&gt; タプルが、彼らはそう期待するかもしれないことをノードセットを持っていないという機能を。</target>
        </trans-unit>
        <trans-unit id="d1b14a46877d8df03142e17f562b21c36e25830b" translate="yes" xml:space="preserve">
          <source>The SP-GiST core code takes care of null entries. Although SP-GiST indexes do store entries for nulls in indexed columns, this is hidden from the index operator class code: no null index entries or search conditions will ever be passed to the operator class methods. (It is assumed that SP-GiST operators are strict and so cannot succeed for null values.) Null values are therefore not discussed further here.</source>
          <target state="translated">SP-GISTコアコードはヌルエントリの処理を行います。SP-GISTインデックスはインデックス化された列にヌルのためのエントリを格納しますが、これはインデックス演算子クラスのコードからは隠されています:ヌルのインデックスエントリや検索条件が演算子クラスのメソッドに渡されることはありません。(SP-GiST演算子は厳密であるため、ヌル値に対しては成功しないことが想定されています)。したがって、ヌル値についてはここでは説明しません。</target>
        </trans-unit>
        <trans-unit id="fe87973f3ef5a0d6b6662bce168960f63417cd65" translate="yes" xml:space="preserve">
          <source>The SQL &lt;code&gt;CASE&lt;/code&gt; expression is a generic conditional expression, similar to if/else statements in other programming languages:</source>
          <target state="translated">SQL &lt;code&gt;CASE&lt;/code&gt; 式は、他のプログラミング言語のif / elseステートメントに似た、一般的な条件式です。</target>
        </trans-unit>
        <trans-unit id="d48ab325670cd3e1aa8741d57a661891b103e0ac" translate="yes" xml:space="preserve">
          <source>The SQL command &lt;code&gt;SET TIME ZONE&lt;/code&gt; sets the time zone for the session. This is an alternative spelling of &lt;code&gt;SET TIMEZONE TO&lt;/code&gt; with a more SQL-spec-compatible syntax.</source>
          <target state="translated">SQLコマンド &lt;code&gt;SET TIME ZONE&lt;/code&gt; は、セッションのタイムゾーンを設定します。これは、SQL仕様互換の構文を使用した &lt;code&gt;SET TIMEZONE TO&lt;/code&gt; の代替スペルです。</target>
        </trans-unit>
        <trans-unit id="d138e80b8b9922df49f297ce30f8d0bcbf9cc1b2" translate="yes" xml:space="preserve">
          <source>The SQL command used to request data from a &lt;a href=&quot;glossary#GLOSSARY-DATABASE&quot;&gt;database&lt;/a&gt;. Normally, &lt;code&gt;SELECT&lt;/code&gt; commands are not expected to modify the &lt;a href=&quot;glossary#GLOSSARY-DATABASE&quot;&gt;database&lt;/a&gt; in any way, but it is possible that &lt;a href=&quot;glossary#GLOSSARY-FUNCTION&quot;&gt;functions&lt;/a&gt; invoked within the query could have side effects that do modify data.</source>
          <target state="translated">&lt;a href=&quot;glossary#GLOSSARY-DATABASE&quot;&gt;データベース&lt;/a&gt;からデータを要求するために使用されるSQLコマンド。通常、 &lt;code&gt;SELECT&lt;/code&gt; コマンドは&lt;a href=&quot;glossary#GLOSSARY-DATABASE&quot;&gt;データベース&lt;/a&gt;を変更することは想定されていませんが、クエリ内で呼び出された&lt;a href=&quot;glossary#GLOSSARY-FUNCTION&quot;&gt;関数が&lt;/a&gt;データを変更する副作用を引き起こす可能性があります。</target>
        </trans-unit>
        <trans-unit id="64de07c340bdb76d49ccd2451af6603ff373cc2b" translate="yes" xml:space="preserve">
          <source>The SQL declaration of the function must look like this:</source>
          <target state="translated">関数のSQL宣言は次のようにしてください。</target>
        </trans-unit>
        <trans-unit id="d7b4645499046b1f0731ca7d87e83bccfa0f031d" translate="yes" xml:space="preserve">
          <source>The SQL script will be written to the standard output. Use the &lt;code&gt;-f&lt;/code&gt;/&lt;code&gt;--file&lt;/code&gt; option or shell operators to redirect it into a file.</source>
          <target state="translated">SQLスクリプトが標準出力に書き込まれます。 &lt;code&gt;-f&lt;/code&gt; / &lt;code&gt;--file&lt;/code&gt; オプションまたはシェル演算子を使用して、ファイルにリダイレクトします。</target>
        </trans-unit>
        <trans-unit id="e638b08fc8b7ed4b2fdc056d0b48506d414e8ee3" translate="yes" xml:space="preserve">
          <source>The SQL specification requires row-wise comparison to return NULL if the result depends on comparing two NULL values or a NULL and a non-NULL. PostgreSQL does this only when comparing the results of two row constructors (as in &lt;a href=&quot;functions-comparisons#ROW-WISE-COMPARISON&quot;&gt;Section 9.23.5&lt;/a&gt;) or comparing a row constructor to the output of a subquery (as in &lt;a href=&quot;functions-subquery&quot;&gt;Section 9.22&lt;/a&gt;). In other contexts where two composite-type values are compared, two NULL field values are considered equal, and a NULL is considered larger than a non-NULL. This is necessary in order to have consistent sorting and indexing behavior for composite types.</source>
          <target state="translated">SQL仕様では、結果が2つのNULL値またはNULLと非NULLの比較に依存する場合、NULLを返すために行ごとの比較が必要です。PostgreSQLがこれを行うのは、2つの行コンストラクタの結果を比較する場合（&lt;a href=&quot;functions-comparisons#ROW-WISE-COMPARISON&quot;&gt;セクション9.23.5のように&lt;/a&gt;）または行コンストラクタをサブクエリの出力と比較するとき（&lt;a href=&quot;functions-subquery&quot;&gt;セクション9.22のように&lt;/a&gt;）だけです。2つの複合型値が比較される他のコンテキストでは、2つのNULLフィールド値は等しいと見なされ、NULLは非NULLよりも大きいと見なされます。これは、複合型のソートおよびインデックス付け動作に一貫性を持たせるために必要です。</target>
        </trans-unit>
        <trans-unit id="70d6fe59fbf6e2a74e4c6678f95fcbb041c7ebd1" translate="yes" xml:space="preserve">
          <source>The SQL specification requires row-wise comparison to return NULL if the result depends on comparing two NULL values or a NULL and a non-NULL. PostgreSQL does this only when comparing the results of two row constructors (as in &lt;a href=&quot;functions-comparisons#ROW-WISE-COMPARISON&quot;&gt;Section 9.24.5&lt;/a&gt;) or comparing a row constructor to the output of a subquery (as in &lt;a href=&quot;functions-subquery&quot;&gt;Section 9.23&lt;/a&gt;). In other contexts where two composite-type values are compared, two NULL field values are considered equal, and a NULL is considered larger than a non-NULL. This is necessary in order to have consistent sorting and indexing behavior for composite types.</source>
          <target state="translated">SQL仕様では、結果が2つのNULL値、またはNULLと非NULLの比較に依存する場合、NULLを返すために行ごとの比較が必要です。 PostgreSQLは、2つの行コンストラクターの結果を比較する場合（&lt;a href=&quot;functions-comparisons#ROW-WISE-COMPARISON&quot;&gt;セクション9.24.5のように&lt;/a&gt;）、または行コンストラクターをサブクエリの出力と比較する場合（&lt;a href=&quot;functions-subquery&quot;&gt;セクション9.23のように&lt;/a&gt;）にのみこれを行います。 2つの複合タイプの値が比較される他のコンテキストでは、2つのNULLフィールド値は等しいと見なされ、NULLは非NULLよりも大きいと見なされます。これは、複合型のソートとインデックス作成の動作を一貫させるために必要です。</target>
        </trans-unit>
        <trans-unit id="22ab3c86af000737aa210aeaf592af19c218233b" translate="yes" xml:space="preserve">
          <source>The SQL standard (not XQuery itself) attempts to cater for more variants of &amp;ldquo;newline&amp;rdquo; than POSIX does. The newline-sensitive matching options described above consider only ASCII NL (&lt;code&gt;\n&lt;/code&gt;) to be a newline, but SQL would have us treat CR (&lt;code&gt;\r&lt;/code&gt;), CRLF (&lt;code&gt;\r\n&lt;/code&gt;) (a Windows-style newline), and some Unicode-only characters like LINE SEPARATOR (U+2028) as newlines as well. Notably, &lt;code&gt;.&lt;/code&gt; and &lt;code&gt;\s&lt;/code&gt; should count &lt;code&gt;\r\n&lt;/code&gt; as one character not two according to SQL.</source>
          <target state="translated">SQL標準（XQuery自体ではない）は、POSIXよりも多くの「改行」のバリアントに対応しようとします。上記の改行を区別するマッチングオプションでは、ASCII NL（ &lt;code&gt;\n&lt;/code&gt; ）のみを改行と見なしますが、SQLではCR（ &lt;code&gt;\r&lt;/code&gt; ）、CRLF（ &lt;code&gt;\r\n&lt;/code&gt; ）（Windowsスタイルの改行）、および改行としてのLINE SEPARATOR（U + 2028）などのUnicode専用文字。注目すべきは、 &lt;code&gt;.&lt;/code&gt; SQLによると、 &lt;code&gt;\s&lt;/code&gt; は &lt;code&gt;\r\n&lt;/code&gt; を2文字ではなく1文字としてカウントする必要があります。</target>
        </trans-unit>
        <trans-unit id="3ca979281ade8cf94abb51fcd1544322941db9bd" translate="yes" xml:space="preserve">
          <source>The SQL standard allows a &lt;code&gt;DEFAULT CHARACTER SET&lt;/code&gt; clause in &lt;code&gt;CREATE SCHEMA&lt;/code&gt;, as well as more subcommand types than are presently accepted by PostgreSQL.</source>
          <target state="translated">SQL標準では、 &lt;code&gt;CREATE SCHEMA&lt;/code&gt; の &lt;code&gt;DEFAULT CHARACTER SET&lt;/code&gt; 句、および現在PostgreSQLで受け入れられているよりも多くのサブコマンドタイプを許可しています。</target>
        </trans-unit>
        <trans-unit id="a28253dba0b95d8667501243721aade5c4069637" translate="yes" xml:space="preserve">
          <source>The SQL standard allows cursors only in embedded SQL and in modules. PostgreSQL permits cursors to be used interactively.</source>
          <target state="translated">標準SQLでは、組み込みSQLとモジュール内でのみカーソルを使用することができます。PostgreSQLでは、カーソルを対話的に使用することができます。</target>
        </trans-unit>
        <trans-unit id="7005659d6b42749138703e7ef74f259a352e97f5" translate="yes" xml:space="preserve">
          <source>The SQL standard allows only &lt;code&gt;FROM&lt;/code&gt; preceding the cursor name; the option to use &lt;code&gt;IN&lt;/code&gt;, or to leave them out altogether, is an extension.</source>
          <target state="translated">SQL標準では、カーソル名の前に &lt;code&gt;FROM&lt;/code&gt; のみを許可しています。 &lt;code&gt;IN&lt;/code&gt; を使用するオプション、またはそれらを完全に省略するオプションは、拡張機能です。</target>
        </trans-unit>
        <trans-unit id="69a8fc7cc008eb25ed064f0d1fdca190a5bf8644" translate="yes" xml:space="preserve">
          <source>The SQL standard allows some other expressions to appear in place of the literal &lt;code&gt;user_name&lt;/code&gt;, but these options are not important in practice. PostgreSQL allows identifier syntax (&lt;code&gt;&quot;username&quot;&lt;/code&gt;), which SQL does not. SQL does not allow this command during a transaction; PostgreSQL does not make this restriction because there is no reason to. The &lt;code&gt;SESSION&lt;/code&gt; and &lt;code&gt;LOCAL&lt;/code&gt; modifiers are a PostgreSQL extension, as is the &lt;code&gt;RESET&lt;/code&gt; syntax.</source>
          <target state="translated">SQL標準では、他のいくつかの式をリテラル &lt;code&gt;user_name&lt;/code&gt; の代わりに使用できますが、これらのオプションは実際には重要ではありません。PostgreSQLでは識別子構文（ &lt;code&gt;&quot;username&quot;&lt;/code&gt; ）を使用できますが、SQLでは使用できません。SQLでは、トランザクション中にこのコマンドを使用できません。PostgreSQLには理由がないため、この制限はありません。 &lt;code&gt;SESSION&lt;/code&gt; および &lt;code&gt;LOCAL&lt;/code&gt; 修飾子はようで、PostgreSQLの拡張です &lt;code&gt;RESET&lt;/code&gt; の構文。</target>
        </trans-unit>
        <trans-unit id="473020e153f860561552af61b3a2ab3766cfb98d" translate="yes" xml:space="preserve">
          <source>The SQL standard allows the &lt;code&gt;GRANTED BY&lt;/code&gt; option to be used in all forms of &lt;code&gt;GRANT&lt;/code&gt;. PostgreSQL only supports it when granting role membership, and even then only superusers may use it in nontrivial ways.</source>
          <target state="translated">SQL標準では、 &lt;code&gt;GRANTED BY&lt;/code&gt; オプションをすべての形式の &lt;code&gt;GRANT&lt;/code&gt; で使用できます。PostgreSQLは、ロールメンバーシップを付与する場合にのみサポートし、それでもスーパーユーザーのみが重要な方法で使用できます。</target>
        </trans-unit>
        <trans-unit id="b623e7f141c55510760b9b77e9eb99f9e4321e9e" translate="yes" xml:space="preserve">
          <source>The SQL standard also distinguishes between global and local temporary tables, where a local temporary table has a separate set of contents for each SQL module within each session, though its definition is still shared across sessions. Since PostgreSQL does not support SQL modules, this distinction is not relevant in PostgreSQL.</source>
          <target state="translated">SQL標準では、グローバルテンポラリテーブルとローカルテンポラリテーブルを区別しています。ローカルテンポラリテーブルは、各セッション内の各SQLモジュールに対して別々の内容のセットを持っていますが、その定義はセッション間で共有されています。PostgreSQLはSQLモジュールをサポートしていないので、PostgreSQLではこの区別は関係ありません。</target>
        </trans-unit>
        <trans-unit id="6f9fa0f99df0f3d6e4d172f087bbf08f499d13c0" translate="yes" xml:space="preserve">
          <source>The SQL standard and PostgreSQL-implemented transaction isolation levels are described in &lt;a href=&quot;transaction-iso#MVCC-ISOLEVEL-TABLE&quot;&gt;Table 13.1&lt;/a&gt;.</source>
          <target state="translated">SQL標準およびPostgreSQL実装のトランザクション分離レベルについては、&lt;a href=&quot;transaction-iso#MVCC-ISOLEVEL-TABLE&quot;&gt;表13.1で&lt;/a&gt;説明されています。</target>
        </trans-unit>
        <trans-unit id="e49f9cf60061c8b5fe47367c7175f7b9d12754fa" translate="yes" xml:space="preserve">
          <source>The SQL standard calls databases &amp;ldquo;catalogs&amp;rdquo;, but there is no difference in practice.</source>
          <target state="translated">SQL標準ではデータベースを「カタログ」と呼んでいますが、実際には違いはありません。</target>
        </trans-unit>
        <trans-unit id="f6b9dd41b616b1103c4995e9bab7f0a1474529d1" translate="yes" xml:space="preserve">
          <source>The SQL standard defines &lt;code&gt;DROP ROLE&lt;/code&gt;, but it allows only one role to be dropped at a time, and it specifies different privilege requirements than PostgreSQL uses.</source>
          <target state="translated">SQL標準では &lt;code&gt;DROP ROLE&lt;/code&gt; を定義していますが、一度に1つのロールのみを削除でき、PostgreSQLが使用するのとは異なる特権要件を指定しています。</target>
        </trans-unit>
        <trans-unit id="89dd410d4b1dc70cede977d3716ec82a83bd84ad" translate="yes" xml:space="preserve">
          <source>The SQL standard defines &lt;code&gt;FETCH&lt;/code&gt; for use in embedded SQL only. The variant of &lt;code&gt;FETCH&lt;/code&gt; described here returns the data as if it were a &lt;code&gt;SELECT&lt;/code&gt; result rather than placing it in host variables. Other than this point, &lt;code&gt;FETCH&lt;/code&gt; is fully upward-compatible with the SQL standard.</source>
          <target state="translated">SQL標準では、埋め込みSQLでのみ使用する &lt;code&gt;FETCH&lt;/code&gt; を定義しています。ここで説明する &lt;code&gt;FETCH&lt;/code&gt; のバリアントは、データをホスト変数に置くのではなく、 &lt;code&gt;SELECT&lt;/code&gt; 結果であるかのようにデータを返します。この点を &lt;code&gt;FETCH&lt;/code&gt; 、FETCHはSQL標準と完全に上位互換性があります。</target>
        </trans-unit>
        <trans-unit id="0433545c375e6f7a87b9a6951397354ec73ee790" translate="yes" xml:space="preserve">
          <source>The SQL standard defines a &lt;code&gt;RESPECT NULLS&lt;/code&gt; or &lt;code&gt;IGNORE NULLS&lt;/code&gt; option for &lt;code&gt;lead&lt;/code&gt;, &lt;code&gt;lag&lt;/code&gt;, &lt;code&gt;first_value&lt;/code&gt;, &lt;code&gt;last_value&lt;/code&gt;, and &lt;code&gt;nth_value&lt;/code&gt;. This is not implemented in PostgreSQL: the behavior is always the same as the standard's default, namely &lt;code&gt;RESPECT NULLS&lt;/code&gt;. Likewise, the standard's &lt;code&gt;FROM FIRST&lt;/code&gt; or &lt;code&gt;FROM LAST&lt;/code&gt; option for &lt;code&gt;nth_value&lt;/code&gt; is not implemented: only the default &lt;code&gt;FROM FIRST&lt;/code&gt; behavior is supported. (You can achieve the result of &lt;code&gt;FROM LAST&lt;/code&gt; by reversing the &lt;code&gt;ORDER BY&lt;/code&gt; ordering.)</source>
          <target state="translated">SQL標準では、 &lt;code&gt;lead&lt;/code&gt; 、 &lt;code&gt;lag&lt;/code&gt; 、 &lt;code&gt;first_value&lt;/code&gt; 、 &lt;code&gt;last_value&lt;/code&gt; 、および &lt;code&gt;nth_value&lt;/code&gt; に対して &lt;code&gt;RESPECT NULLS&lt;/code&gt; または &lt;code&gt;IGNORE NULLS&lt;/code&gt; オプションを定義しています。これはPostgreSQLには実装されていません。動作は常に標準のデフォルト、つまり &lt;code&gt;RESPECT NULLS&lt;/code&gt; と同じです。同様に、標準の &lt;code&gt;nth_value&lt;/code&gt; の &lt;code&gt;FROM FIRST&lt;/code&gt; または &lt;code&gt;FROM LAST&lt;/code&gt; オプションは実装されていません。デフォルトの &lt;code&gt;FROM FIRST&lt;/code&gt; 動作のみがサポートされています。 （ &lt;code&gt;ORDER BY&lt;/code&gt; の順序を逆にすることで &lt;code&gt;FROM LAST&lt;/code&gt; の結果を得ることができます。）</target>
        </trans-unit>
        <trans-unit id="fa458ed41634d193bea2fac0154b209dd0cf765a" translate="yes" xml:space="preserve">
          <source>The SQL standard defines a different binary string type, called &lt;code&gt;BLOB&lt;/code&gt; or &lt;code&gt;BINARY LARGE OBJECT&lt;/code&gt;. The input format is different from &lt;code&gt;bytea&lt;/code&gt;, but the provided functions and operators are mostly the same.</source>
          <target state="translated">SQL標準では、 &lt;code&gt;BLOB&lt;/code&gt; または &lt;code&gt;BINARY LARGE OBJECT&lt;/code&gt; と呼ばれる別のバイナリ文字列型を定義しています。入力形式は &lt;code&gt;bytea&lt;/code&gt; とは異なりますが、提供される関数と演算子はほとんど同じです。</target>
        </trans-unit>
        <trans-unit id="a6502238836b3c1e6ea2cb2c05c9c3eff6b47428" translate="yes" xml:space="preserve">
          <source>The SQL standard defines four levels of transaction isolation. The most strict is Serializable, which is defined by the standard in a paragraph which says that any concurrent execution of a set of Serializable transactions is guaranteed to produce the same effect as running them one at a time in some order. The other three levels are defined in terms of phenomena, resulting from interaction between concurrent transactions, which must not occur at each level. The standard notes that due to the definition of Serializable, none of these phenomena are possible at that level. (This is hardly surprising -- if the effect of the transactions must be consistent with having been run one at a time, how could you see any phenomena caused by interactions?)</source>
          <target state="translated">SQL標準では、トランザクションの分離を4つのレベルで定義しています。最も厳密なのはSerializableで、Serializableトランザクションのセットの同時実行は、それらをある順序で一度に一つずつ実行したのと同じ効果をもたらすことが保証されているという段落で標準で定義されています。他の3つのレベルは、同時実行トランザクション間の相互作用から生じる現象の観点から定義されているが、各レベルでは発生してはならない。標準では、Serializableの定義により、そのレベルではこれらの現象のどれも可能ではないことに注意が必要である。トランザクションの効果が一度に1つずつ実行されたことと一致していなければならない場合、相互作用に起因する現象をどのようにして見ることができるのでしょうか?</target>
        </trans-unit>
        <trans-unit id="e0bda65f48165dca64ab0bb74baf32b2635a1f88" translate="yes" xml:space="preserve">
          <source>The SQL standard defines one additional level, &lt;code&gt;READ UNCOMMITTED&lt;/code&gt;. In PostgreSQL &lt;code&gt;READ UNCOMMITTED&lt;/code&gt; is treated as &lt;code&gt;READ COMMITTED&lt;/code&gt;.</source>
          <target state="translated">SQL標準では、 &lt;code&gt;READ UNCOMMITTED&lt;/code&gt; という 1つの追加レベルが定義されています。PostgreSQLでは、 &lt;code&gt;READ UNCOMMITTED&lt;/code&gt; は &lt;code&gt;READ COMMITTED&lt;/code&gt; として扱われます。</target>
        </trans-unit>
        <trans-unit id="4646156599f749581333cb75ad841c671d1c0b23" translate="yes" xml:space="preserve">
          <source>The SQL standard defines the concepts of users and roles, but it regards them as distinct concepts and leaves all commands defining users to be specified by each database implementation. In PostgreSQL we have chosen to unify users and roles into a single kind of entity. Roles therefore have many more optional attributes than they do in the standard.</source>
          <target state="translated">SQL標準ではユーザとロールの概念を定義していますが、それらを別個の概念とみなし、ユーザを定義するすべてのコマンドはデータベースの実装ごとに指定するようにしています。PostgreSQLでは、ユーザとロールを単一の種類の実体に統一することを選択しました。そのため、ロールは標準の属性よりも多くのオプション属性を持っています。</target>
        </trans-unit>
        <trans-unit id="0663b6424dd2f8b2135d82962a5208510f77e258" translate="yes" xml:space="preserve">
          <source>The SQL standard defines two &lt;em&gt;passing mechanisms&lt;/em&gt; that apply when passing an XML argument from SQL to an XML function or receiving a result: &lt;code&gt;BY REF&lt;/code&gt;, in which a particular XML value retains its node identity, and &lt;code&gt;BY VALUE&lt;/code&gt;, in which the content of the XML is passed but node identity is not preserved. A mechanism can be specified before a list of parameters, as the default mechanism for all of them, or after any parameter, to override the default.</source>
          <target state="translated">SQL標準では、SQLからXML関数にXML引数を渡すとき、または結果を受け取るときに適用される2つの&lt;em&gt;受け渡しメカニズム&lt;/em&gt;が定義されています &lt;code&gt;BY REF&lt;/code&gt; （特定のXML値がノードIDを保持する）と &lt;code&gt;BY VALUE&lt;/code&gt; （XMLのコンテンツが保持される）は渡されますが、ノードIDは保持されません。メカニズムは、パラメーターのリストの前、パラメーターのすべてのデフォルトメカニズムとして、またはパラメーターの後に指定して、デフォルトをオーバーライドできます。</target>
        </trans-unit>
        <trans-unit id="8be5477647682fea4652e9633a7fdf7ae02cb95d" translate="yes" xml:space="preserve">
          <source>The SQL standard differentiates &lt;code&gt;timestamp without time zone&lt;/code&gt; and &lt;code&gt;timestamp with time zone&lt;/code&gt; literals by the presence of a &amp;ldquo;+&amp;rdquo; or &amp;ldquo;-&amp;rdquo; symbol and time zone offset after the time. Hence, according to the standard,</source>
          <target state="translated">SQL標準では、 &lt;code&gt;timestamp with time zone&lt;/code&gt; &lt;code&gt;timestamp without time zone&lt;/code&gt; タイムスタンプとタイムゾーンリテラルのあるタイムスタンプを、「+」または「-」の記号の存在と、タイムゾーンオフセットの後に表示します。したがって、標準によれば、</target>
        </trans-unit>
        <trans-unit id="e664f1068d4185a0e2c4e6676631526d39744df1" translate="yes" xml:space="preserve">
          <source>The SQL standard includes a &lt;code&gt;DEALLOCATE&lt;/code&gt; statement, but it is only for use in embedded SQL.</source>
          <target state="translated">SQL標準には &lt;code&gt;DEALLOCATE&lt;/code&gt; 文が含まれていますが、これは埋め込みSQLでのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="c90f74b3a15257d28d6e4bb3296f2c0e98aadae3" translate="yes" xml:space="preserve">
          <source>The SQL standard includes a &lt;code&gt;PREPARE&lt;/code&gt; statement, but it is only for use in embedded SQL. This version of the &lt;code&gt;PREPARE&lt;/code&gt; statement also uses a somewhat different syntax.</source>
          <target state="translated">SQL標準には &lt;code&gt;PREPARE&lt;/code&gt; ステートメントが含まれていますが、これは埋め込みSQLでのみ使用できます。このバージョンの &lt;code&gt;PREPARE&lt;/code&gt; ステートメントも、多少異なる構文を使用しています。</target>
        </trans-unit>
        <trans-unit id="fe224ee017c2bd35d24d44088347efdd2b498c3d" translate="yes" xml:space="preserve">
          <source>The SQL standard includes an &lt;code&gt;EXECUTE&lt;/code&gt; statement, but it is only for use in embedded SQL. This version of the &lt;code&gt;EXECUTE&lt;/code&gt; statement also uses a somewhat different syntax.</source>
          <target state="translated">SQL標準には &lt;code&gt;EXECUTE&lt;/code&gt; ステートメントが含まれていますが、これは埋め込みSQLでのみ使用できます。このバージョンの &lt;code&gt;EXECUTE&lt;/code&gt; ステートメントも、多少異なる構文を使用しています。</target>
        </trans-unit>
        <trans-unit id="3efa28b82e46f4409adc369dc8a870c8a673cbae" translate="yes" xml:space="preserve">
          <source>The SQL standard only makes provisions for cursors in embedded SQL. The PostgreSQL server does not implement an &lt;code&gt;OPEN&lt;/code&gt; statement for cursors; a cursor is considered to be open when it is declared. However, ECPG, the embedded SQL preprocessor for PostgreSQL, supports the standard SQL cursor conventions, including those involving &lt;code&gt;DECLARE&lt;/code&gt; and &lt;code&gt;OPEN&lt;/code&gt; statements.</source>
          <target state="translated">SQL標準では、埋め込みSQLのカーソルのみがプロビジョニングされます。PostgreSQLサーバーはカーソルの &lt;code&gt;OPEN&lt;/code&gt; ステートメントを実装していません。カーソルは宣言されたときに開いていると見なされます。ただし、PostgreSQLの埋め込みSQLプリプロセッサであるECPGは、 &lt;code&gt;DECLARE&lt;/code&gt; ステートメントや &lt;code&gt;OPEN&lt;/code&gt; ステートメントを含む標準SQLカーソル規則をサポートしています。</target>
        </trans-unit>
        <trans-unit id="27a77950710338562f963e53983e9db24c286f83" translate="yes" xml:space="preserve">
          <source>The SQL standard provides for a &lt;code&gt;USAGE&lt;/code&gt; privilege on other kinds of objects: character sets, collations, translations.</source>
          <target state="translated">SQL標準では、他の種類のオブジェクト（文字セット、照合順序、翻訳）に対する &lt;code&gt;USAGE&lt;/code&gt; 特権が提供されています。</target>
        </trans-unit>
        <trans-unit id="eee762b9a6787226a912a1d85c8be87d3dbf797a" translate="yes" xml:space="preserve">
          <source>The SQL standard requires commas between successive &lt;code&gt;transaction_modes&lt;/code&gt;, but for historical reasons PostgreSQL allows the commas to be omitted.</source>
          <target state="translated">SQL標準では、連続する &lt;code&gt;transaction_modes&lt;/code&gt; の間にカンマが必要ですが、歴史的な理由により、PostgreSQLではカンマを省略できます。</target>
        </trans-unit>
        <trans-unit id="0cdcd239c4d51fe5d06e09469371cb72d1e4c5cc" translate="yes" xml:space="preserve">
          <source>The SQL standard requires parentheses around the table name when writing &lt;code&gt;ONLY&lt;/code&gt;, for example &lt;code&gt;SELECT * FROM ONLY (tab1), ONLY (tab2) WHERE ...&lt;/code&gt;. PostgreSQL considers these parentheses to be optional.</source>
          <target state="translated">SQL標準では、 &lt;code&gt;ONLY&lt;/code&gt; を書き込むときに、テーブル名を括弧で囲む必要があります。たとえば、 &lt;code&gt;SELECT * FROM ONLY (tab1), ONLY (tab2) WHERE ...&lt;/code&gt; 。PostgreSQLはこれらの括弧をオプションと見なします。</target>
        </trans-unit>
        <trans-unit id="9c327a647bb63bff5c4e11d3c2640afdd42ebe7e" translate="yes" xml:space="preserve">
          <source>The SQL standard requires that writing just &lt;code&gt;timestamp&lt;/code&gt; be equivalent to &lt;code&gt;timestamp without time zone&lt;/code&gt;, and PostgreSQL honors that behavior. &lt;code&gt;timestamptz&lt;/code&gt; is accepted as an abbreviation for &lt;code&gt;timestamp with time zone&lt;/code&gt;; this is a PostgreSQL extension.</source>
          <target state="translated">SQL標準では、 &lt;code&gt;timestamp&lt;/code&gt; のみを書き込む &lt;code&gt;timestamp without time zone&lt;/code&gt; タイムスタンプと同等であることを要求し、PostgreSQLはその動作を尊重します。 &lt;code&gt;timestamptz&lt;/code&gt; は &lt;code&gt;timestamp with time zone&lt;/code&gt; 省略形として受け入れられます。これはPostgreSQLの拡張機能です。</target>
        </trans-unit>
        <trans-unit id="b32d323a75124833c9180676bb48b77e9c8490b4" translate="yes" xml:space="preserve">
          <source>The SQL standard says that &lt;code&gt;CHECK&lt;/code&gt; column constraints can only refer to the column they apply to; only &lt;code&gt;CHECK&lt;/code&gt; table constraints can refer to multiple columns. PostgreSQL does not enforce this restriction; it treats column and table check constraints alike.</source>
          <target state="translated">SQL標準では、 &lt;code&gt;CHECK&lt;/code&gt; 列制約は、それらが適用される列のみを参照できるとしています。複数の列を参照できるのは、 &lt;code&gt;CHECK&lt;/code&gt; テーブル制約のみです。PostgreSQLはこの制限を強制しません。列とテーブルのチェック制約を同じように扱います。</target>
        </trans-unit>
        <trans-unit id="17cd16f5bf5a8ca370f92a98424035c167fcaa79" translate="yes" xml:space="preserve">
          <source>The SQL standard says that it is implementation-dependent whether cursors are sensitive to concurrent updates of the underlying data by default. In PostgreSQL, cursors are insensitive by default, and can be made sensitive by specifying &lt;code&gt;FOR UPDATE&lt;/code&gt;. Other products may work differently.</source>
          <target state="translated">SQL標準では、デフォルトでカーソルが基礎となるデータの同時更新に敏感であるかどうかは、実装に依存するとしています。PostgreSQLでは、カーソルはデフォルトで無効であり、 &lt;code&gt;FOR UPDATE&lt;/code&gt; を指定することで有効にすることができます。他の製品は動作が異なる場合があります。</target>
        </trans-unit>
        <trans-unit id="6c0e6c19202fe94a3734c19398394df433a6c622" translate="yes" xml:space="preserve">
          <source>The SQL standard says that table and domain constraints must have names that are unique across the schema containing the table or domain. PostgreSQL is laxer: it only requires constraint names to be unique across the constraints attached to a particular table or domain. However, this extra freedom does not exist for index-based constraints (&lt;code&gt;UNIQUE&lt;/code&gt;, &lt;code&gt;PRIMARY KEY&lt;/code&gt;, and &lt;code&gt;EXCLUDE&lt;/code&gt; constraints), because the associated index is named the same as the constraint, and index names must be unique across all relations within the same schema.</source>
          <target state="translated">SQL標準では、テーブルとドメインの制約には、テーブルまたはドメインを含むスキーマ全体で一意の名前を付ける必要があると規定されています。PostgreSQLは緩いです。特定のテーブルまたはドメインに関連付けられている制約全体で一意である必要がある制約名のみです。ただし、この追加の自由度は、インデックスベースの制約（ &lt;code&gt;UNIQUE&lt;/code&gt; 、 &lt;code&gt;PRIMARY KEY&lt;/code&gt; 、および &lt;code&gt;EXCLUDE&lt;/code&gt; 制約）には存在しません。関連付けられたインデックスには制約と同じ名前が付けられ、インデックス名は同じスキーマ内のすべての関係で一意である必要があるためです。</target>
        </trans-unit>
        <trans-unit id="5a79884799ecc17f7b669e9ed40107182ffe5aca" translate="yes" xml:space="preserve">
          <source>The SQL standard specifies that &lt;code&gt;OVERRIDING SYSTEM VALUE&lt;/code&gt; can only be specified if an identity column that is generated always exists. PostgreSQL allows the clause in any case and ignores it if it is not applicable.</source>
          <target state="translated">SQL標準では、生成されるID列が常に存在する場合にのみ、 &lt;code&gt;OVERRIDING SYSTEM VALUE&lt;/code&gt; を指定できると規定されています。PostgreSQLはどのような場合でもこの句を許可し、該当しない場合は無視します。</target>
        </trans-unit>
        <trans-unit id="5b1e1c604541e0514a1f4ecda3cb5b97bda57985" translate="yes" xml:space="preserve">
          <source>The SQL standard specifies that the key word &lt;code&gt;SAVEPOINT&lt;/code&gt; is mandatory, but PostgreSQL and Oracle allow it to be omitted. SQL allows only &lt;code&gt;WORK&lt;/code&gt;, not &lt;code&gt;TRANSACTION&lt;/code&gt;, as a noise word after &lt;code&gt;ROLLBACK&lt;/code&gt;. Also, SQL has an optional clause &lt;code&gt;AND [ NO ] CHAIN&lt;/code&gt; which is not currently supported by PostgreSQL. Otherwise, this command conforms to the SQL standard.</source>
          <target state="translated">SQL標準では、キーワード &lt;code&gt;SAVEPOINT&lt;/code&gt; は必須であると指定されていますが、PostgreSQLとOracleでは省略可能です。SQLのみを可能に &lt;code&gt;WORK&lt;/code&gt; 、ない &lt;code&gt;TRANSACTION&lt;/code&gt; 後のノイズワードとして、 &lt;code&gt;ROLLBACK&lt;/code&gt; 。また、SQLにはオプションの句 &lt;code&gt;AND [ NO ] CHAIN&lt;/code&gt; ありますが、現在PostgreSQLではサポートされていません。それ以外の場合、このコマンドはSQL標準に準拠しています。</target>
        </trans-unit>
        <trans-unit id="4ef02d5b8713fad53d23c6b10f7669991c2a9427" translate="yes" xml:space="preserve">
          <source>The SQL standard specifies that the subcommands in &lt;code&gt;CREATE SCHEMA&lt;/code&gt; can appear in any order. The present PostgreSQL implementation does not handle all cases of forward references in subcommands; it might sometimes be necessary to reorder the subcommands in order to avoid forward references.</source>
          <target state="translated">SQL標準では、 &lt;code&gt;CREATE SCHEMA&lt;/code&gt; のサブコマンドは任意の順序で指定できると規定されています。現在のPostgreSQL実装は、サブコマンドでの前方参照のすべてのケースを処理するわけではありません。前方参照を回避するために、サブコマンドを並べ替える必要がある場合があります。</target>
        </trans-unit>
        <trans-unit id="7b4258f023ecf83c293dc59266efcd9181140a14" translate="yes" xml:space="preserve">
          <source>The SQL standard states that &amp;ldquo;Within the definition of a &amp;lsquo;datetime literal&amp;rsquo;, the &amp;lsquo;datetime values&amp;rsquo; are constrained by the natural rules for dates and times according to the Gregorian calendar&amp;rdquo;. PostgreSQL follows the SQL standard's lead by counting dates exclusively in the Gregorian calendar, even for years before that calendar was in use. This rule is known as the &lt;em&gt;proleptic Gregorian calendar&lt;/em&gt;.</source>
          <target state="translated">SQL標準では、「 'datetimeリテラル'の定義内では、 'datetimeの値'はグレゴリオ暦による日付と時刻の自然な規則によって制約されています」と述べています。 PostgreSQLは、グレゴリオ暦でのみ日付をカウントすることにより、その暦が使用される前の年についても、SQL標準の先導に従っています。このルールは、前発性&lt;em&gt;グレゴリオ暦&lt;/em&gt;として知られています。</target>
        </trans-unit>
        <trans-unit id="d19cb60e6641fce6ca2d40fc0e7200daf402177c" translate="yes" xml:space="preserve">
          <source>The SQL standard uses &lt;code&gt;SELECT INTO&lt;/code&gt; to represent selecting values into scalar variables of a host program, rather than creating a new table. This indeed is the usage found in ECPG (see &lt;a href=&quot;https://www.postgresql.org/docs/12/ecpg.html&quot;&gt;Chapter 35&lt;/a&gt;) and PL/pgSQL (see &lt;a href=&quot;https://www.postgresql.org/docs/12/plpgsql.html&quot;&gt;Chapter 42&lt;/a&gt;). The PostgreSQL usage of &lt;code&gt;SELECT INTO&lt;/code&gt; to represent table creation is historical. It is best to use &lt;code&gt;CREATE TABLE AS&lt;/code&gt; for this purpose in new code.</source>
          <target state="translated">SQL標準では、 &lt;code&gt;SELECT INTO&lt;/code&gt; を使用して、新しいテーブルを作成するのではなく、ホストプログラムのスカラー変数への選択値を表します。これは確かに、ECPG（&lt;a href=&quot;https://www.postgresql.org/docs/12/ecpg.html&quot;&gt;第35章を&lt;/a&gt;参照）およびPL / pgSQL（&lt;a href=&quot;https://www.postgresql.org/docs/12/plpgsql.html&quot;&gt;第42章を&lt;/a&gt;参照）で見られる使用法です。テーブルの作成を表すための &lt;code&gt;SELECT INTO&lt;/code&gt; のPostgreSQLの使用は歴史的です。新しいコードでこの目的のために &lt;code&gt;CREATE TABLE AS&lt;/code&gt; を使用するのが最善です。</target>
        </trans-unit>
        <trans-unit id="975d3d6f53b33edd080d2a6f73dab7ae808007c0" translate="yes" xml:space="preserve">
          <source>The SQL standard uses &lt;code&gt;SELECT INTO&lt;/code&gt; to represent selecting values into scalar variables of a host program, rather than creating a new table. This indeed is the usage found in ECPG (see &lt;a href=&quot;https://www.postgresql.org/docs/13/ecpg.html&quot;&gt;Chapter 35&lt;/a&gt;) and PL/pgSQL (see &lt;a href=&quot;https://www.postgresql.org/docs/13/plpgsql.html&quot;&gt;Chapter 42&lt;/a&gt;). The PostgreSQL usage of &lt;code&gt;SELECT INTO&lt;/code&gt; to represent table creation is historical. It is best to use &lt;code&gt;CREATE TABLE AS&lt;/code&gt; for this purpose in new code.</source>
          <target state="translated">SQL標準では、新しいテーブルを作成するのではなく、 &lt;code&gt;SELECT INTO&lt;/code&gt; を使用してホストプログラムのスカラー変数への値の選択を表します。これは確かに、ECPG（&lt;a href=&quot;https://www.postgresql.org/docs/13/ecpg.html&quot;&gt;第35章を&lt;/a&gt;参照）およびPL / pgSQL（&lt;a href=&quot;https://www.postgresql.org/docs/13/plpgsql.html&quot;&gt;第42章を&lt;/a&gt;参照）で見られる使用法です。PostgreSQLの使用 &lt;code&gt;SELECT INTO&lt;/code&gt; テーブル作成を表すためには、歴史的です。新しいコードでは、この目的のために &lt;code&gt;CREATE TABLE AS&lt;/code&gt; を使用するのが最善です。</target>
        </trans-unit>
        <trans-unit id="fe56d39f2bcc805d7f67d5dc92546476c02ed72d" translate="yes" xml:space="preserve">
          <source>The SQL standard uses this term to indicate what is called a &lt;a href=&quot;glossary#GLOSSARY-DATABASE&quot;&gt;database&lt;/a&gt; in PostgreSQL's terminology.</source>
          <target state="translated">SQL標準では、この用語を使用して、PostgreSQLの用語で&lt;a href=&quot;glossary#GLOSSARY-DATABASE&quot;&gt;データベース&lt;/a&gt;と呼ばれるものを示しています。</target>
        </trans-unit>
        <trans-unit id="7f96ecc2fb3538c905f725be2098ce0d65cd6679" translate="yes" xml:space="preserve">
          <source>The SQL syntax is not very consistent regarding what tokens identify commands and which are operands or parameters. The first few tokens are generally the command name, so in the above example we would usually speak of a &amp;ldquo;SELECT&amp;rdquo;, an &amp;ldquo;UPDATE&amp;rdquo;, and an &amp;ldquo;INSERT&amp;rdquo; command. But for instance the &lt;code&gt;UPDATE&lt;/code&gt; command always requires a &lt;code&gt;SET&lt;/code&gt; token to appear in a certain position, and this particular variation of &lt;code&gt;INSERT&lt;/code&gt; also requires a &lt;code&gt;VALUES&lt;/code&gt; in order to be complete. The precise syntax rules for each command are described in &lt;a href=&quot;index&quot;&gt;Part VI&lt;/a&gt;.</source>
          <target state="translated">SQL構文は、どのトークンがコマンドを識別し、どれがオペランドまたはパラメーターであるかに関して、あまり一貫性がありません。最初のいくつかのトークンは通常コマンド名であるため、上記の例では、通常、「SELECT」、「UPDATE」、および「INSERT」コマンドについて説明します。しかし、たとえば、 &lt;code&gt;UPDATE&lt;/code&gt; コマンドでは、常に特定の位置に &lt;code&gt;SET&lt;/code&gt; トークンを表示する必要があり、 &lt;code&gt;INSERT&lt;/code&gt; のこの特定のバリエーションも、完了するために &lt;code&gt;VALUES&lt;/code&gt; を必要とします。各コマンドの正確な構文規則は、&lt;a href=&quot;index&quot;&gt;パートVIで&lt;/a&gt;説明されています。</target>
        </trans-unit>
        <trans-unit id="bb05fc557b9719130cdacd9aa3c915a94bbdf061" translate="yes" xml:space="preserve">
          <source>The SQL/JSON standard borrows its definition for regular expressions from the &lt;code&gt;LIKE_REGEX&lt;/code&gt; operator, which in turn uses the XQuery standard. PostgreSQL does not currently support the &lt;code&gt;LIKE_REGEX&lt;/code&gt; operator. Therefore, the &lt;code&gt;like_regex&lt;/code&gt; filter is implemented using the POSIX regular expression engine described in &lt;a href=&quot;functions-matching#FUNCTIONS-POSIX-REGEXP&quot;&gt;Section 9.7.3&lt;/a&gt;. This leads to various minor discrepancies from standard SQL/JSON behavior, which are cataloged in &lt;a href=&quot;functions-matching#POSIX-VS-XQUERY&quot;&gt;Section 9.7.3.8&lt;/a&gt;. Note, however, that the flag-letter incompatibilities described there do not apply to SQL/JSON, as it translates the XQuery flag letters to match what the POSIX engine expects.</source>
          <target state="translated">SQL / JSON標準は、 &lt;code&gt;LIKE_REGEX&lt;/code&gt; 演算子から正規表現の定義を借用し、LIKE_REGEX演算子はXQuery標準を使用します。現在、PostgreSQLは &lt;code&gt;LIKE_REGEX&lt;/code&gt; 演算子をサポートしていません。したがって、 &lt;code&gt;like_regex&lt;/code&gt; フィルターは、&lt;a href=&quot;functions-matching#FUNCTIONS-POSIX-REGEXP&quot;&gt;セクション9.7.3で&lt;/a&gt;説明されているPOSIX正規表現エンジンを使用して実装されます。これにより、標準のSQL / JSON動作とのさまざまなマイナーな不一致が&lt;a href=&quot;functions-matching#POSIX-VS-XQUERY&quot;&gt;発生し&lt;/a&gt;ます。これは、セクション9.7.3.8でカタログ化されています。ただし、そこで説明されているフラグ文字の非互換性はSQL / JSONには適用されないことに注意してください。これは、XQueryフラグ文字を変換してPOSIXエンジンが期待するものと一致させるためです。</target>
        </trans-unit>
        <trans-unit id="2c1fd14d6c7b89183a3f90fd72282a55b3166126" translate="yes" xml:space="preserve">
          <source>The SQL:2008 standard includes a &lt;code&gt;TRUNCATE&lt;/code&gt; command with the syntax &lt;code&gt;TRUNCATE TABLE tablename&lt;/code&gt;. The clauses &lt;code&gt;CONTINUE IDENTITY&lt;/code&gt;/&lt;code&gt;RESTART IDENTITY&lt;/code&gt; also appear in that standard, but have slightly different though related meanings. Some of the concurrency behavior of this command is left implementation-defined by the standard, so the above notes should be considered and compared with other implementations if necessary.</source>
          <target state="translated">SQL：2008標準は、 &lt;code&gt;TRUNCATE&lt;/code&gt; の構文でコマンド &lt;code&gt;TRUNCATE TABLE tablename&lt;/code&gt; 。節 &lt;code&gt;CONTINUE IDENTITY&lt;/code&gt; / &lt;code&gt;RESTART IDENTITY&lt;/code&gt; もその規格に表示されますが、関連する意味は多少異なります。このコマンドの同時実行動作の一部は、標準で実装定義されているため、上記の注意事項を考慮し、必要に応じて他の実装と比較する必要があります。</target>
        </trans-unit>
        <trans-unit id="0be6f583c1240a1ebc14deaf65c6d5260c133db4" translate="yes" xml:space="preserve">
          <source>The Serializable isolation level is implemented using a technique known in academic database literature as Serializable Snapshot Isolation, which builds on Snapshot Isolation by adding checks for serialization anomalies. Some differences in behavior and performance may be observed when compared with other systems that use a traditional locking technique. Please see &lt;a href=&quot;https://www.postgresql.org/docs/13/biblio.html#PORTS12&quot;&gt;[ports12]&lt;/a&gt; for detailed information.</source>
          <target state="translated">シリアル化可能な分離レベルは、学術データベースの文献でシリアル化可能なスナップショット分離として知られている手法を使用して実装されます。これは、シリアル化の異常のチェックを追加することにより、スナップショット分離に基づいています。従来のロック技術を使用する他のシステムと比較すると、動作とパフォーマンスにいくつかの違いが見られる場合があります。詳細については、&lt;a href=&quot;https://www.postgresql.org/docs/13/biblio.html#PORTS12&quot;&gt;[ports12]&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="106deb17fc13475a8af50970b808cc1e2661d130" translate="yes" xml:space="preserve">
          <source>The Serializable transaction isolation level is not yet available in hot standby. (See &lt;a href=&quot;transaction-iso#XACT-SERIALIZABLE&quot;&gt;Section 13.2.3&lt;/a&gt; and &lt;a href=&quot;applevel-consistency#SERIALIZABLE-CONSISTENCY&quot;&gt;Section 13.4.1&lt;/a&gt; for details.) An attempt to set a transaction to the serializable isolation level in hot standby mode will generate an error.</source>
          <target state="translated">シリアル化可能なトランザクション分離レベルは、ホットスタンバイではまだ使用できません。（参照&lt;a href=&quot;transaction-iso#XACT-SERIALIZABLE&quot;&gt;13.2.3&lt;/a&gt;および&lt;a href=&quot;applevel-consistency#SERIALIZABLE-CONSISTENCY&quot;&gt;セクション13.4.1&lt;/a&gt;、ホットスタンバイモードでシリアライズ可能分離レベルにトランザクションを設定するための詳細については。）しようとすると、エラーが発生します。</target>
        </trans-unit>
        <trans-unit id="66e4ba5dbccb413a9c06a219a5d2e98558807585" translate="yes" xml:space="preserve">
          <source>The Snowball dictionary template is based on a project by Martin Porter, inventor of the popular Porter's stemming algorithm for the English language. Snowball now provides stemming algorithms for many languages (see the &lt;a href=&quot;http://snowballstem.org/&quot;&gt;Snowball site&lt;/a&gt; for more information). Each algorithm understands how to reduce common variant forms of words to a base, or stem, spelling within its language. A Snowball dictionary requires a &lt;code&gt;language&lt;/code&gt; parameter to identify which stemmer to use, and optionally can specify a &lt;code&gt;stopword&lt;/code&gt; file name that gives a list of words to eliminate. (PostgreSQL's standard stopword lists are also provided by the Snowball project.) For example, there is a built-in definition equivalent to</source>
          <target state="translated">Snowball辞書テンプレートは、人気のあるポーターの英語のステミングアルゴリズムの発明者であるマーティンポーターによるプロジェクトに基づいています。 Snowballは現在、多くの言語用のステミングアルゴリズムを提供しています（詳細については、&lt;a href=&quot;http://snowballstem.org/&quot;&gt;Snowballサイト&lt;/a&gt;を参照してください）。各アルゴリズムは、一般的な異形の単語を、その言語内のベースまたはステムのスペルに減らす方法を理解しています。 Snowball辞書は、使用するステマーを識別するための &lt;code&gt;language&lt;/code&gt; パラメーターを必要とし、オプションで、除去する単語のリストを提供する &lt;code&gt;stopword&lt;/code&gt; ファイル名を指定できます。 （PostgreSQLの標準ストップワードリストもSnowballプロジェクトによって提供されています。）たとえば、以下に相当する組み込みの定義があります。</target>
        </trans-unit>
        <trans-unit id="00f96728bd51fe9881e179ce29f4aab84f3a0eb5" translate="yes" xml:space="preserve">
          <source>The Snowball dictionary template is based on a project by Martin Porter, inventor of the popular Porter's stemming algorithm for the English language. Snowball now provides stemming algorithms for many languages (see the &lt;a href=&quot;https://snowballstem.org/&quot;&gt;Snowball site&lt;/a&gt; for more information). Each algorithm understands how to reduce common variant forms of words to a base, or stem, spelling within its language. A Snowball dictionary requires a &lt;code&gt;language&lt;/code&gt; parameter to identify which stemmer to use, and optionally can specify a &lt;code&gt;stopword&lt;/code&gt; file name that gives a list of words to eliminate. (PostgreSQL's standard stopword lists are also provided by the Snowball project.) For example, there is a built-in definition equivalent to</source>
          <target state="translated">Snowball辞書テンプレートは、人気のあるPorterの英語のステミングアルゴリズムの発明者であるMartinPorterによるプロジェクトに基づいています。 Snowballは現在、多くの言語のステミングアルゴリズムを提供しています（詳細については、&lt;a href=&quot;https://snowballstem.org/&quot;&gt;Snowballサイト&lt;/a&gt;を参照してください）。各アルゴリズムは、単語の一般的な異形を、その​​言語内のベースまたはステムのスペルに減らす方法を理解しています。 Snowball辞書には、使用するステマーを識別するための &lt;code&gt;language&lt;/code&gt; パラメーターが必要です。オプションで、削除する単語のリストを提供する &lt;code&gt;stopword&lt;/code&gt; ファイル名を指定できます。 （PostgreSQLの標準ストップワードリストもSnowballプロジェクトによって提供されます。）たとえば、次のような組み込みの定義があります。</target>
        </trans-unit>
        <trans-unit id="13e42c2d23de5bce64e42840619341e599527d06" translate="yes" xml:space="preserve">
          <source>The Sort node shows the sort method used (in particular, whether the sort was in-memory or on-disk) and the amount of memory or disk space needed. The Hash node shows the number of hash buckets and batches as well as the peak amount of memory used for the hash table. (If the number of batches exceeds one, there will also be disk space usage involved, but that is not shown.)</source>
          <target state="translated">ソートノードは、使用されたソート方法(特に、ソートがインメモリかオンディスクか)と、必要とされるメモリまたはディスク容量を示します。Hashノードは、ハッシュバケットとバッチの数と、ハッシュテーブルに使用されたメモリのピーク量を示します。(バッチ数が1を超える場合は、ディスク容量の使用量も関係しますが、それは表示されません)。</target>
        </trans-unit>
        <trans-unit id="ffcd4e9238fc5943a8a630abc801447e679c88d8" translate="yes" xml:space="preserve">
          <source>The Soundex system is a method of matching similar-sounding names by converting them to the same code. It was initially used by the United States Census in 1880, 1900, and 1910. Note that Soundex is not very useful for non-English names.</source>
          <target state="translated">サウンドデックス方式とは、似たような響きの名前を同一符号に変換して照合する方法である。これは当初、1880年、1900年、1910年の米国国勢調査で使用されていました。Soundexは英語以外の名前にはあまり役に立たないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="30ad8964ef3e16d1b565ba3b7fd4ae7ed8f17e69" translate="yes" xml:space="preserve">
          <source>The TCP port the server listens on; 5432 by default. Note that the same port number is used for all IP addresses the server listens on. This parameter can only be set at server start.</source>
          <target state="translated">サーバが listen する TCP ポート。デフォルトでは 5432。サーバがリッスンするすべての IP アドレスに同じポート番号が使用されることに注意してください。このパラメータは、サーバの起動時にのみ設定できます。</target>
        </trans-unit>
        <trans-unit id="4a5c86c75e37eef9f48a99edd2521f09dbad0224" translate="yes" xml:space="preserve">
          <source>The TOAST management code is triggered only when a row value to be stored in a table is wider than &lt;code&gt;TOAST_TUPLE_THRESHOLD&lt;/code&gt; bytes (normally 2 kB). The TOAST code will compress and/or move field values out-of-line until the row value is shorter than &lt;code&gt;TOAST_TUPLE_TARGET&lt;/code&gt; bytes (also normally 2 kB, adjustable) or no more gains can be had. During an UPDATE operation, values of unchanged fields are normally preserved as-is; so an UPDATE of a row with out-of-line values incurs no TOAST costs if none of the out-of-line values change.</source>
          <target state="translated">TOAST管理コードは、テーブルに格納される行の値が &lt;code&gt;TOAST_TUPLE_THRESHOLD&lt;/code&gt; バイト（通常は2 kB）より大きい場合にのみトリガーされます。 TOASTコードは、行の値が &lt;code&gt;TOAST_TUPLE_TARGET&lt;/code&gt; バイト（通常は2 kB、調整可能）よりも短くなるか、それ以上の利益が得られなくなるまで、フィールド値を圧縮して行外に移動します。 UPDATE操作中、通常、変更されていないフィールドの値はそのまま保持されます。したがって、行外の値を含む行のUPDATEでは、行外の値が変更されない場合、TOASTコストは発生しません。</target>
        </trans-unit>
        <trans-unit id="2962f8d4658219a67247690e9e9ec2e5d8ddb34b" translate="yes" xml:space="preserve">
          <source>The TOAST management code recognizes four different strategies for storing TOAST-able columns on disk:</source>
          <target state="translated">TOAST管理コードは、ディスク上にTOAST可能なカラムを格納するための4つの異なる戦略を認識しています。</target>
        </trans-unit>
        <trans-unit id="a81c03b713c7e31311d0848c27a627beb8a79d13" translate="yes" xml:space="preserve">
          <source>The Time Stamp Counter (TSC) clock source is the most accurate one available on current generation CPUs. It's the preferred way to track the system time when it's supported by the operating system and the TSC clock is reliable. There are several ways that TSC can fail to provide an accurate timing source, making it unreliable. Older systems can have a TSC clock that varies based on the CPU temperature, making it unusable for timing. Trying to use TSC on some older multicore CPUs can give a reported time that's inconsistent among multiple cores. This can result in the time going backwards, a problem this program checks for. And even the newest systems can fail to provide accurate TSC timing with very aggressive power saving configurations.</source>
          <target state="translated">タイムスタンプカウンター(TSC)クロックソースは、現世代のCPUで利用可能な最も正確なものです。オペレーティングシステムがサポートしており、TSCクロックが信頼できる場合、システムの時間を追跡するのに適した方法です。TSCが正確なタイミングソースを提供できず、信頼性が低くなる方法はいくつかあります。古いシステムでは、CPU の温度に応じて TSC クロックが変化し、タイミングを取るのに使用できなくなることがあります。古いマルチコアCPUでTSCを使用しようとすると、複数のコア間で時間が不一致になることがあります。これは、このプログラムがチェックしている問題で、時間が逆行する可能性があります。また、最新のシステムであっても、非常に積極的な省電力構成では、正確なTSCタイミングを提供できないことがあります。</target>
        </trans-unit>
        <trans-unit id="42e64c3210927fbc153414d6d364fd7a502138f4" translate="yes" xml:space="preserve">
          <source>The URL scheme &lt;code&gt;ldaps&lt;/code&gt; chooses the LDAPS method for making LDAP connections over SSL, equivalent to using &lt;code&gt;ldapscheme=ldaps&lt;/code&gt;. To use encrypted LDAP connections using the &lt;code&gt;StartTLS&lt;/code&gt; operation, use the normal URL scheme &lt;code&gt;ldap&lt;/code&gt; and specify the &lt;code&gt;ldaptls&lt;/code&gt; option in addition to &lt;code&gt;ldapurl&lt;/code&gt;.</source>
          <target state="translated">URLスキーム &lt;code&gt;ldaps&lt;/code&gt; は、SSLを介してLDAP接続を確立するためにLDAPSメソッドを選択し &lt;code&gt;ldapscheme=ldaps&lt;/code&gt; 。これは、ldapscheme = ldapsを使用する場合と同じです。 &lt;code&gt;StartTLS&lt;/code&gt; 操作を使用して暗号化されたLDAP接続を使用するには、通常のURLスキーム &lt;code&gt;ldap&lt;/code&gt; を使用し、 &lt;code&gt;ldaptls&lt;/code&gt; に加えて &lt;code&gt;ldapurl&lt;/code&gt; オプションを指定します。</target>
        </trans-unit>
        <trans-unit id="7c6010c68a5af10d545c5e024dfa86cf3e81ff1d" translate="yes" xml:space="preserve">
          <source>The Unicode escape syntax works fully only when the server encoding is &lt;code&gt;UTF8&lt;/code&gt;. When other server encodings are used, only code points in the ASCII range (up to &lt;code&gt;\u007F&lt;/code&gt;) can be specified. Both the 4-digit and the 8-digit form can be used to specify UTF-16 surrogate pairs to compose characters with code points larger than U+FFFF, although the availability of the 8-digit form technically makes this unnecessary. (When surrogate pairs are used when the server encoding is &lt;code&gt;UTF8&lt;/code&gt;, they are first combined into a single code point that is then encoded in UTF-8.)</source>
          <target state="translated">Unicodeエスケープ構文は、サーバーのエンコーディングが &lt;code&gt;UTF8&lt;/code&gt; の場合にのみ完全に機能します。他のサーバーエンコーディングが使用されている場合、ASCII範囲（最大 &lt;code&gt;\u007F&lt;/code&gt; ）のコードポイントのみを指定できます。 4桁と8桁の両方の形式を使用して、UTF-16サロゲートペアを指定し、U + FFFFより大きいコードポイントを持つ文字を構成できます。ただし、8桁の形式を使用できるため、技術的にこれは不要です。 （サーバーのエンコードが &lt;code&gt;UTF8&lt;/code&gt; のときにサロゲートペアが使用される場合、それらは最初に単一のコードポイントに結合され、次にUTF-8でエンコードされます。）</target>
        </trans-unit>
        <trans-unit id="9d177c404952bede8f8a850e0e6bf27fc770e815" translate="yes" xml:space="preserve">
          <source>The Unicode escape syntax works only when the server encoding is &lt;code&gt;UTF8&lt;/code&gt;. When other server encodings are used, only code points in the ASCII range (up to &lt;code&gt;\007F&lt;/code&gt;) can be specified. Both the 4-digit and the 6-digit form can be used to specify UTF-16 surrogate pairs to compose characters with code points larger than U+FFFF, although the availability of the 6-digit form technically makes this unnecessary. (Surrogate pairs are not stored directly, but combined into a single code point that is then encoded in UTF-8.)</source>
          <target state="translated">Unicodeエスケープ構文は、サーバーのエンコーディングが &lt;code&gt;UTF8&lt;/code&gt; の場合にのみ機能します。他のサーバーエンコーディングが使用されている場合、ASCII範囲（ &lt;code&gt;\007F&lt;/code&gt; ）のコードポイントのみを指定できます。 4桁と6桁の両方の形式を使用して、UTF-16サロゲートペアを指定し、U + FFFFより大きいコードポイントを持つ文字を構成できますが、6桁の形式を使用できるため、技術的にこれは不要です。 （サロゲートペアは直接格納されませんが、単一のコードポイントに結合され、UTF-8でエンコードされます。）</target>
        </trans-unit>
        <trans-unit id="7a66f8e165736e1d6137c7cb68f9f8d177bec3f5" translate="yes" xml:space="preserve">
          <source>The Unicode escape syntax works only when the server encoding is &lt;code&gt;UTF8&lt;/code&gt;. When other server encodings are used, only code points in the ASCII range (up to &lt;code&gt;\007F&lt;/code&gt;) can be specified. Both the 4-digit and the 6-digit form can be used to specify UTF-16 surrogate pairs to compose characters with code points larger than U+FFFF, although the availability of the 6-digit form technically makes this unnecessary. (When surrogate pairs are used when the server encoding is &lt;code&gt;UTF8&lt;/code&gt;, they are first combined into a single code point that is then encoded in UTF-8.)</source>
          <target state="translated">Unicodeエスケープ構文は、サーバーのエンコーディングが &lt;code&gt;UTF8&lt;/code&gt; の場合にのみ機能します。他のサーバーエンコーディングが使用されている場合、ASCII範囲（ &lt;code&gt;\007F&lt;/code&gt; ）のコードポイントのみを指定できます。4桁と6桁の両方の形式を使用して、UTF-16サロゲートペアを指定し、U + FFFFより大きいコードポイントを持つ文字を構成できますが、6桁の形式を使用できるため、技術的にこれは不要です。（サーバーのエンコードが &lt;code&gt;UTF8&lt;/code&gt; のときにサロゲートペアが使用される場合、それらは最初に単一のコードポイントに結合され、次にUTF-8でエンコードされます。）</target>
        </trans-unit>
        <trans-unit id="f25ec485689944e9d0206ff9e943ed99a4c57c18" translate="yes" xml:space="preserve">
          <source>The WAL sender process is currently estimating the total amount of database files that will be streamed as a base backup.</source>
          <target state="translated">WAL送信者プロセスは現在、ベースバックアップとしてストリーミングされるデータベースファイルの総量を見積もっています。</target>
        </trans-unit>
        <trans-unit id="fad15d4e7352ffeba617fa81631fe16434d0ac21" translate="yes" xml:space="preserve">
          <source>The WAL sender process is currently performing &lt;code&gt;pg_start_backup&lt;/code&gt; to prepare to take a base backup, and waiting for the start-of-backup checkpoint to finish.</source>
          <target state="translated">WAL送信側プロセスは、現在 &lt;code&gt;pg_start_backup&lt;/code&gt; を実行して基本バックアップを作成する準備をしており、バックアップの開始チェックポイントが終了するのを待っています。</target>
        </trans-unit>
        <trans-unit id="f7b81498551e6dcef3f85194b60965948e30f611" translate="yes" xml:space="preserve">
          <source>The WAL sender process is currently performing &lt;code&gt;pg_stop_backup&lt;/code&gt; to finish the backup, and waiting for all the WAL files required for the base backup to be successfully archived. If either &lt;code&gt;--wal-method=none&lt;/code&gt; or &lt;code&gt;--wal-method=stream&lt;/code&gt; is specified in pg_basebackup, the backup will end when this phase is completed.</source>
          <target state="translated">WAL送信者プロセスは現在 &lt;code&gt;pg_stop_backup&lt;/code&gt; を実行してバックアップを終了し、基本バックアップに必要なすべてのWALファイルが正常にアーカイブされるのを待っています。いずれかの場合 &lt;code&gt;--wal-method=none&lt;/code&gt; または &lt;code&gt;--wal-method=stream&lt;/code&gt; pg_basebackupに指定されていないこの段階が完了すると、バックアップが終了します。</target>
        </trans-unit>
        <trans-unit id="742081e8987be9e068dabd67697e13799d4135be" translate="yes" xml:space="preserve">
          <source>The WAL sender process is currently streaming database files as a base backup.</source>
          <target state="translated">WAL送信者プロセスは現在、ベースバックアップとしてデータベースファイルをストリーミングしています。</target>
        </trans-unit>
        <trans-unit id="26f868b9098d5fef7b7fac16f33bf4c597bcd9b6" translate="yes" xml:space="preserve">
          <source>The WAL sender process is currently transferring all WAL logs generated during the backup. This phase occurs after &lt;code&gt;waiting for wal archiving to finish&lt;/code&gt; phase if &lt;code&gt;--wal-method=fetch&lt;/code&gt; is specified in pg_basebackup. The backup will end when this phase is completed.</source>
          <target state="translated">WAL送信者プロセスは現在、バックアップ中に生成されたすべてのWALログを転送しています。このフェーズは、 &lt;code&gt;--wal-method=fetch&lt;/code&gt; が指定されている場合 &lt;code&gt;waiting for wal archiving to finish&lt;/code&gt; フェーズを待機した後に発生します。このフェーズが完了すると、バックアップは終了します。</target>
        </trans-unit>
        <trans-unit id="614ca7f59107c1f62192373c03f83f3a6cdc3ee6" translate="yes" xml:space="preserve">
          <source>The WAL sender process is preparing to begin the backup. This phase is expected to be very brief.</source>
          <target state="translated">WAL送信者プロセスは、バックアップを開始する準備をしています。このフェーズは非常に短いと予想されます。</target>
        </trans-unit>
        <trans-unit id="9ece699458bd7501153fdfb1c5912141f3441417" translate="yes" xml:space="preserve">
          <source>The XPath-based functions support passing one parameter to serve as the XPath expression's context item, but do not support passing additional values to be available to the expression as named parameters.</source>
          <target state="translated">XPath ベースの関数は XPath 式のコンテキスト項目として機能するために 1 つのパラメータを渡すことをサポートしていますが、名前付きパラメータとして式に利用可能な追加の値を渡すことはサポートしていません。</target>
        </trans-unit>
        <trans-unit id="68d2d71e2fc0b0be97c31a2b21762a50375e3cf0" translate="yes" xml:space="preserve">
          <source>The ability of pg_dump and psql to write to or read from pipes makes it possible to dump a database directly from one server to another, for example:</source>
          <target state="translated">pg_dumpとpsqlがパイプへの書き込みやパイプからの読み込みを行う機能により、例えばあるサーバから別のサーバへ直接データベースをダンプすることが可能になります。</target>
        </trans-unit>
        <trans-unit id="fa4fd86ff72f122e1d8e3fdfa6f01d6588a00c68" translate="yes" xml:space="preserve">
          <source>The ability to create a composite type with zero attributes is a PostgreSQL-specific deviation from the standard (analogous to the same case in &lt;code&gt;CREATE TABLE&lt;/code&gt;).</source>
          <target state="translated">属性がゼロの複合型を作成する機能は、標準からのPostgreSQL固有の偏差です（ &lt;code&gt;CREATE TABLE&lt;/code&gt; の同じケースに類似しています）。</target>
        </trans-unit>
        <trans-unit id="adfc2f9948045f7d285be1359a7594bd62946d41" translate="yes" xml:space="preserve">
          <source>The ability to create like-named objects in different schemas complicates writing a query that references precisely the same objects every time. It also opens up the potential for users to change the behavior of other users' queries, maliciously or accidentally. Due to the prevalence of unqualified names in queries and their use in PostgreSQL internals, adding a schema to &lt;code&gt;search_path&lt;/code&gt; effectively trusts all users having &lt;code&gt;CREATE&lt;/code&gt; privilege on that schema. When you run an ordinary query, a malicious user able to create objects in a schema of your search path can take control and execute arbitrary SQL functions as though you executed them.</source>
          <target state="translated">異なるスキーマで同じ名前のオブジェクトを作成する機能は、毎回まったく同じオブジェクトを参照するクエリの記述を複雑にします。また、ユーザーが他のユーザーのクエリの動作を故意または偶然に変更する可能性を広げます。クエリ内の非修飾名の普及とPostgreSQL内部でのそれらの使用のため、スキーマを &lt;code&gt;search_path&lt;/code&gt; に追加すると、そのスキーマに対する &lt;code&gt;CREATE&lt;/code&gt; 特権を持つすべてのユーザーが効果的に信頼されます。通常のクエリを実行すると、検索パスのスキーマにオブジェクトを作成できる悪意のあるユーザーが、任意のSQL関数を制御して実行する可能性があります。</target>
        </trans-unit>
        <trans-unit id="b4ae0fec1e129dc1403f8e4a1f54de4512e5b908" translate="yes" xml:space="preserve">
          <source>The ability to fire triggers for &lt;code&gt;TRUNCATE&lt;/code&gt; is a PostgreSQL extension of the SQL standard, as is the ability to define statement-level triggers on views.</source>
          <target state="translated">&lt;code&gt;TRUNCATE&lt;/code&gt; のトリガーを起動する機能は、SQL標準のPostgreSQLの拡張機能であり、ビューにステートメントレベルのトリガーを定義する機能も同様です。</target>
        </trans-unit>
        <trans-unit id="a5cde4cacd03ad144a2f1d01e84ddaf95711d39b" translate="yes" xml:space="preserve">
          <source>The ability to handle parts of executing a &lt;a href=&quot;glossary#GLOSSARY-QUERY&quot;&gt;query&lt;/a&gt; to take advantage of parallel processes on servers with multiple CPUs.</source>
          <target state="translated">複数のCPUを搭載したサーバーで並列プロセスを利用するために、&lt;a href=&quot;glossary#GLOSSARY-QUERY&quot;&gt;クエリ&lt;/a&gt;の実行の一部を処理する機能。</target>
        </trans-unit>
        <trans-unit id="b3edb8c451c19be6c183faaf56035a29e2c4b780" translate="yes" xml:space="preserve">
          <source>The ability to restore the database to a previous point in time creates some complexities that are akin to science-fiction stories about time travel and parallel universes. For example, in the original history of the database, suppose you dropped a critical table at 5:15PM on Tuesday evening, but didn't realize your mistake until Wednesday noon. Unfazed, you get out your backup, restore to the point-in-time 5:14PM Tuesday evening, and are up and running. In &lt;em&gt;this&lt;/em&gt; history of the database universe, you never dropped the table. But suppose you later realize this wasn't such a great idea, and would like to return to sometime Wednesday morning in the original history. You won't be able to if, while your database was up-and-running, it overwrote some of the WAL segment files that led up to the time you now wish you could get back to. Thus, to avoid this, you need to distinguish the series of WAL records generated after you've done a point-in-time recovery from those that were generated in the original database history.</source>
          <target state="translated">データベースを以前の時点に復元する機能は、タイムトラベルとパラレルユニバースに関するSFの話に似た複雑さを生み出します。たとえば、データベースの元の履歴で、火曜日の午後5時15分に重要なテーブルを削除したが、水曜日の正午まで間違いに気づかなかったとします。慌てずに、バックアップを取得し、火曜日の夕方の午後5時14分に復元して、稼働します。では&lt;em&gt;、この&lt;/em&gt;データベースユニバースの履歴では、テーブルを削除したことはありません。しかし、これがそれほど素晴らしいアイデアではなかったことに後で気づき、元の歴史の水曜日の朝のいつかに戻りたいとしましょう。データベースが稼働しているときに、元に戻すことができるようになるまでのWALセグメントファイルの一部が上書きされた場合は、これを行うことができません。したがって、これを回避するには、ポイントインタイムリカバリを実行した後に生成された一連のWALレコードを、元のデータベース履歴で生成されたものと区別する必要があります。</target>
        </trans-unit>
        <trans-unit id="e29767e86a52c901615b571a0d1b5b49dcfd5235" translate="yes" xml:space="preserve">
          <source>The ability to specify argument modes and names</source>
          <target state="translated">引数モードと名前を指定する機能</target>
        </trans-unit>
        <trans-unit id="f83cfa93265ba6bdf2c4af4154ac85132df7584f" translate="yes" xml:space="preserve">
          <source>The ability to specify both &lt;code&gt;DISTINCT&lt;/code&gt; and &lt;code&gt;ORDER BY&lt;/code&gt; in an aggregate function is a PostgreSQL extension.</source>
          <target state="translated">集約関数で &lt;code&gt;DISTINCT&lt;/code&gt; と &lt;code&gt;ORDER BY&lt;/code&gt; の両方を指定する機能は、PostgreSQLの拡張機能です。</target>
        </trans-unit>
        <trans-unit id="36892c35402a71971c62f926cf33611f0095f448" translate="yes" xml:space="preserve">
          <source>The ability to specify multiple actions for a single trigger using &lt;code&gt;OR&lt;/code&gt; is a PostgreSQL extension of the SQL standard.</source>
          <target state="translated">&lt;code&gt;OR&lt;/code&gt; を使用して単一のトリガーに複数のアクションを指定する機能は、SQL標準のPostgreSQLの拡張機能です。</target>
        </trans-unit>
        <trans-unit id="12f8b21071990877da6aa1b7a33a6ab04258d42b" translate="yes" xml:space="preserve">
          <source>The ability to temporarily enable or disable a trigger is provided by &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt;, not by &lt;code&gt;ALTER TRIGGER&lt;/code&gt;, because &lt;code&gt;ALTER TRIGGER&lt;/code&gt; has no convenient way to express the option of enabling or disabling all of a table's triggers at once.</source>
          <target state="translated">一時的に有効またはトリガーを無効にする機能は、によって提供され&lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt;ないことで、 &lt;code&gt;ALTER TRIGGER&lt;/code&gt; ので、 &lt;code&gt;ALTER TRIGGER&lt;/code&gt; が有効か、一度にテーブルのトリガのすべてを無効にするオプションを表現する便利な方法を持っていません。</target>
        </trans-unit>
        <trans-unit id="181b9f5d513d598d56342cbdee6549b14a30572c" translate="yes" xml:space="preserve">
          <source>The ability to use indexes with &lt;code&gt;LIKE&lt;/code&gt; clauses</source>
          <target state="translated">&lt;code&gt;LIKE&lt;/code&gt; 句でインデックスを使用する機能</target>
        </trans-unit>
        <trans-unit id="cf1bad54aa29381ffc99e0cd6534801214045eea" translate="yes" xml:space="preserve">
          <source>The above are all simple text search examples. As mentioned before, full text search functionality includes the ability to do many more things: skip indexing certain words (stop words), process synonyms, and use sophisticated parsing, e.g., parse based on more than just white space. This functionality is controlled by &lt;em&gt;text search configurations&lt;/em&gt;. PostgreSQL comes with predefined configurations for many languages, and you can easily create your own configurations. (psql's &lt;code&gt;\dF&lt;/code&gt; command shows all available configurations.)</source>
          <target state="translated">上記はすべて単純なテキスト検索の例です。前述のように、全文検索機能には、特定の単語（ストップワード）のインデックス作成をスキップし、類義語を処理し、洗練された解析を使用する機能（たとえば、空白以外のものに基づく解析）が含まれます。この機能は、&lt;em&gt;テキスト検索構成&lt;/em&gt;によって制御され&lt;em&gt;ます&lt;/em&gt;。PostgreSQLには多くの言語用に事前定義された構成が付属しており、独自の構成を簡単に作成できます。（psqlの &lt;code&gt;\dF&lt;/code&gt; コマンドは、使用可能なすべての構成を表示します。）</target>
        </trans-unit>
        <trans-unit id="2c3e1167e52b923579b2a7fc4d461580b2f1f1dc" translate="yes" xml:space="preserve">
          <source>The above operations should be performed by an administrative user.</source>
          <target state="translated">上記の操作は管理者が行ってください。</target>
        </trans-unit>
        <trans-unit id="d0d28ebaf3e9bc7217eabce77d41a45e775db518" translate="yes" xml:space="preserve">
          <source>The above query only shows the rows from the inner query having &lt;code&gt;rank&lt;/code&gt; less than 3.</source>
          <target state="translated">上記のクエリでは、 &lt;code&gt;rank&lt;/code&gt; が3未満の内部クエリの行のみが表示されます。</target>
        </trans-unit>
        <trans-unit id="5129e9bc20e65e89b0d436aa6187d7cf918d1aeb" translate="yes" xml:space="preserve">
          <source>The above query using &lt;code&gt;int_array_enum&lt;/code&gt; produces the same results as</source>
          <target state="translated">上記の &lt;code&gt;int_array_enum&lt;/code&gt; を使用したクエリは、</target>
        </trans-unit>
        <trans-unit id="8107fdc88da76184415ef69e2ecad722706ac13d" translate="yes" xml:space="preserve">
          <source>The above rules associate greediness attributes not only with individual quantified atoms, but with branches and entire REs that contain quantified atoms. What that means is that the matching is done in such a way that the branch, or whole RE, matches the longest or shortest possible substring &lt;em&gt;as a whole&lt;/em&gt;. Once the length of the entire match is determined, the part of it that matches any particular subexpression is determined on the basis of the greediness attribute of that subexpression, with subexpressions starting earlier in the RE taking priority over ones starting later.</source>
          <target state="translated">上記のルールは、貪欲属性を個々の定量化された原子だけでなく、定量化された原子を含むブランチおよびRE全体にも関連付けます。どのような手段は、マッチングが支店、または全体のREは、最長または最短の部分文字列と一致するような方法で行われていることである&lt;em&gt;全体としての&lt;/em&gt;。一致全体の長さが決定されると、特定の部分式に一致する部分がその部分式の貪欲属性に基づいて決定され、部分式はREの前に開始され、後から開始される部分より優先されます。</target>
        </trans-unit>
        <trans-unit id="fe4e00a739ad370965c561bc4d7c298f0756e50c" translate="yes" xml:space="preserve">
          <source>The above skeleton is suitable for the case where no decompression is needed. (But, of course, omitting the method altogether is even easier, and is recommended in such cases.)</source>
          <target state="translated">上記のスケルトンは、減圧を必要としない場合に適しています。(もちろん、完全に省略した方がより簡単であり、そのような場合にはお勧めです)。</target>
        </trans-unit>
        <trans-unit id="6987a09f0b14c398190d54898784ad9944a48328" translate="yes" xml:space="preserve">
          <source>The above syntax has the drawback that you need to know the order of the columns in the table. To avoid this you can also list the columns explicitly. For example, both of the following commands have the same effect as the one above:</source>
          <target state="translated">上記の構文では、テーブル内のカラムの順序を知る必要があるという欠点があります。これを避けるために、列を明示的にリストアップすることもできます。例えば、以下のコマンドはどちらも上のコマンドと同じ効果があります。</target>
        </trans-unit>
        <trans-unit id="d92b695ce2e1fc99e7debc111a49b6a3b4275271" translate="yes" xml:space="preserve">
          <source>The above transaction will insert both 3 and 4.</source>
          <target state="translated">上記の取引では、3と4の両方を挿入します。</target>
        </trans-unit>
        <trans-unit id="d3ded6bad4b3e8cb90f32aef7f2e2ce8e740539c" translate="yes" xml:space="preserve">
          <source>The above transaction will insert the values 1 and 3, but not 2.</source>
          <target state="translated">上記のトランザクションでは、値1と値3が挿入されますが、値2は挿入されません。</target>
        </trans-unit>
        <trans-unit id="dec9b433ac3e4e8910b0ae4310ac815b98eb482c" translate="yes" xml:space="preserve">
          <source>The above will start the replication process, which synchronizes the initial table contents of the tables &lt;code&gt;users&lt;/code&gt; and &lt;code&gt;departments&lt;/code&gt; and then starts replicating incremental changes to those tables.</source>
          <target state="translated">上記はレプリケーションプロセスを開始し、 &lt;code&gt;users&lt;/code&gt; と &lt;code&gt;departments&lt;/code&gt; のテーブルの初期テーブルコンテンツを同期してから、それらのテーブルへの増分変更のレプリケーションを開始します。</target>
        </trans-unit>
        <trans-unit id="4792ca68861299622c8a8489cae6e3ff6fc1e734" translate="yes" xml:space="preserve">
          <source>The access costs should include all disk and CPU costs associated with scanning the index itself, but &lt;em&gt;not&lt;/em&gt; the costs of retrieving or processing the parent-table rows that are identified by the index.</source>
          <target state="translated">アクセスコストには、インデックス自体のスキャンに関連するすべてのディスクとCPUのコストが含まれますが、インデックスによって識別される親テーブルの行の取得または処理のコストは含まれ&lt;em&gt;ません&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="07883ad5be74942310a3c715c9a683e447816066" translate="yes" xml:space="preserve">
          <source>The access method can report that the index is &lt;em&gt;lossy&lt;/em&gt;, or requires rechecks, for a particular query. This implies that the index scan will return all the entries that pass the scan key, plus possibly additional entries that do not. The core system's index-scan machinery will then apply the index conditions again to the heap tuple to verify whether or not it really should be selected. If the recheck option is not specified, the index scan must return exactly the set of matching entries.</source>
          <target state="translated">アクセス方法は、特定のクエリに対してインデックスに&lt;em&gt;損失&lt;/em&gt;が&lt;em&gt;ある&lt;/em&gt;、または再チェックが必要であることを報告できます。これは、インデックススキャンがスキャンキーを渡すすべてのエントリに加えて、そうでない追加のエントリを返す可能性があることを意味します。コアシステムのインデックススキャン機構は、インデックス条件をヒープタプルに再度適用して、本当に選択する必要があるかどうかを確認します。再チェックオプションが指定されていない場合、インデックススキャンは、一致するエントリのセットを正確に返す必要があります。</target>
        </trans-unit>
        <trans-unit id="7463ace40ac0727457d3fd85331890fec1e03b44" translate="yes" xml:space="preserve">
          <source>The access method must identify any rows which might violate the unique constraint, but it is not an error for it to report false positives. This allows the check to be done without waiting for other transactions to finish; conflicts reported here are not treated as errors and will be rechecked later, by which time they may no longer be conflicts.</source>
          <target state="translated">アクセス・メソッドは一意性制約に違反する可能性のある行を識別しなければなりませんが、偽陽性を報告することはエラーではありません。これにより、他のトランザクションが終了するのを待たずにチェックを行うことができます。ここで報告された競合はエラーとしては扱われず、後で再チェックされます。</target>
        </trans-unit>
        <trans-unit id="3b57f7233950ac2f66da1f759e801ef6dd2f3764" translate="yes" xml:space="preserve">
          <source>The access method must support &lt;code&gt;amgettuple&lt;/code&gt; (see &lt;a href=&quot;https://www.postgresql.org/docs/12/indexam.html&quot;&gt;Chapter 61&lt;/a&gt;); at present this means GIN cannot be used. Although it's allowed, there is little point in using B-tree or hash indexes with an exclusion constraint, because this does nothing that an ordinary unique constraint doesn't do better. So in practice the access method will always be GiST or SP-GiST.</source>
          <target state="translated">アクセス方法は &lt;code&gt;amgettuple&lt;/code&gt; をサポートする必要があります（&lt;a href=&quot;https://www.postgresql.org/docs/12/indexam.html&quot;&gt;第61章を&lt;/a&gt;参照）。現在、これはGINを使用できないことを意味します。これは許可されていますが、除外制約でBツリーまたはハッシュインデックスを使用してもほとんど意味がありません。これは、通常の一意の制約では改善されないためです。したがって、実際には、アクセス方法は常にGiSTまたはSP-GiSTになります。</target>
        </trans-unit>
        <trans-unit id="f11bb13c1be4b89a9073f3965e1e4a21ea97d02b" translate="yes" xml:space="preserve">
          <source>The access method must support &lt;code&gt;amgettuple&lt;/code&gt; (see &lt;a href=&quot;https://www.postgresql.org/docs/13/indexam.html&quot;&gt;Chapter 61&lt;/a&gt;); at present this means GIN cannot be used. Although it's allowed, there is little point in using B-tree or hash indexes with an exclusion constraint, because this does nothing that an ordinary unique constraint doesn't do better. So in practice the access method will always be GiST or SP-GiST.</source>
          <target state="translated">アクセス方法は &lt;code&gt;amgettuple&lt;/code&gt; をサポートする必要があります（&lt;a href=&quot;https://www.postgresql.org/docs/13/indexam.html&quot;&gt;第61章を&lt;/a&gt;参照）。現在、これはGINを使用できないことを意味します。許可されていますが、除外制約を指定してBツリーまたはハッシュインデックスを使用する意味はほとんどありません。これは、通常の一意性制約がうまく機能しないことを意味するものではないためです。したがって、実際には、アクセス方法は常にGiSTまたはSP-GiSTになります。</target>
        </trans-unit>
        <trans-unit id="925d234c42527636b378041891a37fa8bc13f69a" translate="yes" xml:space="preserve">
          <source>The access method name must be unique within the database.</source>
          <target state="translated">アクセスメソッド名はデータベース内で一意でなければなりません。</target>
        </trans-unit>
        <trans-unit id="269e5a0688390217e0c08f2b5f501b6e542e7ab1" translate="yes" xml:space="preserve">
          <source>The accumulated cost that will cause the vacuuming process to sleep. The default value is 200.</source>
          <target state="translated">バキューム処理をスリープ状態にする累積コスト。デフォルト値は200です。</target>
        </trans-unit>
        <trans-unit id="1dfce3d6c647c6b7a46c7536dcf8246e840a748e" translate="yes" xml:space="preserve">
          <source>The accumulating calendar error prompted Pope Gregory XIII to reform the calendar in accordance with instructions from the Council of Trent. In the Gregorian calendar, the tropical year is approximated as 365 + 97 / 400 days = 365.2425 days. Thus it takes approximately 3300 years for the tropical year to shift one day with respect to the Gregorian calendar.</source>
          <target state="translated">暦の誤りの蓄積は、教皇グレゴリオ13世に促され、トレント公会議の指示に基づいて暦を改正しました。グレゴリオ暦では、熱帯年は365+97/400日=365.2425日と近似しています。したがって、グレゴリオ暦では熱帯年が1日ずれるのに約3300年かかることになります。</target>
        </trans-unit>
        <trans-unit id="e8af8f1a0118bcdb3de7cccd47ade7dfba7146dc" translate="yes" xml:space="preserve">
          <source>The act of finalizing a &lt;a href=&quot;glossary#GLOSSARY-TRANSACTION&quot;&gt;transaction&lt;/a&gt; within the &lt;a href=&quot;glossary#GLOSSARY-DATABASE&quot;&gt;database&lt;/a&gt;, which makes it visible to other transactions and assures its &lt;a href=&quot;glossary#GLOSSARY-DURABILITY&quot;&gt;durability&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;glossary#GLOSSARY-DATABASE&quot;&gt;データベース&lt;/a&gt;内で&lt;a href=&quot;glossary#GLOSSARY-TRANSACTION&quot;&gt;トランザクション&lt;/a&gt;をファイナライズする行為。これにより、他のトランザクションからトランザクションが見えるようになり、その&lt;a href=&quot;glossary#GLOSSARY-DURABILITY&quot;&gt;耐久性が&lt;/a&gt;保証されます。</target>
        </trans-unit>
        <trans-unit id="db888abdcc969733f24ba8448a46853590f7acc2" translate="yes" xml:space="preserve">
          <source>The act of reproducing data on one &lt;a href=&quot;glossary#GLOSSARY-SERVER&quot;&gt;server&lt;/a&gt; onto another server called a &lt;a href=&quot;glossary#GLOSSARY-REPLICA&quot;&gt;replica&lt;/a&gt;. This can take the form of &lt;em&gt;physical replication&lt;/em&gt;, where all file changes from one server are copied verbatim, or &lt;em&gt;logical replication&lt;/em&gt; where a defined subset of data changes are conveyed using a higher-level representation.</source>
          <target state="translated">ある&lt;a href=&quot;glossary#GLOSSARY-SERVER&quot;&gt;サーバー&lt;/a&gt;上のデータを&lt;a href=&quot;glossary#GLOSSARY-REPLICA&quot;&gt;レプリカ&lt;/a&gt;と呼ばれる別のサーバーに複製する行為。これは、1つのサーバーからのすべてのファイル変更が逐語的にコピーされる&lt;em&gt;物理レプリケーション&lt;/em&gt;、またはデータ変更の定義されたサブセットがより高いレベルの表現を使用して伝達される&lt;em&gt;論理レプリケーション&lt;/em&gt;の形式をとることができます。</target>
        </trans-unit>
        <trans-unit id="6e5a51f4541a92f0a7b8eafcdaec433dbe4bd0a9" translate="yes" xml:space="preserve">
          <source>The actions for identity columns (&lt;code&gt;ADD GENERATED&lt;/code&gt;, &lt;code&gt;SET&lt;/code&gt; etc., &lt;code&gt;DROP IDENTITY&lt;/code&gt;), as well as the actions &lt;code&gt;TRIGGER&lt;/code&gt;, &lt;code&gt;CLUSTER&lt;/code&gt;, &lt;code&gt;OWNER&lt;/code&gt;, and &lt;code&gt;TABLESPACE&lt;/code&gt; never recurse to descendant tables; that is, they always act as though &lt;code&gt;ONLY&lt;/code&gt; were specified. Adding a constraint recurses only for &lt;code&gt;CHECK&lt;/code&gt; constraints that are not marked &lt;code&gt;NO INHERIT&lt;/code&gt;.</source>
          <target state="translated">ID列のアクション（ &lt;code&gt;ADD GENERATED&lt;/code&gt; 、 &lt;code&gt;SET&lt;/code&gt; など、 &lt;code&gt;DROP IDENTITY&lt;/code&gt; ）、およびアクション &lt;code&gt;TRIGGER&lt;/code&gt; 、 &lt;code&gt;CLUSTER&lt;/code&gt; 、 &lt;code&gt;OWNER&lt;/code&gt; 、および &lt;code&gt;TABLESPACE&lt;/code&gt; は、子孫テーブルに再帰することはありません。つまり、それらは常に指定されたものとして &lt;code&gt;ONLY&lt;/code&gt; 機能します。制約の追加は、 &lt;code&gt;NO INHERIT&lt;/code&gt; とマークされていない &lt;code&gt;CHECK&lt;/code&gt; 制約に対してのみ再帰します。</target>
        </trans-unit>
        <trans-unit id="909f7edd282ab8c888fdf2ed34039a5329b6ad7a" translate="yes" xml:space="preserve">
          <source>The actual choice here is mostly a matter of taste, constrained only by possible restrictions in client applications. Both methods support all possible values, although the hex encoding will be somewhat larger than the base64 encoding.</source>
          <target state="translated">ここでの実際の選択はほとんどが好みの問題であり、クライアントアプリケーションでの可能性のある制限によってのみ制約されます。どちらの方法もすべての可能な値をサポートしていますが、16進数のエンコーディングはbase64のエンコーディングよりも多少大きくなります。</target>
        </trans-unit>
        <trans-unit id="42c8786b869e4cc819db8d6cf4749d981fd3444f" translate="yes" xml:space="preserve">
          <source>The actual colors to be used are configured using the environment variable &lt;code&gt;PG_COLORS&lt;/code&gt; (note plural). The value is a colon-separated list of &lt;code&gt;key=value&lt;/code&gt; pairs. The keys specify what the color is to be used for. The values are SGR (Select Graphic Rendition) specifications, which are interpreted by the terminal.</source>
          <target state="translated">使用される実際の色は、環境変数 &lt;code&gt;PG_COLORS&lt;/code&gt; （複数形に注意）を使用して構成されます。値は、 &lt;code&gt;key=value&lt;/code&gt; のペアのコロンで区切られたリストです。キーは、使用する色を指定します。値はSGR（Select Graphic Rendition）仕様であり、端末によって解釈されます。</target>
        </trans-unit>
        <trans-unit id="486a25c1f79db6232bfe3c602e8f3539de88dd46" translate="yes" xml:space="preserve">
          <source>The actual data types of the various &lt;code&gt;Datum&lt;/code&gt; values mentioned above vary depending on the operator class. The item values passed to &lt;code&gt;extractValue&lt;/code&gt; are always of the operator class's input type, and all key values must be of the class's &lt;code&gt;STORAGE&lt;/code&gt; type. The type of the &lt;code&gt;query&lt;/code&gt; argument passed to &lt;code&gt;extractQuery&lt;/code&gt;, &lt;code&gt;consistent&lt;/code&gt; and &lt;code&gt;triConsistent&lt;/code&gt; is whatever is the right-hand input type of the class member operator identified by the strategy number. This need not be the same as the indexed type, so long as key values of the correct type can be extracted from it. However, it is recommended that the SQL declarations of these three support functions use the opclass's indexed data type for the &lt;code&gt;query&lt;/code&gt; argument, even though the actual type might be something else depending on the operator.</source>
          <target state="translated">上記のさまざまな &lt;code&gt;Datum&lt;/code&gt; 値の実際のデータ型は、演算子クラスによって異なります。 &lt;code&gt;extractValue&lt;/code&gt; に渡されるアイテム値は常に演算子クラスの入力タイプであり、すべてのキー値はクラスの &lt;code&gt;STORAGE&lt;/code&gt; タイプである必要があります。 &lt;code&gt;extractQuery&lt;/code&gt; に渡される &lt;code&gt;query&lt;/code&gt; 引数のタイプ、 &lt;code&gt;consistent&lt;/code&gt; および &lt;code&gt;triConsistent&lt;/code&gt; 戦略番号で識別されるクラスメンバー演算子の右側の入力タイプは何でもかまいません。これは、正しいタイプのキー値を抽出できる限り、インデックス付きのタイプと同じである必要はありません。ただし、これら3つのサポート関数のSQL宣言では、演算子によっては実際の型が別の型である場合でも、 &lt;code&gt;query&lt;/code&gt; 引数にopclassのインデックス付きデータ型を使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="941436b14f077228160b589974e7f72ed527cb34" translate="yes" xml:space="preserve">
          <source>The actual items themselves.</source>
          <target state="translated">実物そのもの。</target>
        </trans-unit>
        <trans-unit id="fffe8ba3b231865545aa8ca6fdb204ce35d44eac" translate="yes" xml:space="preserve">
          <source>The actual number of rows this query would select is 7000, but the &lt;code&gt;rows&lt;/code&gt; estimate is only approximate. If you try to duplicate this experiment, you will probably get a slightly different estimate; moreover, it can change after each &lt;code&gt;ANALYZE&lt;/code&gt; command, because the statistics produced by &lt;code&gt;ANALYZE&lt;/code&gt; are taken from a randomized sample of the table.</source>
          <target state="translated">このクエリが選択する実際の行数は7000ですが、推定 &lt;code&gt;rows&lt;/code&gt; 数は概算です。この実験を複製しようとすると、おそらく少し異なる見積もりが得られます。また、それぞれの後に変更することができ &lt;code&gt;ANALYZE&lt;/code&gt; によって生成された統計があるため、コマンド &lt;code&gt;ANALYZE&lt;/code&gt; テーブルの無作為サンプルから取られます。</target>
        </trans-unit>
        <trans-unit id="6d27af95eda9a00aefcefbbb3f7c08b95ed3e6d3" translate="yes" xml:space="preserve">
          <source>The actual output rows are computed using the &lt;code&gt;SELECT&lt;/code&gt; output expressions for each selected row or row group. (See &lt;a href=&quot;sql-select#SQL-SELECT-LIST&quot;&gt;&lt;code&gt;SELECT&lt;/code&gt; List&lt;/a&gt; below.)</source>
          <target state="translated">実際の出力行は、 &lt;code&gt;SELECT&lt;/code&gt; された行または行グループごとにSELECT出力式を使用して計算されます。（以下の&lt;a href=&quot;sql-select#SQL-SELECT-LIST&quot;&gt; &lt;code&gt;SELECT&lt;/code&gt; リストを&lt;/a&gt;参照してください。）</target>
        </trans-unit>
        <trans-unit id="748767c5001b9a6c88bed2030a93343c4f97acfc" translate="yes" xml:space="preserve">
          <source>The actual output rows are computed using the &lt;code&gt;SELECT&lt;/code&gt; output expressions for each selected row or row group. (See &lt;a href=&quot;sql-select#SQL-SELECT-LIST&quot;&gt;SELECT List&lt;/a&gt; below.)</source>
          <target state="translated">実際の出力行は、選択した各行または行グループの &lt;code&gt;SELECT&lt;/code&gt; 出力式を使用して計算されます。（以下の&lt;a href=&quot;sql-select#SQL-SELECT-LIST&quot;&gt;SELECTリストを&lt;/a&gt;参照してください。）</target>
        </trans-unit>
        <trans-unit id="747c207c89333b66eb66b4cfc2d12a9cf95c6535" translate="yes" xml:space="preserve">
          <source>The actual value of a parameter to the prepared statement. This must be an expression yielding a value that is compatible with the data type of this parameter, as was determined when the prepared statement was created.</source>
          <target state="translated">準備された文のパラメータの実際の値。これは、準備されたステートメントが作成されたときに決定されたように、このパラメータのデータ型と互換性のある値を生成する式でなければなりません。</target>
        </trans-unit>
        <trans-unit id="ac7f1235d4be6ac9ddfc264172bcdc008188f6f4" translate="yes" xml:space="preserve">
          <source>The added condition &lt;code&gt;stringu1 = 'xxx'&lt;/code&gt; reduces the output row count estimate, but not the cost because we still have to visit the same set of rows. Notice that the &lt;code&gt;stringu1&lt;/code&gt; clause cannot be applied as an index condition, since this index is only on the &lt;code&gt;unique1&lt;/code&gt; column. Instead it is applied as a filter on the rows retrieved by the index. Thus the cost has actually gone up slightly to reflect this extra checking.</source>
          <target state="translated">追加された条件 &lt;code&gt;stringu1 = 'xxx'&lt;/code&gt; は、出力行数の見積もりを削減しますが、同じ行のセットにアクセスする必要があるため、コストは削減されません。 &lt;code&gt;stringu1&lt;/code&gt; 句はインデックス条件として適用できないことに注意してください。これは、このインデックスが &lt;code&gt;unique1&lt;/code&gt; 列にのみ存在するためです。代わりに、インデックスによって取得された行のフィルターとして適用されます。したがって、この追加のチェックを反映するために、実際にはコストがわずかに上昇しています。</target>
        </trans-unit>
        <trans-unit id="0d6d3b7f07c64185ea468d2b62ff4270f9a83a5e" translate="yes" xml:space="preserve">
          <source>The additional &lt;em&gt;&lt;code&gt;heapallindexed&lt;/code&gt;&lt;/em&gt; phase adds significant overhead: verification will typically take several times longer. However, there is no change to the relation-level locks acquired when &lt;em&gt;&lt;code&gt;heapallindexed&lt;/code&gt;&lt;/em&gt; verification is performed.</source>
          <target state="translated">追加&lt;em&gt; &lt;code&gt;heapallindexed&lt;/code&gt; &lt;/em&gt;相は、かなりのオーバーヘッドが追加されます。検証は、一般的に長く、数回かかります。ただし、&lt;em&gt; &lt;code&gt;heapallindexed&lt;/code&gt; &lt;/em&gt;検証の実行時に取得される関係レベルのロックに変更はありません。</target>
        </trans-unit>
        <trans-unit id="9c1fb74bfe43620aa3ec5e950d1f4303783e6a3c" translate="yes" xml:space="preserve">
          <source>The address (&lt;code&gt;LSN&lt;/code&gt;) of oldest WAL which still might be required by the consumer of this slot and thus won't be automatically removed during checkpoints unless this LSN gets behind more than &lt;a href=&quot;runtime-config-replication#GUC-MAX-SLOT-WAL-KEEP-SIZE&quot;&gt;max_slot_wal_keep_size&lt;/a&gt; from the current LSN. &lt;code&gt;NULL&lt;/code&gt; if the &lt;code&gt;LSN&lt;/code&gt; of this slot has never been reserved.</source>
          <target state="translated">最も古いWALのアドレス（ &lt;code&gt;LSN&lt;/code&gt; ）。このスロットのコンシューマーが引き続き必要とする可能性があるため、このLSNが現在のLSNから&lt;a href=&quot;runtime-config-replication#GUC-MAX-SLOT-WAL-KEEP-SIZE&quot;&gt;max_slot_wal_keep_size&lt;/a&gt;を超えない限り、チェックポイント中に自動的に削除されません。このスロットの &lt;code&gt;LSN&lt;/code&gt; が予約されたことがない場合は &lt;code&gt;NULL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1ce4777382e2000ea7e60f8a7131343e38753550" translate="yes" xml:space="preserve">
          <source>The address (&lt;code&gt;LSN&lt;/code&gt;) of oldest WAL which still might be required by the consumer of this slot and thus won't be automatically removed during checkpoints. &lt;code&gt;NULL&lt;/code&gt; if the &lt;code&gt;LSN&lt;/code&gt; of this slot has never been reserved.</source>
          <target state="translated">最も古いWAL のアドレス（ &lt;code&gt;LSN&lt;/code&gt; ）。このスロットのコンシューマーがまだ必要とする可能性があるため、チェックポイント中に自動的に削除されません。このスロットの &lt;code&gt;LSN&lt;/code&gt; が予約されたことがない場合は &lt;code&gt;NULL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="034439fc21dbd36a2802df824278cae81f75f88d" translate="yes" xml:space="preserve">
          <source>The address (&lt;code&gt;LSN&lt;/code&gt;) up to which the logical slot's consumer has confirmed receiving data. Data older than this is not available anymore. &lt;code&gt;NULL&lt;/code&gt; for physical slots.</source>
          <target state="translated">論理スロットのコンシューマーがデータの受信を確認したアドレス（ &lt;code&gt;LSN&lt;/code&gt; ）。これより古いデータはもう利用できません。物理スロットの場合は &lt;code&gt;NULL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7a0ec05d31abc58e50953bffde428d1c139a9fa7" translate="yes" xml:space="preserve">
          <source>The aggregate functions &lt;code&gt;array_agg&lt;/code&gt;, &lt;code&gt;json_agg&lt;/code&gt;, &lt;code&gt;jsonb_agg&lt;/code&gt;, &lt;code&gt;json_object_agg&lt;/code&gt;, &lt;code&gt;jsonb_object_agg&lt;/code&gt;, &lt;code&gt;string_agg&lt;/code&gt;, and &lt;code&gt;xmlagg&lt;/code&gt;, as well as similar user-defined aggregate functions, produce meaningfully different result values depending on the order of the input values. This ordering is unspecified by default, but can be controlled by writing an &lt;code&gt;ORDER BY&lt;/code&gt; clause within the aggregate call, as shown in &lt;a href=&quot;sql-expressions#SYNTAX-AGGREGATES&quot;&gt;Section 4.2.7&lt;/a&gt;. Alternatively, supplying the input values from a sorted subquery will usually work. For example:</source>
          <target state="translated">集計関数 &lt;code&gt;array_agg&lt;/code&gt; 、 &lt;code&gt;json_agg&lt;/code&gt; 、 &lt;code&gt;jsonb_agg&lt;/code&gt; 、 &lt;code&gt;json_object_agg&lt;/code&gt; 、 &lt;code&gt;jsonb_object_agg&lt;/code&gt; 、 &lt;code&gt;string_agg&lt;/code&gt; 、および &lt;code&gt;xmlagg&lt;/code&gt; は、同様のユーザー定義集計関数と同様に、入力値の順序に応じて意味のある異なる結果値を生成します。この順序はデフォルトでは指定されていませんが、&lt;a href=&quot;sql-expressions#SYNTAX-AGGREGATES&quot;&gt;4.2.7項​​に&lt;/a&gt;示すように、集計呼び出し内で &lt;code&gt;ORDER BY&lt;/code&gt; 句を記述することで制御できます。あるいは、ソートされたサブクエリからの入力値の提供は通常は機能します。例えば：</target>
        </trans-unit>
        <trans-unit id="25a2a3e2d738bffa30059bdc53d46f7e3eca9a3f" translate="yes" xml:space="preserve">
          <source>The aggregator is an aggregate function &lt;code&gt;int_array_aggregate(integer)&lt;/code&gt; that produces an integer array containing exactly the integers it is fed. This is a wrapper around &lt;code&gt;array_agg&lt;/code&gt;, which does the same thing for any array type.</source>
          <target state="translated">アグリゲーターは、与えられた整数を正確に含む整数配列を生成する集約関数 &lt;code&gt;int_array_aggregate(integer)&lt;/code&gt; です。これは &lt;code&gt;array_agg&lt;/code&gt; のラッパーであり、どの配列タイプでも同じことを行います。</target>
        </trans-unit>
        <trans-unit id="424703d8d222e3285ae8821252bab5f244b1d269" translate="yes" xml:space="preserve">
          <source>The aim of WAL is to ensure that the log is written before database records are altered, but this can be subverted by disk drives that falsely report a successful write to the kernel, when in fact they have only cached the data and not yet stored it on the disk. A power failure in such a situation might lead to irrecoverable data corruption. Administrators should try to ensure that disks holding PostgreSQL's WAL log files do not make such false reports. (See &lt;a href=&quot;wal-reliability&quot;&gt;Section 29.1&lt;/a&gt;.)</source>
          <target state="translated">WALの目的は、データベースレコードが変更される前にログが確実に書き込まれるようにすることですが、実際にはデータをキャッシュし、まだ保存していない場合に、カーネルへの書き込みの成功を誤って報告するディスクドライブによってこれが破壊される可能性がありますディスク上。このような状況で電源障害が発生すると、回復不可能なデータ破損が発生する可能性があります。管理者は、PostgreSQLのWALログファイルを保持するディスクがそのような誤ったレポートを作成しないようにする必要があります。（&lt;a href=&quot;wal-reliability&quot;&gt;項29.1を&lt;/a&gt;参照してください。）</target>
        </trans-unit>
        <trans-unit id="f9e7ab5030dfc9ff217b5be87f2efd2576b52bbd" translate="yes" xml:space="preserve">
          <source>The algorithms in &lt;code&gt;crypt()&lt;/code&gt; differ from the usual MD5 or SHA1 hashing algorithms in the following respects:</source>
          <target state="translated">&lt;code&gt;crypt()&lt;/code&gt; のアルゴリズムは、通常のMD5またはSHA1ハッシュアルゴリズムと次の点で異なります。</target>
        </trans-unit>
        <trans-unit id="bb6ddacff228befd7481577e88b1910758787a46" translate="yes" xml:space="preserve">
          <source>The alias becomes the new name of the table reference so far as the current query is concerned &amp;mdash; it is not allowed to refer to the table by the original name elsewhere in the query. Thus, this is not valid:</source>
          <target state="translated">現在のクエリに関する限り、エイリアスはテーブル参照の新しい名前になります。クエリの他の場所で元の名前でテーブルを参照することはできません。したがって、これは無効です。</target>
        </trans-unit>
        <trans-unit id="5c707c122664d3415484ea0149341fcdfab44cfa" translate="yes" xml:space="preserve">
          <source>The allowed contents of a &lt;code&gt;RETURNING&lt;/code&gt; clause are the same as a &lt;code&gt;SELECT&lt;/code&gt; command's output list (see &lt;a href=&quot;queries-select-lists&quot;&gt;Section 7.3&lt;/a&gt;). It can contain column names of the command's target table, or value expressions using those columns. A common shorthand is &lt;code&gt;RETURNING *&lt;/code&gt;, which selects all columns of the target table in order.</source>
          <target state="translated">&lt;code&gt;RETURNING&lt;/code&gt; 句の許可される内容は、 &lt;code&gt;SELECT&lt;/code&gt; コマンドの出力リストと同じです（&lt;a href=&quot;queries-select-lists&quot;&gt;7.3節を&lt;/a&gt;参照）。コマンドのターゲットテーブルの列名、またはそれらの列を使用する値式を含めることができます。一般的な省略表現は &lt;code&gt;RETURNING *&lt;/code&gt; で、ターゲットテーブルのすべての列を順番に選択します。</target>
        </trans-unit>
        <trans-unit id="6fc27c228553cd704a3ef6963db1526d2404113f" translate="yes" xml:space="preserve">
          <source>The alternative archive file formats must be used with &lt;a href=&quot;app-pgrestore&quot;&gt;pg_restore&lt;/a&gt; to rebuild the database. They allow pg_restore to be selective about what is restored, or even to reorder the items prior to being restored. The archive file formats are designed to be portable across architectures.</source>
          <target state="translated">データベースを再構築するには、&lt;a href=&quot;app-pgrestore&quot;&gt;pg_restoreで&lt;/a&gt;代替アーカイブファイル形式を使用する必要があります。 pg_restoreは、復元するものを選択したり、復元する前にアイテムを並べ替えたりすることができます。アーカイブファイル形式は、アーキテクチャ間で移植できるように設計されています。</target>
        </trans-unit>
        <trans-unit id="30b730b12e2a6a8e73614c8aa5e3a5771cc3031c" translate="yes" xml:space="preserve">
          <source>The amount of information stored in &lt;code&gt;pg_statistic&lt;/code&gt; by &lt;code&gt;ANALYZE&lt;/code&gt;, in particular the maximum number of entries in the &lt;code&gt;most_common_vals&lt;/code&gt; and &lt;code&gt;histogram_bounds&lt;/code&gt; arrays for each column, can be set on a column-by-column basis using the &lt;code&gt;ALTER TABLE SET STATISTICS&lt;/code&gt; command, or globally by setting the &lt;a href=&quot;runtime-config-query#GUC-DEFAULT-STATISTICS-TARGET&quot;&gt;default_statistics_target&lt;/a&gt; configuration variable. The default limit is presently 100 entries. Raising the limit might allow more accurate planner estimates to be made, particularly for columns with irregular data distributions, at the price of consuming more space in &lt;code&gt;pg_statistic&lt;/code&gt; and slightly more time to compute the estimates. Conversely, a lower limit might be sufficient for columns with simple data distributions.</source>
          <target state="translated">&lt;code&gt;ANALYZE&lt;/code&gt; によって &lt;code&gt;pg_statistic&lt;/code&gt; に保存される情報の量、特に各列の &lt;code&gt;most_common_vals&lt;/code&gt; と &lt;code&gt;histogram_bounds&lt;/code&gt; 配列のエントリの最大数は、 &lt;code&gt;ALTER TABLE SET STATISTICS&lt;/code&gt; コマンドを使用して列ごとに、またはグローバルに設定することによって設定できます&lt;a href=&quot;runtime-config-query#GUC-DEFAULT-STATISTICS-TARGET&quot;&gt;default_statistics_target&lt;/a&gt;設定変数。デフォルトの制限は現在100エントリです。制限を上げると、 &lt;code&gt;pg_statistic&lt;/code&gt; でより多くのスペースを消費することを犠牲にして、特に不規則なデータ分布を持つ列に対して、より正確なプランナー推定が行われる可能性があります。見積もりを計算するのに少し時間がかかります。逆に、データ分布が単純な列の場合は、下限で十分な場合があります。</target>
        </trans-unit>
        <trans-unit id="0881173259f19f591f19be0dcc933c7ede671117" translate="yes" xml:space="preserve">
          <source>The amount of shared memory used for WAL data that has not yet been written to disk. The default setting of -1 selects a size equal to 1/32nd (about 3%) of &lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt;shared_buffers&lt;/a&gt;, but not less than &lt;code&gt;64kB&lt;/code&gt; nor more than the size of one WAL segment, typically &lt;code&gt;16MB&lt;/code&gt;. This value can be set manually if the automatic choice is too large or too small, but any positive value less than &lt;code&gt;32kB&lt;/code&gt; will be treated as &lt;code&gt;32kB&lt;/code&gt;. If this value is specified without units, it is taken as WAL blocks, that is &lt;code&gt;XLOG_BLCKSZ&lt;/code&gt; bytes, typically 8kB. This parameter can only be set at server start.</source>
          <target state="translated">ディスクにまだ書き込まれていないWALデータに使用される共有メモリの量。デフォルト設定の-1は、&lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt;shared_buffersの1/32&lt;/a&gt;（約3％）に等しいサイズを選択しますが、 &lt;code&gt;64kB&lt;/code&gt; 以上、1つのWALセグメントのサイズ（通常は &lt;code&gt;16MB&lt;/code&gt; )以下を選択します。自動選択が大きすぎるか小さすぎる場合、この値は手動で設定できますが、 &lt;code&gt;32kB&lt;/code&gt; 未満の正の値は32kBとして扱われ &lt;code&gt;32kB&lt;/code&gt; 。この値が単位なしで指定されている場合、WALブロック、つまり &lt;code&gt;XLOG_BLCKSZ&lt;/code&gt; バイト、通常は8kBと見なされます。このパラメータは、サーバーの起動時にのみ設定できます。</target>
        </trans-unit>
        <trans-unit id="fb3e8e0a1884bdfed25b92caf4ca9464cbb400f7" translate="yes" xml:space="preserve">
          <source>The amount of time that the process will sleep when the cost limit has been exceeded. If this value is specified without units, it is taken as milliseconds. The default value is zero, which disables the cost-based vacuum delay feature. Positive values enable cost-based vacuuming.</source>
          <target state="translated">コストの上限を超えたときにプロセスがスリープする時間。この値が単位なしで指定された場合、ミリ秒として扱われます。デフォルト値はゼロで、コストベースのバキューム遅延機能は無効になります。正の値を指定すると、コストベースのバキュームが有効になります。</target>
        </trans-unit>
        <trans-unit id="398a780c0d81cf69e4ef47e3ad5d58413fde5194" translate="yes" xml:space="preserve">
          <source>The amount of time to delay just after a new server process is forked, before it conducts the authentication procedure. This is intended to give developers an opportunity to attach to the server process with a debugger to trace down misbehavior in authentication. If this value is specified without units, it is taken as seconds. A value of zero (the default) disables the delay. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">新しいサーバープロセスが分岐された直後に、認証手順が実行されるまでの遅延時間。これは、開発者がデバッガを使用してサーバープロセスに接続し、認証の不正な動作を追跡できるようにすることを目的としています。この値が単位なしで指定された場合、秒として取得されます。値0（デフォルト）は遅延を無効にします。このパラメーターは、 &lt;code&gt;postgresql.conf&lt;/code&gt; ファイルまたはサーバーのコマンドラインでのみ設定できます。</target>
        </trans-unit>
        <trans-unit id="eaa9e04a9a492e3d82c3eee69d98abd9fe97d974" translate="yes" xml:space="preserve">
          <source>The amount of time to delay when a new server process is started, after it conducts the authentication procedure. This is intended to give developers an opportunity to attach to the server process with a debugger. If this value is specified without units, it is taken as seconds. A value of zero (the default) disables the delay. This parameter cannot be changed after session start.</source>
          <target state="translated">新しいサーバプロセスが起動したときに、認証手続きを行った後に遅延させる時間を指定します。これは、開発者がデバッガを使ってサーバプロセスにアタッチする機会を与えることを目的としています。この値を単位なしで指定した場合は、秒として扱われます。0 (既定値)を指定すると、遅延は無効になります。このパラメータは、セッション開始後に変更することはできません。</target>
        </trans-unit>
        <trans-unit id="6eb708237d12cba546c559b2942241cf8b7e257d" translate="yes" xml:space="preserve">
          <source>The apply process on the subscriber database always runs with &lt;code&gt;session_replication_role&lt;/code&gt; set to &lt;code&gt;replica&lt;/code&gt;, which produces the usual effects on triggers and constraints.</source>
          <target state="translated">サブスクライバデータベースの適用プロセスは、常に &lt;code&gt;session_replication_role&lt;/code&gt; を &lt;code&gt;replica&lt;/code&gt; に設定して実行されます。これにより、トリガーと制約に通常の影響が生じます。</target>
        </trans-unit>
        <trans-unit id="7cc0c47ee6bb287c95c39ac65d501649b42f2391" translate="yes" xml:space="preserve">
          <source>The approach of lower-casing strings for comparison does not handle some Unicode special cases correctly, for example when one upper-case letter has two lower-case letter equivalents. Unicode distinguishes between &lt;em&gt;case mapping&lt;/em&gt; and &lt;em&gt;case folding&lt;/em&gt; for this reason. Use nondeterministic collations instead of &lt;code&gt;citext&lt;/code&gt; to handle that correctly.</source>
          <target state="translated">比較のための小文字の文字列のアプローチでは、たとえば1つの大文字に2つの小文字の同等物がある場合など、一部のUnicodeの特殊なケースが正しく処理されません。Unicodeは、このため、&lt;em&gt;大文字&lt;/em&gt;&lt;em&gt;小文字のマッピング&lt;/em&gt;と&lt;em&gt;フォールディング&lt;/em&gt;を区別します。これを正しく処理するには、 &lt;code&gt;citext&lt;/code&gt; の代わりに非決定的照合を使用します。</target>
        </trans-unit>
        <trans-unit id="6080666b4ca02e10aa81255d6daacddec5bda53b" translate="yes" xml:space="preserve">
          <source>The approximate average size (in bytes) of the aggregate's state value, when using moving-aggregate mode. This works the same as &lt;code&gt;state_data_size&lt;/code&gt;.</source>
          <target state="translated">移動集約モードを使用する場合の、集約の状態値のおおよその平均サイズ（バイト単位）。これは &lt;code&gt;state_data_size&lt;/code&gt; と同じように機能します。</target>
        </trans-unit>
        <trans-unit id="f88fc1ceaae9590f9501a23eabf20365f3ad0987" translate="yes" xml:space="preserve">
          <source>The approximate average size (in bytes) of the aggregate's state value. If this parameter is omitted or is zero, a default estimate is used based on the &lt;code&gt;state_data_type&lt;/code&gt;. The planner uses this value to estimate the memory required for a grouped aggregate query.</source>
          <target state="translated">アグリゲートの状態値のおおよその平均サイズ（バイト単位）。このパラメーターが省略されているかゼロの場合、 &lt;code&gt;state_data_type&lt;/code&gt; に基づいてデフォルトの推定値が使用されます。プランナーはこの値を使用して、グループ化された集計クエリに必要なメモリを見積もります。</target>
        </trans-unit>
        <trans-unit id="cd3a8a8bd1d1979e55b0fa66bfe45e8f15c71463" translate="yes" xml:space="preserve">
          <source>The approximate average size (in bytes) of the aggregate's state value. If this parameter is omitted or is zero, a default estimate is used based on the &lt;code&gt;state_data_type&lt;/code&gt;. The planner uses this value to estimate the memory required for a grouped aggregate query. The planner will consider using hash aggregation for such a query only if the hash table is estimated to fit in &lt;a href=&quot;runtime-config-resource#GUC-WORK-MEM&quot;&gt;work_mem&lt;/a&gt;; therefore, large values of this parameter discourage use of hash aggregation.</source>
          <target state="translated">アグリゲートの状態値のおおよその平均サイズ（バイト単位）。このパラメーターが省略されるかゼロの場合、 &lt;code&gt;state_data_type&lt;/code&gt; に基づいてデフォルトの見積もりが使用されます。プランナーはこの値を使用して、グループ化された集計クエリに必要なメモリを見積もります。プランナーは、ハッシュテーブルが&lt;a href=&quot;runtime-config-resource#GUC-WORK-MEM&quot;&gt;work_mem&lt;/a&gt;に収まると推定される場合にのみ、そのようなクエリにハッシュ集約を使用することを検討します。したがって、このパラメーターの値が大きいと、ハッシュ集約を使用できなくなります。</target>
        </trans-unit>
        <trans-unit id="5bc1a8ecb6b5b4b69664dd591c46774534fc3e77" translate="yes" xml:space="preserve">
          <source>The approximation 365+97/400 is achieved by having 97 leap years every 400 years, using the following rules:</source>
          <target state="translated">近似365+97/400は、400年ごとに97のうるう年を持つことで、次のようなルールで達成されます。</target>
        </trans-unit>
        <trans-unit id="31a6736bfcac19a9525dbc2f1d3d326327c448b4" translate="yes" xml:space="preserve">
          <source>The archive command is only invoked on completed WAL segments. Hence, if your server generates only little WAL traffic (or has slack periods where it does so), there could be a long delay between the completion of a transaction and its safe recording in archive storage. To put a limit on how old unarchived data can be, you can set &lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-TIMEOUT&quot;&gt;archive_timeout&lt;/a&gt; to force the server to switch to a new WAL segment file at least that often. Note that archived files that are archived early due to a forced switch are still the same length as completely full files. It is therefore unwise to set a very short &lt;code&gt;archive_timeout&lt;/code&gt; &amp;mdash; it will bloat your archive storage. &lt;code&gt;archive_timeout&lt;/code&gt; settings of a minute or so are usually reasonable.</source>
          <target state="translated">アーカイブコマンドは、完了したWALセグメントでのみ呼び出されます。したがって、サーバーが生成するWALトラフィックがほとんどない場合（またはそのようにスラック期間がある場合）、トランザクションの完了とアーカイブストレージへの安全な記録との間に長い遅延が生じる可能性があります。アーカイブされていない古いデータの保存期間を制限するには、&lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-TIMEOUT&quot;&gt;archive_timeout&lt;/a&gt;を設定して、サーバーに少なくともその頻度で新しいWALセグメントファイルに強制的に切り替えさせます。強制切り替えのために早期にアーカイブされたアーカイブファイルは、完全に完全なファイルと同じ長さであることに注意してください。したがって、非常に短い &lt;code&gt;archive_timeout&lt;/code&gt; を設定することは賢明ではありません&amp;mdash;アーカイブストレージが肥大化します。通常、1分程度の &lt;code&gt;archive_timeout&lt;/code&gt; 設定が妥当です。</target>
        </trans-unit>
        <trans-unit id="4b5c4c289983b255b0c54296b2920b77c593a40a" translate="yes" xml:space="preserve">
          <source>The archive command should generally be designed to refuse to overwrite any pre-existing archive file. This is an important safety feature to preserve the integrity of your archive in case of administrator error (such as sending the output of two different servers to the same archive directory).</source>
          <target state="translated">archive コマンドは一般的に、既存のアーカイブファイルの上書きを拒否するように設計されているべきです。これは、管理者のエラーが発生した場合にアーカイブの整合性を維持するための重要な安全機能です (2 つの異なるサーバの出力を同じアーカイブディレクトリに送信するなど)。</target>
        </trans-unit>
        <trans-unit id="cf0db639e47353fbf356cd38ab714bab5a462b99" translate="yes" xml:space="preserve">
          <source>The archive command will be executed under the ownership of the same user that the PostgreSQL server is running as. Since the series of WAL files being archived contains effectively everything in your database, you will want to be sure that the archived data is protected from prying eyes; for example, archive into a directory that does not have group or world read access.</source>
          <target state="translated">アーカイブコマンドは、PostgreSQLサーバが実行しているのと同じユーザの所有下で実行されます。アーカイブされる一連のWALファイルは事実上データベース内のすべてのものを含んでいるので、アーカイブされたデータが盗み見から保護されていることを確認したいでしょう。</target>
        </trans-unit>
        <trans-unit id="c8f2b342beee7c3f52ad6834dd7e62ec7b49990d" translate="yes" xml:space="preserve">
          <source>The archive is a &lt;code&gt;tar&lt;/code&gt; archive.</source>
          <target state="translated">アーカイブは &lt;code&gt;tar&lt;/code&gt; アーカイブです。</target>
        </trans-unit>
        <trans-unit id="d5dd8d384e2ea3f19ced747049fc2fc3701b0b55" translate="yes" xml:space="preserve">
          <source>The archive is a directory archive.</source>
          <target state="translated">ディレクトリアーカイブになっています。</target>
        </trans-unit>
        <trans-unit id="055700e9693e4de21f0986775e962d50e33c74ee" translate="yes" xml:space="preserve">
          <source>The archive is in the custom format of pg_dump.</source>
          <target state="translated">アーカイブはpg_dumpのカスタムフォーマットです。</target>
        </trans-unit>
        <trans-unit id="eadab5c3d582261bf3c9c742fde723a5f27a622f" translate="yes" xml:space="preserve">
          <source>The argument is a pointer to a &lt;code&gt;GISTENTRY&lt;/code&gt; struct. On entry, its &lt;code&gt;key&lt;/code&gt; field contains a non-NULL leaf datum in compressed form. The return value is another &lt;code&gt;GISTENTRY&lt;/code&gt; struct, whose &lt;code&gt;key&lt;/code&gt; field contains the same datum in its original, uncompressed form. If the opclass's compress function does nothing for leaf entries, the &lt;code&gt;fetch&lt;/code&gt; method can return the argument as-is. Or, if the opclass does not have a compress function, the &lt;code&gt;fetch&lt;/code&gt; method can be omitted as well, since it would necessarily be a no-op.</source>
          <target state="translated">引数は &lt;code&gt;GISTENTRY&lt;/code&gt; 構造体へのポインタです。入力時、その &lt;code&gt;key&lt;/code&gt; フィールドには、圧縮された形式のNULL以外の葉データが含まれています。戻り値は別の &lt;code&gt;GISTENTRY&lt;/code&gt; 構造体であり、その &lt;code&gt;key&lt;/code&gt; フィールドには同じデータが元の非圧縮形式で含まれています。 opclassの圧縮関数がリーフエントリに対して何もしない場合、 &lt;code&gt;fetch&lt;/code&gt; メソッドは引数をそのまま返すことができます。または、opclassに圧縮関数がない場合は、 &lt;code&gt;fetch&lt;/code&gt; メソッドも省略できます。これは、必ずしも何もしないためです。</target>
        </trans-unit>
        <trans-unit id="dac840b1ef4656a9069d124658163a0da1612eba" translate="yes" xml:space="preserve">
          <source>The argument of &lt;code&gt;EXISTS&lt;/code&gt; is an arbitrary &lt;code&gt;SELECT&lt;/code&gt; statement, or &lt;em&gt;subquery&lt;/em&gt;. The subquery is evaluated to determine whether it returns any rows. If it returns at least one row, the result of &lt;code&gt;EXISTS&lt;/code&gt; is &amp;ldquo;true&amp;rdquo;; if the subquery returns no rows, the result of &lt;code&gt;EXISTS&lt;/code&gt; is &amp;ldquo;false&amp;rdquo;.</source>
          <target state="translated">&lt;code&gt;EXISTS&lt;/code&gt; の引数は、任意の &lt;code&gt;SELECT&lt;/code&gt; ステートメントまたは&lt;em&gt;サブクエリ&lt;/em&gt;です。サブクエリは、行を返すかどうかを判断するために評価されます。少なくとも1つの行を返す場合、 &lt;code&gt;EXISTS&lt;/code&gt; の結果は「true」です。サブクエリが行を返さない場合、 &lt;code&gt;EXISTS&lt;/code&gt; の結果は「false」になります。</target>
        </trans-unit>
        <trans-unit id="d6ba5cebe3465380bdcbb01333aff93c94b4f911" translate="yes" xml:space="preserve">
          <source>The arguments can appear in any order, not only the one shown above.</source>
          <target state="translated">引数は上記のものに限らず、任意の順番で出現することができます。</target>
        </trans-unit>
        <trans-unit id="e994da275c22b1ba01eba6c807a42b44a7a8c8c1" translate="yes" xml:space="preserve">
          <source>The arguments can optionally have names attached. See &lt;a href=&quot;sql-syntax-calling-funcs&quot;&gt;Section 4.3&lt;/a&gt; for details.</source>
          <target state="translated">引数にはオプションで名前を付けることができます。詳細については、&lt;a href=&quot;sql-syntax-calling-funcs&quot;&gt;セクション4.3&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="b00f745b2cd63e4e8f1ed5a9dd09b736b5753686" translate="yes" xml:space="preserve">
          <source>The arguments must all be convertible to a common data type, which will be the type of the result (see &lt;a href=&quot;typeconv-union-case&quot;&gt;Section 10.5&lt;/a&gt; for details).</source>
          <target state="translated">引数はすべて、結果の型となる共通のデータ型に変換可能である必要があります（詳細は&lt;a href=&quot;typeconv-union-case&quot;&gt;セクション10.5&lt;/a&gt;を参照）。</target>
        </trans-unit>
        <trans-unit id="bdbe896c9bc5e0129d6c42af254aeecec20136cc" translate="yes" xml:space="preserve">
          <source>The arguments of &lt;code&gt;\set&lt;/code&gt; are subject to the same substitution rules as with other commands. Thus you can construct interesting references such as &lt;code&gt;\set :foo 'something'&lt;/code&gt; and get &amp;ldquo;soft links&amp;rdquo; or &amp;ldquo;variable variables&amp;rdquo; of Perl or PHP fame, respectively. Unfortunately (or fortunately?), there is no way to do anything useful with these constructs. On the other hand, &lt;code&gt;\set bar :foo&lt;/code&gt; is a perfectly valid way to copy a variable.</source>
          <target state="translated">&lt;code&gt;\set&lt;/code&gt; の引数は、他のコマンドと同じ置換規則に従います。したがって、 &lt;code&gt;\set :foo 'something'&lt;/code&gt; などの興味深い参照を作成し、PerlまたはPHPの名声の「ソフトリンク」または「変数変数」をそれぞれ取得できます。残念ながら（または幸いなことに？）、これらの構成要素を使用して何かを行う方法はありません。一方、 &lt;code&gt;\set bar :foo&lt;/code&gt; は、変数をコピーするための完全に有効な方法です。</target>
        </trans-unit>
        <trans-unit id="2a1116027fc276cc8421c002135dbd224494828a" translate="yes" xml:space="preserve">
          <source>The arguments to the &lt;code&gt;distance&lt;/code&gt; function are identical to the arguments of the &lt;code&gt;consistent&lt;/code&gt; function.</source>
          <target state="translated">引数 &lt;code&gt;distance&lt;/code&gt; 関数は、引数のと同じです &lt;code&gt;consistent&lt;/code&gt; 機能。</target>
        </trans-unit>
        <trans-unit id="7770d5c449c9e31af54123c29733b7fdcc835b68" translate="yes" xml:space="preserve">
          <source>The arithmetic, bitwise, comparison and logical operators listed in &lt;a href=&quot;pgbench#PGBENCH-OPERATORS&quot;&gt;Table 258&lt;/a&gt; are built into pgbench and may be used in expressions appearing in &lt;a href=&quot;pgbench#PGBENCH-METACOMMAND-SET&quot;&gt;&lt;code&gt;\set&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;pgbench#PGBENCH-OPERATORS&quot;&gt;表258に&lt;/a&gt;リストされている算術、ビットごと、比較、および論理演算子はpgbenchに組み込まれており、&lt;a href=&quot;pgbench#PGBENCH-METACOMMAND-SET&quot;&gt; &lt;code&gt;\set&lt;/code&gt; &lt;/a&gt;現れる式で使用できます。</target>
        </trans-unit>
        <trans-unit id="c75d7c8ffc6407b194e547c6bae30091147ee957" translate="yes" xml:space="preserve">
          <source>The arithmetic, bitwise, comparison and logical operators listed in &lt;a href=&quot;pgbench#PGBENCH-OPERATORS&quot;&gt;Table 274&lt;/a&gt; are built into pgbench and may be used in expressions appearing in &lt;a href=&quot;pgbench#PGBENCH-METACOMMAND-SET&quot;&gt;&lt;code&gt;\set&lt;/code&gt;&lt;/a&gt;. The operators are listed in increasing precedence order. Except as noted, operators taking two numeric inputs will produce a double value if either input is double, otherwise they produce an integer result.</source>
          <target state="translated">&lt;a href=&quot;pgbench#PGBENCH-OPERATORS&quot;&gt;表274に&lt;/a&gt;リストされている算術演算子、ビット演算子、比較演算子、および論理演算子はpgbenchに組み込まれており、&lt;a href=&quot;pgbench#PGBENCH-METACOMMAND-SET&quot;&gt; &lt;code&gt;\set&lt;/code&gt; &lt;/a&gt;表示される式で使用できます。演算子は優先順位の高い順にリストされています。特に明記されていない限り、2つの数値入力を受け取る演算子は、どちらかの入力がdoubleの場合はdouble値を生成し、そうでない場合は整数の結果を生成します。</target>
        </trans-unit>
        <trans-unit id="f99ae22a382dffdb58abe986f81d4d8fc31ff15a" translate="yes" xml:space="preserve">
          <source>The array &lt;code&gt;scankeys&lt;/code&gt;, of length &lt;code&gt;nkeys&lt;/code&gt;, describes the index search condition(s). These conditions are combined with AND &amp;mdash; only index entries that satisfy all of them are interesting. (Note that &lt;code&gt;nkeys&lt;/code&gt; = 0 implies that all index entries satisfy the query.) Usually the consistent function only cares about the &lt;code&gt;sk_strategy&lt;/code&gt; and &lt;code&gt;sk_argument&lt;/code&gt; fields of each array entry, which respectively give the indexable operator and comparison value. In particular it is not necessary to check &lt;code&gt;sk_flags&lt;/code&gt; to see if the comparison value is NULL, because the SP-GiST core code will filter out such conditions. The array &lt;code&gt;orderbys&lt;/code&gt;, of length &lt;code&gt;norderbys&lt;/code&gt;, describes ordering operators (if any) in the same manner. &lt;code&gt;reconstructedValue&lt;/code&gt; is the value reconstructed for the parent tuple; it is &lt;code&gt;(Datum) 0&lt;/code&gt; at the root level or if the &lt;code&gt;inner_consistent&lt;/code&gt; function did not provide a value at the parent level. &lt;code&gt;reconstructedValue&lt;/code&gt; is always of &lt;code&gt;spgConfigOut&lt;/code&gt;.&lt;code&gt;leafType&lt;/code&gt; type. &lt;code&gt;traversalValue&lt;/code&gt; is a pointer to any traverse data passed down from the previous call of &lt;code&gt;inner_consistent&lt;/code&gt; on the parent index tuple, or NULL at the root level. &lt;code&gt;traversalMemoryContext&lt;/code&gt; is the memory context in which to store output traverse values (see below). &lt;code&gt;level&lt;/code&gt; is the current inner tuple's level, starting at zero for the root level. &lt;code&gt;returnData&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; if reconstructed data is required for this query; this will only be so if the &lt;code&gt;config&lt;/code&gt; function asserted &lt;code&gt;canReturnData&lt;/code&gt;. &lt;code&gt;allTheSame&lt;/code&gt; is true if the current inner tuple is marked &amp;ldquo;all-the-same&amp;rdquo;; in this case all the nodes have the same label (if any) and so either all or none of them match the query (see &lt;a href=&quot;spgist-implementation#SPGIST-ALL-THE-SAME&quot;&gt;Section 65.4.3&lt;/a&gt;). &lt;code&gt;hasPrefix&lt;/code&gt; is true if the current inner tuple contains a prefix; if so, &lt;code&gt;prefixDatum&lt;/code&gt; is its value. &lt;code&gt;nNodes&lt;/code&gt; is the number of child nodes contained in the inner tuple, and &lt;code&gt;nodeLabels&lt;/code&gt; is an array of their label values, or NULL if the nodes do not have labels.</source>
          <target state="translated">長さが &lt;code&gt;nkeys&lt;/code&gt; の配列 &lt;code&gt;scankeys&lt;/code&gt; は、インデックス検索条件を記述します。これらの条件はANDと組み合わされます&amp;mdash;条件のすべてを満たすインデックスエントリのみが対象です。 （なお、 &lt;code&gt;nkeys&lt;/code&gt; = 0は、すべてのインデックスエントリは、クエリを満たすことを意味する。）通常、一貫した機能についてのみ心配 &lt;code&gt;sk_strategy&lt;/code&gt; と &lt;code&gt;sk_argument&lt;/code&gt; それぞれ割出し可能オペレータと比較値を与える各アレイ・エントリのフィールドを、。特に、SP-GiSTコアコードはそのような条件を除外するため、 &lt;code&gt;sk_flags&lt;/code&gt; をチェックして比較値がNULLかどうかを確認する必要はありません。配列 &lt;code&gt;orderbys&lt;/code&gt; 長の、 &lt;code&gt;norderbys&lt;/code&gt; は、演算子がある場合は、同じ方法で演算子を並べ替えます。 &lt;code&gt;reconstructedValue&lt;/code&gt; は、親タプルに対して再構築された値です。それは &lt;code&gt;(Datum) 0&lt;/code&gt; 場合は、ルートレベルまたは &lt;code&gt;inner_consistent&lt;/code&gt; 機能は、親レベルの値を提供しませんでした。 &lt;code&gt;reconstructedValue&lt;/code&gt; は常に &lt;code&gt;spgConfigOut&lt;/code&gt; です。 &lt;code&gt;leafType&lt;/code&gt; タイプ。 &lt;code&gt;traversalValue&lt;/code&gt; は、親インデックスタプルに対する &lt;code&gt;inner_consistent&lt;/code&gt; の前回の呼び出しから渡されたトラバースデータへのポインター、またはルートレベルのNULLです。 &lt;code&gt;traversalMemoryContext&lt;/code&gt; は、出力トラバース値を格納するメモリコンテキストです（以下を参照）。 &lt;code&gt;level&lt;/code&gt; ルートレベルのゼロから始まる、現在の内部タプルのレベルです。このクエリに再構築されたデータが必要な場合、 &lt;code&gt;returnData&lt;/code&gt; は &lt;code&gt;true&lt;/code&gt; です。これは、 &lt;code&gt;config&lt;/code&gt; 関数が &lt;code&gt;canReturnData&lt;/code&gt; をアサートした場合にのみ当てはまります。現在の内部タプルが「すべて同じ」とマークされている場合、 &lt;code&gt;allTheSame&lt;/code&gt; はtrueです。この場合、すべてのノードは同じラベル（存在する場合）を持つため、それらのすべてまたはいずれもクエリに一致しません（&lt;a href=&quot;spgist-implementation#SPGIST-ALL-THE-SAME&quot;&gt;項65.4.3を&lt;/a&gt;参照）。現在の内部タプルにプレフィックスが含まれている場合、 &lt;code&gt;hasPrefix&lt;/code&gt; はtrueです。その場合、 &lt;code&gt;prefixDatum&lt;/code&gt; がその値です。 &lt;code&gt;nNodes&lt;/code&gt; は、内部タプルに含まれる子ノードの数であり、 &lt;code&gt;nodeLabels&lt;/code&gt; ラベル値の配列、またはノードにラベルがない場合はNULLです。</target>
        </trans-unit>
        <trans-unit id="b4cb45da91499c64a7e30418524dae4c6bc491fc" translate="yes" xml:space="preserve">
          <source>The array &lt;code&gt;scankeys&lt;/code&gt;, of length &lt;code&gt;nkeys&lt;/code&gt;, describes the index search condition(s). These conditions are combined with AND &amp;mdash; only index entries that satisfy all of them satisfy the query. (Note that &lt;code&gt;nkeys&lt;/code&gt; = 0 implies that all index entries satisfy the query.) Usually the consistent function only cares about the &lt;code&gt;sk_strategy&lt;/code&gt; and &lt;code&gt;sk_argument&lt;/code&gt; fields of each array entry, which respectively give the indexable operator and comparison value. In particular it is not necessary to check &lt;code&gt;sk_flags&lt;/code&gt; to see if the comparison value is NULL, because the SP-GiST core code will filter out such conditions. The array &lt;code&gt;orderbys&lt;/code&gt;, of length &lt;code&gt;norderbys&lt;/code&gt;, describes the ordering operators in the same manner. &lt;code&gt;reconstructedValue&lt;/code&gt; is the value reconstructed for the parent tuple; it is &lt;code&gt;(Datum) 0&lt;/code&gt; at the root level or if the &lt;code&gt;inner_consistent&lt;/code&gt; function did not provide a value at the parent level. &lt;code&gt;reconstructedValue&lt;/code&gt; is always of &lt;code&gt;spgConfigOut&lt;/code&gt;.&lt;code&gt;leafType&lt;/code&gt; type. &lt;code&gt;traversalValue&lt;/code&gt; is a pointer to any traverse data passed down from the previous call of &lt;code&gt;inner_consistent&lt;/code&gt; on the parent index tuple, or NULL at the root level. &lt;code&gt;level&lt;/code&gt; is the current leaf tuple's level, starting at zero for the root level. &lt;code&gt;returnData&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; if reconstructed data is required for this query; this will only be so if the &lt;code&gt;config&lt;/code&gt; function asserted &lt;code&gt;canReturnData&lt;/code&gt;. &lt;code&gt;leafDatum&lt;/code&gt; is the key value of &lt;code&gt;spgConfigOut&lt;/code&gt;.&lt;code&gt;leafType&lt;/code&gt; stored in the current leaf tuple.</source>
          <target state="translated">長さが &lt;code&gt;nkeys&lt;/code&gt; の配列 &lt;code&gt;scankeys&lt;/code&gt; は、インデックス検索条件を記述します。これらの条件はANDと組み合わされます。これらすべての条件を満たすインデックスエントリのみがクエリを満たします。 （なお、 &lt;code&gt;nkeys&lt;/code&gt; = 0は、すべてのインデックスエントリは、クエリを満たすことを意味する。）通常、一貫した機能についてのみ心配 &lt;code&gt;sk_strategy&lt;/code&gt; と &lt;code&gt;sk_argument&lt;/code&gt; それぞれ割出し可能オペレータと比較値を与える各アレイ・エントリのフィールドを、。特に、SP-GiSTコアコードはそのような条件を除外するため、 &lt;code&gt;sk_flags&lt;/code&gt; をチェックして比較値がNULLかどうかを確認する必要はありません。配列 &lt;code&gt;orderbys&lt;/code&gt; 長の、 &lt;code&gt;norderbys&lt;/code&gt; 、順序付け演算子を同じ方法で説明します。 &lt;code&gt;reconstructedValue&lt;/code&gt; は、親タプルに対して再構築された値です。それは &lt;code&gt;(Datum) 0&lt;/code&gt; 場合は、ルートレベルまたは &lt;code&gt;inner_consistent&lt;/code&gt; 機能は、親レベルの値を提供しませんでした。 &lt;code&gt;reconstructedValue&lt;/code&gt; は常に &lt;code&gt;spgConfigOut&lt;/code&gt; です。 &lt;code&gt;leafType&lt;/code&gt; タイプ。 &lt;code&gt;traversalValue&lt;/code&gt; は、親インデックスタプルに対する &lt;code&gt;inner_consistent&lt;/code&gt; の前回の呼び出しから渡されたトラバースデータへのポインター、またはルートレベルのNULLです。 &lt;code&gt;level&lt;/code&gt; は、現在のリーフタプルのレベルであり、ルートレベルのゼロから始まります。 &lt;code&gt;returnData&lt;/code&gt; は &lt;code&gt;true&lt;/code&gt; このクエリに再構築されたデータが必要な場合。これは、 &lt;code&gt;config&lt;/code&gt; 関数が &lt;code&gt;canReturnData&lt;/code&gt; をアサートした場合にのみ当てはまります。 &lt;code&gt;leafDatum&lt;/code&gt; は、キー値である &lt;code&gt;spgConfigOut&lt;/code&gt; 。現在の &lt;code&gt;leafType&lt;/code&gt; 格納されているleafType。</target>
        </trans-unit>
        <trans-unit id="e26f508cb31ef1599228fd2a799f7ebeb7c2026b" translate="yes" xml:space="preserve">
          <source>The array containment operators (&lt;code&gt;&amp;lt;@&lt;/code&gt; and &lt;code&gt;@&amp;gt;&lt;/code&gt;) consider one array to be contained in another one if each of its elements appears in the other one. Duplicates are not treated specially, thus &lt;code&gt;ARRAY[1]&lt;/code&gt; and &lt;code&gt;ARRAY[1,1]&lt;/code&gt; are each considered to contain the other.</source>
          <target state="translated">配列包含演算子（ &lt;code&gt;&amp;lt;@&lt;/code&gt; および &lt;code&gt;@&amp;gt;&lt;/code&gt; ）は、各要素が他の配列に出現する場合、1つの配列が別の配列に含まれていると見なします。重複は特別に処理されないため、 &lt;code&gt;ARRAY[1]&lt;/code&gt; と &lt;code&gt;ARRAY[1,1]&lt;/code&gt; はそれぞれ他方を含むと見なされます。</target>
        </trans-unit>
        <trans-unit id="a1ac56c0bce21554d688d27823930a835d434c12" translate="yes" xml:space="preserve">
          <source>The array ordering operators (&lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;, etc) compare the array contents element-by-element, using the default B-tree comparison function for the element data type, and sort based on the first difference. In multidimensional arrays the elements are visited in row-major order (last subscript varies most rapidly). If the contents of two arrays are equal but the dimensionality is different, the first difference in the dimensionality information determines the sort order. (This is a change from versions of PostgreSQL prior to 8.2: older versions would claim that two arrays with the same contents were equal, even if the number of dimensions or subscript ranges were different.)</source>
          <target state="translated">配列順序付け演算子（ &lt;code&gt;&amp;lt;&lt;/code&gt; 、 &lt;code&gt;&amp;gt;=&lt;/code&gt; など）は、要素のデータ型のデフォルトのBツリー比較関数を使用して、配列の内容を要素ごとに比較し、最初の違いに基づいてソートします。多次元配列では、要素は行優先順でアクセスされます（最後の添え字は最も急速に変化します）。 2つの配列の内容は等しいが次元数が異なる場合、次元数情報の最初の違いがソート順を決定します。 （これは8.2より前のバージョンのPostgreSQLからの変更点です。古いバージョンでは、次元数または添え字範囲の数が異なっていても、同じ内容の2つの配列は等しいと主張していました。）</target>
        </trans-unit>
        <trans-unit id="46741e31bee949b907d3858dce5eac23fd4bcbdf" translate="yes" xml:space="preserve">
          <source>The array output routine will include explicit dimensions in its result only when there are one or more lower bounds different from one.</source>
          <target state="translated">配列出力ルーチンは、下界が1つ以上異なる場合にのみ、その結果に明示的な次元を含みます。</target>
        </trans-unit>
        <trans-unit id="145d4d2c0c7cafb8b7bd9116657b494c47b146d7" translate="yes" xml:space="preserve">
          <source>The array output routine will put double quotes around element values if they are empty strings, contain curly braces, delimiter characters, double quotes, backslashes, or white space, or match the word &lt;code&gt;NULL&lt;/code&gt;. Double quotes and backslashes embedded in element values will be backslash-escaped. For numeric data types it is safe to assume that double quotes will never appear, but for textual data types one should be prepared to cope with either the presence or absence of quotes.</source>
          <target state="translated">配列出力ルーチンは、要素の値が空の文字列である場合、中括弧、区切り文字、二重引用符、バックスラッシュ、または空白を含む場合、または単語 &lt;code&gt;NULL&lt;/code&gt; に一致する場合、要素値を二重引用符で囲みます。要素の値に埋め込まれた二重引用符とバックスラッシュは、バックスラッシュでエスケープされます。数値データ型の場合、二重引用符は表示されないと想定しても安全ですが、テキストデータ型の場合、引用符の有無に対処できるように準備しておく必要があります。</target>
        </trans-unit>
        <trans-unit id="103411c7faff9f23f3f96fc9d71ef919bccd0156" translate="yes" xml:space="preserve">
          <source>The array subscript numbers are written within square brackets. By default PostgreSQL uses a one-based numbering convention for arrays, that is, an array of &lt;code&gt;n&lt;/code&gt; elements starts with &lt;code&gt;array[1]&lt;/code&gt; and ends with &lt;code&gt;array[n]&lt;/code&gt;.</source>
          <target state="translated">配列の添え字番号は角括弧内に記述されます。デフォルトでは、PostgreSQLは配列に1ベースの番号付け規則を使用します。つまり、 &lt;code&gt;n&lt;/code&gt; 要素の配列は &lt;code&gt;array[1]&lt;/code&gt; で始まり、 &lt;code&gt;array[n]&lt;/code&gt; 終わります。</target>
        </trans-unit>
        <trans-unit id="d22d8bf767f7e2f65ff41f5dea0e4f13bccb5b56" translate="yes" xml:space="preserve">
          <source>The associated sort operator for a &lt;code&gt;MIN&lt;/code&gt;- or &lt;code&gt;MAX&lt;/code&gt;-like aggregate. This is just an operator name (possibly schema-qualified). The operator is assumed to have the same input data types as the aggregate (which must be a single-argument normal aggregate).</source>
          <target state="translated">&lt;code&gt;MIN&lt;/code&gt; または &lt;code&gt;MAX&lt;/code&gt; のような集約に関連付けられたソート演算子。これは単なる演算子名です（スキーマ修飾されている可能性があります）。演算子は、集約と同じ入力データ型（単一引数の通常の集約でなければならない）であると想定されています。</target>
        </trans-unit>
        <trans-unit id="9f45180efdf5d69d899f4c71484ab019adca9bab" translate="yes" xml:space="preserve">
          <source>The associated value is always a list of objects, each describing a range of WAL records that must be readable from a particular timeline in order to make use of the backup. The structure of these objects is further described in &lt;a href=&quot;backup-manifest-wal-ranges&quot;&gt;Section 71.3&lt;/a&gt;.</source>
          <target state="translated">関連する値は常にオブジェクトのリストであり、各オブジェクトは、バックアップを利用するために特定のタイムラインから読み取る必要があるWALレコードの範囲を記述します。これらのオブジェクトの構造については、&lt;a href=&quot;backup-manifest-wal-ranges&quot;&gt;セクション71.3で&lt;/a&gt;詳しく説明します。</target>
        </trans-unit>
        <trans-unit id="658fbccdd7164ea13c1ae7470c9f741a09ac38d8" translate="yes" xml:space="preserve">
          <source>The associated value is always a list of objects, each describing one file that is present in the backup. No entries are present in this list for the WAL files that are needed in order to use the backup, or for the backup manifest itself. The structure of each object in the list is described in &lt;a href=&quot;backup-manifest-files&quot;&gt;Section 71.2&lt;/a&gt;.</source>
          <target state="translated">関連する値は常にオブジェクトのリストであり、それぞれがバックアップに存在する1つのファイルを記述します。このリストには、バックアップを使用するために必要なWALファイル、またはバックアップマニフェスト自体のエントリはありません。リスト内の各オブジェクトの構造については、&lt;a href=&quot;backup-manifest-files&quot;&gt;セクション71.2で&lt;/a&gt;説明しています。</target>
        </trans-unit>
        <trans-unit id="c8c6c90066586df369729932567a3ffed5f17a48" translate="yes" xml:space="preserve">
          <source>The associated value is always the integer 1.</source>
          <target state="translated">関連する値は常に整数の1です。</target>
        </trans-unit>
        <trans-unit id="354efec1fb802640a13d0696d88d4e7e365ca415" translate="yes" xml:space="preserve">
          <source>The assurance that once a &lt;a href=&quot;glossary#GLOSSARY-TRANSACTION&quot;&gt;transaction&lt;/a&gt; has been &lt;a href=&quot;glossary#GLOSSARY-COMMIT&quot;&gt;committed&lt;/a&gt;, the changes remain even after a system failure or crash. This is one of the ACID properties.</source>
          <target state="translated">&lt;a href=&quot;glossary#GLOSSARY-TRANSACTION&quot;&gt;トランザクション&lt;/a&gt;が&lt;a href=&quot;glossary#GLOSSARY-COMMIT&quot;&gt;コミットされる&lt;/a&gt;と、システム障害またはクラッシュ後も変更が保持されるという保証。これはACIDプロパティの1つです。</target>
        </trans-unit>
        <trans-unit id="daf89077b4ae20ed63b034eee053148490bd888b" translate="yes" xml:space="preserve">
          <source>The asterisk (&lt;code&gt;*&lt;/code&gt;) is used in some contexts to denote all the fields of a table row or composite value. It also has a special meaning when used as the argument of an aggregate function, namely that the aggregate does not require any explicit parameter.</source>
          <target state="translated">アスタリスク（ &lt;code&gt;*&lt;/code&gt; ）は、テーブルの行または複合値のすべてのフィールドを示すために、一部のコンテキストで使用されます。また、集約関数の引数として使用する場合は特別な意味があります。つまり、集約は明示的なパラメータを必要としません。</target>
        </trans-unit>
        <trans-unit id="a8f1751d17a34d74d41affe83afc62bf9926cd57" translate="yes" xml:space="preserve">
          <source>The autocommit-on mode is PostgreSQL's traditional behavior, but autocommit-off is closer to the SQL spec. If you prefer autocommit-off, you might wish to set it in the system-wide &lt;code&gt;psqlrc&lt;/code&gt; file or your &lt;code&gt;~/.psqlrc&lt;/code&gt; file.</source>
          <target state="translated">自動コミットオンモードはPostgreSQLの従来の動作ですが、自動コミットオフはSQL仕様により近くなっています。自動コミットオフを希望する場合は、システム全体の &lt;code&gt;psqlrc&lt;/code&gt; ファイルまたは &lt;code&gt;~/.psqlrc&lt;/code&gt; ファイルに設定することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="a786e81687748275f55ad70f3f5bbc00d402d949" translate="yes" xml:space="preserve">
          <source>The autovacuum daemon does not issue &lt;code&gt;ANALYZE&lt;/code&gt; commands for foreign tables, since it has no means of determining how often that might be useful. If your queries require statistics on foreign tables for proper planning, it's a good idea to run manually-managed &lt;code&gt;ANALYZE&lt;/code&gt; commands on those tables on a suitable schedule.</source>
          <target state="translated">autovacuumデーモンは、有用である可能性のある頻度を判別する手段がないため、外部テーブルに対して &lt;code&gt;ANALYZE&lt;/code&gt; コマンドを発行しません。クエリで適切な計画のために外部テーブルの統計が必要な場合は、それらのテーブルに対して手動で管理された &lt;code&gt;ANALYZE&lt;/code&gt; コマンドを適切なスケジュールで実行することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="c3fb21098ee7138941d3ecbb7f53e34e6b514d65" translate="yes" xml:space="preserve">
          <source>The autovacuum daemon, if enabled, will automatically issue &lt;code&gt;ANALYZE&lt;/code&gt; commands whenever the content of a table has changed sufficiently. However, administrators might prefer to rely on manually-scheduled &lt;code&gt;ANALYZE&lt;/code&gt; operations, particularly if it is known that update activity on a table will not affect the statistics of &amp;ldquo;interesting&amp;rdquo; columns. The daemon schedules &lt;code&gt;ANALYZE&lt;/code&gt; strictly as a function of the number of rows inserted or updated; it has no knowledge of whether that will lead to meaningful statistical changes.</source>
          <target state="translated">自動バキュームデーモンが有効になっている場合、テーブルの内容が十分に変更されると、 &lt;code&gt;ANALYZE&lt;/code&gt; コマンドが自動的に発行されます。ただし、管理者は、特にテーブルの更新アクティビティが「興味深い」列の統計に影響しないことがわかっている場合は、手動でスケジュールされた &lt;code&gt;ANALYZE&lt;/code&gt; 操作に依存することを好むかもしれません。デーモンは &lt;code&gt;ANALYZE&lt;/code&gt; を厳密に、挿入または更新された行数の関数としてスケジュールします。それが意味のある統計的変化につながるかどうかについては知りません。</target>
        </trans-unit>
        <trans-unit id="252860c5ed0258d1ec21ceb8459b34f92032e663" translate="yes" xml:space="preserve">
          <source>The availability of the different password-based authentication methods depends on how a user's password on the server is encrypted (or hashed, more accurately). This is controlled by the configuration parameter &lt;a href=&quot;runtime-config-connection#GUC-PASSWORD-ENCRYPTION&quot;&gt;password_encryption&lt;/a&gt; at the time the password is set. If a password was encrypted using the &lt;code&gt;scram-sha-256&lt;/code&gt; setting, then it can be used for the authentication methods &lt;code&gt;scram-sha-256&lt;/code&gt; and &lt;code&gt;password&lt;/code&gt; (but password transmission will be in plain text in the latter case). The authentication method specification &lt;code&gt;md5&lt;/code&gt; will automatically switch to using the &lt;code&gt;scram-sha-256&lt;/code&gt; method in this case, as explained above, so it will also work. If a password was encrypted using the &lt;code&gt;md5&lt;/code&gt; setting, then it can be used only for the &lt;code&gt;md5&lt;/code&gt; and &lt;code&gt;password&lt;/code&gt; authentication method specifications (again, with the password transmitted in plain text in the latter case). (Previous PostgreSQL releases supported storing the password on the server in plain text. This is no longer possible.) To check the currently stored password hashes, see the system catalog &lt;code&gt;pg_authid&lt;/code&gt;.</source>
          <target state="translated">さまざまなパスワードベースの認証方法を使用できるかどうかは、サーバー上のユーザーのパスワードをどのように暗号化（またはハッシュ化）するかによって異なります。これは、パスワードの設定時に構成パラメーター&lt;a href=&quot;runtime-config-connection#GUC-PASSWORD-ENCRYPTION&quot;&gt;password_encryption&lt;/a&gt;によって制御されます。パスワードが &lt;code&gt;scram-sha-256&lt;/code&gt; 設定を使用して暗号化されている場合、認証方法 &lt;code&gt;scram-sha-256&lt;/code&gt; と &lt;code&gt;password&lt;/code&gt; 使用できます（ただし、パスワードの送信は、後者の場合はプレーンテキストになります）。この場合、認証方法の指定 &lt;code&gt;md5&lt;/code&gt; は、上で説明したように &lt;code&gt;scram-sha-256&lt;/code&gt; 方法を使用するように自動的に切り替わるため、機能します。パスワードが &lt;code&gt;md5&lt;/code&gt; を使用して暗号化されている場合設定すると、 &lt;code&gt;md5&lt;/code&gt; および &lt;code&gt;password&lt;/code&gt; 認証方法の仕様でのみ使用できます（後者の場合も、パスワードはプレーンテキストで送信されます）。（以前のPostgreSQLリリースでは、サーバーへのパスワードのプレーンテキストでの保存がサポートされていました。これはできなくなりました。）現在保存されているパスワードハッシュを確認するには、システムカタログ &lt;code&gt;pg_authid&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="be4db45cb9d664398bfb8a833d78745c5f0e03cb" translate="yes" xml:space="preserve">
          <source>The available commands are:</source>
          <target state="translated">使用可能なコマンドは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="a8b4cfaf9660d8b419b38ef501d2e57aeb699d73" translate="yes" xml:space="preserve">
          <source>The available functions are shown in &lt;a href=&quot;ltree#LTREE-FUNC-TABLE&quot;&gt;Table F.14&lt;/a&gt;.</source>
          <target state="translated">利用可能な機能を&lt;a href=&quot;ltree#LTREE-FUNC-TABLE&quot;&gt;表F.14に&lt;/a&gt;示します。</target>
        </trans-unit>
        <trans-unit id="4cf27edb4ec77236cfb1d7851c53ced1470b1ae0" translate="yes" xml:space="preserve">
          <source>The available privileges are:</source>
          <target state="translated">利用可能な特典は</target>
        </trans-unit>
        <trans-unit id="b24cdea942d5e58d37185d11c8d0001459291bc6" translate="yes" xml:space="preserve">
          <source>The available sequence functions are:</source>
          <target state="translated">利用可能なシーケンス機能は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="1f54359e34884f0f14a7082c4b037dceb1040a71" translate="yes" xml:space="preserve">
          <source>The available transaction characteristics are the transaction isolation level, the transaction access mode (read/write or read-only), and the deferrable mode. In addition, a snapshot can be selected, though only for the current transaction, not as a session default.</source>
          <target state="translated">利用可能なトランザクション特性は、トランザクション分離レベル、トランザクショ ンアクセスモード(読み取り/書き込みまたは読み取り専用)、および遅延可能なモードである。さらに、セッションのデフォルトではなく、現在のトランザクショ ンに対してのみであるが、スナップショットを選択することができる。</target>
        </trans-unit>
        <trans-unit id="690838e9cb021af0a2b1acec6c3a93a7e08f1bb6" translate="yes" xml:space="preserve">
          <source>The average stored width, in bytes, of nonnull entries</source>
          <target state="translated">非ヌル項目の平均格納幅(バイト単位)。</target>
        </trans-unit>
        <trans-unit id="4f544e0e02bfed2fa010d1f669949bc62b79024b" translate="yes" xml:space="preserve">
          <source>The backend type corresponds to the column &lt;code&gt;backend_type&lt;/code&gt; in the view &lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-ACTIVITY-VIEW&quot;&gt;&lt;code&gt;pg_stat_activity&lt;/code&gt;&lt;/a&gt;, but additional types can appear in the log that don't show in that view.</source>
          <target state="translated">バックエンドタイプは、ビュー&lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-ACTIVITY-VIEW&quot;&gt; &lt;code&gt;pg_stat_activity&lt;/code&gt; の&lt;/a&gt;列 &lt;code&gt;backend_type&lt;/code&gt; に対応しますが、そのビューに表示されない追加のタイプがログに表示される場合があります。</target>
        </trans-unit>
        <trans-unit id="fde6e34822920c61d23e994603a609b1307667e3" translate="yes" xml:space="preserve">
          <source>The background writer is active during recovery and will perform restartpoints (similar to checkpoints on the primary) and normal block cleaning activities. This can include updates of the hint bit information stored on the standby server. The &lt;code&gt;CHECKPOINT&lt;/code&gt; command is accepted during recovery, though it performs a restartpoint rather than a new checkpoint.</source>
          <target state="translated">バックグラウンドライターはリカバリ中アクティブであり、再起動ポイント（プライマリのチェックポイントと同様）および通常のブロッククリーニングアクティビティを実行します。これには、スタンバイサーバーに格納されているヒントビット情報の更新が含まれます。 &lt;code&gt;CHECKPOINT&lt;/code&gt; のそれはリスタートではなく、新しいチェックポイントを実行しても、コマンドは、リカバリ中に受け入れられています。</target>
        </trans-unit>
        <trans-unit id="6a4770c7c3de3b5a6b683a55e8771f9ee1778b13" translate="yes" xml:space="preserve">
          <source>The backup history file is just a small text file. It contains the label string you gave to &lt;a href=&quot;app-pgbasebackup&quot;&gt;pg_basebackup&lt;/a&gt;, as well as the starting and ending times and WAL segments of the backup. If you used the label to identify the associated dump file, then the archived history file is enough to tell you which dump file to restore.</source>
          <target state="translated">バックアップ履歴ファイルは小さなテキストファイルです。これには、&lt;a href=&quot;app-pgbasebackup&quot;&gt;pg_basebackupに指定し&lt;/a&gt;たラベル文字列、バックアップの開始時間と終了時間、およびWALセグメントが含まれています。ラベルを使用して関連するダンプファイルを識別した場合、アーカイブされた履歴ファイルは、どのダンプファイルを復元するかを通知するのに十分です。</target>
        </trans-unit>
        <trans-unit id="c801dce038f073674a8ac5aca2db97b365640813" translate="yes" xml:space="preserve">
          <source>The backup history file is not created in the database cluster backed up.</source>
          <target state="translated">バックアップしたデータベースクラスタにバックアップ履歴ファイルが作成されません。</target>
        </trans-unit>
        <trans-unit id="0c8b05e2a70131e9b678814d20139ef5d923c4dc" translate="yes" xml:space="preserve">
          <source>The backup is made over a regular PostgreSQL connection that uses the replication protocol. The connection must be made with a user ID that has &lt;code&gt;REPLICATION&lt;/code&gt; permissions (see &lt;a href=&quot;role-attributes&quot;&gt;Section 21.2&lt;/a&gt;) or is a superuser, and &lt;a href=&quot;auth-pg-hba-conf&quot;&gt;&lt;code&gt;pg_hba.conf&lt;/code&gt;&lt;/a&gt; must permit the replication connection. The server must also be configured with &lt;a href=&quot;runtime-config-replication#GUC-MAX-WAL-SENDERS&quot;&gt;max_wal_senders&lt;/a&gt; set high enough to provide at least one walsender for the backup plus one for WAL streaming (if used).</source>
          <target state="translated">バックアップは、レプリケーションプロトコルを使用する通常のPostgreSQL接続を介して行われます。接続は、 &lt;code&gt;REPLICATION&lt;/code&gt; 権限を持つユーザーID （&lt;a href=&quot;role-attributes&quot;&gt;セクション21.2を&lt;/a&gt;参照）またはスーパーユーザーで行う必要があり、&lt;a href=&quot;auth-pg-hba-conf&quot;&gt; &lt;code&gt;pg_hba.conf&lt;/code&gt; &lt;/a&gt;はレプリケーション接続を許可する必要があります。サーバーは、バックアップ用に少なくとも1つのウォルセンダーとWALストリーミング用に1つ（使用する場合）を提供するのに十分な高さに設定された&lt;a href=&quot;runtime-config-replication#GUC-MAX-WAL-SENDERS&quot;&gt;max_wal_senders&lt;/a&gt;で構成する必要もあります。</target>
        </trans-unit>
        <trans-unit id="be7e03b230f28bb65cecb0388bcfd3f69ad98241" translate="yes" xml:space="preserve">
          <source>The backup is made over a regular PostgreSQL connection, and uses the replication protocol. The connection must be made with a superuser or a user having &lt;code&gt;REPLICATION&lt;/code&gt; permissions (see &lt;a href=&quot;role-attributes&quot;&gt;Section 21.2&lt;/a&gt;), and &lt;code&gt;pg_hba.conf&lt;/code&gt; must explicitly permit the replication connection. The server must also be configured with &lt;a href=&quot;runtime-config-replication#GUC-MAX-WAL-SENDERS&quot;&gt;max_wal_senders&lt;/a&gt; set high enough to leave at least one session available for the backup and one for WAL streaming (if used).</source>
          <target state="translated">バックアップは通常のPostgreSQL接続を介して行われ、レプリケーションプロトコルを使用します。接続は、スーパーユーザーまたは &lt;code&gt;REPLICATION&lt;/code&gt; 権限（&lt;a href=&quot;role-attributes&quot;&gt;セクション21.2を&lt;/a&gt;参照）を持つユーザーを使用して行う必要があり、 &lt;code&gt;pg_hba.conf&lt;/code&gt; はレプリケーション接続を明示的に許可する必要があります。サーバーは、少なくとも1つのセッションをバックアップに、&lt;a href=&quot;runtime-config-replication#GUC-MAX-WAL-SENDERS&quot;&gt;残りの&lt;/a&gt; 1つをWALストリーミング（使用する場合）に使用できるように、max_wal_sendersを十分に高く設定して構成する必要もあります。</target>
        </trans-unit>
        <trans-unit id="eee28f79bda7267e3e26bc973ac8a0442a749a1b" translate="yes" xml:space="preserve">
          <source>The backup label file includes the label string you gave to &lt;code&gt;pg_start_backup&lt;/code&gt;, as well as the time at which &lt;code&gt;pg_start_backup&lt;/code&gt; was run, and the name of the starting WAL file. In case of confusion it is therefore possible to look inside a backup file and determine exactly which backup session the dump file came from. The tablespace map file includes the symbolic link names as they exist in the directory &lt;code&gt;pg_tblspc/&lt;/code&gt; and the full path of each symbolic link. These files are not merely for your information; their presence and contents are critical to the proper operation of the system's recovery process.</source>
          <target state="translated">バックアップラベルファイルには、 &lt;code&gt;pg_start_backup&lt;/code&gt; に指定したラベル文字列、 &lt;code&gt;pg_start_backup&lt;/code&gt; が実行された時刻、および開始WALファイルの名前が含まれています。したがって、混乱した場合は、バックアップファイルの内部を調べて、ダンプファイルのバックアップセッションを正確に特定することができます。テーブルスペースマップファイルには、 &lt;code&gt;pg_tblspc/&lt;/code&gt; ディレクトリに存在するシンボリックリンク名と、各シンボリックリンクの絶対パスが含まれています。これらのファイルは単に情報を提供するものではありません。それらの存在と内容は、システムの回復プロセスの適切な操作に不可欠です。</target>
        </trans-unit>
        <trans-unit id="e501c42ea79c8d19e5c5b2265b4863425cf9ba55" translate="yes" xml:space="preserve">
          <source>The backup manifest JSON document contains the following keys.</source>
          <target state="translated">バックアップ マニフェスト JSON ドキュメントには、以下のキーが含まれています。</target>
        </trans-unit>
        <trans-unit id="ec28fc3545975c7f203eb96bb815ab982f3d0305" translate="yes" xml:space="preserve">
          <source>The backup will include all files in the data directory and tablespaces, including the configuration files and any additional files placed in the directory by third parties, except certain temporary files managed by PostgreSQL. But only regular files and directories are copied, except that symbolic links used for tablespaces are preserved. Symbolic links pointing to certain directories known to PostgreSQL are copied as empty directories. Other symbolic links and special device files are skipped. See &lt;a href=&quot;https://www.postgresql.org/docs/12/protocol-replication.html&quot;&gt;Section 52.4&lt;/a&gt; for the precise details.</source>
          <target state="translated">バックアップには、PostgreSQLが管理する特定の一時ファイルを除いて、データディレクトリとテーブルスペース内のすべてのファイルが含まれます。ただし、テーブルスペースに使用されるシンボリックリンクが保持されることを除いて、通常のファイルとディレクトリのみがコピーされます。PostgreSQLが認識している特定のディレクトリを指すシンボリックリンクは、空のディレクトリとしてコピーされます。他のシンボリックリンクと特別なデバイスファイルはスキップされます。詳細については、&lt;a href=&quot;https://www.postgresql.org/docs/12/protocol-replication.html&quot;&gt;セクション52.4&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="fcd73c92b5c4d4bc4af88fe2398a5bc2bbfd5cfa" translate="yes" xml:space="preserve">
          <source>The backup will include all files in the data directory and tablespaces, including the configuration files and any additional files placed in the directory by third parties, except certain temporary files managed by PostgreSQL. But only regular files and directories are copied, except that symbolic links used for tablespaces are preserved. Symbolic links pointing to certain directories known to PostgreSQL are copied as empty directories. Other symbolic links and special device files are skipped. See &lt;a href=&quot;https://www.postgresql.org/docs/13/protocol-replication.html&quot;&gt;Section 52.4&lt;/a&gt; for the precise details.</source>
          <target state="translated">バックアップには、データディレクトリとテーブルスペース内のすべてのファイルが含まれます。これには、PostgreSQLによって管理される特定の一時ファイルを除き、構成ファイルとサードパーティによってディレクトリに配置された追加ファイルが含まれます。ただし、表領域に使用されるシンボリックリンクが保持されることを除いて、通常のファイルとディレクトリのみがコピーされます。PostgreSQLに認識されている特定のディレクトリを指すシンボリックリンクは、空のディレクトリとしてコピーされます。他のシンボリックリンクと特別なデバイスファイルはスキップされます。参照&lt;a href=&quot;https://www.postgresql.org/docs/13/protocol-replication.html&quot;&gt;セクション52.4を&lt;/a&gt;正確な詳細のために。</target>
        </trans-unit>
        <trans-unit id="3172c702cad81af002509edf932aeb8ebbddf103" translate="yes" xml:space="preserve">
          <source>The bare-bones way to start the server manually is just to invoke &lt;code&gt;postgres&lt;/code&gt; directly, specifying the location of the data directory with the &lt;code&gt;-D&lt;/code&gt; option, for example:</source>
          <target state="translated">サーバーを手動で起動するための &lt;code&gt;postgres&lt;/code&gt; 、postgresを直接呼び出し、 &lt;code&gt;-D&lt;/code&gt; オプションを使用してデータディレクトリの場所を指定することです。次に例を示します。</target>
        </trans-unit>
        <trans-unit id="010379dd868ed62184a64309858104a1ef8bdfc1" translate="yes" xml:space="preserve">
          <source>The base directory on the file system of a &lt;a href=&quot;glossary#GLOSSARY-SERVER&quot;&gt;server&lt;/a&gt; that contains all data files and subdirectories associated with a &lt;a href=&quot;glossary#GLOSSARY-DB-CLUSTER&quot;&gt;database cluster&lt;/a&gt; (with the exception of &lt;a href=&quot;glossary#GLOSSARY-TABLESPACE&quot;&gt;tablespaces&lt;/a&gt;, and optionally &lt;a href=&quot;glossary#GLOSSARY-WAL&quot;&gt;WAL&lt;/a&gt;). The environment variable &lt;code&gt;PGDATA&lt;/code&gt; is commonly used to refer to the data directory.</source>
          <target state="translated">&lt;a href=&quot;glossary#GLOSSARY-DB-CLUSTER&quot;&gt;データベースクラスターに&lt;/a&gt;関連付けられたすべてのデータファイルとサブディレクトリを含む&lt;a href=&quot;glossary#GLOSSARY-SERVER&quot;&gt;サーバーの&lt;/a&gt;ファイルシステム上のベースディレクトリ（&lt;a href=&quot;glossary#GLOSSARY-TABLESPACE&quot;&gt;テーブルスペース&lt;/a&gt;、およびオプションで&lt;a href=&quot;glossary#GLOSSARY-WAL&quot;&gt;WALを&lt;/a&gt;除く）。環境変数 &lt;code&gt;PGDATA&lt;/code&gt; は、通常、データディレクトリを参照するために使用されます。</target>
        </trans-unit>
        <trans-unit id="5658ad1f6ce193a23633c994bf8ae4b8bb4bf57e" translate="yes" xml:space="preserve">
          <source>The base name of the shared object containing the output plugin this logical slot is using, or null for physical slots.</source>
          <target state="translated">この論理スロットが使用している出力プラグインを含む共有オブジェクトのベース名。</target>
        </trans-unit>
        <trans-unit id="01f76877be594c383342f8dd0d2d641fff88c4a5" translate="yes" xml:space="preserve">
          <source>The basic idea is to copy all file system-level changes from the source cluster to the target cluster:</source>
          <target state="translated">基本的な考え方は、すべてのファイルシステムレベルの変更をソースクラスタからターゲットクラスタにコピーすることです。</target>
        </trans-unit>
        <trans-unit id="37c34616336e6db6cae77db2468a45723a3fb8d6" translate="yes" xml:space="preserve">
          <source>The basic structure used to store relation data. All pages are of the same size. Data pages are typically stored on disk, each in a specific file, and can be read to &lt;a href=&quot;glossary#GLOSSARY-SHARED-MEMORY&quot;&gt;shared buffers&lt;/a&gt; where they can be modified, becoming &lt;em&gt;dirty&lt;/em&gt;. They become clean when written to disk. New pages, which initially exist in memory only, are also dirty until written.</source>
          <target state="translated">関係データを格納するために使用される基本構造。すべてのページは同じサイズです。データページは通常、それぞれ特定のファイルのディスクに保存され、&lt;a href=&quot;glossary#GLOSSARY-SHARED-MEMORY&quot;&gt;共有バッファ&lt;/a&gt;に読み取られて変更され、&lt;em&gt;ダーティ&lt;/em&gt;になります。ディスクに書き込むときれいになります。最初はメモリにのみ存在する新しいページも、書き込まれるまでダーティです。</target>
        </trans-unit>
        <trans-unit id="19e50f37cd3ac57ef618ac5cb372c8487c7f1bd1" translate="yes" xml:space="preserve">
          <source>The basic value of &lt;code&gt;SELECT&lt;/code&gt; in &lt;code&gt;WITH&lt;/code&gt; is to break down complicated queries into simpler parts. An example is:</source>
          <target state="translated">基本値 &lt;code&gt;SELECT&lt;/code&gt; での &lt;code&gt;WITH&lt;/code&gt; は、単純な部分に複雑なクエリを打破することです。例は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="a2b5aa5c42d40515ef87930aadc0b43fe175a670" translate="yes" xml:space="preserve">
          <source>The behavior of &lt;code&gt;%&lt;/code&gt; is a bit complicated. It tries to match words rather than the entire label. For example &lt;code&gt;foo_bar%&lt;/code&gt; matches &lt;code&gt;foo_bar_baz&lt;/code&gt; but not &lt;code&gt;foo_barbaz&lt;/code&gt;. If combined with &lt;code&gt;*&lt;/code&gt;, prefix matching applies to each word separately, for example &lt;code&gt;foo_bar%*&lt;/code&gt; matches &lt;code&gt;foo1_bar2_baz&lt;/code&gt; but not &lt;code&gt;foo1_br2_baz&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;%&lt;/code&gt; の動作は少し複雑です。ラベル全体ではなく、単語を一致させようとします。たとえば、 &lt;code&gt;foo_bar%&lt;/code&gt; は &lt;code&gt;foo_barbaz&lt;/code&gt; 一致し &lt;code&gt;foo_bar_baz&lt;/code&gt; が、foo_barbazとは一致しません。 &lt;code&gt;*&lt;/code&gt; と組み合わせると、プレフィックス一致は各単語に個別に適用されます。たとえば、 &lt;code&gt;foo_bar%*&lt;/code&gt; は &lt;code&gt;foo1_br2_baz&lt;/code&gt; 一致し &lt;code&gt;foo1_bar2_baz&lt;/code&gt; が、foo1_br2_bazとは一致しません。</target>
        </trans-unit>
        <trans-unit id="1e8f85d7de8ab2c8253e41f10bbddbd7196e58ed" translate="yes" xml:space="preserve">
          <source>The behavior of a custom text search configuration can easily become confusing. The functions described in this section are useful for testing text search objects. You can test a complete configuration, or test parsers and dictionaries separately.</source>
          <target state="translated">カスタムテキスト検索設定の動作は、簡単に混乱を招く可能性があります。このセクションで説明する機能は、テキスト検索オブジェクトをテストするのに便利です。完全な構成をテストすることも、パーサと辞書を別々にテストすることもできます。</target>
        </trans-unit>
        <trans-unit id="7b27c83984e819ed5cc108965dd1a811c9d23e12" translate="yes" xml:space="preserve">
          <source>The behavior of foreign keys can be finely tuned to your application. We will not go beyond this simple example in this tutorial, but just refer you to &lt;a href=&quot;https://www.postgresql.org/docs/12/ddl.html&quot;&gt;Chapter 5&lt;/a&gt; for more information. Making correct use of foreign keys will definitely improve the quality of your database applications, so you are strongly encouraged to learn about them.</source>
          <target state="translated">外部キーの動作は、アプリケーションに合わせて微調整できます。このチュートリアルでは、この単純な例を超えることはしませんが、詳細については&lt;a href=&quot;https://www.postgresql.org/docs/12/ddl.html&quot;&gt;第5章を&lt;/a&gt;参照してください。外部キーを正しく使用すると、データベースアプリケーションの品質が確実に向上するため、それらについて学ぶことを強くお勧めします。</target>
        </trans-unit>
        <trans-unit id="3eeed7c57eb15931aa5b185d4f571a20fdfcd681" translate="yes" xml:space="preserve">
          <source>The behavior of foreign keys can be finely tuned to your application. We will not go beyond this simple example in this tutorial, but just refer you to &lt;a href=&quot;https://www.postgresql.org/docs/13/ddl.html&quot;&gt;Chapter 5&lt;/a&gt; for more information. Making correct use of foreign keys will definitely improve the quality of your database applications, so you are strongly encouraged to learn about them.</source>
          <target state="translated">外部キーの動作は、アプリケーションに合わせて微調整できます。このチュートリアルでは、この単純な例を超えることはしませんが、詳細については&lt;a href=&quot;https://www.postgresql.org/docs/13/ddl.html&quot;&gt;第5章を&lt;/a&gt;参照してください。外部キーを正しく使用すると、データベースアプリケーションの品質が確実に向上するため、外部キーについて学ぶことを強くお勧めします。</target>
        </trans-unit>
        <trans-unit id="296b0cebbabc7c8e4b2d8335b6fb9121ab843326" translate="yes" xml:space="preserve">
          <source>The behavior of temporary tables at the end of a transaction block can be controlled using &lt;code&gt;ON COMMIT&lt;/code&gt;. The three options are:</source>
          <target state="translated">トランザクションブロックの最後の一時テーブルの動作は、 &lt;code&gt;ON COMMIT&lt;/code&gt; を使用して制御できます。次の3つのオプションがあります。</target>
        </trans-unit>
        <trans-unit id="80731f14bda7a7a22a0a9014398f2bbf94eee233" translate="yes" xml:space="preserve">
          <source>The behavior of the &lt;code&gt;-t&lt;/code&gt; switch is not entirely upward compatible with pre-8.2 PostgreSQL versions. Formerly, writing &lt;code&gt;-t tab&lt;/code&gt; would dump all tables named &lt;code&gt;tab&lt;/code&gt;, but now it just dumps whichever one is visible in your default search path. To get the old behavior you can write &lt;code&gt;-t '*.tab'&lt;/code&gt;. Also, you must write something like &lt;code&gt;-t sch.tab&lt;/code&gt; to select a table in a particular schema, rather than the old locution of &lt;code&gt;-n sch -t tab&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;-t&lt;/code&gt; スイッチの動作は、8.2より前のPostgreSQLバージョンと完全に上位互換ではありません。以前は、書き込み &lt;code&gt;-t tab&lt;/code&gt; 名前のすべてのテーブルのダンプしまう &lt;code&gt;tab&lt;/code&gt; 、今ではただ一つのデフォルトの検索パスに表示されている方ダンプします。古い動作を取得するには、 &lt;code&gt;-t '*.tab'&lt;/code&gt; と記述します。また、特定のスキーマのテーブルを選択するには、 &lt;code&gt;-n sch -t tab&lt;/code&gt; の古い位置ではなく、 &lt;code&gt;-t sch.tab&lt;/code&gt; のようなものを記述する必要があります。</target>
        </trans-unit>
        <trans-unit id="6bad8faf22e7898fa3d14beb6bbfad8894c7e5cb" translate="yes" xml:space="preserve">
          <source>The behavior specified by the SQL standard is most closely approximated by giving users the &lt;code&gt;NOINHERIT&lt;/code&gt; attribute, while roles are given the &lt;code&gt;INHERIT&lt;/code&gt; attribute.</source>
          <target state="translated">SQL標準で指定されている動作は、ユーザーに &lt;code&gt;NOINHERIT&lt;/code&gt; 属性を与えることで最も厳密に近似されていますが、ロールには &lt;code&gt;INHERIT&lt;/code&gt; 属性が与えられています。</target>
        </trans-unit>
        <trans-unit id="999fc3c54ee5c4c5f6f59e07c2e8f063ee92343a" translate="yes" xml:space="preserve">
          <source>The benefits will normally be worthwhile only when a table would otherwise be very large. The exact point at which a table will benefit from partitioning depends on the application, although a rule of thumb is that the size of the table should exceed the physical memory of the database server.</source>
          <target state="translated">通常、テーブルが非常に大きくなる場合にのみ、その利点は価値があります。テーブルがパーティショニングの恩恵を受ける正確なポイントはアプリケーションによって異なりますが、経験則としては、テーブルのサイズがデータベースサーバの物理メモリを超えるべきです。</target>
        </trans-unit>
        <trans-unit id="7e72906a1cbbbaa7de5bc80e5365aa82f11074fd" translate="yes" xml:space="preserve">
          <source>The best defense against deadlocks is generally to avoid them by being certain that all applications using a database acquire locks on multiple objects in a consistent order. In the example above, if both transactions had updated the rows in the same order, no deadlock would have occurred. One should also ensure that the first lock acquired on an object in a transaction is the most restrictive mode that will be needed for that object. If it is not feasible to verify this in advance, then deadlocks can be handled on-the-fly by retrying transactions that abort due to deadlocks.</source>
          <target state="translated">デッドロックに対する最善の防御策は、一般的に、データベースを使用するすべてのアプリケーションが、一貫した順序で複数のオブジェクトのロックを取得するようにすることで、デッドロックを回避することです。上の例では、両方のトランザクションが同じ順番で行を更新していればデッドロックは発生しなかったでしょう。また、あるトランザクションでオブジェクトに対して最初に取得したロックが、そのオブジェクトに必要とされる最も制限的なモードであることを確認する必要があります。これを事前に確認することが不可能な場合は、デッドロックのために中断するトランザクションを再試行することで、その場でデッドロックを処理することができます。</target>
        </trans-unit>
        <trans-unit id="d85f73754546926f4e2d17ccb6f522601d212cb5" translate="yes" xml:space="preserve">
          <source>The best solution for high availability is to ensure you keep as many synchronous standbys as requested. This can be achieved by naming multiple potential synchronous standbys using &lt;code&gt;synchronous_standby_names&lt;/code&gt;.</source>
          <target state="translated">高可用性のための最良のソリューションは、要求された数の同期スタンバイを確保することです。これは、使用して複数の潜在的な同期スタンバイを命名することによって達成することができる &lt;code&gt;synchronous_standby_names&lt;/code&gt; を。</target>
        </trans-unit>
        <trans-unit id="e9ecf6d09480763021769b90c87994739dc69c88" translate="yes" xml:space="preserve">
          <source>The bitwise operators work only on integral data types, whereas the others are available for all numeric data types. The bitwise operators are also available for the bit string types &lt;code&gt;bit&lt;/code&gt; and &lt;code&gt;bit varying&lt;/code&gt;, as shown in &lt;a href=&quot;functions-bitstring#FUNCTIONS-BIT-STRING-OP-TABLE&quot;&gt;Table 9.14&lt;/a&gt;.</source>
          <target state="translated">ビット演算子は整数データ型でのみ機能しますが、その他はすべての数値データ型で使用できます。&lt;a href=&quot;functions-bitstring#FUNCTIONS-BIT-STRING-OP-TABLE&quot;&gt;表9.14に&lt;/a&gt;示すように、ビット演算子はビット文字列型 &lt;code&gt;bit&lt;/code&gt; および &lt;code&gt;bit varying&lt;/code&gt; にも使用できます。</target>
        </trans-unit>
        <trans-unit id="1111c2349c7453008fe438b3fef48bff0b694759" translate="yes" xml:space="preserve">
          <source>The boolean aggregates &lt;code&gt;bool_and&lt;/code&gt; and &lt;code&gt;bool_or&lt;/code&gt; correspond to the standard SQL aggregates &lt;code&gt;every&lt;/code&gt; and &lt;code&gt;any&lt;/code&gt; or &lt;code&gt;some&lt;/code&gt;. PostgreSQL supports &lt;code&gt;every&lt;/code&gt;, but not &lt;code&gt;any&lt;/code&gt; or &lt;code&gt;some&lt;/code&gt;, because there is an ambiguity built into the standard syntax:</source>
          <target state="translated">ブール集合体 &lt;code&gt;bool_and&lt;/code&gt; と &lt;code&gt;bool_or&lt;/code&gt; 標準SQLの集合体に対応し &lt;code&gt;every&lt;/code&gt; および &lt;code&gt;any&lt;/code&gt; または &lt;code&gt;some&lt;/code&gt; 。PostgreSQLはサポート &lt;code&gt;every&lt;/code&gt; ではなく、 &lt;code&gt;any&lt;/code&gt; か、 &lt;code&gt;some&lt;/code&gt; の標準的な構文には曖昧さがあるので、：</target>
        </trans-unit>
        <trans-unit id="0bb544aef82eb5e331a1c83d14ba3f14981e458a" translate="yes" xml:space="preserve">
          <source>The built-in parser is named &lt;code&gt;pg_catalog.default&lt;/code&gt;. It recognizes 23 token types, shown in &lt;a href=&quot;textsearch-parsers#TEXTSEARCH-DEFAULT-PARSER&quot;&gt;Table 12.1&lt;/a&gt;.</source>
          <target state="translated">組み込みパーサーは &lt;code&gt;pg_catalog.default&lt;/code&gt; という名前です。&lt;a href=&quot;textsearch-parsers#TEXTSEARCH-DEFAULT-PARSER&quot;&gt;表12.1&lt;/a&gt;に示すように、23のトークンタイプを認識します。</target>
        </trans-unit>
        <trans-unit id="0849997236dc34c615a4c13089f2ec08456d374b" translate="yes" xml:space="preserve">
          <source>The built-in range types &lt;code&gt;int4range&lt;/code&gt;, &lt;code&gt;int8range&lt;/code&gt;, and &lt;code&gt;daterange&lt;/code&gt; all use a canonical form that includes the lower bound and excludes the upper bound; that is, &lt;code&gt;[)&lt;/code&gt;. User-defined range types can use other conventions, however.</source>
          <target state="translated">組み込みの範囲型 &lt;code&gt;int4range&lt;/code&gt; 、 &lt;code&gt;int8range&lt;/code&gt; 、および &lt;code&gt;daterange&lt;/code&gt; はすべて、下限を含み、上限を除外する正規形式を使用します。つまり、 &lt;code&gt;[)&lt;/code&gt; です。ただし、ユーザー定義の範囲タイプは他の規則を使用できます。</target>
        </trans-unit>
        <trans-unit id="2a312305dbd3d6563e32a6d1866cf9d94a8d3583" translate="yes" xml:space="preserve">
          <source>The built-in window functions are described in &lt;a href=&quot;functions-window#FUNCTIONS-WINDOW-TABLE&quot;&gt;Table 9.60&lt;/a&gt;. Other window functions can be added by the user. Also, any built-in or user-defined general-purpose or statistical aggregate can be used as a window function. (Ordered-set and hypothetical-set aggregates cannot presently be used as window functions.)</source>
          <target state="translated">組み込みのウ​​ィンドウ関数については、&lt;a href=&quot;functions-window#FUNCTIONS-WINDOW-TABLE&quot;&gt;表9.60で&lt;/a&gt;説明します。ユーザーは他のウィンドウ機能を追加できます。また、組み込みまたはユーザー定義の汎用または統計集約をウィンドウ関数として使用できます。（現在、順序付き集合と仮説集合の集合はウィンドウ関数として使用できません。）</target>
        </trans-unit>
        <trans-unit id="1eb1519109d2d92138e97ee3336017e3e8180e57" translate="yes" xml:space="preserve">
          <source>The built-in window functions are listed in &lt;a href=&quot;functions-window#FUNCTIONS-WINDOW-TABLE&quot;&gt;Table 9.60&lt;/a&gt;. Note that these functions &lt;em&gt;must&lt;/em&gt; be invoked using window function syntax, i.e., an &lt;code&gt;OVER&lt;/code&gt; clause is required.</source>
          <target state="translated">組み込みのウ​​ィンドウ関数を&lt;a href=&quot;functions-window#FUNCTIONS-WINDOW-TABLE&quot;&gt;表9.60に示し&lt;/a&gt;ます。これらの関数&lt;em&gt;は&lt;/em&gt;ウィンドウ関数構文を使用して呼び出す&lt;em&gt;必要&lt;/em&gt;があることに注意してください。つまり、 &lt;code&gt;OVER&lt;/code&gt; 句が必要です。</target>
        </trans-unit>
        <trans-unit id="0a15741ae39e976d65eb76bd158e7ef106ba0c6d" translate="yes" xml:space="preserve">
          <source>The call handler function, the inline handler function (if any), and the validator function (if any) must already exist if the server does not have an entry for the language in &lt;code&gt;pg_pltemplate&lt;/code&gt;. But when there is an entry, the functions need not already exist; they will be automatically defined if not present in the database. (This might result in &lt;code&gt;CREATE LANGUAGE&lt;/code&gt; failing, if the shared library that implements the language is not available in the installation.)</source>
          <target state="translated">サーバーに &lt;code&gt;pg_pltemplate&lt;/code&gt; の言語のエントリがない場合、呼び出しハンドラ関数、インラインハンドラ関数（存在する場合）、およびバリデータ関数（存在する場合）はすでに存在している必要があります。ただし、エントリがある場合、関数はすでに存在している必要はありません。データベースに存在しない場合は、自動的に定義されます。（言語を実装する共有ライブラリがインストールで使用できない場合、これにより &lt;code&gt;CREATE LANGUAGE&lt;/code&gt; が失敗する可能性があります。）</target>
        </trans-unit>
        <trans-unit id="8a84995528c0ec41b02f477f2f19723fd9aad88c" translate="yes" xml:space="preserve">
          <source>The calling &lt;code&gt;SELECT&lt;/code&gt; statement doesn't necessarily have to be just &lt;code&gt;SELECT *&lt;/code&gt; &amp;mdash; it can reference the output columns by name or join them to other tables. The function produces a virtual table with which you can perform any operation you wish (e.g. aggregation, joining, sorting etc). So we could also have:</source>
          <target state="translated">呼び出し側の &lt;code&gt;SELECT&lt;/code&gt; ステートメントは必ずしも &lt;code&gt;SELECT *&lt;/code&gt; である必要はありません。名前で出力列を参照したり、他のテーブルに結合したりできます。この関数は、任意の操作（たとえば、集計、結合、並べ替えなど）を実行できる仮想テーブルを生成します。したがって、次のようにすることもできます。</target>
        </trans-unit>
        <trans-unit id="811562b4913f9796ae3f8f1999c658370788685e" translate="yes" xml:space="preserve">
          <source>The calling &lt;code&gt;SELECT&lt;/code&gt; statement doesn't necessarily have to be just &lt;code&gt;SELECT *&lt;/code&gt; &amp;mdash; it can reference the output columns by name or join them to other tables. The function produces a virtual table with which you can perform any operation you wish (e.g., aggregation, joining, sorting etc). So we could also have:</source>
          <target state="translated">呼び出し元の &lt;code&gt;SELECT&lt;/code&gt; ステートメントは必ずしも &lt;code&gt;SELECT *&lt;/code&gt; である必要はありません。名前で出力列を参照したり、他のテーブルに結合したりできます。この関数は、必要な操作（集約、結合、並べ替えなど）を実行できる仮想テーブルを生成します。したがって、次のこともできます。</target>
        </trans-unit>
        <trans-unit id="35f5d39131b77dc8ba4b8e8bbcf6ab1ac892db18" translate="yes" xml:space="preserve">
          <source>The capabilities available for administrators to monitor and control the server often change and improve in each major release.</source>
          <target state="translated">管理者がサーバを監視・制御するために利用できる機能は、メジャーリリースのたびに変更・改善されることがよくあります。</target>
        </trans-unit>
        <trans-unit id="dcba21726e373c0ef3c1310c54912c4461e260b5" translate="yes" xml:space="preserve">
          <source>The cascading replication feature allows a standby server to accept replication connections and stream WAL records to other standbys, acting as a relay. This can be used to reduce the number of direct connections to the master and also to minimize inter-site bandwidth overheads.</source>
          <target state="translated">カスケードレプリケーション機能は、スタンバイサーバーがレプリケーション接続を受け入れ、リレーのように動作して他のスタンバイサーバーにWALレコードをストリーム配信することを可能にします。これは、マスターへの直接接続数を減らし、サイト間の帯域幅オーバーヘッドを最小限に抑えるために使用できます。</target>
        </trans-unit>
        <trans-unit id="2414745d3bf9d469e38eb6deaa116aeca4c295eb" translate="yes" xml:space="preserve">
          <source>The cast functions listed in &lt;code&gt;pg_cast&lt;/code&gt; must always take the cast source type as their first argument type, and return the cast destination type as their result type. A cast function can have up to three arguments. The second argument, if present, must be type &lt;code&gt;integer&lt;/code&gt;; it receives the type modifier associated with the destination type, or -1 if there is none. The third argument, if present, must be type &lt;code&gt;boolean&lt;/code&gt;; it receives &lt;code&gt;true&lt;/code&gt; if the cast is an explicit cast, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;pg_cast&lt;/code&gt; にリストされているキャスト関数は、常に最初の引数の型としてキャストソースタイプを受け取り、結果のタイプとしてキャスト宛先タイプを返す必要があります。キャスト関数は最大3つの引数を持つことができます。 2番目の引数がある場合、それは &lt;code&gt;integer&lt;/code&gt; 型でなければなりません。宛先タイプに関連付けられたタイプ修飾子を受け取ります。存在しない場合は-1を受け取ります。 3番目の引数が存在する場合、それは &lt;code&gt;boolean&lt;/code&gt; 型でなければなりません。キャストが明示的なキャストである場合は &lt;code&gt;true&lt;/code&gt; を受け取り、それ以外の場合は &lt;code&gt;false&lt;/code&gt; を受け取ります。</target>
        </trans-unit>
        <trans-unit id="fc5f1d64f67b0574d5ae7974d9bf0296a9ac950c" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_aggregate&lt;/code&gt; stores information about aggregate functions. An aggregate function is a function that operates on a set of values (typically one column from each row that matches a query condition) and returns a single value computed from all these values. Typical aggregate functions are &lt;code&gt;sum&lt;/code&gt;, &lt;code&gt;count&lt;/code&gt;, and &lt;code&gt;max&lt;/code&gt;. Each entry in &lt;code&gt;pg_aggregate&lt;/code&gt; is an extension of an entry in &lt;code&gt;pg_proc&lt;/code&gt;. The &lt;code&gt;pg_proc&lt;/code&gt; entry carries the aggregate's name, input and output data types, and other information that is similar to ordinary functions.</source>
          <target state="translated">&lt;code&gt;pg_aggregate&lt;/code&gt; カタログは、集約関数に関する情報を格納します。集約関数は、一連の値（通常、クエリ条件に一致する各行の1つの列）を操作し、これらすべての値から計算された単一の値を返す関数です。一般的な集計関数は、 &lt;code&gt;sum&lt;/code&gt; 、 &lt;code&gt;count&lt;/code&gt; 、および &lt;code&gt;max&lt;/code&gt; です。各エントリ &lt;code&gt;pg_aggregate&lt;/code&gt; 内には、内のエントリの拡張である &lt;code&gt;pg_proc&lt;/code&gt; 。 &lt;code&gt;pg_proc&lt;/code&gt; エントリは、集合の通常の機能に似ている名前、入力および出力データタイプ、およびその他の情報を運びます。</target>
        </trans-unit>
        <trans-unit id="a29845311714d7d30ac211e7ed8230388dda9146" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_am&lt;/code&gt; stores information about relation access methods. There is one row for each access method supported by the system. Currently, only tables and indexes have access methods. The requirements for table and index access methods are discussed in detail in &lt;a href=&quot;tableam&quot;&gt;Chapter 60&lt;/a&gt; and &lt;a href=&quot;https://www.postgresql.org/docs/12/indexam.html&quot;&gt;Chapter 61&lt;/a&gt; respectively.</source>
          <target state="translated">&lt;code&gt;pg_am&lt;/code&gt; カタログはリレーションアクセスメソッドに関する情報を保存しています。システムがサポートするアクセス方式ごとに1つの行があります。現在、テーブルとインデックスのみがアクセス方法を持っています。テーブルとインデックスのアクセス方法の要件については、それぞれ&lt;a href=&quot;tableam&quot;&gt;第60 &lt;/a&gt;&lt;a href=&quot;https://www.postgresql.org/docs/12/indexam.html&quot;&gt;章&lt;/a&gt;と第61 章で詳しく説明しています。</target>
        </trans-unit>
        <trans-unit id="a660b5abad7b774d10c5ce0b5d5dff4f4fa539e0" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_am&lt;/code&gt; stores information about relation access methods. There is one row for each access method supported by the system. Currently, only tables and indexes have access methods. The requirements for table and index access methods are discussed in detail in &lt;a href=&quot;tableam&quot;&gt;Chapter 60&lt;/a&gt; and &lt;a href=&quot;https://www.postgresql.org/docs/13/indexam.html&quot;&gt;Chapter 61&lt;/a&gt; respectively.</source>
          <target state="translated">カタログ &lt;code&gt;pg_am&lt;/code&gt; には、リレーションアクセスメソッドに関する情報が格納されています。システムでサポートされているアクセス方法ごとに1つの行があります。現在、アクセス方法があるのはテーブルとインデックスのみです。テーブルとインデックスのアクセス方法の要件については、それぞれ&lt;a href=&quot;tableam&quot;&gt;第60&lt;/a&gt;&lt;a href=&quot;https://www.postgresql.org/docs/13/indexam.html&quot;&gt;章&lt;/a&gt;と第61章で詳しく説明しています。</target>
        </trans-unit>
        <trans-unit id="5bec1e44f2188ec347a755f0e3375dfd03dbafab" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_amop&lt;/code&gt; stores information about operators associated with access method operator families. There is one row for each operator that is a member of an operator family. A family member can be either a &lt;em&gt;search&lt;/em&gt; operator or an &lt;em&gt;ordering&lt;/em&gt; operator. An operator can appear in more than one family, but cannot appear in more than one search position nor more than one ordering position within a family. (It is allowed, though unlikely, for an operator to be used for both search and ordering purposes.)</source>
          <target state="translated">&lt;code&gt;pg_amop&lt;/code&gt; カタログには、アクセス方法演算子ファミリーに関連する演算子に関する情報が格納されています。オペレーター・ファミリーのメンバーであるオペレーターごとに1つの行があります。ファミリーメンバーは、&lt;em&gt;検索&lt;/em&gt;演算子または&lt;em&gt;順序付け&lt;/em&gt;演算子のいずれかになります。演算子は複数のファミリーに現れることができますが、ファミリー内の複数の検索位置または複数の順序付け位置に現れることはできません。（可能性は低いですが、演算子を検索と順序付けの両方の目的で使用することは許可されています。）</target>
        </trans-unit>
        <trans-unit id="7b26f7790ff6d1feb6dfed34e5224303ebaba082" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_amproc&lt;/code&gt; stores information about support functions associated with access method operator families. There is one row for each support function belonging to an operator family.</source>
          <target state="translated">&lt;code&gt;pg_amproc&lt;/code&gt; カタログには、アクセス方法演算子ファミリーに関連するサポート関数に関する情報が格納されています。演算子族に属するサポート関数ごとに1つの行があります。</target>
        </trans-unit>
        <trans-unit id="e1c43da8c1bc3b1aedcc6d0b4907170e6e551dad" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_attrdef&lt;/code&gt; stores column default values. The main information about columns is stored in &lt;a href=&quot;catalog-pg-attribute&quot;&gt;&lt;code&gt;pg_attribute&lt;/code&gt;&lt;/a&gt;. Only columns for which a default value has been explicitly set will have an entry here.</source>
          <target state="translated">&lt;code&gt;pg_attrdef&lt;/code&gt; カタログは列のデフォルト値を保存します。列に関する主な情報は&lt;a href=&quot;catalog-pg-attribute&quot;&gt; &lt;code&gt;pg_attribute&lt;/code&gt; に&lt;/a&gt;保存されます。ここには、デフォルト値が明示的に設定されている列のみにエントリがあります。</target>
        </trans-unit>
        <trans-unit id="418f63e0244ab894621f6561175c2bc70b572229" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_attribute&lt;/code&gt; stores information about table columns. There will be exactly one &lt;code&gt;pg_attribute&lt;/code&gt; row for every column in every table in the database. (There will also be attribute entries for indexes, and indeed all objects that have &lt;code&gt;pg_class&lt;/code&gt; entries.)</source>
          <target state="translated">&lt;code&gt;pg_attribute&lt;/code&gt; カタログはテーブルの列に関する情報を保存します。データベース内のすべてのテーブルのすべての列に対して1つの &lt;code&gt;pg_attribute&lt;/code&gt; 行があります。（インデックスの属性エントリもあり、実際に &lt;code&gt;pg_class&lt;/code&gt; エントリを持つすべてのオブジェクトがあります。）</target>
        </trans-unit>
        <trans-unit id="85bbce99b3a9fdd7e277ae10030b9970f56238bf" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_auth_members&lt;/code&gt; shows the membership relations between roles. Any non-circular set of relationships is allowed.</source>
          <target state="translated">&lt;code&gt;pg_auth_members&lt;/code&gt; カタログはロール間のメンバーシップ関係を示しています。非循環関係のセットは許可されます。</target>
        </trans-unit>
        <trans-unit id="c8154dc7e56592f09e48c6280c85b2550f6de4fa" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_authid&lt;/code&gt; contains information about database authorization identifiers (roles). A role subsumes the concepts of &amp;ldquo;users&amp;rdquo; and &amp;ldquo;groups&amp;rdquo;. A user is essentially just a role with the &lt;code&gt;rolcanlogin&lt;/code&gt; flag set. Any role (with or without &lt;code&gt;rolcanlogin&lt;/code&gt;) can have other roles as members; see &lt;a href=&quot;catalog-pg-auth-members&quot;&gt;&lt;code&gt;pg_auth_members&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;pg_authid&lt;/code&gt; カタログには、データベース認証識別子（ロール）に関する情報が含まれています。ロールは、「ユーザー」と「グループ」の概念を包括します。ユーザーは基本的に、 &lt;code&gt;rolcanlogin&lt;/code&gt; フラグが設定された単なる役割です。すべてのロール（ &lt;code&gt;rolcanlogin&lt;/code&gt; の有無にかかわらず）は、メンバーとして他のロールを持つことができます。&lt;a href=&quot;catalog-pg-auth-members&quot;&gt; &lt;code&gt;pg_auth_members&lt;/code&gt; を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="ec983a869f6c2ea34ce8826bbeff462247f967af" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_cast&lt;/code&gt; stores data type conversion paths, both built-in and user-defined.</source>
          <target state="translated">&lt;code&gt;pg_cast&lt;/code&gt; カタログは、組み込み型とユーザー定義の両方のデータ型変換パスを格納します。</target>
        </trans-unit>
        <trans-unit id="9d04631bf68325b8525e49c943e731abe3613af7" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_class&lt;/code&gt; catalogs tables and most everything else that has columns or is otherwise similar to a table. This includes indexes (but see also &lt;code&gt;pg_index&lt;/code&gt;), sequences (but see also &lt;code&gt;pg_sequence&lt;/code&gt;), views, materialized views, composite types, and TOAST tables; see &lt;code&gt;relkind&lt;/code&gt;. Below, when we mean all of these kinds of objects we speak of &amp;ldquo;relations&amp;rdquo;. Not all columns are meaningful for all relation types.</source>
          <target state="translated">カタログ &lt;code&gt;pg_class&lt;/code&gt; カタログ表および列を持っているか、テーブルとそれ以外似ている他のほとんどすべてのもの。これには、インデックス（ &lt;code&gt;pg_index&lt;/code&gt; も参照）、シーケンス（ &lt;code&gt;pg_sequence&lt;/code&gt; も参照）、ビュー、マテリアライズドビュー、複合型、およびTOASTテーブルが含まれます。 &lt;code&gt;relkind&lt;/code&gt; を参照してください。以下では、これらすべての種類のオブジェクトを意味する場合、「関係」について説明します。すべての列がすべての関係タイプにとって意味があるわけではありません。</target>
        </trans-unit>
        <trans-unit id="ce60dbecc80ee8b02722d2865bea98e5166433a6" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_collation&lt;/code&gt; describes the available collations, which are essentially mappings from an SQL name to operating system locale categories. See &lt;a href=&quot;collation&quot;&gt;Section 23.2&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;pg_collation&lt;/code&gt; カタログは利用可能な照合を説明しています。これは基本的にSQL名からオペレーティングシステムのロケールカテゴリへのマッピングです。詳細は&lt;a href=&quot;collation&quot;&gt;項23.2&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="b24facc60ba613b096ec1ffd9828eff85b641f58" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_constraint&lt;/code&gt; stores check, primary key, unique, foreign key, and exclusion constraints on tables. (Column constraints are not treated specially. Every column constraint is equivalent to some table constraint.) Not-null constraints are represented in the &lt;code&gt;pg_attribute&lt;/code&gt; catalog, not here.</source>
          <target state="translated">&lt;code&gt;pg_constraint&lt;/code&gt; カタログはチェック、主キー、一意、外部キー、およびテーブルの除外制約を保存します。（列制約は特別に扱われません。すべての列制約はいくつかのテーブル制約と同等です。）非null制約は、ここではなく &lt;code&gt;pg_attribute&lt;/code&gt; カタログで表されます。</target>
        </trans-unit>
        <trans-unit id="b1be34b922edf24e062d7f1ae068ab828f281a75" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_conversion&lt;/code&gt; describes encoding conversion functions. See &lt;a href=&quot;sql-createconversion&quot;&gt;CREATE CONVERSION&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;pg_conversion&lt;/code&gt; カタログはエンコーディング変換関数を説明しています。詳細については、&lt;a href=&quot;sql-createconversion&quot;&gt;CREATE CONVERSION&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="7fa266de7304c33b5491fba7214040981ff64d51" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_database&lt;/code&gt; stores information about the available databases. Databases are created with the &lt;a href=&quot;sql-createdatabase&quot;&gt;CREATE DATABASE&lt;/a&gt; command. Consult &lt;a href=&quot;https://www.postgresql.org/docs/12/managing-databases.html&quot;&gt;Chapter 22&lt;/a&gt; for details about the meaning of some of the parameters.</source>
          <target state="translated">&lt;code&gt;pg_database&lt;/code&gt; カタログには、利用可能なデータベースに関する情報が格納されています。データベースは&lt;a href=&quot;sql-createdatabase&quot;&gt;CREATE DATABASE&lt;/a&gt;コマンドで作成されます。相談する&lt;a href=&quot;https://www.postgresql.org/docs/12/managing-databases.html&quot;&gt;第22章を&lt;/a&gt;いくつかのパラメータの詳細については。</target>
        </trans-unit>
        <trans-unit id="f49685a729552e79238070db8b64c8366090dda2" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_database&lt;/code&gt; stores information about the available databases. Databases are created with the &lt;a href=&quot;sql-createdatabase&quot;&gt;CREATE DATABASE&lt;/a&gt; command. Consult &lt;a href=&quot;https://www.postgresql.org/docs/13/managing-databases.html&quot;&gt;Chapter 22&lt;/a&gt; for details about the meaning of some of the parameters.</source>
          <target state="translated">カタログ &lt;code&gt;pg_database&lt;/code&gt; には、使用可能なデータベースに関する情報が格納されています。データベースは、&lt;a href=&quot;sql-createdatabase&quot;&gt;CREATEDATABASE&lt;/a&gt;コマンドで作成されます。相談する&lt;a href=&quot;https://www.postgresql.org/docs/13/managing-databases.html&quot;&gt;第22章を&lt;/a&gt;いくつかのパラメータの詳細については。</target>
        </trans-unit>
        <trans-unit id="0eca146c013dcb962be7fbc89316ecc63d19d2b8" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_db_role_setting&lt;/code&gt; records the default values that have been set for run-time configuration variables, for each role and database combination.</source>
          <target state="translated">&lt;code&gt;pg_db_role_setting&lt;/code&gt; カタログは、ロールとデータベースの組み合わせごとに、ランタイム構成変数に設定されているデフォルト値を記録します。</target>
        </trans-unit>
        <trans-unit id="e6bd2b6528e4d970391e533c9ea2086c3fe18fc0" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_default_acl&lt;/code&gt; stores initial privileges to be assigned to newly created objects.</source>
          <target state="translated">&lt;code&gt;pg_default_acl&lt;/code&gt; カタログは、新しく作成されたオブジェクトに割り当てられる初期権限を保存します。</target>
        </trans-unit>
        <trans-unit id="fa08d6f7153471b38ae0793d338ba6ab5b3ad0bd" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_depend&lt;/code&gt; records the dependency relationships between database objects. This information allows &lt;code&gt;DROP&lt;/code&gt; commands to find which other objects must be dropped by &lt;code&gt;DROP CASCADE&lt;/code&gt; or prevent dropping in the &lt;code&gt;DROP RESTRICT&lt;/code&gt; case.</source>
          <target state="translated">&lt;code&gt;pg_depend&lt;/code&gt; カタログはデータベースオブジェクト間の依存関係を記録しています。この情報により、 &lt;code&gt;DROP&lt;/code&gt; コマンドは、 &lt;code&gt;DROP CASCADE&lt;/code&gt; によってドロップする必要がある他のオブジェクトを検出したり、 &lt;code&gt;DROP RESTRICT&lt;/code&gt; の場合にドロップを防止したりできます。</target>
        </trans-unit>
        <trans-unit id="ef59984dd4696772f2e8a7bbf2dcc9de1f2f041a" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_description&lt;/code&gt; stores optional descriptions (comments) for each database object. Descriptions can be manipulated with the &lt;a href=&quot;sql-comment&quot;&gt;COMMENT&lt;/a&gt; command and viewed with psql's &lt;code&gt;\d&lt;/code&gt; commands. Descriptions of many built-in system objects are provided in the initial contents of &lt;code&gt;pg_description&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pg_description&lt;/code&gt; カタログは、各データベースオブジェクトのオプションの説明（コメント）を格納します。説明は&lt;a href=&quot;sql-comment&quot;&gt;COMMENT&lt;/a&gt;コマンドで操作でき、psqlの &lt;code&gt;\d&lt;/code&gt; コマンドで表示できます。多くの組み込みシステムオブジェクトの説明は、 &lt;code&gt;pg_description&lt;/code&gt; の最初のコンテンツで提供されています。</target>
        </trans-unit>
        <trans-unit id="9f9198ecc665eb9bf0a1925898c8388b6df71db7" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_event_trigger&lt;/code&gt; stores event triggers. See &lt;a href=&quot;https://www.postgresql.org/docs/12/event-triggers.html&quot;&gt;Chapter 39&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;pg_event_trigger&lt;/code&gt; カタログはイベントトリガーを保存します。詳細については、&lt;a href=&quot;https://www.postgresql.org/docs/12/event-triggers.html&quot;&gt;第39章を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="5ae659e278f2c6f623d87b5b040902fb8aebc1a0" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_event_trigger&lt;/code&gt; stores event triggers. See &lt;a href=&quot;https://www.postgresql.org/docs/13/event-triggers.html&quot;&gt;Chapter 39&lt;/a&gt; for more information.</source>
          <target state="translated">カタログ &lt;code&gt;pg_event_trigger&lt;/code&gt; は、イベントトリガーを格納します。詳細については、&lt;a href=&quot;https://www.postgresql.org/docs/13/event-triggers.html&quot;&gt;第39章を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="08e240a6b04efec03e383c5c2cbf6a0f5343f115" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_extension&lt;/code&gt; stores information about the installed extensions. See &lt;a href=&quot;https://www.postgresql.org/docs/12/extend-extensions.html&quot;&gt;Section 37.17&lt;/a&gt; for details about extensions.</source>
          <target state="translated">&lt;code&gt;pg_extension&lt;/code&gt; カタログには、インストールされている拡張機能に関する情報が格納されています。参照&lt;a href=&quot;https://www.postgresql.org/docs/12/extend-extensions.html&quot;&gt;セクション37.17を&lt;/a&gt;拡張の詳細については。</target>
        </trans-unit>
        <trans-unit id="9a6bd669eb72e3c7fbbe3af8a149088d554d60d9" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_extension&lt;/code&gt; stores information about the installed extensions. See &lt;a href=&quot;https://www.postgresql.org/docs/13/extend-extensions.html&quot;&gt;Section 37.17&lt;/a&gt; for details about extensions.</source>
          <target state="translated">カタログ &lt;code&gt;pg_extension&lt;/code&gt; には、インストールされている拡張機能に関する情報が格納されています。参照&lt;a href=&quot;https://www.postgresql.org/docs/13/extend-extensions.html&quot;&gt;セクション37.17を&lt;/a&gt;拡張の詳細については。</target>
        </trans-unit>
        <trans-unit id="60ec179e1854cef6ef5b48336a3d0be1aebd94a3" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_foreign_data_wrapper&lt;/code&gt; stores foreign-data wrapper definitions. A foreign-data wrapper is the mechanism by which external data, residing on foreign servers, is accessed.</source>
          <target state="translated">&lt;code&gt;pg_foreign_data_wrapper&lt;/code&gt; カタログは外部データラッパー定義を保存します。外部データラッパーは、外部サーバーにある外部データにアクセスするメカニズムです。</target>
        </trans-unit>
        <trans-unit id="14e59b5f4fd68c0de1f4d9757cb9140d56e66bca" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_foreign_server&lt;/code&gt; stores foreign server definitions. A foreign server describes a source of external data, such as a remote server. Foreign servers are accessed via foreign-data wrappers.</source>
          <target state="translated">&lt;code&gt;pg_foreign_server&lt;/code&gt; カタログは外部サーバー定義を保存します。外部サーバーは、リモートサーバーなどの外部データのソースを表します。外部サーバーは外部データラッパーを介してアクセスされます。</target>
        </trans-unit>
        <trans-unit id="51d82ed7d4c3db5d6e6e20d733bd83d0fb2db31f" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_foreign_table&lt;/code&gt; contains auxiliary information about foreign tables. A foreign table is primarily represented by a &lt;code&gt;pg_class&lt;/code&gt; entry, just like a regular table. Its &lt;code&gt;pg_foreign_table&lt;/code&gt; entry contains the information that is pertinent only to foreign tables and not any other kind of relation.</source>
          <target state="translated">&lt;code&gt;pg_foreign_table&lt;/code&gt; カタログには、外部テーブルに関する補助情報が含まれています。外部テーブルは、通常のテーブルと同様に、主に &lt;code&gt;pg_class&lt;/code&gt; エントリによって表されます。その &lt;code&gt;pg_foreign_table&lt;/code&gt; エントリには、他の種類の関係ではなく、外部テーブルにのみ関連する情報が含まれています。</target>
        </trans-unit>
        <trans-unit id="775fb259c9b9e32be3ed5d81afd596a58bfd39dd" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_index&lt;/code&gt; contains part of the information about indexes. The rest is mostly in &lt;code&gt;pg_class&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pg_index&lt;/code&gt; カタログには、インデックスに関する情報の一部が含まれています。残りは主に &lt;code&gt;pg_class&lt;/code&gt; にあります。</target>
        </trans-unit>
        <trans-unit id="be9fa6ee074572af10ef89fb86dd033d0a67087f" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_inherits&lt;/code&gt; records information about table and index inheritance hierarchies. There is one entry for each direct parent-child table or index relationship in the database. (Indirect inheritance can be determined by following chains of entries.)</source>
          <target state="translated">カタログ &lt;code&gt;pg_inherits&lt;/code&gt; は、テーブルとインデックスの継承階層に関する情報を記録します。データベース内の直接の親子テーブルまたはインデックス関係ごとに1つのエントリがあります。（間接継承は、エントリのチェーンをたどることによって決定できます。）</target>
        </trans-unit>
        <trans-unit id="3a623a0b18b2ebaf8e83d5ac1d0d6cf3474af033" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_inherits&lt;/code&gt; records information about table inheritance hierarchies. There is one entry for each direct parent-child table relationship in the database. (Indirect inheritance can be determined by following chains of entries.)</source>
          <target state="translated">&lt;code&gt;pg_inherits&lt;/code&gt; カタログは、テーブルの継承階層に関する情報を記録しています。データベース内の直接の親子テーブルの関係ごとに1つのエントリがあります。（間接継承は、エントリのチェーンをたどることによって決定できます。）</target>
        </trans-unit>
        <trans-unit id="3ef3657b35ed0b4f238ec5987d2edc24285c1ce6" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_init_privs&lt;/code&gt; records information about the initial privileges of objects in the system. There is one entry for each object in the database which has a non-default (non-NULL) initial set of privileges.</source>
          <target state="translated">&lt;code&gt;pg_init_privs&lt;/code&gt; カタログは、システム内のオブジェクトの初期特権に関する情報を記録しています。データベース内の各オブジェクトには、デフォルト以外（NULL以外）の初期特権セットを持つ1つのエントリがあります。</target>
        </trans-unit>
        <trans-unit id="aed131707c511022c9597a108a69123aaaa06b71" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_language&lt;/code&gt; registers languages in which you can write functions or stored procedures. See &lt;a href=&quot;sql-createlanguage&quot;&gt;CREATE LANGUAGE&lt;/a&gt; and &lt;a href=&quot;https://www.postgresql.org/docs/12/xplang.html&quot;&gt;Chapter 41&lt;/a&gt; for more information about language handlers.</source>
          <target state="translated">&lt;code&gt;pg_language&lt;/code&gt; カタログは、関数またはストアドプロシージャを記述できる言語を登録します。言語ハンドラの詳細については、&lt;a href=&quot;sql-createlanguage&quot;&gt;CREATE LANGUAGE&lt;/a&gt;および&lt;a href=&quot;https://www.postgresql.org/docs/12/xplang.html&quot;&gt;第41章を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="3dbfd44a82e6b207a606d4410b4069adc945e68c" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_language&lt;/code&gt; registers languages in which you can write functions or stored procedures. See &lt;a href=&quot;sql-createlanguage&quot;&gt;CREATE LANGUAGE&lt;/a&gt; and &lt;a href=&quot;https://www.postgresql.org/docs/13/xplang.html&quot;&gt;Chapter 41&lt;/a&gt; for more information about language handlers.</source>
          <target state="translated">カタログ &lt;code&gt;pg_language&lt;/code&gt; は、関数またはストアドプロシージャを記述できる言語を登録します。言語ハンドラーの詳細は、&lt;a href=&quot;sql-createlanguage&quot;&gt;CREATELANGUAGE&lt;/a&gt;および&lt;a href=&quot;https://www.postgresql.org/docs/13/xplang.html&quot;&gt;第41章を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="bc853ae6dcab566bb8d51b6c3df6a48ca149be41" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_largeobject&lt;/code&gt; holds the data making up &amp;ldquo;large objects&amp;rdquo;. A large object is identified by an OID assigned when it is created. Each large object is broken into segments or &amp;ldquo;pages&amp;rdquo; small enough to be conveniently stored as rows in &lt;code&gt;pg_largeobject&lt;/code&gt;. The amount of data per page is defined to be &lt;code&gt;LOBLKSIZE&lt;/code&gt; (which is currently &lt;code&gt;BLCKSZ/4&lt;/code&gt;, or typically 2 kB).</source>
          <target state="translated">カタログ &lt;code&gt;pg_largeobject&lt;/code&gt; は「ラージオブジェクト」を構成するデータを保持しています。ラージオブジェクトは、作成時に割り当てられたOIDによって識別されます。各ラージオブジェクトは、 &lt;code&gt;pg_largeobject&lt;/code&gt; の行として便利に格納できるほど小さいセグメントまたは「ページ」に分割されます。ページあたりのデータ量は、 &lt;code&gt;LOBLKSIZE&lt;/code&gt; （現在は &lt;code&gt;BLCKSZ/4&lt;/code&gt; 、または通常は2 kB）と定義されています。</target>
        </trans-unit>
        <trans-unit id="637a0fff02f805fcd7f6572b41b759dc3d88c524" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_largeobject_metadata&lt;/code&gt; holds metadata associated with large objects. The actual large object data is stored in &lt;a href=&quot;catalog-pg-largeobject&quot;&gt;&lt;code&gt;pg_largeobject&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">カタログ &lt;code&gt;pg_largeobject_metadata&lt;/code&gt; は、ラージオブジェクトに関連するメタデータを保持しています。実際のラージオブジェクトデータは&lt;a href=&quot;catalog-pg-largeobject&quot;&gt; &lt;code&gt;pg_largeobject&lt;/code&gt; に&lt;/a&gt;格納されます。</target>
        </trans-unit>
        <trans-unit id="1da9fb341c1eb2b89353bf65057bd43bdb97a022" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_namespace&lt;/code&gt; stores namespaces. A namespace is the structure underlying SQL schemas: each namespace can have a separate collection of relations, types, etc. without name conflicts.</source>
          <target state="translated">&lt;code&gt;pg_namespace&lt;/code&gt; カタログは名前空間を保存します。ネームスペースは、SQLスキーマの基礎となる構造です。各ネームスペースは、名前の競合なしに、関係、タイプなどの個別のコレクションを持つことができます。</target>
        </trans-unit>
        <trans-unit id="85e7a372d092106d4f08f9fcd3ea02828fcaa191" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_opclass&lt;/code&gt; defines index access method operator classes. Each operator class defines semantics for index columns of a particular data type and a particular index access method. An operator class essentially specifies that a particular operator family is applicable to a particular indexable column data type. The set of operators from the family that are actually usable with the indexed column are whichever ones accept the column's data type as their left-hand input.</source>
          <target state="translated">&lt;code&gt;pg_opclass&lt;/code&gt; カタログはインデックスアクセスメソッド演算子クラスを定義しています。各演算子クラスは、特定のデータ型のインデックス列と特定のインデックスアクセスメソッドのセマンティクスを定義します。演算子クラスは基本的に、特定の演算子ファミリーが特定のインデックス可能な列のデータ型に適用可能であることを指定します。インデックス付きの列で実際に使用できるファミリの演算子のセットは、左側の入力として列のデータ型を受け入れる演算子です。</target>
        </trans-unit>
        <trans-unit id="c87fca68633fb63db57e86d79fac7ce1b22101ea" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_operator&lt;/code&gt; stores information about operators. See &lt;a href=&quot;sql-createoperator&quot;&gt;CREATE OPERATOR&lt;/a&gt; and &lt;a href=&quot;https://www.postgresql.org/docs/12/xoper.html&quot;&gt;Section 37.14&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;pg_operator&lt;/code&gt; カタログはオペレーターに関する情報を保存します。詳細については、&lt;a href=&quot;sql-createoperator&quot;&gt;CREATE OPERATOR&lt;/a&gt;および&lt;a href=&quot;https://www.postgresql.org/docs/12/xoper.html&quot;&gt;セクション37.14&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="db699f37242b8105097dbca69774e5077ef97a6f" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_operator&lt;/code&gt; stores information about operators. See &lt;a href=&quot;sql-createoperator&quot;&gt;CREATE OPERATOR&lt;/a&gt; and &lt;a href=&quot;https://www.postgresql.org/docs/13/xoper.html&quot;&gt;Section 37.14&lt;/a&gt; for more information.</source>
          <target state="translated">カタログ &lt;code&gt;pg_operator&lt;/code&gt; には、演算子に関する情報が格納されています。参照&lt;a href=&quot;sql-createoperator&quot;&gt;OPERATOR CREATE&lt;/a&gt;および&lt;a href=&quot;https://www.postgresql.org/docs/13/xoper.html&quot;&gt;セクション37.14を&lt;/a&gt;詳細については。</target>
        </trans-unit>
        <trans-unit id="ae3fdeed75aa3ce97ce3c38ef12f91f3c508c158" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_opfamily&lt;/code&gt; defines operator families. Each operator family is a collection of operators and associated support routines that implement the semantics specified for a particular index access method. Furthermore, the operators in a family are all &amp;ldquo;compatible&amp;rdquo;, in a way that is specified by the access method. The operator family concept allows cross-data-type operators to be used with indexes and to be reasoned about using knowledge of access method semantics.</source>
          <target state="translated">&lt;code&gt;pg_opfamily&lt;/code&gt; カタログはオペレーターファミリーを定義します。各演算子ファミリは、特定のインデックスアクセスメソッドに指定されたセマンティクスを実装する演算子と関連するサポートルーチンのコレクションです。さらに、ファミリー内のオペレーターは、アクセス方法で指定されているように、すべて「互換性」があります。演算子族の概念により、クロスデータタイプの演算子をインデックスで使用し、アクセス方法のセマンティクスの知識を使用することを推論することができます。</target>
        </trans-unit>
        <trans-unit id="9f9d81d5db57fdf3722685cee5c72c0b7b266b01" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_partitioned_table&lt;/code&gt; stores information about how tables are partitioned.</source>
          <target state="translated">&lt;code&gt;pg_partitioned_table&lt;/code&gt; カタログはテーブルがどのように分割されるかについての情報を保存します。</target>
        </trans-unit>
        <trans-unit id="c4598dc8a02ea46018473ad3a155097abd3c7904" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_pltemplate&lt;/code&gt; stores &amp;ldquo;template&amp;rdquo; information for procedural languages. A template for a language allows the language to be created in a particular database by a simple &lt;code&gt;CREATE LANGUAGE&lt;/code&gt; command, with no need to specify implementation details.</source>
          <target state="translated">&lt;code&gt;pg_pltemplate&lt;/code&gt; カタログには、手続き型言語の「テンプレート」情報が格納されています。言語のテンプレートを使用すると、実装の詳細を指定する必要なく、単純な &lt;code&gt;CREATE LANGUAGE&lt;/code&gt; コマンドで特定のデータベースに言語を作成できます。</target>
        </trans-unit>
        <trans-unit id="38521eab8f4daa25e1c972502335611e746aa47f" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_policy&lt;/code&gt; stores row level security policies for tables. A policy includes the kind of command that it applies to (possibly all commands), the roles that it applies to, the expression to be added as a security-barrier qualification to queries that include the table, and the expression to be added as a &lt;code&gt;WITH CHECK&lt;/code&gt; option for queries that attempt to add new records to the table.</source>
          <target state="translated">&lt;code&gt;pg_policy&lt;/code&gt; カタログはテーブルの行レベルのセキュリティポリシーを保存します。ポリシーには、適用されるコマンドの種類（場合によってはすべてのコマンド）、適用されるロール、テーブルを含むクエリにセキュリティバリア資格として追加される式、および追加される式が含まれます新しいレコードをテーブルに追加しようとするクエリの &lt;code&gt;WITH CHECK&lt;/code&gt; オプション。</target>
        </trans-unit>
        <trans-unit id="077da08d3639d4de1fea458f7cc6d9c77756beb9" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_proc&lt;/code&gt; stores information about functions, procedures, aggregate functions, and window functions (collectively also known as routines). See &lt;a href=&quot;sql-createfunction&quot;&gt;CREATE FUNCTION&lt;/a&gt;, &lt;a href=&quot;sql-createprocedure&quot;&gt;CREATE PROCEDURE&lt;/a&gt;, and &lt;a href=&quot;https://www.postgresql.org/docs/12/xfunc.html&quot;&gt;Section 37.3&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;pg_proc&lt;/code&gt; カタログは、関数、プロシージャ、集約関数、ウィンドウ関数（まとめてルーチンとも呼ばれます）に関する情報を格納します。詳細は、「&lt;a href=&quot;sql-createfunction&quot;&gt;CREATE FUNCTION」&lt;/a&gt;、「&lt;a href=&quot;sql-createprocedure&quot;&gt;CREATE PROCEDURE」&lt;/a&gt;、および&lt;a href=&quot;https://www.postgresql.org/docs/12/xfunc.html&quot;&gt;セクション37.3&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="9e11644222b2201539ac16dfa7848782b7baf235" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_proc&lt;/code&gt; stores information about functions, procedures, aggregate functions, and window functions (collectively also known as routines). See &lt;a href=&quot;sql-createfunction&quot;&gt;CREATE FUNCTION&lt;/a&gt;, &lt;a href=&quot;sql-createprocedure&quot;&gt;CREATE PROCEDURE&lt;/a&gt;, and &lt;a href=&quot;https://www.postgresql.org/docs/13/xfunc.html&quot;&gt;Section 37.3&lt;/a&gt; for more information.</source>
          <target state="translated">カタログ &lt;code&gt;pg_proc&lt;/code&gt; には、関数、プロシージャ、集計関数、およびウィンドウ関数（総称してルーチンとも呼ばれます）に関する情報が格納されています。詳細については、&lt;a href=&quot;sql-createfunction&quot;&gt;CREATE FUNCTION&lt;/a&gt;、&lt;a href=&quot;sql-createprocedure&quot;&gt;CREATE PROCEDURE&lt;/a&gt;、および&lt;a href=&quot;https://www.postgresql.org/docs/13/xfunc.html&quot;&gt;セクション37.3&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="0bfdad63a7f3f3f55487cbe48d50b5126f2fe14c" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_publication&lt;/code&gt; contains all publications created in the database. For more on publications see &lt;a href=&quot;logical-replication-publication&quot;&gt;Section 30.1&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;pg_publication&lt;/code&gt; カタログには、データベースで作成されたすべてのパブリケーションが含まれています。出版物の詳細については、&lt;a href=&quot;logical-replication-publication&quot;&gt;セクション30.1を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="b073514e28d8a7dd7d94b64ba581679b1b8073f2" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_publication_rel&lt;/code&gt; contains the mapping between relations and publications in the database. This is a many-to-many mapping. See also &lt;a href=&quot;view-pg-publication-tables&quot;&gt;Section 51.78&lt;/a&gt; for a more user-friendly view of this information.</source>
          <target state="translated">カタログ &lt;code&gt;pg_publication_rel&lt;/code&gt; には、データベース内のリレーションとパブリケーション間のマッピングが含まれています。これは多対多のマッピングです。この情報のよりユーザーフレンドリーなビューについては、&lt;a href=&quot;view-pg-publication-tables&quot;&gt;セクション51.78&lt;/a&gt;も参照してください。</target>
        </trans-unit>
        <trans-unit id="221d9ab9d81b22114af5be8f658f635812a98821" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_publication_rel&lt;/code&gt; contains the mapping between relations and publications in the database. This is a many-to-many mapping. See also &lt;a href=&quot;view-pg-publication-tables&quot;&gt;Section 51.79&lt;/a&gt; for a more user-friendly view of this information.</source>
          <target state="translated">カタログ &lt;code&gt;pg_publication_rel&lt;/code&gt; には、データベース内の関係とパブリケーション間のマッピングが含まれています。これは多対多のマッピングです。この情報のより&lt;a href=&quot;view-pg-publication-tables&quot;&gt;わかり&lt;/a&gt;やすいビューについては、セクション51.79も参照してください。</target>
        </trans-unit>
        <trans-unit id="52875f38f647bef6fb760c4d6882bec8ce49439c" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_range&lt;/code&gt; stores information about range types. This is in addition to the types' entries in &lt;a href=&quot;catalog-pg-type&quot;&gt;&lt;code&gt;pg_type&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;pg_range&lt;/code&gt; カタログは範囲タイプに関する情報を保存します。これは&lt;a href=&quot;catalog-pg-type&quot;&gt; &lt;code&gt;pg_type&lt;/code&gt; の&lt;/a&gt;タイプのエントリに追加されます。</target>
        </trans-unit>
        <trans-unit id="cc31d507f60721e880a15f8324203d061317541c" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_rewrite&lt;/code&gt; stores rewrite rules for tables and views.</source>
          <target state="translated">&lt;code&gt;pg_rewrite&lt;/code&gt; カタログはテーブルとビューの書き換えルールを保存します。</target>
        </trans-unit>
        <trans-unit id="2bbefd7f86634f56307ee5fef9c894c5719937d5" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_seclabel&lt;/code&gt; stores security labels on database objects. Security labels can be manipulated with the &lt;a href=&quot;sql-security-label&quot;&gt;SECURITY LABEL&lt;/a&gt; command. For an easier way to view security labels, see &lt;a href=&quot;view-pg-seclabels&quot;&gt;Section 51.83&lt;/a&gt;.</source>
          <target state="translated">カタログ &lt;code&gt;pg_seclabel&lt;/code&gt; は、データベースオブジェクトのセキュリティラベルを格納します。セキュリティラベルは、&lt;a href=&quot;sql-security-label&quot;&gt;SECURITYLABEL&lt;/a&gt;コマンドで操作できます。セキュリティラベルを表示する簡単な方法については、&lt;a href=&quot;view-pg-seclabels&quot;&gt;セクション51.83を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="743cf387d8af7cd433c0ab8fa075de457723d7d5" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_seclabel&lt;/code&gt; stores security labels on database objects. Security labels can be manipulated with the &lt;a href=&quot;sql-security-label&quot;&gt;SECURITY LABEL&lt;/a&gt; command. For an easier way to view security labels, see &lt;a href=&quot;view-pg-seclabels&quot;&gt;Section 51.84&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;pg_seclabel&lt;/code&gt; カタログはデータベースオブジェクトのセキュリティラベルを保存します。セキュリティラベルは、&lt;a href=&quot;sql-security-label&quot;&gt;SECURITY LABEL&lt;/a&gt;コマンドで操作できます。セキュリティラベルを表示する簡単な方法については、&lt;a href=&quot;view-pg-seclabels&quot;&gt;セクション51.84を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="06336f290aa5f875fbaac3ca8b83cb8674898645" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_sequence&lt;/code&gt; contains information about sequences. Some of the information about sequences, such as the name and the schema, is in &lt;code&gt;pg_class&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pg_sequence&lt;/code&gt; カタログには、シーケンスに関する情報が含まれています。名前やスキーマなど、シーケンスに関する情報の一部は &lt;code&gt;pg_class&lt;/code&gt; にあります。</target>
        </trans-unit>
        <trans-unit id="98aafe9d92bd83fff00a553e40adb49ebd9fb0ff" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_shdepend&lt;/code&gt; records the dependency relationships between database objects and shared objects, such as roles. This information allows PostgreSQL to ensure that those objects are unreferenced before attempting to delete them.</source>
          <target state="translated">カタログ &lt;code&gt;pg_shdepend&lt;/code&gt; は、データベースオブジェクトとロールなどの共有オブジェクト間の依存関係を記録します。この情報により、PostgreSQLは、それらのオブジェクトを削除する前に、それらのオブジェクトが参照されていないことを確認できます。</target>
        </trans-unit>
        <trans-unit id="707a904a0a65e47118a70277c90bf66e00682ea7" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_shdescription&lt;/code&gt; stores optional descriptions (comments) for shared database objects. Descriptions can be manipulated with the &lt;a href=&quot;sql-comment&quot;&gt;COMMENT&lt;/a&gt; command and viewed with psql's &lt;code&gt;\d&lt;/code&gt; commands.</source>
          <target state="translated">&lt;code&gt;pg_shdescription&lt;/code&gt; カタログは、共有データベースオブジェクトのオプションの説明（コメント）を格納します。説明は&lt;a href=&quot;sql-comment&quot;&gt;COMMENT&lt;/a&gt;コマンドで操作でき、psqlの &lt;code&gt;\d&lt;/code&gt; コマンドで表示できます。</target>
        </trans-unit>
        <trans-unit id="108e726e137da0b8ec8293c84d0b89131f7f1510" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_shseclabel&lt;/code&gt; stores security labels on shared database objects. Security labels can be manipulated with the &lt;a href=&quot;sql-security-label&quot;&gt;SECURITY LABEL&lt;/a&gt; command. For an easier way to view security labels, see &lt;a href=&quot;view-pg-seclabels&quot;&gt;Section 51.83&lt;/a&gt;.</source>
          <target state="translated">カタログ &lt;code&gt;pg_shseclabel&lt;/code&gt; は、共有データベースオブジェクトのセキュリティラベルを格納します。セキュリティラベルは、&lt;a href=&quot;sql-security-label&quot;&gt;SECURITYLABEL&lt;/a&gt;コマンドで操作できます。セキュリティラベルを表示する簡単な方法については、&lt;a href=&quot;view-pg-seclabels&quot;&gt;セクション51.83を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="bb1cad576af7b20a74691e7e84a0abf3918f82ca" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_shseclabel&lt;/code&gt; stores security labels on shared database objects. Security labels can be manipulated with the &lt;a href=&quot;sql-security-label&quot;&gt;SECURITY LABEL&lt;/a&gt; command. For an easier way to view security labels, see &lt;a href=&quot;view-pg-seclabels&quot;&gt;Section 51.84&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;pg_shseclabel&lt;/code&gt; カタログは、共有データベースオブジェクトのセキュリティラベルを格納します。セキュリティラベルは、&lt;a href=&quot;sql-security-label&quot;&gt;SECURITY LABEL&lt;/a&gt;コマンドで操作できます。セキュリティラベルを表示する簡単な方法については、&lt;a href=&quot;view-pg-seclabels&quot;&gt;セクション51.84を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="d95048be51e3aac388b17358a36c3017066f7afd" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_statistic&lt;/code&gt; stores statistical data about the contents of the database. Entries are created by &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt; and subsequently used by the query planner. Note that all the statistical data is inherently approximate, even assuming that it is up-to-date.</source>
          <target state="translated">&lt;code&gt;pg_statistic&lt;/code&gt; カタログには、データベースの内容に関する統計データが格納されています。エントリは&lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt;によって作成され、その後クエリプランナーによって使用されます。すべての統計データは、それが最新であると仮定しても、本質的に概算であることに注意してください。</target>
        </trans-unit>
        <trans-unit id="1a788b199242747f1e3ab3d464f7f212c88021b3" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_statistic_ext&lt;/code&gt; holds definitions of extended planner statistics. Each row in this catalog corresponds to a &lt;em&gt;statistics object&lt;/em&gt; created with &lt;a href=&quot;sql-createstatistics&quot;&gt;CREATE STATISTICS&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;pg_statistic_ext&lt;/code&gt; カタログは拡張プランナー統計の定義を保持しています。このカタログの各行は、&lt;a href=&quot;sql-createstatistics&quot;&gt;CREATE STATISTICSで&lt;/a&gt;作成された&lt;em&gt;統計オブジェクトに&lt;/em&gt;対応してい&lt;em&gt;ます&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="efd7c967165399ed5a01a4ab9407cb379c75802f" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_statistic_ext_data&lt;/code&gt; holds data for extended planner statistics defined in &lt;code&gt;pg_statistic_ext&lt;/code&gt;. Each row in this catalog corresponds to a &lt;em&gt;statistics object&lt;/em&gt; created with &lt;a href=&quot;sql-createstatistics&quot;&gt;CREATE STATISTICS&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;pg_statistic_ext_data&lt;/code&gt; カタログは、 &lt;code&gt;pg_statistic_ext&lt;/code&gt; で定義された拡張プランナー統計のデータを保持します。このカタログの各行は、&lt;a href=&quot;sql-createstatistics&quot;&gt;CREATE STATISTICSで&lt;/a&gt;作成された&lt;em&gt;統計オブジェクトに&lt;/em&gt;対応してい&lt;em&gt;ます&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="c35fed25fc50b397d0a14fb9dcbeb17e75e6fe0f" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_subscription&lt;/code&gt; contains all existing logical replication subscriptions. For more information about logical replication see &lt;a href=&quot;https://www.postgresql.org/docs/12/logical-replication.html&quot;&gt;Chapter 30&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;pg_subscription&lt;/code&gt; カタログには、既存のすべての論理レプリケーションサブスクリプションが含まれています。論理複製の詳細については、&lt;a href=&quot;https://www.postgresql.org/docs/12/logical-replication.html&quot;&gt;第30章を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="2bfa0dd174813a02371e96eb1388d8212cb9d420" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_subscription&lt;/code&gt; contains all existing logical replication subscriptions. For more information about logical replication see &lt;a href=&quot;https://www.postgresql.org/docs/13/logical-replication.html&quot;&gt;Chapter 30&lt;/a&gt;.</source>
          <target state="translated">カタログ &lt;code&gt;pg_subscription&lt;/code&gt; には、既存のすべての論理レプリケーションサブスクリプションが含まれています。論理レプリケーションの詳細については、&lt;a href=&quot;https://www.postgresql.org/docs/13/logical-replication.html&quot;&gt;第30章を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="3cdf4cde86fcb864fb5af90b023119fc34f2142d" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_subscription_rel&lt;/code&gt; contains the state for each replicated relation in each subscription. This is a many-to-many mapping.</source>
          <target state="translated">&lt;code&gt;pg_subscription_rel&lt;/code&gt; カタログには、各サブスクリプションの複製された各関係の状態が含まれています。これは多対多のマッピングです。</target>
        </trans-unit>
        <trans-unit id="c447f5488ab316d33bbd3ebcf5f5d8b7c31ae85d" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_tablespace&lt;/code&gt; stores information about the available tablespaces. Tables can be placed in particular tablespaces to aid administration of disk layout.</source>
          <target state="translated">&lt;code&gt;pg_tablespace&lt;/code&gt; カタログは、利用可能なテーブルスペースに関する情報を保存します。テーブルを特定のテーブルスペースに配置して、ディスクレイアウトの管理を支援できます。</target>
        </trans-unit>
        <trans-unit id="5fd8fed96cb099d0e2d39d4d04e6e7c47d74045e" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_transform&lt;/code&gt; stores information about transforms, which are a mechanism to adapt data types to procedural languages. See &lt;a href=&quot;sql-createtransform&quot;&gt;CREATE TRANSFORM&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;pg_transform&lt;/code&gt; カタログは、データ型を手続き型言語に適合させるメカニズムである変換に関する情報を格納します。詳細については、&lt;a href=&quot;sql-createtransform&quot;&gt;CREATE TRANSFORM&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="75ce3dfcf04f9d1f1bc6bfe6a8a43c82175b0a72" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_trigger&lt;/code&gt; stores triggers on tables and views. See &lt;a href=&quot;sql-createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;pg_trigger&lt;/code&gt; カタログはテーブルとビューのトリガーを保存します。詳細については、&lt;a href=&quot;sql-createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="392fc6d5e6430c985734db6f435318b9f05a7dd3" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_type&lt;/code&gt; stores information about data types. Base types and enum types (scalar types) are created with &lt;a href=&quot;sql-createtype&quot;&gt;CREATE TYPE&lt;/a&gt;, and domains with &lt;a href=&quot;sql-createdomain&quot;&gt;CREATE DOMAIN&lt;/a&gt;. A composite type is automatically created for each table in the database, to represent the row structure of the table. It is also possible to create composite types with &lt;code&gt;CREATE TYPE AS&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pg_type&lt;/code&gt; カタログはデータ型に関する情報を保存します。基本型と列挙型（スカラー型）は&lt;a href=&quot;sql-createtype&quot;&gt;CREATE TYPE&lt;/a&gt;で作成され、ドメインは&lt;a href=&quot;sql-createdomain&quot;&gt;CREATE DOMAINで&lt;/a&gt;作成されます。複合型は、テーブルの行構造を表すために、データベース内の各テーブルに対して自動的に作成されます。 &lt;code&gt;CREATE TYPE AS&lt;/code&gt; を使用して複合型を作成することもできます。</target>
        </trans-unit>
        <trans-unit id="6bc1e303fc4f7bb28411737b0ff9561def41771f" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_user_mapping&lt;/code&gt; stores the mappings from local user to remote. Access to this catalog is restricted from normal users, use the view &lt;a href=&quot;view-pg-user-mappings&quot;&gt;&lt;code&gt;pg_user_mappings&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">&lt;code&gt;pg_user_mapping&lt;/code&gt; カタログは、ローカルユーザーからリモートへのマッピングを保存します。このカタログへのアクセスは通常のユーザーから制限されています。代わりにビュー&lt;a href=&quot;view-pg-user-mappings&quot;&gt; &lt;code&gt;pg_user_mappings&lt;/code&gt; を&lt;/a&gt;使用してください。</target>
        </trans-unit>
        <trans-unit id="96e368561ccfd905eaa08f49037cf99602ef83c4" translate="yes" xml:space="preserve">
          <source>The category code (a single ASCII character) for this type. The default is &lt;code&gt;'U'&lt;/code&gt; for &amp;ldquo;user-defined type&amp;rdquo;. Other standard category codes can be found in &lt;a href=&quot;catalog-pg-type#CATALOG-TYPCATEGORY-TABLE&quot;&gt;Table 51.63&lt;/a&gt;. You may also choose other ASCII characters in order to create custom categories.</source>
          <target state="translated">このタイプのカテゴリコード（単一のASCII文字）。「ユーザー定義型」のデフォルトは &lt;code&gt;'U'&lt;/code&gt; です。その他の標準カテゴリコードは、&lt;a href=&quot;catalog-pg-type#CATALOG-TYPCATEGORY-TABLE&quot;&gt;表51.63にあり&lt;/a&gt;ます。カスタムカテゴリを作成するために、他のASCII文字を選択することもできます。</target>
        </trans-unit>
        <trans-unit id="60a544b25f1cc2eef0830902b29eb1826d7423c5" translate="yes" xml:space="preserve">
          <source>The category code (a single ASCII character) for this type. The default is &lt;code&gt;'U'&lt;/code&gt; for &amp;ldquo;user-defined type&amp;rdquo;. Other standard category codes can be found in &lt;a href=&quot;catalog-pg-type#CATALOG-TYPCATEGORY-TABLE&quot;&gt;Table 51.64&lt;/a&gt;. You may also choose other ASCII characters in order to create custom categories.</source>
          <target state="translated">このタイプのカテゴリコード（単一のASCII文字）。デフォルトは「ユーザー定義タイプ」の &lt;code&gt;'U'&lt;/code&gt; です。その他の標準カテゴリコードは、&lt;a href=&quot;catalog-pg-type#CATALOG-TYPCATEGORY-TABLE&quot;&gt;表51.64にあり&lt;/a&gt;ます。カスタムカテゴリを作成するために、他のASCII文字を選択することもできます。</target>
        </trans-unit>
        <trans-unit id="6e0699308172a4d35d3852cf096bcc7cdc0d6fc5" translate="yes" xml:space="preserve">
          <source>The category names translate into names of &lt;code&gt;initdb&lt;/code&gt; options to override the locale choice for a specific category. For instance, to set the locale to French Canadian, but use U.S. rules for formatting currency, use &lt;code&gt;initdb --locale=fr_CA --lc-monetary=en_US&lt;/code&gt;.</source>
          <target state="translated">カテゴリー名は、 &lt;code&gt;initdb&lt;/code&gt; オプションの名前に変換され、特定のカテゴリーのロケール選択をオーバーライドします。たとえば、ロケールをフランスカナダに設定し、通貨のフォーマットに米国のルールを使用するには、 &lt;code&gt;initdb --locale=fr_CA --lc-monetary=en_US&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="90aadd1f991be6c6a59649f2cf2279a49d630988" translate="yes" xml:space="preserve">
          <source>The century</source>
          <target state="translated">世紀</target>
        </trans-unit>
        <trans-unit id="64714127e62379960f8b9dabad3b7dd16b967248" translate="yes" xml:space="preserve">
          <source>The character set encoding specified for the new database must be compatible with the chosen locale settings (&lt;code&gt;LC_COLLATE&lt;/code&gt; and &lt;code&gt;LC_CTYPE&lt;/code&gt;). If the locale is &lt;code&gt;C&lt;/code&gt; (or equivalently &lt;code&gt;POSIX&lt;/code&gt;), then all encodings are allowed, but for other locale settings there is only one encoding that will work properly. (On Windows, however, UTF-8 encoding can be used with any locale.) &lt;code&gt;CREATE DATABASE&lt;/code&gt; will allow superusers to specify &lt;code&gt;SQL_ASCII&lt;/code&gt; encoding regardless of the locale settings, but this choice is deprecated and may result in misbehavior of character-string functions if data that is not encoding-compatible with the locale is stored in the database.</source>
          <target state="translated">新しいデータベースに指定する文字セットエンコーディングは、選択したロケール設定（ &lt;code&gt;LC_COLLATE&lt;/code&gt; および &lt;code&gt;LC_CTYPE&lt;/code&gt; ）と互換性がある必要があります。ロケールが &lt;code&gt;C&lt;/code&gt; （または同等の &lt;code&gt;POSIX&lt;/code&gt; ）の場合、すべてのエンコーディングが許可されますが、他のロケール設定では、正しく機能するエンコーディングは1つだけです。 （ただし、Windowsでは、UTF-8エンコーディングを任意のロケールで使用できます。） &lt;code&gt;CREATE DATABASE&lt;/code&gt; を使用すると、スーパーユーザーはロケール設定に関係なく &lt;code&gt;SQL_ASCII&lt;/code&gt; エンコーディングを指定できますが、この選択は非推奨であり、データの場合、文字列関数の誤動作を引き起こす可能性があります。ロケールとエンコード互換ではないものはデータベースに格納されます。</target>
        </trans-unit>
        <trans-unit id="89d6fa6368565c20d96f1143f8a41b5bdded6f20" translate="yes" xml:space="preserve">
          <source>The character set support in PostgreSQL allows you to store text in a variety of character sets (also called encodings), including single-byte character sets such as the ISO 8859 series and multiple-byte character sets such as EUC (Extended Unix Code), UTF-8, and Mule internal code. All supported character sets can be used transparently by clients, but a few are not supported for use within the server (that is, as a server-side encoding). The default character set is selected while initializing your PostgreSQL database cluster using &lt;code&gt;initdb&lt;/code&gt;. It can be overridden when you create a database, so you can have multiple databases each with a different character set.</source>
          <target state="translated">PostgreSQLの文字セットのサポートにより、ISO 8859シリーズなどのシングルバイト文字セットやEUC（Extended Unix Code）などのマルチバイト文字セットなど、さまざまな文字セット（エンコーディングとも呼ばれます）でテキストを保存できます。 UTF-8、およびMule内部コード。サポートされているすべての文字セットはクライアントから透過的に使用できますが、サーバー内での使用（つまり、サーバー側のエンコーディングとして）がサポートされていないものもあります。 &lt;code&gt;initdb&lt;/code&gt; を使用してPostgreSQLデータベースクラスターを初期化するときに、デフォルトの文字セットが選択されます。データベースを作成するときに上書きできるため、それぞれが異なる文字セットを持つ複数のデータベースを持つことができます。</target>
        </trans-unit>
        <trans-unit id="97fdcbffdcc8da09aa147a46393111714ca188e7" translate="yes" xml:space="preserve">
          <source>The character with the code zero cannot be in a string constant.</source>
          <target state="translated">コード0の文字は文字列定数には入れられません。</target>
        </trans-unit>
        <trans-unit id="1c743222d29807902173d80c9ab0c69944ad07be" translate="yes" xml:space="preserve">
          <source>The character with the indicated octal code is substituted.</source>
          <target state="translated">表示されている8進数コードの文字が置換されます。</target>
        </trans-unit>
        <trans-unit id="9883df04aca064376efa049e7f1ac203fe46e46b" translate="yes" xml:space="preserve">
          <source>The character-entry escapes are always taken as ordinary characters. For example, &lt;code&gt;\135&lt;/code&gt; is &lt;code&gt;]&lt;/code&gt; in ASCII, but &lt;code&gt;\135&lt;/code&gt; does not terminate a bracket expression.</source>
          <target state="translated">文字入力エスケープは常に通常の文字として扱われます。例えば、 &lt;code&gt;\135&lt;/code&gt; ある &lt;code&gt;]&lt;/code&gt; ASCIIではなく、 &lt;code&gt;\135&lt;/code&gt; ブラケット表現を終了しません。</target>
        </trans-unit>
        <trans-unit id="ef0e78b53fce5d8f9142725e8e0f3c5fa09a015f" translate="yes" xml:space="preserve">
          <source>The checkpoint requirement of flushing all dirty data pages to disk can cause a significant I/O load. For this reason, checkpoint activity is throttled so that I/O begins at checkpoint start and completes before the next checkpoint is due to start; this minimizes performance degradation during checkpoints.</source>
          <target state="translated">すべてのダーティデータページをディスクにフラッシュするというチェックポイントの要件は、大きなI/O負荷を引き起こす可能性があります。このため、チェックポイントのアクティビティは、チェックポイントの開始時にI/Oが開始され、次のチェックポイントが開始される前に完了するようにスロットルされており、チェックポイント中のパフォーマンス低下を最小限に抑えます。</target>
        </trans-unit>
        <trans-unit id="f4d35c97f000761ce44e09472b3a63a412d56f71" translate="yes" xml:space="preserve">
          <source>The checkpointer process and the background writer process are active during recovery. The checkpointer process will perform restartpoints (similar to checkpoints on the primary) and the background writer process will perform normal block cleaning activities. This can include updates of the hint bit information stored on the standby server. The &lt;code&gt;CHECKPOINT&lt;/code&gt; command is accepted during recovery, though it performs a restartpoint rather than a new checkpoint.</source>
          <target state="translated">チェックポインタプロセスとバックグラウンドライタープロセスは、リカバリ中にアクティブになります。チェックポインタープロセスはリスタートポイント（プライマリのチェックポイントと同様）を実行し、バックグラウンドライタープロセスは通常のブロッククリーニングアクティビティを実行します。これには、スタンバイサーバーに保存されているヒントビット情報の更新が含まれる場合があります。 &lt;code&gt;CHECKPOINT&lt;/code&gt; のそれはリスタートではなく、新しいチェックポイントを実行しても、コマンドは、リカバリ中に受け入れられています。</target>
        </trans-unit>
        <trans-unit id="c35fb7c2595863d64a01efb7c2bd0d7867c26535" translate="yes" xml:space="preserve">
          <source>The checksum algorithm used to compute a checksum for this file. Currently, this will be the same for every file in the backup manifest, but this may change in future releases. At present, the supported checksum algorithms are &lt;code&gt;CRC32C&lt;/code&gt;, &lt;code&gt;SHA224&lt;/code&gt;, &lt;code&gt;SHA256&lt;/code&gt;, &lt;code&gt;SHA384&lt;/code&gt;, and &lt;code&gt;SHA512&lt;/code&gt;.</source>
          <target state="translated">このファイルのチェックサムを計算するために使用されるチェックサムアルゴリズム。現在、これはバックアップマニフェストのすべてのファイルで同じですが、将来のリリースで変更される可能性があります。現在、サポートされているチェックサムアルゴリズムは、 &lt;code&gt;CRC32C&lt;/code&gt; 、 &lt;code&gt;SHA224&lt;/code&gt; 、 &lt;code&gt;SHA256&lt;/code&gt; 、 &lt;code&gt;SHA384&lt;/code&gt; 、および &lt;code&gt;SHA512&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="0e144e6ae4a14c0e501dd6cac26f66ddeeba08c8" translate="yes" xml:space="preserve">
          <source>The checksum computed for this file, stored as a series of hexadecimal characters, two for each byte of the checksum.</source>
          <target state="translated">このファイルに対して計算されたチェックサムは、チェックサムのバイトごとに2つの16進数文字で格納されます。</target>
        </trans-unit>
        <trans-unit id="aea1ec4dfdbf684f4c49444bdb751e65ee9f5e89" translate="yes" xml:space="preserve">
          <source>The checksum computed with this function can be compared with the &lt;code&gt;checksum&lt;/code&gt; result field of the function &lt;code&gt;page_header&lt;/code&gt;. If data checksums are enabled for this instance, then the two values should be equal.</source>
          <target state="translated">この関数で計算された &lt;code&gt;checksum&lt;/code&gt; は、関数 &lt;code&gt;page_header&lt;/code&gt; のチェックサム結果フィールドと比較できます。このインスタンスでデータチェックサムが有効になっている場合、2つの値は等しいはずです。</target>
        </trans-unit>
        <trans-unit id="12cbfddc1d2244a2eb37d3e1009dc9d4f7140abc" translate="yes" xml:space="preserve">
          <source>The choice between GiST and GIN indexing depends on the relative performance characteristics of GiST and GIN, which are discussed elsewhere.</source>
          <target state="translated">GiSTとGINのインデキシングの選択は、GiSTとGINの相対的な性能特性に依存しますが、これは別の場所で議論されています。</target>
        </trans-unit>
        <trans-unit id="3567ccb40f1481d219e5951c92fe9f650cc7303e" translate="yes" xml:space="preserve">
          <source>The choice between these formats is up to the user. The first format is a proper XML document, which will be important in many applications. The second format tends to be more useful in the &lt;code&gt;cursor_to_xml&lt;/code&gt; function if the result values are to be reassembled into one document later on. The functions for producing XML content discussed above, in particular &lt;code&gt;xmlelement&lt;/code&gt;, can be used to alter the results to taste.</source>
          <target state="translated">これらの形式の選択はユーザー次第です。最初の形式は適切なXMLドキュメントであり、多くのアプリケーションで重要になります。2番目の形式は、結果の値を後で1つのドキュメントに再構成する場合、 &lt;code&gt;cursor_to_xml&lt;/code&gt; 関数でより役立つ傾向があります。上記のXMLコンテンツを生成するための関数、特に &lt;code&gt;xmlelement&lt;/code&gt; を使用して、結果を好みに応じて変更できます。</target>
        </trans-unit>
        <trans-unit id="2fcd6e12232fcafb17e4f9eed475f29ab9c942d0" translate="yes" xml:space="preserve">
          <source>The choice of how to partition a table should be made carefully as the performance of query planning and execution can be negatively affected by poor design.</source>
          <target state="translated">テーブルをどのように分割するかの選択は慎重に行う必要があります。</target>
        </trans-unit>
        <trans-unit id="eba68582494f00f7d7461ffee77aebc9a862ba45" translate="yes" xml:space="preserve">
          <source>The clause &lt;code&gt;CACHE cache&lt;/code&gt; enables sequence numbers to be preallocated and stored in memory for faster access. The minimum value is 1 (only one value can be generated at a time, i.e., no cache). If unspecified, the old cache value will be maintained.</source>
          <target state="translated">&lt;code&gt;CACHE cache&lt;/code&gt; 句を使用すると、シーケンス番号を事前に割り当ててメモリに格納し、アクセスを高速化できます。最小値は1です（一度に生成できる値は1つだけです。つまり、キャッシュはありません）。指定しない場合、古いキャッシュ値が維持されます。</target>
        </trans-unit>
        <trans-unit id="75a69760c05706a624428c520aa62a2819be2cc8" translate="yes" xml:space="preserve">
          <source>The clause &lt;code&gt;INCREMENT BY increment&lt;/code&gt; is optional. A positive value will make an ascending sequence, a negative one a descending sequence. If unspecified, the old increment value will be maintained.</source>
          <target state="translated">&lt;code&gt;INCREMENT BY increment&lt;/code&gt; 句はオプションです。正の値は昇順のシーケンスになり、負の値は降順のシーケンスになります。指定しない場合、古い増分値が維持されます。</target>
        </trans-unit>
        <trans-unit id="1e885032e33c3c5f3562475ecafb5ece897bbab7" translate="yes" xml:space="preserve">
          <source>The clauses &lt;code&gt;ALWAYS&lt;/code&gt; and &lt;code&gt;BY DEFAULT&lt;/code&gt; determine how explicitly user-specified values are handled in &lt;code&gt;INSERT&lt;/code&gt; and &lt;code&gt;UPDATE&lt;/code&gt; commands.</source>
          <target state="translated">&lt;code&gt;ALWAYS&lt;/code&gt; 句と &lt;code&gt;BY DEFAULT&lt;/code&gt; 句は、ユーザー指定の値が &lt;code&gt;INSERT&lt;/code&gt; コマンドと &lt;code&gt;UPDATE&lt;/code&gt; コマンドでどのように明示的に処理されるかを決定します。</target>
        </trans-unit>
        <trans-unit id="867e5349b79e57e50c69654c14c2d9c684ca93bc" translate="yes" xml:space="preserve">
          <source>The clauses &lt;code&gt;ALWAYS&lt;/code&gt; and &lt;code&gt;BY DEFAULT&lt;/code&gt; determine how the sequence value is given precedence over a user-specified value in an &lt;code&gt;INSERT&lt;/code&gt; statement. If &lt;code&gt;ALWAYS&lt;/code&gt; is specified, a user-specified value is only accepted if the &lt;code&gt;INSERT&lt;/code&gt; statement specifies &lt;code&gt;OVERRIDING SYSTEM VALUE&lt;/code&gt;. If &lt;code&gt;BY DEFAULT&lt;/code&gt; is specified, then the user-specified value takes precedence. See &lt;a href=&quot;sql-insert&quot;&gt;INSERT&lt;/a&gt; for details. (In the &lt;code&gt;COPY&lt;/code&gt; command, user-specified values are always used regardless of this setting.)</source>
          <target state="translated">&lt;code&gt;ALWAYS&lt;/code&gt; 句と &lt;code&gt;BY DEFAULT&lt;/code&gt; 句は、 &lt;code&gt;INSERT&lt;/code&gt; 文でユーザーが指定した値よりもシーケンス値を優先させる方法を決定します。場合 &lt;code&gt;ALWAYS&lt;/code&gt; が指定されている場合、ユーザーが指定した値のみが受け入れられ &lt;code&gt;INSERT&lt;/code&gt; 文指定は &lt;code&gt;OVERRIDING SYSTEM VALUE&lt;/code&gt; 。 &lt;code&gt;BY DEFAULT&lt;/code&gt; が指定されている場合、ユーザー指定の値が優先されます。詳細については、&lt;a href=&quot;sql-insert&quot;&gt;INSERT&lt;/a&gt;を参照してください。 （ &lt;code&gt;COPY&lt;/code&gt; コマンドでは、この設定に関係なく、ユーザー指定の値が常に使用されます。）</target>
        </trans-unit>
        <trans-unit id="234bcc40e3c1c6669b66cf6ee7882220428cd61f" translate="yes" xml:space="preserve">
          <source>The clauses &lt;code&gt;LIMIT&lt;/code&gt; and &lt;code&gt;OFFSET&lt;/code&gt; are PostgreSQL-specific syntax, also used by MySQL. The SQL:2008 standard has introduced the clauses &lt;code&gt;OFFSET ... FETCH {FIRST|NEXT} ...&lt;/code&gt; for the same functionality, as shown above in &lt;a href=&quot;sql-select#SQL-LIMIT&quot;&gt;&lt;code&gt;LIMIT&lt;/code&gt; Clause&lt;/a&gt;. This syntax is also used by IBM DB2. (Applications written for Oracle frequently use a workaround involving the automatically generated &lt;code&gt;rownum&lt;/code&gt; column, which is not available in PostgreSQL, to implement the effects of these clauses.)</source>
          <target state="translated">&lt;code&gt;LIMIT&lt;/code&gt; および &lt;code&gt;OFFSET&lt;/code&gt; 句はPostgreSQL固有の構文で、MySQLでも使用されます。 SQL：2008標準では、上記の&lt;a href=&quot;sql-select#SQL-LIMIT&quot;&gt; &lt;code&gt;LIMIT&lt;/code&gt; &lt;/a&gt;句に示されているように、同じ機能に対して &lt;code&gt;OFFSET ... FETCH {FIRST|NEXT} ...&lt;/code&gt; 句が導入されています。この構文は、IBM DB2でも使用されます。 （Oracle用に作成されたアプリケーションは、PostgreSQLにはない自動生成された &lt;code&gt;rownum&lt;/code&gt; 列を含む回避策を頻繁に使用して、これらの句の効果を実装します。）</target>
        </trans-unit>
        <trans-unit id="4ef779e24cd70dc78d1e7371780e8d692d8fd135" translate="yes" xml:space="preserve">
          <source>The clauses &lt;code&gt;LIMIT&lt;/code&gt; and &lt;code&gt;OFFSET&lt;/code&gt; are PostgreSQL-specific syntax, also used by MySQL. The SQL:2008 standard has introduced the clauses &lt;code&gt;OFFSET ... FETCH {FIRST|NEXT} ...&lt;/code&gt; for the same functionality, as shown above in &lt;a href=&quot;sql-select#SQL-LIMIT&quot;&gt;LIMIT Clause&lt;/a&gt;. This syntax is also used by IBM DB2. (Applications written for Oracle frequently use a workaround involving the automatically generated &lt;code&gt;rownum&lt;/code&gt; column, which is not available in PostgreSQL, to implement the effects of these clauses.)</source>
          <target state="translated">&lt;code&gt;LIMIT&lt;/code&gt; 句と &lt;code&gt;OFFSET&lt;/code&gt; 句はPostgreSQL固有の構文であり、MySQLでも使用されます。 SQL：2008標準では、上記の&lt;a href=&quot;sql-select#SQL-LIMIT&quot;&gt;LIMIT句に&lt;/a&gt;示されているように、同じ機能に対して &lt;code&gt;OFFSET ... FETCH {FIRST|NEXT} ...&lt;/code&gt; 句が導入されています。この構文は、IBMDB2でも使用されます。 （Oracle用に作成されたアプリケーションは、これらの句の効果を実装するために、PostgreSQLでは使用できない自動生成された &lt;code&gt;rownum&lt;/code&gt; 列を含む回避策を頻繁に使用します。）</target>
        </trans-unit>
        <trans-unit id="54380a0f1c98e1a0a687fefef82dc949bcffc323" translate="yes" xml:space="preserve">
          <source>The client must be allowed to access all referenced tables and columns, even if they originated from views which were then expanded, so that we apply consistent access control rules independent of the manner in which the table contents are referenced.</source>
          <target state="translated">クライアントは、たとえそれらがビューから派生して展開されたものであっても、参照されるすべてのテーブルとカラムへのアクセスを許可しなければなりません。</target>
        </trans-unit>
        <trans-unit id="05fdc0ebe765756a24f5709f3f5f878e85b6fb9a" translate="yes" xml:space="preserve">
          <source>The client process can be any program that understands the PostgreSQL protocol described in &lt;a href=&quot;https://www.postgresql.org/docs/12/protocol.html&quot;&gt;Chapter 52&lt;/a&gt;. Many clients are based on the C-language library libpq, but several independent implementations of the protocol exist, such as the Java JDBC driver.</source>
          <target state="translated">クライアントプロセスは、&lt;a href=&quot;https://www.postgresql.org/docs/12/protocol.html&quot;&gt;第52章で&lt;/a&gt;説明するPostgreSQLプロトコルを理解する任意のプログラムにすることができます。多くのクライアントはC言語ライブラリlibpqに基づいていますが、Java JDBCドライバーなど、プロトコルのいくつかの独立した実装が存在します。</target>
        </trans-unit>
        <trans-unit id="973ecfa139cd389fe92d63aca6613fcea6c732f4" translate="yes" xml:space="preserve">
          <source>The client process can be any program that understands the PostgreSQL protocol described in &lt;a href=&quot;https://www.postgresql.org/docs/13/protocol.html&quot;&gt;Chapter 52&lt;/a&gt;. Many clients are based on the C-language library libpq, but several independent implementations of the protocol exist, such as the Java JDBC driver.</source>
          <target state="translated">クライアントプロセスは、&lt;a href=&quot;https://www.postgresql.org/docs/13/protocol.html&quot;&gt;第52章で&lt;/a&gt;説明されているPostgreSQLプロトコルを理解する任意のプログラムにすることができます。多くのクライアントはC言語ライブラリlibpqに基づいていますが、Java JDBCドライバーなど、プロトコルのいくつかの独立した実装が存在します。</target>
        </trans-unit>
        <trans-unit id="14c663b89bef91d752e19ecca16e81b132b43904" translate="yes" xml:space="preserve">
          <source>The client responds by sending a SASLInitialResponse message, which indicates the chosen mechanism, &lt;code&gt;SCRAM-SHA-256&lt;/code&gt; or &lt;code&gt;SCRAM-SHA-256-PLUS&lt;/code&gt;. (A client is free to choose either mechanism, but for better security it should choose the channel-binding variant if it can support it.) In the Initial Client response field, the message contains the SCRAM &lt;code&gt;client-first-message&lt;/code&gt;. The &lt;code&gt;client-first-message&lt;/code&gt; also contains the channel binding type chosen by the client.</source>
          <target state="translated">クライアントは、選択されたメカニズムである &lt;code&gt;SCRAM-SHA-256&lt;/code&gt; または &lt;code&gt;SCRAM-SHA-256-PLUS&lt;/code&gt; を示すSASLInitialResponseメッセージを送信して応答します。（クライアントはどちらのメカニズムも自由に選択できますが、より良いセキュリティのために、それがサポートできる場合はチャネルバインディングバリアントを選択する必要があります。）[初期クライアント応答]フィールドで、メッセージにはSCRAM &lt;code&gt;client-first-message&lt;/code&gt; が含まれます。 &lt;code&gt;client-first-message&lt;/code&gt; 、クライアントによって選択されたチャネルバインディングタイプを含みます。</target>
        </trans-unit>
        <trans-unit id="28e4175f56ce1936736eeadfb881155016ea4fed" translate="yes" xml:space="preserve">
          <source>The client selects one of the supported mechanisms from the list, and sends a SASLInitialResponse message to the server. The message includes the name of the selected mechanism, and an optional Initial Client Response, if the selected mechanism uses that.</source>
          <target state="translated">クライアントはリストからサポートされているメカニズムのひとつを選択し、 SASLInitialResponse メッセージをサーバーに送信します。メッセージには、選択したメカニズムの名前と、選択したメカニズムがそれを使用している場合は、オプションの初期クライアント・レスポンスが含まれます。</target>
        </trans-unit>
        <trans-unit id="229cec88eb4f3eac7279336f40b13a71ae9b84dd" translate="yes" xml:space="preserve">
          <source>The client sends an Execute message with a non-zero fetch count. See the discussion of the &lt;a href=&quot;https://www.postgresql.org/docs/12/protocol-flow.html#PROTOCOL-FLOW-EXT-QUERY&quot;&gt;extended query protocol&lt;/a&gt;. Since &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq.html&quot;&gt;libpq&lt;/a&gt; currently provides no way to send such a message, this can only occur when using a client that does not rely on libpq. If this is a frequent occurrence, it may be a good idea to set &lt;a href=&quot;runtime-config-resource#GUC-MAX-PARALLEL-WORKERS-PER-GATHER&quot;&gt;max_parallel_workers_per_gather&lt;/a&gt; to zero in sessions where it is likely, so as to avoid generating query plans that may be suboptimal when run serially.</source>
          <target state="translated">クライアントは、ゼロ以外のフェッチカウントで実行メッセージを送信します。&lt;a href=&quot;https://www.postgresql.org/docs/12/protocol-flow.html#PROTOCOL-FLOW-EXT-QUERY&quot;&gt;拡張クエリプロトコルの&lt;/a&gt;説明を参照してください。以来&lt;a href=&quot;https://www.postgresql.org/docs/12/libpq.html&quot;&gt;のlibpqは&lt;/a&gt;現在、Aメッセージを送信するための方法を提供していませんのlibpqに依存していないクライアントを使用している場合、これが唯一の発生する可能性があります。これが頻繁に発生する場合は、可能性のあるセッションで&lt;a href=&quot;runtime-config-resource#GUC-MAX-PARALLEL-WORKERS-PER-GATHER&quot;&gt;max_parallel_workers_per_gather&lt;/a&gt;をゼロに設定して、逐次実行すると最適ではないクエリプランが生成されないようにすることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="b4c35b44809114c2fabb0bca78243a5e0e3a582e" translate="yes" xml:space="preserve">
          <source>The client sends an Execute message with a non-zero fetch count. See the discussion of the &lt;a href=&quot;https://www.postgresql.org/docs/13/protocol-flow.html#PROTOCOL-FLOW-EXT-QUERY&quot;&gt;extended query protocol&lt;/a&gt;. Since &lt;a href=&quot;https://www.postgresql.org/docs/13/libpq.html&quot;&gt;libpq&lt;/a&gt; currently provides no way to send such a message, this can only occur when using a client that does not rely on libpq. If this is a frequent occurrence, it may be a good idea to set &lt;a href=&quot;runtime-config-resource#GUC-MAX-PARALLEL-WORKERS-PER-GATHER&quot;&gt;max_parallel_workers_per_gather&lt;/a&gt; to zero in sessions where it is likely, so as to avoid generating query plans that may be suboptimal when run serially.</source>
          <target state="translated">クライアントは、フェッチカウントがゼロ以外の実行メッセージを送信します。&lt;a href=&quot;https://www.postgresql.org/docs/13/protocol-flow.html#PROTOCOL-FLOW-EXT-QUERY&quot;&gt;拡張クエリプロトコルの&lt;/a&gt;説明を参照してください。以来&lt;a href=&quot;https://www.postgresql.org/docs/13/libpq.html&quot;&gt;のlibpqは&lt;/a&gt;現在、Aメッセージを送信するための方法を提供していませんのlibpqに依存していないクライアントを使用している場合、これが唯一の発生する可能性があります。これが頻繁に発生する場合は、シリアル実行時に最適ではない可能性のあるクエリプランの生成を回避するために、可能性のあるセッションで&lt;a href=&quot;runtime-config-resource#GUC-MAX-PARALLEL-WORKERS-PER-GATHER&quot;&gt;max_parallel_workers_per_gather&lt;/a&gt;をゼロに設定することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="2c8bc9da59ada6925c6ca4e1408b3caa10a534cd" translate="yes" xml:space="preserve">
          <source>The code block is treated as though it were the body of a function with no parameters, returning &lt;code&gt;void&lt;/code&gt;. It is parsed and executed a single time.</source>
          <target state="translated">コードブロックは、パラメーターのない関数の本体であるかのように扱われ、 &lt;code&gt;void&lt;/code&gt; を返します。解析と実行は1回です。</target>
        </trans-unit>
        <trans-unit id="312278044badf1f81c35c2b663c752edaa662f24" translate="yes" xml:space="preserve">
          <source>The collation assigned to a function or operator's combined input expressions is also considered to apply to the function or operator's result, if the function or operator delivers a result of a collatable data type. So, in</source>
          <target state="translated">関数または演算子の結合された入力式に割り当てられた照合は、関数または演算子が照合可能なデータ型の結果を提供する場合、関数または演算子の結果にも適用されると考えられます。そのため、以下のように</target>
        </trans-unit>
        <trans-unit id="07ad042e8eb9598587dcbb36503b3ffb45fa7270" translate="yes" xml:space="preserve">
          <source>The collation feature allows specifying the sort order and character classification behavior of data per-column, or even per-operation. This alleviates the restriction that the &lt;code&gt;LC_COLLATE&lt;/code&gt; and &lt;code&gt;LC_CTYPE&lt;/code&gt; settings of a database cannot be changed after its creation.</source>
          <target state="translated">照合機能を使用すると、列ごと、または操作ごとに、データの並べ替え順序と文字分類動作を指定できます。これにより、データベースの &lt;code&gt;LC_COLLATE&lt;/code&gt; および &lt;code&gt;LC_CTYPE&lt;/code&gt; 設定は作成後に変更できないという制限が緩和されます。</target>
        </trans-unit>
        <trans-unit id="6968224c63a84f2b924666a708e6eefcbe1a5fe3" translate="yes" xml:space="preserve">
          <source>The collation of an expression can be the &amp;ldquo;default&amp;rdquo; collation, which means the locale settings defined for the database. It is also possible for an expression's collation to be indeterminate. In such cases, ordering operations and other operations that need to know the collation will fail.</source>
          <target state="translated">式の照合順序は、「デフォルト」の照合順序にすることができます。これは、データベースに定義されたロケール設定を意味します。式の照合順序が不確定になる可能性もあります。そのような場合、順序付け操作および照合を知る必要がある他の操作は失敗します。</target>
        </trans-unit>
        <trans-unit id="8cbb0497a2d0489a87ba349c1f09ee8dec4f3fd5" translate="yes" xml:space="preserve">
          <source>The collation used to derive the statistics stored in the &lt;code&gt;N&lt;/code&gt;th &amp;ldquo;slot&amp;rdquo;. For example, a histogram slot for a collatable column would show the collation that defines the sort order of the data. Zero for noncollatable data.</source>
          <target state="translated">&lt;code&gt;N&lt;/code&gt; 番目の「スロット」に格納されている統計情報を取得するために使用される照合順序。たとえば、照合可能な列のヒストグラムスロットは、データのソート順を定義する照合を示します。照合不可能なデータの場合はゼロ。</target>
        </trans-unit>
        <trans-unit id="b4385bb7e15544b6f2f8d39c7296d888e4a8a5d9" translate="yes" xml:space="preserve">
          <source>The colon (&lt;code&gt;:&lt;/code&gt;) is used to select &amp;ldquo;slices&amp;rdquo; from arrays. (See &lt;a href=&quot;arrays&quot;&gt;Section 8.15&lt;/a&gt;.) In certain SQL dialects (such as Embedded SQL), the colon is used to prefix variable names.</source>
          <target state="translated">コロン（ &lt;code&gt;:&lt;/code&gt; ）アレイからの「スライス」を選択するために使用されます。（&lt;a href=&quot;arrays&quot;&gt;セクション8.15を&lt;/a&gt;参照してください。）特定のSQL方言（Embedded SQLなど）では、コロンを使用して変数名にプレフィックスを付けます。</target>
        </trans-unit>
        <trans-unit id="b41c26c54c1ac62b21f77b8fd62d5d3012b96e24" translate="yes" xml:space="preserve">
          <source>The colon syntax for variables is standard SQL for embedded query languages, such as ECPG. The colon syntaxes for array slices and type casts are PostgreSQL extensions, which can sometimes conflict with the standard usage. The colon-quote syntax for escaping a variable's value as an SQL literal or identifier is a psql extension.</source>
          <target state="translated">変数のコロン構文は、ECPGなどの組み込み問い合わせ言語の標準SQLです。配列スライスと型キャストのコロン構文はPostgreSQLの拡張であり、標準的な使用法と衝突することがあります。変数の値をSQLリテラルや識別子としてエスケープするためのコロン・クォート構文はpsql拡張です。</target>
        </trans-unit>
        <trans-unit id="d094304df5c5c2f3f002a3a5f2b5b0282e855c32" translate="yes" xml:space="preserve">
          <source>The column data type that this operator class is for.</source>
          <target state="translated">この演算子クラスが対象とする列データ型。</target>
        </trans-unit>
        <trans-unit id="5a6fb4ccabc2a7663f993c4ebb4c744ff2affbac" translate="yes" xml:space="preserve">
          <source>The column default value, in &lt;code&gt;nodeToString()&lt;/code&gt; representation. Use &lt;code&gt;pg_get_expr(adbin, adrelid)&lt;/code&gt; to convert it to an SQL expression.</source>
          <target state="translated">&lt;code&gt;nodeToString()&lt;/code&gt; 表現での列のデフォルト値。使う &lt;code&gt;pg_get_expr(adbin, adrelid)&lt;/code&gt; SQL式に変換します。</target>
        </trans-unit>
        <trans-unit id="08368fd428556014aaea42a5338ea6c2743ad445" translate="yes" xml:space="preserve">
          <source>The column is allowed to contain null values. This is the default.</source>
          <target state="translated">列にはヌル値を含めることができます。これがデフォルトです。</target>
        </trans-unit>
        <trans-unit id="5bb55967abb94c1ccc24a2441d33dbf806399e61" translate="yes" xml:space="preserve">
          <source>The column is not allowed to contain null values.</source>
          <target state="translated">列にヌル値を含めることはできません。</target>
        </trans-unit>
        <trans-unit id="8420d2c88df44919ff7832e5423eccf9e0e7b65d" translate="yes" xml:space="preserve">
          <source>The column name</source>
          <target state="translated">カラム名</target>
        </trans-unit>
        <trans-unit id="d9ec3849dbdc73ff83e6e2b53f90a20a6fb0948f" translate="yes" xml:space="preserve">
          <source>The column source table(s) must be &lt;code&gt;INNER&lt;/code&gt; or &lt;code&gt;LEFT&lt;/code&gt; joined to the &lt;code&gt;LATERAL&lt;/code&gt; item, else there would not be a well-defined set of rows from which to compute each set of rows for the &lt;code&gt;LATERAL&lt;/code&gt; item. Thus, although a construct such as &lt;code&gt;X RIGHT JOIN LATERAL Y&lt;/code&gt; is syntactically valid, it is not actually allowed for &lt;code&gt;Y&lt;/code&gt; to reference &lt;code&gt;X&lt;/code&gt;.</source>
          <target state="translated">列ソーステーブルは &lt;code&gt;LATERAL&lt;/code&gt; アイテムに結合された &lt;code&gt;INNER&lt;/code&gt; または &lt;code&gt;LEFT&lt;/code&gt; である必要があります。そうでない場合、 &lt;code&gt;LATERAL&lt;/code&gt; アイテムの行の各セットを計算するための明確に定義された行のセットはありません。ような構築物がこのように、 &lt;code&gt;X RIGHT JOIN LATERAL Y&lt;/code&gt; 構文的に有効であり、それは実際に許可されていない &lt;code&gt;Y&lt;/code&gt; 基準に &lt;code&gt;X&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e991f9b83115d7ba9de797ba7c6fd7f9b86d5e91" translate="yes" xml:space="preserve">
          <source>The columns names &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, and &lt;code&gt;c&lt;/code&gt; are either the actual names of the columns of tables referenced in the &lt;code&gt;FROM&lt;/code&gt; clause, or the aliases given to them as explained in &lt;a href=&quot;queries-table-expressions#QUERIES-TABLE-ALIASES&quot;&gt;Section 7.2.1.2&lt;/a&gt;. The name space available in the select list is the same as in the &lt;code&gt;WHERE&lt;/code&gt; clause, unless grouping is used, in which case it is the same as in the &lt;code&gt;HAVING&lt;/code&gt; clause.</source>
          <target state="translated">列名 &lt;code&gt;a&lt;/code&gt; 、 &lt;code&gt;b&lt;/code&gt; 、および &lt;code&gt;c&lt;/code&gt; は、 &lt;code&gt;FROM&lt;/code&gt; 句で参照されるテーブルの列の実際の名前、または&lt;a href=&quot;queries-table-expressions#QUERIES-TABLE-ALIASES&quot;&gt;7.2.1.2項で&lt;/a&gt;説明されているように、それらに割り当てられたエイリアスです。グループ化が使用されない限り、選択リストで使用可能な名前空間は &lt;code&gt;WHERE&lt;/code&gt; 句と同じです。この場合、グループ化は &lt;code&gt;HAVING&lt;/code&gt; 句と同じです。</target>
        </trans-unit>
        <trans-unit id="4599d6eec1312706887ef09d2464d5545c627474" translate="yes" xml:space="preserve">
          <source>The combination of the return value of this function with the certificate serial number uniquely identifies the certificate.</source>
          <target state="translated">この関数の戻り値と証明書のシリアル番号の組み合わせは、証明書を一意に識別します。</target>
        </trans-unit>
        <trans-unit id="062e4ea98a9662fe6dca5fb34a40a037aa606eb5" translate="yes" xml:space="preserve">
          <source>The command</source>
          <target state="translated">コマンド</target>
        </trans-unit>
        <trans-unit id="fd4ecf316bcb95382c9ca99fb6834b4e0a4db40c" translate="yes" xml:space="preserve">
          <source>The command &lt;a href=&quot;sql-createcollation&quot;&gt;CREATE COLLATION&lt;/a&gt; can also be used to create a new collation from an existing collation, which can be useful to be able to use operating-system-independent collation names in applications, create compatibility names, or use an ICU-provided collation under a more readable name. For example:</source>
          <target state="translated">コマンド&lt;a href=&quot;sql-createcollation&quot;&gt;CREATE COLLATION&lt;/a&gt;を使用して、既存の照合から新しい照合を作成することもできます。これは、アプリケーションでオペレーティングシステムに依存しない照合名を使用したり、互換性名を作成したり、ICU提供の照合をより読みやすい名前。例えば：</target>
        </trans-unit>
        <trans-unit id="d977c35dcae77bd0de806a55a77621ba14612b62" translate="yes" xml:space="preserve">
          <source>The command &lt;code&gt;ALTER PUBLICATION&lt;/code&gt; can change the attributes of a publication.</source>
          <target state="translated">コマンド &lt;code&gt;ALTER PUBLICATION&lt;/code&gt; は、パブリケーションの属性を変更できます。</target>
        </trans-unit>
        <trans-unit id="969778663757608a9ceb272b57ae37cfa06e3dd9" translate="yes" xml:space="preserve">
          <source>The command &lt;code&gt;COMMIT&lt;/code&gt; conforms to the SQL standard. The form &lt;code&gt;COMMIT TRANSACTION&lt;/code&gt; is a PostgreSQL extension.</source>
          <target state="translated">コマンド &lt;code&gt;COMMIT&lt;/code&gt; は、SQL標準に準拠しています。 &lt;code&gt;COMMIT TRANSACTION&lt;/code&gt; という形式は、PostgreSQLの拡張機能です。</target>
        </trans-unit>
        <trans-unit id="dbf0fa331f942a39e4739f4ed15c74b619e12d1b" translate="yes" xml:space="preserve">
          <source>The command &lt;code&gt;CREATE DOMAIN&lt;/code&gt; conforms to the SQL standard.</source>
          <target state="translated">コマンド &lt;code&gt;CREATE DOMAIN&lt;/code&gt; は、SQL標準に準拠しています。</target>
        </trans-unit>
        <trans-unit id="c0e7572b18c65a9a6261e55f6991fd2f67f9ff3c" translate="yes" xml:space="preserve">
          <source>The command &lt;code&gt;LOCK TABLE a, b;&lt;/code&gt; is equivalent to &lt;code&gt;LOCK TABLE a; LOCK TABLE b;&lt;/code&gt;. The tables are locked one-by-one in the order specified in the &lt;code&gt;LOCK TABLE&lt;/code&gt; command.</source>
          <target state="translated">コマンド &lt;code&gt;LOCK TABLE a, b;&lt;/code&gt; &lt;code&gt;LOCK TABLE a; LOCK TABLE b;&lt;/code&gt; と同等です。ロックテーブルb; 。テーブルは、 &lt;code&gt;LOCK TABLE&lt;/code&gt; コマンドで指定された順序で1つずつロックされます。</target>
        </trans-unit>
        <trans-unit id="bd29caedfd38b09e6ed21c78963ca39d6d0fdf15" translate="yes" xml:space="preserve">
          <source>The command &lt;code&gt;ROLLBACK&lt;/code&gt; conforms to the SQL standard. The form &lt;code&gt;ROLLBACK TRANSACTION&lt;/code&gt; is a PostgreSQL extension.</source>
          <target state="translated">コマンド &lt;code&gt;ROLLBACK&lt;/code&gt; は、SQL標準に準拠しています。 &lt;code&gt;ROLLBACK TRANSACTION&lt;/code&gt; の形式はPostgreSQLの拡張です。</target>
        </trans-unit>
        <trans-unit id="14f45c2838c91f3d088f1dbeb531759099cc9619" translate="yes" xml:space="preserve">
          <source>The command does not actually have to prompt the user for a passphrase. It can read it from a file, obtain it from a keychain facility, or similar. It is up to the user to make sure the chosen mechanism is adequately secure.</source>
          <target state="translated">コマンドは実際にはパスフレーズの入力をユーザに求める必要はありません。ファイルから読み取るか、キーチェーン施設から取得するか、または同様の方法でパスフレーズを取得することができます。選択したメカニズムが十分に安全であることを確認するのはユーザ次第です。</target>
        </trans-unit>
        <trans-unit id="125f23e3bb7186ab7a646a52cf5bf9eca19bcc45" translate="yes" xml:space="preserve">
          <source>The command form &lt;code&gt;\d+&lt;/code&gt; is identical, except that more information is displayed: any comments associated with the columns of the table are shown, as is the presence of OIDs in the table, the view definition if the relation is a view, a non-default &lt;a href=&quot;sql-altertable#SQL-CREATETABLE-REPLICA-IDENTITY&quot;&gt;replica identity&lt;/a&gt; setting.</source>
          <target state="translated">コマンドフォーム &lt;code&gt;\d+&lt;/code&gt; は同じですが、詳細情報が表示されます。テーブルの列に関連付けられているコメントが表示されます。テーブルにOIDが存在する場合、リレーションがビューの場合はビューの定義、デフォルトの&lt;a href=&quot;sql-altertable#SQL-CREATETABLE-REPLICA-IDENTITY&quot;&gt;レプリカID&lt;/a&gt;設定。</target>
        </trans-unit>
        <trans-unit id="0916bd8daa5b51f8834876be91b7f972c2fe0c9c" translate="yes" xml:space="preserve">
          <source>The command identifier (starting at zero) within the inserting transaction.</source>
          <target state="translated">挿入トランザクション内のコマンド識別子(ゼロから始まる)。</target>
        </trans-unit>
        <trans-unit id="d1364d07c5f1725771640b150e94c42c6a8b2515" translate="yes" xml:space="preserve">
          <source>The command identifier within the deleting transaction, or zero.</source>
          <target state="translated">削除するトランザクション内のコマンド識別子、またはゼロ。</target>
        </trans-unit>
        <trans-unit id="1437750e20fa527029f8f074bcd579b652d1fc5a" translate="yes" xml:space="preserve">
          <source>The command is computing extended statistics from the sample rows obtained during the table scan.</source>
          <target state="translated">このコマンドは、テーブルスキャン中に得られたサンプル行から拡張統計量を計算しています。</target>
        </trans-unit>
        <trans-unit id="733186417b69bd6a5c32f04973634c419eb62936" translate="yes" xml:space="preserve">
          <source>The command is computing statistics from the sample rows obtained during the table scan.</source>
          <target state="translated">このコマンドは、テーブルスキャン中に得られたサンプル行から統計情報を計算しています。</target>
        </trans-unit>
        <trans-unit id="4d0382226380f9ead190eb302a73c778dbdd6e8d" translate="yes" xml:space="preserve">
          <source>The command is currently rebuilding an index.</source>
          <target state="translated">コマンドは現在インデックスを再構築中です。</target>
        </trans-unit>
        <trans-unit id="08589d87d0f9a78f65af3716f713118502dde96d" translate="yes" xml:space="preserve">
          <source>The command is currently scanning child tables to obtain sample rows. Columns &lt;code&gt;child_tables_total&lt;/code&gt;, &lt;code&gt;child_tables_done&lt;/code&gt;, and &lt;code&gt;current_child_table_relid&lt;/code&gt; contain the progress information for this phase.</source>
          <target state="translated">このコマンドは現在、子テーブルをスキャンしてサンプル行を取得しています。列 &lt;code&gt;child_tables_total&lt;/code&gt; 、 &lt;code&gt;child_tables_done&lt;/code&gt; 、および &lt;code&gt;current_child_table_relid&lt;/code&gt; には、このフェーズの進行状況情報が含まれています。</target>
        </trans-unit>
        <trans-unit id="818a6c346e272bdd257338212ea062e5d982098f" translate="yes" xml:space="preserve">
          <source>The command is currently scanning the table given by &lt;code&gt;relid&lt;/code&gt; to obtain sample rows.</source>
          <target state="translated">このコマンドは現在、サンプル行を取得するために &lt;code&gt;relid&lt;/code&gt; で指定されたテーブルをスキャンしています。</target>
        </trans-unit>
        <trans-unit id="bf18e6a22964c8d441f27d38a4a845cd36e9d7a8" translate="yes" xml:space="preserve">
          <source>The command is currently scanning the table using a sequential scan.</source>
          <target state="translated">コマンドは現在、シーケンシャル スキャンを使用してテーブルをスキャンしています。</target>
        </trans-unit>
        <trans-unit id="2d997222e2d809bc7ed01be5d82f30faa7501100" translate="yes" xml:space="preserve">
          <source>The command is currently swapping newly-built files into place.</source>
          <target state="translated">コマンドは現在、新しくビルドされたファイルを所定の場所にスワップしています。</target>
        </trans-unit>
        <trans-unit id="d36048945358a61f078040109a39866ba3017fd5" translate="yes" xml:space="preserve">
          <source>The command is performing final cleanup. When this phase is completed, &lt;code&gt;CLUSTER&lt;/code&gt; or &lt;code&gt;VACUUM FULL&lt;/code&gt; will end.</source>
          <target state="translated">コマンドは最終クリーンアップを実行しています。このフェーズが完了すると、 &lt;code&gt;CLUSTER&lt;/code&gt; または &lt;code&gt;VACUUM FULL&lt;/code&gt; が終了します。</target>
        </trans-unit>
        <trans-unit id="b779f0c2e033575cc8fc0dc14c755c01561f9ff6" translate="yes" xml:space="preserve">
          <source>The command is preparing to begin scanning the heap. This phase is expected to be very brief.</source>
          <target state="translated">コマンドはヒープのスキャンを開始する準備をしています。このフェーズは非常に短いと予想されます。</target>
        </trans-unit>
        <trans-unit id="68b75bc58da613bc57b4a395ff1c9dc327e8f607" translate="yes" xml:space="preserve">
          <source>The command is updating &lt;code&gt;pg_class&lt;/code&gt;. When this phase is completed, &lt;code&gt;ANALYZE&lt;/code&gt; will end.</source>
          <target state="translated">コマンドは &lt;code&gt;pg_class&lt;/code&gt; を更新しています。このフェーズが完了すると、 &lt;code&gt;ANALYZE&lt;/code&gt; は終了します。</target>
        </trans-unit>
        <trans-unit id="00faacb1d010fe63608a96c43ef3a7084a48b136" translate="yes" xml:space="preserve">
          <source>The command must print the passphrase to the standard output and exit with code 0. In the parameter value, &lt;code&gt;%p&lt;/code&gt; is replaced by a prompt string. (Write &lt;code&gt;%%&lt;/code&gt; for a literal &lt;code&gt;%&lt;/code&gt;.) Note that the prompt string will probably contain whitespace, so be sure to quote adequately. A single newline is stripped from the end of the output if present.</source>
          <target state="translated">コマンドはパスフレーズを標準出力に出力し、コード0で終了する必要があります。パラメーター値では、 &lt;code&gt;%p&lt;/code&gt; はプロンプト文字列に置き換えられます。（リテラル &lt;code&gt;%&lt;/code&gt; の場合は &lt;code&gt;%%&lt;/code&gt; と記述します。）プロンプト文字列にはおそらく空白が含まれるため、適切に引用してください。存在する場合、出力の最後から単一の改行が削除されます。</target>
        </trans-unit>
        <trans-unit id="c98b53eebf8fcd4fa5340e65c4d477e99fd91e81" translate="yes" xml:space="preserve">
          <source>The command or commands that make up the rule action. Valid commands are &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;, or &lt;code&gt;NOTIFY&lt;/code&gt;.</source>
          <target state="translated">ルールアクションを構成するコマンド。有効なコマンドは、 &lt;code&gt;SELECT&lt;/code&gt; 、 &lt;code&gt;INSERT&lt;/code&gt; 、 &lt;code&gt;UPDATE&lt;/code&gt; 、 &lt;code&gt;DELETE&lt;/code&gt; 、または &lt;code&gt;NOTIFY&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="8f5e5a53841d0cfd1aacf0accff8cefa2f5212ac" translate="yes" xml:space="preserve">
          <source>The command tag returned by &lt;code&gt;EXECUTE&lt;/code&gt; is that of the prepared statement, and not &lt;code&gt;EXECUTE&lt;/code&gt;.</source>
          <target state="translated">タグは、によって返さコマンド &lt;code&gt;EXECUTE&lt;/code&gt; は、準備された文のことではなく、 &lt;code&gt;EXECUTE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="74ac6ad09ab58057a9fed1f64a26a788f3d3e326" translate="yes" xml:space="preserve">
          <source>The command that is running. Either &lt;code&gt;CLUSTER&lt;/code&gt; or &lt;code&gt;VACUUM FULL&lt;/code&gt;.</source>
          <target state="translated">実行中のコマンド。 &lt;code&gt;CLUSTER&lt;/code&gt; または &lt;code&gt;VACUUM FULL&lt;/code&gt; のいずれか。</target>
        </trans-unit>
        <trans-unit id="a9850fa889a0eec791cad23100b9e331cd2aa4fc" translate="yes" xml:space="preserve">
          <source>The command that is running: &lt;code&gt;CREATE INDEX&lt;/code&gt;, &lt;code&gt;CREATE INDEX CONCURRENTLY&lt;/code&gt;, &lt;code&gt;REINDEX&lt;/code&gt;, or &lt;code&gt;REINDEX CONCURRENTLY&lt;/code&gt;.</source>
          <target state="translated">実行中のコマンド： &lt;code&gt;CREATE INDEX&lt;/code&gt; 、 &lt;code&gt;CREATE INDEX CONCURRENTLY&lt;/code&gt; 、 &lt;code&gt;REINDEX&lt;/code&gt; 、または &lt;code&gt;REINDEX CONCURRENTLY&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="559d421f3432d35c3d9a8fb5131571d6eb8752e8" translate="yes" xml:space="preserve">
          <source>The command to which the policy applies. Valid options are &lt;code&gt;ALL&lt;/code&gt;, &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, and &lt;code&gt;DELETE&lt;/code&gt;. &lt;code&gt;ALL&lt;/code&gt; is the default. See below for specifics regarding how these are applied.</source>
          <target state="translated">ポリシーが適用されるコマンド。有効なオプションは、 &lt;code&gt;ALL&lt;/code&gt; 、 &lt;code&gt;SELECT&lt;/code&gt; 、 &lt;code&gt;INSERT&lt;/code&gt; 、 &lt;code&gt;UPDATE&lt;/code&gt; 、および &lt;code&gt;DELETE&lt;/code&gt; です。 &lt;code&gt;ALL&lt;/code&gt; がデフォルトです。これらの適用方法の詳細については、以下を参照してください。</target>
        </trans-unit>
        <trans-unit id="7852202b8a6003f108d83f18dfb4650d44b65813" translate="yes" xml:space="preserve">
          <source>The command type to which the policy is applied</source>
          <target state="translated">ポリシーを適用するコマンドタイプ</target>
        </trans-unit>
        <trans-unit id="6c49af8969ccfcd1693376760717e08595698aa9" translate="yes" xml:space="preserve">
          <source>The command type to which the policy is applied: &lt;code&gt;r&lt;/code&gt; for &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;a&lt;/code&gt; for &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;w&lt;/code&gt; for &lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;d&lt;/code&gt; for &lt;code&gt;DELETE&lt;/code&gt;, or &lt;code&gt;*&lt;/code&gt; for all</source>
          <target state="translated">ポリシーが適用されるコマンドタイプ： &lt;code&gt;r&lt;/code&gt; は &lt;code&gt;SELECT&lt;/code&gt; 、 &lt;code&gt;a&lt;/code&gt; は &lt;code&gt;INSERT&lt;/code&gt; 、 &lt;code&gt;w&lt;/code&gt; は &lt;code&gt;UPDATE&lt;/code&gt; 、 &lt;code&gt;d&lt;/code&gt; は &lt;code&gt;DELETE&lt;/code&gt; 、または &lt;code&gt;*&lt;/code&gt; はすべて</target>
        </trans-unit>
        <trans-unit id="31a55b9a99200f37a1fc91d5f4fc188806cc57ad" translate="yes" xml:space="preserve">
          <source>The command's result is a textual description of the plan selected for the &lt;code&gt;statement&lt;/code&gt;, optionally annotated with execution statistics. &lt;a href=&quot;using-explain&quot;&gt;Section 14.1&lt;/a&gt; describes the information provided.</source>
          <target state="translated">コマンドの結果は、 &lt;code&gt;statement&lt;/code&gt; に対して選択されたプランのテキストによる説明であり、オプションで実行統計情報が注釈として付けられます。&lt;a href=&quot;using-explain&quot;&gt;セクション14.1&lt;/a&gt;では、提供される情報について説明します。</target>
        </trans-unit>
        <trans-unit id="40e0a2632f98d43624e2ba898ef7cc5bdd1cf8c1" translate="yes" xml:space="preserve">
          <source>The command-line history is stored in the file &lt;code&gt;~/.psql_history&lt;/code&gt;, or &lt;code&gt;%APPDATA%\postgresql\psql_history&lt;/code&gt; on Windows.</source>
          <target state="translated">コマンドライン履歴は、ファイル &lt;code&gt;~/.psql_history&lt;/code&gt; 、またはWindowsでは &lt;code&gt;%APPDATA%\postgresql\psql_history&lt;/code&gt; れます。</target>
        </trans-unit>
        <trans-unit id="f9e42c3efb15d8e677dc2308149404249d782207" translate="yes" xml:space="preserve">
          <source>The command-line-style arguments specified in &lt;code&gt;extra-options&lt;/code&gt; are passed to all server processes started by this &lt;code&gt;postgres&lt;/code&gt; process.</source>
          <target state="translated">&lt;code&gt;extra-options&lt;/code&gt; で指定されたコマンドラインスタイルの引数は、この &lt;code&gt;postgres&lt;/code&gt; プロセスによって開始されたすべてのサーバープロセスに渡されます。</target>
        </trans-unit>
        <trans-unit id="360d0f8394d720d22156d27a3f3ab0d50f8729e3" translate="yes" xml:space="preserve">
          <source>The commands &lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;, and &lt;code&gt;INSERT&lt;/code&gt; acquire this lock mode on the target table (in addition to &lt;code&gt;ACCESS SHARE&lt;/code&gt; locks on any other referenced tables). In general, this lock mode will be acquired by any command that &lt;em&gt;modifies data&lt;/em&gt; in a table.</source>
          <target state="translated">コマンド &lt;code&gt;UPDATE&lt;/code&gt; 、 &lt;code&gt;DELETE&lt;/code&gt; 、および &lt;code&gt;INSERT&lt;/code&gt; は、（他の参照されるテーブルの &lt;code&gt;ACCESS SHARE&lt;/code&gt; ロックに加えて）ターゲットテーブルでこのロックモードを取得します。一般に、このロックモードは、テーブルの&lt;em&gt;データ&lt;/em&gt;を&lt;em&gt;変更する&lt;/em&gt;コマンドによって取得されます。</target>
        </trans-unit>
        <trans-unit id="b120614b8a1edecdcf4c676c85b59acab98338cc" translate="yes" xml:space="preserve">
          <source>The commutator of this operator.</source>
          <target state="translated">この演算子の整流子。</target>
        </trans-unit>
        <trans-unit id="f6803da73417ed20d6aa993c5529f00237b3f6a3" translate="yes" xml:space="preserve">
          <source>The compatibility notes of the &lt;a href=&quot;sql-grant&quot;&gt;GRANT&lt;/a&gt; command apply analogously to &lt;code&gt;REVOKE&lt;/code&gt;. The keyword &lt;code&gt;RESTRICT&lt;/code&gt; or &lt;code&gt;CASCADE&lt;/code&gt; is required according to the standard, but PostgreSQL assumes &lt;code&gt;RESTRICT&lt;/code&gt; by default.</source>
          <target state="translated">互換性ノート&lt;a href=&quot;sql-grant&quot;&gt;のGRANT&lt;/a&gt;コマンドは、と同様に適用されます &lt;code&gt;REVOKE&lt;/code&gt; 。標準ではキーワード &lt;code&gt;RESTRICT&lt;/code&gt; または &lt;code&gt;CASCADE&lt;/code&gt; が必要ですが、PostgreSQL ではデフォルトで &lt;code&gt;RESTRICT&lt;/code&gt; が想定されています。</target>
        </trans-unit>
        <trans-unit id="40702de9ee6c2366268d72254909613dec0511c4" translate="yes" xml:space="preserve">
          <source>The complete lack of these facilities is usually manifested by an &amp;ldquo;Illegal system call&amp;rdquo; error upon server start. In that case there is no alternative but to reconfigure your kernel. PostgreSQL won't work without them. This situation is rare, however, among modern operating systems.</source>
          <target state="translated">これらの機能の完全な欠如は、通常、サーバー起動時の「不正なシステムコール」エラーによって明らかになります。その場合、カーネルを再構成する以外に方法はありません。PostgreSQLはそれらなしでは動作しません。ただし、最近のオペレーティングシステムでは、このような状況はまれです。</target>
        </trans-unit>
        <trans-unit id="8728921721ecf34d843d2d7d08bdc9c0ecc2f84b" translate="yes" xml:space="preserve">
          <source>The composite output routine will put double quotes around field values if they are empty strings or contain parentheses, commas, double quotes, backslashes, or white space. (Doing so for white space is not essential, but aids legibility.) Double quotes and backslashes embedded in field values will be doubled.</source>
          <target state="translated">複合出力ルーチンは、フィールド値が空の文字列であったり、括弧、カンマ、二重引用符、バックスラッシュ、または空白が含まれている場合には、フィールド値の周りに二重引用符を配置します。フィールド値に埋め込まれた二重引用符とバックスラッシュは二重になります。</target>
        </trans-unit>
        <trans-unit id="7b5e42f8ee02c00c89066a781bb2783e80203625" translate="yes" xml:space="preserve">
          <source>The compression technique used for either in-line or out-of-line compressed data is a fairly simple and very fast member of the LZ family of compression techniques. See &lt;code&gt;src/common/pg_lzcompress.c&lt;/code&gt; for the details.</source>
          <target state="translated">インラインまたはアウトオブラインの圧縮データに使用される圧縮技術は、LZファミリーの圧縮技術のかなり単純で非常に高速なメンバーです。詳細については &lt;code&gt;src/common/pg_lzcompress.c&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="74936e59660e5e1e74d04f83302b0b914fcee784" translate="yes" xml:space="preserve">
          <source>The concatenation operator allows a single element to be pushed onto the beginning or end of a one-dimensional array. It also accepts two &lt;code&gt;N&lt;/code&gt;-dimensional arrays, or an &lt;code&gt;N&lt;/code&gt;-dimensional and an &lt;code&gt;N+1&lt;/code&gt;-dimensional array.</source>
          <target state="translated">連結演算子を使用すると、1つの要素を1次元配列の先頭または末尾にプッシュできます。また、2つの受け入れ &lt;code&gt;N&lt;/code&gt; 次元アレイ、または &lt;code&gt;N&lt;/code&gt; 次元と &lt;code&gt;N+1&lt;/code&gt; 次元アレイ。</target>
        </trans-unit>
        <trans-unit id="4e300a4f5e6f2c02a48d5242548de8a6b349eea4" translate="yes" xml:space="preserve">
          <source>The concept that multiple independent operations happen within the &lt;a href=&quot;glossary#GLOSSARY-DATABASE&quot;&gt;database&lt;/a&gt; at the same time. In PostgreSQL, concurrency is controlled by the &lt;a href=&quot;glossary#GLOSSARY-MVCC&quot;&gt;multiversion concurrency control&lt;/a&gt; mechanism.</source>
          <target state="translated">複数の独立した操作が&lt;a href=&quot;glossary#GLOSSARY-DATABASE&quot;&gt;データベース内&lt;/a&gt;で同時に発生するという概念。PostgreSQLでは、同時実行は&lt;a href=&quot;glossary#GLOSSARY-MVCC&quot;&gt;マルチバージョン同時実行制御&lt;/a&gt;メカニズムによって制御されます。</target>
        </trans-unit>
        <trans-unit id="5239ff4b58c91e7e13723e3163e22ecae35f6c6f" translate="yes" xml:space="preserve">
          <source>The condition &lt;code&gt;t1.hundred &amp;lt; t2.hundred&lt;/code&gt; can't be tested in the &lt;code&gt;tenk2_unique2&lt;/code&gt; index, so it's applied at the join node. This reduces the estimated output row count of the join node, but does not change either input scan.</source>
          <target state="translated">条件 &lt;code&gt;t1.hundred &amp;lt; t2.hundred&lt;/code&gt; は &lt;code&gt;tenk2_unique2&lt;/code&gt; インデックスでテストできないため、結合ノードで適用されます。これにより、結合ノードの推定出力行数が減少しますが、入力スキャンは変更されません。</target>
        </trans-unit>
        <trans-unit id="c068c3abe0f845f75d348f1e71b7501c9e85d719" translate="yes" xml:space="preserve">
          <source>The configuration file is reread whenever the main server process receives a SIGHUP signal; this signal is most easily sent by running &lt;code&gt;pg_ctl reload&lt;/code&gt; from the command line or by calling the SQL function &lt;code&gt;pg_reload_conf()&lt;/code&gt;. The main server process also propagates this signal to all currently running server processes, so that existing sessions also adopt the new values (this will happen after they complete any currently-executing client command). Alternatively, you can send the signal to a single server process directly. Some parameters can only be set at server start; any changes to their entries in the configuration file will be ignored until the server is restarted. Invalid parameter settings in the configuration file are likewise ignored (but logged) during SIGHUP processing.</source>
          <target state="translated">メインサーバープロセスがSIGHUPシグナルを受信するたびに、構成ファイルが再読み取りされます。このシグナルは、コマンドラインから &lt;code&gt;pg_ctl reload&lt;/code&gt; を実行するか、SQL関数 &lt;code&gt;pg_reload_conf()&lt;/code&gt; を呼び出すことによって最も簡単に送信されます。また、メインサーバープロセスはこの信号を現在実行中のすべてのサーバープロセスに伝達するため、既存のセッションも新しい値を採用します（これは、現在実行中のクライアントコマンドが完了した後に発生します）。または、シグナルを単一のサーバープロセスに直接送信することもできます。一部のパラメータはサーバーの起動時にのみ設定できます。構成ファイル内のエントリへの変更は、サーバーが再起動されるまで無視されます。同様に、構成ファイル内の無効なパラメーター設定は、SIGHUP処理中に無視されます（ただしログに記録されます）。</target>
        </trans-unit>
        <trans-unit id="b9dccd142849bf4c5f5639f61a51dab8e56e5d09" translate="yes" xml:space="preserve">
          <source>The configuration variable &lt;a href=&quot;runtime-config-query#GUC-JIT&quot;&gt;jit&lt;/a&gt; determines whether JIT compilation is enabled or disabled. If it is enabled, the configuration variables &lt;a href=&quot;runtime-config-query#GUC-JIT-ABOVE-COST&quot;&gt;jit_above_cost&lt;/a&gt;, &lt;a href=&quot;runtime-config-query#GUC-JIT-INLINE-ABOVE-COST&quot;&gt;jit_inline_above_cost&lt;/a&gt;, and &lt;a href=&quot;runtime-config-query#GUC-JIT-OPTIMIZE-ABOVE-COST&quot;&gt;jit_optimize_above_cost&lt;/a&gt; determine whether JIT compilation is performed for a query, and how much effort is spent doing so.</source>
          <target state="translated">構成変数&lt;a href=&quot;runtime-config-query#GUC-JIT&quot;&gt;jit&lt;/a&gt;は、JITコンパイルを有効にするか無効にするかを決定します。有効になっている場合、設定変数&lt;a href=&quot;runtime-config-query#GUC-JIT-ABOVE-COST&quot;&gt;jit_above_cost&lt;/a&gt;、&lt;a href=&quot;runtime-config-query#GUC-JIT-INLINE-ABOVE-COST&quot;&gt;jit_inline_above_cost&lt;/a&gt;、および&lt;a href=&quot;runtime-config-query#GUC-JIT-OPTIMIZE-ABOVE-COST&quot;&gt;jit_optimize_above_cost&lt;/a&gt;は、クエリに対してJITコンパイルが実行されるかどうか、および実行に費やされる労力を決定します。</target>
        </trans-unit>
        <trans-unit id="19797f9713f4025f6738d996f66f2f16f1bb3ee3" translate="yes" xml:space="preserve">
          <source>The connection must be to the same database used to create the slot.</source>
          <target state="translated">接続先は、スロットを作成するために使用したのと同じデータベースでなければなりません。</target>
        </trans-unit>
        <trans-unit id="cbc80489eb4bf174c233f6bbbaa42452b7d3d86f" translate="yes" xml:space="preserve">
          <source>The connection string should specify the host name (or address) of the sending server, as well as the port number if it is not the same as the standby server's default. Also specify a user name corresponding to a suitably-privileged role on the sending server (see &lt;a href=&quot;warm-standby#STREAMING-REPLICATION-AUTHENTICATION&quot;&gt;Section 26.2.5.1&lt;/a&gt;). A password needs to be provided too, if the sender demands password authentication. It can be provided in the &lt;code&gt;primary_conninfo&lt;/code&gt; string, or in a separate &lt;code&gt;~/.pgpass&lt;/code&gt; file on the standby server (use &lt;code&gt;replication&lt;/code&gt; as the database name). Do not specify a database name in the &lt;code&gt;primary_conninfo&lt;/code&gt; string.</source>
          <target state="translated">接続文字列は、送信サーバーのホスト名（またはアドレス）と、スタンバイサーバーのデフォルトと異なる場合はポート番号を指定する必要があります。また、送信側サーバーの適切な特権を持つロールに対応するユーザー名を指定します（&lt;a href=&quot;warm-standby#STREAMING-REPLICATION-AUTHENTICATION&quot;&gt;セクション26.2.5.1を&lt;/a&gt;参照）。送信者がパスワード認証を要求する場合、パスワードも提供する必要があります。これは、 &lt;code&gt;primary_conninfo&lt;/code&gt; 文字列、またはスタンバイサーバー上の別の &lt;code&gt;~/.pgpass&lt;/code&gt; ファイルで提供できます（データベース名として &lt;code&gt;replication&lt;/code&gt; を使用）。 &lt;code&gt;primary_conninfo&lt;/code&gt; 文字列にデータベース名を指定しないでください。</target>
        </trans-unit>
        <trans-unit id="31fcb6829f600da0b565f01362ffaf255feb5d94" translate="yes" xml:space="preserve">
          <source>The connection string to the publisher. For details see &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-connect.html#LIBPQ-CONNSTRING&quot;&gt;Section 33.1.1&lt;/a&gt;.</source>
          <target state="translated">パブリッシャーへの接続文字列。詳細については、&lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-connect.html#LIBPQ-CONNSTRING&quot;&gt;セクション33.1.1を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="3910ec7c4e89817bfb9d10225155392dd277cac9" translate="yes" xml:space="preserve">
          <source>The connection string to the publisher. For details see &lt;a href=&quot;https://www.postgresql.org/docs/13/libpq-connect.html#LIBPQ-CONNSTRING&quot;&gt;Section 33.1.1&lt;/a&gt;.</source>
          <target state="translated">パブリッシャーへの接続文字列。詳細については、&lt;a href=&quot;https://www.postgresql.org/docs/13/libpq-connect.html#LIBPQ-CONNSTRING&quot;&gt;セクション33.1.1を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="164c7293cd6f4e265338f6fb352f7b98d06266a8" translate="yes" xml:space="preserve">
          <source>The constraint expression for a partial index.</source>
          <target state="translated">部分インデックスの制約式。</target>
        </trans-unit>
        <trans-unit id="0a023003d324d129028d83c645a2d4429045b67a" translate="yes" xml:space="preserve">
          <source>The constraint will be checked immediately, so the table data must satisfy the constraint before it can be added.</source>
          <target state="translated">制約はすぐにチェックされるので、テーブルデータは制約を満たしていないと追加できません。</target>
        </trans-unit>
        <trans-unit id="f753df8000fdee9203aa2be3a2862eb377d770ad" translate="yes" xml:space="preserve">
          <source>The construct &lt;code&gt;(a, b)&lt;/code&gt; is normally recognized in expressions as a &lt;a href=&quot;sql-expressions#SQL-SYNTAX-ROW-CONSTRUCTORS&quot;&gt;row constructor&lt;/a&gt;. Within the &lt;code&gt;GROUP BY&lt;/code&gt; clause, this does not apply at the top levels of expressions, and &lt;code&gt;(a, b)&lt;/code&gt; is parsed as a list of expressions as described above. If for some reason you &lt;em&gt;need&lt;/em&gt; a row constructor in a grouping expression, use &lt;code&gt;ROW(a, b)&lt;/code&gt;.</source>
          <target state="translated">構文 &lt;code&gt;(a, b)&lt;/code&gt; は、通常、式では&lt;a href=&quot;sql-expressions#SQL-SYNTAX-ROW-CONSTRUCTORS&quot;&gt;行コンストラクター&lt;/a&gt;として認識されます。 &lt;code&gt;GROUP BY&lt;/code&gt; 句内では、これは式の最上位には適用されず、 &lt;code&gt;(a, b)&lt;/code&gt; は上記のように式のリストとして解析されます。何らかの理由でグループ化式で行コンストラクターが&lt;em&gt;必要な&lt;/em&gt;場合は、 &lt;code&gt;ROW(a, b)&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="bdace32fdb5c0027816e247b4bd1b7fb7ff95259" translate="yes" xml:space="preserve">
          <source>The contents of tables and indexes are discussed further in &lt;a href=&quot;storage-page-layout&quot;&gt;Section 68.6&lt;/a&gt;.</source>
          <target state="translated">テーブルとインデックスの内容については、&lt;a href=&quot;storage-page-layout&quot;&gt;セクション68.6で&lt;/a&gt;詳しく説明します。</target>
        </trans-unit>
        <trans-unit id="38f47269fb5aeb6c838c026cdcf1f0ae2ecfc4fc" translate="yes" xml:space="preserve">
          <source>The contents of the WAL buffers are written out to disk at every transaction commit, so extremely large values are unlikely to provide a significant benefit. However, setting this value to at least a few megabytes can improve write performance on a busy server where many clients are committing at once. The auto-tuning selected by the default setting of -1 should give reasonable results in most cases.</source>
          <target state="translated">WALバッファの内容はトランザクションのコミットごとにディスクに書き出されるので、極端に大きな値を設定しても大きなメリットにはならないでしょう。しかし、この値を少なくとも数メガバイトに設定することで、多くのクライアントが一度にコミットするような忙しいサーバでは、書き込みパフォーマンスを向上させることができます。デフォルト設定の-1で選択されている自動調整は、ほとんどの場合でそれなりの結果をもたらすはずです。</target>
        </trans-unit>
        <trans-unit id="b1c6502d2f4ffe992973e02c33536a28b4746870" translate="yes" xml:space="preserve">
          <source>The contents of the directories &lt;code&gt;pg_dynshmem/&lt;/code&gt;, &lt;code&gt;pg_notify/&lt;/code&gt;, &lt;code&gt;pg_serial/&lt;/code&gt;, &lt;code&gt;pg_snapshots/&lt;/code&gt;, &lt;code&gt;pg_stat_tmp/&lt;/code&gt;, and &lt;code&gt;pg_subtrans/&lt;/code&gt; (but not the directories themselves) can be omitted from the backup as they will be initialized on postmaster startup. If &lt;a href=&quot;runtime-config-statistics#GUC-STATS-TEMP-DIRECTORY&quot;&gt;stats_temp_directory&lt;/a&gt; is set and is under the data directory then the contents of that directory can also be omitted.</source>
          <target state="translated">ディレクトリ &lt;code&gt;pg_dynshmem/&lt;/code&gt; 、 &lt;code&gt;pg_notify/&lt;/code&gt; 、 &lt;code&gt;pg_serial/&lt;/code&gt; 、 &lt;code&gt;pg_snapshots/&lt;/code&gt; 、 &lt;code&gt;pg_stat_tmp/&lt;/code&gt; 、および &lt;code&gt;pg_subtrans/&lt;/code&gt; （ディレクトリ自体ではなく）の内容は、ポストマスターの起動時に初期化されるため、バックアップから除外できます。場合&lt;a href=&quot;runtime-config-statistics#GUC-STATS-TEMP-DIRECTORY&quot;&gt;をstats_temp_directoryが&lt;/a&gt;セットされ、データディレクトリの下にある、そのディレクトリの内容を省略することもできます。</target>
        </trans-unit>
        <trans-unit id="3de8d3c890918676d736b678933d22a18ab061b7" translate="yes" xml:space="preserve">
          <source>The convention followed by the operator classes included with the core PostgreSQL distribution is to register a stock, generic &lt;code&gt;equalimage&lt;/code&gt; function. Most operator classes register &lt;code&gt;btequalimage()&lt;/code&gt;, which indicates that deduplication is safe unconditionally. Operator classes for collatable data types such as &lt;code&gt;text&lt;/code&gt; register &lt;code&gt;btvarstrequalimage()&lt;/code&gt;, which indicates that deduplication is safe with deterministic collations. Best practice for third-party extensions is to register their own custom function to retain control.</source>
          <target state="translated">コアPostgreSQLディストリビューションに含まれている演算子クラスが従う規則は、ストックの汎用 &lt;code&gt;equalimage&lt;/code&gt; 関数を登録することです。ほとんどの演算子クラスは &lt;code&gt;btequalimage()&lt;/code&gt; を登録します。これは、重複排除が無条件に安全であることを示します。 &lt;code&gt;text&lt;/code&gt; レジスタ &lt;code&gt;btvarstrequalimage()&lt;/code&gt; などの照合可能なデータ型の演算子クラス。これは、決定論的な照合で重複排除が安全であることを示します。サードパーティの拡張機能のベストプラクティスは、独自のカスタム関数を登録して制御を維持することです。</target>
        </trans-unit>
        <trans-unit id="46e0411ab62d3d86cfefc61b32fd0a5818262ee5" translate="yes" xml:space="preserve">
          <source>The conversion rules presented here are not exactly those of the SQL standard, as discussed in &lt;a href=&quot;xml-limits-conformance#FUNCTIONS-XML-LIMITS-CASTS&quot;&gt;Section D.3.1.3&lt;/a&gt;.</source>
          <target state="translated">ここに示す変換ルールは、&lt;a href=&quot;xml-limits-conformance#FUNCTIONS-XML-LIMITS-CASTS&quot;&gt;D.3.1.3項で&lt;/a&gt;説明したように、SQL標準のものとは厳密には異なります。</target>
        </trans-unit>
        <trans-unit id="93003637d33db2eb4895822b5caba9508ac9a024" translate="yes" xml:space="preserve">
          <source>The coordinates of an individual in the search space are represented by &lt;em&gt;chromosomes&lt;/em&gt;, in essence a set of character strings. A &lt;em&gt;gene&lt;/em&gt; is a subsection of a chromosome which encodes the value of a single parameter being optimized. Typical encodings for a gene could be &lt;em&gt;binary&lt;/em&gt; or &lt;em&gt;integer&lt;/em&gt;.</source>
          <target state="translated">サーチスペース内の個人の座標は、基本的には文字列のセットである&lt;em&gt;染色体&lt;/em&gt;によって表されます。&lt;em&gt;遺伝子は、&lt;/em&gt;最適化される単一のパラメータの値を符号化する染色体のサブセクションです。遺伝子の一般的なエンコーディングは、&lt;em&gt;バイナリ&lt;/em&gt;または&lt;em&gt;整数&lt;/em&gt;です。</target>
        </trans-unit>
        <trans-unit id="862293286080d0a9f0113978ebf74556e90249fd" translate="yes" xml:space="preserve">
          <source>The core PostgreSQL distribution includes the BRIN operator classes shown in &lt;a href=&quot;brin-builtin-opclasses#BRIN-BUILTIN-OPCLASSES-TABLE&quot;&gt;Table 67.1&lt;/a&gt;.</source>
          <target state="translated">コアPostgreSQLディストリビューションには、&lt;a href=&quot;brin-builtin-opclasses#BRIN-BUILTIN-OPCLASSES-TABLE&quot;&gt;表67.1に&lt;/a&gt;示すBRIN演算子クラスが含まれています。</target>
        </trans-unit>
        <trans-unit id="7243c976dc744d56b010e5d36a8288b88892f5dc" translate="yes" xml:space="preserve">
          <source>The core PostgreSQL distribution includes the GIN operator classes previously shown in &lt;a href=&quot;gin-builtin-opclasses#GIN-BUILTIN-OPCLASSES-TABLE&quot;&gt;Table 66.1&lt;/a&gt;. The following &lt;code&gt;contrib&lt;/code&gt; modules also contain GIN operator classes:</source>
          <target state="translated">コアPostgreSQLディストリビューションには、以前に&lt;a href=&quot;gin-builtin-opclasses#GIN-BUILTIN-OPCLASSES-TABLE&quot;&gt;表66.1に&lt;/a&gt;示したGIN演算子クラスが含まれています。次の &lt;code&gt;contrib&lt;/code&gt; モジュールには、GIN演算子クラスも含まれています。</target>
        </trans-unit>
        <trans-unit id="c2fbf40f11cf35a0a12e58dfa2d5f0d5377fea85" translate="yes" xml:space="preserve">
          <source>The core PostgreSQL distribution includes the GIN operator classes shown in &lt;a href=&quot;gin-builtin-opclasses#GIN-BUILTIN-OPCLASSES-TABLE&quot;&gt;Table 66.1&lt;/a&gt;. (Some of the optional modules described in &lt;a href=&quot;https://www.postgresql.org/docs/12/contrib.html&quot;&gt;Appendix F&lt;/a&gt; provide additional GIN operator classes.)</source>
          <target state="translated">コアPostgreSQLディストリビューションには、&lt;a href=&quot;gin-builtin-opclasses#GIN-BUILTIN-OPCLASSES-TABLE&quot;&gt;表66.1に&lt;/a&gt;示すGIN演算子クラスが含まれています。（&lt;a href=&quot;https://www.postgresql.org/docs/12/contrib.html&quot;&gt;付録Fで&lt;/a&gt;説明されている一部のオプションモジュールは、追加のGIN演算子クラスを提供します。）</target>
        </trans-unit>
        <trans-unit id="806d720c4b8fe7fcc17e70e9b466b37e2e2f856b" translate="yes" xml:space="preserve">
          <source>The core PostgreSQL distribution includes the GIN operator classes shown in &lt;a href=&quot;gin-builtin-opclasses#GIN-BUILTIN-OPCLASSES-TABLE&quot;&gt;Table 66.1&lt;/a&gt;. (Some of the optional modules described in &lt;a href=&quot;https://www.postgresql.org/docs/13/contrib.html&quot;&gt;Appendix F&lt;/a&gt; provide additional GIN operator classes.)</source>
          <target state="translated">コアPostgreSQLディストリビューションには、&lt;a href=&quot;gin-builtin-opclasses#GIN-BUILTIN-OPCLASSES-TABLE&quot;&gt;表66.1に&lt;/a&gt;示すGIN演算子クラスが含まれています。（&lt;a href=&quot;https://www.postgresql.org/docs/13/contrib.html&quot;&gt;付録Fで&lt;/a&gt;説明されているオプションモジュールの一部は、追加のGINオペレータークラスを提供します。）</target>
        </trans-unit>
        <trans-unit id="3d8a9d6f1f395ae01d0f93e48fe3bca4cc653cd4" translate="yes" xml:space="preserve">
          <source>The core PostgreSQL distribution includes the GiST operator classes shown in &lt;a href=&quot;gist-builtin-opclasses#GIST-BUILTIN-OPCLASSES-TABLE&quot;&gt;Table 64.1&lt;/a&gt;. (Some of the optional modules described in &lt;a href=&quot;https://www.postgresql.org/docs/12/contrib.html&quot;&gt;Appendix F&lt;/a&gt; provide additional GiST operator classes.)</source>
          <target state="translated">コアPostgreSQLディストリビューションには、&lt;a href=&quot;gist-builtin-opclasses#GIST-BUILTIN-OPCLASSES-TABLE&quot;&gt;表64.1に&lt;/a&gt;示すGiST演算子クラスが含まれています。（&lt;a href=&quot;https://www.postgresql.org/docs/12/contrib.html&quot;&gt;付録Fで&lt;/a&gt;説明されている一部のオプションモジュールは、追加のGiST演算子クラスを提供します。）</target>
        </trans-unit>
        <trans-unit id="0cf2930ff562138360e1ed4d1a72443d736ec8f6" translate="yes" xml:space="preserve">
          <source>The core PostgreSQL distribution includes the GiST operator classes shown in &lt;a href=&quot;gist-builtin-opclasses#GIST-BUILTIN-OPCLASSES-TABLE&quot;&gt;Table 64.1&lt;/a&gt;. (Some of the optional modules described in &lt;a href=&quot;https://www.postgresql.org/docs/13/contrib.html&quot;&gt;Appendix F&lt;/a&gt; provide additional GiST operator classes.)</source>
          <target state="translated">コアPostgreSQLディストリビューションには、&lt;a href=&quot;gist-builtin-opclasses#GIST-BUILTIN-OPCLASSES-TABLE&quot;&gt;表64.1に&lt;/a&gt;示すGiSTオペレータークラスが含まれています。（&lt;a href=&quot;https://www.postgresql.org/docs/13/contrib.html&quot;&gt;付録Fで&lt;/a&gt;説明されているオプションモジュールの一部は、追加のGiSTオペレータークラスを提供します。）</target>
        </trans-unit>
        <trans-unit id="3d4f128e5e4ead669ae57136a3aca466199dcb9f" translate="yes" xml:space="preserve">
          <source>The core PostgreSQL distribution includes the SP-GiST operator classes shown in &lt;a href=&quot;spgist-builtin-opclasses#SPGIST-BUILTIN-OPCLASSES-TABLE&quot;&gt;Table 65.1&lt;/a&gt;.</source>
          <target state="translated">コアPostgreSQLディストリビューションには、&lt;a href=&quot;spgist-builtin-opclasses#SPGIST-BUILTIN-OPCLASSES-TABLE&quot;&gt;表65.1に&lt;/a&gt;示すSP-GiST演算子クラスが含まれています。</target>
        </trans-unit>
        <trans-unit id="05fafa81f43ebb1970323c27149ee647ab30ffe3" translate="yes" xml:space="preserve">
          <source>The core code is fundamentally unable to deduce anything about the &amp;ldquo;equality implies image equality&amp;rdquo; status of an operator class within a multiple-data-type family based on details from other operator classes in the same family. Also, it is not sensible for an operator family to register a cross-type &lt;code&gt;equalimage&lt;/code&gt; function, and attempting to do so will result in an error. This is because &amp;ldquo;equality implies image equality&amp;rdquo; status does not just depend on sorting/equality semantics, which are more or less defined at the operator family level. In general, the semantics that one particular data type implements must be considered separately.</source>
          <target state="translated">コアコードは基本的に、同じファミリ内の他の演算子クラスからの詳細に基づいて、複数データ型ファミリ内の演算子クラスの「同等性はイメージの同等性を意味する」ステータスについて何も推測できません。また、演算子ファミリがクロスタイプの等 &lt;code&gt;equalimage&lt;/code&gt; 関数を登録することは意味がなく、登録しようとするとエラーが発生します。これは、「平等は画像の平等を意味する」ステータスが、演算子ファミリレベルで多かれ少なかれ定義されている並べ替え/平等のセマンティクスに依存するだけではないためです。一般に、1つの特定のデータ型が実装するセマンティクスは個別に検討する必要があります。</target>
        </trans-unit>
        <trans-unit id="89a856912c9ac553c9e328fb462dc4a3dc3f226a" translate="yes" xml:space="preserve">
          <source>The core distribution includes support for two types of operator classes: minmax and inclusion. Operator class definitions using them are shipped for in-core data types as appropriate. Additional operator classes can be defined by the user for other data types using equivalent definitions, without having to write any source code; appropriate catalog entries being declared is enough. Note that assumptions about the semantics of operator strategies are embedded in the support functions' source code.</source>
          <target state="translated">コア・ディストリビューションには、minmaxとinclusionの2種類の演算子クラスがサポートされています。これらを使用する演算子クラスの定義は、必要に応じてコア内のデータ型に対して出荷されます。追加の演算子クラスは、ソースコードを書かなくても、同等の定義を使用して他のデータ型に対してユーザが定義することができます。演算子ストラテジーのセマンティクスに関する仮定は、サポート関数のソースコードに埋め込まれていることに注意してください。</target>
        </trans-unit>
        <trans-unit id="c6af74783e2e512b02fff35f8b9b1611ba92c8bc" translate="yes" xml:space="preserve">
          <source>The corresponding column will be filled with its default value.</source>
          <target state="translated">対応する列はデフォルト値で埋められます。</target>
        </trans-unit>
        <trans-unit id="33e9a48b1e5df95c7200af8afb9a8f1b54ef12f2" translate="yes" xml:space="preserve">
          <source>The corresponding column will be filled with its default value. An identity column will be filled with a new value generated by the associated sequence. For a generated column, specifying this is permitted but merely specifies the normal behavior of computing the column from its generation expression.</source>
          <target state="translated">対応する列はデフォルト値で埋められます。ID 列は、関連するシーケンスによって生成された新しい値で埋められる。生成された列については、これを指定することは許可されていますが、単に生成式から列を計算する際の通常の動作を指定するだけです。</target>
        </trans-unit>
        <trans-unit id="39b1b5853e1b21f147904a21bac6120e0399eff4" translate="yes" xml:space="preserve">
          <source>The corresponding constraint in the parent partitioned table, if this is a constraint in a partition; else 0</source>
          <target state="translated">パーティション内の制約であれば、親パーティショニングされたテーブル内の対応する制約。</target>
        </trans-unit>
        <trans-unit id="e50bc6dd81573c8b84e401b93b09d0320c5165e6" translate="yes" xml:space="preserve">
          <source>The costs are measured in arbitrary units determined by the planner's cost parameters (see &lt;a href=&quot;runtime-config-query#RUNTIME-CONFIG-QUERY-CONSTANTS&quot;&gt;Section 19.7.2&lt;/a&gt;). Traditional practice is to measure the costs in units of disk page fetches; that is, &lt;a href=&quot;runtime-config-query#GUC-SEQ-PAGE-COST&quot;&gt;seq_page_cost&lt;/a&gt; is conventionally set to &lt;code&gt;1.0&lt;/code&gt; and the other cost parameters are set relative to that. The examples in this section are run with the default cost parameters.</source>
          <target state="translated">コストは、プランナのコストパラメータによって決定される任意の単位で測定されます（&lt;a href=&quot;runtime-config-query#RUNTIME-CONFIG-QUERY-CONSTANTS&quot;&gt;セクション19.7.2を&lt;/a&gt;参照）。従来の方法では、ディスクページフェッチの単位でコストを測定していました。つまり、&lt;a href=&quot;runtime-config-query#GUC-SEQ-PAGE-COST&quot;&gt;seq_page_cost&lt;/a&gt;は通常 &lt;code&gt;1.0&lt;/code&gt; に設定され、他のコストパラメータはそれに関連して設定されます。このセクションの例は、デフォルトのコストパラメータを使用して実行されます。</target>
        </trans-unit>
        <trans-unit id="40a2e5c659fc82ea65929c45fcbdccd61dafc250" translate="yes" xml:space="preserve">
          <source>The creation of a publication does not start replication. It only defines a grouping and filtering logic for future subscribers.</source>
          <target state="translated">パブリケーションの作成はレプリケーションを開始しません。それは、将来のサブスクライバのためのグループ化とフィルタリング・ロジックを定義するだけです。</target>
        </trans-unit>
        <trans-unit id="3e98adbd0156fb7d426b89504f191dda4a555319" translate="yes" xml:space="preserve">
          <source>The creation of databases is a restricted operation. See &lt;a href=&quot;role-attributes&quot;&gt;Section 21.2&lt;/a&gt; for how to grant permission.</source>
          <target state="translated">データベースの作成は制限された操作です。許可を与える方法については&lt;a href=&quot;role-attributes&quot;&gt;項21.2&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="1880291804157d355a896d197b0a52d8a09b04b7" translate="yes" xml:space="preserve">
          <source>The cube a contains the cube b.</source>
          <target state="translated">立方体aには立方体bが含まれています。</target>
        </trans-unit>
        <trans-unit id="375266423676b7d7beda6d0e513197403bfef8c1" translate="yes" xml:space="preserve">
          <source>The cube a is contained in the cube b.</source>
          <target state="translated">立方体aは立方体bに含まれています。</target>
        </trans-unit>
        <trans-unit id="b588f40bf468c3153645f14f27d51be8b21426c9" translate="yes" xml:space="preserve">
          <source>The cube a is greater than or equal to the cube b.</source>
          <target state="translated">立方体aは立方体b以上である。</target>
        </trans-unit>
        <trans-unit id="2f01cfa360b4f7c3692487eca6dd5b417fc389b3" translate="yes" xml:space="preserve">
          <source>The cube a is greater than the cube b.</source>
          <target state="translated">立方体aは立方体bよりも大きい。</target>
        </trans-unit>
        <trans-unit id="0e6cf54be6b186407704fdff88fc957131d4ed9b" translate="yes" xml:space="preserve">
          <source>The cube a is less than or equal to the cube b.</source>
          <target state="translated">立方体aは、立方体b以下である。</target>
        </trans-unit>
        <trans-unit id="f2d342ff49043cacce0129a759922d79461a11fa" translate="yes" xml:space="preserve">
          <source>The cube a is less than the cube b.</source>
          <target state="translated">立方体aは立方体bよりも小さい。</target>
        </trans-unit>
        <trans-unit id="4634367f6224780d287c24528a5fced1237e5fa1" translate="yes" xml:space="preserve">
          <source>The cube a is not equal to the cube b.</source>
          <target state="translated">立方体aと立方体bは等しくない。</target>
        </trans-unit>
        <trans-unit id="45987f656860bb4eb975fa1cd72ba43bc699f956" translate="yes" xml:space="preserve">
          <source>The cubes a and b are identical.</source>
          <target state="translated">立方体のaとbは同じです。</target>
        </trans-unit>
        <trans-unit id="9213cf52b8d8a10f6b7daa93550fc8c65e89e83d" translate="yes" xml:space="preserve">
          <source>The cubes a and b overlap.</source>
          <target state="translated">立方体のaとbが重なっている。</target>
        </trans-unit>
        <trans-unit id="1a1e2040f8ce058f3c38c6e6d3751c0a69992146" translate="yes" xml:space="preserve">
          <source>The current backend's &lt;code&gt;xmin&lt;/code&gt; horizon.</source>
          <target state="translated">現在のバックエンドの &lt;code&gt;xmin&lt;/code&gt; ホライズン。</target>
        </trans-unit>
        <trans-unit id="71bea49a2448467c39ae3d46b44b8328244be40c" translate="yes" xml:space="preserve">
          <source>The current client character set encoding. This is set every time you connect to a database (including program start-up), and when you change the encoding with &lt;code&gt;\encoding&lt;/code&gt;, but it can be changed or unset.</source>
          <target state="translated">現在のクライアントの文字セットエンコーディング。これは、データベースに接続するたびに（プログラムの起動を含む）、 &lt;code&gt;\encoding&lt;/code&gt; を使用してエンコードを変更するたびに設定されますが、変更または未設定にすることができます。</target>
        </trans-unit>
        <trans-unit id="0deea51724bf6c34acfe1425e13fc10373b6c41e" translate="yes" xml:space="preserve">
          <source>The current dimensions of any array value can be retrieved with the &lt;code&gt;array_dims&lt;/code&gt; function:</source>
          <target state="translated">任意の配列値の現在の次元は、 &lt;code&gt;array_dims&lt;/code&gt; 関数で取得できます。</target>
        </trans-unit>
        <trans-unit id="8c3a8302b74a0c1c2418c7953403859316142fae" translate="yes" xml:space="preserve">
          <source>The current effective value of the search path can be examined via the SQL function &lt;code&gt;current_schemas&lt;/code&gt; (see &lt;a href=&quot;functions-info&quot;&gt;Section 9.25&lt;/a&gt;). This is not quite the same as examining the value of &lt;code&gt;search_path&lt;/code&gt;, since &lt;code&gt;current_schemas&lt;/code&gt; shows how the items appearing in &lt;code&gt;search_path&lt;/code&gt; were resolved.</source>
          <target state="translated">検索パスの現在の有効値は、SQL関数 &lt;code&gt;current_schemas&lt;/code&gt; を使用して調べることができます（&lt;a href=&quot;functions-info&quot;&gt;セクション9.25を&lt;/a&gt;参照）。 &lt;code&gt;current_schemas&lt;/code&gt; は &lt;code&gt;search_path&lt;/code&gt; に現れる項目がどのように解決されたかを示すので、これは &lt;code&gt;search_path&lt;/code&gt; の値を調べることとはまったく同じではありません。</target>
        </trans-unit>
        <trans-unit id="197001cc9f21d760f60e1fb495baacfbe4512e51" translate="yes" xml:space="preserve">
          <source>The current effective value of the search path can be examined via the SQL function &lt;code&gt;current_schemas&lt;/code&gt; (see &lt;a href=&quot;functions-info&quot;&gt;Section 9.26&lt;/a&gt;). This is not quite the same as examining the value of &lt;code&gt;search_path&lt;/code&gt;, since &lt;code&gt;current_schemas&lt;/code&gt; shows how the items appearing in &lt;code&gt;search_path&lt;/code&gt; were resolved.</source>
          <target state="translated">検索パスの現在の有効値は、SQL関数 &lt;code&gt;current_schemas&lt;/code&gt; を介して調べることができます（&lt;a href=&quot;functions-info&quot;&gt;セクション9.26を&lt;/a&gt;参照）。 &lt;code&gt;current_schemas&lt;/code&gt; は、 &lt;code&gt;search_path&lt;/code&gt; に表示されるアイテムがどのように解決されたかを示すため、これは &lt;code&gt;search_path&lt;/code&gt; の値を調べることとまったく同じではありません。</target>
        </trans-unit>
        <trans-unit id="588306ac744664bcce2285f16a927597e5d43ed4" translate="yes" xml:space="preserve">
          <source>The current implementation does not enforce the declared number of dimensions either. Arrays of a particular element type are all considered to be of the same type, regardless of size or number of dimensions. So, declaring the array size or number of dimensions in &lt;code&gt;CREATE TABLE&lt;/code&gt; is simply documentation; it does not affect run-time behavior.</source>
          <target state="translated">現在の実装では、宣言された次元数も強制されません。特定の要素タイプの配列は、サイズや次元数に関係なく、すべて同じタイプであると見なされます。そのため、 &lt;code&gt;CREATE TABLE&lt;/code&gt; で配列サイズまたは次元数を宣言することは、単なるドキュメントです。実行時の動作には影響しません。</target>
        </trans-unit>
        <trans-unit id="03a220364aef06c1bbc7f574a82ccaeced5bea27" translate="yes" xml:space="preserve">
          <source>The current implementation has significant limitations, and does not enforce mandatory access control for all actions. See &lt;a href=&quot;sepgsql#SEPGSQL-LIMITATIONS&quot;&gt;Section F.35.7&lt;/a&gt;.</source>
          <target state="translated">現在の実装には重大な制限があり、すべてのアクションに必須のアクセス制御を適用していません。&lt;a href=&quot;sepgsql#SEPGSQL-LIMITATIONS&quot;&gt;セクションF.35.7を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="25210d55190c9236b389899a74a7b5704fff78d4" translate="yes" xml:space="preserve">
          <source>The current implementation of &lt;code&gt;unaccent&lt;/code&gt; cannot be used as a normalizing dictionary for the &lt;code&gt;thesaurus&lt;/code&gt; dictionary.</source>
          <target state="translated">&lt;code&gt;unaccent&lt;/code&gt; の現在の実装は、 &lt;code&gt;thesaurus&lt;/code&gt; 辞書の正規化辞書として使用できません。</target>
        </trans-unit>
        <trans-unit id="ed96c59248b01f330729c6c44b2035a2f3097a16" translate="yes" xml:space="preserve">
          <source>The current limitations of PostgreSQL's text search features are:</source>
          <target state="translated">現在のPostgreSQLのテキスト検索機能の限界は、以下の通りです。</target>
        </trans-unit>
        <trans-unit id="11ad6de9ae99189b133ed48695fe71e760901959" translate="yes" xml:space="preserve">
          <source>The cursor should be declared with the &lt;code&gt;SCROLL&lt;/code&gt; option if one intends to use any variants of &lt;code&gt;FETCH&lt;/code&gt; other than &lt;code&gt;FETCH NEXT&lt;/code&gt; or &lt;code&gt;FETCH FORWARD&lt;/code&gt; with a positive count. For simple queries PostgreSQL will allow backwards fetch from cursors not declared with &lt;code&gt;SCROLL&lt;/code&gt;, but this behavior is best not relied on. If the cursor is declared with &lt;code&gt;NO SCROLL&lt;/code&gt;, no backward fetches are allowed.</source>
          <target state="translated">カーソルを使用して宣言しなければならない &lt;code&gt;SCROLL&lt;/code&gt; の 1のいずれかのバリアントを使用しようとする場合のオプション &lt;code&gt;FETCH&lt;/code&gt; 以外の &lt;code&gt;FETCH NEXT&lt;/code&gt; または &lt;code&gt;FETCH FORWARD&lt;/code&gt; 正の数とします。単純なクエリの場合、PostgreSQLは &lt;code&gt;SCROLL&lt;/code&gt; で宣言されていないカーソルからの後方フェッチを許可しますが、この動作は依存しないのが最善です。カーソルが &lt;code&gt;NO SCROLL&lt;/code&gt; を指定して宣言されている場合、後方フェッチは許可されません。</target>
        </trans-unit>
        <trans-unit id="4f29dd59131cbd500833c5a80fec96f77393e7a4" translate="yes" xml:space="preserve">
          <source>The data distribution is very simple; there are only 100 distinct values in each column, uniformly distributed.</source>
          <target state="translated">データの分布は非常に単純で、各列には100個の異なる値が一様に分布しています。</target>
        </trans-unit>
        <trans-unit id="bf388f98f91dd65f88f15e7c3f1b408fc205654b" translate="yes" xml:space="preserve">
          <source>The data is prefixed with a block of random bytes. This is equivalent to using a random IV.</source>
          <target state="translated">データの前にはランダムバイトのブロックが付けられています。これは、ランダムIVを使用することに相当します。</target>
        </trans-unit>
        <trans-unit id="d53ba1352e33254f15d2784088350652d0fec89f" translate="yes" xml:space="preserve">
          <source>The data on the standby takes some time to arrive from the primary server so there will be a measurable delay between primary and standby. Running the same query nearly simultaneously on both primary and standby might therefore return differing results. We say that data on the standby is &lt;em&gt;eventually consistent&lt;/em&gt; with the primary. Once the commit record for a transaction is replayed on the standby, the changes made by that transaction will be visible to any new snapshots taken on the standby. Snapshots may be taken at the start of each query or at the start of each transaction, depending on the current transaction isolation level. For more details, see &lt;a href=&quot;transaction-iso&quot;&gt;Section 13.2&lt;/a&gt;.</source>
          <target state="translated">スタンバイのデータがプライマリサーバーから到着するまでに時間がかかるため、プライマリとスタンバイの間に測定可能な遅延が生じます。したがって、プライマリとスタンバイの両方で同じクエリをほぼ同時に実行すると、異なる結果が返される可能性があります。スタンバイ上のデータは、&lt;em&gt;最終的&lt;/em&gt;にはプライマリと&lt;em&gt;整合&lt;/em&gt;していると言えます。トランザクションのコミットレコードがスタンバイで再生されると、そのトランザクションによって行われた変更は、スタンバイで作成された新しいスナップショットに表示されます。現在のトランザクション分離レベルに応じて、各クエリの開始時または各トランザクションの開始時にスナップショットを取得できます。詳細については、&lt;a href=&quot;transaction-iso&quot;&gt;セクション13.2を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="0b4139483f5abc1e06390b32222b164b98282561" translate="yes" xml:space="preserve">
          <source>The data section contains actual table data as well as large-object definitions. Post-data items consist of definitions of indexes, triggers, rules and constraints other than validated check constraints. Pre-data items consist of all other data definition items.</source>
          <target state="translated">データセクションには、実際のテーブルデータとラージオブジェクトの定義が含まれています。ポストデータ項目は、有効なチェック制約以外のインデックス、トリガ、ルール、制約の定義で構成されています。プレデータ項目は、他のすべてのデータ定義項目で構成されています。</target>
        </trans-unit>
        <trans-unit id="e6ca4b823a5f4163ec85e2bd3fdf29af04d8b385" translate="yes" xml:space="preserve">
          <source>The data section contains actual table data, large-object contents, and sequence values. Post-data items include definitions of indexes, triggers, rules, and constraints other than validated check constraints. Pre-data items include all other data definition items.</source>
          <target state="translated">データセクションには、実際のテーブルデータ、ラージオブジェクトの内容、シーケンス値が含まれます。ポストデータ項目には、有効なチェック制約以外のインデックス、トリガ、ルール、制約の定義が含まれます。プリデータ項目には、他のすべてのデータ定義項目が含まれます。</target>
        </trans-unit>
        <trans-unit id="b17b79d26641dd87ba0c23b6c9bc174faa3a8b61" translate="yes" xml:space="preserve">
          <source>The data type &lt;code&gt;uuid&lt;/code&gt; stores Universally Unique Identifiers (UUID) as defined by RFC 4122, ISO/IEC 9834-8:2005, and related standards. (Some systems refer to this data type as a globally unique identifier, or GUID, instead.) This identifier is a 128-bit quantity that is generated by an algorithm chosen to make it very unlikely that the same identifier will be generated by anyone else in the known universe using the same algorithm. Therefore, for distributed systems, these identifiers provide a better uniqueness guarantee than sequence generators, which are only unique within a single database.</source>
          <target state="translated">データ型 &lt;code&gt;uuid&lt;/code&gt; は、RFC 4122、ISO / IEC 9834-8：2005、および関連する標準で定義されているUniversally Unique Identifier（UUID）を格納します。 （一部のシステムでは、このデータ型をグローバル一意識別子（GUID）と呼びます。）この識別子は、同じ識別子が他の誰かによって生成される可能性を低くするように選択されたアルゴリズムによって生成される128ビットの数量です。同じアルゴリズムを使用して既知の宇宙で。したがって、分散システムの場合、これらの識別子は、単一のデータベース内でのみ一意であるシーケンスジェネレータよりも優れた一意性を保証します。</target>
        </trans-unit>
        <trans-unit id="9a349537e0ccabe90f0be4224865fb39a87fb38c" translate="yes" xml:space="preserve">
          <source>The data type actually stored in the index. Normally this is the same as the column data type, but some index methods (currently GiST, GIN and BRIN) allow it to be different. The &lt;code&gt;STORAGE&lt;/code&gt; clause must be omitted unless the index method allows a different type to be used. If the column &lt;code&gt;data_type&lt;/code&gt; is specified as &lt;code&gt;anyarray&lt;/code&gt;, the &lt;code&gt;storage_type&lt;/code&gt; can be declared as &lt;code&gt;anyelement&lt;/code&gt; to indicate that the index entries are members of the element type belonging to the actual array type that each particular index is created for.</source>
          <target state="translated">実際にインデックスに格納されるデータ型。通常、これは列のデータ型と同じですが、一部のインデックスメソッド（現在はGiST、GIN、およびBRIN）では、異なる値にすることができます。 &lt;code&gt;STORAGE&lt;/code&gt; のインデックスメソッドが異なるタイプを使用することができない限り、句を省略しなければなりません。列 &lt;code&gt;data_type&lt;/code&gt; が &lt;code&gt;anyarray&lt;/code&gt; として指定されている場合、 &lt;code&gt;storage_type&lt;/code&gt; を &lt;code&gt;anyelement&lt;/code&gt; として宣言して、インデックスエントリが、特定の各インデックスが作成される実際の配列タイプに属する要素タイプのメンバーであることを示すことができます。</target>
        </trans-unit>
        <trans-unit id="b3cf16533d2c33c2548b22d8bef5b9f8bd26fb43" translate="yes" xml:space="preserve">
          <source>The data type for the aggregate's state value, when using moving-aggregate mode.</source>
          <target state="translated">移動アグリゲートモードを使用している場合、アグリゲートの状態値のデータ型。</target>
        </trans-unit>
        <trans-unit id="450e47ffde369f976b7ab98b3a6e066768317211" translate="yes" xml:space="preserve">
          <source>The data type for the aggregate's state value.</source>
          <target state="translated">集約体の状態値のデータ型。</target>
        </trans-unit>
        <trans-unit id="a84accdb873accb8d045ec8f5d98450a1c8038e0" translate="yes" xml:space="preserve">
          <source>The data type of a function, procedure, or aggregate argument.</source>
          <target state="translated">関数、プロシージャ、または集合体の引数のデータ型。</target>
        </trans-unit>
        <trans-unit id="7678a7f2db2f20f82bdcd718575a886bbedb555c" translate="yes" xml:space="preserve">
          <source>The data type of a parameter to the prepared statement. If the data type of a particular parameter is unspecified or is specified as &lt;code&gt;unknown&lt;/code&gt;, it will be inferred from the context in which the parameter is first referenced. To refer to the parameters in the prepared statement itself, use &lt;code&gt;$1&lt;/code&gt;, &lt;code&gt;$2&lt;/code&gt;, etc.</source>
          <target state="translated">準備済みステートメントへのパラメーターのデータ型。特定のパラメーターのデータ型が指定されてい &lt;code&gt;unknown&lt;/code&gt; 場合、またはunknownとして指定されている場合、パラメーターが最初に参照されたコンテキストから推測されます。準備されたステートメント自体のパラメーターを参照するには、 &lt;code&gt;$1&lt;/code&gt; 、 &lt;code&gt;$2&lt;/code&gt; などを使用します。</target>
        </trans-unit>
        <trans-unit id="97e7b1042480837c18e5146ff95fc1e9e9d4ce38" translate="yes" xml:space="preserve">
          <source>The data type of an output column in the &lt;code&gt;RETURNS TABLE&lt;/code&gt; syntax.</source>
          <target state="translated">&lt;code&gt;RETURNS TABLE&lt;/code&gt; 構文の出力列のデータ型。</target>
        </trans-unit>
        <trans-unit id="1f4da46a2e46ee99f93db576da8c6c70a740dbca" translate="yes" xml:space="preserve">
          <source>The data type of the attribute to add, or the new type of the attribute to alter.</source>
          <target state="translated">追加する属性のデータ型、または変更する属性の新しい型。</target>
        </trans-unit>
        <trans-unit id="643babd5ccd3dbc1eadd607ad51f52e3099e9220" translate="yes" xml:space="preserve">
          <source>The data type of the column. This can include array specifiers. For more information on the data types supported by PostgreSQL, refer to &lt;a href=&quot;datatype&quot;&gt;Chapter 8&lt;/a&gt;.</source>
          <target state="translated">列のデータ型。これには、配列指定子を含めることができます。PostgreSQLでサポートされているデータ型の詳細については、&lt;a href=&quot;datatype&quot;&gt;第8章を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="00e2be0bf08b0f249705f534c771af62f659c534" translate="yes" xml:space="preserve">
          <source>The data type of the operator's left operand, if any. This option would be omitted for a left-unary operator.</source>
          <target state="translated">演算子の左オペランドがあれば、そのデータ型を指定します。左単項演算子の場合、このオプションは省略されます。</target>
        </trans-unit>
        <trans-unit id="3851b291352047da5cb8dab5436b1049af2b810b" translate="yes" xml:space="preserve">
          <source>The data type of the operator's left operand; write &lt;code&gt;NONE&lt;/code&gt; if the operator has no left operand.</source>
          <target state="translated">演算子の左オペランドのデータ型。演算子に左オペランドがない場合は、 &lt;code&gt;NONE&lt;/code&gt; を書き込みます。</target>
        </trans-unit>
        <trans-unit id="ccbd8cc94b9c8b592bbe8864eb6cc7e34df08235" translate="yes" xml:space="preserve">
          <source>The data type of the operator's right operand, if any. This option would be omitted for a right-unary operator.</source>
          <target state="translated">演算子の右オペランドがあれば、そのデータ型を指定します。このオプションは、右単項演算子の場合は省略されます。</target>
        </trans-unit>
        <trans-unit id="977b80839dcec0a264635f6fae2341cd4abe466d" translate="yes" xml:space="preserve">
          <source>The data type of the operator's right operand; write &lt;code&gt;NONE&lt;/code&gt; if the operator has no right operand.</source>
          <target state="translated">演算子の右側のオペランドのデータ型。演算子に右オペランドがない場合は、 &lt;code&gt;NONE&lt;/code&gt; を書き込みます。</target>
        </trans-unit>
        <trans-unit id="d1e6d9a6627f0f8541d4b2888407afff0ea3591c" translate="yes" xml:space="preserve">
          <source>The data type of this column</source>
          <target state="translated">この列のデータ型</target>
        </trans-unit>
        <trans-unit id="536b65adfc0c23a20e0043a6c217a813568358a2" translate="yes" xml:space="preserve">
          <source>The data type(s) of the function's arguments (optionally schema-qualified), if any.</source>
          <target state="translated">関数の引数のデータ型 (スキーマ修飾されたものがある場合は、オプションでスキーマ修飾されたもの)。</target>
        </trans-unit>
        <trans-unit id="c1899d531f40a6d2bc934ee7a1bdb436b5b33cc2" translate="yes" xml:space="preserve">
          <source>The data type(s) of the function's arguments (optionally schema-qualified), if any. The argument types can be base, composite, or domain types, or can reference the type of a table column.</source>
          <target state="translated">関数の引数のデータ型(スキーマ修飾されている場合は、オプションでスキーマ修飾されている)。引数の型は、ベース型、複合型、ドメイン型、またはテーブルカラムの型を参照することができます。</target>
        </trans-unit>
        <trans-unit id="0fa26cbbebcfa5ffa72e0fb66013b91729e1dbea" translate="yes" xml:space="preserve">
          <source>The data type(s) of the operator's arguments (optionally schema-qualified). Write &lt;code&gt;NONE&lt;/code&gt; for the missing argument of a prefix or postfix operator.</source>
          <target state="translated">オペレーターの引数のデータ型（オプションでスキーマ修飾）。前置演算子または後置演算子の欠落している引数に &lt;code&gt;NONE&lt;/code&gt; を書き込みます。</target>
        </trans-unit>
        <trans-unit id="f78d5722d424ec9c1eb5a72c627a144311353db1" translate="yes" xml:space="preserve">
          <source>The data type(s) of the procedure's arguments (optionally schema-qualified), if any.</source>
          <target state="translated">プロシージャの引数のデータ型(スキーマ修飾されている場合には、オプションでスキーマ修飾されている場合もあります)。</target>
        </trans-unit>
        <trans-unit id="cc4ed7c8f0edb91ee3802c9f1cbfdfe5d88cd95f" translate="yes" xml:space="preserve">
          <source>The data type(s) of the procedure's arguments (optionally schema-qualified), if any. The argument types can be base, composite, or domain types, or can reference the type of a table column.</source>
          <target state="translated">プロシージャの引数のデータ型(スキーマ修飾されている場合は、オプションでスキーマ修飾されています)。引数の型は、ベース型、複合型、ドメイン型、またはテーブルカラムの型を参照することができます。</target>
        </trans-unit>
        <trans-unit id="b13b1cfa55ac5025cb1667821c336a02f9958dc9" translate="yes" xml:space="preserve">
          <source>The data types &lt;code&gt;real&lt;/code&gt; and &lt;code&gt;double precision&lt;/code&gt; are inexact, variable-precision numeric types. On all currently supported platforms, these types are implementations of IEEE Standard 754 for Binary Floating-Point Arithmetic (single and double precision, respectively), to the extent that the underlying processor, operating system, and compiler support it.</source>
          <target state="translated">&lt;code&gt;real&lt;/code&gt; および &lt;code&gt;double precision&lt;/code&gt; のデータ型は、不正確な可変精度数値型です。現在サポートされているすべてのプラットフォームで、これらの型は、基になるプロセッサ、オペレーティングシステム、およびコンパイラがサポートする範囲で、2進浮動小数点演算（それぞれ単精度および倍精度）のIEEE標準754の実装です。</target>
        </trans-unit>
        <trans-unit id="95cc47952f3a5e2e5bea18ece63744adf6f3d52b" translate="yes" xml:space="preserve">
          <source>The data types &lt;code&gt;smallserial&lt;/code&gt;, &lt;code&gt;serial&lt;/code&gt; and &lt;code&gt;bigserial&lt;/code&gt; are not true types, but merely a notational convenience for creating unique identifier columns (similar to the &lt;code&gt;AUTO_INCREMENT&lt;/code&gt; property supported by some other databases). In the current implementation, specifying:</source>
          <target state="translated">&lt;code&gt;smallserial&lt;/code&gt; 、 &lt;code&gt;serial&lt;/code&gt; 、および &lt;code&gt;bigserial&lt;/code&gt; のデータ型は真の型ではなく、一意の識別子列を作成するための表記上の便宜にすぎません（他のデータベースでサポートされている &lt;code&gt;AUTO_INCREMENT&lt;/code&gt; プロパティと同様）。現在の実装では、以下を指定します：</target>
        </trans-unit>
        <trans-unit id="c1d4cee11581ccf46822d30574cc04ac170d447c" translate="yes" xml:space="preserve">
          <source>The data types of all the &lt;code&gt;result&lt;/code&gt; expressions must be convertible to a single output type. See &lt;a href=&quot;typeconv-union-case&quot;&gt;Section 10.5&lt;/a&gt; for more details.</source>
          <target state="translated">すべての &lt;code&gt;result&lt;/code&gt; 式のデータ型は、単一の出力型に変換できる必要があります。詳細については、&lt;a href=&quot;typeconv-union-case&quot;&gt;セクション10.5&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="833950eaad4f091a792f16ed765cff996e89f49e" translate="yes" xml:space="preserve">
          <source>The data values are listed in the order in which the columns appear in the table, separated by commas. Usually, the data values will be literals (constants), but scalar expressions are also allowed.</source>
          <target state="translated">データ値は、カンマで区切られた表の列が現れる順にリストアップされています。通常、データ値はリテラル(定数)となりますが、スカラー表現も可能です。</target>
        </trans-unit>
        <trans-unit id="511f74682fefbedf40676929009d5d52bb81a56d" translate="yes" xml:space="preserve">
          <source>The data values are mapped in the same way as described for the function &lt;code&gt;xmlelement&lt;/code&gt; above.</source>
          <target state="translated">データ値は、上記の関数 &lt;code&gt;xmlelement&lt;/code&gt; で説明したのと同じ方法でマッピングされます。</target>
        </trans-unit>
        <trans-unit id="b3854c2d1d8f8304933b603d0d2fef62ed88a35f" translate="yes" xml:space="preserve">
          <source>The database activity of pg_dump is normally collected by the statistics collector. If this is undesirable, you can set parameter &lt;code&gt;track_counts&lt;/code&gt; to false via &lt;code&gt;PGOPTIONS&lt;/code&gt; or the &lt;code&gt;ALTER USER&lt;/code&gt; command.</source>
          <target state="translated">pg_dumpのデータベースアクティビティは、通常、統計コレクターによって収集されます。これが望ましくない場合は、 &lt;code&gt;PGOPTIONS&lt;/code&gt; または &lt;code&gt;ALTER USER&lt;/code&gt; コマンドを使用して、パラメーター &lt;code&gt;track_counts&lt;/code&gt; をfalseに設定できます。</target>
        </trans-unit>
        <trans-unit id="e78726feeb2c4690a432f23c59d13fb4ceea2509" translate="yes" xml:space="preserve">
          <source>The database named in the &lt;code&gt;-d&lt;/code&gt; switch can be any database existing in the cluster; pg_restore only uses it to issue the &lt;code&gt;CREATE DATABASE&lt;/code&gt; command for &lt;code&gt;mydb&lt;/code&gt;. With &lt;code&gt;-C&lt;/code&gt;, data is always restored into the database name that appears in the dump file.</source>
          <target state="translated">で指定されたデータベース &lt;code&gt;-d&lt;/code&gt; スイッチは、クラスタ内の既存の任意のデータベースにすることができます。pg_restoreは、 &lt;code&gt;mydb&lt;/code&gt; に対して &lt;code&gt;CREATE DATABASE&lt;/code&gt; コマンドを発行するためにのみ使用します。では &lt;code&gt;-C&lt;/code&gt; 、データは常にダンプ・ファイルに記述された名前のデータベースに復元されます。</target>
        </trans-unit>
        <trans-unit id="a7217998725cfcd7339a40affa714dc41a9f7779" translate="yes" xml:space="preserve">
          <source>The database schema and DDL commands are not replicated. The initial schema can be copied by hand using &lt;code&gt;pg_dump --schema-only&lt;/code&gt;. Subsequent schema changes would need to be kept in sync manually. (Note, however, that there is no need for the schemas to be absolutely the same on both sides.) Logical replication is robust when schema definitions change in a live database: When the schema is changed on the publisher and replicated data starts arriving at the subscriber but does not fit into the table schema, replication will error until the schema is updated. In many cases, intermittent errors can be avoided by applying additive schema changes to the subscriber first.</source>
          <target state="translated">データベーススキーマとDDLコマンドは複製されません。初期スキーマは &lt;code&gt;pg_dump --schema-only&lt;/code&gt; を使用して手動でコピーできます。その後のスキーマ変更は、手動で同期を保つ必要があります。 （ただし、スキーマが両側で完全に同じである必要はないことに注意してください。）ライブデータベースでスキーマ定義が変更された場合、論理レプリケーションは堅牢です。パブリッシャーでスキーマが変更され、複製されたデータが到着し始めたときサブスクライバーがテーブルスキーマに適合しない場合、スキーマが更新されるまでレプリケーションはエラーになります。多くの場合、最初にサブスクライバーに追加のスキーマ変更を適用することにより、断続的なエラーを回避できます。</target>
        </trans-unit>
        <trans-unit id="7126248724d0590ca70b478abc60308b632b1141" translate="yes" xml:space="preserve">
          <source>The database server &lt;em&gt;must&lt;/em&gt; be shut down in order to get a usable backup. Half-way measures such as disallowing all connections will &lt;em&gt;not&lt;/em&gt; work (in part because &lt;code&gt;tar&lt;/code&gt; and similar tools do not take an atomic snapshot of the state of the file system, but also because of internal buffering within the server). Information about stopping the server can be found in &lt;a href=&quot;server-shutdown&quot;&gt;Section 18.5&lt;/a&gt;. Needless to say, you also need to shut down the server before restoring the data.</source>
          <target state="translated">使用可能なバックアップを取得するには、データベースサーバーをシャットダウンする&lt;em&gt;必要&lt;/em&gt;が&lt;em&gt;あり&lt;/em&gt;ます。すべての接続を許可しないなどの中間的な対策は機能し&lt;em&gt;ません&lt;/em&gt;（ &lt;code&gt;tar&lt;/code&gt; や類似のツールがファイルシステムの状態のアトミックスナップショットを取得しないため、サーバー内の内部バッファリングも原因です）。サーバーの停止に関する情報は&lt;a href=&quot;server-shutdown&quot;&gt;項18.5にあり&lt;/a&gt;ます。言うまでもなく、データを復元する前にサーバーをシャットダウンする必要もあります。</target>
        </trans-unit>
        <trans-unit id="c8210278fffa651db73498b44685083caea4837b" translate="yes" xml:space="preserve">
          <source>The database server host you are currently connected to. This is set every time you connect to a database (including program start-up), but can be changed or unset.</source>
          <target state="translated">現在接続しているデータベースサーバーのホスト。これは、データベースに接続するたびに(プログラムの起動を含む)設定されますが、変更または解除することができます。</target>
        </trans-unit>
        <trans-unit id="4225ad89a733947e3891f6391650e080a1af4ac1" translate="yes" xml:space="preserve">
          <source>The database server port to which you are currently connected. This is set every time you connect to a database (including program start-up), but can be changed or unset.</source>
          <target state="translated">現在接続しているデータベースサーバーのポート。これは、データベースに接続するたびに(プログラムの起動を含めて)設定されますが、変更したり、設定を解除したりすることができます。</target>
        </trans-unit>
        <trans-unit id="cc0f8108abc644f84f0071b412b2512b78ad2132" translate="yes" xml:space="preserve">
          <source>The database server's host name</source>
          <target state="translated">データベースサーバのホスト名</target>
        </trans-unit>
        <trans-unit id="a4b3d744975ee6b60121119bc335e231f7de4513" translate="yes" xml:space="preserve">
          <source>The database server's port number</source>
          <target state="translated">データベースサーバのポート番号</target>
        </trans-unit>
        <trans-unit id="cfe5c0809041f0c5dee1fdfbdf2f909905d7bde5" translate="yes" xml:space="preserve">
          <source>The database session user name. (The expansion of this value might change during a database session as the result of the command &lt;code&gt;SET SESSION AUTHORIZATION&lt;/code&gt;.)</source>
          <target state="translated">データベースセッションのユーザー名。（この値の拡張は、 &lt;code&gt;SET SESSION AUTHORIZATION&lt;/code&gt; コマンドの結果として、データベースセッション中に変更される場合があります。）</target>
        </trans-unit>
        <trans-unit id="7c6fc494e971daf47c30896ebfcc78ba315d5aed" translate="yes" xml:space="preserve">
          <source>The database to connect to. See the description of the actions for what this means in detail. The &lt;code&gt;dbname&lt;/code&gt; can be a &lt;a href=&quot;https://www.postgresql.org/docs/13/libpq-connect.html#LIBPQ-CONNSTRING&quot;&gt;connection string&lt;/a&gt;. If so, connection string parameters will override any conflicting command line options. Defaults to the user name.</source>
          <target state="translated">接続するデータベース。これが何を意味するかについては、アクションの説明を詳細に参照してください。 &lt;code&gt;dbname&lt;/code&gt; することができ&lt;a href=&quot;https://www.postgresql.org/docs/13/libpq-connect.html#LIBPQ-CONNSTRING&quot;&gt;、接続文字列&lt;/a&gt;。その場合、接続文字列パラメータは、競合するコマンドラインオプションを上書きします。デフォルトはユーザー名です。</target>
        </trans-unit>
        <trans-unit id="8854074f0a9f2884a73fba5bef5522aadc8c6fe8" translate="yes" xml:space="preserve">
          <source>The database to connect to. See the description of the actions for what this means in detail. This can be a libpq connection string; see &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-connect.html#LIBPQ-CONNSTRING&quot;&gt;Section 33.1.1&lt;/a&gt; for more information. Defaults to user name.</source>
          <target state="translated">接続するデータベース。詳しくは、アクションの説明をご覧ください。これはlibpq接続文字列にすることができます。詳細は&lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-connect.html#LIBPQ-CONNSTRING&quot;&gt;項33.1.1&lt;/a&gt;を参照してください。デフォルトはユーザー名です。</target>
        </trans-unit>
        <trans-unit id="8142c603a5c381a14fdd730098342401f6c26eea" translate="yes" xml:space="preserve">
          <source>The database user you are currently connected as. This is set every time you connect to a database (including program start-up), but can be changed or unset.</source>
          <target state="translated">現在接続しているデータベースユーザー。これは、データベースに接続するたびに(プログラムの起動を含めて)設定されますが、変更したり、設定を解除したりすることができます。</target>
        </trans-unit>
        <trans-unit id="b630a685a9f1e8cf73c559db8e767d96cc4b9662" translate="yes" xml:space="preserve">
          <source>The database you are trying to connect to does not exist. Note that if you do not specify a database name, it defaults to the database user name, which might or might not be the right thing.</source>
          <target state="translated">接続しようとしているデータベースが存在しません。データベース名を指定しないと、データベースのユーザー名がデフォルトで使用されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="fee1a6c055e42f40e71b91d8726649529647f66d" translate="yes" xml:space="preserve">
          <source>The datatype input function for type &lt;code&gt;boolean&lt;/code&gt; accepts these string representations for the &amp;ldquo;true&amp;rdquo; state:</source>
          <target state="translated">&lt;code&gt;boolean&lt;/code&gt; 型のデータ型入力関数は、「true」状態の次の文字列表現を受け入れます。</target>
        </trans-unit>
        <trans-unit id="ae4a7ff4b226f1bae5a99aaa421f3e1ec4a71979" translate="yes" xml:space="preserve">
          <source>The datatype output function for type &lt;code&gt;boolean&lt;/code&gt; always emits either &lt;code&gt;t&lt;/code&gt; or &lt;code&gt;f&lt;/code&gt;, as shown in &lt;a href=&quot;datatype-boolean#DATATYPE-BOOLEAN-EXAMPLE&quot;&gt;Example 8.2&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;datatype-boolean#DATATYPE-BOOLEAN-EXAMPLE&quot;&gt;例8.2に&lt;/a&gt;示すように、 &lt;code&gt;boolean&lt;/code&gt; 型のデータ型出力関数は常に &lt;code&gt;t&lt;/code&gt; または &lt;code&gt;f&lt;/code&gt; のいずれかを発行します。</target>
        </trans-unit>
        <trans-unit id="7cfcef52fd742ca2a7d47081e6367dac502e36ab" translate="yes" xml:space="preserve">
          <source>The date/time style can be selected by the user using the &lt;code&gt;SET datestyle&lt;/code&gt; command, the &lt;a href=&quot;runtime-config-client#GUC-DATESTYLE&quot;&gt;DateStyle&lt;/a&gt; parameter in the &lt;code&gt;postgresql.conf&lt;/code&gt; configuration file, or the &lt;code&gt;PGDATESTYLE&lt;/code&gt; environment variable on the server or client.</source>
          <target state="translated">日付/時刻スタイルは、 &lt;code&gt;SET datestyle&lt;/code&gt; コマンド、 &lt;code&gt;postgresql.conf&lt;/code&gt; 構成ファイルの&lt;a href=&quot;runtime-config-client#GUC-DATESTYLE&quot;&gt;DateStyle&lt;/a&gt;パラメータ、またはサーバーまたはクライアントの &lt;code&gt;PGDATESTYLE&lt;/code&gt; 環境変数を使用して、ユーザーが選択できます。</target>
        </trans-unit>
        <trans-unit id="5d764ba10f260d8d4e8bfcd3a741fca678bd1d96" translate="yes" xml:space="preserve">
          <source>The day of the week as Monday (&lt;code&gt;1&lt;/code&gt;) to Sunday (&lt;code&gt;7&lt;/code&gt;)</source>
          <target state="translated">月曜日（ &lt;code&gt;1&lt;/code&gt; ）から日曜日（ &lt;code&gt;7&lt;/code&gt; ）までの曜日</target>
        </trans-unit>
        <trans-unit id="a891efc073ada13a5907f18625fe5fde82907c09" translate="yes" xml:space="preserve">
          <source>The day of the week as Sunday (&lt;code&gt;0&lt;/code&gt;) to Saturday (&lt;code&gt;6&lt;/code&gt;)</source>
          <target state="translated">日曜日（ &lt;code&gt;0&lt;/code&gt; ）から土曜日（ &lt;code&gt;6&lt;/code&gt; ）までの曜日</target>
        </trans-unit>
        <trans-unit id="9ca4eefed78bdde53eebbe05d44c2b02c01e2924" translate="yes" xml:space="preserve">
          <source>The day of the year (1 - 365/366)</source>
          <target state="translated">年の日(1~365/366)にちなんで</target>
        </trans-unit>
        <trans-unit id="9a1fd8cf416c0db89c29a7999ef88f31189e883a" translate="yes" xml:space="preserve">
          <source>The day of the year (1&amp;ndash;365/366)</source>
          <target state="translated">年間通算日（1&amp;ndash;365 / 366）</target>
        </trans-unit>
        <trans-unit id="cb0c5380f15a2fcb247a4681d0ebeea27f30d33e" translate="yes" xml:space="preserve">
          <source>The daylight-savings transition &lt;code&gt;rule&lt;/code&gt; has the format</source>
          <target state="translated">夏時間移行 &lt;code&gt;rule&lt;/code&gt; の形式は</target>
        </trans-unit>
        <trans-unit id="d4a9223278a724eaae749c9ac28592e80acca20f" translate="yes" xml:space="preserve">
          <source>The decrypted data and the decryption key are present on the server for a brief time while it is being decrypted and communicated between the client and server. This presents a brief moment where the data and keys can be intercepted by someone with complete access to the database server, such as the system administrator.</source>
          <target state="translated">復号化されたデータと復号化キーは、クライアントとサーバの間で復号化されて通信されている間、短時間だけサーバ上に存在します。これは、システム管理者のようなデータベースサーバへの完全なアクセス権を持つ者が、データと鍵を傍受することができる短い時間を示しています。</target>
        </trans-unit>
        <trans-unit id="0c0cddca1cd2a66e6ef93ce9c61b41178a127f6f" translate="yes" xml:space="preserve">
          <source>The deduplication process occurs lazily, when a new item is inserted that cannot fit on an existing leaf page. This prevents (or at least delays) leaf page splits. Unlike GIN posting list tuples, B-Tree posting list tuples do not need to expand every time a new duplicate is inserted; they are merely an alternative physical representation of the original logical contents of the leaf page. This design prioritizes consistent performance with mixed read-write workloads. Most client applications will at least see a moderate performance benefit from using deduplication. Deduplication is enabled by default.</source>
          <target state="translated">重複除外処理は、既存のリーフページに収まらない新しい項目が挿入されたときに、怠惰に行われる。これにより、リーフページの分割を防ぐ(あるいは少なくとも遅延させる)ことができる。GIN ポスティングリストタプルとは異なり、B-Tree ポスティングリストタプルは新しい重複が挿入されるたびに展開する必要はありません。この設計では、読み書きの混在するワークロードでの一貫したパフォーマンスを優先しています。ほとんどのクライアントアプリケーションでは、少なくとも重複排除を使用することで中程度のパフォーマンスの恩恵を受けることができるだろう。重複排除はデフォルトで有効になっている。</target>
        </trans-unit>
        <trans-unit id="164046e431b6ca84db93b57b79867c4791c090cf" translate="yes" xml:space="preserve">
          <source>The default (and recommended) setting of &lt;a href=&quot;runtime-config-query#GUC-CONSTRAINT-EXCLUSION&quot;&gt;constraint_exclusion&lt;/a&gt; is neither &lt;code&gt;on&lt;/code&gt; nor &lt;code&gt;off&lt;/code&gt;, but an intermediate setting called &lt;code&gt;partition&lt;/code&gt;, which causes the technique to be applied only to queries that are likely to be working on inheritance partitioned tables. The &lt;code&gt;on&lt;/code&gt; setting causes the planner to examine &lt;code&gt;CHECK&lt;/code&gt; constraints in all queries, even simple ones that are unlikely to benefit.</source>
          <target state="translated">デフォルト設定（および推奨）&lt;a href=&quot;runtime-config-query#GUC-CONSTRAINT-EXCLUSION&quot;&gt;constraint_exclusionのは&lt;/a&gt;どちらもありません &lt;code&gt;on&lt;/code&gt; も &lt;code&gt;off&lt;/code&gt; 、しかしと呼ばれる中間設定 &lt;code&gt;partition&lt;/code&gt; 技術を引き起こし、唯一の継承は、テーブルをパーティションで作業する可能性があるクエリに適用されます。 &lt;code&gt;on&lt;/code&gt; 設定では、検討するプランナー原因 &lt;code&gt;CHECK&lt;/code&gt; すべてのクエリ内の制約、利益のためにそうであっても簡単なもの。</target>
        </trans-unit>
        <trans-unit id="1787e7e5cf03a442dbbaaa1d6af68edf6096b6e2" translate="yes" xml:space="preserve">
          <source>The default GIN operator class for &lt;code&gt;jsonb&lt;/code&gt; supports queries with top-level key-exists operators &lt;code&gt;?&lt;/code&gt;, &lt;code&gt;?&amp;amp;&lt;/code&gt; and &lt;code&gt;?|&lt;/code&gt; operators and path/value-exists operator &lt;code&gt;@&amp;gt;&lt;/code&gt;. (For details of the semantics that these operators implement, see &lt;a href=&quot;functions-json#FUNCTIONS-JSONB-OP-TABLE&quot;&gt;Table 9.45&lt;/a&gt;.) An example of creating an index with this operator class is:</source>
          <target state="translated">&lt;code&gt;jsonb&lt;/code&gt; のデフォルトのGIN演算子クラスは、最上位のキー存在演算子を使用したクエリをサポートし &lt;code&gt;?&lt;/code&gt; 、 &lt;code&gt;?&amp;amp;&lt;/code&gt; および &lt;code&gt;?|&lt;/code&gt; 演算子とpath / value-exists演算子 &lt;code&gt;@&amp;gt;&lt;/code&gt; 。（これらの演算子が実装するセマンティクスの詳細については、&lt;a href=&quot;functions-json#FUNCTIONS-JSONB-OP-TABLE&quot;&gt;表9.45を&lt;/a&gt;参照してください。）この演算子クラスでインデックスを作成する例は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="2eb60f012e323a27dd228ff40f13cdf0f9d72cff" translate="yes" xml:space="preserve">
          <source>The default IPC settings can be changed using the &lt;code&gt;sysctl&lt;/code&gt; or &lt;code&gt;loader&lt;/code&gt; interfaces. The following parameters can be set using &lt;code&gt;sysctl&lt;/code&gt;:</source>
          <target state="translated">デフォルトのIPC設定は、 &lt;code&gt;sysctl&lt;/code&gt; または &lt;code&gt;loader&lt;/code&gt; インターフェースを使用して変更できます。次のパラメータは、 &lt;code&gt;sysctl&lt;/code&gt; を使用して設定できます。</target>
        </trans-unit>
        <trans-unit id="0939858e47c24e25aea8221bd11aa7efd06e7d2d" translate="yes" xml:space="preserve">
          <source>The default TPC-B-like transaction test requires specific tables to be set up beforehand. pgbench should be invoked with the &lt;code&gt;-i&lt;/code&gt; (initialize) option to create and populate these tables. (When you are testing a custom script, you don't need this step, but will instead need to do whatever setup your test needs.) Initialization looks like:</source>
          <target state="translated">デフォルトのTPC-Bのようなトランザクションテストでは、事前に特定のテーブルを設定する必要があります。pgbenchは &lt;code&gt;-i&lt;/code&gt; （初期化）オプションを指定して起動し、これらのテーブルを作成してデータを入力する必要があります。（カスタムスクリプトをテストする場合、この手順は必要ありませんが、テストに必要なセットアップをすべて行う必要があります。）初期化は次のようになります。</target>
        </trans-unit>
        <trans-unit id="1cd3fc8c960efc439298488cea62fca507ea8c64" translate="yes" xml:space="preserve">
          <source>The default behavior for huge pages in PostgreSQL is to use them when possible and to fall back to normal pages when failing. To enforce the use of huge pages, you can set &lt;a href=&quot;runtime-config-resource#GUC-HUGE-PAGES&quot;&gt;huge_pages&lt;/a&gt; to &lt;code&gt;on&lt;/code&gt; in &lt;code&gt;postgresql.conf&lt;/code&gt;. Note that with this setting PostgreSQL will fail to start if not enough huge pages are available.</source>
          <target state="translated">PostgreSQLの巨大なページのデフォルトの動作は、可能な場合はそれらを使用し、失敗した場合は通常のページにフォールバックすることです。巨大ページの使用を強制する &lt;code&gt;on&lt;/code&gt; は、 &lt;code&gt;postgresql.conf&lt;/code&gt; で&lt;a href=&quot;runtime-config-resource#GUC-HUGE-PAGES&quot;&gt;huge_pages&lt;/a&gt;をonに設定します。この設定では、十分な巨大ページが利用できない場合、PostgreSQLは起動に失敗することに注意してください。</target>
        </trans-unit>
        <trans-unit id="aaa5ded69b6418f38f6ec7a4670e3b4d29f7971b" translate="yes" xml:space="preserve">
          <source>The default behavior of recovery is to recover along the same timeline that was current when the base backup was taken. If you wish to recover into some child timeline (that is, you want to return to some state that was itself generated after a recovery attempt), you need to specify the target timeline ID in &lt;a href=&quot;runtime-config-wal#GUC-RECOVERY-TARGET-TIMELINE&quot;&gt;recovery_target_timeline&lt;/a&gt;. You cannot recover into timelines that branched off earlier than the base backup.</source>
          <target state="translated">リカバリのデフォルトの動作は、ベースバックアップが作成されたときと同じタイムラインに沿ってリカバリすることです。あなたには、いくつかの子タイムライン（つまり、あなたは、それ自体が、回復の試みの後に生成されたいくつかの状態に戻したい）に回復したい場合は、ターゲットタイムラインのIDを指定する必要が&lt;a href=&quot;runtime-config-wal#GUC-RECOVERY-TARGET-TIMELINE&quot;&gt;recovery_target_timeline&lt;/a&gt;。ベースバックアップより前に分岐したタイムラインにリカバリすることはできません。</target>
        </trans-unit>
        <trans-unit id="3a7ad1055953cf587ab781a3bc1fc4c9129cc265" translate="yes" xml:space="preserve">
          <source>The default built-in transaction script (also invoked with &lt;code&gt;-b tpcb-like&lt;/code&gt;) issues seven commands per transaction over randomly chosen &lt;code&gt;aid&lt;/code&gt;, &lt;code&gt;tid&lt;/code&gt;, &lt;code&gt;bid&lt;/code&gt; and &lt;code&gt;delta&lt;/code&gt;. The scenario is inspired by the TPC-B benchmark, but is not actually TPC-B, hence the name.</source>
          <target state="translated">デフォルトの組み込みトランザクションスクリプト（これも &lt;code&gt;-b tpcb-like&lt;/code&gt; で呼び出されます）は、ランダムに選択された &lt;code&gt;aid&lt;/code&gt; 、 &lt;code&gt;tid&lt;/code&gt; 、 &lt;code&gt;bid&lt;/code&gt; および &lt;code&gt;delta&lt;/code&gt; に対してトランザクションごとに7つのコマンドを発行します。このシナリオはTPC-Bベンチマークに触発されていますが、実際にはTPC-Bではないため、この名前が付けられています。</target>
        </trans-unit>
        <trans-unit id="23125fde28fb9f59764dcf1b23a280a89053eb88" translate="yes" xml:space="preserve">
          <source>The default database privilege system allows database superusers to modify system catalogs using DML commands, and reference or modify toast tables. These operations are prohibited when &lt;code&gt;sepgsql&lt;/code&gt; is enabled.</source>
          <target state="translated">デフォルトのデータベース権限システムでは、データベーススーパーユーザーがDMLコマンドを使用してシステムカタログを変更したり、トーストテーブルを参照または変更したりできます。 &lt;code&gt;sepgsql&lt;/code&gt; が有効な場合、これらの操作は禁止されています。</target>
        </trans-unit>
        <trans-unit id="bc78e0117d012c08a955c11c85e0b86286d746a5" translate="yes" xml:space="preserve">
          <source>The default expression will be used in any insert operation that does not specify a value for the column. If a default value is defined for a particular column, it overrides any default associated with the domain. In turn, the domain default overrides any default value associated with the underlying data type.</source>
          <target state="translated">デフォルト式は、列の値を指定しない挿入操作で使用されます。デフォルト値が特定の列に定義されている場合、ドメインに関連付けられているすべてのデフォルト値が上書きされます。また、ドメインのデフォルトは、基礎となるデータ型に関連付けられているすべてのデフォルト値を上書きします。</target>
        </trans-unit>
        <trans-unit id="e924dec24aeaf46efa87502acfc94f6cc77685ce" translate="yes" xml:space="preserve">
          <source>The default expression will be used in any insert operation that does not specify a value for the column. If there is no default for a column, then the default is null.</source>
          <target state="translated">カラムの値を指定しない挿入操作では、デフォルト式が使用されます。カラムにデフォルトがない場合、デフォルトはnullとなります。</target>
        </trans-unit>
        <trans-unit id="5c475e2d48f46531de3913f26ad3045b4e6daa74" translate="yes" xml:space="preserve">
          <source>The default framing option is &lt;code&gt;RANGE UNBOUNDED PRECEDING&lt;/code&gt;, which is the same as &lt;code&gt;RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW&lt;/code&gt;. With &lt;code&gt;ORDER BY&lt;/code&gt;, this sets the frame to be all rows from the partition start up through the current row's last &lt;code&gt;ORDER BY&lt;/code&gt; peer. Without &lt;code&gt;ORDER BY&lt;/code&gt;, this means all rows of the partition are included in the window frame, since all rows become peers of the current row.</source>
          <target state="translated">デフォルトのフレーミングオプションは &lt;code&gt;RANGE UNBOUNDED PRECEDING&lt;/code&gt; で、これは &lt;code&gt;RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW&lt;/code&gt; と同じです。 &lt;code&gt;ORDER BY&lt;/code&gt; では、これにより、フレームは、パーティションの開始から現在の行の最後の &lt;code&gt;ORDER BY&lt;/code&gt; ピアまでのすべての行になるように設定されます。 &lt;code&gt;ORDER BY&lt;/code&gt; がない場合、すべての行が現在の行のピアになるため、パーティションのすべての行がウィンドウフレームに含まれます。</target>
        </trans-unit>
        <trans-unit id="ab9ba2008544bbedbbd493b6d70ae946d72bc7ec" translate="yes" xml:space="preserve">
          <source>The default framing option is &lt;code&gt;RANGE UNBOUNDED PRECEDING&lt;/code&gt;, which is the same as &lt;code&gt;RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW&lt;/code&gt;; it sets the frame to be all rows from the partition start up through the current row's last &lt;em&gt;peer&lt;/em&gt; (a row that the window's &lt;code&gt;ORDER BY&lt;/code&gt; clause considers equivalent to the current row; all rows are peers if there is no &lt;code&gt;ORDER BY&lt;/code&gt;). In general, &lt;code&gt;UNBOUNDED PRECEDING&lt;/code&gt; means that the frame starts with the first row of the partition, and similarly &lt;code&gt;UNBOUNDED FOLLOWING&lt;/code&gt; means that the frame ends with the last row of the partition, regardless of &lt;code&gt;RANGE&lt;/code&gt;, &lt;code&gt;ROWS&lt;/code&gt; or &lt;code&gt;GROUPS&lt;/code&gt; mode. In &lt;code&gt;ROWS&lt;/code&gt; mode, &lt;code&gt;CURRENT ROW&lt;/code&gt; means that the frame starts or ends with the current row; but in &lt;code&gt;RANGE&lt;/code&gt; or &lt;code&gt;GROUPS&lt;/code&gt; mode it means that the frame starts or ends with the current row's first or last peer in the &lt;code&gt;ORDER BY&lt;/code&gt; ordering. The &lt;code&gt;offset&lt;/code&gt;&lt;code&gt;PRECEDING&lt;/code&gt; and &lt;code&gt;offset&lt;/code&gt;&lt;code&gt;FOLLOWING&lt;/code&gt; options vary in meaning depending on the frame mode. In &lt;code&gt;ROWS&lt;/code&gt; mode, the &lt;code&gt;offset&lt;/code&gt; is an integer indicating that the frame starts or ends that many rows before or after the current row. In &lt;code&gt;GROUPS&lt;/code&gt; mode, the &lt;code&gt;offset&lt;/code&gt; is an integer indicating that the frame starts or ends that many peer groups before or after the current row's peer group, where a &lt;em&gt;peer group&lt;/em&gt; is a group of rows that are equivalent according to the window's &lt;code&gt;ORDER BY&lt;/code&gt; clause. In &lt;code&gt;RANGE&lt;/code&gt; mode, use of an &lt;code&gt;offset&lt;/code&gt; option requires that there be exactly one &lt;code&gt;ORDER BY&lt;/code&gt; column in the window definition. Then the frame contains those rows whose ordering column value is no more than &lt;code&gt;offset&lt;/code&gt; less than (for &lt;code&gt;PRECEDING&lt;/code&gt;) or more than (for &lt;code&gt;FOLLOWING&lt;/code&gt;) the current row's ordering column value. In these cases the data type of the &lt;code&gt;offset&lt;/code&gt; expression depends on the data type of the ordering column. For numeric ordering columns it is typically of the same type as the ordering column, but for datetime ordering columns it is an &lt;code&gt;interval&lt;/code&gt;. In all these cases, the value of the &lt;code&gt;offset&lt;/code&gt; must be non-null and non-negative. Also, while the &lt;code&gt;offset&lt;/code&gt; does not have to be a simple constant, it cannot contain variables, aggregate functions, or window functions.</source>
          <target state="translated">デフォルトのフレーミングオプションは &lt;code&gt;RANGE UNBOUNDED PRECEDING&lt;/code&gt; で、これは &lt;code&gt;RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW&lt;/code&gt; と同じです。フレームを、パーティションの開始から現在の行の最後の&lt;em&gt;ピア&lt;/em&gt;（ウィンドウの &lt;code&gt;ORDER BY&lt;/code&gt; 句が現在の行と同等と見なす行）までのすべての行になるように設定します。すべての行は、 &lt;code&gt;ORDER BY&lt;/code&gt; がない場合はピアです。一般に、 &lt;code&gt;UNBOUNDED PRECEDING&lt;/code&gt; 手段フレームは、パーティションの最初の行から始まり、同様こと &lt;code&gt;UNBOUNDED FOLLOWING&lt;/code&gt; の手段パーティションの最後の行とフレーム終了したこと、に関係なく &lt;code&gt;RANGE&lt;/code&gt; 、 &lt;code&gt;ROWS&lt;/code&gt; または &lt;code&gt;GROUPS&lt;/code&gt; モード。中 &lt;code&gt;ROWS&lt;/code&gt; モード、 &lt;code&gt;CURRENT ROW&lt;/code&gt; フレームが開始または現在の行で終わることを意味します。しかし、 &lt;code&gt;RANGE&lt;/code&gt; または &lt;code&gt;GROUPS&lt;/code&gt; モードでは、フレームは、 &lt;code&gt;ORDER BY&lt;/code&gt; 順序付けで現在の行の最初または最後のピアで開始または終了することを意味します。 &lt;code&gt;offset&lt;/code&gt; &lt;code&gt;PRECEDING&lt;/code&gt; と &lt;code&gt;offset&lt;/code&gt; &lt;code&gt;FOLLOWING&lt;/code&gt; オプションは、フレームモードによって意味が異なります。 &lt;code&gt;ROWS&lt;/code&gt; モード、 &lt;code&gt;offset&lt;/code&gt; そのフレームの開始または終了行数を現在の行の前または後にあることを示す整数です。 &lt;code&gt;GROUPS&lt;/code&gt; モード、 &lt;code&gt;offset&lt;/code&gt; フレームが現在の行のピアグループの前後にある多くのピアグループを開始または終了することを示す整数です。&lt;em&gt;ピアグループ&lt;/em&gt;は、ウィンドウの &lt;code&gt;ORDER BY&lt;/code&gt; 句に従って同等の行のグループです。では &lt;code&gt;RANGE&lt;/code&gt; のモードの使用 &lt;code&gt;offset&lt;/code&gt; オプションは、1つの存在であることを要求 &lt;code&gt;ORDER BY&lt;/code&gt; ウィンドウ定義内の列。次に、フレームには、順序付け列の値が現在の行の順序付け列値の &lt;code&gt;offset&lt;/code&gt; （ &lt;code&gt;PRECEDING&lt;/code&gt; の場合）以下（ &lt;code&gt;FOLLOWING&lt;/code&gt; の場合）以下の行が含まれます。これらの場合、 &lt;code&gt;offset&lt;/code&gt; データ型式は、順序付けする列のデータ型によって異なります。数値の順序付け列の場合、これは通常、順序付け列と同じタイプですが、日時順序付け列の場合は &lt;code&gt;interval&lt;/code&gt; です。これらのすべてのケースで、 &lt;code&gt;offset&lt;/code&gt; の値はnullでなく、負でない必要があります。また、 &lt;code&gt;offset&lt;/code&gt; は単純な定数である必要はありませんが、変数、集約関数、またはウィンドウ関数を含めることはできません。</target>
        </trans-unit>
        <trans-unit id="02427aea9e6cc1534ffa5badcc166ebd495d7d99" translate="yes" xml:space="preserve">
          <source>The default initialization behavior uses client-side data generation (equivalent to &lt;code&gt;g&lt;/code&gt;).</source>
          <target state="translated">デフォルトの初期化動作では、クライアント側のデータ生成（ &lt;code&gt;g&lt;/code&gt; と同等）が使用されます。</target>
        </trans-unit>
        <trans-unit id="585bb809ddf49c27ccd679a2aefbbe26ae6b7fc7" translate="yes" xml:space="preserve">
          <source>The default is 1 on supported systems, otherwise 0. This value can be overridden for tables in a particular tablespace by setting the tablespace parameter of the same name (see &lt;a href=&quot;sql-altertablespace&quot;&gt;ALTER TABLESPACE&lt;/a&gt;).</source>
          <target state="translated">サポートされているシステムでは、デフォルトは1です。それ以外の場合は0です。この名前は、同じ名前のテーブルスペースパラメータを設定することにより、特定のテーブルスペース内のテーブルに対してオーバーライドできます（&lt;a href=&quot;sql-altertablespace&quot;&gt;ALTER TABLESPACEを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="b428941637c56ecacd6f3388f30af9a9f66c9397" translate="yes" xml:space="preserve">
          <source>The default is 10 on supported systems, otherwise 0. This value can be overridden for tables in a particular tablespace by setting the tablespace parameter of the same name (see &lt;a href=&quot;sql-altertablespace&quot;&gt;ALTER TABLESPACE&lt;/a&gt;).</source>
          <target state="translated">サポートされているシステムでは、デフォルトは10です。それ以外の場合は0です。この値は、同じ名前の表領域パラメーターを設定することにより、特定の表領域の表に対してオーバーライドできます（&lt;a href=&quot;sql-altertablespace&quot;&gt;ALTER TABLESPACEを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="e91abeb434a6ce9f069e1f28ad61aa04fc26c2bb" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;+&lt;/code&gt; on Unix systems (corresponding to the default editor &lt;code&gt;vi&lt;/code&gt;, and useful for many other common editors); but there is no default on Windows systems.</source>
          <target state="translated">UNIXシステムでは、デフォルトは &lt;code&gt;+&lt;/code&gt; です（デフォルトのエディター &lt;code&gt;vi&lt;/code&gt; に対応し、他の多くの一般的なエディターで役立ちます）。ただし、Windowsシステムにはデフォルトはありません。</target>
        </trans-unit>
        <trans-unit id="20bd35f00ae043441f0cf7d67ea091592c87a851" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;CONTENT&lt;/code&gt;, so all forms of XML data are allowed.</source>
          <target state="translated">デフォルトは &lt;code&gt;CONTENT&lt;/code&gt; であるため、すべての形式のXMLデータが許可されます。</target>
        </trans-unit>
        <trans-unit id="a9030ed63211ad93fd21a5052bbbc9ec44c66fe7" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;TLSv1.2&lt;/code&gt;, which satisfies industry best practices as of this writing.</source>
          <target state="translated">デフォルトは &lt;code&gt;TLSv1.2&lt;/code&gt; であり、この記事の執筆時点で業界のベストプラクティスを満たしています。</target>
        </trans-unit>
        <trans-unit id="520d36bf5a7163373f8a236d77b263a2c0a04d44" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;TLSv1&lt;/code&gt;, mainly to support older versions of the OpenSSL library. You might want to set this to a higher value if all software components can support the newer protocol versions.</source>
          <target state="translated">デフォルトは &lt;code&gt;TLSv1&lt;/code&gt; で、主に古いバージョンのOpenSSLライブラリをサポートします。すべてのソフトウェアコンポーネントが新しいプロトコルバージョンをサポートできる場合は、これをより高い値に設定することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="231c42f70ffe5e8ab4244e5bdc8f6dbabaa3b107" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;none&lt;/code&gt;. Only superusers can change this setting.</source>
          <target state="translated">デフォルトは &lt;code&gt;none&lt;/code&gt; です。この設定を変更できるのはスーパーユーザーだけです。</target>
        </trans-unit>
        <trans-unit id="bd107bd07370addfaeb12f86e3bf6c56137f5dc1" translate="yes" xml:space="preserve">
          <source>The default is simple query protocol. (See &lt;a href=&quot;https://www.postgresql.org/docs/12/protocol.html&quot;&gt;Chapter 52&lt;/a&gt; for more information.)</source>
          <target state="translated">デフォルトは単純なクエリプロトコルです。（詳細については、&lt;a href=&quot;https://www.postgresql.org/docs/12/protocol.html&quot;&gt;第52章を&lt;/a&gt;参照してください。）</target>
        </trans-unit>
        <trans-unit id="4a4b29d9014d7b5f69a6f2afb601d3ce7d3550d2" translate="yes" xml:space="preserve">
          <source>The default is simple query protocol. (See &lt;a href=&quot;https://www.postgresql.org/docs/13/protocol.html&quot;&gt;Chapter 52&lt;/a&gt; for more information.)</source>
          <target state="translated">デフォルトは単純なクエリプロトコルです。（詳細については、&lt;a href=&quot;https://www.postgresql.org/docs/13/protocol.html&quot;&gt;第52章を&lt;/a&gt;参照してください。）</target>
        </trans-unit>
        <trans-unit id="c6f72dd6acfbb83ab51b40e408e5dc009e36a5da" translate="yes" xml:space="preserve">
          <source>The default maximum segment size is 32 MB, and the default maximum total size is 2097152 pages. A page is almost always 4096 bytes except in unusual kernel configurations with &amp;ldquo;huge pages&amp;rdquo; (use &lt;code&gt;getconf PAGE_SIZE&lt;/code&gt; to verify).</source>
          <target state="translated">デフォルトの最大セグメントサイズは32 MBで、デフォルトの最大合計サイズは2097152ページです。「巨大なページ」を備えた異常なカーネル構成を除いて、ページはほとんど常に4096バイトです（確認するには &lt;code&gt;getconf PAGE_SIZE&lt;/code&gt; を使用してください）。</target>
        </trans-unit>
        <trans-unit id="d525664dcf3bd05b109fdf34118093a16b891bcb" translate="yes" xml:space="preserve">
          <source>The default permissions are &lt;code&gt;0600&lt;/code&gt;, meaning only the server owner can read or write the log files. The other commonly useful setting is &lt;code&gt;0640&lt;/code&gt;, allowing members of the owner's group to read the files. Note however that to make use of such a setting, you'll need to alter &lt;a href=&quot;runtime-config-logging#GUC-LOG-DIRECTORY&quot;&gt;log_directory&lt;/a&gt; to store the files somewhere outside the cluster data directory. In any case, it's unwise to make the log files world-readable, since they might contain sensitive data.</source>
          <target state="translated">デフォルトの権限は &lt;code&gt;0600&lt;/code&gt; です。つまり、サーバーの所有者だけがログファイルを読み書きできます。その他の一般的に役立つ設定は &lt;code&gt;0640&lt;/code&gt; で、所有者のグループのメンバーがファイルを読み取ることができます。ただし、このような設定を利用するには、&lt;a href=&quot;runtime-config-logging#GUC-LOG-DIRECTORY&quot;&gt;log_directory&lt;/a&gt;を変更して、ファイルをクラスターデータディレクトリの外部のどこかに格納する必要があることに注意してください。いずれにせよ、ログファイルには機密データが含まれている可能性があるため、ログファイルを誰でも読み取り可能にすることは賢明ではありません。</target>
        </trans-unit>
        <trans-unit id="d2132a47fb8ed97625d8e6972b86c9c464704580" translate="yes" xml:space="preserve">
          <source>The default permissions are &lt;code&gt;0777&lt;/code&gt;, meaning anyone can connect. Reasonable alternatives are &lt;code&gt;0770&lt;/code&gt; (only user and group, see also &lt;code&gt;unix_socket_group&lt;/code&gt;) and &lt;code&gt;0700&lt;/code&gt; (only user). (Note that for a Unix-domain socket, only write permission matters, so there is no point in setting or revoking read or execute permissions.)</source>
          <target state="translated">デフォルトの許可は &lt;code&gt;0777&lt;/code&gt; で、誰でも接続できることを意味します。 &lt;code&gt;unix_socket_group&lt;/code&gt; な代替手段は &lt;code&gt;0770&lt;/code&gt; （ユーザーとグループのみ、unix_socket_groupも参照）と &lt;code&gt;0700&lt;/code&gt; （ユーザーのみ）です。（Unixドメインソケットの場合、書き込み権限のみが重要であるため、読み取り権限または実行権限を設定または取り消す意味はありません。）</target>
        </trans-unit>
        <trans-unit id="68b85b4979bd5c75a82926a217579dec94acad6f" translate="yes" xml:space="preserve">
          <source>The default roles are described in &lt;a href=&quot;default-roles#DEFAULT-ROLES-TABLE&quot;&gt;Table 21.1&lt;/a&gt;. Note that the specific permissions for each of the default roles may change in the future as additional capabilities are added. Administrators should monitor the release notes for changes.</source>
          <target state="translated">デフォルトの役割を&lt;a href=&quot;default-roles#DEFAULT-ROLES-TABLE&quot;&gt;表21.1に示し&lt;/a&gt;ます。機能が追加されると、デフォルトの各役割の特定の権限が将来変更される可能性があることに注意してください。管理者は、リリースノートの変更を監視する必要があります。</target>
        </trans-unit>
        <trans-unit id="252df4a98d09d9259c2e1911dffde240009cf803" translate="yes" xml:space="preserve">
          <source>The default set of collations provided by &lt;code&gt;libc&lt;/code&gt; map directly to the locales installed in the operating system, which can be listed using the command &lt;code&gt;locale -a&lt;/code&gt;. In case a &lt;code&gt;libc&lt;/code&gt; collation is needed that has different values for &lt;code&gt;LC_COLLATE&lt;/code&gt; and &lt;code&gt;LC_CTYPE&lt;/code&gt;, or if new locales are installed in the operating system after the database system was initialized, then a new collation may be created using the &lt;a href=&quot;sql-createcollation&quot;&gt;CREATE COLLATION&lt;/a&gt; command. New operating system locales can also be imported en masse using the &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-COLLATION&quot;&gt;&lt;code&gt;pg_import_system_collations()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">&lt;code&gt;libc&lt;/code&gt; によって提供されるデフォルトの照合のセットは、オペレーティングシステムにインストールされているロケールに直接マップされ &lt;code&gt;locale -a&lt;/code&gt; 。ロケールは、コマンドlocale -aを使用してリストできます。場合 &lt;code&gt;libc&lt;/code&gt; の照合は、異なる値を有することが必要である &lt;code&gt;LC_COLLATE&lt;/code&gt; と &lt;code&gt;LC_CTYPE&lt;/code&gt; データベースシステムが初期化された後に新しいロケールがオペレーティングシステムにインストールされている場合、または、新しい照合を使用して作成することができる&lt;a href=&quot;sql-createcollation&quot;&gt;COLLATIONのCREATE&lt;/a&gt;コマンドを。新しいオペレーティングシステムロケールは、&lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-COLLATION&quot;&gt; &lt;code&gt;pg_import_system_collations()&lt;/code&gt; &lt;/a&gt;関数を使用してまとめてインポートすることもできます。</target>
        </trans-unit>
        <trans-unit id="bd6c5d1d773597e919f54fc6c40b0813dfeb2846" translate="yes" xml:space="preserve">
          <source>The default settings tend to suffice for normal installations.</source>
          <target state="translated">通常のインストールではデフォルト設定で十分な傾向があります。</target>
        </trans-unit>
        <trans-unit id="1fa3c32f18b7a363e1e30df22bf5f90a31fa97a8" translate="yes" xml:space="preserve">
          <source>The default settings tend to suffice for normal installations. On HP-UX 10, the factory default for &lt;code&gt;SEMMNS&lt;/code&gt; is 128, which might be too low for larger database sites.</source>
          <target state="translated">通常のインストールでは、デフォルト設定で十分です。HP-UX 10では、 &lt;code&gt;SEMMNS&lt;/code&gt; の工場出荷時のデフォルトは128ですが、大規模なデータベースサイトには低すぎる可能性があります。</target>
        </trans-unit>
        <trans-unit id="387f794e89c6e468e480bdf4684dee520f1e3ee6" translate="yes" xml:space="preserve">
          <source>The default shared memory and semaphore settings are usually good enough for most PostgreSQL applications. Solaris defaults to a &lt;code&gt;SHMMAX&lt;/code&gt; of one-quarter of system RAM. To further adjust this setting, use a project setting associated with the &lt;code&gt;postgres&lt;/code&gt; user. For example, run the following as &lt;code&gt;root&lt;/code&gt;:</source>
          <target state="translated">デフォルトの共有メモリとセマフォの設定は、通常、ほとんどのPostgreSQLアプリケーションに十分です。Solarisのデフォルトは、システムRAMの4分の1の &lt;code&gt;SHMMAX&lt;/code&gt; です。この設定をさらに調整するには、 &lt;code&gt;postgres&lt;/code&gt; ユーザーに関連付けられたプロジェクト設定を使用します。たとえば、 &lt;code&gt;root&lt;/code&gt; として以下を実行します。</target>
        </trans-unit>
        <trans-unit id="6f84f4a393cffab388bec3988211dd06baa8b6f3" translate="yes" xml:space="preserve">
          <source>The default shared memory and semaphore settings are usually good enough, unless you have set &lt;code&gt;shared_memory_type&lt;/code&gt; to &lt;code&gt;sysv&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;shared_memory_type&lt;/code&gt; を &lt;code&gt;sysv&lt;/code&gt; に設定していない限り、通常はデフォルトの共有メモリとセマフォの設定で十分です。</target>
        </trans-unit>
        <trans-unit id="8182b5b7aff519b85fd1a2180f16c9dae4671198" translate="yes" xml:space="preserve">
          <source>The default shared memory settings are usually good enough, unless you have set &lt;code&gt;shared_memory_type&lt;/code&gt; to &lt;code&gt;sysv&lt;/code&gt;, and even then only on older kernel versions that shipped with low defaults. System V semaphores are not used on this platform.</source>
          <target state="translated">&lt;code&gt;shared_memory_type&lt;/code&gt; を &lt;code&gt;sysv&lt;/code&gt; に設定していない限り、デフォルトの共有メモリ設定で十分です。その場合でも、デフォルトが低い状態で出荷された古いカーネルバージョンでのみ使用できます。System Vセマフォは、このプラットフォームでは使用されません。</target>
        </trans-unit>
        <trans-unit id="eb304375b17e288f6f388651b3f58cf692da39fb" translate="yes" xml:space="preserve">
          <source>The default shared memory settings are usually good enough, unless you have set &lt;code&gt;shared_memory_type&lt;/code&gt; to &lt;code&gt;sysv&lt;/code&gt;. System V semaphores are not used on this platform.</source>
          <target state="translated">&lt;code&gt;shared_memory_type&lt;/code&gt; を &lt;code&gt;sysv&lt;/code&gt; に設定していない限り、通常はデフォルトの共有メモリ設定で十分です。 System Vセマフォは、このプラットフォームでは使用されません。</target>
        </trans-unit>
        <trans-unit id="c4af5ef9d1d5b1be0577de1bcf13eca580f5485e" translate="yes" xml:space="preserve">
          <source>The default shared memory settings are usually good enough, unless you have set &lt;code&gt;shared_memory_type&lt;/code&gt; to &lt;code&gt;sysv&lt;/code&gt;. You will usually want to increase &lt;code&gt;kern.ipc.semmni&lt;/code&gt; and &lt;code&gt;kern.ipc.semmns&lt;/code&gt;, as NetBSD's default settings for these are uncomfortably small.</source>
          <target state="translated">The default shared memory settings are usually good enough, unless you have set &lt;code&gt;shared_memory_type&lt;/code&gt; to &lt;code&gt;sysv&lt;/code&gt; . You will usually want to increase &lt;code&gt;kern.ipc.semmni&lt;/code&gt; and &lt;code&gt;kern.ipc.semmns&lt;/code&gt; , as NetBSD's default settings for these are uncomfortably small.</target>
        </trans-unit>
        <trans-unit id="5adefc1dbffba745f0ea181ce26972df7feee97e" translate="yes" xml:space="preserve">
          <source>The default shared memory settings are usually good enough, unless you have set &lt;code&gt;shared_memory_type&lt;/code&gt; to &lt;code&gt;sysv&lt;/code&gt;. You will usually want to increase &lt;code&gt;kern.seminfo.semmni&lt;/code&gt; and &lt;code&gt;kern.seminfo.semmns&lt;/code&gt;, as OpenBSD's default settings for these are uncomfortably small.</source>
          <target state="translated">The default shared memory settings are usually good enough, unless you have set &lt;code&gt;shared_memory_type&lt;/code&gt; to &lt;code&gt;sysv&lt;/code&gt; . You will usually want to increase &lt;code&gt;kern.seminfo.semmni&lt;/code&gt; and &lt;code&gt;kern.seminfo.semmns&lt;/code&gt; , as OpenBSD's default settings for these are uncomfortably small.</target>
        </trans-unit>
        <trans-unit id="44e22ca1caa169ea01c4c21799c6c36ccb13234f" translate="yes" xml:space="preserve">
          <source>The default tablespace for the database. Within this database, all tables for which &lt;code&gt;pg_class&lt;/code&gt;.&lt;code&gt;reltablespace&lt;/code&gt; is zero will be stored in this tablespace; in particular, all the non-shared system catalogs will be there.</source>
          <target state="translated">データベースのデフォルトのテーブルスペース。このデータベース内で、 &lt;code&gt;pg_class&lt;/code&gt; のすべてのテーブル。 &lt;code&gt;reltablespace&lt;/code&gt; is zeroは、このテーブルスペースに格納されます。特に、すべての非共有システムカタログが存在します。</target>
        </trans-unit>
        <trans-unit id="80289ade38539d0a5fbe52bfa6a8f6f1dac442e4" translate="yes" xml:space="preserve">
          <source>The default test scenario is also quite sensitive to how long it's been since the tables were initialized: accumulation of dead rows and dead space in the tables changes the results. To understand the results you must keep track of the total number of updates and when vacuuming happens. If autovacuum is enabled it can result in unpredictable changes in measured performance.</source>
          <target state="translated">デフォルトのテストシナリオは、テーブルが初期化されてからどれくらいの時間が経過しているかにも敏感です:テーブルにデッドローやデッドスペースが蓄積されると結果が変わります。結果を理解するためには、更新の総数とバキュームがいつ行われたかを追跡する必要があります。自動バキュームが有効になっている場合、測定されたパフォーマンスに予測できない変化をもたらす可能性があります。</target>
        </trans-unit>
        <trans-unit id="9132263848d1108e0d8602af59d87e147d73248d" translate="yes" xml:space="preserve">
          <source>The default thresholds and scale factors are taken from &lt;code&gt;postgresql.conf&lt;/code&gt;, but it is possible to override them (and many other autovacuum control parameters) on a per-table basis; see &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-STORAGE-PARAMETERS&quot;&gt;Storage Parameters&lt;/a&gt; for more information. If a setting has been changed via a table's storage parameters, that value is used when processing that table; otherwise the global settings are used. See &lt;a href=&quot;runtime-config-autovacuum&quot;&gt;Section 19.10&lt;/a&gt; for more details on the global settings.</source>
          <target state="translated">デフォルトのしきい値とスケール係数は &lt;code&gt;postgresql.conf&lt;/code&gt; から取得されますが、テーブルごとにそれら（および他の多くの自動バキューム制御パラメーター）をオーバーライドすることが可能です。詳細については、&lt;a href=&quot;sql-createtable#SQL-CREATETABLE-STORAGE-PARAMETERS&quot;&gt;ストレージパラメータ&lt;/a&gt;を参照してください。テーブルのストレージパラメータを介して設定が変更された場合、その値はそのテーブルを処理するときに使用されます。それ以外の場合は、グローバル設定が使用されます。参照&lt;a href=&quot;runtime-config-autovacuum&quot;&gt;セクション19.10を&lt;/a&gt;グローバル設定の詳細については。</target>
        </trans-unit>
        <trans-unit id="0424e3dc5096d9c8dbd34cb8d06e5315c54e045d" translate="yes" xml:space="preserve">
          <source>The default time zone is specified as a constant numeric offset from UTC. It is therefore impossible to adapt to daylight-saving time when doing date/time arithmetic across DST boundaries.</source>
          <target state="translated">デフォルトのタイムゾーンは、UTCからの一定の数値オフセットとして指定されます。そのため、DSTの境界を越えて日付/時刻の演算を行う際に、サマータイムに合わせることはできません。</target>
        </trans-unit>
        <trans-unit id="cfbfb39fe00c30f34ca2449d77325fd4667682f6" translate="yes" xml:space="preserve">
          <source>The default timing of the trigger. See the &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; documentation for details of these constraint options. This can only be specified for constraint triggers.</source>
          <target state="translated">トリガーのデフォルトのタイミング。これらの制約オプションの詳細については、&lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLEの&lt;/a&gt;ドキュメントを参照してください。これは、制約トリガーにのみ指定できます。</target>
        </trans-unit>
        <trans-unit id="d7cc14aa1c7871e1d91e9c6189dd189cdc4b1317" translate="yes" xml:space="preserve">
          <source>The default value can be an expression, which will be evaluated whenever the default value is inserted (&lt;em&gt;not&lt;/em&gt; when the table is created). A common example is for a &lt;code&gt;timestamp&lt;/code&gt; column to have a default of &lt;code&gt;CURRENT_TIMESTAMP&lt;/code&gt;, so that it gets set to the time of row insertion. Another common example is generating a &amp;ldquo;serial number&amp;rdquo; for each row. In PostgreSQL this is typically done by something like:</source>
          <target state="translated">デフォルト値は式にすることが&lt;em&gt;でき&lt;/em&gt;、（テーブルの作成時では&lt;em&gt;なく）&lt;/em&gt;デフォルト値が挿入されるたびに評価されます。一般的な例は、 &lt;code&gt;timestamp&lt;/code&gt; 列にデフォルトの &lt;code&gt;CURRENT_TIMESTAMP&lt;/code&gt; を設定して、行が挿入された時刻に設定されるようにすることです。別の一般的な例は、各行の「シリアル番号」を生成することです。 PostgreSQLでは、これは通常次のような方法で行われます。</target>
        </trans-unit>
        <trans-unit id="0b0db30e831b0c9d520dd21139ba84ee034c9c6b" translate="yes" xml:space="preserve">
          <source>The default value for the data type. If this is omitted, the default is null.</source>
          <target state="translated">データ型のデフォルト値です。これを省略した場合、デフォルトはnullとなります。</target>
        </trans-unit>
        <trans-unit id="ee14fce3a3ca851f605a2ff7d5b6a51a01fb240b" translate="yes" xml:space="preserve">
          <source>The default value for this parameter is &lt;code&gt;&quot;$user&quot;, public&lt;/code&gt;. This setting supports shared use of a database (where no users have private schemas, and all share use of &lt;code&gt;public&lt;/code&gt;), private per-user schemas, and combinations of these. Other effects can be obtained by altering the default search path setting, either globally or per-user.</source>
          <target state="translated">このパラメーターのデフォルト値は &lt;code&gt;&quot;$user&quot;, public&lt;/code&gt; です。この設定は、データベースの共有使用（ユーザーがプライベートスキーマを持たず、すべてが &lt;code&gt;public&lt;/code&gt; の共有使用）、ユーザーごとのプライベートスキーマ、およびこれらの組み合わせをサポートします。他の効果は、デフォルトの検索パス設定をグローバルに、またはユーザーごとに変更することで得られます。</target>
        </trans-unit>
        <trans-unit id="85d16eca710f45efd17caf29c22cdac95ac6757a" translate="yes" xml:space="preserve">
          <source>The default value for this parameter is &lt;code&gt;'$libdir'&lt;/code&gt;. If the value is set to an empty string, the automatic path search is turned off.</source>
          <target state="translated">このパラメーターのデフォルト値は &lt;code&gt;'$libdir'&lt;/code&gt; です。値が空の文字列に設定されている場合、自動パス検索はオフになります。</target>
        </trans-unit>
        <trans-unit id="71d008eed3fec13080aed7c6d124a51c1f2df8b8" translate="yes" xml:space="preserve">
          <source>The default value is 2.</source>
          <target state="translated">デフォルト値は2です。</target>
        </trans-unit>
        <trans-unit id="d8e9c33db68a29a970a8558f211b5f4b07ef1edd" translate="yes" xml:space="preserve">
          <source>The default value is 4.</source>
          <target state="translated">デフォルト値は4です。</target>
        </trans-unit>
        <trans-unit id="65c175fa9341b5e979c73accbe6240cd619cd0dc" translate="yes" xml:space="preserve">
          <source>The default value is &lt;code&gt;error=01;31:warning=01;35:locus=01&lt;/code&gt; (&lt;code&gt;01;31&lt;/code&gt; = bold red, &lt;code&gt;01;35&lt;/code&gt; = bold magenta, &lt;code&gt;01&lt;/code&gt; = bold default color).</source>
          <target state="translated">The default value is &lt;code&gt;error=01;31:warning=01;35:locus=01&lt;/code&gt; ( &lt;code&gt;01;31&lt;/code&gt; = bold red, &lt;code&gt;01;35&lt;/code&gt; = bold magenta, &lt;code&gt;01&lt;/code&gt; = bold default color).</target>
        </trans-unit>
        <trans-unit id="ca161bfe7f68575f9b78d9b22cc20c4f61990ca6" translate="yes" xml:space="preserve">
          <source>The default value is an empty string, which results in all temporary objects being created in the default tablespace of the current database.</source>
          <target state="translated">デフォルト値は空の文字列で、現在のデータベースのデフォルトのテーブルスペースにすべてのテンポラリオブジェクトが作成されます。</target>
        </trans-unit>
        <trans-unit id="2dbc96deb9627171cbe40ca7523d55ca78505616" translate="yes" xml:space="preserve">
          <source>The default value is defined as the value that the parameter would have had, if no &lt;code&gt;SET&lt;/code&gt; had ever been issued for it in the current session. The actual source of this value might be a compiled-in default, the configuration file, command-line options, or per-database or per-user default settings. This is subtly different from defining it as &amp;ldquo;the value that the parameter had at session start&amp;rdquo;, because if the value came from the configuration file, it will be reset to whatever is specified by the configuration file now. See &lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;Chapter 19&lt;/a&gt; for details.</source>
          <target state="translated">デフォルト値は、現在のセッションで &lt;code&gt;SET&lt;/code&gt; が発行されていなかった場合のパラメータの値として定義されています。この値の実際のソースは、コンパイル済みのデフォルト、構成ファイル、コマンドラインオプション、またはデータベースごとまたはユーザーごとのデフォルト設定です。これは、「セッションの開始時にパラメーターが持っていた値」と定義することとは微妙に異なります。値が構成ファイルからのものである場合は、構成ファイルで指定されている値にリセットされるからです。詳細については、&lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;第19章&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="04f2d094b00a5be29b7b3b7af554f26ca4e00d68" translate="yes" xml:space="preserve">
          <source>The default value is defined as the value that the parameter would have had, if no &lt;code&gt;SET&lt;/code&gt; had ever been issued for it in the current session. The actual source of this value might be a compiled-in default, the configuration file, command-line options, or per-database or per-user default settings. This is subtly different from defining it as &amp;ldquo;the value that the parameter had at session start&amp;rdquo;, because if the value came from the configuration file, it will be reset to whatever is specified by the configuration file now. See &lt;a href=&quot;https://www.postgresql.org/docs/13/runtime-config.html&quot;&gt;Chapter 19&lt;/a&gt; for details.</source>
          <target state="translated">The default value is defined as the value that the parameter would have had, if no &lt;code&gt;SET&lt;/code&gt; had ever been issued for it in the current session. The actual source of this value might be a compiled-in default, the configuration file, command-line options, or per-database or per-user default settings. This is subtly different from defining it as &amp;ldquo;the value that the parameter had at session start&amp;rdquo;, because if the value came from the configuration file, it will be reset to whatever is specified by the configuration file now. See &lt;a href=&quot;https://www.postgresql.org/docs/13/runtime-config.html&quot;&gt;Chapter 19&lt;/a&gt; for details.</target>
        </trans-unit>
        <trans-unit id="7169dc9a643791bfe51c929b266f11a33c289429" translate="yes" xml:space="preserve">
          <source>The default value is three connections. The value must be less than &lt;code&gt;max_connections&lt;/code&gt;. This parameter can only be set at server start.</source>
          <target state="translated">デフォルト値は3つの接続です。値は &lt;code&gt;max_connections&lt;/code&gt; より小さくなければなりません。このパラメータは、サーバーの起動時にのみ設定できます。</target>
        </trans-unit>
        <trans-unit id="72f22d9e98b0402b3ffa342734437db31335a193" translate="yes" xml:space="preserve">
          <source>The default value of this setting is the empty string, which disables the feature. It can be set to &lt;code&gt;all&lt;/code&gt; to check all records, or to a comma-separated list of resource managers to check only records originating from those resource managers. Currently, the supported resource managers are &lt;code&gt;heap&lt;/code&gt;, &lt;code&gt;heap2&lt;/code&gt;, &lt;code&gt;btree&lt;/code&gt;, &lt;code&gt;hash&lt;/code&gt;, &lt;code&gt;gin&lt;/code&gt;, &lt;code&gt;gist&lt;/code&gt;, &lt;code&gt;sequence&lt;/code&gt;, &lt;code&gt;spgist&lt;/code&gt;, &lt;code&gt;brin&lt;/code&gt;, and &lt;code&gt;generic&lt;/code&gt;. Only superusers can change this setting.</source>
          <target state="translated">この設定のデフォルト値は空の文字列で、この機能は無効になっています。 &lt;code&gt;all&lt;/code&gt; に設定してすべてのレコードをチェックするか、リソースマネージャーのコンマ区切りのリストに設定して、それらのリソースマネージャーから発信されたレコードのみをチェックすることができます。現在、サポートされているリソースマネージャは、 &lt;code&gt;heap&lt;/code&gt; 、 &lt;code&gt;heap2&lt;/code&gt; 、 &lt;code&gt;btree&lt;/code&gt; 、 &lt;code&gt;hash&lt;/code&gt; 、 &lt;code&gt;gin&lt;/code&gt; 、 &lt;code&gt;gist&lt;/code&gt; 、 &lt;code&gt;sequence&lt;/code&gt; 、 &lt;code&gt;spgist&lt;/code&gt; 、 &lt;code&gt;brin&lt;/code&gt; 、および &lt;code&gt;generic&lt;/code&gt; 。この設定を変更できるのはスーパーユーザーだけです。</target>
        </trans-unit>
        <trans-unit id="20ab73f20d81504384efda8f5568618702ec519f" translate="yes" xml:space="preserve">
          <source>The default virtual memory behavior on Linux is not optimal for PostgreSQL. Because of the way that the kernel implements memory overcommit, the kernel might terminate the PostgreSQL postmaster (the master server process) if the memory demands of either PostgreSQL or another process cause the system to run out of virtual memory.</source>
          <target state="translated">Linuxのデフォルトの仮想メモリの動作はPostgreSQLには最適ではありません。カーネルがメモリオーバーコミットを実装する方法のため、PostgreSQLや他のプロセスのメモリ要求によりシステムが仮想メモリを使い果たした場合、カーネルはPostgreSQLのポストマスタ(マスタサーバプロセス)を終了させる可能性があります。</target>
        </trans-unit>
        <trans-unit id="dd9068090248fdb711a8f2a412ca5077ebbda170" translate="yes" xml:space="preserve">
          <source>The defined collation of the column, or zero if the column is not of a collatable data type.</source>
          <target state="translated">列の定義された照合順序、または列が照合可能なデータ型でない場合はゼロ。</target>
        </trans-unit>
        <trans-unit id="b0e121be440089b477e6ea25c5d7cb8d2a246664" translate="yes" xml:space="preserve">
          <source>The definitions of the columns exposed by the view are shown in &lt;a href=&quot;pgbuffercache#PGBUFFERCACHE-COLUMNS&quot;&gt;Table F.15&lt;/a&gt;.</source>
          <target state="translated">ビューによって公開される列の定義を&lt;a href=&quot;pgbuffercache#PGBUFFERCACHE-COLUMNS&quot;&gt;表F.15に&lt;/a&gt;示します。</target>
        </trans-unit>
        <trans-unit id="a8c0177656a1475222b9e9f01f048f945368cb6d" translate="yes" xml:space="preserve">
          <source>The delay occurs once the database in recovery has reached a consistent state, until the standby is promoted or triggered. After that the standby will end recovery without further waiting.</source>
          <target state="translated">遅延は、回復中のデータベースが一貫した状態になると、スタンバイが昇格またはトリガされるまで発生します。その後、スタンバイはそれ以上待たずに回復を終了します。</target>
        </trans-unit>
        <trans-unit id="37c54600b84522926deb2fb64ab7c8c51ddae0fc" translate="yes" xml:space="preserve">
          <source>The delay occurs only on WAL records for transaction commits. Other records are replayed as quickly as possible, which is not a problem because MVCC visibility rules ensure their effects are not visible until the corresponding commit record is applied.</source>
          <target state="translated">遅延が発生するのは、トランザクションコミットの WAL レコードのみです。その他のレコードは可能な限り迅速に再生されますが、MVCC の可視化ルールにより、対応するコミットレコードが適用されるまでその効果が見えないようになっているため、これは問題ではありません。</target>
        </trans-unit>
        <trans-unit id="790720978a39aefa71d264470fa610449c099e01" translate="yes" xml:space="preserve">
          <source>The delimiter character to be used between values in arrays made of this type.</source>
          <target state="translated">この型で作られた配列の値の間に使用される区切り文字です。</target>
        </trans-unit>
        <trans-unit id="e3f72476c5f4c3f27d14849d70a712b70cac2da9" translate="yes" xml:space="preserve">
          <source>The dependent object can be dropped separately from the referenced object, and should be automatically dropped (regardless of &lt;code&gt;RESTRICT&lt;/code&gt; or &lt;code&gt;CASCADE&lt;/code&gt; mode) if the referenced object is dropped. Example: a named constraint on a table is made auto-dependent on the table, so that it will go away if the table is dropped.</source>
          <target state="translated">依存オブジェクトは、参照オブジェクトとは別に削除できます。参照オブジェクトが削除されると、（ &lt;code&gt;RESTRICT&lt;/code&gt; または &lt;code&gt;CASCADE&lt;/code&gt; モードに関係なく）自動的に削除されます。例：テーブルの名前付き制約はテーブルに自動的に依存するため、テーブルが削除された場合、制約はなくなります。</target>
        </trans-unit>
        <trans-unit id="42b52b99ac2341cf62bd00d9b5e1bc3f8c4f0ef2" translate="yes" xml:space="preserve">
          <source>The dependent object is a member of the &lt;em&gt;extension&lt;/em&gt; that is the referenced object (see &lt;a href=&quot;catalog-pg-extension&quot;&gt;&lt;code&gt;pg_extension&lt;/code&gt;&lt;/a&gt;). The dependent object can be dropped only via &lt;code&gt;DROP EXTENSION&lt;/code&gt; on the referenced object. Functionally this dependency type acts the same as an &lt;code&gt;INTERNAL&lt;/code&gt; dependency, but it's kept separate for clarity and to simplify pg_dump.</source>
          <target state="translated">依存オブジェクトは、参照オブジェクトである&lt;em&gt;拡張機能の&lt;/em&gt;メンバーです（&lt;a href=&quot;catalog-pg-extension&quot;&gt; &lt;code&gt;pg_extension&lt;/code&gt; を&lt;/a&gt;参照）。依存オブジェクトは、参照オブジェクトの &lt;code&gt;DROP EXTENSION&lt;/code&gt; を介してのみ削除できます。機能的には、この依存関係タイプは &lt;code&gt;INTERNAL&lt;/code&gt; 依存関係と同じように機能しますが、明確にするため、およびpg_dumpを簡略化するために、別々に保持されています。</target>
        </trans-unit>
        <trans-unit id="bf57c8a0f5e570bb9686592bde8b3b28f101a435" translate="yes" xml:space="preserve">
          <source>The dependent object is not a member of the extension that is the referenced object (and so it should not be ignored by pg_dump), but it cannot function without the extension and should be auto-dropped if the extension is. The dependent object may be dropped on its own as well. Functionally this dependency type acts the same as an &lt;code&gt;AUTO&lt;/code&gt; dependency, but it's kept separate for clarity and to simplify pg_dump.</source>
          <target state="translated">依存オブジェクトは、参照オブジェクトである拡張機能のメンバーではありません（したがって、pg_dumpによって無視されるべきではありません）が、拡張機能なしで機能することはできず、拡張機能がある場合は自動的に削除されます。依存オブジェクトは、それ自体で削除される場合もあります。機能的には、この依存関係タイプは &lt;code&gt;AUTO&lt;/code&gt; 依存関係と同じように機能しますが、明確にするため、およびpg_dumpを簡略化するために、個別に保持されています。</target>
        </trans-unit>
        <trans-unit id="39aa74188fe1f062ac474926c65191d5babb5508" translate="yes" xml:space="preserve">
          <source>The dependent object was created as part of creation of the referenced object, and is really just a part of its internal implementation. A direct &lt;code&gt;DROP&lt;/code&gt; of the dependent object will be disallowed outright (we'll tell the user to issue a &lt;code&gt;DROP&lt;/code&gt; against the referenced object, instead). A &lt;code&gt;DROP&lt;/code&gt; of the referenced object will result in automatically dropping the dependent object whether &lt;code&gt;CASCADE&lt;/code&gt; is specified or not. If the dependent object has to be dropped due to a dependency on some other object being removed, its drop is converted to a drop of the referenced object, so that &lt;code&gt;NORMAL&lt;/code&gt; and &lt;code&gt;AUTO&lt;/code&gt; dependencies of the dependent object behave much like they were dependencies of the referenced object. Example: a view's &lt;code&gt;ON SELECT&lt;/code&gt; rule is made internally dependent on the view, preventing it from being dropped while the view remains. Dependencies of the rule (such as tables it refers to) act as if they were dependencies of the view.</source>
          <target state="translated">依存オブジェクトは、参照オブジェクトの作成の一部として作成されたものであり、実際にはその内部実装の一部にすぎません。依存オブジェクトの直接 &lt;code&gt;DROP&lt;/code&gt; は完全に禁止されます（代わりに、参照されたオブジェクトに対して &lt;code&gt;DROP&lt;/code&gt; を発行するようにユーザーに通知します）。 &lt;code&gt;DROP&lt;/code&gt; 参照オブジェクトのは、自動的にかどうかに依存するオブジェクトドロップをもたらす &lt;code&gt;CASCADE&lt;/code&gt; が指定され又はされていないが。他のオブジェクトへの依存関係が削除されたために依存オブジェクトを削除する必要がある場合、そのドロップは参照オブジェクトのドロップに変換されるため、 &lt;code&gt;NORMAL&lt;/code&gt; および &lt;code&gt;AUTO&lt;/code&gt; 依存オブジェクトの依存関係は、参照オブジェクトの依存関係とほとんど同じように動作します。例：ビューの &lt;code&gt;ON SELECT&lt;/code&gt; ルールは内部的にビューに依存しており、ビューが残っている間はドロップされません。ルールの依存関係（参照するテーブルなど）は、ビューの依存関係であるかのように動作します。</target>
        </trans-unit>
        <trans-unit id="6f08ad4e0433fd5acac3297aba03b2acf8ab1183" translate="yes" xml:space="preserve">
          <source>The dependent object was created as part of creation of the referenced object, and is really just a part of its internal implementation; however, unlike &lt;code&gt;INTERNAL&lt;/code&gt;, there is more than one such referenced object. The dependent object must not be dropped unless at least one of these referenced objects is dropped; if any one is, the dependent object should be dropped whether or not &lt;code&gt;CASCADE&lt;/code&gt; is specified. Also unlike &lt;code&gt;INTERNAL&lt;/code&gt;, a drop of some other object that the dependent object depends on does not result in automatic deletion of any partition-referenced object. Hence, if the drop does not cascade to at least one of these objects via some other path, it will be refused. (In most cases, the dependent object shares all its non-partition dependencies with at least one partition-referenced object, so that this restriction does not result in blocking any cascaded delete.) Primary and secondary partition dependencies behave identically except that the primary dependency is preferred for use in error messages; hence, a partition-dependent object should have one primary partition dependency and one or more secondary partition dependencies. Note that partition dependencies are made in addition to, not instead of, any dependencies the object would normally have. This simplifies &lt;code&gt;ATTACH/DETACH PARTITION&lt;/code&gt; operations: the partition dependencies need only be added or removed. Example: a child partitioned index is made partition-dependent on both the partition table it is on and the parent partitioned index, so that it goes away if either of those is dropped, but not otherwise. The dependency on the parent index is primary, so that if the user tries to drop the child partitioned index, the error message will suggest dropping the parent index instead (not the table).</source>
          <target state="translated">依存オブジェクトは、参照オブジェクトの作成の一部として作成されたものであり、実際には内部実装の一部にすぎません。ただし、 &lt;code&gt;INTERNAL&lt;/code&gt; とは異なり、そのような参照オブジェクトは複数存在します。これらの参照オブジェクトの少なくとも1つが削除されない限り、依存オブジェクトは削除しないでください。いずれかが存在する場合、 &lt;code&gt;CASCADE&lt;/code&gt; が指定されているかどうかに関係なく、依存オブジェクトを削除する必要があります。また、 &lt;code&gt;INTERNAL&lt;/code&gt; とは異なり、依存オブジェクトが依存する他のオブジェクトを削除しても、パーティション参照オブジェクトは自動的に削除されません。したがって、ドロップが他のパスを介してこれらのオブジェクトの少なくとも1つにカスケードされない場合、ドロップは拒否されます。 （ほとんどの場合、依存オブジェクトはすべての非パーティション依存関係を少なくとも1つのパーティション参照オブジェクトと共有するため、この制限によってカスケード削除がブロックされることはありません。）プライマリおよびセカンダリパーティションの依存関係は、プライマリ依存関係を除いて同じように動作します。エラーメッセージでの使用が推奨されます。したがって、パーティション依存オブジェクトには、1つのプライマリパーティション依存関係と1つ以上のセカンダリパーティション依存関係が必要です。パーティションの依存関係は、オブジェクトが通常持っている依存関係に追加されるのではなく、追加されることに注意してください。これにより、 &lt;code&gt;ATTACH/DETACH PARTITION&lt;/code&gt; 操作：パーティションの依存関係を追加または削除するだけです。例：子パーティションインデックスは、それが配置されているパーティションテーブルと親パーティションインデックスの両方にパーティション依存になるため、どちらかが削除された場合は削除されますが、それ以外の場合は削除されません。親インデックスへの依存関係は主なものであるため、ユーザーが子パーティションインデックスを削除しようとすると、エラーメッセージは代わりに（テーブルではなく）親インデックスを削除することを提案します。</target>
        </trans-unit>
        <trans-unit id="7ba979debfd87ef975dc568dd7e8792b4269670b" translate="yes" xml:space="preserve">
          <source>The desired new version of the extension. This can be written as either an identifier or a string literal. If not specified, &lt;code&gt;ALTER EXTENSION UPDATE&lt;/code&gt; attempts to update to whatever is shown as the default version in the extension's control file.</source>
          <target state="translated">拡張の目的の新しいバージョン。これは、識別子または文字列リテラルとして記述できます。指定されていない場合、 &lt;code&gt;ALTER EXTENSION UPDATE&lt;/code&gt; は、拡張機能の制御ファイルでデフォルトバージョンとして示されているものへの更新を試みます。</target>
        </trans-unit>
        <trans-unit id="fbd0e34ca3a19b97d0aeb9f0e2c89bbf73246c51" translate="yes" xml:space="preserve">
          <source>The destination encoding name.</source>
          <target state="translated">宛先のエンコード名。</target>
        </trans-unit>
        <trans-unit id="acbe64874af1481c3f0cac1a6029d7f03fb77273" translate="yes" xml:space="preserve">
          <source>The details of these commands are not important here; the important point is that there are several separate updates involved to accomplish this rather simple operation. Our bank's officers will want to be assured that either all these updates happen, or none of them happen. It would certainly not do for a system failure to result in Bob receiving $100.00 that was not debited from Alice. Nor would Alice long remain a happy customer if she was debited without Bob being credited. We need a guarantee that if something goes wrong partway through the operation, none of the steps executed so far will take effect. Grouping the updates into a &lt;em&gt;transaction&lt;/em&gt; gives us this guarantee. A transaction is said to be &lt;em&gt;atomic&lt;/em&gt;: from the point of view of other transactions, it either happens completely or not at all.</source>
          <target state="translated">これらのコマンドの詳細はここでは重要ではありません。重要な点は、このかなり単純な操作を実行するために、いくつかの個別の更新が含まれていることです。私たちの銀行の役員は、これらすべての更新が行われるか、またはどれも行われないことを保証する必要があります。システム障害が原因でボブがアリスから引き落とされなかった$ 100.00を受け取ることは確かにありません。アリスがボブにクレジットされずに引き落とされたとしても、アリスは長い間幸せな顧客であり続けるでしょう。操作の途中で問題が発生した場合、これまでに実行されたどのステップも有効にならないことを保証する必要があります。更新を&lt;em&gt;トランザクションに&lt;/em&gt;グループ化すると、この保証が得られます。トランザクションは&lt;em&gt;アトミックで&lt;/em&gt;あると言われています&lt;em&gt;&lt;/em&gt;：他のトランザクションの観点からは、完全に発生するか、まったく発生しないかのどちらかです。</target>
        </trans-unit>
        <trans-unit id="81c51a0e7b9a40e273e8f7fe3f2164c947629b88" translate="yes" xml:space="preserve">
          <source>The dictionary accepts three options:</source>
          <target state="translated">辞書は3つのオプションを受け付けます。</target>
        </trans-unit>
        <trans-unit id="9e98ae374f333e238cb54e40ccd57bf293c2950f" translate="yes" xml:space="preserve">
          <source>The dictionary accepts two options:</source>
          <target state="translated">辞書は2つのオプションを受け付けます。</target>
        </trans-unit>
        <trans-unit id="a19f3de80263e9a6413003bf67d42fb29a4dfff8" translate="yes" xml:space="preserve">
          <source>The difference between enabling &lt;code&gt;log_duration&lt;/code&gt; and setting &lt;a href=&quot;runtime-config-logging#GUC-LOG-MIN-DURATION-STATEMENT&quot;&gt;log_min_duration_statement&lt;/a&gt; to zero is that exceeding &lt;code&gt;log_min_duration_statement&lt;/code&gt; forces the text of the query to be logged, but this option doesn't. Thus, if &lt;code&gt;log_duration&lt;/code&gt; is &lt;code&gt;on&lt;/code&gt; and &lt;code&gt;log_min_duration_statement&lt;/code&gt; has a positive value, all durations are logged but the query text is included only for statements exceeding the threshold. This behavior can be useful for gathering statistics in high-load installations.</source>
          <target state="translated">有効違い &lt;code&gt;log_duration&lt;/code&gt; をして設定&lt;a href=&quot;runtime-config-logging#GUC-LOG-MIN-DURATION-STATEMENT&quot;&gt;log_min_duration_statementを&lt;/a&gt;ゼロには超えていることである &lt;code&gt;log_min_duration_statement&lt;/code&gt; がログに記録されるクエリのテキストを強制的に、しかし、このオプションはありません。したがって、 &lt;code&gt;log_duration&lt;/code&gt; が &lt;code&gt;on&lt;/code&gt; 、 &lt;code&gt;log_min_duration_statement&lt;/code&gt; に正の値がある場合、すべての期間が記録されますが、クエリテキストは、しきい値を超えるステートメントに対してのみ含まれます。この動作は、高負荷のインストールで統計を収集するのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="86d6a3829cada6f81d9cef342af0288f96d331f4" translate="yes" xml:space="preserve">
          <source>The difference is that the query against the summary table has to get only one row from the table, whereas the direct query against &lt;code&gt;one_to_many&lt;/code&gt; must index scan and fetch a row for each entry.</source>
          <target state="translated">違いは、サマリーテーブルに対するクエリはテーブルから行を1つだけ取得する必要があるのに対し、 &lt;code&gt;one_to_many&lt;/code&gt; に対する直接クエリはインデックススキャンを実行し、各エントリの行をフェッチする必要があることです。</target>
        </trans-unit>
        <trans-unit id="638327d505052c3c14e5ba331469e70ba93f8131" translate="yes" xml:space="preserve">
          <source>The differences highlighted here are not all of them. In XQuery and the 2.0 and later versions of XPath, there is an XPath 1.0 compatibility mode, and the W3C lists of &lt;a href=&quot;https://www.w3.org/TR/2010/REC-xpath-functions-20101214/#xpath1-compatibility&quot;&gt;function library changes&lt;/a&gt; and &lt;a href=&quot;https://www.w3.org/TR/xpath20/#id-backwards-compatibility&quot;&gt;language changes&lt;/a&gt; applied in that mode offer a more complete (but still not exhaustive) account of the differences. The compatibility mode cannot make the later languages exactly equivalent to XPath 1.0.</source>
          <target state="translated">ここで強調表示されている違いはそれらのすべてではありません。 XQueryと2.0以降のバージョンのXPathには、XPath 1.0互換モードがあり、そのモードで適用される&lt;a href=&quot;https://www.w3.org/TR/2010/REC-xpath-functions-20101214/#xpath1-compatibility&quot;&gt;関数ライブラリの変更&lt;/a&gt;と&lt;a href=&quot;https://www.w3.org/TR/xpath20/#id-backwards-compatibility&quot;&gt;言語の変更&lt;/a&gt;のW3Cリストは、違いのより完全な（しかし網羅的ではない）アカウントを提供します。互換モードでは、それ以降の言語をXPath 1.0とまったく同じにすることはできません。</target>
        </trans-unit>
        <trans-unit id="3e588858632409434bd776e63f92b5761c3db20c" translate="yes" xml:space="preserve">
          <source>The directory &lt;code&gt;$PGDATA/pg_tblspc&lt;/code&gt; contains symbolic links that point to each of the non-built-in tablespaces defined in the cluster. Although not recommended, it is possible to adjust the tablespace layout by hand by redefining these links. Under no circumstances perform this operation while the server is running. Note that in PostgreSQL 9.1 and earlier you will also need to update the &lt;code&gt;pg_tablespace&lt;/code&gt; catalog with the new locations. (If you do not, &lt;code&gt;pg_dump&lt;/code&gt; will continue to output the old tablespace locations.)</source>
          <target state="translated">ディレクトリ &lt;code&gt;$PGDATA/pg_tblspc&lt;/code&gt; は、クラスターで定義されている非組み込みの各テーブルスペースを指すシンボリックリンクが含まれています。お勧めしませんが、これらのリンクを再定義することにより、手動でテーブルスペースのレイアウトを調整することができます。サーバーが稼働している間は、この操作を実行しないでください。PostgreSQL 9.1以前では、 &lt;code&gt;pg_tablespace&lt;/code&gt; カタログも新しい場所で更新する必要があることに注意してください。（そうしないと、 &lt;code&gt;pg_dump&lt;/code&gt; は古いテーブルスペースの場所を出力し続けます。）</target>
        </trans-unit>
        <trans-unit id="48e3d4bb3b396fb8ccb3377c9877d054f3fd3eaa" translate="yes" xml:space="preserve">
          <source>The directory &lt;code&gt;src/test/locale&lt;/code&gt; in the source distribution contains a test suite for PostgreSQL's locale support.</source>
          <target state="translated">ソース配布のディレクトリ &lt;code&gt;src/test/locale&lt;/code&gt; には、PostgreSQLのロケールサポート用のテストスイートが含まれています。</target>
        </trans-unit>
        <trans-unit id="8f609b85a02a4ded47fa5c57a791418dd0d72112" translate="yes" xml:space="preserve">
          <source>The directory that will be used for the tablespace. The directory must exist (&lt;code&gt;CREATE TABLESPACE&lt;/code&gt; will not create it), should be empty, and must be owned by the PostgreSQL system user. The directory must be specified by an absolute path name.</source>
          <target state="translated">テーブルスペースに使用されるディレクトリ。ディレクトリは存在しなければならず（ &lt;code&gt;CREATE TABLESPACE&lt;/code&gt; はそれを作成しません）、空であり、PostgreSQLシステムユーザーが所有している必要があります。ディレクトリは絶対パス名で指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="0c9ae3d8cb40fd37366fec2ea07a50700e4c2316" translate="yes" xml:space="preserve">
          <source>The domain this constraint is on; 0 if not a domain constraint</source>
          <target state="translated">ドメイン制約でない場合は0。</target>
        </trans-unit>
        <trans-unit id="66141cd3e18bcdc88d4a038dfc634ffad3fa560d" translate="yes" xml:space="preserve">
          <source>The drawback of this procedure is that it depends on the integrity of the client: if the client machine is untrusted or compromised, an attacker could run just about any program on port 113 and return any user name they choose. This authentication method is therefore only appropriate for closed networks where each client machine is under tight control and where the database and system administrators operate in close contact. In other words, you must trust the machine running the ident server. Heed the warning:</source>
          <target state="translated">この手順の欠点は、クライアントの完全性に依存することです。クライアント・マシンが信頼されていなかったり、危殆化していたりすると、攻撃者はポート 113 であらゆるプログラムを実行し、任意のユーザ名を返すことができます。したがって、この認証方法は、各クライアントマシンが厳重に管理されており、データベースとシステム管理者が密接に連絡を取り合って動作しているクローズドネットワークにのみ適しています。言い換えれば、 ident サーバを実行しているマシンを信頼しなければなりません。警告に注意してください。</target>
        </trans-unit>
        <trans-unit id="13aa020c26befcd9c06640c85756679a7699e20c" translate="yes" xml:space="preserve">
          <source>The drawback of using locales other than &lt;code&gt;C&lt;/code&gt; or &lt;code&gt;POSIX&lt;/code&gt; in PostgreSQL is its performance impact. It slows character handling and prevents ordinary indexes from being used by &lt;code&gt;LIKE&lt;/code&gt;. For this reason use locales only if you actually need them.</source>
          <target state="translated">PostgreSQLで &lt;code&gt;C&lt;/code&gt; または &lt;code&gt;POSIX&lt;/code&gt; 以外のロケールを使用することの欠点は、パフォーマンスへの影響です。文字の処理が遅くなり、通常のインデックスが &lt;code&gt;LIKE&lt;/code&gt; で使用されなくなります。このため、実際に必要な場合にのみロケールを使用してください。</target>
        </trans-unit>
        <trans-unit id="ff3e6b54f5a69b71d88bd211c608fb1a58dc225c" translate="yes" xml:space="preserve">
          <source>The dump file produced by pg_dump does not contain the statistics used by the optimizer to make query planning decisions. Therefore, it is wise to run &lt;code&gt;ANALYZE&lt;/code&gt; after restoring from a dump file to ensure optimal performance; see &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-STATISTICS&quot;&gt;Section 24.1.3&lt;/a&gt; and &lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;Section 24.1.6&lt;/a&gt; for more information.</source>
          <target state="translated">pg_dumpによって生成されたダンプファイルには、クエリの計画を決定するためにオプティマイザが使用する統計が含まれていません。したがって、最適なパフォーマンスを確保するには、ダンプファイルから復元した後に &lt;code&gt;ANALYZE&lt;/code&gt; を実行するのが賢明です。詳細は、&lt;a href=&quot;routine-vacuuming#VACUUM-FOR-STATISTICS&quot;&gt;セクション24.1.3&lt;/a&gt;および&lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;セクション24.1.6&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="7b92c28f4a6038b16d370463cb2b0c497c1536e4" translate="yes" xml:space="preserve">
          <source>The dump script should not be expected to run completely without errors. In particular, because the script will issue &lt;code&gt;CREATE ROLE&lt;/code&gt; for every role existing in the source cluster, it is certain to get a &amp;ldquo;role already exists&amp;rdquo; error for the bootstrap superuser, unless the destination cluster was initialized with a different bootstrap superuser name. This error is harmless and should be ignored. Use of the &lt;code&gt;--clean&lt;/code&gt; option is likely to produce additional harmless error messages about non-existent objects, although you can minimize those by adding &lt;code&gt;--if-exists&lt;/code&gt;.</source>
          <target state="translated">ダンプスクリプトは、エラーなしで完全に実行されることを期待すべきではありません。特に、スクリプトはソースクラスターに存在するすべての &lt;code&gt;CREATE ROLE&lt;/code&gt; に対してCREATE ROLEを発行するので、宛先クラスターが別のブートストラップスーパーユーザー名で初期化されていない限り、ブートストラップスーパーユーザーに対して「ロールはすでに存在します」エラーが発生します。このエラーは無害であるため、無視してください。 &lt;code&gt;--clean&lt;/code&gt; オプションを使用すると、存在しないオブジェクトに関する追加の無害なエラーメッセージが生成される可能性がありますが、 &lt;code&gt;--if-exists&lt;/code&gt; を追加することでそれらを最小限に抑えることができます。</target>
        </trans-unit>
        <trans-unit id="7f3181a66ca9fbe6427fab730ca21eb224bb5bb9" translate="yes" xml:space="preserve">
          <source>The dumps produced by pg_dump are relative to &lt;code&gt;template0&lt;/code&gt;. This means that any languages, procedures, etc. added via &lt;code&gt;template1&lt;/code&gt; will also be dumped by pg_dump. As a result, when restoring, if you are using a customized &lt;code&gt;template1&lt;/code&gt;, you must create the empty database from &lt;code&gt;template0&lt;/code&gt;, as in the example above.</source>
          <target state="translated">pg_dumpによって生成されるダンプは、 &lt;code&gt;template0&lt;/code&gt; に関連しています。これは、 &lt;code&gt;template1&lt;/code&gt; を介して追加された言語、手順などもpg_dumpによってダンプされることを意味します。その結果、カスタマイズされた &lt;code&gt;template1&lt;/code&gt; を使用している場合は、復元時に、上の例のように、 &lt;code&gt;template0&lt;/code&gt; から空のデータベースを作成する必要があります。</target>
        </trans-unit>
        <trans-unit id="95dc72eaaf7198b33e4096fb87aae7d094164670" translate="yes" xml:space="preserve">
          <source>The earliest LSN at which replay on the indicated timeline may end when making use of this backup. This is stored in the same format as &lt;code&gt;Start-LSN&lt;/code&gt;.</source>
          <target state="translated">The earliest LSN at which replay on the indicated timeline may end when making use of this backup. This is stored in the same format as &lt;code&gt;Start-LSN&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7817fb8368f1c7b07f344d07c4746bc348201b26" translate="yes" xml:space="preserve">
          <source>The easiest way to perform a base backup is to use the &lt;a href=&quot;app-pgbasebackup&quot;&gt;pg_basebackup&lt;/a&gt; tool. It can create a base backup either as regular files or as a tar archive. If more flexibility than &lt;a href=&quot;app-pgbasebackup&quot;&gt;pg_basebackup&lt;/a&gt; can provide is required, you can also make a base backup using the low level API (see &lt;a href=&quot;continuous-archiving#BACKUP-LOWLEVEL-BASE-BACKUP&quot;&gt;Section 25.3.3&lt;/a&gt;).</source>
          <target state="translated">ベースバックアップを実行する最も簡単な方法は、&lt;a href=&quot;app-pgbasebackup&quot;&gt;pg_basebackup&lt;/a&gt;ツールを使用することです。通常のファイルまたはtarアーカイブとしてベースバックアップを作成できます。&lt;a href=&quot;app-pgbasebackup&quot;&gt;pg_basebackup&lt;/a&gt;が提供できる以上の柔軟性が必要な場合は、低レベルAPIを使用してベースバックアップを作成することもできます（&lt;a href=&quot;continuous-archiving#BACKUP-LOWLEVEL-BASE-BACKUP&quot;&gt;セクション25.3.3を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="29f1de90d9c685081e50b22b770744253403d7c5" translate="yes" xml:space="preserve">
          <source>The effect of this mechanism is that in the default configuration, triggers do not fire on replicas. This is useful because if a trigger is used on the origin to propagate data between tables, then the replication system will also replicate the propagated data, and the trigger should not fire a second time on the replica, because that would lead to duplication. However, if a trigger is used for another purpose such as creating external alerts, then it might be appropriate to set it to &lt;code&gt;ENABLE ALWAYS&lt;/code&gt; so that it is also fired on replicas.</source>
          <target state="translated">このメカニズムの効果は、デフォルトの構成では、レプリカでトリガーが起動されないことです。トリガーがオリジンで使用されてテーブル間でデータを伝達する場合、複製システムは伝達されたデータもレプリケートし、複製でトリガーが2回発生しないようにする必要があるため、これは便利です。ただし、トリガーが外部アラートの作成などの別の目的で使用されている場合は、トリガーを &lt;code&gt;ENABLE ALWAYS&lt;/code&gt; に設定して、レプリカでも起動されるようにするのが適切な場合があります。</target>
        </trans-unit>
        <trans-unit id="11f70bcfbdc794c385378840673cf0a249c54a0a" translate="yes" xml:space="preserve">
          <source>The effective maximum for &lt;code&gt;vacuum_freeze_table_age&lt;/code&gt; is 0.95 * &lt;code&gt;autovacuum_freeze_max_age&lt;/code&gt;; a setting higher than that will be capped to the maximum. A value higher than &lt;code&gt;autovacuum_freeze_max_age&lt;/code&gt; wouldn't make sense because an anti-wraparound autovacuum would be triggered at that point anyway, and the 0.95 multiplier leaves some breathing room to run a manual &lt;code&gt;VACUUM&lt;/code&gt; before that happens. As a rule of thumb, &lt;code&gt;vacuum_freeze_table_age&lt;/code&gt; should be set to a value somewhat below &lt;code&gt;autovacuum_freeze_max_age&lt;/code&gt;, leaving enough gap so that a regularly scheduled &lt;code&gt;VACUUM&lt;/code&gt; or an autovacuum triggered by normal delete and update activity is run in that window. Setting it too close could lead to anti-wraparound autovacuums, even though the table was recently vacuumed to reclaim space, whereas lower values lead to more frequent aggressive vacuuming.</source>
          <target state="translated">&lt;code&gt;vacuum_freeze_table_age&lt;/code&gt; の実効最大値は0.95 * &lt;code&gt;autovacuum_freeze_max_age&lt;/code&gt; です。それより高い設定は最大に制限されます。 &lt;code&gt;autovacuum_freeze_max_age&lt;/code&gt; より高い値は、とにかく折り返し防止autovacuumがその時点でトリガーされ、0.95乗数が発生する前に手動の &lt;code&gt;VACUUM&lt;/code&gt; を実行するための余地を残すため、意味がありません。経験則として、 &lt;code&gt;vacuum_freeze_table_age&lt;/code&gt; は &lt;code&gt;autovacuum_freeze_max_age&lt;/code&gt; よりも少し低い値に設定し、定期的にスケジュールされた &lt;code&gt;VACUUM&lt;/code&gt; または、通常の削除および更新アクティビティによってトリガーされる自動バキュームがそのウィンドウで実行されます。設定が近すぎると、テーブルが最近バキュームされてスペースを再利用しているにもかかわらず、ラップアラウンドの自動バキュームが発生する可能性があります。値が小さいと、積極的なバキュームが頻繁に発生します。</target>
        </trans-unit>
        <trans-unit id="6acae8d5fe7431e883721a35bb83f27f6d33e399" translate="yes" xml:space="preserve">
          <source>The effective resolution of the sleep interval is platform-specific; 0.01 seconds is a common value. The sleep delay will be at least as long as specified. It might be longer depending on factors such as server load. In particular, &lt;code&gt;pg_sleep_until&lt;/code&gt; is not guaranteed to wake up exactly at the specified time, but it will not wake up any earlier.</source>
          <target state="translated">スリープ間隔の効果的な解決はプラットフォーム固有です。0.01秒が一般的な値です。スリープ遅延は、少なくとも指定された長さになります。サーバーの負荷などの要因によっては、それよりも長くなる場合があります。特に、 &lt;code&gt;pg_sleep_until&lt;/code&gt; は、指定された時間に正確に起動することが保証されていませんが、それ以前に起動することはありません。</target>
        </trans-unit>
        <trans-unit id="ca3e0b7947e98767e7bc3c70b05110c06d007fc6" translate="yes" xml:space="preserve">
          <source>The effects of &lt;code&gt;SET LOCAL&lt;/code&gt; last only till the end of the current transaction, whether committed or not. A special case is &lt;code&gt;SET&lt;/code&gt; followed by &lt;code&gt;SET LOCAL&lt;/code&gt; within a single transaction: the &lt;code&gt;SET LOCAL&lt;/code&gt; value will be seen until the end of the transaction, but afterwards (if the transaction is committed) the &lt;code&gt;SET&lt;/code&gt; value will take effect.</source>
          <target state="translated">&lt;code&gt;SET LOCAL&lt;/code&gt; の効果は、コミットされているかどうかに関係なく、現在のトランザクションが終了するまで有効です。特別なケースは、単一のトランザクション内で &lt;code&gt;SET&lt;/code&gt; の後に &lt;code&gt;SET LOCAL&lt;/code&gt; が続く場合です &lt;code&gt;SET LOCAL&lt;/code&gt; 値はトランザクションの終了まで表示されますが、その後（トランザクションがコミットされた場合） &lt;code&gt;SET&lt;/code&gt; 値が有効になります。</target>
        </trans-unit>
        <trans-unit id="1963e14d77518dfe80e47bfcd05e2429f11a8bde" translate="yes" xml:space="preserve">
          <source>The effects of &lt;code&gt;SET&lt;/code&gt; or &lt;code&gt;SET LOCAL&lt;/code&gt; are also canceled by rolling back to a savepoint that is earlier than the command.</source>
          <target state="translated">コマンドよりも前のセーブポイントにロールバックすることにより、 &lt;code&gt;SET&lt;/code&gt; または &lt;code&gt;SET LOCAL&lt;/code&gt; の効果もキャンセルされます。</target>
        </trans-unit>
        <trans-unit id="005a74c57d93879fd436d69f089f03e96ff53b14" translate="yes" xml:space="preserve">
          <source>The elements of the &lt;code&gt;PARTITION BY&lt;/code&gt; list are interpreted in much the same fashion as elements of a &lt;a href=&quot;sql-select#SQL-GROUPBY&quot;&gt;&lt;code&gt;GROUP BY&lt;/code&gt; Clause&lt;/a&gt;, except that they are always simple expressions and never the name or number of an output column. Another difference is that these expressions can contain aggregate function calls, which are not allowed in a regular &lt;code&gt;GROUP BY&lt;/code&gt; clause. They are allowed here because windowing occurs after grouping and aggregation.</source>
          <target state="translated">要素 &lt;code&gt;PARTITION BY&lt;/code&gt; リストはの要素とほとんど同じ方法で解釈され&lt;a href=&quot;sql-select#SQL-GROUPBY&quot;&gt; &lt;code&gt;GROUP BY&lt;/code&gt; 句&lt;/a&gt;、彼らは常に単純な式と決して名または出力列の数であることを除いて、。別の違いは、これらの式には、通常の &lt;code&gt;GROUP BY&lt;/code&gt; 句では許可されない集約関数呼び出しを含めることができるということです。グループ化と集計の後にウィンドウ処理が行われるため、ここでは許可されます。</target>
        </trans-unit>
        <trans-unit id="ee005edb8cd95f17a956edeff522c590d6992936" translate="yes" xml:space="preserve">
          <source>The elements of the &lt;code&gt;PARTITION BY&lt;/code&gt; list are interpreted in much the same fashion as elements of a &lt;a href=&quot;sql-select#SQL-GROUPBY&quot;&gt;&lt;code&gt;GROUP BY&lt;/code&gt;&lt;/a&gt; clause, except that they are always simple expressions and never the name or number of an output column. Another difference is that these expressions can contain aggregate function calls, which are not allowed in a regular &lt;code&gt;GROUP BY&lt;/code&gt; clause. They are allowed here because windowing occurs after grouping and aggregation.</source>
          <target state="translated">The elements of the &lt;code&gt;PARTITION BY&lt;/code&gt; list are interpreted in much the same fashion as elements of a &lt;a href=&quot;sql-select#SQL-GROUPBY&quot;&gt; &lt;code&gt;GROUP BY&lt;/code&gt; &lt;/a&gt; clause, except that they are always simple expressions and never the name or number of an output column. Another difference is that these expressions can contain aggregate function calls, which are not allowed in a regular &lt;code&gt;GROUP BY&lt;/code&gt; clause. They are allowed here because windowing occurs after grouping and aggregation.</target>
        </trans-unit>
        <trans-unit id="bd51d8414173fa812e307883cf9daca455add1a4" translate="yes" xml:space="preserve">
          <source>The empty scalar sub-SELECT will produce a null value that is considered to be of the domain type, so no further constraint checking is applied to it, and the insertion will succeed.</source>
          <target state="translated">空のスカラsub-SELECTは、ドメイン型であると考えられるNULL値を生成するので、それ以上の制約チェックは適用されず、挿入は成功します。</target>
        </trans-unit>
        <trans-unit id="750129d09bd31bb5985c26e665018fb53719c8d3" translate="yes" xml:space="preserve">
          <source>The encoding and locale settings must match those of the template database, except when &lt;code&gt;template0&lt;/code&gt; is used as template. This is because other databases might contain data that does not match the specified encoding, or might contain indexes whose sort ordering is affected by &lt;code&gt;LC_COLLATE&lt;/code&gt; and &lt;code&gt;LC_CTYPE&lt;/code&gt;. Copying such data would result in a database that is corrupt according to the new settings. &lt;code&gt;template0&lt;/code&gt;, however, is known to not contain any data or indexes that would be affected.</source>
          <target state="translated">エンコーディングおよびロケール設定が場合を除いて、テンプレートデータベースのものと一致している必要があり &lt;code&gt;template0&lt;/code&gt; テンプレートとして使用されます。これは、他のデータベースに、指定されたエンコーディングと一致しないデータが含まれているか、ソート順が &lt;code&gt;LC_COLLATE&lt;/code&gt; および &lt;code&gt;LC_CTYPE&lt;/code&gt; の影響を受けるインデックスが含まれている可能性があるためです。このようなデータをコピーすると、新しい設定に従ってデータベースが破損します。ただし、 &lt;code&gt;template0&lt;/code&gt; には、影響を受けるデータやインデックスが含まれていないことがわかっています。</target>
        </trans-unit>
        <trans-unit id="06ebfe8f29152790c8c19069e09027b276e20d6f" translate="yes" xml:space="preserve">
          <source>The encoding for a database is stored in the system catalog &lt;code&gt;pg_database&lt;/code&gt;. You can see it by using the &lt;code&gt;psql&lt;/code&gt;&lt;code&gt;-l&lt;/code&gt; option or the &lt;code&gt;\l&lt;/code&gt; command.</source>
          <target state="translated">データベースのエンコーディングは、システムカタログ &lt;code&gt;pg_database&lt;/code&gt; に格納されています。これは、 &lt;code&gt;psql&lt;/code&gt; &lt;code&gt;-l&lt;/code&gt; オプションまたは &lt;code&gt;\l&lt;/code&gt; コマンドを使用して確認できます。</target>
        </trans-unit>
        <trans-unit id="7b548a79db3b694cdb5c78e7ae46892fe80152d6" translate="yes" xml:space="preserve">
          <source>The encryption vector used will only be cryptographically strong if PostgreSQL is built with support for OpenSSL. In other cases, the transmission to the RADIUS server should only be considered obfuscated, not secured, and external security measures should be applied if necessary.</source>
          <target state="translated">使用する暗号化ベクトルは、PostgreSQLがOpenSSLをサポートして構築されている場合に限り、暗号化に強いものとなります。それ以外の場合は、RADIUSサーバへの送信は難読化されているとしか考えられず、安全性は確保されておらず、必要に応じて外部のセキュリティ対策を施す必要があります。</target>
        </trans-unit>
        <trans-unit id="807f48853a85df34d9a80e7027652fd76ea8d1d2" translate="yes" xml:space="preserve">
          <source>The entries in the select list can be assigned names for subsequent processing, such as for use in an &lt;code&gt;ORDER BY&lt;/code&gt; clause or for display by the client application. For example:</source>
          <target state="translated">選択リストのエントリには、 &lt;code&gt;ORDER BY&lt;/code&gt; 句で使用したり、クライアントアプリケーションで表示したりするために、後続の処理のために名前を割り当てることができます。例えば：</target>
        </trans-unit>
        <trans-unit id="5ed44cca4375f0386d06f29a5cb471a7a637f589" translate="yes" xml:space="preserve">
          <source>The enumerator is a function &lt;code&gt;int_array_enum(integer[])&lt;/code&gt; that returns &lt;code&gt;setof integer&lt;/code&gt;. It is essentially the reverse operation of the aggregator: given an array of integers, expand it into a set of rows. This is a wrapper around &lt;code&gt;unnest&lt;/code&gt;, which does the same thing for any array type.</source>
          <target state="translated">列挙子は、 &lt;code&gt;setof integer&lt;/code&gt; を返す関数 &lt;code&gt;int_array_enum(integer[])&lt;/code&gt; です。これは、基本的にはアグリゲーターの逆の操作です。整数の配列を指定すると、それを一連の行に展開します。これは &lt;code&gt;unnest&lt;/code&gt; のラッパーであり、どの配列型でも同じことを行います。</target>
        </trans-unit>
        <trans-unit id="adf2db7b61ef30b8a94189e9e7cbc4a2342e7f7a" translate="yes" xml:space="preserve">
          <source>The environment variable &lt;code&gt;PG_COLOR&lt;/code&gt; specifies whether to use color in diagnostic messages. Possible values are &lt;code&gt;always&lt;/code&gt;, &lt;code&gt;auto&lt;/code&gt; and &lt;code&gt;never&lt;/code&gt;.</source>
          <target state="translated">The environment variable &lt;code&gt;PG_COLOR&lt;/code&gt; specifies whether to use color in diagnostic messages. Possible values are &lt;code&gt;always&lt;/code&gt; , &lt;code&gt;auto&lt;/code&gt; and &lt;code&gt;never&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d14b9d4e54d6bcfb1eb32844ae2033e082cd8255" translate="yes" xml:space="preserve">
          <source>The environment variable &lt;code&gt;PG_COLOR&lt;/code&gt; specifies whether to use color in diagnostics messages. Possible values are &lt;code&gt;always&lt;/code&gt;, &lt;code&gt;auto&lt;/code&gt;, &lt;code&gt;never&lt;/code&gt;.</source>
          <target state="translated">環境変数 &lt;code&gt;PG_COLOR&lt;/code&gt; は、診断メッセージで色を使用するかどうかを指定します。可能な値は &lt;code&gt;always&lt;/code&gt; 、 &lt;code&gt;auto&lt;/code&gt; 、 &lt;code&gt;never&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="0960a83450dbd1eaf41a4a82cb1e20f4eb07da46" translate="yes" xml:space="preserve">
          <source>The error code (see &lt;a href=&quot;errcodes-appendix&quot;&gt;Appendix A&lt;/a&gt;) associated with the last SQL query's failure, or &lt;code&gt;00000&lt;/code&gt; if it succeeded.</source>
          <target state="translated">最後のSQLクエリの失敗に関連するエラーコード（&lt;a href=&quot;errcodes-appendix&quot;&gt;付録Aを&lt;/a&gt;参照）、または成功した場合は &lt;code&gt;00000&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="18033404335da13276f24e2efbba0cea44bc2fa8" translate="yes" xml:space="preserve">
          <source>The error message contains a useful hint: if you do not want to bother deleting all the dependent objects individually, you can run:</source>
          <target state="translated">エラーメッセージには有用なヒントが含まれています。</target>
        </trans-unit>
        <trans-unit id="57829bc22f9a034fee876abab6cb834a1c2e8f4d" translate="yes" xml:space="preserve">
          <source>The escape character can be any single character other than a hexadecimal digit, the plus sign, a single quote, a double quote, or a whitespace character.</source>
          <target state="translated">エスケープ文字は、16進数、プラス記号、シングルクォーテーション、ダブルクォーテーション、または空白文字以外の任意の単一の文字を指定できます。</target>
        </trans-unit>
        <trans-unit id="67bd70b6b09776588b82cea1e08b3ca407b7095e" translate="yes" xml:space="preserve">
          <source>The escape character can be any single character other than a hexadecimal digit, the plus sign, a single quote, a double quote, or a whitespace character. Note that the escape character is written in single quotes, not double quotes, after &lt;code&gt;UESCAPE&lt;/code&gt;.</source>
          <target state="translated">The escape character can be any single character other than a hexadecimal digit, the plus sign, a single quote, a double quote, or a whitespace character. Note that the escape character is written in single quotes, not double quotes, after &lt;code&gt;UESCAPE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="558d22a4e0d0e48723c35f2a0cfc8e75bf258ba8" translate="yes" xml:space="preserve">
          <source>The escape character can be any single character other than a hexadecimal digit, the plus sign, a single quote, a double quote, or a whitespace character. Note that the escape character is written in single quotes, not double quotes.</source>
          <target state="translated">エスケープ文字は、16進数、プラス記号、単一引用符、二重引用符、空白文字以外の任意の単一文字にすることができます。エスケープ文字は、二重引用符ではなく単一引用符で書かれていることに注意してください。</target>
        </trans-unit>
        <trans-unit id="c319bbe8d3e052f0e1ded51a38eee81a844539cf" translate="yes" xml:space="preserve">
          <source>The escape-double-quote separators actually divide &lt;code&gt;substring&lt;/code&gt;'s pattern into three independent regular expressions; for example, a vertical bar (&lt;code&gt;|&lt;/code&gt;) in any of the three sections affects only that section. Also, the first and third of these regular expressions are defined to match the smallest possible amount of text, not the largest, when there is any ambiguity about how much of the data string matches which pattern. (In POSIX parlance, the first and third regular expressions are forced to be non-greedy.)</source>
          <target state="translated">エスケープと二重引用符の区切り文字は、実際には &lt;code&gt;substring&lt;/code&gt; のパターンを3つの独立した正規表現に分割します。たとえば、3つのセクションのいずれかにある縦棒（ &lt;code&gt;|&lt;/code&gt; ）は、そのセクションにのみ影響します。また、これらの正規表現の1番目と3番目は、データ文字列のどのパターンがどのパターンに一致するかについて曖昧な場合に、最大ではなく最小のテキスト量に一致するように定義されています。（POSIXの用語では、最初と3番目の正規表現は貪欲ではありません。）</target>
        </trans-unit>
        <trans-unit id="3b9ec713fc7d733ff3cae68659b4d4e80a25bebd" translate="yes" xml:space="preserve">
          <source>The essential difference between &lt;code&gt;inet&lt;/code&gt; and &lt;code&gt;cidr&lt;/code&gt; data types is that &lt;code&gt;inet&lt;/code&gt; accepts values with nonzero bits to the right of the netmask, whereas &lt;code&gt;cidr&lt;/code&gt; does not. For example, &lt;code&gt;192.168.0.1/24&lt;/code&gt; is valid for &lt;code&gt;inet&lt;/code&gt; but not for &lt;code&gt;cidr&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;inet&lt;/code&gt; と &lt;code&gt;cidr&lt;/code&gt; のデータ型の本質的な違いは、 &lt;code&gt;inet&lt;/code&gt; はネットマスクの右側にゼロ以外のビットを持つ値を受け入れるのに対し、 &lt;code&gt;cidr&lt;/code&gt; は受け入れないということです。たとえば、 &lt;code&gt;192.168.0.1/24&lt;/code&gt; &lt;code&gt;cidr&lt;/code&gt; は &lt;code&gt;inet&lt;/code&gt; では有効ですが、cidrでは無効です。</target>
        </trans-unit>
        <trans-unit id="df18f95e8b31c041dbe1102915fb4ff49c1585b3" translate="yes" xml:space="preserve">
          <source>The essential semantics of an &lt;code&gt;in_range&lt;/code&gt; function depend on the two Boolean flag parameters. It should add or subtract &lt;code&gt;base&lt;/code&gt; and &lt;code&gt;offset&lt;/code&gt;, then compare &lt;code&gt;val&lt;/code&gt; to the result, as follows:</source>
          <target state="translated">&lt;code&gt;in_range&lt;/code&gt; 関数の基本的なセマンティクスは、2つのブールフラグパラメーターに依存します。次のように、 &lt;code&gt;base&lt;/code&gt; と &lt;code&gt;offset&lt;/code&gt; を加算または減算してから、 &lt;code&gt;val&lt;/code&gt; と結果を比較します。</target>
        </trans-unit>
        <trans-unit id="e84d23798c1117bda45a63153c240c91e5736421" translate="yes" xml:space="preserve">
          <source>The estimate is as accurate as with the functional dependencies, mostly thanks to the table being fairly small and having a simple distribution with a low number of distinct values. Before looking at the second query, which was not handled by functional dependencies particularly well, let's inspect the MCV list a bit.</source>
          <target state="translated">推定値は、機能依存性の場合と同様に正確ですが、テーブルがかなり小さく、明瞭な値の数が少ない単純な分布を持っていることが主な要因です。2番目のクエリを見る前に、機能依存性によって特にうまく処理されなかった、MCVリストを少し調べてみましょう。</target>
        </trans-unit>
        <trans-unit id="e69083f44a757893f1ada1ae6b8cb9bd97b58e99" translate="yes" xml:space="preserve">
          <source>The estimated cost charged when vacuum modifies a block that was previously clean. It represents the extra I/O required to flush the dirty block out to disk again. The default value is 20.</source>
          <target state="translated">以前はクリーンだったブロックをバキュームで変更した場合に請求される概算コスト。これは、汚れたブロックを再びディスクに流すために必要な余分なI/Oを表します。デフォルト値は20です。</target>
        </trans-unit>
        <trans-unit id="ee2db52b19d2bfa03dc1ab623c01a2a1907e2459" translate="yes" xml:space="preserve">
          <source>The estimated cost for vacuuming a buffer found in the shared buffer cache. It represents the cost to lock the buffer pool, lookup the shared hash table and scan the content of the page. The default value is one.</source>
          <target state="translated">共有バッファキャッシュで見つかったバッファをバキュームするための推定コストです。バッファプールをロックし、共有ハッシュテーブルを検索し、ページの内容をスキャンするためのコストを表します。デフォルト値は 1 です。</target>
        </trans-unit>
        <trans-unit id="83ce27e1c08fee6790695cac6b8c3ef5bff725b5" translate="yes" xml:space="preserve">
          <source>The estimated cost for vacuuming a buffer that has to be read from disk. This represents the effort to lock the buffer pool, lookup the shared hash table, read the desired block in from the disk and scan its content. The default value is 10.</source>
          <target state="translated">ディスクから読み込まなければならないバッファをバキュームするための推定コスト。これは、バッファプールをロックし、共有ハッシュテーブルを検索し、ディスクから目的のブロックを読み込み、その内容をスキャンするための労力を表します。デフォルト値は10です。</target>
        </trans-unit>
        <trans-unit id="a717571e9b46bfa71ced49ce7ab5ad2053e90b7b" translate="yes" xml:space="preserve">
          <source>The event is one of &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, or &lt;code&gt;DELETE&lt;/code&gt;. Note that an &lt;code&gt;INSERT&lt;/code&gt; containing an &lt;code&gt;ON CONFLICT&lt;/code&gt; clause cannot be used on tables that have either &lt;code&gt;INSERT&lt;/code&gt; or &lt;code&gt;UPDATE&lt;/code&gt; rules. Consider using an updatable view instead.</source>
          <target state="translated">イベントは、 &lt;code&gt;SELECT&lt;/code&gt; 、 &lt;code&gt;INSERT&lt;/code&gt; 、 &lt;code&gt;UPDATE&lt;/code&gt; 、または &lt;code&gt;DELETE&lt;/code&gt; のいずれかです。そのノート &lt;code&gt;INSERT&lt;/code&gt; 含有 &lt;code&gt;ON CONFLICT&lt;/code&gt; 句は、いずれかの有するテーブルで使用することができない &lt;code&gt;INSERT&lt;/code&gt; または &lt;code&gt;UPDATE&lt;/code&gt; ルール。代わりに更新可能なビューの使用を検討してください。</target>
        </trans-unit>
        <trans-unit id="227dafe90d62bc0d6660bf9b763aa381e9cc9dfe" translate="yes" xml:space="preserve">
          <source>The exact values that are acceptable for the &lt;code&gt;locale&lt;/code&gt; clause in this command depend on the operating system. On Unix-like systems, the command &lt;code&gt;locale -a&lt;/code&gt; will show a list.</source>
          <target state="translated">このコマンドの &lt;code&gt;locale&lt;/code&gt; 句で許容される正確な値は、オペレーティングシステムによって異なります。Unixライクなシステムでは、コマンド &lt;code&gt;locale -a&lt;/code&gt; を実行するとリストが表示されます。</target>
        </trans-unit>
        <trans-unit id="1583bbd20b51e7ac63ce0bb194332cc2a7d7d470" translate="yes" xml:space="preserve">
          <source>The example above can be written using the simple &lt;code&gt;CASE&lt;/code&gt; syntax:</source>
          <target state="translated">上記の例は、単純な &lt;code&gt;CASE&lt;/code&gt; 構文を使用して記述できます。</target>
        </trans-unit>
        <trans-unit id="af8e2a351cf21a24426f9811e0f9ff471eeba69b" translate="yes" xml:space="preserve">
          <source>The example below shows a DTrace script for analyzing transaction counts in the system, as an alternative to snapshotting &lt;code&gt;pg_stat_database&lt;/code&gt; before and after a performance test:</source>
          <target state="translated">以下の例は、パフォーマンステストの前後に &lt;code&gt;pg_stat_database&lt;/code&gt; をスナップショットする代わりに、システムのトランザクション数を分析するためのDTraceスクリプトを示しています。</target>
        </trans-unit>
        <trans-unit id="f0d6977a3eaffb08d482eddd947f053b0bf9bd5c" translate="yes" xml:space="preserve">
          <source>The examples above only show &lt;code&gt;WITH&lt;/code&gt; being used with &lt;code&gt;SELECT&lt;/code&gt;, but it can be attached in the same way to &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, or &lt;code&gt;DELETE&lt;/code&gt;. In each case it effectively provides temporary table(s) that can be referred to in the main command.</source>
          <target state="translated">上記の例は、 &lt;code&gt;SELECT&lt;/code&gt; で使用される &lt;code&gt;WITH&lt;/code&gt; のみを示していますが、 &lt;code&gt;INSERT&lt;/code&gt; 、 &lt;code&gt;UPDATE&lt;/code&gt; 、または &lt;code&gt;DELETE&lt;/code&gt; と同じ方法でアタッチできます。いずれの場合も、メインコマンドで参照できる一時テーブルを効果的に提供します。</target>
        </trans-unit>
        <trans-unit id="380cc7f137a8c15a1ad87e0fd8242117724c9f5a" translate="yes" xml:space="preserve">
          <source>The examples in the previous section illustrated full text matching using simple constant strings. This section shows how to search table data, optionally using indexes.</source>
          <target state="translated">前のセクションの例では、単純な定数文字列を使用した全文一致を説明しました。このセクションでは、テーブルデータを検索する方法を示します。</target>
        </trans-unit>
        <trans-unit id="b9b0afad9f26eddf93a4253af463b944d4205ce4" translate="yes" xml:space="preserve">
          <source>The examples shown below use tables in the PostgreSQL regression test database. The outputs shown are taken from version 8.3. The behavior of earlier (or later) versions might vary. Note also that since &lt;code&gt;ANALYZE&lt;/code&gt; uses random sampling while producing statistics, the results will change slightly after any new &lt;code&gt;ANALYZE&lt;/code&gt;.</source>
          <target state="translated">以下の例では、PostgreSQL回帰テストデータベースのテーブルを使用しています。表示される出力は、バージョン8.3から取得されます。以前（またはそれ以降）のバージョンの動作は異なる場合があります。 &lt;code&gt;ANALYZE&lt;/code&gt; は統計の生成中にランダムサンプリングを使用するため、新しい &lt;code&gt;ANALYZE&lt;/code&gt; を実行すると結果がわずかに変化することにも注意してください。</target>
        </trans-unit>
        <trans-unit id="c2367138a166c600af3d676a2ed6d45de33c069c" translate="yes" xml:space="preserve">
          <source>The examples use &lt;code&gt;EXPLAIN&lt;/code&gt;'s default &amp;ldquo;text&amp;rdquo; output format, which is compact and convenient for humans to read. If you want to feed &lt;code&gt;EXPLAIN&lt;/code&gt;'s output to a program for further analysis, you should use one of its machine-readable output formats (XML, JSON, or YAML) instead.</source>
          <target state="translated">例では、 &lt;code&gt;EXPLAIN&lt;/code&gt; のデフォルトの「テキスト」出力形式を使用しています。これはコンパクトで、人間が読むのに便利です。さらに分析するために &lt;code&gt;EXPLAIN&lt;/code&gt; の出力をプログラムにフィードする場合は、代わりにその機械可読出力形式（XML、JSON、またはYAML）のいずれかを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="d75f123f158a40ce2bca3268003c1deb66947f66" translate="yes" xml:space="preserve">
          <source>The exclusive backup method is deprecated and should be avoided. Prior to PostgreSQL 9.6, this was the only low-level method available, but it is now recommended that all users upgrade their scripts to use non-exclusive backups.</source>
          <target state="translated">排他的バックアップ方法は非推奨であり、避けるべきです。PostgreSQL 9.6以前では、これは唯一の低レベルの方法でしたが、現在では、すべてのユーザが非排他的バックアップを使用するようにスクリプトをアップグレードすることが推奨されています。</target>
        </trans-unit>
        <trans-unit id="bb6f1793100519508110d4857d8c27514367d631" translate="yes" xml:space="preserve">
          <source>The executor mechanism is used to evaluate all four basic SQL query types: &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, and &lt;code&gt;DELETE&lt;/code&gt;. For &lt;code&gt;SELECT&lt;/code&gt;, the top-level executor code only needs to send each row returned by the query plan tree off to the client. For &lt;code&gt;INSERT&lt;/code&gt;, each returned row is inserted into the target table specified for the &lt;code&gt;INSERT&lt;/code&gt;. This is done in a special top-level plan node called &lt;code&gt;ModifyTable&lt;/code&gt;. (A simple &lt;code&gt;INSERT ... VALUES&lt;/code&gt; command creates a trivial plan tree consisting of a single &lt;code&gt;Result&lt;/code&gt; node, which computes just one result row, and &lt;code&gt;ModifyTable&lt;/code&gt; above it to perform the insertion. But &lt;code&gt;INSERT ... SELECT&lt;/code&gt; can demand the full power of the executor mechanism.) For &lt;code&gt;UPDATE&lt;/code&gt;, the planner arranges that each computed row includes all the updated column values, plus the &lt;em&gt;TID&lt;/em&gt; (tuple ID, or row ID) of the original target row; this data is fed into a &lt;code&gt;ModifyTable&lt;/code&gt; node, which uses the information to create a new updated row and mark the old row deleted. For &lt;code&gt;DELETE&lt;/code&gt;, the only column that is actually returned by the plan is the TID, and the &lt;code&gt;ModifyTable&lt;/code&gt; node simply uses the TID to visit each target row and mark it deleted.</source>
          <target state="translated">エグゼキューターメカニズムは、 &lt;code&gt;SELECT&lt;/code&gt; 、 &lt;code&gt;INSERT&lt;/code&gt; 、 &lt;code&gt;UPDATE&lt;/code&gt; 、 &lt;code&gt;DELETE&lt;/code&gt; の 4つの基本的なSQLクエリタイプすべてを評価するために使用されます。以下のために &lt;code&gt;SELECT&lt;/code&gt; 、トップレベルのエグゼキュータのコードは、クライアントにオフクエリプランツリーによって返される各行を送信する必要があります。ため &lt;code&gt;INSERT&lt;/code&gt; 、各返される行はのために指定されたターゲット表に挿入される &lt;code&gt;INSERT&lt;/code&gt; 。これは、 &lt;code&gt;ModifyTable&lt;/code&gt; と呼ばれる特別なトップレベルの計画ノードで行われます。 （単純な &lt;code&gt;INSERT ... VALUES&lt;/code&gt; コマンドは、1つの結果行のみを計算する単一の &lt;code&gt;Result&lt;/code&gt; ノードと &lt;code&gt;ModifyTable&lt;/code&gt; で構成される簡単な計画ツリーを作成しますその上で挿入を実行します。ただし、 &lt;code&gt;INSERT ... SELECT&lt;/code&gt; は、エグゼキュータメカニズムの全機能を要求する可能性があります &lt;code&gt;UPDATE&lt;/code&gt; 場合、プランナは、計算された各行に、更新されたすべての列の値と元のターゲット行の&lt;em&gt;TID&lt;/em&gt;（タプルID、または行ID）が含まれるように調整します。 ;このデータは、 &lt;code&gt;ModifyTable&lt;/code&gt; ノードにフィードされます。ModifyTableノードは、この情報を使用して、新しい更新された行を作成し、古い行を削除済みとしてマークします。ため &lt;code&gt;DELETE&lt;/code&gt; 、実際に計画によって返される唯一の列がTIDであり、そして &lt;code&gt;ModifyTable&lt;/code&gt; ノードは、単に、各対象行を訪問し、それを削除マークするTIDを使用します。</target>
        </trans-unit>
        <trans-unit id="4ce520996e20d2c06a7766155c3058caa75b4272" translate="yes" xml:space="preserve">
          <source>The executor recursively steps through the &lt;em&gt;plan tree&lt;/em&gt; and retrieves rows in the way represented by the plan. The executor makes use of the &lt;em&gt;storage system&lt;/em&gt; while scanning relations, performs &lt;em&gt;sorts&lt;/em&gt; and &lt;em&gt;joins&lt;/em&gt;, evaluates &lt;em&gt;qualifications&lt;/em&gt; and finally hands back the rows derived.</source>
          <target state="translated">executorは、&lt;em&gt;計画ツリー&lt;/em&gt;を再帰的にステップ実行し、&lt;em&gt;計画&lt;/em&gt;によって表される方法で行を取得します。executorは、関係のスキャン中に&lt;em&gt;ストレージシステム&lt;/em&gt;を利用し、並べ&lt;em&gt;替え&lt;/em&gt;と&lt;em&gt;結合を&lt;/em&gt;実行し、&lt;em&gt;資格&lt;/em&gt;を評価し、最後に派生行を返します。</target>
        </trans-unit>
        <trans-unit id="cf8658aa7a1382f233186544e10108cceaf18988" translate="yes" xml:space="preserve">
          <source>The existence of functional dependencies directly affects the accuracy of estimates in certain queries. If a query contains conditions on both the independent and the dependent column(s), the conditions on the dependent columns do not further reduce the result size; but without knowledge of the functional dependency, the query planner will assume that the conditions are independent, resulting in underestimating the result size.</source>
          <target state="translated">機能依存性の存在は、特定のクエリにおける推定精度に直接影響します。クエリが独立カラムと従属カラムの両方の条件を含んでいる場合、従属カラムの条件が結果サイズをさらに小さくすることはありませんが、機能依存性を知らないと、クエリプランナは条件が独立していると仮定してしまい、結果サイズを過小評価してしまいます。</target>
        </trans-unit>
        <trans-unit id="278c43dc066d35135921d352f59558e56072aaf4" translate="yes" xml:space="preserve">
          <source>The existing enum value that should be renamed. Like all enum literals, it needs to be quoted.</source>
          <target state="translated">名前を変更する既存の列挙型の値。すべてのenumリテラルと同様に、引用符で囲む必要があります。</target>
        </trans-unit>
        <trans-unit id="ec72bab01087d3968b75adfc77dfce97e7c1c187" translate="yes" xml:space="preserve">
          <source>The existing enum value that the new value should be added immediately before or after in the enum type's sort ordering. Like all enum literals, it needs to be quoted.</source>
          <target state="translated">既存の列挙型のソート順の直前または直後に新しい値を追加すべき列挙型の値。すべてのenumリテラルと同様に、引用符で囲まれている必要があります。</target>
        </trans-unit>
        <trans-unit id="288730aef18ef4aa044e0dc2a74d3a67ae251dbc" translate="yes" xml:space="preserve">
          <source>The expected parameter types for the prepared statement in the form of an array of &lt;code&gt;regtype&lt;/code&gt;. The OID corresponding to an element of this array can be obtained by casting the &lt;code&gt;regtype&lt;/code&gt; value to &lt;code&gt;oid&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;regtype&lt;/code&gt; の配列の形式で準備されたステートメントに期待されるパラメータータイプ。この配列の要素に対応するOIDは、 &lt;code&gt;regtype&lt;/code&gt; 値を &lt;code&gt;oid&lt;/code&gt; にキャストすることで取得できます。</target>
        </trans-unit>
        <trans-unit id="2f35445a6307ee1d7e051209ff3712898a533184" translate="yes" xml:space="preserve">
          <source>The expected size of this file, as an integer.</source>
          <target state="translated">このファイルの予想サイズを整数で指定します。</target>
        </trans-unit>
        <trans-unit id="6d73c415087d49efbf447ec5f41bf9143b5e43b5" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;IS DOCUMENT&lt;/code&gt; returns true if the argument XML value is a proper XML document, false if it is not (that is, it is a content fragment), or null if the argument is null. See &lt;a href=&quot;datatype-xml&quot;&gt;Section 8.13&lt;/a&gt; about the difference between documents and content fragments.</source>
          <target state="translated">式 &lt;code&gt;IS DOCUMENT&lt;/code&gt; は、引数XML値が適切なXMLドキュメントである場合はtrueを返し、そうでない場合（つまり、コンテンツフラグメントである場合）を返します。引数がnullの場合はnullを返します。ドキュメントとコンテンツフラグメントの違いについては、&lt;a href=&quot;datatype-xml&quot;&gt;セクション8.13を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="d3f0f5215911482c31ec80c4c63789e99b22d5c9" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;IS NOT DOCUMENT&lt;/code&gt; returns false if the argument XML value is a proper XML document, true if it is not (that is, it is a content fragment), or null if the argument is null.</source>
          <target state="translated">式 &lt;code&gt;IS NOT DOCUMENT&lt;/code&gt; は、引数XML値が適切なXMLドキュメントである場合はfalseを返し、そうでない場合（つまり、コンテンツフラグメントである場合）はtrueを返し、引数がnullの場合はnullを返します。</target>
        </trans-unit>
        <trans-unit id="2fefc72765ee0edb8389edc8b54df23ebd5b6c13" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;collation for&lt;/code&gt; returns the collation of the value that is passed to it. Example:</source>
          <target state="translated">式 &lt;code&gt;collation for&lt;/code&gt; は、渡された値の照合を返します。例：</target>
        </trans-unit>
        <trans-unit id="9cec711d90ae7214afb1e767819f2c01ba82f2bc" translate="yes" xml:space="preserve">
          <source>The expression added to the WITH CHECK qualifications for queries that attempt to add rows to this table</source>
          <target state="translated">このテーブルに行を追加しようとするクエリのWITH CHECK資格に追加された式</target>
        </trans-unit>
        <trans-unit id="fa02a0029d6349d8e6423a393d9fb0288905f902" translate="yes" xml:space="preserve">
          <source>The expression added to the security barrier qualifications for queries that this policy applies to</source>
          <target state="translated">このポリシーが適用されるクエリのセキュリティバリア資格に追加された表現</target>
        </trans-unit>
        <trans-unit id="239121cdfc5b45b387f1658717f60a67584813d6" translate="yes" xml:space="preserve">
          <source>The expression tree to be added to the WITH CHECK qualifications for queries that attempt to add rows to the table</source>
          <target state="translated">テーブルに行を追加しようとするクエリのWITH CHECK資格に追加される式ツリー</target>
        </trans-unit>
        <trans-unit id="710b7212dd7cdac519a9932cd2101a57cc49631a" translate="yes" xml:space="preserve">
          <source>The expression tree to be added to the security barrier qualifications for queries that use the table</source>
          <target state="translated">テーブルを使用するクエリのセキュリティバリア資格に追加される式ツリー</target>
        </trans-unit>
        <trans-unit id="d2c435961e2d1a2d5fc091620a3b53aedf1bc369" translate="yes" xml:space="preserve">
          <source>The expression used in the &lt;code&gt;WHERE&lt;/code&gt; clause can refer only to columns of the underlying table, but it can use all columns, not just the ones being indexed. Presently, subqueries and aggregate expressions are also forbidden in &lt;code&gt;WHERE&lt;/code&gt;. The same restrictions apply to index fields that are expressions.</source>
          <target state="translated">&lt;code&gt;WHERE&lt;/code&gt; 句で使用される式は、基になるテーブルの列のみを参照できますが、インデックス付けされている列だけでなく、すべての列を使用できます。現在、サブクエリと集計式は &lt;code&gt;WHERE&lt;/code&gt; でも禁止されています。式であるインデックスフィールドにも同じ制限が適用されます。</target>
        </trans-unit>
        <trans-unit id="e44d27b215403bd620571252d0254bbcc4cec3b6" translate="yes" xml:space="preserve">
          <source>The expressions described in this section check properties of &lt;code&gt;xml&lt;/code&gt; values.</source>
          <target state="translated">このセクションで説明する式は、 &lt;code&gt;xml&lt;/code&gt; 値のプロパティをチェックします。</target>
        </trans-unit>
        <trans-unit id="56934ce6588045922ec59583c810f1cb0acd84a1" translate="yes" xml:space="preserve">
          <source>The extensions currently available for loading can be identified from the &lt;a href=&quot;view-pg-available-extensions&quot;&gt;&lt;code&gt;pg_available_extensions&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;view-pg-available-extension-versions&quot;&gt;&lt;code&gt;pg_available_extension_versions&lt;/code&gt;&lt;/a&gt; system views.</source>
          <target state="translated">現在ロード可能な拡張機能は、&lt;a href=&quot;view-pg-available-extensions&quot;&gt; &lt;code&gt;pg_available_extensions&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;view-pg-available-extension-versions&quot;&gt; &lt;code&gt;pg_available_extension_versions&lt;/code&gt; &lt;/a&gt;システムビューから識別できます。</target>
        </trans-unit>
        <trans-unit id="8afec2ee5b2d1b2e4a42a77922b5f5aca2fe0a53" translate="yes" xml:space="preserve">
          <source>The extensions for PL/Perl are called &lt;code&gt;jsonb_plperl&lt;/code&gt; and &lt;code&gt;jsonb_plperlu&lt;/code&gt;. If you use them, &lt;code&gt;jsonb&lt;/code&gt; values are mapped to Perl arrays, hashes, and scalars, as appropriate.</source>
          <target state="translated">PL / Perlの拡張機能は &lt;code&gt;jsonb_plperl&lt;/code&gt; および &lt;code&gt;jsonb_plperlu&lt;/code&gt; と呼ばれます。それらを使用する場合、 &lt;code&gt;jsonb&lt;/code&gt; 値は、必要に応じてPerl配列、ハッシュ、およびスカラーにマップされます。</target>
        </trans-unit>
        <trans-unit id="19e8b6e34d048aaf0ad16665bbe37cdf1acb53f4" translate="yes" xml:space="preserve">
          <source>The extensions for PL/Python are called &lt;code&gt;jsonb_plpythonu&lt;/code&gt;, &lt;code&gt;jsonb_plpython2u&lt;/code&gt;, and &lt;code&gt;jsonb_plpython3u&lt;/code&gt; (see &lt;a href=&quot;https://www.postgresql.org/docs/12/plpython-python23.html&quot;&gt;Section 45.1&lt;/a&gt; for the PL/Python naming convention). If you use them, &lt;code&gt;jsonb&lt;/code&gt; values are mapped to Python dictionaries, lists, and scalars, as appropriate.</source>
          <target state="translated">PL / Pythonの拡張機能は、 &lt;code&gt;jsonb_plpythonu&lt;/code&gt; 、 &lt;code&gt;jsonb_plpython2u&lt;/code&gt; 、および &lt;code&gt;jsonb_plpython3u&lt;/code&gt; と呼ばれます（PL / Pythonの命名規則については、&lt;a href=&quot;https://www.postgresql.org/docs/12/plpython-python23.html&quot;&gt;セクション45.1&lt;/a&gt;を参照してください）。それらを使用する場合、 &lt;code&gt;jsonb&lt;/code&gt; 値は、必要に応じてPython辞書、リスト、スカラーにマップされます。</target>
        </trans-unit>
        <trans-unit id="b34c58961fecd5bbfea5deffa1c8dc758272c022" translate="yes" xml:space="preserve">
          <source>The extensions for PL/Python are called &lt;code&gt;jsonb_plpythonu&lt;/code&gt;, &lt;code&gt;jsonb_plpython2u&lt;/code&gt;, and &lt;code&gt;jsonb_plpython3u&lt;/code&gt; (see &lt;a href=&quot;https://www.postgresql.org/docs/13/plpython-python23.html&quot;&gt;Section 45.1&lt;/a&gt; for the PL/Python naming convention). If you use them, &lt;code&gt;jsonb&lt;/code&gt; values are mapped to Python dictionaries, lists, and scalars, as appropriate.</source>
          <target state="translated">The extensions for PL/Python are called &lt;code&gt;jsonb_plpythonu&lt;/code&gt; , &lt;code&gt;jsonb_plpython2u&lt;/code&gt; , and &lt;code&gt;jsonb_plpython3u&lt;/code&gt; (see &lt;a href=&quot;https://www.postgresql.org/docs/13/plpython-python23.html&quot;&gt;Section 45.1&lt;/a&gt; for the PL/Python naming convention). If you use them, &lt;code&gt;jsonb&lt;/code&gt; values are mapped to Python dictionaries, lists, and scalars, as appropriate.</target>
        </trans-unit>
        <trans-unit id="05f3501f99bc04897b07450c60fab261a8909a70" translate="yes" xml:space="preserve">
          <source>The extensions supplied with PostgreSQL are believed to be secure against installation-time attacks of this sort, except for a few that depend on other extensions. As stated in the documentation for those extensions, they should be installed into secure schemas, or installed into the same schemas as the extensions they depend on, or both.</source>
          <target state="translated">PostgreSQLと一緒に提供されている拡張機能は、他の拡張機能に依存しているものを除いて、この種のインストール時の攻撃に対して安全であると考えられています。これらの拡張機能のドキュメントに記載されているように、それらの拡張機能は安全なスキーマにインストールするか、依存する拡張機能と同じスキーマにインストールするか、あるいはその両方にインストールする必要があります。</target>
        </trans-unit>
        <trans-unit id="75cf68d4493c1ff227589e69d7f36aa6187d6f32" translate="yes" xml:space="preserve">
          <source>The extent of analysis can be controlled by adjusting the &lt;a href=&quot;runtime-config-query#GUC-DEFAULT-STATISTICS-TARGET&quot;&gt;default_statistics_target&lt;/a&gt; configuration variable, or on a column-by-column basis by setting the per-column statistics target with &lt;code&gt;ALTER TABLE ... ALTER COLUMN ... SET STATISTICS&lt;/code&gt; (see &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt;). The target value sets the maximum number of entries in the most-common-value list and the maximum number of bins in the histogram. The default target value is 100, but this can be adjusted up or down to trade off accuracy of planner estimates against the time taken for &lt;code&gt;ANALYZE&lt;/code&gt; and the amount of space occupied in &lt;code&gt;pg_statistic&lt;/code&gt;. In particular, setting the statistics target to zero disables collection of statistics for that column. It might be useful to do that for columns that are never used as part of the &lt;code&gt;WHERE&lt;/code&gt;, &lt;code&gt;GROUP BY&lt;/code&gt;, or &lt;code&gt;ORDER BY&lt;/code&gt; clauses of queries, since the planner will have no use for statistics on such columns.</source>
          <target state="translated">分析の範囲は、&lt;a href=&quot;runtime-config-query#GUC-DEFAULT-STATISTICS-TARGET&quot;&gt;default_statistics_target&lt;/a&gt;構成変数を調整することによって、または &lt;code&gt;ALTER TABLE ... ALTER COLUMN ... SET STATISTICS&lt;/code&gt; 使用して列ごとの統計ターゲットを設定することによって列ごとに制御できます（&lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLEを&lt;/a&gt;参照）。ターゲット値は、最も一般的な値のリストのエントリの最大数とヒストグラムのビンの最大数を設定します。デフォルトのターゲット値は100ですが、これを上下に調整して、 &lt;code&gt;ANALYZE&lt;/code&gt; にかかる時間と &lt;code&gt;pg_statistic&lt;/code&gt; で占有されているスペースの量に対するプランナー推定の精度をトレードオフできます。。特に、統計ターゲットをゼロに設定すると、その列の統計の収集が無効になります。クエリの &lt;code&gt;WHERE&lt;/code&gt; 、 &lt;code&gt;GROUP BY&lt;/code&gt; 、または &lt;code&gt;ORDER BY&lt;/code&gt; 句の一部として決して使用されない列については、プランナがそのような列の統計情報を使用しないため、これを行うと役立つ場合があります。</target>
        </trans-unit>
        <trans-unit id="4a1085020ce268691ef6285fd13220f59746e5a1" translate="yes" xml:space="preserve">
          <source>The external representation of an interval is formed using one or two floating-point numbers joined by the range operator (&lt;code&gt;..&lt;/code&gt; or &lt;code&gt;...&lt;/code&gt;). Alternatively, it can be specified as a center point plus or minus a deviation. Optional certainty indicators (&lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt; or &lt;code&gt;~&lt;/code&gt;) can be stored as well. (Certainty indicators are ignored by all the built-in operators, however.) &lt;a href=&quot;seg#SEG-REPR-TABLE&quot;&gt;Table F.26&lt;/a&gt; gives an overview of allowed representations; &lt;a href=&quot;seg#SEG-INPUT-EXAMPLES&quot;&gt;Table F.27&lt;/a&gt; shows some examples.</source>
          <target state="translated">間隔の外部表現は、範囲演算子（ &lt;code&gt;..&lt;/code&gt; または &lt;code&gt;...&lt;/code&gt; ）で結合された1つまたは2つの浮動小数点数を使用して形成されます。または、偏差を中心点としてプラスまたはマイナスとして指定することもできます。オプションの確実性インジケーター（ &lt;code&gt;&amp;lt;&lt;/code&gt; 、 &lt;code&gt;&amp;gt;&lt;/code&gt; または &lt;code&gt;~&lt;/code&gt; ）も保存できます。 （ただし、すべての組み込み演算子では確実性インジケータは無視されます。）&lt;a href=&quot;seg#SEG-REPR-TABLE&quot;&gt;表F.26に&lt;/a&gt;、許可される表現の概要を示します。&lt;a href=&quot;seg#SEG-INPUT-EXAMPLES&quot;&gt;表F.27に&lt;/a&gt;いくつかの例を示します。</target>
        </trans-unit>
        <trans-unit id="ae94f4d8ec241ec4efa4661c23c0573db1da2b96" translate="yes" xml:space="preserve">
          <source>The external text representation of a composite value consists of items that are interpreted according to the I/O conversion rules for the individual field types, plus decoration that indicates the composite structure. The decoration consists of parentheses (&lt;code&gt;(&lt;/code&gt; and &lt;code&gt;)&lt;/code&gt;) around the whole value, plus commas (&lt;code&gt;,&lt;/code&gt;) between adjacent items. Whitespace outside the parentheses is ignored, but within the parentheses it is considered part of the field value, and might or might not be significant depending on the input conversion rules for the field data type. For example, in:</source>
          <target state="translated">複合値の外部テキスト表現は、個々のフィールドタイプのI / O変換ルールに従って解釈されるアイテムと、複合構造を示す装飾で構成されます。装飾は、値全体を囲む括弧（ &lt;code&gt;(&lt;/code&gt; および &lt;code&gt;)&lt;/code&gt; ）と、隣接する項目間のコンマ（ &lt;code&gt;,&lt;/code&gt; ）で構成されます。括弧の外側の空白は無視されますが、括弧内はフィールド値の一部と見なされ、フィールドデータタイプの入力変換規則によっては、重要でない場合があります。たとえば、次の場所にあります。</target>
        </trans-unit>
        <trans-unit id="165e79d513851869bfa7df4f3e60a06eff8eadcf" translate="yes" xml:space="preserve">
          <source>The external text representation of an array value consists of items that are interpreted according to the I/O conversion rules for the array's element type, plus decoration that indicates the array structure. The decoration consists of curly braces (&lt;code&gt;{&lt;/code&gt; and &lt;code&gt;}&lt;/code&gt;) around the array value plus delimiter characters between adjacent items. The delimiter character is usually a comma (&lt;code&gt;,&lt;/code&gt;) but can be something else: it is determined by the &lt;code&gt;typdelim&lt;/code&gt; setting for the array's element type. Among the standard data types provided in the PostgreSQL distribution, all use a comma, except for type &lt;code&gt;box&lt;/code&gt;, which uses a semicolon (&lt;code&gt;;&lt;/code&gt;). In a multidimensional array, each dimension (row, plane, cube, etc.) gets its own level of curly braces, and delimiters must be written between adjacent curly-braced entities of the same level.</source>
          <target state="translated">配列値の外部テキスト表現は、配列の要素タイプのI / O変換規則に従って解釈されるアイテムと、配列構造を示す装飾で構成されます。装飾は、配列値を囲む中括弧（ &lt;code&gt;{&lt;/code&gt; および &lt;code&gt;}&lt;/code&gt; ）と、隣接するアイテム間の区切り文字で構成されます。区切り文字は通常コンマ（ &lt;code&gt;,&lt;/code&gt; ）ですが、他の文字でもかまいません。これは、配列の要素タイプの &lt;code&gt;typdelim&lt;/code&gt; 設定によって決定されます。 PostgreSQLディストリビューションで提供される標準のデータ型のうち、セミコロン（ &lt;code&gt;;&lt;/code&gt; を使用する &lt;code&gt;box&lt;/code&gt; 型を除き、すべてコンマを使用します。）。多次元配列では、各次元（行、平面、立方体など）が独自のレベルの波括弧を取得し、同じレベルの隣接する波括弧エンティティ間に区切り文字を記述する必要があります。</target>
        </trans-unit>
        <trans-unit id="6b72823d964b50e21e643394f5a86559900b575c" translate="yes" xml:space="preserve">
          <source>The external, user defined, name of a replication origin.</source>
          <target state="translated">レプリケーションオリジンの外部、ユーザー定義の名前。</target>
        </trans-unit>
        <trans-unit id="b158be94edfd836340b3eb6a9fee5fccbd77513b" translate="yes" xml:space="preserve">
          <source>The fact that a result set is a relation means that a query can be used in the definition of another query, becoming a &lt;em&gt;subquery&lt;/em&gt;.</source>
          <target state="translated">The fact that a result set is a relation means that a query can be used in the definition of another query, becoming a &lt;em&gt;subquery&lt;/em&gt;.</target>
        </trans-unit>
        <trans-unit id="23e10c575081917649336c89f16d01777906e835" translate="yes" xml:space="preserve">
          <source>The fact that constraint exclusion uses &lt;code&gt;CHECK&lt;/code&gt; constraints, which makes it slow compared to partition pruning, can sometimes be used as an advantage: because constraints can be defined even on declaratively-partitioned tables, in addition to their internal partition bounds, constraint exclusion may be able to elide additional partitions from the query plan.</source>
          <target state="translated">制約の除外は &lt;code&gt;CHECK&lt;/code&gt; 制約を使用するため、パーティションのプルーニングに比べて遅くなりますが、利点として使用できる場合があります。内部パーティション境界に加えて、宣言的にパーティション分割されたテーブルでも制約を定義できるため、制約の除外はクエリプランから追加のパーティションを除外できます。</target>
        </trans-unit>
        <trans-unit id="19233032264a45feb14fbaa7d90f7412bf00d3b4" translate="yes" xml:space="preserve">
          <source>The factory default limit on open files is often set to &amp;ldquo;socially friendly&amp;rdquo; values that allow many users to coexist on a machine without using an inappropriate fraction of the system resources. If you run many servers on a machine this is perhaps what you want, but on dedicated servers you might want to raise this limit.</source>
          <target state="translated">オープンファイルの工場出荷時のデフォルト制限は、多くの場合、システムリソースの不適切な部分を使用せずに多くのユーザーがマシン上で共存できる「社交的」な値に設定されています。マシン上で多くのサーバーを実行する場合、これはおそらく必要なことですが、専用サーバーではこの制限を引き上げることができます。</target>
        </trans-unit>
        <trans-unit id="656ca22572866570d9b541e49d642f6e1926acfb" translate="yes" xml:space="preserve">
          <source>The field/element/path extraction operators return NULL, rather than failing, if the JSON input does not have the right structure to match the request; for example if no such key or array element exists.</source>
          <target state="translated">フィールド/要素/パス抽出演算子は、JSON 入力がリクエストにマッチする正しい構造を持っていない場合、 失敗するのではなく NULL を返します。</target>
        </trans-unit>
        <trans-unit id="7eb210aea67c31ef1dbed7fd3eae3f43ab6220c6" translate="yes" xml:space="preserve">
          <source>The file &lt;code&gt;/etc/sysctl.conf&lt;/code&gt; is only honored in macOS 10.3.9 and later. If you are running a previous 10.3.x release, you must edit the file &lt;code&gt;/etc/rc&lt;/code&gt; and change the values in the following commands:</source>
          <target state="translated">&lt;code&gt;/etc/sysctl.conf&lt;/code&gt; ファイルは、macOS 10.3.9以降でのみ有効です。以前の10.3.xリリースを実行している場合は、ファイル &lt;code&gt;/etc/rc&lt;/code&gt; を編集して、次のコマンドの値を変更する必要があります。</target>
        </trans-unit>
        <trans-unit id="84e9c854c59c60e0df39d55604e40742c14a3b04" translate="yes" xml:space="preserve">
          <source>The file &lt;code&gt;scan.l&lt;/code&gt; is transformed to the C source file &lt;code&gt;scan.c&lt;/code&gt; using the program flex and &lt;code&gt;gram.y&lt;/code&gt; is transformed to &lt;code&gt;gram.c&lt;/code&gt; using bison. After these transformations have taken place a normal C compiler can be used to create the parser. Never make any changes to the generated C files as they will be overwritten the next time flex or bison is called.</source>
          <target state="translated">ファイル &lt;code&gt;scan.l&lt;/code&gt; はプログラムflexを使用してCソースファイル &lt;code&gt;scan.c&lt;/code&gt; に変換され、 &lt;code&gt;gram.y&lt;/code&gt; はbisonを使用して &lt;code&gt;gram.c&lt;/code&gt; に変換されます。これらの変換が行われた後、通常のCコンパイラを使用してパーサーを作成できます。生成されたCファイルは、次回flexまたはbisonが呼び出されたときに上書きされるため、変更しないでください。</target>
        </trans-unit>
        <trans-unit id="45d0800a2dc4458be5cbd179d0ad2c43301c7d89" translate="yes" xml:space="preserve">
          <source>The file header consists of 15 bytes of fixed fields, followed by a variable-length header extension area. The fixed fields are:</source>
          <target state="translated">ファイルヘッダーは15バイトの固定フィールドと、可変長のヘッダー拡張領域で構成されています。固定フィールドは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="08e8ce7451fee51ac789a7527b77201e50285954" translate="yes" xml:space="preserve">
          <source>The file name that will be used to store the history list. If unset, the file name is taken from the &lt;code&gt;PSQL_HISTORY&lt;/code&gt; environment variable. If that is not set either, the default is &lt;code&gt;~/.psql_history&lt;/code&gt;, or &lt;code&gt;%APPDATA%\postgresql\psql_history&lt;/code&gt; on Windows. For example, putting:</source>
          <target state="translated">履歴リストの保存に使用されるファイル名。設定されていない場合、ファイル名は &lt;code&gt;PSQL_HISTORY&lt;/code&gt; 環境変数から取得されます。これも設定されていない場合、デフォルトは &lt;code&gt;~/.psql_history&lt;/code&gt; 、またはWindowsでは &lt;code&gt;%APPDATA%\postgresql\psql_history&lt;/code&gt; です。たとえば、次のようにします。</target>
        </trans-unit>
        <trans-unit id="349919ea5386038c9255234a7dc46c1f159466f8" translate="yes" xml:space="preserve">
          <source>The file trailer consists of a 16-bit integer word containing -1. This is easily distinguished from a tuple's field-count word.</source>
          <target state="translated">ファイルトレーラは、-1を含む16ビットの整数ワードで構成されています。これはタプルのフィールドカウントワードと簡単に区別できます。</target>
        </trans-unit>
        <trans-unit id="80e18aa528aa991bd67d4fb018eb762c1dfd60ad" translate="yes" xml:space="preserve">
          <source>The fillfactor for a table is a percentage between 10 and 100. 100 (complete packing) is the default. When a smaller fillfactor is specified, &lt;code&gt;INSERT&lt;/code&gt; operations pack table pages only to the indicated percentage; the remaining space on each page is reserved for updating rows on that page. This gives &lt;code&gt;UPDATE&lt;/code&gt; a chance to place the updated copy of a row on the same page as the original, which is more efficient than placing it on a different page. For a table whose entries are never updated, complete packing is the best choice, but in heavily updated tables smaller fillfactors are appropriate. This parameter cannot be set for TOAST tables.</source>
          <target state="translated">テーブルのfillfactorは、10から100の間のパーセントです。100（完全なパッキング）がデフォルトです。より小さいfillfactorが指定されている場合、 &lt;code&gt;INSERT&lt;/code&gt; 操作は、指定されたパーセンテージにのみテーブルページをパックします。各ページの残りのスペースは、そのページの行を更新するために予約されています。これにより、 &lt;code&gt;UPDATE&lt;/code&gt; は行の更新されたコピーを元のページと同じページに配置する機会が得られます。これは、別のページに配置するよりも効率的です。エントリが決して更新されないテーブルの場合、完全なパッキングが最良の選択ですが、頻繁に更新されるテーブルでは、より小さいfillfactorsが適切です。このパラメーターはTOASTテーブルには設定できません。</target>
        </trans-unit>
        <trans-unit id="4a018942b6effccffd16cfc6cd2d9f3b5906ea0a" translate="yes" xml:space="preserve">
          <source>The fillfactor for an index is a percentage that determines how full the index method will try to pack index pages. For B-trees, leaf pages are filled to this percentage during initial index build, and also when extending the index at the right (adding new largest key values). If pages subsequently become completely full, they will be split, leading to gradual degradation in the index's efficiency. B-trees use a default fillfactor of 90, but any integer value from 10 to 100 can be selected. If the table is static then fillfactor 100 is best to minimize the index's physical size, but for heavily updated tables a smaller fillfactor is better to minimize the need for page splits. The other index methods use fillfactor in different but roughly analogous ways; the default fillfactor varies between methods.</source>
          <target state="translated">インデックスのフィルファクターは、インデックスメソッドがインデックスページをどれだけいっぱいに詰めようとするかを決定するパーセンテージです。B-木の場合、リーフページは、最初のインデックス構築時と、右端でインデックスを拡張するとき(新しい最大のキー値を追加するとき)に、このパーセンテージで埋められます。その後、ページが完全に一杯になった場合、それらのページは分割され、インデックスの効率は徐々に低下していきます。B-tree はデフ ォル ト の fillfactor 90 を用いていますが、10 ~ 100 の任意の整数値を選択することができます。テーブルが静的な場合は、インデックスの物理的なサイズを最小化するにはフィルファクタ100が最適ですが、更新の多いテーブルの場合は、ページ分割の必要性を最小化するにはフィルファクタを小さくした方が良いでしょう。他のインデックスメソッドは、異なる方法で fillfactor を使用していますが、ほぼ類似した方法で使用しています。</target>
        </trans-unit>
        <trans-unit id="5c29e42edd123c00869988ea11e4589bccf58ecb" translate="yes" xml:space="preserve">
          <source>The final section is the &amp;ldquo;special section&amp;rdquo; which can contain anything the access method wishes to store. For example, b-tree indexes store links to the page's left and right siblings, as well as some other data relevant to the index structure. Ordinary tables do not use a special section at all (indicated by setting &lt;code&gt;pd_special&lt;/code&gt; to equal the page size).</source>
          <target state="translated">最後のセクションは「特別なセクション」であり、アクセスメソッドが格納したいものをすべて含めることができます。たとえば、Bツリーインデックスには、ページの左兄弟と右兄弟へのリンクだけでなく、インデックス構造に関連するその他のデータも格納されます。通常のテーブルは特別なセクションをまったく使用しません（ページサイズと等しくなるように &lt;code&gt;pd_special&lt;/code&gt; を設定することで示されます）。</target>
        </trans-unit>
        <trans-unit id="02efe302dcd79b9e88f3a8473b49b8f9d4ac5123" translate="yes" xml:space="preserve">
          <source>The finished plan tree consists of sequential or index scans of the base relations, plus nested-loop, merge, or hash join nodes as needed, plus any auxiliary steps needed, such as sort nodes or aggregate-function calculation nodes. Most of these plan node types have the additional ability to do &lt;em&gt;selection&lt;/em&gt; (discarding rows that do not meet a specified Boolean condition) and &lt;em&gt;projection&lt;/em&gt; (computation of a derived column set based on given column values, that is, evaluation of scalar expressions where needed). One of the responsibilities of the planner is to attach selection conditions from the &lt;code&gt;WHERE&lt;/code&gt; clause and computation of required output expressions to the most appropriate nodes of the plan tree.</source>
          <target state="translated">完成したプランツリーは、基本リレーションの順次スキャンまたはインデックススキャン、さらに必要に応じてネストループ、マージ、またはハッシュ結合ノード、およびソートノードや集計関数計算ノードなどの必要な補助ステップで構成されます。これらのプランノードタイプのほとんどには、&lt;em&gt;選択&lt;/em&gt;（指定されたブール条件を満たさない行を破棄する）および&lt;em&gt;射影&lt;/em&gt;（特定の列値に基づく派生列セットの計算、つまり必要に応じたスカラー式の評価）を実行する追加機能があります。 。プランナーの責任の1つは、 &lt;code&gt;WHERE&lt;/code&gt; 句からの選択条件と必要な出力式の計算をプランツリーの最も適切なノードに付加することです。</target>
        </trans-unit>
        <trans-unit id="2f91a1368250aec82fa6c3ae45da03e945de99bb" translate="yes" xml:space="preserve">
          <source>The firing of triggers that are declared as &amp;ldquo;constraint triggers&amp;rdquo; is also controlled by this setting &amp;mdash; they fire at the same time that the associated constraint should be checked.</source>
          <target state="translated">「制約トリガー」として宣言されているトリガーの起動も、この設定によって制御されます。これらのトリガーは、関連する制約を確認すると同時に起動します。</target>
        </trans-unit>
        <trans-unit id="88e7caa4743ed2b44e88bb8540b5ed22e8f063f5" translate="yes" xml:space="preserve">
          <source>The first 24 bytes of each page consists of a page header (&lt;code&gt;PageHeaderData&lt;/code&gt;). Its format is detailed in &lt;a href=&quot;storage-page-layout#PAGEHEADERDATA-TABLE&quot;&gt;Table 68.3&lt;/a&gt;. The first field tracks the most recent WAL entry related to this page. The second field contains the page checksum if &lt;a href=&quot;app-initdb#APP-INITDB-DATA-CHECKSUMS&quot;&gt;data checksums&lt;/a&gt; are enabled. Next is a 2-byte field containing flag bits. This is followed by three 2-byte integer fields (&lt;code&gt;pd_lower&lt;/code&gt;, &lt;code&gt;pd_upper&lt;/code&gt;, and &lt;code&gt;pd_special&lt;/code&gt;). These contain byte offsets from the page start to the start of unallocated space, to the end of unallocated space, and to the start of the special space. The next 2 bytes of the page header, &lt;code&gt;pd_pagesize_version&lt;/code&gt;, store both the page size and a version indicator. Beginning with PostgreSQL 8.3 the version number is 4; PostgreSQL 8.1 and 8.2 used version number 3; PostgreSQL 8.0 used version number 2; PostgreSQL 7.3 and 7.4 used version number 1; prior releases used version number 0. (The basic page layout and header format has not changed in most of these versions, but the layout of heap row headers has.) The page size is basically only present as a cross-check; there is no support for having more than one page size in an installation. The last field is a hint that shows whether pruning the page is likely to be profitable: it tracks the oldest un-pruned XMAX on the page.</source>
          <target state="translated">各ページの最初の24バイトは、ページヘッダー（ &lt;code&gt;PageHeaderData&lt;/code&gt; ）で構成されています。そのフォーマットの詳細を&lt;a href=&quot;storage-page-layout#PAGEHEADERDATA-TABLE&quot;&gt;表68.3に示し&lt;/a&gt;ます。最初のフィールドは、このページに関連する最新のWALエントリを追跡します。&lt;a href=&quot;app-initdb#APP-INITDB-DATA-CHECKSUMS&quot;&gt;データチェックサム&lt;/a&gt;が有効な場合、2番目のフィールドにはページのチェックサムが含まれます。次は、フラグビットを含む2バイトのフィールドです。この後に、3つの2バイト整数フィールド（ &lt;code&gt;pd_lower&lt;/code&gt; 、 &lt;code&gt;pd_upper&lt;/code&gt; 、および &lt;code&gt;pd_special&lt;/code&gt; ）が続きます。これらには、ページの開始から未割り当てスペースの開始、未割り当てスペースの終了、および特殊スペースの開始までのバイトオフセットが含まれています。ページヘッダーの次の2バイト、 &lt;code&gt;pd_pagesize_version&lt;/code&gt; 、ページサイズとバージョンインジケーターの両方を保存します。 PostgreSQL 8.3以降、バージョン番号は4です。 PostgreSQL 8.1および8.2はバージョン番号3を使用しました。 PostgreSQL 8.0はバージョン番号2を使用しました。 PostgreSQL 7.3および7.4はバージョン番号1を使用しました。以前のリリースではバージョン番号0を使用していました（これらのバージョンのほとんどで基本的なページレイアウトとヘッダー形式は変更されていませんが、ヒープ行ヘッダーのレイアウトは変更されています）。ページサイズは基本的にクロスチェックとしてのみ存在します。インストールで複数のページサイズを使用することはサポートされていません。最後のフィールドは、ページのプルーニングが有益である可能性が高いかどうかを示すヒントです。これは、ページ上の最も古いプルーニングされていないXMAXを追跡します。</target>
        </trans-unit>
        <trans-unit id="146b5ed003ceae9188015f907676c66e37810a01" translate="yes" xml:space="preserve">
          <source>The first &lt;code&gt;UPDATE&lt;/code&gt; statement successfully acquires a row-level lock on the specified row, so it succeeds in updating that row. However, the second &lt;code&gt;UPDATE&lt;/code&gt; statement finds that the row it is attempting to update has already been locked, so it waits for the transaction that acquired the lock to complete. Transaction two is now waiting on transaction one to complete before it continues execution. Now, transaction one executes:</source>
          <target state="translated">最初の &lt;code&gt;UPDATE&lt;/code&gt; ステートメントは、指定された行の行レベルのロックを正常に取得するため、その行の更新に成功します。ただし、2番目の &lt;code&gt;UPDATE&lt;/code&gt; ステートメントは、更新しようとしている行が既にロックされていることを検出したため、ロックを取得したトランザクションが完了するまで待機します。トランザクション2は、実行を続行する前にトランザクション1が完了するのを待機しています。ここで、トランザクション1が実行されます。</target>
        </trans-unit>
        <trans-unit id="5efcfda2d8c77b88473ca9337c42439a024d54ff" translate="yes" xml:space="preserve">
          <source>The first &lt;code&gt;expression&lt;/code&gt; is computed, then compared to each of the &lt;code&gt;value&lt;/code&gt; expressions in the &lt;code&gt;WHEN&lt;/code&gt; clauses until one is found that is equal to it. If no match is found, the &lt;code&gt;result&lt;/code&gt; of the &lt;code&gt;ELSE&lt;/code&gt; clause (or a null value) is returned. This is similar to the &lt;code&gt;switch&lt;/code&gt; statement in C.</source>
          <target state="translated">最初の &lt;code&gt;expression&lt;/code&gt; が計算され、それと等しいものが見つかるまで、 &lt;code&gt;WHEN&lt;/code&gt; 句の各 &lt;code&gt;value&lt;/code&gt; 式と比較されます。一致するものが見つからない場合、 &lt;code&gt;ELSE&lt;/code&gt; 句の &lt;code&gt;result&lt;/code&gt; （またはnull値）が返されます。これは、Cの &lt;code&gt;switch&lt;/code&gt; ステートメントに似ています。</target>
        </trans-unit>
        <trans-unit id="db81095a43bec432038707d12a55f4ea232797fc" translate="yes" xml:space="preserve">
          <source>The first approach makes use of the &lt;code&gt;cert&lt;/code&gt; authentication method for &lt;code&gt;hostssl&lt;/code&gt; entries in &lt;code&gt;pg_hba.conf&lt;/code&gt;, such that the certificate itself is used for authentication while also providing ssl connection security. See &lt;a href=&quot;auth-cert&quot;&gt;Section 20.12&lt;/a&gt; for details. (It is not necessary to specify any &lt;code&gt;clientcert&lt;/code&gt; options explicitly when using the &lt;code&gt;cert&lt;/code&gt; authentication method.) In this case, the &lt;code&gt;cn&lt;/code&gt; (Common Name) provided in the certificate is checked against the user name or an applicable mapping.</source>
          <target state="translated">最初のアプローチは &lt;code&gt;pg_hba.conf&lt;/code&gt; の &lt;code&gt;hostssl&lt;/code&gt; エントリに &lt;code&gt;cert&lt;/code&gt; 認証方式を利用することで、証明書自体が認証に使用されると同時に、SSL接続のセキュリティも提供されます。詳細は&lt;a href=&quot;auth-cert&quot;&gt;項20.12&lt;/a&gt;を参照してください。 （ &lt;code&gt;cert&lt;/code&gt; 認証方式を使用する場合、 &lt;code&gt;clientcert&lt;/code&gt; オプションを明示的に指定する必要はありません。）この場合、証明書で提供される &lt;code&gt;cn&lt;/code&gt; （共通名）は、ユーザー名または適用可能なマッピングに対してチェックされます。</target>
        </trans-unit>
        <trans-unit id="44f0ace0e5a351af8867382fc6a4698f25099edc" translate="yes" xml:space="preserve">
          <source>The first argument is a pointer to a &lt;code&gt;spgChooseIn&lt;/code&gt; C struct, containing input data for the function. The second argument is a pointer to a &lt;code&gt;spgChooseOut&lt;/code&gt; C struct, which the function must fill with result data.</source>
          <target state="translated">最初の引数は、関数の入力データを含む &lt;code&gt;spgChooseIn&lt;/code&gt; C構造体へのポインターです。2番目の引数は &lt;code&gt;spgChooseOut&lt;/code&gt; C構造体へのポインターであり、関数は結果データを入力する必要があります。</target>
        </trans-unit>
        <trans-unit id="73a46dbd547b3476953fd0d40d226d75ab67a447" translate="yes" xml:space="preserve">
          <source>The first argument is a pointer to a &lt;code&gt;spgConfigIn&lt;/code&gt; C struct, containing input data for the function. The second argument is a pointer to a &lt;code&gt;spgConfigOut&lt;/code&gt; C struct, which the function must fill with result data.</source>
          <target state="translated">最初の引数は、関数の入力データを含む &lt;code&gt;spgConfigIn&lt;/code&gt; C構造体へのポインターです。2番目の引数は &lt;code&gt;spgConfigOut&lt;/code&gt; C構造体へのポインターであり、関数は結果データを入力する必要があります。</target>
        </trans-unit>
        <trans-unit id="b3d25ba584bb4c4acb9f3461e219135398ddc741" translate="yes" xml:space="preserve">
          <source>The first argument is a pointer to a &lt;code&gt;spgInnerConsistentIn&lt;/code&gt; C struct, containing input data for the function. The second argument is a pointer to a &lt;code&gt;spgInnerConsistentOut&lt;/code&gt; C struct, which the function must fill with result data.</source>
          <target state="translated">最初の引数は、関数の入力データを含む &lt;code&gt;spgInnerConsistentIn&lt;/code&gt; C構造体へのポインターです。2番目の引数は、関数が結果データで埋めなければならない &lt;code&gt;spgInnerConsistentOut&lt;/code&gt; C構造体へのポインターです。</target>
        </trans-unit>
        <trans-unit id="4b95190547cc0ff307d0a7948518c66223c69217" translate="yes" xml:space="preserve">
          <source>The first argument is a pointer to a &lt;code&gt;spgLeafConsistentIn&lt;/code&gt; C struct, containing input data for the function. The second argument is a pointer to a &lt;code&gt;spgLeafConsistentOut&lt;/code&gt; C struct, which the function must fill with result data.</source>
          <target state="translated">最初の引数は、関数の入力データを含む &lt;code&gt;spgLeafConsistentIn&lt;/code&gt; C構造体へのポインターです。2番目の引数は、関数が結果データで埋めなければならない &lt;code&gt;spgLeafConsistentOut&lt;/code&gt; C構造体へのポインターです。</target>
        </trans-unit>
        <trans-unit id="ca5853d09340bad3adb00c3e57ccca9e872f72bb" translate="yes" xml:space="preserve">
          <source>The first argument is a pointer to a &lt;code&gt;spgPickSplitIn&lt;/code&gt; C struct, containing input data for the function. The second argument is a pointer to a &lt;code&gt;spgPickSplitOut&lt;/code&gt; C struct, which the function must fill with result data.</source>
          <target state="translated">最初の引数は、関数の入力データを含む &lt;code&gt;spgPickSplitIn&lt;/code&gt; C構造体へのポインターです。2番目の引数は、関数が結果データで埋めなければならない &lt;code&gt;spgPickSplitOut&lt;/code&gt; C構造体へのポインターです。</target>
        </trans-unit>
        <trans-unit id="1f369dd1771752484284223f6c8b61724d963075" translate="yes" xml:space="preserve">
          <source>The first argument is the relation to be prewarmed. The second argument is the prewarming method to be used, as further discussed below; the third is the relation fork to be prewarmed, usually &lt;code&gt;main&lt;/code&gt;. The fourth argument is the first block number to prewarm (&lt;code&gt;NULL&lt;/code&gt; is accepted as a synonym for zero). The fifth argument is the last block number to prewarm (&lt;code&gt;NULL&lt;/code&gt; means prewarm through the last block in the relation). The return value is the number of blocks prewarmed.</source>
          <target state="translated">最初の引数は、事前に暖められる関係です。 2番目の引数は、以下でさらに説明するように、使用する予熱方法です。 3番目は、事前に暖められる関係フォークで、通常は &lt;code&gt;main&lt;/code&gt; です。 4番目の引数は、事前ウォームする最初のブロック番号です（ &lt;code&gt;NULL&lt;/code&gt; はゼロの同義語として受け入れられます）。 5番目の引数は、事前ウォームする最後のブロック番号です（ &lt;code&gt;NULL&lt;/code&gt; は、関係の最後のブロックまで事前ウォームすることを意味します）。戻り値は、予熱されたブロックの数です。</target>
        </trans-unit>
        <trans-unit id="cd29c1ca625357cd146a327c957cb4b92e5a317e" translate="yes" xml:space="preserve">
          <source>The first century starts at 0001-01-01 00:00:00 AD, although they did not know it at the time. This definition applies to all Gregorian calendar countries. There is no century number 0, you go from -1 century to 1 century. If you disagree with this, please write your complaint to: Pope, Cathedral Saint-Peter of Roma, Vatican.</source>
          <target state="translated">当時は知らなかったが、1世紀は西暦0001-01-01 00:00:00から始まる。この定義はすべてのグレゴリオ暦の国に適用されます。世紀番号0は存在せず、-1世紀から1世紀へと進みます。あなたがこれに同意しない場合は、あなたの苦情を書いてください。ローマ教皇、ローマ大聖堂サン=ペテル、バチカン</target>
        </trans-unit>
        <trans-unit id="31c0daddd0e62eb1e65c5d8c244c78848b7fb826" translate="yes" xml:space="preserve">
          <source>The first certificate in &lt;code&gt;server.crt&lt;/code&gt; must be the server's certificate because it must match the server's private key. The certificates of &amp;ldquo;intermediate&amp;rdquo; certificate authorities can also be appended to the file. Doing this avoids the necessity of storing intermediate certificates on clients, assuming the root and intermediate certificates were created with &lt;code&gt;v3_ca&lt;/code&gt; extensions. (This sets the certificate's basic constraint of &lt;code&gt;CA&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt;.) This allows easier expiration of intermediate certificates.</source>
          <target state="translated">The first certificate in &lt;code&gt;server.crt&lt;/code&gt; must be the server's certificate because it must match the server's private key. The certificates of &amp;ldquo;intermediate&amp;rdquo; certificate authorities can also be appended to the file. Doing this avoids the necessity of storing intermediate certificates on clients, assuming the root and intermediate certificates were created with &lt;code&gt;v3_ca&lt;/code&gt; extensions. (This sets the certificate's basic constraint of &lt;code&gt;CA&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt; .) This allows easier expiration of intermediate certificates.</target>
        </trans-unit>
        <trans-unit id="256263538ce2e1f28734e2b2ed2dbaa9ee5222c8" translate="yes" xml:space="preserve">
          <source>The first certificate in &lt;code&gt;server.crt&lt;/code&gt; must be the server's certificate because it must match the server's private key. The certificates of &amp;ldquo;intermediate&amp;rdquo; certificate authorities can also be appended to the file. Doing this avoids the necessity of storing intermediate certificates on clients, assuming the root and intermediate certificates were created with &lt;code&gt;v3_ca&lt;/code&gt; extensions. This allows easier expiration of intermediate certificates.</source>
          <target state="translated">&lt;code&gt;server.crt&lt;/code&gt; の最初の証明書は、サーバーの秘密鍵と一致する必要があるため、サーバーの証明書でなければなりません。 「中間」認証局の証明書もファイルに追加できます。これにより、ルート証明書と中間証明書が &lt;code&gt;v3_ca&lt;/code&gt; 拡張で作成されたと想定して、中間証明書をクライアントに保存する必要がなくなります。これにより、中間証明書の有効期限が簡単になります。</target>
        </trans-unit>
        <trans-unit id="79f3996eda734e252b355fcb3237a8e729927963" translate="yes" xml:space="preserve">
          <source>The first element specifies that a schema with the same name as the current user is to be searched. If no such schema exists, the entry is ignored. The second element refers to the public schema that we have seen already.</source>
          <target state="translated">最初の要素は、現在のユーザと同じ名前のスキーマを検索することを指定します。そのようなスキーマが存在しない場合、エントリは無視されます。2番目の要素は、すでに見た公開スキーマを参照します。</target>
        </trans-unit>
        <trans-unit id="f0dca4048f0fcfac6cd746615ce4e8a0baea6f2f" translate="yes" xml:space="preserve">
          <source>The first example adds a time zone to a value that lacks it, and displays the value using the current &lt;code&gt;TimeZone&lt;/code&gt; setting. The second example shifts the time stamp with time zone value to the specified time zone, and returns the value without a time zone. This allows storage and display of values different from the current &lt;code&gt;TimeZone&lt;/code&gt; setting. The third example converts Tokyo time to Chicago time.</source>
          <target state="translated">The first example adds a time zone to a value that lacks it, and displays the value using the current &lt;code&gt;TimeZone&lt;/code&gt; setting. The second example shifts the time stamp with time zone value to the specified time zone, and returns the value without a time zone. This allows storage and display of values different from the current &lt;code&gt;TimeZone&lt;/code&gt; setting. The third example converts Tokyo time to Chicago time.</target>
        </trans-unit>
        <trans-unit id="5dd1c81747f7da19e4955a86256d7b17a34ec6f9" translate="yes" xml:space="preserve">
          <source>The first example adds a time zone to a value that lacks it, and displays the value using the current &lt;code&gt;TimeZone&lt;/code&gt; setting. The second example shifts the time stamp with time zone value to the specified time zone, and returns the value without a time zone. This allows storage and display of values different from the current &lt;code&gt;TimeZone&lt;/code&gt; setting. The third example converts Tokyo time to Chicago time. Converting &lt;em&gt;time&lt;/em&gt; values to other time zones uses the currently active time zone rules since no date is supplied.</source>
          <target state="translated">最初の例では、タイムゾーンを欠落している値に追加し、現在の &lt;code&gt;TimeZone&lt;/code&gt; 設定を使用して値を表示します。2番目の例では、タイムゾーン値を含むタイムスタンプを指定されたタイムゾーンにシフトし、タイムゾーンなしの値を返します。これにより、現在の &lt;code&gt;TimeZone&lt;/code&gt; 設定とは異なる値を保存および表示できます。3番目の例は、東京時間をシカゴ時間に変換します。&lt;em&gt;時間&lt;/em&gt;値を他のタイムゾーンに変換するには、日付が指定されていないため、現在アクティブなタイムゾーンルールが使用されます。</target>
        </trans-unit>
        <trans-unit id="dd4f388d81712247b36f96199e31fe01ab0dcd8a" translate="yes" xml:space="preserve">
          <source>The first example omits &lt;code&gt;ROW&lt;/code&gt;, the second uses it; we could have done it either way.</source>
          <target state="translated">最初の例では &lt;code&gt;ROW&lt;/code&gt; を省略し、2番目の例ではROWを使用しています。どちらにしてもできたはずです。</target>
        </trans-unit>
        <trans-unit id="612c7d9435df3c5121ea73e09ab866021bad4c1b" translate="yes" xml:space="preserve">
          <source>The first example selects the ICU locale using a &amp;ldquo;language tag&amp;rdquo; per BCP 47. The second example uses the traditional ICU-specific locale syntax. The first style is preferred going forward, but it is not supported by older ICU versions.</source>
          <target state="translated">最初の例では、BCP 47の「言語タグ」を使用してICUロケールを選択します。2番目の例では、従来のICU固有のロケール構文を使用します。最初のスタイルは今後推奨されますが、古いICUバージョンではサポートされていません。</target>
        </trans-unit>
        <trans-unit id="f1d60b8c5a21ae5115bceb8211e299ddf895cf0f" translate="yes" xml:space="preserve">
          <source>The first example shows how to spread a command over several lines of input. Notice the changing prompt:</source>
          <target state="translated">最初の例では、コマンドを数行の入力に分散させる方法を示しています。変化するプロンプトに注目してください。</target>
        </trans-unit>
        <trans-unit id="e43256b97dc53da480190315bac59bb3f0cada5f" translate="yes" xml:space="preserve">
          <source>The first form changes certain per-database settings. (See below for details.) Only the database owner or a superuser can change these settings.</source>
          <target state="translated">最初のフォームでは、データベースごとに特定の設定を変更します。(詳細は以下を参照してください。)これらの設定を変更できるのは、データベースの所有者またはスーパーユーザーのみです。</target>
        </trans-unit>
        <trans-unit id="da17ae59b4b9d415d049588fbe4c802a8a77a808" translate="yes" xml:space="preserve">
          <source>The first form of &lt;code&gt;CREATE TYPE&lt;/code&gt; creates a composite type. The composite type is specified by a list of attribute names and data types. An attribute's collation can be specified too, if its data type is collatable. A composite type is essentially the same as the row type of a table, but using &lt;code&gt;CREATE TYPE&lt;/code&gt; avoids the need to create an actual table when all that is wanted is to define a type. A stand-alone composite type is useful, for example, as the argument or return type of a function.</source>
          <target state="translated">&lt;code&gt;CREATE TYPE&lt;/code&gt; の最初の形式は、複合型を作成します。複合型は、属性名とデータ型のリストによって指定されます。データ型が照合可能な場合、属性の照合も指定できます。複合タイプは基本的にテーブルの行タイプと同じですが、 &lt;code&gt;CREATE TYPE&lt;/code&gt; を使用すると、タイプを定義するだけで実際のテーブルを作成する必要がなくなります。スタンドアロンの複合型は、たとえば、関数の引数または戻り値の型として役立ちます。</target>
        </trans-unit>
        <trans-unit id="a9da06ff6dbdef653da94da0ffaf44a0aef0024f" translate="yes" xml:space="preserve">
          <source>The first form of aggregate expression invokes the aggregate once for each input row. The second form is the same as the first, since &lt;code&gt;ALL&lt;/code&gt; is the default. The third form invokes the aggregate once for each distinct value of the expression (or distinct set of values, for multiple expressions) found in the input rows. The fourth form invokes the aggregate once for each input row; since no particular input value is specified, it is generally only useful for the &lt;code&gt;count(*)&lt;/code&gt; aggregate function. The last form is used with &lt;em&gt;ordered-set&lt;/em&gt; aggregate functions, which are described below.</source>
          <target state="translated">集約式の最初の形式は、入力行ごとに1回、集約を呼び出します。 &lt;code&gt;ALL&lt;/code&gt; がデフォルトであるため、2番目の形式は最初の形式と同じです。 3番目の形式は、入力行にある式の個別の値（または複数の式の場合は個別の値のセット）ごとに1回集計を呼び出します。 4番目の形式は、入力行ごとに1回集計を呼び出します。特定の入力値が指定されていないため、通常は &lt;code&gt;count(*)&lt;/code&gt; 集約関数に対してのみ役立ちます。最後の形式は、以下で説明する&lt;em&gt;順序付き&lt;/em&gt;集合関数で使用されます。</target>
        </trans-unit>
        <trans-unit id="c6c37d2c4cb9171a6fcf0c1214edbc6145fc4b4d" translate="yes" xml:space="preserve">
          <source>The first form of the &lt;code&gt;CREATE TYPE&lt;/code&gt; command, which creates a composite type, conforms to the SQL standard. The other forms are PostgreSQL extensions. The &lt;code&gt;CREATE TYPE&lt;/code&gt; statement in the SQL standard also defines other forms that are not implemented in PostgreSQL.</source>
          <target state="translated">複合タイプを作成する &lt;code&gt;CREATE TYPE&lt;/code&gt; コマンドの最初の形式は、SQL標準に準拠しています。他の形式はPostgreSQL拡張機能です。SQL標準の &lt;code&gt;CREATE TYPE&lt;/code&gt; ステートメントは、PostgreSQLに実装されていない他の形式も定義します。</target>
        </trans-unit>
        <trans-unit id="c38ff028812a13bb491adf5222d97dc3de42b820" translate="yes" xml:space="preserve">
          <source>The first line of an affix class is the header. Fields of an affix rules are listed after the header:</source>
          <target state="translated">アフィックスクラスの最初の行はヘッダーです。アフィックスルールのフィールドは、ヘッダーの後にリストアップされます。</target>
        </trans-unit>
        <trans-unit id="c36e2c0d0e2475af262a16c7939f4fd6fcb834b7" translate="yes" xml:space="preserve">
          <source>The first number in the &lt;code&gt;-L&lt;/code&gt; argument, 63333, is the local port number of the tunnel; it can be any unused port. (IANA reserves ports 49152 through 65535 for private use.) The name or IP address after this is the remote bind address you are connecting to, i.e., &lt;code&gt;localhost&lt;/code&gt;, which is the default. The second number, 5432, is the remote end of the tunnel, e.g., the port number your database server is using. In order to connect to the database server using this tunnel, you connect to port 63333 on the local machine:</source>
          <target state="translated">The first number in the &lt;code&gt;-L&lt;/code&gt; argument, 63333, is the local port number of the tunnel; it can be any unused port. (IANA reserves ports 49152 through 65535 for private use.) The name or IP address after this is the remote bind address you are connecting to, i.e., &lt;code&gt;localhost&lt;/code&gt; , which is the default. The second number, 5432, is the remote end of the tunnel, e.g., the port number your database server is using. In order to connect to the database server using this tunnel, you connect to port 63333 on the local machine:</target>
        </trans-unit>
        <trans-unit id="8e805cf56cf5d6631bb0160a0e06bad5df15b037" translate="yes" xml:space="preserve">
          <source>The first number in the &lt;code&gt;-L&lt;/code&gt; argument, 63333, is the port number of your end of the tunnel; it can be any unused port. (IANA reserves ports 49152 through 65535 for private use.) The second number, 5432, is the remote end of the tunnel: the port number your server is using. The name or IP address between the port numbers is the host with the database server you are going to connect to, as seen from the host you are logging in to, which is &lt;code&gt;foo.com&lt;/code&gt; in this example. In order to connect to the database server using this tunnel, you connect to port 63333 on the local machine:</source>
          <target state="translated">&lt;code&gt;-L&lt;/code&gt; 引数の最初の番号63333は、トンネルの終端のポート番号です。未使用のポートにすることができます。 （IANAはプライベート使用のためにポート49152から65535を予約しています。）2番目の番号5432は、トンネルのリモートエンドです。サーバーが使用しているポート番号です。ポート番号間の名前またはIPアドレスは、ログインするホスト（この例では &lt;code&gt;foo.com&lt;/code&gt; )から見て、接続するデータベースサーバーのホストです。このトンネルを使用してデータベースサーバーに接続するには、ローカルマシンのポート63333に接続します。</target>
        </trans-unit>
        <trans-unit id="3f99873fa941c47208f84d01e9069ef478e98de2" translate="yes" xml:space="preserve">
          <source>The first one worked using &lt;em&gt;row level&lt;/em&gt; processing and was implemented deep in the &lt;em&gt;executor&lt;/em&gt;. The rule system was called whenever an individual row had been accessed. This implementation was removed in 1995 when the last official release of the Berkeley Postgres project was transformed into Postgres95.</source>
          <target state="translated">最初のものは&lt;em&gt;行レベルの&lt;/em&gt;処理を使用して機能し、&lt;em&gt;エグゼキュータの&lt;/em&gt;奥深くに実装されました。ルールシステムは、個々の行がアクセスされるたびに呼び出されました。この実装は、Berkeley Postgresプロジェクトの最後の公式リリースがPostgres95に変換された1995年に削除されました。</target>
        </trans-unit>
        <trans-unit id="0fa18c39fe287e28bd5e7314fe8af5727d16d727" translate="yes" xml:space="preserve">
          <source>The first schema in the search path that exists is the default location for creating new objects. That is the reason that by default objects are created in the public schema. When objects are referenced in any other context without schema qualification (table modification, data modification, or query commands) the search path is traversed until a matching object is found. Therefore, in the default configuration, any unqualified access again can only refer to the public schema.</source>
          <target state="translated">検索パスの中で最初に存在するスキーマは、新しいオブジェクトを作成するためのデフォルトの場所です。これが、デフォルトでオブジェクトがパブリックスキーマで作成される理由です。オブジェクトがスキーマの修飾なしに他のコンテキストで参照された場合(テーブルの変更、データの変更、またはクエリコマンド)、検索パスは一致するオブジェクトが見つかるまでトラバースされます。したがって、デフォルトの構成では、修飾されていないアクセスが再びアクセスしても、パブリックスキーマのみを参照することができます。</target>
        </trans-unit>
        <trans-unit id="9f3413da7a0291a52f1a7dcc2b820079440b3c54" translate="yes" xml:space="preserve">
          <source>The first schema named in the search path is called the current schema. Aside from being the first schema searched, it is also the schema in which new tables will be created if the &lt;code&gt;CREATE TABLE&lt;/code&gt; command does not specify a schema name.</source>
          <target state="translated">検索パスで指定された最初のスキーマは、現在のスキーマと呼ばれます。最初に検索されるスキーマの他に、 &lt;code&gt;CREATE TABLE&lt;/code&gt; コマンドでスキーマ名が指定されていない場合に、新しいテーブルが作成されるスキーマでもあります。</target>
        </trans-unit>
        <trans-unit id="9d12bc7a9f0942909d34ace4bd41d7e184667d01" translate="yes" xml:space="preserve">
          <source>The first six lines report some of the most important parameter settings. The next line reports the number of transactions completed and intended (the latter being just the product of number of clients and number of transactions per client); these will be equal unless the run failed before completion. (In &lt;code&gt;-T&lt;/code&gt; mode, only the actual number of transactions is printed.) The last two lines report the number of transactions per second, figured with and without counting the time to start database sessions.</source>
          <target state="translated">最初の6行は、最も重要なパラメータ設定のいくつかを報告しています。次の行は、完了および意図されたトランザクションの数を報告します（後者は、クライアントの数とクライアントごとのトランザクションの数の積です）。完了する前に実行が失敗しない限り、これらは等しくなります。 （ &lt;code&gt;-T&lt;/code&gt; モードでは、実際のトランザクション数のみが出力されます。）最後の2行は、データベースセッションを開始する時間をカウントした場合とカウントしない場合の1秒あたりのトランザクション数を報告します。</target>
        </trans-unit>
        <trans-unit id="46861698534eb993d5363434e9d5cb2bd00b93d2" translate="yes" xml:space="preserve">
          <source>The first step is to generate an auxiliary table containing all the unique words in the documents:</source>
          <target state="translated">まず、文書に含まれるすべてのユニークな単語を含む補助テーブルを生成します。</target>
        </trans-unit>
        <trans-unit id="d440c66135f418ef7372813549a4be5ffe416b8b" translate="yes" xml:space="preserve">
          <source>The first test to see whether you can access the database server is to try to create a database. A running PostgreSQL server can manage many databases. Typically, a separate database is used for each project or for each user.</source>
          <target state="translated">データベースサーバにアクセスできるかどうかの最初のテストは、データベースを作成してみることです。実行中のPostgreSQLサーバは、多くのデータベースを管理することができます。一般的には、プロジェクトごと、あるいはユーザごとに別々のデータベースが使用されます。</target>
        </trans-unit>
        <trans-unit id="c00d09908f3f4ddbf657d8ad0f17eabf84136b00" translate="yes" xml:space="preserve">
          <source>The first three output columns come directly from the table &lt;code&gt;empsalary&lt;/code&gt;, and there is one output row for each row in the table. The fourth column represents an average taken across all the table rows that have the same &lt;code&gt;depname&lt;/code&gt; value as the current row. (This actually is the same function as the non-window &lt;code&gt;avg&lt;/code&gt; aggregate, but the &lt;code&gt;OVER&lt;/code&gt; clause causes it to be treated as a window function and computed across the window frame.)</source>
          <target state="translated">最初の3つの出力列は &lt;code&gt;empsalary&lt;/code&gt; テーブルから直接取得され、テーブルの各行に1つの出力行があります。 4番目の列は、現在の行と同じ &lt;code&gt;depname&lt;/code&gt; 値を持つすべてのテーブル行にわたって取られた平均を表します。 （これは実際には非ウィンドウの &lt;code&gt;avg&lt;/code&gt; 集計と同じ関数ですが、 &lt;code&gt;OVER&lt;/code&gt; 句を指定すると、ウィンドウ関数として扱われ、ウィンドウフレーム全体で計算されます。）</target>
        </trans-unit>
        <trans-unit id="c0413166d43e378dc8855747d05360346ec4b249" translate="yes" xml:space="preserve">
          <source>The first three parameters are inputs:</source>
          <target state="translated">最初の3つのパラメータは入力です。</target>
        </trans-unit>
        <trans-unit id="54956845c90a8b39103dc2ab8d6e4402b710d114" translate="yes" xml:space="preserve">
          <source>The first three variants change which tables are part of the publication. The &lt;code&gt;SET TABLE&lt;/code&gt; clause will replace the list of tables in the publication with the specified one. The &lt;code&gt;ADD TABLE&lt;/code&gt; and &lt;code&gt;DROP TABLE&lt;/code&gt; clauses will add and remove one or more tables from the publication. Note that adding tables to a publication that is already subscribed to will require a &lt;code&gt;ALTER SUBSCRIPTION ... REFRESH PUBLICATION&lt;/code&gt; action on the subscribing side in order to become effective.</source>
          <target state="translated">最初の3つのバリアントは、パブリケーションの一部であるテーブルを変更します。 &lt;code&gt;SET TABLE&lt;/code&gt; 句は、指定されたものとパブリケーション内のテーブルのリストを置き換えます。 &lt;code&gt;ADD TABLE&lt;/code&gt; と &lt;code&gt;DROP TABLE&lt;/code&gt; 句は、出版から1つまたは複数のテーブルを追加および削除します。既にサブスクライブされているパブリケーションにテーブルを追加するには、サブスクライブする側で &lt;code&gt;ALTER SUBSCRIPTION ... REFRESH PUBLICATION&lt;/code&gt; アクションを有効にする必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="70d5b4450dbfd9e788e4338d7701eefa6a67f05f" translate="yes" xml:space="preserve">
          <source>The first trigger argument must be the name of the &lt;code&gt;tsvector&lt;/code&gt; column to be updated. The second argument specifies the text search configuration to be used to perform the conversion. For &lt;code&gt;tsvector_update_trigger&lt;/code&gt;, the configuration name is simply given as the second trigger argument. It must be schema-qualified as shown above, so that the trigger behavior will not change with changes in &lt;code&gt;search_path&lt;/code&gt;. For &lt;code&gt;tsvector_update_trigger_column&lt;/code&gt;, the second trigger argument is the name of another table column, which must be of type &lt;code&gt;regconfig&lt;/code&gt;. This allows a per-row selection of configuration to be made. The remaining argument(s) are the names of textual columns (of type &lt;code&gt;text&lt;/code&gt;, &lt;code&gt;varchar&lt;/code&gt;, or &lt;code&gt;char&lt;/code&gt;). These will be included in the document in the order given. NULL values will be skipped (but the other columns will still be indexed).</source>
          <target state="translated">最初のトリガー引数は、更新する &lt;code&gt;tsvector&lt;/code&gt; 列の名前でなければなりません。 2番目の引数は、変換を実行するために使用されるテキスト検索構成を指定します。 &lt;code&gt;tsvector_update_trigger&lt;/code&gt; 、コンフィギュレーション名は、単純に第2のトリガ引数として指定されています。上記のようにスキーマ修飾する必要があります。これにより、 &lt;code&gt;search_path&lt;/code&gt; を変更してもトリガーの動作が変更されません。ため &lt;code&gt;tsvector_update_trigger_column&lt;/code&gt; 、第2のトリガ引数は、型のものでなければならない別のテーブルの列の名前である &lt;code&gt;regconfig&lt;/code&gt; 。これにより、構成を行ごとに選択できます。残りの引数は、テキスト列（タイプ &lt;code&gt;text&lt;/code&gt; 、 &lt;code&gt;varchar&lt;/code&gt; ）の名前です。、または &lt;code&gt;char&lt;/code&gt; ）。これらは、指定された順序でドキュメントに含まれます。NULL値はスキップされます（ただし、他の列には引き続きインデックスが付けられます）。</target>
        </trans-unit>
        <trans-unit id="01ce9912b77202e1b48ed397f2bfc3b3783947c2" translate="yes" xml:space="preserve">
          <source>The first two constraints should look familiar. The third one uses a new syntax. It is not attached to a particular column, instead it appears as a separate item in the comma-separated column list. Column definitions and these constraint definitions can be listed in mixed order.</source>
          <target state="translated">最初の2つの制約は見覚えがあるはずです。3番目の制約は新しい構文を使用しています。これは、特定の列には関連付けられず、代わりにカンマで区切られた列リストの別個の項目として表示されます。列定義とこれらの制約定義は、混在した順序でリストアップすることができます。</target>
        </trans-unit>
        <trans-unit id="2927557f90bef3d374c5198102a6e3ea28461171" translate="yes" xml:space="preserve">
          <source>The first two of these we saw already. The form &lt;code&gt;text&lt;/code&gt;&lt;code&gt;@@&lt;/code&gt;&lt;code&gt;tsquery&lt;/code&gt; is equivalent to &lt;code&gt;to_tsvector(x) @@ y&lt;/code&gt;. The form &lt;code&gt;text&lt;/code&gt;&lt;code&gt;@@&lt;/code&gt;&lt;code&gt;text&lt;/code&gt; is equivalent to &lt;code&gt;to_tsvector(x) @@ plainto_tsquery(y)&lt;/code&gt;.</source>
          <target state="translated">すでに見たこれらの最初の2つ。フォーム &lt;code&gt;text&lt;/code&gt; &lt;code&gt;@@&lt;/code&gt; &lt;code&gt;tsquery&lt;/code&gt; と等価である &lt;code&gt;to_tsvector(x) @@ y&lt;/code&gt; 。 &lt;code&gt;text&lt;/code&gt; &lt;code&gt;@@&lt;/code&gt; &lt;code&gt;text&lt;/code&gt; という形式は、 &lt;code&gt;to_tsvector(x) @@ plainto_tsquery(y)&lt;/code&gt; と同等です。</target>
        </trans-unit>
        <trans-unit id="cdaab7b9b529bcc8f6406321204002fe17ed4b88" translate="yes" xml:space="preserve">
          <source>The first two output columns are used for the current row's key and its parent row's key; they must match the type of the table's key field. The third output column is the depth in the tree and must be of type &lt;code&gt;integer&lt;/code&gt;. If a &lt;em&gt;&lt;code&gt;branch_delim&lt;/code&gt;&lt;/em&gt; parameter was given, the next output column is the branch display and must be of type &lt;code&gt;text&lt;/code&gt;. Finally, if an &lt;em&gt;&lt;code&gt;orderby_fld&lt;/code&gt;&lt;/em&gt; parameter was given, the last output column is a serial number, and must be of type &lt;code&gt;integer&lt;/code&gt;.</source>
          <target state="translated">最初の2つの出力列は、現在の行のキーとその親行のキーに使用されます。それらはテーブルのキーフィールドのタイプと一致する必要があります。 3番目の出力列はツリーの深さであり、 &lt;code&gt;integer&lt;/code&gt; 型でなければなりません。場合&lt;em&gt; &lt;code&gt;branch_delim&lt;/code&gt; &lt;/em&gt;パラメータが与えられた、次の出力列には分岐表示され、タイプのものでなければならない &lt;code&gt;text&lt;/code&gt; 。最後に、&lt;em&gt; &lt;code&gt;orderby_fld&lt;/code&gt; &lt;/em&gt;パラメーターが指定された場合、最後の出力列はシリアル番号であり、 &lt;code&gt;integer&lt;/code&gt; 型でなければなりません。</target>
        </trans-unit>
        <trans-unit id="bf7215eea980a2a0bf86f75a412a5f3cd60fbcd5" translate="yes" xml:space="preserve">
          <source>The first two variants add users to a group or remove them from a group. (Any role can play the part of either a &amp;ldquo;user&amp;rdquo; or a &amp;ldquo;group&amp;rdquo; for this purpose.) These variants are effectively equivalent to granting or revoking membership in the role named as the &amp;ldquo;group&amp;rdquo;; so the preferred way to do this is to use &lt;a href=&quot;sql-grant&quot;&gt;GRANT&lt;/a&gt; or &lt;a href=&quot;sql-revoke&quot;&gt;REVOKE&lt;/a&gt;.</source>
          <target state="translated">最初の2つのバリアントは、ユーザーをグループに追加するか、グループから削除します。 （どの役割も、この目的で「ユーザー」または「グループ」の役割を果たすことができます。）これらのバリアントは、「グループ」という名前の役割のメンバーシップを付与または取り消すことと実質的に同等です。そのため、これを行うには、&lt;a href=&quot;sql-grant&quot;&gt;GRANT&lt;/a&gt;または&lt;a href=&quot;sql-revoke&quot;&gt;REVOKE&lt;/a&gt;を使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="586ee19112a7a3ecf50504f1b0e758b680347d53" translate="yes" xml:space="preserve">
          <source>The first variant of this command listed in the synopsis can change many of the role attributes that can be specified in &lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLE&lt;/a&gt;. (All the possible attributes are covered, except that there are no options for adding or removing memberships; use &lt;a href=&quot;sql-grant&quot;&gt;GRANT&lt;/a&gt; and &lt;a href=&quot;sql-revoke&quot;&gt;REVOKE&lt;/a&gt; for that.) Attributes not mentioned in the command retain their previous settings. Database superusers can change any of these settings for any role. Roles having &lt;code&gt;CREATEROLE&lt;/code&gt; privilege can change any of these settings except &lt;code&gt;SUPERUSER&lt;/code&gt;, &lt;code&gt;REPLICATION&lt;/code&gt;, and &lt;code&gt;BYPASSRLS&lt;/code&gt;; but only for non-superuser and non-replication roles. Ordinary roles can only change their own password.</source>
          <target state="translated">The first variant of this command listed in the synopsis can change many of the role attributes that can be specified in &lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLE&lt;/a&gt;. (All the possible attributes are covered, except that there are no options for adding or removing memberships; use &lt;a href=&quot;sql-grant&quot;&gt;GRANT&lt;/a&gt; and &lt;a href=&quot;sql-revoke&quot;&gt;REVOKE&lt;/a&gt; for that.) Attributes not mentioned in the command retain their previous settings. Database superusers can change any of these settings for any role. Roles having &lt;code&gt;CREATEROLE&lt;/code&gt; privilege can change any of these settings except &lt;code&gt;SUPERUSER&lt;/code&gt; , &lt;code&gt;REPLICATION&lt;/code&gt; , and &lt;code&gt;BYPASSRLS&lt;/code&gt; ; but only for non-superuser and non-replication roles. Ordinary roles can only change their own password.</target>
        </trans-unit>
        <trans-unit id="0b5e370e58213823b4126e17f4b6e7ad4cef2b17" translate="yes" xml:space="preserve">
          <source>The first variant of this command listed in the synopsis can change many of the role attributes that can be specified in &lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLE&lt;/a&gt;. (All the possible attributes are covered, except that there are no options for adding or removing memberships; use &lt;a href=&quot;sql-grant&quot;&gt;GRANT&lt;/a&gt; and &lt;a href=&quot;sql-revoke&quot;&gt;REVOKE&lt;/a&gt; for that.) Attributes not mentioned in the command retain their previous settings. Database superusers can change any of these settings for any role. Roles having &lt;code&gt;CREATEROLE&lt;/code&gt; privilege can change any of these settings, but only for non-superuser and non-replication roles. Ordinary roles can only change their own password.</source>
          <target state="translated">概要にリストされているこのコマンドの最初のバリアントは、&lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLE&lt;/a&gt;で指定できる多くのロール属性を変更できます。 （メンバーシップを追加または削除するオプションがないことを除いて、可能なすべての属性がカバーされています。そのためには&lt;a href=&quot;sql-grant&quot;&gt;GRANT&lt;/a&gt;および&lt;a href=&quot;sql-revoke&quot;&gt;REVOKE&lt;/a&gt;を使用してください。）コマンドで言及されていない属性は以前の設定を保持します。データベースのスーパーユーザーは、任意のロールのこれらの設定を変更できます。 &lt;code&gt;CREATEROLE&lt;/code&gt; 特権を持つロールは、これらの設定のいずれかを変更できますが、非スーパーユーザーおよび非レプリケーションロールに対してのみです。通常のロールは、自分のパスワードのみを変更できます。</target>
        </trans-unit>
        <trans-unit id="25ae6ee44a0f0d836e1704c794f00aceb8d356c4" translate="yes" xml:space="preserve">
          <source>The five mandatory user-defined methods are:</source>
          <target state="translated">必須のユーザー定義メソッドは以下の5つです。</target>
        </trans-unit>
        <trans-unit id="72ce333d0c25ef1597b4fa8ad61ed91fb435220e" translate="yes" xml:space="preserve">
          <source>The following &amp;ldquo;parameters&amp;rdquo; are read-only, and are determined when PostgreSQL is compiled or when it is installed. As such, they have been excluded from the sample &lt;code&gt;postgresql.conf&lt;/code&gt; file. These options report various aspects of PostgreSQL behavior that might be of interest to certain applications, particularly administrative front-ends.</source>
          <target state="translated">次の「パラメータ」は読み取り専用であり、PostgreSQLのコンパイル時またはインストール時に決定されます。そのため、サンプルの &lt;code&gt;postgresql.conf&lt;/code&gt; ファイルから除外されています。これらのオプションは、特定のアプリケーション、特に管理フロントエンドに関係する可能性があるPostgreSQLの動作のさまざまな側面を報告します。</target>
        </trans-unit>
        <trans-unit id="a28614c3e8ef3dfbb002911a23857ed9cadcc2f2" translate="yes" xml:space="preserve">
          <source>The following &lt;code&gt;method&lt;/code&gt;s for collecting the write-ahead logs are supported:</source>
          <target state="translated">The following &lt;code&gt;method&lt;/code&gt; s for collecting the write-ahead logs are supported:</target>
        </trans-unit>
        <trans-unit id="771558088b2464a0c70d76532be21bcb4ca8194b" translate="yes" xml:space="preserve">
          <source>The following SQL-compatible functions can also be used to obtain the current time value for the corresponding data type: &lt;code&gt;CURRENT_DATE&lt;/code&gt;, &lt;code&gt;CURRENT_TIME&lt;/code&gt;, &lt;code&gt;CURRENT_TIMESTAMP&lt;/code&gt;, &lt;code&gt;LOCALTIME&lt;/code&gt;, &lt;code&gt;LOCALTIMESTAMP&lt;/code&gt;. (See &lt;a href=&quot;functions-datetime#FUNCTIONS-DATETIME-CURRENT&quot;&gt;Section 9.9.4&lt;/a&gt;.) Note that these are SQL functions and are &lt;em&gt;not&lt;/em&gt; recognized in data input strings.</source>
          <target state="translated">The following SQL-compatible functions can also be used to obtain the current time value for the corresponding data type: &lt;code&gt;CURRENT_DATE&lt;/code&gt; , &lt;code&gt;CURRENT_TIME&lt;/code&gt; , &lt;code&gt;CURRENT_TIMESTAMP&lt;/code&gt; , &lt;code&gt;LOCALTIME&lt;/code&gt; , &lt;code&gt;LOCALTIMESTAMP&lt;/code&gt; . (See &lt;a href=&quot;functions-datetime#FUNCTIONS-DATETIME-CURRENT&quot;&gt;Section 9.9.4&lt;/a&gt;.) Note that these are SQL functions and are &lt;em&gt;not&lt;/em&gt; recognized in data input strings.</target>
        </trans-unit>
        <trans-unit id="f94e73cd2b87aba8e9913a22c540c941db79c62c" translate="yes" xml:space="preserve">
          <source>The following SQL-compatible functions can also be used to obtain the current time value for the corresponding data type: &lt;code&gt;CURRENT_DATE&lt;/code&gt;, &lt;code&gt;CURRENT_TIME&lt;/code&gt;, &lt;code&gt;CURRENT_TIMESTAMP&lt;/code&gt;, &lt;code&gt;LOCALTIME&lt;/code&gt;, &lt;code&gt;LOCALTIMESTAMP&lt;/code&gt;. The latter four accept an optional subsecond precision specification. (See &lt;a href=&quot;functions-datetime#FUNCTIONS-DATETIME-CURRENT&quot;&gt;Section 9.9.4&lt;/a&gt;.) Note that these are SQL functions and are &lt;em&gt;not&lt;/em&gt; recognized in data input strings.</source>
          <target state="translated">次のSQL互換関数を使用して、対応するデータ型の現在の時刻値を取得することもできます： &lt;code&gt;CURRENT_DATE&lt;/code&gt; 、 &lt;code&gt;CURRENT_TIME&lt;/code&gt; 、 &lt;code&gt;CURRENT_TIMESTAMP&lt;/code&gt; 、 &lt;code&gt;LOCALTIME&lt;/code&gt; 、 &lt;code&gt;LOCALTIMESTAMP&lt;/code&gt; 。後者の4つは、オプションのサブ秒精度指定を受け入れます。（&lt;a href=&quot;functions-datetime#FUNCTIONS-DATETIME-CURRENT&quot;&gt;項9.9.4を&lt;/a&gt;参照してください。）これらはSQL関数であり、データ入力文字列で&lt;em&gt;は&lt;/em&gt;認識され&lt;em&gt;ない&lt;/em&gt;ことに注意してください。</target>
        </trans-unit>
        <trans-unit id="7345097a3373ddd38c8dbf7f484bcb7a83adcfc5" translate="yes" xml:space="preserve">
          <source>The following SQL-standard functions work on bit strings as well as character strings: &lt;code&gt;length&lt;/code&gt;, &lt;code&gt;bit_length&lt;/code&gt;, &lt;code&gt;octet_length&lt;/code&gt;, &lt;code&gt;position&lt;/code&gt;, &lt;code&gt;substring&lt;/code&gt;, &lt;code&gt;overlay&lt;/code&gt;.</source>
          <target state="translated">次のSQL標準関数は、文字列だけでなくビット文字列でも機能します： &lt;code&gt;length&lt;/code&gt; 、 &lt;code&gt;bit_length&lt;/code&gt; 、 &lt;code&gt;octet_length&lt;/code&gt; 、 &lt;code&gt;position&lt;/code&gt; 、 &lt;code&gt;substring&lt;/code&gt; 、 &lt;code&gt;overlay&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9bd2c2e8eaa4afd48046645ba794fcbca53b28f4" translate="yes" xml:space="preserve">
          <source>The following additional options are available:</source>
          <target state="translated">以下の追加オプションをご用意しております。</target>
        </trans-unit>
        <trans-unit id="0f218f3efdde351da4f071874c06c4afe80e209d" translate="yes" xml:space="preserve">
          <source>The following are all valid &lt;code&gt;json&lt;/code&gt; (or &lt;code&gt;jsonb&lt;/code&gt;) expressions:</source>
          <target state="translated">以下はすべて有効な &lt;code&gt;json&lt;/code&gt; （または &lt;code&gt;jsonb&lt;/code&gt; ）式です。</target>
        </trans-unit>
        <trans-unit id="c039bfa9f08ddfc0a59acd61d84cddcf4b0d6ac9" translate="yes" xml:space="preserve">
          <source>The following caveats apply to constraint exclusion:</source>
          <target state="translated">制約の除外には、以下の注意事項が適用されます。</target>
        </trans-unit>
        <trans-unit id="ed89af6d7b571e68348aa46975289d8d36b6f9e9" translate="yes" xml:space="preserve">
          <source>The following caveats apply to partitioning implemented using inheritance:</source>
          <target state="translated">継承を用いて実装されたパーティショニングには、以下の注意事項が適用されます。</target>
        </trans-unit>
        <trans-unit id="29e533c6b217bf172992ac716839050a2d3fd0b7" translate="yes" xml:space="preserve">
          <source>The following command can be used to create an index on the &lt;code&gt;id&lt;/code&gt; column, as discussed:</source>
          <target state="translated">説明したように、次のコマンドを使用して &lt;code&gt;id&lt;/code&gt; 列にインデックスを作成できます。</target>
        </trans-unit>
        <trans-unit id="4545d07872378e0f1220b619c3281f607f171dfb" translate="yes" xml:space="preserve">
          <source>The following command defines a new operator, area-equality, for the data type &lt;code&gt;box&lt;/code&gt;:</source>
          <target state="translated">次のコマンドは、データ型 &lt;code&gt;box&lt;/code&gt; に新しい演算子area-equalityを定義します。</target>
        </trans-unit>
        <trans-unit id="55cc91b2b085f350c73a66cbdf6d3a5a0c4fb379" translate="yes" xml:space="preserve">
          <source>The following command-line options are available:</source>
          <target state="translated">以下のコマンドラインオプションが利用できます。</target>
        </trans-unit>
        <trans-unit id="7065caab547161a186d449fdb20fb545416a7f46" translate="yes" xml:space="preserve">
          <source>The following command-line options control the connection to the source server:</source>
          <target state="translated">以下のコマンドラインオプションは、ソースサーバへの接続を制御します。</target>
        </trans-unit>
        <trans-unit id="8b5ca5337b558c5af015478dbbd74c89d07107d2" translate="yes" xml:space="preserve">
          <source>The following command-line options control the content and format of the output.</source>
          <target state="translated">以下のコマンドラインオプションは、出力の内容と形式を制御します。</target>
        </trans-unit>
        <trans-unit id="05475cf2eec87e97d8772a07ec18d9fdca7b5435" translate="yes" xml:space="preserve">
          <source>The following command-line options control the database connection parameters.</source>
          <target state="translated">以下のコマンドラインオプションは、データベース接続パラメータを制御します。</target>
        </trans-unit>
        <trans-unit id="3d113b81b40bdffb0cde200d7b3c4f6a86ddbb52" translate="yes" xml:space="preserve">
          <source>The following command-line options control the generation of the backup and the invocation of the program:</source>
          <target state="translated">以下のコマンドラインオプションは、バックアップの生成とプログラムの起動を制御します。</target>
        </trans-unit>
        <trans-unit id="220365fea8f99014f431d00f0ea052b58e2c1fcb" translate="yes" xml:space="preserve">
          <source>The following command-line options control the generation of the backup and the running of the program.</source>
          <target state="translated">以下のコマンドラインオプションは、バックアップの生成とプログラムの実行を制御します。</target>
        </trans-unit>
        <trans-unit id="a56b05f8e623fa43fb5bc9f1eeba6d4c3440d581" translate="yes" xml:space="preserve">
          <source>The following command-line options control the location and format of the output and other replication behavior:</source>
          <target state="translated">以下のコマンドラインオプションは、出力の場所とフォーマット、およびその他のレプリケーション動作を制御します。</target>
        </trans-unit>
        <trans-unit id="f449555e10b2046b1ccc209c3ef5b6dce0f90612" translate="yes" xml:space="preserve">
          <source>The following command-line options control the location and format of the output.</source>
          <target state="translated">以下のコマンドラインオプションは、出力の場所と形式を制御します。</target>
        </trans-unit>
        <trans-unit id="00a034b5b9d901cf6c0ba2052c558173c4b654b2" translate="yes" xml:space="preserve">
          <source>The following command-line options control the location and format of the output:</source>
          <target state="translated">以下のコマンドラインオプションは、出力の場所と形式を制御します。</target>
        </trans-unit>
        <trans-unit id="b90c14e70ab12e4fce9bec3bf939f8e3cd367938" translate="yes" xml:space="preserve">
          <source>The following configuration options are supported for GSSAPI:</source>
          <target state="translated">GSSAPIでは以下の設定オプションがサポートされています。</target>
        </trans-unit>
        <trans-unit id="46edfe1841a44936730cc915774b2516fbe1a78a" translate="yes" xml:space="preserve">
          <source>The following configuration options are supported for PAM:</source>
          <target state="translated">PAM では以下の設定オプションがサポートされています。</target>
        </trans-unit>
        <trans-unit id="514923f06896538a2f8d0943aa9139974686a363" translate="yes" xml:space="preserve">
          <source>The following configuration options are supported for RADIUS:</source>
          <target state="translated">RADIUSでは、以下の構成オプションがサポートされています。</target>
        </trans-unit>
        <trans-unit id="acf0b28821a566799fd52288a31f3e25a128c408" translate="yes" xml:space="preserve">
          <source>The following configuration options are supported for SSL certificate authentication:</source>
          <target state="translated">SSL 証明書認証では、以下の設定オプションがサポートされています。</target>
        </trans-unit>
        <trans-unit id="bad3bae7c6cb5e9156e0aafc4f4c4d5aa18bfd10" translate="yes" xml:space="preserve">
          <source>The following configuration options are supported for SSPI:</source>
          <target state="translated">以下の設定オプションは、SSPI でサポートされています。</target>
        </trans-unit>
        <trans-unit id="be704faf73a86cf08decb39d5cfdd09dedabb81b" translate="yes" xml:space="preserve">
          <source>The following configuration options are supported for ident:</source>
          <target state="translated">ident には以下の設定オプションがサポートされています。</target>
        </trans-unit>
        <trans-unit id="7fd3b16b14e5df4be73c034d0d0a8f2f793213cc" translate="yes" xml:space="preserve">
          <source>The following configuration options are supported for peer:</source>
          <target state="translated">ピアでは、以下の構成オプションがサポートされています。</target>
        </trans-unit>
        <trans-unit id="b2cc6138e97e8a814646a47d2cd6ecdb0c1d8d16" translate="yes" xml:space="preserve">
          <source>The following configuration options are used in both modes:</source>
          <target state="translated">どちらのモードでも、以下の設定オプションを使用します。</target>
        </trans-unit>
        <trans-unit id="82ae133d649ffad972068d98ba1e0a950ea94086" translate="yes" xml:space="preserve">
          <source>The following containment predicate uses the point syntax, while in fact the second argument is internally represented by a box. This syntax makes it unnecessary to define a separate point type and functions for (box,point) predicates.</source>
          <target state="translated">次の包含述語はポイント構文を使用していますが、実際には第 2 引数は内部的にボックスで表現されています。この構文により、(box,point)述語のために別個のポイント型や関数を定義する必要がありません。</target>
        </trans-unit>
        <trans-unit id="ab1f58c5086fb9d7dbb2dff29ebf934fc1fd38a7" translate="yes" xml:space="preserve">
          <source>The following example command &amp;ldquo;updates&amp;rdquo; the dictionary's definition without actually changing anything.</source>
          <target state="translated">次のコマンド例は、実際には何も変更せずに辞書の定義を「更新」します。</target>
        </trans-unit>
        <trans-unit id="5f20cbbdfc0e4abc07d317b7cde01bad2e3188ac" translate="yes" xml:space="preserve">
          <source>The following example command adds cross-data-type operators and support functions to an operator family that already contains B-tree operator classes for data types &lt;code&gt;int4&lt;/code&gt; and &lt;code&gt;int2&lt;/code&gt;.</source>
          <target state="translated">次のコマンド例は、データ型 &lt;code&gt;int4&lt;/code&gt; および &lt;code&gt;int2&lt;/code&gt; の Bツリー演算子クラスが既に含まれている演算子族に、データ型間演算子とサポート関数を追加します。</target>
        </trans-unit>
        <trans-unit id="98ce952daa9dd539b9ae5ea67f8fc03311bc7883" translate="yes" xml:space="preserve">
          <source>The following example command changes the language option to &lt;code&gt;dutch&lt;/code&gt;, and removes the stopword option entirely.</source>
          <target state="translated">次のコマンド例は、言語オプションを &lt;code&gt;dutch&lt;/code&gt; に変更し、ストップワードオプションを完全に削除します。</target>
        </trans-unit>
        <trans-unit id="0690fd36226cece879c24f85e0b2a34e7740cb2a" translate="yes" xml:space="preserve">
          <source>The following example command changes the stopword list for a Snowball-based dictionary. Other parameters remain unchanged.</source>
          <target state="translated">次の例のコマンドは、Snowball ベースの辞書のストップワードリストを変更します。他のパラメータは変更されません。</target>
        </trans-unit>
        <trans-unit id="c6c6101649b45994a81cc07611f7c341ccfd2d4d" translate="yes" xml:space="preserve">
          <source>The following example command creates a Snowball-based dictionary with a nonstandard list of stop words.</source>
          <target state="translated">以下の例のコマンドは、標準ではない停止語のリストを持つスノーボールベースの辞書を作成します。</target>
        </trans-unit>
        <trans-unit id="0540cfecb071eb102ec89874893aeae6b2dac906" translate="yes" xml:space="preserve">
          <source>The following example command defines a GiST index operator class for the data type &lt;code&gt;_int4&lt;/code&gt; (array of &lt;code&gt;int4&lt;/code&gt;). See the &lt;a href=&quot;intarray&quot;&gt;intarray&lt;/a&gt; module for the complete example.</source>
          <target state="translated">次のコマンド例は、データ型のためのGiSTインデックス演算子クラスを定義 &lt;code&gt;_int4&lt;/code&gt; （配列 &lt;code&gt;int4&lt;/code&gt; ）。完全な例については、&lt;a href=&quot;intarray&quot;&gt;intarray&lt;/a&gt;モジュールを参照してください。</target>
        </trans-unit>
        <trans-unit id="ef3a1ce4208d975ebd37d2a046e1777755826724" translate="yes" xml:space="preserve">
          <source>The following example copies a table to the client using the vertical bar (&lt;code&gt;|&lt;/code&gt;) as the field delimiter:</source>
          <target state="translated">次の例では、フィールド区切り文字として縦棒（ &lt;code&gt;|&lt;/code&gt; ）を使用して、クライアントにテーブルをコピーします。</target>
        </trans-unit>
        <trans-unit id="0d013459769f3027ad75584e21efea2204848877" translate="yes" xml:space="preserve">
          <source>The following example illustrates how the &lt;code&gt;XMLNAMESPACES&lt;/code&gt; clause can be used to specify a list of namespaces used in the XML document as well as in the XPath expressions:</source>
          <target state="translated">次の例は、 &lt;code&gt;XMLNAMESPACES&lt;/code&gt; 句を使用して、XMLドキュメントとXPath式で使用される名前空間のリストを指定する方法を示しています。</target>
        </trans-unit>
        <trans-unit id="8120020f967b896e9eb5f42600de6773abdc4c59" translate="yes" xml:space="preserve">
          <source>The following example puts the final account balance from the first query into variable &lt;code&gt;abalance&lt;/code&gt;, and fills variables &lt;code&gt;p_two&lt;/code&gt; and &lt;code&gt;p_three&lt;/code&gt; with integers from the third query. The result of the second query is discarded.</source>
          <target state="translated">次の例では、変数に最初のクエリからの最終的な勘定残高入れ &lt;code&gt;abalance&lt;/code&gt; を、変数がいっぱい &lt;code&gt;p_two&lt;/code&gt; と &lt;code&gt;p_three&lt;/code&gt; 第クエリから整数で。2番目のクエリの結果は破棄されます。</target>
        </trans-unit>
        <trans-unit id="550fb6dd31ce5c45513c6afc9762a8e612652741" translate="yes" xml:space="preserve">
          <source>The following example puts the final account balance from the first query into variable &lt;code&gt;abalance&lt;/code&gt;, and fills variables &lt;code&gt;p_two&lt;/code&gt; and &lt;code&gt;p_three&lt;/code&gt; with integers from the third query. The result of the second query is discarded. The result of the two last combined queries are stored in variables &lt;code&gt;four&lt;/code&gt; and &lt;code&gt;five&lt;/code&gt;.</source>
          <target state="translated">The following example puts the final account balance from the first query into variable &lt;code&gt;abalance&lt;/code&gt; , and fills variables &lt;code&gt;p_two&lt;/code&gt; and &lt;code&gt;p_three&lt;/code&gt; with integers from the third query. The result of the second query is discarded. The result of the two last combined queries are stored in variables &lt;code&gt;four&lt;/code&gt; and &lt;code&gt;five&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4e0272043332c15e45fca8627b9940585ab0ce4a" translate="yes" xml:space="preserve">
          <source>The following example replaces the &lt;code&gt;english&lt;/code&gt; dictionary with the &lt;code&gt;swedish&lt;/code&gt; dictionary anywhere that &lt;code&gt;english&lt;/code&gt; is used within &lt;code&gt;my_config&lt;/code&gt;.</source>
          <target state="translated">次の例では、 &lt;code&gt;english&lt;/code&gt; 辞書を、 &lt;code&gt;my_config&lt;/code&gt; 内で &lt;code&gt;english&lt;/code&gt; が使用されている &lt;code&gt;swedish&lt;/code&gt; 辞書に置き換えます。</target>
        </trans-unit>
        <trans-unit id="a86c39babfe81954fe9ebb108b217aea8248e655" translate="yes" xml:space="preserve">
          <source>The following example shows concatenation of multiple text() nodes, usage of the column name as XPath filter, and the treatment of whitespace, XML comments and processing instructions:</source>
          <target state="translated">次の例は、複数の text()ノードの連結、XPath フィルタとしてのカラム名の使用、空白の処理、XML コメント、処理命令を示しています。</target>
        </trans-unit>
        <trans-unit id="54642b031a2227e507d5a953bc0c97aa2f10ca2d" translate="yes" xml:space="preserve">
          <source>The following example shows how the security label of a table might be changed.</source>
          <target state="translated">次の例では、テーブルのセキュリティラベルを変更する方法を示しています。</target>
        </trans-unit>
        <trans-unit id="b9d0858a7dd21e2c17fd7d8938ac8b2bda33b78f" translate="yes" xml:space="preserve">
          <source>The following example shows the result of estimating a &lt;code&gt;WHERE&lt;/code&gt; condition on the &lt;code&gt;a&lt;/code&gt; column:</source>
          <target state="translated">次の例は、 &lt;code&gt;a&lt;/code&gt; 列の &lt;code&gt;WHERE&lt;/code&gt; 条件を推定した結果を示しています。</target>
        </trans-unit>
        <trans-unit id="04036b5b20e932a63bf10913615aab08c6e7f9bb" translate="yes" xml:space="preserve">
          <source>The following example traverses a table using a cursor:</source>
          <target state="translated">次の例は、カーソルを使用してテーブルをトラバースします。</target>
        </trans-unit>
        <trans-unit id="b0c8644502b27c5f09c1b2cd46083c907b3859da" translate="yes" xml:space="preserve">
          <source>The following examples will illustrate the usage of all three notations, using the following function definition:</source>
          <target state="translated">以下の例では、以下の関数定義を使用して、3つの表記法すべての使用法を説明します。</target>
        </trans-unit>
        <trans-unit id="ddc2a5eced86eee0d88b99c3c79c239f1015ae7c" translate="yes" xml:space="preserve">
          <source>The following functions allow direct testing of a text search parser.</source>
          <target state="translated">以下の関数では、テキスト検索パーサを直接テストすることができます。</target>
        </trans-unit>
        <trans-unit id="5e0070eaa8f2988c475085144814bd098c68e7d6" translate="yes" xml:space="preserve">
          <source>The following functions are available if libxslt is installed:</source>
          <target state="translated">libxslt がインストールされている場合、以下の機能が利用できます。</target>
        </trans-unit>
        <trans-unit id="6868f6a5c512b545d6b54882e8a5b465e4040e96" translate="yes" xml:space="preserve">
          <source>The following functions are available to delay execution of the server process:</source>
          <target state="translated">サーバプロセスの実行を遅らせるために、以下の機能を利用できます。</target>
        </trans-unit>
        <trans-unit id="7eaa7ab3c8107e57a840871a19a9fd7639ac2e60" translate="yes" xml:space="preserve">
          <source>The following functions map the contents of relational tables to XML values. They can be thought of as XML export functionality:</source>
          <target state="translated">以下の関数は、リレーショナルテーブルの内容をXML値にマッピングします。これらはXMLエクスポート機能と考えることができます。</target>
        </trans-unit>
        <trans-unit id="d99534b0054b1dbaf525bfa83dffbf3dceb4ed5a" translate="yes" xml:space="preserve">
          <source>The following functions produce XML data mappings and the corresponding XML Schema in one document (or forest), linked together. They can be useful where self-contained and self-describing results are wanted:</source>
          <target state="translated">以下の関数は、XMLデータのマッピングとそれに対応するXMLスキーマを、1つのドキュメント(あるいはフォレスト)の中にまとめてリンクしたものです。これらの関数は、自己完結型で自己記述的な結果が必要な場合に便利です。</target>
        </trans-unit>
        <trans-unit id="0717a340e1889a17503b962f24442ac075bb61f2" translate="yes" xml:space="preserve">
          <source>The following functions return XML Schema documents describing the mappings performed by the corresponding functions above:</source>
          <target state="translated">以下の関数は、上記の対応する関数によって実行されるマッピングを記述したXMLスキーマ文書を返す。</target>
        </trans-unit>
        <trans-unit id="87e9cfe2ae99c540eae639b3c0d4e7139991c05c" translate="yes" xml:space="preserve">
          <source>The following functions work on bit strings as well as binary strings: &lt;code&gt;get_bit&lt;/code&gt;, &lt;code&gt;set_bit&lt;/code&gt;. When working with a bit string, these functions number the first (leftmost) bit of the string as bit 0.</source>
          <target state="translated">次の関数は、ビット文字列とバイナリ文字列で機能します： &lt;code&gt;get_bit&lt;/code&gt; 、 &lt;code&gt;set_bit&lt;/code&gt; 。ビット文字列を処理する場合、これらの関数は文字列の最初（左端）のビットをビット0として番号付けします。</target>
        </trans-unit>
        <trans-unit id="f8888d531981405af8909029406e91231d32e3fc" translate="yes" xml:space="preserve">
          <source>The following is an equivalent way of accomplishing the same result:</source>
          <target state="translated">以下は、同じ結果を達成するための同等の方法です。</target>
        </trans-unit>
        <trans-unit id="f5156ec918109db1c50b00eba83d4a25d3045435" translate="yes" xml:space="preserve">
          <source>The following is divided into three subsections. Different options are used during database initialization and while running benchmarks, but some options are useful in both cases.</source>
          <target state="translated">以下、3つのサブセクションに分けて説明します。データベースの初期化中とベンチマーク実行中では異なるオプションが使用されますが、どちらの場合でも有用なオプションがあります。</target>
        </trans-unit>
        <trans-unit id="647af377018af1687ed8efb04b9618837aa7790d" translate="yes" xml:space="preserve">
          <source>The following is the same data, output in binary format. The data is shown after filtering through the Unix utility &lt;code&gt;od -c&lt;/code&gt;. The table has three columns; the first has type &lt;code&gt;char(2)&lt;/code&gt;, the second has type &lt;code&gt;text&lt;/code&gt;, and the third has type &lt;code&gt;integer&lt;/code&gt;. All the rows have a null value in the third column.</source>
          <target state="translated">以下は同じデータで、バイナリ形式で出力されます。データは、Unixユーティリティ &lt;code&gt;od -c&lt;/code&gt; でフィルタリングした後に表示されます。テーブルには3つの列があります。最初の型は &lt;code&gt;char(2)&lt;/code&gt; 型、2番目の型は &lt;code&gt;text&lt;/code&gt; 型、3番目の型は &lt;code&gt;integer&lt;/code&gt; 型です。すべての行の3列目にnull値があります。</target>
        </trans-unit>
        <trans-unit id="c1be0628b6cf705e05d346385bba0020aac7aea8" translate="yes" xml:space="preserve">
          <source>The following keys are currently in use:</source>
          <target state="translated">現在、以下のキーが使用されています。</target>
        </trans-unit>
        <trans-unit id="eda35f89f366a92b9c1f3ee20bc9ca7f81e63cc1" translate="yes" xml:space="preserve">
          <source>The following less trivial example writes the Russian word &amp;ldquo;slon&amp;rdquo; (elephant) in Cyrillic letters:</source>
          <target state="translated">次の簡単な例では、ロシア語の「slon」（象）をキリル文字で表記しています。</target>
        </trans-unit>
        <trans-unit id="189e345b5ef4ff87c793abeb8737dfccbc0f04c1" translate="yes" xml:space="preserve">
          <source>The following limitations apply to partitioned tables:</source>
          <target state="translated">パーティショニングされたテーブルには、以下の制限が適用されます。</target>
        </trans-unit>
        <trans-unit id="44e788f5edc12a91d7e7f317a229ad70f5f2729c" translate="yes" xml:space="preserve">
          <source>The following meta-commands are defined:</source>
          <target state="translated">以下のメタコマンドが定義されています。</target>
        </trans-unit>
        <trans-unit id="cd608061d746b035415cdac00c81458451b62316" translate="yes" xml:space="preserve">
          <source>The following methods for collecting the write-ahead logs are supported:</source>
          <target state="translated">書込ログの収集方法は、以下の方法がサポートされています。</target>
        </trans-unit>
        <trans-unit id="a56049877daf2d04bdadddbc86e9035f590ef7d4" translate="yes" xml:space="preserve">
          <source>The following non-standard approach used to be recommended in previous versions, and may still be useful in specific cases:</source>
          <target state="translated">以前のバージョンでは、以下のような非標準的なアプローチが推奨されていましたが、特定のケースではまだ有用な場合があります。</target>
        </trans-unit>
        <trans-unit id="8a441d0a9d0ce26e47c5d9596d3d57e320cb00a5" translate="yes" xml:space="preserve">
          <source>The following operations are always parallel restricted.</source>
          <target state="translated">以下の操作は常に並列制限されています。</target>
        </trans-unit>
        <trans-unit id="0e406b45cfda5d02b89a1154761a86fa7316f577" translate="yes" xml:space="preserve">
          <source>The following operations are always parallel restricted:</source>
          <target state="translated">以下の操作は常に並列制限されています。</target>
        </trans-unit>
        <trans-unit id="51e78db2119a951e7a8c9fc8a972d223a3355886" translate="yes" xml:space="preserve">
          <source>The following options are only needed when &lt;code&gt;pg_resetwal&lt;/code&gt; is unable to determine appropriate values by reading &lt;code&gt;pg_control&lt;/code&gt;. Safe values can be determined as described below. For values that take numeric arguments, hexadecimal values can be specified by using the prefix &lt;code&gt;0x&lt;/code&gt;.</source>
          <target state="translated">以下のオプションは、 &lt;code&gt;pg_resetwal&lt;/code&gt; が &lt;code&gt;pg_control&lt;/code&gt; を読み取って適切な値を決定できない場合にのみ必要です。安全値は、以下のように決定できます。数値引数を取る値の場合、プレフィックス &lt;code&gt;0x&lt;/code&gt; を使用して16進値を指定できます。</target>
        </trans-unit>
        <trans-unit id="69bed63b9b9fa472f1bfef341fe738b22ca2d102" translate="yes" xml:space="preserve">
          <source>The following options are used in search+bind mode only:</source>
          <target state="translated">以下のオプションは、検索+バインドモードでのみ使用されます。</target>
        </trans-unit>
        <trans-unit id="a727fc2f66779d9648449bd2ed769b9bf5969532" translate="yes" xml:space="preserve">
          <source>The following options are used in simple bind mode only:</source>
          <target state="translated">以下のオプションは、シンプルバインドモードでのみ使用されます。</target>
        </trans-unit>
        <trans-unit id="537f6640d02bb24a88ec9d9b40defc6c0eca02e5" translate="yes" xml:space="preserve">
          <source>The following options further specify the recovery target, and affect what happens when the target is reached:</source>
          <target state="translated">以下のオプションは、回復目標をさらに指定し、目標に到達したときに何が起こるかに影響を与えます。</target>
        </trans-unit>
        <trans-unit id="b33280ef9e0c134ead04314d2e16bd6297d099cc" translate="yes" xml:space="preserve">
          <source>The following options only apply to the single-user mode (see &lt;a href=&quot;app-postgres#APP-POSTGRES-SINGLE-USER&quot;&gt;Single-User Mode&lt;/a&gt; below).</source>
          <target state="translated">The following options only apply to the single-user mode (see &lt;a href=&quot;app-postgres#APP-POSTGRES-SINGLE-USER&quot;&gt;Single-User Mode&lt;/a&gt; below).</target>
        </trans-unit>
        <trans-unit id="7135a7643cb1d0d74cb2e4a970ae91d9faed5be8" translate="yes" xml:space="preserve">
          <source>The following options only apply to the single-user mode (see &lt;a href=&quot;app-postgres#APP-POSTGRES-SINGLE-USER&quot;&gt;Single-User Mode&lt;/a&gt;).</source>
          <target state="translated">次のオプションは、シングルユーザーモードにのみ適用されます（&lt;a href=&quot;app-postgres#APP-POSTGRES-SINGLE-USER&quot;&gt;シングルユーザーモードを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="4e806d19c35f4be356192bcaf56df7bac7d67cbd" translate="yes" xml:space="preserve">
          <source>The following parameters are intended for work on the PostgreSQL source code, and in some cases to assist with recovery of severely damaged databases. There should be no reason to use them on a production database. As such, they have been excluded from the sample &lt;code&gt;postgresql.conf&lt;/code&gt; file. Note that many of these parameters require special source compilation flags to work at all.</source>
          <target state="translated">以下のパラメーターは、PostgreSQLソースコードでの作業、および場合によっては、深刻な損傷を受けたデータベースの復旧を支援することを目的としています。本番データベースで使用する理由はありません。そのため、サンプルの &lt;code&gt;postgresql.conf&lt;/code&gt; ファイルから除外されています。これらのパラメータの多くが機能するには、特別なソースコンパイルフラグが必要です。</target>
        </trans-unit>
        <trans-unit id="4026e02031547a37479fb9b05f84b97775d5fe92" translate="yes" xml:space="preserve">
          <source>The following query can be used to identify all collations in the current database that need to be refreshed and the objects that depend on them:</source>
          <target state="translated">以下のクエリを使用して、現在のデータベース内でリフレッシュが必要な照合順序と、それに依存するオブジェクトをすべて特定することができます。</target>
        </trans-unit>
        <trans-unit id="c0122a37523d76103f38f449cd343e0b060ab0d9" translate="yes" xml:space="preserve">
          <source>The following query shows all defined operator classes:</source>
          <target state="translated">次のクエリは、定義されたすべての演算子クラスを表示します。</target>
        </trans-unit>
        <trans-unit id="8cfe858c80303e50296d8f2a37810c84b510900d" translate="yes" xml:space="preserve">
          <source>The following resources contain additional information about genetic algorithms:</source>
          <target state="translated">以下のリソースには、遺伝的アルゴリズムに関する追加情報が含まれています。</target>
        </trans-unit>
        <trans-unit id="66737f1e0a66b3e5bd4174eda08630ddc7c2985c" translate="yes" xml:space="preserve">
          <source>The following sections describe each of these authentication methods in more detail.</source>
          <target state="translated">以下では、それぞれの認証方法について詳しく説明します。</target>
        </trans-unit>
        <trans-unit id="327c23aaa47c9cad7b97d5d2a03e766b6d51df50" translate="yes" xml:space="preserve">
          <source>The following sections describe the authentication methods in more detail.</source>
          <target state="translated">以下では、認証方法について詳しく説明します。</target>
        </trans-unit>
        <trans-unit id="aeb4c79f6ac510d43001882e836e62ac542ea4a4" translate="yes" xml:space="preserve">
          <source>The following sections describe the details of the select list, the table expression, and the sort specification. &lt;code&gt;WITH&lt;/code&gt; queries are treated last since they are an advanced feature.</source>
          <target state="translated">次のセクションでは、選択リスト、テーブル式、およびソート仕様の詳細について説明します。 &lt;code&gt;WITH&lt;/code&gt; クエリは高度な機能であるため、最後に処理されます。</target>
        </trans-unit>
        <trans-unit id="9d4ca436eba9354db1bd47061237b54b62f2b67c" translate="yes" xml:space="preserve">
          <source>The following special backslash sequences are recognized by &lt;code&gt;COPY FROM&lt;/code&gt;:</source>
          <target state="translated">次の特殊なバックスラッシュシーケンスは &lt;code&gt;COPY FROM&lt;/code&gt; によって認識されます。</target>
        </trans-unit>
        <trans-unit id="8f427c4f9638a34d3033435ec6c0132981a12871" translate="yes" xml:space="preserve">
          <source>The following steps occur in a concurrent reindex. Each step is run in a separate transaction. If there are multiple indexes to be rebuilt, then each step loops through all the indexes before moving to the next step.</source>
          <target state="translated">以下のステップは、同時再インデックスで発生します。各ステップは個別のトランザクションで実行されます。再構築するインデックスが複数ある場合、各ステップは次のステップに移る前にすべてのインデックスをループします。</target>
        </trans-unit>
        <trans-unit id="e32c87e22cead595c4cbd93a657097e6823f09e3" translate="yes" xml:space="preserve">
          <source>The following subsections describe the kinds of extended statistics that are currently supported.</source>
          <target state="translated">以下のサブセクションでは、現在サポートされている拡張統計の種類について説明します。</target>
        </trans-unit>
        <trans-unit id="542557b3d5f6134bfa542b4b0f72c63ee404d9ac" translate="yes" xml:space="preserve">
          <source>The following syntax was used before PostgreSQL version 7.3 and is still supported:</source>
          <target state="translated">以下の構文はPostgreSQLバージョン7.3以前に使用されていたもので、現在もサポートされています。</target>
        </trans-unit>
        <trans-unit id="cb4264d6fcf534ad0d711543bbbad940acfd384f" translate="yes" xml:space="preserve">
          <source>The following syntax was used before PostgreSQL version 9.0 and is still supported:</source>
          <target state="translated">以下の構文はPostgreSQLバージョン9.0以前に使用されていたもので、現在もサポートされています。</target>
        </trans-unit>
        <trans-unit id="7ffe77d533e655164667efaec733a8644752fd0c" translate="yes" xml:space="preserve">
          <source>The following table summarizes which types of triggers may be used on tables, views, and foreign tables:</source>
          <target state="translated">次の表は、テーブル、ビュー、および外部テーブルで使用できるトリガーの種類をまとめたものです。</target>
        </trans-unit>
        <trans-unit id="b9dedb03b6c7c1e94159053f8cafdd1b64ee1259" translate="yes" xml:space="preserve">
          <source>The following two examples are identical ways of sorting the individual results according to the contents of the second column (&lt;code&gt;name&lt;/code&gt;):</source>
          <target state="translated">次の2つの例は、2番目の列（ &lt;code&gt;name&lt;/code&gt; ）の内容に従って個々の結果をソートする同じ方法です。</target>
        </trans-unit>
        <trans-unit id="a55bcd1aa5b5db14890555290a8f28e4c18316d2" translate="yes" xml:space="preserve">
          <source>The following two keys are always present:</source>
          <target state="translated">以下の2つのキーが常に存在しています。</target>
        </trans-unit>
        <trans-unit id="f82d287994dca1133e1c905ec21b4420d1348aaa" translate="yes" xml:space="preserve">
          <source>The following types (or spellings thereof) are specified by SQL: &lt;code&gt;bigint&lt;/code&gt;, &lt;code&gt;bit&lt;/code&gt;, &lt;code&gt;bit varying&lt;/code&gt;, &lt;code&gt;boolean&lt;/code&gt;, &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;character varying&lt;/code&gt;, &lt;code&gt;character&lt;/code&gt;, &lt;code&gt;varchar&lt;/code&gt;, &lt;code&gt;date&lt;/code&gt;, &lt;code&gt;double precision&lt;/code&gt;, &lt;code&gt;integer&lt;/code&gt;, &lt;code&gt;interval&lt;/code&gt;, &lt;code&gt;numeric&lt;/code&gt;, &lt;code&gt;decimal&lt;/code&gt;, &lt;code&gt;real&lt;/code&gt;, &lt;code&gt;smallint&lt;/code&gt;, &lt;code&gt;time&lt;/code&gt; (with or without time zone), &lt;code&gt;timestamp&lt;/code&gt; (with or without time zone), &lt;code&gt;xml&lt;/code&gt;.</source>
          <target state="translated">（またはその綴り）次のタイプは、SQLで指定された： &lt;code&gt;bigint&lt;/code&gt; 、 &lt;code&gt;bit&lt;/code&gt; 、 &lt;code&gt;bit varying&lt;/code&gt; 、 &lt;code&gt;boolean&lt;/code&gt; 、 &lt;code&gt;char&lt;/code&gt; 、 &lt;code&gt;character varying&lt;/code&gt; 、 &lt;code&gt;character&lt;/code&gt; 、 &lt;code&gt;varchar&lt;/code&gt; 、 &lt;code&gt;date&lt;/code&gt; 、 &lt;code&gt;double precision&lt;/code&gt; 、 &lt;code&gt;integer&lt;/code&gt; 、 &lt;code&gt;interval&lt;/code&gt; 、 &lt;code&gt;numeric&lt;/code&gt; 、 &lt;code&gt;decimal&lt;/code&gt; 、 &lt;code&gt;real&lt;/code&gt; 、 &lt;code&gt;smallint&lt;/code&gt; 、 &lt;code&gt;time&lt;/code&gt; （タイムゾーンの有無にかかわらず）、 &lt;code&gt;timestamp&lt;/code&gt; （タイムゾーンの有無にかかわらず）、 &lt;code&gt;xml&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="008f4840c9bbbc114acf97e5143a54c88f68912b" translate="yes" xml:space="preserve">
          <source>The following types of administration commands are not accepted during recovery mode:</source>
          <target state="translated">リカバリーモード中は、以下の種類の管理コマンドは受け付けられません。</target>
        </trans-unit>
        <trans-unit id="d4a4cbf72726623686906a4dfcab95be0271a53f" translate="yes" xml:space="preserve">
          <source>The following types of parallel-aware table scans are currently supported.</source>
          <target state="translated">現在、以下のタイプの並列対応テーブルスキャンがサポートされています。</target>
        </trans-unit>
        <trans-unit id="45ec767602366e0da0c6d60741f363eda41896e3" translate="yes" xml:space="preserve">
          <source>The foreign server to import from.</source>
          <target state="translated">インポート元の海外サーバー。</target>
        </trans-unit>
        <trans-unit id="fbe288bd62bdf2a35ec4994319ad86594322f65f" translate="yes" xml:space="preserve">
          <source>The foreign-data wrapper name must be unique within the database.</source>
          <target state="translated">外部データのラッパー名はデータベース内で一意でなければなりません。</target>
        </trans-unit>
        <trans-unit id="721abb232cb1907cbf75dfbc734244683645423e" translate="yes" xml:space="preserve">
          <source>The form of &lt;code&gt;CREATE LANGUAGE&lt;/code&gt; that does not supply any handler function is obsolete. For backwards compatibility with old dump files, it is interpreted as &lt;code&gt;CREATE EXTENSION&lt;/code&gt;. That will work if the language has been packaged into an extension of the same name, which is the conventional way to set up procedural languages.</source>
          <target state="translated">The form of &lt;code&gt;CREATE LANGUAGE&lt;/code&gt; that does not supply any handler function is obsolete. For backwards compatibility with old dump files, it is interpreted as &lt;code&gt;CREATE EXTENSION&lt;/code&gt; . That will work if the language has been packaged into an extension of the same name, which is the conventional way to set up procedural languages.</target>
        </trans-unit>
        <trans-unit id="128070d44af946b3f1ecf65ccd252fb06b8cf14f" translate="yes" xml:space="preserve">
          <source>The format of a psql command is the backslash, followed immediately by a command verb, then any arguments. The arguments are separated from the command verb and each other by any number of whitespace characters.</source>
          <target state="translated">psqlコマンドの形式は、バックスラッシュの後にコマンド動詞が続き、その後に引数が続きます。引数は、コマンド動詞から任意の数の空白文字で区切られています。</target>
        </trans-unit>
        <trans-unit id="7f3c7541e2c4fcc461ec02ccb2547741ee4be834" translate="yes" xml:space="preserve">
          <source>The format of the log is:</source>
          <target state="translated">ログの形式は</target>
        </trans-unit>
        <trans-unit id="c1adf1c1ec6d1279c3ae3b2793de10b99dbd36d4" translate="yes" xml:space="preserve">
          <source>The formatting function &lt;code&gt;to_char&lt;/code&gt; (see &lt;a href=&quot;functions-formatting&quot;&gt;Section 9.8&lt;/a&gt;) is also available as a more flexible way to format date/time output.</source>
          <target state="translated">日付/時刻出力をフォーマットするより柔軟な方法として、フォーマット関数 &lt;code&gt;to_char&lt;/code&gt; （&lt;a href=&quot;functions-formatting&quot;&gt;セクション9.8を&lt;/a&gt;参照）も使用できます。</target>
        </trans-unit>
        <trans-unit id="9ba5e32cb8a2291627c08e67bf1bfb6249955cd8" translate="yes" xml:space="preserve">
          <source>The forms &lt;code&gt;ADD&lt;/code&gt; (without &lt;code&gt;USING INDEX&lt;/code&gt;), &lt;code&gt;DROP [COLUMN]&lt;/code&gt;, &lt;code&gt;DROP IDENTITY&lt;/code&gt;, &lt;code&gt;RESTART&lt;/code&gt;, &lt;code&gt;SET DEFAULT&lt;/code&gt;, &lt;code&gt;SET DATA TYPE&lt;/code&gt; (without &lt;code&gt;USING&lt;/code&gt;), &lt;code&gt;SET GENERATED&lt;/code&gt;, and &lt;code&gt;SET sequence_option&lt;/code&gt; conform with the SQL standard. The other forms are PostgreSQL extensions of the SQL standard. Also, the ability to specify more than one manipulation in a single &lt;code&gt;ALTER TABLE&lt;/code&gt; command is an extension.</source>
          <target state="translated">&lt;code&gt;ADD&lt;/code&gt; （ &lt;code&gt;USING INDEX&lt;/code&gt; なし）、 &lt;code&gt;DROP [COLUMN]&lt;/code&gt; 、 &lt;code&gt;DROP IDENTITY&lt;/code&gt; 、 &lt;code&gt;RESTART&lt;/code&gt; 、 &lt;code&gt;SET DEFAULT&lt;/code&gt; 、 &lt;code&gt;SET DATA TYPE&lt;/code&gt; （ &lt;code&gt;USING&lt;/code&gt; なし）、 &lt;code&gt;SET GENERATED&lt;/code&gt; 、および &lt;code&gt;SET sequence_option&lt;/code&gt; の形式は、SQL標準に準拠しています。その他の形式は、SQL標準のPostgreSQL拡張機能です。また、単一の &lt;code&gt;ALTER TABLE&lt;/code&gt; コマンドで複数の操作を指定する機能は拡張機能です。</target>
        </trans-unit>
        <trans-unit id="60e0a26739b6392b783c8e0781017e51a86f2c82" translate="yes" xml:space="preserve">
          <source>The forms &lt;code&gt;ADD&lt;/code&gt;, &lt;code&gt;DROP&lt;/code&gt;, and &lt;code&gt;SET DATA TYPE&lt;/code&gt; conform with the SQL standard. The other forms are PostgreSQL extensions of the SQL standard. Also, the ability to specify more than one manipulation in a single &lt;code&gt;ALTER FOREIGN TABLE&lt;/code&gt; command is an extension.</source>
          <target state="translated">&lt;code&gt;ADD&lt;/code&gt; 、 &lt;code&gt;DROP&lt;/code&gt; 、および &lt;code&gt;SET DATA TYPE&lt;/code&gt; の形式は、SQL標準に準拠しています。その他の形式は、SQL標準のPostgreSQL拡張機能です。また、1つの &lt;code&gt;ALTER FOREIGN TABLE&lt;/code&gt; コマンドで複数の操作を指定する機能も拡張されています。</target>
        </trans-unit>
        <trans-unit id="ceb183e300587222b81cf3fc6aa4245c9a8136ea" translate="yes" xml:space="preserve">
          <source>The forms &lt;code&gt;NEXT&lt;/code&gt;, &lt;code&gt;PRIOR&lt;/code&gt;, &lt;code&gt;FIRST&lt;/code&gt;, &lt;code&gt;LAST&lt;/code&gt;, &lt;code&gt;ABSOLUTE&lt;/code&gt;, &lt;code&gt;RELATIVE&lt;/code&gt; fetch a single row after moving the cursor appropriately. If there is no such row, an empty result is returned, and the cursor is left positioned before the first row or after the last row as appropriate.</source>
          <target state="translated">&lt;code&gt;NEXT&lt;/code&gt; 、 &lt;code&gt;PRIOR&lt;/code&gt; 、 &lt;code&gt;FIRST&lt;/code&gt; 、 &lt;code&gt;LAST&lt;/code&gt; 、 &lt;code&gt;ABSOLUTE&lt;/code&gt; 、 &lt;code&gt;RELATIVE&lt;/code&gt; の形式は、カーソルを適切に移動した後に単一の行をフェッチします。そのような行がない場合、空の結果が返され、カーソルは必要に応じて最初の行の前または最後の行の後に置かれます。</target>
        </trans-unit>
        <trans-unit id="2588add0e86c17b12a1c6aa4f12342731ddacd9b" translate="yes" xml:space="preserve">
          <source>The forms using &lt;code&gt;FORWARD&lt;/code&gt; and &lt;code&gt;BACKWARD&lt;/code&gt; retrieve the indicated number of rows moving in the forward or backward direction, leaving the cursor positioned on the last-returned row (or after/before all rows, if the &lt;code&gt;count&lt;/code&gt; exceeds the number of rows available).</source>
          <target state="translated">&lt;code&gt;FORWARD&lt;/code&gt; と &lt;code&gt;BACKWARD&lt;/code&gt; を使用するフォームは、順方向または逆方向に移動する指定された行数を取得し、最後に返された行（または、 &lt;code&gt;count&lt;/code&gt; が使用可能な行数を超える場合はすべての行の前後）にカーソルを置きます。</target>
        </trans-unit>
        <trans-unit id="38a28d1e90b500392094fc0f5e04fc9e1934bc5b" translate="yes" xml:space="preserve">
          <source>The forms using &lt;code&gt;{&lt;/code&gt;&lt;code&gt;...&lt;/code&gt;&lt;code&gt;}&lt;/code&gt; are known as &lt;em&gt;bounds&lt;/em&gt;. The numbers &lt;code&gt;m&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt; within a bound are unsigned decimal integers with permissible values from 0 to 255 inclusive.</source>
          <target state="translated">&lt;code&gt;{&lt;/code&gt; &lt;code&gt;...&lt;/code&gt; &lt;code&gt;}&lt;/code&gt; を使用するフォームは、&lt;em&gt;境界と&lt;/em&gt;呼ばれ&lt;em&gt;ます&lt;/em&gt;。範囲内の数値 &lt;code&gt;m&lt;/code&gt; と &lt;code&gt;n&lt;/code&gt; は、0から255までの許容値を持つ符号なし10進整数です。</target>
        </trans-unit>
        <trans-unit id="35372a44df7778273e762917011aca61a01afe9f" translate="yes" xml:space="preserve">
          <source>The forward transition function for moving-aggregate mode is not allowed to return NULL as the new state value. If the inverse transition function returns NULL, this is taken as an indication that the inverse function cannot reverse the state calculation for this particular input, and so the aggregate calculation will be redone from scratch for the current frame starting position. This convention allows moving-aggregate mode to be used in situations where there are some infrequent cases that are impractical to reverse out of the running state value.</source>
          <target state="translated">移動アグリゲートモードの正転遷移関数は、新しい状態値として NULL を返すことはできません。逆遷移関数が NULL を返した場合は、逆関数がこの特定の入力の状態計算を逆にできないことを示しており、現在のフレーム開始位置のために一から集計計算をやり直すことになります。この規約により、実行中の状態値から逆算することが現実的ではないケースが稀にある場合に、移動アグリゲートモードを使用することができます。</target>
        </trans-unit>
        <trans-unit id="5ac2696bdfdb7d076133fbfd9fa64682db1b8328" translate="yes" xml:space="preserve">
          <source>The four timezone names &lt;code&gt;EST5EDT&lt;/code&gt;, &lt;code&gt;CST6CDT&lt;/code&gt;, &lt;code&gt;MST7MDT&lt;/code&gt;, and &lt;code&gt;PST8PDT&lt;/code&gt; look like they are POSIX zone specifications. However, they actually are treated as named time zones because (for historical reasons) there are files by those names in the IANA time zone database. The practical implication of this is that these zone names will produce valid historical USA daylight-savings transitions, even when a plain POSIX specification would not.</source>
          <target state="translated">The four timezone names &lt;code&gt;EST5EDT&lt;/code&gt; , &lt;code&gt;CST6CDT&lt;/code&gt; , &lt;code&gt;MST7MDT&lt;/code&gt; , and &lt;code&gt;PST8PDT&lt;/code&gt; look like they are POSIX zone specifications. However, they actually are treated as named time zones because (for historical reasons) there are files by those names in the IANA time zone database. The practical implication of this is that these zone names will produce valid historical USA daylight-savings transitions, even when a plain POSIX specification would not.</target>
        </trans-unit>
        <trans-unit id="ab5226a0f4072d37673ee94afa6e18b7e80854c8" translate="yes" xml:space="preserve">
          <source>The fourth form changes the default tablespace of the database. Only the database owner or a superuser can do this; you must also have create privilege for the new tablespace. This command physically moves any tables or indexes in the database's old default tablespace to the new tablespace. The new default tablespace must be empty for this database, and no one can be connected to the database. Tables and indexes in non-default tablespaces are unaffected.</source>
          <target state="translated">4 番目のフォームでは、データベースのデフォルトのテーブルスペースを変更します。これは、データベース所有者またはスーパーユーザーのみが行うことができ、新しいテーブルスペースの作成権限を持っている必要があります。このコマンドは、データベースの古い既定のテーブル空間にあるテーブルまたはインデックスを新しいテーブル空間に物理的に移動します。新しい既定のテーブルスペースは、このデータベースでは空でなければならず、データベースには誰も接続できません。既定でないテーブルスペースのテーブルとインデックスは影響を受けません。</target>
        </trans-unit>
        <trans-unit id="36812cc6bb8478aaca401b63d7fbabaea11a3122" translate="yes" xml:space="preserve">
          <source>The fourth form of &lt;code&gt;CREATE TYPE&lt;/code&gt; creates a new base type (scalar type). To create a new base type, you must be a superuser. (This restriction is made because an erroneous type definition could confuse or even crash the server.)</source>
          <target state="translated">&lt;code&gt;CREATE TYPE&lt;/code&gt; の4番目の形式は、新しい基本型（スカラー型）を作成します。新しい基本タイプを作成するには、スーパーユーザーである必要があります。（この制限は、誤った型定義がサーバーを混乱させたり、場合によってはクラッシュさせる可能性があるためです。）</target>
        </trans-unit>
        <trans-unit id="9a5bc0cc22101b5b7b3dd6dc1462291809c736e9" translate="yes" xml:space="preserve">
          <source>The fourth variant of this command listed in the synopsis can change all of the publication properties specified in &lt;a href=&quot;sql-createpublication&quot;&gt;CREATE PUBLICATION&lt;/a&gt;. Properties not mentioned in the command retain their previous settings.</source>
          <target state="translated">概要にリストされているこのコマンドの4番目のバリアントは、&lt;a href=&quot;sql-createpublication&quot;&gt;CREATE PUBLICATIONで&lt;/a&gt;指定されたすべてのパブリケーションプロパティを変更できます。コマンドに記載されていないプロパティは、以前の設定を保持します。</target>
        </trans-unit>
        <trans-unit id="dea2017c78cbd95284b251ddbea3a7b1e10a923d" translate="yes" xml:space="preserve">
          <source>The fraction of the column's entries that are null</source>
          <target state="translated">カラムのエントリがヌルである割合</target>
        </trans-unit>
        <trans-unit id="44d7567a007c45862dffe28ca10785cde8529aa6" translate="yes" xml:space="preserve">
          <source>The full SQL type syntax is allowed for declaring a function's arguments and return value. However, parenthesized type modifiers (e.g., the precision field for type &lt;code&gt;numeric&lt;/code&gt;) are discarded by &lt;code&gt;CREATE FUNCTION&lt;/code&gt;. Thus for example &lt;code&gt;CREATE FUNCTION foo (varchar(10)) ...&lt;/code&gt; is exactly the same as &lt;code&gt;CREATE FUNCTION foo (varchar) ...&lt;/code&gt;.</source>
          <target state="translated">関数の引数と戻り値を宣言するには、完全なSQL型構文を使用できます。ただし、括弧で囲まれた型修飾子（たとえば、 &lt;code&gt;numeric&lt;/code&gt; 型の精度フィールド）は &lt;code&gt;CREATE FUNCTION&lt;/code&gt; によって破棄されます。したがって、たとえば &lt;code&gt;CREATE FUNCTION foo (varchar(10)) ...&lt;/code&gt; はCREATE FUNCTION foo（varchar）...とまったく同じ &lt;code&gt;CREATE FUNCTION foo (varchar) ...&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b36f659c83072f67d547396d3e51c25042456bdd" translate="yes" xml:space="preserve">
          <source>The full host name (with domain name) of the database server, or &lt;code&gt;[local]&lt;/code&gt; if the connection is over a Unix domain socket, or &lt;code&gt;[local:/dir/name]&lt;/code&gt;, if the Unix domain socket is not at the compiled in default location.</source>
          <target state="translated">データベースサーバーの完全なホスト名（ドメイン名付き）、または接続がUnixドメインソケットを介している場合は &lt;code&gt;[local]&lt;/code&gt; 、UNIXドメインソケットがデフォルトでコンパイルされていない場合は &lt;code&gt;[local:/dir/name]&lt;/code&gt; ロケーション。</target>
        </trans-unit>
        <trans-unit id="51d56119fb00f5592b9aaa01b9f5e760e9ad4329" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;current_setting&lt;/code&gt; produces equivalent output; see &lt;a href=&quot;functions-admin&quot;&gt;Section 9.26&lt;/a&gt;. Also, the &lt;a href=&quot;view-pg-settings&quot;&gt;&lt;code&gt;pg_settings&lt;/code&gt;&lt;/a&gt; system view produces the same information.</source>
          <target state="translated">関数 &lt;code&gt;current_setting&lt;/code&gt; は同等の出力を生成します。&lt;a href=&quot;functions-admin&quot;&gt;セクション9.26を&lt;/a&gt;参照してください。また、&lt;a href=&quot;view-pg-settings&quot;&gt; &lt;code&gt;pg_settings&lt;/code&gt; &lt;/a&gt;システムビューでも同じ情報が生成されます。</target>
        </trans-unit>
        <trans-unit id="5afbca91f6730238f363a7b1792e0e6d19d8f348" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;current_setting&lt;/code&gt; produces equivalent output; see &lt;a href=&quot;functions-admin&quot;&gt;Section 9.27&lt;/a&gt;. Also, the &lt;a href=&quot;view-pg-settings&quot;&gt;&lt;code&gt;pg_settings&lt;/code&gt;&lt;/a&gt; system view produces the same information.</source>
          <target state="translated">The function &lt;code&gt;current_setting&lt;/code&gt; produces equivalent output; see &lt;a href=&quot;functions-admin&quot;&gt;Section 9.27&lt;/a&gt;. Also, the &lt;a href=&quot;view-pg-settings&quot;&gt; &lt;code&gt;pg_settings&lt;/code&gt; &lt;/a&gt; system view produces the same information.</target>
        </trans-unit>
        <trans-unit id="afa8c22afca8c86aa84834df3d7365a4c4ad70ab" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;current_setting&lt;/code&gt; yields the current value of the setting &lt;em&gt;&lt;code&gt;setting_name&lt;/code&gt;&lt;/em&gt;. It corresponds to the SQL command &lt;code&gt;SHOW&lt;/code&gt;. An example:</source>
          <target state="translated">関数 &lt;code&gt;current_setting&lt;/code&gt; は、設定&lt;em&gt; &lt;code&gt;setting_name&lt;/code&gt; の&lt;/em&gt;現在の値を生成します。SQLコマンド &lt;code&gt;SHOW&lt;/code&gt; に対応します。例：</target>
        </trans-unit>
        <trans-unit id="f6649ace670e65e10a1490b2ecf7a4829ee526f2" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;date_trunc&lt;/code&gt; is conceptually similar to the &lt;code&gt;trunc&lt;/code&gt; function for numbers.</source>
          <target state="translated">関数 &lt;code&gt;date_trunc&lt;/code&gt; は、概念的には数値の &lt;code&gt;trunc&lt;/code&gt; 関数に似ています。</target>
        </trans-unit>
        <trans-unit id="246b10543803d9782a161a47909e8e612b910177" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;format&lt;/code&gt; produces output formatted according to a format string, in a style similar to the C function &lt;code&gt;sprintf&lt;/code&gt;.</source>
          <target state="translated">関数 &lt;code&gt;format&lt;/code&gt; は、C関数 &lt;code&gt;sprintf&lt;/code&gt; と同様のスタイルで、フォーマット文字列に従ってフォーマットされた出力を生成します。</target>
        </trans-unit>
        <trans-unit id="0f972d6e5c3f5f9e5c41c594a5f0d51dc8e13164" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;hstore_to_json&lt;/code&gt; is used when an &lt;code&gt;hstore&lt;/code&gt; value is cast to &lt;code&gt;json&lt;/code&gt;. Likewise, &lt;code&gt;hstore_to_jsonb&lt;/code&gt; is used when an &lt;code&gt;hstore&lt;/code&gt; value is cast to &lt;code&gt;jsonb&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;hstore_to_json&lt;/code&gt; 関数は、 &lt;code&gt;hstore&lt;/code&gt; 値が &lt;code&gt;json&lt;/code&gt; にキャストされるときに使用されます。同様に、 &lt;code&gt;hstore_to_jsonb&lt;/code&gt; は、 &lt;code&gt;hstore&lt;/code&gt; 値が &lt;code&gt;jsonb&lt;/code&gt; にキャストされるときに使用されます。</target>
        </trans-unit>
        <trans-unit id="3e40c0481379cfb3fb5e6423f9267d79ee88e237" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;pg_export_snapshot&lt;/code&gt; saves the current snapshot and returns a &lt;code&gt;text&lt;/code&gt; string identifying the snapshot. This string must be passed (outside the database) to clients that want to import the snapshot. The snapshot is available for import only until the end of the transaction that exported it. A transaction can export more than one snapshot, if needed. Note that doing so is only useful in &lt;code&gt;READ COMMITTED&lt;/code&gt; transactions, since in &lt;code&gt;REPEATABLE READ&lt;/code&gt; and higher isolation levels, transactions use the same snapshot throughout their lifetime. Once a transaction has exported any snapshots, it cannot be prepared with &lt;a href=&quot;sql-prepare-transaction&quot;&gt;PREPARE TRANSACTION&lt;/a&gt;.</source>
          <target state="translated">関数 &lt;code&gt;pg_export_snapshot&lt;/code&gt; は現在のスナップショットを保存し、スナップショットを識別する &lt;code&gt;text&lt;/code&gt; 文字列を返します。この文字列は、スナップショットをインポートするクライアントに（データベースの外部で）渡す必要があります。スナップショットは、それをエクスポートしたトランザクションが終了するまでのみインポートできます。トランザクションは、必要に応じて複数のスナップショットをエクスポートできます。 &lt;code&gt;REPEATABLE READ&lt;/code&gt; 以上の分離レベルでは、トランザクションは存続期間を通じて同じスナップショットを使用するため、そうすることは &lt;code&gt;READ COMMITTED&lt;/code&gt; トランザクションでのみ役立つことに注意してください。トランザクションがスナップショットをエクスポートすると、&lt;a href=&quot;sql-prepare-transaction&quot;&gt;PREPARE TRANSACTIONでは&lt;/a&gt;準備できません。</target>
        </trans-unit>
        <trans-unit id="9f7c2a78ba8dec8a097ba6554379141ee778a83d" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;pg_notification_queue_usage&lt;/code&gt; returns the fraction of the queue that is currently occupied by pending notifications. See &lt;a href=&quot;functions-info&quot;&gt;Section 9.25&lt;/a&gt; for more information.</source>
          <target state="translated">関数 &lt;code&gt;pg_notification_queue_usage&lt;/code&gt; は、保留中の通知によって現在占有されているキューの割合を返します。詳細は&lt;a href=&quot;functions-info&quot;&gt;項9.25&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="47fe71d7219fa50bb753b32d84319041e350cf1a" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;pg_notification_queue_usage&lt;/code&gt; returns the fraction of the queue that is currently occupied by pending notifications. See &lt;a href=&quot;functions-info&quot;&gt;Section 9.26&lt;/a&gt; for more information.</source>
          <target state="translated">The function &lt;code&gt;pg_notification_queue_usage&lt;/code&gt; returns the fraction of the queue that is currently occupied by pending notifications. See &lt;a href=&quot;functions-info&quot;&gt;Section 9.26&lt;/a&gt; for more information.</target>
        </trans-unit>
        <trans-unit id="082064f30064e38cacd08cc4cf5d96bae8c8c23d" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;populate_record&lt;/code&gt; is actually declared with &lt;code&gt;anyelement&lt;/code&gt;, not &lt;code&gt;record&lt;/code&gt;, as its first argument, but it will reject non-record types with a run-time error.</source>
          <target state="translated">関数 &lt;code&gt;populate_record&lt;/code&gt; は、最初の引数として、 &lt;code&gt;record&lt;/code&gt; ではなく &lt;code&gt;anyelement&lt;/code&gt; で実際に宣言されますが、実行時エラーで非レコード型を拒否します。</target>
        </trans-unit>
        <trans-unit id="472db68032e87a9f5dc2308d607eed94d8936c47" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;set_config&lt;/code&gt; provides equivalent functionality; see &lt;a href=&quot;functions-admin&quot;&gt;Section 9.26&lt;/a&gt;. Also, it is possible to UPDATE the &lt;a href=&quot;view-pg-settings&quot;&gt;&lt;code&gt;pg_settings&lt;/code&gt;&lt;/a&gt; system view to perform the equivalent of &lt;code&gt;SET&lt;/code&gt;.</source>
          <target state="translated">関数 &lt;code&gt;set_config&lt;/code&gt; は同等の機能を提供します。&lt;a href=&quot;functions-admin&quot;&gt;セクション9.26を&lt;/a&gt;参照してください。また、&lt;a href=&quot;view-pg-settings&quot;&gt; &lt;code&gt;pg_settings&lt;/code&gt; &lt;/a&gt;システムビューを更新して、 &lt;code&gt;SET&lt;/code&gt; と同等の機能を実行することもできます。</target>
        </trans-unit>
        <trans-unit id="1a81b9de17dd1c89cda6e145c6b31e9ece522492" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;set_config&lt;/code&gt; provides equivalent functionality; see &lt;a href=&quot;functions-admin&quot;&gt;Section 9.27&lt;/a&gt;. Also, it is possible to UPDATE the &lt;a href=&quot;view-pg-settings&quot;&gt;&lt;code&gt;pg_settings&lt;/code&gt;&lt;/a&gt; system view to perform the equivalent of &lt;code&gt;SET&lt;/code&gt;.</source>
          <target state="translated">The function &lt;code&gt;set_config&lt;/code&gt; provides equivalent functionality; see &lt;a href=&quot;functions-admin&quot;&gt;Section 9.27&lt;/a&gt;. Also, it is possible to UPDATE the &lt;a href=&quot;view-pg-settings&quot;&gt; &lt;code&gt;pg_settings&lt;/code&gt; &lt;/a&gt; system view to perform the equivalent of &lt;code&gt;SET&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1a0af8636b241010eb58f1e64ca4ece0dacf61bc" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;setweight&lt;/code&gt; can be used to label the entries of a &lt;code&gt;tsvector&lt;/code&gt; with a given &lt;em&gt;weight&lt;/em&gt;, where a weight is one of the letters &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;, &lt;code&gt;C&lt;/code&gt;, or &lt;code&gt;D&lt;/code&gt;. This is typically used to mark entries coming from different parts of a document, such as title versus body. Later, this information can be used for ranking of search results.</source>
          <target state="translated">関数 &lt;code&gt;setweight&lt;/code&gt; を使用して、 &lt;code&gt;tsvector&lt;/code&gt; のエントリに特定の&lt;em&gt;重み&lt;/em&gt;でラベルを付けることができます。重みは、 &lt;code&gt;A&lt;/code&gt; 、 &lt;code&gt;B&lt;/code&gt; 、 &lt;code&gt;C&lt;/code&gt; 、または &lt;code&gt;D&lt;/code&gt; のいずれかの文字です。これは通常、タイトルと本文など、ドキュメントのさまざまな部分からのエントリをマークするために使用されます。後で、この情報は検索結果のランキングに使用できます。</target>
        </trans-unit>
        <trans-unit id="13cca378c8ae0fc168761a1769d0060a92e5808a" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;timezone(zone, timestamp)&lt;/code&gt; is equivalent to the SQL-conforming construct &lt;code&gt;timestamp AT TIME ZONE zone&lt;/code&gt;.</source>
          <target state="translated">関数 &lt;code&gt;timezone(zone, timestamp)&lt;/code&gt; は、SQL準拠の構成要素 &lt;code&gt;timestamp AT TIME ZONE zone&lt;/code&gt; と同等です。</target>
        </trans-unit>
        <trans-unit id="6c2461207b12b5b4e196270e7b51786ac6ccae21" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;ts_debug&lt;/code&gt; allows easy testing of a text search configuration.</source>
          <target state="translated">関数 &lt;code&gt;ts_debug&lt;/code&gt; を使用すると、テキスト検索構成を簡単にテストできます。</target>
        </trans-unit>
        <trans-unit id="99af9ae29d7989fa85e4ac3a29989c54729ceea6" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;ts_stat&lt;/code&gt; is useful for checking your configuration and for finding stop-word candidates.</source>
          <target state="translated">関数 &lt;code&gt;ts_stat&lt;/code&gt; は、構成のチェックやストップワード候補の検索に役立ちます。</target>
        </trans-unit>
        <trans-unit id="2e394c193235d538ba957624ee9cbb6815d37e36" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;xmlagg&lt;/code&gt; is, unlike the other functions described here, an aggregate function. It concatenates the input values to the aggregate function call, much like &lt;code&gt;xmlconcat&lt;/code&gt; does, except that concatenation occurs across rows rather than across expressions in a single row. See &lt;a href=&quot;functions-aggregate&quot;&gt;Section 9.20&lt;/a&gt; for additional information about aggregate functions.</source>
          <target state="translated">関数 &lt;code&gt;xmlagg&lt;/code&gt; は、ここで説明する他の関数とは異なり、集約関数です。単一の行の式全体ではなく行全体で連結が行われることを除いて、 &lt;code&gt;xmlconcat&lt;/code&gt; と同様に、入力値を集約関数呼び出しに連結します。集計関数の詳細は、&lt;a href=&quot;functions-aggregate&quot;&gt;9.20&lt;/a&gt;項を参照してください。</target>
        </trans-unit>
        <trans-unit id="0c233db134ccdaf6d9f67f9f0ee69ad09d27e178" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;xmlagg&lt;/code&gt; is, unlike the other functions described here, an aggregate function. It concatenates the input values to the aggregate function call, much like &lt;code&gt;xmlconcat&lt;/code&gt; does, except that concatenation occurs across rows rather than across expressions in a single row. See &lt;a href=&quot;functions-aggregate&quot;&gt;Section 9.21&lt;/a&gt; for additional information about aggregate functions.</source>
          <target state="translated">The function &lt;code&gt;xmlagg&lt;/code&gt; is, unlike the other functions described here, an aggregate function. It concatenates the input values to the aggregate function call, much like &lt;code&gt;xmlconcat&lt;/code&gt; does, except that concatenation occurs across rows rather than across expressions in a single row. See &lt;a href=&quot;functions-aggregate&quot;&gt;Section 9.21&lt;/a&gt; for additional information about aggregate functions.</target>
        </trans-unit>
        <trans-unit id="1f1fc89a699325691e39d0dd59e92400a699e36a" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;xmlcomment&lt;/code&gt; creates an XML value containing an XML comment with the specified text as content. The text cannot contain &amp;ldquo;&lt;code&gt;--&lt;/code&gt;&amp;rdquo; or end with a &amp;ldquo;&lt;code&gt;-&lt;/code&gt;&amp;rdquo; so that the resulting construct is a valid XML comment. If the argument is null, the result is null.</source>
          <target state="translated">関数 &lt;code&gt;xmlcomment&lt;/code&gt; は、指定されたテキストをコンテンツとして持つXMLコメントを含むXML値を作成します。結果の構成が有効なXMLコメントになるように、テキストに「 &lt;code&gt;--&lt;/code&gt; 」を含めたり、「 &lt;code&gt;-&lt;/code&gt; 」で終了したりすることはできません。引数がnullの場合、結果はnullです。</target>
        </trans-unit>
        <trans-unit id="3e13677298d4e7c49ab95cddcc30183542277248" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;xmlcomment&lt;/code&gt; creates an XML value containing an XML comment with the specified text as content. The text cannot contain &amp;ldquo;&lt;code&gt;--&lt;/code&gt;&amp;rdquo; or end with a &amp;ldquo;&lt;code&gt;-&lt;/code&gt;&amp;rdquo;, otherwise the resulting construct would not be a valid XML comment. If the argument is null, the result is null.</source>
          <target state="translated">The function &lt;code&gt;xmlcomment&lt;/code&gt; creates an XML value containing an XML comment with the specified text as content. The text cannot contain &amp;ldquo; &lt;code&gt;--&lt;/code&gt; &amp;rdquo; or end with a &amp;ldquo; &lt;code&gt;-&lt;/code&gt; &amp;rdquo;, otherwise the resulting construct would not be a valid XML comment. If the argument is null, the result is null.</target>
        </trans-unit>
        <trans-unit id="ebaef272546a7798627e85265fe680ca3031d61e" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;xmlconcat&lt;/code&gt; concatenates a list of individual XML values to create a single value containing an XML content fragment. Null values are omitted; the result is only null if there are no nonnull arguments.</source>
          <target state="translated">関数 &lt;code&gt;xmlconcat&lt;/code&gt; は、個々のXML値のリストを連結して、XMLコンテンツフラグメントを含む単一の値を作成します。null値は省略されます。null以外の引数がない場合、結果はnullのみです。</target>
        </trans-unit>
        <trans-unit id="ef22fdb70040aafe9245779771954e498b2f3f6a" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;xmlexists&lt;/code&gt; evaluates an XPath 1.0 expression (the first argument), with the passed XML value as its context item. The function returns false if the result of that evaluation yields an empty node-set, true if it yields any other value. The function returns null if any argument is null. A nonnull value passed as the context item must be an XML document, not a content fragment or any non-XML value.</source>
          <target state="translated">関数 &lt;code&gt;xmlexists&lt;/code&gt; は、渡されたXML値をコンテキスト項目として使用して、XPath 1.0式（最初の引数）を評価します。その評価の結果が空のノードセットを生成する場合、関数はfalseを返し、他の値を生成する場合はtrueを返します。引数がnullの場合、関数はnullを返します。コンテキストアイテムとして渡されるnull以外の値は、コンテンツフラグメントや非XML値ではなく、XMLドキュメントでなければなりません。</target>
        </trans-unit>
        <trans-unit id="837a957d18da91847b5357c6c3108da0982c435c" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;xpath&lt;/code&gt; evaluates the XPath 1.0 expression &lt;code&gt;xpath&lt;/code&gt; (a &lt;code&gt;text&lt;/code&gt; value) against the XML value &lt;code&gt;xml&lt;/code&gt;. It returns an array of XML values corresponding to the node-set produced by the XPath expression. If the XPath expression returns a scalar value rather than a node-set, a single-element array is returned.</source>
          <target state="translated">関数 &lt;code&gt;xpath&lt;/code&gt; は、XML値 &lt;code&gt;xml&lt;/code&gt; に対してXPath 1.0式 &lt;code&gt;xpath&lt;/code&gt; （ &lt;code&gt;text&lt;/code&gt; 値）を評価します。XPath式によって生成されたノードセットに対応するXML値の配列を返します。XPath式がノードセットではなくスカラー値を返す場合、単一要素の配列が返されます。</target>
        </trans-unit>
        <trans-unit id="8aa320cc15b2fe4c99adf1be98b695e1536ba201" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;xpath&lt;/code&gt; evaluates the XPath 1.0 expression &lt;em&gt;&lt;code&gt;xpath&lt;/code&gt;&lt;/em&gt; (given as text) against the XML value &lt;em&gt;&lt;code&gt;xml&lt;/code&gt;&lt;/em&gt;. It returns an array of XML values corresponding to the node-set produced by the XPath expression. If the XPath expression returns a scalar value rather than a node-set, a single-element array is returned.</source>
          <target state="translated">The function &lt;code&gt;xpath&lt;/code&gt; evaluates the XPath 1.0 expression &lt;em&gt; &lt;code&gt;xpath&lt;/code&gt; &lt;/em&gt; (given as text) against the XML value &lt;em&gt; &lt;code&gt;xml&lt;/code&gt; &lt;/em&gt;. It returns an array of XML values corresponding to the node-set produced by the XPath expression. If the XPath expression returns a scalar value rather than a node-set, a single-element array is returned.</target>
        </trans-unit>
        <trans-unit id="49641632c456630ce0fe9561c2cd9fece93afa1f" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;xpath_exists&lt;/code&gt; is a specialized form of the &lt;code&gt;xpath&lt;/code&gt; function. Instead of returning the individual XML values that satisfy the XPath 1.0 expression, this function returns a Boolean indicating whether the query was satisfied or not (specifically, whether it produced any value other than an empty node-set). This function is equivalent to the &lt;code&gt;XMLEXISTS&lt;/code&gt; predicate, except that it also offers support for a namespace mapping argument.</source>
          <target state="translated">関数 &lt;code&gt;xpath_exists&lt;/code&gt; は、 &lt;code&gt;xpath&lt;/code&gt; 関数の特殊な形式です。この関数は、XPath 1.0式を満たす個々のXML値を返す代わりに、クエリが満たされたかどうか（具体的には、空のノードセット以外の値を生成したかどうか）を示すブール値を返します。この関数は、名前空間マッピング引数のサポートも提供することを除いて、 &lt;code&gt;XMLEXISTS&lt;/code&gt; 述語と同等です。</target>
        </trans-unit>
        <trans-unit id="5c574a36f3d0b3b9d8fd4793fb7a1aefa7712dc3" translate="yes" xml:space="preserve">
          <source>The function has no side effects. No information about the arguments is conveyed except via the return value. Any function that might throw an error depending on the values of its arguments is not leak-proof.</source>
          <target state="translated">この関数には副作用はありません。引数に関する情報は、戻り値を経由する以外には何も伝えられません。引数の値に依存してエラーを投げる可能性のある関数は、リークプルーフではありません。</target>
        </trans-unit>
        <trans-unit id="b27ab2a24cc42745c4233c190a0fd395e1a3a156" translate="yes" xml:space="preserve">
          <source>The function has to be used in a &lt;code&gt;FROM&lt;/code&gt; expression, with an &lt;code&gt;AS&lt;/code&gt; clause to specify the output columns; for example</source>
          <target state="translated">この関数は、出力列を指定する &lt;code&gt;AS&lt;/code&gt; 句とともに &lt;code&gt;FROM&lt;/code&gt; 式で使用する必要があります。例えば</target>
        </trans-unit>
        <trans-unit id="c9d8fff21244f2a2d5eabd0812b19e459568cfb8" translate="yes" xml:space="preserve">
          <source>The function is passed a pointer to a &lt;code&gt;local_relopts&lt;/code&gt; struct, which needs to be filled with a set of operator class specific options. The options can be accessed from other support functions using the &lt;code&gt;PG_HAS_OPCLASS_OPTIONS()&lt;/code&gt; and &lt;code&gt;PG_GET_OPCLASS_OPTIONS()&lt;/code&gt; macros.</source>
          <target state="translated">The function is passed a pointer to a &lt;code&gt;local_relopts&lt;/code&gt; struct, which needs to be filled with a set of operator class specific options. The options can be accessed from other support functions using the &lt;code&gt;PG_HAS_OPCLASS_OPTIONS()&lt;/code&gt; and &lt;code&gt;PG_GET_OPCLASS_OPTIONS()&lt;/code&gt; macros.</target>
        </trans-unit>
        <trans-unit id="b6bc1caecad2cc53ec1c4c77402a0b8f9335155f" translate="yes" xml:space="preserve">
          <source>The function must have the following signature:</source>
          <target state="translated">関数は以下のシグネチャを持つ必要があります。</target>
        </trans-unit>
        <trans-unit id="c9d3b3a8b1ce80dcb6ec1f9fb5fa0bcff0d4df0d" translate="yes" xml:space="preserve">
          <source>The function must return &lt;code&gt;true&lt;/code&gt; if the leaf tuple matches the query, or &lt;code&gt;false&lt;/code&gt; if not. In the &lt;code&gt;true&lt;/code&gt; case, if &lt;code&gt;returnData&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; then &lt;code&gt;leafValue&lt;/code&gt; must be set to the value of &lt;code&gt;spgConfigIn&lt;/code&gt;.&lt;code&gt;attType&lt;/code&gt; type originally supplied to be indexed for this leaf tuple. Also, &lt;code&gt;recheck&lt;/code&gt; may be set to &lt;code&gt;true&lt;/code&gt; if the match is uncertain and so the operator(s) must be re-applied to the actual heap tuple to verify the match. If ordered search is performed, set &lt;code&gt;distances&lt;/code&gt; to an array of distance values according to &lt;code&gt;orderbys&lt;/code&gt; array. Leave it NULL otherwise. If at least one of returned distances is not exact, set &lt;code&gt;recheckDistances&lt;/code&gt; to true. In this case, the executor will calculate the exact distances after fetching the tuple from the heap, and will reorder the tuples if needed.</source>
          <target state="translated">リーフタプルがクエリと一致する場合、関数は &lt;code&gt;true&lt;/code&gt; を返し、一致しない場合は &lt;code&gt;false&lt;/code&gt; を返す必要があります。 &lt;code&gt;true&lt;/code&gt; 場合場合、 &lt;code&gt;returnData&lt;/code&gt; がある &lt;code&gt;true&lt;/code&gt; 次いで &lt;code&gt;leafValue&lt;/code&gt; は、の値に設定する必要があり &lt;code&gt;spgConfigIn&lt;/code&gt; 。 &lt;code&gt;attType&lt;/code&gt; にインデックスを付けるために最初に提供されたattTypeタイプ。また、一致が不確かな場合は、 &lt;code&gt;recheck&lt;/code&gt; を &lt;code&gt;true&lt;/code&gt; に設定して、演算子を実際のヒープタプルに再適用して、一致を確認する必要があります。順序付けられた検索が行われた場合、設定され &lt;code&gt;distances&lt;/code&gt; に応じて距離値の配列への &lt;code&gt;orderbys&lt;/code&gt; アレイ。それ以外の場合はNULLのままにします。返された距離の少なくとも1つが正確でない場合は、 &lt;code&gt;recheckDistances&lt;/code&gt; をtrue に設定します。この場合、executorはヒープからタプルをフェッチした後に正確な距離を計算し、必要に応じてタプルを再配列します。</target>
        </trans-unit>
        <trans-unit id="dbb965af01f35df576ea93f5375cbc5d7cb5a800" translate="yes" xml:space="preserve">
          <source>The function names can be schema-qualified if necessary. Argument types are not given, since the argument list for each type of function is predetermined. All except the headline function are required.</source>
          <target state="translated">関数名は必要に応じてスキーマ修飾することができます。引数の種類は、関数の種類ごとの引数リストがあらかじめ決められているので、引数の種類は与えない。ヘッドライン関数以外は必須です。</target>
        </trans-unit>
        <trans-unit id="85e3b58b43bc6834c37e08716eb6be535f35e900" translate="yes" xml:space="preserve">
          <source>The function names can be schema-qualified if necessary. Argument types are not given, since the argument list for each type of function is predetermined. The lexize function is required, but the init function is optional.</source>
          <target state="translated">関数名は必要に応じてスキーマ修飾することができます。引数の種類は、関数の種類ごとの引数リストがあらかじめ決められているので、引数の種類は与えられません。lexize関数は必須ですが、init関数はオプションです。</target>
        </trans-unit>
        <trans-unit id="3e644e558fc444f59115fd62f759afc494438aeb" translate="yes" xml:space="preserve">
          <source>The function to be called</source>
          <target state="translated">呼び出される関数</target>
        </trans-unit>
        <trans-unit id="10c50baf8431e61e9cb02cb427556dde06fcb6c7" translate="yes" xml:space="preserve">
          <source>The function used to implement this operator.</source>
          <target state="translated">この演算子を実装するために使用される関数。</target>
        </trans-unit>
        <trans-unit id="0c214640ce9489d4916101b16e01715654ee3006" translate="yes" xml:space="preserve">
          <source>The function used to perform the cast. The function name can be schema-qualified. If it is not, the function will be looked up in the schema search path. The function's result data type must match the target type of the cast. Its arguments are discussed below. If no argument list is specified, the function name must be unique in its schema.</source>
          <target state="translated">キャストを実行するために使用される関数。関数名はスキーマ修飾名にすることができます。スキーマ修飾されていない場合、関数はスキーマ検索パスで検索されます。関数の結果データ型はキャストのターゲット型と一致しなければなりません。その引数については後述します。引数リストが指定されない場合、関数名はスキーマ内で一意でなければなりません。</target>
        </trans-unit>
        <trans-unit id="4070b563f17e2132c89c11f1dad26e620d3d0a33" translate="yes" xml:space="preserve">
          <source>The function used to perform the conversion. The function name can be schema-qualified. If it is not, the function will be looked up in the path.</source>
          <target state="translated">変換を実行するために使用される関数。関数名はスキーマ修飾することができます。そうでない場合,関数はパスで検索されます。</target>
        </trans-unit>
        <trans-unit id="32829bac3c1c7822fdaafe64cfff6a892c8b38d6" translate="yes" xml:space="preserve">
          <source>The function will now execute with whatever search path is used by its caller.</source>
          <target state="translated">この関数は、呼び出し元で使用されている検索パスで実行されるようになりました。</target>
        </trans-unit>
        <trans-unit id="3887f28b4d8dd432ded2ac6b6e06e93d7b6fd604" translate="yes" xml:space="preserve">
          <source>The function's Boolean result value is significant only when &lt;code&gt;checkUnique&lt;/code&gt; is &lt;code&gt;UNIQUE_CHECK_PARTIAL&lt;/code&gt;. In this case a true result means the new entry is known unique, whereas false means it might be non-unique (and a deferred uniqueness check must be scheduled). For other cases a constant false result is recommended.</source>
          <target state="translated">関数のブール結果値は、 &lt;code&gt;checkUnique&lt;/code&gt; が &lt;code&gt;UNIQUE_CHECK_PARTIAL&lt;/code&gt; の場合にのみ意味があります。この場合、真の結果は新しいエントリが一意であることがわかっていることを意味し、偽はそれが一意ではない可能性があることを意味します（延期された一意性チェックをスケジュールする必要があります）。その他の場合は、一定の偽の結果が推奨されます。</target>
        </trans-unit>
        <trans-unit id="e1dfbee76245b05e9845e2733e79d53c030e40bb" translate="yes" xml:space="preserve">
          <source>The function-like syntax is in fact just a function call. When one of the two standard cast syntaxes is used to do a run-time conversion, it will internally invoke a registered function to perform the conversion. By convention, these conversion functions have the same name as their output type, and thus the &amp;ldquo;function-like syntax&amp;rdquo; is nothing more than a direct invocation of the underlying conversion function. Obviously, this is not something that a portable application should rely on. For further details see &lt;a href=&quot;sql-createcast&quot;&gt;CREATE CAST&lt;/a&gt;.</source>
          <target state="translated">関数のような構文は、実際には単なる関数呼び出しです。 2つの標準キャスト構文の1つを使用してランタイム変換を行うと、登録された関数を内部的に呼び出して変換を実行します。慣例により、これらの変換関数の名前は出力タイプと同じであるため、「関数のような構文」は、基になる変換関数を直接呼び出すことにすぎません。明らかに、これは移植可能なアプリケーションが依存すべきものではありません。詳細については、&lt;a href=&quot;sql-createcast&quot;&gt;CREATE CAST&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="1ff17dc219c0bcfbebd29717a230a4a214e2cbc8" translate="yes" xml:space="preserve">
          <source>The functionality provided by this module overlaps substantially with the functionality of the older &lt;a href=&quot;https://www.postgresql.org/docs/12/dblink.html&quot;&gt;dblink&lt;/a&gt; module. But &lt;code&gt;postgres_fdw&lt;/code&gt; provides more transparent and standards-compliant syntax for accessing remote tables, and can give better performance in many cases.</source>
          <target state="translated">このモジュールが提供する機能は、以前の&lt;a href=&quot;https://www.postgresql.org/docs/12/dblink.html&quot;&gt;dblink&lt;/a&gt;モジュールの機能と実質的に重複しています。しかし、 &lt;code&gt;postgres_fdw&lt;/code&gt; は、リモートテーブルにアクセスするためのより透過的で標準に準拠した構文を提供し、多くの場合により良いパフォーマンスを提供できます。</target>
        </trans-unit>
        <trans-unit id="a4c5ee9bf20fe8736a119caaca754b1fea56c984" translate="yes" xml:space="preserve">
          <source>The functionality provided by this module overlaps substantially with the functionality of the older &lt;a href=&quot;https://www.postgresql.org/docs/13/dblink.html&quot;&gt;dblink&lt;/a&gt; module. But &lt;code&gt;postgres_fdw&lt;/code&gt; provides more transparent and standards-compliant syntax for accessing remote tables, and can give better performance in many cases.</source>
          <target state="translated">The functionality provided by this module overlaps substantially with the functionality of the older &lt;a href=&quot;https://www.postgresql.org/docs/13/dblink.html&quot;&gt;dblink&lt;/a&gt; module. But &lt;code&gt;postgres_fdw&lt;/code&gt; provides more transparent and standards-compliant syntax for accessing remote tables, and can give better performance in many cases.</target>
        </trans-unit>
        <trans-unit id="31e36b0f324aa4e2e4f308d3f86f3d1cbe3d7e22" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;crypt()&lt;/code&gt; and &lt;code&gt;gen_salt()&lt;/code&gt; are specifically designed for hashing passwords. &lt;code&gt;crypt()&lt;/code&gt; does the hashing and &lt;code&gt;gen_salt()&lt;/code&gt; prepares algorithm parameters for it.</source>
          <target state="translated">関数 &lt;code&gt;crypt()&lt;/code&gt; および &lt;code&gt;gen_salt()&lt;/code&gt; は、パスワードのハッシュ用に特別に設計されています。 &lt;code&gt;crypt()&lt;/code&gt; はハッシュを行い、 &lt;code&gt;gen_salt()&lt;/code&gt; はそのためのアルゴリズムパラメータを準備します。</target>
        </trans-unit>
        <trans-unit id="459538ee1cd160dead602c42a37b3db46574d899" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;json[b]_populate_record&lt;/code&gt;, &lt;code&gt;json[b]_populate_recordset&lt;/code&gt;, &lt;code&gt;json[b]_to_record&lt;/code&gt; and &lt;code&gt;json[b]_to_recordset&lt;/code&gt; operate on a JSON object, or array of objects, and extract the values associated with keys whose names match column names of the output row type. Object fields that do not correspond to any output column name are ignored, and output columns that do not match any object field will be filled with nulls. To convert a JSON value to the SQL type of an output column, the following rules are applied in sequence:</source>
          <target state="translated">関数 &lt;code&gt;json[b]_populate_record&lt;/code&gt; 、 &lt;code&gt;json[b]_populate_recordset&lt;/code&gt; 、 &lt;code&gt;json[b]_to_record&lt;/code&gt; および &lt;code&gt;json[b]_to_recordset&lt;/code&gt; は、JSONオブジェクトまたはオブジェクトの配列を操作し、名前が出力行タイプ。どの出力列名にも対応しないオブジェクトフィールドは無視され、どのオブジェクトフィールドとも一致しない出力列はnullで埋められます。JSON値を出力列のSQLタイプに変換するには、次のルールが順番に適用されます。</target>
        </trans-unit>
        <trans-unit id="377b36f768957552b23e80bcd91c885aadb25355" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;lower_inc&lt;/code&gt; and &lt;code&gt;upper_inc&lt;/code&gt; test the inclusivity of the lower and upper bounds of a range value, respectively.</source>
          <target state="translated">関数 &lt;code&gt;lower_inc&lt;/code&gt; および &lt;code&gt;upper_inc&lt;/code&gt; は、それぞれ範囲値の下限と上限の包含性をテストします。</target>
        </trans-unit>
        <trans-unit id="f9b6f07f168f9bab47cb0d63914798ab55512000" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;lower_inf&lt;/code&gt; and &lt;code&gt;upper_inf&lt;/code&gt; test for infinite lower and upper bounds of a range, respectively.</source>
          <target state="translated">関数 &lt;code&gt;lower_inf&lt;/code&gt; と &lt;code&gt;upper_inf&lt;/code&gt; は、それぞれ範囲の無限の下限と上限をテストします。</target>
        </trans-unit>
        <trans-unit id="f703d74ff7244a4147930578a835fc919fa68d3e" translate="yes" xml:space="preserve">
          <source>The functions above that operate on tables or indexes accept a &lt;code&gt;regclass&lt;/code&gt; argument, which is simply the OID of the table or index in the &lt;code&gt;pg_class&lt;/code&gt; system catalog. You do not have to look up the OID by hand, however, since the &lt;code&gt;regclass&lt;/code&gt; data type's input converter will do the work for you. Just write the table name enclosed in single quotes so that it looks like a literal constant. For compatibility with the handling of ordinary SQL names, the string will be converted to lower case unless it contains double quotes around the table name.</source>
          <target state="translated">上記のテーブルまたはインデックスを操作する関数は、 &lt;code&gt;regclass&lt;/code&gt; 引数を受け入れます。これは、 &lt;code&gt;pg_class&lt;/code&gt; システムカタログ内のテーブルまたはインデックスのOIDです。ただし、 &lt;code&gt;regclass&lt;/code&gt; データ型の入力コンバーターが機能するため、OIDを手動で検索する必要はありません。リテラル定数のように見えるように、単一引用符で囲まれたテーブル名を記述します。通常のSQL名の処理との互換性を保つため、テーブル名の前後に二重引用符が含まれていない限り、文字列は小文字に変換されます。</target>
        </trans-unit>
        <trans-unit id="c0e923506f65e63b3dddbd22a7fb5e1606f3b604" translate="yes" xml:space="preserve">
          <source>The functions and function-like expressions described in this section operate on values of type &lt;code&gt;xml&lt;/code&gt;. See &lt;a href=&quot;datatype-xml&quot;&gt;Section 8.13&lt;/a&gt; for information about the &lt;code&gt;xml&lt;/code&gt; type. The function-like expressions &lt;code&gt;xmlparse&lt;/code&gt; and &lt;code&gt;xmlserialize&lt;/code&gt; for converting to and from type &lt;code&gt;xml&lt;/code&gt; are documented there, not in this section.</source>
          <target state="translated">このセクションで説明する関数と関数のような式は、 &lt;code&gt;xml&lt;/code&gt; 型の値を操作します。 &lt;code&gt;xml&lt;/code&gt; タイプについては、&lt;a href=&quot;datatype-xml&quot;&gt;8.13&lt;/a&gt;項を参照してください。 &lt;code&gt;xml&lt;/code&gt; 型との &lt;code&gt;xmlserialize&lt;/code&gt; で変換するための関数のような式 &lt;code&gt;xmlparse&lt;/code&gt; およびxmlserializeは、このセクションではなく、ドキュメント化されています。</target>
        </trans-unit>
        <trans-unit id="446413d467bd2bbb60b9839ce5313e8b03a2051d" translate="yes" xml:space="preserve">
          <source>The functions and operators that can be used in filter expressions are listed in &lt;a href=&quot;functions-json#FUNCTIONS-SQLJSON-FILTER-EX-TABLE&quot;&gt;Table 9.49&lt;/a&gt;. Within a filter expression, the &lt;code&gt;@&lt;/code&gt; variable denotes the value being filtered (i.e., one result of the preceding path step). You can write accessor operators after &lt;code&gt;@&lt;/code&gt; to retrieve component items.</source>
          <target state="translated">The functions and operators that can be used in filter expressions are listed in &lt;a href=&quot;functions-json#FUNCTIONS-SQLJSON-FILTER-EX-TABLE&quot;&gt;Table 9.49&lt;/a&gt;. Within a filter expression, the &lt;code&gt;@&lt;/code&gt; variable denotes the value being filtered (i.e., one result of the preceding path step). You can write accessor operators after &lt;code&gt;@&lt;/code&gt; to retrieve component items.</target>
        </trans-unit>
        <trans-unit id="6ccb73aae614647b2269d26a350b909a44513b27" translate="yes" xml:space="preserve">
          <source>The functions described in &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-BACKUP&quot;&gt;Section 9.26.3&lt;/a&gt;, &lt;a href=&quot;functions-admin#FUNCTIONS-RECOVERY-CONTROL&quot;&gt;Section 9.26.4&lt;/a&gt;, and &lt;a href=&quot;functions-admin#FUNCTIONS-SNAPSHOT-SYNCHRONIZATION&quot;&gt;Section 9.26.5&lt;/a&gt; are also relevant for replication.</source>
          <target state="translated">&lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-BACKUP&quot;&gt;セクション9.26.3&lt;/a&gt;、&lt;a href=&quot;functions-admin#FUNCTIONS-RECOVERY-CONTROL&quot;&gt;セクション9.26.4&lt;/a&gt;、および&lt;a href=&quot;functions-admin#FUNCTIONS-SNAPSHOT-SYNCHRONIZATION&quot;&gt;セクション9.26.5で&lt;/a&gt;説明されている関数は、レプリケーションにも関連しています。</target>
        </trans-unit>
        <trans-unit id="b81751fa3955355b5d3a556c7a3d013468731610" translate="yes" xml:space="preserve">
          <source>The functions described in &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-BACKUP&quot;&gt;Section 9.27.3&lt;/a&gt;, &lt;a href=&quot;functions-admin#FUNCTIONS-RECOVERY-CONTROL&quot;&gt;Section 9.27.4&lt;/a&gt;, and &lt;a href=&quot;functions-admin#FUNCTIONS-SNAPSHOT-SYNCHRONIZATION&quot;&gt;Section 9.27.5&lt;/a&gt; are also relevant for replication.</source>
          <target state="translated">The functions described in &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-BACKUP&quot;&gt;Section 9.27.3&lt;/a&gt;, &lt;a href=&quot;functions-admin#FUNCTIONS-RECOVERY-CONTROL&quot;&gt;Section 9.27.4&lt;/a&gt;, and &lt;a href=&quot;functions-admin#FUNCTIONS-SNAPSHOT-SYNCHRONIZATION&quot;&gt;Section 9.27.5&lt;/a&gt; are also relevant for replication.</target>
        </trans-unit>
        <trans-unit id="e464a1af28710d4a1fd7e811bd3d0475c5576752" translate="yes" xml:space="preserve">
          <source>The functions described in this section are used to control and monitor a PostgreSQL installation.</source>
          <target state="translated">このセクションで説明する関数は、PostgreSQLのインストールを制御・監視するために使用します。</target>
        </trans-unit>
        <trans-unit id="01945498ca90e6ae3cd1d1b921c28c9c72aead1f" translate="yes" xml:space="preserve">
          <source>The functions here implement the encryption part of the OpenPGP (RFC 4880) standard. Supported are both symmetric-key and public-key encryption.</source>
          <target state="translated">この関数は、OpenPGP (RFC 4880)規格の暗号化部分を実装しています。対称鍵暗号化と公開鍵暗号化の両方をサポートしています。</target>
        </trans-unit>
        <trans-unit id="122b22a585b5cb5a2901cc7acf3393bb3b507311" translate="yes" xml:space="preserve">
          <source>The functions in &lt;a href=&quot;functions-textsearch#TEXTSEARCH-FUNCTIONS-DEBUG-TABLE&quot;&gt;Table 9.43&lt;/a&gt; are listed separately because they are not usually used in everyday text searching operations. They are helpful for development and debugging of new text search configurations.</source>
          <target state="translated">&lt;a href=&quot;functions-textsearch#TEXTSEARCH-FUNCTIONS-DEBUG-TABLE&quot;&gt;表9.43&lt;/a&gt;の関数は、通常、日常のテキスト検索操作では使用されないため、個別にリストされています。新しいテキスト検索構成の開発とデバッグに役立ちます。</target>
        </trans-unit>
        <trans-unit id="c6ad12baa54d39c8fc88a5e6e9a85448981c7055" translate="yes" xml:space="preserve">
          <source>The functions in &lt;a href=&quot;functions-textsearch#TEXTSEARCH-FUNCTIONS-DEBUG-TABLE&quot;&gt;Table 9.43&lt;/a&gt; are listed separately because they are not usually used in everyday text searching operations. They are primarily helpful for development and debugging of new text search configurations.</source>
          <target state="translated">The functions in &lt;a href=&quot;functions-textsearch#TEXTSEARCH-FUNCTIONS-DEBUG-TABLE&quot;&gt;Table 9.43&lt;/a&gt; are listed separately because they are not usually used in everyday text searching operations. They are primarily helpful for development and debugging of new text search configurations.</target>
        </trans-unit>
        <trans-unit id="60ec00f1a0d952540e42b411ff256f01a844ba9a" translate="yes" xml:space="preserve">
          <source>The functions listed in &lt;a href=&quot;pgbench#PGBENCH-FUNCTIONS&quot;&gt;Table 259&lt;/a&gt; are built into pgbench and may be used in expressions appearing in &lt;a href=&quot;pgbench#PGBENCH-METACOMMAND-SET&quot;&gt;&lt;code&gt;\set&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;pgbench#PGBENCH-FUNCTIONS&quot;&gt;表259に&lt;/a&gt;リストされている関数はpgbenchに組み込まれており、&lt;a href=&quot;pgbench#PGBENCH-METACOMMAND-SET&quot;&gt; &lt;code&gt;\set&lt;/code&gt; &lt;/a&gt;現れる式で使用できます。</target>
        </trans-unit>
        <trans-unit id="eb877f9037b63b7fb5ec45e9dfbcbce68a00d900" translate="yes" xml:space="preserve">
          <source>The functions listed in &lt;a href=&quot;pgbench#PGBENCH-FUNCTIONS&quot;&gt;Table 275&lt;/a&gt; are built into pgbench and may be used in expressions appearing in &lt;a href=&quot;pgbench#PGBENCH-METACOMMAND-SET&quot;&gt;&lt;code&gt;\set&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">The functions listed in &lt;a href=&quot;pgbench#PGBENCH-FUNCTIONS&quot;&gt;Table 275&lt;/a&gt; are built into pgbench and may be used in expressions appearing in &lt;a href=&quot;pgbench#PGBENCH-METACOMMAND-SET&quot;&gt; &lt;code&gt;\set&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="1d976c2e21ce82fc5ee166341bd65f2f942d7585" translate="yes" xml:space="preserve">
          <source>The functions provided by the &lt;code&gt;intarray&lt;/code&gt; module are shown in &lt;a href=&quot;intarray#INTARRAY-FUNC-TABLE&quot;&gt;Table F.9&lt;/a&gt;, the operators in &lt;a href=&quot;intarray#INTARRAY-OP-TABLE&quot;&gt;Table F.10&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;intarray&lt;/code&gt; モジュールが提供する関数を&lt;a href=&quot;intarray#INTARRAY-FUNC-TABLE&quot;&gt;表F.9&lt;/a&gt;に、演算子を&lt;a href=&quot;intarray#INTARRAY-OP-TABLE&quot;&gt;表F.10に示し&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="589cd253a59ec741e7593831b0243a0b8a47c194" translate="yes" xml:space="preserve">
          <source>The functions provided by the &lt;code&gt;pg_trgm&lt;/code&gt; module are shown in &lt;a href=&quot;pgtrgm#PGTRGM-FUNC-TABLE&quot;&gt;Table F.24&lt;/a&gt;, the operators in &lt;a href=&quot;pgtrgm#PGTRGM-OP-TABLE&quot;&gt;Table F.25&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;pg_trgm&lt;/code&gt; モジュールによって提供される関数は、&lt;a href=&quot;pgtrgm#PGTRGM-FUNC-TABLE&quot;&gt;表F.24の&lt;/a&gt;&lt;a href=&quot;pgtrgm#PGTRGM-OP-TABLE&quot;&gt;表F.25の&lt;/a&gt;演算子に示されています。</target>
        </trans-unit>
        <trans-unit id="5afb7a5be90f1ea0d87d155bbd2bc796569625a1" translate="yes" xml:space="preserve">
          <source>The functions provided to manipulate advisory locks are described in &lt;a href=&quot;functions-admin#FUNCTIONS-ADVISORY-LOCKS&quot;&gt;Section 9.26.10&lt;/a&gt;.</source>
          <target state="translated">勧告的ロックを操作するために提供される関数については、&lt;a href=&quot;functions-admin#FUNCTIONS-ADVISORY-LOCKS&quot;&gt;セクション9.26.10で&lt;/a&gt;説明されています。</target>
        </trans-unit>
        <trans-unit id="7cd30982d3557c91a4d774832819968f49725f2e" translate="yes" xml:space="preserve">
          <source>The functions provided to manipulate advisory locks are described in &lt;a href=&quot;functions-admin#FUNCTIONS-ADVISORY-LOCKS&quot;&gt;Section 9.27.10&lt;/a&gt;.</source>
          <target state="translated">The functions provided to manipulate advisory locks are described in &lt;a href=&quot;functions-admin#FUNCTIONS-ADVISORY-LOCKS&quot;&gt;Section 9.27.10&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="29ef1c3ef042af3960555b6b81e0fa70ed4d457f" translate="yes" xml:space="preserve">
          <source>The functions shown in &lt;a href=&quot;adminpack#FUNCTIONS-ADMINPACK-TABLE&quot;&gt;Table F.1&lt;/a&gt; provide write access to files on the machine hosting the server. (See also the functions in &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-GENFILE-TABLE&quot;&gt;Table 9.94&lt;/a&gt;, which provide read-only access.) Only files within the database cluster directory can be accessed, unless the user is a superuser or given one of the pg_read_server_files, or pg_write_server_files roles, as appropriate for the function, but either a relative or absolute path is allowable.</source>
          <target state="translated">&lt;a href=&quot;adminpack#FUNCTIONS-ADMINPACK-TABLE&quot;&gt;表F.1に&lt;/a&gt;示す関数は、サーバーをホストしているマシン上のファイルへの書き込みアクセスを提供します。 （読み取り専用アクセスを提供する&lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-GENFILE-TABLE&quot;&gt;Table 9.94&lt;/a&gt;の関数も参照してください。）ユーザーがスーパーユーザーであるか、関数に応じてpg_read_server_filesまたはpg_write_server_filesロールのいずれかが与えられていない限り、データベースクラスターディレクトリ内のファイルのみにアクセスできます。ですが、相対パスまたは絶対パスのいずれかを使用できます。</target>
        </trans-unit>
        <trans-unit id="70cd1eb89b2a38aa3978efc4d80de7d291b55bb8" translate="yes" xml:space="preserve">
          <source>The functions shown in &lt;a href=&quot;adminpack#FUNCTIONS-ADMINPACK-TABLE&quot;&gt;Table F.1&lt;/a&gt; provide write access to files on the machine hosting the server. (See also the functions in &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-GENFILE-TABLE&quot;&gt;Table 9.95&lt;/a&gt;, which provide read-only access.) Only files within the database cluster directory can be accessed, unless the user is a superuser or given one of the pg_read_server_files, or pg_write_server_files roles, as appropriate for the function, but either a relative or absolute path is allowable.</source>
          <target state="translated">The functions shown in &lt;a href=&quot;adminpack#FUNCTIONS-ADMINPACK-TABLE&quot;&gt;Table F.1&lt;/a&gt; provide write access to files on the machine hosting the server. (See also the functions in &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-GENFILE-TABLE&quot;&gt;Table 9.95&lt;/a&gt;, which provide read-only access.) Only files within the database cluster directory can be accessed, unless the user is a superuser or given one of the pg_read_server_files, or pg_write_server_files roles, as appropriate for the function, but either a relative or absolute path is allowable.</target>
        </trans-unit>
        <trans-unit id="af557d79922e415d01771dc33cbf93a73edbe83c" translate="yes" xml:space="preserve">
          <source>The functions shown in &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-BACKUP-TABLE&quot;&gt;Table 9.84&lt;/a&gt; assist in making on-line backups. These functions cannot be executed during recovery (except non-exclusive &lt;code&gt;pg_start_backup&lt;/code&gt;, non-exclusive &lt;code&gt;pg_stop_backup&lt;/code&gt;, &lt;code&gt;pg_is_in_backup&lt;/code&gt;, &lt;code&gt;pg_backup_start_time&lt;/code&gt; and &lt;code&gt;pg_wal_lsn_diff&lt;/code&gt;).</source>
          <target state="translated">&lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-BACKUP-TABLE&quot;&gt;表9.84に&lt;/a&gt;示す関数は、オンラインバックアップの作成に役立ちます。これらの関数は、リカバリ中に実行できません（非排他的な &lt;code&gt;pg_start_backup&lt;/code&gt; 、非排他的な &lt;code&gt;pg_stop_backup&lt;/code&gt; 、 &lt;code&gt;pg_is_in_backup&lt;/code&gt; 、 &lt;code&gt;pg_backup_start_time&lt;/code&gt; 、および &lt;code&gt;pg_wal_lsn_diff&lt;/code&gt; を除く）。</target>
        </trans-unit>
        <trans-unit id="fbbf6edb07e082e01233d3732d43204b4655cc4b" translate="yes" xml:space="preserve">
          <source>The functions shown in &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-BACKUP-TABLE&quot;&gt;Table 9.85&lt;/a&gt; assist in making on-line backups. These functions cannot be executed during recovery (except non-exclusive &lt;code&gt;pg_start_backup&lt;/code&gt;, non-exclusive &lt;code&gt;pg_stop_backup&lt;/code&gt;, &lt;code&gt;pg_is_in_backup&lt;/code&gt;, &lt;code&gt;pg_backup_start_time&lt;/code&gt; and &lt;code&gt;pg_wal_lsn_diff&lt;/code&gt;).</source>
          <target state="translated">The functions shown in &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-BACKUP-TABLE&quot;&gt;Table 9.85&lt;/a&gt; assist in making on-line backups. These functions cannot be executed during recovery (except non-exclusive &lt;code&gt;pg_start_backup&lt;/code&gt; , non-exclusive &lt;code&gt;pg_stop_backup&lt;/code&gt; , &lt;code&gt;pg_is_in_backup&lt;/code&gt; , &lt;code&gt;pg_backup_start_time&lt;/code&gt; and &lt;code&gt;pg_wal_lsn_diff&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="3f2948c9238f28bd4ff2bb40ce8791d0b13005bd" translate="yes" xml:space="preserve">
          <source>The functions shown in &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-DBLOCATION&quot;&gt;Table 9.90&lt;/a&gt; assist in identifying the specific disk files associated with database objects.</source>
          <target state="translated">&lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-DBLOCATION&quot;&gt;表9.90に&lt;/a&gt;示す関数は、データベースオブジェクトに関連付けられた特定のディスクファイルを識別するのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="862902fc740913f3db230495f16a3481a70b3805" translate="yes" xml:space="preserve">
          <source>The functions shown in &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-DBLOCATION&quot;&gt;Table 9.91&lt;/a&gt; assist in identifying the specific disk files associated with database objects.</source>
          <target state="translated">The functions shown in &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-DBLOCATION&quot;&gt;Table 9.91&lt;/a&gt; assist in identifying the specific disk files associated with database objects.</target>
        </trans-unit>
        <trans-unit id="3d92b50819e3d60d5191300256c8390d3bc20d24" translate="yes" xml:space="preserve">
          <source>The functions shown in &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-DBSIZE&quot;&gt;Table 9.89&lt;/a&gt; calculate the disk space usage of database objects.</source>
          <target state="translated">&lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-DBSIZE&quot;&gt;表9.89に&lt;/a&gt;示す関数は、データベースオブジェクトのディスク領域の使用量を計算します。</target>
        </trans-unit>
        <trans-unit id="4a83057be3a29505df68ff81363e61d91a887e44" translate="yes" xml:space="preserve">
          <source>The functions shown in &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-DBSIZE&quot;&gt;Table 9.90&lt;/a&gt; calculate the disk space usage of database objects, or assist in presentation of usage results. All these functions return sizes measured in bytes. If an OID that does not represent an existing object is passed to one of these functions, &lt;code&gt;NULL&lt;/code&gt; is returned.</source>
          <target state="translated">The functions shown in &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-DBSIZE&quot;&gt;Table 9.90&lt;/a&gt; calculate the disk space usage of database objects, or assist in presentation of usage results. All these functions return sizes measured in bytes. If an OID that does not represent an existing object is passed to one of these functions, &lt;code&gt;NULL&lt;/code&gt; is returned.</target>
        </trans-unit>
        <trans-unit id="596d61caa752f0c6f6982e0c8634c7eacfed18b6" translate="yes" xml:space="preserve">
          <source>The functions shown in &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-GENFILE-TABLE&quot;&gt;Table 9.94&lt;/a&gt; provide native access to files on the machine hosting the server. Only files within the database cluster directory and the &lt;code&gt;log_directory&lt;/code&gt; can be accessed unless the user is granted the role &lt;code&gt;pg_read_server_files&lt;/code&gt;. Use a relative path for files in the cluster directory, and a path matching the &lt;code&gt;log_directory&lt;/code&gt; configuration setting for log files.</source>
          <target state="translated">&lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-GENFILE-TABLE&quot;&gt;表9.94に&lt;/a&gt;示す関数は、サーバーをホストしているマシン上のファイルへのネイティブアクセスを提供します。ユーザーに &lt;code&gt;pg_read_server_files&lt;/code&gt; ロールが付与されていない限り、データベースクラスターディレクトリと &lt;code&gt;log_directory&lt;/code&gt; 内のファイルにのみアクセスできます。クラスターディレクトリ内のファイルの相対パスと、ログファイルの &lt;code&gt;log_directory&lt;/code&gt; 構成設定と一致するパスを使用します。</target>
        </trans-unit>
        <trans-unit id="e2846b4d9144cb92c1cdd58938547d8a0b822c70" translate="yes" xml:space="preserve">
          <source>The functions shown in &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-GENFILE-TABLE&quot;&gt;Table 9.95&lt;/a&gt; provide native access to files on the machine hosting the server. Only files within the database cluster directory and the &lt;code&gt;log_directory&lt;/code&gt; can be accessed, unless the user is a superuser or is granted the role &lt;code&gt;pg_read_server_files&lt;/code&gt;. Use a relative path for files in the cluster directory, and a path matching the &lt;code&gt;log_directory&lt;/code&gt; configuration setting for log files.</source>
          <target state="translated">The functions shown in &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-GENFILE-TABLE&quot;&gt;Table 9.95&lt;/a&gt; provide native access to files on the machine hosting the server. Only files within the database cluster directory and the &lt;code&gt;log_directory&lt;/code&gt; can be accessed, unless the user is a superuser or is granted the role &lt;code&gt;pg_read_server_files&lt;/code&gt; . Use a relative path for files in the cluster directory, and a path matching the &lt;code&gt;log_directory&lt;/code&gt; configuration setting for log files.</target>
        </trans-unit>
        <trans-unit id="f3c73f231d92075fb0c71fc7740bf5175d685468" translate="yes" xml:space="preserve">
          <source>The functions shown in &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-SIGNAL-TABLE&quot;&gt;Table 9.83&lt;/a&gt; send control signals to other server processes. Use of these functions is restricted to superusers by default but access may be granted to others using &lt;code&gt;GRANT&lt;/code&gt;, with noted exceptions.</source>
          <target state="translated">&lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-SIGNAL-TABLE&quot;&gt;表9.83に&lt;/a&gt;示す関数は、制御信号を他のサーバープロセスに送信します。これらの関数の使用は、デフォルトではスーパーユーザーに制限されていますが、注記された例外を除いて、 &lt;code&gt;GRANT&lt;/code&gt; を使用して他のユーザーにアクセスを許可することができます。</target>
        </trans-unit>
        <trans-unit id="3a4405481fecb5e6303cc2c9e6917c8fc5078234" translate="yes" xml:space="preserve">
          <source>The functions shown in &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-SIGNAL-TABLE&quot;&gt;Table 9.84&lt;/a&gt; send control signals to other server processes. Use of these functions is restricted to superusers by default but access may be granted to others using &lt;code&gt;GRANT&lt;/code&gt;, with noted exceptions.</source>
          <target state="translated">The functions shown in &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-SIGNAL-TABLE&quot;&gt;Table 9.84&lt;/a&gt; send control signals to other server processes. Use of these functions is restricted to superusers by default but access may be granted to others using &lt;code&gt;GRANT&lt;/code&gt; , with noted exceptions.</target>
        </trans-unit>
        <trans-unit id="11868a349a93977f4f568672a07b5dec83a888d7" translate="yes" xml:space="preserve">
          <source>The functions shown in &lt;a href=&quot;functions-admin#FUNCTIONS-ADVISORY-LOCKS-TABLE&quot;&gt;Table 9.95&lt;/a&gt; manage advisory locks. For details about proper use of these functions, see &lt;a href=&quot;explicit-locking#ADVISORY-LOCKS&quot;&gt;Section 13.3.5&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;functions-admin#FUNCTIONS-ADVISORY-LOCKS-TABLE&quot;&gt;表9.95に&lt;/a&gt;示す関数は、勧告的ロックを管理します。これらの関数の適切な使用の詳細については、&lt;a href=&quot;explicit-locking#ADVISORY-LOCKS&quot;&gt;セクション13.3.5を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="0b59303348c39a352bb589d8b03735abeb1beeb3" translate="yes" xml:space="preserve">
          <source>The functions shown in &lt;a href=&quot;functions-admin#FUNCTIONS-ADVISORY-LOCKS-TABLE&quot;&gt;Table 9.96&lt;/a&gt; manage advisory locks. For details about proper use of these functions, see &lt;a href=&quot;explicit-locking#ADVISORY-LOCKS&quot;&gt;Section 13.3.5&lt;/a&gt;.</source>
          <target state="translated">The functions shown in &lt;a href=&quot;functions-admin#FUNCTIONS-ADVISORY-LOCKS-TABLE&quot;&gt;Table 9.96&lt;/a&gt; manage advisory locks. For details about proper use of these functions, see &lt;a href=&quot;explicit-locking#ADVISORY-LOCKS&quot;&gt;Section 13.3.5&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="ba997e6585ffd2ebf0df203e2718f49b87e3ad76" translate="yes" xml:space="preserve">
          <source>The functions shown in &lt;a href=&quot;functions-admin#FUNCTIONS-RECOVERY-CONTROL-TABLE&quot;&gt;Table 9.86&lt;/a&gt; control the progress of recovery. These functions may be executed only during recovery.</source>
          <target state="translated">&lt;a href=&quot;functions-admin#FUNCTIONS-RECOVERY-CONTROL-TABLE&quot;&gt;表9.86に&lt;/a&gt;示す関数は、リカバリーの進行を制御します。これらの機能は、リカバリ中にのみ実行できます。</target>
        </trans-unit>
        <trans-unit id="127dcdaf3c316cf3d90889d6aee1511f65db73de" translate="yes" xml:space="preserve">
          <source>The functions shown in &lt;a href=&quot;functions-admin#FUNCTIONS-RECOVERY-CONTROL-TABLE&quot;&gt;Table 9.87&lt;/a&gt; control the progress of recovery. These functions may be executed only during recovery.</source>
          <target state="translated">The functions shown in &lt;a href=&quot;functions-admin#FUNCTIONS-RECOVERY-CONTROL-TABLE&quot;&gt;Table 9.87&lt;/a&gt; control the progress of recovery. These functions may be executed only during recovery.</target>
        </trans-unit>
        <trans-unit id="8cf9851935069d5da8579d648493492e0773919e" translate="yes" xml:space="preserve">
          <source>The functions shown in &lt;a href=&quot;functions-admin#FUNCTIONS-RECOVERY-INFO-TABLE&quot;&gt;Table 9.85&lt;/a&gt; provide information about the current status of the standby. These functions may be executed both during recovery and in normal running.</source>
          <target state="translated">&lt;a href=&quot;functions-admin#FUNCTIONS-RECOVERY-INFO-TABLE&quot;&gt;表9.85に&lt;/a&gt;示す関数は、スタンバイの現在のステータスに関する情報を提供します。これらの機能は、リカバリ時と通常の実行時の両方で実行できます。</target>
        </trans-unit>
        <trans-unit id="341a6188170e97e18176dfb27299fdbe78c52ae6" translate="yes" xml:space="preserve">
          <source>The functions shown in &lt;a href=&quot;functions-admin#FUNCTIONS-RECOVERY-INFO-TABLE&quot;&gt;Table 9.86&lt;/a&gt; provide information about the current status of a standby server. These functions may be executed both during recovery and in normal running.</source>
          <target state="translated">The functions shown in &lt;a href=&quot;functions-admin#FUNCTIONS-RECOVERY-INFO-TABLE&quot;&gt;Table 9.86&lt;/a&gt; provide information about the current status of a standby server. These functions may be executed both during recovery and in normal running.</target>
        </trans-unit>
        <trans-unit id="64ba5a0a32a32de29b727183748ebc1db30a8063" translate="yes" xml:space="preserve">
          <source>The functions shown in &lt;a href=&quot;functions-admin#FUNCTIONS-REPLICATION-TABLE&quot;&gt;Table 9.88&lt;/a&gt; are for controlling and interacting with replication features. See &lt;a href=&quot;warm-standby#STREAMING-REPLICATION&quot;&gt;Section 26.2.5&lt;/a&gt;, &lt;a href=&quot;warm-standby#STREAMING-REPLICATION-SLOTS&quot;&gt;Section 26.2.6&lt;/a&gt;, and &lt;a href=&quot;https://www.postgresql.org/docs/12/replication-origins.html&quot;&gt;Chapter 49&lt;/a&gt; for information about the underlying features. Use of functions for replication origin is restricted to superusers. Use of functions for replication slot is restricted to superusers and users having &lt;code&gt;REPLICATION&lt;/code&gt; privilege.</source>
          <target state="translated">&lt;a href=&quot;functions-admin#FUNCTIONS-REPLICATION-TABLE&quot;&gt;表9.88に&lt;/a&gt;示す関数は、複製機能を制御および操作するためのものです。基礎となる機能については、&lt;a href=&quot;warm-standby#STREAMING-REPLICATION&quot;&gt;セクション26.2.5&lt;/a&gt;、&lt;a href=&quot;warm-standby#STREAMING-REPLICATION-SLOTS&quot;&gt;セクション26.2.6&lt;/a&gt;、および&lt;a href=&quot;https://www.postgresql.org/docs/12/replication-origins.html&quot;&gt;第49章を&lt;/a&gt;参照してください。複製元の関数の使用はスーパーユーザーに制限されています。複製スロットの関数の使用は、スーパーユーザーと &lt;code&gt;REPLICATION&lt;/code&gt; 特権を持つユーザーに制限されています。</target>
        </trans-unit>
        <trans-unit id="0dad85ba1196a94eeff1c17a7e2716734fef21a9" translate="yes" xml:space="preserve">
          <source>The functions shown in &lt;a href=&quot;functions-admin#FUNCTIONS-REPLICATION-TABLE&quot;&gt;Table 9.89&lt;/a&gt; are for controlling and interacting with replication features. See &lt;a href=&quot;warm-standby#STREAMING-REPLICATION&quot;&gt;Section 26.2.5&lt;/a&gt;, &lt;a href=&quot;warm-standby#STREAMING-REPLICATION-SLOTS&quot;&gt;Section 26.2.6&lt;/a&gt;, and &lt;a href=&quot;https://www.postgresql.org/docs/13/replication-origins.html&quot;&gt;Chapter 49&lt;/a&gt; for information about the underlying features. Use of functions for replication origin is restricted to superusers. Use of functions for replication slots is restricted to superusers and users having &lt;code&gt;REPLICATION&lt;/code&gt; privilege.</source>
          <target state="translated">The functions shown in &lt;a href=&quot;functions-admin#FUNCTIONS-REPLICATION-TABLE&quot;&gt;Table 9.89&lt;/a&gt; are for controlling and interacting with replication features. See &lt;a href=&quot;warm-standby#STREAMING-REPLICATION&quot;&gt;Section 26.2.5&lt;/a&gt;, &lt;a href=&quot;warm-standby#STREAMING-REPLICATION-SLOTS&quot;&gt;Section 26.2.6&lt;/a&gt;, and &lt;a href=&quot;https://www.postgresql.org/docs/13/replication-origins.html&quot;&gt;Chapter 49&lt;/a&gt; for information about the underlying features. Use of functions for replication origin is restricted to superusers. Use of functions for replication slots is restricted to superusers and users having &lt;code&gt;REPLICATION&lt;/code&gt; privilege.</target>
        </trans-unit>
        <trans-unit id="423b085ba2dc236f90217ee4b570443351039e1a" translate="yes" xml:space="preserve">
          <source>The functions shown in &lt;a href=&quot;functions-info#FUNCTIONS-COMMIT-TIMESTAMP&quot;&gt;Table 9.76&lt;/a&gt; provide information about transactions that have been already committed. These functions mainly provide information about when the transactions were committed. They only provide useful data when &lt;a href=&quot;runtime-config-replication#GUC-TRACK-COMMIT-TIMESTAMP&quot;&gt;track_commit_timestamp&lt;/a&gt; configuration option is enabled and only for transactions that were committed after it was enabled.</source>
          <target state="translated">&lt;a href=&quot;functions-info#FUNCTIONS-COMMIT-TIMESTAMP&quot;&gt;表9.76に&lt;/a&gt;示す関数は、すでにコミットされているトランザクションに関する情報を提供します。これらの関数は、主にトランザクションがいつコミットされたかに関する情報を提供します。これらは、&lt;a href=&quot;runtime-config-replication#GUC-TRACK-COMMIT-TIMESTAMP&quot;&gt;track_commit_timestamp&lt;/a&gt;構成オプションが有効になっている場合、および有効にされた後にコミットされたトランザクションに対してのみ、有用なデータを提供します。</target>
        </trans-unit>
        <trans-unit id="d456c632c2c97e3b05a72328c838d9913de5f8d0" translate="yes" xml:space="preserve">
          <source>The functions shown in &lt;a href=&quot;functions-info#FUNCTIONS-COMMIT-TIMESTAMP&quot;&gt;Table 9.77&lt;/a&gt; provide information about when past transactions were committed. They only provide useful data when the &lt;a href=&quot;runtime-config-replication#GUC-TRACK-COMMIT-TIMESTAMP&quot;&gt;track_commit_timestamp&lt;/a&gt; configuration option is enabled, and only for transactions that were committed after it was enabled.</source>
          <target state="translated">The functions shown in &lt;a href=&quot;functions-info#FUNCTIONS-COMMIT-TIMESTAMP&quot;&gt;Table 9.77&lt;/a&gt; provide information about when past transactions were committed. They only provide useful data when the &lt;a href=&quot;runtime-config-replication#GUC-TRACK-COMMIT-TIMESTAMP&quot;&gt;track_commit_timestamp&lt;/a&gt; configuration option is enabled, and only for transactions that were committed after it was enabled.</target>
        </trans-unit>
        <trans-unit id="6bfe1a4de569556a1d516d3985556b63d6f6146f" translate="yes" xml:space="preserve">
          <source>The functions shown in &lt;a href=&quot;functions-info#FUNCTIONS-CONTROLDATA&quot;&gt;Table 9.77&lt;/a&gt; print information initialized during &lt;code&gt;initdb&lt;/code&gt;, such as the catalog version. They also show information about write-ahead logging and checkpoint processing. This information is cluster-wide, and not specific to any one database. They provide most of the same information, from the same source, as &lt;a href=&quot;app-pgcontroldata&quot;&gt;pg_controldata&lt;/a&gt;, although in a form better suited to SQL functions.</source>
          <target state="translated">&lt;a href=&quot;functions-info#FUNCTIONS-CONTROLDATA&quot;&gt;表9.77に&lt;/a&gt;示す関数は、カタログのバージョンなど、 &lt;code&gt;initdb&lt;/code&gt; 中に初期化された情報を出力します。また、先読みロギングとチェックポイント処理に関する情報も表示されます。この情報はクラスター全体にわたるものであり、特定のデータベースに固有のものではありません。それらは、&lt;a href=&quot;app-pgcontroldata&quot;&gt;pg_controldata&lt;/a&gt;と同じソースから同じ情報のほとんどを提供しますが、SQL関数により適した形式です。</target>
        </trans-unit>
        <trans-unit id="f4644a53e9bb9e3b709daab47cfd9c549aaf8f50" translate="yes" xml:space="preserve">
          <source>The functions shown in &lt;a href=&quot;functions-info#FUNCTIONS-CONTROLDATA&quot;&gt;Table 9.78&lt;/a&gt; print information initialized during &lt;code&gt;initdb&lt;/code&gt;, such as the catalog version. They also show information about write-ahead logging and checkpoint processing. This information is cluster-wide, not specific to any one database. These functions provide most of the same information, from the same source, as the &lt;a href=&quot;app-pgcontroldata&quot;&gt;pg_controldata&lt;/a&gt; application.</source>
          <target state="translated">The functions shown in &lt;a href=&quot;functions-info#FUNCTIONS-CONTROLDATA&quot;&gt;Table 9.78&lt;/a&gt; print information initialized during &lt;code&gt;initdb&lt;/code&gt; , such as the catalog version. They also show information about write-ahead logging and checkpoint processing. This information is cluster-wide, not specific to any one database. These functions provide most of the same information, from the same source, as the &lt;a href=&quot;app-pgcontroldata&quot;&gt;pg_controldata&lt;/a&gt; application.</target>
        </trans-unit>
        <trans-unit id="46311f3452a56adeb669710af158b1d331e3ba4e" translate="yes" xml:space="preserve">
          <source>The functions shown in &lt;a href=&quot;functions-info#FUNCTIONS-INFO-COMMENT-TABLE&quot;&gt;Table 9.73&lt;/a&gt; extract comments previously stored with the &lt;a href=&quot;sql-comment&quot;&gt;COMMENT&lt;/a&gt; command. A null value is returned if no comment could be found for the specified parameters.</source>
          <target state="translated">&lt;a href=&quot;functions-info#FUNCTIONS-INFO-COMMENT-TABLE&quot;&gt;表9.73に&lt;/a&gt;示す関数は、&lt;a href=&quot;sql-comment&quot;&gt;COMMENT&lt;/a&gt;コマンドで以前に保存されたコメントを抽出します。指定されたパラメーターのコメントが見つからなかった場合は、NULL値が返されます。</target>
        </trans-unit>
        <trans-unit id="d1b030aa28d10d3a864b72b4ee87a9054320e5c9" translate="yes" xml:space="preserve">
          <source>The functions shown in &lt;a href=&quot;functions-info#FUNCTIONS-PG-SNAPSHOT&quot;&gt;Table 9.74&lt;/a&gt; provide server transaction information in an exportable form. The main use of these functions is to determine which transactions were committed between two snapshots.</source>
          <target state="translated">The functions shown in &lt;a href=&quot;functions-info#FUNCTIONS-PG-SNAPSHOT&quot;&gt;Table 9.74&lt;/a&gt; provide server transaction information in an exportable form. The main use of these functions is to determine which transactions were committed between two snapshots.</target>
        </trans-unit>
        <trans-unit id="6f306d4b7a9229188bb697a19658366a35ce8588" translate="yes" xml:space="preserve">
          <source>The functions shown in &lt;a href=&quot;functions-info#FUNCTIONS-TXID-SNAPSHOT&quot;&gt;Table 9.74&lt;/a&gt; provide server transaction information in an exportable form. The main use of these functions is to determine which transactions were committed between two snapshots.</source>
          <target state="translated">&lt;a href=&quot;functions-info#FUNCTIONS-TXID-SNAPSHOT&quot;&gt;表9.74に&lt;/a&gt;示す関数は、サーバートランザクション情報をエクスポート可能な形式で提供します。これらの関数の主な用途は、2つのスナップショット間でコミットされたトランザクションを判別することです。</target>
        </trans-unit>
        <trans-unit id="9398f596a0390810b3e41d607c70ae410202516a" translate="yes" xml:space="preserve">
          <source>The functions verify various &lt;em&gt;invariants&lt;/em&gt; in the structure of the representation of particular relations. The correctness of the access method functions behind index scans and other important operations relies on these invariants always holding. For example, certain functions verify, among other things, that all B-Tree pages have items in &amp;ldquo;logical&amp;rdquo; order (e.g., for B-Tree indexes on &lt;code&gt;text&lt;/code&gt;, index tuples should be in collated lexical order). If that particular invariant somehow fails to hold, we can expect binary searches on the affected page to incorrectly guide index scans, resulting in wrong answers to SQL queries.</source>
          <target state="translated">関数は、特定の関係の表現の構造におけるさまざまな&lt;em&gt;不変条件&lt;/em&gt;を検証します。インデックススキャンやその他の重要な操作の背後にあるアクセス方法関数の正確性は、常に保持されているこれらの不変条件に依存しています。たとえば、特定の関数は、特に、すべてのBツリーページに「論理」順序のアイテムがあることを確認します（たとえば、 &lt;code&gt;text&lt;/code&gt; Bツリーインデックスの場合、インデックスタプルは照合された字句順である必要があります）。その特定の不変条件が何らかの理由で保持されない場合、影響を受けるページでのバイナリ検索がインデックススキャンを誤って導き、SQLクエリに対する誤った回答をもたらすことが予想されます。</target>
        </trans-unit>
        <trans-unit id="0d68a3d97b1b4428fbfcb9d0333819c6fcb3c2b0" translate="yes" xml:space="preserve">
          <source>The fundamental type of an XQuery/XPath expression, the &lt;code&gt;sequence&lt;/code&gt;, which can contain XML nodes, atomic values, or both, does not exist in XPath 1.0. A 1.0 expression can only produce a node-set (containing zero or more XML nodes), or a single atomic value.</source>
          <target state="translated">XQuery / XPath式の基本的なタイプである &lt;code&gt;sequence&lt;/code&gt; 、XMLノード、アトミック値、またはその両方を含むことができ、XPath 1.0には存在しません。1.0の式は、ノードセット（0個以上のXMLノードを含む）、または単一のアトミック値のみを生成できます。</target>
        </trans-unit>
        <trans-unit id="01481c12012dd36b33a9e59e6d02e28615f69f45" translate="yes" xml:space="preserve">
          <source>The general form of a recursive &lt;code&gt;WITH&lt;/code&gt; query is always a &lt;em&gt;non-recursive term&lt;/em&gt;, then &lt;code&gt;UNION&lt;/code&gt; (or &lt;code&gt;UNION ALL&lt;/code&gt;), then a &lt;em&gt;recursive term&lt;/em&gt;, where only the recursive term can contain a reference to the query's own output. Such a query is executed as follows:</source>
          <target state="translated">再帰的な &lt;code&gt;WITH&lt;/code&gt; クエリの一般的な形式は、常に&lt;em&gt;非再帰的な用語&lt;/em&gt;、次に &lt;code&gt;UNION&lt;/code&gt; （または &lt;code&gt;UNION ALL&lt;/code&gt; ）、次に&lt;em&gt;再帰的な用語です&lt;/em&gt;。この場合、再帰的な用語のみがクエリ自体の出力への参照を含むことができます。このようなクエリは次のように実行されます。</target>
        </trans-unit>
        <trans-unit id="8eee7d4e38c500df724907fbea7403f66500c981" translate="yes" xml:space="preserve">
          <source>The general format of the &lt;code&gt;pg_hba.conf&lt;/code&gt; file is a set of records, one per line. Blank lines are ignored, as is any text after the &lt;code&gt;#&lt;/code&gt; comment character. Records cannot be continued across lines. A record is made up of a number of fields which are separated by spaces and/or tabs. Fields can contain white space if the field value is double-quoted. Quoting one of the keywords in a database, user, or address field (e.g., &lt;code&gt;all&lt;/code&gt; or &lt;code&gt;replication&lt;/code&gt;) makes the word lose its special meaning, and just match a database, user, or host with that name.</source>
          <target state="translated">&lt;code&gt;pg_hba.conf&lt;/code&gt; ファイルの一般的な形式は、1行に1つのレコードのセットです。 &lt;code&gt;#&lt;/code&gt; コメント文字の後のテキストと同様に、空白行は無視されます。レコードは行をまたがって継続することはできません。レコードは、スペースやタブで区切られたいくつかのフィールドで構成されています。フィールド値が二重引用符で囲まれている場合、フィールドに空白を含めることができます。データベース、ユーザー、またはアドレスフィールド（たとえば、 &lt;code&gt;all&lt;/code&gt; または &lt;code&gt;replication&lt;/code&gt; ）のキーワードの1つを引用すると、その単語の特別な意味が失われ、データベース、ユーザー、またはホストがその名前と一致します。</target>
        </trans-unit>
        <trans-unit id="2ed177efb04faf95279eeefdbca2d0ce9a32d2a9" translate="yes" xml:space="preserve">
          <source>The general principle is that the contained object must match the containing object as to structure and data contents, possibly after discarding some non-matching array elements or object key/value pairs from the containing object. But remember that the order of array elements is not significant when doing a containment match, and duplicate array elements are effectively considered only once.</source>
          <target state="translated">一般的な原則は、含まれるオブジェクトは、構造とデータの内容に関して、含まれるオブジェクトと一致しなければならないということです。しかし、配列要素の順序は、格納物の一致を行う際には重要ではないことを覚えておいてください。</target>
        </trans-unit>
        <trans-unit id="ab5e9d694a644360b18b209b2a60b5fe2f2901b9" translate="yes" xml:space="preserve">
          <source>The general rule for configuring a list of dictionaries is to place first the most narrow, most specific dictionary, then the more general dictionaries, finishing with a very general dictionary, like a Snowball stemmer or &lt;code&gt;simple&lt;/code&gt;, which recognizes everything. For example, for an astronomy-specific search (&lt;code&gt;astro_en&lt;/code&gt; configuration) one could bind token type &lt;code&gt;asciiword&lt;/code&gt; (ASCII word) to a synonym dictionary of astronomical terms, a general English dictionary and a Snowball English stemmer:</source>
          <target state="translated">辞書のリストを構成するための一般的な規則は、最初に最も狭くて最も具体的な辞書を配置し、次により一般的な辞書を配置して、すべてを認識するSnowballステマーや &lt;code&gt;simple&lt;/code&gt; などの非常に一般的な辞書で終わります。たとえば、天文学固有の検索（ &lt;code&gt;astro_en&lt;/code&gt; 構成）の場合、トークンタイプの &lt;code&gt;asciiword&lt;/code&gt; （ASCIIワード）を、天文学用語の同義語辞書、一般的な英語辞書、Snowball英語ステマーにバインドできます。</target>
        </trans-unit>
        <trans-unit id="5f82a175fcf092449c33c188da71a078b0c24826" translate="yes" xml:space="preserve">
          <source>The generated array type's name is the scalar type's name with an underscore prepended. The array entry's other fields are filled from &lt;code&gt;BKI_ARRAY_DEFAULT(value)&lt;/code&gt; annotations in &lt;code&gt;pg_type.h&lt;/code&gt;, or if there isn't one, copied from the scalar type. (There's also a special case for &lt;code&gt;typalign&lt;/code&gt;.) Then the &lt;code&gt;typelem&lt;/code&gt; and &lt;code&gt;typarray&lt;/code&gt; fields of the two entries are set to cross-reference each other.</source>
          <target state="translated">生成される配列型の名前は、アンダースコアが前に付けられたスカラー型の名前です。配列エントリの他のフィールドには、 &lt;code&gt;pg_type.h&lt;/code&gt; の &lt;code&gt;BKI_ARRAY_DEFAULT(value)&lt;/code&gt; アノテーションが入力されます。アノテーションがない場合は、スカラー型からコピーされます。 （他にも特殊なケースがあります &lt;code&gt;typalign&lt;/code&gt; 。）次に &lt;code&gt;typelem&lt;/code&gt; と &lt;code&gt;typarray&lt;/code&gt; 2つのエントリのフィールドが互いに相互参照が設定されています。</target>
        </trans-unit>
        <trans-unit id="3eb30312d4c2f46733a2c8327c7814b6e7e52a77" translate="yes" xml:space="preserve">
          <source>The generated queries are executed in the order in which the rows are returned, and left-to-right within each row if there is more than one column. NULL fields are ignored. The generated queries are sent literally to the server for processing, so they cannot be psql meta-commands nor contain psql variable references. If any individual query fails, execution of the remaining queries continues unless &lt;code&gt;ON_ERROR_STOP&lt;/code&gt; is set. Execution of each query is subject to &lt;code&gt;ECHO&lt;/code&gt; processing. (Setting &lt;code&gt;ECHO&lt;/code&gt; to &lt;code&gt;all&lt;/code&gt; or &lt;code&gt;queries&lt;/code&gt; is often advisable when using &lt;code&gt;\gexec&lt;/code&gt;.) Query logging, single-step mode, timing, and other query execution features apply to each generated query as well.</source>
          <target state="translated">生成されたクエリは、行が返される順序で実行され、複数の列がある場合は各行内で左から右に実行されます。 NULLフィールドは無視されます。生成されたクエリは、文字通りサーバーに送信されて処理されるため、psqlメタコマンドにすることも、psql変数参照を含めることもできません。個々のクエリが失敗した場合、 &lt;code&gt;ON_ERROR_STOP&lt;/code&gt; が設定されていない限り、残りのクエリの実行が続行されます。各クエリの実行は、 &lt;code&gt;ECHO&lt;/code&gt; 処理の対象となります。 （ &lt;code&gt;\gexec&lt;/code&gt; を使用する場合、 &lt;code&gt;ECHO&lt;/code&gt; を &lt;code&gt;all&lt;/code&gt; または &lt;code&gt;queries&lt;/code&gt; 設定することをお勧めします。）クエリログ、シングルステップモード、タイミング、およびその他のクエリ実行機能は、生成された各クエリにも適用されます。</target>
        </trans-unit>
        <trans-unit id="b9932b57cc46c7c3eb3f68c8f986add5fa46c3a0" translate="yes" xml:space="preserve">
          <source>The generation expression can only use immutable functions and cannot use subqueries or reference anything other than the current row in any way.</source>
          <target state="translated">生成式は不変関数のみを使用することができ、サブクエリを使用したり、現在の行以外のものを参照したりすることはできません。</target>
        </trans-unit>
        <trans-unit id="491279f444aecfec04612928c73be9653a1967ca" translate="yes" xml:space="preserve">
          <source>The generation expression can refer to other columns in the table, but not other generated columns. Any functions and operators used must be immutable. References to other tables are not allowed.</source>
          <target state="translated">生成式は、テーブル内の他の列を参照することはできますが、他の生成された列を参照することはできません。使用される関数や演算子はすべて不変でなければなりません。他のテーブルへの参照は許可されていません。</target>
        </trans-unit>
        <trans-unit id="107e72819959dbe843c78d42ff3ca5cede1b2e0f" translate="yes" xml:space="preserve">
          <source>The generic WAL redo function will acquire exclusive locks to buffers in the same order as they were registered. After redoing all changes, the locks will be released in the same order.</source>
          <target state="translated">一般的なWALのやり直し機能は、登録した順番通りにバッファに対して排他的なロックを取得します。すべての変更をやり直した後、同じ順番でロックが解除されます。</target>
        </trans-unit>
        <trans-unit id="0ec880a1f4bc52e38225ff4766fdd3a9f49cf436" translate="yes" xml:space="preserve">
          <source>The generic term for all objects in a &lt;a href=&quot;glossary#GLOSSARY-DATABASE&quot;&gt;database&lt;/a&gt; that have a name and a list of &lt;a href=&quot;glossary#GLOSSARY-ATTRIBUTE&quot;&gt;attributes&lt;/a&gt; defined in a specific order. &lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;Tables&lt;/a&gt;, &lt;a href=&quot;glossary#GLOSSARY-SEQUENCE&quot;&gt;sequences&lt;/a&gt;, &lt;a href=&quot;glossary#GLOSSARY-VIEW&quot;&gt;views&lt;/a&gt;, &lt;a href=&quot;glossary#GLOSSARY-FOREIGN-TABLE&quot;&gt;foreign tables&lt;/a&gt;, &lt;a href=&quot;glossary#GLOSSARY-MATERIALIZED-VIEW&quot;&gt;materialized views&lt;/a&gt;, composite types, and &lt;a href=&quot;glossary#GLOSSARY-INDEX&quot;&gt;indexes&lt;/a&gt; are all relations.</source>
          <target state="translated">The generic term for all objects in a &lt;a href=&quot;glossary#GLOSSARY-DATABASE&quot;&gt;database&lt;/a&gt; that have a name and a list of &lt;a href=&quot;glossary#GLOSSARY-ATTRIBUTE&quot;&gt;attributes&lt;/a&gt; defined in a specific order. &lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;Tables&lt;/a&gt;, &lt;a href=&quot;glossary#GLOSSARY-SEQUENCE&quot;&gt;sequences&lt;/a&gt;, &lt;a href=&quot;glossary#GLOSSARY-VIEW&quot;&gt;views&lt;/a&gt;, &lt;a href=&quot;glossary#GLOSSARY-FOREIGN-TABLE&quot;&gt;foreign tables&lt;/a&gt;, &lt;a href=&quot;glossary#GLOSSARY-MATERIALIZED-VIEW&quot;&gt;materialized views&lt;/a&gt;, composite types, and &lt;a href=&quot;glossary#GLOSSARY-INDEX&quot;&gt;indexes&lt;/a&gt; are all relations.</target>
        </trans-unit>
        <trans-unit id="82aaa212b0dcfe65dc390eb2bddcbdc50aeac8ad" translate="yes" xml:space="preserve">
          <source>The genetic algorithm (GA) is a heuristic optimization method which operates through randomized search. The set of possible solutions for the optimization problem is considered as a &lt;em&gt;population&lt;/em&gt; of &lt;em&gt;individuals&lt;/em&gt;. The degree of adaptation of an individual to its environment is specified by its &lt;em&gt;fitness&lt;/em&gt;.</source>
          <target state="translated">遺伝的アルゴリズム（GA）は、ランダム化された検索を通じて動作するヒューリスティックな最適化手法です。最適化問題の可能な解決策のセットは、&lt;em&gt;個人の&lt;/em&gt;&lt;em&gt;母集団&lt;/em&gt;と見なされます。個人の環境への適応の度合いは、その&lt;em&gt;適応度&lt;/em&gt;によって指定されます。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7ee74388f5d56affe1f244671fe03aad5cc5e12c" translate="yes" xml:space="preserve">
          <source>The genetic query optimizer (GEQO) is an algorithm that does query planning using heuristic searching. This reduces planning time for complex queries (those joining many relations), at the cost of producing plans that are sometimes inferior to those found by the normal exhaustive-search algorithm. For more information see &lt;a href=&quot;https://www.postgresql.org/docs/12/geqo.html&quot;&gt;Chapter 59&lt;/a&gt;.</source>
          <target state="translated">遺伝的クエリオプティマイザー（GEQO）は、ヒューリスティック検索を使用してクエリ計画を行うアルゴリズムです。これにより、複雑なクエリ（多くのリレーションを結合するクエリ）の計画時間が短縮されますが、通常の全数検索アルゴリズムで見つかる計画よりも劣る計画が作成されるという犠牲が伴います。詳細については、&lt;a href=&quot;https://www.postgresql.org/docs/12/geqo.html&quot;&gt;第59章を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="76e81ac1072d86242c4bc156a134a00ceecb9182" translate="yes" xml:space="preserve">
          <source>The genetic query optimizer (GEQO) is an algorithm that does query planning using heuristic searching. This reduces planning time for complex queries (those joining many relations), at the cost of producing plans that are sometimes inferior to those found by the normal exhaustive-search algorithm. For more information see &lt;a href=&quot;https://www.postgresql.org/docs/13/geqo.html&quot;&gt;Chapter 59&lt;/a&gt;.</source>
          <target state="translated">The genetic query optimizer (GEQO) is an algorithm that does query planning using heuristic searching. This reduces planning time for complex queries (those joining many relations), at the cost of producing plans that are sometimes inferior to those found by the normal exhaustive-search algorithm. For more information see &lt;a href=&quot;https://www.postgresql.org/docs/13/geqo.html&quot;&gt;Chapter 59&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="be4cf5614687e283544003825f41ef8216ea5370" translate="yes" xml:space="preserve">
          <source>The geometric types &lt;code&gt;point&lt;/code&gt;, &lt;code&gt;box&lt;/code&gt;, &lt;code&gt;lseg&lt;/code&gt;, &lt;code&gt;line&lt;/code&gt;, &lt;code&gt;path&lt;/code&gt;, &lt;code&gt;polygon&lt;/code&gt;, and &lt;code&gt;circle&lt;/code&gt; have a large set of native support functions and operators, shown in &lt;a href=&quot;functions-geometry#FUNCTIONS-GEOMETRY-OP-TABLE&quot;&gt;Table 9.34&lt;/a&gt;, &lt;a href=&quot;functions-geometry#FUNCTIONS-GEOMETRY-FUNC-TABLE&quot;&gt;Table 9.35&lt;/a&gt;, and &lt;a href=&quot;functions-geometry#FUNCTIONS-GEOMETRY-CONV-TABLE&quot;&gt;Table 9.36&lt;/a&gt;.</source>
          <target state="translated">幾何タイプ &lt;code&gt;point&lt;/code&gt; 、 &lt;code&gt;box&lt;/code&gt; 、 &lt;code&gt;lseg&lt;/code&gt; 、 &lt;code&gt;line&lt;/code&gt; 、 &lt;code&gt;path&lt;/code&gt; 、 &lt;code&gt;polygon&lt;/code&gt; 、および &lt;code&gt;circle&lt;/code&gt; には、&lt;a href=&quot;functions-geometry#FUNCTIONS-GEOMETRY-OP-TABLE&quot;&gt;表9.34&lt;/a&gt;、&lt;a href=&quot;functions-geometry#FUNCTIONS-GEOMETRY-FUNC-TABLE&quot;&gt;表9.35&lt;/a&gt;、および&lt;a href=&quot;functions-geometry#FUNCTIONS-GEOMETRY-CONV-TABLE&quot;&gt;表9.36&lt;/a&gt;に示すように、ネイティブサポート関数と演算子の大きなセットがあります。</target>
        </trans-unit>
        <trans-unit id="347bd2183f41ac71a7c964a957ff88f0b7d2f9db" translate="yes" xml:space="preserve">
          <source>The geometric types &lt;code&gt;point&lt;/code&gt;, &lt;code&gt;box&lt;/code&gt;, &lt;code&gt;lseg&lt;/code&gt;, &lt;code&gt;line&lt;/code&gt;, &lt;code&gt;path&lt;/code&gt;, &lt;code&gt;polygon&lt;/code&gt;, and &lt;code&gt;circle&lt;/code&gt; have a large set of native support functions and operators, shown in &lt;a href=&quot;functions-geometry#FUNCTIONS-GEOMETRY-OP-TABLE&quot;&gt;Table 9.35&lt;/a&gt;, &lt;a href=&quot;functions-geometry#FUNCTIONS-GEOMETRY-FUNC-TABLE&quot;&gt;Table 9.36&lt;/a&gt;, and &lt;a href=&quot;functions-geometry#FUNCTIONS-GEOMETRY-CONV-TABLE&quot;&gt;Table 9.37&lt;/a&gt;.</source>
          <target state="translated">The geometric types &lt;code&gt;point&lt;/code&gt; , &lt;code&gt;box&lt;/code&gt; , &lt;code&gt;lseg&lt;/code&gt; , &lt;code&gt;line&lt;/code&gt; , &lt;code&gt;path&lt;/code&gt; , &lt;code&gt;polygon&lt;/code&gt; , and &lt;code&gt;circle&lt;/code&gt; have a large set of native support functions and operators, shown in &lt;a href=&quot;functions-geometry#FUNCTIONS-GEOMETRY-OP-TABLE&quot;&gt;Table 9.35&lt;/a&gt;, &lt;a href=&quot;functions-geometry#FUNCTIONS-GEOMETRY-FUNC-TABLE&quot;&gt;Table 9.36&lt;/a&gt;, and &lt;a href=&quot;functions-geometry#FUNCTIONS-GEOMETRY-CONV-TABLE&quot;&gt;Table 9.37&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="66e8935cc591dee18b7ed24a47a78f49e5afb1a3" translate="yes" xml:space="preserve">
          <source>The geometry of measurements is usually more complex than that of a point in a numeric continuum. A measurement is usually a segment of that continuum with somewhat fuzzy limits. The measurements come out as intervals because of uncertainty and randomness, as well as because the value being measured may naturally be an interval indicating some condition, such as the temperature range of stability of a protein.</source>
          <target state="translated">測定の幾何学的形状は、通常、数値連続体の点よりも複雑です。測定は、通常、ややあいまいな限界を持つ連続体のセグメントです。測定は、不確実性とランダム性のために、また、測定される値が当然のことながら、タンパク質の安定性の温度範囲など、何らかの条件を示す間隔である場合があるために、間隔として出てきます。</target>
        </trans-unit>
        <trans-unit id="443b3b682ab171a2c355d696fdc2acc186cfef4d" translate="yes" xml:space="preserve">
          <source>The given password is hashed using a String2Key (S2K) algorithm. This is rather similar to &lt;code&gt;crypt()&lt;/code&gt; algorithms &amp;mdash; purposefully slow and with random salt &amp;mdash; but it produces a full-length binary key.</source>
          <target state="translated">指定されたパスワードは、String2Key（S2K）アルゴリズムを使用してハッシュされます。これは &lt;code&gt;crypt()&lt;/code&gt; アルゴリズムにかなり似ています&amp;mdash;意図的に遅く、ランダムなソルトを使用しますが、完全長のバイナリキーを生成します。</target>
        </trans-unit>
        <trans-unit id="0e4e030b166d032a885deba1d77181dbb66b8bc9" translate="yes" xml:space="preserve">
          <source>The grouping operations shown in &lt;a href=&quot;functions-aggregate#FUNCTIONS-GROUPING-TABLE&quot;&gt;Table 9.59&lt;/a&gt; are used in conjunction with grouping sets (see &lt;a href=&quot;queries-table-expressions#QUERIES-GROUPING-SETS&quot;&gt;Section 7.2.4&lt;/a&gt;) to distinguish result rows. The arguments to the &lt;code&gt;GROUPING&lt;/code&gt; function are not actually evaluated, but they must exactly match expressions given in the &lt;code&gt;GROUP BY&lt;/code&gt; clause of the associated query level. For example:</source>
          <target state="translated">The grouping operations shown in &lt;a href=&quot;functions-aggregate#FUNCTIONS-GROUPING-TABLE&quot;&gt;Table 9.59&lt;/a&gt; are used in conjunction with grouping sets (see &lt;a href=&quot;queries-table-expressions#QUERIES-GROUPING-SETS&quot;&gt;Section 7.2.4&lt;/a&gt;) to distinguish result rows. The arguments to the &lt;code&gt;GROUPING&lt;/code&gt; function are not actually evaluated, but they must exactly match expressions given in the &lt;code&gt;GROUP BY&lt;/code&gt; clause of the associated query level. For example:</target>
        </trans-unit>
        <trans-unit id="a0b9a6b33b61484344b41d8768ea944df1857641" translate="yes" xml:space="preserve">
          <source>The header extension area is envisioned to contain a sequence of self-identifying chunks. The flags field is not intended to tell readers what is in the extension area. Specific design of header extension contents is left for a later release.</source>
          <target state="translated">ヘッダ拡張領域は、自己識別可能な一連のチャンクを含むことを想定しています。フラグフィールドは、拡張領域に何があるかを読者に伝えることを意図していません。ヘッダ拡張内容の具体的な設計は後のリリースに委ねられています。</target>
        </trans-unit>
        <trans-unit id="6e01e0ce077bd1d9c99c3825e5edad48a491fa26" translate="yes" xml:space="preserve">
          <source>The horizontal header, displayed as the first row, contains the values found in column &lt;code&gt;colH&lt;/code&gt;, with duplicates removed. By default, these appear in the same order as in the query results. But if the optional &lt;code&gt;sortcolH&lt;/code&gt; argument is given, it identifies a column whose values must be integer numbers, and the values from &lt;code&gt;colH&lt;/code&gt; will appear in the horizontal header sorted according to the corresponding &lt;code&gt;sortcolH&lt;/code&gt; values.</source>
          <target state="translated">最初の行として表示される水平ヘッダーには、列 &lt;code&gt;colH&lt;/code&gt; で見つかった値が含まれ、重複が削除されています。デフォルトでは、これらはクエリ結果と同じ順序で表示されます。ただし、オプションの &lt;code&gt;sortcolH&lt;/code&gt; 引数が指定されている場合、それは値が整数でなければならない列を識別し、 &lt;code&gt;colH&lt;/code&gt; からの値は、対応する &lt;code&gt;sortcolH&lt;/code&gt; 値に従ってソートされた水平ヘッダーに表示されます。</target>
        </trans-unit>
        <trans-unit id="323272ce1c2fce6128855defbc54368c470d5d34" translate="yes" xml:space="preserve">
          <source>The host name and port number of the primary, connection user name, and password are specified in the &lt;a href=&quot;runtime-config-replication#GUC-PRIMARY-CONNINFO&quot;&gt;primary_conninfo&lt;/a&gt;. The password can also be set in the &lt;code&gt;~/.pgpass&lt;/code&gt; file on the standby (specify &lt;code&gt;replication&lt;/code&gt; in the &lt;code&gt;database&lt;/code&gt; field). For example, if the primary is running on host IP &lt;code&gt;192.168.1.50&lt;/code&gt;, port &lt;code&gt;5432&lt;/code&gt;, the account name for replication is &lt;code&gt;foo&lt;/code&gt;, and the password is &lt;code&gt;foopass&lt;/code&gt;, the administrator can add the following line to the &lt;code&gt;postgresql.conf&lt;/code&gt; file on the standby:</source>
          <target state="translated">プライマリのホスト名とポート番号、接続ユーザー名、およびパスワードは、&lt;a href=&quot;runtime-config-replication#GUC-PRIMARY-CONNINFO&quot;&gt;primary_conninfoで&lt;/a&gt;指定されます。パスワードは、スタンバイの &lt;code&gt;~/.pgpass&lt;/code&gt; ファイルでも設定できます（ &lt;code&gt;database&lt;/code&gt; フィールドで &lt;code&gt;replication&lt;/code&gt; を指定します）。たとえば、プライマリがホストIP &lt;code&gt;192.168.1.50&lt;/code&gt; 、ポート &lt;code&gt;5432&lt;/code&gt; で実行され、レプリケーションのアカウント名が &lt;code&gt;foo&lt;/code&gt; で、パスワードが &lt;code&gt;foopass&lt;/code&gt; の場合、管理者は次の行をスタンバイの &lt;code&gt;postgresql.conf&lt;/code&gt; ファイルに追加できます。</target>
        </trans-unit>
        <trans-unit id="41cfca1d0872f04d37ad8cb9cbf3834cb90f01db" translate="yes" xml:space="preserve">
          <source>The host name of the database server, truncated at the first dot, or &lt;code&gt;[local]&lt;/code&gt; if the connection is over a Unix domain socket.</source>
          <target state="translated">最初のドットで切り捨てられたデータベースサーバーのホスト名、または接続がUnixドメインソケットを介している場合は &lt;code&gt;[local]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0b7649f0038242a26a0c621f7315d0b3f51c7304" translate="yes" xml:space="preserve">
          <source>The hour component of the time zone offset</source>
          <target state="translated">タイムゾーンオフセットの時間成分</target>
        </trans-unit>
        <trans-unit id="6ced8e552c81e4a5ec5eb0ba5039b71c87a5c484" translate="yes" xml:space="preserve">
          <source>The hour field (0 - 23)</source>
          <target state="translated">時間フィールド(0~23)</target>
        </trans-unit>
        <trans-unit id="c96645608711f945ba53324fe90b2674f60c24de" translate="yes" xml:space="preserve">
          <source>The hour field (0&amp;ndash;23)</source>
          <target state="translated">The hour field (0&amp;ndash;23)</target>
        </trans-unit>
        <trans-unit id="842cd42d6043fc7261db6ee13e01b6e92f6c88ea" translate="yes" xml:space="preserve">
          <source>The i7-860 system measured runs the count query in 9.8 ms while the &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; version takes 16.6 ms, each processing just over 100,000 rows. That 6.8 ms difference means the timing overhead per row is 68 ns, about twice what pg_test_timing estimated it would be. Even that relatively small amount of overhead is making the fully timed count statement take almost 70% longer. On more substantial queries, the timing overhead would be less problematic.</source>
          <target state="translated">測定されたi7-860システムはカウントクエリを9.8ミリ秒で実行しますが、 &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; バージョンは16.6ミリ秒かかり、各処理は100,000行をわずかに超えます。その6.8ミリ秒の差は、行ごとのタイミングオーバーヘッドが68 nsであることを意味し、pg_test_timingが見積もった値の約2倍です。オーバーヘッドが比較的小さい場合でも、完全に計時されたカウントステートメントはほぼ70％長くかかります。より実質的なクエリでは、タイミングのオーバーヘッドの問題は少なくなります。</target>
        </trans-unit>
        <trans-unit id="fbf85920bba7cb75c10687cf6cd36aab7a7c9b2a" translate="yes" xml:space="preserve">
          <source>The idea behind this dump method is to generate a file with SQL commands that, when fed back to the server, will recreate the database in the same state as it was at the time of the dump. PostgreSQL provides the utility program &lt;a href=&quot;app-pgdump&quot;&gt;pg_dump&lt;/a&gt; for this purpose. The basic usage of this command is:</source>
          <target state="translated">このダンプメソッドの背後にある考え方は、SQLコマンドを含むファイルを生成することです。このコマンドは、サーバーにフィードバックされたときに、ダンプ時と同じ状態でデータベースを再作成します。PostgreSQLは、この目的のためのユーティリティプログラム&lt;a href=&quot;app-pgdump&quot;&gt;pg_dump&lt;/a&gt;を提供しています。このコマンドの基本的な使用法は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="6cf4bd1d2fa41d408b71387e9f46d7734f70e2c4" translate="yes" xml:space="preserve">
          <source>The ident authentication method works by obtaining the client's operating system user name from an ident server and using it as the allowed database user name (with an optional user name mapping). This is only supported on TCP/IP connections.</source>
          <target state="translated">この認証方法は、クライアントのオペレーティングシステムのユーザ名を ident サーバから取得し、それを許可されたデータベースのユーザ名として使用します (オプションでユーザ名のマッピングも可能です)。これは TCP/IP 接続でのみサポートされています。</target>
        </trans-unit>
        <trans-unit id="75cef3c7a191b437000bac7046319a3652002a6f" translate="yes" xml:space="preserve">
          <source>The identifier of the prepared statement</source>
          <target state="translated">作成されたステートメントの識別子</target>
        </trans-unit>
        <trans-unit id="5814fec88046aa889ddca71e977eccd80834a133" translate="yes" xml:space="preserve">
          <source>The identity (transaction ID) of the deleting transaction, or zero for an undeleted row version. It is possible for this column to be nonzero in a visible row version. That usually indicates that the deleting transaction hasn't committed yet, or that an attempted deletion was rolled back.</source>
          <target state="translated">削除するトランザクションのID(トランザクションID)、または削除されていない行のバージョ ンの場合はゼロである。表示されている行のバージョンでは、この列が0以外の値になることもある。これは通常、削除するトランザクションがまだコミットされていないか、削除の試みがロールバックされたことを示す。</target>
        </trans-unit>
        <trans-unit id="7c52aeea0184eb0092fc19e054b01bbe20a261fc" translate="yes" xml:space="preserve">
          <source>The identity (transaction ID) of the inserting transaction for this row version. (A row version is an individual state of a row; each update of a row creates a new row version for the same logical row.)</source>
          <target state="translated">この行バージョンの挿入トランザクションの ID (トランザクション ID)。(行バージョンは、行の個々の状態です。行の各更新は、同じ論理行の新しい行バージョンを作成します)。</target>
        </trans-unit>
        <trans-unit id="61965181bc017854598b0845bd8393cd487f7cfb" translate="yes" xml:space="preserve">
          <source>The implementation does not resist &lt;a href=&quot;https://en.wikipedia.org/wiki/Side-channel_attack&quot;&gt;side-channel attacks&lt;/a&gt;. For example, the time required for a &lt;code&gt;pgcrypto&lt;/code&gt; decryption function to complete varies among ciphertexts of a given size.</source>
          <target state="translated">実装は&lt;a href=&quot;https://en.wikipedia.org/wiki/Side-channel_attack&quot;&gt;サイドチャネル攻撃に&lt;/a&gt;抵抗しません。たとえば、 &lt;code&gt;pgcrypto&lt;/code&gt; 復号化関数の完了に必要な時間は、所定のサイズの暗号文によって異なります。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
