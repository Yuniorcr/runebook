<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="kotlin">
    <body>
      <group id="kotlin">
        <trans-unit id="ac3430431502d340786bc5ac5f5a79619bd1b1b8" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;mapping&lt;/em&gt; transformation creates a collection from the results of a function on the elements of another collection. The basic mapping function is &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/map&quot;&gt;&lt;code&gt;map()&lt;/code&gt;&lt;/a&gt;. It applies the given lambda function to each subsequent element and returns the list of the lambda results. The order of results is the same as the original order of elements. To apply a transformation that additionally uses the element index as an argument, use &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/map-indexed&quot;&gt;&lt;code&gt;mapIndexed()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;マッピングの&lt;/em&gt;変換は、別のコレクションの要素に対する関数の結果からコレクションを作成します。基本的なマッピング関数は&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/map&quot;&gt; &lt;code&gt;map()&lt;/code&gt; &lt;/a&gt;です。指定されたラムダ関数を後続の各要素に適用し、ラムダ結果のリストを返します。結果の順序は、元の要素の順序と同じです。要素インデックスを引数としてさらに使用する変換を適用するには、&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/map-indexed&quot;&gt; &lt;code&gt;mapIndexed()&lt;/code&gt; を&lt;/a&gt;使用します。</target>
        </trans-unit>
        <trans-unit id="7f10d769163cad6919d11542a05d27b21373fb57" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;no-arg&lt;/em&gt; compiler plugin generates an additional zero-argument constructor for classes with a specific annotation.</source>
          <target state="translated">&lt;em&gt;引数なしの&lt;/em&gt;コンパイラプラグインは、特定の注釈付きクラスのための追加の引数なしのコンストラクタを生成します。</target>
        </trans-unit>
        <trans-unit id="5691855d07c59433c1b89721a503fe2ada65d67c" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;override&lt;/em&gt; modifier is required for &lt;code&gt;Circle.draw()&lt;/code&gt;. If it were missing, the compiler would complain. If there is no &lt;em&gt;open&lt;/em&gt; modifier on a function, like &lt;code&gt;Shape.fill()&lt;/code&gt;, declaring a method with the same signature in a subclass is illegal, either with &lt;em&gt;override&lt;/em&gt; or without it. The &lt;em&gt;open&lt;/em&gt; modifier has no effect when added on members of a final class (i.e.. a class with no &lt;em&gt;open&lt;/em&gt; modifier).</source>
          <target state="translated">&lt;em&gt;オーバーライド&lt;/em&gt;修飾子が要求される &lt;code&gt;Circle.draw()&lt;/code&gt; 。それが欠落している場合、コンパイラは文句を言います。 &lt;code&gt;Shape.fill()&lt;/code&gt; のように、関数に&lt;em&gt;open&lt;/em&gt;修飾子がない場合、サブクラスで同じシグネチャを持つメソッドを宣言することは、&lt;em&gt;オーバーライドの&lt;/em&gt;有無にかかわらず、違法です。&lt;em&gt;オープン&lt;/em&gt;finalクラス（すなわちなしでクラスのメンバーに追加したとき修飾子は効果がありません&lt;em&gt;オープン&lt;/em&gt;修飾子）。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c23eadbd5827ce2bda3043305cafb8fee54b97d1" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;override&lt;/em&gt; modifier is required for &lt;code&gt;Derived.v()&lt;/code&gt;. If it were missing, the compiler would complain. If there is no &lt;em&gt;open&lt;/em&gt; modifier on a function, like &lt;code&gt;Base.nv()&lt;/code&gt;, declaring a method with the same signature in a subclass is illegal, either with &lt;em&gt;override&lt;/em&gt; or without it. The &lt;em&gt;open&lt;/em&gt; modifier has no effect when added on members of a final class (i.e.. a class with no &lt;em&gt;open&lt;/em&gt; modifier).</source>
          <target state="translated">&lt;em&gt;オーバーライド&lt;/em&gt;修飾子が要求される &lt;code&gt;Derived.v()&lt;/code&gt; 。それが欠けていると、コンパイラーは文句を言うでしょう。 &lt;code&gt;Base.nv()&lt;/code&gt; などの関数に&lt;em&gt;オープン&lt;/em&gt;修飾子がない場合、サブクラスで同じシグネチャを持つメソッドを宣言することは、&lt;em&gt;オーバーライドの&lt;/em&gt;有無にかかわらず、不正です。&lt;em&gt;オープン&lt;/em&gt; finalクラス（すなわちなしでクラスのメンバーに追加したとき修飾子は効果がありません&lt;em&gt;オープン&lt;/em&gt;修飾子）。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7a6efa4e40ec720cdbba584f5f17332e3c02e6f0" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;primitive data types&lt;/em&gt; are the most fundamental types in Kotlin; all other types are built up of these types and arrays thereof. Their representation is very efficient (both in terms of memory and CPU time), as they map to small byte groups that are directly manipulatable by the CPU.</source>
          <target state="translated">&lt;em&gt;プリミティブデータ型は、&lt;/em&gt; Kotlinの中で最も基本的なタイプです。他のすべてのタイプは、これらのタイプとその配列で構成されます。それらは、CPUによって直接操作可能な小さなバイトグループにマッピングされるため、（メモリとCPU時間の両方に関して）非常に効率的です。</target>
        </trans-unit>
        <trans-unit id="487cd135e968638b95e9f2832e5094575fc75a4e" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;return&lt;/em&gt;-expression returns from the nearest enclosing function, i.e. &lt;code&gt;foo&lt;/code&gt;. (Note that such non-local returns are supported only for lambda expressions passed to &lt;a href=&quot;inline-functions&quot;&gt;inline functions&lt;/a&gt;.) If we need to return from a lambda expression, we have to label it and qualify the &lt;em&gt;return&lt;/em&gt;:</source>
          <target state="translated">&lt;em&gt;リターン&lt;/em&gt;最も内側の関数から-expression戻り、すなわち &lt;code&gt;foo&lt;/code&gt; という。（このような非局所的なリターンのみに渡されたラムダ式のためにサポートされていることを注意&lt;a href=&quot;inline-functions&quot;&gt;インライン関数&lt;/a&gt;。）私たちはラムダ式から復帰する必要がある場合は、我々はそれにラベルを付け、修飾する必要が&lt;em&gt;リターンを&lt;/em&gt;：</target>
        </trans-unit>
        <trans-unit id="cafe8afb40f89fdcda59dc51de02a6061deac76b" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;sam-with-receiver&lt;/em&gt; compiler plugin makes the first parameter of the annotated Java &quot;single abstract method&quot; (SAM) interface method a receiver in Kotlin. This conversion only works when the SAM interface is passed as a Kotlin lambda, both for SAM adapters and SAM constructors (see the &lt;a href=&quot;java-interop#sam-conversions&quot;&gt;documentation&lt;/a&gt; for more details).</source>
          <target state="translated">&lt;em&gt;SAM-とレシーバ&lt;/em&gt;コンパイラプラグインは、注釈付きのJava「単一抽象メソッド」（SAM）インターフェースメソッドの最初のパラメータKotlinで受信を行います。この変換は、SAMアダプターとSAMコンストラクターの両方について、SAMインターフェースがKotlinラムダとして渡される場合にのみ機能します（詳細については、&lt;a href=&quot;java-interop#sam-conversions&quot;&gt;ドキュメント&lt;/a&gt;を参照してください）。</target>
        </trans-unit>
        <trans-unit id="2b5aab8f26eb6a59834e5185db5f935d540467ca" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;this&lt;/em&gt; keyword inside an extension function corresponds to the receiver object (the one that is passed before the dot). Now, we can call such a function on any &lt;code&gt;MutableList&amp;lt;Int&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">拡張関数内の&lt;em&gt;this&lt;/em&gt;キーワードは、レシーバーオブジェクト（ドットの前に渡されるオブジェクト）に対応します。これで、このような関数を任意の &lt;code&gt;MutableList&amp;lt;Int&amp;gt;&lt;/code&gt; 呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="610610ce4b9c2a06c0d2c740b86b1595d612ed87" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;when&lt;/em&gt; expression replaces the switch statement in C-like languages. In the simplest form it looks like this</source>
          <target state="translated">&lt;em&gt;とき&lt;/em&gt;式はCに似た言語でswitch文を置き換えます。最も単純な形式では、次のようになります</target>
        </trans-unit>
        <trans-unit id="4474dcb438fb0b1d5730dee1b01c00e81230dea0" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Debug&lt;/strong&gt; tool window contains the &lt;strong&gt;Coroutines&lt;/strong&gt; tab. In this tab, you can find information about both currently running and suspended coroutines. The coroutines are grouped by the dispatcher they are running on.</source>
          <target state="translated">&lt;strong&gt;デバッグ&lt;/strong&gt;ツールウィンドウが含まれている&lt;strong&gt;コルーチン&lt;/strong&gt;タブを。このタブでは、現在実行中のコルーチンと一時停止中のコルーチンの両方に関する情報を見つけることができます。コルーチンは、実行しているディスパッチャによってグループ化されます。</target>
        </trans-unit>
        <trans-unit id="64ff96f8d5986618b0177325f56f06db0b6ef27e" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;cinterop&lt;/strong&gt; tool produces &lt;code&gt;.klib&lt;/code&gt; wrappers for native libraries as its main output. For example, using the simple &lt;code&gt;libgit2.def&lt;/code&gt; native library definition file provided in your Kotlin/Native distribution</source>
          <target state="translated">&lt;strong&gt;cinteropの&lt;/strong&gt;ツールが生成 &lt;code&gt;.klib&lt;/code&gt; そのメイン出力などのネイティブライブラリのラッパーを。たとえば、Kotlin /ネイティブディストリビューションで提供されているシンプルな &lt;code&gt;libgit2.def&lt;/code&gt; ネイティブライブラリ定義ファイルを使用します。</target>
        </trans-unit>
        <trans-unit id="3afe66cbf747b6ceb2175d27e523f7de3f8680c5" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;klib&lt;/strong&gt; library management utility allows you to inspect and install the libraries.</source>
          <target state="translated">&lt;strong&gt;klib&lt;/strong&gt;ライブラリ管理ユーティリティを使用すると、ライブラリを検査し、インストールすることができます。</target>
        </trans-unit>
        <trans-unit id="4754f312fedbc815f86ed89afbc9edf502f5ba2a" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;out&lt;/strong&gt; modifier is called a &lt;strong&gt;variance annotation&lt;/strong&gt;, and since it is provided at the type parameter declaration site, we talk about &lt;strong&gt;declaration-site variance&lt;/strong&gt;. This is in contrast with Java's &lt;strong&gt;use-site variance&lt;/strong&gt; where wildcards in the type usages make the types covariant.</source>
          <target state="translated">&lt;strong&gt;アウト&lt;/strong&gt;修飾子が呼び出され&lt;strong&gt;、分散注釈&lt;/strong&gt;、それは型パラメータ宣言のサイトで提供されているので、我々はについて話&lt;strong&gt;宣言サイトの分散&lt;/strong&gt;。これは、型の使用法でワイルドカードを使用して型を共変にするJavaの&lt;strong&gt;使用サイトの差異&lt;/strong&gt;とは対照的です。</target>
        </trans-unit>
        <trans-unit id="e4cdeee14d0ede31e2c00aaa982268d6ad103b09" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;wildcard type argument&lt;/strong&gt;&lt;code&gt;? extends E&lt;/code&gt; indicates that this method accepts a collection of objects of &lt;code&gt;E&lt;/code&gt;&lt;em&gt;or some subtype of&lt;/em&gt;&lt;code&gt;E&lt;/code&gt;, not just &lt;code&gt;E&lt;/code&gt; itself. This means that we can safely &lt;strong&gt;read&lt;/strong&gt;&lt;code&gt;E&lt;/code&gt;'s from items (elements of this collection are instances of a subclass of E), but &lt;strong&gt;cannot write&lt;/strong&gt; to it since we do not know what objects comply to that unknown subtype of &lt;code&gt;E&lt;/code&gt;. In return for this limitation, we have the desired behaviour: &lt;code&gt;Collection&amp;lt;String&amp;gt;&lt;/code&gt;&lt;em&gt;is&lt;/em&gt; a subtype of &lt;code&gt;Collection&amp;lt;? extends Object&amp;gt;&lt;/code&gt;. In &quot;clever words&quot;, the wildcard with an &lt;strong&gt;extends&lt;/strong&gt;-bound (&lt;strong&gt;upper&lt;/strong&gt; bound) makes the type &lt;strong&gt;covariant&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;ワイルドカード型引数&lt;/strong&gt; &lt;code&gt;? extends E&lt;/code&gt; は、このメソッドが &lt;code&gt;E&lt;/code&gt; 自体だけでなく、 &lt;code&gt;E&lt;/code&gt; &lt;em&gt;または&lt;/em&gt; &lt;code&gt;E&lt;/code&gt; の&lt;em&gt;サブタイプの&lt;/em&gt;オブジェクトのコレクションを受け入れることを示します。つまり、アイテムから &lt;code&gt;E&lt;/code&gt; を安全に&lt;strong&gt;読み取る&lt;/strong&gt;ことができます（このコレクションの要素はEのサブクラスのインスタンスです）が、その未知のサブタイプである &lt;code&gt;E&lt;/code&gt; に準拠するオブジェクトがわからないため、&lt;strong&gt;書き込むこと&lt;/strong&gt;が&lt;strong&gt;できません&lt;/strong&gt;。この制限の見返りとして、望ましい動作があります &lt;code&gt;Collection&amp;lt;String&amp;gt;&lt;/code&gt; &lt;em&gt;は&lt;/em&gt; &lt;code&gt;Collection&amp;lt;? extends Object&amp;gt;&lt;/code&gt; サブタイプです。 Object&amp;gt;を拡張します。 「賢い言葉」では、ワイルドカードに&lt;strong&gt;extends&lt;/strong&gt; -bound（&lt;strong&gt;upper&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;&lt;em&gt;&lt;/em&gt;&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;bound）型を&lt;strong&gt;共変にし&lt;/strong&gt;ます。</target>
        </trans-unit>
        <trans-unit id="1a90eeb87b3e982cfd1ef4a4b65cfd6c27586462" translate="yes" xml:space="preserve">
          <source>The Android world has many popular frameworks simplifying development. You can use the same frameworks if you develop in Kotlin, often as easily as you'd do that in Java. This tutorial provides examples and highlights the differences in settings.</source>
          <target state="translated">Androidの世界には、開発を簡単にする人気のフレームワークがたくさんあります。Kotlinで開発する場合も同じフレームワークを使うことができ、Javaで開発するのと同じように簡単にできることが多いです。このチュートリアルでは、例を示し、設定の違いを強調しています。</target>
        </trans-unit>
        <trans-unit id="d41ba3261445c389f8874772f5879ab48af811af" translate="yes" xml:space="preserve">
          <source>The C data variable containing the pointer to &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; へのポインターを含むCデータ変数。</target>
        </trans-unit>
        <trans-unit id="05360f394dd3e60e07e614be2588088eb89e3b72" translate="yes" xml:space="preserve">
          <source>The C data variable located in memory.</source>
          <target state="translated">メモリ上にあるCデータ変数です。</target>
        </trans-unit>
        <trans-unit id="cf919179eecf4647d490ce563cdd6bff132af96d" translate="yes" xml:space="preserve">
          <source>The C function.</source>
          <target state="translated">C関数です。</target>
        </trans-unit>
        <trans-unit id="d36502dcbc1bebedd6773776218e3117a26820bc" translate="yes" xml:space="preserve">
          <source>The C primitive-typed variable located in memory.</source>
          <target state="translated">メモリ内にある C のプリミティブ型変数。</target>
        </trans-unit>
        <trans-unit id="639b72b8a51545cc688d8100df8871c5e14d7a1a" translate="yes" xml:space="preserve">
          <source>The C struct-typed variable located in memory.</source>
          <target state="translated">メモリ上にあるCの構造体型変数。</target>
        </trans-unit>
        <trans-unit id="c4b0fbfe88d7c41e706fcbcc447e39c33c492192" translate="yes" xml:space="preserve">
          <source>The CocoaPods plugin also allows using CocoaPods libraries without manual configuring cinterop parameters (see the &lt;a href=&quot;../building-mpp-with-gradle#cinterop-support&quot;&gt;corresponding section&lt;/a&gt; of the multiplatform plugin documentation). The &lt;code&gt;cocoapods { ... }&lt;/code&gt; code block allows you to add dependencies on CocoaPods libraries.</source>
          <target state="translated">CocoaPodsプラグインでは、cinteropパラメータを手動で構成せずにCocoaPodsライブラリを使用することもできます（マルチプラットフォームプラグインのドキュメントの&lt;a href=&quot;../building-mpp-with-gradle#cinterop-support&quot;&gt;対応するセクション&lt;/a&gt;を参照してください）。 &lt;code&gt;cocoapods { ... }&lt;/code&gt; コードブロックは、あなたがCocoaPodsライブラリの依存関係を追加することができます。</target>
        </trans-unit>
        <trans-unit id="8779fd3a2cac48558378b86549bbda66333c4276" translate="yes" xml:space="preserve">
          <source>The CocoaPods support is implemented in a separate Gradle plugin: &lt;code&gt;org.jetbrains.kotlin.native.cocoapods&lt;/code&gt;.</source>
          <target state="translated">：CocoaPodsサポートは、別のGradleプラグインで実装されて &lt;code&gt;org.jetbrains.kotlin.native.cocoapods&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bd3aa1e3e57f3eb3ef63cd39980df09053647402" translate="yes" xml:space="preserve">
          <source>The Coroutine Debugger of the Kotlin plugin simplifies debugging coroutines in IntelliJ IDEA.</source>
          <target state="translated">KotlinプラグインのCoroutineデバッガは、IntelliJ IDEAでのコルーチンのデバッグを簡素化します。</target>
        </trans-unit>
        <trans-unit id="24a56079ca4afabfa7a909e10193add3dd7a492a" translate="yes" xml:space="preserve">
          <source>The DOM also provides us a way to retrieve a specific element by ID, name, class name, tag name and so on. All returned elements are of type &lt;code&gt;NodeList&lt;/code&gt;, and to access members we need to cast them to the specific type of element. The code below shows how we could access an input element on the page:</source>
          <target state="translated">DOMは、ID、名前、クラス名、タグ名などによって特定の要素を取得する方法も提供します。返される要素はすべて &lt;code&gt;NodeList&lt;/code&gt; タイプであり、メンバーにアクセスするには、それらを特定のタイプの要素にキャストする必要があります。以下のコードは、ページの入力要素にアクセスする方法を示しています。</target>
        </trans-unit>
        <trans-unit id="325910eae4ee7077ed16505d94cb7161a53ff4ff" translate="yes" xml:space="preserve">
          <source>The Entry Point</source>
          <target state="translated">エントリーポイント</target>
        </trans-unit>
        <trans-unit id="c1f2de3caa83760aa037581086bf37c054caebbb" translate="yes" xml:space="preserve">
          <source>The Gradle file is pretty much standard for Spring Boot. The only differences are the structure layout for source folders for Kotlin, the required Kotlin dependencies and the &lt;a href=&quot;../reference/compiler-plugins#kotlin-spring-compiler-plugi&quot;&gt;&lt;em&gt;kotlin-spring&lt;/em&gt;&lt;/a&gt; Gradle plugin (CGLIB proxies used for example for &lt;code&gt;@Configuration&lt;/code&gt; and &lt;code&gt;@Bean&lt;/code&gt; processing require &lt;code&gt;open&lt;/code&gt; classes).</source>
          <target state="translated">Gradleファイルは、Spring Bootのほとんどの標準です。唯一の違いは、Kotlinのソースフォルダーの構造レイアウト、必要なKotlinの依存関係、およびKotlin &lt;a href=&quot;../reference/compiler-plugins#kotlin-spring-compiler-plugi&quot;&gt;&lt;em&gt;-spring&lt;/em&gt;&lt;/a&gt; Gradleプラグインです（たとえば、 &lt;code&gt;@Configuration&lt;/code&gt; および &lt;code&gt;@Bean&lt;/code&gt; の処理に使用されるCGLIBプロキシには &lt;code&gt;open&lt;/code&gt; クラスが必要です）。</target>
        </trans-unit>
        <trans-unit id="af4ea41e06d67df72de18198c84923c5e721e071" translate="yes" xml:space="preserve">
          <source>The Gradle plugin provides a separate task that creates a universal framework for iOS targets from several regular ones. The example below shows how to use this task. Note that the fat framework must have the same base name as the initial frameworks.</source>
          <target state="translated">Gradleプラグインは、いくつかの通常のものからiOSターゲット用のユニバーサルフレームワークを作成する別のタスクを提供しています。以下の例は、このタスクの使い方を示しています。fatフレームワークは初期のフレームワークと同じベース名を持つ必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="c9686505fe7f54579b832493ec5b1983b12000c6" translate="yes" xml:space="preserve">
          <source>The JS typed arrays support that translates Kotlin primitive arrays, such as &lt;code&gt;IntArray&lt;/code&gt;, &lt;code&gt;DoubleArray&lt;/code&gt;, into &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Typed_arrays&quot;&gt;JavaScript typed arrays&lt;/a&gt;, that was previously an opt-in feature, has been enabled by default.</source>
          <target state="translated">&lt;code&gt;IntArray&lt;/code&gt; や &lt;code&gt;DoubleArray&lt;/code&gt; などのKotlinプリミティブ配列を&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Typed_arrays&quot;&gt;JavaScriptの型付き配列&lt;/a&gt;に変換するJS型付き配列サポートは、以前はオプトイン機能でしたが、デフォルトで有効になっています。</target>
        </trans-unit>
        <trans-unit id="37ed5aeb9956cf68199e058567f26ab71cd7268f" translate="yes" xml:space="preserve">
          <source>The JSR-305 checks can be configured by adding the &lt;code&gt;-Xjsr305&lt;/code&gt; compiler flag with the following options (and their combination):</source>
          <target state="translated">JSR-305チェックは、 &lt;code&gt;-Xjsr305&lt;/code&gt; コンパイラフラグに次のオプション（およびそれらの組み合わせ）を追加することで構成できます。</target>
        </trans-unit>
        <trans-unit id="8614662835decc941fb88cef784012c8f902a438" translate="yes" xml:space="preserve">
          <source>The Kotlin Android Extensions plugin allows us to obtain the same experience we have with some of these libraries, without having to add any extra code.</source>
          <target state="translated">Kotlin Android Extensions プラグインを使うと、余分なコードを追加することなく、これらのライブラリを使っているのと同じ経験を得ることができます。</target>
        </trans-unit>
        <trans-unit id="3fa035c9f4f03b0b989b6313990e3a366a7fc07b" translate="yes" xml:space="preserve">
          <source>The Kotlin Gradle plugin 1.4.10 works with Gradle 5.4 and later. The &lt;code&gt;kotlin-multiplatform&lt;/code&gt; plugin requires Gradle 6.0 or later.</source>
          <target state="translated">Kotlin Gradleプラグイン1.4.10は、Gradle5.4以降で動作します。 &lt;code&gt;kotlin-multiplatform&lt;/code&gt; プラグインには、Gradle6.0以降が必要です。</target>
        </trans-unit>
        <trans-unit id="b801cd7f041e6d90c21e7238c859980046339a8a" translate="yes" xml:space="preserve">
          <source>The Kotlin Gradle plugin supports incremental compilation. Incremental compilation tracks changes of source files between builds so only files affected by these changes would be compiled.</source>
          <target state="translated">Kotlin Gradle プラグインはインクリメンタルコンパイルをサポートしています。インクリメンタルコンパイルはビルド間のソースファイルの変更を追跡するので、変更の影響を受けるファイルのみがコンパイルされます。</target>
        </trans-unit>
        <trans-unit id="11818c172874b525f41c4774ffd3a8d06183ee2a" translate="yes" xml:space="preserve">
          <source>The Kotlin Maven Plugin needs to be referenced to compile the sources:</source>
          <target state="translated">ソースをコンパイルするためにKotlin Mavenプラグインを参照する必要があります。</target>
        </trans-unit>
        <trans-unit id="e701f1b663fc8e1d541e7d7bed4b022ef1cd48e3" translate="yes" xml:space="preserve">
          <source>The Kotlin Standard Library provides a comprehensive set of tools for managing &lt;em&gt;collections&lt;/em&gt; &amp;ndash; groups of a variable number of items (possibly zero) that share significance to the problem being solved and are operated upon commonly.</source>
          <target state="translated">Kotlin標準ライブラリは、&lt;em&gt;コレクション&lt;/em&gt;を管理するための包括的なツールセットを提供します。これは、解決される問題の重要性を共有し、一般的に操作される、変数の数（おそらく0）のグループです。</target>
        </trans-unit>
        <trans-unit id="8a031299bd7c193b637e92a822d8538f69af9b3a" translate="yes" xml:space="preserve">
          <source>The Kotlin Standard Library provides implementations for basic collection types: sets, lists, and maps. A pair of interfaces represent each collection type:</source>
          <target state="translated">Kotlin標準ライブラリは,基本的なコレクションタイプであるセット,リスト,マップの実装を提供します.一対のインターフェースがそれぞれのコレクションタイプを表します。</target>
        </trans-unit>
        <trans-unit id="3f614163c9f0e1a9b558eccd140b5d89bbaff4cb" translate="yes" xml:space="preserve">
          <source>The Kotlin Standard Library provides living essentials for everyday work with Kotlin. These include:</source>
          <target state="translated">Kotlin Standard Libraryは、Kotlinで毎日の仕事に必要な生活必需品を提供しています。これらには以下のものが含まれます。</target>
        </trans-unit>
        <trans-unit id="33a29a3734d935aaab60c852c81fd82eccf705fa" translate="yes" xml:space="preserve">
          <source>The Kotlin code is turned into very similar looking code in Swift. There are some small differences, though. In Kotlin any &lt;code&gt;object&lt;/code&gt; has only one instance. Kotlin &lt;code&gt;object Object&lt;/code&gt; now has a constructor in Swift, and we use the &lt;code&gt;Object()&lt;/code&gt; syntax to access the only instance of it. The instance is always the same in Swift, so that &lt;code&gt;Object() === Object()&lt;/code&gt; is true. Methods and property names are translated as-is. Kotlin &lt;code&gt;String&lt;/code&gt; is turned into Swift &lt;code&gt;String&lt;/code&gt; too. Swift hides &lt;code&gt;NSNumber*&lt;/code&gt; boxing from us too. We pass Swift closure to Kotlin and call a Kotlin lambda function from Swift too.</source>
          <target state="translated">Kotlinコードは、Swiftで非常によく似たコードに変わります。ただし、小さな違いがいくつかあります。 Kotlinでは、どの &lt;code&gt;object&lt;/code&gt; もインスタンスは1つしかありません。 Kotlin &lt;code&gt;object Object&lt;/code&gt; はSwiftにコンストラクターを持ち、 &lt;code&gt;Object()&lt;/code&gt; 構文を使用してその唯一のインスタンスにアクセスします。インスタンスはSwiftでも常に同じなので、 &lt;code&gt;Object() === Object()&lt;/code&gt; はtrueです。メソッドとプロパティ名はそのまま変換されます。 Kotlin &lt;code&gt;String&lt;/code&gt; もSwift &lt;code&gt;String&lt;/code&gt; に変わりました。 Swiftは &lt;code&gt;NSNumber*&lt;/code&gt; ボクシングも私たちから隠しています。 SwiftクロージャーをKotlinに渡し、SwiftからKotlinラムダ関数も呼び出します。</target>
        </trans-unit>
        <trans-unit id="a82d7ab28c8dc762af0699f165239106b9d7ca89" translate="yes" xml:space="preserve">
          <source>The Kotlin collections package contains extension functions for popular operations on sets: finding intersections, merging, or subtracting collections from each other.</source>
          <target state="translated">Kotlin コレクションパッケージには、集合に対する一般的な操作である、交差を見つけたり、結合したり、コレクションを互いに引き算したりするための拡張関数が含まれています。</target>
        </trans-unit>
        <trans-unit id="5352e834912895fb7e864dc749c6a67a63a5c1bd" translate="yes" xml:space="preserve">
          <source>The Kotlin collections package provides functions for sorting collections in natural, custom, and even random orders. On this page, we'll describe sorting functions that apply to &lt;a href=&quot;collections-overview#collection-types&quot;&gt;read-only&lt;/a&gt; collections. These functions return their result as a new collection containing the elements of the original collection in the requested order. To learn about functions for sorting &lt;a href=&quot;collections-overview#collection-types&quot;&gt;mutable&lt;/a&gt; collections in place, see the &lt;a href=&quot;list-operations#sorting&quot;&gt;List Specific Operations&lt;/a&gt;.</source>
          <target state="translated">Kotlinコレクションパッケージは、自然、カスタム、さらにはランダムな順序でコレクションを並べ替える関数を提供します。このページでは、&lt;a href=&quot;collections-overview#collection-types&quot;&gt;読み取り専用の&lt;/a&gt;コレクションに適用される並べ替え関数について説明します。これらの関数は、要求された順序で元のコレクションの要素を含む新しいコレクションとして結果を返します。&lt;a href=&quot;collections-overview#collection-types&quot;&gt;変更可能な&lt;/a&gt;コレクションを適切に並べ替える関数については、「&lt;a href=&quot;list-operations#sorting&quot;&gt;リスト固有の操作&lt;/a&gt;」を参照してください。</target>
        </trans-unit>
        <trans-unit id="606ec4093466ccf8ac7dfb28ac45fda128eb6073" translate="yes" xml:space="preserve">
          <source>The Kotlin compiler can now use information from type casts in type inference. If you&amp;rsquo;re calling a generic method that returns a type parameter &lt;code&gt;T&lt;/code&gt; and casting the return value to a specific type &lt;code&gt;Foo&lt;/code&gt;, the compiler now understands that &lt;code&gt;T&lt;/code&gt; for this call needs to be bound to the type &lt;code&gt;Foo&lt;/code&gt;.</source>
          <target state="translated">Kotlinコンパイラーは、型推論で型キャストからの情報を使用できるようになりました。型パラメーター &lt;code&gt;T&lt;/code&gt; を返すジェネリックメソッドを呼び出し、戻り値を特定の型 &lt;code&gt;Foo&lt;/code&gt; にキャストする場合、コンパイラーは、この呼び出しの &lt;code&gt;T&lt;/code&gt; を型 &lt;code&gt;Foo&lt;/code&gt; にバインドする必要があることを理解しました。</target>
        </trans-unit>
        <trans-unit id="3ccc8c3cdb40fba2c36169a3fed32ce41fa13cee" translate="yes" xml:space="preserve">
          <source>The Kotlin compiler does extensive static analysis to provide warnings and reduce boilerplate. One of the most notable features is smartcasts &amp;mdash; with the ability to perform a cast automatically based on the performed type checks:</source>
          <target state="translated">Kotlinコンパイラーは、広範な静的分析を行って警告を出し、定型文を減らします。最も注目すべき機能の1つはスマートキャストです。実行された型チェックに基づいて自動的にキャストを実行する機能があります。</target>
        </trans-unit>
        <trans-unit id="9b9028d4b3725e4248715dfa8cff6060191e14fa" translate="yes" xml:space="preserve">
          <source>The Kotlin compiler provides all the necessary information about &lt;code&gt;prop&lt;/code&gt; in the arguments: the first argument &lt;code&gt;this&lt;/code&gt; refers to an instance of the outer class &lt;code&gt;C&lt;/code&gt; and &lt;code&gt;this::prop&lt;/code&gt; is a reflection object of the &lt;code&gt;KProperty&lt;/code&gt; type describing &lt;code&gt;prop&lt;/code&gt; itself.</source>
          <target state="translated">Kotlinコンパイラは、約すべての必要な情報を提供 &lt;code&gt;prop&lt;/code&gt; 引数に：最初の引数 &lt;code&gt;this&lt;/code&gt; 外側のクラスのインスタンスを指し &lt;code&gt;C&lt;/code&gt; 及び &lt;code&gt;this::prop&lt;/code&gt; の反射対象である &lt;code&gt;KProperty&lt;/code&gt; の記述タイプ &lt;code&gt;prop&lt;/code&gt; 自体。</target>
        </trans-unit>
        <trans-unit id="d8f9b6bf737be7b0aa49748489bb11aedc0ed8e0" translate="yes" xml:space="preserve">
          <source>The Kotlin compiler tries to comply with the following goals:</source>
          <target state="translated">Kotlinコンパイラは、以下の目標を守ろうとしています。</target>
        </trans-unit>
        <trans-unit id="84694c64245d13b803ebc2f9a85d6bc26cef8561" translate="yes" xml:space="preserve">
          <source>The Kotlin compiler will prefer using underlying types instead of wrappers to produce the most performant and optimized code. However, sometimes it is necessary to keep wrappers around. As a rule of thumb, inline classes are boxed whenever they are used as another type.</source>
          <target state="translated">Kotlin コンパイラは、最もパフォーマンスが高く最適化されたコードを生成するために、ラッパーではなく基本的な型を使用することを好むでしょう。しかし、時にはラッパーを使い続ける必要があることもあります。経験則として、インラインクラスが他の型として使われるときは必ず箱詰めされます。</target>
        </trans-unit>
        <trans-unit id="b1defae0fa9dbdfd545ce26ab8cc2b793d3d11fe" translate="yes" xml:space="preserve">
          <source>The Kotlin compiler will use this restriction to aggressively optimize runtime representation of inline classes and substitute their instances with the value of the underlying property where possible removing constructor calls, GC pressure, and enabling other optimizations:</source>
          <target state="translated">Kotlinコンパイラはこの制限を利用してインラインクラスのランタイム表現を積極的に最適化し、可能であればそのインスタンスを基礎となるプロパティの値で置き換え、コンストラクタの呼び出しやGCの圧力を取り除き、他の最適化を可能にします。</target>
        </trans-unit>
        <trans-unit id="d850079f06081665ec514cb65c4f969e8d679814" translate="yes" xml:space="preserve">
          <source>The Kotlin language and toolset are divided into many components such as the compilers for the JVM, JS and Native targets, the Standard Library, various accompanying tools and so on. Many of these components were officially released as &lt;strong&gt;Stable&lt;/strong&gt; which means that they are evolved in the backward-compatible way following the &lt;a href=&quot;kotlin-evolution&quot;&gt;principles&lt;/a&gt; of &lt;em&gt;Comfortable Updates&lt;/em&gt; and &lt;em&gt;Keeping the Language Modern&lt;/em&gt;. Among such stable components are, for example, the Kotlin compiler for the JVM, the Standard Library, and Coroutines.</source>
          <target state="translated">Kotlinの言語とツールセットは、JVM、JS、ネイティブターゲットのコンパイラ、標準ライブラリ、さまざまな付属ツールなど、多くのコンポーネントに分かれています。これらのコンポーネントの多くは&lt;strong&gt;Stable&lt;/strong&gt;として正式にリリースされまし&lt;strong&gt;た&lt;/strong&gt;。つまり、&lt;em&gt;快適な更新&lt;/em&gt;と&lt;em&gt;言語の最新性の維持の&lt;/em&gt;&lt;a href=&quot;kotlin-evolution&quot;&gt;原則&lt;/a&gt;に従って、下位互換性のある方法で進化しています。このような安定したコンポーネントには、たとえば、JVM用のKotlinコンパイラ、標準ライブラリ、コルーチンなどがあります。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="421148b46361ca016988f110ea6a768864eebc2b" translate="yes" xml:space="preserve">
          <source>The Kotlin plugin also bundles a Java to Kotlin converter (&lt;em&gt;J2K&lt;/em&gt;) that automatically converts Java files to Kotlin. To use J2K on a file, click &lt;strong&gt;Convert Java File to Kotlin File&lt;/strong&gt; in its context menu or in the &lt;strong&gt;Code&lt;/strong&gt; menu of IntelliJ IDEA.</source>
          <target state="translated">Kotlinプラグインには、JavaファイルをKotlinに自動的に変換するJava to Kotlinコンバーター（&lt;em&gt;J2K&lt;/em&gt;）もバンドルされています。ファイルでJ2Kを使用するには、コンテキストメニューまたはIntelliJ IDEAの[ &lt;strong&gt;コード&lt;/strong&gt; ]メニューで[ &lt;strong&gt;JavaファイルをKotlinファイル&lt;/strong&gt;に&lt;strong&gt;変換&lt;/strong&gt; ]をクリックします。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f2e3c8e9ac9f87a3c6a3c66f4442bdb2dd4de716" translate="yes" xml:space="preserve">
          <source>The Kotlin plugin for IntelliJ IDEA supports &lt;a href=&quot;https://www.jetbrains.com/help/idea/scratches.html&quot;&gt;&lt;em&gt;scratches&lt;/em&gt;&lt;/a&gt; and &lt;em&gt;worksheets.&lt;/em&gt;</source>
          <target state="translated">IntelliJ IDEA用のKotlinプラグインは、&lt;a href=&quot;https://www.jetbrains.com/help/idea/scratches.html&quot;&gt;&lt;em&gt;スクラッチ&lt;/em&gt;&lt;/a&gt;と&lt;em&gt;ワークシートを&lt;/em&gt;サポートしてい&lt;em&gt;ます。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8d656f515ef009525fec5de5fd6f927dce6dbed0" translate="yes" xml:space="preserve">
          <source>The Kotlin plugin supports &lt;a href=&quot;https://guides.gradle.org/using-build-cache/&quot;&gt;Gradle Build Cache&lt;/a&gt; (Gradle version 4.3 and above is required; caching is disabled with lower versions).</source>
          <target state="translated">Kotlinプラグインは&lt;a href=&quot;https://guides.gradle.org/using-build-cache/&quot;&gt;Gradleビルドキャッシュを&lt;/a&gt;サポートします（Gradleバージョン4.3以降が必要です。それより低いバージョンではキャッシングが無効になります）。</target>
        </trans-unit>
        <trans-unit id="bb12e098841b4fa9ff61972654d2907071becf6c" translate="yes" xml:space="preserve">
          <source>The Kotlin plugin supports &lt;a href=&quot;https://guides.gradle.org/using-build-cache/&quot;&gt;Gradle Build Cache&lt;/a&gt;.</source>
          <target state="translated">Kotlinプラグインは&lt;a href=&quot;https://guides.gradle.org/using-build-cache/&quot;&gt;GradleBuildCacheを&lt;/a&gt;サポートしています。</target>
        </trans-unit>
        <trans-unit id="4e886321a88f27f1211fc7e6327218f1b649f0a9" translate="yes" xml:space="preserve">
          <source>The Kotlin sources are arranged into &lt;a href=&quot;#configuring-source-sets&quot;&gt;source sets&lt;/a&gt;. In addition to Kotlin source files and resources, each source set may have its own dependencies. Source sets form a hierarchy that is built with the &lt;em&gt;&quot;depends on&quot;&lt;/em&gt; relation. A source set by itself is platform agnostic, but it may contain platform-specific code and dependencies if it's only compiled for a single platform.</source>
          <target state="translated">Kotlinソースは&lt;a href=&quot;#configuring-source-sets&quot;&gt;ソースセットに&lt;/a&gt;配置されます。Kotlinソースファイルとリソースに加えて、各ソースセットには独自の依存関係がある場合があります。ソースセットは、&lt;em&gt;「依存」&lt;/em&gt;関係で構築された階層を形成します。単独で設定されたソースはプラットフォームに依存しませんが、単一のプラットフォーム用にのみコンパイルされている場合は、プラットフォーム固有のコードと依存関係が含まれている可能性があります。</target>
        </trans-unit>
        <trans-unit id="16279f302f8a88f25bf841c70c273ae22857462c" translate="yes" xml:space="preserve">
          <source>The Kotlin standard library &lt;code&gt;kotlin-stdlib&lt;/code&gt; targets Java 6 and above. There are extended versions of the standard library that add support for some of the features of JDK 7 and JDK 8. To use these versions, add one of the following dependencies instead of &lt;code&gt;kotlin-stdlib&lt;/code&gt;:</source>
          <target state="translated">Kotlin標準ライブラリ &lt;code&gt;kotlin-stdlib&lt;/code&gt; は、Java 6以降を対象としています。JDK 7とJDK 8の一部の機能のサポートを追加する標準ライブラリの拡張バージョンがあります。これらのバージョンを使用するには、 &lt;code&gt;kotlin-stdlib&lt;/code&gt; の代わりに次の依存関係のいずれかを追加します。</target>
        </trans-unit>
        <trans-unit id="e19faba3d18413b5a548d796d002602d1f6b7b0d" translate="yes" xml:space="preserve">
          <source>The Kotlin standard library contains extension functions for retrieving parts of a collection. These functions provide a variety of ways to select elements for the result collection: listing their positions explicitly, specifying the result size, and others.</source>
          <target state="translated">Kotlin標準ライブラリには、コレクションの一部を取得するための拡張関数が含まれています。これらの関数は、結果コレクションの要素を選択するための様々な方法を提供しています:位置を明示的にリストアップしたり、結果のサイズを指定したり、その他。</target>
        </trans-unit>
        <trans-unit id="aee8a9e1bcfd6364e58b2c53a697014bcd222ec2" translate="yes" xml:space="preserve">
          <source>The Kotlin standard library contains several functions whose sole purpose is to execute a block of code within the context of an object. When you call such a function on an object with a &lt;a href=&quot;lambdas&quot;&gt;lambda expression&lt;/a&gt; provided, it forms a temporary scope. In this scope, you can access the object without its name. Such functions are called &lt;em&gt;scope functions&lt;/em&gt;. There are five of them: &lt;code&gt;let&lt;/code&gt;, &lt;code&gt;run&lt;/code&gt;, &lt;code&gt;with&lt;/code&gt;, &lt;code&gt;apply&lt;/code&gt;, and &lt;code&gt;also&lt;/code&gt;.</source>
          <target state="translated">Kotlin標準ライブラリには、オブジェクトのコンテキスト内でコードのブロックを実行することを唯一の目的とするいくつかの関数が含まれています。&lt;a href=&quot;lambdas&quot;&gt;ラムダ式が指定&lt;/a&gt;されたオブジェクトでこのような関数を呼び出すと、一時的なスコープが形成されます。このスコープでは、名前なしでオブジェクトにアクセスできます。このような関数は、&lt;em&gt;スコープ関数&lt;/em&gt;と呼ばれ&lt;em&gt;ます&lt;/em&gt;。それらの5つがあります &lt;code&gt;let&lt;/code&gt; 、 &lt;code&gt;run&lt;/code&gt; 、 &lt;code&gt;with&lt;/code&gt; 、 &lt;code&gt;apply&lt;/code&gt; 、および &lt;code&gt;also&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="41ab82952f2d2fb6d715a1d54dee47f369b23a5d" translate="yes" xml:space="preserve">
          <source>The Kotlin standard library is available on &lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm&lt;/a&gt; and we can simply include it in our &lt;code&gt;package.json&lt;/code&gt; as a dependency.</source>
          <target state="translated">Kotlin標準ライブラリは&lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm&lt;/a&gt;で使用でき、 &lt;code&gt;package.json&lt;/code&gt; に依存関係として単に含めることができます。</target>
        </trans-unit>
        <trans-unit id="aa008c18e28c0e852d10e5f6a39e59c2d9ab879a" translate="yes" xml:space="preserve">
          <source>The Kotlin standard library is now fully compatible with the Java 9 module system, which forbids split packages (multiple jar files declaring classes in the same package). In order to support that, new artifacts &lt;code&gt;kotlin-stdlib-jdk7&lt;/code&gt; and &lt;code&gt;kotlin-stdlib-jdk8&lt;/code&gt; are introduced, which replace the old &lt;code&gt;kotlin-stdlib-jre7&lt;/code&gt; and &lt;code&gt;kotlin-stdlib-jre8&lt;/code&gt;.</source>
          <target state="translated">Kotlin標準ライブラリは、Java 9モジュールシステムと完全に互換性があるようになりました。これにより、パッケージの分割（同じパッケージでクラスを宣言する複数のjarファイル）が禁止されます。これをサポートするために、 &lt;code&gt;kotlin-stdlib-jdk7&lt;/code&gt; アーティファクトkotlin-stdlib-jdk7および &lt;code&gt;kotlin-stdlib-jdk8&lt;/code&gt; が導入されました。これらは、古い &lt;code&gt;kotlin-stdlib-jre7&lt;/code&gt; および &lt;code&gt;kotlin-stdlib-jre8&lt;/code&gt; に置き換わるものです。</target>
        </trans-unit>
        <trans-unit id="870dd777a08235fb630e1002ab11ba8d4d93e900" translate="yes" xml:space="preserve">
          <source>The Kotlin standard library offers a broad variety of functions for performing operations on collections. This includes simple operations, such as getting or adding elements, as well as more complex ones including search, sorting, filtering, transformations, and so on.</source>
          <target state="translated">Kotlin標準ライブラリには、コレクションに対する操作を行うための様々な関数が用意されています。これには、要素の取得や追加などの単純な操作から、検索、ソート、フィルタリング、変換などのより複雑な操作までが含まれます。</target>
        </trans-unit>
        <trans-unit id="7504a2da20208970eadd23d20d879fda0292513a" translate="yes" xml:space="preserve">
          <source>The Kotlin standard library provides a series of wrappers around the JavaScript API for interacting with documents. The main component we'd usually access is the variable &lt;code&gt;document&lt;/code&gt;. Given we have access to this, we can simply read and write to the corresponding properties. For instance, to set the background of the page we can do</source>
          <target state="translated">Kotlin標準ライブラリは、ドキュメントと対話するためのJavaScript APIの一連のラッパーを提供します。通常アクセスする主なコンポーネントは可変 &lt;code&gt;document&lt;/code&gt; です。これにアクセスできれば、対応するプロパティの読み取りと書き込みを行うだけです。たとえば、ページの背景を設定するには、</target>
        </trans-unit>
        <trans-unit id="d4672fe3591cd8e490f322d7264f5d7b48dbb930" translate="yes" xml:space="preserve">
          <source>The Kotlin standard library provides a set of extension functions for collection &lt;em&gt;transformations&lt;/em&gt;. These functions build new collections from existing ones based on the transformation rules provided. In this page, we'll give an overview of the available collection transformation functions.</source>
          <target state="translated">Kotlin標準ライブラリは、コレクション&lt;em&gt;変換の&lt;/em&gt;ための一連の拡張関数を提供します。これらの関数は、提供された変換ルールに基づいて、既存のコレクションから新しいコレクションを構築します。このページでは、利用可能なコレクション変換関数の概要を説明します。</target>
        </trans-unit>
        <trans-unit id="0d403b1b6b6cec3fc85d2c8444ad4595fd15211b" translate="yes" xml:space="preserve">
          <source>The Kotlin standard library provides developers with a mechanism for creating and using &lt;em&gt;experimental&lt;/em&gt; APIs. This mechanism lets library authors inform users that certain components of their API, such as classes or functions, are unstable and are likely to change in the future. Such changes may require rewriting and recompiling the client code. To prevent potential compatibility issues, the compiler warns users of the experimental status of such APIs and may require them to give their explicit consent to use the API.</source>
          <target state="translated">Kotlin標準ライブラリは、&lt;em&gt;実験的な&lt;/em&gt; API を作成および使用するためのメカニズムを開発者に提供します。このメカニズムにより、ライブラリの作成者は、クラスや関数など、APIの特定のコンポーネントが不安定であり、将来変更される可能性があることをユーザーに通知できます。このような変更には、クライアントコードの書き換えと再コンパイルが必要な場合があります。潜在的な互換性の問題を防ぐために、コンパイラーはそのようなAPIの試験的なステータスをユーザーに警告し、APIを使用することについて明示的な同意をユーザーに要求する場合があります。</target>
        </trans-unit>
        <trans-unit id="25b12f54730219e6bd01543d34c7f6d86941696e" translate="yes" xml:space="preserve">
          <source>The Kotlin standard library provides extension functions for grouping collection elements. The basic function &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/group-by&quot;&gt;&lt;code&gt;groupBy()&lt;/code&gt;&lt;/a&gt; takes a lambda function and returns a &lt;code&gt;Map&lt;/code&gt;. In this map, each key is the lambda result and the corresponding value is the &lt;code&gt;List&lt;/code&gt; of elements on which this result is returned. This function can be used, for example, to group a list of &lt;code&gt;String&lt;/code&gt;s by their first letter.</source>
          <target state="translated">Kotlin標準ライブラリは、コレクション要素をグループ化するための拡張関数を提供します。基本的な関数&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/group-by&quot;&gt; &lt;code&gt;groupBy()&lt;/code&gt; &lt;/a&gt;はラムダ関数を取り、 &lt;code&gt;Map&lt;/code&gt; を返します。このマップでは、各キーはラムダ結果であり、対応する値はこの結果が返される要素の &lt;code&gt;List&lt;/code&gt; です。この関数は、たとえば &lt;code&gt;String&lt;/code&gt; のリストを最初の文字でグループ化するために使用できます。</target>
        </trans-unit>
        <trans-unit id="d49763e3623bb841ba6b661af00bff69df48a815" translate="yes" xml:space="preserve">
          <source>The Kotlin standard library provides factory methods for several useful kinds of delegates.</source>
          <target state="translated">Kotlin標準ライブラリは、いくつかの有用なデリゲートのファクトリメソッドを提供しています。</target>
        </trans-unit>
        <trans-unit id="d4752902cbbab973b31545d271408bf4e6b55c29" translate="yes" xml:space="preserve">
          <source>The Kotlin team offers a set of tools for Android development that goes beyond the standard language features:</source>
          <target state="translated">Kotlinチームは、標準的な言語機能を超えたAndroid開発のためのツールセットを提供しています。</target>
        </trans-unit>
        <trans-unit id="3835dcf5cfa983896474e2202e8aad1e87118beb" translate="yes" xml:space="preserve">
          <source>The Kotlin visibilities are mapped to Java in the following way:</source>
          <target state="translated">Kotlinの可視性は、以下のようにJavaにマッピングされています。</target>
        </trans-unit>
        <trans-unit id="ed293f7536e6525a4d07d9691dc5108b394e4a3c" translate="yes" xml:space="preserve">
          <source>The Kotlin visibility modifiers map to Java in the following way:</source>
          <target state="translated">Kotlin の可視性修飾子は、以下のように Java にマッピングされます。</target>
        </trans-unit>
        <trans-unit id="f818f7eac72c440d892f7b7bd134c99b2cf031b4" translate="yes" xml:space="preserve">
          <source>The Kotlin/JS Gradle plugin handles DCE automatically when you build a &lt;strong&gt;production bundle&lt;/strong&gt;, for example by using the &lt;code&gt;browserProductionWebpack&lt;/code&gt; task. &lt;strong&gt;Development bundling&lt;/strong&gt; tasks (like &lt;code&gt;browserDevelopmentWebpack&lt;/code&gt;) don't include DCE.</source>
          <target state="translated">Kotlin / JS Gradleプラグインは、たとえば &lt;code&gt;browserProductionWebpack&lt;/code&gt; タスクを使用して、&lt;strong&gt;プロダクションバンドル&lt;/strong&gt;をビルドするときに、DCEを自動的に処理します。&lt;strong&gt;開発バンドル&lt;/strong&gt;タスク（ &lt;code&gt;browserDevelopmentWebpack&lt;/code&gt; など）にはDCEは含まれていません。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9e48978274145dccf82bae99c2dc2a30b0c91f68" translate="yes" xml:space="preserve">
          <source>The Kotlin/JS Gradle plugin includes a &lt;a href=&quot;https://wikipedia.org/wiki/Dead_code_elimination&quot;&gt;&lt;em&gt;dead code elimination&lt;/em&gt;&lt;/a&gt; (&lt;em&gt;DCE&lt;/em&gt;) tool. Dead code elimination is often also called &lt;em&gt;tree shaking&lt;/em&gt;. It reduces the size or the resulting JavaScript code by removing unused properties, functions, and classes.</source>
          <target state="translated">Kotlin / JS Gradleプラグインには、&lt;a href=&quot;https://wikipedia.org/wiki/Dead_code_elimination&quot;&gt;&lt;em&gt;デッドコード除去&lt;/em&gt;&lt;/a&gt;（&lt;em&gt;DCE&lt;/em&gt;）ツールが含まれています。デッドコードの除去は、&lt;em&gt;ツリーシェイク&lt;/em&gt;とも呼ばれ&lt;em&gt;ます&lt;/em&gt;。未使用のプロパティ、関数、およびクラスを削除することにより、サイズまたは結果のJavaScriptコードを削減します。</target>
        </trans-unit>
        <trans-unit id="6d899757cb2398280c10acb19695bbcab979ce63" translate="yes" xml:space="preserve">
          <source>The Kotlin/Native compiler is available for macOS, Linux, and Windows. It supports different targets including iOS (arm32, arm64, simulator x86_64), Windows (mingw32 and x86_64), Linux (x86_64, arm64, MIPS), macOS (x86_64), Raspberry PI, SMT32, WASM. For the full list of targets we can refer to the &lt;a href=&quot;../../reference/native-overview&quot;&gt;Kotlin/Native overview&lt;/a&gt;. While cross-platform compilation is possible (i.e., using one platform to compile for another), in this first tutorial we are only compiling for the operating system we're running on.</source>
          <target state="translated">Kotlin / Nativeコンパイラーは、macOS、Linux、およびWindowsで使用できます。iOS（arm32、arm64、シミュレータx86_64）、Windows（mingw32およびx86_64）、Linux（x86_64、arm64、MIPS）、macOS（x86_64）、Raspberry PI、SMT32、WASMなどのさまざまなターゲットをサポートしています。ターゲットの完全なリストについては、&lt;a href=&quot;../../reference/native-overview&quot;&gt;Kotlin /ネイティブの概要を&lt;/a&gt;参照できます。クロスプラットフォームコンパイルは可能です（つまり、あるプラットフォームを使用して別のプラットフォームをコンパイルする）が、この最初のチュートリアルでは、実行中のオペレーティングシステム用にのみコンパイルします。</target>
        </trans-unit>
        <trans-unit id="81130cfc1e83adbcab9e6da86955c53516b100d6" translate="yes" xml:space="preserve">
          <source>The Language Committee makes final decisions on what incompatible changes will be made and what exact measures should be taken to make user updates comfortable. In doing so, it relies on a set of guidelines available &lt;a href=&quot;https://kotlinlang.org/foundation/language-committee-guidelines.html&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">言語委員会は、互換性のない変更を行うか、ユーザーの更新を快適にするためにどのような正確な措置をとるべきかについて最終決定を下します。その際、&lt;a href=&quot;https://kotlinlang.org/foundation/language-committee-guidelines.html&quot;&gt;ここで&lt;/a&gt;利用可能な一連のガイドラインに依存します。</target>
        </trans-unit>
        <trans-unit id="ef80e6d685a55893a99e950f4ed7fce2a86a1387" translate="yes" xml:space="preserve">
          <source>The Maven coordinates can be altered and additional artifact files may be added to the publications within the &lt;code&gt;targets { ... }&lt;/code&gt; block or the &lt;code&gt;publishing { ... }&lt;/code&gt; DSL:</source>
          <target state="translated">Maven座標は変更可能であり、 &lt;code&gt;targets { ... }&lt;/code&gt; ブロックまたは &lt;code&gt;publishing { ... }&lt;/code&gt; DSL 内のパブリケーションに追加のアーティファクトファイルを追加できます。</target>
        </trans-unit>
        <trans-unit id="88e2042b128835939040b35b47b76d2e41113fdc" translate="yes" xml:space="preserve">
          <source>The Node.js target provided by Kotlin/JS enables you to create applications that &lt;strong&gt;run on a server&lt;/strong&gt; or get &lt;strong&gt;executed on serverless infrastructure&lt;/strong&gt;. You benefit from the same advantages as other applications executing in a JavaScript runtime, such as &lt;strong&gt;faster startup speed&lt;/strong&gt; and a &lt;strong&gt;reduced memory footprint&lt;/strong&gt;. With &lt;a href=&quot;https://github.com/Kotlin/kotlinx-nodejs&quot;&gt;&lt;code&gt;kotlinx-nodejs&lt;/code&gt;&lt;/a&gt;, you have typesafe access to the &lt;a href=&quot;https://nodejs.org/docs/latest/api/&quot;&gt;Node.js API&lt;/a&gt; directly from your Kotlin code.</source>
          <target state="translated">Kotlin / JSが提供するNode.jsターゲットを使用&lt;strong&gt;すると、サーバー上&lt;/strong&gt;で&lt;strong&gt;実行したり、サーバー&lt;/strong&gt;&lt;strong&gt;レスインフラストラクチャで実行し&lt;/strong&gt;たりするアプリケーションを作成できます。&lt;strong&gt;起動速度の高速化&lt;/strong&gt;や&lt;strong&gt;メモリフットプリントの削減&lt;/strong&gt;など、JavaScriptランタイムで実行される他のアプリケーションと同じ利点があります。&lt;a href=&quot;https://github.com/Kotlin/kotlinx-nodejs&quot;&gt; &lt;code&gt;kotlinx-nodejs&lt;/code&gt; &lt;/a&gt;、あなたはへのタイプセーフアクセスしてい&lt;a href=&quot;https://nodejs.org/docs/latest/api/&quot;&gt;Node.jsのAPI&lt;/a&gt;あなたKotlinコードから直接に。</target>
        </trans-unit>
        <trans-unit id="cc27fb0be25fb775df8eea4ef2ba6465502161d0" translate="yes" xml:space="preserve">
          <source>The Nothing type</source>
          <target state="translated">何もないタイプ</target>
        </trans-unit>
        <trans-unit id="8cc0334fa925283a3687c8c8309944d9801a3bf7" translate="yes" xml:space="preserve">
          <source>The REPL command line interface opens. You can enter any valid Kotlin code and see the result. Results are printed as variables with auto-generated names like &lt;code&gt;res*&lt;/code&gt;. You can later use such variables in the code you run in REPL.</source>
          <target state="translated">REPLコマンドラインインターフェイスが開きます。有効なKotlinコードを入力して、結果を確認できます。結果は &lt;code&gt;res*&lt;/code&gt; ような自動生成された名前を持つ変数として出力されます。後で、REPLで実行するコードでそのような変数を使用できます。</target>
        </trans-unit>
        <trans-unit id="8fd3a2d7df046fd886264d64f792856593ec9b52" translate="yes" xml:space="preserve">
          <source>The REPL command line interface will open. You can enter any valid Kotlin code and see the result. The results are printed as variables with auto-generated names like &lt;code&gt;res*&lt;/code&gt;. You can later use such variables in the code you run in REPL.</source>
          <target state="translated">REPLコマンドラインインターフェイスが開きます。有効なKotlinコードを入力して、結果を確認できます。結果は、 &lt;code&gt;res*&lt;/code&gt; ような自動生成された名前の変数として出力されます。後で、REPLで実行するコードでそのような変数を使用できます。</target>
        </trans-unit>
        <trans-unit id="2b7ee6e00ac4369b5da7230befe3c113bdc4222a" translate="yes" xml:space="preserve">
          <source>The above code compiles. However, it will produce a runtime error if the object is not properly initialised before use or if &lt;code&gt;callAnything()&lt;/code&gt; is not defined at runtime.</source>
          <target state="translated">上記のコードはコンパイルされます。ただし、オブジェクトが使用前に適切に初期化されていない場合、または &lt;code&gt;callAnything()&lt;/code&gt; が実行時に定義されていない場合は、実行時エラーが発生します。</target>
        </trans-unit>
        <trans-unit id="f67cd69d25bde43de96336b3847aa293b8518b9e" translate="yes" xml:space="preserve">
          <source>The above code indicates that the function is defined externally. The &lt;code&gt;@JsName(&quot;$&quot;)&lt;/code&gt; annotation allows us to map the name at runtime to &lt;code&gt;$&lt;/code&gt;. For more details on external declarations, please refer to the &lt;a href=&quot;../../reference/js-interop#external-modifier&quot;&gt;JavaScript interop documentation&lt;/a&gt;.</source>
          <target state="translated">上記のコードは、関数が外部で定義されていることを示しています。 &lt;code&gt;@JsName(&quot;$&quot;)&lt;/code&gt; 注釈は、私たちは実行時に名前をマッピングすることができます &lt;code&gt;$&lt;/code&gt; 。外部宣言の詳細については、&lt;a href=&quot;../../reference/js-interop#external-modifier&quot;&gt;JavaScriptの相互運用ドキュメント&lt;/a&gt;をご覧ください。</target>
        </trans-unit>
        <trans-unit id="5749a0f0fe8aac855f406af86fe841d365cd7cde" translate="yes" xml:space="preserve">
          <source>The above could also be a oneliner - and note that the compiler knows that because the &lt;code&gt;throw&lt;/code&gt; will prevent &lt;code&gt;y&lt;/code&gt; from coming into existence if &lt;code&gt;x&lt;/code&gt; is null, &lt;code&gt;y&lt;/code&gt; must be non-null if we reach the line below. Contrast this with &lt;code&gt;x?.importantFunction()&lt;/code&gt;, which is a no-op if &lt;code&gt;x&lt;/code&gt; is null.</source>
          <target state="translated">上記はonelinerである可能性もあります。また、コンパイラーは、 &lt;code&gt;x&lt;/code&gt; がnullの場合、 &lt;code&gt;throw&lt;/code&gt; によって &lt;code&gt;y&lt;/code&gt; が存在しないようにするため、以下の行に到達した場合、 &lt;code&gt;y&lt;/code&gt; はnull 以外でなければならないことを知っています。これを &lt;code&gt;x?.importantFunction()&lt;/code&gt; と比較してください。これは、 &lt;code&gt;x&lt;/code&gt; がnullの場合は何もしません。</target>
        </trans-unit>
        <trans-unit id="a87217033eafba44229106ab25d3816102c24f78" translate="yes" xml:space="preserve">
          <source>The above is preferable to:</source>
          <target state="translated">以上であることが好ましい。</target>
        </trans-unit>
        <trans-unit id="83d32caa4c432fbb23e6f884577d8ac97faf56a2" translate="yes" xml:space="preserve">
          <source>The affected type parameter or type is &lt;em&gt;contravariant&lt;/em&gt;. Denoted by the &lt;code&gt;in&lt;/code&gt; modifier in the source code.</source>
          <target state="translated">影響を受ける型パラメーターまたは型は&lt;em&gt;反変&lt;/em&gt;です。ソースコードの &lt;code&gt;in&lt;/code&gt; 修飾子で示されます。</target>
        </trans-unit>
        <trans-unit id="c340d256f4b2e039e4cb98547a639c6b4f11b7ba" translate="yes" xml:space="preserve">
          <source>The affected type parameter or type is &lt;em&gt;covariant&lt;/em&gt;. Denoted by the &lt;code&gt;out&lt;/code&gt; modifier in the source code.</source>
          <target state="translated">影響を受ける型パラメーターまたは型は&lt;em&gt;共変&lt;/em&gt;です。ソースコードの &lt;code&gt;out&lt;/code&gt; 修飾子で示されます。</target>
        </trans-unit>
        <trans-unit id="dff58c2fdf74d3cdbb35c54ab0e0155e83797493" translate="yes" xml:space="preserve">
          <source>The affected type parameter or type is &lt;em&gt;invariant&lt;/em&gt;, which means it has no variance applied to it.</source>
          <target state="translated">影響を受ける型パラメーターまたは型は&lt;em&gt;不変&lt;/em&gt;です。つまり、分散が適用されていません。</target>
        </trans-unit>
        <trans-unit id="e638916d7acda84432e87e4a36d2e48c0c286bc5" translate="yes" xml:space="preserve">
          <source>The annotation also works for constructors, static methods, and so on. It can't be used on abstract methods, including methods defined in interfaces.</source>
          <target state="translated">このアノテーションは、コンストラクタや静的メソッドなどでも動作します。インターフェースで定義されているメソッドなど、抽象的なメソッドには使用できません。</target>
        </trans-unit>
        <trans-unit id="718f26b180ad67d2a1e20d6b7d4406049d2961a3" translate="yes" xml:space="preserve">
          <source>The annotation can be used on top-level external declarations (classes, properties, functions) and files. In case of file (which can't be &lt;code&gt;external&lt;/code&gt;) the following rule applies: all the declarations in the file must be &lt;code&gt;external&lt;/code&gt;. By applying &lt;code&gt;@JsModule(...)&lt;/code&gt; on a file you tell the compiler to import a JavaScript object that contain all the declarations from the file.</source>
          <target state="translated">アノテーションは、トップレベルの外部宣言（クラス、プロパティ、関数）およびファイルで使用できます。ファイル（ &lt;code&gt;external&lt;/code&gt; することはできません）の場合、次の規則が適用されます。ファイル内のすべての宣言は &lt;code&gt;external&lt;/code&gt; なければなりません。 &lt;code&gt;@JsModule(...)&lt;/code&gt; をファイルに適用することにより、ファイルからのすべての宣言を含むJavaScriptオブジェクトをインポートするようコンパイラーに指示します。</target>
        </trans-unit>
        <trans-unit id="ac7d8e089591134bac44995dadba571525f38003" translate="yes" xml:space="preserve">
          <source>The annotation has effect only in Kotlin/Native platform.</source>
          <target state="translated">アノテーションはKotlin/Nativeプラットフォームでのみ有効です。</target>
        </trans-unit>
        <trans-unit id="993a0bc9861bdf8ea351a5eb1dd7c588f24a97de" translate="yes" xml:space="preserve">
          <source>The annotations for marking and using experimental APIs (&lt;code&gt;@Experimental&lt;/code&gt; and &lt;code&gt;@UseExperimental&lt;/code&gt;) are &lt;em&gt;experimental&lt;/em&gt; in Kotlin 1.3. See details &lt;a href=&quot;#experimental-status-of-experimental-api-markers&quot;&gt;below&lt;/a&gt;.</source>
          <target state="translated">実験的なAPI（ &lt;code&gt;@Experimental&lt;/code&gt; および &lt;code&gt;@UseExperimental&lt;/code&gt; ）をマークおよび使用するためのアノテーションは、Kotlin 1.3では&lt;em&gt;実験的なもの&lt;/em&gt;です。詳細は&lt;a href=&quot;#experimental-status-of-experimental-api-markers&quot;&gt;以下を&lt;/a&gt;ご覧ください。</target>
        </trans-unit>
        <trans-unit id="ecb7079c4ed4f36ab04fb8b963913758bd291799" translate="yes" xml:space="preserve">
          <source>The anonymous function syntax allows you to specify the receiver type of a function literal directly. This can be useful if you need to declare a variable of a function type with receiver, and to use it later.</source>
          <target state="translated">匿名関数構文では、関数リテラルのレシーバ型を直接指定することができます。これは、関数型の変数をレシーバで宣言して、後でそれを使用する必要がある場合に便利です。</target>
        </trans-unit>
        <trans-unit id="e99a96b83211ab5edf0514b0e8d206e232457fc5" translate="yes" xml:space="preserve">
          <source>The application we're going to create will simply show &lt;code&gt;Kotlin Rocks on Android&lt;/code&gt; on Android and &lt;code&gt;Kotlin Rocks on iOS &amp;lt;version&amp;gt;&lt;/code&gt; on iOS. The idea is to share the code that generates this message.</source>
          <target state="translated">これから作成するアプリケーションでは &lt;code&gt;Kotlin Rocks on Android&lt;/code&gt; ではAndroidに &lt;code&gt;Kotlin Rocks on iOS &amp;lt;version&amp;gt;&lt;/code&gt; にKotlin Rocksを表示します。アイデアは、このメッセージを生成するコードを共有することです。</target>
        </trans-unit>
        <trans-unit id="c116b8d3b85f1f036748497d93f617762a69f1eb" translate="yes" xml:space="preserve">
          <source>The array literal syntax is constrained to annotation arguments.</source>
          <target state="translated">配列リテラル構文は、アノテーション引数に制約されます。</target>
        </trans-unit>
        <trans-unit id="e6585b22e37432101f079b3e68122b140a6c8d0b" translate="yes" xml:space="preserve">
          <source>The arrow notation is right-associative, &lt;code&gt;(Int) -&amp;gt; (Int) -&amp;gt; Unit&lt;/code&gt; is equivalent to the previous example, but not to &lt;code&gt;((Int) -&amp;gt; (Int)) -&amp;gt; Unit&lt;/code&gt;.</source>
          <target state="translated">矢印表記は右結合です。 &lt;code&gt;(Int) -&amp;gt; (Int) -&amp;gt; Unit&lt;/code&gt; は前の例と同じですが、 &lt;code&gt;((Int) -&amp;gt; (Int)) -&amp;gt; Unit&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="eff75fbb6c3dbfe907753b9474216f02d469cd66" translate="yes" xml:space="preserve">
          <source>The author strongly recommends that you use an IDE with Kotlin support, as the static typing allows an IDE to do reliable navigation and code completion. I recommend &lt;a href=&quot;https://www.jetbrains.com/idea/&quot;&gt;IntelliJ IDEA&lt;/a&gt;, which is built by the same company that created Kotlin. The Community Edition is free; see &lt;a href=&quot;../getting-started&quot;&gt;instructions for getting started&lt;/a&gt; (it comes bundled with Kotlin, and you can run your program from the IDE).</source>
          <target state="translated">静的型付けによりIDEは信頼性の高いナビゲーションとコード補完を実行できるため、作成者はKotlinをサポートするIDEを使用することを強くお勧めします。Kotlinを作成したのと同じ会社が開発した&lt;a href=&quot;https://www.jetbrains.com/idea/&quot;&gt;IntelliJ IDEA&lt;/a&gt;をお勧めします。Community Editionは無料です。&lt;a href=&quot;../getting-started&quot;&gt;開始の手順を&lt;/a&gt;参照してください（Kotlinにバンドルされており、IDEからプログラムを実行できます）。</target>
        </trans-unit>
        <trans-unit id="031b37e00f6cc7d0005e366d6305ce9ae5158eb7" translate="yes" xml:space="preserve">
          <source>The available options for persistence include direct JDBC access, JPA, as well as using NoSQL databases through their Java drivers. For JPA, the &lt;a href=&quot;compiler-plugins#jpa-support&quot;&gt;kotlin-jpa compiler plugin&lt;/a&gt; adapts Kotlin-compiled classes to the requirements of the framework.</source>
          <target state="translated">永続化に使用できるオプションには、直接JDBCアクセス、JPA、およびJavaドライバーを介したNoSQLデータベースの使用が含まれます。JPAの場合、&lt;a href=&quot;compiler-plugins#jpa-support&quot;&gt;kotlin-jpaコンパイラプラグイン&lt;/a&gt;は、Kotlinでコンパイルされたクラスをフレームワークの要件に適合させます。</target>
        </trans-unit>
        <trans-unit id="f64d03b5ac4e40dff196fed46f6ad483b559e0ca" translate="yes" xml:space="preserve">
          <source>The base class for all errors and exceptions. Only instances of this class can be thrown or caught.</source>
          <target state="translated">すべてのエラーと例外の基底クラス。このクラスのインスタンスのみがスローされたりキャッチされたりします。</target>
        </trans-unit>
        <trans-unit id="9567e5bd74f98cde043ce2604d36c00a7448fbca" translate="yes" xml:space="preserve">
          <source>The base exception class is &lt;code&gt;Throwable&lt;/code&gt; (but it is more common to extend its subclass &lt;code&gt;Exception&lt;/code&gt;), and there are a ton of built-in exception classes. If you don't find one that match your needs, you can create your own by inheriting from an existing exception class.</source>
          <target state="translated">基本例外クラスは &lt;code&gt;Throwable&lt;/code&gt; ですが（そのサブクラス &lt;code&gt;Exception&lt;/code&gt; を拡張する方が一般的です）、大量の組み込み例外クラスがあります。ニーズに一致するものが見つからない場合は、既存の例外クラスから継承することにより、独自のクラスを作成できます。</target>
        </trans-unit>
        <trans-unit id="d9ecc0f2cf4982d26aff3dd399995b9e266ca38f" translate="yes" xml:space="preserve">
          <source>The basic association function &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/associate-with&quot;&gt;&lt;code&gt;associateWith()&lt;/code&gt;&lt;/a&gt; creates a &lt;code&gt;Map&lt;/code&gt; in which the elements of the original collection are keys, and values are produced from them by the given transformation function. If two elements are equal, only the last one remains in the map.</source>
          <target state="translated">基本的な関連付け関数&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/associate-with&quot;&gt; &lt;code&gt;associateWith()&lt;/code&gt; &lt;/a&gt;は、元のコレクションの要素がキーである &lt;code&gt;Map&lt;/code&gt; を作成し、指定された変換関数によってそれらから値が生成されます。2つの要素が等しい場合、最後の要素のみがマップに残ります。</target>
        </trans-unit>
        <trans-unit id="8747487378c0fd48a48984cf8a26dd2308ffac09" translate="yes" xml:space="preserve">
          <source>The basic filtering function is &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/filter&quot;&gt;&lt;code&gt;filter()&lt;/code&gt;&lt;/a&gt;. When called with a predicate, &lt;code&gt;filter()&lt;/code&gt; returns the collection elements that match it. For both &lt;code&gt;List&lt;/code&gt; and &lt;code&gt;Set&lt;/code&gt;, the resulting collection is a &lt;code&gt;List&lt;/code&gt;, for &lt;code&gt;Map&lt;/code&gt; it's a &lt;code&gt;Map&lt;/code&gt; as well.</source>
          <target state="translated">基本的なフィルタリング関数は&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/filter&quot;&gt; &lt;code&gt;filter()&lt;/code&gt; &lt;/a&gt;です。述語で呼び出されると、 &lt;code&gt;filter()&lt;/code&gt; はそれに一致するコレクション要素を返します。 &lt;code&gt;List&lt;/code&gt; と &lt;code&gt;Set&lt;/code&gt; の両方で、結果のコレクションは &lt;code&gt;List&lt;/code&gt; です &lt;code&gt;Map&lt;/code&gt; 場合も同様に &lt;code&gt;Map&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="699437afba4c1eb6f2aa1a305318c9d9571a4fe8" translate="yes" xml:space="preserve">
          <source>The basic functions &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/sorted&quot;&gt;&lt;code&gt;sorted()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/sorted-descending&quot;&gt;&lt;code&gt;sortedDescending()&lt;/code&gt;&lt;/a&gt; return elements of a collection sorted into ascending and descending sequence according to their natural order. These functions apply to collections of &lt;code&gt;Comparable&lt;/code&gt; elements.</source>
          <target state="translated">基本的な関数&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/sorted&quot;&gt; &lt;code&gt;sorted()&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/sorted-descending&quot;&gt; &lt;code&gt;sortedDescending()&lt;/code&gt; &lt;/a&gt;は、自然な順序に従って昇順と降順にソートされたコレクションの要素を返します。これらの関数は、 &lt;code&gt;Comparable&lt;/code&gt; 要素のコレクションに適用されます。</target>
        </trans-unit>
        <trans-unit id="176655605bee6eae4892bd4ec703e94408b0c3f3" translate="yes" xml:space="preserve">
          <source>The best place to start is &lt;a href=&quot;https://kotlinlang.org&quot;&gt;this website&lt;/a&gt;. From there you can download the compiler, &lt;a href=&quot;https://play.kotlinlang.org&quot;&gt;try it online&lt;/a&gt; as well as get access to resources, &lt;a href=&quot;index&quot;&gt;reference documentation&lt;/a&gt; and &lt;a href=&quot;../tutorials/index&quot;&gt;tutorials&lt;/a&gt;.</source>
          <target state="translated">開始するのに最適な場所は、&lt;a href=&quot;https://kotlinlang.org&quot;&gt;このWebサイト&lt;/a&gt;です。そこからコンパイラをダウンロードし、&lt;a href=&quot;https://play.kotlinlang.org&quot;&gt;オンライン&lt;/a&gt;で試すことができます。また、リソース、&lt;a href=&quot;index&quot;&gt;リファレンスドキュメント&lt;/a&gt;、&lt;a href=&quot;../tutorials/index&quot;&gt;チュートリアルに&lt;/a&gt;アクセスできます。</target>
        </trans-unit>
        <trans-unit id="a00b10508469a6652d6e476b8749625b68deb8ad" translate="yes" xml:space="preserve">
          <source>The best way to see what C data types are visible in Kotlin is to try it</source>
          <target state="translated">KotlinでどのようなC言語のデータ型が表示されているかを確認するための最良の方法は、次のようにしてみることです。</target>
        </trans-unit>
        <trans-unit id="8cccc62dffea928c706df5dfd73f9995b0b8212a" translate="yes" xml:space="preserve">
          <source>The best way to understand the mapping between C and Kotlin languages is to try it out on a small example. We will create a small library headers for that. First, we need to create a &lt;code&gt;lib.h&lt;/code&gt; file with the following declaration of functions that deal with the C strings:</source>
          <target state="translated">C言語とKotlin言語の間のマッピングを理解する最良の方法は、小さな例で試してみることです。そのための小さなライブラリヘッダーを作成します。まず、C文字列を処理する次の関数宣言を含む &lt;code&gt;lib.h&lt;/code&gt; ファイルを作成する必要があります。</target>
        </trans-unit>
        <trans-unit id="ffd6c6681f86404c6d10fd90b4e30255a8c338ed" translate="yes" xml:space="preserve">
          <source>The best way to understand the mapping between Kotlin and C is to try a tiny example. We declare a function that accepts a function pointer as a parameter and another function that returns a function pointer.</source>
          <target state="translated">KotlinとC言語の間のマッピングを理解する最良の方法は、小さな例を試してみることです。関数ポインタをパラメータとして受け取る関数と、関数ポインタを返す別の関数を宣言します。</target>
        </trans-unit>
        <trans-unit id="6537550691113ba29bcd420ea4633f14458a70b1" translate="yes" xml:space="preserve">
          <source>The best way to understand the mapping between Kotlin and C is to try a tiny example. We will declare a struct and a union in the C language, to see how they are mapped into Kotlin.</source>
          <target state="translated">Kotlin と C の間のマッピングを理解する最良の方法は、小さな例を試してみることです。構造体と組合をC言語で宣言して、それらがKotlinにどのようにマッピングされているかを見てみましょう。</target>
        </trans-unit>
        <trans-unit id="4232ac266b4561b99b9bc10fa2be9171a24a3226" translate="yes" xml:space="preserve">
          <source>The best way to understand these techniques is to try them out. Let's create a first tiny Kotlin library and use it from a C program.</source>
          <target state="translated">これらのテクニックを理解するには、実際に試してみるのが一番です。最初の小さなKotlinライブラリを作って、Cプログラムから使ってみましょう。</target>
        </trans-unit>
        <trans-unit id="eaa47ef7640a883ac2445b67958ca2668d316a2e" translate="yes" xml:space="preserve">
          <source>The best way to use the Kotlin/Native compiler is with a build system. It helps by downloading and caching the Kotlin/Native compiler binaries and libraries with transitive dependencies, and running the compiler and tests. It caches the compilation results too. A build system can also be used by an IDE to understand the project layout.</source>
          <target state="translated">Kotlin/Native コンパイラを使うための最良の方法はビルドシステムを使うことです。Kotlin/Native コンパイラのバイナリとライブラリをダウンロードしてキャッシュし、コンパイラとテストを実行することで助けてくれます。また、コンパイル結果もキャッシュされます。ビルドシステムはプロジェクトのレイアウトを理解するために IDE で使用することもできます。</target>
        </trans-unit>
        <trans-unit id="9af9e08ad353ac6ed57e0041c23dca829fbff7c4" translate="yes" xml:space="preserve">
          <source>The binaries DSL allows not only creating binaries but also accessing already created ones to configure them or get their properties (e.g. path to an output file). The &lt;code&gt;binaries&lt;/code&gt; collection implements the &lt;a href=&quot;https://docs.gradle.org/current/javadoc/org/gradle/api/DomainObjectSet.html&quot;&gt;&lt;code&gt;DomainObjectSet&lt;/code&gt;&lt;/a&gt; interface and provides methods like &lt;code&gt;all&lt;/code&gt; or &lt;code&gt;matching&lt;/code&gt; allowing configuring groups of elements.</source>
          <target state="translated">バイナリDSLを使用すると、バイナリを作成できるだけでなく、すでに作成されたバイナリにアクセスしてそれらを構成したり、プロパティ（出力ファイルへのパスなど）を取得したりすることもできます。 &lt;code&gt;binaries&lt;/code&gt; コレクションを実装&lt;a href=&quot;https://docs.gradle.org/current/javadoc/org/gradle/api/DomainObjectSet.html&quot;&gt; &lt;code&gt;DomainObjectSet&lt;/code&gt; の&lt;/a&gt;インタフェースを等方法を提供 &lt;code&gt;all&lt;/code&gt; 又は &lt;code&gt;matching&lt;/code&gt; 要素のグループを設定可能にします。</target>
        </trans-unit>
        <trans-unit id="bc8bcc38381183bfcc94707aa9b37df0e52f23b1" translate="yes" xml:space="preserve">
          <source>The binary files are created in the &lt;code&gt;build/bin/native/debugExecutable&lt;/code&gt; or &lt;code&gt;build/bin/native/releaseExecutable&lt;/code&gt; folders respectively. The file has a &lt;code&gt;.kexe&lt;/code&gt; extension on Linux and macOS and an &lt;code&gt;.exe&lt;/code&gt; extension on Windows. Use the following command to instruct the build to produce binaries:</source>
          <target state="translated">バイナリファイルは、それぞれ &lt;code&gt;build/bin/native/debugExecutable&lt;/code&gt; または &lt;code&gt;build/bin/native/releaseExecutable&lt;/code&gt; フォルダーに作成されます。このファイルには、LinuxおよびmacOSでは &lt;code&gt;.kexe&lt;/code&gt; 拡張子、Windowsでは &lt;code&gt;.exe&lt;/code&gt; 拡張子が付いています。次のコマンドを使用して、バイナリに生成するようビルドに指示します。</target>
        </trans-unit>
        <trans-unit id="54650137fcf92a797ec9822a89e0e51a3d74473c" translate="yes" xml:space="preserve">
          <source>The block after &lt;code&gt;tree(&quot;root&quot;)&lt;/code&gt; is the first function literal with receiver, which will be passed to &lt;code&gt;tree()&lt;/code&gt; as the &lt;code&gt;initialize&lt;/code&gt; parameter. According to the parameter list of &lt;code&gt;tree()&lt;/code&gt;, the receiver is of type &lt;code&gt;TreeNode&lt;/code&gt;, and therefore, &lt;code&gt;tree()&lt;/code&gt; can call &lt;code&gt;initialize()&lt;/code&gt; on &lt;code&gt;root&lt;/code&gt;. &lt;code&gt;root&lt;/code&gt; then becomes &lt;code&gt;this&lt;/code&gt; inside the scope of that lambda expression, so when we call &lt;code&gt;node(&quot;math&quot;)&lt;/code&gt;, it implicitly says &lt;code&gt;this.node(&quot;math&quot;)&lt;/code&gt;, where &lt;code&gt;this&lt;/code&gt; refers to the same &lt;code&gt;TreeNode&lt;/code&gt; as &lt;code&gt;root&lt;/code&gt;. The next block is passed to &lt;code&gt;TreeNode.node()&lt;/code&gt;, and is invoked on the first child of the &lt;code&gt;root&lt;/code&gt; node, namely &lt;code&gt;math&lt;/code&gt;, and inside it, &lt;code&gt;this&lt;/code&gt; will refer to &lt;code&gt;math&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;tree(&quot;root&quot;)&lt;/code&gt; の後のブロックは、レシーバーを備えた最初の関数リテラルであり、 &lt;code&gt;initialize&lt;/code&gt; パラメーターとして &lt;code&gt;tree()&lt;/code&gt; に渡されます。 &lt;code&gt;tree()&lt;/code&gt; のパラメーターリストによると、レシーバーは &lt;code&gt;TreeNode&lt;/code&gt; タイプであるため、 &lt;code&gt;tree()&lt;/code&gt; は &lt;code&gt;root&lt;/code&gt; で &lt;code&gt;initialize()&lt;/code&gt; を呼び出すことができます。 &lt;code&gt;root&lt;/code&gt; はそのラムダ式のスコープ内で &lt;code&gt;this&lt;/code&gt; になるため、 &lt;code&gt;node(&quot;math&quot;)&lt;/code&gt; を呼び出すと、暗黙的に &lt;code&gt;this.node(&quot;math&quot;)&lt;/code&gt; と表示されます。 &lt;code&gt;this&lt;/code&gt; は &lt;code&gt;root&lt;/code&gt; と同じ &lt;code&gt;TreeNode&lt;/code&gt; を参照します。次のブロックは &lt;code&gt;TreeNode.node()&lt;/code&gt; に渡され、 &lt;code&gt;root&lt;/code&gt; ノードの最初の子、つまり &lt;code&gt;math&lt;/code&gt; で呼び出されます。その内部では、 &lt;code&gt;this&lt;/code&gt; は &lt;code&gt;math&lt;/code&gt; を参照します。</target>
        </trans-unit>
        <trans-unit id="299004dba6c7ef441e08541633a7bed7d65922cd" translate="yes" xml:space="preserve">
          <source>The body can be a block.</source>
          <target state="translated">体がブロックになることもあります。</target>
        </trans-unit>
        <trans-unit id="d17dad4981064bd9e13820de989411c6afec8c62" translate="yes" xml:space="preserve">
          <source>The body of an object expression may access, and possibly modify, the local variables of the containing scope.</source>
          <target state="translated">オブジェクト式の本体は、スコープを含むスコープのローカル変数にアクセスしたり、変更したりすることがあります。</target>
        </trans-unit>
        <trans-unit id="6eb082a62156761cbe45120602d0be4ff5a5d1b2" translate="yes" xml:space="preserve">
          <source>The box classes used for capturing mutable closure variables in lambdas no longer have volatile fields. This change improves performance, but can lead to new race conditions in some rare usage scenarios. If you're affected by this, you need to provide your own synchronization for accessing the variables.</source>
          <target state="translated">ラムダでの変異可能なクロージャ変数のキャプチャに使用されるボックスクラスは、揮発性のフィールドを持たなくなりました。この変更によりパフォーマンスは向上しますが、一部のまれな使用シナリオでは新たな競合状態になる可能性があります。この影響を受ける場合は、変数にアクセスするための独自の同期を提供する必要があります。</target>
        </trans-unit>
        <trans-unit id="0bb1979f4fa500a54eb079957dc97f38da2dd0fd" translate="yes" xml:space="preserve">
          <source>The build generates the following files under the &lt;code&gt;build/bin/native/debugShared&lt;/code&gt; folder, depending on the host OS:</source>
          <target state="translated">ビルドは、ホストOSに応じて、 &lt;code&gt;build/bin/native/debugShared&lt;/code&gt; フォルダーの下に次のファイルを生成します。</target>
        </trans-unit>
        <trans-unit id="8d7f1cfca83f4be43b98d7bc6f3dc13e77358eda" translate="yes" xml:space="preserve">
          <source>The call to &lt;code&gt;C().foo(1)&lt;/code&gt; will print &quot;extension&quot;.</source>
          <target state="translated">&lt;code&gt;C().foo(1)&lt;/code&gt; を呼び出すと、「拡張子」が出力されます。</target>
        </trans-unit>
        <trans-unit id="5986952e4227de9affa4abe69a35c446c0bfc14d" translate="yes" xml:space="preserve">
          <source>The call to &lt;code&gt;execute&lt;/code&gt; uses a function passed as its second parameter to produce an object subgraph (i.e. set of mutually referring objects) which is then passed as a whole to that worker, it is then no longer available to the thread that initiated the request. This property is checked if the first parameter is &lt;code&gt;TransferMode.SAFE&lt;/code&gt; by graph traversal and is just assumed to be true, if it is &lt;code&gt;TransferMode.UNSAFE&lt;/code&gt;. The last parameter to &lt;code&gt;execute&lt;/code&gt; is a special Kotlin lambda, which is not allowed to capture any state, and is actually invoked in the target worker's context. Once processed, the result is transferred to whatever consumes it in the future, and it is attached to the object graph of that worker/thread.</source>
          <target state="translated">&lt;code&gt;execute&lt;/code&gt; の呼び出しは、2番目のパラメーターとして渡された関数を使用してオブジェクトサブグラフ（つまり、相互参照オブジェクトのセット）を生成し、全体としてそのワーカーに渡されると、要求を開始したスレッドで使用できなくなります。このプロパティは、最初のパラメーターがグラフトラバーサルによって &lt;code&gt;TransferMode.SAFE&lt;/code&gt; である場合にチェックされ、それが &lt;code&gt;TransferMode.UNSAFE&lt;/code&gt; である場合にのみtrueであると見なされます。 &lt;code&gt;execute&lt;/code&gt; 最後のパラメーターは特別なKotlinラムダであり、状態をキャプチャすることはできず、実際にはターゲットワーカーのコンテキストで呼び出されます。処理されると、結果は将来それを消費するものに転送され、そのワーカー/スレッドのオブジェクトグラフにアタッチされます。</target>
        </trans-unit>
        <trans-unit id="cf4d64ccc981a36348dc5e3486734b7a527c1cd6" translate="yes" xml:space="preserve">
          <source>The callback which is called after the change of the property is made. The value of the property has already been changed when this callback is invoked.</source>
          <target state="translated">プロパティの変更が行われた後に呼び出されるコールバックです。このコールバックが呼び出されたとき、プロパティの値はすでに変更されています。</target>
        </trans-unit>
        <trans-unit id="f46a88a879fdbb85f0bd5182483f8be3f20e50d2" translate="yes" xml:space="preserve">
          <source>The callback which is called before a change to the property value is attempted. The value of the property hasn't been changed yet, when this callback is invoked. If the callback returns &lt;code&gt;true&lt;/code&gt; the value of the property is being set to the new value, and if the callback returns &lt;code&gt;false&lt;/code&gt; the new value is discarded and the property remains its old value.</source>
          <target state="translated">プロパティ値の変更が試行される前に呼び出されるコールバック。このコールバックが呼び出されたとき、プロパティの値はまだ変更されていません。コールバックが &lt;code&gt;true&lt;/code&gt; を返す場合、プロパティの値は新しい値に設定され、コールバックが &lt;code&gt;false&lt;/code&gt; を返す場合、新しい値は破棄され、プロパティは古い値のままになります。</target>
        </trans-unit>
        <trans-unit id="e3032cd7941afef1fb6a2120a573d1232d288d72" translate="yes" xml:space="preserve">
          <source>The calls that affect inference are either members of the receiver type of an annotated function parameter or extensions for that type. The extensions must be themselves annotated with &lt;code&gt;@BuilderInference&lt;/code&gt;.</source>
          <target state="translated">推論に影響を与える呼び出しは、注釈付き関数パラメーターのレシーバータイプのメンバーか、そのタイプの拡張です。拡張自体は &lt;code&gt;@BuilderInference&lt;/code&gt; で注釈を付ける必要があります。</target>
        </trans-unit>
        <trans-unit id="5833c1f716afd68e76f6ee63506f61a1ac4d8150" translate="yes" xml:space="preserve">
          <source>The changes in dependencies are &lt;a href=&quot;https://en.wikipedia.org/wiki/Application_binary_interface&quot;&gt;ABI&lt;/a&gt; compatible. For example, the only changes are in method bodies.</source>
          <target state="translated">依存関係の変更は&lt;a href=&quot;https://en.wikipedia.org/wiki/Application_binary_interface&quot;&gt;ABI&lt;/a&gt;互換です。たとえば、唯一の変更はメソッド本体です。</target>
        </trans-unit>
        <trans-unit id="ca6d3d47c03bc25dbb852207c0d849513ed5fbaf" translate="yes" xml:space="preserve">
          <source>The channels shown so far had no buffer. Unbuffered channels transfer elements when sender and receiver meet each other (aka rendezvous). If send is invoked first, then it is suspended until receive is invoked, if receive is invoked first, it is suspended until send is invoked.</source>
          <target state="translated">これまで表示されていたチャンネルにはバッファがありませんでした。バッファなしのチャンネルは、送信者と受信者が出会ったときに要素を転送します (ランデブーとも呼ばれます)。send が先に起動された場合は、receive が起動されるまで中断され、receive が先に起動された場合は、send が起動されるまで中断されます。</target>
        </trans-unit>
        <trans-unit id="fa768c5c4432c77d50de790cda1c8c687dccf1cc" translate="yes" xml:space="preserve">
          <source>The character &quot; &amp;ndash; quotation mark</source>
          <target state="translated">文字 &quot;&amp;ndash;引用符</target>
        </trans-unit>
        <trans-unit id="10c860623b3bfd4256ce034a4fa10ecca2e8d17c" translate="yes" xml:space="preserve">
          <source>The character $ &amp;ndash; dollar sign</source>
          <target state="translated">文字$ &amp;ndash;ドル記号</target>
        </trans-unit>
        <trans-unit id="bb0b9f77aa3a2b1b235948227a9bb6e95724f73c" translate="yes" xml:space="preserve">
          <source>The character &amp;Dagger;</source>
          <target state="translated">キャラクター &amp;Dagger;</target>
        </trans-unit>
        <trans-unit id="97d065e0957f914068e24066c8bc53313cb9196a" translate="yes" xml:space="preserve">
          <source>The character &amp;Prime;</source>
          <target state="translated">キャラクター &quot;</target>
        </trans-unit>
        <trans-unit id="697b0963155a10d5f080f157c0e1d9c9aacc9b21" translate="yes" xml:space="preserve">
          <source>The character &amp;amp; &amp;ndash; ampersand</source>
          <target state="translated">文字＆&amp;ndash;アンパサンド</target>
        </trans-unit>
        <trans-unit id="094872d2798a25e27adaff380803676c236be373" translate="yes" xml:space="preserve">
          <source>The character &amp;asymp;</source>
          <target state="translated">キャラクター&amp;asymp;</target>
        </trans-unit>
        <trans-unit id="41d60c0526caa8463741bd966759bf19026cb739" translate="yes" xml:space="preserve">
          <source>The character &amp;bdquo;</source>
          <target state="translated">キャラクター &quot;</target>
        </trans-unit>
        <trans-unit id="fff1f1e9d607e97e90b4bc028bb0cc7f10c48e01" translate="yes" xml:space="preserve">
          <source>The character &amp;bull;</source>
          <target state="translated">キャラクター &amp;bull;</target>
        </trans-unit>
        <trans-unit id="143c3fcec665ebddc83c2753db67d88e2fbaf38a" translate="yes" xml:space="preserve">
          <source>The character &amp;cent;</source>
          <target state="translated">キャラクター&amp;cent;</target>
        </trans-unit>
        <trans-unit id="ee171eaf967121aa215c85e62d2ec509ebb04257" translate="yes" xml:space="preserve">
          <source>The character &amp;copy;</source>
          <target state="translated">キャラクター&amp;copy;</target>
        </trans-unit>
        <trans-unit id="314c38bf0716b200771c1a885fab69a9b65b99c6" translate="yes" xml:space="preserve">
          <source>The character &amp;dagger;</source>
          <target state="translated">キャラクター &amp;dagger;</target>
        </trans-unit>
        <trans-unit id="6f9bd3084db43833f63880cca5d946309a97ca39" translate="yes" xml:space="preserve">
          <source>The character &amp;deg;</source>
          <target state="translated">文字&amp;deg;</target>
        </trans-unit>
        <trans-unit id="0e423b28ce34d3cf18fda3a07cf0dfa515d8890e" translate="yes" xml:space="preserve">
          <source>The character &amp;euro;</source>
          <target state="translated">キャラクター&amp;euro;</target>
        </trans-unit>
        <trans-unit id="b1449855c21d4fd06c0d5e74b5a2a7a14edf968a" translate="yes" xml:space="preserve">
          <source>The character &amp;frac12;</source>
          <target state="translated">キャラクター&amp;frac12;</target>
        </trans-unit>
        <trans-unit id="1fa4a09afc8d4c4f53c306db471f300c4497957c" translate="yes" xml:space="preserve">
          <source>The character &amp;ge;</source>
          <target state="translated">文字&amp;ge;</target>
        </trans-unit>
        <trans-unit id="3dfbeeaef1c98d8a22709ebef333428072939a42" translate="yes" xml:space="preserve">
          <source>The character &amp;gt; &amp;ndash; greater-than sign</source>
          <target state="translated">文字&amp;gt; &amp;ndash;大なり記号</target>
        </trans-unit>
        <trans-unit id="6eb5e1e14a002081da7d716b380be22cde00b939" translate="yes" xml:space="preserve">
          <source>The character &amp;hellip;</source>
          <target state="translated">キャラクター &amp;hellip;</target>
        </trans-unit>
        <trans-unit id="a01873a887462b6593c2f5f42a550b38052e578a" translate="yes" xml:space="preserve">
          <source>The character &amp;laquo;</source>
          <target state="translated">キャラクター &quot;</target>
        </trans-unit>
        <trans-unit id="e667dca130564a78a41110f6cbd1264a713d8dd2" translate="yes" xml:space="preserve">
          <source>The character &amp;ldquo;</source>
          <target state="translated">キャラクター &quot;</target>
        </trans-unit>
        <trans-unit id="950de0de2afce4fa96ad4f62ca4dab286d3d82a8" translate="yes" xml:space="preserve">
          <source>The character &amp;le;</source>
          <target state="translated">文字&amp;le;</target>
        </trans-unit>
        <trans-unit id="9023ce61724bbabe84554211f1682a5b7d26a59b" translate="yes" xml:space="preserve">
          <source>The character &amp;lsquo;</source>
          <target state="translated">キャラクター '</target>
        </trans-unit>
        <trans-unit id="e9f2776cd83195ab61d81c705eb53d1d3649fd0e" translate="yes" xml:space="preserve">
          <source>The character &amp;lt; &amp;ndash; less-than sign</source>
          <target state="translated">文字&amp;lt;&amp;ndash;小なり記号</target>
        </trans-unit>
        <trans-unit id="7e613a75a280526a06a5c3a8cccd7722979dfc79" translate="yes" xml:space="preserve">
          <source>The character &amp;mdash;</source>
          <target state="translated">キャラクター -</target>
        </trans-unit>
        <trans-unit id="257dd2718c3d554488c288a2e9f88456100a73ef" translate="yes" xml:space="preserve">
          <source>The character &amp;middot;</source>
          <target state="translated">キャラクター ・</target>
        </trans-unit>
        <trans-unit id="b00154ce5f2758f6abb5e4356e419ba3e2aed105" translate="yes" xml:space="preserve">
          <source>The character &amp;ndash;</source>
          <target state="translated">キャラクター -</target>
        </trans-unit>
        <trans-unit id="aad571a2b53620d99840a4d55bce3f5907371d75" translate="yes" xml:space="preserve">
          <source>The character &amp;ne;</source>
          <target state="translated">キャラクター&amp;ne;</target>
        </trans-unit>
        <trans-unit id="a360453c2e244288bd242eeb7641ad601e593f75" translate="yes" xml:space="preserve">
          <source>The character &amp;para;</source>
          <target state="translated">キャラクター &amp;para;</target>
        </trans-unit>
        <trans-unit id="1c97c4311adda721fa170a84ab8496cb5535afa3" translate="yes" xml:space="preserve">
          <source>The character &amp;plusmn;</source>
          <target state="translated">文字&amp;plusmn;</target>
        </trans-unit>
        <trans-unit id="55144636deb97ada56b2d29a7bb655a9f22ea932" translate="yes" xml:space="preserve">
          <source>The character &amp;pound;</source>
          <target state="translated">キャラクター&amp;pound;</target>
        </trans-unit>
        <trans-unit id="09c581b6f45120a7ecac89f6de96696cea52b01c" translate="yes" xml:space="preserve">
          <source>The character &amp;prime;</source>
          <target state="translated">キャラクター '</target>
        </trans-unit>
        <trans-unit id="c49eacef46814486b9678b461b5fad7053d65453" translate="yes" xml:space="preserve">
          <source>The character &amp;raquo;</source>
          <target state="translated">キャラクター &quot;</target>
        </trans-unit>
        <trans-unit id="b94a5614ad8379d659840f63e74a095d51d6a7c0" translate="yes" xml:space="preserve">
          <source>The character &amp;rdquo;</source>
          <target state="translated">キャラクター &quot;</target>
        </trans-unit>
        <trans-unit id="be87e8e3080722678155d4e087ea1bf466788605" translate="yes" xml:space="preserve">
          <source>The character &amp;reg;</source>
          <target state="translated">キャラクター&amp;reg;</target>
        </trans-unit>
        <trans-unit id="e6daa833ce04c765a61d1650a1e4e3d75924ca44" translate="yes" xml:space="preserve">
          <source>The character &amp;rsquo;</source>
          <target state="translated">キャラクター '</target>
        </trans-unit>
        <trans-unit id="43ad6d82b90d71d375e73e1b9402ca5934e45166" translate="yes" xml:space="preserve">
          <source>The character &amp;sbquo;</source>
          <target state="translated">キャラクター 、</target>
        </trans-unit>
        <trans-unit id="4139cb770ca9a15c26a42368989f1dc39e1910da" translate="yes" xml:space="preserve">
          <source>The character &amp;sect;</source>
          <target state="translated">キャラクター &amp;sect;</target>
        </trans-unit>
        <trans-unit id="98e7fc24f032b2c1437d0f55811d67ee1de7b88e" translate="yes" xml:space="preserve">
          <source>The character &amp;times;</source>
          <target state="translated">キャラクター&amp;times;</target>
        </trans-unit>
        <trans-unit id="f6467d07a9719c1073ddb29614f3d2a5ac72dfb3" translate="yes" xml:space="preserve">
          <source>The character &amp;trade;</source>
          <target state="translated">キャラクター&amp;trade;</target>
        </trans-unit>
        <trans-unit id="1789ee1227acc918fbc63737b2058bf75be81287" translate="yes" xml:space="preserve">
          <source>The class can also declare &lt;strong&gt;secondary constructors&lt;/strong&gt;, which are prefixed with &lt;em&gt;constructor&lt;/em&gt;:</source>
          <target state="translated">このクラスは、&lt;em&gt;コンストラクタ&lt;/em&gt;が前に付けられた&lt;strong&gt;2次コンストラクタ&lt;/strong&gt;も宣言できます。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bc78b13ff48b9fc50475495610ff41f558bf6256" translate="yes" xml:space="preserve">
          <source>The class declaration consists of the class name, the class header (specifying its type parameters, the primary constructor etc.) and the class body, surrounded by curly braces. Both the header and the body are optional; if the class has no body, curly braces can be omitted.</source>
          <target state="translated">クラス宣言は、クラス名、クラス・ヘッダ (型パラメータ、プライマリ・コンストラクタなどを指定します)、および中括弧で囲まれたクラス・ボディから構成されます。ヘッダとボディはどちらもオプションで、ボディを持たないクラスの場合は中括弧を省略できます。</target>
        </trans-unit>
        <trans-unit id="20fb66c6dd38ed7ad8f3ab7df8f07a3ccc7c3a1d" translate="yes" xml:space="preserve">
          <source>The class file with a kind not listed here is treated as a non-Kotlin file.</source>
          <target state="translated">ここに記載されていない種類のクラスファイルは、非Kotlinファイルとして扱われます。</target>
        </trans-unit>
        <trans-unit id="8d923d6e9fe47217a8cbe28cd4bc0054618db9f2" translate="yes" xml:space="preserve">
          <source>The code above uses a &lt;a href=&quot;reflection#bound-class-references-since-11&quot;&gt;bound class reference&lt;/a&gt;, which is supported since Kotlin 1.1. You can also use the &lt;code&gt;javaClass&lt;/code&gt; extension property:</source>
          <target state="translated">上記のコードは、Kotlin 1.1以降でサポート&lt;a href=&quot;reflection#bound-class-references-since-11&quot;&gt;され&lt;/a&gt;ているバインドクラス参照を使用しています。 &lt;code&gt;javaClass&lt;/code&gt; 拡張プロパティを使用することもできます。</target>
        </trans-unit>
        <trans-unit id="732a1f0dd7bc7add2cc125d4681e9dd3eef05206" translate="yes" xml:space="preserve">
          <source>The code in object expressions can access variables from the enclosing scope.</source>
          <target state="translated">オブジェクト式のコードは、囲んだスコープから変数にアクセスすることができます。</target>
        </trans-unit>
        <trans-unit id="2a037143482eba48d7a06126430f1e3e039ee172" translate="yes" xml:space="preserve">
          <source>The code in question is from the &lt;a href=&quot;https://curl.haxx.se/libcurl/c/simple.html&quot;&gt;simple&lt;/a&gt; example (comments removed for brevity)</source>
          <target state="translated">問題のコードは&lt;a href=&quot;https://curl.haxx.se/libcurl/c/simple.html&quot;&gt;単純な&lt;/a&gt;例からのものです（簡潔にするためにコメントは削除されています）</target>
        </trans-unit>
        <trans-unit id="02b7f3091db5cc1f6df8785c890e5a0df1e43276" translate="yes" xml:space="preserve">
          <source>The code in the &lt;code&gt;hello.kt&lt;/code&gt; file may look like this:</source>
          <target state="translated">&lt;code&gt;hello.kt&lt;/code&gt; ファイルのコードは次のようになります。</target>
        </trans-unit>
        <trans-unit id="8051836ca1f9bfcf8f55044dce46370d2274f4e3" translate="yes" xml:space="preserve">
          <source>The code in the final &lt;code&gt;hello.kt&lt;/code&gt; file may look like this:</source>
          <target state="translated">最終的な &lt;code&gt;hello.kt&lt;/code&gt; ファイルのコードは次のようになります。</target>
        </trans-unit>
        <trans-unit id="53a9cf6b4f40ef47e2031c236bc499f1385bb27e" translate="yes" xml:space="preserve">
          <source>The code is full of Objective-C attributes, which are intended to help the use of the framework from both Objective-C and Swift languages. &lt;code&gt;DemoClazz&lt;/code&gt;, &lt;code&gt;DemoInterface&lt;/code&gt;, and &lt;code&gt;DemoObject&lt;/code&gt; are created for &lt;code&gt;Clazz&lt;/code&gt;, &lt;code&gt;Interface&lt;/code&gt;, and &lt;code&gt;Object&lt;/code&gt; respectively. The &lt;code&gt;Interface&lt;/code&gt; is turned into &lt;code&gt;@protocol&lt;/code&gt;, both a &lt;code&gt;class&lt;/code&gt; and an &lt;code&gt;object&lt;/code&gt; are represented as &lt;code&gt;@interface&lt;/code&gt;. The &lt;code&gt;Demo&lt;/code&gt; prefix comes from the &lt;code&gt;-output&lt;/code&gt; parameter of the &lt;code&gt;kotlinc-native&lt;/code&gt; compiler and the framework name. We see here that the nullable return type &lt;code&gt;ULong?&lt;/code&gt; is turned into &lt;code&gt;DemoLong*&lt;/code&gt; in Objective-C.</source>
          <target state="translated">コードはObjective-C属性で一杯です。これは、Objective-C言語とSwift言語の両方からのフレームワークの使用を支援することを目的としています。 &lt;code&gt;DemoClazz&lt;/code&gt; 、 &lt;code&gt;DemoInterface&lt;/code&gt; 、そして &lt;code&gt;DemoObject&lt;/code&gt; がために作成され &lt;code&gt;Clazz&lt;/code&gt; 、 &lt;code&gt;Interface&lt;/code&gt; 、および &lt;code&gt;Object&lt;/code&gt; それぞれ。 &lt;code&gt;Interface&lt;/code&gt; になっている &lt;code&gt;@protocol&lt;/code&gt; 両方、 &lt;code&gt;class&lt;/code&gt; および &lt;code&gt;object&lt;/code&gt; として表され &lt;code&gt;@interface&lt;/code&gt; 。 &lt;code&gt;Demo&lt;/code&gt; プレフィックスはから来て &lt;code&gt;-output&lt;/code&gt; のパラメータ &lt;code&gt;kotlinc-native&lt;/code&gt; コンパイラとフレームワーク名。ここでは、null許容の戻り型が &lt;code&gt;ULong?&lt;/code&gt; Objective-C &lt;code&gt;DemoLong*&lt;/code&gt; に変換されます。</target>
        </trans-unit>
        <trans-unit id="bb3f232ccbe55c8a64749007e2a52df82753b753" translate="yes" xml:space="preserve">
          <source>The code is still written as if we were writing synchronous code, top-down, without the need of any special syntax, beyond the use of a function called &lt;code&gt;launch&lt;/code&gt; which essentially kicks-off the coroutine (covered in other tutorials).</source>
          <target state="translated">コードは依然として、トップダウンで同期コードを記述しているかのように、本質的にコルーチン（他のチュートリアルで説明）を &lt;code&gt;launch&lt;/code&gt; と呼ばれる関数の使用を超えて、特別な構文を必要とせずに記述されます。</target>
        </trans-unit>
        <trans-unit id="a467b8b9b7ee4d493e257af4cbf437bbbbde6f1c" translate="yes" xml:space="preserve">
          <source>The code or data pointed by the value of this variable.</source>
          <target state="translated">この変数の値が指すコードまたはデータ。</target>
        </trans-unit>
        <trans-unit id="02020b547b7971154705decbe3b4487f3a320a20" translate="yes" xml:space="preserve">
          <source>The code reads as follows. We have the &lt;code&gt;libnative_ExportedSymbols&lt;/code&gt; structure, which defines all the functions that Kotlin/Native and our library provides us. It uses nested anonymous structures heavily to mimic packages. The &lt;code&gt;libnative_&lt;/code&gt; prefix comes from the library name.</source>
          <target state="translated">コードは次のようになります。我々は持っている &lt;code&gt;libnative_ExportedSymbols&lt;/code&gt; の Kotlin /ネイティブと私たちの図書館が私たちを提供するすべての機能を定義する構造体を、。ネストされた匿名構造を多用してパッケージを模倣します。 &lt;code&gt;libnative_&lt;/code&gt; プレフィックスは、ライブラリの名前から来ています。</target>
        </trans-unit>
        <trans-unit id="38d106af82f35f678ad2690b0baa41429ea7b73f" translate="yes" xml:space="preserve">
          <source>The code uses anonymous structure declarations. The code &lt;code&gt;struct { .. } foo&lt;/code&gt; declares a field in the outer struct of that anonymous structure type, the type with no name.</source>
          <target state="translated">コードは匿名の構造宣言を使用します。コード &lt;code&gt;struct { .. } foo&lt;/code&gt; は、名前のない型の匿名構造型の外部構造体のフィールドを宣言します。</target>
        </trans-unit>
        <trans-unit id="5a75d5c9d164b0af6fa981261ed056bb33166b99" translate="yes" xml:space="preserve">
          <source>The collection interfaces and related functions are located in the kotlin.collections package. Let's get an overview of its contents.</source>
          <target state="translated">コレクションのインターフェイスと関連する関数は、kotlin.collections パッケージにあります。その内容の概要を見てみましょう。</target>
        </trans-unit>
        <trans-unit id="8eb00e1a99072f02da7c9734f0160d0f6d88090d" translate="yes" xml:space="preserve">
          <source>The command produces the &lt;code&gt;main.exe&lt;/code&gt; file, which we can run.</source>
          <target state="translated">このコマンドにより、実行可能な &lt;code&gt;main.exe&lt;/code&gt; ファイルが生成されます。</target>
        </trans-unit>
        <trans-unit id="c3c76c63d39731dfbcdc20b108a998ffa2cab356" translate="yes" xml:space="preserve">
          <source>The common base class of all enum classes. See the &lt;a href=&quot;../../../../../../docs/reference/enum-classes&quot;&gt;Kotlin language documentation&lt;/a&gt; for more information on enum classes.</source>
          <target state="translated">すべての列挙型クラスの共通基本クラス。列挙型クラスの詳細については、&lt;a href=&quot;../../../../../../docs/reference/enum-classes&quot;&gt;Kotlin言語のドキュメント&lt;/a&gt;をご覧ください。</target>
        </trans-unit>
        <trans-unit id="b0aedfb3fef921fc9d29c01593b4d03896cda204" translate="yes" xml:space="preserve">
          <source>The common base class of all enum classes. See the &lt;a href=&quot;../../../../../docs/reference/enum-classes&quot;&gt;Kotlin language documentation&lt;/a&gt; for more information on enum classes.</source>
          <target state="translated">すべての列挙型クラスの共通基本クラス。列挙型クラスの詳細については、&lt;a href=&quot;../../../../../docs/reference/enum-classes&quot;&gt;Kotlin言語のドキュメント&lt;/a&gt;をご覧ください。</target>
        </trans-unit>
        <trans-unit id="81167d80c8bd1494ae8b5c6e43cfe5f3d98e0f63" translate="yes" xml:space="preserve">
          <source>The common code is &lt;code&gt;&quot;Kotlin Rocks on ${platformName()}&quot;&lt;/code&gt;, where &lt;code&gt;platformName()&lt;/code&gt; is a function that is declared using the &lt;code&gt;expect&lt;/code&gt; keyword. The &lt;code&gt;actual&lt;/code&gt; implementation will be specific to the platform.</source>
          <target state="translated">一般的なコードは &lt;code&gt;&quot;Kotlin Rocks on ${platformName()}&quot;&lt;/code&gt; 。ここで、 &lt;code&gt;platformName()&lt;/code&gt; は &lt;code&gt;expect&lt;/code&gt; キーワードを使用して宣言された関数です。 &lt;code&gt;actual&lt;/code&gt; 実装はプラットフォームに固有になります。</target>
        </trans-unit>
        <trans-unit id="26e2504fa6bfc493ea02066bb2b03d45d4bc4811" translate="yes" xml:space="preserve">
          <source>The common source sets cannot include Java sources.</source>
          <target state="translated">共通のソース・セットには、Javaソースを含めることはできません。</target>
        </trans-unit>
        <trans-unit id="95ec79a350a2b7276da32a4ea5b29db260f72d85" translate="yes" xml:space="preserve">
          <source>The common supertype for all callable references is &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.reflect/-k-callable/index&quot;&gt;&lt;code&gt;KCallable&amp;lt;out R&amp;gt;&lt;/code&gt;&lt;/a&gt;, where &lt;code&gt;R&lt;/code&gt; is the return value type, which is the property type for properties, and the constructed type for constructors.</source>
          <target state="translated">すべての呼び出し可能な参照に共通のスーパータイプは&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.reflect/-k-callable/index&quot;&gt; &lt;code&gt;KCallable&amp;lt;out R&amp;gt;&lt;/code&gt; &lt;/a&gt;。ここで、 &lt;code&gt;R&lt;/code&gt; はプロパティのプロパティタイプである戻り値のタイプであり、コンストラクターの構築タイプです。</target>
        </trans-unit>
        <trans-unit id="b490df5b9d3260a0f0b5037a5c6848fe5e1088c0" translate="yes" xml:space="preserve">
          <source>The companion object &lt;a href=&quot;-default/index&quot;&gt;Random.Default&lt;/a&gt; is the default instance of &lt;a href=&quot;index&quot;&gt;Random&lt;/a&gt;.</source>
          <target state="translated">コンパニオンオブジェクト&lt;a href=&quot;-default/index&quot;&gt;Random.Default&lt;/a&gt;は&lt;a href=&quot;index&quot;&gt;Random&lt;/a&gt;のデフォルトのインスタンスです。</target>
        </trans-unit>
        <trans-unit id="d53a914136005ae6f435321f1dcd61b723a192c1" translate="yes" xml:space="preserve">
          <source>The companion object is a singleton, and its members can be accessed directly via the name of the containing class (although you can also insert the name of the companion object if you want to be explicit about accessing the companion object):</source>
          <target state="translated">コンパニオンオブジェクトはシングルトンであり、そのメンバには含まれるクラスの名前を使って直接アクセスすることができます (コンパニオンオブジェクトへのアクセスを明示したい場合はコンパニオンオブジェクトの名前を挿入することもできますが)。</target>
        </trans-unit>
        <trans-unit id="1e2216eb9ae725f1d6c56e917607f0c9488b74a1" translate="yes" xml:space="preserve">
          <source>The compiler automatically derives the following members from all properties declared in the primary constructor:</source>
          <target state="translated">コンパイラは、プライマリ・コンストラクタで宣言されたすべてのプロパティから以下のメンバを自動的に導出します。</target>
        </trans-unit>
        <trans-unit id="6577ea37c1117c7a1d89eaf0755007d75c98ca87" translate="yes" xml:space="preserve">
          <source>The compiler can infer the function types for variables if there is enough information:</source>
          <target state="translated">コンパイラは十分な情報があれば、変数の関数型を推論することができます。</target>
        </trans-unit>
        <trans-unit id="6c9d4888e9777e469bf8f8415875e00d70265bbb" translate="yes" xml:space="preserve">
          <source>The compiler ensures that every expected declaration has actual declarations in all platform modules that implement the corresponding common module, and reports an error if any actual declarations are missing. The IDE provides tools that help you create the missing actual declarations.</source>
          <target state="translated">コンパイラは、すべての期待される宣言が、対応する共通モジュールを実装するすべてのプラットフォーム モジュールで実際の宣言を持つことを保証し、実際の宣言がない場合はエラーを報告します。IDE には、不足している実際の宣言を作成するのに役立つツールが用意されています。</target>
        </trans-unit>
        <trans-unit id="1bc9fa0ea96f6adbeae3b32244221538e36f7db6" translate="yes" xml:space="preserve">
          <source>The compiler generates an executable called &lt;code&gt;a.out&lt;/code&gt;. We need to run it to see in action the Kotlin code being executed from C library. On Linux, we'll need to include &lt;code&gt;.&lt;/code&gt; into the &lt;code&gt;LD_LIBRARY_PATH&lt;/code&gt; to let the application know to load the &lt;code&gt;libnative.so&lt;/code&gt; library from the current folder.</source>
          <target state="translated">コンパイラーは &lt;code&gt;a.out&lt;/code&gt; と呼ばれる実行可能ファイルを生成します。実際に実行して、Cライブラリから実行されているKotlinコードを確認する必要があります。Linuxでは、を含める必要があります &lt;code&gt;.&lt;/code&gt; &lt;code&gt;LD_LIBRARY_PATH&lt;/code&gt; ロードするためにアプリケーションが知っているようにする &lt;code&gt;libnative.so&lt;/code&gt; 現在のフォルダからライブラリを。</target>
        </trans-unit>
        <trans-unit id="9c32f1ebf038bdf8cbaba8702b89e98ca18e811a" translate="yes" xml:space="preserve">
          <source>The compiler is smart enough to know a cast to be safe if a negative check leads to a return:</source>
          <target state="translated">コンパイラは、ネガティブチェックがリターンにつながる場合に安全なキャストを知っているほど賢いです。</target>
        </trans-unit>
        <trans-unit id="6c760f17f753a0cd7195aa08e67eb2dc50e9752a" translate="yes" xml:space="preserve">
          <source>The compiler now inlines values of &lt;code&gt;const val&lt;/code&gt; properties into the locations where they are used.</source>
          <target state="translated">コンパイラーは &lt;code&gt;const val&lt;/code&gt; プロパティーの値を、それらが使用される場所にインライン化するようになりました。</target>
        </trans-unit>
        <trans-unit id="4ba2b709c858d08263f181dafb3aabf655fd192d" translate="yes" xml:space="preserve">
          <source>The compiler now provides an option to treat all warnings as errors. Use &lt;code&gt;-Werror&lt;/code&gt; on the command line, or the following Gradle snippet:</source>
          <target state="translated">コンパイラーは、すべての警告をエラーとして扱うオプションを提供するようになりました。コマンドラインで &lt;code&gt;-Werror&lt;/code&gt; を使用するか、次のGradleスニペットを使用します。</target>
        </trans-unit>
        <trans-unit id="71411ab1eb04e1e2a8b1556ddf262cc1922d7424" translate="yes" xml:space="preserve">
          <source>The compiler performs the following steps for resolution of an operator in the &lt;em&gt;postfix&lt;/em&gt; form, e.g. &lt;code&gt;a++&lt;/code&gt;:</source>
          <target state="translated">コンパイラーは、&lt;em&gt;後置形&lt;/em&gt;式のオペレーター（例えば &lt;code&gt;a++&lt;/code&gt; 解決のために、以下のステップを実行します。</target>
        </trans-unit>
        <trans-unit id="ade270e63280116ba329a9222cd68e987a0137a2" translate="yes" xml:space="preserve">
          <source>The compiler produces a warning for the cast in the last line. The cast cannot be fully checked at runtime and provides no guarantee that the values in the map are &lt;code&gt;Int&lt;/code&gt;.</source>
          <target state="translated">コンパイラーは、キャストの最終行に警告を生成します。キャストは実行時に完全にチェックすることはできず、マップの値が &lt;code&gt;Int&lt;/code&gt; であるという保証はありません。</target>
        </trans-unit>
        <trans-unit id="c187f47b8c07f5d91c0556c45f360de519c42c3f" translate="yes" xml:space="preserve">
          <source>The compiler produces the code relevant for the target module system, for example, in case of CommonJS, it will import the declaration via the &lt;code&gt;require(...)&lt;/code&gt; function.</source>
          <target state="translated">コンパイラは、ターゲットモジュールシステムに関連するコードを生成します。たとえば、CommonJSの場合、 &lt;code&gt;require(...)&lt;/code&gt; 関数を介して宣言をインポートします。</target>
        </trans-unit>
        <trans-unit id="8552578d258f1326cbba27a9248961d718afcda8" translate="yes" xml:space="preserve">
          <source>The compiler tracks the information about the check you performed, and allows the call to &lt;code&gt;length&lt;/code&gt; inside the &lt;em&gt;if&lt;/em&gt;. More complex conditions are supported as well:</source>
          <target state="translated">コンパイラーは実行したチェックに関する情報を追跡し、&lt;em&gt;if&lt;/em&gt;内で &lt;code&gt;length&lt;/code&gt; への呼び出しを許可します。より複雑な条件もサポートされています。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9778744271ecf22c5df54071242110d274ebb382" translate="yes" xml:space="preserve">
          <source>The compiler will allow this function to be called as e.g. &lt;code&gt;test(&quot;a&quot;, &quot;b&quot;)&lt;/code&gt; or &lt;code&gt;test(&quot;a&quot;, null)&lt;/code&gt;, but not as &lt;code&gt;test(null, &quot;b&quot;)&lt;/code&gt; or &lt;code&gt;test(null, null)&lt;/code&gt;. Calling &lt;code&gt;test(a, b)&lt;/code&gt; is only allowed if the compiler can prove that &lt;code&gt;a&lt;/code&gt; cannot possibly be null. Inside of &lt;code&gt;test&lt;/code&gt;, the compiler will not allow you to do anything with &lt;code&gt;b&lt;/code&gt; that would result in an exception if &lt;code&gt;b&lt;/code&gt; should happen to be null - so you can do &lt;code&gt;a.length&lt;/code&gt;, but not &lt;code&gt;b.length&lt;/code&gt;. However, once you're inside a conditional where you have checked that &lt;code&gt;b&lt;/code&gt; is not null, you can do it:</source>
          <target state="translated">コンパイラーは、この関数を &lt;code&gt;test(&quot;a&quot;, &quot;b&quot;)&lt;/code&gt; または &lt;code&gt;test(&quot;a&quot;, null)&lt;/code&gt; として呼び出すことを許可し &lt;code&gt;test(null, &quot;b&quot;)&lt;/code&gt; または &lt;code&gt;test(null, null)&lt;/code&gt; としては許可しません。 &lt;code&gt;test(a, b)&lt;/code&gt; 呼び出しは、コンパイラが &lt;code&gt;a&lt;/code&gt; をnullにできないことを証明できる場合にのみ許可されます。内部の &lt;code&gt;test&lt;/code&gt; 、コンパイラはあなたと何も行うことができません &lt;code&gt;b&lt;/code&gt; 場合は例外につながる &lt;code&gt;b&lt;/code&gt; はあなたが行うことができるように- nullであることが起こるはずです &lt;code&gt;a.length&lt;/code&gt; を、ではなく &lt;code&gt;b.length&lt;/code&gt; 。ただし、 &lt;code&gt;b&lt;/code&gt; がnullでないことを確認した条件内に​​入ると、次のように実行できます。</target>
        </trans-unit>
        <trans-unit id="d2b29d9a02116dffd597657f45323e8d260b605c" translate="yes" xml:space="preserve">
          <source>The compiler will generate something like this (except that &lt;code&gt;start&lt;/code&gt; won't collide with any other identifiers with the same name):</source>
          <target state="translated">コンパイラーは次のようなものを生成します（ただし、 &lt;code&gt;start&lt;/code&gt; が同じ名前の他の識別子と衝突しない場合を除きます）。</target>
        </trans-unit>
        <trans-unit id="93c0badc9698bd83e21fa61741e490ba8801596d" translate="yes" xml:space="preserve">
          <source>The compiler will not let you perform checks that can't possibly succeed because the declared type of the variable is a class that is on an unrelated branch of the class hierarchy from the class you're checking against - if the declared type of &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;MotorVehicle&lt;/code&gt;, you can't check if &lt;code&gt;x&lt;/code&gt; is a &lt;code&gt;Person&lt;/code&gt;. If the right-hand side of &lt;code&gt;is&lt;/code&gt; is an interface, Kotlin will allow the type of the left-hand side to be any interface or open class, because it could be that some subclass thereof implements the interface.</source>
          <target state="translated">変数の宣言された型が、チェック対象のクラスからのクラス階層の無関係なブランチにあるクラスであるため、コンパイラーは成功しない可能性のあるチェックを実行できません-宣言された &lt;code&gt;x&lt;/code&gt; の型が &lt;code&gt;MotorVehicle&lt;/code&gt; の場合、 &lt;code&gt;x&lt;/code&gt; が &lt;code&gt;Person&lt;/code&gt; であるかどうかは確認できません。右側場合 &lt;code&gt;is&lt;/code&gt; インターフェースである、それはいくつかのサブクラスがそのインターフェースを実装することである可能性があるため、Kotlinは、左側のタイプは、任意のインタフェースまたはオープンクラスであることを可能にします。</target>
        </trans-unit>
        <trans-unit id="945c10a176528faf419fb001b8765fc6d7f48809" translate="yes" xml:space="preserve">
          <source>The complete list of options for the Gradle tasks is the following:</source>
          <target state="translated">Gradleタスクのオプションの完全なリストは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="cbc4e4912fffd8b8c15a7f1685ee311f7de94af5" translate="yes" xml:space="preserve">
          <source>The consumer may only need to add the attribute to a single target where the ambiguity arises.</source>
          <target state="translated">消費者は、曖昧さが生じている単一のターゲットに属性を追加するだけで済むかもしれません。</target>
        </trans-unit>
        <trans-unit id="2fa143f534ac2f4a54ee1e8593acf92219a64686" translate="yes" xml:space="preserve">
          <source>The contents of our &lt;code&gt;main.js&lt;/code&gt; would be:</source>
          <target state="translated">&lt;code&gt;main.js&lt;/code&gt; の内容は次のようになります。</target>
        </trans-unit>
        <trans-unit id="ccc1b0f9d51d769d3aac8a2e95f9b22ce641f370" translate="yes" xml:space="preserve">
          <source>The context of the coroutine that corresponds to this continuation.</source>
          <target state="translated">この続きに対応するコルーチンのコンテキスト。</target>
        </trans-unit>
        <trans-unit id="347bd2f03e4af765cba7e04d72d0cecc9c6bb8cc" translate="yes" xml:space="preserve">
          <source>The contract description must be at the beginning of a function and have at least one effect.</source>
          <target state="translated">契約書の記載は、機能の先頭にあり、少なくとも1つの効果があることが必要です。</target>
        </trans-unit>
        <trans-unit id="4954ad3fce80d9310d9ce43541aaf17e0123a4ea" translate="yes" xml:space="preserve">
          <source>The contravariant type parameter of a parameter of a function-typed return type (the user will call the returned function with something that can consume any &lt;code&gt;Fruit&lt;/code&gt;, so it's okay to return a function that expects to receive something that can handle &lt;code&gt;Apple&lt;/code&gt;)</source>
          <target state="translated">関数型の戻り値型のパラメーターの反変型パラメーター（ユーザーは、戻り値の関数を、任意の &lt;code&gt;Fruit&lt;/code&gt; を消費できるもので呼び出すため、 &lt;code&gt;Apple&lt;/code&gt; を処理できるものを受け取ることを期待する関数を返しても問題ありません）</target>
        </trans-unit>
        <trans-unit id="fc9281a07f7c7bacfae7f8c712a66286fa4aa11c" translate="yes" xml:space="preserve">
          <source>The contravariant type parameter of a parameter type (the user is passing a consumer that can handle any &lt;code&gt;Fruit&lt;/code&gt;, and it will be given an &lt;code&gt;Apple&lt;/code&gt;)</source>
          <target state="translated">パラメーター型の反変型パラメーター（ユーザーは、任意の &lt;code&gt;Fruit&lt;/code&gt; を処理できるコンシューマーを渡しており、 &lt;code&gt;Apple&lt;/code&gt; が提供されます）</target>
        </trans-unit>
        <trans-unit id="3b2df0437d1139299375d04a6b3d749596fe34b3" translate="yes" xml:space="preserve">
          <source>The contravariant type parameter of the return type of a function-typed parameter (the user is passing a function that will return a consumer of any &lt;code&gt;Fruit&lt;/code&gt;, and the returned consumer will be given &lt;code&gt;Apple&lt;/code&gt; instances)</source>
          <target state="translated">関数型パラメーターの戻り値の型の反変型パラメーター（ユーザーは任意の &lt;code&gt;Fruit&lt;/code&gt; のコンシューマーを返す関数を渡し、返されたコンシューマーには &lt;code&gt;Apple&lt;/code&gt; インスタンスが与えられます）</target>
        </trans-unit>
        <trans-unit id="3ed87fa7f81c4d406e21bd5206fb7068af42bc61" translate="yes" xml:space="preserve">
          <source>The convention that is followed is that each library gets its own definition file, usually named the same as the library. For more information on all the options available to &lt;code&gt;cinterop&lt;/code&gt;, see &lt;a href=&quot;../../reference/native/c_interop&quot;&gt;the Interop documentation&lt;/a&gt;</source>
          <target state="translated">従う規則は、各ライブラリが通常はライブラリと同じ名前の独自の定義ファイルを取得することです。 &lt;code&gt;cinterop&lt;/code&gt; で使用できるすべてのオプションの詳細について&lt;a href=&quot;../../reference/native/c_interop&quot;&gt;は、Interopのドキュメントを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="c72d89d38289079cb805c34b2308d4dfa8c2fd72" translate="yes" xml:space="preserve">
          <source>The coroutine context includes a &lt;em&gt;coroutine dispatcher&lt;/em&gt; (see &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-dispatcher/index.html&quot;&gt;CoroutineDispatcher&lt;/a&gt;) that determines what thread or threads the corresponding coroutine uses for its execution. The coroutine dispatcher can confine coroutine execution to a specific thread, dispatch it to a thread pool, or let it run unconfined.</source>
          <target state="translated">コルーチンコンテキストには、対応するコルーチンが実行に使用する1つまたは複数のスレッドを決定する&lt;em&gt;コルーチンディスパッチャー&lt;/em&gt;（&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-dispatcher/index.html&quot;&gt;CoroutineDispatcherを&lt;/a&gt;参照）が含まれます。コルーチンディスパッチャは、コルーチンの実行を特定のスレッドに制限したり、スレッドプールにディスパッチしたり、制限なしで実行したりできます。</target>
        </trans-unit>
        <trans-unit id="d4ce8b1f45a5d6806ad09e59cc85adf7dc80106f" translate="yes" xml:space="preserve">
          <source>The coroutine context is a set of various elements. The main elements are the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html&quot;&gt;Job&lt;/a&gt; of the coroutine, which we've seen before, and its dispatcher, which is covered in this section.</source>
          <target state="translated">コルーチンコンテキストは、さまざまな要素のセットです。主な要素は、以前に見たコルーチンの&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html&quot;&gt;ジョブ&lt;/a&gt;と、このセクションで説明するそのディスパッチャーです。</target>
        </trans-unit>
        <trans-unit id="09d67675b7aec2c1bf9665203e1b50714b4ffefe" translate="yes" xml:space="preserve">
          <source>The coroutine is started directly in the invoker's thread without going through the &lt;a href=&quot;../kotlin.coroutines/-continuation-interceptor/index&quot;&gt;ContinuationInterceptor&lt;/a&gt; that might be present in the completion's &lt;a href=&quot;../kotlin.coroutines/-coroutine-context/index&quot;&gt;CoroutineContext&lt;/a&gt;. It is the invoker's responsibility to ensure that a proper invocation context is established.</source>
          <target state="translated">コルーチンは、補完の&lt;a href=&quot;../kotlin.coroutines/-coroutine-context/index&quot;&gt;CoroutineContextに&lt;/a&gt;存在する可能性のある&lt;a href=&quot;../kotlin.coroutines/-continuation-interceptor/index&quot;&gt;ContinuationInterceptor&lt;/a&gt;を経由せずに、呼び出し元のスレッドで直接開始されます。適切な呼び出しコンテキストが確立されるようにするのは、呼び出し側の責任です。</target>
        </trans-unit>
        <trans-unit id="5075509aaa121a034050446e85498c3f79064890" translate="yes" xml:space="preserve">
          <source>The coroutine's &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html&quot;&gt;Job&lt;/a&gt; is part of its context, and can be retrieved from it using the &lt;code&gt;coroutineContext[Job]&lt;/code&gt; expression:</source>
          <target state="translated">コルーチンの&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html&quot;&gt;ジョブ&lt;/a&gt;はそのコンテキストの一部であり、 &lt;code&gt;coroutineContext[Job]&lt;/code&gt; 式を使用してコルーチンから取得できます。</target>
        </trans-unit>
        <trans-unit id="3db3fa62931fade33326b38aff7867fe578bfdd9" translate="yes" xml:space="preserve">
          <source>The coroutine's &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html&quot;&gt;Job&lt;/a&gt; is part of its context. The coroutine can retrieve it from its own context using &lt;code&gt;coroutineContext[Job]&lt;/code&gt; expression:</source>
          <target state="translated">コルーチンの&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html&quot;&gt;ジョブ&lt;/a&gt;は、そのコンテキストの一部です。コルーチンは、 &lt;code&gt;coroutineContext[Job]&lt;/code&gt; 式を使用して、独自のコンテキストから取得できます。</target>
        </trans-unit>
        <trans-unit id="5769f42ad3e1d523865b402b5e67bd28e7b20bad" translate="yes" xml:space="preserve">
          <source>The corresponding &lt;code&gt;sourceSets&lt;/code&gt; property should be updated if not using the default convention:</source>
          <target state="translated">デフォルトの規則を使用しない場合は、対応する &lt;code&gt;sourceSets&lt;/code&gt; プロパティを更新する必要があります。</target>
        </trans-unit>
        <trans-unit id="e1d461218111d234968b7db694b9b764401c60b6" translate="yes" xml:space="preserve">
          <source>The corresponding &lt;em&gt;sourceSets&lt;/em&gt; property should be updated if not using the default convention:</source>
          <target state="translated">デフォルトの規則を使用しない場合は、対応する&lt;em&gt;sourceSets&lt;/em&gt;プロパティを更新する必要があります。</target>
        </trans-unit>
        <trans-unit id="16c7a1a50f1d32fc204564f81e6d0304f7356ed7" translate="yes" xml:space="preserve">
          <source>The covariant type parameter of a read-only property type (the user is expecting a producer of &lt;code&gt;Fruit&lt;/code&gt;, and gets a producer of &lt;code&gt;Apple&lt;/code&gt;)</source>
          <target state="translated">読み取り専用プロパティタイプの共変タイプのパラメーター（ユーザーは &lt;code&gt;Fruit&lt;/code&gt; のプロデューサーを想定しており、 &lt;code&gt;Apple&lt;/code&gt; のプロデューサーを取得します）</target>
        </trans-unit>
        <trans-unit id="7d1a94c8808bc3894d49e0ec4259312cbb359362" translate="yes" xml:space="preserve">
          <source>The covariant type parameter of a return type (the user is expecting that the returned value will produce a &lt;code&gt;Fruit&lt;/code&gt;, so it's okay if it really produces an &lt;code&gt;Apple&lt;/code&gt;)</source>
          <target state="translated">戻り値型の共変型パラメーター（ユーザーは戻り値が &lt;code&gt;Fruit&lt;/code&gt; を生成することを期待しているため、実際に &lt;code&gt;Apple&lt;/code&gt; を生成しても問題ありません）</target>
        </trans-unit>
        <trans-unit id="ec6f1c24b0cd8b11d61e4f25576ab198b6bece55" translate="yes" xml:space="preserve">
          <source>The covariant type parameter of the parameter type of a function-typed parameter (the user is passing a function that can handle any &lt;code&gt;Fruit&lt;/code&gt; producer, and it will be given an &lt;code&gt;Apple&lt;/code&gt; producer)</source>
          <target state="translated">関数型パラメーターのパラメーター型の共変型パラメーター（ユーザーは任意の &lt;code&gt;Fruit&lt;/code&gt; プロデューサーを処理できる関数を渡しており、 &lt;code&gt;Apple&lt;/code&gt; プロデューサーが与えられます）</target>
        </trans-unit>
        <trans-unit id="bc2c5c3395341afe0bbd48554537d9a1ac25a9db" translate="yes" xml:space="preserve">
          <source>The covariant type parameter of the return type of a function-typed return type (the user expects the returned function to return something that produces &lt;code&gt;Fruit&lt;/code&gt;, so it's okay if it really produces &lt;code&gt;Apple&lt;/code&gt;)</source>
          <target state="translated">関数型の戻り値型の戻り値型の共変型パラメーター（ユーザーは、戻り値の関数が &lt;code&gt;Fruit&lt;/code&gt; を生成するものを返すことを期待しているので、本当に &lt;code&gt;Apple&lt;/code&gt; を生成しても問題ありません）</target>
        </trans-unit>
        <trans-unit id="a39f5e4ad2c9626d5a5f458b4068b5771d3c11f9" translate="yes" xml:space="preserve">
          <source>The created &lt;code&gt;StableRef&lt;/code&gt; should eventually be manually disposed using the &lt;code&gt;.dispose()&lt;/code&gt; method to prevent memory leaks:</source>
          <target state="translated">作成された &lt;code&gt;StableRef&lt;/code&gt; は、メモリリークを防ぐために、最終的に &lt;code&gt;.dispose()&lt;/code&gt; メソッドを使用して手動で破棄する必要があります。</target>
        </trans-unit>
        <trans-unit id="7dc376ddde1c64329f76a2fdf0f77fd2f42853b6" translate="yes" xml:space="preserve">
          <source>The created iOS application is ready to run on the iOS emulator or on the iOS device. The device run may require an Apple developer account and to issue a developer certificate. Xcode does its best to guide us through the process.</source>
          <target state="translated">作成されたiOSアプリケーションは、iOSエミュレータまたはiOSデバイス上で実行する準備ができています。デバイスでの実行には、Appleの開発者アカウントが必要な場合と、開発者証明書の発行が必要な場合があります。Xcodeは、このプロセスを通して私たちを導くために最善を尽くします。</target>
        </trans-unit>
        <trans-unit id="e20d095cd0f1efef77b1627ffafe7b1dfa3d28bf" translate="yes" xml:space="preserve">
          <source>The curly braces around a body can be omitted if the body is a oneliner. This is discouraged unless the body goes on the same line as the condition, because it makes it easy to make this mistake, especially when one is used to Python:</source>
          <target state="translated">ボディの周りの中括弧は、ボディがオネリの場合は省略することができます。特に Python に慣れている場合には、この間違いを犯しやすいので、ボディが条件と同じライン上にある場合を除き、これはお勧めしません。</target>
        </trans-unit>
        <trans-unit id="dcfce21884a60ba71ce3d59d9e2af53e74e2e10c" translate="yes" xml:space="preserve">
          <source>The currently released version is 1.3.41, published on July 4, 2019.</source>
          <target state="translated">現在リリースされているバージョンは1.3.41で、2019年7月4日に公開されました。</target>
        </trans-unit>
        <trans-unit id="b5744a90420458acc57f96347ae2c3cc6f2d50b3" translate="yes" xml:space="preserve">
          <source>The currently released version is 1.4.10, published on September 10, 2020.</source>
          <target state="translated">現在リリースされているバージョンは1.4.10で、2020年9月10日に公開されています。</target>
        </trans-unit>
        <trans-unit id="99a5ae4aba1310a5ec2c1c1ea8e6bbd89807b2b1" translate="yes" xml:space="preserve">
          <source>The declaration of the classifier used in this type. For example, in the type &lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt; the classifier would be the &lt;a href=&quot;../-k-class/index#kotlin.reflect.KClass&quot;&gt;KClass&lt;/a&gt; instance for &lt;a href=&quot;../../kotlin.collections/-list/index#kotlin.collections.List&quot;&gt;List&lt;/a&gt;.</source>
          <target state="translated">このタイプで使用される分類子の宣言。たとえば、タイプ &lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt; では、&lt;a href=&quot;../-k-class/index#kotlin.reflect.KClass&quot;&gt;分類子&lt;/a&gt;は&lt;a href=&quot;../../kotlin.collections/-list/index#kotlin.collections.List&quot;&gt;Listの&lt;/a&gt;KClassインスタンスになります。</target>
        </trans-unit>
        <trans-unit id="e4cb77989b70ae7af02cc584cc3eb602ad306980" translate="yes" xml:space="preserve">
          <source>The declarations in the new artifacts are visible under the same package names from the Kotlin point of view, but have different package names for Java. Therefore, switching to the new artifacts will not require any changes to your source code.</source>
          <target state="translated">新しいアーティファクトの宣言は、Kotlinの観点からは同じパッケージ名で表示されますが、Javaの場合は異なるパッケージ名になっています。したがって、新しいアーティファクトに切り替えても、ソースコードに変更を加える必要はありません。</target>
        </trans-unit>
        <trans-unit id="38a82a6bd4d8bda70773fac15ae91a2110030d1c" translate="yes" xml:space="preserve">
          <source>The default &lt;a href=&quot;https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/&quot;&gt;encoding&lt;/a&gt; is UTF-8, but you can specify it if you need something else:</source>
          <target state="translated">デフォルトの&lt;a href=&quot;https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/&quot;&gt;エンコーディング&lt;/a&gt;はUTF-8ですが、他に必要な場合は指定できます。</target>
        </trans-unit>
        <trans-unit id="7643db7f540eca7261e951018ad1bc000680e9fc" translate="yes" xml:space="preserve">
          <source>The default artifact IDs follow the pattern &lt;code&gt;&amp;lt;projectName&amp;gt;-&amp;lt;targetNameToLowerCase&amp;gt;&lt;/code&gt;, for example &lt;code&gt;sample-lib-nodejs&lt;/code&gt; for a target named &lt;code&gt;nodeJs&lt;/code&gt; in a project &lt;code&gt;sample-lib&lt;/code&gt;.</source>
          <target state="translated">デフォルトのアーティファクトIDは、パターン &lt;code&gt;&amp;lt;projectName&amp;gt;-&amp;lt;targetNameToLowerCase&amp;gt;&lt;/code&gt; に従います。たとえば、プロジェクト &lt;code&gt;sample-lib&lt;/code&gt; 内の &lt;code&gt;nodeJs&lt;/code&gt; という名前のターゲットの &lt;code&gt;sample-lib-nodejs&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="960beb3d459f57914f0b08a89c8e7a0ae2d213a2" translate="yes" xml:space="preserve">
          <source>The default dispatcher that is used when coroutines are launched in &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope&lt;/a&gt; is represented by &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-default.html&quot;&gt;Dispatchers.Default&lt;/a&gt; and uses a shared background pool of threads, so &lt;code&gt;launch(Dispatchers.Default) { ... }&lt;/code&gt; uses the same dispatcher as &lt;code&gt;GlobalScope.launch { ... }&lt;/code&gt;.</source>
          <target state="translated">コルーチンがで起動される場合に使用されるデフォルトのディスパッチャ&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScopeが&lt;/a&gt;表される&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-default.html&quot;&gt;Dispatchers.Default&lt;/a&gt;ので、スレッドの共有背景プールを使用 &lt;code&gt;launch(Dispatchers.Default) { ... }&lt;/code&gt; と同じディスパッチャを使用 &lt;code&gt;GlobalScope.launch { ... }&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b76c41789282ed3ab00f219e4dbda9192589571a" translate="yes" xml:space="preserve">
          <source>The default dispatcher, that is used when coroutines are launched in &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope&lt;/a&gt;, is represented by &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-default.html&quot;&gt;Dispatchers.Default&lt;/a&gt; and uses shared background pool of threads, so &lt;code&gt;launch(Dispatchers.Default) { ... }&lt;/code&gt; uses the same dispatcher as &lt;code&gt;GlobalScope.launch { ... }&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope&lt;/a&gt;でコルーチンが起動されるときに使用されるデフォルトのディスパッチャーは&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-default.html&quot;&gt;Dispatchers.Default&lt;/a&gt;で表され、スレッドの共有バックグラウンドプールを使用するため、 &lt;code&gt;launch(Dispatchers.Default) { ... }&lt;/code&gt; は &lt;code&gt;GlobalScope.launch { ... }&lt;/code&gt; と同じディスパッチャーを使用します。 ..}。</target>
        </trans-unit>
        <trans-unit id="034812e12bafb58c2506d45936895dac0de7b559" translate="yes" xml:space="preserve">
          <source>The default implementation is available for Java classes implementing the interface.</source>
          <target state="translated">インターフェースを実装しているJavaクラスでは、デフォルトの実装が利用可能です。</target>
        </trans-unit>
        <trans-unit id="eae7fdc4a8ba33e2f9213a2722bb2903c080bbc0" translate="yes" xml:space="preserve">
          <source>The default implementation of &lt;code&gt;Map&lt;/code&gt; &amp;ndash; &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-linked-hash-map/index&quot;&gt;&lt;code&gt;LinkedHashMap&lt;/code&gt;&lt;/a&gt; &amp;ndash; preserves the order of elements insertion when iterating the map. In turn, an alternative implementation &amp;ndash; &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-hash-map/index&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt; &amp;ndash; says nothing about the elements order.</source>
          <target state="translated">&lt;code&gt;Map&lt;/code&gt; のデフォルト実装&amp;ndash; &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-linked-hash-map/index&quot;&gt; &lt;code&gt;LinkedHashMap&lt;/code&gt; &lt;/a&gt; &amp;ndash;マップを反復するときに要素の挿入順序を保持します。次に、代替の実装&amp;ndash; &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-hash-map/index&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt; &amp;ndash;は要素の順序について何も述べていません。</target>
        </trans-unit>
        <trans-unit id="1d4f4ecafdd233f07d5e3f6afd06222be0312077" translate="yes" xml:space="preserve">
          <source>The default implementation of &lt;code&gt;Set&lt;/code&gt; &amp;ndash; &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-linked-hash-set/index&quot;&gt;&lt;code&gt;LinkedHashSet&lt;/code&gt;&lt;/a&gt; &amp;ndash; preserves the order of elements insertion. Hence, the functions that rely on the order, such as &lt;code&gt;first()&lt;/code&gt; or &lt;code&gt;last()&lt;/code&gt;, return predictable results on such sets.</source>
          <target state="translated">&lt;code&gt;Set&lt;/code&gt; &amp;ndash; &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-linked-hash-set/index&quot;&gt; &lt;code&gt;LinkedHashSet&lt;/code&gt; &lt;/a&gt; &amp;ndash; のデフォルトの実装では、要素の挿入順序が保持されます。したがって、 &lt;code&gt;first()&lt;/code&gt; や &lt;code&gt;last()&lt;/code&gt; などの順序に依存する関数は、そのようなセットに対して予測可能な結果を​​返します。</target>
        </trans-unit>
        <trans-unit id="bed0e18ec00404266f1579a08902984894034905" translate="yes" xml:space="preserve">
          <source>The default nullability is used when a type itself is not annotated by a nullability annotation, and the default is determined by the innermost enclosing element annotated with a type qualifier default annotation with the &lt;code&gt;ElementType&lt;/code&gt; matching the type usage.</source>
          <target state="translated">デフォルトのnull可能性は、タイプ自体にnull可能性アノテーションが付いていない場合に使用され、デフォルトは、タイプの使用法に一致する &lt;code&gt;ElementType&lt;/code&gt; を持つタイプ修飾子のデフォルトアノテーションが付いた最も内側の囲み要素によって決定されます。</target>
        </trans-unit>
        <trans-unit id="9d69906046e2ddf59f421f52ac090513e9b9f2a3" translate="yes" xml:space="preserve">
          <source>The default random number generator.</source>
          <target state="translated">デフォルトの乱数発生器。</target>
        </trans-unit>
        <trans-unit id="f9ef35e4ea1c850fbe5f46bb280445cc0cd754fc" translate="yes" xml:space="preserve">
          <source>The default source set &lt;code&gt;commonMain&lt;/code&gt; is added to each production (application or library) variant's compilation. The &lt;code&gt;commonTest&lt;/code&gt; source set is, similarly, added to the compilations of unit test and instrumented test variants.</source>
          <target state="translated">デフォルトのソースセット &lt;code&gt;commonMain&lt;/code&gt; は、各プロダクション（アプリケーションまたはライブラリ）バリアントのコンパイルに追加されます。 &lt;code&gt;commonTest&lt;/code&gt; ソースセットは、同様に、ユニットテストとインストルメント試験変異体のコンパイルに追加されます。</target>
        </trans-unit>
        <trans-unit id="c561b55e89597682ebf08bcc014c20773fedb83e" translate="yes" xml:space="preserve">
          <source>The default upper bound (if none specified) is &lt;code&gt;Any?&lt;/code&gt;. Only one upper bound can be specified inside the angle brackets. If the same type parameter needs more than one upper bound, we need a separate &lt;strong&gt;where&lt;/strong&gt;-clause:</source>
          <target state="translated">デフォルトの上限（指定されていない場合）は &lt;code&gt;Any?&lt;/code&gt; です。。山かっこ内で指定できる上限は1つだけです。同じ型パラメーターに複数の上限が必要な場合は、別の&lt;strong&gt;where&lt;/strong&gt; -clause が必要です。</target>
        </trans-unit>
        <trans-unit id="7b5f3fac0dd293e61c74032e957e6e608fec3b05" translate="yes" xml:space="preserve">
          <source>The default value is provided at the declaration of this parameter.</source>
          <target state="translated">デフォルト値は、このパラメータの宣言時に提供されます。</target>
        </trans-unit>
        <trans-unit id="44653ab72c57ae2dec40031a1386b4afc98b3166" translate="yes" xml:space="preserve">
          <source>The definitions part shows how Kotlin primitive types map into C primitive types. We discussed reverse mapping in the &lt;a href=&quot;mapping-primitive-data-types-from-c&quot;&gt;Mapping Primitive Data Types from C&lt;/a&gt; tutorial.</source>
          <target state="translated">定義部分は、Kotlinプリミティブ型がCプリミティブ型にどのようにマッピングされるかを示しています。&lt;a href=&quot;mapping-primitive-data-types-from-c&quot;&gt;C&lt;/a&gt;チュートリアルのプリミティブデータ型のマッピングでリバースマッピングについて説明しました。</target>
        </trans-unit>
        <trans-unit id="7879370b21d5da1f44f128551f264e026a0fb9ed" translate="yes" xml:space="preserve">
          <source>The delegate class may implement one of the interfaces &lt;code&gt;ReadOnlyProperty&lt;/code&gt; and &lt;code&gt;ReadWriteProperty&lt;/code&gt; containing the required &lt;code&gt;operator&lt;/code&gt; methods. These interfaces are declared in the Kotlin standard library:</source>
          <target state="translated">デリゲートクラスは、必要な &lt;code&gt;operator&lt;/code&gt; メソッドを含むインターフェイス &lt;code&gt;ReadOnlyProperty&lt;/code&gt; および &lt;code&gt;ReadWriteProperty&lt;/code&gt; の 1つを実装できます。これらのインターフェースはKotlin標準ライブラリで宣言されています。</target>
        </trans-unit>
        <trans-unit id="42bebb3adac2ab3e00fbad0af368d0931c57bd77" translate="yes" xml:space="preserve">
          <source>The delegated property can be used like this to declare a property in &lt;code&gt;Person&lt;/code&gt; - note the use of &lt;code&gt;by&lt;/code&gt; instead of &lt;code&gt;=&lt;/code&gt;:</source>
          <target state="translated">委任されたプロパティをこのように使用して、 &lt;code&gt;Person&lt;/code&gt; でプロパティを宣言できます。 &lt;code&gt;=&lt;/code&gt; の代わりに &lt;code&gt;by&lt;/code&gt; を使用していることに注意してください。</target>
        </trans-unit>
        <trans-unit id="898cc738a761dcd3be73120e07ea5697ac2725df" translate="yes" xml:space="preserve">
          <source>The dependencies configuration has been changed; dependencies are now specified separately for each source root.</source>
          <target state="translated">依存関係の設定が変更されました。</target>
        </trans-unit>
        <trans-unit id="973f16e5337bff9eb9481252b3daeac2f25a5f4f" translate="yes" xml:space="preserve">
          <source>The dependencies declared in this way are added in the podspec file and downloaded during the execution of &lt;code&gt;pod install&lt;/code&gt;.</source>
          <target state="translated">この方法で宣言された依存関係は、podspecファイルに追加され、 &lt;code&gt;pod install&lt;/code&gt; の実行中にダウンロードされます。</target>
        </trans-unit>
        <trans-unit id="8e289438644482986fe5eb08aaf9b0616f49cac1" translate="yes" xml:space="preserve">
          <source>The described mechanism for marking and using experimental APIs is itself experimental in Kotlin 1.3. This means that in future releases it may be changed in ways that make it incompatible. To make the users of annotations &lt;code&gt;@Experimental&lt;/code&gt; and &lt;code&gt;UseExperimental&lt;/code&gt; aware of their experimental status, the compiler raises warnings when compiling the code with these annotations:</source>
          <target state="translated">実験的なAPIをマークして使用するための説明されたメカニズム自体は、Kotlin 1.3では実験的なものです。つまり、将来のリリースでは、互換性がなくなるように変更される可能性があります。アノテーション &lt;code&gt;@Experimental&lt;/code&gt; および &lt;code&gt;UseExperimental&lt;/code&gt; のユーザーに実験的なステータスを知らせるために、コンパイラーはこれらのアノテーションを使用してコードをコンパイルするときに警告を出します。</target>
        </trans-unit>
        <trans-unit id="cf37d613f63880e424569836a2ab82c0f6bbbfbf" translate="yes" xml:space="preserve">
          <source>The design of inline classes is experimental, meaning that this feature is &lt;em&gt;moving fast&lt;/em&gt; and no compatibility guarantees are given. When using inline classes in Kotlin 1.3+, a warning will be reported, indicating that this feature is experimental.</source>
          <target state="translated">インラインクラスの設計は実験的です。つまり、この機能は&lt;em&gt;高速で動作して&lt;/em&gt;おり、互換性の保証はありません。Kotlin 1.3以降でインラインクラスを使用すると、この機能が実験的であることを示す警告が報告されます。</target>
        </trans-unit>
        <trans-unit id="530e7472ee58bdd7a4958120705547c1d20c1ddf" translate="yes" xml:space="preserve">
          <source>The design of inline classes is in &lt;a href=&quot;evolution/components-stability&quot;&gt;Alpha&lt;/a&gt;, meaning that no compatibility guarantees are given for future versions. When using inline classes in Kotlin 1.3+, a warning will be reported, indicating that this feature has not been released as stable.</source>
          <target state="translated">インラインクラスの設計は&lt;a href=&quot;evolution/components-stability&quot;&gt;アルファ&lt;/a&gt;版です。つまり、将来のバージョンでは互換性の保証はありません。Kotlin 1.3以降でインラインクラスを使用すると、この機能が安定版としてリリースされていないことを示す警告が報告されます。</target>
        </trans-unit>
        <trans-unit id="b65859994bf9d4a7fb5d934baaf88e39c3f04558" translate="yes" xml:space="preserve">
          <source>The design of unsigned types is experimental, meaning that this feature is moving fast and no compatibility guarantees are given. When using unsigned arithmetics in Kotlin 1.3+, warning will be reported, indicating that this feature is experimental. To remove warning, you have to opt-in for experimental usage of unsigned types.</source>
          <target state="translated">符号なし型の設計は実験的なものであり、この機能は高速に動いており、互換性は保証されていません。Kotlin 1.3+で符号なし演算器を使うと、この機能が実験的なものであることを示す警告が報告されます。警告を解除するには、実験的な利用を許可する必要があります。</target>
        </trans-unit>
        <trans-unit id="a2b28866ac37f05ef8569c7d67a02f97e240cc06" translate="yes" xml:space="preserve">
          <source>The design of unsigned types is in &lt;a href=&quot;evolution/components-stability&quot;&gt;Beta&lt;/a&gt;, meaning that its compatibility is best-effort only and not guaranteed. When using unsigned arithmetics in Kotlin 1.3+, a warning will be reported, indicating that this feature has not been released as stable. To remove the warning, you have to opt in for usage of unsigned types.</source>
          <target state="translated">符号なしタイプの設計は&lt;a href=&quot;evolution/components-stability&quot;&gt;ベータ版です&lt;/a&gt;。つまり、互換性はベストエフォートのみであり、保証されていません。Kotlin 1.3以降で符号なし演算を使用すると、この機能が安定版としてリリースされていないことを示す警告が報告されます。警告を削除するには、符号なしタイプの使用をオプトインする必要があります。</target>
        </trans-unit>
        <trans-unit id="a0d2b5a6b59247ce3c2ac4eba75f43c56acf4c3d" translate="yes" xml:space="preserve">
          <source>The difference between the two functions is that &lt;code&gt;fold()&lt;/code&gt; takes an initial value and uses it as the accumulated value on the first step, whereas the first step of &lt;code&gt;reduce()&lt;/code&gt; uses the first and the second elements as operation arguments on the first step.</source>
          <target state="translated">2つの関数の違いは、 &lt;code&gt;fold()&lt;/code&gt; は初期値を取り、それを最初のステップの累積値として使用するのに対し、 &lt;code&gt;reduce()&lt;/code&gt; の最初のステップは、最初のステップの操作引数として最初と2番目の要素を使用することです。</target>
        </trans-unit>
        <trans-unit id="16d1b90dc650643e776a4004ab589d677449c331" translate="yes" xml:space="preserve">
          <source>The directories containing the source files to compile</source>
          <target state="translated">コンパイルするソースファイルを含むディレクトリ</target>
        </trans-unit>
        <trans-unit id="f28bb53a04db0fb8fa17ba4aa3c143de9bce62e3" translate="yes" xml:space="preserve">
          <source>The dynamic type is not supported in code targeting the JVM</source>
          <target state="translated">動的型は、JVMをターゲットとするコードではサポートされていません。</target>
        </trans-unit>
        <trans-unit id="52d4bb2170c55ab0a1a89bfce15477357b84c2db" translate="yes" xml:space="preserve">
          <source>The dynamic type is not supported in code targeting the JVM.</source>
          <target state="translated">動的型は、JVMをターゲットとするコードではサポートされていません。</target>
        </trans-unit>
        <trans-unit id="c1e94b86df57391ab40db234f4362544f610c993" translate="yes" xml:space="preserve">
          <source>The easiest way to create a new application targeting JavaScript with Maven is to allow IntelliJ IDEA to configure the Maven project for us. Simply create a new Maven project in IntelliJ IDEA and once the project is created, add a new folder to host the Kotlin source code, removing the default Java one. The project should end up with the following structure</source>
          <target state="translated">MavenでJavaScriptをターゲットにした新しいアプリケーションを作成する最も簡単な方法は、IntelliJ IDEAでMavenプロジェクトを設定できるようにすることです。IntelliJ IDEAで新しいMavenプロジェクトを作成し、プロジェクトが作成されたら、Kotlinのソースコードをホストする新しいフォルダを追加し、デフォルトのJavaを削除します。プロジェクトは次のような構造になっているはずです。</target>
        </trans-unit>
        <trans-unit id="171e3cf4fb89f709d12d970ce788f0d3a1e1b68e" translate="yes" xml:space="preserve">
          <source>The effect of computing the expression is:</source>
          <target state="translated">式を計算する効果があります。</target>
        </trans-unit>
        <trans-unit id="ff0a9ac30d7664a4e4282016eea87cab13969066" translate="yes" xml:space="preserve">
          <source>The element is initialized with the specified &lt;a href=&quot;append-element#kotlin.dom%24appendElement(org.w3c.dom.Element,%20kotlin.String,%20kotlin.Function1((org.w3c.dom.Element,%20kotlin.Unit)))/init&quot;&gt;init&lt;/a&gt; function.</source>
          <target state="translated">要素は、指定された&lt;a href=&quot;append-element#kotlin.dom%24appendElement(org.w3c.dom.Element,%20kotlin.String,%20kotlin.Function1((org.w3c.dom.Element,%20kotlin.Unit)))/init&quot;&gt;init&lt;/a&gt;関数で初期化されます。</target>
        </trans-unit>
        <trans-unit id="d9a189a8bbd800a60d20579c11365537800d1c5b" translate="yes" xml:space="preserve">
          <source>The element is initialized with the specified &lt;a href=&quot;create-element#kotlin.dom%24createElement(org.w3c.dom.Document,%20kotlin.String,%20kotlin.Function1((org.w3c.dom.Element,%20kotlin.Unit)))/init&quot;&gt;init&lt;/a&gt; function.</source>
          <target state="translated">要素は、指定された&lt;a href=&quot;create-element#kotlin.dom%24createElement(org.w3c.dom.Document,%20kotlin.String,%20kotlin.Function1((org.w3c.dom.Element,%20kotlin.Unit)))/init&quot;&gt;init&lt;/a&gt;関数で初期化されます。</target>
        </trans-unit>
        <trans-unit id="0a6537bfaccb8cddd8c481ef1fab76499f34a316" translate="yes" xml:space="preserve">
          <source>The element is initialized with the speicifed &lt;a href=&quot;append-element#kotlin.dom%24appendElement%28org.w3c.dom.Element%2C+kotlin.String%2C+kotlin.Function1%28%28org.w3c.dom.Element%2C+kotlin.Unit%29%29%29%2Finit&quot;&gt;init&lt;/a&gt; function.</source>
          <target state="translated">要素は特定の&lt;a href=&quot;append-element#kotlin.dom%24appendElement%28org.w3c.dom.Element%2C+kotlin.String%2C+kotlin.Function1%28%28org.w3c.dom.Element%2C+kotlin.Unit%29%29%29%2Finit&quot;&gt;init&lt;/a&gt;関数で初期化されます。</target>
        </trans-unit>
        <trans-unit id="3c970d5af5c7c3d91e3eb72687259d2ce93c168c" translate="yes" xml:space="preserve">
          <source>The element is initialized with the speicifed &lt;a href=&quot;create-element#kotlin.dom%24createElement%28org.w3c.dom.Document%2C+kotlin.String%2C+kotlin.Function1%28%28org.w3c.dom.Element%2C+kotlin.Unit%29%29%29%2Finit&quot;&gt;init&lt;/a&gt; function.</source>
          <target state="translated">要素は特定の&lt;a href=&quot;create-element#kotlin.dom%24createElement%28org.w3c.dom.Document%2C+kotlin.String%2C+kotlin.Function1%28%28org.w3c.dom.Element%2C+kotlin.Unit%29%29%29%2Finit&quot;&gt;init&lt;/a&gt;関数で初期化されます。</target>
        </trans-unit>
        <trans-unit id="4479436b9b0ce8aa0beac7c43130aa60627f658c" translate="yes" xml:space="preserve">
          <source>The elements are appended in the order they appear in the &lt;a href=&quot;../-mutable-list/add-all#kotlin.collections.MutableList%24addAll%28kotlin.collections.Collection%28%28kotlin.collections.MutableList.E%29%29%29%2Felements&quot;&gt;elements&lt;/a&gt; collection.</source>
          <target state="translated">要素は、&lt;a href=&quot;../-mutable-list/add-all#kotlin.collections.MutableList%24addAll%28kotlin.collections.Collection%28%28kotlin.collections.MutableList.E%29%29%29%2Felements&quot;&gt;要素&lt;/a&gt;コレクションに表示される順序で追加されます。</target>
        </trans-unit>
        <trans-unit id="544e4fbca97528fef2325c3afe55cace763538a4" translate="yes" xml:space="preserve">
          <source>The elements are appended in the order they appear in the &lt;a href=&quot;../-mutable-list/add-all#kotlin.collections.MutableList%24addAll(kotlin.collections.Collection((kotlin.collections.MutableList.E)))/elements&quot;&gt;elements&lt;/a&gt; collection.</source>
          <target state="translated">要素は、&lt;a href=&quot;../-mutable-list/add-all#kotlin.collections.MutableList%24addAll(kotlin.collections.Collection((kotlin.collections.MutableList.E)))/elements&quot;&gt;要素&lt;/a&gt;コレクションに表示される順序で追加されます。</target>
        </trans-unit>
        <trans-unit id="23022bf4214f0845c5b1a370815de8e19dc6515a" translate="yes" xml:space="preserve">
          <source>The elements are appended in the order they appear in the &lt;a href=&quot;add-all#kotlin.collections.MutableList%24addAll%28kotlin.collections.Collection%28%28kotlin.collections.MutableList.E%29%29%29%2Felements&quot;&gt;elements&lt;/a&gt; collection.</source>
          <target state="translated">要素は、&lt;a href=&quot;add-all#kotlin.collections.MutableList%24addAll%28kotlin.collections.Collection%28%28kotlin.collections.MutableList.E%29%29%29%2Felements&quot;&gt;要素&lt;/a&gt;コレクションに表示される順序で追加されます。</target>
        </trans-unit>
        <trans-unit id="82095a92897d87f6ce531db50ce0bc12db68723f" translate="yes" xml:space="preserve">
          <source>The elements are appended in the order they appear in the &lt;a href=&quot;add-all#kotlin.collections.MutableList%24addAll(kotlin.collections.Collection((kotlin.collections.MutableList.E)))/elements&quot;&gt;elements&lt;/a&gt; collection.</source>
          <target state="translated">要素は、&lt;a href=&quot;add-all#kotlin.collections.MutableList%24addAll(kotlin.collections.Collection((kotlin.collections.MutableList.E)))/elements&quot;&gt;要素&lt;/a&gt;コレクションに表示される順序で追加されます。</target>
        </trans-unit>
        <trans-unit id="daa9aa5d9ebd8b42b1bcdf3100554fd92ca03d09" translate="yes" xml:space="preserve">
          <source>The elements are compared for equality with the &lt;a href=&quot;../kotlin/-any/equals#kotlin.Any%24equals%28kotlin.Any%29&quot;&gt;equals&lt;/a&gt; function. For floating point numbers it means that &lt;code&gt;NaN&lt;/code&gt; is equal to itself and &lt;code&gt;-0.0&lt;/code&gt; is not equal to &lt;code&gt;0.0&lt;/code&gt;.</source>
          <target state="translated">要素は、&lt;a href=&quot;../kotlin/-any/equals#kotlin.Any%24equals%28kotlin.Any%29&quot;&gt;equals&lt;/a&gt;関数を使用して等しいかどうか比較されます。浮動小数点数の場合、 &lt;code&gt;NaN&lt;/code&gt; はそれ自体と等しく、 &lt;code&gt;-0.0&lt;/code&gt; は &lt;code&gt;0.0&lt;/code&gt; と等しくありません。</target>
        </trans-unit>
        <trans-unit id="aad20466e5a76028e3397e50e8845f24663b34cf" translate="yes" xml:space="preserve">
          <source>The elements are compared for equality with the &lt;a href=&quot;../kotlin/-any/equals#kotlin.Any%24equals(kotlin.Any?)&quot;&gt;equals&lt;/a&gt; function. For floating point numbers it means that &lt;code&gt;NaN&lt;/code&gt; is equal to itself and &lt;code&gt;-0.0&lt;/code&gt; is not equal to &lt;code&gt;0.0&lt;/code&gt;.</source>
          <target state="translated">要素は、&lt;a href=&quot;../kotlin/-any/equals#kotlin.Any%24equals(kotlin.Any?)&quot;&gt;equals&lt;/a&gt;関数と等しいかどうか比較されます。浮動小数点数の場合、 &lt;code&gt;NaN&lt;/code&gt; はそれ自体に等しく、 &lt;code&gt;-0.0&lt;/code&gt; は &lt;code&gt;0.0&lt;/code&gt; に等しくないことを意味します。</target>
        </trans-unit>
        <trans-unit id="f7d4f10d9d6ff53cf3cb02a56dcf3900dc9233c7" translate="yes" xml:space="preserve">
          <source>The elements in the resulting list are in the same order as they were in the source array.</source>
          <target state="translated">結果として得られるリストの要素は、元の配列に含まれていたものと同じ順番になります。</target>
        </trans-unit>
        <trans-unit id="4758b35da216c6ed38b8e3b01e9232e835ffdf62" translate="yes" xml:space="preserve">
          <source>The elements in the resulting list are in the same order as they were in the source collection.</source>
          <target state="translated">結果として得られるリストの要素は、ソース・コレクションにあったものと同じ順番で表示されます。</target>
        </trans-unit>
        <trans-unit id="925245d7080579f68b367dc0eefbb0c6350a2c59" translate="yes" xml:space="preserve">
          <source>The elements in the resulting sequence are in the same order as they were in the source sequence.</source>
          <target state="translated">結果として得られるシーケンスの要素は、元のシーケンスにあったものと同じ順番である。</target>
        </trans-unit>
        <trans-unit id="62f13d9c86bbfcad668fdecca43def6919a28064" translate="yes" xml:space="preserve">
          <source>The elements of other types are compared for equality with the &lt;a href=&quot;../kotlin/-any/equals#kotlin.Any%24equals%28kotlin.Any%29&quot;&gt;equals&lt;/a&gt; function. For floating point numbers it means that &lt;code&gt;NaN&lt;/code&gt; is equal to itself and &lt;code&gt;-0.0&lt;/code&gt; is not equal to &lt;code&gt;0.0&lt;/code&gt;.</source>
          <target state="translated">他のタイプの要素は、&lt;a href=&quot;../kotlin/-any/equals#kotlin.Any%24equals%28kotlin.Any%29&quot;&gt;equals&lt;/a&gt;関数を使用して等しいかどうか比較されます。浮動小数点数の場合、 &lt;code&gt;NaN&lt;/code&gt; はそれ自体と等しく、 &lt;code&gt;-0.0&lt;/code&gt; は &lt;code&gt;0.0&lt;/code&gt; と等しくありません。</target>
        </trans-unit>
        <trans-unit id="410a7c8a1416b4dffdf86f7b2fb29d1be03e7884" translate="yes" xml:space="preserve">
          <source>The elements of other types are compared for equality with the &lt;a href=&quot;../kotlin/-any/equals#kotlin.Any%24equals(kotlin.Any?)&quot;&gt;equals&lt;/a&gt; function. For floating point numbers it means that &lt;code&gt;NaN&lt;/code&gt; is equal to itself and &lt;code&gt;-0.0&lt;/code&gt; is not equal to &lt;code&gt;0.0&lt;/code&gt;.</source>
          <target state="translated">他のタイプの要素は、&lt;a href=&quot;../kotlin/-any/equals#kotlin.Any%24equals(kotlin.Any?)&quot;&gt;equals&lt;/a&gt;関数と等しいかどうか比較されます。浮動小数点数の場合、 &lt;code&gt;NaN&lt;/code&gt; はそれ自体に等しく、 &lt;code&gt;-0.0&lt;/code&gt; は &lt;code&gt;0.0&lt;/code&gt; に等しくないことを意味します。</target>
        </trans-unit>
        <trans-unit id="bb685b2c6e5acf402eac7fe67da99cd138309729" translate="yes" xml:space="preserve">
          <source>The end index of the &lt;a href=&quot;remove-range#kotlin.text%24removeRange%28kotlin.CharSequence%2C+kotlin.ranges.IntRange%29%2Frange&quot;&gt;range&lt;/a&gt; is included in the removed part.</source>
          <target state="translated">&lt;a href=&quot;remove-range#kotlin.text%24removeRange%28kotlin.CharSequence%2C+kotlin.ranges.IntRange%29%2Frange&quot;&gt;範囲&lt;/a&gt;の終了インデックスは、削除された部分に含まれます。</target>
        </trans-unit>
        <trans-unit id="11df9d3925f0418a6e38aed874d509daf4025048" translate="yes" xml:space="preserve">
          <source>The end index of the &lt;a href=&quot;remove-range#kotlin.text%24removeRange%28kotlin.String%2C+kotlin.ranges.IntRange%29%2Frange&quot;&gt;range&lt;/a&gt; is included in the removed part.</source>
          <target state="translated">&lt;a href=&quot;remove-range#kotlin.text%24removeRange%28kotlin.String%2C+kotlin.ranges.IntRange%29%2Frange&quot;&gt;範囲&lt;/a&gt;の終了インデックスは、削除された部分に含まれます。</target>
        </trans-unit>
        <trans-unit id="67fcbb6ac3e2a5c62cd2e430c9777a067763d923" translate="yes" xml:space="preserve">
          <source>The end index of the &lt;a href=&quot;remove-range#kotlin.text%24removeRange(kotlin.CharSequence,%20kotlin.ranges.IntRange)/range&quot;&gt;range&lt;/a&gt; is included in the removed part.</source>
          <target state="translated">&lt;a href=&quot;remove-range#kotlin.text%24removeRange(kotlin.CharSequence,%20kotlin.ranges.IntRange)/range&quot;&gt;範囲&lt;/a&gt;の終了インデックスは、削除された部分に含まれています。</target>
        </trans-unit>
        <trans-unit id="7aa81f1705dd0f516aa78c926061ad0c0bdec167" translate="yes" xml:space="preserve">
          <source>The end index of the &lt;a href=&quot;remove-range#kotlin.text%24removeRange(kotlin.String,%20kotlin.ranges.IntRange)/range&quot;&gt;range&lt;/a&gt; is included in the removed part.</source>
          <target state="translated">&lt;a href=&quot;remove-range#kotlin.text%24removeRange(kotlin.String,%20kotlin.ranges.IntRange)/range&quot;&gt;範囲&lt;/a&gt;の終了インデックスは、削除された部分に含まれています。</target>
        </trans-unit>
        <trans-unit id="88ef0ef1c8adfc13f79b17d279153b4deca66c2a" translate="yes" xml:space="preserve">
          <source>The end index of the &lt;a href=&quot;replace-range#kotlin.text%24replaceRange%28kotlin.CharSequence%2C+kotlin.ranges.IntRange%2C+kotlin.CharSequence%29%2Frange&quot;&gt;range&lt;/a&gt; is included in the part to be replaced.</source>
          <target state="translated">&lt;a href=&quot;replace-range#kotlin.text%24replaceRange%28kotlin.CharSequence%2C+kotlin.ranges.IntRange%2C+kotlin.CharSequence%29%2Frange&quot;&gt;範囲&lt;/a&gt;の終了インデックスは、置き換えられるパーツに含まれます。</target>
        </trans-unit>
        <trans-unit id="110043ac6542bd5ea84cfa58a2ba979b14417af8" translate="yes" xml:space="preserve">
          <source>The end index of the &lt;a href=&quot;replace-range#kotlin.text%24replaceRange%28kotlin.String%2C+kotlin.ranges.IntRange%2C+kotlin.CharSequence%29%2Frange&quot;&gt;range&lt;/a&gt; is included in the part to be replaced.</source>
          <target state="translated">&lt;a href=&quot;replace-range#kotlin.text%24replaceRange%28kotlin.String%2C+kotlin.ranges.IntRange%2C+kotlin.CharSequence%29%2Frange&quot;&gt;範囲&lt;/a&gt;の終了インデックスは、置き換えられるパーツに含まれます。</target>
        </trans-unit>
        <trans-unit id="265808d7f064c65b3e4484a504c21278573abe5f" translate="yes" xml:space="preserve">
          <source>The end index of the &lt;a href=&quot;replace-range#kotlin.text%24replaceRange(kotlin.CharSequence,%20kotlin.ranges.IntRange,%20kotlin.CharSequence)/range&quot;&gt;range&lt;/a&gt; is included in the part to be replaced.</source>
          <target state="translated">&lt;a href=&quot;replace-range#kotlin.text%24replaceRange(kotlin.CharSequence,%20kotlin.ranges.IntRange,%20kotlin.CharSequence)/range&quot;&gt;範囲&lt;/a&gt;の終了インデックスは、交換されるパーツに含まれています。</target>
        </trans-unit>
        <trans-unit id="2757b02f416ac5f1c57fe37f28ebb5f19a2beb88" translate="yes" xml:space="preserve">
          <source>The end index of the &lt;a href=&quot;replace-range#kotlin.text%24replaceRange(kotlin.String,%20kotlin.ranges.IntRange,%20kotlin.CharSequence)/range&quot;&gt;range&lt;/a&gt; is included in the part to be replaced.</source>
          <target state="translated">&lt;a href=&quot;replace-range#kotlin.text%24replaceRange(kotlin.String,%20kotlin.ranges.IntRange,%20kotlin.CharSequence)/range&quot;&gt;範囲&lt;/a&gt;の終了インデックスは、交換されるパーツに含まれています。</target>
        </trans-unit>
        <trans-unit id="d2bb3fe28b22f0be53eb5ccfae4478026ce71334" translate="yes" xml:space="preserve">
          <source>The entity which has an associated native pointer. Subtypes are supposed to represent interpretations of the pointed data or code.</source>
          <target state="translated">関連するネイティブポインタを持つ実体。サブタイプは、ポイントされたデータやコードの解釈を表すことになっています。</target>
        </trans-unit>
        <trans-unit id="2c6bd81b6f529ef522b5222f238d9ced96f1bfdb" translate="yes" xml:space="preserve">
          <source>The enum constants also implement the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-comparable/index&quot;&gt;Comparable&lt;/a&gt; interface, with the natural order being the order in which they are defined in the enum class.</source>
          <target state="translated">enum定数は&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-comparable/index&quot;&gt;Comparable&lt;/a&gt;インターフェースも実装し、自然順序はenumクラスで定義された順序です。</target>
        </trans-unit>
        <trans-unit id="1f86188b4a8b45564220a022aed934fe72f40d6e" translate="yes" xml:space="preserve">
          <source>The example above shows the difference: &lt;code&gt;fold()&lt;/code&gt; is used for calculating the sum of doubled elements. If you pass the same function to &lt;code&gt;reduce()&lt;/code&gt;, it will return another result because it uses the list's first and second elements as arguments on the first step, so the first element won't be doubled.</source>
          <target state="translated">上記の例は違いを示しています &lt;code&gt;fold()&lt;/code&gt; は、2倍の要素の合計を計算するために使用されます。同じ関数を &lt;code&gt;reduce()&lt;/code&gt; に渡すと、リストの最初と2番目の要素を最初のステップの引数として使用するため、別の結果が返され、最初の要素は2倍になりません。</target>
        </trans-unit>
        <trans-unit id="b596f3f6b2203ee7818d443ce1a3eb3a2049daee" translate="yes" xml:space="preserve">
          <source>The example above will work for Android libraries with no product flavors. For a library with product flavors, the variant names also contain the flavors, like &lt;code&gt;fooBarDebug&lt;/code&gt; or &lt;code&gt;fooBazRelease&lt;/code&gt;.</source>
          <target state="translated">上記の例は、製品フレーバーのないAndroidライブラリで機能します。製品フレーバーを持つライブラリーの場合、バリアント名には &lt;code&gt;fooBarDebug&lt;/code&gt; や &lt;code&gt;fooBazRelease&lt;/code&gt; などのフレーバーも含まれます。</target>
        </trans-unit>
        <trans-unit id="2034baca1648e38acba659c7ed9ab52779def3a9" translate="yes" xml:space="preserve">
          <source>The example of using &lt;code&gt;convert&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;convert&lt;/code&gt; の使用例：</target>
        </trans-unit>
        <trans-unit id="18829b154c907ba2a13646994ee9e04f0d08452d" translate="yes" xml:space="preserve">
          <source>The exception thrown when a character encoding or decoding error occurs.</source>
          <target state="translated">文字エンコーディングまたはデコーディングエラーが発生した場合にスローされる例外。</target>
        </trans-unit>
        <trans-unit id="15573b104c4da364167fd1f5ed5ef94aba8df42c" translate="yes" xml:space="preserve">
          <source>The experimental marker for associated objects API.</source>
          <target state="translated">関連オブジェクトAPIの実験的マーカー。</target>
        </trans-unit>
        <trans-unit id="6d95121d07b3626cf990aefa17a36910bfcf4f29" translate="yes" xml:space="preserve">
          <source>The experimental marker for type inference augmenting annotations.</source>
          <target state="translated">アノテーションを補強する型推論のための実験的マーカー。</target>
        </trans-unit>
        <trans-unit id="deb8aac7cf53fe1202db4a3293685d56f19ee1b3" translate="yes" xml:space="preserve">
          <source>The experimental multiplatform support API marker.</source>
          <target state="translated">実験的なマルチプラットフォーム対応APIマーカー。</target>
        </trans-unit>
        <trans-unit id="0428313ba384ac9c0b8833c120ad8f95ce4ede3d" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;::x&lt;/code&gt; evaluates to a property object of type &lt;code&gt;KProperty&amp;lt;Int&amp;gt;&lt;/code&gt;, which allows us to read its value using &lt;code&gt;get()&lt;/code&gt; or retrieve the property name using the &lt;code&gt;name&lt;/code&gt; property. For more information, please refer to the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.reflect/-k-property/index&quot;&gt;docs on the &lt;code&gt;KProperty&lt;/code&gt; class&lt;/a&gt;.</source>
          <target state="translated">式 &lt;code&gt;::x&lt;/code&gt; は、タイプ &lt;code&gt;KProperty&amp;lt;Int&amp;gt;&lt;/code&gt; プロパティオブジェクトに評価されます。これにより、 &lt;code&gt;get()&lt;/code&gt; を使用してその値を読み取るか、 &lt;code&gt;name&lt;/code&gt; プロパティを使用してプロパティ名を取得できます。詳細について&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.reflect/-k-property/index&quot;&gt;は、 &lt;code&gt;KProperty&lt;/code&gt; クラスのドキュメント&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="788ff064b8ecef1f248204a84772fdfe4508eee7" translate="yes" xml:space="preserve">
          <source>The file is missing the &lt;code&gt;extern &quot;C&quot;&lt;/code&gt; block, which is not needed for our example, but may be necessary if we use C++ and overloaded functions. The &lt;a href=&quot;https://stackoverflow.com/questions/1041866/what-is-the-effect-of-extern-c-in-c&quot;&gt;C++ compatibility&lt;/a&gt; thread contains more details on this.</source>
          <target state="translated">このファイルには &lt;code&gt;extern &quot;C&quot;&lt;/code&gt; ブロックがありません。この例では必要ありませんが、C ++とオーバーロードされた関数を使用する場合は必要になることがあります。&lt;a href=&quot;https://stackoverflow.com/questions/1041866/what-is-the-effect-of-extern-c-in-c&quot;&gt;C ++の互換性の&lt;/a&gt;スレッドがこのについての詳細が含まれています。</target>
        </trans-unit>
        <trans-unit id="2828031dfb85b70cc7191c0b9ade03e3586cc60a" translate="yes" xml:space="preserve">
          <source>The file system locations for the Java sources are different from the &lt;code&gt;java&lt;/code&gt; plugin's defaults. The Java source files need to be placed in the sibling directories of the Kotlin source roots. For example, if the JVM target has the default name &lt;code&gt;jvm&lt;/code&gt;, the paths are:</source>
          <target state="translated">Javaソースのファイルシステムの場所が異なっている &lt;code&gt;java&lt;/code&gt; プラグインのデフォルト設定。Javaソースファイルは、Kotlinソースルートの兄弟ディレクトリに配置する必要があります。たとえば、JVMターゲットのデフォルト名が &lt;code&gt;jvm&lt;/code&gt; の場合、パスは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="a63cb5acdae60d6976d603a52addbcfa0b41167c" translate="yes" xml:space="preserve">
          <source>The file we're mostly interested in is &lt;code&gt;ConsoleOutput.js&lt;/code&gt;</source>
          <target state="translated">私たちが最も関心のあるファイルは &lt;code&gt;ConsoleOutput.js&lt;/code&gt; です</target>
        </trans-unit>
        <trans-unit id="b2c228ca59fbecd7257e251a141cb2c1718c2ba0" translate="yes" xml:space="preserve">
          <source>The final code in the &lt;code&gt;hello.kt&lt;/code&gt; file may look like that:</source>
          <target state="translated">&lt;code&gt;hello.kt&lt;/code&gt; ファイルの最終的なコードは次のようになります。</target>
        </trans-unit>
        <trans-unit id="994c32d45d717275b8093d1a6c05a756a3faeb93" translate="yes" xml:space="preserve">
          <source>The final code in the &lt;code&gt;hello.kt&lt;/code&gt; file may look like this:</source>
          <target state="translated">&lt;code&gt;hello.kt&lt;/code&gt; ファイルの最終的なコードは次のようになります。</target>
        </trans-unit>
        <trans-unit id="845eeef01520a4662cdfbe660097ba30ecf3f4fb" translate="yes" xml:space="preserve">
          <source>The final step is to define the actual compilation of the project, which uses the standard IntelliJ IDEA Runner Type</source>
          <target state="translated">最後のステップは、プロジェクトの実際のコンパイルを定義することで、標準のIntelliJ IDEAランナータイプを使用します。</target>
        </trans-unit>
        <trans-unit id="64ebebb6a3a3dfec1d013df86e5fccb457a8633c" translate="yes" xml:space="preserve">
          <source>The final step is to make Xcode call our Gradle build to prepare the &lt;code&gt;SharedCode&lt;/code&gt; framework before each run. We open the &lt;em&gt;Build Phases&lt;/em&gt; tab and click &lt;code&gt;+&lt;/code&gt; to add the &lt;em&gt;New Run Script Phase&lt;/em&gt; and add the following code into it:</source>
          <target state="translated">最後のステップは、XcodeがGradleビルドを呼び出して、実行する前に &lt;code&gt;SharedCode&lt;/code&gt; フレームワークを準備することです。[ &lt;em&gt;ビルドフェーズ&lt;/em&gt; ]タブを開き、[ &lt;code&gt;+&lt;/code&gt; ]をクリックして&lt;em&gt;新しい実行スクリプトフェーズ&lt;/em&gt;を追加し、それに次のコードを追加します。</target>
        </trans-unit>
        <trans-unit id="18cac2860812daece2680c18729b8285d0c95c2d" translate="yes" xml:space="preserve">
          <source>The first &lt;code&gt;this&lt;/code&gt; refers to &lt;code&gt;maybeNull&lt;/code&gt;, the second one refers to the result of &lt;code&gt;firstFunction()&lt;/code&gt;, and &lt;code&gt;result&lt;/code&gt; will be the result of &lt;code&gt;secondFunction()&lt;/code&gt; (or null if &lt;code&gt;maybeNull&lt;/code&gt; or any of the intermediate results were null).</source>
          <target state="translated">最初 &lt;code&gt;this&lt;/code&gt; を意味 &lt;code&gt;maybeNull&lt;/code&gt; 、もう一つは結果を参照 &lt;code&gt;firstFunction()&lt;/code&gt; 、及び &lt;code&gt;result&lt;/code&gt; 結果になり &lt;code&gt;secondFunction()&lt;/code&gt; (場合はnull &lt;code&gt;maybeNull&lt;/code&gt; 又は中間結果のいずれかがNULLでした）。</target>
        </trans-unit>
        <trans-unit id="4fdd8b62987d88f8c4db3a2a41e10fc4d1887b5c" translate="yes" xml:space="preserve">
          <source>The first argument in this example allows one to set a name prefix for the created binaries which is used to access them in the buildscript (see the &lt;a href=&quot;#accessing-binaries&quot;&gt;&quot;Accessing binaries&quot;&lt;/a&gt; section). Also this prefix is used as a default name for the binary file. For example on Windows the sample above produces files &lt;code&gt;foo.exe&lt;/code&gt; and &lt;code&gt;bar.exe&lt;/code&gt;.</source>
          <target state="translated">この例の最初の引数を使用すると、作成されたバイナリの名前プレフィックスを設定できます。これは、ビルドスクリプトでそれらにアクセスするために使用されます（&lt;a href=&quot;#accessing-binaries&quot;&gt;「バイナリへのアクセス」&lt;/a&gt;セクションを参照）。また、この接頭辞はバイナリファイルのデフォルト名として使用されます。たとえばWindowsでは、上記のサンプルはファイル &lt;code&gt;foo.exe&lt;/code&gt; および &lt;code&gt;bar.exe&lt;/code&gt; を生成します。</target>
        </trans-unit>
        <trans-unit id="2fc302c51d198c918ae55a3c30c065988889b3c8" translate="yes" xml:space="preserve">
          <source>The first call in the chain usually should have a line break before it, but it's OK to omit it if the code makes more sense that way.</source>
          <target state="translated">チェーンの最初の呼び出しは通常、その前に改行を入れるべきですが、その方がコードに意味があるのであれば、それを省略しても構いません。</target>
        </trans-unit>
        <trans-unit id="b4e33fae8e821602ad4182a2f8cd98570f5752fb" translate="yes" xml:space="preserve">
          <source>The first element in the progression.</source>
          <target state="translated">進行の最初の要素。</target>
        </trans-unit>
        <trans-unit id="f74c962485a9f3f35870c553a197b5ef319d5a35" translate="yes" xml:space="preserve">
          <source>The first example mixes &lt;em&gt;non-blocking&lt;/em&gt;&lt;code&gt;delay(...)&lt;/code&gt; and &lt;em&gt;blocking&lt;/em&gt;&lt;code&gt;Thread.sleep(...)&lt;/code&gt; in the same code. It is easy to lose track of which one is blocking and which one is not. Let's be explicit about blocking using &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt; coroutine builder:</source>
          <target state="translated">最初の例では、同じコードで&lt;em&gt;非ブロッキング&lt;/em&gt; &lt;code&gt;delay(...)&lt;/code&gt; と&lt;em&gt;ブロッキング&lt;/em&gt; &lt;code&gt;Thread.sleep(...)&lt;/code&gt; &lt;em&gt;を&lt;/em&gt;組み合わせています。どちらがブロックしているか、どちらがブロックしていないかを見失うのは簡単です。&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt;コルーチンビルダーを使用したブロッキングについて明示的にしましょう。</target>
        </trans-unit>
        <trans-unit id="1aa4bbc7c819801ad00e125d4e56e82f4c2f67c5" translate="yes" xml:space="preserve">
          <source>The first example mixes &lt;em&gt;non-blocking&lt;/em&gt;&lt;code&gt;delay(...)&lt;/code&gt; and &lt;em&gt;blocking&lt;/em&gt;&lt;code&gt;Thread.sleep(...)&lt;/code&gt; in the same code. It is easy to lose track of which one is blocking and which one is not. Let's be explicit about blocking using the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt; coroutine builder:</source>
          <target state="translated">最初の例では、&lt;em&gt;非ブロッキング&lt;/em&gt; &lt;code&gt;delay(...)&lt;/code&gt; と&lt;em&gt;ブロッキング&lt;/em&gt; &lt;code&gt;Thread.sleep(...)&lt;/code&gt; を同じコードに混在させています。どちらがブロックしていて、どれがブロックしていないかを見失うことは簡単です。&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt;コルーチンビルダーを使用したブロッキングについて明示的にしましょう。</target>
        </trans-unit>
        <trans-unit id="b2d66cf460f6f78061ad6d5f7262d3436e850f41" translate="yes" xml:space="preserve">
          <source>The first extension takes a &lt;code&gt;char *&lt;/code&gt; as a UTF-8 string and turns it into a String. The second function does the same but for wide UTF-16 strings.</source>
          <target state="translated">最初の拡張は &lt;code&gt;char *&lt;/code&gt; をUTF-8文字列として取り、それを文字列に変換します。2番目の関数は同じことを行いますが、ワイドUTF-16文字列に対してです。</target>
        </trans-unit>
        <trans-unit id="60455f009d759b3a711a0c86694ca0f8e3417539" translate="yes" xml:space="preserve">
          <source>The first four elements are added to the buffer and the sender suspends when trying to send the fifth one.</source>
          <target state="translated">最初の4つの要素がバッファに追加され、5つ目の要素を送ろうとすると送信者がサスペンドします。</target>
        </trans-unit>
        <trans-unit id="ab32e32b6495f8ef1ecac2deb728551ecd768355" translate="yes" xml:space="preserve">
          <source>The first function is &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/flatten&quot;&gt;&lt;code&gt;flatten()&lt;/code&gt;&lt;/a&gt;. You can call it on a collection of collections, for example, a &lt;code&gt;List&lt;/code&gt; of &lt;code&gt;Set&lt;/code&gt;s. The function returns a single &lt;code&gt;List&lt;/code&gt; of all the elements of the nested collections.</source>
          <target state="translated">最初の関数は&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/flatten&quot;&gt; &lt;code&gt;flatten()&lt;/code&gt; &lt;/a&gt;です。コレクションのコレクション、たとえば &lt;code&gt;List&lt;/code&gt; of &lt;code&gt;Set&lt;/code&gt; で呼び出すことができます。この関数は、ネストされたコレクションのすべての要素の単一の &lt;code&gt;List&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="bb9b81609c647210d6aacd108c4c1230b4870b5f" translate="yes" xml:space="preserve">
          <source>The first line of the input contains two integers &lt;code&gt;n&lt;/code&gt; and &lt;code&gt;k&lt;/code&gt;</source>
          <target state="translated">入力の最初の行には2つの整数 &lt;code&gt;n&lt;/code&gt; と &lt;code&gt;k&lt;/code&gt; が含まれています</target>
        </trans-unit>
        <trans-unit id="a973365d252e2f2156e9bff5ffce49da12fd36a5" translate="yes" xml:space="preserve">
          <source>The first list contains the first elements of each &lt;code&gt;Pair&lt;/code&gt; in the original list.</source>
          <target state="translated">最初のリストには、元のリストの各 &lt;code&gt;Pair&lt;/code&gt; 最初の要素が含まれています。</target>
        </trans-unit>
        <trans-unit id="79bda60284dc4aa80a7917505f3968fd9009f668" translate="yes" xml:space="preserve">
          <source>The first step of using an actor is to define a class of messages that an actor is going to process. Kotlin's &lt;a href=&quot;../sealed-classes&quot;&gt;sealed classes&lt;/a&gt; are well suited for that purpose. We define &lt;code&gt;CounterMsg&lt;/code&gt; sealed class with &lt;code&gt;IncCounter&lt;/code&gt; message to increment a counter and &lt;code&gt;GetCounter&lt;/code&gt; message to get its value. The later needs to send a response. A &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-completable-deferred/index.html&quot;&gt;CompletableDeferred&lt;/a&gt; communication primitive, that represents a single value that will be known (communicated) in the future, is used here for that purpose.</source>
          <target state="translated">アクターを使用する最初のステップは、アクターが処理するメッセージのクラスを定義することです。Kotlinの&lt;a href=&quot;../sealed-classes&quot;&gt;シールドクラス&lt;/a&gt;は、その目的に適しています。カウンターをインクリメントするための &lt;code&gt;IncCounter&lt;/code&gt; メッセージとその値を取得するための &lt;code&gt;GetCounter&lt;/code&gt; メッセージを使用して、 &lt;code&gt;CounterMsg&lt;/code&gt; 密封クラスを定義します。後者は応答を送信する必要があります。&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-completable-deferred/index.html&quot;&gt;CompletableDeferredの&lt;/a&gt;将来において知られている（連通）される単一の値を表すプリミティブの通信は、その目的のためにここで使用されます。</target>
        </trans-unit>
        <trans-unit id="38481ec6d5c41bf35d07d09bc7535247f80dee43" translate="yes" xml:space="preserve">
          <source>The first thing we'll need is a Kotlin file called &lt;code&gt;src/nativeMain/kotlin/hello.kt&lt;/code&gt; with the &lt;code&gt;main&lt;/code&gt; function defined in it and then proceed to translate each line</source>
          <target state="translated">最初に必要なのは、 &lt;code&gt;main&lt;/code&gt; 関数が定義された &lt;code&gt;src/nativeMain/kotlin/hello.kt&lt;/code&gt; というKotlinファイルで、各行の翻訳に進みます。</target>
        </trans-unit>
        <trans-unit id="6f6aa8f820f0284bd28697b0207de3b2578af79f" translate="yes" xml:space="preserve">
          <source>The following attributes are supported:</source>
          <target state="translated">以下の属性がサポートされています。</target>
        </trans-unit>
        <trans-unit id="d555f20ea9bbf2028964527e2711757cec45ebd4" translate="yes" xml:space="preserve">
          <source>The following code launches a long-running coroutine in &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope&lt;/a&gt; that prints &quot;I'm sleeping&quot; twice a second and then returns from the main function after some delay:</source>
          <target state="translated">次のコードは、&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope&lt;/a&gt;で実行時間の長いコルーチンを起動し、「I'm Sleeping」を1秒に2回出力し、しばらくしてからメイン関数から戻ります。</target>
        </trans-unit>
        <trans-unit id="ead88ea1dd6b3e545d54d2d74bc4d103e0cfff51" translate="yes" xml:space="preserve">
          <source>The following commands are available.</source>
          <target state="translated">以下のコマンドが利用できます。</target>
        </trans-unit>
        <trans-unit id="55be4cb42f91b956f18957a0a075265fb24672f6" translate="yes" xml:space="preserve">
          <source>The following example demonstrates this concept:</source>
          <target state="translated">次の例は、この概念を示しています。</target>
        </trans-unit>
        <trans-unit id="40d8cb89ac87b573a486f4f8fe49663dde1297b2" translate="yes" xml:space="preserve">
          <source>The following example prints the first ten prime numbers, running the whole pipeline in the context of the main thread. Since all the coroutines are launched in the scope of the main &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt; coroutine we don't have to keep an explicit list of all the coroutines we have started. We use &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/kotlin.coroutines.-coroutine-context/cancel-children.html&quot;&gt;cancelChildren&lt;/a&gt; extension function to cancel all the children coroutines after we have printed the first ten prime numbers.</source>
          <target state="translated">次の例では、メインスレッドのコンテキストでパイプライン全体を実行して、最初の10個の素数を出力します。すべてのコルーチンはメインの&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt;コルーチンのスコープ内で起動されるため、開始したすべてのコルーチンの明示的なリストを保持する必要はありません。最初の10個の素数を出力した後、&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/kotlin.coroutines.-coroutine-context/cancel-children.html&quot;&gt;cancelChildren&lt;/a&gt;拡張関数を使用してすべての子コルーチンをキャンセルします。</target>
        </trans-unit>
        <trans-unit id="9f818012b8152abe166a094d93ab2ca0ec79eab1" translate="yes" xml:space="preserve">
          <source>The following example shows how to use these settings.</source>
          <target state="translated">以下の例では、これらの設定を使用する方法を説明します。</target>
        </trans-unit>
        <trans-unit id="29c80399d536894a6ec94c527a731166260c49c2" translate="yes" xml:space="preserve">
          <source>The following example shows their use outside of coroutine:</source>
          <target state="translated">以下の例では、コルーチン以外での使用例を示しています。</target>
        </trans-unit>
        <trans-unit id="b39c4c0b095563ff59ef483ec27836f8b662f2fa" translate="yes" xml:space="preserve">
          <source>The following examples show different possibilities of configuring the Gradle plugin:</source>
          <target state="translated">以下の例では、Gradle プラグインを設定するためのさまざまな可能性を示しています。</target>
        </trans-unit>
        <trans-unit id="e712d7790d39e907b7ee7e8cb60e61e0c86b31e2" translate="yes" xml:space="preserve">
          <source>The following identifiers are defined by the compiler in specific contexts and can be used as regular identifiers in other contexts:</source>
          <target state="translated">以下の識別子は、特定のコンテキストでコンパイラによって定義され、他のコンテキストでは通常の識別子として使用することができます。</target>
        </trans-unit>
        <trans-unit id="bf95dedf99c3841e1d5196a0ba2d969912347f7d" translate="yes" xml:space="preserve">
          <source>The following is an example interface of the JDK implemented by &lt;code&gt;StringBuilder&lt;/code&gt; class:</source>
          <target state="translated">以下は、 &lt;code&gt;StringBuilder&lt;/code&gt; クラスによって実装されるJDKのインターフェースの例です。</target>
        </trans-unit>
        <trans-unit id="8e29598dc88ea6b0ec70ab50aa2a4cfa741c6e7f" translate="yes" xml:space="preserve">
          <source>The following pipeline stage filters an incoming stream of numbers, removing all the numbers that are divisible by the given prime number:</source>
          <target state="translated">次のパイプラインステージは、入力された数のストリームをフィルタリングし、与えられた素数で割り切れるすべての数を削除します。</target>
        </trans-unit>
        <trans-unit id="29b7ef083a5e449cb9ecea68dfa0ae64024fefca" translate="yes" xml:space="preserve">
          <source>The following podspec fields are required by CocoaPods:</source>
          <target state="translated">CocoaPodsでは、以下のpodspecフィールドが必須となります。</target>
        </trans-unit>
        <trans-unit id="21b0584d86535ffda98821a37bb76687f7207959" translate="yes" xml:space="preserve">
          <source>The following sections explain in more detail the concepts mentioned so far.</source>
          <target state="translated">以下では、これまでに述べた概念をより詳細に説明する。</target>
        </trans-unit>
        <trans-unit id="5472a88e6462dc9e30567cf6b7a816998c79c200" translate="yes" xml:space="preserve">
          <source>The following tokens act as keywords in modifier lists of declarations and can be used as identifiers in other contexts:</source>
          <target state="translated">以下のトークンは、宣言の修飾子リストのキーワードとして機能し、他のコンテキストで識別子として使用することができます。</target>
        </trans-unit>
        <trans-unit id="c62886b027ba800287b4be18a333a156fdeb309b" translate="yes" xml:space="preserve">
          <source>The following tokens act as keywords in the context when they are applicable and can be used as identifiers in other contexts:</source>
          <target state="translated">以下のトークンは、該当する場合にはコンテキスト内のキーワードとして動作し、他のコンテキストでは識別子として使用することができます。</target>
        </trans-unit>
        <trans-unit id="71c4c5ec356525034ad2f877a92ba2dfdfffc609" translate="yes" xml:space="preserve">
          <source>The following tokens are always interpreted as keywords and cannot be used as identifiers:</source>
          <target state="translated">以下のトークンは常にキーワードとして解釈され、識別子として使用することはできません。</target>
        </trans-unit>
        <trans-unit id="0493d41eaaff9f9930d4990e582a0014dff8b09e" translate="yes" xml:space="preserve">
          <source>The following workflow is expected when interacting with the native library.</source>
          <target state="translated">ネイティブライブラリとの対話では、以下のようなワークフローが想定されます。</target>
        </trans-unit>
        <trans-unit id="41bde8cb095fdaa39e87c44d34bec8992402e368" translate="yes" xml:space="preserve">
          <source>The fractional part, if any, is rounded down towards zero. Returns zero if this &lt;code&gt;Double&lt;/code&gt; value is &lt;code&gt;NaN&lt;/code&gt;, &lt;a href=&quot;../-int/-m-i-n_-v-a-l-u-e#kotlin.Int.Companion%24MIN_VALUE&quot;&gt;Int.MIN_VALUE&lt;/a&gt; if it's less than &lt;code&gt;Int.MIN_VALUE&lt;/code&gt;, &lt;a href=&quot;../-int/-m-a-x_-v-a-l-u-e#kotlin.Int.Companion%24MAX_VALUE&quot;&gt;Int.MAX_VALUE&lt;/a&gt; if it's bigger than &lt;code&gt;Int.MAX_VALUE&lt;/code&gt;.</source>
          <target state="translated">小数部分がある場合は、ゼロに向かって切り捨てられます。この &lt;code&gt;Double&lt;/code&gt; 値が &lt;code&gt;NaN&lt;/code&gt; の場合はゼロを返し、&lt;a href=&quot;../-int/-m-i-n_-v-a-l-u-e#kotlin.Int.Companion%24MIN_VALUE&quot;&gt;Int.MIN_VALUEより小さい&lt;/a&gt;場合は &lt;code&gt;Int.MIN_VALUE&lt;/code&gt; 、&lt;a href=&quot;../-int/-m-a-x_-v-a-l-u-e#kotlin.Int.Companion%24MAX_VALUE&quot;&gt;Int.MAX_VALUE&lt;/a&gt;より大きい場合は &lt;code&gt;Int.MAX_VALUE&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="b7dbd577dd676bd08f82b2f5d51d9ac8e4bfc959" translate="yes" xml:space="preserve">
          <source>The fractional part, if any, is rounded down towards zero. Returns zero if this &lt;code&gt;Double&lt;/code&gt; value is &lt;code&gt;NaN&lt;/code&gt;, &lt;a href=&quot;../-long/-m-i-n_-v-a-l-u-e#kotlin.Long.Companion%24MIN_VALUE&quot;&gt;Long.MIN_VALUE&lt;/a&gt; if it's less than &lt;code&gt;Long.MIN_VALUE&lt;/code&gt;, &lt;a href=&quot;../-long/-m-a-x_-v-a-l-u-e#kotlin.Long.Companion%24MAX_VALUE&quot;&gt;Long.MAX_VALUE&lt;/a&gt; if it's bigger than &lt;code&gt;Long.MAX_VALUE&lt;/code&gt;.</source>
          <target state="translated">小数部分がある場合は、ゼロに向かって切り捨てられます。この &lt;code&gt;Double&lt;/code&gt; 値が &lt;code&gt;NaN&lt;/code&gt; の場合はゼロを返し、&lt;a href=&quot;../-long/-m-i-n_-v-a-l-u-e#kotlin.Long.Companion%24MIN_VALUE&quot;&gt;Long.MIN_VALUE&lt;/a&gt;より小さい場合は &lt;code&gt;Long.MIN_VALUE&lt;/code&gt; 、&lt;a href=&quot;../-long/-m-a-x_-v-a-l-u-e#kotlin.Long.Companion%24MAX_VALUE&quot;&gt;Long.MAX_VALUE&lt;/a&gt;より大きい場合は &lt;code&gt;Long.MAX_VALUE&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="7c24376936f310cfc6a2b02ee789c1ab9c4a079c" translate="yes" xml:space="preserve">
          <source>The fractional part, if any, is rounded down towards zero. Returns zero if this &lt;code&gt;Double&lt;/code&gt; value is negative or &lt;code&gt;NaN&lt;/code&gt;, &lt;a href=&quot;-u-int/-m-a-x_-v-a-l-u-e&quot;&gt;UInt.MAX_VALUE&lt;/a&gt; if it's bigger than &lt;code&gt;UInt.MAX_VALUE&lt;/code&gt;.</source>
          <target state="translated">小数部分がある場合は、ゼロに向かって切り捨てられます。この場合はゼロを返します &lt;code&gt;Double&lt;/code&gt; 値が負または &lt;code&gt;NaN&lt;/code&gt; で、&lt;a href=&quot;-u-int/-m-a-x_-v-a-l-u-e&quot;&gt;UInt.MAX_VALUE&lt;/a&gt;それはよりも大きいかどう &lt;code&gt;UInt.MAX_VALUE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="19ac86b4bcb26b195d587cd10aa019f5e68922bb" translate="yes" xml:space="preserve">
          <source>The fractional part, if any, is rounded down towards zero. Returns zero if this &lt;code&gt;Double&lt;/code&gt; value is negative or &lt;code&gt;NaN&lt;/code&gt;, &lt;a href=&quot;-u-long/-m-a-x_-v-a-l-u-e&quot;&gt;ULong.MAX_VALUE&lt;/a&gt; if it's bigger than &lt;code&gt;ULong.MAX_VALUE&lt;/code&gt;.</source>
          <target state="translated">小数部分がある場合は、ゼロに向かって切り捨てられます。この場合はゼロを返します &lt;code&gt;Double&lt;/code&gt; 値が負または &lt;code&gt;NaN&lt;/code&gt; で、&lt;a href=&quot;-u-long/-m-a-x_-v-a-l-u-e&quot;&gt;ULong.MAX_VALUE&lt;/a&gt;それはよりも大きいかどう &lt;code&gt;ULong.MAX_VALUE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a03b953ac3fd08a46517db9b02880729ef0942e5" translate="yes" xml:space="preserve">
          <source>The fractional part, if any, is rounded down towards zero. Returns zero if this &lt;code&gt;Float&lt;/code&gt; value is &lt;code&gt;NaN&lt;/code&gt;, &lt;a href=&quot;../-int/-m-i-n_-v-a-l-u-e#kotlin.Int.Companion%24MIN_VALUE&quot;&gt;Int.MIN_VALUE&lt;/a&gt; if it's less than &lt;code&gt;Int.MIN_VALUE&lt;/code&gt;, &lt;a href=&quot;../-int/-m-a-x_-v-a-l-u-e#kotlin.Int.Companion%24MAX_VALUE&quot;&gt;Int.MAX_VALUE&lt;/a&gt; if it's bigger than &lt;code&gt;Int.MAX_VALUE&lt;/code&gt;.</source>
          <target state="translated">小数部分がある場合は、ゼロに向かって切り捨てられます。この &lt;code&gt;Float&lt;/code&gt; 値が &lt;code&gt;NaN&lt;/code&gt; の場合はゼロを返し、&lt;a href=&quot;../-int/-m-i-n_-v-a-l-u-e#kotlin.Int.Companion%24MIN_VALUE&quot;&gt;Int.MIN_VALUEより小さい&lt;/a&gt;場合は &lt;code&gt;Int.MIN_VALUE&lt;/code&gt; 、&lt;a href=&quot;../-int/-m-a-x_-v-a-l-u-e#kotlin.Int.Companion%24MAX_VALUE&quot;&gt;Int.MAX_VALUE&lt;/a&gt;より大きい場合は &lt;code&gt;Int.MAX_VALUE&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="f8f1f7669eb111859c7b969d69798041d2a9b37e" translate="yes" xml:space="preserve">
          <source>The fractional part, if any, is rounded down towards zero. Returns zero if this &lt;code&gt;Float&lt;/code&gt; value is &lt;code&gt;NaN&lt;/code&gt;, &lt;a href=&quot;../-long/-m-i-n_-v-a-l-u-e#kotlin.Long.Companion%24MIN_VALUE&quot;&gt;Long.MIN_VALUE&lt;/a&gt; if it's less than &lt;code&gt;Long.MIN_VALUE&lt;/code&gt;, &lt;a href=&quot;../-long/-m-a-x_-v-a-l-u-e#kotlin.Long.Companion%24MAX_VALUE&quot;&gt;Long.MAX_VALUE&lt;/a&gt; if it's bigger than &lt;code&gt;Long.MAX_VALUE&lt;/code&gt;.</source>
          <target state="translated">小数部分がある場合は、ゼロに向かって切り捨てられます。この &lt;code&gt;Float&lt;/code&gt; 値が &lt;code&gt;NaN&lt;/code&gt; の場合はゼロを返し、&lt;a href=&quot;../-long/-m-i-n_-v-a-l-u-e#kotlin.Long.Companion%24MIN_VALUE&quot;&gt;Long.MIN_VALUE&lt;/a&gt;より小さい場合は &lt;code&gt;Long.MIN_VALUE&lt;/code&gt; 、&lt;a href=&quot;../-long/-m-a-x_-v-a-l-u-e#kotlin.Long.Companion%24MAX_VALUE&quot;&gt;Long.MAX_VALUE&lt;/a&gt;より大きい場合は &lt;code&gt;Long.MAX_VALUE&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="43741e55696c4613d380e3f315ef0bfbfc2d96be" translate="yes" xml:space="preserve">
          <source>The fractional part, if any, is rounded down towards zero. Returns zero if this &lt;code&gt;Float&lt;/code&gt; value is negative or &lt;code&gt;NaN&lt;/code&gt;, &lt;a href=&quot;-u-int/-m-a-x_-v-a-l-u-e&quot;&gt;UInt.MAX_VALUE&lt;/a&gt; if it's bigger than &lt;code&gt;UInt.MAX_VALUE&lt;/code&gt;.</source>
          <target state="translated">小数部分がある場合は、ゼロに向かって切り捨てられます。この場合の戻り値はゼロ &lt;code&gt;Float&lt;/code&gt; 値が負かで &lt;code&gt;NaN&lt;/code&gt; 、&lt;a href=&quot;-u-int/-m-a-x_-v-a-l-u-e&quot;&gt;UInt.MAX_VALUE&lt;/a&gt;それはよりも大きいかどう &lt;code&gt;UInt.MAX_VALUE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3fd2c9a0fe0f333063fc214dadef0239e9bff9de" translate="yes" xml:space="preserve">
          <source>The fractional part, if any, is rounded down towards zero. Returns zero if this &lt;code&gt;Float&lt;/code&gt; value is negative or &lt;code&gt;NaN&lt;/code&gt;, &lt;a href=&quot;-u-long/-m-a-x_-v-a-l-u-e&quot;&gt;ULong.MAX_VALUE&lt;/a&gt; if it's bigger than &lt;code&gt;ULong.MAX_VALUE&lt;/code&gt;.</source>
          <target state="translated">小数部分がある場合は、ゼロに向かって切り捨てられます。この場合の戻り値はゼロ &lt;code&gt;Float&lt;/code&gt; 値が負かで &lt;code&gt;NaN&lt;/code&gt; 、&lt;a href=&quot;-u-long/-m-a-x_-v-a-l-u-e&quot;&gt;ULong.MAX_VALUE&lt;/a&gt;それはよりも大きいかどう &lt;code&gt;ULong.MAX_VALUE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="46d230bab2ec3e41d052e1e397afc7cc1e96642c" translate="yes" xml:space="preserve">
          <source>The fractional part, if any, is rounded down. Returns zero if this &lt;code&gt;Double&lt;/code&gt; value is &lt;code&gt;NaN&lt;/code&gt;, &lt;a href=&quot;../-int/-m-i-n_-v-a-l-u-e#kotlin.Int.Companion%24MIN_VALUE&quot;&gt;Int.MIN_VALUE&lt;/a&gt; if it's less than &lt;code&gt;Int.MIN_VALUE&lt;/code&gt;, &lt;a href=&quot;../-int/-m-a-x_-v-a-l-u-e#kotlin.Int.Companion%24MAX_VALUE&quot;&gt;Int.MAX_VALUE&lt;/a&gt; if it's bigger than &lt;code&gt;Int.MAX_VALUE&lt;/code&gt;.</source>
          <target state="translated">小数部がある場合は、切り捨てられます。この &lt;code&gt;Double&lt;/code&gt; 値が &lt;code&gt;NaN&lt;/code&gt; の場合はゼロを返し、&lt;a href=&quot;../-int/-m-i-n_-v-a-l-u-e#kotlin.Int.Companion%24MIN_VALUE&quot;&gt;Int.MIN_VALUEより小さい&lt;/a&gt;場合は &lt;code&gt;Int.MIN_VALUE&lt;/code&gt; を返し、&lt;a href=&quot;../-int/-m-a-x_-v-a-l-u-e#kotlin.Int.Companion%24MAX_VALUE&quot;&gt;Int.MAX_VALUE&lt;/a&gt;より大きい場合は &lt;code&gt;Int.MAX_VALUE&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="c7c04cb487d62c119eaf78735ad59d58fbbea7f7" translate="yes" xml:space="preserve">
          <source>The fractional part, if any, is rounded down. Returns zero if this &lt;code&gt;Double&lt;/code&gt; value is &lt;code&gt;NaN&lt;/code&gt;, &lt;a href=&quot;../-long/-m-i-n_-v-a-l-u-e#kotlin.Long.Companion%24MIN_VALUE&quot;&gt;Long.MIN_VALUE&lt;/a&gt; if it's less than &lt;code&gt;Long.MIN_VALUE&lt;/code&gt;, &lt;a href=&quot;../-long/-m-a-x_-v-a-l-u-e#kotlin.Long.Companion%24MAX_VALUE&quot;&gt;Long.MAX_VALUE&lt;/a&gt; if it's bigger than &lt;code&gt;Long.MAX_VALUE&lt;/code&gt;.</source>
          <target state="translated">小数部がある場合は、切り捨てられます。この &lt;code&gt;Double&lt;/code&gt; 値が &lt;code&gt;NaN&lt;/code&gt; の場合はゼロを返し、&lt;a href=&quot;../-long/-m-i-n_-v-a-l-u-e#kotlin.Long.Companion%24MIN_VALUE&quot;&gt;Long.MIN_VALUE&lt;/a&gt;より小さい場合は &lt;code&gt;Long.MIN_VALUE&lt;/code&gt; を返し、&lt;a href=&quot;../-long/-m-a-x_-v-a-l-u-e#kotlin.Long.Companion%24MAX_VALUE&quot;&gt;Long.MAX_VALUE&lt;/a&gt;より大きい場合は &lt;code&gt;Long.MAX_VALUE&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="986d603361e48796a38eb31b882249f0e0fb1907" translate="yes" xml:space="preserve">
          <source>The fractional part, if any, is rounded down. Returns zero if this &lt;code&gt;Double&lt;/code&gt; value is negative or &lt;code&gt;NaN&lt;/code&gt;, &lt;a href=&quot;-u-int/-m-a-x_-v-a-l-u-e&quot;&gt;UInt.MAX_VALUE&lt;/a&gt; if it's bigger than &lt;code&gt;UInt.MAX_VALUE&lt;/code&gt;.</source>
          <target state="translated">小数部がある場合は、切り捨てられます。この &lt;code&gt;Double&lt;/code&gt; 値が負の場合はゼロを返し、それが &lt;code&gt;UInt.MAX_VALUE&lt;/code&gt; より大きい場合は &lt;code&gt;NaN&lt;/code&gt; 、&lt;a href=&quot;-u-int/-m-a-x_-v-a-l-u-e&quot;&gt;UInt.MAX_VALUEを&lt;/a&gt;返します。</target>
        </trans-unit>
        <trans-unit id="db89446a546caa08c045751959e85b9b42af6661" translate="yes" xml:space="preserve">
          <source>The fractional part, if any, is rounded down. Returns zero if this &lt;code&gt;Double&lt;/code&gt; value is negative or &lt;code&gt;NaN&lt;/code&gt;, &lt;a href=&quot;-u-long/-m-a-x_-v-a-l-u-e&quot;&gt;ULong.MAX_VALUE&lt;/a&gt; if it's bigger than &lt;code&gt;ULong.MAX_VALUE&lt;/code&gt;.</source>
          <target state="translated">小数部がある場合は、切り捨てられます。この場合はゼロを返します &lt;code&gt;Double&lt;/code&gt; 値が負または &lt;code&gt;NaN&lt;/code&gt; で、&lt;a href=&quot;-u-long/-m-a-x_-v-a-l-u-e&quot;&gt;ULong.MAX_VALUE&lt;/a&gt;それはよりも大きいかどう &lt;code&gt;ULong.MAX_VALUE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6c0d7df43097a38a432b999c674eaa178ec96a50" translate="yes" xml:space="preserve">
          <source>The fractional part, if any, is rounded down. Returns zero if this &lt;code&gt;Float&lt;/code&gt; value is &lt;code&gt;NaN&lt;/code&gt;, &lt;a href=&quot;../-int/-m-i-n_-v-a-l-u-e#kotlin.Int.Companion%24MIN_VALUE&quot;&gt;Int.MIN_VALUE&lt;/a&gt; if it's less than &lt;code&gt;Int.MIN_VALUE&lt;/code&gt;, &lt;a href=&quot;../-int/-m-a-x_-v-a-l-u-e#kotlin.Int.Companion%24MAX_VALUE&quot;&gt;Int.MAX_VALUE&lt;/a&gt; if it's bigger than &lt;code&gt;Int.MAX_VALUE&lt;/code&gt;.</source>
          <target state="translated">小数部がある場合は、切り捨てられます。この &lt;code&gt;Float&lt;/code&gt; 値が &lt;code&gt;NaN&lt;/code&gt; の場合はゼロを返し、&lt;a href=&quot;../-int/-m-i-n_-v-a-l-u-e#kotlin.Int.Companion%24MIN_VALUE&quot;&gt;Int.MIN_VALUEより小さい&lt;/a&gt;場合は &lt;code&gt;Int.MIN_VALUE&lt;/code&gt; を返し、&lt;a href=&quot;../-int/-m-a-x_-v-a-l-u-e#kotlin.Int.Companion%24MAX_VALUE&quot;&gt;Int.MAX_VALUE&lt;/a&gt;より大きい場合は &lt;code&gt;Int.MAX_VALUE&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="234cddb40ea7edc20ba16f302fd45e435a6a6dbf" translate="yes" xml:space="preserve">
          <source>The fractional part, if any, is rounded down. Returns zero if this &lt;code&gt;Float&lt;/code&gt; value is &lt;code&gt;NaN&lt;/code&gt;, &lt;a href=&quot;../-long/-m-i-n_-v-a-l-u-e#kotlin.Long.Companion%24MIN_VALUE&quot;&gt;Long.MIN_VALUE&lt;/a&gt; if it's less than &lt;code&gt;Long.MIN_VALUE&lt;/code&gt;, &lt;a href=&quot;../-long/-m-a-x_-v-a-l-u-e#kotlin.Long.Companion%24MAX_VALUE&quot;&gt;Long.MAX_VALUE&lt;/a&gt; if it's bigger than &lt;code&gt;Long.MAX_VALUE&lt;/code&gt;.</source>
          <target state="translated">小数部がある場合は、切り捨てられます。この &lt;code&gt;Float&lt;/code&gt; 値が &lt;code&gt;NaN&lt;/code&gt; の場合はゼロを返し、&lt;a href=&quot;../-long/-m-i-n_-v-a-l-u-e#kotlin.Long.Companion%24MIN_VALUE&quot;&gt;Long.MIN_VALUE&lt;/a&gt;より小さい場合は &lt;code&gt;Long.MIN_VALUE&lt;/code&gt; 、&lt;a href=&quot;../-long/-m-a-x_-v-a-l-u-e#kotlin.Long.Companion%24MAX_VALUE&quot;&gt;Long.MAX_VALUE&lt;/a&gt;より大きい場合は &lt;code&gt;Long.MAX_VALUE&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="0a1bb43be34e6fb6de623932b67b670ae0006852" translate="yes" xml:space="preserve">
          <source>The fractional part, if any, is rounded down. Returns zero if this &lt;code&gt;Float&lt;/code&gt; value is negative or &lt;code&gt;NaN&lt;/code&gt;, &lt;a href=&quot;-u-int/-m-a-x_-v-a-l-u-e&quot;&gt;UInt.MAX_VALUE&lt;/a&gt; if it's bigger than &lt;code&gt;UInt.MAX_VALUE&lt;/code&gt;.</source>
          <target state="translated">小数部がある場合は、切り捨てられます。この場合の戻り値はゼロ &lt;code&gt;Float&lt;/code&gt; 値が負かで &lt;code&gt;NaN&lt;/code&gt; 、&lt;a href=&quot;-u-int/-m-a-x_-v-a-l-u-e&quot;&gt;UInt.MAX_VALUE&lt;/a&gt;それはよりも大きいかどう &lt;code&gt;UInt.MAX_VALUE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1fdd0d739f0100ce802b95ab4a4c9b2532feeff0" translate="yes" xml:space="preserve">
          <source>The fractional part, if any, is rounded down. Returns zero if this &lt;code&gt;Float&lt;/code&gt; value is negative or &lt;code&gt;NaN&lt;/code&gt;, &lt;a href=&quot;-u-long/-m-a-x_-v-a-l-u-e&quot;&gt;ULong.MAX_VALUE&lt;/a&gt; if it's bigger than &lt;code&gt;ULong.MAX_VALUE&lt;/code&gt;.</source>
          <target state="translated">小数部がある場合は、切り捨てられます。この場合の戻り値はゼロ &lt;code&gt;Float&lt;/code&gt; 値が負かで &lt;code&gt;NaN&lt;/code&gt; 、&lt;a href=&quot;-u-long/-m-a-x_-v-a-l-u-e&quot;&gt;ULong.MAX_VALUE&lt;/a&gt;それはよりも大きいかどう &lt;code&gt;ULong.MAX_VALUE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ea6eb6722ce134e1e96c66df47559354876af311" translate="yes" xml:space="preserve">
          <source>The framework that we compiled with Kotlin/Native has helper attributes to make it easier to use with Swift. Let's convert the previous Objective-C example into Swift. As a result, we'll have the following code in &lt;code&gt;main.swift&lt;/code&gt;:</source>
          <target state="translated">Kotlin / Nativeでコンパイルしたフレームワークには、Swiftでの使用を容易にするヘルパー属性があります。前のObjective-Cの例をSwiftに変換してみましょう。その結果、 &lt;code&gt;main.swift&lt;/code&gt; に次のコードが含まれます。</target>
        </trans-unit>
        <trans-unit id="229775820ba0ca0053d7b140e68dd9b3ed428ae4" translate="yes" xml:space="preserve">
          <source>The full build script for the sample project can be found &lt;a href=&quot;https://github.com/JetBrains/kotlin-examples/tree/master/gradle/kotlin-dagger/build.gradle&quot;&gt;here&lt;/a&gt;. You can also look at the converted code for &lt;a href=&quot;https://github.com/JetBrains/kotlin-examples/tree/master/gradle/android-dagger&quot;&gt;the Android sample&lt;/a&gt;.</source>
          <target state="translated">サンプルプロジェクトの完全なビルドスクリプトは、&lt;a href=&quot;https://github.com/JetBrains/kotlin-examples/tree/master/gradle/kotlin-dagger/build.gradle&quot;&gt;こちらにあります&lt;/a&gt;。&lt;a href=&quot;https://github.com/JetBrains/kotlin-examples/tree/master/gradle/android-dagger&quot;&gt;Androidサンプル&lt;/a&gt;用に変換されたコードも確認できます。</target>
        </trans-unit>
        <trans-unit id="e62bc4cb51ca1d1cddfe4e1d3d510caa93dee388" translate="yes" xml:space="preserve">
          <source>The full list of arguments that can be used is shown when you run &lt;code&gt;kotlinc -help&lt;/code&gt;.</source>
          <target state="translated">使用可能な引数の完全なリストは、 &lt;code&gt;kotlinc -help&lt;/code&gt; を実行すると表示されます。</target>
        </trans-unit>
        <trans-unit id="02b69f589be9184eaa6e08d9fb77b12e7b2d6da2" translate="yes" xml:space="preserve">
          <source>The full list of supported use-site targets is:</source>
          <target state="translated">サポートされているユースサイトのターゲットの完全なリストです。</target>
        </trans-unit>
        <trans-unit id="58018a7c2f7cccce2f2841705c78d55576a7e56f" translate="yes" xml:space="preserve">
          <source>The full syntactic form of lambda expressions is as follows:</source>
          <target state="translated">ラムダ式の完全な構文形式は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="1347221f9ac10fa3f9465e07c5ca87cc27e8a8e6" translate="yes" xml:space="preserve">
          <source>The full syntax for declaring a property is</source>
          <target state="translated">プロパティを宣言するための完全な構文は</target>
        </trans-unit>
        <trans-unit id="905c760b34a0beb7b5d4d319c2f007dd8ebd0fd3" translate="yes" xml:space="preserve">
          <source>The full syntax of a read-only property declaration differs from a mutable one in two ways: it starts with &lt;code&gt;val&lt;/code&gt; instead of &lt;code&gt;var&lt;/code&gt; and does not allow a setter:</source>
          <target state="translated">2つの方法で変更可能なものから、読み取り専用のプロパティ宣言が異なるの完全な構文：それはで始まる &lt;code&gt;val&lt;/code&gt; の代わりに &lt;code&gt;var&lt;/code&gt; とセッターを許可していません。</target>
        </trans-unit>
        <trans-unit id="776f7d695f882be224aebfaccabd52b1c0591bc5" translate="yes" xml:space="preserve">
          <source>The fully qualified dot-separated name of the class, or &lt;code&gt;null&lt;/code&gt; if the class is local or a class of an anonymous object.</source>
          <target state="translated">クラスの完全修飾ドット区切り名。クラスがローカルまたは匿名オブジェクトのクラスの場合は &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0ee52f844a0963f3db9f0478ccd20b13916c48b9" translate="yes" xml:space="preserve">
          <source>The fully qualified dot-separated name of the class, or &lt;code&gt;null&lt;/code&gt; if the class is local or it is an anonymous object literal.</source>
          <target state="translated">ドットで区切られたクラスの完全修飾名。クラスがローカルの場合、または匿名オブジェクトリテラルの場合は &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f6c5b38e497b6843a07b1a8945d528e3c7606264" translate="yes" xml:space="preserve">
          <source>The function &lt;a href=&quot;-list#kotlin.collections%24List(kotlin.Int,%20kotlin.Function1((kotlin.Int,%20kotlin.collections.List.T)))/init&quot;&gt;init&lt;/a&gt; is called for each list element sequentially starting from the first one. It should return the value for a list element given its index.</source>
          <target state="translated">関数&lt;a href=&quot;-list#kotlin.collections%24List(kotlin.Int,%20kotlin.Function1((kotlin.Int,%20kotlin.collections.List.T)))/init&quot;&gt;init&lt;/a&gt;は、リスト要素ごとに最初の要素から順番に呼び出されます。インデックスが指定されたリスト要素の値を返す必要があります。</target>
        </trans-unit>
        <trans-unit id="7696926a08823163fe79a297a106aabaf3f3d399" translate="yes" xml:space="preserve">
          <source>The function &lt;a href=&quot;-mutable-list#kotlin.collections%24MutableList(kotlin.Int,%20kotlin.Function1((kotlin.Int,%20kotlin.collections.MutableList.T)))/init&quot;&gt;init&lt;/a&gt; is called for each list element sequentially starting from the first one. It should return the value for a list element given its index.</source>
          <target state="translated">関数&lt;a href=&quot;-mutable-list#kotlin.collections%24MutableList(kotlin.Int,%20kotlin.Function1((kotlin.Int,%20kotlin.collections.MutableList.T)))/init&quot;&gt;init&lt;/a&gt;は、リスト要素ごとに最初の要素から順番に呼び出されます。インデックスが指定されたリスト要素の値を返す必要があります。</target>
        </trans-unit>
        <trans-unit id="ed3c35965fc33462a41df8d6c5d69d9f13434071" translate="yes" xml:space="preserve">
          <source>The function &lt;a href=&quot;-u-byte-array#kotlin%24UByteArray(kotlin.Int,%20kotlin.Function1((kotlin.Int,%20kotlin.UByte)))/init&quot;&gt;init&lt;/a&gt; is called for each array element sequentially starting from the first one. It should return the value for an array element given its index.</source>
          <target state="translated">関数&lt;a href=&quot;-u-byte-array#kotlin%24UByteArray(kotlin.Int,%20kotlin.Function1((kotlin.Int,%20kotlin.UByte)))/init&quot;&gt;init&lt;/a&gt;は、最初の配列要素から順番に配列要素ごとに呼び出されます。インデックスが指定された配列要素の値を返す必要があります。</target>
        </trans-unit>
        <trans-unit id="acfbb507b912e298abe7a785c884c806da178f93" translate="yes" xml:space="preserve">
          <source>The function &lt;a href=&quot;-u-int-array#kotlin%24UIntArray(kotlin.Int,%20kotlin.Function1((kotlin.Int,%20kotlin.UInt)))/init&quot;&gt;init&lt;/a&gt; is called for each array element sequentially starting from the first one. It should return the value for an array element given its index.</source>
          <target state="translated">関数&lt;a href=&quot;-u-int-array#kotlin%24UIntArray(kotlin.Int,%20kotlin.Function1((kotlin.Int,%20kotlin.UInt)))/init&quot;&gt;init&lt;/a&gt;は、最初の配列要素から順番に配列要素ごとに呼び出されます。インデックスが指定された配列要素の値を返す必要があります。</target>
        </trans-unit>
        <trans-unit id="804f600305f25777086b4066f40ae2670855676b" translate="yes" xml:space="preserve">
          <source>The function &lt;a href=&quot;-u-long-array#kotlin%24ULongArray(kotlin.Int,%20kotlin.Function1((kotlin.Int,%20kotlin.ULong)))/init&quot;&gt;init&lt;/a&gt; is called for each array element sequentially starting from the first one. It should return the value for an array element given its index.</source>
          <target state="translated">関数&lt;a href=&quot;-u-long-array#kotlin%24ULongArray(kotlin.Int,%20kotlin.Function1((kotlin.Int,%20kotlin.ULong)))/init&quot;&gt;init&lt;/a&gt;は、最初の配列要素から順番に配列要素ごとに呼び出されます。インデックスが指定された配列要素の値を返す必要があります。</target>
        </trans-unit>
        <trans-unit id="98c90b068891a2e0a90f241b535756a6f3e22982" translate="yes" xml:space="preserve">
          <source>The function &lt;a href=&quot;-u-short-array#kotlin%24UShortArray(kotlin.Int,%20kotlin.Function1((kotlin.Int,%20kotlin.UShort)))/init&quot;&gt;init&lt;/a&gt; is called for each array element sequentially starting from the first one. It should return the value for an array element given its index.</source>
          <target state="translated">関数&lt;a href=&quot;-u-short-array#kotlin%24UShortArray(kotlin.Int,%20kotlin.Function1((kotlin.Int,%20kotlin.UShort)))/init&quot;&gt;init&lt;/a&gt;は、最初の配列要素から順番に配列要素ごとに呼び出されます。インデックスが指定された配列要素の値を返す必要があります。</target>
        </trans-unit>
        <trans-unit id="39a40c87789f813fc496dc5468cc91805583814e" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;libnative_symbols&lt;/code&gt; allows us to open the way from the native code to the Kotlin/Native library. This is the entry point we use. The library name is used as a prefix for the function name.</source>
          <target state="translated">関数 &lt;code&gt;libnative_symbols&lt;/code&gt; を使用すると、ネイティブコードからKotlin / Nativeライブラリへの道を開くことができます。これは、私たちが使用するエントリポイントです。ライブラリ名は、関数名の接頭辞として使用されます。</target>
        </trans-unit>
        <trans-unit id="ecf68a80d3d421d1a3dac0bf6a7b99795040c5e0" translate="yes" xml:space="preserve">
          <source>The function body is delimited by curly braces - indentation is generally not significant in Kotlin, but you should of course indent your code properly for the benefit of human readers.</source>
          <target state="translated">関数本体は中括弧で区切られています。Kotlinではインデントは一般的に重要ではありませんが、人間の読者のためにコードを適切にインデントする必要があります。</target>
        </trans-unit>
        <trans-unit id="892b57cbc7486be03e2291de2837204f537e592b" translate="yes" xml:space="preserve">
          <source>The function does upgrade from read to write lock if needed, but this upgrade is not atomic as such upgrade is not supported by &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/ReentrantReadWriteLock.html&quot;&gt;ReentrantReadWriteLock&lt;/a&gt;. In order to do such upgrade this function first releases all read locks held by this thread, then acquires write lock, and after releasing it acquires read locks back again.</source>
          <target state="translated">この関数は、必要に応じて読み取りから書き込みロックにアップグレードしますが、このアップグレードは&lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/ReentrantReadWriteLock.html&quot;&gt;ReentrantReadWriteLockで&lt;/a&gt;サポートされていないため、アトミックではありません。このようなアップグレードを行うために、この関数は最初にこのスレッドによって保持されているすべての読み取りロックを解放し、次に書き込みロックを取得します。解放後、読み取りロックを再度取得します。</target>
        </trans-unit>
        <trans-unit id="41eab38f14ba2d1160f8a85b6cc897eb549e21ad" translate="yes" xml:space="preserve">
          <source>The function does upgrade from read to write lock if needed, but this upgrade is not atomic as such upgrade is not supported by &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/ReentrantReadWriteLock.html&quot;&gt;ReentrantReadWriteLock&lt;/a&gt;. In order to do such upgrade this function first releases all read locks held by this thread, then acquires write lock, and after releasing it acquires read locks back again.</source>
          <target state="translated">この関数は、必要に応じて読み取りロックから書き込みロックにアップグレードしますが、このようなアップグレードは&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/ReentrantReadWriteLock.html&quot;&gt;ReentrantReadWriteLockで&lt;/a&gt;サポートされていないため、このアップグレードはアトミックではありません。このようなアップグレードを行うために、この関数は最初にこのスレッドによって保持されているすべての読み取りロックを解放し、次に書き込みロックを取得し、解放した後、再び読み取りロックを取得します。</target>
        </trans-unit>
        <trans-unit id="11c5bbd79a2512e469db0fde4da38bfd3abb594c" translate="yes" xml:space="preserve">
          <source>The function init is called for each array element sequentially starting from the first one. It should return the value for an array element given its index.</source>
          <target state="translated">関数 init は,最初の配列要素から順に各配列要素に対して呼び出されます.この関数はインデックスが与えられた配列要素の値を返します。</target>
        </trans-unit>
        <trans-unit id="47e9d14611b3a1f9114880a2ff853190d9e97c10" translate="yes" xml:space="preserve">
          <source>The function signature remains exactly the same. The only difference is &lt;code&gt;suspend&lt;/code&gt; being added to it. The return type however is the type we want to be returned.</source>
          <target state="translated">関数のシグネチャはまったく同じです。唯一の違いは、 &lt;code&gt;suspend&lt;/code&gt; が追加されることです。ただし、戻り値の型は、返される型です。</target>
        </trans-unit>
        <trans-unit id="f6772ad37911fb29515e5ecad2f466bed6bdb7cd" translate="yes" xml:space="preserve">
          <source>The function type notation can optionally include names for the function parameters: &lt;code&gt;(x: Int, y: Int) -&amp;gt; Point&lt;/code&gt;. These names can be used for documenting the meaning of the parameters.</source>
          <target state="translated">関数タイプ表記には、オプションで関数パラメーターの名前を含めることができます： &lt;code&gt;(x: Int, y: Int) -&amp;gt; Point&lt;/code&gt; 。これらの名前は、パラメーターの意味を文書化するために使用できます。</target>
        </trans-unit>
        <trans-unit id="5f62a960bb01edb991f086fcecfa3233b3994fce" translate="yes" xml:space="preserve">
          <source>The functions include trigonometric, hyperbolic, exponentiation and power, logarithmic, rounding, sign and absolute value.</source>
          <target state="translated">関数は三角関数、双曲線関数、指数と乗数、対数、丸め、符号、絶対値などがあります。</target>
        </trans-unit>
        <trans-unit id="332c4fb906dbcda140f018d0de201e8c1ce3d30d" translate="yes" xml:space="preserve">
          <source>The general rule is: when a type parameter &lt;code&gt;T&lt;/code&gt; of a class &lt;code&gt;C&lt;/code&gt; is declared &lt;strong&gt;out&lt;/strong&gt;, it may occur only in &lt;strong&gt;out&lt;/strong&gt;-position in the members of &lt;code&gt;C&lt;/code&gt;, but in return &lt;code&gt;C&amp;lt;Base&amp;gt;&lt;/code&gt; can safely be a supertype of &lt;code&gt;C&amp;lt;Derived&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">一般的な規則は次のとおりです。クラス &lt;code&gt;C&lt;/code&gt; の型パラメーター &lt;code&gt;T&lt;/code&gt; が&lt;strong&gt;out&lt;/strong&gt;として宣言さ&lt;strong&gt;れて&lt;/strong&gt;いる場合、それは &lt;code&gt;C&lt;/code&gt; のメンバーの&lt;strong&gt;out&lt;/strong&gt;位置でのみ発生する可能性がありますが、代わりに &lt;code&gt;C&amp;lt;Base&amp;gt;&lt;/code&gt; は &lt;code&gt;C&amp;lt;Derived&amp;gt;&lt;/code&gt; スーパータイプにすることができます。&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="47a803852f9a44b2a9ede00ebab7d2f5f19ab5c5" translate="yes" xml:space="preserve">
          <source>The general rule:</source>
          <target state="translated">一般的なルールです。</target>
        </trans-unit>
        <trans-unit id="39d2229c00faf1c133ef862b873c7364c63bd099" translate="yes" xml:space="preserve">
          <source>The general solution that works both for threads and for coroutines is to use a thread-safe (aka synchronized, linearizable, or atomic) data structure that provides all the necessarily synchronization for the corresponding operations that needs to be performed on a shared state. In the case of a simple counter we can use &lt;code&gt;AtomicInteger&lt;/code&gt; class which has atomic &lt;code&gt;incrementAndGet&lt;/code&gt; operations:</source>
          <target state="translated">スレッドとコルーチンの両方で機能する一般的な解決策は、共有状態で実行する必要がある対応する操作に必要なすべての同期を提供するスレッドセーフ（同期、線形化、またはアトミック）データ構造を使用することです。単純なカウンターの場合、アトミックな &lt;code&gt;incrementAndGet&lt;/code&gt; 操作を持つ &lt;code&gt;AtomicInteger&lt;/code&gt; クラスを使用できます。</target>
        </trans-unit>
        <trans-unit id="4e700b89372f9cc694759aa68e2252618aa967c7" translate="yes" xml:space="preserve">
          <source>The general solution that works both for threads and for coroutines is to use a thread-safe (aka synchronized, linearizable, or atomic) data structure that provides all the necessary synchronization for the corresponding operations that needs to be performed on a shared state. In the case of a simple counter we can use &lt;code&gt;AtomicInteger&lt;/code&gt; class which has atomic &lt;code&gt;incrementAndGet&lt;/code&gt; operations:</source>
          <target state="translated">スレッドとコルーチンの両方で機能する一般的なソリューションは、共有状態で実行する必要のある対応する操作に必要なすべての同期を提供するスレッドセーフ（同期、線形化可能、またはアトミック）データ構造を使用することです。単純なカウンターの場合、アトミック &lt;code&gt;incrementAndGet&lt;/code&gt; 操作を持つ &lt;code&gt;AtomicInteger&lt;/code&gt; クラスを使用できます。</target>
        </trans-unit>
        <trans-unit id="fe194a34c4e181902ef2477861ca1a56a0c14e72" translate="yes" xml:space="preserve">
          <source>The generated constructor is synthetic so it can&amp;rsquo;t be directly called from Java or Kotlin, but it can be called using reflection.</source>
          <target state="translated">生成されたコンストラクターは合成であるため、JavaまたはKotlinから直接呼び出すことはできませんが、リフレクションを使用して呼び出すことはできます。</target>
        </trans-unit>
        <trans-unit id="c09ea74ea1b03fd685bbe5f94354a8374db022b3" translate="yes" xml:space="preserve">
          <source>The getter of this property, used to obtain the value of the property.</source>
          <target state="translated">このプロパティの値を取得するために使用される、このプロパティのゲッター。</target>
        </trans-unit>
        <trans-unit id="5599725590a9016e21ca4310f17eb7b2b01a0483" translate="yes" xml:space="preserve">
          <source>The globs are applied to the header paths relative to the appropriate include path elements, e.g. &lt;code&gt;time.h&lt;/code&gt; or &lt;code&gt;curl/curl.h&lt;/code&gt;. So if the library is usually included with &lt;code&gt;#include &amp;lt;SomeLbrary/Header.h&amp;gt;&lt;/code&gt;, then it would probably be correct to filter headers with</source>
          <target state="translated">グロブは、適切なインクルードパス要素（たとえば、 &lt;code&gt;time.h&lt;/code&gt; または &lt;code&gt;curl/curl.h&lt;/code&gt; )に関連するヘッダーパスに適用されます。そのため、ライブラリが通常 &lt;code&gt;#include &amp;lt;SomeLbrary/Header.h&amp;gt;&lt;/code&gt; に含まれている場合は、ヘッダーをフィルターするのがおそらく正しいでしょう。</target>
        </trans-unit>
        <trans-unit id="a57ffec5971f7b3f89d004ca095f66feb86eb296" translate="yes" xml:space="preserve">
          <source>The goal of the tutorial is to demonstrate Kotlin code re-use between Android and iOS. Let's start by manually creating the &lt;code&gt;SharedCode&lt;/code&gt; sub-project in our Gradle project. The source code from the &lt;code&gt;SharedCode&lt;/code&gt; project will be shared between platforms. We will create several new files in our project to implement that.</source>
          <target state="translated">このチュートリアルの目的は、AndroidとiOS間でのKotlinコードの再利用を示すことです。まず、Gradleプロジェクトで &lt;code&gt;SharedCode&lt;/code&gt; サブプロジェクトを手動で作成してみましょう。 &lt;code&gt;SharedCode&lt;/code&gt; プロジェクトのソースコードは、プラットフォーム間で共有されます。プロジェクトにいくつかの新しいファイルを作成して、それを実装します。</target>
        </trans-unit>
        <trans-unit id="068a964193217c327091688b8b7de38e4eb4f3e1" translate="yes" xml:space="preserve">
          <source>The header files merely contain function declarations for functionality that is defined at runtime. For instance, we could define a &lt;code&gt;jQuery&lt;/code&gt; function like so</source>
          <target state="translated">ヘッダーファイルには、実行時に定義される機能の関数宣言のみが含まれています。たとえば、次のように &lt;code&gt;jQuery&lt;/code&gt; 関数を定義できます。</target>
        </trans-unit>
        <trans-unit id="6ce2e166fe215303244aa3044be29e2844cbf2bc" translate="yes" xml:space="preserve">
          <source>The iOS simulator requires a framework compiled for the &lt;code&gt;ios_x64&lt;/code&gt; target, the &lt;code&gt;iOS_sim&lt;/code&gt; folder in our case.</source>
          <target state="translated">iOSシミュレーターには、 &lt;code&gt;ios_x64&lt;/code&gt; ターゲット用にコンパイルされたフレームワーク（この場合は &lt;code&gt;iOS_sim&lt;/code&gt; フォルダー）が必要です。</target>
        </trans-unit>
        <trans-unit id="31859b6cbcfb9892316b62d967e1f5ae2235d5ef" translate="yes" xml:space="preserve">
          <source>The idea behind Rx is to move towards what's called &lt;code&gt;observable streams&lt;/code&gt; where by we now think of data as streams (infinite amounts of data) and these streams can be observed. In practical terms, Rx is simply the &lt;a href=&quot;https://en.wikipedia.org/wiki/Observer_pattern&quot;&gt;Observer Pattern&lt;/a&gt; with a series of extensions which allow us to operate on the data.</source>
          <target state="translated">Rxの背後にある考え方は、監視 &lt;code&gt;observable streams&lt;/code&gt; と呼ばれるものに移動することです。これにより、データをストリーム（無限量のデータ）と見なし、これらのストリームを監視できるようになります。実際には、Rxは単にデータを操作できるようにする一連の拡張機能を備えた&lt;a href=&quot;https://en.wikipedia.org/wiki/Observer_pattern&quot;&gt;オブザーバーパターン&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="a752acd40500d4af1aa6897c4527c1276e603455" translate="yes" xml:space="preserve">
          <source>The idea behind futures or promises (there are also other terms these can be referred to depending on language/platform), is that when we make a call, we're promised that at some point it will return with an object called a Promise, which can then be operated on.</source>
          <target state="translated">futures や promises (言語やプラットフォームによっては他の用語もあります)の背後にある考え方は、呼び出しをするときに、ある時点で Promise と呼ばれるオブジェクトが戻ってくることを約束しているというもので、それを操作することができます。</target>
        </trans-unit>
        <trans-unit id="0ec5a5ec78c5bbba1d9a9593b45aa36ac04ad75c" translate="yes" xml:space="preserve">
          <source>The idea is to make every platform show similar text: &lt;code&gt;Kotlin Rocks on Android&lt;/code&gt; and &lt;code&gt;Kotlin Rocks on iOS&lt;/code&gt;, depending on the platform. We will reuse the way we generate the message. Let's create the file (and missing directories) &lt;code&gt;SharedCode/src/commonMain/kotlin/common.kt&lt;/code&gt; with the following contents under the project root directory</source>
          <target state="translated">アイデアは、すべてのプラットフォームを作ることであるようなテキストを示しています。 &lt;code&gt;Kotlin Rocks on Android&lt;/code&gt; と &lt;code&gt;Kotlin Rocks on iOS&lt;/code&gt; プラットフォームに応じて、。メッセージの生成方法を再利用します。プロジェクトのルートディレクトリの下に次の内容でファイル（および欠落しているディレクトリ） &lt;code&gt;SharedCode/src/commonMain/kotlin/common.kt&lt;/code&gt; を作成してみましょう</target>
        </trans-unit>
        <trans-unit id="82fd6cd237e491604315526b684dbfedf391a053" translate="yes" xml:space="preserve">
          <source>The implementation of the &lt;a href=&quot;-mutable-set/index#kotlin.collections.MutableSet&quot;&gt;MutableSet&lt;/a&gt; interface, backed by a &lt;a href=&quot;-hash-map/index#kotlin.collections.HashMap&quot;&gt;HashMap&lt;/a&gt; instance.</source>
          <target state="translated">&lt;a href=&quot;-hash-map/index#kotlin.collections.HashMap&quot;&gt;HashMap&lt;/a&gt;インスタンスに支えられた&lt;a href=&quot;-mutable-set/index#kotlin.collections.MutableSet&quot;&gt;MutableSet&lt;/a&gt;インターフェースの実装。</target>
        </trans-unit>
        <trans-unit id="6ba732549bab36d600a33b057cb1445e14d3cdfc" translate="yes" xml:space="preserve">
          <source>The implementation of the &lt;a href=&quot;-mutable-set/index#kotlin.collections.MutableSet&quot;&gt;MutableSet&lt;/a&gt; interface, backed by a &lt;a href=&quot;-linked-hash-map/index#kotlin.collections.LinkedHashMap&quot;&gt;LinkedHashMap&lt;/a&gt; instance.</source>
          <target state="translated">&lt;a href=&quot;-linked-hash-map/index#kotlin.collections.LinkedHashMap&quot;&gt;LinkedHashMap&lt;/a&gt;インスタンスによってサポートされる&lt;a href=&quot;-mutable-set/index#kotlin.collections.MutableSet&quot;&gt;MutableSet&lt;/a&gt;インターフェースの実装。</target>
        </trans-unit>
        <trans-unit id="e80ec37934bbec50821c43bd38cce1238a634038" translate="yes" xml:space="preserve">
          <source>The implementation of the &lt;a href=&quot;../-mutable-set/index#kotlin.collections.MutableSet&quot;&gt;MutableSet&lt;/a&gt; interface, backed by a &lt;a href=&quot;../-hash-map/index#kotlin.collections.HashMap&quot;&gt;HashMap&lt;/a&gt; instance.</source>
          <target state="translated">&lt;a href=&quot;../-hash-map/index#kotlin.collections.HashMap&quot;&gt;HashMap&lt;/a&gt;インスタンスに支えられた&lt;a href=&quot;../-mutable-set/index#kotlin.collections.MutableSet&quot;&gt;MutableSet&lt;/a&gt;インターフェースの実装。</target>
        </trans-unit>
        <trans-unit id="9ab2ec2a4f2966a3555f9fce9c9ee7c196c5adc8" translate="yes" xml:space="preserve">
          <source>The implementation of the &lt;a href=&quot;../-mutable-set/index#kotlin.collections.MutableSet&quot;&gt;MutableSet&lt;/a&gt; interface, backed by a &lt;a href=&quot;../-linked-hash-map/index#kotlin.collections.LinkedHashMap&quot;&gt;LinkedHashMap&lt;/a&gt; instance.</source>
          <target state="translated">&lt;a href=&quot;../-linked-hash-map/index#kotlin.collections.LinkedHashMap&quot;&gt;LinkedHashMap&lt;/a&gt;インスタンスによってサポートされる&lt;a href=&quot;../-mutable-set/index#kotlin.collections.MutableSet&quot;&gt;MutableSet&lt;/a&gt;インターフェースの実装。</target>
        </trans-unit>
        <trans-unit id="41ae2cd6b24e4bafa0efb17c582aa2f3dbd61174" translate="yes" xml:space="preserve">
          <source>The implementation of the &lt;a href=&quot;../../kotlin.collections/-mutable-set/index#kotlin.collections.MutableSet&quot;&gt;MutableSet&lt;/a&gt; interface, backed by a &lt;a href=&quot;../../kotlin.collections/-hash-map/index#kotlin.collections.HashMap&quot;&gt;HashMap&lt;/a&gt; instance.</source>
          <target state="translated">&lt;a href=&quot;../../kotlin.collections/-hash-map/index#kotlin.collections.HashMap&quot;&gt;HashMap&lt;/a&gt;インスタンスに支えられた&lt;a href=&quot;../../kotlin.collections/-mutable-set/index#kotlin.collections.MutableSet&quot;&gt;MutableSet&lt;/a&gt;インターフェースの実装。</target>
        </trans-unit>
        <trans-unit id="b29deea1bb921913df3a5fadba5cd74a8f4acd5e" translate="yes" xml:space="preserve">
          <source>The implementation of the &lt;a href=&quot;../../kotlin.collections/-mutable-set/index#kotlin.collections.MutableSet&quot;&gt;MutableSet&lt;/a&gt; interface, backed by a &lt;a href=&quot;../../kotlin.collections/-linked-hash-map/index#kotlin.collections.LinkedHashMap&quot;&gt;LinkedHashMap&lt;/a&gt; instance.</source>
          <target state="translated">&lt;a href=&quot;../../kotlin.collections/-linked-hash-map/index#kotlin.collections.LinkedHashMap&quot;&gt;LinkedHashMap&lt;/a&gt;インスタンスによってサポートされる&lt;a href=&quot;../../kotlin.collections/-mutable-set/index#kotlin.collections.MutableSet&quot;&gt;MutableSet&lt;/a&gt;インターフェースの実装。</target>
        </trans-unit>
        <trans-unit id="a6579034caa6bf530c44ba48e1557ccf3e4b94a3" translate="yes" xml:space="preserve">
          <source>The implementation of the &lt;a href=&quot;index#kotlin.collections.MutableSet&quot;&gt;MutableSet&lt;/a&gt; interface, backed by a &lt;a href=&quot;../-hash-map/index#kotlin.collections.HashMap&quot;&gt;HashMap&lt;/a&gt; instance.</source>
          <target state="translated">&lt;a href=&quot;../-hash-map/index#kotlin.collections.HashMap&quot;&gt;HashMap&lt;/a&gt;インスタンスに支えられた&lt;a href=&quot;index#kotlin.collections.MutableSet&quot;&gt;MutableSet&lt;/a&gt;インターフェースの実装。</target>
        </trans-unit>
        <trans-unit id="a009a3a444f03e70f059b3c04a3a49cc825d720d" translate="yes" xml:space="preserve">
          <source>The implementation of the &lt;a href=&quot;index#kotlin.collections.MutableSet&quot;&gt;MutableSet&lt;/a&gt; interface, backed by a &lt;a href=&quot;../-linked-hash-map/index#kotlin.collections.LinkedHashMap&quot;&gt;LinkedHashMap&lt;/a&gt; instance.</source>
          <target state="translated">&lt;a href=&quot;../-linked-hash-map/index#kotlin.collections.LinkedHashMap&quot;&gt;LinkedHashMap&lt;/a&gt;インスタンスによってサポートされる&lt;a href=&quot;index#kotlin.collections.MutableSet&quot;&gt;MutableSet&lt;/a&gt;インターフェースの実装。</target>
        </trans-unit>
        <trans-unit id="fa50aaadf0215e23e542746cdfa2658460833341" translate="yes" xml:space="preserve">
          <source>The implementor is required to implement &lt;a href=&quot;../-map/entries#kotlin.collections.Map%24entries&quot;&gt;entries&lt;/a&gt; property, which should return read-only set of map entries.</source>
          <target state="translated">実装者は&lt;a href=&quot;../-map/entries#kotlin.collections.Map%24entries&quot;&gt;エントリ&lt;/a&gt;プロパティを実装する必要があります。これは、マップエントリの読み取り専用のセットを返す必要があります。</target>
        </trans-unit>
        <trans-unit id="0d9844010488cdb05175b5fbda28866913c16552" translate="yes" xml:space="preserve">
          <source>The implementor is required to implement &lt;a href=&quot;../-mutable-map/entries#kotlin.collections.MutableMap%24entries&quot;&gt;entries&lt;/a&gt; property, which should return mutable set of map entries, and &lt;a href=&quot;put#kotlin.collections.AbstractMutableMap%24put%28kotlin.collections.AbstractMutableMap.K%2C+kotlin.collections.AbstractMutableMap.V%29&quot;&gt;put&lt;/a&gt; function.</source>
          <target state="translated">実装者は、マップエントリの変更可能なセットを返し、関数を&lt;a href=&quot;put#kotlin.collections.AbstractMutableMap%24put%28kotlin.collections.AbstractMutableMap.K%2C+kotlin.collections.AbstractMutableMap.V%29&quot;&gt;置く&lt;/a&gt;、&lt;a href=&quot;../-mutable-map/entries#kotlin.collections.MutableMap%24entries&quot;&gt;entries&lt;/a&gt;プロパティを実装する必要があります。</target>
        </trans-unit>
        <trans-unit id="4c2bcd3066d4911e1651a3eb4e73833cb38dc376" translate="yes" xml:space="preserve">
          <source>The implementor is required to implement &lt;a href=&quot;../-mutable-map/entries#kotlin.collections.MutableMap%24entries&quot;&gt;entries&lt;/a&gt; property, which should return mutable set of map entries, and &lt;a href=&quot;put#kotlin.collections.AbstractMutableMap%24put(kotlin.collections.AbstractMutableMap.K,%20kotlin.collections.AbstractMutableMap.V)&quot;&gt;put&lt;/a&gt; function.</source>
          <target state="translated">実装者は、マップエントリの可変セットを返す&lt;a href=&quot;../-mutable-map/entries#kotlin.collections.MutableMap%24entries&quot;&gt;entries&lt;/a&gt;プロパティを実装し、関数を&lt;a href=&quot;put#kotlin.collections.AbstractMutableMap%24put(kotlin.collections.AbstractMutableMap.K,%20kotlin.collections.AbstractMutableMap.V)&quot;&gt;配置する必要があり&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="b072b8461d749216f126589f253d2136dcee5a49" translate="yes" xml:space="preserve">
          <source>The implementor is required to implement &lt;a href=&quot;entries&quot;&gt;entries&lt;/a&gt; property, which should return mutable set of map entries, and &lt;a href=&quot;put#kotlin.collections.AbstractMutableMap%24put%28kotlin.collections.AbstractMutableMap.K%2C+kotlin.collections.AbstractMutableMap.V%29&quot;&gt;put&lt;/a&gt; function.</source>
          <target state="translated">実装者は、マップエントリの変更可能なセットを返し、関数を&lt;a href=&quot;put#kotlin.collections.AbstractMutableMap%24put%28kotlin.collections.AbstractMutableMap.K%2C+kotlin.collections.AbstractMutableMap.V%29&quot;&gt;置く&lt;/a&gt;、&lt;a href=&quot;entries&quot;&gt;entries&lt;/a&gt;プロパティを実装する必要があります。</target>
        </trans-unit>
        <trans-unit id="de6f180abcaad3c2e2c4cd19c5f847e641f85c21" translate="yes" xml:space="preserve">
          <source>The implementor is required to implement &lt;a href=&quot;entries&quot;&gt;entries&lt;/a&gt; property, which should return mutable set of map entries, and &lt;a href=&quot;put#kotlin.collections.AbstractMutableMap%24put(kotlin.collections.AbstractMutableMap.K,%20kotlin.collections.AbstractMutableMap.V)&quot;&gt;put&lt;/a&gt; function.</source>
          <target state="translated">実装者は、マップエントリの可変セットを返す&lt;a href=&quot;entries&quot;&gt;entries&lt;/a&gt;プロパティを実装し、関数を&lt;a href=&quot;put#kotlin.collections.AbstractMutableMap%24put(kotlin.collections.AbstractMutableMap.K,%20kotlin.collections.AbstractMutableMap.V)&quot;&gt;配置する必要があり&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="b4d84ada0a069eb9728359000c31d5443cb7fe8c" translate="yes" xml:space="preserve">
          <source>The in-place sorting functions have similar names to the functions that apply to read-only lists, but without the &lt;code&gt;ed/d&lt;/code&gt; suffix:</source>
          <target state="translated">インプレースソート関数の名前は、読み取り専用リストに適用される関数と似ていますが、 &lt;code&gt;ed/d&lt;/code&gt; サフィックスはありません。</target>
        </trans-unit>
        <trans-unit id="ad88781015ab91e944a6d24ed6740d21e1a613c0" translate="yes" xml:space="preserve">
          <source>The indentation in front of the accessors is due to convention; like elsewhere in Kotlin, it has no syntactic significance. The compiler can tell which accessors belong to which properties because the only legal place for an accessor is immediately after the property declaration (and there can be at most one getter and one setter) - so you can't split the property declaration and the accessor declarations. However, the order of the accessors doesn't matter.</source>
          <target state="translated">アクセサの前のインデントは慣習によるもので、Kotlinの他の場所と同様、構文的には意味がありません。コンパイラはどのアクセサがどのプロパティに属しているかを知ることができます。なぜなら、アクセサが適法に配置されるのはプロパティ宣言の直後だけだからです(そして、ゲッターとセッターは最大でも1つしかありません)。しかし、アクセサの順番は問題ではありません。</target>
        </trans-unit>
        <trans-unit id="a438c4c204700f052b62784ad094f3d42692c3e5" translate="yes" xml:space="preserve">
          <source>The inheritors are used in &lt;a href=&quot;-contract-builder/index&quot;&gt;ContractBuilder&lt;/a&gt; to describe the contract of a function.</source>
          <target state="translated">継承者は、関数の&lt;a href=&quot;-contract-builder/index&quot;&gt;コントラクト&lt;/a&gt;を記述するためにContractBuilderで使用されます。</target>
        </trans-unit>
        <trans-unit id="927c0a69730a98787dc84c53359365aef174d24b" translate="yes" xml:space="preserve">
          <source>The initializer, getter and setter are optional. Property type is optional if it can be inferred from the initializer (or from the getter return type, as shown below).</source>
          <target state="translated">イニシャライザ、ゲッター、セッターはオプションです。プロパティの型は、イニシャライザ(または以下のようにゲッターの戻り値の型)から推測できる場合はオプションです。</target>
        </trans-unit>
        <trans-unit id="df4b9318a341c1f296940189b67832418073c297" translate="yes" xml:space="preserve">
          <source>The inserted characters go in same order as in the &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.CharArray)/value&quot;&gt;value&lt;/a&gt; character array, starting at &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.CharArray)/index&quot;&gt;index&lt;/a&gt;.</source>
          <target state="translated">挿入された文字は、&lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.CharArray)/index&quot;&gt;インデックス&lt;/a&gt;から始まる&lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.CharArray)/value&quot;&gt;値の&lt;/a&gt;文字配列と同じ順序になります。</target>
        </trans-unit>
        <trans-unit id="1d6b868449af039ece3f79e19a7f1bdef4bb1a01" translate="yes" xml:space="preserve">
          <source>The inserted characters go in the same order as in the &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.CharSequence?)/value&quot;&gt;value&lt;/a&gt; character sequence, starting at &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.CharSequence?)/index&quot;&gt;index&lt;/a&gt;.</source>
          <target state="translated">挿入された文字は、&lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.CharSequence?)/index&quot;&gt;インデックス&lt;/a&gt;から始まる&lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.CharSequence?)/value&quot;&gt;値の&lt;/a&gt;文字シーケンスと同じ順序になります。</target>
        </trans-unit>
        <trans-unit id="73ab217fa7b8d452fbb508f24860b5983aed819b" translate="yes" xml:space="preserve">
          <source>The insertion order is preserved by maintaining a doubly-linked list of all of its entries.</source>
          <target state="translated">挿入順は、すべてのエントリの二重リンクされたリストを維持することで保持されます。</target>
        </trans-unit>
        <trans-unit id="d2ac540734122ad9d9f148278a049a69e4049649" translate="yes" xml:space="preserve">
          <source>The instance of the object declaration, or &lt;code&gt;null&lt;/code&gt; if this class is not an object declaration.</source>
          <target state="translated">オブジェクト宣言のインスタンス。このクラスがオブジェクト宣言でない場合は &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4e1a88c47519272f4d061661530035978afeff04" translate="yes" xml:space="preserve">
          <source>The interoperability tool analyses C headers and produces a &quot;natural&quot; mapping of the types, functions, and constants into the Kotlin world. The generated stubs can be imported into an IDE for the purpose of code completion and navigation.</source>
          <target state="translated">この相互運用性ツールは、Cヘッダを解析し、型、関数、定数のKotlinワールドへの「自然な」マッピングを生成します。生成されたスタブは、コード補完やナビゲーションのために IDE にインポートすることができます。</target>
        </trans-unit>
        <trans-unit id="78163206f8e53ce50e1eec86f00b2814cc4b80d9" translate="yes" xml:space="preserve">
          <source>The kapt annotation processing tasks are &lt;a href=&quot;https://guides.gradle.org/using-build-cache/&quot;&gt;cached in Gradle&lt;/a&gt; by default. However, annotation processors run arbitrary code that may not necessarily transform the task inputs into the outputs, might access and modify the files that are not tracked by Gradle etc. If the annotation processors used in the build cannot be properly cached, it is possible to disable caching for kapt entirely by adding the following lines to the build script, in order to avoid false-positive cache hits for the kapt tasks:</source>
          <target state="translated">kaptアノテーション処理タスクは、デフォルト&lt;a href=&quot;https://guides.gradle.org/using-build-cache/&quot;&gt;でGradleにキャッシュさ&lt;/a&gt;れます。ただし、アノテーションプロセッサは、タスク入力を出力に変換するとは限らない任意のコードを実行し、Gradleなどによって追跡されないファイルにアクセスして変更する可能性があります。ビルドで使用されるアノテーションプロセッサを適切にキャッシュできない場合は、次のことが可能です。 kaptタスクの誤検知キャッシュヒットを回避するために、ビルドスクリプトに次の行を追加して、kaptのキャッシュを完全に無効にします。</target>
        </trans-unit>
        <trans-unit id="0c34ac28f0b47dc2a95569e5a72bbe09867d14d5" translate="yes" xml:space="preserve">
          <source>The kapt annotation processing tasks are not &lt;a href=&quot;https://guides.gradle.org/using-build-cache/&quot;&gt;cached in Gradle&lt;/a&gt; by default. Annotation processors run arbitrary code that may not necessarily transform the task inputs into the outputs, might access and modify the files that are not tracked by Gradle etc. To enable caching for kapt anyway, add the following lines to the build script:</source>
          <target state="translated">kaptアノテーション処理タスクは、デフォルト&lt;a href=&quot;https://guides.gradle.org/using-build-cache/&quot;&gt;ではGradleにキャッシュされ&lt;/a&gt;ません。注釈プロセッサは任意のコードを実行しますが、必ずしもタスクの入力を出力に変換する必要はなく、Gradleなどによって追跡されないファイルにアクセスして変更する可能性があります。kaptのキャッシュを有効にするには、ビルドスクリプトに次の行を追加します。</target>
        </trans-unit>
        <trans-unit id="0d265db62daefe24281a53daa642fa0260c64977" translate="yes" xml:space="preserve">
          <source>The key benefit of using sealed classes comes into play when you use them in a &lt;a href=&quot;control-flow#when-expression&quot;&gt;&lt;code&gt;when&lt;/code&gt; expression&lt;/a&gt;. If it's possible to verify that the statement covers all cases, you don't need to add an &lt;code&gt;else&lt;/code&gt; clause to the statement. However, this works only if you use &lt;code&gt;when&lt;/code&gt; as an expression (using the result) and not as a statement.</source>
          <target state="translated">&lt;a href=&quot;control-flow#when-expression&quot;&gt; &lt;code&gt;when&lt;/code&gt; 式&lt;/a&gt;で使用する場合、シールクラスを使用する主な利点が発揮されます。ステートメントがすべてのケースをカバーしていることを確認できる場合は、ステートメントに &lt;code&gt;else&lt;/code&gt; 句を追加する必要はありません。ただし、これは、ステートメントとしてではなく、式として（結果を使用して）を使用する &lt;code&gt;when&lt;/code&gt; のみ機能します。</target>
        </trans-unit>
        <trans-unit id="60878e19d1626a7113513294279d9306ebdfd3af" translate="yes" xml:space="preserve">
          <source>The key differences to the old model are:</source>
          <target state="translated">旧モデルとの主な違いは</target>
        </trans-unit>
        <trans-unit id="ba83743a7b4886ce5d922ef71ed4bc654a53eba4" translate="yes" xml:space="preserve">
          <source>The key for each element is provided by the &lt;a href=&quot;-grouping/key-of&quot;&gt;Grouping.keyOf&lt;/a&gt; function.</source>
          <target state="translated">各要素のキーは、&lt;a href=&quot;-grouping/key-of&quot;&gt;Grouping.keyOf&lt;/a&gt;関数によって提供されます。</target>
        </trans-unit>
        <trans-unit id="c7780b4923a988af8ea0601856ae08a944187203" translate="yes" xml:space="preserve">
          <source>The key new feature in Kotlin 1.1 is &lt;em&gt;coroutines&lt;/em&gt;, bringing the support of &lt;code&gt;async&lt;/code&gt;/&lt;code&gt;await&lt;/code&gt;, &lt;code&gt;yield&lt;/code&gt; and similar programming patterns. The key feature of Kotlin's design is that the implementation of coroutine execution is part of the libraries, not the language, so you aren't bound to any specific programming paradigm or concurrency library.</source>
          <target state="translated">Kotlin 1.1の主要な新機能は&lt;em&gt;コルーチン&lt;/em&gt;です。これにより、 &lt;code&gt;async&lt;/code&gt; / &lt;code&gt;await&lt;/code&gt; 、 &lt;code&gt;yield&lt;/code&gt; 、および同様のプログラミングパターンがサポートされます。Kotlinの設計の重要な特徴は、コルーチン実行の実装が言語ではなくライブラリの一部であるため、特定のプログラミングパラダイムや同時実行ライブラリに縛られることはありません。</target>
        </trans-unit>
        <trans-unit id="255ddce16ff2d3386fde18744e92b0919a0c3dcd" translate="yes" xml:space="preserve">
          <source>The key that defines &lt;em&gt;the&lt;/em&gt; context interceptor.</source>
          <target state="translated">コンテキストインターセプターを定義&lt;em&gt;する&lt;/em&gt;キー。</target>
        </trans-unit>
        <trans-unit id="f78236335bddfda90f254cf18135e3e283c652aa" translate="yes" xml:space="preserve">
          <source>The key to understanding why this trick works is rather simple: if you can only &lt;strong&gt;take&lt;/strong&gt; items from a collection, then using a collection of &lt;code&gt;String&lt;/code&gt;s and reading &lt;code&gt;Object&lt;/code&gt;s from it is fine. Conversely, if you can only &lt;em&gt;put&lt;/em&gt; items into the collection, it's OK to take a collection of &lt;code&gt;Object&lt;/code&gt;s and put &lt;code&gt;String&lt;/code&gt;s into it: in Java we have &lt;code&gt;List&amp;lt;? super String&amp;gt;&lt;/code&gt; a &lt;strong&gt;supertype&lt;/strong&gt; of &lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">このトリックが機能する理由を理解するための鍵はかなり単純です。コレクションからのみアイテムを&lt;strong&gt;取得&lt;/strong&gt;できる場合は、 &lt;code&gt;String&lt;/code&gt; のコレクションを使用し、そこから &lt;code&gt;Object&lt;/code&gt; を読み取るのが適切です。逆に、アイテムをコレクションに&lt;em&gt;入れる&lt;/em&gt;ことしかできない場合は、 &lt;code&gt;Object&lt;/code&gt; のコレクションを取り、それに &lt;code&gt;String&lt;/code&gt; を入れることは問題あり &lt;code&gt;List&amp;lt;? super String&amp;gt;&lt;/code&gt; 。JavaではList &amp;lt;？スーパー文字列&amp;gt; &lt;strong&gt;スーパータイプ&lt;/strong&gt;の &lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e72d25f147746520f953f90cd2e72b99d7c03c99" translate="yes" xml:space="preserve">
          <source>The kind of JS module generated by the compiler</source>
          <target state="translated">コンパイラが生成するJSモジュールの種類</target>
        </trans-unit>
        <trans-unit id="d05fefa144a9bfaff0069cb495aef5fbbe9dc415" translate="yes" xml:space="preserve">
          <source>The language settings are checked for consistency between source sets depending on each other. Namely, if &lt;code&gt;foo&lt;/code&gt; depends on &lt;code&gt;bar&lt;/code&gt;:</source>
          <target state="translated">言語設定は、相互に依存するソースセット間の整合性がチェックされます。つまり、 &lt;code&gt;foo&lt;/code&gt; が &lt;code&gt;bar&lt;/code&gt; に依存している場合：</target>
        </trans-unit>
        <trans-unit id="7ae80735e57bee13b52032eac31a1a1787272a8f" translate="yes" xml:space="preserve">
          <source>The language settings for a source set can be specified as follows:</source>
          <target state="translated">ソースセットの言語設定は、以下のように指定することができます。</target>
        </trans-unit>
        <trans-unit id="fbaea25f697b924abdcdee8361823761cf7fe6eb" translate="yes" xml:space="preserve">
          <source>The language used to document Kotlin code (the equivalent of Java's JavaDoc) is called &lt;strong&gt;KDoc&lt;/strong&gt;. In its essence, KDoc combines JavaDoc's syntax for block tags (extended to support Kotlin's specific constructs) and Markdown for inline markup.</source>
          <target state="translated">Kotlinコードの文書化に使用される言語（JavaのJavaDocに相当）は&lt;strong&gt;KDoc&lt;/strong&gt;と呼ばれ&lt;strong&gt;ます&lt;/strong&gt;。基本的に、KDocはブロックタグ用のJavaDocの構文（Kotlinの特定の構成をサポートするように拡張されています）とインラインマークアップ用のMarkdownを組み合わせています。</target>
        </trans-unit>
        <trans-unit id="6bd524ff724eae23548f42d94d576b7a82d79f24" translate="yes" xml:space="preserve">
          <source>The last element in the progression.</source>
          <target state="translated">進行の最後の要素。</target>
        </trans-unit>
        <trans-unit id="5ac343906b9635efc6bc3ea707e0886b7e34f40a" translate="yes" xml:space="preserve">
          <source>The last element of the progression is calculated to find the maximum value not greater than the end value for a positive step or the minimum value not less than the end value for a negative step such that &lt;code&gt;(last - first) % step == 0&lt;/code&gt;.</source>
          <target state="translated">進行の最後の要素が計算されて、正のステップの終了値以下の最大値、または負のステップの終了値以上の最小値が &lt;code&gt;(last - first) % step == 0&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="01b3b5a6efe68e4716a891433d6bbbed0351ca8d" translate="yes" xml:space="preserve">
          <source>The last line is invoking the function itself and passing as argument &lt;code&gt;kotlin&lt;/code&gt;, which refers to the standard library. This can be obtained in one of two ways:</source>
          <target state="translated">最後の行は関数自体を呼び出し、標準ライブラリを参照する引数 &lt;code&gt;kotlin&lt;/code&gt; として渡します。これは、次の2つの方法のいずれかで取得できます。</target>
        </trans-unit>
        <trans-unit id="538d53f2bc70104b650857f7bb5ca32765c9300b" translate="yes" xml:space="preserve">
          <source>The last list in the resulting list may have less elements than the given &lt;a href=&quot;chunked#kotlin.collections%24chunked%28kotlin.collections.Iterable%28%28kotlin.collections.chunked.T%29%29%2C+kotlin.Int%29%2Fsize&quot;&gt;size&lt;/a&gt;.</source>
          <target state="translated">結果のリストの最後のリストは、指定&lt;a href=&quot;chunked#kotlin.collections%24chunked%28kotlin.collections.Iterable%28%28kotlin.collections.chunked.T%29%29%2C+kotlin.Int%29%2Fsize&quot;&gt;さ&lt;/a&gt;れたサイズよりも要素が少ない場合があります。</target>
        </trans-unit>
        <trans-unit id="ff4c16017113383cfa2553bc4b666ff8af31f35a" translate="yes" xml:space="preserve">
          <source>The last list in the resulting list may have less elements than the given &lt;a href=&quot;chunked#kotlin.collections%24chunked(kotlin.collections.Iterable((kotlin.collections.chunked.T)),%20kotlin.Int)/size&quot;&gt;size&lt;/a&gt;.</source>
          <target state="translated">結果のリストの最後のリストには、指定&lt;a href=&quot;chunked#kotlin.collections%24chunked(kotlin.collections.Iterable((kotlin.collections.chunked.T)),%20kotlin.Int)/size&quot;&gt;さ&lt;/a&gt;れたサイズよりも少ない要素が含まれている可能性があります。</target>
        </trans-unit>
        <trans-unit id="df81eba7c4b794145b48baa6539e2f2979a8d58f" translate="yes" xml:space="preserve">
          <source>The last list in the resulting sequence may have less elements than the given &lt;a href=&quot;chunked#kotlin.sequences%24chunked%28kotlin.sequences.Sequence%28%28kotlin.sequences.chunked.T%29%29%2C+kotlin.Int%29%2Fsize&quot;&gt;size&lt;/a&gt;.</source>
          <target state="translated">結果のシーケンスの最後のリストには、指定&lt;a href=&quot;chunked#kotlin.sequences%24chunked%28kotlin.sequences.Sequence%28%28kotlin.sequences.chunked.T%29%29%2C+kotlin.Int%29%2Fsize&quot;&gt;さ&lt;/a&gt;れたサイズよりも要素が少ない場合があります。</target>
        </trans-unit>
        <trans-unit id="e4ef2ba5891ebf7ffa1b88944ac0282efb5fecf2" translate="yes" xml:space="preserve">
          <source>The last list in the resulting sequence may have less elements than the given &lt;a href=&quot;chunked#kotlin.sequences%24chunked(kotlin.sequences.Sequence((kotlin.sequences.chunked.T)),%20kotlin.Int)/size&quot;&gt;size&lt;/a&gt;.</source>
          <target state="translated">結果のシーケンスの最後のリストには、指定&lt;a href=&quot;chunked#kotlin.sequences%24chunked(kotlin.sequences.Sequence((kotlin.sequences.chunked.T)),%20kotlin.Int)/size&quot;&gt;さ&lt;/a&gt;れたサイズよりも少ない要素が含まれている可能性があります。</target>
        </trans-unit>
        <trans-unit id="19dcc0ec6fdfe1941cf804b7c1eaf5c5297a4c82" translate="yes" xml:space="preserve">
          <source>The last string in the resulting list may have less characters than the given &lt;a href=&quot;chunked#kotlin.text%24chunked%28kotlin.CharSequence%2C+kotlin.Int%29%2Fsize&quot;&gt;size&lt;/a&gt;.</source>
          <target state="translated">結果のリストの最後の文字列は、指定&lt;a href=&quot;chunked#kotlin.text%24chunked%28kotlin.CharSequence%2C+kotlin.Int%29%2Fsize&quot;&gt;さ&lt;/a&gt;れたサイズよりも文字数が少ない場合があります。</target>
        </trans-unit>
        <trans-unit id="01c80e09f206886b89d00be2fa9ab43305c32874" translate="yes" xml:space="preserve">
          <source>The last string in the resulting list may have less characters than the given &lt;a href=&quot;chunked#kotlin.text%24chunked(kotlin.CharSequence,%20kotlin.Int)/size&quot;&gt;size&lt;/a&gt;.</source>
          <target state="translated">結果のリストの最後の文字列は、指定&lt;a href=&quot;chunked#kotlin.text%24chunked(kotlin.CharSequence,%20kotlin.Int)/size&quot;&gt;さ&lt;/a&gt;れたサイズよりも少ない文字である可能性があります。</target>
        </trans-unit>
        <trans-unit id="5264566740d059c5fcc7247f9b4782bf04dc775d" translate="yes" xml:space="preserve">
          <source>The last string in the resulting sequence may have less characters than the given &lt;a href=&quot;chunked-sequence#kotlin.text%24chunkedSequence%28kotlin.CharSequence%2C+kotlin.Int%29%2Fsize&quot;&gt;size&lt;/a&gt;.</source>
          <target state="translated">結果のシーケンスの最後の文字列は、指定&lt;a href=&quot;chunked-sequence#kotlin.text%24chunkedSequence%28kotlin.CharSequence%2C+kotlin.Int%29%2Fsize&quot;&gt;さ&lt;/a&gt;れたサイズよりも文字数が少ない場合があります。</target>
        </trans-unit>
        <trans-unit id="7ebb5e898a1a9ea0d92ef57e7df9d364782eae89" translate="yes" xml:space="preserve">
          <source>The last string in the resulting sequence may have less characters than the given &lt;a href=&quot;chunked-sequence#kotlin.text%24chunkedSequence(kotlin.CharSequence,%20kotlin.Int)/size&quot;&gt;size&lt;/a&gt;.</source>
          <target state="translated">結果のシーケンスの最後の文字列は、指定&lt;a href=&quot;chunked-sequence#kotlin.text%24chunkedSequence(kotlin.CharSequence,%20kotlin.Int)/size&quot;&gt;さ&lt;/a&gt;れたサイズよりも少ない文字である可能性があります。</target>
        </trans-unit>
        <trans-unit id="34c76d76568703e916e3116e8326427af7debc51" translate="yes" xml:space="preserve">
          <source>The lastIndex is a read/write integer property of regular expressions that specifies the index at which to start the next match.</source>
          <target state="translated">lastIndexは、次のマッチを開始するインデックスを指定する正規表現の読み書き可能な整数プロパティです。</target>
        </trans-unit>
        <trans-unit id="9d0eba273c11a973f53f6330c745e78d9f5b9345" translate="yes" xml:space="preserve">
          <source>The latter is called &lt;strong&gt;contravariance&lt;/strong&gt;, and you can only call methods that take String as an argument on &lt;code&gt;List&amp;lt;? super String&amp;gt;&lt;/code&gt; (e.g., you can call &lt;code&gt;add(String)&lt;/code&gt; or &lt;code&gt;set(int, String)&lt;/code&gt;), while if you call something that returns &lt;code&gt;T&lt;/code&gt; in &lt;code&gt;List&amp;lt;T&amp;gt;&lt;/code&gt;, you don't get a &lt;code&gt;String&lt;/code&gt;, but an &lt;code&gt;Object&lt;/code&gt;.</source>
          <target state="translated">後者は&lt;strong&gt;contravariance&lt;/strong&gt;と呼ばれ、 &lt;code&gt;List&amp;lt;? super String&amp;gt;&lt;/code&gt; 引数としてStringを取るメソッドのみを呼び出すことができます。スーパー文字列&amp;gt;（例えば、あなたが呼び出すことができます &lt;code&gt;add(String)&lt;/code&gt; または &lt;code&gt;set(int, String)&lt;/code&gt; ）、あなたが戻ってその何かを呼び出す場合ながら &lt;code&gt;T&lt;/code&gt; で &lt;code&gt;List&amp;lt;T&amp;gt;&lt;/code&gt; 、あなたが取得しない &lt;code&gt;String&lt;/code&gt; が、 &lt;code&gt;Object&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="86eeb4f1664e3df8b781582839802549edf89327" translate="yes" xml:space="preserve">
          <source>The layout of a Kotlin multiplatform project is constructed out of the following building blocks:</source>
          <target state="translated">Kotlinのマルチプラットフォームプロジェクトのレイアウトは、以下のビルディングブロックで構成されています。</target>
        </trans-unit>
        <trans-unit id="dc4b69a6e38939f4509626db77c33dd8c679086f" translate="yes" xml:space="preserve">
          <source>The least significant 16 bits of the resulting &lt;code&gt;Int&lt;/code&gt; value are the same as the bits of this &lt;code&gt;Short&lt;/code&gt; value, whereas the most significant 16 bits are filled with the sign bit of this value.</source>
          <target state="translated">結果の &lt;code&gt;Int&lt;/code&gt; 値の最下位16ビットはこの &lt;code&gt;Short&lt;/code&gt; 値のビットと同じですが、最上位16ビットはこの値の符号ビットで埋められます。</target>
        </trans-unit>
        <trans-unit id="4f0f34d38c4a4771a59f6d35fcaf5f32f9d5a113" translate="yes" xml:space="preserve">
          <source>The least significant 16 bits of the resulting &lt;code&gt;Int&lt;/code&gt; value are the same as the bits of this &lt;code&gt;UShort&lt;/code&gt; value, whereas the most significant 16 bits are filled with zeros.</source>
          <target state="translated">結果の &lt;code&gt;Int&lt;/code&gt; 値の最下位16ビットはこの &lt;code&gt;UShort&lt;/code&gt; 値のビットと同じですが、最上位16ビットはゼロで埋められます。</target>
        </trans-unit>
        <trans-unit id="db7d64a40964cbcc91041fe9c6abd3a6f883ba7c" translate="yes" xml:space="preserve">
          <source>The least significant 16 bits of the resulting &lt;code&gt;Long&lt;/code&gt; value are the same as the bits of this &lt;code&gt;Short&lt;/code&gt; value, whereas the most significant 48 bits are filled with the sign bit of this value.</source>
          <target state="translated">結果の &lt;code&gt;Long&lt;/code&gt; 値の最下位16ビットはこの &lt;code&gt;Short&lt;/code&gt; 値のビットと同じですが、最上位48ビットはこの値の符号ビットで埋められます。</target>
        </trans-unit>
        <trans-unit id="96755580626f22c0780c08fafc24e52c9efd9ea9" translate="yes" xml:space="preserve">
          <source>The least significant 16 bits of the resulting &lt;code&gt;Long&lt;/code&gt; value are the same as the bits of this &lt;code&gt;UShort&lt;/code&gt; value, whereas the most significant 48 bits are filled with zeros.</source>
          <target state="translated">結果の &lt;code&gt;Long&lt;/code&gt; 値の最下位16ビットはこの &lt;code&gt;UShort&lt;/code&gt; 値のビットと同じですが、最上位の48ビットはゼロで埋められます。</target>
        </trans-unit>
        <trans-unit id="805e1d578ae5895787cd7c80c9a6f84d9875cbdf" translate="yes" xml:space="preserve">
          <source>The least significant 16 bits of the resulting &lt;code&gt;UInt&lt;/code&gt; value are the same as the bits of this &lt;code&gt;Short&lt;/code&gt; value, whereas the most significant 16 bits are filled with the sign bit of this value.</source>
          <target state="translated">結果の &lt;code&gt;UInt&lt;/code&gt; 値の最下位16ビットはこの &lt;code&gt;Short&lt;/code&gt; 値のビットと同じですが、最上位16ビットはこの値の符号ビットで埋められます。</target>
        </trans-unit>
        <trans-unit id="e2d7f90749fa8a275417e31e2a951b621f7bdd7e" translate="yes" xml:space="preserve">
          <source>The least significant 16 bits of the resulting &lt;code&gt;UInt&lt;/code&gt; value are the same as the bits of this &lt;code&gt;UShort&lt;/code&gt; value, whereas the most significant 16 bits are filled with zeros.</source>
          <target state="translated">結果の &lt;code&gt;UInt&lt;/code&gt; 値の最下位16ビットはこの &lt;code&gt;UShort&lt;/code&gt; 値のビットと同じですが、最上位16ビットはゼロで埋められます。</target>
        </trans-unit>
        <trans-unit id="382a5532019e821cafc1c9ca21454b43f1f91a60" translate="yes" xml:space="preserve">
          <source>The least significant 16 bits of the resulting &lt;code&gt;ULong&lt;/code&gt; value are the same as the bits of this &lt;code&gt;Short&lt;/code&gt; value, whereas the most significant 48 bits are filled with the sign bit of this value.</source>
          <target state="translated">結果の &lt;code&gt;ULong&lt;/code&gt; 値の最下位16ビットはこの &lt;code&gt;Short&lt;/code&gt; 値のビットと同じですが、最上位48ビットはこの値の符号ビットで埋められます。</target>
        </trans-unit>
        <trans-unit id="98d7b8a419dc2e1a1e55aeb89fee5123de4a6b5e" translate="yes" xml:space="preserve">
          <source>The least significant 16 bits of the resulting &lt;code&gt;ULong&lt;/code&gt; value are the same as the bits of this &lt;code&gt;UShort&lt;/code&gt; value, whereas the most significant 48 bits are filled with zeros.</source>
          <target state="translated">結果の &lt;code&gt;ULong&lt;/code&gt; 値の最下位16ビットはこの &lt;code&gt;UShort&lt;/code&gt; 値のビットと同じですが、最上位48ビットはゼロで埋められます。</target>
        </trans-unit>
        <trans-unit id="b511f5bcb1b166f6a21672ecd3a364142d43ef6e" translate="yes" xml:space="preserve">
          <source>The least significant 32 bits of the resulting &lt;code&gt;Long&lt;/code&gt; value are the same as the bits of this &lt;code&gt;Int&lt;/code&gt; value, whereas the most significant 32 bits are filled with the sign bit of this value.</source>
          <target state="translated">結果の &lt;code&gt;Long&lt;/code&gt; 値の最下位32ビットはこの &lt;code&gt;Int&lt;/code&gt; 値のビットと同じですが、最上位32ビットはこの値の符号ビットで埋められます。</target>
        </trans-unit>
        <trans-unit id="8552752324805690a09e930c3347d0b3b76fb45a" translate="yes" xml:space="preserve">
          <source>The least significant 32 bits of the resulting &lt;code&gt;Long&lt;/code&gt; value are the same as the bits of this &lt;code&gt;UInt&lt;/code&gt; value, whereas the most significant 32 bits are filled with zeros.</source>
          <target state="translated">結果の &lt;code&gt;Long&lt;/code&gt; 値の最下位32ビットはこの &lt;code&gt;UInt&lt;/code&gt; 値のビットと同じですが、最上位32ビットはゼロで埋められます。</target>
        </trans-unit>
        <trans-unit id="13513c5d8d4b778bf7d2d02871ec67b342f92eb3" translate="yes" xml:space="preserve">
          <source>The least significant 32 bits of the resulting &lt;code&gt;ULong&lt;/code&gt; value are the same as the bits of this &lt;code&gt;Int&lt;/code&gt; value, whereas the most significant 32 bits are filled with the sign bit of this value.</source>
          <target state="translated">結果の &lt;code&gt;ULong&lt;/code&gt; 値の最下位32ビットはこの &lt;code&gt;Int&lt;/code&gt; 値のビットと同じですが、最上位32ビットはこの値の符号ビットで埋められます。</target>
        </trans-unit>
        <trans-unit id="098196788f072e1b90241673f7cd1c8d4ddc487e" translate="yes" xml:space="preserve">
          <source>The least significant 32 bits of the resulting &lt;code&gt;ULong&lt;/code&gt; value are the same as the bits of this &lt;code&gt;UInt&lt;/code&gt; value, whereas the most significant 32 bits are filled with zeros.</source>
          <target state="translated">結果の &lt;code&gt;ULong&lt;/code&gt; 値の最下位32ビットはこの &lt;code&gt;UInt&lt;/code&gt; 値のビットと同じですが、最上位32ビットはゼロで埋められます。</target>
        </trans-unit>
        <trans-unit id="1e95934eab4e475329950f2eb8e7a3a03516b89c" translate="yes" xml:space="preserve">
          <source>The least significant 8 bits of the resulting &lt;code&gt;Char&lt;/code&gt; code are the same as the bits of this &lt;code&gt;Byte&lt;/code&gt; value, whereas the most significant 8 bits are filled with the sign bit of this value.</source>
          <target state="translated">結果の &lt;code&gt;Char&lt;/code&gt; コードの最下位8ビットはこの &lt;code&gt;Byte&lt;/code&gt; 値のビットと同じですが、最上位8ビットはこの値の符号ビットで埋められます。</target>
        </trans-unit>
        <trans-unit id="1ccfa3d5b3f0d4c2cadb8ddee394a5e74b7f3fb0" translate="yes" xml:space="preserve">
          <source>The least significant 8 bits of the resulting &lt;code&gt;Int&lt;/code&gt; value are the same as the bits of this &lt;code&gt;Byte&lt;/code&gt; value, whereas the most significant 24 bits are filled with the sign bit of this value.</source>
          <target state="translated">結果の &lt;code&gt;Int&lt;/code&gt; 値の最下位8ビットはこの &lt;code&gt;Byte&lt;/code&gt; 値のビットと同じですが、最上位24ビットはこの値の符号ビットで埋められます。</target>
        </trans-unit>
        <trans-unit id="682e9bb2df532a75f2a73fb4a8682c3fe53c3f6f" translate="yes" xml:space="preserve">
          <source>The least significant 8 bits of the resulting &lt;code&gt;Int&lt;/code&gt; value are the same as the bits of this &lt;code&gt;UByte&lt;/code&gt; value, whereas the most significant 24 bits are filled with zeros.</source>
          <target state="translated">結果の &lt;code&gt;Int&lt;/code&gt; 値の最下位8ビットはこの &lt;code&gt;UByte&lt;/code&gt; 値のビットと同じですが、最上位24ビットはゼロで埋められます。</target>
        </trans-unit>
        <trans-unit id="740b8988c3d828c3ba10680439510f32d7f08bd4" translate="yes" xml:space="preserve">
          <source>The least significant 8 bits of the resulting &lt;code&gt;Long&lt;/code&gt; value are the same as the bits of this &lt;code&gt;Byte&lt;/code&gt; value, whereas the most significant 56 bits are filled with the sign bit of this value.</source>
          <target state="translated">結果の &lt;code&gt;Long&lt;/code&gt; 値の最下位8ビットはこの &lt;code&gt;Byte&lt;/code&gt; 値のビットと同じですが、最上位56ビットはこの値の符号ビットで埋められます。</target>
        </trans-unit>
        <trans-unit id="f2986e4bdb9623eb7b0be806904f6c45008e66a1" translate="yes" xml:space="preserve">
          <source>The least significant 8 bits of the resulting &lt;code&gt;Long&lt;/code&gt; value are the same as the bits of this &lt;code&gt;UByte&lt;/code&gt; value, whereas the most significant 56 bits are filled with zeros.</source>
          <target state="translated">結果の &lt;code&gt;Long&lt;/code&gt; 値の最下位8ビットはこの &lt;code&gt;UByte&lt;/code&gt; 値のビットと同じですが、最上位56ビットはゼロで埋められます。</target>
        </trans-unit>
        <trans-unit id="da411f42fa8b3bbe7fd6d9ed1a7edbedcead90c8" translate="yes" xml:space="preserve">
          <source>The least significant 8 bits of the resulting &lt;code&gt;Short&lt;/code&gt; value are the same as the bits of this &lt;code&gt;Byte&lt;/code&gt; value, whereas the most significant 8 bits are filled with the sign bit of this value.</source>
          <target state="translated">結果の &lt;code&gt;Short&lt;/code&gt; 値の最下位8ビットはこの &lt;code&gt;Byte&lt;/code&gt; 値のビットと同じですが、最上位8ビットはこの値の符号ビットで埋められます。</target>
        </trans-unit>
        <trans-unit id="dbca88370b969aea0b645fa67d458151bf144ef3" translate="yes" xml:space="preserve">
          <source>The least significant 8 bits of the resulting &lt;code&gt;Short&lt;/code&gt; value are the same as the bits of this &lt;code&gt;UByte&lt;/code&gt; value, whereas the most significant 8 bits are filled with zeros.</source>
          <target state="translated">結果の &lt;code&gt;Short&lt;/code&gt; 値の最下位8ビットはこの &lt;code&gt;UByte&lt;/code&gt; 値のビットと同じですが、最上位8ビットはゼロで埋められます。</target>
        </trans-unit>
        <trans-unit id="0705f7403c9d4340ca48e777c703d467c71d6c8f" translate="yes" xml:space="preserve">
          <source>The least significant 8 bits of the resulting &lt;code&gt;UInt&lt;/code&gt; value are the same as the bits of this &lt;code&gt;Byte&lt;/code&gt; value, whereas the most significant 24 bits are filled with the sign bit of this value.</source>
          <target state="translated">結果の &lt;code&gt;UInt&lt;/code&gt; 値の最下位8ビットはこの &lt;code&gt;Byte&lt;/code&gt; 値のビットと同じですが、最上位24ビットはこの値の符号ビットで埋められます。</target>
        </trans-unit>
        <trans-unit id="e35a3b71a791931b3596ab2bd1edb46d9365dda1" translate="yes" xml:space="preserve">
          <source>The least significant 8 bits of the resulting &lt;code&gt;UInt&lt;/code&gt; value are the same as the bits of this &lt;code&gt;UByte&lt;/code&gt; value, whereas the most significant 24 bits are filled with zeros.</source>
          <target state="translated">結果の &lt;code&gt;UInt&lt;/code&gt; 値の最下位8ビットはこの &lt;code&gt;UByte&lt;/code&gt; 値のビットと同じですが、最上位24ビットはゼロで埋められます。</target>
        </trans-unit>
        <trans-unit id="fbe359060636f5088c741be0b327d7d46254bbcd" translate="yes" xml:space="preserve">
          <source>The least significant 8 bits of the resulting &lt;code&gt;ULong&lt;/code&gt; value are the same as the bits of this &lt;code&gt;Byte&lt;/code&gt; value, whereas the most significant 56 bits are filled with the sign bit of this value.</source>
          <target state="translated">結果の &lt;code&gt;ULong&lt;/code&gt; 値の最下位8ビットはこの &lt;code&gt;Byte&lt;/code&gt; 値のビットと同じですが、最上位56ビットはこの値の符号ビットで埋められます。</target>
        </trans-unit>
        <trans-unit id="9d9c37d2ab226e9ed58e44937eac9a5c2afe8841" translate="yes" xml:space="preserve">
          <source>The least significant 8 bits of the resulting &lt;code&gt;ULong&lt;/code&gt; value are the same as the bits of this &lt;code&gt;UByte&lt;/code&gt; value, whereas the most significant 56 bits are filled with zeros.</source>
          <target state="translated">結果の &lt;code&gt;ULong&lt;/code&gt; 値の最下位8ビットはこの &lt;code&gt;UByte&lt;/code&gt; 値のビットと同じですが、最上位56ビットはゼロで埋められます。</target>
        </trans-unit>
        <trans-unit id="573a497b93bab09d8947aa89f58fd5f36237628f" translate="yes" xml:space="preserve">
          <source>The least significant 8 bits of the resulting &lt;code&gt;UShort&lt;/code&gt; value are the same as the bits of this &lt;code&gt;Byte&lt;/code&gt; value, whereas the most significant 8 bits are filled with the sign bit of this value.</source>
          <target state="translated">結果の &lt;code&gt;UShort&lt;/code&gt; 値の最下位8ビットはこの &lt;code&gt;Byte&lt;/code&gt; 値のビットと同じですが、最上位8ビットはこの値の符号ビットで埋められます。</target>
        </trans-unit>
        <trans-unit id="d49f6edce25857427bee05e2a6463c8f203f6aab" translate="yes" xml:space="preserve">
          <source>The least significant 8 bits of the resulting &lt;code&gt;UShort&lt;/code&gt; value are the same as the bits of this &lt;code&gt;UByte&lt;/code&gt; value, whereas the most significant 8 bits are filled with zeros.</source>
          <target state="translated">結果の &lt;code&gt;UShort&lt;/code&gt; 値の最下位8ビットはこの &lt;code&gt;UByte&lt;/code&gt; 値のビットと同じですが、最上位8ビットはゼロで埋められます。</target>
        </trans-unit>
        <trans-unit id="1511f8695777128c7450dc6f9cc52fbdbfc512c7" translate="yes" xml:space="preserve">
          <source>The less obvious cases that belong to the &quot;grey area&quot; include handling corner cases differently, throwing an exception of a different type than before, changing behavior observable only through reflection, changes in undocumented/undefined behavior, renaming binary artifacts, etc. Sometimes such changes are very important and affect migration experience dramatically, sometimes they are insignificant.</source>
          <target state="translated">グレーゾーン」に属するあまり目立たないケースとしては、コーナーケースを別の方法で扱う、以前とは異なるタイプの例外を投げる、反射によってのみ観察可能な動作を変更する、文書化されていない/定義されていない動作を変更する、バイナリのアーティファクトの名前を変更する、などがあります。このような変更は非常に重要であり、マイグレーションの経験に劇的な影響を与えることもあれば、取るに足らない変更であることもあります。</target>
        </trans-unit>
        <trans-unit id="dd894256ff253457e13d98fae75ab576481e876c" translate="yes" xml:space="preserve">
          <source>The library format</source>
          <target state="translated">図書館のフォーマット</target>
        </trans-unit>
        <trans-unit id="c48fdef888f67d5a66f513cae58be8d045c058e0" translate="yes" xml:space="preserve">
          <source>The library has been created in the current directory:</source>
          <target state="translated">カレントディレクトリにライブラリが作成されました。</target>
        </trans-unit>
        <trans-unit id="cff219119dad603b83453d082db1d0aa5cce3800" translate="yes" xml:space="preserve">
          <source>The lines returned do not include terminating line separators.</source>
          <target state="translated">返された行には、終端行の区切り文字が含まれていません。</target>
        </trans-unit>
        <trans-unit id="0ec3834f8762f850d976d74a3444d0d24d17d417" translate="yes" xml:space="preserve">
          <source>The list is expected to be sorted so that the signs of the &lt;a href=&quot;binary-search#kotlin.collections%24binarySearch(kotlin.collections.List((kotlin.collections.binarySearch.T)),%20kotlin.Int,%20kotlin.Int,%20kotlin.Function1((kotlin.collections.binarySearch.T,%20kotlin.Int)))/comparison&quot;&gt;comparison&lt;/a&gt; function's return values ascend on the list elements, i.e. negative values come before zero and zeroes come before positive values. Otherwise, the result is undefined.</source>
          <target state="translated">リストは、&lt;a href=&quot;binary-search#kotlin.collections%24binarySearch(kotlin.collections.List((kotlin.collections.binarySearch.T)),%20kotlin.Int,%20kotlin.Int,%20kotlin.Function1((kotlin.collections.binarySearch.T,%20kotlin.Int)))/comparison&quot;&gt;比較&lt;/a&gt;関数の戻り値の符号がリスト要素で昇るように並べ替えられることが期待されます。つまり、負の値はゼロの前にあり、ゼロは正の値の前にあります。それ以外の場合、結果は未定義です。</target>
        </trans-unit>
        <trans-unit id="ecc031fda17a51efc3a0c6e7f3483a236bf69e52" translate="yes" xml:space="preserve">
          <source>The list of immediate supertypes of this class, in the order they are listed in the source code.</source>
          <target state="translated">このクラスの即時スーパータイプのリスト。</target>
        </trans-unit>
        <trans-unit id="37daaa29c5ab04c74e60f96a3c80a72671943c78" translate="yes" xml:space="preserve">
          <source>The list of possible time measurement units, in which a duration can be expressed.</source>
          <target state="translated">持続時間を表すことができる時間測定単位のリスト。</target>
        </trans-unit>
        <trans-unit id="e7cfcc4e5ebb2fa63d0c44bdcf02351c03c9e8d4" translate="yes" xml:space="preserve">
          <source>The list of the immediate subclasses if this class is a sealed class, or an empty list otherwise.</source>
          <target state="translated">このクラスが封印されたクラスである場合はその直後のサブクラスのリスト、そうでない場合は空のリスト。</target>
        </trans-unit>
        <trans-unit id="af028a3423820dfb61266857373312e6321072a9" translate="yes" xml:space="preserve">
          <source>The list of type parameters of this callable.</source>
          <target state="translated">このコールアブルの型パラメータのリスト。</target>
        </trans-unit>
        <trans-unit id="3983145b3c17efebd4ca1c3dd6839e784929aaa8" translate="yes" xml:space="preserve">
          <source>The list of type parameters of this class. This list does &lt;em&gt;not&lt;/em&gt; include type parameters of outer classes.</source>
          <target state="translated">このクラスの型パラメーターのリスト。このリストには、外部クラスの型パラメーターは含まれていませ&lt;em&gt;ん&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="7dd6f3d5d8e8c83c9d11a7ed45e7362cc872b1a5" translate="yes" xml:space="preserve">
          <source>The locking in this example is fine-grained, so it pays the price. However, it is a good choice for some situations where you absolutely must modify some shared state periodically, but there is no natural thread that this state is confined to.</source>
          <target state="translated">この例のロックは細かいので、その代償を払っています。しかし、共有された状態を定期的に絶対に変更しなければならないが、この状態が制限されている自然なスレッドが存在しないというような状況には良い選択です。</target>
        </trans-unit>
        <trans-unit id="993a245cc6dcc5a6d2356a7f7d1259d26b6ea137" translate="yes" xml:space="preserve">
          <source>The loop variable(s), if any, must be declared outside of the &lt;code&gt;while&lt;/code&gt; loop, and are therefore available for inspection afterwards, at which point they will contain the value(s) that made the loop condition false.</source>
          <target state="translated">ループ変数がある場合は、 &lt;code&gt;while&lt;/code&gt; ループの外で宣言する必要があるため、後で検査できるようになり、その時点でループ条件がfalseになった値が含まれます。</target>
        </trans-unit>
        <trans-unit id="f10abe77e5b16e3b7aa73cabd19e9ac919e5868d" translate="yes" xml:space="preserve">
          <source>The main code is straightforward:</source>
          <target state="translated">メインのコードは簡単です。</target>
        </trans-unit>
        <trans-unit id="21b17843ae6bab256e1f2d7c26e40966048480db" translate="yes" xml:space="preserve">
          <source>The main code starts and connects the whole pipeline:</source>
          <target state="translated">メインコードが起動し、パイプライン全体を接続します。</target>
        </trans-unit>
        <trans-unit id="1415e580114f63d99c0e8622a1104c3c733c68ba" translate="yes" xml:space="preserve">
          <source>The main disadvantage of changing the code style in an existing project is that the blame/annotate VCS feature will point to irrelevant commits more often. While each VCS has some kind of way to deal with this problem (&lt;a href=&quot;https://www.jetbrains.com/help/idea/investigate-changes.html&quot;&gt;&quot;Annotate Previous Revision&quot;&lt;/a&gt; can be used in IntelliJ IDEA), it's important to decide if a new style is worth all the effort. The practice of separating reformatting commits from meaningful changes can help a lot with later investigations.</source>
          <target state="translated">既存のプロジェクトでコードスタイルを変更することの主な欠点は、VCMの注釈/注釈機能が、無関係なコミットをより頻繁に指すようになることです。各VCSにはこの問題に対処するための何らかの方法がありますが（&lt;a href=&quot;https://www.jetbrains.com/help/idea/investigate-changes.html&quot;&gt;「以前のリビジョンの注釈」&lt;/a&gt;はIntelliJ IDEAで使用できます）、新しいスタイルがすべての努力に値するかどうかを判断することが重要です。再フォーマットのコミットと意味のある変更を分離することは、後の調査で非常に役立ちます。</target>
        </trans-unit>
        <trans-unit id="f0255c27371bb337a0275ae99c66e66aefbb2cf2" translate="yes" xml:space="preserve">
          <source>The main function just launches a coroutine to print results of &lt;code&gt;switchMapDeferreds&lt;/code&gt; and sends some test data to it:</source>
          <target state="translated">メイン関数はコルーチンを起動して、 &lt;code&gt;switchMapDeferreds&lt;/code&gt; の結果を出力し、テストデータを送信します。</target>
        </trans-unit>
        <trans-unit id="c0a11bc5688f898de97456dfcb543cf05d79b8a1" translate="yes" xml:space="preserve">
          <source>The main thread (that runs the &lt;code&gt;main()&lt;/code&gt; function) must wait until our coroutine completes, otherwise the program ends before &lt;code&gt;Hello&lt;/code&gt; is printed.</source>
          <target state="translated">（ &lt;code&gt;main()&lt;/code&gt; 関数を実行する）メインスレッドは、コルーチンが完了するまで待機する必要があります。そうでない場合、プログラムは &lt;code&gt;Hello&lt;/code&gt; が出力される前に終了します。</target>
        </trans-unit>
        <trans-unit id="2c831066dd6087f2516b15d01bfb68e39b9bcf05" translate="yes" xml:space="preserve">
          <source>The maximum number of substrings to return. Zero by default means no limit is set.</source>
          <target state="translated">返す部分文字列の最大数。デフォルトでは0は制限が設定されていないことを意味します。</target>
        </trans-unit>
        <trans-unit id="4e76f165176d7e28c6b59c285a7ee8af5a71fc72" translate="yes" xml:space="preserve">
          <source>The maximum radix available for conversion to and from strings.</source>
          <target state="translated">文字列への変換と文字列からの変換で利用可能な最大基数。</target>
        </trans-unit>
        <trans-unit id="38f9246447f2685e9dd36b4c8d7e0bf7ff2fb023" translate="yes" xml:space="preserve">
          <source>The maximum value in the range (inclusive).</source>
          <target state="translated">範囲内の最大値(含む)。</target>
        </trans-unit>
        <trans-unit id="cc9397547e8b9fc8e2131246f8cce9b80a975147" translate="yes" xml:space="preserve">
          <source>The maximum value of a Unicode code point. Kotlin/Native specific.</source>
          <target state="translated">Unicodeコードポイントの最大値。Kotlin/ネイティブ固有。</target>
        </trans-unit>
        <trans-unit id="af496c450bf387c2b7d7ee0dc32c766b9f1b66c1" translate="yes" xml:space="preserve">
          <source>The maximum value of a Unicode high-surrogate code unit.</source>
          <target state="translated">Unicode ハイサロゲートコード単位の最大値。</target>
        </trans-unit>
        <trans-unit id="68f9d655dde4db0c3b71fc09c97d0f87e103d52b" translate="yes" xml:space="preserve">
          <source>The maximum value of a Unicode low-surrogate code unit.</source>
          <target state="translated">Unicode ローサロゲートコード単位の最大値。</target>
        </trans-unit>
        <trans-unit id="0cb5887284a08dd04202e0863d133d8ed431392d" translate="yes" xml:space="preserve">
          <source>The maximum value of a Unicode surrogate code unit.</source>
          <target state="translated">Unicodeサロゲートコード単位の最大値。</target>
        </trans-unit>
        <trans-unit id="ea009c16dc0030623058aff99eec7f7c7973366c" translate="yes" xml:space="preserve">
          <source>The maximum value of a character code unit.</source>
          <target state="translated">文字コード単位の最大値。</target>
        </trans-unit>
        <trans-unit id="dce9edb79f3aca5450e6dfb555e231182e2c5340" translate="yes" xml:space="preserve">
          <source>The meaning of a visibility modifier depends on whether it's applied to a top-level declaration or to a declaration inside a class. For top-level declarations:</source>
          <target state="translated">visibility修飾子の意味は、それがトップレベル宣言に適用されるか、クラス内の宣言に適用されるかによって異なります。トップレベル宣言の場合。</target>
        </trans-unit>
        <trans-unit id="2f5715d8d7aab68289e0b8a47e46f1764f30f76e" translate="yes" xml:space="preserve">
          <source>The message explaining the deprecation and recommending an alternative API to use.</source>
          <target state="translated">非推奨を説明するメッセージと、使用する代替APIを推奨するメッセージです。</target>
        </trans-unit>
        <trans-unit id="1d7af1b2ed876762350f57904a38e801662ebbf4" translate="yes" xml:space="preserve">
          <source>The meta-runner for Kotlin is available on &lt;a href=&quot;https://github.com/jonnyzzz/Kotlin.TeamCity&quot;&gt;GitHub&lt;/a&gt;. If using TeamCity 9 or above, we can now simply import that meta-runner from the TeamCity user interface</source>
          <target state="translated">Kotlinのメタランナーは&lt;a href=&quot;https://github.com/jonnyzzz/Kotlin.TeamCity&quot;&gt;GitHub&lt;/a&gt;で入手できます。TeamCity 9以上を使用している場合、TeamCityユーザーインターフェイスからメタランナーをインポートするだけで済みます</target>
        </trans-unit>
        <trans-unit id="cbb5d37dc4d790a9dba2a103cd7fc2ea1af9db2f" translate="yes" xml:space="preserve">
          <source>The minimum radix available for conversion to and from strings.</source>
          <target state="translated">文字列への変換と文字列からの変換で利用可能な最小基数。</target>
        </trans-unit>
        <trans-unit id="3eb6b21e0f2a2eb117e5ca90292e6def24614862" translate="yes" xml:space="preserve">
          <source>The minimum value in the range.</source>
          <target state="translated">範囲内の最小値。</target>
        </trans-unit>
        <trans-unit id="480df25e783a3ddb0c5eabcc07d40b9a21fd328e" translate="yes" xml:space="preserve">
          <source>The minimum value of a Unicode code point. Kotlin/Native specific.</source>
          <target state="translated">Unicode コードポイントの最小値。Kotlin/ネイティブ固有。</target>
        </trans-unit>
        <trans-unit id="c11b4b4a4cfd50662da801109ced72e7ef8083ad" translate="yes" xml:space="preserve">
          <source>The minimum value of a Unicode high-surrogate code unit.</source>
          <target state="translated">Unicode ハイサロゲートコード単位の最小値。</target>
        </trans-unit>
        <trans-unit id="7a57e546e08f3cd66a3ed8cebd57f37a4137a78d" translate="yes" xml:space="preserve">
          <source>The minimum value of a Unicode low-surrogate code unit.</source>
          <target state="translated">Unicode ローサロゲートコード単位の最小値。</target>
        </trans-unit>
        <trans-unit id="47b523f1a39e9c9f7bda17fc85b300ab3e0da311" translate="yes" xml:space="preserve">
          <source>The minimum value of a Unicode surrogate code unit.</source>
          <target state="translated">Unicodeサロゲートコード単位の最小値。</target>
        </trans-unit>
        <trans-unit id="e3fc4d1ab4988e695801daf57bd33d3f470c3668" translate="yes" xml:space="preserve">
          <source>The minimum value of a character code unit.</source>
          <target state="translated">文字コード単位の最小値。</target>
        </trans-unit>
        <trans-unit id="d80a9d6c0ddeb1216ece2df4cc2d7d63382408e4" translate="yes" xml:space="preserve">
          <source>The minimum value of a supplementary code point, &lt;code&gt;\u0x10000&lt;/code&gt;. Kotlin/Native specific.</source>
          <target state="translated">補助コードポイントの最小値 &lt;code&gt;\u0x10000&lt;/code&gt; 。Kotlin /ネイティブ固有。</target>
        </trans-unit>
        <trans-unit id="39042f06ab046e1bfc15de4ecf52d5a28eec3294" translate="yes" xml:space="preserve">
          <source>The modifier can be used on &lt;code&gt;var&lt;/code&gt; properties declared inside the body of a class (not in the primary constructor, and only when the property does not have a custom getter or setter) and, since Kotlin 1.2, for top-level properties and local variables. The type of the property or variable must be non-null, and it must not be a primitive type.</source>
          <target state="translated">修飾子は、クラスの本体内で宣言された &lt;code&gt;var&lt;/code&gt; プロパティ（プライマリコンストラクターではなく、プロパティにカスタムゲッターまたはセッターがない場合のみ）で使用できます。Kotlin1.2以降、トップレベルのプロパティとローカル変数に使用できます。 。プロパティまたは変数の型はnull以外である必要があり、プリミティブ型であってはなりません。</target>
        </trans-unit>
        <trans-unit id="bb919d11f95900a1425b0a32e4257389d1fc669f" translate="yes" xml:space="preserve">
          <source>The most &quot;natural&quot; placement is in the object &lt;code&gt;nativeHeap&lt;/code&gt;. It corresponds to allocating native memory with &lt;code&gt;malloc&lt;/code&gt; and provides an additional &lt;code&gt;.free()&lt;/code&gt; operation to free allocated memory:</source>
          <target state="translated">最も「自然な」配置は、オブジェクト &lt;code&gt;nativeHeap&lt;/code&gt; 内にあります。これは、 &lt;code&gt;malloc&lt;/code&gt; によるネイティブメモリの割り当てに対応し、割り当てられたメモリを解放するための追加の &lt;code&gt;.free()&lt;/code&gt; 操作を提供します。</target>
        </trans-unit>
        <trans-unit id="0d14eba091c54d0c22e0562741651e98077e032c" translate="yes" xml:space="preserve">
          <source>The most basic reflection feature is getting the runtime reference to a Kotlin class. To obtain the reference to a statically known Kotlin class, you can use the &lt;em&gt;class literal&lt;/em&gt; syntax:</source>
          <target state="translated">最も基本的なリフレクション機能は、Kotlinクラスへのランタイム参照を取得することです。静的に既知のKotlinクラスへの参照を取得するには、&lt;em&gt;クラスリテラル&lt;/em&gt;構文を使用できます。</target>
        </trans-unit>
        <trans-unit id="ae0dbb4ff6b4fc6cc9b694111494978916ff6daf" translate="yes" xml:space="preserve">
          <source>The most basic usage of enum classes is implementing type-safe enums:</source>
          <target state="translated">enumクラスの最も基本的な使い方は、型安全なenumを実装することです。</target>
        </trans-unit>
        <trans-unit id="564a165b2993e039b868e117559d08b7cdc98e88" translate="yes" xml:space="preserve">
          <source>The most common kind of properties simply reads from (and maybe writes to) a backing field. On the other hand, with custom getters and setters one can implement any behaviour of a property. Somewhere in between, there are certain common patterns of how a property may work. A few examples: lazy values, reading from a map by a given key, accessing a database, notifying listener on access, etc.</source>
          <target state="translated">最も一般的なプロパティの種類は、単にバッキングフィールドから読み出す(そして多分書き込む)だけです。一方、カスタムゲッターやセッターを使えば、プロパティのあらゆる動作を実装することができます。その中間のどこかに、プロパティがどのように動作するかについて、ある種の一般的なパターンがあります。いくつかの例としては、遅延値、与えられたキーによるマップからの読み込み、データベースへのアクセス、アクセス時のリスナーへの通知などがあります。</target>
        </trans-unit>
        <trans-unit id="d5cbdfb8e81de653dd867a75b87523ff1d242141" translate="yes" xml:space="preserve">
          <source>The most common type of constraint is an &lt;strong&gt;upper bound&lt;/strong&gt; that corresponds to Java's &lt;em&gt;extends&lt;/em&gt; keyword:</source>
          <target state="translated">最も一般的なタイプの制約は、Javaの&lt;em&gt;extends&lt;/em&gt;キーワードに対応する&lt;strong&gt;上限&lt;/strong&gt;です。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="368d747cfcb5fb4e353c85a7469dfacbb5453495" translate="yes" xml:space="preserve">
          <source>The most common way to create a collection is with the standard library functions &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/list-of&quot;&gt;&lt;code&gt;listOf&amp;lt;T&amp;gt;()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/set-of&quot;&gt;&lt;code&gt;setOf&amp;lt;T&amp;gt;()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/mutable-list-of&quot;&gt;&lt;code&gt;mutableListOf&amp;lt;T&amp;gt;()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/mutable-set-of&quot;&gt;&lt;code&gt;mutableSetOf&amp;lt;T&amp;gt;()&lt;/code&gt;&lt;/a&gt;. If you provide a comma-separated list of collection elements as arguments, the compiler detects the element type automatically. When creating empty collections, specify the type explicitly.</source>
          <target state="translated">コレクションを作成する最も一般的な方法は、標準ライブラリ関数&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/list-of&quot;&gt; &lt;code&gt;listOf&amp;lt;T&amp;gt;()&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/set-of&quot;&gt; &lt;code&gt;setOf&amp;lt;T&amp;gt;()&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/mutable-list-of&quot;&gt; &lt;code&gt;mutableListOf&amp;lt;T&amp;gt;()&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/mutable-set-of&quot;&gt; &lt;code&gt;mutableSetOf&amp;lt;T&amp;gt;()&lt;/code&gt; &lt;/a&gt;です。コレクション要素のコンマ区切りのリストを引数として指定すると、コンパイラーは要素タイプを自動的に検出します。空のコレクションを作成する場合は、タイプを明示的に指定してください。</target>
        </trans-unit>
        <trans-unit id="b853cf446ccffab0ecfd031a6ec9cd9f7555703c" translate="yes" xml:space="preserve">
          <source>The most notable change is in the continuation indentation policy. There's a nice idea to use the double indent for showing that a multi-line expression hasn't ended on the previous line. This is a very simple and general rule, but several Kotlin constructions look a bit awkward when they are formatted this way. In Kotlin Coding Conventions it's recommended to use a single indent in cases where the long continuation indent has been forced before</source>
          <target state="translated">最も注目すべき変更点は、継続インデントのポリシーです。複数行の式が前の行で終わっていないことを示すためにダブルインデントを使うという良いアイデアがあります。これは非常にシンプルで一般的なルールですが、いくつかの Kotlin の構文がこのようにフォーマットされていると、少し不恰好に見えてしまいます。Kotlin のコーディング規約では、長い連続インデントが前の行で強制的に使われている場合はシングルインデントを使うことが推奨されています。</target>
        </trans-unit>
        <trans-unit id="e8c58687aab400a3400843ec6513c56c72bdb694" translate="yes" xml:space="preserve">
          <source>The most obvious practical reason to cancel execution of a coroutine is because its execution time has exceeded some timeout. While you can manually track the reference to the corresponding &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html&quot;&gt;Job&lt;/a&gt; and launch a separate coroutine to cancel the tracked one after delay, there is a ready to use &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-timeout.html&quot;&gt;withTimeout&lt;/a&gt; function that does it. Look at the following example:</source>
          <target state="translated">コルーチンの実行をキャンセルする最も明白な実用的な理由は、その実行時間がタイムアウトを超えたためです。対応する&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html&quot;&gt;ジョブ&lt;/a&gt;への参照を手動で追跡し、別のコルーチンを起動して追跡後に追跡をキャンセルできますが、それを実行する&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-timeout.html&quot;&gt;withTimeout&lt;/a&gt;関数を使用する準備ができています。次の例を見てください。</target>
        </trans-unit>
        <trans-unit id="d08f23af81c5dad7c4dca8d8027b602b0ab864b4" translate="yes" xml:space="preserve">
          <source>The most peculiar feature of &lt;code&gt;dynamic&lt;/code&gt; is that we are allowed to call &lt;strong&gt;any&lt;/strong&gt; property or function with any parameters on a &lt;code&gt;dynamic&lt;/code&gt; variable:</source>
          <target state="translated">&lt;code&gt;dynamic&lt;/code&gt; の最も独特な機能は、 &lt;code&gt;dynamic&lt;/code&gt; 変数の任意のパラメーターで&lt;strong&gt;任意の&lt;/strong&gt;プロパティまたは関数を呼び出すことができることです。</target>
        </trans-unit>
        <trans-unit id="3c05df95cb8e9db1a4f2601246ac944d5c8bd276" translate="yes" xml:space="preserve">
          <source>The multiplatform projects and multiplatform libraries are discussed in the &lt;a href=&quot;../../reference/multiplatform&quot;&gt;documentation&lt;/a&gt; too.</source>
          <target state="translated">マルチプラットフォームプロジェクトとマルチプラットフォームライブラリは、&lt;a href=&quot;../../reference/multiplatform&quot;&gt;ドキュメントで&lt;/a&gt;も説明されています。</target>
        </trans-unit>
        <trans-unit id="6595e5fe1547363b463835d421622aad398ae9cc" translate="yes" xml:space="preserve">
          <source>The name contains the following parts (some of them may be empty):</source>
          <target state="translated">名前には以下の部分が含まれています(一部空の場合があります)。</target>
        </trans-unit>
        <trans-unit id="705b141c8de1d697224950845ea5a1b7afb58d54" translate="yes" xml:space="preserve">
          <source>The name of a class is usually a noun or a noun phrase explaining what the class &lt;em&gt;is&lt;/em&gt;: &lt;code&gt;List&lt;/code&gt;, &lt;code&gt;PersonReader&lt;/code&gt;.</source>
          <target state="translated">クラスの名前は通常、クラス&lt;em&gt;が&lt;/em&gt;何であるかを説明する名詞または名詞句&lt;em&gt;です&lt;/em&gt;： &lt;code&gt;List&lt;/code&gt; 、 &lt;code&gt;PersonReader&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2218455df585d83e3681475aae4631f54b57ae59" translate="yes" xml:space="preserve">
          <source>The name of a class used by itself (not as a qualifier to another name) acts as a reference to the companion object of the class (whether named or not):</source>
          <target state="translated">(別の名前の修飾子としてではなく)それ自身で使用されるクラスの名前は、そのクラスのコンパニオン・オブジェクトへの参照として機能します (名前が付いているかどうかに関わらず)。</target>
        </trans-unit>
        <trans-unit id="07fe46086dbe239fd375c49037bb37bff00ee0c4" translate="yes" xml:space="preserve">
          <source>The name of a method is usually a verb or a verb phrase saying what the method &lt;em&gt;does&lt;/em&gt;: &lt;code&gt;close&lt;/code&gt;, &lt;code&gt;readPersons&lt;/code&gt;. The name should also suggest if the method is mutating the object or returning a new one. For instance &lt;code&gt;sort&lt;/code&gt; is sorting a collection in place, while &lt;code&gt;sorted&lt;/code&gt; is returning a sorted copy of the collection.</source>
          <target state="translated">メソッドの名前は、通常、動詞またはメソッドが何を言っ動詞句で&lt;em&gt;行い&lt;/em&gt;： &lt;code&gt;close&lt;/code&gt; 、 &lt;code&gt;readPersons&lt;/code&gt; 。この名前は、メソッドがオブジェクトを変更しているか、新しいオブジェクトを返しているかも示します。たとえば、 &lt;code&gt;sort&lt;/code&gt; はコレクションを &lt;code&gt;sorted&lt;/code&gt; 、sortedはコレクションの並べ替えられたコピーを返します。</target>
        </trans-unit>
        <trans-unit id="07c434a5d635392f2cc52f562338d62b0cd9ae9a" translate="yes" xml:space="preserve">
          <source>The name of the companion object can be omitted, in which case the name &lt;code&gt;Companion&lt;/code&gt; will be used:</source>
          <target state="translated">コンパニオンオブジェクトの名前は省略できます。その場合、 &lt;code&gt;Companion&lt;/code&gt; という名前が使用されます。</target>
        </trans-unit>
        <trans-unit id="ba35193d0490ae1490a81583acf93693abaa382e" translate="yes" xml:space="preserve">
          <source>The name of the file should describe what the code in the file does. Therefore, you should avoid using meaningless words such as &quot;Util&quot; in file names.</source>
          <target state="translated">ファイル名は、そのファイルのコードが何をするかを記述しなければなりません。そのため、ファイル名に「Util」のような意味のない言葉を使うのは避けるべきです。</target>
        </trans-unit>
        <trans-unit id="3aecf5d5ce4130f99667312567cec868e0f727ee" translate="yes" xml:space="preserve">
          <source>The name of the generated Java class can be changed using the &lt;code&gt;@JvmName&lt;/code&gt; annotation:</source>
          <target state="translated">生成されたJavaクラスの名前は、 &lt;code&gt;@JvmName&lt;/code&gt; アノテーションを使用して変更できます。</target>
        </trans-unit>
        <trans-unit id="c5f1bfd2676f7023c48bd8f681608f158236c940" translate="yes" xml:space="preserve">
          <source>The name of the target (if specified) or the project</source>
          <target state="translated">ターゲットの名前(指定されている場合)またはプロジェクトの名前</target>
        </trans-unit>
        <trans-unit id="cbba3c187c456ab45b79f8154b1183097b8b2546" translate="yes" xml:space="preserve">
          <source>The name of this callable as it was declared in the source code. If the callable has no name, a special invented name is created. Nameless callables include:</source>
          <target state="translated">ソースコードで宣言されているこの呼び出し可能ファイルの名前。コールアブルに名前がない場合は、特別に考案された名前が作成されます。名前のない callable には、以下のようなものがあります。</target>
        </trans-unit>
        <trans-unit id="688bb052b4a717479ab8663cafb721fc37d4378a" translate="yes" xml:space="preserve">
          <source>The name of this type parameter as it was declared in the source code.</source>
          <target state="translated">ソース・コードで宣言されているこの型パラメータの名前。</target>
        </trans-unit>
        <trans-unit id="25f073ea1bd96da303a6eb4e8f3418d2fb774887" translate="yes" xml:space="preserve">
          <source>The names of Kotlin classes and interfaces are prefixed when imported to Objective-C. The prefix is derived from the framework name.</source>
          <target state="translated">Kotlinのクラスやインターフェースの名前は、Objective-Cにインポートする際に接頭辞が付けられます。プレフィックスはフレームワーク名に由来します。</target>
        </trans-unit>
        <trans-unit id="69675486a4053839ac9b38d8b7b0c3ec7c01c08b" translate="yes" xml:space="preserve">
          <source>The names of the tasks in Android Projects contain the &lt;a href=&quot;https://developer.android.com/studio/build/build-variants.html&quot;&gt;build variant&lt;/a&gt; names and follow the pattern &lt;code&gt;compile&amp;lt;BuildVariant&amp;gt;Kotlin&lt;/code&gt;, for example, &lt;code&gt;compileDebugKotlin&lt;/code&gt;, &lt;code&gt;compileReleaseUnitTestKotlin&lt;/code&gt;.</source>
          <target state="translated">Androidプロジェクトのタスクの名前には、&lt;a href=&quot;https://developer.android.com/studio/build/build-variants.html&quot;&gt;ビルドバリアント&lt;/a&gt;名が含まれ、 &lt;code&gt;compile&amp;lt;BuildVariant&amp;gt;Kotlin&lt;/code&gt; パターンに従います（例えば、 &lt;code&gt;compileDebugKotlin&lt;/code&gt; 、 &lt;code&gt;compileReleaseUnitTestKotlin&lt;/code&gt; )。</target>
        </trans-unit>
        <trans-unit id="b01e22b1729a53f5c38e9b03b567bbe208d510c5" translate="yes" xml:space="preserve">
          <source>The names of these tasks were created from the formula: &lt;code&gt;run[Debug|Release]Executable&amp;lt;target name&amp;gt;&lt;/code&gt;, where &lt;code&gt;target name&lt;/code&gt; is the capitalized target name that we specified in the &lt;code&gt;build.gradle.kts&lt;/code&gt;&lt;code&gt;build.gradle&lt;/code&gt; file out of our build, &lt;code&gt;&quot;native&quot;&lt;/code&gt; in our case. Let's run the task in the IDE. For that, let's open the Gradle Tool Window and find the task in the list:</source>
          <target state="translated">これらのタスクの名前は、式 &lt;code&gt;run[Debug|Release]Executable&amp;lt;target name&amp;gt;&lt;/code&gt; から作成されました。ここで、 &lt;code&gt;target name&lt;/code&gt; は、ビルドの &lt;code&gt;build.gradle.kts&lt;/code&gt; &lt;code&gt;build.gradle&lt;/code&gt; ファイルで指定した大文字のターゲット名です。私たちの場合は &lt;code&gt;&quot;native&quot;&lt;/code&gt; 。IDEでタスクを実行してみましょう。そのために、Gradle Toolウィンドウを開いて、リストからタスクを見つけましょう。</target>
        </trans-unit>
        <trans-unit id="f0aa5ea5557fedda4c5d2598dc5dd22d0363ac01" translate="yes" xml:space="preserve">
          <source>The names should make it clear what the purpose of the entity is, so it's best to avoid using meaningless words (&lt;code&gt;Manager&lt;/code&gt;, &lt;code&gt;Wrapper&lt;/code&gt; etc.) in names.</source>
          <target state="translated">名前はエンティティの目的を明確にする必要があるため、名前に意味のない単語（ &lt;code&gt;Manager&lt;/code&gt; 、 &lt;code&gt;Wrapper&lt;/code&gt; など）を使用しないことをお勧めします。</target>
        </trans-unit>
        <trans-unit id="73a31785499746e1755c5fd02e03d5e8b58c34d0" translate="yes" xml:space="preserve">
          <source>The native memory can be allocated using the &lt;code&gt;NativePlacement&lt;/code&gt; interface, e.g.</source>
          <target state="translated">ネイティブメモリは、 &lt;code&gt;NativePlacement&lt;/code&gt; インターフェイスを使用して割り当てることができます。</target>
        </trans-unit>
        <trans-unit id="183994f4ebd6d698ee09d0ba15ca6b6ca68c9e19" translate="yes" xml:space="preserve">
          <source>The next lines are about providing linker and compiler options, which can vary depending on different target platforms. In our case, we are defining it for macOS (the &lt;code&gt;.osx&lt;/code&gt; suffix) and Linux (the &lt;code&gt;.linux&lt;/code&gt; suffix). Parameters without a suffix is also possible (e.g. &lt;code&gt;linkerOpts=&lt;/code&gt;) and will be applied to all platforms.</source>
          <target state="translated">次の行は、リンカーとコンパイラのオプションを提供することです。これらのオプションは、ターゲットプラットフォームによって異なる場合があります。私たちのケースでは、MacOSのためにそれを定義している（ &lt;code&gt;.osx&lt;/code&gt; 接尾辞）とLinux（ &lt;code&gt;.linux&lt;/code&gt; 接尾辞）。接尾辞のないパラメータも可能で（ &lt;code&gt;linkerOpts=&lt;/code&gt; ）、すべてのプラットフォームに適用されます。</target>
        </trans-unit>
        <trans-unit id="5a6c6de321d2f0ef15a3d35472d5a5225a93083f" translate="yes" xml:space="preserve">
          <source>The next part of the &lt;code&gt;&amp;lt;Framework&amp;gt;/Headers/Demo.h&lt;/code&gt; contains number type mappings between Kotlin/Native and &lt;code&gt;NSNumber&lt;/code&gt;. We have the base class called &lt;code&gt;DemoNumber&lt;/code&gt; in Objective-C and &lt;code&gt;KotlinNumber&lt;/code&gt; in Swift. It extends &lt;code&gt;NSNumber&lt;/code&gt;. There are also child classes per Kotlin number type:</source>
          <target state="translated">&lt;code&gt;&amp;lt;Framework&amp;gt;/Headers/Demo.h&lt;/code&gt; の次の部分には、Kotlin / Nativeと &lt;code&gt;NSNumber&lt;/code&gt; の間の数値型マッピングが含まれています。Objective-C &lt;code&gt;DemoNumber&lt;/code&gt; という基本クラスがあり、Swift &lt;code&gt;KotlinNumber&lt;/code&gt; があります。 &lt;code&gt;NSNumber&lt;/code&gt; を拡張します。Kotlin数値タイプごとに子クラスもあります。</target>
        </trans-unit>
        <trans-unit id="cfe4a47831305057cc6388a57b9e77a3a7e3a7a8" translate="yes" xml:space="preserve">
          <source>The next part of the &lt;code&gt;libnative_api.h&lt;/code&gt; file contains definitions of the types that are used in the library:</source>
          <target state="translated">&lt;code&gt;libnative_api.h&lt;/code&gt; ファイルの次の部分には、ライブラリで使用されるタイプの定義が含まれています。</target>
        </trans-unit>
        <trans-unit id="dc72aec2231c401cec520bbf86ad2595019584f0" translate="yes" xml:space="preserve">
          <source>The next step is going to prompt us on the Kotlin runtime library. By default the plugin selects the one that is associated to the currently installed version. Unless we want to create a different one, we can click Finish at this point after entering the project name and location.</source>
          <target state="translated">次のステップではKotlinのランタイムライブラリを確認します。デフォルトでは、プラグインは現在インストールされているバージョンに関連付けられているものを選択します。別のライブラリを作成したい場合を除いて、プロジェクト名と場所を入力した後、この時点で終了をクリックしてください。</target>
        </trans-unit>
        <trans-unit id="93716c2cabdff509bf9835ed635452819990ca4f" translate="yes" xml:space="preserve">
          <source>The next step is to call a C function pointer from a C pointer that we have from the &lt;code&gt;supply_fun()&lt;/code&gt; call:</source>
          <target state="translated">次のステップは、 &lt;code&gt;supply_fun()&lt;/code&gt; 呼び出しから取得したCポインターからC関数ポインターを呼び出すことです。</target>
        </trans-unit>
        <trans-unit id="4c075c67c98b72698b50bde83417679cfcaad540" translate="yes" xml:space="preserve">
          <source>The next step is to compile our application. We already covered the basics of compiling a Kotlin/Native application from the command line in the &lt;a href=&quot;basic-kotlin-native-app&quot;&gt;A Basic Kotlin/Native application&lt;/a&gt; tutorial. The only difference in this case is that the &lt;code&gt;cinterop&lt;/code&gt; generated part is implicitly included into the build: Let's call the following command:</source>
          <target state="translated">次のステップは、アプリケーションをコンパイルすることです。コマンドラインからのKotlin / Nativeアプリケーションのコンパイルの基本については、&lt;a href=&quot;basic-kotlin-native-app&quot;&gt;A基本的なKotlin / Nativeアプリケーションの&lt;/a&gt;チュートリアルですでに説明しました。この場合の唯一の違いは、 &lt;code&gt;cinterop&lt;/code&gt; で生成された部分が暗黙的にビルドに含まれることです。次のコマンドを呼び出します。</target>
        </trans-unit>
        <trans-unit id="29eb1a88978e11cb19e6153185329a8fdd184b9c" translate="yes" xml:space="preserve">
          <source>The next step is to create Greeting Data class that has two properties: &lt;em&gt;id&lt;/em&gt; and a &lt;em&gt;content&lt;/em&gt;</source>
          <target state="translated">次のステップでは、&lt;em&gt;id&lt;/em&gt;と&lt;em&gt;content&lt;/em&gt;という2つのプロパティを持つGreeting Dataクラスを作成します&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f2ba2b214cfaccb2ec50010bfe1a0d121ee2cd4b" translate="yes" xml:space="preserve">
          <source>The next step is to create a Run Configuration in IntelliJ IDEA under Tomcat / Local which deploys the WAR and starts up Tomcat.</source>
          <target state="translated">次のステップでは、Tomcat/Localの下にIntelliJ IDEAでRun Configurationを作成し、WARをデプロイしてTomcatを起動します。</target>
        </trans-unit>
        <trans-unit id="27ce517e143c3dea9eb55849f860e4c5596ec3f9" translate="yes" xml:space="preserve">
          <source>The next step is to decide which modules to configure (if the project has more than one module) and whether you want to add the runtime library to the project or use those provided by the current Kotlin plugin.</source>
          <target state="translated">次のステップでは、どのモジュールを設定するか(プロジェクトに複数のモジュールがある場合)、ランタイムライブラリをプロジェクトに追加するか、現在のKotlinプラグインで提供されているものを使用するかを決定します。</target>
        </trans-unit>
        <trans-unit id="22779d3ccc120e4892af96a829245aa095780550" translate="yes" xml:space="preserve">
          <source>The non-abstract subclasses should represent the (complete) C data type and thus specify size and alignment. Each such subclass must have a companion object which is a &lt;a href=&quot;-type/index&quot;&gt;Type&lt;/a&gt;.</source>
          <target state="translated">非抽象サブクラスは、（完全な）Cデータ型を表し、サイズと配置を指定する必要があります。そのような各サブクラスには、&lt;a href=&quot;-type/index&quot;&gt;Type&lt;/a&gt;であるコンパニオンオブジェクトが必要です。</target>
        </trans-unit>
        <trans-unit id="fc28129df689ae65c9fd83a31b9aa03dac9e8ced" translate="yes" xml:space="preserve">
          <source>The non-breaking space character</source>
          <target state="translated">壊れない空間キャラ</target>
        </trans-unit>
        <trans-unit id="e8f00eeeaaa301ab094d387f05d45fa33541dead" translate="yes" xml:space="preserve">
          <source>The nullable version &lt;code&gt;Nothing?&lt;/code&gt; will be used by the compiler when something is initialized with null and there is no other type information. In &lt;code&gt;val x = null&lt;/code&gt;, the type of &lt;code&gt;x&lt;/code&gt; will be &lt;code&gt;Nothing?&lt;/code&gt;. This type does not have the &quot;never returns normally&quot; semantics; instead, the compiler knows that the value will always be null.</source>
          <target state="translated">null許容バージョン &lt;code&gt;Nothing?&lt;/code&gt; 何かがnullで初期化され、他の型情報がない場合、コンパイラによって使用されます。では &lt;code&gt;val x = null&lt;/code&gt; 、のタイプ &lt;code&gt;x&lt;/code&gt; はなり &lt;code&gt;Nothing?&lt;/code&gt; 。このタイプには、「通常は戻らない」というセマンティクスはありません。代わりに、コンパイラは値が常にnullであることを認識しています。</target>
        </trans-unit>
        <trans-unit id="77363aca1573dd5dba20e28ad666c9c7fd83436a" translate="yes" xml:space="preserve">
          <source>The number is converted to a string and then the string is converted to a &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/math/BigDecimal.html&quot;&gt;BigDecimal&lt;/a&gt;.</source>
          <target state="translated">数値は文字列に変換され、次に文字列は&lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/math/BigDecimal.html&quot;&gt;BigDecimalに&lt;/a&gt;変換されます。</target>
        </trans-unit>
        <trans-unit id="bbb7b619e5deab250c82714dad5c6223da422d99" translate="yes" xml:space="preserve">
          <source>The number is converted to a string and then the string is converted to a &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/math/BigDecimal.html&quot;&gt;BigDecimal&lt;/a&gt;.</source>
          <target state="translated">数値は文字列に変換されてから、文字列は&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/math/BigDecimal.html&quot;&gt;BigDecimalに&lt;/a&gt;変換されます。</target>
        </trans-unit>
        <trans-unit id="bc9979a04405cfcd09395aa075f56f352dfb5b1c" translate="yes" xml:space="preserve">
          <source>The number of bits used to represent a Char in a binary form.</source>
          <target state="translated">Charを2進数で表現するために使用されるビット数です。</target>
        </trans-unit>
        <trans-unit id="a5aabbd23fb87b74097e1ccd4055f0b183ecbf87" translate="yes" xml:space="preserve">
          <source>The number of bits used to represent an instance of Byte in a binary form.</source>
          <target state="translated">Byteのインスタンスをバイナリ形式で表現するために使用されるビット数。</target>
        </trans-unit>
        <trans-unit id="fc5f8fcea457f48ba61aea0a6c6364e750d35bba" translate="yes" xml:space="preserve">
          <source>The number of bits used to represent an instance of Double in a binary form.</source>
          <target state="translated">Doubleのインスタンスをバイナリ形式で表現するために使用されるビット数。</target>
        </trans-unit>
        <trans-unit id="3ac96a9235bc1077029c5934186d743a5b00c197" translate="yes" xml:space="preserve">
          <source>The number of bits used to represent an instance of Float in a binary form.</source>
          <target state="translated">Float のインスタンスをバイナリ形式で表現するために使用されるビット数。</target>
        </trans-unit>
        <trans-unit id="0f9c3201d4f3bb80740106fd705fe9901bfc9490" translate="yes" xml:space="preserve">
          <source>The number of bits used to represent an instance of Int in a binary form.</source>
          <target state="translated">Int のインスタンスをバイナリ形式で表現するために使用されるビット数。</target>
        </trans-unit>
        <trans-unit id="881c588a79332a9f90d40c26e737596c51909376" translate="yes" xml:space="preserve">
          <source>The number of bits used to represent an instance of Long in a binary form.</source>
          <target state="translated">Longのインスタンスをバイナリ形式で表現するために使用されるビット数。</target>
        </trans-unit>
        <trans-unit id="3a2fa986a400a5de2289aa09e08c447c811e1ab0" translate="yes" xml:space="preserve">
          <source>The number of bits used to represent an instance of Short in a binary form.</source>
          <target state="translated">Short のインスタンスをバイナリ形式で表現するために使用されるビット数。</target>
        </trans-unit>
        <trans-unit id="b557b6ad22e0d4a32e6ecf5e7c42a83086397f62" translate="yes" xml:space="preserve">
          <source>The number of bits used to represent an instance of UByte in a binary form.</source>
          <target state="translated">UByte のインスタンスをバイナリ形式で表現するために使用されるビット数。</target>
        </trans-unit>
        <trans-unit id="04a46c8fcf471f6f7a2489fd5541b67d79b2dbba" translate="yes" xml:space="preserve">
          <source>The number of bits used to represent an instance of UInt in a binary form.</source>
          <target state="translated">UInt のインスタンスをバイナリ形式で表現するために使用されるビット数。</target>
        </trans-unit>
        <trans-unit id="970f51f6cf41ca82dcda9c5384dd1584581a3241" translate="yes" xml:space="preserve">
          <source>The number of bits used to represent an instance of ULong in a binary form.</source>
          <target state="translated">ULongのインスタンスをバイナリ形式で表現するために使用されるビット数。</target>
        </trans-unit>
        <trans-unit id="f405dad940dd8a9ba9986616021e6669d81ef332" translate="yes" xml:space="preserve">
          <source>The number of bits used to represent an instance of UShort in a binary form.</source>
          <target state="translated">UShort のインスタンスをバイナリ形式で表現するために使用されるビット数。</target>
        </trans-unit>
        <trans-unit id="7fca3ee96d6d11e61b4e40ce8aef39bbd3166f00" translate="yes" xml:space="preserve">
          <source>The number of bytes used to represent a Char in a binary form.</source>
          <target state="translated">Charをバイナリ形式で表現するために使用されるバイト数です。</target>
        </trans-unit>
        <trans-unit id="d455af0205d71a29c80b7797e96f36f72c818b20" translate="yes" xml:space="preserve">
          <source>The number of bytes used to represent an instance of Byte in a binary form.</source>
          <target state="translated">Byte のインスタンスをバイナリ形式で表現するために使用されるバイト数。</target>
        </trans-unit>
        <trans-unit id="cfb84d55b9d6ee08abf33db55d2a61462dded701" translate="yes" xml:space="preserve">
          <source>The number of bytes used to represent an instance of Double in a binary form.</source>
          <target state="translated">Double のインスタンスをバイナリ形式で表現するために使用されるバイト数。</target>
        </trans-unit>
        <trans-unit id="080e5eee27bb967010b8c2b300a0c20e8300d7a1" translate="yes" xml:space="preserve">
          <source>The number of bytes used to represent an instance of Float in a binary form.</source>
          <target state="translated">Float のインスタンスをバイナリ形式で表現するために使用されるバイト数。</target>
        </trans-unit>
        <trans-unit id="012737f61c97912b11277e0542ab793fcecbd8f6" translate="yes" xml:space="preserve">
          <source>The number of bytes used to represent an instance of Int in a binary form.</source>
          <target state="translated">Int のインスタンスをバイナリ形式で表現するために使用されるバイト数。</target>
        </trans-unit>
        <trans-unit id="ac50dee558bf2179b63147e5d4abcf881946deb1" translate="yes" xml:space="preserve">
          <source>The number of bytes used to represent an instance of Long in a binary form.</source>
          <target state="translated">Long のインスタンスをバイナリ形式で表現するために使用されるバイト数。</target>
        </trans-unit>
        <trans-unit id="d47711ab000d6ab309cdde940a4d6cc83958bbb7" translate="yes" xml:space="preserve">
          <source>The number of bytes used to represent an instance of Short in a binary form.</source>
          <target state="translated">Short のインスタンスをバイナリ形式で表現するために使用されるバイト数。</target>
        </trans-unit>
        <trans-unit id="5da103d9bfe814cb16e570a63e8fffdec6abede9" translate="yes" xml:space="preserve">
          <source>The number of bytes used to represent an instance of UByte in a binary form.</source>
          <target state="translated">UByte のインスタンスをバイナリ形式で表現するために使用されるバイト数。</target>
        </trans-unit>
        <trans-unit id="7aa018571731f4dfc20dc2f2b40bc661649fe4df" translate="yes" xml:space="preserve">
          <source>The number of bytes used to represent an instance of UInt in a binary form.</source>
          <target state="translated">UInt のインスタンスをバイナリ形式で表現するために使用されるバイト数。</target>
        </trans-unit>
        <trans-unit id="c4d88684784d0b5692fee9bc8fbbdcbfde1bb159" translate="yes" xml:space="preserve">
          <source>The number of bytes used to represent an instance of ULong in a binary form.</source>
          <target state="translated">バイナリ形式でULongのインスタンスを表現するために使用されるバイト数。</target>
        </trans-unit>
        <trans-unit id="de97fd8a16a598b6d753acf6fc495d892600d39e" translate="yes" xml:space="preserve">
          <source>The number of bytes used to represent an instance of UShort in a binary form.</source>
          <target state="translated">UShort のインスタンスをバイナリ形式で表現するために使用されるバイト数。</target>
        </trans-unit>
        <trans-unit id="802421b7bac6f95ce971296bce66f238a1ca7ee6" translate="yes" xml:space="preserve">
          <source>The official docs also have a very cool example with a &lt;a href=&quot;../../reference/type-safe-builders&quot;&gt; DSL for constructing HTML documents&lt;/a&gt;.</source>
          <target state="translated">公式ドキュメントには、&lt;a href=&quot;../../reference/type-safe-builders&quot;&gt;HTMLドキュメントを構築&lt;/a&gt;するためのDSLを使用した非常に優れた例もあります。</target>
        </trans-unit>
        <trans-unit id="9824ffa4fbac1aa2ba4df2857cc7d27ae42fbdf3" translate="yes" xml:space="preserve">
          <source>The only target for which it is not available is &lt;a href=&quot;https://en.wikipedia.org/wiki/WebAssembly&quot;&gt;WebAssembly&lt;/a&gt;.</source>
          <target state="translated">利用できない唯一のターゲットは&lt;a href=&quot;https://en.wikipedia.org/wiki/WebAssembly&quot;&gt;WebAssembly&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="20601b96604d0e7211b7510d021f94ac0577f4a7" translate="yes" xml:space="preserve">
          <source>The only thing left to do is compile our application (Build|Build Project), and once the JavaScript files have been generated, we can open the &lt;code&gt;index.html&lt;/code&gt; file in the browser and see the result in the console debug window.</source>
          <target state="translated">あとは、アプリケーションをコンパイルして（Build | Build Project）、JavaScriptファイルが生成されたら、ブラウザーで &lt;code&gt;index.html&lt;/code&gt; ファイルを開いて、コンソールのデバッグウィンドウで結果を確認できます。</target>
        </trans-unit>
        <trans-unit id="940b1bdb9d47159d1535cf808141916fc2b5f10e" translate="yes" xml:space="preserve">
          <source>The operation doesn't preserve copied file attributes such as creation/modification date, permissions, etc.</source>
          <target state="translated">この操作では、コピーされたファイルの作成/変更日やパーミッションなどの属性は保存されません。</target>
        </trans-unit>
        <trans-unit id="b9a452f893e9486c5fbe89e3c1a52b0da8c35684" translate="yes" xml:space="preserve">
          <source>The operation is &lt;em&gt;intermediate&lt;/em&gt; and &lt;em&gt;stateful&lt;/em&gt;.</source>
          <target state="translated">操作は&lt;em&gt;中間的&lt;/em&gt;で&lt;em&gt;ステートフル&lt;/em&gt;です。</target>
        </trans-unit>
        <trans-unit id="64f2d6f436a63697c12d9826dd0b449a2c8ece4d" translate="yes" xml:space="preserve">
          <source>The operation is &lt;em&gt;intermediate&lt;/em&gt; and &lt;em&gt;stateless&lt;/em&gt;.</source>
          <target state="translated">操作は&lt;em&gt;中間&lt;/em&gt;で&lt;em&gt;ステートレス&lt;/em&gt;です。</target>
        </trans-unit>
        <trans-unit id="2f74c9f051d5d0a5178895ef9787aac4f50f4820" translate="yes" xml:space="preserve">
          <source>The operation is &lt;em&gt;intermediate&lt;/em&gt; for this sequence and &lt;em&gt;terminal&lt;/em&gt; and &lt;em&gt;stateful&lt;/em&gt; for the &lt;a href=&quot;minus#kotlin.sequences%24minus%28kotlin.sequences.Sequence%28%28kotlin.sequences.minus.T%29%29%2C+kotlin.sequences.Sequence%28%28kotlin.sequences.minus.T%29%29%29%2Felements&quot;&gt;elements&lt;/a&gt; sequence.</source>
          <target state="translated">動作は、&lt;em&gt;中間&lt;/em&gt;この配列および&lt;em&gt;端末&lt;/em&gt;と&lt;em&gt;ステートフル&lt;/em&gt;ための&lt;a href=&quot;minus#kotlin.sequences%24minus%28kotlin.sequences.Sequence%28%28kotlin.sequences.minus.T%29%29%2C+kotlin.sequences.Sequence%28%28kotlin.sequences.minus.T%29%29%29%2Felements&quot;&gt;要素&lt;/a&gt;配列。</target>
        </trans-unit>
        <trans-unit id="790886232e90f42fd32ca4859b4baabd53b9cbd8" translate="yes" xml:space="preserve">
          <source>The operation is &lt;em&gt;intermediate&lt;/em&gt; for this sequence and &lt;em&gt;terminal&lt;/em&gt; and &lt;em&gt;stateful&lt;/em&gt; for the &lt;a href=&quot;minus#kotlin.sequences%24minus(kotlin.sequences.Sequence((kotlin.sequences.minus.T)),%20kotlin.sequences.Sequence((kotlin.sequences.minus.T)))/elements&quot;&gt;elements&lt;/a&gt; sequence.</source>
          <target state="translated">動作は、&lt;em&gt;中間&lt;/em&gt;この配列および&lt;em&gt;端末&lt;/em&gt;と&lt;em&gt;ステートフル&lt;/em&gt;ための&lt;a href=&quot;minus#kotlin.sequences%24minus(kotlin.sequences.Sequence((kotlin.sequences.minus.T)),%20kotlin.sequences.Sequence((kotlin.sequences.minus.T)))/elements&quot;&gt;要素&lt;/a&gt;配列。</target>
        </trans-unit>
        <trans-unit id="f90173c5f7dc2e732f31878b5387f1009c2ad309" translate="yes" xml:space="preserve">
          <source>The operation is &lt;em&gt;terminal&lt;/em&gt;.</source>
          <target state="translated">操作は&lt;em&gt;ターミナル&lt;/em&gt;です。</target>
        </trans-unit>
        <trans-unit id="24cec715dc71cea63c8c77aa342afd935860c2d6" translate="yes" xml:space="preserve">
          <source>The operations on floating point numbers discussed in this section are:</source>
          <target state="translated">このセクションで議論されている浮動小数点数に対する操作は、以下の通りです。</target>
        </trans-unit>
        <trans-unit id="c81054e9fa59c990a7f0009d1471af7d0d80d085" translate="yes" xml:space="preserve">
          <source>The operator &lt;code&gt;plus&lt;/code&gt; provides a way to add key-value pair(s) to a read-only map producing a new map, however there was not a simple way to do the opposite: to remove a key from the map you have to resort to less straightforward ways to like &lt;code&gt;Map.filter()&lt;/code&gt; or &lt;code&gt;Map.filterKeys()&lt;/code&gt;. Now the operator &lt;code&gt;minus&lt;/code&gt; fills this gap. There are 4 overloads available: for removing a single key, a collection of keys, a sequence of keys and an array of keys.</source>
          <target state="translated">演算子 &lt;code&gt;plus&lt;/code&gt; は、キーと値のペアを読み取り専用のマップに追加して新しいマップを生成する方法を提供しますが、その逆の簡単な方法はありませんでした：頼らなければならないマップからキーを削除する &lt;code&gt;Map.filter()&lt;/code&gt; や &lt;code&gt;Map.filterKeys()&lt;/code&gt; のように簡単な方法ではありません。これで、オペレーターの &lt;code&gt;minus&lt;/code&gt; がこのギャップを埋めます。使用可能なオーバーロードは4つあります。単一のキー、キーのコレクション、キーのシーケンス、およびキーの配列を削除するためです。</target>
        </trans-unit>
        <trans-unit id="a3dfe13bda3af06c0e25457985a11e6db0a3ea90" translate="yes" xml:space="preserve">
          <source>The order of elements is an important aspect of certain collection types. For example, two lists of the same elements are not equal if their elements are ordered differently.</source>
          <target state="translated">要素の順序は、ある種のコレクションタイプの重要な側面です。例えば、同じ要素を持つ2つのリストは、要素の順序が異なる場合には等しくありません。</target>
        </trans-unit>
        <trans-unit id="97cb339b9434116a61ea466562966c5cfa7e6e7a" translate="yes" xml:space="preserve">
          <source>The order of operations execution is different as well: &lt;code&gt;Sequence&lt;/code&gt; performs all the processing steps one-by-one for every single element. In turn, &lt;code&gt;Iterable&lt;/code&gt; completes each step for the whole collection and then proceeds to the next step.</source>
          <target state="translated">操作の実行順序も異なります &lt;code&gt;Sequence&lt;/code&gt; は、すべての要素に対して1つずつすべての処理ステップを実行します。次に、 &lt;code&gt;Iterable&lt;/code&gt; はコレクション全体の各ステップを完了してから、次のステップに進みます。</target>
        </trans-unit>
        <trans-unit id="812e3a1f04f0d82a55115416fefd4d8f871219e6" translate="yes" xml:space="preserve">
          <source>The original exception is handled by the parent only when all its children terminate, which is demonstrated by the following example.</source>
          <target state="translated">元の例外は、すべての子が終了した場合にのみ親によって処理されます。</target>
        </trans-unit>
        <trans-unit id="b74ff8ee45b0b8f3cea227a5cb8b0ca2512e0fa1" translate="yes" xml:space="preserve">
          <source>The output is:</source>
          <target state="translated">出力されます。</target>
        </trans-unit>
        <trans-unit id="21b2e4b0974b9e68e9c52fc5e687c75f3f109501" translate="yes" xml:space="preserve">
          <source>The output it produces with &lt;code&gt;-Dkotlinx.coroutines.debug&lt;/code&gt; JVM option is similar to:</source>
          <target state="translated">&lt;code&gt;-Dkotlinx.coroutines.debug&lt;/code&gt; JVMオプションで生成される出力は、次のようになります。</target>
        </trans-unit>
        <trans-unit id="335f16bba6cd2578184d6190d9013ac4ec39e185" translate="yes" xml:space="preserve">
          <source>The output of a config script with &lt;code&gt;--libs&lt;/code&gt; will be passed as a &lt;code&gt;-linkedArgs&lt;/code&gt;&lt;code&gt;kotlinc&lt;/code&gt; flag value (quoted) when compiling.</source>
          <target state="translated">&lt;code&gt;--libs&lt;/code&gt; を使用した構成スクリプトの出力は、コンパイル時に &lt;code&gt;-linkedArgs&lt;/code&gt; &lt;code&gt;kotlinc&lt;/code&gt; フラグ値（引用）として渡されます。</target>
        </trans-unit>
        <trans-unit id="a335f7db5ad6c9bad17c284454dcaeefbd6be278" translate="yes" xml:space="preserve">
          <source>The output of this code is (with &lt;a href=&quot;https://github.com/Kotlin/kotlinx.coroutines/blob/master/docs/coroutine-context-and-dispatchers.md#debugging-coroutines-and-threads&quot;&gt;debug&lt;/a&gt;):</source>
          <target state="translated">このコードの出力は次のとおりです（&lt;a href=&quot;https://github.com/Kotlin/kotlinx.coroutines/blob/master/docs/coroutine-context-and-dispatchers.md#debugging-coroutines-and-threads&quot;&gt;debugを使用&lt;/a&gt;）：</target>
        </trans-unit>
        <trans-unit id="d91d0dd8fa3a619861392f5c074fea2d8db4eaf2" translate="yes" xml:space="preserve">
          <source>The output of this code is:</source>
          <target state="translated">このコードの出力は</target>
        </trans-unit>
        <trans-unit id="647a971dfd3700d13cfdc057be9aa0bc71494501" translate="yes" xml:space="preserve">
          <source>The output of this code shows that the &lt;code&gt;filter()&lt;/code&gt; and &lt;code&gt;map()&lt;/code&gt; functions are called only when building the result list. So, you first see the line of text &lt;code&gt;&amp;ldquo;Lengths of..&amp;rdquo;&lt;/code&gt; and then the sequence processing starts. Note that for elements left after filtering, the map executes before filtering the next element. When the result size reaches 4, the processing stops because it's the largest possible size that &lt;code&gt;take(4)&lt;/code&gt; can return.</source>
          <target state="translated">このコードの出力は、 &lt;code&gt;filter()&lt;/code&gt; および &lt;code&gt;map()&lt;/code&gt; 関数が結果リストを作成するときにのみ呼び出されることを示しています。したがって、最初に &lt;code&gt;&amp;ldquo;Lengths of..&amp;rdquo;&lt;/code&gt; テキスト行が表示され、次にシーケンス処理が開始されます。フィルタリング後に残った要素については、次の要素をフィルタリングする前にマップが実行されることに注意してください。結果のサイズが4に達すると、 &lt;code&gt;take(4)&lt;/code&gt; が返すことができる最大サイズであるため、処理が停止します。</target>
        </trans-unit>
        <trans-unit id="4914ca42a65eab132541007ef394cf246de086f7" translate="yes" xml:space="preserve">
          <source>The output of this code with &lt;code&gt;-Dkotlinx.coroutines.debug&lt;/code&gt; JVM option is:</source>
          <target state="translated">&lt;code&gt;-Dkotlinx.coroutines.debug&lt;/code&gt; JVMオプションを使用したこのコードの出力は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="ef205ce911c3cb52ce12493307210d6d78d5dcb8" translate="yes" xml:space="preserve">
          <source>The output of this code with the &lt;code&gt;-Dkotlinx.coroutines.debug&lt;/code&gt; JVM option is:</source>
          <target state="translated">&lt;code&gt;-Dkotlinx.coroutines.debug&lt;/code&gt; JVMオプションを使用したこのコードの出力は、次のとおりです。</target>
        </trans-unit>
        <trans-unit id="fdcf4102afb246d995583e41d5abf443dc9b24d6" translate="yes" xml:space="preserve">
          <source>The output of this example is:</source>
          <target state="translated">この例の出力は</target>
        </trans-unit>
        <trans-unit id="d7f56deac4aeaab1be47a9075fd39d0cd515a13f" translate="yes" xml:space="preserve">
          <source>The output of this is a blank page that prints &lt;code&gt;Hello JavaScript!&lt;/code&gt; to the console.</source>
          <target state="translated">この出力は、 &lt;code&gt;Hello JavaScript!&lt;/code&gt; を出力する空白のページです。コンソールに。</target>
        </trans-unit>
        <trans-unit id="c7adcbeb9a00e6f9f8d55d348527ceb949cebeb0" translate="yes" xml:space="preserve">
          <source>The output should be:</source>
          <target state="translated">出力されるはずです。</target>
        </trans-unit>
        <trans-unit id="0b8e02788f842ec131e59334f158260f8f72ffc7" translate="yes" xml:space="preserve">
          <source>The output will be similar to the the following one, albeit the processor ids that receive each specific integer may be different:</source>
          <target state="translated">出力は、各特定の整数を受信するプロセッサIDが異なる場合がありますが、以下のものに似ています。</target>
        </trans-unit>
        <trans-unit id="dacb06aada01cf9353bf2a419b476781dd3c13a9" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the &lt;a href=&quot;append#kotlin.text.StringBuilder%24append(kotlin.Any?)/value&quot;&gt;value&lt;/a&gt; were converted to a string by the &lt;code&gt;value.toString()&lt;/code&gt; method, and then that string was appended to this string builder.</source>
          <target state="translated">全体的な効果は、 &lt;code&gt;value.toString()&lt;/code&gt; メソッドによって&lt;a href=&quot;append#kotlin.text.StringBuilder%24append(kotlin.Any?)/value&quot;&gt;値&lt;/a&gt;が文字列に変換され、その文字列がこの文字列ビルダーに追加された場合とまったく同じです。</target>
        </trans-unit>
        <trans-unit id="2fa46c20aa677e08c4fbabd2c01f13037e7e1a67" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the &lt;a href=&quot;append#kotlin.text.StringBuilder%24append(kotlin.Boolean)/value&quot;&gt;value&lt;/a&gt; were converted to a string by the &lt;code&gt;value.toString()&lt;/code&gt; method, and then that string was appended to this string builder.</source>
          <target state="translated">全体的な効果は、 &lt;code&gt;value.toString()&lt;/code&gt; メソッドによって&lt;a href=&quot;append#kotlin.text.StringBuilder%24append(kotlin.Boolean)/value&quot;&gt;値&lt;/a&gt;が文字列に変換され、その文字列がこの文字列ビルダーに追加された場合とまったく同じです。</target>
        </trans-unit>
        <trans-unit id="3d95d1d469be2176ebbc72a21468acef591255ad" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.Any?)/value&quot;&gt;value&lt;/a&gt; were converted to a string by the &lt;code&gt;value.toString()&lt;/code&gt; method, and then that string was inserted into this string builder at the specified &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.Any?)/index&quot;&gt;index&lt;/a&gt;.</source>
          <target state="translated">全体的な効果は、 &lt;code&gt;value.toString()&lt;/code&gt; メソッドによって&lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.Any?)/value&quot;&gt;値&lt;/a&gt;が文字列に変換され、その文字列が指定された&lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.Any?)/index&quot;&gt;インデックス&lt;/a&gt;でこの文字列ビルダーに挿入された場合とまったく同じです。</target>
        </trans-unit>
        <trans-unit id="76acc76cfe7700de42074cf269fd6d05489f7e96" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.Boolean)/value&quot;&gt;value&lt;/a&gt; were converted to a string by the &lt;code&gt;value.toString()&lt;/code&gt; method, and then that string was inserted into this string builder at the specified &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.Boolean)/index&quot;&gt;index&lt;/a&gt;.</source>
          <target state="translated">全体的な効果は、 &lt;code&gt;value.toString()&lt;/code&gt; メソッドによって&lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.Boolean)/value&quot;&gt;値&lt;/a&gt;が文字列に変換され、その文字列が指定された&lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.Boolean)/index&quot;&gt;インデックス&lt;/a&gt;でこの文字列ビルダーに挿入された場合とまったく同じです。</target>
        </trans-unit>
        <trans-unit id="b56500d82b30990e46ae5220b62e1c3f4e225003" translate="yes" xml:space="preserve">
          <source>The overriding constructor must have the same parameter names and types as the overridden one.</source>
          <target state="translated">オーバーライドするコンストラクタは、オーバーライドするものと同じパラメータ名と型を持つ必要があります。</target>
        </trans-unit>
        <trans-unit id="d0fd3de86e4826ba8c7cde26e87523bae54839bc" translate="yes" xml:space="preserve">
          <source>The packages from platform libraries are available by default. No special link flags need to be specified to use them. &lt;code&gt;Kotlin/Native&lt;/code&gt; compiler automatically detects which of the platform libraries have been accessed and automatically links the needed libraries.</source>
          <target state="translated">プラットフォームライブラリのパッケージは、デフォルトで使用できます。それらを使用するために特別なリンクフラグを指定する必要はありません。 &lt;code&gt;Kotlin/Native&lt;/code&gt; コンパイラは、アクセスされたプラットフォームライブラリを自動的に検出し、必要なライブラリを自動的にリンクします。</target>
        </trans-unit>
        <trans-unit id="f9eac82235030e7e86a0bff236552f847d9867dd" translate="yes" xml:space="preserve">
          <source>The parameter is declared in a member function and one of the corresponding parameters in the super functions is optional.</source>
          <target state="translated">パラメータはメンバ関数内で宣言され、スーパー関数内の対応するパラメータのうちの1つはオプションです。</target>
        </trans-unit>
        <trans-unit id="1a311c087dc5f415abb270981ad04ec98ba47164" translate="yes" xml:space="preserve">
          <source>The parameter must not &lt;a href=&quot;#variable-number-of-arguments-varargs&quot;&gt;accept variable number of arguments&lt;/a&gt; and must have no &lt;a href=&quot;#default-arguments&quot;&gt;default value&lt;/a&gt;.</source>
          <target state="translated">パラメータは&lt;a href=&quot;#variable-number-of-arguments-varargs&quot;&gt;可変数の引数&lt;/a&gt;を受け入れてはならず、&lt;a href=&quot;#default-arguments&quot;&gt;デフォルト値を&lt;/a&gt;持たない必要があります。</target>
        </trans-unit>
        <trans-unit id="85604054f8838d2bde0848abdc31a44140b69283" translate="yes" xml:space="preserve">
          <source>The parameter of &lt;code&gt;@JsName&lt;/code&gt; is required to be a constant string literal which is a valid identifier. The compiler will report an error on any attempt to pass non-identifier string to &lt;code&gt;@JsName&lt;/code&gt;. The following example produces a compile-time error:</source>
          <target state="translated">&lt;code&gt;@JsName&lt;/code&gt; のパラメーターは、有効な識別子である定数文字列リテラルである必要があります。コンパイラは、識別子以外の文字列を &lt;code&gt;@JsName&lt;/code&gt; に渡そうとすると、エラーを報告します。次の例では、コンパイル時エラーが発生します。</target>
        </trans-unit>
        <trans-unit id="d09d94c8171c7316821713755fce66dc3c85e74a" translate="yes" xml:space="preserve">
          <source>The parameter of &lt;code&gt;js&lt;/code&gt; is required to be a string constant. So, the following code is incorrect:</source>
          <target state="translated">&lt;code&gt;js&lt;/code&gt; のパラメータは文字列定数である必要があります。したがって、次のコードは正しくありません。</target>
        </trans-unit>
        <trans-unit id="64419b25b7715086a3a5cdbe138547b81a0a98a1" translate="yes" xml:space="preserve">
          <source>The parameter type of a function-typed parameter (the user is passing a function that can handle any &lt;code&gt;Fruit&lt;/code&gt;, and it will be given an &lt;code&gt;Apple&lt;/code&gt;)</source>
          <target state="translated">関数型パラメーターのパラメーター型（ユーザーは、任意の &lt;code&gt;Fruit&lt;/code&gt; を処理できる関数を渡しており、 &lt;code&gt;Apple&lt;/code&gt; が提供されます）</target>
        </trans-unit>
        <trans-unit id="6ef05f581070101fa2afecc255e98671537cdea0" translate="yes" xml:space="preserve">
          <source>The parameters and the return type are specified in the same way as for regular functions, except that the parameter types can be omitted if they can be inferred from context:</source>
          <target state="translated">パラメータと戻り値の型は、コンテキストから推測できる場合にはパラメータの型を省略できることを除いては、正規の関数と同じように指定します。</target>
        </trans-unit>
        <trans-unit id="d2818a5f4b17e0f3d50df0846a19518863e09067" translate="yes" xml:space="preserve">
          <source>The parameters of &lt;code&gt;provideDelegate&lt;/code&gt; are the same as for &lt;code&gt;getValue&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;provideDelegate&lt;/code&gt; のパラメーターは &lt;code&gt;getValue&lt;/code&gt; の場合と同じです。</target>
        </trans-unit>
        <trans-unit id="87e2c98795ae2a97eb179a3bb9ccc1f2e2c982d8" translate="yes" xml:space="preserve">
          <source>The passed type must satisfy all conditions of the &lt;code&gt;where&lt;/code&gt; clause simultaneously. In the above example, the &lt;code&gt;T&lt;/code&gt; type must implement &lt;em&gt;both&lt;/em&gt;&lt;code&gt;CharSequence&lt;/code&gt; and &lt;code&gt;Comparable&lt;/code&gt;.</source>
          <target state="translated">渡された型は、 &lt;code&gt;where&lt;/code&gt; 句のすべての条件を同時に満たす必要があります。上記の例では、 &lt;code&gt;T&lt;/code&gt; 型は &lt;code&gt;CharSequence&lt;/code&gt; と &lt;code&gt;Comparable&lt;/code&gt; の&lt;em&gt;両方を&lt;/em&gt;実装する必要があります。</target>
        </trans-unit>
        <trans-unit id="0f70942d020a14104380fd6e7920e316921b42c6" translate="yes" xml:space="preserve">
          <source>The path refers to the default output location that IntelliJ IDEA uses when we compile the application. Below we'll see how to change this.</source>
          <target state="translated">パスはIntelliJ IDEAがアプリケーションをコンパイルする際に使用するデフォルトの出力先を参照します。以下では、これを変更する方法を見ていきます。</target>
        </trans-unit>
        <trans-unit id="38dc6771af81ffcbac99f06b8c7fb1ebccf80f9d" translate="yes" xml:space="preserve">
          <source>The pattern string of this regular expression.</source>
          <target state="translated">この正規表現のパターン文字列。</target>
        </trans-unit>
        <trans-unit id="1144f4eed1bc15fed420102b18cb1c4e49c25335" translate="yes" xml:space="preserve">
          <source>The pattern where a coroutine is producing a sequence of elements is quite common. This is a part of &lt;em&gt;producer-consumer&lt;/em&gt; pattern that is often found in concurrent code. You could abstract such a producer into a function that takes channel as its parameter, but this goes contrary to common sense that results must be returned from functions.</source>
          <target state="translated">コルーチンが要素のシーケンスを生成するパターンは非常に一般的です。これは、並行コードでよく見られる&lt;em&gt;プロデューサー/コンシューマー&lt;/em&gt;パターンの一部です。そのようなプロデューサーを、channelをパラメーターとして取る関数に抽象化することもできますが、これは関数から結果を返さなければならないという常識に反しています。</target>
        </trans-unit>
        <trans-unit id="0452bcbdd609690466ea082ea5af90749aa8dcc5" translate="yes" xml:space="preserve">
          <source>The placeholder &lt;code&gt;&amp;lt;...&amp;gt;&lt;/code&gt; should be replaced with one of the plugin names that can be found in further sections.</source>
          <target state="translated">プレースホルダー &lt;code&gt;&amp;lt;...&amp;gt;&lt;/code&gt; は、以降のセクションで見つけることができるプラグイン名の1つに置き換える必要があります。</target>
        </trans-unit>
        <trans-unit id="02d885dcfef73f7197c98c6f94fc980ae42855f5" translate="yes" xml:space="preserve">
          <source>The plugin allows you to customize the pom generated for the publication with the &lt;code&gt;pom&lt;/code&gt; code block available for every component:</source>
          <target state="translated">プラグインを使用すると、すべてのコンポーネントで使用可能な &lt;code&gt;pom&lt;/code&gt; コードブロックを使用して、パブリケーション用に生成されたpomをカスタマイズできます。</target>
        </trans-unit>
        <trans-unit id="73896d94724b0c15c533e7832f50fc2c5d439771" translate="yes" xml:space="preserve">
          <source>The plugin allows you to declare dependencies on files and other projects using traditional Gradle's mechanism of configurations. The plugin supports Kotlin multiplatform projects allowing you to declare the &lt;code&gt;expectedBy&lt;/code&gt; dependencies</source>
          <target state="translated">プラグインを使用すると、従来のGradleの構成メカニズムを使用して、ファイルや他のプロジェクトへの依存関係を宣言できます。このプラグインはKotlinマルチプラットフォームプロジェクトをサポートし、 &lt;code&gt;expectedBy&lt;/code&gt; 依存関係を宣言できます</target>
        </trans-unit>
        <trans-unit id="e2b8c11954d8c4f9f34c307b3e3ea0e12583e5af" translate="yes" xml:space="preserve">
          <source>The plugin builds a test executable for all the targets specified for the &lt;code&gt;test&lt;/code&gt; component. If the current host platform is included in this list the test running tasks are also created. To run tests, execute the standard lifecycle &lt;code&gt;check&lt;/code&gt; task:</source>
          <target state="translated">プラグインは、 &lt;code&gt;test&lt;/code&gt; コンポーネントに指定されたすべてのターゲットのテスト実行可能ファイルをビルドします。現在のホストプラットフォームがこのリストに含まれている場合、テスト実行タスクも作成されます。テストを実行するには、標準のライフサイクル &lt;code&gt;check&lt;/code&gt; タスクを実行します。</target>
        </trans-unit>
        <trans-unit id="cbd612ac393a456f8773735c05ddbd5f91419396" translate="yes" xml:space="preserve">
          <source>The plugin creates a compilation task for each combination of the target, output kind, and build type. The tasks have the following naming convention:</source>
          <target state="translated">このプラグインは、ターゲット、出力の種類、ビルドタイプの組み合わせごとにコンパイルタスクを作成します。タスクの命名規則は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="b7797d4ea1281347f08b98f3d1593b5740b623cc" translate="yes" xml:space="preserve">
          <source>The plugin is shipped with a customized version of the &lt;code&gt;kotlinx.serialization&lt;/code&gt; plugin. To use it you don't have to add new buildscript dependencies, just apply the plugins and add a dependency on the serialization library:</source>
          <target state="translated">プラグインは、 &lt;code&gt;kotlinx.serialization&lt;/code&gt; プラグインのカスタマイズバージョンに同梱されています。これを使用するには、新しいbuildscript依存関係を追加する必要はありません。プラグインを適用して、シリアル化ライブラリに依存関係を追加するだけです。</target>
        </trans-unit>
        <trans-unit id="a5b5cad9084adc7ffa681b4e8b7b6b009920bbab" translate="yes" xml:space="preserve">
          <source>The plugin option format is: &lt;code&gt;-P plugin:&amp;lt;plugin id&amp;gt;:&amp;lt;key&amp;gt;=&amp;lt;value&amp;gt;&lt;/code&gt;. Options can be repeated.</source>
          <target state="translated">プラグインオプションの形式は次のとおりです。- &lt;code&gt;-P plugin:&amp;lt;plugin id&amp;gt;:&amp;lt;key&amp;gt;=&amp;lt;value&amp;gt;&lt;/code&gt; 。オプションは繰り返すことができます。</target>
        </trans-unit>
        <trans-unit id="4b96dd9cca135b083ee411ceef82d46edf74c104" translate="yes" xml:space="preserve">
          <source>The plugin specifies the following annotations: &lt;a href=&quot;http://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/stereotype/Component.html&quot;&gt;&lt;code&gt;@Component&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/scheduling/annotation/Async.html&quot;&gt;&lt;code&gt;@Async&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;http://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/transaction/annotation/Transactional.html&quot;&gt;&lt;code&gt;@Transactional&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;http://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/cache/annotation/Cacheable.html&quot;&gt;&lt;code&gt;@Cacheable&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://docs.spring.io/spring-boot/docs/current/api/org/springframework/boot/test/context/SpringBootTest.html&quot;&gt;&lt;code&gt;@SpringBootTest&lt;/code&gt;&lt;/a&gt;. Thanks to meta-annotations support classes annotated with &lt;a href=&quot;https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/context/annotation/Configuration.html&quot;&gt;&lt;code&gt;@Configuration&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/stereotype/Controller.html&quot;&gt;&lt;code&gt;@Controller&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/bind/annotation/RestController.html&quot;&gt;&lt;code&gt;@RestController&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/stereotype/Service.html&quot;&gt;&lt;code&gt;@Service&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/stereotype/Repository.html&quot;&gt;&lt;code&gt;@Repository&lt;/code&gt;&lt;/a&gt; are automatically opened since these annotations are meta-annotated with &lt;a href=&quot;http://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/stereotype/Component.html&quot;&gt;&lt;code&gt;@Component&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">：プラグインは、以下のアノテーションを指定&lt;a href=&quot;http://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/stereotype/Component.html&quot;&gt; &lt;code&gt;@Component&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/scheduling/annotation/Async.html&quot;&gt; &lt;code&gt;@Async&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;http://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/transaction/annotation/Transactional.html&quot;&gt; &lt;code&gt;@Transactional&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;http://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/cache/annotation/Cacheable.html&quot;&gt; &lt;code&gt;@Cacheable&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;https://docs.spring.io/spring-boot/docs/current/api/org/springframework/boot/test/context/SpringBootTest.html&quot;&gt; &lt;code&gt;@SpringBootTest&lt;/code&gt; を&lt;/a&gt;。メタ注釈のおかげでで注釈を付けたクラスをサポート&lt;a href=&quot;https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/context/annotation/Configuration.html&quot;&gt; &lt;code&gt;@Configuration&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/stereotype/Controller.html&quot;&gt; &lt;code&gt;@Controller&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/bind/annotation/RestController.html&quot;&gt; &lt;code&gt;@RestController&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/stereotype/Service.html&quot;&gt; &lt;code&gt;@Service&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/stereotype/Repository.html&quot;&gt; &lt;code&gt;@Repository&lt;/code&gt; &lt;/a&gt;これらの注釈がメタ注釈付きであるため、自動的に開かれますが&lt;a href=&quot;http://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/stereotype/Component.html&quot;&gt; &lt;code&gt;@Component&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="422a0ed13a769b30fb09b25e92467921db8dd51b" translate="yes" xml:space="preserve">
          <source>The plugin uses the same notation as the compiler. By default, test component uses the same targets as specified for the main one.</source>
          <target state="translated">プラグインはコンパイラと同じ表記法を使用します。デフォルトでは、テストコンポーネントはメインコンポーネントに指定されたものと同じターゲットを使用します。</target>
        </trans-unit>
        <trans-unit id="1f3c2f2fca540697d8f63e00a5a21435f0484957" translate="yes" xml:space="preserve">
          <source>The podspec generated includes a path to an output framework and script phases which automate building this framework during a build process of an Xcode project. Some fields of the podspec file can be configured using the &lt;code&gt;kotlin.cocoapods { ... }&lt;/code&gt; code block.</source>
          <target state="translated">生成されたpodspecには、出力フレームワークへのパスと、Xcodeプロジェクトのビルドプロセス中にこのフレームワークのビルドを自動化するスクリプトフェーズが含まれています。podspecファイルの一部のフィールドは、kotlin.cocoapods &lt;code&gt;kotlin.cocoapods { ... }&lt;/code&gt; コードブロックを使用して構成できます。</target>
        </trans-unit>
        <trans-unit id="4f2f6c39a4cfc0d578583a59ccc054d34affa473" translate="yes" xml:space="preserve">
          <source>The pointer with an opaque type.</source>
          <target state="translated">不透明なタイプのポインタ。</target>
        </trans-unit>
        <trans-unit id="cac38148225622f1c3ccca3dceed3d6a499e0217" translate="yes" xml:space="preserve">
          <source>The possible values of &lt;a href=&quot;returns#kotlin.contracts.ContractBuilder%24returns%28kotlin.Any%29%2Fvalue&quot;&gt;value&lt;/a&gt; are limited to &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt; or &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;returns#kotlin.contracts.ContractBuilder%24returns%28kotlin.Any%29%2Fvalue&quot;&gt;value&lt;/a&gt;の可能な値は、 &lt;code&gt;true&lt;/code&gt; 、 &lt;code&gt;false&lt;/code&gt; 、または &lt;code&gt;null&lt;/code&gt; に制限されています。</target>
        </trans-unit>
        <trans-unit id="ff2c8804ee232db23ae3d579f25ad98024549ce9" translate="yes" xml:space="preserve">
          <source>The possible values of &lt;a href=&quot;returns#kotlin.contracts.ContractBuilder%24returns(kotlin.Any?)/value&quot;&gt;value&lt;/a&gt; are limited to &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt; or &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">可能な値の&lt;a href=&quot;returns#kotlin.contracts.ContractBuilder%24returns(kotlin.Any?)/value&quot;&gt;値&lt;/a&gt;は、 &lt;code&gt;true&lt;/code&gt; 、 &lt;code&gt;false&lt;/code&gt; 、または &lt;code&gt;null&lt;/code&gt; に制限されています。</target>
        </trans-unit>
        <trans-unit id="db453765e0a754bcf108983d99d14a9cceb4e257" translate="yes" xml:space="preserve">
          <source>The predicates in &lt;code&gt;filter()&lt;/code&gt; can only check the values of the elements. If you want to use element positions in the filter, use &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/filter-indexed&quot;&gt;&lt;code&gt;filterIndexed()&lt;/code&gt;&lt;/a&gt;. It takes a predicate with two arguments: the index and the value of an element.</source>
          <target state="translated">&lt;code&gt;filter()&lt;/code&gt; の述語は、要素の値のみをチェックできます。フィルターで要素の位置を使用する場合は、&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/filter-indexed&quot;&gt; &lt;code&gt;filterIndexed()&lt;/code&gt; を&lt;/a&gt;使用します。これは、要素のインデックスと値の2つの引数を持つ述語を取ります。</target>
        </trans-unit>
        <trans-unit id="273bc9daf88463decafd479d30c651cc98374847" translate="yes" xml:space="preserve">
          <source>The prepared project sources can be directly downloaded from &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-groovy-macos.zip&quot;&gt;GitHub&lt;/a&gt;. &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-groovy-linux.zip&quot;&gt;GitHub&lt;/a&gt;. &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-groovy-windows.zip&quot;&gt;GitHub&lt;/a&gt;. &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-kotlin-macos.zip&quot;&gt;GitHub&lt;/a&gt;. &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-kotlin-linux.zip&quot;&gt;GitHub&lt;/a&gt;. &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-kotlin-windows.zip&quot;&gt;GitHub&lt;/a&gt;.</source>
          <target state="translated">準備されたプロジェクトソースは、&lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-groovy-macos.zip&quot;&gt;GitHub&lt;/a&gt;から直接ダウンロードできます。&lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-groovy-linux.zip&quot;&gt;GitHubの&lt;/a&gt;。&lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-groovy-windows.zip&quot;&gt;GitHubの&lt;/a&gt;。&lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-kotlin-macos.zip&quot;&gt;GitHubの&lt;/a&gt;。&lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-kotlin-linux.zip&quot;&gt;GitHubの&lt;/a&gt;。&lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-kotlin-windows.zip&quot;&gt;GitHubの&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1cda211d823296d73d5059839d0f82ff49bb5da0" translate="yes" xml:space="preserve">
          <source>The prepared project sources can be directly downloaded from &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-framework-groovy-macos-mac.zip&quot;&gt;GitHub&lt;/a&gt;. &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-framework-kotlin-macos-mac.zip&quot;&gt;GitHub&lt;/a&gt;.</source>
          <target state="translated">準備されたプロジェクトソースは、&lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-framework-groovy-macos-mac.zip&quot;&gt;GitHub&lt;/a&gt;から直接ダウンロードできます。&lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-framework-kotlin-macos-mac.zip&quot;&gt;GitHubの&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="83fad008770a134699f224ecf517dfb249b17b87" translate="yes" xml:space="preserve">
          <source>The prepared project sources can be directly downloaded from &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-shared-lib-groovy-linux.zip&quot;&gt;GitHub&lt;/a&gt;. &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-shared-lib-groovy-macos.zip&quot;&gt;GitHub&lt;/a&gt;. &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-shared-lib-groovy-windows.zip&quot;&gt;GitHub&lt;/a&gt;. &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-shared-lib-kotlin-linux.zip&quot;&gt;GitHub&lt;/a&gt;. &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-shared-lib-kotlin-macos.zip&quot;&gt;GitHub&lt;/a&gt;. &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-shared-lib-kotlin-windows.zip&quot;&gt;GitHub&lt;/a&gt;.</source>
          <target state="translated">準備されたプロジェクトソースは、&lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-shared-lib-groovy-linux.zip&quot;&gt;GitHub&lt;/a&gt;から直接ダウンロードできます。&lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-shared-lib-groovy-macos.zip&quot;&gt;GitHubの&lt;/a&gt;。&lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-shared-lib-groovy-windows.zip&quot;&gt;GitHubの&lt;/a&gt;。&lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-shared-lib-kotlin-linux.zip&quot;&gt;GitHubの&lt;/a&gt;。&lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-shared-lib-kotlin-macos.zip&quot;&gt;GitHubの&lt;/a&gt;。&lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-shared-lib-kotlin-windows.zip&quot;&gt;GitHubの&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="47fbf2be0cf9555e26f724c9cc904699b4e6d2c6" translate="yes" xml:space="preserve">
          <source>The prepared project sources can be downloaded directly from &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-groovy-macos-c.zip&quot;&gt;GitHub&lt;/a&gt;. &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-groovy-linux-c.zip&quot;&gt;GitHub&lt;/a&gt;. &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-groovy-windows-c.zip&quot;&gt;GitHub&lt;/a&gt;. &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-kotlin-macos-c.zip&quot;&gt;GitHub&lt;/a&gt;. &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-kotlin-linux-c.zip&quot;&gt;GitHub&lt;/a&gt;. &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-kotlin-windows-c.zip&quot;&gt;GitHub&lt;/a&gt;.</source>
          <target state="translated">準備されたプロジェクトソースは、&lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-groovy-macos-c.zip&quot;&gt;GitHub&lt;/a&gt;から直接ダウンロードできます。&lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-groovy-linux-c.zip&quot;&gt;GitHubの&lt;/a&gt;。&lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-groovy-windows-c.zip&quot;&gt;GitHubの&lt;/a&gt;。&lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-kotlin-macos-c.zip&quot;&gt;GitHubの&lt;/a&gt;。&lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-kotlin-linux-c.zip&quot;&gt;GitHubの&lt;/a&gt;。&lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-kotlin-windows-c.zip&quot;&gt;GitHubの&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0b884226386a575e859d8ba59646588a18cff524" translate="yes" xml:space="preserve">
          <source>The preset functions return an existing target if there is one. This can be used to configure an existing target:</source>
          <target state="translated">プリセット機能は、既存のターゲットが存在する場合、そのターゲットを返します。これを利用して、既存のターゲットを設定することができます。</target>
        </trans-unit>
        <trans-unit id="94b4a93f08efae43f49ccc9068c6ccc45a749339" translate="yes" xml:space="preserve">
          <source>The primary constructor cannot contain any code. Initialization code can be placed in &lt;strong&gt;initializer blocks&lt;/strong&gt;, which are prefixed with the &lt;em&gt;init&lt;/em&gt; keyword.</source>
          <target state="translated">プライマリコンストラクターにコードを含めることはできません。初期化コードは、&lt;em&gt;init&lt;/em&gt;キーワードが前に付けられた&lt;strong&gt;初期化ブロック&lt;/strong&gt;に配置できます。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9fdf36149a4f79a1bb95fdb86a615c52def92e79" translate="yes" xml:space="preserve">
          <source>The primary constructor needs to have at least one parameter;</source>
          <target state="translated">一次コンストラクタは、少なくとも 1 つのパラメータを持つ必要があります。</target>
        </trans-unit>
        <trans-unit id="da3ee8bb58d5e5b4db4f578cf06329f7adf39108" translate="yes" xml:space="preserve">
          <source>The principles of Keeping the Language Modern and Comfortable Updates suggest that incompatible changes are sometimes necessary, but they should be introduced carefully. Our goal is to make the users aware of upcoming changes well in advance to let them migrate their code comfortably.</source>
          <target state="translated">Keeping the Language Modern and Comfortable Updatesの原則は、互換性のない変更が必要な場合もあることを示唆していますが、それらは慎重に導入されるべきです。私たちの目標は、ユーザーがコードを快適に移行できるように、今後の変更点を事前に十分に認識できるようにすることです。</target>
        </trans-unit>
        <trans-unit id="8a9400005c3bca2486ac5d4f71c851ac612c4135" translate="yes" xml:space="preserve">
          <source>The problem</source>
          <target state="translated">問題点</target>
        </trans-unit>
        <trans-unit id="9c66b2fe04efcfddbeb39708f916ac0b213e981b" translate="yes" xml:space="preserve">
          <source>The problem is that in Kotlin we can say &lt;code&gt;unboxBase(boxDerived(&quot;s&quot;))&lt;/code&gt;, but in Java that would be impossible, because in Java the class &lt;code&gt;Box&lt;/code&gt; is &lt;em&gt;invariant&lt;/em&gt; in its parameter &lt;code&gt;T&lt;/code&gt;, and thus &lt;code&gt;Box&amp;lt;Derived&amp;gt;&lt;/code&gt; is not a subtype of &lt;code&gt;Box&amp;lt;Base&amp;gt;&lt;/code&gt;. To make it work in Java we'd have to define &lt;code&gt;unboxBase&lt;/code&gt; as follows:</source>
          <target state="translated">問題は、Kotlinでは &lt;code&gt;unboxBase(boxDerived(&quot;s&quot;))&lt;/code&gt; と言えますが、Javaでは不可能です。これは、Javaではクラス &lt;code&gt;Box&lt;/code&gt; がパラメーター &lt;code&gt;T&lt;/code&gt; で&lt;em&gt;不変&lt;/em&gt;であり、したがって &lt;code&gt;Box&amp;lt;Derived&amp;gt;&lt;/code&gt; がサブタイプではないためです。 &lt;code&gt;Box&amp;lt;Base&amp;gt;&lt;/code&gt; 。Javaで機能させるには、次のように &lt;code&gt;unboxBase&lt;/code&gt; を定義する必要があります。</target>
        </trans-unit>
        <trans-unit id="d0d37636a32f4cdf2f104260760bfa7761da1ecf" translate="yes" xml:space="preserve">
          <source>The process of building and running the Kotlin application in Android Studio is exactly the same as with Java.</source>
          <target state="translated">Android StudioでKotlinアプリケーションをビルドして実行するプロセスは、Javaと全く同じです。</target>
        </trans-unit>
        <trans-unit id="5333ca5a84bee1fa54c6c2c65a4ed24b1d5a7d39" translate="yes" xml:space="preserve">
          <source>The programming model and APIs remain the same. We can continue to use loops, exception handling, etc. and there's no need to learn a complete set of new APIs</source>
          <target state="translated">プログラミングモデルとAPIは変わりません。ループや例外処理などを使い続けることができ、新しいAPIの完全なセットを学ぶ必要はありません。</target>
        </trans-unit>
        <trans-unit id="cbc23b45ec695a38d5e9af2e658da812853cfa4f" translate="yes" xml:space="preserve">
          <source>The progression starts with the &lt;a href=&quot;from-closed-range#kotlin.ranges.CharProgression.Companion%24fromClosedRange%28kotlin.Char%2C+kotlin.Char%2C+kotlin.Int%29%2FrangeStart&quot;&gt;rangeStart&lt;/a&gt; value and goes toward the &lt;a href=&quot;from-closed-range#kotlin.ranges.CharProgression.Companion%24fromClosedRange%28kotlin.Char%2C+kotlin.Char%2C+kotlin.Int%29%2FrangeEnd&quot;&gt;rangeEnd&lt;/a&gt; value not excluding it, with the specified &lt;a href=&quot;from-closed-range#kotlin.ranges.CharProgression.Companion%24fromClosedRange%28kotlin.Char%2C+kotlin.Char%2C+kotlin.Int%29%2Fstep&quot;&gt;step&lt;/a&gt;. In order to go backwards the &lt;a href=&quot;from-closed-range#kotlin.ranges.CharProgression.Companion%24fromClosedRange%28kotlin.Char%2C+kotlin.Char%2C+kotlin.Int%29%2Fstep&quot;&gt;step&lt;/a&gt; must be negative.</source>
          <target state="translated">進行は&lt;a href=&quot;from-closed-range#kotlin.ranges.CharProgression.Companion%24fromClosedRange%28kotlin.Char%2C+kotlin.Char%2C+kotlin.Int%29%2FrangeStart&quot;&gt;rangeStart&lt;/a&gt;値から始まり、指定された&lt;a href=&quot;from-closed-range#kotlin.ranges.CharProgression.Companion%24fromClosedRange%28kotlin.Char%2C+kotlin.Char%2C+kotlin.Int%29%2Fstep&quot;&gt;step&lt;/a&gt;で、それを除外せずに&lt;a href=&quot;from-closed-range#kotlin.ranges.CharProgression.Companion%24fromClosedRange%28kotlin.Char%2C+kotlin.Char%2C+kotlin.Int%29%2FrangeEnd&quot;&gt;rangeEnd&lt;/a&gt;値に向かって進みます。後退するには、&lt;a href=&quot;from-closed-range#kotlin.ranges.CharProgression.Companion%24fromClosedRange%28kotlin.Char%2C+kotlin.Char%2C+kotlin.Int%29%2Fstep&quot;&gt;ステップ&lt;/a&gt;は負でなければなりません。</target>
        </trans-unit>
        <trans-unit id="3cfecf27df2864c65a3a1ce3c515f4f228c95a52" translate="yes" xml:space="preserve">
          <source>The progression starts with the &lt;a href=&quot;from-closed-range#kotlin.ranges.CharProgression.Companion%24fromClosedRange(kotlin.Char,%20kotlin.Char,%20kotlin.Int)/rangeStart&quot;&gt;rangeStart&lt;/a&gt; value and goes toward the &lt;a href=&quot;from-closed-range#kotlin.ranges.CharProgression.Companion%24fromClosedRange(kotlin.Char,%20kotlin.Char,%20kotlin.Int)/rangeEnd&quot;&gt;rangeEnd&lt;/a&gt; value not excluding it, with the specified &lt;a href=&quot;from-closed-range#kotlin.ranges.CharProgression.Companion%24fromClosedRange(kotlin.Char,%20kotlin.Char,%20kotlin.Int)/step&quot;&gt;step&lt;/a&gt;. In order to go backwards the &lt;a href=&quot;from-closed-range#kotlin.ranges.CharProgression.Companion%24fromClosedRange(kotlin.Char,%20kotlin.Char,%20kotlin.Int)/step&quot;&gt;step&lt;/a&gt; must be negative.</source>
          <target state="translated">進行は、&lt;a href=&quot;from-closed-range#kotlin.ranges.CharProgression.Companion%24fromClosedRange(kotlin.Char,%20kotlin.Char,%20kotlin.Int)/rangeStart&quot;&gt;rangeStart&lt;/a&gt;値から始まり、指定された&lt;a href=&quot;from-closed-range#kotlin.ranges.CharProgression.Companion%24fromClosedRange(kotlin.Char,%20kotlin.Char,%20kotlin.Int)/step&quot;&gt;ステップ&lt;/a&gt;で、それを除外せずに&lt;a href=&quot;from-closed-range#kotlin.ranges.CharProgression.Companion%24fromClosedRange(kotlin.Char,%20kotlin.Char,%20kotlin.Int)/rangeEnd&quot;&gt;rangeEnd&lt;/a&gt;値に向かって進みます。逆方向に進むには、&lt;a href=&quot;from-closed-range#kotlin.ranges.CharProgression.Companion%24fromClosedRange(kotlin.Char,%20kotlin.Char,%20kotlin.Int)/step&quot;&gt;ステップ&lt;/a&gt;が負である必要があります。</target>
        </trans-unit>
        <trans-unit id="8d272fe15b8cfff505d8d535e47fe9213e3e4bb4" translate="yes" xml:space="preserve">
          <source>The progression starts with the &lt;a href=&quot;from-closed-range#kotlin.ranges.IntProgression.Companion%24fromClosedRange%28kotlin.Int%2C+kotlin.Int%2C+kotlin.Int%29%2FrangeStart&quot;&gt;rangeStart&lt;/a&gt; value and goes toward the &lt;a href=&quot;from-closed-range#kotlin.ranges.IntProgression.Companion%24fromClosedRange%28kotlin.Int%2C+kotlin.Int%2C+kotlin.Int%29%2FrangeEnd&quot;&gt;rangeEnd&lt;/a&gt; value not excluding it, with the specified &lt;a href=&quot;from-closed-range#kotlin.ranges.IntProgression.Companion%24fromClosedRange%28kotlin.Int%2C+kotlin.Int%2C+kotlin.Int%29%2Fstep&quot;&gt;step&lt;/a&gt;. In order to go backwards the &lt;a href=&quot;from-closed-range#kotlin.ranges.IntProgression.Companion%24fromClosedRange%28kotlin.Int%2C+kotlin.Int%2C+kotlin.Int%29%2Fstep&quot;&gt;step&lt;/a&gt; must be negative.</source>
          <target state="translated">進行は&lt;a href=&quot;from-closed-range#kotlin.ranges.IntProgression.Companion%24fromClosedRange%28kotlin.Int%2C+kotlin.Int%2C+kotlin.Int%29%2FrangeStart&quot;&gt;rangeStart&lt;/a&gt;値から始まり、指定された&lt;a href=&quot;from-closed-range#kotlin.ranges.IntProgression.Companion%24fromClosedRange%28kotlin.Int%2C+kotlin.Int%2C+kotlin.Int%29%2Fstep&quot;&gt;step&lt;/a&gt;で、それを除外せずに&lt;a href=&quot;from-closed-range#kotlin.ranges.IntProgression.Companion%24fromClosedRange%28kotlin.Int%2C+kotlin.Int%2C+kotlin.Int%29%2FrangeEnd&quot;&gt;rangeEnd&lt;/a&gt;値に向かって進みます。後退するには、&lt;a href=&quot;from-closed-range#kotlin.ranges.IntProgression.Companion%24fromClosedRange%28kotlin.Int%2C+kotlin.Int%2C+kotlin.Int%29%2Fstep&quot;&gt;ステップ&lt;/a&gt;は負でなければなりません。</target>
        </trans-unit>
        <trans-unit id="2c4a6206c951ddbe8fde808b1243da3bfe938dbc" translate="yes" xml:space="preserve">
          <source>The progression starts with the &lt;a href=&quot;from-closed-range#kotlin.ranges.IntProgression.Companion%24fromClosedRange(kotlin.Int,%20kotlin.Int,%20kotlin.Int)/rangeStart&quot;&gt;rangeStart&lt;/a&gt; value and goes toward the &lt;a href=&quot;from-closed-range#kotlin.ranges.IntProgression.Companion%24fromClosedRange(kotlin.Int,%20kotlin.Int,%20kotlin.Int)/rangeEnd&quot;&gt;rangeEnd&lt;/a&gt; value not excluding it, with the specified &lt;a href=&quot;from-closed-range#kotlin.ranges.IntProgression.Companion%24fromClosedRange(kotlin.Int,%20kotlin.Int,%20kotlin.Int)/step&quot;&gt;step&lt;/a&gt;. In order to go backwards the &lt;a href=&quot;from-closed-range#kotlin.ranges.IntProgression.Companion%24fromClosedRange(kotlin.Int,%20kotlin.Int,%20kotlin.Int)/step&quot;&gt;step&lt;/a&gt; must be negative.</source>
          <target state="translated">進行は、&lt;a href=&quot;from-closed-range#kotlin.ranges.IntProgression.Companion%24fromClosedRange(kotlin.Int,%20kotlin.Int,%20kotlin.Int)/rangeStart&quot;&gt;rangeStart&lt;/a&gt;値から始まり、指定された&lt;a href=&quot;from-closed-range#kotlin.ranges.IntProgression.Companion%24fromClosedRange(kotlin.Int,%20kotlin.Int,%20kotlin.Int)/step&quot;&gt;ステップ&lt;/a&gt;で、それを除外せずに&lt;a href=&quot;from-closed-range#kotlin.ranges.IntProgression.Companion%24fromClosedRange(kotlin.Int,%20kotlin.Int,%20kotlin.Int)/rangeEnd&quot;&gt;rangeEnd&lt;/a&gt;値に向かって進みます。逆方向に進むには、&lt;a href=&quot;from-closed-range#kotlin.ranges.IntProgression.Companion%24fromClosedRange(kotlin.Int,%20kotlin.Int,%20kotlin.Int)/step&quot;&gt;ステップ&lt;/a&gt;が負である必要があります。</target>
        </trans-unit>
        <trans-unit id="84ee7e5946067792bd4d0c03b228099a9bd9d9cd" translate="yes" xml:space="preserve">
          <source>The progression starts with the &lt;a href=&quot;from-closed-range#kotlin.ranges.LongProgression.Companion%24fromClosedRange%28kotlin.Long%2C+kotlin.Long%2C+kotlin.Long%29%2FrangeStart&quot;&gt;rangeStart&lt;/a&gt; value and goes toward the &lt;a href=&quot;from-closed-range#kotlin.ranges.LongProgression.Companion%24fromClosedRange%28kotlin.Long%2C+kotlin.Long%2C+kotlin.Long%29%2FrangeEnd&quot;&gt;rangeEnd&lt;/a&gt; value not excluding it, with the specified &lt;a href=&quot;from-closed-range#kotlin.ranges.LongProgression.Companion%24fromClosedRange%28kotlin.Long%2C+kotlin.Long%2C+kotlin.Long%29%2Fstep&quot;&gt;step&lt;/a&gt;. In order to go backwards the &lt;a href=&quot;from-closed-range#kotlin.ranges.LongProgression.Companion%24fromClosedRange%28kotlin.Long%2C+kotlin.Long%2C+kotlin.Long%29%2Fstep&quot;&gt;step&lt;/a&gt; must be negative.</source>
          <target state="translated">進行は&lt;a href=&quot;from-closed-range#kotlin.ranges.LongProgression.Companion%24fromClosedRange%28kotlin.Long%2C+kotlin.Long%2C+kotlin.Long%29%2FrangeStart&quot;&gt;rangeStart&lt;/a&gt;値から始まり、指定された&lt;a href=&quot;from-closed-range#kotlin.ranges.LongProgression.Companion%24fromClosedRange%28kotlin.Long%2C+kotlin.Long%2C+kotlin.Long%29%2Fstep&quot;&gt;step&lt;/a&gt;で、それを除外せずに&lt;a href=&quot;from-closed-range#kotlin.ranges.LongProgression.Companion%24fromClosedRange%28kotlin.Long%2C+kotlin.Long%2C+kotlin.Long%29%2FrangeEnd&quot;&gt;rangeEnd&lt;/a&gt;値に向かって進みます。後退するには、&lt;a href=&quot;from-closed-range#kotlin.ranges.LongProgression.Companion%24fromClosedRange%28kotlin.Long%2C+kotlin.Long%2C+kotlin.Long%29%2Fstep&quot;&gt;ステップ&lt;/a&gt;は負でなければなりません。</target>
        </trans-unit>
        <trans-unit id="d9d863d5adbc27747b9056e74161d14934d72f8c" translate="yes" xml:space="preserve">
          <source>The progression starts with the &lt;a href=&quot;from-closed-range#kotlin.ranges.LongProgression.Companion%24fromClosedRange(kotlin.Long,%20kotlin.Long,%20kotlin.Long)/rangeStart&quot;&gt;rangeStart&lt;/a&gt; value and goes toward the &lt;a href=&quot;from-closed-range#kotlin.ranges.LongProgression.Companion%24fromClosedRange(kotlin.Long,%20kotlin.Long,%20kotlin.Long)/rangeEnd&quot;&gt;rangeEnd&lt;/a&gt; value not excluding it, with the specified &lt;a href=&quot;from-closed-range#kotlin.ranges.LongProgression.Companion%24fromClosedRange(kotlin.Long,%20kotlin.Long,%20kotlin.Long)/step&quot;&gt;step&lt;/a&gt;. In order to go backwards the &lt;a href=&quot;from-closed-range#kotlin.ranges.LongProgression.Companion%24fromClosedRange(kotlin.Long,%20kotlin.Long,%20kotlin.Long)/step&quot;&gt;step&lt;/a&gt; must be negative.</source>
          <target state="translated">進行は、&lt;a href=&quot;from-closed-range#kotlin.ranges.LongProgression.Companion%24fromClosedRange(kotlin.Long,%20kotlin.Long,%20kotlin.Long)/rangeStart&quot;&gt;rangeStart&lt;/a&gt;値から始まり、指定された&lt;a href=&quot;from-closed-range#kotlin.ranges.LongProgression.Companion%24fromClosedRange(kotlin.Long,%20kotlin.Long,%20kotlin.Long)/step&quot;&gt;ステップ&lt;/a&gt;で、それを除外せずに&lt;a href=&quot;from-closed-range#kotlin.ranges.LongProgression.Companion%24fromClosedRange(kotlin.Long,%20kotlin.Long,%20kotlin.Long)/rangeEnd&quot;&gt;rangeEnd&lt;/a&gt;値に向かって進みます。逆方向に進むには、&lt;a href=&quot;from-closed-range#kotlin.ranges.LongProgression.Companion%24fromClosedRange(kotlin.Long,%20kotlin.Long,%20kotlin.Long)/step&quot;&gt;ステップ&lt;/a&gt;が負である必要があります。</target>
        </trans-unit>
        <trans-unit id="8d8b7627f24846e9a31abff3ae25964002a498bf" translate="yes" xml:space="preserve">
          <source>The progression starts with the &lt;a href=&quot;from-closed-range#kotlin.ranges.UIntProgression.Companion%24fromClosedRange%28kotlin.UInt%2C+kotlin.UInt%2C+kotlin.Int%29%2FrangeStart&quot;&gt;rangeStart&lt;/a&gt; value and goes toward the &lt;a href=&quot;from-closed-range#kotlin.ranges.UIntProgression.Companion%24fromClosedRange%28kotlin.UInt%2C+kotlin.UInt%2C+kotlin.Int%29%2FrangeEnd&quot;&gt;rangeEnd&lt;/a&gt; value not excluding it, with the specified &lt;a href=&quot;from-closed-range#kotlin.ranges.UIntProgression.Companion%24fromClosedRange%28kotlin.UInt%2C+kotlin.UInt%2C+kotlin.Int%29%2Fstep&quot;&gt;step&lt;/a&gt;. In order to go backwards the &lt;a href=&quot;from-closed-range#kotlin.ranges.UIntProgression.Companion%24fromClosedRange%28kotlin.UInt%2C+kotlin.UInt%2C+kotlin.Int%29%2Fstep&quot;&gt;step&lt;/a&gt; must be negative.</source>
          <target state="translated">進行は&lt;a href=&quot;from-closed-range#kotlin.ranges.UIntProgression.Companion%24fromClosedRange%28kotlin.UInt%2C+kotlin.UInt%2C+kotlin.Int%29%2FrangeStart&quot;&gt;rangeStart&lt;/a&gt;値から始まり、指定された&lt;a href=&quot;from-closed-range#kotlin.ranges.UIntProgression.Companion%24fromClosedRange%28kotlin.UInt%2C+kotlin.UInt%2C+kotlin.Int%29%2Fstep&quot;&gt;step&lt;/a&gt;で、それを除外せずに&lt;a href=&quot;from-closed-range#kotlin.ranges.UIntProgression.Companion%24fromClosedRange%28kotlin.UInt%2C+kotlin.UInt%2C+kotlin.Int%29%2FrangeEnd&quot;&gt;rangeEnd&lt;/a&gt;値に向かって進みます。後退するには、&lt;a href=&quot;from-closed-range#kotlin.ranges.UIntProgression.Companion%24fromClosedRange%28kotlin.UInt%2C+kotlin.UInt%2C+kotlin.Int%29%2Fstep&quot;&gt;ステップ&lt;/a&gt;は負でなければなりません。</target>
        </trans-unit>
        <trans-unit id="890067d4bb4a41e1198a024fd7c7c538b8728df3" translate="yes" xml:space="preserve">
          <source>The progression starts with the &lt;a href=&quot;from-closed-range#kotlin.ranges.UIntProgression.Companion%24fromClosedRange(kotlin.UInt,%20kotlin.UInt,%20kotlin.Int)/rangeStart&quot;&gt;rangeStart&lt;/a&gt; value and goes toward the &lt;a href=&quot;from-closed-range#kotlin.ranges.UIntProgression.Companion%24fromClosedRange(kotlin.UInt,%20kotlin.UInt,%20kotlin.Int)/rangeEnd&quot;&gt;rangeEnd&lt;/a&gt; value not excluding it, with the specified &lt;a href=&quot;from-closed-range#kotlin.ranges.UIntProgression.Companion%24fromClosedRange(kotlin.UInt,%20kotlin.UInt,%20kotlin.Int)/step&quot;&gt;step&lt;/a&gt;. In order to go backwards the &lt;a href=&quot;from-closed-range#kotlin.ranges.UIntProgression.Companion%24fromClosedRange(kotlin.UInt,%20kotlin.UInt,%20kotlin.Int)/step&quot;&gt;step&lt;/a&gt; must be negative.</source>
          <target state="translated">進行は、&lt;a href=&quot;from-closed-range#kotlin.ranges.UIntProgression.Companion%24fromClosedRange(kotlin.UInt,%20kotlin.UInt,%20kotlin.Int)/rangeStart&quot;&gt;rangeStart&lt;/a&gt;値から始まり、指定された&lt;a href=&quot;from-closed-range#kotlin.ranges.UIntProgression.Companion%24fromClosedRange(kotlin.UInt,%20kotlin.UInt,%20kotlin.Int)/step&quot;&gt;ステップ&lt;/a&gt;で、それを除外せずに&lt;a href=&quot;from-closed-range#kotlin.ranges.UIntProgression.Companion%24fromClosedRange(kotlin.UInt,%20kotlin.UInt,%20kotlin.Int)/rangeEnd&quot;&gt;rangeEnd&lt;/a&gt;値に向かって進みます。逆方向に進むには、&lt;a href=&quot;from-closed-range#kotlin.ranges.UIntProgression.Companion%24fromClosedRange(kotlin.UInt,%20kotlin.UInt,%20kotlin.Int)/step&quot;&gt;ステップ&lt;/a&gt;が負である必要があります。</target>
        </trans-unit>
        <trans-unit id="bc7d38b12995812c4efea617bb206ec4460e9ccc" translate="yes" xml:space="preserve">
          <source>The progression starts with the &lt;a href=&quot;from-closed-range#kotlin.ranges.ULongProgression.Companion%24fromClosedRange%28kotlin.ULong%2C+kotlin.ULong%2C+kotlin.Long%29%2FrangeStart&quot;&gt;rangeStart&lt;/a&gt; value and goes toward the &lt;a href=&quot;from-closed-range#kotlin.ranges.ULongProgression.Companion%24fromClosedRange%28kotlin.ULong%2C+kotlin.ULong%2C+kotlin.Long%29%2FrangeEnd&quot;&gt;rangeEnd&lt;/a&gt; value not excluding it, with the specified &lt;a href=&quot;from-closed-range#kotlin.ranges.ULongProgression.Companion%24fromClosedRange%28kotlin.ULong%2C+kotlin.ULong%2C+kotlin.Long%29%2Fstep&quot;&gt;step&lt;/a&gt;. In order to go backwards the &lt;a href=&quot;from-closed-range#kotlin.ranges.ULongProgression.Companion%24fromClosedRange%28kotlin.ULong%2C+kotlin.ULong%2C+kotlin.Long%29%2Fstep&quot;&gt;step&lt;/a&gt; must be negative.</source>
          <target state="translated">進行は&lt;a href=&quot;from-closed-range#kotlin.ranges.ULongProgression.Companion%24fromClosedRange%28kotlin.ULong%2C+kotlin.ULong%2C+kotlin.Long%29%2FrangeStart&quot;&gt;rangeStart&lt;/a&gt;値から始まり、指定された&lt;a href=&quot;from-closed-range#kotlin.ranges.ULongProgression.Companion%24fromClosedRange%28kotlin.ULong%2C+kotlin.ULong%2C+kotlin.Long%29%2Fstep&quot;&gt;step&lt;/a&gt;で、それを除外せずに&lt;a href=&quot;from-closed-range#kotlin.ranges.ULongProgression.Companion%24fromClosedRange%28kotlin.ULong%2C+kotlin.ULong%2C+kotlin.Long%29%2FrangeEnd&quot;&gt;rangeEnd&lt;/a&gt;値に向かって進みます。後退するには、&lt;a href=&quot;from-closed-range#kotlin.ranges.ULongProgression.Companion%24fromClosedRange%28kotlin.ULong%2C+kotlin.ULong%2C+kotlin.Long%29%2Fstep&quot;&gt;ステップ&lt;/a&gt;は負でなければなりません。</target>
        </trans-unit>
        <trans-unit id="cfd566a721eacfbba5c78dd8988340e1f6d111e0" translate="yes" xml:space="preserve">
          <source>The progression starts with the &lt;a href=&quot;from-closed-range#kotlin.ranges.ULongProgression.Companion%24fromClosedRange(kotlin.ULong,%20kotlin.ULong,%20kotlin.Long)/rangeStart&quot;&gt;rangeStart&lt;/a&gt; value and goes toward the &lt;a href=&quot;from-closed-range#kotlin.ranges.ULongProgression.Companion%24fromClosedRange(kotlin.ULong,%20kotlin.ULong,%20kotlin.Long)/rangeEnd&quot;&gt;rangeEnd&lt;/a&gt; value not excluding it, with the specified &lt;a href=&quot;from-closed-range#kotlin.ranges.ULongProgression.Companion%24fromClosedRange(kotlin.ULong,%20kotlin.ULong,%20kotlin.Long)/step&quot;&gt;step&lt;/a&gt;. In order to go backwards the &lt;a href=&quot;from-closed-range#kotlin.ranges.ULongProgression.Companion%24fromClosedRange(kotlin.ULong,%20kotlin.ULong,%20kotlin.Long)/step&quot;&gt;step&lt;/a&gt; must be negative.</source>
          <target state="translated">進行は、&lt;a href=&quot;from-closed-range#kotlin.ranges.ULongProgression.Companion%24fromClosedRange(kotlin.ULong,%20kotlin.ULong,%20kotlin.Long)/rangeStart&quot;&gt;rangeStart&lt;/a&gt;値から始まり、指定された&lt;a href=&quot;from-closed-range#kotlin.ranges.ULongProgression.Companion%24fromClosedRange(kotlin.ULong,%20kotlin.ULong,%20kotlin.Long)/step&quot;&gt;ステップ&lt;/a&gt;で、それを除外せずに&lt;a href=&quot;from-closed-range#kotlin.ranges.ULongProgression.Companion%24fromClosedRange(kotlin.ULong,%20kotlin.ULong,%20kotlin.Long)/rangeEnd&quot;&gt;rangeEnd&lt;/a&gt;値に向かって進みます。逆方向に進むには、&lt;a href=&quot;from-closed-range#kotlin.ranges.ULongProgression.Companion%24fromClosedRange(kotlin.ULong,%20kotlin.ULong,%20kotlin.Long)/step&quot;&gt;ステップ&lt;/a&gt;が負である必要があります。</target>
        </trans-unit>
        <trans-unit id="f35887cf67bb91d63b75657011139a4b8f31176b" translate="yes" xml:space="preserve">
          <source>The project file configures the C interop as an additional step of the build. Let's move the &lt;code&gt;interop.def&lt;/code&gt; file to the &lt;code&gt;src/nativeInterop/cinterop&lt;/code&gt; directory. Gradle recommends using conventions instead of configurations, for example, the source files are expected to be in the &lt;code&gt;src/nativeMain/kotlin&lt;/code&gt; folder. By default, all the symbols from C are imported to the &lt;code&gt;interop&lt;/code&gt; package, we may want to import the whole package in our &lt;code&gt;.kt&lt;/code&gt; files. Check out the &lt;a href=&quot;../../reference/building-mpp-with-gradle&quot;&gt;kotlin-multiplatform&lt;/a&gt; plugin documentation to learn about all the different ways you could configure it.</source>
          <target state="translated">プロジェクトファイルは、ビルドの追加ステップとしてC相互運用機能を構成します。 &lt;code&gt;interop.def&lt;/code&gt; ファイルを &lt;code&gt;src/nativeInterop/cinterop&lt;/code&gt; ディレクトリに移動しましょう。 Gradleは、構成の代わりに規則を使用することを推奨しています。たとえば、ソースファイルは &lt;code&gt;src/nativeMain/kotlin&lt;/code&gt; フォルダーにあると想定されています。デフォルトでは、Cからのすべてのシンボルが &lt;code&gt;interop&lt;/code&gt; パッケージにインポートされます。パッケージ全体を &lt;code&gt;.kt&lt;/code&gt; ファイルにインポートすることもできます。&lt;a href=&quot;../../reference/building-mpp-with-gradle&quot;&gt;kotlin-multiplatform&lt;/a&gt;プラグインのドキュメントをチェックして、プラグインを構成するさまざまな方法について学習してください。</target>
        </trans-unit>
        <trans-unit id="c7f7aa55f08a335c3d3db3f646f14c719c538320" translate="yes" xml:space="preserve">
          <source>The project file configures the C interop as an additional step of the build. Let's move the &lt;code&gt;interop.def&lt;/code&gt; file to the &lt;code&gt;src/nativeInterop/cinterop&lt;/code&gt; directory. Gradle recommends using conventions instead of configurations, for example, the source files are expected to be in the &lt;code&gt;src/nativeMain/kotlin&lt;/code&gt; folder. By default, all the symbols from C are imported to the &lt;code&gt;interop&lt;/code&gt; package, we may want to import the whole package in our &lt;code&gt;.kt&lt;/code&gt; files. Check out the &lt;a href=&quot;../../reference/mpp-discover-project#multiplatform-plugin&quot;&gt;kotlin-multiplatform&lt;/a&gt; plugin documentation to learn about all the different ways you could configure it.</source>
          <target state="translated">プロジェクトファイルは、ビルドの追加ステップとしてC相互運用機能を構成します。 &lt;code&gt;interop.def&lt;/code&gt; ファイルを &lt;code&gt;src/nativeInterop/cinterop&lt;/code&gt; ディレクトリに移動してみましょう。 Gradleは、構成の代わりに規則を使用することをお勧めします。たとえば、ソースファイルは &lt;code&gt;src/nativeMain/kotlin&lt;/code&gt; フォルダーにあると予想されます。デフォルトでは、Cからのすべてのシンボルが &lt;code&gt;interop&lt;/code&gt; パッケージにインポートされます。パッケージ全体を &lt;code&gt;.kt&lt;/code&gt; ファイルにインポートしたい場合があります。&lt;a href=&quot;../../reference/mpp-discover-project#multiplatform-plugin&quot;&gt;kotlin-multiplatform&lt;/a&gt;プラグインのドキュメントを確認して、構成できるさまざまな方法をすべて確認してください。</target>
        </trans-unit>
        <trans-unit id="04a29f21fc01df00a35820fecf66f137da298242" translate="yes" xml:space="preserve">
          <source>The project is ready. The next step is to open it in IntelliJ IDEA. For advanced build scenarios, it is recommended to refer to the &lt;a href=&quot;../../reference/building-mpp-with-gradle#setting-up-a-multiplatform-project&quot;&gt;more detailed&lt;/a&gt; documentation.</source>
          <target state="translated">プロジェクトの準備が整いました。次のステップは、IntelliJ IDEAで開くことです。高度なビルドシナリオについては、&lt;a href=&quot;../../reference/building-mpp-with-gradle#setting-up-a-multiplatform-project&quot;&gt;より詳細な&lt;/a&gt;ドキュメントを参照することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="b358195ade68af7da060ed2c5bd98eb5f625c0a9" translate="yes" xml:space="preserve">
          <source>The project source roots</source>
          <target state="translated">プロジェクトソースのルーツ</target>
        </trans-unit>
        <trans-unit id="6b692a2a5504099d52b9ee1d8cd9e82682b0438b" translate="yes" xml:space="preserve">
          <source>The project structure looks like this:</source>
          <target state="translated">プロジェクトの構造はこんな感じです。</target>
        </trans-unit>
        <trans-unit id="85001da371d8ff3d4160eee8edd3719f9a8a82c8" translate="yes" xml:space="preserve">
          <source>The project's source files are unchanged.</source>
          <target state="translated">プロジェクトのソースファイルは変更されていません。</target>
        </trans-unit>
        <trans-unit id="fe6d1020447b5badd7227ed9268d67a33471daca" translate="yes" xml:space="preserve">
          <source>The property that can be used as a placeholder for statements and values that are defined in JavaScript.</source>
          <target state="translated">JavaScriptで定義されているステートメントや値のプレースホルダとして使用できるプロパティです。</target>
        </trans-unit>
        <trans-unit id="fe5ea5ce74d05b50ab08ac3eaf5980cd10f01114" translate="yes" xml:space="preserve">
          <source>The property which this accessor is originated from.</source>
          <target state="translated">このアクセサの由来となっているプロパティ。</target>
        </trans-unit>
        <trans-unit id="f478ed7d5b12b6f5e34c37814b287211378258c6" translate="yes" xml:space="preserve">
          <source>The provisions of the &lt;a href=&quot;kotlin-evolution&quot;&gt;Kotlin evolution policy&lt;/a&gt; fully apply only to components that have reached Full Stability (FS). From that point on incompatible changes have to be approved by the Language Committee.</source>
          <target state="translated">&lt;a href=&quot;kotlin-evolution&quot;&gt;Kotlin進化ポリシー&lt;/a&gt;の規定は、完全安定性（FS）に達したコンポーネントにのみ完全に適用されます。その時点から、互換性のない変更は言語委員会によって承認される必要があります。</target>
        </trans-unit>
        <trans-unit id="4e0268d689de7d5f78e70c6cb1e82a66dc683856" translate="yes" xml:space="preserve">
          <source>The publication of this target is handled by the Kotlin plugin and doesn't require the steps that are specific to the Java plugin, such as manually creating a publication and configuring it as &lt;code&gt;from(components.java)&lt;/code&gt;.</source>
          <target state="translated">このターゲットのパブリケーションはKotlinプラグインによって処理され、パブリケーションを手動で作成して &lt;code&gt;from(components.java)&lt;/code&gt; として構成するなど、Javaプラグインに固有の手順を必要としません。</target>
        </trans-unit>
        <trans-unit id="38341133c8abc06ea8b313769f8407419006fee4" translate="yes" xml:space="preserve">
          <source>The purpose of this code is to write out some text in the console. In order to use this from the browser, load it, preferably from inside an HTML page:</source>
          <target state="translated">このコードの目的は、コンソールにテキストを書き出すことです。ブラウザから使用するためには、できればHTMLページの中から読み込んでください。</target>
        </trans-unit>
        <trans-unit id="dc84bc4a3671f7fd39fcbdb5d811a4f7dfb04fdc" translate="yes" xml:space="preserve">
          <source>The quickest way to try out C API mapping is to have all C declarations in the &lt;code&gt;interop.def&lt;/code&gt; file, without creating any &lt;code&gt;.h&lt;/code&gt; of &lt;code&gt;.c&lt;/code&gt; files at all. Then place the C declarations in a &lt;code&gt;.def&lt;/code&gt; file after the special &lt;code&gt;---&lt;/code&gt; separator line:</source>
          <target state="translated">C APIマッピングを試す最も簡単な方法は、 &lt;code&gt;.c&lt;/code&gt; ファイルの &lt;code&gt;.h&lt;/code&gt; をまったく作成せずに、すべてのC宣言を &lt;code&gt;interop.def&lt;/code&gt; ファイルに含めることです。次に、C宣言を &lt;code&gt;.def&lt;/code&gt; ファイルの特別な &lt;code&gt;---&lt;/code&gt; セパレータ行の後に配置します。</target>
        </trans-unit>
        <trans-unit id="086ba4582c0f9ff5d704a53067f7ea26f2bef36a" translate="yes" xml:space="preserve">
          <source>The range of indices in the input string where group was captured.</source>
          <target state="translated">グループが捕捉された入力文字列のインデックスの範囲。</target>
        </trans-unit>
        <trans-unit id="d16563c64c4aedfc780b010fa9c5624f673175d2" translate="yes" xml:space="preserve">
          <source>The range of indices in the original string where match was captured.</source>
          <target state="translated">マッチがキャプチャされた元の文字列のインデックスの範囲。</target>
        </trans-unit>
        <trans-unit id="199d1e88f27ba9b05b8adc73d8d822df0cadd36a" translate="yes" xml:space="preserve">
          <source>The read-only collection types are &lt;a href=&quot;generics#variance&quot;&gt;covariant&lt;/a&gt;. This means that, if a &lt;code&gt;Rectangle&lt;/code&gt; class inherits from &lt;code&gt;Shape&lt;/code&gt;, you can use a &lt;code&gt;List&amp;lt;Rectangle&amp;gt;&lt;/code&gt; anywhere the &lt;code&gt;List&amp;lt;Shape&amp;gt;&lt;/code&gt; is required. In other words, the collection types have the same subtyping relationship as the element types. Maps are covariant on the value type, but not on the key type.</source>
          <target state="translated">読み取り専用のコレクション型は&lt;a href=&quot;generics#variance&quot;&gt;共変&lt;/a&gt;です。つまり、 &lt;code&gt;Rectangle&lt;/code&gt; クラスが &lt;code&gt;Shape&lt;/code&gt; を継承する場合、 &lt;code&gt;List&amp;lt;Shape&amp;gt;&lt;/code&gt; が必要な場所であればどこでも &lt;code&gt;List&amp;lt;Rectangle&amp;gt;&lt;/code&gt; 使用できます。つまり、コレクション型は、要素型と同じサブタイプ関係を持っています。マップは、値タイプでは共変ですが、キータイプでは共変ではありません。</target>
        </trans-unit>
        <trans-unit id="2ddb83b3e5eaf3228b8ed04e27d5be844d1ede7b" translate="yes" xml:space="preserve">
          <source>The reason we're seeing the actual output is because the call &lt;code&gt;curl_easy_perform&lt;/code&gt; prints the result to the standard output. We could hide this using &lt;code&gt;curl_easy_setopt&lt;/code&gt;.</source>
          <target state="translated">実際の出力が表示されるのは、 &lt;code&gt;curl_easy_perform&lt;/code&gt; を呼び出すと結果が標準出力に出力されるためです。 &lt;code&gt;curl_easy_setopt&lt;/code&gt; を使用してこれを非表示にすることができます。</target>
        </trans-unit>
        <trans-unit id="4670c1839cea0120059e336f30de1dda186179ab" translate="yes" xml:space="preserve">
          <source>The recommended way to use Kotlin/JS is via the &lt;code&gt;kotlin.js&lt;/code&gt; and &lt;code&gt;kotlin.multiplatform&lt;/code&gt; Gradle plugins. They provide a central and convenient way to set up and control Kotlin projects targeting JavaScript. This includes essential functionality such as controlling the bundling of your application, adding JavaScript dependencies directly from npm, and more. To get an overview of the available options, check out the &lt;a href=&quot;js-project-setup&quot;&gt;Kotlin/JS project setup&lt;/a&gt; documentation.</source>
          <target state="translated">Kotlin / JSを使用するための推奨される方法は、 &lt;code&gt;kotlin.js&lt;/code&gt; および &lt;code&gt;kotlin.multiplatform&lt;/code&gt; Gradleプラグインを使用することです。これらは、JavaScriptを対象とするKotlinプロジェクトをセットアップおよび制御するための中心的で便利な方法を提供します。これには、アプリケーションのバンドルの制御、npmからのJavaScript依存関係の直接追加などの重要な機能が含まれます。利用可能なオプションの概要については、&lt;a href=&quot;js-project-setup&quot;&gt;Kotlin / JSプロジェクトのセットアップ&lt;/a&gt;ドキュメントをご覧ください。</target>
        </trans-unit>
        <trans-unit id="58ca5ea2bf2b7e6112a4ed6c521b74a4fb8e1b96" translate="yes" xml:space="preserve">
          <source>The reference is a value of type &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.reflect/-k-class/index&quot;&gt;KClass&lt;/a&gt;.</source>
          <target state="translated">参照は&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.reflect/-k-class/index&quot;&gt;KClass&lt;/a&gt;型の値です。</target>
        </trans-unit>
        <trans-unit id="225d32a1d2d879830740b8e0770ecbbb02de2cc7" translate="yes" xml:space="preserve">
          <source>The referenced value. Gets the value or sets the new value. If new value is not null, and &lt;code&gt;this&lt;/code&gt; is frozen - it must be frozen or permanent object.</source>
          <target state="translated">参照される値。値を取得するか、新しい値を設定します。新しい値がnullではなく、 &lt;code&gt;this&lt;/code&gt; が凍結されている場合-凍結されているか、永続的なオブジェクトでなければなりません。</target>
        </trans-unit>
        <trans-unit id="9e1c9e946585f6c5b784f91adc26c58c91e5a3c2" translate="yes" xml:space="preserve">
          <source>The referenced value. Gets the value or sets the new value. If new value is not null, it must be frozen or permanent object.</source>
          <target state="translated">参照されている値。値を取得するか、新しい値を設定します。新しい値がnullでない場合は、フリーズしているか恒久的なオブジェクトでなければなりません。</target>
        </trans-unit>
        <trans-unit id="04f24df5fbabe6af37ab1161e95151a96c9196e9" translate="yes" xml:space="preserve">
          <source>The repositories where the library will be published are added via the &lt;code&gt;repositories&lt;/code&gt; block in the &lt;code&gt;publishing { ... }&lt;/code&gt; DSL, as explained in &lt;a href=&quot;https://docs.gradle.org/current/userguide/publishing_maven.html#publishing_maven:repositories&quot;&gt;Maven Publish Plugin. Repositories&lt;/a&gt;.</source>
          <target state="translated">ライブラリが公開される &lt;code&gt;repositories&lt;/code&gt; は、&lt;a href=&quot;https://docs.gradle.org/current/userguide/publishing_maven.html#publishing_maven:repositories&quot;&gt;Maven Publish Pluginで&lt;/a&gt;説明されているように、 &lt;code&gt;publishing { ... }&lt;/code&gt; DSL のリポジトリブロックを介して追加されます。リポジトリ。</target>
        </trans-unit>
        <trans-unit id="7ffbb195d8e128e52d788e2edb39be54dd761c55" translate="yes" xml:space="preserve">
          <source>The rest of the procedure works in exactly the same way as in Java.</source>
          <target state="translated">プロシージャの残りの部分は、Javaと全く同じように動作します。</target>
        </trans-unit>
        <trans-unit id="81a9c69ffb22a2342532cf8251cc7d0415b9dbb2" translate="yes" xml:space="preserve">
          <source>The result is an object which represents a reference to the property (the &quot;Platonic ideal&quot; property, not a property on a particular instance). There's a type hierarchy for property objects: the base interface is &lt;code&gt;KProperty&lt;/code&gt;, which lets you get metadata about the property, such as its name and type. If you want to use the property object to read or modify the property's value in an object, you need to use a subinterface that specifies what kind of property it is. Immutable properties typically are &lt;code&gt;KProperty1&amp;lt;R, V&amp;gt;&lt;/code&gt;, and mutable properties typically are &lt;code&gt;KMutableProperty1&amp;lt;R, V&amp;gt;&lt;/code&gt;. Both of these are generic interfaces, with &lt;code&gt;R&lt;/code&gt; being the receiver type (the type on which the property is declared, in this case &lt;code&gt;Person&lt;/code&gt;) and &lt;code&gt;V&lt;/code&gt; being the type of the property's value.</source>
          <target state="translated">結果は、プロパティへの参照を表すオブジェクトです（特定のインスタンスのプロパティではなく、「プラトニックイデアル」プロパティ）。プロパティオブジェクトにはタイプ階層があります。基本インターフェイスは &lt;code&gt;KProperty&lt;/code&gt; で、名前やタイプなど、プロパティに関するメタデータを取得できます。プロパティオブジェクトを使用してオブジェクトのプロパティの値を読み取りまたは変更する場合は、プロパティの種類を指定するサブインターフェイスを使用する必要があります。不変のプロパティは通常 &lt;code&gt;KProperty1&amp;lt;R, V&amp;gt;&lt;/code&gt; であり、変更可能なプロパティは通常 &lt;code&gt;KMutableProperty1&amp;lt;R, V&amp;gt;&lt;/code&gt; です。これらはどちらも汎用インターフェースであり、 &lt;code&gt;R&lt;/code&gt; はレシーバータイプ（プロパティが宣言されているタイプ、この場合は &lt;code&gt;Person&lt;/code&gt; )です。）、 &lt;code&gt;V&lt;/code&gt; はプロパティの値のタイプです。</target>
        </trans-unit>
        <trans-unit id="1a8aae926c8fa4cd902ab72788ba84f110e52d36" translate="yes" xml:space="preserve">
          <source>The result is computed as &lt;code&gt;r = this - (q * divisor)&lt;/code&gt; where &lt;code&gt;q&lt;/code&gt; is the quotient of division rounded to the nearest integer, &lt;code&gt;q = round(this / other)&lt;/code&gt;.</source>
          <target state="translated">結果は、 &lt;code&gt;r = this - (q * divisor)&lt;/code&gt; として計算されます。ここで、 &lt;code&gt;q&lt;/code&gt; は、最も近い整数に丸められた除算の商、 &lt;code&gt;q = round(this / other)&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="8346187656aa601c46c1b882160101b5d70d1783" translate="yes" xml:space="preserve">
          <source>The result is going to be:</source>
          <target state="translated">結果が出てきます。</target>
        </trans-unit>
        <trans-unit id="f757614cb2200a5a31db5b9a50190e9f1a783287" translate="yes" xml:space="preserve">
          <source>The result is the same, but this code uses only non-blocking &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/delay.html&quot;&gt;delay&lt;/a&gt;. The main thread invoking &lt;code&gt;runBlocking&lt;/code&gt;&lt;em&gt;blocks&lt;/em&gt; until the coroutine inside &lt;code&gt;runBlocking&lt;/code&gt; completes.</source>
          <target state="translated">結果は同じですが、このコードは非ブロッキング&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/delay.html&quot;&gt;遅延&lt;/a&gt;のみを使用します。呼び出しメインスレッド &lt;code&gt;runBlocking&lt;/code&gt; &lt;em&gt;ブロックを&lt;/em&gt;内部コルーチンまで &lt;code&gt;runBlocking&lt;/code&gt; を完了します。</target>
        </trans-unit>
        <trans-unit id="80513416e38e21b1cd6b19983bdbc1cd0f8dbc1d" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;minus&lt;/code&gt; contains the elements of the original collection &lt;em&gt;except&lt;/em&gt; the elements from the second operand. If it's an element, &lt;code&gt;minus&lt;/code&gt; removes its &lt;em&gt;first&lt;/em&gt; occurrence; if it's a collection, &lt;em&gt;all&lt;/em&gt; occurrences of its elements are removed.</source>
          <target state="translated">&lt;code&gt;minus&lt;/code&gt; の結果には、第2オペランドの要素を&lt;em&gt;除く&lt;/em&gt;元のコレクションの要素が含まれます。要素の場合、 &lt;code&gt;minus&lt;/code&gt; は&lt;em&gt;最初の&lt;/em&gt;出現を削除します。コレクションの場合、その要素の&lt;em&gt;すべての&lt;/em&gt;出現が削除されます。</target>
        </trans-unit>
        <trans-unit id="9f4386a5cc0897ae566404e34449e10c9271784f" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;plus&lt;/code&gt; contains the elements from the original collection &lt;em&gt;and&lt;/em&gt; from the second operand.</source>
          <target state="translated">&lt;code&gt;plus&lt;/code&gt; の結果には、元のコレクション&lt;em&gt;と&lt;/em&gt;第2オペランドの要素が含まれます。</target>
        </trans-unit>
        <trans-unit id="ff8add7f5e14fd024c26ef191ab483a18b621fed" translate="yes" xml:space="preserve">
          <source>The result of the future computation. Blocks execution until the future is ready. Second attempt to get will result in an error.</source>
          <target state="translated">未来の計算結果。未来が準備できるまで実行をブロックします。2回目の取得はエラーになります。</target>
        </trans-unit>
        <trans-unit id="b0a33939298c1573b79334a09954b9afb450d438" translate="yes" xml:space="preserve">
          <source>The result of this code is quite interesting, so we'll analyze it in mode detail:</source>
          <target state="translated">このコードの結果がかなり面白いので、モードで詳しく分析してみます。</target>
        </trans-unit>
        <trans-unit id="4a889b01b76fad01cdae52fa6c7d371792173b90" translate="yes" xml:space="preserve">
          <source>The result of this code is quite interesting, so we'll analyze it in more detail:</source>
          <target state="translated">このコードの結果はかなり面白いので、もう少し詳しく分析してみます。</target>
        </trans-unit>
        <trans-unit id="a92982b6e3242403fa82d0db42fdb4534028b312" translate="yes" xml:space="preserve">
          <source>The result of this code is:</source>
          <target state="translated">このコードの結果は</target>
        </trans-unit>
        <trans-unit id="ee6868c39ff4d2539255b06db5a2381813300a75" translate="yes" xml:space="preserve">
          <source>The result of this code:</source>
          <target state="translated">このコードの結果です。</target>
        </trans-unit>
        <trans-unit id="4844d20ae5c2024023a55c2b6b3214cb6ce72593" translate="yes" xml:space="preserve">
          <source>The resulting &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/util/SortedMap.html&quot;&gt;SortedMap&lt;/a&gt; determines the equality and order of keys according to their natural sorting order.</source>
          <target state="translated">結果の&lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/util/SortedMap.html&quot;&gt;SortedMap&lt;/a&gt;は、自然なソート順に従ってキーの等価性と順序を決定します。</target>
        </trans-unit>
        <trans-unit id="e25355ad3b686053cc1bc487b49186167f01eccb" translate="yes" xml:space="preserve">
          <source>The resulting &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/SortedMap.html&quot;&gt;SortedMap&lt;/a&gt; determines the equality and order of keys according to the sorting order provided by the given &lt;a href=&quot;sorted-map-of#kotlin.collections%24sortedMapOf(java.util.Comparator((kotlin.collections.sortedMapOf.K)),%20kotlin.Array((kotlin.Pair((kotlin.collections.sortedMapOf.K,%20kotlin.collections.sortedMapOf.V)))))/comparator&quot;&gt;comparator&lt;/a&gt;.</source>
          <target state="translated">結果の&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/SortedMap.html&quot;&gt;SortedMap&lt;/a&gt;は、指定された&lt;a href=&quot;sorted-map-of#kotlin.collections%24sortedMapOf(java.util.Comparator((kotlin.collections.sortedMapOf.K)),%20kotlin.Array((kotlin.Pair((kotlin.collections.sortedMapOf.K,%20kotlin.collections.sortedMapOf.V)))))/comparator&quot;&gt;コンパレータ&lt;/a&gt;によって提供されるソート順に従って、キーの同等性と順序を決定します。</target>
        </trans-unit>
        <trans-unit id="634514a1676e5366bef12944cb3543ffee02d086" translate="yes" xml:space="preserve">
          <source>The resulting &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/SortedMap.html&quot;&gt;SortedMap&lt;/a&gt; determines the equality and order of keys according to their natural sorting order.</source>
          <target state="translated">結果の&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/SortedMap.html&quot;&gt;SortedMap&lt;/a&gt;は、自然な並べ替え順序に従ってキーの同等性と順序を決定します。</target>
        </trans-unit>
        <trans-unit id="8f890bef6e41ea49023cd4e145c9ac8e02777347" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Byte&lt;/code&gt; value has the same binary representation as this &lt;code&gt;UByte&lt;/code&gt; value.</source>
          <target state="translated">結果の &lt;code&gt;Byte&lt;/code&gt; 値は、この &lt;code&gt;UByte&lt;/code&gt; 値と同じバイナリ表現を持っています。</target>
        </trans-unit>
        <trans-unit id="bcc21fce83c8a76fb70c4188dec066655dc99e5f" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Byte&lt;/code&gt; value is equal to &lt;code&gt;this.toInt().toByte()&lt;/code&gt;.</source>
          <target state="translated">結果の &lt;code&gt;Byte&lt;/code&gt; 値は &lt;code&gt;this.toInt().toByte()&lt;/code&gt; と等しくなります。</target>
        </trans-unit>
        <trans-unit id="500fd389152dfac3d3a3bdf516db69049b6112d1" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Byte&lt;/code&gt; value is represented by the least significant 8 bits of this &lt;code&gt;Int&lt;/code&gt; value.</source>
          <target state="translated">結果の &lt;code&gt;Byte&lt;/code&gt; 値は、この &lt;code&gt;Int&lt;/code&gt; 値の最下位8ビットで表されます。</target>
        </trans-unit>
        <trans-unit id="f5d708d0dd756dc92bd87189470b9a3b0f187bad" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Byte&lt;/code&gt; value is represented by the least significant 8 bits of this &lt;code&gt;Long&lt;/code&gt; value.</source>
          <target state="translated">結果の &lt;code&gt;Byte&lt;/code&gt; 値は、この &lt;code&gt;Long&lt;/code&gt; 値の最下位8ビットで表されます。</target>
        </trans-unit>
        <trans-unit id="f1c617d1ad1ce5e0250376516d3fc7acee8c76a7" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Byte&lt;/code&gt; value is represented by the least significant 8 bits of this &lt;code&gt;Short&lt;/code&gt; value.</source>
          <target state="translated">結果の &lt;code&gt;Byte&lt;/code&gt; 値は、この &lt;code&gt;Short&lt;/code&gt; 値の最下位8ビットで表されます。</target>
        </trans-unit>
        <trans-unit id="3c0aa6565c5cc7948d96b6aa45e671f5d970085c" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Byte&lt;/code&gt; value is represented by the least significant 8 bits of this &lt;code&gt;UInt&lt;/code&gt; value. Note that the resulting &lt;code&gt;Byte&lt;/code&gt; value may be negative.</source>
          <target state="translated">結果の &lt;code&gt;Byte&lt;/code&gt; 値は、この &lt;code&gt;UInt&lt;/code&gt; 値の最下位8ビットで表されます。結果の &lt;code&gt;Byte&lt;/code&gt; 値が負になる場合があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="dd46bb58530a520cf29001659a58a32130329b50" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Byte&lt;/code&gt; value is represented by the least significant 8 bits of this &lt;code&gt;ULong&lt;/code&gt; value. Note that the resulting &lt;code&gt;Byte&lt;/code&gt; value may be negative.</source>
          <target state="translated">結果の &lt;code&gt;Byte&lt;/code&gt; 値は、この &lt;code&gt;ULong&lt;/code&gt; 値の最下位8ビットで表されます。結果の &lt;code&gt;Byte&lt;/code&gt; 値が負になる場合があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="f0796ad9fb92ce12d111b3b2e535fa3a4138ff67" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Byte&lt;/code&gt; value is represented by the least significant 8 bits of this &lt;code&gt;UShort&lt;/code&gt; value. Note that the resulting &lt;code&gt;Byte&lt;/code&gt; value may be negative.</source>
          <target state="translated">結果の &lt;code&gt;Byte&lt;/code&gt; 値は、この &lt;code&gt;UShort&lt;/code&gt; 値の最下位8ビットで表されます。結果の &lt;code&gt;Byte&lt;/code&gt; 値が負になる場合があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="1dcececb10dcdcffc92e35f3fc84338088990b5d" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Char&lt;/code&gt; code is equal to this value reinterpreted as an unsigned number, i.e. it has the same binary representation as this &lt;code&gt;Short&lt;/code&gt;.</source>
          <target state="translated">結果の &lt;code&gt;Char&lt;/code&gt; コードは、符号なしの数値として再解釈されたこの値に等しくなります。つまり、この &lt;code&gt;Short&lt;/code&gt; と同じバイナリ表現になります。</target>
        </trans-unit>
        <trans-unit id="7d3990133293f18f718906ea26c50d316e7978f0" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Char&lt;/code&gt; code is represented by the least significant 16 bits of this &lt;code&gt;Int&lt;/code&gt; value.</source>
          <target state="translated">結果の &lt;code&gt;Char&lt;/code&gt; コードは、この &lt;code&gt;Int&lt;/code&gt; 値の最下位16ビットで表されます。</target>
        </trans-unit>
        <trans-unit id="8e5f25cf2555e851681e56711455629d8b96cc85" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Char&lt;/code&gt; code is represented by the least significant 16 bits of this &lt;code&gt;Long&lt;/code&gt; value.</source>
          <target state="translated">結果の &lt;code&gt;Char&lt;/code&gt; コードは、この &lt;code&gt;Long&lt;/code&gt; 値の最下位16ビットで表されます。</target>
        </trans-unit>
        <trans-unit id="7c93c7f205f664c42eb53e198c38febdd8681e8c" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Char&lt;/code&gt; value is equal to &lt;code&gt;this.toInt().toChar()&lt;/code&gt;.</source>
          <target state="translated">結果の &lt;code&gt;Char&lt;/code&gt; 値は &lt;code&gt;this.toInt().toChar()&lt;/code&gt; と等しくなります。</target>
        </trans-unit>
        <trans-unit id="fb0bee6e823fc7a039aaeeb4e2cf6ccadd56cad2" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Double&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Byte&lt;/code&gt;.</source>
          <target state="translated">結果の &lt;code&gt;Double&lt;/code&gt; 値は、この &lt;code&gt;Byte&lt;/code&gt; と同じ数値を表します。</target>
        </trans-unit>
        <trans-unit id="ec044076f69f3a9e4c8c326707b213be48dbdf4c" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Double&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Float&lt;/code&gt;.</source>
          <target state="translated">結果の &lt;code&gt;Double&lt;/code&gt; 値は、この &lt;code&gt;Float&lt;/code&gt; と同じ数値を表します。</target>
        </trans-unit>
        <trans-unit id="413cc395d49c3c9b688aa7288d432c1583480097" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Double&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Int&lt;/code&gt;.</source>
          <target state="translated">結果の &lt;code&gt;Double&lt;/code&gt; 値は、この &lt;code&gt;Int&lt;/code&gt; と同じ数値を表します。</target>
        </trans-unit>
        <trans-unit id="e04c116c448cef44fd49f1d1da49c8be72cf833e" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Double&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Short&lt;/code&gt;.</source>
          <target state="translated">結果の &lt;code&gt;Double&lt;/code&gt; 値は、この &lt;code&gt;Short&lt;/code&gt; と同じ数値を表します。</target>
        </trans-unit>
        <trans-unit id="624ad9cad2fadf7c5df7034160380cba9b36827a" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Double&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UByte&lt;/code&gt;.</source>
          <target state="translated">結果の &lt;code&gt;Double&lt;/code&gt; 値は、この &lt;code&gt;UByte&lt;/code&gt; と同じ数値を表します。</target>
        </trans-unit>
        <trans-unit id="e233d00009204b3d8e16f6c4faaeb29b610dd152" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Double&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UInt&lt;/code&gt;.</source>
          <target state="translated">結果の &lt;code&gt;Double&lt;/code&gt; 値は、この &lt;code&gt;UInt&lt;/code&gt; と同じ数値を表します。</target>
        </trans-unit>
        <trans-unit id="be9fd1536c9016ec165d93e9e044c6403df23d59" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Double&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UShort&lt;/code&gt;.</source>
          <target state="translated">結果の &lt;code&gt;Double&lt;/code&gt; 値は、この &lt;code&gt;UShort&lt;/code&gt; と同じ数値を表します。</target>
        </trans-unit>
        <trans-unit id="ae244f9a05312104462c229a2e3a4a4de64be4e1" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Float&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Byte&lt;/code&gt;.</source>
          <target state="translated">結果の &lt;code&gt;Float&lt;/code&gt; 値は、この &lt;code&gt;Byte&lt;/code&gt; と同じ数値を表します。</target>
        </trans-unit>
        <trans-unit id="f8088fd36ea4c2c1efeb80cfa5d2e317eb476320" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Float&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Short&lt;/code&gt;.</source>
          <target state="translated">結果の &lt;code&gt;Float&lt;/code&gt; 値は、この &lt;code&gt;Short&lt;/code&gt; と同じ数値を表します。</target>
        </trans-unit>
        <trans-unit id="f353ad75e4345f7f3c16a80f19361bddd53a4f67" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Float&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UByte&lt;/code&gt;.</source>
          <target state="translated">結果の &lt;code&gt;Float&lt;/code&gt; 値は、この &lt;code&gt;UByte&lt;/code&gt; と同じ数値を表します。</target>
        </trans-unit>
        <trans-unit id="abac5ba157cb93c8f101ff3e6ab497cfac17749a" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Float&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UShort&lt;/code&gt;.</source>
          <target state="translated">結果の &lt;code&gt;Float&lt;/code&gt; 値は、この &lt;code&gt;UShort&lt;/code&gt; と同じ数値を表します。</target>
        </trans-unit>
        <trans-unit id="9d03c1143daecc3b8a141860933f0a92adb18b37" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Int&lt;/code&gt; value has the same binary representation as this &lt;code&gt;UInt&lt;/code&gt; value.</source>
          <target state="translated">結果の &lt;code&gt;Int&lt;/code&gt; 値は、この &lt;code&gt;UInt&lt;/code&gt; 値と同じバイナリ表現を持っています。</target>
        </trans-unit>
        <trans-unit id="6ff94aee825d38ae08d93f2ca58819f2a03d9747" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Int&lt;/code&gt; value is represented by the least significant 32 bits of this &lt;code&gt;Long&lt;/code&gt; value.</source>
          <target state="translated">結果の &lt;code&gt;Int&lt;/code&gt; 値は、この &lt;code&gt;Long&lt;/code&gt; 値の最下位32ビットで表されます。</target>
        </trans-unit>
        <trans-unit id="7a5d4e0dea3c1513f10c80d1128e159e3a009787" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Int&lt;/code&gt; value is represented by the least significant 32 bits of this &lt;code&gt;ULong&lt;/code&gt; value. Note that the resulting &lt;code&gt;Int&lt;/code&gt; value may be negative.</source>
          <target state="translated">結果の &lt;code&gt;Int&lt;/code&gt; 値は、この &lt;code&gt;ULong&lt;/code&gt; 値の最下位32ビットで表されます。結果の &lt;code&gt;Int&lt;/code&gt; 値が負になる場合があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="134cc45d29d5c0611e6038571857feed8853b0ee" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Int&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Byte&lt;/code&gt;.</source>
          <target state="translated">結果の &lt;code&gt;Int&lt;/code&gt; 値は、この &lt;code&gt;Byte&lt;/code&gt; と同じ数値を表します。</target>
        </trans-unit>
        <trans-unit id="a8d60bc3ef88b39460060b7f8165763da80802bc" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Int&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Short&lt;/code&gt;.</source>
          <target state="translated">結果の &lt;code&gt;Int&lt;/code&gt; 値は、この &lt;code&gt;Short&lt;/code&gt; と同じ数値を表します。</target>
        </trans-unit>
        <trans-unit id="12aaa5ec83610d73b4b2fc195902417a297ddd61" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Int&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UByte&lt;/code&gt;.</source>
          <target state="translated">結果の &lt;code&gt;Int&lt;/code&gt; 値は、この &lt;code&gt;UByte&lt;/code&gt; と同じ数値を表します。</target>
        </trans-unit>
        <trans-unit id="b30712342fda907bc49df4d10c136bbeeaaf708b" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Int&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UShort&lt;/code&gt;.</source>
          <target state="translated">結果の &lt;code&gt;Int&lt;/code&gt; 値は、この &lt;code&gt;UShort&lt;/code&gt; と同じ数値を表します。</target>
        </trans-unit>
        <trans-unit id="25bcbeae5576ececd431ec0f451a2c7cf6bf73b4" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Long&lt;/code&gt; value has the same binary representation as this &lt;code&gt;ULong&lt;/code&gt; value.</source>
          <target state="translated">結果の &lt;code&gt;Long&lt;/code&gt; 値は、この &lt;code&gt;ULong&lt;/code&gt; 値と同じバイナリ表現になります。</target>
        </trans-unit>
        <trans-unit id="e6a0efc4ac5c4b05735980342faa240209bf9353" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Long&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Byte&lt;/code&gt;.</source>
          <target state="translated">結果の &lt;code&gt;Long&lt;/code&gt; 値は、この &lt;code&gt;Byte&lt;/code&gt; と同じ数値を表します。</target>
        </trans-unit>
        <trans-unit id="a30381cf3452bf71d4466b6a6a9c5a35e959654a" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Long&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Int&lt;/code&gt;.</source>
          <target state="translated">結果の &lt;code&gt;Long&lt;/code&gt; 値は、この &lt;code&gt;Int&lt;/code&gt; と同じ数値を表します。</target>
        </trans-unit>
        <trans-unit id="7692c28294ebe4518a8808f192338ab899b5aeec" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Long&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Short&lt;/code&gt;.</source>
          <target state="translated">結果の &lt;code&gt;Long&lt;/code&gt; 値は、この &lt;code&gt;Short&lt;/code&gt; と同じ数値を表します。</target>
        </trans-unit>
        <trans-unit id="60b7e7e3ba10c2b92827e84db685cc040e179ed1" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Long&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UByte&lt;/code&gt;.</source>
          <target state="translated">結果の &lt;code&gt;Long&lt;/code&gt; 値は、この &lt;code&gt;UByte&lt;/code&gt; と同じ数値を表します。</target>
        </trans-unit>
        <trans-unit id="a95d7e6a557f4530d701aed1a8410d9b6e793205" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Long&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UInt&lt;/code&gt;.</source>
          <target state="translated">結果の &lt;code&gt;Long&lt;/code&gt; 値は、この &lt;code&gt;UInt&lt;/code&gt; と同じ数値を表します。</target>
        </trans-unit>
        <trans-unit id="e900373f53d6267fd01ecf92bb2c5cb1fed9a7b7" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Long&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UShort&lt;/code&gt;.</source>
          <target state="translated">結果の &lt;code&gt;Long&lt;/code&gt; 値は、この &lt;code&gt;UShort&lt;/code&gt; と同じ数値を表します。</target>
        </trans-unit>
        <trans-unit id="3866529acc183dc8b682af92a84909ec65bd5749" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Short&lt;/code&gt; value has the same binary representation as this &lt;code&gt;UShort&lt;/code&gt; value.</source>
          <target state="translated">結果の &lt;code&gt;Short&lt;/code&gt; 値は、この &lt;code&gt;UShort&lt;/code&gt; 値と同じバイナリ表現を持っています。</target>
        </trans-unit>
        <trans-unit id="5ccfa5aff935ee9326f2b407c585467d126768e7" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Short&lt;/code&gt; value is equal to &lt;code&gt;this.toInt().toShort()&lt;/code&gt;.</source>
          <target state="translated">結果の &lt;code&gt;Short&lt;/code&gt; 値は &lt;code&gt;this.toInt().toShort()&lt;/code&gt; と同じです。</target>
        </trans-unit>
        <trans-unit id="fb338e05b22f496cc978d6bf212ddabde5dd17a4" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Short&lt;/code&gt; value is represented by the least significant 16 bits of this &lt;code&gt;Int&lt;/code&gt; value.</source>
          <target state="translated">結果の &lt;code&gt;Short&lt;/code&gt; 値は、この &lt;code&gt;Int&lt;/code&gt; 値の最下位16ビットで表されます。</target>
        </trans-unit>
        <trans-unit id="27367d77acd56c6a1050bc0a49a57fcf2061de96" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Short&lt;/code&gt; value is represented by the least significant 16 bits of this &lt;code&gt;Long&lt;/code&gt; value.</source>
          <target state="translated">結果の &lt;code&gt;Short&lt;/code&gt; 値は、この &lt;code&gt;Long&lt;/code&gt; 値の最下位16ビットで表されます。</target>
        </trans-unit>
        <trans-unit id="0bc0fbdc70644d6d748c478656fa78e912cc16e6" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Short&lt;/code&gt; value is represented by the least significant 16 bits of this &lt;code&gt;UInt&lt;/code&gt; value. Note that the resulting &lt;code&gt;Short&lt;/code&gt; value may be negative.</source>
          <target state="translated">結果の &lt;code&gt;Short&lt;/code&gt; 値は、この &lt;code&gt;UInt&lt;/code&gt; 値の最下位16ビットで表されます。結果の &lt;code&gt;Short&lt;/code&gt; 値が負になる場合があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="bb9494a50b8985a2d74ddd24ec83038bdcd4606a" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Short&lt;/code&gt; value is represented by the least significant 16 bits of this &lt;code&gt;ULong&lt;/code&gt; value. Note that the resulting &lt;code&gt;Short&lt;/code&gt; value may be negative.</source>
          <target state="translated">結果の &lt;code&gt;Short&lt;/code&gt; 値は、この &lt;code&gt;ULong&lt;/code&gt; 値の最下位16ビットで表されます。結果の &lt;code&gt;Short&lt;/code&gt; 値が負になる場合があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="1fbe35f845af4aa0feff1d9060ab35a7c6fe3476" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Short&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Byte&lt;/code&gt;.</source>
          <target state="translated">結果の &lt;code&gt;Short&lt;/code&gt; 値は、この &lt;code&gt;Byte&lt;/code&gt; と同じ数値を表します。</target>
        </trans-unit>
        <trans-unit id="62163dcead131c0bf0933b1342f420db3bc4bb8d" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Short&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UByte&lt;/code&gt;.</source>
          <target state="translated">結果の &lt;code&gt;Short&lt;/code&gt; 値は、この &lt;code&gt;UByte&lt;/code&gt; と同じ数値を表します。</target>
        </trans-unit>
        <trans-unit id="26c6a5634d9e1d8b962bb6788ae67bc866b78e45" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UByte&lt;/code&gt; value has the same binary representation as this &lt;code&gt;Byte&lt;/code&gt; value.</source>
          <target state="translated">結果の &lt;code&gt;UByte&lt;/code&gt; 値は、この &lt;code&gt;Byte&lt;/code&gt; 値と同じバイナリ表現を持っています。</target>
        </trans-unit>
        <trans-unit id="11d5b691a4a978c7af952b604f7d065d5eac1305" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UByte&lt;/code&gt; value is represented by the least significant 8 bits of this &lt;code&gt;Int&lt;/code&gt; value.</source>
          <target state="translated">結果の &lt;code&gt;UByte&lt;/code&gt; 値は、この &lt;code&gt;Int&lt;/code&gt; 値の最下位8ビットで表されます。</target>
        </trans-unit>
        <trans-unit id="5226c83d79204652c28eff49e7528cb1e99fe2d6" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UByte&lt;/code&gt; value is represented by the least significant 8 bits of this &lt;code&gt;Long&lt;/code&gt; value.</source>
          <target state="translated">結果の &lt;code&gt;UByte&lt;/code&gt; 値は、この &lt;code&gt;Long&lt;/code&gt; 値の最下位8ビットで表されます。</target>
        </trans-unit>
        <trans-unit id="726d8e3bdd3b093a08a44094c2cae4da994770da" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UByte&lt;/code&gt; value is represented by the least significant 8 bits of this &lt;code&gt;Short&lt;/code&gt; value.</source>
          <target state="translated">結果の &lt;code&gt;UByte&lt;/code&gt; 値は、この &lt;code&gt;Short&lt;/code&gt; 値の最下位8ビットで表されます。</target>
        </trans-unit>
        <trans-unit id="1dfb49e88d21be6bcb0f49bf822a5aaa6937a983" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UByte&lt;/code&gt; value is represented by the least significant 8 bits of this &lt;code&gt;UInt&lt;/code&gt; value.</source>
          <target state="translated">結果の &lt;code&gt;UByte&lt;/code&gt; 値は、この &lt;code&gt;UInt&lt;/code&gt; 値の最下位8ビットで表されます。</target>
        </trans-unit>
        <trans-unit id="2686cc59be2588fb1dc986c8db1acdab514c552c" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UByte&lt;/code&gt; value is represented by the least significant 8 bits of this &lt;code&gt;ULong&lt;/code&gt; value.</source>
          <target state="translated">結果の &lt;code&gt;UByte&lt;/code&gt; 値は、この &lt;code&gt;ULong&lt;/code&gt; 値の最下位8ビットで表されます。</target>
        </trans-unit>
        <trans-unit id="a5d21503bfa5cb9b99c854c368f0b66239678aba" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UByte&lt;/code&gt; value is represented by the least significant 8 bits of this &lt;code&gt;UShort&lt;/code&gt; value.</source>
          <target state="translated">結果の &lt;code&gt;UByte&lt;/code&gt; 値は、この &lt;code&gt;UShort&lt;/code&gt; 値の最下位8ビットで表されます。</target>
        </trans-unit>
        <trans-unit id="4f3fe5211f1aea05bea1a841d6d73788aeeb2998" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UInt&lt;/code&gt; value has the same binary representation as this &lt;code&gt;Int&lt;/code&gt; value.</source>
          <target state="translated">結果の &lt;code&gt;UInt&lt;/code&gt; 値は、この &lt;code&gt;Int&lt;/code&gt; 値と同じバイナリ表現を持っています。</target>
        </trans-unit>
        <trans-unit id="66a1e76fd131680ad5406468e22ad3973f35ff4e" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UInt&lt;/code&gt; value is represented by the least significant 32 bits of this &lt;code&gt;Long&lt;/code&gt; value.</source>
          <target state="translated">結果の &lt;code&gt;UInt&lt;/code&gt; 値は、この &lt;code&gt;Long&lt;/code&gt; 値の最下位32ビットで表されます。</target>
        </trans-unit>
        <trans-unit id="bc935cba2a00e8cc63899ff18d12438a89739380" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UInt&lt;/code&gt; value is represented by the least significant 32 bits of this &lt;code&gt;ULong&lt;/code&gt; value.</source>
          <target state="translated">結果の &lt;code&gt;UInt&lt;/code&gt; 値は、この &lt;code&gt;ULong&lt;/code&gt; 値の最下位32ビットで表されます。</target>
        </trans-unit>
        <trans-unit id="9d9ba2608012da37a52b5b9b7da96f6d67796334" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UInt&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UByte&lt;/code&gt;.</source>
          <target state="translated">結果の &lt;code&gt;UInt&lt;/code&gt; 値は、この &lt;code&gt;UByte&lt;/code&gt; と同じ数値を表します。</target>
        </trans-unit>
        <trans-unit id="9ab12c98c1ea5502db93ef496727f7d48f4edc12" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UInt&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UShort&lt;/code&gt;.</source>
          <target state="translated">結果の &lt;code&gt;UInt&lt;/code&gt; 値は、この &lt;code&gt;UShort&lt;/code&gt; と同じ数値を表します。</target>
        </trans-unit>
        <trans-unit id="e00a9f9829597db51c5f5f105c5c613e61839318" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;ULong&lt;/code&gt; value has the same binary representation as this &lt;code&gt;Long&lt;/code&gt; value.</source>
          <target state="translated">結果の &lt;code&gt;ULong&lt;/code&gt; 値は、この &lt;code&gt;Long&lt;/code&gt; 値と同じバイナリ表現を持っています。</target>
        </trans-unit>
        <trans-unit id="a5fe358a0a132b3d4ac886ee0067825836c972c3" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;ULong&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UByte&lt;/code&gt;.</source>
          <target state="translated">結果の &lt;code&gt;ULong&lt;/code&gt; 値は、この &lt;code&gt;UByte&lt;/code&gt; と同じ数値を表します。</target>
        </trans-unit>
        <trans-unit id="1e225f6484184e1fd9b9a789c6be2168c16944f8" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;ULong&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UInt&lt;/code&gt;.</source>
          <target state="translated">結果の &lt;code&gt;ULong&lt;/code&gt; 値は、この &lt;code&gt;UInt&lt;/code&gt; と同じ数値を表します。</target>
        </trans-unit>
        <trans-unit id="951d01157187c8755e4bb93be0ec662d70035ced" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;ULong&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UShort&lt;/code&gt;.</source>
          <target state="translated">結果の &lt;code&gt;ULong&lt;/code&gt; 値は、この &lt;code&gt;UShort&lt;/code&gt; と同じ数値を表します。</target>
        </trans-unit>
        <trans-unit id="76c0754fefaa89b43d0e48e2d3b2efa1a3c37cac" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UShort&lt;/code&gt; value has the same binary representation as this &lt;code&gt;Short&lt;/code&gt; value.</source>
          <target state="translated">結果の &lt;code&gt;UShort&lt;/code&gt; 値は、この &lt;code&gt;Short&lt;/code&gt; 値と同じバイナリ表現を持っています。</target>
        </trans-unit>
        <trans-unit id="ed25489ad27c7ad2fa4a9e9ed8a17e177ed921a7" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UShort&lt;/code&gt; value is represented by the least significant 16 bits of this &lt;code&gt;Int&lt;/code&gt; value.</source>
          <target state="translated">結果の &lt;code&gt;UShort&lt;/code&gt; 値は、この &lt;code&gt;Int&lt;/code&gt; 値の最下位16ビットで表されます。</target>
        </trans-unit>
        <trans-unit id="f42954d6785f3d5db6ef1809c504748ad3c8598b" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UShort&lt;/code&gt; value is represented by the least significant 16 bits of this &lt;code&gt;Long&lt;/code&gt; value.</source>
          <target state="translated">結果の &lt;code&gt;UShort&lt;/code&gt; 値は、この &lt;code&gt;Long&lt;/code&gt; 値の最下位16ビットで表されます。</target>
        </trans-unit>
        <trans-unit id="1457c7b3fcc5ff173b3ad803474b4e660273fb3a" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UShort&lt;/code&gt; value is represented by the least significant 16 bits of this &lt;code&gt;UInt&lt;/code&gt; value.</source>
          <target state="translated">結果の &lt;code&gt;UShort&lt;/code&gt; 値は、この &lt;code&gt;UInt&lt;/code&gt; 値の最下位16ビットで表されます。</target>
        </trans-unit>
        <trans-unit id="f4cfae00353cb363d45d034bd2773a412889ab06" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UShort&lt;/code&gt; value is represented by the least significant 16 bits of this &lt;code&gt;ULong&lt;/code&gt; value.</source>
          <target state="translated">結果の &lt;code&gt;UShort&lt;/code&gt; 値は、この &lt;code&gt;ULong&lt;/code&gt; 値の最下位16ビットで表されます。</target>
        </trans-unit>
        <trans-unit id="fd44eb3bc0245bda18586fe624c6aa7f2130c655" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UShort&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UByte&lt;/code&gt;.</source>
          <target state="translated">結果の &lt;code&gt;UShort&lt;/code&gt; 値は、この &lt;code&gt;UByte&lt;/code&gt; と同じ数値を表します。</target>
        </trans-unit>
        <trans-unit id="26ad7d1c46a7946f361222464d3fd9f54190f2e7" translate="yes" xml:space="preserve">
          <source>The resulting value is the closest &lt;code&gt;Double&lt;/code&gt; to this &lt;code&gt;Long&lt;/code&gt; value. In case when this &lt;code&gt;Long&lt;/code&gt; value is exactly between two &lt;code&gt;Double&lt;/code&gt;s, the one with zero at least significant bit of mantissa is selected.</source>
          <target state="translated">結果の値は、この &lt;code&gt;Long&lt;/code&gt; 値に最も近い &lt;code&gt;Double&lt;/code&gt; です。この &lt;code&gt;Long&lt;/code&gt; 値が2つの &lt;code&gt;Double&lt;/code&gt; の間にある場合、仮数の最下位ビットがゼロのものが選択されます。</target>
        </trans-unit>
        <trans-unit id="492c13f0924f52f27eadd038e36be9a70c7d0f23" translate="yes" xml:space="preserve">
          <source>The resulting value is the closest &lt;code&gt;Double&lt;/code&gt; to this &lt;code&gt;ULong&lt;/code&gt; value. In case when this &lt;code&gt;ULong&lt;/code&gt; value is exactly between two &lt;code&gt;Double&lt;/code&gt;s, the one with zero at least significant bit of mantissa is selected.</source>
          <target state="translated">結果の値は、この &lt;code&gt;ULong&lt;/code&gt; 値に最も近い &lt;code&gt;Double&lt;/code&gt; です。この &lt;code&gt;ULong&lt;/code&gt; 値が正確に2つの &lt;code&gt;Double&lt;/code&gt; の間にある場合、仮数の最下位ビットがゼロの値が選択されます。</target>
        </trans-unit>
        <trans-unit id="fc0e588cba1b5e32b36bbd725d91a005e8eca137" translate="yes" xml:space="preserve">
          <source>The resulting value is the closest &lt;code&gt;Float&lt;/code&gt; to this &lt;code&gt;Double&lt;/code&gt; value. In case when this &lt;code&gt;Double&lt;/code&gt; value is exactly between two &lt;code&gt;Float&lt;/code&gt;s, the one with zero at least significant bit of mantissa is selected.</source>
          <target state="translated">結果の値は、この &lt;code&gt;Double&lt;/code&gt; 値に最も近い &lt;code&gt;Float&lt;/code&gt; です。この &lt;code&gt;Double&lt;/code&gt; 値が2つの &lt;code&gt;Float&lt;/code&gt; の間にある場合、仮数の最下位ビットがゼロの値が選択されます。</target>
        </trans-unit>
        <trans-unit id="1a94a9e0d2914f4ed72b19cd967f6325996af0de" translate="yes" xml:space="preserve">
          <source>The resulting value is the closest &lt;code&gt;Float&lt;/code&gt; to this &lt;code&gt;Int&lt;/code&gt; value. In case when this &lt;code&gt;Int&lt;/code&gt; value is exactly between two &lt;code&gt;Float&lt;/code&gt;s, the one with zero at least significant bit of mantissa is selected.</source>
          <target state="translated">結果の値は、この &lt;code&gt;Int&lt;/code&gt; 値に最も近い &lt;code&gt;Float&lt;/code&gt; です。この &lt;code&gt;Int&lt;/code&gt; 値が2つの &lt;code&gt;Float&lt;/code&gt; の間にある場合は、仮数の最下位ビットがゼロのものが選択されます。</target>
        </trans-unit>
        <trans-unit id="4c34f885e332b614efeb077bdc9dc7f566d719ac" translate="yes" xml:space="preserve">
          <source>The resulting value is the closest &lt;code&gt;Float&lt;/code&gt; to this &lt;code&gt;Long&lt;/code&gt; value. In case when this &lt;code&gt;Long&lt;/code&gt; value is exactly between two &lt;code&gt;Float&lt;/code&gt;s, the one with zero at least significant bit of mantissa is selected.</source>
          <target state="translated">結果の値は、この &lt;code&gt;Long&lt;/code&gt; 値に最も近い &lt;code&gt;Float&lt;/code&gt; です。この &lt;code&gt;Long&lt;/code&gt; 値が2つの &lt;code&gt;Float&lt;/code&gt; の間にある場合、仮数の最下位ビットがゼロのものが選択されます。</target>
        </trans-unit>
        <trans-unit id="56778d0fa4ef4bd39c3c6c8e27df252ff267b86a" translate="yes" xml:space="preserve">
          <source>The resulting value is the closest &lt;code&gt;Float&lt;/code&gt; to this &lt;code&gt;UInt&lt;/code&gt; value. In case when this &lt;code&gt;UInt&lt;/code&gt; value is exactly between two &lt;code&gt;Float&lt;/code&gt;s, the one with zero at least significant bit of mantissa is selected.</source>
          <target state="translated">結果の値は、この &lt;code&gt;UInt&lt;/code&gt; 値に最も近い &lt;code&gt;Float&lt;/code&gt; です。この &lt;code&gt;UInt&lt;/code&gt; 値が2つの &lt;code&gt;Float&lt;/code&gt; の間にある場合、仮数の最下位ビットがゼロのものが選択されます。</target>
        </trans-unit>
        <trans-unit id="498957909e2b3c5b2a70150c6779dc9db0eb20c7" translate="yes" xml:space="preserve">
          <source>The resulting value is the closest &lt;code&gt;Float&lt;/code&gt; to this &lt;code&gt;ULong&lt;/code&gt; value. In case when this &lt;code&gt;ULong&lt;/code&gt; value is exactly between two &lt;code&gt;Float&lt;/code&gt;s, the one with zero at least significant bit of mantissa is selected.</source>
          <target state="translated">結果の値は、この &lt;code&gt;ULong&lt;/code&gt; 値に最も近い &lt;code&gt;Float&lt;/code&gt; です。この &lt;code&gt;ULong&lt;/code&gt; 値が2つの &lt;code&gt;Float&lt;/code&gt; の間にある場合、仮数の最下位ビットがゼロの値が選択されます。</target>
        </trans-unit>
        <trans-unit id="65d14c2cdb6c9b143338a902f9c4de4c9b45f92f" translate="yes" xml:space="preserve">
          <source>The return type inference for anonymous functions works just like for normal functions: the return type is inferred automatically for anonymous functions with an expression body and has to be specified explicitly (or is assumed to be &lt;code&gt;Unit&lt;/code&gt;) for anonymous functions with a block body.</source>
          <target state="translated">無名関数の戻り値の型推論は、通常の関数の場合と同様に機能します。戻り値の型は、式の本体を持つ匿名関数の場合は自動的に推論され、ブロック本体のある匿名関数の場合は明示的に指定する必要があります（または &lt;code&gt;Unit&lt;/code&gt; と見なされます）。</target>
        </trans-unit>
        <trans-unit id="dbab78ef44eaefb4e469bd1e51f4e8661d634cea" translate="yes" xml:space="preserve">
          <source>The return type of a function-typed return type (the user expects the returned function to return &lt;code&gt;Fruit&lt;/code&gt;, so it's okay if it really returns &lt;code&gt;Apple&lt;/code&gt;)</source>
          <target state="translated">関数型の戻り値型の戻り値の型（ユーザーは戻り値の関数が &lt;code&gt;Fruit&lt;/code&gt; を返すことを期待しているので、本当に &lt;code&gt;Apple&lt;/code&gt; を返しても問題ありません）</target>
        </trans-unit>
        <trans-unit id="d8362d946ac99a87abd0521089565682c0510f07" translate="yes" xml:space="preserve">
          <source>The return type of a lambda expression is inferred from the type of the last expression inside it (or from the function type of the variable/parameter that the lambda expression is assigned to). If a lambda expression is passed as a function parameter (which is the ordinary use) or assigned to a variable with a declared type, Kotlin can infer the parameter types too, and you only need to specify their names:</source>
          <target state="translated">ラムダ式の戻り値の型は、その中の最後の式の型から推測されます (またはラムダ式が代入されている変数/パラメータの関数型から推測されます)。ラムダ式が関数パラメータとして渡された場合(これは通常の使用法です)、または宣言された型を持つ変数に代入された場合、Kotlin はパラメータの型も推測することができ、その名前を指定するだけで済みます。</target>
        </trans-unit>
        <trans-unit id="d7c260eb93497371636dc4de8fdb8ef84ac32045" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;apply&lt;/code&gt; and &lt;code&gt;also&lt;/code&gt; is the context object itself. Hence, they can be included into call chains as &lt;em&gt;side steps&lt;/em&gt;: you can continue chaining function calls on the same object after them.</source>
          <target state="translated">戻り値 &lt;code&gt;apply&lt;/code&gt; し、 &lt;code&gt;also&lt;/code&gt; コンテキストオブジェクトそのものです。したがって、それらは&lt;em&gt;サイドステップ&lt;/em&gt;として呼び出しチェーンに含めることができます。その後、同じオブジェクトで関数呼び出しをチェーンし続けることができます。</target>
        </trans-unit>
        <trans-unit id="6d324367f598aa028770dca0838f66177648fed1" translate="yes" xml:space="preserve">
          <source>The return value.</source>
          <target state="translated">戻り値です。</target>
        </trans-unit>
        <trans-unit id="046b6584c1bbd3a7a64857edece72cc830dec917" translate="yes" xml:space="preserve">
          <source>The returned instance uses the specified &lt;a href=&quot;lazy#kotlin%24lazy%28kotlin.Any%2C+kotlin.Function0%28%28kotlin.lazy.T%29%29%29%2Flock&quot;&gt;lock&lt;/a&gt; object to synchronize on. When the &lt;a href=&quot;lazy#kotlin%24lazy%28kotlin.Any%2C+kotlin.Function0%28%28kotlin.lazy.T%29%29%29%2Flock&quot;&gt;lock&lt;/a&gt; is not specified the instance uses itself to synchronize on, in this case do not synchronize from external code on the returned instance as it may cause accidental deadlock. Also this behavior can be changed in the future.</source>
          <target state="translated">返されたインスタンスは、指定された&lt;a href=&quot;lazy#kotlin%24lazy%28kotlin.Any%2C+kotlin.Function0%28%28kotlin.lazy.T%29%29%29%2Flock&quot;&gt;ロック&lt;/a&gt;オブジェクトを使用して同期します。&lt;a href=&quot;lazy#kotlin%24lazy%28kotlin.Any%2C+kotlin.Function0%28%28kotlin.lazy.T%29%29%29%2Flock&quot;&gt;ロック&lt;/a&gt;が指定されていない場合、インスタンスはそれ自体を使用して同期します。この場合、予期しないデッドロックが発生する可能性があるため、返されたインスタンスの外部コードから同期しないでください。また、この動作は将来変更される可能性があります。</target>
        </trans-unit>
        <trans-unit id="9b93655dba3d2a18324e24a42bc0aa37bcaff559" translate="yes" xml:space="preserve">
          <source>The returned instance uses the specified &lt;a href=&quot;lazy#kotlin%24lazy(kotlin.Any?,%20kotlin.Function0((kotlin.lazy.T)))/lock&quot;&gt;lock&lt;/a&gt; object to synchronize on. When the &lt;a href=&quot;lazy#kotlin%24lazy(kotlin.Any?,%20kotlin.Function0((kotlin.lazy.T)))/lock&quot;&gt;lock&lt;/a&gt; is not specified the instance uses itself to synchronize on, in this case do not synchronize from external code on the returned instance as it may cause accidental deadlock. Also this behavior can be changed in the future.</source>
          <target state="translated">返されたインスタンスは、指定された&lt;a href=&quot;lazy#kotlin%24lazy(kotlin.Any?,%20kotlin.Function0((kotlin.lazy.T)))/lock&quot;&gt;ロック&lt;/a&gt;オブジェクトを使用して同期します。&lt;a href=&quot;lazy#kotlin%24lazy(kotlin.Any?,%20kotlin.Function0((kotlin.lazy.T)))/lock&quot;&gt;ロック&lt;/a&gt;が指定されていない場合、インスタンスはそれ自体を使用して同期します。この場合、誤ってデッドロックが発生する可能性があるため、返されたインスタンスの外部コードから同期しないでください。また、この動作は将来変更される可能性があります。</target>
        </trans-unit>
        <trans-unit id="97bfc2ca377533226a66b10393317b0a2f994fba" translate="yes" xml:space="preserve">
          <source>The returned list is empty if this char sequence contains less than two characters.</source>
          <target state="translated">返されるリストは、この文字列が2文字未満の場合は空です。</target>
        </trans-unit>
        <trans-unit id="d158c2273db93047119908af61efbbba35bd76f3" translate="yes" xml:space="preserve">
          <source>The returned list is empty if this collection contains less than two elements.</source>
          <target state="translated">返されるリストは、このコレクションに含まれる要素が2つ以下の場合は空です。</target>
        </trans-unit>
        <trans-unit id="29bbad5c305945f97c70cd75ffccab450111f2ea" translate="yes" xml:space="preserve">
          <source>The returned map is serializable (JVM).</source>
          <target state="translated">返されたマップはシリアライズ可能(JVM)です。</target>
        </trans-unit>
        <trans-unit id="ec4d25dd41a10ce08bae955efed7031764938b43" translate="yes" xml:space="preserve">
          <source>The returned map is serializable.</source>
          <target state="translated">返されるマップはシリアライズ可能です。</target>
        </trans-unit>
        <trans-unit id="6f1137c5bd275e0d050f73fe1ffb45e6bc0fef52" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the keys produced from the original array.</source>
          <target state="translated">返されるマップは、元の配列から生成されたキーのエントリの反復順序を保持します。</target>
        </trans-unit>
        <trans-unit id="aab8c4af63582433af11da060d436e3782362d9a" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the keys produced from the original char sequence.</source>
          <target state="translated">返されるマップは、元の文字列から生成されたキーのエントリの反復順序を保持します。</target>
        </trans-unit>
        <trans-unit id="16f1a5aa5ffd50a8f9547783402bf7757df5025f" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the keys produced from the original collection.</source>
          <target state="translated">返されたマップは、元のコレクションから生成されたキーのエントリの反復順序を保持します。</target>
        </trans-unit>
        <trans-unit id="19c068ac54b988c0d6076dddd8c2dbf4092708f6" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the keys produced from the original sequence.</source>
          <target state="translated">返されるマップは、元のシーケンスから生成されたキーのエントリの反復順序を保持します。</target>
        </trans-unit>
        <trans-unit id="f54f229a0ee8d8720d828fe3e27b2d2a6ca940bc" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original array.</source>
          <target state="translated">返されるマップは,元の配列のエントリの反復順序を保持します.</target>
        </trans-unit>
        <trans-unit id="918c726186d31885a03be5dd5847d194f356551f" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original array. If any of two pairs would have the same key the last one gets added to the map.</source>
          <target state="translated">返されるマップは,元の配列のエントリの繰り返し順を保持します.2 つのペアのうち、同じキーを持つペアがあった場合は、最後のペアがマップに追加されます。</target>
        </trans-unit>
        <trans-unit id="1331dc1f7dcbe48a5148654c3f9a9dd17b60c885" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original char sequence.</source>
          <target state="translated">返されるマップは,元の文字列のエントリの反復順序を保持します.</target>
        </trans-unit>
        <trans-unit id="566ed3a9dcb7ca74d4f2c70c6fdf84ac896debb5" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original collection.</source>
          <target state="translated">返されたマップは、元のコレクションのエントリの反復順序を保持します。</target>
        </trans-unit>
        <trans-unit id="2e469a2caf818c0835cee9e0a1babf1e2e3c07a5" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original collection. If any of two pairs would have the same key the last one gets added to the map.</source>
          <target state="translated">返されるマップは、元のコレクションのエントリの反復順序を保持します。2 つのペアのいずれかが同じキーを持つ場合は、最後のペアがマップに追加されます。</target>
        </trans-unit>
        <trans-unit id="4c19d30d5fb69c54a255c5b1e548f2fa56d3aefb" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original map.</source>
          <target state="translated">返されたマップは、元のマップのエントリの反復順序を保持します。</target>
        </trans-unit>
        <trans-unit id="f87204408405ad88a40594eff8f4867029a89b59" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original map. The &lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.Pair%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%2Fpair&quot;&gt;pair&lt;/a&gt; is iterated in the end if it has a unique key.</source>
          <target state="translated">返されたマップは、元のマップのエントリ反復順序を保持します。&lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.Pair%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%2Fpair&quot;&gt;ペアは&lt;/a&gt;、それが一意のキーを持っている場合、最終的に繰り返されます。</target>
        </trans-unit>
        <trans-unit id="2699ea2c18d183922dd8db09dd9a3f0e18a1eb1d" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original map. The &lt;a href=&quot;plus#kotlin.collections%24plus(kotlin.collections.Map((kotlin.collections.plus.K,%20kotlin.collections.plus.V)),%20kotlin.Pair((kotlin.collections.plus.K,%20kotlin.collections.plus.V)))/pair&quot;&gt;pair&lt;/a&gt; is iterated in the end if it has a unique key.</source>
          <target state="translated">返されるマップは、元のマップのエントリの反復順序を保持します。&lt;a href=&quot;plus#kotlin.collections%24plus(kotlin.collections.Map((kotlin.collections.plus.K,%20kotlin.collections.plus.V)),%20kotlin.Pair((kotlin.collections.plus.K,%20kotlin.collections.plus.V)))/pair&quot;&gt;ペアは&lt;/a&gt;、それが一意のキーを持っている場合、最終的に繰り返されます。</target>
        </trans-unit>
        <trans-unit id="8ff3f66b8173f81182161d671f67a90a7b9f8d74" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original map. Those &lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.Array%28%28kotlin.Pair%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%29%29%2Fpairs&quot;&gt;pairs&lt;/a&gt; with unique keys are iterated in the end in the order of &lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.Array%28%28kotlin.Pair%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%29%29%2Fpairs&quot;&gt;pairs&lt;/a&gt; array.</source>
          <target state="translated">返されたマップは、元のマップのエントリ反復順序を保持します。一意のキーを持つこれらの&lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.Array%28%28kotlin.Pair%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%29%29%2Fpairs&quot;&gt;ペア&lt;/a&gt;は、最後に&lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.Array%28%28kotlin.Pair%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%29%29%2Fpairs&quot;&gt;ペア&lt;/a&gt;配列の順序で反復されます。</target>
        </trans-unit>
        <trans-unit id="4c15bc5f538aa94ff9d36f2c463553e37bffffa8" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original map. Those &lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.collections.Iterable%28%28kotlin.Pair%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%29%29%2Fpairs&quot;&gt;pairs&lt;/a&gt; with unique keys are iterated in the end in the order of &lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.collections.Iterable%28%28kotlin.Pair%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%29%29%2Fpairs&quot;&gt;pairs&lt;/a&gt; collection.</source>
          <target state="translated">返されたマップは、元のマップのエントリ反復順序を保持します。一意のキーを持つこれらの&lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.collections.Iterable%28%28kotlin.Pair%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%29%29%2Fpairs&quot;&gt;ペア&lt;/a&gt;は、最後に&lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.collections.Iterable%28%28kotlin.Pair%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%29%29%2Fpairs&quot;&gt;ペア&lt;/a&gt;コレクションの順序で繰り返されます。</target>
        </trans-unit>
        <trans-unit id="41524b28b32f1890886788ed586175d793500478" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original map. Those &lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.sequences.Sequence%28%28kotlin.Pair%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%29%29%2Fpairs&quot;&gt;pairs&lt;/a&gt; with unique keys are iterated in the end in the order of &lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.sequences.Sequence%28%28kotlin.Pair%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%29%29%2Fpairs&quot;&gt;pairs&lt;/a&gt; sequence.</source>
          <target state="translated">返されたマップは、元のマップのエントリ反復順序を保持します。一意のキーを持つこれらの&lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.sequences.Sequence%28%28kotlin.Pair%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%29%29%2Fpairs&quot;&gt;ペア&lt;/a&gt;は、最後に&lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.sequences.Sequence%28%28kotlin.Pair%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%29%29%2Fpairs&quot;&gt;ペア&lt;/a&gt;の順序で繰り返されます。</target>
        </trans-unit>
        <trans-unit id="f1a276280301194297ba4dd69f82e32624b066f0" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original map. Those &lt;a href=&quot;plus#kotlin.collections%24plus(kotlin.collections.Map((kotlin.collections.plus.K,%20kotlin.collections.plus.V)),%20kotlin.Array((kotlin.Pair((kotlin.collections.plus.K,%20kotlin.collections.plus.V)))))/pairs&quot;&gt;pairs&lt;/a&gt; with unique keys are iterated in the end in the order of &lt;a href=&quot;plus#kotlin.collections%24plus(kotlin.collections.Map((kotlin.collections.plus.K,%20kotlin.collections.plus.V)),%20kotlin.Array((kotlin.Pair((kotlin.collections.plus.K,%20kotlin.collections.plus.V)))))/pairs&quot;&gt;pairs&lt;/a&gt; array.</source>
          <target state="translated">返されるマップは、元のマップのエントリの反復順序を保持します。これらの&lt;a href=&quot;plus#kotlin.collections%24plus(kotlin.collections.Map((kotlin.collections.plus.K,%20kotlin.collections.plus.V)),%20kotlin.Array((kotlin.Pair((kotlin.collections.plus.K,%20kotlin.collections.plus.V)))))/pairs&quot;&gt;ペア&lt;/a&gt;ユニークキーでの順に最後に繰り返される&lt;a href=&quot;plus#kotlin.collections%24plus(kotlin.collections.Map((kotlin.collections.plus.K,%20kotlin.collections.plus.V)),%20kotlin.Array((kotlin.Pair((kotlin.collections.plus.K,%20kotlin.collections.plus.V)))))/pairs&quot;&gt;対&lt;/a&gt;アレイ。</target>
        </trans-unit>
        <trans-unit id="60a4b6ca8bf806aec99d136cb53e3d0881c0b238" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original map. Those &lt;a href=&quot;plus#kotlin.collections%24plus(kotlin.collections.Map((kotlin.collections.plus.K,%20kotlin.collections.plus.V)),%20kotlin.collections.Iterable((kotlin.Pair((kotlin.collections.plus.K,%20kotlin.collections.plus.V)))))/pairs&quot;&gt;pairs&lt;/a&gt; with unique keys are iterated in the end in the order of &lt;a href=&quot;plus#kotlin.collections%24plus(kotlin.collections.Map((kotlin.collections.plus.K,%20kotlin.collections.plus.V)),%20kotlin.collections.Iterable((kotlin.Pair((kotlin.collections.plus.K,%20kotlin.collections.plus.V)))))/pairs&quot;&gt;pairs&lt;/a&gt; collection.</source>
          <target state="translated">返されるマップは、元のマップのエントリの反復順序を保持します。これらの&lt;a href=&quot;plus#kotlin.collections%24plus(kotlin.collections.Map((kotlin.collections.plus.K,%20kotlin.collections.plus.V)),%20kotlin.collections.Iterable((kotlin.Pair((kotlin.collections.plus.K,%20kotlin.collections.plus.V)))))/pairs&quot;&gt;ペア&lt;/a&gt;のユニークなキーでは、の順で最後に反復されている&lt;a href=&quot;plus#kotlin.collections%24plus(kotlin.collections.Map((kotlin.collections.plus.K,%20kotlin.collections.plus.V)),%20kotlin.collections.Iterable((kotlin.Pair((kotlin.collections.plus.K,%20kotlin.collections.plus.V)))))/pairs&quot;&gt;ペアの&lt;/a&gt;コレクション。</target>
        </trans-unit>
        <trans-unit id="b1d13bbc3f9bab24f8a9c962714d64145931ced0" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original map. Those &lt;a href=&quot;plus#kotlin.collections%24plus(kotlin.collections.Map((kotlin.collections.plus.K,%20kotlin.collections.plus.V)),%20kotlin.sequences.Sequence((kotlin.Pair((kotlin.collections.plus.K,%20kotlin.collections.plus.V)))))/pairs&quot;&gt;pairs&lt;/a&gt; with unique keys are iterated in the end in the order of &lt;a href=&quot;plus#kotlin.collections%24plus(kotlin.collections.Map((kotlin.collections.plus.K,%20kotlin.collections.plus.V)),%20kotlin.sequences.Sequence((kotlin.Pair((kotlin.collections.plus.K,%20kotlin.collections.plus.V)))))/pairs&quot;&gt;pairs&lt;/a&gt; sequence.</source>
          <target state="translated">返されるマップは、元のマップのエントリの反復順序を保持します。これらの&lt;a href=&quot;plus#kotlin.collections%24plus(kotlin.collections.Map((kotlin.collections.plus.K,%20kotlin.collections.plus.V)),%20kotlin.sequences.Sequence((kotlin.Pair((kotlin.collections.plus.K,%20kotlin.collections.plus.V)))))/pairs&quot;&gt;ペア&lt;/a&gt;のユニークなキーでは、の順で最後に反復されている&lt;a href=&quot;plus#kotlin.collections%24plus(kotlin.collections.Map((kotlin.collections.plus.K,%20kotlin.collections.plus.V)),%20kotlin.sequences.Sequence((kotlin.Pair((kotlin.collections.plus.K,%20kotlin.collections.plus.V)))))/pairs&quot;&gt;ペアの&lt;/a&gt;シーケンス。</target>
        </trans-unit>
        <trans-unit id="af1ab049b7a80d37b426b5189d29b3d33630f886" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original map. Those entries of another &lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%2Fmap&quot;&gt;map&lt;/a&gt; that are missing in this map are iterated in the end in the order of that &lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%2Fmap&quot;&gt;map&lt;/a&gt;.</source>
          <target state="translated">返されたマップは、元のマップのエントリ反復順序を保持します。このマップにない別の&lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%2Fmap&quot;&gt;マップの&lt;/a&gt;エントリは、最後にその&lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%2Fmap&quot;&gt;マップの&lt;/a&gt;順序で繰り返されます。</target>
        </trans-unit>
        <trans-unit id="9b1dd6b497b334d1c744c85f81ba4c2ff9742b26" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original map. Those entries of another &lt;a href=&quot;plus#kotlin.collections%24plus(kotlin.collections.Map((kotlin.collections.plus.K,%20kotlin.collections.plus.V)),%20kotlin.collections.Map((kotlin.collections.plus.K,%20kotlin.collections.plus.V)))/map&quot;&gt;map&lt;/a&gt; that are missing in this map are iterated in the end in the order of that &lt;a href=&quot;plus#kotlin.collections%24plus(kotlin.collections.Map((kotlin.collections.plus.K,%20kotlin.collections.plus.V)),%20kotlin.collections.Map((kotlin.collections.plus.K,%20kotlin.collections.plus.V)))/map&quot;&gt;map&lt;/a&gt;.</source>
          <target state="translated">返されるマップは、元のマップのエントリの反復順序を保持します。このマップで欠落している別の&lt;a href=&quot;plus#kotlin.collections%24plus(kotlin.collections.Map((kotlin.collections.plus.K,%20kotlin.collections.plus.V)),%20kotlin.collections.Map((kotlin.collections.plus.K,%20kotlin.collections.plus.V)))/map&quot;&gt;マップの&lt;/a&gt;エントリは、最後にその&lt;a href=&quot;plus#kotlin.collections%24plus(kotlin.collections.Map((kotlin.collections.plus.K,%20kotlin.collections.plus.V)),%20kotlin.collections.Map((kotlin.collections.plus.K,%20kotlin.collections.plus.V)))/map&quot;&gt;マップの&lt;/a&gt;順序で繰り返されます。</target>
        </trans-unit>
        <trans-unit id="048dcd341f30e50bd04dda11327a4ef88e0d2612" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original sequence.</source>
          <target state="translated">返されるマップは,元のシーケンスのエントリの反復順序を保持します.</target>
        </trans-unit>
        <trans-unit id="bba2889b44a4cec09a40249a683767a797d71e14" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original sequence. If any of two pairs would have the same key the last one gets added to the map.</source>
          <target state="translated">返されるマップは,元のシーケンスのエントリの反復順序を保持します.2 つのペアのうち、同じキーを持つペアがあった場合は、最後のペアがマップに追加されます。</target>
        </trans-unit>
        <trans-unit id="b48dc5da4ba5d84bf8f51570f1be30c9067ca36a" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order.</source>
          <target state="translated">返されたマップは、エントリの反復順序を保持します。</target>
        </trans-unit>
        <trans-unit id="d70c61d5fb5764eefc41a239b3b607225317f588" translate="yes" xml:space="preserve">
          <source>The returned sequence is constrained to be iterated only once.</source>
          <target state="translated">返されたシーケンスは,一度だけ反復処理されるように制約されています.</target>
        </trans-unit>
        <trans-unit id="a79b9e6a21565ad6033f2ab5027e737873a51569" translate="yes" xml:space="preserve">
          <source>The returned sequence is empty if this sequence contains less than two elements.</source>
          <target state="translated">返されるシーケンスは、このシーケンスが2つ以下の要素を含む場合は空です。</target>
        </trans-unit>
        <trans-unit id="7927ae1e5106eaeb7bb0b0dc1138826c33d1919c" translate="yes" xml:space="preserve">
          <source>The returned set preserves the element iteration order of the original array.</source>
          <target state="translated">返されるセットは,元の配列の要素の反復順序を保持します.</target>
        </trans-unit>
        <trans-unit id="8e820b287237249236a403161f0b70ed17d391a2" translate="yes" xml:space="preserve">
          <source>The returned set preserves the element iteration order of the original array. Those elements of the &lt;a href=&quot;union#kotlin.collections%24union%28kotlin.Array%28%28kotlin.collections.union.T%29%29%2C+kotlin.collections.Iterable%28%28kotlin.collections.union.T%29%29%29%2Fother&quot;&gt;other&lt;/a&gt; collection that are unique are iterated in the end in the order of the &lt;a href=&quot;union#kotlin.collections%24union%28kotlin.Array%28%28kotlin.collections.union.T%29%29%2C+kotlin.collections.Iterable%28%28kotlin.collections.union.T%29%29%29%2Fother&quot;&gt;other&lt;/a&gt; collection.</source>
          <target state="translated">返されたセットは、元の配列の要素の反復順序を保持します。一意である&lt;a href=&quot;union#kotlin.collections%24union%28kotlin.Array%28%28kotlin.collections.union.T%29%29%2C+kotlin.collections.Iterable%28%28kotlin.collections.union.T%29%29%29%2Fother&quot;&gt;他の&lt;/a&gt;コレクションの要素は、最後に&lt;a href=&quot;union#kotlin.collections%24union%28kotlin.Array%28%28kotlin.collections.union.T%29%29%2C+kotlin.collections.Iterable%28%28kotlin.collections.union.T%29%29%29%2Fother&quot;&gt;他の&lt;/a&gt;コレクションの順序で繰り返されます。</target>
        </trans-unit>
        <trans-unit id="3daac3d7a93bd39f019e22a0fe48ced02c6896f9" translate="yes" xml:space="preserve">
          <source>The returned set preserves the element iteration order of the original array. Those elements of the &lt;a href=&quot;union#kotlin.collections%24union(kotlin.Array((kotlin.collections.union.T)),%20kotlin.collections.Iterable((kotlin.collections.union.T)))/other&quot;&gt;other&lt;/a&gt; collection that are unique are iterated in the end in the order of the &lt;a href=&quot;union#kotlin.collections%24union(kotlin.Array((kotlin.collections.union.T)),%20kotlin.collections.Iterable((kotlin.collections.union.T)))/other&quot;&gt;other&lt;/a&gt; collection.</source>
          <target state="translated">返されたセットは、元の配列の要素の反復順序を保持します。&lt;a href=&quot;union#kotlin.collections%24union(kotlin.Array((kotlin.collections.union.T)),%20kotlin.collections.Iterable((kotlin.collections.union.T)))/other&quot;&gt;他の&lt;/a&gt;コレクションの一意である要素は、最後に&lt;a href=&quot;union#kotlin.collections%24union(kotlin.Array((kotlin.collections.union.T)),%20kotlin.collections.Iterable((kotlin.collections.union.T)))/other&quot;&gt;他の&lt;/a&gt;コレクションの順序で繰り返されます。</target>
        </trans-unit>
        <trans-unit id="b2b309c05bb0df5183017b60bb11949ef16cec12" translate="yes" xml:space="preserve">
          <source>The returned set preserves the element iteration order of the original char sequence.</source>
          <target state="translated">返されるセットは,元の文字列の要素の反復順序を保持します.</target>
        </trans-unit>
        <trans-unit id="77b699621c7e191100bcd082c9accf071cd60f08" translate="yes" xml:space="preserve">
          <source>The returned set preserves the element iteration order of the original collection.</source>
          <target state="translated">返されるセットは、元のコレクションの要素の反復順序を保持します。</target>
        </trans-unit>
        <trans-unit id="ed96aca660cbd3c3aee98cb1f013ac3448395f47" translate="yes" xml:space="preserve">
          <source>The returned set preserves the element iteration order of the original collection. Those elements of the &lt;a href=&quot;union#kotlin.collections%24union%28kotlin.collections.Iterable%28%28kotlin.collections.union.T%29%29%2C+kotlin.collections.Iterable%28%28kotlin.collections.union.T%29%29%29%2Fother&quot;&gt;other&lt;/a&gt; collection that are unique are iterated in the end in the order of the &lt;a href=&quot;union#kotlin.collections%24union%28kotlin.collections.Iterable%28%28kotlin.collections.union.T%29%29%2C+kotlin.collections.Iterable%28%28kotlin.collections.union.T%29%29%29%2Fother&quot;&gt;other&lt;/a&gt; collection.</source>
          <target state="translated">返されたセットは、元のコレクションの要素の反復順序を保持します。一意である&lt;a href=&quot;union#kotlin.collections%24union%28kotlin.collections.Iterable%28%28kotlin.collections.union.T%29%29%2C+kotlin.collections.Iterable%28%28kotlin.collections.union.T%29%29%29%2Fother&quot;&gt;他の&lt;/a&gt;コレクションの要素は、最後に&lt;a href=&quot;union#kotlin.collections%24union%28kotlin.collections.Iterable%28%28kotlin.collections.union.T%29%29%2C+kotlin.collections.Iterable%28%28kotlin.collections.union.T%29%29%29%2Fother&quot;&gt;他の&lt;/a&gt;コレクションの順序で繰り返されます。</target>
        </trans-unit>
        <trans-unit id="c4910c50663c8a64b733d52ca426f65568fa0287" translate="yes" xml:space="preserve">
          <source>The returned set preserves the element iteration order of the original collection. Those elements of the &lt;a href=&quot;union#kotlin.collections%24union(kotlin.collections.Iterable((kotlin.collections.union.T)),%20kotlin.collections.Iterable((kotlin.collections.union.T)))/other&quot;&gt;other&lt;/a&gt; collection that are unique are iterated in the end in the order of the &lt;a href=&quot;union#kotlin.collections%24union(kotlin.collections.Iterable((kotlin.collections.union.T)),%20kotlin.collections.Iterable((kotlin.collections.union.T)))/other&quot;&gt;other&lt;/a&gt; collection.</source>
          <target state="translated">返されたセットは、元のコレクションの要素の反復順序を保持します。&lt;a href=&quot;union#kotlin.collections%24union(kotlin.collections.Iterable((kotlin.collections.union.T)),%20kotlin.collections.Iterable((kotlin.collections.union.T)))/other&quot;&gt;他の&lt;/a&gt;コレクションの一意である要素は、最後に&lt;a href=&quot;union#kotlin.collections%24union(kotlin.collections.Iterable((kotlin.collections.union.T)),%20kotlin.collections.Iterable((kotlin.collections.union.T)))/other&quot;&gt;他の&lt;/a&gt;コレクションの順序で繰り返されます。</target>
        </trans-unit>
        <trans-unit id="b556a6977dd4e71f20e303d7d9385040d75f0ac7" translate="yes" xml:space="preserve">
          <source>The returned set preserves the element iteration order of the original sequence.</source>
          <target state="translated">返される集合は,元のシーケンスの要素の反復順序を保持します.</target>
        </trans-unit>
        <trans-unit id="eddbfc5096c56b9aafbe04f2e54352a74a62ad62" translate="yes" xml:space="preserve">
          <source>The returned set preserves the element iteration order of the original set.</source>
          <target state="translated">返されたセットは、元のセットの要素の反復順序を保持します。</target>
        </trans-unit>
        <trans-unit id="4e9b4d20ac671bfe117e4f28b0081ad091c327b5" translate="yes" xml:space="preserve">
          <source>The returned set preserves the element iteration order.</source>
          <target state="translated">返された集合は,要素の反復順序を保持します.</target>
        </trans-unit>
        <trans-unit id="7c0e13333db8789388b9d52adff49d100d5cf6ca" translate="yes" xml:space="preserve">
          <source>The returned value is &lt;code&gt;y&lt;/code&gt; such that &lt;code&gt;sinh(y) == x&lt;/code&gt;.</source>
          <target state="translated">返される値である &lt;code&gt;y&lt;/code&gt; よう &lt;code&gt;sinh(y) == x&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f0a819fc71728e449a1fa0a52b2d805fcb67dfe6" translate="yes" xml:space="preserve">
          <source>The returned value is &lt;code&gt;y&lt;/code&gt; such that &lt;code&gt;tanh(y) == x&lt;/code&gt;.</source>
          <target state="translated">返される値である &lt;code&gt;y&lt;/code&gt; よう &lt;code&gt;tanh(y) == x&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="38db1bb7310932e868d4c70216856f90e11179f2" translate="yes" xml:space="preserve">
          <source>The returned value is positive &lt;code&gt;y&lt;/code&gt; such that &lt;code&gt;cosh(y) == x&lt;/code&gt;.</source>
          <target state="translated">戻り値は、 &lt;code&gt;cosh(y) == x&lt;/code&gt; ような正の &lt;code&gt;y&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="92462ffebca930d13f4cb4aaee4b7842f4ea14de" translate="yes" xml:space="preserve">
          <source>The returned value of a &lt;em&gt;try&lt;/em&gt;-expression is either the last expression in the &lt;em&gt;try&lt;/em&gt; block or the last expression in the &lt;em&gt;catch&lt;/em&gt; block (or blocks). Contents of the &lt;em&gt;finally&lt;/em&gt; block do not affect the result of the expression.</source>
          <target state="translated">&lt;em&gt;try&lt;/em&gt; -expression の戻り値は、&lt;em&gt;try&lt;/em&gt;ブロックの最後の式か、&lt;em&gt;catch&lt;/em&gt;ブロック（またはブロック）の最後の式のいずれかです。&lt;em&gt;finally&lt;/em&gt;ブロックの内容は、式の結果に影響を与えません。</target>
        </trans-unit>
        <trans-unit id="261319d8fec52739ec6c832665ae3f7dbd0e5025" translate="yes" xml:space="preserve">
          <source>The root of the Kotlin class hierarchy. Every Kotlin class has &lt;a href=&quot;-any/index#kotlin.Any&quot;&gt;Any&lt;/a&gt; as a superclass.</source>
          <target state="translated">Kotlinクラス階層のルート。すべてのKotlinクラスには、スーパークラスとして&lt;a href=&quot;-any/index#kotlin.Any&quot;&gt;Any&lt;/a&gt;があります。</target>
        </trans-unit>
        <trans-unit id="a55ae833319a2f8e509e5aee918452e19eb747a8" translate="yes" xml:space="preserve">
          <source>The root of the Kotlin class hierarchy. Every Kotlin class has &lt;a href=&quot;index#kotlin.Any&quot;&gt;Any&lt;/a&gt; as a superclass.</source>
          <target state="translated">Kotlinクラス階層のルート。すべてのKotlinクラスには、スーパークラスとして&lt;a href=&quot;index#kotlin.Any&quot;&gt;Any&lt;/a&gt;があります。</target>
        </trans-unit>
        <trans-unit id="98512a74a1640b8252b93eb9be999aab21267c59" translate="yes" xml:space="preserve">
          <source>The runner will set the value for the property system.path.macro.KOTLIN.BUNDLED to the correct one based on the path settings from the IntelliJ IDEA project. However this value needs to be defined in TeamCity (and can be set to any value). Therefore we need to define it as a system variable.</source>
          <target state="translated">ランナーは、IntelliJ IDEAプロジェクトからのパス設定に基づいて、プロパティsystem.path.macro.KOTLIN.BUNDLEDの値を正しいものに設定します。しかし、この値はTeamCityで定義する必要があります(任意の値を設定することができます)。そのため、システム変数として定義する必要があります。</target>
        </trans-unit>
        <trans-unit id="578262526068b614504d1b18d76cf8dea19e1504" translate="yes" xml:space="preserve">
          <source>The same is available for maps with the functions &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/map-of&quot;&gt;&lt;code&gt;mapOf()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/mutable-map-of&quot;&gt;&lt;code&gt;mutableMapOf()&lt;/code&gt;&lt;/a&gt;. The map's keys and values are passed as &lt;code&gt;Pair&lt;/code&gt; objects (usually created with &lt;code&gt;to&lt;/code&gt; infix function).</source>
          <target state="translated">同じことは、機能を持つマップのために利用可能である&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/map-of&quot;&gt; &lt;code&gt;mapOf()&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/mutable-map-of&quot;&gt; &lt;code&gt;mutableMapOf()&lt;/code&gt; &lt;/a&gt;。マップのキーと値は &lt;code&gt;Pair&lt;/code&gt; オブジェクトとして渡されます（通常、 &lt;code&gt;to&lt;/code&gt; infix関数で作成されます）。</target>
        </trans-unit>
        <trans-unit id="25f5c97c541192ff226fb77118f20b9141f29a81" translate="yes" xml:space="preserve">
          <source>The same rules are used by the Kotlin/Native compiler to generate the &lt;code&gt;.h&lt;/code&gt; file for all platforms.</source>
          <target state="translated">Kotlin / Nativeコンパイラーも同じルールを使用して、すべてのプラットフォームの &lt;code&gt;.h&lt;/code&gt; ファイルを生成します。</target>
        </trans-unit>
        <trans-unit id="dac2ac98305c82e23b60095cae0d9b066592bfa3" translate="yes" xml:space="preserve">
          <source>The same set of functions (but without constants) is also available for &lt;code&gt;Float&lt;/code&gt; arguments.</source>
          <target state="translated">同じ関数のセット（ただし、定数なし）も &lt;code&gt;Float&lt;/code&gt; 引数で使用できます。</target>
        </trans-unit>
        <trans-unit id="afd6887219148439be70535c83e0ab200b27625e" translate="yes" xml:space="preserve">
          <source>The same syntax can be used to annotate the entire file. To do this, put an annotation with the target &lt;code&gt;file&lt;/code&gt; at the top level of a file, before the package directive or before all imports if the file is in the default package:</source>
          <target state="translated">同じ構文を使用して、ファイル全体に注釈を付けることができます。これを行うには、ターゲット &lt;code&gt;file&lt;/code&gt; の最上位にある注釈を、パッケージディレクティブの前、またはファイルがデフォルトパッケージにある場合はすべてのインポートの前に配置します。</target>
        </trans-unit>
        <trans-unit id="2ae227fcecaec9d7de3afec1996267608672f87b" translate="yes" xml:space="preserve">
          <source>The same syntax with omitted type arguments can be used for casts that do not take type arguments into account: &lt;code&gt;list as ArrayList&lt;/code&gt;.</source>
          <target state="translated">型引数を省略した同じ構文を、型引数を考慮しないキャストに使用できます。 &lt;code&gt;list as ArrayList&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="998fefac425fa7727b709de3b80c938ce507ca90" translate="yes" xml:space="preserve">
          <source>The same trick applies when we need to have a property &lt;code&gt;x&lt;/code&gt; alongside with a function &lt;code&gt;getX()&lt;/code&gt;:</source>
          <target state="translated">プロパティ &lt;code&gt;x&lt;/code&gt; と関数 &lt;code&gt;getX()&lt;/code&gt; が必要な場合にも同じトリックが適用されます。</target>
        </trans-unit>
        <trans-unit id="7028478d43f0e9046e167eadedccdd38efaac612" translate="yes" xml:space="preserve">
          <source>The same type parameter can be used in both covariant and contravariant projections (because it's the generic classes that are being projected, not the type parameter):</source>
          <target state="translated">同じ型パラメータを共変投影と対変量投影の両方で使用することができます(投影されるのは型パラメータではなく一般的なクラスなので)。</target>
        </trans-unit>
        <trans-unit id="e34374077b9198e942d005d02c16935775597fa6" translate="yes" xml:space="preserve">
          <source>The scale of the result is the same as the scale of &lt;code&gt;this&lt;/code&gt; (divident), and for rounding the &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/math/RoundingMode.html#HALF_EVEN&quot;&gt;RoundingMode.HALF_EVEN&lt;/a&gt; rounding mode is used.</source>
          <target state="translated">結果のスケールは &lt;code&gt;this&lt;/code&gt; （除数）のスケールと同じであり、丸めには&lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/math/RoundingMode.html#HALF_EVEN&quot;&gt;RoundingMode.HALF_EVEN&lt;/a&gt;丸めモードが使用されます。</target>
        </trans-unit>
        <trans-unit id="862c489ca779c92aa7c1ebb24e7220c5850ae722" translate="yes" xml:space="preserve">
          <source>The scale of the result is the same as the scale of &lt;code&gt;this&lt;/code&gt; (divident), and for rounding the &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/math/RoundingMode.html#HALF_EVEN&quot;&gt;RoundingMode.HALF_EVEN&lt;/a&gt; rounding mode is used.</source>
          <target state="translated">結果のスケールは &lt;code&gt;this&lt;/code&gt; （被除数）のスケールと同じであり、丸めには&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/math/RoundingMode.html#HALF_EVEN&quot;&gt;RoundingMode.HALF_EVEN&lt;/a&gt;丸めモードが使用されます。</target>
        </trans-unit>
        <trans-unit id="f22bffdb314393bc05bae9820f09e84c2f28f7a7" translate="yes" xml:space="preserve">
          <source>The scope for yielding values of a &lt;a href=&quot;-sequence/index&quot;&gt;Sequence&lt;/a&gt; or an &lt;a href=&quot;../kotlin.collections/-iterator/index#kotlin.collections.Iterator&quot;&gt;Iterator&lt;/a&gt;, provides &lt;a href=&quot;-sequence-scope/yield&quot;&gt;yield&lt;/a&gt; and &lt;a href=&quot;-sequence-scope/yield-all&quot;&gt;yieldAll&lt;/a&gt; suspension functions.</source>
          <target state="translated">&lt;a href=&quot;-sequence/index&quot;&gt;Sequence&lt;/a&gt;または&lt;a href=&quot;../kotlin.collections/-iterator/index#kotlin.collections.Iterator&quot;&gt;Iteratorの&lt;/a&gt;値を生成するスコープは、&lt;a href=&quot;-sequence-scope/yield&quot;&gt;yield&lt;/a&gt;および&lt;a href=&quot;-sequence-scope/yield-all&quot;&gt;yieldAll&lt;/a&gt;サスペンション関数を提供します。</target>
        </trans-unit>
        <trans-unit id="4a3f3df589995633decc0a7530a1bb032d855ae5" translate="yes" xml:space="preserve">
          <source>The scope for yielding values of a &lt;a href=&quot;../-sequence/index&quot;&gt;Sequence&lt;/a&gt; or an &lt;a href=&quot;../../kotlin.collections/-iterator/index#kotlin.collections.Iterator&quot;&gt;Iterator&lt;/a&gt;, provides &lt;a href=&quot;yield&quot;&gt;yield&lt;/a&gt; and &lt;a href=&quot;yield-all&quot;&gt;yieldAll&lt;/a&gt; suspension functions.</source>
          <target state="translated">&lt;a href=&quot;../-sequence/index&quot;&gt;Sequence&lt;/a&gt;または&lt;a href=&quot;../../kotlin.collections/-iterator/index#kotlin.collections.Iterator&quot;&gt;Iteratorの&lt;/a&gt;値を生成するスコープは、&lt;a href=&quot;yield&quot;&gt;yield&lt;/a&gt;および&lt;a href=&quot;yield-all&quot;&gt;yieldAll&lt;/a&gt;サスペンション関数を提供します。</target>
        </trans-unit>
        <trans-unit id="a36f2feb54110b2ee9d15c70833427be6cae37ba" translate="yes" xml:space="preserve">
          <source>The scope for yielding values of a &lt;a href=&quot;../../kotlin.sequences/-sequence/index&quot;&gt;Sequence&lt;/a&gt; or an &lt;a href=&quot;../../kotlin.collections/-iterator/index#kotlin.collections.Iterator&quot;&gt;Iterator&lt;/a&gt;, provides &lt;a href=&quot;../../kotlin.sequences/-sequence-scope/yield&quot;&gt;yield&lt;/a&gt; and &lt;a href=&quot;../../kotlin.sequences/-sequence-scope/yield-all&quot;&gt;yieldAll&lt;/a&gt; suspension functions.</source>
          <target state="translated">&lt;a href=&quot;../../kotlin.sequences/-sequence/index&quot;&gt;Sequence&lt;/a&gt;または&lt;a href=&quot;../../kotlin.collections/-iterator/index#kotlin.collections.Iterator&quot;&gt;Iteratorの&lt;/a&gt;値を生成するスコープは、&lt;a href=&quot;../../kotlin.sequences/-sequence-scope/yield&quot;&gt;yield&lt;/a&gt;および&lt;a href=&quot;../../kotlin.sequences/-sequence-scope/yield-all&quot;&gt;yieldAll&lt;/a&gt;サスペンション関数を提供します。</target>
        </trans-unit>
        <trans-unit id="f47c36946d42e828300cda7cb035fe509918aa59" translate="yes" xml:space="preserve">
          <source>The scope functions differ by the result they return:</source>
          <target state="translated">スコープ関数は、返す結果によって異なります。</target>
        </trans-unit>
        <trans-unit id="8f4977d6e6dad61eba46e51272eff7452a6f78a7" translate="yes" xml:space="preserve">
          <source>The scope functions do not introduce any new technical capabilities, but they can make your code more concise and readable.</source>
          <target state="translated">スコープ関数は新しい技術的な機能を導入するものではありませんが、コードをより簡潔で読みやすいものにすることができます。</target>
        </trans-unit>
        <trans-unit id="5f41bf24b11179244ce6543e55a837627d8700cb" translate="yes" xml:space="preserve">
          <source>The second line is the &lt;code&gt;headerFilter&lt;/code&gt;. This is used to denote what exactly we want included. In C, when one file references another file with the &lt;code&gt;#include&lt;/code&gt; directive, all the headers are also included. Sometimes this may not be needed, and we can use this parameter, &lt;a href=&quot;https://en.wikipedia.org/wiki/Glob_(programming)&quot;&gt;using glob patterns&lt;/a&gt;, to fine tune things. Note, that &lt;code&gt;headerFilter&lt;/code&gt; is an optional argument and mostly only used when the library we're using is being installed as a system library, and we do not want to fetch external dependencies (such as system &lt;code&gt;stdint.h&lt;/code&gt; header) into our interop library. It may be important for both optimizing the library size and fixing potential conflicts between the system and the Kotlin/Native provided compilation environment.</source>
          <target state="translated">2行目は &lt;code&gt;headerFilter&lt;/code&gt; です。これは、正確に何を含めたいかを示すために使用されます。 Cでは、1つのファイルが &lt;code&gt;#include&lt;/code&gt; ディレクティブで別のファイルを参照すると、すべてのヘッダーも含まれます。時々これは必要ないかもしれません、そして、私たちは物事を微調整するために&lt;a href=&quot;https://en.wikipedia.org/wiki/Glob_(programming)&quot;&gt;グロブパターンを使って&lt;/a&gt;このパラメーターを使うことができます。 &lt;code&gt;headerFilter&lt;/code&gt; はオプションの引数であり、ほとんどの場合、使用しているライブラリがシステムライブラリとしてインストールされている場合にのみ使用されます。相互依存ライブラリに外部依存関係（システム &lt;code&gt;stdint.h&lt;/code&gt; ヘッダーなど）をフェッチしたくない場合に注意してください。ライブラリのサイズを最適化することと、システムとKotlin / Nativeが提供するコンパイル環境との間の潜在的な競合を修正することの両方にとって重要な場合があります。</target>
        </trans-unit>
        <trans-unit id="840619ade32a5f33b95550212b369e6072d8ca9d" translate="yes" xml:space="preserve">
          <source>The second list contains the second elements.</source>
          <target state="translated">第2のリストには、第2の要素が含まれています。</target>
        </trans-unit>
        <trans-unit id="61c6cf9e9e7f1d565d89fe5986da63f4fbcd432b" translate="yes" xml:space="preserve">
          <source>The second observation, is that &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/on-receive-or-null.html&quot;&gt;onReceiveOrNull&lt;/a&gt; gets immediately selected when the channel is already closed.</source>
          <target state="translated">2番目の観察は、チャネルがすでに閉じているときに&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/on-receive-or-null.html&quot;&gt;onReceiveOrNull&lt;/a&gt;がすぐに選択されることです。</target>
        </trans-unit>
        <trans-unit id="90bb330cf5e09011380c337ab5bbdf9ebc55c7f5" translate="yes" xml:space="preserve">
          <source>The second step is to configure the framework search path of the produced binary. It is also known as &lt;code&gt;rpath&lt;/code&gt; or &lt;a href=&quot;https://en.wikipedia.org/wiki/Rpath&quot;&gt;run-time search path&lt;/a&gt;. The binary uses the path to look for the required frameworks. We do not recommend installing additional frameworks to the OS if it is not needed. We should understand the layout of our future application, for example, we may have the &lt;code&gt;Frameworks&lt;/code&gt; folder under the application bundle with all the frameworks we use. The &lt;code&gt;@rpath&lt;/code&gt; parameter can be configured in Xcode. We need to open the &lt;em&gt;project&lt;/em&gt; configuration and find the &lt;code&gt;Runpath Search Paths&lt;/code&gt; section. Here we specify the relative path to the compiled framework.</source>
          <target state="translated">2番目のステップは、生成されたバイナリのフレームワーク検索パスを構成することです。これは、 &lt;code&gt;rpath&lt;/code&gt; または&lt;a href=&quot;https://en.wikipedia.org/wiki/Rpath&quot;&gt;ランタイム検索パス&lt;/a&gt;とも呼ばれます。バイナリはパスを使用して、必要なフレームワークを探します。 OSに不要なフレームワークをインストールすることはお勧めしません。将来のアプリケーションのレイアウトを理解する必要があります。たとえば、使用するすべてのフレームワークを含むアプリケーションバンドルの下に &lt;code&gt;Frameworks&lt;/code&gt; フォルダーがある場合があります。 &lt;code&gt;@rpath&lt;/code&gt; のパラメータは、Xcodeで設定することができます。&lt;em&gt;プロジェクト&lt;/em&gt;構成を開き、 &lt;code&gt;Runpath Search Paths&lt;/code&gt; セクションを見つける必要があります。ここでは、コンパイルされたフレームワークへの相対パスを指定します。</target>
        </trans-unit>
        <trans-unit id="654406bf07807fb9a1c468fda5253d223f604a77" translate="yes" xml:space="preserve">
          <source>The second step is to then include the framework path into the &lt;code&gt;Framework Search Paths&lt;/code&gt; block of the &lt;code&gt;Build Settings&lt;/code&gt; section of the &lt;em&gt;target&lt;/em&gt; configuration page. It is possible to use &lt;code&gt;$(PROJECT_DIR)&lt;/code&gt; macro to simplify the setup.</source>
          <target state="translated">次に、&lt;em&gt;ターゲット&lt;/em&gt;構成ページの &lt;code&gt;Build Settings&lt;/code&gt; セクションの &lt;code&gt;Framework Search Paths&lt;/code&gt; ブロックにフレームワークパスを含めます。 &lt;code&gt;$(PROJECT_DIR)&lt;/code&gt; マクロを使用して、設定を簡略化することができます。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="18e3a3f25c81d64436deec2668dbca688024cd76" translate="yes" xml:space="preserve">
          <source>The second way is using typed getters. These getters allow one to access a binary of a certain type by its name prefix and build type.</source>
          <target state="translated">2つ目の方法は、型付きゲッターを使用する方法です。これらのゲッターを使用することで、名前のプレフィックスとビルド型によって特定の型のバイナリにアクセスすることができます。</target>
        </trans-unit>
        <trans-unit id="827737115fbde8c1114cdac2570a8c2c25e8999d" translate="yes" xml:space="preserve">
          <source>The sequence can be iterated multiple times, each time starting with &lt;a href=&quot;generate-sequence#kotlin.sequences%24generateSequence%28kotlin.sequences.generateSequence.T%2C+kotlin.Function1%28%28kotlin.sequences.generateSequence.T%2C+kotlin.sequences.generateSequence.T%29%29%29%2Fseed&quot;&gt;seed&lt;/a&gt;.</source>
          <target state="translated">シーケンスは複数回繰り返すことができ、そのたびに&lt;a href=&quot;generate-sequence#kotlin.sequences%24generateSequence%28kotlin.sequences.generateSequence.T%2C+kotlin.Function1%28%28kotlin.sequences.generateSequence.T%2C+kotlin.sequences.generateSequence.T%29%29%29%2Fseed&quot;&gt;シードで&lt;/a&gt;始まります。</target>
        </trans-unit>
        <trans-unit id="fc73d4e6f9fffbb0e65e07b8a9240c6689985bdd" translate="yes" xml:space="preserve">
          <source>The sequence can be iterated multiple times, each time starting with &lt;a href=&quot;generate-sequence#kotlin.sequences%24generateSequence(kotlin.sequences.generateSequence.T?,%20kotlin.Function1((kotlin.sequences.generateSequence.T,%20kotlin.sequences.generateSequence.T?)))/seed&quot;&gt;seed&lt;/a&gt;.</source>
          <target state="translated">シーケンスは、&lt;a href=&quot;generate-sequence#kotlin.sequences%24generateSequence(kotlin.sequences.generateSequence.T?,%20kotlin.Function1((kotlin.sequences.generateSequence.T,%20kotlin.sequences.generateSequence.T?)))/seed&quot;&gt;seedで&lt;/a&gt;始まるたびに、複数回繰り返すことができます。</target>
        </trans-unit>
        <trans-unit id="0eda5b13d201be08982eef0e6ce47fb43644a540" translate="yes" xml:space="preserve">
          <source>The sequence can be iterated multiple times.</source>
          <target state="translated">シーケンスを複数回反復することができます。</target>
        </trans-unit>
        <trans-unit id="0a85208253c6224f238363151292bff48ddafdf4" translate="yes" xml:space="preserve">
          <source>The sequence can be potentially infinite.</source>
          <target state="translated">シーケンスは潜在的に無限大になる可能性があります。</target>
        </trans-unit>
        <trans-unit id="0e5675a51efa9f06e75cacd0d5cc4fa5944cc8f4" translate="yes" xml:space="preserve">
          <source>The sequence of values returned by the given iterator can be potentially infinite.</source>
          <target state="translated">与えられたイテレータによって返される値のシーケンスは、潜在的に無限大になる可能性があります。</target>
        </trans-unit>
        <trans-unit id="7d79c1f34f116fdb6c923fac302558f761c71524" translate="yes" xml:space="preserve">
          <source>The sequence operations can be classified into the following groups regarding their state requirements:</source>
          <target state="translated">シーケンス操作は、その状態要件に関して以下のグループに分類することができる。</target>
        </trans-unit>
        <trans-unit id="30c4d2821891f6cd1d6f9f4ff92091f8670df4f6" translate="yes" xml:space="preserve">
          <source>The sequence processing goes like this:</source>
          <target state="translated">シーケンス処理はこのようになります。</target>
        </trans-unit>
        <trans-unit id="037cfea620d6aaba99a768d063c28b857dfd0b60" translate="yes" xml:space="preserve">
          <source>The sequence produces values until it encounters first &lt;code&gt;null&lt;/code&gt; value. If &lt;a href=&quot;generate-sequence#kotlin.sequences%24generateSequence%28kotlin.Function0%28%28kotlin.sequences.generateSequence.T%29%29%2C+kotlin.Function1%28%28kotlin.sequences.generateSequence.T%2C+kotlin.sequences.generateSequence.T%29%29%29%2FseedFunction&quot;&gt;seedFunction&lt;/a&gt; returns &lt;code&gt;null&lt;/code&gt;, an empty sequence is produced.</source>
          <target state="translated">シーケンスは、最初の &lt;code&gt;null&lt;/code&gt; 値が見つかるまで値を生成します。&lt;a href=&quot;generate-sequence#kotlin.sequences%24generateSequence%28kotlin.Function0%28%28kotlin.sequences.generateSequence.T%29%29%2C+kotlin.Function1%28%28kotlin.sequences.generateSequence.T%2C+kotlin.sequences.generateSequence.T%29%29%29%2FseedFunction&quot;&gt;seedFunction&lt;/a&gt;が &lt;code&gt;null&lt;/code&gt; を返す場合、空のシーケンスが生成されます。</target>
        </trans-unit>
        <trans-unit id="6f1a48a2bbbc690466820f3b0f0b43bc4de3e6e5" translate="yes" xml:space="preserve">
          <source>The sequence produces values until it encounters first &lt;code&gt;null&lt;/code&gt; value. If &lt;a href=&quot;generate-sequence#kotlin.sequences%24generateSequence%28kotlin.sequences.generateSequence.T%2C+kotlin.Function1%28%28kotlin.sequences.generateSequence.T%2C+kotlin.sequences.generateSequence.T%29%29%29%2Fseed&quot;&gt;seed&lt;/a&gt; is &lt;code&gt;null&lt;/code&gt;, an empty sequence is produced.</source>
          <target state="translated">シーケンスは、最初の &lt;code&gt;null&lt;/code&gt; 値が見つかるまで値を生成します。場合は&lt;a href=&quot;generate-sequence#kotlin.sequences%24generateSequence%28kotlin.sequences.generateSequence.T%2C+kotlin.Function1%28%28kotlin.sequences.generateSequence.T%2C+kotlin.sequences.generateSequence.T%29%29%29%2Fseed&quot;&gt;種子が&lt;/a&gt;ある &lt;code&gt;null&lt;/code&gt; 、空のシーケンスが作成されます。</target>
        </trans-unit>
        <trans-unit id="7f85b3586f825638607e86e68f4e2c3390aaa658" translate="yes" xml:space="preserve">
          <source>The sequence produces values until it encounters first &lt;code&gt;null&lt;/code&gt; value. If &lt;a href=&quot;generate-sequence#kotlin.sequences%24generateSequence(kotlin.Function0((kotlin.sequences.generateSequence.T?)),%20kotlin.Function1((kotlin.sequences.generateSequence.T,%20kotlin.sequences.generateSequence.T?)))/seedFunction&quot;&gt;seedFunction&lt;/a&gt; returns &lt;code&gt;null&lt;/code&gt;, an empty sequence is produced.</source>
          <target state="translated">シーケンスは、最初の &lt;code&gt;null&lt;/code&gt; 値に遭遇するまで値を生成します。&lt;a href=&quot;generate-sequence#kotlin.sequences%24generateSequence(kotlin.Function0((kotlin.sequences.generateSequence.T?)),%20kotlin.Function1((kotlin.sequences.generateSequence.T,%20kotlin.sequences.generateSequence.T?)))/seedFunction&quot;&gt;seedFunction&lt;/a&gt;が &lt;code&gt;null&lt;/code&gt; を返す場合、空のシーケンスが生成されます。</target>
        </trans-unit>
        <trans-unit id="2bd1e283bb0d03da60d7adf31bcae11b19146a2e" translate="yes" xml:space="preserve">
          <source>The sequence produces values until it encounters first &lt;code&gt;null&lt;/code&gt; value. If &lt;a href=&quot;generate-sequence#kotlin.sequences%24generateSequence(kotlin.sequences.generateSequence.T?,%20kotlin.Function1((kotlin.sequences.generateSequence.T,%20kotlin.sequences.generateSequence.T?)))/seed&quot;&gt;seed&lt;/a&gt; is &lt;code&gt;null&lt;/code&gt;, an empty sequence is produced.</source>
          <target state="translated">シーケンスは、最初の &lt;code&gt;null&lt;/code&gt; 値に遭遇するまで値を生成します。場合は&lt;a href=&quot;generate-sequence#kotlin.sequences%24generateSequence(kotlin.sequences.generateSequence.T?,%20kotlin.Function1((kotlin.sequences.generateSequence.T,%20kotlin.sequences.generateSequence.T?)))/seed&quot;&gt;種子が&lt;/a&gt;ある &lt;code&gt;null&lt;/code&gt; 、空のシーケンスが作成されます。</target>
        </trans-unit>
        <trans-unit id="5a3082b192dc0701c42da2f86e13f788df24a0f1" translate="yes" xml:space="preserve">
          <source>The set of all possible types that can be substituted for a given type parameter may be restricted by &lt;strong&gt;generic constraints&lt;/strong&gt;.</source>
          <target state="translated">特定のタイプパラメータの代わりに使用できるすべてのタイプのセットは、&lt;strong&gt;一般的な制約&lt;/strong&gt;によって制限される場合があり&lt;strong&gt;ます&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="bf0dd762f332fcd86a0727fbb8e23b4a1bb32f29" translate="yes" xml:space="preserve">
          <source>The set of options that were used to create this regular expression.</source>
          <target state="translated">この正規表現を作成するために使用されたオプションのセット。</target>
        </trans-unit>
        <trans-unit id="459759855b3639a06e88e0e2596d7493a847d411" translate="yes" xml:space="preserve">
          <source>The set of target platforms is defined by a multiplatform library author, and they should provide all of the platform-specific implementations for the library. Adding new targets for a multiplatform library at the consumer's side is not supported.</source>
          <target state="translated">ターゲット プラットフォームのセットは、マルチプラットフォーム ライブラリの作成者によって定義され、ライブラリのプラットフォーム固有の実装をすべて提供する必要があります。コンシューマ側でマルチプラットフォーム ライブラリの新しいターゲットを追加することはサポートされていません。</target>
        </trans-unit>
        <trans-unit id="488655893b603c994560325ea4e7b1458229763b" translate="yes" xml:space="preserve">
          <source>The setter of this mutable property, used to change the value of the property.</source>
          <target state="translated">プロパティの値を変更するために使用される、この変更可能なプロパティのセッター。</target>
        </trans-unit>
        <trans-unit id="67fe2f456972c4ac12399f4f27262af0c978820f" translate="yes" xml:space="preserve">
          <source>The signature of &lt;code&gt;greet()&lt;/code&gt; is &lt;code&gt;KFunction2&amp;lt;Person, String, String&amp;gt;&lt;/code&gt; because it's a function on &lt;code&gt;Person&lt;/code&gt; that takes a &lt;code&gt;String&lt;/code&gt; and returns a &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">署名 &lt;code&gt;greet()&lt;/code&gt; である &lt;code&gt;KFunction2&amp;lt;Person, String, String&amp;gt;&lt;/code&gt; それは上の機能ですので、 &lt;code&gt;Person&lt;/code&gt; 取り &lt;code&gt;String&lt;/code&gt; を返す &lt;code&gt;String&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3e351be319f91b0a3ca4911e8fb9da8a9528097a" translate="yes" xml:space="preserve">
          <source>The signature of a member function or an &lt;a href=&quot;extension-functionsproperties&quot;&gt;extension function&lt;/a&gt; begins with a &lt;em&gt;receiver&lt;/em&gt;: the type upon which the function can be invoked. For example, the signature of &lt;code&gt;toString()&lt;/code&gt; is &lt;code&gt;Any.() -&amp;gt; String&lt;/code&gt; - it can be called on any non-null object (the receiver), it takes no parameters, and it returns a &lt;code&gt;String&lt;/code&gt;. It is possible to write a lambda function with such a signature - this is called a &lt;em&gt;function literal with receiver&lt;/em&gt;, and is extremely useful for building DSLs.</source>
          <target state="translated">メンバー関数または&lt;a href=&quot;extension-functionsproperties&quot;&gt;拡張関数&lt;/a&gt;のシグネチャは、&lt;em&gt;レシーバー&lt;/em&gt;、つまり関数を呼び出すことができるタイプで始まります。たとえば、 &lt;code&gt;toString()&lt;/code&gt; のシグネチャは &lt;code&gt;Any.() -&amp;gt; String&lt;/code&gt; これは、null以外のオブジェクト（レシーバー）で呼び出すことができ、パラメーターを取らず、 &lt;code&gt;String&lt;/code&gt; を返します。そのようなシグネチャを持つラムダ関数を書くことは可能です-これは&lt;em&gt;レシーバー付きの関数リテラルと&lt;/em&gt;呼ばれ、DSLを構築するのに非常に役立ちます。</target>
        </trans-unit>
        <trans-unit id="aadf52185468aa82855f792813cb9471782e9fa0" translate="yes" xml:space="preserve">
          <source>The signature of the overriding function must exactly match the overridden one, except that the return type in the overriding function may be a subtype of the return type of the overridden function.</source>
          <target state="translated">オーバーライド関数のシグネチャは、オーバーライドされた関数と完全に一致していなければなりませんが、オーバーライド関数の戻り値の型がオーバーライドされた関数の戻り値の型のサブタイプである場合があります。</target>
        </trans-unit>
        <trans-unit id="cb5cfcfa1d9e07364a5b05687e8945f6f792b6b5" translate="yes" xml:space="preserve">
          <source>The simple name of the class as it was declared in the source code, or &lt;code&gt;null&lt;/code&gt; if the class has no name (if, for example, it is a class of an anonymous object).</source>
          <target state="translated">ソースコードで宣言されたクラスの単純な名前。クラスに名前がない場合は &lt;code&gt;null&lt;/code&gt; （たとえば、匿名オブジェクトのクラスの場合）。</target>
        </trans-unit>
        <trans-unit id="0290c571ea3c6c1d4ef5f1279658ebad7901a082" translate="yes" xml:space="preserve">
          <source>The simple name of the class as it was declared in the source code, or &lt;code&gt;null&lt;/code&gt; if the class has no name (if, for example, it is an anonymous object literal).</source>
          <target state="translated">ソースコードで宣言されたクラスの単純な名前、またはクラスに名前がない場合は &lt;code&gt;null&lt;/code&gt; （たとえば、匿名オブジェクトリテラルの場合）。</target>
        </trans-unit>
        <trans-unit id="4a78d65e883965ba15ad1eec8e7ccc645ad6c9f8" translate="yes" xml:space="preserve">
          <source>The simplest version doesn't require any additional parameters and creates one binary for each build type. Currently there a two build types available: &lt;code&gt;DEBUG&lt;/code&gt; (produces a not optimized binary with a debug information) and &lt;code&gt;RELEASE&lt;/code&gt; (produces an optimized binary without debug information). Consequently the following snippet creates two executable binaries: debug and release.</source>
          <target state="translated">最も単純なバージョンでは、追加のパラメーターは必要なく、ビルドタイプごとに1つのバイナリが作成されます。現在利用可能な2つのビルドタイプがあります： &lt;code&gt;DEBUG&lt;/code&gt; （デバッグ情報を含む最適化されていないバイナリを生成）および &lt;code&gt;RELEASE&lt;/code&gt; （デバッグ情報を含まない最適化されたバイナリを生成）。したがって、次のスニペットは、デバッグとリリースの2つの実行可能バイナリを作成します。</target>
        </trans-unit>
        <trans-unit id="0e7b9b0dd8fa90a8e9f2b4ea99f92d60e815b8b9" translate="yes" xml:space="preserve">
          <source>The single immutable C value. It is self-contained and doesn't depend on native memory.</source>
          <target state="translated">単一の不変C値。自己完結型で、ネイティブメモリには依存しません。</target>
        </trans-unit>
        <trans-unit id="d8e685c40e1d41520bbfb52a9a2cf6ce5cf4d2b1" translate="yes" xml:space="preserve">
          <source>The single-parent rule often becomes too limiting, as you'll often find commonalities between classes in different branches of a class hierarchy. These commonalities can be expressed in &lt;em&gt;interfaces&lt;/em&gt;.</source>
          <target state="translated">クラス階層の異なるブランチにあるクラス間の共通点を見つけることが多いため、単一親ルールは制限が多すぎることがよくあります。これらの共通点は、&lt;em&gt;インターフェース&lt;/em&gt;で表現でき&lt;em&gt;ます&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="ad2d029e0bf9000bbb670b32b9cfbfdfb5c64ee2" translate="yes" xml:space="preserve">
          <source>The solution is a &lt;em&gt;delegated property&lt;/em&gt;, which allows you to specify the behavior of getting and setting a property (somewhat similar to implementing &lt;code&gt;__getattribute__()&lt;/code&gt; and &lt;code&gt;__setattribute__()&lt;/code&gt; in Python, but for one property at a time).</source>
          <target state="translated">解決策は&lt;em&gt;委任されたプロパティです&lt;/em&gt;。これにより、プロパティの取得と設定の動作を指定できます &lt;code&gt;__setattribute__()&lt;/code&gt; Pythonで &lt;code&gt;__getattribute__()&lt;/code&gt; および__setattribute __（）を実装するのと少し似ていますが、一度に1つのプロパティに対して）。</target>
        </trans-unit>
        <trans-unit id="02ba30e8a0350e3498389f6bdcc51b4d923322f5" translate="yes" xml:space="preserve">
          <source>The solution is to mark the targets with a custom attribute, which is taken into account by Gradle during dependency resolution. This, however, must be done on both the library author and the consumer sides, and it's the library author's responsibility to communicate the attribute and its possible values to the consumers.</source>
          <target state="translated">解決策は、ターゲットにカスタム属性でマークを付けることで、依存関係の解決時に Gradle が考慮します。しかし、これはライブラリ作者と消費者の両方で行わなければならず、属性とその可能な値を消費者に伝えるのはライブラリ作者の責任です。</target>
        </trans-unit>
        <trans-unit id="4ce364ecc8aca93a0b9f937690067d3d1f6fcb4e" translate="yes" xml:space="preserve">
          <source>The sort is &lt;em&gt;stable&lt;/em&gt;. It means that equal elements preserve their order relative to each other after sorting.</source>
          <target state="translated">ソートは&lt;em&gt;安定してい&lt;/em&gt;ます。つまり、等しい要素は、並べ替え後も互いの順序を維持します。</target>
        </trans-unit>
        <trans-unit id="563e0866ee26fde4dae779a523cc71b4cbb6977d" translate="yes" xml:space="preserve">
          <source>The source set names are case-sensitive. When referring to a default source set by its name, make sure the name prefix matches a target's name, for example, a source set &lt;code&gt;iosX64Main&lt;/code&gt; for a target &lt;code&gt;iosX64&lt;/code&gt;.</source>
          <target state="translated">ソースセット名では大文字と小文字が区別されます。名前でデフォルトのソースセットを参照する場合は、名前のプレフィックスがターゲットの名前と一致していることを確認して &lt;code&gt;iosX64&lt;/code&gt; 。たとえば、ターゲットiosX64のソースセット &lt;code&gt;iosX64Main&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="11b3468dd6e9b05386099434c4ca46b0c2547522" translate="yes" xml:space="preserve">
          <source>The source sets DSL can be used to define these connections between the source sets:</source>
          <target state="translated">ソースセット間のこれらの接続を定義するために、ソースセットDSLを使用することができます。</target>
        </trans-unit>
        <trans-unit id="5ee1552c884a6b1c888ad99542230488f493bca7" translate="yes" xml:space="preserve">
          <source>The source sets are configured within a &lt;code&gt;sourceSets { ... }&lt;/code&gt; block of the &lt;code&gt;kotlin { ... }&lt;/code&gt; extension:</source>
          <target state="translated">ソースセットは、 &lt;code&gt;kotlin { ... }&lt;/code&gt; 拡張の &lt;code&gt;sourceSets { ... }&lt;/code&gt; ブロック内で構成されます。</target>
        </trans-unit>
        <trans-unit id="d4cf592997fcfc68c560b9248ead3349afe2d7c1" translate="yes" xml:space="preserve">
          <source>The specification of the requirements to the delegated object can be found &lt;a href=&quot;delegated-properties#property-delegate-requirements&quot;&gt;below&lt;/a&gt;.</source>
          <target state="translated">委任されたオブジェクトの要件の仕様は&lt;a href=&quot;delegated-properties#property-delegate-requirements&quot;&gt;以下にあります&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d73e9a80f0bf586c373c77dd33cae5cc1f592da3" translate="yes" xml:space="preserve">
          <source>The specified arrays are also considered deeply equal if both are &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">指定された配列も、両方が &lt;code&gt;null&lt;/code&gt; の場合、完全に等しいと見なされます。</target>
        </trans-unit>
        <trans-unit id="63949c8dfec16ede4c20d9d3cd58cdaf9f88fafe" translate="yes" xml:space="preserve">
          <source>The standard JavaDoc generation plugin (&lt;code&gt;maven-javadoc-plugin&lt;/code&gt;) does not support Kotlin code. To generate documentation for Kotlin projects, use &lt;a href=&quot;https://github.com/Kotlin/dokka&quot;&gt;Dokka&lt;/a&gt;; please refer to the &lt;a href=&quot;https://github.com/Kotlin/dokka/blob/master/README.md#using-the-maven-plugin&quot;&gt;Dokka README&lt;/a&gt; for configuration instructions. Dokka supports mixed-language projects and can generate output in multiple formats, including standard JavaDoc.</source>
          <target state="translated">標準のJavaDoc生成プラグイン（ &lt;code&gt;maven-javadoc-plugin&lt;/code&gt; ）はKotlinコードをサポートしていません。Kotlinプロジェクトのドキュメントを生成するには、&lt;a href=&quot;https://github.com/Kotlin/dokka&quot;&gt;Dokkaを&lt;/a&gt;使用します。設定手順については、&lt;a href=&quot;https://github.com/Kotlin/dokka/blob/master/README.md#using-the-maven-plugin&quot;&gt;Dokka README&lt;/a&gt;を参照してください。Dokkaは混合言語プロジェクトをサポートし、標準のJavaDocを含む複数の形式で出力を生成できます。</target>
        </trans-unit>
        <trans-unit id="bb8d32cf58d6a52257e9ed55a0d5c90647cf240f" translate="yes" xml:space="preserve">
          <source>The standard library contains a group of extension functions that let you filter collections in a single call. These functions leave the original collection unchanged, so they are available for both &lt;a href=&quot;collections-overview#collection-types&quot;&gt;mutable and read-only&lt;/a&gt; collections. To operate the filtering result, you should assign it to a variable or chain the functions after filtering.</source>
          <target state="translated">標準ライブラリには、1回の呼び出しでコレクションをフィルタリングできる拡張関数のグループが含まれています。これらの関数は元のコレクションを変更しないままにするため、&lt;a href=&quot;collections-overview#collection-types&quot;&gt;変更可能な&lt;/a&gt;コレクションと読み取り専用コレクションの両方で使用できます。フィルタリング結果を操作するには、フィルタリング結果を変数に割り当てるか、フィルタリング後に関数をチェーンする必要があります。</target>
        </trans-unit>
        <trans-unit id="64cd7cca211b28854215461360962734eb107f4c" translate="yes" xml:space="preserve">
          <source>The standard library defines a function named &lt;a href=&quot;../../../api/latest/jvm/stdlib/kotlin.js/as-dynamic&quot;&gt;&lt;code&gt;asDynamic()&lt;/code&gt;&lt;/a&gt; which casts a value to the dynamic type. Given our previous example where we used jQuery to work with DOM elements, we can now combine this with &lt;code&gt;asDynamic()&lt;/code&gt; to then invoke &lt;code&gt;dataTable()&lt;/code&gt; on the result:</source>
          <target state="translated">標準ライブラリは、値を動的型にキャストする&lt;a href=&quot;../../../api/latest/jvm/stdlib/kotlin.js/as-dynamic&quot;&gt; &lt;code&gt;asDynamic()&lt;/code&gt; &lt;/a&gt;という名前の関数を定義します。私たちは、DOM要素を持つ作品へのjQueryを使用前の例を考えると、我々は今でこれを組み合わせることができます &lt;code&gt;asDynamic()&lt;/code&gt; たinvoke、その後に &lt;code&gt;dataTable()&lt;/code&gt; の結果に：</target>
        </trans-unit>
        <trans-unit id="2f92a5708c1e21664731222bd701621446c56d87" translate="yes" xml:space="preserve">
          <source>The standard library now provides a set of functions for element-by-element operations on arrays: comparison (&lt;code&gt;contentEquals&lt;/code&gt; and &lt;code&gt;contentDeepEquals&lt;/code&gt;), hash code calculation (&lt;code&gt;contentHashCode&lt;/code&gt; and &lt;code&gt;contentDeepHashCode&lt;/code&gt;), and conversion to a string (&lt;code&gt;contentToString&lt;/code&gt; and &lt;code&gt;contentDeepToString&lt;/code&gt;). They're supported both for the JVM (where they act as aliases for the corresponding functions in &lt;code&gt;java.util.Arrays&lt;/code&gt;) and for JS (where the implementation is provided in the Kotlin standard library).</source>
          <target state="translated">標準ライブラリは、配列の要素 &lt;code&gt;contentEquals&lt;/code&gt; 操作のための一連の関数を提供します：比較（contentEqualsおよび &lt;code&gt;contentDeepEquals&lt;/code&gt; ）、ハッシュコード計算（ &lt;code&gt;contentHashCode&lt;/code&gt; および &lt;code&gt;contentDeepHashCode&lt;/code&gt; ）、および文字列への変換（ &lt;code&gt;contentToString&lt;/code&gt; および &lt;code&gt;contentDeepToString&lt;/code&gt; ）。これらは、JVM（ &lt;code&gt;java.util.Arrays&lt;/code&gt; の対応する関数のエイリアスとして機能する）とJS（実装がKotlin標準ライブラリで提供される）の両方でサポートされています。</target>
        </trans-unit>
        <trans-unit id="4cd1337efd07a01ae50fb56677c92729c05a2ca9" translate="yes" xml:space="preserve">
          <source>The standard library provides &lt;code&gt;Pair&lt;/code&gt; and &lt;code&gt;Triple&lt;/code&gt;. In most cases, though, named data classes are a better design choice, because they make the code more readable by providing meaningful names for properties.</source>
          <target state="translated">標準ライブラリは、 &lt;code&gt;Pair&lt;/code&gt; と &lt;code&gt;Triple&lt;/code&gt; 提供します。ただし、ほとんどの場合、名前付きデータクラスは、プロパティに意味のある名前を付けることでコードを読みやすくするため、より良い設計上の選択です。</target>
        </trans-unit>
        <trans-unit id="0fa7bf33e28a4e2133f3eb85b822f13a5861e747" translate="yes" xml:space="preserve">
          <source>The standard library provides us with a series of wrappers around DOM as well as functions to work with JavaScript, using static typing. What happens however when we want to use a library such as jQuery? Kotlin does not have its own &quot;header&quot; files for all the different libraries available on the JavaScript ecosystem however, TypeScript does. The &lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped/&quot;&gt;Definitely Typed repository&lt;/a&gt; provides us with a very large selection of header files.</source>
          <target state="translated">標準ライブラリは、静的なタイピングを使用して、JavaScriptを操作する関数だけでなく、DOMの一連のラッパーを提供します。しかし、jQueryなどのライブラリを使用したい場合はどうなりますか？Kotlinには、JavaScriptエコシステムで利用可能なすべての異なるライブラリ用の独自の「ヘッダー」ファイルはありませんが、TypeScriptにはあります。&lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped/&quot;&gt;確かに型指定されたリポジトリには、&lt;/a&gt;ヘッダファイルの非常に大きな選択を提供してくれます。</target>
        </trans-unit>
        <trans-unit id="5b02aa301d08018505c67b11eafce33e20430963" translate="yes" xml:space="preserve">
          <source>The standard library uses coroutines to support &lt;em&gt;lazily generated sequences&lt;/em&gt; with &lt;code&gt;yield&lt;/code&gt; and &lt;code&gt;yieldAll&lt;/code&gt; functions. In such a sequence, the block of code that returns sequence elements is suspended after each element has been retrieved, and resumed when the next element is requested. Here's an example:</source>
          <target state="translated">標準ライブラリは、コルーチンを使用し &lt;code&gt;yield&lt;/code&gt; 、 &lt;code&gt;yieldAll&lt;/code&gt; 関数とyieldAll関数で&lt;em&gt;遅延生成されたシーケンス&lt;/em&gt;をサポートします。このようなシーケンスでは、シーケンス要素を返すコードのブロックは、各要素が取得された後に中断され、次の要素が要求されたときに再開されます。次に例を示します。</target>
        </trans-unit>
        <trans-unit id="bd81d65292e2ed27e6a7bd7b3f70e04e3c6f5969" translate="yes" xml:space="preserve">
          <source>The status value in &lt;code&gt;@UnderMigration(status = ...)&lt;/code&gt; specifies how the compiler treats inappropriate usages of the annotated types in Kotlin (e.g. using a &lt;code&gt;@MyNullable&lt;/code&gt;-annotated type value as non-null):</source>
          <target state="translated">&lt;code&gt;@UnderMigration(status = ...)&lt;/code&gt; のステータス値は、コンパイラがKotlinの注釈付き型の不適切な使用をどのように処理するかを指定します（例： &lt;code&gt;@MyNullable&lt;/code&gt; MyNullable- 注釈付き型の値を非nullとして使用）：</target>
        </trans-unit>
        <trans-unit id="4dfa4a2af58e962d2e78195bb041069a8bfddba3" translate="yes" xml:space="preserve">
          <source>The step of the progression.</source>
          <target state="translated">進行のステップ。</target>
        </trans-unit>
        <trans-unit id="e2561323722fd466eed7e84734bba0e2d9a0a20e" translate="yes" xml:space="preserve">
          <source>The step value must be positive. If you need to count downwards, use the inclusive &lt;code&gt;downTo&lt;/code&gt;:</source>
          <target state="translated">ステップ値は正でなければなりません。下方にカウントする必要がある場合は、包括的な &lt;code&gt;downTo&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="ba5dcc36cf4e926283f2cf38c8b5b4a8a22b74ac" translate="yes" xml:space="preserve">
          <source>The subclass &lt;em&gt;inherits&lt;/em&gt; all members that exist in its superclass - both those that are directly defined in the superclass and the ones that the superclass itself has inherited. In this example, &lt;code&gt;Car&lt;/code&gt; contains the following members:</source>
          <target state="translated">サブクラスは、スーパークラスに存在&lt;em&gt;する&lt;/em&gt;すべてのメンバーを継承します。スーパークラスで直接定義されているメンバーと、スーパークラス自体が&lt;em&gt;継承&lt;/em&gt;したメンバーの両方が継承されます。この例では、 &lt;code&gt;Car&lt;/code&gt; には次のメンバーが含まれています。</target>
        </trans-unit>
        <trans-unit id="9587208b56b71c873bb976ba7dd19e63565c1783" translate="yes" xml:space="preserve">
          <source>The substring from the input string captured by this match.</source>
          <target state="translated">このマッチで捕捉された入力文字列の部分文字列。</target>
        </trans-unit>
        <trans-unit id="ef9d4de4ce3f425feef1d92bfbe702742ff76fe2" translate="yes" xml:space="preserve">
          <source>The syntax is: &lt;code&gt;val/var &amp;lt;property name&amp;gt;: &amp;lt;Type&amp;gt; by &amp;lt;expression&amp;gt;&lt;/code&gt;. The expression after &lt;em&gt;by&lt;/em&gt; is the &lt;em&gt;delegate&lt;/em&gt;, because &lt;code&gt;get()&lt;/code&gt; (and &lt;code&gt;set()&lt;/code&gt;) corresponding to the property will be delegated to its &lt;code&gt;getValue()&lt;/code&gt; and &lt;code&gt;setValue()&lt;/code&gt; methods. Property delegates don&amp;rsquo;t have to implement any interface, but they have to provide a &lt;code&gt;getValue()&lt;/code&gt; function (and &lt;code&gt;setValue()&lt;/code&gt; &amp;mdash; for &lt;em&gt;var&lt;/em&gt;s). For example:</source>
          <target state="translated">構文は次のとおりです： &lt;code&gt;val/var &amp;lt;property name&amp;gt;: &amp;lt;Type&amp;gt; by &amp;lt;expression&amp;gt;&lt;/code&gt; 。プロパティに対応する &lt;code&gt;get()&lt;/code&gt; （および &lt;code&gt;set()&lt;/code&gt; ）はその &lt;code&gt;getValue()&lt;/code&gt; および &lt;code&gt;setValue()&lt;/code&gt; メソッドに委譲されるため、&lt;em&gt;byの&lt;/em&gt;後の式は&lt;em&gt;delegate&lt;/em&gt;です。プロパティデリゲートはインターフェイスを実装する必要はありませんが、 &lt;code&gt;getValue()&lt;/code&gt; 関数（および&lt;em&gt;var&lt;/em&gt;の場合は &lt;code&gt;setValue()&lt;/code&gt; )を提供する必要があります。例えば：&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7f8b0e5f27ed7447035e9e8912fa4868135e5b36" translate="yes" xml:space="preserve">
          <source>The table below shows how Kotlin concepts are mapped to Swift/Objective-C and vice versa.</source>
          <target state="translated">下の表は、Kotlinの概念がSwift/Objective-Cにどのようにマッピングされているかを示しています。</target>
        </trans-unit>
        <trans-unit id="27aee67b81ecee081c926fb6403fc250a2669b58" translate="yes" xml:space="preserve">
          <source>The targets created from presets are added to the &lt;code&gt;kotlin.targets&lt;/code&gt; domain object collection, which can be used to access them by their names or configure all targets:</source>
          <target state="translated">プリセットから作成されたターゲットは、 &lt;code&gt;kotlin.targets&lt;/code&gt; ドメインオブジェクトコレクションに追加されます。これを使用して、名前でアクセスしたり、すべてのターゲットを構成したりできます。</target>
        </trans-unit>
        <trans-unit id="ea834ff7223c20a4c037e26a9eaa3ee2e490ee75" translate="yes" xml:space="preserve">
          <source>The terminology is that &lt;code&gt;var&lt;/code&gt; declares a &lt;em&gt;mutable&lt;/em&gt; variable, and that &lt;code&gt;val&lt;/code&gt; declares a &lt;em&gt;read-only&lt;/em&gt; or &lt;em&gt;assign-once&lt;/em&gt; variable - so both kinds are called &lt;em&gt;variables&lt;/em&gt;.</source>
          <target state="translated">用語は、 &lt;code&gt;var&lt;/code&gt; が&lt;em&gt;可変&lt;/em&gt;変数を宣言し、 &lt;code&gt;val&lt;/code&gt; が&lt;em&gt;読み取り専用&lt;/em&gt;変数または&lt;em&gt;代入式&lt;/em&gt;変数を宣言する&lt;em&gt;こと&lt;/em&gt;です-したがって、両方の種類は&lt;em&gt;変数&lt;/em&gt;と呼ばれ&lt;em&gt;ます&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="d2c1a93ffe9401881d7e0f5a7066475d9434f33d" translate="yes" xml:space="preserve">
          <source>The the &lt;a href=&quot;https://github.com/ilmat192/kotlin-native-serialization-sample&quot;&gt;example project&lt;/a&gt; for details.</source>
          <target state="translated">詳細については、&lt;a href=&quot;https://github.com/ilmat192/kotlin-native-serialization-sample&quot;&gt;サンプルプロジェクト&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="db0d4a97f9fddd6cc7f4a4e559ab92c9b243b3dc" translate="yes" xml:space="preserve">
          <source>The third option is for NPE-lovers: the not-null assertion operator (&lt;code&gt;!!&lt;/code&gt;) converts any value to a non-null type and throws an exception if the value is null. We can write &lt;code&gt;b!!&lt;/code&gt;, and this will return a non-null value of &lt;code&gt;b&lt;/code&gt; (e.g., a &lt;code&gt;String&lt;/code&gt; in our example) or throw an NPE if &lt;code&gt;b&lt;/code&gt; is null:</source>
          <target state="translated">3番目のオプションはNPE愛好家向けです。nullではないアサーション演算子（ &lt;code&gt;!!&lt;/code&gt; ）は、値をnull以外の型に変換し、値がnullの場合は例外をスローします。 &lt;code&gt;b!!&lt;/code&gt; 書けます!! 、これは &lt;code&gt;b&lt;/code&gt; の null以外の値（例ではこの例では &lt;code&gt;String&lt;/code&gt; ）を返すか、 &lt;code&gt;b&lt;/code&gt; がnullの場合はNPEをスローします。</target>
        </trans-unit>
        <trans-unit id="328eee564065ef14869693e4097fdfb0bb1e1ca4" translate="yes" xml:space="preserve">
          <source>The three targets are created with the preset functions &lt;code&gt;jvm()&lt;/code&gt;, &lt;code&gt;js()&lt;/code&gt;, and &lt;code&gt;mingwX64()&lt;/code&gt; that provide some &lt;a href=&quot;#default-project-layout&quot;&gt;default configuration&lt;/a&gt;. There are presets for each of the &lt;a href=&quot;#supported-platforms&quot;&gt;supported platforms&lt;/a&gt;.</source>
          <target state="translated">3つのターゲットは、いくつかの&lt;a href=&quot;#default-project-layout&quot;&gt;デフォルト構成&lt;/a&gt;を提供するプリセット関数 &lt;code&gt;jvm()&lt;/code&gt; 、 &lt;code&gt;js()&lt;/code&gt; 、および &lt;code&gt;mingwX64()&lt;/code&gt; で作成されます。&lt;a href=&quot;#supported-platforms&quot;&gt;サポートされているプラ​​ットフォーム&lt;/a&gt;ごとにプリセットがあります。</target>
        </trans-unit>
        <trans-unit id="865a447cbe3c80dc40999ce2ca6d480bd87143d3" translate="yes" xml:space="preserve">
          <source>The timeout event in &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-timeout.html&quot;&gt;withTimeout&lt;/a&gt; is asynchronous with respect to the code running in its block and may happen at any time, even right before the return from inside of the timeout block. Keep this in mind if you open or acquire some resource inside the block that needs closing or release outside of the block.</source>
          <target state="translated">&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-timeout.html&quot;&gt;withTimeout&lt;/a&gt;のタイムアウトイベントは、そのブロックで実行されているコードに関して非同期であり、タイムアウトブロック内から戻る直前であっても、いつでも発生する可能性があります。ブロック内でリソースを開いたり取得したりして、ブロック外で閉じるか解放する必要がある場合は、このことに注意してください。</target>
        </trans-unit>
        <trans-unit id="04def297d18523cf309971345c57324bf9993c18" translate="yes" xml:space="preserve">
          <source>The title case of a character is usually the same as its upper case with several exceptions. The particular list of characters with the special title case form depends on the underlying platform.</source>
          <target state="translated">文字のタイトルケースは、いくつかの例外を除いて、通常は大文字と同じです。特別なタイトルケース形式を持つ文字の特定のリストは、基礎となるプラットフォームに依存します。</target>
        </trans-unit>
        <trans-unit id="3871e9aa2f804023caa55782736ddd2a4dee3be1" translate="yes" xml:space="preserve">
          <source>The two characters are the same (as compared by the == operator)</source>
          <target state="translated">二つの文字は同じです(==演算子で比較すると</target>
        </trans-unit>
        <trans-unit id="43727256131e4c09e21487921129d951e5403bce" translate="yes" xml:space="preserve">
          <source>The type &lt;a href=&quot;exceptions#the-nothing-type&quot;&gt;&lt;code&gt;Nothing&lt;/code&gt;&lt;/a&gt; is special, because it has no natural counterpart in Java. Indeed, every Java reference type, including &lt;code&gt;java.lang.Void&lt;/code&gt;, accepts &lt;code&gt;null&lt;/code&gt; as a value, and &lt;code&gt;Nothing&lt;/code&gt; doesn't accept even that. So, this type cannot be accurately represented in the Java world. This is why Kotlin generates a raw type where an argument of type &lt;code&gt;Nothing&lt;/code&gt; is used:</source>
          <target state="translated">型&lt;a href=&quot;exceptions#the-nothing-type&quot;&gt; &lt;code&gt;Nothing&lt;/code&gt; &lt;/a&gt;は特別なものです。Javaには自然な型がないからです。実際、 &lt;code&gt;java.lang.Void&lt;/code&gt; を含むすべてのJava参照型は &lt;code&gt;null&lt;/code&gt; を値として受け入れ、 &lt;code&gt;Nothing&lt;/code&gt; はそれを受け入れません。したがって、このタイプはJavaの世界では正確に表すことができません。これが、Kotlinが &lt;code&gt;Nothing&lt;/code&gt; 型の引数が使用されるraw型を生成する理由です。</target>
        </trans-unit>
        <trans-unit id="5840d7b86dbf1ab10e5032023a9859ef434e1278" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;Boolean&lt;/code&gt; represents booleans, and has two values: &lt;em&gt;true&lt;/em&gt; and &lt;em&gt;false&lt;/em&gt;.</source>
          <target state="translated">&lt;code&gt;Boolean&lt;/code&gt; 型はブールを表し、&lt;em&gt;true&lt;/em&gt;と&lt;em&gt;falseの&lt;/em&gt; 2つの値があり&lt;em&gt;ます&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="fdef02e2cbe116b674c3a5cab83d13e4789bcc49" translate="yes" xml:space="preserve">
          <source>The type argument &lt;code&gt;T&lt;/code&gt; of &lt;code&gt;CPointer&amp;lt;T&amp;gt;&lt;/code&gt; must be one of the &quot;lvalue&quot; types described above, e.g., the C type &lt;code&gt;struct S*&lt;/code&gt; is mapped to &lt;code&gt;CPointer&amp;lt;S&amp;gt;&lt;/code&gt;, &lt;code&gt;int8_t*&lt;/code&gt; is mapped to &lt;code&gt;CPointer&amp;lt;int_8tVar&amp;gt;&lt;/code&gt;, and &lt;code&gt;char**&lt;/code&gt; is mapped to &lt;code&gt;CPointer&amp;lt;CPointerVar&amp;lt;ByteVar&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;CPointer&amp;lt;T&amp;gt;&lt;/code&gt; の型引数 &lt;code&gt;T&lt;/code&gt; は、上記の「lvalue」型のいずれかである必要があります。たとえば、C型 &lt;code&gt;struct S*&lt;/code&gt; は &lt;code&gt;CPointer&amp;lt;S&amp;gt;&lt;/code&gt; にマップされ、 &lt;code&gt;int8_t*&lt;/code&gt; は &lt;code&gt;CPointer&amp;lt;int_8tVar&amp;gt;&lt;/code&gt; マップされ、 &lt;code&gt;char**&lt;/code&gt; は &lt;code&gt;CPointer&amp;lt;CPointerVar&amp;lt;ByteVar&amp;gt;&amp;gt;&lt;/code&gt; マップされます。</target>
        </trans-unit>
        <trans-unit id="304e12f8621867e9197c2891cfb5db65d05e542f" translate="yes" xml:space="preserve">
          <source>The type arguments of generic function calls are also only checked at compile time. Inside the function bodies, the type parameters cannot be used for type checks, and type casts to type parameters (&lt;code&gt;foo as T&lt;/code&gt;) are unchecked. However, &lt;a href=&quot;inline-functions#reified-type-parameters&quot;&gt;reified type parameters&lt;/a&gt; of inline functions are substituted by the actual type arguments in the inlined function body at the call sites and thus can be used for type checks and casts, with the same restrictions for instances of generic types as described above.</source>
          <target state="translated">ジェネリック関数呼び出しの型引数も、コンパイル時にのみチェックされます。関数本体内では、型パラメーターは型チェックに使用できず、型パラメーター（ &lt;code&gt;foo as T&lt;/code&gt; ）への型キャストはチェックされません。ただし、インライン関数の&lt;a href=&quot;inline-functions#reified-type-parameters&quot;&gt;具体化された型パラメーター&lt;/a&gt;は、呼び出しサイトでインライン関数本体の実際の型引数で置き換えられるため、型チェックとキャストに使用でき、前述のジェネリック型のインスタンスと同じ制限があります。</target>
        </trans-unit>
        <trans-unit id="6d035411fbfdc1232561efb8b45fef51b9b3f1fe" translate="yes" xml:space="preserve">
          <source>The type of &lt;code&gt;safeDivide&lt;/code&gt; is &lt;code&gt;(Int, Int) -&amp;gt; Double&lt;/code&gt;. Note that unlike function type declarations, the parameter list of a lambda expression must not be enclosed in parentheses.</source>
          <target state="translated">&lt;code&gt;safeDivide&lt;/code&gt; のタイプは &lt;code&gt;(Int, Int) -&amp;gt; Double&lt;/code&gt; です。関数型宣言とは異なり、ラムダ式のパラメーターリストは括弧で囲まないでください。</target>
        </trans-unit>
        <trans-unit id="c50d2b6bc67063abeddc4b2628733da7784a58f0" translate="yes" xml:space="preserve">
          <source>The type of a property, and the types that are used for the parameters and the return type of a function, must be &quot;at least as visible&quot; as the property/function itself. For example, a public function can't take a private type as a parameter.</source>
          <target state="translated">プロパティの型、および関数のパラメータや戻り値の型に使用される型は、プロパティ/関数自体と同じように「少なくとも目に見える」ものでなければなりません。例えば、パブリック関数は、プライベート型をパラメータとして取ることはできません。</target>
        </trans-unit>
        <trans-unit id="8de1071b6667ea170a2315b344096736147854e4" translate="yes" xml:space="preserve">
          <source>The type of the &lt;code&gt;throw&lt;/code&gt; expression is the special type &lt;code&gt;Nothing&lt;/code&gt;. The type has no values and is used to mark code locations that can never be reached. In your own code, you can use &lt;code&gt;Nothing&lt;/code&gt; to mark a function that never returns:</source>
          <target state="translated">種類 &lt;code&gt;throw&lt;/code&gt; 式は、特殊なタイプではありません &lt;code&gt;Nothing&lt;/code&gt; 。タイプには値がなく、到達できないコードの場所をマークするために使用されます。独自のコードでは、 &lt;code&gt;Nothing&lt;/code&gt; を使用して、決して返されない関数をマークできます。</target>
        </trans-unit>
        <trans-unit id="23c18621bf7101376cb4104c69faad184a7d75d0" translate="yes" xml:space="preserve">
          <source>The type of these expressions is the &lt;a href=&quot;exceptions#the-nothing-type&quot;&gt;Nothing type&lt;/a&gt;.</source>
          <target state="translated">これらの式のタイプは&lt;a href=&quot;exceptions#the-nothing-type&quot;&gt;Nothingタイプ&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="28dfc8e3403b9f6de19da78b037825e3337aa674" translate="yes" xml:space="preserve">
          <source>The type of values returned by this callable.</source>
          <target state="translated">このコールアブルが返す値の型。</target>
        </trans-unit>
        <trans-unit id="724404b217f8e33affca4710ff6d760dfbd8b8e9" translate="yes" xml:space="preserve">
          <source>The type safety checks that Kotlin performs for generic declaration usages are only done at compile time. At runtime, the instances of generic types do not hold any information about their actual type arguments. The type information is said to be &lt;em&gt;erased&lt;/em&gt;. For example, the instances of &lt;code&gt;Foo&amp;lt;Bar&amp;gt;&lt;/code&gt; and &lt;code&gt;Foo&amp;lt;Baz?&amp;gt;&lt;/code&gt; are erased to just &lt;code&gt;Foo&amp;lt;*&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Kotlinが一般的な宣言の使用法に対して実行する型安全性チェックは、コンパイル時にのみ行われます。実行時、ジェネリック型のインスタンスは、実際の型引数に関する情報を保持しません。タイプ情報は&lt;em&gt;消去さ&lt;/em&gt;れるといいます。たとえば、 &lt;code&gt;Foo&amp;lt;Bar&amp;gt;&lt;/code&gt; および &lt;code&gt;Foo&amp;lt;Baz?&amp;gt;&lt;/code&gt; のインスタンスは &lt;code&gt;Foo&amp;lt;*&amp;gt;&lt;/code&gt; 消去されます。</target>
        </trans-unit>
        <trans-unit id="bd9368e467f6513ce687f28529e6a3ccfb31bd57" translate="yes" xml:space="preserve">
          <source>The type specified after a colon is the &lt;strong&gt;upper bound&lt;/strong&gt;: only a subtype of &lt;code&gt;Comparable&amp;lt;T&amp;gt;&lt;/code&gt; may be substituted for &lt;code&gt;T&lt;/code&gt;. For example:</source>
          <target state="translated">コロンの後に指定されたタイプが&lt;strong&gt;上限&lt;/strong&gt;です &lt;code&gt;T&lt;/code&gt; 代わりに使用できるのは、 &lt;code&gt;Comparable&amp;lt;T&amp;gt;&lt;/code&gt; サブタイプのみです。例えば：</target>
        </trans-unit>
        <trans-unit id="195a81820ffdceacb4b4779278f03f44e25e239e" translate="yes" xml:space="preserve">
          <source>The type specified in the projection, or &lt;code&gt;null&lt;/code&gt; if this is a star projection.</source>
          <target state="translated">プロジェクションで指定されたタイプ。これがスタープロジェクションの場合は &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e184ade95bbad48da746688d8668a604f12d3467" translate="yes" xml:space="preserve">
          <source>The type with only one value: the &lt;code&gt;Unit&lt;/code&gt; object.</source>
          <target state="translated">値が1つしかないタイプ： &lt;code&gt;Unit&lt;/code&gt; オブジェクト。</target>
        </trans-unit>
        <trans-unit id="19328e2c828d83e68c896264bdfa85a39aa786f7" translate="yes" xml:space="preserve">
          <source>The type with only one value: the &lt;code&gt;Unit&lt;/code&gt; object. This type corresponds to the &lt;code&gt;void&lt;/code&gt; type in Java.</source>
          <target state="translated">値が1つしかないタイプ： &lt;code&gt;Unit&lt;/code&gt; オブジェクト。この型は、Java の &lt;code&gt;void&lt;/code&gt; 型に対応しています。</target>
        </trans-unit>
        <trans-unit id="7008246671a61ed2da63a9b1d753eac75888ec6a" translate="yes" xml:space="preserve">
          <source>The types inside the angle brackets are called &lt;em&gt;generic type parameters&lt;/em&gt;, which we will cover later. In short, it's a useful technique to make a class that is tied to another class (such as a container class, which is tied to its element class) applicable to many different classes.</source>
          <target state="translated">山かっこ内の&lt;em&gt;型&lt;/em&gt;は、&lt;em&gt;総称型パラメーター&lt;/em&gt;と呼ばれ&lt;em&gt;ます&lt;/em&gt;。これについては後で説明します。つまり、別のクラスに関連付けられているクラス（要素クラスに関連付けられているコンテナークラスなど）をさまざまなクラスに適用できるようにすることは、便利な手法です。</target>
        </trans-unit>
        <trans-unit id="608adb2d4b11107c32aaf63109063a2afc4cba2c" translate="yes" xml:space="preserve">
          <source>The unconfined dispatcher is an advanced mechanism that can be helpful in certain corner cases where dispatching of a coroutine for its execution later is not needed or produces undesirable side-effects, because some operation in a coroutine must be performed right away. The unconfined dispatcher should not be used in general code.</source>
          <target state="translated">不確定ディスパッチャは高度なメカニズムであり、コー ルーチンの中のいくつかの操作がすぐに実行されなければならないため、後で実行するためにコー ルーチンをディスパッチする必要がなかったり、望ましくない副作用が発生したりするような場合に役立ちます。不確定ディスパッチャは、一般的なコードでは使用すべきではありません。</target>
        </trans-unit>
        <trans-unit id="3b16b6543fccfa319ed1bb173131c9217c5b8ccc" translate="yes" xml:space="preserve">
          <source>The usage from C is straightforward and uncomplicated. We create a &lt;code&gt;main.c&lt;/code&gt; file with the following code:</source>
          <target state="translated">Cからの使用法は簡単で複雑ではありません。次のコードで &lt;code&gt;main.c&lt;/code&gt; ファイルを作成します。</target>
        </trans-unit>
        <trans-unit id="eda63df3b0cc777042c5e16e6a7e9e820a7f02bd" translate="yes" xml:space="preserve">
          <source>The usage is pretty similar to all-open.</source>
          <target state="translated">使い方はオールオープンとかなり似ています。</target>
        </trans-unit>
        <trans-unit id="d4460c6a02beaa088565d93296bf84c132fa91dd" translate="yes" xml:space="preserve">
          <source>The usage is the same to all-open and no-arg, except the fact that sam-with-receiver does not have any built-in presets, and you need to specify your own list of special-treated annotations.</source>
          <target state="translated">使い方は all-open や no-arg と同じですが、sam-with-receiver には組み込みのプリセットがなく、特殊な処理を施したアノテーションのリストを自分で指定する必要があるという点を除いては、all-open や no-arg と同じです。</target>
        </trans-unit>
        <trans-unit id="79d6496f32a4f62877c61deb0bd17640fe23059a" translate="yes" xml:space="preserve">
          <source>The use cases of different functions overlap, so that you can choose the functions based on the specific conventions used in your project or team.</source>
          <target state="translated">異なる機能のユースケースが重なっているので、プロジェクトやチームで使用されている具体的な規約に基づいて機能を選択することができます。</target>
        </trans-unit>
        <trans-unit id="882548c8ded53fae119e86e0601fc1f2361824a2" translate="yes" xml:space="preserve">
          <source>The use-site variance specified in the projection, or &lt;code&gt;null&lt;/code&gt; if this is a star projection.</source>
          <target state="translated">投影法で指定された使用場所の分散。これがスター投影法の場合は &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f6253f8d51fcab2be72d37974c28482731bda531" translate="yes" xml:space="preserve">
          <source>The value being held by this class.</source>
          <target state="translated">このクラスが保持している値。</target>
        </trans-unit>
        <trans-unit id="3c6df952c69c83c655c026cd3cab96c052641127" translate="yes" xml:space="preserve">
          <source>The value must be positive and &lt;a href=&quot;../../kotlin/-int/-m-a-x_-v-a-l-u-e#kotlin.Int.Companion%24MAX_VALUE&quot;&gt;Int.MAX_VALUE&lt;/a&gt; is used to specify an unlimited depth.</source>
          <target state="translated">値は正でなければならず、&lt;a href=&quot;../../kotlin/-int/-m-a-x_-v-a-l-u-e#kotlin.Int.Companion%24MAX_VALUE&quot;&gt;Int.MAX_VALUE&lt;/a&gt;を使用して無制限の深さを指定します。</target>
        </trans-unit>
        <trans-unit id="239f4ace7ed276249b435b6f6174eb7de8fef7a5" translate="yes" xml:space="preserve">
          <source>The value of captured group.</source>
          <target state="translated">捕獲されたグループの値。</target>
        </trans-unit>
        <trans-unit id="af704602dd7474776e5b688f4b067018b5e41c89" translate="yes" xml:space="preserve">
          <source>The value of this variable.</source>
          <target state="translated">この変数の値。</target>
        </trans-unit>
        <trans-unit id="3aabcc212c1608210121013dee11f396d22f4fca" translate="yes" xml:space="preserve">
          <source>The variable containing a &lt;a href=&quot;-c-opaque-pointer&quot;&gt;COpaquePointer&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;-c-opaque-pointer&quot;&gt;COpaquePointer&lt;/a&gt;を含む変数。</target>
        </trans-unit>
        <trans-unit id="e9b853cf2301d69ed0ca13dfc9180094e7f3e288" translate="yes" xml:space="preserve">
          <source>The version of the bytecode interface (naming conventions, signatures) of the class file annotated with this annotation.</source>
          <target state="translated">このアノテーションでアノテーションされたクラス・ファイルのバイトコード・インターフェース(命名規則、シグネチャ)のバージョン。</target>
        </trans-unit>
        <trans-unit id="1abfb175c8f11a4b2665f4fbd6b2ed384b7a75ef" translate="yes" xml:space="preserve">
          <source>The version of the metadata provided in the arguments of this annotation.</source>
          <target state="translated">このアノテーションの引数で提供されるメタデータのバージョン。</target>
        </trans-unit>
        <trans-unit id="b210bbe6f64c596cb275d652b699dc315a1fc8bc" translate="yes" xml:space="preserve">
          <source>The very first part contains the standard C/C++ header and footer:</source>
          <target state="translated">非常に最初の部分には、標準のC/C++ヘッダーとフッターが含まれています。</target>
        </trans-unit>
        <trans-unit id="13204b21b51f8144497368ed89b8d47c465b75a3" translate="yes" xml:space="preserve">
          <source>The visibility level only affects the &lt;em&gt;lexical visibility&lt;/em&gt; of the &lt;em&gt;symbol&lt;/em&gt; - i.e., where the compiler allows you to type out the symbol. It does not affect where &lt;em&gt;instances&lt;/em&gt; are used: for example, a public top-level function may well return an instance of a private class, as long as the return type doesn't mention the private class name but is instead a public base class of the private class (possibly &lt;code&gt;Any&lt;/code&gt;) or a public interface that the private class implements. When you &lt;a href=&quot;inheritance#subclassing&quot;&gt;subclass&lt;/a&gt; a class, its private members are also inherited by the subclass, but are not directly accessible there - however, if you call an inherited public function that happens to access a private member, that's fine.</source>
          <target state="translated">可視性レベルは、&lt;em&gt;シンボルの&lt;/em&gt;&lt;em&gt;字句可視性&lt;/em&gt;にのみ影響します。つまり、コンパイラーがシンボルを入力できる場所です。&lt;em&gt;インスタンス&lt;/em&gt;が使用される場所には影響しません。&lt;em&gt;たとえば&lt;/em&gt;、戻り値の型がプライベートクラス名に言及せず、代わりにパブリックベースクラスである限り、パブリックトップレベル関数はプライベートクラスのインスタンスを返す可能性があります。プライベートクラス（おそらく &lt;code&gt;Any&lt;/code&gt; ）またはプライベートクラスが実装するパブリックインターフェイスクラスを&lt;a href=&quot;inheritance#subclassing&quot;&gt;サブクラス化&lt;/a&gt;すると、そのプライベートメンバーもサブクラスによって継承されますが、そこで直接アクセスすることはできません。ただし、継承されたパブリック関数を呼び出して、プライベートメンバーにアクセスする場合は問題ありません。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="be08405fa49b795ce8dcbbade59f22553916f972" translate="yes" xml:space="preserve">
          <source>The way in which we'd use this from JavaScript would be to call &lt;code&gt;dataTable()&lt;/code&gt; on the corresponding &lt;code&gt;&amp;lt;table&amp;gt;&lt;/code&gt; element</source>
          <target state="translated">これをJavaScriptから使用する方法は、対応する &lt;code&gt;&amp;lt;table&amp;gt;&lt;/code&gt; 要素で &lt;code&gt;dataTable()&lt;/code&gt; を呼び出すことです。</target>
        </trans-unit>
        <trans-unit id="df6c92cd4ac7021995eb7f605c7d7406310257be" translate="yes" xml:space="preserve">
          <source>The way to refer to the context object</source>
          <target state="translated">コンテキストオブジェクトの参照方法</target>
        </trans-unit>
        <trans-unit id="db21ceeaa7842bb619c97af30e1e09b94faa6e61" translate="yes" xml:space="preserve">
          <source>The web site has a bunch of &lt;a href=&quot;https://kotlinlang.org/community/&quot;&gt;online resources&lt;/a&gt;, including &lt;a href=&quot;https://kotlin.link&quot;&gt;Kotlin Digests&lt;/a&gt; by community members, a &lt;a href=&quot;http://www.kotlinweekly.net&quot;&gt;newsletter&lt;/a&gt;, a &lt;a href=&quot;https://talkingkotlin.com&quot;&gt;podcast&lt;/a&gt; and more.</source>
          <target state="translated">ウェブサイトには、たくさんの持っている&lt;a href=&quot;https://kotlinlang.org/community/&quot;&gt;オンラインリソース&lt;/a&gt;を含め、&lt;a href=&quot;https://kotlin.link&quot;&gt;Kotlinダイジェスト&lt;/a&gt;コミュニティのメンバーによって、&lt;a href=&quot;http://www.kotlinweekly.net&quot;&gt;ニュースレター&lt;/a&gt;、&lt;a href=&quot;https://talkingkotlin.com&quot;&gt;ポッドキャスト&lt;/a&gt;などを。</target>
        </trans-unit>
        <trans-unit id="ffaad4042bec05249e2007ea2e2a7c01e5b1b264" translate="yes" xml:space="preserve">
          <source>Then add the respective dependencies using the &lt;code&gt;kapt&lt;/code&gt; configuration in your &lt;code&gt;dependencies&lt;/code&gt; block:</source>
          <target state="translated">次に、 &lt;code&gt;dependencies&lt;/code&gt; ブロックの &lt;code&gt;kapt&lt;/code&gt; 構成を使用して、それぞれの依存関係を追加します。</target>
        </trans-unit>
        <trans-unit id="3d3dd4715a6e839facb3a4bc6c2872f8802ec4b8" translate="yes" xml:space="preserve">
          <source>Then follow the wizard steps. You'll have a &lt;code&gt;build.gradle&lt;/code&gt; file created with Kotlin configured according to &lt;a href=&quot;../../reference/using-gradle&quot;&gt;this document&lt;/a&gt;. Make sure it's configured for Kotlin 1.3 or higher.</source>
          <target state="translated">次に、ウィザードの手順に従います。&lt;a href=&quot;../../reference/using-gradle&quot;&gt;このドキュメント&lt;/a&gt;に従って構成されたKotlinで作成された &lt;code&gt;build.gradle&lt;/code&gt; ファイルがあります。Kotlin 1.3以降用に設定されていることを確認してください。</target>
        </trans-unit>
        <trans-unit id="9ed3e436c4ee364169e1bdacb724480b6ae120b2" translate="yes" xml:space="preserve">
          <source>Then follow the wizard steps. You'll have a &lt;code&gt;pom.xml&lt;/code&gt; file created with Kotlin configured according to &lt;a href=&quot;../../reference/using-maven&quot;&gt;this document&lt;/a&gt;. Make sure it's configured for Kotlin 1.3 or higher.</source>
          <target state="translated">次に、ウィザードの手順に従います。&lt;a href=&quot;../../reference/using-maven&quot;&gt;このドキュメント&lt;/a&gt;に従って構成されたKotlinで作成された &lt;code&gt;pom.xml&lt;/code&gt; ファイルがあります。Kotlin 1.3以降用に設定されていることを確認してください。</target>
        </trans-unit>
        <trans-unit id="10cfe3c1803900b3459055c1fdedb21ced35e4cd" translate="yes" xml:space="preserve">
          <source>Then run the &lt;code&gt;cinterop&lt;/code&gt; tool with something like this (note that for host libraries that are not included in the sysroot search paths, headers may be needed):</source>
          <target state="translated">次に、 &lt;code&gt;cinterop&lt;/code&gt; ツールを次のように実行します（sysroot検索パスに含まれていないホストライブラリの場合、ヘッダーが必要になる場合があります）。</target>
        </trans-unit>
        <trans-unit id="5581239ffa3d854f1837127435e240d49f122ba5" translate="yes" xml:space="preserve">
          <source>Then specify the list of SAM-with-receiver annotations:</source>
          <target state="translated">次に、SAM-with-receiverアノテーションのリストを指定します。</target>
        </trans-unit>
        <trans-unit id="9b78fa9ef8a36ffde61cb8bc4f298109afadcbee" translate="yes" xml:space="preserve">
          <source>Then specify the list of annotations that will make classes open:</source>
          <target state="translated">次に、クラスをオープンにするアノテーションのリストを指定します。</target>
        </trans-unit>
        <trans-unit id="fd73374c27e0a874f2f41c35f033bfc599a82d6b" translate="yes" xml:space="preserve">
          <source>Then specify the list of no-arg annotations:</source>
          <target state="translated">次に、引数なしのアノテーションのリストを指定します。</target>
        </trans-unit>
        <trans-unit id="0ef92249fe5f505a551a8b463644321da779af43" translate="yes" xml:space="preserve">
          <source>Then we can have several processor coroutines. In this example, they just print their id and received number:</source>
          <target state="translated">そうすれば、いくつかのプロセッサ・コルーチンを持つことができます。この例では、彼らは自分のIDと受信番号を表示するだけです。</target>
        </trans-unit>
        <trans-unit id="490b87ea6044ef60c21b2e7783571a7d77df8b12" translate="yes" xml:space="preserve">
          <source>Then we define a function that launches an actor using an &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/actor.html&quot;&gt;actor&lt;/a&gt; coroutine builder:</source>
          <target state="translated">次に、&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/actor.html&quot;&gt;アクター&lt;/a&gt;コルーチンビルダーを使用してアクターを起動する関数を定義します。</target>
        </trans-unit>
        <trans-unit id="843feae1b1434f20428d159db5d3289af1525e9c" translate="yes" xml:space="preserve">
          <source>Then, for each &lt;a href=&quot;https://developer.android.com/studio/build/build-variants#sourcesets&quot;&gt;Android source set&lt;/a&gt; compiled by the variants, a Kotlin source set is created under that source set name prepended by the target name, like Kotlin source set &lt;code&gt;androidDebug&lt;/code&gt; for an Android source set &lt;code&gt;debug&lt;/code&gt; and the Kotlin target named &lt;code&gt;android&lt;/code&gt;. These Kotlin source sets are added to the variants compilations accordingly.</source>
          <target state="translated">次に、バリアントによってコンパイルされた&lt;a href=&quot;https://developer.android.com/studio/build/build-variants#sourcesets&quot;&gt;Androidソースセット&lt;/a&gt;ごとに、ターゲット名が前に付けられたソースセット名の下にKotlinソースセットが作成されます。 &lt;code&gt;androidDebug&lt;/code&gt; 、Androidソースセット &lt;code&gt;debug&lt;/code&gt; 用のKotlinソースセットandroidDebugおよび &lt;code&gt;android&lt;/code&gt; という名前のKotlinターゲットです。これらのKotlinソースセットは、それに応じてバリアントコンパイルに追加されます。</target>
        </trans-unit>
        <trans-unit id="68562aa9b0f180cb0bf47fd690042cd2286c6294" translate="yes" xml:space="preserve">
          <source>Then, it would be perfectly safe to store a reference to an instance of &lt;code&gt;Source&amp;lt;String&amp;gt;&lt;/code&gt; in a variable of type &lt;code&gt;Source&amp;lt;Object&amp;gt;&lt;/code&gt; &amp;ndash; there are no consumer-methods to call. But Java does not know this, and still prohibits it:</source>
          <target state="translated">その後、 &lt;code&gt;Source&amp;lt;Object&amp;gt;&lt;/code&gt; 型の変数に &lt;code&gt;Source&amp;lt;String&amp;gt;&lt;/code&gt; インスタンスへの参照を格納することは完全に安全です。呼び出すコンシューマメソッドはありません。しかし、Javaはこれを認識しておらず、依然として禁止しています。</target>
        </trans-unit>
        <trans-unit id="d673d7a939528ccf7977db751d0c7bd0f923bb89" translate="yes" xml:space="preserve">
          <source>Then, once a target is added, default compilations are created for it:</source>
          <target state="translated">そして、ターゲットが追加されると、そのターゲット用のデフォルトのコンパイルが作成されます。</target>
        </trans-unit>
        <trans-unit id="a7b51b664e8983298e6dc346e7c7dc0b18863813" translate="yes" xml:space="preserve">
          <source>Then, some time later the deprecation level is raised to &lt;a href=&quot;../-deprecation-level/-e-r-r-o-r#kotlin.DeprecationLevel.ERROR&quot;&gt;DeprecationLevel.ERROR&lt;/a&gt;, so that no new Kotlin code can be compiled using the deprecated API.</source>
          <target state="translated">その後、しばらくして非推奨レベルが&lt;a href=&quot;../-deprecation-level/-e-r-r-o-r#kotlin.DeprecationLevel.ERROR&quot;&gt;DeprecationLevel.ERROR&lt;/a&gt;に引き上げられ、非推奨のAPIを使用して新しいKotlinコードをコンパイルできなくなります。</target>
        </trans-unit>
        <trans-unit id="b6377e7d0f06e408f80f03d549dd08ce8d9b969c" translate="yes" xml:space="preserve">
          <source>Then, the only thing we want to ensure is that &lt;code&gt;copy()&lt;/code&gt; does not do any bad things. We want to prohibit it from &lt;strong&gt;writing&lt;/strong&gt; to &lt;code&gt;from&lt;/code&gt;, and we can:</source>
          <target state="translated">次に、確認したい唯一のことは、 &lt;code&gt;copy()&lt;/code&gt; が悪いことをしないことです。私たちは、からそれを禁止したい&lt;strong&gt;書き込み&lt;/strong&gt;に &lt;code&gt;from&lt;/code&gt; 、私たちは次のことができます。</target>
        </trans-unit>
        <trans-unit id="2e04f4cdf39ff6bfe2fd15e1cdcb551eff15e642" translate="yes" xml:space="preserve">
          <source>There are a few courses available for Kotlin, including a &lt;a href=&quot;https://www.pluralsight.com/courses/kotlin-getting-started&quot;&gt;Pluralsight Kotlin Course&lt;/a&gt; by Kevin Jones, an &lt;a href=&quot;http://shop.oreilly.com/product/0636920052982.do&quot;&gt;O&amp;rsquo;Reilly Course&lt;/a&gt; by Hadi Hariri and an &lt;a href=&quot;http://petersommerhoff.com/dev/kotlin/kotlin-beginner-tutorial/&quot;&gt;Udemy Kotlin Course&lt;/a&gt; by Peter Sommerhoff.</source>
          <target state="translated">含むKotlinために利用可能ないくつかのコースがある&lt;a href=&quot;https://www.pluralsight.com/courses/kotlin-getting-started&quot;&gt;Pluralsight Kotlinコース&lt;/a&gt;ケビン・ジョーンズは、&lt;a href=&quot;http://shop.oreilly.com/product/0636920052982.do&quot;&gt;オライリーコースは&lt;/a&gt;ハディ・ハリリとによって&lt;a href=&quot;http://petersommerhoff.com/dev/kotlin/kotlin-beginner-tutorial/&quot;&gt;Udemy Kotlinコース&lt;/a&gt;ピーターSommerhoffによります。</target>
        </trans-unit>
        <trans-unit id="7aeb1151dcad680105c7a075482911c8fc7a00f6" translate="yes" xml:space="preserve">
          <source>There are a lot of built-in extension functions/properties in Kotlin - for example, &lt;code&gt;map()&lt;/code&gt;, &lt;code&gt;filter()&lt;/code&gt;, and the rest of the framework for processing collections in a functional manner is built using extension functions.</source>
          <target state="translated">Kotlinには、 &lt;code&gt;map()&lt;/code&gt; 、 &lt;code&gt;filter()&lt;/code&gt; などの組み込みの拡張関数/プロパティが多数あり、コレクションを機能的に処理するための残りのフレームワークは、拡張関数を使用して構築されます。</target>
        </trans-unit>
        <trans-unit id="24f819fcebc7b01f0f49b06a15eca941aac602cd" translate="yes" xml:space="preserve">
          <source>There are already &lt;a href=&quot;https://kotlinlang.org/docs/books.html&quot;&gt;a number of books&lt;/a&gt; available for Kotlin, including &lt;a href=&quot;https://www.manning.com/books/kotlin-in-action&quot;&gt;Kotlin in Action&lt;/a&gt; which is by Kotlin team members Dmitry Jemerov and Svetlana Isakova, &lt;a href=&quot;https://leanpub.com/kotlin-for-android-developers&quot;&gt;Kotlin for Android Developers&lt;/a&gt; targeted at Android developers.</source>
          <target state="translated">Kotlinで利用可能な&lt;a href=&quot;https://kotlinlang.org/docs/books.html&quot;&gt;書籍&lt;/a&gt;はすでに多数あります。Kotlinin &lt;a href=&quot;https://www.manning.com/books/kotlin-in-action&quot;&gt;Action&lt;/a&gt;は、KotlinチームメンバーのDmitry JemerovとSvetlana Isakovaによるもので&lt;a href=&quot;https://leanpub.com/kotlin-for-android-developers&quot;&gt;、Android開発者向けのAndroid開発者向けのKotlinです&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cafdda410a7a8fb3e86649e5eeda1f41cb52882f" translate="yes" xml:space="preserve">
          <source>There are also functions for creating collections without any elements: &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/empty-list&quot;&gt;&lt;code&gt;emptyList()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/empty-set&quot;&gt;&lt;code&gt;emptySet()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/empty-map&quot;&gt;&lt;code&gt;emptyMap()&lt;/code&gt;&lt;/a&gt;. When creating empty collections, you should specify the type of elements that the collection will hold.</source>
          <target state="translated">要素のないコレクションを作成するための関数もあります：&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/empty-list&quot;&gt; &lt;code&gt;emptyList()&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/empty-set&quot;&gt; &lt;code&gt;emptySet()&lt;/code&gt; &lt;/a&gt;、および&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/empty-map&quot;&gt; &lt;code&gt;emptyMap()&lt;/code&gt; &lt;/a&gt;。空のコレクションを作成するときは、コレクションが保持する要素のタイプを指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="843241bb0f5eb80f440f0b1b3622ce9c95598c3b" translate="yes" xml:space="preserve">
          <source>There are also functions for retrieving the smallest and the largest elements by certain selector function or custom &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-comparator/index&quot;&gt;&lt;code&gt;Comparator&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">特定のセレクター関数またはカスタム&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-comparator/index&quot;&gt; &lt;code&gt;Comparator&lt;/code&gt; &lt;/a&gt;レーターによって最小要素と最大要素を取得するための関数もあります。</target>
        </trans-unit>
        <trans-unit id="4888d99de496e5f2812e2d42599de7f621ae0a73" translate="yes" xml:space="preserve">
          <source>There are also functions that narrow the element type by filtering elements of a given type:</source>
          <target state="translated">また、与えられた型の要素をフィルタリングすることで、要素の型を絞り込む機能もあります。</target>
        </trans-unit>
        <trans-unit id="22fc645d90366ef3cbd36340e10852155ba93121" translate="yes" xml:space="preserve">
          <source>There are also many recordings of &lt;a href=&quot;http://kotlinlang.org/community/talks.html&quot;&gt;Kotlin talks&lt;/a&gt; available on YouTube and Vimeo.</source>
          <target state="translated">YouTubeとVimeoで利用可能な&lt;a href=&quot;http://kotlinlang.org/community/talks.html&quot;&gt;Kotlinの講演の&lt;/a&gt;録音も多数あります。</target>
        </trans-unit>
        <trans-unit id="e4606566df8d7d15d5ed6bd46e8178f7ee899fb7" translate="yes" xml:space="preserve">
          <source>There are also more specific types:</source>
          <target state="translated">さらに具体的なタイプもあります。</target>
        </trans-unit>
        <trans-unit id="06489c1e98a1df08c22af1c2c8a1f880cc0522a9" translate="yes" xml:space="preserve">
          <source>There are also some tools available to convert between Kotlin and C strings manually:</source>
          <target state="translated">また、KotlinとC言語の文字列を手動で変換するツールもあります。</target>
        </trans-unit>
        <trans-unit id="5da1b83a877bec99a63204ac23c3a863bcc7d2fe" translate="yes" xml:space="preserve">
          <source>There are also the following type qualifiers in the C language: &lt;code&gt;const&lt;/code&gt;, &lt;code&gt;volatile&lt;/code&gt;, &lt;code&gt;restruct&lt;/code&gt;, &lt;code&gt;atomic&lt;/code&gt;.</source>
          <target state="translated">C言語の型修飾子には、 &lt;code&gt;const&lt;/code&gt; 、 &lt;code&gt;volatile&lt;/code&gt; 、 &lt;code&gt;restruct&lt;/code&gt; 、 &lt;code&gt;atomic&lt;/code&gt; もあります。</target>
        </trans-unit>
        <trans-unit id="d1856539b37f6f362e28eec082e8282bf62fdd7b" translate="yes" xml:space="preserve">
          <source>There are also two specific ways for filtering maps: by keys and by values. For each way, there is a function: &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/filter-keys&quot;&gt;&lt;code&gt;filterKeys()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/filter-values&quot;&gt;&lt;code&gt;filterValues()&lt;/code&gt;&lt;/a&gt;. Both return a new map of entries which match the given predicate. The predicate for &lt;code&gt;filterKeys()&lt;/code&gt; checks only the element keys, the one for &lt;code&gt;filterValues()&lt;/code&gt; checks only values.</source>
          <target state="translated">マップのフィルタリングには、キーと値による2つの特定の方法もあります。それぞれの方法について、&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/filter-keys&quot;&gt; &lt;code&gt;filterKeys()&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/filter-values&quot;&gt; &lt;code&gt;filterValues()&lt;/code&gt; &lt;/a&gt;という関数があります。どちらも、指定された述語に一致するエントリの新しいマップを返します。以下のための述語 &lt;code&gt;filterKeys()&lt;/code&gt; をチェックするだけの要素キー、のための1つ &lt;code&gt;filterValues()&lt;/code&gt; チェック値のみ。</target>
        </trans-unit>
        <trans-unit id="250044abbac1d0cc39bffb2b00e37419c1aa5fa8" translate="yes" xml:space="preserve">
          <source>There are also useful aliases for retrieving the first and the last element of the collection: &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/first&quot;&gt;&lt;code&gt;first()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/last&quot;&gt;&lt;code&gt;last()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">コレクションの最初と最後の要素を取得するための便利なエイリアスもあります：&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/first&quot;&gt; &lt;code&gt;first()&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/last&quot;&gt; &lt;code&gt;last()&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f989069ff2a0fc8bbd7269050d48a2e9c89946af" translate="yes" xml:space="preserve">
          <source>There are certain common kinds of properties, that, though we can implement them manually every time we need them, would be very nice to implement once and for all, and put into a library. Examples include:</source>
          <target state="translated">ある種の一般的なプロパティがありますが、必要になるたびに手動で実装することができますが、一度に全部実装してライブラリに入れるのはとても素晴らしいことです。例えば、以下のようなものがあります。</target>
        </trans-unit>
        <trans-unit id="e9d07a2b7a0e6a37bb57f8fc3823505798a41626" translate="yes" xml:space="preserve">
          <source>There are certain rules that define write operations on maps:</source>
          <target state="translated">マップへの書き込み操作を定義する一定のルールがあります。</target>
        </trans-unit>
        <trans-unit id="2a3a36051a175f99aacc43b0a72a065674774e2a" translate="yes" xml:space="preserve">
          <source>There are couple of observations to make out of it.</source>
          <target state="translated">いくつかの観察結果があります。</target>
        </trans-unit>
        <trans-unit id="fd050ce9dc8260feb80b7e8ad7e70f3ec42e69f1" translate="yes" xml:space="preserve">
          <source>There are exactly four instances of this class, named &lt;code&gt;ContentKind.TOPIC&lt;/code&gt;, and so on. Instances of this class can be compared to each other with &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;!=&lt;/code&gt;, and you can get all the allowable values with &lt;code&gt;ContentKind.values()&lt;/code&gt;. You can also tack on more information to each instance if you need:</source>
          <target state="translated">このクラスには、 &lt;code&gt;ContentKind.TOPIC&lt;/code&gt; という名前のインスタンスが4つあります。このクラスのインスタンスは、 &lt;code&gt;==&lt;/code&gt; および &lt;code&gt;!=&lt;/code&gt; を使用して相互に比較でき、 &lt;code&gt;ContentKind.values()&lt;/code&gt; を使用してすべての許容値を取得できます。必要に応じて、各インスタンスにさらに多くの情報を追加することもできます。</target>
        </trans-unit>
        <trans-unit id="f927ac2e11471dbf3b5e6b2ee718ccfcd881bb02" translate="yes" xml:space="preserve">
          <source>There are many approaches to this problem, and in Kotlin we take a very flexible one by providing &lt;a href=&quot;https://en.wikipedia.org/wiki/Coroutine&quot;&gt;Coroutine&lt;/a&gt; support at the language level and delegating most of the functionality to libraries, much in line with Kotlin's philosophy.</source>
          <target state="translated">この問題には多くのアプローチがあり、Kotlin では、言語レベルで&lt;a href=&quot;https://en.wikipedia.org/wiki/Coroutine&quot;&gt;コルーチンの&lt;/a&gt;サポートを提供し、ほとんどの機能をライブラリに委任することで、Kotlinの理念に沿った非常に柔軟なアプローチを採用しています。</target>
        </trans-unit>
        <trans-unit id="a0366ee935c5394b522c3fe877f29b4f014a964b" translate="yes" xml:space="preserve">
          <source>There are many more platform libraries available for host and cross-compilation targets. &lt;code&gt;Kotlin/Native&lt;/code&gt; distribution provides access to &lt;code&gt;OpenGL&lt;/code&gt;, &lt;code&gt;zlib&lt;/code&gt; and other popular native libraries on applicable platforms.</source>
          <target state="translated">ホストおよびクロスコンパイルターゲットで使用できるプラットフォームライブラリは他にも多数あります。 &lt;code&gt;Kotlin/Native&lt;/code&gt; ディストリビューションは、 &lt;code&gt;OpenGL&lt;/code&gt; 、 &lt;code&gt;zlib&lt;/code&gt; 、およびその他の一般的なネイティブライブラリへのアクセスを、適切なプラットフォームで提供します。</target>
        </trans-unit>
        <trans-unit id="ef27dee02c48c1f5d014bbb6297ef36468bd6491" translate="yes" xml:space="preserve">
          <source>There are multiple ways to compile Kotlin to JavaScript. The recommended approach is to use Gradle; if desired, you can also build JavaScript projects directly from IntelliJ IDEA, use Maven, or compile the code manually from the command line. To learn more about how to compile to JavaScript please see the corresponding tutorials:</source>
          <target state="translated">KotlinをJavaScriptにコンパイルする方法は複数あります。推奨される方法はGradleを使用することです。必要であれば、IntelliJ IDEAから直接JavaScriptプロジェクトを構築したり、Mavenを使用したり、コマンドラインから手動でコードをコンパイルしたりすることもできます。JavaScriptへのコンパイル方法の詳細については、対応するチュートリアルを参照してください。</target>
        </trans-unit>
        <trans-unit id="655afcf98b929642faf68faf52cca26e671f04f6" translate="yes" xml:space="preserve">
          <source>There are no &lt;code&gt;**kwargs&lt;/code&gt; in Kotlin, but you can define optional parameters with default values, and you may choose to name some or all of the parameters when you call the function (whether they've got default values or not). A parameter with a default value must still specify its type explicitly. Like in Python, the named arguments can be reordered at will at the call site:</source>
          <target state="translated">Kotlinには &lt;code&gt;**kwargs&lt;/code&gt; はありませんが、デフォルト値を使用してオプションのパラメーターを定義できます。関数を呼び出すときに、パラメーターの一部またはすべてに名前を付けることができます（デフォルト値があるかどうかに関係なく）。デフォルト値を持つパラメータでも、そのタイプを明示的に指定する必要があります。Pythonと同様に、名前付き引数は呼び出しサイトで自由に並べ替えることができます。</target>
        </trans-unit>
        <trans-unit id="577ed2c21e3c8a21c4f57421503fea8126403589" translate="yes" xml:space="preserve">
          <source>There are no automatic conversions to boolean and thus no concept of truthy and falsy: checks for zero, empty, or null must be done explicitly with &lt;code&gt;==&lt;/code&gt; or &lt;code&gt;!=&lt;/code&gt;. Most collection types have an &lt;code&gt;isEmpty()&lt;/code&gt; and an &lt;code&gt;isNotEmpty()&lt;/code&gt; function.</source>
          <target state="translated">booleanへの自動変換はないため、真偽の概念はありません。ゼロ、空、またはnullのチェックは、 &lt;code&gt;==&lt;/code&gt; または &lt;code&gt;!=&lt;/code&gt; を使用して明示的に行う必要があります。ほとんどのコレクション型を持っている &lt;code&gt;isEmpty()&lt;/code&gt; と &lt;code&gt;isNotEmpty()&lt;/code&gt; 関数を。</target>
        </trans-unit>
        <trans-unit id="0173c0164165dfc2326b31145c73366a6b9e4caf" translate="yes" xml:space="preserve">
          <source>There are now separate versions of the standard library supporting the new JDK APIs added in Java 7 and 8. If you need access to the new APIs, use &lt;code&gt;kotlin-stdlib-jre7&lt;/code&gt; and &lt;code&gt;kotlin-stdlib-jre8&lt;/code&gt; maven artifacts instead of the standard &lt;code&gt;kotlin-stdlib&lt;/code&gt;. These artifacts are tiny extensions on top of &lt;code&gt;kotlin-stdlib&lt;/code&gt; and they bring it to your project as a transitive dependency.</source>
          <target state="translated">Java 7と8で追加された新しいJDK APIをサポートする標準ライブラリの個別のバージョンがあります。新しいAPIにアクセスする必要がある場合は、標準の &lt;code&gt;kotlin-stdlib&lt;/code&gt; 代わりに &lt;code&gt;kotlin-stdlib-jre7&lt;/code&gt; および &lt;code&gt;kotlin-stdlib-jre8&lt;/code&gt; mavenアーティファクトを使用してください。 stdlib。これらのアーティファクトは &lt;code&gt;kotlin-stdlib&lt;/code&gt; の上の小さな拡張であり、推移的な依存関係としてプロジェクトにもたらします。</target>
        </trans-unit>
        <trans-unit id="eb7a82db5fbadd7939003437756e36c07405db69" translate="yes" xml:space="preserve">
          <source>There are numerous ways that Kotlin/JS can be used. To provide you some inspiration, here's a non-exhaustive list of scenarios in which you can use Kotlin/JS.</source>
          <target state="translated">Kotlin/JSを使う方法はたくさんあります。ここでは、Kotlin/JSを使うことができるシナリオを網羅的ではありませんが紹介します。</target>
        </trans-unit>
        <trans-unit id="4f69b73bfcd710307d7869f79c049d0bc960833d" translate="yes" xml:space="preserve">
          <source>There are several ways to obtain an instance of a function type:</source>
          <target state="translated">関数型のインスタンスを取得する方法はいくつかあります。</target>
        </trans-unit>
        <trans-unit id="bfb4470f4c8ab69e441c59ca19feae2c36a172f6" translate="yes" xml:space="preserve">
          <source>There are several ways to override the default setting:</source>
          <target state="translated">デフォルトの設定を上書きする方法がいくつかあります。</target>
        </trans-unit>
        <trans-unit id="3ea08a710ccd5abee84ca77d28377d406d442756" translate="yes" xml:space="preserve">
          <source>There are some limitations:</source>
          <target state="translated">いくつかの制限があります。</target>
        </trans-unit>
        <trans-unit id="060bb5e1464bf104cc44e53612c8d8eb0e6d472c" translate="yes" xml:space="preserve">
          <source>There are target presets that one can apply using the preset functions, as shown above, for the following target platforms:</source>
          <target state="translated">上記のようにプリセット機能を利用して、以下のターゲットプラットフォームに適用できるターゲットプリセットがあります。</target>
        </trans-unit>
        <trans-unit id="7df642de78432a3520c5b5afd68e2c605c1c315a" translate="yes" xml:space="preserve">
          <source>There are the following kinds of literal constants for integral values:</source>
          <target state="translated">積分値のリテラル定数には次のような種類があります。</target>
        </trans-unit>
        <trans-unit id="f4373b7b309c5120a0c7bdb4b6efb5a4594f35b5" translate="yes" xml:space="preserve">
          <source>There are three coroutines. The main coroutine (#1) &amp;ndash; &lt;code&gt;runBlocking&lt;/code&gt; one, and two coroutines computing deferred values &lt;code&gt;a&lt;/code&gt; (#2) and &lt;code&gt;b&lt;/code&gt; (#3). They are all executing in the context of &lt;code&gt;runBlocking&lt;/code&gt; and are confined to the main thread. The output of this code is:</source>
          <target state="translated">コルーチンは3つあります。メインコルーチン（＃1）&amp;ndash; &lt;code&gt;runBlocking&lt;/code&gt; 1つと2つのコルーチンが遅延値 &lt;code&gt;a&lt;/code&gt; （＃2）と &lt;code&gt;b&lt;/code&gt; （＃3）を計算します。これらはすべて &lt;code&gt;runBlocking&lt;/code&gt; のコンテキストで実行され、メインスレッドに限定されます。このコードの出力は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="b170e6fd924b27994900ac3fea0116365dd9d5a3" translate="yes" xml:space="preserve">
          <source>There are three coroutines. The main coroutine (#1) inside &lt;code&gt;runBlocking&lt;/code&gt; and two coroutines computing the deferred values &lt;code&gt;a&lt;/code&gt; (#2) and &lt;code&gt;b&lt;/code&gt; (#3). They are all executing in the context of &lt;code&gt;runBlocking&lt;/code&gt; and are confined to the main thread. The output of this code is:</source>
          <target state="translated">3つのコルーチンがあります。 &lt;code&gt;runBlocking&lt;/code&gt; 内のメインコルーチン（＃1）と、遅延値 &lt;code&gt;a&lt;/code&gt; （＃2）および &lt;code&gt;b&lt;/code&gt; （＃3）を計算する2つのコルーチン。これらはすべて &lt;code&gt;runBlocking&lt;/code&gt; のコンテキストで実行されており、メインスレッドに限定されています。このコードの出力は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="f684c90b5c1cc2b45ec708952abe326e96395793" translate="yes" xml:space="preserve">
          <source>There are too many companies using Kotlin to list, but some more visible companies that have publicly declared usage of Kotlin, be this via blog posts, GitHub repositories or talks include &lt;a href=&quot;https://medium.com/square-corner-blog/square-open-source-loves-kotlin-c57c21710a17&quot;&gt;Square&lt;/a&gt;, &lt;a href=&quot;https://www.youtube.com/watch?v=mDpnc45WwlI&quot;&gt;Pinterest&lt;/a&gt;, &lt;a href=&quot;https://m.signalvnoise.com/how-we-made-basecamp-3s-android-app-100-kotlin-35e4e1c0ef12&quot;&gt;Basecamp&lt;/a&gt; or &lt;a href=&quot;https://docs.corda.net/releases/release-M9.2/further-notes-on-kotlin.html&quot;&gt;Corda&lt;/a&gt;.</source>
          <target state="translated">Kotlinを使用している企業が多すぎてリストアップできませんが、Kotlinの使用を公に宣言しているいくつかのより目に見える企業は、ブログ投稿、GitHubリポジトリ、または&lt;a href=&quot;https://medium.com/square-corner-blog/square-open-source-loves-kotlin-c57c21710a17&quot;&gt;Square&lt;/a&gt;、&lt;a href=&quot;https://www.youtube.com/watch?v=mDpnc45WwlI&quot;&gt;Pinterest&lt;/a&gt;、&lt;a href=&quot;https://m.signalvnoise.com/how-we-made-basecamp-3s-android-app-100-kotlin-35e4e1c0ef12&quot;&gt;Basecamp、&lt;/a&gt;または&lt;a href=&quot;https://docs.corda.net/releases/release-M9.2/further-notes-on-kotlin.html&quot;&gt;Cordaを&lt;/a&gt;含む講演です。</target>
        </trans-unit>
        <trans-unit id="26ea8b64f47f54b93f794f79bdbd7ea265251dad" translate="yes" xml:space="preserve">
          <source>There are two approaches to making computation code cancellable. The first one is to periodically invoke a suspending function that checks for cancellation. There is a &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/yield.html&quot;&gt;yield&lt;/a&gt; function that is a good choice for that purpose. The other one is to explicitly check the cancellation status. Let us try the latter approach.</source>
          <target state="translated">計算コードをキャンセル可能にする方法は2つあります。1つ目は、キャンセルをチェックする一時停止機能を定期的に呼び出すことです。その目的に適した&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/yield.html&quot;&gt;イールド&lt;/a&gt;関数があります。もう1つは、キャンセルステータスを明示的に確認することです。後者のアプローチを試してみましょう。</target>
        </trans-unit>
        <trans-unit id="cdb0e62ebdac6496d2a6cecaea4c9ddd6a113e2b" translate="yes" xml:space="preserve">
          <source>There are two functions for which the compiler gives same name in JavaScript, you can mark one with &lt;code&gt;@JsName(...)&lt;/code&gt; to prevent the compiler from reporting error.</source>
          <target state="translated">コンパイラーがJavaScriptで同じ名前を付ける関数は2つあります。 &lt;code&gt;@JsName(...)&lt;/code&gt; マークを付けて、コンパイラーがエラーを報告しないようにすることができます。</target>
        </trans-unit>
        <trans-unit id="538a207adbe54f7fe71914302d366f642c584d32" translate="yes" xml:space="preserve">
          <source>There are two possible ways to opt-in for unsigned types: with marking your API as experimental too, or without doing that.</source>
          <target state="translated">符号なし型のオプトインには、API を実験的なものとしてマークする方法と、マークしない方法があります。</target>
        </trans-unit>
        <trans-unit id="8fb334f842c55f58127659b8b13256439fde4f09" translate="yes" xml:space="preserve">
          <source>There are two possible ways to opt-in for unsigned types: with requiring an opt-in for your API, or without doing that.</source>
          <target state="translated">符号なし型のオプトインには、API にオプトインを要求する方法と、オプトインを行わない方法の 2 つの方法があります。</target>
        </trans-unit>
        <trans-unit id="86b3923915c4ddd4dd399b02f1d436b8dc853f8d" translate="yes" xml:space="preserve">
          <source>There can be different modes of stability depending of how quickly a component is evolving:</source>
          <target state="translated">コンポーネントがどのくらいの速さで進化しているかによって、異なる安定性のモードが存在することがあります。</target>
        </trans-unit>
        <trans-unit id="0b3f1a4d9ad65e8f5f359abf2fed82920c3beef2" translate="yes" xml:space="preserve">
          <source>There have been many approaches to solving this problem, including:</source>
          <target state="translated">この問題を解決するためには、以下のような様々なアプローチがありました。</target>
        </trans-unit>
        <trans-unit id="c4dc29b34f77a8368125ef8d384ca8b6bfbe8472" translate="yes" xml:space="preserve">
          <source>There is a &lt;code&gt;kotlin.root.example.Clazz&lt;/code&gt; field that represents the &lt;code&gt;Clazz&lt;/code&gt; from Kotlin. The &lt;code&gt;Clazz#memberFunction&lt;/code&gt; is accessible with the &lt;code&gt;memberFunction&lt;/code&gt; field. The only difference is that the &lt;code&gt;memberFunction&lt;/code&gt; accepts a &lt;code&gt;this&lt;/code&gt; reference as the first parameter. The C language does not support objects, and this is the reason to pass a &lt;code&gt;this&lt;/code&gt; pointer explicitly.</source>
          <target state="translated">あり &lt;code&gt;kotlin.root.example.Clazz&lt;/code&gt; の表しフィールド &lt;code&gt;Clazz&lt;/code&gt; Kotlinからは。 &lt;code&gt;Clazz#memberFunction&lt;/code&gt; はでアクセス &lt;code&gt;memberFunction&lt;/code&gt; のフィールド。唯一の違いは、 &lt;code&gt;memberFunction&lt;/code&gt; が &lt;code&gt;this&lt;/code&gt; 参照を最初のパラメーターとして受け入れることです。C言語はオブジェクトをサポートしていません。 &lt;code&gt;this&lt;/code&gt; ポインターを明示的に渡す理由です。</target>
        </trans-unit>
        <trans-unit id="725365acc046d2774e785fd58198ecf73c6aec56" translate="yes" xml:space="preserve">
          <source>There is a better solution. We can use structured concurrency in our code. Instead of launching coroutines in the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope&lt;/a&gt;, just like we usually do with threads (threads are always global), we can launch coroutines in the specific scope of the operation we are performing.</source>
          <target state="translated">より良い解決策があります。コードでは構造化された並行性を使用できます。&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope&lt;/a&gt;でコルーチンを起動する代わりに、通常スレッドで行うように（スレッドは常にグローバルです）、実行する操作の特定のスコープでコルーチンを起動できます。</target>
        </trans-unit>
        <trans-unit id="f4b1300b6ec8e15e33a7b0dfe89c4e2e11e628f0" translate="yes" xml:space="preserve">
          <source>There is a bunch of new extensions on the String class to convert it to a number without throwing an exception on invalid number: &lt;code&gt;String.toIntOrNull(): Int?&lt;/code&gt;, &lt;code&gt;String.toDoubleOrNull(): Double?&lt;/code&gt; etc.</source>
          <target state="translated">Stringクラスには、無効な数値で例外をスローせずに数値に変換する新しい拡張機能がたくさんあります &lt;code&gt;String.toIntOrNull(): Int?&lt;/code&gt; 、 &lt;code&gt;String.toDoubleOrNull(): Double?&lt;/code&gt; 等</target>
        </trans-unit>
        <trans-unit id="2d16488afd500f574acdf4a610fe81c8b613729f" translate="yes" xml:space="preserve">
          <source>There is a common misconception that making a variable &lt;code&gt;volatile&lt;/code&gt; solves concurrency problem. Let us try it:</source>
          <target state="translated">変数を &lt;code&gt;volatile&lt;/code&gt; することで並行性の問題が解決されるという一般的な誤解があります。それを試してみましょう：</target>
        </trans-unit>
        <trans-unit id="7e33e2bb2c0c45c94e894d38130281f13150c4a3" translate="yes" xml:space="preserve">
          <source>There is a constructor in the &lt;code&gt;Clazz&lt;/code&gt; field (aka &lt;code&gt;kotlin.root.example.Clazz.Clazz&lt;/code&gt;), which is the constructor function to create an instance of the &lt;code&gt;Clazz&lt;/code&gt;.</source>
          <target state="translated">で、コンストラクタはあり &lt;code&gt;Clazz&lt;/code&gt; フィールド（別名 &lt;code&gt;kotlin.root.example.Clazz.Clazz&lt;/code&gt; のインスタンスを作成するコンストラクタ関数である）、 &lt;code&gt;Clazz&lt;/code&gt; が。</target>
        </trans-unit>
        <trans-unit id="b8e6c9d338e18c01513c4cf42dbec9a1ab61f7aa" translate="yes" xml:space="preserve">
          <source>There is a convenient coroutine builder named &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/produce.html&quot;&gt;produce&lt;/a&gt; that makes it easy to do it right on producer side, and an extension function &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/consume-each.html&quot;&gt;consumeEach&lt;/a&gt;, that replaces a &lt;code&gt;for&lt;/code&gt; loop on the consumer side:</source>
          <target state="translated">プロデューサー側で簡単に実行できる、&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/produce.html&quot;&gt;プロデュース&lt;/a&gt;という便利なコルーチンビルダーと、コンシューマー側の &lt;code&gt;for&lt;/code&gt; ループを置き換える拡張関数&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/consume-each.html&quot;&gt;consumerEach&lt;/a&gt;があります。</target>
        </trans-unit>
        <trans-unit id="2dc05473a597a891dd992cdcf3cb31ec48971266" translate="yes" xml:space="preserve">
          <source>There is a laziness option to &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html&quot;&gt;async&lt;/a&gt; using an optional &lt;code&gt;start&lt;/code&gt; parameter with a value of &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-start/-l-a-z-y.html&quot;&gt;CoroutineStart.LAZY&lt;/a&gt;. It starts coroutine only when its result is needed by some &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/await.html&quot;&gt;await&lt;/a&gt; or if a &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/start.html&quot;&gt;start&lt;/a&gt; function is invoked. Run the following example:</source>
          <target state="translated">&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-start/-l-a-z-y.html&quot;&gt;CoroutineStart.LAZYの&lt;/a&gt;値を持つオプションの &lt;code&gt;start&lt;/code&gt; パラメーターを使用して&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html&quot;&gt;非同期に&lt;/a&gt;遅延オプションがあります。コルーチンを開始するのは、その結果が何らかの&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/await.html&quot;&gt;待機&lt;/a&gt;によって必要になった場合、または&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/start.html&quot;&gt;開始&lt;/a&gt;関数が呼び出された場合のみです。次の例を実行します。</target>
        </trans-unit>
        <trans-unit id="64fbf3e4d33c3845151425fcbae0bd95c1ac7ffc" translate="yes" xml:space="preserve">
          <source>There is a nice piece of syntactic sugar that lets you do this: &lt;em&gt;extension functions&lt;/em&gt; and &lt;em&gt;extension properties&lt;/em&gt;. They look like regular member functions/properties, but they are defined outside of any class - yet they reference the class name and can use &lt;code&gt;this&lt;/code&gt;. However, they can only use visible members of the class (typically just the public ones). Behind the scenes, they get compiled down to regular functions that take the target instance as a parameter.</source>
          <target state="translated">これを可能にする優れた構文糖質があります。&lt;em&gt;拡張関数&lt;/em&gt;と&lt;em&gt;拡張プロパティ&lt;/em&gt;です。それらは通常のメンバー関数/プロパティのように見えますが、クラスの外部で定義されていますが、クラス名を参照し、 &lt;code&gt;this&lt;/code&gt; を使用できます。ただし、使用できるのはクラスの可視メンバーのみです（通常はパブリックメンバーのみ）。舞台裏では、ターゲットインスタンスをパラメーターとして受け取る通常の関数にコンパイルされます。</target>
        </trans-unit>
        <trans-unit id="56a1a93e9823bbcbe462dd3f2561922740df0cc6" translate="yes" xml:space="preserve">
          <source>There is also &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.sync/with-lock.html&quot;&gt;withLock&lt;/a&gt; extension function that conveniently represents &lt;code&gt;mutex.lock(); try { ... } finally { mutex.unlock() }&lt;/code&gt; pattern:</source>
          <target state="translated">&lt;code&gt;mutex.lock(); try { ... } finally { mutex.unlock() }&lt;/code&gt; を便利に表す&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.sync/with-lock.html&quot;&gt;withLock&lt;/a&gt;拡張関数もあります。最後に{...}を試してください{mutex.unlock（）}パターン：</target>
        </trans-unit>
        <trans-unit id="5482d8805716b35d94ddb1402c557dc6720d3835" translate="yes" xml:space="preserve">
          <source>There is also a pair of functions that take a predicate and search for elements matching it:</source>
          <target state="translated">また、述語を受け取り、それにマッチする要素を検索する関数もあります。</target>
        </trans-unit>
        <trans-unit id="40c042439b9082c369e4da946808b3cddd767bd9" translate="yes" xml:space="preserve">
          <source>There is an &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/actor.html&quot;&gt;actor&lt;/a&gt; coroutine builder that conveniently combines actor's mailbox channel into its scope to receive messages from and combines the send channel into the resulting job object, so that a single reference to the actor can be carried around as its handle.</source>
          <target state="translated">アクターのメールボックスチャネルをスコープに結合してメッセージを受信し、送信チャネルを結果のジョブオブジェクトに結合する&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/actor.html&quot;&gt;アクター&lt;/a&gt;コルーチンビルダーがあります。これにより、アクターへの単一参照をハンドルとして持ち運ぶことができます。</target>
        </trans-unit>
        <trans-unit id="b44464d4de5fbd249cc21009c9fb2f52893bbcce" translate="yes" xml:space="preserve">
          <source>There is an optimization that removes redundant arrays creation in such cases, which prevents performance degradation. The single-argument form produces warnings in Kotlin 1.2 and is to be dropped in Kotlin 1.3.</source>
          <target state="translated">このような場合に冗長な配列を生成しないようにする最適化があり、パフォーマンスの低下を防ぐことができます。Kotlin 1.2では単一引数形式が警告を出していましたが、Kotlin 1.3では削除される予定です。</target>
        </trans-unit>
        <trans-unit id="6a4b4c7df274b19d3bf5dccee93fd3962d578245" translate="yes" xml:space="preserve">
          <source>There is an option to publish variants grouped by the product flavor, so that the outputs of the different build types are placed in a single module, with the build type becoming a classifier for the artifacts (the release build type is still published with no classifier). This mode is disabled by default and can be enabled as follows:</source>
          <target state="translated">製品のフレーバーによってグループ化された variant を公開するオプションがあり、異なるビルドタイプの出力を一つのモジュールにまとめ、ビルドタイプが成果物の分類器となるようにします (リリースのビルドタイプは分類器なしで公開されています)。このモードはデフォルトでは無効になっており、以下のように有効にすることができます。</target>
        </trans-unit>
        <trans-unit id="6a3b908fffabfbd0bb64797382bd07626137ec3f" translate="yes" xml:space="preserve">
          <source>There is common misconception that making a variable &lt;code&gt;volatile&lt;/code&gt; solves concurrency problem. Let us try it:</source>
          <target state="translated">変数を &lt;code&gt;volatile&lt;/code&gt; することで並行性の問題が解決されるという一般的な誤解があります。試してみましょう：</target>
        </trans-unit>
        <trans-unit id="5eb09ee69535cf6dda53683554e0ee16259161ba" translate="yes" xml:space="preserve">
          <source>There is no dedicated type in C language for strings. A developer knows from a method signature or the documentation, whether a given &lt;code&gt;char *&lt;/code&gt; means a C string in the context. Strings in the C language are null-terminated, a trailing zero character &lt;code&gt;\0&lt;/code&gt; is added at the end of a bytes sequence to mark a string termination. Usually, &lt;a href=&quot;https://en.wikipedia.org/wiki/UTF-8&quot;&gt;UTF-8 encoded strings&lt;/a&gt; are used. The UTF-8 encoding uses variable width characters, and it is backward compatible with &lt;a href=&quot;https://en.wikipedia.org/wiki/ASCII&quot;&gt;ASCII&lt;/a&gt;. Kotlin/Native uses UTF-8 character encoding by default.</source>
          <target state="translated">C言語には文字列専用の型はありません。開発者は、メソッドのシグネチャまたはドキュメントから、与えられた &lt;code&gt;char *&lt;/code&gt; がコンテキスト内のC文字列を意味するかどうかを知っています。 C言語の文字列はnullで終了します。文字列の終了を示すために、バイトシーケンスの最後に末尾のゼロ文字 &lt;code&gt;\0&lt;/code&gt; が追加されます。通常、&lt;a href=&quot;https://en.wikipedia.org/wiki/UTF-8&quot;&gt;UTF-8エンコードされた文字列&lt;/a&gt;が使用されます。 UTF-8エンコーディングは可変幅文字を使用し、&lt;a href=&quot;https://en.wikipedia.org/wiki/ASCII&quot;&gt;ASCII&lt;/a&gt;との下位互換性があります。 Kotlin / NativeはデフォルトでUTF-8文字エンコーディングを使用します。</target>
        </trans-unit>
        <trans-unit id="50408f344ff56fd13407ed98b66fe0baaa2ef0c5" translate="yes" xml:space="preserve">
          <source>There is no longer an exception when running this code:</source>
          <target state="translated">このコードを実行しても例外が発生しなくなりました。</target>
        </trans-unit>
        <trans-unit id="edef4e6315a2b596a0ca3836f2b3be1feee84974" translate="yes" xml:space="preserve">
          <source>There is no meaning attached to values in this class, it can be used for any purpose. Pair exhibits value semantics, i.e. two pairs are equal if both components are equal.</source>
          <target state="translated">このクラスでは値には何の意味もありません。ペアは値のセマンティクスを示します。</target>
        </trans-unit>
        <trans-unit id="0049a565ebb0e6780625b95d2507e4c5901c80a7" translate="yes" xml:space="preserve">
          <source>There is no meaning attached to values in this class, it can be used for any purpose. Triple exhibits value semantics, i.e. two triples are equal if all three components are equal. An example of decomposing it into values:</source>
          <target state="translated">このクラスでは値には何の意味もありませんので、どのような目的にも使用できます。Tripleは値のセマンティクスを示します。つまり、3つの構成要素がすべて等しい場合、2つのTripleは等しいということです。値に分解した例。</target>
        </trans-unit>
        <trans-unit id="1dd7b0fcce3d3026dd4903ea1dcae2ace7aba63b" translate="yes" xml:space="preserve">
          <source>There is no namespaces support in C, so the Kotlin/Native compiler generates long names to avoid any possible clashes with other symbols in the existing native project.</source>
          <target state="translated">C言語には名前空間のサポートがないため、Kotlin/Nativeコンパイラは既存のネイティブプロジェクトの他のシンボルとの衝突を避けるために長い名前を生成します。</target>
        </trans-unit>
        <trans-unit id="9fc7acf9c721c77f449446dbc8b3636586ef2efc" translate="yes" xml:space="preserve">
          <source>There is no need to consider compatibility for new interfaces, as no clients have used them before. You can minimize the compatibility overhead by excluding these interfaces from the compatibility mode. To do this, annotate them with the &lt;code&gt;@JvmDefaultWithoutCompatibility&lt;/code&gt; annotation. Such interfaces compile the same way as with &lt;code&gt;-Xjvm-default=all&lt;/code&gt;.</source>
          <target state="translated">これまでクライアントが使用したことがないため、新しいインターフェイスの互換性を考慮する必要はありません。これらのインターフェイスを互換モードから除外することで、互換性のオーバーヘッドを最小限に抑えることができます。これを行うには、 &lt;code&gt;@JvmDefaultWithoutCompatibility&lt;/code&gt; アノテーションを付けます。このようなインターフェースは、 &lt;code&gt;-Xjvm-default=all&lt;/code&gt; の場合と同じ方法でコンパイルされます。</target>
        </trans-unit>
        <trans-unit id="8859e68bee06f71aa7ff22831dc050e526d2f13b" translate="yes" xml:space="preserve">
          <source>There is no need to handle the case of misformatted input in competitive programming. In competitive programming, an input format is always precisely specified and the actual input cannot deviate from the input specification in the problem statement. That's what the null-assertion operator &lt;code&gt;!!&lt;/code&gt; essentially does &amp;mdash; it asserts that the input string is present and throws an exception otherwise. Likewise, the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.text/to-int&quot;&gt;String.toInt()&lt;/a&gt; function throws an exception if the input string is not an integer.</source>
          <target state="translated">競合プログラミングでは、入力のフォーマットが誤っている場合に対処する必要はありません。競合プログラミングでは、入力形式は常に正確に指定されており、実際の入力は問題ステートメントの入力仕様から逸脱することはできません。それがnullアサーション演算子です &lt;code&gt;!!&lt;/code&gt; 基本的にそうです&amp;mdash;入力文字列が存在することを表明し、そうでなければ例外をスローします。同様に、入力文字列が整数でない場合、&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.text/to-int&quot;&gt;String.toInt（）&lt;/a&gt;関数は例外をスローします。</target>
        </trans-unit>
        <trans-unit id="c6d0ebaf0b7e6376420eb9484810949b156e1e12" translate="yes" xml:space="preserve">
          <source>There is no such syntax in Kotlin. However, in Kotlin we have &lt;a href=&quot;object-declarations#companion-objects&quot;&gt;&lt;code&gt;companion&lt;/code&gt;&lt;/a&gt; objects. Kotlin treats companion objects of &lt;code&gt;external&lt;/code&gt; classes in a special way: instead of expecting an object, it assumes members of companion objects to be members of the class itself. &lt;code&gt;MyClass&lt;/code&gt; from the example above can be described as follows:</source>
          <target state="translated">Kotlinにはそのような構文はありません。ただし、Kotlinには&lt;a href=&quot;object-declarations#companion-objects&quot;&gt; &lt;code&gt;companion&lt;/code&gt; &lt;/a&gt;オブジェクトがあります。Kotlinは、 &lt;code&gt;external&lt;/code&gt; クラスのコンパニオンオブジェクトを特別な方法で扱います。オブジェクトを期待する代わりに、コンパニオンオブジェクトのメンバーをクラス自体のメンバーと見なします。上記の例の &lt;code&gt;MyClass&lt;/code&gt; は、次のように説明できます。</target>
        </trans-unit>
        <trans-unit id="e914e64115449100ebfd64599edfd2968cff02a7" translate="yes" xml:space="preserve">
          <source>There is now a large number of &lt;a href=&quot;building-mpp-with-gradle#supported-platforms&quot;&gt;preset platform configurations&lt;/a&gt; for different supported platforms.</source>
          <target state="translated">現在、サポートされているさまざまなプラットフォーム用に多数の&lt;a href=&quot;building-mpp-with-gradle#supported-platforms&quot;&gt;事前設定されたプラットフォーム構成&lt;/a&gt;があります。</target>
        </trans-unit>
        <trans-unit id="5c9261e9c8424c9800b6b0327e8368a8f20c36c1" translate="yes" xml:space="preserve">
          <source>There is now a large number of &lt;a href=&quot;mpp-supported-platforms&quot;&gt;preset platform configurations&lt;/a&gt; for different supported platforms.</source>
          <target state="translated">現在、サポートされているさまざまなプラットフォーム用に多数の&lt;a href=&quot;mpp-supported-platforms&quot;&gt;プリセットプラットフォーム構成&lt;/a&gt;があります。</target>
        </trans-unit>
        <trans-unit id="9b648b3a77b4b2e5fa4527e728e2d5fe0ae2a410" translate="yes" xml:space="preserve">
          <source>There is one important semantic difference between object expressions and object declarations:</source>
          <target state="translated">オブジェクト表現とオブジェクト宣言の間には、1つの重要な意味的な違いがあります。</target>
        </trans-unit>
        <trans-unit id="8fd6b73de53838cea1717936197f551e12e9d247" translate="yes" xml:space="preserve">
          <source>There is one more way to search elements in lists &amp;ndash; &lt;a href=&quot;https://en.wikipedia.org/wiki/Binary_search_algorithm&quot;&gt;binary search&lt;/a&gt;. It works significantly faster than other built-in search functions but &lt;em&gt;requires the list to be &lt;a href=&quot;collection-ordering&quot;&gt;sorted&lt;/a&gt;&lt;/em&gt; in ascending order according to a certain ordering: natural or another one provided in the function parameter. Otherwise, the result is undefined.</source>
          <target state="translated">リスト内の要素を検索する方法がもう1つあり&lt;a href=&quot;https://en.wikipedia.org/wiki/Binary_search_algorithm&quot;&gt;ます&lt;/a&gt;。バイナリ検索です。他の組み込み検索関数よりも大幅に高速に動作しますが&lt;em&gt;、リストを&lt;a href=&quot;collection-ordering&quot;&gt;&lt;/a&gt;&lt;/em&gt;特定の順序（自然または関数パラメーターで提供される別の順序）に従って昇順&lt;em&gt;で&lt;/em&gt;&lt;em&gt;ソート&lt;/em&gt;&lt;em&gt;する必要&lt;/em&gt;が&lt;em&gt;あり&lt;/em&gt;ます。それ以外の場合、結果は未定義です。</target>
        </trans-unit>
        <trans-unit id="c4497244354ad07743aea06bad3f15a18c72b5c2" translate="yes" xml:space="preserve">
          <source>There is still something to be desired for practical usage of coroutines. When we use &lt;code&gt;GlobalScope.launch&lt;/code&gt;, we create a top-level coroutine. Even though it is light-weight, it still consumes some memory resources while it runs. If we forget to keep a reference to the newly launched coroutine it still runs. What if the code in the coroutine hangs (for example, we erroneously delay for too long), what if we launched too many coroutines and ran out of memory? Having to manually keep references to all the launched coroutines and &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/join.html&quot;&gt;join&lt;/a&gt; them is error-prone.</source>
          <target state="translated">コルーチンの実際の使用に望まれることがまだあります。 &lt;code&gt;GlobalScope.launch&lt;/code&gt; を使用すると、トップレベルのコルーチンが作成されます。軽量ですが、実行中にメモリリソースを消費します。新しく起動したコルーチンへの参照を保持し忘れても、まだ実行されます。コルーチンのコードがハングした場合（たとえば、誤って遅延が長すぎるなど）、コルーチンを起動しすぎてメモリ不足になった場合はどうなりますか？起動されたすべてのコルーチンへの参照を手動で保持し、それらを&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/join.html&quot;&gt;結合する&lt;/a&gt;必要があると、エラーが発生しやすくなります。</target>
        </trans-unit>
        <trans-unit id="c2958b4b7d6ee3fe23d0044dbf293010b99dd8e5" translate="yes" xml:space="preserve">
          <source>There is still something to be desired for practical usage of coroutines. When we use &lt;code&gt;GlobalScope.launch&lt;/code&gt;, we create a top-level coroutine. Even though it is light-weight, it still consumes some memory resources while it runs. If we forget to keep a reference to the newly launched coroutine, it still runs. What if the code in the coroutine hangs (for example, we erroneously delay for too long), what if we launched too many coroutines and ran out of memory? Having to manually keep references to all the launched coroutines and &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/join.html&quot;&gt;join&lt;/a&gt; them is error-prone.</source>
          <target state="translated">コルーチンの実用化にはまだまだ何かが望まれています。 &lt;code&gt;GlobalScope.launch&lt;/code&gt; を使用すると、トップレベルのコルーチンが作成されます。軽量ですが、実行中にメモリリソースを消費します。新しく起動されたコルーチンへの参照を保持するのを忘れた場合でも、実行されます。コルーチンのコードがハングした場合（たとえば、誤って長時間遅延した場合）、起動したコルーチンが多すぎてメモリが不足した場合はどうなりますか？起動されたすべてのコルーチンへの参照を手動で保持して&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/join.html&quot;&gt;結合する&lt;/a&gt;必要があると、エラーが発生しやすくなります。</target>
        </trans-unit>
        <trans-unit id="01079d64cb67e3f5b3eb1ab0a3228010e68dcdd0" translate="yes" xml:space="preserve">
          <source>There may be times when you need to quickly write and execute code outside of a project or application. This may be useful, for example, when learning Kotlin or evaluating expressions. Let's have a look at three handy ways we can use to run Kotlin code quickly:</source>
          <target state="translated">プロジェクトやアプリケーションの外で素早くコードを書いて実行する必要がある場合があるかもしれません。例えば、Kotlin を学ぶときや式を評価するときなどに便利です。ここでは、Kotlinのコードを素早く実行するための3つの便利な方法を見てみましょう。</target>
        </trans-unit>
        <trans-unit id="98631247ce5d35bfa57c2de9453651ac4adc252b" translate="yes" xml:space="preserve">
          <source>There may be zero or more &lt;em&gt;catch&lt;/em&gt; blocks. &lt;em&gt;finally&lt;/em&gt; block may be omitted. However at least one &lt;em&gt;catch&lt;/em&gt; or &lt;em&gt;finally&lt;/em&gt; block should be present.</source>
          <target state="translated">0個以上の&lt;em&gt;catch&lt;/em&gt;ブロックが存在する可能性があります。&lt;em&gt;最後に&lt;/em&gt;ブロックを省略できます。ただし、少なくとも1つの&lt;em&gt;キャッチ&lt;/em&gt;または&lt;em&gt;最終&lt;/em&gt;ブロックが存在する必要があります。</target>
        </trans-unit>
        <trans-unit id="f116d6d19440fd947335171cc03cdab27f6adc4e" translate="yes" xml:space="preserve">
          <source>There will be a property named &lt;code&gt;hello&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;hello&lt;/code&gt; という名前のプロパティがあります。</target>
        </trans-unit>
        <trans-unit id="def4b70b1b61bdf7178a471139f991f3029fb44c" translate="yes" xml:space="preserve">
          <source>There will only ever be one instance of this class, and the instance (which is created the first time it is accessed, in a thread-safe manner) has got the same name as the class:</source>
          <target state="translated">このクラスのインスタンスは1つしか存在せず、そのインスタンスは (最初にアクセスされたときにスレッドセーフな方法で作成されます)クラスと同じ名前を持っています。</target>
        </trans-unit>
        <trans-unit id="6f9f7587a2e090ad5e29fbff32347947646d8531" translate="yes" xml:space="preserve">
          <source>There's a little bit of runtime overhead associated with lambda functions: they are really objects, so they must be instantiated, and (like other functions) calling them takes a little bit of time too. If we use the &lt;code&gt;inline&lt;/code&gt; keyword on a function, we tell the compiler to &lt;em&gt;inline&lt;/em&gt; both the function and its lambda parameters (if any) - that is, the compiler will copy the code of the function (and its lambda parameters) into &lt;em&gt;every&lt;/em&gt; callsite, thus eliminating the overhead of both the lambda instantiation and the calling of the function and the lambdas. This will happen unconditionally, unlike in C and C++, where &lt;code&gt;inline&lt;/code&gt; is more of a hint to the compiler. This will cause the size of the compiled code to grow, but it may be worth it for certain small but frequently-called functions.</source>
          <target state="translated">ラムダ関数に関連する実行時のオーバーヘッドは少しあります。これらは実際にはオブジェクトであるため、インスタンス化する必要があり、（他の関数と同様に）関数の呼び出しにも少し時間がかかります。関数で &lt;code&gt;inline&lt;/code&gt; キーワードを使用する場合、関数とそのラムダパラメーター（存在する場合）の両方を&lt;em&gt;インライン展開&lt;/em&gt;するようにコンパイラーに指示します。つまり、コンパイラーは関数のコード（およびそのラムダパラメーター）を&lt;em&gt;すべての&lt;/em&gt;呼び出しサイトにコピーします。したがって、ラムダのインスタンス化と、関数とラムダの呼び出しの両方のオーバーヘッドがなくなります。これは、CおよびC ++とは異なり、無条件に発生し &lt;code&gt;inline&lt;/code&gt; コンパイラへのヒントです。これにより、コンパイルされたコードのサイズが大きくなりますが、特定の小さいが頻繁に呼び出される関数にとっては価値がある場合があります。</target>
        </trans-unit>
        <trans-unit id="1db5770d8b83e30706aed362d9428bb0d8466fab" translate="yes" xml:space="preserve">
          <source>There's a vast collection of functional programming-style operations available in the &lt;a href=&quot;../../../api/latest/jvm/stdlib/kotlin.collections/index&quot;&gt;&lt;code&gt;kotlin.collections&lt;/code&gt; package&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../../api/latest/jvm/stdlib/kotlin.collections/index&quot;&gt; &lt;code&gt;kotlin.collections&lt;/code&gt; パッケージに&lt;/a&gt;は、関数型プログラミングスタイルの操作の膨大なコレクションがあります。</target>
        </trans-unit>
        <trans-unit id="202786b020b9056a1534a505736791f80248ba7e" translate="yes" xml:space="preserve">
          <source>There's no 64 bit integer number in JavaScript, so &lt;code&gt;kotlin.Long&lt;/code&gt; is not mapped to any JavaScript object, it's emulated by a Kotlin class.</source>
          <target state="translated">JavaScriptには64ビット整数がないため、 &lt;code&gt;kotlin.Long&lt;/code&gt; はJavaScriptオブジェクトにマップされず、Kotlinクラスによってエミュレートされます。</target>
        </trans-unit>
        <trans-unit id="9178e1d163a2f07f63e80e90e8b72e40666cb6be" translate="yes" xml:space="preserve">
          <source>There's no such syntax in Kotlin. However, in Kotlin we have &lt;code&gt;companion&lt;/code&gt; objects. Kotlin treats companion objects of &lt;code&gt;external&lt;/code&gt; class in a special way: instead of expecting an object, it assumes members of companion objects to be members of the class itself. To describe &lt;code&gt;MyClass&lt;/code&gt; from the example above, you can write:</source>
          <target state="translated">Kotlinにはそのような構文はありません。ただし、Kotlinには &lt;code&gt;companion&lt;/code&gt; オブジェクトがあります。Kotlinは &lt;code&gt;external&lt;/code&gt; クラスのコンパニオンオブジェクトを特別な方法で扱います。オブジェクトを期待する代わりに、コンパニオンオブジェクトのメンバーがクラス自体のメンバーであると想定します。上記の例から &lt;code&gt;MyClass&lt;/code&gt; を説明するには、次のように記述します。</target>
        </trans-unit>
        <trans-unit id="918d499d192390404b8163b61ae9ad18a046a4a8" translate="yes" xml:space="preserve">
          <source>There's two forms of using &lt;code&gt;definedExternally&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;definedExternally&lt;/code&gt; の使用には2つの形式があります。</target>
        </trans-unit>
        <trans-unit id="1d27760789bc7d15f7cae3944fffbd1ed1e60b2e" translate="yes" xml:space="preserve">
          <source>Therefore if the &lt;a href=&quot;write#kotlin.concurrent%24write%28java.util.concurrent.locks.ReentrantReadWriteLock%2C+kotlin.Function0%28%28kotlin.concurrent.write.T%29%29%29%2Faction&quot;&gt;action&lt;/a&gt; inside write lock has been initiated by checking some condition, the condition must be rechecked inside the &lt;a href=&quot;write#kotlin.concurrent%24write%28java.util.concurrent.locks.ReentrantReadWriteLock%2C+kotlin.Function0%28%28kotlin.concurrent.write.T%29%29%29%2Faction&quot;&gt;action&lt;/a&gt; to avoid possible races.</source>
          <target state="translated">したがって、書き込みロック内の&lt;a href=&quot;write#kotlin.concurrent%24write%28java.util.concurrent.locks.ReentrantReadWriteLock%2C+kotlin.Function0%28%28kotlin.concurrent.write.T%29%29%29%2Faction&quot;&gt;アクション&lt;/a&gt;が何らかの条件をチェックすることによって開始された場合、起こり得る競合を避けるために、&lt;a href=&quot;write#kotlin.concurrent%24write%28java.util.concurrent.locks.ReentrantReadWriteLock%2C+kotlin.Function0%28%28kotlin.concurrent.write.T%29%29%29%2Faction&quot;&gt;アクション&lt;/a&gt;内で条件を再チェックする必要があります。</target>
        </trans-unit>
        <trans-unit id="e58964a321357f25142def10569f3d0cf1f1691d" translate="yes" xml:space="preserve">
          <source>Therefore if the &lt;a href=&quot;write#kotlin.concurrent%24write(java.util.concurrent.locks.ReentrantReadWriteLock,%20kotlin.Function0((kotlin.concurrent.write.T)))/action&quot;&gt;action&lt;/a&gt; inside write lock has been initiated by checking some condition, the condition must be rechecked inside the &lt;a href=&quot;write#kotlin.concurrent%24write(java.util.concurrent.locks.ReentrantReadWriteLock,%20kotlin.Function0((kotlin.concurrent.write.T)))/action&quot;&gt;action&lt;/a&gt; to avoid possible races.</source>
          <target state="translated">したがって、書き込みロック内の&lt;a href=&quot;write#kotlin.concurrent%24write(java.util.concurrent.locks.ReentrantReadWriteLock,%20kotlin.Function0((kotlin.concurrent.write.T)))/action&quot;&gt;アクション&lt;/a&gt;が何らかの条件をチェックすることによって開始された場合、競合の可能性を回避するために、&lt;a href=&quot;write#kotlin.concurrent%24write(java.util.concurrent.locks.ReentrantReadWriteLock,%20kotlin.Function0((kotlin.concurrent.write.T)))/action&quot;&gt;アクション&lt;/a&gt;内で条件を再チェックする必要があります。</target>
        </trans-unit>
        <trans-unit id="0f17bb5adc41c5c7eefa8d167c2c05552954588a" translate="yes" xml:space="preserve">
          <source>Therefore, the two following snippets are equivalent:</source>
          <target state="translated">したがって、以下の2つのスニペットは等価です。</target>
        </trans-unit>
        <trans-unit id="b2fcfe97b28b6d55545bf13f39eacf58d2cbb997" translate="yes" xml:space="preserve">
          <source>Therefore, there is no general way to check whether an instance of a generic type was created with certain type arguments at runtime, and the compiler &lt;a href=&quot;typecasts#type-erasure-and-generic-type-checks&quot;&gt;prohibits such &lt;em&gt;is&lt;/em&gt;-checks&lt;/a&gt;.</source>
          <target state="translated">したがって、そこにジェネリック型のインスタンスは、実行時に特定の型の引数を使用して作成されたかどうかをチェックするという一般的な方法はありません、コンパイラは&lt;a href=&quot;typecasts#type-erasure-and-generic-type-checks&quot;&gt;そのようなものが禁止&lt;em&gt;され&lt;/em&gt; -checks&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ba4578c0908f499a877e6e75a3e1e8fb6ca14fec" translate="yes" xml:space="preserve">
          <source>These &lt;a href=&quot;typecasts#unchecked-casts&quot;&gt;unchecked casts&lt;/a&gt; can be used when type safety is implied by the high-level program logic but cannot be inferred directly by the compiler. The compiler issues a warning on unchecked casts, and at runtime, only the non-generic part is checked (equivalent to &lt;code&gt;foo as List&amp;lt;*&amp;gt;&lt;/code&gt;).</source>
          <target state="translated">これらの&lt;a href=&quot;typecasts#unchecked-casts&quot;&gt;未チェックのキャスト&lt;/a&gt;は、型の安全性が高レベルのプログラムロジックによって暗示されているが、コンパイラーによって直接推論できない場合に使用できます。コンパイラーは、チェックされていないキャストに対して警告を発行し、実行時に非ジェネリックな部分のみがチェックされます（ &lt;code&gt;foo as List&amp;lt;*&amp;gt;&lt;/code&gt; 同等）。</target>
        </trans-unit>
        <trans-unit id="dd3d3ea77431105543bdd1015eeb929086add1c8" translate="yes" xml:space="preserve">
          <source>These abstract classes can be used as base classes when implementing Kotlin collection classes. For implementing read-only collections there are &lt;code&gt;AbstractCollection&lt;/code&gt;, &lt;code&gt;AbstractList&lt;/code&gt;, &lt;code&gt;AbstractSet&lt;/code&gt; and &lt;code&gt;AbstractMap&lt;/code&gt;, and for mutable collections there are &lt;code&gt;AbstractMutableCollection&lt;/code&gt;, &lt;code&gt;AbstractMutableList&lt;/code&gt;, &lt;code&gt;AbstractMutableSet&lt;/code&gt; and &lt;code&gt;AbstractMutableMap&lt;/code&gt;. On JVM these abstract mutable collections inherit most of their functionality from JDK's abstract collections.</source>
          <target state="translated">これらの抽象クラスは、Kotlinコレクションクラスを実装するときに基本クラスとして使用できます。読み取り専用のコレクションを実装するために存在し &lt;code&gt;AbstractCollection&lt;/code&gt; 、 &lt;code&gt;AbstractList&lt;/code&gt; 、 &lt;code&gt;AbstractSet&lt;/code&gt; と &lt;code&gt;AbstractMap&lt;/code&gt; の、そして可変コレクションのためにそこにある &lt;code&gt;AbstractMutableCollection&lt;/code&gt; 、 &lt;code&gt;AbstractMutableList&lt;/code&gt; 、 &lt;code&gt;AbstractMutableSet&lt;/code&gt; と &lt;code&gt;AbstractMutableMap&lt;/code&gt; が。 JVMでは、これらの抽象可変コレクションは、JDKの抽象コレクションからほとんどの機能を継承します。</target>
        </trans-unit>
        <trans-unit id="aae55c4083a74f1ac27e26d5124083a7a6b3b4cb" translate="yes" xml:space="preserve">
          <source>These are the &lt;a href=&quot;#default-project-layout&quot;&gt;default source set names&lt;/a&gt; for the production and test sources for the targets configured above. The source sets &lt;code&gt;commonMain&lt;/code&gt; and &lt;code&gt;commonTest&lt;/code&gt; are included into production and test compilations, respectively, of all targets. Note that the dependencies for common source sets &lt;code&gt;commonMain&lt;/code&gt; and &lt;code&gt;commonTest&lt;/code&gt; are the common artifacts, and the platform libraries go to the source sets of the specific targets.</source>
          <target state="translated">これらは、上記で構成されたターゲットの本番およびテストソースの&lt;a href=&quot;#default-project-layout&quot;&gt;デフォルトのソースセット名&lt;/a&gt;です。ソースセット &lt;code&gt;commonMain&lt;/code&gt; および &lt;code&gt;commonTest&lt;/code&gt; は、すべてのターゲットの本番コンパイルおよびテストコンパイルにそれぞれ含まれます。共通ソースセット &lt;code&gt;commonMain&lt;/code&gt; および &lt;code&gt;commonTest&lt;/code&gt; の依存関係は共通のアーティファクトであり、プラットフォームライブラリは特定のターゲットのソースセットに移動することに注意してください。</target>
        </trans-unit>
        <trans-unit id="6c67dd2d501b6f7860e7b47d523d2ae61bab43e4" translate="yes" xml:space="preserve">
          <source>These are three general-purpose extension functions applicable to any receiver.</source>
          <target state="translated">これらは、どのような受信機にも適用可能な3つの汎用拡張機能です。</target>
        </trans-unit>
        <trans-unit id="4a99a063b2c797ffc59fde5538599b9e6760c083" translate="yes" xml:space="preserve">
          <source>These considerations lead to the following rules. A covariant type parameter &lt;code&gt;T&lt;/code&gt; (which the user of an object might think is &lt;code&gt;Fruit&lt;/code&gt;, while the object in reality is tied to &lt;code&gt;Apple&lt;/code&gt;) may be used as:</source>
          <target state="translated">これらの考慮事項は、次のルールにつながります。共変タイプのパラメーター &lt;code&gt;T&lt;/code&gt; （オブジェクトのユーザーは &lt;code&gt;Fruit&lt;/code&gt; と考えるかもしれませんが、実際にはオブジェクトは &lt;code&gt;Apple&lt;/code&gt; に関連付けられています）は次のように使用できます。</target>
        </trans-unit>
        <trans-unit id="e8a12f370f83960d4f7413fab1b904c1e1f23ab2" translate="yes" xml:space="preserve">
          <source>These declarations look clear. All &lt;code&gt;char *&lt;/code&gt; pointers are turned into &lt;code&gt;str: CValuesRef&amp;lt;ByteVar&amp;gt;?&lt;/code&gt; for parameters and to &lt;code&gt;CPointer&amp;lt;ByteVar&amp;gt;?&lt;/code&gt; in return types. Kotlin turns &lt;code&gt;char&lt;/code&gt; type into &lt;code&gt;kotlin.Byte&lt;/code&gt; type, as it is usually an 8-bit signed value.</source>
          <target state="translated">これらの宣言は明確に見えます。すべての &lt;code&gt;char *&lt;/code&gt; ポインタは &lt;code&gt;str: CValuesRef&amp;lt;ByteVar&amp;gt;?&lt;/code&gt; に変換されます：CValuesRef &amp;lt;ByteVar&amp;gt;？パラメータと &lt;code&gt;CPointer&amp;lt;ByteVar&amp;gt;?&lt;/code&gt; 戻り型。Kotlinは &lt;code&gt;char&lt;/code&gt; 型を &lt;code&gt;kotlin.Byte&lt;/code&gt; 型に変換します。これは通常、8ビットの符号付き値であるためです。</target>
        </trans-unit>
        <trans-unit id="53e4257de1ac9420719572d5eaf311fafd22b5c2" translate="yes" xml:space="preserve">
          <source>These features are not considered production ready yet, so you need to turn on the &lt;em&gt;experimental mode&lt;/em&gt; in &lt;code&gt;build.gradle&lt;/code&gt; in order to use them:</source>
          <target state="translated">これらの機能はまだプロダクション対応とは見なされていないため、使用するには &lt;code&gt;build.gradle&lt;/code&gt; で&lt;em&gt;試験&lt;/em&gt;運用&lt;em&gt;モード&lt;/em&gt;をオンにする必要があります。</target>
        </trans-unit>
        <trans-unit id="e6b05d8f5b89932c0c2ddc8328889d3567a05266" translate="yes" xml:space="preserve">
          <source>These functions can also be used for converting collections to other types, for example, build a set from a list or vice versa.</source>
          <target state="translated">これらの関数は、コレクションを他の型に変換するためにも使用できます。</target>
        </trans-unit>
        <trans-unit id="d5e9c8cae28543e16ef49eb2054cfc4937ef3fcf" translate="yes" xml:space="preserve">
          <source>These functions can be used for easy copying of maps:</source>
          <target state="translated">これらの機能を利用して、地図を簡単にコピーすることができます。</target>
        </trans-unit>
        <trans-unit id="2a7f12885b59bbc14ccabadd6389a34cf6ff8eb2" translate="yes" xml:space="preserve">
          <source>These functions can be used to find the lowest and greatest of two or three given values, where values are primitive numbers or &lt;code&gt;Comparable&lt;/code&gt; objects. There is also an overload of each function that take an additional &lt;code&gt;Comparator&lt;/code&gt; instance, if you want to compare objects that are not comparable themselves.</source>
          <target state="translated">これらの関数を使用して、2つまたは3つの指定された値の最小値と最大値を見つけることができます。値はプリミティブ数または &lt;code&gt;Comparable&lt;/code&gt; オブジェクトです。比較できないオブジェクトを比較する場合は、追加の &lt;code&gt;Comparator&lt;/code&gt; インスタンスを取得する各関数のオーバーロードもあります。</target>
        </trans-unit>
        <trans-unit id="8f7f5c9e85694705edbe3da3b621cafe8f2795f3" translate="yes" xml:space="preserve">
          <source>These functions deal with Kotlin/Native objects. Call the &lt;code&gt;DisposeStablePointer&lt;/code&gt; to release a Kotlin object and &lt;code&gt;DisposeString&lt;/code&gt; to release a Kotlin String, which has the &lt;code&gt;char*&lt;/code&gt; type in C. It is possible to use the &lt;code&gt;IsInstance&lt;/code&gt; function to check if a Kotlin type or a &lt;code&gt;libnative_KNativePtr&lt;/code&gt; is an instance of another type. The actual set of operations generated depends on the actual usages.</source>
          <target state="translated">これらの関数はKotlin / Nativeオブジェクトを扱います。コール &lt;code&gt;DisposeStablePointer&lt;/code&gt; Kotlinオブジェクトおよび解放する &lt;code&gt;DisposeString&lt;/code&gt; がありKotlin文字列、解放するために &lt;code&gt;char*&lt;/code&gt; を使用することが可能であるC.タイプ &lt;code&gt;IsInstance&lt;/code&gt; Kotlinタイプまたはかどうかをチェックする機能を &lt;code&gt;libnative_KNativePtr&lt;/code&gt; が、別の型のインスタンスです。生成される実際の操作セットは、実際の使用方法によって異なります。</target>
        </trans-unit>
        <trans-unit id="ebcfd0ed6c7e90830065d9ee1e014161378d5e50" translate="yes" xml:space="preserve">
          <source>These include &lt;a href=&quot;reflection#bound-function-and-property-references-since-11&quot;&gt;bound callable references&lt;/a&gt; that point to a member of a particular instance: &lt;code&gt;foo::toString&lt;/code&gt;.</source>
          <target state="translated">これらには、特定のインスタンス &lt;code&gt;foo::toString&lt;/code&gt; メンバーを指す&lt;a href=&quot;reflection#bound-function-and-property-references-since-11&quot;&gt;バインドされた呼び出し可能な参照&lt;/a&gt;が含まれます。</target>
        </trans-unit>
        <trans-unit id="341a2ef673574a4668acee83662de92778d835b1" translate="yes" xml:space="preserve">
          <source>These operators only work with the function &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-any/equals&quot;&gt;&lt;code&gt;equals(other: Any?): Boolean&lt;/code&gt;&lt;/a&gt;, which can be overridden to provide custom equality check implementation. Any other function with the same name (like &lt;code&gt;equals(other: Foo)&lt;/code&gt;) will not be called.</source>
          <target state="translated">これらの演算子は、関数&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-any/equals&quot;&gt; &lt;code&gt;equals(other: Any?): Boolean&lt;/code&gt; &lt;/a&gt;でのみ機能します。これをオーバーライドして、カスタムの等価チェック実装を提供できます。同じ名前の他の関数（ &lt;code&gt;equals(other: Foo)&lt;/code&gt; ）は呼び出されません。</target>
        </trans-unit>
        <trans-unit id="04c64c9fdc4ddbb026d14664db7dfcf575773eab" translate="yes" xml:space="preserve">
          <source>These options have nearly the same effect as clang's &lt;code&gt;-fembed-bitcode&lt;/code&gt;/&lt;code&gt;-fembed-bitcode-marker&lt;/code&gt; and swiftc's &lt;code&gt;-embed-bitcode&lt;/code&gt;/&lt;code&gt;-embed-bitcode-marker&lt;/code&gt;.</source>
          <target state="translated">これらのオプションは、clangの &lt;code&gt;-fembed-bitcode&lt;/code&gt; / &lt;code&gt;-fembed-bitcode-marker&lt;/code&gt; およびswiftcの &lt;code&gt;-embed-bitcode&lt;/code&gt; / &lt;code&gt;-embed-bitcode-marker&lt;/code&gt; とほぼ同じ効果があります。</target>
        </trans-unit>
        <trans-unit id="42a0b78cb4e25be9e1f6ef7cf3d39eb3e781050e" translate="yes" xml:space="preserve">
          <source>These tasks are defined in the &lt;em&gt;kotlin-ant.jar&lt;/em&gt; library which is located in the &lt;em&gt;lib&lt;/em&gt; folder for the &lt;a href=&quot;https://github.com/JetBrains/kotlin/releases/tag/v1.3.41&quot;&gt;Kotlin Compiler&lt;/a&gt; Ant version 1.8.2+ is required.</source>
          <target state="translated">これらのタスクは、&lt;a href=&quot;https://github.com/JetBrains/kotlin/releases/tag/v1.3.41&quot;&gt;Kotlin Compiler&lt;/a&gt; Antバージョン1.8.2+ の&lt;em&gt;lib&lt;/em&gt;フォルダーにある&lt;em&gt;kotlin-ant.jar&lt;/em&gt;ライブラリで定義されています。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="35fb8f738b23790388f177e5975164208ed39249" translate="yes" xml:space="preserve">
          <source>These tasks are defined in the &lt;em&gt;kotlin-ant.jar&lt;/em&gt; library which is located in the &lt;em&gt;lib&lt;/em&gt; folder for the &lt;a href=&quot;https://github.com/JetBrains/kotlin/releases/tag/v1.4.10&quot;&gt;Kotlin Compiler&lt;/a&gt; Ant version 1.8.2+ is required.</source>
          <target state="translated">これらのタスクは、&lt;a href=&quot;https://github.com/JetBrains/kotlin/releases/tag/v1.4.10&quot;&gt;Kotlinコンパイラの&lt;/a&gt;&lt;em&gt;lib&lt;/em&gt;フォルダーにある&lt;em&gt;kotlin-ant.jar&lt;/em&gt;ライブラリで定義されています。Antバージョン1.8.2+が必要です。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1d0ae43a71338a23e33d7f8aec6b35c87860e63a" translate="yes" xml:space="preserve">
          <source>These transformations can also be applied to &lt;code&gt;Sequence&amp;lt;T&amp;gt;&lt;/code&gt;, which is similar to Python's generators and allows for lazy evaluation. If you have a huge list and you want to process it lazily, you can call &lt;code&gt;asSequence()&lt;/code&gt; on it.</source>
          <target state="translated">これらの変換は、Pythonのジェネレーターに似ており、遅延評価を可能にする &lt;code&gt;Sequence&amp;lt;T&amp;gt;&lt;/code&gt; にも適用できます。巨大なリストがあり、それを遅延処理したい場合は、その上で &lt;code&gt;asSequence()&lt;/code&gt; を呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="03f364964cb20dc479a4f5003a2a44d235abdb7a" translate="yes" xml:space="preserve">
          <source>These two functions can not be defined side-by-side, because their JVM signatures are the same: &lt;code&gt;filterValid(Ljava/util/List;)Ljava/util/List;&lt;/code&gt;. If we really want them to have the same name in Kotlin, we can annotate one (or both) of them with &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.jvm/-jvm-name/index&quot;&gt;&lt;code&gt;@JvmName&lt;/code&gt;&lt;/a&gt; and specify a different name as an argument:</source>
          <target state="translated">これらの2つの関数は、JVMシグニチャーが同じであるため、並べて定義することはできません &lt;code&gt;filterValid(Ljava/util/List;)Ljava/util/List;&lt;/code&gt; 。Kotlinで実際に同じ名前にしたい場合は、&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.jvm/-jvm-name/index&quot;&gt; &lt;code&gt;@JvmName&lt;/code&gt; &lt;/a&gt;でそれらの1つ（または両方）に注釈を付け、引数として別の名前を指定できます。</target>
        </trans-unit>
        <trans-unit id="921fb3d0fcc9e0673ab266d259447beb1dbfed2e" translate="yes" xml:space="preserve">
          <source>These two options let you choose the proper function depending on what you do next in your code.</source>
          <target state="translated">この 2 つのオプションでは、コードの中で次に何をするかに応じて適切な関数を選択できます。</target>
        </trans-unit>
        <trans-unit id="5dbdf5173288dba5a705ae6e593e7cbdf4691ea2" translate="yes" xml:space="preserve">
          <source>These types are used to map boxed Kotlin number types into Objective-C and Swift. In Swift, we may simply call the constructor to create an instance, e.g. &lt;code&gt;KotlinLong(value: 42)&lt;/code&gt;.</source>
          <target state="translated">これらの型は、ボックス化されたKotlin数値型をObjective-CおよびSwiftにマッピングするために使用されます。Swiftでは、コンストラクターを呼び出してインスタンスを作成するだけ &lt;code&gt;KotlinLong(value: 42)&lt;/code&gt; 例：KotlinLong（value：42））。</target>
        </trans-unit>
        <trans-unit id="c780ae4d91e6b3d59d657bd21738eface7e6d706" translate="yes" xml:space="preserve">
          <source>These types have a special notation that corresponds to the signatures of the functions, i.e. their parameters and return values:</source>
          <target state="translated">これらの型は、関数のシグネチャ、すなわちパラメータと戻り値に対応する特別な記法を持っています。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
