<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="kotlin">
    <body>
      <group id="kotlin">
        <trans-unit id="23d6510bb7782c43d563dd375dee713e5d305e0b" translate="yes" xml:space="preserve">
          <source>If you need a &lt;em&gt;singleton&lt;/em&gt; - a class that only has got one instance - you can declare the class in the usual way, but use the &lt;code&gt;object&lt;/code&gt; keyword instead of &lt;code&gt;class&lt;/code&gt;:</source>
          <target state="translated">あなたが必要な場合は&lt;em&gt;シングルトン&lt;/em&gt;インスタンスを1つだけ持っているクラスを- -あなたは、通常の方法でクラスを宣言しますが、使用することができ &lt;code&gt;object&lt;/code&gt; の代わりにキーワードを &lt;code&gt;class&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="fc8467398b87bfa40771e50f53a8a177a25657b1" translate="yes" xml:space="preserve">
          <source>If you need a fancier way of reading or writing file data, you have access to the full Java suite of I/O classes - in particular, &lt;code&gt;Scanner&lt;/code&gt;, which can parse numbers and other data types from files or other streams, and &lt;code&gt;BufferedReader&lt;/code&gt; (which is good for efficient reading of large amounts of data), which you can obtain by calling &lt;code&gt;bufferedReader()&lt;/code&gt; on a file or stream. See any Java tutorial for how to use these.</source>
          <target state="translated">ファイルデータの読み書きをより洗練された方法で行う必要がある場合は、I / Oクラスの完全なJavaスイートにアクセスできます。特に、ファイルやその他のストリームから数値やその他のデータ型を解析できる &lt;code&gt;Scanner&lt;/code&gt; や、 &lt;code&gt;BufferedReader&lt;/code&gt; （これには大量のデータを効率的に読み取るのに適しています）。これは、ファイルまたはストリームで &lt;code&gt;bufferedReader()&lt;/code&gt; を呼び出すことで取得できます。これらの使用方法については、Javaチュートリアルを参照してください。</target>
        </trans-unit>
        <trans-unit id="54e87845252769ababaaab1c06f5bd872659abd6" translate="yes" xml:space="preserve">
          <source>If you need a function or a property to be tied to a class rather than to instances of it (similar to &lt;code&gt;@staticmethod&lt;/code&gt; in Python), you can declare it inside a &lt;em&gt;companion object&lt;/em&gt;:</source>
          <target state="translated">関数またはプロパティをインスタンスではなくクラスに &lt;code&gt;@staticmethod&lt;/code&gt; がある場合（Pythonの@staticmethodと同様）、&lt;em&gt;コンパニオンオブジェクト&lt;/em&gt;内で宣言でき&lt;em&gt;ます&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="8de1431e2a233483ba705c03102c9221f4f2f632" translate="yes" xml:space="preserve">
          <source>If you need multiple ways to initialize a class, you can create &lt;em&gt;secondary constructors&lt;/em&gt;, each of which looks like a function whose name is &lt;code&gt;constructor&lt;/code&gt;. Every secondary constructor must invoke another (primary or secondary) constructor by using the &lt;code&gt;this&lt;/code&gt; keyword as if it were a function (so that every instance construction eventually calls the primary constructor).</source>
          <target state="translated">クラスを初期化するために複数の方法が必要な場合は、それぞれ &lt;code&gt;constructor&lt;/code&gt; という名前の関数のように見える、&lt;em&gt;2次コンストラクター&lt;/em&gt;を作成できます。すべての2次コンストラクターは、関数のように &lt;code&gt;this&lt;/code&gt; キーワードを使用して、別の（1次または2次）コンストラクターを呼び出す必要があります（そのため、すべてのインスタンス構築が最終的に1次コンストラクターを呼び出します）。</target>
        </trans-unit>
        <trans-unit id="e23221640befe2f0b60d6c58ea9b02d7e3a97b07" translate="yes" xml:space="preserve">
          <source>If you need to access a class implemented in JavaScript from Kotlin in a typesafe way, you can write a Kotlin declaration using the &lt;code&gt;external&lt;/code&gt; modifier. (In Kotlin 1.0, the &lt;code&gt;@native&lt;/code&gt; annotation was used instead.) Unlike the JVM target, the JS one permits to use external modifier with classes and properties. For example, here's how you can declare the DOM &lt;code&gt;Node&lt;/code&gt; class:</source>
          <target state="translated">タイプセーフな方法でKotlinからJavaScriptで実装されたクラスにアクセスする必要がある場合は、 &lt;code&gt;external&lt;/code&gt; 修飾子を使用してKotlin宣言を記述できます。（Kotlin 1.0では、代わりに &lt;code&gt;@native&lt;/code&gt; アノテーションが使用されていました。）JVMターゲットとは異なり、JSはクラスとプロパティで外部修飾子を使用することを許可します。たとえば、DOM &lt;code&gt;Node&lt;/code&gt; クラスを宣言する方法は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="f99443af480d55217c4ce0d28159d54e4f7cf72b" translate="yes" xml:space="preserve">
          <source>If you need to access platform-specific APIs from the shared code, use the Kotlin mechanism of &lt;a href=&quot;mpp-connect-to-apis&quot;&gt;expected and actual declarations&lt;/a&gt;.</source>
          <target state="translated">共有コードからプラットフォーム固有のAPIにアクセスする必要がある場合は、&lt;a href=&quot;mpp-connect-to-apis&quot;&gt;予想される宣言と実際の宣言の&lt;/a&gt;Kotlinメカニズムを使用してください。</target>
        </trans-unit>
        <trans-unit id="d4e8082dbfdacd1170b034e190a7f81841b9039b" translate="yes" xml:space="preserve">
          <source>If you need to annotate the primary constructor of a class, you need to add the &lt;em&gt;constructor&lt;/em&gt; keyword to the constructor declaration, and add the annotations before it:</source>
          <target state="translated">クラスのプライマリコンストラクターに注釈を付ける必要がある場合は、&lt;em&gt;コンストラクター&lt;/em&gt;キーワードをコンストラクター宣言に追加し、その前に注釈を追加する必要があります。</target>
        </trans-unit>
        <trans-unit id="e462275c07255513e75672de08e598bdce5e271f" translate="yes" xml:space="preserve">
          <source>If you need to change the visibility of an accessor or to annotate it, but don't need to change the default implementation, you can define the accessor without defining its body:</source>
          <target state="translated">アクセサの可視性を変更したり注釈を付けたりする必要があるが、デフォルトの実装を変更する必要がない場合は、アクセサのボディを定義せずにアクセサを定義することができます。</target>
        </trans-unit>
        <trans-unit id="4613a8244834c0ecb89ce0d825ca742a6fa51707" translate="yes" xml:space="preserve">
          <source>If you need to expose a Kotlin property as a field in Java, annotate it with the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.jvm/-jvm-field/index&quot;&gt;&lt;code&gt;@JvmField&lt;/code&gt;&lt;/a&gt; annotation. The field will have the same visibility as the underlying property. You can annotate a property with &lt;code&gt;@JvmField&lt;/code&gt; if it has a backing field, is not private, does not have &lt;code&gt;open&lt;/code&gt;, &lt;code&gt;override&lt;/code&gt; or &lt;code&gt;const&lt;/code&gt; modifiers, and is not a delegated property.</source>
          <target state="translated">KotlinプロパティをJavaのフィールドとして公開する必要がある場合は、&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.jvm/-jvm-field/index&quot;&gt; &lt;code&gt;@JvmField&lt;/code&gt; &lt;/a&gt;アノテーションを付けます。フィールドは、基になるプロパティと同じ可視性を持ちます。プロパティにバッキングフィールドがあり、プライベートではなく、 &lt;code&gt;open&lt;/code&gt; 、 &lt;code&gt;override&lt;/code&gt; または &lt;code&gt;const&lt;/code&gt; 修飾子がなく、委任されたプロパティでない場合、 &lt;code&gt;@JvmField&lt;/code&gt; プロパティに注釈を付けることができます。</target>
        </trans-unit>
        <trans-unit id="b3648463615f31d33dec14dff446661a5d42afc8" translate="yes" xml:space="preserve">
          <source>If you need to know the index of the current element when you're iterating over something, you can use &lt;code&gt;withIndex()&lt;/code&gt;, which corresponds to &lt;code&gt;enumerate()&lt;/code&gt;. It produces a sequence of objects that have got two properties (the index and the value) and two specially-named accessor functions called &lt;code&gt;component1()&lt;/code&gt; and &lt;code&gt;component2()&lt;/code&gt;; Kotlin lets you destructure such an object into a declaration:</source>
          <target state="translated">何かを反復処理するときに現在の要素のインデックスを知る必要がある場合は、 &lt;code&gt;enumerate()&lt;/code&gt; に対応する &lt;code&gt;withIndex()&lt;/code&gt; を使用できます。これは、2つのプロパティ（インデックスと値）と、 &lt;code&gt;component1()&lt;/code&gt; および &lt;code&gt;component2()&lt;/code&gt; と呼ばれる2つの特別な名前のアクセサ関数を持つオブジェクトのシーケンスを生成します。Kotlinを使用すると、このようなオブジェクトを宣言に分解できます。</target>
        </trans-unit>
        <trans-unit id="89e90e48358e19dcdf7d70c38acd3455ecae2039" translate="yes" xml:space="preserve">
          <source>If you need to know the index of the current element when you're iterating through something, you can use &lt;code&gt;withIndex()&lt;/code&gt;, which corresponds to &lt;code&gt;enumerate()&lt;/code&gt;. It produces a sequence of objects that have got two properties (the index and the value) and two specially-named accessor functions called &lt;code&gt;component1()&lt;/code&gt; and &lt;code&gt;component2()&lt;/code&gt;; Kotlin lets you destructure such an object into a declaration:</source>
          <target state="translated">何かを反復しているときに現在の要素のインデックスを知る必要がある場合は、 &lt;code&gt;enumerate()&lt;/code&gt; に対応する &lt;code&gt;withIndex()&lt;/code&gt; を使用できます。これは、2つのプロパティ（インデックスと値）と、 &lt;code&gt;component1()&lt;/code&gt; および &lt;code&gt;component2()&lt;/code&gt; と呼ばれる2つの特別な名前のアクセサ関数を持つオブジェクトのシーケンスを生成します。Kotlinでは、そのようなオブジェクトを宣言に分解できます。</target>
        </trans-unit>
        <trans-unit id="4c304182ad4dffb827b2cd5041835d4a1290ba5c" translate="yes" xml:space="preserve">
          <source>If you need to look up the class dynamically as well, you can use &lt;code&gt;Class.forName()&lt;/code&gt; and supply the fully-qualified name of the class.</source>
          <target state="translated">クラスも動的に検索する必要がある場合は、 &lt;code&gt;Class.forName()&lt;/code&gt; を使用して、クラスの完全修飾名を指定できます。</target>
        </trans-unit>
        <trans-unit id="fb05e76a6c128f62bf211b270ee1f300cbc3d9aa" translate="yes" xml:space="preserve">
          <source>If you need to retrieve an arbitrary element of a collection, call the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/random&quot;&gt;&lt;code&gt;random()&lt;/code&gt;&lt;/a&gt; function. You can call it without arguments or with a &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.random/-random/index&quot;&gt;&lt;code&gt;Random&lt;/code&gt;&lt;/a&gt; object as a source of the randomness.</source>
          <target state="translated">コレクションの任意の要素を取得する必要がある場合は、&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/random&quot;&gt; &lt;code&gt;random()&lt;/code&gt; &lt;/a&gt;関数を呼び出します。引数なしで、またはランダム性のソースとして&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.random/-random/index&quot;&gt; &lt;code&gt;Random&lt;/code&gt; &lt;/a&gt;オブジェクトを使用して呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="2c6c6ff6a76abad65e2d1d67dae2bda5a0418cb0" translate="yes" xml:space="preserve">
          <source>If you need to retrieve the collection content in a readable format, use functions that transform the collections to strings: &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/join-to-string&quot;&gt;&lt;code&gt;joinToString()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/join-to&quot;&gt;&lt;code&gt;joinTo()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">コレクションのコンテンツを読み取り可能な形式で取得する必要がある場合は、コレクションを文字列に変換する関数&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/join-to-string&quot;&gt; &lt;code&gt;joinToString()&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/join-to&quot;&gt; &lt;code&gt;joinTo()&lt;/code&gt; を使用し&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="27633af274eff8d8c59fb2e4a25231c59018307c" translate="yes" xml:space="preserve">
          <source>If you need to specify a class as an argument of an annotation, use a Kotlin class (&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.reflect/-k-class/index&quot;&gt;KClass&lt;/a&gt;). The Kotlin compiler will automatically convert it to a Java class, so that the Java code can access the annotations and arguments normally.</source>
          <target state="translated">アノテーションの引数としてクラスを指定する必要がある場合は、Kotlinクラス（&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.reflect/-k-class/index&quot;&gt;KClass&lt;/a&gt;）を使用してください。Kotlinコンパイラはそれを自動的にJavaクラスに変換するため、Javaコードは通常どおりアノテーションと引数にアクセスできます。</target>
        </trans-unit>
        <trans-unit id="993106f4a5b27e1d574e1151066452d4ad416447" translate="yes" xml:space="preserve">
          <source>If you need to specify a class as an argument of an annotation, use a Kotlin class (&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.reflect/-k-class/index&quot;&gt;KClass&lt;/a&gt;). The Kotlin compiler will automatically convert it to a Java class, so that the Java code will be able to see the annotations and arguments normally.</source>
          <target state="translated">アノテーションの引数としてクラスを指定する必要がある場合は、Kotlinクラス（&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.reflect/-k-class/index&quot;&gt;KClass&lt;/a&gt;）を使用します。Kotlinコンパイラーはそれを自動的にJavaクラスに変換するため、Javaコードは通常、注釈と引数を見ることができます。</target>
        </trans-unit>
        <trans-unit id="7448bb25e266494ddde684c5929327a96a8fb964" translate="yes" xml:space="preserve">
          <source>If you need to use a nullable &lt;code&gt;Boolean&lt;/code&gt; in a conditional statement, use &lt;code&gt;if (value == true)&lt;/code&gt; or &lt;code&gt;if (value == false)&lt;/code&gt; checks.</source>
          <target state="translated">条件ステートメントでnull許容の &lt;code&gt;Boolean&lt;/code&gt; を使用する必要がある場合は、 &lt;code&gt;if (value == true)&lt;/code&gt; または &lt;code&gt;if (value == false)&lt;/code&gt; チェックを使用します。</target>
        </trans-unit>
        <trans-unit id="2c201a6c8803ec9d0564e44a48fc6ef8489585c2" translate="yes" xml:space="preserve">
          <source>If you need to write a function that can be called without having a class instance but needs access to the internals of a class (for example, a factory method), you can write it as a member of an &lt;a href=&quot;object-declarations&quot;&gt;object declaration&lt;/a&gt; inside that class.</source>
          <target state="translated">クラスインスタンスがなくても呼び出すことができるが、クラスの内部（たとえば、ファクトリメソッド）にアクセスする必要がある関数を記述する必要がある場合は、そのクラス内の&lt;a href=&quot;object-declarations&quot;&gt;オブジェクト宣言の&lt;/a&gt;メンバーとして関数を記述できます。</target>
        </trans-unit>
        <trans-unit id="5f584df433485780683ca571ae5a89e659948c6b" translate="yes" xml:space="preserve">
          <source>If you only want to call the function and don't care about the metadata, use a function type, e.g. &lt;code&gt;(A, B) -&amp;gt; V&lt;/code&gt; for an ordinary function reference or a bound member function reference, or &lt;code&gt;A.(B, C) -&amp;gt; V&lt;/code&gt; for an unbound member function reference on &lt;code&gt;A&lt;/code&gt;. Note that &lt;code&gt;KFunction&amp;lt;V&amp;gt;&lt;/code&gt; and its subinterfaces are only available for declared functions (obtained either by explicitly referencing it in the code, or through reflection, as shown later) - only function types are available for function literals (lambda expressions or anonymous functions).</source>
          <target state="translated">関数を呼び出すだけでメタデータを気にしない場合は、関数タイプを使用します。例： &lt;code&gt;(A, B) -&amp;gt; V&lt;/code&gt; 通常の関数参照またはバインドされたメンバー関数参照、または &lt;code&gt;A.(B, C) -&amp;gt; V&lt;/code&gt; に結合していないメンバ関数参照の &lt;code&gt;A&lt;/code&gt; 。 &lt;code&gt;KFunction&amp;lt;V&amp;gt;&lt;/code&gt; とそのサブインターフェースは、宣言された関数（コードで明示的に参照するか、後で示すようにリフレクションによって取得）でのみ使用できることに注意してください-関数リテラル（ラムダ式または無名関数）で使用できるのは関数タイプのみです。 。</target>
        </trans-unit>
        <trans-unit id="8014e84399844604d4127e5bfb102e3054b9b7f6" translate="yes" xml:space="preserve">
          <source>If you operate nested collections, you may find the standard library functions that provide flat access to nested collection elements useful.</source>
          <target state="translated">入れ子になったコレクションを操作する場合、入れ子になったコレクション要素へのフラットアクセスを提供する標準ライブラリ関数が便利です。</target>
        </trans-unit>
        <trans-unit id="aa8d397c2c2050d55c50d82eec1a501b49617481" translate="yes" xml:space="preserve">
          <source>If you override a &lt;code&gt;protected&lt;/code&gt; member and do not specify the visibility explicitly, the overriding member will also have &lt;code&gt;protected&lt;/code&gt; visibility.</source>
          <target state="translated">&lt;code&gt;protected&lt;/code&gt; メンバーをオーバーライドし、可視性を明示的に指定しない場合、オーバーライドするメンバーも可視性を &lt;code&gt;protected&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="bd8f947a24ab8c99f576a413b868a14fd70348dc" translate="yes" xml:space="preserve">
          <source>If you previously used the &lt;a href=&quot;https://developer.android.com/studio/build/gradle-plugin-3-0-0-migration.html#annotationProcessor_config&quot;&gt;Android support&lt;/a&gt; for annotation processors, replace usages of the &lt;code&gt;annotationProcessor&lt;/code&gt; configuration with &lt;code&gt;kapt&lt;/code&gt;. If your project contains Java classes, &lt;code&gt;kapt&lt;/code&gt; will also take care of them.</source>
          <target state="translated">以前にアノテーションプロセッサの&lt;a href=&quot;https://developer.android.com/studio/build/gradle-plugin-3-0-0-migration.html#annotationProcessor_config&quot;&gt;Androidサポート&lt;/a&gt;を使用していた場合は、 &lt;code&gt;annotationProcessor&lt;/code&gt; 構成の使用法を &lt;code&gt;kapt&lt;/code&gt; に置き換えます。プロジェクトにJavaクラスが含まれている場合、 &lt;code&gt;kapt&lt;/code&gt; もそれらを処理します。</target>
        </trans-unit>
        <trans-unit id="3126f475d393c0188e7088d866ab3c517a722979" translate="yes" xml:space="preserve">
          <source>If you publish several features in the experimental state, declare a marker for each. Separate markers make the use of experimental features safer for your clients: they'll be able to use only the features that they explicitly accept. This also lets you graduate the features to stable independently.</source>
          <target state="translated">実験的な状態で複数の機能を公開する場合は、それぞれにマーカーを宣言します。マーカーを分けておくことで、実験的な機能をより安全に使用することができます。これにより、機能を独立して安定版に移行させることができます。</target>
        </trans-unit>
        <trans-unit id="df8a586d7260c254feebf62ecf6abe57e497a3fe" translate="yes" xml:space="preserve">
          <source>If you really really need a mixed-type collection, you can use the element type &lt;code&gt;Any&lt;/code&gt; - but you'll need typecasting to get the elements back to their proper type again, so if what you want is a multiple-value return from a function, please use the per-element-typed &lt;code&gt;Pair&lt;/code&gt; or &lt;code&gt;Triple&lt;/code&gt; instead. If you need four or more elements, consider making a &lt;a href=&quot;classes#data-classes&quot;&gt;data class&lt;/a&gt; for the return type instead (which you should ideally do for two or three elements as well, especially if it's a public function, since it gives you proper names for the elements) - it's very easy and usually a oneliner.</source>
          <target state="translated">本当に混合型のコレクションが必要な場合は、要素型 &lt;code&gt;Any&lt;/code&gt; を使用できますが、要素を適切な型に戻すには型キャストが必要になるため、関数から複数の値を返す場合は、代わりに要素ごとに型指定された &lt;code&gt;Pair&lt;/code&gt; または &lt;code&gt;Triple&lt;/code&gt; を使用してください。4つ以上の要素が必要な場合は、代わりに戻り値の型の&lt;a href=&quot;classes#data-classes&quot;&gt;データクラス&lt;/a&gt;を作成することを検討してください（2つまたは3つの要素にも理想的です。特に、それが要素の適切な名前を提供するため、パブリック関数の場合）。とても簡単で、通常はワンライナーです。</target>
        </trans-unit>
        <trans-unit id="cbc8324a9f6502600707b1d372c5b0e01758d5e6" translate="yes" xml:space="preserve">
          <source>If you really want to, you can both initialize and specify the type on the same line. This is mostly useful if you're dealing with a class hierarchy (more on that later) and you want the variable type to be a base type of the value's class:</source>
          <target state="translated">本当に必要ならば、初期化と型の指定を同じ行で行うことができます。これは、クラス階層を扱っていて(これについては後述します)、変数の型を値のクラスのベース型にしたい場合に便利です。</target>
        </trans-unit>
        <trans-unit id="13648197906f478e28c0bcf3383cb817c3e322b6" translate="yes" xml:space="preserve">
          <source>If you run the above code you'll see that it does not always print zero, though it may depend on the timings of your machine you may need to tweak timeouts in this example to actually see non-zero values.</source>
          <target state="translated">上記のコードを実行してみると、常にゼロを表示しているわけではないことがわかるでしょう。</target>
        </trans-unit>
        <trans-unit id="dd3a00df64d22ebf69e57bb704a9d62539a93298" translate="yes" xml:space="preserve">
          <source>If you start by replacing &lt;code&gt;GlobalScope.launch&lt;/code&gt; by &lt;code&gt;thread&lt;/code&gt;, the compiler produces the following error:</source>
          <target state="translated">&lt;code&gt;GlobalScope.launch&lt;/code&gt; を &lt;code&gt;thread&lt;/code&gt; で置き換えることから始めると、コンパイラーは次のエラーを生成します。</target>
        </trans-unit>
        <trans-unit id="1244c242be7001db0fa42d5a34807cd464a4c723" translate="yes" xml:space="preserve">
          <source>If you start by replacing &lt;code&gt;GlobalScope.launch&lt;/code&gt; with &lt;code&gt;thread&lt;/code&gt;, the compiler produces the following error:</source>
          <target state="translated">&lt;code&gt;GlobalScope.launch&lt;/code&gt; を &lt;code&gt;thread&lt;/code&gt; に置き換えることから始めると、コンパイラーは次のエラーを生成します。</target>
        </trans-unit>
        <trans-unit id="589b4c81823f6922542c45e2902c148531d2b494" translate="yes" xml:space="preserve">
          <source>If you target JavaScript, use the &lt;code&gt;stdlib-js&lt;/code&gt; dependency.</source>
          <target state="translated">JavaScriptをターゲットにする場合は、 &lt;code&gt;stdlib-js&lt;/code&gt; 依存関係を使用します。</target>
        </trans-unit>
        <trans-unit id="bf587872264afbd1369b320aaae73dd1b3673d1b" translate="yes" xml:space="preserve">
          <source>If you use &lt;a href=&quot;kapt&quot;&gt;kapt&lt;/a&gt;, note that the kapt annotation processing tasks are not cached by default. However, you can &lt;a href=&quot;kapt#gradle-build-cache-support-since-1220&quot;&gt;enable caching for them manually&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;kapt&quot;&gt;kapt&lt;/a&gt;を使用する場合、kaptアノテーション処理タスクはデフォルトではキャッシュされないことに注意してください。ただし、&lt;a href=&quot;kapt#gradle-build-cache-support-since-1220&quot;&gt;手動でキャッシュを有効にする&lt;/a&gt;ことができます。</target>
        </trans-unit>
        <trans-unit id="39efa722c74de834ad1bd8a4e4c201bd7dac494b" translate="yes" xml:space="preserve">
          <source>If you use &lt;a href=&quot;kapt&quot;&gt;kapt&lt;/a&gt;, note that the kapt annotation processing tasks are not cached by default. However, you can enable caching for them manually. See the &lt;a href=&quot;kapt#gradle-build-cache-support-since-1220&quot;&gt;kapt page&lt;/a&gt; for details.</source>
          <target state="translated">&lt;a href=&quot;kapt&quot;&gt;kapt&lt;/a&gt;を使用する場合、kaptアノテーション処理タスクはデフォルトではキャッシュされないことに注意してください。ただし、それらのキャッシュを手動で有効にすることができます。詳細については、&lt;a href=&quot;kapt#gradle-build-cache-support-since-1220&quot;&gt;kaptページ&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="a73c7aeee6bdc5c7806d3e53e9294fc8ac4610bf" translate="yes" xml:space="preserve">
          <source>If you use Spring, you can enable the &lt;em&gt;kotlin-spring&lt;/em&gt; compiler plugin instead of specifying Spring annotations manually. The kotlin-spring is a wrapper on top of all-open, and it behaves exactly the same way.</source>
          <target state="translated">Springを使用する場合は、Springアノテーションを手動で指定する代わりに、&lt;em&gt;kotlin-spring&lt;/em&gt;コンパイラプラグインを有効にすることができます。kotlin-springはall-openのラッパーであり、まったく同じように動作します。</target>
        </trans-unit>
        <trans-unit id="611d8f619bf7a7948c981fe9d16f096526d50981" translate="yes" xml:space="preserve">
          <source>If you use a kotlinx library and need a platform-specific dependency, you can use platform-specific variants of libraries with suffixes such as &lt;code&gt;-jvm&lt;/code&gt; or &lt;code&gt;-js&lt;/code&gt;, for example, &lt;code&gt;kotlinx-coroutines-core-jvm&lt;/code&gt;. You can also use the library base artifact name instead &amp;ndash; &lt;code&gt;kotlinx-coroutines-core&lt;/code&gt;.</source>
          <target state="translated">kotlinxライブラリを使用していて、プラットフォーム固有の依存関係が必要な場合は、 &lt;code&gt;-jvm&lt;/code&gt; や &lt;code&gt;-js&lt;/code&gt; などのサフィックスが付いたライブラリのプラットフォーム固有のバリアントを使用できます（例： &lt;code&gt;kotlinx-coroutines-core-jvm&lt;/code&gt; )。代わりに、ライブラリベースのアーティファクト名 &lt;code&gt;kotlinx-coroutines-core&lt;/code&gt; 使用することもできます。</target>
        </trans-unit>
        <trans-unit id="7efa55746211a1f8112a9a60777f3c462da2efbd" translate="yes" xml:space="preserve">
          <source>If you use a multiplatform library and need to depend on the shared code, set the dependency only once in the shared source set. Use the library base artifact name, such as &lt;code&gt;kotlinx-coroutines-core&lt;/code&gt; or &lt;code&gt;ktor-client-core&lt;/code&gt;.</source>
          <target state="translated">マルチプラットフォームライブラリを使用していて、共有コードに依存する必要がある場合は、共有ソースセットで依存関係を1回だけ設定してください。 &lt;code&gt;kotlinx-coroutines-core&lt;/code&gt; や &lt;code&gt;ktor-client-core&lt;/code&gt; などのライブラリベースアーティファクト名を使用します。</target>
        </trans-unit>
        <trans-unit id="1bce77e8c93a7ca161789d86b2fef454e9ed0e0f" translate="yes" xml:space="preserve">
          <source>If you use annotation processors for your &lt;code&gt;androidTest&lt;/code&gt; or &lt;code&gt;test&lt;/code&gt; sources, the respective &lt;code&gt;kapt&lt;/code&gt; configurations are named &lt;code&gt;kaptAndroidTest&lt;/code&gt; and &lt;code&gt;kaptTest&lt;/code&gt;. Note that &lt;code&gt;kaptAndroidTest&lt;/code&gt; and &lt;code&gt;kaptTest&lt;/code&gt; extends &lt;code&gt;kapt&lt;/code&gt;, so you can just provide the &lt;code&gt;kapt&lt;/code&gt; dependency and it will be available both for production sources and tests.</source>
          <target state="translated">&lt;code&gt;androidTest&lt;/code&gt; または &lt;code&gt;test&lt;/code&gt; ソースにアノテーションプロセッサを使用する場合、それぞれの &lt;code&gt;kapt&lt;/code&gt; 構成は &lt;code&gt;kaptAndroidTest&lt;/code&gt; および &lt;code&gt;kaptTest&lt;/code&gt; という名前になります。ことを注意 &lt;code&gt;kaptAndroidTest&lt;/code&gt; と &lt;code&gt;kaptTest&lt;/code&gt; が拡張 &lt;code&gt;kapt&lt;/code&gt; を、あなたはただ提供することができます &lt;code&gt;kapt&lt;/code&gt; の依存関係を、それが両方の生産源とテストのために利用できるようになります。</target>
        </trans-unit>
        <trans-unit id="8e5fa9bba802b4996dceed857e221c7dc79c3552" translate="yes" xml:space="preserve">
          <source>If you use the NV Kotlin compiler and have the OV standard library or the OV reflection library in the classpath, it can be a sign that the project is misconfigured. To prevent unexpected problems during compilation or at runtime, we suggest either updating the dependencies to NV, or specifying the API version / language version arguments explicitly. Otherwise the compiler detects that something can go wrong and reports a warning.</source>
          <target state="translated">NVのKotlinコンパイラを使用していて、クラスパスにOV標準ライブラリやOV反射ライブラリがある場合、プロジェクトの設定が間違っているサインである可能性があります。コンパイル中や実行時の予期せぬ問題を防ぐために、依存関係をNVに更新するか、APIバージョン/言語バージョンの引数を明示的に指定することをお勧めします。そうしないと、コンパイラは何かが間違っている可能性があることを検出し、警告を報告します。</target>
        </trans-unit>
        <trans-unit id="f69388ccfa9be1025c7351e156b510d0110f1b95" translate="yes" xml:space="preserve">
          <source>If you want a literal &lt;code&gt;$&lt;/code&gt;, you need to escape it: &lt;code&gt;\$&lt;/code&gt;. Escaping generally works the same way as in Python, with a similar set of standard escape sequences.</source>
          <target state="translated">リテラル &lt;code&gt;$&lt;/code&gt; が必要な場合は、エスケープする必要があります： &lt;code&gt;\$&lt;/code&gt; 。エスケープは通常、Pythonと同じように機能し、類似した標準エスケープシーケンスのセットを使用します。</target>
        </trans-unit>
        <trans-unit id="542e15c450e9d7499e5b8e3fd1eff9a8b7386f93" translate="yes" xml:space="preserve">
          <source>If you want to &lt;strong&gt;start from scratch&lt;/strong&gt;, you can &lt;a href=&quot;jvm-get-started&quot;&gt;create a basic Kotlin application&lt;/a&gt;. Once you&amp;rsquo;ve created the application, you can dive deeper into Kotlin syntax:</source>
          <target state="translated">&lt;strong&gt;ゼロ&lt;/strong&gt;から&lt;strong&gt;始め&lt;/strong&gt;たい場合は&lt;a href=&quot;jvm-get-started&quot;&gt;、基本的なKotlinアプリケーションを作成&lt;/a&gt;できます。アプリケーションを作成したら、Kotlin構文をさらに深く掘り下げることができます。</target>
        </trans-unit>
        <trans-unit id="dcc75b83f1a6aedb14b4da0cf0332f54ec31285c" translate="yes" xml:space="preserve">
          <source>If you want to alert callers of possible exceptions when calling Kotlin code from Java, Swift, or Objective-C, you can use the &lt;code&gt;@Throws&lt;/code&gt; annotation. Read more about using this annotation &lt;a href=&quot;java-to-kotlin-interop#checked-exceptions&quot;&gt;for Java&lt;/a&gt; as well as &lt;a href=&quot;native/objc_interop#errors-and-exceptions&quot;&gt;for Swift and Objective-C&lt;/a&gt;.</source>
          <target state="translated">Java、Swift、またはObjective-CからKotlinコードを呼び出すときに発生する可能性のある例外について発信者に警告する場合は、 &lt;code&gt;@Throws&lt;/code&gt; アノテーションを使用できます。このアノテーション&lt;a href=&quot;java-to-kotlin-interop#checked-exceptions&quot;&gt;をJava&lt;/a&gt;だけでなく&lt;a href=&quot;native/objc_interop#errors-and-exceptions&quot;&gt;、SwiftとObjective-Cに&lt;/a&gt;も使用する方法の詳細をご覧ください。</target>
        </trans-unit>
        <trans-unit id="aeb2cd1321a6da714d1670aa5db99ba2841082d1" translate="yes" xml:space="preserve">
          <source>If you want to be able to intercept an assignment and &quot;veto&quot; it, use &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.properties/-delegates/vetoable&quot;&gt;&lt;code&gt;vetoable()&lt;/code&gt;&lt;/a&gt; instead of &lt;code&gt;observable()&lt;/code&gt;. The handler passed to the &lt;code&gt;vetoable&lt;/code&gt; is called &lt;em&gt;before&lt;/em&gt; the assignment of a new property value has been performed.</source>
          <target state="translated">割り当てをインターセプトして「拒否」できるようにするには、 &lt;code&gt;observable()&lt;/code&gt; ではなく&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.properties/-delegates/vetoable&quot;&gt; &lt;code&gt;vetoable()&lt;/code&gt; を&lt;/a&gt;使用します。 &lt;code&gt;vetoable&lt;/code&gt; 渡されたハンドラーは、新しいプロパティ値の割り当てが実行される&lt;em&gt;前&lt;/em&gt;に呼び出されます。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bfcb549b385e785251e8b67f2103cc999018679b" translate="yes" xml:space="preserve">
          <source>If you want to be more explicit about the fact that you're creating a function, you can make an &lt;em&gt;anonymous function&lt;/em&gt;, which is still an expression rather than a declaration:</source>
          <target state="translated">関数を作成しているという事実をより明確にしたい場合は、宣言ではなく式である&lt;em&gt;無名関数&lt;/em&gt;を作成できます。</target>
        </trans-unit>
        <trans-unit id="696e4536ad6464f41098a1506dbe37ed6e039609" translate="yes" xml:space="preserve">
          <source>If you want to check for &lt;em&gt;not&lt;/em&gt; being an instance of a type, use &lt;code&gt;!is&lt;/code&gt;. Note that &lt;code&gt;null&lt;/code&gt; is never an instance of any non-nullable type, but it is always an &quot;instance&quot; of any nullable type (even though it technically isn't an instance, but an absence of any instance).</source>
          <target state="translated">タイプのインスタンスで&lt;em&gt;ない&lt;/em&gt;ことを確認する場合は、 &lt;code&gt;!is&lt;/code&gt; を使用します。 &lt;code&gt;null&lt;/code&gt; はnull可能ではない型のインスタンスではないことに注意してください。ただし、null可能な型の「インスタンス」であることに注意してください（技術的にはインスタンスではなく、インスタンスがない場合でも）。</target>
        </trans-unit>
        <trans-unit id="da257f8128fc0a8ca8d706e6f33a71205b6846f0" translate="yes" xml:space="preserve">
          <source>If you want to customize your builds or run configuration, refer to the Android Studio &lt;a href=&quot;https://developer.android.com/studio/run&quot;&gt;documentation&lt;/a&gt;.</source>
          <target state="translated">ビルドまたは実行構成をカスタマイズする場合は、Android Studioの&lt;a href=&quot;https://developer.android.com/studio/run&quot;&gt;ドキュメントを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="6811d9ac7923673de93e7c6cb86e0dcf12f4b539" translate="yes" xml:space="preserve">
          <source>If you want to declare your module's API as experimental, create an annotation class to use as its &lt;em&gt;experimental marker&lt;/em&gt;. This class must be annotated with &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-experimental/index&quot;&gt;@Experimental&lt;/a&gt;:</source>
          <target state="translated">モジュールのAPIを実験的として宣言する場合は、&lt;em&gt;実験的マーカー&lt;/em&gt;として使用する注釈クラスを作成し&lt;em&gt;ます&lt;/em&gt;。このクラスには&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-experimental/index&quot;&gt;@Experimental&lt;/a&gt;アノテーションを付ける必要があります：</target>
        </trans-unit>
        <trans-unit id="03930681c826a10c017d1c305e0dfdcd631eb099" translate="yes" xml:space="preserve">
          <source>If you want to do something that does not fit into this &quot;implicit backing field&quot; scheme, you can always fall back to having a &lt;em&gt;backing property&lt;/em&gt;:</source>
          <target state="translated">この「暗黙のバッキングフィールド」のスキームに当てはまらないことをしたい場合は、常に&lt;em&gt;バッキングプロパティ&lt;/em&gt;を使用するようにフォールバックでき&lt;em&gt;ます&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="469cbead1816f95552e8fb9afc4584e38910eba1" translate="yes" xml:space="preserve">
          <source>If you want to exclude the last value, use &lt;code&gt;until&lt;/code&gt;:</source>
          <target state="translated">最後の値を除外する場合は、 &lt;code&gt;until&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="21db5d6173e4569eae43123218189b3a3fd619bd" translate="yes" xml:space="preserve">
          <source>If you want to group elements and then apply an operation to all groups at one time, use the function &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/grouping-by&quot;&gt;&lt;code&gt;groupingBy()&lt;/code&gt;&lt;/a&gt;. It returns an instance of the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-grouping/index&quot;&gt;&lt;code&gt;Grouping&lt;/code&gt;&lt;/a&gt; type. The &lt;code&gt;Grouping&lt;/code&gt; instance lets you apply operations to all groups in a lazy manner: the groups are actually built right before the operation execution.</source>
          <target state="translated">要素を&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/grouping-by&quot;&gt; &lt;code&gt;groupingBy()&lt;/code&gt; &lt;/a&gt;から、一度にすべてのグループに操作を適用する場合は、関数groupingBy（）を使用します。これは、&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-grouping/index&quot;&gt; &lt;code&gt;Grouping&lt;/code&gt; &lt;/a&gt;タイプのインスタンスを返します。 &lt;code&gt;Grouping&lt;/code&gt; グループが実際に右の操作を実行する前に構築されています：インスタンスは、あなたが怠惰な方法で、すべてのグループに操作を適用することができます。</target>
        </trans-unit>
        <trans-unit id="28c8357f8e591acaadaa35ef0312974da5893976" translate="yes" xml:space="preserve">
          <source>If you want to impose additional constraints, you must use a separate &lt;code&gt;where&lt;/code&gt; clause, in which case the type parameter must be a subclass of the given class (if you specify a class, and you can specify at most one) &lt;em&gt;and&lt;/em&gt; implement all the given interfaces. You may then access all the public members of all the given types whenever you've got a value of type &lt;code&gt;T&lt;/code&gt;:</source>
          <target state="translated">追加の制約を課したい場合は、別個の &lt;code&gt;where&lt;/code&gt; 句を使用する必要があります。その場合、typeパラメータは特定のクラスのサブクラスでなければならず（クラスを指定し、最大で1つを指定できる場合）、特定のすべて&lt;em&gt;を&lt;/em&gt;実装します。インターフェース。その後、型 &lt;code&gt;T&lt;/code&gt; の値を取得すると、指定されたすべての型のすべてのパブリックメンバーにアクセスできます。</target>
        </trans-unit>
        <trans-unit id="1e91febbc6ec64c3a83c00953396a7246b3b6ef2" translate="yes" xml:space="preserve">
          <source>If you want to intercept assignments and &quot;veto&quot; them, use &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.properties/-delegates/vetoable&quot;&gt;&lt;code&gt;vetoable()&lt;/code&gt;&lt;/a&gt; instead of &lt;code&gt;observable()&lt;/code&gt;. The handler passed to the &lt;code&gt;vetoable&lt;/code&gt; is called &lt;em&gt;before&lt;/em&gt; the assignment of a new property value has been performed.</source>
          <target state="translated">割り当てをインターセプトして「拒否」する場合は、 &lt;code&gt;observable()&lt;/code&gt; の代わりに&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.properties/-delegates/vetoable&quot;&gt; &lt;code&gt;vetoable()&lt;/code&gt; を&lt;/a&gt;使用します。 &lt;code&gt;vetoable&lt;/code&gt; に渡されたハンドラーは、新しいプロパティ値の割り当てが実行される&lt;em&gt;前&lt;/em&gt;に呼び出されます。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ad4ce20803bf2d9ea3efb4e51b2111ecb76db405" translate="yes" xml:space="preserve">
          <source>If you want to iterate through an array or a list with an index, you can do it this way:</source>
          <target state="translated">インデックスを持つ配列やリストを反復処理したい場合は、このようにします。</target>
        </trans-unit>
        <trans-unit id="125c434fa84549730a675353dd139689f7b256f9" translate="yes" xml:space="preserve">
          <source>If you want to keep a whole package or module from elimination, you can use its fully qualified name as it appears in the generated JavaScript code.</source>
          <target state="translated">パッケージやモジュール全体を削除しないようにしたい場合は、生成された JavaScript コードに表示される完全修飾名を使うことができます。</target>
        </trans-unit>
        <trans-unit id="c6675875ca0e15a9e0e94e4e62bcc35aa2271753" translate="yes" xml:space="preserve">
          <source>If you want to keep your code compatible with the 1.0 standard library, you can pass &lt;code&gt;-api-version 1.0&lt;/code&gt;.</source>
          <target state="translated">コードを1.0標準ライブラリと互換性を維持したい場合は、 &lt;code&gt;-api-version 1.0&lt;/code&gt; を渡すことができます。</target>
        </trans-unit>
        <trans-unit id="a90f40cf003c1ca63835c4f5252dade99a0b6302" translate="yes" xml:space="preserve">
          <source>If you want to learn different Kotlin features, try &lt;a href=&quot;koans&quot;&gt;Kotlin Koans&lt;/a&gt;.</source>
          <target state="translated">Kotlinのさまざまな機能を学びたい場合は、&lt;a href=&quot;koans&quot;&gt;Kotlin Koansを&lt;/a&gt;試してください。</target>
        </trans-unit>
        <trans-unit id="00db4d51336388a60b35cfdb52f35a642fd46d81" translate="yes" xml:space="preserve">
          <source>If you want to look at the metadata of a function (e.g. its name), use &lt;code&gt;KFunction&amp;lt;V&amp;gt;&lt;/code&gt; or one of its subinterfaces, where &lt;code&gt;V&lt;/code&gt; is the function's return type. Here's a basic example:</source>
          <target state="translated">あなたは、関数のメタデータ（例えば、名前）、使用を見たい場合は &lt;code&gt;KFunction&amp;lt;V&amp;gt;&lt;/code&gt; またはそのサブインタフェースの1、 &lt;code&gt;V&lt;/code&gt; は、関数の戻り値の型です。基本的な例は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="1d1730df83789869c0eec8797d86c76b973936cd" translate="yes" xml:space="preserve">
          <source>If you want to restrict the set of subclasses of a base class, you can declare the base class to be &lt;code&gt;sealed&lt;/code&gt; (which also makes it abstract), in which case you can only declare subclasses in the same file. The compiler then knows the complete set of possible subclasses, which will let you do exhaustive &lt;code&gt;when&lt;/code&gt; expression for all the possible subtypes without the need for an &lt;code&gt;else&lt;/code&gt; clause (and if you add another subclass in the future and forget to update the &lt;code&gt;when&lt;/code&gt;, the compiler will let you know).</source>
          <target state="translated">基本クラスのサブクラスのセットを制限したい場合は、基本クラスを &lt;code&gt;sealed&lt;/code&gt; するように宣言できます（これにより抽象化もできます）。この場合、同じファイルでサブクラスのみを宣言できます。コンパイラーは次に、可能なサブクラスの完全なセットを認識します。これにより、 &lt;code&gt;else&lt;/code&gt; 節を必要とせずにすべての可能なサブタイプの &lt;code&gt;when&lt;/code&gt; 式を網羅的に実行できます（将来、別のサブクラスを追加して &lt;code&gt;when&lt;/code&gt; の更新を忘れた場合、コンパイラーお知らせします）。</target>
        </trans-unit>
        <trans-unit id="24aa907f13ca700b9ceeaa1262123234a9393fc1" translate="yes" xml:space="preserve">
          <source>If you want to see all available options run</source>
          <target state="translated">利用可能なオプションをすべて表示したい場合は、次のように実行してください。</target>
        </trans-unit>
        <trans-unit id="2d21aa936de4e7ff46724ca50ee4a418c4b5e521" translate="yes" xml:space="preserve">
          <source>If you want to see how your task will be look to the learner, right-click the &lt;code&gt;Task.kt&lt;/code&gt; file in the &lt;strong&gt;Project&lt;/strong&gt; tool window, and choose &lt;strong&gt;Course Creator -&amp;gt; Show Preview&lt;/strong&gt;:</source>
          <target state="translated">タスクが学習者にどのように見えるかを確認したい場合は、&lt;strong&gt;プロジェクト&lt;/strong&gt;ツールウィンドウで &lt;code&gt;Task.kt&lt;/code&gt; ファイルを右クリックし、&lt;strong&gt;コース作成者-&amp;gt;プレビューを表示&lt;/strong&gt;を選択します。&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="81dec7b57d1ae160cc859398f6b261d2b3f48fa4" translate="yes" xml:space="preserve">
          <source>If you want to specify a custom label for the link, use the Markdown reference-style syntax:</source>
          <target state="translated">リンクにカスタムラベルを指定したい場合は、Markdown参照スタイルの構文を使用します。</target>
        </trans-unit>
        <trans-unit id="e8b98cb29aff85793ce838953d8ec8871fe09a05" translate="yes" xml:space="preserve">
          <source>If you want to start from scratch with the task, use the &lt;strong&gt;Reset&lt;/strong&gt; icon at the top of &lt;strong&gt;Task Description&lt;/strong&gt; panel:</source>
          <target state="translated">タスクを最初から開始する場合は、&lt;strong&gt;タスクの説明&lt;/strong&gt;パネルの上部にある&lt;strong&gt;リセット&lt;/strong&gt;アイコンを使用します。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c377ee38e06516840389b0006f62da827c729d93" translate="yes" xml:space="preserve">
          <source>If you want to start using Kotlin for Android development, read &lt;a href=&quot;https://developer.android.com/kotlin/get-started&quot;&gt;Google&amp;rsquo;s recommendation for getting started with Kotlin on Android&lt;/a&gt;.</source>
          <target state="translated">Android開発でKotlinの使用を開始する場合は、AndroidでKotlinの使用を開始するための&lt;a href=&quot;https://developer.android.com/kotlin/get-started&quot;&gt;Googleの推奨事項をお&lt;/a&gt;読みください。</target>
        </trans-unit>
        <trans-unit id="ef089a53351dae0337ca675a4a633d10abb6eccf" translate="yes" xml:space="preserve">
          <source>If you want to use a value only if it satisfies a certain condition, try &lt;code&gt;takeIf()&lt;/code&gt;, which returns the value it's called on if it satisfies the given predicate, and null otherwise. There's also &lt;code&gt;takeUnless()&lt;/code&gt;, which inverts the logic. You can follow this with a &lt;code&gt;?.&lt;/code&gt; to perform an operation on the value only if it satisfies the predicate. Below, we compute the square of some expression, but only if the expression value is at least 42:</source>
          <target state="translated">特定の条件を満たす場合にのみ値を使用したい場合は、 &lt;code&gt;takeIf()&lt;/code&gt; を試してください。これは、指定された述部を満たす場合に呼び出された値を返し、それ以外の場合はnullを返します。ロジックを反転させる &lt;code&gt;takeUnless()&lt;/code&gt; もあります。これに &lt;code&gt;?.&lt;/code&gt; 付けることができます。述語を満たす場合にのみ、値に対して演算を実行します。以下では、式の2乗を計算しますが、式の値が少なくとも42の場合のみです。</target>
        </trans-unit>
        <trans-unit id="39803479c2452982a2bf2e4068e689f82660ee9c" translate="yes" xml:space="preserve">
          <source>If you want to use dependencies on local pods from Kotlin code, import the corresponding packages.</source>
          <target state="translated">Kotlinコードからローカルポッドへの依存関係を利用したい場合は、対応するパッケージをインポートします。</target>
        </trans-unit>
        <trans-unit id="be96354e6d849f99091812f51218336ab205ca9c" translate="yes" xml:space="preserve">
          <source>If you want to use the EduTools plugin for teaching, read &lt;a href=&quot;edu-tools-educator&quot;&gt;Teaching Kotlin with EduTools plugin&lt;/a&gt;.</source>
          <target state="translated">教育にEduToolsプラグインを使用する場合は、EduToolsプラグインを使用した&lt;a href=&quot;edu-tools-educator&quot;&gt;TeachingKotlinをお&lt;/a&gt;読みください。</target>
        </trans-unit>
        <trans-unit id="67fb2febabe66895070c2641c4d6f978cdb57747" translate="yes" xml:space="preserve">
          <source>If you want to use the EduTools plugin to learn Kotlin, read &lt;a href=&quot;edu-tools-learner&quot;&gt;Learning Kotlin with EduTools plugin&lt;/a&gt;.</source>
          <target state="translated">EduToolsプラグインを使用してKotlinを学習する場合は、EduToolsプラグインを使用したKotlinの&lt;a href=&quot;edu-tools-learner&quot;&gt;学習をお&lt;/a&gt;読みください。</target>
        </trans-unit>
        <trans-unit id="87bc643ce85513f6868cb2e9de9823d1f4369259" translate="yes" xml:space="preserve">
          <source>If you want to write strings gradually, you need to create an &lt;code&gt;OutputStreamWriter&lt;/code&gt; by calling &lt;code&gt;writer()&lt;/code&gt; on the file object. You can write binary data to a file by calling &lt;code&gt;outputStream()&lt;/code&gt; on a file object and use the resulting &lt;code&gt;OutputStream&lt;/code&gt; to write bytes.</source>
          <target state="translated">文字列を徐々に書き込む場合は、ファイルオブジェクトで &lt;code&gt;writer()&lt;/code&gt; を呼び出して、 &lt;code&gt;OutputStreamWriter&lt;/code&gt; を作成する必要があります。ファイルオブジェクトで &lt;code&gt;outputStream()&lt;/code&gt; を呼び出してバイナリデータをファイルに書き込み、結果の &lt;code&gt;OutputStream&lt;/code&gt; を使用してバイトを書き込むことができます。</target>
        </trans-unit>
        <trans-unit id="a41befb145b42cbf8131f21728e484a8a91115d2" translate="yes" xml:space="preserve">
          <source>If you write the same without &lt;code&gt;let&lt;/code&gt;, you'll have to introduce a new variable and repeat its name whenever you use it.</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; なしで同じものを書く場合、新しい変数を導入し、使用するたびにその名前を繰り返す必要があります。</target>
        </trans-unit>
        <trans-unit id="0a3aaf1f9dd9fea6023de83a437602a5eadebf5e" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re on Ubuntu 16.04 or later, you can install the compiler from the command line:</source>
          <target state="translated">Ubuntu 16.04以降を使用している場合は、コマンドラインからコンパイラをインストールできます。</target>
        </trans-unit>
        <trans-unit id="4ef3b492d472d99a86a122fa8edba6106fbe3c08" translate="yes" xml:space="preserve">
          <source>If you'd rather do &lt;code&gt;x.unsigned&lt;/code&gt;, you can define an extension property:</source>
          <target state="translated">あなたはむしろないと思います場合 &lt;code&gt;x.unsigned&lt;/code&gt; 、あなたは拡張プロパティを定義することができます。</target>
        </trans-unit>
        <trans-unit id="07dd95cbbfcdccfc3f0d530d8306040139f15ae7" translate="yes" xml:space="preserve">
          <source>If you're a &lt;a href=&quot;https://www.macports.org/&quot;&gt;MacPorts&lt;/a&gt; user, you can install the compiler with:</source>
          <target state="translated">あなたがいる場合は&lt;a href=&quot;https://www.macports.org/&quot;&gt;MacPortsのの&lt;/a&gt;ユーザー、あなたがコンパイラをインストールすることができます。</target>
        </trans-unit>
        <trans-unit id="0509d81eee59f0e681a0c3f0c84d5a54a79b4f26" translate="yes" xml:space="preserve">
          <source>If you're developing a library to be used by other Kotlin applications, you can build the &lt;em&gt;.jar&lt;/em&gt; file without including the Kotlin runtime into it.</source>
          <target state="translated">他のKotlinアプリケーションで使用するライブラリを開発している場合は、Kotlinランタイムを含めずに&lt;em&gt;.jar&lt;/em&gt;ファイルをビルドできます。</target>
        </trans-unit>
        <trans-unit id="368782cf6eaff197b952127bcc0c0565b3479378" translate="yes" xml:space="preserve">
          <source>If you're developing a library to be used by other Kotlin applications, you can produce the .jar file without including the Kotlin runtime into it.</source>
          <target state="translated">他のKotlinアプリケーションで使用するライブラリを開発している場合は、Kotlinランタイムを含まずに.jarファイルを作成することができます。</target>
        </trans-unit>
        <trans-unit id="9da5d517a7b5384e2a44811f79965cdbfc0afba2" translate="yes" xml:space="preserve">
          <source>If you're new to Android and want to learn to create applications with Kotlin, check out &lt;a href=&quot;https://www.udacity.com/course/developing-android-apps-with-kotlin--ud9012&quot;&gt;this Udacity course&lt;/a&gt;.</source>
          <target state="translated">Androidを初めて使用し、Kotlinを使用してアプリケーションを作成する方法を学びたい場合は、&lt;a href=&quot;https://www.udacity.com/course/developing-android-apps-with-kotlin--ud9012&quot;&gt;このUdacityコースを&lt;/a&gt;確認してください。</target>
        </trans-unit>
        <trans-unit id="f128e1fe8c8eb81ea54217b5ba66f82b1c59b061" translate="yes" xml:space="preserve">
          <source>If you're new to Kotlin, a good first step would be to familiarise yourself with the &lt;a href=&quot;basic-syntax&quot;&gt;Basic Syntax&lt;/a&gt; of the language.</source>
          <target state="translated">Kotlinを初めて使用する場合、最初のステップとして、言語の&lt;a href=&quot;basic-syntax&quot;&gt;基本構文&lt;/a&gt;を理解することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="766f702953f8980e6bc50e185cc1d656f34dfbc1" translate="yes" xml:space="preserve">
          <source>If you're targeting JDK 7 or JDK 8, you can use extended versions of the Kotlin standard library which contain additional extension functions for APIs added in new JDK versions. Instead of &lt;code&gt;kotlin-stdlib&lt;/code&gt;, use &lt;code&gt;kotlin-stdlib-jdk7&lt;/code&gt; or &lt;code&gt;kotlin-stdlib-jdk8&lt;/code&gt;, depending on your JDK version (for Kotlin 1.1.x use &lt;code&gt;kotlin-stdlib-jre7&lt;/code&gt; and &lt;code&gt;kotlin-stdlib-jre8&lt;/code&gt; as the &lt;code&gt;jdk&lt;/code&gt; counterparts were introduced in 1.2.0).</source>
          <target state="translated">JDK 7またはJDK 8を対象としている場合は、新しいJDKバージョンで追加されたAPIの追加の拡張関数を含むKotlin標準ライブラリの拡張バージョンを使用できます。代わりに &lt;code&gt;kotlin-stdlib&lt;/code&gt; 、使用 &lt;code&gt;kotlin-stdlib-jdk7&lt;/code&gt; または &lt;code&gt;kotlin-stdlib-jdk8&lt;/code&gt; （お使いのJDKのバージョンに応じて、Kotlin 1.1.xの使用を &lt;code&gt;kotlin-stdlib-jre7&lt;/code&gt; と &lt;code&gt;kotlin-stdlib-jre8&lt;/code&gt; として &lt;code&gt;jdk&lt;/code&gt; のカウンターパートは1.2で導入されました.0）。</target>
        </trans-unit>
        <trans-unit id="b775395194955c271aef49dac84498fbe90d7450" translate="yes" xml:space="preserve">
          <source>If you're targeting the JVM platform, you can also use Java's reflection system directly. In this example, we grab a function reference from an object's class by specifying the function's name as a string (if the function takes parameters, you also need to specify their types), and then we call it. Note that we didn't mention &lt;code&gt;String&lt;/code&gt; anywhere - this technique works without knowing what the object's class is, but it will raise an exception if the object's class doesn't have the requested function. However, Java-style function references do not have type information, so you won't get verification of the parameter types, and you must cast the return value:</source>
          <target state="translated">JVMプラットフォームをターゲットにしている場合は、Javaのリフレクションシステムを直接使用することもできます。この例では、関数の名前を文字列として指定してオブジェクトのクラスから関数参照を取得し（関数がパラメーターを取る場合は、その型も指定する必要があります）、それを呼び出します。 &lt;code&gt;String&lt;/code&gt; についてはどこにも触れなかったことに注意してください。この手法はオブジェクトのクラスが何であるかを知らなくても機能しますが、オブジェクトのクラスに要求された関数がない場合は例外が発生します。ただし、Javaスタイルの関数参照には型情報がないため、パラメーターの型の検証は行われず、戻り値をキャストする必要があります。</target>
        </trans-unit>
        <trans-unit id="3a761f12674bd3c30efe00ec7ea6eb2be1927a55" translate="yes" xml:space="preserve">
          <source>If you're targeting the browser and want to use a different module system than UMD, you can specify the desired module type in the &lt;code&gt;webpackTask&lt;/code&gt; configuration block. For example, to switch to CommonJS, use:</source>
          <target state="translated">ブラウザを対象としていて、UMDとは異なるモジュールシステムを使用する場合は、 &lt;code&gt;webpackTask&lt;/code&gt; 構成ブロックで目的のモジュールタイプを指定できます。たとえば、CommonJSに切り替えるには、次を使用します。</target>
        </trans-unit>
        <trans-unit id="5d2933676dc2f7e28b956599b006e00954f9395f" translate="yes" xml:space="preserve">
          <source>If you're using &lt;em&gt;if&lt;/em&gt; as an expression rather than a statement (for example, returning its value or assigning it to a variable), the expression is required to have an &lt;code&gt;else&lt;/code&gt; branch.</source>
          <target state="translated">ステートメントではなく式として&lt;em&gt;if&lt;/em&gt;を使用している&lt;em&gt;場合&lt;/em&gt;（たとえば、その値を返す、または変数に割り当てる）、式には &lt;code&gt;else&lt;/code&gt; 分岐が必要です。</target>
        </trans-unit>
        <trans-unit id="51fc2cadbf8df70dee87fb5d749d2ee884d218b0" translate="yes" xml:space="preserve">
          <source>If you're using a generic class whose type parameters haven't been declared in a variant way (either because its authors didn't think of it, or because the type parameters can't have either variance kind because they are used both as parameter types and return types), you can still use it in a variant way thanks to &lt;em&gt;type projection&lt;/em&gt;. The term &quot;projection&quot; refers to the fact that when you do this, you might restrict yourself to using only some of its members - so you're in a sense only seeing a partial, or &quot;projected&quot; version of the class. Let's look again at our &lt;code&gt;Bowl&lt;/code&gt; class, but without the variant interfaces this time:</source>
          <target state="translated">型パラメーターがさまざまな方法で宣言されていないジェネリッククラスを使用している場合（その作成者がそれを考慮していなかったため、または型パラメーターが両方として使用されているため、型パラメーターに分散の種類を指定できないため）パラメータ型と戻り値型）、&lt;em&gt;型プロジェクションの&lt;/em&gt;おかげで、まださまざまな方法で使用できます。 「プロジェクション」という用語は、これを行うと、一部のメンバーのみを使用するように制限する場合があるという事実を意味します。つまり、ある意味では、クラスの部分バージョンまたは「プロジェクション」バージョンのみが表示されます。もう一度、 &lt;code&gt;Bowl&lt;/code&gt; クラスを見てみましょう。ただし、今回はバリアントインターフェイスはありません。</target>
        </trans-unit>
        <trans-unit id="f6e51da97890d2ae9ab3d189065498b378cc4fb2" translate="yes" xml:space="preserve">
          <source>If you've got one string that you want to write to a file, overwriting the existing contents if the file already exists, do this (again, UTF-8 is the default encoding):</source>
          <target state="translated">ファイルに書き込みたい文字列が1つある場合、ファイルがすでに存在する場合は既存の内容を上書きして、このようにします (ここでもデフォルトのエンコーディングは UTF-8 です)。</target>
        </trans-unit>
        <trans-unit id="d91079d5275bf77f335cf6cb84c315d0b54d9ee8" translate="yes" xml:space="preserve">
          <source>If you've just upgraded to Kotlin 1.1 but can not use new language features yet (e.g. because some of your teammates may not have upgraded), you can pass &lt;code&gt;-language-version 1.0&lt;/code&gt;, which will restrict all APIs and language features to 1.0.</source>
          <target state="translated">Kotlin 1.1にアップグレードしたばかりで、まだ新しい言語機能を使用できない場合（たとえば、チームメートの一部がアップグレードしていない可能性があるため）、 &lt;code&gt;-language-version 1.0&lt;/code&gt; を渡すと、すべてのAPIと言語機能が1.0に制限されます。</target>
        </trans-unit>
        <trans-unit id="6a4d49a0aa58db91f5538f1484a110d84d269171" translate="yes" xml:space="preserve">
          <source>If your application already uses DBFlow, you can safely introduce Kotlin into your project. You can gradually convert existing code to Kotlin (ensuring that everything compiles along the way). The converted code doesn't differ much from Java. For instance, declaring a table looks similar to Java with the small difference that default values for properties must be specified explicitly:</source>
          <target state="translated">もしあなたのアプリケーションが既に DBFlow を使用しているのであれば、Kotlin をプロジェクトに安全に導入することができます。既存のコードを徐々にKotlinに変換していくことができます(途中ですべてのコードがコンパイルされることを確認してください)。変換されたコードはJavaとあまり変わりません。例えば、テーブルの宣言は Java と似ていますが、プロパティのデフォルト値を明示的に指定しなければならないという小さな違いがあります。</target>
        </trans-unit>
        <trans-unit id="f63962aa6cf85ec6f47c280bebab4a954c284cd2" translate="yes" xml:space="preserve">
          <source>If your class requires more advanced serialization logic, write it inside a companion class:</source>
          <target state="translated">クラスでより高度なシリアライズ・ロジックが必要な場合は、コンパニオン・クラスの中に記述します。</target>
        </trans-unit>
        <trans-unit id="3503de21b9cb0b7cba965dc4634f2918727f903d" translate="yes" xml:space="preserve">
          <source>If your class requires more advanced serialization logic, you can write it inside a companion class:</source>
          <target state="translated">クラスでより高度なシリアライズロジックが必要な場合は、コンパニオンクラスの中に書くことができます。</target>
        </trans-unit>
        <trans-unit id="eacc53066a886e6486df3248d96a52d89fd95863" translate="yes" xml:space="preserve">
          <source>If your code is too clever for the compiler, and you know without the help of &lt;code&gt;is&lt;/code&gt; that &lt;code&gt;x&lt;/code&gt; is an instance of &lt;code&gt;Person&lt;/code&gt; but the compiler doesn't, you can &lt;em&gt;cast&lt;/em&gt; your value with &lt;code&gt;as&lt;/code&gt;:</source>
          <target state="translated">あなたのコードは、コンパイラのためにあまりにも巧妙で、そしてあなたがの助けなし知っている場合 &lt;code&gt;is&lt;/code&gt; ことを &lt;code&gt;x&lt;/code&gt; のインスタンスである &lt;code&gt;Person&lt;/code&gt; しかし、コンパイラは、次のことができていない&lt;em&gt;キャスト&lt;/em&gt;を使用して値を &lt;code&gt;as&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="2ecf8bd14ee3aa94f5fa13c2b5cd616c3b320e5a" translate="yes" xml:space="preserve">
          <source>If your project uses &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.reflect.full/index&quot;&gt;Kotlin reflection&lt;/a&gt; or testing facilities, you need to add the corresponding dependencies as well. The artifact IDs are &lt;code&gt;kotlin-reflect&lt;/code&gt; for the reflection library, and &lt;code&gt;kotlin-test&lt;/code&gt; and &lt;code&gt;kotlin-test-junit&lt;/code&gt; for the testing libraries.</source>
          <target state="translated">プロジェクトで&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.reflect.full/index&quot;&gt;Kotlinリフレクション&lt;/a&gt;またはテスト機能を使用している場合は、対応する依存関係も追加する必要があります。アーティファクトIDは、リフレクションライブラリの場合は &lt;code&gt;kotlin-reflect&lt;/code&gt; 、テストライブラリの場合は &lt;code&gt;kotlin-test&lt;/code&gt; および &lt;code&gt;kotlin-test-junit&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="aaffb39c3271a99cd3c6b1dcd26285bb7f6d4133" translate="yes" xml:space="preserve">
          <source>If your project uses &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.reflect.full/index&quot;&gt;Kotlin reflection&lt;/a&gt; or testing facilities, you need to add the corresponding dependencies as well:</source>
          <target state="translated">プロジェクトで&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.reflect.full/index&quot;&gt;Kotlinリフレクション&lt;/a&gt;またはテスト機能を使用している場合は、対応する依存関係も追加する必要があります。</target>
        </trans-unit>
        <trans-unit id="ff4ecabd35e3e545f9518b5b102d6fa77c32607a" translate="yes" xml:space="preserve">
          <source>If, by any chance, we need &quot;just an object&quot;, with no nontrivial supertypes, we can simply say:</source>
          <target state="translated">ひょっとして、非自明なスーパータイプを持たない「ただのオブジェクト」が必要な場合は、単純に言えば、「ただのオブジェクト」と言えます。</target>
        </trans-unit>
        <trans-unit id="f78ba0d5d02014df85f65107c7688ad5093fc4b0" translate="yes" xml:space="preserve">
          <source>If, upon updating from one version to another, some code that used to work doesn't work any more, it is an &lt;em&gt;incompatible change&lt;/em&gt; in the language (sometimes referred to as &quot;breaking change&quot;). There can be debates as to what &quot;doesn't work any more&quot; means precisely in some cases, but it definitely includes the following:</source>
          <target state="translated">あるバージョンから別のバージョンに更新したときに、以前は機能していた一部のコードが機能しなくなった場合、それは言語の&lt;em&gt;互換性のない変更&lt;/em&gt;です（「重大な変更」と呼ばれることもあります）。 「これ以上機能しない」が何を意味するのかについては、場合によっては正確に論争がある可能性がありますが、これには間違いなく以下が含まれます。</target>
        </trans-unit>
        <trans-unit id="ea0b39c7ffc510626fe28212437d8a57285e5a4c" translate="yes" xml:space="preserve">
          <source>IllegalArgumentException</source>
          <target state="translated">IllegalArgumentException</target>
        </trans-unit>
        <trans-unit id="906f0c92cf03edbafe4a5d12e37d92701ba25962" translate="yes" xml:space="preserve">
          <source>IllegalCallableAccessException</source>
          <target state="translated">IllegalCallableAccessException</target>
        </trans-unit>
        <trans-unit id="6bfee05d69b5aa826fde5d373d8ebea121200b58" translate="yes" xml:space="preserve">
          <source>IllegalCharacterConversionException</source>
          <target state="translated">IllegalCharacterConversionException</target>
        </trans-unit>
        <trans-unit id="6d13e3edbafba5c6ba6e57ae6bc8267296d1bf66" translate="yes" xml:space="preserve">
          <source>IllegalPropertyDelegateAccessException</source>
          <target state="translated">IllegalPropertyDelegateAccessException</target>
        </trans-unit>
        <trans-unit id="63b3abc14a5b2c9db143083b94887cb72910c4de" translate="yes" xml:space="preserve">
          <source>IllegalStateException</source>
          <target state="translated">IllegalStateException</target>
        </trans-unit>
        <trans-unit id="0ef9de975cdef9d9d9b896b68103ad59db30e33a" translate="yes" xml:space="preserve">
          <source>ImageBitmap</source>
          <target state="translated">ImageBitmap</target>
        </trans-unit>
        <trans-unit id="33f05a29887232f2adef5f1b64b04d6cf8bd78f2" translate="yes" xml:space="preserve">
          <source>ImageBitmapOptions</source>
          <target state="translated">ImageBitmapOptions</target>
        </trans-unit>
        <trans-unit id="91a39bdc5a33f203d5c2f138f0da931369fac84f" translate="yes" xml:space="preserve">
          <source>ImageBitmapRenderingContext</source>
          <target state="translated">ImageBitmapRenderingContext</target>
        </trans-unit>
        <trans-unit id="1a722437bfbd0c07b7f837b5b4332fd5d966ead2" translate="yes" xml:space="preserve">
          <source>ImageBitmapRenderingContextSettings</source>
          <target state="translated">ImageBitmapRenderingContextSettings</target>
        </trans-unit>
        <trans-unit id="b28af413c72a2e03556905d9b27766a80ae5dd7b" translate="yes" xml:space="preserve">
          <source>ImageBitmapSource</source>
          <target state="translated">ImageBitmapSource</target>
        </trans-unit>
        <trans-unit id="682b65e19d67a5e783299b757e21bec2832c6fb5" translate="yes" xml:space="preserve">
          <source>ImageData</source>
          <target state="translated">ImageData</target>
        </trans-unit>
        <trans-unit id="2217055c382ca08984df9c834dee428b5ed7c541" translate="yes" xml:space="preserve">
          <source>ImageOrientation</source>
          <target state="translated">ImageOrientation</target>
        </trans-unit>
        <trans-unit id="3394b71415cd8bd55fc9255b5d6beaf734d6f770" translate="yes" xml:space="preserve">
          <source>ImageSmoothingQuality</source>
          <target state="translated">ImageSmoothingQuality</target>
        </trans-unit>
        <trans-unit id="f98fd49f8f974a3886c42cb3693e5ffdf40539ee" translate="yes" xml:space="preserve">
          <source>Immediate superclasses of this class, in the order they are listed in the source code. Includes superclasses and superinterfaces of the class, but does not include the class itself.</source>
          <target state="translated">このクラスの即時のスーパークラスを、ソース・コードに記載されている順に示します。このクラスのスーパークラスとスーパーインターフェースを含みますが、クラス自体は含まれません。</target>
        </trans-unit>
        <trans-unit id="70af22099196223b8485c95684bbf8824a9afa2b" translate="yes" xml:space="preserve">
          <source>Immutability</source>
          <target state="translated">Immutability</target>
        </trans-unit>
        <trans-unit id="bb86d1b762a23d9068f4510901eeff7d18242638" translate="yes" xml:space="preserve">
          <source>Immutability in Kotlin/Native</source>
          <target state="translated">コトリン/ネイティブの不変性</target>
        </trans-unit>
        <trans-unit id="7f8782e7a667262dd5095f5ff184ddd709f4772b" translate="yes" xml:space="preserve">
          <source>Immutability is a runtime property in Kotlin/Native, and can be applied to an arbitrary object subgraph using the &lt;code&gt;kotlin.native.concurrent.freeze&lt;/code&gt; function. It makes all the objects reachable from the given one immutable, such a transition is a one-way operation (i.e., objects cannot be unfrozen later). Some naturally immutable objects such as &lt;code&gt;kotlin.String&lt;/code&gt;, &lt;code&gt;kotlin.Int&lt;/code&gt;, and other primitive types, along with &lt;code&gt;AtomicInt&lt;/code&gt; and &lt;code&gt;AtomicReference&lt;/code&gt; are frozen by default. If a mutating operation is applied to a frozen object, an &lt;code&gt;InvalidMutabilityException&lt;/code&gt; is thrown.</source>
          <target state="translated">不変性はKotlin / Nativeのランタイムプロパティであり、 &lt;code&gt;kotlin.native.concurrent.freeze&lt;/code&gt; 関数を使用して任意のオブジェクトサブグラフに適用できます。指定された1つの不変オブジェクトからすべてのオブジェクトに到達可能にします。このような遷移は一方向の操作です（つまり、オブジェクトを後でフリーズ解除することはできません）。 &lt;code&gt;kotlin.String&lt;/code&gt; 、 &lt;code&gt;kotlin.Int&lt;/code&gt; 、およびその他のプリミティブ型などの一部の自然に不変のオブジェクトは、 &lt;code&gt;AtomicInt&lt;/code&gt; および &lt;code&gt;AtomicReference&lt;/code&gt; とともに、デフォルトでフリーズされています。変更された操作がフリーズされたオブジェクトに適用されると、 &lt;code&gt;InvalidMutabilityException&lt;/code&gt; がスローされます。</target>
        </trans-unit>
        <trans-unit id="ed22a68de3c3f3cb15e1268df39db4a167fd746d" translate="yes" xml:space="preserve">
          <source>ImmutableBlob</source>
          <target state="translated">ImmutableBlob</target>
        </trans-unit>
        <trans-unit id="ee7341a728a58d68c7532bf18aeb0fac4452b6b5" translate="yes" xml:space="preserve">
          <source>Implementation by Delegation</source>
          <target state="translated">委任による実施</target>
        </trans-unit>
        <trans-unit id="dc1735ad8ce42355f885445d5ba551e409b9c86b" translate="yes" xml:space="preserve">
          <source>Implementations of the interface can override default methods.</source>
          <target state="translated">インターフェースの実装は、デフォルトのメソッドをオーバーライドすることができます。</target>
        </trans-unit>
        <trans-unit id="00d5f96768fee4f4899fb4ea94381d1c87db0a66" translate="yes" xml:space="preserve">
          <source>Implementing Interfaces</source>
          <target state="translated">インターフェースの実装</target>
        </trans-unit>
        <trans-unit id="d640e1d5eb2b7a283f3bc3070dd151afc512fb6c" translate="yes" xml:space="preserve">
          <source>Implementing Interfaces in Enum Classes</source>
          <target state="translated">Enum クラスでのインターフェイスの実装</target>
        </trans-unit>
        <trans-unit id="b2153d6fa67762548da1f8fe28f3d481ede48834" translate="yes" xml:space="preserve">
          <source>Implements the core logic of a property delegate for a read/write property that calls callback functions when changed.</source>
          <target state="translated">変更されたときにコールバック関数を呼び出す読み書きプロパティのデリゲートのコア・ロジックを実装します。</target>
        </trans-unit>
        <trans-unit id="b1af49118602d4ab9bd26831d35fc303f95ea13f" translate="yes" xml:space="preserve">
          <source>Implicit &lt;code&gt;this&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; 暗示する</target>
        </trans-unit>
        <trans-unit id="febd7a841f47bb67cef7b18f13ac806c637192b6" translate="yes" xml:space="preserve">
          <source>Important: files marked with &lt;code&gt;@file:JsModule&lt;/code&gt; annotation can't declare non-external members. The example below produces compile-time error:</source>
          <target state="translated">重要： &lt;code&gt;@file:JsModule&lt;/code&gt; アノテーションが付けられたファイルは、非外部メンバーを宣言できません。次の例では、コンパイル時エラーが発生します。</target>
        </trans-unit>
        <trans-unit id="e45479a7a7959d4875b5ea4acddae533ace5e782" translate="yes" xml:space="preserve">
          <source>Importing deeper package hierarchies</source>
          <target state="translated">より深いパッケージ階層のインポート</target>
        </trans-unit>
        <trans-unit id="a932c1ce87f097109d85ae710ba5975b2888a20e" translate="yes" xml:space="preserve">
          <source>Importing synthetic properties</source>
          <target state="translated">合成プロパティのインポート</target>
        </trans-unit>
        <trans-unit id="e42328ac01cd03a47978f064c93b392caf3861f0" translate="yes" xml:space="preserve">
          <source>Imports</source>
          <target state="translated">Imports</target>
        </trans-unit>
        <trans-unit id="513df22c9887b1f085e00ef3b729d3f007cfd9d9" translate="yes" xml:space="preserve">
          <source>Improved import handling</source>
          <target state="translated">インポート処理の改善</target>
        </trans-unit>
        <trans-unit id="d8972a1f28a588591d73ee09ddd836428eaca222" translate="yes" xml:space="preserve">
          <source>Improving smartcasts analysis by declaring the relation between a function's call outcome and the passed arguments values:</source>
          <target state="translated">関数の呼び出し結果と渡された引数の値の関係を宣言することで、スマートキャストの解析を改善します。</target>
        </trans-unit>
        <trans-unit id="3ea84fc4dca92bbd95cba0393e768bc0dbac665a" translate="yes" xml:space="preserve">
          <source>Improving the variable initialization analysis in the presence of high-order functions:</source>
          <target state="translated">高次関数の存在下での変数初期化解析の改善</target>
        </trans-unit>
        <trans-unit id="1a9aa64fd2cf728e6a54a37ad269e224c4406ae7" translate="yes" xml:space="preserve">
          <source>In &quot;clever words&quot; they say that the class &lt;code&gt;C&lt;/code&gt; is &lt;strong&gt;covariant&lt;/strong&gt; in the parameter &lt;code&gt;T&lt;/code&gt;, or that &lt;code&gt;T&lt;/code&gt; is a &lt;strong&gt;covariant&lt;/strong&gt; type parameter. You can think of &lt;code&gt;C&lt;/code&gt; as being a &lt;strong&gt;producer&lt;/strong&gt; of &lt;code&gt;T&lt;/code&gt;'s, and NOT a &lt;strong&gt;consumer&lt;/strong&gt; of &lt;code&gt;T&lt;/code&gt;'s.</source>
          <target state="translated">「賢い言葉」では、クラス &lt;code&gt;C&lt;/code&gt; はパラメーター &lt;code&gt;T&lt;/code&gt; で&lt;strong&gt;共変&lt;/strong&gt;である、または &lt;code&gt;T&lt;/code&gt; は&lt;strong&gt;共変型&lt;/strong&gt;パラメーターであると述べています。あなたは考えることができます &lt;code&gt;C&lt;/code&gt; として&lt;strong&gt;プロデューサー&lt;/strong&gt;の &lt;code&gt;T&lt;/code&gt; さん、およびNOT &lt;strong&gt;消費者&lt;/strong&gt;の &lt;code&gt;T&lt;/code&gt; さん。&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6019b82a793e669523c1435271b5d51f4ccb4ffc" translate="yes" xml:space="preserve">
          <source>In 1.3 we reworked the entire multiplatform model. The &lt;a href=&quot;building-mpp-with-gradle&quot;&gt;new DSL&lt;/a&gt; we have for describing multiplatform Gradle projects is much more flexible, and we'll keep working on it to make project configuration straightforward.</source>
          <target state="translated">1.3では、マルチプラットフォームモデル全体を作り直しました。&lt;a href=&quot;building-mpp-with-gradle&quot;&gt;新しいDSL&lt;/a&gt;マルチGradleのプロジェクトを記述するため、我々は持っているがはるかに柔軟であり、我々は、プロジェクトの設定は簡単に作ってそれに取り組んでおこう。</target>
        </trans-unit>
        <trans-unit id="08f9bdd95bef61c2c357a6e138e1e9a913682812" translate="yes" xml:space="preserve">
          <source>In 1.3, we've completely reworked the model of multiplatform projects in order to improve expressiveness and flexibility, and to make sharing common code easier. Also, Kotlin/Native is now supported as one of the targets!</source>
          <target state="translated">1.3では、表現力と柔軟性を向上させ、共通のコードを共有しやすくするために、マルチプラットフォームプロジェクトのモデルを完全に作り直しました。また、Kotlin/Native がターゲットの一つとしてサポートされるようになりました。</target>
        </trans-unit>
        <trans-unit id="5745802255877abfa046b72cbccdadc8221d5622" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;collection-ordering&quot;&gt;Collection Ordering&lt;/a&gt;, we describe operations that retrieve collection elements in specific orders. For mutable lists, the standard library offers similar extension functions that perform the same ordering operations in place. When you apply such an operation to a list instance, it changes the order of elements in that exact instance.</source>
          <target state="translated">で&lt;a href=&quot;collection-ordering&quot;&gt;コレクションの注文&lt;/a&gt;、我々は特定の順序でコレクション要素を取得する操作について説明します。可変リストの場合、標準ライブラリは、同じ順序付け操作を実行する同様の拡張関数を提供します。このような操作をリストインスタンスに適用すると、その正確なインスタンス内の要素の順序が変更されます。</target>
        </trans-unit>
        <trans-unit id="be8a31aea4fdca8e3b9bdedb1958918e98cae1d2" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;collections-overview#map&quot;&gt;maps&lt;/a&gt;, types of both keys and values are user-defined. Key-based access to map entries enables various map-specific processing capabilities from getting a value by key to separate filtering of keys and values. On this page, we provide descriptions of the map processing functions from the standard library.</source>
          <target state="translated">では&lt;a href=&quot;collections-overview#map&quot;&gt;マップ&lt;/a&gt;、キーと値の両方のタイプは、ユーザが定義しています。マップエントリへのキーベースのアクセスにより、キーごとの値の取得から、キーと値のフィルタリングの分離まで、さまざまなマップ固有の処理機能が可能になります。このページでは、標準ライブラリのマップ処理関数について説明します。</target>
        </trans-unit>
        <trans-unit id="7454358e40f9eaf26ccc7cd55f4c30f555918de5" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;mapping-primitive-data-types-from-c&quot;&gt;the previous tutorial&lt;/a&gt; we created a &lt;code&gt;lib.h&lt;/code&gt; file. This time, we are going to include those declarations directly into the &lt;code&gt;interop.def&lt;/code&gt; file, after the &lt;code&gt;---&lt;/code&gt; separator line:</source>
          <target state="translated">で&lt;a href=&quot;mapping-primitive-data-types-from-c&quot;&gt;前のチュートリアル&lt;/a&gt;、我々は、作成 &lt;code&gt;lib.h&lt;/code&gt; ファイルを。今回は、それらの宣言を &lt;code&gt;interop.def&lt;/code&gt; ファイルの &lt;code&gt;---&lt;/code&gt; セパレータ行の後に直接含めます。</target>
        </trans-unit>
        <trans-unit id="f0454a21172602b262219293f4778fc730c2daf2" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;build.gradle.kts&lt;/code&gt; (or &lt;code&gt;build.gradle&lt;/code&gt;) of your IDEA project, apply the CocoaPods plugin as well as the Kotlin Multiplatform plugin.</source>
          <target state="translated">で &lt;code&gt;build.gradle.kts&lt;/code&gt; （または &lt;code&gt;build.gradle&lt;/code&gt; あなたIDEAプロジェクトの）、プラグインCocoaPodsだけでなく、Kotlinマルチプラグインを適用します。</target>
        </trans-unit>
        <trans-unit id="4f2d8d96fc34753484a87526254e4a4f003f9c05" translate="yes" xml:space="preserve">
          <source>In Android projects, additional Kotlin source sets are created for each &lt;a href=&quot;https://developer.android.com/studio/build/#sourcesets&quot;&gt;Android source set&lt;/a&gt;. If the Android target has a name &lt;code&gt;foo&lt;/code&gt;, the Android source set &lt;code&gt;bar&lt;/code&gt; gets a Kotlin source set counterpart &lt;code&gt;fooBar&lt;/code&gt;. The Kotlin compilations, however, are able to consume Kotlin sources from all of the directories &lt;code&gt;src/bar/java&lt;/code&gt;, &lt;code&gt;src/bar/kotlin&lt;/code&gt;, and &lt;code&gt;src/fooBar/kotlin&lt;/code&gt;. Java sources are only read from the first of these directories.</source>
          <target state="translated">Androidプロジェクトでは、&lt;a href=&quot;https://developer.android.com/studio/build/#sourcesets&quot;&gt;Androidソースセット&lt;/a&gt;ごとに追加のKotlinソースセットが作成されます。 Androidターゲットの名前が &lt;code&gt;foo&lt;/code&gt; の場合、Androidソースセット &lt;code&gt;bar&lt;/code&gt; はKotlinソースセットの対応する &lt;code&gt;fooBar&lt;/code&gt; を取得します。ただし、Kotlinのコンパイルでは、 &lt;code&gt;src/bar/java&lt;/code&gt; 、 &lt;code&gt;src/bar/kotlin&lt;/code&gt; 、および &lt;code&gt;src/fooBar/kotlin&lt;/code&gt; のすべてのディレクトリからKotlinソースを利用できます。 Javaソースは、これらのディレクトリの最初からのみ読み取られます。</target>
        </trans-unit>
        <trans-unit id="33342ff8fe9e060731185ad7c136d99b9461055f" translate="yes" xml:space="preserve">
          <source>In Gradle</source>
          <target state="translated">グラドルでは</target>
        </trans-unit>
        <trans-unit id="9ffad76a20436e6770075c18f7fc5a623588a28f" translate="yes" xml:space="preserve">
          <source>In Gradle 5.3 and above, the module metadata is always used during dependency resolution, but publications don't include any module metadata by default. To enable module metadata publishing, add &lt;code&gt;enableFeaturePreview(&quot;GRADLE_METADATA&quot;)&lt;/code&gt; to the root project's &lt;code&gt;settings.gradle&lt;/code&gt; file. With older Gradle versions, this is also required for module metadata consumption.</source>
          <target state="translated">Gradle 5.3以降では、依存関係の解決中にモジュールメタデータが常に使用されますが、パブリケーションにはデフォルトでモジュールメタデータが含まれていません。モジュールのメタデータの公開を有効にするには、ルートプロジェクトの &lt;code&gt;settings.gradle&lt;/code&gt; ファイルに &lt;code&gt;enableFeaturePreview(&quot;GRADLE_METADATA&quot;)&lt;/code&gt; を追加します。古いGradleバージョンでは、これはモジュールメタデータの消費にも必要です。</target>
        </trans-unit>
        <trans-unit id="db8d93f584f6cd9be9c19cceb09290c42348f8b6" translate="yes" xml:space="preserve">
          <source>In Gradle command line parameters: add the parameter &lt;code&gt;-Pkotlin.incremental&lt;/code&gt; or &lt;code&gt;-Pkotlin.incremental.js&lt;/code&gt; with the boolean value reflecting the usage of incremental compilation. Note that in this case the parameter should be added to each subsequent build, and any build with disabled incremental compilation invalidates incremental caches.</source>
          <target state="translated">Gradleコマンドラインパラメータで、パラメータ &lt;code&gt;-Pkotlin.incremental&lt;/code&gt; または &lt;code&gt;-Pkotlin.incremental.js&lt;/code&gt; を追加して、増分コンパイルの使用を反映するブール値を指定します。この場合、パラメーターは後続の各ビルドに追加する必要があることに注意してください。増分コンパイルが無効になっているビルドは、増分キャッシュを無効にします。</target>
        </trans-unit>
        <trans-unit id="d95af6982c4662ae34dc8dfd04c6f3d77bb71544" translate="yes" xml:space="preserve">
          <source>In Gradle configuration files: add the line &lt;code&gt;kotlin.incremental=&amp;lt;value&amp;gt;&lt;/code&gt; for Kotlin/JVM or &lt;code&gt;kotlin.incremental.js=&amp;lt;value&amp;gt;&lt;/code&gt; for Kotlin/JS projects either to &lt;code&gt;gradle.properties&lt;/code&gt; or to &lt;code&gt;local.properties&lt;/code&gt; file. &lt;code&gt;&amp;lt;value&amp;gt;&lt;/code&gt; is a boolean value reflecting the usage of incremental compilation.</source>
          <target state="translated">Gradleの設定ファイルでは：行を追加 &lt;code&gt;kotlin.incremental=&amp;lt;value&amp;gt;&lt;/code&gt; Kotlin / JVMまたはのため &lt;code&gt;kotlin.incremental.js=&amp;lt;value&amp;gt;&lt;/code&gt; のいずれかにKotlin / JSプロジェクトのため &lt;code&gt;gradle.properties&lt;/code&gt; かに &lt;code&gt;local.properties&lt;/code&gt; のファイル。 &lt;code&gt;&amp;lt;value&amp;gt;&lt;/code&gt; は、増分コンパイルの使用を反映するブール値です。</target>
        </trans-unit>
        <trans-unit id="537c1a3af537507e4b627b3261006ddbdae522fd" translate="yes" xml:space="preserve">
          <source>In Gradle:</source>
          <target state="translated">Gradleで。</target>
        </trans-unit>
        <trans-unit id="d2d1d0c783432497ec07d157b951c4e78d7cc0b8" translate="yes" xml:space="preserve">
          <source>In IntelliJ IDEA go to &lt;em&gt;File -&amp;gt; New &amp;gt; Project&amp;hellip;&lt;/em&gt; and check the &lt;em&gt;Create from archetype&lt;/em&gt; box:</source>
          <target state="translated">IntelliJ IDEAでに行き&lt;em&gt;、ファイル- &amp;gt;新規&amp;gt;プロジェクト...&lt;/em&gt;とチェック&lt;em&gt;原型から作成&lt;/em&gt;ボックス：</target>
        </trans-unit>
        <trans-unit id="4d485a76c7a3760895d18fab529fc51f77b28063" translate="yes" xml:space="preserve">
          <source>In IntelliJ IDEA go to &lt;em&gt;File -&amp;gt; New &amp;gt; Project&amp;hellip;&lt;/em&gt;:</source>
          <target state="translated">IntelliJ IDEAで、&lt;em&gt;[ファイル]-&amp;gt; [新規]&amp;gt; [プロジェクト]に移動します&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="9cc14db5a6e801d7da035df405c7d7827fc53b41" translate="yes" xml:space="preserve">
          <source>In JVM platform code:</source>
          <target state="translated">JVMプラットフォームのコードで。</target>
        </trans-unit>
        <trans-unit id="513ad5f28a98a53d38c2cd4b1ebf3e53ba78a0e9" translate="yes" xml:space="preserve">
          <source>In Java you specify &lt;code&gt;Dagger&lt;/code&gt; as &lt;code&gt;annotationProcessor&lt;/code&gt; (or &lt;code&gt;apt&lt;/code&gt;) dependency:</source>
          <target state="translated">Javaでは、 &lt;code&gt;Dagger&lt;/code&gt; を &lt;code&gt;annotationProcessor&lt;/code&gt; （または &lt;code&gt;apt&lt;/code&gt; ）依存関係として指定します。</target>
        </trans-unit>
        <trans-unit id="e76e330054ec3492dbde5d95b20d3d1c9ac12e6f" translate="yes" xml:space="preserve">
          <source>In Java, we are used to classes named &quot;*Utils&quot;: &lt;code&gt;FileUtils&lt;/code&gt;, &lt;code&gt;StringUtils&lt;/code&gt; and so on. The famous &lt;code&gt;java.util.Collections&lt;/code&gt; belongs to the same breed. And the unpleasant part about these Utils-classes is that the code that uses them looks like this:</source>
          <target state="translated">Javaでは、「* Utils」という名前のクラスに慣れています： &lt;code&gt;FileUtils&lt;/code&gt; 、 &lt;code&gt;StringUtils&lt;/code&gt; など。有名な &lt;code&gt;java.util.Collections&lt;/code&gt; は同じ品種に属しています。また、これらのUtilsクラスの不愉快な点は、それらを使用するコードが次のようになっていることです。</target>
        </trans-unit>
        <trans-unit id="8310a54b24568803ae04cc82e73e4ed7d64a2ce9" translate="yes" xml:space="preserve">
          <source>In Java:</source>
          <target state="translated">Javaでは。</target>
        </trans-unit>
        <trans-unit id="abb66954294d1e4253f6894befd4961b0fc88ece" translate="yes" xml:space="preserve">
          <source>In JavaScript you can define members either on a prototype or a class itself. I.e.:</source>
          <target state="translated">JavaScriptでは、プロトタイプやクラス自体にメンバーを定義することができます。例えば</target>
        </trans-unit>
        <trans-unit id="592ce5c07c0fe6dc9a4e0ec16760d4af84a287b3" translate="yes" xml:space="preserve">
          <source>In JavaScript you can define members either on a prototype or a class itself:</source>
          <target state="translated">JavaScriptでは、プロトタイプやクラス自体にメンバーを定義することができます。</target>
        </trans-unit>
        <trans-unit id="b73e80ab874eb4a673c8b0548f2f4b1a57e2e5b0" translate="yes" xml:space="preserve">
          <source>In Kotlin 1.0, code in the lambda passed to &lt;code&gt;td&lt;/code&gt; has access to three implicit receivers: the one passed to &lt;code&gt;table&lt;/code&gt;, to &lt;code&gt;tr&lt;/code&gt; and to &lt;code&gt;td&lt;/code&gt;. This allows you to call methods that make no sense in the context - for example to call &lt;code&gt;tr&lt;/code&gt; inside &lt;code&gt;td&lt;/code&gt; and thus to put a &lt;code&gt;&amp;lt;tr&amp;gt;&lt;/code&gt; tag in a &lt;code&gt;&amp;lt;td&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Kotlin 1.0では、 &lt;code&gt;td&lt;/code&gt; に渡されるラムダ内のコードは、3つの暗黙的なレシーバー（ &lt;code&gt;table&lt;/code&gt; 、 &lt;code&gt;tr&lt;/code&gt; 、および &lt;code&gt;td&lt;/code&gt; に渡されるレシーバー）にアクセスできます。これにより、コンテキスト内で意味のないメソッドを呼び出すことができます。たとえば、 &lt;code&gt;td&lt;/code&gt; 内で &lt;code&gt;tr&lt;/code&gt; を呼び出して、 &lt;code&gt;&amp;lt;tr&amp;gt;&lt;/code&gt; タグを &lt;code&gt;&amp;lt;td&amp;gt;&lt;/code&gt; に配置できます。</target>
        </trans-unit>
        <trans-unit id="faca07a0c2f2dcf45e7526d00d395e3cdc377fcb" translate="yes" xml:space="preserve">
          <source>In Kotlin 1.1, you can restrict that, so that only methods defined on the implicit receiver of &lt;code&gt;td&lt;/code&gt; will be available inside the lambda passed to &lt;code&gt;td&lt;/code&gt;. You do that by defining your annotation marked with the &lt;code&gt;@DslMarker&lt;/code&gt; meta-annotation and applying it to the base class of the tag classes.</source>
          <target state="translated">Kotlin 1.1では、 &lt;code&gt;td&lt;/code&gt; に渡されたラムダ内で &lt;code&gt;td&lt;/code&gt; の暗黙のレシーバーで定義されたメソッドのみが使用できるように、それを制限できます。 &lt;code&gt;@DslMarker&lt;/code&gt; メタ注釈でマークされた注釈を定義し、それをタグクラスの基本クラスに適用することにより、これを行います。</target>
        </trans-unit>
        <trans-unit id="24a213ee88ffeaa2bec3378db48986b075744611" translate="yes" xml:space="preserve">
          <source>In Kotlin 1.1.x, use &lt;code&gt;kotlin-stdlib-jre7&lt;/code&gt; and &lt;code&gt;kotlin-stdlib-jre8&lt;/code&gt; instead.</source>
          <target state="translated">Kotlin 1.1.xでは、 &lt;code&gt;kotlin-stdlib-jre7&lt;/code&gt; と &lt;code&gt;kotlin-stdlib-jre8&lt;/code&gt; を使用してください。</target>
        </trans-unit>
        <trans-unit id="6ea3af6627b279c964f114bd464c51ab696c689f" translate="yes" xml:space="preserve">
          <source>In Kotlin 1.3 it is possible for annotations to have nested classes, interfaces, objects, and companions:</source>
          <target state="translated">Kotlin 1.3では、アノテーションにネストされたクラス、インターフェース、オブジェクト、コンパニオンを持たせることができます。</target>
        </trans-unit>
        <trans-unit id="3098d1aa730f31e91846c87eaae7ac71342cdc7e" translate="yes" xml:space="preserve">
          <source>In Kotlin 1.3, it is now possible to capture the &lt;code&gt;when&lt;/code&gt; subject into variable:</source>
          <target state="translated">Kotlin 1.3では、サブジェクトを変数にキャプチャすることが可能 &lt;code&gt;when&lt;/code&gt; なりました。</target>
        </trans-unit>
        <trans-unit id="2a99d2573a55fb319e350044cce69239e344a488" translate="yes" xml:space="preserve">
          <source>In Kotlin functions can be declared at top level in a file, meaning you do not need to create a class to hold a function, which you are required to do in languages such as Java, C# or Scala. In addition to top level functions, Kotlin functions can also be declared local, as member functions and extension functions.</source>
          <target state="translated">つまり、JavaやC#、Scalaなどの言語で必要とされるような、関数を保持するためのクラスを作成する必要がありません。トップレベルの関数に加えて、Kotlinの関数はメンバー関数や拡張関数としてローカルに宣言することもできます。</target>
        </trans-unit>
        <trans-unit id="d5176ee2358fd7911cf590e90f48fd7d921131e2" translate="yes" xml:space="preserve">
          <source>In Kotlin there are two types of equality:</source>
          <target state="translated">コトリンでは2種類の平等があります。</target>
        </trans-unit>
        <trans-unit id="1307e7346626ce5c88b95620e1843731ae3969f4" translate="yes" xml:space="preserve">
          <source>In Kotlin this line can be concisely parsed with the following statement using &lt;a href=&quot;../reference/multi-declarations#destructuring-declarations&quot;&gt;destructuring declaration&lt;/a&gt; from a list of integers:</source>
          <target state="translated">Kotlinでは、この行は整数のリストからの構造化&lt;a href=&quot;../reference/multi-declarations#destructuring-declarations&quot;&gt;宣言&lt;/a&gt;を使用して、次のステートメントで簡潔に解析できます。</target>
        </trans-unit>
        <trans-unit id="d2cb95a39c5087932a02f405cc63f954a5dedc22" translate="yes" xml:space="preserve">
          <source>In Kotlin you can provide upper bounds for a generic type. Objective-C also supports this, but that support is unavailable in more complex cases, and is currently not supported in the Kotlin - Objective-C interop. The exception here being a non-null upper bound will make Objective-C methods/properties non-null.</source>
          <target state="translated">Kotlinでは、一般的な型の上限を指定することができます。Objective-Cもこれをサポートしていますが、より複雑なケースではサポートされておらず、現在のところKotlin-Objective-Cの相互運用ではサポートされていません。ここでの例外は、非 null 上限を指定すると Objective-C のメソッドやプロパティが非 null になることです。</target>
        </trans-unit>
        <trans-unit id="ef29e345af9c063df71b3f01a21f78a928c57611" translate="yes" xml:space="preserve">
          <source>In Kotlin you can't work with fields directly, you work with &lt;a href=&quot;../reference/properties&quot;&gt;properties&lt;/a&gt;. You annotate the property:</source>
          <target state="translated">Kotlinでは、フィールドを直接操作することはできません。&lt;a href=&quot;../reference/properties&quot;&gt;プロパティを操作&lt;/a&gt;します。プロパティに注釈を付けます。</target>
        </trans-unit>
        <trans-unit id="b1411aa40ea7c5b9a0de303333e37baf632f1665" translate="yes" xml:space="preserve">
          <source>In Kotlin you have to add the &lt;code&gt;kotlin-kapt&lt;/code&gt; plugin to enable &lt;code&gt;kapt&lt;/code&gt;, and then replace &lt;code&gt;annotationProcessor&lt;/code&gt; with &lt;code&gt;kapt&lt;/code&gt;:</source>
          <target state="translated">Kotlinでは、 &lt;code&gt;kotlin-kapt&lt;/code&gt; プラグインを追加してkaptを有効にして &lt;code&gt;kapt&lt;/code&gt; 、 &lt;code&gt;annotationProcessor&lt;/code&gt; を &lt;code&gt;kapt&lt;/code&gt; に置き換える必要があります。</target>
        </trans-unit>
        <trans-unit id="da7a2b73e175cb7362740b3fbdff60c8cc8e5724" translate="yes" xml:space="preserve">
          <source>In Kotlin you specify the dependencies in a similar to Java way using &lt;a href=&quot;../reference/kapt&quot;&gt;Kotlin Annotation processing tool&lt;/a&gt; (&lt;code&gt;kapt&lt;/code&gt;) instead of &lt;code&gt;annotationProcessor&lt;/code&gt;.</source>
          <target state="translated">Kotlin では、 &lt;code&gt;annotationProcessor&lt;/code&gt; の代わりに&lt;a href=&quot;../reference/kapt&quot;&gt;Kotlin注釈処理ツール&lt;/a&gt;（ &lt;code&gt;kapt&lt;/code&gt; ）を使用して、Javaと同様の方法で依存関係を指定します。</target>
        </trans-unit>
        <trans-unit id="0a2601b06937bb12c0744830de8e7b372473464e" translate="yes" xml:space="preserve">
          <source>In Kotlin, &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/plus&quot;&gt;&lt;code&gt;plus&lt;/code&gt;&lt;/a&gt; (&lt;code&gt;+&lt;/code&gt;) and &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/minus&quot;&gt;&lt;code&gt;minus&lt;/code&gt;&lt;/a&gt; (&lt;code&gt;-&lt;/code&gt;) operators are defined for collections. They take a collection as the first operand; the second operand can be either an element or another collection. The return value is a new read-only collection:</source>
          <target state="translated">Kotlinでは、&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/plus&quot;&gt; &lt;code&gt;plus&lt;/code&gt; &lt;/a&gt;（ &lt;code&gt;+&lt;/code&gt; ）および&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/minus&quot;&gt; &lt;code&gt;minus&lt;/code&gt; &lt;/a&gt;（ &lt;code&gt;-&lt;/code&gt; ）演算子がコレクションに定義されています。彼らは最初のオペランドとしてコレクションを取ります。2番目のオペランドは、要素または別のコレクションです。戻り値は、新しい読み取り専用のコレクションです。</target>
        </trans-unit>
        <trans-unit id="78f4990d53a6e7c8067b2fe1adea30492b815286" translate="yes" xml:space="preserve">
          <source>In Kotlin, &lt;em&gt;if&lt;/em&gt; can also be used as an expression:</source>
          <target state="translated">Kotlinでは、&lt;em&gt;if&lt;/em&gt;を式として使用&lt;em&gt;する&lt;/em&gt;こともできます。</target>
        </trans-unit>
        <trans-unit id="630fd5574aed5de24f8dfa12e49c30f220082837" translate="yes" xml:space="preserve">
          <source>In Kotlin, &lt;em&gt;if&lt;/em&gt; is an expression, i.e. it returns a value. Therefore there is no ternary operator (condition ? then : else), because ordinary &lt;em&gt;if&lt;/em&gt; works fine in this role.</source>
          <target state="translated">Kotlinでは、&lt;em&gt;if&lt;/em&gt;が式、つまり値を返します。したがって、通常の&lt;em&gt;if&lt;/em&gt;がこの役割でうまく機能するため、3項演算子（条件？then：else）はありません。</target>
        </trans-unit>
        <trans-unit id="449834b1db02375da0148e9e57aea36e01ccf956" translate="yes" xml:space="preserve">
          <source>In Kotlin, all exceptions are unchecked, meaning that the compiler does not force you to catch any of them. So, when you call a Java method that declares a checked exception, Kotlin does not force you to do anything:</source>
          <target state="translated">Kotlinでは、すべての例外はチェックされていないので、コンパイラが強制的に例外をキャッチすることはありません。つまり、チェックされた例外を宣言するJavaメソッドを呼び出しても、Kotlinは何も強制しません。</target>
        </trans-unit>
        <trans-unit id="ccb7acc6feff10a66296746e0c93a95c37a6267f" translate="yes" xml:space="preserve">
          <source>In Kotlin, everything is an object in the sense that we can call member functions and properties on any variable. Some of the types can have a special internal representation - for example, numbers, characters and booleans can be represented as primitive values at runtime - but to the user they look like ordinary classes. In this section we describe the basic types used in Kotlin: numbers, characters, booleans, arrays, and strings.</source>
          <target state="translated">Kotlinでは、あらゆる変数のメンバ関数やプロパティを呼び出すことができるという意味で、すべてのものがオブジェクトです。型の中には特別な内部表現が可能なものもあります-例えば、数値、文字、ブーリアンは実行時にプリミティブ値として表現できますが、ユーザには普通のクラスのように見えます。このセクションでは、Kotlin で使われる基本的な型について説明します:数字、文字、ブーリアン、配列、文字列です。</target>
        </trans-unit>
        <trans-unit id="bcc1b8c2a992c6c34b455f92da91c74149cd8719" translate="yes" xml:space="preserve">
          <source>In Kotlin, functional types are represented as generic classes taking a different number of parameters: &lt;code&gt;Function0&amp;lt;R&amp;gt;&lt;/code&gt;, &lt;code&gt;Function1&amp;lt;P0, R&amp;gt;&lt;/code&gt;, &lt;code&gt;Function2&amp;lt;P0, P1, R&amp;gt;&lt;/code&gt;, &amp;hellip; This approach has a problem in that this list is finite, and it currently ends with &lt;code&gt;Function22&lt;/code&gt;.</source>
          <target state="translated">Kotlinでは、関数型は異なる数のパラメーターを取る汎用クラスとして表されます &lt;code&gt;Function0&amp;lt;R&amp;gt;&lt;/code&gt; 、 &lt;code&gt;Function1&amp;lt;P0, R&amp;gt;&lt;/code&gt; 、 &lt;code&gt;Function2&amp;lt;P0, P1, R&amp;gt;&lt;/code&gt; 、&amp;hellip;このアプローチには、このリストが有限であるという問題があります。 、現在は &lt;code&gt;Function22&lt;/code&gt; で終わります。</target>
        </trans-unit>
        <trans-unit id="dda94f8bd95fbc2c5d984c18e048611fb7b42dbc" translate="yes" xml:space="preserve">
          <source>In Kotlin, implementation inheritance is regulated by the following rule: if a class inherits many implementations of the same member from its immediate superclasses, it must override this member and provide its own implementation (perhaps, using one of the inherited ones). To denote the supertype from which the inherited implementation is taken, we use &lt;em&gt;super&lt;/em&gt; qualified by the supertype name in angle brackets, e.g. &lt;code&gt;super&amp;lt;Base&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">Kotlinでは、実装の継承は次のルールによって規制されています。クラスが同じメンバーの多くの実装を直接のスーパークラスから継承する場合、クラスはこのメンバーをオーバーライドし、独自の実装を提供する必要があります（おそらく、継承された実装の1つを使用します）。継承された実装の取得元のスーパータイプを示すために、山かっこで囲まれたスーパータイプ名で&lt;em&gt;スーパー&lt;/em&gt;修飾を使用します。例： &lt;code&gt;super&amp;lt;Base&amp;gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="7e8de20bd90cf59ff062bcee3a6b6475fd0af4bb" translate="yes" xml:space="preserve">
          <source>In Kotlin, implementation inheritance is regulated by the following rule: if a class inherits multiple implementations of the same member from its immediate superclasses, it must override this member and provide its own implementation (perhaps, using one of the inherited ones). To denote the supertype from which the inherited implementation is taken, we use &lt;em&gt;super&lt;/em&gt; qualified by the supertype name in angle brackets, e.g. &lt;code&gt;super&amp;lt;Base&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">Kotlinでは、実装の継承は次のルールによって規制されています。クラスがその直接のスーパークラスから同じメンバーの複数の実装を継承する場合、このメンバーをオーバーライドして、独自の実装を提供する必要があります（おそらく、継承されたものの1つを使用します）。継承された実装が取られているから、スーパータイプを示すために、私たちが使用する&lt;em&gt;スーパー&lt;/em&gt;角括弧内のスーパータイプ名によって修飾、例えば &lt;code&gt;super&amp;lt;Base&amp;gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="7dcc76eece2b8bf2e4ff6b5b682eb767b78c7f50" translate="yes" xml:space="preserve">
          <source>In Kotlin, importing is a compile-time concept - importing something does not actually cause any code to run (unlike Python, where all top-level statements in a file are executed at import time). Therefore, circular imports are allowed, but they might suggest a design problem in your code. However, during execution, a class will be loaded the first time it (or any of its properties or functions) is referenced, and class loading causes &lt;a href=&quot;objects-and-companion-objects#companion-objects&quot;&gt;companion objects&lt;/a&gt; to be initialized - this can lead to runtime exceptions if you have circular dependencies.</source>
          <target state="translated">Kotlinでは、インポートはコンパイル時の概念です。何かをインポートしても、実際にはコードが実行されません（Pythonとは異なり、ファイル内のすべてのトップレベルのステートメントがインポート時に実行されます）。したがって、循環インポートは許可されますが、コードの設計上の問題を示唆している可能性があります。ただし、実行時には、クラス（またはそのプロパティや関数）が最初に参照されたときにクラスが読み込まれ、クラスの読み込みによって&lt;a href=&quot;objects-and-companion-objects#companion-objects&quot;&gt;コンパニオンオブジェクト&lt;/a&gt;が初期化されます。これにより、循環依存関係がある場合、ランタイム例外が発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="9724d2f4d0f2fb74f7ee2235878c749f495a0bad" translate="yes" xml:space="preserve">
          <source>In Kotlin, polymorphism is achieved via the class hierarchy, in such a way that it is impossible to run into a situation where a property or function is missing. The basic rule is that a variable/property/parameter whose declared type is &lt;code&gt;A&lt;/code&gt; may refer to an instance of a class &lt;code&gt;B&lt;/code&gt; if and only if &lt;code&gt;B&lt;/code&gt; is a subtype of &lt;code&gt;A&lt;/code&gt;. This means that either, &lt;code&gt;A&lt;/code&gt; must be a class and &lt;code&gt;B&lt;/code&gt; must be a subclass of &lt;code&gt;A&lt;/code&gt;, or that &lt;code&gt;A&lt;/code&gt; must be an interface and &lt;code&gt;B&lt;/code&gt; must be a class that implements that interface or be a subclass of a class that does. With our classes and interfaces from the previous sections, we can define these functions:</source>
          <target state="translated">Kotlinでは、ポリモーフィズムはクラス階層を介して実現され、プロパティまたは関数が欠落している状況に遭遇することは不可能です。基本的なルールは、宣言されたタイプが &lt;code&gt;A&lt;/code&gt; である変数/プロパティ/パラメータは、 &lt;code&gt;B&lt;/code&gt; が &lt;code&gt;A&lt;/code&gt; のサブタイプである場合に限り、クラス &lt;code&gt;B&lt;/code&gt; のインスタンスを参照することができるということです。これは、 &lt;code&gt;A&lt;/code&gt; がクラスであり、 &lt;code&gt;B&lt;/code&gt; が &lt;code&gt;A&lt;/code&gt; のサブクラスであるか、または &lt;code&gt;A&lt;/code&gt; がインターフェースであり、 &lt;code&gt;B&lt;/code&gt; がそのインターフェースを実装するクラスであるか、またはそのクラスのサブクラスである必要があることを意味します。前のセクションのクラスとインターフェースを使用して、次の関数を定義できます。</target>
        </trans-unit>
        <trans-unit id="0ea4efcee086c70a1dc18d5edfeb999729e27f06" translate="yes" xml:space="preserve">
          <source>In Kotlin, semicolons are optional, and therefore line breaks are significant. The language design assumes Java-style braces, and you may encounter surprising behavior if you try to use a different formatting style.</source>
          <target state="translated">Kotlinではセミコロンはオプションなので、改行は重要です。言語設計ではJavaスタイルの中括弧を前提としているため、異なる書式スタイルを使おうとすると驚くような動作をするかもしれません。</target>
        </trans-unit>
        <trans-unit id="1ea952e978cda6b66f0b076e1bf4afae5776a252" translate="yes" xml:space="preserve">
          <source>In Kotlin, the default implementation of &lt;code&gt;List&lt;/code&gt; is &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-array-list/index&quot;&gt;&lt;code&gt;ArrayList&lt;/code&gt;&lt;/a&gt; which you can think of as a resizable array.</source>
          <target state="translated">Kotlinでは、 &lt;code&gt;List&lt;/code&gt; のデフォルト実装は&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-array-list/index&quot;&gt; &lt;code&gt;ArrayList&lt;/code&gt; で&lt;/a&gt;あり、サイズ変更可能な配列と考えることができます。</target>
        </trans-unit>
        <trans-unit id="b0f2e47b033955ac0009c7acc59029af121c0f6e" translate="yes" xml:space="preserve">
          <source>In Kotlin, the expression for a default value is evaluated every time the function is invoked. Therefore, you will avoid the above trap as long as you use an expression that produces a new list every time it is evaluated:</source>
          <target state="translated">Kotlinでは、デフォルト値の式は関数が呼び出されるたびに評価されます。したがって、評価されるたびに新しいリストを生成する式を使用している限り、上記の罠を回避することができます。</target>
        </trans-unit>
        <trans-unit id="1f711d573309109397667a32c94fd541ceecdc60" translate="yes" xml:space="preserve">
          <source>In Kotlin, the orders of objects can be defined in several ways.</source>
          <target state="translated">Kotlinでは、オブジェクトの順序をいくつかの方法で定義することができます。</target>
        </trans-unit>
        <trans-unit id="2339e3beff8d4c7968bd5b14328be82bd9a5b046" translate="yes" xml:space="preserve">
          <source>In Kotlin, the type system distinguishes between references that can hold &lt;em&gt;null&lt;/em&gt; (nullable references) and those that can not (non-null references). For example, a regular variable of type &lt;code&gt;String&lt;/code&gt; can not hold &lt;em&gt;null&lt;/em&gt;:</source>
          <target state="translated">Kotlinでは、型システムは&lt;em&gt;null&lt;/em&gt;を保持できる参照（null可能な参照）と保持できない参照（null以外の参照）を区別し&lt;em&gt;ます&lt;/em&gt;。たとえば、 &lt;code&gt;String&lt;/code&gt; 型の通常の変数は&lt;em&gt;nullを&lt;/em&gt;保持できません。</target>
        </trans-unit>
        <trans-unit id="832014b08edc07489a35f79862dd60fe09daab6f" translate="yes" xml:space="preserve">
          <source>In Kotlin, there is a convention: if the last parameter of a function is a function, then a lambda expression passed as the corresponding argument can be placed outside the parentheses:</source>
          <target state="translated">Kotlinでは、関数の最後のパラメータが関数の場合、対応する引数として渡されたラムダ式を括弧の外に置くことができます。</target>
        </trans-unit>
        <trans-unit id="c2a3923bf671e235e84ea1d045b896ec7fad1d7d" translate="yes" xml:space="preserve">
          <source>In Kotlin, there is a way to explain this sort of thing to the compiler. This is called &lt;strong&gt;declaration-site variance&lt;/strong&gt;: we can annotate the &lt;strong&gt;type parameter&lt;/strong&gt;&lt;code&gt;T&lt;/code&gt; of Source to make sure that it is only &lt;strong&gt;returned&lt;/strong&gt; (produced) from members of &lt;code&gt;Source&amp;lt;T&amp;gt;&lt;/code&gt;, and never consumed. To do this we provide the &lt;strong&gt;out&lt;/strong&gt; modifier:</source>
          <target state="translated">Kotlinには、この種のことをコンパイラーに説明する方法があります。これは&lt;strong&gt;宣言サイトバリアンス&lt;/strong&gt;と呼ばれます。Sourceの&lt;strong&gt;型パラメーター&lt;/strong&gt; &lt;code&gt;T&lt;/code&gt; に注釈を付けて、 &lt;code&gt;Source&amp;lt;T&amp;gt;&lt;/code&gt; メンバーからのみ&lt;strong&gt;返され&lt;/strong&gt;（生成され）、消費されないようにすることができます。これを行うには、&lt;strong&gt;out&lt;/strong&gt;修飾子を提供します。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="feddf47fe54f2c3f729a6d26efa190cb7e973f88" translate="yes" xml:space="preserve">
          <source>In Kotlin, unlike Java or C#, classes do not have static methods. In most cases, it's recommended to simply use package-level functions instead.</source>
          <target state="translated">Kotlin では、Java や C#とは異なり、クラスは静的メソッドを持ちません。ほとんどの場合、代わりに単にパッケージレベルの関数を使うことをお勧めします。</target>
        </trans-unit>
        <trans-unit id="d5e92ec06e3b15b62ad5ec58ebeffa93765ab71a" translate="yes" xml:space="preserve">
          <source>In Kotlin, we can only use a normal, unqualified &lt;code&gt;return&lt;/code&gt; to exit a named function or an anonymous function. This means that to exit a lambda, we have to use a &lt;a href=&quot;returns#return-at-labels&quot;&gt;label&lt;/a&gt;, and a bare &lt;code&gt;return&lt;/code&gt; is forbidden inside a lambda, because a lambda cannot make the enclosing function return:</source>
          <target state="translated">Kotlinでは、名前の付いた関数または無名関数を終了するために、通常の修飾されていない &lt;code&gt;return&lt;/code&gt; のみを使用できます。これは、ラムダを終了するには&lt;a href=&quot;returns#return-at-labels&quot;&gt;label&lt;/a&gt;を使用する必要があることを意味します。ラムダは囲み関数を返すことができないため、ラムダ内でのベア &lt;code&gt;return&lt;/code&gt; は禁止されています。</target>
        </trans-unit>
        <trans-unit id="0bc591251b1866272d3defd4ab24986b180f3e99" translate="yes" xml:space="preserve">
          <source>In Kotlin/JS implementation of StringBuilder the initial capacity has no effect on the further performance of operations.</source>
          <target state="translated">Kotlin/JSのStringBuilderの実装では、初期容量はそれ以降の操作のパフォーマンスに影響を与えません。</target>
        </trans-unit>
        <trans-unit id="3d25d5f146a0d36095ac2d2fbada4dfa30e5c1b3" translate="yes" xml:space="preserve">
          <source>In Kotlin/JS implementation of StringBuilder the size of the backing storage is always equal to the length of the string builder.</source>
          <target state="translated">Kotlin/JSのStringBuilderの実装では、バッキングストレージのサイズは常に文字列ビルダーの長さと等しくなります。</target>
        </trans-unit>
        <trans-unit id="9c5a4446d1a6bca7a876f80da83f707725750c3e" translate="yes" xml:space="preserve">
          <source>In Kotlin/JS implementation of StringBuilder the size of the backing storage is not extended to comply the given &lt;a href=&quot;ensure-capacity#kotlin.text.StringBuilder%24ensureCapacity(kotlin.Int)/minimumCapacity&quot;&gt;minimumCapacity&lt;/a&gt;, thus calling this method has no effect on the further performance of operations.</source>
          <target state="translated">StringBuilderのKotlin / JS実装では、バッキングストレージのサイズは、指定された&lt;a href=&quot;ensure-capacity#kotlin.text.StringBuilder%24ensureCapacity(kotlin.Int)/minimumCapacity&quot;&gt;minimumCapacity&lt;/a&gt;に準拠するように拡張されないため、このメソッドを呼び出しても、操作のさらなるパフォーマンスには影響しません。</target>
        </trans-unit>
        <trans-unit id="6b416b284c329b83d138fdf71a7f58ad406d7c9b" translate="yes" xml:space="preserve">
          <source>In Maven</source>
          <target state="translated">メイヴンでは</target>
        </trans-unit>
        <trans-unit id="9ce095374b679dfd053dccebdba1f6ce80a67e34" translate="yes" xml:space="preserve">
          <source>In Maven, enable the &lt;code&gt;jpa&lt;/code&gt; plugin:</source>
          <target state="translated">Mavenで &lt;code&gt;jpa&lt;/code&gt; プラグインを有効にします。</target>
        </trans-unit>
        <trans-unit id="4cf1f43e65b88c5f6958702897fafbb7af63f2e9" translate="yes" xml:space="preserve">
          <source>In Maven, enable the &lt;code&gt;spring&lt;/code&gt; plugin:</source>
          <target state="translated">Mavenのでは、有効 &lt;code&gt;spring&lt;/code&gt; プラグインを：</target>
        </trans-unit>
        <trans-unit id="14be0db4481edc4ab423c4343db7ab0c7cfdc4a9" translate="yes" xml:space="preserve">
          <source>In Maven, the &lt;code&gt;spring&lt;/code&gt; plugin is provided by the &lt;code&gt;kotlin-maven-allopen&lt;/code&gt; plugin dependency, so to enable it:</source>
          <target state="translated">Mavenのでは、 &lt;code&gt;spring&lt;/code&gt; プラグインはによって提供される &lt;code&gt;kotlin-maven-allopen&lt;/code&gt; ので、それを可能にするために、プラグインの依存：</target>
        </trans-unit>
        <trans-unit id="2fde5916b654de021cf5316e7c8446b2d071c3b3" translate="yes" xml:space="preserve">
          <source>In Maven:</source>
          <target state="translated">Mavenで。</target>
        </trans-unit>
        <trans-unit id="6dc887971001bc1cd4775889e759bfb59211b14c" translate="yes" xml:space="preserve">
          <source>In Python, function names must be unique within a module or a class. In Kotlin, we can &lt;em&gt;overload&lt;/em&gt; functions: there can be multiple declarations of functions that have the same name. Overloaded functions must be distinguishable from each other through their parameter lists. (The types of the parameter list, together with the return type, is known as a function's &lt;em&gt;signature&lt;/em&gt;, but the return type cannot be used to disambiguate overloaded functions.) For example, we can have both of these functions in the same file:</source>
          <target state="translated">Pythonでは、関数名はモジュールまたはクラス内で一意である必要があります。Kotlinでは、関数を&lt;em&gt;オーバーロード&lt;/em&gt;できます。同じ名前の関数が複数宣言されている可能性があります。オーバーロードされた関数は、パラメーターリストを通じて互いに区別できる必要があります。（パラメーターリストの型は、戻り値の型と合わせて関数の&lt;em&gt;シグネチャ&lt;/em&gt;と呼ばれますが、戻り値の型を使用して、オーバーロードされた関数を明確にすることはできません。）たとえば、これらの両方の関数を同じファイルに含めることができます。</target>
        </trans-unit>
        <trans-unit id="1c0f7f91981a6ecf109d226f21e3069c8aabc15a" translate="yes" xml:space="preserve">
          <source>In Python, the expression for a default value is evaluated once, at function definition time. That leads to this classic trap, where the developer hopes to get a new, empty list every time the function is called without a value for &lt;code&gt;numbers&lt;/code&gt;, but instead, the same list is being used every time:</source>
          <target state="translated">Pythonでは、デフォルト値の式は関数定義時に1回評価されます。これはこの古典的なトラップにつながります。開発者は、数値の値なしで関数が呼び出されるたびに新しい空のリストを取得することを望んでい &lt;code&gt;numbers&lt;/code&gt; が、代わりに同じリストが毎回使用されています。</target>
        </trans-unit>
        <trans-unit id="cd3d02ed8996a5f9eaf8b21aad3a4aaadb80de18" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;when&lt;/code&gt; statement, if a branch is more than a single line, consider separating it from adjacent case blocks with a blank line:</source>
          <target state="translated">で &lt;code&gt;when&lt;/code&gt; 、分岐は1行以上であれば文、空白行と隣接するケースブロックからそれを分離する検討します。</target>
        </trans-unit>
        <trans-unit id="3a1b36cf0bd1ee7bba19fe0760cca000ad48b849" translate="yes" xml:space="preserve">
          <source>In a long-running application you might need fine-grained control on your background coroutines. For example, a user might have closed the page that launched a coroutine and now its result is no longer needed and its operation can be cancelled. The &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/launch.html&quot;&gt;launch&lt;/a&gt; function returns a &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html&quot;&gt;Job&lt;/a&gt; that can be used to cancel the running coroutine:</source>
          <target state="translated">実行時間の長いアプリケーションでは、バックグラウンドコルーチンをきめ細かく制御する必要がある場合があります。たとえば、ユーザーがコルーチンを起動したページを閉じたために、結果が不要になり、その操作をキャンセルできる場合があります。&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/launch.html&quot;&gt;打ち上げ&lt;/a&gt;関数は返し&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html&quot;&gt;ジョブ&lt;/a&gt;実行中のコルーチンをキャンセルするために使用することができます。</target>
        </trans-unit>
        <trans-unit id="e333c99581fbe52762649b5ab0c35c55ffcd093c" translate="yes" xml:space="preserve">
          <source>In a member of a &lt;a href=&quot;classes#inheritance&quot;&gt;class&lt;/a&gt;, &lt;em&gt;this&lt;/em&gt; refers to the current object of that class.</source>
          <target state="translated">&lt;a href=&quot;classes#inheritance&quot;&gt;クラスの&lt;/a&gt;メンバーでは、&lt;em&gt;これ&lt;/em&gt;はそのクラスの現在のオブジェクトを指します。</target>
        </trans-unit>
        <trans-unit id="15a56874c4866fabbe734af8a3fb102f28e0b12f" translate="yes" xml:space="preserve">
          <source>In a nutshell, you can use libraries such as &lt;a href=&quot;https://google.github.io/dagger/&quot;&gt;Dagger&lt;/a&gt; or &lt;a href=&quot;https://developer.android.com/topic/libraries/data-binding/index.html&quot;&gt;Data Binding&lt;/a&gt; in your Kotlin projects.</source>
          <target state="translated">簡単に言えば、Kotlinプロジェクトで&lt;a href=&quot;https://google.github.io/dagger/&quot;&gt;Dagger&lt;/a&gt;や&lt;a href=&quot;https://developer.android.com/topic/libraries/data-binding/index.html&quot;&gt;Data Binding&lt;/a&gt;などのライブラリを使用できます。</target>
        </trans-unit>
        <trans-unit id="5544e7dcfdd04da3eceaae6a1614ec1e4f550da9" translate="yes" xml:space="preserve">
          <source>In addition to &lt;strong&gt;out&lt;/strong&gt;, Kotlin provides a complementary variance annotation: &lt;strong&gt;in&lt;/strong&gt;. It makes a type parameter &lt;strong&gt;contravariant&lt;/strong&gt;: it can only be consumed and never produced. A good example of a contravariant type is &lt;code&gt;Comparable&lt;/code&gt;:</source>
          <target state="translated">&lt;strong&gt;out&lt;/strong&gt;に加え&lt;strong&gt;て&lt;/strong&gt;、Kotlinは補完的な分散アノテーションを提供します：&lt;strong&gt;in&lt;/strong&gt;。型パラメーターを&lt;strong&gt;反変に&lt;/strong&gt;します。消費のみ可能で、生成はできません。反変型の良い例は &lt;code&gt;Comparable&lt;/code&gt; です：</target>
        </trans-unit>
        <trans-unit id="c6329f208d955601deb101d4b33fc1acdf8accac" translate="yes" xml:space="preserve">
          <source>In addition to common operations for &lt;a href=&quot;collection-parts&quot;&gt;Retrieving Collection Parts&lt;/a&gt;, lists provide the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-list/sub-list&quot;&gt;&lt;code&gt;subList()&lt;/code&gt;&lt;/a&gt; function that returns a view of the specified elements range as a list. Thus, if an element of the original collection changes, it also changes in the previously created sublists and vice versa.</source>
          <target state="translated">&lt;a href=&quot;collection-parts&quot;&gt;コレクションパーツ&lt;/a&gt;を取得するための一般的な操作に加えて、リストは、指定された要素の範囲のビューをリストとして返す&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-list/sub-list&quot;&gt; &lt;code&gt;subList()&lt;/code&gt; &lt;/a&gt;関数を提供します。したがって、元のコレクションの要素が変更されると、以前に作成されたサブリストでも変更され、逆も同様です。</target>
        </trans-unit>
        <trans-unit id="9674c96ddd7757af7200ad4daae22ce260bb2047" translate="yes" xml:space="preserve">
          <source>In addition to removing elements, the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-mutable-list-iterator/index&quot;&gt;&lt;code&gt;MutableListIterator&lt;/code&gt;&lt;/a&gt; can also insert and replace elements while iterating the list.</source>
          <target state="translated">要素の削除に加えて、&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-mutable-list-iterator/index&quot;&gt; &lt;code&gt;MutableListIterator&lt;/code&gt; &lt;/a&gt;はリストの反復中に要素を挿入および置換することもできます。</target>
        </trans-unit>
        <trans-unit id="38a6e3c954dde3e3eb6edba41ad0b83ce52bd70c" translate="yes" xml:space="preserve">
          <source>In addition to scope functions, the standard library contains the functions &lt;code&gt;takeIf&lt;/code&gt; and &lt;code&gt;takeUnless&lt;/code&gt;. These functions let you embed checks of the object state in call chains.</source>
          <target state="translated">スコープ関数に加えて、標準ライブラリには関数 &lt;code&gt;takeIf&lt;/code&gt; および &lt;code&gt;takeUnless&lt;/code&gt; が含まれています。これらの関数を使用すると、オブジェクト状態のチェックを呼び出しチェーンに埋め込むことができます。</target>
        </trans-unit>
        <trans-unit id="acfd15e725bcfef6236f16c4782a0f3dc2126f4d" translate="yes" xml:space="preserve">
          <source>In addition to that, you can use &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.js/js&quot;&gt;KClass.js&lt;/a&gt; to access the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.js/-js-class/index&quot;&gt;JsClass&lt;/a&gt; instance corresponding to the class. The &lt;code&gt;JsClass&lt;/code&gt; instance itself is a reference to the constructor function. This can be used to interoperate with JS functions that expect a reference to a constructor.</source>
          <target state="translated">さらに、&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.js/js&quot;&gt;KClass.js&lt;/a&gt;を使用して、クラスに対応する&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.js/-js-class/index&quot;&gt;JsClass&lt;/a&gt;インスタンスにアクセスできます。 &lt;code&gt;JsClass&lt;/code&gt; のインスタンス自体は、コンストラクタ関数への参照です。これは、コンストラクターへの参照を期待するJS関数と相互運用するために使用できます。</target>
        </trans-unit>
        <trans-unit id="36b7ccec26bcb88294baf54023cc9ae72ecaa90f" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;a href=&quot;typecasts#unsafe-cast-operator&quot;&gt;&quot;unsafe&quot; cast operator&lt;/a&gt;&lt;code&gt;as&lt;/code&gt;, which throws a &lt;code&gt;ClassCastException&lt;/code&gt; in case a cast is not possible, Kotlin/JS also provides &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.js/unsafe-cast&quot;&gt;&lt;code&gt;unsafeCast&amp;lt;T&amp;gt;()&lt;/code&gt;&lt;/a&gt;. When using &lt;code&gt;unsafeCast&lt;/code&gt;, &lt;em&gt;no type checking is done at all&lt;/em&gt; during runtime. For example, consider the following two methods:</source>
          <target state="translated">キャストが不可能な場合に &lt;code&gt;ClassCastException&lt;/code&gt; をスローする&lt;a href=&quot;typecasts#unsafe-cast-operator&quot;&gt;「安全でない」キャスト演算子&lt;/a&gt; &lt;code&gt;as&lt;/code&gt; に加えて、Kotlin / JSは&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.js/unsafe-cast&quot;&gt; &lt;code&gt;unsafeCast&amp;lt;T&amp;gt;()&lt;/code&gt; &lt;/a&gt;も提供します。 &lt;code&gt;unsafeCast&lt;/code&gt; を使用する場合、実行時に&lt;em&gt;型チェックはまったく行われません&lt;/em&gt;。たとえば、次の2つの方法について考えてみます。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5594aa712f7692fd1a48c40180fe2939a4654a66" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;code&gt;kotlin-gradle-plugin&lt;/code&gt; dependency shown above, you need to add a dependency on the Kotlin standard library:</source>
          <target state="translated">上記の &lt;code&gt;kotlin-gradle-plugin&lt;/code&gt; 依存関係に加えて、Kotlin標準ライブラリへの依存関係を追加する必要があります。</target>
        </trans-unit>
        <trans-unit id="ea7c2f23dd342e78eba03e7edea502fd9fbb6ef4" translate="yes" xml:space="preserve">
          <source>In addition to the build tasks, the Gradle build includes helpful tasks to run the application directly via &lt;code&gt;runDebugExecutableNative&lt;/code&gt; and &lt;code&gt;runReleaseExecutableNative&lt;/code&gt;.</source>
          <target state="translated">ビルドタスクに加えて、Gradleビルドには、 &lt;code&gt;runDebugExecutableNative&lt;/code&gt; および &lt;code&gt;runReleaseExecutableNative&lt;/code&gt; を介してアプリケーションを直接実行するための便利なタスクが含まれています。</target>
        </trans-unit>
        <trans-unit id="1d5b7f7ad1a1556c56ce8e8eb4580dccfbc4c337" translate="yes" xml:space="preserve">
          <source>In addition to the collection modification operations described in &lt;a href=&quot;collection-write&quot;&gt;Collection Write Operations&lt;/a&gt;, &lt;a href=&quot;collections-overview#collection-types&quot;&gt;mutable&lt;/a&gt; lists support specific write operations. Such operations use the index to access elements to broaden the list modification capabilities.</source>
          <target state="translated">&lt;a href=&quot;collection-write&quot;&gt;コレクションの書き込み&lt;/a&gt;操作で説明されているコレクションの変更操作に加えて、&lt;a href=&quot;collections-overview#collection-types&quot;&gt;可変&lt;/a&gt;リストは特定の書き込み操作をサポートしています。このような操作では、インデックスを使用して要素にアクセスし、リスト変更機能を拡張します。</target>
        </trans-unit>
        <trans-unit id="edff8af41569526ee6f34e250c39b84435f2d3a3" translate="yes" xml:space="preserve">
          <source>In addition to the command line compiler and IntelliJ IDEA, you can also build Kotlin projects with Ant, Maven, and Gradle.</source>
          <target state="translated">コマンドラインコンパイラやIntelliJ IDEAに加えて、Ant、Maven、Gradleを使ってKotlinプロジェクトを構築することができます。</target>
        </trans-unit>
        <trans-unit id="13939289a96ed1a1e50225139ac3fbd7b0bc2be9" translate="yes" xml:space="preserve">
          <source>In addition to the coroutine scope provided by different builders, it is possible to declare your own scope using &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;coroutineScope&lt;/a&gt; builder. It creates a coroutine scope and does not complete until all launched children complete. The main difference between &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt; and &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;coroutineScope&lt;/a&gt; is that the latter does not block the current thread while waiting for all children to complete.</source>
          <target state="translated">別のビルダーによって提供さコルーチン範囲に加えて、使用して独自のスコープを宣言することが可能である&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;coroutineScopeの&lt;/a&gt;ビルダーを。コルーチンスコープを作成し、起動されたすべての子が完了するまで完了しません。主な違い&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt;と&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;coroutineScopeは&lt;/a&gt;完全にすべての子供たちを待っている間に、後者は現在のスレッドをブロックしていないということです。</target>
        </trans-unit>
        <trans-unit id="e5077ac7f8cceff0957d255db71b0d1a0a24a0ba" translate="yes" xml:space="preserve">
          <source>In addition to the coroutine scope provided by different builders, it is possible to declare your own scope using the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;coroutineScope&lt;/a&gt; builder. It creates a coroutine scope and does not complete until all launched children complete.</source>
          <target state="translated">別のビルダーによって提供さコルーチン範囲に加えて、使用して独自のスコープを宣言することが可能である&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;coroutineScopeの&lt;/a&gt;ビルダーを。コルーチンスコープを作成し、起動されたすべての子が完了するまで完了しません。</target>
        </trans-unit>
        <trans-unit id="063fa2441ff30c74a010fc27ec5f2018d7ca4ef2" translate="yes" xml:space="preserve">
          <source>In addition to the output JavaScript file, the plugin by default creates an additional JS file with binary descriptors. This file is required if you're building a reusable library that other Kotlin modules can depend on, and should be distributed together with the result of translation. The generation is controlled by the &lt;code&gt;kotlinOptions.metaInfo&lt;/code&gt; option:</source>
          <target state="translated">出力JavaScriptファイルに加えて、プラグインはデフォルトでバイナリ記述子を含む追加のJSファイルを作成します。このファイルは、他のKotlinモジュールが依存できる再利用可能なライブラリを構築する場合に必要であり、変換の結果とともに配布する必要があります。生成は、 &lt;code&gt;kotlinOptions.metaInfo&lt;/code&gt; オプションによって制御されます。</target>
        </trans-unit>
        <trans-unit id="4c8c93a8699f08045725902510444a7e2a812bf3" translate="yes" xml:space="preserve">
          <source>In addition, Rx does introduce a somewhat nicer approach to error handling.</source>
          <target state="translated">加えて、Rx はエラー処理に多少マシなアプローチを導入しています。</target>
        </trans-unit>
        <trans-unit id="3434b058fadc1fd97196abc0cd226b5de0eff131" translate="yes" xml:space="preserve">
          <source>In addition, each of these also have a corresponding &lt;code&gt;{file}.meta.js&lt;/code&gt; meta file which will be used for reflection and other functionality.</source>
          <target state="translated">さらに、これらのそれぞれには対応する &lt;code&gt;{file}.meta.js&lt;/code&gt; メタファイルがあり、リフレクションやその他の機能に使用されます。</target>
        </trans-unit>
        <trans-unit id="adf05c9d4a5ea22db47de9f6cd0f0a1f61618f95" translate="yes" xml:space="preserve">
          <source>In all cases, the C string is supposed to be encoded as UTF-8.</source>
          <target state="translated">いずれの場合も、Cの文字列はUTF-8でエンコードされることになっています。</target>
        </trans-unit>
        <trans-unit id="2ad8a2cde437dc29e925bd2e2608bcf1efd428d2" translate="yes" xml:space="preserve">
          <source>In all respects, this is just the same as in Java since access to private properties with default getters and setters is optimized so that no function call overhead is introduced.</source>
          <target state="translated">デフォルトのゲッターやセッターを使ったプライベート・プロパティへのアクセスが最適化されているため、関数呼び出しのオーバーヘッドが発生しません。</target>
        </trans-unit>
        <trans-unit id="af3fb6a2c1c95a7bcc9ea3f79ae7998d4cb1b27a" translate="yes" xml:space="preserve">
          <source>In an &lt;a href=&quot;extensions&quot;&gt;extension function&lt;/a&gt; or a &lt;a href=&quot;lambdas#function-literals-with-receiver&quot;&gt;function literal with receiver&lt;/a&gt;&lt;em&gt;this&lt;/em&gt; denotes the &lt;em&gt;receiver&lt;/em&gt; parameter that is passed on the left-hand side of a dot.</source>
          <target state="translated">で&lt;a href=&quot;extensions&quot;&gt;拡張機能&lt;/a&gt;または&lt;a href=&quot;lambdas#function-literals-with-receiver&quot;&gt;受信機と関数リテラル&lt;/a&gt;&lt;em&gt;この&lt;/em&gt;意味&lt;em&gt;受信&lt;/em&gt;ドットの左側に渡されるパラメータ。</target>
        </trans-unit>
        <trans-unit id="751813b87d30d6501d1bf6ea23fd73a02ca28ea0" translate="yes" xml:space="preserve">
          <source>In an inline function definition, you can use &lt;code&gt;noinline&lt;/code&gt; in front of any function-typed parameter to prevent the lambda that will be passed to it from also being inlined.</source>
          <target state="translated">インライン関数定義では、関数型パラメーターの前に &lt;code&gt;noinline&lt;/code&gt; を使用して、渡されるラムダもインライン化されないようにすることができます。</target>
        </trans-unit>
        <trans-unit id="751fca68ff5e9efd6f13ba9f691a416e15e88e6e" translate="yes" xml:space="preserve">
          <source>In any lists, you can find the position of an element using the functions &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/index-of&quot;&gt;&lt;code&gt;indexOf()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/last-index-of&quot;&gt;&lt;code&gt;lastIndexOf()&lt;/code&gt;&lt;/a&gt;. They return the first and the last position of an element equal to the given argument in the list. If there are no such elements, both functions return &lt;code&gt;-1&lt;/code&gt;.</source>
          <target state="translated">どのリストでも、関数&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/index-of&quot;&gt; &lt;code&gt;indexOf()&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/last-index-of&quot;&gt; &lt;code&gt;lastIndexOf()&lt;/code&gt; &lt;/a&gt;を使用して要素の位置を見つけることができます。それらは、リスト内の指定された引数に等しい要素の最初と最後の位置を返します。そのような要素がない場合、どちらの関数も &lt;code&gt;-1&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="c3c35f058a2881495687f9b24556ffc42c9b3b89" translate="yes" xml:space="preserve">
          <source>In approach it's quite similar to Futures, but one can think of a Future as returning a discrete element, whereby Rx returns a stream. However, similar to the previous, it also introduces a complete new way of thinking about our programming model, famously phrased as</source>
          <target state="translated">アプローチとしてはFuturesに非常に似ていますが、Futureは離散的な要素を返すと考えることができ、Rxはストリームを返すことになります。しかし、前のものと似ていますが、これはプログラミングモデルについての全く新しい考え方を導入しています。</target>
        </trans-unit>
        <trans-unit id="afaa57d188a4de777b467f6dcde31f2f2cfb5700" translate="yes" xml:space="preserve">
          <source>In case if any two entries are mapped to the equal keys, the value of the latter one will overwrite the value associated with the former one.</source>
          <target state="translated">2つのエントリがイコールキーにマッピングされている場合、後者の値が前者の値を上書きします。</target>
        </trans-unit>
        <trans-unit id="ab773dc6434fe9e51f59bd2f39f7407e2e315f54" translate="yes" xml:space="preserve">
          <source>In case if the resource is being closed due to an exception occurred in &lt;a href=&quot;use#kotlin%24use%28kotlin.use.T%2C+kotlin.Function1%28%28kotlin.use.T%2C+kotlin.use.R%29%29%29%2Fblock&quot;&gt;block&lt;/a&gt;, and the closing also fails with an exception, the latter is added to the &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/lang/Throwable.html#addSuppressed(java.lang.Throwable)&quot;&gt;suppressed&lt;/a&gt; exceptions of the former.</source>
          <target state="translated">&lt;a href=&quot;use#kotlin%24use%28kotlin.use.T%2C+kotlin.Function1%28%28kotlin.use.T%2C+kotlin.use.R%29%29%29%2Fblock&quot;&gt;ブロック&lt;/a&gt;で発生した例外が原因でリソースが閉じられていて、そのクローズも例外で失敗した場合、後者は前者の&lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/lang/Throwable.html#addSuppressed(java.lang.Throwable)&quot;&gt;抑制&lt;/a&gt;された例外に追加されます。</target>
        </trans-unit>
        <trans-unit id="753affb3f26053a8d6fe6a50898f37935f2da6a8" translate="yes" xml:space="preserve">
          <source>In case if the resource is being closed due to an exception occurred in &lt;a href=&quot;use#kotlin%24use(kotlin.use.T,%20kotlin.Function1((kotlin.use.T,%20kotlin.use.R)))/block&quot;&gt;block&lt;/a&gt;, and the closing also fails with an exception, the latter is added to the suppressed exceptions of the former.</source>
          <target state="translated">&lt;a href=&quot;use#kotlin%24use(kotlin.use.T,%20kotlin.Function1((kotlin.use.T,%20kotlin.use.R)))/block&quot;&gt;ブロック&lt;/a&gt;で例外が発生したためにリソースがクローズされていて、例外でクローズも失敗した場合、前者の抑制された例外に後者が追加されます。</target>
        </trans-unit>
        <trans-unit id="a99d3de27a9334d7d61ccdc4fea1d3937e232802" translate="yes" xml:space="preserve">
          <source>In case if there are non-blank lines with no leading whitespace characters (no indent at all) then the common indent is 0, and therefore this function doesn't change the indentation.</source>
          <target state="translated">空白でない行で先頭の空白文字がない(インデントが全くない)場合は、共通のインデントは0になりますので、この関数はインデントを変更しません。</target>
        </trans-unit>
        <trans-unit id="c60b20e0301bd757b71bb24ccc047d80b78f21b1" translate="yes" xml:space="preserve">
          <source>In case of a name conflict between the members of the dispatch receiver and the extension receiver, the extension receiver takes precedence. To refer to the member of the dispatch receiver you can use the &lt;a href=&quot;this-expressions#qualified&quot;&gt;qualified &lt;code&gt;this&lt;/code&gt; syntax&lt;/a&gt;.</source>
          <target state="translated">ディスパッチレシーバーと拡張レシーバーのメンバー間で名前が競合する場合、拡張レシーバーが優先されます。ディスパッチレシーバーのメンバーを参照するには、&lt;a href=&quot;this-expressions#qualified&quot;&gt;修飾された &lt;code&gt;this&lt;/code&gt; 構文を&lt;/a&gt;使用できます。</target>
        </trans-unit>
        <trans-unit id="2564f2a33e66657de3341732c5e625e51d4323de" translate="yes" xml:space="preserve">
          <source>In case of the extension property in a class, the instance of the class should be passed first and the instance of the extension receiver second.</source>
          <target state="translated">クラス内の拡張プロパティの場合は、そのクラスのインスタンスを先に渡し、拡張受信側のインスタンスを後に渡します。</target>
        </trans-unit>
        <trans-unit id="1a1fb30f33e29cde0e4a9adce651bb450975c80d" translate="yes" xml:space="preserve">
          <source>In case this type is based on an inner class, the returned list contains the type arguments provided for the innermost class first, then its outer class, and so on. For example, in the type &lt;code&gt;Outer&amp;lt;A, B&amp;gt;.Inner&amp;lt;C, D&amp;gt;&lt;/code&gt; the returned list is &lt;code&gt;[C, D, A, B]&lt;/code&gt;.</source>
          <target state="translated">この型が内部クラスに基づいている場合、返されるリストには、最初に最も内側のクラス、次にその外部クラスなどに提供される型引数が含まれます。たとえば、タイプ &lt;code&gt;Outer&amp;lt;A, B&amp;gt;.Inner&amp;lt;C, D&amp;gt;&lt;/code&gt; では、返されるリストは &lt;code&gt;[C, D, A, B]&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="744293bc64c3188af17bab32f33333fe2cad85c9" translate="yes" xml:space="preserve">
          <source>In case you want only some of the lambdas passed to an inline function to be inlined, you can mark some of your function parameters with the &lt;code&gt;noinline&lt;/code&gt; modifier:</source>
          <target state="translated">インライン関数に渡されるラムダの一部のみをインライン化する場合は、関数パラメーターの一部を &lt;code&gt;noinline&lt;/code&gt; 修飾子でマークできます。</target>
        </trans-unit>
        <trans-unit id="816f79d2ddebc85fd82a80af3cc580e6eeb81694" translate="yes" xml:space="preserve">
          <source>In case you're wondering about how &lt;code&gt;use&lt;/code&gt;, which is a function, can just be followed by a block like that, see the section on &lt;a href=&quot;functional-programming#receivers&quot;&gt;DSL support&lt;/a&gt;.</source>
          <target state="translated">関数である &lt;code&gt;use&lt;/code&gt; の後に、そのようなブロックを続ける方法について疑問がある場合は、&lt;a href=&quot;functional-programming#receivers&quot;&gt;DSLサポート&lt;/a&gt;に関するセクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="de1e14373afc30cdce829d5ccf1028c05a1345bf" translate="yes" xml:space="preserve">
          <source>In common code:</source>
          <target state="translated">共通のコードで</target>
        </trans-unit>
        <trans-unit id="dbd13320c78fae25fd6f48673f77aea087d10896" translate="yes" xml:space="preserve">
          <source>In essence, this allows for the following code:</source>
          <target state="translated">本質的には、これにより以下のようなコードが可能になります。</target>
        </trans-unit>
        <trans-unit id="b797e297636a01e5f39faa44903e3922322a2f0c" translate="yes" xml:space="preserve">
          <source>In fact, for declaring properties and initializing them from the primary constructor, Kotlin has a concise syntax:</source>
          <target state="translated">実際、プロパティの宣言やプライマリコンストラクタからの初期化については、Kotlinには簡潔な構文があります。</target>
        </trans-unit>
        <trans-unit id="8575e5bc9be645637c35224eaab5422d26408ea8" translate="yes" xml:space="preserve">
          <source>In further sections, these concepts are described in more detail along with the DSL to configure them in a project.</source>
          <target state="translated">後のセクションでは、これらの概念をプロジェクトで設定するためのDSLと一緒に、より詳細に説明します。</target>
        </trans-unit>
        <trans-unit id="093d33db378ee271b0948a0579ab35389d4e97d5" translate="yes" xml:space="preserve">
          <source>In general, for small projects, we recommend converting all the files at once.</source>
          <target state="translated">一般的に、小規模なプロジェクトの場合は、一度にすべてのファイルを変換することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="2ad6bf46a8b188e9bc3522dea93919d7678b502b" translate="yes" xml:space="preserve">
          <source>In general, identifiers may consist of letters, digits, and underscores, and may not begin with a digit. However, if you are writing code that e.g. autogenerates JSON based on identifiers and you want the JSON key to be a string that does not conform to these rules or that collides with a keyword, you can enclose it in backticks: &lt;code&gt;`I can't believe this is not an error!`&lt;/code&gt; is a valid identifier.</source>
          <target state="translated">一般に、識別子は文字、数字、アンダースコアで構成され、数字で始めることはできません。あなたが例えば自動生成識別子に基づいてJSONやキーワードでこれらの規則やその衝突に準拠していない文字列になるようにJSONのキーが欲しいというコードを書いている場合は、あなたはバッククォートで囲むことができます： &lt;code&gt;`I can't believe this is not an error!`&lt;/code&gt; は有効な識別子です。</target>
        </trans-unit>
        <trans-unit id="def8cf1480d12ae42f29a02a77be00f6fa6a05e6" translate="yes" xml:space="preserve">
          <source>In general, if a certain syntactic construction in Kotlin is optional and highlighted by the IDE as redundant, you should omit it in your code. Do not leave unnecessary syntactic elements in code just &quot;for clarity&quot;.</source>
          <target state="translated">一般的に、Kotlin のある構文の構成がオプションであり、IDE によって冗長であると強調されている場合は、コードの中でそれを省略するべきです。コードの中に不要な構文的要素を「わかりやすくするため」に残してはいけません。</target>
        </trans-unit>
        <trans-unit id="01b3fb6a7b9e95b734c635ce49024c6d660e14c4" translate="yes" xml:space="preserve">
          <source>In general, to create an instance of such a class, we need to provide the type arguments:</source>
          <target state="translated">一般的に、このようなクラスのインスタンスを作成するには、型の引数を提供する必要があります。</target>
        </trans-unit>
        <trans-unit id="450c32ce21d7e1cf7d82473c6445b4ccee4985e3" translate="yes" xml:space="preserve">
          <source>In generated code, the Kotlin compiler keeps a &lt;em&gt;wrapper&lt;/em&gt; for each inline class. Inline class instances can be represented at runtime either as wrappers or as the underlying type. This is similar to how &lt;code&gt;Int&lt;/code&gt; can be &lt;a href=&quot;basic-types#representation&quot;&gt;represented&lt;/a&gt; either as a primitive &lt;code&gt;int&lt;/code&gt; or as the wrapper &lt;code&gt;Integer&lt;/code&gt;.</source>
          <target state="translated">生成されたコードでは、Kotlinコンパイラは各インラインクラスの&lt;em&gt;ラッパー&lt;/em&gt;を保持し&lt;em&gt;ます&lt;/em&gt;。インラインクラスインスタンスは、実行時にラッパーまたは基になる型として表すことができます。これは、 &lt;code&gt;Int&lt;/code&gt; をプリミティブ &lt;code&gt;int&lt;/code&gt; またはラッパー &lt;code&gt;Integer&lt;/code&gt; として&lt;a href=&quot;basic-types#representation&quot;&gt;表す&lt;/a&gt;方法と似ています。</target>
        </trans-unit>
        <trans-unit id="fd80bee1bf4ef4cc9fdfdeda947dd40e1e56db38" translate="yes" xml:space="preserve">
          <source>In lambda expressions, spaces should be used around the curly braces, as well as around the arrow which separates the parameters from the body. If a call takes a single lambda, it should be passed outside of parentheses whenever possible.</source>
          <target state="translated">ラムダ式では、中括弧の周りや、パラメータと本文を区切る矢印の周りにスペースを使用する必要があります。呼び出しが単一のラムダを取る場合は、可能な限り括弧の外に渡さなければなりません。</target>
        </trans-unit>
        <trans-unit id="80c8a890c9d273e819066140d09ce2d0bc285c7d" translate="yes" xml:space="preserve">
          <source>In lambdas which are short and not nested, it's recommended to use the &lt;code&gt;it&lt;/code&gt; convention instead of declaring the parameter explicitly. In nested lambdas with parameters, parameters should be always declared explicitly.</source>
          <target state="translated">短く、ネストされていないラムダでは、パラメーターを明示的に宣言する代わりに &lt;code&gt;it&lt;/code&gt; 規則を使用することをお勧めします。パラメータを持つネストされたラムダでは、パラメータは常に明示的に宣言する必要があります。</target>
        </trans-unit>
        <trans-unit id="0f96591676e8e90474bcc2e9cbd0fe550a87c6d7" translate="yes" xml:space="preserve">
          <source>In long argument lists, put a line break after the opening parenthesis. Indent arguments by 4 spaces. Group multiple closely related arguments on the same line.</source>
          <target state="translated">長い引数リストでは、最初の括弧の後に改行を入れます。引数を4スペースでインデントする。密接に関連する複数の引数を同じ行にグループ化する。</target>
        </trans-unit>
        <trans-unit id="e70f274fab45a9ad1cf0f5234b5a4c58fefd78f6" translate="yes" xml:space="preserve">
          <source>In many cases, one does not need to use explicit cast operators in Kotlin, because the compiler tracks the &lt;code&gt;is&lt;/code&gt;-checks and &lt;a href=&quot;#unsafe-cast-operator&quot;&gt;explicit casts&lt;/a&gt; for immutable values and inserts (safe) casts automatically when needed:</source>
          <target state="translated">多くの場合、Kotlinで明示的なキャスト演算子を使用する必要はありません。これは、コンパイラが不変値の &lt;code&gt;is&lt;/code&gt; チェックと&lt;a href=&quot;#unsafe-cast-operator&quot;&gt;明示的なキャスト&lt;/a&gt;を追跡し、必要に応じて（安全な）キャストを自動的に挿入するためです。</target>
        </trans-unit>
        <trans-unit id="d05a001b4fb4f64cd4a87d987f4f265545ae66a8" translate="yes" xml:space="preserve">
          <source>In mixed-language projects, Kotlin source files should reside in the same source root as the Java source files, and follow the same directory structure (each file should be stored in the directory corresponding to each package statement).</source>
          <target state="translated">混合言語プロジェクトでは、Kotlin のソースファイルは Java のソースファイルと同じソースルートに存在し、同じディレクトリ構造に従うべきです (各ファイルは各パッケージ文に対応するディレクトリに格納されるべきです)。</target>
        </trans-unit>
        <trans-unit id="a772373d726c1ea1dd1e4b5bd74e75bb5171d98d" translate="yes" xml:space="preserve">
          <source>In modules that don't provide their own API, such as application modules, you can use experimental APIs without propagating the experimental status to your code. In this case, mark your code with the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-use-experimental/index&quot;&gt;@UseExperimental(Marker::class)&lt;/a&gt; annotation specifying the marker annotation of the experimental API:</source>
          <target state="translated">アプリケーションモジュールなど、独自のAPIを提供しないモジュールでは、試験的なステータスをコードに伝播せずに試験的なAPIを使用できます。この場合、実験的なAPIのマーカーアノテーションを指定する&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-use-experimental/index&quot;&gt;@UseExperimental（Marker :: class）&lt;/a&gt;アノテーションでコードをマークします。</target>
        </trans-unit>
        <trans-unit id="cfed7f25e3bb00e2797542765d6c2ca96af68b87" translate="yes" xml:space="preserve">
          <source>In most cases, Kotlin follows the Java coding conventions.</source>
          <target state="translated">ほとんどの場合、KotlinはJavaのコーディング規約に従っています。</target>
        </trans-unit>
        <trans-unit id="d126b0359662ea6c66b61b9e3af53b0d85339044" translate="yes" xml:space="preserve">
          <source>In multiline mode the expressions &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;$&lt;/code&gt; match just after or just before, respectively, a line terminator or the end of the input sequence.</source>
          <target state="translated">複数行モードでは、式 &lt;code&gt;^&lt;/code&gt; および &lt;code&gt;$&lt;/code&gt; は、それぞれ行末記号または入力シーケンスの終わりの直後または直前に一致します。</target>
        </trans-unit>
        <trans-unit id="6667a323602babcf47c04e12460b410e75814d22" translate="yes" xml:space="preserve">
          <source>In order to assemble an application, we also need to include the Kotlin standard library, i.e. &lt;code&gt;kotlin.js&lt;/code&gt;, which was included as a dependency, and the other libraries if any.</source>
          <target state="translated">アプリケーションをアセンブルするには、依存関係として含まれていたKotlin標準ライブラリ、つまり &lt;code&gt;kotlin.js&lt;/code&gt; と、存在する場合は他のライブラリも含める必要があります。</target>
        </trans-unit>
        <trans-unit id="034cc52464c28236e3f8c4183a0d3673ce621a3f" translate="yes" xml:space="preserve">
          <source>In order to avoid compatibility issues during an Xcode build, the plugin requires using a &lt;a href=&quot;https://docs.gradle.org/current/userguide/gradle_wrapper.html&quot;&gt;Gradle wrapper&lt;/a&gt;. To generate the wrapper automatically during execution of the &lt;code&gt;podspec&lt;/code&gt; task, run it with the parameter &lt;code&gt;-Pkotlin.native.cocoapods.generate.wrapper=true&lt;/code&gt;.</source>
          <target state="translated">Xcodeビルド中の互換性の問題を回避するために、プラグインは&lt;a href=&quot;https://docs.gradle.org/current/userguide/gradle_wrapper.html&quot;&gt;Gradleラッパー&lt;/a&gt;を使用する必要があります。 &lt;code&gt;podspec&lt;/code&gt; タスクの実行中にラッパーを自動的に生成するには、パラメーター &lt;code&gt;-Pkotlin.native.cocoapods.generate.wrapper=true&lt;/code&gt; を指定してラッパーを実行します。</target>
        </trans-unit>
        <trans-unit id="320ea67fc7a407c39652cf848b66d1bac7958814" translate="yes" xml:space="preserve">
          <source>In order to build a Kotlin project with Gradle, you should &lt;a href=&quot;#plugin-and-versions&quot;&gt;apply the Kotlin Gradle plugin to your project&lt;/a&gt; and &lt;a href=&quot;#configuring-dependencies&quot;&gt;configure dependencies&lt;/a&gt;.</source>
          <target state="translated">Gradleを使用してKotlinプロジェクトをビルド&lt;a href=&quot;#plugin-and-versions&quot;&gt;するには、Kotlin Gradleプラグインをプロジェクトに適用し、&lt;/a&gt;&lt;a href=&quot;#configuring-dependencies&quot;&gt;依存関係&lt;/a&gt;を構成する必要があります。</target>
        </trans-unit>
        <trans-unit id="4a047d1f6392366b3f681991fe461367b7be253f" translate="yes" xml:space="preserve">
          <source>In order to build a Kotlin project with Gradle, you should &lt;a href=&quot;#plugin-and-versions&quot;&gt;set up the &lt;em&gt;kotlin-gradle&lt;/em&gt; plugin&lt;/a&gt;, &lt;a href=&quot;#targeting-the-jvm&quot;&gt;apply it&lt;/a&gt; to your project and &lt;a href=&quot;#configuring-dependencies&quot;&gt;add &lt;em&gt;kotlin-stdlib&lt;/em&gt; dependencies&lt;/a&gt;. Those actions may also be performed automatically in IntelliJ IDEA by invoking &lt;strong&gt;Tools | Kotlin | Configure Kotlin&lt;/strong&gt; in &lt;strong&gt;Project&lt;/strong&gt; action.</source>
          <target state="translated">GradleのでKotlinのプロジェクトをビルドするためには、あなたがすべき&lt;a href=&quot;#plugin-and-versions&quot;&gt;設定&lt;em&gt;kotlin-のGradle&lt;/em&gt;プラグインを&lt;/a&gt;、&lt;a href=&quot;#targeting-the-jvm&quot;&gt;それを適用する&lt;/a&gt;プロジェクトにし、&lt;a href=&quot;#configuring-dependencies&quot;&gt;追加&lt;em&gt;kotlin-STDLIBの&lt;/em&gt;依存関係を&lt;/a&gt;。これらのアクションは、IntelliJ IDEAで&lt;strong&gt;Tools | コトリン| &lt;/strong&gt;&lt;strong&gt;プロジェクト&lt;/strong&gt;アクションで&lt;strong&gt;Kotlin&lt;/strong&gt;を&lt;strong&gt;構成し&lt;/strong&gt;ます。</target>
        </trans-unit>
        <trans-unit id="e347f51a9c40cc493b347c1bed8c2d5285726dad" translate="yes" xml:space="preserve">
          <source>In order to compile JavaScript code, you need to use the &lt;code&gt;js&lt;/code&gt; and &lt;code&gt;test-js&lt;/code&gt; goals for the &lt;code&gt;compile&lt;/code&gt; execution:</source>
          <target state="translated">JavaScriptコードをコンパイルするには、 &lt;code&gt;compile&lt;/code&gt; 実行に &lt;code&gt;js&lt;/code&gt; および &lt;code&gt;test-js&lt;/code&gt; ゴールを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="7888ab5509b34a7615518c3269c358c32f2dd548" translate="yes" xml:space="preserve">
          <source>In order to debug the application using IntelliJ IDEA, we need to perform two steps:</source>
          <target state="translated">IntelliJ IDEAを使ってアプリケーションをデバッグするためには、2つのステップを実行する必要があります。</target>
        </trans-unit>
        <trans-unit id="0d60abc6454bf0506cb62dd1ac746f025ab62610" translate="yes" xml:space="preserve">
          <source>In order to generate these bindings, we need to create a library definition &lt;code&gt;.def&lt;/code&gt; file that contains some information about the headers we need to generate. In our case we want to use the famous &lt;code&gt;libcurl&lt;/code&gt; library to make some HTTP calls, so we'll create a file named &lt;code&gt;libcurl.def&lt;/code&gt; with the following contents</source>
          <target state="translated">これらのバインディングを生成するには、生成する必要があるヘッダーに関する情報を含むライブラリ定義 &lt;code&gt;.def&lt;/code&gt; ファイルを作成する必要があります。この例では、有名な &lt;code&gt;libcurl&lt;/code&gt; ライブラリを使用してHTTP呼び出しを行いたいので、次の内容で &lt;code&gt;libcurl.def&lt;/code&gt; という名前のファイルを作成します。</target>
        </trans-unit>
        <trans-unit id="ffbf97f9cc48e7603dadd7a45b25bf4f6b7e3989" translate="yes" xml:space="preserve">
          <source>In order to run, we need the corresponding WAR(s) for deploying. We can generate these using the &lt;em&gt;war&lt;/em&gt; task in Gradle which can easily be executed via the Gradle tool window in IntelliJ IDEA.</source>
          <target state="translated">実行するには、デプロイするための対応するWARが必要です。これらはGradleで&lt;em&gt;war&lt;/em&gt;タスクを使用して生成できます。これはIntelliJ IDEAのGradleツールウィンドウから簡単に実行できます。</target>
        </trans-unit>
        <trans-unit id="24dcbfd34df21e70b79c4b2191a485e90cc3e450" translate="yes" xml:space="preserve">
          <source>In order to share the changes across the project developers &lt;code&gt;.idea/codeStyle&lt;/code&gt; folder, it has to be committed to VCS. Alternatively &lt;strong&gt;kotlin.code.style&lt;/strong&gt;=&lt;strong&gt;obsolete&lt;/strong&gt; can be used for projects configured with Gradle or Maven.</source>
          <target state="translated">プロジェクト開発者の &lt;code&gt;.idea/codeStyle&lt;/code&gt; フォルダー間で変更を共有するには、VCSにコミットする必要があります。あるいは、&lt;strong&gt;kotlin.code.style&lt;/strong&gt; = &lt;strong&gt;obsolete&lt;/strong&gt;は、GradleまたはMavenで構成されたプロジェクトに使用できます。</target>
        </trans-unit>
        <trans-unit id="155fb0f00f3221a063feea137fb0401c04ce9dd5" translate="yes" xml:space="preserve">
          <source>In order to share those changes for all project developers &lt;code&gt;.idea/codeStyle&lt;/code&gt; folder have to be committed to VCS.</source>
          <target state="translated">すべてのプロジェクト開発者がこれらの変更を共有するには、 &lt;code&gt;.idea/codeStyle&lt;/code&gt; フォルダーをVCSにコミットする必要があります。</target>
        </trans-unit>
        <trans-unit id="fa88cf692336fd455afd07788cc5c7d6ab06d938" translate="yes" xml:space="preserve">
          <source>In order to specify the module kind, we can add a configuration to our plugin as below</source>
          <target state="translated">モジュールの種類を指定するには、以下のようにプラグインに設定を追加します。</target>
        </trans-unit>
        <trans-unit id="59607fe0baf1ba77b3f9ca8983f516dc1d471c45" translate="yes" xml:space="preserve">
          <source>In order to support a potentially nullable type, the Objc header needs to define &lt;code&gt;myVal&lt;/code&gt; with a nullable return value.</source>
          <target state="translated">null可能性のある型をサポートするために、Objcヘッダーはnull可能の戻り値で &lt;code&gt;myVal&lt;/code&gt; を定義する必要があります。</target>
        </trans-unit>
        <trans-unit id="de88f4d0de61705bae1956451c94335904114bb9" translate="yes" xml:space="preserve">
          <source>In order to support a potentially nullable type, the Objective-C header needs to define &lt;code&gt;myVal&lt;/code&gt; with a nullable return value.</source>
          <target state="translated">潜在的にnull許容型をサポートするには、Objective-Cヘッダーで &lt;code&gt;myVal&lt;/code&gt; をnull許容戻り値で定義する必要があります。</target>
        </trans-unit>
        <trans-unit id="9aac89688353374371a7ae0f65a4346b1a58df3a" translate="yes" xml:space="preserve">
          <source>In order to use Gradle to target JavaScript, we need to use the &lt;code&gt;kotlin2js&lt;/code&gt; plugin as opposed to the &lt;code&gt;kotlin&lt;/code&gt; plugin.</source>
          <target state="translated">JavaScriptをターゲットにするのGradleを使用するために、我々は、使用する必要が &lt;code&gt;kotlin2js&lt;/code&gt; とは対照的に、プラグインを &lt;code&gt;kotlin&lt;/code&gt; プラグイン。</target>
        </trans-unit>
        <trans-unit id="33526a8ed38f3fde7c6b4f6af71779367c169bbc" translate="yes" xml:space="preserve">
          <source>In order to use Kotlin with node.js, we need to set the compiler option to use CommonJS. Once we do that, the output of the application should be accessible using the node module system.</source>
          <target state="translated">Kotlinをnode.jsで使うためには、コンパイラのオプションでCommonJSを使うように設定する必要があります。そうすれば、アプリケーションの出力はnodeモジュールシステムを使ってアクセスできるようになるはずです。</target>
        </trans-unit>
        <trans-unit id="5bdfd7a958cb3b5e6a62acec15106d2a72aa846c" translate="yes" xml:space="preserve">
          <source>In order to use coroutines as well as follow the examples in this guide, you need to add a dependency on &lt;code&gt;kotlinx-coroutines-core&lt;/code&gt; module as explained &lt;a href=&quot;https://github.com/kotlin/kotlinx.coroutines/blob/master/README.md#using-in-your-projects&quot;&gt;in the project README&lt;/a&gt;.</source>
          <target state="translated">このガイドの例に加えてコルーチンを使用するに&lt;a href=&quot;https://github.com/kotlin/kotlinx.coroutines/blob/master/README.md#using-in-your-projects&quot;&gt;は、プロジェクトのREADMEで&lt;/a&gt;説明されているように、 &lt;code&gt;kotlinx-coroutines-core&lt;/code&gt; モジュールへの依存関係を追加する必要があります。</target>
        </trans-unit>
        <trans-unit id="cc71e5241592939229f3aa2e6f5ed18f17024e17" translate="yes" xml:space="preserve">
          <source>In order to use coroutines as well as follow the examples in this guide, you need to add a dependency on the &lt;code&gt;kotlinx-coroutines-core&lt;/code&gt; module as explained &lt;a href=&quot;https://github.com/kotlin/kotlinx.coroutines/blob/master/README.md#using-in-your-projects&quot;&gt;in the project README&lt;/a&gt;.</source>
          <target state="translated">コルーチンを使用し、このガイドの例に従うには&lt;a href=&quot;https://github.com/kotlin/kotlinx.coroutines/blob/master/README.md#using-in-your-projects&quot;&gt;、プロジェクトREADMEで&lt;/a&gt;説明されているように、 &lt;code&gt;kotlinx-coroutines-core&lt;/code&gt; モジュールへの依存関係を追加する必要があります。</target>
        </trans-unit>
        <trans-unit id="1cc60ead46c9defc457295413372bae706d2254f" translate="yes" xml:space="preserve">
          <source>In order to use something from a package, it is sufficient to use the package name to fully qualify the name of the symbol at the place where you use the symbol:</source>
          <target state="translated">パッケージから何かを使用するためには、そのシンボルを使用する場所のシンボルの名前を完全に修飾するためにパッケージ名を使用すれば十分です。</target>
        </trans-unit>
        <trans-unit id="9abc8ef7836ac20fac6436adb16fe6c5da1f6518" translate="yes" xml:space="preserve">
          <source>In order to use this, we also need to include the Kotlin standard library in our application, i.e. &lt;code&gt;kotlin.js&lt;/code&gt;, which was included as a dependency. By default, Maven does not expand the JAR as part of the build process, so we would need to add an additional step in our build to do so.</source>
          <target state="translated">これを使用するには、アプリケーションにKotlin標準ライブラリ、つまり依存関係として含まれていた &lt;code&gt;kotlin.js&lt;/code&gt; も含める必要があります。デフォルトでは、Mavenはビルドプロセスの一部としてJARを拡張しないため、ビルドに追加のステップを追加する必要があります。</target>
        </trans-unit>
        <trans-unit id="a5c6ba86278357c55cc58dbde4e4e54ec8ffad3f" translate="yes" xml:space="preserve">
          <source>In other words, inline classes introduce a truly &lt;em&gt;new&lt;/em&gt; type, contrary to type aliases which only introduce an alternative name (alias) for an existing type:</source>
          <target state="translated">言い換えると、インラインクラスは、既存のタイプの代替名（エイリアス）のみを導入するタイプエイリアスとは対照的に、真に&lt;em&gt;新しい&lt;/em&gt;タイプを導入します。</target>
        </trans-unit>
        <trans-unit id="2fcd261cf566bdf17c9a0226c120616065441d92" translate="yes" xml:space="preserve">
          <source>In our DSL all the tag classes extend the same superclass &lt;code&gt;Tag&lt;/code&gt;. It's enough to annotate only the superclass with &lt;code&gt;@HtmlTagMarker&lt;/code&gt; and after that the Kotlin compiler will treat all the inherited classes as annotated:</source>
          <target state="translated">DSLでは、すべてのタグクラスが同じスーパークラス &lt;code&gt;Tag&lt;/code&gt; 拡張しています。 &lt;code&gt;@HtmlTagMarker&lt;/code&gt; でスーパークラスのみに注釈を付けるだけで十分です。その後、Kotlinコンパイラは継承されたすべてのクラスを注釈付きとして扱います。</target>
        </trans-unit>
        <trans-unit id="055ba8d22e98a479f59a07d7a075048bb0a20fe4" translate="yes" xml:space="preserve">
          <source>In our example, we have &lt;code&gt;main&lt;/code&gt; function that is turned into a coroutine using &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt; coroutine builder. Every coroutine builder, including &lt;code&gt;runBlocking&lt;/code&gt;, adds an instance of &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;CoroutineScope&lt;/a&gt; to the scope of its code block. We can launch coroutines in this scope without having to &lt;code&gt;join&lt;/code&gt; them explicitly, because an outer coroutine (&lt;code&gt;runBlocking&lt;/code&gt; in our example) does not complete until all the coroutines launched in its scope complete. Thus, we can make our example simpler:</source>
          <target state="translated">この例では、&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt;コルーチンビルダーを使用してコルーチンに変換される &lt;code&gt;main&lt;/code&gt; 関数があります。 &lt;code&gt;runBlocking&lt;/code&gt; を含むすべてのコルーチンビルダーは、コードブロックのスコープに&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;CoroutineScopeの&lt;/a&gt;インスタンスを追加します。外側のコルーチン（この例では &lt;code&gt;runBlocking&lt;/code&gt; ）は、そのスコープで起動されたすべてのコルーチンが完了するまで完了しないため、明示的に &lt;code&gt;join&lt;/code&gt; 必要なく、このスコープでコルーチンを起動できます。したがって、例をより単純にすることができます。</target>
        </trans-unit>
        <trans-unit id="a2b76b0743b9831752920932ff5a5625568afac3" translate="yes" xml:space="preserve">
          <source>In our example, we have a &lt;code&gt;main&lt;/code&gt; function that is turned into a coroutine using the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt; coroutine builder. Every coroutine builder, including &lt;code&gt;runBlocking&lt;/code&gt;, adds an instance of &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html&quot;&gt;CoroutineScope&lt;/a&gt; to the scope of its code block. We can launch coroutines in this scope without having to &lt;code&gt;join&lt;/code&gt; them explicitly, because an outer coroutine (&lt;code&gt;runBlocking&lt;/code&gt; in our example) does not complete until all the coroutines launched in its scope complete. Thus, we can make our example simpler:</source>
          <target state="translated">この例では、&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt;コルーチンビルダーを使用してコルーチンに変換される &lt;code&gt;main&lt;/code&gt; 関数があります。 &lt;code&gt;runBlocking&lt;/code&gt; を含むすべてのコルーチンビルダーは、&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html&quot;&gt;CoroutineScopeの&lt;/a&gt;インスタンスをそのコードブロックのスコープに追加します。スコープ内で起動されたすべてのコルーチンが完了するまで外部コルーチン（この例では &lt;code&gt;runBlocking&lt;/code&gt; ）が完了しないため、明示的に &lt;code&gt;join&lt;/code&gt; しなくても、このスコープ内でコルーチンを起動できます。したがって、例をより単純にすることができます。</target>
        </trans-unit>
        <trans-unit id="99c50d394fc235f8eeca8f1ea6662b1ec125d6bd" translate="yes" xml:space="preserve">
          <source>In our main function we create activity, call our test &lt;code&gt;doSomething&lt;/code&gt; function, and destroy activity after 500ms. This cancels all the coroutines that were launched which we can confirm by noting that it does not print onto the screen anymore if we wait:</source>
          <target state="translated">メイン関数でアクティビティを作成し、テストの &lt;code&gt;doSomething&lt;/code&gt; 関数を呼び出し、500ミリ秒後にアクティビティを破棄します。これにより、起動されたすべてのコルーチンがキャンセルされます。これを待つと、画面に印刷されなくなることに注意して確認できます。</target>
        </trans-unit>
        <trans-unit id="8567ecf52dbb46832894d62cc3534eccec93e924" translate="yes" xml:space="preserve">
          <source>In our main function we create the activity, call our test &lt;code&gt;doSomething&lt;/code&gt; function, and destroy the activity after 500ms. This cancels all the coroutines that were launched from &lt;code&gt;doSomething&lt;/code&gt;. We can see that because after the destruction of the activity no more messages are printed, even if we wait a little longer.</source>
          <target state="translated">メイン関数では、アクティビティを作成し、テスト &lt;code&gt;doSomething&lt;/code&gt; 関数を呼び出し、500ミリ秒後にアクティビティを破棄します。これにより、 &lt;code&gt;doSomething&lt;/code&gt; から起動されたすべてのコルーチンがキャンセルされます。アクティビティが破棄された後、もう少し待ってもメッセージが出力されないことがわかります。</target>
        </trans-unit>
        <trans-unit id="4e33cfe3a798666f120dafc2300d3a53a316781b" translate="yes" xml:space="preserve">
          <source>In particular, when defining extension functions for a class which are relevant for all clients of this class, put them in the same file where the class itself is defined. When defining extension functions that make sense only for a specific client, put them next to the code of that client. Do not create files just to hold &quot;all extensions of Foo&quot;.</source>
          <target state="translated">特に、あるクラスの拡張関数で、そのクラスのすべてのクライアントに関連するものを定義する場合は、そのクラス自体が定義されているのと同じファイルに記述してください。特定のクライアントにのみ意味のある拡張関数を定義する場合は、そのクライアントのコードの隣に置くようにしてください。Fooのすべての拡張子」を保持するためだけにファイルを作成しないでください。</target>
        </trans-unit>
        <trans-unit id="2683ff56288a092d85a9176c5ad7bb38fce09a9b" translate="yes" xml:space="preserve">
          <source>In practice some changes can't be accurately detected at compile time, so no warnings can be reported, but at least the users will be notified through Release notes of version A that a change is coming in version B.</source>
          <target state="translated">実際には、コンパイル時に正確に検出できない変更もあるので、警告を報告することはできませんが、少なくともユーザにはバージョンAのリリースノートを通して、バージョンBに変更があることが通知されます。</target>
        </trans-unit>
        <trans-unit id="1e5d38479fe45d55c10d169d2b3903a772bc6139" translate="yes" xml:space="preserve">
          <source>In practice, quite a bit of code is affected, so this can be considered a major code style update.</source>
          <target state="translated">実際には、かなりのコードが影響を受けているので、これはコードスタイルのメジャーな更新と考えることができます。</target>
        </trans-unit>
        <trans-unit id="57e5b70de31acdb27d8d2c67fea04b3d16fdd8a7" translate="yes" xml:space="preserve">
          <source>In practice, thread confinement is performed in large chunks, e.g. big pieces of state-updating business logic are confined to the single thread. The following example does it like that, running each coroutine in the single-threaded context to start with.</source>
          <target state="translated">実際には、大きな塊でスレッドを閉じ込めることが行われます。例えば、状態を更新するビジネスロジックの大きな部分はシングルスレッドに閉じ込められます。以下の例では、各コルーチンをシングルスレッドのコンテキストで実行しています。</target>
        </trans-unit>
        <trans-unit id="40969ff7e4fed85e58f626291a67f5273e20a573" translate="yes" xml:space="preserve">
          <source>In progressive mode, some fixes in language semantics can arrive immediately. All these fixes have two important properties:</source>
          <target state="translated">プログレッシブモードでは、言語セマンティクスのいくつかの修正がすぐに到着することがあります。これらの修正はすべて、2つの重要な性質を持っています。</target>
        </trans-unit>
        <trans-unit id="eff40107a95c01dec77eae6fb0ec0b96a075ea6f" translate="yes" xml:space="preserve">
          <source>In pure Kotlin projects, the recommended directory structure follows the package structure with the common root package omitted. For example, if all the code in the project is in the &lt;code&gt;org.example.kotlin&lt;/code&gt; package and its subpackages, files with the &lt;code&gt;org.example.kotlin&lt;/code&gt; package should be placed directly under the source root, and files in &lt;code&gt;org.example.kotlin.network.socket&lt;/code&gt; should be in the &lt;code&gt;network/socket&lt;/code&gt; subdirectory of the source root.</source>
          <target state="translated">純粋なKotlinプロジェクトでは、推奨されるディレクトリ構造は、共通のルートパッケージが省略されたパッケージ構造に従います。たとえば、プロジェクト内のすべてのコードが &lt;code&gt;org.example.kotlin&lt;/code&gt; パッケージとそのサブパッケージにある場合、 &lt;code&gt;org.example.kotlin&lt;/code&gt; パッケージのファイルはソースルートの直下に配置し、ファイルはorg.example.kotlinに配置する必要があります &lt;code&gt;org.example.kotlin.network.socket&lt;/code&gt; は、ソースルートの &lt;code&gt;network/socket&lt;/code&gt; サブディレクトリにある必要があります。</target>
        </trans-unit>
        <trans-unit id="d10877f2d49f4fb7859f1ddc63051feb0cebe60b" translate="yes" xml:space="preserve">
          <source>In pure Kotlin projects, the recommended directory structure is to follow the package structure with the common root package omitted (e.g. if all the code in the project is in the &quot;org.example.kotlin&quot; package and its subpackages, files with the &quot;org.example.kotlin&quot; package should be placed directly under the source root, and files in &quot;org.example.kotlin.foo.bar&quot; should be in the &quot;foo/bar&quot; subdirectory of the source root).</source>
          <target state="translated">純粋なKotlinプロジェクトでは、共通のルートパッケージを省略したパッケージ構造に従うことが推奨されます (例えば、プロジェクト内のすべてのコードが &quot;org.example.kotlin &quot;パッケージとそのサブパッケージに含まれている場合、&quot;org.example.kotlin &quot;パッケージのファイルはソースルートの直下に、&quot;org.example.kotlin.foo.bar &quot;のファイルはソースルートの &quot;foo/bar &quot;サブディレクトリに置くべきです)。</target>
        </trans-unit>
        <trans-unit id="c30c378469f41e6f1d1072007ebada7e490b3451" translate="yes" xml:space="preserve">
          <source>In scratches and worksheets, you can write any valid Kotlin code. Syntax highlighting, auto-completion, and the other IntelliJ IDEA code editing features are all supported too. Note that there's no need for declaring the &lt;code&gt;main&lt;/code&gt; function: all the code you write is executed as if it would be in the body of &lt;code&gt;main&lt;/code&gt;.</source>
          <target state="translated">スクラッチとワークシートには、有効なKotlinコードを記述できます。構文の強調表示、オートコンプリート、およびその他のIntelliJIDEAコード編集機能もすべてサポートされています。 &lt;code&gt;main&lt;/code&gt; 関数を宣言する必要はないことに注意してください。作成するすべてのコードは、 &lt;code&gt;main&lt;/code&gt; の本体にあるかのように実行されます。</target>
        </trans-unit>
        <trans-unit id="7a5be9888b7ba5a318d3261861baf4d32fa8861a" translate="yes" xml:space="preserve">
          <source>In short: &lt;em&gt;think carefully through your declarations of integers, and be absolutely certain that the value will never ever need to be larger than the limits of the type!&lt;/em&gt; If you need an integer of unlimited size, use the non-primitive type &lt;code&gt;BigInteger&lt;/code&gt;.</source>
          <target state="translated">つまり&lt;em&gt;、整数の宣言を注意深く検討し、値が型の制限よりも大きくなる必要がないことを絶対に確認してください。&lt;/em&gt;サイズが無制限の整数が必要な場合は、非プリミティブ型 &lt;code&gt;BigInteger&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="4a3b75ce2c9b15401d05148e77e0306873596e7e" translate="yes" xml:space="preserve">
          <source>In situations like this we can use the &lt;code&gt;dynamic&lt;/code&gt; type, which allows us to work with dynamic types when targeting JavaScript. The following variable is declared as &lt;code&gt;dynamic&lt;/code&gt; meaning that whatever we invoke on it will not result in a compile-time error:</source>
          <target state="translated">このような状況では、 &lt;code&gt;dynamic&lt;/code&gt; タイプを使用できます。これにより、JavaScriptをターゲットにするときに動的タイプを操作できます。次の変数は &lt;code&gt;dynamic&lt;/code&gt; として宣言されています。これは、その変数を呼び出してもコンパイル時エラーが発生しないことを意味します。</target>
        </trans-unit>
        <trans-unit id="55bd36b85c22e6a1c4d10234a638ea714c3940ad" translate="yes" xml:space="preserve">
          <source>In some cases (for example, to support overloads), Kotlin compiler mangles names of generated functions and attributes in JavaScript code. To control the generated names, you can use the &lt;code&gt;@JsName&lt;/code&gt; annotation:</source>
          <target state="translated">場合によっては（たとえば、オーバーロードをサポートするために）、KotlinコンパイラーはJavaScriptコードで生成された関数と属性の名前をマングルします。生成された名前を制御するには、 &lt;code&gt;@JsName&lt;/code&gt; アノテーションを使用できます。</target>
        </trans-unit>
        <trans-unit id="f1f62f22b0a379feb738d1ada9b061745859834e" translate="yes" xml:space="preserve">
          <source>In some cases (for example, to support overloads), the Kotlin compiler mangles the names of generated functions and attributes in JavaScript code. To control the generated names, you can use the &lt;code&gt;@JsName&lt;/code&gt; annotation:</source>
          <target state="translated">場合によっては（たとえば、オーバーロードをサポートするために）、KotlinコンパイラーはJavaScriptコードで生成された関数と属性の名前をマングルします。生成される名前を制御するには、 &lt;code&gt;@JsName&lt;/code&gt; アノテーションを使用できます。</target>
        </trans-unit>
        <trans-unit id="8f1f57175de66b286d8ac98729c81851940d41f3" translate="yes" xml:space="preserve">
          <source>In some cases functions with no arguments might be interchangeable with read-only properties. Although the semantics are similar, there are some stylistic conventions on when to prefer one to another.</source>
          <target state="translated">場合によっては、引数を持たない関数が読み取り専用のプロパティと互換性があるかもしれません。セマンティクスは似ていますが、いつ別のものを好むかについては、いくつかの文体上の決まりがあります。</target>
        </trans-unit>
        <trans-unit id="4526b2f446cfa690eb7c5baadbe7c8dea021438f" translate="yes" xml:space="preserve">
          <source>In some ways, this is easier to read because the operations are specified in the order they are applied to the values. The result will be an immutable &lt;code&gt;List&amp;lt;T&amp;gt;&lt;/code&gt;, where &lt;code&gt;T&lt;/code&gt; is whichever type is produced by the transformations you use (in this case, &lt;code&gt;String&lt;/code&gt;). If you need a mutable list, call &lt;code&gt;toMutableList()&lt;/code&gt; at the end. If you want a set, call &lt;code&gt;toSet()&lt;/code&gt; or &lt;code&gt;toMutableSet()&lt;/code&gt; at the end. If you want to transform a collection into a map, call &lt;code&gt;associateBy()&lt;/code&gt;, which takes two lambdas that specify how to extract the key and the value from each element: &lt;code&gt;people.associateBy({it.ssn}, {it.name})&lt;/code&gt; (you can omit the second lambda if you want the entire element to be the value, and you can call &lt;code&gt;toMutableMap()&lt;/code&gt; at the end if you want the result to be mutable).</source>
          <target state="translated">いくつかの点で、操作は値に適用される順序で指定されるため、これは読みやすくなります。結果は不変の &lt;code&gt;List&amp;lt;T&amp;gt;&lt;/code&gt; になります &lt;code&gt;T&lt;/code&gt; は、使用する変換（この場合は &lt;code&gt;String&lt;/code&gt; ）によって生成されるタイプです。変更可能なリストが必要な場合は、最後に &lt;code&gt;toMutableList()&lt;/code&gt; を呼び出します。セットが必要な場合は、最後に &lt;code&gt;toSet()&lt;/code&gt; または &lt;code&gt;toMutableSet()&lt;/code&gt; を呼び出します。コレクションをマップに変換する場合は、 &lt;code&gt;associateBy()&lt;/code&gt; 呼び出します。これは、各要素からキーと値を抽出する方法を指定する2つのラムダを取得します &lt;code&gt;people.associateBy({it.ssn}, {it.name})&lt;/code&gt; （要素全体を値にする場合は、2番目のラムダを省略できます。結果を変更可能にする場合は、最後に &lt;code&gt;toMutableMap()&lt;/code&gt; を呼び出します）。</target>
        </trans-unit>
        <trans-unit id="482c7a83b939d337af8bf0cb41a70749c1cb67ed" translate="yes" xml:space="preserve">
          <source>In spite of the &lt;code&gt;object&lt;/code&gt; keyword being used, a new instance of the anonymous class will be created whenever the object expression is evaluated.</source>
          <target state="translated">&lt;code&gt;object&lt;/code&gt; キーワードが使用されているにもかかわらず、オブジェクト式が評価されるたびに、匿名クラスの新しいインスタンスが作成されます。</target>
        </trans-unit>
        <trans-unit id="10fed13cfcbccf5e09d7648e3ceabcf9a0d8e2f5" translate="yes" xml:space="preserve">
          <source>In spite of this syntactical convenience, the companion object is a proper object on its own, and can have its own supertypes - and you can assign it to a variable and pass it around. If you're integrating with Java code and need a true &lt;code&gt;static&lt;/code&gt; member, you can &lt;a href=&quot;annotations&quot;&gt;annotate&lt;/a&gt; a member inside a companion object with &lt;code&gt;@JvmStatic&lt;/code&gt;.</source>
          <target state="translated">この構文上の便利さにもかかわらず、コンパニオンオブジェクトはそれ自体が適切なオブジェクトであり、独自のスーパータイプを持つことができます。また、それを変数に割り当てて渡すことができます。Javaコードと統合していて、真の &lt;code&gt;static&lt;/code&gt; メンバーが必要な場合は、コンパニオンオブジェクト内のメンバーに &lt;code&gt;@JvmStatic&lt;/code&gt; で&lt;a href=&quot;annotations&quot;&gt;注釈を付ける&lt;/a&gt;ことができます。</target>
        </trans-unit>
        <trans-unit id="8be34c3c318a79f1a61390cd86ad3bb03f42aee7" translate="yes" xml:space="preserve">
          <source>In subsequent tutorials we'll show how you can influence the files generated, for example, change location, prefix and suffixes, and how you can work with modules.</source>
          <target state="translated">以降のチュートリアルでは、生成されたファイルにどのように影響を与えることができるのか、例えば場所の変更、接頭辞や接尾辞の変更、モジュールの操作方法などを説明します。</target>
        </trans-unit>
        <trans-unit id="bc19aea0692b9f67e799748ba127b1fc2dfa9708" translate="yes" xml:space="preserve">
          <source>In tests (and &lt;strong&gt;only&lt;/strong&gt; in tests), it's acceptable to use method names with spaces enclosed in backticks. (Note that such method names are currently not supported by the Android runtime.) Underscores in method names are also allowed in test code.</source>
          <target state="translated">テスト（およびテスト&lt;strong&gt;のみ&lt;/strong&gt;）では、スペースをバッククォートで囲んだメソッド名を使用できます。（このようなメソッド名は現在、Androidランタイムではサポートされていないことに注意してください。）メソッド名のアンダースコアは、テストコードでも許可されています。</target>
        </trans-unit>
        <trans-unit id="de0700bb726b0915ca84006a652a9bb020053b41" translate="yes" xml:space="preserve">
          <source>In tests (and only in tests), it's acceptable to use method names with spaces enclosed in backticks. (Note that such method names are currently not supported by the Android runtime.) Underscores in method names are also allowed in test code.</source>
          <target state="translated">テストでは(テストでのみ)、バックトークで囲まれたスペース付きのメソッド名を使用しても構いません。(このようなメソッド名は現在のところ Android ランタイムではサポートされていないことに注意してください)。メソッド名のアンダースコアはテストコードでも使用可能です。</target>
        </trans-unit>
        <trans-unit id="e4ad3e9e93913c50444eb70a3c6d491b3cf74240" translate="yes" xml:space="preserve">
          <source>In that case you need to use the spread operator &lt;code&gt;*&lt;/code&gt; to pass the &lt;code&gt;IntArray&lt;/code&gt;:</source>
          <target state="translated">その場合は、スプレッド演算子 &lt;code&gt;*&lt;/code&gt; を使用して &lt;code&gt;IntArray&lt;/code&gt; を渡す必要があります。</target>
        </trans-unit>
        <trans-unit id="a1e90ae09efa8b0693d6eb0e54489eb2ffa5613b" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;#debugging-coroutines-and-threads&quot;&gt;debug mode&lt;/a&gt;, it outputs something like this:</source>
          <target state="translated">で&lt;a href=&quot;#debugging-coroutines-and-threads&quot;&gt;、デバッグモードで&lt;/a&gt;は、このようなものを出力します。</target>
        </trans-unit>
        <trans-unit id="dfa4bedab09a124fc51fd33f0b20a721f3509f7a" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;#enabling-experimental-features&quot;&gt;experimental mode&lt;/a&gt;, you can specify any variant name (not only flavor), e.g. &lt;code&gt;freeDebug&lt;/code&gt; or &lt;code&gt;freeRelease&lt;/code&gt; will work as well.</source>
          <target state="translated">では&lt;a href=&quot;#enabling-experimental-features&quot;&gt;、実験モードで&lt;/a&gt;使用すると、任意のバリアント名（味だけではなく）を指定することができ、例えば、 &lt;code&gt;freeDebug&lt;/code&gt; または &lt;code&gt;freeRelease&lt;/code&gt; は同様に動作します。</target>
        </trans-unit>
        <trans-unit id="34502d3bacebdc9ab51090cbc1ee8b5aa02dcb57" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;libnative_api.h&lt;/code&gt;, we'll find the following code. We will discuss the code in parts to make it easier to understand.</source>
          <target state="translated">で &lt;code&gt;libnative_api.h&lt;/code&gt; 、我々は次のコードを見つけることができます。わかりやすくするために、コードを部分的に説明します。</target>
        </trans-unit>
        <trans-unit id="97cbe1bbd40fde30fcff61322aab402c1acd97ce" translate="yes" xml:space="preserve">
          <source>In the Gradle dependencies you use add the &lt;code&gt;kotlin-kapt&lt;/code&gt; plugin and replace &lt;code&gt;annotationProcessor&lt;/code&gt; with &lt;code&gt;kapt&lt;/code&gt;:</source>
          <target state="translated">Gradleの依存関係では、 &lt;code&gt;kotlin-kapt&lt;/code&gt; プラグインを追加し、 &lt;code&gt;annotationProcessor&lt;/code&gt; を &lt;code&gt;kapt&lt;/code&gt; に置き換えます。</target>
        </trans-unit>
        <trans-unit id="a87144873c9b9ee0a65c1c2fda83f3948fb32756" translate="yes" xml:space="preserve">
          <source>In the JavaScript world, a completely different set of APIs is availiable, so one could instead implement logging to the console:</source>
          <target state="translated">JavaScript の世界では、全く異なる API のセットが利用可能なので、代わりにコンソールへのロギングを実装することができます。</target>
        </trans-unit>
        <trans-unit id="cc47ebd8b09857b2d92aa6e80c268cb28a620e3a" translate="yes" xml:space="preserve">
          <source>In the Kotlin Gradle DSL, there is also a shortcut for setting the CommonJS module kind:</source>
          <target state="translated">Kotlin Gradle DSLでは、CommonJSモジュールの種類を設定するショートカットもあります。</target>
        </trans-unit>
        <trans-unit id="952c75185ceff6a4ea2264e236a32b30e1121e70" translate="yes" xml:space="preserve">
          <source>In the code above, the parameter &lt;code&gt;combine&lt;/code&gt; has a &lt;a href=&quot;#function-types&quot;&gt;function type&lt;/a&gt;&lt;code&gt;(R, T) -&amp;gt; R&lt;/code&gt;, so it accepts a function that takes two arguments of types &lt;code&gt;R&lt;/code&gt; and &lt;code&gt;T&lt;/code&gt; and returns a value of type &lt;code&gt;R&lt;/code&gt;. It is &lt;a href=&quot;#invoking-a-function-type-instance&quot;&gt;invoked&lt;/a&gt; inside the &lt;em&gt;for&lt;/em&gt;-loop, and the return value is then assigned to &lt;code&gt;accumulator&lt;/code&gt;.</source>
          <target state="translated">上記のコードでは、パラメータは &lt;code&gt;combine&lt;/code&gt; 持つ&lt;a href=&quot;#function-types&quot;&gt;機能タイプ&lt;/a&gt; &lt;code&gt;(R, T) -&amp;gt; R&lt;/code&gt; が受け入れるように、種類の二つの引数を取る関数は &lt;code&gt;R&lt;/code&gt; と &lt;code&gt;T&lt;/code&gt; 型の戻り値 &lt;code&gt;R&lt;/code&gt; を。これは&lt;em&gt;for&lt;/em&gt;ループ内で&lt;a href=&quot;#invoking-a-function-type-instance&quot;&gt;呼び出さ&lt;/a&gt;れ、戻り値は &lt;code&gt;accumulator&lt;/code&gt; に割り当てられます。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="983dc81454e62d4d8dfeb15d4d6704ae3670a9b1" translate="yes" xml:space="preserve">
          <source>In the example above, the production sources for the JVM target are compiled by its &lt;code&gt;main&lt;/code&gt; compilation and therefore include the sources and dependencies from the source sets &lt;code&gt;jvmMain&lt;/code&gt; and &lt;code&gt;commonMain&lt;/code&gt; (due to the &lt;em&gt;depends on&lt;/em&gt; relation):</source>
          <target state="translated">上記の例では、JVMターゲットの本番ソースは &lt;code&gt;main&lt;/code&gt; コンパイルによってコンパイルされるため、ソースセット &lt;code&gt;jvmMain&lt;/code&gt; および &lt;code&gt;commonMain&lt;/code&gt; からのソースと依存関係が含まれます（&lt;em&gt;依存&lt;/em&gt;関係による）。</target>
        </trans-unit>
        <trans-unit id="92a4732d4ba58bb8eb4b7a1a153809f54718cd39" translate="yes" xml:space="preserve">
          <source>In the example below, we assume that there is a &lt;code&gt;DbModel&lt;/code&gt; base class, and that every subclass has got a parameterless primary constructor. In the inline function, &lt;code&gt;T&lt;/code&gt; is reified, so we can get the class metadata. We pass this to the function that does the real work of talking to the database.</source>
          <target state="translated">以下の例では、 &lt;code&gt;DbModel&lt;/code&gt; 基本クラスがあり、すべてのサブクラスがパラメーターなしのプライマリコンストラクターを持っていると想定しています。インライン関数では &lt;code&gt;T&lt;/code&gt; が具体化されているため、クラスのメタデータを取得できます。これを、データベースと対話する実際の作業を行う関数に渡します。</target>
        </trans-unit>
        <trans-unit id="f9725b5629cf5c05b1dabad8df3abc795d27f14a" translate="yes" xml:space="preserve">
          <source>In the example we have the most popular ways to pass or receive a string in the C language. We should take the return of &lt;code&gt;return_string&lt;/code&gt; with care. In general, it is best to make sure we use the right function to dispose the returned &lt;code&gt;char*&lt;/code&gt; with the right &lt;code&gt;free(..)&lt;/code&gt; function call.</source>
          <target state="translated">この例では、C言語で文字列を渡したり受け取ったりする最も一般的な方法があります。 &lt;code&gt;return_string&lt;/code&gt; の戻りには注意が必要です。一般に、正しい関数を使用して、返された &lt;code&gt;char*&lt;/code&gt; を正しい &lt;code&gt;free(..)&lt;/code&gt; 関数呼び出しで破棄することを確認することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="45b64e498fcd11490ca143779a88435b7d9e0b0c" translate="yes" xml:space="preserve">
          <source>In the following example, &lt;code&gt;findViewById()&lt;/code&gt; is only invoked once:</source>
          <target state="translated">次の例では、 &lt;code&gt;findViewById()&lt;/code&gt; は1回だけ呼び出されます。</target>
        </trans-unit>
        <trans-unit id="8cf0c93c6e85cb80e10b5e71f71e2e6899fc70c7" translate="yes" xml:space="preserve">
          <source>In the generated Kotlin declarations, we see that &lt;code&gt;str&lt;/code&gt; is represented as &lt;code&gt;CValuesRef&amp;lt;ByteVar/&amp;gt;?&lt;/code&gt;. The type is nullable, and we can simply pass Kotlin &lt;code&gt;null&lt;/code&gt; as the parameter value.</source>
          <target state="translated">生成されたKotlin宣言では、 &lt;code&gt;str&lt;/code&gt; が &lt;code&gt;CValuesRef&amp;lt;ByteVar/&amp;gt;?&lt;/code&gt; として表されていることがわかりますか？。タイプはnull可能で、パラメーター値としてKotlin &lt;code&gt;null&lt;/code&gt; を単に渡すことができます。</target>
        </trans-unit>
        <trans-unit id="6ffd682e74db1be23092050eecf5e03af23b3260" translate="yes" xml:space="preserve">
          <source>In the generated code, the &lt;code&gt;provideDelegate&lt;/code&gt; method is called to initialize the auxiliary &lt;code&gt;prop$delegate&lt;/code&gt; property. Compare the generated code for the property declaration &lt;code&gt;val prop: Type by MyDelegate()&lt;/code&gt; with the generated code &lt;a href=&quot;delegated-properties#translation-rules&quot;&gt;above&lt;/a&gt; (when the &lt;code&gt;provideDelegate&lt;/code&gt; method is not present):</source>
          <target state="translated">生成されたコードで、 &lt;code&gt;provideDelegate&lt;/code&gt; メソッドが呼び出され、補助 &lt;code&gt;prop$delegate&lt;/code&gt; プロパティが初期化されます。プロパティ宣言のために生成されたコードを比較 &lt;code&gt;val prop: Type by MyDelegate()&lt;/code&gt; 生成されたコードを有する&lt;a href=&quot;delegated-properties#translation-rules&quot;&gt;上記&lt;/a&gt;（場合 &lt;code&gt;provideDelegate&lt;/code&gt; の方法が存在しません）。</target>
        </trans-unit>
        <trans-unit id="f86f30c4d84e613891c93b386289b1fcc35ce4d5" translate="yes" xml:space="preserve">
          <source>In the last line &lt;code&gt;button&lt;/code&gt; is referenced by &lt;code&gt;id&lt;/code&gt; using the &lt;a href=&quot;android-plugin&quot;&gt;Kotlin Android Extensions&lt;/a&gt; plugin. Consider using this plugin as an alternative which allows you to keep binding logic in code and have the concise syntax at the same time.</source>
          <target state="translated">最後の行では、 &lt;code&gt;button&lt;/code&gt; は&lt;a href=&quot;android-plugin&quot;&gt;Kotlin Android Extensions&lt;/a&gt;プラグインを使用して &lt;code&gt;id&lt;/code&gt; によって参照されます。このプラグインを代替ロジックとして使用することを検討してください。これにより、コードのバインディングロジックを維持し、同時に簡潔な構文を使用できます。</target>
        </trans-unit>
        <trans-unit id="7da80e212e3fb5a8c2cf3d597abb266f174acf51" translate="yes" xml:space="preserve">
          <source>In the last line, there's an implicit &lt;code&gt;this.&lt;/code&gt; in front of both &lt;code&gt;memberFunction()&lt;/code&gt; and &lt;code&gt;memberProperty&lt;/code&gt; (if these exist on the type of &lt;code&gt;someExpression&lt;/code&gt;). The return value is that of the last expression.</source>
          <target state="translated">最後の行には、暗黙の &lt;code&gt;this.&lt;/code&gt; &lt;code&gt;memberFunction()&lt;/code&gt; と &lt;code&gt;memberProperty&lt;/code&gt; の両方の前（これらが &lt;code&gt;someExpression&lt;/code&gt; の型に存在する場合）。戻り値は最後の式の戻り値です。</target>
        </trans-unit>
        <trans-unit id="21de312c94f28c9a74e944cc50e80500b0df440a" translate="yes" xml:space="preserve">
          <source>In the next dialog, provide the project details:</source>
          <target state="translated">次のダイアログでは、プロジェクトの詳細を入力します。</target>
        </trans-unit>
        <trans-unit id="fb8d123847c0bf27cf6ffe6e978d7163ff9a921d" translate="yes" xml:space="preserve">
          <source>In the old model, common and platform-specific code needed to be placed in separate modules, linked by &lt;code&gt;expectedBy&lt;/code&gt; dependencies. Now, common and platform-specific code is placed in different source roots of the same module, making projects easier to configure.</source>
          <target state="translated">古いモデルでは、一般的なコードとプラットフォーム固有のコードを、 &lt;code&gt;expectedBy&lt;/code&gt; 依存関係によってリンクされた別々のモジュールに配置する必要がありました。現在、共通のプラットフォーム固有のコードは、同じモジュールの異なるソースルートに配置されており、プロジェクトの構成が容易になっています。</target>
        </trans-unit>
        <trans-unit id="ca766f4efd26534c30d9c87798187848fcb65628" translate="yes" xml:space="preserve">
          <source>In the presence of &lt;code&gt;maven-publish&lt;/code&gt; plugin the publications for all the binaries built are created. The plugin uses Gradle metadata to publish the artifacts so this feature must be enabled (see the &lt;a href=&quot;#dependencies&quot;&gt;dependencies&lt;/a&gt; section).</source>
          <target state="translated">&lt;code&gt;maven-publish&lt;/code&gt; プラグインが存在する場合、ビルドされたすべてのバイナリのパブリケーションが作成されます。プラグインはGradleメタデータを使用してアーティファクトを公開するため、この機能を有効にする必要があります（&lt;a href=&quot;#dependencies&quot;&gt;依存関係の&lt;/a&gt;セクションを参照）。</target>
        </trans-unit>
        <trans-unit id="d60dd59e4676a95bd7097287912e2ec3768e0f9a" translate="yes" xml:space="preserve">
          <source>In the previous example the JavaScript module exports a single package. However, some JavaScript libraries export multiple packages from within a module. This case is also supported by Kotlin, though you have to declare a new &lt;code&gt;.kt&lt;/code&gt; file for each package you import.</source>
          <target state="translated">前の例では、JavaScriptモジュールは単一のパッケージをエクスポートします。ただし、一部のJavaScriptライブラリは、モジュール内から複数のパッケージをエクスポートします。このケースはKotlinでもサポートされていますが、インポートするパッケージごとに新しい &lt;code&gt;.kt&lt;/code&gt; ファイルを宣言する必要があります。</target>
        </trans-unit>
        <trans-unit id="42d1f7acaeec00a73953ae801ded4c35e710f59f" translate="yes" xml:space="preserve">
          <source>In the tutorial we will learn:</source>
          <target state="translated">チュートリアルでは、私たちは学びます。</target>
        </trans-unit>
        <trans-unit id="5c983473a452d20ce90bb4b7f97f64c188d78e2f" translate="yes" xml:space="preserve">
          <source>In the tutorial we:</source>
          <target state="translated">チュートリアルでは、私たち。</target>
        </trans-unit>
        <trans-unit id="91d34ec07b8ea3ab8718a88b953168add8f0c256" translate="yes" xml:space="preserve">
          <source>In these examples &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-exception-handler/index.html&quot;&gt;CoroutineExceptionHandler&lt;/a&gt; is always installed to a coroutine that is created in &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope&lt;/a&gt;. It does not make sense to install an exception handler to a coroutine that is launched in the scope of the main &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt;, since the main coroutine is going to be always cancelled when its child completes with exception despite the installed handler.</source>
          <target state="translated">これらの例では、&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-exception-handler/index.html&quot;&gt;CoroutineExceptionHandler&lt;/a&gt;は常に&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope&lt;/a&gt;で作成されたコルーチンにインストールされます。メインの&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlockingの&lt;/a&gt;スコープで起動されたコルーチンに例外ハンドラーをインストールすることは意味がありません。これは、インストールされたハンドラーにもかかわらず、子が例外を完了したときにメインコルーチンが常にキャンセルされるためです。</target>
        </trans-unit>
        <trans-unit id="095e7f10496f59e9c1f965ea0b808ca458b5529c" translate="yes" xml:space="preserve">
          <source>In this case the compiler will not be downloaded by the plugin.</source>
          <target state="translated">この場合、コンパイラはプラグインからダウンロードされません。</target>
        </trans-unit>
        <trans-unit id="f1f881dff617021acda0968035a0c51bb38a1c2d" translate="yes" xml:space="preserve">
          <source>In this case, JQuery will be imported as a module named &lt;code&gt;jquery&lt;/code&gt;. Alternatively, it can be used as a $-object, depending on what module system Kotlin compiler is configured to use.</source>
          <target state="translated">この場合、JQueryは &lt;code&gt;jquery&lt;/code&gt; という名前のモジュールとしてインポートされます。または、Kotlinコンパイラーが使用するように構成されているモジュールシステムに応じて、$オブジェクトとして使用できます。</target>
        </trans-unit>
        <trans-unit id="c032e19443eb1eff2c0c1528c6eb2e5d72dfce23" translate="yes" xml:space="preserve">
          <source>In this case, we've set the output of our compilation to the &lt;code&gt;scripts&lt;/code&gt; folder. On running the application we should see the following output:</source>
          <target state="translated">この例では、コンパイルの出力を &lt;code&gt;scripts&lt;/code&gt; フォルダーに設定しています。アプリケーションを実行すると、次の出力が表示されます。</target>
        </trans-unit>
        <trans-unit id="de0ac72463e7c41b8825d92484726f740a2112b2" translate="yes" xml:space="preserve">
          <source>In this dense code, in addition to collection transformations, you can see such handy Kotlin features as local functions and the &lt;a href=&quot;../reference/null-safety#elvis-operator&quot;&gt;elvis operator&lt;/a&gt;&lt;code&gt;?:&lt;/code&gt; that allow to express &lt;a href=&quot;../reference/idioms&quot;&gt;idioms&lt;/a&gt; like &quot;take the value if it is positive or else use length&quot; with a concise and readable expressions like &lt;code&gt;.takeIf { it &amp;gt;= 0 } ?: s.length&lt;/code&gt;, yet it is perfectly fine with Kotlin to create additional mutable variables and express the same code in imperative style, too.</source>
          <target state="translated">この密なコードでは、コレクションの変換に加えて、あなたは、このような便利なKotlinは地元の機能として備えており、見ることができる&lt;a href=&quot;../reference/null-safety#elvis-operator&quot;&gt;演算子をELVIS &lt;/a&gt; &lt;code&gt;?:&lt;/code&gt; 表現することを可能にするという&lt;a href=&quot;../reference/idioms&quot;&gt;イディオム&lt;/a&gt;簡潔で、「それは、正または他の使用の長さがある場合は、値を取る」などを &lt;code&gt;.takeIf { it &amp;gt;= 0 } ?: s.length&lt;/code&gt; ような読み取り可能な式ですが、追加の可変変数を作成して同じコードを命令型スタイルで表現することもKotlinでは完全に問題ありません。</target>
        </trans-unit>
        <trans-unit id="e691bb86d414ab1eeeac0ce8d8cf107c13b24d6b" translate="yes" xml:space="preserve">
          <source>In this doc, we'll sometimes specify the type unnecessarily, in order to highlight what type is produced by an expression. (Also, a good IDE will be able to show you the resulting type.)</source>
          <target state="translated">このドキュメントでは、式によってどのような型が生成されるかを強調するために、不必要に型を指定することがあります。(また、優れたIDEであれば、結果の型を表示することができます)。</target>
        </trans-unit>
        <trans-unit id="7d12593ba02967f080622029b34989f6d346aaf9" translate="yes" xml:space="preserve">
          <source>In this document we introduce several kinds of compatibility:</source>
          <target state="translated">このドキュメントでは、いくつかの種類の互換性を紹介します。</target>
        </trans-unit>
        <trans-unit id="537f8c16fc8f03cc135b33707b31eb29f9995ea0" translate="yes" xml:space="preserve">
          <source>In this example only members of the nearest implicit receiver &lt;code&gt;this@head&lt;/code&gt; must be available; &lt;code&gt;head()&lt;/code&gt; is a member of the outer receiver &lt;code&gt;this@html&lt;/code&gt;, so it must be illegal to call it.</source>
          <target state="translated">この例では、最も近い暗黙のレシーバー &lt;code&gt;this@head&lt;/code&gt; メンバーのみが使用可能でなければなりません。 &lt;code&gt;head()&lt;/code&gt; は、外側のレシーバ &lt;code&gt;this@html&lt;/code&gt; メンバーなので、呼び出すことは違法でなければなりません。</target>
        </trans-unit>
        <trans-unit id="9c36d65c210f75f6cba412252945fedc98c222bc" translate="yes" xml:space="preserve">
          <source>In this example we launch a new coroutine in a background thread pool using &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-default.html&quot;&gt;Dispatchers.Default&lt;/a&gt;, so it works on a different thread from the thread pool, but it still has the value of the thread local variable that we specified using &lt;code&gt;threadLocal.asContextElement(value = &quot;launch&quot;)&lt;/code&gt;, no matter which thread the coroutine is executed on. Thus, the output (with &lt;a href=&quot;#debugging-coroutines-and-threads&quot;&gt;debug&lt;/a&gt;) is:</source>
          <target state="translated">この例では、&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-default.html&quot;&gt;Dispatchers.Default&lt;/a&gt;を使用してバックグラウンドスレッドプールで新しいコルーチンを起動するため、スレッドプールとは異なるスレッドで機能しますが、 &lt;code&gt;threadLocal.asContextElement(value = &quot;launch&quot;)&lt;/code&gt; を使用して指定したスレッドローカル変数の値は引き続き保持されます。 = &quot;launch&quot;）、コルーチンが実行されるスレッドに関係なく。したがって、出力（&lt;a href=&quot;#debugging-coroutines-and-threads&quot;&gt;デバッグあり&lt;/a&gt;）は次のようになります。</target>
        </trans-unit>
        <trans-unit id="67582c167007a9ba92244086b3d65c9a9e9700f4" translate="yes" xml:space="preserve">
          <source>In this example we launch a new coroutine in a background thread pool using &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-default.html&quot;&gt;Dispatchers.Default&lt;/a&gt;, so it works on a different threads from a thread pool, but it still has the value of thread local variable, that we've specified using &lt;code&gt;threadLocal.asContextElement(value = &quot;launch&quot;)&lt;/code&gt;, no matter on what thread the coroutine is executed. Thus, output (with &lt;a href=&quot;#debugging-coroutines-and-threads&quot;&gt;debug&lt;/a&gt;) is:</source>
          <target state="translated">この例では、&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-default.html&quot;&gt;Dispatchers.Default&lt;/a&gt;を使用してバックグラウンドスレッドプールで新しいコルーチンを起動します。これにより、スレッドコルーチンは、スレッドプールとは異なるスレッドで機能しますが、 &lt;code&gt;threadLocal.asContextElement(value = &quot;launch&quot;)&lt;/code&gt; を使用して指定したスレッドローカル変数の値を保持します。 （値= &quot;launch&quot;）、コルーチンが実行されるスレッドに関係なく。したがって、（&lt;a href=&quot;#debugging-coroutines-and-threads&quot;&gt;debugを使用した&lt;/a&gt;）出力は次のようになります。</target>
        </trans-unit>
        <trans-unit id="872d3ddd1be8b8c4ec3ab8cc792f3b5cde57d822" translate="yes" xml:space="preserve">
          <source>In this example, all values passed to the C API &lt;code&gt;new_menu()&lt;/code&gt; have a lifetime of the innermost &lt;code&gt;memScope&lt;/code&gt; it belongs to. Once the control flow leaves the &lt;code&gt;memScoped&lt;/code&gt; scope the C pointers become invalid.</source>
          <target state="translated">この例では、C API &lt;code&gt;new_menu()&lt;/code&gt; に渡されるすべての値は、それが属する最も内側の &lt;code&gt;memScope&lt;/code&gt; の有効期間を持っています。制御フローが &lt;code&gt;memScoped&lt;/code&gt; スコープを離れると、Cポインターは無効になります。</target>
        </trans-unit>
        <trans-unit id="5b70f0a7dd260f72c7acee91c3f5762c472a459a" translate="yes" xml:space="preserve">
          <source>In this example, the constructor takes a map:</source>
          <target state="translated">この例では、コンストラクタはマップを受け取ります。</target>
        </trans-unit>
        <trans-unit id="06698ce38b883fc740d14dcc830fa9e382960eb5" translate="yes" xml:space="preserve">
          <source>In this example, the sequence processing takes 18 steps instead of 23 steps for doing the same with lists.</source>
          <target state="translated">この例では、リストで同様の処理を行う場合の23ステップの代わりに、18ステップのシーケンス処理を行う。</target>
        </trans-unit>
        <trans-unit id="550b3c67b81cc4d4252fe83306649fc1df1e86da" translate="yes" xml:space="preserve">
          <source>In this example, using &lt;code&gt;Person&lt;/code&gt; and &lt;code&gt;callAndPrintTwoParam()&lt;/code&gt; from the previous section, we locate a member function reference by name and call it:</source>
          <target state="translated">この例では、前のセクションの &lt;code&gt;Person&lt;/code&gt; および &lt;code&gt;callAndPrintTwoParam()&lt;/code&gt; を使用して、メンバー関数参照を名前で検索し、呼び出します。</target>
        </trans-unit>
        <trans-unit id="25017fcbb3e37d1b9106fc29788136cb1c456365" translate="yes" xml:space="preserve">
          <source>In this function both &lt;a href=&quot;-continuation/resume&quot;&gt;Continuation.resume&lt;/a&gt; and &lt;a href=&quot;-continuation/resume-with-exception&quot;&gt;Continuation.resumeWithException&lt;/a&gt; can be used either synchronously in the same stack-frame where suspension function is run or asynchronously later in the same thread or from a different thread of execution. Repeated invocation of any resume function produces &lt;a href=&quot;../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt;.</source>
          <target state="translated">この関数では、&lt;a href=&quot;-continuation/resume&quot;&gt;Continuation.resume&lt;/a&gt;と&lt;a href=&quot;-continuation/resume-with-exception&quot;&gt;Continuation.resumeWithExceptionの&lt;/a&gt;両方を、サスペンション関数が実行されている同じスタックフレームで同期的に使用することも、後で同じスレッドでまたは非同期に別の実行スレッドから使​​用することもできます。再開関数を繰り返し呼び出すと、&lt;a href=&quot;../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateExceptionが発生し&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="a802dce08d5c39703b387f16a864974235e44de0" translate="yes" xml:space="preserve">
          <source>In this function both &lt;a href=&quot;resume&quot;&gt;Continuation.resume&lt;/a&gt; and &lt;a href=&quot;resume-with-exception&quot;&gt;Continuation.resumeWithException&lt;/a&gt; can be used either synchronously in the same stack-frame where the suspension function is run or asynchronously later in the same thread or from a different thread of execution. Subsequent invocation of any resume function will produce an &lt;a href=&quot;../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt;.</source>
          <target state="translated">この関数では、&lt;a href=&quot;resume&quot;&gt;Continuation.resume&lt;/a&gt;と&lt;a href=&quot;resume-with-exception&quot;&gt;Continuation.resumeWithExceptionの&lt;/a&gt;両方を、suspend関数が実行される同じスタックフレームで同期的に使用することも、同じスレッドで後で非同期に、または別の実行スレッドから使​​用することもできます。その後に再開機能を呼び出すと、&lt;a href=&quot;../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt;が発生します。</target>
        </trans-unit>
        <trans-unit id="677125a2bada551194ff25d8eec9f1b62a3c4ba4" translate="yes" xml:space="preserve">
          <source>In this section a commented DSL is shown. See also the example projects that use this plugin, e.g. &lt;a href=&quot;https://github.com/Kotlin/kotlinx.coroutines&quot;&gt;Kotlinx.coroutines&lt;/a&gt;, &lt;a href=&quot;https://github.com/e5l/http-client-common/tree/master/samples/ios-test-application&quot;&gt;MPP http client&lt;/a&gt;</source>
          <target state="translated">このセクションでは、コメント付きのDSLが表示されます。このプラグインを使用するサンプルプロジェクトも参照してください。例：&lt;a href=&quot;https://github.com/Kotlin/kotlinx.coroutines&quot;&gt;Kotlinx.coroutines&lt;/a&gt;、&lt;a href=&quot;https://github.com/e5l/http-client-common/tree/master/samples/ios-test-application&quot;&gt;MPP httpクライアント&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="45d0e31509240af7f0d899e0847fb308f3f6c3d9" translate="yes" xml:space="preserve">
          <source>In this tutorial We will learn how to:</source>
          <target state="translated">このチュートリアルでは、以下の方法を学びます。</target>
        </trans-unit>
        <trans-unit id="b8d78e48aa113b25ef679f219669ead0543c6d9d" translate="yes" xml:space="preserve">
          <source>In this tutorial however, we'll see how to use some specific libraries, such as &lt;code&gt;libcurl&lt;/code&gt;. We'll learn to</source>
          <target state="translated">ただし、このチュートリアルでは、 &lt;code&gt;libcurl&lt;/code&gt; などの特定のライブラリの使用方法について説明します。私たちは学びます</target>
        </trans-unit>
        <trans-unit id="38ae904b992e64be7d6f1c95db212a698e90d2ef" translate="yes" xml:space="preserve">
          <source>In this tutorial we have:</source>
          <target state="translated">このチュートリアルでは</target>
        </trans-unit>
        <trans-unit id="814c4fd32a87a880ed24663823d0826f5fba0218" translate="yes" xml:space="preserve">
          <source>In this tutorial we see how to deal with C strings in Kotlin/Native. We will learn how to:</source>
          <target state="translated">このチュートリアルでは、Kotlin/NativeでC言語の文字列を扱う方法を見ていきます。その方法を学んでいきます。</target>
        </trans-unit>
        <trans-unit id="f187570814c6d6abda5a2c00ead30d73ef74a12e" translate="yes" xml:space="preserve">
          <source>In this tutorial we will create an iOS and Android application, by making use of Kotlin's code sharing features. For Android we'll be using Kotlin/JVM, while for iOS it will be Kotlin/Native.</source>
          <target state="translated">このチュートリアルでは、Kotlinのコード共有機能を利用して、iOSとAndroidのアプリケーションを作成します。AndroidではKotlin/JVMを使用し、iOSではKotlin/Nativeを使用します。</target>
        </trans-unit>
        <trans-unit id="e75dd7cce5c41f63288c1748bd5bfd1c78d1ff1b" translate="yes" xml:space="preserve">
          <source>In this tutorial we'll see how to</source>
          <target state="translated">このチュートリアルでは</target>
        </trans-unit>
        <trans-unit id="73192ff47f695a8d1b74a36ad93cdb6ae37eb2de" translate="yes" xml:space="preserve">
          <source>In this tutorial we'll walk through the steps required to use the Kotlin Android Extensions plugin, enhancing the experience of Android development.</source>
          <target state="translated">このチュートリアルでは、Kotlin Android Extensionsプラグインを使用するために必要な手順を説明します。</target>
        </trans-unit>
        <trans-unit id="f0e340bf119483d38d43d3af161837206adf260c" translate="yes" xml:space="preserve">
          <source>In this tutorial we'll walk through the steps required. For a more thorough explanation of Spring Boot and Kotlin, please see &lt;a href=&quot;https://spring.io/guides/tutorials/spring-boot-kotlin/&quot;&gt;Building web applications with Spring Boot and Kotlin&lt;/a&gt;.</source>
          <target state="translated">このチュートリアルでは、必要な手順について説明します。Spring BootとKotlinの詳細については&lt;a href=&quot;https://spring.io/guides/tutorials/spring-boot-kotlin/&quot;&gt;、Spring BootとKotlinを使用したウェブアプリケーションの構築&lt;/a&gt;をご覧ください。</target>
        </trans-unit>
        <trans-unit id="04ead99e3026a0a00111c1c9a4f51b0c3c739752" translate="yes" xml:space="preserve">
          <source>In this tutorial we'll:</source>
          <target state="translated">このチュートリアルでは</target>
        </trans-unit>
        <trans-unit id="0f464678d81fef87702589d2f00f58596a930600" translate="yes" xml:space="preserve">
          <source>In this tutorial we're going to use IntelliJ IDEA. For instructions on how to compile and execute Kotlin applications using the command line compiler, see &lt;a href=&quot;command-line&quot;&gt;Working with the Command Line Compiler&lt;/a&gt;.</source>
          <target state="translated">このチュートリアルでは、IntelliJ IDEAを使用します。コマンドラインコンパイラを使用してKotlinアプリケーションをコンパイルして実行する方法については、参照&lt;a href=&quot;command-line&quot;&gt;コマンドラインコンパイラを使用した作業を&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a5d5b9a27b34d95239a0c33821d0a9b033c40bd3" translate="yes" xml:space="preserve">
          <source>In this tutorial we've seen how to create a Kotlin application that targets JavaScript, debug it as well as set compiler options. In other tutorials we'll cover more in-depth topics such as interacting with the DOM, etc.</source>
          <target state="translated">このチュートリアルでは、JavaScriptをターゲットにしたKotlinアプリケーションの作成方法、デバッグ方法、コンパイラオプションの設定方法を見てきました。他のチュートリアルでは、DOM との対話など、より深いトピックを取り上げていきます。</target>
        </trans-unit>
        <trans-unit id="15ab8dc4bd9f08f596ae63880b3958cb4434a6d7" translate="yes" xml:space="preserve">
          <source>In this tutorial, we learn what C data types are visible in Kotlin/Native and vice versa. We will:</source>
          <target state="translated">このチュートリアルでは、Kotlin/Native ではどのような C 言語のデータ型が表示されるのか、またその逆の場合はどのようなデータ型が表示されるのかを学びます。このチュートリアルでは、以下のことを学びます。</target>
        </trans-unit>
        <trans-unit id="8a05d2cdb1fd77bc1ee6b2a0bfc489f7b20f51b2" translate="yes" xml:space="preserve">
          <source>In this tutorial, we look at how we can use the Kotlin/Native code from existing native applications or libraries. For this, we need to compile our Kotlin code into a dynamic library, &lt;code&gt;.so&lt;/code&gt;, &lt;code&gt;.dylib&lt;/code&gt;, and &lt;code&gt;.dll&lt;/code&gt;.</source>
          <target state="translated">このチュートリアルでは、既存のネイティブアプリケーションまたはライブラリからKotlin / Nativeコードを使用する方法について説明します。これを行うには、Kotlinコードを動的ライブラリ &lt;code&gt;.so&lt;/code&gt; 、 &lt;code&gt;.dylib&lt;/code&gt; 、および &lt;code&gt;.dll&lt;/code&gt; にコンパイルする必要があります。</target>
        </trans-unit>
        <trans-unit id="701903e9f376cd1d8503774a4d299554e97196a0" translate="yes" xml:space="preserve">
          <source>In this tutorial, we will build a small library available from the worlds of JVM, JS, and Native. You will learn step-by-step how to create a multiplatform library which can be used from any other common code (e.g., one shared with Android and iOS), and how to write tests which will be executed on all platforms and use an efficient implementation provided by the concrete platform.</source>
          <target state="translated">このチュートリアルでは、JVM、JS、Native の世界から利用可能な小さなライブラリを構築します。他のどのような共通コード(例えば、AndroidやiOSと共有されているもの)からでも利用できるマルチプラットフォームライブラリを作成する方法や、すべてのプラットフォームで実行され、具体的なプラットフォームが提供する効率的な実装を利用するテストの書き方をステップバイステップで学びます。</target>
        </trans-unit>
        <trans-unit id="8459da0cf638e813dae1e5c0fa95e9568c3582bd" translate="yes" xml:space="preserve">
          <source>In this tutorial, we will look at how to use Kotlin/Native code from Objective-C and Swift applications on macOS and iOS. We will build a framework from Kotlin code.</source>
          <target state="translated">このチュートリアルでは、Objective-CやSwiftアプリのKotlin/NativeコードをmacOSやiOSで利用する方法を見ていきます。Kotlinのコードからフレームワークを構築していきます。</target>
        </trans-unit>
        <trans-unit id="864dde628feba0ddb56fa697c290d183bee8b077" translate="yes" xml:space="preserve">
          <source>In this tutorial, we will:</source>
          <target state="translated">このチュートリアルでは、次のことを行います。</target>
        </trans-unit>
        <trans-unit id="98c10d04454a966f67cb1dfe790300722810cd2d" translate="yes" xml:space="preserve">
          <source>In this tutorial, we'll look at how to</source>
          <target state="translated">このチュートリアルでは、以下の方法を見ていきます。</target>
        </trans-unit>
        <trans-unit id="0c3ebd5f96036d4c23f2a9d6d5dd9911faa69aff" translate="yes" xml:space="preserve">
          <source>In this tutorial, we're going to be using Gradle but the same can be accomplished using either IntelliJ IDEA project structure or Maven. For details on setting up Gradle to work with Kotlin, see &lt;a href=&quot;../reference/using-gradle&quot;&gt;Using Gradle&lt;/a&gt;.</source>
          <target state="translated">このチュートリアルでは、Gradleを使用しますが、IntelliJ IDEAプロジェクト構造またはMavenを使用しても同じことができます。Kotlinで動作するようにGradleを設定する方法の詳細については、「&lt;a href=&quot;../reference/using-gradle&quot;&gt;Gradleの使用&lt;/a&gt;」を参照してください。</target>
        </trans-unit>
        <trans-unit id="aa1a5fa948935055fc078b1993ec8baed9df514c" translate="yes" xml:space="preserve">
          <source>In this tutorial, we're going to be using Gradle but the same can be accomplished using either IntelliJ IDEA project structure or Maven. For details on setting up Gradle to work with Kotlin, see &lt;a href=&quot;../reference/using-gradle&quot;&gt;Using Gradle&lt;/a&gt;. The main dependency required for using HTTP servlets is the JavaEE API:</source>
          <target state="translated">このチュートリアルでは、Gradleを使用しますが、IntelliJ IDEAプロジェクト構造またはMavenを使用しても同じことができます。Kotlinで動作するようにGradleを設定する方法の詳細については、「&lt;a href=&quot;../reference/using-gradle&quot;&gt;Gradleの使用&lt;/a&gt;」を参照してください。HTTPサーブレットを使用するために必要な主な依存関係は、JavaEE APIです。</target>
        </trans-unit>
        <trans-unit id="40ab0f9121b36c46d899b6425de4821ece3db190" translate="yes" xml:space="preserve">
          <source>In this video, Kotlin Developer Advocate Sebastian Aigner will explain the main Kotlin/JS benefits to you, share some tips and use cases, and also tell you about the plans and upcoming features for Kotlin/JS.</source>
          <target state="translated">このビデオでは、Kotlin Developer AdvocateのSebastian AignerがKotlin/JSの主な利点を説明し、いくつかのヒントやユースケースを共有し、Kotlin/JSの計画や今後の機能についてもお伝えします。</target>
        </trans-unit>
        <trans-unit id="23e1b785f9b5814cd84a43b0c10801c0740b41ac" translate="yes" xml:space="preserve">
          <source>In turn, &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;also&lt;/code&gt; have the context object as a lambda argument. If the argument name is not specified, the object is accessed by the implicit default name &lt;code&gt;it&lt;/code&gt;. &lt;code&gt;it&lt;/code&gt; is shorter than &lt;code&gt;this&lt;/code&gt; and expressions with &lt;code&gt;it&lt;/code&gt; are usually easier for reading. However, when calling the object functions or properties you don't have the object available implicitly like &lt;code&gt;this&lt;/code&gt;. Hence, having the context object as &lt;code&gt;it&lt;/code&gt; is better when the object is mostly used as an argument in function calls. &lt;code&gt;it&lt;/code&gt; is also better if you use multiple variables in the code block.</source>
          <target state="translated">ターンでは、 &lt;code&gt;let&lt;/code&gt; と &lt;code&gt;also&lt;/code&gt; ラムダ引数としてコンテキストオブジェクトを持っています。引数名が指定されていない場合、オブジェクトは暗黙のデフォルト名 &lt;code&gt;it&lt;/code&gt; でアクセスされます。 &lt;code&gt;it&lt;/code&gt; は &lt;code&gt;this&lt;/code&gt; よりも短く、通常、 &lt;code&gt;it&lt;/code&gt; を含む式は読みやすくなります。ただし、オブジェクトの関数またはプロパティを呼び出す場合、 &lt;code&gt;this&lt;/code&gt; ように暗黙的に使用できるオブジェクトはありません。したがって、オブジェクトが関数呼び出しの引数として主に使用される場合は、コンテキストオブジェクトを使用 &lt;code&gt;it&lt;/code&gt; 方が適切です。 &lt;code&gt;it&lt;/code&gt; あなたがコードブロックに複数の変数を使用している場合にも優れています。</target>
        </trans-unit>
        <trans-unit id="812b574e96ace8dd4cdbeccd6ad6e3f2e4f0aabb" translate="yes" xml:space="preserve">
          <source>In turn, mutable collections aren't covariant; otherwise, this would lead to runtime failures. If &lt;code&gt;MutableList&amp;lt;Rectangle&amp;gt;&lt;/code&gt; was a subtype of &lt;code&gt;MutableList&amp;lt;Shape&amp;gt;&lt;/code&gt;, you could insert other &lt;code&gt;Shape&lt;/code&gt; inheritors (for example, &lt;code&gt;Circle&lt;/code&gt;) into it, thus violating its &lt;code&gt;Rectangle&lt;/code&gt; type argument.</source>
          <target state="translated">一方、変更可能なコレクションは共変ではありません。そうしないと、ランタイムエラーが発生します。場合 &lt;code&gt;MutableList&amp;lt;Rectangle&amp;gt;&lt;/code&gt; のサブタイプだった &lt;code&gt;MutableList&amp;lt;Shape&amp;gt;&lt;/code&gt; 、あなたは他の挿入可能性 &lt;code&gt;Shape&lt;/code&gt; （例えば、相続を &lt;code&gt;Circle&lt;/code&gt; したがって、その違反し、その中に） &lt;code&gt;Rectangle&lt;/code&gt; 型引数を。</target>
        </trans-unit>
        <trans-unit id="2a50d6665033bbbaf15909f2a8b12edea9bb1926" translate="yes" xml:space="preserve">
          <source>In turn, set is not an ordered collection by &lt;a href=&quot;collections-overview&quot;&gt;definition&lt;/a&gt;. However, the Kotlin &lt;code&gt;Set&lt;/code&gt; stores elements in certain orders. These can be the order of insertion (in &lt;code&gt;LinkedHashSet&lt;/code&gt;), natural sorting order (in &lt;code&gt;SortedSet&lt;/code&gt;), or another order. The order of a set of elements can also be unknown. In such cases, the elements are still ordered somehow, so the functions that rely on the element positions still return their results. However, such results are unpredictable to the caller unless they know the specific implementation of &lt;code&gt;Set&lt;/code&gt; used.</source>
          <target state="translated">同様に、セットは&lt;a href=&quot;collections-overview&quot;&gt;定義&lt;/a&gt;により順序付けられたコレクションではありません。ただし、Kotlin &lt;code&gt;Set&lt;/code&gt; は特定の順序で要素を格納します。これらは、挿入の順序（ &lt;code&gt;LinkedHashSet&lt;/code&gt; 内）、自然なソート順（ &lt;code&gt;SortedSet&lt;/code&gt; 内）、または別の順序にすることができます。要素のセットの順序も不明な場合があります。そのような場合でも、要素はなんらかの方法で順序付けられているため、要素の位置に依存する関数は結果を返します。ただし、このような結果は、使用される &lt;code&gt;Set&lt;/code&gt; の特定の実装を知らない限り、呼び出し元には予測できません。</target>
        </trans-unit>
        <trans-unit id="26d300702c75a3b26e8ba1f4228f68dc28aca421" translate="yes" xml:space="preserve">
          <source>In turn, worksheets are project files: they are stored in project directories and tied to the project modules. Worksheets are useful for writing code parts that don't actually make a software unit but should still be stored together in a project. For example, you can use worksheets for education or demo materials.</source>
          <target state="translated">ワークシートはプロジェクトディレクトリに格納され、プロジェクトモジュールに関連付けられています。ワークシートは、実際にはソフトウェアユニットを作らないが、プロジェクトに一緒に保存されるべきコード部分を書くのに便利です。例えば、教育用やデモ用の教材にワークシートを使うことができます。</target>
        </trans-unit>
        <trans-unit id="01b654ef30cda18991ddded390d4b967ccf9e9a4" translate="yes" xml:space="preserve">
          <source>In your scratch, you can write any valid Kotlin code, including new functions and classes. Syntax highlighting, auto-completion, and other code editing features of IntelliJ IDEA are supported in scratches.</source>
          <target state="translated">スクラッチでは、新しい関数やクラスを含む有効なKotlinコードを書くことができます。スクラッチでは、IntelliJ IDEAのシンタックスハイライト、自動補完、その他のコード編集機能がサポートされています。</target>
        </trans-unit>
        <trans-unit id="3348bba79393338a33249573a6e3c773462946f1" translate="yes" xml:space="preserve">
          <source>Include a custom JDK from the specified location into the classpath instead of the default JAVA_HOME</source>
          <target state="translated">デフォルトの JAVA_HOME の代わりに、指定した場所のカスタム JDK をクラスパスに含めます。</target>
        </trans-unit>
        <trans-unit id="f2699078d9287cbd90f76ee50448a4fec028de87" translate="yes" xml:space="preserve">
          <source>Including static library in your klib</source>
          <target state="translated">klibにスタティックライブラリを含める</target>
        </trans-unit>
        <trans-unit id="84996d5891b1f1a645c33eb5c3b22433a18e3eec" translate="yes" xml:space="preserve">
          <source>Incompatible Changes</source>
          <target state="translated">互換性のない変更</target>
        </trans-unit>
        <trans-unit id="8d41722fdaa1b8acfa42d80a00302ec1d80e560e" translate="yes" xml:space="preserve">
          <source>IncorrectDereferenceException</source>
          <target state="translated">IncorrectDereferenceException</target>
        </trans-unit>
        <trans-unit id="7c15aa041f9a78e640a95e3034dce236ee5d488b" translate="yes" xml:space="preserve">
          <source>Incremental Compilation</source>
          <target state="translated">インクリメンタルコンパイル</target>
        </trans-unit>
        <trans-unit id="1d25e364e8dc05079a68a8ada56d8fbeda70bc16" translate="yes" xml:space="preserve">
          <source>Incremental annotation processing (since 1.3.30)</source>
          <target state="translated">増分アノテーション処理(1.3.30以降</target>
        </trans-unit>
        <trans-unit id="29106d30f82b4fbf8a046db084591a963e0208cc" translate="yes" xml:space="preserve">
          <source>Incremental annotation processing is enabled by default starting from version 1.3.50. To disable incremental annotation processing, add this line to your &lt;code&gt;gradle.properties&lt;/code&gt; file:</source>
          <target state="translated">バージョン1.3.50以降、増分注釈処理はデフォルトで有効になっています。インクリメンタルアノテーション処理を無効にするには、次の行を &lt;code&gt;gradle.properties&lt;/code&gt; ファイルに追加します。</target>
        </trans-unit>
        <trans-unit id="b1262b9eb921db266028505964086f28ad7e7f94" translate="yes" xml:space="preserve">
          <source>Incremental compilation</source>
          <target state="translated">インクリメンタルコンパイル</target>
        </trans-unit>
        <trans-unit id="3bb3cfba326a2bdc90f381639a6d53003c8fb9e7" translate="yes" xml:space="preserve">
          <source>Incremental compilation is supported for Kotlin/JVM and Kotlin/JS projects.</source>
          <target state="translated">インクリメンタルコンパイルはKotlin/JVMとKotlin/JSプロジェクトでサポートされています。</target>
        </trans-unit>
        <trans-unit id="33b5061796594b36b41f624484bcfb3853bb6d0c" translate="yes" xml:space="preserve">
          <source>Incremental compilation is supported for Kotlin/JVM and Kotlin/JS projects. It's enabled by default since Kotlin 1.1.1 for Kotlin/JVM and 1.3.20 for Kotlin/JS.</source>
          <target state="translated">インクリメンタルコンパイルはKotlin/JVMとKotlin/JSプロジェクトでサポートされています。Kotlin/JVMではKotlin 1.1.1、Kotlin/JSでは1.3.20からデフォルトで有効になっています。</target>
        </trans-unit>
        <trans-unit id="d6dbea2b53708e66e73d3f1a6a99defec97fa2a9" translate="yes" xml:space="preserve">
          <source>Incremental releases bring updates in the tooling (often including features), performance improvements and bug fixes. We try to keep such versions compatible with each other, so changes to the compiler are mostly optimizations and warning additions/removals. Experimental features may, of course, be added, removed or changed at any time.</source>
          <target state="translated">インクリメンタルリリースでは、ツールの更新 (多くの場合、機能を含む)、パフォーマンスの向上、バグの修正が行われます。このようなバージョンはお互いに互換性を保つようにしていますので、コンパイラの変更はほとんどが最適化と警告の追加/削除です。もちろん、実験的な機能はいつでも追加、削除、変更される可能性があります。</target>
        </trans-unit>
        <trans-unit id="36431db4a12e3c14e9de849f36b5befe35ed62b5" translate="yes" xml:space="preserve">
          <source>Incremental releases bring updates in the tooling (often including features), performance improvements and bug fixes. We try to keep such versions compatible with each other, so changes to the compiler are mostly optimizations and warning additions/removals. Pre-stable features may, of course, be added, removed or changed at any time.</source>
          <target state="translated">インクリメンタルリリースでは、ツールの更新 (多くの場合、機能を含む)、パフォーマンスの向上、バグの修正が行われます。このようなバージョンはお互いに互換性を保つようにしているので、コンパイラへの変更はほとんどが最適化と警告の追加/削除です。もちろん、安定化前の機能はいつでも追加、削除、変更される可能性があります。</target>
        </trans-unit>
        <trans-unit id="9c0b336ea67b1169e696bcad497094e1948f51aa" translate="yes" xml:space="preserve">
          <source>Increments and decrements</source>
          <target state="translated">インクリメントとデクリメント</target>
        </trans-unit>
        <trans-unit id="51065cc396f6ec67a2538e872f538ab2d9ab75c9" translate="yes" xml:space="preserve">
          <source>Increments the value by &lt;a href=&quot;add-and-get#kotlin.native.concurrent.AtomicInt%24addAndGet%28kotlin.Int%29%2Fdelta&quot;&gt;delta&lt;/a&gt; and returns the new value.</source>
          <target state="translated">&lt;a href=&quot;add-and-get#kotlin.native.concurrent.AtomicInt%24addAndGet%28kotlin.Int%29%2Fdelta&quot;&gt;デルタ&lt;/a&gt;によって値を増分し、新しい値を返します。</target>
        </trans-unit>
        <trans-unit id="b0f32b37b99e84f7a892589880d018ef9b908ef9" translate="yes" xml:space="preserve">
          <source>Increments the value by &lt;a href=&quot;add-and-get#kotlin.native.concurrent.AtomicInt%24addAndGet(kotlin.Int)/delta&quot;&gt;delta&lt;/a&gt; and returns the new value.</source>
          <target state="translated">値を&lt;a href=&quot;add-and-get#kotlin.native.concurrent.AtomicInt%24addAndGet(kotlin.Int)/delta&quot;&gt;デルタ&lt;/a&gt;単位でインクリメントし、新しい値を返します。</target>
        </trans-unit>
        <trans-unit id="44233843d94836d1fccccf70b3b2b867d9acc067" translate="yes" xml:space="preserve">
          <source>Increments the value by &lt;a href=&quot;add-and-get#kotlin.native.concurrent.AtomicLong%24addAndGet%28kotlin.Long%29%2Fdelta&quot;&gt;delta&lt;/a&gt; and returns the new value.</source>
          <target state="translated">&lt;a href=&quot;add-and-get#kotlin.native.concurrent.AtomicLong%24addAndGet%28kotlin.Long%29%2Fdelta&quot;&gt;デルタ&lt;/a&gt;によって値を増分し、新しい値を返します。</target>
        </trans-unit>
        <trans-unit id="166f962aa69e44913e0b39e6fa68583a02fd3a79" translate="yes" xml:space="preserve">
          <source>Increments the value by &lt;a href=&quot;add-and-get#kotlin.native.concurrent.AtomicLong%24addAndGet(kotlin.Long)/delta&quot;&gt;delta&lt;/a&gt; and returns the new value.</source>
          <target state="translated">値を&lt;a href=&quot;add-and-get#kotlin.native.concurrent.AtomicLong%24addAndGet(kotlin.Long)/delta&quot;&gt;デルタ&lt;/a&gt;単位でインクリメントし、新しい値を返します。</target>
        </trans-unit>
        <trans-unit id="28411949be3415589036a91826011ccfec40fbd4" translate="yes" xml:space="preserve">
          <source>Increments this value.</source>
          <target state="translated">この値を増加させます。</target>
        </trans-unit>
        <trans-unit id="b8fcfd847cda35bcb6945261dd3c4eb8f88f412a" translate="yes" xml:space="preserve">
          <source>Increments value by one.</source>
          <target state="translated">値を1つインクリメントします。</target>
        </trans-unit>
        <trans-unit id="c2df9b932637fe9d32a0f16da1c11873398f873d" translate="yes" xml:space="preserve">
          <source>Index</source>
          <target state="translated">Index</target>
        </trans-unit>
        <trans-unit id="83f705f84f3e506a637956b9907406ba6fe9f41e" translate="yes" xml:space="preserve">
          <source>IndexOutOfBoundsException</source>
          <target state="translated">IndexOutOfBoundsException</target>
        </trans-unit>
        <trans-unit id="4a12f879063aea0813ebab8015ddf21b727cd7af" translate="yes" xml:space="preserve">
          <source>Indexed access operator</source>
          <target state="translated">インデックス化されたアクセス演算子</target>
        </trans-unit>
        <trans-unit id="d4e1cf8d774b0c0bb9b5921ec7fa833544082d60" translate="yes" xml:space="preserve">
          <source>IndexedValue</source>
          <target state="translated">IndexedValue</target>
        </trans-unit>
        <trans-unit id="2606e49e237c315e21ba9ad3205e46744904acbb" translate="yes" xml:space="preserve">
          <source>Indexing suffix</source>
          <target state="translated">インデックス接尾辞</target>
        </trans-unit>
        <trans-unit id="4ad24986a96806bcf716cdb15281ed398b1a31f5" translate="yes" xml:space="preserve">
          <source>Indicates whether some other object is &quot;equal to&quot; this one. Implementations must fulfil the following requirements:</source>
          <target state="translated">他のオブジェクトがこのオブジェクトと「等しい」かどうかを示す。実装は以下の要件を満たさなければならない。</target>
        </trans-unit>
        <trans-unit id="53f09d01b93a3110068a373094e1fb376a10c3c8" translate="yes" xml:space="preserve">
          <source>Indicates whether the regular expression can find at least one match in the specified &lt;a href=&quot;contains-match-in#kotlin.text.Regex%24containsMatchIn%28kotlin.CharSequence%29%2Finput&quot;&gt;input&lt;/a&gt;.</source>
          <target state="translated">正規表現が指定された&lt;a href=&quot;contains-match-in#kotlin.text.Regex%24containsMatchIn%28kotlin.CharSequence%29%2Finput&quot;&gt;入力&lt;/a&gt;で少なくとも1つの一致を見つけることができるかどうかを示します。</target>
        </trans-unit>
        <trans-unit id="51429e87bd819bb2f3942329861eee4721f512b8" translate="yes" xml:space="preserve">
          <source>Indicates whether the regular expression can find at least one match in the specified &lt;a href=&quot;contains-match-in#kotlin.text.Regex%24containsMatchIn(kotlin.CharSequence)/input&quot;&gt;input&lt;/a&gt;.</source>
          <target state="translated">正規表現が指定された&lt;a href=&quot;contains-match-in#kotlin.text.Regex%24containsMatchIn(kotlin.CharSequence)/input&quot;&gt;入力&lt;/a&gt;で少なくとも1つの一致を見つけることができるかどうかを示します。</target>
        </trans-unit>
        <trans-unit id="cc670204f79af50c97c85084d6a41b77270ab6a4" translate="yes" xml:space="preserve">
          <source>Indicates whether the regular expression matches the entire &lt;a href=&quot;matches#kotlin.text.Regex%24matches%28kotlin.CharSequence%29%2Finput&quot;&gt;input&lt;/a&gt;.</source>
          <target state="translated">正規表現が&lt;a href=&quot;matches#kotlin.text.Regex%24matches%28kotlin.CharSequence%29%2Finput&quot;&gt;入力&lt;/a&gt;全体と一致するかどうかを示します。</target>
        </trans-unit>
        <trans-unit id="b98c0b71834f5e2d5a0d8cf79e50cdeebb2945aa" translate="yes" xml:space="preserve">
          <source>Indicates whether the regular expression matches the entire &lt;a href=&quot;matches#kotlin.text.Regex%24matches(kotlin.CharSequence)/input&quot;&gt;input&lt;/a&gt;.</source>
          <target state="translated">正規表現が&lt;a href=&quot;matches#kotlin.text.Regex%24matches(kotlin.CharSequence)/input&quot;&gt;入力&lt;/a&gt;全体に一致するかどうかを示します。</target>
        </trans-unit>
        <trans-unit id="767a32bb6d83112e90455e54a6dd8a16300ca86c" translate="yes" xml:space="preserve">
          <source>Infix calls for named functions</source>
          <target state="translated">名前付き関数のインフィックス呼び出し</target>
        </trans-unit>
        <trans-unit id="1cea4b28540c3fbdd2e2436ba68910be38a3f387" translate="yes" xml:space="preserve">
          <source>Infix function calls have lower precedence than the arithmetic operators, type casts, and the &lt;code&gt;rangeTo&lt;/code&gt; operator. The following expressions are equivalent:</source>
          <target state="translated">Infix関数呼び出しは、算術演算子、型キャスト、および &lt;code&gt;rangeTo&lt;/code&gt; 演算子よりも優先順位が低くなります。次の式は同等です。</target>
        </trans-unit>
        <trans-unit id="c345bbff4a1e1fc76b2e4ede7fbe52f5de947e6b" translate="yes" xml:space="preserve">
          <source>Infix functions</source>
          <target state="translated">インフィックス機能</target>
        </trans-unit>
        <trans-unit id="19c6abcd2f2f19793afb1f4565bae99cd5d50667" translate="yes" xml:space="preserve">
          <source>Infix notation</source>
          <target state="translated">インフィックス表記法</target>
        </trans-unit>
        <trans-unit id="c5a135f955f6a2349a2d4263f326ff3a2a3304ed" translate="yes" xml:space="preserve">
          <source>Information from explicit casts is used for type inference</source>
          <target state="translated">明示的なキャストからの情報は型推論に利用されます。</target>
        </trans-unit>
        <trans-unit id="fdaddb9ce367c2ca746a97cc24d2e8817a51f27d" translate="yes" xml:space="preserve">
          <source>Inheritance</source>
          <target state="translated">Inheritance</target>
        </trans-unit>
        <trans-unit id="fc3ff49d31fe091e3831cd8bc1f2e6d38992276d" translate="yes" xml:space="preserve">
          <source>Inheritance from Java classes</source>
          <target state="translated">Javaクラスからの継承</target>
        </trans-unit>
        <trans-unit id="060c830dba717926ce4d26ef9693decc297e0680" translate="yes" xml:space="preserve">
          <source>Inheritance that leads to a &lt;code&gt;copy&lt;/code&gt; conflict has become deprecated with a warning in Kotlin 1.2 and will be an error in Kotlin 1.3.</source>
          <target state="translated">&lt;code&gt;copy&lt;/code&gt; 競合につながる継承は、Kotlin 1.2では警告とともに廃止され、Kotlin 1.3ではエラーになります。</target>
        </trans-unit>
        <trans-unit id="fe8f308745a21bdbf9c67ae8f86198813253366c" translate="yes" xml:space="preserve">
          <source>Inherited Functions</source>
          <target state="translated">継承機能</target>
        </trans-unit>
        <trans-unit id="a97b2d009dc11ee2399b0468fc72e941eebbf165" translate="yes" xml:space="preserve">
          <source>Inherited Properties</source>
          <target state="translated">継承されたプロパティ</target>
        </trans-unit>
        <trans-unit id="f54b5bc69098e64d7fae998cd4e9df2d4fa8e7af" translate="yes" xml:space="preserve">
          <source>Inherited built-in functions</source>
          <target state="translated">継承された組み込み機能</target>
        </trans-unit>
        <trans-unit id="af6ed82fe139bda1a895add0ffee5c78ca3dcf12" translate="yes" xml:space="preserve">
          <source>Inheritors</source>
          <target state="translated">Inheritors</target>
        </trans-unit>
        <trans-unit id="68fa16ffd48f366e4fa8d57fea78ff03fcab0191" translate="yes" xml:space="preserve">
          <source>Initialization</source>
          <target state="translated">Initialization</target>
        </trans-unit>
        <trans-unit id="100b184b34b9bc80bfe5761ad8aa4a5db3c27036" translate="yes" xml:space="preserve">
          <source>Initialized with a value of type &lt;code&gt;String&lt;/code&gt; or a primitive type</source>
          <target state="translated">&lt;code&gt;String&lt;/code&gt; 型またはプリミティブ型の値で初期化されました</target>
        </trans-unit>
        <trans-unit id="0c55ba13e2bd9dbfd35641ebe93792c6061e39cd" translate="yes" xml:space="preserve">
          <source>Initializer</source>
          <target state="translated">Initializer</target>
        </trans-unit>
        <trans-unit id="cddbd43ce85bc15d27c1f2848a884d7030458b88" translate="yes" xml:space="preserve">
          <source>Initializer function can be called several times on concurrent access to uninitialized &lt;a href=&quot;../-lazy/index&quot;&gt;Lazy&lt;/a&gt; instance value, but only the first returned value will be used as the value of &lt;a href=&quot;../-lazy/index&quot;&gt;Lazy&lt;/a&gt; instance.</source>
          <target state="translated">初期化関数は、初期化されていないへの同時アクセスに複数回呼び出すことができます&lt;a href=&quot;../-lazy/index&quot;&gt;怠惰な&lt;/a&gt;インスタンス値が、唯一の最初の戻り値は、の値として使用されます&lt;a href=&quot;../-lazy/index&quot;&gt;レイジー&lt;/a&gt;インスタンス。</target>
        </trans-unit>
        <trans-unit id="8de9a4ea59b21de32db609afcfc607895faed0de" translate="yes" xml:space="preserve">
          <source>Initializer functions for lists</source>
          <target state="translated">リストの初期化関数</target>
        </trans-unit>
        <trans-unit id="db5e65d8fc7dddd98f6860c2416bcbcc90ec0fba" translate="yes" xml:space="preserve">
          <source>Initializers</source>
          <target state="translated">Initializers</target>
        </trans-unit>
        <trans-unit id="96e412fcc42808e35495dbc64ebcde5c69c261de" translate="yes" xml:space="preserve">
          <source>Initializes Kotlin runtime for the current thread, if not inited already.</source>
          <target state="translated">まだ起動していない場合は、現在のスレッドの Kotlin ランタイムを初期化します。</target>
        </trans-unit>
        <trans-unit id="4bf76bf156ef56b953245fb5da4ea73be4ae4d91" translate="yes" xml:space="preserve">
          <source>Initiates a call to this deep recursive function, forming a root of the call tree.</source>
          <target state="translated">この深い再帰関数の呼び出しを開始し、呼び出しツリーのルートを形成します。</target>
        </trans-unit>
        <trans-unit id="be787dbbf62b5076f4a13439769f15509c2967ea" translate="yes" xml:space="preserve">
          <source>Inlinable lambdas can only be called inside the inline functions or passed as inlinable arguments, but &lt;code&gt;noinline&lt;/code&gt; ones can be manipulated in any way we like: stored in fields, passed around etc.</source>
          <target state="translated">INLINABLEラムダは、インライン関数内と呼ばれるかINLINABLE引数として渡すことができるが &lt;code&gt;noinline&lt;/code&gt; ものは、私たちのような任意の方法で操作することができます。周りに渡され、フィールドに保存されているなど</target>
        </trans-unit>
        <trans-unit id="b60019f47df04ae92897fa912c6748a6013313fa" translate="yes" xml:space="preserve">
          <source>Inline Functions</source>
          <target state="translated">インライン関数</target>
        </trans-unit>
        <trans-unit id="77dc1cce985d17f15f3bb54896d9ab82a2428c34" translate="yes" xml:space="preserve">
          <source>Inline JavaScript</source>
          <target state="translated">インライン JavaScript</target>
        </trans-unit>
        <trans-unit id="62d048ab15fe71589a192aa32dfde8cfed8f778a" translate="yes" xml:space="preserve">
          <source>Inline Markup</source>
          <target state="translated">インラインマークアップ</target>
        </trans-unit>
        <trans-unit id="5d360c4149ca0224f961067c92c26613a7104175" translate="yes" xml:space="preserve">
          <source>Inline classes</source>
          <target state="translated">インラインクラス</target>
        </trans-unit>
        <trans-unit id="9286e6770b0362425ca42b0e3ebc568ac630fc5b" translate="yes" xml:space="preserve">
          <source>Inline classes are allowed to inherit from interfaces:</source>
          <target state="translated">インラインクラスはインターフェイスを継承することができます。</target>
        </trans-unit>
        <trans-unit id="4c5881ab063c0ce817cf6f52ab599309c2d3110f" translate="yes" xml:space="preserve">
          <source>Inline classes are available only since Kotlin 1.3 and currently are &lt;em&gt;experimental&lt;/em&gt;. See details &lt;a href=&quot;#experimental-status-of-inline-classes&quot;&gt;below&lt;/a&gt;</source>
          <target state="translated">インラインクラスは、Kotlin 1.3以降でのみ使用でき、現在&lt;em&gt;実験&lt;/em&gt;段階です。&lt;a href=&quot;#experimental-status-of-inline-classes&quot;&gt;以下の&lt;/a&gt;詳細をご覧ください</target>
        </trans-unit>
        <trans-unit id="f253e2ca96472e7c3372c8639328c1d3867dc3b6" translate="yes" xml:space="preserve">
          <source>Inline classes are available only since Kotlin 1.3 and currently are &lt;em&gt;experimental&lt;/em&gt;. See details in the &lt;a href=&quot;inline-classes#experimental-status-of-inline-classes&quot;&gt;reference&lt;/a&gt;.</source>
          <target state="translated">インラインクラスは、Kotlin 1.3以降でのみ使用でき、現在&lt;em&gt;実験&lt;/em&gt;段階です。詳細は&lt;a href=&quot;inline-classes#experimental-status-of-inline-classes&quot;&gt;リファレンスを&lt;/a&gt;ご覧ください。</target>
        </trans-unit>
        <trans-unit id="1fe109e560117398094720f2c3a634950943781d" translate="yes" xml:space="preserve">
          <source>Inline classes are available only since Kotlin 1.3 and currently are in &lt;a href=&quot;evolution/components-stability&quot;&gt;Alpha&lt;/a&gt;. See details in the &lt;a href=&quot;inline-classes#alpha-status-of-inline-classes&quot;&gt;reference&lt;/a&gt;.</source>
          <target state="translated">インラインクラスはKotlin1.3以降でのみ利用可能で、現在は&lt;a href=&quot;evolution/components-stability&quot;&gt;Alpha&lt;/a&gt;です。詳細については、&lt;a href=&quot;inline-classes#alpha-status-of-inline-classes&quot;&gt;リファレンス&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="6ad02ddc63db8ea1a5da350db44423e72064462a" translate="yes" xml:space="preserve">
          <source>Inline classes are available only since Kotlin 1.3 and currently in &lt;a href=&quot;evolution/components-stability&quot;&gt;Alpha&lt;/a&gt;. See details &lt;a href=&quot;#alpha-status-of-inline-classes&quot;&gt;below&lt;/a&gt;</source>
          <target state="translated">インラインクラスは、Kotlin 1.3以降、現在&lt;a href=&quot;evolution/components-stability&quot;&gt;Alphaで&lt;/a&gt;のみ使用できます。&lt;a href=&quot;#alpha-status-of-inline-classes&quot;&gt;以下の&lt;/a&gt;詳細を参照してください</target>
        </trans-unit>
        <trans-unit id="a7a2cb12c8331fe8180ea13004fae9e89ef3e1fd" translate="yes" xml:space="preserve">
          <source>Inline classes support some functionality of regular classes. In particular, they are allowed to declare properties and functions:</source>
          <target state="translated">インライン・クラスは、通常のクラスのいくつかの機能をサポートしています。特に、プロパティや関数を宣言することができます。</target>
        </trans-unit>
        <trans-unit id="6c7769b31582b2d304756a0e1ee20904b47b72a0" translate="yes" xml:space="preserve">
          <source>Inline classes vs type aliases</source>
          <target state="translated">インラインクラスと型のエイリアス</target>
        </trans-unit>
        <trans-unit id="126b7ff7e58c488c8dbbe2c35dcf311f885d0926" translate="yes" xml:space="preserve">
          <source>Inline extension functions that were called on a null value of a platform type did not check the receiver for null and would thus allow null to escape into the other code. Kotlin 1.2 forces this check at the call sites, throwing an exception if the receiver is null.</source>
          <target state="translated">プラットフォーム型のNULL値で呼び出されるインライン拡張関数は、レシーバーがNULLであるかどうかをチェックしないため、NULLが他のコードに逃げてしまうことがありました。Kotlin 1.2 では、コールサイトでこのチェックを強制的に行い、レシーバーが null の場合は例外をスローします。</target>
        </trans-unit>
        <trans-unit id="5c804513cadec43c33b180af13b2e9aec456a962" translate="yes" xml:space="preserve">
          <source>Inline functions</source>
          <target state="translated">インライン関数</target>
        </trans-unit>
        <trans-unit id="9d0d1200e09d5fde96bd026c2e6ca0b2d04d5ad5" translate="yes" xml:space="preserve">
          <source>Inline functions are explained &lt;a href=&quot;inline-functions&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;inline-functions&quot;&gt;ここで&lt;/a&gt;はインライン関数について説明します。</target>
        </trans-unit>
        <trans-unit id="aa8db13612a09f046bbacee8122bb577b38d70fa" translate="yes" xml:space="preserve">
          <source>Inline functions are now allowed to have default values for their inlined functional parameters:</source>
          <target state="translated">インライン関数は、そのインライン関数のパラメータにデフォルト値を持つことができるようになりました。</target>
        </trans-unit>
        <trans-unit id="d6c978967701dd3225fcc54de37cf91805dd0b8d" translate="yes" xml:space="preserve">
          <source>Inline functions with &lt;a href=&quot;inline-functions#reified-type-parameters&quot;&gt;reified type parameters&lt;/a&gt; have their actual type arguments inlined at each call site, which enables &lt;code&gt;arg is T&lt;/code&gt; checks for the type parameters, but if &lt;code&gt;arg&lt;/code&gt; is an instance of a generic type itself, &lt;em&gt;its&lt;/em&gt; type arguments are still erased. Example:</source>
          <target state="translated">&lt;a href=&quot;inline-functions#reified-type-parameters&quot;&gt;型パラメーター&lt;/a&gt;を具体化したインライン関数は、実際の型引数が各呼び出しサイトでインライン化されます。これにより、 &lt;code&gt;arg is T&lt;/code&gt; が型パラメーターをチェックできるようになりますが、 &lt;code&gt;arg&lt;/code&gt; がジェネリック型自体のインスタンスである場合&lt;em&gt;、&lt;/em&gt;型引数は消去されます。例：</target>
        </trans-unit>
        <trans-unit id="dad40d691cb152e5ea04161c10815db00953ebbb" translate="yes" xml:space="preserve">
          <source>Inline functions with default functional parameters</source>
          <target state="translated">デフォルトの機能パラメータを持つインライン関数</target>
        </trans-unit>
        <trans-unit id="e60dd1451a60d33b2eca72439470d0150cb5cb84" translate="yes" xml:space="preserve">
          <source>Inline properties (since 1.1)</source>
          <target state="translated">インラインプロパティ(1.1以降</target>
        </trans-unit>
        <trans-unit id="6fec8c0d06ca4be7ff0c4bc9fa753ee420aa8bbc" translate="yes" xml:space="preserve">
          <source>Inline property accessors</source>
          <target state="translated">インラインプロパティアクセサ</target>
        </trans-unit>
        <trans-unit id="01185d7fc605bc19fbe95771073571a841e3e817" translate="yes" xml:space="preserve">
          <source>Inlining may cause the generated code to grow; however, if we do it in a reasonable way (i.e. avoiding inlining large functions), it will pay off in performance, especially at &quot;megamorphic&quot; call-sites inside loops.</source>
          <target state="translated">インライン化は生成されたコードを大きくする原因になるかもしれませんが、合理的な方法で行えば(大きな関数のインライン化を避けるなど)、特にループ内の「メガモルフィック」なコールサイトでは、パフォーマンスの面で報われます。</target>
        </trans-unit>
        <trans-unit id="aacf14c4398ec9fe537fae7e92753856f34743cb" translate="yes" xml:space="preserve">
          <source>Inner classes</source>
          <target state="translated">インナークラス</target>
        </trans-unit>
        <trans-unit id="bc3fa717af37b9f1e13149ace0b8f86497367e3c" translate="yes" xml:space="preserve">
          <source>Inner classes inheriting &lt;code&gt;Throwable&lt;/code&gt; that capture generic parameters from the outer class</source>
          <target state="translated">外部クラスからジェネリックパラメーターをキャプチャする &lt;code&gt;Throwable&lt;/code&gt; を継承する内部クラス</target>
        </trans-unit>
        <trans-unit id="258becf2f7c7396759bd76072890548fa224b9a4" translate="yes" xml:space="preserve">
          <source>Inner classes of generic types that inherit from &lt;code&gt;Throwable&lt;/code&gt; could violate type-safety in a throw-catch scenario and thus have been deprecated, with a warning in Kotlin 1.2 and an error in Kotlin 1.3.</source>
          <target state="translated">&lt;code&gt;Throwable&lt;/code&gt; から継承するジェネリック型の内部クラスは、throw-catchシナリオの型安全性に違反する可能性があるため、Kotlin 1.2の警告とKotlin 1.3のエラーで非推奨になりました。</target>
        </trans-unit>
        <trans-unit id="b14a7c09e5913aa9efafcb8d3f6e59361da51506" translate="yes" xml:space="preserve">
          <source>InputEventInit</source>
          <target state="translated">InputEventInit</target>
        </trans-unit>
        <trans-unit id="081e0fb72f26260fc891fc2cb6cbf71cf9e0d97f" translate="yes" xml:space="preserve">
          <source>Inserts all of the elements of the specified collection &lt;a href=&quot;../-mutable-list/add-all#kotlin.collections.MutableList%24addAll%28kotlin.Int%2C+kotlin.collections.Collection%28%28kotlin.collections.MutableList.E%29%29%29%2Felements&quot;&gt;elements&lt;/a&gt; into this list at the specified &lt;a href=&quot;../-mutable-list/add-all#kotlin.collections.MutableList%24addAll%28kotlin.Int%2C+kotlin.collections.Collection%28%28kotlin.collections.MutableList.E%29%29%29%2Findex&quot;&gt;index&lt;/a&gt;.</source>
          <target state="translated">指定されたコレクション&lt;a href=&quot;../-mutable-list/add-all#kotlin.collections.MutableList%24addAll%28kotlin.Int%2C+kotlin.collections.Collection%28%28kotlin.collections.MutableList.E%29%29%29%2Felements&quot;&gt;要素の&lt;/a&gt;すべての要素を、このリストの指定された&lt;a href=&quot;../-mutable-list/add-all#kotlin.collections.MutableList%24addAll%28kotlin.Int%2C+kotlin.collections.Collection%28%28kotlin.collections.MutableList.E%29%29%29%2Findex&quot;&gt;インデックスに&lt;/a&gt;挿入します。</target>
        </trans-unit>
        <trans-unit id="005fc2603487998262e6a4431116600f620b75a0" translate="yes" xml:space="preserve">
          <source>Inserts all of the elements of the specified collection &lt;a href=&quot;../-mutable-list/add-all#kotlin.collections.MutableList%24addAll(kotlin.Int,%20kotlin.collections.Collection((kotlin.collections.MutableList.E)))/elements&quot;&gt;elements&lt;/a&gt; into this list at the specified &lt;a href=&quot;../-mutable-list/add-all#kotlin.collections.MutableList%24addAll(kotlin.Int,%20kotlin.collections.Collection((kotlin.collections.MutableList.E)))/index&quot;&gt;index&lt;/a&gt;.</source>
          <target state="translated">指定されたコレクション&lt;a href=&quot;../-mutable-list/add-all#kotlin.collections.MutableList%24addAll(kotlin.Int,%20kotlin.collections.Collection((kotlin.collections.MutableList.E)))/elements&quot;&gt;要素の&lt;/a&gt;すべての要素を、このリストの指定された&lt;a href=&quot;../-mutable-list/add-all#kotlin.collections.MutableList%24addAll(kotlin.Int,%20kotlin.collections.Collection((kotlin.collections.MutableList.E)))/index&quot;&gt;インデックスに&lt;/a&gt;挿入します。</target>
        </trans-unit>
        <trans-unit id="887d8e7112f2b5499df8e54becfa68d97d70bd00" translate="yes" xml:space="preserve">
          <source>Inserts all of the elements of the specified collection &lt;a href=&quot;add-all#kotlin.collections.MutableList%24addAll%28kotlin.Int%2C+kotlin.collections.Collection%28%28kotlin.collections.MutableList.E%29%29%29%2Felements&quot;&gt;elements&lt;/a&gt; into this list at the specified &lt;a href=&quot;add-all#kotlin.collections.MutableList%24addAll%28kotlin.Int%2C+kotlin.collections.Collection%28%28kotlin.collections.MutableList.E%29%29%29%2Findex&quot;&gt;index&lt;/a&gt;.</source>
          <target state="translated">指定されたコレクション&lt;a href=&quot;add-all#kotlin.collections.MutableList%24addAll%28kotlin.Int%2C+kotlin.collections.Collection%28%28kotlin.collections.MutableList.E%29%29%29%2Felements&quot;&gt;要素の&lt;/a&gt;すべての要素を、このリストの指定された&lt;a href=&quot;add-all#kotlin.collections.MutableList%24addAll%28kotlin.Int%2C+kotlin.collections.Collection%28%28kotlin.collections.MutableList.E%29%29%29%2Findex&quot;&gt;インデックスに&lt;/a&gt;挿入します。</target>
        </trans-unit>
        <trans-unit id="602fbcd913879c3c9b700203739e32c4a9b2050d" translate="yes" xml:space="preserve">
          <source>Inserts all of the elements of the specified collection &lt;a href=&quot;add-all#kotlin.collections.MutableList%24addAll(kotlin.Int,%20kotlin.collections.Collection((kotlin.collections.MutableList.E)))/elements&quot;&gt;elements&lt;/a&gt; into this list at the specified &lt;a href=&quot;add-all#kotlin.collections.MutableList%24addAll(kotlin.Int,%20kotlin.collections.Collection((kotlin.collections.MutableList.E)))/index&quot;&gt;index&lt;/a&gt;.</source>
          <target state="translated">指定されたコレクション&lt;a href=&quot;add-all#kotlin.collections.MutableList%24addAll(kotlin.Int,%20kotlin.collections.Collection((kotlin.collections.MutableList.E)))/elements&quot;&gt;要素の&lt;/a&gt;すべての要素を、このリストの指定された&lt;a href=&quot;add-all#kotlin.collections.MutableList%24addAll(kotlin.Int,%20kotlin.collections.Collection((kotlin.collections.MutableList.E)))/index&quot;&gt;インデックスに&lt;/a&gt;挿入します。</target>
        </trans-unit>
        <trans-unit id="d0c7a2de4f7654463ee73faa30f98d50a3b73e7e" translate="yes" xml:space="preserve">
          <source>Inserts an element into the list at the specified &lt;a href=&quot;../-mutable-list/add#kotlin.collections.MutableList%24add%28kotlin.Int%2C+kotlin.collections.MutableList.E%29%2Findex&quot;&gt;index&lt;/a&gt;.</source>
          <target state="translated">リストの指定された&lt;a href=&quot;../-mutable-list/add#kotlin.collections.MutableList%24add%28kotlin.Int%2C+kotlin.collections.MutableList.E%29%2Findex&quot;&gt;インデックスに&lt;/a&gt;要素を挿入します。</target>
        </trans-unit>
        <trans-unit id="043751f897f4eb9dc49253608d3dad5a3c113e89" translate="yes" xml:space="preserve">
          <source>Inserts an element into the list at the specified &lt;a href=&quot;../-mutable-list/add#kotlin.collections.MutableList%24add(kotlin.Int,%20kotlin.collections.MutableList.E)/index&quot;&gt;index&lt;/a&gt;.</source>
          <target state="translated">指定された&lt;a href=&quot;../-mutable-list/add#kotlin.collections.MutableList%24add(kotlin.Int,%20kotlin.collections.MutableList.E)/index&quot;&gt;インデックスで&lt;/a&gt;リストに要素を挿入します。</target>
        </trans-unit>
        <trans-unit id="f6b6ae35f6d9d56e894884fb222d27eda900dc09" translate="yes" xml:space="preserve">
          <source>Inserts an element into the list at the specified &lt;a href=&quot;add#kotlin.collections.AbstractMutableList%24add%28kotlin.Int%2C+kotlin.collections.AbstractMutableList.E%29%2Findex&quot;&gt;index&lt;/a&gt;.</source>
          <target state="translated">リストの指定された&lt;a href=&quot;add#kotlin.collections.AbstractMutableList%24add%28kotlin.Int%2C+kotlin.collections.AbstractMutableList.E%29%2Findex&quot;&gt;インデックスに&lt;/a&gt;要素を挿入します。</target>
        </trans-unit>
        <trans-unit id="dc5d1b50a39baeed86e36617a548438e3f127155" translate="yes" xml:space="preserve">
          <source>Inserts an element into the list at the specified &lt;a href=&quot;add#kotlin.collections.AbstractMutableList%24add(kotlin.Int,%20kotlin.collections.AbstractMutableList.E)/index&quot;&gt;index&lt;/a&gt;.</source>
          <target state="translated">指定された&lt;a href=&quot;add#kotlin.collections.AbstractMutableList%24add(kotlin.Int,%20kotlin.collections.AbstractMutableList.E)/index&quot;&gt;インデックスで&lt;/a&gt;リストに要素を挿入します。</target>
        </trans-unit>
        <trans-unit id="6c1226de8bd8dc851fb3874b9c31e306f3fa56c5" translate="yes" xml:space="preserve">
          <source>Inserts an element into the list at the specified &lt;a href=&quot;add#kotlin.collections.MutableList%24add%28kotlin.Int%2C+kotlin.collections.MutableList.E%29%2Findex&quot;&gt;index&lt;/a&gt;.</source>
          <target state="translated">リストの指定された&lt;a href=&quot;add#kotlin.collections.MutableList%24add%28kotlin.Int%2C+kotlin.collections.MutableList.E%29%2Findex&quot;&gt;インデックスに&lt;/a&gt;要素を挿入します。</target>
        </trans-unit>
        <trans-unit id="8e37de1820797a87c23300e79e4b0ed919d09e2a" translate="yes" xml:space="preserve">
          <source>Inserts an element into the list at the specified &lt;a href=&quot;add#kotlin.collections.MutableList%24add(kotlin.Int,%20kotlin.collections.MutableList.E)/index&quot;&gt;index&lt;/a&gt;.</source>
          <target state="translated">指定された&lt;a href=&quot;add#kotlin.collections.MutableList%24add(kotlin.Int,%20kotlin.collections.MutableList.E)/index&quot;&gt;インデックスで&lt;/a&gt;リストに要素を挿入します。</target>
        </trans-unit>
        <trans-unit id="27480ec1869e9733f33a48ab29f659fcb2a460a3" translate="yes" xml:space="preserve">
          <source>Inserts characters in a subarray of the specified character array &lt;a href=&quot;insert-range#kotlin.text%24insertRange(java.lang.StringBuilder,%20kotlin.Int,%20kotlin.CharArray,%20kotlin.Int,%20kotlin.Int)/value&quot;&gt;value&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert-range#kotlin.text%24insertRange(java.lang.StringBuilder,%20kotlin.Int,%20kotlin.CharArray,%20kotlin.Int,%20kotlin.Int)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</source>
          <target state="translated">指定された文字配列&lt;a href=&quot;insert-range#kotlin.text%24insertRange(java.lang.StringBuilder,%20kotlin.Int,%20kotlin.CharArray,%20kotlin.Int,%20kotlin.Int)/value&quot;&gt;値の&lt;/a&gt;サブ配列内の文字を、指定された&lt;a href=&quot;insert-range#kotlin.text%24insertRange(java.lang.StringBuilder,%20kotlin.Int,%20kotlin.CharArray,%20kotlin.Int,%20kotlin.Int)/index&quot;&gt;インデックス&lt;/a&gt;でこの文字列ビルダーに挿入し、このインスタンスを返します。</target>
        </trans-unit>
        <trans-unit id="0751e96b7b08da95e20ff3bc7df0567c20077897" translate="yes" xml:space="preserve">
          <source>Inserts characters in a subarray of the specified character array &lt;a href=&quot;insert-range#kotlin.text%24insertRange(kotlin.text.StringBuilder,%20kotlin.Int,%20kotlin.CharArray,%20kotlin.Int,%20kotlin.Int)/value&quot;&gt;value&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert-range#kotlin.text%24insertRange(kotlin.text.StringBuilder,%20kotlin.Int,%20kotlin.CharArray,%20kotlin.Int,%20kotlin.Int)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</source>
          <target state="translated">指定された文字配列&lt;a href=&quot;insert-range#kotlin.text%24insertRange(kotlin.text.StringBuilder,%20kotlin.Int,%20kotlin.CharArray,%20kotlin.Int,%20kotlin.Int)/value&quot;&gt;値の&lt;/a&gt;サブ配列内の文字を、指定された&lt;a href=&quot;insert-range#kotlin.text%24insertRange(kotlin.text.StringBuilder,%20kotlin.Int,%20kotlin.CharArray,%20kotlin.Int,%20kotlin.Int)/index&quot;&gt;インデックス&lt;/a&gt;でこの文字列ビルダーに挿入し、このインスタンスを返します。</target>
        </trans-unit>
        <trans-unit id="3e04a0c39fa9e9ba6f8f7b53f66419ea35f91587" translate="yes" xml:space="preserve">
          <source>Inserts characters in a subarray of the specified character array &lt;a href=&quot;insert-range#kotlin.text.StringBuilder%24insertRange(kotlin.Int,%20kotlin.CharArray,%20kotlin.Int,%20kotlin.Int)/value&quot;&gt;value&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert-range#kotlin.text.StringBuilder%24insertRange(kotlin.Int,%20kotlin.CharArray,%20kotlin.Int,%20kotlin.Int)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</source>
          <target state="translated">指定された文字配列&lt;a href=&quot;insert-range#kotlin.text.StringBuilder%24insertRange(kotlin.Int,%20kotlin.CharArray,%20kotlin.Int,%20kotlin.Int)/value&quot;&gt;値の&lt;/a&gt;サブ配列内の文字を、指定された&lt;a href=&quot;insert-range#kotlin.text.StringBuilder%24insertRange(kotlin.Int,%20kotlin.CharArray,%20kotlin.Int,%20kotlin.Int)/index&quot;&gt;インデックス&lt;/a&gt;でこの文字列ビルダーに挿入し、このインスタンスを返します。</target>
        </trans-unit>
        <trans-unit id="990caaef55fa9369abe10fe21e08b659ee5241e9" translate="yes" xml:space="preserve">
          <source>Inserts characters in a subsequence of the specified character sequence &lt;a href=&quot;../insert#kotlin.text%24insert(kotlin.text.StringBuilder,%20kotlin.Int,%20kotlin.CharSequence?,%20kotlin.Int,%20kotlin.Int)/csq&quot;&gt;csq&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;../insert#kotlin.text%24insert(kotlin.text.StringBuilder,%20kotlin.Int,%20kotlin.CharSequence?,%20kotlin.Int,%20kotlin.Int)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</source>
          <target state="translated">指定された文字シーケンス&lt;a href=&quot;../insert#kotlin.text%24insert(kotlin.text.StringBuilder,%20kotlin.Int,%20kotlin.CharSequence?,%20kotlin.Int,%20kotlin.Int)/csq&quot;&gt;csqのサブ&lt;/a&gt;シーケンス内の文字を、指定された&lt;a href=&quot;../insert#kotlin.text%24insert(kotlin.text.StringBuilder,%20kotlin.Int,%20kotlin.CharSequence?,%20kotlin.Int,%20kotlin.Int)/index&quot;&gt;インデックス&lt;/a&gt;でこの文字列ビルダーに挿入し、このインスタンスを返します。</target>
        </trans-unit>
        <trans-unit id="56381b6576df78ab7498f4c21ed74ffb38fce356" translate="yes" xml:space="preserve">
          <source>Inserts characters in a subsequence of the specified character sequence &lt;a href=&quot;insert#kotlin.text%24insert(kotlin.text.StringBuilder,%20kotlin.Int,%20kotlin.CharSequence?,%20kotlin.Int,%20kotlin.Int)/csq&quot;&gt;csq&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert#kotlin.text%24insert(kotlin.text.StringBuilder,%20kotlin.Int,%20kotlin.CharSequence?,%20kotlin.Int,%20kotlin.Int)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</source>
          <target state="translated">指定された文字シーケンス&lt;a href=&quot;insert#kotlin.text%24insert(kotlin.text.StringBuilder,%20kotlin.Int,%20kotlin.CharSequence?,%20kotlin.Int,%20kotlin.Int)/csq&quot;&gt;csqのサブ&lt;/a&gt;シーケンス内の文字を、指定された&lt;a href=&quot;insert#kotlin.text%24insert(kotlin.text.StringBuilder,%20kotlin.Int,%20kotlin.CharSequence?,%20kotlin.Int,%20kotlin.Int)/index&quot;&gt;インデックス&lt;/a&gt;でこの文字列ビルダーに挿入し、このインスタンスを返します。</target>
        </trans-unit>
        <trans-unit id="13ca00255e68344adaf9baf7d5fd54a64418b339" translate="yes" xml:space="preserve">
          <source>Inserts characters in a subsequence of the specified character sequence &lt;a href=&quot;insert-range#kotlin.text%24insertRange(java.lang.StringBuilder,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.Int)/value&quot;&gt;value&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert-range#kotlin.text%24insertRange(java.lang.StringBuilder,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.Int)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</source>
          <target state="translated">指定された文字シーケンス&lt;a href=&quot;insert-range#kotlin.text%24insertRange(java.lang.StringBuilder,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.Int)/value&quot;&gt;値の&lt;/a&gt;サブシーケンス内の文字を、指定された&lt;a href=&quot;insert-range#kotlin.text%24insertRange(java.lang.StringBuilder,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.Int)/index&quot;&gt;インデックス&lt;/a&gt;でこの文字列ビルダーに挿入し、このインスタンスを返します。</target>
        </trans-unit>
        <trans-unit id="f16ec6bfc81f5c607f3cb9b48f5e7a410c32c025" translate="yes" xml:space="preserve">
          <source>Inserts characters in a subsequence of the specified character sequence &lt;a href=&quot;insert-range#kotlin.text%24insertRange(kotlin.text.StringBuilder,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.Int)/value&quot;&gt;value&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert-range#kotlin.text%24insertRange(kotlin.text.StringBuilder,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.Int)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</source>
          <target state="translated">指定された文字シーケンス&lt;a href=&quot;insert-range#kotlin.text%24insertRange(kotlin.text.StringBuilder,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.Int)/value&quot;&gt;値の&lt;/a&gt;サブシーケンス内の文字を、指定された&lt;a href=&quot;insert-range#kotlin.text%24insertRange(kotlin.text.StringBuilder,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.Int)/index&quot;&gt;インデックス&lt;/a&gt;でこの文字列ビルダーに挿入し、このインスタンスを返します。</target>
        </trans-unit>
        <trans-unit id="b15a142e3f1c0e94cad906174d3311d39fef798f" translate="yes" xml:space="preserve">
          <source>Inserts characters in a subsequence of the specified character sequence &lt;a href=&quot;insert-range#kotlin.text.StringBuilder%24insertRange(kotlin.Int,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.Int)/value&quot;&gt;value&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert-range#kotlin.text.StringBuilder%24insertRange(kotlin.Int,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.Int)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</source>
          <target state="translated">指定された文字シーケンス&lt;a href=&quot;insert-range#kotlin.text.StringBuilder%24insertRange(kotlin.Int,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.Int)/value&quot;&gt;値の&lt;/a&gt;サブシーケンス内の文字を、指定された&lt;a href=&quot;insert-range#kotlin.text.StringBuilder%24insertRange(kotlin.Int,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.Int)/index&quot;&gt;インデックス&lt;/a&gt;でこの文字列ビルダーに挿入し、このインスタンスを返します。</target>
        </trans-unit>
        <trans-unit id="98e8ddbbdefb8f6d9c8e1f1a1ec159981fb75050" translate="yes" xml:space="preserve">
          <source>Inserts characters in the specified character array &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.CharArray)/value&quot;&gt;value&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.CharArray)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</source>
          <target state="translated">指定された文字配列&lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.CharArray)/value&quot;&gt;値の&lt;/a&gt;文字を、指定された&lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.CharArray)/index&quot;&gt;インデックス&lt;/a&gt;でこの文字列ビルダーに挿入し、このインスタンスを返します。</target>
        </trans-unit>
        <trans-unit id="8bd299382c17ed7be741a94000ce27e3cb569545" translate="yes" xml:space="preserve">
          <source>Inserts characters in the specified character sequence &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.CharSequence?)/value&quot;&gt;value&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.CharSequence?)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</source>
          <target state="translated">指定された文字シーケンス&lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.CharSequence?)/value&quot;&gt;値の&lt;/a&gt;文字を、指定された&lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.CharSequence?)/index&quot;&gt;インデックス&lt;/a&gt;でこの文字列ビルダーに挿入し、このインスタンスを返します。</target>
        </trans-unit>
        <trans-unit id="c10488d941ff5f739e50f3ed8d100fc28145f09c" translate="yes" xml:space="preserve">
          <source>Inserts the specified character &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.Char)/value&quot;&gt;value&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.Char)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</source>
          <target state="translated">指定された文字&lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.Char)/value&quot;&gt;値&lt;/a&gt;をこの文字列ビルダーの指定された&lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.Char)/index&quot;&gt;インデックスに&lt;/a&gt;挿入し、このインスタンスを返します。</target>
        </trans-unit>
        <trans-unit id="ad678e17f874b23d4231a5cb1e5b3edfa0684922" translate="yes" xml:space="preserve">
          <source>Inserts the string &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.String?)/value&quot;&gt;value&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.String?)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</source>
          <target state="translated">指定された&lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.String?)/index&quot;&gt;インデックス&lt;/a&gt;でこの文字列ビルダーに文字列&lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.String?)/value&quot;&gt;値&lt;/a&gt;を挿入し、このインスタンスを返します。</target>
        </trans-unit>
        <trans-unit id="cb5279ca89113fa744f9ed912c21f45c93146fab" translate="yes" xml:space="preserve">
          <source>Inserts the string representation of the specified boolean &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.Boolean)/value&quot;&gt;value&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.Boolean)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</source>
          <target state="translated">指定されたブール&lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.Boolean)/value&quot;&gt;値&lt;/a&gt;の文字列表現を、この文字列ビルダーの指定された&lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.Boolean)/index&quot;&gt;インデックスに&lt;/a&gt;挿入し、このインスタンスを返します。</target>
        </trans-unit>
        <trans-unit id="b8ce5257d0d44bc8ee828b4f0aa168d27143f4fc" translate="yes" xml:space="preserve">
          <source>Inserts the string representation of the specified object &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.Any?)/value&quot;&gt;value&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.Any?)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</source>
          <target state="translated">指定されたオブジェクト&lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.Any?)/value&quot;&gt;値&lt;/a&gt;の文字列表現を、指定された&lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.Any?)/index&quot;&gt;インデックス&lt;/a&gt;でこの文字列ビルダーに挿入し、このインスタンスを返します。</target>
        </trans-unit>
        <trans-unit id="40e63a4d54fc0992dbc62da98003576fd7d50dbb" translate="yes" xml:space="preserve">
          <source>Inside a class, you can declare extensions for another class. Inside such an extension, there are multiple &lt;em&gt;implicit receivers&lt;/em&gt; - objects members of which can be accessed without a qualifier. The instance of the class in which the extension is declared is called &lt;em&gt;dispatch receiver&lt;/em&gt;, and the instance of the receiver type of the extension method is called &lt;em&gt;extension receiver&lt;/em&gt;.</source>
          <target state="translated">クラス内では、別のクラスの拡張を宣言できます。このような拡張機能の内部には、複数の&lt;em&gt;暗黙的なレシーバー&lt;/em&gt;があり、そのメンバーには修飾子なしでアクセスできます。拡張が宣言されているクラスのインスタンスは&lt;em&gt;ディスパッチレシーバ&lt;/em&gt;と呼ば&lt;em&gt;れ&lt;/em&gt;、拡張メソッドのレシーバタイプのインスタンスは&lt;em&gt;拡張レシーバ&lt;/em&gt;と呼ばれます。</target>
        </trans-unit>
        <trans-unit id="97c34b033d93e70cd2130ab46bfa71cd52ac56f6" translate="yes" xml:space="preserve">
          <source>Inside a function a &lt;code&gt;vararg&lt;/code&gt;-parameter of type &lt;code&gt;T&lt;/code&gt; is visible as an array of &lt;code&gt;T&lt;/code&gt;, i.e. the &lt;code&gt;ts&lt;/code&gt; variable in the example above has type &lt;code&gt;Array&amp;lt;out T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">関数内では、タイプ &lt;code&gt;T&lt;/code&gt; の &lt;code&gt;vararg&lt;/code&gt; パラメータは &lt;code&gt;T&lt;/code&gt; の配列として表示されます。つまり、上記の例の &lt;code&gt;ts&lt;/code&gt; 変数はタイプ &lt;code&gt;Array&amp;lt;out T&amp;gt;&lt;/code&gt; 持っています。</target>
        </trans-unit>
        <trans-unit id="826cc6f6147dd291bf22ea4078acd71a79ba87cf" translate="yes" xml:space="preserve">
          <source>Inside a lambda expression with receiver, you can use &lt;code&gt;this&lt;/code&gt; to refer to the receiver object (in this case, &lt;code&gt;car&lt;/code&gt;). As usual, you can omit &lt;code&gt;this&lt;/code&gt; if there are no naming conflicts, which is why we can simply say &lt;code&gt;$horsepowers&lt;/code&gt; instead of &lt;code&gt;${this.horsepowers}&lt;/code&gt;. So beware that in Kotlin, &lt;code&gt;this&lt;/code&gt; can have different meanings depending on the context: if used inside (possibly nested) lambda expressions with receivers, it refers to the receiver object of the innermost enclosing lambda expression with receiver. If you need to &quot;break out&quot; of the function literal and get the &quot;original&quot; &lt;code&gt;this&lt;/code&gt; (the instance the member function you're inside is executing on), mention the containing class name after &lt;code&gt;this@&lt;/code&gt; - so if you're inside a function literal with receiver inside a member function of Car, use &lt;code&gt;this@Car&lt;/code&gt;.</source>
          <target state="translated">レシーバー付きのラムダ式の内部では、 &lt;code&gt;this&lt;/code&gt; を使用してレシーバーオブジェクト（この場合は &lt;code&gt;car&lt;/code&gt; ）を参照できます。いつものように、名前の競合がない場合は &lt;code&gt;this&lt;/code&gt; を省略できます。そのため、 &lt;code&gt;${this.horsepowers}&lt;/code&gt; ではなく &lt;code&gt;$horsepowers&lt;/code&gt; とだけ言うことができます。したがって、Kotlinでは、 &lt;code&gt;this&lt;/code&gt; はコンテキストに応じて異なる意味を持つ可能性があることに注意してください。レシーバーを持つ（ネストされている可能性がある）ラムダ式内で使用される場合、レシーバーを持つ最も内側の外側のラムダ式のレシーバーオブジェクトを参照します。関数リテラルを「抜け出し」、「元の」 &lt;code&gt;this&lt;/code&gt; を取得する必要がある場合（内部にいるメンバー関数が実行されているインスタンス）、 &lt;code&gt;this@&lt;/code&gt; を含むクラス名をthis @の後に記述します。したがって、Carのメンバー関数内にレシーバーがある関数リテラル内にいる場合は、 &lt;code&gt;this@Car&lt;/code&gt; 使用します。</target>
        </trans-unit>
        <trans-unit id="d76861f103960eff4ae0c7430fef1ebd5d3e542c" translate="yes" xml:space="preserve">
          <source>Inside an inner class, accessing the superclass of the outer class is done with the &lt;em&gt;super&lt;/em&gt; keyword qualified with the outer class name: &lt;code&gt;super@Outer&lt;/code&gt;:</source>
          <target state="translated">内部クラス内では、外部クラスのスーパークラスへのアクセスは、外部クラス名で修飾された&lt;em&gt;super&lt;/em&gt;キーワードで行われます： &lt;code&gt;super@Outer&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="8ccb5c0d6d5858f7a6cc2ca5c66201a3c3cecf82" translate="yes" xml:space="preserve">
          <source>Inside enum entries, defining a nested type that is not an &lt;code&gt;inner class&lt;/code&gt; has been deprecated due to issues in the initialization logic. This causes a warning in Kotlin 1.2 and will become an error in Kotlin 1.3.</source>
          <target state="translated">列挙型エントリ内で、 &lt;code&gt;inner class&lt;/code&gt; ではないネストされた型を定義することは、初期化ロジックの問題により廃止されました。これにより、Kotlin 1.2では警告が発生し、Kotlin 1.3ではエラーになります。</target>
        </trans-unit>
        <trans-unit id="d5019da5c150ca59c7fa4dd453ea0a06cf96e080" translate="yes" xml:space="preserve">
          <source>Inside the &lt;code&gt;apply&lt;/code&gt; block, &lt;code&gt;this&lt;/code&gt; refers to &lt;code&gt;maybeNull&lt;/code&gt;. There's an implicit &lt;code&gt;this&lt;/code&gt; in front of &lt;code&gt;memberPropertyA&lt;/code&gt;, &lt;code&gt;memberPropertyB&lt;/code&gt;, and &lt;code&gt;memberFunctionA&lt;/code&gt; (unless these don't exist on &lt;code&gt;maybeNull&lt;/code&gt;, in which case they'll be looked for in the containing scopes). Afterwards, &lt;code&gt;memberFunctionB()&lt;/code&gt; is also invoked on &lt;code&gt;maybeNull&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;apply&lt;/code&gt; ブロック内では、 &lt;code&gt;this&lt;/code&gt; は &lt;code&gt;maybeNull&lt;/code&gt; を参照します。 &lt;code&gt;memberPropertyA&lt;/code&gt; 、 &lt;code&gt;memberPropertyB&lt;/code&gt; 、および &lt;code&gt;memberFunctionA&lt;/code&gt; の前に暗黙の &lt;code&gt;this&lt;/code&gt; があります（maybeNullにこれらが存在しない場合を &lt;code&gt;maybeNull&lt;/code&gt; ます。その場合、それらは包含スコープで検索されます）。その後、 &lt;code&gt;memberFunctionB()&lt;/code&gt; も呼び出され &lt;code&gt;maybeNull&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f13d8be73f140532f836309395f0554a59c9c6f7" translate="yes" xml:space="preserve">
          <source>Inside the body of the function literal, the receiver object passed to a call becomes an &lt;em&gt;implicit&lt;/em&gt;&lt;em&gt;this&lt;/em&gt;, so that you can access the members of that receiver object without any additional qualifiers, or access the receiver object using a &lt;a href=&quot;this-expressions&quot;&gt;&lt;code&gt;this&lt;/code&gt; expression&lt;/a&gt;.</source>
          <target state="translated">関数リテラルの本体内で、呼び出しに渡されるレシーバーオブジェクトは&lt;em&gt;暗黙の&lt;/em&gt;&lt;em&gt;this&lt;/em&gt;になるため、追加の修飾子なしでそのレシーバーオブジェクトのメンバーにアクセスしたり、&lt;a href=&quot;this-expressions&quot;&gt; &lt;code&gt;this&lt;/code&gt; 式&lt;/a&gt;を使用してレシーバーオブジェクトにアクセスしたりできます。</target>
        </trans-unit>
        <trans-unit id="2558cc93d05f62b7942210cca1e0fecc8bdce932" translate="yes" xml:space="preserve">
          <source>Inside the class that declares a lateinit property, you can check if it has been initialized:</source>
          <target state="translated">lateinitプロパティを宣言しているクラスの内部では、初期化されているかどうかを確認することができます。</target>
        </trans-unit>
        <trans-unit id="987506c0627eacba63113c8eade53536a31e1484" translate="yes" xml:space="preserve">
          <source>Inside the file, the documentation for the module as a whole and for individual packages is introduced by the corresponding first-level headings. The text of the heading must be &quot;Module &lt;code&gt;&amp;lt;module name&amp;gt;&lt;/code&gt;&quot; for the module, and &quot;Package &lt;code&gt;&amp;lt;package qualified name&amp;gt;&lt;/code&gt;&quot; for a package.</source>
          <target state="translated">ファイル内では、モジュール全体のドキュメントと個々のパッケージのドキュメントが、対応する第1レベルの見出しで紹介されています。見出しのテキストは、モジュールの場合は「モジュール &lt;code&gt;&amp;lt;module name&amp;gt;&lt;/code&gt; 」、パッケージの場合は「パッケージ &lt;code&gt;&amp;lt;package qualified name&amp;gt;&lt;/code&gt; 」である必要があります。</target>
        </trans-unit>
        <trans-unit id="493e88f297e12412d7ac95bb437b962fd0497829" translate="yes" xml:space="preserve">
          <source>Inside the lambda of a scope function, the context object is available by a short reference instead of its actual name. Each scope function uses one of two ways to access the context object: as a lambda &lt;a href=&quot;lambdas#function-literals-with-receiver&quot;&gt;receiver&lt;/a&gt; (&lt;code&gt;this&lt;/code&gt;) or as a lambda argument (&lt;code&gt;it&lt;/code&gt;). Both provide the same capabilities, so we'll describe the pros and cons of each for different cases and provide recommendations on their use.</source>
          <target state="translated">スコープ関数のラムダ内では、コンテキストオブジェクトは、実際の名前の代わりに短い参照で利用できます。各スコープ関数は、ラムダ&lt;a href=&quot;lambdas#function-literals-with-receiver&quot;&gt;レシーバー&lt;/a&gt;（ &lt;code&gt;this&lt;/code&gt; ）またはラムダ引数（ &lt;code&gt;it&lt;/code&gt; ）として、コンテキストオブジェクトにアクセスする2つの方法のいずれかを使用します。どちらも同じ機能を提供するため、さまざまなケースについてそれぞれの長所と短所を説明し、それらの使用に関する推奨事項を提供します。</target>
        </trans-unit>
        <trans-unit id="5003ad2518c8a72a35acc2813b3f299786173c02" translate="yes" xml:space="preserve">
          <source>Inspect Generated Kotlin APIs from a C library</source>
          <target state="translated">生成されたKotlin APIをCライブラリから検査する</target>
        </trans-unit>
        <trans-unit id="40cd793a9f0552fd84c4436f73c844d1482e9756" translate="yes" xml:space="preserve">
          <source>Inspect the contents of &lt;code&gt;dist/klib/platform/$target&lt;/code&gt; of the distribution for the details.</source>
          <target state="translated">詳細については、ディストリビューションの &lt;code&gt;dist/klib/platform/$target&lt;/code&gt; の内容を調べてください。</target>
        </trans-unit>
        <trans-unit id="125c70324902d1ea37a08feb6e548d2fa859e9e8" translate="yes" xml:space="preserve">
          <source>Inspecting Generated Kotlin APIs for a C library</source>
          <target state="translated">C ライブラリの生成された Kotlin API を検査する</target>
        </trans-unit>
        <trans-unit id="bc318e2b8cd3f066b53b59698e603a8b1ca8d81c" translate="yes" xml:space="preserve">
          <source>Install custom unhandled exception hook. Returns old hook, or null if it was not specified. Hook is invoked whenever there's uncaught exception reaching boundaries of the Kotlin world, i.e. top level main(), or when Objective-C to Kotlin call not marked with @Throws throws an exception. Hook must be a frozen lambda, so that it could be called from any thread/worker. Hook is invoked once, and is cleared afterwards, so that memory leak detection works as expected even with custom exception hooks.</source>
          <target state="translated">カスタムのアンハンドレッド例外フックをインストールします。古いフックを返すか、指定されていない場合は null を返します。フックは、捕らえられなかった例外が Kotlin の世界の境界に到達したとき、つまりトップレベルの main()や、@Throws でマークされていない Objective-C から Kotlin への呼び出しで例外が発生したときに呼び出されます。フックはどのスレッドやワーカーからでも呼び出せるように、フリーズしたラムダでなければならない。フックは一度だけ呼び出され、その後はクリアされるので、カスタムの例外フックを使ってもメモリリークの検出は期待通りに動作します。</target>
        </trans-unit>
        <trans-unit id="61dc4e9bf861172198001de007eee7dfc119f627" translate="yes" xml:space="preserve">
          <source>Install libgit2 and prepare stubs for the git library:</source>
          <target state="translated">libgit2 をインストールし、git ライブラリ用のスタブを用意します。</target>
        </trans-unit>
        <trans-unit id="55178375f2d34a4d0b5f0a6c687d2b1b982ae90c" translate="yes" xml:space="preserve">
          <source>Install the &lt;a href=&quot;https://chrome.google.com/webstore/detail/jetbrains-ide-support/hmhgeddbohgjknpmjagkdomcpobmllji?hl=en&quot;&gt;JetBrains Chrome Extension&lt;/a&gt; which allows debugging inside IntelliJ IDEA via Chrome. This is useful for any type of web application developed with IntelliJ IDEA, not just Kotlin.</source>
          <target state="translated">&lt;a href=&quot;https://chrome.google.com/webstore/detail/jetbrains-ide-support/hmhgeddbohgjknpmjagkdomcpobmllji?hl=en&quot;&gt;JetBrains Chrome拡張機能&lt;/a&gt;をインストールして、Chrome経由でIntelliJ IDEA内でデバッグできるようにします。これは、Kotlinだけでなく、IntelliJ IDEAで開発されたあらゆる種類のWebアプリケーションに役立ちます。</target>
        </trans-unit>
        <trans-unit id="cba3ec3086c29abcbfa73fe1ec7eb10077b3664f" translate="yes" xml:space="preserve">
          <source>Install the &lt;a href=&quot;https://cocoapods.org/&quot;&gt;CocoaPods dependency manager&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://cocoapods.org/&quot;&gt;CocoaPods依存関係マネージャー&lt;/a&gt;をインストールします。</target>
        </trans-unit>
        <trans-unit id="7237a8f52f82477e8aca289f73e7feebfb253754" translate="yes" xml:space="preserve">
          <source>Install the &lt;a href=&quot;https://github.com/square/cocoapods-generate&quot;&gt;&lt;code&gt;cocoapods-generate&lt;/code&gt;&lt;/a&gt; plugin.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/square/cocoapods-generate&quot;&gt; &lt;code&gt;cocoapods-generate&lt;/code&gt; &lt;/a&gt;プラグインをインストールします。</target>
        </trans-unit>
        <trans-unit id="d91d23355e44b9f891a149ed27d5dd594ef16726" translate="yes" xml:space="preserve">
          <source>Install the &lt;a href=&quot;https://plugins.jetbrains.com/plugin/10081-edutools&quot;&gt;EduTools plugin&lt;/a&gt; for IDEA and complete exercises from the &lt;a href=&quot;https://www.jetbrains.com/help/education/learner-start-guide.html?section=Kotlin%20Koans&quot;&gt;Kotlin Koans course&lt;/a&gt;</source>
          <target state="translated">IDEA用の&lt;a href=&quot;https://plugins.jetbrains.com/plugin/10081-edutools&quot;&gt;EduToolsプラグイン&lt;/a&gt;をインストールし、KotlinKoans&lt;a href=&quot;https://www.jetbrains.com/help/education/learner-start-guide.html?section=Kotlin%20Koans&quot;&gt;コースの&lt;/a&gt;演習を完了します</target>
        </trans-unit>
        <trans-unit id="a6c9c342f22b1bebf06cebee1a33f0bf01b82e59" translate="yes" xml:space="preserve">
          <source>Install the CocoaPods dependency manager and plugin</source>
          <target state="translated">CocoaPods の依存関係マネージャとプラグインをインストールします。</target>
        </trans-unit>
        <trans-unit id="fdaed5952d98f86231a297a2212142ac7c035122" translate="yes" xml:space="preserve">
          <source>Installing EduTools plugin</source>
          <target state="translated">EduToolsプラグインのインストール</target>
        </trans-unit>
        <trans-unit id="2a79a656994e8f8c151cea0c7b39c2c9e4d16ed5" translate="yes" xml:space="preserve">
          <source>Instance Checks</source>
          <target state="translated">インスタンスチェック</target>
        </trans-unit>
        <trans-unit id="9e1218ddd72144e647203114e5a8e7ec310019cb" translate="yes" xml:space="preserve">
          <source>Instance fields</source>
          <target state="translated">インスタンスフィールド</target>
        </trans-unit>
        <trans-unit id="808164c9992eeb307ee53ea9dae39f6fb259b6e5" translate="yes" xml:space="preserve">
          <source>Instance required to make a call to the member, or an outer class instance for an inner class constructor.</source>
          <target state="translated">メンバへの呼び出しに必要なインスタンス、またはインナー・クラスのコンストラクタのためのアウター・クラスのインスタンス。</target>
        </trans-unit>
        <trans-unit id="a15783fb8d36e7147f368f4e99e9d406c5062f79" translate="yes" xml:space="preserve">
          <source>Instantiating a function type</source>
          <target state="translated">関数型のインスタンス化</target>
        </trans-unit>
        <trans-unit id="323fad682a062c4a52dfeb27dd2280fe7981b362" translate="yes" xml:space="preserve">
          <source>Instead of &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;coroutineScope&lt;/a&gt;, we can use &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/supervisor-scope.html&quot;&gt;supervisorScope&lt;/a&gt; for &lt;em&gt;scoped&lt;/em&gt; concurrency. It propagates the cancellation in one direction only and cancels all its children only if it failed itself. It also waits for all children before completion just like &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;coroutineScope&lt;/a&gt; does.</source>
          <target state="translated">&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;coroutineScopeの&lt;/a&gt;代わりに、&lt;em&gt;スコープ付き&lt;/em&gt;同時実行に&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/supervisor-scope.html&quot;&gt;supervisorScope&lt;/a&gt;を&lt;em&gt;使用&lt;/em&gt;できます。キャンセルは一方向にのみ伝播し、失敗した場合にのみすべての子をキャンセルします。また、&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;coroutineScope&lt;/a&gt;と同様に、完了する前にすべての子を待機します。</target>
        </trans-unit>
        <trans-unit id="4d2cc7618aade0b4e22b2f6e46628e00aba0ed39" translate="yes" xml:space="preserve">
          <source>Instead of calling the method &lt;code&gt;matches&lt;/code&gt; directly we are storing a reference to it. Such reference is bound to its receiver. It can be called directly (like in the example above) or used whenever an expression of function type is expected:</source>
          <target state="translated">メソッド &lt;code&gt;matches&lt;/code&gt; 直接呼び出す代わりに、メソッドへの参照を保存します。そのような参照はそのレシーバーにバインドされます。（上記の例のように）直接呼び出すことも、関数型の式が期待される場合はいつでも使用できます。</target>
        </trans-unit>
        <trans-unit id="8213790556130c398f868064e28de372b2469df8" translate="yes" xml:space="preserve">
          <source>Instead of creating a function object for the parameter and generating a call, the compiler could emit the following code:</source>
          <target state="translated">パラメータの関数オブジェクトを作成して呼び出しを生成する代わりに、コンパイラは以下のコードを出力します。</target>
        </trans-unit>
        <trans-unit id="f83cef13eec16cda3d2cf44a7d9356f601633a76" translate="yes" xml:space="preserve">
          <source>Instead of threads Kotlin/Native runtime offers the concept of workers: concurrently executed control flow streams with an associated request queue. Workers are very similar to the actors in the Actor Model. A worker can exchange Kotlin objects with another worker, so that at any moment each mutable object is owned by a single worker, but ownership can be transferred. See section &lt;a href=&quot;#transfer&quot;&gt;Object transfer and freezing&lt;/a&gt;.</source>
          <target state="translated">スレッドの代わりにKotlin / Nativeランタイムはワーカーの概念を提供します：同時に実行される制御フローストリームと関連するリクエストキュー。ワーカーは、アクターモデルのアクターとよく似ています。ワーカーはKotlinオブジェクトを別のワーカーと交換できます。そのため、いつでも各可変オブジェクトは単一のワーカーによって所有されますが、所有権は譲渡できます。See section &lt;a href=&quot;#transfer&quot;&gt;オブジェクトの転送と凍結&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="72f70be3d9872cba860894ac5cf17293ed0d78f8" translate="yes" xml:space="preserve">
          <source>Instructs compiler to generate or omit wildcards for type arguments corresponding to parameters with declaration-site variance, for example such as &lt;code&gt;Collection&amp;lt;out T&amp;gt;&lt;/code&gt; has.</source>
          <target state="translated">&lt;code&gt;Collection&amp;lt;out T&amp;gt;&lt;/code&gt; ように、宣言サイトに差異があるパラメーターに対応する型引数のワイルドカードを生成または省略するようにコンパイラーに指示します。</target>
        </trans-unit>
        <trans-unit id="783a81e7c87c37045741ac6ac177384c0af024d5" translate="yes" xml:space="preserve">
          <source>Instructs compiler to generate wildcard for annotated type arguments corresponding to parameters with declaration-site variance.</source>
          <target state="translated">宣言サイト分散を持つパラメータに対応する注釈付き型引数のワイルドカードを生成するようにコンパイラに指示します。</target>
        </trans-unit>
        <trans-unit id="2008818ef3a5b5313d7106b4d54dde4c0275e9fe" translate="yes" xml:space="preserve">
          <source>Instructs the Kotlin compiler not to generate getters/setters for this property and expose it as a field.</source>
          <target state="translated">Kotlin コンパイラがこのプロパティのゲッター/セッターを生成せず、フィールドとして公開するように指示します。</target>
        </trans-unit>
        <trans-unit id="13386323cf0532c0c864d57e3f5e6f155f3a611f" translate="yes" xml:space="preserve">
          <source>Instructs the Kotlin compiler to generate a multifile class with top-level functions and properties declared in this file as one of its parts. Name of the corresponding multifile class is provided by the &lt;a href=&quot;-jvm-name/index#kotlin.jvm.JvmName&quot;&gt;JvmName&lt;/a&gt; annotation.</source>
          <target state="translated">Kotlinコンパイラーに、最上位の関数とプロパティがこのファイルでその一部の1つとして宣言されているマルチファイルクラスを生成するように指示します。対応するマルチ&lt;a href=&quot;-jvm-name/index#kotlin.jvm.JvmName&quot;&gt;ファイル&lt;/a&gt;クラスの名前は、JvmNameアノテーションによって提供されます。</target>
        </trans-unit>
        <trans-unit id="c90ad955a31d769d0ca4882df53d8563d188c893" translate="yes" xml:space="preserve">
          <source>Instructs the Kotlin compiler to generate a multifile class with top-level functions and properties declared in this file as one of its parts. Name of the corresponding multifile class is provided by the &lt;a href=&quot;../-jvm-name/index#kotlin.jvm.JvmName&quot;&gt;JvmName&lt;/a&gt; annotation.</source>
          <target state="translated">Kotlinコンパイラーに、最上位の関数とプロパティがこのファイルでその一部の1つとして宣言されているマルチファイルクラスを生成するように指示します。対応するマルチ&lt;a href=&quot;../-jvm-name/index#kotlin.jvm.JvmName&quot;&gt;ファイル&lt;/a&gt;クラスの名前は、JvmNameアノテーションによって提供されます。</target>
        </trans-unit>
        <trans-unit id="8b0c8be222fd671f12f20bd767b02c4381772bb8" translate="yes" xml:space="preserve">
          <source>Instructs the Kotlin compiler to generate a multifile class with top-level functions and properties declared in this file as one of its parts. Name of the corresponding multifile class is provided by the &lt;a href=&quot;../../kotlin.jvm/-jvm-name/index#kotlin.jvm.JvmName&quot;&gt;JvmName&lt;/a&gt; annotation.</source>
          <target state="translated">Kotlinコンパイラーに、最上位の関数とプロパティがこのファイルでその一部の1つとして宣言されているマルチファイルクラスを生成するように指示します。対応するマルチ&lt;a href=&quot;../../kotlin.jvm/-jvm-name/index#kotlin.jvm.JvmName&quot;&gt;ファイル&lt;/a&gt;クラスの名前は、JvmNameアノテーションによって提供されます。</target>
        </trans-unit>
        <trans-unit id="7818697c4ce6725112184b56cee9c62bbd312790" translate="yes" xml:space="preserve">
          <source>Instructs the Kotlin compiler to generate a multifile class with top-level functions and properties declared in this file as one of its parts. Name of the corresponding multifile class is provided by the &lt;a href=&quot;../kotlin.jvm/-jvm-name/index#kotlin.jvm.JvmName&quot;&gt;JvmName&lt;/a&gt; annotation.</source>
          <target state="translated">Kotlinコンパイラーに、最上位の関数とプロパティがこのファイルでその一部の1つとして宣言されているマルチファイルクラスを生成するように指示します。対応するマルチ&lt;a href=&quot;../kotlin.jvm/-jvm-name/index#kotlin.jvm.JvmName&quot;&gt;ファイル&lt;/a&gt;クラスの名前は、JvmNameアノテーションによって提供されます。</target>
        </trans-unit>
        <trans-unit id="b493b4c87b9464cb2f6602a1607cbc49417f03a7" translate="yes" xml:space="preserve">
          <source>Instructs the Kotlin compiler to generate overloads for this function that substitute default parameter values.</source>
          <target state="translated">Kotlinコンパイラにこの関数のオーバーロードを生成し、デフォルトのパラメータ値を代用するよう指示します。</target>
        </trans-unit>
        <trans-unit id="b7b71d6677358cf2e0528038c668cb35b0db79e9" translate="yes" xml:space="preserve">
          <source>Instructs the Kotlin compiler to treat annotated Java class as pure implementation of given Kotlin interface. &quot;Pure&quot; means here that each type parameter of class becomes non-platform type argument of that interface.</source>
          <target state="translated">Kotlinコンパイラに、アノテーションされたJavaクラスを、与えられたKotlinインターフェースの純粋な実装として扱うように指示します。&quot;純粋 &quot;とは、クラスの各型パラメータがそのインターフェースの非プラットフォーム型引数になることを意味します。</target>
        </trans-unit>
        <trans-unit id="5c89edcac2811a6a9e8072517cae7f3cbfd5049d" translate="yes" xml:space="preserve">
          <source>Int</source>
          <target state="translated">Int</target>
        </trans-unit>
        <trans-unit id="691e0102b6c4ff1f7d6b4b79971b501f00d71a45" translate="yes" xml:space="preserve">
          <source>Int16Array</source>
          <target state="translated">Int16Array</target>
        </trans-unit>
        <trans-unit id="5c193dd46f10dac764d5258087bf039ad767fbce" translate="yes" xml:space="preserve">
          <source>Int32Array</source>
          <target state="translated">Int32Array</target>
        </trans-unit>
        <trans-unit id="e088a2144c05ba06fd761a7dbefbb84d2fc79069" translate="yes" xml:space="preserve">
          <source>Int8Array</source>
          <target state="translated">Int8Array</target>
        </trans-unit>
        <trans-unit id="4e1eee767ff111b716b2cc9473b02ef4802f7fa3" translate="yes" xml:space="preserve">
          <source>IntArray</source>
          <target state="translated">IntArray</target>
        </trans-unit>
        <trans-unit id="80050b51df21784d163dd20b4b73efde68f88f12" translate="yes" xml:space="preserve">
          <source>IntIterator</source>
          <target state="translated">IntIterator</target>
        </trans-unit>
        <trans-unit id="5808b7bdff6fe2202d34d31f55aa02c48c8f9d57" translate="yes" xml:space="preserve">
          <source>IntProgression</source>
          <target state="translated">IntProgression</target>
        </trans-unit>
        <trans-unit id="1ecd34c101b616e04032d5f18915a529dbf2c1ba" translate="yes" xml:space="preserve">
          <source>IntRange</source>
          <target state="translated">IntRange</target>
        </trans-unit>
        <trans-unit id="122a70b702fe4ea6640b0afbf0db142a8ee86964" translate="yes" xml:space="preserve">
          <source>IntVar</source>
          <target state="translated">IntVar</target>
        </trans-unit>
        <trans-unit id="3d2bffbceb8bff9b98f810d1689ed67697bea8bf" translate="yes" xml:space="preserve">
          <source>IntVarOf</source>
          <target state="translated">IntVarOf</target>
        </trans-unit>
        <trans-unit id="876569ad85ebaf17d9149dea5706aba22e882fe8" translate="yes" xml:space="preserve">
          <source>Integer types</source>
          <target state="translated">整数型</target>
        </trans-unit>
        <trans-unit id="dee1ac1dc651dc2435d67e71a4478aae5437b7bf" translate="yes" xml:space="preserve">
          <source>Integer types in Kotlin have a &lt;em&gt;limited size&lt;/em&gt;, as opposed to the arbitrarily large integers in Python. The limit depends on the type, which decides how many bits the number occupies in memory:</source>
          <target state="translated">Pythonの任意の大きな整数とは対照的に、Kotlinの整数型の&lt;em&gt;サイズ&lt;/em&gt;は&lt;em&gt;制限さ&lt;/em&gt;れています。制限はタイプに依存し、メモリ内でビットが何ビットを占有するかを決定します。</target>
        </trans-unit>
        <trans-unit id="cda60a10cf7788b96a2f3e8c4df843ff16bf37d4" translate="yes" xml:space="preserve">
          <source>Integral type ranges (&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/-int-range/index&quot;&gt;&lt;code&gt;IntRange&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/-long-range/index&quot;&gt;&lt;code&gt;LongRange&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/-char-range/index&quot;&gt;&lt;code&gt;CharRange&lt;/code&gt;&lt;/a&gt;) have an extra feature: they can be iterated over. These ranges are also &lt;a href=&quot;https://en.wikipedia.org/wiki/Arithmetic_progression&quot;&gt;progressions&lt;/a&gt; of the corresponding integral types. Such ranges are generally used for iteration in the &lt;code&gt;for&lt;/code&gt; loops.</source>
          <target state="translated">整数型の範囲（&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/-int-range/index&quot;&gt; &lt;code&gt;IntRange&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/-long-range/index&quot;&gt; &lt;code&gt;LongRange&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/-char-range/index&quot;&gt; &lt;code&gt;CharRange&lt;/code&gt; &lt;/a&gt;）には、追加の機能があり、反復することができます。これらの範囲は、対応する整数型の&lt;a href=&quot;https://en.wikipedia.org/wiki/Arithmetic_progression&quot;&gt;累進&lt;/a&gt;でもあります。このような範囲は、一般的に &lt;code&gt;for&lt;/code&gt; ループの反復に使用されます。</target>
        </trans-unit>
        <trans-unit id="13f8bf35d86cdecdc30977f1b4bf82da0dde4e54" translate="yes" xml:space="preserve">
          <source>IntelliJ IDEA can also automatically generate the &lt;code&gt;@Suppress&lt;/code&gt; annotation. Open the intentions menu via the light bulb icon or Alt-Enter, and click the small arrow next to the &quot;Change type arguments&quot; quick-fix. Here, you can select the suppression scope, and your IDE will add the annotation to your file accordingly.</source>
          <target state="translated">IntelliJ IDEAは、 &lt;code&gt;@Suppress&lt;/code&gt; アノテーションを自動的に生成することもできます。電球アイコンまたはAlt-Enterを使用して意図メニューを開き、[タイプ引数の変更]クイックフィックスの横にある小さな矢印をクリックします。ここで、抑制スコープを選択できます。IDEはそれに応じてファイルに注釈を追加します。</target>
        </trans-unit>
        <trans-unit id="2bee37b0cdd0528c3a6b459962cdaf6bec045292" translate="yes" xml:space="preserve">
          <source>IntelliJ IDEA can also automatically generate the &lt;code&gt;@Suppress&lt;/code&gt; annotation. Open the intentions menu via the light bulb icon or Alt-Enter, and click the small arrow next to the &quot;Unchecked cast to external interface&quot; inspection. Here, you can select the suppression scope, and your IDE will add the annotation to your file accordingly.</source>
          <target state="translated">IntelliJ IDEAは、 &lt;code&gt;@Suppress&lt;/code&gt; アノテーションを自動的に生成することもできます。電球アイコンまたはAlt-Enterを使用して意図メニューを開き、[外部インターフェイスへのチェックされていないキャスト]検査の横にある小さな矢印をクリックします。ここで、抑制スコープを選択できます。IDEはそれに応じてファイルに注釈を追加します。</target>
        </trans-unit>
        <trans-unit id="10bb7deeea7ab770c8cc611de5a7e9bd46c52593" translate="yes" xml:space="preserve">
          <source>IntelliJ IDEA can run the code from scratches and worksheets automatically. To get the execution results when you stop typing, switch on the &lt;strong&gt;Interactive mode&lt;/strong&gt;.</source>
          <target state="translated">IntelliJ IDEAは、コードを最初から実行し、ワークシートを自動的に実行できます。入力を停止したときに実行結果を取得するには、&lt;strong&gt;インタラクティブモードを&lt;/strong&gt;オンにし&lt;strong&gt;ます&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="8489966f59e24770658292f5a494ac85bfb4f6e0" translate="yes" xml:space="preserve">
          <source>IntelliJ IDEA can run your scratches automatically. To get the execution results once you stop typing for a short time, switch on the &lt;strong&gt;Interactive mode&lt;/strong&gt;.</source>
          <target state="translated">IntelliJ IDEAはスクラッチを自動的に実行できます。しばらく入力をやめたときに実行結果を取得するには、&lt;strong&gt;インタラクティブモードを&lt;/strong&gt;オンにし&lt;strong&gt;ます&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="11066aac7596078ae46263d8a457c412baa42d01" translate="yes" xml:space="preserve">
          <source>IntelliJ IDEA will add the corresponding entries for us in the &lt;a href=&quot;#maven-configuration&quot;&gt;Maven configuration&lt;/a&gt;.</source>
          <target state="translated">IntelliJ IDEAは、対応するエントリを&lt;a href=&quot;#maven-configuration&quot;&gt;Maven構成に&lt;/a&gt;追加します。</target>
        </trans-unit>
        <trans-unit id="eff2bf29e6c4ca5eac858ebfb9f2e0be07577de6" translate="yes" xml:space="preserve">
          <source>IntelliJ IDEA's kotlin plugin understands the semantics of &lt;code&gt;TODO()&lt;/code&gt; and automatically adds a code pointer in the TODO toolwindow.</source>
          <target state="translated">IntelliJ IDEAのkotlinプラグインは、 &lt;code&gt;TODO()&lt;/code&gt; のセマンティクスを理解し、TODOツールウィンドウにコードポインターを自動的に追加します。</target>
        </trans-unit>
        <trans-unit id="54d05b8bf6f20e0d324256cf774765900389821b" translate="yes" xml:space="preserve">
          <source>Interact with the DOM</source>
          <target state="translated">DOM との相互作用</target>
        </trans-unit>
        <trans-unit id="2c419294377dd8ca37e7cb76b4dea91ed19ea8dc" translate="yes" xml:space="preserve">
          <source>Interacting with the DOM</source>
          <target state="translated">DOM との相互作用</target>
        </trans-unit>
        <trans-unit id="0d798c0b1cd4a6d135dc1e4671cde5f33dab863b" translate="yes" xml:space="preserve">
          <source>Interactive mode</source>
          <target state="translated">インタラクティブモード</target>
        </trans-unit>
        <trans-unit id="b02084f4df61f4f1999048df4a4f737cbeb8d5d5" translate="yes" xml:space="preserve">
          <source>Intercept continuation with &lt;a href=&quot;../-continuation-interceptor/index&quot;&gt;ContinuationInterceptor&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../-continuation-interceptor/index&quot;&gt;ContinuationInterceptorを使用して&lt;/a&gt;継続をインターセプトします。</target>
        </trans-unit>
        <trans-unit id="653ee20081a2ed0c0dfdeafb8d4cc56b1706495b" translate="yes" xml:space="preserve">
          <source>Intercept continuation with &lt;a href=&quot;../kotlin.coroutines.experimental/-continuation-interceptor/index&quot;&gt;ContinuationInterceptor&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../kotlin.coroutines.experimental/-continuation-interceptor/index&quot;&gt;ContinuationInterceptorを使用して&lt;/a&gt;継続をインターセプトします。</target>
        </trans-unit>
        <trans-unit id="ef76b9eb4630422886c9e0fac2f1db0f2f6f1af1" translate="yes" xml:space="preserve">
          <source>Interception of delegated property binding</source>
          <target state="translated">委譲されたプロパティのバインディングの傍受</target>
        </trans-unit>
        <trans-unit id="fc7a4e9264f9fe99aec05e3498611be00e954e41" translate="yes" xml:space="preserve">
          <source>Intercepts this continuation with &lt;a href=&quot;../kotlin.coroutines/-continuation-interceptor/index&quot;&gt;ContinuationInterceptor&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../kotlin.coroutines/-continuation-interceptor/index&quot;&gt;ContinuationInterceptorで&lt;/a&gt;この継続をインターセプトします。</target>
        </trans-unit>
        <trans-unit id="16bd3eae0558639cfe5dccb9e5a929f401a38bef" translate="yes" xml:space="preserve">
          <source>Interface implementation layout</source>
          <target state="translated">インターフェースの実装レイアウト</target>
        </trans-unit>
        <trans-unit id="b4d21bf63ded1f81b33de5ff71ef6ec0031cdd1f" translate="yes" xml:space="preserve">
          <source>Interface representing a continuation after a suspension point that returns a value of type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">タイプ &lt;code&gt;T&lt;/code&gt; の値を返す中断ポイントの後の継続を表すインターフェース。</target>
        </trans-unit>
        <trans-unit id="3d559a197ac3fd74c061414f5d71be30830c373e" translate="yes" xml:space="preserve">
          <source>Interface representing a continuation after a suspension point that returns value of type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">タイプ &lt;code&gt;T&lt;/code&gt; の値を返す中断点の後の継続を表すインターフェース。</target>
        </trans-unit>
        <trans-unit id="b356313f979923fc829adb909098ed26a5a01aff" translate="yes" xml:space="preserve">
          <source>Interfaces</source>
          <target state="translated">Interfaces</target>
        </trans-unit>
        <trans-unit id="3fb0788052e6b21a9e30969754a6a4b19102a8cb" translate="yes" xml:space="preserve">
          <source>Interfaces &lt;em&gt;A&lt;/em&gt; and &lt;em&gt;B&lt;/em&gt; both declare functions &lt;em&gt;foo()&lt;/em&gt; and &lt;em&gt;bar()&lt;/em&gt;. Both of them implement &lt;em&gt;foo()&lt;/em&gt;, but only &lt;em&gt;B&lt;/em&gt; implements &lt;em&gt;bar()&lt;/em&gt; (&lt;em&gt;bar()&lt;/em&gt; is not marked abstract in &lt;em&gt;A&lt;/em&gt;, because this is the default for interfaces, if the function has no body). Now, if we derive a concrete class &lt;em&gt;C&lt;/em&gt; from &lt;em&gt;A&lt;/em&gt;, we, obviously, have to override &lt;em&gt;bar()&lt;/em&gt; and provide an implementation.</source>
          <target state="translated">インターフェース&lt;em&gt;A&lt;/em&gt;と&lt;em&gt;Bは&lt;/em&gt;どちらも関数&lt;em&gt;foo（）&lt;/em&gt;と&lt;em&gt;bar（）を&lt;/em&gt;宣言しています。それらの両方が実装&lt;em&gt;FOOを（）&lt;/em&gt;が、唯一の&lt;em&gt;B&lt;/em&gt;実装の&lt;em&gt;バー（） &lt;/em&gt;（&lt;em&gt;バーは（）&lt;/em&gt;で抽象的にマークされていない&lt;em&gt;A&lt;/em&gt;機能に本体がない場合、これは、インターフェイスのデフォルトであるため、）。ここで、&lt;em&gt;A&lt;/em&gt;から具象クラス&lt;em&gt;C&lt;/em&gt;を派生させる場合、明らかに、&lt;em&gt;bar（）&lt;/em&gt;をオーバーライドして実装を提供する必要があります。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="99ffdc8085488e57490fe414d8c6f2ac4c1599ac" translate="yes" xml:space="preserve">
          <source>Interfaces Inheritance</source>
          <target state="translated">インターフェース継承</target>
        </trans-unit>
        <trans-unit id="8b075e134839d5d81cca3ebe6834964746dbfa9f" translate="yes" xml:space="preserve">
          <source>Interfaces in Kotlin are very similar to Java 8. They can contain declarations of abstract methods, as well as method implementations. What makes them different from abstract classes is that interfaces cannot store state. They can have properties but these need to be abstract or to provide accessor implementations.</source>
          <target state="translated">KotlinのインターフェイスはJava 8と非常に似ています。インターフェースには、メソッドの実装だけでなく、抽象メソッドの宣言を含めることができます。抽象クラスと異なる点は、インターフェイスは状態を保存できないということです。プロパティを持つことはできますが、それらは抽象化されているか、アクセサの実装を提供する必要があります。</target>
        </trans-unit>
        <trans-unit id="3dc6f1c623405f44dfc6225166b717008c4b39d3" translate="yes" xml:space="preserve">
          <source>Interfaces in Kotlin can contain declarations of abstract methods, as well as method implementations. What makes them different from abstract classes is that interfaces cannot store state. They can have properties but these need to be abstract or to provide accessor implementations.</source>
          <target state="translated">Kotlin のインターフェイスは、メソッドの実装だけでなく、抽象メソッドの宣言を含むことができます。抽象クラスと異なる点は、インターフェイスは状態を保存できないということです。インターフェースはプロパティを持つことができますが、それらは抽象クラスであるか、アクセサの実装を提供する必要があります。</target>
        </trans-unit>
        <trans-unit id="f3a19a0ac9dc5495efba84238a1c889b8a1af7e4" translate="yes" xml:space="preserve">
          <source>Interop with Java</source>
          <target state="translated">JavaとのInterop</target>
        </trans-unit>
        <trans-unit id="c644acaf1f3c1a0ed7a1256f251846c1b5938545" translate="yes" xml:space="preserve">
          <source>InteropStubs</source>
          <target state="translated">InteropStubs</target>
        </trans-unit>
        <trans-unit id="e8ee8f70e7d8b9c0f444242c7791f8de975f2a89" translate="yes" xml:space="preserve">
          <source>Interoperability</source>
          <target state="translated">Interoperability</target>
        </trans-unit>
        <trans-unit id="68de227c33695f7eee1af76e54576c5f473dbabb" translate="yes" xml:space="preserve">
          <source>Interoperability With Java Reflection</source>
          <target state="translated">Java Reflectionとの相互運用性</target>
        </trans-unit>
        <trans-unit id="2a2e730dccd30c2b052062769d22631b368b3446" translate="yes" xml:space="preserve">
          <source>Interoperability with Java reflection</source>
          <target state="translated">Java リフレクションとの相互運用性</target>
        </trans-unit>
        <trans-unit id="768631baf54d445fa8bf1b363fe5b7347532e0f6" translate="yes" xml:space="preserve">
          <source>Interoperability with Swift/Objective-C is provided too and covered in a separate document &lt;a href=&quot;objc_interop&quot;&gt;OBJC_INTEROP.md&lt;/a&gt;.</source>
          <target state="translated">Swift / Objective-Cとの相互運用性も提供されており、別のドキュメント&lt;a href=&quot;objc_interop&quot;&gt;OBJC_INTEROP.mdで&lt;/a&gt;カバーされています。</target>
        </trans-unit>
        <trans-unit id="cf0f2c7977d4a0d28911368671a5b929d3d0eeba" translate="yes" xml:space="preserve">
          <source>Introducing an expression as a variable in local scope: &lt;code&gt;let&lt;/code&gt;</source>
          <target state="translated">式をローカルスコープの変数として導入： &lt;code&gt;let&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="32255fd1a8ee65ebb05876eff1fd292d27126703" translate="yes" xml:space="preserve">
          <source>Introduction to Kotlin (in Russian)</source>
          <target state="translated">コトリン入門(ロシア語</target>
        </trans-unit>
        <trans-unit id="8907e06f66221d3c7deda7eaa03a2cc4d7313211" translate="yes" xml:space="preserve">
          <source>Introduction to Kotlin Programming</source>
          <target state="translated">Kotlinプログラミング入門</target>
        </trans-unit>
        <trans-unit id="1a733ca17cc418ac2040451ede20832965697fc4" translate="yes" xml:space="preserve">
          <source>InvalidMutabilityException</source>
          <target state="translated">InvalidMutabilityException</target>
        </trans-unit>
        <trans-unit id="ed8bc42e69c9abe4619cbcab39f65339c9a9ce60" translate="yes" xml:space="preserve">
          <source>Inverts the bits in this value.</source>
          <target state="translated">この値のビットを反転させます。</target>
        </trans-unit>
        <trans-unit id="555df15449eba01e6d316f12f10d25ead6974375" translate="yes" xml:space="preserve">
          <source>Inverts the bits including the sign bit in this value.</source>
          <target state="translated">この値の符号ビットを含むビットを反転させます。</target>
        </trans-unit>
        <trans-unit id="1808969803eb296cd6d4f6a8c06b19cec81c8416" translate="yes" xml:space="preserve">
          <source>Invocation of &lt;a href=&quot;../kotlin.coroutines/-continuation/resume-with&quot;&gt;Continuation.resumeWith&lt;/a&gt; resumes coroutine directly in the invoker's thread without going through the &lt;a href=&quot;../kotlin.coroutines/-continuation-interceptor/index&quot;&gt;ContinuationInterceptor&lt;/a&gt; that might be present in the coroutine's &lt;a href=&quot;../kotlin.coroutines/-coroutine-context/index&quot;&gt;CoroutineContext&lt;/a&gt;. It is the invoker's responsibility to ensure that a proper invocation context is established. &lt;a href=&quot;intercepted#kotlin.coroutines.intrinsics%24intercepted%28kotlin.coroutines.Continuation%28%28kotlin.coroutines.intrinsics.intercepted.T%29%29%29&quot;&gt;Continuation.intercepted&lt;/a&gt; can be used to acquire the intercepted continuation.</source>
          <target state="translated">呼び出し&lt;a href=&quot;../kotlin.coroutines/-continuation/resume-with&quot;&gt;Continuation.resumeWithは&lt;/a&gt;経由せずに呼び出し元のスレッドに直接コルーチンを再開&lt;a href=&quot;../kotlin.coroutines/-continuation-interceptor/index&quot;&gt;ContinuationInterceptor&lt;/a&gt;コルーチンの中に存在するかもしれない&lt;a href=&quot;../kotlin.coroutines/-coroutine-context/index&quot;&gt;CoroutineContext&lt;/a&gt;。適切な呼び出しコンテキストが確立されるようにするのは、呼び出し側の責任です。&lt;a href=&quot;intercepted#kotlin.coroutines.intrinsics%24intercepted%28kotlin.coroutines.Continuation%28%28kotlin.coroutines.intrinsics.intercepted.T%29%29%29&quot;&gt;Continuation.intercepted&lt;/a&gt;を使用して、インターセプトされた継続を取得できます。</target>
        </trans-unit>
        <trans-unit id="12923fefc07e48286763b781976e0602cda671d5" translate="yes" xml:space="preserve">
          <source>Invocation of &lt;a href=&quot;../kotlin.coroutines/-continuation/resume-with&quot;&gt;Continuation.resumeWith&lt;/a&gt; resumes coroutine directly in the invoker's thread without going through the &lt;a href=&quot;../kotlin.coroutines/-continuation-interceptor/index&quot;&gt;ContinuationInterceptor&lt;/a&gt; that might be present in the coroutine's &lt;a href=&quot;../kotlin.coroutines/-coroutine-context/index&quot;&gt;CoroutineContext&lt;/a&gt;. It is the invoker's responsibility to ensure that a proper invocation context is established. &lt;a href=&quot;intercepted#kotlin.coroutines.intrinsics%24intercepted(kotlin.coroutines.Continuation((kotlin.coroutines.intrinsics.intercepted.T)))&quot;&gt;Continuation.intercepted&lt;/a&gt; can be used to acquire the intercepted continuation.</source>
          <target state="translated">呼び出し&lt;a href=&quot;../kotlin.coroutines/-continuation/resume-with&quot;&gt;Continuation.resumeWithは&lt;/a&gt;経由せずに呼び出し元のスレッドに直接コルーチンを再開&lt;a href=&quot;../kotlin.coroutines/-continuation-interceptor/index&quot;&gt;ContinuationInterceptor&lt;/a&gt;コルーチンの中に存在するかもしれない&lt;a href=&quot;../kotlin.coroutines/-coroutine-context/index&quot;&gt;CoroutineContext&lt;/a&gt;。適切な呼び出しコンテキストが確立されていることを確認するのは、呼び出し側の責任です。&lt;a href=&quot;intercepted#kotlin.coroutines.intrinsics%24intercepted(kotlin.coroutines.Continuation((kotlin.coroutines.intrinsics.intercepted.T)))&quot;&gt;Continuation.intercepted&lt;/a&gt;は、インターセプトされた継続を取得するために使用できます。</target>
        </trans-unit>
        <trans-unit id="a142e8aa439986e2d57c987fdc039b4c2ce8b67d" translate="yes" xml:space="preserve">
          <source>InvocationKind</source>
          <target state="translated">InvocationKind</target>
        </trans-unit>
        <trans-unit id="32a85866515d2c40342d72243d3af2e2ade61880" translate="yes" xml:space="preserve">
          <source>Invoke operator</source>
          <target state="translated">呼び出し演算子</target>
        </trans-unit>
        <trans-unit id="90d36cdc449e51ffdeb986b93d9cc3791424dd45" translate="yes" xml:space="preserve">
          <source>Invoked for the continuation instance returned by &lt;a href=&quot;intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt; when the original continuation completes and will not be used anymore. This function is invoked only if &lt;a href=&quot;intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt; had returned a different continuation instance from the one it was invoked with.</source>
          <target state="translated">元の継続が完了し、使用されなくなったときに、&lt;a href=&quot;intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt;によって返された継続インスタンスに対して呼び出されます。この関数は、&lt;a href=&quot;intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt;が呼び出されたインスタンスとは異なる継続インスタンスを返した場合にのみ呼び出されます。</target>
        </trans-unit>
        <trans-unit id="e7b262710ce446d5dceec2a721a656e3054eebf5" translate="yes" xml:space="preserve">
          <source>Invoking &lt;code&gt;call()&lt;/code&gt; on a function object will call the function. If it is a member function, the first parameter must be the &lt;em&gt;receiver&lt;/em&gt; (the object on which the function is to be invoked, in this case &lt;code&gt;person&lt;/code&gt;), and the remaining parameters must be the ordinary function parameters (in this case &lt;code&gt;&quot;Anne&quot;&lt;/code&gt;).</source>
          <target state="translated">関数オブジェクトで &lt;code&gt;call()&lt;/code&gt; を呼び出すと、関数が呼び出されます。メンバー関数の場合、最初のパラメーターは&lt;em&gt;レシーバー&lt;/em&gt;（関数が呼び出されるオブジェクト、この場合は &lt;code&gt;person&lt;/code&gt; ）でなければならず、残りのパラメーターは通常の関数パラメーター（この場合は &lt;code&gt;&quot;Anne&quot;&lt;/code&gt; ）でなければなりません。。</target>
        </trans-unit>
        <trans-unit id="e517c0efd966757777074a55cf84552ef188ca9a" translate="yes" xml:space="preserve">
          <source>Invoking &lt;code&gt;findViewById()&lt;/code&gt; can be slow, especially in case of huge view hierarchies, so Android Extensions tries to minimize &lt;code&gt;findViewById()&lt;/code&gt; calls by caching views in containers.</source>
          <target state="translated">呼び出す &lt;code&gt;findViewById()&lt;/code&gt; Androidの拡張機能は最小限にしようとするので、特に巨大なビュー階層の場合には、遅くなることがあります &lt;code&gt;findViewById()&lt;/code&gt; は、コンテナ内のビューをキャッシュすることによって呼び出されます。</target>
        </trans-unit>
        <trans-unit id="55b7cc54c31bd895727aeb7e2e5dfcfeaf500f67" translate="yes" xml:space="preserve">
          <source>Invoking a function type instance</source>
          <target state="translated">関数型インスタンスの呼び出し</target>
        </trans-unit>
        <trans-unit id="609d1188a5fb6f3c57a44ee5ee27b2fb07938bf1" translate="yes" xml:space="preserve">
          <source>Invoking functions on other collections</source>
          <target state="translated">他のコレクションで関数を呼び出す</target>
        </trans-unit>
        <trans-unit id="39f649540ce7c567f8fc21179741df12bdec413a" translate="yes" xml:space="preserve">
          <source>Is Kotlin an object-oriented language or a functional one?</source>
          <target state="translated">Kotlin はオブジェクト指向言語なのか、それとも関数型言語なのか?</target>
        </trans-unit>
        <trans-unit id="0396150c49da7aa331143384cade7b9761b9c77b" translate="yes" xml:space="preserve">
          <source>Is Kotlin compatible with the Java programming language?</source>
          <target state="translated">KotlinはJavaプログラミング言語と互換性がありますか?</target>
        </trans-unit>
        <trans-unit id="d651f0b2ee6f868c27d5b6dae520cfb850abc9e7" translate="yes" xml:space="preserve">
          <source>Is Kotlin free?</source>
          <target state="translated">コトリンは無料ですか?</target>
        </trans-unit>
        <trans-unit id="4096c8e1086b327150a7292e4d2afe3394a12f6e" translate="yes" xml:space="preserve">
          <source>Is Kotlin hard?</source>
          <target state="translated">コトリンは硬い?</target>
        </trans-unit>
        <trans-unit id="9edc452dd78ce29f04fd4cdc3ccb57260c61debd" translate="yes" xml:space="preserve">
          <source>Is Kotlin on Social Media?</source>
          <target state="translated">コトリンはソーシャルメディアを使っていますか?</target>
        </trans-unit>
        <trans-unit id="4e2b800e686ee55bbeca8de0e7c4e9007eb7822f" translate="yes" xml:space="preserve">
          <source>Is Kotlin on social media?</source>
          <target state="translated">コトリンはソーシャルメディアを使っているのか?</target>
        </trans-unit>
        <trans-unit id="06373ad2bc61a9e4042f42be3c932a4374d09d55" translate="yes" xml:space="preserve">
          <source>Is extension function</source>
          <target state="translated">拡張機能はありますか?</target>
        </trans-unit>
        <trans-unit id="84f7edacad77f3efea0c1f9a95023335afe8e98e" translate="yes" xml:space="preserve">
          <source>Is there a Kotlin conference?</source>
          <target state="translated">Kotlinの会議はありますか?</target>
        </trans-unit>
        <trans-unit id="23fb12980d63818dd24d249914c5dbde1e4eab5d" translate="yes" xml:space="preserve">
          <source>Isn't it what we wanted from the very beginning?</source>
          <target state="translated">最初から望んでいたことではないでしょうか?</target>
        </trans-unit>
        <trans-unit id="651e4641fbeb110db3b7fdfb2bb5a04a7dfe7d1b" translate="yes" xml:space="preserve">
          <source>Isolating declarations in a separate JavaScript object</source>
          <target state="translated">別の JavaScript オブジェクトで宣言を分離する</target>
        </trans-unit>
        <trans-unit id="d439914b4bf445ecb5fcbbcfd0b7501a29e97254" translate="yes" xml:space="preserve">
          <source>Isolating declarations in a separate JavaScript object in &lt;code&gt;plain&lt;/code&gt; mode</source>
          <target state="translated">&lt;code&gt;plain&lt;/code&gt; モードで別のJavaScriptオブジェクトの宣言を分離する</target>
        </trans-unit>
        <trans-unit id="ec40e8e2417f63763bc4005b1f45f89c4b9bd620" translate="yes" xml:space="preserve">
          <source>It also works with meta-annotations:</source>
          <target state="translated">メタアノテーションとの連携も可能です。</target>
        </trans-unit>
        <trans-unit id="6f49ae3f8f0dbf679bfc3c5ff95bf21f8e30ee20" translate="yes" xml:space="preserve">
          <source>It can be demonstrated by a simple example that creates coroutines in the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope&lt;/a&gt;:</source>
          <target state="translated">これは、&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScopeに&lt;/a&gt;コルーチンを作成する簡単な例で説明できます。</target>
        </trans-unit>
        <trans-unit id="fafe915e21eb48d949ca0df5819ea5714df59866" translate="yes" xml:space="preserve">
          <source>It can be demonstrated by a simple example that creates root coroutines using the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope&lt;/a&gt;:</source>
          <target state="translated">これは、&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope&lt;/a&gt;を使用してルートコルーチンを作成する簡単な例で示すことができます。</target>
        </trans-unit>
        <trans-unit id="b2cb6066b03e8d078e05b9934f5a0885eb7115c7" translate="yes" xml:space="preserve">
          <source>It can be demonstrated by the following example:</source>
          <target state="translated">それは、以下の例で実証することができます。</target>
        </trans-unit>
        <trans-unit id="c7f79c6fa89f2be4d0900a1df15f6e4c9cd6d6d8" translate="yes" xml:space="preserve">
          <source>It can of course be done as a single expression: &lt;code&gt;val x = javaFunctionThatYouKnowReturnsNonNull()!!&lt;/code&gt;.</source>
          <target state="translated">もちろん、単一の式として行うこともできます： &lt;code&gt;val x = javaFunctionThatYouKnowReturnsNonNull()!!&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b4869b700b07f0d7aa2566a42cedd6c00ff40027" translate="yes" xml:space="preserve">
          <source>It demonstrates several new techniques. One is using &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt; with an explicitly specified context, and the other one is using &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-context.html&quot;&gt;withContext&lt;/a&gt; function to change a context of a coroutine while still staying in the same coroutine as you can see in the output below:</source>
          <target state="translated">これは、いくつかの新しいテクニックを示しています。1つは明示的に指定されたコンテキストで&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt;を使用しており、もう1つは&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-context.html&quot;&gt;withContext&lt;/a&gt;関数を使用してコルーチンのコンテキストを変更しながら、以下の出力で確認できるように同じコルーチンにとどまっています。</target>
        </trans-unit>
        <trans-unit id="407d919d76eb160a2f5dfd9e474e1e25b6f6932e" translate="yes" xml:space="preserve">
          <source>It demonstrates several new techniques. One is using &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt; with an explicitly specified context, and the other one is using the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-context.html&quot;&gt;withContext&lt;/a&gt; function to change the context of a coroutine while still staying in the same coroutine, as you can see in the output below:</source>
          <target state="translated">それはいくつかの新しい技術を示しています。次の出力に示すように、1つは明示的に指定されたコンテキストで&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt;を使用し、もう1つは&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-context.html&quot;&gt;withContext&lt;/a&gt;関数を使用して、同じコルーチンにとどまりながらコルーチンのコンテキストを変更します。</target>
        </trans-unit>
        <trans-unit id="df6b25cff4a7799af9dc4369b6ce738113d68ee2" translate="yes" xml:space="preserve">
          <source>It does not matter (for correctness) what context the actor itself is executed in. An actor is a coroutine and a coroutine is executed sequentially, so confinement of the state to the specific coroutine works as a solution to the problem of shared mutable state. Indeed, actors may modify their own private state, but can only affect each other through messages (avoiding the need for any locks).</source>
          <target state="translated">アクタ自体がどのようなコンテキストで実行されるかは(正確性のために)問題ではありません。アクタはコルーチンであり、コルーチンは順次実行されるので、特定のコルーチンに状態を限定することは、共有された変異可能な状態の問題の解決策として機能します。実際、アクタは自分自身のプライベートな状態を変更することができますが、メッセージを通してしかお互いに影響を与えることができません(ロックの必要性を回避します)。</target>
        </trans-unit>
        <trans-unit id="838f4ba272421d5995e2a80726c6cbb738d51748" translate="yes" xml:space="preserve">
          <source>It expects the targets to provide platform-specific implementations for &lt;code&gt;writeLogMessage&lt;/code&gt;, and the common code can now use this declaration without any consideration of how it is implemented.</source>
          <target state="translated">ターゲットが &lt;code&gt;writeLogMessage&lt;/code&gt; のプラットフォーム固有の実装を提供することを期待しており、一般的なコードは、実装方法を考慮せずにこの宣言を使用できるようになりました。</target>
        </trans-unit>
        <trans-unit id="acca4b75fdfdc287f94d60288ba8cbf8ea940d89" translate="yes" xml:space="preserve">
          <source>It is also convenient to use when you have a callable reference instead of the lambda:</source>
          <target state="translated">ラムダの代わりに呼び出し可能な参照がある場合にも便利です。</target>
        </trans-unit>
        <trans-unit id="db36d25fe18e1fa8b4a072e0b9e5e699d53ac00e" translate="yes" xml:space="preserve">
          <source>It is also possible to configure all Kotlin compilation tasks in the project:</source>
          <target state="translated">また、プロジェクト内のすべてのKotlinコンパイルタスクを設定することも可能です。</target>
        </trans-unit>
        <trans-unit id="4e799686fc388ae642c64e9044143db835d23770" translate="yes" xml:space="preserve">
          <source>It is also possible to debug Kotlin applications using the standard Chrome debugger. Just make sure that you do generate source maps.</source>
          <target state="translated">標準のChromeデバッガーを使ってKotlinアプリケーションをデバッグすることも可能です。ただ、ソースマップを生成するようにしてください。</target>
        </trans-unit>
        <trans-unit id="2d484974349c030ade989fbea0475cbaae9e9d98" translate="yes" xml:space="preserve">
          <source>It is also possible to iterate over numbers with an arbitrary step (not necessarily 1). This is done via the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/step&quot;&gt;&lt;code&gt;step&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">任意のステップ（必ずしも1である必要はない）で数値を反復することも可能です。これは、&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/step&quot;&gt; &lt;code&gt;step&lt;/code&gt; &lt;/a&gt;関数を介して行われます。</target>
        </trans-unit>
        <trans-unit id="dc446105af35ae94e82863937d04520fa631bab7" translate="yes" xml:space="preserve">
          <source>It is convenient to import all widget properties for a specific layout in one go:</source>
          <target state="translated">特定のレイアウトのウィジェットプロパティを一括でインポートできるのが便利です。</target>
        </trans-unit>
        <trans-unit id="ea87fa24d13265d437721a500dc610021a2b6ae7" translate="yes" xml:space="preserve">
          <source>It is created by attaching &lt;code&gt;keySelector: (T) -&amp;gt; K&lt;/code&gt; function to a source of elements. To get an instance of &lt;a href=&quot;index&quot;&gt;Grouping&lt;/a&gt; use one of &lt;code&gt;groupingBy&lt;/code&gt; extension functions:</source>
          <target state="translated">&lt;code&gt;keySelector: (T) -&amp;gt; K&lt;/code&gt; 関数を要素のソースにアタッチすることで作成されます。&lt;a href=&quot;index&quot;&gt;Groupingの&lt;/a&gt;インスタンスを取得するには、 &lt;code&gt;groupingBy&lt;/code&gt; 拡張関数のいずれかを使用します。</target>
        </trans-unit>
        <trans-unit id="9817b3326fc94d2d632dd03bcb277b7bc5e546ba" translate="yes" xml:space="preserve">
          <source>It is easy to demonstrate it in action:</source>
          <target state="translated">それを行動で示すのは簡単です。</target>
        </trans-unit>
        <trans-unit id="5057879a755e254fb21862c60fef7113f875d675" translate="yes" xml:space="preserve">
          <source>It is easy to include a compiled Kotlin code into existing projects written in C, C++, Swift, Objective-C, and other languages. It is also easy to use existing native code, static or dynamic &lt;a href=&quot;native/c_interop&quot;&gt;C libraries&lt;/a&gt;, Swift/Objective-C &lt;a href=&quot;native/objc_interop&quot;&gt;frameworks&lt;/a&gt;, graphical engines, and anything else directly from Kotlin/Native.</source>
          <target state="translated">コンパイル済みのKotlinコードを、C、C ++、Swift、Objective-C、およびその他の言語で記述された既存のプロジェクトに簡単に組み込むことができます。また、既存のネイティブコード、静的または動的&lt;a href=&quot;native/c_interop&quot;&gt;Cライブラリ&lt;/a&gt;、Swift / Objective-C &lt;a href=&quot;native/objc_interop&quot;&gt;フレームワーク&lt;/a&gt;、グラフィカルエンジンなど、Kotlin / Nativeから直接使用することも簡単です。</target>
        </trans-unit>
        <trans-unit id="5f37ac7cf663ce39ab7cecdf53e288f77e8f878b" translate="yes" xml:space="preserve">
          <source>It is easy to use the generated wrapper classes for C &lt;code&gt;struct&lt;/code&gt; and &lt;code&gt;union&lt;/code&gt; types from Kotlin. Thanks to the generated properties, it feels natural to use them in Kotlin code. The only question, so far, is how do we create a new instance on those classes. As we see from the declarations of &lt;code&gt;MyStruct&lt;/code&gt; and &lt;code&gt;MyUnion&lt;/code&gt;, their constructors require a &lt;code&gt;NativePtr&lt;/code&gt;. Of course, we are not willing to deal with pointers manually. Instead, we can use Kotlin API to have those objects instantiated for us.</source>
          <target state="translated">KotlinからC &lt;code&gt;struct&lt;/code&gt; および &lt;code&gt;union&lt;/code&gt; 体型用に生成されたラッパークラスを使用するのは簡単です。生成されたプロパティのおかげで、Kotlinコードでそれらを使用するのは自然なことです。これまでの唯一の問題は、これらのクラスに新しいインスタンスを作成する方法です。 &lt;code&gt;MyStruct&lt;/code&gt; と &lt;code&gt;MyUnion&lt;/code&gt; の宣言からわかるように、それらのコンストラクターには &lt;code&gt;NativePtr&lt;/code&gt; が必要です。もちろん、ポインターを手動で処理することはできません。代わりに、Kotlin APIを使用して、これらのオブジェクトをインスタンス化することができます。</target>
        </trans-unit>
        <trans-unit id="13a7c2154690aa37b95c233923686a0683d02a9e" translate="yes" xml:space="preserve">
          <source>It is equivalent to this Java code:</source>
          <target state="translated">このJavaコードに相当します。</target>
        </trans-unit>
        <trans-unit id="fd011ac428fa7a3101febe89637cd71887a4e771" translate="yes" xml:space="preserve">
          <source>It is forbidden for inline classes to participate in a class hierarchy. This means that inline classes cannot extend other classes and must be &lt;em&gt;final&lt;/em&gt;.</source>
          <target state="translated">インラインクラスがクラス階層に参加することは禁止されています。つまり、インラインクラスは他のクラスを拡張できず、&lt;em&gt;最終&lt;/em&gt;クラスでなければなりません。</target>
        </trans-unit>
        <trans-unit id="baf0c1eedc3c7d76ed7d17e6f83833365d1074e5" translate="yes" xml:space="preserve">
          <source>It is important to note that some of the &lt;a href=&quot;#supported-platforms&quot;&gt;Kotlin/Native targets&lt;/a&gt; may only be built with an appropriate host machine:</source>
          <target state="translated">&lt;a href=&quot;#supported-platforms&quot;&gt;Kotlin /ネイティブターゲットの&lt;/a&gt;一部は、適切なホストマシンでのみビルドできることに注意することが重要です。</target>
        </trans-unit>
        <trans-unit id="417f8643742c5b4b13e710785eaf864b3ada4be9" translate="yes" xml:space="preserve">
          <source>It is important to understand that just like in the case of &lt;code&gt;callAnything()&lt;/code&gt;, the &lt;code&gt;dataTable()&lt;/code&gt; function must exist at runtime. In our case, we need to make sure that the corresponding script file for our plugin is included:</source>
          <target state="translated">&lt;code&gt;callAnything()&lt;/code&gt; の場合と同様に、 &lt;code&gt;dataTable()&lt;/code&gt; 関数は実行時に存在する必要があることを理解することが重要です。この場合、プラグインに対応するスクリプトファイルが含まれていることを確認する必要があります。</target>
        </trans-unit>
        <trans-unit id="0e863e2f2b3f4c7cb9be7530e2969137eb812edc" translate="yes" xml:space="preserve">
          <source>It is not recommended to publish variants grouped by the product flavor in case they have different dependencies, as those will be merged into one dependencies list.</source>
          <target state="translated">異なる依存関係を持っている場合に、製品のフレーバーでグループ化された variant を公開することは推奨されません。</target>
        </trans-unit>
        <trans-unit id="41a0e8e8363c715bede252f00decd03608d5ae6b" translate="yes" xml:space="preserve">
          <source>It is not required to match directories and packages: source files can be placed arbitrarily in the file system.</source>
          <target state="translated">ディレクトリとパッケージを一致させる必要はありません:ソースファイルはファイルシステム内の任意の場所に置くことができます。</target>
        </trans-unit>
        <trans-unit id="ed10861129de21214d3c19646f1725bf54132b36" translate="yes" xml:space="preserve">
          <source>It is now possible to enumerate the values of an enum class in a generic way.</source>
          <target state="translated">enumクラスの値を汎用的に列挙することができるようになりました。</target>
        </trans-unit>
        <trans-unit id="e7a4a5a763a24f82bedd348e3c81f2b59dad3138" translate="yes" xml:space="preserve">
          <source>It is platform independent. Whether we targeting JVM, JavaScript or any other platform, the code we write is the same. Under the covers the compiler takes care of adapting it to each platform.</source>
          <target state="translated">プラットフォームに依存しません。JVMをターゲットにしていても、JavaScriptをターゲットにしていても、他のプラットフォームをターゲットにしていても、書くコードは同じです。カバーの下では、コンパイラが各プラットフォームに適応するように世話をしてくれます。</target>
        </trans-unit>
        <trans-unit id="4d947185f89d323fe7c7abf6d8cbb01ea4b530eb" translate="yes" xml:space="preserve">
          <source>It is possible for a class to implement a function type as if it were an interface. It must then supply an operator function called &lt;code&gt;invoke&lt;/code&gt; with the given signature, and instances of that class may then be assigned to a variable of that function type:</source>
          <target state="translated">クラスが関数型をインターフェースのように実装することは可能です。次に、 &lt;code&gt;invoke&lt;/code&gt; と呼ばれる演算子関数を特定のシグネチャで提供する必要があり、そのクラスのインスタンスをその関数型の変数に割り当てることができます。</target>
        </trans-unit>
        <trans-unit id="05ec15ebc6d7af617a86a57248adcf19a55ca53f" translate="yes" xml:space="preserve">
          <source>It is possible to annotate type arguments of generic types to provide nullability information for them as well. For example, consider these annotations on a Java declaration:</source>
          <target state="translated">一般的な型の型引数にもヌル可能性情報を提供するためにアノテーションを付けることができます。例えば、Java宣言に以下のようなアノテーションを付けることを考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="a4db969f6c44a5e65473207ba72459c76a3f1c8a" translate="yes" xml:space="preserve">
          <source>It is possible to configure the language settings of all source sets at once:</source>
          <target state="translated">すべてのソースセットの言語設定を一度に設定することができます。</target>
        </trans-unit>
        <trans-unit id="8ee4c90445d9b9d795928bb3dfbba324ab54fe64" translate="yes" xml:space="preserve">
          <source>It is possible to create a scope-stable pointer of C representation of &lt;code&gt;CValues&amp;lt;T&amp;gt;&lt;/code&gt; instance using the &lt;code&gt;CValues&amp;lt;T&amp;gt;.ptr&lt;/code&gt; extension property, available under &lt;code&gt;memScoped { ... }&lt;/code&gt;. It allows using the APIs which require C pointers with a lifetime bound to a certain &lt;code&gt;MemScope&lt;/code&gt;. For example:</source>
          <target state="translated">Cの表現の範囲安定ポインタを作成することが可能である &lt;code&gt;CValues&amp;lt;T&amp;gt;&lt;/code&gt; 使用してインスタンス &lt;code&gt;CValues&amp;lt;T&amp;gt;.ptr&lt;/code&gt; 下で入手可能な、拡張性、 &lt;code&gt;memScoped { ... }&lt;/code&gt; 。これにより、特定の &lt;code&gt;MemScope&lt;/code&gt; に有効期間がバインドされたCポインターを必要とするAPIを使用できます。例えば：</target>
        </trans-unit>
        <trans-unit id="a1c523500d91947ee9765a964b978e521350e87f" translate="yes" xml:space="preserve">
          <source>It is possible to customize the default behavior of printing &lt;strong&gt;uncaught&lt;/strong&gt; exceptions to the console. &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-exception-handler/index.html&quot;&gt;CoroutineExceptionHandler&lt;/a&gt; context element on a &lt;em&gt;root&lt;/em&gt; coroutine can be used as generic &lt;code&gt;catch&lt;/code&gt; block for this root coroutine and all its children where custom exception handling may take place. It is similar to &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html#setUncaughtExceptionHandler(java.lang.Thread.UncaughtExceptionHandler)&quot;&gt;&lt;code&gt;Thread.uncaughtExceptionHandler&lt;/code&gt;&lt;/a&gt;. You cannot recover from the exception in the &lt;code&gt;CoroutineExceptionHandler&lt;/code&gt;. The coroutine had already completed with the corresponding exception when the handler is called. Normally, the handler is used to log the exception, show some kind of error message, terminate, and/or restart the application.</source>
          <target state="translated">&lt;strong&gt;キャッチされなかった&lt;/strong&gt;例外をコンソールに出力するデフォルトの動作をカスタマイズすることができます。&lt;em&gt;ルート&lt;/em&gt;コルーチンの&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-exception-handler/index.html&quot;&gt;CoroutineExceptionHandler&lt;/a&gt;コンテキスト要素は、このルートコルーチンと、カスタム例外処理が行われる可能性のあるすべての子の汎用 &lt;code&gt;catch&lt;/code&gt; ブロックとして使用できます。これは&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html#setUncaughtExceptionHandler(java.lang.Thread.UncaughtExceptionHandler)&quot;&gt; &lt;code&gt;Thread.uncaughtExceptionHandler&lt;/code&gt; に&lt;/a&gt;似ています。 &lt;code&gt;CoroutineExceptionHandler&lt;/code&gt; の例外から回復することはできません。コルーチンは、ハンドラーが呼び出されたときに対応する例外を除いてすでに完了しています。通常、ハンドラーは、例外のログ記録、何らかのエラーメッセージの表示、アプリケーションの終了、および/または再起動に使用されます。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e9091ebea40cd5ed5eeeecc5f5fcdcb74a99a77f" translate="yes" xml:space="preserve">
          <source>It is possible to declare contracts for your own functions, but this feature is &lt;strong&gt;experimental,&lt;/strong&gt; as the current syntax is in a state of early prototype and will most probably be changed. Also, please note, that currently the Kotlin compiler does not verify contracts, so it's a programmer's responsibility to write correct and sound contracts.</source>
          <target state="translated">独自の関数のコントラクトを宣言することは可能ですが、現在の構文は初期のプロトタイプの状態にあり、おそらく変更されるため&lt;strong&gt;、&lt;/strong&gt;この機能は&lt;strong&gt;実験的&lt;/strong&gt;です。また、現在Kotlinコンパイラーは契約を検証しないため、プログラマーは正しい健全な契約を作成する必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="dc3778d4014e6f71dce4d7d20c0e012498a2087a" translate="yes" xml:space="preserve">
          <source>It is possible to filter headers by globs. The &lt;code&gt;headerFilter&lt;/code&gt; property value from the &lt;code&gt;.def&lt;/code&gt; file is treated as a space-separated list of globs. If the included header matches any of the globs, then the declarations from this header are included into the bindings.</source>
          <target state="translated">グロブでヘッダーをフィルタリングすることが可能です。 &lt;code&gt;.def&lt;/code&gt; ファイルの &lt;code&gt;headerFilter&lt;/code&gt; プロパティ値は、スペースで区切られたグロブのリストとして扱われます。含まれているヘッダーがグロブのいずれかに一致する場合、このヘッダーからの宣言がバインディングに含まれます。</target>
        </trans-unit>
        <trans-unit id="402a77d3239dcd76fb899799d8112b0ad86dfc4e" translate="yes" xml:space="preserve">
          <source>It is possible to have more than one target for a single platform in a multiplatform library. For example, these targets may provide the same API and differ in the libraries they cooperate with at runtime, like testing frameworks or logging solutions.</source>
          <target state="translated">マルチプラットフォームライブラリでは、1 つのプラットフォームに対して複数のターゲットを持つことが可能です。例えば、これらのターゲットは同じ API を提供し、テストフレームワークやロギングソリューションのように、実行時に連携するライブラリが異なる場合があります。</target>
        </trans-unit>
        <trans-unit id="2e301a8ab019737ffb1879efcfc2dbdf711dcf6a" translate="yes" xml:space="preserve">
          <source>It is possible to specify which build types will be used to create binaries and which won't. In the following example only debug executable is created.</source>
          <target state="translated">どのビルドタイプを使用してバイナリを作成し、どのビルドタイプを使用しないかを指定することができます。次の例では、デバッグ用の実行ファイルのみを作成しています。</target>
        </trans-unit>
        <trans-unit id="c4c1947233d08bc7cc11e65c450d05edf9570b44" translate="yes" xml:space="preserve">
          <source>It is quite a common situation to have a list of keys and want to build a map by associating each of these keys with some value. It was possible to do it before with the &lt;code&gt;associate { it to getValue(it) }&lt;/code&gt; function, but now we&amp;rsquo;re introducing a more efficient and easy to explore alternative: &lt;code&gt;keys.associateWith { getValue(it) }&lt;/code&gt;.</source>
          <target state="translated">キーのリストがあり、これらのキーのそれぞれを何らかの値に関連付けることによってマップを作成することは、非常に一般的な状況です。以前は、 &lt;code&gt;associate { it to getValue(it) }&lt;/code&gt; 関数を使用してそれを行うことが可能でしたが、今では、より効率的で簡単に探索できる代替手段である &lt;code&gt;keys.associateWith { getValue(it) }&lt;/code&gt; 導入しています。</target>
        </trans-unit>
        <trans-unit id="cb237bed1931cb077bff53fe7955788594878ed8" translate="yes" xml:space="preserve">
          <source>It is safe to treat a &lt;code&gt;Consumer&amp;lt;Fruit&amp;gt;&lt;/code&gt; as a &lt;code&gt;Consumer&amp;lt;Apple&amp;gt;&lt;/code&gt; - you are then restricted to only adding &lt;code&gt;Apple&lt;/code&gt; instances to it, but that's okay, because it is capable of receiving any &lt;code&gt;Fruit&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Consumer&amp;lt;Fruit&amp;gt;&lt;/code&gt; を &lt;code&gt;Consumer&amp;lt;Apple&amp;gt;&lt;/code&gt; &amp;gt;として扱うのは安全です。これにより、 &lt;code&gt;Apple&lt;/code&gt; インスタンスの追加のみに制限されますが、任意の &lt;code&gt;Fruit&lt;/code&gt; を受け取ることができるため、問題ありません。</target>
        </trans-unit>
        <trans-unit id="dc95825b1857af449f9e7a03e1be3bb43d0ddb3a" translate="yes" xml:space="preserve">
          <source>It is safe to treat a &lt;code&gt;Producer&amp;lt;Apple&amp;gt;&lt;/code&gt; as if it were a &lt;code&gt;Producer&amp;lt;Fruit&amp;gt;&lt;/code&gt; - the only thing it will ever produce is &lt;code&gt;Apple&lt;/code&gt; instances, but that's okay, because an &lt;code&gt;Apple&lt;/code&gt; is a &lt;code&gt;Fruit&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Producer&amp;lt;Apple&amp;gt;&lt;/code&gt; を &lt;code&gt;Producer&amp;lt;Fruit&amp;gt;&lt;/code&gt; ように扱うのは安全です。これにより生成されるのは &lt;code&gt;Apple&lt;/code&gt; インスタンスのみですが、 &lt;code&gt;Apple&lt;/code&gt; は &lt;code&gt;Fruit&lt;/code&gt; なので問題ありません。</target>
        </trans-unit>
        <trans-unit id="1cb7a9be64c1b10976e2826c53f2565e3ab27c33" translate="yes" xml:space="preserve">
          <source>It is the same as the hashCode of &lt;a href=&quot;../-map/entries#kotlin.collections.Map%24entries&quot;&gt;entries&lt;/a&gt; set.</source>
          <target state="translated">設定した&lt;a href=&quot;../-map/entries#kotlin.collections.Map%24entries&quot;&gt;エントリ&lt;/a&gt;のhashCodeと同じです。</target>
        </trans-unit>
        <trans-unit id="638b2a44297b2347a2a9b3d378c007753c4381ba" translate="yes" xml:space="preserve">
          <source>It is the time to try using C Functions from our Kotlin program. Let's call the &lt;code&gt;accept_fun&lt;/code&gt; function and pass the C function pointer to a Kotlin lambda:</source>
          <target state="translated">KotlinプログラムのC関数を使用するときです。 &lt;code&gt;accept_fun&lt;/code&gt; 関数を呼び出して、C関数ポインターをKotlinラムダに渡します。</target>
        </trans-unit>
        <trans-unit id="d8fa5339a1950bfcc4e526f49360c54a4a63bc2d" translate="yes" xml:space="preserve">
          <source>It is very convenient to declare a type parameter T as &lt;em&gt;out&lt;/em&gt; and avoid trouble with subtyping on the use site, but some classes &lt;strong&gt;can't&lt;/strong&gt; actually be restricted to only return &lt;code&gt;T&lt;/code&gt;'s! A good example of this is Array:</source>
          <target state="translated">型パラメーターTを&lt;em&gt;out&lt;/em&gt;として宣言し、使用サイトでのサブタイピングの問題を回避することは非常に便利ですが、一部のクラス&lt;strong&gt;は&lt;/strong&gt;実際には &lt;code&gt;T&lt;/code&gt; のみを返すように制限&lt;strong&gt;できません&lt;/strong&gt;。これの良い例は配列です：</target>
        </trans-unit>
        <trans-unit id="776fdced037b223c21ef26795ae5fc999fa0ee3e" translate="yes" xml:space="preserve">
          <source>It launches 100K coroutines and, after 5 seconds, each coroutine prints a dot.</source>
          <target state="translated">100Kのコルーチンを起動し、5秒後に各コルーチンがドットを印刷します。</target>
        </trans-unit>
        <trans-unit id="b163cb494d8f7133d17c75969b6f58ad44cf2144" translate="yes" xml:space="preserve">
          <source>It launches 100K coroutines and, after a second, each coroutine prints a dot. Now, try that with threads. What would happen? (Most likely your code will produce some sort of out-of-memory error)</source>
          <target state="translated">10万個のコルーチンを起動して 1秒後に各コルーチンがドットを印刷します では、それをスレッドで試してみてください。どうなるでしょうか?(たいていの場合、あなたのコードは何らかのメモリ切れのエラーを出すでしょう)</target>
        </trans-unit>
        <trans-unit id="efa9aff9b6f6c29df2d20508228006677fa18621" translate="yes" xml:space="preserve">
          <source>It leads to the following signature seen in Kotlin:</source>
          <target state="translated">それは、Kotlinで見られる以下のような署名につながります。</target>
        </trans-unit>
        <trans-unit id="31157cfdb7da2c923cc250df2cdef99f52021252" translate="yes" xml:space="preserve">
          <source>It makes it easy to add and reorder elements &amp;ndash; there is no need to add or delete the comma if you manipulate elements.</source>
          <target state="translated">要素の追加と並べ替えが簡単になります。要素を操作する場合、コンマを追加または削除する必要はありません。</target>
        </trans-unit>
        <trans-unit id="17169e22fd37b9c0c61060b6531c5a37b04dbe03" translate="yes" xml:space="preserve">
          <source>It makes version-control diffs cleaner &amp;ndash; as all the focus is on the changed value.</source>
          <target state="translated">変更された値にすべての焦点が当てられるため、バージョン管理の差分がよりクリーンになります。</target>
        </trans-unit>
        <trans-unit id="50a8da20f5180842f95e2e885ec1433b6eb6b732" translate="yes" xml:space="preserve">
          <source>It may be helpful only if declaration seems to be inconvenient to use from Java without wildcard.</source>
          <target state="translated">ワイルドカードがないとJavaからの宣言が不便そうな場合にのみ参考になるかもしれません。</target>
        </trans-unit>
        <trans-unit id="8ead6eaf5a09cdd5203f3d7332c148b0e2afab55" translate="yes" xml:space="preserve">
          <source>It may be helpful only if declaration seems to be inconvenient to use from Java.</source>
          <target state="translated">宣言がJavaからだと不便そうな場合にのみ参考になるかもしれません。</target>
        </trans-unit>
        <trans-unit id="92fc36943474eb17749f18ce6facbefadc2bd75a" translate="yes" xml:space="preserve">
          <source>It may seem a logical next step to remove this obscurity by switching the defaults in IntelliJ IDEA and make formatting consistent with the Kotlin Coding Conventions. But this would mean that all the existing Kotlin projects will have a new code style enabled the moment the Kotlin plugin is installed. Not really the expected result for plugin update, right?</source>
          <target state="translated">この不明瞭さを取り除くために、IntelliJ IDEAのデフォルトを切り替えて、Kotlinのコーディング規約と整合性のあるフォーマットにすることは、論理的な次のステップのように思えるかもしれません。しかし、これはKotlinプラグインがインストールされた瞬間に、すべての既存のKotlinプロジェクトで新しいコードスタイルが有効になることを意味します。プラグインのアップデートではあまり期待していた結果ではないですよね?</target>
        </trans-unit>
        <trans-unit id="5a4d0a01a307589d4ada06d8aac41c245c2a1232" translate="yes" xml:space="preserve">
          <source>It means that, by the time of the base class constructor execution, the properties declared or overridden in the derived class are not yet initialized. If any of those properties are used in the base class initialization logic (either directly or indirectly, through another overridden &lt;em&gt;open&lt;/em&gt; member implementation), it may lead to incorrect behavior or a runtime failure. When designing a base class, you should therefore avoid using &lt;em&gt;open&lt;/em&gt; members in the constructors, property initializers, and &lt;em&gt;init&lt;/em&gt; blocks.</source>
          <target state="translated">つまり、基本クラスコンストラクターの実行時には、派生クラスで宣言またはオーバーライドされたプロパティはまだ初期化されていません。これらのプロパティのいずれかが（直接または間接的に、別のオーバーライドさ&lt;em&gt;れたオープン&lt;/em&gt;メンバー実装を介して）基本クラスの初期化ロジックで使用されている場合、不正な動作またはランタイムエラーが発生する可能性があります。したがって、基本クラスを設計するときは、コンストラクター、プロパティ初期化子、および&lt;em&gt;init&lt;/em&gt;ブロックで&lt;em&gt;オープン&lt;/em&gt;メンバーを使用しないようにする必要があります。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="797f38dacaae5d59a26c62d2dd822a0488289854" translate="yes" xml:space="preserve">
          <source>It might be temping to use JVM's &lt;code&gt;java.util.Scanner&lt;/code&gt; class to parse less structured input formats. Kotlin is designed to interoperate well with JVM libraries, so that their use feels quite natural in Kotlin. However, beware that &lt;code&gt;java.util.Scanner&lt;/code&gt; is extremely slow. So slow, in fact, that parsing 10&lt;sup&gt;5&lt;/sup&gt; or more integers with it might not fit into a typical 2 second time-limit, which a simple Kotlin's &lt;code&gt;split(&quot; &quot;).map { it.toInt() }&lt;/code&gt; would handle.</source>
          <target state="translated">あまり構造化されていない入力形式を解析するために、JVMの &lt;code&gt;java.util.Scanner&lt;/code&gt; クラスを使用するのは魅力的かもしれません。KotlinはJVMライブラリとうまく相互運用できるように設計されているため、Kotlinでの使用は非常に自然に感じられます。ただし、 &lt;code&gt;java.util.Scanner&lt;/code&gt; は非常に遅いことに注意してください。実際には非常に遅いため、10 &lt;sup&gt;5&lt;/sup&gt;以上の整数を解析すると、単純なKotlinの &lt;code&gt;split(&quot; &quot;).map { it.toInt() }&lt;/code&gt; が処理する通常の2秒の時間制限に収まらない可能性があります。</target>
        </trans-unit>
        <trans-unit id="4dcefeb4f7398e3e9107786806cb210122661b33" translate="yes" xml:space="preserve">
          <source>It prints &quot;sending&quot; &lt;em&gt;five&lt;/em&gt; times using a buffered channel with capacity of &lt;em&gt;four&lt;/em&gt;:</source>
          <target state="translated">&lt;em&gt;4つの&lt;/em&gt;容量を持つバッファ付きチャネルを使用して、「送信」を&lt;em&gt;5&lt;/em&gt;回印刷します。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="22cac1fe7a5de098526c35e5a30637b070cd91b6" translate="yes" xml:space="preserve">
          <source>It prints following lines:</source>
          <target state="translated">以下の行を印刷します。</target>
        </trans-unit>
        <trans-unit id="c7f4b533e837bd7e46a9ce1a0a22fbfcd4d17d31" translate="yes" xml:space="preserve">
          <source>It produces something like that when running in &lt;a href=&quot;#debugging-coroutines-and-threads&quot;&gt;debug mode&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;#debugging-coroutines-and-threads&quot;&gt;デバッグモードで&lt;/a&gt;実行すると、次のようになります。</target>
        </trans-unit>
        <trans-unit id="438255e8d8df7e6af7b2286b9eb0a1ff8f4ea247" translate="yes" xml:space="preserve">
          <source>It produces something like this:</source>
          <target state="translated">こんな感じのものが出てきます。</target>
        </trans-unit>
        <trans-unit id="fb781104064af1d8629d3a388a507c72839c91db" translate="yes" xml:space="preserve">
          <source>It produces the following output (maybe in different order):</source>
          <target state="translated">以下のような出力が得られます(順番が違うかもしれません)。</target>
        </trans-unit>
        <trans-unit id="c9f7c3047939db3a0d1c9e3a0026fbe61df824db" translate="yes" xml:space="preserve">
          <source>It produces the following output:</source>
          <target state="translated">以下のような出力が得られます。</target>
        </trans-unit>
        <trans-unit id="17589c30d4bd3d4e252acd3e2fde1d3c719a5224" translate="yes" xml:space="preserve">
          <source>It returns a composition of two functions passed to it: &lt;code&gt;compose(f, g) = f(g(*))&lt;/code&gt;. Now, you can apply it to callable references:</source>
          <target state="translated">渡された2つの関数 &lt;code&gt;compose(f, g) = f(g(*))&lt;/code&gt; 合成を返します。これで、呼び出し可能な参照にそれを適用できます。</target>
        </trans-unit>
        <trans-unit id="ed5dfacacd6fed6df8733c434a43165786f1b136" translate="yes" xml:space="preserve">
          <source>It simplifies code generation, for example, for object initializers. The last element can also have a comma.</source>
          <target state="translated">これにより、例えばオブジェクトのイニシャライザなどのコード生成が簡素化されます。最後の要素にはカンマを付けることもできます。</target>
        </trans-unit>
        <trans-unit id="adaa459203490bc09b0dd6700bcf5aacd3687f3b" translate="yes" xml:space="preserve">
          <source>It takes two &lt;code&gt;Int&lt;/code&gt; parameters and returns a &lt;code&gt;Double&lt;/code&gt;, so its type is &lt;code&gt;(Int, Int) -&amp;gt; Double&lt;/code&gt;. We can reference the function itself by prefixing its name with &lt;code&gt;::&lt;/code&gt;, and we can assign it to a variable (whose type would normally be inferred, but we show the type signature for demonstration):</source>
          <target state="translated">2つの &lt;code&gt;Int&lt;/code&gt; パラメータを取り、 &lt;code&gt;Double&lt;/code&gt; を返すため、その型は &lt;code&gt;(Int, Int) -&amp;gt; Double&lt;/code&gt; です。名前の前に &lt;code&gt;::&lt;/code&gt; を付けることで関数自体を参照し、変数に割り当てることができます（型は通常推論されますが、デモのために型シグネチャを示します）。</target>
        </trans-unit>
        <trans-unit id="c85187abd273afe2d39456db809770ff8d17b7cc" translate="yes" xml:space="preserve">
          <source>It will produce a platform-specific shared object (.so on Linux, .dylib on macOS, and .dll on Windows targets) and a C language header, allowing the use of all public APIs available in your Kotlin/Native program from C/C++ code. See &lt;code&gt;samples/python_extension&lt;/code&gt; for an example of using such a shared object to provide a bridge between Python and Kotlin/Native.</source>
          <target state="translated">プラットフォーム固有の共有オブジェクト（Linuxでは.so、macOSでは.dylib、Windowsターゲットでは.dll）とC言語ヘッダーを生成し、C /からKotlin / Nativeプログラムで利用可能なすべてのパブリックAPIを使用できるようにしますC ++コード。このような共有オブジェクトを使用してPythonとKotlin / Native間のブリッジを提供する例については、 &lt;code&gt;samples/python_extension&lt;/code&gt; をご覧ください。</target>
        </trans-unit>
        <trans-unit id="9b575c19d946e336100c7ed068ca562177833082" translate="yes" xml:space="preserve">
          <source>It will produce a platform-specific static object (.a library format) and a C language header, allowing you to use all the public APIs available in your Kotlin/Native program from C/C++ code.</source>
          <target state="translated">プラットフォーム固有の静的オブジェクト (.a ライブラリ形式)と C 言語ヘッダを生成し、C/C++コードから Kotlin/Native プログラムで利用可能なすべてのパブリック API を利用できるようにします。</target>
        </trans-unit>
        <trans-unit id="c77b95136e56addaaf94d730513b3a8bef6e57a3" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s almost done, user feedback is especially important now.</source>
          <target state="translated">ほぼ完了しました。ユーザーからのフィードバックは特に重要です。</target>
        </trans-unit>
        <trans-unit id="039acb422f298b9e2dda428662093ea454940860" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s done. We will be evolving it according to our strict &lt;a href=&quot;https://kotlinlang.org/foundation/language-committee-guidelines.html&quot;&gt;backward compatibility rules&lt;/a&gt;.</source>
          <target state="translated">終わった。厳密な&lt;a href=&quot;https://kotlinlang.org/foundation/language-committee-guidelines.html&quot;&gt;下位互換性ルール&lt;/a&gt;に従って進化させます。</target>
        </trans-unit>
        <trans-unit id="b3d38eb85ce2f60386c4898b42f31b426d1bea2f" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s easy to get started with Kotlin using the Kotlin plugin integrated in &lt;a href=&quot;https://www.jetbrains.com/idea/&quot;&gt;IntelliJ IDEA&lt;/a&gt;. Benefit from code highlighting, code completion, refactoring, debugging, and other features available for Kotlin.</source>
          <target state="translated">&lt;a href=&quot;https://www.jetbrains.com/idea/&quot;&gt;IntelliJ IDEAに&lt;/a&gt;統合されたKotlinプラグインを使用すると、Kotlinを簡単に使い始めることができます。Kotlinで利用可能なコードの強調表示、コードの補完、リファクタリング、デバッグ、およびその他の機能を利用できます。</target>
        </trans-unit>
        <trans-unit id="7d20f5ce9372886e3a18510e89bf62db3fa25cfc" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s extremely easy to start using Kotlin for Android development. In this tutorial we&amp;rsquo;ll follow the warming up process with Android Studio. If you're using Intellij IDEA with Android, the process is almost the same.</source>
          <target state="translated">Android開発にKotlinを使い始めるのは非常に簡単です。このチュートリアルでは、Android Studioを使用したウォーミングアッププロセスに従います。AndroidでIntellij IDEAを使用している場合、プロセスはほとんど同じです。</target>
        </trans-unit>
        <trans-unit id="0d25598a290d255bee23e0efee2aa27e246b4f17" translate="yes" xml:space="preserve">
          <source>It's allowed to pass the same array in the &lt;a href=&quot;copy-into#kotlin.collections%24copyInto%28kotlin.Array%28%28kotlin.collections.copyInto.T%29%29%2C+kotlin.Array%28%28kotlin.collections.copyInto.T%29%29%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Int%29%2Fdestination&quot;&gt;destination&lt;/a&gt; and even specify the subrange so that it overlaps with the destination range.</source>
          <target state="translated">同じ配列を&lt;a href=&quot;copy-into#kotlin.collections%24copyInto%28kotlin.Array%28%28kotlin.collections.copyInto.T%29%29%2C+kotlin.Array%28%28kotlin.collections.copyInto.T%29%29%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Int%29%2Fdestination&quot;&gt;宛先&lt;/a&gt;に渡して、宛先範囲と重複するようにサブ範囲を指定することもできます。</target>
        </trans-unit>
        <trans-unit id="ccc637fca146e7aa9091977f4ab6a14a8ec874b0" translate="yes" xml:space="preserve">
          <source>It's allowed to pass the same array in the &lt;a href=&quot;copy-into#kotlin.collections%24copyInto%28kotlin.UIntArray%2C+kotlin.UIntArray%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Int%29%2Fdestination&quot;&gt;destination&lt;/a&gt; and even specify the subrange so that it overlaps with the destination range.</source>
          <target state="translated">同じ配列を&lt;a href=&quot;copy-into#kotlin.collections%24copyInto%28kotlin.UIntArray%2C+kotlin.UIntArray%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Int%29%2Fdestination&quot;&gt;宛先&lt;/a&gt;に渡して、宛先範囲と重複するようにサブ範囲を指定することもできます。</target>
        </trans-unit>
        <trans-unit id="c547761ff928eabb85ae6f68b2a8d06acf2434c8" translate="yes" xml:space="preserve">
          <source>It's allowed to pass the same array in the &lt;a href=&quot;copy-into#kotlin.collections%24copyInto(kotlin.Array((kotlin.collections.copyInto.T)),%20kotlin.Array((kotlin.collections.copyInto.T)),%20kotlin.Int,%20kotlin.Int,%20kotlin.Int)/destination&quot;&gt;destination&lt;/a&gt; and even specify the subrange so that it overlaps with the destination range.</source>
          <target state="translated">&lt;a href=&quot;copy-into#kotlin.collections%24copyInto(kotlin.Array((kotlin.collections.copyInto.T)),%20kotlin.Array((kotlin.collections.copyInto.T)),%20kotlin.Int,%20kotlin.Int,%20kotlin.Int)/destination&quot;&gt;宛先で&lt;/a&gt;同じ配列を渡すことができ、宛先範囲とオーバーラップするようにサブ範囲を指定することもできます。</target>
        </trans-unit>
        <trans-unit id="0234d9c081afa271a5761a94d33278199b8154d0" translate="yes" xml:space="preserve">
          <source>It's allowed to pass the same array in the &lt;a href=&quot;copy-into#kotlin.collections%24copyInto(kotlin.UIntArray,%20kotlin.UIntArray,%20kotlin.Int,%20kotlin.Int,%20kotlin.Int)/destination&quot;&gt;destination&lt;/a&gt; and even specify the subrange so that it overlaps with the destination range.</source>
          <target state="translated">&lt;a href=&quot;copy-into#kotlin.collections%24copyInto(kotlin.UIntArray,%20kotlin.UIntArray,%20kotlin.Int,%20kotlin.Int,%20kotlin.Int)/destination&quot;&gt;宛先で&lt;/a&gt;同じ配列を渡すことができ、宛先範囲とオーバーラップするようにサブ範囲を指定することもできます。</target>
        </trans-unit>
        <trans-unit id="031250b72b284d8b276f90bf0d49fd6078c2857d" translate="yes" xml:space="preserve">
          <source>It's always possible to explicitly set the IntelliJ IDEA code style as the correct code style for the project. To do so please switch to the &lt;em&gt;Project&lt;/em&gt; scheme in &lt;code&gt;Settings &amp;rarr; Editor &amp;rarr; Code Style &amp;rarr; Kotlin&lt;/code&gt; and select &lt;em&gt;&quot;Kotlin obsolete IntelliJ IDEA codestyle&quot;&lt;/em&gt; in the &lt;em&gt;&quot;Use defaults from:&quot;&lt;/em&gt; on the &lt;em&gt;Load&lt;/em&gt; tab.</source>
          <target state="translated">IntelliJ IDEAコードスタイルをプロジェクトの正しいコードスタイルとして明示的に設定することは常に可能です。そうしてくださいスイッチを行うには&lt;em&gt;、プロジェクト&lt;/em&gt;におけるスキーム &lt;code&gt;Settings &amp;rarr; Editor &amp;rarr; Code Style &amp;rarr; Kotlin&lt;/code&gt; と選択し&lt;em&gt;、「Kotlin時代遅れのIntelliJ IDEAのcodestyleを」&lt;/em&gt;中&lt;em&gt;「から使用デフォルト：」&lt;/em&gt;に&lt;em&gt;ロード&lt;/em&gt; ]タブをクリックします。</target>
        </trans-unit>
        <trans-unit id="6e80a1e74b8c8e47694ccc45eb2685d70fcb822d" translate="yes" xml:space="preserve">
          <source>It's currently not possible to pass &lt;em&gt;null&lt;/em&gt; to a method that is declared as varargs.</source>
          <target state="translated">現在、varargsとして宣言されているメソッドに&lt;em&gt;null&lt;/em&gt;を渡すことはできません。</target>
        </trans-unit>
        <trans-unit id="114b9bcaf449cf9b870e05fba48add6ecc248f08" translate="yes" xml:space="preserve">
          <source>It's easy to forget to set the corresponding context element. The thread-local variable accessed from the coroutine may then have an unexpected value, if the thread running the coroutine is different. To avoid such situations, it is recommended to use the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/java.lang.-thread-local/ensure-present.html&quot;&gt;ensurePresent&lt;/a&gt; method and fail-fast on improper usages.</source>
          <target state="translated">対応するコンテキスト要素を設定するのを忘れがちです。コルーチンを実行しているスレッドが異なる場合、コルーチンからアクセスされるスレッドローカル変数は予期しない値を持つ可能性があります。このような状況を回避するには、&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/java.lang.-thread-local/ensure-present.html&quot;&gt;ensurePresent&lt;/a&gt;メソッドを使用し、不適切な使用法でフェイルファストすることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="acfee84980c04ef0fe85e54f28d399f66e64abaa" translate="yes" xml:space="preserve">
          <source>It's fine to inherit from both &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;, and we have no problems with &lt;code&gt;a()&lt;/code&gt; and &lt;code&gt;b()&lt;/code&gt; since &lt;code&gt;C&lt;/code&gt; inherits only one implementation of each of these functions. But for &lt;code&gt;f()&lt;/code&gt; we have two implementations inherited by &lt;code&gt;C&lt;/code&gt;, and thus we have to override &lt;code&gt;f()&lt;/code&gt; in &lt;code&gt;C&lt;/code&gt; and provide our own implementation that eliminates the ambiguity.</source>
          <target state="translated">これは、罰金の継承の両方から &lt;code&gt;A&lt;/code&gt; と &lt;code&gt;B&lt;/code&gt; 、そして我々はに問題がない &lt;code&gt;a()&lt;/code&gt; と &lt;code&gt;b()&lt;/code&gt; ので、 &lt;code&gt;C&lt;/code&gt; は、これらの機能のそれぞれの唯一の実装を継承します。しかし、用 &lt;code&gt;f()&lt;/code&gt; 我々はによって継承された2つの実装持っている &lt;code&gt;C&lt;/code&gt; をので、私たちはオーバーライドする必要があり &lt;code&gt;f()&lt;/code&gt; 中に &lt;code&gt;C&lt;/code&gt; やあいまいさを排除し、当社独自の実装を提供します。</target>
        </trans-unit>
        <trans-unit id="04f1d0f6695973692315398bd64dee5cfdd7323c" translate="yes" xml:space="preserve">
          <source>It's fine to inherit from both &lt;code&gt;Rectangle&lt;/code&gt; and &lt;code&gt;Polygon&lt;/code&gt;, but both of them have their implementations of &lt;code&gt;draw()&lt;/code&gt;, so we have to override &lt;code&gt;draw()&lt;/code&gt; in &lt;code&gt;Square&lt;/code&gt; and provide its own implementation that eliminates the ambiguity.</source>
          <target state="translated">&lt;code&gt;Rectangle&lt;/code&gt; と &lt;code&gt;Polygon&lt;/code&gt; の両方から継承することは問題ありませんが、どちらにも &lt;code&gt;draw()&lt;/code&gt; の実装があるため、 &lt;code&gt;Square&lt;/code&gt; で &lt;code&gt;draw()&lt;/code&gt; をオーバーライドし、あいまいさを排除する独自の実装を提供する必要があります。</target>
        </trans-unit>
        <trans-unit id="442e1f9409803560cb8db1e8e932691b852b50ed" translate="yes" xml:space="preserve">
          <source>It's important to close a stream when you're done with it; otherwise, your program will leak a file handle. See the next section for how do do this nicely.</source>
          <target state="translated">そうしないと、プログラムがファイルハンドルを漏らしてしまいます。そうしないと、あなたのプログラムはファイルハンドルを漏らしてしまいます。</target>
        </trans-unit>
        <trans-unit id="9346c60b395e4bb0937fa0abc8c38e87d658e069" translate="yes" xml:space="preserve">
          <source>It's important to make sure that the &lt;em&gt;Include Kotlin support&lt;/em&gt; checkbox is ticked. For now we can leave the default settings in the next step of the wizard. We then proceed to select the &lt;em&gt;Empty Activity&lt;/em&gt; option and click &lt;em&gt;Next&lt;/em&gt;, finally pressing &lt;em&gt;Finish&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;Kotlinサポートを含める&lt;/em&gt;チェックボックスがオンになっていることを確認することが重要です。とりあえず、ウィザードの次のステップはデフォルト設定のままにしておくことができます。&lt;em&gt;次に&lt;/em&gt;、[ &lt;em&gt;空のアクティビティ&lt;/em&gt; ]オプションを選択して[ &lt;em&gt;次へ&lt;/em&gt; ]をクリックし、最後に[ &lt;em&gt;完了&lt;/em&gt; ]を押します。</target>
        </trans-unit>
        <trans-unit id="3f80b2897a86bf69ce94fa9c91efda88ddaabb97" translate="yes" xml:space="preserve">
          <source>It's important to understand that this is now a native application, and no runtime or virtual machine is required. We can now run the compiled binary from the console:</source>
          <target state="translated">これがネイティブアプリケーションになったことを理解することが重要で、ランタイムや仮想マシンは必要ありません。コンパイルしたバイナリをコンソールから実行できるようになりました。</target>
        </trans-unit>
        <trans-unit id="841256700fec240b48d1a1475f562513e2734121" translate="yes" xml:space="preserve">
          <source>It's not recommended that you apply Kotlin plugins with &lt;code&gt;apply&lt;/code&gt; in Gradle Kotlin DSL &amp;ndash; &lt;a href=&quot;#using-gradle-kotlin-dsl&quot;&gt;see why&lt;/a&gt;.</source>
          <target state="translated">Gradle Kotlin DSLで &lt;code&gt;apply&lt;/code&gt; を使用してKotlinプラグインを適用することはお勧めしません&amp;ndash;&lt;a href=&quot;#using-gradle-kotlin-dsl&quot;&gt;理由を参照してください&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="451aaccdf6c2eb6d6c44303ffdea63bce2a3d7a2" translate="yes" xml:space="preserve">
          <source>It's not recommended to apply Kotlin plugins with &lt;code&gt;apply&lt;/code&gt; in Gradle Kotlin DSL. The details are provided &lt;a href=&quot;#using-gradle-kotlin-dsl&quot;&gt;below&lt;/a&gt;.</source>
          <target state="translated">Gradle Kotlin DSLの &lt;code&gt;apply&lt;/code&gt; でKotlinプラグインを適用することはお勧めしません。詳細は&lt;a href=&quot;#using-gradle-kotlin-dsl&quot;&gt;以下のとおり&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="903ee30ab34cc6304b069dd5e5dba6a6e65093d1" translate="yes" xml:space="preserve">
          <source>It's often the case that we need to copy an object altering &lt;em&gt;some&lt;/em&gt; of its properties, but keeping the rest unchanged. This is what &lt;code&gt;copy()&lt;/code&gt; function is generated for. For the &lt;code&gt;User&lt;/code&gt; class above, its implementation would be as follows:</source>
          <target state="translated">多くの場合、オブジェクトの&lt;em&gt;一部&lt;/em&gt;のプロパティを変更しながらオブジェクトをコピーする必要がありますが、残りは変更しません。これが &lt;code&gt;copy()&lt;/code&gt; 関数の生成対象です。上記の &lt;code&gt;User&lt;/code&gt; クラスの場合、その実装は次のようになります。</target>
        </trans-unit>
        <trans-unit id="f5bc060842af3a7b6e0d01c24d0becf2bb7a201f" translate="yes" xml:space="preserve">
          <source>It's possible to declare a cinterop dependency for a component:</source>
          <target state="translated">コンポーネントのcinterop依存関係を宣言することができます。</target>
        </trans-unit>
        <trans-unit id="2884706f64f3c6fe7682c1d6d6493a0cd7c7c71d" translate="yes" xml:space="preserve">
          <source>It's possible to depend on a Kotlin/Native library published earlier in a maven repo. The plugin relies on Gradle's &lt;a href=&quot;https://github.com/gradle/gradle/blob/master/subprojects/docs/src/docs/design/gradle-module-metadata-specification.md&quot;&gt;metadata&lt;/a&gt; support so the corresponding feature must be enabled. Add the following line in your &lt;code&gt;settings.gradle&lt;/code&gt;:</source>
          <target state="translated">Mavenリポジトリで以前に公開されたKotlin /ネイティブライブラリに依存することは可能です。プラグインはGradleの&lt;a href=&quot;https://github.com/gradle/gradle/blob/master/subprojects/docs/src/docs/design/gradle-module-metadata-specification.md&quot;&gt;メタデータ&lt;/a&gt;サポートに依存しているため、対応する機能を有効にする必要があります。 &lt;code&gt;settings.gradle&lt;/code&gt; に次の行を追加します。</target>
        </trans-unit>
        <trans-unit id="c597ff748c96d1169a0e3b1f389a9e5bf8a14509" translate="yes" xml:space="preserve">
          <source>It's recommended that you use Android Studio for creating Android applications. &lt;a href=&quot;https://developer.android.com/studio/releases/gradle-plugin&quot;&gt;Learn how to use Android Gradle plugin&lt;/a&gt;.</source>
          <target state="translated">Androidアプリケーションの作成にはAndroidStudioを使用することをお勧めします。&lt;a href=&quot;https://developer.android.com/studio/releases/gradle-plugin&quot;&gt;AndroidGradleプラグインの使用方法を学びます&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="268bb3f4ba30e1a5b60f8f81ac29d4c03ccdf710" translate="yes" xml:space="preserve">
          <source>It's recommended to propagate the experimental status to the API that depends on unsigned types by annotating it with this annotation.</source>
          <target state="translated">符号なし型に依存するAPIにこのアノテーションを付けることで、実験的な状態を伝播させることが推奨されています。</target>
        </trans-unit>
        <trans-unit id="d7daa3cad985a04d515f5a0b14e8155b1a6fab3e" translate="yes" xml:space="preserve">
          <source>It's up to you to decide if your clients have to explicitly opt-in into usage of your API, but bear in mind that unsigned types are an experimental feature, so API which uses them can be suddenly broken due to changes in language.</source>
          <target state="translated">クライアントが明示的にAPIの利用をオプトインするかどうかはあなた次第ですが、符号なし型は実験的な機能であり、言語の変更によってそれらを使用するAPIが突然壊れてしまう可能性があることを覚えておいてください。</target>
        </trans-unit>
        <trans-unit id="da8e68f5b23a3014c6d8de49b6e15eb047b18c62" translate="yes" xml:space="preserve">
          <source>It's up to you to decide if your clients have to explicitly opt-in into usage of your API, but bear in mind that unsigned types are not a stable feature, so API which uses them can be broken by changes in the language.</source>
          <target state="translated">クライアントが明示的にオプトインしてAPIを使用するかどうかはあなた次第ですが、符号なし型は安定した機能ではないことに留意してください。</target>
        </trans-unit>
        <trans-unit id="9fa67b0c21d7b8170095650619f367328af7593f" translate="yes" xml:space="preserve">
          <source>It's useful to shorten long generic types. For instance, it's often tempting to shrink collection types:</source>
          <target state="translated">長い汎用型を短縮するのは便利です。例えば、コレクション型を縮小したくなることがよくあります。</target>
        </trans-unit>
        <trans-unit id="d50dbfd39b435235eb76a4c86249fda694136067" translate="yes" xml:space="preserve">
          <source>It's very common that a lambda expression has only one parameter.</source>
          <target state="translated">ラムダ式のパラメータが1つしかないことはよくあることです。</target>
        </trans-unit>
        <trans-unit id="497cb9444d2d1993508a971a9e38bf60f29788e9" translate="yes" xml:space="preserve">
          <source>ItemArrayLike</source>
          <target state="translated">ItemArrayLike</target>
        </trans-unit>
        <trans-unit id="08ca6a3da933ca6826a2f4d3fcc919af71d7e380" translate="yes" xml:space="preserve">
          <source>Iterable</source>
          <target state="translated">Iterable</target>
        </trans-unit>
        <trans-unit id="dc8802d44941c46da0da729594bb50e6d441ce2d" translate="yes" xml:space="preserve">
          <source>Iterable.groupingBy</source>
          <target state="translated">Iterable.groupingBy</target>
        </trans-unit>
        <trans-unit id="380a211ab0a9e218f328f8421df21a0f64a31d3e" translate="yes" xml:space="preserve">
          <source>Iterates through each line of this reader, calls &lt;a href=&quot;for-each-line#kotlin.io%24forEachLine%28java.io.Reader%2C+kotlin.Function1%28%28kotlin.String%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;action&lt;/a&gt; for each line read and closes the &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/io/Reader.html&quot;&gt;Reader&lt;/a&gt; when it's completed.</source>
          <target state="translated">このリーダーの各行を反復処理し、読み込まれた各行の&lt;a href=&quot;for-each-line#kotlin.io%24forEachLine%28java.io.Reader%2C+kotlin.Function1%28%28kotlin.String%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;アクション&lt;/a&gt;を呼び出し、完了したら&lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/io/Reader.html&quot;&gt;リーダー&lt;/a&gt;を閉じます。</target>
        </trans-unit>
        <trans-unit id="a23c7a347a61820ec903389403c010444ab83c86" translate="yes" xml:space="preserve">
          <source>Iterates through each line of this reader, calls &lt;a href=&quot;for-each-line#kotlin.io%24forEachLine(java.io.Reader,%20kotlin.Function1((kotlin.String,%20kotlin.Unit)))/action&quot;&gt;action&lt;/a&gt; for each line read and closes the &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/io/Reader.html&quot;&gt;Reader&lt;/a&gt; when it's completed.</source>
          <target state="translated">このリーダーの各行を繰り返し処理し、読み取った各行に対して&lt;a href=&quot;for-each-line#kotlin.io%24forEachLine(java.io.Reader,%20kotlin.Function1((kotlin.String,%20kotlin.Unit)))/action&quot;&gt;アクション&lt;/a&gt;を呼び出し、&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/io/Reader.html&quot;&gt;リーダー&lt;/a&gt;が完了すると閉じます。</target>
        </trans-unit>
        <trans-unit id="df79ba3f92580a38aac3b295d97ec6467bf9c601" translate="yes" xml:space="preserve">
          <source>Iterating over a collection:</source>
          <target state="translated">コレクションを反復処理します。</target>
        </trans-unit>
        <trans-unit id="cd542426f011094d421bd238597459f01a78a773" translate="yes" xml:space="preserve">
          <source>Iterating over a range:</source>
          <target state="translated">範囲を反復していく。</target>
        </trans-unit>
        <trans-unit id="bae8809b2429231a50c28ba87cecc038aac88855" translate="yes" xml:space="preserve">
          <source>Iterator</source>
          <target state="translated">Iterator</target>
        </trans-unit>
        <trans-unit id="003d5d89ff75536e7c8fe75998f6c431dc6a6bfb" translate="yes" xml:space="preserve">
          <source>Iterator for characters of the given char sequence.</source>
          <target state="translated">指定した文字列の文字のイテレータ。</target>
        </trans-unit>
        <trans-unit id="909a5f0dfd8c3a4ef79cd1458e2b5fb136ad7fae" translate="yes" xml:space="preserve">
          <source>Iterators</source>
          <target state="translated">Iterators</target>
        </trans-unit>
        <trans-unit id="506c9ecd5cb52c951984866e4ca884bba6f6ea5f" translate="yes" xml:space="preserve">
          <source>Iterators can be obtained for inheritors of the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-iterable/index&quot;&gt;&lt;code&gt;Iterable&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; interface, including &lt;code&gt;Set&lt;/code&gt; and &lt;code&gt;List&lt;/code&gt;, by calling the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-iterable/iterator&quot;&gt;&lt;code&gt;iterator()&lt;/code&gt;&lt;/a&gt; function. Once you obtain an iterator, it points to the first element of a collection; calling the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-iterator/next&quot;&gt;&lt;code&gt;next()&lt;/code&gt;&lt;/a&gt; function returns this element and moves the iterator position to the following element if it exists. Once the iterator passes through the last element, it can no longer be used for retrieving elements; neither can it be reset to any previous position. To iterate through the collection again, create a new iterator.</source>
          <target state="translated">イテレータは、&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-iterable/iterator&quot;&gt; &lt;code&gt;iterator()&lt;/code&gt; &lt;/a&gt;関数を呼び出すことで、 &lt;code&gt;Set&lt;/code&gt; や &lt;code&gt;List&lt;/code&gt; を含む&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-iterable/index&quot;&gt; &lt;code&gt;Iterable&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;インターフェースの継承のために取得できます。イテレータを取得すると、それはコレクションの最初の要素を指します。&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-iterator/next&quot;&gt; &lt;code&gt;next()&lt;/code&gt; &lt;/a&gt;関数を呼び出すと、この要素が返され、イテレータの位置が存在する場合は次の要素に移動します。イテレータが最後の要素を通過すると、要素を取得するために使用できなくなります。また、以前の位置にリセットすることもできません。コレクションを繰り返し処理するには、新しいイテレータを作成します。</target>
        </trans-unit>
        <trans-unit id="bc0b40497b63bea004394bd2f67e443f08b6588f" translate="yes" xml:space="preserve">
          <source>JAR file for the Android project, from the &lt;code&gt;androidMain&lt;/code&gt; source set</source>
          <target state="translated">&lt;code&gt;androidMain&lt;/code&gt; ソースセットからのAndroidプロジェクトのJARファイル</target>
        </trans-unit>
        <trans-unit id="1c094e3ab7a1c494d642222b6728398ff3000b42" translate="yes" xml:space="preserve">
          <source>JPA support</source>
          <target state="translated">JPA支援</target>
        </trans-unit>
        <trans-unit id="95f92b2f0cb530542d16d90a6c2af59e20759430" translate="yes" xml:space="preserve">
          <source>JS</source>
          <target state="translated">JS</target>
        </trans-unit>
        <trans-unit id="2ef44ba04cb41365765eba178e5fb528ee006a1b" translate="yes" xml:space="preserve">
          <source>JS:</source>
          <target state="translated">JS:</target>
        </trans-unit>
        <trans-unit id="031a4e76f0b39d0df073d934da5fc48da8d737e5" translate="yes" xml:space="preserve">
          <source>JSON</source>
          <target state="translated">JSON</target>
        </trans-unit>
        <trans-unit id="8262ef9c2c68924dbec9b88761bde41ad5ef98f3" translate="yes" xml:space="preserve">
          <source>JSR-305 (&lt;code&gt;javax.annotation&lt;/code&gt;, more details below)</source>
          <target state="translated">JSR-305（ &lt;code&gt;javax.annotation&lt;/code&gt; 、詳細は以下）</target>
        </trans-unit>
        <trans-unit id="5188151af5277b4d83b75fa70a7e55c37a18f211" translate="yes" xml:space="preserve">
          <source>JSR-305 Support</source>
          <target state="translated">JSR-305 サポート</target>
        </trans-unit>
        <trans-unit id="bb63c86538bf1c2ee7cd6190cf88dd1f44d85eff" translate="yes" xml:space="preserve">
          <source>JVM</source>
          <target state="translated">JVM</target>
        </trans-unit>
        <trans-unit id="04a7d3f3683303c17ad132f382f6d0c911d30883" translate="yes" xml:space="preserve">
          <source>JVM 6</source>
          <target state="translated">JVM 6</target>
        </trans-unit>
        <trans-unit id="3430f69443094c1010f905be31e657db1bc9cecc" translate="yes" xml:space="preserve">
          <source>JVM Backend</source>
          <target state="translated">JVMバックエンド</target>
        </trans-unit>
        <trans-unit id="8a60d58cc6c328ec0b68627b45e8de68d5004fb4" translate="yes" xml:space="preserve">
          <source>JVM backend</source>
          <target state="translated">JVMバックエンド</target>
        </trans-unit>
        <trans-unit id="e314b08890e867b0e66c9aacb3731e2c760fd4e5" translate="yes" xml:space="preserve">
          <source>JVM dependency</source>
          <target state="translated">JVM依存性</target>
        </trans-unit>
        <trans-unit id="1e479037f37f3056da4dd3f4b8476891324342ba" translate="yes" xml:space="preserve">
          <source>JVM:</source>
          <target state="translated">JVM:</target>
        </trans-unit>
        <trans-unit id="4aa2729d3292a207da300462e1c7fb9e07fee8d1" translate="yes" xml:space="preserve">
          <source>Jar file</source>
          <target state="translated">ジャーファイル</target>
        </trans-unit>
        <trans-unit id="c32dbe67bb4cda6c969b9b214ff6e46a25b2a0f2" translate="yes" xml:space="preserve">
          <source>Java 7's try with resources</source>
          <target state="translated">リソースを使ったJava 7の試み</target>
        </trans-unit>
        <trans-unit id="ac187b2b88eb97c8a6d1b499783f3187c6ec8c0b" translate="yes" xml:space="preserve">
          <source>Java 8 bytecode support</source>
          <target state="translated">Java 8 バイトコードサポート</target>
        </trans-unit>
        <trans-unit id="072e6f9a3196506ae761b516738d856e34828cc7" translate="yes" xml:space="preserve">
          <source>Java 8 standard library support</source>
          <target state="translated">Java 8 標準ライブラリのサポート</target>
        </trans-unit>
        <trans-unit id="01579d0353cd60180076cc09ff0d55781e923e55" translate="yes" xml:space="preserve">
          <source>Java Annotations</source>
          <target state="translated">Java アノテーション</target>
        </trans-unit>
        <trans-unit id="d04e5ac8f8fe9912f7302d2d4689867b318a2094" translate="yes" xml:space="preserve">
          <source>Java Arrays</source>
          <target state="translated">Java 配列</target>
        </trans-unit>
        <trans-unit id="860970d26c3938762fa2e2c7b7194b61a0231169" translate="yes" xml:space="preserve">
          <source>Java EE Http servlets can be used from Kotlin much like any other Java library or framework. We'll see how to make a simple controller that returns &quot;Hello, World!&quot;.</source>
          <target state="translated">Java EE Httpサーブレットは、他のJavaライブラリやフレームワークと同様にKotlinから使用することができます。Hello,World!&quot;を返すシンプルなコントローラを作る方法を見てみましょう。</target>
        </trans-unit>
        <trans-unit id="98c55e3f9693daef863846ba04beb7a87639d58b" translate="yes" xml:space="preserve">
          <source>Java Interoperability</source>
          <target state="translated">ジャバ相互運用性</target>
        </trans-unit>
        <trans-unit id="ab55871eec7aba9e50581782c94506d7b076be92" translate="yes" xml:space="preserve">
          <source>Java Reflection</source>
          <target state="translated">Java リフレクション</target>
        </trans-unit>
        <trans-unit id="8b7c04d9bb7da5a0513e73469be371a892a0ddec" translate="yes" xml:space="preserve">
          <source>Java Support in JVM Targets</source>
          <target state="translated">JVMターゲットでのJavaサポート</target>
        </trans-unit>
        <trans-unit id="027f8a4631110b77b693f662b6d14564e95f3ad5" translate="yes" xml:space="preserve">
          <source>Java Varargs</source>
          <target state="translated">Java Varargs</target>
        </trans-unit>
        <trans-unit id="746c982d879f15c37e1edb8014f7e0a7a57db534" translate="yes" xml:space="preserve">
          <source>Java annotations are 100% compatible with Kotlin:</source>
          <target state="translated">JavaアノテーションはKotlinと100%互換性があります。</target>
        </trans-unit>
        <trans-unit id="85a2157de6f31be86d225df11c21c07e4164424b" translate="yes" xml:space="preserve">
          <source>Java classes sometimes use a method declaration for the indices with a variable number of arguments (varargs):</source>
          <target state="translated">Javaのクラスは、可変数の引数(varargs)を持つインデックスのメソッド宣言を使用することがあります。</target>
        </trans-unit>
        <trans-unit id="695cb4693d8f07873088e0e2ca1954a3e6b1dec0" translate="yes" xml:space="preserve">
          <source>Java compiler options</source>
          <target state="translated">Java コンパイラオプション</target>
        </trans-unit>
        <trans-unit id="53d9a40a89e185b3910817fb0920db3433576443" translate="yes" xml:space="preserve">
          <source>Java generics in Kotlin</source>
          <target state="translated">Kotlin での Java ジェネリック</target>
        </trans-unit>
        <trans-unit id="8de44c9537e6dbc55b9f15952d2d0c0a403f924d" translate="yes" xml:space="preserve">
          <source>Java interoperation:</source>
          <target state="translated">Javaの相互運用。</target>
        </trans-unit>
        <trans-unit id="e832e4cfea4d9817c729a744a89f9449a5f1d1ee" translate="yes" xml:space="preserve">
          <source>Java only got support for function types and lambda expressions a few years ago. Previously, Java worked around this by using an interface to define a function signature and allowing an inline, anonymous definition of a class that implements the interface. This is also available in Kotlin, partly for compatibility with Java libraries and partly because it can be handy for specifying event handlers (in particular if there is more than one event type that must be listened for by the same listener object). Consider an interface or a (possibly abstract) class, as well a function that takes an instance of it:</source>
          <target state="translated">Javaが関数型とラムダ式をサポートしたのは数年前のことです。以前のJavaでは、関数のシグネチャを定義するためにインターフェイスを使用し、インターフェイスを実装したクラスをインラインで匿名で定義できるようにすることで、この問題を回避していました。これはKotlinでも利用できます。これはJavaライブラリとの互換性のためと、イベントハンドラを指定するのに便利だからです(特に、同じリスナーオブジェクトでリッスンしなければならないイベントタイプが複数ある場合)。インターフェースや(抽象的な)クラス、そしてそのインスタンスを受け取る関数を考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="1915d97968b458264a2f2dbd19e10237488a0c18" translate="yes" xml:space="preserve">
          <source>Java reflection works on Kotlin classes and vice versa. As mentioned above, you can use &lt;code&gt;instance::class.java&lt;/code&gt;, &lt;code&gt;ClassName::class.java&lt;/code&gt; or &lt;code&gt;instance.javaClass&lt;/code&gt; to enter Java reflection through &lt;code&gt;java.lang.Class&lt;/code&gt;.</source>
          <target state="translated">JavaリフレクションはKotlinクラスで動作し、その逆も同様です。上記のように、 &lt;code&gt;instance::class.java&lt;/code&gt; 、 &lt;code&gt;ClassName::class.java&lt;/code&gt; または &lt;code&gt;instance.javaClass&lt;/code&gt; を使用して、 &lt;code&gt;java.lang.Class&lt;/code&gt; を通じてJavaリフレクションに入ることができます。</target>
        </trans-unit>
        <trans-unit id="ef56a24f4d8f2d665c8315a53a8f2125506c9068" translate="yes" xml:space="preserve">
          <source>Java reflection works on Kotlin classes and vice versa. As mentioned above, you can use &lt;code&gt;instance::class.java&lt;/code&gt;, &lt;code&gt;ClassName::class.java&lt;/code&gt; or &lt;code&gt;instance.javaClass&lt;/code&gt; to enter Java reflection through &lt;code&gt;java.lang.Class&lt;/code&gt;. You may also use &lt;code&gt;ClassName::class.javaObjectType&lt;/code&gt; for getting primitive types wrappers.</source>
          <target state="translated">JavaリフレクションはKotlinクラスで機能し、その逆も同様です。上記のように、 &lt;code&gt;instance::class.java&lt;/code&gt; 、 &lt;code&gt;ClassName::class.java&lt;/code&gt; または &lt;code&gt;instance.javaClass&lt;/code&gt; を使用して、 &lt;code&gt;java.lang.Class&lt;/code&gt; を介してJavaリフレクションを入力できます。プリミティブ型のラッパーを取得するために &lt;code&gt;ClassName::class.javaObjectType&lt;/code&gt; を使用することもできます。</target>
        </trans-unit>
        <trans-unit id="604557100ea734a8e508b4cfcd3fd0b6ae0fffe3" translate="yes" xml:space="preserve">
          <source>Java types which have nullability annotations are represented not as platform types, but as actual nullable or non-null Kotlin types. The compiler supports several flavors of nullability annotations, including:</source>
          <target state="translated">nullabilityアノテーションを持つJavaの型は、プラットフォーム型としてではなく、実際のnullableまたはnon-nullのKotlin型として表現されます。コンパイラは、以下のようないくつかの種類のヌル可能性アノテーションをサポートしています。</target>
        </trans-unit>
        <trans-unit id="dc024086aaa20e53d67ca09758f8c4d13c64cb3c" translate="yes" xml:space="preserve">
          <source>Java's arrays are mapped as mentioned &lt;a href=&quot;java-interop#java-arrays&quot;&gt;below&lt;/a&gt;:</source>
          <target state="translated">Javaの配列は、次のようにマップされ&lt;a href=&quot;java-interop#java-arrays&quot;&gt;ます&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a52c0cfe5cac6860cf184e57dfda94c4e4aab7eb" translate="yes" xml:space="preserve">
          <source>Java's boxed primitive types are mapped to nullable Kotlin types:</source>
          <target state="translated">Javaの箱型プリミティブ型は、ヌル可能なKotlin型にマッピングされています。</target>
        </trans-unit>
        <trans-unit id="a93aa77d99dfed9f4e64393e47b4458e7232bba4" translate="yes" xml:space="preserve">
          <source>Java's raw types are converted into star projections,</source>
          <target state="translated">Javaの生の型は星の投影に変換されます。</target>
        </trans-unit>
        <trans-unit id="4b08bd53dd6ccc40659e0ead9c100bf1e91b5ac6" translate="yes" xml:space="preserve">
          <source>Java's wildcards are converted into type projections,</source>
          <target state="translated">Javaのワイルドカードは型投影に変換されます。</target>
        </trans-unit>
        <trans-unit id="b7e0008cfda3632a9ce80870d8378b5ff1ce2de5" translate="yes" xml:space="preserve">
          <source>Java-default method calls</source>
          <target state="translated">ジャワデフォルトメソッド呼び出し</target>
        </trans-unit>
        <trans-unit id="28658a9e65ac1fce8b895da9099268ad9257b5a4" translate="yes" xml:space="preserve">
          <source>Java-style reflection</source>
          <target state="translated">ジャバ式反射</target>
        </trans-unit>
        <trans-unit id="d3d2902f267714c4d2888df7a9cb53494548b955" translate="yes" xml:space="preserve">
          <source>Java2Kotlin converter</source>
          <target state="translated">ジャワツーコトリンコンバータ</target>
        </trans-unit>
        <trans-unit id="ee620923ff5fc510555dc37083a135ee93b5404b" translate="yes" xml:space="preserve">
          <source>JavaScript</source>
          <target state="translated">JavaScript</target>
        </trans-unit>
        <trans-unit id="cb598ee02a2a4ba66a8b8c49bee0bba3cd995db7" translate="yes" xml:space="preserve">
          <source>JavaScript Backend</source>
          <target state="translated">JavaScriptバックエンド</target>
        </trans-unit>
        <trans-unit id="7ceba75ee976f8baf2462d625f66425dd948bcef" translate="yes" xml:space="preserve">
          <source>JavaScript DCE</source>
          <target state="translated">JavaScript DCE</target>
        </trans-unit>
        <trans-unit id="1731268deeec6a5538ea96e67d2bad77e86644c6" translate="yes" xml:space="preserve">
          <source>JavaScript Dead Code Elimination (DCE)</source>
          <target state="translated">JavaScriptデッドコード排除(DCE</target>
        </trans-unit>
        <trans-unit id="b3f888694954b41c7c2070331437408d8501d710" translate="yes" xml:space="preserve">
          <source>JavaScript Modules</source>
          <target state="translated">JavaScriptモジュール</target>
        </trans-unit>
        <trans-unit id="8c784f817b830f35e8d38eb1b5afb3d6e6b36d02" translate="yes" xml:space="preserve">
          <source>JavaScript Reflection</source>
          <target state="translated">JavaScript リフレクション</target>
        </trans-unit>
        <trans-unit id="6427edfd3be2acf2cb18120ef89fe67414e7fe92" translate="yes" xml:space="preserve">
          <source>JavaScript backend</source>
          <target state="translated">JavaScriptバックエンド</target>
        </trans-unit>
        <trans-unit id="21bc6187f833ae0234195b5bb7f032fa9c9eddf3" translate="yes" xml:space="preserve">
          <source>JavaScript backend now generates more statically checkable code, which is friendlier to JS code processing tools, like minifiers, optimisers, linters, etc.</source>
          <target state="translated">JavaScriptバックエンドは、より静的にチェック可能なコードを生成するようになり、ミニファイア、オプティマイザ、リンタなどのJSコード処理ツールとの親和性が向上しました。</target>
        </trans-unit>
        <trans-unit id="18040e1d6c0077c2a62cb7d49ff581501d95859d" translate="yes" xml:space="preserve">
          <source>JavaScript does not have concept of packages (namespaces). They are usually emulated by nested objects. The compiler turns references to &lt;code&gt;external&lt;/code&gt; declarations either to plain unprefixed names (in case of &lt;em&gt;plain&lt;/em&gt; modules) or to plain imports. However, if a JavaScript library provides its declarations in packages, you won't be satisfied with this. You can tell the compiler to generate additional prefix before references to &lt;code&gt;external&lt;/code&gt; declarations using the &lt;code&gt;@JsQualifier(...)&lt;/code&gt; annotation.</source>
          <target state="translated">JavaScriptには、パッケージ（名前空間）の概念はありません。これらは通常、ネストされたオブジェクトによってエミュレートされます。コンパイラーは、 &lt;code&gt;external&lt;/code&gt; 宣言への参照を、プレフィックスのないプレフィックス名（&lt;em&gt;プレーンな&lt;/em&gt;モジュールの場合）またはプレーンなインポートに変換します。ただし、JavaScriptライブラリがその宣言をパッケージで提供する場合は、これで満足できません。 &lt;code&gt;@JsQualifier(...)&lt;/code&gt; アノテーションを使用して、 &lt;code&gt;external&lt;/code&gt; 宣言を参照する前に追加のプレフィックスを生成するようにコンパイラーに指示できます。</target>
        </trans-unit>
        <trans-unit id="95802660178652b3cea0422eb5403bb445448c4c" translate="yes" xml:space="preserve">
          <source>JavaScript does not have the concept of interfaces. When a function expects its parameter to support &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;bar&lt;/code&gt; methods, you just pass objects that actually have these methods. You can use interfaces to express this for statically-typed Kotlin, for example:</source>
          <target state="translated">JavaScriptにはインターフェースの概念はありません。関数がそのパラメーターが &lt;code&gt;foo&lt;/code&gt; および &lt;code&gt;bar&lt;/code&gt; メソッドをサポートすることを期待する場合、実際にこれらのメソッドを持つオブジェクトを渡すだけです。インターフェースを使用して、静的に型付けされたKotlinに対してこれを表現できます。次に例を示します。</target>
        </trans-unit>
        <trans-unit id="db533d2ccc039c3271e49d0037285a95132804d3" translate="yes" xml:space="preserve">
          <source>JavaScript does not have the concept of interfaces. When a function expects its parameter to support two methods &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;bar&lt;/code&gt;, you would just pass in an object that actually has these methods.</source>
          <target state="translated">JavaScriptにはインターフェースの概念がありません。関数がそのパラメーターが2つのメソッド &lt;code&gt;foo&lt;/code&gt; と &lt;code&gt;bar&lt;/code&gt; をサポートすることを期待している場合、実際にこれらのメソッドを持つオブジェクトを渡すだけです。</target>
        </trans-unit>
        <trans-unit id="fffb2c94a89ef37f4ff800dd4f2f3274e7b4c9bf" translate="yes" xml:space="preserve">
          <source>JetBrains develops and maintains several tools specifically for the React community: &lt;a href=&quot;https://github.com/JetBrains/kotlin-wrappers&quot;&gt;React bindings&lt;/a&gt; as well as &lt;a href=&quot;https://github.com/JetBrains/create-react-kotlin-app&quot;&gt;Create React Kotlin App&lt;/a&gt;. The latter helps you start building React apps with Kotlin with no build configuration.</source>
          <target state="translated">JetBrainsは、Reactコミュニティ専用のいくつかのツールを開発および保守しています&lt;a href=&quot;https://github.com/JetBrains/kotlin-wrappers&quot;&gt;。Reactバインディング&lt;/a&gt;と&lt;a href=&quot;https://github.com/JetBrains/create-react-kotlin-app&quot;&gt;Create React Kotlinアプリ&lt;/a&gt;です。後者は、ビルド構成のないKotlinでReactアプリのビルドを開始するのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="0afbb0e9a99e99277b2f49549fedbc94a32802c2" translate="yes" xml:space="preserve">
          <source>Job in the context</source>
          <target state="translated">文脈の中での仕事</target>
        </trans-unit>
        <trans-unit id="06c75c90e1e9379a2cdd628513a60c328e9a2837" translate="yes" xml:space="preserve">
          <source>Join the Kotlin/JS community</source>
          <target state="translated">Kotlin/JSコミュニティに参加する</target>
        </trans-unit>
        <trans-unit id="4f050b9ce8a72499f6d4325b437a4f8f851d64df" translate="yes" xml:space="preserve">
          <source>Join us to continue exploring the C language types and their representation in Kotlin/Native in the related tutorials:</source>
          <target state="translated">Kotlin/Native での C 言語の型とその表現について、関連するチュートリアルに参加してみませんか?</target>
        </trans-unit>
        <trans-unit id="560f658735b552460323d7d08486e67939d8b69b" translate="yes" xml:space="preserve">
          <source>Joining a course</source>
          <target state="translated">コースに参加する</target>
        </trans-unit>
        <trans-unit id="e14bf41ef01fdef5cf6b52dd5564ec2b2886f811" translate="yes" xml:space="preserve">
          <source>Joshua Bloch calls those objects you only &lt;strong&gt;read&lt;/strong&gt; from &lt;strong&gt;Producers&lt;/strong&gt;, and those you only &lt;strong&gt;write&lt;/strong&gt; to &lt;strong&gt;Consumers&lt;/strong&gt;. He recommends: &quot;&lt;em&gt;For maximum flexibility, use wildcard types on input parameters that represent producers or consumers&lt;/em&gt;&quot;, and proposes the following mnemonic:</source>
          <target state="translated">ジョシュア・ブロックは、それらを使用すると、オブジェクトのみ呼び出す&lt;strong&gt;読み&lt;/strong&gt;から&lt;strong&gt;生産&lt;/strong&gt;、そしてあなただけのものを&lt;strong&gt;書く&lt;/strong&gt;には&lt;strong&gt;消費者&lt;/strong&gt;。彼は、「&lt;em&gt;最大限の柔軟性を得るために、プロデューサーまたはコンシューマーを表す入力パラメーターでワイルドカードタイプを使用する&lt;/em&gt;」ことを推奨し、次のニーモニックを提案します。</target>
        </trans-unit>
        <trans-unit id="aaaf7cda9e752b334875dd3fb12220ae53318575" translate="yes" xml:space="preserve">
          <source>JsArray</source>
          <target state="translated">JsArray</target>
        </trans-unit>
        <trans-unit id="5cf2add42044a4a104180a92b4649ba344349b36" translate="yes" xml:space="preserve">
          <source>JsClass</source>
          <target state="translated">JsClass</target>
        </trans-unit>
        <trans-unit id="829d41f036e4b83f97d9207ff01e19270a103dc5" translate="yes" xml:space="preserve">
          <source>JsExport</source>
          <target state="translated">JsExport</target>
        </trans-unit>
        <trans-unit id="680d5016d394bd1910f8e79c1f48e1099ec8a45e" translate="yes" xml:space="preserve">
          <source>JsModule</source>
          <target state="translated">JsModule</target>
        </trans-unit>
        <trans-unit id="bb2ba9a64ec3ce618d8658d2bac2ab5b52799c41" translate="yes" xml:space="preserve">
          <source>JsName</source>
          <target state="translated">JsName</target>
        </trans-unit>
        <trans-unit id="285e217de7a6a19bb6ff3224730d97a2ffb8669c" translate="yes" xml:space="preserve">
          <source>JsNonModule</source>
          <target state="translated">JsNonModule</target>
        </trans-unit>
        <trans-unit id="4431c8a7c0e95318d4df4acc2fb68414f204013b" translate="yes" xml:space="preserve">
          <source>JsQualifier</source>
          <target state="translated">JsQualifier</target>
        </trans-unit>
        <trans-unit id="5e2ef85ac474ea70113e00f2d535adfcd131ef41" translate="yes" xml:space="preserve">
          <source>JsValue</source>
          <target state="translated">JsValue</target>
        </trans-unit>
        <trans-unit id="0e8b29f774aacb41aea9f3a3e3922bc27a5b2f86" translate="yes" xml:space="preserve">
          <source>Json</source>
          <target state="translated">Json</target>
        </trans-unit>
        <trans-unit id="ee67901393cc367dccd6b7380bc834e3173528f8" translate="yes" xml:space="preserve">
          <source>Jumping between threads</source>
          <target state="translated">スレッド間のジャンプ</target>
        </trans-unit>
        <trans-unit id="35e8c2b0fe924d03188fa9d13f85d320bcb98681" translate="yes" xml:space="preserve">
          <source>Just add the plugin JAR file to the compiler plugin classpath and specify the list of sam-with-receiver annotations:</source>
          <target state="translated">プラグイン JAR ファイルをコンパイラプラグインのクラスパスに追加し、sam-with-receiver アノテーションのリストを指定するだけです。</target>
        </trans-unit>
        <trans-unit id="23faffb10dc95518c4b08d2ccd86868a15d724ef" translate="yes" xml:space="preserve">
          <source>Just as in Java 8, Kotlin now allows to use underscores in numeric literals to separate groups of digits:</source>
          <target state="translated">Java 8と同様に、Kotlinでも数値リテラルの中でアンダースコアを使って数字のグループを区切ることができるようになりました。</target>
        </trans-unit>
        <trans-unit id="1d8e794cae8b9d9de103c8c7346fbf29e3d8b66f" translate="yes" xml:space="preserve">
          <source>Just like Java 8, Kotlin supports SAM conversions. This means that Kotlin function literals can be automatically converted into implementations of Java interfaces with a single non-default method, as long as the parameter types of the interface method match the parameter types of the Kotlin function.</source>
          <target state="translated">Java 8と同様に、KotlinはSAM変換をサポートしています。つまり、Kotlinの関数リテラルは、インターフェースメソッドのパラメータ型がKotlin関数のパラメータ型と一致する限り、デフォルトではない1つのメソッドでJavaインターフェースの実装に自動的に変換することができます。</target>
        </trans-unit>
        <trans-unit id="949a51b86664f4131dce0e0c1b95750468898210" translate="yes" xml:space="preserve">
          <source>Just like Java and JavaScript, Kotlin supports end-of-line and block comments.</source>
          <target state="translated">JavaやJavaScriptと同様に、Kotlinは行末コメントやブロックコメントをサポートしています。</target>
        </trans-unit>
        <trans-unit id="470dca02756a771de4224b1f3a4e099fc973e2f5" translate="yes" xml:space="preserve">
          <source>Just like Java's anonymous inner classes, code in object expressions can access variables from the enclosing scope. (Unlike Java, this is not restricted to final or effectively final variables.)</source>
          <target state="translated">Javaの匿名内部クラスと同様に、オブジェクト式のコードは、囲んだスコープから変数にアクセスすることができます。(Javaとは異なり、これは最終的な変数や事実上の最終的な変数には限定されません)。</target>
        </trans-unit>
        <trans-unit id="52bd785fc290723ed0a2f51dcda0df34f29bb395" translate="yes" xml:space="preserve">
          <source>Just like in Java, a special case is the &lt;code&gt;value&lt;/code&gt; parameter; its value can be specified without an explicit name:</source>
          <target state="translated">Javaと同様に、特殊なケースは &lt;code&gt;value&lt;/code&gt; パラメーターです。その値は明示的な名前なしで指定できます：</target>
        </trans-unit>
        <trans-unit id="56e17eda787fc8a6435c74f86b6d7baef2f4cc5c" translate="yes" xml:space="preserve">
          <source>Just like in Java, enum classes in Kotlin have synthetic methods allowing to list the defined enum constants and to get an enum constant by its name. The signatures of these methods are as follows (assuming the name of the enum class is &lt;code&gt;EnumClass&lt;/code&gt;):</source>
          <target state="translated">Javaと同じように、Kotlinの列挙型クラスには、定義済みの列挙型定数をリストし、その名前で列挙型定数を取得できる合成メソッドがあります。これらのメソッドのシグネチャは次のとおりです（列挙型クラスの名前が &lt;code&gt;EnumClass&lt;/code&gt; であると想定）。</target>
        </trans-unit>
        <trans-unit id="087fe94dcb6ae8bf0df1e1981129ddf1a93236a7" translate="yes" xml:space="preserve">
          <source>Just like most modern languages, Kotlin supports single-line (or &lt;em&gt;end-of-line&lt;/em&gt;) and multi-line (&lt;em&gt;block&lt;/em&gt;) comments.</source>
          <target state="translated">最新のほとんどの言語と同様に、Kotlinは単一行（または&lt;em&gt;行末&lt;/em&gt;）および複数行（&lt;em&gt;ブロック&lt;/em&gt;）コメントをサポートします。</target>
        </trans-unit>
        <trans-unit id="9137e7255bdeb308d1bb811a9d7f200fe163b672" translate="yes" xml:space="preserve">
          <source>Just like regular members of the companion object, they can be called using only the class name as the qualifier:</source>
          <target state="translated">コンパニオン・オブジェクトの通常のメンバと同様に、クラス名のみを修飾子として使用して呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="0848ea7d6dc0355eb57cb3d83744477db1fa4d97" translate="yes" xml:space="preserve">
          <source>Just like with JavaDoc, KDoc comments start with &lt;code&gt;/**&lt;/code&gt; and end with &lt;code&gt;*/&lt;/code&gt;. Every line of the comment may begin with an asterisk, which is not considered part of the contents of the comment.</source>
          <target state="translated">JavaDocと同様に、KDocコメントは &lt;code&gt;/**&lt;/code&gt; で始まり、 &lt;code&gt;*/&lt;/code&gt; で終わります。コメントのすべての行はアスタリスクで始まる場合がありますが、これはコメントの内容の一部とは見なされません。</target>
        </trans-unit>
        <trans-unit id="d4d2de8b4148383d16c153caa1ed915e8e3e98f8" translate="yes" xml:space="preserve">
          <source>JvmDefault</source>
          <target state="translated">JvmDefault</target>
        </trans-unit>
        <trans-unit id="8d8475b40c0c838717c002d3eb803f88fd28b448" translate="yes" xml:space="preserve">
          <source>JvmDefaultWithoutCompatibility</source>
          <target state="translated">JvmDefaultWithoutCompatibility</target>
        </trans-unit>
        <trans-unit id="692baf8c605cdd872f8ac1b51f0db35d878fa6ec" translate="yes" xml:space="preserve">
          <source>JvmField</source>
          <target state="translated">JvmField</target>
        </trans-unit>
        <trans-unit id="8cafb887c2be5267183d19409f4ac9f885353c0a" translate="yes" xml:space="preserve">
          <source>JvmMultifileClass</source>
          <target state="translated">JvmMultifileClass</target>
        </trans-unit>
        <trans-unit id="2033eae859b01f53e2d78af856c5c34461b71b90" translate="yes" xml:space="preserve">
          <source>JvmName</source>
          <target state="translated">JvmName</target>
        </trans-unit>
        <trans-unit id="311d71c3b3f54390c29adff749b3edbb6a494b4a" translate="yes" xml:space="preserve">
          <source>JvmOverloads</source>
          <target state="translated">JvmOverloads</target>
        </trans-unit>
        <trans-unit id="747778441d808007d459844a0415514317ff72b7" translate="yes" xml:space="preserve">
          <source>JvmStatic</source>
          <target state="translated">JvmStatic</target>
        </trans-unit>
        <trans-unit id="6bc8e12710c62fe36d0378462ee3b1c664cd3300" translate="yes" xml:space="preserve">
          <source>JvmSuppressWildcards</source>
          <target state="translated">JvmSuppressWildcards</target>
        </trans-unit>
        <trans-unit id="a351df29143ba3c04cf22dc294f311273bb9b60f" translate="yes" xml:space="preserve">
          <source>JvmSynthetic</source>
          <target state="translated">JvmSynthetic</target>
        </trans-unit>
        <trans-unit id="85e086e57dc0c9b8c2d108ccec8876b36768e9b7" translate="yes" xml:space="preserve">
          <source>JvmWildcard</source>
          <target state="translated">JvmWildcard</target>
        </trans-unit>
        <trans-unit id="269b4c8f67d4bef3fb8e55e7c16a561a21d1145a" translate="yes" xml:space="preserve">
          <source>KAnnotatedElement</source>
          <target state="translated">KAnnotatedElement</target>
        </trans-unit>
        <trans-unit id="2380c006605522b5d08a2ee817a1eaa70c3eee66" translate="yes" xml:space="preserve">
          <source>KCallable</source>
          <target state="translated">KCallable</target>
        </trans-unit>
        <trans-unit id="638ba738d7801f4caebfacfc6daada8a29efaa3c" translate="yes" xml:space="preserve">
          <source>KClass</source>
          <target state="translated">KClass</target>
        </trans-unit>
        <trans-unit id="fab281a5b19ac7d1db397f74e48d5b9b12cc8340" translate="yes" xml:space="preserve">
          <source>KClass.cast</source>
          <target state="translated">KClass.cast</target>
        </trans-unit>
        <trans-unit id="acf5de634c6435ff94d10fad8e77c31d4afdb216" translate="yes" xml:space="preserve">
          <source>KClass.isInstance</source>
          <target state="translated">KClass.isInstance</target>
        </trans-unit>
        <trans-unit id="0eb6eed766c7bf5a996d5d184bea9e1688094497" translate="yes" xml:space="preserve">
          <source>KClass.safeCast</source>
          <target state="translated">KClass.safeCast</target>
        </trans-unit>
        <trans-unit id="64fa1008f290c0ccc3cc7c6ea0be14a5730d8c96" translate="yes" xml:space="preserve">
          <source>KClassifier</source>
          <target state="translated">KClassifier</target>
        </trans-unit>
        <trans-unit id="79b222c243d152a61ff297964121af433061592b" translate="yes" xml:space="preserve">
          <source>KClassifier.createType</source>
          <target state="translated">KClassifier.createType</target>
        </trans-unit>
        <trans-unit id="20cb65ed76161cb0b2be5e7c93b9d81ef134450b" translate="yes" xml:space="preserve">
          <source>KDeclarationContainer</source>
          <target state="translated">KDeclarationContainer</target>
        </trans-unit>
        <trans-unit id="7bf1a6c1fa5dce180803fdb8c3400d5e981f7201" translate="yes" xml:space="preserve">
          <source>KDoc Syntax</source>
          <target state="translated">KDoc構文</target>
        </trans-unit>
        <trans-unit id="7d4c77574d0b857a214718597dca35a72ce59ec3" translate="yes" xml:space="preserve">
          <source>KDoc currently supports the following block tags:</source>
          <target state="translated">KDocは現在、以下のブロックタグをサポートしています。</target>
        </trans-unit>
        <trans-unit id="fae5be3a00cdb97c4b5aa9435d19be927a5665ba" translate="yes" xml:space="preserve">
          <source>KDoc does not support the &lt;code&gt;@deprecated&lt;/code&gt; tag. Instead, please use the &lt;code&gt;@Deprecated&lt;/code&gt; annotation.</source>
          <target state="translated">KDocは &lt;code&gt;@deprecated&lt;/code&gt; タグをサポートしていません。代わりに、 &lt;code&gt;@Deprecated&lt;/code&gt; アノテーションを使用してください。</target>
        </trans-unit>
        <trans-unit id="343a3fd44d3f90b682e5b8542c76a1c8f0dc43bf" translate="yes" xml:space="preserve">
          <source>KDoc syntax</source>
          <target state="translated">KDoc構文</target>
        </trans-unit>
        <trans-unit id="cf7f75d8adb5a4855b94e1806ea4b9da20753a2a" translate="yes" xml:space="preserve">
          <source>KFunction</source>
          <target state="translated">KFunction</target>
        </trans-unit>
        <trans-unit id="ed5e1b52600600ea74e498fffdc8c815085f7d28" translate="yes" xml:space="preserve">
          <source>KLib binaries</source>
          <target state="translated">KLibバイナリ</target>
        </trans-unit>
        <trans-unit id="351228c4e54d9346ab6c9f3124cf8905349ef3f6" translate="yes" xml:space="preserve">
          <source>KMutableProperty</source>
          <target state="translated">KMutableProperty</target>
        </trans-unit>
        <trans-unit id="b8079b1b2c0efc81f1810eda68de2b7cfe28211b" translate="yes" xml:space="preserve">
          <source>KMutableProperty0</source>
          <target state="translated">KMutableProperty0</target>
        </trans-unit>
        <trans-unit id="ee64a1ab548503607558b0ae24255a9fb8d1bf97" translate="yes" xml:space="preserve">
          <source>KMutableProperty1</source>
          <target state="translated">KMutableProperty1</target>
        </trans-unit>
        <trans-unit id="b5a2a8a013bdb0ae3b43fd0eedfa92a1c579f8b7" translate="yes" xml:space="preserve">
          <source>KMutableProperty2</source>
          <target state="translated">KMutableProperty2</target>
        </trans-unit>
        <trans-unit id="3b161212f1754e4e1f54c5dee3fdb112a6efcc79" translate="yes" xml:space="preserve">
          <source>KParameter</source>
          <target state="translated">KParameter</target>
        </trans-unit>
        <trans-unit id="47dc03443aa940939b9abccc2588997b2fd72705" translate="yes" xml:space="preserve">
          <source>KProperty</source>
          <target state="translated">KProperty</target>
        </trans-unit>
        <trans-unit id="7c65965ff00632a4a27df6d2ccf39af470a5196a" translate="yes" xml:space="preserve">
          <source>KProperty0</source>
          <target state="translated">KProperty0</target>
        </trans-unit>
        <trans-unit id="8baedb2820a644b389145928c1658d83b9918bc5" translate="yes" xml:space="preserve">
          <source>KProperty1</source>
          <target state="translated">KProperty1</target>
        </trans-unit>
        <trans-unit id="8bf91abab2e2266a64dcd908bc6e070ddbaf118e" translate="yes" xml:space="preserve">
          <source>KProperty1.getDelegate</source>
          <target state="translated">KProperty1.getDelegate</target>
        </trans-unit>
        <trans-unit id="d8609e0c5b369de4819d2e07e76fd6ed37986905" translate="yes" xml:space="preserve">
          <source>KProperty2</source>
          <target state="translated">KProperty2</target>
        </trans-unit>
        <trans-unit id="fd138efe2eefe64c683fdbac01b4ebe15e42c11f" translate="yes" xml:space="preserve">
          <source>KProperty2.getDelegate</source>
          <target state="translated">KProperty2.getDelegate</target>
        </trans-unit>
        <trans-unit id="cddedd34830292c250dc6df0c7292dd170403bdb" translate="yes" xml:space="preserve">
          <source>KType</source>
          <target state="translated">KType</target>
        </trans-unit>
        <trans-unit id="f3764cdd111b81b5f82e469014413398559a3a69" translate="yes" xml:space="preserve">
          <source>KTypeParameter</source>
          <target state="translated">KTypeParameter</target>
        </trans-unit>
        <trans-unit id="a52a8fe183ee882846ec18218986d60cbd8b9caa" translate="yes" xml:space="preserve">
          <source>KTypeParameter.variance</source>
          <target state="translated">KTypeParameter.variance</target>
        </trans-unit>
        <trans-unit id="541ac7b02574ef282f5fea0a7caa24f963767d58" translate="yes" xml:space="preserve">
          <source>KTypeProjection</source>
          <target state="translated">KTypeProjection</target>
        </trans-unit>
        <trans-unit id="453bbaf5b6df4218f396acb7d784d58647332cd3" translate="yes" xml:space="preserve">
          <source>KVariance</source>
          <target state="translated">KVariance</target>
        </trans-unit>
        <trans-unit id="540dc0ef81ec2a035fa8eb530610a94d10ceaf33" translate="yes" xml:space="preserve">
          <source>KVisibility</source>
          <target state="translated">KVisibility</target>
        </trans-unit>
        <trans-unit id="89ee95ab7caa6f00ebf6ba552593878d5c2b4d1a" translate="yes" xml:space="preserve">
          <source>Kapt can generate Kotlin sources. Just write the generated Kotlin source files to the directory specified by &lt;code&gt;processingEnv.options[&quot;kapt.kotlin.generated&quot;]&lt;/code&gt;, and these files will be compiled together with the main sources.</source>
          <target state="translated">KaptはKotlinソースを生成できます。生成されたKotlinソースファイルを &lt;code&gt;processingEnv.options[&quot;kapt.kotlin.generated&quot;]&lt;/code&gt; で指定されたディレクトリに書き込むだけで、これらのファイルがメインソースとともにコンパイルされます。</target>
        </trans-unit>
        <trans-unit id="115c000133ca0eeaa296737859925189dceee8bb" translate="yes" xml:space="preserve">
          <source>Kapt compiler plugin is available in the binary distribution of the Kotlin compiler.</source>
          <target state="translated">Kapt コンパイラプラグインは Kotlin コンパイラのバイナリディストリビューションで利用できます。</target>
        </trans-unit>
        <trans-unit id="d2790ed7723277b25aa2209903904a8c31657160" translate="yes" xml:space="preserve">
          <source>Kapt uses Java compiler to run annotation processors.</source>
          <target state="translated">Kaptはアノテーションプロセッサを実行するためにJavaコンパイラを使用しています。</target>
        </trans-unit>
        <trans-unit id="ec688ce3d89067940f46fd29a7ea54660b831823" translate="yes" xml:space="preserve">
          <source>Keep in mind that this is just syntactic sugar - you're not actually modifying the class or its instances. Therefore, you have to import an extension function/property wherever you want to use it (since it isn't carried along with the instances of the class). For the same reason, you can not override extension members - you can reimplement them for subtypes, but the resolution happens at compile-time based on the static type of the expression you're invoking it on. So if you declare an extension function for &lt;code&gt;Vehicle&lt;/code&gt;, and one with the same name and signature for its subclass &lt;code&gt;Car&lt;/code&gt;, and you do the following, it's the extension function on &lt;code&gt;Vehicle&lt;/code&gt; that will be called, even though &lt;code&gt;v&lt;/code&gt; is really a &lt;code&gt;Car&lt;/code&gt;:</source>
          <target state="translated">これは単なる構文上の砂糖であることを覚えておいてください。実際にクラスやそのインスタンスを変更するわけではありません。したがって、拡張関数/プロパティは、それを使用したい場所にインポートする必要があります（クラスのインスタンスと一緒に実行されないため）。同じ理由で、拡張メンバーをオーバーライドすることはできません。サブタイプ用に拡張メンバーを再実装できますが、解決は、呼び出している式の静的タイプに基づいてコンパイル時に行われます。したがって、 &lt;code&gt;Vehicle&lt;/code&gt; の拡張関数を宣言し、そのサブクラス &lt;code&gt;Car&lt;/code&gt; の名前とシグネチャが同じである関数を次のように宣言すると、 &lt;code&gt;v&lt;/code&gt; は実際には &lt;code&gt;Car&lt;/code&gt; ですが、呼び出されるのは &lt;code&gt;Vehicle&lt;/code&gt; の拡張関数です。</target>
        </trans-unit>
        <trans-unit id="18218cc9fd8c5aa995704dae391402dc208f9851" translate="yes" xml:space="preserve">
          <source>Keep the language modern over the years.</source>
          <target state="translated">何年もかけて言葉を現代的なものにしましょう。</target>
        </trans-unit>
        <trans-unit id="07ccea1c92ddb53422b1f7f7120a95adacb8fcf2" translate="yes" xml:space="preserve">
          <source>Keeping whole packages or modules from elimination can prevent DCE from removing many unused declarations. Because of this, it is preferable to select individual declarations which should be excluded from DCE one by one.</source>
          <target state="translated">パッケージやモジュール全体を除外しないようにしておくと、DCEから多くの未使用の宣言を除外することができなくなることがあります。このため、DCEから除外すべき個々の宣言を一つずつ選択することが望ましい。</target>
        </trans-unit>
        <trans-unit id="428b07e8e32e536ccaf4d9521cd95cadbf7fb10f" translate="yes" xml:space="preserve">
          <source>Keepsafe's App Lock app has also been &lt;a href=&quot;https://medium.com/keepsafe-engineering/lessons-from-converting-an-app-to-100-kotlin-68984a05dcb6&quot;&gt;converted to 100% Kotlin&lt;/a&gt;, leading to a 30% decrease in source line count and 10% decrease in method count.</source>
          <target state="translated">KeepsafeのApp Lockアプリも&lt;a href=&quot;https://medium.com/keepsafe-engineering/lessons-from-converting-an-app-to-100-kotlin-68984a05dcb6&quot;&gt;100％Kotlinに変換され&lt;/a&gt;、ソース行数が30％、メソッド数が10％減少しました。</target>
        </trans-unit>
        <trans-unit id="c67dd20ee842986086a0a915ddc2a279490130ed" translate="yes" xml:space="preserve">
          <source>Key</source>
          <target state="translated">Key</target>
        </trans-unit>
        <trans-unit id="4529f1f2ec7b60606af93bf0af48f282ccf9e92f" translate="yes" xml:space="preserve">
          <source>Key for the elements of &lt;a href=&quot;index&quot;&gt;CoroutineContext&lt;/a&gt;. &lt;a href=&quot;-key#E&quot;&gt;E&lt;/a&gt; is a type of element with this key.</source>
          <target state="translated">&lt;a href=&quot;index&quot;&gt;CoroutineContext&lt;/a&gt;の要素のキー。&lt;a href=&quot;-key#E&quot;&gt;E&lt;/a&gt;は、このキーを持つ要素のタイプです。</target>
        </trans-unit>
        <trans-unit id="14a72bb7f1422b3f859b664b3562ae101c3c66b5" translate="yes" xml:space="preserve">
          <source>Key for the elements of &lt;a href=&quot;index&quot;&gt;CoroutineContext&lt;/a&gt;. &lt;a href=&quot;-key#E&quot;&gt;E&lt;/a&gt; is a type of element with this key. Keys in the context are compared &lt;em&gt;by reference&lt;/em&gt;.</source>
          <target state="translated">&lt;a href=&quot;index&quot;&gt;CoroutineContext&lt;/a&gt;の要素のキー。&lt;a href=&quot;-key#E&quot;&gt;E&lt;/a&gt;は、このキーを持つ要素のタイプです。コンテキスト内のキーは&lt;em&gt;参照によって&lt;/em&gt;比較&lt;em&gt;されます&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="7dea00f8bb18a0d2f420e398a89ddb4931a962cc" translate="yes" xml:space="preserve">
          <source>KeyboardEventInit</source>
          <target state="translated">KeyboardEventInit</target>
        </trans-unit>
        <trans-unit id="12698e3202bea6e77c14cc7645aefe1f40b4a95b" translate="yes" xml:space="preserve">
          <source>Keywords and Operators</source>
          <target state="translated">キーワードと演算子</target>
        </trans-unit>
        <trans-unit id="e00ac23f2ac2ff73ad4f3c4b263d6c5bbfb80190" translate="yes" xml:space="preserve">
          <source>Kind</source>
          <target state="translated">Kind</target>
        </trans-unit>
        <trans-unit id="6d7060b8f0b142e9cc5d99251ae9bfc8344b5cdb" translate="yes" xml:space="preserve">
          <source>Kind of a module generated by compiler</source>
          <target state="translated">コンパイラで生成されるモジュールの種類</target>
        </trans-unit>
        <trans-unit id="1d34a603bd791899c80e1dbe11daaee6bb135493" translate="yes" xml:space="preserve">
          <source>Kind of this parameter.</source>
          <target state="translated">このパラメータの種類。</target>
        </trans-unit>
        <trans-unit id="b295237940a339c9b3b99ec9fc0619f9bc3cd8b9" translate="yes" xml:space="preserve">
          <source>Kind represents a particular position of the parameter declaration in the source code, such as an instance, an extension receiver parameter or a value parameter.</source>
          <target state="translated">種類は、インスタンス、拡張レシーバ・パラメータ、値パラメータなど、ソース・コード内のパラメータ宣言の特定の位置を表します。</target>
        </trans-unit>
        <trans-unit id="b05203cf89b60eb36609a1a8b7f3cafe0927486a" translate="yes" xml:space="preserve">
          <source>Known issues</source>
          <target state="translated">既知の問題</target>
        </trans-unit>
        <trans-unit id="7205eb983ba710302eb6c62f19abead98485f315" translate="yes" xml:space="preserve">
          <source>Koans</source>
          <target state="translated">Koans</target>
        </trans-unit>
        <trans-unit id="cff7933a49bb6d767f24e765c4887a762a5f9c00" translate="yes" xml:space="preserve">
          <source>Konan_js_getProperty</source>
          <target state="translated">Konan_js_getProperty</target>
        </trans-unit>
        <trans-unit id="4b97a1cc4cde2d848838f0605a552d5704eea24b" translate="yes" xml:space="preserve">
          <source>Kotlin</source>
          <target state="translated">Kotlin</target>
        </trans-unit>
        <trans-unit id="ce2c3a212ddf8e8e1152459e5ba603b0e8d0abe9" translate="yes" xml:space="preserve">
          <source>Kotlin 1.1 introduced coroutines, a new way of writing asynchronous, non-blocking code (and much more). In this tutorial we will go through some basics of using Kotlin coroutines with the help of the &lt;code&gt;kotlinx.coroutines&lt;/code&gt; library, which is a collection of helpers and wrappers for existing Java libraries.</source>
          <target state="translated">Kotlin 1.1はコルーチンを導入しました。これは、非同期の非ブロッキングコード（およびその他）を記述する新しい方法です。このチュートリアルでは、既存のJavaライブラリのヘルパーとラッパーのコレクションである &lt;code&gt;kotlinx.coroutines&lt;/code&gt; ライブラリを使用して、Kotlinコルーチンの基本的な使用方法をいくつか説明します。</target>
        </trans-unit>
        <trans-unit id="63575fcf9f53cf161b23b5a5120b649f923aec04" translate="yes" xml:space="preserve">
          <source>Kotlin 1.1 removes some of the restrictions on sealed and data classes that were present in Kotlin 1.0. Now you can define subclasses of a top-level sealed class on the top level in the same file, and not just as nested classes of the sealed class. Data classes can now extend other classes. This can be used to define a hierarchy of expression classes nicely and cleanly:</source>
          <target state="translated">Kotlin 1.1では、Kotlin 1.0にあった封印されたクラスとデータクラスに関する制限のいくつかが取り除かれました。トップレベルの封印されたクラスのサブクラスを、封印されたクラスのネストされたクラスとしてだけでなく、同じファイル内でトップレベルの封印されたクラスのサブクラスを定義できるようになりました。データクラスは他のクラスを拡張できるようになりました。これにより、式クラスの階層をきれいに定義することができます。</target>
        </trans-unit>
        <trans-unit id="4b689f1de0358fa8de1c1a96775c0c0ab1538fa5" translate="yes" xml:space="preserve">
          <source>Kotlin 1.2 introduces a set of functions for operating with &lt;code&gt;BigInteger&lt;/code&gt; and &lt;code&gt;BigDecimal&lt;/code&gt; and creating them from other numeric types. These are:</source>
          <target state="translated">Kotlin 1.2では、 &lt;code&gt;BigInteger&lt;/code&gt; と &lt;code&gt;BigDecimal&lt;/code&gt; を操作し、他の数値型から作成するための一連の関数が導入されています。これらは：</target>
        </trans-unit>
        <trans-unit id="f18db78c63aaf770b997189868cab88ccb0ebc9f" translate="yes" xml:space="preserve">
          <source>Kotlin 1.3 continues to evolve and improve scripting API, introducing some experimental support for scripts customization, such as adding external properties, providing static or dynamic dependencies, and so on.</source>
          <target state="translated">Kotlin 1.3 はスクリプト API の進化と改善を続けており、外部プロパティの追加、静的または動的な依存関係の提供など、スクリプトのカスタマイズのための実験的なサポートを導入しています。</target>
        </trans-unit>
        <trans-unit id="88e2adace5bac1e48c0adc9ef2ac271c679c842b" translate="yes" xml:space="preserve">
          <source>Kotlin 1.3 continues to improve and polish the Native target. See the &lt;a href=&quot;native-overview&quot;&gt;Kotlin/Native overview&lt;/a&gt; for details.</source>
          <target state="translated">Kotlin 1.3は、ネイティブターゲットの改善と改良を続けています。詳細については、&lt;a href=&quot;native-overview&quot;&gt;Kotlin /ネイティブの概要&lt;/a&gt;をご覧ください。</target>
        </trans-unit>
        <trans-unit id="fb394a79550e8145ec468f60617c81e553701477" translate="yes" xml:space="preserve">
          <source>Kotlin 1.3 introduced a simpler form of &lt;code&gt;main&lt;/code&gt; which takes no parameters. Now &amp;ldquo;Hello, World&amp;rdquo; in Kotlin is 19 characters shorter!</source>
          <target state="translated">Kotlin 1.3では、パラメーターを取らないシンプルな形式の &lt;code&gt;main&lt;/code&gt; が導入されました。Kotlinの「Hello、World」が19文字短くなりました。</target>
        </trans-unit>
        <trans-unit id="bfa732fa62960ffc201f7ae614e12c53ef901915" translate="yes" xml:space="preserve">
          <source>Kotlin 1.3 introduces a new kind of declaration &amp;mdash; &lt;code&gt;inline class&lt;/code&gt;. Inline classes can be viewed as a restricted version of the usual classes, in particular, inline classes must have exactly one property:</source>
          <target state="translated">Kotlin 1.3では、新しい種類の宣言である &lt;code&gt;inline class&lt;/code&gt; が導入されています。インラインクラスは、通常のクラスの制限されたバージョンと見なすことができます。特に、インラインクラスはプロパティを1つだけ持つ必要があります。</target>
        </trans-unit>
        <trans-unit id="32e23fcaa9e8679e7038c793f0f15c69e36b0fe8" translate="yes" xml:space="preserve">
          <source>Kotlin 1.3 introduces callable references on suspend-functions and support of Coroutines in the Reflection API.</source>
          <target state="translated">Kotlin 1.3 では、サスペンド関数の呼び出し可能な参照と Reflection API の Coroutines のサポートが導入されました。</target>
        </trans-unit>
        <trans-unit id="99e7bed5b89ef9affe2aabaa02c6b466182d4674" translate="yes" xml:space="preserve">
          <source>Kotlin 1.3 introduces support for runnable Kotlin &lt;em&gt;scratch files&lt;/em&gt;. &lt;em&gt;Scratch file&lt;/em&gt; is a kotlin script file with a .kts extension which you can run and get evaluation results directly in the editor.</source>
          <target state="translated">Kotlin 1.3では、実行可能なKotlin &lt;em&gt;スクラッチファイルの&lt;/em&gt;サポートが導入されてい&lt;em&gt;ます&lt;/em&gt;。&lt;em&gt;スクラッチファイル&lt;/em&gt;は、拡張子が.ktsのkotlinスクリプトファイルで、エディターで直接実行して評価結果を取得できます。</target>
        </trans-unit>
        <trans-unit id="62694aae6035c5ad4972f2e14bf03a63310cd91a" translate="yes" xml:space="preserve">
          <source>Kotlin 1.3 introduces support for the &lt;a href=&quot;coding-conventions&quot;&gt;recommended code style&lt;/a&gt; in the IDE. Check out &lt;a href=&quot;code-style-migration-guide&quot;&gt;this page&lt;/a&gt; for the migration guidelines.</source>
          <target state="translated">Kotlin 1.3では、IDEで&lt;a href=&quot;coding-conventions&quot;&gt;推奨されるコードスタイルの&lt;/a&gt;サポートが導入されています。チェックアウト&lt;a href=&quot;code-style-migration-guide&quot;&gt;このページを&lt;/a&gt;移行ガイドラインについて。</target>
        </trans-unit>
        <trans-unit id="dae614ce706dcca5f69b1c3253fcc5bc2a15bada" translate="yes" xml:space="preserve">
          <source>Kotlin 1.3 introduces unsigned integer types:</source>
          <target state="translated">Kotlin 1.3では符号なし整数型が導入されました。</target>
        </trans-unit>
        <trans-unit id="29c35fc143ca98d825aae2e4d6224d719799d607" translate="yes" xml:space="preserve">
          <source>Kotlin 1.3 relaxes this limitation and adds support for functions with bigger arity:</source>
          <target state="translated">Kotlin 1.3 ではこの制限が緩和され、より大きなアーティシティを持つ関数のサポートが追加されました。</target>
        </trans-unit>
        <trans-unit id="fab6809ce8d845633ec216cd46b20c0f5a989761" translate="yes" xml:space="preserve">
          <source>Kotlin &lt;code&gt;Any&lt;/code&gt; type</source>
          <target state="translated">Kotlin &lt;code&gt;Any&lt;/code&gt; タイプ</target>
        </trans-unit>
        <trans-unit id="1e0b4419e56e01f176b70724da2be7f1570af7d9" translate="yes" xml:space="preserve">
          <source>Kotlin &lt;code&gt;String&lt;/code&gt; type</source>
          <target state="translated">Kotlin &lt;code&gt;String&lt;/code&gt; 型</target>
        </trans-unit>
        <trans-unit id="e0c3f493c89be1b94503fdc3f47d5c69cab752c8" translate="yes" xml:space="preserve">
          <source>Kotlin &lt;code&gt;inline&lt;/code&gt; classes</source>
          <target state="translated">Kotlin &lt;code&gt;inline&lt;/code&gt; クラス</target>
        </trans-unit>
        <trans-unit id="c6f908927df8b995d9d09ec9bb214acf154074cf" translate="yes" xml:space="preserve">
          <source>Kotlin &lt;code&gt;interface&lt;/code&gt; types</source>
          <target state="translated">Kotlin &lt;code&gt;interface&lt;/code&gt; タイプ</target>
        </trans-unit>
        <trans-unit id="efe980e61f0d5167fc83d8f145a3ab77bfa2773d" translate="yes" xml:space="preserve">
          <source>Kotlin &lt;code&gt;object Object&lt;/code&gt; is accessible as &lt;code&gt;kotlin.root.example.Object&lt;/code&gt;. There is the &lt;code&gt;_instance&lt;/code&gt; function to get the only instance of the object.</source>
          <target state="translated">Kotlin &lt;code&gt;object Object&lt;/code&gt; は、 &lt;code&gt;kotlin.root.example.Object&lt;/code&gt; としてアクセスできます。オブジェクトの唯一のインスタンスを取得する &lt;code&gt;_instance&lt;/code&gt; 関数があります。</target>
        </trans-unit>
        <trans-unit id="0c1eb8d6dc73bce62ae72ba95f8c60b359816283" translate="yes" xml:space="preserve">
          <source>Kotlin Android Extensions</source>
          <target state="translated">Kotlin Android拡張機能</target>
        </trans-unit>
        <trans-unit id="7ffa31859972ce0a8778bfbe6687b81f154ab790" translate="yes" xml:space="preserve">
          <source>Kotlin Coding Conventions and IntelliJ IDEA formatter</source>
          <target state="translated">Kotlinコーディング規約とIntelliJ IDEAフォーマッタ</target>
        </trans-unit>
        <trans-unit id="d072d7cbb3d097a577aaa31d4b14236492b51583" translate="yes" xml:space="preserve">
          <source>Kotlin Collections Overview</source>
          <target state="translated">コトリンコレクションの概要</target>
        </trans-unit>
        <trans-unit id="e053b5d9a8bf9415ef3c2e418563c34aaf8713f7" translate="yes" xml:space="preserve">
          <source>Kotlin Define</source>
          <target state="translated">コトリンの定義</target>
        </trans-unit>
        <trans-unit id="f0cb9aff4685505b6e4d1a7786d44dbe9c5c78a7" translate="yes" xml:space="preserve">
          <source>Kotlin Educational Plugin</source>
          <target state="translated">Kotlin教育用プラグイン</target>
        </trans-unit>
        <trans-unit id="d2c2322d0e9d4d8a96800bd4df5ea6b0ed7d65ca" translate="yes" xml:space="preserve">
          <source>Kotlin Evolution</source>
          <target state="translated">コトリンの進化</target>
        </trans-unit>
        <trans-unit id="5cd6704a0bf9c9ca5663fc3e713188fc0c5a8b1c" translate="yes" xml:space="preserve">
          <source>Kotlin Examples</source>
          <target state="translated">コトリンの例</target>
        </trans-unit>
        <trans-unit id="37cd15476fbbf200875db0672669c456999520ce" translate="yes" xml:space="preserve">
          <source>Kotlin Gradle plugin 1.3.41 works with Android Gradle Plugin 3.0 and later.</source>
          <target state="translated">Kotlin Gradleプラグイン1.3.41はAndroid Gradleプラグイン3.0以降で動作します。</target>
        </trans-unit>
        <trans-unit id="4cd0aaf87578a00cb3abace9012077865b35012d" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript Overview</source>
          <target state="translated">Kotlin JavaScript の概要</target>
        </trans-unit>
        <trans-unit id="59567d5d08261cc25efe7ed7644a3eac45c8cd4f" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the &lt;a href=&quot;https://fetch.spec.whatwg.org&quot;&gt;W3C fetch API&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://fetch.spec.whatwg.org&quot;&gt;W3CフェッチAPI&lt;/a&gt;用のKotlin JavaScriptラッパー。</target>
        </trans-unit>
        <trans-unit id="89d3498431602c2625879d1556695e73607eefba" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the &lt;a href=&quot;https://www.w3.org/TR/FileAPI/&quot;&gt;W3C file API&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.w3.org/TR/FileAPI/&quot;&gt;W3CファイルAPI&lt;/a&gt;用のKotlin JavaScriptラッパー。</target>
        </trans-unit>
        <trans-unit id="87540457cfa4e684d01ade1be4ff2d537b4f72fb" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the &lt;a href=&quot;https://www.w3.org/TR/XMLHttpRequest/&quot;&gt;XMLHttpRequest API&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.w3.org/TR/XMLHttpRequest/&quot;&gt;XMLHttpRequest APIの&lt;/a&gt; Kotlin JavaScriptラッパー。</target>
        </trans-unit>
        <trans-unit id="e6596f2dab21e4e3036fba3783d7f4c0fbb0bb5f" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the &lt;a href=&quot;https://www.w3.org/TR/navigation-timing/&quot;&gt;Navigation Timing API&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.w3.org/TR/navigation-timing/&quot;&gt;Navigation Timing APIの&lt;/a&gt; Kotlin JavaScriptラッパー。</target>
        </trans-unit>
        <trans-unit id="449720a2299361e4c4ce93870004ed0025bd08d4" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the &lt;a href=&quot;https://www.w3.org/TR/notifications/&quot;&gt;Web Notifications API&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.w3.org/TR/notifications/&quot;&gt;Web通知API&lt;/a&gt;用のKotlin JavaScriptラッパー。</target>
        </trans-unit>
        <trans-unit id="273f94ff92211232696d0bb0cccbbaefd99d6ca2" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the &lt;a href=&quot;https://www.w3.org/TR/workers/&quot;&gt;Web Workers API&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.w3.org/TR/workers/&quot;&gt;Web Workers API&lt;/a&gt;用のKotlin JavaScriptラッパー。</target>
        </trans-unit>
        <trans-unit id="60b8cb21a679faec431a00498befc15353dcf7ae" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the DOM API.</source>
          <target state="translated">DOM API 用の Kotlin JavaScript ラッパーです。</target>
        </trans-unit>
        <trans-unit id="510e862b2092dfc113c9c6425e75519b326f41d7" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the DOM CSS API.</source>
          <target state="translated">DOM CSS API 用の Kotlin JavaScript ラッパーです。</target>
        </trans-unit>
        <trans-unit id="f801c6554f4b1898140dcdff66b0ae475172001f" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the DOM SVG API.</source>
          <target state="translated">DOM SVG API 用の Kotlin JavaScript ラッパーです。</target>
        </trans-unit>
        <trans-unit id="ac97493032ddcd8ea7ab49e6704871e5d4e02a32" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the DOM URL API.</source>
          <target state="translated">DOM URL API 用の Kotlin JavaScript ラッパーです。</target>
        </trans-unit>
        <trans-unit id="632516fede4eb8d78a61753d5a6b557583fae63f" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the DOM events API.</source>
          <target state="translated">DOM イベント API 用の Kotlin JavaScript ラッパーです。</target>
        </trans-unit>
        <trans-unit id="9961d958d00f28d74f54365fb789a0a4c6ef0a4a" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the DOM parsing API.</source>
          <target state="translated">DOM 解析 API 用の Kotlin JavaScript ラッパーです。</target>
        </trans-unit>
        <trans-unit id="1124adb3f39b71dbc17459b09b1abc27195f61e8" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the WebGL API.</source>
          <target state="translated">WebGL API用のKotlin JavaScriptラッパーです。</target>
        </trans-unit>
        <trans-unit id="c722e55da392cbca2ad7039aefd4506956b7b45a" translate="yes" xml:space="preserve">
          <source>Kotlin Koans</source>
          <target state="translated">コトリンコーン</target>
        </trans-unit>
        <trans-unit id="8d8f55606ab1553a327fba954030ef9e92582959" translate="yes" xml:space="preserve">
          <source>Kotlin Koans are a series of exercises to get you familiar with the Kotlin Syntax. Each exercise is created as a failing unit test and your job is to make it pass. You can work with Kotlin Koans in one of following two ways:</source>
          <target state="translated">Kotlin Koans は Kotlin 構文に慣れるための一連の練習問題です。それぞれの練習問題は失敗するユニットテストとして作成されており、あなたの仕事はそれを合格させることです。Kotlin Koansを使うには、以下の2つの方法があります。</target>
        </trans-unit>
        <trans-unit id="02527323fc74019fbf781a55d67bc6708fd5c80b" translate="yes" xml:space="preserve">
          <source>Kotlin Multiplatform Mobile documentation</source>
          <target state="translated">Kotlin マルチプラットフォーム モバイル ドキュメント</target>
        </trans-unit>
        <trans-unit id="79d51b4bb6a5d02df45fa0b0d8769519481f6142" translate="yes" xml:space="preserve">
          <source>Kotlin Multiplatform Mobile samples</source>
          <target state="translated">Kotlin マルチプラットフォームモバイルのサンプル</target>
        </trans-unit>
        <trans-unit id="6c868382257c277087bdd2ca5e011f6e8a06d6f5" translate="yes" xml:space="preserve">
          <source>Kotlin Multiplatform projects require Gradle version 4.7 and above, older Gradle versions are not supported.</source>
          <target state="translated">Kotlin Multiplatform プロジェクトには Gradle のバージョン 4.7 以上が必要ですが、それ以前のバージョンの Gradle はサポートされていません。</target>
        </trans-unit>
        <trans-unit id="5beef88265abf70b994272f6614d166413737387" translate="yes" xml:space="preserve">
          <source>Kotlin Multiplatform projects support the Android platform by providing the &lt;code&gt;android&lt;/code&gt; preset. Creating an Android target requires that one of the Android Gradle plugins, like &lt;code&gt;com.android.application&lt;/code&gt; or &lt;code&gt;com.android.library&lt;/code&gt; is manually applied to the project. Only one Android target may be created per Gradle subproject:</source>
          <target state="translated">Kotlin Multiplatformプロジェクトは、 &lt;code&gt;android&lt;/code&gt; プリセットを提供することでAndroidプラットフォームをサポートします。 Androidターゲットを作成するには、 &lt;code&gt;com.android.application&lt;/code&gt; や &lt;code&gt;com.android.library&lt;/code&gt; などのAndroid Gradleプラグインの1つを手動でプロジェクトに適用する必要があります。 Gradleサブプロジェクトごとに作成できるAndroidターゲットは1つだけです。</target>
        </trans-unit>
        <trans-unit id="dc3e3dd997f7c2c71d9a81f4cdb39cd90d645230" translate="yes" xml:space="preserve">
          <source>Kotlin Numbers and NSNumber</source>
          <target state="translated">コトリンナンバーズとNSナンバーズ</target>
        </trans-unit>
        <trans-unit id="eb93d433c30733afdb11f2126d70c53184c02256" translate="yes" xml:space="preserve">
          <source>Kotlin Programming: The Big Nerd Ranch Guide</source>
          <target state="translated">Kotlin プログラミング。ビッグオタクランチガイド</target>
        </trans-unit>
        <trans-unit id="7be628ef89900aa7e06bf8cc0824f551fbf7c2e0" translate="yes" xml:space="preserve">
          <source>Kotlin Scripting APIs</source>
          <target state="translated">Kotlin スクリプト API</target>
        </trans-unit>
        <trans-unit id="faea4ae8da7ddba5c8fa58aae401857d2734ca04" translate="yes" xml:space="preserve">
          <source>Kotlin Scripting APIs and custom hosts</source>
          <target state="translated">Kotlin スクリプト API とカスタムホスト</target>
        </trans-unit>
        <trans-unit id="011d36adfc33756acd805d34ad317cbce9bd6e81" translate="yes" xml:space="preserve">
          <source>Kotlin Scripts (*.kts)</source>
          <target state="translated">Kotlin スクリプト (*.kts)</target>
        </trans-unit>
        <trans-unit id="ede3b405bdfcccaf670f3a431d8f9e4a2a31a89a" translate="yes" xml:space="preserve">
          <source>Kotlin Standard Library</source>
          <target state="translated">Kotkin 標準ライブラリ</target>
        </trans-unit>
        <trans-unit id="f1cf27226d5b75bef32541fe78ffcb393aaf20fa" translate="yes" xml:space="preserve">
          <source>Kotlin allows us to provide implementations for a predefined set of operators on our types. These operators have fixed symbolic representation (like &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;*&lt;/code&gt;) and fixed &lt;a href=&quot;https://kotlinlang.org/docs/reference/grammar.html#expressions&quot;&gt;precedence&lt;/a&gt;. To implement an operator, we provide a &lt;a href=&quot;functions#member-functions&quot;&gt;member function&lt;/a&gt; or an &lt;a href=&quot;extensions&quot;&gt;extension function&lt;/a&gt; with a fixed name, for the corresponding type, i.e. left-hand side type for binary operations and argument type for unary ones. Functions that overload operators need to be marked with the &lt;code&gt;operator&lt;/code&gt; modifier.</source>
          <target state="translated">Kotlinを使用すると、事前定義された一連の演算子の実装を型に提供できます。これらの演算子には、記号表現（ &lt;code&gt;+&lt;/code&gt; や &lt;code&gt;*&lt;/code&gt; など）と&lt;a href=&quot;https://kotlinlang.org/docs/reference/grammar.html#expressions&quot;&gt;優先順位が&lt;/a&gt;固定されています。演算子を実装するには、対応する型（つまり、2項演算の左側の型と単項演算子の引数の型）に、固定名の&lt;a href=&quot;functions#member-functions&quot;&gt;メンバー関数&lt;/a&gt;または&lt;a href=&quot;extensions&quot;&gt;拡張関数&lt;/a&gt;を提供します。演算子をオーバーロードする関数は、 &lt;code&gt;operator&lt;/code&gt; 修飾子でマークする必要があります。</target>
        </trans-unit>
        <trans-unit id="b851c189b290bdaf55745756936a76cc50344467" translate="yes" xml:space="preserve">
          <source>Kotlin allows you to compile your Kotlin projects to JavaScript modules for popular module systems. Here is the list of available options:</source>
          <target state="translated">Kotlinでは、Kotlinプロジェクトを一般的なモジュールシステム用のJavaScriptモジュールにコンパイルすることができます。利用可能なオプションのリストは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="9b5fdfaaf9a73290e0eaf81fbe25051b78fa8542" translate="yes" xml:space="preserve">
          <source>Kotlin allows you to enforce symbol visibility (which Python only does via underscore conventions) via &lt;em&gt;visibility modifiers&lt;/em&gt;, which can be placed on symbol declarations. If you don't supply a visibility modifier, you get the default visibility level, which is &lt;em&gt;public&lt;/em&gt;.</source>
          <target state="translated">Kotlinを使用すると、シンボル宣言に配置できる&lt;em&gt;可視性修飾子を使用して&lt;/em&gt;、シンボルの可視性（Pythonはアンダースコア規則を介してのみ実行する）を適用できます。可視性修飾子を指定しない場合、デフォルトの可視性レベルである&lt;em&gt;public&lt;/em&gt;を取得します。</target>
        </trans-unit>
        <trans-unit id="abf47a509d1576212045a5d60665d20e7353bdcd" translate="yes" xml:space="preserve">
          <source>Kotlin also has specialized classes to represent arrays of primitive types without boxing overhead: &lt;code&gt;ByteArray&lt;/code&gt;, &lt;code&gt;ShortArray&lt;/code&gt;, &lt;code&gt;IntArray&lt;/code&gt; and so on. These classes have no inheritance relation to the &lt;code&gt;Array&lt;/code&gt; class, but they have the same set of methods and properties. Each of them also has a corresponding factory function:</source>
          <target state="translated">Kotlinには、プリミティブ型の配列をボックス化オーバーヘッドなしで表すための特殊なクラスもあります： &lt;code&gt;ByteArray&lt;/code&gt; 、 &lt;code&gt;ShortArray&lt;/code&gt; 、 &lt;code&gt;IntArray&lt;/code&gt; など。これらのクラスには、 &lt;code&gt;Array&lt;/code&gt; クラスとの継承関係はありませんが、メソッドとプロパティの同じセットがあります。それぞれに対応するファクトリ関数もあります。</target>
        </trans-unit>
        <trans-unit id="7c8be75b3b89d72e9e8ecc5a19439af68c79c8b1" translate="yes" xml:space="preserve">
          <source>Kotlin also supports a conventional notation for floating-point numbers:</source>
          <target state="translated">Kotlinは浮動小数点数の従来の記法もサポートしています。</target>
        </trans-unit>
        <trans-unit id="fdbc9c499ba317d1129cfbc92871c8a9261e88e6" translate="yes" xml:space="preserve">
          <source>Kotlin and Continuous Integration with TeamCity</source>
          <target state="translated">Kotlin と TeamCity での継続的インテグレーション</target>
        </trans-unit>
        <trans-unit id="a29301ac26900a11e482b9b5b30d720163c72b02" translate="yes" xml:space="preserve">
          <source>Kotlin and Java sources</source>
          <target state="translated">Kotlin と Java のソース</target>
        </trans-unit>
        <trans-unit id="1c08b7274c4d1ababf7790a5bd9928dd47f39d9b" translate="yes" xml:space="preserve">
          <source>Kotlin and OSGi</source>
          <target state="translated">コトリンとOSGi</target>
        </trans-unit>
        <trans-unit id="b68da677f694a6554746e03538ca7213a7ff25e8" translate="yes" xml:space="preserve">
          <source>Kotlin and Swift both define nullability as part of the type specification, while Objc defines nullability on methods and properties of a type. As such, the following:</source>
          <target state="translated">KotlinとSwiftはどちらも型の仕様の一部としてヌル可能性を定義していますが、Objcは型のメソッドやプロパティに対してヌル可能性を定義しています。そのため、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="de39894b7ea202f08e960c5e82b74ef66fdd95ec" translate="yes" xml:space="preserve">
          <source>Kotlin and Swift both define nullability as part of the type specification, while Objective-C defines nullability on methods and properties of a type. As such, the following:</source>
          <target state="translated">Kotlin と Swift はどちらも型の仕様の一部としてヌル可能性を定義していますが、Objective-C は型のメソッドとプロパティに対してヌル可能性を定義しています。そのため、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="fab22e5d648c157aabeded51b75888d84156c11e" translate="yes" xml:space="preserve">
          <source>Kotlin applications can be deployed into any host that supports Java Web applications, including Amazon Web Services, Google Cloud Platform and more.</source>
          <target state="translated">Kotlinのアプリケーションは、Amazon Web ServicesやGoogle Cloud Platformなど、Java Webアプリケーションをサポートするあらゆるホストにデプロイすることができます。</target>
        </trans-unit>
        <trans-unit id="e02f5529b0cc0cc0f331270b870a1119276c7c49" translate="yes" xml:space="preserve">
          <source>Kotlin as a statically typed programming language plays well for writing Gradle build scripts. Thanks to the static type inference, the Kotlin compiler detects errors earlier and shows important compilation error messages and warnings. Both an IDE and the compiler can use the information about types to infer the available functions and properties in a given scope.</source>
          <target state="translated">静的型付けされたプログラミング言語である Kotlin は Gradle のビルドスクリプトを書くのに適しています。静的型推論のおかげで、Kotlin コンパイラはより早くエラーを検出し、重要なコンパイルエラーメッセージや警告を表示します。IDE とコンパイラは、型に関する情報を使って、指定されたスコープで利用可能な関数やプロパティを推論することができます。</target>
        </trans-unit>
        <trans-unit id="2c6b22009eb8eb5969f5ded032f4849774e1cf34" translate="yes" xml:space="preserve">
          <source>Kotlin by Example</source>
          <target state="translated">事例によるコトリン</target>
        </trans-unit>
        <trans-unit id="6b0d896d7d9bc79daab4d58d21e623cb98946df3" translate="yes" xml:space="preserve">
          <source>Kotlin can also be used as a scripting language. A script is a Kotlin source file (.kts) with top level executable code.</source>
          <target state="translated">Kotlin はスクリプト言語としても使用できます。スクリプトとは、トップレベルの実行可能なコードを含む Kotlin のソースファイル (.kts)のことです。</target>
        </trans-unit>
        <trans-unit id="89f1b06f3d13062a764afffd52c7537a00883d5c" translate="yes" xml:space="preserve">
          <source>Kotlin can also be used as a scripting language. A script is a Kotlin source file (&lt;em&gt;.kts&lt;/em&gt;) with top level executable code.</source>
          <target state="translated">Kotlinはスクリプト言語としても使用できます。スクリプトは、トップレベルの実行可能コードを&lt;em&gt;含む&lt;/em&gt;Kotlinソースファイル（&lt;em&gt;.kts&lt;/em&gt;）です。</target>
        </trans-unit>
        <trans-unit id="c3ea6432cc5a54843d5885315d7e06f428855633" translate="yes" xml:space="preserve">
          <source>Kotlin can be compiled for several different platforms. In this document, we assume that the target platform is the Java virtual machine, which grants some extra capabilities - in particular, your code will be compiled to Java bytecode and will therefore be interoperable with the large ecosystem of Java libraries.</source>
          <target state="translated">Kotlinはいくつかの異なるプラットフォーム用にコンパイルすることができます。このドキュメントでは、ターゲットプラットフォームがJava仮想マシンであることを前提としていますが、これはいくつかの特別な機能を提供します。</target>
        </trans-unit>
        <trans-unit id="fb59a20f7c43ef0e90a9a5fe239e22f7fac4ccd8" translate="yes" xml:space="preserve">
          <source>Kotlin can be used for any kind of development, be it server-side, client-side web and Android. With Kotlin/Native currently in the works, support for other platforms such as embedded systems, macOS and iOS is coming. People are using Kotlin for mobile and server-side applications, client-side with JavaScript or JavaFX, and data science, just to name a few possibilities.</source>
          <target state="translated">Kotlinは、サーバーサイド、クライアントサイドのWeb、Androidなど、あらゆる種類の開発に利用できます。現在Kotlin/Nativeが開発中で、組み込みシステム、macOS、iOSなどの他のプラットフォームのサポートも予定されています。モバイルやサーバーサイドのアプリケーション、JavaScriptやJavaFXを使ったクライアントサイド、データサイエンスなどにKotlinを使っています。</target>
        </trans-unit>
        <trans-unit id="521266653280c8e4a255fb437cafa5ed253cdca4" translate="yes" xml:space="preserve">
          <source>Kotlin can be used together with existing third-party libraries and frameworks, such as jQuery or React. To access third-party frameworks with a strongly-typed API, you can convert TypeScript definitions from the &lt;a href=&quot;http://definitelytyped.org/&quot;&gt;Definitely Typed&lt;/a&gt; type definitions repository to Kotlin using the &lt;a href=&quot;https://github.com/kotlin/ts2kt&quot;&gt;ts2kt&lt;/a&gt; tool. Alternatively, you can use the &lt;a href=&quot;dynamic-type&quot;&gt;dynamic type&lt;/a&gt; to access any framework without strong typing.</source>
          <target state="translated">Kotlinは、jQueryやReactなどの既存のサードパーティライブラリやフレームワークと一緒に使用できます。強く型付けされたAPIを使用してサードパーティのフレームワークにアクセスするには、&lt;a href=&quot;https://github.com/kotlin/ts2kt&quot;&gt;ts2kt&lt;/a&gt;ツールを使用して、TypeScript定義を&lt;a href=&quot;http://definitelytyped.org/&quot;&gt;Definitely Typed&lt;/a&gt; type definitionリポジトリからKotlinに変換できます。または、&lt;a href=&quot;dynamic-type&quot;&gt;動的な型&lt;/a&gt;を使用して、強い型付けを行わずに任意のフレームワークにアクセスできます。</target>
        </trans-unit>
        <trans-unit id="7c790b4c961dea3d891274def8258c901571e23a" translate="yes" xml:space="preserve">
          <source>Kotlin can get quite close to the compactness of Python's &lt;code&gt;list&lt;/code&gt;/&lt;code&gt;dict&lt;/code&gt;/&lt;code&gt;set&lt;/code&gt; comprehensions. Assuming that &lt;code&gt;people&lt;/code&gt; is a collection of &lt;code&gt;Person&lt;/code&gt; objects with a &lt;code&gt;name&lt;/code&gt; property:</source>
          <target state="translated">Kotlinは、Pythonの &lt;code&gt;list&lt;/code&gt; / &lt;code&gt;dict&lt;/code&gt; / &lt;code&gt;set&lt;/code&gt; 内包の簡潔さにかなり近づくことができます。 &lt;code&gt;people&lt;/code&gt; が &lt;code&gt;name&lt;/code&gt; プロパティを持つ &lt;code&gt;Person&lt;/code&gt; オブジェクトのコレクションであると想定します。</target>
        </trans-unit>
        <trans-unit id="88373e20528c6bc39fe448071ad8e0db31e3a229" translate="yes" xml:space="preserve">
          <source>Kotlin can't distinguish between numeric types at run time (except for &lt;code&gt;kotlin.Long&lt;/code&gt;), i.e. the following code works:</source>
          <target state="translated">Kotlinは、実行時に数値型を区別できません（ &lt;code&gt;kotlin.Long&lt;/code&gt; を除く）。つまり、次のコードは機能します。</target>
        </trans-unit>
        <trans-unit id="f14b3e6c2a42d2b616f9f3f45afd4a5a6fa4ccb2" translate="yes" xml:space="preserve">
          <source>Kotlin can't distinguish between numeric types at run time (except for &lt;code&gt;kotlin.Long&lt;/code&gt;), so the following code works:</source>
          <target state="translated">Kotlinは実行時に数値タイプを区別できないため（ &lt;code&gt;kotlin.Long&lt;/code&gt; を除く）、次のコードが機能します。</target>
        </trans-unit>
        <trans-unit id="6add9a81cfef0c10e828238aa1031be87d4fbdd7" translate="yes" xml:space="preserve">
          <source>Kotlin cares a lot about stability and backward compatibility of code: Kotlin compatibility policy says that &quot;breaking changes&quot; (e.g., a change which makes the code that used to compile fine, not compile anymore) can be introduced only in the major releases (1.2, 1.3, etc.).</source>
          <target state="translated">Kotlinはコードの安定性と下位互換性をかなり気にしています。Kotlin の互換性ポリシーによると、&quot;Breaking Change&quot; (例えば、以前は正常にコンパイルできていたコードをコンパイルできなくするような変更)はメジャーリリース (1.2,1.3 など)でのみ導入できるとされています。</target>
        </trans-unit>
        <trans-unit id="7c15ccd2ee8e753a90a11ef141acc11bda9b7db8" translate="yes" xml:space="preserve">
          <source>Kotlin classes and interfaces can be subclassed by Swift/Objective-C classes and protocols.</source>
          <target state="translated">Kotlinのクラスやインターフェースは、Swift/Objective-Cのクラスやプロトコルでサブクラス化することができます。</target>
        </trans-unit>
        <trans-unit id="21d314ecbc0aafe901079bc4583e826c76990ca2" translate="yes" xml:space="preserve">
          <source>Kotlin classes have a &lt;code&gt;KotlinBase&lt;/code&gt; base class in Objective-C, the class extends the &lt;code&gt;NSObject&lt;/code&gt; class there. We also have wrappers for collections and exceptions. Most of the collection types are mapped to similar collection types from the other side:</source>
          <target state="translated">KotlinクラスにはObjective-Cの &lt;code&gt;KotlinBase&lt;/code&gt; 基本クラスがあり、このクラスは &lt;code&gt;NSObject&lt;/code&gt; クラスを拡張します。コレクションと例外のラッパーもあります。コレクションタイプのほとんどは、反対側から同様のコレクションタイプにマップされます。</target>
        </trans-unit>
        <trans-unit id="8a8b117cc96a073696a10569a9a03f3366586d14" translate="yes" xml:space="preserve">
          <source>Kotlin code can be easily called from Java. For example, instances of a Kotlin class can be seamlessly created and operated in Java methods. However, there are certain differences between Java and Kotlin that require attention when integrating Kotlin code into Java. On this page, we'll describe the ways to tailor the interop of your Kotlin code with its Java clients.</source>
          <target state="translated">KotlinのコードはJavaから簡単に呼び出すことができます。例えば、Kotlinクラスのインスタンスをシームレスに作成し、Javaのメソッドで操作することができます。しかし、JavaとKotlinの間には、KotlinのコードをJavaに統合する際に注意が必要な違いがあります。このページでは、KotlinコードのJavaクライアントとの相互接続を調整する方法を説明します。</target>
        </trans-unit>
        <trans-unit id="9fd6821c54cf8552d62d9de4efae79ccdf8ce19d" translate="yes" xml:space="preserve">
          <source>Kotlin collection types and subtypes</source>
          <target state="translated">Kotlin コレクションのタイプとサブタイプ</target>
        </trans-unit>
        <trans-unit id="315f6541c31d964f7f6872786a71a0ab54434ee9" translate="yes" xml:space="preserve">
          <source>Kotlin collections (&lt;code&gt;List&lt;/code&gt;, &lt;code&gt;Set&lt;/code&gt;, &lt;code&gt;Map&lt;/code&gt;, etc.) are not mapped to any specific JavaScript type.</source>
          <target state="translated">Kotlinコレクション（ &lt;code&gt;List&lt;/code&gt; 、 &lt;code&gt;Set&lt;/code&gt; 、 &lt;code&gt;Map&lt;/code&gt; など）は、特定のJavaScriptタイプにマップされません。</target>
        </trans-unit>
        <trans-unit id="82a1593c6b9e1c8836da6d1fc4eb0ee62fff00f0" translate="yes" xml:space="preserve">
          <source>Kotlin collections (i.e. &lt;code&gt;List&lt;/code&gt;, &lt;code&gt;Set&lt;/code&gt;, &lt;code&gt;Map&lt;/code&gt;, etc) are not mapped to any specific JavaScript type.</source>
          <target state="translated">Kotlinコレクション（つまり、 &lt;code&gt;List&lt;/code&gt; 、 &lt;code&gt;Set&lt;/code&gt; 、 &lt;code&gt;Map&lt;/code&gt; など）は、特定のJavaScriptタイプにはマップされません。</target>
        </trans-unit>
        <trans-unit id="89a478aadf91b074b0da52969af13f23d22bc823" translate="yes" xml:space="preserve">
          <source>Kotlin collections are converted to Swift/Objective-C collections as described in the table above. Swift/Objective-C collections are mapped to Kotlin in the same way, except for &lt;code&gt;NSMutableSet&lt;/code&gt; and &lt;code&gt;NSMutableDictionary&lt;/code&gt;. &lt;code&gt;NSMutableSet&lt;/code&gt; isn't converted to a Kotlin &lt;code&gt;MutableSet&lt;/code&gt;. To pass an object for Kotlin &lt;code&gt;MutableSet&lt;/code&gt;, you can create this kind of Kotlin collection explicitly by either creating it in Kotlin with e.g. &lt;code&gt;mutableSetOf()&lt;/code&gt;, or using the &lt;code&gt;KotlinMutableSet&lt;/code&gt; class in Swift (or &lt;code&gt;${prefix}MutableSet&lt;/code&gt; in Objective-C, where &lt;code&gt;prefix&lt;/code&gt; is the framework names prefix). The same holds for &lt;code&gt;MutableMap&lt;/code&gt;.</source>
          <target state="translated">Kotlinコレクションは、上記の表で説明されているようにSwift / Objective-Cコレクションに変換されます。 Swift / Objective-Cコレクションは、 &lt;code&gt;NSMutableSet&lt;/code&gt; と &lt;code&gt;NSMutableDictionary&lt;/code&gt; を除いて、同じ方法でKotlinにマップされます。 &lt;code&gt;NSMutableSet&lt;/code&gt; はKotlin &lt;code&gt;MutableSet&lt;/code&gt; に変換されません。 Kotlinのためのオブジェクト渡すには &lt;code&gt;MutableSet&lt;/code&gt; を、あなたは、例えばとKotlinでそれを作成することによって明示的にKotlinコレクションのこの種を作成することができます &lt;code&gt;mutableSetOf()&lt;/code&gt; 、または使用して &lt;code&gt;KotlinMutableSet&lt;/code&gt; のスウィフト（またはでクラスを &lt;code&gt;${prefix}MutableSet&lt;/code&gt; のObjective-C、に &lt;code&gt;prefix&lt;/code&gt; フレームワーク名の接頭辞です）。 &lt;code&gt;MutableMap&lt;/code&gt; についても同様です。</target>
        </trans-unit>
        <trans-unit id="b92ab48756ee9ee4eecd8b48a584a882c8254f38" translate="yes" xml:space="preserve">
          <source>Kotlin collections contain functions for commonly used &lt;em&gt;aggregate operations&lt;/em&gt; &amp;ndash; operations that return a single value based on the collection content. Most of them are well known and work the same way as they do in other languages:</source>
          <target state="translated">Kotlinコレクションには、一般的に使用される&lt;em&gt;集約オペレーション（&lt;/em&gt;コレクションの内容に基づいて単一の値を返す&lt;em&gt;オペレーション）の&lt;/em&gt;関数が含まれています。それらのほとんどはよく知られており、他の言語と同じように機能します。</target>
        </trans-unit>
        <trans-unit id="6f6ae7c2ed581955837fb7fe33d78ac601409b90" translate="yes" xml:space="preserve">
          <source>Kotlin collections provide a set of functions for retrieving single elements from collections. Functions described on this page apply to both lists and sets.</source>
          <target state="translated">Kotlin のコレクションには、コレクションから単一の要素を取得するための関数が用意されています。このページで説明する関数はリストとセットの両方に適用されます。</target>
        </trans-unit>
        <trans-unit id="ba542c391d818d9d92362b069b9bf7f9bd8bf71d" translate="yes" xml:space="preserve">
          <source>Kotlin community is open, helpful, and welcoming. Don't hesitate to join and ask on any platform you like:</source>
          <target state="translated">Kotlin コミュニティはオープンで親切で歓迎されています。遠慮なく参加して、好きなプラットフォームで質問してください。</target>
        </trans-unit>
        <trans-unit id="4e7553781e500e3864ae344f47e5a7328b499d62" translate="yes" xml:space="preserve">
          <source>Kotlin compiler generates normal JavaScript classes, functions and properties you can freely use from JavaScript code. Nevertheless, there are some subtle things you should remember.</source>
          <target state="translated">Kotlinコンパイラは、JavaScriptのコードから自由に使える普通のJavaScriptのクラスや関数、プロパティを生成してくれます。とはいえ、微妙に覚えておくべきことがあります。</target>
        </trans-unit>
        <trans-unit id="6a4e8f76fdd58bb0af9bcb56f7360e7af41cc619" translate="yes" xml:space="preserve">
          <source>Kotlin compiler produces byte-code, thus there really is no difference in terms of look and feel of Kotlin applications versus those written in Java.</source>
          <target state="translated">Kotlinコンパイラはバイトコードを生成するので、Javaで書かれたものとKotlinアプリケーションの見た目に違いはありません。</target>
        </trans-unit>
        <trans-unit id="254a81c2b10749e0ebcc71c56165e699f0faa1e8" translate="yes" xml:space="preserve">
          <source>Kotlin compiler specifics</source>
          <target state="translated">Kotlin コンパイラの仕様</target>
        </trans-unit>
        <trans-unit id="9aad08d33b38b295c66376049aa54dafe55e242e" translate="yes" xml:space="preserve">
          <source>Kotlin compiler would generate the following output</source>
          <target state="translated">Kotlin コンパイラは以下のような出力を生成します。</target>
        </trans-unit>
        <trans-unit id="4e6a12781a358b0632ea318dc28241e7061cc96f" translate="yes" xml:space="preserve">
          <source>Kotlin constructors are imported as initializers to Swift/Objective-C.</source>
          <target state="translated">Kotlinのコンストラクタは、Swift/Objective-Cのイニシャライザとしてインポートされます。</target>
        </trans-unit>
        <trans-unit id="fd097194728e7a8d4e414220f1c3adc66a1135aa" translate="yes" xml:space="preserve">
          <source>Kotlin documentation is a good place to start, check out these links to get your feet wet:</source>
          <target state="translated">Kotlin のドキュメントは始めるには良い場所です。</target>
        </trans-unit>
        <trans-unit id="22a04b6935ed8f621d145360c7aea12d3366842f" translate="yes" xml:space="preserve">
          <source>Kotlin does not have Python's &lt;em&gt;resource managers&lt;/em&gt; or Java's &lt;em&gt;try-with-resources&lt;/em&gt;, but thanks to extension functions, there's &lt;code&gt;use&lt;/code&gt;:</source>
          <target state="translated">KotlinにはPythonの&lt;em&gt;リソースマネージャー&lt;/em&gt;やJavaの&lt;em&gt;try-with-resources&lt;/em&gt;がありませんが、拡張関数のおかげで、次の &lt;code&gt;use&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8da11f04c1c3d7dbbef032228e63afa6f04d63f3" translate="yes" xml:space="preserve">
          <source>Kotlin does not have checked &lt;a href=&quot;exceptions&quot;&gt;exceptions&lt;/a&gt;</source>
          <target state="translated">Kotlinは&lt;a href=&quot;exceptions&quot;&gt;例外&lt;/a&gt;を確認していません</target>
        </trans-unit>
        <trans-unit id="58e8fc7ba9fc6ab7f17a343e98ca51e5a850e480" translate="yes" xml:space="preserve">
          <source>Kotlin does not have checked exceptions. There are many reasons for this, but we will provide a simple example.</source>
          <target state="translated">Kotlinにはチェック済みの例外がありません。これには様々な理由がありますが、簡単な例を示します。</target>
        </trans-unit>
        <trans-unit id="7ea8df84918172c874d6ce26a2d2ac8d56eff8a7" translate="yes" xml:space="preserve">
          <source>Kotlin does not implement lazy initialization of top-level properties in JavaScript.</source>
          <target state="translated">KotlinはJavaScriptのトップレベルプロパティの遅延初期化を実装していません。</target>
        </trans-unit>
        <trans-unit id="1c19ec6ca29946106579b7774a9f16c5845ebbc2" translate="yes" xml:space="preserve">
          <source>Kotlin ensures type safety of operations involving &lt;a href=&quot;generics&quot;&gt;generics&lt;/a&gt; at compile time, while, at runtime, instances of generic types hold no information about their actual type arguments. For example, &lt;code&gt;List&amp;lt;Foo&amp;gt;&lt;/code&gt; is erased to just &lt;code&gt;List&amp;lt;*&amp;gt;&lt;/code&gt;. In general, there is no way to check whether an instance belongs to a generic type with certain type arguments at runtime.</source>
          <target state="translated">Kotlinは、コンパイル時に&lt;a href=&quot;generics&quot;&gt;ジェネリック&lt;/a&gt;を含む操作の型安全性を保証しますが、実行時、ジェネリック型のインスタンスは実際の型引数に関する情報を保持しません。たとえば、 &lt;code&gt;List&amp;lt;Foo&amp;gt;&lt;/code&gt; は消去され、 &lt;code&gt;List&amp;lt;*&amp;gt;&lt;/code&gt; だけになります。一般に、インスタンスが実行時に特定の型引数を持つジェネリック型に属しているかどうかを確認する方法はありません。</target>
        </trans-unit>
        <trans-unit id="e3093475043dd707a8b9c1069aead086bf16cf6d" translate="yes" xml:space="preserve">
          <source>Kotlin exposes its package structure to JavaScript, so unless you define your declarations in the root package, you have to use fully qualified names in JavaScript. For example:</source>
          <target state="translated">Kotlin はそのパッケージ構造を JavaScript に公開しているので、ルートパッケージで宣言を定義しない限り、JavaScript で完全修飾名を使用しなければなりません。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="bbcaf4c7dfc1607eaa4b2ffde25fea37b6fff50b" translate="yes" xml:space="preserve">
          <source>Kotlin exposes its package structure to JavaScript, so unless you define your declarations in the root package, you have to use fully-qualified names in JavaScript. For example:</source>
          <target state="translated">Kotlin はそのパッケージ構造を JavaScript に公開しているので、ルートパッケージで宣言を定義しない限り、JavaScript で完全修飾名を使用しなければなりません。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="7be04058c2375c4141e803b8f5f5c3ef0ebe450b" translate="yes" xml:space="preserve">
          <source>Kotlin extensions to &quot;regular&quot; Kotlin classes are imported to Swift and Objective-C as extensions and category members respectively. Kotlin extensions to other types are treated as &lt;a href=&quot;#top-level-functions-and-properties&quot;&gt;top-level declarations&lt;/a&gt; with an additional receiver parameter. These types include:</source>
          <target state="translated">「通常の」KotlinクラスへのKotlin拡張機能は、拡張機能とカテゴリメンバーとしてそれぞれSwiftとObjective-Cにインポートされます。他のタイプへのKotlin拡張は、追加のレシーバーパラメーターを持つ&lt;a href=&quot;#top-level-functions-and-properties&quot;&gt;トップレベルの宣言&lt;/a&gt;として扱われます。これらのタイプは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="6bd032e19c9c721a60ec9014384d50331ee1d338" translate="yes" xml:space="preserve">
          <source>Kotlin fixes a series of issues that Java suffers from:</source>
          <target state="translated">Kotlin は Java が抱える一連の問題を修正します。</target>
        </trans-unit>
        <trans-unit id="2e70b9b4257b183b5c7e10570483451ad725fc8a" translate="yes" xml:space="preserve">
          <source>Kotlin follows the Java naming conventions. In particular:</source>
          <target state="translated">KotlinはJavaの命名規則に従っています。特に</target>
        </trans-unit>
        <trans-unit id="0548deb8694e8bfa87792c4e732edf938085eb1e" translate="yes" xml:space="preserve">
          <source>Kotlin for Android Case Studies</source>
          <target state="translated">Kotlin for Androidの導入事例</target>
        </trans-unit>
        <trans-unit id="c1441b497e656bddb290de8de9224360e00ecbdf" translate="yes" xml:space="preserve">
          <source>Kotlin for Android Developers</source>
          <target state="translated">Android開発者のためのKotlin</target>
        </trans-unit>
        <trans-unit id="7b2f1c8edda5c1d58bf2a573a1626581c631617c" translate="yes" xml:space="preserve">
          <source>Kotlin for Java Developers</source>
          <target state="translated">Java開発者のためのKotlin</target>
        </trans-unit>
        <trans-unit id="e6f31bf50fe73009407bd97cfc46c1659646cb16" translate="yes" xml:space="preserve">
          <source>Kotlin function types and subtypes</source>
          <target state="translated">Kotlin 関数の型とサブタイプ</target>
        </trans-unit>
        <trans-unit id="fe6b04ae909883df5d80ca51aec87a07bb290e41" translate="yes" xml:space="preserve">
          <source>Kotlin function-typed objects (e.g. lambdas) are converted to Swift functions / Objective-C blocks. However there is a difference in how types of parameters and return values are mapped when translating a function and a function type. In the latter case primitive types are mapped to their boxed representation. Kotlin &lt;code&gt;Unit&lt;/code&gt; return value is represented as a corresponding &lt;code&gt;Unit&lt;/code&gt; singleton in Swift/Objective-C. The value of this singleton can be retrieved in the same way as it is for any other Kotlin &lt;code&gt;object&lt;/code&gt; (see singletons in the table above). To sum the things up:</source>
          <target state="translated">Kotlin関数型オブジェクト（ラムダなど）は、Swift関数/ Objective-Cブロックに変換されます。ただし、関数と関数の型を変換するときに、パラメーターの型と戻り値がマップされる方法には違いがあります。後者の場合、プリミティブ型はボックス化された表現にマップされます。 Kotlin &lt;code&gt;Unit&lt;/code&gt; 戻り値は、Swift / Objective-Cでは対応する &lt;code&gt;Unit&lt;/code&gt; シングルトンとして表されます。このシングルトンの値は、他のKotlin &lt;code&gt;object&lt;/code&gt; 場合と同じ方法で取得できます（上記の表のシングルトンを参照）。まとめると：</target>
        </trans-unit>
        <trans-unit id="6377c81eb40cd3205e240b814a78f31b9c3b2c4e" translate="yes" xml:space="preserve">
          <source>Kotlin functions are &lt;a href=&quot;https://en.wikipedia.org/wiki/First-class_function&quot;&gt;&lt;em&gt;first-class&lt;/em&gt;&lt;/a&gt;, which means that they can be stored in variables and data structures, passed as arguments to and returned from other &lt;a href=&quot;#higher-order-functions&quot;&gt;higher-order functions&lt;/a&gt;. You can operate with functions in any way that is possible for other non-function values.</source>
          <target state="translated">Kotlin関数は&lt;a href=&quot;https://en.wikipedia.org/wiki/First-class_function&quot;&gt;&lt;em&gt;ファーストクラス&lt;/em&gt;&lt;/a&gt;です。つまり、変数やデータ構造に格納でき、引数として他の&lt;a href=&quot;#higher-order-functions&quot;&gt;高次関数&lt;/a&gt;に渡したり、他の高次関数から返したりできます。他の非関数値で可能な方法で関数を操作できます。</target>
        </trans-unit>
        <trans-unit id="06212cca9855d4bc50a6216a937f6da059a9c0cc" translate="yes" xml:space="preserve">
          <source>Kotlin generate JavaScript code that is compatible with Asynchronous Module Definition (AMD), CommonJS and Universal Model Definition (UMD).</source>
          <target state="translated">Kotlinは、非同期モジュール定義(AMD)、CommonJS、ユニバーサルモデル定義(UMD)と互換性のあるJavaScriptコードを生成します。</target>
        </trans-unit>
        <trans-unit id="7e3d5465bac3e356284fe278ce3583ae2129ce4a" translate="yes" xml:space="preserve">
          <source>Kotlin handles numbers in a way close to Java, but not exactly the same. For example, there are no implicit widening conversions for numbers, and literals are slightly different in some cases.</source>
          <target state="translated">KotlinはJavaに近い方法で数値を扱いますが、全く同じではありません。例えば、数字には暗黙のワイド化変換はありませんし、リテラルも若干異なる場合があります。</target>
        </trans-unit>
        <trans-unit id="a419931ca3da367222b771f7660e3ff6428af9ed" translate="yes" xml:space="preserve">
          <source>Kotlin has a rather small runtime file size: the library is approximately 964KB (as of 1.3.41). This means Kotlin adds just a little to .apk file size.</source>
          <target state="translated">Kotlinの実行時のファイルサイズはかなり小さく、ライブラリは約964KBです(1.3.41現在)。つまり、Kotlinは.apkのファイルサイズにほんの少しだけ足しています。</target>
        </trans-unit>
        <trans-unit id="1a3e60d485f88e60187d3caa5025c740961ab3aa" translate="yes" xml:space="preserve">
          <source>Kotlin has an extensive standard library that can be used in your applications. Configure the following dependency in the pom file:</source>
          <target state="translated">Kotlinには、アプリケーションで使用できる標準ライブラリが豊富に用意されています。pomファイルに以下の依存関係を設定します。</target>
        </trans-unit>
        <trans-unit id="ab1e60d19725004dca25a2263f17ef1cdb84890e" translate="yes" xml:space="preserve">
          <source>Kotlin has been successfully adopted by major companies, and a few of them have shared their experiences:</source>
          <target state="translated">Kotlinは大手企業での採用に成功しており、その体験談をいくつか紹介しています。</target>
        </trans-unit>
        <trans-unit id="3ed9d85f3169bc5321f12531a1c541d127d00550" translate="yes" xml:space="preserve">
          <source>Kotlin has both object-oriented and functional constructs. You can use it in both OO and FP styles, or mix elements of the two. With first-class support for features such as higher-order functions, function types and lambdas, Kotlin is a great choice if you&amp;rsquo;re doing or exploring functional programming.</source>
          <target state="translated">Kotlinには、オブジェクト指向と機能の両方の構造があります。OOスタイルとFPスタイルの両方で使用することも、2つの要素を混在させることもできます。高階関数、関数型、ラムダなどの機能をファーストクラスでサポートするKotlinは、関数型プログラミングを行っている、または探索している場合に最適です。</target>
        </trans-unit>
        <trans-unit id="d0b80a6eafa346308b4f2ffbb72d503567999d28" translate="yes" xml:space="preserve">
          <source>Kotlin has classes and their members &lt;code&gt;final&lt;/code&gt; by default, which makes it inconvenient to use frameworks and libraries such as Spring AOP that require classes to be &lt;code&gt;open&lt;/code&gt;. The &lt;em&gt;all-open&lt;/em&gt; compiler plugin adapts Kotlin to the requirements of those frameworks and makes classes annotated with a specific annotation and their members open without the explicit &lt;code&gt;open&lt;/code&gt; keyword.</source>
          <target state="translated">Kotlinにはデフォルトで &lt;code&gt;final&lt;/code&gt; クラスとそのメンバーがあるため、Spring AOPなどのクラスが &lt;code&gt;open&lt;/code&gt; ている必要があるフレームワークやライブラリを使用するのは不便です。&lt;em&gt;すべてのオープン&lt;/em&gt;コンパイラプラグインは、これらのフレームワークの要件にKotlinを適応し、特定のアノテーションを付けたクラスを作り、そのメンバーは、明示的に使われていないオープン &lt;code&gt;open&lt;/code&gt; キーワード。</target>
        </trans-unit>
        <trans-unit id="b816faaaa048d52b55167846f58533c82dcf332c" translate="yes" xml:space="preserve">
          <source>Kotlin has got its own reflection library (&lt;code&gt;kotlin-reflect.jar&lt;/code&gt; must be included in your build). When targeting the JVM, you can also use the Java reflection facilities. Note that the Kotlin reflection isn't quite feature-complete yet - in particular, you can't use it to inspect built-in classes like &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">Kotlinには独自のリフレクションライブラリがあります（ &lt;code&gt;kotlin-reflect.jar&lt;/code&gt; 必要があります）。JVMをターゲットとする場合、Javaリフレクション機能も使用できます。Kotlinリフレクションはまだ機能が完全ではないことに注意してください。特に、これを使用して &lt;code&gt;String&lt;/code&gt; などの組み込みクラスを検査することはできません。</target>
        </trans-unit>
        <trans-unit id="89599a2b8afb959091521970edd698c7f8696cca" translate="yes" xml:space="preserve">
          <source>Kotlin has inherited Java's fidgety (but very flexible) way of doing I/O, but with some simplifying extra features. We won't get into all of it here, so for starters, this is how to iterate through all the lines of a file (you'll need &lt;code&gt;import java.io.File&lt;/code&gt;):</source>
          <target state="translated">Kotlinは、I / Oを実行するJavaの手間のかかる（ただし非常に柔軟な）方法を継承していますが、いくつかの単純化された追加機能があります。ここではすべてを説明するわけではないので、最初に、これはファイルのすべての行を反復処理する方法です（ &lt;code&gt;import java.io.File&lt;/code&gt; が必要です）。</target>
        </trans-unit>
        <trans-unit id="789ece85cba2d7c5232dc414bc11dc159641da4f" translate="yes" xml:space="preserve">
          <source>Kotlin has inherited Java's fidgety array system, so primitive types have got their own array types and conversion functions, while any other type uses the generic &lt;code&gt;Array&lt;/code&gt; type, to which you can convert with &lt;code&gt;.toTypedArray()&lt;/code&gt;.</source>
          <target state="translated">KotlinはJavaのフィジー配列システムを継承しているため、プリミティブ型には独自の配列型と変換関数があり、他の型は &lt;code&gt;.toTypedArray()&lt;/code&gt; で変換できる汎用の &lt;code&gt;Array&lt;/code&gt; 型を使用しています。</target>
        </trans-unit>
        <trans-unit id="99a77fa93b5373d975ec4157225559f8cd6c6cb3" translate="yes" xml:space="preserve">
          <source>Kotlin has no concept of checked exceptions, all Kotlin exceptions are unchecked. Swift has only checked errors. So if Swift or Objective-C code calls a Kotlin method which throws an exception to be handled, then the Kotlin method should be marked with a &lt;code&gt;@Throws&lt;/code&gt; annotation specifying a list of &quot;expected&quot; exception classes.</source>
          <target state="translated">Kotlinにはチェックされた例外の概念がなく、すべてのKotlin例外はチェックされていません。Swiftはエラーのみをチェックしました。したがって、SwiftまたはObjective-Cコードが処理する例外をスローするKotlinメソッドを呼び出す場合、Kotlinメソッドは、「予期される」例外クラスのリストを指定する &lt;code&gt;@Throws&lt;/code&gt; アノテーションでマークする必要があります。</target>
        </trans-unit>
        <trans-unit id="2e626b593df468862004f3cb251d2e1710f0e139" translate="yes" xml:space="preserve">
          <source>Kotlin has no concept of checked exceptions, all Kotlin exceptions are unchecked. Swift has only checked errors. So if Swift or Objective-C code calls a Kotlin method which throws an exception to be handled, then the Kotlin method should be marked with a &lt;code&gt;@Throws&lt;/code&gt; annotation. In this case all Kotlin exceptions (except for instances of &lt;code&gt;Error&lt;/code&gt;, &lt;code&gt;RuntimeException&lt;/code&gt; and subclasses) are translated into a Swift error/&lt;code&gt;NSError&lt;/code&gt;.</source>
          <target state="translated">Kotlinにはチェック済み例外の概念はありません。すべてのKotlin例外はチェックされていません。 Swiftがチェックしたのはエラーのみです。したがって、SwiftまたはObjective-Cのコードが、処理する例外をスローするKotlinメソッドを呼び出す場合、Kotlinメソッドは &lt;code&gt;@Throws&lt;/code&gt; アノテーションでマークする必要があります。この場合、すべてのKotlin例外（ &lt;code&gt;Error&lt;/code&gt; 、 &lt;code&gt;RuntimeException&lt;/code&gt; 、およびサブクラスのインスタンスを除く）はSwift error / &lt;code&gt;NSError&lt;/code&gt; に変換されます。</target>
        </trans-unit>
        <trans-unit id="178ebff753223a76976f1b5505609a06e7a0941e" translate="yes" xml:space="preserve">
          <source>Kotlin has now the option of generating Java 8 bytecode (&lt;code&gt;-jvm-target 1.8&lt;/code&gt; command line option or the corresponding options in Ant/Maven/Gradle). For now this doesn't change the semantics of the bytecode (in particular, default methods in interfaces and lambdas are generated exactly as in Kotlin 1.0), but we plan to make further use of this later.</source>
          <target state="translated">Kotlinには、Java 8バイトコードを生成するオプションがあります（ &lt;code&gt;-jvm-target 1.8&lt;/code&gt; コマンドラインオプション、またはAnt / Maven / Gradleの対応するオプション）。現時点では、これはバイトコードのセマンティクスを変更しません（特に、インターフェースとラムダのデフォルトメソッドはKotlin 1.0とまったく同じように生成されます）が、これは後でさらに使用する予定です。</target>
        </trans-unit>
        <trans-unit id="1b256a14cb898b1876ca682918ab4726ae689547" translate="yes" xml:space="preserve">
          <source>Kotlin has proper &lt;a href=&quot;lambdas#function-types&quot;&gt;function types&lt;/a&gt;, as opposed to Java's SAM-conversions</source>
          <target state="translated">JavaのSAM変換ではなく、Kotlinには適切な&lt;a href=&quot;lambdas#function-types&quot;&gt;関数型&lt;/a&gt;があります。</target>
        </trans-unit>
        <trans-unit id="21d65ae753898818d1cd1395d2b3d50ce49c4d34" translate="yes" xml:space="preserve">
          <source>Kotlin has three structural jump expressions:</source>
          <target state="translated">Kotlinには3つの構造的なジャンプ表現があります。</target>
        </trans-unit>
        <trans-unit id="8fab1b92010786ac4e42e500d9dbd613684af3aa" translate="yes" xml:space="preserve">
          <source>Kotlin has two types of string literals: escaped strings that may have escaped characters in them and raw strings that can contain newlines and arbitrary text. An escaped string is very much like a Java string:</source>
          <target state="translated">Kotlinには2種類の文字列リテラルがあります:エスケープ文字を含む可能性のあるエスケープ文字列と、改行や任意のテキストを含む可能性のある生の文字列です。エスケープされた文字列はJavaの文字列と非常によく似ています。</target>
        </trans-unit>
        <trans-unit id="88377cf789dc237868418b003f1376d4a4fb9cfb" translate="yes" xml:space="preserve">
          <source>Kotlin has two types of string literals: escaped strings that may have escaped characters in them and raw strings that can contain newlines and arbitrary text. Here's an example of an escaped string:</source>
          <target state="translated">Kotlinには2種類の文字列リテラルがあります:エスケープされた文字が含まれている可能性のあるエスケープ文字列と、改行や任意のテキストを含む可能性のある生の文字列です。以下にエスケープされた文字列の例を示します。</target>
        </trans-unit>
        <trans-unit id="7c53d6c43db7159858e1b06d40910057344f857d" translate="yes" xml:space="preserve">
          <source>Kotlin in Action</source>
          <target state="translated">アクションのコトリン</target>
        </trans-unit>
        <trans-unit id="897dddb8bded8aacac7c4f7f6865ba43edeed083" translate="yes" xml:space="preserve">
          <source>Kotlin introduces following types for unsigned integers:</source>
          <target state="translated">Kotlinでは、符号なし整数の型を以下のように紹介しています。</target>
        </trans-unit>
        <trans-unit id="1162e3ef7e5343b47c0a5de3586b0dd6d01591ce" translate="yes" xml:space="preserve">
          <source>Kotlin is a compiled, statically typed language, which might provide some initial hurdles for people who are used to the interpreted, dynamically typed Python. This document aims to explain a substantial portion of Kotlin's syntax and concepts in terms of how they compare to corresponding concepts in Python.</source>
          <target state="translated">Kotlin はコンパイルされた静的型付けされた言語であり、解釈された動的型付けされた Python に慣れている人にとっては最初のハードルとなるかもしれません。このドキュメントでは、Kotlin の構文と概念のかなりの部分を、Python の対応する概念と比較して説明することを目的としています。</target>
        </trans-unit>
        <trans-unit id="640ddadf7e88f55374061d5998c2bee5a53626f4" translate="yes" xml:space="preserve">
          <source>Kotlin is a great fit for developing Android applications, bringing all of the advantages of a modern language to the Android platform without introducing any new restrictions:</source>
          <target state="translated">KotlinはAndroidアプリケーションの開発に最適で、新しい制限を導入することなく、現代の言語の利点をすべてAndroidプラットフォームにもたらします。</target>
        </trans-unit>
        <trans-unit id="b1f1b3f12f705373f46ad38b06f457675f0bb145" translate="yes" xml:space="preserve">
          <source>Kotlin is a great fit for developing server-side applications, allowing you to write concise and expressive code while maintaining full compatibility with existing Java-based technology stacks and a smooth learning curve:</source>
          <target state="translated">Kotlinはサーバーサイドアプリケーションの開発に最適で、既存のJavaベースのテクノロジースタックとの完全な互換性を維持しながら、簡潔で表現力豊かなコードを書くことができ、スムーズな学習曲線を実現します。</target>
        </trans-unit>
        <trans-unit id="942fb98d86e153b0e83fe0d61de04cbccacbe8f7" translate="yes" xml:space="preserve">
          <source>Kotlin is a pragmatic and unopinionated language, supporting both imperative and function programming styles without pushing the developer towards either one. We can implement the function &lt;code&gt;f&lt;/code&gt; in functional style, using such Kotlin features as &lt;a href=&quot;../reference/functions#tail-recursive-functions&quot;&gt;tail recursion&lt;/a&gt;:</source>
          <target state="translated">Kotlinは実用的で根拠のない言語であり、開発者をどちらかに向けることなく、命令型と関数型のプログラミングスタイルの両方をサポートします。このようなKotlin機能を&lt;a href=&quot;../reference/functions#tail-recursive-functions&quot;&gt;末尾再帰&lt;/a&gt;として使用して、関数 &lt;code&gt;f&lt;/code&gt; を関数スタイルで実装できます。</target>
        </trans-unit>
        <trans-unit id="c0d8f4fd81a58ee08fc7afcc5cfdb0b02c31ab79" translate="yes" xml:space="preserve">
          <source>Kotlin is a statically typed language, which makes it different from the dynamically typed JavaScript. In order to facilitate interoperation with JavaScript code, Kotlin/JS offers the &lt;code&gt;dynamic&lt;/code&gt; type:</source>
          <target state="translated">Kotlinは静的に型付けされた言語であるため、動的に型付けされたJavaScriptとは異なります。JavaScriptコードとの相互運用を容易にするために、Kotlin / JSは &lt;code&gt;dynamic&lt;/code&gt; タイプを提供します。</target>
        </trans-unit>
        <trans-unit id="f033af0ab747811276c086c79a9bfc947c92c7d6" translate="yes" xml:space="preserve">
          <source>Kotlin is an OSS statically typed programming language that targets the JVM, Android, JavaScript and Native. It&amp;rsquo;s developed by &lt;a href=&quot;http://www.jetbrains.com&quot;&gt;JetBrains&lt;/a&gt;. The project started in 2010 and was open source from very early on. The first official 1.0 release was in February 2016.</source>
          <target state="translated">Kotlinは、JVM、Android、JavaScript、およびネイティブを対象とするOSS静的型付けプログラミング言語です。&lt;a href=&quot;http://www.jetbrains.com&quot;&gt;JetBrains&lt;/a&gt;によって開発されました。プロジェクトは2010年に開始され、当初からオープンソースでした。最初の公式1.0リリースは2016年2月でした。</target>
        </trans-unit>
        <trans-unit id="654d332c5c16069d8e33851920e04af4ba1633e6" translate="yes" xml:space="preserve">
          <source>Kotlin is an open-source statically typed programming language that targets the JVM, Android, JavaScript and Native. It&amp;rsquo;s developed by &lt;a href=&quot;http://www.jetbrains.com&quot;&gt;JetBrains&lt;/a&gt;. The project started in 2010 and was open source from very early on. The first official 1.0 release was in February 2016.</source>
          <target state="translated">Kotlinは、JVM、Android、JavaScript、およびネイティブを対象とするオープンソースの静的型付けプログラミング言語です。&lt;a href=&quot;http://www.jetbrains.com&quot;&gt;JetBrains&lt;/a&gt;によって開発されました。プロジェクトは2010年に開始され、非常に早い段階からオープンソースでした。最初の公式1.0リリースは2016年2月でした。</target>
        </trans-unit>
        <trans-unit id="d9537d803964341dc28f1f4951da5b348b7b611e" translate="yes" xml:space="preserve">
          <source>Kotlin is compatible with CommonJS, AMD and UMD, &lt;a href=&quot;../tutorials/javascript/working-with-modules/working-with-modules&quot;&gt;making interaction with different&lt;/a&gt; module systems straightforward.</source>
          <target state="translated">KotlinはCommonJS、AMD、UMDと互換性があり、&lt;a href=&quot;../tutorials/javascript/working-with-modules/working-with-modules&quot;&gt;さまざまな&lt;/a&gt;モジュールシステムと簡単にやり取りできます。</target>
        </trans-unit>
        <trans-unit id="2c3ca5bc7aa971f25976aff86462ee8c65c9cb7e" translate="yes" xml:space="preserve">
          <source>Kotlin is designed to be a pragmatic tool for programmers. When it comes to language evolution, its pragmatic nature is captured by the following principles:</source>
          <target state="translated">Kotlinはプログラマのための実用的なツールとして設計されています。言語の進化に関して言えば、そのプラグマティックな性質は以下の原則によって捉えられています。</target>
        </trans-unit>
        <trans-unit id="93c08e581c43a4ec4822d841d4ddc6b6324821eb" translate="yes" xml:space="preserve">
          <source>Kotlin is designed to be easy to learn for people who already know Java. A quick overview of differences is given on &lt;a href=&quot;../reference/comparison-to-java&quot;&gt;the official comparison page&lt;/a&gt;. A short introduction to the basic syntax of Kotlin for software developers can be found directly in the reference section of the web site starting from &lt;a href=&quot;../reference/basic-syntax&quot;&gt;basic syntax&lt;/a&gt;.</source>
          <target state="translated">Kotlinは、Javaをすでに知っている人が簡単に習得できるように設計されています。違いの概要については&lt;a href=&quot;../reference/comparison-to-java&quot;&gt;、公式の比較ページをご覧ください&lt;/a&gt;。ソフトウェア開発者向けのKotlinの基本構文の簡単な紹介は、基本構文から始まるWebサイトのリファレンスセクションに直接あり&lt;a href=&quot;../reference/basic-syntax&quot;&gt;ます&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="76527281e23251ab9b22562a01f9e2381d26e878" translate="yes" xml:space="preserve">
          <source>Kotlin is designed with Java Interoperability in mind. Existing Java code can be called from Kotlin in a natural way, and Kotlin code can be used from Java rather smoothly as well. In this section we describe some details about calling Java code from Kotlin.</source>
          <target state="translated">KotlinはJavaとの相互運用性を考慮して設計されています。既存のJavaコードをKotlinから自然な形で呼び出すことができ、KotlinのコードはJavaからもスムーズに利用することができます。ここでは、KotlinからJavaコードを呼び出す方法について詳しく説明します。</target>
        </trans-unit>
        <trans-unit id="b1117330525358e715dea7a8875981cd28a616bf" translate="yes" xml:space="preserve">
          <source>Kotlin is distributed with &lt;code&gt;kotlin.js&lt;/code&gt; standard library as a single file, which is itself compiled as an UMD module, so you can use it with any module system described above. Also it is available on NPM as &lt;a href=&quot;https://www.npmjs.com/package/kotlin&quot;&gt;&lt;code&gt;kotlin&lt;/code&gt; package&lt;/a&gt;</source>
          <target state="translated">Kotlinは、 &lt;code&gt;kotlin.js&lt;/code&gt; 標準ライブラリとともに単一ファイルとして配布され、それ自体がUMDモジュールとしてコンパイルされるため、上記の任意のモジュールシステムで使用できます。また、NPMでは&lt;a href=&quot;https://www.npmjs.com/package/kotlin&quot;&gt; &lt;code&gt;kotlin&lt;/code&gt; &lt;/a&gt;パッケージとしても利用できます</target>
        </trans-unit>
        <trans-unit id="d0a18e9cef9fc2a234c1d159c10281aea5af17fa" translate="yes" xml:space="preserve">
          <source>Kotlin is distributed with the Kotlin/JS standard library as a single file, which is itself compiled as an UMD module, so you can use it with any module system described above. While for most use cases of Kotlin/JS, it is recommended to use a Gradle dependency on &lt;code&gt;kotlin-stdlib-js&lt;/code&gt;, it is also available on NPM as the &lt;a href=&quot;https://www.npmjs.com/package/kotlin&quot;&gt;&lt;code&gt;kotlin&lt;/code&gt;&lt;/a&gt; package.</source>
          <target state="translated">Kotlinは、Kotlin / JS標準ライブラリとともに単一のファイルとして配布されます。このファイル自体はUMDモジュールとしてコンパイルされるため、上記の任意のモジュールシステムで使用できます。Kotlin / JSのほとんどのユースケースでは、 &lt;code&gt;kotlin-stdlib-js&lt;/code&gt; へのGradle依存関係を使用することをお勧めしますが、NPMでは&lt;a href=&quot;https://www.npmjs.com/package/kotlin&quot;&gt; &lt;code&gt;kotlin&lt;/code&gt; &lt;/a&gt;パッケージとしても利用できます。</target>
        </trans-unit>
        <trans-unit id="0bb12b617173b78ae2213fea703120a48dac83b8" translate="yes" xml:space="preserve">
          <source>Kotlin is inspired by existing languages such as Java, C#, JavaScript, Scala and Groovy. We've tried to ensure that Kotlin is easy to learn, so that people can easily jump on board, reading and writing Kotlin in a matter of days. Learning idiomatic Kotlin and using some more of its advanced features can take a little longer, but overall it is not a complicated language.</source>
          <target state="translated">Kotlinは、Java、C#、JavaScript、Scala、Groovyなどの既存の言語に触発されています。私たちは、Kotlinが簡単に学べるように心がけていますので、数日でKotlinを読み書きできるようになります。慣用的なKotlinの学習や高度な機能を使うには少し時間がかかるかもしれませんが、全体的には複雑な言語ではありません。</target>
        </trans-unit>
        <trans-unit id="62c8094d2f49ea185993571453009f8f90b8b387" translate="yes" xml:space="preserve">
          <source>Kotlin is more concise. Rough estimates indicate approximately a 40% cut in the number of lines of code. It&amp;rsquo;s also more type-safe, e.g. support for non-nullable types makes applications less prone to NPE&amp;rsquo;s. Other features including smart casting, higher-order functions, extension functions and lambdas with receivers provide the ability to write expressive code as well as facilitating creation of DSL.</source>
          <target state="translated">Kotlinはより簡潔です。概算では、コードの行数が約40％削減されています。また、タイプセーフです。たとえば、null可能でない型のサポートにより、アプリケーションがNPEになりにくくなります。スマートキャスティング、高次関数、拡張関数、レシーバー付きのラムダなどの他の機能により、表現力豊かなコードを記述し、DSLの作成を容易にすることができます。</target>
        </trans-unit>
        <trans-unit id="57ebc857aaa4fe4ee76557729aedd97eb250b716" translate="yes" xml:space="preserve">
          <source>Kotlin is primarily developed by a team of engineers at JetBrains (current team size is 100+). The lead language designer is &lt;a href=&quot;https://twitter.com/abreslav&quot;&gt;Andrey Breslav&lt;/a&gt;. In addition to the core team, there are also over 250 external contributors on GitHub.</source>
          <target state="translated">Kotlinは、主にJetBrainsのエンジニアチームによって開発されています（現在のチームサイズは100以上です）。主な言語デザイナーは&lt;a href=&quot;https://twitter.com/abreslav&quot;&gt;AndreyBreslav&lt;/a&gt;です。コアチームに加えて、GitHubには250人を超える外部の貢献者もいます。</target>
        </trans-unit>
        <trans-unit id="8a6891160d562ed8798489fdde041cf7382a9267" translate="yes" xml:space="preserve">
          <source>Kotlin is primarily developed by a team of engineers at JetBrains (current team size is 50+). The lead language designer is &lt;a href=&quot;https://twitter.com/abreslav&quot;&gt;Andrey Breslav&lt;/a&gt;. In addition to the core team, there are also over 250 external contributors on GitHub.</source>
          <target state="translated">Kotlinは主にJetBrainsのエンジニアのチームによって開発されています（現在のチームサイズは50歳以上）。主要言語デザイナーは&lt;a href=&quot;https://twitter.com/abreslav&quot;&gt;Andrey Breslav&lt;/a&gt;です。コアチームに加えて、GitHubには250人を超える外部の寄稿者がいます。</target>
        </trans-unit>
        <trans-unit id="e252e4cd43e2222ef996694efabbf2a368b1568c" translate="yes" xml:space="preserve">
          <source>Kotlin is supported by all major Java IDEs including &lt;a href=&quot;../tutorials/getting-started&quot;&gt;IntelliJ IDEA&lt;/a&gt;, &lt;a href=&quot;../tutorials/kotlin-android&quot;&gt;Android Studio&lt;/a&gt;, &lt;a href=&quot;../tutorials/getting-started-eclipse&quot;&gt;Eclipse&lt;/a&gt; and &lt;a href=&quot;http://plugins.netbeans.org/plugin/68590/kotlin&quot;&gt;NetBeans&lt;/a&gt;. In addition, a &lt;a href=&quot;../tutorials/command-line&quot;&gt;command line compiler&lt;/a&gt; is available and provides straightforward support for compiling and running applications.</source>
          <target state="translated">Kotlinは、&lt;a href=&quot;../tutorials/getting-started&quot;&gt;IntelliJ IDEA&lt;/a&gt;、&lt;a href=&quot;../tutorials/kotlin-android&quot;&gt;Android Studio&lt;/a&gt;、&lt;a href=&quot;../tutorials/getting-started-eclipse&quot;&gt;Eclipse&lt;/a&gt;、&lt;a href=&quot;http://plugins.netbeans.org/plugin/68590/kotlin&quot;&gt;NetBeans&lt;/a&gt;を含むすべての主要なJava IDEでサポートされています。さらに、&lt;a href=&quot;../tutorials/command-line&quot;&gt;コマンドラインコンパイラ&lt;/a&gt;を利用でき、アプリケーションのコンパイルと実行を簡単にサポートできます。</target>
        </trans-unit>
        <trans-unit id="8b9c46bf1ad2fe2fbc414ecfb85cf4b65bec1ff6" translate="yes" xml:space="preserve">
          <source>Kotlin is supported by all major Java IDEs including &lt;a href=&quot;../tutorials/jvm-get-started&quot;&gt;IntelliJ IDEA&lt;/a&gt;, &lt;a href=&quot;https://developer.android.com/kotlin/get-started&quot;&gt;Android Studio&lt;/a&gt;, &lt;a href=&quot;../tutorials/getting-started-eclipse&quot;&gt;Eclipse&lt;/a&gt; and &lt;a href=&quot;http://plugins.netbeans.org/plugin/68590/kotlin&quot;&gt;NetBeans&lt;/a&gt;. In addition, a &lt;a href=&quot;../tutorials/command-line&quot;&gt;command line compiler&lt;/a&gt; is available and provides straightforward support for compiling and running applications.</source>
          <target state="translated">Kotlinは、&lt;a href=&quot;../tutorials/jvm-get-started&quot;&gt;IntelliJ IDEA&lt;/a&gt;、&lt;a href=&quot;https://developer.android.com/kotlin/get-started&quot;&gt;Android Studio&lt;/a&gt;、&lt;a href=&quot;../tutorials/getting-started-eclipse&quot;&gt;Eclipse&lt;/a&gt;、&lt;a href=&quot;http://plugins.netbeans.org/plugin/68590/kotlin&quot;&gt;NetBeans&lt;/a&gt;を含むすべての主要なJavaIDEでサポートされています。さらに、&lt;a href=&quot;../tutorials/command-line&quot;&gt;コマンドラインコンパイラ&lt;/a&gt;が利用可能であり、アプリケーションのコンパイルと実行を簡単にサポートします。</target>
        </trans-unit>
        <trans-unit id="38b8eb152c426ee3fe939706153705b8354595aa" translate="yes" xml:space="preserve">
          <source>Kotlin is well covered in online courses, check out recommended courses here:</source>
          <target state="translated">Kotlinはオンラインコースでもしっかりとカバーしていますので、おすすめのコースはこちらからチェックしてみてください。</target>
        </trans-unit>
        <trans-unit id="f6275eeb32172070d309b650be85e7156b1c7dc9" translate="yes" xml:space="preserve">
          <source>Kotlin lets you choose the version of JVM for execution. By default, the Kotlin/JVM compiler produces Java 6 compatible bytecode. If you want to make use of optimizations available in newer versions of Java, you can explicitly specify the target Java version from 8 to 13. Note that in this case the resulting bytecode might not run on lower versions.</source>
          <target state="translated">Kotlinでは、実行するJVMのバージョンを選択することができます。デフォルトでは、Kotlin/JVMコンパイラはJava 6互換のバイトコードを生成します。新しいバージョンのJavaで利用できる最適化を利用したい場合は、ターゲットとなるJavaのバージョンを8から13の間で明示的に指定することができます。この場合、生成されたバイトコードはそれ以下のバージョンでは動作しないかもしれないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="47b75c21f1512e55023917a6b77552862460e120" translate="yes" xml:space="preserve">
          <source>Kotlin lets you easily create ranges of values using the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/range-to&quot;&gt;&lt;code&gt;rangeTo()&lt;/code&gt;&lt;/a&gt; function from the &lt;code&gt;kotlin.ranges&lt;/code&gt; package and its operator form &lt;code&gt;..&lt;/code&gt;. Usually, &lt;code&gt;rangeTo()&lt;/code&gt; is complemented by &lt;code&gt;in&lt;/code&gt; or &lt;code&gt;!in&lt;/code&gt; functions.</source>
          <target state="translated">Kotlinは、あなたが簡単に使用して値の範囲を作成することができます&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/range-to&quot;&gt; &lt;code&gt;rangeTo()&lt;/code&gt; &lt;/a&gt;から関数 &lt;code&gt;kotlin.ranges&lt;/code&gt; のパッケージとそのオペレータのフォームを &lt;code&gt;..&lt;/code&gt; .。通常、 &lt;code&gt;rangeTo()&lt;/code&gt; によって補完される &lt;code&gt;in&lt;/code&gt; または &lt;code&gt;!in&lt;/code&gt; 機能します。</target>
        </trans-unit>
        <trans-unit id="ceee386e40b3b46c69160d750c22ce62d0c3f184" translate="yes" xml:space="preserve">
          <source>Kotlin lets you manipulate collections independently of the exact type of objects stored in them. In other words, you add a &lt;code&gt;String&lt;/code&gt; to a list of &lt;code&gt;String&lt;/code&gt;s the same way as you would do with &lt;code&gt;Int&lt;/code&gt;s or a user-defined class. So, the Kotlin Standard Library offers generic interfaces, classes, and functions for creating, populating, and managing collections of any type.</source>
          <target state="translated">Kotlinでは、コレクションに格納されているオブジェクトの正確なタイプとは関係なく、コレクションを操作できます。言い換えれば、あなたは追加 &lt;code&gt;String&lt;/code&gt; リストに &lt;code&gt;String&lt;/code&gt; あなたがするだろうとの同様 &lt;code&gt;Int&lt;/code&gt; Sまたはユーザー定義クラス。したがって、Kotlin標準ライブラリは、あらゆるタイプのコレクションを作成、入力、および管理するための汎用インターフェイス、クラス、および関数を提供します。</target>
        </trans-unit>
        <trans-unit id="8bb9f52709d9b5cdac5f51755d862ecbca9c415c" translate="yes" xml:space="preserve">
          <source>Kotlin metadata</source>
          <target state="translated">Kotlin メタデータ</target>
        </trans-unit>
        <trans-unit id="0e7ef1544d45f6a307acf242d3ddb29c611697ae" translate="yes" xml:space="preserve">
          <source>Kotlin modules can be used in Swift/Objective-C code if compiled into a framework (see &quot;Targets and output kinds&quot; section in &lt;a href=&quot;gradle_plugin#targets-and-output-kinds&quot;&gt;Gradle plugin documentation&lt;/a&gt;). See &lt;a href=&quot;https://github.com/JetBrains/kotlin-native/tree/master/samples/calculator&quot;&gt;calculator sample&lt;/a&gt; for an example.</source>
          <target state="translated">Kotlinモジュールは、フレームワークにコンパイルされている場合、Swift / Objective-Cコードで使用できます（&lt;a href=&quot;gradle_plugin#targets-and-output-kinds&quot;&gt;Gradleプラグインのドキュメントの&lt;/a&gt;「ターゲットと出力の種類」セクションを参照）。例については、&lt;a href=&quot;https://github.com/JetBrains/kotlin-native/tree/master/samples/calculator&quot;&gt;電卓のサンプル&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="a0c9d0d836710fc155aae7ff2099c119f8b8ff3b" translate="yes" xml:space="preserve">
          <source>Kotlin now integrates with the &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/javax/script/package-summary.html&quot;&gt;javax.script API&lt;/a&gt; (JSR-223). The API allows to evaluate snippets of code at runtime:</source>
          <target state="translated">Kotlinが&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/javax/script/package-summary.html&quot;&gt;javax.script API&lt;/a&gt;（JSR-223）と統合されるようになりました。APIを使用すると、実行時にコードのスニペットを評価できます。</target>
        </trans-unit>
        <trans-unit id="5917b5d1de587466aad2c24c7e35497e2343f72e" translate="yes" xml:space="preserve">
          <source>Kotlin now supports storing parameter names in the bytecode. This can be enabled using the &lt;code&gt;-java-parameters&lt;/code&gt; command line option.</source>
          <target state="translated">Kotlinは、バイトコードへのパラメーター名の格納をサポートするようになりました。これは、 &lt;code&gt;-java-parameters&lt;/code&gt; コマンドラインオプションを使用して有効にできます。</target>
        </trans-unit>
        <trans-unit id="900f5e70ca199686eb62d660ad48f2ce1610ab30" translate="yes" xml:space="preserve">
          <source>Kotlin numeric types, except for &lt;code&gt;kotlin.Long&lt;/code&gt; are mapped to JavaScript Number.</source>
          <target state="translated">&lt;code&gt;kotlin.Long&lt;/code&gt; を除くKotlin数値型は、JavaScript番号にマップされます。</target>
        </trans-unit>
        <trans-unit id="fa0f528e5b1ad066646e40d867c682edc345e3d1" translate="yes" xml:space="preserve">
          <source>Kotlin objects could be pinned, i.e. their position in memory is guaranteed to be stable until unpinned, and pointers to such objects inner data could be passed to the C functions. For example</source>
          <target state="translated">Kotlin オブジェクトを固定することができます。つまり、固定されていない状態になるまでメモリ上での位置が安定していることが保証されており、そのようなオブジェクトの内部データへのポインタを C 関数に渡すことができます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="23971a8580dfc32441ac3140ce5ff12ac8ef11bf" translate="yes" xml:space="preserve">
          <source>Kotlin plugin 1.3.21 or higher should be installed in the IDE. This can be verified via &lt;em&gt;Language &amp;amp; Frameworks | Kotlin Updates&lt;/em&gt; section in the &lt;em&gt;Settings&lt;/em&gt; (or &lt;em&gt;Preferences&lt;/em&gt;) of the IDE.</source>
          <target state="translated">IDEにはKotlinプラグイン1.3.21以降がインストールされている必要があります。&lt;em&gt;言語とフレームワークで&lt;/em&gt;確認できます&lt;em&gt;| &lt;/em&gt;IDEの&lt;em&gt;[設定]&lt;/em&gt;（または&lt;em&gt;[設定&lt;/em&gt;&lt;em&gt;]&lt;/em&gt;）の&lt;em&gt;Kotlin更新&lt;/em&gt;セクション。</target>
        </trans-unit>
        <trans-unit id="446a5a46278f3d1273d1c8d81bcdc944823353d2" translate="yes" xml:space="preserve">
          <source>Kotlin plugin for IntelliJ IDEA supports &lt;a href=&quot;https://www.jetbrains.com/help/idea/scratches.html&quot;&gt;scratches&lt;/a&gt;. Scratches let you create code drafts in the same IDE window with your project and run them on the fly. Scratches are not tied to projects; you can access and run all your scratches from any IntelliJ IDEA window on your OS.</source>
          <target state="translated">IntelliJ IDEAのKotlinプラグインは&lt;a href=&quot;https://www.jetbrains.com/help/idea/scratches.html&quot;&gt;スクラッチを&lt;/a&gt;サポートしています。スクラッチを使用すると、プロジェクトと同じIDEウィンドウでコードドラフトを作成し、その場で実行できます。スクラッチはプロジェクトに関連付けられていません。OSのIntelliJ IDEAウィンドウからすべてのスクラッチにアクセスして実行できます。</target>
        </trans-unit>
        <trans-unit id="bf764bc84647534de5f2a7804f4aa2d9d548f9f9" translate="yes" xml:space="preserve">
          <source>Kotlin preserves lazy object initialization in JavaScript.</source>
          <target state="translated">Kotlin は JavaScript での遅延オブジェクトの初期化を保持します。</target>
        </trans-unit>
        <trans-unit id="69aede4d1ffe657e5907011bd8394bcc0601690e" translate="yes" xml:space="preserve">
          <source>Kotlin preserves overflow semantics for &lt;code&gt;kotlin.Int&lt;/code&gt;, &lt;code&gt;kotlin.Byte&lt;/code&gt;, &lt;code&gt;kotlin.Short&lt;/code&gt;, &lt;code&gt;kotlin.Char&lt;/code&gt; and &lt;code&gt;kotlin.Long&lt;/code&gt;.</source>
          <target state="translated">Kotlinはオーバーフロー用のセマンティクス保存し &lt;code&gt;kotlin.Int&lt;/code&gt; 、 &lt;code&gt;kotlin.Byte&lt;/code&gt; 、 &lt;code&gt;kotlin.Short&lt;/code&gt; 、 &lt;code&gt;kotlin.Char&lt;/code&gt; と &lt;code&gt;kotlin.Long&lt;/code&gt; を。</target>
        </trans-unit>
        <trans-unit id="2849a08507ed289fb75d76677103722db661daba" translate="yes" xml:space="preserve">
          <source>Kotlin primitive type boxes are mapped to special Swift/Objective-C classes. For example, &lt;code&gt;kotlin.Int&lt;/code&gt; box is represented as &lt;code&gt;KotlinInt&lt;/code&gt; class instance in Swift (or &lt;code&gt;${prefix}Int&lt;/code&gt; instance in Objective-C, where &lt;code&gt;prefix&lt;/code&gt; is the framework names prefix). These classes are derived from &lt;code&gt;NSNumber&lt;/code&gt;, so the instances are proper &lt;code&gt;NSNumber&lt;/code&gt;s supporting all corresponding operations.</source>
          <target state="translated">Kotlinプリミティブ型ボックスは、特別なSwift / Objective-Cクラスにマップされます。たとえば、 &lt;code&gt;kotlin.Int&lt;/code&gt; ボックスは、Swift &lt;code&gt;KotlinInt&lt;/code&gt; クラスインスタンス（またはObjective-Cでは &lt;code&gt;${prefix}Int&lt;/code&gt; インスタンス、 &lt;code&gt;prefix&lt;/code&gt; はフレームワーク名のプレフィックス）として表されます。これらのクラスは &lt;code&gt;NSNumber&lt;/code&gt; から派生しているため、インスタンスは対応するすべての操作をサポートする適切な &lt;code&gt;NSNumber&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="a7ceca5755070f2e75db1f8f41e2c1a411bf045a" translate="yes" xml:space="preserve">
          <source>Kotlin primitive types</source>
          <target state="translated">コトリン基本型</target>
        </trans-unit>
        <trans-unit id="56d4abf280a1b7394ae7fdfbb57bfe9eaca646d5" translate="yes" xml:space="preserve">
          <source>Kotlin properties declared in a named object or a companion object will have static backing fields either in that named object or in the class containing the companion object.</source>
          <target state="translated">名前付きオブジェクトやコンパニオンオブジェクトで宣言されたKotlinプロパティは、その名前付きオブジェクトかコンパニオンオブジェクトを含むクラスのどちらかに静的なバッキングフィールドを持ちます。</target>
        </trans-unit>
        <trans-unit id="cf2e0c6a8a702a4b4cb47d5f81663fe43b024e43" translate="yes" xml:space="preserve">
          <source>Kotlin provides a series of compiler options that are accessible in IntelliJ IDEA also. In addition to the one we've just seen for generating source maps, we also have the ability to set</source>
          <target state="translated">Kotlinには、IntelliJ IDEAでもアクセス可能な一連のコンパイラオプションが用意されています。先ほど見たソースマップを生成するためのものの他にも</target>
        </trans-unit>
        <trans-unit id="e2142c523bbfdb03dd37f333a0ce0922e05e00a3" translate="yes" xml:space="preserve">
          <source>Kotlin provides a set of built-in types that represent numbers.</source>
          <target state="translated">Kotlinは数値を表す組み込み型のセットを提供しています。</target>
        </trans-unit>
        <trans-unit id="0a113f99eec74b4131a54c5b784be8df823aef27" translate="yes" xml:space="preserve">
          <source>Kotlin provides a variety of functions to execute a block of code in the context of a given object: &lt;code&gt;let&lt;/code&gt;, &lt;code&gt;run&lt;/code&gt;, &lt;code&gt;with&lt;/code&gt;, &lt;code&gt;apply&lt;/code&gt;, and &lt;code&gt;also&lt;/code&gt;. For the guidance on choosing the right scope function for your case, refer to &lt;a href=&quot;scope-functions&quot;&gt;Scope Functions&lt;/a&gt;.</source>
          <target state="translated">：Kotlinは、指定されたオブジェクトのコンテキストでコードのブロックを実行するためにさまざまな機能を提供 &lt;code&gt;let&lt;/code&gt; 、 &lt;code&gt;run&lt;/code&gt; 、 &lt;code&gt;with&lt;/code&gt; 、 &lt;code&gt;apply&lt;/code&gt; 、および &lt;code&gt;also&lt;/code&gt; 。あなたのケースのための右のスコープ機能の選択に関するガイダンスについては、を参照してください&lt;a href=&quot;scope-functions&quot;&gt;スコープ機能&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9bdbfc816d9da34f310288932621f6005bd4a635" translate="yes" xml:space="preserve">
          <source>Kotlin provides so called &lt;strong&gt;star-projection&lt;/strong&gt; syntax for this:</source>
          <target state="translated">Kotlinは、このためのいわゆる&lt;strong&gt;スター投影&lt;/strong&gt;構文を提供しています。</target>
        </trans-unit>
        <trans-unit id="a7357de7d14d7d6aa1f1f673c4bd660028007794" translate="yes" xml:space="preserve">
          <source>Kotlin provides the ability to extend a class with new functionality without having to inherit from the class or use design patterns such as Decorator. This is done via special declarations called &lt;em&gt;extensions&lt;/em&gt;. For example, you can write new functions for a class from a third-party library that you can't modify. Such functions are available for calling in the usual way as if they were methods of the original class. This mechanism is called &lt;em&gt;extension functions&lt;/em&gt;. There are also &lt;em&gt;extension properties&lt;/em&gt; that let you define new properties for existing classes.</source>
          <target state="translated">Kotlinは、クラスから継承したり、Decoratorなどのデザインパターンを使用したりすることなく、新しい機能でクラスを拡張する機能を提供します。これは、&lt;em&gt;拡張機能&lt;/em&gt;と呼ばれる特別な宣言を介して行われます。たとえば、変更できないサードパーティのライブラリからクラスの新しい関数を作成できます。このような関数は、元のクラスのメソッドであるかのように、通常の方法で呼び出すことができます。このメカニズムは&lt;em&gt;拡張機能&lt;/em&gt;と呼ばれ&lt;em&gt;ます&lt;/em&gt;。既存のクラスの新しいプロパティを定義できる&lt;em&gt;拡張プロパティ&lt;/em&gt;もあります。</target>
        </trans-unit>
        <trans-unit id="45eae3e9e04c057fe2a9ce2b00c2b1626952c923" translate="yes" xml:space="preserve">
          <source>Kotlin provides the ability to target JavaScript. It does so by transpiling Kotlin to JavaScript. The current implementation targets ECMAScript 5.1 but there are plans to eventually target ECMAScript 2015 as well.</source>
          <target state="translated">Kotlin は JavaScript をターゲットにする機能を提供します。これは、KotlinをJavaScriptにトランスパイリングすることで行います。現在の実装は ECMAScript 5.1 をターゲットにしていますが、最終的には ECMAScript 2015 もターゲットにする予定です。</target>
        </trans-unit>
        <trans-unit id="1d361e832e7fbd8cbfa474feeaaf4e3060965e0c" translate="yes" xml:space="preserve">
          <source>Kotlin provides the following built-in types representing numbers (this is close to Java):</source>
          <target state="translated">Kotlinには、数値を表す以下の組み込み型が用意されています(これはJavaに近いです)。</target>
        </trans-unit>
        <trans-unit id="bcb1ec23fd44ea30c0c43e5be53b38271d9f8878" translate="yes" xml:space="preserve">
          <source>Kotlin provides three tasks for Ant:</source>
          <target state="translated">コトリンはAntに3つのタスクを提供しています。</target>
        </trans-unit>
        <trans-unit id="d32683bae75ae112d7b7ae383176964359ce8293" translate="yes" xml:space="preserve">
          <source>Kotlin requires that every member property is initialized during instance construction. Sometimes, a class is intended to be used in such a way that the constructor doesn't have enough information to initialize all properties (such as when making a builder class or when using property-based dependency injection). In order to not have to make those properties nullable, you can use a &lt;em&gt;late-initialized property&lt;/em&gt;:</source>
          <target state="translated">Kotlinでは、インスタンスの構築中にすべてのメンバープロパティを初期化する必要があります。場合によっては、クラスが、コンストラクターがすべてのプロパティを初期化するのに十分な情報を持たないような方法で使用されることを目的としています（ビルダークラスを作成するとき、またはプロパティベースの依存関係注入を使用するときなど）。これらのプロパティをnull可能にする必要がないようにするために、&lt;em&gt;遅延初期化プロパティを&lt;/em&gt;使用でき&lt;em&gt;ます&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="b6c82522c1d0ee2c933047e31fffeca6f833ef7e" translate="yes" xml:space="preserve">
          <source>Kotlin scripts in &lt;code&gt;build.gradle.kts&lt;/code&gt; files</source>
          <target state="translated">&lt;code&gt;build.gradle.kts&lt;/code&gt; ファイル内のKotlinスクリプト</target>
        </trans-unit>
        <trans-unit id="120e9cfe3ecde2244c4b2038cf0d5e11c76827a7" translate="yes" xml:space="preserve">
          <source>Kotlin singleton (made with an &lt;code&gt;object&lt;/code&gt; declaration, including &lt;code&gt;companion object&lt;/code&gt;) is imported to Swift/Objective-C as a class with a single instance. The instance is available through the factory method, i.e. as &lt;code&gt;[MySingleton mySingleton]&lt;/code&gt; in Objective-C and &lt;code&gt;MySingleton()&lt;/code&gt; in Swift.</source>
          <target state="translated">Kotlinシングルトン（ &lt;code&gt;companion object&lt;/code&gt; を含む &lt;code&gt;object&lt;/code&gt; 宣言で作成）は、単一のインスタンスを持つクラスとしてSwift / Objective-Cにインポートされます。インスタンスは、ファクトリメソッドを介して、つまりObjective-Cでは &lt;code&gt;[MySingleton mySingleton]&lt;/code&gt; として、Swift &lt;code&gt;MySingleton()&lt;/code&gt; として使用できます。</target>
        </trans-unit>
        <trans-unit id="bea729ea75b1b1e606f056a5012e91fb52a83a74" translate="yes" xml:space="preserve">
          <source>Kotlin singletons</source>
          <target state="translated">コトリンシングルトン</target>
        </trans-unit>
        <trans-unit id="a2394b4a95a3420db31c70572b58364d6b98a0c6" translate="yes" xml:space="preserve">
          <source>Kotlin source file or directory to compile</source>
          <target state="translated">コンパイルする Kotlin ソースファイルまたはディレクトリ</target>
        </trans-unit>
        <trans-unit id="e2f631b0ebe5da9da1b87daae220f0696369b117" translate="yes" xml:space="preserve">
          <source>Kotlin source sets may be connected with the &lt;em&gt;'depends on'&lt;/em&gt; relation, so that if a source set &lt;code&gt;foo&lt;/code&gt; depends on a source set &lt;code&gt;bar&lt;/code&gt; then:</source>
          <target state="translated">Kotlinソースセットは&lt;em&gt;「依存」&lt;/em&gt;関係に関連付けられている場合があるため、ソースセット &lt;code&gt;foo&lt;/code&gt; がソースセット &lt;code&gt;bar&lt;/code&gt; 依存する場合は、次のようになります。</target>
        </trans-unit>
        <trans-unit id="3806de1d34a4bca588a5784ceb856faa4c1b15c6" translate="yes" xml:space="preserve">
          <source>Kotlin sources can be mixed with Java sources in the same folder, or in different folders. The default convention is using different folders:</source>
          <target state="translated">Kotlin のソースと Java のソースを同じフォルダに入れたり、別のフォルダに入れたりすることができます。デフォルトでは異なるフォルダを使用しています。</target>
        </trans-unit>
        <trans-unit id="8dda6be52af63434ddc539d85c3f07ae2c8c8de5" translate="yes" xml:space="preserve">
          <source>Kotlin sources can be stored with Java sources in the same folder, or placed to different folders. The default convention is using different folders:</source>
          <target state="translated">Kotlin のソースは Java ソースと一緒に同じフォルダに保存したり、別のフォルダに配置したりすることができます。デフォルトでは異なるフォルダを使用しています。</target>
        </trans-unit>
        <trans-unit id="742632ac6e0e85caf1c4f062cccebafab2dafb01" translate="yes" xml:space="preserve">
          <source>Kotlin standard library artifacts and split packages</source>
          <target state="translated">Kotlin 標準ライブラリのアーティファクトとスプリットパッケージ</target>
        </trans-unit>
        <trans-unit id="77cb00a3ce7a3cdab1c1c157be47f7632c70f806" translate="yes" xml:space="preserve">
          <source>Kotlin subclasses of Objective-C classes</source>
          <target state="translated">Objective-CクラスのKotlinサブクラス</target>
        </trans-unit>
        <trans-unit id="2607bec52d42f747a5225384e349fc0ccef2ced7" translate="yes" xml:space="preserve">
          <source>Kotlin supports SAM conversions for both Java and &lt;a href=&quot;fun-interfaces&quot;&gt;Kotlin interfaces&lt;/a&gt;. This support for Java means that Kotlin function literals can be automatically converted into implementations of Java interfaces with a single non-default method, as long as the parameter types of the interface method match the parameter types of the Kotlin function.</source>
          <target state="translated">Kotlinは、Java&lt;a href=&quot;fun-interfaces&quot;&gt;インターフェイス&lt;/a&gt;とKotlinインターフェイスの両方でSAM変換をサポートしています。このJavaのサポートは、インターフェイスメソッドのパラメータタイプがKotlin関数のパラメータタイプと一致する限り、Kotlin関数リテラルを単一のデフォルト以外のメソッドでJavaインターフェイスの実装に自動的に変換できることを意味します。</target>
        </trans-unit>
        <trans-unit id="e4a28ec1a46419f171d723ee46383588cd9c1cbc" translate="yes" xml:space="preserve">
          <source>Kotlin supports a style of functional programming known as &lt;a href=&quot;https://en.wikipedia.org/wiki/Tail_call&quot;&gt;tail recursion&lt;/a&gt;. This allows some algorithms that would normally be written using loops to instead be written using a recursive function, but without the risk of stack overflow. When a function is marked with the &lt;code&gt;tailrec&lt;/code&gt; modifier and meets the required form, the compiler optimises out the recursion, leaving behind a fast and efficient loop based version instead:</source>
          <target state="translated">Kotlinは、&lt;a href=&quot;https://en.wikipedia.org/wiki/Tail_call&quot;&gt;末尾再帰と&lt;/a&gt;呼ばれる関数型プログラミングのスタイルをサポートしています。これにより、通常ループを使用して記述される一部のアルゴリズムを、代わりに再帰関数を使用して記述できますが、スタックオーバーフローのリスクはありません。関数が &lt;code&gt;tailrec&lt;/code&gt; 修飾子でマークされ、必要な形式を満たすと、コンパイラーは再帰を最適化し、代わりに高速で効率的なループベースのバージョンを残します。</target>
        </trans-unit>
        <trans-unit id="a2baed6c5430ce0572e2f1a5bae6b4631f0f1c73" translate="yes" xml:space="preserve">
          <source>Kotlin supports a style of functional programming known as &lt;a href=&quot;https://en.wikipedia.org/wiki/Tail_call&quot;&gt;tail recursion&lt;/a&gt;. This allows some algorithms that would normally be written using loops to instead be written using a recursive function, but without the risk of stack overflow. When a function is marked with the &lt;code&gt;tailrec&lt;/code&gt; modifier and meets the required form, the compiler optimizes out the recursion, leaving behind a fast and efficient loop based version instead:</source>
          <target state="translated">Kotlinは、&lt;a href=&quot;https://en.wikipedia.org/wiki/Tail_call&quot;&gt;末尾再帰と&lt;/a&gt;呼ばれる関数型プログラミングのスタイルをサポートしています。これにより、通常はループを使用して記述される一部のアルゴリズムを、代わりに再帰関数を使用して記述できますが、スタックオーバーフローのリスクはありません。関数が &lt;code&gt;tailrec&lt;/code&gt; 修飾子でマークされ、必要な形式を満たすと、コンパイラーは再帰を最適化し、代わりに高速で効率的なループベースのバージョンを残します。</target>
        </trans-unit>
        <trans-unit id="f764f32b8a5f60d7b0c651002320db85fd7d539f" translate="yes" xml:space="preserve">
          <source>Kotlin supports annonation processing via the &lt;em&gt;Kotlin annotation processing tool&lt;/em&gt;(&lt;code&gt;kapt&lt;/code&gt;). Usage of kapt with Gradle is described on the &lt;a href=&quot;kapt&quot;&gt;kapt page&lt;/a&gt;.</source>
          <target state="translated">Kotlinは、&lt;em&gt;Kotlin注釈処理ツール&lt;/em&gt;（ &lt;code&gt;kapt&lt;/code&gt; ）による&lt;em&gt;注釈&lt;/em&gt;処理をサポートしています。Gradleでのkaptの使用法については、&lt;a href=&quot;kapt&quot;&gt;kaptページで&lt;/a&gt;説明しています。</target>
        </trans-unit>
        <trans-unit id="13f5d747f019181c1a771753e56710d47a2bbad6" translate="yes" xml:space="preserve">
          <source>Kotlin supports annonation processing via the Kotlin annotation processing tool &lt;a href=&quot;kapt&quot;&gt;&lt;code&gt;kapt&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Kotlinは、Kotlinアノテーション処理ツール&lt;a href=&quot;kapt&quot;&gt; &lt;code&gt;kapt&lt;/code&gt; を&lt;/a&gt;介したアノテーション処理をサポートしています。</target>
        </trans-unit>
        <trans-unit id="92bcfac7403d3cddfb4464119a784d92d81f9f9d" translate="yes" xml:space="preserve">
          <source>Kotlin supports local functions, i.e. a function inside another function:</source>
          <target state="translated">Kotlin はローカル関数、つまり別の関数の中にある関数をサポートしています。</target>
        </trans-unit>
        <trans-unit id="282b26637b1a5ff71051d95d88177e34b6cefc30" translate="yes" xml:space="preserve">
          <source>Kotlin supports single-parent class inheritance - so each class (except the root class &lt;code&gt;Any&lt;/code&gt;) has got exactly one parent class, called a &lt;em&gt;superclass&lt;/em&gt;. Kotlin wants you to think through your class design to make sure that it's actually safe to &lt;em&gt;subclass&lt;/em&gt; it, so classes are &lt;em&gt;closed&lt;/em&gt; by default and can't be inherited from unless you explicitly declare the class to be &lt;em&gt;open&lt;/em&gt; or &lt;em&gt;abstract&lt;/em&gt;. You can then subclass from that class by declaring a new class which mentions its parent class after a colon:</source>
          <target state="translated">Kotlinは単一親クラスの継承をサポートしているため、各クラス（ルートクラス &lt;code&gt;Any&lt;/code&gt; を除く）には、&lt;em&gt;スーパークラス&lt;/em&gt;と呼ばれる親クラスが1つだけあり&lt;em&gt;ます&lt;/em&gt;。 Kotlinは、クラス設計を十分に検討して、実際に&lt;em&gt;サブクラス化し&lt;/em&gt;ても安全であることを確認することを求めています。そのため、クラスはデフォルトで&lt;em&gt;閉じ&lt;/em&gt;られており、クラスを&lt;em&gt;open&lt;/em&gt;または&lt;em&gt;abstract&lt;/em&gt;として明示的に宣言しない限り、クラスを継承できません。次に、コロンの後に親クラスを記述する新しいクラスを宣言することにより、そのクラスからサブクラス化できます。</target>
        </trans-unit>
        <trans-unit id="c701dab67e42733a07778c8e90d14a14d6115e0e" translate="yes" xml:space="preserve">
          <source>Kotlin supports the following operators and special symbols:</source>
          <target state="translated">Kotlinは以下の演算子と特殊記号をサポートしています。</target>
        </trans-unit>
        <trans-unit id="b9f65c39eaf4fcfb17c2f522f10687c0e4404fdb" translate="yes" xml:space="preserve">
          <source>Kotlin supports the standard set of arithmetical operations over numbers (&lt;code&gt;+&lt;/code&gt;&lt;code&gt;-&lt;/code&gt;&lt;code&gt;*&lt;/code&gt;&lt;code&gt;/&lt;/code&gt;&lt;code&gt;%&lt;/code&gt;), which are declared as members of appropriate classes (but the compiler optimizes the calls down to the corresponding instructions). See &lt;a href=&quot;operator-overloading&quot;&gt;Operator overloading&lt;/a&gt;.</source>
          <target state="translated">Kotlinは、適切なクラスのメンバーとして宣言されている数値（ &lt;code&gt;+&lt;/code&gt; &lt;code&gt;-&lt;/code&gt; &lt;code&gt;*&lt;/code&gt; &lt;code&gt;/&lt;/code&gt; &lt;code&gt;%&lt;/code&gt; ）に対する算術演算の標準セットをサポートしています（ただし、コンパイラーは、対応する命令までの呼び出しを最適化します）。&lt;a href=&quot;operator-overloading&quot;&gt;演算子のオーバーロードを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="4887c0a9ca610838532432bde155538452979c8b" translate="yes" xml:space="preserve">
          <source>Kotlin supports the standard set of arithmetical operations over numbers, which are declared as members of appropriate classes (but the compiler optimizes the calls down to the corresponding instructions). See &lt;a href=&quot;operator-overloading&quot;&gt;Operator overloading&lt;/a&gt;.</source>
          <target state="translated">Kotlinは、適切なクラスのメンバーとして宣言されている数値に対する算術演算の標準セットをサポートしています（ただし、コンパイラーは、対応する命令までの呼び出しを最適化します）。&lt;a href=&quot;operator-overloading&quot;&gt;オペレーターのオーバーロードを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="c8bfc686b943f3ad415464d9f2987e93b995ca8c" translate="yes" xml:space="preserve">
          <source>Kotlin supports traditional &lt;em&gt;break&lt;/em&gt; and &lt;em&gt;continue&lt;/em&gt; operators in loops. See &lt;a href=&quot;returns&quot;&gt;Returns and jumps&lt;/a&gt;.</source>
          <target state="translated">Kotlinは、ループで従来の&lt;em&gt;ブレーク&lt;/em&gt;および&lt;em&gt;継続&lt;/em&gt;演算子をサポートしています。&lt;a href=&quot;returns&quot;&gt;リターンとジャンプを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="0d07ef64d55abdae6d6a123db33be555df8316b4" translate="yes" xml:space="preserve">
          <source>Kotlin supports trailing commas in the following cases:</source>
          <target state="translated">Kotlinは以下の場合には末尾のカンマをサポートしています。</target>
        </trans-unit>
        <trans-unit id="d836a05da6a45d7708b37e3a93892db605af05e1" translate="yes" xml:space="preserve">
          <source>Kotlin targets a wide range of the Java versions, including Java 6 and Java 7, where default methods in the interfaces are not allowed. For your convenience, the Kotlin compiler works around that limitation, but this workaround isn't compatible with the &lt;code&gt;default&lt;/code&gt; methods, introduced in Java 8.</source>
          <target state="translated">Kotlinは、インターフェースのデフォルトのメソッドが許可されていないJava 6やJava 7を含む幅広いJavaバージョンを対象としています。便宜上、Kotlinコンパイラはその制限を回避しますが、この回避策はJava 8で導入された &lt;code&gt;default&lt;/code&gt; メソッドと互換性がありません。</target>
        </trans-unit>
        <trans-unit id="7a3c3013cf9e37dd556eb25470f92f220350c10a" translate="yes" xml:space="preserve">
          <source>Kotlin to JavaScript</source>
          <target state="translated">コトリンからJavaScriptへ</target>
        </trans-unit>
        <trans-unit id="09a30aded79f08fdd22e3766d5057679b6cb51d6" translate="yes" xml:space="preserve">
          <source>Kotlin treats some Java types specially. Such types are not loaded from Java &quot;as is&quot;, but are &lt;em&gt;mapped&lt;/em&gt; to corresponding Kotlin types. The mapping only matters at compile time, the runtime representation remains unchanged. Java's primitive types are mapped to corresponding Kotlin types (keeping &lt;a href=&quot;#null-safety-and-platform-types&quot;&gt;platform types&lt;/a&gt; in mind):</source>
          <target state="translated">Kotlinは一部のJavaタイプを特別に扱います。このような型は、Javaから「そのまま」ロードされるのではなく、対応するKotlin型に&lt;em&gt;マップさ&lt;/em&gt;れます。マッピングはコンパイル時にのみ重要であり、ランタイム表現は変更されません。Javaのプリミティブ型は、対応するKotlin型にマッピングされます（&lt;a href=&quot;#null-safety-and-platform-types&quot;&gt;プラットフォームの型&lt;/a&gt;を覚えておいてください）。</target>
        </trans-unit>
        <trans-unit id="768f1e9cdea1a9d60e4596098790dc6c5c883f4f" translate="yes" xml:space="preserve">
          <source>Kotlin turns the function pointer return type into a nullable &lt;code&gt;CPointer&amp;lt;CFunction&amp;lt;..&amp;gt;&lt;/code&gt; object. There is the need to explicitly check for &lt;code&gt;null&lt;/code&gt; first. We use &lt;a href=&quot;../../reference/null-safety&quot;&gt;elvis operator&lt;/a&gt; for that. The &lt;code&gt;cinterop&lt;/code&gt; tool helps us to turn a C function pointer into an easy to call object in Kotlin. This is what we did on the last line.</source>
          <target state="translated">Kotlinは、関数ポインターの戻り値の型をnull可能な &lt;code&gt;CPointer&amp;lt;CFunction&amp;lt;..&amp;gt;&lt;/code&gt; オブジェクトに変換します。最初に明示的に &lt;code&gt;null&lt;/code&gt; をチェックする必要があります。そのために&lt;a href=&quot;../../reference/null-safety&quot;&gt;elvis演算子&lt;/a&gt;を使用します。 &lt;code&gt;cinterop&lt;/code&gt; のツールは、私たちはKotlinでオブジェクトを呼び出すために簡単にC関数ポインタを回すのに役立ちます。これが最後の行で行ったものです。</target>
        </trans-unit>
        <trans-unit id="db8f21bde482b5a130cf00596109ec23d3d336d2" translate="yes" xml:space="preserve">
          <source>Kotlin uses a family of function types like &lt;code&gt;(Int) -&amp;gt; String&lt;/code&gt; for declarations that deal with functions: &lt;code&gt;val onClick: () -&amp;gt; Unit = ...&lt;/code&gt;.</source>
          <target state="translated">Kotlinのような関数型のファミリーの使用 &lt;code&gt;(Int) -&amp;gt; String&lt;/code&gt; の宣言のためにその機能との契約： &lt;code&gt;val onClick: () -&amp;gt; Unit = ...&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bb4aa710f2c72b83ee921d5d3e539487fd005073" translate="yes" xml:space="preserve">
          <source>Kotlin uses the &lt;code&gt;libnative_&lt;/code&gt; prefix for all declarations in the created &lt;code&gt;libnative_api.h&lt;/code&gt; file. Let's present the mapping of the types in a more readable way:</source>
          <target state="translated">Kotlinは、作成された &lt;code&gt;libnative_api.h&lt;/code&gt; ファイルのすべての宣言に &lt;code&gt;libnative_&lt;/code&gt; プレフィックスを使用します。より読みやすい方法で型のマッピングを提示しましょう：</target>
        </trans-unit>
        <trans-unit id="b58121b32bf1a1498b7715228a497191716fd48d" translate="yes" xml:space="preserve">
          <source>Kotlin was designed for easy interoperation with Java platform. It sees Java classes as Kotlin classes, and Java sees Kotlin classes as Java classes. However, JavaScript is a dynamically-typed language, which means it does not check types in compile-time. You can freely talk to JavaScript from Kotlin via &lt;a href=&quot;dynamic-type&quot;&gt;dynamic&lt;/a&gt; types, but if you want the full power of Kotlin type system, you can create Kotlin headers for JavaScript libraries.</source>
          <target state="translated">Kotlinは、Javaプラットフォームと簡単に相互運用できるように設計されています。 JavaクラスはKotlinクラスと見なされ、JavaはKotlinクラスをJavaクラスと見なします。ただし、JavaScriptは動的に型付けされる言語です。つまり、コンパイル時に型をチェックしません。&lt;a href=&quot;dynamic-type&quot;&gt;動的&lt;/a&gt;型を介してKotlinからJavaScriptに自由に通信できますが、Kotlin型システムの全機能を必要とする場合は、JavaScriptライブラリ用のKotlinヘッダーを作成できます。</target>
        </trans-unit>
        <trans-unit id="e4c0f3a3782b90edcee0e70de97ebb0b28520a70" translate="yes" xml:space="preserve">
          <source>Kotlin was first designed for easy interoperation with the Java platform: it sees Java classes as Kotlin classes, and Java sees Kotlin classes as Java classes.</source>
          <target state="translated">KotlinはJavaプラットフォームとの相互運用を容易にするために最初に設計されました。</target>
        </trans-unit>
        <trans-unit id="487d5ff42a3055fc2a4cb28f3d53d445d59f1865" translate="yes" xml:space="preserve">
          <source>Kotlin will allow you to declare this property without initializing it, and you can set the property value at some point after construction (either directly or via a function). It is the responsibility of the class itself as well as its users to take care not to read the property before it has been set, and Kotlin allows you to write code that reads &lt;code&gt;name&lt;/code&gt; as if it were an ordinary, non-nullable property. However, the compiler is unable to enforce correct usage, so if the property is read before it has been set, an &lt;code&gt;UninitializedPropertyAccessException&lt;/code&gt; will be thrown at runtime.</source>
          <target state="translated">Kotlinを使用すると、初期化せずにこのプロパティを宣言でき、構築後のある時点で（直接または関数を介して）プロパティ値を設定できます。プロパティが設定される前にプロパティを読み取らないように注意することは、クラス自体とそのユーザーの責任です。Kotlinを使用すると、 &lt;code&gt;name&lt;/code&gt; を通常のnull不可のプロパティのように読み取るコードを記述できます。ただし、コンパイラーは正しい使用法を適用できません。そのため、プロパティーが設定される前に読み取られた場合、実行時に &lt;code&gt;UninitializedPropertyAccessException&lt;/code&gt; がスローされます。</target>
        </trans-unit>
        <trans-unit id="b3a556e28261e02ebafecde169f3b3513ca13075" translate="yes" xml:space="preserve">
          <source>Kotlin works quite smoothly with Spring Boot and many of the steps found on the &lt;a href=&quot;https://spring.io/guides&quot;&gt;Spring Guides&lt;/a&gt; for creating a RESTful service can be followed verbatim for Kotlin. There are some minor differences however when it comes to defining the Gradle configuration and the project layout structure, as well as the initialization code.</source>
          <target state="translated">Kotlinは、Spring Bootと非常にスムーズに連携します。RESTfulサービスを作成するための&lt;a href=&quot;https://spring.io/guides&quot;&gt;Spring Guides&lt;/a&gt;にある手順の多くは、Kotlinをそのまま使用できます。ただし、Gradle構成とプロジェクトレイアウト構造、および初期化コードの定義に関しては、いくつかの小さな違いがあります。</target>
        </trans-unit>
        <trans-unit id="43ea688f8664ba8f8dabcebd91046161c6146f3c" translate="yes" xml:space="preserve">
          <source>Kotlin works with different &lt;a href=&quot;build-tools&quot;&gt;build tools&lt;/a&gt;, so if we're using a standard tool such as Ant, Maven or Gradle, the process for setting up a Kotlin project is no different to any other language or library that integrates with these tools. Where there are some minor requirements and differences is when using JBS, which is the internal build system that IntelliJ IDEA uses, which is also supported on TeamCity.</source>
          <target state="translated">Kotlinはさまざまな&lt;a href=&quot;build-tools&quot;&gt;ビルドツール&lt;/a&gt;で動作するため、Ant、Maven、Gradleなどの標準ツールを使用している場合、Kotlinプロジェクトを設定するプロセスは、これらのツールと統合する他の言語やライブラリと同じです。いくつかの小さな要件と違いがあるのは、JBSを使用する場合です。これは、IntelliJ IDEAが使用する内部ビルドシステムであり、TeamCityでもサポートされています。</target>
        </trans-unit>
        <trans-unit id="457e307b979be376836ec99d4487123ba8ace79f" translate="yes" xml:space="preserve">
          <source>Kotlin's approach to working with asynchronous code is using coroutines, which is the idea of suspendable computations, i.e. the idea that a function can suspend its execution at some point and resume later on.</source>
          <target state="translated">Kotlinの非同期コードを扱うためのアプローチは、コルーチンを使ったもので、これはサスペンド可能な計算、つまり関数がある時点で実行を一時停止し、後で再開できるという考え方です。</target>
        </trans-unit>
        <trans-unit id="b5ab858d5d3418daf57f2ff97756dc06bfcd23b9" translate="yes" xml:space="preserve">
          <source>Kotlin's documentation generation tool is called &lt;a href=&quot;https://github.com/Kotlin/dokka&quot;&gt;Dokka&lt;/a&gt;. See the &lt;a href=&quot;https://github.com/Kotlin/dokka/blob/master/README.md&quot;&gt;Dokka README&lt;/a&gt; for usage instructions.</source>
          <target state="translated">Kotlinのドキュメント生成ツールは&lt;a href=&quot;https://github.com/Kotlin/dokka&quot;&gt;Dokka&lt;/a&gt;と呼ばれます。使用方法については、&lt;a href=&quot;https://github.com/Kotlin/dokka/blob/master/README.md&quot;&gt;Dokka README&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="3af1e3ba09d170fd30c3af38c47add3814785926" translate="yes" xml:space="preserve">
          <source>Kotlin's documentation syntax is called &lt;em&gt;KDoc&lt;/em&gt;. A KDoc block is placed above the construct it describes, and begins with &lt;code&gt;/**&lt;/code&gt; and ends with &lt;code&gt;*/&lt;/code&gt; (possibly on one line; if not, each intermediate lines should start with an aligned asterisk). The first block of text is the summary; then, you can use &lt;em&gt;block tags&lt;/em&gt; to provide information about specific parts of the construct. Some block tags are &lt;code&gt;@param&lt;/code&gt; for function parameters and generic type parameters, and &lt;code&gt;@return&lt;/code&gt; for the return value. You can link to identifiers inside brackets. All the text outside of links and block tag names is in Markdown format.</source>
          <target state="translated">Kotlinのドキュメント構文は&lt;em&gt;KDoc&lt;/em&gt;と呼ばれ&lt;em&gt;ます&lt;/em&gt;。 KDocブロックは、それが記述する構成の上に配置され、 &lt;code&gt;/**&lt;/code&gt; で始まり &lt;code&gt;*/&lt;/code&gt; で終わります（1行である可能性があります。そうでない場合は、各中間行はアスタリスクで始まります）。テキストの最初のブロックは要約です。次に、&lt;em&gt;ブロックタグ&lt;/em&gt;を使用して、構成の特定の部分に関する情報を提供できます。一部のブロックタグは、関数パラメーターとジェネリック型パラメーターの &lt;code&gt;@param&lt;/code&gt; 、および戻り値の &lt;code&gt;@return&lt;/code&gt; です。大括弧内の識別子にリンクできます。リンクとブロックタグ名の外側のすべてのテキストは、Markdown形式です。</target>
        </trans-unit>
        <trans-unit id="053760c0ead482ee5ae43f8e0bead527a31d7dd2" translate="yes" xml:space="preserve">
          <source>Kotlin's generics are a little different from Java's (see &lt;a href=&quot;generics&quot;&gt;Generics&lt;/a&gt;). When importing Java types to Kotlin we perform some conversions:</source>
          <target state="translated">Kotlinのジェネリックは、Javaのジェネリックとは少し異なります（&lt;a href=&quot;generics&quot;&gt;ジェネリックを&lt;/a&gt;参照）。JavaタイプをKotlinにインポートするとき、いくつかの変換を実行します。</target>
        </trans-unit>
        <trans-unit id="9ce324f37629b9d5fdf6ee64821674d4e61b9c46" translate="yes" xml:space="preserve">
          <source>Kotlin's loops are similar to Python's. &lt;code&gt;for&lt;/code&gt; iterates over anything that is &lt;em&gt;iterable&lt;/em&gt; (anything that has an &lt;code&gt;iterator()&lt;/code&gt; function that provides an &lt;code&gt;Iterator&lt;/code&gt; object), or anything that is itself an iterator:</source>
          <target state="translated">KotlinのループはPythonのループに似ています。 &lt;code&gt;for&lt;/code&gt; であるものを反復&lt;em&gt;反復可能&lt;/em&gt;（持つもの &lt;code&gt;iterator()&lt;/code&gt; を提供関数 &lt;code&gt;Iterator&lt;/code&gt; オブジェクト）、または反復子自体であるもの：</target>
        </trans-unit>
        <trans-unit id="ba05695800cb8016bdf03b211c131a78afee8e93" translate="yes" xml:space="preserve">
          <source>Kotlin's object model is substantially different from Python's. Most importantly, classes are &lt;em&gt;not&lt;/em&gt; dynamically modifiable at runtime! (There are some limited exceptions to this, but you generally shouldn't do it. However, it &lt;em&gt;is&lt;/em&gt; possible to dynamically &lt;em&gt;inspect&lt;/em&gt; classes and objects at runtime with a feature called &lt;em&gt;reflection&lt;/em&gt; - this can be useful, but should be judiciously used.) All properties (attributes) and functions that might ever be needed on a class must be declared either directly in the class body or as &lt;a href=&quot;extension-functionsproperties&quot;&gt;&lt;em&gt;extension functions&lt;/em&gt;&lt;/a&gt;, so you should think carefully through your class design.</source>
          <target state="translated">Kotlinのオブジェクトモデルは、Pythonのオブジェクトモデルとは大きく異なります。最も重要なのは、クラスは実行時に動的に変更&lt;em&gt;できないこと&lt;/em&gt;です。 （これにはいくつかの限定的な例外がありますが、通常は行うべきではありません。ただし、&lt;em&gt;リフレクション&lt;/em&gt;と呼ばれる機能を使用して、実行時にクラスとオブジェクトを動的に&lt;em&gt;検査する&lt;/em&gt;こと&lt;em&gt;は&lt;/em&gt;可能です。これは便利ですが、慎重に使用する必要があります。）すべてクラスで必要になる可能性のあるプロパティ（属性）と関数は、クラス本体で直接または&lt;a href=&quot;extension-functionsproperties&quot;&gt;&lt;em&gt;拡張関数&lt;/em&gt;&lt;/a&gt;として宣言する必要があるため、クラスの設計を慎重に検討する必要があります。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d2a59f6487d643d44ccac72e26090969f3853d89" translate="yes" xml:space="preserve">
          <source>Kotlin's standard library has a &lt;code&gt;TODO()&lt;/code&gt; function that will always throw a &lt;code&gt;NotImplementedError&lt;/code&gt;. Its return type is &lt;code&gt;Nothing&lt;/code&gt; so it can be used regardless of expected type. There's also an overload that accepts a reason parameter:</source>
          <target state="translated">Kotlinの標準ライブラリには、常に &lt;code&gt;NotImplementedError&lt;/code&gt; をスローする &lt;code&gt;TODO()&lt;/code&gt; 関数があります。その戻り値の型は &lt;code&gt;Nothing&lt;/code&gt; であるため、予期される型に関係なく使用できます。理由パラメーターを受け入れるオーバーロードもあります。</target>
        </trans-unit>
        <trans-unit id="970540431e074be00582837c3e83cd1ca1a5ee04" translate="yes" xml:space="preserve">
          <source>Kotlin's type system is aimed at eliminating the danger of null references from code, also known as the &lt;a href=&quot;http://en.wikipedia.org/wiki/Tony_Hoare#Apologies_and_retractions&quot;&gt;The Billion Dollar Mistake&lt;/a&gt;.</source>
          <target state="translated">Kotlinの型システムは、コードからのnull参照の危険性を排除することを目的としています。&lt;a href=&quot;http://en.wikipedia.org/wiki/Tony_Hoare#Apologies_and_retractions&quot;&gt;これ&lt;/a&gt;は、The Billion Dollar Mistakeとしても知られています。</target>
        </trans-unit>
        <trans-unit id="8b3b3c2fce26ced6c3f89e4969b12ebc4e57fb47" translate="yes" xml:space="preserve">
          <source>Kotlin's type system is aimed at eliminating the danger of null references from code, also known as the &lt;a href=&quot;https://en.wikipedia.org/wiki/Tony_Hoare#Apologies_and_retractions&quot;&gt;The Billion Dollar Mistake&lt;/a&gt;.</source>
          <target state="translated">Kotlinの型システムは、コードからnull参照の危険性を排除することを目的としています。&lt;a href=&quot;https://en.wikipedia.org/wiki/Tony_Hoare#Apologies_and_retractions&quot;&gt;これは、10億ドルの間違い&lt;/a&gt;としても知られています。</target>
        </trans-unit>
        <trans-unit id="6ae5912eae484ffd44f09a774b363dbba8158106" translate="yes" xml:space="preserve">
          <source>Kotlin's type system is aimed to eliminate &lt;code&gt;NullPointerException&lt;/code&gt;'s from our code. The only possible causes of NPE's may be:</source>
          <target state="translated">Kotlinの型システムは、コードから &lt;code&gt;NullPointerException&lt;/code&gt; を排除することを目的としています。NPEの考えられる原因は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="0b21dfbe494a9eaaf724f5a9592dd235fdd14650" translate="yes" xml:space="preserve">
          <source>Kotlin, as a language, provides only minimal low-level APIs in its standard library to enable various other libraries to utilize coroutines. Unlike many other languages with similar capabilities, &lt;code&gt;async&lt;/code&gt; and &lt;code&gt;await&lt;/code&gt; are not keywords in Kotlin and are not even part of its standard library. Moreover, Kotlin's concept of &lt;em&gt;suspending function&lt;/em&gt; provides a safer and less error-prone abstraction for asynchronous operations than futures and promises.</source>
          <target state="translated">Kotlinは、言語として、標準ライブラリで最小限の低レベルAPIのみを提供して、他のさまざまなライブラリがコルーチンを利用できるようにします。同様の機能を持つ他の多くの言語とは異なり、 &lt;code&gt;async&lt;/code&gt; と &lt;code&gt;await&lt;/code&gt; はKotlinのキーワードではなく、標準ライブラリの一部でもありません。さらに、Kotlinの&lt;em&gt;一時停止機能&lt;/em&gt;の概念は、フューチャーやプロミスよりも安全でエラーの発生しにくい非同期操作の抽象化を提供します。</target>
        </trans-unit>
        <trans-unit id="1aefdadaf18a27e16e25f47128252ff2aeb47fe6" translate="yes" xml:space="preserve">
          <source>Kotlin, similar to C# and Gosu, provides the ability to extend a class with new functionality without having to inherit from the class or use any type of design pattern such as Decorator. This is done via special declarations called &lt;em&gt;extensions&lt;/em&gt;. Kotlin supports &lt;em&gt;extension functions&lt;/em&gt; and &lt;em&gt;extension properties&lt;/em&gt;.</source>
          <target state="translated">Kotlinは、C＃やGosuと同様に、クラスから継承したり、Decoratorなどのデザインパターンを使用したりすることなく、新しい機能でクラスを拡張する機能を提供します。これは、&lt;em&gt;extensions&lt;/em&gt;と呼ばれる特別な宣言を介して行われます。Kotlinは、&lt;em&gt;拡張関数&lt;/em&gt;と&lt;em&gt;拡張プロパティを&lt;/em&gt;サポートしてい&lt;em&gt;ます&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="66f1754b6d5c7a12dce00bd5e634c25ddb75bf52" translate="yes" xml:space="preserve">
          <source>Kotlin/JS</source>
          <target state="translated">Kotlin/JS</target>
        </trans-unit>
        <trans-unit id="b4529ea374c3a4cde07a41aa987a9b048c623d50" translate="yes" xml:space="preserve">
          <source>Kotlin/JS (Classic back-end)</source>
          <target state="translated">Kotlin/JS (クラシックバックエンド)</target>
        </trans-unit>
        <trans-unit id="4c111df440b988d7ac0f881b0ae8eeed10bb5e43" translate="yes" xml:space="preserve">
          <source>Kotlin/JS (IR-based)</source>
          <target state="translated">Kotlin/JS(IRベース</target>
        </trans-unit>
        <trans-unit id="3409f54fa5231194c2d7cb0f9009c3222e1a2109" translate="yes" xml:space="preserve">
          <source>Kotlin/JS Overview</source>
          <target state="translated">Kotlin/JSの概要</target>
        </trans-unit>
        <trans-unit id="5579b6ef038f8f8ca2fe985b676250979f056cbe" translate="yes" xml:space="preserve">
          <source>Kotlin/JS allows you to &lt;strong&gt;leverage powerful browser and web APIs&lt;/strong&gt; in a type-safe fashion. Create, modify and interact with elements in the Document Object Model (DOM), use Kotlin code to control the rendering of &lt;code&gt;canvas&lt;/code&gt; or WebGL components, and enjoy access to many more of the features supported in modern browsers.</source>
          <target state="translated">Kotlin / JSを使用すると&lt;strong&gt;、強力なブラウザーAPIとWebAPI&lt;/strong&gt;をタイプセーフな方法で&lt;strong&gt;活用&lt;/strong&gt;できます。ドキュメントオブジェクトモデル（DOM）の要素を作成、変更、操作し、Kotlinコードを使用して &lt;code&gt;canvas&lt;/code&gt; またはWebGLコンポーネントのレンダリングを制御し、最新のブラウザーでサポートされている多くの機能にアクセスできます。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
