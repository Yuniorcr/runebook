<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="kotlin">
    <body>
      <group id="kotlin">
        <trans-unit id="cb5279ca89113fa744f9ed912c21f45c93146fab" translate="yes" xml:space="preserve">
          <source>Inserts the string representation of the specified boolean &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.Boolean)/value&quot;&gt;value&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.Boolean)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</source>
          <target state="translated">指定されたブール&lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.Boolean)/value&quot;&gt;値&lt;/a&gt;の文字列表現を、この文字列ビルダーの指定された&lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.Boolean)/index&quot;&gt;インデックスに&lt;/a&gt;挿入し、このインスタンスを返します。</target>
        </trans-unit>
        <trans-unit id="b8ce5257d0d44bc8ee828b4f0aa168d27143f4fc" translate="yes" xml:space="preserve">
          <source>Inserts the string representation of the specified object &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.Any?)/value&quot;&gt;value&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.Any?)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</source>
          <target state="translated">指定されたオブジェクト&lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.Any?)/value&quot;&gt;値&lt;/a&gt;の文字列表現を、指定された&lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.Any?)/index&quot;&gt;インデックス&lt;/a&gt;でこの文字列ビルダーに挿入し、このインスタンスを返します。</target>
        </trans-unit>
        <trans-unit id="40e63a4d54fc0992dbc62da98003576fd7d50dbb" translate="yes" xml:space="preserve">
          <source>Inside a class, you can declare extensions for another class. Inside such an extension, there are multiple &lt;em&gt;implicit receivers&lt;/em&gt; - objects members of which can be accessed without a qualifier. The instance of the class in which the extension is declared is called &lt;em&gt;dispatch receiver&lt;/em&gt;, and the instance of the receiver type of the extension method is called &lt;em&gt;extension receiver&lt;/em&gt;.</source>
          <target state="translated">クラス内では、別のクラスの拡張を宣言できます。このような拡張機能の内部には、複数の&lt;em&gt;暗黙的なレシーバー&lt;/em&gt;があり、そのメンバーには修飾子なしでアクセスできます。拡張が宣言されているクラスのインスタンスは&lt;em&gt;ディスパッチレシーバ&lt;/em&gt;と呼ば&lt;em&gt;れ&lt;/em&gt;、拡張メソッドのレシーバタイプのインスタンスは&lt;em&gt;拡張レシーバ&lt;/em&gt;と呼ばれます。</target>
        </trans-unit>
        <trans-unit id="97c34b033d93e70cd2130ab46bfa71cd52ac56f6" translate="yes" xml:space="preserve">
          <source>Inside a function a &lt;code&gt;vararg&lt;/code&gt;-parameter of type &lt;code&gt;T&lt;/code&gt; is visible as an array of &lt;code&gt;T&lt;/code&gt;, i.e. the &lt;code&gt;ts&lt;/code&gt; variable in the example above has type &lt;code&gt;Array&amp;lt;out T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">関数内では、タイプ &lt;code&gt;T&lt;/code&gt; の &lt;code&gt;vararg&lt;/code&gt; パラメータは &lt;code&gt;T&lt;/code&gt; の配列として表示されます。つまり、上記の例の &lt;code&gt;ts&lt;/code&gt; 変数はタイプ &lt;code&gt;Array&amp;lt;out T&amp;gt;&lt;/code&gt; 持っています。</target>
        </trans-unit>
        <trans-unit id="826cc6f6147dd291bf22ea4078acd71a79ba87cf" translate="yes" xml:space="preserve">
          <source>Inside a lambda expression with receiver, you can use &lt;code&gt;this&lt;/code&gt; to refer to the receiver object (in this case, &lt;code&gt;car&lt;/code&gt;). As usual, you can omit &lt;code&gt;this&lt;/code&gt; if there are no naming conflicts, which is why we can simply say &lt;code&gt;$horsepowers&lt;/code&gt; instead of &lt;code&gt;${this.horsepowers}&lt;/code&gt;. So beware that in Kotlin, &lt;code&gt;this&lt;/code&gt; can have different meanings depending on the context: if used inside (possibly nested) lambda expressions with receivers, it refers to the receiver object of the innermost enclosing lambda expression with receiver. If you need to &quot;break out&quot; of the function literal and get the &quot;original&quot; &lt;code&gt;this&lt;/code&gt; (the instance the member function you're inside is executing on), mention the containing class name after &lt;code&gt;this@&lt;/code&gt; - so if you're inside a function literal with receiver inside a member function of Car, use &lt;code&gt;this@Car&lt;/code&gt;.</source>
          <target state="translated">レシーバー付きのラムダ式の内部では、 &lt;code&gt;this&lt;/code&gt; を使用してレシーバーオブジェクト（この場合は &lt;code&gt;car&lt;/code&gt; ）を参照できます。いつものように、名前の競合がない場合は &lt;code&gt;this&lt;/code&gt; を省略できます。そのため、 &lt;code&gt;${this.horsepowers}&lt;/code&gt; ではなく &lt;code&gt;$horsepowers&lt;/code&gt; とだけ言うことができます。したがって、Kotlinでは、 &lt;code&gt;this&lt;/code&gt; はコンテキストに応じて異なる意味を持つ可能性があることに注意してください。レシーバーを持つ（ネストされている可能性がある）ラムダ式内で使用される場合、レシーバーを持つ最も内側の外側のラムダ式のレシーバーオブジェクトを参照します。関数リテラルを「抜け出し」、「元の」 &lt;code&gt;this&lt;/code&gt; を取得する必要がある場合（内部にいるメンバー関数が実行されているインスタンス）、 &lt;code&gt;this@&lt;/code&gt; を含むクラス名をthis @の後に記述します。したがって、Carのメンバー関数内にレシーバーがある関数リテラル内にいる場合は、 &lt;code&gt;this@Car&lt;/code&gt; 使用します。</target>
        </trans-unit>
        <trans-unit id="d76861f103960eff4ae0c7430fef1ebd5d3e542c" translate="yes" xml:space="preserve">
          <source>Inside an inner class, accessing the superclass of the outer class is done with the &lt;em&gt;super&lt;/em&gt; keyword qualified with the outer class name: &lt;code&gt;super@Outer&lt;/code&gt;:</source>
          <target state="translated">内部クラス内では、外部クラスのスーパークラスへのアクセスは、外部クラス名で修飾された&lt;em&gt;super&lt;/em&gt;キーワードで行われます： &lt;code&gt;super@Outer&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="8ccb5c0d6d5858f7a6cc2ca5c66201a3c3cecf82" translate="yes" xml:space="preserve">
          <source>Inside enum entries, defining a nested type that is not an &lt;code&gt;inner class&lt;/code&gt; has been deprecated due to issues in the initialization logic. This causes a warning in Kotlin 1.2 and will become an error in Kotlin 1.3.</source>
          <target state="translated">列挙型エントリ内で、 &lt;code&gt;inner class&lt;/code&gt; ではないネストされた型を定義することは、初期化ロジックの問題により廃止されました。これにより、Kotlin 1.2では警告が発生し、Kotlin 1.3ではエラーになります。</target>
        </trans-unit>
        <trans-unit id="d5019da5c150ca59c7fa4dd453ea0a06cf96e080" translate="yes" xml:space="preserve">
          <source>Inside the &lt;code&gt;apply&lt;/code&gt; block, &lt;code&gt;this&lt;/code&gt; refers to &lt;code&gt;maybeNull&lt;/code&gt;. There's an implicit &lt;code&gt;this&lt;/code&gt; in front of &lt;code&gt;memberPropertyA&lt;/code&gt;, &lt;code&gt;memberPropertyB&lt;/code&gt;, and &lt;code&gt;memberFunctionA&lt;/code&gt; (unless these don't exist on &lt;code&gt;maybeNull&lt;/code&gt;, in which case they'll be looked for in the containing scopes). Afterwards, &lt;code&gt;memberFunctionB()&lt;/code&gt; is also invoked on &lt;code&gt;maybeNull&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;apply&lt;/code&gt; ブロック内では、 &lt;code&gt;this&lt;/code&gt; は &lt;code&gt;maybeNull&lt;/code&gt; を参照します。 &lt;code&gt;memberPropertyA&lt;/code&gt; 、 &lt;code&gt;memberPropertyB&lt;/code&gt; 、および &lt;code&gt;memberFunctionA&lt;/code&gt; の前に暗黙の &lt;code&gt;this&lt;/code&gt; があります（maybeNullにこれらが存在しない場合を &lt;code&gt;maybeNull&lt;/code&gt; ます。その場合、それらは包含スコープで検索されます）。その後、 &lt;code&gt;memberFunctionB()&lt;/code&gt; も呼び出され &lt;code&gt;maybeNull&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="201f7c7f50eead5096b8205dfcee81a61ab42986" translate="yes" xml:space="preserve">
          <source>Inside the &lt;code&gt;kotlin&lt;/code&gt; section, you can manage the following aspects:</source>
          <target state="translated">&lt;code&gt;kotlin&lt;/code&gt; セクション内では、次の側面を管理できます。</target>
        </trans-unit>
        <trans-unit id="f13d8be73f140532f836309395f0554a59c9c6f7" translate="yes" xml:space="preserve">
          <source>Inside the body of the function literal, the receiver object passed to a call becomes an &lt;em&gt;implicit&lt;/em&gt;&lt;em&gt;this&lt;/em&gt;, so that you can access the members of that receiver object without any additional qualifiers, or access the receiver object using a &lt;a href=&quot;this-expressions&quot;&gt;&lt;code&gt;this&lt;/code&gt; expression&lt;/a&gt;.</source>
          <target state="translated">関数リテラルの本体内で、呼び出しに渡されるレシーバーオブジェクトは&lt;em&gt;暗黙の&lt;/em&gt;&lt;em&gt;this&lt;/em&gt;になるため、追加の修飾子なしでそのレシーバーオブジェクトのメンバーにアクセスしたり、&lt;a href=&quot;this-expressions&quot;&gt; &lt;code&gt;this&lt;/code&gt; 式&lt;/a&gt;を使用してレシーバーオブジェクトにアクセスしたりできます。</target>
        </trans-unit>
        <trans-unit id="2558cc93d05f62b7942210cca1e0fecc8bdce932" translate="yes" xml:space="preserve">
          <source>Inside the class that declares a lateinit property, you can check if it has been initialized:</source>
          <target state="translated">lateinitプロパティを宣言しているクラスの内部では、初期化されているかどうかを確認することができます。</target>
        </trans-unit>
        <trans-unit id="987506c0627eacba63113c8eade53536a31e1484" translate="yes" xml:space="preserve">
          <source>Inside the file, the documentation for the module as a whole and for individual packages is introduced by the corresponding first-level headings. The text of the heading must be &quot;Module &lt;code&gt;&amp;lt;module name&amp;gt;&lt;/code&gt;&quot; for the module, and &quot;Package &lt;code&gt;&amp;lt;package qualified name&amp;gt;&lt;/code&gt;&quot; for a package.</source>
          <target state="translated">ファイル内では、モジュール全体のドキュメントと個々のパッケージのドキュメントが、対応する第1レベルの見出しで紹介されています。見出しのテキストは、モジュールの場合は「モジュール &lt;code&gt;&amp;lt;module name&amp;gt;&lt;/code&gt; 」、パッケージの場合は「パッケージ &lt;code&gt;&amp;lt;package qualified name&amp;gt;&lt;/code&gt; 」である必要があります。</target>
        </trans-unit>
        <trans-unit id="493e88f297e12412d7ac95bb437b962fd0497829" translate="yes" xml:space="preserve">
          <source>Inside the lambda of a scope function, the context object is available by a short reference instead of its actual name. Each scope function uses one of two ways to access the context object: as a lambda &lt;a href=&quot;lambdas#function-literals-with-receiver&quot;&gt;receiver&lt;/a&gt; (&lt;code&gt;this&lt;/code&gt;) or as a lambda argument (&lt;code&gt;it&lt;/code&gt;). Both provide the same capabilities, so we'll describe the pros and cons of each for different cases and provide recommendations on their use.</source>
          <target state="translated">スコープ関数のラムダ内では、コンテキストオブジェクトは、実際の名前の代わりに短い参照で利用できます。各スコープ関数は、ラムダ&lt;a href=&quot;lambdas#function-literals-with-receiver&quot;&gt;レシーバー&lt;/a&gt;（ &lt;code&gt;this&lt;/code&gt; ）またはラムダ引数（ &lt;code&gt;it&lt;/code&gt; ）として、コンテキストオブジェクトにアクセスする2つの方法のいずれかを使用します。どちらも同じ機能を提供するため、さまざまなケースについてそれぞれの長所と短所を説明し、それらの使用に関する推奨事項を提供します。</target>
        </trans-unit>
        <trans-unit id="5003ad2518c8a72a35acc2813b3f299786173c02" translate="yes" xml:space="preserve">
          <source>Inspect Generated Kotlin APIs from a C library</source>
          <target state="translated">生成されたKotlin APIをCライブラリから検査する</target>
        </trans-unit>
        <trans-unit id="40cd793a9f0552fd84c4436f73c844d1482e9756" translate="yes" xml:space="preserve">
          <source>Inspect the contents of &lt;code&gt;dist/klib/platform/$target&lt;/code&gt; of the distribution for the details.</source>
          <target state="translated">詳細については、ディストリビューションの &lt;code&gt;dist/klib/platform/$target&lt;/code&gt; の内容を調べてください。</target>
        </trans-unit>
        <trans-unit id="125c70324902d1ea37a08feb6e548d2fa859e9e8" translate="yes" xml:space="preserve">
          <source>Inspecting Generated Kotlin APIs for a C library</source>
          <target state="translated">C ライブラリの生成された Kotlin API を検査する</target>
        </trans-unit>
        <trans-unit id="bc318e2b8cd3f066b53b59698e603a8b1ca8d81c" translate="yes" xml:space="preserve">
          <source>Install custom unhandled exception hook. Returns old hook, or null if it was not specified. Hook is invoked whenever there's uncaught exception reaching boundaries of the Kotlin world, i.e. top level main(), or when Objective-C to Kotlin call not marked with @Throws throws an exception. Hook must be a frozen lambda, so that it could be called from any thread/worker. Hook is invoked once, and is cleared afterwards, so that memory leak detection works as expected even with custom exception hooks.</source>
          <target state="translated">カスタムのアンハンドレッド例外フックをインストールします。古いフックを返すか、指定されていない場合は null を返します。フックは、捕らえられなかった例外が Kotlin の世界の境界に到達したとき、つまりトップレベルの main()や、@Throws でマークされていない Objective-C から Kotlin への呼び出しで例外が発生したときに呼び出されます。フックはどのスレッドやワーカーからでも呼び出せるように、フリーズしたラムダでなければならない。フックは一度だけ呼び出され、その後はクリアされるので、カスタムの例外フックを使ってもメモリリークの検出は期待通りに動作します。</target>
        </trans-unit>
        <trans-unit id="61dc4e9bf861172198001de007eee7dfc119f627" translate="yes" xml:space="preserve">
          <source>Install libgit2 and prepare stubs for the git library:</source>
          <target state="translated">libgit2 をインストールし、git ライブラリ用のスタブを用意します。</target>
        </trans-unit>
        <trans-unit id="55178375f2d34a4d0b5f0a6c687d2b1b982ae90c" translate="yes" xml:space="preserve">
          <source>Install the &lt;a href=&quot;https://chrome.google.com/webstore/detail/jetbrains-ide-support/hmhgeddbohgjknpmjagkdomcpobmllji?hl=en&quot;&gt;JetBrains Chrome Extension&lt;/a&gt; which allows debugging inside IntelliJ IDEA via Chrome. This is useful for any type of web application developed with IntelliJ IDEA, not just Kotlin.</source>
          <target state="translated">&lt;a href=&quot;https://chrome.google.com/webstore/detail/jetbrains-ide-support/hmhgeddbohgjknpmjagkdomcpobmllji?hl=en&quot;&gt;JetBrains Chrome拡張機能&lt;/a&gt;をインストールして、Chrome経由でIntelliJ IDEA内でデバッグできるようにします。これは、Kotlinだけでなく、IntelliJ IDEAで開発されたあらゆる種類のWebアプリケーションに役立ちます。</target>
        </trans-unit>
        <trans-unit id="cba3ec3086c29abcbfa73fe1ec7eb10077b3664f" translate="yes" xml:space="preserve">
          <source>Install the &lt;a href=&quot;https://cocoapods.org/&quot;&gt;CocoaPods dependency manager&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://cocoapods.org/&quot;&gt;CocoaPods依存関係マネージャー&lt;/a&gt;をインストールします。</target>
        </trans-unit>
        <trans-unit id="7237a8f52f82477e8aca289f73e7feebfb253754" translate="yes" xml:space="preserve">
          <source>Install the &lt;a href=&quot;https://github.com/square/cocoapods-generate&quot;&gt;&lt;code&gt;cocoapods-generate&lt;/code&gt;&lt;/a&gt; plugin.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/square/cocoapods-generate&quot;&gt; &lt;code&gt;cocoapods-generate&lt;/code&gt; &lt;/a&gt;プラグインをインストールします。</target>
        </trans-unit>
        <trans-unit id="d91d23355e44b9f891a149ed27d5dd594ef16726" translate="yes" xml:space="preserve">
          <source>Install the &lt;a href=&quot;https://plugins.jetbrains.com/plugin/10081-edutools&quot;&gt;EduTools plugin&lt;/a&gt; for IDEA and complete exercises from the &lt;a href=&quot;https://www.jetbrains.com/help/education/learner-start-guide.html?section=Kotlin%20Koans&quot;&gt;Kotlin Koans course&lt;/a&gt;</source>
          <target state="translated">IDEA用の&lt;a href=&quot;https://plugins.jetbrains.com/plugin/10081-edutools&quot;&gt;EduToolsプラグイン&lt;/a&gt;をインストールし、KotlinKoans&lt;a href=&quot;https://www.jetbrains.com/help/education/learner-start-guide.html?section=Kotlin%20Koans&quot;&gt;コースの&lt;/a&gt;演習を完了します</target>
        </trans-unit>
        <trans-unit id="a6c9c342f22b1bebf06cebee1a33f0bf01b82e59" translate="yes" xml:space="preserve">
          <source>Install the CocoaPods dependency manager and plugin</source>
          <target state="translated">CocoaPods の依存関係マネージャとプラグインをインストールします。</target>
        </trans-unit>
        <trans-unit id="1a87099d120ccde681dac7b4563f2ddd1e2d4aca" translate="yes" xml:space="preserve">
          <source>Install the Kotlin Plugin 1.4.x or higher in the IDE. You can check the Kotlin version in &lt;strong&gt;Tools&lt;/strong&gt; | &lt;strong&gt;Kotlin&lt;/strong&gt; | &lt;strong&gt;Configure Plugin Updates&lt;/strong&gt;.</source>
          <target state="translated">Kotlinプラグイン1.4.x以降をIDEにインストールします。Kotlinのバージョンは&lt;strong&gt;ツール&lt;/strong&gt;|で確認でき&lt;strong&gt;ます&lt;/strong&gt;。&lt;strong&gt;Kotlin&lt;/strong&gt; | &lt;strong&gt;プラグインの更新を構成します&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="fdaed5952d98f86231a297a2212142ac7c035122" translate="yes" xml:space="preserve">
          <source>Installing EduTools plugin</source>
          <target state="translated">EduToolsプラグインのインストール</target>
        </trans-unit>
        <trans-unit id="2a79a656994e8f8c151cea0c7b39c2c9e4d16ed5" translate="yes" xml:space="preserve">
          <source>Instance Checks</source>
          <target state="translated">インスタンスチェック</target>
        </trans-unit>
        <trans-unit id="9e1218ddd72144e647203114e5a8e7ec310019cb" translate="yes" xml:space="preserve">
          <source>Instance fields</source>
          <target state="translated">インスタンスフィールド</target>
        </trans-unit>
        <trans-unit id="808164c9992eeb307ee53ea9dae39f6fb259b6e5" translate="yes" xml:space="preserve">
          <source>Instance required to make a call to the member, or an outer class instance for an inner class constructor.</source>
          <target state="translated">メンバへの呼び出しに必要なインスタンス、またはインナー・クラスのコンストラクタのためのアウター・クラスのインスタンス。</target>
        </trans-unit>
        <trans-unit id="a15783fb8d36e7147f368f4e99e9d406c5062f79" translate="yes" xml:space="preserve">
          <source>Instantiating a function type</source>
          <target state="translated">関数型のインスタンス化</target>
        </trans-unit>
        <trans-unit id="323fad682a062c4a52dfeb27dd2280fe7981b362" translate="yes" xml:space="preserve">
          <source>Instead of &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;coroutineScope&lt;/a&gt;, we can use &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/supervisor-scope.html&quot;&gt;supervisorScope&lt;/a&gt; for &lt;em&gt;scoped&lt;/em&gt; concurrency. It propagates the cancellation in one direction only and cancels all its children only if it failed itself. It also waits for all children before completion just like &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;coroutineScope&lt;/a&gt; does.</source>
          <target state="translated">&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;coroutineScopeの&lt;/a&gt;代わりに、&lt;em&gt;スコープ付き&lt;/em&gt;同時実行に&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/supervisor-scope.html&quot;&gt;supervisorScope&lt;/a&gt;を&lt;em&gt;使用&lt;/em&gt;できます。キャンセルは一方向にのみ伝播し、失敗した場合にのみすべての子をキャンセルします。また、&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;coroutineScope&lt;/a&gt;と同様に、完了する前にすべての子を待機します。</target>
        </trans-unit>
        <trans-unit id="4d2cc7618aade0b4e22b2f6e46628e00aba0ed39" translate="yes" xml:space="preserve">
          <source>Instead of calling the method &lt;code&gt;matches&lt;/code&gt; directly we are storing a reference to it. Such reference is bound to its receiver. It can be called directly (like in the example above) or used whenever an expression of function type is expected:</source>
          <target state="translated">メソッド &lt;code&gt;matches&lt;/code&gt; 直接呼び出す代わりに、メソッドへの参照を保存します。そのような参照はそのレシーバーにバインドされます。（上記の例のように）直接呼び出すことも、関数型の式が期待される場合はいつでも使用できます。</target>
        </trans-unit>
        <trans-unit id="aad6314ddaef7ba86c76eaf3164d0bca4da5fc5d" translate="yes" xml:space="preserve">
          <source>Instead of creating a class that implements a functional interface manually, you can use a lambda expression. With a SAM conversion, Kotlin can convert any lambda expression whose signature matches the signature of the interface's single method into an instance of a class that implements the interface.</source>
          <target state="translated">機能的なインターフェースを実装するクラスを手動で作成する代わりに、ラムダ式を使用することができます。SAM変換を使うと、Kotlinはインターフェースの単一メソッドのシグネチャと一致するラムダ式を、インターフェースを実装したクラスのインスタンスに変換することができます。</target>
        </trans-unit>
        <trans-unit id="8213790556130c398f868064e28de372b2469df8" translate="yes" xml:space="preserve">
          <source>Instead of creating a function object for the parameter and generating a call, the compiler could emit the following code:</source>
          <target state="translated">パラメータの関数オブジェクトを作成して呼び出しを生成する代わりに、コンパイラは以下のコードを出力します。</target>
        </trans-unit>
        <trans-unit id="07b156a4a7a7d22439a598737b46c70a6ec2b640" translate="yes" xml:space="preserve">
          <source>Instead of doing this, you can create a hierarchical structure with &lt;a href=&quot;mpp-share-on-platforms#use-target-shortcuts&quot;&gt;target shortcuts&lt;/a&gt; available for typical multi-target scenarios, or you can manually declare and connect the source sets. For example, you can create two iOS targets and a shared source set with the &lt;code&gt;ios()&lt;/code&gt; shortcut:</source>
          <target state="translated">これを行う代わりに、一般的なマルチターゲットシナリオで使用可能な&lt;a href=&quot;mpp-share-on-platforms#use-target-shortcuts&quot;&gt;ターゲットショートカットを&lt;/a&gt;使用して階層構造を作成するか、ソースセットを手動で宣言して接続することができます。たとえば、 &lt;code&gt;ios()&lt;/code&gt; ショートカットを使用して2つのiOSターゲットと共有ソースセットを作成できます。</target>
        </trans-unit>
        <trans-unit id="db904fe60f6fc13954beaf8c6781a1e474eddead" translate="yes" xml:space="preserve">
          <source>Instead of manually compiling and executing our Kotlin/JS project every time we want to see the changes we made, we can make use of the &lt;em&gt;continuous compilation&lt;/em&gt; mode. Instead of using the regular &lt;code&gt;run&lt;/code&gt; command, we instead invoke the Gradle wrapper in &lt;em&gt;continuous&lt;/em&gt; mode:</source>
          <target state="translated">行った変更を確認するたびにKotlin / JSプロジェクトを手動でコンパイルして実行する代わりに、&lt;em&gt;連続コンパイル&lt;/em&gt;モードを利用できます。通常の &lt;code&gt;run&lt;/code&gt; コマンドを使用する代わりに、代わりに&lt;em&gt;連続&lt;/em&gt;モードでGradleラッパーを呼び出します。</target>
        </trans-unit>
        <trans-unit id="f83cef13eec16cda3d2cf44a7d9356f601633a76" translate="yes" xml:space="preserve">
          <source>Instead of threads Kotlin/Native runtime offers the concept of workers: concurrently executed control flow streams with an associated request queue. Workers are very similar to the actors in the Actor Model. A worker can exchange Kotlin objects with another worker, so that at any moment each mutable object is owned by a single worker, but ownership can be transferred. See section &lt;a href=&quot;#transfer&quot;&gt;Object transfer and freezing&lt;/a&gt;.</source>
          <target state="translated">スレッドの代わりにKotlin / Nativeランタイムはワーカーの概念を提供します：同時に実行される制御フローストリームと関連するリクエストキュー。ワーカーは、アクターモデルのアクターとよく似ています。ワーカーはKotlinオブジェクトを別のワーカーと交換できます。そのため、いつでも各可変オブジェクトは単一のワーカーによって所有されますが、所有権は譲渡できます。See section &lt;a href=&quot;#transfer&quot;&gt;オブジェクトの転送と凍結&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="72f70be3d9872cba860894ac5cf17293ed0d78f8" translate="yes" xml:space="preserve">
          <source>Instructs compiler to generate or omit wildcards for type arguments corresponding to parameters with declaration-site variance, for example such as &lt;code&gt;Collection&amp;lt;out T&amp;gt;&lt;/code&gt; has.</source>
          <target state="translated">&lt;code&gt;Collection&amp;lt;out T&amp;gt;&lt;/code&gt; ように、宣言サイトに差異があるパラメーターに対応する型引数のワイルドカードを生成または省略するようにコンパイラーに指示します。</target>
        </trans-unit>
        <trans-unit id="783a81e7c87c37045741ac6ac177384c0af024d5" translate="yes" xml:space="preserve">
          <source>Instructs compiler to generate wildcard for annotated type arguments corresponding to parameters with declaration-site variance.</source>
          <target state="translated">宣言サイト分散を持つパラメータに対応する注釈付き型引数のワイルドカードを生成するようにコンパイラに指示します。</target>
        </trans-unit>
        <trans-unit id="2008818ef3a5b5313d7106b4d54dde4c0275e9fe" translate="yes" xml:space="preserve">
          <source>Instructs the Kotlin compiler not to generate getters/setters for this property and expose it as a field.</source>
          <target state="translated">Kotlin コンパイラがこのプロパティのゲッター/セッターを生成せず、フィールドとして公開するように指示します。</target>
        </trans-unit>
        <trans-unit id="13386323cf0532c0c864d57e3f5e6f155f3a611f" translate="yes" xml:space="preserve">
          <source>Instructs the Kotlin compiler to generate a multifile class with top-level functions and properties declared in this file as one of its parts. Name of the corresponding multifile class is provided by the &lt;a href=&quot;-jvm-name/index#kotlin.jvm.JvmName&quot;&gt;JvmName&lt;/a&gt; annotation.</source>
          <target state="translated">Kotlinコンパイラーに、最上位の関数とプロパティがこのファイルでその一部の1つとして宣言されているマルチファイルクラスを生成するように指示します。対応するマルチ&lt;a href=&quot;-jvm-name/index#kotlin.jvm.JvmName&quot;&gt;ファイル&lt;/a&gt;クラスの名前は、JvmNameアノテーションによって提供されます。</target>
        </trans-unit>
        <trans-unit id="c90ad955a31d769d0ca4882df53d8563d188c893" translate="yes" xml:space="preserve">
          <source>Instructs the Kotlin compiler to generate a multifile class with top-level functions and properties declared in this file as one of its parts. Name of the corresponding multifile class is provided by the &lt;a href=&quot;../-jvm-name/index#kotlin.jvm.JvmName&quot;&gt;JvmName&lt;/a&gt; annotation.</source>
          <target state="translated">Kotlinコンパイラーに、最上位の関数とプロパティがこのファイルでその一部の1つとして宣言されているマルチファイルクラスを生成するように指示します。対応するマルチ&lt;a href=&quot;../-jvm-name/index#kotlin.jvm.JvmName&quot;&gt;ファイル&lt;/a&gt;クラスの名前は、JvmNameアノテーションによって提供されます。</target>
        </trans-unit>
        <trans-unit id="8b0c8be222fd671f12f20bd767b02c4381772bb8" translate="yes" xml:space="preserve">
          <source>Instructs the Kotlin compiler to generate a multifile class with top-level functions and properties declared in this file as one of its parts. Name of the corresponding multifile class is provided by the &lt;a href=&quot;../../kotlin.jvm/-jvm-name/index#kotlin.jvm.JvmName&quot;&gt;JvmName&lt;/a&gt; annotation.</source>
          <target state="translated">Kotlinコンパイラーに、最上位の関数とプロパティがこのファイルでその一部の1つとして宣言されているマルチファイルクラスを生成するように指示します。対応するマルチ&lt;a href=&quot;../../kotlin.jvm/-jvm-name/index#kotlin.jvm.JvmName&quot;&gt;ファイル&lt;/a&gt;クラスの名前は、JvmNameアノテーションによって提供されます。</target>
        </trans-unit>
        <trans-unit id="7818697c4ce6725112184b56cee9c62bbd312790" translate="yes" xml:space="preserve">
          <source>Instructs the Kotlin compiler to generate a multifile class with top-level functions and properties declared in this file as one of its parts. Name of the corresponding multifile class is provided by the &lt;a href=&quot;../kotlin.jvm/-jvm-name/index#kotlin.jvm.JvmName&quot;&gt;JvmName&lt;/a&gt; annotation.</source>
          <target state="translated">Kotlinコンパイラーに、最上位の関数とプロパティがこのファイルでその一部の1つとして宣言されているマルチファイルクラスを生成するように指示します。対応するマルチ&lt;a href=&quot;../kotlin.jvm/-jvm-name/index#kotlin.jvm.JvmName&quot;&gt;ファイル&lt;/a&gt;クラスの名前は、JvmNameアノテーションによって提供されます。</target>
        </trans-unit>
        <trans-unit id="b493b4c87b9464cb2f6602a1607cbc49417f03a7" translate="yes" xml:space="preserve">
          <source>Instructs the Kotlin compiler to generate overloads for this function that substitute default parameter values.</source>
          <target state="translated">Kotlinコンパイラにこの関数のオーバーロードを生成し、デフォルトのパラメータ値を代用するよう指示します。</target>
        </trans-unit>
        <trans-unit id="b7b71d6677358cf2e0528038c668cb35b0db79e9" translate="yes" xml:space="preserve">
          <source>Instructs the Kotlin compiler to treat annotated Java class as pure implementation of given Kotlin interface. &quot;Pure&quot; means here that each type parameter of class becomes non-platform type argument of that interface.</source>
          <target state="translated">Kotlinコンパイラに、アノテーションされたJavaクラスを、与えられたKotlinインターフェースの純粋な実装として扱うように指示します。&quot;純粋 &quot;とは、クラスの各型パラメータがそのインターフェースの非プラットフォーム型引数になることを意味します。</target>
        </trans-unit>
        <trans-unit id="5c89edcac2811a6a9e8072517cae7f3cbfd5049d" translate="yes" xml:space="preserve">
          <source>Int</source>
          <target state="translated">Int</target>
        </trans-unit>
        <trans-unit id="691e0102b6c4ff1f7d6b4b79971b501f00d71a45" translate="yes" xml:space="preserve">
          <source>Int16Array</source>
          <target state="translated">Int16Array</target>
        </trans-unit>
        <trans-unit id="5c193dd46f10dac764d5258087bf039ad767fbce" translate="yes" xml:space="preserve">
          <source>Int32Array</source>
          <target state="translated">Int32Array</target>
        </trans-unit>
        <trans-unit id="e088a2144c05ba06fd761a7dbefbb84d2fc79069" translate="yes" xml:space="preserve">
          <source>Int8Array</source>
          <target state="translated">Int8Array</target>
        </trans-unit>
        <trans-unit id="4e1eee767ff111b716b2cc9473b02ef4802f7fa3" translate="yes" xml:space="preserve">
          <source>IntArray</source>
          <target state="translated">IntArray</target>
        </trans-unit>
        <trans-unit id="80050b51df21784d163dd20b4b73efde68f88f12" translate="yes" xml:space="preserve">
          <source>IntIterator</source>
          <target state="translated">IntIterator</target>
        </trans-unit>
        <trans-unit id="5808b7bdff6fe2202d34d31f55aa02c48c8f9d57" translate="yes" xml:space="preserve">
          <source>IntProgression</source>
          <target state="translated">IntProgression</target>
        </trans-unit>
        <trans-unit id="1ecd34c101b616e04032d5f18915a529dbf2c1ba" translate="yes" xml:space="preserve">
          <source>IntRange</source>
          <target state="translated">IntRange</target>
        </trans-unit>
        <trans-unit id="122a70b702fe4ea6640b0afbf0db142a8ee86964" translate="yes" xml:space="preserve">
          <source>IntVar</source>
          <target state="translated">IntVar</target>
        </trans-unit>
        <trans-unit id="3d2bffbceb8bff9b98f810d1689ed67697bea8bf" translate="yes" xml:space="preserve">
          <source>IntVarOf</source>
          <target state="translated">IntVarOf</target>
        </trans-unit>
        <trans-unit id="876569ad85ebaf17d9149dea5706aba22e882fe8" translate="yes" xml:space="preserve">
          <source>Integer types</source>
          <target state="translated">整数型</target>
        </trans-unit>
        <trans-unit id="dee1ac1dc651dc2435d67e71a4478aae5437b7bf" translate="yes" xml:space="preserve">
          <source>Integer types in Kotlin have a &lt;em&gt;limited size&lt;/em&gt;, as opposed to the arbitrarily large integers in Python. The limit depends on the type, which decides how many bits the number occupies in memory:</source>
          <target state="translated">Pythonの任意の大きな整数とは対照的に、Kotlinの整数型の&lt;em&gt;サイズ&lt;/em&gt;は&lt;em&gt;制限さ&lt;/em&gt;れています。制限はタイプに依存し、メモリ内でビットが何ビットを占有するかを決定します。</target>
        </trans-unit>
        <trans-unit id="cda60a10cf7788b96a2f3e8c4df843ff16bf37d4" translate="yes" xml:space="preserve">
          <source>Integral type ranges (&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/-int-range/index&quot;&gt;&lt;code&gt;IntRange&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/-long-range/index&quot;&gt;&lt;code&gt;LongRange&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/-char-range/index&quot;&gt;&lt;code&gt;CharRange&lt;/code&gt;&lt;/a&gt;) have an extra feature: they can be iterated over. These ranges are also &lt;a href=&quot;https://en.wikipedia.org/wiki/Arithmetic_progression&quot;&gt;progressions&lt;/a&gt; of the corresponding integral types. Such ranges are generally used for iteration in the &lt;code&gt;for&lt;/code&gt; loops.</source>
          <target state="translated">整数型の範囲（&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/-int-range/index&quot;&gt; &lt;code&gt;IntRange&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/-long-range/index&quot;&gt; &lt;code&gt;LongRange&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/-char-range/index&quot;&gt; &lt;code&gt;CharRange&lt;/code&gt; &lt;/a&gt;）には、追加の機能があり、反復することができます。これらの範囲は、対応する整数型の&lt;a href=&quot;https://en.wikipedia.org/wiki/Arithmetic_progression&quot;&gt;累進&lt;/a&gt;でもあります。このような範囲は、一般的に &lt;code&gt;for&lt;/code&gt; ループの反復に使用されます。</target>
        </trans-unit>
        <trans-unit id="13f8bf35d86cdecdc30977f1b4bf82da0dde4e54" translate="yes" xml:space="preserve">
          <source>IntelliJ IDEA can also automatically generate the &lt;code&gt;@Suppress&lt;/code&gt; annotation. Open the intentions menu via the light bulb icon or Alt-Enter, and click the small arrow next to the &quot;Change type arguments&quot; quick-fix. Here, you can select the suppression scope, and your IDE will add the annotation to your file accordingly.</source>
          <target state="translated">IntelliJ IDEAは、 &lt;code&gt;@Suppress&lt;/code&gt; アノテーションを自動的に生成することもできます。電球アイコンまたはAlt-Enterを使用して意図メニューを開き、[タイプ引数の変更]クイックフィックスの横にある小さな矢印をクリックします。ここで、抑制スコープを選択できます。IDEはそれに応じてファイルに注釈を追加します。</target>
        </trans-unit>
        <trans-unit id="2bee37b0cdd0528c3a6b459962cdaf6bec045292" translate="yes" xml:space="preserve">
          <source>IntelliJ IDEA can also automatically generate the &lt;code&gt;@Suppress&lt;/code&gt; annotation. Open the intentions menu via the light bulb icon or Alt-Enter, and click the small arrow next to the &quot;Unchecked cast to external interface&quot; inspection. Here, you can select the suppression scope, and your IDE will add the annotation to your file accordingly.</source>
          <target state="translated">IntelliJ IDEAは、 &lt;code&gt;@Suppress&lt;/code&gt; アノテーションを自動的に生成することもできます。電球アイコンまたはAlt-Enterを使用して意図メニューを開き、[外部インターフェイスへのチェックされていないキャスト]検査の横にある小さな矢印をクリックします。ここで、抑制スコープを選択できます。IDEはそれに応じてファイルに注釈を追加します。</target>
        </trans-unit>
        <trans-unit id="10bb7deeea7ab770c8cc611de5a7e9bd46c52593" translate="yes" xml:space="preserve">
          <source>IntelliJ IDEA can run the code from scratches and worksheets automatically. To get the execution results when you stop typing, switch on the &lt;strong&gt;Interactive mode&lt;/strong&gt;.</source>
          <target state="translated">IntelliJ IDEAは、コードを最初から実行し、ワークシートを自動的に実行できます。入力を停止したときに実行結果を取得するには、&lt;strong&gt;インタラクティブモードを&lt;/strong&gt;オンにし&lt;strong&gt;ます&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="8489966f59e24770658292f5a494ac85bfb4f6e0" translate="yes" xml:space="preserve">
          <source>IntelliJ IDEA can run your scratches automatically. To get the execution results once you stop typing for a short time, switch on the &lt;strong&gt;Interactive mode&lt;/strong&gt;.</source>
          <target state="translated">IntelliJ IDEAはスクラッチを自動的に実行できます。しばらく入力をやめたときに実行結果を取得するには、&lt;strong&gt;インタラクティブモードを&lt;/strong&gt;オンにし&lt;strong&gt;ます&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="918971018a2752255f900c2cf2e714f49b6e48a7" translate="yes" xml:space="preserve">
          <source>IntelliJ IDEA opens the &lt;strong&gt;Run&lt;/strong&gt; tab and shows the output.</source>
          <target state="translated">IntelliJ IDEAは[&lt;strong&gt;実行&lt;/strong&gt;]タブを開き、出力を表示します。</target>
        </trans-unit>
        <trans-unit id="412b9a62ef1aac11c1728c644747bfbcd40b3ae6" translate="yes" xml:space="preserve">
          <source>IntelliJ IDEA opens the &lt;strong&gt;Run&lt;/strong&gt; tab and shows the output:</source>
          <target state="translated">IntelliJ IDEAは[&lt;strong&gt;実行&lt;/strong&gt;]タブを開き、出力を表示します。</target>
        </trans-unit>
        <trans-unit id="11066aac7596078ae46263d8a457c412baa42d01" translate="yes" xml:space="preserve">
          <source>IntelliJ IDEA will add the corresponding entries for us in the &lt;a href=&quot;#maven-configuration&quot;&gt;Maven configuration&lt;/a&gt;.</source>
          <target state="translated">IntelliJ IDEAは、対応するエントリを&lt;a href=&quot;#maven-configuration&quot;&gt;Maven構成に&lt;/a&gt;追加します。</target>
        </trans-unit>
        <trans-unit id="eff2bf29e6c4ca5eac858ebfb9f2e0be07577de6" translate="yes" xml:space="preserve">
          <source>IntelliJ IDEA's kotlin plugin understands the semantics of &lt;code&gt;TODO()&lt;/code&gt; and automatically adds a code pointer in the TODO toolwindow.</source>
          <target state="translated">IntelliJ IDEAのkotlinプラグインは、 &lt;code&gt;TODO()&lt;/code&gt; のセマンティクスを理解し、TODOツールウィンドウにコードポインターを自動的に追加します。</target>
        </trans-unit>
        <trans-unit id="54d05b8bf6f20e0d324256cf774765900389821b" translate="yes" xml:space="preserve">
          <source>Interact with the DOM</source>
          <target state="translated">DOM との相互作用</target>
        </trans-unit>
        <trans-unit id="2c419294377dd8ca37e7cb76b4dea91ed19ea8dc" translate="yes" xml:space="preserve">
          <source>Interacting with the DOM</source>
          <target state="translated">DOM との相互作用</target>
        </trans-unit>
        <trans-unit id="4ee5033c0dc3e88efff33103b78dd8f7118a9355" translate="yes" xml:space="preserve">
          <source>Interactive editors</source>
          <target state="translated">インタラクティブエディタ</target>
        </trans-unit>
        <trans-unit id="0d798c0b1cd4a6d135dc1e4671cde5f33dab863b" translate="yes" xml:space="preserve">
          <source>Interactive mode</source>
          <target state="translated">インタラクティブモード</target>
        </trans-unit>
        <trans-unit id="b02084f4df61f4f1999048df4a4f737cbeb8d5d5" translate="yes" xml:space="preserve">
          <source>Intercept continuation with &lt;a href=&quot;../-continuation-interceptor/index&quot;&gt;ContinuationInterceptor&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../-continuation-interceptor/index&quot;&gt;ContinuationInterceptorを使用して&lt;/a&gt;継続をインターセプトします。</target>
        </trans-unit>
        <trans-unit id="653ee20081a2ed0c0dfdeafb8d4cc56b1706495b" translate="yes" xml:space="preserve">
          <source>Intercept continuation with &lt;a href=&quot;../kotlin.coroutines.experimental/-continuation-interceptor/index&quot;&gt;ContinuationInterceptor&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../kotlin.coroutines.experimental/-continuation-interceptor/index&quot;&gt;ContinuationInterceptorを使用して&lt;/a&gt;継続をインターセプトします。</target>
        </trans-unit>
        <trans-unit id="ef76b9eb4630422886c9e0fac2f1db0f2f6f1af1" translate="yes" xml:space="preserve">
          <source>Interception of delegated property binding</source>
          <target state="translated">委譲されたプロパティのバインディングの傍受</target>
        </trans-unit>
        <trans-unit id="fc7a4e9264f9fe99aec05e3498611be00e954e41" translate="yes" xml:space="preserve">
          <source>Intercepts this continuation with &lt;a href=&quot;../kotlin.coroutines/-continuation-interceptor/index&quot;&gt;ContinuationInterceptor&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../kotlin.coroutines/-continuation-interceptor/index&quot;&gt;ContinuationInterceptorで&lt;/a&gt;この継続をインターセプトします。</target>
        </trans-unit>
        <trans-unit id="16bd3eae0558639cfe5dccb9e5a929f401a38bef" translate="yes" xml:space="preserve">
          <source>Interface implementation layout</source>
          <target state="translated">インターフェースの実装レイアウト</target>
        </trans-unit>
        <trans-unit id="b4d21bf63ded1f81b33de5ff71ef6ec0031cdd1f" translate="yes" xml:space="preserve">
          <source>Interface representing a continuation after a suspension point that returns a value of type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">タイプ &lt;code&gt;T&lt;/code&gt; の値を返す中断ポイントの後の継続を表すインターフェース。</target>
        </trans-unit>
        <trans-unit id="3d559a197ac3fd74c061414f5d71be30830c373e" translate="yes" xml:space="preserve">
          <source>Interface representing a continuation after a suspension point that returns value of type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">タイプ &lt;code&gt;T&lt;/code&gt; の値を返す中断点の後の継続を表すインターフェース。</target>
        </trans-unit>
        <trans-unit id="b356313f979923fc829adb909098ed26a5a01aff" translate="yes" xml:space="preserve">
          <source>Interfaces</source>
          <target state="translated">Interfaces</target>
        </trans-unit>
        <trans-unit id="3fb0788052e6b21a9e30969754a6a4b19102a8cb" translate="yes" xml:space="preserve">
          <source>Interfaces &lt;em&gt;A&lt;/em&gt; and &lt;em&gt;B&lt;/em&gt; both declare functions &lt;em&gt;foo()&lt;/em&gt; and &lt;em&gt;bar()&lt;/em&gt;. Both of them implement &lt;em&gt;foo()&lt;/em&gt;, but only &lt;em&gt;B&lt;/em&gt; implements &lt;em&gt;bar()&lt;/em&gt; (&lt;em&gt;bar()&lt;/em&gt; is not marked abstract in &lt;em&gt;A&lt;/em&gt;, because this is the default for interfaces, if the function has no body). Now, if we derive a concrete class &lt;em&gt;C&lt;/em&gt; from &lt;em&gt;A&lt;/em&gt;, we, obviously, have to override &lt;em&gt;bar()&lt;/em&gt; and provide an implementation.</source>
          <target state="translated">インターフェース&lt;em&gt;A&lt;/em&gt;と&lt;em&gt;Bは&lt;/em&gt;どちらも関数&lt;em&gt;foo（）&lt;/em&gt;と&lt;em&gt;bar（）を&lt;/em&gt;宣言しています。それらの両方が実装&lt;em&gt;FOOを（）&lt;/em&gt;が、唯一の&lt;em&gt;B&lt;/em&gt;実装の&lt;em&gt;バー（） &lt;/em&gt;（&lt;em&gt;バーは（）&lt;/em&gt;で抽象的にマークされていない&lt;em&gt;A&lt;/em&gt;機能に本体がない場合、これは、インターフェイスのデフォルトであるため、）。ここで、&lt;em&gt;A&lt;/em&gt;から具象クラス&lt;em&gt;C&lt;/em&gt;を派生させる場合、明らかに、&lt;em&gt;bar（）&lt;/em&gt;をオーバーライドして実装を提供する必要があります。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="99ffdc8085488e57490fe414d8c6f2ac4c1599ac" translate="yes" xml:space="preserve">
          <source>Interfaces Inheritance</source>
          <target state="translated">インターフェース継承</target>
        </trans-unit>
        <trans-unit id="8b075e134839d5d81cca3ebe6834964746dbfa9f" translate="yes" xml:space="preserve">
          <source>Interfaces in Kotlin are very similar to Java 8. They can contain declarations of abstract methods, as well as method implementations. What makes them different from abstract classes is that interfaces cannot store state. They can have properties but these need to be abstract or to provide accessor implementations.</source>
          <target state="translated">KotlinのインターフェイスはJava 8と非常に似ています。インターフェースには、メソッドの実装だけでなく、抽象メソッドの宣言を含めることができます。抽象クラスと異なる点は、インターフェイスは状態を保存できないということです。プロパティを持つことはできますが、それらは抽象化されているか、アクセサの実装を提供する必要があります。</target>
        </trans-unit>
        <trans-unit id="3dc6f1c623405f44dfc6225166b717008c4b39d3" translate="yes" xml:space="preserve">
          <source>Interfaces in Kotlin can contain declarations of abstract methods, as well as method implementations. What makes them different from abstract classes is that interfaces cannot store state. They can have properties but these need to be abstract or to provide accessor implementations.</source>
          <target state="translated">Kotlin のインターフェイスは、メソッドの実装だけでなく、抽象メソッドの宣言を含むことができます。抽象クラスと異なる点は、インターフェイスは状態を保存できないということです。インターフェースはプロパティを持つことができますが、それらは抽象クラスであるか、アクセサの実装を提供する必要があります。</target>
        </trans-unit>
        <trans-unit id="6f2e69a2381964d98d7dca2d48b42c9749b41571" translate="yes" xml:space="preserve">
          <source>Intermediate flow operators</source>
          <target state="translated">中間フロー演算子</target>
        </trans-unit>
        <trans-unit id="f3a19a0ac9dc5495efba84238a1c889b8a1af7e4" translate="yes" xml:space="preserve">
          <source>Interop with Java</source>
          <target state="translated">JavaとのInterop</target>
        </trans-unit>
        <trans-unit id="c644acaf1f3c1a0ed7a1256f251846c1b5938545" translate="yes" xml:space="preserve">
          <source>InteropStubs</source>
          <target state="translated">InteropStubs</target>
        </trans-unit>
        <trans-unit id="e8ee8f70e7d8b9c0f444242c7791f8de975f2a89" translate="yes" xml:space="preserve">
          <source>Interoperability</source>
          <target state="translated">Interoperability</target>
        </trans-unit>
        <trans-unit id="68de227c33695f7eee1af76e54576c5f473dbabb" translate="yes" xml:space="preserve">
          <source>Interoperability With Java Reflection</source>
          <target state="translated">Java Reflectionとの相互運用性</target>
        </trans-unit>
        <trans-unit id="2a2e730dccd30c2b052062769d22631b368b3446" translate="yes" xml:space="preserve">
          <source>Interoperability with Java reflection</source>
          <target state="translated">Java リフレクションとの相互運用性</target>
        </trans-unit>
        <trans-unit id="768631baf54d445fa8bf1b363fe5b7347532e0f6" translate="yes" xml:space="preserve">
          <source>Interoperability with Swift/Objective-C is provided too and covered in a separate document &lt;a href=&quot;objc_interop&quot;&gt;OBJC_INTEROP.md&lt;/a&gt;.</source>
          <target state="translated">Swift / Objective-Cとの相互運用性も提供されており、別のドキュメント&lt;a href=&quot;objc_interop&quot;&gt;OBJC_INTEROP.mdで&lt;/a&gt;カバーされています。</target>
        </trans-unit>
        <trans-unit id="fc3ed9f2e2ef0d7ff8b99c31c5f5dfba491948e8" translate="yes" xml:space="preserve">
          <source>Introduce a local variable &lt;code&gt;name&lt;/code&gt; with the keyword &lt;code&gt;val&lt;/code&gt;. It will get its value from an input where you will enter your name &amp;ndash; &lt;code&gt;readLine()&lt;/code&gt;.</source>
          <target state="translated">キーワード &lt;code&gt;val&lt;/code&gt; を使用してローカル変数 &lt;code&gt;name&lt;/code&gt; を導入します。それはあなたがあなたの名前を入力する入力からその値を取得します&amp;ndash; &lt;code&gt;readLine()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cf0f2c7977d4a0d28911368671a5b929d3d0eeba" translate="yes" xml:space="preserve">
          <source>Introducing an expression as a variable in local scope: &lt;code&gt;let&lt;/code&gt;</source>
          <target state="translated">式をローカルスコープの変数として導入： &lt;code&gt;let&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="32255fd1a8ee65ebb05876eff1fd292d27126703" translate="yes" xml:space="preserve">
          <source>Introduction to Kotlin (in Russian)</source>
          <target state="translated">コトリン入門(ロシア語</target>
        </trans-unit>
        <trans-unit id="8907e06f66221d3c7deda7eaa03a2cc4d7313211" translate="yes" xml:space="preserve">
          <source>Introduction to Kotlin Programming</source>
          <target state="translated">Kotlinプログラミング入門</target>
        </trans-unit>
        <trans-unit id="1a733ca17cc418ac2040451ede20832965697fc4" translate="yes" xml:space="preserve">
          <source>InvalidMutabilityException</source>
          <target state="translated">InvalidMutabilityException</target>
        </trans-unit>
        <trans-unit id="f4afeb75d0f49bdd06579dbdb4f04043561414aa" translate="yes" xml:space="preserve">
          <source>Invariant projections of type arguments, such as &lt;code&gt;Smth&amp;lt;@Ann Foo&amp;gt;&lt;/code&gt;, &lt;code&gt;Array&amp;lt;@Ann Foo&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Smth&amp;lt;@Ann Foo&amp;gt;&lt;/code&gt; 、 &lt;code&gt;Array&amp;lt;@Ann Foo&amp;gt;&lt;/code&gt; &amp;gt;などの型引数の不変射影。</target>
        </trans-unit>
        <trans-unit id="ed8bc42e69c9abe4619cbcab39f65339c9a9ce60" translate="yes" xml:space="preserve">
          <source>Inverts the bits in this value.</source>
          <target state="translated">この値のビットを反転させます。</target>
        </trans-unit>
        <trans-unit id="555df15449eba01e6d316f12f10d25ead6974375" translate="yes" xml:space="preserve">
          <source>Inverts the bits including the sign bit in this value.</source>
          <target state="translated">この値の符号ビットを含むビットを反転させます。</target>
        </trans-unit>
        <trans-unit id="1808969803eb296cd6d4f6a8c06b19cec81c8416" translate="yes" xml:space="preserve">
          <source>Invocation of &lt;a href=&quot;../kotlin.coroutines/-continuation/resume-with&quot;&gt;Continuation.resumeWith&lt;/a&gt; resumes coroutine directly in the invoker's thread without going through the &lt;a href=&quot;../kotlin.coroutines/-continuation-interceptor/index&quot;&gt;ContinuationInterceptor&lt;/a&gt; that might be present in the coroutine's &lt;a href=&quot;../kotlin.coroutines/-coroutine-context/index&quot;&gt;CoroutineContext&lt;/a&gt;. It is the invoker's responsibility to ensure that a proper invocation context is established. &lt;a href=&quot;intercepted#kotlin.coroutines.intrinsics%24intercepted%28kotlin.coroutines.Continuation%28%28kotlin.coroutines.intrinsics.intercepted.T%29%29%29&quot;&gt;Continuation.intercepted&lt;/a&gt; can be used to acquire the intercepted continuation.</source>
          <target state="translated">呼び出し&lt;a href=&quot;../kotlin.coroutines/-continuation/resume-with&quot;&gt;Continuation.resumeWithは&lt;/a&gt;経由せずに呼び出し元のスレッドに直接コルーチンを再開&lt;a href=&quot;../kotlin.coroutines/-continuation-interceptor/index&quot;&gt;ContinuationInterceptor&lt;/a&gt;コルーチンの中に存在するかもしれない&lt;a href=&quot;../kotlin.coroutines/-coroutine-context/index&quot;&gt;CoroutineContext&lt;/a&gt;。適切な呼び出しコンテキストが確立されるようにするのは、呼び出し側の責任です。&lt;a href=&quot;intercepted#kotlin.coroutines.intrinsics%24intercepted%28kotlin.coroutines.Continuation%28%28kotlin.coroutines.intrinsics.intercepted.T%29%29%29&quot;&gt;Continuation.intercepted&lt;/a&gt;を使用して、インターセプトされた継続を取得できます。</target>
        </trans-unit>
        <trans-unit id="12923fefc07e48286763b781976e0602cda671d5" translate="yes" xml:space="preserve">
          <source>Invocation of &lt;a href=&quot;../kotlin.coroutines/-continuation/resume-with&quot;&gt;Continuation.resumeWith&lt;/a&gt; resumes coroutine directly in the invoker's thread without going through the &lt;a href=&quot;../kotlin.coroutines/-continuation-interceptor/index&quot;&gt;ContinuationInterceptor&lt;/a&gt; that might be present in the coroutine's &lt;a href=&quot;../kotlin.coroutines/-coroutine-context/index&quot;&gt;CoroutineContext&lt;/a&gt;. It is the invoker's responsibility to ensure that a proper invocation context is established. &lt;a href=&quot;intercepted#kotlin.coroutines.intrinsics%24intercepted(kotlin.coroutines.Continuation((kotlin.coroutines.intrinsics.intercepted.T)))&quot;&gt;Continuation.intercepted&lt;/a&gt; can be used to acquire the intercepted continuation.</source>
          <target state="translated">呼び出し&lt;a href=&quot;../kotlin.coroutines/-continuation/resume-with&quot;&gt;Continuation.resumeWithは&lt;/a&gt;経由せずに呼び出し元のスレッドに直接コルーチンを再開&lt;a href=&quot;../kotlin.coroutines/-continuation-interceptor/index&quot;&gt;ContinuationInterceptor&lt;/a&gt;コルーチンの中に存在するかもしれない&lt;a href=&quot;../kotlin.coroutines/-coroutine-context/index&quot;&gt;CoroutineContext&lt;/a&gt;。適切な呼び出しコンテキストが確立されていることを確認するのは、呼び出し側の責任です。&lt;a href=&quot;intercepted#kotlin.coroutines.intrinsics%24intercepted(kotlin.coroutines.Continuation((kotlin.coroutines.intrinsics.intercepted.T)))&quot;&gt;Continuation.intercepted&lt;/a&gt;は、インターセプトされた継続を取得するために使用できます。</target>
        </trans-unit>
        <trans-unit id="a142e8aa439986e2d57c987fdc039b4c2ce8b67d" translate="yes" xml:space="preserve">
          <source>InvocationKind</source>
          <target state="translated">InvocationKind</target>
        </trans-unit>
        <trans-unit id="32a85866515d2c40342d72243d3af2e2ade61880" translate="yes" xml:space="preserve">
          <source>Invoke operator</source>
          <target state="translated">呼び出し演算子</target>
        </trans-unit>
        <trans-unit id="90d36cdc449e51ffdeb986b93d9cc3791424dd45" translate="yes" xml:space="preserve">
          <source>Invoked for the continuation instance returned by &lt;a href=&quot;intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt; when the original continuation completes and will not be used anymore. This function is invoked only if &lt;a href=&quot;intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt; had returned a different continuation instance from the one it was invoked with.</source>
          <target state="translated">元の継続が完了し、使用されなくなったときに、&lt;a href=&quot;intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt;によって返された継続インスタンスに対して呼び出されます。この関数は、&lt;a href=&quot;intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt;が呼び出されたインスタンスとは異なる継続インスタンスを返した場合にのみ呼び出されます。</target>
        </trans-unit>
        <trans-unit id="e7b262710ce446d5dceec2a721a656e3054eebf5" translate="yes" xml:space="preserve">
          <source>Invoking &lt;code&gt;call()&lt;/code&gt; on a function object will call the function. If it is a member function, the first parameter must be the &lt;em&gt;receiver&lt;/em&gt; (the object on which the function is to be invoked, in this case &lt;code&gt;person&lt;/code&gt;), and the remaining parameters must be the ordinary function parameters (in this case &lt;code&gt;&quot;Anne&quot;&lt;/code&gt;).</source>
          <target state="translated">関数オブジェクトで &lt;code&gt;call()&lt;/code&gt; を呼び出すと、関数が呼び出されます。メンバー関数の場合、最初のパラメーターは&lt;em&gt;レシーバー&lt;/em&gt;（関数が呼び出されるオブジェクト、この場合は &lt;code&gt;person&lt;/code&gt; ）でなければならず、残りのパラメーターは通常の関数パラメーター（この場合は &lt;code&gt;&quot;Anne&quot;&lt;/code&gt; ）でなければなりません。。</target>
        </trans-unit>
        <trans-unit id="e517c0efd966757777074a55cf84552ef188ca9a" translate="yes" xml:space="preserve">
          <source>Invoking &lt;code&gt;findViewById()&lt;/code&gt; can be slow, especially in case of huge view hierarchies, so Android Extensions tries to minimize &lt;code&gt;findViewById()&lt;/code&gt; calls by caching views in containers.</source>
          <target state="translated">呼び出す &lt;code&gt;findViewById()&lt;/code&gt; Androidの拡張機能は最小限にしようとするので、特に巨大なビュー階層の場合には、遅くなることがあります &lt;code&gt;findViewById()&lt;/code&gt; は、コンテナ内のビューをキャッシュすることによって呼び出されます。</target>
        </trans-unit>
        <trans-unit id="55b7cc54c31bd895727aeb7e2e5dfcfeaf500f67" translate="yes" xml:space="preserve">
          <source>Invoking a function type instance</source>
          <target state="translated">関数型インスタンスの呼び出し</target>
        </trans-unit>
        <trans-unit id="609d1188a5fb6f3c57a44ee5ee27b2fb07938bf1" translate="yes" xml:space="preserve">
          <source>Invoking functions on other collections</source>
          <target state="translated">他のコレクションで関数を呼び出す</target>
        </trans-unit>
        <trans-unit id="39f649540ce7c567f8fc21179741df12bdec413a" translate="yes" xml:space="preserve">
          <source>Is Kotlin an object-oriented language or a functional one?</source>
          <target state="translated">Kotlin はオブジェクト指向言語なのか、それとも関数型言語なのか?</target>
        </trans-unit>
        <trans-unit id="0396150c49da7aa331143384cade7b9761b9c77b" translate="yes" xml:space="preserve">
          <source>Is Kotlin compatible with the Java programming language?</source>
          <target state="translated">KotlinはJavaプログラミング言語と互換性がありますか?</target>
        </trans-unit>
        <trans-unit id="d651f0b2ee6f868c27d5b6dae520cfb850abc9e7" translate="yes" xml:space="preserve">
          <source>Is Kotlin free?</source>
          <target state="translated">コトリンは無料ですか?</target>
        </trans-unit>
        <trans-unit id="4096c8e1086b327150a7292e4d2afe3394a12f6e" translate="yes" xml:space="preserve">
          <source>Is Kotlin hard?</source>
          <target state="translated">コトリンは硬い?</target>
        </trans-unit>
        <trans-unit id="9edc452dd78ce29f04fd4cdc3ccb57260c61debd" translate="yes" xml:space="preserve">
          <source>Is Kotlin on Social Media?</source>
          <target state="translated">コトリンはソーシャルメディアを使っていますか?</target>
        </trans-unit>
        <trans-unit id="4e2b800e686ee55bbeca8de0e7c4e9007eb7822f" translate="yes" xml:space="preserve">
          <source>Is Kotlin on social media?</source>
          <target state="translated">コトリンはソーシャルメディアを使っているのか?</target>
        </trans-unit>
        <trans-unit id="06373ad2bc61a9e4042f42be3c932a4374d09d55" translate="yes" xml:space="preserve">
          <source>Is extension function</source>
          <target state="translated">拡張機能はありますか?</target>
        </trans-unit>
        <trans-unit id="84f7edacad77f3efea0c1f9a95023335afe8e98e" translate="yes" xml:space="preserve">
          <source>Is there a Kotlin conference?</source>
          <target state="translated">Kotlinの会議はありますか?</target>
        </trans-unit>
        <trans-unit id="23fb12980d63818dd24d249914c5dbde1e4eab5d" translate="yes" xml:space="preserve">
          <source>Isn't it what we wanted from the very beginning?</source>
          <target state="translated">最初から望んでいたことではないでしょうか?</target>
        </trans-unit>
        <trans-unit id="651e4641fbeb110db3b7fdfb2bb5a04a7dfe7d1b" translate="yes" xml:space="preserve">
          <source>Isolating declarations in a separate JavaScript object</source>
          <target state="translated">別の JavaScript オブジェクトで宣言を分離する</target>
        </trans-unit>
        <trans-unit id="d439914b4bf445ecb5fcbbcfd0b7501a29e97254" translate="yes" xml:space="preserve">
          <source>Isolating declarations in a separate JavaScript object in &lt;code&gt;plain&lt;/code&gt; mode</source>
          <target state="translated">&lt;code&gt;plain&lt;/code&gt; モードで別のJavaScriptオブジェクトの宣言を分離する</target>
        </trans-unit>
        <trans-unit id="ec40e8e2417f63763bc4005b1f45f89c4b9bd620" translate="yes" xml:space="preserve">
          <source>It also works with meta-annotations:</source>
          <target state="translated">メタアノテーションとの連携も可能です。</target>
        </trans-unit>
        <trans-unit id="6f49ae3f8f0dbf679bfc3c5ff95bf21f8e30ee20" translate="yes" xml:space="preserve">
          <source>It can be demonstrated by a simple example that creates coroutines in the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope&lt;/a&gt;:</source>
          <target state="translated">これは、&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScopeに&lt;/a&gt;コルーチンを作成する簡単な例で説明できます。</target>
        </trans-unit>
        <trans-unit id="fafe915e21eb48d949ca0df5819ea5714df59866" translate="yes" xml:space="preserve">
          <source>It can be demonstrated by a simple example that creates root coroutines using the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope&lt;/a&gt;:</source>
          <target state="translated">これは、&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope&lt;/a&gt;を使用してルートコルーチンを作成する簡単な例で示すことができます。</target>
        </trans-unit>
        <trans-unit id="b2cb6066b03e8d078e05b9934f5a0885eb7115c7" translate="yes" xml:space="preserve">
          <source>It can be demonstrated by the following example:</source>
          <target state="translated">それは、以下の例で実証することができます。</target>
        </trans-unit>
        <trans-unit id="c7f79c6fa89f2be4d0900a1df15f6e4c9cd6d6d8" translate="yes" xml:space="preserve">
          <source>It can of course be done as a single expression: &lt;code&gt;val x = javaFunctionThatYouKnowReturnsNonNull()!!&lt;/code&gt;.</source>
          <target state="translated">もちろん、単一の式として行うこともできます： &lt;code&gt;val x = javaFunctionThatYouKnowReturnsNonNull()!!&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b4869b700b07f0d7aa2566a42cedd6c00ff40027" translate="yes" xml:space="preserve">
          <source>It demonstrates several new techniques. One is using &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt; with an explicitly specified context, and the other one is using &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-context.html&quot;&gt;withContext&lt;/a&gt; function to change a context of a coroutine while still staying in the same coroutine as you can see in the output below:</source>
          <target state="translated">これは、いくつかの新しいテクニックを示しています。1つは明示的に指定されたコンテキストで&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt;を使用しており、もう1つは&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-context.html&quot;&gt;withContext&lt;/a&gt;関数を使用してコルーチンのコンテキストを変更しながら、以下の出力で確認できるように同じコルーチンにとどまっています。</target>
        </trans-unit>
        <trans-unit id="407d919d76eb160a2f5dfd9e474e1e25b6f6932e" translate="yes" xml:space="preserve">
          <source>It demonstrates several new techniques. One is using &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt; with an explicitly specified context, and the other one is using the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-context.html&quot;&gt;withContext&lt;/a&gt; function to change the context of a coroutine while still staying in the same coroutine, as you can see in the output below:</source>
          <target state="translated">それはいくつかの新しい技術を示しています。次の出力に示すように、1つは明示的に指定されたコンテキストで&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt;を使用し、もう1つは&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-context.html&quot;&gt;withContext&lt;/a&gt;関数を使用して、同じコルーチンにとどまりながらコルーチンのコンテキストを変更します。</target>
        </trans-unit>
        <trans-unit id="df6b25cff4a7799af9dc4369b6ce738113d68ee2" translate="yes" xml:space="preserve">
          <source>It does not matter (for correctness) what context the actor itself is executed in. An actor is a coroutine and a coroutine is executed sequentially, so confinement of the state to the specific coroutine works as a solution to the problem of shared mutable state. Indeed, actors may modify their own private state, but can only affect each other through messages (avoiding the need for any locks).</source>
          <target state="translated">アクタ自体がどのようなコンテキストで実行されるかは(正確性のために)問題ではありません。アクタはコルーチンであり、コルーチンは順次実行されるので、特定のコルーチンに状態を限定することは、共有された変異可能な状態の問題の解決策として機能します。実際、アクタは自分自身のプライベートな状態を変更することができますが、メッセージを通してしかお互いに影響を与えることができません(ロックの必要性を回避します)。</target>
        </trans-unit>
        <trans-unit id="838f4ba272421d5995e2a80726c6cbb738d51748" translate="yes" xml:space="preserve">
          <source>It expects the targets to provide platform-specific implementations for &lt;code&gt;writeLogMessage&lt;/code&gt;, and the common code can now use this declaration without any consideration of how it is implemented.</source>
          <target state="translated">ターゲットが &lt;code&gt;writeLogMessage&lt;/code&gt; のプラットフォーム固有の実装を提供することを期待しており、一般的なコードは、実装方法を考慮せずにこの宣言を使用できるようになりました。</target>
        </trans-unit>
        <trans-unit id="acca4b75fdfdc287f94d60288ba8cbf8ea940d89" translate="yes" xml:space="preserve">
          <source>It is also convenient to use when you have a callable reference instead of the lambda:</source>
          <target state="translated">ラムダの代わりに呼び出し可能な参照がある場合にも便利です。</target>
        </trans-unit>
        <trans-unit id="db36d25fe18e1fa8b4a072e0b9e5e699d53ac00e" translate="yes" xml:space="preserve">
          <source>It is also possible to configure all Kotlin compilation tasks in the project:</source>
          <target state="translated">また、プロジェクト内のすべてのKotlinコンパイルタスクを設定することも可能です。</target>
        </trans-unit>
        <trans-unit id="4e799686fc388ae642c64e9044143db835d23770" translate="yes" xml:space="preserve">
          <source>It is also possible to debug Kotlin applications using the standard Chrome debugger. Just make sure that you do generate source maps.</source>
          <target state="translated">標準のChromeデバッガーを使ってKotlinアプリケーションをデバッグすることも可能です。ただ、ソースマップを生成するようにしてください。</target>
        </trans-unit>
        <trans-unit id="2d484974349c030ade989fbea0475cbaae9e9d98" translate="yes" xml:space="preserve">
          <source>It is also possible to iterate over numbers with an arbitrary step (not necessarily 1). This is done via the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/step&quot;&gt;&lt;code&gt;step&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">任意のステップ（必ずしも1である必要はない）で数値を反復することも可能です。これは、&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/step&quot;&gt; &lt;code&gt;step&lt;/code&gt; &lt;/a&gt;関数を介して行われます。</target>
        </trans-unit>
        <trans-unit id="dc446105af35ae94e82863937d04520fa631bab7" translate="yes" xml:space="preserve">
          <source>It is convenient to import all widget properties for a specific layout in one go:</source>
          <target state="translated">特定のレイアウトのウィジェットプロパティを一括でインポートできるのが便利です。</target>
        </trans-unit>
        <trans-unit id="ea87fa24d13265d437721a500dc610021a2b6ae7" translate="yes" xml:space="preserve">
          <source>It is created by attaching &lt;code&gt;keySelector: (T) -&amp;gt; K&lt;/code&gt; function to a source of elements. To get an instance of &lt;a href=&quot;index&quot;&gt;Grouping&lt;/a&gt; use one of &lt;code&gt;groupingBy&lt;/code&gt; extension functions:</source>
          <target state="translated">&lt;code&gt;keySelector: (T) -&amp;gt; K&lt;/code&gt; 関数を要素のソースにアタッチすることで作成されます。&lt;a href=&quot;index&quot;&gt;Groupingの&lt;/a&gt;インスタンスを取得するには、 &lt;code&gt;groupingBy&lt;/code&gt; 拡張関数のいずれかを使用します。</target>
        </trans-unit>
        <trans-unit id="6148f03cfc2015e2c10414350a23c5c6eccbddac" translate="yes" xml:space="preserve">
          <source>It is currently prohibited to export the following kinds of declarations:</source>
          <target state="translated">現在、以下の種類の申告書の輸出は禁止されています。</target>
        </trans-unit>
        <trans-unit id="9817b3326fc94d2d632dd03bcb277b7bc5e546ba" translate="yes" xml:space="preserve">
          <source>It is easy to demonstrate it in action:</source>
          <target state="translated">それを行動で示すのは簡単です。</target>
        </trans-unit>
        <trans-unit id="5057879a755e254fb21862c60fef7113f875d675" translate="yes" xml:space="preserve">
          <source>It is easy to include a compiled Kotlin code into existing projects written in C, C++, Swift, Objective-C, and other languages. It is also easy to use existing native code, static or dynamic &lt;a href=&quot;native/c_interop&quot;&gt;C libraries&lt;/a&gt;, Swift/Objective-C &lt;a href=&quot;native/objc_interop&quot;&gt;frameworks&lt;/a&gt;, graphical engines, and anything else directly from Kotlin/Native.</source>
          <target state="translated">コンパイル済みのKotlinコードを、C、C ++、Swift、Objective-C、およびその他の言語で記述された既存のプロジェクトに簡単に組み込むことができます。また、既存のネイティブコード、静的または動的&lt;a href=&quot;native/c_interop&quot;&gt;Cライブラリ&lt;/a&gt;、Swift / Objective-C &lt;a href=&quot;native/objc_interop&quot;&gt;フレームワーク&lt;/a&gt;、グラフィカルエンジンなど、Kotlin / Nativeから直接使用することも簡単です。</target>
        </trans-unit>
        <trans-unit id="a1e4c80fa63f2c717618535a583de6ba5b964535" translate="yes" xml:space="preserve">
          <source>It is easy to use flows to represent asynchronous events that are coming from some source. In this case, we need an analogue of the &lt;code&gt;addEventListener&lt;/code&gt; function that registers a piece of code with a reaction for incoming events and continues further work. The &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/on-each.html&quot;&gt;onEach&lt;/a&gt; operator can serve this role. However, &lt;code&gt;onEach&lt;/code&gt; is an intermediate operator. We also need a terminal operator to collect the flow. Otherwise, just calling &lt;code&gt;onEach&lt;/code&gt; has no effect.</source>
          <target state="translated">フローを使用して、あるソースからの非同期イベントを表すのは簡単です。この場合、コードの一部を着信イベントへの反応に登録し、さらなる作業を継続する &lt;code&gt;addEventListener&lt;/code&gt; 関数の類似物が必要です。&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/on-each.html&quot;&gt;onEachの&lt;/a&gt;オペレータは、この役割を果たすことができます。ただし、 &lt;code&gt;onEach&lt;/code&gt; は中間演算子です。また、フローを収集するためのターミナルオペレーターも必要です。それ以外の場合は、 &lt;code&gt;onEach&lt;/code&gt; を呼び出すだけでは効果がありません。</target>
        </trans-unit>
        <trans-unit id="5f37ac7cf663ce39ab7cecdf53e288f77e8f878b" translate="yes" xml:space="preserve">
          <source>It is easy to use the generated wrapper classes for C &lt;code&gt;struct&lt;/code&gt; and &lt;code&gt;union&lt;/code&gt; types from Kotlin. Thanks to the generated properties, it feels natural to use them in Kotlin code. The only question, so far, is how do we create a new instance on those classes. As we see from the declarations of &lt;code&gt;MyStruct&lt;/code&gt; and &lt;code&gt;MyUnion&lt;/code&gt;, their constructors require a &lt;code&gt;NativePtr&lt;/code&gt;. Of course, we are not willing to deal with pointers manually. Instead, we can use Kotlin API to have those objects instantiated for us.</source>
          <target state="translated">KotlinからC &lt;code&gt;struct&lt;/code&gt; および &lt;code&gt;union&lt;/code&gt; 体型用に生成されたラッパークラスを使用するのは簡単です。生成されたプロパティのおかげで、Kotlinコードでそれらを使用するのは自然なことです。これまでの唯一の問題は、これらのクラスに新しいインスタンスを作成する方法です。 &lt;code&gt;MyStruct&lt;/code&gt; と &lt;code&gt;MyUnion&lt;/code&gt; の宣言からわかるように、それらのコンストラクターには &lt;code&gt;NativePtr&lt;/code&gt; が必要です。もちろん、ポインターを手動で処理することはできません。代わりに、Kotlin APIを使用して、これらのオブジェクトをインスタンス化することができます。</target>
        </trans-unit>
        <trans-unit id="13a7c2154690aa37b95c233923686a0683d02a9e" translate="yes" xml:space="preserve">
          <source>It is equivalent to this Java code:</source>
          <target state="translated">このJavaコードに相当します。</target>
        </trans-unit>
        <trans-unit id="fd011ac428fa7a3101febe89637cd71887a4e771" translate="yes" xml:space="preserve">
          <source>It is forbidden for inline classes to participate in a class hierarchy. This means that inline classes cannot extend other classes and must be &lt;em&gt;final&lt;/em&gt;.</source>
          <target state="translated">インラインクラスがクラス階層に参加することは禁止されています。つまり、インラインクラスは他のクラスを拡張できず、&lt;em&gt;最終&lt;/em&gt;クラスでなければなりません。</target>
        </trans-unit>
        <trans-unit id="baf0c1eedc3c7d76ed7d17e6f83833365d1074e5" translate="yes" xml:space="preserve">
          <source>It is important to note that some of the &lt;a href=&quot;#supported-platforms&quot;&gt;Kotlin/Native targets&lt;/a&gt; may only be built with an appropriate host machine:</source>
          <target state="translated">&lt;a href=&quot;#supported-platforms&quot;&gt;Kotlin /ネイティブターゲットの&lt;/a&gt;一部は、適切なホストマシンでのみビルドできることに注意することが重要です。</target>
        </trans-unit>
        <trans-unit id="417f8643742c5b4b13e710785eaf864b3ada4be9" translate="yes" xml:space="preserve">
          <source>It is important to understand that just like in the case of &lt;code&gt;callAnything()&lt;/code&gt;, the &lt;code&gt;dataTable()&lt;/code&gt; function must exist at runtime. In our case, we need to make sure that the corresponding script file for our plugin is included:</source>
          <target state="translated">&lt;code&gt;callAnything()&lt;/code&gt; の場合と同様に、 &lt;code&gt;dataTable()&lt;/code&gt; 関数は実行時に存在する必要があることを理解することが重要です。この場合、プラグインに対応するスクリプトファイルが含まれていることを確認する必要があります。</target>
        </trans-unit>
        <trans-unit id="12337a359954227bfe96e37274de5fc654fa35be" translate="yes" xml:space="preserve">
          <source>It is not recommended that you publish variants grouped by the product flavor in case they have different dependencies, as those will be merged into one dependencies list.</source>
          <target state="translated">異なる依存関係がある場合に、製品のフレーバーでグループ化された variant を公開することはお勧めしません。</target>
        </trans-unit>
        <trans-unit id="0e863e2f2b3f4c7cb9be7530e2969137eb812edc" translate="yes" xml:space="preserve">
          <source>It is not recommended to publish variants grouped by the product flavor in case they have different dependencies, as those will be merged into one dependencies list.</source>
          <target state="translated">異なる依存関係を持っている場合に、製品のフレーバーでグループ化された variant を公開することは推奨されません。</target>
        </trans-unit>
        <trans-unit id="41a0e8e8363c715bede252f00decd03608d5ae6b" translate="yes" xml:space="preserve">
          <source>It is not required to match directories and packages: source files can be placed arbitrarily in the file system.</source>
          <target state="translated">ディレクトリとパッケージを一致させる必要はありません:ソースファイルはファイルシステム内の任意の場所に置くことができます。</target>
        </trans-unit>
        <trans-unit id="ed10861129de21214d3c19646f1725bf54132b36" translate="yes" xml:space="preserve">
          <source>It is now possible to enumerate the values of an enum class in a generic way.</source>
          <target state="translated">enumクラスの値を汎用的に列挙することができるようになりました。</target>
        </trans-unit>
        <trans-unit id="e7a4a5a763a24f82bedd348e3c81f2b59dad3138" translate="yes" xml:space="preserve">
          <source>It is platform independent. Whether we targeting JVM, JavaScript or any other platform, the code we write is the same. Under the covers the compiler takes care of adapting it to each platform.</source>
          <target state="translated">プラットフォームに依存しません。JVMをターゲットにしていても、JavaScriptをターゲットにしていても、他のプラットフォームをターゲットにしていても、書くコードは同じです。カバーの下では、コンパイラが各プラットフォームに適応するように世話をしてくれます。</target>
        </trans-unit>
        <trans-unit id="4d947185f89d323fe7c7abf6d8cbb01ea4b530eb" translate="yes" xml:space="preserve">
          <source>It is possible for a class to implement a function type as if it were an interface. It must then supply an operator function called &lt;code&gt;invoke&lt;/code&gt; with the given signature, and instances of that class may then be assigned to a variable of that function type:</source>
          <target state="translated">クラスが関数型をインターフェースのように実装することは可能です。次に、 &lt;code&gt;invoke&lt;/code&gt; と呼ばれる演算子関数を特定のシグネチャで提供する必要があり、そのクラスのインスタンスをその関数型の変数に割り当てることができます。</target>
        </trans-unit>
        <trans-unit id="05ec15ebc6d7af617a86a57248adcf19a55ca53f" translate="yes" xml:space="preserve">
          <source>It is possible to annotate type arguments of generic types to provide nullability information for them as well. For example, consider these annotations on a Java declaration:</source>
          <target state="translated">一般的な型の型引数にもヌル可能性情報を提供するためにアノテーションを付けることができます。例えば、Java宣言に以下のようなアノテーションを付けることを考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="a4db969f6c44a5e65473207ba72459c76a3f1c8a" translate="yes" xml:space="preserve">
          <source>It is possible to configure the language settings of all source sets at once:</source>
          <target state="translated">すべてのソースセットの言語設定を一度に設定することができます。</target>
        </trans-unit>
        <trans-unit id="8ee4c90445d9b9d795928bb3dfbba324ab54fe64" translate="yes" xml:space="preserve">
          <source>It is possible to create a scope-stable pointer of C representation of &lt;code&gt;CValues&amp;lt;T&amp;gt;&lt;/code&gt; instance using the &lt;code&gt;CValues&amp;lt;T&amp;gt;.ptr&lt;/code&gt; extension property, available under &lt;code&gt;memScoped { ... }&lt;/code&gt;. It allows using the APIs which require C pointers with a lifetime bound to a certain &lt;code&gt;MemScope&lt;/code&gt;. For example:</source>
          <target state="translated">Cの表現の範囲安定ポインタを作成することが可能である &lt;code&gt;CValues&amp;lt;T&amp;gt;&lt;/code&gt; 使用してインスタンス &lt;code&gt;CValues&amp;lt;T&amp;gt;.ptr&lt;/code&gt; 下で入手可能な、拡張性、 &lt;code&gt;memScoped { ... }&lt;/code&gt; 。これにより、特定の &lt;code&gt;MemScope&lt;/code&gt; に有効期間がバインドされたCポインターを必要とするAPIを使用できます。例えば：</target>
        </trans-unit>
        <trans-unit id="a1c523500d91947ee9765a964b978e521350e87f" translate="yes" xml:space="preserve">
          <source>It is possible to customize the default behavior of printing &lt;strong&gt;uncaught&lt;/strong&gt; exceptions to the console. &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-exception-handler/index.html&quot;&gt;CoroutineExceptionHandler&lt;/a&gt; context element on a &lt;em&gt;root&lt;/em&gt; coroutine can be used as generic &lt;code&gt;catch&lt;/code&gt; block for this root coroutine and all its children where custom exception handling may take place. It is similar to &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html#setUncaughtExceptionHandler(java.lang.Thread.UncaughtExceptionHandler)&quot;&gt;&lt;code&gt;Thread.uncaughtExceptionHandler&lt;/code&gt;&lt;/a&gt;. You cannot recover from the exception in the &lt;code&gt;CoroutineExceptionHandler&lt;/code&gt;. The coroutine had already completed with the corresponding exception when the handler is called. Normally, the handler is used to log the exception, show some kind of error message, terminate, and/or restart the application.</source>
          <target state="translated">&lt;strong&gt;キャッチされなかった&lt;/strong&gt;例外をコンソールに出力するデフォルトの動作をカスタマイズすることができます。&lt;em&gt;ルート&lt;/em&gt;コルーチンの&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-exception-handler/index.html&quot;&gt;CoroutineExceptionHandler&lt;/a&gt;コンテキスト要素は、このルートコルーチンと、カスタム例外処理が行われる可能性のあるすべての子の汎用 &lt;code&gt;catch&lt;/code&gt; ブロックとして使用できます。これは&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html#setUncaughtExceptionHandler(java.lang.Thread.UncaughtExceptionHandler)&quot;&gt; &lt;code&gt;Thread.uncaughtExceptionHandler&lt;/code&gt; に&lt;/a&gt;似ています。 &lt;code&gt;CoroutineExceptionHandler&lt;/code&gt; の例外から回復することはできません。コルーチンは、ハンドラーが呼び出されたときに対応する例外を除いてすでに完了しています。通常、ハンドラーは、例外のログ記録、何らかのエラーメッセージの表示、アプリケーションの終了、および/または再起動に使用されます。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e9091ebea40cd5ed5eeeecc5f5fcdcb74a99a77f" translate="yes" xml:space="preserve">
          <source>It is possible to declare contracts for your own functions, but this feature is &lt;strong&gt;experimental,&lt;/strong&gt; as the current syntax is in a state of early prototype and will most probably be changed. Also, please note, that currently the Kotlin compiler does not verify contracts, so it's a programmer's responsibility to write correct and sound contracts.</source>
          <target state="translated">独自の関数のコントラクトを宣言することは可能ですが、現在の構文は初期のプロトタイプの状態にあり、おそらく変更されるため&lt;strong&gt;、&lt;/strong&gt;この機能は&lt;strong&gt;実験的&lt;/strong&gt;です。また、現在Kotlinコンパイラーは契約を検証しないため、プログラマーは正しい健全な契約を作成する必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="dc3778d4014e6f71dce4d7d20c0e012498a2087a" translate="yes" xml:space="preserve">
          <source>It is possible to filter headers by globs. The &lt;code&gt;headerFilter&lt;/code&gt; property value from the &lt;code&gt;.def&lt;/code&gt; file is treated as a space-separated list of globs. If the included header matches any of the globs, then the declarations from this header are included into the bindings.</source>
          <target state="translated">グロブでヘッダーをフィルタリングすることが可能です。 &lt;code&gt;.def&lt;/code&gt; ファイルの &lt;code&gt;headerFilter&lt;/code&gt; プロパティ値は、スペースで区切られたグロブのリストとして扱われます。含まれているヘッダーがグロブのいずれかに一致する場合、このヘッダーからの宣言がバインディングに含まれます。</target>
        </trans-unit>
        <trans-unit id="402a77d3239dcd76fb899799d8112b0ad86dfc4e" translate="yes" xml:space="preserve">
          <source>It is possible to have more than one target for a single platform in a multiplatform library. For example, these targets may provide the same API and differ in the libraries they cooperate with at runtime, like testing frameworks or logging solutions.</source>
          <target state="translated">マルチプラットフォームライブラリでは、1 つのプラットフォームに対して複数のターゲットを持つことが可能です。例えば、これらのターゲットは同じ API を提供し、テストフレームワークやロギングソリューションのように、実行時に連携するライブラリが異なる場合があります。</target>
        </trans-unit>
        <trans-unit id="2e301a8ab019737ffb1879efcfc2dbdf711dcf6a" translate="yes" xml:space="preserve">
          <source>It is possible to specify which build types will be used to create binaries and which won't. In the following example only debug executable is created.</source>
          <target state="translated">どのビルドタイプを使用してバイナリを作成し、どのビルドタイプを使用しないかを指定することができます。次の例では、デバッグ用の実行ファイルのみを作成しています。</target>
        </trans-unit>
        <trans-unit id="c4c1947233d08bc7cc11e65c450d05edf9570b44" translate="yes" xml:space="preserve">
          <source>It is quite a common situation to have a list of keys and want to build a map by associating each of these keys with some value. It was possible to do it before with the &lt;code&gt;associate { it to getValue(it) }&lt;/code&gt; function, but now we&amp;rsquo;re introducing a more efficient and easy to explore alternative: &lt;code&gt;keys.associateWith { getValue(it) }&lt;/code&gt;.</source>
          <target state="translated">キーのリストがあり、これらのキーのそれぞれを何らかの値に関連付けることによってマップを作成することは、非常に一般的な状況です。以前は、 &lt;code&gt;associate { it to getValue(it) }&lt;/code&gt; 関数を使用してそれを行うことが可能でしたが、今では、より効率的で簡単に探索できる代替手段である &lt;code&gt;keys.associateWith { getValue(it) }&lt;/code&gt; 導入しています。</target>
        </trans-unit>
        <trans-unit id="5af6059bcf4a05b2b995079d84a33266eddebc57" translate="yes" xml:space="preserve">
          <source>It is recommended to only provide external declarations manually in your source folder &lt;em&gt;or&lt;/em&gt; enabling the generation of external declarations at build time for any single dependency. Doing both can result in resolution issues.</source>
          <target state="translated">あなただけのソースフォルダに手動で外部宣言を提供することを推奨し&lt;em&gt;たり&lt;/em&gt;、任意の単一の依存関係のために、ビルド時に外部宣言を生成することができます。両方を実行すると、解決の問題が発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="cb237bed1931cb077bff53fe7955788594878ed8" translate="yes" xml:space="preserve">
          <source>It is safe to treat a &lt;code&gt;Consumer&amp;lt;Fruit&amp;gt;&lt;/code&gt; as a &lt;code&gt;Consumer&amp;lt;Apple&amp;gt;&lt;/code&gt; - you are then restricted to only adding &lt;code&gt;Apple&lt;/code&gt; instances to it, but that's okay, because it is capable of receiving any &lt;code&gt;Fruit&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Consumer&amp;lt;Fruit&amp;gt;&lt;/code&gt; を &lt;code&gt;Consumer&amp;lt;Apple&amp;gt;&lt;/code&gt; &amp;gt;として扱うのは安全です。これにより、 &lt;code&gt;Apple&lt;/code&gt; インスタンスの追加のみに制限されますが、任意の &lt;code&gt;Fruit&lt;/code&gt; を受け取ることができるため、問題ありません。</target>
        </trans-unit>
        <trans-unit id="dc95825b1857af449f9e7a03e1be3bb43d0ddb3a" translate="yes" xml:space="preserve">
          <source>It is safe to treat a &lt;code&gt;Producer&amp;lt;Apple&amp;gt;&lt;/code&gt; as if it were a &lt;code&gt;Producer&amp;lt;Fruit&amp;gt;&lt;/code&gt; - the only thing it will ever produce is &lt;code&gt;Apple&lt;/code&gt; instances, but that's okay, because an &lt;code&gt;Apple&lt;/code&gt; is a &lt;code&gt;Fruit&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Producer&amp;lt;Apple&amp;gt;&lt;/code&gt; を &lt;code&gt;Producer&amp;lt;Fruit&amp;gt;&lt;/code&gt; ように扱うのは安全です。これにより生成されるのは &lt;code&gt;Apple&lt;/code&gt; インスタンスのみですが、 &lt;code&gt;Apple&lt;/code&gt; は &lt;code&gt;Fruit&lt;/code&gt; なので問題ありません。</target>
        </trans-unit>
        <trans-unit id="1cb7a9be64c1b10976e2826c53f2565e3ab27c33" translate="yes" xml:space="preserve">
          <source>It is the same as the hashCode of &lt;a href=&quot;../-map/entries#kotlin.collections.Map%24entries&quot;&gt;entries&lt;/a&gt; set.</source>
          <target state="translated">設定した&lt;a href=&quot;../-map/entries#kotlin.collections.Map%24entries&quot;&gt;エントリ&lt;/a&gt;のhashCodeと同じです。</target>
        </trans-unit>
        <trans-unit id="638b2a44297b2347a2a9b3d378c007753c4381ba" translate="yes" xml:space="preserve">
          <source>It is the time to try using C Functions from our Kotlin program. Let's call the &lt;code&gt;accept_fun&lt;/code&gt; function and pass the C function pointer to a Kotlin lambda:</source>
          <target state="translated">KotlinプログラムのC関数を使用するときです。 &lt;code&gt;accept_fun&lt;/code&gt; 関数を呼び出して、C関数ポインターをKotlinラムダに渡します。</target>
        </trans-unit>
        <trans-unit id="d8fa5339a1950bfcc4e526f49360c54a4a63bc2d" translate="yes" xml:space="preserve">
          <source>It is very convenient to declare a type parameter T as &lt;em&gt;out&lt;/em&gt; and avoid trouble with subtyping on the use site, but some classes &lt;strong&gt;can't&lt;/strong&gt; actually be restricted to only return &lt;code&gt;T&lt;/code&gt;'s! A good example of this is Array:</source>
          <target state="translated">型パラメーターTを&lt;em&gt;out&lt;/em&gt;として宣言し、使用サイトでのサブタイピングの問題を回避することは非常に便利ですが、一部のクラス&lt;strong&gt;は&lt;/strong&gt;実際には &lt;code&gt;T&lt;/code&gt; のみを返すように制限&lt;strong&gt;できません&lt;/strong&gt;。これの良い例は配列です：</target>
        </trans-unit>
        <trans-unit id="776fdced037b223c21ef26795ae5fc999fa0ee3e" translate="yes" xml:space="preserve">
          <source>It launches 100K coroutines and, after 5 seconds, each coroutine prints a dot.</source>
          <target state="translated">100Kのコルーチンを起動し、5秒後に各コルーチンがドットを印刷します。</target>
        </trans-unit>
        <trans-unit id="b163cb494d8f7133d17c75969b6f58ad44cf2144" translate="yes" xml:space="preserve">
          <source>It launches 100K coroutines and, after a second, each coroutine prints a dot. Now, try that with threads. What would happen? (Most likely your code will produce some sort of out-of-memory error)</source>
          <target state="translated">10万個のコルーチンを起動して 1秒後に各コルーチンがドットを印刷します では、それをスレッドで試してみてください。どうなるでしょうか?(たいていの場合、あなたのコードは何らかのメモリ切れのエラーを出すでしょう)</target>
        </trans-unit>
        <trans-unit id="efa9aff9b6f6c29df2d20508228006677fa18621" translate="yes" xml:space="preserve">
          <source>It leads to the following signature seen in Kotlin:</source>
          <target state="translated">それは、Kotlinで見られる以下のような署名につながります。</target>
        </trans-unit>
        <trans-unit id="31157cfdb7da2c923cc250df2cdef99f52021252" translate="yes" xml:space="preserve">
          <source>It makes it easy to add and reorder elements &amp;ndash; there is no need to add or delete the comma if you manipulate elements.</source>
          <target state="translated">要素の追加と並べ替えが簡単になります。要素を操作する場合、コンマを追加または削除する必要はありません。</target>
        </trans-unit>
        <trans-unit id="17169e22fd37b9c0c61060b6531c5a37b04dbe03" translate="yes" xml:space="preserve">
          <source>It makes version-control diffs cleaner &amp;ndash; as all the focus is on the changed value.</source>
          <target state="translated">変更された値にすべての焦点が当てられるため、バージョン管理の差分がよりクリーンになります。</target>
        </trans-unit>
        <trans-unit id="50a8da20f5180842f95e2e885ec1433b6eb6b732" translate="yes" xml:space="preserve">
          <source>It may be helpful only if declaration seems to be inconvenient to use from Java without wildcard.</source>
          <target state="translated">ワイルドカードがないとJavaからの宣言が不便そうな場合にのみ参考になるかもしれません。</target>
        </trans-unit>
        <trans-unit id="8ead6eaf5a09cdd5203f3d7332c148b0e2afab55" translate="yes" xml:space="preserve">
          <source>It may be helpful only if declaration seems to be inconvenient to use from Java.</source>
          <target state="translated">宣言がJavaからだと不便そうな場合にのみ参考になるかもしれません。</target>
        </trans-unit>
        <trans-unit id="92fc36943474eb17749f18ce6facbefadc2bd75a" translate="yes" xml:space="preserve">
          <source>It may seem a logical next step to remove this obscurity by switching the defaults in IntelliJ IDEA and make formatting consistent with the Kotlin Coding Conventions. But this would mean that all the existing Kotlin projects will have a new code style enabled the moment the Kotlin plugin is installed. Not really the expected result for plugin update, right?</source>
          <target state="translated">この不明瞭さを取り除くために、IntelliJ IDEAのデフォルトを切り替えて、Kotlinのコーディング規約と整合性のあるフォーマットにすることは、論理的な次のステップのように思えるかもしれません。しかし、これはKotlinプラグインがインストールされた瞬間に、すべての既存のKotlinプロジェクトで新しいコードスタイルが有効になることを意味します。プラグインのアップデートではあまり期待していた結果ではないですよね?</target>
        </trans-unit>
        <trans-unit id="5a4d0a01a307589d4ada06d8aac41c245c2a1232" translate="yes" xml:space="preserve">
          <source>It means that, by the time of the base class constructor execution, the properties declared or overridden in the derived class are not yet initialized. If any of those properties are used in the base class initialization logic (either directly or indirectly, through another overridden &lt;em&gt;open&lt;/em&gt; member implementation), it may lead to incorrect behavior or a runtime failure. When designing a base class, you should therefore avoid using &lt;em&gt;open&lt;/em&gt; members in the constructors, property initializers, and &lt;em&gt;init&lt;/em&gt; blocks.</source>
          <target state="translated">つまり、基本クラスコンストラクターの実行時には、派生クラスで宣言またはオーバーライドされたプロパティはまだ初期化されていません。これらのプロパティのいずれかが（直接または間接的に、別のオーバーライドさ&lt;em&gt;れたオープン&lt;/em&gt;メンバー実装を介して）基本クラスの初期化ロジックで使用されている場合、不正な動作またはランタイムエラーが発生する可能性があります。したがって、基本クラスを設計するときは、コンストラクター、プロパティ初期化子、および&lt;em&gt;init&lt;/em&gt;ブロックで&lt;em&gt;オープン&lt;/em&gt;メンバーを使用しないようにする必要があります。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="797f38dacaae5d59a26c62d2dd822a0488289854" translate="yes" xml:space="preserve">
          <source>It might be temping to use JVM's &lt;code&gt;java.util.Scanner&lt;/code&gt; class to parse less structured input formats. Kotlin is designed to interoperate well with JVM libraries, so that their use feels quite natural in Kotlin. However, beware that &lt;code&gt;java.util.Scanner&lt;/code&gt; is extremely slow. So slow, in fact, that parsing 10&lt;sup&gt;5&lt;/sup&gt; or more integers with it might not fit into a typical 2 second time-limit, which a simple Kotlin's &lt;code&gt;split(&quot; &quot;).map { it.toInt() }&lt;/code&gt; would handle.</source>
          <target state="translated">あまり構造化されていない入力形式を解析するために、JVMの &lt;code&gt;java.util.Scanner&lt;/code&gt; クラスを使用するのは魅力的かもしれません。KotlinはJVMライブラリとうまく相互運用できるように設計されているため、Kotlinでの使用は非常に自然に感じられます。ただし、 &lt;code&gt;java.util.Scanner&lt;/code&gt; は非常に遅いことに注意してください。実際には非常に遅いため、10 &lt;sup&gt;5&lt;/sup&gt;以上の整数を解析すると、単純なKotlinの &lt;code&gt;split(&quot; &quot;).map { it.toInt() }&lt;/code&gt; が処理する通常の2秒の時間制限に収まらない可能性があります。</target>
        </trans-unit>
        <trans-unit id="4dcefeb4f7398e3e9107786806cb210122661b33" translate="yes" xml:space="preserve">
          <source>It prints &quot;sending&quot; &lt;em&gt;five&lt;/em&gt; times using a buffered channel with capacity of &lt;em&gt;four&lt;/em&gt;:</source>
          <target state="translated">&lt;em&gt;4つの&lt;/em&gt;容量を持つバッファ付きチャネルを使用して、「送信」を&lt;em&gt;5&lt;/em&gt;回印刷します。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="22cac1fe7a5de098526c35e5a30637b070cd91b6" translate="yes" xml:space="preserve">
          <source>It prints following lines:</source>
          <target state="translated">以下の行を印刷します。</target>
        </trans-unit>
        <trans-unit id="4fc49613736421c5526df5f47051346dc40ed425" translate="yes" xml:space="preserve">
          <source>It prints:</source>
          <target state="translated">印刷されます。</target>
        </trans-unit>
        <trans-unit id="c7f4b533e837bd7e46a9ce1a0a22fbfcd4d17d31" translate="yes" xml:space="preserve">
          <source>It produces something like that when running in &lt;a href=&quot;#debugging-coroutines-and-threads&quot;&gt;debug mode&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;#debugging-coroutines-and-threads&quot;&gt;デバッグモードで&lt;/a&gt;実行すると、次のようになります。</target>
        </trans-unit>
        <trans-unit id="937e4c5bd1079031a2dfad58d8e0700ddac7f05b" translate="yes" xml:space="preserve">
          <source>It produces something like this, with the whole collection taking around 1200 ms (three numbers, 400 ms for each):</source>
          <target state="translated">これは、コレクション全体が約1200ミリ秒(3つの数字、それぞれが400ミリ秒)かかると、このようなものを生成します。</target>
        </trans-unit>
        <trans-unit id="438255e8d8df7e6af7b2286b9eb0a1ff8f4ea247" translate="yes" xml:space="preserve">
          <source>It produces something like this:</source>
          <target state="translated">こんな感じのものが出てきます。</target>
        </trans-unit>
        <trans-unit id="fb781104064af1d8629d3a388a507c72839c91db" translate="yes" xml:space="preserve">
          <source>It produces the following output (maybe in different order):</source>
          <target state="translated">以下のような出力が得られます(順番が違うかもしれません)。</target>
        </trans-unit>
        <trans-unit id="c9f7c3047939db3a0d1c9e3a0026fbe61df824db" translate="yes" xml:space="preserve">
          <source>It produces the following output:</source>
          <target state="translated">以下のような出力が得られます。</target>
        </trans-unit>
        <trans-unit id="020338510019284e271656ee98c10ee9502fa284" translate="yes" xml:space="preserve">
          <source>It produces the following three lines, each line appearing after each second:</source>
          <target state="translated">それは以下の3行を生成し、各行は各秒の後に表示されます。</target>
        </trans-unit>
        <trans-unit id="6b842d5f86ada273da6149c65d3d77df472ae9b5" translate="yes" xml:space="preserve">
          <source>It produces the same numbers just faster, as we have effectively created a processing pipeline, having to only wait 100 ms for the first number and then spending only 300 ms to process each number. This way it takes around 1000 ms to run:</source>
          <target state="translated">最初の数字のために100ミリ秒しか待たず、その後、各数字を処理するために300ミリ秒しか使わない処理パイプラインを効果的に作成しているので、同じ数字がより速く生成されます。この方法では、実行するのに約1000ミリ秒かかります。</target>
        </trans-unit>
        <trans-unit id="17589c30d4bd3d4e252acd3e2fde1d3c719a5224" translate="yes" xml:space="preserve">
          <source>It returns a composition of two functions passed to it: &lt;code&gt;compose(f, g) = f(g(*))&lt;/code&gt;. Now, you can apply it to callable references:</source>
          <target state="translated">渡された2つの関数 &lt;code&gt;compose(f, g) = f(g(*))&lt;/code&gt; 合成を返します。これで、呼び出し可能な参照にそれを適用できます。</target>
        </trans-unit>
        <trans-unit id="ed5dfacacd6fed6df8733c434a43165786f1b136" translate="yes" xml:space="preserve">
          <source>It simplifies code generation, for example, for object initializers. The last element can also have a comma.</source>
          <target state="translated">これにより、例えばオブジェクトのイニシャライザなどのコード生成が簡素化されます。最後の要素にはカンマを付けることもできます。</target>
        </trans-unit>
        <trans-unit id="adaa459203490bc09b0dd6700bcf5aacd3687f3b" translate="yes" xml:space="preserve">
          <source>It takes two &lt;code&gt;Int&lt;/code&gt; parameters and returns a &lt;code&gt;Double&lt;/code&gt;, so its type is &lt;code&gt;(Int, Int) -&amp;gt; Double&lt;/code&gt;. We can reference the function itself by prefixing its name with &lt;code&gt;::&lt;/code&gt;, and we can assign it to a variable (whose type would normally be inferred, but we show the type signature for demonstration):</source>
          <target state="translated">2つの &lt;code&gt;Int&lt;/code&gt; パラメータを取り、 &lt;code&gt;Double&lt;/code&gt; を返すため、その型は &lt;code&gt;(Int, Int) -&amp;gt; Double&lt;/code&gt; です。名前の前に &lt;code&gt;::&lt;/code&gt; を付けることで関数自体を参照し、変数に割り当てることができます（型は通常推論されますが、デモのために型シグネチャを示します）。</target>
        </trans-unit>
        <trans-unit id="2543e91e8c67adc1567e54c9ccc67fdf2ca3724a" translate="yes" xml:space="preserve">
          <source>It was really annoying when all the arguments were in their correct positions but you wanted to specify a name for one argument in the middle. It was especially helpful for making absolutely clear which attribute a boolean or &lt;code&gt;null&lt;/code&gt; value belongs to.</source>
          <target state="translated">すべての引数が正しい位置にあるときは本当に面倒でしたが、途中で1つの引数の名前を指定したいとしました。ブール値または &lt;code&gt;null&lt;/code&gt; 値がどの属性に属するかを完全に明確にするのに特に役立ちました。</target>
        </trans-unit>
        <trans-unit id="c85187abd273afe2d39456db809770ff8d17b7cc" translate="yes" xml:space="preserve">
          <source>It will produce a platform-specific shared object (.so on Linux, .dylib on macOS, and .dll on Windows targets) and a C language header, allowing the use of all public APIs available in your Kotlin/Native program from C/C++ code. See &lt;code&gt;samples/python_extension&lt;/code&gt; for an example of using such a shared object to provide a bridge between Python and Kotlin/Native.</source>
          <target state="translated">プラットフォーム固有の共有オブジェクト（Linuxでは.so、macOSでは.dylib、Windowsターゲットでは.dll）とC言語ヘッダーを生成し、C /からKotlin / Nativeプログラムで利用可能なすべてのパブリックAPIを使用できるようにしますC ++コード。このような共有オブジェクトを使用してPythonとKotlin / Native間のブリッジを提供する例については、 &lt;code&gt;samples/python_extension&lt;/code&gt; をご覧ください。</target>
        </trans-unit>
        <trans-unit id="9b575c19d946e336100c7ed068ca562177833082" translate="yes" xml:space="preserve">
          <source>It will produce a platform-specific static object (.a library format) and a C language header, allowing you to use all the public APIs available in your Kotlin/Native program from C/C++ code.</source>
          <target state="translated">プラットフォーム固有の静的オブジェクト (.a ライブラリ形式)と C 言語ヘッダを生成し、C/C++コードから Kotlin/Native プログラムで利用可能なすべてのパブリック API を利用できるようにします。</target>
        </trans-unit>
        <trans-unit id="7c5675ec989f2dc249c2ff33b781d2949c2f52a5" translate="yes" xml:space="preserve">
          <source>It works only for interop libraries shipped with Kotlin/Native.</source>
          <target state="translated">Kotlin/Nativeと一緒に出荷されたinteropライブラリでのみ動作します。</target>
        </trans-unit>
        <trans-unit id="c77b95136e56addaaf94d730513b3a8bef6e57a3" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s almost done, user feedback is especially important now.</source>
          <target state="translated">ほぼ完了しました。ユーザーからのフィードバックは特に重要です。</target>
        </trans-unit>
        <trans-unit id="039acb422f298b9e2dda428662093ea454940860" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s done. We will be evolving it according to our strict &lt;a href=&quot;https://kotlinlang.org/foundation/language-committee-guidelines.html&quot;&gt;backward compatibility rules&lt;/a&gt;.</source>
          <target state="translated">終わった。厳密な&lt;a href=&quot;https://kotlinlang.org/foundation/language-committee-guidelines.html&quot;&gt;下位互換性ルール&lt;/a&gt;に従って進化させます。</target>
        </trans-unit>
        <trans-unit id="b3d38eb85ce2f60386c4898b42f31b426d1bea2f" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s easy to get started with Kotlin using the Kotlin plugin integrated in &lt;a href=&quot;https://www.jetbrains.com/idea/&quot;&gt;IntelliJ IDEA&lt;/a&gt;. Benefit from code highlighting, code completion, refactoring, debugging, and other features available for Kotlin.</source>
          <target state="translated">&lt;a href=&quot;https://www.jetbrains.com/idea/&quot;&gt;IntelliJ IDEAに&lt;/a&gt;統合されたKotlinプラグインを使用すると、Kotlinを簡単に使い始めることができます。Kotlinで利用可能なコードの強調表示、コードの補完、リファクタリング、デバッグ、およびその他の機能を利用できます。</target>
        </trans-unit>
        <trans-unit id="7d20f5ce9372886e3a18510e89bf62db3fa25cfc" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s extremely easy to start using Kotlin for Android development. In this tutorial we&amp;rsquo;ll follow the warming up process with Android Studio. If you're using Intellij IDEA with Android, the process is almost the same.</source>
          <target state="translated">Android開発にKotlinを使い始めるのは非常に簡単です。このチュートリアルでは、Android Studioを使用したウォーミングアッププロセスに従います。AndroidでIntellij IDEAを使用している場合、プロセスはほとんど同じです。</target>
        </trans-unit>
        <trans-unit id="0d25598a290d255bee23e0efee2aa27e246b4f17" translate="yes" xml:space="preserve">
          <source>It's allowed to pass the same array in the &lt;a href=&quot;copy-into#kotlin.collections%24copyInto%28kotlin.Array%28%28kotlin.collections.copyInto.T%29%29%2C+kotlin.Array%28%28kotlin.collections.copyInto.T%29%29%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Int%29%2Fdestination&quot;&gt;destination&lt;/a&gt; and even specify the subrange so that it overlaps with the destination range.</source>
          <target state="translated">同じ配列を&lt;a href=&quot;copy-into#kotlin.collections%24copyInto%28kotlin.Array%28%28kotlin.collections.copyInto.T%29%29%2C+kotlin.Array%28%28kotlin.collections.copyInto.T%29%29%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Int%29%2Fdestination&quot;&gt;宛先&lt;/a&gt;に渡して、宛先範囲と重複するようにサブ範囲を指定することもできます。</target>
        </trans-unit>
        <trans-unit id="ccc637fca146e7aa9091977f4ab6a14a8ec874b0" translate="yes" xml:space="preserve">
          <source>It's allowed to pass the same array in the &lt;a href=&quot;copy-into#kotlin.collections%24copyInto%28kotlin.UIntArray%2C+kotlin.UIntArray%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Int%29%2Fdestination&quot;&gt;destination&lt;/a&gt; and even specify the subrange so that it overlaps with the destination range.</source>
          <target state="translated">同じ配列を&lt;a href=&quot;copy-into#kotlin.collections%24copyInto%28kotlin.UIntArray%2C+kotlin.UIntArray%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Int%29%2Fdestination&quot;&gt;宛先&lt;/a&gt;に渡して、宛先範囲と重複するようにサブ範囲を指定することもできます。</target>
        </trans-unit>
        <trans-unit id="c547761ff928eabb85ae6f68b2a8d06acf2434c8" translate="yes" xml:space="preserve">
          <source>It's allowed to pass the same array in the &lt;a href=&quot;copy-into#kotlin.collections%24copyInto(kotlin.Array((kotlin.collections.copyInto.T)),%20kotlin.Array((kotlin.collections.copyInto.T)),%20kotlin.Int,%20kotlin.Int,%20kotlin.Int)/destination&quot;&gt;destination&lt;/a&gt; and even specify the subrange so that it overlaps with the destination range.</source>
          <target state="translated">&lt;a href=&quot;copy-into#kotlin.collections%24copyInto(kotlin.Array((kotlin.collections.copyInto.T)),%20kotlin.Array((kotlin.collections.copyInto.T)),%20kotlin.Int,%20kotlin.Int,%20kotlin.Int)/destination&quot;&gt;宛先で&lt;/a&gt;同じ配列を渡すことができ、宛先範囲とオーバーラップするようにサブ範囲を指定することもできます。</target>
        </trans-unit>
        <trans-unit id="0234d9c081afa271a5761a94d33278199b8154d0" translate="yes" xml:space="preserve">
          <source>It's allowed to pass the same array in the &lt;a href=&quot;copy-into#kotlin.collections%24copyInto(kotlin.UIntArray,%20kotlin.UIntArray,%20kotlin.Int,%20kotlin.Int,%20kotlin.Int)/destination&quot;&gt;destination&lt;/a&gt; and even specify the subrange so that it overlaps with the destination range.</source>
          <target state="translated">&lt;a href=&quot;copy-into#kotlin.collections%24copyInto(kotlin.UIntArray,%20kotlin.UIntArray,%20kotlin.Int,%20kotlin.Int,%20kotlin.Int)/destination&quot;&gt;宛先で&lt;/a&gt;同じ配列を渡すことができ、宛先範囲とオーバーラップするようにサブ範囲を指定することもできます。</target>
        </trans-unit>
        <trans-unit id="031250b72b284d8b276f90bf0d49fd6078c2857d" translate="yes" xml:space="preserve">
          <source>It's always possible to explicitly set the IntelliJ IDEA code style as the correct code style for the project. To do so please switch to the &lt;em&gt;Project&lt;/em&gt; scheme in &lt;code&gt;Settings &amp;rarr; Editor &amp;rarr; Code Style &amp;rarr; Kotlin&lt;/code&gt; and select &lt;em&gt;&quot;Kotlin obsolete IntelliJ IDEA codestyle&quot;&lt;/em&gt; in the &lt;em&gt;&quot;Use defaults from:&quot;&lt;/em&gt; on the &lt;em&gt;Load&lt;/em&gt; tab.</source>
          <target state="translated">IntelliJ IDEAコードスタイルをプロジェクトの正しいコードスタイルとして明示的に設定することは常に可能です。そうしてくださいスイッチを行うには&lt;em&gt;、プロジェクト&lt;/em&gt;におけるスキーム &lt;code&gt;Settings &amp;rarr; Editor &amp;rarr; Code Style &amp;rarr; Kotlin&lt;/code&gt; と選択し&lt;em&gt;、「Kotlin時代遅れのIntelliJ IDEAのcodestyleを」&lt;/em&gt;中&lt;em&gt;「から使用デフォルト：」&lt;/em&gt;に&lt;em&gt;ロード&lt;/em&gt; ]タブをクリックします。</target>
        </trans-unit>
        <trans-unit id="6e80a1e74b8c8e47694ccc45eb2685d70fcb822d" translate="yes" xml:space="preserve">
          <source>It's currently not possible to pass &lt;em&gt;null&lt;/em&gt; to a method that is declared as varargs.</source>
          <target state="translated">現在、varargsとして宣言されているメソッドに&lt;em&gt;null&lt;/em&gt;を渡すことはできません。</target>
        </trans-unit>
        <trans-unit id="114b9bcaf449cf9b870e05fba48add6ecc248f08" translate="yes" xml:space="preserve">
          <source>It's easy to forget to set the corresponding context element. The thread-local variable accessed from the coroutine may then have an unexpected value, if the thread running the coroutine is different. To avoid such situations, it is recommended to use the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/java.lang.-thread-local/ensure-present.html&quot;&gt;ensurePresent&lt;/a&gt; method and fail-fast on improper usages.</source>
          <target state="translated">対応するコンテキスト要素を設定するのを忘れがちです。コルーチンを実行しているスレッドが異なる場合、コルーチンからアクセスされるスレッドローカル変数は予期しない値を持つ可能性があります。このような状況を回避するには、&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/java.lang.-thread-local/ensure-present.html&quot;&gt;ensurePresent&lt;/a&gt;メソッドを使用し、不適切な使用法でフェイルファストすることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="acfee84980c04ef0fe85e54f28d399f66e64abaa" translate="yes" xml:space="preserve">
          <source>It's fine to inherit from both &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;, and we have no problems with &lt;code&gt;a()&lt;/code&gt; and &lt;code&gt;b()&lt;/code&gt; since &lt;code&gt;C&lt;/code&gt; inherits only one implementation of each of these functions. But for &lt;code&gt;f()&lt;/code&gt; we have two implementations inherited by &lt;code&gt;C&lt;/code&gt;, and thus we have to override &lt;code&gt;f()&lt;/code&gt; in &lt;code&gt;C&lt;/code&gt; and provide our own implementation that eliminates the ambiguity.</source>
          <target state="translated">これは、罰金の継承の両方から &lt;code&gt;A&lt;/code&gt; と &lt;code&gt;B&lt;/code&gt; 、そして我々はに問題がない &lt;code&gt;a()&lt;/code&gt; と &lt;code&gt;b()&lt;/code&gt; ので、 &lt;code&gt;C&lt;/code&gt; は、これらの機能のそれぞれの唯一の実装を継承します。しかし、用 &lt;code&gt;f()&lt;/code&gt; 我々はによって継承された2つの実装持っている &lt;code&gt;C&lt;/code&gt; をので、私たちはオーバーライドする必要があり &lt;code&gt;f()&lt;/code&gt; 中に &lt;code&gt;C&lt;/code&gt; やあいまいさを排除し、当社独自の実装を提供します。</target>
        </trans-unit>
        <trans-unit id="04f1d0f6695973692315398bd64dee5cfdd7323c" translate="yes" xml:space="preserve">
          <source>It's fine to inherit from both &lt;code&gt;Rectangle&lt;/code&gt; and &lt;code&gt;Polygon&lt;/code&gt;, but both of them have their implementations of &lt;code&gt;draw()&lt;/code&gt;, so we have to override &lt;code&gt;draw()&lt;/code&gt; in &lt;code&gt;Square&lt;/code&gt; and provide its own implementation that eliminates the ambiguity.</source>
          <target state="translated">&lt;code&gt;Rectangle&lt;/code&gt; と &lt;code&gt;Polygon&lt;/code&gt; の両方から継承することは問題ありませんが、どちらにも &lt;code&gt;draw()&lt;/code&gt; の実装があるため、 &lt;code&gt;Square&lt;/code&gt; で &lt;code&gt;draw()&lt;/code&gt; をオーバーライドし、あいまいさを排除する独自の実装を提供する必要があります。</target>
        </trans-unit>
        <trans-unit id="442e1f9409803560cb8db1e8e932691b852b50ed" translate="yes" xml:space="preserve">
          <source>It's important to close a stream when you're done with it; otherwise, your program will leak a file handle. See the next section for how do do this nicely.</source>
          <target state="translated">そうしないと、プログラムがファイルハンドルを漏らしてしまいます。そうしないと、あなたのプログラムはファイルハンドルを漏らしてしまいます。</target>
        </trans-unit>
        <trans-unit id="9346c60b395e4bb0937fa0abc8c38e87d658e069" translate="yes" xml:space="preserve">
          <source>It's important to make sure that the &lt;em&gt;Include Kotlin support&lt;/em&gt; checkbox is ticked. For now we can leave the default settings in the next step of the wizard. We then proceed to select the &lt;em&gt;Empty Activity&lt;/em&gt; option and click &lt;em&gt;Next&lt;/em&gt;, finally pressing &lt;em&gt;Finish&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;Kotlinサポートを含める&lt;/em&gt;チェックボックスがオンになっていることを確認することが重要です。とりあえず、ウィザードの次のステップはデフォルト設定のままにしておくことができます。&lt;em&gt;次に&lt;/em&gt;、[ &lt;em&gt;空のアクティビティ&lt;/em&gt; ]オプションを選択して[ &lt;em&gt;次へ&lt;/em&gt; ]をクリックし、最後に[ &lt;em&gt;完了&lt;/em&gt; ]を押します。</target>
        </trans-unit>
        <trans-unit id="3f80b2897a86bf69ce94fa9c91efda88ddaabb97" translate="yes" xml:space="preserve">
          <source>It's important to understand that this is now a native application, and no runtime or virtual machine is required. We can now run the compiled binary from the console:</source>
          <target state="translated">これがネイティブアプリケーションになったことを理解することが重要で、ランタイムや仮想マシンは必要ありません。コンパイルしたバイナリをコンソールから実行できるようになりました。</target>
        </trans-unit>
        <trans-unit id="841256700fec240b48d1a1475f562513e2734121" translate="yes" xml:space="preserve">
          <source>It's not recommended that you apply Kotlin plugins with &lt;code&gt;apply&lt;/code&gt; in Gradle Kotlin DSL &amp;ndash; &lt;a href=&quot;#using-gradle-kotlin-dsl&quot;&gt;see why&lt;/a&gt;.</source>
          <target state="translated">Gradle Kotlin DSLで &lt;code&gt;apply&lt;/code&gt; を使用してKotlinプラグインを適用することはお勧めしません&amp;ndash;&lt;a href=&quot;#using-gradle-kotlin-dsl&quot;&gt;理由を参照してください&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="451aaccdf6c2eb6d6c44303ffdea63bce2a3d7a2" translate="yes" xml:space="preserve">
          <source>It's not recommended to apply Kotlin plugins with &lt;code&gt;apply&lt;/code&gt; in Gradle Kotlin DSL. The details are provided &lt;a href=&quot;#using-gradle-kotlin-dsl&quot;&gt;below&lt;/a&gt;.</source>
          <target state="translated">Gradle Kotlin DSLの &lt;code&gt;apply&lt;/code&gt; でKotlinプラグインを適用することはお勧めしません。詳細は&lt;a href=&quot;#using-gradle-kotlin-dsl&quot;&gt;以下のとおり&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="903ee30ab34cc6304b069dd5e5dba6a6e65093d1" translate="yes" xml:space="preserve">
          <source>It's often the case that we need to copy an object altering &lt;em&gt;some&lt;/em&gt; of its properties, but keeping the rest unchanged. This is what &lt;code&gt;copy()&lt;/code&gt; function is generated for. For the &lt;code&gt;User&lt;/code&gt; class above, its implementation would be as follows:</source>
          <target state="translated">多くの場合、オブジェクトの&lt;em&gt;一部&lt;/em&gt;のプロパティを変更しながらオブジェクトをコピーする必要がありますが、残りは変更しません。これが &lt;code&gt;copy()&lt;/code&gt; 関数の生成対象です。上記の &lt;code&gt;User&lt;/code&gt; クラスの場合、その実装は次のようになります。</target>
        </trans-unit>
        <trans-unit id="f5bc060842af3a7b6e0d01c24d0becf2bb7a201f" translate="yes" xml:space="preserve">
          <source>It's possible to declare a cinterop dependency for a component:</source>
          <target state="translated">コンポーネントのcinterop依存関係を宣言することができます。</target>
        </trans-unit>
        <trans-unit id="2884706f64f3c6fe7682c1d6d6493a0cd7c7c71d" translate="yes" xml:space="preserve">
          <source>It's possible to depend on a Kotlin/Native library published earlier in a maven repo. The plugin relies on Gradle's &lt;a href=&quot;https://github.com/gradle/gradle/blob/master/subprojects/docs/src/docs/design/gradle-module-metadata-specification.md&quot;&gt;metadata&lt;/a&gt; support so the corresponding feature must be enabled. Add the following line in your &lt;code&gt;settings.gradle&lt;/code&gt;:</source>
          <target state="translated">Mavenリポジトリで以前に公開されたKotlin /ネイティブライブラリに依存することは可能です。プラグインはGradleの&lt;a href=&quot;https://github.com/gradle/gradle/blob/master/subprojects/docs/src/docs/design/gradle-module-metadata-specification.md&quot;&gt;メタデータ&lt;/a&gt;サポートに依存しているため、対応する機能を有効にする必要があります。 &lt;code&gt;settings.gradle&lt;/code&gt; に次の行を追加します。</target>
        </trans-unit>
        <trans-unit id="c597ff748c96d1169a0e3b1f389a9e5bf8a14509" translate="yes" xml:space="preserve">
          <source>It's recommended that you use Android Studio for creating Android applications. &lt;a href=&quot;https://developer.android.com/studio/releases/gradle-plugin&quot;&gt;Learn how to use Android Gradle plugin&lt;/a&gt;.</source>
          <target state="translated">Androidアプリケーションの作成にはAndroidStudioを使用することをお勧めします。&lt;a href=&quot;https://developer.android.com/studio/releases/gradle-plugin&quot;&gt;AndroidGradleプラグインの使用方法を学びます&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="268bb3f4ba30e1a5b60f8f81ac29d4c03ccdf710" translate="yes" xml:space="preserve">
          <source>It's recommended to propagate the experimental status to the API that depends on unsigned types by annotating it with this annotation.</source>
          <target state="translated">符号なし型に依存するAPIにこのアノテーションを付けることで、実験的な状態を伝播させることが推奨されています。</target>
        </trans-unit>
        <trans-unit id="d7daa3cad985a04d515f5a0b14e8155b1a6fab3e" translate="yes" xml:space="preserve">
          <source>It's up to you to decide if your clients have to explicitly opt-in into usage of your API, but bear in mind that unsigned types are an experimental feature, so API which uses them can be suddenly broken due to changes in language.</source>
          <target state="translated">クライアントが明示的にAPIの利用をオプトインするかどうかはあなた次第ですが、符号なし型は実験的な機能であり、言語の変更によってそれらを使用するAPIが突然壊れてしまう可能性があることを覚えておいてください。</target>
        </trans-unit>
        <trans-unit id="da8e68f5b23a3014c6d8de49b6e15eb047b18c62" translate="yes" xml:space="preserve">
          <source>It's up to you to decide if your clients have to explicitly opt-in into usage of your API, but bear in mind that unsigned types are not a stable feature, so API which uses them can be broken by changes in the language.</source>
          <target state="translated">クライアントが明示的にオプトインしてAPIを使用するかどうかはあなた次第ですが、符号なし型は安定した機能ではないことに留意してください。</target>
        </trans-unit>
        <trans-unit id="9fa67b0c21d7b8170095650619f367328af7593f" translate="yes" xml:space="preserve">
          <source>It's useful to shorten long generic types. For instance, it's often tempting to shrink collection types:</source>
          <target state="translated">長い汎用型を短縮するのは便利です。例えば、コレクション型を縮小したくなることがよくあります。</target>
        </trans-unit>
        <trans-unit id="d50dbfd39b435235eb76a4c86249fda694136067" translate="yes" xml:space="preserve">
          <source>It's very common that a lambda expression has only one parameter.</source>
          <target state="translated">ラムダ式のパラメータが1つしかないことはよくあることです。</target>
        </trans-unit>
        <trans-unit id="497cb9444d2d1993508a971a9e38bf60f29788e9" translate="yes" xml:space="preserve">
          <source>ItemArrayLike</source>
          <target state="translated">ItemArrayLike</target>
        </trans-unit>
        <trans-unit id="08ca6a3da933ca6826a2f4d3fcc919af71d7e380" translate="yes" xml:space="preserve">
          <source>Iterable</source>
          <target state="translated">Iterable</target>
        </trans-unit>
        <trans-unit id="dc8802d44941c46da0da729594bb50e6d441ce2d" translate="yes" xml:space="preserve">
          <source>Iterable.groupingBy</source>
          <target state="translated">Iterable.groupingBy</target>
        </trans-unit>
        <trans-unit id="380a211ab0a9e218f328f8421df21a0f64a31d3e" translate="yes" xml:space="preserve">
          <source>Iterates through each line of this reader, calls &lt;a href=&quot;for-each-line#kotlin.io%24forEachLine%28java.io.Reader%2C+kotlin.Function1%28%28kotlin.String%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;action&lt;/a&gt; for each line read and closes the &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/io/Reader.html&quot;&gt;Reader&lt;/a&gt; when it's completed.</source>
          <target state="translated">このリーダーの各行を反復処理し、読み込まれた各行の&lt;a href=&quot;for-each-line#kotlin.io%24forEachLine%28java.io.Reader%2C+kotlin.Function1%28%28kotlin.String%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;アクション&lt;/a&gt;を呼び出し、完了したら&lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/io/Reader.html&quot;&gt;リーダー&lt;/a&gt;を閉じます。</target>
        </trans-unit>
        <trans-unit id="a23c7a347a61820ec903389403c010444ab83c86" translate="yes" xml:space="preserve">
          <source>Iterates through each line of this reader, calls &lt;a href=&quot;for-each-line#kotlin.io%24forEachLine(java.io.Reader,%20kotlin.Function1((kotlin.String,%20kotlin.Unit)))/action&quot;&gt;action&lt;/a&gt; for each line read and closes the &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/io/Reader.html&quot;&gt;Reader&lt;/a&gt; when it's completed.</source>
          <target state="translated">このリーダーの各行を繰り返し処理し、読み取った各行に対して&lt;a href=&quot;for-each-line#kotlin.io%24forEachLine(java.io.Reader,%20kotlin.Function1((kotlin.String,%20kotlin.Unit)))/action&quot;&gt;アクション&lt;/a&gt;を呼び出し、&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/io/Reader.html&quot;&gt;リーダー&lt;/a&gt;が完了すると閉じます。</target>
        </trans-unit>
        <trans-unit id="df79ba3f92580a38aac3b295d97ec6467bf9c601" translate="yes" xml:space="preserve">
          <source>Iterating over a collection:</source>
          <target state="translated">コレクションを反復処理します。</target>
        </trans-unit>
        <trans-unit id="cd542426f011094d421bd238597459f01a78a773" translate="yes" xml:space="preserve">
          <source>Iterating over a range:</source>
          <target state="translated">範囲を反復していく。</target>
        </trans-unit>
        <trans-unit id="bae8809b2429231a50c28ba87cecc038aac88855" translate="yes" xml:space="preserve">
          <source>Iterator</source>
          <target state="translated">Iterator</target>
        </trans-unit>
        <trans-unit id="003d5d89ff75536e7c8fe75998f6c431dc6a6bfb" translate="yes" xml:space="preserve">
          <source>Iterator for characters of the given char sequence.</source>
          <target state="translated">指定した文字列の文字のイテレータ。</target>
        </trans-unit>
        <trans-unit id="909a5f0dfd8c3a4ef79cd1458e2b5fb136ad7fae" translate="yes" xml:space="preserve">
          <source>Iterators</source>
          <target state="translated">Iterators</target>
        </trans-unit>
        <trans-unit id="506c9ecd5cb52c951984866e4ca884bba6f6ea5f" translate="yes" xml:space="preserve">
          <source>Iterators can be obtained for inheritors of the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-iterable/index&quot;&gt;&lt;code&gt;Iterable&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; interface, including &lt;code&gt;Set&lt;/code&gt; and &lt;code&gt;List&lt;/code&gt;, by calling the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-iterable/iterator&quot;&gt;&lt;code&gt;iterator()&lt;/code&gt;&lt;/a&gt; function. Once you obtain an iterator, it points to the first element of a collection; calling the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-iterator/next&quot;&gt;&lt;code&gt;next()&lt;/code&gt;&lt;/a&gt; function returns this element and moves the iterator position to the following element if it exists. Once the iterator passes through the last element, it can no longer be used for retrieving elements; neither can it be reset to any previous position. To iterate through the collection again, create a new iterator.</source>
          <target state="translated">イテレータは、&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-iterable/iterator&quot;&gt; &lt;code&gt;iterator()&lt;/code&gt; &lt;/a&gt;関数を呼び出すことで、 &lt;code&gt;Set&lt;/code&gt; や &lt;code&gt;List&lt;/code&gt; を含む&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-iterable/index&quot;&gt; &lt;code&gt;Iterable&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;インターフェースの継承のために取得できます。イテレータを取得すると、それはコレクションの最初の要素を指します。&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-iterator/next&quot;&gt; &lt;code&gt;next()&lt;/code&gt; &lt;/a&gt;関数を呼び出すと、この要素が返され、イテレータの位置が存在する場合は次の要素に移動します。イテレータが最後の要素を通過すると、要素を取得するために使用できなくなります。また、以前の位置にリセットすることもできません。コレクションを繰り返し処理するには、新しいイテレータを作成します。</target>
        </trans-unit>
        <trans-unit id="bc0b40497b63bea004394bd2f67e443f08b6588f" translate="yes" xml:space="preserve">
          <source>JAR file for the Android project, from the &lt;code&gt;androidMain&lt;/code&gt; source set</source>
          <target state="translated">&lt;code&gt;androidMain&lt;/code&gt; ソースセットからのAndroidプロジェクトのJARファイル</target>
        </trans-unit>
        <trans-unit id="1c094e3ab7a1c494d642222b6728398ff3000b42" translate="yes" xml:space="preserve">
          <source>JPA support</source>
          <target state="translated">JPA支援</target>
        </trans-unit>
        <trans-unit id="95f92b2f0cb530542d16d90a6c2af59e20759430" translate="yes" xml:space="preserve">
          <source>JS</source>
          <target state="translated">JS</target>
        </trans-unit>
        <trans-unit id="18acc06f648ff3dfaa92d38568a89dcb1c336e71" translate="yes" xml:space="preserve">
          <source>JS + Native</source>
          <target state="translated">JS+ネイティブ</target>
        </trans-unit>
        <trans-unit id="2ef44ba04cb41365765eba178e5fb528ee006a1b" translate="yes" xml:space="preserve">
          <source>JS:</source>
          <target state="translated">JS:</target>
        </trans-unit>
        <trans-unit id="031a4e76f0b39d0df073d934da5fc48da8d737e5" translate="yes" xml:space="preserve">
          <source>JSON</source>
          <target state="translated">JSON</target>
        </trans-unit>
        <trans-unit id="8262ef9c2c68924dbec9b88761bde41ad5ef98f3" translate="yes" xml:space="preserve">
          <source>JSR-305 (&lt;code&gt;javax.annotation&lt;/code&gt;, more details below)</source>
          <target state="translated">JSR-305（ &lt;code&gt;javax.annotation&lt;/code&gt; 、詳細は以下）</target>
        </trans-unit>
        <trans-unit id="5188151af5277b4d83b75fa70a7e55c37a18f211" translate="yes" xml:space="preserve">
          <source>JSR-305 Support</source>
          <target state="translated">JSR-305 サポート</target>
        </trans-unit>
        <trans-unit id="bb63c86538bf1c2ee7cd6190cf88dd1f44d85eff" translate="yes" xml:space="preserve">
          <source>JVM</source>
          <target state="translated">JVM</target>
        </trans-unit>
        <trans-unit id="ba55f5a90bf0d3ce9f1b0f807b6ef302c9ac96c9" translate="yes" xml:space="preserve">
          <source>JVM + Android targets</source>
          <target state="translated">JVM+Androidターゲット</target>
        </trans-unit>
        <trans-unit id="d91c8eab1c7dd4c61791a6e6cea54a63f44fc1bc" translate="yes" xml:space="preserve">
          <source>JVM + JS</source>
          <target state="translated">JVM+JS</target>
        </trans-unit>
        <trans-unit id="6c072fe1de9573a0b46a9ce0b06fdf1d4adc47cb" translate="yes" xml:space="preserve">
          <source>JVM + JS + Native</source>
          <target state="translated">JVM+JS+ネイティブ</target>
        </trans-unit>
        <trans-unit id="0b9d77993a56f0043f2307875f7d47573f436cff" translate="yes" xml:space="preserve">
          <source>JVM + Native</source>
          <target state="translated">JVM+ネイティブ</target>
        </trans-unit>
        <trans-unit id="04a7d3f3683303c17ad132f382f6d0c911d30883" translate="yes" xml:space="preserve">
          <source>JVM 6</source>
          <target state="translated">JVM 6</target>
        </trans-unit>
        <trans-unit id="3430f69443094c1010f905be31e657db1bc9cecc" translate="yes" xml:space="preserve">
          <source>JVM Backend</source>
          <target state="translated">JVMバックエンド</target>
        </trans-unit>
        <trans-unit id="8a60d58cc6c328ec0b68627b45e8de68d5004fb4" translate="yes" xml:space="preserve">
          <source>JVM backend</source>
          <target state="translated">JVMバックエンド</target>
        </trans-unit>
        <trans-unit id="e314b08890e867b0e66c9aacb3731e2c760fd4e5" translate="yes" xml:space="preserve">
          <source>JVM dependency</source>
          <target state="translated">JVM依存性</target>
        </trans-unit>
        <trans-unit id="458cadbdc19f7b0625a6ae9eae43cf7d180c87dd" translate="yes" xml:space="preserve">
          <source>JVM modules</source>
          <target state="translated">JVMモジュール</target>
        </trans-unit>
        <trans-unit id="7843626ea3524e7d3635490a634ced48fdacaeb5" translate="yes" xml:space="preserve">
          <source>JVM targets</source>
          <target state="translated">JVMターゲット</target>
        </trans-unit>
        <trans-unit id="1e479037f37f3056da4dd3f4b8476891324342ba" translate="yes" xml:space="preserve">
          <source>JVM:</source>
          <target state="translated">JVM:</target>
        </trans-unit>
        <trans-unit id="4aa2729d3292a207da300462e1c7fb9e07fee8d1" translate="yes" xml:space="preserve">
          <source>Jar file</source>
          <target state="translated">ジャーファイル</target>
        </trans-unit>
        <trans-unit id="c32dbe67bb4cda6c969b9b214ff6e46a25b2a0f2" translate="yes" xml:space="preserve">
          <source>Java 7's try with resources</source>
          <target state="translated">リソースを使ったJava 7の試み</target>
        </trans-unit>
        <trans-unit id="ac187b2b88eb97c8a6d1b499783f3187c6ec8c0b" translate="yes" xml:space="preserve">
          <source>Java 8 bytecode support</source>
          <target state="translated">Java 8 バイトコードサポート</target>
        </trans-unit>
        <trans-unit id="072e6f9a3196506ae761b516738d856e34828cc7" translate="yes" xml:space="preserve">
          <source>Java 8 standard library support</source>
          <target state="translated">Java 8 標準ライブラリのサポート</target>
        </trans-unit>
        <trans-unit id="01579d0353cd60180076cc09ff0d55781e923e55" translate="yes" xml:space="preserve">
          <source>Java Annotations</source>
          <target state="translated">Java アノテーション</target>
        </trans-unit>
        <trans-unit id="d04e5ac8f8fe9912f7302d2d4689867b318a2094" translate="yes" xml:space="preserve">
          <source>Java Arrays</source>
          <target state="translated">Java 配列</target>
        </trans-unit>
        <trans-unit id="860970d26c3938762fa2e2c7b7194b61a0231169" translate="yes" xml:space="preserve">
          <source>Java EE Http servlets can be used from Kotlin much like any other Java library or framework. We'll see how to make a simple controller that returns &quot;Hello, World!&quot;.</source>
          <target state="translated">Java EE Httpサーブレットは、他のJavaライブラリやフレームワークと同様にKotlinから使用することができます。Hello,World!&quot;を返すシンプルなコントローラを作る方法を見てみましょう。</target>
        </trans-unit>
        <trans-unit id="98c55e3f9693daef863846ba04beb7a87639d58b" translate="yes" xml:space="preserve">
          <source>Java Interoperability</source>
          <target state="translated">ジャバ相互運用性</target>
        </trans-unit>
        <trans-unit id="ab55871eec7aba9e50581782c94506d7b076be92" translate="yes" xml:space="preserve">
          <source>Java Reflection</source>
          <target state="translated">Java リフレクション</target>
        </trans-unit>
        <trans-unit id="2fbdce03c9470f1b2722c2ee692684eb6163442c" translate="yes" xml:space="preserve">
          <source>Java SAM interfaces in Kotlin</source>
          <target state="translated">Kotlin の Java SAM インターフェース</target>
        </trans-unit>
        <trans-unit id="8b7c04d9bb7da5a0513e73469be371a892a0ddec" translate="yes" xml:space="preserve">
          <source>Java Support in JVM Targets</source>
          <target state="translated">JVMターゲットでのJavaサポート</target>
        </trans-unit>
        <trans-unit id="027f8a4631110b77b693f662b6d14564e95f3ad5" translate="yes" xml:space="preserve">
          <source>Java Varargs</source>
          <target state="translated">Java Varargs</target>
        </trans-unit>
        <trans-unit id="83c71cd47e81bcbb82cda5a763f3b5d7be5fba22" translate="yes" xml:space="preserve">
          <source>Java Virtual Machine</source>
          <target state="translated">Java仮想マシン</target>
        </trans-unit>
        <trans-unit id="746c982d879f15c37e1edb8014f7e0a7a57db534" translate="yes" xml:space="preserve">
          <source>Java annotations are 100% compatible with Kotlin:</source>
          <target state="translated">JavaアノテーションはKotlinと100%互換性があります。</target>
        </trans-unit>
        <trans-unit id="85a2157de6f31be86d225df11c21c07e4164424b" translate="yes" xml:space="preserve">
          <source>Java classes sometimes use a method declaration for the indices with a variable number of arguments (varargs):</source>
          <target state="translated">Javaのクラスは、可変数の引数(varargs)を持つインデックスのメソッド宣言を使用することがあります。</target>
        </trans-unit>
        <trans-unit id="695cb4693d8f07873088e0e2ca1954a3e6b1dec0" translate="yes" xml:space="preserve">
          <source>Java compiler options</source>
          <target state="translated">Java コンパイラオプション</target>
        </trans-unit>
        <trans-unit id="53d9a40a89e185b3910817fb0920db3433576443" translate="yes" xml:space="preserve">
          <source>Java generics in Kotlin</source>
          <target state="translated">Kotlin での Java ジェネリック</target>
        </trans-unit>
        <trans-unit id="8de44c9537e6dbc55b9f15952d2d0c0a403f924d" translate="yes" xml:space="preserve">
          <source>Java interoperation:</source>
          <target state="translated">Javaの相互運用。</target>
        </trans-unit>
        <trans-unit id="05bbb6e796992dd8a4fef0cfa9a4d27c4b673a12" translate="yes" xml:space="preserve">
          <source>Java libraries</source>
          <target state="translated">ジャバライブラリ</target>
        </trans-unit>
        <trans-unit id="e832e4cfea4d9817c729a744a89f9449a5f1d1ee" translate="yes" xml:space="preserve">
          <source>Java only got support for function types and lambda expressions a few years ago. Previously, Java worked around this by using an interface to define a function signature and allowing an inline, anonymous definition of a class that implements the interface. This is also available in Kotlin, partly for compatibility with Java libraries and partly because it can be handy for specifying event handlers (in particular if there is more than one event type that must be listened for by the same listener object). Consider an interface or a (possibly abstract) class, as well a function that takes an instance of it:</source>
          <target state="translated">Javaが関数型とラムダ式をサポートしたのは数年前のことです。以前のJavaでは、関数のシグネチャを定義するためにインターフェイスを使用し、インターフェイスを実装したクラスをインラインで匿名で定義できるようにすることで、この問題を回避していました。これはKotlinでも利用できます。これはJavaライブラリとの互換性のためと、イベントハンドラを指定するのに便利だからです(特に、同じリスナーオブジェクトでリッスンしなければならないイベントタイプが複数ある場合)。インターフェースや(抽象的な)クラス、そしてそのインスタンスを受け取る関数を考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="1915d97968b458264a2f2dbd19e10237488a0c18" translate="yes" xml:space="preserve">
          <source>Java reflection works on Kotlin classes and vice versa. As mentioned above, you can use &lt;code&gt;instance::class.java&lt;/code&gt;, &lt;code&gt;ClassName::class.java&lt;/code&gt; or &lt;code&gt;instance.javaClass&lt;/code&gt; to enter Java reflection through &lt;code&gt;java.lang.Class&lt;/code&gt;.</source>
          <target state="translated">JavaリフレクションはKotlinクラスで動作し、その逆も同様です。上記のように、 &lt;code&gt;instance::class.java&lt;/code&gt; 、 &lt;code&gt;ClassName::class.java&lt;/code&gt; または &lt;code&gt;instance.javaClass&lt;/code&gt; を使用して、 &lt;code&gt;java.lang.Class&lt;/code&gt; を通じてJavaリフレクションに入ることができます。</target>
        </trans-unit>
        <trans-unit id="ef56a24f4d8f2d665c8315a53a8f2125506c9068" translate="yes" xml:space="preserve">
          <source>Java reflection works on Kotlin classes and vice versa. As mentioned above, you can use &lt;code&gt;instance::class.java&lt;/code&gt;, &lt;code&gt;ClassName::class.java&lt;/code&gt; or &lt;code&gt;instance.javaClass&lt;/code&gt; to enter Java reflection through &lt;code&gt;java.lang.Class&lt;/code&gt;. You may also use &lt;code&gt;ClassName::class.javaObjectType&lt;/code&gt; for getting primitive types wrappers.</source>
          <target state="translated">JavaリフレクションはKotlinクラスで機能し、その逆も同様です。上記のように、 &lt;code&gt;instance::class.java&lt;/code&gt; 、 &lt;code&gt;ClassName::class.java&lt;/code&gt; または &lt;code&gt;instance.javaClass&lt;/code&gt; を使用して、 &lt;code&gt;java.lang.Class&lt;/code&gt; を介してJavaリフレクションを入力できます。プリミティブ型のラッパーを取得するために &lt;code&gt;ClassName::class.javaObjectType&lt;/code&gt; を使用することもできます。</target>
        </trans-unit>
        <trans-unit id="604557100ea734a8e508b4cfcd3fd0b6ae0fffe3" translate="yes" xml:space="preserve">
          <source>Java types which have nullability annotations are represented not as platform types, but as actual nullable or non-null Kotlin types. The compiler supports several flavors of nullability annotations, including:</source>
          <target state="translated">nullabilityアノテーションを持つJavaの型は、プラットフォーム型としてではなく、実際のnullableまたはnon-nullのKotlin型として表現されます。コンパイラは、以下のようないくつかの種類のヌル可能性アノテーションをサポートしています。</target>
        </trans-unit>
        <trans-unit id="dc024086aaa20e53d67ca09758f8c4d13c64cb3c" translate="yes" xml:space="preserve">
          <source>Java's arrays are mapped as mentioned &lt;a href=&quot;java-interop#java-arrays&quot;&gt;below&lt;/a&gt;:</source>
          <target state="translated">Javaの配列は、次のようにマップされ&lt;a href=&quot;java-interop#java-arrays&quot;&gt;ます&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a52c0cfe5cac6860cf184e57dfda94c4e4aab7eb" translate="yes" xml:space="preserve">
          <source>Java's boxed primitive types are mapped to nullable Kotlin types:</source>
          <target state="translated">Javaの箱型プリミティブ型は、ヌル可能なKotlin型にマッピングされています。</target>
        </trans-unit>
        <trans-unit id="a93aa77d99dfed9f4e64393e47b4458e7232bba4" translate="yes" xml:space="preserve">
          <source>Java's raw types are converted into star projections,</source>
          <target state="translated">Javaの生の型は星の投影に変換されます。</target>
        </trans-unit>
        <trans-unit id="4b08bd53dd6ccc40659e0ead9c100bf1e91b5ac6" translate="yes" xml:space="preserve">
          <source>Java's wildcards are converted into type projections,</source>
          <target state="translated">Javaのワイルドカードは型投影に変換されます。</target>
        </trans-unit>
        <trans-unit id="b7e0008cfda3632a9ce80870d8378b5ff1ce2de5" translate="yes" xml:space="preserve">
          <source>Java-default method calls</source>
          <target state="translated">ジャワデフォルトメソッド呼び出し</target>
        </trans-unit>
        <trans-unit id="28658a9e65ac1fce8b895da9099268ad9257b5a4" translate="yes" xml:space="preserve">
          <source>Java-style reflection</source>
          <target state="translated">ジャバ式反射</target>
        </trans-unit>
        <trans-unit id="d3d2902f267714c4d2888df7a9cb53494548b955" translate="yes" xml:space="preserve">
          <source>Java2Kotlin converter</source>
          <target state="translated">ジャワツーコトリンコンバータ</target>
        </trans-unit>
        <trans-unit id="ee620923ff5fc510555dc37083a135ee93b5404b" translate="yes" xml:space="preserve">
          <source>JavaScript</source>
          <target state="translated">JavaScript</target>
        </trans-unit>
        <trans-unit id="cb598ee02a2a4ba66a8b8c49bee0bba3cd995db7" translate="yes" xml:space="preserve">
          <source>JavaScript Backend</source>
          <target state="translated">JavaScriptバックエンド</target>
        </trans-unit>
        <trans-unit id="7ceba75ee976f8baf2462d625f66425dd948bcef" translate="yes" xml:space="preserve">
          <source>JavaScript DCE</source>
          <target state="translated">JavaScript DCE</target>
        </trans-unit>
        <trans-unit id="1731268deeec6a5538ea96e67d2bad77e86644c6" translate="yes" xml:space="preserve">
          <source>JavaScript Dead Code Elimination (DCE)</source>
          <target state="translated">JavaScriptデッドコード排除(DCE</target>
        </trans-unit>
        <trans-unit id="b3f888694954b41c7c2070331437408d8501d710" translate="yes" xml:space="preserve">
          <source>JavaScript Modules</source>
          <target state="translated">JavaScriptモジュール</target>
        </trans-unit>
        <trans-unit id="8c784f817b830f35e8d38eb1b5afb3d6e6b36d02" translate="yes" xml:space="preserve">
          <source>JavaScript Reflection</source>
          <target state="translated">JavaScript リフレクション</target>
        </trans-unit>
        <trans-unit id="6427edfd3be2acf2cb18120ef89fe67414e7fe92" translate="yes" xml:space="preserve">
          <source>JavaScript backend</source>
          <target state="translated">JavaScriptバックエンド</target>
        </trans-unit>
        <trans-unit id="21bc6187f833ae0234195b5bb7f032fa9c9eddf3" translate="yes" xml:space="preserve">
          <source>JavaScript backend now generates more statically checkable code, which is friendlier to JS code processing tools, like minifiers, optimisers, linters, etc.</source>
          <target state="translated">JavaScriptバックエンドは、より静的にチェック可能なコードを生成するようになり、ミニファイア、オプティマイザ、リンタなどのJSコード処理ツールとの親和性が向上しました。</target>
        </trans-unit>
        <trans-unit id="18040e1d6c0077c2a62cb7d49ff581501d95859d" translate="yes" xml:space="preserve">
          <source>JavaScript does not have concept of packages (namespaces). They are usually emulated by nested objects. The compiler turns references to &lt;code&gt;external&lt;/code&gt; declarations either to plain unprefixed names (in case of &lt;em&gt;plain&lt;/em&gt; modules) or to plain imports. However, if a JavaScript library provides its declarations in packages, you won't be satisfied with this. You can tell the compiler to generate additional prefix before references to &lt;code&gt;external&lt;/code&gt; declarations using the &lt;code&gt;@JsQualifier(...)&lt;/code&gt; annotation.</source>
          <target state="translated">JavaScriptには、パッケージ（名前空間）の概念はありません。これらは通常、ネストされたオブジェクトによってエミュレートされます。コンパイラーは、 &lt;code&gt;external&lt;/code&gt; 宣言への参照を、プレフィックスのないプレフィックス名（&lt;em&gt;プレーンな&lt;/em&gt;モジュールの場合）またはプレーンなインポートに変換します。ただし、JavaScriptライブラリがその宣言をパッケージで提供する場合は、これで満足できません。 &lt;code&gt;@JsQualifier(...)&lt;/code&gt; アノテーションを使用して、 &lt;code&gt;external&lt;/code&gt; 宣言を参照する前に追加のプレフィックスを生成するようにコンパイラーに指示できます。</target>
        </trans-unit>
        <trans-unit id="95802660178652b3cea0422eb5403bb445448c4c" translate="yes" xml:space="preserve">
          <source>JavaScript does not have the concept of interfaces. When a function expects its parameter to support &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;bar&lt;/code&gt; methods, you just pass objects that actually have these methods. You can use interfaces to express this for statically-typed Kotlin, for example:</source>
          <target state="translated">JavaScriptにはインターフェースの概念はありません。関数がそのパラメーターが &lt;code&gt;foo&lt;/code&gt; および &lt;code&gt;bar&lt;/code&gt; メソッドをサポートすることを期待する場合、実際にこれらのメソッドを持つオブジェクトを渡すだけです。インターフェースを使用して、静的に型付けされたKotlinに対してこれを表現できます。次に例を示します。</target>
        </trans-unit>
        <trans-unit id="db533d2ccc039c3271e49d0037285a95132804d3" translate="yes" xml:space="preserve">
          <source>JavaScript does not have the concept of interfaces. When a function expects its parameter to support two methods &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;bar&lt;/code&gt;, you would just pass in an object that actually has these methods.</source>
          <target state="translated">JavaScriptにはインターフェースの概念がありません。関数がそのパラメーターが2つのメソッド &lt;code&gt;foo&lt;/code&gt; と &lt;code&gt;bar&lt;/code&gt; をサポートすることを期待している場合、実際にこれらのメソッドを持つオブジェクトを渡すだけです。</target>
        </trans-unit>
        <trans-unit id="5b5802824529ccfad8f8c81c90d94e61f99e64f2" translate="yes" xml:space="preserve">
          <source>JavaScript targets</source>
          <target state="translated">ジャバスクリプトターゲット</target>
        </trans-unit>
        <trans-unit id="fffb2c94a89ef37f4ff800dd4f2f3274e7b4c9bf" translate="yes" xml:space="preserve">
          <source>JetBrains develops and maintains several tools specifically for the React community: &lt;a href=&quot;https://github.com/JetBrains/kotlin-wrappers&quot;&gt;React bindings&lt;/a&gt; as well as &lt;a href=&quot;https://github.com/JetBrains/create-react-kotlin-app&quot;&gt;Create React Kotlin App&lt;/a&gt;. The latter helps you start building React apps with Kotlin with no build configuration.</source>
          <target state="translated">JetBrainsは、Reactコミュニティ専用のいくつかのツールを開発および保守しています&lt;a href=&quot;https://github.com/JetBrains/kotlin-wrappers&quot;&gt;。Reactバインディング&lt;/a&gt;と&lt;a href=&quot;https://github.com/JetBrains/create-react-kotlin-app&quot;&gt;Create React Kotlinアプリ&lt;/a&gt;です。後者は、ビルド構成のないKotlinでReactアプリのビルドを開始するのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="0afbb0e9a99e99277b2f49549fedbc94a32802c2" translate="yes" xml:space="preserve">
          <source>Job in the context</source>
          <target state="translated">文脈の中での仕事</target>
        </trans-unit>
        <trans-unit id="06c75c90e1e9379a2cdd628513a60c328e9a2837" translate="yes" xml:space="preserve">
          <source>Join the Kotlin/JS community</source>
          <target state="translated">Kotlin/JSコミュニティに参加する</target>
        </trans-unit>
        <trans-unit id="4f050b9ce8a72499f6d4325b437a4f8f851d64df" translate="yes" xml:space="preserve">
          <source>Join us to continue exploring the C language types and their representation in Kotlin/Native in the related tutorials:</source>
          <target state="translated">Kotlin/Native での C 言語の型とその表現について、関連するチュートリアルに参加してみませんか?</target>
        </trans-unit>
        <trans-unit id="560f658735b552460323d7d08486e67939d8b69b" translate="yes" xml:space="preserve">
          <source>Joining a course</source>
          <target state="translated">コースに参加する</target>
        </trans-unit>
        <trans-unit id="e14bf41ef01fdef5cf6b52dd5564ec2b2886f811" translate="yes" xml:space="preserve">
          <source>Joshua Bloch calls those objects you only &lt;strong&gt;read&lt;/strong&gt; from &lt;strong&gt;Producers&lt;/strong&gt;, and those you only &lt;strong&gt;write&lt;/strong&gt; to &lt;strong&gt;Consumers&lt;/strong&gt;. He recommends: &quot;&lt;em&gt;For maximum flexibility, use wildcard types on input parameters that represent producers or consumers&lt;/em&gt;&quot;, and proposes the following mnemonic:</source>
          <target state="translated">ジョシュア・ブロックは、それらを使用すると、オブジェクトのみ呼び出す&lt;strong&gt;読み&lt;/strong&gt;から&lt;strong&gt;生産&lt;/strong&gt;、そしてあなただけのものを&lt;strong&gt;書く&lt;/strong&gt;には&lt;strong&gt;消費者&lt;/strong&gt;。彼は、「&lt;em&gt;最大限の柔軟性を得るために、プロデューサーまたはコンシューマーを表す入力パラメーターでワイルドカードタイプを使用する&lt;/em&gt;」ことを推奨し、次のニーモニックを提案します。</target>
        </trans-unit>
        <trans-unit id="aaaf7cda9e752b334875dd3fb12220ae53318575" translate="yes" xml:space="preserve">
          <source>JsArray</source>
          <target state="translated">JsArray</target>
        </trans-unit>
        <trans-unit id="5cf2add42044a4a104180a92b4649ba344349b36" translate="yes" xml:space="preserve">
          <source>JsClass</source>
          <target state="translated">JsClass</target>
        </trans-unit>
        <trans-unit id="829d41f036e4b83f97d9207ff01e19270a103dc5" translate="yes" xml:space="preserve">
          <source>JsExport</source>
          <target state="translated">JsExport</target>
        </trans-unit>
        <trans-unit id="680d5016d394bd1910f8e79c1f48e1099ec8a45e" translate="yes" xml:space="preserve">
          <source>JsModule</source>
          <target state="translated">JsModule</target>
        </trans-unit>
        <trans-unit id="bb2ba9a64ec3ce618d8658d2bac2ab5b52799c41" translate="yes" xml:space="preserve">
          <source>JsName</source>
          <target state="translated">JsName</target>
        </trans-unit>
        <trans-unit id="285e217de7a6a19bb6ff3224730d97a2ffb8669c" translate="yes" xml:space="preserve">
          <source>JsNonModule</source>
          <target state="translated">JsNonModule</target>
        </trans-unit>
        <trans-unit id="4431c8a7c0e95318d4df4acc2fb68414f204013b" translate="yes" xml:space="preserve">
          <source>JsQualifier</source>
          <target state="translated">JsQualifier</target>
        </trans-unit>
        <trans-unit id="5e2ef85ac474ea70113e00f2d535adfcd131ef41" translate="yes" xml:space="preserve">
          <source>JsValue</source>
          <target state="translated">JsValue</target>
        </trans-unit>
        <trans-unit id="0e8b29f774aacb41aea9f3a3e3922bc27a5b2f86" translate="yes" xml:space="preserve">
          <source>Json</source>
          <target state="translated">Json</target>
        </trans-unit>
        <trans-unit id="ee67901393cc367dccd6b7380bc834e3173528f8" translate="yes" xml:space="preserve">
          <source>Jumping between threads</source>
          <target state="translated">スレッド間のジャンプ</target>
        </trans-unit>
        <trans-unit id="c4dd39bfc503df3e7ae8d48062e97ce8c118b15c" translate="yes" xml:space="preserve">
          <source>Jupyter Kotlin kernel</source>
          <target state="translated">ジュピターコトリンカーネル</target>
        </trans-unit>
        <trans-unit id="35e8c2b0fe924d03188fa9d13f85d320bcb98681" translate="yes" xml:space="preserve">
          <source>Just add the plugin JAR file to the compiler plugin classpath and specify the list of sam-with-receiver annotations:</source>
          <target state="translated">プラグイン JAR ファイルをコンパイラプラグインのクラスパスに追加し、sam-with-receiver アノテーションのリストを指定するだけです。</target>
        </trans-unit>
        <trans-unit id="23faffb10dc95518c4b08d2ccd86868a15d724ef" translate="yes" xml:space="preserve">
          <source>Just as in Java 8, Kotlin now allows to use underscores in numeric literals to separate groups of digits:</source>
          <target state="translated">Java 8と同様に、Kotlinでも数値リテラルの中でアンダースコアを使って数字のグループを区切ることができるようになりました。</target>
        </trans-unit>
        <trans-unit id="884734e755cc6d6bbd1b938aff073932b22e3094" translate="yes" xml:space="preserve">
          <source>Just change the Kotlin version to &lt;code&gt;1.4.0&lt;/code&gt; and re-import your Gradle or Maven project. The IDE will then ask you about migration.</source>
          <target state="translated">Kotlinのバージョンを &lt;code&gt;1.4.0&lt;/code&gt; に変更し、GradleまたはMavenプロジェクトを再インポートするだけです。次に、IDEは移行について尋ねます。</target>
        </trans-unit>
        <trans-unit id="1d8e794cae8b9d9de103c8c7346fbf29e3d8b66f" translate="yes" xml:space="preserve">
          <source>Just like Java 8, Kotlin supports SAM conversions. This means that Kotlin function literals can be automatically converted into implementations of Java interfaces with a single non-default method, as long as the parameter types of the interface method match the parameter types of the Kotlin function.</source>
          <target state="translated">Java 8と同様に、KotlinはSAM変換をサポートしています。つまり、Kotlinの関数リテラルは、インターフェースメソッドのパラメータ型がKotlin関数のパラメータ型と一致する限り、デフォルトではない1つのメソッドでJavaインターフェースの実装に自動的に変換することができます。</target>
        </trans-unit>
        <trans-unit id="949a51b86664f4131dce0e0c1b95750468898210" translate="yes" xml:space="preserve">
          <source>Just like Java and JavaScript, Kotlin supports end-of-line and block comments.</source>
          <target state="translated">JavaやJavaScriptと同様に、Kotlinは行末コメントやブロックコメントをサポートしています。</target>
        </trans-unit>
        <trans-unit id="470dca02756a771de4224b1f3a4e099fc973e2f5" translate="yes" xml:space="preserve">
          <source>Just like Java's anonymous inner classes, code in object expressions can access variables from the enclosing scope. (Unlike Java, this is not restricted to final or effectively final variables.)</source>
          <target state="translated">Javaの匿名内部クラスと同様に、オブジェクト式のコードは、囲んだスコープから変数にアクセスすることができます。(Javaとは異なり、これは最終的な変数や事実上の最終的な変数には限定されません)。</target>
        </trans-unit>
        <trans-unit id="52bd785fc290723ed0a2f51dcda0df34f29bb395" translate="yes" xml:space="preserve">
          <source>Just like in Java, a special case is the &lt;code&gt;value&lt;/code&gt; parameter; its value can be specified without an explicit name:</source>
          <target state="translated">Javaと同様に、特殊なケースは &lt;code&gt;value&lt;/code&gt; パラメーターです。その値は明示的な名前なしで指定できます：</target>
        </trans-unit>
        <trans-unit id="56e17eda787fc8a6435c74f86b6d7baef2f4cc5c" translate="yes" xml:space="preserve">
          <source>Just like in Java, enum classes in Kotlin have synthetic methods allowing to list the defined enum constants and to get an enum constant by its name. The signatures of these methods are as follows (assuming the name of the enum class is &lt;code&gt;EnumClass&lt;/code&gt;):</source>
          <target state="translated">Javaと同じように、Kotlinの列挙型クラスには、定義済みの列挙型定数をリストし、その名前で列挙型定数を取得できる合成メソッドがあります。これらのメソッドのシグネチャは次のとおりです（列挙型クラスの名前が &lt;code&gt;EnumClass&lt;/code&gt; であると想定）。</target>
        </trans-unit>
        <trans-unit id="087fe94dcb6ae8bf0df1e1981129ddf1a93236a7" translate="yes" xml:space="preserve">
          <source>Just like most modern languages, Kotlin supports single-line (or &lt;em&gt;end-of-line&lt;/em&gt;) and multi-line (&lt;em&gt;block&lt;/em&gt;) comments.</source>
          <target state="translated">最新のほとんどの言語と同様に、Kotlinは単一行（または&lt;em&gt;行末&lt;/em&gt;）および複数行（&lt;em&gt;ブロック&lt;/em&gt;）コメントをサポートします。</target>
        </trans-unit>
        <trans-unit id="9137e7255bdeb308d1bb811a9d7f200fe163b672" translate="yes" xml:space="preserve">
          <source>Just like regular members of the companion object, they can be called using only the class name as the qualifier:</source>
          <target state="translated">コンパニオン・オブジェクトの通常のメンバと同様に、クラス名のみを修飾子として使用して呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="27573ad44b2952298adae482665b1d05330c84b0" translate="yes" xml:space="preserve">
          <source>Just like the &lt;a href=&quot;../../../api/latest/jvm/stdlib/kotlin.sequences/zip&quot;&gt;Sequence.zip&lt;/a&gt; extension function in the Kotlin standard library, flows have a &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/zip.html&quot;&gt;zip&lt;/a&gt; operator that combines the corresponding values of two flows:</source>
          <target state="translated">Kotlin標準ライブラリの&lt;a href=&quot;../../../api/latest/jvm/stdlib/kotlin.sequences/zip&quot;&gt;Sequence.zip&lt;/a&gt;拡張関数と同様に、フローには2つのフローの対応する値を組み合わせる&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/zip.html&quot;&gt;zip&lt;/a&gt;演算子があります。</target>
        </trans-unit>
        <trans-unit id="0848ea7d6dc0355eb57cb3d83744477db1fa4d97" translate="yes" xml:space="preserve">
          <source>Just like with JavaDoc, KDoc comments start with &lt;code&gt;/**&lt;/code&gt; and end with &lt;code&gt;*/&lt;/code&gt;. Every line of the comment may begin with an asterisk, which is not considered part of the contents of the comment.</source>
          <target state="translated">JavaDocと同様に、KDocコメントは &lt;code&gt;/**&lt;/code&gt; で始まり、 &lt;code&gt;*/&lt;/code&gt; で終わります。コメントのすべての行はアスタリスクで始まる場合がありますが、これはコメントの内容の一部とは見なされません。</target>
        </trans-unit>
        <trans-unit id="d4d2de8b4148383d16c153caa1ed915e8e3e98f8" translate="yes" xml:space="preserve">
          <source>JvmDefault</source>
          <target state="translated">JvmDefault</target>
        </trans-unit>
        <trans-unit id="8d8475b40c0c838717c002d3eb803f88fd28b448" translate="yes" xml:space="preserve">
          <source>JvmDefaultWithoutCompatibility</source>
          <target state="translated">JvmDefaultWithoutCompatibility</target>
        </trans-unit>
        <trans-unit id="692baf8c605cdd872f8ac1b51f0db35d878fa6ec" translate="yes" xml:space="preserve">
          <source>JvmField</source>
          <target state="translated">JvmField</target>
        </trans-unit>
        <trans-unit id="8cafb887c2be5267183d19409f4ac9f885353c0a" translate="yes" xml:space="preserve">
          <source>JvmMultifileClass</source>
          <target state="translated">JvmMultifileClass</target>
        </trans-unit>
        <trans-unit id="2033eae859b01f53e2d78af856c5c34461b71b90" translate="yes" xml:space="preserve">
          <source>JvmName</source>
          <target state="translated">JvmName</target>
        </trans-unit>
        <trans-unit id="311d71c3b3f54390c29adff749b3edbb6a494b4a" translate="yes" xml:space="preserve">
          <source>JvmOverloads</source>
          <target state="translated">JvmOverloads</target>
        </trans-unit>
        <trans-unit id="747778441d808007d459844a0415514317ff72b7" translate="yes" xml:space="preserve">
          <source>JvmStatic</source>
          <target state="translated">JvmStatic</target>
        </trans-unit>
        <trans-unit id="6bc8e12710c62fe36d0378462ee3b1c664cd3300" translate="yes" xml:space="preserve">
          <source>JvmSuppressWildcards</source>
          <target state="translated">JvmSuppressWildcards</target>
        </trans-unit>
        <trans-unit id="a351df29143ba3c04cf22dc294f311273bb9b60f" translate="yes" xml:space="preserve">
          <source>JvmSynthetic</source>
          <target state="translated">JvmSynthetic</target>
        </trans-unit>
        <trans-unit id="85e086e57dc0c9b8c2d108ccec8876b36768e9b7" translate="yes" xml:space="preserve">
          <source>JvmWildcard</source>
          <target state="translated">JvmWildcard</target>
        </trans-unit>
        <trans-unit id="7d24ba100f0e49fea8997c1580577eea18ef483a" translate="yes" xml:space="preserve">
          <source>KAPT: Names of synthetic &lt;code&gt;$annotations()&lt;/code&gt; methods for properties have changed</source>
          <target state="translated">KAPT：プロパティの合成 &lt;code&gt;$annotations()&lt;/code&gt; Annotations （）メソッドの名前が変更されました</target>
        </trans-unit>
        <trans-unit id="269b4c8f67d4bef3fb8e55e7c16a561a21d1145a" translate="yes" xml:space="preserve">
          <source>KAnnotatedElement</source>
          <target state="translated">KAnnotatedElement</target>
        </trans-unit>
        <trans-unit id="2380c006605522b5d08a2ee817a1eaa70c3eee66" translate="yes" xml:space="preserve">
          <source>KCallable</source>
          <target state="translated">KCallable</target>
        </trans-unit>
        <trans-unit id="638ba738d7801f4caebfacfc6daada8a29efaa3c" translate="yes" xml:space="preserve">
          <source>KClass</source>
          <target state="translated">KClass</target>
        </trans-unit>
        <trans-unit id="fab281a5b19ac7d1db397f74e48d5b9b12cc8340" translate="yes" xml:space="preserve">
          <source>KClass.cast</source>
          <target state="translated">KClass.cast</target>
        </trans-unit>
        <trans-unit id="acf5de634c6435ff94d10fad8e77c31d4afdb216" translate="yes" xml:space="preserve">
          <source>KClass.isInstance</source>
          <target state="translated">KClass.isInstance</target>
        </trans-unit>
        <trans-unit id="0eb6eed766c7bf5a996d5d184bea9e1688094497" translate="yes" xml:space="preserve">
          <source>KClass.safeCast</source>
          <target state="translated">KClass.safeCast</target>
        </trans-unit>
        <trans-unit id="64fa1008f290c0ccc3cc7c6ea0be14a5730d8c96" translate="yes" xml:space="preserve">
          <source>KClassifier</source>
          <target state="translated">KClassifier</target>
        </trans-unit>
        <trans-unit id="79b222c243d152a61ff297964121af433061592b" translate="yes" xml:space="preserve">
          <source>KClassifier.createType</source>
          <target state="translated">KClassifier.createType</target>
        </trans-unit>
        <trans-unit id="20cb65ed76161cb0b2be5e7c93b9d81ef134450b" translate="yes" xml:space="preserve">
          <source>KDeclarationContainer</source>
          <target state="translated">KDeclarationContainer</target>
        </trans-unit>
        <trans-unit id="7bf1a6c1fa5dce180803fdb8c3400d5e981f7201" translate="yes" xml:space="preserve">
          <source>KDoc Syntax</source>
          <target state="translated">KDoc構文</target>
        </trans-unit>
        <trans-unit id="7d4c77574d0b857a214718597dca35a72ce59ec3" translate="yes" xml:space="preserve">
          <source>KDoc currently supports the following block tags:</source>
          <target state="translated">KDocは現在、以下のブロックタグをサポートしています。</target>
        </trans-unit>
        <trans-unit id="fae5be3a00cdb97c4b5aa9435d19be927a5665ba" translate="yes" xml:space="preserve">
          <source>KDoc does not support the &lt;code&gt;@deprecated&lt;/code&gt; tag. Instead, please use the &lt;code&gt;@Deprecated&lt;/code&gt; annotation.</source>
          <target state="translated">KDocは &lt;code&gt;@deprecated&lt;/code&gt; タグをサポートしていません。代わりに、 &lt;code&gt;@Deprecated&lt;/code&gt; アノテーションを使用してください。</target>
        </trans-unit>
        <trans-unit id="343a3fd44d3f90b682e5b8542c76a1c8f0dc43bf" translate="yes" xml:space="preserve">
          <source>KDoc syntax</source>
          <target state="translated">KDoc構文</target>
        </trans-unit>
        <trans-unit id="cf7f75d8adb5a4855b94e1806ea4b9da20753a2a" translate="yes" xml:space="preserve">
          <source>KFunction</source>
          <target state="translated">KFunction</target>
        </trans-unit>
        <trans-unit id="ed5e1b52600600ea74e498fffdc8c815085f7d28" translate="yes" xml:space="preserve">
          <source>KLib binaries</source>
          <target state="translated">KLibバイナリ</target>
        </trans-unit>
        <trans-unit id="351228c4e54d9346ab6c9f3124cf8905349ef3f6" translate="yes" xml:space="preserve">
          <source>KMutableProperty</source>
          <target state="translated">KMutableProperty</target>
        </trans-unit>
        <trans-unit id="b8079b1b2c0efc81f1810eda68de2b7cfe28211b" translate="yes" xml:space="preserve">
          <source>KMutableProperty0</source>
          <target state="translated">KMutableProperty0</target>
        </trans-unit>
        <trans-unit id="ee64a1ab548503607558b0ae24255a9fb8d1bf97" translate="yes" xml:space="preserve">
          <source>KMutableProperty1</source>
          <target state="translated">KMutableProperty1</target>
        </trans-unit>
        <trans-unit id="b5a2a8a013bdb0ae3b43fd0eedfa92a1c579f8b7" translate="yes" xml:space="preserve">
          <source>KMutableProperty2</source>
          <target state="translated">KMutableProperty2</target>
        </trans-unit>
        <trans-unit id="3b161212f1754e4e1f54c5dee3fdb112a6efcc79" translate="yes" xml:space="preserve">
          <source>KParameter</source>
          <target state="translated">KParameter</target>
        </trans-unit>
        <trans-unit id="47dc03443aa940939b9abccc2588997b2fd72705" translate="yes" xml:space="preserve">
          <source>KProperty</source>
          <target state="translated">KProperty</target>
        </trans-unit>
        <trans-unit id="7c65965ff00632a4a27df6d2ccf39af470a5196a" translate="yes" xml:space="preserve">
          <source>KProperty0</source>
          <target state="translated">KProperty0</target>
        </trans-unit>
        <trans-unit id="8baedb2820a644b389145928c1658d83b9918bc5" translate="yes" xml:space="preserve">
          <source>KProperty1</source>
          <target state="translated">KProperty1</target>
        </trans-unit>
        <trans-unit id="8bf91abab2e2266a64dcd908bc6e070ddbaf118e" translate="yes" xml:space="preserve">
          <source>KProperty1.getDelegate</source>
          <target state="translated">KProperty1.getDelegate</target>
        </trans-unit>
        <trans-unit id="d8609e0c5b369de4819d2e07e76fd6ed37986905" translate="yes" xml:space="preserve">
          <source>KProperty2</source>
          <target state="translated">KProperty2</target>
        </trans-unit>
        <trans-unit id="fd138efe2eefe64c683fdbac01b4ebe15e42c11f" translate="yes" xml:space="preserve">
          <source>KProperty2.getDelegate</source>
          <target state="translated">KProperty2.getDelegate</target>
        </trans-unit>
        <trans-unit id="cddedd34830292c250dc6df0c7292dd170403bdb" translate="yes" xml:space="preserve">
          <source>KType</source>
          <target state="translated">KType</target>
        </trans-unit>
        <trans-unit id="f3764cdd111b81b5f82e469014413398559a3a69" translate="yes" xml:space="preserve">
          <source>KTypeParameter</source>
          <target state="translated">KTypeParameter</target>
        </trans-unit>
        <trans-unit id="a52a8fe183ee882846ec18218986d60cbd8b9caa" translate="yes" xml:space="preserve">
          <source>KTypeParameter.variance</source>
          <target state="translated">KTypeParameter.variance</target>
        </trans-unit>
        <trans-unit id="541ac7b02574ef282f5fea0a7caa24f963767d58" translate="yes" xml:space="preserve">
          <source>KTypeProjection</source>
          <target state="translated">KTypeProjection</target>
        </trans-unit>
        <trans-unit id="453bbaf5b6df4218f396acb7d784d58647332cd3" translate="yes" xml:space="preserve">
          <source>KVariance</source>
          <target state="translated">KVariance</target>
        </trans-unit>
        <trans-unit id="540dc0ef81ec2a035fa8eb530610a94d10ceaf33" translate="yes" xml:space="preserve">
          <source>KVisibility</source>
          <target state="translated">KVisibility</target>
        </trans-unit>
        <trans-unit id="89ee95ab7caa6f00ebf6ba552593878d5c2b4d1a" translate="yes" xml:space="preserve">
          <source>Kapt can generate Kotlin sources. Just write the generated Kotlin source files to the directory specified by &lt;code&gt;processingEnv.options[&quot;kapt.kotlin.generated&quot;]&lt;/code&gt;, and these files will be compiled together with the main sources.</source>
          <target state="translated">KaptはKotlinソースを生成できます。生成されたKotlinソースファイルを &lt;code&gt;processingEnv.options[&quot;kapt.kotlin.generated&quot;]&lt;/code&gt; で指定されたディレクトリに書き込むだけで、これらのファイルがメインソースとともにコンパイルされます。</target>
        </trans-unit>
        <trans-unit id="115c000133ca0eeaa296737859925189dceee8bb" translate="yes" xml:space="preserve">
          <source>Kapt compiler plugin is available in the binary distribution of the Kotlin compiler.</source>
          <target state="translated">Kapt コンパイラプラグインは Kotlin コンパイラのバイナリディストリビューションで利用できます。</target>
        </trans-unit>
        <trans-unit id="d2790ed7723277b25aa2209903904a8c31657160" translate="yes" xml:space="preserve">
          <source>Kapt uses Java compiler to run annotation processors.</source>
          <target state="translated">Kaptはアノテーションプロセッサを実行するためにJavaコンパイラを使用しています。</target>
        </trans-unit>
        <trans-unit id="ec688ce3d89067940f46fd29a7ea54660b831823" translate="yes" xml:space="preserve">
          <source>Keep in mind that this is just syntactic sugar - you're not actually modifying the class or its instances. Therefore, you have to import an extension function/property wherever you want to use it (since it isn't carried along with the instances of the class). For the same reason, you can not override extension members - you can reimplement them for subtypes, but the resolution happens at compile-time based on the static type of the expression you're invoking it on. So if you declare an extension function for &lt;code&gt;Vehicle&lt;/code&gt;, and one with the same name and signature for its subclass &lt;code&gt;Car&lt;/code&gt;, and you do the following, it's the extension function on &lt;code&gt;Vehicle&lt;/code&gt; that will be called, even though &lt;code&gt;v&lt;/code&gt; is really a &lt;code&gt;Car&lt;/code&gt;:</source>
          <target state="translated">これは単なる構文上の砂糖であることを覚えておいてください。実際にクラスやそのインスタンスを変更するわけではありません。したがって、拡張関数/プロパティは、それを使用したい場所にインポートする必要があります（クラスのインスタンスと一緒に実行されないため）。同じ理由で、拡張メンバーをオーバーライドすることはできません。サブタイプ用に拡張メンバーを再実装できますが、解決は、呼び出している式の静的タイプに基づいてコンパイル時に行われます。したがって、 &lt;code&gt;Vehicle&lt;/code&gt; の拡張関数を宣言し、そのサブクラス &lt;code&gt;Car&lt;/code&gt; の名前とシグネチャが同じである関数を次のように宣言すると、 &lt;code&gt;v&lt;/code&gt; は実際には &lt;code&gt;Car&lt;/code&gt; ですが、呼び出されるのは &lt;code&gt;Vehicle&lt;/code&gt; の拡張関数です。</target>
        </trans-unit>
        <trans-unit id="18218cc9fd8c5aa995704dae391402dc208f9851" translate="yes" xml:space="preserve">
          <source>Keep the language modern over the years.</source>
          <target state="translated">何年もかけて言葉を現代的なものにしましょう。</target>
        </trans-unit>
        <trans-unit id="07ccea1c92ddb53422b1f7f7120a95adacb8fcf2" translate="yes" xml:space="preserve">
          <source>Keeping whole packages or modules from elimination can prevent DCE from removing many unused declarations. Because of this, it is preferable to select individual declarations which should be excluded from DCE one by one.</source>
          <target state="translated">パッケージやモジュール全体を除外しないようにしておくと、DCEから多くの未使用の宣言を除外することができなくなることがあります。このため、DCEから除外すべき個々の宣言を一つずつ選択することが望ましい。</target>
        </trans-unit>
        <trans-unit id="428b07e8e32e536ccaf4d9521cd95cadbf7fb10f" translate="yes" xml:space="preserve">
          <source>Keepsafe's App Lock app has also been &lt;a href=&quot;https://medium.com/keepsafe-engineering/lessons-from-converting-an-app-to-100-kotlin-68984a05dcb6&quot;&gt;converted to 100% Kotlin&lt;/a&gt;, leading to a 30% decrease in source line count and 10% decrease in method count.</source>
          <target state="translated">KeepsafeのApp Lockアプリも&lt;a href=&quot;https://medium.com/keepsafe-engineering/lessons-from-converting-an-app-to-100-kotlin-68984a05dcb6&quot;&gt;100％Kotlinに変換され&lt;/a&gt;、ソース行数が30％、メソッド数が10％減少しました。</target>
        </trans-unit>
        <trans-unit id="c67dd20ee842986086a0a915ddc2a279490130ed" translate="yes" xml:space="preserve">
          <source>Key</source>
          <target state="translated">Key</target>
        </trans-unit>
        <trans-unit id="4529f1f2ec7b60606af93bf0af48f282ccf9e92f" translate="yes" xml:space="preserve">
          <source>Key for the elements of &lt;a href=&quot;index&quot;&gt;CoroutineContext&lt;/a&gt;. &lt;a href=&quot;-key#E&quot;&gt;E&lt;/a&gt; is a type of element with this key.</source>
          <target state="translated">&lt;a href=&quot;index&quot;&gt;CoroutineContext&lt;/a&gt;の要素のキー。&lt;a href=&quot;-key#E&quot;&gt;E&lt;/a&gt;は、このキーを持つ要素のタイプです。</target>
        </trans-unit>
        <trans-unit id="14a72bb7f1422b3f859b664b3562ae101c3c66b5" translate="yes" xml:space="preserve">
          <source>Key for the elements of &lt;a href=&quot;index&quot;&gt;CoroutineContext&lt;/a&gt;. &lt;a href=&quot;-key#E&quot;&gt;E&lt;/a&gt; is a type of element with this key. Keys in the context are compared &lt;em&gt;by reference&lt;/em&gt;.</source>
          <target state="translated">&lt;a href=&quot;index&quot;&gt;CoroutineContext&lt;/a&gt;の要素のキー。&lt;a href=&quot;-key#E&quot;&gt;E&lt;/a&gt;は、このキーを持つ要素のタイプです。コンテキスト内のキーは&lt;em&gt;参照によって&lt;/em&gt;比較&lt;em&gt;されます&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="7dea00f8bb18a0d2f420e398a89ddb4931a962cc" translate="yes" xml:space="preserve">
          <source>KeyboardEventInit</source>
          <target state="translated">KeyboardEventInit</target>
        </trans-unit>
        <trans-unit id="12698e3202bea6e77c14cc7645aefe1f40b4a95b" translate="yes" xml:space="preserve">
          <source>Keywords and Operators</source>
          <target state="translated">キーワードと演算子</target>
        </trans-unit>
        <trans-unit id="e00ac23f2ac2ff73ad4f3c4b263d6c5bbfb80190" translate="yes" xml:space="preserve">
          <source>Kind</source>
          <target state="translated">Kind</target>
        </trans-unit>
        <trans-unit id="6d7060b8f0b142e9cc5d99251ae9bfc8344b5cdb" translate="yes" xml:space="preserve">
          <source>Kind of a module generated by compiler</source>
          <target state="translated">コンパイラで生成されるモジュールの種類</target>
        </trans-unit>
        <trans-unit id="1d34a603bd791899c80e1dbe11daaee6bb135493" translate="yes" xml:space="preserve">
          <source>Kind of this parameter.</source>
          <target state="translated">このパラメータの種類。</target>
        </trans-unit>
        <trans-unit id="b295237940a339c9b3b99ec9fc0619f9bc3cd8b9" translate="yes" xml:space="preserve">
          <source>Kind represents a particular position of the parameter declaration in the source code, such as an instance, an extension receiver parameter or a value parameter.</source>
          <target state="translated">種類は、インスタンス、拡張レシーバ・パラメータ、値パラメータなど、ソース・コード内のパラメータ宣言の特定の位置を表します。</target>
        </trans-unit>
        <trans-unit id="b05203cf89b60eb36609a1a8b7f3cafe0927486a" translate="yes" xml:space="preserve">
          <source>Known issues</source>
          <target state="translated">既知の問題</target>
        </trans-unit>
        <trans-unit id="7205eb983ba710302eb6c62f19abead98485f315" translate="yes" xml:space="preserve">
          <source>Koans</source>
          <target state="translated">Koans</target>
        </trans-unit>
        <trans-unit id="cff7933a49bb6d767f24e765c4887a762a5f9c00" translate="yes" xml:space="preserve">
          <source>Konan_js_getProperty</source>
          <target state="translated">Konan_js_getProperty</target>
        </trans-unit>
        <trans-unit id="4b97a1cc4cde2d848838f0605a552d5704eea24b" translate="yes" xml:space="preserve">
          <source>Kotlin</source>
          <target state="translated">Kotlin</target>
        </trans-unit>
        <trans-unit id="ce2c3a212ddf8e8e1152459e5ba603b0e8d0abe9" translate="yes" xml:space="preserve">
          <source>Kotlin 1.1 introduced coroutines, a new way of writing asynchronous, non-blocking code (and much more). In this tutorial we will go through some basics of using Kotlin coroutines with the help of the &lt;code&gt;kotlinx.coroutines&lt;/code&gt; library, which is a collection of helpers and wrappers for existing Java libraries.</source>
          <target state="translated">Kotlin 1.1はコルーチンを導入しました。これは、非同期の非ブロッキングコード（およびその他）を記述する新しい方法です。このチュートリアルでは、既存のJavaライブラリのヘルパーとラッパーのコレクションである &lt;code&gt;kotlinx.coroutines&lt;/code&gt; ライブラリを使用して、Kotlinコルーチンの基本的な使用方法をいくつか説明します。</target>
        </trans-unit>
        <trans-unit id="63575fcf9f53cf161b23b5a5120b649f923aec04" translate="yes" xml:space="preserve">
          <source>Kotlin 1.1 removes some of the restrictions on sealed and data classes that were present in Kotlin 1.0. Now you can define subclasses of a top-level sealed class on the top level in the same file, and not just as nested classes of the sealed class. Data classes can now extend other classes. This can be used to define a hierarchy of expression classes nicely and cleanly:</source>
          <target state="translated">Kotlin 1.1では、Kotlin 1.0にあった封印されたクラスとデータクラスに関する制限のいくつかが取り除かれました。トップレベルの封印されたクラスのサブクラスを、封印されたクラスのネストされたクラスとしてだけでなく、同じファイル内でトップレベルの封印されたクラスのサブクラスを定義できるようになりました。データクラスは他のクラスを拡張できるようになりました。これにより、式クラスの階層をきれいに定義することができます。</target>
        </trans-unit>
        <trans-unit id="4b689f1de0358fa8de1c1a96775c0c0ab1538fa5" translate="yes" xml:space="preserve">
          <source>Kotlin 1.2 introduces a set of functions for operating with &lt;code&gt;BigInteger&lt;/code&gt; and &lt;code&gt;BigDecimal&lt;/code&gt; and creating them from other numeric types. These are:</source>
          <target state="translated">Kotlin 1.2では、 &lt;code&gt;BigInteger&lt;/code&gt; と &lt;code&gt;BigDecimal&lt;/code&gt; を操作し、他の数値型から作成するための一連の関数が導入されています。これらは：</target>
        </trans-unit>
        <trans-unit id="f18db78c63aaf770b997189868cab88ccb0ebc9f" translate="yes" xml:space="preserve">
          <source>Kotlin 1.3 continues to evolve and improve scripting API, introducing some experimental support for scripts customization, such as adding external properties, providing static or dynamic dependencies, and so on.</source>
          <target state="translated">Kotlin 1.3 はスクリプト API の進化と改善を続けており、外部プロパティの追加、静的または動的な依存関係の提供など、スクリプトのカスタマイズのための実験的なサポートを導入しています。</target>
        </trans-unit>
        <trans-unit id="88e2adace5bac1e48c0adc9ef2ac271c679c842b" translate="yes" xml:space="preserve">
          <source>Kotlin 1.3 continues to improve and polish the Native target. See the &lt;a href=&quot;native-overview&quot;&gt;Kotlin/Native overview&lt;/a&gt; for details.</source>
          <target state="translated">Kotlin 1.3は、ネイティブターゲットの改善と改良を続けています。詳細については、&lt;a href=&quot;native-overview&quot;&gt;Kotlin /ネイティブの概要&lt;/a&gt;をご覧ください。</target>
        </trans-unit>
        <trans-unit id="fb394a79550e8145ec468f60617c81e553701477" translate="yes" xml:space="preserve">
          <source>Kotlin 1.3 introduced a simpler form of &lt;code&gt;main&lt;/code&gt; which takes no parameters. Now &amp;ldquo;Hello, World&amp;rdquo; in Kotlin is 19 characters shorter!</source>
          <target state="translated">Kotlin 1.3では、パラメーターを取らないシンプルな形式の &lt;code&gt;main&lt;/code&gt; が導入されました。Kotlinの「Hello、World」が19文字短くなりました。</target>
        </trans-unit>
        <trans-unit id="bfa732fa62960ffc201f7ae614e12c53ef901915" translate="yes" xml:space="preserve">
          <source>Kotlin 1.3 introduces a new kind of declaration &amp;mdash; &lt;code&gt;inline class&lt;/code&gt;. Inline classes can be viewed as a restricted version of the usual classes, in particular, inline classes must have exactly one property:</source>
          <target state="translated">Kotlin 1.3では、新しい種類の宣言である &lt;code&gt;inline class&lt;/code&gt; が導入されています。インラインクラスは、通常のクラスの制限されたバージョンと見なすことができます。特に、インラインクラスはプロパティを1つだけ持つ必要があります。</target>
        </trans-unit>
        <trans-unit id="32e23fcaa9e8679e7038c793f0f15c69e36b0fe8" translate="yes" xml:space="preserve">
          <source>Kotlin 1.3 introduces callable references on suspend-functions and support of Coroutines in the Reflection API.</source>
          <target state="translated">Kotlin 1.3 では、サスペンド関数の呼び出し可能な参照と Reflection API の Coroutines のサポートが導入されました。</target>
        </trans-unit>
        <trans-unit id="99e7bed5b89ef9affe2aabaa02c6b466182d4674" translate="yes" xml:space="preserve">
          <source>Kotlin 1.3 introduces support for runnable Kotlin &lt;em&gt;scratch files&lt;/em&gt;. &lt;em&gt;Scratch file&lt;/em&gt; is a kotlin script file with a .kts extension which you can run and get evaluation results directly in the editor.</source>
          <target state="translated">Kotlin 1.3では、実行可能なKotlin &lt;em&gt;スクラッチファイルの&lt;/em&gt;サポートが導入されてい&lt;em&gt;ます&lt;/em&gt;。&lt;em&gt;スクラッチファイル&lt;/em&gt;は、拡張子が.ktsのkotlinスクリプトファイルで、エディターで直接実行して評価結果を取得できます。</target>
        </trans-unit>
        <trans-unit id="62694aae6035c5ad4972f2e14bf03a63310cd91a" translate="yes" xml:space="preserve">
          <source>Kotlin 1.3 introduces support for the &lt;a href=&quot;coding-conventions&quot;&gt;recommended code style&lt;/a&gt; in the IDE. Check out &lt;a href=&quot;code-style-migration-guide&quot;&gt;this page&lt;/a&gt; for the migration guidelines.</source>
          <target state="translated">Kotlin 1.3では、IDEで&lt;a href=&quot;coding-conventions&quot;&gt;推奨されるコードスタイルの&lt;/a&gt;サポートが導入されています。チェックアウト&lt;a href=&quot;code-style-migration-guide&quot;&gt;このページを&lt;/a&gt;移行ガイドラインについて。</target>
        </trans-unit>
        <trans-unit id="dae614ce706dcca5f69b1c3253fcc5bc2a15bada" translate="yes" xml:space="preserve">
          <source>Kotlin 1.3 introduces unsigned integer types:</source>
          <target state="translated">Kotlin 1.3では符号なし整数型が導入されました。</target>
        </trans-unit>
        <trans-unit id="29c35fc143ca98d825aae2e4d6224d719799d607" translate="yes" xml:space="preserve">
          <source>Kotlin 1.3 relaxes this limitation and adds support for functions with bigger arity:</source>
          <target state="translated">Kotlin 1.3 ではこの制限が緩和され、より大きなアーティシティを持つ関数のサポートが追加されました。</target>
        </trans-unit>
        <trans-unit id="066cd750e197b01a81e98cd924fadfe8604b9df8" translate="yes" xml:space="preserve">
          <source>Kotlin 1.4 supports more cases for using callable references:</source>
          <target state="translated">Kotlin 1.4では、呼び出し可能な参照を使用するケースが増えました。</target>
        </trans-unit>
        <trans-unit id="5350f6595e85d319ae1e0cc79c4bfec4d9dbf0c3" translate="yes" xml:space="preserve">
          <source>Kotlin 1.4 uses a new, more powerful type inference algorithm. This new algorithm was already available to try in Kotlin 1.3 by specifying a compiler option, and now it&amp;rsquo;s used by default. You can find the full list of issues fixed in the new algorithm in &lt;a href=&quot;https://youtrack.jetbrains.com/issues/KT?q=Tag:%20fixed-in-new-inference%20&quot;&gt;YouTrack&lt;/a&gt;. Here you can find some of the most noticeable improvements:</source>
          <target state="translated">Kotlin 1.4は、新しい、より強力な型推論アルゴリズムを使用しています。この新しいアルゴリズムは、コンパイラオプションを指定することで、Kotlin 1.3ですでに使用可能でしたが、現在はデフォルトで使用されています。&lt;a href=&quot;https://youtrack.jetbrains.com/issues/KT?q=Tag:%20fixed-in-new-inference%20&quot;&gt;YouTrackの&lt;/a&gt;新しいアルゴリズムで修正された問題の完全なリストを見つけることができます。ここでは、最も顕著な改善点のいくつかを見つけることができます。</target>
        </trans-unit>
        <trans-unit id="2bc80b855b0a3b819dba3841d64e1cfc7470a8c4" translate="yes" xml:space="preserve">
          <source>Kotlin 1.4.0 adds &lt;code&gt;module-info.java&lt;/code&gt; module information to default standard library artifacts. This lets you use them with &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/tools/jlink.html&quot;&gt;&lt;strong&gt;jlink&lt;/strong&gt; tool&lt;/a&gt;, which generates custom Java runtime images containing only the platform modules that are required for your app. You could already use jlink with Kotlin standard library artifacts, but you had to use separate artifacts to do so &amp;ndash; the ones with the &amp;ldquo;modular&amp;rdquo; classifier &amp;ndash; and the whole setup wasn&amp;rsquo;t straightforward.</source>
          <target state="translated">Kotlin 1.4.0は、 &lt;code&gt;module-info.java&lt;/code&gt; モジュール情報をデフォルトの標準ライブラリアーティファクトに追加します。これにより、アプリに必要なプラットフォームモジュールのみを含むカスタムJavaランタイムイメージを生成する&lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/tools/jlink.html&quot;&gt;&lt;strong&gt;jlink&lt;/strong&gt;ツール&lt;/a&gt;でそれらを使用できます。Kotlin標準ライブラリアーティファクトでjlinkを使用することはできますが、そのためには個別のアーティファクト（「モジュラー」分類子を使用するアーティファクト）を使用する必要があり、セットアップ全体が簡単ではありませんでした。</target>
        </trans-unit>
        <trans-unit id="0378da784d7afe2b6f5df83cd22d948f8f205d9b" translate="yes" xml:space="preserve">
          <source>Kotlin 1.4.0 comes with a variety of different language features and improvements. They include:</source>
          <target state="translated">Kotlin 1.4.0 には様々な言語機能と改善が含まれています。その中には以下が含まれています。</target>
        </trans-unit>
        <trans-unit id="95c73be7140ebf78f98979e2eca4cd593ef933ad" translate="yes" xml:space="preserve">
          <source>Kotlin 1.4.0 comes with lots of features and improvements in the tooling for multiplatform programming. Some of them just work out of the box on existing projects, and some require additional configuration steps. This guide will help you migrate your multiplatform projects to 1.4.0 and get the benefits of all its new features.</source>
          <target state="translated">Kotlin 1.4.0 には、マルチプラットフォームプログラミングのためのツールに多くの機能と改良が加えられています。その中には、既存のプロジェクトですぐに使えるものもあれば、追加の設定が必要なものもあります。このガイドでは、マルチプラットフォームプロジェクトを 1.4.0 に移行し、その新機能の恩恵を受けるための手助けをします。</target>
        </trans-unit>
        <trans-unit id="9e7a073ad0548ea1abeb025f0d02a8940c8b2833" translate="yes" xml:space="preserve">
          <source>Kotlin 1.4.0 does not provide a public API for such extensions yet, but we are working closely with our partners, including &lt;a href=&quot;https://developer.android.com/jetpack/compose&quot;&gt;Jetpack Compose&lt;/a&gt;, who are already building their compiler plugins using our new backend.</source>
          <target state="translated">Kotlin 1.4.0は、このような拡張機能のパブリックAPIをまだ提供していませんが、新しいバックエンドを使用してコンパイラプラグインを既に構築している&lt;a href=&quot;https://developer.android.com/jetpack/compose&quot;&gt;JetpackCompose&lt;/a&gt;などのパートナーと緊密に連携しています。</target>
        </trans-unit>
        <trans-unit id="119bb4e318a0a5c97768f9b15754a1c8be59df76" translate="yes" xml:space="preserve">
          <source>Kotlin 1.4.0 includes a number of JVM-specific improvements, such as:</source>
          <target state="translated">Kotlin 1.4.0 には、以下のような JVM 固有の改善点が多数含まれています。</target>
        </trans-unit>
        <trans-unit id="56b88cbfefbff762c9e5fd3f41575d2d7448be9e" translate="yes" xml:space="preserve">
          <source>Kotlin 1.4.0 introduces the Alpha IR compiler for Kotlin/JS. For more detailed information about the Kotlin/JS IR compiler&amp;rsquo;s backend and how to configure it, consult the &lt;a href=&quot;js-ir-compiler&quot;&gt;documentation&lt;/a&gt;.</source>
          <target state="translated">Kotlin 1.4.0では、Kotlin / JS用のAlphaIRコンパイラが導入されています。Kotlin / JS IRコンパイラのバックエンドとその設定方法の詳細については、&lt;a href=&quot;js-ir-compiler&quot;&gt;ドキュメントを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="fab6809ce8d845633ec216cd46b20c0f5a989761" translate="yes" xml:space="preserve">
          <source>Kotlin &lt;code&gt;Any&lt;/code&gt; type</source>
          <target state="translated">Kotlin &lt;code&gt;Any&lt;/code&gt; タイプ</target>
        </trans-unit>
        <trans-unit id="1e0b4419e56e01f176b70724da2be7f1570af7d9" translate="yes" xml:space="preserve">
          <source>Kotlin &lt;code&gt;String&lt;/code&gt; type</source>
          <target state="translated">Kotlin &lt;code&gt;String&lt;/code&gt; 型</target>
        </trans-unit>
        <trans-unit id="e0c3f493c89be1b94503fdc3f47d5c69cab752c8" translate="yes" xml:space="preserve">
          <source>Kotlin &lt;code&gt;inline&lt;/code&gt; classes</source>
          <target state="translated">Kotlin &lt;code&gt;inline&lt;/code&gt; クラス</target>
        </trans-unit>
        <trans-unit id="c6f908927df8b995d9d09ec9bb214acf154074cf" translate="yes" xml:space="preserve">
          <source>Kotlin &lt;code&gt;interface&lt;/code&gt; types</source>
          <target state="translated">Kotlin &lt;code&gt;interface&lt;/code&gt; タイプ</target>
        </trans-unit>
        <trans-unit id="efe980e61f0d5167fc83d8f145a3ab77bfa2773d" translate="yes" xml:space="preserve">
          <source>Kotlin &lt;code&gt;object Object&lt;/code&gt; is accessible as &lt;code&gt;kotlin.root.example.Object&lt;/code&gt;. There is the &lt;code&gt;_instance&lt;/code&gt; function to get the only instance of the object.</source>
          <target state="translated">Kotlin &lt;code&gt;object Object&lt;/code&gt; は、 &lt;code&gt;kotlin.root.example.Object&lt;/code&gt; としてアクセスできます。オブジェクトの唯一のインスタンスを取得する &lt;code&gt;_instance&lt;/code&gt; 関数があります。</target>
        </trans-unit>
        <trans-unit id="0c1eb8d6dc73bce62ae72ba95f8c60b359816283" translate="yes" xml:space="preserve">
          <source>Kotlin Android Extensions</source>
          <target state="translated">Kotlin Android拡張機能</target>
        </trans-unit>
        <trans-unit id="7ffa31859972ce0a8778bfbe6687b81f154ab790" translate="yes" xml:space="preserve">
          <source>Kotlin Coding Conventions and IntelliJ IDEA formatter</source>
          <target state="translated">Kotlinコーディング規約とIntelliJ IDEAフォーマッタ</target>
        </trans-unit>
        <trans-unit id="d072d7cbb3d097a577aaa31d4b14236492b51583" translate="yes" xml:space="preserve">
          <source>Kotlin Collections Overview</source>
          <target state="translated">コトリンコレクションの概要</target>
        </trans-unit>
        <trans-unit id="2e918bca9080c65d49a41d94237060bf519ea8e7" translate="yes" xml:space="preserve">
          <source>Kotlin Compiler Options</source>
          <target state="translated">Kotlin コンパイラオプション</target>
        </trans-unit>
        <trans-unit id="e053b5d9a8bf9415ef3c2e418563c34aaf8713f7" translate="yes" xml:space="preserve">
          <source>Kotlin Define</source>
          <target state="translated">コトリンの定義</target>
        </trans-unit>
        <trans-unit id="f0cb9aff4685505b6e4d1a7786d44dbe9c5c78a7" translate="yes" xml:space="preserve">
          <source>Kotlin Educational Plugin</source>
          <target state="translated">Kotlin教育用プラグイン</target>
        </trans-unit>
        <trans-unit id="d2c2322d0e9d4d8a96800bd4df5ea6b0ed7d65ca" translate="yes" xml:space="preserve">
          <source>Kotlin Evolution</source>
          <target state="translated">コトリンの進化</target>
        </trans-unit>
        <trans-unit id="5cd6704a0bf9c9ca5663fc3e713188fc0c5a8b1c" translate="yes" xml:space="preserve">
          <source>Kotlin Examples</source>
          <target state="translated">コトリンの例</target>
        </trans-unit>
        <trans-unit id="37cd15476fbbf200875db0672669c456999520ce" translate="yes" xml:space="preserve">
          <source>Kotlin Gradle plugin 1.3.41 works with Android Gradle Plugin 3.0 and later.</source>
          <target state="translated">Kotlin Gradleプラグイン1.3.41はAndroid Gradleプラグイン3.0以降で動作します。</target>
        </trans-unit>
        <trans-unit id="4cd0aaf87578a00cb3abace9012077865b35012d" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript Overview</source>
          <target state="translated">Kotlin JavaScript の概要</target>
        </trans-unit>
        <trans-unit id="59567d5d08261cc25efe7ed7644a3eac45c8cd4f" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the &lt;a href=&quot;https://fetch.spec.whatwg.org&quot;&gt;W3C fetch API&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://fetch.spec.whatwg.org&quot;&gt;W3CフェッチAPI&lt;/a&gt;用のKotlin JavaScriptラッパー。</target>
        </trans-unit>
        <trans-unit id="89d3498431602c2625879d1556695e73607eefba" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the &lt;a href=&quot;https://www.w3.org/TR/FileAPI/&quot;&gt;W3C file API&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.w3.org/TR/FileAPI/&quot;&gt;W3CファイルAPI&lt;/a&gt;用のKotlin JavaScriptラッパー。</target>
        </trans-unit>
        <trans-unit id="87540457cfa4e684d01ade1be4ff2d537b4f72fb" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the &lt;a href=&quot;https://www.w3.org/TR/XMLHttpRequest/&quot;&gt;XMLHttpRequest API&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.w3.org/TR/XMLHttpRequest/&quot;&gt;XMLHttpRequest APIの&lt;/a&gt; Kotlin JavaScriptラッパー。</target>
        </trans-unit>
        <trans-unit id="e6596f2dab21e4e3036fba3783d7f4c0fbb0bb5f" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the &lt;a href=&quot;https://www.w3.org/TR/navigation-timing/&quot;&gt;Navigation Timing API&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.w3.org/TR/navigation-timing/&quot;&gt;Navigation Timing APIの&lt;/a&gt; Kotlin JavaScriptラッパー。</target>
        </trans-unit>
        <trans-unit id="449720a2299361e4c4ce93870004ed0025bd08d4" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the &lt;a href=&quot;https://www.w3.org/TR/notifications/&quot;&gt;Web Notifications API&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.w3.org/TR/notifications/&quot;&gt;Web通知API&lt;/a&gt;用のKotlin JavaScriptラッパー。</target>
        </trans-unit>
        <trans-unit id="273f94ff92211232696d0bb0cccbbaefd99d6ca2" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the &lt;a href=&quot;https://www.w3.org/TR/workers/&quot;&gt;Web Workers API&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.w3.org/TR/workers/&quot;&gt;Web Workers API&lt;/a&gt;用のKotlin JavaScriptラッパー。</target>
        </trans-unit>
        <trans-unit id="60b8cb21a679faec431a00498befc15353dcf7ae" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the DOM API.</source>
          <target state="translated">DOM API 用の Kotlin JavaScript ラッパーです。</target>
        </trans-unit>
        <trans-unit id="510e862b2092dfc113c9c6425e75519b326f41d7" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the DOM CSS API.</source>
          <target state="translated">DOM CSS API 用の Kotlin JavaScript ラッパーです。</target>
        </trans-unit>
        <trans-unit id="f801c6554f4b1898140dcdff66b0ae475172001f" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the DOM SVG API.</source>
          <target state="translated">DOM SVG API 用の Kotlin JavaScript ラッパーです。</target>
        </trans-unit>
        <trans-unit id="ac97493032ddcd8ea7ab49e6704871e5d4e02a32" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the DOM URL API.</source>
          <target state="translated">DOM URL API 用の Kotlin JavaScript ラッパーです。</target>
        </trans-unit>
        <trans-unit id="632516fede4eb8d78a61753d5a6b557583fae63f" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the DOM events API.</source>
          <target state="translated">DOM イベント API 用の Kotlin JavaScript ラッパーです。</target>
        </trans-unit>
        <trans-unit id="9961d958d00f28d74f54365fb789a0a4c6ef0a4a" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the DOM parsing API.</source>
          <target state="translated">DOM 解析 API 用の Kotlin JavaScript ラッパーです。</target>
        </trans-unit>
        <trans-unit id="1124adb3f39b71dbc17459b09b1abc27195f61e8" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the WebGL API.</source>
          <target state="translated">WebGL API用のKotlin JavaScriptラッパーです。</target>
        </trans-unit>
        <trans-unit id="c722e55da392cbca2ad7039aefd4506956b7b45a" translate="yes" xml:space="preserve">
          <source>Kotlin Koans</source>
          <target state="translated">コトリンコーン</target>
        </trans-unit>
        <trans-unit id="8d8f55606ab1553a327fba954030ef9e92582959" translate="yes" xml:space="preserve">
          <source>Kotlin Koans are a series of exercises to get you familiar with the Kotlin Syntax. Each exercise is created as a failing unit test and your job is to make it pass. You can work with Kotlin Koans in one of following two ways:</source>
          <target state="translated">Kotlin Koans は Kotlin 構文に慣れるための一連の練習問題です。それぞれの練習問題は失敗するユニットテストとして作成されており、あなたの仕事はそれを合格させることです。Kotlin Koansを使うには、以下の2つの方法があります。</target>
        </trans-unit>
        <trans-unit id="409a3dab696a4f7e601ab24128dac2f50d01d468" translate="yes" xml:space="preserve">
          <source>Kotlin Multiplatform</source>
          <target state="translated">Kotlin マルチプラットフォーム</target>
        </trans-unit>
        <trans-unit id="8c495a5c1562a573edd3b920fba276a2422fbf84" translate="yes" xml:space="preserve">
          <source>Kotlin Multiplatform Gradle DSL Reference</source>
          <target state="translated">Kotlin マルチプラットフォーム Gradle DSL リファレンス</target>
        </trans-unit>
        <trans-unit id="02527323fc74019fbf781a55d67bc6708fd5c80b" translate="yes" xml:space="preserve">
          <source>Kotlin Multiplatform Mobile documentation</source>
          <target state="translated">Kotlin マルチプラットフォーム モバイル ドキュメント</target>
        </trans-unit>
        <trans-unit id="79d51b4bb6a5d02df45fa0b0d8769519481f6142" translate="yes" xml:space="preserve">
          <source>Kotlin Multiplatform Mobile samples</source>
          <target state="translated">Kotlin マルチプラットフォームモバイルのサンプル</target>
        </trans-unit>
        <trans-unit id="6c868382257c277087bdd2ca5e011f6e8a06d6f5" translate="yes" xml:space="preserve">
          <source>Kotlin Multiplatform projects require Gradle version 4.7 and above, older Gradle versions are not supported.</source>
          <target state="translated">Kotlin Multiplatform プロジェクトには Gradle のバージョン 4.7 以上が必要ですが、それ以前のバージョンの Gradle はサポートされていません。</target>
        </trans-unit>
        <trans-unit id="5beef88265abf70b994272f6614d166413737387" translate="yes" xml:space="preserve">
          <source>Kotlin Multiplatform projects support the Android platform by providing the &lt;code&gt;android&lt;/code&gt; preset. Creating an Android target requires that one of the Android Gradle plugins, like &lt;code&gt;com.android.application&lt;/code&gt; or &lt;code&gt;com.android.library&lt;/code&gt; is manually applied to the project. Only one Android target may be created per Gradle subproject:</source>
          <target state="translated">Kotlin Multiplatformプロジェクトは、 &lt;code&gt;android&lt;/code&gt; プリセットを提供することでAndroidプラットフォームをサポートします。 Androidターゲットを作成するには、 &lt;code&gt;com.android.application&lt;/code&gt; や &lt;code&gt;com.android.library&lt;/code&gt; などのAndroid Gradleプラグインの1つを手動でプロジェクトに適用する必要があります。 Gradleサブプロジェクトごとに作成できるAndroidターゲットは1つだけです。</target>
        </trans-unit>
        <trans-unit id="dc3e3dd997f7c2c71d9a81f4cdb39cd90d645230" translate="yes" xml:space="preserve">
          <source>Kotlin Numbers and NSNumber</source>
          <target state="translated">コトリンナンバーズとNSナンバーズ</target>
        </trans-unit>
        <trans-unit id="eb93d433c30733afdb11f2126d70c53184c02256" translate="yes" xml:space="preserve">
          <source>Kotlin Programming: The Big Nerd Ranch Guide</source>
          <target state="translated">Kotlin プログラミング。ビッグオタクランチガイド</target>
        </trans-unit>
        <trans-unit id="7be628ef89900aa7e06bf8cc0824f551fbf7c2e0" translate="yes" xml:space="preserve">
          <source>Kotlin Scripting APIs</source>
          <target state="translated">Kotlin スクリプト API</target>
        </trans-unit>
        <trans-unit id="faea4ae8da7ddba5c8fa58aae401857d2734ca04" translate="yes" xml:space="preserve">
          <source>Kotlin Scripting APIs and custom hosts</source>
          <target state="translated">Kotlin スクリプト API とカスタムホスト</target>
        </trans-unit>
        <trans-unit id="011d36adfc33756acd805d34ad317cbce9bd6e81" translate="yes" xml:space="preserve">
          <source>Kotlin Scripts (*.kts)</source>
          <target state="translated">Kotlin スクリプト (*.kts)</target>
        </trans-unit>
        <trans-unit id="ede3b405bdfcccaf670f3a431d8f9e4a2a31a89a" translate="yes" xml:space="preserve">
          <source>Kotlin Standard Library</source>
          <target state="translated">Kotkin 標準ライブラリ</target>
        </trans-unit>
        <trans-unit id="f1cf27226d5b75bef32541fe78ffcb393aaf20fa" translate="yes" xml:space="preserve">
          <source>Kotlin allows us to provide implementations for a predefined set of operators on our types. These operators have fixed symbolic representation (like &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;*&lt;/code&gt;) and fixed &lt;a href=&quot;https://kotlinlang.org/docs/reference/grammar.html#expressions&quot;&gt;precedence&lt;/a&gt;. To implement an operator, we provide a &lt;a href=&quot;functions#member-functions&quot;&gt;member function&lt;/a&gt; or an &lt;a href=&quot;extensions&quot;&gt;extension function&lt;/a&gt; with a fixed name, for the corresponding type, i.e. left-hand side type for binary operations and argument type for unary ones. Functions that overload operators need to be marked with the &lt;code&gt;operator&lt;/code&gt; modifier.</source>
          <target state="translated">Kotlinを使用すると、事前定義された一連の演算子の実装を型に提供できます。これらの演算子には、記号表現（ &lt;code&gt;+&lt;/code&gt; や &lt;code&gt;*&lt;/code&gt; など）と&lt;a href=&quot;https://kotlinlang.org/docs/reference/grammar.html#expressions&quot;&gt;優先順位が&lt;/a&gt;固定されています。演算子を実装するには、対応する型（つまり、2項演算の左側の型と単項演算子の引数の型）に、固定名の&lt;a href=&quot;functions#member-functions&quot;&gt;メンバー関数&lt;/a&gt;または&lt;a href=&quot;extensions&quot;&gt;拡張関数&lt;/a&gt;を提供します。演算子をオーバーロードする関数は、 &lt;code&gt;operator&lt;/code&gt; 修飾子でマークする必要があります。</target>
        </trans-unit>
        <trans-unit id="b851c189b290bdaf55745756936a76cc50344467" translate="yes" xml:space="preserve">
          <source>Kotlin allows you to compile your Kotlin projects to JavaScript modules for popular module systems. Here is the list of available options:</source>
          <target state="translated">Kotlinでは、Kotlinプロジェクトを一般的なモジュールシステム用のJavaScriptモジュールにコンパイルすることができます。利用可能なオプションのリストは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="9b5fdfaaf9a73290e0eaf81fbe25051b78fa8542" translate="yes" xml:space="preserve">
          <source>Kotlin allows you to enforce symbol visibility (which Python only does via underscore conventions) via &lt;em&gt;visibility modifiers&lt;/em&gt;, which can be placed on symbol declarations. If you don't supply a visibility modifier, you get the default visibility level, which is &lt;em&gt;public&lt;/em&gt;.</source>
          <target state="translated">Kotlinを使用すると、シンボル宣言に配置できる&lt;em&gt;可視性修飾子を使用して&lt;/em&gt;、シンボルの可視性（Pythonはアンダースコア規則を介してのみ実行する）を適用できます。可視性修飾子を指定しない場合、デフォルトの可視性レベルである&lt;em&gt;public&lt;/em&gt;を取得します。</target>
        </trans-unit>
        <trans-unit id="abf47a509d1576212045a5d60665d20e7353bdcd" translate="yes" xml:space="preserve">
          <source>Kotlin also has specialized classes to represent arrays of primitive types without boxing overhead: &lt;code&gt;ByteArray&lt;/code&gt;, &lt;code&gt;ShortArray&lt;/code&gt;, &lt;code&gt;IntArray&lt;/code&gt; and so on. These classes have no inheritance relation to the &lt;code&gt;Array&lt;/code&gt; class, but they have the same set of methods and properties. Each of them also has a corresponding factory function:</source>
          <target state="translated">Kotlinには、プリミティブ型の配列をボックス化オーバーヘッドなしで表すための特殊なクラスもあります： &lt;code&gt;ByteArray&lt;/code&gt; 、 &lt;code&gt;ShortArray&lt;/code&gt; 、 &lt;code&gt;IntArray&lt;/code&gt; など。これらのクラスには、 &lt;code&gt;Array&lt;/code&gt; クラスとの継承関係はありませんが、メソッドとプロパティの同じセットがあります。それぞれに対応するファクトリ関数もあります。</target>
        </trans-unit>
        <trans-unit id="7c8be75b3b89d72e9e8ecc5a19439af68c79c8b1" translate="yes" xml:space="preserve">
          <source>Kotlin also supports a conventional notation for floating-point numbers:</source>
          <target state="translated">Kotlinは浮動小数点数の従来の記法もサポートしています。</target>
        </trans-unit>
        <trans-unit id="fdbc9c499ba317d1129cfbc92871c8a9261e88e6" translate="yes" xml:space="preserve">
          <source>Kotlin and Continuous Integration with TeamCity</source>
          <target state="translated">Kotlin と TeamCity での継続的インテグレーション</target>
        </trans-unit>
        <trans-unit id="a29301ac26900a11e482b9b5b30d720163c72b02" translate="yes" xml:space="preserve">
          <source>Kotlin and Java sources</source>
          <target state="translated">Kotlin と Java のソース</target>
        </trans-unit>
        <trans-unit id="1c08b7274c4d1ababf7790a5bd9928dd47f39d9b" translate="yes" xml:space="preserve">
          <source>Kotlin and OSGi</source>
          <target state="translated">コトリンとOSGi</target>
        </trans-unit>
        <trans-unit id="b68da677f694a6554746e03538ca7213a7ff25e8" translate="yes" xml:space="preserve">
          <source>Kotlin and Swift both define nullability as part of the type specification, while Objc defines nullability on methods and properties of a type. As such, the following:</source>
          <target state="translated">KotlinとSwiftはどちらも型の仕様の一部としてヌル可能性を定義していますが、Objcは型のメソッドやプロパティに対してヌル可能性を定義しています。そのため、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="de39894b7ea202f08e960c5e82b74ef66fdd95ec" translate="yes" xml:space="preserve">
          <source>Kotlin and Swift both define nullability as part of the type specification, while Objective-C defines nullability on methods and properties of a type. As such, the following:</source>
          <target state="translated">Kotlin と Swift はどちらも型の仕様の一部としてヌル可能性を定義していますが、Objective-C は型のメソッドとプロパティに対してヌル可能性を定義しています。そのため、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="fab22e5d648c157aabeded51b75888d84156c11e" translate="yes" xml:space="preserve">
          <source>Kotlin applications can be deployed into any host that supports Java Web applications, including Amazon Web Services, Google Cloud Platform and more.</source>
          <target state="translated">Kotlinのアプリケーションは、Amazon Web ServicesやGoogle Cloud Platformなど、Java Webアプリケーションをサポートするあらゆるホストにデプロイすることができます。</target>
        </trans-unit>
        <trans-unit id="e02f5529b0cc0cc0f331270b870a1119276c7c49" translate="yes" xml:space="preserve">
          <source>Kotlin as a statically typed programming language plays well for writing Gradle build scripts. Thanks to the static type inference, the Kotlin compiler detects errors earlier and shows important compilation error messages and warnings. Both an IDE and the compiler can use the information about types to infer the available functions and properties in a given scope.</source>
          <target state="translated">静的型付けされたプログラミング言語である Kotlin は Gradle のビルドスクリプトを書くのに適しています。静的型推論のおかげで、Kotlin コンパイラはより早くエラーを検出し、重要なコンパイルエラーメッセージや警告を表示します。IDE とコンパイラは、型に関する情報を使って、指定されたスコープで利用可能な関数やプロパティを推論することができます。</target>
        </trans-unit>
        <trans-unit id="2c6b22009eb8eb5969f5ded032f4849774e1cf34" translate="yes" xml:space="preserve">
          <source>Kotlin by Example</source>
          <target state="translated">事例によるコトリン</target>
        </trans-unit>
        <trans-unit id="6b0d896d7d9bc79daab4d58d21e623cb98946df3" translate="yes" xml:space="preserve">
          <source>Kotlin can also be used as a scripting language. A script is a Kotlin source file (.kts) with top level executable code.</source>
          <target state="translated">Kotlin はスクリプト言語としても使用できます。スクリプトとは、トップレベルの実行可能なコードを含む Kotlin のソースファイル (.kts)のことです。</target>
        </trans-unit>
        <trans-unit id="89f1b06f3d13062a764afffd52c7537a00883d5c" translate="yes" xml:space="preserve">
          <source>Kotlin can also be used as a scripting language. A script is a Kotlin source file (&lt;em&gt;.kts&lt;/em&gt;) with top level executable code.</source>
          <target state="translated">Kotlinはスクリプト言語としても使用できます。スクリプトは、トップレベルの実行可能コードを&lt;em&gt;含む&lt;/em&gt;Kotlinソースファイル（&lt;em&gt;.kts&lt;/em&gt;）です。</target>
        </trans-unit>
        <trans-unit id="c3ea6432cc5a54843d5885315d7e06f428855633" translate="yes" xml:space="preserve">
          <source>Kotlin can be compiled for several different platforms. In this document, we assume that the target platform is the Java virtual machine, which grants some extra capabilities - in particular, your code will be compiled to Java bytecode and will therefore be interoperable with the large ecosystem of Java libraries.</source>
          <target state="translated">Kotlinはいくつかの異なるプラットフォーム用にコンパイルすることができます。このドキュメントでは、ターゲットプラットフォームがJava仮想マシンであることを前提としていますが、これはいくつかの特別な機能を提供します。</target>
        </trans-unit>
        <trans-unit id="fb59a20f7c43ef0e90a9a5fe239e22f7fac4ccd8" translate="yes" xml:space="preserve">
          <source>Kotlin can be used for any kind of development, be it server-side, client-side web and Android. With Kotlin/Native currently in the works, support for other platforms such as embedded systems, macOS and iOS is coming. People are using Kotlin for mobile and server-side applications, client-side with JavaScript or JavaFX, and data science, just to name a few possibilities.</source>
          <target state="translated">Kotlinは、サーバーサイド、クライアントサイドのWeb、Androidなど、あらゆる種類の開発に利用できます。現在Kotlin/Nativeが開発中で、組み込みシステム、macOS、iOSなどの他のプラットフォームのサポートも予定されています。モバイルやサーバーサイドのアプリケーション、JavaScriptやJavaFXを使ったクライアントサイド、データサイエンスなどにKotlinを使っています。</target>
        </trans-unit>
        <trans-unit id="521266653280c8e4a255fb437cafa5ed253cdca4" translate="yes" xml:space="preserve">
          <source>Kotlin can be used together with existing third-party libraries and frameworks, such as jQuery or React. To access third-party frameworks with a strongly-typed API, you can convert TypeScript definitions from the &lt;a href=&quot;http://definitelytyped.org/&quot;&gt;Definitely Typed&lt;/a&gt; type definitions repository to Kotlin using the &lt;a href=&quot;https://github.com/kotlin/ts2kt&quot;&gt;ts2kt&lt;/a&gt; tool. Alternatively, you can use the &lt;a href=&quot;dynamic-type&quot;&gt;dynamic type&lt;/a&gt; to access any framework without strong typing.</source>
          <target state="translated">Kotlinは、jQueryやReactなどの既存のサードパーティライブラリやフレームワークと一緒に使用できます。強く型付けされたAPIを使用してサードパーティのフレームワークにアクセスするには、&lt;a href=&quot;https://github.com/kotlin/ts2kt&quot;&gt;ts2kt&lt;/a&gt;ツールを使用して、TypeScript定義を&lt;a href=&quot;http://definitelytyped.org/&quot;&gt;Definitely Typed&lt;/a&gt; type definitionリポジトリからKotlinに変換できます。または、&lt;a href=&quot;dynamic-type&quot;&gt;動的な型&lt;/a&gt;を使用して、強い型付けを行わずに任意のフレームワークにアクセスできます。</target>
        </trans-unit>
        <trans-unit id="8ac487e3599218d513d99cbe95341abd1004db54" translate="yes" xml:space="preserve">
          <source>Kotlin can build a &lt;a href=&quot;mpp-share-on-platforms#share-code-on-similar-platforms&quot;&gt;source set hierarchy&lt;/a&gt; with the &lt;code&gt;dependsOn&lt;/code&gt; relation.</source>
          <target state="translated">Kotlinは、 &lt;code&gt;dependsOn&lt;/code&gt; リレーションを使用して&lt;a href=&quot;mpp-share-on-platforms#share-code-on-similar-platforms&quot;&gt;ソースセット階層&lt;/a&gt;を構築できます。</target>
        </trans-unit>
        <trans-unit id="7c790b4c961dea3d891274def8258c901571e23a" translate="yes" xml:space="preserve">
          <source>Kotlin can get quite close to the compactness of Python's &lt;code&gt;list&lt;/code&gt;/&lt;code&gt;dict&lt;/code&gt;/&lt;code&gt;set&lt;/code&gt; comprehensions. Assuming that &lt;code&gt;people&lt;/code&gt; is a collection of &lt;code&gt;Person&lt;/code&gt; objects with a &lt;code&gt;name&lt;/code&gt; property:</source>
          <target state="translated">Kotlinは、Pythonの &lt;code&gt;list&lt;/code&gt; / &lt;code&gt;dict&lt;/code&gt; / &lt;code&gt;set&lt;/code&gt; 内包の簡潔さにかなり近づくことができます。 &lt;code&gt;people&lt;/code&gt; が &lt;code&gt;name&lt;/code&gt; プロパティを持つ &lt;code&gt;Person&lt;/code&gt; オブジェクトのコレクションであると想定します。</target>
        </trans-unit>
        <trans-unit id="1a109a14558842e44146557931b4bc933ed0c8e4" translate="yes" xml:space="preserve">
          <source>Kotlin can now generate type annotations in the JVM bytecode (target version 1.8+), so that they become available in Java reflection at runtime. To emit the type annotation in the bytecode, follow these steps:</source>
          <target state="translated">Kotlinでは、JVMバイトコード(ターゲットバージョン1.8+)で型アノテーションを生成できるようになり、実行時にJavaのリフレクションで利用できるようになりました。バイトコード内の型アノテーションを生成するには、以下の手順に従ってください。</target>
        </trans-unit>
        <trans-unit id="01363668f0c8a96c308b85201388c8e9019873f8" translate="yes" xml:space="preserve">
          <source>Kotlin can use only Swift declarations marked with the &lt;code&gt;@objc&lt;/code&gt; attribute.</source>
          <target state="translated">Kotlinは、 &lt;code&gt;@objc&lt;/code&gt; 属性でマークされたSwift宣言のみを使用できます。</target>
        </trans-unit>
        <trans-unit id="88373e20528c6bc39fe448071ad8e0db31e3a229" translate="yes" xml:space="preserve">
          <source>Kotlin can't distinguish between numeric types at run time (except for &lt;code&gt;kotlin.Long&lt;/code&gt;), i.e. the following code works:</source>
          <target state="translated">Kotlinは、実行時に数値型を区別できません（ &lt;code&gt;kotlin.Long&lt;/code&gt; を除く）。つまり、次のコードは機能します。</target>
        </trans-unit>
        <trans-unit id="f14b3e6c2a42d2b616f9f3f45afd4a5a6fa4ccb2" translate="yes" xml:space="preserve">
          <source>Kotlin can't distinguish between numeric types at run time (except for &lt;code&gt;kotlin.Long&lt;/code&gt;), so the following code works:</source>
          <target state="translated">Kotlinは実行時に数値タイプを区別できないため（ &lt;code&gt;kotlin.Long&lt;/code&gt; を除く）、次のコードが機能します。</target>
        </trans-unit>
        <trans-unit id="6add9a81cfef0c10e828238aa1031be87d4fbdd7" translate="yes" xml:space="preserve">
          <source>Kotlin cares a lot about stability and backward compatibility of code: Kotlin compatibility policy says that &quot;breaking changes&quot; (e.g., a change which makes the code that used to compile fine, not compile anymore) can be introduced only in the major releases (1.2, 1.3, etc.).</source>
          <target state="translated">Kotlinはコードの安定性と下位互換性をかなり気にしています。Kotlin の互換性ポリシーによると、&quot;Breaking Change&quot; (例えば、以前は正常にコンパイルできていたコードをコンパイルできなくするような変更)はメジャーリリース (1.2,1.3 など)でのみ導入できるとされています。</target>
        </trans-unit>
        <trans-unit id="7c15ccd2ee8e753a90a11ef141acc11bda9b7db8" translate="yes" xml:space="preserve">
          <source>Kotlin classes and interfaces can be subclassed by Swift/Objective-C classes and protocols.</source>
          <target state="translated">Kotlinのクラスやインターフェースは、Swift/Objective-Cのクラスやプロトコルでサブクラス化することができます。</target>
        </trans-unit>
        <trans-unit id="21d314ecbc0aafe901079bc4583e826c76990ca2" translate="yes" xml:space="preserve">
          <source>Kotlin classes have a &lt;code&gt;KotlinBase&lt;/code&gt; base class in Objective-C, the class extends the &lt;code&gt;NSObject&lt;/code&gt; class there. We also have wrappers for collections and exceptions. Most of the collection types are mapped to similar collection types from the other side:</source>
          <target state="translated">KotlinクラスにはObjective-Cの &lt;code&gt;KotlinBase&lt;/code&gt; 基本クラスがあり、このクラスは &lt;code&gt;NSObject&lt;/code&gt; クラスを拡張します。コレクションと例外のラッパーもあります。コレクションタイプのほとんどは、反対側から同様のコレクションタイプにマップされます。</target>
        </trans-unit>
        <trans-unit id="8a8b117cc96a073696a10569a9a03f3366586d14" translate="yes" xml:space="preserve">
          <source>Kotlin code can be easily called from Java. For example, instances of a Kotlin class can be seamlessly created and operated in Java methods. However, there are certain differences between Java and Kotlin that require attention when integrating Kotlin code into Java. On this page, we'll describe the ways to tailor the interop of your Kotlin code with its Java clients.</source>
          <target state="translated">KotlinのコードはJavaから簡単に呼び出すことができます。例えば、Kotlinクラスのインスタンスをシームレスに作成し、Javaのメソッドで操作することができます。しかし、JavaとKotlinの間には、KotlinのコードをJavaに統合する際に注意が必要な違いがあります。このページでは、KotlinコードのJavaクライアントとの相互接続を調整する方法を説明します。</target>
        </trans-unit>
        <trans-unit id="9fd6821c54cf8552d62d9de4efae79ccdf8ce19d" translate="yes" xml:space="preserve">
          <source>Kotlin collection types and subtypes</source>
          <target state="translated">Kotlin コレクションのタイプとサブタイプ</target>
        </trans-unit>
        <trans-unit id="315f6541c31d964f7f6872786a71a0ab54434ee9" translate="yes" xml:space="preserve">
          <source>Kotlin collections (&lt;code&gt;List&lt;/code&gt;, &lt;code&gt;Set&lt;/code&gt;, &lt;code&gt;Map&lt;/code&gt;, etc.) are not mapped to any specific JavaScript type.</source>
          <target state="translated">Kotlinコレクション（ &lt;code&gt;List&lt;/code&gt; 、 &lt;code&gt;Set&lt;/code&gt; 、 &lt;code&gt;Map&lt;/code&gt; など）は、特定のJavaScriptタイプにマップされません。</target>
        </trans-unit>
        <trans-unit id="82a1593c6b9e1c8836da6d1fc4eb0ee62fff00f0" translate="yes" xml:space="preserve">
          <source>Kotlin collections (i.e. &lt;code&gt;List&lt;/code&gt;, &lt;code&gt;Set&lt;/code&gt;, &lt;code&gt;Map&lt;/code&gt;, etc) are not mapped to any specific JavaScript type.</source>
          <target state="translated">Kotlinコレクション（つまり、 &lt;code&gt;List&lt;/code&gt; 、 &lt;code&gt;Set&lt;/code&gt; 、 &lt;code&gt;Map&lt;/code&gt; など）は、特定のJavaScriptタイプにはマップされません。</target>
        </trans-unit>
        <trans-unit id="89a478aadf91b074b0da52969af13f23d22bc823" translate="yes" xml:space="preserve">
          <source>Kotlin collections are converted to Swift/Objective-C collections as described in the table above. Swift/Objective-C collections are mapped to Kotlin in the same way, except for &lt;code&gt;NSMutableSet&lt;/code&gt; and &lt;code&gt;NSMutableDictionary&lt;/code&gt;. &lt;code&gt;NSMutableSet&lt;/code&gt; isn't converted to a Kotlin &lt;code&gt;MutableSet&lt;/code&gt;. To pass an object for Kotlin &lt;code&gt;MutableSet&lt;/code&gt;, you can create this kind of Kotlin collection explicitly by either creating it in Kotlin with e.g. &lt;code&gt;mutableSetOf()&lt;/code&gt;, or using the &lt;code&gt;KotlinMutableSet&lt;/code&gt; class in Swift (or &lt;code&gt;${prefix}MutableSet&lt;/code&gt; in Objective-C, where &lt;code&gt;prefix&lt;/code&gt; is the framework names prefix). The same holds for &lt;code&gt;MutableMap&lt;/code&gt;.</source>
          <target state="translated">Kotlinコレクションは、上記の表で説明されているようにSwift / Objective-Cコレクションに変換されます。 Swift / Objective-Cコレクションは、 &lt;code&gt;NSMutableSet&lt;/code&gt; と &lt;code&gt;NSMutableDictionary&lt;/code&gt; を除いて、同じ方法でKotlinにマップされます。 &lt;code&gt;NSMutableSet&lt;/code&gt; はKotlin &lt;code&gt;MutableSet&lt;/code&gt; に変換されません。 Kotlinのためのオブジェクト渡すには &lt;code&gt;MutableSet&lt;/code&gt; を、あなたは、例えばとKotlinでそれを作成することによって明示的にKotlinコレクションのこの種を作成することができます &lt;code&gt;mutableSetOf()&lt;/code&gt; 、または使用して &lt;code&gt;KotlinMutableSet&lt;/code&gt; のスウィフト（またはでクラスを &lt;code&gt;${prefix}MutableSet&lt;/code&gt; のObjective-C、に &lt;code&gt;prefix&lt;/code&gt; フレームワーク名の接頭辞です）。 &lt;code&gt;MutableMap&lt;/code&gt; についても同様です。</target>
        </trans-unit>
        <trans-unit id="b92ab48756ee9ee4eecd8b48a584a882c8254f38" translate="yes" xml:space="preserve">
          <source>Kotlin collections contain functions for commonly used &lt;em&gt;aggregate operations&lt;/em&gt; &amp;ndash; operations that return a single value based on the collection content. Most of them are well known and work the same way as they do in other languages:</source>
          <target state="translated">Kotlinコレクションには、一般的に使用される&lt;em&gt;集約オペレーション（&lt;/em&gt;コレクションの内容に基づいて単一の値を返す&lt;em&gt;オペレーション）の&lt;/em&gt;関数が含まれています。それらのほとんどはよく知られており、他の言語と同じように機能します。</target>
        </trans-unit>
        <trans-unit id="6f6ae7c2ed581955837fb7fe33d78ac601409b90" translate="yes" xml:space="preserve">
          <source>Kotlin collections provide a set of functions for retrieving single elements from collections. Functions described on this page apply to both lists and sets.</source>
          <target state="translated">Kotlin のコレクションには、コレクションから単一の要素を取得するための関数が用意されています。このページで説明する関数はリストとセットの両方に適用されます。</target>
        </trans-unit>
        <trans-unit id="ba542c391d818d9d92362b069b9bf7f9bd8bf71d" translate="yes" xml:space="preserve">
          <source>Kotlin community is open, helpful, and welcoming. Don't hesitate to join and ask on any platform you like:</source>
          <target state="translated">Kotlin コミュニティはオープンで親切で歓迎されています。遠慮なく参加して、好きなプラットフォームで質問してください。</target>
        </trans-unit>
        <trans-unit id="4e7553781e500e3864ae344f47e5a7328b499d62" translate="yes" xml:space="preserve">
          <source>Kotlin compiler generates normal JavaScript classes, functions and properties you can freely use from JavaScript code. Nevertheless, there are some subtle things you should remember.</source>
          <target state="translated">Kotlinコンパイラは、JavaScriptのコードから自由に使える普通のJavaScriptのクラスや関数、プロパティを生成してくれます。とはいえ、微妙に覚えておくべきことがあります。</target>
        </trans-unit>
        <trans-unit id="e2af437257c982ea32c02d4a42942eceaf188caa" translate="yes" xml:space="preserve">
          <source>Kotlin compiler offers &lt;em&gt;explicit API mode&lt;/em&gt; for library authors. In this mode, the compiler performs additional checks that help make the library&amp;rsquo;s API clearer and more consistent. It adds the following requirements for declarations exposed to the library&amp;rsquo;s public API:</source>
          <target state="translated">Kotlinコンパイラは、ライブラリ作成者に&lt;em&gt;明示的なAPIモード&lt;/em&gt;を提供します。このモードでは、コンパイラーは、ライブラリーのAPIをより明確で一貫性のあるものにするのに役立つ追加のチェックを実行します。ライブラリのパブリックAPIに公開される宣言に次の要件を追加します。</target>
        </trans-unit>
        <trans-unit id="6a4e8f76fdd58bb0af9bcb56f7360e7af41cc619" translate="yes" xml:space="preserve">
          <source>Kotlin compiler produces byte-code, thus there really is no difference in terms of look and feel of Kotlin applications versus those written in Java.</source>
          <target state="translated">Kotlinコンパイラはバイトコードを生成するので、Javaで書かれたものとKotlinアプリケーションの見た目に違いはありません。</target>
        </trans-unit>
        <trans-unit id="254a81c2b10749e0ebcc71c56165e699f0faa1e8" translate="yes" xml:space="preserve">
          <source>Kotlin compiler specifics</source>
          <target state="translated">Kotlin コンパイラの仕様</target>
        </trans-unit>
        <trans-unit id="9aad08d33b38b295c66376049aa54dafe55e242e" translate="yes" xml:space="preserve">
          <source>Kotlin compiler would generate the following output</source>
          <target state="translated">Kotlin コンパイラは以下のような出力を生成します。</target>
        </trans-unit>
        <trans-unit id="f142a3debb6f5ab93f8769b5839aca7d9de9a318" translate="yes" xml:space="preserve">
          <source>Kotlin compilers have a number of options for tailoring the compiling process. Compiler options for different targets are listed on this page together with a description of each one.</source>
          <target state="translated">Kotlin のコンパイラには、コンパイルプロセスをカスタマイズするためのオプションがいくつかあります。このページでは、ターゲットごとのコンパイラーオプションとその説明をリストアップしています。</target>
        </trans-unit>
        <trans-unit id="4e6a12781a358b0632ea318dc28241e7061cc96f" translate="yes" xml:space="preserve">
          <source>Kotlin constructors are imported as initializers to Swift/Objective-C.</source>
          <target state="translated">Kotlinのコンストラクタは、Swift/Objective-Cのイニシャライザとしてインポートされます。</target>
        </trans-unit>
        <trans-unit id="fd097194728e7a8d4e414220f1c3adc66a1135aa" translate="yes" xml:space="preserve">
          <source>Kotlin documentation is a good place to start, check out these links to get your feet wet:</source>
          <target state="translated">Kotlin のドキュメントは始めるには良い場所です。</target>
        </trans-unit>
        <trans-unit id="22a04b6935ed8f621d145360c7aea12d3366842f" translate="yes" xml:space="preserve">
          <source>Kotlin does not have Python's &lt;em&gt;resource managers&lt;/em&gt; or Java's &lt;em&gt;try-with-resources&lt;/em&gt;, but thanks to extension functions, there's &lt;code&gt;use&lt;/code&gt;:</source>
          <target state="translated">KotlinにはPythonの&lt;em&gt;リソースマネージャー&lt;/em&gt;やJavaの&lt;em&gt;try-with-resources&lt;/em&gt;がありませんが、拡張関数のおかげで、次の &lt;code&gt;use&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8da11f04c1c3d7dbbef032228e63afa6f04d63f3" translate="yes" xml:space="preserve">
          <source>Kotlin does not have checked &lt;a href=&quot;exceptions&quot;&gt;exceptions&lt;/a&gt;</source>
          <target state="translated">Kotlinは&lt;a href=&quot;exceptions&quot;&gt;例外&lt;/a&gt;を確認していません</target>
        </trans-unit>
        <trans-unit id="58e8fc7ba9fc6ab7f17a343e98ca51e5a850e480" translate="yes" xml:space="preserve">
          <source>Kotlin does not have checked exceptions. There are many reasons for this, but we will provide a simple example.</source>
          <target state="translated">Kotlinにはチェック済みの例外がありません。これには様々な理由がありますが、簡単な例を示します。</target>
        </trans-unit>
        <trans-unit id="7ea8df84918172c874d6ce26a2d2ac8d56eff8a7" translate="yes" xml:space="preserve">
          <source>Kotlin does not implement lazy initialization of top-level properties in JavaScript.</source>
          <target state="translated">KotlinはJavaScriptのトップレベルプロパティの遅延初期化を実装していません。</target>
        </trans-unit>
        <trans-unit id="1c19ec6ca29946106579b7774a9f16c5845ebbc2" translate="yes" xml:space="preserve">
          <source>Kotlin ensures type safety of operations involving &lt;a href=&quot;generics&quot;&gt;generics&lt;/a&gt; at compile time, while, at runtime, instances of generic types hold no information about their actual type arguments. For example, &lt;code&gt;List&amp;lt;Foo&amp;gt;&lt;/code&gt; is erased to just &lt;code&gt;List&amp;lt;*&amp;gt;&lt;/code&gt;. In general, there is no way to check whether an instance belongs to a generic type with certain type arguments at runtime.</source>
          <target state="translated">Kotlinは、コンパイル時に&lt;a href=&quot;generics&quot;&gt;ジェネリック&lt;/a&gt;を含む操作の型安全性を保証しますが、実行時、ジェネリック型のインスタンスは実際の型引数に関する情報を保持しません。たとえば、 &lt;code&gt;List&amp;lt;Foo&amp;gt;&lt;/code&gt; は消去され、 &lt;code&gt;List&amp;lt;*&amp;gt;&lt;/code&gt; だけになります。一般に、インスタンスが実行時に特定の型引数を持つジェネリック型に属しているかどうかを確認する方法はありません。</target>
        </trans-unit>
        <trans-unit id="e3093475043dd707a8b9c1069aead086bf16cf6d" translate="yes" xml:space="preserve">
          <source>Kotlin exposes its package structure to JavaScript, so unless you define your declarations in the root package, you have to use fully qualified names in JavaScript. For example:</source>
          <target state="translated">Kotlin はそのパッケージ構造を JavaScript に公開しているので、ルートパッケージで宣言を定義しない限り、JavaScript で完全修飾名を使用しなければなりません。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="bbcaf4c7dfc1607eaa4b2ffde25fea37b6fff50b" translate="yes" xml:space="preserve">
          <source>Kotlin exposes its package structure to JavaScript, so unless you define your declarations in the root package, you have to use fully-qualified names in JavaScript. For example:</source>
          <target state="translated">Kotlin はそのパッケージ構造を JavaScript に公開しているので、ルートパッケージで宣言を定義しない限り、JavaScript で完全修飾名を使用しなければなりません。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="7be04058c2375c4141e803b8f5f5c3ef0ebe450b" translate="yes" xml:space="preserve">
          <source>Kotlin extensions to &quot;regular&quot; Kotlin classes are imported to Swift and Objective-C as extensions and category members respectively. Kotlin extensions to other types are treated as &lt;a href=&quot;#top-level-functions-and-properties&quot;&gt;top-level declarations&lt;/a&gt; with an additional receiver parameter. These types include:</source>
          <target state="translated">「通常の」KotlinクラスへのKotlin拡張機能は、拡張機能とカテゴリメンバーとしてそれぞれSwiftとObjective-Cにインポートされます。他のタイプへのKotlin拡張は、追加のレシーバーパラメーターを持つ&lt;a href=&quot;#top-level-functions-and-properties&quot;&gt;トップレベルの宣言&lt;/a&gt;として扱われます。これらのタイプは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="6bd032e19c9c721a60ec9014384d50331ee1d338" translate="yes" xml:space="preserve">
          <source>Kotlin fixes a series of issues that Java suffers from:</source>
          <target state="translated">Kotlin は Java が抱える一連の問題を修正します。</target>
        </trans-unit>
        <trans-unit id="2e70b9b4257b183b5c7e10570483451ad725fc8a" translate="yes" xml:space="preserve">
          <source>Kotlin follows the Java naming conventions. In particular:</source>
          <target state="translated">KotlinはJavaの命名規則に従っています。特に</target>
        </trans-unit>
        <trans-unit id="0548deb8694e8bfa87792c4e732edf938085eb1e" translate="yes" xml:space="preserve">
          <source>Kotlin for Android Case Studies</source>
          <target state="translated">Kotlin for Androidの導入事例</target>
        </trans-unit>
        <trans-unit id="c1441b497e656bddb290de8de9224360e00ecbdf" translate="yes" xml:space="preserve">
          <source>Kotlin for Android Developers</source>
          <target state="translated">Android開発者のためのKotlin</target>
        </trans-unit>
        <trans-unit id="697d1de6e7cb2c06571dc421613de269a61dd215" translate="yes" xml:space="preserve">
          <source>Kotlin for Data Science</source>
          <target state="translated">データサイエンスのためのKotlin</target>
        </trans-unit>
        <trans-unit id="7b2f1c8edda5c1d58bf2a573a1626581c631617c" translate="yes" xml:space="preserve">
          <source>Kotlin for Java Developers</source>
          <target state="translated">Java開発者のためのKotlin</target>
        </trans-unit>
        <trans-unit id="e6f31bf50fe73009407bd97cfc46c1659646cb16" translate="yes" xml:space="preserve">
          <source>Kotlin function types and subtypes</source>
          <target state="translated">Kotlin 関数の型とサブタイプ</target>
        </trans-unit>
        <trans-unit id="fe6b04ae909883df5d80ca51aec87a07bb290e41" translate="yes" xml:space="preserve">
          <source>Kotlin function-typed objects (e.g. lambdas) are converted to Swift functions / Objective-C blocks. However there is a difference in how types of parameters and return values are mapped when translating a function and a function type. In the latter case primitive types are mapped to their boxed representation. Kotlin &lt;code&gt;Unit&lt;/code&gt; return value is represented as a corresponding &lt;code&gt;Unit&lt;/code&gt; singleton in Swift/Objective-C. The value of this singleton can be retrieved in the same way as it is for any other Kotlin &lt;code&gt;object&lt;/code&gt; (see singletons in the table above). To sum the things up:</source>
          <target state="translated">Kotlin関数型オブジェクト（ラムダなど）は、Swift関数/ Objective-Cブロックに変換されます。ただし、関数と関数の型を変換するときに、パラメーターの型と戻り値がマップされる方法には違いがあります。後者の場合、プリミティブ型はボックス化された表現にマップされます。 Kotlin &lt;code&gt;Unit&lt;/code&gt; 戻り値は、Swift / Objective-Cでは対応する &lt;code&gt;Unit&lt;/code&gt; シングルトンとして表されます。このシングルトンの値は、他のKotlin &lt;code&gt;object&lt;/code&gt; 場合と同じ方法で取得できます（上記の表のシングルトンを参照）。まとめると：</target>
        </trans-unit>
        <trans-unit id="6377c81eb40cd3205e240b814a78f31b9c3b2c4e" translate="yes" xml:space="preserve">
          <source>Kotlin functions are &lt;a href=&quot;https://en.wikipedia.org/wiki/First-class_function&quot;&gt;&lt;em&gt;first-class&lt;/em&gt;&lt;/a&gt;, which means that they can be stored in variables and data structures, passed as arguments to and returned from other &lt;a href=&quot;#higher-order-functions&quot;&gt;higher-order functions&lt;/a&gt;. You can operate with functions in any way that is possible for other non-function values.</source>
          <target state="translated">Kotlin関数は&lt;a href=&quot;https://en.wikipedia.org/wiki/First-class_function&quot;&gt;&lt;em&gt;ファーストクラス&lt;/em&gt;&lt;/a&gt;です。つまり、変数やデータ構造に格納でき、引数として他の&lt;a href=&quot;#higher-order-functions&quot;&gt;高次関数&lt;/a&gt;に渡したり、他の高次関数から返したりできます。他の非関数値で可能な方法で関数を操作できます。</target>
        </trans-unit>
        <trans-unit id="06212cca9855d4bc50a6216a937f6da059a9c0cc" translate="yes" xml:space="preserve">
          <source>Kotlin generate JavaScript code that is compatible with Asynchronous Module Definition (AMD), CommonJS and Universal Model Definition (UMD).</source>
          <target state="translated">Kotlinは、非同期モジュール定義(AMD)、CommonJS、ユニバーサルモデル定義(UMD)と互換性のあるJavaScriptコードを生成します。</target>
        </trans-unit>
        <trans-unit id="7e3d5465bac3e356284fe278ce3583ae2129ce4a" translate="yes" xml:space="preserve">
          <source>Kotlin handles numbers in a way close to Java, but not exactly the same. For example, there are no implicit widening conversions for numbers, and literals are slightly different in some cases.</source>
          <target state="translated">KotlinはJavaに近い方法で数値を扱いますが、全く同じではありません。例えば、数字には暗黙のワイド化変換はありませんし、リテラルも若干異なる場合があります。</target>
        </trans-unit>
        <trans-unit id="a419931ca3da367222b771f7660e3ff6428af9ed" translate="yes" xml:space="preserve">
          <source>Kotlin has a rather small runtime file size: the library is approximately 964KB (as of 1.3.41). This means Kotlin adds just a little to .apk file size.</source>
          <target state="translated">Kotlinの実行時のファイルサイズはかなり小さく、ライブラリは約964KBです(1.3.41現在)。つまり、Kotlinは.apkのファイルサイズにほんの少しだけ足しています。</target>
        </trans-unit>
        <trans-unit id="1a3e60d485f88e60187d3caa5025c740961ab3aa" translate="yes" xml:space="preserve">
          <source>Kotlin has an extensive standard library that can be used in your applications. Configure the following dependency in the pom file:</source>
          <target state="translated">Kotlinには、アプリケーションで使用できる標準ライブラリが豊富に用意されています。pomファイルに以下の依存関係を設定します。</target>
        </trans-unit>
        <trans-unit id="ab1e60d19725004dca25a2263f17ef1cdb84890e" translate="yes" xml:space="preserve">
          <source>Kotlin has been successfully adopted by major companies, and a few of them have shared their experiences:</source>
          <target state="translated">Kotlinは大手企業での採用に成功しており、その体験談をいくつか紹介しています。</target>
        </trans-unit>
        <trans-unit id="3ed9d85f3169bc5321f12531a1c541d127d00550" translate="yes" xml:space="preserve">
          <source>Kotlin has both object-oriented and functional constructs. You can use it in both OO and FP styles, or mix elements of the two. With first-class support for features such as higher-order functions, function types and lambdas, Kotlin is a great choice if you&amp;rsquo;re doing or exploring functional programming.</source>
          <target state="translated">Kotlinには、オブジェクト指向と機能の両方の構造があります。OOスタイルとFPスタイルの両方で使用することも、2つの要素を混在させることもできます。高階関数、関数型、ラムダなどの機能をファーストクラスでサポートするKotlinは、関数型プログラミングを行っている、または探索している場合に最適です。</target>
        </trans-unit>
        <trans-unit id="d0b80a6eafa346308b4f2ffbb72d503567999d28" translate="yes" xml:space="preserve">
          <source>Kotlin has classes and their members &lt;code&gt;final&lt;/code&gt; by default, which makes it inconvenient to use frameworks and libraries such as Spring AOP that require classes to be &lt;code&gt;open&lt;/code&gt;. The &lt;em&gt;all-open&lt;/em&gt; compiler plugin adapts Kotlin to the requirements of those frameworks and makes classes annotated with a specific annotation and their members open without the explicit &lt;code&gt;open&lt;/code&gt; keyword.</source>
          <target state="translated">Kotlinにはデフォルトで &lt;code&gt;final&lt;/code&gt; クラスとそのメンバーがあるため、Spring AOPなどのクラスが &lt;code&gt;open&lt;/code&gt; ている必要があるフレームワークやライブラリを使用するのは不便です。&lt;em&gt;すべてのオープン&lt;/em&gt;コンパイラプラグインは、これらのフレームワークの要件にKotlinを適応し、特定のアノテーションを付けたクラスを作り、そのメンバーは、明示的に使われていないオープン &lt;code&gt;open&lt;/code&gt; キーワード。</target>
        </trans-unit>
        <trans-unit id="b816faaaa048d52b55167846f58533c82dcf332c" translate="yes" xml:space="preserve">
          <source>Kotlin has got its own reflection library (&lt;code&gt;kotlin-reflect.jar&lt;/code&gt; must be included in your build). When targeting the JVM, you can also use the Java reflection facilities. Note that the Kotlin reflection isn't quite feature-complete yet - in particular, you can't use it to inspect built-in classes like &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">Kotlinには独自のリフレクションライブラリがあります（ &lt;code&gt;kotlin-reflect.jar&lt;/code&gt; 必要があります）。JVMをターゲットとする場合、Javaリフレクション機能も使用できます。Kotlinリフレクションはまだ機能が完全ではないことに注意してください。特に、これを使用して &lt;code&gt;String&lt;/code&gt; などの組み込みクラスを検査することはできません。</target>
        </trans-unit>
        <trans-unit id="89599a2b8afb959091521970edd698c7f8696cca" translate="yes" xml:space="preserve">
          <source>Kotlin has inherited Java's fidgety (but very flexible) way of doing I/O, but with some simplifying extra features. We won't get into all of it here, so for starters, this is how to iterate through all the lines of a file (you'll need &lt;code&gt;import java.io.File&lt;/code&gt;):</source>
          <target state="translated">Kotlinは、I / Oを実行するJavaの手間のかかる（ただし非常に柔軟な）方法を継承していますが、いくつかの単純化された追加機能があります。ここではすべてを説明するわけではないので、最初に、これはファイルのすべての行を反復処理する方法です（ &lt;code&gt;import java.io.File&lt;/code&gt; が必要です）。</target>
        </trans-unit>
        <trans-unit id="789ece85cba2d7c5232dc414bc11dc159641da4f" translate="yes" xml:space="preserve">
          <source>Kotlin has inherited Java's fidgety array system, so primitive types have got their own array types and conversion functions, while any other type uses the generic &lt;code&gt;Array&lt;/code&gt; type, to which you can convert with &lt;code&gt;.toTypedArray()&lt;/code&gt;.</source>
          <target state="translated">KotlinはJavaのフィジー配列システムを継承しているため、プリミティブ型には独自の配列型と変換関数があり、他の型は &lt;code&gt;.toTypedArray()&lt;/code&gt; で変換できる汎用の &lt;code&gt;Array&lt;/code&gt; 型を使用しています。</target>
        </trans-unit>
        <trans-unit id="99a77fa93b5373d975ec4157225559f8cd6c6cb3" translate="yes" xml:space="preserve">
          <source>Kotlin has no concept of checked exceptions, all Kotlin exceptions are unchecked. Swift has only checked errors. So if Swift or Objective-C code calls a Kotlin method which throws an exception to be handled, then the Kotlin method should be marked with a &lt;code&gt;@Throws&lt;/code&gt; annotation specifying a list of &quot;expected&quot; exception classes.</source>
          <target state="translated">Kotlinにはチェックされた例外の概念がなく、すべてのKotlin例外はチェックされていません。Swiftはエラーのみをチェックしました。したがって、SwiftまたはObjective-Cコードが処理する例外をスローするKotlinメソッドを呼び出す場合、Kotlinメソッドは、「予期される」例外クラスのリストを指定する &lt;code&gt;@Throws&lt;/code&gt; アノテーションでマークする必要があります。</target>
        </trans-unit>
        <trans-unit id="2e626b593df468862004f3cb251d2e1710f0e139" translate="yes" xml:space="preserve">
          <source>Kotlin has no concept of checked exceptions, all Kotlin exceptions are unchecked. Swift has only checked errors. So if Swift or Objective-C code calls a Kotlin method which throws an exception to be handled, then the Kotlin method should be marked with a &lt;code&gt;@Throws&lt;/code&gt; annotation. In this case all Kotlin exceptions (except for instances of &lt;code&gt;Error&lt;/code&gt;, &lt;code&gt;RuntimeException&lt;/code&gt; and subclasses) are translated into a Swift error/&lt;code&gt;NSError&lt;/code&gt;.</source>
          <target state="translated">Kotlinにはチェック済み例外の概念はありません。すべてのKotlin例外はチェックされていません。 Swiftがチェックしたのはエラーのみです。したがって、SwiftまたはObjective-Cのコードが、処理する例外をスローするKotlinメソッドを呼び出す場合、Kotlinメソッドは &lt;code&gt;@Throws&lt;/code&gt; アノテーションでマークする必要があります。この場合、すべてのKotlin例外（ &lt;code&gt;Error&lt;/code&gt; 、 &lt;code&gt;RuntimeException&lt;/code&gt; 、およびサブクラスのインスタンスを除く）はSwift error / &lt;code&gt;NSError&lt;/code&gt; に変換されます。</target>
        </trans-unit>
        <trans-unit id="178ebff753223a76976f1b5505609a06e7a0941e" translate="yes" xml:space="preserve">
          <source>Kotlin has now the option of generating Java 8 bytecode (&lt;code&gt;-jvm-target 1.8&lt;/code&gt; command line option or the corresponding options in Ant/Maven/Gradle). For now this doesn't change the semantics of the bytecode (in particular, default methods in interfaces and lambdas are generated exactly as in Kotlin 1.0), but we plan to make further use of this later.</source>
          <target state="translated">Kotlinには、Java 8バイトコードを生成するオプションがあります（ &lt;code&gt;-jvm-target 1.8&lt;/code&gt; コマンドラインオプション、またはAnt / Maven / Gradleの対応するオプション）。現時点では、これはバイトコードのセマンティクスを変更しません（特に、インターフェースとラムダのデフォルトメソッドはKotlin 1.0とまったく同じように生成されます）が、これは後でさらに使用する予定です。</target>
        </trans-unit>
        <trans-unit id="1b256a14cb898b1876ca682918ab4726ae689547" translate="yes" xml:space="preserve">
          <source>Kotlin has proper &lt;a href=&quot;lambdas#function-types&quot;&gt;function types&lt;/a&gt;, as opposed to Java's SAM-conversions</source>
          <target state="translated">JavaのSAM変換ではなく、Kotlinには適切な&lt;a href=&quot;lambdas#function-types&quot;&gt;関数型&lt;/a&gt;があります。</target>
        </trans-unit>
        <trans-unit id="0bf97cc3e62a44a9f204f95382694f7ebe3c3d2c" translate="yes" xml:space="preserve">
          <source>Kotlin has supported SAM conversions for Java interfaces from the beginning, but there was one case that wasn&amp;rsquo;t supported, which was sometimes annoying when working with existing Java libraries. If you called a Java method that took two SAM interfaces as parameters, both arguments needed to be either lambdas or regular objects. You couldn't pass one argument as a lambda and another as an object.</source>
          <target state="translated">Kotlinは最初からJavaインターフェイスのSAM変換をサポートしてきましたが、サポートされていないケースが1つあり、既存のJavaライブラリを操作するときに煩わしいことがありました。2つのSAMインターフェースをパラメーターとして使用するJavaメソッドを呼び出す場合、両方の引数はラムダまたは通常のオブジェクトである必要がありました。1つの引数をラムダとして渡し、別の引数をオブジェクトとして渡すことはできませんでした。</target>
        </trans-unit>
        <trans-unit id="21d65ae753898818d1cd1395d2b3d50ce49c4d34" translate="yes" xml:space="preserve">
          <source>Kotlin has three structural jump expressions:</source>
          <target state="translated">Kotlinには3つの構造的なジャンプ表現があります。</target>
        </trans-unit>
        <trans-unit id="8fab1b92010786ac4e42e500d9dbd613684af3aa" translate="yes" xml:space="preserve">
          <source>Kotlin has two types of string literals: escaped strings that may have escaped characters in them and raw strings that can contain newlines and arbitrary text. An escaped string is very much like a Java string:</source>
          <target state="translated">Kotlinには2種類の文字列リテラルがあります:エスケープ文字を含む可能性のあるエスケープ文字列と、改行や任意のテキストを含む可能性のある生の文字列です。エスケープされた文字列はJavaの文字列と非常によく似ています。</target>
        </trans-unit>
        <trans-unit id="88377cf789dc237868418b003f1376d4a4fb9cfb" translate="yes" xml:space="preserve">
          <source>Kotlin has two types of string literals: escaped strings that may have escaped characters in them and raw strings that can contain newlines and arbitrary text. Here's an example of an escaped string:</source>
          <target state="translated">Kotlinには2種類の文字列リテラルがあります:エスケープされた文字が含まれている可能性のあるエスケープ文字列と、改行や任意のテキストを含む可能性のある生の文字列です。以下にエスケープされた文字列の例を示します。</target>
        </trans-unit>
        <trans-unit id="7c53d6c43db7159858e1b06d40910057344f857d" translate="yes" xml:space="preserve">
          <source>Kotlin in Action</source>
          <target state="translated">アクションのコトリン</target>
        </trans-unit>
        <trans-unit id="897dddb8bded8aacac7c4f7f6865ba43edeed083" translate="yes" xml:space="preserve">
          <source>Kotlin introduces following types for unsigned integers:</source>
          <target state="translated">Kotlinでは、符号なし整数の型を以下のように紹介しています。</target>
        </trans-unit>
        <trans-unit id="1162e3ef7e5343b47c0a5de3586b0dd6d01591ce" translate="yes" xml:space="preserve">
          <source>Kotlin is a compiled, statically typed language, which might provide some initial hurdles for people who are used to the interpreted, dynamically typed Python. This document aims to explain a substantial portion of Kotlin's syntax and concepts in terms of how they compare to corresponding concepts in Python.</source>
          <target state="translated">Kotlin はコンパイルされた静的型付けされた言語であり、解釈された動的型付けされた Python に慣れている人にとっては最初のハードルとなるかもしれません。このドキュメントでは、Kotlin の構文と概念のかなりの部分を、Python の対応する概念と比較して説明することを目的としています。</target>
        </trans-unit>
        <trans-unit id="640ddadf7e88f55374061d5998c2bee5a53626f4" translate="yes" xml:space="preserve">
          <source>Kotlin is a great fit for developing Android applications, bringing all of the advantages of a modern language to the Android platform without introducing any new restrictions:</source>
          <target state="translated">KotlinはAndroidアプリケーションの開発に最適で、新しい制限を導入することなく、現代の言語の利点をすべてAndroidプラットフォームにもたらします。</target>
        </trans-unit>
        <trans-unit id="b1f1b3f12f705373f46ad38b06f457675f0bb145" translate="yes" xml:space="preserve">
          <source>Kotlin is a great fit for developing server-side applications, allowing you to write concise and expressive code while maintaining full compatibility with existing Java-based technology stacks and a smooth learning curve:</source>
          <target state="translated">Kotlinはサーバーサイドアプリケーションの開発に最適で、既存のJavaベースのテクノロジースタックとの完全な互換性を維持しながら、簡潔で表現力豊かなコードを書くことができ、スムーズな学習曲線を実現します。</target>
        </trans-unit>
        <trans-unit id="942fb98d86e153b0e83fe0d61de04cbccacbe8f7" translate="yes" xml:space="preserve">
          <source>Kotlin is a pragmatic and unopinionated language, supporting both imperative and function programming styles without pushing the developer towards either one. We can implement the function &lt;code&gt;f&lt;/code&gt; in functional style, using such Kotlin features as &lt;a href=&quot;../reference/functions#tail-recursive-functions&quot;&gt;tail recursion&lt;/a&gt;:</source>
          <target state="translated">Kotlinは実用的で根拠のない言語であり、開発者をどちらかに向けることなく、命令型と関数型のプログラミングスタイルの両方をサポートします。このようなKotlin機能を&lt;a href=&quot;../reference/functions#tail-recursive-functions&quot;&gt;末尾再帰&lt;/a&gt;として使用して、関数 &lt;code&gt;f&lt;/code&gt; を関数スタイルで実装できます。</target>
        </trans-unit>
        <trans-unit id="c0d8f4fd81a58ee08fc7afcc5cfdb0b02c31ab79" translate="yes" xml:space="preserve">
          <source>Kotlin is a statically typed language, which makes it different from the dynamically typed JavaScript. In order to facilitate interoperation with JavaScript code, Kotlin/JS offers the &lt;code&gt;dynamic&lt;/code&gt; type:</source>
          <target state="translated">Kotlinは静的に型付けされた言語であるため、動的に型付けされたJavaScriptとは異なります。JavaScriptコードとの相互運用を容易にするために、Kotlin / JSは &lt;code&gt;dynamic&lt;/code&gt; タイプを提供します。</target>
        </trans-unit>
        <trans-unit id="f033af0ab747811276c086c79a9bfc947c92c7d6" translate="yes" xml:space="preserve">
          <source>Kotlin is an OSS statically typed programming language that targets the JVM, Android, JavaScript and Native. It&amp;rsquo;s developed by &lt;a href=&quot;http://www.jetbrains.com&quot;&gt;JetBrains&lt;/a&gt;. The project started in 2010 and was open source from very early on. The first official 1.0 release was in February 2016.</source>
          <target state="translated">Kotlinは、JVM、Android、JavaScript、およびネイティブを対象とするOSS静的型付けプログラミング言語です。&lt;a href=&quot;http://www.jetbrains.com&quot;&gt;JetBrains&lt;/a&gt;によって開発されました。プロジェクトは2010年に開始され、当初からオープンソースでした。最初の公式1.0リリースは2016年2月でした。</target>
        </trans-unit>
        <trans-unit id="654d332c5c16069d8e33851920e04af4ba1633e6" translate="yes" xml:space="preserve">
          <source>Kotlin is an open-source statically typed programming language that targets the JVM, Android, JavaScript and Native. It&amp;rsquo;s developed by &lt;a href=&quot;http://www.jetbrains.com&quot;&gt;JetBrains&lt;/a&gt;. The project started in 2010 and was open source from very early on. The first official 1.0 release was in February 2016.</source>
          <target state="translated">Kotlinは、JVM、Android、JavaScript、およびネイティブを対象とするオープンソースの静的型付けプログラミング言語です。&lt;a href=&quot;http://www.jetbrains.com&quot;&gt;JetBrains&lt;/a&gt;によって開発されました。プロジェクトは2010年に開始され、非常に早い段階からオープンソースでした。最初の公式1.0リリースは2016年2月でした。</target>
        </trans-unit>
        <trans-unit id="d9537d803964341dc28f1f4951da5b348b7b611e" translate="yes" xml:space="preserve">
          <source>Kotlin is compatible with CommonJS, AMD and UMD, &lt;a href=&quot;../tutorials/javascript/working-with-modules/working-with-modules&quot;&gt;making interaction with different&lt;/a&gt; module systems straightforward.</source>
          <target state="translated">KotlinはCommonJS、AMD、UMDと互換性があり、&lt;a href=&quot;../tutorials/javascript/working-with-modules/working-with-modules&quot;&gt;さまざまな&lt;/a&gt;モジュールシステムと簡単にやり取りできます。</target>
        </trans-unit>
        <trans-unit id="60bc1c7729db3b60c6d62ba20f7492d0f9556d43" translate="yes" xml:space="preserve">
          <source>Kotlin is concise, readable and easy to learn.</source>
          <target state="translated">Kotlinは簡潔で読みやすく、学習しやすいです。</target>
        </trans-unit>
        <trans-unit id="2c3ca5bc7aa971f25976aff86462ee8c65c9cb7e" translate="yes" xml:space="preserve">
          <source>Kotlin is designed to be a pragmatic tool for programmers. When it comes to language evolution, its pragmatic nature is captured by the following principles:</source>
          <target state="translated">Kotlinはプログラマのための実用的なツールとして設計されています。言語の進化に関して言えば、そのプラグマティックな性質は以下の原則によって捉えられています。</target>
        </trans-unit>
        <trans-unit id="93c08e581c43a4ec4822d841d4ddc6b6324821eb" translate="yes" xml:space="preserve">
          <source>Kotlin is designed to be easy to learn for people who already know Java. A quick overview of differences is given on &lt;a href=&quot;../reference/comparison-to-java&quot;&gt;the official comparison page&lt;/a&gt;. A short introduction to the basic syntax of Kotlin for software developers can be found directly in the reference section of the web site starting from &lt;a href=&quot;../reference/basic-syntax&quot;&gt;basic syntax&lt;/a&gt;.</source>
          <target state="translated">Kotlinは、Javaをすでに知っている人が簡単に習得できるように設計されています。違いの概要については&lt;a href=&quot;../reference/comparison-to-java&quot;&gt;、公式の比較ページをご覧ください&lt;/a&gt;。ソフトウェア開発者向けのKotlinの基本構文の簡単な紹介は、基本構文から始まるWebサイトのリファレンスセクションに直接あり&lt;a href=&quot;../reference/basic-syntax&quot;&gt;ます&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="76527281e23251ab9b22562a01f9e2381d26e878" translate="yes" xml:space="preserve">
          <source>Kotlin is designed with Java Interoperability in mind. Existing Java code can be called from Kotlin in a natural way, and Kotlin code can be used from Java rather smoothly as well. In this section we describe some details about calling Java code from Kotlin.</source>
          <target state="translated">KotlinはJavaとの相互運用性を考慮して設計されています。既存のJavaコードをKotlinから自然な形で呼び出すことができ、KotlinのコードはJavaからもスムーズに利用することができます。ここでは、KotlinからJavaコードを呼び出す方法について詳しく説明します。</target>
        </trans-unit>
        <trans-unit id="b1117330525358e715dea7a8875981cd28a616bf" translate="yes" xml:space="preserve">
          <source>Kotlin is distributed with &lt;code&gt;kotlin.js&lt;/code&gt; standard library as a single file, which is itself compiled as an UMD module, so you can use it with any module system described above. Also it is available on NPM as &lt;a href=&quot;https://www.npmjs.com/package/kotlin&quot;&gt;&lt;code&gt;kotlin&lt;/code&gt; package&lt;/a&gt;</source>
          <target state="translated">Kotlinは、 &lt;code&gt;kotlin.js&lt;/code&gt; 標準ライブラリとともに単一ファイルとして配布され、それ自体がUMDモジュールとしてコンパイルされるため、上記の任意のモジュールシステムで使用できます。また、NPMでは&lt;a href=&quot;https://www.npmjs.com/package/kotlin&quot;&gt; &lt;code&gt;kotlin&lt;/code&gt; &lt;/a&gt;パッケージとしても利用できます</target>
        </trans-unit>
        <trans-unit id="d0a18e9cef9fc2a234c1d159c10281aea5af17fa" translate="yes" xml:space="preserve">
          <source>Kotlin is distributed with the Kotlin/JS standard library as a single file, which is itself compiled as an UMD module, so you can use it with any module system described above. While for most use cases of Kotlin/JS, it is recommended to use a Gradle dependency on &lt;code&gt;kotlin-stdlib-js&lt;/code&gt;, it is also available on NPM as the &lt;a href=&quot;https://www.npmjs.com/package/kotlin&quot;&gt;&lt;code&gt;kotlin&lt;/code&gt;&lt;/a&gt; package.</source>
          <target state="translated">Kotlinは、Kotlin / JS標準ライブラリとともに単一のファイルとして配布されます。このファイル自体はUMDモジュールとしてコンパイルされるため、上記の任意のモジュールシステムで使用できます。Kotlin / JSのほとんどのユースケースでは、 &lt;code&gt;kotlin-stdlib-js&lt;/code&gt; へのGradle依存関係を使用することをお勧めしますが、NPMでは&lt;a href=&quot;https://www.npmjs.com/package/kotlin&quot;&gt; &lt;code&gt;kotlin&lt;/code&gt; &lt;/a&gt;パッケージとしても利用できます。</target>
        </trans-unit>
        <trans-unit id="0bb12b617173b78ae2213fea703120a48dac83b8" translate="yes" xml:space="preserve">
          <source>Kotlin is inspired by existing languages such as Java, C#, JavaScript, Scala and Groovy. We've tried to ensure that Kotlin is easy to learn, so that people can easily jump on board, reading and writing Kotlin in a matter of days. Learning idiomatic Kotlin and using some more of its advanced features can take a little longer, but overall it is not a complicated language.</source>
          <target state="translated">Kotlinは、Java、C#、JavaScript、Scala、Groovyなどの既存の言語に触発されています。私たちは、Kotlinが簡単に学べるように心がけていますので、数日でKotlinを読み書きできるようになります。慣用的なKotlinの学習や高度な機能を使うには少し時間がかかるかもしれませんが、全体的には複雑な言語ではありません。</target>
        </trans-unit>
        <trans-unit id="62c8094d2f49ea185993571453009f8f90b8b387" translate="yes" xml:space="preserve">
          <source>Kotlin is more concise. Rough estimates indicate approximately a 40% cut in the number of lines of code. It&amp;rsquo;s also more type-safe, e.g. support for non-nullable types makes applications less prone to NPE&amp;rsquo;s. Other features including smart casting, higher-order functions, extension functions and lambdas with receivers provide the ability to write expressive code as well as facilitating creation of DSL.</source>
          <target state="translated">Kotlinはより簡潔です。概算では、コードの行数が約40％削減されています。また、タイプセーフです。たとえば、null可能でない型のサポートにより、アプリケーションがNPEになりにくくなります。スマートキャスティング、高次関数、拡張関数、レシーバー付きのラムダなどの他の機能により、表現力豊かなコードを記述し、DSLの作成を容易にすることができます。</target>
        </trans-unit>
        <trans-unit id="57ebc857aaa4fe4ee76557729aedd97eb250b716" translate="yes" xml:space="preserve">
          <source>Kotlin is primarily developed by a team of engineers at JetBrains (current team size is 100+). The lead language designer is &lt;a href=&quot;https://twitter.com/abreslav&quot;&gt;Andrey Breslav&lt;/a&gt;. In addition to the core team, there are also over 250 external contributors on GitHub.</source>
          <target state="translated">Kotlinは、主にJetBrainsのエンジニアチームによって開発されています（現在のチームサイズは100以上です）。主な言語デザイナーは&lt;a href=&quot;https://twitter.com/abreslav&quot;&gt;AndreyBreslav&lt;/a&gt;です。コアチームに加えて、GitHubには250人を超える外部の貢献者もいます。</target>
        </trans-unit>
        <trans-unit id="8a6891160d562ed8798489fdde041cf7382a9267" translate="yes" xml:space="preserve">
          <source>Kotlin is primarily developed by a team of engineers at JetBrains (current team size is 50+). The lead language designer is &lt;a href=&quot;https://twitter.com/abreslav&quot;&gt;Andrey Breslav&lt;/a&gt;. In addition to the core team, there are also over 250 external contributors on GitHub.</source>
          <target state="translated">Kotlinは主にJetBrainsのエンジニアのチームによって開発されています（現在のチームサイズは50歳以上）。主要言語デザイナーは&lt;a href=&quot;https://twitter.com/abreslav&quot;&gt;Andrey Breslav&lt;/a&gt;です。コアチームに加えて、GitHubには250人を超える外部の寄稿者がいます。</target>
        </trans-unit>
        <trans-unit id="e252e4cd43e2222ef996694efabbf2a368b1568c" translate="yes" xml:space="preserve">
          <source>Kotlin is supported by all major Java IDEs including &lt;a href=&quot;../tutorials/getting-started&quot;&gt;IntelliJ IDEA&lt;/a&gt;, &lt;a href=&quot;../tutorials/kotlin-android&quot;&gt;Android Studio&lt;/a&gt;, &lt;a href=&quot;../tutorials/getting-started-eclipse&quot;&gt;Eclipse&lt;/a&gt; and &lt;a href=&quot;http://plugins.netbeans.org/plugin/68590/kotlin&quot;&gt;NetBeans&lt;/a&gt;. In addition, a &lt;a href=&quot;../tutorials/command-line&quot;&gt;command line compiler&lt;/a&gt; is available and provides straightforward support for compiling and running applications.</source>
          <target state="translated">Kotlinは、&lt;a href=&quot;../tutorials/getting-started&quot;&gt;IntelliJ IDEA&lt;/a&gt;、&lt;a href=&quot;../tutorials/kotlin-android&quot;&gt;Android Studio&lt;/a&gt;、&lt;a href=&quot;../tutorials/getting-started-eclipse&quot;&gt;Eclipse&lt;/a&gt;、&lt;a href=&quot;http://plugins.netbeans.org/plugin/68590/kotlin&quot;&gt;NetBeans&lt;/a&gt;を含むすべての主要なJava IDEでサポートされています。さらに、&lt;a href=&quot;../tutorials/command-line&quot;&gt;コマンドラインコンパイラ&lt;/a&gt;を利用でき、アプリケーションのコンパイルと実行を簡単にサポートできます。</target>
        </trans-unit>
        <trans-unit id="8b9c46bf1ad2fe2fbc414ecfb85cf4b65bec1ff6" translate="yes" xml:space="preserve">
          <source>Kotlin is supported by all major Java IDEs including &lt;a href=&quot;../tutorials/jvm-get-started&quot;&gt;IntelliJ IDEA&lt;/a&gt;, &lt;a href=&quot;https://developer.android.com/kotlin/get-started&quot;&gt;Android Studio&lt;/a&gt;, &lt;a href=&quot;../tutorials/getting-started-eclipse&quot;&gt;Eclipse&lt;/a&gt; and &lt;a href=&quot;http://plugins.netbeans.org/plugin/68590/kotlin&quot;&gt;NetBeans&lt;/a&gt;. In addition, a &lt;a href=&quot;../tutorials/command-line&quot;&gt;command line compiler&lt;/a&gt; is available and provides straightforward support for compiling and running applications.</source>
          <target state="translated">Kotlinは、&lt;a href=&quot;../tutorials/jvm-get-started&quot;&gt;IntelliJ IDEA&lt;/a&gt;、&lt;a href=&quot;https://developer.android.com/kotlin/get-started&quot;&gt;Android Studio&lt;/a&gt;、&lt;a href=&quot;../tutorials/getting-started-eclipse&quot;&gt;Eclipse&lt;/a&gt;、&lt;a href=&quot;http://plugins.netbeans.org/plugin/68590/kotlin&quot;&gt;NetBeans&lt;/a&gt;を含むすべての主要なJavaIDEでサポートされています。さらに、&lt;a href=&quot;../tutorials/command-line&quot;&gt;コマンドラインコンパイラ&lt;/a&gt;が利用可能であり、アプリケーションのコンパイルと実行を簡単にサポートします。</target>
        </trans-unit>
        <trans-unit id="38b8eb152c426ee3fe939706153705b8354595aa" translate="yes" xml:space="preserve">
          <source>Kotlin is well covered in online courses, check out recommended courses here:</source>
          <target state="translated">Kotlinはオンラインコースでもしっかりとカバーしていますので、おすすめのコースはこちらからチェックしてみてください。</target>
        </trans-unit>
        <trans-unit id="f6275eeb32172070d309b650be85e7156b1c7dc9" translate="yes" xml:space="preserve">
          <source>Kotlin lets you choose the version of JVM for execution. By default, the Kotlin/JVM compiler produces Java 6 compatible bytecode. If you want to make use of optimizations available in newer versions of Java, you can explicitly specify the target Java version from 8 to 13. Note that in this case the resulting bytecode might not run on lower versions.</source>
          <target state="translated">Kotlinでは、実行するJVMのバージョンを選択することができます。デフォルトでは、Kotlin/JVMコンパイラはJava 6互換のバイトコードを生成します。新しいバージョンのJavaで利用できる最適化を利用したい場合は、ターゲットとなるJavaのバージョンを8から13の間で明示的に指定することができます。この場合、生成されたバイトコードはそれ以下のバージョンでは動作しないかもしれないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="47b75c21f1512e55023917a6b77552862460e120" translate="yes" xml:space="preserve">
          <source>Kotlin lets you easily create ranges of values using the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/range-to&quot;&gt;&lt;code&gt;rangeTo()&lt;/code&gt;&lt;/a&gt; function from the &lt;code&gt;kotlin.ranges&lt;/code&gt; package and its operator form &lt;code&gt;..&lt;/code&gt;. Usually, &lt;code&gt;rangeTo()&lt;/code&gt; is complemented by &lt;code&gt;in&lt;/code&gt; or &lt;code&gt;!in&lt;/code&gt; functions.</source>
          <target state="translated">Kotlinは、あなたが簡単に使用して値の範囲を作成することができます&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/range-to&quot;&gt; &lt;code&gt;rangeTo()&lt;/code&gt; &lt;/a&gt;から関数 &lt;code&gt;kotlin.ranges&lt;/code&gt; のパッケージとそのオペレータのフォームを &lt;code&gt;..&lt;/code&gt; .。通常、 &lt;code&gt;rangeTo()&lt;/code&gt; によって補完される &lt;code&gt;in&lt;/code&gt; または &lt;code&gt;!in&lt;/code&gt; 機能します。</target>
        </trans-unit>
        <trans-unit id="ceee386e40b3b46c69160d750c22ce62d0c3f184" translate="yes" xml:space="preserve">
          <source>Kotlin lets you manipulate collections independently of the exact type of objects stored in them. In other words, you add a &lt;code&gt;String&lt;/code&gt; to a list of &lt;code&gt;String&lt;/code&gt;s the same way as you would do with &lt;code&gt;Int&lt;/code&gt;s or a user-defined class. So, the Kotlin Standard Library offers generic interfaces, classes, and functions for creating, populating, and managing collections of any type.</source>
          <target state="translated">Kotlinでは、コレクションに格納されているオブジェクトの正確なタイプとは関係なく、コレクションを操作できます。言い換えれば、あなたは追加 &lt;code&gt;String&lt;/code&gt; リストに &lt;code&gt;String&lt;/code&gt; あなたがするだろうとの同様 &lt;code&gt;Int&lt;/code&gt; Sまたはユーザー定義クラス。したがって、Kotlin標準ライブラリは、あらゆるタイプのコレクションを作成、入力、および管理するための汎用インターフェイス、クラス、および関数を提供します。</target>
        </trans-unit>
        <trans-unit id="a804893fba1e9dc304662ad5aa9e7244e8ba7e41" translate="yes" xml:space="preserve">
          <source>Kotlin libraries</source>
          <target state="translated">Kotlin ライブラリ</target>
        </trans-unit>
        <trans-unit id="8bb9f52709d9b5cdac5f51755d862ecbca9c415c" translate="yes" xml:space="preserve">
          <source>Kotlin metadata</source>
          <target state="translated">Kotlin メタデータ</target>
        </trans-unit>
        <trans-unit id="0e7ef1544d45f6a307acf242d3ddb29c611697ae" translate="yes" xml:space="preserve">
          <source>Kotlin modules can be used in Swift/Objective-C code if compiled into a framework (see &quot;Targets and output kinds&quot; section in &lt;a href=&quot;gradle_plugin#targets-and-output-kinds&quot;&gt;Gradle plugin documentation&lt;/a&gt;). See &lt;a href=&quot;https://github.com/JetBrains/kotlin-native/tree/master/samples/calculator&quot;&gt;calculator sample&lt;/a&gt; for an example.</source>
          <target state="translated">Kotlinモジュールは、フレームワークにコンパイルされている場合、Swift / Objective-Cコードで使用できます（&lt;a href=&quot;gradle_plugin#targets-and-output-kinds&quot;&gt;Gradleプラグインのドキュメントの&lt;/a&gt;「ターゲットと出力の種類」セクションを参照）。例については、&lt;a href=&quot;https://github.com/JetBrains/kotlin-native/tree/master/samples/calculator&quot;&gt;電卓のサンプル&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="5f16158d7bd59887136035c889e332065c93a9e3" translate="yes" xml:space="preserve">
          <source>Kotlin multiplatform projects use compilations for producing artifacts. Each target can have one or more compilations, for example, for production and test purposes.</source>
          <target state="translated">Kotlin のマルチプラットフォームプロジェクトでは、成果物を生成するためにコンパイルを使用します。それぞれのターゲットは、例えば、プロダクションやテストのために、1つ以上のコンパイルを持つことができます。</target>
        </trans-unit>
        <trans-unit id="a0c9d0d836710fc155aae7ff2099c119f8b8ff3b" translate="yes" xml:space="preserve">
          <source>Kotlin now integrates with the &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/javax/script/package-summary.html&quot;&gt;javax.script API&lt;/a&gt; (JSR-223). The API allows to evaluate snippets of code at runtime:</source>
          <target state="translated">Kotlinが&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/javax/script/package-summary.html&quot;&gt;javax.script API&lt;/a&gt;（JSR-223）と統合されるようになりました。APIを使用すると、実行時にコードのスニペットを評価できます。</target>
        </trans-unit>
        <trans-unit id="5917b5d1de587466aad2c24c7e35497e2343f72e" translate="yes" xml:space="preserve">
          <source>Kotlin now supports storing parameter names in the bytecode. This can be enabled using the &lt;code&gt;-java-parameters&lt;/code&gt; command line option.</source>
          <target state="translated">Kotlinは、バイトコードへのパラメーター名の格納をサポートするようになりました。これは、 &lt;code&gt;-java-parameters&lt;/code&gt; コマンドラインオプションを使用して有効にできます。</target>
        </trans-unit>
        <trans-unit id="900f5e70ca199686eb62d660ad48f2ce1610ab30" translate="yes" xml:space="preserve">
          <source>Kotlin numeric types, except for &lt;code&gt;kotlin.Long&lt;/code&gt; are mapped to JavaScript Number.</source>
          <target state="translated">&lt;code&gt;kotlin.Long&lt;/code&gt; を除くKotlin数値型は、JavaScript番号にマップされます。</target>
        </trans-unit>
        <trans-unit id="fa0f528e5b1ad066646e40d867c682edc345e3d1" translate="yes" xml:space="preserve">
          <source>Kotlin objects could be pinned, i.e. their position in memory is guaranteed to be stable until unpinned, and pointers to such objects inner data could be passed to the C functions. For example</source>
          <target state="translated">Kotlin オブジェクトを固定することができます。つまり、固定されていない状態になるまでメモリ上での位置が安定していることが保証されており、そのようなオブジェクトの内部データへのポインタを C 関数に渡すことができます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="23971a8580dfc32441ac3140ce5ff12ac8ef11bf" translate="yes" xml:space="preserve">
          <source>Kotlin plugin 1.3.21 or higher should be installed in the IDE. This can be verified via &lt;em&gt;Language &amp;amp; Frameworks | Kotlin Updates&lt;/em&gt; section in the &lt;em&gt;Settings&lt;/em&gt; (or &lt;em&gt;Preferences&lt;/em&gt;) of the IDE.</source>
          <target state="translated">IDEにはKotlinプラグイン1.3.21以降がインストールされている必要があります。&lt;em&gt;言語とフレームワークで&lt;/em&gt;確認できます&lt;em&gt;| &lt;/em&gt;IDEの&lt;em&gt;[設定]&lt;/em&gt;（または&lt;em&gt;[設定&lt;/em&gt;&lt;em&gt;]&lt;/em&gt;）の&lt;em&gt;Kotlin更新&lt;/em&gt;セクション。</target>
        </trans-unit>
        <trans-unit id="446a5a46278f3d1273d1c8d81bcdc944823353d2" translate="yes" xml:space="preserve">
          <source>Kotlin plugin for IntelliJ IDEA supports &lt;a href=&quot;https://www.jetbrains.com/help/idea/scratches.html&quot;&gt;scratches&lt;/a&gt;. Scratches let you create code drafts in the same IDE window with your project and run them on the fly. Scratches are not tied to projects; you can access and run all your scratches from any IntelliJ IDEA window on your OS.</source>
          <target state="translated">IntelliJ IDEAのKotlinプラグインは&lt;a href=&quot;https://www.jetbrains.com/help/idea/scratches.html&quot;&gt;スクラッチを&lt;/a&gt;サポートしています。スクラッチを使用すると、プロジェクトと同じIDEウィンドウでコードドラフトを作成し、その場で実行できます。スクラッチはプロジェクトに関連付けられていません。OSのIntelliJ IDEAウィンドウからすべてのスクラッチにアクセスして実行できます。</target>
        </trans-unit>
        <trans-unit id="bf764bc84647534de5f2a7804f4aa2d9d548f9f9" translate="yes" xml:space="preserve">
          <source>Kotlin preserves lazy object initialization in JavaScript.</source>
          <target state="translated">Kotlin は JavaScript での遅延オブジェクトの初期化を保持します。</target>
        </trans-unit>
        <trans-unit id="69aede4d1ffe657e5907011bd8394bcc0601690e" translate="yes" xml:space="preserve">
          <source>Kotlin preserves overflow semantics for &lt;code&gt;kotlin.Int&lt;/code&gt;, &lt;code&gt;kotlin.Byte&lt;/code&gt;, &lt;code&gt;kotlin.Short&lt;/code&gt;, &lt;code&gt;kotlin.Char&lt;/code&gt; and &lt;code&gt;kotlin.Long&lt;/code&gt;.</source>
          <target state="translated">Kotlinはオーバーフロー用のセマンティクス保存し &lt;code&gt;kotlin.Int&lt;/code&gt; 、 &lt;code&gt;kotlin.Byte&lt;/code&gt; 、 &lt;code&gt;kotlin.Short&lt;/code&gt; 、 &lt;code&gt;kotlin.Char&lt;/code&gt; と &lt;code&gt;kotlin.Long&lt;/code&gt; を。</target>
        </trans-unit>
        <trans-unit id="2849a08507ed289fb75d76677103722db661daba" translate="yes" xml:space="preserve">
          <source>Kotlin primitive type boxes are mapped to special Swift/Objective-C classes. For example, &lt;code&gt;kotlin.Int&lt;/code&gt; box is represented as &lt;code&gt;KotlinInt&lt;/code&gt; class instance in Swift (or &lt;code&gt;${prefix}Int&lt;/code&gt; instance in Objective-C, where &lt;code&gt;prefix&lt;/code&gt; is the framework names prefix). These classes are derived from &lt;code&gt;NSNumber&lt;/code&gt;, so the instances are proper &lt;code&gt;NSNumber&lt;/code&gt;s supporting all corresponding operations.</source>
          <target state="translated">Kotlinプリミティブ型ボックスは、特別なSwift / Objective-Cクラスにマップされます。たとえば、 &lt;code&gt;kotlin.Int&lt;/code&gt; ボックスは、Swift &lt;code&gt;KotlinInt&lt;/code&gt; クラスインスタンス（またはObjective-Cでは &lt;code&gt;${prefix}Int&lt;/code&gt; インスタンス、 &lt;code&gt;prefix&lt;/code&gt; はフレームワーク名のプレフィックス）として表されます。これらのクラスは &lt;code&gt;NSNumber&lt;/code&gt; から派生しているため、インスタンスは対応するすべての操作をサポートする適切な &lt;code&gt;NSNumber&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="a7ceca5755070f2e75db1f8f41e2c1a411bf045a" translate="yes" xml:space="preserve">
          <source>Kotlin primitive types</source>
          <target state="translated">コトリン基本型</target>
        </trans-unit>
        <trans-unit id="231e51698e1b22447348936da3858b45208fbb94" translate="yes" xml:space="preserve">
          <source>Kotlin projects require a recent version of Gradle</source>
          <target state="translated">Kotlin プロジェクトには最新バージョンの Gradle が必要です。</target>
        </trans-unit>
        <trans-unit id="56d4abf280a1b7394ae7fdfbb57bfe9eaca646d5" translate="yes" xml:space="preserve">
          <source>Kotlin properties declared in a named object or a companion object will have static backing fields either in that named object or in the class containing the companion object.</source>
          <target state="translated">名前付きオブジェクトやコンパニオンオブジェクトで宣言されたKotlinプロパティは、その名前付きオブジェクトかコンパニオンオブジェクトを含むクラスのどちらかに静的なバッキングフィールドを持ちます。</target>
        </trans-unit>
        <trans-unit id="b0f8122e9d8ea69357864a2385801f06d58ec608" translate="yes" xml:space="preserve">
          <source>Kotlin provides &lt;a href=&quot;native/c_interop&quot;&gt;interoperability with native languages&lt;/a&gt; and DSL to configure this for a specific compilation.</source>
          <target state="translated">Kotlinは&lt;a href=&quot;native/c_interop&quot;&gt;、ネイティブ言語&lt;/a&gt;およびDSLとの相互運用性を提供して、特定のコンパイル用にこれを構成します。</target>
        </trans-unit>
        <trans-unit id="cf2e0c6a8a702a4b4cb47d5f81663fe43b024e43" translate="yes" xml:space="preserve">
          <source>Kotlin provides a series of compiler options that are accessible in IntelliJ IDEA also. In addition to the one we've just seen for generating source maps, we also have the ability to set</source>
          <target state="translated">Kotlinには、IntelliJ IDEAでもアクセス可能な一連のコンパイラオプションが用意されています。先ほど見たソースマップを生成するためのものの他にも</target>
        </trans-unit>
        <trans-unit id="e2142c523bbfdb03dd37f333a0ce0922e05e00a3" translate="yes" xml:space="preserve">
          <source>Kotlin provides a set of built-in types that represent numbers.</source>
          <target state="translated">Kotlinは数値を表す組み込み型のセットを提供しています。</target>
        </trans-unit>
        <trans-unit id="0a113f99eec74b4131a54c5b784be8df823aef27" translate="yes" xml:space="preserve">
          <source>Kotlin provides a variety of functions to execute a block of code in the context of a given object: &lt;code&gt;let&lt;/code&gt;, &lt;code&gt;run&lt;/code&gt;, &lt;code&gt;with&lt;/code&gt;, &lt;code&gt;apply&lt;/code&gt;, and &lt;code&gt;also&lt;/code&gt;. For the guidance on choosing the right scope function for your case, refer to &lt;a href=&quot;scope-functions&quot;&gt;Scope Functions&lt;/a&gt;.</source>
          <target state="translated">：Kotlinは、指定されたオブジェクトのコンテキストでコードのブロックを実行するためにさまざまな機能を提供 &lt;code&gt;let&lt;/code&gt; 、 &lt;code&gt;run&lt;/code&gt; 、 &lt;code&gt;with&lt;/code&gt; 、 &lt;code&gt;apply&lt;/code&gt; 、および &lt;code&gt;also&lt;/code&gt; 。あなたのケースのための右のスコープ機能の選択に関するガイダンスについては、を参照してください&lt;a href=&quot;scope-functions&quot;&gt;スコープ機能&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9bdbfc816d9da34f310288932621f6005bd4a635" translate="yes" xml:space="preserve">
          <source>Kotlin provides so called &lt;strong&gt;star-projection&lt;/strong&gt; syntax for this:</source>
          <target state="translated">Kotlinは、このためのいわゆる&lt;strong&gt;スター投影&lt;/strong&gt;構文を提供しています。</target>
        </trans-unit>
        <trans-unit id="a7357de7d14d7d6aa1f1f673c4bd660028007794" translate="yes" xml:space="preserve">
          <source>Kotlin provides the ability to extend a class with new functionality without having to inherit from the class or use design patterns such as Decorator. This is done via special declarations called &lt;em&gt;extensions&lt;/em&gt;. For example, you can write new functions for a class from a third-party library that you can't modify. Such functions are available for calling in the usual way as if they were methods of the original class. This mechanism is called &lt;em&gt;extension functions&lt;/em&gt;. There are also &lt;em&gt;extension properties&lt;/em&gt; that let you define new properties for existing classes.</source>
          <target state="translated">Kotlinは、クラスから継承したり、Decoratorなどのデザインパターンを使用したりすることなく、新しい機能でクラスを拡張する機能を提供します。これは、&lt;em&gt;拡張機能&lt;/em&gt;と呼ばれる特別な宣言を介して行われます。たとえば、変更できないサードパーティのライブラリからクラスの新しい関数を作成できます。このような関数は、元のクラスのメソッドであるかのように、通常の方法で呼び出すことができます。このメカニズムは&lt;em&gt;拡張機能&lt;/em&gt;と呼ばれ&lt;em&gt;ます&lt;/em&gt;。既存のクラスの新しいプロパティを定義できる&lt;em&gt;拡張プロパティ&lt;/em&gt;もあります。</target>
        </trans-unit>
        <trans-unit id="45eae3e9e04c057fe2a9ce2b00c2b1626952c923" translate="yes" xml:space="preserve">
          <source>Kotlin provides the ability to target JavaScript. It does so by transpiling Kotlin to JavaScript. The current implementation targets ECMAScript 5.1 but there are plans to eventually target ECMAScript 2015 as well.</source>
          <target state="translated">Kotlin は JavaScript をターゲットにする機能を提供します。これは、KotlinをJavaScriptにトランスパイリングすることで行います。現在の実装は ECMAScript 5.1 をターゲットにしていますが、最終的には ECMAScript 2015 もターゲットにする予定です。</target>
        </trans-unit>
        <trans-unit id="1d361e832e7fbd8cbfa474feeaaf4e3060965e0c" translate="yes" xml:space="preserve">
          <source>Kotlin provides the following built-in types representing numbers (this is close to Java):</source>
          <target state="translated">Kotlinには、数値を表す以下の組み込み型が用意されています(これはJavaに近いです)。</target>
        </trans-unit>
        <trans-unit id="bcb1ec23fd44ea30c0c43e5be53b38271d9f8878" translate="yes" xml:space="preserve">
          <source>Kotlin provides three tasks for Ant:</source>
          <target state="translated">コトリンはAntに3つのタスクを提供しています。</target>
        </trans-unit>
        <trans-unit id="d32683bae75ae112d7b7ae383176964359ce8293" translate="yes" xml:space="preserve">
          <source>Kotlin requires that every member property is initialized during instance construction. Sometimes, a class is intended to be used in such a way that the constructor doesn't have enough information to initialize all properties (such as when making a builder class or when using property-based dependency injection). In order to not have to make those properties nullable, you can use a &lt;em&gt;late-initialized property&lt;/em&gt;:</source>
          <target state="translated">Kotlinでは、インスタンスの構築中にすべてのメンバープロパティを初期化する必要があります。場合によっては、クラスが、コンストラクターがすべてのプロパティを初期化するのに十分な情報を持たないような方法で使用されることを目的としています（ビルダークラスを作成するとき、またはプロパティベースの依存関係注入を使用するときなど）。これらのプロパティをnull可能にする必要がないようにするために、&lt;em&gt;遅延初期化プロパティを&lt;/em&gt;使用でき&lt;em&gt;ます&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="b6c82522c1d0ee2c933047e31fffeca6f833ef7e" translate="yes" xml:space="preserve">
          <source>Kotlin scripts in &lt;code&gt;build.gradle.kts&lt;/code&gt; files</source>
          <target state="translated">&lt;code&gt;build.gradle.kts&lt;/code&gt; ファイル内のKotlinスクリプト</target>
        </trans-unit>
        <trans-unit id="120e9cfe3ecde2244c4b2038cf0d5e11c76827a7" translate="yes" xml:space="preserve">
          <source>Kotlin singleton (made with an &lt;code&gt;object&lt;/code&gt; declaration, including &lt;code&gt;companion object&lt;/code&gt;) is imported to Swift/Objective-C as a class with a single instance. The instance is available through the factory method, i.e. as &lt;code&gt;[MySingleton mySingleton]&lt;/code&gt; in Objective-C and &lt;code&gt;MySingleton()&lt;/code&gt; in Swift.</source>
          <target state="translated">Kotlinシングルトン（ &lt;code&gt;companion object&lt;/code&gt; を含む &lt;code&gt;object&lt;/code&gt; 宣言で作成）は、単一のインスタンスを持つクラスとしてSwift / Objective-Cにインポートされます。インスタンスは、ファクトリメソッドを介して、つまりObjective-Cでは &lt;code&gt;[MySingleton mySingleton]&lt;/code&gt; として、Swift &lt;code&gt;MySingleton()&lt;/code&gt; として使用できます。</target>
        </trans-unit>
        <trans-unit id="bea729ea75b1b1e606f056a5012e91fb52a83a74" translate="yes" xml:space="preserve">
          <source>Kotlin singletons</source>
          <target state="translated">コトリンシングルトン</target>
        </trans-unit>
        <trans-unit id="a2394b4a95a3420db31c70572b58364d6b98a0c6" translate="yes" xml:space="preserve">
          <source>Kotlin source file or directory to compile</source>
          <target state="translated">コンパイルする Kotlin ソースファイルまたはディレクトリ</target>
        </trans-unit>
        <trans-unit id="e2f631b0ebe5da9da1b87daae220f0696369b117" translate="yes" xml:space="preserve">
          <source>Kotlin source sets may be connected with the &lt;em&gt;'depends on'&lt;/em&gt; relation, so that if a source set &lt;code&gt;foo&lt;/code&gt; depends on a source set &lt;code&gt;bar&lt;/code&gt; then:</source>
          <target state="translated">Kotlinソースセットは&lt;em&gt;「依存」&lt;/em&gt;関係に関連付けられている場合があるため、ソースセット &lt;code&gt;foo&lt;/code&gt; がソースセット &lt;code&gt;bar&lt;/code&gt; 依存する場合は、次のようになります。</target>
        </trans-unit>
        <trans-unit id="3806de1d34a4bca588a5784ceb856faa4c1b15c6" translate="yes" xml:space="preserve">
          <source>Kotlin sources can be mixed with Java sources in the same folder, or in different folders. The default convention is using different folders:</source>
          <target state="translated">Kotlin のソースと Java のソースを同じフォルダに入れたり、別のフォルダに入れたりすることができます。デフォルトでは異なるフォルダを使用しています。</target>
        </trans-unit>
        <trans-unit id="8dda6be52af63434ddc539d85c3f07ae2c8c8de5" translate="yes" xml:space="preserve">
          <source>Kotlin sources can be stored with Java sources in the same folder, or placed to different folders. The default convention is using different folders:</source>
          <target state="translated">Kotlin のソースは Java ソースと一緒に同じフォルダに保存したり、別のフォルダに配置したりすることができます。デフォルトでは異なるフォルダを使用しています。</target>
        </trans-unit>
        <trans-unit id="448431d8ccbcd8c407715ad54cff923c4f538ad6" translate="yes" xml:space="preserve">
          <source>Kotlin standard libraries</source>
          <target state="translated">Kotlin 標準ライブラリ</target>
        </trans-unit>
        <trans-unit id="742632ac6e0e85caf1c4f062cccebafab2dafb01" translate="yes" xml:space="preserve">
          <source>Kotlin standard library artifacts and split packages</source>
          <target state="translated">Kotlin 標準ライブラリのアーティファクトとスプリットパッケージ</target>
        </trans-unit>
        <trans-unit id="77cb00a3ce7a3cdab1c1c157be47f7632c70f806" translate="yes" xml:space="preserve">
          <source>Kotlin subclasses of Objective-C classes</source>
          <target state="translated">Objective-CクラスのKotlinサブクラス</target>
        </trans-unit>
        <trans-unit id="2607bec52d42f747a5225384e349fc0ccef2ced7" translate="yes" xml:space="preserve">
          <source>Kotlin supports SAM conversions for both Java and &lt;a href=&quot;fun-interfaces&quot;&gt;Kotlin interfaces&lt;/a&gt;. This support for Java means that Kotlin function literals can be automatically converted into implementations of Java interfaces with a single non-default method, as long as the parameter types of the interface method match the parameter types of the Kotlin function.</source>
          <target state="translated">Kotlinは、Java&lt;a href=&quot;fun-interfaces&quot;&gt;インターフェイス&lt;/a&gt;とKotlinインターフェイスの両方でSAM変換をサポートしています。このJavaのサポートは、インターフェイスメソッドのパラメータタイプがKotlin関数のパラメータタイプと一致する限り、Kotlin関数リテラルを単一のデフォルト以外のメソッドでJavaインターフェイスの実装に自動的に変換できることを意味します。</target>
        </trans-unit>
        <trans-unit id="e4a28ec1a46419f171d723ee46383588cd9c1cbc" translate="yes" xml:space="preserve">
          <source>Kotlin supports a style of functional programming known as &lt;a href=&quot;https://en.wikipedia.org/wiki/Tail_call&quot;&gt;tail recursion&lt;/a&gt;. This allows some algorithms that would normally be written using loops to instead be written using a recursive function, but without the risk of stack overflow. When a function is marked with the &lt;code&gt;tailrec&lt;/code&gt; modifier and meets the required form, the compiler optimises out the recursion, leaving behind a fast and efficient loop based version instead:</source>
          <target state="translated">Kotlinは、&lt;a href=&quot;https://en.wikipedia.org/wiki/Tail_call&quot;&gt;末尾再帰と&lt;/a&gt;呼ばれる関数型プログラミングのスタイルをサポートしています。これにより、通常ループを使用して記述される一部のアルゴリズムを、代わりに再帰関数を使用して記述できますが、スタックオーバーフローのリスクはありません。関数が &lt;code&gt;tailrec&lt;/code&gt; 修飾子でマークされ、必要な形式を満たすと、コンパイラーは再帰を最適化し、代わりに高速で効率的なループベースのバージョンを残します。</target>
        </trans-unit>
        <trans-unit id="a2baed6c5430ce0572e2f1a5bae6b4631f0f1c73" translate="yes" xml:space="preserve">
          <source>Kotlin supports a style of functional programming known as &lt;a href=&quot;https://en.wikipedia.org/wiki/Tail_call&quot;&gt;tail recursion&lt;/a&gt;. This allows some algorithms that would normally be written using loops to instead be written using a recursive function, but without the risk of stack overflow. When a function is marked with the &lt;code&gt;tailrec&lt;/code&gt; modifier and meets the required form, the compiler optimizes out the recursion, leaving behind a fast and efficient loop based version instead:</source>
          <target state="translated">Kotlinは、&lt;a href=&quot;https://en.wikipedia.org/wiki/Tail_call&quot;&gt;末尾再帰と&lt;/a&gt;呼ばれる関数型プログラミングのスタイルをサポートしています。これにより、通常はループを使用して記述される一部のアルゴリズムを、代わりに再帰関数を使用して記述できますが、スタックオーバーフローのリスクはありません。関数が &lt;code&gt;tailrec&lt;/code&gt; 修飾子でマークされ、必要な形式を満たすと、コンパイラーは再帰を最適化し、代わりに高速で効率的なループベースのバージョンを残します。</target>
        </trans-unit>
        <trans-unit id="f764f32b8a5f60d7b0c651002320db85fd7d539f" translate="yes" xml:space="preserve">
          <source>Kotlin supports annonation processing via the &lt;em&gt;Kotlin annotation processing tool&lt;/em&gt;(&lt;code&gt;kapt&lt;/code&gt;). Usage of kapt with Gradle is described on the &lt;a href=&quot;kapt&quot;&gt;kapt page&lt;/a&gt;.</source>
          <target state="translated">Kotlinは、&lt;em&gt;Kotlin注釈処理ツール&lt;/em&gt;（ &lt;code&gt;kapt&lt;/code&gt; ）による&lt;em&gt;注釈&lt;/em&gt;処理をサポートしています。Gradleでのkaptの使用法については、&lt;a href=&quot;kapt&quot;&gt;kaptページで&lt;/a&gt;説明しています。</target>
        </trans-unit>
        <trans-unit id="13f5d747f019181c1a771753e56710d47a2bbad6" translate="yes" xml:space="preserve">
          <source>Kotlin supports annonation processing via the Kotlin annotation processing tool &lt;a href=&quot;kapt&quot;&gt;&lt;code&gt;kapt&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Kotlinは、Kotlinアノテーション処理ツール&lt;a href=&quot;kapt&quot;&gt; &lt;code&gt;kapt&lt;/code&gt; を&lt;/a&gt;介したアノテーション処理をサポートしています。</target>
        </trans-unit>
        <trans-unit id="92bcfac7403d3cddfb4464119a784d92d81f9f9d" translate="yes" xml:space="preserve">
          <source>Kotlin supports local functions, i.e. a function inside another function:</source>
          <target state="translated">Kotlin はローカル関数、つまり別の関数の中にある関数をサポートしています。</target>
        </trans-unit>
        <trans-unit id="282b26637b1a5ff71051d95d88177e34b6cefc30" translate="yes" xml:space="preserve">
          <source>Kotlin supports single-parent class inheritance - so each class (except the root class &lt;code&gt;Any&lt;/code&gt;) has got exactly one parent class, called a &lt;em&gt;superclass&lt;/em&gt;. Kotlin wants you to think through your class design to make sure that it's actually safe to &lt;em&gt;subclass&lt;/em&gt; it, so classes are &lt;em&gt;closed&lt;/em&gt; by default and can't be inherited from unless you explicitly declare the class to be &lt;em&gt;open&lt;/em&gt; or &lt;em&gt;abstract&lt;/em&gt;. You can then subclass from that class by declaring a new class which mentions its parent class after a colon:</source>
          <target state="translated">Kotlinは単一親クラスの継承をサポートしているため、各クラス（ルートクラス &lt;code&gt;Any&lt;/code&gt; を除く）には、&lt;em&gt;スーパークラス&lt;/em&gt;と呼ばれる親クラスが1つだけあり&lt;em&gt;ます&lt;/em&gt;。 Kotlinは、クラス設計を十分に検討して、実際に&lt;em&gt;サブクラス化し&lt;/em&gt;ても安全であることを確認することを求めています。そのため、クラスはデフォルトで&lt;em&gt;閉じ&lt;/em&gt;られており、クラスを&lt;em&gt;open&lt;/em&gt;または&lt;em&gt;abstract&lt;/em&gt;として明示的に宣言しない限り、クラスを継承できません。次に、コロンの後に親クラスを記述する新しいクラスを宣言することにより、そのクラスからサブクラス化できます。</target>
        </trans-unit>
        <trans-unit id="c701dab67e42733a07778c8e90d14a14d6115e0e" translate="yes" xml:space="preserve">
          <source>Kotlin supports the following operators and special symbols:</source>
          <target state="translated">Kotlinは以下の演算子と特殊記号をサポートしています。</target>
        </trans-unit>
        <trans-unit id="a681ed989bc5949117e886914d64403b1862e6f9" translate="yes" xml:space="preserve">
          <source>Kotlin supports the following platforms and provides target presets for each platform. See how to &lt;a href=&quot;mpp-set-up-targets&quot;&gt;use a target preset&lt;/a&gt;.</source>
          <target state="translated">Kotlinは次のプラットフォームをサポートし、各プラットフォームのターゲットプリセットを提供します。&lt;a href=&quot;mpp-set-up-targets&quot;&gt;ターゲットプリセットの使用&lt;/a&gt;方法をご覧ください。</target>
        </trans-unit>
        <trans-unit id="b9f65c39eaf4fcfb17c2f522f10687c0e4404fdb" translate="yes" xml:space="preserve">
          <source>Kotlin supports the standard set of arithmetical operations over numbers (&lt;code&gt;+&lt;/code&gt;&lt;code&gt;-&lt;/code&gt;&lt;code&gt;*&lt;/code&gt;&lt;code&gt;/&lt;/code&gt;&lt;code&gt;%&lt;/code&gt;), which are declared as members of appropriate classes (but the compiler optimizes the calls down to the corresponding instructions). See &lt;a href=&quot;operator-overloading&quot;&gt;Operator overloading&lt;/a&gt;.</source>
          <target state="translated">Kotlinは、適切なクラスのメンバーとして宣言されている数値（ &lt;code&gt;+&lt;/code&gt; &lt;code&gt;-&lt;/code&gt; &lt;code&gt;*&lt;/code&gt; &lt;code&gt;/&lt;/code&gt; &lt;code&gt;%&lt;/code&gt; ）に対する算術演算の標準セットをサポートしています（ただし、コンパイラーは、対応する命令までの呼び出しを最適化します）。&lt;a href=&quot;operator-overloading&quot;&gt;演算子のオーバーロードを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="4887c0a9ca610838532432bde155538452979c8b" translate="yes" xml:space="preserve">
          <source>Kotlin supports the standard set of arithmetical operations over numbers, which are declared as members of appropriate classes (but the compiler optimizes the calls down to the corresponding instructions). See &lt;a href=&quot;operator-overloading&quot;&gt;Operator overloading&lt;/a&gt;.</source>
          <target state="translated">Kotlinは、適切なクラスのメンバーとして宣言されている数値に対する算術演算の標準セットをサポートしています（ただし、コンパイラーは、対応する命令までの呼び出しを最適化します）。&lt;a href=&quot;operator-overloading&quot;&gt;オペレーターのオーバーロードを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="c8bfc686b943f3ad415464d9f2987e93b995ca8c" translate="yes" xml:space="preserve">
          <source>Kotlin supports traditional &lt;em&gt;break&lt;/em&gt; and &lt;em&gt;continue&lt;/em&gt; operators in loops. See &lt;a href=&quot;returns&quot;&gt;Returns and jumps&lt;/a&gt;.</source>
          <target state="translated">Kotlinは、ループで従来の&lt;em&gt;ブレーク&lt;/em&gt;および&lt;em&gt;継続&lt;/em&gt;演算子をサポートしています。&lt;a href=&quot;returns&quot;&gt;リターンとジャンプを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="0d07ef64d55abdae6d6a123db33be555df8316b4" translate="yes" xml:space="preserve">
          <source>Kotlin supports trailing commas in the following cases:</source>
          <target state="translated">Kotlinは以下の場合には末尾のカンマをサポートしています。</target>
        </trans-unit>
        <trans-unit id="d836a05da6a45d7708b37e3a93892db605af05e1" translate="yes" xml:space="preserve">
          <source>Kotlin targets a wide range of the Java versions, including Java 6 and Java 7, where default methods in the interfaces are not allowed. For your convenience, the Kotlin compiler works around that limitation, but this workaround isn't compatible with the &lt;code&gt;default&lt;/code&gt; methods, introduced in Java 8.</source>
          <target state="translated">Kotlinは、インターフェースのデフォルトのメソッドが許可されていないJava 6やJava 7を含む幅広いJavaバージョンを対象としています。便宜上、Kotlinコンパイラはその制限を回避しますが、この回避策はJava 8で導入された &lt;code&gt;default&lt;/code&gt; メソッドと互換性がありません。</target>
        </trans-unit>
        <trans-unit id="7a3c3013cf9e37dd556eb25470f92f220350c10a" translate="yes" xml:space="preserve">
          <source>Kotlin to JavaScript</source>
          <target state="translated">コトリンからJavaScriptへ</target>
        </trans-unit>
        <trans-unit id="09a30aded79f08fdd22e3766d5057679b6cb51d6" translate="yes" xml:space="preserve">
          <source>Kotlin treats some Java types specially. Such types are not loaded from Java &quot;as is&quot;, but are &lt;em&gt;mapped&lt;/em&gt; to corresponding Kotlin types. The mapping only matters at compile time, the runtime representation remains unchanged. Java's primitive types are mapped to corresponding Kotlin types (keeping &lt;a href=&quot;#null-safety-and-platform-types&quot;&gt;platform types&lt;/a&gt; in mind):</source>
          <target state="translated">Kotlinは一部のJavaタイプを特別に扱います。このような型は、Javaから「そのまま」ロードされるのではなく、対応するKotlin型に&lt;em&gt;マップさ&lt;/em&gt;れます。マッピングはコンパイル時にのみ重要であり、ランタイム表現は変更されません。Javaのプリミティブ型は、対応するKotlin型にマッピングされます（&lt;a href=&quot;#null-safety-and-platform-types&quot;&gt;プラットフォームの型&lt;/a&gt;を覚えておいてください）。</target>
        </trans-unit>
        <trans-unit id="768f1e9cdea1a9d60e4596098790dc6c5c883f4f" translate="yes" xml:space="preserve">
          <source>Kotlin turns the function pointer return type into a nullable &lt;code&gt;CPointer&amp;lt;CFunction&amp;lt;..&amp;gt;&lt;/code&gt; object. There is the need to explicitly check for &lt;code&gt;null&lt;/code&gt; first. We use &lt;a href=&quot;../../reference/null-safety&quot;&gt;elvis operator&lt;/a&gt; for that. The &lt;code&gt;cinterop&lt;/code&gt; tool helps us to turn a C function pointer into an easy to call object in Kotlin. This is what we did on the last line.</source>
          <target state="translated">Kotlinは、関数ポインターの戻り値の型をnull可能な &lt;code&gt;CPointer&amp;lt;CFunction&amp;lt;..&amp;gt;&lt;/code&gt; オブジェクトに変換します。最初に明示的に &lt;code&gt;null&lt;/code&gt; をチェックする必要があります。そのために&lt;a href=&quot;../../reference/null-safety&quot;&gt;elvis演算子&lt;/a&gt;を使用します。 &lt;code&gt;cinterop&lt;/code&gt; のツールは、私たちはKotlinでオブジェクトを呼び出すために簡単にC関数ポインタを回すのに役立ちます。これが最後の行で行ったものです。</target>
        </trans-unit>
        <trans-unit id="db8f21bde482b5a130cf00596109ec23d3d336d2" translate="yes" xml:space="preserve">
          <source>Kotlin uses a family of function types like &lt;code&gt;(Int) -&amp;gt; String&lt;/code&gt; for declarations that deal with functions: &lt;code&gt;val onClick: () -&amp;gt; Unit = ...&lt;/code&gt;.</source>
          <target state="translated">Kotlinのような関数型のファミリーの使用 &lt;code&gt;(Int) -&amp;gt; String&lt;/code&gt; の宣言のためにその機能との契約： &lt;code&gt;val onClick: () -&amp;gt; Unit = ...&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bb4aa710f2c72b83ee921d5d3e539487fd005073" translate="yes" xml:space="preserve">
          <source>Kotlin uses the &lt;code&gt;libnative_&lt;/code&gt; prefix for all declarations in the created &lt;code&gt;libnative_api.h&lt;/code&gt; file. Let's present the mapping of the types in a more readable way:</source>
          <target state="translated">Kotlinは、作成された &lt;code&gt;libnative_api.h&lt;/code&gt; ファイルのすべての宣言に &lt;code&gt;libnative_&lt;/code&gt; プレフィックスを使用します。より読みやすい方法で型のマッピングを提示しましょう：</target>
        </trans-unit>
        <trans-unit id="b58121b32bf1a1498b7715228a497191716fd48d" translate="yes" xml:space="preserve">
          <source>Kotlin was designed for easy interoperation with Java platform. It sees Java classes as Kotlin classes, and Java sees Kotlin classes as Java classes. However, JavaScript is a dynamically-typed language, which means it does not check types in compile-time. You can freely talk to JavaScript from Kotlin via &lt;a href=&quot;dynamic-type&quot;&gt;dynamic&lt;/a&gt; types, but if you want the full power of Kotlin type system, you can create Kotlin headers for JavaScript libraries.</source>
          <target state="translated">Kotlinは、Javaプラットフォームと簡単に相互運用できるように設計されています。 JavaクラスはKotlinクラスと見なされ、JavaはKotlinクラスをJavaクラスと見なします。ただし、JavaScriptは動的に型付けされる言語です。つまり、コンパイル時に型をチェックしません。&lt;a href=&quot;dynamic-type&quot;&gt;動的&lt;/a&gt;型を介してKotlinからJavaScriptに自由に通信できますが、Kotlin型システムの全機能を必要とする場合は、JavaScriptライブラリ用のKotlinヘッダーを作成できます。</target>
        </trans-unit>
        <trans-unit id="e4c0f3a3782b90edcee0e70de97ebb0b28520a70" translate="yes" xml:space="preserve">
          <source>Kotlin was first designed for easy interoperation with the Java platform: it sees Java classes as Kotlin classes, and Java sees Kotlin classes as Java classes.</source>
          <target state="translated">KotlinはJavaプラットフォームとの相互運用を容易にするために最初に設計されました。</target>
        </trans-unit>
        <trans-unit id="487d5ff42a3055fc2a4cb28f3d53d445d59f1865" translate="yes" xml:space="preserve">
          <source>Kotlin will allow you to declare this property without initializing it, and you can set the property value at some point after construction (either directly or via a function). It is the responsibility of the class itself as well as its users to take care not to read the property before it has been set, and Kotlin allows you to write code that reads &lt;code&gt;name&lt;/code&gt; as if it were an ordinary, non-nullable property. However, the compiler is unable to enforce correct usage, so if the property is read before it has been set, an &lt;code&gt;UninitializedPropertyAccessException&lt;/code&gt; will be thrown at runtime.</source>
          <target state="translated">Kotlinを使用すると、初期化せずにこのプロパティを宣言でき、構築後のある時点で（直接または関数を介して）プロパティ値を設定できます。プロパティが設定される前にプロパティを読み取らないように注意することは、クラス自体とそのユーザーの責任です。Kotlinを使用すると、 &lt;code&gt;name&lt;/code&gt; を通常のnull不可のプロパティのように読み取るコードを記述できます。ただし、コンパイラーは正しい使用法を適用できません。そのため、プロパティーが設定される前に読み取られた場合、実行時に &lt;code&gt;UninitializedPropertyAccessException&lt;/code&gt; がスローされます。</target>
        </trans-unit>
        <trans-unit id="b3a556e28261e02ebafecde169f3b3513ca13075" translate="yes" xml:space="preserve">
          <source>Kotlin works quite smoothly with Spring Boot and many of the steps found on the &lt;a href=&quot;https://spring.io/guides&quot;&gt;Spring Guides&lt;/a&gt; for creating a RESTful service can be followed verbatim for Kotlin. There are some minor differences however when it comes to defining the Gradle configuration and the project layout structure, as well as the initialization code.</source>
          <target state="translated">Kotlinは、Spring Bootと非常にスムーズに連携します。RESTfulサービスを作成するための&lt;a href=&quot;https://spring.io/guides&quot;&gt;Spring Guides&lt;/a&gt;にある手順の多くは、Kotlinをそのまま使用できます。ただし、Gradle構成とプロジェクトレイアウト構造、および初期化コードの定義に関しては、いくつかの小さな違いがあります。</target>
        </trans-unit>
        <trans-unit id="43ea688f8664ba8f8dabcebd91046161c6146f3c" translate="yes" xml:space="preserve">
          <source>Kotlin works with different &lt;a href=&quot;build-tools&quot;&gt;build tools&lt;/a&gt;, so if we're using a standard tool such as Ant, Maven or Gradle, the process for setting up a Kotlin project is no different to any other language or library that integrates with these tools. Where there are some minor requirements and differences is when using JBS, which is the internal build system that IntelliJ IDEA uses, which is also supported on TeamCity.</source>
          <target state="translated">Kotlinはさまざまな&lt;a href=&quot;build-tools&quot;&gt;ビルドツール&lt;/a&gt;で動作するため、Ant、Maven、Gradleなどの標準ツールを使用している場合、Kotlinプロジェクトを設定するプロセスは、これらのツールと統合する他の言語やライブラリと同じです。いくつかの小さな要件と違いがあるのは、JBSを使用する場合です。これは、IntelliJ IDEAが使用する内部ビルドシステムであり、TeamCityでもサポートされています。</target>
        </trans-unit>
        <trans-unit id="457e307b979be376836ec99d4487123ba8ace79f" translate="yes" xml:space="preserve">
          <source>Kotlin's approach to working with asynchronous code is using coroutines, which is the idea of suspendable computations, i.e. the idea that a function can suspend its execution at some point and resume later on.</source>
          <target state="translated">Kotlinの非同期コードを扱うためのアプローチは、コルーチンを使ったもので、これはサスペンド可能な計算、つまり関数がある時点で実行を一時停止し、後で再開できるという考え方です。</target>
        </trans-unit>
        <trans-unit id="b5ab858d5d3418daf57f2ff97756dc06bfcd23b9" translate="yes" xml:space="preserve">
          <source>Kotlin's documentation generation tool is called &lt;a href=&quot;https://github.com/Kotlin/dokka&quot;&gt;Dokka&lt;/a&gt;. See the &lt;a href=&quot;https://github.com/Kotlin/dokka/blob/master/README.md&quot;&gt;Dokka README&lt;/a&gt; for usage instructions.</source>
          <target state="translated">Kotlinのドキュメント生成ツールは&lt;a href=&quot;https://github.com/Kotlin/dokka&quot;&gt;Dokka&lt;/a&gt;と呼ばれます。使用方法については、&lt;a href=&quot;https://github.com/Kotlin/dokka/blob/master/README.md&quot;&gt;Dokka README&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="3af1e3ba09d170fd30c3af38c47add3814785926" translate="yes" xml:space="preserve">
          <source>Kotlin's documentation syntax is called &lt;em&gt;KDoc&lt;/em&gt;. A KDoc block is placed above the construct it describes, and begins with &lt;code&gt;/**&lt;/code&gt; and ends with &lt;code&gt;*/&lt;/code&gt; (possibly on one line; if not, each intermediate lines should start with an aligned asterisk). The first block of text is the summary; then, you can use &lt;em&gt;block tags&lt;/em&gt; to provide information about specific parts of the construct. Some block tags are &lt;code&gt;@param&lt;/code&gt; for function parameters and generic type parameters, and &lt;code&gt;@return&lt;/code&gt; for the return value. You can link to identifiers inside brackets. All the text outside of links and block tag names is in Markdown format.</source>
          <target state="translated">Kotlinのドキュメント構文は&lt;em&gt;KDoc&lt;/em&gt;と呼ばれ&lt;em&gt;ます&lt;/em&gt;。 KDocブロックは、それが記述する構成の上に配置され、 &lt;code&gt;/**&lt;/code&gt; で始まり &lt;code&gt;*/&lt;/code&gt; で終わります（1行である可能性があります。そうでない場合は、各中間行はアスタリスクで始まります）。テキストの最初のブロックは要約です。次に、&lt;em&gt;ブロックタグ&lt;/em&gt;を使用して、構成の特定の部分に関する情報を提供できます。一部のブロックタグは、関数パラメーターとジェネリック型パラメーターの &lt;code&gt;@param&lt;/code&gt; 、および戻り値の &lt;code&gt;@return&lt;/code&gt; です。大括弧内の識別子にリンクできます。リンクとブロックタグ名の外側のすべてのテキストは、Markdown形式です。</target>
        </trans-unit>
        <trans-unit id="053760c0ead482ee5ae43f8e0bead527a31d7dd2" translate="yes" xml:space="preserve">
          <source>Kotlin's generics are a little different from Java's (see &lt;a href=&quot;generics&quot;&gt;Generics&lt;/a&gt;). When importing Java types to Kotlin we perform some conversions:</source>
          <target state="translated">Kotlinのジェネリックは、Javaのジェネリックとは少し異なります（&lt;a href=&quot;generics&quot;&gt;ジェネリックを&lt;/a&gt;参照）。JavaタイプをKotlinにインポートするとき、いくつかの変換を実行します。</target>
        </trans-unit>
        <trans-unit id="9ce324f37629b9d5fdf6ee64821674d4e61b9c46" translate="yes" xml:space="preserve">
          <source>Kotlin's loops are similar to Python's. &lt;code&gt;for&lt;/code&gt; iterates over anything that is &lt;em&gt;iterable&lt;/em&gt; (anything that has an &lt;code&gt;iterator()&lt;/code&gt; function that provides an &lt;code&gt;Iterator&lt;/code&gt; object), or anything that is itself an iterator:</source>
          <target state="translated">KotlinのループはPythonのループに似ています。 &lt;code&gt;for&lt;/code&gt; であるものを反復&lt;em&gt;反復可能&lt;/em&gt;（持つもの &lt;code&gt;iterator()&lt;/code&gt; を提供関数 &lt;code&gt;Iterator&lt;/code&gt; オブジェクト）、または反復子自体であるもの：</target>
        </trans-unit>
        <trans-unit id="ba05695800cb8016bdf03b211c131a78afee8e93" translate="yes" xml:space="preserve">
          <source>Kotlin's object model is substantially different from Python's. Most importantly, classes are &lt;em&gt;not&lt;/em&gt; dynamically modifiable at runtime! (There are some limited exceptions to this, but you generally shouldn't do it. However, it &lt;em&gt;is&lt;/em&gt; possible to dynamically &lt;em&gt;inspect&lt;/em&gt; classes and objects at runtime with a feature called &lt;em&gt;reflection&lt;/em&gt; - this can be useful, but should be judiciously used.) All properties (attributes) and functions that might ever be needed on a class must be declared either directly in the class body or as &lt;a href=&quot;extension-functionsproperties&quot;&gt;&lt;em&gt;extension functions&lt;/em&gt;&lt;/a&gt;, so you should think carefully through your class design.</source>
          <target state="translated">Kotlinのオブジェクトモデルは、Pythonのオブジェクトモデルとは大きく異なります。最も重要なのは、クラスは実行時に動的に変更&lt;em&gt;できないこと&lt;/em&gt;です。 （これにはいくつかの限定的な例外がありますが、通常は行うべきではありません。ただし、&lt;em&gt;リフレクション&lt;/em&gt;と呼ばれる機能を使用して、実行時にクラスとオブジェクトを動的に&lt;em&gt;検査する&lt;/em&gt;こと&lt;em&gt;は&lt;/em&gt;可能です。これは便利ですが、慎重に使用する必要があります。）すべてクラスで必要になる可能性のあるプロパティ（属性）と関数は、クラス本体で直接または&lt;a href=&quot;extension-functionsproperties&quot;&gt;&lt;em&gt;拡張関数&lt;/em&gt;&lt;/a&gt;として宣言する必要があるため、クラスの設計を慎重に検討する必要があります。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d2a59f6487d643d44ccac72e26090969f3853d89" translate="yes" xml:space="preserve">
          <source>Kotlin's standard library has a &lt;code&gt;TODO()&lt;/code&gt; function that will always throw a &lt;code&gt;NotImplementedError&lt;/code&gt;. Its return type is &lt;code&gt;Nothing&lt;/code&gt; so it can be used regardless of expected type. There's also an overload that accepts a reason parameter:</source>
          <target state="translated">Kotlinの標準ライブラリには、常に &lt;code&gt;NotImplementedError&lt;/code&gt; をスローする &lt;code&gt;TODO()&lt;/code&gt; 関数があります。その戻り値の型は &lt;code&gt;Nothing&lt;/code&gt; であるため、予期される型に関係なく使用できます。理由パラメーターを受け入れるオーバーロードもあります。</target>
        </trans-unit>
        <trans-unit id="970540431e074be00582837c3e83cd1ca1a5ee04" translate="yes" xml:space="preserve">
          <source>Kotlin's type system is aimed at eliminating the danger of null references from code, also known as the &lt;a href=&quot;http://en.wikipedia.org/wiki/Tony_Hoare#Apologies_and_retractions&quot;&gt;The Billion Dollar Mistake&lt;/a&gt;.</source>
          <target state="translated">Kotlinの型システムは、コードからのnull参照の危険性を排除することを目的としています。&lt;a href=&quot;http://en.wikipedia.org/wiki/Tony_Hoare#Apologies_and_retractions&quot;&gt;これ&lt;/a&gt;は、The Billion Dollar Mistakeとしても知られています。</target>
        </trans-unit>
        <trans-unit id="8b3b3c2fce26ced6c3f89e4969b12ebc4e57fb47" translate="yes" xml:space="preserve">
          <source>Kotlin's type system is aimed at eliminating the danger of null references from code, also known as the &lt;a href=&quot;https://en.wikipedia.org/wiki/Tony_Hoare#Apologies_and_retractions&quot;&gt;The Billion Dollar Mistake&lt;/a&gt;.</source>
          <target state="translated">Kotlinの型システムは、コードからnull参照の危険性を排除することを目的としています。&lt;a href=&quot;https://en.wikipedia.org/wiki/Tony_Hoare#Apologies_and_retractions&quot;&gt;これは、10億ドルの間違い&lt;/a&gt;としても知られています。</target>
        </trans-unit>
        <trans-unit id="6ae5912eae484ffd44f09a774b363dbba8158106" translate="yes" xml:space="preserve">
          <source>Kotlin's type system is aimed to eliminate &lt;code&gt;NullPointerException&lt;/code&gt;'s from our code. The only possible causes of NPE's may be:</source>
          <target state="translated">Kotlinの型システムは、コードから &lt;code&gt;NullPointerException&lt;/code&gt; を排除することを目的としています。NPEの考えられる原因は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="0b21dfbe494a9eaaf724f5a9592dd235fdd14650" translate="yes" xml:space="preserve">
          <source>Kotlin, as a language, provides only minimal low-level APIs in its standard library to enable various other libraries to utilize coroutines. Unlike many other languages with similar capabilities, &lt;code&gt;async&lt;/code&gt; and &lt;code&gt;await&lt;/code&gt; are not keywords in Kotlin and are not even part of its standard library. Moreover, Kotlin's concept of &lt;em&gt;suspending function&lt;/em&gt; provides a safer and less error-prone abstraction for asynchronous operations than futures and promises.</source>
          <target state="translated">Kotlinは、言語として、標準ライブラリで最小限の低レベルAPIのみを提供して、他のさまざまなライブラリがコルーチンを利用できるようにします。同様の機能を持つ他の多くの言語とは異なり、 &lt;code&gt;async&lt;/code&gt; と &lt;code&gt;await&lt;/code&gt; はKotlinのキーワードではなく、標準ライブラリの一部でもありません。さらに、Kotlinの&lt;em&gt;一時停止機能&lt;/em&gt;の概念は、フューチャーやプロミスよりも安全でエラーの発生しにくい非同期操作の抽象化を提供します。</target>
        </trans-unit>
        <trans-unit id="1aefdadaf18a27e16e25f47128252ff2aeb47fe6" translate="yes" xml:space="preserve">
          <source>Kotlin, similar to C# and Gosu, provides the ability to extend a class with new functionality without having to inherit from the class or use any type of design pattern such as Decorator. This is done via special declarations called &lt;em&gt;extensions&lt;/em&gt;. Kotlin supports &lt;em&gt;extension functions&lt;/em&gt; and &lt;em&gt;extension properties&lt;/em&gt;.</source>
          <target state="translated">Kotlinは、C＃やGosuと同様に、クラスから継承したり、Decoratorなどのデザインパターンを使用したりすることなく、新しい機能でクラスを拡張する機能を提供します。これは、&lt;em&gt;extensions&lt;/em&gt;と呼ばれる特別な宣言を介して行われます。Kotlinは、&lt;em&gt;拡張関数&lt;/em&gt;と&lt;em&gt;拡張プロパティを&lt;/em&gt;サポートしてい&lt;em&gt;ます&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="66f1754b6d5c7a12dce00bd5e634c25ddb75bf52" translate="yes" xml:space="preserve">
          <source>Kotlin/JS</source>
          <target state="translated">Kotlin/JS</target>
        </trans-unit>
        <trans-unit id="b4529ea374c3a4cde07a41aa987a9b048c623d50" translate="yes" xml:space="preserve">
          <source>Kotlin/JS (Classic back-end)</source>
          <target state="translated">Kotlin/JS (クラシックバックエンド)</target>
        </trans-unit>
        <trans-unit id="4c111df440b988d7ac0f881b0ae8eeed10bb5e43" translate="yes" xml:space="preserve">
          <source>Kotlin/JS (IR-based)</source>
          <target state="translated">Kotlin/JS(IRベース</target>
        </trans-unit>
        <trans-unit id="3409f54fa5231194c2d7cb0f9009c3222e1a2109" translate="yes" xml:space="preserve">
          <source>Kotlin/JS Overview</source>
          <target state="translated">Kotlin/JSの概要</target>
        </trans-unit>
        <trans-unit id="5579b6ef038f8f8ca2fe985b676250979f056cbe" translate="yes" xml:space="preserve">
          <source>Kotlin/JS allows you to &lt;strong&gt;leverage powerful browser and web APIs&lt;/strong&gt; in a type-safe fashion. Create, modify and interact with elements in the Document Object Model (DOM), use Kotlin code to control the rendering of &lt;code&gt;canvas&lt;/code&gt; or WebGL components, and enjoy access to many more of the features supported in modern browsers.</source>
          <target state="translated">Kotlin / JSを使用すると&lt;strong&gt;、強力なブラウザーAPIとWebAPI&lt;/strong&gt;をタイプセーフな方法で&lt;strong&gt;活用&lt;/strong&gt;できます。ドキュメントオブジェクトモデル（DOM）の要素を作成、変更、操作し、Kotlinコードを使用して &lt;code&gt;canvas&lt;/code&gt; またはWebGLコンポーネントのレンダリングを制御し、最新のブラウザーでサポートされている多くの機能にアクセスできます。</target>
        </trans-unit>
        <trans-unit id="c551ceb4f789ea0a28725793cbf50b7fde3239c9" translate="yes" xml:space="preserve">
          <source>Kotlin/JS compiler options</source>
          <target state="translated">Kotlin/JS コンパイラのオプション</target>
        </trans-unit>
        <trans-unit id="bc555107bc3ab29b699e3ac57e1fb75bce2155ce" translate="yes" xml:space="preserve">
          <source>Kotlin/JS is also compatible with the most common module systems: UMD, CommonJS, and AMD. Being able to &lt;a href=&quot;../tutorials/javascript/working-with-modules/working-with-modules&quot;&gt;produce and consume modules&lt;/a&gt; means that you can interact with the JavaScript ecosystem in a structured manner.</source>
          <target state="translated">Kotlin / JSは、最も一般的なモジュールシステムであるUMD、CommonJS、AMDとも互換性があります。&lt;a href=&quot;../tutorials/javascript/working-with-modules/working-with-modules&quot;&gt;モジュール&lt;/a&gt;を生成および消費できるということは、構造化された方法でJavaScriptエコシステムと対話できることを意味します。</target>
        </trans-unit>
        <trans-unit id="6c71e5ac2d4139fc0df7bb50e9a0d7dcc0b261db" translate="yes" xml:space="preserve">
          <source>Kotlin/JS projects can target two different execution environments:</source>
          <target state="translated">Kotlin/JSプロジェクトでは、2つの異なる実行環境をターゲットにすることができます。</target>
        </trans-unit>
        <trans-unit id="2dd41eae9565ad317afb86080bea814ec06af110" translate="yes" xml:space="preserve">
          <source>Kotlin/JS projects use Gradle as a build system. To let developers easily manage their Kotlin/JS projects, we offer the &lt;code&gt;kotlin.js&lt;/code&gt; Gradle plugin that provides project configuration tools together with helper tasks for automating routines typical for JavaScript development. For example, the plugin downloads the &lt;a href=&quot;https://yarnpkg.com/&quot;&gt;Yarn&lt;/a&gt; package manager for managing &lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm&lt;/a&gt; dependencies in background and can build a JavaScript bundle from a Kotlin project using &lt;a href=&quot;https://webpack.js.org/&quot;&gt;webpack&lt;/a&gt;. Dependency management and configuration adjustments can be done to a large part directly from the Gradle build file, with the option to override automatically generated configurations for full control.</source>
          <target state="translated">Kotlin / JSプロジェクトは、ビルドシステムとしてGradleを使用します。開発者がKotlin / JSプロジェクトを簡単に管理できるように、JavaScript開発で一般的なルーチンを自動化するためのヘルパータスクとともにプロジェクト構成ツールを提供する &lt;code&gt;kotlin.js&lt;/code&gt; Gradleプラグインを提供しています。たとえば、プラグインはバックグラウンドで&lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npmの&lt;/a&gt;依存関係を管理するための&lt;a href=&quot;https://yarnpkg.com/&quot;&gt;Yarn&lt;/a&gt;パッケージマネージャーをダウンロードし、&lt;a href=&quot;https://webpack.js.org/&quot;&gt;webpack&lt;/a&gt;を使用してKotlinプロジェクトからJavaScriptバンドルを構築できます。依存関係の管理と構成の調整は、Gradleビルドファイルから直接大部分を行うことができ、完全に制御するために自動生成された構成をオーバーライドするオプションがあります。</target>
        </trans-unit>
        <trans-unit id="73e221948b2977f48bf5440d552a61a97802b3f2" translate="yes" xml:space="preserve">
          <source>Kotlin/JS provides the ability to transpile your Kotlin code, the Kotlin standard library, and any compatible dependencies to JavaScript. The current implementation of Kotlin/JS targets &lt;a href=&quot;https://www.ecma-international.org/ecma-262/5.1/&quot;&gt;ES5&lt;/a&gt;.</source>
          <target state="translated">Kotlin / JSは、Kotlinコード、Kotlin標準ライブラリ、およびJavaScriptとの互換性のある依存関係をトランスパイルする機能を提供します。Kotlin / JSの現在の実装は、&lt;a href=&quot;https://www.ecma-international.org/ecma-262/5.1/&quot;&gt;ES5を&lt;/a&gt;対象としています。</target>
        </trans-unit>
        <trans-unit id="e161bf22c4b5c5951be23fef6f0ff257426ebe17" translate="yes" xml:space="preserve">
          <source>Kotlin/JS, Today and Tomorrow</source>
          <target state="translated">Kotlin/JS、今日と明日</target>
        </trans-unit>
        <trans-unit id="44cbff389316ebfe00ceb67daf169189d44ae420" translate="yes" xml:space="preserve">
          <source>Kotlin/JVM</source>
          <target state="translated">Kotlin/JVM</target>
        </trans-unit>
        <trans-unit id="629649c3a6fde50e4105c70afe705d63afa55224" translate="yes" xml:space="preserve">
          <source>Kotlin/JVM (IR-based)</source>
          <target state="translated">Kotlin/JVM (IRベース)</target>
        </trans-unit>
        <trans-unit id="101afe89559b0f2b0c4257af7917cfec768ae3d7" translate="yes" xml:space="preserve">
          <source>Kotlin/JVM compiler options</source>
          <target state="translated">Kotlin/JVM コンパイラのオプション</target>
        </trans-unit>
        <trans-unit id="59ce5e2461e87e30bf83a0eb1faafe214139a6af" translate="yes" xml:space="preserve">
          <source>Kotlin/Native</source>
          <target state="translated">Kotlin/Native</target>
        </trans-unit>
        <trans-unit id="ba24fc19201f933494d7dd5a5c0dfc8e159aaf9b" translate="yes" xml:space="preserve">
          <source>Kotlin/Native &lt;a href=&quot;native/platform_libs&quot;&gt;libraries&lt;/a&gt; help to share Kotlin code between projects. POSIX, gzip, OpenGL, Metal, Foundation, and many other popular libraries and Apple frameworks are pre-imported and included as Kotlin/Native libraries into the compiler package.</source>
          <target state="translated">Kotlin /ネイティブ&lt;a href=&quot;native/platform_libs&quot;&gt;ライブラリは&lt;/a&gt;、プロジェクト間でKotlinコードを共有するのに役立ちます。POSIX、gzip、OpenGL、Metal、Foundation、およびその他の多くの一般的なライブラリとAppleフレームワークが事前にインポートされ、Kotlin / Nativeライブラリとしてコンパイラパッケージに含まれています。</target>
        </trans-unit>
        <trans-unit id="87f61b22867c181628a95e8886f5b445415a504e" translate="yes" xml:space="preserve">
          <source>Kotlin/Native Gradle plugin</source>
          <target state="translated">Kotlin/Native Gradle プラグイン</target>
        </trans-unit>
        <trans-unit id="c83dbff85c7c1cfb09790c18b941a770c8cb6d04" translate="yes" xml:space="preserve">
          <source>Kotlin/Native Runtime</source>
          <target state="translated">Kotlin/ネイティブランタイム</target>
        </trans-unit>
        <trans-unit id="df149e18227e20b3ab9482b52698611b0a6fc13c" translate="yes" xml:space="preserve">
          <source>Kotlin/Native Runtime Declarations</source>
          <target state="translated">Kotlin/ネイティブランタイム宣言</target>
        </trans-unit>
        <trans-unit id="491c504edd0672427d971480838eef4206234894" translate="yes" xml:space="preserve">
          <source>Kotlin/Native also has tight integration with Apple technologies. The &lt;a href=&quot;apple-framework&quot;&gt;Kotlin/Native as an Apple Framework&lt;/a&gt; tutorial explains how to compile Kotlin code into a framework for Swift and Objective-C.</source>
          <target state="translated">Kotlin / NativeもAppleテクノロジーと緊密に統合されています。&lt;a href=&quot;apple-framework&quot;&gt;Appleフレームワークとして&lt;/a&gt;のKotlin / Nativeチュートリアルでは、KotlinコードをSwiftとObjective-Cのフレームワークにコンパイルする方法について説明しています。</target>
        </trans-unit>
        <trans-unit id="1d512deb7d342683898c6350ed1a11736984886b" translate="yes" xml:space="preserve">
          <source>Kotlin/Native also has tight integration with Objective-C and Swift. It is covered in the &lt;a href=&quot;apple-framework&quot;&gt;Kotlin/Native as an Apple Framework&lt;/a&gt; tutorial.</source>
          <target state="translated">Kotlin / Nativeは、Objective-CおよびSwiftとも緊密に統合されています。これは&lt;a href=&quot;apple-framework&quot;&gt;、Apple Framework&lt;/a&gt;チュートリアルとしてKotlin / Nativeでカバーされています。</target>
        </trans-unit>
        <trans-unit id="08982dde24268c672ff4e00ffc1e0aa78c3c7edf" translate="yes" xml:space="preserve">
          <source>Kotlin/Native as a Dynamic Library</source>
          <target state="translated">動的ライブラリとしてのKotlin/Native</target>
        </trans-unit>
        <trans-unit id="9337f3778507f31504f20c46b400d4ffe737a776" translate="yes" xml:space="preserve">
          <source>Kotlin/Native as an Apple Framework</source>
          <target state="translated">AppleフレームワークとしてのKotlin/Native</target>
        </trans-unit>
        <trans-unit id="5920643ed2bd803efde8c74d41d4425c7caa2ab6" translate="yes" xml:space="preserve">
          <source>Kotlin/Native can be used for many &lt;a href=&quot;basic-kotlin-native-app&quot;&gt;targets&lt;/a&gt; and applications, including, but not limited to macOS, Windows, Linux, and &lt;a href=&quot;mpp-ios-android&quot;&gt;iOS&lt;/a&gt;.</source>
          <target state="translated">Kotlin / Nativeは、macOS、Windows、Linux、&lt;a href=&quot;mpp-ios-android&quot;&gt;iOS&lt;/a&gt;など、多くの&lt;a href=&quot;basic-kotlin-native-app&quot;&gt;ターゲット&lt;/a&gt;およびアプリケーションで使用できます。</target>
        </trans-unit>
        <trans-unit id="5a86ebad61bd5c0feb7bd99b7af759453735031a" translate="yes" xml:space="preserve">
          <source>Kotlin/Native comes with the &lt;code&gt;cinterop&lt;/code&gt; tool, the tool generates bindings between the C language and Kotlin. It uses a &lt;code&gt;.def&lt;/code&gt; file to specify a C library to import. More details are discussed in the &lt;a href=&quot;../../reference/native/c_interop&quot;&gt;Interop with C Libraries&lt;/a&gt; tutorial.</source>
          <target state="translated">Kotlin / Nativeには &lt;code&gt;cinterop&lt;/code&gt; ツールが付属しており、このツールはC言語とKotlin間のバインディングを生成します。 &lt;code&gt;.def&lt;/code&gt; ファイルを使用して、インポートするCライブラリを指定します。詳細は&lt;a href=&quot;../../reference/native/c_interop&quot;&gt;、Cライブラリと&lt;/a&gt;の相互運用のチュートリアルで説明されています。</target>
        </trans-unit>
        <trans-unit id="c8a9d6995d5deeb05943192825e878fac0954ca5" translate="yes" xml:space="preserve">
          <source>Kotlin/Native comes with the &lt;code&gt;cinterop&lt;/code&gt; tool; the tool generates bindings between the C language and Kotlin. It uses a &lt;code&gt;.def&lt;/code&gt; file to specify a C library to import. More details on this are in the &lt;a href=&quot;../../reference/native/c_interop&quot;&gt;Interop with C Libraries&lt;/a&gt; tutorial.</source>
          <target state="translated">Kotlin / Nativeには &lt;code&gt;cinterop&lt;/code&gt; ツールが付属しています。このツールは、C言語とKotlinの間のバインディングを生成します。 &lt;code&gt;.def&lt;/code&gt; ファイルを使用して、インポートするCライブラリを指定します。これに関する詳細は、&lt;a href=&quot;../../reference/native/c_interop&quot;&gt;Cライブラリと&lt;/a&gt;の相互運用のチュートリアルにあります。</target>
        </trans-unit>
        <trans-unit id="f608852356bc7f03f212743cacdba0d3e22a135a" translate="yes" xml:space="preserve">
          <source>Kotlin/Native comes with the &lt;code&gt;cinterop&lt;/code&gt; tool; the tool generates bindings between the C language and Kotlin. It uses a &lt;code&gt;.def&lt;/code&gt; file to specify a C library to import. More details on this are in the &lt;a href=&quot;../../reference/native/c_interop&quot;&gt;Interop with C Libraries&lt;/a&gt; tutorial. The quickest way to try out C API mapping is to have all C declarations in the &lt;code&gt;interop.def&lt;/code&gt; file, without creating any &lt;code&gt;.h&lt;/code&gt; of &lt;code&gt;.c&lt;/code&gt; files at all. Then place the C declarations in a &lt;code&gt;interop.def&lt;/code&gt; file after the special &lt;code&gt;---&lt;/code&gt; separator line:</source>
          <target state="translated">Kotlin / Nativeには &lt;code&gt;cinterop&lt;/code&gt; ツールが付属しています。このツールは、C言語とKotlinの間のバインディングを生成します。 &lt;code&gt;.def&lt;/code&gt; ファイルを使用して、インポートするCライブラリを指定します。これに関する詳細は、&lt;a href=&quot;../../reference/native/c_interop&quot;&gt;Cライブラリと&lt;/a&gt;の相互運用のチュートリアルにあります。 C APIマッピングを試す最も簡単な方法は、 &lt;code&gt;.c&lt;/code&gt; ファイルの &lt;code&gt;.h&lt;/code&gt; をまったく作成せずに、すべてのC宣言を &lt;code&gt;interop.def&lt;/code&gt; ファイルに含めることです。次に、C宣言を &lt;code&gt;interop.def&lt;/code&gt; ファイルの特別な &lt;code&gt;---&lt;/code&gt; セパレータ行の後に配置します。</target>
        </trans-unit>
        <trans-unit id="02527cf62d35559073254c9faa21884b055d8fe5" translate="yes" xml:space="preserve">
          <source>Kotlin/Native compiler can produce a dynamic library out of the Kotlin code we have. A dynamic library often comes with a header file, a &lt;code&gt;.h&lt;/code&gt; file, which we will use to call compiled code from C.</source>
          <target state="translated">Kotlin /ネイティブコンパイラは、私たちが持っているKotlinコードから動的ライブラリを生成できます。ダイナミックライブラリには、多くの場合、ヘッダーファイルである &lt;code&gt;.h&lt;/code&gt; ファイルが付属しています。このファイルを使用して、Cからコンパイル済みコードを呼び出します。</target>
        </trans-unit>
        <trans-unit id="aa4881e31bc09168e1508d74717ea87e97808663" translate="yes" xml:space="preserve">
          <source>Kotlin/Native compiler can produce a framework for macOS and iOS out of the Kotlin code. The created framework contains all declarations and binaries needed to use it with Objective-C and Swift. The best way to understand the techniques is to try it for ourselves. Let's create a tiny Kotlin library first and use it from an Objective-C program.</source>
          <target state="translated">Kotlin/Nativeコンパイラは、KotlinのコードからmacOSやiOS用のフレームワークを作成することができます。作成されたフレームワークには、Objective-CやSwiftで使用するために必要なすべての宣言とバイナリが含まれています。テクニックを理解するには、実際に試してみるのが一番です。まずは小さなKotlinライブラリを作って、Objective-Cプログラムから使ってみましょう。</target>
        </trans-unit>
        <trans-unit id="b715f52434e20442ebb46ac504b8f84bf0548313" translate="yes" xml:space="preserve">
          <source>Kotlin/Native compiler compiles Kotlin source files into native binaries for the &lt;a href=&quot;native-overview#target-platforms&quot;&gt;supported platforms&lt;/a&gt;. The command-line tool for Kotlin/Native compilation is &lt;code&gt;kotlinc-native&lt;/code&gt;.</source>
          <target state="translated">Kotlin / Nativeコンパイラは、Kotlinソースファイルを&lt;a href=&quot;native-overview#target-platforms&quot;&gt;サポートさ&lt;/a&gt;れているプラットフォームのネイティブバイナリにコンパイルします。Kotlin / Nativeコンパイル用のコマンドラインツールは &lt;code&gt;kotlinc-native&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="72370bde43174b087fc25e3ae6d822902a3834d6" translate="yes" xml:space="preserve">
          <source>Kotlin/Native compiler options</source>
          <target state="translated">Kotlin/ネイティブコンパイラのオプション</target>
        </trans-unit>
        <trans-unit id="c0c8b720dae4415d29464c12eeee3db3497f57a4" translate="yes" xml:space="preserve">
          <source>Kotlin/Native doesn't support Maven and IntelliJ IDEA native builder.</source>
          <target state="translated">Kotlin/NativeはMavenとIntelliJ IDEAネイティブビルダーをサポートしていません。</target>
        </trans-unit>
        <trans-unit id="4e70e70db2bb73d6cf1636bc883f8b53e7b6e7cb" translate="yes" xml:space="preserve">
          <source>Kotlin/Native for Native</source>
          <target state="translated">コトリン/ネイティブのためのネイティブ</target>
        </trans-unit>
        <trans-unit id="7c2c0a3630334c277a8dc79b0ff364b848f6cdc2" translate="yes" xml:space="preserve">
          <source>Kotlin/Native has bidirectional interop with Objective-C and Swift languages. Kotlin objects integrate with Objective-C/Swift reference counting. Unused Kotlin objects are automatically removed. The &lt;a href=&quot;https://github.com/JetBrains/kotlin-native/blob/master/OBJC_INTEROP.md&quot;&gt;Objective-C Interop&lt;/a&gt; article contains more information on the interop implementation details. Of course, it is possible to import an existing framework and use it from Kotlin. Kotlin/Native comes with a good set of pre-imported system frameworks.</source>
          <target state="translated">Kotlin / Nativeには、Objective-CおよびSwift言語との双方向の相互運用機能があります。Kotlinオブジェクトは、Objective-C / Swift参照カウントと統合されます。未使用のKotlinオブジェクトは自動的に削除されます。&lt;a href=&quot;https://github.com/JetBrains/kotlin-native/blob/master/OBJC_INTEROP.md&quot;&gt;Objective-Cの相互運用の&lt;/a&gt;記事は、相互運用機能実装の詳細についての詳細情報が含まれています。もちろん、既存のフレームワークをインポートしてKotlinから使用することもできます。Kotlin / Nativeには、事前にインポートされたシステムフレームワークの優れたセットが付属しています。</target>
        </trans-unit>
        <trans-unit id="fb79704d30655deeda4430e028a0903e865692a2" translate="yes" xml:space="preserve">
          <source>Kotlin/Native has garbage collection, but it does not help us deal with Kotlin objects from the C language. Kotlin/Native has interop with Objective-C and Swift and integrates with their reference counters. The &lt;a href=&quot;../../reference/native/objc_interop&quot;&gt;Objective-C Interop&lt;/a&gt; documentation article contains more details on it. Also, there is the tutorial &lt;a href=&quot;apple-framework&quot;&gt;Kotlin/Native as an Apple Framework&lt;/a&gt;.</source>
          <target state="translated">Kotlin / Nativeにはガベージコレクションがありますが、C言語のKotlinオブジェクトの処理には役立ちません。Kotlin / NativeはObjective-CおよびSwiftと相互運用性があり、それらの参照カウンターと統合します。&lt;a href=&quot;../../reference/native/objc_interop&quot;&gt;Objective-Cの相互運用&lt;/a&gt;ドキュメントの記事は、それについての詳細が含まれています。また、&lt;a href=&quot;apple-framework&quot;&gt;Apple Frameworkとしての&lt;/a&gt;チュートリアルKotlin / Nativeもあります。</target>
        </trans-unit>
        <trans-unit id="bd3fb305a0493b588bb98fac3fd02dfc049654c2" translate="yes" xml:space="preserve">
          <source>Kotlin/Native has received a number of performance improvements that speed up both the development process and execution. Here are some examples:</source>
          <target state="translated">Kotlin/Native は、開発プロセスと実行の両方を高速化するパフォーマンスの改善を多数受けています。以下にいくつかの例を紹介します。</target>
        </trans-unit>
        <trans-unit id="c4bedc3bea01878b4fcc1d82e743d0490ea2316b" translate="yes" xml:space="preserve">
          <source>Kotlin/Native implements strict mutability checks, ensuring the important invariant that the object is either immutable or accessible from the single thread at that moment in time (&lt;code&gt;mutable XOR global&lt;/code&gt;).</source>
          <target state="translated">Kotlin / Nativeは厳密な &lt;code&gt;mutable XOR global&lt;/code&gt; 性チェックを実装し、オブジェクトが不変であるか、その時点で単一のスレッドからアクセス可能であるという重要な不変条件を保証します（可変XORグローバル）。</target>
        </trans-unit>
        <trans-unit id="36a59900f037725e245ca430f51e42774fdb92b1" translate="yes" xml:space="preserve">
          <source>Kotlin/Native interop with Swift and Objective-C is covered in the &lt;a href=&quot;../../reference/native/objc_interop&quot;&gt;documentation&lt;/a&gt; article. Also, the same topic is covered in the &lt;a href=&quot;apple-framework&quot;&gt;Kotlin/Native as an Apple Framework&lt;/a&gt; tutorial.</source>
          <target state="translated">SwiftおよびObjective-CとのKotlin / Native相互運用については、&lt;a href=&quot;../../reference/native/objc_interop&quot;&gt;ドキュメントの&lt;/a&gt;記事で説明しています。また、同じトピックが&lt;a href=&quot;apple-framework&quot;&gt;Kotlin / NativeでApple Framework&lt;/a&gt;チュートリアルとしてカバーされています。</target>
        </trans-unit>
        <trans-unit id="9fbae7a065c905b4b51aef1c8da31351fd4627d4" translate="yes" xml:space="preserve">
          <source>Kotlin/Native interoperability</source>
          <target state="translated">Kotlin/ネイティブの相互運用性</target>
        </trans-unit>
        <trans-unit id="1610b5a5d3e7a47921adb6d92cccbad92bdc99b6" translate="yes" xml:space="preserve">
          <source>Kotlin/Native interoperability with Swift/Objective-C</source>
          <target state="translated">Kotlin/Swift/Objective-Cとのネイティブ相互運用性</target>
        </trans-unit>
        <trans-unit id="d8be23859d14973d71698ea0e5cefbc7c40946a7" translate="yes" xml:space="preserve">
          <source>Kotlin/Native is a technology for compiling Kotlin code to native binaries, which can run without a virtual machine. It is an &lt;a href=&quot;https://llvm.org/&quot;&gt;LLVM&lt;/a&gt; based backend for the Kotlin compiler and native implementation of the Kotlin standard library.</source>
          <target state="translated">Kotlin / Nativeは、Kotlinコードをネイティブバイナリにコンパイルするテクノロジーであり、仮想マシンなしで実行できます。これは、KotlinコンパイラーおよびKotlin標準ライブラリーのネイティブ実装用の&lt;a href=&quot;https://llvm.org/&quot;&gt;LLVM&lt;/a&gt;ベースのバックエンドです。</target>
        </trans-unit>
        <trans-unit id="f0c84f3b6f232babbc963e394f0dc8678a4ccc49" translate="yes" xml:space="preserve">
          <source>Kotlin/Native is currently &lt;a href=&quot;https://blog.jetbrains.com/kotlin/tag/native/&quot;&gt;in the works&lt;/a&gt;. It compiles Kotlin to native code that can run without a VM. There is a Technology Preview released but it is not production-ready yet, and doesn&amp;rsquo;t yet target all the platforms that we plan to support for 1.0. For more information check out the &lt;a href=&quot;https://blog.jetbrains.com/kotlin/2017/04/kotlinnative-tech-preview-kotlin-without-a-vm/&quot;&gt;blog post announcing Kotlin/Native&lt;/a&gt;.</source>
          <target state="translated">Kotlin / Nativeは現在&lt;a href=&quot;https://blog.jetbrains.com/kotlin/tag/native/&quot;&gt;作業中&lt;/a&gt;です。KotlinをVMなしで実行できるネイティブコードにコンパイルします。テクノロジープレビューがリリースされましたが、まだ本番環境には対応しておらず、1.0をサポートする予定のすべてのプラットフォームをまだターゲットにしていません。詳細については、&lt;a href=&quot;https://blog.jetbrains.com/kotlin/2017/04/kotlinnative-tech-preview-kotlin-without-a-vm/&quot;&gt;Kotlin / Nativeを発表&lt;/a&gt;したブログ投稿をご覧ください。</target>
        </trans-unit>
        <trans-unit id="2e6e839c9eb016aad26e87b63395598581d37d86" translate="yes" xml:space="preserve">
          <source>Kotlin/Native is primarily designed to allow compilation for platforms where &lt;em&gt;virtual machines&lt;/em&gt; are not desirable or possible, for example, embedded devices or iOS. It solves the situations when a developer needs to produce a self-contained program that does not require an additional runtime or virtual machine.</source>
          <target state="translated">Kotlin / Nativeは主に、組み込みデバイスやiOSなど、&lt;em&gt;仮想マシン&lt;/em&gt;が望ましくない、または不可能であるプラットフォームでのコンパイルを可能にするように設計されています。追加のランタイムや仮想マシンを必要としない自己完結型プログラムを開発者が作成する必要がある状況を解決します。</target>
        </trans-unit>
        <trans-unit id="0a635a513919c15b75bf38827975739bea97d9aa" translate="yes" xml:space="preserve">
          <source>Kotlin/Native libraries</source>
          <target state="translated">Kotlin/ネイティブライブラリ</target>
        </trans-unit>
        <trans-unit id="e52aa2cf9fdcb60b58b2f9cbee9d5268ded14cfd" translate="yes" xml:space="preserve">
          <source>Kotlin/Native libraries are zip files containing a predefined directory structure, with the following layout:</source>
          <target state="translated">Kotlin/Native ライブラリは、あらかじめ定義されたディレクトリ構造を含む zip ファイルで、以下のようなレイアウトになっています。</target>
        </trans-unit>
        <trans-unit id="0c6f4cb92f825877d15d4e0409193ad150464dfb" translate="yes" xml:space="preserve">
          <source>Kotlin/Native plugin requires a newer version of Gradle, let's patch the &lt;code&gt;gradle/wrapper/gradle-wrapper.properties&lt;/code&gt; and use the following &lt;code&gt;distrubutionUrl&lt;/code&gt;:</source>
          <target state="translated">Kotlin /ネイティブプラグインは、レッツ・パッチ、のGradleの新しいバージョンを必要とする &lt;code&gt;gradle/wrapper/gradle-wrapper.properties&lt;/code&gt; と、次の使用 &lt;code&gt;distrubutionUrl&lt;/code&gt; を：</target>
        </trans-unit>
        <trans-unit id="bc9ab4e314800dbff8307a948abe9a382ccbda9f" translate="yes" xml:space="preserve">
          <source>Kotlin/Native provides bi-directional interoperability with Objective-C/Swift. Objective-C frameworks and libraries can be used in Kotlin code. Kotlin modules can be used in Swift/Objective-C code too. Besides that, Kotlin/Native has &lt;a href=&quot;https://github.com/JetBrains/kotlin-native/blob/master/INTEROP.md&quot;&gt;C Interop&lt;/a&gt;. There is also the &lt;a href=&quot;dynamic-libraries&quot;&gt;Kotlin/Native as a Dynamic Library&lt;/a&gt; tutorial for more information.</source>
          <target state="translated">Kotlin / Nativeは、Objective-C / Swiftとの双方向の相互運用性を提供します。Objective-CフレームワークとライブラリはKotlinコードで使用できます。Kotlinモジュールは、Swift / Objective-Cコードでも使用できます。それ以外に、Kotlin / Nativeには&lt;a href=&quot;https://github.com/JetBrains/kotlin-native/blob/master/INTEROP.md&quot;&gt;C Interopがあり&lt;/a&gt;ます。詳細については&lt;a href=&quot;dynamic-libraries&quot;&gt;、ダイナミックライブラリ&lt;/a&gt;チュートリアルとしてのKotlin / Nativeもあります。</target>
        </trans-unit>
        <trans-unit id="c6b2dc69e2661f2073dd575f2affbfbd48e1816c" translate="yes" xml:space="preserve">
          <source>Kotlin/Native provides bidirectional interoperability with Objective-C. Objective-C frameworks and libraries can be used in Kotlin code if properly imported to the build (system frameworks are imported by default). See e.g. &quot;Using cinterop&quot; in &lt;a href=&quot;gradle_plugin#using-cinterop&quot;&gt;Gradle plugin documentation&lt;/a&gt;. A Swift library can be used in Kotlin code if its API is exported to Objective-C with &lt;code&gt;@objc&lt;/code&gt;. Pure Swift modules are not yet supported.</source>
          <target state="translated">Kotlin / Nativeは、Objective-Cとの双方向の相互運用性を提供します。Objective-Cフレームワークとライブラリは、ビルドに適切にインポートされた場合、Kotlinコードで使用できます（システムフレームワークはデフォルトでインポートされます）。たとえば、&lt;a href=&quot;gradle_plugin#using-cinterop&quot;&gt;Gradleプラグインのドキュメントの&lt;/a&gt;「cinteropの使用」を参照してください。Swiftライブラリは、そのAPIが &lt;code&gt;@objc&lt;/code&gt; を使用してObjective-Cにエクスポートされている場合、Kotlinコードで使用できます。Pure Swiftモジュールはまだサポートされていません。</target>
        </trans-unit>
        <trans-unit id="70a326aefb047308c0a09cf46a7be9e9cca8e58e" translate="yes" xml:space="preserve">
          <source>Kotlin/Native provides integration with the &lt;a href=&quot;https://cocoapods.org/&quot;&gt;CocoaPods dependency manager&lt;/a&gt;. You can add dependencies on Pod libraries stored in the CocoaPods repository or locally as well as use a multiplatform project with native targets as a CocoaPods dependency (Kotlin Pod).</source>
          <target state="translated">Kotlin / Nativeは、&lt;a href=&quot;https://cocoapods.org/&quot;&gt;CocoaPods依存関係マネージャー&lt;/a&gt;との統合を提供します。CocoaPodsリポジトリまたはローカルに保存されているPodライブラリへの依存関係を追加したり、ネイティブターゲットを使用したマルチプラットフォームプロジェクトをCocoaPods依存関係（Kotlin Pod）として使用したりできます。</target>
        </trans-unit>
        <trans-unit id="b1c01f6b8c6b07e3bae6f070059599f6036610db" translate="yes" xml:space="preserve">
          <source>Kotlin/Native provides us with the ability to consume standard C libraries, opening up an entire ecosystem of functionality that exists for pretty much anything we could need. In fact, Kotlin/Native already ships with a set of prebuilt &lt;a href=&quot;https://github.com/JetBrains/kotlin-native/blob/master/PLATFORM_LIBS.md&quot;&gt;platform libraries&lt;/a&gt; which provide some additional common functionality to that of the standard library.</source>
          <target state="translated">Kotlin / Nativeは、標準のCライブラリを利用する機能を提供し、必要なほぼすべてのもののために存在する機能のエコシステム全体を開きます。実際、Kotlin / Nativeには、標準ライブラリの機能にいくつかの追加の共通機能を提供する一連のビルド済み&lt;a href=&quot;https://github.com/JetBrains/kotlin-native/blob/master/PLATFORM_LIBS.md&quot;&gt;プラットフォームライブラリ&lt;/a&gt;がすでに付属しています。</target>
        </trans-unit>
        <trans-unit id="d5389b5d85aa38736c73eb5aa9a313b033cc4d19" translate="yes" xml:space="preserve">
          <source>Kotlin/Native runtime doesn't encourage a classical thread-oriented concurrency model with mutually exclusive code blocks and conditional variables, as this model is known to be error-prone and unreliable. Instead, we suggest a collection of alternative approaches, allowing you to use hardware concurrency and implement blocking IO. Those approaches are as follows, and they will be elaborated on in further sections:</source>
          <target state="translated">Kotlin/Native ランタイムでは、相互に排他的なコードブロックと条件変数を持つ古典的なスレッド指向の同時実行モデルを推奨していません。このモデルはエラーが発生しやすく信頼性が低いことが知られているからです。その代わりに、ハードウェア同時実行を使用して IO をブロッキングすることを可能にする代替アプローチを提案します。これらのアプローチは以下の通りで、さらに詳しく説明します。</target>
        </trans-unit>
        <trans-unit id="ac06a1726ed52d913d8c1eb5dbb2c82e723e185d" translate="yes" xml:space="preserve">
          <source>Kotlin/Native sources and examples</source>
          <target state="translated">コトリン/ネイティブのソースと例</target>
        </trans-unit>
        <trans-unit id="c4fa13c8ae49679dc61a192fdfe13c1f15f778dd" translate="yes" xml:space="preserve">
          <source>Kotlin/Native sources and examples (.tgz)</source>
          <target state="translated">Kotlin/ネイティブのソースと例 (.tgz)</target>
        </trans-unit>
        <trans-unit id="950455929874daa5e49199f24231f9f317130873" translate="yes" xml:space="preserve">
          <source>Kotlin/Native sources and examples (.zip)</source>
          <target state="translated">Kotlin/ネイティブのソースとサンプル (.zip)</target>
        </trans-unit>
        <trans-unit id="5729c05577d9982b3fa36c76507104ea69c51357" translate="yes" xml:space="preserve">
          <source>Kotlin/Native standard library provides primitives for safe working with concurrently mutable data, namely &lt;code&gt;AtomicInt&lt;/code&gt;, &lt;code&gt;AtomicLong&lt;/code&gt;, &lt;code&gt;AtomicNativePtr&lt;/code&gt;, &lt;code&gt;AtomicReference&lt;/code&gt; and &lt;code&gt;FreezableAtomicReference&lt;/code&gt; in the package &lt;code&gt;kotlin.native.concurrent&lt;/code&gt;. Atomic primitives allows concurrency-safe update operations, such as increment, decrement and compare-and-swap, along with value setters and getters. Atomic primitives are considered always frozen by the runtime, and while their fields can be updated with the regular &lt;code&gt;field.value += 1&lt;/code&gt;, it is not concurrency safe. Value must be be changed using dedicated operations, so it is possible to perform concurrent-safe global counters and similar data structures.</source>
          <target state="translated">Kotlin / Native標準ライブラリは、同時に変更可能なデータ、つまり &lt;code&gt;AtomicInt&lt;/code&gt; 、 &lt;code&gt;AtomicLong&lt;/code&gt; 、 &lt;code&gt;AtomicNativePtr&lt;/code&gt; 、 &lt;code&gt;AtomicReference&lt;/code&gt; 、 &lt;code&gt;FreezableAtomicReference&lt;/code&gt; をパッケージ &lt;code&gt;kotlin.native.concurrent&lt;/code&gt; で安全に操作するためのプリミティブを提供します。アトミックプリミティブを使用すると、値セッターとゲッターに加えて、インクリメント、デクリメント、コンペアアンドスワップなどの並行性に安全な更新操作が可能になります。アトミックプリミティブは、ランタイムによって常にフリーズされていると見なされますが、それらのフィールドは通常の &lt;code&gt;field.value += 1&lt;/code&gt; 更新できます。、並行性は安全ではありません。専用の操作を使用して値を変更する必要があるため、同時安全なグローバルカウンターや同様のデータ構造を実行できます。</target>
        </trans-unit>
        <trans-unit id="120d75c1b3c3fba55f52d619ebc338f3dea2b2f3" translate="yes" xml:space="preserve">
          <source>Kotlin/Native supports C interop too. Check out the &lt;a href=&quot;dynamic-libraries&quot;&gt;Kotlin/Native as a Dynamic Library&lt;/a&gt; tutorial for that, or have a look at the &lt;a href=&quot;../../reference/native/c_interop&quot;&gt;C Interop&lt;/a&gt; documentation article</source>
          <target state="translated">Kotlin / NativeもC相互運用性をサポートしています。そのための&lt;a href=&quot;dynamic-libraries&quot;&gt;ダイナミックライブラリ&lt;/a&gt;チュートリアルとしてのKotlin / Nativeを確認するか、&lt;a href=&quot;../../reference/native/c_interop&quot;&gt;C Interopの&lt;/a&gt;ドキュメント記事をご覧ください。</target>
        </trans-unit>
        <trans-unit id="8011eb11da7ebe065e7322454c19657ef14fbebd" translate="yes" xml:space="preserve">
          <source>Kotlin/Native supports the following platforms:</source>
          <target state="translated">Kotlin/Native は以下のプラットフォームに対応しています。</target>
        </trans-unit>
        <trans-unit id="ab1b874667f8863029a4700ab21570b44d78ad0e" translate="yes" xml:space="preserve">
          <source>Kotlin/Native supports two-way interoperability with the Native world. On the one hand, the compiler creates:</source>
          <target state="translated">Kotlin/Native はネイティブの世界との双方向の相互運用性をサポートしています。一方ではコンパイラが作成します。</target>
        </trans-unit>
        <trans-unit id="6804afabbebdb0087394548cd2a9146eb760288b" translate="yes" xml:space="preserve">
          <source>Kotlin/Native target presets (see the &lt;a href=&quot;#using-kotlinnative-targets&quot;&gt;notes&lt;/a&gt; below):</source>
          <target state="translated">Kotlin /ネイティブターゲットプリセット（下記の&lt;a href=&quot;#using-kotlinnative-targets&quot;&gt;注を&lt;/a&gt;参照）：</target>
        </trans-unit>
        <trans-unit id="48119a00acf039b3da2d7a8a891256a947a47f3e" translate="yes" xml:space="preserve">
          <source>Kotlin/Native targets do not require additional test dependencies, and the &lt;code&gt;kotlin.test&lt;/code&gt; API implementations are built-in.</source>
          <target state="translated">Kotlin /ネイティブターゲットには追加のテスト依存関係は必要なく、 &lt;code&gt;kotlin.test&lt;/code&gt; API実装が組み込まれています。</target>
        </trans-unit>
        <trans-unit id="5a2754b26e3f7ed0f09f6ac7ae0bd6b529fb311d" translate="yes" xml:space="preserve">
          <source>Kotlin/Native uses the &lt;a href=&quot;https://gradle.org&quot;&gt;Gradle&lt;/a&gt; build system through the &lt;a href=&quot;../../reference/building-mpp-with-gradle&quot;&gt;kotlin-multiplatform&lt;/a&gt; plugin. We'll look at how to configure a Gradle build below. For some corner cases, a Kotlin/Native compiler can still be obtained manually (not recommended) from the &lt;a href=&quot;https://github.com/JetBrains/kotlin/releases&quot;&gt;Kotlin releases page on GitHub&lt;/a&gt;. In the tutorial, we are focusing on using the Gradle builds.</source>
          <target state="translated">Kotlin / Nativeは、&lt;a href=&quot;../../reference/building-mpp-with-gradle&quot;&gt;kotlin-multiplatform&lt;/a&gt;プラグインを介して&lt;a href=&quot;https://gradle.org&quot;&gt;Gradle&lt;/a&gt;ビルドシステムを使用します。以下で、Gradleビルドを構成する方法を見ていきます。一部のまれなケースでは、&lt;a href=&quot;https://github.com/JetBrains/kotlin/releases&quot;&gt;GitHubのKotlinリリースページ&lt;/a&gt;からKotlin / Nativeコンパイラーを手動で取得できます（非推奨）。チュートリアルでは、Gradleビルドの使用に重点を置いています。</target>
        </trans-unit>
        <trans-unit id="8a3c5258f5b49cfb85ed7f0dcaee614a131a77c3" translate="yes" xml:space="preserve">
          <source>Kotlin:</source>
          <target state="translated">Kotlin:</target>
        </trans-unit>
        <trans-unit id="b43ff6724657fd16732a9b1a55f67abda3312ad7" translate="yes" xml:space="preserve">
          <source>KotlinConf Spinner app</source>
          <target state="translated">KotlinConfスピナーアプリ</target>
        </trans-unit>
        <trans-unit id="b1cd61d796dd3aa3454e388dffcf47f0812af913" translate="yes" xml:space="preserve">
          <source>KotlinConf app</source>
          <target state="translated">KotlinConf アプリ</target>
        </trans-unit>
        <trans-unit id="6047c8afd00f076fe5dfb352137d01b27268ea83" translate="yes" xml:space="preserve">
          <source>KotlinNullPointerException</source>
          <target state="translated">KotlinNullPointerException</target>
        </trans-unit>
        <trans-unit id="ee7e86f4510f7d7092cbe3960fdb6815985528a4" translate="yes" xml:space="preserve">
          <source>KotlinReflectionNotSupportedError</source>
          <target state="translated">KotlinReflectionNotSupportedError</target>
        </trans-unit>
        <trans-unit id="4b1b0c248352273cdb7b000d38d1c480106dbb58" translate="yes" xml:space="preserve">
          <source>KotlinVersion</source>
          <target state="translated">KotlinVersion</target>
        </trans-unit>
        <trans-unit id="399d4d156e1a5773fbf3b4b0cfd04b6e517c9fca" translate="yes" xml:space="preserve">
          <source>KtFunction</source>
          <target state="translated">KtFunction</target>
        </trans-unit>
        <trans-unit id="57da6543f61562be137bdbd9c9e157724aeffda4" translate="yes" xml:space="preserve">
          <source>LEFT_TO_RIGHT</source>
          <target state="translated">LEFT_TO_RIGHT</target>
        </trans-unit>
        <trans-unit id="a75ecccfbf31bd489981a90341d7e832ee10f3c8" translate="yes" xml:space="preserve">
          <source>LEFT_TO_RIGHT_EMBEDDING</source>
          <target state="translated">LEFT_TO_RIGHT_EMBEDDING</target>
        </trans-unit>
        <trans-unit id="51859752bb5b0316e072d757734043db04448fc4" translate="yes" xml:space="preserve">
          <source>LEFT_TO_RIGHT_OVERRIDE</source>
          <target state="translated">LEFT_TO_RIGHT_OVERRIDE</target>
        </trans-unit>
        <trans-unit id="758213c577cf41a86fde124f3b88be88d415048d" translate="yes" xml:space="preserve">
          <source>LETTER_NUMBER</source>
          <target state="translated">LETTER_NUMBER</target>
        </trans-unit>
        <trans-unit id="e8e9a4d54a1399696ec25a431fcc0c615fbc2e7a" translate="yes" xml:space="preserve">
          <source>LINE_SEPARATOR</source>
          <target state="translated">LINE_SEPARATOR</target>
        </trans-unit>
        <trans-unit id="e84f54372586b1a789f2b6cf056c7a1173be8141" translate="yes" xml:space="preserve">
          <source>LINUX</source>
          <target state="translated">LINUX</target>
        </trans-unit>
        <trans-unit id="7ec99800d18c128a406891a50a13ae7030c97a75" translate="yes" xml:space="preserve">
          <source>LITERAL</source>
          <target state="translated">LITERAL</target>
        </trans-unit>
        <trans-unit id="e893e5d306bb8ac993e8000a6af037f4725105be" translate="yes" xml:space="preserve">
          <source>LOCAL_VARIABLE</source>
          <target state="translated">LOCAL_VARIABLE</target>
        </trans-unit>
        <trans-unit id="99de6ad7c4876501b047c66fac1fc218394c8386" translate="yes" xml:space="preserve">
          <source>LOWERCASE_LETTER</source>
          <target state="translated">LOWERCASE_LETTER</target>
        </trans-unit>
        <trans-unit id="ebb1178c70d79da7a0d8f3efa343b4f1b5b8c8bd" translate="yes" xml:space="preserve">
          <source>Lambda Expressions and Anonymous Functions</source>
          <target state="translated">ラムダ式と匿名関数</target>
        </trans-unit>
        <trans-unit id="41d636c884bc5c4615a06b36835ca61116f4c96a" translate="yes" xml:space="preserve">
          <source>Lambda expression syntax</source>
          <target state="translated">ラムダ式の構文</target>
        </trans-unit>
        <trans-unit id="0b86dab2bd78e474cfa2ccedae83439dde48687c" translate="yes" xml:space="preserve">
          <source>Lambda expressions and anonymous functions are 'function literals', i.e. functions that are not declared, but passed immediately as an expression. Consider the following example:</source>
          <target state="translated">ラムダ式や匿名関数は「関数リテラル」、つまり宣言されずに式としてすぐに渡される関数です。次の例を考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="5688b8dc62f61bfb17ef962f1f3970299059391c" translate="yes" xml:space="preserve">
          <source>Lambda expressions and anonymous functions are collectively called &lt;em&gt;function literals&lt;/em&gt;.</source>
          <target state="translated">ラムダ式と無名関数は、まとめて&lt;em&gt;関数リテラル&lt;/em&gt;と呼ばれ&lt;em&gt;ます&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="7575b2907cada2fd0b97a753d13dd1b9c1b841f5" translate="yes" xml:space="preserve">
          <source>Lambda expressions can be used as function literals with receiver when the receiver type can be inferred from context. One of the most important examples of their usage is &lt;a href=&quot;type-safe-builders&quot;&gt;type-safe builders&lt;/a&gt;:</source>
          <target state="translated">ラムダ式は、レシーバータイプをコンテキストから推測できる場合、レシーバーで関数リテラルとして使用できます。その使用法の最も重要な例の1つは、&lt;a href=&quot;type-safe-builders&quot;&gt;タイプセーフなビルダー&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="ad3d3ff2619991da585042e4417d2462b7beccf2" translate="yes" xml:space="preserve">
          <source>Lambda formatting</source>
          <target state="translated">ラムダフォーマット</target>
        </trans-unit>
        <trans-unit id="13d6fc1369e9172c884961d85e8a1601ad741c0d" translate="yes" xml:space="preserve">
          <source>Lambda parameters</source>
          <target state="translated">ラムダパラメータ</target>
        </trans-unit>
        <trans-unit id="b220e56144b93a1600b71766a84e029644f0540d" translate="yes" xml:space="preserve">
          <source>Lambda result</source>
          <target state="translated">ラムダ結果</target>
        </trans-unit>
        <trans-unit id="ba9dfe5041cd205445df5b843e8a9dc628256415" translate="yes" xml:space="preserve">
          <source>Lambdas</source>
          <target state="translated">Lambdas</target>
        </trans-unit>
        <trans-unit id="92af1ed3cd8ff99b216bc082c8daaf4fcc54a009" translate="yes" xml:space="preserve">
          <source>Lambdas returning &lt;code&gt;kotlin.Result&lt;/code&gt; now return boxed value instead of unboxed</source>
          <target state="translated">返すラムダ &lt;code&gt;kotlin.Result&lt;/code&gt; は今箱入り値を返す代わりにアンボクシング</target>
        </trans-unit>
        <trans-unit id="5a9f9099a35efc6c2d9f032d57efb49b93a9221c" translate="yes" xml:space="preserve">
          <source>Language and stdlib</source>
          <target state="translated">言語とstdlib</target>
        </trans-unit>
        <trans-unit id="fa3f4623762408896074b73a50b22e0a64f2aec4" translate="yes" xml:space="preserve">
          <source>Language features and improvements</source>
          <target state="translated">言語機能と改善</target>
        </trans-unit>
        <trans-unit id="49ddf0eb799de42693040dadaac202ba4004f236" translate="yes" xml:space="preserve">
          <source>Language settings</source>
          <target state="translated">言語設定</target>
        </trans-unit>
        <trans-unit id="a69a0d9ceb988516811878ad5b3baf535d6a8d16" translate="yes" xml:space="preserve">
          <source>Language settings are checked for consistency in the following ways:</source>
          <target state="translated">言語設定の整合性は、以下の方法でチェックされます。</target>
        </trans-unit>
        <trans-unit id="1ff5129754f331271a9a3fac5165d942c8cc5ff1" translate="yes" xml:space="preserve">
          <source>Language settings of a source set affect how the sources are analyzed in the IDE. Due to the current limitations, in a Gradle build, only the language settings of the compilation's default source set are used and are applied to all of the sources participating in the compilation.</source>
          <target state="translated">ソースセットの言語設定は、IDEでソースがどのように解析されるかに影響します。現在の制限のため、Gradle のビルドでは、コンパイルのデフォルトソースセットの言語設定のみが使用され、コンパイルに参加しているすべてのソースに適用されます。</target>
        </trans-unit>
        <trans-unit id="d6774da675388cdd08014c6406478bff14597287" translate="yes" xml:space="preserve">
          <source>Late-Initialized Properties and Variables</source>
          <target state="translated">初期化されたプロパティと変数</target>
        </trans-unit>
        <trans-unit id="99322069c074a7f591d86eb26eeac43fa69f34bd" translate="yes" xml:space="preserve">
          <source>Lateinit</source>
          <target state="translated">Lateinit</target>
        </trans-unit>
        <trans-unit id="f84a3ef3e20f72377a42e84bdb45e09bb7b7843f" translate="yes" xml:space="preserve">
          <source>Lateinit top-level properties and local variables</source>
          <target state="translated">Lateinit トップレベルのプロパティとローカル変数</target>
        </trans-unit>
        <trans-unit id="8958c019aa5a02d51718ce29ef1d34ac94e1a924" translate="yes" xml:space="preserve">
          <source>Launching flow</source>
          <target state="translated">流れを起動する</target>
        </trans-unit>
        <trans-unit id="b3bb9d6cae3f462e729059bd666f0ea34bc0ea80" translate="yes" xml:space="preserve">
          <source>Lazily started async</source>
          <target state="translated">怠惰に非同期を開始</target>
        </trans-unit>
        <trans-unit id="84e98cf97551805d46a1030b73cb47aa40988008" translate="yes" xml:space="preserve">
          <source>Lazy</source>
          <target state="translated">Lazy</target>
        </trans-unit>
        <trans-unit id="be5e08be6cf0006ff0c341fef7d3f6b41fb802ed" translate="yes" xml:space="preserve">
          <source>Lazy property</source>
          <target state="translated">怠惰な性質</target>
        </trans-unit>
        <trans-unit id="54579fdbee70b6cb28a03b9cca5ce503dbf0fab9" translate="yes" xml:space="preserve">
          <source>LazyThreadSafetyMode</source>
          <target state="translated">LazyThreadSafetyMode</target>
        </trans-unit>
        <trans-unit id="88e85262e00274cab89a641da3cb45b95f5a2ce2" translate="yes" xml:space="preserve">
          <source>Learn &lt;a href=&quot;native/cocoapods&quot;&gt;how to add dependencies&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;native/cocoapods&quot;&gt;依存関係を追加する方法を&lt;/a&gt;学びます。</target>
        </trans-unit>
        <trans-unit id="aca4dc328f8e03ba7e98c1efbf5068f7d83287c3" translate="yes" xml:space="preserve">
          <source>Learn Kotlin</source>
          <target state="translated">ベースンを学ぶ</target>
        </trans-unit>
        <trans-unit id="e3737ad5066ff8c2efc62a80380f6fc54741a2ea" translate="yes" xml:space="preserve">
          <source>Learn about &lt;a href=&quot;../../reference/mpp-discover-project&quot;&gt;multiplatform projects&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../reference/mpp-discover-project&quot;&gt;マルチプラットフォームプロジェクト&lt;/a&gt;について学びます。</target>
        </trans-unit>
        <trans-unit id="2474d64d95d6b15d329e41bab7ed01766c506ac9" translate="yes" xml:space="preserve">
          <source>Learn how to &lt;a href=&quot;mpp-configure-compilations&quot;&gt;configure compilations&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;mpp-configure-compilations&quot;&gt;コンパイル&lt;/a&gt;を構成する方法を学びます。</target>
        </trans-unit>
        <trans-unit id="6bcd0abba8e732ce3f464292f0728067fe8360ff" translate="yes" xml:space="preserve">
          <source>Learn how to &lt;a href=&quot;mpp-set-up-targets&quot;&gt;set up targets manually&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;mpp-set-up-targets&quot;&gt;ターゲットを手動で設定する&lt;/a&gt;方法を学びます。</target>
        </trans-unit>
        <trans-unit id="20953bfc9862dd27c555f29879ffef5ff21fa3c3" translate="yes" xml:space="preserve">
          <source>Learn how to &lt;a href=&quot;mpp-share-on-platforms#share-code-on-similar-platforms&quot;&gt;build the hierarchy of source sets&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;mpp-share-on-platforms#share-code-on-similar-platforms&quot;&gt;ソースセットの階層&lt;/a&gt;を構築する方法を学びます。</target>
        </trans-unit>
        <trans-unit id="e2ca28cd12d1bd44a1297fd960c1eedef1b345b3" translate="yes" xml:space="preserve">
          <source>Learn how to &lt;a href=&quot;using-gradle#dependency-on-the-standard-library&quot;&gt;change the default behavior&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;using-gradle#dependency-on-the-standard-library&quot;&gt;デフォルトの動作&lt;/a&gt;を変更する方法を学びます。</target>
        </trans-unit>
        <trans-unit id="64487eb003a10dbcb473f2557c19c16b00054e2a" translate="yes" xml:space="preserve">
          <source>Learn more about &lt;a href=&quot;#share-code-in-libraries&quot;&gt;sharing code in libraries&lt;/a&gt; and &lt;a href=&quot;#use-native-libraries-in-the-hierarchical-structure&quot;&gt;using Native libraries in the hierarchical structure&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#share-code-in-libraries&quot;&gt;ライブラリ&lt;/a&gt;でコードを共有&lt;a href=&quot;#use-native-libraries-in-the-hierarchical-structure&quot;&gt;し、階層構造でネイティブライブラリ&lt;/a&gt;を使用する方法の詳細をご覧ください。</target>
        </trans-unit>
        <trans-unit id="ed58d30a4c6366747487c1ab11dfdb8bd165900e" translate="yes" xml:space="preserve">
          <source>Learn more about &lt;a href=&quot;fun-interfaces&quot;&gt;Kotlin functional interfaces and SAM conversions&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;fun-interfaces&quot;&gt;Kotlinの機能インターフェイスとSAM変換の&lt;/a&gt;詳細をご覧ください。</target>
        </trans-unit>
        <trans-unit id="e3a266a26503caec98e47c6ba6a7a5accc48d540" translate="yes" xml:space="preserve">
          <source>Learn more about &lt;a href=&quot;js-project-setup&quot;&gt;configuring Kotlin/JS projects&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;js-project-setup&quot;&gt;Kotlin / JSプロジェクトの構成の&lt;/a&gt;詳細をご覧ください。</target>
        </trans-unit>
        <trans-unit id="68ece8a8530cbd084c4191e879166f55575d6c48" translate="yes" xml:space="preserve">
          <source>Learn more about &lt;a href=&quot;mpp-build-native-binaries&quot;&gt;building native binaries&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;mpp-build-native-binaries&quot;&gt;ネイティブバイナリの構築の&lt;/a&gt;詳細をご覧ください。</target>
        </trans-unit>
        <trans-unit id="a7794648f1ef065710c83db4bd3fd00ce935fd99" translate="yes" xml:space="preserve">
          <source>Learn more about &lt;a href=&quot;mpp-configure-compilations&quot;&gt;configuring compilations&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;mpp-configure-compilations&quot;&gt;コンパイルの構成の&lt;/a&gt;詳細をご覧ください。</target>
        </trans-unit>
        <trans-unit id="35eb7e7ef591eb8121626725e4cbc15aad464688" translate="yes" xml:space="preserve">
          <source>Learn more about &lt;a href=&quot;mpp-configure-compilations#compilation-for-android&quot;&gt;compilation for Android&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;mpp-configure-compilations#compilation-for-android&quot;&gt;Android用のコンパイルの&lt;/a&gt;詳細をご覧ください。</target>
        </trans-unit>
        <trans-unit id="b82dbe77a2cb72a3eed96435795f26fc5fd861ab" translate="yes" xml:space="preserve">
          <source>Learn more about &lt;a href=&quot;mpp-discover-project#source-sets&quot;&gt;source sets&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;mpp-discover-project#source-sets&quot;&gt;ソースセットの&lt;/a&gt;詳細をご覧ください。</target>
        </trans-unit>
        <trans-unit id="8403f45e73c3fa76d6076b7f5f4ef79b474eabc9" translate="yes" xml:space="preserve">
          <source>Learn more about &lt;a href=&quot;mpp-dsl-reference#common-target-configuration&quot;&gt;additional settings for targets&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;mpp-dsl-reference#common-target-configuration&quot;&gt;ターゲットの追加設定の&lt;/a&gt;詳細をご覧ください。</target>
        </trans-unit>
        <trans-unit id="2f4ffd267ae3e789bf0bdbf84175cab85c2a10c6" translate="yes" xml:space="preserve">
          <source>Learn more about &lt;a href=&quot;mpp-share-on-platforms#use-native-libraries-in-the-hierarchical-structure&quot;&gt;usage of platform-dependent libraries&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;mpp-share-on-platforms#use-native-libraries-in-the-hierarchical-structure&quot;&gt;プラットフォームに依存するライブラリの使用法の&lt;/a&gt;詳細をご覧ください。</target>
        </trans-unit>
        <trans-unit id="10bdd6e03dcdfbfdc0a865fbc438364cc7870614" translate="yes" xml:space="preserve">
          <source>Learn more about &lt;a href=&quot;using-gradle#configuring-dependencies&quot;&gt;configuring dependencies&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;using-gradle#configuring-dependencies&quot;&gt;依存関係の構成の&lt;/a&gt;詳細をご覧ください。</target>
        </trans-unit>
        <trans-unit id="802c13534d20e4859719f8999764811676dc2ecd" translate="yes" xml:space="preserve">
          <source>Learn more about coroutines debugging in the &lt;a href=&quot;../../tutorials/coroutines/debug-coroutines-with-idea&quot;&gt;tutorial&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../tutorials/coroutines/debug-coroutines-with-idea&quot;&gt;チュートリアルで&lt;/a&gt;コルーチンのデバッグの詳細をご覧ください。</target>
        </trans-unit>
        <trans-unit id="f0f6b2049ff0f8271b4ef5ecd9ffeb77c34f8ee0" translate="yes" xml:space="preserve">
          <source>Learn more about creating a &lt;a href=&quot;mpp-configure-compilations#create-a-custom-compilation&quot;&gt;custom compilation&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;mpp-configure-compilations#create-a-custom-compilation&quot;&gt;カスタムコンパイルの&lt;/a&gt;作成の詳細をご覧ください。</target>
        </trans-unit>
        <trans-unit id="e871fbb0e4ca02f35986ac2bcdf867ebcc67c62b" translate="yes" xml:space="preserve">
          <source>Learn more about debugging coroutines in &lt;a href=&quot;https://blog.jetbrains.com/kotlin/2020/07/kotlin-1-4-rc-debugging-coroutines/&quot;&gt;this blog post&lt;/a&gt; and &lt;a href=&quot;https://www.jetbrains.com/help/idea/debug-kotlin-coroutines.html&quot;&gt;IntelliJ IDEA documentation&lt;/a&gt;.</source>
          <target state="translated">コルーチンのデバッグについて詳しくは、&lt;a href=&quot;https://blog.jetbrains.com/kotlin/2020/07/kotlin-1-4-rc-debugging-coroutines/&quot;&gt;このブログ投稿&lt;/a&gt;と&lt;a href=&quot;https://www.jetbrains.com/help/idea/debug-kotlin-coroutines.html&quot;&gt;IntelliJIDEAドキュメントを&lt;/a&gt;ご覧ください。</target>
        </trans-unit>
        <trans-unit id="c350bcedee9353ee1217f26074d552b05f99da2b" translate="yes" xml:space="preserve">
          <source>Learn more about the &lt;a href=&quot;https://github.com/JetBrains/kotlin/blob/1.4.0/native/commonizer/README.md&quot;&gt;technical details&lt;/a&gt;.</source>
          <target state="translated">詳細情報&lt;a href=&quot;https://github.com/JetBrains/kotlin/blob/1.4.0/native/commonizer/README.md&quot;&gt;の技術的な詳細を&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="382bc2b5420e5bc5b00d6eff83fe5cc43062a688" translate="yes" xml:space="preserve">
          <source>Learn more about the available features in the Kotlin/JS IR compiler backend in the &lt;a href=&quot;js-ir-compiler&quot;&gt;documentation&lt;/a&gt;.</source>
          <target state="translated">Kotlin / JS IRコンパイラバックエンドで利用可能な機能の詳細については、&lt;a href=&quot;js-ir-compiler&quot;&gt;ドキュメントを&lt;/a&gt;ご覧ください。</target>
        </trans-unit>
        <trans-unit id="65a7c9acfbc9796eb30e7c60b60f1b0ce15271c8" translate="yes" xml:space="preserve">
          <source>Learn more how to &lt;a href=&quot;mpp-configure-compilations#configure-interop-with-native-languages&quot;&gt;configure interop with native languages&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;mpp-configure-compilations#configure-interop-with-native-languages&quot;&gt;ネイティブ言語との相互運用&lt;/a&gt;を構成する方法の詳細をご覧ください。</target>
        </trans-unit>
        <trans-unit id="7fc982a7f5ebfb278a6eac9d43da3ac1981ee500" translate="yes" xml:space="preserve">
          <source>Learn more in &lt;a href=&quot;js-project-setup#choosing-execution-environment&quot;&gt;Setting up a Kotlin/JS project&lt;/a&gt;.</source>
          <target state="translated">詳細については&lt;a href=&quot;js-project-setup#choosing-execution-environment&quot;&gt;、Kotlin / JSプロジェクトの設定を&lt;/a&gt;ご覧ください。</target>
        </trans-unit>
        <trans-unit id="b28b1c4866b45b6c232187eb0f49c55bd90b8a14" translate="yes" xml:space="preserve">
          <source>Learning Kotlin</source>
          <target state="translated">コトリンを学ぶ</target>
        </trans-unit>
        <trans-unit id="23f50e0c99ce18545a5c0af46eb7b9685859fd37" translate="yes" xml:space="preserve">
          <source>Learning Kotlin with EduTools plugin</source>
          <target state="translated">EduToolsプラグインでKotlinを学ぶ</target>
        </trans-unit>
        <trans-unit id="e19a030656541f97ece0fe153ca0f1966796261d" translate="yes" xml:space="preserve">
          <source>Leave other options with their default values and click &lt;strong&gt;Finish&lt;/strong&gt;.</source>
          <target state="translated">他のオプションはデフォルト値のままにし、[ &lt;strong&gt;完了&lt;/strong&gt; ]をクリックします。</target>
        </trans-unit>
        <trans-unit id="b8d43e4d61d6a5ac38163dd5c6fce699c5294311" translate="yes" xml:space="preserve">
          <source>Let us have two producers of strings: &lt;code&gt;fizz&lt;/code&gt; and &lt;code&gt;buzz&lt;/code&gt;. The &lt;code&gt;fizz&lt;/code&gt; produces &quot;Fizz&quot; string every 300 ms:</source>
          <target state="translated">文字列の2つのプロデューサー、 &lt;code&gt;fizz&lt;/code&gt; と &lt;code&gt;buzz&lt;/code&gt; があるとします。 &lt;code&gt;fizz&lt;/code&gt; 、すべて300ミリ「フィズ」の文字列を生成します。</target>
        </trans-unit>
        <trans-unit id="d5d7818bcabda3185325fd62a8d08d65a192e5b3" translate="yes" xml:space="preserve">
          <source>Let us launch a hundred coroutines all doing the same action a thousand times. We'll also measure their completion time for further comparisons:</source>
          <target state="translated">同じ動作を1000回行う100個のコルーチンを起動してみましょう。さらに比較のために、それらの完了時間も測定してみましょう。</target>
        </trans-unit>
        <trans-unit id="97c13d20ca41b326b3be0985ea83f77551576d93" translate="yes" xml:space="preserve">
          <source>Let us launch a hundred coroutines all doing the same action thousand times. We'll also measure their completion time for further comparisons:</source>
          <target state="translated">100個のコルーチンを起動して、同じ動作を1000回行ってみましょう。さらに比較のために、それらの完了時間も測定してみましょう。</target>
        </trans-unit>
        <trans-unit id="00337a32763192378fa8ed88a3475bc09950f868" translate="yes" xml:space="preserve">
          <source>Let us put our knowledge about contexts, children and jobs together. Assume that our application has an object with a lifecycle, but that object is not a coroutine. For example, we are writing an Android application and launch various coroutines in the context of an Android activity to perform asynchronous operations to fetch and update data, do animations, etc. All of these coroutines must be cancelled when activity is destroyed to avoid memory leaks. We, of course, can manipulate contexts and jobs manually to tie activity's and coroutines lifecycles, but &lt;code&gt;kotlinx.coroutines&lt;/code&gt; provides an abstraction that encapsulates that: &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html&quot;&gt;CoroutineScope&lt;/a&gt;. You should be already familiar with coroutine scope as all coroutine builders are declared as extensions on it.</source>
          <target state="translated">コンテキスト、子供、仕事についての知識をまとめましょう。アプリケーションにライフサイクルを持つオブジェクトがあると仮定しますが、そのオブジェクトはコルーチンではありません。たとえば、Androidアプリケーションを作成し、Androidアクティビティのコンテキストでさまざまなコルーチンを起動して、データのフェッチや更新、アニメーションなどの非同期操作を実行します。メモリリークを回避するには、アクティビティが破棄されたときに、これらのコルーチンをすべてキャンセルする必要があります。 。私たちは、当然のことながら、活動のとコルーチンのライフサイクルを結びつけるために、手動でコンテキストとジョブを操作することができますが、 &lt;code&gt;kotlinx.coroutines&lt;/code&gt; は抽象化を提供するカプセル化し：&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html&quot;&gt;CoroutineScope&lt;/a&gt;。コルーチンスコープはすべてコルーチンビルダーに拡張として宣言されているため、コルーチンスコープに精通している必要があります。</target>
        </trans-unit>
        <trans-unit id="0f1725d0b230accb8eeb7b1ecce985617d4f3a5c" translate="yes" xml:space="preserve">
          <source>Let us put our knowledge about contexts, children and jobs together. Assume that our application has an object with a lifecycle, but that object is not a coroutine. For example, we are writing an Android application and launch various coroutines in the context of an Android activity to perform asynchronous operations to fetch and update data, do animations, etc. All of these coroutines must be cancelled when the activity is destroyed to avoid memory leaks. We, of course, can manipulate contexts and jobs manually to tie the lifecycles of the activity and its coroutines, but &lt;code&gt;kotlinx.coroutines&lt;/code&gt; provides an abstraction encapsulating that: &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html&quot;&gt;CoroutineScope&lt;/a&gt;. You should be already familiar with the coroutine scope as all coroutine builders are declared as extensions on it.</source>
          <target state="translated">文脈、子供、仕事についての知識をまとめましょう。アプリケーションにライフサイクルを持つオブジェクトがありますが、そのオブジェクトはコルーチンではないとします。たとえば、Androidアプリケーションを作成し、Androidアクティビティのコンテキストでさまざまなコルーチンを起動して、データのフェッチと更新、アニメーションの実行などの非同期操作を実行します。メモリを避けるために、アクティビティが破棄されたら、これらのコルーチンをすべてキャンセルする必要があります。リーク。私たちは、当然のことながら、活動及びそのコルーチンのライフサイクルを結びつけるために、手動でコンテキストとジョブを操作することができますが、 &lt;code&gt;kotlinx.coroutines&lt;/code&gt; はそれをカプセル化する抽象化を提供します：&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html&quot;&gt;CoroutineScope&lt;/a&gt;。すべてのコルーチンビルダーはその拡張機能として宣言されているため、コルーチンスコープについてはすでに理解している必要があります。</target>
        </trans-unit>
        <trans-unit id="f17004be77e3f7094989ac66ca7a6fcece2d7637" translate="yes" xml:space="preserve">
          <source>Let us run it all seven times:</source>
          <target state="translated">全部で7回走らせてみましょう。</target>
        </trans-unit>
        <trans-unit id="887399487cb35f46c356a942974d9aca65f7d75b" translate="yes" xml:space="preserve">
          <source>Let us start a dozen of them with a random delay.</source>
          <target state="translated">ランダム遅延で十数個始めてみよう。</target>
        </trans-unit>
        <trans-unit id="413db7e1244403c1e2eef1bc015d6f2b29e5c10d" translate="yes" xml:space="preserve">
          <source>Let us take &lt;a href=&quot;#concurrent-using-async&quot;&gt;Concurrent using async&lt;/a&gt; example and extract a function that concurrently performs &lt;code&gt;doSomethingUsefulOne&lt;/code&gt; and &lt;code&gt;doSomethingUsefulTwo&lt;/code&gt; and returns the sum of their results. Because &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html&quot;&gt;async&lt;/a&gt; coroutines builder is defined as extension on &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;CoroutineScope&lt;/a&gt; we need to have it in the scope and that is what &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;coroutineScope&lt;/a&gt; function provides:</source>
          <target state="translated">&lt;a href=&quot;#concurrent-using-async&quot;&gt;非同期の&lt;/a&gt;例を使用してConcurrentを取り上げ、 &lt;code&gt;doSomethingUsefulTwo&lt;/code&gt; と &lt;code&gt;doSomethingUsefulOne&lt;/code&gt; を同時に実行して結果の合計を返す関数を抽出してみましょう。ので&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html&quot;&gt;非同期&lt;/a&gt;コルーチンビルダーは、上の拡張として定義されて&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;CoroutineScope&lt;/a&gt;我々はスコープでそれを持っている必要があり、それが何である&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;coroutineScopeの&lt;/a&gt;機能が用意されています。</target>
        </trans-unit>
        <trans-unit id="bcdef397c512533845238594a2c065ab9f9b9332" translate="yes" xml:space="preserve">
          <source>Let us take the &lt;a href=&quot;#concurrent-using-async&quot;&gt;Concurrent using async&lt;/a&gt; example and extract a function that concurrently performs &lt;code&gt;doSomethingUsefulOne&lt;/code&gt; and &lt;code&gt;doSomethingUsefulTwo&lt;/code&gt; and returns the sum of their results. Because the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html&quot;&gt;async&lt;/a&gt; coroutine builder is defined as an extension on &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html&quot;&gt;CoroutineScope&lt;/a&gt;, we need to have it in the scope and that is what the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;coroutineScope&lt;/a&gt; function provides:</source>
          <target state="translated">&lt;a href=&quot;#concurrent-using-async&quot;&gt;非同期の&lt;/a&gt;例を使用して並行を取り、 &lt;code&gt;doSomethingUsefulOne&lt;/code&gt; と &lt;code&gt;doSomethingUsefulTwo&lt;/code&gt; を同時に実行し、それらの結果の合計を返す関数を抽出してみましょう。ので&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html&quot;&gt;非同期&lt;/a&gt;コルーチンビルダーは、上の拡張として定義されて&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html&quot;&gt;CoroutineScope&lt;/a&gt;、我々はスコープでそれを持っている必要があり、それが何である&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;coroutineScopeの&lt;/a&gt;機能が用意されています。</target>
        </trans-unit>
        <trans-unit id="4952c7e38d872a3739e9ba60b2855b8019e8b9ca" translate="yes" xml:space="preserve">
          <source>Let us write a channel producer function that consumes a channel of deferred string values, waits for each received deferred value, but only until the next deferred value comes over or the channel is closed. This example puts together &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/on-receive-or-null.html&quot;&gt;onReceiveOrNull&lt;/a&gt; and &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/on-await.html&quot;&gt;onAwait&lt;/a&gt; clauses in the same &lt;code&gt;select&lt;/code&gt;:</source>
          <target state="translated">遅延文字列値のチャネルを消費し、受信した各遅延値を待機するチャネルプロデューサー関数を記述してみましょう。ただし、次の遅延値が発生するか、チャネルが閉じられるまでのみです。この例プット一緒&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/on-receive-or-null.html&quot;&gt;onReceiveOrNull&lt;/a&gt;と&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/on-await.html&quot;&gt;onAwait&lt;/a&gt;同じで句 &lt;code&gt;select&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="4731fc0f08644e9fc8c26a8f5800aec92b69f2ee" translate="yes" xml:space="preserve">
          <source>Let us write an example of producer of integers that sends its values to a &lt;code&gt;side&lt;/code&gt; channel when the consumers on its primary channel cannot keep up with it:</source>
          <target state="translated">プライマリチャネルのコンシューマーが対応できない場合に、値を &lt;code&gt;side&lt;/code&gt; チャネルに送信する整数のプロデューサーの例を書いてみましょう。</target>
        </trans-unit>
        <trans-unit id="2a09d0572f014b56fede8ceb5d706fa8418ec701" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s take a look at how to serialize Kotlin objects into JSON.</source>
          <target state="translated">KotlinオブジェクトをJSONにシリアル化する方法を見てみましょう。</target>
        </trans-unit>
        <trans-unit id="9ad40ae1c76d7921aa80d947aae7e4174122ffe9" translate="yes" xml:space="preserve">
          <source>Let's also make sure that our coroutines actually run in parallel. If we add a 1-second &lt;code&gt;delay()&lt;/code&gt; to each of the &lt;code&gt;async&lt;/code&gt;'s, the resulting program won't run for 1'000'000 seconds (over 11,5 days):</source>
          <target state="translated">また、コルーチンが実際に並行して実行されることを確認しましょう。各 &lt;code&gt;async&lt;/code&gt; に 1秒の &lt;code&gt;delay()&lt;/code&gt; を追加すると、結果のプログラムは1'000'000秒（11.5日以上）実行されません。</target>
        </trans-unit>
        <trans-unit id="d5f68d829cd771ce134770e031cf5bf3966ac35a" translate="yes" xml:space="preserve">
          <source>Let's assume in the code above that &lt;code&gt;preparePost&lt;/code&gt; is a long-running process and consequently would block the user interface. What we can do is launch it in a separate thread. This would then allow us to avoid the UI from blocking. This is a very common technique, but has a series of drawbacks:</source>
          <target state="translated">上記のコードで &lt;code&gt;preparePost&lt;/code&gt; が長時間実行されるプロセスであり、その結果ユーザーインターフェイスがブロックされると仮定しましょう。私たちができることは、別のスレッドでそれを起動することです。これにより、UIのブロックを回避できます。これは非常に一般的な手法ですが、一連の欠点があります。</target>
        </trans-unit>
        <trans-unit id="0b36e6d9aeacb6946bbe6f44c31eebe2f8d34c7f" translate="yes" xml:space="preserve">
          <source>Let's call the framework from Objective-C. For that we create the &lt;code&gt;main.m&lt;/code&gt; file with the following content:</source>
          <target state="translated">Objective-Cからフレームワークを呼び出しましょう。そのために、次の内容の &lt;code&gt;main.m&lt;/code&gt; ファイルを作成します。</target>
        </trans-unit>
        <trans-unit id="de2db89a9bd54d886863702055b65232c802ea65" translate="yes" xml:space="preserve">
          <source>Let's check out the C API of our Kotlin library.`</source>
          <target state="translated">Kotlin ライブラリの C API を見てみましょう。</target>
        </trans-unit>
        <trans-unit id="ccdc7274b76228eb418fb01b25e4e0b2b1a04fe1" translate="yes" xml:space="preserve">
          <source>Let's click on the &lt;code&gt;App&lt;/code&gt; run configuration to get our project running either on a real Android Device or on the emulator.</source>
          <target state="translated">&lt;code&gt;App&lt;/code&gt; 実行構成をクリックして、実際のAndroidデバイスまたはエミュレーターでプロジェクトを実行します。</target>
        </trans-unit>
        <trans-unit id="1f650b1ab54a0b4e48ce9f7def949cc9e4127516" translate="yes" xml:space="preserve">
          <source>Let's click the &lt;em&gt;Run&lt;/em&gt; button in Xcode, and we'll see our application running</source>
          <target state="translated">Xcodeの「&lt;em&gt;実行」&lt;/em&gt;ボタンをクリックしてみましょう。アプリケーションが実行されているのがわかります。</target>
        </trans-unit>
        <trans-unit id="735664d189535b1add7a525bb222b33a786f953e" translate="yes" xml:space="preserve">
          <source>Let's create a &lt;code&gt;src/nativeMain/kotlin/hello.kt&lt;/code&gt; stub file with the following content to see how C primitive type declarations are visible from Kotlin:</source>
          <target state="translated">次の内容で &lt;code&gt;src/nativeMain/kotlin/hello.kt&lt;/code&gt; スタブファイルを作成して、Cプリミティブ型宣言がKotlinからどのように見えるかを確認してみましょう。</target>
        </trans-unit>
        <trans-unit id="10159fd0817061a10325f96cf0c251b77597ee1f" translate="yes" xml:space="preserve">
          <source>Let's create a &lt;code&gt;src/nativeMain/kotlin/hello.kt&lt;/code&gt; stub file with the following content to see how our C declarations are visible from Kotlin:</source>
          <target state="translated">次の内容の &lt;code&gt;src/nativeMain/kotlin/hello.kt&lt;/code&gt; スタブファイルを作成して、C宣言がKotlinからどのように見えるかを確認してみましょう。</target>
        </trans-unit>
        <trans-unit id="a7acdfe9286fc908f1acf3c36443211f26fc104a" translate="yes" xml:space="preserve">
          <source>Let's create a million coroutines again, keeping their &lt;code&gt;Deferred&lt;/code&gt; objects. Now there's no need in the atomic counter, as we can just return the numbers to be added from our coroutines:</source>
          <target state="translated">&lt;code&gt;Deferred&lt;/code&gt; オブジェクトを保持したまま、100万個のコルーチンを作成してみましょう。これで、追加する数値をコルーチンから返すことができるため、アトミックカウンターは必要ありません。</target>
        </trans-unit>
        <trans-unit id="996aed5293f16fb62ea0b0ffc195f181e0ae218e" translate="yes" xml:space="preserve">
          <source>Let's create the class &lt;code&gt;Base64Test&lt;/code&gt; in &lt;code&gt;commonTest/kotlin/jetbrains/base64&lt;/code&gt; folder and write the basic tests for Base64.</source>
          <target state="translated">クラスを作成してみましょう &lt;code&gt;Base64Test&lt;/code&gt; をして &lt;code&gt;commonTest/kotlin/jetbrains/base64&lt;/code&gt; フォルダやBase64のための基本的なテストを書きます。</target>
        </trans-unit>
        <trans-unit id="bbdbbcfe4f2f14866b323983f8f8272c8a107004" translate="yes" xml:space="preserve">
          <source>Let's denote a function f(x) in such a way: we add 1 to x, then, while there is at least one trailing zero in the resulting number, we remove that zero.</source>
          <target state="translated">関数f(x)をこのように表してみましょう:xに1を加え、その結果として得られる数の最後に少なくとも1つのゼロがある間に、そのゼロを除去します。</target>
        </trans-unit>
        <trans-unit id="b41c2ae19915325ca1208b1c0d9b4b01df9a8df1" translate="yes" xml:space="preserve">
          <source>Let's dig a little into what it means. The biggest merit of coroutines is that they can &lt;em&gt;suspend&lt;/em&gt; without blocking a thread. The compiler has to emit some special code to make this possible, so we have to mark functions that &lt;em&gt;may suspend&lt;/em&gt; explicitly in the code. We use the &lt;code&gt;suspend&lt;/code&gt; modifier for it:</source>
          <target state="translated">それが何を意味するかを少し掘り下げましょう。コルーチンの最大のメリットは、スレッドをブロックせずに&lt;em&gt;中断&lt;/em&gt;できることです。これを可能にするには、コンパイラーが特別なコードを発行する必要があるため、コード内で明示的に&lt;em&gt;中断さ&lt;/em&gt;れる&lt;em&gt;可能性のある&lt;/em&gt;関数をマークする必要&lt;em&gt;が&lt;/em&gt;あります。そのために &lt;code&gt;suspend&lt;/code&gt; 修飾子を使用します。</target>
        </trans-unit>
        <trans-unit id="b909fa7b179bbce71ededd8361a6bf68ecb8e547" translate="yes" xml:space="preserve">
          <source>Let's extract the block of code inside &lt;code&gt;launch { ... }&lt;/code&gt; into a separate function. When you perform &quot;Extract function&quot; refactoring on this code you get a new function with &lt;code&gt;suspend&lt;/code&gt; modifier. That is your first &lt;em&gt;suspending function&lt;/em&gt;. Suspending functions can be used inside coroutines just like regular functions, but their additional feature is that they can, in turn, use other suspending functions, like &lt;code&gt;delay&lt;/code&gt; in this example, to &lt;em&gt;suspend&lt;/em&gt; execution of a coroutine.</source>
          <target state="translated">&lt;code&gt;launch { ... }&lt;/code&gt; 内のコードのブロックを別の関数に抽出してみましょう。このコードで「関数の抽出」リファクタリングを実行すると、 &lt;code&gt;suspend&lt;/code&gt; 修飾子を持つ新しい関数が得られます。これが最初の&lt;em&gt;一時停止機能&lt;/em&gt;です。一時停止関数は、通常の関数と同じようにコルーチン内で使用できますが、追加機能として、この例の &lt;code&gt;delay&lt;/code&gt; などの他の一時停止関数を使用して、コルーチンの実行を&lt;em&gt;一時停止でき&lt;/em&gt;ます。</target>
        </trans-unit>
        <trans-unit id="61bad05f01a2e90a1664c7ea21ea22130405aa4e" translate="yes" xml:space="preserve">
          <source>Let's extract the block of code inside &lt;code&gt;launch { ... }&lt;/code&gt; into a separate function. When you perform &quot;Extract function&quot; refactoring on this code, you get a new function with the &lt;code&gt;suspend&lt;/code&gt; modifier. This is your first &lt;em&gt;suspending function&lt;/em&gt;. Suspending functions can be used inside coroutines just like regular functions, but their additional feature is that they can, in turn, use other suspending functions (like &lt;code&gt;delay&lt;/code&gt; in this example) to &lt;em&gt;suspend&lt;/em&gt; execution of a coroutine.</source>
          <target state="translated">&lt;code&gt;launch { ... }&lt;/code&gt; 内のコードブロックを別の関数に抽出してみましょう。このコードで「関数の抽出」リファクタリングを実行すると、 &lt;code&gt;suspend&lt;/code&gt; 修飾子を使用して新しい関数を取得します。これは最初の&lt;em&gt;一時停止機能&lt;/em&gt;です。一時停止関数は、通常の関数と同じようにコルーチン内で使用できますが、追加の機能として、他の一時停止関数（この例では &lt;code&gt;delay&lt;/code&gt; など）を使用してコルーチンの実行を&lt;em&gt;一時停止でき&lt;/em&gt;ます。</target>
        </trans-unit>
        <trans-unit id="e7122eef62315ddd178e19521346dcd7b3d4f4ef" translate="yes" xml:space="preserve">
          <source>Let's first create a project folder. All the paths in this tutorial will be relative to this folder. Sometimes the missing directories will have to be created before new files are added.</source>
          <target state="translated">まず、プロジェクトフォルダを作成しましょう。このチュートリアルのすべてのパスは、このフォルダからの相対パスになります。時々、新しいファイルを追加する前に不足しているディレクトリを作成しなければならないことがあります。</target>
        </trans-unit>
        <trans-unit id="8cb38e1408559447345a86b525296d1eabcbbd05" translate="yes" xml:space="preserve">
          <source>Let's get straight to the point - type this into a file with the extension &lt;code&gt;.kt&lt;/code&gt;:</source>
          <target state="translated">ポイントにまっすぐに行きましょう-これを拡張子 &lt;code&gt;.kt&lt;/code&gt; のファイルに入力します：</target>
        </trans-unit>
        <trans-unit id="bd86f7e49e4cf62602c569422996655dedc19452" translate="yes" xml:space="preserve">
          <source>Let's include the dependency from the &lt;code&gt;SharedCode&lt;/code&gt; project to the Android project. We need to patch the &lt;code&gt;app/build.gradle&lt;/code&gt; file and include the following line into the &lt;code&gt;dependencies { .. }&lt;/code&gt; block:</source>
          <target state="translated">&lt;code&gt;SharedCode&lt;/code&gt; プロジェクトからAndroidプロジェクトへの依存関係を含めましょう。 &lt;code&gt;app/build.gradle&lt;/code&gt; ファイルにパッチを適用し、次の行を &lt;code&gt;dependencies { .. }&lt;/code&gt; ブロックに含める必要があります。</target>
        </trans-unit>
        <trans-unit id="b82b4fa1803ecc5b171c4989f538f93a5e12eeda" translate="yes" xml:space="preserve">
          <source>Let's just check everything is right with the project so far, the project structure should be:</source>
          <target state="translated">ここまでのプロジェクトで問題がないことを確認してみましょう、プロジェクトの構造はこうでなければなりません。</target>
        </trans-unit>
        <trans-unit id="3031affd63f3a34c70e027c9fb0083b3841cbbd1" translate="yes" xml:space="preserve">
          <source>Let's look at &lt;code&gt;async&lt;/code&gt;/&lt;code&gt;await&lt;/code&gt; which is implemented in an external library, &lt;a href=&quot;https://github.com/kotlin/kotlinx.coroutines&quot;&gt;kotlinx.coroutines&lt;/a&gt;:</source>
          <target state="translated">外部ライブラリ&lt;a href=&quot;https://github.com/kotlin/kotlinx.coroutines&quot;&gt;kotlinx.coroutinesに&lt;/a&gt;実装され &lt;code&gt;await&lt;/code&gt; いる &lt;code&gt;async&lt;/code&gt; / awaitを見てみましょう。</target>
        </trans-unit>
        <trans-unit id="957a84aa6afafd513ebe49ba72fc204fd5a6b335" translate="yes" xml:space="preserve">
          <source>Let's look at a full program that uses &lt;code&gt;launch&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;launch&lt;/code&gt; を使用する完全なプログラムを見てみましょう。</target>
        </trans-unit>
        <trans-unit id="4e571fdb95d6ede65232f8b540598b12acfcf120" translate="yes" xml:space="preserve">
          <source>Let's look over it to spot what has changed. In Java you annotated the field, binding it with the corresponding view:</source>
          <target state="translated">何が変わったのかを見てみましょう。Javaでは、フィールドにアノテーションを付け、対応するビューにバインドしていました。</target>
        </trans-unit>
        <trans-unit id="1fb40ced67af4648c46e396667df192d29c4d5c8" translate="yes" xml:space="preserve">
          <source>Let's make sure we can run the application on the iPhone emulator or device.</source>
          <target state="translated">iPhoneのエミュレータやデバイスでアプリを実行できることを確認してみましょう。</target>
        </trans-unit>
        <trans-unit id="4c1369d1fff2907e87dbe0e51a95a4a2b1d68308" translate="yes" xml:space="preserve">
          <source>Let's move the sources file into the &lt;code&gt;src/nativeMain/kotlin&lt;/code&gt; folder under the project. That is the default path, where sources are located, when the &lt;a href=&quot;../../reference/building-mpp-with-gradle&quot;&gt;kotlin-multiplatform&lt;/a&gt; plugin is used. We use the following block to instruct configure the project to generate a dynamic or shared library for us:</source>
          <target state="translated">sourcesファイルをプロジェクトの &lt;code&gt;src/nativeMain/kotlin&lt;/code&gt; フォルダーに移動します。これは、&lt;a href=&quot;../../reference/building-mpp-with-gradle&quot;&gt;kotlin-multiplatform&lt;/a&gt;プラグインが使用されている場合の、ソースが配置されているデフォルトのパスです。次のブロックを使用して、動的または共有ライブラリを生成するようにプロジェクトを構成します。</target>
        </trans-unit>
        <trans-unit id="254d91019bfe0a24fa67828566bb23aeecf078e8" translate="yes" xml:space="preserve">
          <source>Let's move the sources file into the &lt;code&gt;src/nativeMain/kotlin&lt;/code&gt; folder under the project. That is the default path, where sources are located, when the &lt;a href=&quot;../../reference/mpp-discover-project&quot;&gt;kotlin-multiplatform&lt;/a&gt; plugin is used. We use the following block to instruct configure the project to generate a dynamic or shared library for us:</source>
          <target state="translated">ソースファイルをプロジェクトの下の &lt;code&gt;src/nativeMain/kotlin&lt;/code&gt; フォルダーに移動しましょう。これは、&lt;a href=&quot;../../reference/mpp-discover-project&quot;&gt;kotlin-multiplatform&lt;/a&gt;プラグインが使用される場合の、ソースが配置されるデフォルトのパスです。次のブロックを使用して、動的ライブラリまたは共有ライブラリを生成するようにプロジェクトを構成するように指示します。</target>
        </trans-unit>
        <trans-unit id="684a72371b803184f7a1d16df5fdf49dd7a6a0de" translate="yes" xml:space="preserve">
          <source>Let's move the sources file into the &lt;code&gt;src/nativeMain/kotlin&lt;/code&gt; folder under the project. This is the default path, for where sources are located, when the &lt;a href=&quot;../../reference/building-mpp-with-gradle&quot;&gt;kotlin-multiplatform&lt;/a&gt; plugin is used. We use the following block to instruct and configure the project to generate a dynamic or shared library for us:</source>
          <target state="translated">sourcesファイルをプロジェクトの &lt;code&gt;src/nativeMain/kotlin&lt;/code&gt; フォルダーに移動します。これは、&lt;a href=&quot;../../reference/building-mpp-with-gradle&quot;&gt;kotlin-multiplatform&lt;/a&gt;プラグインを使用する場合の、ソースが配置されるデフォルトのパスです。次のブロックを使用して、動的または共有ライブラリを生成するようにプロジェクトに指示および構成します。</target>
        </trans-unit>
        <trans-unit id="034d9c3c346b06a98e0db9b883376985d9d3fdc3" translate="yes" xml:space="preserve">
          <source>Let's move the sources file into the &lt;code&gt;src/nativeMain/kotlin&lt;/code&gt; folder under the project. This is the default path, for where sources are located, when the &lt;a href=&quot;../../reference/mpp-discover-project&quot;&gt;kotlin-multiplatform&lt;/a&gt; plugin is used. We use the following block to instruct and configure the project to generate a dynamic or shared library for us:</source>
          <target state="translated">ソースファイルをプロジェクトの下の &lt;code&gt;src/nativeMain/kotlin&lt;/code&gt; フォルダーに移動しましょう。これは、&lt;a href=&quot;../../reference/mpp-discover-project&quot;&gt;kotlin-multiplatform&lt;/a&gt;プラグインが使用される場合の、ソースが配置されるデフォルトのパスです。次のブロックを使用して、動的ライブラリまたは共有ライブラリを生成するようにプロジェクトを指示および構成します。</target>
        </trans-unit>
        <trans-unit id="a942f64f48ea1ece8880513eaa81ddefeb619b0a" translate="yes" xml:space="preserve">
          <source>Let's replace &lt;code&gt;testSolution()&lt;/code&gt; function content with the following:</source>
          <target state="translated">&lt;code&gt;testSolution()&lt;/code&gt; 関数の内容を次のように置き換えましょう。</target>
        </trans-unit>
        <trans-unit id="4a173594d073c26a036c43463ffde9097189a153" translate="yes" xml:space="preserve">
          <source>Let's run a lot of them</source>
          <target state="translated">たくさん走らせましょう</target>
        </trans-unit>
        <trans-unit id="4b01757c4af3890b2686d482b6ad16159167a6f9" translate="yes" xml:space="preserve">
          <source>Let's run the &lt;code&gt;linkNative&lt;/code&gt; Gradle task to build the library &lt;a href=&quot;basic-kotlin-native-app#run-in-ide&quot;&gt;in the IDE&lt;/a&gt; or by calling the following console command:</source>
          <target state="translated">&lt;code&gt;linkNative&lt;/code&gt; Gradleタスクを実行&lt;a href=&quot;basic-kotlin-native-app#run-in-ide&quot;&gt;して、IDEで&lt;/a&gt;ライブラリをビルドするか、次のコンソールコマンドを呼び出します。</target>
        </trans-unit>
        <trans-unit id="106249141867c6b57bd6484ccdc821cb560f7f5d" translate="yes" xml:space="preserve">
          <source>Let's run the &lt;code&gt;linkNative&lt;/code&gt; Gradle task to build the library &lt;a href=&quot;using-intellij-idea&quot;&gt;in the IDE&lt;/a&gt; or by calling the following console command:</source>
          <target state="translated">&lt;code&gt;linkNative&lt;/code&gt; Gradleタスクを実行&lt;a href=&quot;using-intellij-idea&quot;&gt;して、IDEで&lt;/a&gt;ライブラリをビルドするか、次のコンソールコマンドを呼び出します。</target>
        </trans-unit>
        <trans-unit id="0027507ed05fb5770a6709f41c759d4f8b675c55" translate="yes" xml:space="preserve">
          <source>Let's run the &lt;code&gt;linkNative&lt;/code&gt; Gradle task to build the library in the IDE or by calling the following console command:</source>
          <target state="translated">&lt;code&gt;linkNative&lt;/code&gt; Gradleタスクを実行して、IDEでライブラリをビルドするか、次のコンソールコマンドを呼び出します。</target>
        </trans-unit>
        <trans-unit id="ced335cd9fa401cb82913f0326e2577c06919225" translate="yes" xml:space="preserve">
          <source>Let's say that you're writing a simple ORM. Your database library represents a row as instances of a class &lt;code&gt;Entity&lt;/code&gt;, with functions like &lt;code&gt;getString(&quot;name&quot;)&lt;/code&gt; and &lt;code&gt;getLong(&quot;age&quot;)&lt;/code&gt; for getting typed values from the given columns. We could create a typed wrapper class like this:</source>
          <target state="translated">単純なORMを作成しているとしましょう。データベースライブラリは、行をクラス &lt;code&gt;Entity&lt;/code&gt; のインスタンスとして表し、指定された列から型付き値を取得するための &lt;code&gt;getString(&quot;name&quot;)&lt;/code&gt; や &lt;code&gt;getLong(&quot;age&quot;)&lt;/code&gt; などの関数を備えています。次のような型付きラッパークラスを作成できます。</target>
        </trans-unit>
        <trans-unit id="a18f6d560df8733728d2795ff272c64a409b9516" translate="yes" xml:space="preserve">
          <source>Let's say we need to return two things from a function. For example, a result object and a status of some sort. A compact way of doing this in Kotlin is to declare a &lt;a href=&quot;data-classes&quot;&gt;&lt;em&gt;data class&lt;/em&gt;&lt;/a&gt; and return its instance:</source>
          <target state="translated">関数から2つのものを返す必要があるとしましょう。たとえば、結果オブジェクトとある種のステータス。Kotlinでこれを行うコンパクトな方法は、&lt;a href=&quot;data-classes&quot;&gt;&lt;em&gt;データクラス&lt;/em&gt;&lt;/a&gt;を宣言してそのインスタンスを返すことです。</target>
        </trans-unit>
        <trans-unit id="8eba6223ee182cc016df2825ffe27a1806c3d5dd" translate="yes" xml:space="preserve">
          <source>Let's see how &lt;code&gt;class&lt;/code&gt; and &lt;code&gt;object&lt;/code&gt; are mapped to Objective-C and Swift. The generated &lt;code&gt;&amp;lt;Framework&amp;gt;/Headers/Demo.h&lt;/code&gt; file contains the exact definitions for &lt;code&gt;Class&lt;/code&gt;, &lt;code&gt;Interface&lt;/code&gt;, and &lt;code&gt;Object&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;class&lt;/code&gt; と &lt;code&gt;object&lt;/code&gt; がどのようにObjective-CとSwiftにマッピングされるか見てみましょう。生成された &lt;code&gt;&amp;lt;Framework&amp;gt;/Headers/Demo.h&lt;/code&gt; ファイルには、 &lt;code&gt;Class&lt;/code&gt; 、 &lt;code&gt;Interface&lt;/code&gt; 、および &lt;code&gt;Object&lt;/code&gt; の正確な定義が含まれています。</target>
        </trans-unit>
        <trans-unit id="2abb7f43d07915bd385a08f6f8eca1904f202535" translate="yes" xml:space="preserve">
          <source>Let's see now &lt;code&gt;CValue&amp;lt;T&amp;gt;&lt;/code&gt; is turned to a pointer first:</source>
          <target state="translated">&lt;code&gt;CValue&amp;lt;T&amp;gt;&lt;/code&gt; が最初にポインターになっているところを見てみましょう。</target>
        </trans-unit>
        <trans-unit id="0da8a1853bc3aa9296a82e748b06afcd60c8ff39" translate="yes" xml:space="preserve">
          <source>Let's summarize what we have in the table:</source>
          <target state="translated">表にあるものをまとめてみましょう。</target>
        </trans-unit>
        <trans-unit id="29489a663f002abc7aabbc10da61ddf3922c9137" translate="yes" xml:space="preserve">
          <source>Let's switch back to the Android Studio and execute the &lt;code&gt;build&lt;/code&gt; target of the &lt;code&gt;SharedCode&lt;/code&gt; project from the &lt;em&gt;Gradle&lt;/em&gt; tool window. The task looks for environment variables set by the Xcode build and copies the right variant of the framework into the &lt;code&gt;SharedCode/build/xcode-frameworks&lt;/code&gt; folder. We then include the framework from that folder into the build</source>
          <target state="translated">Android Studioに切り替えて、&lt;em&gt;Gradle&lt;/em&gt;ツールウィンドウから &lt;code&gt;SharedCode&lt;/code&gt; プロジェクトの &lt;code&gt;build&lt;/code&gt; ターゲットを実行します。タスクは、Xcodeビルドによって設定された環境変数を探し、フレームワークの適切なバリアントを &lt;code&gt;SharedCode/build/xcode-frameworks&lt;/code&gt; フォルダーにコピーします。次に、そのフォルダーのフレームワークをビルドに含めます&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="aa5c06386e1b74a742a7f7576c52eff2fd2031ee" translate="yes" xml:space="preserve">
          <source>Let's take a look at Kotlin runtime declarations first:</source>
          <target state="translated">まずはKotlinのランタイム宣言を見てみましょう。</target>
        </trans-unit>
        <trans-unit id="0d3a04db62b13c25688a0e50c618e3bec15eb02a" translate="yes" xml:space="preserve">
          <source>Let's take a look at a concrete example.</source>
          <target state="translated">具体的な例を見てみましょう。</target>
        </trans-unit>
        <trans-unit id="d83be9a947c4ef371bac95dfdb52ba3f51a09f86" translate="yes" xml:space="preserve">
          <source>Let's take a look at the &lt;code&gt;kotlin.root.example&lt;/code&gt; field, it mimics the package structure of our Kotlin code with a &lt;code&gt;kotlin.root.&lt;/code&gt; prefix.</source>
          <target state="translated">&lt;code&gt;kotlin.root.example&lt;/code&gt; フィールドを見てみましょう &lt;code&gt;kotlin.root.&lt;/code&gt; は、kotlin.rootを使用してKotlinコードのパッケージ構造を模倣しています。接頭辞。</target>
        </trans-unit>
        <trans-unit id="7a1c41eab269c88a145c3bcd2eacac0f706a1202" translate="yes" xml:space="preserve">
          <source>Let's take a look at the difference between &lt;code&gt;Iterable&lt;/code&gt; and &lt;code&gt;Sequence&lt;/code&gt; with an example.</source>
          <target state="translated">&lt;code&gt;Iterable&lt;/code&gt; と &lt;code&gt;Sequence&lt;/code&gt; の違いを例で見てみましょう。</target>
        </trans-unit>
        <trans-unit id="683ff410a92468b732cdb32c98685fb25b7caa78" translate="yes" xml:space="preserve">
          <source>Let's take a look at the generated functions that take our &lt;code&gt;MyStruct&lt;/code&gt; and &lt;code&gt;MyUnion&lt;/code&gt; as parameters. We see that by-value parameters are represented as &lt;code&gt;kotlinx.cinterop.CValue&amp;lt;T&amp;gt;&lt;/code&gt;. And for typed pointer parameters we see &lt;code&gt;kotlinx.cinterop.CValuesRef&amp;lt;T&amp;gt;&lt;/code&gt;. Kotlin provides us with an API to deal with both types easily, let's try it and see.</source>
          <target state="translated">&lt;code&gt;MyStruct&lt;/code&gt; と &lt;code&gt;MyUnion&lt;/code&gt; をパラメーターとして取る生成された関数を見てみましょう。値 &lt;code&gt;kotlinx.cinterop.CValue&amp;lt;T&amp;gt;&lt;/code&gt; パラメーターがkotlinx.cinterop.CValue &amp;lt;T&amp;gt;として表されていることがわかります。また、型付きポインターパラメーターの場合、 &lt;code&gt;kotlinx.cinterop.CValuesRef&amp;lt;T&amp;gt;&lt;/code&gt; 表示されます。Kotlinは、両方のタイプを簡単に処理するためのAPIを提供しています。試して見てみましょう。</target>
        </trans-unit>
        <trans-unit id="640f277dd088f13964789f8075c590d21d6b9dfc" translate="yes" xml:space="preserve">
          <source>Let's take pipelines to the extreme with an example that generates prime numbers using a pipeline of coroutines. We start with an infinite sequence of numbers.</source>
          <target state="translated">パイプラインを極端にして、コアーチンのパイプラインを使って素数を生成する例を挙げてみましょう。まず、無限の数列から始めます。</target>
        </trans-unit>
        <trans-unit id="3a85f4e1e0328af1a77f3960a6412ca2106e30f9" translate="yes" xml:space="preserve">
          <source>Let's try the same with coroutines:</source>
          <target state="translated">コルチンでも同じようにやってみましょう。</target>
        </trans-unit>
        <trans-unit id="7edcd7d839fe1e0dfdcd3a0fe161ec6c231e6fb0" translate="yes" xml:space="preserve">
          <source>Let's try to use the API from Kotlin. Let's call &lt;code&gt;pass_string&lt;/code&gt; first:</source>
          <target state="translated">KotlinのAPIを使ってみましょう。最初に &lt;code&gt;pass_string&lt;/code&gt; を呼び出しましょう：</target>
        </trans-unit>
        <trans-unit id="0627f0965e7ec33cbf1e065c2d05108d4f888350" translate="yes" xml:space="preserve">
          <source>Let's update the Gradle scripts now to implement that and configure our IDE.</source>
          <target state="translated">それでは、Gradleスクリプトを更新して実装し、IDEを設定してみましょう。</target>
        </trans-unit>
        <trans-unit id="cd1102ed7118f5a51e4a3d98942ad07717eaabd4" translate="yes" xml:space="preserve">
          <source>Let's use it with channel &lt;code&gt;a&lt;/code&gt; that produces &quot;Hello&quot; string four times and channel &lt;code&gt;b&lt;/code&gt; that produces &quot;World&quot; four times:</source>
          <target state="translated">チャネルで使用してみましょう &lt;code&gt;a&lt;/code&gt; 「こんにちは」の文字列の4倍とチャネル生成 &lt;code&gt;b&lt;/code&gt; 4回「世界」を生成します。</target>
        </trans-unit>
        <trans-unit id="9dbe6646e8e9a0c1dd5558c986bbdc08c0c317a1" translate="yes" xml:space="preserve">
          <source>Let's walk through the interfaces and their implementations.</source>
          <target state="translated">インターフェイスとその実装を見ていきましょう。</target>
        </trans-unit>
        <trans-unit id="83d65fd8bdf3a04f906b52d7b1ba67e299c6332e" translate="yes" xml:space="preserve">
          <source>Let's walk through the mechanisms of implementing type-safe builders in Kotlin. First of all, we need to define the model we want to build, in this case we need to model HTML tags. It is easily done with a bunch of classes. For example, &lt;code&gt;HTML&lt;/code&gt; is a class that describes the &lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt; tag, i.e. it defines children like &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt;. (See its declaration &lt;a href=&quot;#full-definition-of-the-comexamplehtml-package&quot;&gt;below&lt;/a&gt;.)</source>
          <target state="translated">Kotlinでタイプセーフなビルダーを実装するメカニズムについて見ていきましょう。まず、構築するモデルを定義する必要があります。この場合は、HTMLタグをモデル化する必要があります。たくさんのクラスで簡単にできます。たとえば、 &lt;code&gt;HTML&lt;/code&gt; は &lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt; タグを記述するクラスです。つまり、HTMLは &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; や &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt; などの子を定義します。 （&lt;a href=&quot;#full-definition-of-the-comexamplehtml-package&quot;&gt;以下の&lt;/a&gt;宣言を参照してください。）</target>
        </trans-unit>
        <trans-unit id="7c7f5d049fad2569721d446c4a811f9bd5da5393" translate="yes" xml:space="preserve">
          <source>Level</source>
          <target state="translated">Level</target>
        </trans-unit>
        <trans-unit id="72a321ab062693e53bbb407257b25f97ff6f7e3d" translate="yes" xml:space="preserve">
          <source>Leveraging native libs in the hierarchical structure</source>
          <target state="translated">階層構造でのネイティブライブラリの活用</target>
        </trans-unit>
        <trans-unit id="27c968e6692b41bf6e1a241b870dc41ff1a51b17" translate="yes" xml:space="preserve">
          <source>Libraries</source>
          <target state="translated">Libraries</target>
        </trans-unit>
        <trans-unit id="944db4e3c24472be792b2084d0de67b6c3f7f699" translate="yes" xml:space="preserve">
          <source>Libraries published with the hierarchical project structure are compatible with all kinds of projects, both with and without the hierarchical project structure. However, libraries published without the hierarchical project structure can&amp;rsquo;t be used in a shared native source set. So, for example, users with &lt;code&gt;ios()&lt;/code&gt; shortcuts in their &lt;code&gt;gradle.build&lt;/code&gt; files won&amp;rsquo;t be able to use your library in their iOS-shared code.</source>
          <target state="translated">階層プロジェクト構造で公開されたライブラリは、階層プロジェクト構造の有無にかかわらず、あらゆる種類のプロジェクトと互換性があります。ただし、階層プロジェクト構造なしで公開されたライブラリは、共有ネイティブソースセットでは使用できません。そのため、たとえば、 &lt;code&gt;gradle.build&lt;/code&gt; ファイルに &lt;code&gt;ios()&lt;/code&gt; ショートカットがあるユーザーは、iOS共有コードでライブラリを使用できなくなります。</target>
        </trans-unit>
        <trans-unit id="00f72e56b5ae78fda32dcd4978d25a113af870e2" translate="yes" xml:space="preserve">
          <source>Library authors can use the @Deprecated and &lt;a href=&quot;../opt-in-requirements&quot;&gt;@RequiresOptIn&lt;/a&gt; annotations to control the evolution of their API surface. Note that @Deprecated(level=HIDDEN) can be used to preserve binary compatibility even for declarations removed from the API.</source>
          <target state="translated">ライブラリの作成者は、@ Deprecatedおよび&lt;a href=&quot;../opt-in-requirements&quot;&gt;@RequiresOptIn&lt;/a&gt;アノテーションを使用して、APIサーフェスの進化を制御できます。@Deprecated（level = HIDDEN）を使用すると、APIから削除された宣言であっても、バイナリ互換性を維持できることに注意してください。</target>
        </trans-unit>
        <trans-unit id="74fbbbbc56ff7a0c7c22c830abedb5e3565e5058" translate="yes" xml:space="preserve">
          <source>Library authors can use the @Deprecated and @Experimental annotations to control the evolution of their API surface. Note that @Deprecated(level=HIDDEN) can be used to preserve binary compatibility even for declarations removed from the API.</source>
          <target state="translated">ライブラリの作者は、@Deprecatedアノテーションと@Experimentalアノテーションを使用して、API表面の進化を制御することができます。Deprecated(level=HIDDEN)は、APIから削除された宣言に対してもバイナリ互換性を維持するために使用できることに注意してください。</target>
        </trans-unit>
        <trans-unit id="0405ca8057bdd26aa8a71ed5b78eaef11cd20a80" translate="yes" xml:space="preserve">
          <source>Library code should always specify return types of public/protected functions and properties explicitly thus never relying on type inference for public API. Subtle changes in type inference may cause return types to change inadvertently, leading to binary compatibility issues.</source>
          <target state="translated">ライブラリコードでは、公開/保護された関数やプロパティの戻り値の型を常に明示的に指定しなければなりませんので、公開APIの型推論には決して依存しません。型推論の微妙な変更は、うっかりリターン型を変更してしまい、バイナリ互換性の問題につながる可能性があります。</target>
        </trans-unit>
        <trans-unit id="c7267839499feac3cd8daacca298c9e65946505b" translate="yes" xml:space="preserve">
          <source>Library search path. For more information, see &lt;a href=&quot;native/libraries#library-search-sequence&quot;&gt;Library search sequence&lt;/a&gt;.</source>
          <target state="translated">ライブラリ検索パス。詳細については、&lt;a href=&quot;native/libraries#library-search-sequence&quot;&gt;ライブラリの検索シーケンスを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="2fc01b5cc1b2ec00feddd7cb533ccfb023b55321" translate="yes" xml:space="preserve">
          <source>Library search sequence</source>
          <target state="translated">ライブラリ検索シーケンス</target>
        </trans-unit>
        <trans-unit id="141acdd651d31f900ce141517e6e5b768c6f9865" translate="yes" xml:space="preserve">
          <source>Library support for the Kotlin annotation facility.</source>
          <target state="translated">Kotlin注釈機能のライブラリサポート。</target>
        </trans-unit>
        <trans-unit id="ec793eb7fd1d6c9106d97e622f4fcbf89e666960" translate="yes" xml:space="preserve">
          <source>Licensed under the Apache License, Version 2.0.</source>
          <target state="translated">Apache License,Version 2.0の下でライセンスされています。</target>
        </trans-unit>
        <trans-unit id="8ca0dc8586d3cb640a4422d4f36e3b18f79a2fc2" translate="yes" xml:space="preserve">
          <source>Like Java's, Kotlin's generics are not retained at runtime, i.e. objects do not carry information about actual type arguments passed to their constructors, i.e. &lt;code&gt;ArrayList&amp;lt;Integer&amp;gt;()&lt;/code&gt; is indistinguishable from &lt;code&gt;ArrayList&amp;lt;Character&amp;gt;()&lt;/code&gt;. This makes it impossible to perform &lt;em&gt;is&lt;/em&gt;-checks that take generics into account. Kotlin only allows &lt;em&gt;is&lt;/em&gt;-checks for star-projected generic types:</source>
          <target state="translated">Javaと同様に、Kotlinのジェネリックは実行時に保持されません。つまり、オブジェクトはコンストラクターに渡される実際の型引数に関する情報を保持しません。つまり、 &lt;code&gt;ArrayList&amp;lt;Integer&amp;gt;()&lt;/code&gt; は &lt;code&gt;ArrayList&amp;lt;Character&amp;gt;()&lt;/code&gt; と区別できません。これにより、ジェネリックを考慮した&lt;em&gt;is&lt;/em&gt;チェックを実行できなくなります。Kotlin &lt;em&gt;は&lt;/em&gt;、スター投影されたジェネリック型の&lt;em&gt;is&lt;/em&gt; -checks のみを許可します。</target>
        </trans-unit>
        <trans-unit id="d1e9786250417dc0913291ad74e3ec7573630368" translate="yes" xml:space="preserve">
          <source>Like any other Gradle projects, Kotlin/JS projects support traditional Gradle &lt;a href=&quot;https://docs.gradle.org/current/userguide/declaring_dependencies.html&quot;&gt;dependency declarations&lt;/a&gt; in the &lt;code&gt;dependencies&lt;/code&gt; section of the build script.</source>
          <target state="translated">他のGradleのプロジェクトと同様に、Kotlin / JSプロジェクトは、伝統的なGradleのサポート&lt;a href=&quot;https://docs.gradle.org/current/userguide/declaring_dependencies.html&quot;&gt;依存性宣言を&lt;/a&gt;して &lt;code&gt;dependencies&lt;/code&gt; ビルドスクリプトのセクション。</target>
        </trans-unit>
        <trans-unit id="134fca0c09908f36860692b90dc834d35d2666e9" translate="yes" xml:space="preserve">
          <source>Like in Python, functions in Kotlin are first-class values - they can be assigned to variables and passed around as parameters. The type a function is a &lt;em&gt;function type&lt;/em&gt;, which is indicated with a parenthesized parameter type list and an arrow to the return type. Consider this function:</source>
          <target state="translated">Pythonと同様に、Kotlinの関数は一流の値です。これらは変数に割り当てられ、パラメーターとして渡されます。&lt;em&gt;関数の型&lt;/em&gt;は&lt;em&gt;関数の型&lt;/em&gt;であり、括弧で囲まれたパラメーターの型リストと戻り値の型への矢印で示されます。この関数を考えてみましょう：</target>
        </trans-unit>
        <trans-unit id="4ddd56354c9749dcb1f4e69de6ab93bcbbe060ca" translate="yes" xml:space="preserve">
          <source>Like in Python, statements may be terminated by a semicolon, but it's discouraged. There is no line continuation character; instead, a line is automatically joined with one or more of the subsequent lines if that's the only way to make the code parse correctly. In practice, that means that a statement continues on the next line if we're inside an open parenthesis (like in Python), or if the line ends with a &quot;dangling operator&quot; (unlike in Python) or the following line doesn't parse unless it's joined to the previous one (also unlike in Python). Note that this is pretty much &lt;a href=&quot;https://stackoverflow.com/questions/2846283/what-are-the-rules-for-javascripts-automatic-semicolon-insertion-asi#2846298&quot;&gt;the opposite of JavaScript&lt;/a&gt;, which generally will keep joining lines as long as the resulting code still parses. Thus, the following is two expressions in Kotlin and in Python (because &lt;code&gt;+&lt;/code&gt; can be unary, so the second line parses on its own), but one in JavaScript:</source>
          <target state="translated">Pythonと同様に、ステートメントはセミコロンで終了する場合がありますが、お勧めしません。行継続文字はありません。代わりに、コードを正しく解析する唯一の方法である場合、行は後続の1つ以上の行と自動的に結合されます。実際には、それは、（Pythonのように）左括弧の中にいる場合、または行が「ダングリングオペレーター」で終わる場合（Pythonの場合とは異なります）、または次の行が次の行にない場合、次の行に続くことを意味します。前のものに結合されていない限り解析します（これもPythonとは異なります）。これは&lt;a href=&quot;https://stackoverflow.com/questions/2846283/what-are-the-rules-for-javascripts-automatic-semicolon-insertion-asi#2846298&quot;&gt;JavaScriptの反対で&lt;/a&gt;あることに注意してください。JavaScriptは通常、結果のコードが解析される限り、行を結合し続けます。したがって、次はKotlinとPythonの2つの式です（ &lt;code&gt;+&lt;/code&gt; 単項の場合もあるため、2行目はそれ自体で解析されますが、JavaScriptでは1行です。</target>
        </trans-unit>
        <trans-unit id="36d262d6365f0d350e9446c742577b066fb40895" translate="yes" xml:space="preserve">
          <source>Like in Python, you can write &lt;em&gt;lambda expressions&lt;/em&gt;: unnamed function declarations with a very compact syntax, which evaluate to callable function objects. In Kotlin, lambdas can contain multiple statements, which make them useful for &lt;a href=&quot;functional-programming#receivers&quot;&gt;more complex tasks&lt;/a&gt; than the single-expression lambdas of Python. The last statement must be an expression, whose result will become the return value of the lambda (unless &lt;code&gt;Unit&lt;/code&gt; is the return type of the variable/parameter that the lambda expression is assigned to, in which case the lambda has no return value). A lambda expression is enclosed in curly braces, and begins by listing its parameter names and possibly their types (unless the types can be inferred from context):</source>
          <target state="translated">Pythonの場合と同様に、&lt;em&gt;ラムダ式&lt;/em&gt;を記述できます。非常にコンパクトな構文を使用した名前のない関数宣言であり、呼び出し可能な関数オブジェクトとして評価されます。Kotlinでは、ラムダに複数のステートメントを含めることができるため、Pythonの単一式ラムダよりも&lt;a href=&quot;functional-programming#receivers&quot;&gt;複雑なタスクに&lt;/a&gt;役立ちます。最後のステートメントは式である必要があり、その結果はラムダの戻り値になります（ただし、 &lt;code&gt;Unit&lt;/code&gt; がラムダ式が割り当てられている変数/パラメーターの戻り値の型である場合を除きます。この場合、ラムダには戻り値がありません）。ラムダ式は中括弧で囲まれ、パラメーター名と、場合によってはそれらのタイプをリストすることから始まります（コンテキストからタイプを推測できない場合）。</target>
        </trans-unit>
        <trans-unit id="4ee83e74db24116986fa00ee2921b9703634e255" translate="yes" xml:space="preserve">
          <source>Like numbers, characters are boxed when a nullable reference is needed. Identity is not preserved by the boxing operation.</source>
          <target state="translated">数字と同様に、文字はヌル可能な参照が必要な場合に箱詰めされます。箱詰めの操作では同一性は保持されません。</target>
        </trans-unit>
        <trans-unit id="dc3b674f534270e494afa035103eb57b636704df" translate="yes" xml:space="preserve">
          <source>Likewise, if a multiplatform library is published in the experimental &lt;a href=&quot;#experimental-metadata-publishing-mode&quot;&gt;Gradle metadata publishing mode&lt;/a&gt; and the project is set up to consume the metadata as well, then it is enough to specify a dependency only once, for the common source set. Otherwise, each platform-specific source set should be provided with a corresponding platform module of the library, in addition to the common module, as shown above.</source>
          <target state="translated">同様に、マルチプラットフォームライブラリが試験的な&lt;a href=&quot;#experimental-metadata-publishing-mode&quot;&gt;Gradleメタデータ公開モードで&lt;/a&gt;公開され、プロジェクトがメタデータも使用するように設定されている場合、共通のソースセットに対して依存関係を1回だけ指定するだけで十分です。それ以外の場合は、上記のように、各プラットフォーム固有のソースセットに、共通モジュールに加えて、ライブラリの対応するプラットフォームモジュールを提供する必要があります。</target>
        </trans-unit>
        <trans-unit id="a7c04c64ed3f2a9374590c76c50d3b7f1b18e3da" translate="yes" xml:space="preserve">
          <source>Limitations</source>
          <target state="translated">Limitations</target>
        </trans-unit>
        <trans-unit id="f8233d6f380a149df94d518228f2e14afd396052" translate="yes" xml:space="preserve">
          <source>Linear search</source>
          <target state="translated">線形検索</target>
        </trans-unit>
        <trans-unit id="b867f8dc43342a216856620ba5a0d8c96b534757" translate="yes" xml:space="preserve">
          <source>Link the library into the application</source>
          <target state="translated">ライブラリをアプリケーションにリンクする</target>
        </trans-unit>
        <trans-unit id="51115a9035c7b2d5f77a89ba3f71882db009bed6" translate="yes" xml:space="preserve">
          <source>Link with the library. To learn about using libraries in Kotlin/native projects, see &lt;a href=&quot;native/libraries&quot;&gt;Kotlin/Native libraries&lt;/a&gt;.</source>
          <target state="translated">ライブラリとリンクします。Kotlin / nativeプロジェクトでのライブラリの使用については、&lt;a href=&quot;native/libraries&quot;&gt;Kotlin / Nativeライブラリを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="0084b300581a4369f50268c2c401f96431ea7f31" translate="yes" xml:space="preserve">
          <source>LinkStyle</source>
          <target state="translated">LinkStyle</target>
        </trans-unit>
        <trans-unit id="07410b317023eeb58eba0c065fa4e8416575a68f" translate="yes" xml:space="preserve">
          <source>LinkedHashMap</source>
          <target state="translated">LinkedHashMap</target>
        </trans-unit>
        <trans-unit id="9e6a957a7c69081b233af13d7e01702499988584" translate="yes" xml:space="preserve">
          <source>LinkedHashSet</source>
          <target state="translated">LinkedHashSet</target>
        </trans-unit>
        <trans-unit id="778915b1ca69b860077b72be4fd2810162ac2e59" translate="yes" xml:space="preserve">
          <source>Linking to Elements</source>
          <target state="translated">要素へのリンク</target>
        </trans-unit>
        <trans-unit id="83ad8510bbd3f22363d068e1c96f82fd0fcccd31" translate="yes" xml:space="preserve">
          <source>Linux</source>
          <target state="translated">Linux</target>
        </trans-unit>
        <trans-unit id="ff0484f6287dafcb08eb0a886ac73a7153824af7" translate="yes" xml:space="preserve">
          <source>Linux (x86_64, arm32, MIPS, MIPS little endian, Raspberry Pi)</source>
          <target state="translated">Linux (x86_64,arm32,MIPS,MIPSリトルエンディアン,Raspberry Pi)</target>
        </trans-unit>
        <trans-unit id="c8306ed1ec95ef01523eab6c3a95dbeb9f6511fb" translate="yes" xml:space="preserve">
          <source>Linux (x86_64, arm32, arm64, MIPS, MIPS little endian)</source>
          <target state="translated">Linux (x86_64,arm32,arm64,MIPS,MIPSリトルエンディアン)</target>
        </trans-unit>
        <trans-unit id="967dea98ac299ce02d355a430918fd09ccd9ae77" translate="yes" xml:space="preserve">
          <source>Linux MIPS targets (&lt;code&gt;linuxMips32&lt;/code&gt; and &lt;code&gt;linuxMipsel32&lt;/code&gt;) require a Linux host.</source>
          <target state="translated">Linux MIPSターゲット（ &lt;code&gt;linuxMips32&lt;/code&gt; および &lt;code&gt;linuxMipsel32&lt;/code&gt; ）には、Linuxホストが必要です。</target>
        </trans-unit>
        <trans-unit id="430e92ad771f5c7d80b45e64d2d47aa39cd97e1b" translate="yes" xml:space="preserve">
          <source>Linux MIPS targets (&lt;code&gt;linuxMips32&lt;/code&gt; and &lt;code&gt;linuxMipsel32&lt;/code&gt;) require a Linux host. Other Linux targets can be built on any supported host;</source>
          <target state="translated">Linux MIPSターゲット（ &lt;code&gt;linuxMips32&lt;/code&gt; および &lt;code&gt;linuxMipsel32&lt;/code&gt; ）にはLinuxホストが必要です。その他のLinuxターゲットは、サポートされている任意のホスト上に構築できます。</target>
        </trans-unit>
        <trans-unit id="11304ba6aa97ab18544ed05fda48e987cfe71d39" translate="yes" xml:space="preserve">
          <source>Linux on ARM64 platforms, for example, Raspberry Pi</source>
          <target state="translated">ARM64 プラットフォーム上の Linux、例えば Raspberry Pi</target>
        </trans-unit>
        <trans-unit id="013bd415b99b4bdfce6cddaafa69bba3220fa741" translate="yes" xml:space="preserve">
          <source>Linux on MIPS platforms</source>
          <target state="translated">MIPS プラットフォーム上の Linux</target>
        </trans-unit>
        <trans-unit id="94ff9f10883bcb28fb147e475a8a0df8cd56c6a9" translate="yes" xml:space="preserve">
          <source>Linux on hard-float ARM (ARM32) platforms</source>
          <target state="translated">ハードフロート ARM (ARM32)プラットフォーム上の Linux</target>
        </trans-unit>
        <trans-unit id="0c99b7625097db16217dc289034a1cae4cfdd98e" translate="yes" xml:space="preserve">
          <source>Linux on little-endian MIPS (mipsel) platforms</source>
          <target state="translated">リトルエンディアン MIPS (mipsel)プラットフォーム上の Linux</target>
        </trans-unit>
        <trans-unit id="d6493240830afc488468d930ec91963f82322598" translate="yes" xml:space="preserve">
          <source>Linux on x86_64 platforms</source>
          <target state="translated">x86_64プラットフォーム上のLinux</target>
        </trans-unit>
        <trans-unit id="bfb299cccd6e6b52b05aad6a92f9e230c0c907cf" translate="yes" xml:space="preserve">
          <source>Linux: &lt;code&gt;libnative_api.h&lt;/code&gt; and &lt;code&gt;libnative.so&lt;/code&gt;</source>
          <target state="translated">Linux： &lt;code&gt;libnative_api.h&lt;/code&gt; および &lt;code&gt;libnative.so&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a1fffaaafb7cc996685bceb829c053cc4f7de43d" translate="yes" xml:space="preserve">
          <source>List</source>
          <target state="translated">List</target>
        </trans-unit>
        <trans-unit id="1cf922153258f477bc71540c57fe2b01a501cd22" translate="yes" xml:space="preserve">
          <source>List Specific Operations</source>
          <target state="translated">特定の操作をリストアップ</target>
        </trans-unit>
        <trans-unit id="a159771f6ea4355d13f8450d01c0373e1562c782" translate="yes" xml:space="preserve">
          <source>List elements (including nulls) can duplicate: a list can contain any number of equal objects or occurrences of a single object. Two lists are considered equal if they have the same sizes and &lt;a href=&quot;equality#structural-equality&quot;&gt;structurally equal&lt;/a&gt; elements at the same positions.</source>
          <target state="translated">リスト要素（nullを含む）は複製できます。リストには、任意の数の等しいオブジェクトまたは単一のオブジェクトのオカレンスを含めることができます。 2つのリストは、同じサイズで同じ位置に&lt;a href=&quot;equality#structural-equality&quot;&gt;構造的に等しい&lt;/a&gt;要素がある場合、等しいと見なされます。</target>
        </trans-unit>
        <trans-unit id="06c25d6b7dd57683933b41c5deaf09d2d0ac5990" translate="yes" xml:space="preserve">
          <source>List iterators</source>
          <target state="translated">リストイテレータ</target>
        </trans-unit>
        <trans-unit id="b7bfa71d045baf9d165ce17f80e019c5294d5073" translate="yes" xml:space="preserve">
          <source>List the available hardware targets.</source>
          <target state="translated">利用可能なハードウェアターゲットをリストアップします。</target>
        </trans-unit>
        <trans-unit id="18c411381841a95d683318d92c209a2833825015" translate="yes" xml:space="preserve">
          <source>List write operations</source>
          <target state="translated">リスト書き込み操作</target>
        </trans-unit>
        <trans-unit id="7c5f57edf1aaa5196cbc6ba79770c80aef15f3e5" translate="yes" xml:space="preserve">
          <source>List.listIterator</source>
          <target state="translated">List.listIterator</target>
        </trans-unit>
        <trans-unit id="48fb7de1e7f4ec62a77ab4aa73ec82916ebe8c3e" translate="yes" xml:space="preserve">
          <source>ListIterator</source>
          <target state="translated">ListIterator</target>
        </trans-unit>
        <trans-unit id="a204aa282b7f9617db30e92246b8efaf427d19cd" translate="yes" xml:space="preserve">
          <source>Lists also offer a function to replace an element at a given position - &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-mutable-list/set&quot;&gt;&lt;code&gt;set()&lt;/code&gt;&lt;/a&gt; and its operator form &lt;code&gt;[]&lt;/code&gt;. &lt;code&gt;set()&lt;/code&gt; doesn't change the indexes of other elements.</source>
          <target state="translated">リストは、指定された位置にある要素を置き換える関数も提供します-set &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-mutable-list/set&quot;&gt; &lt;code&gt;set()&lt;/code&gt; &lt;/a&gt;とその演算子形式 &lt;code&gt;[]&lt;/code&gt; 。 &lt;code&gt;set()&lt;/code&gt; は他の要素のインデックスを変更しません。</target>
        </trans-unit>
        <trans-unit id="d5a0dae9f70ca77cfff82765784d806c80043676" translate="yes" xml:space="preserve">
          <source>Lists and maps also provide operations for updating elements. They are described in &lt;a href=&quot;list-operations&quot;&gt;List Specific Operations&lt;/a&gt; and &lt;a href=&quot;map-operations&quot;&gt;Map Specific Operations&lt;/a&gt;. For sets, updating doesn't make sense since it's actually removing an element and adding another one.</source>
          <target state="translated">リストとマップは、要素を更新するための操作も提供します。これらについては、&lt;a href=&quot;list-operations&quot;&gt;リスト固有の操作&lt;/a&gt;と&lt;a href=&quot;map-operations&quot;&gt;マップ固有の操作で説明してい&lt;/a&gt;ます。セットの場合、更新は実際には要素を削除して別の要素を追加するため、意味がありません。</target>
        </trans-unit>
        <trans-unit id="290d0482de491a9f1d45c4e717b747b40f336dfe" translate="yes" xml:space="preserve">
          <source>Lists and sets also provide operations for updating elements. They are described in &lt;a href=&quot;list-operations&quot;&gt;List Specific Operations&lt;/a&gt; and &lt;a href=&quot;map-operations&quot;&gt;Map Specific Operations&lt;/a&gt;. For sets, updating doesn't make sense since it's actually removing an element and adding another one.</source>
          <target state="translated">リストとセットは、要素を更新するための操作も提供します。これらについては、&lt;a href=&quot;list-operations&quot;&gt;リスト固有の操作&lt;/a&gt;と&lt;a href=&quot;map-operations&quot;&gt;マップ固有の操作で説明してい&lt;/a&gt;ます。セットの場合、実際には要素を削除して別の要素を追加するため、更新しても意味がありません。</target>
        </trans-unit>
        <trans-unit id="f70b0e65f09114560be2730b53b6dbbae2e2bd80" translate="yes" xml:space="preserve">
          <source>Lists support all common operations for element retrieval: &lt;code&gt;elementAt()&lt;/code&gt;, &lt;code&gt;first()&lt;/code&gt;, &lt;code&gt;last()&lt;/code&gt;, and others listed in &lt;a href=&quot;collection-elements&quot;&gt;Retrieving Single Elements&lt;/a&gt;. What is specific for lists is index access to the elements, so the simplest way to read an element is retrieving it by index. That is done with the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-list/get&quot;&gt;&lt;code&gt;get()&lt;/code&gt;&lt;/a&gt; function with the index passed in the argument or the shorthand &lt;code&gt;[index]&lt;/code&gt; syntax.</source>
          <target state="translated">リストは、要素取得のすべての一般的な操作をサポートします &lt;code&gt;elementAt()&lt;/code&gt; 、 &lt;code&gt;first()&lt;/code&gt; 、 &lt;code&gt;last()&lt;/code&gt; 、および&lt;a href=&quot;collection-elements&quot;&gt;単一要素の取得に&lt;/a&gt;リストされているその他の操作です。リストに固有なのは、要素へのインデックスアクセスであるため、要素を読み取る最も簡単な方法は、要素をインデックスで取得することです。これは、引数で渡されたインデックスを使用した&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-list/get&quot;&gt; &lt;code&gt;get()&lt;/code&gt; &lt;/a&gt;関数または短縮形の &lt;code&gt;[index]&lt;/code&gt; 構文で行われます。</target>
        </trans-unit>
        <trans-unit id="1b8cc7b0ac11bf88cf97ed5fc81444ae44893988" translate="yes" xml:space="preserve">
          <source>Literal Constants</source>
          <target state="translated">リテラル定数</target>
        </trans-unit>
        <trans-unit id="4da0019bff16f0b757af8c7d691632f05ab7ce73" translate="yes" xml:space="preserve">
          <source>Literal constants</source>
          <target state="translated">リテラル定数</target>
        </trans-unit>
        <trans-unit id="c7ba7dcf662374aafe652b03d75cb8f6024519d9" translate="yes" xml:space="preserve">
          <source>Literals</source>
          <target state="translated">Literals</target>
        </trans-unit>
        <trans-unit id="a354c605a19a501459267f5d2d15e3813a2622ea" translate="yes" xml:space="preserve">
          <source>Local Delegated Properties (since 1.1)</source>
          <target state="translated">ローカル委任プロパティ (1.1 以降)</target>
        </trans-unit>
        <trans-unit id="f5689c7ad8ad393161f3aa4e09dcfcbe8dae0b7c" translate="yes" xml:space="preserve">
          <source>Local Functions</source>
          <target state="translated">ローカル機能</target>
        </trans-unit>
        <trans-unit id="d7250510c8081d4daaa6df727eb914db9c33da3c" translate="yes" xml:space="preserve">
          <source>Local annotation classes</source>
          <target state="translated">ローカルアノテーションクラス</target>
        </trans-unit>
        <trans-unit id="69ebd822a58983be422bb598dba3c478ccd777d9" translate="yes" xml:space="preserve">
          <source>Local declarations</source>
          <target state="translated">ローカル宣言</target>
        </trans-unit>
        <trans-unit id="a1899e5981d8e839cbbac5a4b6b87631ee259818" translate="yes" xml:space="preserve">
          <source>Local delegated properties</source>
          <target state="translated">ローカルデリゲートされたプロパティ</target>
        </trans-unit>
        <trans-unit id="bcdcbb7562bc0be9df365ffa539169787154eb55" translate="yes" xml:space="preserve">
          <source>Local function can access local variables of outer functions (i.e. the closure), so in the case above, the &lt;em&gt;visited&lt;/em&gt; can be a local variable:</source>
          <target state="translated">ローカル関数は外部関数のローカル変数（つまり、クロージャ）にアクセスできるため、上記の場合、&lt;em&gt;visited&lt;/em&gt;はローカル変数になる可能性があります。</target>
        </trans-unit>
        <trans-unit id="c81d1a5213298e456992ce397aa51ab435e7f9b2" translate="yes" xml:space="preserve">
          <source>Local functions</source>
          <target state="translated">ローカル機能</target>
        </trans-unit>
        <trans-unit id="7a8cbb48d88b807f7bfba9d309d29524b5f02383" translate="yes" xml:space="preserve">
          <source>Local variable</source>
          <target state="translated">ローカル変数</target>
        </trans-unit>
        <trans-unit id="e41667e2ac3ba5cde0fdffb1b6bacda9d66718d9" translate="yes" xml:space="preserve">
          <source>Local variables are typically declared and initialized at the same time, in which case the type of the variable is &lt;em&gt;inferred&lt;/em&gt; to be the type of the expression you initialize it with:</source>
          <target state="translated">ローカル変数は通常、同時に宣言および初期化されます。この場合、変数のタイプは、変数を使用して初期化した式のタイプであると&lt;em&gt;推定さ&lt;/em&gt;れます。</target>
        </trans-unit>
        <trans-unit id="ac8a58b4422a8352e1dd6a3c1ee5296717d9a865" translate="yes" xml:space="preserve">
          <source>Local variables, functions and classes can not have visibility modifiers.</source>
          <target state="translated">ローカル変数、関数、クラスは可視性修飾子を持つことができません。</target>
        </trans-unit>
        <trans-unit id="a78aea5b0abb85e3e611fbf1ec8a29dd64f3f7a3" translate="yes" xml:space="preserve">
          <source>LocaleOptions</source>
          <target state="translated">LocaleOptions</target>
        </trans-unit>
        <trans-unit id="d219c68101f532de10add2cf42fb9dbeca73d3be" translate="yes" xml:space="preserve">
          <source>Location</source>
          <target state="translated">Location</target>
        </trans-unit>
        <trans-unit id="d42ac4c4f265835ce678f6a048de877eecd3678f" translate="yes" xml:space="preserve">
          <source>Location of Kotlin source files inside the source set directory.</source>
          <target state="translated">ソースセットディレクトリ内のKotlinソースファイルの場所。</target>
        </trans-unit>
        <trans-unit id="178313af6182f9b545c1f11580b0d5590fb118f3" translate="yes" xml:space="preserve">
          <source>Location of resources inside the source set directory.</source>
          <target state="translated">ソースセットディレクトリ内のリソースの位置。</target>
        </trans-unit>
        <trans-unit id="4a56ee9bffd6aa6b4bd69f9a8fcf34ef4736447e" translate="yes" xml:space="preserve">
          <source>Locks are used to ensure that only a single thread can initialize the &lt;a href=&quot;../-lazy/index&quot;&gt;Lazy&lt;/a&gt; instance.</source>
          <target state="translated">ロックは、単一のスレッドのみが&lt;a href=&quot;../-lazy/index&quot;&gt;Lazy&lt;/a&gt;インスタンスを初期化できるようにするために使用されます。</target>
        </trans-unit>
        <trans-unit id="0003a9c1d32ac7d8fddd983e062e51e3d0daa934" translate="yes" xml:space="preserve">
          <source>Logarithms: &lt;code&gt;log&lt;/code&gt;, &lt;code&gt;log2&lt;/code&gt;, &lt;code&gt;log10&lt;/code&gt;, &lt;code&gt;ln&lt;/code&gt;, &lt;code&gt;ln1p&lt;/code&gt;;</source>
          <target state="translated">対数： &lt;code&gt;log&lt;/code&gt; 、 &lt;code&gt;log2&lt;/code&gt; 、 &lt;code&gt;log10&lt;/code&gt; の、 &lt;code&gt;ln&lt;/code&gt; 、 &lt;code&gt;ln1p&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3496a775372b202cf19086b7723a8ba07a1c1c15" translate="yes" xml:space="preserve">
          <source>Logos can be downloaded &lt;a href=&quot;https://resources.jetbrains.com/storage/products/kotlin/docs/kotlin_logos.zip&quot;&gt;here&lt;/a&gt;. When using the logos, please follow simple rules in the &lt;code&gt;guidelines.pdf&lt;/code&gt; inside the archive and &lt;a href=&quot;https://kotlinlang.org/foundation/guidelines.html&quot;&gt;Kotlin brand usage guidelines&lt;/a&gt;.</source>
          <target state="translated">ロゴは&lt;a href=&quot;https://resources.jetbrains.com/storage/products/kotlin/docs/kotlin_logos.zip&quot;&gt;ここから&lt;/a&gt;ダウンロードできます。ロゴを使用する場合は、アーカイブ内の &lt;code&gt;guidelines.pdf&lt;/code&gt; の簡単なルールと&lt;a href=&quot;https://kotlinlang.org/foundation/guidelines.html&quot;&gt;Kotlinブランドの使用ガイドラインに&lt;/a&gt;従ってください。</target>
        </trans-unit>
        <trans-unit id="3171584f38872fa4d8f17811d91544f7756eaffd" translate="yes" xml:space="preserve">
          <source>Lombok (&lt;code&gt;lombok.NonNull&lt;/code&gt;).</source>
          <target state="translated">ロンボク（ &lt;code&gt;lombok.NonNull&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="11eda67f9b15a760342f8e98a3fc78d8d3ea9945" translate="yes" xml:space="preserve">
          <source>Long</source>
          <target state="translated">Long</target>
        </trans-unit>
        <trans-unit id="28da0e058738129fbcd7e6f45b76bc71f8a53660" translate="yes" xml:space="preserve">
          <source>LongArray</source>
          <target state="translated">LongArray</target>
        </trans-unit>
        <trans-unit id="4fccaadf63b5fc52428c158f51d57e23e947d24e" translate="yes" xml:space="preserve">
          <source>LongIterator</source>
          <target state="translated">LongIterator</target>
        </trans-unit>
        <trans-unit id="5845d554e07454310db9770fb728d9756ce6dae1" translate="yes" xml:space="preserve">
          <source>LongProgression</source>
          <target state="translated">LongProgression</target>
        </trans-unit>
        <trans-unit id="4fb8ec4ef48e7913a58002b0e63b73c29bff9f39" translate="yes" xml:space="preserve">
          <source>LongRange</source>
          <target state="translated">LongRange</target>
        </trans-unit>
        <trans-unit id="0b1c8c87dc520b4e01071e91d1f6a9ceb7e0e408" translate="yes" xml:space="preserve">
          <source>LongVar</source>
          <target state="translated">LongVar</target>
        </trans-unit>
        <trans-unit id="181cf892b1895d898b9744877c740407129f49dc" translate="yes" xml:space="preserve">
          <source>LongVarOf</source>
          <target state="translated">LongVarOf</target>
        </trans-unit>
        <trans-unit id="fd6299f672ee9cc3b8def57411eb0d0d9a44147d" translate="yes" xml:space="preserve">
          <source>Longs are tagged by a capital &lt;code&gt;L&lt;/code&gt;: &lt;code&gt;123L&lt;/code&gt;</source>
          <target state="translated">ロングは大文字の &lt;code&gt;L&lt;/code&gt; でタグ付けされています： &lt;code&gt;123L&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3e38e907fc0523189431e466a50de278a09267fc" translate="yes" xml:space="preserve">
          <source>Looking for more APIs? It is easy to create a &lt;a href=&quot;../multiplatform-library&quot;&gt;multiplatform library&lt;/a&gt; and share it!</source>
          <target state="translated">他のAPIをお探しですか？&lt;a href=&quot;../multiplatform-library&quot;&gt;マルチプラットフォームライブラリ&lt;/a&gt;を作成して共有するのは簡単です。</target>
        </trans-unit>
        <trans-unit id="0c661eae6b65f74e27c40369060777e2f1a666bd" translate="yes" xml:space="preserve">
          <source>Looks up a function &lt;code&gt;inc()&lt;/code&gt; with the &lt;code&gt;operator&lt;/code&gt; modifier and no parameters, applicable to the receiver of type &lt;code&gt;T&lt;/code&gt;;</source>
          <target state="translated">タイプ &lt;code&gt;T&lt;/code&gt; のレシーバーに適用可能な、 &lt;code&gt;operator&lt;/code&gt; 修飾子を使用してパラメーターを指定せずに関数 &lt;code&gt;inc()&lt;/code&gt; を検索します。</target>
        </trans-unit>
        <trans-unit id="06f3cb08bca38254cb72407f33d24848ac5110e5" translate="yes" xml:space="preserve">
          <source>Looks up a function &lt;code&gt;unaryPlus()&lt;/code&gt; with the &lt;code&gt;operator&lt;/code&gt; modifier and no parameters for the receiver &lt;code&gt;T&lt;/code&gt;, i.e. a member function or an extension function;</source>
          <target state="translated">&lt;code&gt;operator&lt;/code&gt; 修飾子があり、レシーバー &lt;code&gt;T&lt;/code&gt; のパラメーターがない関数 &lt;code&gt;unaryPlus()&lt;/code&gt; を検索します（メンバー関数または拡張関数など）。</target>
        </trans-unit>
        <trans-unit id="02720f9d38bf4f35e84ed5228689898bee176418" translate="yes" xml:space="preserve">
          <source>Loops</source>
          <target state="translated">Loops</target>
        </trans-unit>
        <trans-unit id="4c2bd8b7625ef46e049dcc97f3e97069511fe26a" translate="yes" xml:space="preserve">
          <source>Loops on ranges</source>
          <target state="translated">レンジのループ</target>
        </trans-unit>
        <trans-unit id="60369ad7d8b48a14f3d191172cf41bcfb71741f2" translate="yes" xml:space="preserve">
          <source>Low-level building blocks for libraries that provide coroutine-based APIs.</source>
          <target state="translated">コアラインベースのAPIを提供するライブラリのための低レベルのビルディングブロック。</target>
        </trans-unit>
        <trans-unit id="33c64772edef0388f14ce1b4adb0c6c1bb1aa8e4" translate="yes" xml:space="preserve">
          <source>Luckily, Kotlin has got &lt;em&gt;reified type parameters&lt;/em&gt;, which alleviates some of these problems. By writing &lt;code&gt;reified&lt;/code&gt; in front of a generic type parameter, it does become available at runtime, and you'll get to write &lt;code&gt;T::class&lt;/code&gt; to get the &lt;a href=&quot;member-references-and-reflection#obtaining-member-references-from-a-class-reference&quot;&gt;class metadata&lt;/a&gt;. You can only do this in inline functions (because an inline function will be compiled into its callsite, where the type information &lt;em&gt;is&lt;/em&gt; available at runtime), but it still goes a long way. For example, you can make an inline wrapper function for a big function that has got a less elegant signature.</source>
          <target state="translated">幸いなことに、Kotlinには&lt;em&gt;具体化された型パラメーター&lt;/em&gt;があり、これらの問題の一部が軽減されます。ジェネリック型パラメーターの前に &lt;code&gt;reified&lt;/code&gt; を書き込むと、実行時に使用可能になり、&lt;a href=&quot;member-references-and-reflection#obtaining-member-references-from-a-class-reference&quot;&gt;クラスメタデータ&lt;/a&gt;を取得するために &lt;code&gt;T::class&lt;/code&gt; を書き込むことができます。これはインライン関数でのみ実行できます（インライン関数はそのコールサイトにコンパイルされるため、実行時に型情報&lt;em&gt;が&lt;/em&gt;利用可能です）が、それでも長い道のりです。たとえば、あまりエレガントでないシグネチャを持つ大きな関数に対してインラインラッパー関数を作成できます。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2dc6e5580de3bf07607e19a673cd1f05b259b2bd" translate="yes" xml:space="preserve">
          <source>MACOSX</source>
          <target state="translated">MACOSX</target>
        </trans-unit>
        <trans-unit id="c8341a27b6d81ce4872ef2e5c74c71c1fa656185" translate="yes" xml:space="preserve">
          <source>MATH_SYMBOL</source>
          <target state="translated">MATH_SYMBOL</target>
        </trans-unit>
        <trans-unit id="ccd2cb474249294edd8d61576efe0ac7d7c17d4c" translate="yes" xml:space="preserve">
          <source>MAX_CODE_POINT</source>
          <target state="translated">MAX_CODE_POINT</target>
        </trans-unit>
        <trans-unit id="1a9fd1b3912908145111964e328d77ecf366fc06" translate="yes" xml:space="preserve">
          <source>MAX_COMPONENT_VALUE</source>
          <target state="translated">MAX_COMPONENT_VALUE</target>
        </trans-unit>
        <trans-unit id="6a3f20e248cb8672ba053480b2e5604ed15471fb" translate="yes" xml:space="preserve">
          <source>MAX_HIGH_SURROGATE</source>
          <target state="translated">MAX_HIGH_SURROGATE</target>
        </trans-unit>
        <trans-unit id="93b95c89e3f09a5c822039fdb274e4e9543f7b4d" translate="yes" xml:space="preserve">
          <source>MAX_LOW_SURROGATE</source>
          <target state="translated">MAX_LOW_SURROGATE</target>
        </trans-unit>
        <trans-unit id="723df4d178ea35581b90fb4dff97fa4d9e1295a6" translate="yes" xml:space="preserve">
          <source>MAX_RADIX</source>
          <target state="translated">MAX_RADIX</target>
        </trans-unit>
        <trans-unit id="e1273ad446270c0c9cf3fd5cad44848e8250ffba" translate="yes" xml:space="preserve">
          <source>MAX_SURROGATE</source>
          <target state="translated">MAX_SURROGATE</target>
        </trans-unit>
        <trans-unit id="24fdbf54e8bc77709b6bd7478c1804e90d84d0ca" translate="yes" xml:space="preserve">
          <source>MAX_VALUE</source>
          <target state="translated">MAX_VALUE</target>
        </trans-unit>
        <trans-unit id="030147a88935a9397a9625c627fb1af71a30209e" translate="yes" xml:space="preserve">
          <source>MF</source>
          <target state="translated">MF</target>
        </trans-unit>
        <trans-unit id="784a46c14fea9ff3fb4d5c790913e2db7292c56e" translate="yes" xml:space="preserve">
          <source>MICROSECONDS</source>
          <target state="translated">MICROSECONDS</target>
        </trans-unit>
        <trans-unit id="370c3ba851aaa71b93e5d791ecaddbf60722fede" translate="yes" xml:space="preserve">
          <source>MILLISECONDS</source>
          <target state="translated">MILLISECONDS</target>
        </trans-unit>
        <trans-unit id="9c200cc936c861cebaa3fc9dbe92407a4a2f6d99" translate="yes" xml:space="preserve">
          <source>MINUTES</source>
          <target state="translated">MINUTES</target>
        </trans-unit>
        <trans-unit id="c93eded712b6299da78db6d4eb86c71d455d7389" translate="yes" xml:space="preserve">
          <source>MIN_CODE_POINT</source>
          <target state="translated">MIN_CODE_POINT</target>
        </trans-unit>
        <trans-unit id="a8865ad11853a6b46e09f6d1cdddfd073f7d4851" translate="yes" xml:space="preserve">
          <source>MIN_HIGH_SURROGATE</source>
          <target state="translated">MIN_HIGH_SURROGATE</target>
        </trans-unit>
        <trans-unit id="bd2ef64ddf3863a50e14b7b72bf632b54603d300" translate="yes" xml:space="preserve">
          <source>MIN_LOW_SURROGATE</source>
          <target state="translated">MIN_LOW_SURROGATE</target>
        </trans-unit>
        <trans-unit id="91631ed7ebe4f66d93a855f168fd993a18bbb9ae" translate="yes" xml:space="preserve">
          <source>MIN_RADIX</source>
          <target state="translated">MIN_RADIX</target>
        </trans-unit>
        <trans-unit id="ff3ed914be4d85796f20ffe750d11ae41f0c093d" translate="yes" xml:space="preserve">
          <source>MIN_SUPPLEMENTARY_CODE_POINT</source>
          <target state="translated">MIN_SUPPLEMENTARY_CODE_POINT</target>
        </trans-unit>
        <trans-unit id="5aa1c9c7ed6ef1169c3e694d2e0558e797993672" translate="yes" xml:space="preserve">
          <source>MIN_SURROGATE</source>
          <target state="translated">MIN_SURROGATE</target>
        </trans-unit>
        <trans-unit id="ac7a7603646aca67877b81e10b36687c24f7d10a" translate="yes" xml:space="preserve">
          <source>MIN_VALUE</source>
          <target state="translated">MIN_VALUE</target>
        </trans-unit>
        <trans-unit id="9028a909c025cf9d16590fd055950504b793f600" translate="yes" xml:space="preserve">
          <source>MIPS32</source>
          <target state="translated">MIPS32</target>
        </trans-unit>
        <trans-unit id="ac1d1ed5dec64feab585fa1220864d5680a5811e" translate="yes" xml:space="preserve">
          <source>MIPSEL32</source>
          <target state="translated">MIPSEL32</target>
        </trans-unit>
        <trans-unit id="7b5afc2e6529ad3bd8e57a7791978e690003bcdd" translate="yes" xml:space="preserve">
          <source>MODIFIER_LETTER</source>
          <target state="translated">MODIFIER_LETTER</target>
        </trans-unit>
        <trans-unit id="8f6a3829c268c3a50caa5a3744901aba89c88358" translate="yes" xml:space="preserve">
          <source>MODIFIER_SYMBOL</source>
          <target state="translated">MODIFIER_SYMBOL</target>
        </trans-unit>
        <trans-unit id="84757851065b4eb5ddf781037790225276f37d3e" translate="yes" xml:space="preserve">
          <source>MULTILINE</source>
          <target state="translated">MULTILINE</target>
        </trans-unit>
        <trans-unit id="37a6f811775e72996553c62c5ef2ab8e4e658bea" translate="yes" xml:space="preserve">
          <source>MacOS (x86_64)</source>
          <target state="translated">マックオス</target>
        </trans-unit>
        <trans-unit id="07a4d61f0acbbb95318a8a2d2e1f3a3b76934273" translate="yes" xml:space="preserve">
          <source>MacPorts</source>
          <target state="translated">MacPorts</target>
        </trans-unit>
        <trans-unit id="899bd694d29ace1be956ab35177075021977560b" translate="yes" xml:space="preserve">
          <source>Macros</source>
          <target state="translated">Macros</target>
        </trans-unit>
        <trans-unit id="9c574760a1e8c967bc35e78752b8950efd331477" translate="yes" xml:space="preserve">
          <source>Make frameworks static when using rebuild from bitcode</source>
          <target state="translated">ビットコードからのリビルドでフレームワークを静的にする</target>
        </trans-unit>
        <trans-unit id="c22d87ecdb73737e3e9e79d9b2b16c5c79a06654" translate="yes" xml:space="preserve">
          <source>Make sure its return type is &lt;code&gt;Unit&lt;/code&gt;, and report an error otherwise,</source>
          <target state="translated">戻り値の型が &lt;code&gt;Unit&lt;/code&gt; であることを確認し、それ以外の場合はエラーを報告します。</target>
        </trans-unit>
        <trans-unit id="2fba991ad8d6b5e98b20f4c1f0a7d640d19bbf4f" translate="yes" xml:space="preserve">
          <source>Make sure that you have CocoaPods &lt;a href=&quot;https://guides.cocoapods.org/using/getting-started.html#installation&quot;&gt;installed&lt;/a&gt;. We recommend using CocoaPods 1.6.1 or later.</source>
          <target state="translated">CocoaPodsが&lt;a href=&quot;https://guides.cocoapods.org/using/getting-started.html#installation&quot;&gt;インストールされ&lt;/a&gt;ていることを確認してください。CocoaPods 1.6.1以降の使用をお勧めします。</target>
        </trans-unit>
        <trans-unit id="4666c5046e05de3ced6688314c5b8b2fdc5e809d" translate="yes" xml:space="preserve">
          <source>Make sure that you import the &lt;code&gt;react.dom.*&lt;/code&gt; and &lt;code&gt;styled.*&lt;/code&gt; packages.</source>
          <target state="translated">必ず &lt;code&gt;react.dom.*&lt;/code&gt; および &lt;code&gt;styled.*&lt;/code&gt; パッケージをインポートしてください。</target>
        </trans-unit>
        <trans-unit id="c46d38a6352744d726ba87d5e2a3fe0550a5b018" translate="yes" xml:space="preserve">
          <source>Make sure that you import the package &lt;code&gt;kotlinx.html.js.*&lt;/code&gt;.</source>
          <target state="translated">必ずパッケージ &lt;code&gt;kotlinx.html.js.*&lt;/code&gt; をインポートしてください。</target>
        </trans-unit>
        <trans-unit id="872ea4c8c9e3e67462cf45519bbed3ec439a01dd" translate="yes" xml:space="preserve">
          <source>Make sure that you load the &lt;code&gt;kotlin.js&lt;/code&gt; runtime first, and then your application.</source>
          <target state="translated">最初に &lt;code&gt;kotlin.js&lt;/code&gt; ランタイムをロードしてから、アプリケーションをロードしてください。</target>
        </trans-unit>
        <trans-unit id="5aa48b84880f06c505b8b4e3340f284931cef8e6" translate="yes" xml:space="preserve">
          <source>Make sure that your declared annotation has a proper annotation target (Java&amp;rsquo;s &lt;code&gt;ElementType.TYPE_USE&lt;/code&gt; or Kotlin&amp;rsquo;s &lt;code&gt;AnnotationTarget.TYPE&lt;/code&gt;) and retention (&lt;code&gt;AnnotationRetention.RUNTIME&lt;/code&gt;).</source>
          <target state="translated">宣言されたアノテーションに適切なアノテーションターゲット（Javaの &lt;code&gt;ElementType.TYPE_USE&lt;/code&gt; またはKotlinの &lt;code&gt;AnnotationTarget.TYPE&lt;/code&gt; ）と保持（ &lt;code&gt;AnnotationRetention.RUNTIME&lt;/code&gt; ）があることを確認してください。</target>
        </trans-unit>
        <trans-unit id="eb5ad277768300cd65b74ec021eb800da7b06237" translate="yes" xml:space="preserve">
          <source>Make updating to new versions comfortable for the users.</source>
          <target state="translated">新しいバージョンへのアップデートをユーザーにとって快適なものにします。</target>
        </trans-unit>
        <trans-unit id="f677748d219b353836ae9469d4c8eb0bcdf46ffb" translate="yes" xml:space="preserve">
          <source>Makes Kotlin method in Objective-C class accessible through Objective-C dispatch to be used as action sent by control in UIKit or AppKit.</source>
          <target state="translated">Objective-CクラスのKotlinメソッドをObjective-Cディスパッチでアクセス可能にし、UIKitやAppKitのコントロールから送信されるアクションとして利用できるようにします。</target>
        </trans-unit>
        <trans-unit id="09f808d1435cc07cd95f3ecbee1a2efed0c87454" translate="yes" xml:space="preserve">
          <source>Makes Kotlin property in Objective-C class settable through Objective-C dispatch to be used as IB outlet.</source>
          <target state="translated">Objective-C クラスの Kotlin プロパティを Objective-C ディスパッチで設定できるようにし、IB アウトレットとして使用できるようにします。</target>
        </trans-unit>
        <trans-unit id="79cbb2384899cfe766ce2633e3ff22d2f36982b6" translate="yes" xml:space="preserve">
          <source>Makes Kotlin subclass of Objective-C class visible for runtime lookup after Kotlin &lt;code&gt;main&lt;/code&gt; function gets invoked.</source>
          <target state="translated">Kotlin &lt;code&gt;main&lt;/code&gt; 関数が呼び出された後、Objective-CクラスのKotlinサブクラスをランタイムルックアップで表示できるようにします。</target>
        </trans-unit>
        <trans-unit id="f35a32ffaf96633b14ae608748f888d188401daf" translate="yes" xml:space="preserve">
          <source>Makes call to the specified &lt;a href=&quot;../-deep-recursive-function/index&quot;&gt;DeepRecursiveFunction&lt;/a&gt; function putting the call activation frame on the heap, as opposed to the actual call stack that is used by a regular call.</source>
          <target state="translated">通常の呼び出しで使用される実際の呼び出しスタックとは対照的に、指定された&lt;a href=&quot;../-deep-recursive-function/index&quot;&gt;DeepRecursiveFunction&lt;/a&gt;関数を呼び出して、呼び出しアクティブ化フレームをヒープに配置します。</target>
        </trans-unit>
        <trans-unit id="380302710c7a9c26b7742a1058f704b9bb0ef0a3" translate="yes" xml:space="preserve">
          <source>Makes recursive call to this &lt;a href=&quot;../-deep-recursive-function/index&quot;&gt;DeepRecursiveFunction&lt;/a&gt; function putting the call activation frame on the heap, as opposed to the actual call stack that is used by a regular recursive call.</source>
          <target state="translated">通常の再帰呼び出しで使用される実際の呼び出しスタックとは対照的に、この&lt;a href=&quot;../-deep-recursive-function/index&quot;&gt;DeepRecursiveFunction&lt;/a&gt;関数を再帰呼び出しして、呼び出しアクティブ化フレームをヒープに配置します。</target>
        </trans-unit>
        <trans-unit id="34b5071a9847a34a44b37d8ab94597a0b604b867" translate="yes" xml:space="preserve">
          <source>Makes the annotated annotation class an associated object key.</source>
          <target state="translated">注釈付き注釈クラスを関連付けられたオブジェクト・キーにします。</target>
        </trans-unit>
        <trans-unit id="c05c0a0b46c6d81aa3deae4e473b3f5b195d9dae" translate="yes" xml:space="preserve">
          <source>Makes top level function available from C/C++ code with the given name.</source>
          <target state="translated">与えられた名前でC/C++コードからトップレベルの関数を利用できるようにします。</target>
        </trans-unit>
        <trans-unit id="33733bb607beb4f5ed38e06a91a784c426296320" translate="yes" xml:space="preserve">
          <source>Making busy flow cancellable</source>
          <target state="translated">忙しい流れをキャンセル可能にする</target>
        </trans-unit>
        <trans-unit id="3dc9b78fb75740d031749aa0e1f6c2f20915be09" translate="yes" xml:space="preserve">
          <source>Making computation code cancellable</source>
          <target state="translated">計算コードをキャンセル可能にする</target>
        </trans-unit>
        <trans-unit id="d26e8b17246e39f5acbd44ce84cfe44e4708e7bc" translate="yes" xml:space="preserve">
          <source>Making frequent null checks is annoying, so if you have to allow for the possibility of nulls, there are several very useful operators in Kotlin to ease working with values that might be null, as described below.</source>
          <target state="translated">頻繁にヌルチェックをするのは面倒なので、ヌルの可能性を許容しなければならない場合、Kotlinには、以下に説明するように、ヌルになる可能性のある値の処理を簡単にするための非常に便利な演算子がいくつかあります。</target>
        </trans-unit>
        <trans-unit id="f35727fd1febb5955e04a96a85cfbf28b11e18a0" translate="yes" xml:space="preserve">
          <source>Malformed byte sequences are replaced by the replacement char &lt;code&gt;\uFFFD&lt;/code&gt;.</source>
          <target state="translated">不正なバイトシーケンスは、置換文字 &lt;code&gt;\uFFFD&lt;/code&gt; 置き換えられます。</target>
        </trans-unit>
        <trans-unit id="b2aee73bd2e79677bed872d3980e254bec42f2c5" translate="yes" xml:space="preserve">
          <source>Managing dependencies</source>
          <target state="translated">依存関係の管理</target>
        </trans-unit>
        <trans-unit id="f45216dfe5658802d5da85dd6691495f1dd5ee41" translate="yes" xml:space="preserve">
          <source>Managing sources</source>
          <target state="translated">ソースの管理</target>
        </trans-unit>
        <trans-unit id="b0426429a44f47228605bdec162f6e1798c46d34" translate="yes" xml:space="preserve">
          <source>Managing targets</source>
          <target state="translated">目標管理</target>
        </trans-unit>
        <trans-unit id="dc1586db5c7b55a74cd10223f2e3a7fe8bf95caa" translate="yes" xml:space="preserve">
          <source>Mangling</source>
          <target state="translated">Mangling</target>
        </trans-unit>
        <trans-unit id="76f58e9ae1ecc3bcd5734ccddd0e7976cd032c5b" translate="yes" xml:space="preserve">
          <source>Manual Configuration</source>
          <target state="translated">手動設定</target>
        </trans-unit>
        <trans-unit id="724adbdc3ff0031b5c79ad867a79546b920a65f6" translate="yes" xml:space="preserve">
          <source>Manual Install</source>
          <target state="translated">マニュアルインストール</target>
        </trans-unit>
        <trans-unit id="4892a25af3b45967112eda593c6c4ff560c25b52" translate="yes" xml:space="preserve">
          <source>Manually apply an Android Gradle plugin &amp;ndash; &lt;code&gt;com.android.application&lt;/code&gt; or &lt;code&gt;com.android.library&lt;/code&gt;.</source>
          <target state="translated">Android Gradleプラグインを手動で適用します &lt;code&gt;com.android.application&lt;/code&gt; または &lt;code&gt;com.android.library&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3a6d42d1875648e1f154683fe273a941e93a43bb" translate="yes" xml:space="preserve">
          <source>Manually generating external declarations via Gradle task</source>
          <target state="translated">Gradleタスクを使って外部宣言を手動で生成する</target>
        </trans-unit>
        <trans-unit id="65a73e4ea7721ba692baf916576f5d262d09eb6e" translate="yes" xml:space="preserve">
          <source>Many modern IDEs support Kotlin and help in writing idiomatic Kotlin code:</source>
          <target state="translated">最近の多くのIDEはKotlinをサポートしており、慣用的なKotlinコードを書くのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="564f728d4accd1cab1faa6abd0808aa411a7afbc" translate="yes" xml:space="preserve">
          <source>Many of the options can also be configured through properties:</source>
          <target state="translated">オプションの多くは、プロパティからも設定できます。</target>
        </trans-unit>
        <trans-unit id="e10c89b0b0ca5be3c7b04daef4c60db7fc1b6f90" translate="yes" xml:space="preserve">
          <source>Many people already use &lt;a href=&quot;coroutines/coroutines-guide&quot;&gt;coroutines&lt;/a&gt; for asynchronous programming. But when it came to debugging, working with coroutines before Kotlin 1.4, could be a real pain. Since coroutines jumped between threads, it was difficult to understand what a specific coroutine was doing and check its context. In some cases, tracking steps over breakpoints simply didn&amp;rsquo;t work. As a result, you had to rely on logging or mental effort to debug code that used coroutines.</source>
          <target state="translated">多くの人がすでに非同期プログラミングに&lt;a href=&quot;coroutines/coroutines-guide&quot;&gt;コルーチン&lt;/a&gt;を使用しています。しかし、デバッグに関しては、Kotlin1.4より前のコルーチンでの作業は非常に困難な場合があります。コルーチンはスレッド間をジャンプするため、特定のコルーチンが何をしているのかを理解し、そのコンテキストを確認することは困難でした。場合によっては、ブレークポイントを介したステップの追跡が単に機能しませんでした。その結果、コルーチンを使用するコードをデバッグするには、ロギングまたは精神的な努力に頼らざるを得ませんでした。</target>
        </trans-unit>
        <trans-unit id="fe81b734a40201fad1b163bd75e5e8866ba447fc" translate="yes" xml:space="preserve">
          <source>Many startups and Fortune 500 companies have already developed Android applications using Kotlin &amp;ndash; see the list at &lt;a href=&quot;https://developer.android.com/kotlin&quot;&gt;the Google website for Kotlin developers&lt;/a&gt;.</source>
          <target state="translated">多くの新興企業やフォーチュン500企業はすでにKotlinを使用してAndroidアプリケーションを開発しています&lt;a href=&quot;https://developer.android.com/kotlin&quot;&gt;。Kotlin開発者向けのGoogleWebサイトの&lt;/a&gt;リストを参照してください。</target>
        </trans-unit>
        <trans-unit id="ab478f3efc840eebab919dff1b9512286f70c10c" translate="yes" xml:space="preserve">
          <source>Map</source>
          <target state="translated">Map</target>
        </trans-unit>
        <trans-unit id="1a3e682ff2754ef0b1db9651d934d18042efd51a" translate="yes" xml:space="preserve">
          <source>Map Specific Operations</source>
          <target state="translated">マップ固有の操作</target>
        </trans-unit>
        <trans-unit id="8a55ba4dc9c56793f4d86eafccdf893ff4dfc510" translate="yes" xml:space="preserve">
          <source>Map nullable value if not null</source>
          <target state="translated">null でない場合は、nullable 値をマップします。</target>
        </trans-unit>
        <trans-unit id="154baeb185088267d2e04dd13fb49c8faf1731b4" translate="yes" xml:space="preserve">
          <source>Map write operations</source>
          <target state="translated">マップ書き込み操作</target>
        </trans-unit>
        <trans-unit id="7c78455b5524d54dd5717439fdd75a3564e3b05c" translate="yes" xml:space="preserve">
          <source>Map.getValue()</source>
          <target state="translated">Map.getValue()</target>
        </trans-unit>
        <trans-unit id="ab6d914f12b0209ae12f1eaa021fab679f71fbd9" translate="yes" xml:space="preserve">
          <source>Map.minus(key)</source>
          <target state="translated">Map.minus(key)</target>
        </trans-unit>
        <trans-unit id="a1e3b9de38695948c83390c6219ada2b49d0eb03" translate="yes" xml:space="preserve">
          <source>Map.toMap() and Map.toMutableMap()</source>
          <target state="translated">Map.toMap()および Map.toMutableMap()</target>
        </trans-unit>
        <trans-unit id="f5503e0acfd60752001069a9088cb22064b114de" translate="yes" xml:space="preserve">
          <source>Mapped types</source>
          <target state="translated">マップされたタイプ</target>
        </trans-unit>
        <trans-unit id="def2eba59562958fa4a005f8070d692ef8502312" translate="yes" xml:space="preserve">
          <source>Mapping</source>
          <target state="translated">Mapping</target>
        </trans-unit>
        <trans-unit id="ae3c45c6220c54a755f63c613acc1f9b440f728e" translate="yes" xml:space="preserve">
          <source>Mapping Function Pointer Types from C</source>
          <target state="translated">C言語からの関数ポインタ型のマッピング</target>
        </trans-unit>
        <trans-unit id="3629da3c88dfc6308c1eb31a6616f2493b1b3a4a" translate="yes" xml:space="preserve">
          <source>Mapping Function Pointers from C</source>
          <target state="translated">Cからの関数ポインタのマッピング</target>
        </trans-unit>
        <trans-unit id="1ab023f41f65f5d65722a6148006ad3ade089fb2" translate="yes" xml:space="preserve">
          <source>Mapping Primitive Data Types from C</source>
          <target state="translated">Cからのプリミティブデータ型のマッピング</target>
        </trans-unit>
        <trans-unit id="d6b4467553c4b4c986cbd21872e97a3c8e8ea762" translate="yes" xml:space="preserve">
          <source>Mapping Strings from C</source>
          <target state="translated">Cからの文字列のマッピング</target>
        </trans-unit>
        <trans-unit id="76a029f685d2ba76aaeecfdb2224f273ebee328a" translate="yes" xml:space="preserve">
          <source>Mapping Struct and Union C types</source>
          <target state="translated">マッピング構造とユニオンCタイプ</target>
        </trans-unit>
        <trans-unit id="565e074c9f98132ef0f9b4a1395ca391399b5fc8" translate="yes" xml:space="preserve">
          <source>Mapping Struct and Union Types from C</source>
          <target state="translated">Cから構造体とユニオンタイプのマッピング</target>
        </trans-unit>
        <trans-unit id="1cbcdd98d1b5744757244f463b7f939b4869f3e4" translate="yes" xml:space="preserve">
          <source>Mappings</source>
          <target state="translated">Mappings</target>
        </trans-unit>
        <trans-unit id="4811d5bdec38d0b9bed7265f0e3355c78194b1ff" translate="yes" xml:space="preserve">
          <source>Marker interface indicating that the &lt;a href=&quot;-list/index#kotlin.collections.List&quot;&gt;List&lt;/a&gt; implementation supports fast indexed access.</source>
          <target state="translated">&lt;a href=&quot;-list/index#kotlin.collections.List&quot;&gt;Listの&lt;/a&gt;実装が高速なインデックス付きアクセスをサポートすることを示すマーカーインターフェイス。</target>
        </trans-unit>
        <trans-unit id="79f92c6a2f9b55de94523a0137df26f32b271fc3" translate="yes" xml:space="preserve">
          <source>Marker interface indicating that the &lt;a href=&quot;../../kotlin.collections/-list/index#kotlin.collections.List&quot;&gt;List&lt;/a&gt; implementation supports fast indexed access.</source>
          <target state="translated">&lt;a href=&quot;../../kotlin.collections/-list/index#kotlin.collections.List&quot;&gt;Listの&lt;/a&gt;実装が高速なインデックス付きアクセスをサポートすることを示すマーカーインターフェイス。</target>
        </trans-unit>
        <trans-unit id="deb9ed7bb61b8698d73e57af565358059241e0bd" translate="yes" xml:space="preserve">
          <source>Marking API elements</source>
          <target state="translated">API要素のマーキング</target>
        </trans-unit>
        <trans-unit id="39acae63028d11938c7d9a75f3ad9099e5f79972" translate="yes" xml:space="preserve">
          <source>Marking experimental API</source>
          <target state="translated">実験用APIのマーキング</target>
        </trans-unit>
        <trans-unit id="72ca39cc361248a73db4aa376ff098d3162e32bf" translate="yes" xml:space="preserve">
          <source>Marking rules: an implicit receiver is considered marked with @Ann if</source>
          <target state="translated">マーキングルール:暗黙のレシーバは、@Ann でマークされているとみなされます。</target>
        </trans-unit>
        <trans-unit id="86bad6d0089ea3bb1c0a2e322f9709163fa38969" translate="yes" xml:space="preserve">
          <source>Marks a point in time on this time source.</source>
          <target state="translated">この時間のソースにポイントをマークします。</target>
        </trans-unit>
        <trans-unit id="d4db1b9cfb765a0420560d33f4c49a590513a4d0" translate="yes" xml:space="preserve">
          <source>Marks a top level property with a backing field as immutable. It is possible to share the value of such property between multiple threads, but it becomes deeply frozen, so no changes can be made to its state or the state of objects it refers to.</source>
          <target state="translated">バッキングフィールドを持つトップレベルのプロパティを不変としてマークします。このようなプロパティの値を複数のスレッド間で共有することは可能ですが、深く凍結されてしまうため、その状態や参照しているオブジェクトの状態を変更することはできません。</target>
        </trans-unit>
        <trans-unit id="a224cc22214be0edab83e29fa79b9dd2dd10f50f" translate="yes" xml:space="preserve">
          <source>Marks a top level property with a backing field or an object as thread local. The object remains mutable and it is possible to change its state, but every thread will have a distinct copy of this object, so changes in one thread are not reflected in another.</source>
          <target state="translated">バッキングフィールドまたはオブジェクトを持つトップレベルのプロパティをスレッドローカルとしてマークします。オブジェクトは変更可能なままで、その状態を変更することができますが、すべてのスレッドはこのオブジェクトの個別のコピーを持つことになるので、あるスレッドでの変更は別のスレッドには反映されません。</target>
        </trans-unit>
        <trans-unit id="33d0711db8fea3ba5bf0ebfba79cfe0cf8264458" translate="yes" xml:space="preserve">
          <source>Marks a top level variable with a backing field or an object as immutable. It is possible to share such object between multiple threads, but it becomes deeply frozen, so no changes can be made to its state or the state of objects it refers to.</source>
          <target state="translated">バッキングフィールドを持つトップレベルの変数やオブジェクトに不変のマークを付けます。このようなオブジェクトを複数のスレッド間で共有することは可能ですが、深く凍結されてしまうため、その状態や参照しているオブジェクトの状態を変更することはできません。</target>
        </trans-unit>
        <trans-unit id="9c86911fdb83bb1e6cafe3509aa437cd672c34a9" translate="yes" xml:space="preserve">
          <source>Marks a top level variable with a backing field or an object as thread local. The object remains mutable and it is possible to change its state, but every thread will have a distinct copy of this object, so changes in one thread are not reflected in another.</source>
          <target state="translated">バッキングフィールドやオブジェクトを持つトップレベルの変数をスレッドローカルとしてマークします。オブジェクトは変更可能なままで、その状態を変更することができますが、すべてのスレッドがこのオブジェクトの個別のコピーを持つことになるので、あるスレッドでの変更は別のスレッドには反映されません。</target>
        </trans-unit>
        <trans-unit id="6ec4d266890af2cb0a6aa9e1810055ba658008f8" translate="yes" xml:space="preserve">
          <source>Marks an expected annotation class that it isn't required to have actual counterparts in all platforms.</source>
          <target state="translated">すべてのプラットフォームで実際の対応するものを持つ必要がないことを期待される注釈クラスにマークを付けます。</target>
        </trans-unit>
        <trans-unit id="5c6f17834ff35593c5226191e98557d99d755e77" translate="yes" xml:space="preserve">
          <source>Marks coroutine context element that intercepts coroutine continuations. The coroutines framework uses &lt;a href=&quot;-continuation-interceptor/-key&quot;&gt;ContinuationInterceptor.Key&lt;/a&gt; to retrieve the interceptor and intercepts all coroutine continuations with &lt;a href=&quot;-continuation-interceptor/intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt; invocations.</source>
          <target state="translated">コルーチンの継続をインターセプトするコルーチンコンテキスト要素をマークします。コルーチンフレームワークは&lt;a href=&quot;-continuation-interceptor/-key&quot;&gt;ContinuationInterceptor.Key&lt;/a&gt;を使用してインターセプターを取得し、&lt;a href=&quot;-continuation-interceptor/intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt;呼び出しですべてのコルーチンの継続をインターセプトします。</target>
        </trans-unit>
        <trans-unit id="292a3151e7a72885408caf9ee437ad5d8673be4a" translate="yes" xml:space="preserve">
          <source>Marks coroutine context element that intercepts coroutine continuations. The coroutines framework uses &lt;a href=&quot;-key&quot;&gt;ContinuationInterceptor.Key&lt;/a&gt; to retrieve the interceptor and intercepts all coroutine continuations with &lt;a href=&quot;intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt; invocations.</source>
          <target state="translated">コルーチンの継続をインターセプトするコルーチンコンテキスト要素をマークします。コルーチンフレームワークは&lt;a href=&quot;-key&quot;&gt;ContinuationInterceptor.Key&lt;/a&gt;を使用してインターセプターを取得し、&lt;a href=&quot;intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt;呼び出しですべてのコルーチンの継続をインターセプトします。</target>
        </trans-unit>
        <trans-unit id="5be31e799227d8931dded0eeace958d0a3e43418" translate="yes" xml:space="preserve">
          <source>Marks coroutine context element that intercepts coroutine continuations. The coroutines framework uses &lt;a href=&quot;../../kotlin.coroutines.experimental/-continuation-interceptor/-key&quot;&gt;ContinuationInterceptor.Key&lt;/a&gt; to retrieve the interceptor and intercepts all coroutine continuations with &lt;a href=&quot;../../kotlin.coroutines.experimental/-continuation-interceptor/intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt; invocations.</source>
          <target state="translated">コルーチンの継続をインターセプトするコルーチンコンテキスト要素をマークします。コルーチンフレームワークは&lt;a href=&quot;../../kotlin.coroutines.experimental/-continuation-interceptor/-key&quot;&gt;ContinuationInterceptor.Key&lt;/a&gt;を使用してインターセプターを取得し、&lt;a href=&quot;../../kotlin.coroutines.experimental/-continuation-interceptor/intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt;呼び出しですべてのコルーチンの継続をインターセプトします。</target>
        </trans-unit>
        <trans-unit id="589152c67b668bc3a0e5e851927c4f25196aa066" translate="yes" xml:space="preserve">
          <source>Marks coroutine context element that intercepts coroutine continuations. The coroutines framework uses &lt;a href=&quot;../../kotlin.coroutines/-continuation-interceptor/-key&quot;&gt;ContinuationInterceptor.Key&lt;/a&gt; to retrieve the interceptor and intercepts all coroutine continuations with &lt;a href=&quot;../../kotlin.coroutines/-continuation-interceptor/intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt; invocations.</source>
          <target state="translated">コルーチンの継続をインターセプトするコルーチンコンテキスト要素をマークします。コルーチンフレームワークは&lt;a href=&quot;../../kotlin.coroutines/-continuation-interceptor/-key&quot;&gt;ContinuationInterceptor.Key&lt;/a&gt;を使用してインターセプターを取得し、&lt;a href=&quot;../../kotlin.coroutines/-continuation-interceptor/intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt;呼び出しですべてのコルーチンの継続をインターセプトします。</target>
        </trans-unit>
        <trans-unit id="e74d580f7febe5c2f5fce47ebee5f4b2a5e537e3" translate="yes" xml:space="preserve">
          <source>Marks experimental JS export annotations.</source>
          <target state="translated">実験的なJSエクスポートアノテーションをマークします。</target>
        </trans-unit>
        <trans-unit id="2df77c28828a089a19fdffaa1789ccacc76664f7" translate="yes" xml:space="preserve">
          <source>Marks the API that is dependent on the experimental unsigned types, including those types themselves.</source>
          <target state="translated">実験的な符号なし型に依存するAPIをマークします。</target>
        </trans-unit>
        <trans-unit id="73273d6a95cad7e50a139041438fbf00005e8089" translate="yes" xml:space="preserve">
          <source>Marks the JVM backing field of the annotated property as &lt;code&gt;transient&lt;/code&gt;, meaning that it is not part of the default serialized form of the object.</source>
          <target state="translated">注釈付きプロパティのJVMバッキングフィールドを &lt;code&gt;transient&lt;/code&gt; としてマークします。これは、オブジェクトのデフォルトのシリアル化された形式の一部ではないことを意味します。</target>
        </trans-unit>
        <trans-unit id="fd02a709ebd5dfcba6e63db7078d9717fce347a3" translate="yes" xml:space="preserve">
          <source>Marks the JVM backing field of the annotated property as &lt;code&gt;volatile&lt;/code&gt;, meaning that writes to this field are immediately made visible to other threads.</source>
          <target state="translated">注釈付きプロパティのJVMバッキングフィールドを &lt;code&gt;volatile&lt;/code&gt; としてマークします。つまり、このフィールドへの書き込みはすぐに他のスレッドから見えるようになります。</target>
        </trans-unit>
        <trans-unit id="1c403a59019182391a8ff7eb648d56329fc1e05f" translate="yes" xml:space="preserve">
          <source>Marks the JVM method generated from the annotated function as &lt;code&gt;strictfp&lt;/code&gt;, meaning that the precision of floating point operations performed inside the method needs to be restricted in order to achieve better portability.</source>
          <target state="translated">アノテーション付き関数から生成されたJVMメソッドを &lt;code&gt;strictfp&lt;/code&gt; としてマークします。つまり、メソッド内で実行される浮動小数点演算の精度を制限して、移植性を向上させる必要があります。</target>
        </trans-unit>
        <trans-unit id="58ecb1a8fc60ff73e8fc37346fd83ecb47a77bf8" translate="yes" xml:space="preserve">
          <source>Marks the JVM method generated from the annotated function as &lt;code&gt;synchronized&lt;/code&gt;, meaning that the method will be protected from concurrent execution by multiple threads by the monitor of the instance (or, for static methods, the class) on which the method is defined.</source>
          <target state="translated">注釈付き関数から生成されたJVMメソッドを &lt;code&gt;synchronized&lt;/code&gt; としてマークします。つまり、メソッドが定義されているインスタンス（または静的メソッドの場合はクラス）のモニターによって、メソッドが複数のスレッドによる同時実行から保護されます。</target>
        </trans-unit>
        <trans-unit id="fb96fdd73420dc05c701eb6e0838bd95d38438a9" translate="yes" xml:space="preserve">
          <source>Marks the annotated declaration as deprecated.</source>
          <target state="translated">アノテーション宣言を非推奨とするマークを付けます。</target>
        </trans-unit>
        <trans-unit id="7d98c397e94ce7053df95bf37d1da503360432a5" translate="yes" xml:space="preserve">
          <source>Marks the annotated declaration as deprecated. In contrast to &lt;a href=&quot;-deprecated/index#kotlin.Deprecated&quot;&gt;Deprecated&lt;/a&gt;, severity of the reported diagnostic is not a constant value, but differs depending on the API version of the usage (the value of the &lt;code&gt;-api-version&lt;/code&gt; argument when compiling the module where the usage is located). If the API version is greater or equal than &lt;a href=&quot;-deprecated-since-kotlin/hidden-since#kotlin.DeprecatedSinceKotlin%24hiddenSince&quot;&gt;hiddenSince&lt;/a&gt;, the declaration will not be accessible from the code (as if it was deprecated with level &lt;a href=&quot;-deprecation-level/-h-i-d-d-e-n#kotlin.DeprecationLevel.HIDDEN&quot;&gt;DeprecationLevel.HIDDEN&lt;/a&gt;), otherwise if the API version is greater or equal than &lt;a href=&quot;-deprecated-since-kotlin/error-since#kotlin.DeprecatedSinceKotlin%24errorSince&quot;&gt;errorSince&lt;/a&gt;, the usage will be marked as an error (as with &lt;a href=&quot;-deprecation-level/-e-r-r-o-r#kotlin.DeprecationLevel.ERROR&quot;&gt;DeprecationLevel.ERROR&lt;/a&gt;), otherwise if the API version is greater or equal than &lt;a href=&quot;-deprecated-since-kotlin/warning-since#kotlin.DeprecatedSinceKotlin%24warningSince&quot;&gt;warningSince&lt;/a&gt;, the usage will be marked as a warning (as with &lt;a href=&quot;-deprecation-level/-w-a-r-n-i-n-g#kotlin.DeprecationLevel.WARNING&quot;&gt;DeprecationLevel.WARNING&lt;/a&gt;), otherwise the annotation is ignored.</source>
          <target state="translated">注釈付きの宣言を非推奨としてマークします。非&lt;a href=&quot;-deprecated/index#kotlin.Deprecated&quot;&gt;推奨&lt;/a&gt;とは対照的に、報告される診断の重大度は一定の値ではありませんが、使用法のAPIバージョン（使用法が配置されているモジュールをコンパイルするときの &lt;code&gt;-api-version&lt;/code&gt; 引数の値）によって異なります。 APIバージョンが&lt;a href=&quot;-deprecated-since-kotlin/hidden-since#kotlin.DeprecatedSinceKotlin%24hiddenSince&quot;&gt;hiddenSince&lt;/a&gt;以上の場合、宣言はコードからアクセスできません（レベル&lt;a href=&quot;-deprecation-level/-h-i-d-d-e-n#kotlin.DeprecationLevel.HIDDEN&quot;&gt;DeprecationLevel.HIDDENで&lt;/a&gt;非推奨になったかのように）。それ以外の場合、APIバージョンが&lt;a href=&quot;-deprecated-since-kotlin/error-since#kotlin.DeprecatedSinceKotlin%24errorSince&quot;&gt;errorSince&lt;/a&gt;以上の場合、使用量がマークされます。エラーとして（&lt;a href=&quot;-deprecation-level/-e-r-r-o-r#kotlin.DeprecationLevel.ERROR&quot;&gt;DeprecationLevel.ERRORと&lt;/a&gt;同様）、それ以外の場合、APIバージョンが&lt;a href=&quot;-deprecated-since-kotlin/warning-since#kotlin.DeprecatedSinceKotlin%24warningSince&quot;&gt;warningSince&lt;/a&gt;以上の場合、使用法は警告としてマークされます（&lt;a href=&quot;-deprecation-level/-w-a-r-n-i-n-g#kotlin.DeprecationLevel.WARNING&quot;&gt;DeprecationLevel.WARNINGと&lt;/a&gt;同様）。それ以外の場合、注釈は無視されます。</target>
        </trans-unit>
        <trans-unit id="80f9c066c4fb389bf5a2648a88b9da8d8a5af0b6" translate="yes" xml:space="preserve">
          <source>Marks the annotated declaration as deprecated. In contrast to &lt;a href=&quot;../-deprecated/index#kotlin.Deprecated&quot;&gt;Deprecated&lt;/a&gt;, severity of the reported diagnostic is not a constant value, but differs depending on the API version of the usage (the value of the &lt;code&gt;-api-version&lt;/code&gt; argument when compiling the module where the usage is located). If the API version is greater or equal than &lt;a href=&quot;../-deprecated-since-kotlin/hidden-since#kotlin.DeprecatedSinceKotlin%24hiddenSince&quot;&gt;hiddenSince&lt;/a&gt;, the declaration will not be accessible from the code (as if it was deprecated with level &lt;a href=&quot;../-deprecation-level/-h-i-d-d-e-n#kotlin.DeprecationLevel.HIDDEN&quot;&gt;DeprecationLevel.HIDDEN&lt;/a&gt;), otherwise if the API version is greater or equal than &lt;a href=&quot;../-deprecated-since-kotlin/error-since#kotlin.DeprecatedSinceKotlin%24errorSince&quot;&gt;errorSince&lt;/a&gt;, the usage will be marked as an error (as with &lt;a href=&quot;../-deprecation-level/-e-r-r-o-r#kotlin.DeprecationLevel.ERROR&quot;&gt;DeprecationLevel.ERROR&lt;/a&gt;), otherwise if the API version is greater or equal than &lt;a href=&quot;../-deprecated-since-kotlin/warning-since#kotlin.DeprecatedSinceKotlin%24warningSince&quot;&gt;warningSince&lt;/a&gt;, the usage will be marked as a warning (as with &lt;a href=&quot;../-deprecation-level/-w-a-r-n-i-n-g#kotlin.DeprecationLevel.WARNING&quot;&gt;DeprecationLevel.WARNING&lt;/a&gt;), otherwise the annotation is ignored.</source>
          <target state="translated">注釈付きの宣言を非推奨としてマークします。非&lt;a href=&quot;../-deprecated/index#kotlin.Deprecated&quot;&gt;推奨&lt;/a&gt;とは対照的に、報告される診断の重大度は一定の値ではありませんが、使用法のAPIバージョン（使用法が配置されているモジュールをコンパイルするときの &lt;code&gt;-api-version&lt;/code&gt; 引数の値）によって異なります。 APIバージョンが&lt;a href=&quot;../-deprecated-since-kotlin/hidden-since#kotlin.DeprecatedSinceKotlin%24hiddenSince&quot;&gt;hiddenSince&lt;/a&gt;以上の場合、宣言はコードからアクセスできません（レベル&lt;a href=&quot;../-deprecation-level/-h-i-d-d-e-n#kotlin.DeprecationLevel.HIDDEN&quot;&gt;DeprecationLevel.HIDDENで&lt;/a&gt;非推奨になったかのように）。それ以外の場合、APIバージョンが&lt;a href=&quot;../-deprecated-since-kotlin/error-since#kotlin.DeprecatedSinceKotlin%24errorSince&quot;&gt;errorSince&lt;/a&gt;以上の場合、使用量がマークされます。エラーとして（&lt;a href=&quot;../-deprecation-level/-e-r-r-o-r#kotlin.DeprecationLevel.ERROR&quot;&gt;DeprecationLevel.ERRORと&lt;/a&gt;同様）、それ以外の場合、APIバージョンが&lt;a href=&quot;../-deprecated-since-kotlin/warning-since#kotlin.DeprecatedSinceKotlin%24warningSince&quot;&gt;warningSince&lt;/a&gt;以上の場合、使用法は警告としてマークされます（&lt;a href=&quot;../-deprecation-level/-w-a-r-n-i-n-g#kotlin.DeprecationLevel.WARNING&quot;&gt;DeprecationLevel.WARNINGと&lt;/a&gt;同様）。それ以外の場合、注釈は無視されます。</target>
        </trans-unit>
        <trans-unit id="fdea1abd24e2fec8414716149ca5d119c8a1c72d" translate="yes" xml:space="preserve">
          <source>Marks the annotated declaration as deprecated. In contrast to &lt;a href=&quot;../-deprecated/index#kotlin.Deprecated&quot;&gt;Deprecated&lt;/a&gt;, severity of the reported diagnostic is not a constant value, but differs depending on the API version of the usage (the value of the &lt;code&gt;-api-version&lt;/code&gt; argument when compiling the module where the usage is located). If the API version is greater or equal than &lt;a href=&quot;hidden-since#kotlin.DeprecatedSinceKotlin%24hiddenSince&quot;&gt;hiddenSince&lt;/a&gt;, the declaration will not be accessible from the code (as if it was deprecated with level &lt;a href=&quot;../-deprecation-level/-h-i-d-d-e-n#kotlin.DeprecationLevel.HIDDEN&quot;&gt;DeprecationLevel.HIDDEN&lt;/a&gt;), otherwise if the API version is greater or equal than &lt;a href=&quot;error-since#kotlin.DeprecatedSinceKotlin%24errorSince&quot;&gt;errorSince&lt;/a&gt;, the usage will be marked as an error (as with &lt;a href=&quot;../-deprecation-level/-e-r-r-o-r#kotlin.DeprecationLevel.ERROR&quot;&gt;DeprecationLevel.ERROR&lt;/a&gt;), otherwise if the API version is greater or equal than &lt;a href=&quot;warning-since#kotlin.DeprecatedSinceKotlin%24warningSince&quot;&gt;warningSince&lt;/a&gt;, the usage will be marked as a warning (as with &lt;a href=&quot;../-deprecation-level/-w-a-r-n-i-n-g#kotlin.DeprecationLevel.WARNING&quot;&gt;DeprecationLevel.WARNING&lt;/a&gt;), otherwise the annotation is ignored.</source>
          <target state="translated">注釈付きの宣言を非推奨としてマークします。非&lt;a href=&quot;../-deprecated/index#kotlin.Deprecated&quot;&gt;推奨&lt;/a&gt;とは対照的に、報告された診断の重大度は一定の値ではありませんが、使用法のAPIバージョン（使用法が配置されているモジュールをコンパイルするときの &lt;code&gt;-api-version&lt;/code&gt; 引数の値）によって異なります。 APIバージョンが&lt;a href=&quot;hidden-since#kotlin.DeprecatedSinceKotlin%24hiddenSince&quot;&gt;hiddenSince&lt;/a&gt;以上の場合、宣言はコードからアクセスできません（レベル&lt;a href=&quot;../-deprecation-level/-h-i-d-d-e-n#kotlin.DeprecationLevel.HIDDEN&quot;&gt;DeprecationLevel.HIDDENで&lt;/a&gt;非推奨になったかのように）。それ以外の場合、APIバージョンが&lt;a href=&quot;error-since#kotlin.DeprecatedSinceKotlin%24errorSince&quot;&gt;errorSince&lt;/a&gt;以上の場合、使用量がマークされます。エラーとして（&lt;a href=&quot;../-deprecation-level/-e-r-r-o-r#kotlin.DeprecationLevel.ERROR&quot;&gt;DeprecationLevel.ERRORと&lt;/a&gt;同様）、それ以外の場合、APIバージョンが&lt;a href=&quot;warning-since#kotlin.DeprecatedSinceKotlin%24warningSince&quot;&gt;warningSince&lt;/a&gt;以上の場合、使用法は警告としてマークされます（&lt;a href=&quot;../-deprecation-level/-w-a-r-n-i-n-g#kotlin.DeprecationLevel.WARNING&quot;&gt;DeprecationLevel.WARNINGと&lt;/a&gt;同様）。それ以外の場合、注釈は無視されます。</target>
        </trans-unit>
        <trans-unit id="849bb03707fb20c75be09bfab7269367951a2e2c" translate="yes" xml:space="preserve">
          <source>MatchGroup</source>
          <target state="translated">MatchGroup</target>
        </trans-unit>
        <trans-unit id="dca62bbed6a25edcb571ec2b8d04d93aa72d3b21" translate="yes" xml:space="preserve">
          <source>MatchGroupCollection</source>
          <target state="translated">MatchGroupCollection</target>
        </trans-unit>
        <trans-unit id="40ee7a3cd8703b1f6d5c39fe97ef7bdbddff913a" translate="yes" xml:space="preserve">
          <source>MatchNamedGroupCollection</source>
          <target state="translated">MatchNamedGroupCollection</target>
        </trans-unit>
        <trans-unit id="e5e10479d7e48ed2ed4d8e1de8fc8b3e40fd01eb" translate="yes" xml:space="preserve">
          <source>MatchResult</source>
          <target state="translated">MatchResult</target>
        </trans-unit>
        <trans-unit id="3edf0df49942da6d11a1a217e4d3af4a5a8e64f2" translate="yes" xml:space="preserve">
          <source>Math</source>
          <target state="translated">Math</target>
        </trans-unit>
        <trans-unit id="386de788c6f8f526adcdfcc95893611a4f0f2a05" translate="yes" xml:space="preserve">
          <source>Math operations in kotlin-stdlib</source>
          <target state="translated">kotlin-stdlib での数学演算</target>
        </trans-unit>
        <trans-unit id="0ada0ff6418289ab78ea96388455f7b6c8654ca4" translate="yes" xml:space="preserve">
          <source>Mathematical functions and constants.</source>
          <target state="translated">数学的な関数と定数。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
