<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="kotlin">
    <body>
      <group id="kotlin">
        <trans-unit id="2e3cf95b689244eb673190f3f6791a8430eef505" translate="yes" xml:space="preserve">
          <source>To run tests, execute the standard lifecycle &lt;code&gt;check&lt;/code&gt; task:</source>
          <target state="translated">テストを実行するには、標準のライフサイクル &lt;code&gt;check&lt;/code&gt; タスクを実行します。</target>
        </trans-unit>
        <trans-unit id="58d7a0df7bd3a304f110999cd04f5328dff8bc19" translate="yes" xml:space="preserve">
          <source>To run the application, right-click somewhere in the main file and select &lt;strong&gt;Run As | Kotlin Application&lt;/strong&gt;.</source>
          <target state="translated">アプリケーションを実行するには、メインファイルのどこかを右クリックし、[ &lt;strong&gt;実行&lt;/strong&gt; ]、[ &lt;strong&gt;実行&lt;/strong&gt; ]の順に選択し&lt;strong&gt;ます。&lt;/strong&gt;&lt;strong&gt;Kotlinアプリケーション&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="307aa135f670640b026c3a84d1ad04d1025f9beb" translate="yes" xml:space="preserve">
          <source>To run the tests in the browser, we can execute the &lt;code&gt;browserTest&lt;/code&gt; task via IntelliJ IDEA, or use the gutter icons to execute all or individual tests:</source>
          <target state="translated">ブラウザでテストを実行するには、IntelliJ IDEAを介して &lt;code&gt;browserTest&lt;/code&gt; タスクを実行するか、ガターアイコンを使用してすべてまたは個別のテストを実行します。</target>
        </trans-unit>
        <trans-unit id="2e4d15311fa7cd994c8e9ce22c145ce856d694db" translate="yes" xml:space="preserve">
          <source>To save your course as a zip file, go to &lt;strong&gt;Course Creator -&amp;gt; Generate Course Archive&lt;/strong&gt; action. The generated archive can be opened via the &lt;strong&gt;Browse Courses&lt;/strong&gt; available from the &lt;strong&gt;Welcome Screen&lt;/strong&gt; and in the &lt;strong&gt;File Menu&lt;/strong&gt; with the &lt;strong&gt;Import Course&lt;/strong&gt; icon:</source>
          <target state="translated">コースをzipファイルとして保存するには、&lt;strong&gt;コースクリエーター-&amp;gt;コースアーカイブの生成&lt;/strong&gt;アクションに移動します。生成されたアーカイブは、&lt;strong&gt;ウェルカムセンター&lt;/strong&gt;から利用できる[ &lt;strong&gt;コース&lt;/strong&gt;の&lt;strong&gt;参照]&lt;/strong&gt;を介して、または&lt;strong&gt;[ファイル]メニューの[ &lt;/strong&gt;&lt;strong&gt;コース&lt;/strong&gt;の&lt;strong&gt;インポート&lt;/strong&gt; ]アイコンで開くことができます。&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="36a621d8894a43c60f62b88c51e7aa345450af8d" translate="yes" xml:space="preserve">
          <source>To search an element in a sorted list, call the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/binary-search&quot;&gt;&lt;code&gt;binarySearch()&lt;/code&gt;&lt;/a&gt; function passing the value as an argument. If such an element exists, the function returns its index; otherwise, it returns &lt;code&gt;(-insertionPoint - 1)&lt;/code&gt; where &lt;code&gt;insertionPoint&lt;/code&gt; is the index where this element should be inserted so that the list remains sorted. If there is more than one element with the given value, the search can return any of their indices.</source>
          <target state="translated">ソートされたリストの要素を検索するには、引数として値を渡して&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/binary-search&quot;&gt; &lt;code&gt;binarySearch()&lt;/code&gt; &lt;/a&gt;関数を呼び出します。そのような要素が存在する場合、関数はそのインデックスを返します。それ以外の場合は、 &lt;code&gt;(-insertionPoint - 1)&lt;/code&gt; 返します。ここで、 &lt;code&gt;insertionPoint&lt;/code&gt; は、リストがソートされたままになるようにこの要素を挿入する必要があるインデックスです。指定された値を持つ要素が複数ある場合、検索はそれらのインデックスのいずれかを返すことができます。</target>
        </trans-unit>
        <trans-unit id="bf705e6bade184c44c4ccccae5cda8a8acf3a41e" translate="yes" xml:space="preserve">
          <source>To see how we can express how elements in the DOM can be created and structured in a concise way, check out the the &lt;a href=&quot;typesafe-html-dsl&quot;&gt;Typesafe HTML DSL&lt;/a&gt;.</source>
          <target state="translated">DOM内の要素を簡潔に作成および構造化する方法を表現する方法を確認するには、&lt;a href=&quot;typesafe-html-dsl&quot;&gt;Typesafe HTMLDSLを&lt;/a&gt;確認してください。</target>
        </trans-unit>
        <trans-unit id="680ca05ae718e68cfb1629f08e49b399fcda4d93" translate="yes" xml:space="preserve">
          <source>To see the full Gradle script check out the source of the project on GitHub.</source>
          <target state="translated">Gradleスクリプトの全文を見るには、GitHubでプロジェクトのソースをチェックしてください。</target>
        </trans-unit>
        <trans-unit id="6bc22d1c45afda0ba0e9856d43874792a674530d" translate="yes" xml:space="preserve">
          <source>To select module kind, set the &lt;code&gt;moduleKind&lt;/code&gt; compiler option in the Gradle build script.</source>
          <target state="translated">モジュールの種類を選択するには、Gradleビルドスクリプトで &lt;code&gt;moduleKind&lt;/code&gt; コンパイラオプションを設定します。</target>
        </trans-unit>
        <trans-unit id="06d76d8df652a0954c4314eb6cd119fb4f22f648" translate="yes" xml:space="preserve">
          <source>To select module system when compiling via Gradle, you should set &lt;code&gt;moduleKind&lt;/code&gt; property, i.e.</source>
          <target state="translated">Gradle経由でコンパイルするときにモジュールシステムを選択するには、 &lt;code&gt;moduleKind&lt;/code&gt; プロパティを設定する必要があります。</target>
        </trans-unit>
        <trans-unit id="16681c84550456d5ff8bc73b03434df79d115f43" translate="yes" xml:space="preserve">
          <source>To select module system when compiling via Maven, you should set &lt;code&gt;moduleKind&lt;/code&gt; configuration property, i.e. your &lt;code&gt;pom.xml&lt;/code&gt; should look like this:</source>
          <target state="translated">Maven経由でコンパイルするときにモジュールシステムを選択するには、 &lt;code&gt;moduleKind&lt;/code&gt; 構成プロパティを設定する必要があります。つまり、 &lt;code&gt;pom.xml&lt;/code&gt; は次のようになります。</target>
        </trans-unit>
        <trans-unit id="45e994b1f4d37b99eaddc699cd613274dee03180" translate="yes" xml:space="preserve">
          <source>To set another location for project distribution files, add the &lt;code&gt;distribution&lt;/code&gt; block inside &lt;code&gt;browser&lt;/code&gt; in the build script and assign a value to the &lt;code&gt;directory&lt;/code&gt; property. Once you run a project build task, Gradle will save the output bundle in this location together with project resources.</source>
          <target state="translated">プロジェクト配布ファイルの別の場所を設定するには、ビルドスクリプトの &lt;code&gt;browser&lt;/code&gt; 内に &lt;code&gt;distribution&lt;/code&gt; ブロックを追加し、 &lt;code&gt;directory&lt;/code&gt; プロパティに値を割り当てます。プロジェクトビルドタスクを実行すると、Gradleは出力バンドルをプロジェクトリソースと一緒にこの場所に保存します。</target>
        </trans-unit>
        <trans-unit id="269c5e540e50596c2266b2737868df5485939c07" translate="yes" xml:space="preserve">
          <source>To set the desired level, specify the &lt;code&gt;level&lt;/code&gt; parameter of the &lt;code&gt;@RequiresOptIn&lt;/code&gt; annotation.</source>
          <target state="translated">目的のレベルを設定するには、 &lt;code&gt;@RequiresOptIn&lt;/code&gt; アノテーションの &lt;code&gt;level&lt;/code&gt; パラメーターを指定します。</target>
        </trans-unit>
        <trans-unit id="5dfb90c4357595726b2e826922df2d26c2c78269" translate="yes" xml:space="preserve">
          <source>To setup a multiplatform project from scratch in a Gradle project, first apply the &lt;code&gt;kotlin-multiplatform&lt;/code&gt; plugin to the project by adding the following to the beginning of the &lt;code&gt;build.gradle&lt;/code&gt; file:</source>
          <target state="translated">Gradleプロジェクトでマルチプラットフォームプロジェクトを最初からセットアップするには、最初に次の &lt;code&gt;kotlin-multiplatform&lt;/code&gt; &lt;code&gt;build.gradle&lt;/code&gt; ファイルの先頭に追加して、kotlin-multiplatformプラグインをプロジェクトに適用します。</target>
        </trans-unit>
        <trans-unit id="c7e47d17458659905c4f2f62bdab7488ae50c7a1" translate="yes" xml:space="preserve">
          <source>To skip automatic conversion and ensure raw pointers are used in the bindings, a &lt;code&gt;noStringConversion&lt;/code&gt; statement in the &lt;code&gt;.def&lt;/code&gt; file could be used, i.e.</source>
          <target state="translated">自動変換をスキップして、生のポインターがバインディングで使用されるようにするには、 &lt;code&gt;.def&lt;/code&gt; ファイルの &lt;code&gt;noStringConversion&lt;/code&gt; ステートメントを使用できます。</target>
        </trans-unit>
        <trans-unit id="db6bb94ddd68466610ca12cc204d3d3c6bd7dd12" translate="yes" xml:space="preserve">
          <source>To solve such issues, Kotlin introduces a special kind of class called an &lt;code&gt;inline class&lt;/code&gt;, which is declared by placing an &lt;code&gt;inline&lt;/code&gt; modifier before the name of the class:</source>
          <target state="translated">このような問題を解決するために、Kotlinは &lt;code&gt;inline class&lt;/code&gt; と呼ばれる特別な種類のクラスを導入しています。これは、クラスの名前の前に &lt;code&gt;inline&lt;/code&gt; 修飾子を配置することによって宣言されています。</target>
        </trans-unit>
        <trans-unit id="885ff03b6c597841318a22240c06f643cf1cd5fb" translate="yes" xml:space="preserve">
          <source>To solve this, mark the targets on both the library author and consumer sides with a custom attribute, which Gradle uses during dependency resolution.</source>
          <target state="translated">これを解決するには、ライブラリ作成者側と消費者側の両方でターゲットをカスタム属性でマークします。</target>
        </trans-unit>
        <trans-unit id="c6edca763e12c6292a414b20b65eaba5f53f467b" translate="yes" xml:space="preserve">
          <source>To specify a visibility of the primary constructor of a class, use the following syntax (note that you need to add an explicit &lt;em&gt;constructor&lt;/em&gt; keyword):</source>
          <target state="translated">クラスのプライマリコンストラクターの可視性を指定するには、次の構文を使用します（明示的な&lt;em&gt;コンストラクター&lt;/em&gt;キーワードを追加する必要があることに注意してください）。</target>
        </trans-unit>
        <trans-unit id="419bcc45449c9e2a7d1fb4c22599e33f123b758a" translate="yes" xml:space="preserve">
          <source>To specify additional compilation options, use the &lt;code&gt;kotlinOptions&lt;/code&gt; property of a Kotlin compilation task.</source>
          <target state="translated">追加のコンパイルオプションを指定するには、Kotlinコンパイルタスクの &lt;code&gt;kotlinOptions&lt;/code&gt; プロパティを使用します。</target>
        </trans-unit>
        <trans-unit id="0ac203e68342bc2b26ca6bd486204285a11e36be" translate="yes" xml:space="preserve">
          <source>To specify that a function type is &lt;a href=&quot;null-safety#nullable-types-and-non-null-types&quot;&gt;nullable&lt;/a&gt;, use parentheses: &lt;code&gt;((Int, Int) -&amp;gt; Int)?&lt;/code&gt;.</source>
          <target state="translated">関数タイプが&lt;a href=&quot;null-safety#nullable-types-and-non-null-types&quot;&gt;null可能&lt;/a&gt;であることを指定するには、括弧を使用します： &lt;code&gt;((Int, Int) -&amp;gt; Int)?&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fa582abf300c214133b85270789a22565f82393f" translate="yes" xml:space="preserve">
          <source>To start coroutine debugging, you just need to set breakpoints and run the application in debug mode.</source>
          <target state="translated">コアーチンデバッグを開始するには、ブレークポイントを設定して、デバッグモードでアプリケーションを実行するだけです。</target>
        </trans-unit>
        <trans-unit id="e57f72b9d262e6ee5d6ce2e784cc4119575a7e41" translate="yes" xml:space="preserve">
          <source>To start executing the created coroutine, invoke &lt;code&gt;resume(Unit)&lt;/code&gt; on the returned &lt;a href=&quot;-continuation/index&quot;&gt;Continuation&lt;/a&gt; instance. The &lt;a href=&quot;create-coroutine#kotlin.coroutines%24createCoroutine%28kotlin.coroutines.SuspendFunction0%28%28kotlin.coroutines.createCoroutine.T%29%29%2C+kotlin.coroutines.Continuation%28%28kotlin.coroutines.createCoroutine.T%29%29%29%2Fcompletion&quot;&gt;completion&lt;/a&gt; continuation is invoked when the coroutine completes with a result or an exception. Subsequent invocation of any resume function on the resulting continuation will produce an &lt;a href=&quot;../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt;.</source>
          <target state="translated">作成されたコルーチンの実行を開始するには、返された&lt;a href=&quot;-continuation/index&quot;&gt;継続&lt;/a&gt;インスタンスで &lt;code&gt;resume(Unit)&lt;/code&gt; を呼び出します。&lt;a href=&quot;create-coroutine#kotlin.coroutines%24createCoroutine%28kotlin.coroutines.SuspendFunction0%28%28kotlin.coroutines.createCoroutine.T%29%29%2C+kotlin.coroutines.Continuation%28%28kotlin.coroutines.createCoroutine.T%29%29%29%2Fcompletion&quot;&gt;完了&lt;/a&gt;継続がコルーチン結果または例外で完了したときに呼び出されます。結果の継続で再開関数を呼び出すと、&lt;a href=&quot;../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt;が発生します。</target>
        </trans-unit>
        <trans-unit id="29211ac1a181cd4bb3901bb410d7de3d38f88156" translate="yes" xml:space="preserve">
          <source>To start executing the created coroutine, invoke &lt;code&gt;resume(Unit)&lt;/code&gt; on the returned &lt;a href=&quot;-continuation/index&quot;&gt;Continuation&lt;/a&gt; instance. The &lt;a href=&quot;create-coroutine#kotlin.coroutines%24createCoroutine%28kotlin.coroutines.SuspendFunction1%28%28kotlin.coroutines.createCoroutine.R%2C+kotlin.coroutines.createCoroutine.T%29%29%2C+kotlin.coroutines.createCoroutine.R%2C+kotlin.coroutines.Continuation%28%28kotlin.coroutines.createCoroutine.T%29%29%29%2Fcompletion&quot;&gt;completion&lt;/a&gt; continuation is invoked when the coroutine completes with a result or an exception. Subsequent invocation of any resume function on the resulting continuation will produce an &lt;a href=&quot;../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt;.</source>
          <target state="translated">作成されたコルーチンの実行を開始するには、返された&lt;a href=&quot;-continuation/index&quot;&gt;継続&lt;/a&gt;インスタンスで &lt;code&gt;resume(Unit)&lt;/code&gt; を呼び出します。&lt;a href=&quot;create-coroutine#kotlin.coroutines%24createCoroutine%28kotlin.coroutines.SuspendFunction1%28%28kotlin.coroutines.createCoroutine.R%2C+kotlin.coroutines.createCoroutine.T%29%29%2C+kotlin.coroutines.createCoroutine.R%2C+kotlin.coroutines.Continuation%28%28kotlin.coroutines.createCoroutine.T%29%29%29%2Fcompletion&quot;&gt;完了&lt;/a&gt;継続がコルーチン結果または例外で完了したときに呼び出されます。結果の継続で再開関数を呼び出すと、&lt;a href=&quot;../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt;が発生します。</target>
        </trans-unit>
        <trans-unit id="93a4c159e45ae9b13567d12cfe549a89c643e81c" translate="yes" xml:space="preserve">
          <source>To start executing the created coroutine, invoke &lt;code&gt;resume(Unit)&lt;/code&gt; on the returned &lt;a href=&quot;-continuation/index&quot;&gt;Continuation&lt;/a&gt; instance. The &lt;a href=&quot;create-coroutine#kotlin.coroutines%24createCoroutine(kotlin.coroutines.SuspendFunction0((kotlin.coroutines.createCoroutine.T)),%20kotlin.coroutines.Continuation((kotlin.coroutines.createCoroutine.T)))/completion&quot;&gt;completion&lt;/a&gt; continuation is invoked when the coroutine completes with a result or an exception. Subsequent invocation of any resume function on the resulting continuation will produce an &lt;a href=&quot;../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt;.</source>
          <target state="translated">作成されたコルーチンの実行を開始するには、返された&lt;a href=&quot;-continuation/index&quot;&gt;Continuation&lt;/a&gt;インスタンスで &lt;code&gt;resume(Unit)&lt;/code&gt; を呼び出します。&lt;a href=&quot;create-coroutine#kotlin.coroutines%24createCoroutine(kotlin.coroutines.SuspendFunction0((kotlin.coroutines.createCoroutine.T)),%20kotlin.coroutines.Continuation((kotlin.coroutines.createCoroutine.T)))/completion&quot;&gt;完了&lt;/a&gt;継続がコルーチン結果または例外で完了したときに呼び出されます。結果の継続で再開関数を呼び出した後、&lt;a href=&quot;../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt;が生成されます。</target>
        </trans-unit>
        <trans-unit id="03689575e5ce0d05cb5875c63b25386ef2dc70ce" translate="yes" xml:space="preserve">
          <source>To start executing the created coroutine, invoke &lt;code&gt;resume(Unit)&lt;/code&gt; on the returned &lt;a href=&quot;-continuation/index&quot;&gt;Continuation&lt;/a&gt; instance. The &lt;a href=&quot;create-coroutine#kotlin.coroutines%24createCoroutine(kotlin.coroutines.SuspendFunction1((kotlin.coroutines.createCoroutine.R,%20kotlin.coroutines.createCoroutine.T)),%20kotlin.coroutines.createCoroutine.R,%20kotlin.coroutines.Continuation((kotlin.coroutines.createCoroutine.T)))/completion&quot;&gt;completion&lt;/a&gt; continuation is invoked when the coroutine completes with a result or an exception. Subsequent invocation of any resume function on the resulting continuation will produce an &lt;a href=&quot;../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt;.</source>
          <target state="translated">作成されたコルーチンの実行を開始するには、返された&lt;a href=&quot;-continuation/index&quot;&gt;Continuation&lt;/a&gt;インスタンスで &lt;code&gt;resume(Unit)&lt;/code&gt; を呼び出します。&lt;a href=&quot;create-coroutine#kotlin.coroutines%24createCoroutine(kotlin.coroutines.SuspendFunction1((kotlin.coroutines.createCoroutine.R,%20kotlin.coroutines.createCoroutine.T)),%20kotlin.coroutines.createCoroutine.R,%20kotlin.coroutines.Continuation((kotlin.coroutines.createCoroutine.T)))/completion&quot;&gt;完了&lt;/a&gt;継続がコルーチン結果または例外で完了したときに呼び出されます。結果の継続で再開関数を呼び出した後、&lt;a href=&quot;../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt;が生成されます。</target>
        </trans-unit>
        <trans-unit id="b715c677cb96aa31e520707c8bf7a084527dde6c" translate="yes" xml:space="preserve">
          <source>To start executing the created coroutine, invoke &lt;code&gt;resume(Unit)&lt;/code&gt; on the returned &lt;a href=&quot;-continuation/index&quot;&gt;Continuation&lt;/a&gt; instance. The &lt;a href=&quot;create-coroutine#kotlin.coroutines.experimental%24createCoroutine%28kotlin.coroutines.SuspendFunction0%28%28kotlin.coroutines.experimental.createCoroutine.T%29%29%2C+kotlin.coroutines.experimental.Continuation%28%28kotlin.coroutines.experimental.createCoroutine.T%29%29%29%2Fcompletion&quot;&gt;completion&lt;/a&gt; continuation is invoked when coroutine completes with result or exception. Repeated invocation of any resume function on the resulting continuation produces &lt;a href=&quot;../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt;.</source>
          <target state="translated">作成されたコルーチンの実行を開始するには、返された&lt;a href=&quot;-continuation/index&quot;&gt;継続&lt;/a&gt;インスタンスで &lt;code&gt;resume(Unit)&lt;/code&gt; を呼び出します。&lt;a href=&quot;create-coroutine#kotlin.coroutines.experimental%24createCoroutine%28kotlin.coroutines.SuspendFunction0%28%28kotlin.coroutines.experimental.createCoroutine.T%29%29%2C+kotlin.coroutines.experimental.Continuation%28%28kotlin.coroutines.experimental.createCoroutine.T%29%29%29%2Fcompletion&quot;&gt;完成&lt;/a&gt;コルーチンが結果または例外で終了したときに継続が呼び出されます。結果の継続で再開関数を繰り返し呼び出すと、&lt;a href=&quot;../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateExceptionが発生し&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="7ae9d4ba7899cbe4180b0d690d30390847f2291f" translate="yes" xml:space="preserve">
          <source>To start executing the created coroutine, invoke &lt;code&gt;resume(Unit)&lt;/code&gt; on the returned &lt;a href=&quot;-continuation/index&quot;&gt;Continuation&lt;/a&gt; instance. The &lt;a href=&quot;create-coroutine#kotlin.coroutines.experimental%24createCoroutine%28kotlin.coroutines.SuspendFunction1%28%28kotlin.coroutines.experimental.createCoroutine.R%2C+kotlin.coroutines.experimental.createCoroutine.T%29%29%2C+kotlin.coroutines.experimental.createCoroutine.R%2C+kotlin.coroutines.experimental.Continuation%28%28kotlin.coroutines.experimental.createCoroutine.T%29%29%29%2Fcompletion&quot;&gt;completion&lt;/a&gt; continuation is invoked when coroutine completes with result or exception. Repeated invocation of any resume function on the resulting continuation produces &lt;a href=&quot;../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt;.</source>
          <target state="translated">作成されたコルーチンの実行を開始するには、返された&lt;a href=&quot;-continuation/index&quot;&gt;継続&lt;/a&gt;インスタンスで &lt;code&gt;resume(Unit)&lt;/code&gt; を呼び出します。&lt;a href=&quot;create-coroutine#kotlin.coroutines.experimental%24createCoroutine%28kotlin.coroutines.SuspendFunction1%28%28kotlin.coroutines.experimental.createCoroutine.R%2C+kotlin.coroutines.experimental.createCoroutine.T%29%29%2C+kotlin.coroutines.experimental.createCoroutine.R%2C+kotlin.coroutines.experimental.Continuation%28%28kotlin.coroutines.experimental.createCoroutine.T%29%29%29%2Fcompletion&quot;&gt;完成&lt;/a&gt;コルーチンが結果または例外で終了したときに継続が呼び出されます。結果の継続で再開関数を繰り返し呼び出すと、&lt;a href=&quot;../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateExceptionが発生し&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="dfc6df82451691b1971099e0817380884cac3aec" translate="yes" xml:space="preserve">
          <source>To start executing the created coroutine, invoke &lt;code&gt;resume(Unit)&lt;/code&gt; on the returned Continuation instance. The &lt;a href=&quot;create-coroutine-unchecked#kotlin.coroutines.experimental.intrinsics%24createCoroutineUnchecked%28kotlin.coroutines.SuspendFunction0%28%28kotlin.coroutines.experimental.intrinsics.createCoroutineUnchecked.T%29%29%2C+kotlin.coroutines.experimental.Continuation%28%28kotlin.coroutines.experimental.intrinsics.createCoroutineUnchecked.T%29%29%29%2Fcompletion&quot;&gt;completion&lt;/a&gt; continuation is invoked when coroutine completes with result or exception.</source>
          <target state="translated">作成されたコルーチンの実行を開始するには、返された継続インスタンスで &lt;code&gt;resume(Unit)&lt;/code&gt; を呼び出します。&lt;a href=&quot;create-coroutine-unchecked#kotlin.coroutines.experimental.intrinsics%24createCoroutineUnchecked%28kotlin.coroutines.SuspendFunction0%28%28kotlin.coroutines.experimental.intrinsics.createCoroutineUnchecked.T%29%29%2C+kotlin.coroutines.experimental.Continuation%28%28kotlin.coroutines.experimental.intrinsics.createCoroutineUnchecked.T%29%29%29%2Fcompletion&quot;&gt;完成&lt;/a&gt;コルーチンが結果または例外で終了したときに継続が呼び出されます。</target>
        </trans-unit>
        <trans-unit id="e102b42121057a6878b15b2e0b7a9abdd7059c88" translate="yes" xml:space="preserve">
          <source>To start executing the created coroutine, invoke &lt;code&gt;resume(Unit)&lt;/code&gt; on the returned Continuation instance. The &lt;a href=&quot;create-coroutine-unchecked#kotlin.coroutines.experimental.intrinsics%24createCoroutineUnchecked%28kotlin.coroutines.SuspendFunction1%28%28kotlin.coroutines.experimental.intrinsics.createCoroutineUnchecked.R%2C+kotlin.coroutines.experimental.intrinsics.createCoroutineUnchecked.T%29%29%2C+kotlin.coroutines.experimental.intrinsics.createCoroutineUnchecked.R%2C+kotlin.coroutines.experimental.Continuation%28%28kotlin.coroutines.experimental.intrinsics.createCoroutineUnchecked.T%29%29%29%2Fcompletion&quot;&gt;completion&lt;/a&gt; continuation is invoked when coroutine completes with result or exception.</source>
          <target state="translated">作成されたコルーチンの実行を開始するには、返された継続インスタンスで &lt;code&gt;resume(Unit)&lt;/code&gt; を呼び出します。&lt;a href=&quot;create-coroutine-unchecked#kotlin.coroutines.experimental.intrinsics%24createCoroutineUnchecked%28kotlin.coroutines.SuspendFunction1%28%28kotlin.coroutines.experimental.intrinsics.createCoroutineUnchecked.R%2C+kotlin.coroutines.experimental.intrinsics.createCoroutineUnchecked.T%29%29%2C+kotlin.coroutines.experimental.intrinsics.createCoroutineUnchecked.R%2C+kotlin.coroutines.experimental.Continuation%28%28kotlin.coroutines.experimental.intrinsics.createCoroutineUnchecked.T%29%29%29%2Fcompletion&quot;&gt;完成&lt;/a&gt;コルーチンが結果または例外で終了したときに継続が呼び出されます。</target>
        </trans-unit>
        <trans-unit id="a74d51560d5c774d1a56f8d84a208e43206f3604" translate="yes" xml:space="preserve">
          <source>To start executing the created coroutine, invoke &lt;code&gt;resume(Unit)&lt;/code&gt; on the returned Continuation instance. The &lt;a href=&quot;create-coroutine-unintercepted#kotlin.coroutines.intrinsics%24createCoroutineUnintercepted%28kotlin.coroutines.SuspendFunction0%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%2C+kotlin.coroutines.Continuation%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%29%2Fcompletion&quot;&gt;completion&lt;/a&gt; continuation is invoked when coroutine completes with result or exception.</source>
          <target state="translated">作成されたコルーチンの実行を開始するには、返された継続インスタンスで &lt;code&gt;resume(Unit)&lt;/code&gt; を呼び出します。&lt;a href=&quot;create-coroutine-unintercepted#kotlin.coroutines.intrinsics%24createCoroutineUnintercepted%28kotlin.coroutines.SuspendFunction0%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%2C+kotlin.coroutines.Continuation%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%29%2Fcompletion&quot;&gt;完成&lt;/a&gt;コルーチンが結果または例外で終了したときに継続が呼び出されます。</target>
        </trans-unit>
        <trans-unit id="aa80d28b000c404e7e7471739dc834ced4e443ec" translate="yes" xml:space="preserve">
          <source>To start executing the created coroutine, invoke &lt;code&gt;resume(Unit)&lt;/code&gt; on the returned Continuation instance. The &lt;a href=&quot;create-coroutine-unintercepted#kotlin.coroutines.intrinsics%24createCoroutineUnintercepted%28kotlin.coroutines.SuspendFunction1%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.R%2C+kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%2C+kotlin.coroutines.intrinsics.createCoroutineUnintercepted.R%2C+kotlin.coroutines.Continuation%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%29%2Fcompletion&quot;&gt;completion&lt;/a&gt; continuation is invoked when coroutine completes with result or exception.</source>
          <target state="translated">作成されたコルーチンの実行を開始するには、返された継続インスタンスで &lt;code&gt;resume(Unit)&lt;/code&gt; を呼び出します。&lt;a href=&quot;create-coroutine-unintercepted#kotlin.coroutines.intrinsics%24createCoroutineUnintercepted%28kotlin.coroutines.SuspendFunction1%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.R%2C+kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%2C+kotlin.coroutines.intrinsics.createCoroutineUnintercepted.R%2C+kotlin.coroutines.Continuation%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%29%2Fcompletion&quot;&gt;完成&lt;/a&gt;コルーチンが結果または例外で終了したときに継続が呼び出されます。</target>
        </trans-unit>
        <trans-unit id="107268b53cdccea4df633455aa08e9eb59213796" translate="yes" xml:space="preserve">
          <source>To start executing the created coroutine, invoke &lt;code&gt;resume(Unit)&lt;/code&gt; on the returned Continuation instance. The &lt;a href=&quot;create-coroutine-unintercepted#kotlin.coroutines.intrinsics%24createCoroutineUnintercepted(kotlin.coroutines.SuspendFunction0((kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T)),%20kotlin.coroutines.Continuation((kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T)))/completion&quot;&gt;completion&lt;/a&gt; continuation is invoked when coroutine completes with result or exception.</source>
          <target state="translated">作成されたコルーチンの実行を開始するには、返されたContinuationインスタンスで &lt;code&gt;resume(Unit)&lt;/code&gt; を呼び出します。&lt;a href=&quot;create-coroutine-unintercepted#kotlin.coroutines.intrinsics%24createCoroutineUnintercepted(kotlin.coroutines.SuspendFunction0((kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T)),%20kotlin.coroutines.Continuation((kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T)))/completion&quot;&gt;完成&lt;/a&gt;コルーチンが結果または例外で終了したときに継続が呼び出されます。</target>
        </trans-unit>
        <trans-unit id="15c18083bec73d38fe935b18a61bfb26719f41fa" translate="yes" xml:space="preserve">
          <source>To start executing the created coroutine, invoke &lt;code&gt;resume(Unit)&lt;/code&gt; on the returned Continuation instance. The &lt;a href=&quot;create-coroutine-unintercepted#kotlin.coroutines.intrinsics%24createCoroutineUnintercepted(kotlin.coroutines.SuspendFunction1((kotlin.coroutines.intrinsics.createCoroutineUnintercepted.R,%20kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T)),%20kotlin.coroutines.intrinsics.createCoroutineUnintercepted.R,%20kotlin.coroutines.Continuation((kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T)))/completion&quot;&gt;completion&lt;/a&gt; continuation is invoked when coroutine completes with result or exception.</source>
          <target state="translated">作成されたコルーチンの実行を開始するには、返されたContinuationインスタンスで &lt;code&gt;resume(Unit)&lt;/code&gt; を呼び出します。&lt;a href=&quot;create-coroutine-unintercepted#kotlin.coroutines.intrinsics%24createCoroutineUnintercepted(kotlin.coroutines.SuspendFunction1((kotlin.coroutines.intrinsics.createCoroutineUnintercepted.R,%20kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T)),%20kotlin.coroutines.intrinsics.createCoroutineUnintercepted.R,%20kotlin.coroutines.Continuation((kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T)))/completion&quot;&gt;完成&lt;/a&gt;コルーチンが結果または例外で終了したときに継続が呼び出されます。</target>
        </trans-unit>
        <trans-unit id="e2482fe90c75c3748aeac1be942111f81e932b33" translate="yes" xml:space="preserve">
          <source>To start the course, go to &lt;strong&gt;View -&amp;gt; Tool Windows -&amp;gt; Project&lt;/strong&gt;. You will find a course plan, the list of lessons. Every lesson has a set of tasks and code exercises you need to solve. Start with the very first one:</source>
          <target state="translated">コースを開始するには、&lt;strong&gt;[表示]-&amp;gt; [ツールウィンドウ]-&amp;gt; [プロジェクト]&lt;/strong&gt;に移動し&lt;strong&gt;ます&lt;/strong&gt;。あなたはコースプラン、レッスンのリストを見つけるでしょう。すべてのレッスンには、解決する必要がある一連のタスクとコード演習があります。最初のものから始めます：</target>
        </trans-unit>
        <trans-unit id="af4a3359bcc2d8aaecee721a7eaa5358429907bb" translate="yes" xml:space="preserve">
          <source>To start using Kotlin for JavaScript, please refer to the &lt;a href=&quot;js-project-setup&quot;&gt;Setting up a Kotlin/JS project&lt;/a&gt;, or pick a hands-on lab from the next section to work through.</source>
          <target state="translated">Kotlin for JavaScriptの使用を開始&lt;a href=&quot;js-project-setup&quot;&gt;するには、Kotlin / JSプロジェクトのセットアップ&lt;/a&gt;を参照するか、次のセクションからハンズオンラボを選択して作業してください。</target>
        </trans-unit>
        <trans-unit id="5f3ceec14c1433cf322f7865c09a18312ccb1945" translate="yes" xml:space="preserve">
          <source>To start with, we'll need a Microsoft Visual C++ compiler installed that supports a x64_64 target. The easiest way to do this is to have a version of Microsoft Visual Studio installed on a Windows machine.</source>
          <target state="translated">手始めに、x64_64 ターゲットをサポートする Microsoft Visual C++コンパイラがインストールされている必要があります。これを行う最も簡単な方法は、Windows マシンに Microsoft Visual Studio のバージョンがインストールされていることです。</target>
        </trans-unit>
        <trans-unit id="66185b084e5432ac45a03abd883161f880e5f11e" translate="yes" xml:space="preserve">
          <source>To switch to the old behavior, pass the fallback flag &lt;code&gt;-Xno-receiver-assertions&lt;/code&gt; to the compiler.</source>
          <target state="translated">以前の動作に切り替えるには、フォールバックフラグ &lt;code&gt;-Xno-receiver-assertions&lt;/code&gt; をコンパイラに渡します。</target>
        </trans-unit>
        <trans-unit id="cc3b8fe9e3a75acdfca2d542f5fc3f0b9c8e0c32" translate="yes" xml:space="preserve">
          <source>To switch to the old smart casts behavior, pass the fallback flag &lt;code&gt;-Xlegacy-smart-cast-after-try&lt;/code&gt; as the compiler argument. It will become deprecated in Kotlin 1.3.</source>
          <target state="translated">古いスマートキャストの動作に切り替えるには、コンパイラー引数としてフォールバックフラグ &lt;code&gt;-Xlegacy-smart-cast-after-try&lt;/code&gt; を渡します。Kotlin 1.3では非推奨になる予定です。</target>
        </trans-unit>
        <trans-unit id="526447430819405af6d133c6984847835417ebe8" translate="yes" xml:space="preserve">
          <source>To symbolicate addresses in Kotlin code (e.g. for stack trace elements corresponding to Kotlin code) &lt;code&gt;.dSYM&lt;/code&gt; bundle for Kotlin code is required.</source>
          <target state="translated">Kotlinコードでアドレスをシンボリック化するには（たとえば、Kotlinコードに対応するスタックトレース要素の場合）、Kotlinコードの &lt;code&gt;.dSYM&lt;/code&gt; バンドルが必要です。</target>
        </trans-unit>
        <trans-unit id="3ee56f12e381a099c59880a6823066a60e9d50df" translate="yes" xml:space="preserve">
          <source>To take all the elements except a given number of first or last elements, call the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/drop&quot;&gt;&lt;code&gt;drop()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/drop-last&quot;&gt;&lt;code&gt;dropLast()&lt;/code&gt;&lt;/a&gt; functions respectively.</source>
          <target state="translated">指定された数の最初または最後の要素を除くすべての要素を取得するには、それぞれ&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/drop&quot;&gt; &lt;code&gt;drop()&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/drop-last&quot;&gt; &lt;code&gt;dropLast()&lt;/code&gt; &lt;/a&gt;関数を呼び出します。</target>
        </trans-unit>
        <trans-unit id="27b36af5861b299fc805f783568e62a3fc319e12" translate="yes" xml:space="preserve">
          <source>To target the JVM, apply the Kotlin JVM plugin.</source>
          <target state="translated">JVMをターゲットにするには、Kotlin JVMプラグインを適用します。</target>
        </trans-unit>
        <trans-unit id="ca844ba87cff8c023079c9be62782b3a3fde8a97" translate="yes" xml:space="preserve">
          <source>To target the JVM, apply the Kotlin JVM plugin. Starting with Kotlin 1.1.1, the plugin can be applied using the &lt;a href=&quot;https://docs.gradle.org/current/userguide/plugins.html#sec:plugins_block&quot;&gt;Gradle plugins DSL&lt;/a&gt;:</source>
          <target state="translated">JVMをターゲットにするには、Kotlin JVMプラグインを適用します。Kotlin 1.1.1以降、プラグインは&lt;a href=&quot;https://docs.gradle.org/current/userguide/plugins.html#sec:plugins_block&quot;&gt;GradleプラグインDSL&lt;/a&gt;を使用して適用できます。</target>
        </trans-unit>
        <trans-unit id="089288f0ea4e442474ea533e687f95ceb53b919e" translate="yes" xml:space="preserve">
          <source>To tell Kotlin that a certain declaration is written in pure JavaScript, you should mark it with &lt;code&gt;external&lt;/code&gt; modifier. When the compiler sees such a declaration, it assumes that the implementation for the corresponding class, function or property is provided by the developer, and therefore does not try to generate any JavaScript code from the declaration. This means that you should omit bodies of &lt;code&gt;external&lt;/code&gt; declarations. For example:</source>
          <target state="translated">特定の宣言が純粋なJavaScriptで記述されていることをKotlinに伝えるには、 &lt;code&gt;external&lt;/code&gt; 修飾子でそれをマークする必要があります。コンパイラーがこのような宣言を見ると、対応するクラス、関数、またはプロパティーの実装が開発者によって提供されていると想定しているため、宣言からJavaScriptコードを生成しようとしません。これは、 &lt;code&gt;external&lt;/code&gt; 宣言の本文を省略する必要があることを意味します。例えば：</target>
        </trans-unit>
        <trans-unit id="c054ec329a7a56272832fde51ee7e82f8f4336b8" translate="yes" xml:space="preserve">
          <source>To tell Kotlin that a certain declaration is written in pure JavaScript, you should mark it with the &lt;code&gt;external&lt;/code&gt; modifier. When the compiler sees such a declaration, it assumes that the implementation for the corresponding class, function or property is provided externally (by the developer or via an &lt;a href=&quot;js-project-setup#npm-dependencies&quot;&gt;npm dependency&lt;/a&gt;), and therefore does not try to generate any JavaScript code from the declaration. This is also why &lt;code&gt;external&lt;/code&gt; declarations can't have a body. For example:</source>
          <target state="translated">特定の宣言が純粋なJavaScriptで記述されていることをKotlinに伝えるには、 &lt;code&gt;external&lt;/code&gt; 修飾子でマークを付ける必要があります。コンパイラーはそのような宣言を見ると、対応するクラス、関数、またはプロパティの実装が外部から（開発者によって、または&lt;a href=&quot;js-project-setup#npm-dependencies&quot;&gt;npm依存関係&lt;/a&gt;を介して）提供されていると想定するため、宣言からJavaScriptコードを生成しようとはしません。これは、 &lt;code&gt;external&lt;/code&gt; 宣言に本文を含めることができない理由でもあります。例えば：</target>
        </trans-unit>
        <trans-unit id="13b684242eb1261a088744c1edd0d98430ef5246" translate="yes" xml:space="preserve">
          <source>To tell Kotlin that an &lt;code&gt;external&lt;/code&gt; class, package, function or property is a JavaScript module, you can use &lt;code&gt;@JsModule&lt;/code&gt; annotation. Consider you have the following CommonJS module called &quot;hello&quot;:</source>
          <target state="translated">&lt;code&gt;external&lt;/code&gt; クラス、パッケージ、関数、またはプロパティがJavaScriptモジュールであることをKotlinに伝えるには、 &lt;code&gt;@JsModule&lt;/code&gt; アノテーションを使用できます。「hello」という次のCommonJSモジュールがあるとします。</target>
        </trans-unit>
        <trans-unit id="9709dd3d7713138256dbb958ab241135af68f988" translate="yes" xml:space="preserve">
          <source>To test it, we'll use a simple async function that resolves to a specified string after a specified time:</source>
          <target state="translated">これをテストするために、指定した時間後に指定した文字列に解決するシンプルな非同期関数を使用します。</target>
        </trans-unit>
        <trans-unit id="1b99a15ae02c59db4c41dbf465be5149eb5f7541" translate="yes" xml:space="preserve">
          <source>To throw an exception object, use the &lt;em&gt;throw&lt;/em&gt;-expression:</source>
          <target state="translated">例外オブジェクトをスローするには、&lt;em&gt;throw&lt;/em&gt; -expressionを使用します。</target>
        </trans-unit>
        <trans-unit id="c7a0e8b8a829212ce4bf38fa9f7e144c221c0093" translate="yes" xml:space="preserve">
          <source>To turn off DCE completely, use the &lt;code&gt;devMode&lt;/code&gt; option in the &lt;code&gt;dceTask&lt;/code&gt;:</source>
          <target state="translated">完全にDCEオフにするには、使用し &lt;code&gt;devMode&lt;/code&gt; でオプション &lt;code&gt;dceTask&lt;/code&gt; を：</target>
        </trans-unit>
        <trans-unit id="e5d84f46ddf483c214d924898fdd70375c5841ef" translate="yes" xml:space="preserve">
          <source>To turn on CSS support in your project, set the &lt;code&gt;cssSupport.enabled&lt;/code&gt; flag in the Gradle build file for &lt;code&gt;webpackTask&lt;/code&gt;, &lt;code&gt;runTask&lt;/code&gt;, and &lt;code&gt;testTask&lt;/code&gt; respectively. This configuration is also enabled by default when creating a new project using the wizard.</source>
          <target state="translated">プロジェクトでCSSのサポートをオンにするには、設定 &lt;code&gt;cssSupport.enabled&lt;/code&gt; 用のGradleビルドファイルにフラグを &lt;code&gt;webpackTask&lt;/code&gt; 、 &lt;code&gt;runTask&lt;/code&gt; 、および &lt;code&gt;testTask&lt;/code&gt; それぞれ。この構成は、ウィザードを使用して新しいプロジェクトを作成するときにもデフォルトで有効になっています。</target>
        </trans-unit>
        <trans-unit id="374704e123399146f9a10acdf418e1645171dca5" translate="yes" xml:space="preserve">
          <source>To unwrap the reference:</source>
          <target state="translated">リファレンスのラップを解除します。</target>
        </trans-unit>
        <trans-unit id="a91c18bfe059c0da75a37ebc4ffaf3efe0d2e769" translate="yes" xml:space="preserve">
          <source>To unzip a list of pairs, call &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/unzip&quot;&gt;&lt;code&gt;unzip()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">ペアのリストを解凍するには、&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/unzip&quot;&gt; &lt;code&gt;unzip()&lt;/code&gt; を&lt;/a&gt;呼び出します。</target>
        </trans-unit>
        <trans-unit id="2a0e0cb040b2c181af6e3ea61de668187d10e532" translate="yes" xml:space="preserve">
          <source>To use a property, simply refer to it by name:</source>
          <target state="translated">プロパティを使用するには、単に名前で参照します。</target>
        </trans-unit>
        <trans-unit id="d8bf5ffe82f149520490d0887cef3348767dda39" translate="yes" xml:space="preserve">
          <source>To use a property, we simply refer to it by name, as if it were a field in Java:</source>
          <target state="translated">プロパティを使用するには、Javaのフィールドであるかのように、単に名前で参照します。</target>
        </trans-unit>
        <trans-unit id="f72769e7770abb5ce6cba411b555a198f8e3b8fb" translate="yes" xml:space="preserve">
          <source>To use an API that requires opt-in in all functions and classes in a file, add the file-level annotation &lt;code&gt;@file:OptIn&lt;/code&gt; to the top of the file before the package specification and imports.</source>
          <target state="translated">ファイル内のすべての関数とクラスでオプトインを必要とするAPIを使用するには、パッケージを指定してインポートする前に、ファイルレベルのアノテーション &lt;code&gt;@file:OptIn&lt;/code&gt; をファイルの先頭に追加します。</target>
        </trans-unit>
        <trans-unit id="213ffc2b7aa1496be9528a577f9f8df930989d35" translate="yes" xml:space="preserve">
          <source>To use an EAP build instead, we need to specify its version in &lt;code&gt;ext.kotlin_version&lt;/code&gt; and add the corresponding repository to the &lt;code&gt;buildscript&lt;/code&gt; section (usually EAP builds are located on &lt;a href=&quot;https://bintray.com/kotlin&quot;&gt;Bintray&lt;/a&gt;)</source>
          <target state="translated">代わりにEAPビルドを使用するには、 &lt;code&gt;ext.kotlin_version&lt;/code&gt; でそのバージョンを指定し、対応するリポジトリを &lt;code&gt;buildscript&lt;/code&gt; セクションに追加する必要があります（通常、EAPビルドは&lt;a href=&quot;https://bintray.com/kotlin&quot;&gt;Bintrayにあります&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="95905a2dc80cd98916ed0f8c91572f9ae392d28e" translate="yes" xml:space="preserve">
          <source>To use an experimental API in all functions and classes in a file, add the file-level annotation &lt;code&gt;@file:UseExperimental&lt;/code&gt; to the top of the file before the package specification and imports.</source>
          <target state="translated">ファイル内のすべての関数とクラスで試験的なAPIを使用するには、ファイル仕様のアノテーション &lt;code&gt;@file:UseExperimental&lt;/code&gt; をファイルの先頭に追加してから、パッケージを指定してインポートします。</target>
        </trans-unit>
        <trans-unit id="c7911ada2a93fd834ce5409496ee220d5914c628" translate="yes" xml:space="preserve">
          <source>To use classes or functions from a project in a scratch, import them into the scratch file as usual with the &lt;code&gt;import&lt;/code&gt; statement. Then write your code and run it with the appropriate module selected in &lt;strong&gt;Use classpath of module&lt;/strong&gt; list.</source>
          <target state="translated">プロジェクトのクラスまたは関数をスクラッチで使用するには、通常どおり &lt;code&gt;import&lt;/code&gt; ステートメントを使用してそれらをスクラッチファイルにインポートします。次に、コードを記述し、[&lt;strong&gt;モジュール&lt;/strong&gt;リストの&lt;strong&gt;クラスパスを使用]で&lt;/strong&gt;選択した適切なモジュールを&lt;strong&gt;使用&lt;/strong&gt;して実行し&lt;strong&gt;ます&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="905c85d4c4dbeeb5849e639296b6ff9051d12bf0" translate="yes" xml:space="preserve">
          <source>To use classes or functions from a project in the scratch, import them into the scratch file as usual with the &lt;code&gt;import&lt;/code&gt; statement. Then write your code and run it with the appropriate module selected in &lt;strong&gt;Use classpath of module&lt;/strong&gt; list. To rebuild the module automatically before running the scratch, select &lt;strong&gt;Make before Run&lt;/strong&gt;.</source>
          <target state="translated">プロジェクトのクラスまたは関数を最初から使用するには、 &lt;code&gt;import&lt;/code&gt; ステートメントを使用して、通常どおりそれらをスクラッチファイルにインポートします。次に、コードを記述して、&lt;strong&gt;「モジュール&lt;/strong&gt;リストの&lt;strong&gt;クラスパスを使用する」で&lt;/strong&gt;選択された適切なモジュールで実行し&lt;strong&gt;ます&lt;/strong&gt;。スクラッチを実行する前にモジュールを自動的に再構築するには、[ &lt;strong&gt;実行前に実行]を&lt;/strong&gt;選択し&lt;strong&gt;ます&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="5befb1fd889ec3d540fc6857e1cc44328178daf4" translate="yes" xml:space="preserve">
          <source>To use different modes for the same project, use &lt;code&gt;cssSupport.rules&lt;/code&gt;. Here, you can specify a list of &lt;code&gt;KotlinWebpackCssRules&lt;/code&gt;, each of which define a mode, as well as &lt;a href=&quot;https://webpack.js.org/configuration/module/#ruleinclude&quot;&gt;include&lt;/a&gt; and &lt;a href=&quot;https://webpack.js.org/configuration/module/#ruleexclude&quot;&gt;exclude&lt;/a&gt; patterns.</source>
          <target state="translated">同じプロジェクトで異なるモードを使用するには、 &lt;code&gt;cssSupport.rules&lt;/code&gt; を使用します。ここでは、 &lt;code&gt;KotlinWebpackCssRules&lt;/code&gt; のリストを指定できます。各リストはモードを定義し、パターンを&lt;a href=&quot;https://webpack.js.org/configuration/module/#ruleinclude&quot;&gt;含め&lt;/a&gt;たり&lt;a href=&quot;https://webpack.js.org/configuration/module/#ruleexclude&quot;&gt;除外したりし&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="7e6f898d3fd804cbaaa8f5e41eecb4b87b3f095b" translate="yes" xml:space="preserve">
          <source>To use it with Kotlin configure annotation processing dependency using &lt;code&gt;kapt&lt;/code&gt;:</source>
          <target state="translated">Kotlinで使用するには、 &lt;code&gt;kapt&lt;/code&gt; を使用してアノテーション処理の依存関係を構成します。</target>
        </trans-unit>
        <trans-unit id="6b18f46b3a0f449d7eb395f93e2e99d2ceb07f22" translate="yes" xml:space="preserve">
          <source>To use reflection in a Gradle or Maven project, add the dependency on &lt;code&gt;kotlin-reflect&lt;/code&gt;:</source>
          <target state="translated">GradleまたはMavenプロジェクトでリフレクションを使用するには、 &lt;code&gt;kotlin-reflect&lt;/code&gt; への依存関係を追加します。</target>
        </trans-unit>
        <trans-unit id="a24de3bc480fd74ef920d5e8c2200b8ea53a9381" translate="yes" xml:space="preserve">
          <source>To use such an extension outside its declaring package, we need to import it at the call site:</source>
          <target state="translated">このような拡張機能を宣言パッケージの外で使用するには、コールサイトでインポートする必要があります。</target>
        </trans-unit>
        <trans-unit id="f45da6c5e75b429df6c944cb1a348aa71eac1487" translate="yes" xml:space="preserve">
          <source>To use the Gradle worker API for parallel execution of kapt tasks, add this line to your &lt;code&gt;gradle.properties&lt;/code&gt; file:</source>
          <target state="translated">kaptタスクの並列実行にGradleワーカーAPIを使用するには、次の行を &lt;code&gt;gradle.properties&lt;/code&gt; ファイルに追加します。</target>
        </trans-unit>
        <trans-unit id="f4b36ae1fba60b209f3facc66006c1d59e359e4b" translate="yes" xml:space="preserve">
          <source>To use the library just</source>
          <target state="translated">ライブラリを利用するには</target>
        </trans-unit>
        <trans-unit id="f8b6262cd9dc8c43d7c667ac936a5f2566f2a0e4" translate="yes" xml:space="preserve">
          <source>To use these dependencies from a Kotlin code, import a package &lt;code&gt;cocoapods.&amp;lt;library-name&amp;gt;&lt;/code&gt;. In the example above, it's &lt;code&gt;cocoapods.AFNetworking&lt;/code&gt;.</source>
          <target state="translated">Kotlinコードからこれらの依存関係を使用するには、パッケージ &lt;code&gt;cocoapods.&amp;lt;library-name&amp;gt;&lt;/code&gt; インポートします。上記の例では、 &lt;code&gt;cocoapods.AFNetworking&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="fc228ddfd7202033ce71a7fc317732c5e0b0cb8d" translate="yes" xml:space="preserve">
          <source>To use these dependencies from the Kotlin code, import the packages &lt;code&gt;cocoapods.&amp;lt;library-name&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Kotlinコードからこれらの依存関係を使用するには、パッケージ &lt;code&gt;cocoapods.&amp;lt;library-name&amp;gt;&lt;/code&gt; インポートします。</target>
        </trans-unit>
        <trans-unit id="22f56a6a1ece973c1e685039b7b24f3bed65f0bb" translate="yes" xml:space="preserve">
          <source>To verify that your code is formatted according to the style guide, go to &lt;strong&gt;Settings | Editor | Inspections&lt;/strong&gt; and enable the &lt;strong&gt;Kotlin | Style issues | File is not formatted according to project settings&lt;/strong&gt; inspection. Additional inspections that verify other issues described in the style guide (such as naming conventions) are enabled by default.</source>
          <target state="translated">コードがスタイルガイドに従ってフォーマットされていることを確認するには、&lt;strong&gt;[設定]&lt;/strong&gt;、&lt;strong&gt;[設定]の順&lt;/strong&gt;に移動します&lt;strong&gt;。&lt;/strong&gt;&lt;strong&gt;編集者| &lt;/strong&gt;&lt;strong&gt;Kotlinを&lt;/strong&gt;&lt;strong&gt;検査&lt;/strong&gt;して有効にする&lt;strong&gt;| &lt;/strong&gt;&lt;strong&gt;スタイルの問題| &lt;/strong&gt;&lt;strong&gt;プロジェクト設定&lt;/strong&gt;検査&lt;strong&gt;に従ってファイルがフォーマットされていません&lt;/strong&gt;。スタイルガイドに記載されている他の問題（命名規則など）を検証する追加の検査は、デフォルトで有効になっています。</target>
        </trans-unit>
        <trans-unit id="29ce373f521a913b58c57c24b3da2c509d708a6c" translate="yes" xml:space="preserve">
          <source>To verify that your code is formatted according to the style guide, go to the inspection settings and enable the &quot;Kotlin | Style issues | File is not formatted according to project settings&quot; inspection. Additional inspections that verify other issues described in the style guide (such as naming conventions) are enabled by default.</source>
          <target state="translated">あなたのコードがスタイルガイドに従ってフォーマットされているかどうかを確認するには、検査設定で「Kotlin|スタイルの問題|ファイルがプロジェクト設定に従ってフォーマットされていない」検査を有効にしてください。スタイルガイドに記載されているその他の問題(命名規則など)を確認する追加の検査は、デフォルトで有効になっています。</target>
        </trans-unit>
        <trans-unit id="a4960c3af648de37ee9fc988a1b8a755e743e505" translate="yes" xml:space="preserve">
          <source>To workaround this problem you can store a reference to the resource in the variable as opposed to returning it from the &lt;code&gt;withTimeout&lt;/code&gt; block.</source>
          <target state="translated">この問題を回避するには、 &lt;code&gt;withTimeout&lt;/code&gt; ブロックからリソースを返すのではなく、変数にリソースへの参照を格納します。</target>
        </trans-unit>
        <trans-unit id="b6747c485a8043bd5cfaa965ac1719dda893a066" translate="yes" xml:space="preserve">
          <source>To wrap the reference:</source>
          <target state="translated">参照をラップするために。</target>
        </trans-unit>
        <trans-unit id="4fc60ef5d69079c451ea67854c51808d9ec41c01" translate="yes" xml:space="preserve">
          <source>Tooling</source>
          <target state="translated">Tooling</target>
        </trans-unit>
        <trans-unit id="4fa8cc860c52b268dc6a3adcde7305e9415db5bb" translate="yes" xml:space="preserve">
          <source>Tools</source>
          <target state="translated">Tools</target>
        </trans-unit>
        <trans-unit id="a2b342afe760f02175e18eb57be53d77e5b4d945" translate="yes" xml:space="preserve">
          <source>Tools for Android Development</source>
          <target state="translated">Android開発のためのツール</target>
        </trans-unit>
        <trans-unit id="933c173dc4997663d3dd2b639f726f17d399abb1" translate="yes" xml:space="preserve">
          <source>Top level/global variables of non-primitive types are by default accessible in the main thread (i.e., the thread which initialized &lt;em&gt;Kotlin/Native&lt;/em&gt; runtime first) only. Access from another thread will lead to an &lt;code&gt;IncorrectDereferenceException&lt;/code&gt; being thrown. To make such variables accessible in other threads, you can use either the &lt;code&gt;@ThreadLocal&lt;/code&gt; annotation, and mark the value thread local or &lt;code&gt;@SharedImmutable&lt;/code&gt;, which will make the value frozen and accessible from other threads.</source>
          <target state="translated">非プリミティブ型のトップレベル/グローバル変数は、デフォルトではメインスレッド（つまり、最初に&lt;em&gt;Kotlin / Native&lt;/em&gt;ランタイムを初期化したスレッド）でのみアクセスできます。別のスレッドからアクセスすると、 &lt;code&gt;IncorrectDereferenceException&lt;/code&gt; がスローされます。他のスレッドでは、このような変数にアクセスできるようにするには、次のいずれかを使用することができます &lt;code&gt;@ThreadLocal&lt;/code&gt; 注釈を、そしてローカルまたは値のスレッドマーク &lt;code&gt;@SharedImmutable&lt;/code&gt; 他のスレッドからの値が凍結してアクセスできるようになります。</target>
        </trans-unit>
        <trans-unit id="d10164060fa5359f1cc0440621a4aa0561a65a4b" translate="yes" xml:space="preserve">
          <source>Top-level Kotlin functions and properties are accessible as members of special classes. Each Kotlin file is translated into such a class. E.g.</source>
          <target state="translated">トップレベルのKotlinの関数やプロパティは、特別なクラスのメンバーとしてアクセスできます。各Kotlinファイルはそのようなクラスに変換されます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="72f832e9bb11ffaf0e6dadede4c2d82d643da82d" translate="yes" xml:space="preserve">
          <source>Top-level blocks</source>
          <target state="translated">トップレベルブロック</target>
        </trans-unit>
        <trans-unit id="2b1be77aa458090db17874852b17692b274f4c30" translate="yes" xml:space="preserve">
          <source>Top-level functions and properties</source>
          <target state="translated">トップレベルの機能とプロパティ</target>
        </trans-unit>
        <trans-unit id="73a9d7257a50c4b586e17a750a9b120479406586" translate="yes" xml:space="preserve">
          <source>Top-level variables:</source>
          <target state="translated">トップレベルの変数。</target>
        </trans-unit>
        <trans-unit id="093982a5b38ce32bb690b5df5afe9cfb58db39b3" translate="yes" xml:space="preserve">
          <source>Top-level, or member of an &lt;a href=&quot;object-declarations#object-declarations&quot;&gt;&lt;em&gt;object&lt;/em&gt; declaration&lt;/a&gt; or &lt;a href=&quot;object-declarations#companion-objects&quot;&gt;a &lt;em&gt;companion object&lt;/em&gt;&lt;/a&gt;.</source>
          <target state="translated">トップレベル、またはメンバ&lt;a href=&quot;object-declarations#object-declarations&quot;&gt;&lt;em&gt;オブジェクト&lt;/em&gt;宣言&lt;/a&gt;または&lt;a href=&quot;object-declarations#companion-objects&quot;&gt;&lt;em&gt;コンパニオン・オブジェクト&lt;/em&gt;&lt;/a&gt;。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e3f139abb7a549a1210b36f7dbf89215ad6c9902" translate="yes" xml:space="preserve">
          <source>Touch</source>
          <target state="translated">Touch</target>
        </trans-unit>
        <trans-unit id="1efa29eabe3ababde0e86df3b6d2edc46db3122e" translate="yes" xml:space="preserve">
          <source>TouchList</source>
          <target state="translated">TouchList</target>
        </trans-unit>
        <trans-unit id="86c192cdf813e67ab4284db18cce6c47a873de77" translate="yes" xml:space="preserve">
          <source>TrackEventInit</source>
          <target state="translated">TrackEventInit</target>
        </trans-unit>
        <trans-unit id="04a727b8d4352f2bb05170808566a662370f1470" translate="yes" xml:space="preserve">
          <source>Trailing comma</source>
          <target state="translated">末尾のカンマ</target>
        </trans-unit>
        <trans-unit id="7b5b3a2e5f602edd973d6bc7c27d9b7106a52ef4" translate="yes" xml:space="preserve">
          <source>Trailing commas</source>
          <target state="translated">トレイリングカンマ</target>
        </trans-unit>
        <trans-unit id="10b9c6cd7256580987215cb5bd31fae33f7491a8" translate="yes" xml:space="preserve">
          <source>Trailing commas are entirely optional &amp;ndash; your code will still work without them. The Kotlin style guide encourages the use of trailing commas at the declaration site and leaves it at your discretion for the call site.</source>
          <target state="translated">末尾のコンマは完全にオプションです。コードはカンマがなくても機能します。Kotlinスタイルガイドでは、宣言サイトで末尾のコンマを使用することを推奨しており、呼び出しサイトの裁量に任せています。</target>
        </trans-unit>
        <trans-unit id="24c733cfc9ff52310bfeff0739e9d84bd974f090" translate="yes" xml:space="preserve">
          <source>Training Partners</source>
          <target state="translated">トレーニングパートナー</target>
        </trans-unit>
        <trans-unit id="62000f6d60c7b6da6e48acb50b9e4d2454c263e3" translate="yes" xml:space="preserve">
          <source>TransferMode</source>
          <target state="translated">TransferMode</target>
        </trans-unit>
        <trans-unit id="5493525620b201e4aeb2e3e266e9b2a0148f6e9a" translate="yes" xml:space="preserve">
          <source>Transform operator</source>
          <target state="translated">変形演算子</target>
        </trans-unit>
        <trans-unit id="d685ad7c59aeb1945ef867b52857539b62c1b81c" translate="yes" xml:space="preserve">
          <source>Transformations</source>
          <target state="translated">Transformations</target>
        </trans-unit>
        <trans-unit id="e58ba5ae9c3b287bdcbf2771b01865f2bca67751" translate="yes" xml:space="preserve">
          <source>Transformations to &lt;code&gt;Iterable&lt;/code&gt; on &lt;code&gt;Sequence&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Sequence&lt;/code&gt; &lt;code&gt;Iterable&lt;/code&gt; への変換</target>
        </trans-unit>
        <trans-unit id="81c5e51e91e71b63dc5528985dabb38605c21cee" translate="yes" xml:space="preserve">
          <source>Transformations to &lt;code&gt;Sequence&lt;/code&gt; on &lt;code&gt;Iterable&lt;/code&gt;, &lt;code&gt;Array&lt;/code&gt;, and &lt;code&gt;Map&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Iterable&lt;/code&gt; 、 &lt;code&gt;Array&lt;/code&gt; 、および &lt;code&gt;Map&lt;/code&gt; での &lt;code&gt;Sequence&lt;/code&gt; への変換</target>
        </trans-unit>
        <trans-unit id="45d5bc5a6500f8488347501d41f5194f063eae68" translate="yes" xml:space="preserve">
          <source>Transient</source>
          <target state="translated">Transient</target>
        </trans-unit>
        <trans-unit id="ba8d3f89d630067e3ad00c3e459e314bd98fb9a0" translate="yes" xml:space="preserve">
          <source>Transitive: for any non-null values &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;z&lt;/code&gt;, if &lt;code&gt;x.equals(y)&lt;/code&gt; returns true and &lt;code&gt;y.equals(z)&lt;/code&gt; returns true, then &lt;code&gt;x.equals(z)&lt;/code&gt; should return true.</source>
          <target state="translated">推移的：null以外の値 &lt;code&gt;x&lt;/code&gt; 、 &lt;code&gt;y&lt;/code&gt; 、および &lt;code&gt;z&lt;/code&gt; について、 &lt;code&gt;x.equals(y)&lt;/code&gt; がtrueを返し、 &lt;code&gt;y.equals(z)&lt;/code&gt; がtrueを返す場合、 &lt;code&gt;x.equals(z)&lt;/code&gt; はtrueを返す必要があります。</target>
        </trans-unit>
        <trans-unit id="a3b98ac58ac04384390fe968f8d17e1762075dcc" translate="yes" xml:space="preserve">
          <source>Translate primitive arrays to JS typed arrays</source>
          <target state="translated">プリミティブ配列を JS 型配列に変換する</target>
        </trans-unit>
        <trans-unit id="a1e378439cd6792c22e6754f9de426ee92e8887a" translate="yes" xml:space="preserve">
          <source>Translated to</source>
          <target state="translated">訳語は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="bd2fa02487c23403447e0670b33275ea05db6a74" translate="yes" xml:space="preserve">
          <source>Translation Rules</source>
          <target state="translated">翻訳ルール</target>
        </trans-unit>
        <trans-unit id="ab6dfa598f3ee1889c506fcb09d74fa1777c572b" translate="yes" xml:space="preserve">
          <source>Translation of type &lt;code&gt;Nothing&lt;/code&gt;</source>
          <target state="translated">タイプ &lt;code&gt;Nothing&lt;/code&gt; の翻訳</target>
        </trans-unit>
        <trans-unit id="6aceb57c8bb80570e896470165c635c1ee57a688" translate="yes" xml:space="preserve">
          <source>Translation rules</source>
          <target state="translated">翻訳ルール</target>
        </trans-unit>
        <trans-unit id="4d92e703a622ed46d6e27f0f0f77397beeb3e132" translate="yes" xml:space="preserve">
          <source>Transparent catch</source>
          <target state="translated">透明なキャッチ</target>
        </trans-unit>
        <trans-unit id="a15aca388afb19d901171e68fd72afd431d071e5" translate="yes" xml:space="preserve">
          <source>Traversing a map/list of pairs</source>
          <target state="translated">マップ/ペアのリストをトラバースする</target>
        </trans-unit>
        <trans-unit id="c5549ac8b888e22b01fa637b7351d8e5201d7fba" translate="yes" xml:space="preserve">
          <source>TreeWalker</source>
          <target state="translated">TreeWalker</target>
        </trans-unit>
        <trans-unit id="bf7930508d19dc53b19991f963b30e949ffffae4" translate="yes" xml:space="preserve">
          <source>Trigonometric: &lt;code&gt;cos&lt;/code&gt;, &lt;code&gt;sin&lt;/code&gt;, &lt;code&gt;tan&lt;/code&gt; and inverse of them: &lt;code&gt;acos&lt;/code&gt;, &lt;code&gt;asin&lt;/code&gt;, &lt;code&gt;atan&lt;/code&gt;, &lt;code&gt;atan2&lt;/code&gt;;</source>
          <target state="translated">三角関数： &lt;code&gt;cos&lt;/code&gt; 、 &lt;code&gt;sin&lt;/code&gt; 、 &lt;code&gt;tan&lt;/code&gt; およびそれらの逆： &lt;code&gt;acos&lt;/code&gt; 、 &lt;code&gt;asin&lt;/code&gt; 、 &lt;code&gt;atan&lt;/code&gt; 、 &lt;code&gt;atan2&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="b9283be1760ffff3d2b71a4bf3400fc0c777b4fb" translate="yes" xml:space="preserve">
          <source>Trims leading whitespace characters followed by &lt;a href=&quot;../../kotlin.text/trim-margin#kotlin.text%24trimMargin%28kotlin.String%2C+kotlin.String%29%2FmarginPrefix&quot;&gt;marginPrefix&lt;/a&gt; from every line of a source string and removes the first and the last lines if they are blank (notice difference blank vs empty).</source>
          <target state="translated">先頭の空白文字とそれに続く&lt;a href=&quot;../../kotlin.text/trim-margin#kotlin.text%24trimMargin%28kotlin.String%2C+kotlin.String%29%2FmarginPrefix&quot;&gt;marginPrefix&lt;/a&gt;をソース文字列のすべての行から削除し、最初と最後の行が空白の場合は削除します（空白と空の違いに注意）。</target>
        </trans-unit>
        <trans-unit id="5480c14a1f35b84e453f6cd73b5a2004a2f5d464" translate="yes" xml:space="preserve">
          <source>Trims leading whitespace characters followed by &lt;a href=&quot;../../kotlin.text/trim-margin#kotlin.text%24trimMargin(kotlin.String,%20kotlin.String)/marginPrefix&quot;&gt;marginPrefix&lt;/a&gt; from every line of a source string and removes the first and the last lines if they are blank (notice difference blank vs empty).</source>
          <target state="translated">ソース文字列のすべての行から先頭の空白文字とそれに続く&lt;a href=&quot;../../kotlin.text/trim-margin#kotlin.text%24trimMargin(kotlin.String,%20kotlin.String)/marginPrefix&quot;&gt;marginPrefix&lt;/a&gt;を削除し、空白の場合は最初と最後の行を削除します（空白と空の違いに注意してください）。</target>
        </trans-unit>
        <trans-unit id="c35e61d912f4e00490fababb98d899c86bab87f9" translate="yes" xml:space="preserve">
          <source>Trims leading whitespace characters followed by &lt;a href=&quot;trim-margin#kotlin.text%24trimMargin%28kotlin.String%2C+kotlin.String%29%2FmarginPrefix&quot;&gt;marginPrefix&lt;/a&gt; from every line of a source string and removes the first and the last lines if they are blank (notice difference blank vs empty).</source>
          <target state="translated">先頭の空白文字とそれに続く&lt;a href=&quot;trim-margin#kotlin.text%24trimMargin%28kotlin.String%2C+kotlin.String%29%2FmarginPrefix&quot;&gt;marginPrefix&lt;/a&gt;をソース文字列のすべての行から削除し、最初と最後の行が空白の場合は削除します（空白と空の違いに注意）。</target>
        </trans-unit>
        <trans-unit id="84a97aca5ec5480f19364dafde3094ff54f3e81a" translate="yes" xml:space="preserve">
          <source>Trims leading whitespace characters followed by &lt;a href=&quot;trim-margin#kotlin.text%24trimMargin(kotlin.String,%20kotlin.String)/marginPrefix&quot;&gt;marginPrefix&lt;/a&gt; from every line of a source string and removes the first and the last lines if they are blank (notice difference blank vs empty).</source>
          <target state="translated">ソース文字列のすべての行から先頭の空白文字とそれに続く&lt;a href=&quot;trim-margin#kotlin.text%24trimMargin(kotlin.String,%20kotlin.String)/marginPrefix&quot;&gt;marginPrefix&lt;/a&gt;を削除し、空白の場合は最初と最後の行を削除します（空白と空の違いに注意してください）。</target>
        </trans-unit>
        <trans-unit id="ae1a12e0ad64ac32c1b6bcc5a4f65c861d2ccdb6" translate="yes" xml:space="preserve">
          <source>Triple</source>
          <target state="translated">Triple</target>
        </trans-unit>
        <trans-unit id="285ec850c11d78bac10f6bfa31b69a37f1b257c9" translate="yes" xml:space="preserve">
          <source>Troubleshooting</source>
          <target state="translated">Troubleshooting</target>
        </trans-unit>
        <trans-unit id="dd25f60abb02d8a8fead2fd0c632ac71f7dc7572" translate="yes" xml:space="preserve">
          <source>True if this BitSet contains no bits set to true.</source>
          <target state="translated">このBitSetにTrueに設定されているビットがない場合はTrueになります。</target>
        </trans-unit>
        <trans-unit id="ebadece2244cd8c3930af24f6efed50ba5303aeb" translate="yes" xml:space="preserve">
          <source>Try is an expression</source>
          <target state="translated">トライは表現</target>
        </trans-unit>
        <trans-unit id="76626410fd299e2579daa03a6a8e059a7c331dac" translate="yes" xml:space="preserve">
          <source>Try running the following code:</source>
          <target state="translated">以下のコードを実行してみてください。</target>
        </trans-unit>
        <trans-unit id="ab16b9ed40416d31269e0f90879c02e2beaffb5d" translate="yes" xml:space="preserve">
          <source>Try the following example:</source>
          <target state="translated">次の例を試してみてください。</target>
        </trans-unit>
        <trans-unit id="6598cd1f03cde7303010f8b82688f8cd83e05fd7" translate="yes" xml:space="preserve">
          <source>Try the hierarchical project structure</source>
          <target state="translated">プロジェクトの階層構造を試してみる</target>
        </trans-unit>
        <trans-unit id="6e8975e856a765f6b65172a38acea83accc861c3" translate="yes" xml:space="preserve">
          <source>Tuning the Gradle Build Script</source>
          <target state="translated">Gradle ビルドスクリプトのチューニング</target>
        </trans-unit>
        <trans-unit id="ea1b6a2e19cb07b905a5f8a640d896e87bcec9bf" translate="yes" xml:space="preserve">
          <source>Turn any warnings into a compilation error.</source>
          <target state="translated">任意の警告をコンパイルエラーにします。</target>
        </trans-unit>
        <trans-unit id="486df8c49f3484e79ec93676a1d2d32e3c21544f" translate="yes" xml:space="preserve">
          <source>Turn off the discovery of annotation processors in the compile classpath by adding this line to your &lt;code&gt;gradle.properties&lt;/code&gt; file:</source>
          <target state="translated">次の行を &lt;code&gt;gradle.properties&lt;/code&gt; ファイルに追加して、コンパイルクラスパスでの注釈プロセッサの検出をオフにします。</target>
        </trans-unit>
        <trans-unit id="654171647baa6be8557a5d627cf35c7075ebb257" translate="yes" xml:space="preserve">
          <source>Tutorials</source>
          <target state="translated">Tutorials</target>
        </trans-unit>
        <trans-unit id="a8a70d82aa05be09e708b91e7f3e4c134d89ffcd" translate="yes" xml:space="preserve">
          <source>Two characters are considered the same ignoring case if at least one of the following is &lt;code&gt;true&lt;/code&gt;:</source>
          <target state="translated">次の少なくとも1つが &lt;code&gt;true&lt;/code&gt; 場合、2つの文字は大文字と小文字を区別せずに同じと見なされます。</target>
        </trans-unit>
        <trans-unit id="ab472c51dfbccf051740af19176dfafb00b61af8" translate="yes" xml:space="preserve">
          <source>Two generators with the same seed produce the same sequence of values within the same version of Kotlin runtime.</source>
          <target state="translated">同じシードを持つ2つのジェネレータは、同じバージョンのKotlinランタイム内で同じ値のシーケンスを生成します。</target>
        </trans-unit>
        <trans-unit id="d137720f3328e5a478b178126ce3903c8817736d" translate="yes" xml:space="preserve">
          <source>Two maps containing the equal pairs are equal regardless of the pair order.</source>
          <target state="translated">等しいペアを含む2つのマップは、ペアの順序に関係なく等しい。</target>
        </trans-unit>
        <trans-unit id="3deb7456519697ecf4eefc455516c969a3681bae" translate="yes" xml:space="preserve">
          <source>Type</source>
          <target state="translated">Type</target>
        </trans-unit>
        <trans-unit id="5f6616a8e5da9fee3d521ed755f2bea54b08215a" translate="yes" xml:space="preserve">
          <source>Type Checks and Casts: &amp;#x27;is&amp;#x27; and &amp;#x27;as&amp;#x27;</source>
          <target state="translated">タイプチェックとキャスト： 'is'および 'as'</target>
        </trans-unit>
        <trans-unit id="d6cc07866d5f06f3719a56316deb52a9dd1a6362" translate="yes" xml:space="preserve">
          <source>Type Checks and Casts: 'is' and 'as'</source>
          <target state="translated">タイプチェックとキャスト:'is' と 'as'</target>
        </trans-unit>
        <trans-unit id="ba8b607d229159b7de176502ebe44f1a8317de01" translate="yes" xml:space="preserve">
          <source>Type alias</source>
          <target state="translated">タイプエイリアス</target>
        </trans-unit>
        <trans-unit id="58cf557846d7f65d34e8a92739eef2665164fad4" translate="yes" xml:space="preserve">
          <source>Type aliases</source>
          <target state="translated">タイプエイリアス</target>
        </trans-unit>
        <trans-unit id="723718d194ac3a64c7f264ffc4d4f72b344ce07d" translate="yes" xml:space="preserve">
          <source>Type aliases can have only one member, while functional interfaces can have multiple non-abstract members and one abstract member. Functional interfaces can also implement and extend other interfaces.</source>
          <target state="translated">タイプエイリアスは、1つのメンバのみを持つことができますが、機能的なインタフェースは、複数の非抽象的なメンバと1つの抽象的なメンバを持つことができます。機能インタフェースは、他のインタフェースを実装したり、拡張したりすることもできます。</target>
        </trans-unit>
        <trans-unit id="69c8e849ce31321a314a70ac8ad4ed39beff1378" translate="yes" xml:space="preserve">
          <source>Type aliases do not introduce new types. They are equivalent to the corresponding underlying types. When you add &lt;code&gt;typealias Predicate&amp;lt;T&amp;gt;&lt;/code&gt; and use &lt;code&gt;Predicate&amp;lt;Int&amp;gt;&lt;/code&gt; in your code, the Kotlin compiler always expands it to &lt;code&gt;(Int) -&amp;gt; Boolean&lt;/code&gt;. Thus you can pass a variable of your type whenever a general function type is required and vice versa:</source>
          <target state="translated">タイプエイリアスは新しいタイプを導入しません。これらは、対応する基本型と同等です。 &lt;code&gt;typealias Predicate&amp;lt;T&amp;gt;&lt;/code&gt; を追加し、コードで &lt;code&gt;Predicate&amp;lt;Int&amp;gt;&lt;/code&gt; &amp;gt;を使用すると、Kotlinコンパイラーは常にそれを &lt;code&gt;(Int) -&amp;gt; Boolean&lt;/code&gt; ます。したがって、一般的な関数型が必要な場合はいつでも、その型の変数を渡すことができ、その逆も可能です。</target>
        </trans-unit>
        <trans-unit id="63f9c00fb5f4cc41a0eed5075c935b736c6b9723" translate="yes" xml:space="preserve">
          <source>Type aliases provide alternative names for existing types. If the type name is too long you can introduce a different shorter name and use the new one instead.</source>
          <target state="translated">タイプエイリアスは、既存のタイプの代替名を提供します。型名が長すぎる場合は、別の短い名前を導入し、代わりに新しい名前を使用することができます。</target>
        </trans-unit>
        <trans-unit id="a2a8d10c5940641abcd5ce54fb8bcd8a1818a8ed" translate="yes" xml:space="preserve">
          <source>Type annotations in the JVM bytecode</source>
          <target state="translated">JVMバイトコード内のタイプアノテーション</target>
        </trans-unit>
        <trans-unit id="c296bfc3cf8da18578c109dce183097398bf868c" translate="yes" xml:space="preserve">
          <source>Type annotations on method parameters, method return types and property types;</source>
          <target state="translated">メソッドのパラメータ、メソッドの戻り値の型、およびプロパティの型に関する型アノテーション。</target>
        </trans-unit>
        <trans-unit id="e35e3a28b52f56ce98adcccb56e038088090c61a" translate="yes" xml:space="preserve">
          <source>Type arguments</source>
          <target state="translated">引数を入力します。</target>
        </trans-unit>
        <trans-unit id="f97f977bc0dba85c3cc52fd08f6033a3696be06a" translate="yes" xml:space="preserve">
          <source>Type arguments can be omitted if they can be inferred from the context, so the following example works as well:</source>
          <target state="translated">型の引数は、コンテキストから推測できる場合には省略することができますので、以下の例も同様に動作します。</target>
        </trans-unit>
        <trans-unit id="c98c974ad55a448f7905288ae79a3c29e3dafc00" translate="yes" xml:space="preserve">
          <source>Type arguments passed for the parameters of the classifier in this type. For example, in the type &lt;code&gt;Array&amp;lt;out Number&amp;gt;&lt;/code&gt; the only type argument is &lt;code&gt;out Number&lt;/code&gt;.</source>
          <target state="translated">この型の分類子のパラメーターに渡される型引数。たとえば、タイプ &lt;code&gt;Array&amp;lt;out Number&amp;gt;&lt;/code&gt; では、タイプ引数は &lt;code&gt;out Number&lt;/code&gt; のみです。</target>
        </trans-unit>
        <trans-unit id="17f4a34465afc16c831c4800dd92a48a4229a238" translate="yes" xml:space="preserve">
          <source>Type casts to generic types with concrete type arguments, e.g. &lt;code&gt;foo as List&amp;lt;String&amp;gt;&lt;/code&gt;, cannot be checked at runtime.</source>
          <target state="translated">具体的な型引数を持つジェネリック型への型キャスト（例： &lt;code&gt;foo as List&amp;lt;String&amp;gt;&lt;/code&gt; ）は、実行時にチェックできません。</target>
        </trans-unit>
        <trans-unit id="73156460a89d705ba62bd534bd81f39c8db2596a" translate="yes" xml:space="preserve">
          <source>Type checks and automatic casts</source>
          <target state="translated">タイプチェックと自動キャスト</target>
        </trans-unit>
        <trans-unit id="793f10e89d89960ec6635302ed647f148619a822" translate="yes" xml:space="preserve">
          <source>Type erasure</source>
          <target state="translated">タイプ消去</target>
        </trans-unit>
        <trans-unit id="40dc0a7305bb05f3cc921959233fc31aff814e2e" translate="yes" xml:space="preserve">
          <source>Type erasure and generic type checks</source>
          <target state="translated">型の消去と汎用型チェック</target>
        </trans-unit>
        <trans-unit id="3a57e7033772e15f6c935d00cab613d6b63a13b4" translate="yes" xml:space="preserve">
          <source>Type inference for variable and property types</source>
          <target state="translated">変数型とプロパティ型の型推論</target>
        </trans-unit>
        <trans-unit id="6468c2c68f3a4de506104359dc49acb341f7ce4b" translate="yes" xml:space="preserve">
          <source>Type of this parameter. For a &lt;code&gt;vararg&lt;/code&gt; parameter, this is the type of the corresponding array, not the individual element.</source>
          <target state="translated">このパラメーターのタイプ。ための &lt;code&gt;vararg&lt;/code&gt; 、パラメータ、これは対応する配列の種類ではなく、個々の要素です。</target>
        </trans-unit>
        <trans-unit id="c9a3646a7ac556f56d25e93e18f2d2b1583d0264" translate="yes" xml:space="preserve">
          <source>Type parameters</source>
          <target state="translated">タイプパラメータ</target>
        </trans-unit>
        <trans-unit id="67db91aa392a58df5790c33c41ae1990e5a33a95" translate="yes" xml:space="preserve">
          <source>Type projection is either the star projection, or an entity consisting of a specific type plus optional variance.</source>
          <target state="translated">型投影は、スター投影、または特定の型とオプションの分散からなる実体のいずれかです。</target>
        </trans-unit>
        <trans-unit id="a1c1994c749574f626726569018d7132330feb4f" translate="yes" xml:space="preserve">
          <source>Type projections</source>
          <target state="translated">タイプ別予想</target>
        </trans-unit>
        <trans-unit id="390df132c9a4d4db52e48418904c22311abcfb25" translate="yes" xml:space="preserve">
          <source>Type projections (use-site covariance and contravariance)</source>
          <target state="translated">タイプ別予測(使用部位の共分散と対照分散</target>
        </trans-unit>
        <trans-unit id="abe0a5c2d281fcb1877a803065e24a61b33d5485" translate="yes" xml:space="preserve">
          <source>Type qualifier defaults (since 1.1.50)</source>
          <target state="translated">型修飾子のデフォルト (1.1.50 以降)</target>
        </trans-unit>
        <trans-unit id="7774fb35aa4a81a2d582ed079ba64fde2c6c6958" translate="yes" xml:space="preserve">
          <source>Type qualifier nicknames (since 1.1.50)</source>
          <target state="translated">タイプ修飾子のニックネーム (1.1.50 以降)</target>
        </trans-unit>
        <trans-unit id="acbd0130304bd83955856731709666b221130b62" translate="yes" xml:space="preserve">
          <source>Type safety problem because of incorrect subtyping for intersection types</source>
          <target state="translated">交差点タイプのサブタイプが正しくないため、タイプの安全性に問題がある</target>
        </trans-unit>
        <trans-unit id="9199f1fd6ec494778d67bf415e37aa0839ac622f" translate="yes" xml:space="preserve">
          <source>Type safety problem because of lack of captured conversion against nullable type argument</source>
          <target state="translated">ヌル可能な型引数に対する変換がキャプチャされていないため、型の安全性に問題がある</target>
        </trans-unit>
        <trans-unit id="bb995680367f27e40ce4ad1d6abb4c604f7187b7" translate="yes" xml:space="preserve">
          <source>Type safety problem because several equal type variables are instantiated with a different types</source>
          <target state="translated">複数の等しい型変数が異なる型でインスタンス化されているため、型の安全性の問題</target>
        </trans-unit>
        <trans-unit id="40de16300b7ec7ebb7fd5b46ebfe06fa7442e5d2" translate="yes" xml:space="preserve">
          <source>Type usage</source>
          <target state="translated">タイプの使用法</target>
        </trans-unit>
        <trans-unit id="4903c79122878e4bb6246343ee54954a9e90d953" translate="yes" xml:space="preserve">
          <source>Type variable leaks from builder inference because of using &lt;code&gt;this&lt;/code&gt; expression</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; 式を使用しているため、型変数がビルダー推論からリークします</target>
        </trans-unit>
        <trans-unit id="302ec0e139d68906dc0b295bb935fe896afa1e82" translate="yes" xml:space="preserve">
          <source>Type-Safe Builders</source>
          <target state="translated">タイプセーフビルダー</target>
        </trans-unit>
        <trans-unit id="1c6379917dd2967a0cd2179d5b9d494b8ce1b4e8" translate="yes" xml:space="preserve">
          <source>Type-safe builders allow creating Kotlin-based domain-specific languages (DSLs) suitable for building complex hierarchical data structures in a semi-declarative way. Some of the example use cases for the builders are:</source>
          <target state="translated">タイプセーフビルダーは、複雑な階層データ構造を半宣言的に構築するのに適したKotlinベースのドメイン固有言語(DSL)を作成することを可能にします。ビルダーの使用例としては、以下のようなものがあります。</target>
        </trans-unit>
        <trans-unit id="5c15b26d8e7df3e3ffb8c17df0302ea2aa484921" translate="yes" xml:space="preserve">
          <source>TypeCastException</source>
          <target state="translated">TypeCastException</target>
        </trans-unit>
        <trans-unit id="5f0d1a781a66df1f72742486a55df1e5b04f2308" translate="yes" xml:space="preserve">
          <source>Typealias describing custom exception reporting hook.</source>
          <target state="translated">カスタム例外報告フックを記述するTypealias。</target>
        </trans-unit>
        <trans-unit id="f3f4c434904369ad0a9f93c33f4c9768b4547a37" translate="yes" xml:space="preserve">
          <source>TypedArrays support enabled by default</source>
          <target state="translated">デフォルトで有効なTypedArraysのサポート</target>
        </trans-unit>
        <trans-unit id="93b9e289e2842469d001eccf7ad5d79f3c302dc9" translate="yes" xml:space="preserve">
          <source>Types</source>
          <target state="translated">Types</target>
        </trans-unit>
        <trans-unit id="5ee39ed12bcc53f39d2691296714b602c56e8452" translate="yes" xml:space="preserve">
          <source>Types in C Language</source>
          <target state="translated">C言語の型</target>
        </trans-unit>
        <trans-unit id="9082e24429af3d96afc6c792bd53d243c13fe913" translate="yes" xml:space="preserve">
          <source>Types in Kotlin are optional in many places due to pervasive use of type-inference, but every declaration still has a well-defined static type that is known at compilation.</source>
          <target state="translated">Kotlin の型は型推論が広く使われているため、多くの場所でオプションとなっていますが、すべての宣言には、コンパイル時にわかるようにしっかりと定義された静的な型が残っています。</target>
        </trans-unit>
        <trans-unit id="629a9e78a0114f36f48645e6ead99e73e5226592" translate="yes" xml:space="preserve">
          <source>Types mapping between C and Kotlin/Native</source>
          <target state="translated">CとKotlin/Nativeの間の型のマッピング</target>
        </trans-unit>
        <trans-unit id="23a10fa48ff804faeadfa8169422520460b61a41" translate="yes" xml:space="preserve">
          <source>Typesafe HTML DSL</source>
          <target state="translated">タイプセーフ HTML DSL</target>
        </trans-unit>
        <trans-unit id="f4beb9af58f792082d8857ce30b4be1bdbe9b57a" translate="yes" xml:space="preserve">
          <source>Typography</source>
          <target state="translated">Typography</target>
        </trans-unit>
        <trans-unit id="4ae5c7578750deca68bcc325a7a71916e13eb9f0" translate="yes" xml:space="preserve">
          <source>UArraysKt</source>
          <target state="translated">UArraysKt</target>
        </trans-unit>
        <trans-unit id="bf674fff56341390c001cb60679614bd8b320e06" translate="yes" xml:space="preserve">
          <source>UByte</source>
          <target state="translated">UByte</target>
        </trans-unit>
        <trans-unit id="ffb6040505a41eac67ecae4d97b182ca73c78ec7" translate="yes" xml:space="preserve">
          <source>UByteArray</source>
          <target state="translated">UByteArray</target>
        </trans-unit>
        <trans-unit id="d70700d1cf06666209f322639803c081fb20d34b" translate="yes" xml:space="preserve">
          <source>UByteIterator</source>
          <target state="translated">UByteIterator</target>
        </trans-unit>
        <trans-unit id="5c472b4b939131094e43f08559b073c75fc2a028" translate="yes" xml:space="preserve">
          <source>UByteVar</source>
          <target state="translated">UByteVar</target>
        </trans-unit>
        <trans-unit id="f25071b42b8c8e395a2b2b3981b7f23745b87556" translate="yes" xml:space="preserve">
          <source>UByteVarOf</source>
          <target state="translated">UByteVarOf</target>
        </trans-unit>
        <trans-unit id="7df33eb953a0db74ecea7bf713e814fb3abc743c" translate="yes" xml:space="preserve">
          <source>UIEventInit</source>
          <target state="translated">UIEventInit</target>
        </trans-unit>
        <trans-unit id="9b81a5f58a08d125439c4fe920735e6f93f6c26f" translate="yes" xml:space="preserve">
          <source>UInt</source>
          <target state="translated">UInt</target>
        </trans-unit>
        <trans-unit id="e8203a992b0218cb4341f1de99192c75977adf66" translate="yes" xml:space="preserve">
          <source>UIntArray</source>
          <target state="translated">UIntArray</target>
        </trans-unit>
        <trans-unit id="107a5f6058e02cbfca8e781b5a2a6f523ad395cb" translate="yes" xml:space="preserve">
          <source>UIntIterator</source>
          <target state="translated">UIntIterator</target>
        </trans-unit>
        <trans-unit id="b426f73d819457b44ee2c1f6127ae0354bab9219" translate="yes" xml:space="preserve">
          <source>UIntProgression</source>
          <target state="translated">UIntProgression</target>
        </trans-unit>
        <trans-unit id="733f5415b770d705f77b9612bf3ea932f2bce7d0" translate="yes" xml:space="preserve">
          <source>UIntRange</source>
          <target state="translated">UIntRange</target>
        </trans-unit>
        <trans-unit id="c9533b600e74bcc2cae112123bf64c63ddcac0d1" translate="yes" xml:space="preserve">
          <source>UIntVar</source>
          <target state="translated">UIntVar</target>
        </trans-unit>
        <trans-unit id="77c6c1f150c9389635fa7924b4f92a8549cf352c" translate="yes" xml:space="preserve">
          <source>UIntVarOf</source>
          <target state="translated">UIntVarOf</target>
        </trans-unit>
        <trans-unit id="89e5acbaebf4cf3fe914f8e97ce3365330718921" translate="yes" xml:space="preserve">
          <source>ULong</source>
          <target state="translated">ULong</target>
        </trans-unit>
        <trans-unit id="0aede794cd54bbb254cbbba847a9015fdedd384b" translate="yes" xml:space="preserve">
          <source>ULongArray</source>
          <target state="translated">ULongArray</target>
        </trans-unit>
        <trans-unit id="f83610c14f64002be2365b4b214aea8d4eb7c555" translate="yes" xml:space="preserve">
          <source>ULongIterator</source>
          <target state="translated">ULongIterator</target>
        </trans-unit>
        <trans-unit id="7f4860e3cc03b10b3ed8b10361499545cea0082e" translate="yes" xml:space="preserve">
          <source>ULongProgression</source>
          <target state="translated">ULongProgression</target>
        </trans-unit>
        <trans-unit id="904eba861b0907dd0e83aefaefd037f230269422" translate="yes" xml:space="preserve">
          <source>ULongRange</source>
          <target state="translated">ULongRange</target>
        </trans-unit>
        <trans-unit id="c10238514adfeb120f1beff5e873dea7b5ed95a8" translate="yes" xml:space="preserve">
          <source>ULongVar</source>
          <target state="translated">ULongVar</target>
        </trans-unit>
        <trans-unit id="f9dbd48fa2388e1f99c73bab257c97f132eb1089" translate="yes" xml:space="preserve">
          <source>ULongVarOf</source>
          <target state="translated">ULongVarOf</target>
        </trans-unit>
        <trans-unit id="b9a5671fcf84e88d78fc3704de6f9b452eff55a8" translate="yes" xml:space="preserve">
          <source>UNASSIGNED</source>
          <target state="translated">UNASSIGNED</target>
        </trans-unit>
        <trans-unit id="67a492265c45012bb305d1d916be6fecf6ea8e3e" translate="yes" xml:space="preserve">
          <source>UNDEFINED</source>
          <target state="translated">UNDEFINED</target>
        </trans-unit>
        <trans-unit id="a7864204909e345af29e9c794841c9fe894997a9" translate="yes" xml:space="preserve">
          <source>UNIX_LINES</source>
          <target state="translated">UNIX_LINES</target>
        </trans-unit>
        <trans-unit id="25ba44ec3b391ba4ce5fbbd2979635e254775e7d" translate="yes" xml:space="preserve">
          <source>UNKNOWN</source>
          <target state="translated">UNKNOWN</target>
        </trans-unit>
        <trans-unit id="c12e2347be0a8619c1d9ecacaec292e6f681ff3c" translate="yes" xml:space="preserve">
          <source>UNSAFE</source>
          <target state="translated">UNSAFE</target>
        </trans-unit>
        <trans-unit id="260ff90ffb9b1a7afc1635ad4eeec327ff83ec80" translate="yes" xml:space="preserve">
          <source>UPPERCASE_LETTER</source>
          <target state="translated">UPPERCASE_LETTER</target>
        </trans-unit>
        <trans-unit id="0e2d9b0777a485c1276de0803c12a7d76fbc5c39" translate="yes" xml:space="preserve">
          <source>URL</source>
          <target state="translated">URL</target>
        </trans-unit>
        <trans-unit id="b19e8d66e7f004e226c44a75766dadab7d09911a" translate="yes" xml:space="preserve">
          <source>URLSearchParams</source>
          <target state="translated">URLSearchParams</target>
        </trans-unit>
        <trans-unit id="91e7bf3c4d0ab9784e0c43761883c8268e94bc3e" translate="yes" xml:space="preserve">
          <source>US_ASCII</source>
          <target state="translated">US_ASCII</target>
        </trans-unit>
        <trans-unit id="3f4264aca0374d417f001d13663bbf89f0617103" translate="yes" xml:space="preserve">
          <source>UShort</source>
          <target state="translated">UShort</target>
        </trans-unit>
        <trans-unit id="c9c0b8b91e36fe7c1c4c0418920e6f5691e8c55a" translate="yes" xml:space="preserve">
          <source>UShortArray</source>
          <target state="translated">UShortArray</target>
        </trans-unit>
        <trans-unit id="6c3a83167054246ea25835255ce7b0e018316b2a" translate="yes" xml:space="preserve">
          <source>UShortIterator</source>
          <target state="translated">UShortIterator</target>
        </trans-unit>
        <trans-unit id="a33eeb13596790b08a6df8799ea234e412c8c47b" translate="yes" xml:space="preserve">
          <source>UShortVar</source>
          <target state="translated">UShortVar</target>
        </trans-unit>
        <trans-unit id="282cb40f96ea3b82ef408a23ef69ab3812e1c45c" translate="yes" xml:space="preserve">
          <source>UShortVarOf</source>
          <target state="translated">UShortVarOf</target>
        </trans-unit>
        <trans-unit id="bdfd4d8d6952777c39403b2d2e2f8a2a52bf255f" translate="yes" xml:space="preserve">
          <source>UTC</source>
          <target state="translated">UTC</target>
        </trans-unit>
        <trans-unit id="f0217f65f3e1f538b0d8cda26e80a2285c43df22" translate="yes" xml:space="preserve">
          <source>UTF-16 code unit (see the section on &lt;a href=&quot;strings&quot;&gt;strings&lt;/a&gt; - in most cases, this is one Unicode character, but it might be just one half of a Unicode character)</source>
          <target state="translated">UTF-16コード単位（&lt;a href=&quot;strings&quot;&gt;文字列&lt;/a&gt;のセクションを参照-ほとんどの場合、これは1つのUnicode文字ですが、Unicode文字の半分にすぎない場合があります）</target>
        </trans-unit>
        <trans-unit id="3133dd8458a32c8b5ce4a722caa62b68748d9288" translate="yes" xml:space="preserve">
          <source>UTF_16</source>
          <target state="translated">UTF_16</target>
        </trans-unit>
        <trans-unit id="6ca2e2b19e1ecda564482fabe6d3670b269a5872" translate="yes" xml:space="preserve">
          <source>UTF_16BE</source>
          <target state="translated">UTF_16BE</target>
        </trans-unit>
        <trans-unit id="9754e677d06d03c4582e2dcf98147ca46f84d72e" translate="yes" xml:space="preserve">
          <source>UTF_16LE</source>
          <target state="translated">UTF_16LE</target>
        </trans-unit>
        <trans-unit id="447ed343c0ab25980389215d35f14db291c88450" translate="yes" xml:space="preserve">
          <source>UTF_32</source>
          <target state="translated">UTF_32</target>
        </trans-unit>
        <trans-unit id="92586032892e03cbec5d2f808289d67c3e5fe454" translate="yes" xml:space="preserve">
          <source>UTF_32BE</source>
          <target state="translated">UTF_32BE</target>
        </trans-unit>
        <trans-unit id="cbf0128f0e447f51c74b68507c6628894645216c" translate="yes" xml:space="preserve">
          <source>UTF_32LE</source>
          <target state="translated">UTF_32LE</target>
        </trans-unit>
        <trans-unit id="444b32f7d1774bb52a894fb896e3e3f1afe43c1f" translate="yes" xml:space="preserve">
          <source>UTF_8</source>
          <target state="translated">UTF_8</target>
        </trans-unit>
        <trans-unit id="ee17a2d4842b1562f38fb267817829d58a3dedfb" translate="yes" xml:space="preserve">
          <source>Uint16Array</source>
          <target state="translated">Uint16Array</target>
        </trans-unit>
        <trans-unit id="633c2aa79d88322b5d53222bfe0bb765531ece57" translate="yes" xml:space="preserve">
          <source>Uint32Array</source>
          <target state="translated">Uint32Array</target>
        </trans-unit>
        <trans-unit id="9dafd0a91ea1eadf5a4b323d71716a37f430543c" translate="yes" xml:space="preserve">
          <source>Uint8Array</source>
          <target state="translated">Uint8Array</target>
        </trans-unit>
        <trans-unit id="80d3d1902630c787d741b39af0ddaba8dab6c5b7" translate="yes" xml:space="preserve">
          <source>Uint8ClampedArray</source>
          <target state="translated">Uint8ClampedArray</target>
        </trans-unit>
        <trans-unit id="dbab18f3ded2bfe1f1beae0998ec97e669719cb0" translate="yes" xml:space="preserve">
          <source>Unary operations</source>
          <target state="translated">単項演算</target>
        </trans-unit>
        <trans-unit id="700a41ed5d6a21b389d3a06a552007f7d4970e83" translate="yes" xml:space="preserve">
          <source>Unary operators &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;++&lt;/code&gt;, &lt;code&gt;--&lt;/code&gt;, and a function &lt;code&gt;inv&lt;/code&gt;.</source>
          <target state="translated">単項演算子 &lt;code&gt;-&lt;/code&gt; 、 &lt;code&gt;++&lt;/code&gt; 、 &lt;code&gt;--&lt;/code&gt; 、および関数 &lt;code&gt;inv&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f7af4b44086924bef8511e74a06dc5652e98b37f" translate="yes" xml:space="preserve">
          <source>Unary prefix operators</source>
          <target state="translated">単項接頭辞演算子</target>
        </trans-unit>
        <trans-unit id="71f09f8fe1dde2289c868a03cb103ae030625690" translate="yes" xml:space="preserve">
          <source>Unchecked casts</source>
          <target state="translated">チェックされていないキャスト</target>
        </trans-unit>
        <trans-unit id="b8d5b81db1752990f9a00626b0f1fe949182953e" translate="yes" xml:space="preserve">
          <source>Unconfined dispatcher is an advanced mechanism that can be helpful in certain corner cases where dispatching of coroutine for its execution later is not needed or produces undesirable side-effects, because some operation in a coroutine must be performed right away. Unconfined dispatcher should not be used in general code.</source>
          <target state="translated">不定型ディスパッチャは高度なメカニズムで、コルーチン内のいくつかの操作がすぐに実行されなければならないため、後で実行するためにコルーチンをディスパッチする必要がなかったり、望ましくない副作用が発生したりするような場合に役立ちます。一般的なコードでは、未定義のディスパッチャは使用すべきではありません。</target>
        </trans-unit>
        <trans-unit id="1ad54c8520658fa2b0366caffc5901ab7a388736" translate="yes" xml:space="preserve">
          <source>Unconfined vs confined dispatcher</source>
          <target state="translated">非拘束vs拘束された派遣元</target>
        </trans-unit>
        <trans-unit id="a2570f4d995169cd25ade0e53aebb8dd50e4a603" translate="yes" xml:space="preserve">
          <source>Undefined bidirectional character type. Undefined &lt;code&gt;char&lt;/code&gt; values have undefined directionality in the Unicode specification.</source>
          <target state="translated">未定義の双方向文字タイプ。未定義の &lt;code&gt;char&lt;/code&gt; 値は、Unicode仕様で未定義の方向性を持っています。</target>
        </trans-unit>
        <trans-unit id="36bdd28a04792d2d0be5dfb8e33b3534b2fbd55b" translate="yes" xml:space="preserve">
          <source>Under the hood for every delegated property the Kotlin compiler generates an auxiliary property and delegates to it. For instance, for the property &lt;code&gt;prop&lt;/code&gt; the hidden property &lt;code&gt;prop$delegate&lt;/code&gt; is generated, and the code of the accessors simply delegates to this additional property:</source>
          <target state="translated">すべての委任されたプロパティの内部で、Kotlinコンパイラは補助的なプロパティを生成し、それに委任します。たとえば、プロパティ &lt;code&gt;prop&lt;/code&gt; の場合、非表示のプロパティ &lt;code&gt;prop$delegate&lt;/code&gt; が生成され、アクセサーのコードはこの追加のプロパティに単に委任します。</target>
        </trans-unit>
        <trans-unit id="dd8b30eeb866c4439bd48cb8b3176d8c5f111d35" translate="yes" xml:space="preserve">
          <source>Under the hood, for every delegated property the Kotlin compiler generates an auxiliary property and delegates to it. For instance, for the property &lt;code&gt;prop&lt;/code&gt; the hidden property &lt;code&gt;prop$delegate&lt;/code&gt; is generated, and the code of the accessors simply delegates to this additional property:</source>
          <target state="translated">内部的には、委任されたプロパティごとに、Kotlinコンパイラが補助プロパティを生成してそれに委任します。たとえば、プロパティ &lt;code&gt;prop&lt;/code&gt; の場合、非表示のプロパティ &lt;code&gt;prop$delegate&lt;/code&gt; が生成され、アクセサーのコードは単にこの追加のプロパティに委任します。</target>
        </trans-unit>
        <trans-unit id="3488dca90e45f8e2402977d7d251d68f390541e0" translate="yes" xml:space="preserve">
          <source>Underscore for unused variables (since 1.1)</source>
          <target state="translated">未使用の変数のアンダースコア (1.1以降)</target>
        </trans-unit>
        <trans-unit id="fb79a41a5516422da2e439b9cf71e40fb6fb14d4" translate="yes" xml:space="preserve">
          <source>Underscores for unused parameters</source>
          <target state="translated">未使用のパラメータにはアンダースコア</target>
        </trans-unit>
        <trans-unit id="c1313f733bf8697e7ec5cdf78f97cfd84d52c63d" translate="yes" xml:space="preserve">
          <source>Underscores in numeric literals</source>
          <target state="translated">数字リテラルのアンダースコア</target>
        </trans-unit>
        <trans-unit id="a32a8ccb60d72fd24a8aa497590c0bf8ba9cd8dc" translate="yes" xml:space="preserve">
          <source>Underscores in numeric literals (since 1.1)</source>
          <target state="translated">数字リテラルのアンダースコア (1.1以降)</target>
        </trans-unit>
        <trans-unit id="796b398098842ca0559820831bbb74bc385b8a80" translate="yes" xml:space="preserve">
          <source>Unexpected behavior with &lt;code&gt;in&lt;/code&gt; infix operator and &lt;code&gt;ConcurrentHashMap&lt;/code&gt;</source>
          <target state="translated">中置演算子と &lt;code&gt;ConcurrentHashMap&lt;/code&gt; &lt;code&gt;in&lt;/code&gt; 予期しない動作</target>
        </trans-unit>
        <trans-unit id="1d199ddedf7802afc54d34deabe810e8a6bf5c4f" translate="yes" xml:space="preserve">
          <source>Unfortunately, if you want an empty collection, you need to either declare the resulting collection type explicitly, or supply the element type(s) to the function that constructs the collection:</source>
          <target state="translated">残念ながら、空のコレクションが欲しい場合は、結果として得られるコレクションの型を明示的に宣言するか、コレクションを構築する関数に要素の型を指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="e40bf9bbf42c1f6fc0258d8c13f458aad30b49f2" translate="yes" xml:space="preserve">
          <source>Unfortunately, the code formatter built into IntelliJ IDEA had to work long before this document was released and now has a default setup that produces different formatting from what is now recommended.</source>
          <target state="translated">残念ながら、IntelliJ IDEAに組み込まれたコードフォーマッタは、このドキュメントがリリースされるずっと前から機能しており、現在では、現在推奨されているものとは異なるフォーマットを生成するデフォルトの設定を持っています。</target>
        </trans-unit>
        <trans-unit id="12945de7af176c634a0d8ce8b70c82d42353176c" translate="yes" xml:space="preserve">
          <source>Unfortunately, using this would require us to type &lt;code&gt;p.name.value&lt;/code&gt; every time we wanted to use the property. We could do the following, but that's also not great since it introduces an extra property:</source>
          <target state="translated">残念ながら、これを使用するには、プロパティを使用するたびに &lt;code&gt;p.name.value&lt;/code&gt; を入力する必要があります。次のことを行うことができますが、追加のプロパティが導入されるため、これもすばらしいことではありません。</target>
        </trans-unit>
        <trans-unit id="8837f610cd63014d412facb51aa6f98460391f9a" translate="yes" xml:space="preserve">
          <source>Unicode correctness can be onerous in Python 2, since the &quot;default&quot; string type &lt;code&gt;str&lt;/code&gt; is really just a byte array, while &lt;code&gt;unicode&lt;/code&gt; is actually a sequence of &lt;em&gt;code units&lt;/em&gt; (see below) - and whether the code units are 16 or 32 bits wide depends on how your Python distribution was built. In Kotlin, there's no such confusion: &lt;code&gt;String&lt;/code&gt;, which is what you get when you make a string literal (which you can only do with double quotes), is an immutable sequence of UTF-16 code units. &lt;code&gt;ByteArray&lt;/code&gt; is a fixed-size (but otherwise mutable) byte array (and &lt;code&gt;String&lt;/code&gt; can specifically &lt;em&gt;not&lt;/em&gt; be used as a byte array).</source>
          <target state="translated">「デフォルト」の文字列型 &lt;code&gt;str&lt;/code&gt; は実際には単なるバイト配列であるのに対し、 &lt;code&gt;unicode&lt;/code&gt; は実際には一連の&lt;em&gt;コード単位&lt;/em&gt;（以下を参照）であるため、Unicodeの正確さはPython 2では面倒な場合があります。Pythonディストリビューションの構築方法について。 Kotlinでは、そのような混乱はありません。 &lt;code&gt;String&lt;/code&gt; 列リテラル（二重引用符でのみ実行できる）を作成したときに得られるStringは、UTF-16コード単位の不変のシーケンスです。 &lt;code&gt;ByteArray&lt;/code&gt; は固定サイズ（ただし、それ以外の場合は変更可能）のバイト配列です（ &lt;code&gt;String&lt;/code&gt; はバイト配列として使用でき&lt;em&gt;ません&lt;/em&gt;）。</target>
        </trans-unit>
        <trans-unit id="505d5c38054a74d4b2175415322819ae4849fcad" translate="yes" xml:space="preserve">
          <source>Unified Module Definitions (UMD), which is compatible with both &lt;em&gt;AMD&lt;/em&gt; and &lt;em&gt;CommonJS&lt;/em&gt;, and works as &quot;plain&quot; when neither &lt;em&gt;AMD&lt;/em&gt; nor &lt;em&gt;CommonJS&lt;/em&gt; is available at runtime.</source>
          <target state="translated">&lt;em&gt;AMD&lt;/em&gt;と&lt;em&gt;CommonJSの&lt;/em&gt;両方と互換性のある統合モジュール定義（UMD）&lt;em&gt;。AMD&lt;/em&gt;も&lt;em&gt;CommonJS&lt;/em&gt;も実行時に使用できない場合、「プレーン」として機能します。</target>
        </trans-unit>
        <trans-unit id="de5d8b50b3695e8d25f732afc1acabb23472bc08" translate="yes" xml:space="preserve">
          <source>Unified backends and extensibility</source>
          <target state="translated">統一されたバックエンドと拡張性</target>
        </trans-unit>
        <trans-unit id="cb8c9c639d9b52130075c5077a53018a3b076842" translate="yes" xml:space="preserve">
          <source>Unified exception type for null checks</source>
          <target state="translated">ヌルチェックのための統一された例外タイプ</target>
        </trans-unit>
        <trans-unit id="4b0e76a89bd66d41a17ed421fa008af6ae14f66f" translate="yes" xml:space="preserve">
          <source>Unified standard library</source>
          <target state="translated">統一された標準ライブラリ</target>
        </trans-unit>
        <trans-unit id="c4aff5fbbb595afd545658cb39aa6df5dcca07e6" translate="yes" xml:space="preserve">
          <source>Unify exceptions from null checks</source>
          <target state="translated">ヌルチェックによる例外の統一</target>
        </trans-unit>
        <trans-unit id="c4f58ff59e65d2d98ffef40514cadc0e589f2165" translate="yes" xml:space="preserve">
          <source>Unify split by an empty match regex result across the platforms</source>
          <target state="translated">プラットフォーム間での空マッチ正規表現結果による分割を統一</target>
        </trans-unit>
        <trans-unit id="370ce5f1a9eb1b7143f06590af17c7841cb70b8d" translate="yes" xml:space="preserve">
          <source>UninitializedPropertyAccessException</source>
          <target state="translated">UninitializedPropertyAccessException</target>
        </trans-unit>
        <trans-unit id="a91e29c6a18b3d46ad21babc72fbe12a2806e9d6" translate="yes" xml:space="preserve">
          <source>UnionAudioTrackOrTextTrackOrVideoTrack</source>
          <target state="translated">UnionAudioTrackOrTextTrackOrVideoTrack</target>
        </trans-unit>
        <trans-unit id="b427069e00bef5cd6617471fa2f1c76d7e94c1b0" translate="yes" xml:space="preserve">
          <source>UnionClientOrMessagePortOrServiceWorker</source>
          <target state="translated">UnionClientOrMessagePortOrServiceWorker</target>
        </trans-unit>
        <trans-unit id="10052a20073fd80351eaa98a0618cc05908c3fe2" translate="yes" xml:space="preserve">
          <source>UnionElementOrHTMLCollection</source>
          <target state="translated">UnionElementOrHTMLCollection</target>
        </trans-unit>
        <trans-unit id="64df693fc6248e2d4b802ced57f664db2486df1a" translate="yes" xml:space="preserve">
          <source>UnionElementOrMouseEvent</source>
          <target state="translated">UnionElementOrMouseEvent</target>
        </trans-unit>
        <trans-unit id="5d95156c593ab4f5a1d6aa9b7adaaae5b5072eee" translate="yes" xml:space="preserve">
          <source>UnionElementOrProcessingInstruction</source>
          <target state="translated">UnionElementOrProcessingInstruction</target>
        </trans-unit>
        <trans-unit id="cb794bdbfe712bfdef6a341eb0ffeda3e61df94b" translate="yes" xml:space="preserve">
          <source>UnionElementOrRadioNodeList</source>
          <target state="translated">UnionElementOrRadioNodeList</target>
        </trans-unit>
        <trans-unit id="55e9b0c8b2893c068d7bad4f687cd74e04c97fae" translate="yes" xml:space="preserve">
          <source>UnionHTMLOptGroupElementOrHTMLOptionElement</source>
          <target state="translated">UnionHTMLOptGroupElementOrHTMLOptionElement</target>
        </trans-unit>
        <trans-unit id="9914d6bd1e51362b2ae64dd4e4f0c81df753f3a5" translate="yes" xml:space="preserve">
          <source>UnionMessagePortOrServiceWorker</source>
          <target state="translated">UnionMessagePortOrServiceWorker</target>
        </trans-unit>
        <trans-unit id="9f29b0aeda2c26ba869f1da1baf112b08de48285" translate="yes" xml:space="preserve">
          <source>UnionMessagePortOrWindow</source>
          <target state="translated">UnionMessagePortOrWindow</target>
        </trans-unit>
        <trans-unit id="0bdbd6bc95c6e23b6042a486f6d277c7a15fc86a" translate="yes" xml:space="preserve">
          <source>UnionMessagePortOrWindowProxy</source>
          <target state="translated">UnionMessagePortOrWindowProxy</target>
        </trans-unit>
        <trans-unit id="f6b935ab337145efdeadda28cae18aa89a845e36" translate="yes" xml:space="preserve">
          <source>Unit</source>
          <target state="translated">Unit</target>
        </trans-unit>
        <trans-unit id="6e47e918985f3919c21cc4a5d827ef9eada3d607" translate="yes" xml:space="preserve">
          <source>Unit return type. Must not be nullable</source>
          <target state="translated">ユニットの戻り値のタイプ。ヌル可能であってはなりません。</target>
        </trans-unit>
        <trans-unit id="0cc244abccf5ca3308a1494c12878b0d0e26feea" translate="yes" xml:space="preserve">
          <source>Unit-returning functions</source>
          <target state="translated">ユニットリターン機能</target>
        </trans-unit>
        <trans-unit id="4e0950ee26dcc7da4ca806b4b340177a815e5066" translate="yes" xml:space="preserve">
          <source>Unless specified otherwise, the names of functions and modules can be &lt;a href=&quot;js-to-kotlin-interop#jsname-annotation&quot;&gt;mangled&lt;/a&gt; in the generated JavaScript code. To keep such functions from elimination, use the mangled names in the &lt;code&gt;keep&lt;/code&gt; arguments as they appear in the generated JavaScript code.</source>
          <target state="translated">特に指定のない限り、関数とモジュールの名前は、生成されたJavaScriptコードで&lt;a href=&quot;js-to-kotlin-interop#jsname-annotation&quot;&gt;マングル&lt;/a&gt;される可能性があります。このような関数が削除されないようにするには、生成されたJavaScriptコードに表示される &lt;code&gt;keep&lt;/code&gt; 引数でマングルされた名前を使用します。</target>
        </trans-unit>
        <trans-unit id="e885d6886100fb26b71f7747ee932dbb05e71ce7" translate="yes" xml:space="preserve">
          <source>Unless you're working on a library, omit redundant modifiers (e.g. &lt;code&gt;public&lt;/code&gt;).</source>
          <target state="translated">ライブラリで作業しているのでない限り、冗長な修飾子（例： &lt;code&gt;public&lt;/code&gt; ）を省略します。</target>
        </trans-unit>
        <trans-unit id="8feafcdb2005e6ef556074da45e878f1b7bc1d3a" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;suspend-coroutine-or-return&quot;&gt;suspendCoroutineOrReturn&lt;/a&gt; it does not intercept continuation.</source>
          <target state="translated">&lt;a href=&quot;suspend-coroutine-or-return&quot;&gt;suspendCoroutineOrReturn&lt;/a&gt;とは異なり、継続をインターセプトしません。</target>
        </trans-unit>
        <trans-unit id="b5baaedd3e64f7be16b02c01618d1a48a2f53082" translate="yes" xml:space="preserve">
          <source>Unlike Java, Kotlin does not have a separate &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/technotes/guides/language/static-import.html&quot;&gt;&quot;import static&quot;&lt;/a&gt; syntax; all of these declarations are imported using the regular &lt;code&gt;import&lt;/code&gt; keyword.</source>
          <target state="translated">Javaとは異なり、Kotlinには個別の&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/technotes/guides/language/static-import.html&quot;&gt;「静的インポート」&lt;/a&gt;構文はありません。これらの宣言はすべて、通常の &lt;code&gt;import&lt;/code&gt; キーワードを使用してインポートされます。</target>
        </trans-unit>
        <trans-unit id="7e26e1701ff3fbdbd8ab214ddee2ab24ae9fb3e0" translate="yes" xml:space="preserve">
          <source>Unlike Java, block comments in Kotlin can be nested.</source>
          <target state="translated">Javaとは異なり、Kotlinのブロックコメントは入れ子にすることができます。</target>
        </trans-unit>
        <trans-unit id="d71d4e303da5f24db04f06a7b993b10b6d2cf202" translate="yes" xml:space="preserve">
          <source>Unlike Python, &lt;code&gt;try&lt;/code&gt;/&lt;code&gt;catch&lt;/code&gt; is an expression: the last expression of the &lt;code&gt;try&lt;/code&gt; block (if it succeeds) or the chosen &lt;code&gt;catch&lt;/code&gt; block becomes the result value (&lt;code&gt;finally&lt;/code&gt; doesn't affect the result), so we can refactor the function body above to:</source>
          <target state="translated">Pythonとは異なり、 &lt;code&gt;try&lt;/code&gt; / &lt;code&gt;catch&lt;/code&gt; は式です &lt;code&gt;try&lt;/code&gt; ブロックの最後の式（成功した場合）または選択した &lt;code&gt;catch&lt;/code&gt; ブロックが結果の値になり（ &lt;code&gt;finally&lt;/code&gt; に結果に影響しません）、上記の関数本体を次のようにリファクタリングできます：</target>
        </trans-unit>
        <trans-unit id="9ffcb8e6d8c0e1886c9139362bf8a80448f390b9" translate="yes" xml:space="preserve">
          <source>Unlike a queue, a channel can be closed to indicate that no more elements are coming. On the receiver side it is convenient to use a regular &lt;code&gt;for&lt;/code&gt; loop to receive elements from the channel.</source>
          <target state="translated">キューとは異なり、チャネルを閉じて、これ以上要素が来ないことを示すことができます。受信側では、通常の &lt;code&gt;for&lt;/code&gt; ループを使用してチャネルから要素を受信すると便利です。</target>
        </trans-unit>
        <trans-unit id="79736268c87ef812b5a0caf77be57b249d138010" translate="yes" xml:space="preserve">
          <source>Unlike docstrings, KDoc blocks are not available to the program at runtime.</source>
          <target state="translated">docstringsとは異なり、KDocブロックは実行時にプログラムが利用できません。</target>
        </trans-unit>
        <trans-unit id="9e77ba9444bad622fec50b4242ad0088f476d99f" translate="yes" xml:space="preserve">
          <source>Unlike other pointers, the parameters of type &lt;code&gt;const char*&lt;/code&gt; are represented as a Kotlin &lt;code&gt;String&lt;/code&gt;. So it is possible to pass any Kotlin string to a binding expecting a C string.</source>
          <target state="translated">他のポインターとは異なり、 &lt;code&gt;const char*&lt;/code&gt; 型のパラメーターはKotlin &lt;code&gt;String&lt;/code&gt; として表されます。したがって、C文字列を想定しているバインディングに任意のKotlin文字列を渡すことが可能です。</target>
        </trans-unit>
        <trans-unit id="cd3405f910e07d811413c0ab883fbacf2fe2d5fb" translate="yes" xml:space="preserve">
          <source>Unlike sources that can be fixed by hand in the worst case, binaries are a lot harder to migrate, and this makes backwards compatibility very important in the case of binaries. Incompatible changes to binaries can make updates very uncomfortable and thus should be introduced with even more care than those in the source language syntax.</source>
          <target state="translated">最悪の場合に手で修正できるソースとは異なり、バイナリは移行が非常に困難であるため、バイナリの場合は後方互換性が非常に重要になります。バイナリへの互換性のない変更はアップデートを非常に不快にさせるので、ソース言語の構文にあるものよりもさらに注意して導入する必要があります。</target>
        </trans-unit>
        <trans-unit id="71ea4413722e85a3b020d9ed01e939aac7d2c7c0" translate="yes" xml:space="preserve">
          <source>Unlike the overload that accepts an argument of type &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/StringBuffer.html&quot;&gt;StringBuffer&lt;/a&gt;, this function does not compare this string and the specified &lt;a href=&quot;../kotlin/-char-sequence/index#kotlin.CharSequence&quot;&gt;CharSequence&lt;/a&gt; in a synchronized block.</source>
          <target state="translated">&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/StringBuffer.html&quot;&gt;StringBuffer&lt;/a&gt;型の引数を受け入れるオーバーロードとは異なり、この関数は、この文字列と同期ブロック内の指定された&lt;a href=&quot;../kotlin/-char-sequence/index#kotlin.CharSequence&quot;&gt;CharSequence&lt;/a&gt;を比較しません。</target>
        </trans-unit>
        <trans-unit id="418fd8181d764c26cb6aebed80be5ec76fed83e8" translate="yes" xml:space="preserve">
          <source>Unsafe mode is intended for most performance critical operations, where object graph ownership is expected to be correct (such as application debugged earlier in &lt;a href=&quot;-s-a-f-e&quot;&gt;SAFE&lt;/a&gt; mode), just transfers ownership without further checks.</source>
          <target state="translated">安全でないモードは、オブジェクトグラフの所有権が正しいことが期待されるほとんどのパフォーマンスクリティカルな操作（&lt;a href=&quot;-s-a-f-e&quot;&gt;SAFE&lt;/a&gt;モードで以前にデバッグされたアプリケーションなど）を対象としています。</target>
        </trans-unit>
        <trans-unit id="eb25c274c554703f1d6ac7eff8cabedc73b12953" translate="yes" xml:space="preserve">
          <source>UnsafeVariance</source>
          <target state="translated">UnsafeVariance</target>
        </trans-unit>
        <trans-unit id="cfba46d6859cfbbcea2df0d333b94927ce585d13" translate="yes" xml:space="preserve">
          <source>Unsigned arithmetics</source>
          <target state="translated">符号なし算術</target>
        </trans-unit>
        <trans-unit id="5c5289ec1ae0731b7a3321d477acd024a60473b2" translate="yes" xml:space="preserve">
          <source>Unsigned integers</source>
          <target state="translated">符号なし整数</target>
        </trans-unit>
        <trans-unit id="5b676d18e8ccf61f5e227df4adab6b4ac25f32fd" translate="yes" xml:space="preserve">
          <source>Unsigned integers are available only since Kotlin 1.3 and currently are &lt;em&gt;experimental&lt;/em&gt;. See details in the &lt;a href=&quot;basic-types#experimental-status-of-unsigned-integers&quot;&gt;reference&lt;/a&gt;.</source>
          <target state="translated">符号なし整数は、Kotlin 1.3以降でのみ使用でき、現在&lt;em&gt;実験&lt;/em&gt;段階です。詳細は&lt;a href=&quot;basic-types#experimental-status-of-unsigned-integers&quot;&gt;リファレンスを&lt;/a&gt;ご覧ください。</target>
        </trans-unit>
        <trans-unit id="c3f300d5a964ee1dfe6f01eeb8815de2c1adedd0" translate="yes" xml:space="preserve">
          <source>Unsigned integers are available only since Kotlin 1.3 and currently are in &lt;a href=&quot;evolution/components-stability&quot;&gt;Beta&lt;/a&gt;. See details in the &lt;a href=&quot;basic-types#beta-status-of-unsigned-integers&quot;&gt;reference&lt;/a&gt;.</source>
          <target state="translated">符号なし整数は、Kotlin 1.3以降でのみ使用可能であり、現在&lt;a href=&quot;evolution/components-stability&quot;&gt;ベータ版&lt;/a&gt;です。詳細については、&lt;a href=&quot;basic-types#beta-status-of-unsigned-integers&quot;&gt;リファレンス&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="b747e738f03e7ea5b53d3e97fc3d06bb2fdd5460" translate="yes" xml:space="preserve">
          <source>Unsigned types are available only since Kotlin 1.3 and currently are &lt;em&gt;experimental&lt;/em&gt;. See details &lt;a href=&quot;#experimental-status-of-unsigned-integers&quot;&gt;below&lt;/a&gt;</source>
          <target state="translated">符号なしの型は、Kotlin 1.3以降でのみ使用でき、現在&lt;em&gt;実験&lt;/em&gt;段階です。&lt;a href=&quot;#experimental-status-of-unsigned-integers&quot;&gt;以下の&lt;/a&gt;詳細を参照してください</target>
        </trans-unit>
        <trans-unit id="2d65bd8aeb4b2e88a04a2f25ed0b812fa94ab0cb" translate="yes" xml:space="preserve">
          <source>Unsigned types are available only since Kotlin 1.3 and currently in &lt;a href=&quot;evolution/components-stability&quot;&gt;Beta&lt;/a&gt;. See details &lt;a href=&quot;#beta-status-of-unsigned-integers&quot;&gt;below&lt;/a&gt;</source>
          <target state="translated">符号なしタイプは、Kotlin 1.3以降、現在&lt;a href=&quot;evolution/components-stability&quot;&gt;ベータ版で&lt;/a&gt;のみ使用できます。&lt;a href=&quot;#beta-status-of-unsigned-integers&quot;&gt;以下の&lt;/a&gt;詳細を参照してください</target>
        </trans-unit>
        <trans-unit id="c69f19b70030748472412cf013c7f8262fa5cc73" translate="yes" xml:space="preserve">
          <source>Unsigned types are implemented using another experimental feature, namely &lt;a href=&quot;inline-classes&quot;&gt;inline classes&lt;/a&gt;.</source>
          <target state="translated">符号なしの型は、別の実験的機能、つまり&lt;a href=&quot;inline-classes&quot;&gt;インラインクラス&lt;/a&gt;を使用して実装されます。</target>
        </trans-unit>
        <trans-unit id="963c1b3d4bd7cb3c897cb1ca5167eb9af57242de" translate="yes" xml:space="preserve">
          <source>Unsigned types are implemented using another feature that's not yet stable, namely &lt;a href=&quot;inline-classes&quot;&gt;inline classes&lt;/a&gt;.</source>
          <target state="translated">符号なし型は、まだ安定していない別の機能、つまり&lt;a href=&quot;inline-classes&quot;&gt;インラインクラス&lt;/a&gt;を使用して実装されます。</target>
        </trans-unit>
        <trans-unit id="22647f2117d5ec2026da9b7edc1161d8603f0593" translate="yes" xml:space="preserve">
          <source>Unsigned types support most of the operations of their signed counterparts.</source>
          <target state="translated">符号なし型は、符号付きの対応するもののほとんどの操作をサポートしています。</target>
        </trans-unit>
        <trans-unit id="a84f8397c523a0f7323640840daf25c5d28f242d" translate="yes" xml:space="preserve">
          <source>Unsound smartcasts on enum members</source>
          <target state="translated">enumメンバのスマートキャストの音が出ない</target>
        </trans-unit>
        <trans-unit id="fb52c13a5d3c511932c9721a05a0f30bebc8f773" translate="yes" xml:space="preserve">
          <source>Unsupported</source>
          <target state="translated">Unsupported</target>
        </trans-unit>
        <trans-unit id="d6b9cc70af4626956ac004db8653f110603b7231" translate="yes" xml:space="preserve">
          <source>UnsupportedOperationException</source>
          <target state="translated">UnsupportedOperationException</target>
        </trans-unit>
        <trans-unit id="2ce01f081a0318f94ee11d34764838aaa22a8009" translate="yes" xml:space="preserve">
          <source>Unused declarations can appear in cases like:</source>
          <target state="translated">未使用の宣言は、次のような場合に現れます。</target>
        </trans-unit>
        <trans-unit id="7d866719de20162a43b046be2b1dd937f0e0c8b0" translate="yes" xml:space="preserve">
          <source>Unzip the standalone compiler into a directory and optionally add the &lt;code&gt;bin&lt;/code&gt; directory to the system path. The &lt;code&gt;bin&lt;/code&gt; directory contains the scripts needed to compile and run Kotlin on Windows, OS X and Linux.</source>
          <target state="translated">スタンドアロンコンパイラをディレクトリに解凍し、オプションで &lt;code&gt;bin&lt;/code&gt; ディレクトリをシステムパスに追加します。 &lt;code&gt;bin&lt;/code&gt; ディレクトリには、Windows、OS XとLinux上でKotlinをコンパイルして実行するために必要なスクリプトが含まれています。</target>
        </trans-unit>
        <trans-unit id="ab7b8830d7d19c631f4db7f0e7cccdc5fc99c4ae" translate="yes" xml:space="preserve">
          <source>Update Gradle</source>
          <target state="translated">アップデートGradle</target>
        </trans-unit>
        <trans-unit id="bd35499f667636f0205aff356fc79aa271c4a159" translate="yes" xml:space="preserve">
          <source>Update the application</source>
          <target state="translated">アプリケーションの更新</target>
        </trans-unit>
        <trans-unit id="756c6de970516b187b891362c635541de1071978" translate="yes" xml:space="preserve">
          <source>Update to version A (where the change is announced)</source>
          <target state="translated">バージョンAへのアップデート(変更が発表された場所</target>
        </trans-unit>
        <trans-unit id="a8909313fb96928caf2b3605836e51265cd9382c" translate="yes" xml:space="preserve">
          <source>Update to version B (where the change happens)</source>
          <target state="translated">バージョンBへのアップデート(変更が発生する場所</target>
        </trans-unit>
        <trans-unit id="bc69b0f01bd4bf2a5762f9802698425322ca8ecc" translate="yes" xml:space="preserve">
          <source>Updates this map with key/value pairs from the specified map &lt;a href=&quot;../-mutable-map/put-all#kotlin.collections.MutableMap%24putAll%28kotlin.collections.Map%28%28kotlin.collections.MutableMap.K%2C+kotlin.collections.MutableMap.V%29%29%29%2Ffrom&quot;&gt;from&lt;/a&gt;.</source>
          <target state="translated">指定されたマップからキー/値ペアで、このマップを更新します&lt;a href=&quot;../-mutable-map/put-all#kotlin.collections.MutableMap%24putAll%28kotlin.collections.Map%28%28kotlin.collections.MutableMap.K%2C+kotlin.collections.MutableMap.V%29%29%29%2Ffrom&quot;&gt;から&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bb9919809e0edbf2ce222896374072b2a1f62288" translate="yes" xml:space="preserve">
          <source>Updates this map with key/value pairs from the specified map &lt;a href=&quot;../-mutable-map/put-all#kotlin.collections.MutableMap%24putAll(kotlin.collections.Map((kotlin.collections.MutableMap.K,%20kotlin.collections.MutableMap.V)))/from&quot;&gt;from&lt;/a&gt;.</source>
          <target state="translated">指定されたマップからキー/値ペアで、このマップを更新します&lt;a href=&quot;../-mutable-map/put-all#kotlin.collections.MutableMap%24putAll(kotlin.collections.Map((kotlin.collections.MutableMap.K,%20kotlin.collections.MutableMap.V)))/from&quot;&gt;から&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9592e59ae4a1ea78ffeef819217ff2d297efc8bf" translate="yes" xml:space="preserve">
          <source>Updates this map with key/value pairs from the specified map &lt;a href=&quot;put-all#kotlin.collections.MutableMap%24putAll%28kotlin.collections.Map%28%28kotlin.collections.MutableMap.K%2C+kotlin.collections.MutableMap.V%29%29%29%2Ffrom&quot;&gt;from&lt;/a&gt;.</source>
          <target state="translated">指定されたマップからキー/値ペアで、このマップを更新します&lt;a href=&quot;put-all#kotlin.collections.MutableMap%24putAll%28kotlin.collections.Map%28%28kotlin.collections.MutableMap.K%2C+kotlin.collections.MutableMap.V%29%29%29%2Ffrom&quot;&gt;から&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2ea39222df240b93c342df8ff54a9cb5e6582800" translate="yes" xml:space="preserve">
          <source>Updates this map with key/value pairs from the specified map &lt;a href=&quot;put-all#kotlin.collections.MutableMap%24putAll(kotlin.collections.Map((kotlin.collections.MutableMap.K,%20kotlin.collections.MutableMap.V)))/from&quot;&gt;from&lt;/a&gt;.</source>
          <target state="translated">指定されたマップからキー/値ペアで、このマップを更新します&lt;a href=&quot;put-all#kotlin.collections.MutableMap%24putAll(kotlin.collections.Map((kotlin.collections.MutableMap.K,%20kotlin.collections.MutableMap.V)))/from&quot;&gt;から&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ec6952e09b9cc6aee90f3110c55ff105e4facbf9" translate="yes" xml:space="preserve">
          <source>Updating</source>
          <target state="translated">Updating</target>
        </trans-unit>
        <trans-unit id="d63c48198d515b24d1b1b235598c3c48c2a4be5a" translate="yes" xml:space="preserve">
          <source>Updating Gradle Scripts</source>
          <target state="translated">Gradle スクリプトの更新</target>
        </trans-unit>
        <trans-unit id="408c0db23a4308cddf6a6e9ce2a0a6679db93544" translate="yes" xml:space="preserve">
          <source>Updating elements</source>
          <target state="translated">要素の更新</target>
        </trans-unit>
        <trans-unit id="5db2b695ba29ebd7f0ca8dec803b6b54c73ec2a6" translate="yes" xml:space="preserve">
          <source>Upper bounds</source>
          <target state="translated">上限</target>
        </trans-unit>
        <trans-unit id="6fe7e1ccf58a63e3bc126e60c26bcc1a9fac8e17" translate="yes" xml:space="preserve">
          <source>Upper bounds, or generic constraints imposed on this type parameter. See the &lt;a href=&quot;../../../../../../docs/reference/generics#upper-bounds&quot;&gt;Kotlin language documentation&lt;/a&gt; for more information.</source>
          <target state="translated">上限、またはこの型パラメーターに課せられた一般的な制約。詳細については、&lt;a href=&quot;../../../../../../docs/reference/generics#upper-bounds&quot;&gt;Kotlin言語のドキュメント&lt;/a&gt;をご覧ください。</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Usage</target>
        </trans-unit>
        <trans-unit id="034e0e826c171bc69a42734bf5f512ba3665a32d" translate="yes" xml:space="preserve">
          <source>Usage of the &lt;code&gt;!!&lt;/code&gt; operator that is described below;</source>
          <target state="translated">の使い方 &lt;code&gt;!!&lt;/code&gt; 以下で説明する演算子。</target>
        </trans-unit>
        <trans-unit id="e1820bd9f032e11eff310c40682c9835a9eb3203" translate="yes" xml:space="preserve">
          <source>Usage of the deprecated element will be reported as a warning.</source>
          <target state="translated">非推奨要素の使用は警告として報告されます。</target>
        </trans-unit>
        <trans-unit id="8a6da2a0224bff4d0cdbf931eb3f79ea3c663d17" translate="yes" xml:space="preserve">
          <source>Usage of the deprecated element will be reported as an error.</source>
          <target state="translated">非推奨要素の使用はエラーとして報告されます。</target>
        </trans-unit>
        <trans-unit id="2f2278b9118c021e0836f33b45c4b344bc07faf3" translate="yes" xml:space="preserve">
          <source>Usages of such API will be reported as warnings unless an explicit opt-in with the &lt;a href=&quot;../-opt-in/index&quot;&gt;OptIn&lt;/a&gt; annotation, e.g. &lt;code&gt;@OptIn(ExperimentalUnsignedTypes::class)&lt;/code&gt;, or with the &lt;code&gt;-Xopt-in=kotlin.ExperimentalUnsignedTypes&lt;/code&gt; compiler option is given.</source>
          <target state="translated">このようなAPIの使用は、&lt;a href=&quot;../-opt-in/index&quot;&gt;OptIn&lt;/a&gt;アノテーション &lt;code&gt;@OptIn(ExperimentalUnsignedTypes::class)&lt;/code&gt; など）または &lt;code&gt;-Xopt-in=kotlin.ExperimentalUnsignedTypes&lt;/code&gt; コンパイラオプションを使用した明示的なオプトインが指定されていない限り、警告として報告されます。</target>
        </trans-unit>
        <trans-unit id="5b2bd12dd174680813870a73e531a53b2704ad9f" translate="yes" xml:space="preserve">
          <source>Usages of such API will be reported as warnings unless an explicit opt-in with the &lt;a href=&quot;../-use-experimental/index&quot;&gt;UseExperimental&lt;/a&gt; annotation, e.g. &lt;code&gt;@UseExperimental(ExperimentalUnsignedTypes::class)&lt;/code&gt;, or with the &lt;code&gt;-Xuse-experimental=kotlin.ExperimentalUnsignedTypes&lt;/code&gt; compiler option is given.</source>
          <target state="translated">そのようなAPIの使用は、&lt;a href=&quot;../-use-experimental/index&quot;&gt;UseExperimental&lt;/a&gt;アノテーション &lt;code&gt;@UseExperimental(ExperimentalUnsignedTypes::class)&lt;/code&gt; など）を明示的にオプトインするか、または &lt;code&gt;-Xuse-experimental=kotlin.ExperimentalUnsignedTypes&lt;/code&gt; コンパイラオプションを指定しない限り、警告として報告されます。</target>
        </trans-unit>
        <trans-unit id="17a2b4afa5d97d07993ae00f2065c3a2c91e4e36" translate="yes" xml:space="preserve">
          <source>Usages of such annotations will be reported as warnings unless an explicit opt-in with the &lt;a href=&quot;../../kotlin/-opt-in/index&quot;&gt;OptIn&lt;/a&gt; annotation, e.g. &lt;code&gt;@OptIn(ExperimentalJsExport::class)&lt;/code&gt;, or with the &lt;code&gt;-Xopt-in=kotlin.js.ExperimentalJsExport&lt;/code&gt; compiler option is given.</source>
          <target state="translated">&lt;code&gt;@OptIn(ExperimentalJsExport::class)&lt;/code&gt; などの&lt;a href=&quot;../../kotlin/-opt-in/index&quot;&gt;OptIn&lt;/a&gt;アノテーション、または &lt;code&gt;-Xopt-in=kotlin.js.ExperimentalJsExport&lt;/code&gt; コンパイラオプションを使用した明示的なオプトインが指定されていない限り、このようなアノテーションの使用は警告として報告されます。</target>
        </trans-unit>
        <trans-unit id="5461bf95a53302a7c5df48274f6a4f3517903597" translate="yes" xml:space="preserve">
          <source>Usages of this annotation require an explicit compilation argument to be specified: either &lt;code&gt;-Xjvm-default=enable&lt;/code&gt; or &lt;code&gt;-Xjvm-default=compatibility&lt;/code&gt;.</source>
          <target state="translated">このアノテーションを使用するには、 &lt;code&gt;-Xjvm-default=enable&lt;/code&gt; または &lt;code&gt;-Xjvm-default=compatibility&lt;/code&gt; のいずれかの明示的なコンパイル引数を指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="070afea0c959ac4ab2122b78be879a1236b7d5f2" translate="yes" xml:space="preserve">
          <source>Use 4 spaces for indentation. Do not use tabs.</source>
          <target state="translated">インデントには4つのスペースを使用してください。タブは使用しないでください。</target>
        </trans-unit>
        <trans-unit id="505b02e2c68810a100167ed2394b7b09d07536b9" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;#calling-kotlin-code-from-swift&quot;&gt;Kotlin from Swift&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#calling-kotlin-code-from-swift&quot;&gt;SwiftのKotlinを&lt;/a&gt;使用する</target>
        </trans-unit>
        <trans-unit id="259f61d0fe4d9980f69dcb9a143f67a783be3566" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;../-simple-effect/implies&quot;&gt;SimpleEffect.implies&lt;/a&gt; function to describe a conditional effect that happens in such case.</source>
          <target state="translated">&lt;a href=&quot;../-simple-effect/implies&quot;&gt;SimpleEffect.implies&lt;/a&gt;関数を使用して、このような場合に発生する条件付き効果を記述します。</target>
        </trans-unit>
        <trans-unit id="7b3d7f2e06019f3ce17f9b7609b4e12a0a852225" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;../java.io.-file/walk&quot;&gt;File.walk&lt;/a&gt;, &lt;a href=&quot;../java.io.-file/walk-top-down&quot;&gt;File.walkTopDown&lt;/a&gt; or &lt;a href=&quot;../java.io.-file/walk-bottom-up&quot;&gt;File.walkBottomUp&lt;/a&gt; extension functions to instantiate a &lt;code&gt;FileTreeWalk&lt;/code&gt; instance.</source>
          <target state="translated">&lt;a href=&quot;../java.io.-file/walk&quot;&gt;File.walk&lt;/a&gt;、&lt;a href=&quot;../java.io.-file/walk-top-down&quot;&gt;File.walkTopDown&lt;/a&gt;または&lt;a href=&quot;../java.io.-file/walk-bottom-up&quot;&gt;File.walkBottomUp&lt;/a&gt;拡張関数を使用して、 &lt;code&gt;FileTreeWalk&lt;/code&gt; インスタンスをインスタンス化します。</target>
        </trans-unit>
        <trans-unit id="24479d1c98fbbe2aeb0187678fa3eb554ac97484" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;https://github.com/bintray/gradle-bintray-plugin/issues/229#issuecomment-473123891&quot;&gt;a workaround for the Bintray plugin&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://github.com/bintray/gradle-bintray-plugin/issues/229#issuecomment-473123891&quot;&gt;Bintrayプラグインの回避策を&lt;/a&gt;使用する</target>
        </trans-unit>
        <trans-unit id="855c22b8caa56aad8a88d87618784ee61265712d" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;apply&lt;/code&gt; for code blocks that don't return a value and mainly operate on the members of the receiver object. The common case for &lt;code&gt;apply&lt;/code&gt; is the object configuration. Such calls can be read as &amp;ldquo;&lt;em&gt;apply the following assignments to the object.&lt;/em&gt;&amp;rdquo;</source>
          <target state="translated">値を返さず、主にレシーバーオブジェクトのメンバーを操作するコードブロックには、 &lt;code&gt;apply&lt;/code&gt; を使用します。 &lt;code&gt;apply&lt;/code&gt; の一般的なケースは、オブジェクト構成です。このような呼び出しは&lt;em&gt;、次の&lt;/em&gt;ように読み取ることができ&lt;em&gt;ます。&lt;/em&gt;」</target>
        </trans-unit>
        <trans-unit id="6ba975b0b8793e55988fa1e5cd1c3f8baae89326" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;arguments {}&lt;/code&gt; block to pass arguments to annotation processors:</source>
          <target state="translated">&lt;code&gt;arguments {}&lt;/code&gt; ブロックを使用して、引数を注釈プロセッサに渡します。</target>
        </trans-unit>
        <trans-unit id="9068946a50ad967859350bf76f77d127a3ad6ba3" translate="yes" xml:space="preserve">
          <source>Use C function pointer from Kotlin</source>
          <target state="translated">KotlinからC言語の関数ポインタを使用</target>
        </trans-unit>
        <trans-unit id="8d59d0d06987ce05b43d207e59345cd58bf6234b" translate="yes" xml:space="preserve">
          <source>Use Gradle 6.0 and above to generate wrapper (&lt;code&gt;gradle wrapper&lt;/code&gt;) in the project root directory to generate &lt;code&gt;gradlew&lt;/code&gt;, &lt;code&gt;gradlew.bat&lt;/code&gt;, and &lt;code&gt;gradle/wrapper/gradle-wrapper.jar&lt;/code&gt;.</source>
          <target state="translated">Gradle 6.0以降を使用して、プロジェクトルートディレクトリにラッパー（ &lt;code&gt;gradle wrapper&lt;/code&gt; ）を生成し、 &lt;code&gt;gradlew&lt;/code&gt; 、 &lt;code&gt;gradlew.bat&lt;/code&gt; 、およびgradle &lt;code&gt;gradle/wrapper/gradle-wrapper.jar&lt;/code&gt; /gradle-wrapper.jarを生成します。</target>
        </trans-unit>
        <trans-unit id="7f14c4d527695edd872c7fe2172a6db2f31e9728" translate="yes" xml:space="preserve">
          <source>Use Kotlin from node.js with CommonJS</source>
          <target state="translated">CommonJSでnode.jsからKotlinを使う</target>
        </trans-unit>
        <trans-unit id="7955d34ca487ac99a425deedc1ddb62d16416242" translate="yes" xml:space="preserve">
          <source>Use Kotlin in the browser with AMD</source>
          <target state="translated">AMDでブラウザでKotlinを使う</target>
        </trans-unit>
        <trans-unit id="80ebd15dbf9fc53c163f2e8494fee09225815763" translate="yes" xml:space="preserve">
          <source>Use a &lt;a href=&quot;../../reference/basic-types#string-templates&quot;&gt;string template&lt;/a&gt; for your reversed name by adding a dollar sign &lt;code&gt;$&lt;/code&gt; and enclosing it in curly braces &amp;ndash; &lt;code&gt;${state.name.reversed()}&lt;/code&gt;.</source>
          <target state="translated">ドル記号 &lt;code&gt;$&lt;/code&gt; を追加し、中括弧 &lt;code&gt;${state.name.reversed()}&lt;/code&gt; 囲むことにより、逆の名前に&lt;a href=&quot;../../reference/basic-types#string-templates&quot;&gt;文字列テンプレート&lt;/a&gt;を使用します。</target>
        </trans-unit>
        <trans-unit id="2449126f023eebada4dc8166f2d086abc1f70c85" translate="yes" xml:space="preserve">
          <source>Use a &lt;a href=&quot;../../reference/basic-types#string-templates&quot;&gt;string template&lt;/a&gt; to insert your name length into the string by adding a dollar sign &lt;code&gt;$&lt;/code&gt; and enclosing it in curly braces &amp;ndash; &lt;code&gt;${it.length}&lt;/code&gt;. &lt;code&gt;it&lt;/code&gt; is the default name of a &lt;a href=&quot;../../reference/coding-conventions#lambda-parameters&quot;&gt;lambda parameter&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../reference/basic-types#string-templates&quot;&gt;文字列テンプレート&lt;/a&gt;を使用して、ドル記号 &lt;code&gt;$&lt;/code&gt; を追加し、中括弧 &lt;code&gt;${it.length}&lt;/code&gt; 囲むことにより、名前の長さを文字列に挿入します。 &lt;code&gt;it&lt;/code&gt; デフォルトの名前である&lt;a href=&quot;../../reference/coding-conventions#lambda-parameters&quot;&gt;ラムダパラメータ&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="567ed77b3fedba236234b46ed9dd13b2639d5a1d" translate="yes" xml:space="preserve">
          <source>Use a Kotlin Gradle project as a CocoaPods dependency</source>
          <target state="translated">CocoaPodsの依存関係としてKotlin Gradleプロジェクトを使う</target>
        </trans-unit>
        <trans-unit id="dad9d5856fb71823437fdf612d7806d4ef4bcde8" translate="yes" xml:space="preserve">
          <source>Use a custom JDK home directory to include into the classpath if it differs from the default &lt;code&gt;JAVA_HOME&lt;/code&gt;.</source>
          <target state="translated">デフォルトの &lt;code&gt;JAVA_HOME&lt;/code&gt; と異なる場合は、カスタムJDKホームディレクトリを使用してクラスパスに含めます。</target>
        </trans-unit>
        <trans-unit id="5dafba398135044480a3e13e8cf827e6d5239bcb" translate="yes" xml:space="preserve">
          <source>Use a function returning nullable value:</source>
          <target state="translated">ヌル可能な値を返す関数を使用します。</target>
        </trans-unit>
        <trans-unit id="09ab22034a8c650e65b27de7b44cb4d61caf9b2b" translate="yes" xml:space="preserve">
          <source>Use a string template by adding a dollar sign &lt;code&gt;$&lt;/code&gt; before this variable name directly in the text output like this &amp;ndash; &lt;code&gt;$name&lt;/code&gt;.</source>
          <target state="translated">次のようにテキスト出力で直接この変数名の前にドル記号 &lt;code&gt;$&lt;/code&gt; を追加して、文字列テンプレートを使用します&amp;ndash; &lt;code&gt;$name&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6761a777f295b6258dc7a19c0a25a2a4cc06a051" translate="yes" xml:space="preserve">
          <source>Use any members that don't mention the star-projected type parameter(s) at all</source>
          <target state="translated">star-projected 型のパラメータに全く言及しないメンバーを使用します。</target>
        </trans-unit>
        <trans-unit id="02c711d6a5cfe540ce71589b8b208d49d3883457" translate="yes" xml:space="preserve">
          <source>Use any members that return the star-projected type parameter(s), but the return type will appear to be &lt;code&gt;Any?&lt;/code&gt; (unless the type parameter is constrained, in which case you'll get the type mentioned in the constraint)</source>
          <target state="translated">star-projected型パラメーターを返すメンバーを使用しますが、戻り型は &lt;code&gt;Any?&lt;/code&gt; と表示されますか？（型パラメーターが制約されていない場合、その場合、制約で言及されている型を取得します）</target>
        </trans-unit>
        <trans-unit id="14a29ba383c84d15925a42f871530f52904ae908" translate="yes" xml:space="preserve">
          <source>Use cases</source>
          <target state="translated">使用事例</target>
        </trans-unit>
        <trans-unit id="6914afc57d4eceefab3ce74c4e34c13830de00b1" translate="yes" xml:space="preserve">
          <source>Use dynamic to interact with libraries</source>
          <target state="translated">ダイナミックを使用してライブラリと対話する</target>
        </trans-unit>
        <trans-unit id="a696c211088879b039bc564a3a89ee0e5d5cf819" translate="yes" xml:space="preserve">
          <source>Use extension functions liberally. Every time you have a function that works primarily on an object, consider making it an extension function accepting that object as a receiver. To minimize API pollution, restrict the visibility of extension functions as much as it makes sense. As necessary, use local extension functions, member extension functions, or top-level extension functions with private visibility.</source>
          <target state="translated">拡張関数を自由に使いましょう。主にオブジェクトに対して動作する関数を持つたびに、そのオブジェクトをレシーバとして受け入れる拡張関数にすることを検討してください。API汚染を最小限に抑えるために、拡張関数の可視性を理にかなった範囲で制限してください。必要に応じて、ローカルの拡張関数、メンバーの拡張関数、またはプライベートな可視性を持つトップレベルの拡張関数を使用します。</target>
        </trans-unit>
        <trans-unit id="d507109a798498dbaa1e633727d124b6d6bc26b0" translate="yes" xml:space="preserve">
          <source>Use for APIs which have a third-party implementation available at runtime.</source>
          <target state="translated">実行時にサードパーティの実装が利用可能なAPIに使用します。</target>
        </trans-unit>
        <trans-unit id="3f1d8d5003fdff477f08dfe445e9b40450048a1d" translate="yes" xml:space="preserve">
          <source>Use for dependencies needed for the internal logic of a module.</source>
          <target state="translated">モジュールの内部ロジックに必要な依存関係に使用します。</target>
        </trans-unit>
        <trans-unit id="f46a150eeba438f84a49eada07a259f489c6609a" translate="yes" xml:space="preserve">
          <source>Use four spaces for indentation. Do not use tabs.</source>
          <target state="translated">インデントにはスペースを4つ使用してください。タブは使用しないでください。</target>
        </trans-unit>
        <trans-unit id="ce69d8e8477848e488f670533689cb83c9f8c099" translate="yes" xml:space="preserve">
          <source>Use it &lt;a href=&quot;#using-sharedcode-from-android&quot;&gt;from Android app&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#using-sharedcode-from-android&quot;&gt;Androidアプリから&lt;/a&gt;使用する</target>
        </trans-unit>
        <trans-unit id="62f9973d0d21db3635e8a7ac730a624b82c527d3" translate="yes" xml:space="preserve">
          <source>Use kotlinx.html to generate HTML</source>
          <target state="translated">kotlinx.html を使って HTML を生成する</target>
        </trans-unit>
        <trans-unit id="c9f5118d1f54f80362016bfd5b442c56f51dfc9b" translate="yes" xml:space="preserve">
          <source>Use native libraries in the hierarchical structure</source>
          <target state="translated">ネイティブライブラリを階層構造で使用する</target>
        </trans-unit>
        <trans-unit id="7f896877d7535f3235fee51d8eb8bb2fc4692498" translate="yes" xml:space="preserve">
          <source>Use regular indent (4 spaces) for constructor parameters.</source>
          <target state="translated">コンストラクタのパラメータには、正規のインデント (4 スペース)を使用します。</target>
        </trans-unit>
        <trans-unit id="8e22c1db7346b432b927919ebe9e716628c63ef8" translate="yes" xml:space="preserve">
          <source>Use regular indent (4 spaces) for function parameters.</source>
          <target state="translated">関数のパラメータには、正規のインデント(スペース4個)を使用します。</target>
        </trans-unit>
        <trans-unit id="b28f6c3f00f4a4b985821c624ebe6f5d2ab53f74" translate="yes" xml:space="preserve">
          <source>Use regular indent (four spaces) for constructor parameters.</source>
          <target state="translated">コンストラクタのパラメータには、正規のインデント (4 つのスペース)を使用します。</target>
        </trans-unit>
        <trans-unit id="9f39c73e1f23d3754cec94f86de325d9e4b9a4f1" translate="yes" xml:space="preserve">
          <source>Use target shortcuts</source>
          <target state="translated">ターゲットのショートカットを使用する</target>
        </trans-unit>
        <trans-unit id="6356c2b337336539cb098b460ea9fc43a2a742aa" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;../../../api/latest/jvm/stdlib/kotlin.text/replace&quot;&gt;&lt;code&gt;replace()&lt;/code&gt;&lt;/a&gt; function to remove the empty spaces in the name.</source>
          <target state="translated">&lt;a href=&quot;../../../api/latest/jvm/stdlib/kotlin.text/replace&quot;&gt; &lt;code&gt;replace()&lt;/code&gt; &lt;/a&gt;関数を使用して、名前の空のスペースを削除します。</target>
        </trans-unit>
        <trans-unit id="72171ae8b75ba095394479592bf8ca1cc4cab18c" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;../../../api/latest/jvm/stdlib/stdlib/kotlin.io/println&quot;&gt;&lt;code&gt;println()&lt;/code&gt;&lt;/a&gt; function to print computing status and the result of multiplication to the output.</source>
          <target state="translated">&lt;a href=&quot;../../../api/latest/jvm/stdlib/stdlib/kotlin.io/println&quot;&gt; &lt;code&gt;println()&lt;/code&gt; &lt;/a&gt;関数を使用して、計算ステータスと乗算の結果を出力に出力します。</target>
        </trans-unit>
        <trans-unit id="be7280e72c76af98308a3c66e2b7e24f9cc56702" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/await.html&quot;&gt;&lt;code&gt;await()&lt;/code&gt;&lt;/a&gt; function to await the computation result.</source>
          <target state="translated">&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/await.html&quot;&gt; &lt;code&gt;await()&lt;/code&gt; &lt;/a&gt;関数を使用して、計算結果を待ちます。</target>
        </trans-unit>
        <trans-unit id="0461db73580d6d4278fffb255e74938d931ed12e" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html&quot;&gt;&lt;code&gt;async()&lt;/code&gt;&lt;/a&gt; function to create coroutines that compute deferred values &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">使用&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html&quot;&gt; &lt;code&gt;async()&lt;/code&gt; &lt;/a&gt;の値を遅延計算コルーチン作成する機能と、 &lt;code&gt;b&lt;/code&gt; は。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6065d1c978fbee3b2ff226845a77482cccebc712" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/delay.html&quot;&gt;&lt;code&gt;delay()&lt;/code&gt;&lt;/a&gt; function to imitate CPU-consuming blocking code. It suspends the coroutine for 100 ms without blocking the thread.</source>
          <target state="translated">&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/delay.html&quot;&gt; &lt;code&gt;delay()&lt;/code&gt; &lt;/a&gt;関数を使用して、CPUを消費するブロッキングコードを模倣します。スレッドをブロックせずにコルーチンを100ミリ秒間中断します。</target>
        </trans-unit>
        <trans-unit id="b591373cb35b1a0f6e2219e8ca5964a4f1c5a083" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/delay.html&quot;&gt;&lt;code&gt;delay()&lt;/code&gt;&lt;/a&gt; function to imitate CPU-consuming code. It suspends the coroutine for 300 ms without blocking the thread.</source>
          <target state="translated">&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/delay.html&quot;&gt; &lt;code&gt;delay()&lt;/code&gt; &lt;/a&gt;関数を使用して、CPUを消費するコードを模倣します。スレッドをブロックせずにコルーチンを300ミリ秒間中断します。</target>
        </trans-unit>
        <trans-unit id="c33adc7173a74761298cf96415d2790cf72a0ec3" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;&lt;code&gt;runBlocking()&lt;/code&gt;&lt;/a&gt; block to wrap a coroutine.</source>
          <target state="translated">&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt; &lt;code&gt;runBlocking()&lt;/code&gt; &lt;/a&gt;ブロックを使用して、コルーチンをラップします。</target>
        </trans-unit>
        <trans-unit id="50099ad72d8ea21daa614b797c104f31da58f3d2" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;countDistinctCharacters()&lt;/code&gt; function to count the unique letters in your name.</source>
          <target state="translated">&lt;code&gt;countDistinctCharacters()&lt;/code&gt; 関数を使用して、名前の一意の文字をカウントします。</target>
        </trans-unit>
        <trans-unit id="4a252bcad831096a6694a845390d272ffaa5046b" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;maven-publish&lt;/code&gt; Gradle &lt;a href=&quot;https://docs.gradle.org/current/userguide/publishing_maven.html&quot;&gt;plugin&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;maven-publish&lt;/code&gt; publishGradle&lt;a href=&quot;https://docs.gradle.org/current/userguide/publishing_maven.html&quot;&gt;プラグインを&lt;/a&gt;使用します。</target>
        </trans-unit>
        <trans-unit id="2153a3c57b5ac237e2457368e65faee188870aa7" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;until&lt;/code&gt; function to loop over an open range:</source>
          <target state="translated">&lt;code&gt;until&lt;/code&gt; 関数を使用して、開いた範囲をループします。</target>
        </trans-unit>
        <trans-unit id="0bd4c99e44de0d3ffdb3c45eb15b74d7b4c2b386" translate="yes" xml:space="preserve">
          <source>Use the IR backend</source>
          <target state="translated">IRバックエンドを使用する</target>
        </trans-unit>
        <trans-unit id="9e774b3c689a7ceab89fb14ac0440aed57436890" translate="yes" xml:space="preserve">
          <source>Use the Kotlin dynamic library from C</source>
          <target state="translated">CのKotlinダイナミックライブラリを使用する</target>
        </trans-unit>
        <trans-unit id="44f7acf29bd5c28fb7d8d6e6f897b376b75ea2f3" translate="yes" xml:space="preserve">
          <source>Use the boxed version of an inline class in return type position for covariant and generic-specialized overrides</source>
          <target state="translated">共変量と汎用特化型のオーバーライドには、リターン型の位置にインラインクラスの箱型バージョンを使用します。</target>
        </trans-unit>
        <trans-unit id="4f2625d939200fe0f3767b996a1eaa8c5f1f235d" translate="yes" xml:space="preserve">
          <source>Use the following factory methods to declare elements of the &lt;code&gt;binaries&lt;/code&gt; collection.</source>
          <target state="translated">次のファクトリメソッドを使用して、 &lt;code&gt;binaries&lt;/code&gt; コレクションの要素を宣言します。</target>
        </trans-unit>
        <trans-unit id="fca17390ef51588303bcc0395c954faa0b511dcd" translate="yes" xml:space="preserve">
          <source>Use the intention from the IDE to include the missing import line:</source>
          <target state="translated">IDEからの意図を利用して、不足しているインポート行を含むようにします。</target>
        </trans-unit>
        <trans-unit id="c9fe0e8ecff640eabedf59913fdfab4613b76bf4" translate="yes" xml:space="preserve">
          <source>Use the named argument syntax when a method takes multiple parameters of the same primitive type, or for parameters of &lt;code&gt;Boolean&lt;/code&gt; type, unless the meaning of all parameters is absolutely clear from context.</source>
          <target state="translated">メソッドが同じプリミティブ型の複数のパラメーターを取る場合、または &lt;code&gt;Boolean&lt;/code&gt; 型のパラメーターの場合は、すべてのパラメーターの意味がコンテキストから完全に明確でない限り、名前付き引数構文を使用します。</target>
        </trans-unit>
        <trans-unit id="09617aa736694d6bc881574c01e808ebeb4fb7c7" translate="yes" xml:space="preserve">
          <source>Use the path to the Java runtime version 1.8 or 11 for the &lt;em&gt;Gradle JVM&lt;/em&gt; field. Check out the &lt;a href=&quot;https://jdk.java.net/11/&quot;&gt;https://jdk.java.net/11&lt;/a&gt; or &lt;a href=&quot;https://adoptopenjdk.net/&quot;&gt;https://adoptopenjdk.net/&lt;/a&gt; for the best JRE, OpenJDK, or JDK distribution.</source>
          <target state="translated">&lt;em&gt;Gradle JVM&lt;/em&gt;フィールドには、Javaランタイムバージョン1.8または11へのパスを使用します。最適なJRE、OpenJDK、またはJDKディストリビューションについては、&lt;a href=&quot;https://jdk.java.net/11/&quot;&gt;https：//jdk.java.net/11&lt;/a&gt;または&lt;a href=&quot;https://adoptopenjdk.net/&quot;&gt;https://adoptopenjdk.net/&lt;/a&gt;を確認してください。</target>
        </trans-unit>
        <trans-unit id="b686514332051bdffa546563fa862bdb9f30b3de" translate="yes" xml:space="preserve">
          <source>Use the scope function &lt;a href=&quot;../../reference/scope-functions#let&quot;&gt;&lt;code&gt;let&lt;/code&gt;&lt;/a&gt; to run the function within the object context.</source>
          <target state="translated">スコープ関数&lt;a href=&quot;../../reference/scope-functions#let&quot;&gt; &lt;code&gt;let&lt;/code&gt; &lt;/a&gt;を使用して、オブジェクトコンテキスト内で関数を実行します。</target>
        </trans-unit>
        <trans-unit id="efe23756e108375f4f234fa62c62b1a3192f2334" translate="yes" xml:space="preserve">
          <source>Use the shared Kotlin library &lt;a href=&quot;#setting-up-framework-dependency-in-xcode&quot;&gt;from iOS app&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#setting-up-framework-dependency-in-xcode&quot;&gt;iOSアプリから&lt;/a&gt;共有Kotlinライブラリを使用する</target>
        </trans-unit>
        <trans-unit id="bdbe6eb3123e18a3df48280aadc1acf4ad69906d" translate="yes" xml:space="preserve">
          <source>Use the specified paths as base directories. Base directories are used for calculating relative paths in the source map.</source>
          <target state="translated">指定されたパスをベースディレクトリとして使用します。ベースディレクトリは、ソース マップの相対パスを計算するために使用されます。</target>
        </trans-unit>
        <trans-unit id="0e87c063aea31b41f461fabf9570d133ee5c90c0" translate="yes" xml:space="preserve">
          <source>Use the standard library function &lt;code&gt;reversed()&lt;/code&gt; to reverse your name.</source>
          <target state="translated">名前を逆にするには、標準ライブラリ関数 &lt;code&gt;reversed()&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="f9852a84398c6954bfc8ee0f3c95a700b78ffafb" translate="yes" xml:space="preserve">
          <source>Use the types &lt;code&gt;Kotlin2JsCompile&lt;/code&gt; and &lt;code&gt;KotlinCompileCommon&lt;/code&gt; for the JS and Common targets, accordingly.</source>
          <target state="translated">それに &lt;code&gt;KotlinCompileCommon&lt;/code&gt; て、JSおよび共通ターゲットには &lt;code&gt;Kotlin2JsCompile&lt;/code&gt; およびKotlinCompileCommonタイプを使用します。</target>
        </trans-unit>
        <trans-unit id="ba751862add42b30b98929193759e854e81a1255" translate="yes" xml:space="preserve">
          <source>Use this function for projects that contain both Java and Kotlin source files. Note that the default source directories for Java sources don't follow the Java plugin's defaults. Instead, they are derived from the Kotlin source sets. For example, if the JVM target has the default name &lt;code&gt;jvm&lt;/code&gt;, the paths are &lt;code&gt;src/jvmMain/java&lt;/code&gt; (for production Java sources) and &lt;code&gt;src/jvmTest/java&lt;/code&gt; for test Java sources. Learn how to &lt;a href=&quot;mpp-configure-compilations#include-java-sources-in-jvm-compilations&quot;&gt;include Java sources in JVM compilations&lt;/a&gt;.</source>
          <target state="translated">この関数は、JavaとKotlinの両方のソースファイルを含むプロジェクトに使用します。Javaソースのデフォルトのソースディレクトリは、Javaプラグインのデフォルトに従わないことに注意してください。代わりに、Kotlinソースセットから派生しています。たとえば、JVMターゲットのデフォルト名が &lt;code&gt;jvm&lt;/code&gt; の場合、パスは &lt;code&gt;src/jvmMain/java&lt;/code&gt; （本番Javaソースの場合）および &lt;code&gt;src/jvmTest/java&lt;/code&gt; （テストJavaソースの場合）です。&lt;a href=&quot;mpp-configure-compilations#include-java-sources-in-jvm-compilations&quot;&gt;JavaソースをJVMコンパイル&lt;/a&gt;に含める方法を学びます。</target>
        </trans-unit>
        <trans-unit id="4e03be997274e2b63af86d76fc7bf98a2088dbc4" translate="yes" xml:space="preserve">
          <source>Use ts2kt to interact with libraries</source>
          <target state="translated">ts2kt を使ってライブラリと対話する</target>
        </trans-unit>
        <trans-unit id="106c8f3de5148d18865fbc697fa5d5cdeecc28c4" translate="yes" xml:space="preserve">
          <source>Use-site variance: Type projections</source>
          <target state="translated">使用場所の分散。タイプ別予測</target>
        </trans-unit>
        <trans-unit id="e2476b5675d923b0014d65b682cc8d7c7848dd3a" translate="yes" xml:space="preserve">
          <source>UseExperimental</source>
          <target state="translated">UseExperimental</target>
        </trans-unit>
        <trans-unit id="5948d8b97ec29bff3672a84e9d432b919624dc55" translate="yes" xml:space="preserve">
          <source>Used both during compilation and at runtime and is exported to library consumers.</source>
          <target state="translated">コンパイル時と実行時の両方で使用され、ライブラリのコンシューマにエクスポートされます。</target>
        </trans-unit>
        <trans-unit id="8ac3c810c772a41c5e178656755fecd6523a14fa" translate="yes" xml:space="preserve">
          <source>Used during compilation and at runtime for the current module, but is not exposed for compilation of other modules depending on the one with the `implementation` dependency.</source>
          <target state="translated">現在のモジュールのコンパイル時や実行時に利用されますが、`implementation`依存性のあるモジュールに依存している他のモジュールのコンパイル時には公開されません。</target>
        </trans-unit>
        <trans-unit id="73310b7839f171659371cc3680a3ce118bf8dc6d" translate="yes" xml:space="preserve">
          <source>Used for compilation of the current module and is not available at runtime nor during compilation of other modules.</source>
          <target state="translated">現在のモジュールのコンパイルに使用され、実行時や他のモジュールのコンパイル時には使用できません。</target>
        </trans-unit>
        <trans-unit id="06c609f5a60b09cc00048be8eb23732ff873a513" translate="yes" xml:space="preserve">
          <source>Used only with &lt;code&gt;-Xjvm-default=compatibility|all-compatibility&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;-Xjvm-default=compatibility|all-compatibility&lt;/code&gt; のみ使用されます。</target>
        </trans-unit>
        <trans-unit id="f27716b3301b8979f846685e09578fc4d968ef31" translate="yes" xml:space="preserve">
          <source>User-defined contracts</source>
          <target state="translated">ユーザー定義の契約</target>
        </trans-unit>
        <trans-unit id="2546ff21c7035e67f381dd0185abecc195a459e2" translate="yes" xml:space="preserve">
          <source>Users of Kotlin on the Server Side</source>
          <target state="translated">サーバー側のKotlinのユーザー</target>
        </trans-unit>
        <trans-unit id="47181373df2bd78be6294c0add1dbe6339b4681b" translate="yes" xml:space="preserve">
          <source>Uses the provided &lt;a href=&quot;../../kotlin.text/format#kotlin.text%24format%28kotlin.String.Companion%2C+java.util.Locale%2C+kotlin.String%2C+kotlin.Array%28%28kotlin.Any%29%29%29%2Fformat&quot;&gt;format&lt;/a&gt; as a format string and returns a string obtained by substituting the specified arguments, using the specified locale.</source>
          <target state="translated">提供される使用&lt;a href=&quot;../../kotlin.text/format#kotlin.text%24format%28kotlin.String.Companion%2C+java.util.Locale%2C+kotlin.String%2C+kotlin.Array%28%28kotlin.Any%29%29%29%2Fformat&quot;&gt;フォーマットを&lt;/a&gt;フォーマット文字列として、および指定されたロケールを使用して、指定された引数を代入して得られた文字列を返します。</target>
        </trans-unit>
        <trans-unit id="3391e8d9489d92fff425335dfe200993b486d0ea" translate="yes" xml:space="preserve">
          <source>Uses the provided &lt;a href=&quot;../../kotlin.text/format#kotlin.text%24format%28kotlin.String.Companion%2C+kotlin.String%2C+kotlin.Array%28%28kotlin.Any%29%29%29%2Fformat&quot;&gt;format&lt;/a&gt; as a format string and returns a string obtained by substituting the specified arguments, using the default locale.</source>
          <target state="translated">提供使って&lt;a href=&quot;../../kotlin.text/format#kotlin.text%24format%28kotlin.String.Companion%2C+kotlin.String%2C+kotlin.Array%28%28kotlin.Any%29%29%29%2Fformat&quot;&gt;書式を&lt;/a&gt;書式文字列として、デフォルトのロケールを使用して、指定された引数を代入して得られた文字列を返します。</target>
        </trans-unit>
        <trans-unit id="704ebbde6e2b32eeb1c2f67d4e693a35f67af0fd" translate="yes" xml:space="preserve">
          <source>Uses the provided &lt;a href=&quot;../../kotlin.text/format#kotlin.text%24format(kotlin.String.Companion,%20java.util.Locale,%20kotlin.String,%20kotlin.Array((kotlin.Any?)))/format&quot;&gt;format&lt;/a&gt; as a format string and returns a string obtained by substituting the specified arguments, using the specified locale.</source>
          <target state="translated">提供される使用&lt;a href=&quot;../../kotlin.text/format#kotlin.text%24format(kotlin.String.Companion,%20java.util.Locale,%20kotlin.String,%20kotlin.Array((kotlin.Any?)))/format&quot;&gt;フォーマットを&lt;/a&gt;フォーマット文字列として、および指定されたロケールを使用して、指定された引数を代入して得られた文字列を返します。</target>
        </trans-unit>
        <trans-unit id="aac052dc5a6c0e7fbd28f5bc3a043e4ecb32e5f5" translate="yes" xml:space="preserve">
          <source>Uses the provided &lt;a href=&quot;../../kotlin.text/format#kotlin.text%24format(kotlin.String.Companion,%20java.util.Locale?,%20kotlin.String,%20kotlin.Array((kotlin.Any?)))/format&quot;&gt;format&lt;/a&gt; as a format string and returns a string obtained by substituting the specified arguments, using the specified locale. If &lt;a href=&quot;../../kotlin.text/format#kotlin.text%24format(kotlin.String.Companion,%20java.util.Locale?,%20kotlin.String,%20kotlin.Array((kotlin.Any?)))/locale&quot;&gt;locale&lt;/a&gt; is &lt;code&gt;null&lt;/code&gt; then no localization is applied.</source>
          <target state="translated">提供される使用&lt;a href=&quot;../../kotlin.text/format#kotlin.text%24format(kotlin.String.Companion,%20java.util.Locale?,%20kotlin.String,%20kotlin.Array((kotlin.Any?)))/format&quot;&gt;フォーマットを&lt;/a&gt;フォーマット文字列として、および指定されたロケールを使用して、指定された引数を代入して得られた文字列を返します。場合は&lt;a href=&quot;../../kotlin.text/format#kotlin.text%24format(kotlin.String.Companion,%20java.util.Locale?,%20kotlin.String,%20kotlin.Array((kotlin.Any?)))/locale&quot;&gt;、ロケールが&lt;/a&gt;ある &lt;code&gt;null&lt;/code&gt; 、ローカリゼーションは適用されません。</target>
        </trans-unit>
        <trans-unit id="0dd3b1deb8f1d7bfb8c12c5a14f2ab32a21d65af" translate="yes" xml:space="preserve">
          <source>Uses the provided &lt;a href=&quot;../../kotlin.text/format#kotlin.text%24format(kotlin.String.Companion,%20kotlin.String,%20kotlin.Array((kotlin.Any?)))/format&quot;&gt;format&lt;/a&gt; as a format string and returns a string obtained by substituting the specified arguments, using the default locale.</source>
          <target state="translated">提供使って&lt;a href=&quot;../../kotlin.text/format#kotlin.text%24format(kotlin.String.Companion,%20kotlin.String,%20kotlin.Array((kotlin.Any?)))/format&quot;&gt;書式を&lt;/a&gt;書式文字列として、デフォルトのロケールを使用して、指定された引数を代入して得られた文字列を返します。</target>
        </trans-unit>
        <trans-unit id="7a75a8ac839c741b8d08dc9c1deee0d88e4f979c" translate="yes" xml:space="preserve">
          <source>Uses the provided &lt;a href=&quot;format#kotlin.text%24format%28kotlin.String.Companion%2C+java.util.Locale%2C+kotlin.String%2C+kotlin.Array%28%28kotlin.Any%29%29%29%2Fformat&quot;&gt;format&lt;/a&gt; as a format string and returns a string obtained by substituting the specified arguments, using the specified locale.</source>
          <target state="translated">提供される使用&lt;a href=&quot;format#kotlin.text%24format%28kotlin.String.Companion%2C+java.util.Locale%2C+kotlin.String%2C+kotlin.Array%28%28kotlin.Any%29%29%29%2Fformat&quot;&gt;フォーマットを&lt;/a&gt;フォーマット文字列として、および指定されたロケールを使用して、指定された引数を代入して得られた文字列を返します。</target>
        </trans-unit>
        <trans-unit id="9d3ac3ea11a7f22b1d758a682e71f98cc029fa36" translate="yes" xml:space="preserve">
          <source>Uses the provided &lt;a href=&quot;format#kotlin.text%24format%28kotlin.String.Companion%2C+kotlin.String%2C+kotlin.Array%28%28kotlin.Any%29%29%29%2Fformat&quot;&gt;format&lt;/a&gt; as a format string and returns a string obtained by substituting the specified arguments, using the default locale.</source>
          <target state="translated">提供使って&lt;a href=&quot;format#kotlin.text%24format%28kotlin.String.Companion%2C+kotlin.String%2C+kotlin.Array%28%28kotlin.Any%29%29%29%2Fformat&quot;&gt;書式を&lt;/a&gt;書式文字列として、デフォルトのロケールを使用して、指定された引数を代入して得られた文字列を返します。</target>
        </trans-unit>
        <trans-unit id="10dc34a2059cb8159f0a883b5dd86e0bc6137e07" translate="yes" xml:space="preserve">
          <source>Uses the provided &lt;a href=&quot;format#kotlin.text%24format(kotlin.String.Companion,%20java.util.Locale,%20kotlin.String,%20kotlin.Array((kotlin.Any?)))/format&quot;&gt;format&lt;/a&gt; as a format string and returns a string obtained by substituting the specified arguments, using the specified locale.</source>
          <target state="translated">提供される使用&lt;a href=&quot;format#kotlin.text%24format(kotlin.String.Companion,%20java.util.Locale,%20kotlin.String,%20kotlin.Array((kotlin.Any?)))/format&quot;&gt;フォーマットを&lt;/a&gt;フォーマット文字列として、および指定されたロケールを使用して、指定された引数を代入して得られた文字列を返します。</target>
        </trans-unit>
        <trans-unit id="f82d324c322c9f91adb6f0983572279a3329ac89" translate="yes" xml:space="preserve">
          <source>Uses the provided &lt;a href=&quot;format#kotlin.text%24format(kotlin.String.Companion,%20java.util.Locale?,%20kotlin.String,%20kotlin.Array((kotlin.Any?)))/format&quot;&gt;format&lt;/a&gt; as a format string and returns a string obtained by substituting the specified arguments, using the specified locale. If &lt;a href=&quot;format#kotlin.text%24format(kotlin.String.Companion,%20java.util.Locale?,%20kotlin.String,%20kotlin.Array((kotlin.Any?)))/locale&quot;&gt;locale&lt;/a&gt; is &lt;code&gt;null&lt;/code&gt; then no localization is applied.</source>
          <target state="translated">提供される使用&lt;a href=&quot;format#kotlin.text%24format(kotlin.String.Companion,%20java.util.Locale?,%20kotlin.String,%20kotlin.Array((kotlin.Any?)))/format&quot;&gt;フォーマットを&lt;/a&gt;フォーマット文字列として、および指定されたロケールを使用して、指定された引数を代入して得られた文字列を返します。場合は&lt;a href=&quot;format#kotlin.text%24format(kotlin.String.Companion,%20java.util.Locale?,%20kotlin.String,%20kotlin.Array((kotlin.Any?)))/locale&quot;&gt;、ロケールが&lt;/a&gt;ある &lt;code&gt;null&lt;/code&gt; 、ローカリゼーションは適用されません。</target>
        </trans-unit>
        <trans-unit id="65bfa57761f82862cfd81ebd5b8013f5e01aaad7" translate="yes" xml:space="preserve">
          <source>Uses the provided &lt;a href=&quot;format#kotlin.text%24format(kotlin.String.Companion,%20kotlin.String,%20kotlin.Array((kotlin.Any?)))/format&quot;&gt;format&lt;/a&gt; as a format string and returns a string obtained by substituting the specified arguments, using the default locale.</source>
          <target state="translated">提供使って&lt;a href=&quot;format#kotlin.text%24format(kotlin.String.Companion,%20kotlin.String,%20kotlin.Array((kotlin.Any?)))/format&quot;&gt;書式を&lt;/a&gt;書式文字列として、デフォルトのロケールを使用して、指定された引数を代入して得られた文字列を返します。</target>
        </trans-unit>
        <trans-unit id="42fcdb82df9fab88befa785457e65d1af96aa239" translate="yes" xml:space="preserve">
          <source>Uses this string as a format string and returns a string obtained by substituting the specified arguments, using the default locale.</source>
          <target state="translated">この文字列をフォーマット文字列として使用し、指定した引数をデフォルトのロケールで代入した文字列を返します。</target>
        </trans-unit>
        <trans-unit id="3f6866db3da817af6ed67e3dae70c3ec02de81e2" translate="yes" xml:space="preserve">
          <source>Uses this string as a format string and returns a string obtained by substituting the specified arguments, using the specified locale.</source>
          <target state="translated">この文字列を書式文字列として使用し、指定されたロケールを用いて、指定された引数を代入して得られた文字列を返します。</target>
        </trans-unit>
        <trans-unit id="6484cdf608c52e6f223f86ea931137798547136f" translate="yes" xml:space="preserve">
          <source>Uses this string as a format string and returns a string obtained by substituting the specified arguments, using the specified locale. If &lt;a href=&quot;../../kotlin.text/format#kotlin.text%24format(kotlin.String,%20java.util.Locale?,%20kotlin.Array((kotlin.Any?)))/locale&quot;&gt;locale&lt;/a&gt; is &lt;code&gt;null&lt;/code&gt; then no localization is applied.</source>
          <target state="translated">この文字列をフォーマット文字列として使用し、指定されたロケールを使用して、指定された引数を代入して取得した文字列を返します。場合は&lt;a href=&quot;../../kotlin.text/format#kotlin.text%24format(kotlin.String,%20java.util.Locale?,%20kotlin.Array((kotlin.Any?)))/locale&quot;&gt;、ロケールが&lt;/a&gt;ある &lt;code&gt;null&lt;/code&gt; 、ローカリゼーションは適用されません。</target>
        </trans-unit>
        <trans-unit id="a6a6e896b98588b46d5642885789c195ba9adc2a" translate="yes" xml:space="preserve">
          <source>Uses this string as a format string and returns a string obtained by substituting the specified arguments, using the specified locale. If &lt;a href=&quot;format#kotlin.text%24format(kotlin.String,%20java.util.Locale?,%20kotlin.Array((kotlin.Any?)))/locale&quot;&gt;locale&lt;/a&gt; is &lt;code&gt;null&lt;/code&gt; then no localization is applied.</source>
          <target state="translated">この文字列をフォーマット文字列として使用し、指定されたロケールを使用して、指定された引数を代入して取得した文字列を返します。場合は&lt;a href=&quot;format#kotlin.text%24format(kotlin.String,%20java.util.Locale?,%20kotlin.Array((kotlin.Any?)))/locale&quot;&gt;、ロケールが&lt;/a&gt;ある &lt;code&gt;null&lt;/code&gt; 、ローカリゼーションは適用されません。</target>
        </trans-unit>
        <trans-unit id="4e62e86755452347944ce24bc99c8763bab8c2b5" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-receive-channel/receive.html&quot;&gt;receive&lt;/a&gt; suspending function we can receive &lt;em&gt;either&lt;/em&gt; from one channel or the other. But &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.selects/select.html&quot;&gt;select&lt;/a&gt; expression allows us to receive from &lt;em&gt;both&lt;/em&gt; simultaneously using its &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-receive-channel/on-receive.html&quot;&gt;onReceive&lt;/a&gt; clauses:</source>
          <target state="translated">使用&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-receive-channel/receive.html&quot;&gt;受け取る&lt;/a&gt;私たちが受け取ることができる機能を一時停止&lt;em&gt;のいずれか&lt;/em&gt;一方のチャネルまたは他から。しかし、&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.selects/select.html&quot;&gt;select&lt;/a&gt;式では、&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-receive-channel/on-receive.html&quot;&gt;onReceive&lt;/a&gt;句を使用して&lt;em&gt;両方&lt;/em&gt;から同時に受信できます。</target>
        </trans-unit>
        <trans-unit id="08f3f41e2b1efe6c5dce0e5fec64099ed03bdf2b" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;lambdas&quot;&gt;higher-order functions&lt;/a&gt; imposes certain runtime penalties: each function is an object, and it captures a closure, i.e. those variables that are accessed in the body of the function. Memory allocations (both for function objects and classes) and virtual calls introduce runtime overhead.</source>
          <target state="translated">&lt;a href=&quot;lambdas&quot;&gt;高次関数&lt;/a&gt;を使用すると、特定の実行時のペナルティが課せられます。各関数はオブジェクトであり、クロージャー、つまり関数の本体でアクセスされる変数をキャプチャします。メモリ割り当て（関数オブジェクトとクラスの両方）と仮想呼び出しにより、ランタイムオーバーヘッドが発生します。</target>
        </trans-unit>
        <trans-unit id="491e6c994c3baf4cc8af39219068162e74e38931" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;::Foo&lt;/code&gt;, the zero-argument constructor of the class Foo, we can simply call it like this:</source>
          <target state="translated">クラスFooの引数なしのコンストラクター &lt;code&gt;::Foo&lt;/code&gt; を使用して、次のように呼び出すだけです。</target>
        </trans-unit>
        <trans-unit id="df28902f080c8e95c2e047504754d8fc98471dfb" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;break&lt;/code&gt; and &lt;code&gt;continue&lt;/code&gt; inside &lt;code&gt;when&lt;/code&gt; expressions included in loops</source>
          <target state="translated">式がループに含まれている &lt;code&gt;when&lt;/code&gt; &lt;code&gt;break&lt;/code&gt; を使用して内部を &lt;code&gt;continue&lt;/code&gt; します</target>
        </trans-unit>
        <trans-unit id="1288042cdb0bedb4cedef04fffbbc6421151560c" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;when&lt;/code&gt; expression</source>
          <target state="translated">&lt;code&gt;when&lt;/code&gt; 式を使用する</target>
        </trans-unit>
        <trans-unit id="b4d45feb4cce668fd7098830e83bf2557a415c16" translate="yes" xml:space="preserve">
          <source>Using &lt;em&gt;if&lt;/em&gt; as an expression:</source>
          <target state="translated">式として&lt;em&gt;if&lt;/em&gt;を使用する：</target>
        </trans-unit>
        <trans-unit id="7956ce97b97e87d0f55a6ea0cc6e4e05373fcf15" translate="yes" xml:space="preserve">
          <source>Using AMD</source>
          <target state="translated">AMDを使用して</target>
        </trans-unit>
        <trans-unit id="aae897c446cafc25370dcce91792d5e6dfa9a087" translate="yes" xml:space="preserve">
          <source>Using Ant</source>
          <target state="translated">アントの使用</target>
        </trans-unit>
        <trans-unit id="44ab2ab05f55d2266ffc569dcf7fc124a65679b4" translate="yes" xml:space="preserve">
          <source>Using C Interop and libcurl for an App</source>
          <target state="translated">C Interop と libcurl をアプリで使用する</target>
        </trans-unit>
        <trans-unit id="a59cc5aadf82954e8f0283bd3dfcaae639efbadd" translate="yes" xml:space="preserve">
          <source>Using C library from Kotlin/Native</source>
          <target state="translated">Kotlin/NativeからCライブラリを使用</target>
        </trans-unit>
        <trans-unit id="d678710e9135632a43d33f3d5da6bf72dddacbe5" translate="yes" xml:space="preserve">
          <source>Using CommonJS</source>
          <target state="translated">CommonJSの使用</target>
        </trans-unit>
        <trans-unit id="e42f7c8cd0e8730768cbb184338fabc772fadfd5" translate="yes" xml:space="preserve">
          <source>Using Dynamic</source>
          <target state="translated">動的な使用</target>
        </trans-unit>
        <trans-unit id="cbe69bb9e7692bc07945db15e10c51c3ee312db2" translate="yes" xml:space="preserve">
          <source>Using Generated Headers from C</source>
          <target state="translated">C から生成されたヘッダの使用</target>
        </trans-unit>
        <trans-unit id="27c679a18ee1d9ed93d7a66b728665e446e0b013" translate="yes" xml:space="preserve">
          <source>Using Gradle</source>
          <target state="translated">Gradleを使用して</target>
        </trans-unit>
        <trans-unit id="17fbd0b7659b724c4b82377e5e5b6176a4a4d7c0" translate="yes" xml:space="preserve">
          <source>Using Gradle Kotlin DSL</source>
          <target state="translated">Gradle Kotlin DSLを使う</target>
        </trans-unit>
        <trans-unit id="71d5b086b763a415271837d49bf05b383ed34176" translate="yes" xml:space="preserve">
          <source>Using IntelliJ IDEA Build System</source>
          <target state="translated">IntelliJ IDEAビルドシステムの使用</target>
        </trans-unit>
        <trans-unit id="be4003165448a14831defb73021c979f0b4b46d4" translate="yes" xml:space="preserve">
          <source>Using IntelliJ IDEA debugger, you can dig deeper into each coroutine to debug your code.</source>
          <target state="translated">IntelliJ IDEAデバッガを使用することで、各コルーチンを深く掘り下げてコードをデバッグすることができます。</target>
        </trans-unit>
        <trans-unit id="81cb9f3916c8314e916dfe4f86e42b9f41066648" translate="yes" xml:space="preserve">
          <source>Using IntelliJ IDEA we can easily run and debug the application in any of the possible application servers defined such as Tomcat, Glassfish or WildFly. In this case we're going to use Tomcat which has previously &lt;a href=&quot;http://www.jetbrains.com/idea/webhelp/defining-application-servers-in-intellij-idea.html&quot;&gt;been defined as an application server in IntelliJ IDEA&lt;/a&gt;. Note that application server support is only available in IntelliJ IDEA Ultimate.</source>
          <target state="translated">IntelliJ IDEAを使用すると、Tomcat、Glassfish、WildFlyなど、定義されているすべてのアプリケーションサーバーでアプリケーションを簡単に実行およびデバッグできます。この場合は、以前&lt;a href=&quot;http://www.jetbrains.com/idea/webhelp/defining-application-servers-in-intellij-idea.html&quot;&gt;IntelliJ IDEAでアプリケーションサーバーとして定義され&lt;/a&gt;ていたTomcatを使用します。アプリケーションサーバーのサポートはIntelliJ IDEA Ultimateでのみ利用可能であることに注意してください。</target>
        </trans-unit>
        <trans-unit id="4709ae28ff320dfabd65f0869103704aedfcf674" translate="yes" xml:space="preserve">
          <source>Using JNI with Kotlin</source>
          <target state="translated">KotlinでJNIを使う</target>
        </trans-unit>
        <trans-unit id="2bbc39d0664d569562a91137d4d90178cf23c617" translate="yes" xml:space="preserve">
          <source>Using Kotlin Android Extensions</source>
          <target state="translated">KotlinのAndroid拡張機能を使う</target>
        </trans-unit>
        <trans-unit id="b022874247f51c944909afa759f623b6478ca32e" translate="yes" xml:space="preserve">
          <source>Using Kotlin for Android Development</source>
          <target state="translated">Android開発にKotlinを使う</target>
        </trans-unit>
        <trans-unit id="60a1392d0c8d40966f3ba2738ae5f701e549f245" translate="yes" xml:space="preserve">
          <source>Using Kotlin for Android development, you can benefit from:</source>
          <target state="translated">Android開発にKotlinを使用すると、その恩恵を受けることができます。</target>
        </trans-unit>
        <trans-unit id="aaf246aafd7124667a554d398075e5452aa83ed4" translate="yes" xml:space="preserve">
          <source>Using Kotlin for Server-side Development</source>
          <target state="translated">サーバーサイド開発にKotlinを使う</target>
        </trans-unit>
        <trans-unit id="2b0fb5591f02bcbebcc2bd375ac8a71d601338b0" translate="yes" xml:space="preserve">
          <source>Using Kotlin/Native Targets</source>
          <target state="translated">Kotlin/ネイティブターゲットの使用</target>
        </trans-unit>
        <trans-unit id="936b968752b32f197dc84832341b3f607b83a027" translate="yes" xml:space="preserve">
          <source>Using Maven</source>
          <target state="translated">メイヴンを使用する</target>
        </trans-unit>
        <trans-unit id="ef7af2346af2c37f7e6ee428aab1c98075a789a9" translate="yes" xml:space="preserve">
          <source>Using SharedCode from Android</source>
          <target state="translated">AndroidからSharedCodeを使う</target>
        </trans-unit>
        <trans-unit id="603ab8042b5d1c17d5b50d529fa9db7d658d860a" translate="yes" xml:space="preserve">
          <source>Using Struct and Union Types from Kotlin</source>
          <target state="translated">Kotlinから構造体とユニオン型を使う</target>
        </trans-unit>
        <trans-unit id="6e4c13998b5f91e0846d37840959ab407900c453" translate="yes" xml:space="preserve">
          <source>Using a &lt;code&gt;for&lt;/code&gt; loop</source>
          <target state="translated">&lt;code&gt;for&lt;/code&gt; ループの使用</target>
        </trans-unit>
        <trans-unit id="4fe7e2f58454fbb71457b9ce1e7ce104ef338243" translate="yes" xml:space="preserve">
          <source>Using a &lt;code&gt;while&lt;/code&gt; loop</source>
          <target state="translated">&lt;code&gt;while&lt;/code&gt; ループの使用</target>
        </trans-unit>
        <trans-unit id="29dae43467cc406389583f725ed8cb7bcc1c247d" translate="yes" xml:space="preserve">
          <source>Using a Kotlin/JavaScript library.</source>
          <target state="translated">Kotlin/JavaScriptのライブラリを使用しています。</target>
        </trans-unit>
        <trans-unit id="d3383ee07c516c1fa1802c63fcedaaefadd8e48c" translate="yes" xml:space="preserve">
          <source>Using a callable reference to an existing declaration:</source>
          <target state="translated">既存の宣言への呼び出し可能な参照を使用します。</target>
        </trans-unit>
        <trans-unit id="197fb49229d662d3379f8cffecb5a8e470235340" translate="yes" xml:space="preserve">
          <source>Using a code block within a function literal, in one of the forms:</source>
          <target state="translated">関数リテラルの中でコードブロックを使用します。</target>
        </trans-unit>
        <trans-unit id="a7c34a78b0f5530284b929714a111e0120a19cb8" translate="yes" xml:space="preserve">
          <source>Using a standard build tool</source>
          <target state="translated">標準的なビルドツールを使用して</target>
        </trans-unit>
        <trans-unit id="6825ce8ddbdb846319b075044bc1aefd9c058144" translate="yes" xml:space="preserve">
          <source>Using artifacts built with Kotlin 1.4.x in a Kotlin 1.3.x project</source>
          <target state="translated">Kotlin 1.3.x プロジェクトで Kotlin 1.4.x でビルドされたアーティファクトを使う</target>
        </trans-unit>
        <trans-unit id="5a3edbb4ebc2b355b2a8f195be33f5a03ead3d30" translate="yes" xml:space="preserve">
          <source>Using bindings</source>
          <target state="translated">バインディングの使用</target>
        </trans-unit>
        <trans-unit id="92c77c8ea60a2ffe09d3b8484f979577fe3fe402" translate="yes" xml:space="preserve">
          <source>Using cinterop</source>
          <target state="translated">シンタロープの使用</target>
        </trans-unit>
        <trans-unit id="6f335b7fd336f32636cf82fea33e6e5a118b4de7" translate="yes" xml:space="preserve">
          <source>Using collections</source>
          <target state="translated">コレクションの使用</target>
        </trans-unit>
        <trans-unit id="ce4da38f792e511ab4d77c2e6a228d9a0f717f17" translate="yes" xml:space="preserve">
          <source>Using conditional expressions</source>
          <target state="translated">条件式の使用</target>
        </trans-unit>
        <trans-unit id="918641690842037efdc3f921e9d2a03a1b94d884" translate="yes" xml:space="preserve">
          <source>Using conditional statements</source>
          <target state="translated">条件文の使用</target>
        </trans-unit>
        <trans-unit id="3fc2b300fe4dab146a33f883986c605263212bcf" translate="yes" xml:space="preserve">
          <source>Using experimental APIs</source>
          <target state="translated">実験的なAPIの使用</target>
        </trans-unit>
        <trans-unit id="ebd9b5845829e10c5bf4bfdb285f0143f1b0cc17" translate="yes" xml:space="preserve">
          <source>Using extension functions</source>
          <target state="translated">拡張機能の使用</target>
        </trans-unit>
        <trans-unit id="b252910d4e8badbe4bca9df0c30fd5478c5c630b" translate="yes" xml:space="preserve">
          <source>Using in CLI</source>
          <target state="translated">CLIでの使用</target>
        </trans-unit>
        <trans-unit id="30f417bc0504e6fe1552d975f144e48529a622bd" translate="yes" xml:space="preserve">
          <source>Using in Gradle</source>
          <target state="translated">Gradleでの使用</target>
        </trans-unit>
        <trans-unit id="987fbf118a45b1d5fc70735f1b4a9cb07d729a9e" translate="yes" xml:space="preserve">
          <source>Using in Maven</source>
          <target state="translated">Mavenでの使用</target>
        </trans-unit>
        <trans-unit id="b58b6328c1df079d0d8cccee5234ec40deb70287" translate="yes" xml:space="preserve">
          <source>Using infix functions</source>
          <target state="translated">インフィックス関数の使用</target>
        </trans-unit>
        <trans-unit id="a915c033f5e92eb86f6eb764c7d3fbfec97399c7" translate="yes" xml:space="preserve">
          <source>Using instances of a custom class that implements a function type as an interface:</source>
          <target state="translated">関数型を実装したカスタムクラスのインスタンスをインターフェイスとして使用します。</target>
        </trans-unit>
        <trans-unit id="b7d1f08b0755e4efecc6155b06410d6d8f47dd0c" translate="yes" xml:space="preserve">
          <source>Using kotlinx.html</source>
          <target state="translated">kotlinx.htmlを使う</target>
        </trans-unit>
        <trans-unit id="e33a647f9d820f02525a9e589cf38c7cb15aa9e1" translate="yes" xml:space="preserve">
          <source>Using lambda expressions to filter and map collections:</source>
          <target state="translated">ラムダ式を使用して、コレクションをフィルタリングおよびマッピングします。</target>
        </trans-unit>
        <trans-unit id="85b9a9b134d068b76d1d9da5eba9082360a75376" translate="yes" xml:space="preserve">
          <source>Using loops</source>
          <target state="translated">ループの使用</target>
        </trans-unit>
        <trans-unit id="e702f70d153e5bb48504257ee3c4806c305f3fd0" translate="yes" xml:space="preserve">
          <source>Using modules</source>
          <target state="translated">モジュールの使用</target>
        </trans-unit>
        <trans-unit id="9af9fabd79c052500b25a5c07039f994d4da9bd7" translate="yes" xml:space="preserve">
          <source>Using nullable &lt;code&gt;Boolean&lt;/code&gt; values in conditions</source>
          <target state="translated">条件でのnull許容 &lt;code&gt;Boolean&lt;/code&gt; 値の使用</target>
        </trans-unit>
        <trans-unit id="d6a1a404256e60f476abcfdb633a3c534e236959" translate="yes" xml:space="preserve">
          <source>Using nullable values and checking for &lt;em&gt;null&lt;/em&gt;</source>
          <target state="translated">NULL可能値を使用してのチェック&lt;em&gt;はnull&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="872ffc0740cd8cd114c0bd134533ae0bef8b975c" translate="yes" xml:space="preserve">
          <source>Using our favorite editor, we create a new file called &lt;em&gt;library.kt&lt;/em&gt;:</source>
          <target state="translated">お気に入りのエディターを使用して、&lt;em&gt;library.kt&lt;/em&gt;という新しいファイルを作成します。</target>
        </trans-unit>
        <trans-unit id="4b0f18fbc913dc4d928de83407023cd4eadce18c" translate="yes" xml:space="preserve">
          <source>Using packages from npm</source>
          <target state="translated">npmからパッケージを使う</target>
        </trans-unit>
        <trans-unit id="550a8f8d20b2e8584106d065339f4d4da1689dfc" translate="yes" xml:space="preserve">
          <source>Using ranges</source>
          <target state="translated">範囲の使用</target>
        </trans-unit>
        <trans-unit id="51f179a48f07181aae2f460999afe3b38f8238e7" translate="yes" xml:space="preserve">
          <source>Using scope functions apply/with/run/also/let</source>
          <target state="translated">スコープ関数の使用 apply/with/run/also/let</target>
        </trans-unit>
        <trans-unit id="3ec4dda09fda63d9abb963027b78f1d3b6ffe21e" translate="yes" xml:space="preserve">
          <source>Using string templates</source>
          <target state="translated">文字列テンプレートの使用</target>
        </trans-unit>
        <trans-unit id="4e76a46a35a0080ea05cb7befbedfc77e476e034" translate="yes" xml:space="preserve">
          <source>Using strings</source>
          <target state="translated">文字列の使用</target>
        </trans-unit>
        <trans-unit id="e23bbbb1e9be4eb1c796c8553364504fb8af04eb" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;List&amp;lt;Int&amp;gt;&lt;/code&gt; result type, means we can only return all the values at once. To represent the stream of values that are being asynchronously computed, we can use a &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-flow/index.html&quot;&gt;&lt;code&gt;Flow&amp;lt;Int&amp;gt;&lt;/code&gt;&lt;/a&gt; type just like we would use the &lt;code&gt;Sequence&amp;lt;Int&amp;gt;&lt;/code&gt; type for synchronously computed values:</source>
          <target state="translated">&lt;code&gt;List&amp;lt;Int&amp;gt;&lt;/code&gt; 結果タイプを使用すると、一度にすべての値しか返すことができないことを意味します。非同期で計算される値のストリームを表すために、同期的に計算される値に &lt;code&gt;Sequence&amp;lt;Int&amp;gt;&lt;/code&gt; タイプを使用するのと同じように、&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-flow/index.html&quot;&gt; &lt;code&gt;Flow&amp;lt;Int&amp;gt;&lt;/code&gt; &lt;/a&gt;タイプを使用できます。</target>
        </trans-unit>
        <trans-unit id="18148327a2ccfbb8e71316dac9304b16aaccd2b3" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;kotlin-multiplatform&lt;/code&gt; plugin for building &lt;a href=&quot;multiplatform&quot;&gt;multiplatform projects&lt;/a&gt; is described in &lt;a href=&quot;building-mpp-with-gradle&quot;&gt;Building Multiplatform Projects with Gradle&lt;/a&gt;.</source>
          <target state="translated">使用 &lt;code&gt;kotlin-multiplatform&lt;/code&gt; 構築するためのプラグインを&lt;a href=&quot;multiplatform&quot;&gt;マルチプラットフォームのプロジェクトは&lt;/a&gt;に記述されている&lt;a href=&quot;building-mpp-with-gradle&quot;&gt;のGradleで構築するマルチプラットフォームのプロジェクト&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="662526f9ec265672a8f5eadc1e458fce90d93089" translate="yes" xml:space="preserve">
          <source>Using the C Function Pointer from Kotlin</source>
          <target state="translated">KotlinからC関数ポインタを使う</target>
        </trans-unit>
        <trans-unit id="3b3c88f2622b6c11af48eeafb534d5bf373c1268" translate="yes" xml:space="preserve">
          <source>Using the Code from Objective-C</source>
          <target state="translated">Objective-Cのコードを使う</target>
        </trans-unit>
        <trans-unit id="2751cf504326591f0615360e90b35bf6098ad931" translate="yes" xml:space="preserve">
          <source>Using the Code from Swift</source>
          <target state="translated">Swiftのコードを使う</target>
        </trans-unit>
        <trans-unit id="d94748ae1985e15517523c51bbe68be1dc451c79" translate="yes" xml:space="preserve">
          <source>Using the Kotlin/JS IR compiler</source>
          <target state="translated">Kotlin/JS IR コンパイラを使う</target>
        </trans-unit>
        <trans-unit id="51e131a08f907def09c45df11a971dfb390d42ac" translate="yes" xml:space="preserve">
          <source>Using the command line to run scripts</source>
          <target state="translated">コマンドラインを使ってスクリプトを実行する</target>
        </trans-unit>
        <trans-unit id="0dde1829bc0d42dfa9d3d99dc69c6583462ddf28" translate="yes" xml:space="preserve">
          <source>Using the tool &lt;code&gt;ts2kt&lt;/code&gt; (TypeScript to Kotlin) we can convert any &lt;code&gt;d.ts&lt;/code&gt; files to Kotlin. To install the tool we can use &lt;code&gt;npm&lt;/code&gt;</source>
          <target state="translated">ツール &lt;code&gt;ts2kt&lt;/code&gt; （TypeScriptからKotlin）を使用して、 &lt;code&gt;d.ts&lt;/code&gt; ファイルをKotlinに変換できます。ツールをインストールするには、 &lt;code&gt;npm&lt;/code&gt; を使用できます</target>
        </trans-unit>
        <trans-unit id="a89a0f28e4e5bf44543e1c9581c55c0e6aecc40d" translate="yes" xml:space="preserve">
          <source>Using trailing commas has several benefits:</source>
          <target state="translated">最後にカンマを使用すると、いくつかの利点があります。</target>
        </trans-unit>
        <trans-unit id="4ebccac5de220cac33103fa30ac3780779ac2fcd" translate="yes" xml:space="preserve">
          <source>Using ts2kt to generate header files for Kotlin</source>
          <target state="translated">ts2kt を使って Kotlin のヘッダファイルを生成する</target>
        </trans-unit>
        <trans-unit id="e0fbba9738442b4c0647e5831e5969871c4f6a2a" translate="yes" xml:space="preserve">
          <source>Using type checks and automatic casts</source>
          <target state="translated">タイプチェックと自動キャストの使用</target>
        </trans-unit>
        <trans-unit id="d8d81e999a726d52e9414f74a35f368a368d19de" translate="yes" xml:space="preserve">
          <source>Usually these fields are private but they can be exposed in one of the following ways:</source>
          <target state="translated">通常、これらのフィールドは非公開ですが、以下のいずれかの方法で公開することができます。</target>
        </trans-unit>
        <trans-unit id="c1278d398657af96687576590c71d68b9a3f58aa" translate="yes" xml:space="preserve">
          <source>Usually, a native binary can be compiled as &lt;em&gt;debug&lt;/em&gt; with more debug information and fewer optimizations, and &lt;em&gt;release&lt;/em&gt; where optimizations are enabled and there is no (or at least less) debug information available.</source>
          <target state="translated">通常、ネイティブバイナリとしてコンパイルすることができない&lt;em&gt;デバッグ&lt;/em&gt;複数のデバッグ情報と少ない最適化と、および&lt;em&gt;解放&lt;/em&gt;最適化が有効にされるとNO（以下少なくとも）がある利用可能なデバッグ情報。</target>
        </trans-unit>
        <trans-unit id="12caefb8a5010ce40aa23c1ea29352f8837f75ed" translate="yes" xml:space="preserve">
          <source>Usually, the cast operator throws an exception if the cast is not possible. Thus, we call it &lt;em&gt;unsafe&lt;/em&gt;. The unsafe cast in Kotlin is done by the infix operator &lt;em&gt;as&lt;/em&gt; (see &lt;a href=&quot;https://kotlinlang.org/docs/reference/grammar.html#expressions&quot;&gt;operator precedence&lt;/a&gt;):</source>
          <target state="translated">通常、キャストが不可能な場合、キャスト演算子は例外をスローします。したがって、これを&lt;em&gt;unsafe&lt;/em&gt;と呼びます。Kotlinで危険なキャストが中置演算子によって行われている&lt;em&gt;として&lt;/em&gt;（参照&lt;a href=&quot;https://kotlinlang.org/docs/reference/grammar.html#expressions&quot;&gt;演算子の優先順位を&lt;/a&gt;）：</target>
        </trans-unit>
        <trans-unit id="078efedb0f7a9297e4a66c7bf48c73578606e64d" translate="yes" xml:space="preserve">
          <source>Utility functions for concurrent programming.</source>
          <target state="translated">コンカレントプログラミングのためのユーティリティ関数。</target>
        </trans-unit>
        <trans-unit id="54a27f71a3926c933fffb4cc8fcd736d36aae00b" translate="yes" xml:space="preserve">
          <source>Utility functions for working with Java 8 &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html&quot;&gt;streams&lt;/a&gt;.</source>
          <target state="translated">Java 8 &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html&quot;&gt;ストリーム&lt;/a&gt;を操作するためのユーティリティ関数。</target>
        </trans-unit>
        <trans-unit id="70a0023fe530c9e1dc6b5efd1156df2342cee154" translate="yes" xml:space="preserve">
          <source>Utility functions for working with the browser DOM.</source>
          <target state="translated">ブラウザの DOM を操作するためのユーティリティ機能。</target>
        </trans-unit>
        <trans-unit id="7dc10180b878fd7bd185c2d6a23c0519a292a3a0" translate="yes" xml:space="preserve">
          <source>VALUE</source>
          <target state="translated">VALUE</target>
        </trans-unit>
        <trans-unit id="b48498a5cff3c4e7ce37b18fdd81413319dd4656" translate="yes" xml:space="preserve">
          <source>VALUE_PARAMETER</source>
          <target state="translated">VALUE_PARAMETER</target>
        </trans-unit>
        <trans-unit id="242cc9162b91c0b54499ac05fdd663dcea97e3ff" translate="yes" xml:space="preserve">
          <source>ValidityState</source>
          <target state="translated">ValidityState</target>
        </trans-unit>
        <trans-unit id="4ca51107e6a14998cd7631ba2234ead0b2f51037" translate="yes" xml:space="preserve">
          <source>Value arguments</source>
          <target state="translated">値の引数</target>
        </trans-unit>
        <trans-unit id="bc813f9a338f88bada03e57203025b97e72de98e" translate="yes" xml:space="preserve">
          <source>Value parameter of a function or a constructor</source>
          <target state="translated">関数またはコンストラクタの値パラメータ</target>
        </trans-unit>
        <trans-unit id="ae0d9f73010cf89531cbcdadc5148c931b0aba52" translate="yes" xml:space="preserve">
          <source>Values are &lt;em&gt;collected&lt;/em&gt; from the flow using &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/collect.html&quot;&gt;collect&lt;/a&gt; function.</source>
          <target state="translated">値は、&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/collect.html&quot;&gt;collect&lt;/a&gt;関数を使用してフローから&lt;em&gt;収集さ&lt;/em&gt;れます。</target>
        </trans-unit>
        <trans-unit id="9d4b78efaf35ec9ac8ccb78b50e8f937f6c083fa" translate="yes" xml:space="preserve">
          <source>Values are &lt;em&gt;emitted&lt;/em&gt; from the flow using &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-flow-collector/emit.html&quot;&gt;emit&lt;/a&gt; function.</source>
          <target state="translated">値は、&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-flow-collector/emit.html&quot;&gt;emit&lt;/a&gt;関数を使用してフローから出力&lt;em&gt;さ&lt;/em&gt;れます。</target>
        </trans-unit>
        <trans-unit id="ae7d4e58b65d5a70d4dfae24ee97f38d7c1a9ff0" translate="yes" xml:space="preserve">
          <source>Values can be updated. In turn, keys never change: once you add an entry, its key is constant.</source>
          <target state="translated">値は更新することができます。一度エントリを追加すると、そのキーは一定になります。</target>
        </trans-unit>
        <trans-unit id="83ce8efcd219286f9e80c1c630307f7c0a05ac1f" translate="yes" xml:space="preserve">
          <source>Values of an annotation instance are exposed as properties to Kotlin code:</source>
          <target state="translated">アノテーションのインスタンスの値は、Kotlin コードのプロパティとして公開されます。</target>
        </trans-unit>
        <trans-unit id="e2e1116424b8a24a96cede1b506dcc3d11485f0b" translate="yes" xml:space="preserve">
          <source>VarType</source>
          <target state="translated">VarType</target>
        </trans-unit>
        <trans-unit id="42ec9490f36e6cae9913c4374b09e32237c707ad" translate="yes" xml:space="preserve">
          <source>Varargs and optional/named parameters</source>
          <target state="translated">Varargs とオプション/名前付きパラメータ</target>
        </trans-unit>
        <trans-unit id="10eea16b487acafb1da690a6fa932f924aadcf7a" translate="yes" xml:space="preserve">
          <source>Variable inspection</source>
          <target state="translated">可変検査</target>
        </trans-unit>
        <trans-unit id="342ee951b83918c9c708f1243be034edc6ba7220" translate="yes" xml:space="preserve">
          <source>Variable inspections for var variables works out of the box for primitive types. For non-primitive types there are custom pretty printers for lldb in &lt;code&gt;konan_lldb.py&lt;/code&gt;:</source>
          <target state="translated">var変数の変数検査は、プリミティブ型のボックスのすぐに機能します。プリミティブ以外のタイプの場合、konan_lldb.pyに &lt;code&gt;konan_lldb.py&lt;/code&gt; 用のカスタムプリティプリンターがあります。</target>
        </trans-unit>
        <trans-unit id="a018b33a39aac69fe200a8b99412d4c30ecc8054" translate="yes" xml:space="preserve">
          <source>Variable names should use &lt;code&gt;lowerCamelCase&lt;/code&gt; instead of &lt;code&gt;snake_case&lt;/code&gt;.</source>
          <target state="translated">変数名は使用すべき &lt;code&gt;lowerCamelCase&lt;/code&gt; の代わり &lt;code&gt;snake_case&lt;/code&gt; を。</target>
        </trans-unit>
        <trans-unit id="43edb35cae8befc5879d0b7aa2cd22c92255e5d7" translate="yes" xml:space="preserve">
          <source>Variable number of arguments (Varargs)</source>
          <target state="translated">可変引数数(Varargs</target>
        </trans-unit>
        <trans-unit id="ac018db1f7b00972061adff843d37497d8ee153c" translate="yes" xml:space="preserve">
          <source>Variables</source>
          <target state="translated">Variables</target>
        </trans-unit>
        <trans-unit id="eaac90ed072370b9f57426b726154a33050c4fed" translate="yes" xml:space="preserve">
          <source>Variables &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; get the values returned by &lt;code&gt;component1()&lt;/code&gt; and &lt;code&gt;component2()&lt;/code&gt; called on elements of the collection.</source>
          <target state="translated">変数 &lt;code&gt;a&lt;/code&gt; および &lt;code&gt;b&lt;/code&gt; は、コレクションの要素で呼び出された &lt;code&gt;component1()&lt;/code&gt; および &lt;code&gt;component2()&lt;/code&gt; によって返された値を取得します。</target>
        </trans-unit>
        <trans-unit id="808412b58bbf8525d5dac7961edbdfc05c3db76a" translate="yes" xml:space="preserve">
          <source>Variables that can be reassigned use the &lt;code&gt;var&lt;/code&gt; keyword:</source>
          <target state="translated">再割り当て可能な変数は、 &lt;code&gt;var&lt;/code&gt; キーワードを使用します。</target>
        </trans-unit>
        <trans-unit id="eb39bbf6ccbbc8fdb77438c3cd6155bb1b7ec6b8" translate="yes" xml:space="preserve">
          <source>Variance</source>
          <target state="translated">Variance</target>
        </trans-unit>
        <trans-unit id="1a91ea423a97d4a87943d588b081e7e38282531c" translate="yes" xml:space="preserve">
          <source>Variance directions</source>
          <target state="translated">バリアンスの方向性</target>
        </trans-unit>
        <trans-unit id="5c16bf6df0ccb8c8f8d9897278f38f99a8d180ae" translate="yes" xml:space="preserve">
          <source>Variant generics</source>
          <target state="translated">異種ジェネリック</target>
        </trans-unit>
        <trans-unit id="48aeb525f24a17a17a2746ff3465033889ff970a" translate="yes" xml:space="preserve">
          <source>Various collections and sequences can be converted to flows using &lt;code&gt;.asFlow()&lt;/code&gt; extension functions.</source>
          <target state="translated">&lt;code&gt;.asFlow()&lt;/code&gt; 拡張関数を使用して、さまざまなコレクションとシーケンスをフローに変換できます。</target>
        </trans-unit>
        <trans-unit id="7ed714f305f37a57ecb8473b7415dfab9db01f6a" translate="yes" xml:space="preserve">
          <source>Various utilities for working with strings and char sequences.</source>
          <target state="translated">文字列や文字列を扱うための様々なユーティリティ。</target>
        </trans-unit>
        <trans-unit id="280853b24c26b2f29a476f73ab7f87fbd08c6186" translate="yes" xml:space="preserve">
          <source>Vector128</source>
          <target state="translated">Vector128</target>
        </trans-unit>
        <trans-unit id="6c08e229ae1df722641eb28302211d6c86591e45" translate="yes" xml:space="preserve">
          <source>Vector128Var</source>
          <target state="translated">Vector128Var</target>
        </trans-unit>
        <trans-unit id="9ffb8650f3fdd46d87c18838f3017eda5ad872f4" translate="yes" xml:space="preserve">
          <source>Vector128VarOf</source>
          <target state="translated">Vector128VarOf</target>
        </trans-unit>
        <trans-unit id="288ce52d20fd503b110a72d86e9675e1c95e19eb" translate="yes" xml:space="preserve">
          <source>Verify the emulator configuration and click &lt;strong&gt;Finish&lt;/strong&gt;.</source>
          <target state="translated">エミュレータの構成を確認し、[ &lt;strong&gt;完了&lt;/strong&gt; ]をクリックします。</target>
        </trans-unit>
        <trans-unit id="de621f8c2654b2397c981cb428da06adf04bb6fe" translate="yes" xml:space="preserve">
          <source>Versioned separately from the language</source>
          <target state="translated">言語とは別バージョン</target>
        </trans-unit>
        <trans-unit id="84bee7b1488f1e88fea6081e11b80da21edf9ec4" translate="yes" xml:space="preserve">
          <source>VideoFacingModeEnum</source>
          <target state="translated">VideoFacingModeEnum</target>
        </trans-unit>
        <trans-unit id="fa871b63d316a5ccaf06d516a54da0961996827d" translate="yes" xml:space="preserve">
          <source>VideoResizeModeEnum</source>
          <target state="translated">VideoResizeModeEnum</target>
        </trans-unit>
        <trans-unit id="64fea40a0473c85795b9336e14b2b716b018b418" translate="yes" xml:space="preserve">
          <source>VideoTrack</source>
          <target state="translated">VideoTrack</target>
        </trans-unit>
        <trans-unit id="c02eab00438fffc417a6ac0aa9bb22fc06605beb" translate="yes" xml:space="preserve">
          <source>View binding</source>
          <target state="translated">バインディングを見る</target>
        </trans-unit>
        <trans-unit id="db9fea7c8a56a15e997acc428b673797be1af865" translate="yes" xml:space="preserve">
          <source>View caching</source>
          <target state="translated">キャッシングを見る</target>
        </trans-unit>
        <trans-unit id="7d9ff4f0de398581c4640bcbb6e536c355a391be" translate="yes" xml:space="preserve">
          <source>Visibility</source>
          <target state="translated">Visibility</target>
        </trans-unit>
        <trans-unit id="0d73e14a3fcddf8956a7da60bbcb1e077c95f7a0" translate="yes" xml:space="preserve">
          <source>Visibility Modifiers</source>
          <target state="translated">可視性修飾子</target>
        </trans-unit>
        <trans-unit id="28ffb1b2d0c701707ce3c73f2c7cf4a513706777" translate="yes" xml:space="preserve">
          <source>Visibility is an aspect of a Kotlin declaration regulating where that declaration is accessible in the source code. Visibility can be changed with one of the following modifiers: &lt;code&gt;public&lt;/code&gt;, &lt;code&gt;protected&lt;/code&gt;, &lt;code&gt;internal&lt;/code&gt;, &lt;code&gt;private&lt;/code&gt;.</source>
          <target state="translated">可視性は、Kotlin宣言の1つの側面であり、ソースコード内でその宣言にアクセスできる場所を規定します。可視性は、次の修飾子の1つで変更できます： &lt;code&gt;public&lt;/code&gt; 、 &lt;code&gt;protected&lt;/code&gt; 、 &lt;code&gt;internal&lt;/code&gt; 、 &lt;code&gt;private&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="849b37d75d9e78cb34f760a7b86638406d0e4272" translate="yes" xml:space="preserve">
          <source>Visibility modifiers</source>
          <target state="translated">可視性修飾子</target>
        </trans-unit>
        <trans-unit id="572b59949083550c2f89c909f2a69634e1647c72" translate="yes" xml:space="preserve">
          <source>Visibility modifiers are required for declarations if the default visibility exposes them to the public API. This helps ensure that no declarations are exposed to the public API unintentionally.</source>
          <target state="translated">デフォルトの可視性がパブリック API に公開されている場合は、可視性修飾子が宣言に必要となります。これは、宣言が意図せずにパブリック API に公開されないようにするのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="8ccb166e167967c0af7bc8270ccff3bc3f332444" translate="yes" xml:space="preserve">
          <source>Visibility modifiers can't be placed on local variables, since their visibility is always limited to the containing block.</source>
          <target state="translated">可視性修飾子をローカル変数に配置することはできません。</target>
        </trans-unit>
        <trans-unit id="6cd8f7e2419769693129b0c2082de4e40a0da3a3" translate="yes" xml:space="preserve">
          <source>Visibility of Top-level Declarations</source>
          <target state="translated">トップレベル宣言の可視性</target>
        </trans-unit>
        <trans-unit id="b794e604145c856d9c96b2bfb79a673421c9cf64" translate="yes" xml:space="preserve">
          <source>Visibility of declarations marked with the &lt;code&gt;internal&lt;/code&gt; modifier.</source>
          <target state="translated">&lt;code&gt;internal&lt;/code&gt; 修飾子でマークされた宣言の可視性。</target>
        </trans-unit>
        <trans-unit id="63bf3a48e0f5fd4c5b7c9576056b33b03784b05d" translate="yes" xml:space="preserve">
          <source>Visibility of declarations marked with the &lt;code&gt;private&lt;/code&gt; modifier.</source>
          <target state="translated">&lt;code&gt;private&lt;/code&gt; 修飾子でマークされた宣言の可視性。</target>
        </trans-unit>
        <trans-unit id="d02ce232d311d05d3099c6a996cbef8c4dd286f9" translate="yes" xml:space="preserve">
          <source>Visibility of declarations marked with the &lt;code&gt;protected&lt;/code&gt; modifier.</source>
          <target state="translated">&lt;code&gt;protected&lt;/code&gt; 修飾子でマークされた宣言の可視性。</target>
        </trans-unit>
        <trans-unit id="dd1c739248ca96578cca7f9bfb547899b54a876f" translate="yes" xml:space="preserve">
          <source>Visibility of declarations marked with the &lt;code&gt;public&lt;/code&gt; modifier, or with no modifier at all.</source>
          <target state="translated">&lt;code&gt;public&lt;/code&gt; 修飾子でマークされた宣言、または修飾子がまったくない宣言の可視性。</target>
        </trans-unit>
        <trans-unit id="de706486df3bb39a3413cb5cbbb1d996126bda21" translate="yes" xml:space="preserve">
          <source>Visibility of this callable, or &lt;code&gt;null&lt;/code&gt; if its visibility cannot be represented in Kotlin.</source>
          <target state="translated">この呼び出し可能オブジェクトの可視性。可視性がKotlinで表現できない場合は &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dac6119f07007062b4875b1638bac8a721585f4a" translate="yes" xml:space="preserve">
          <source>Visibility of this class, or &lt;code&gt;null&lt;/code&gt; if its visibility cannot be represented in Kotlin.</source>
          <target state="translated">このクラスの可視性。可視性がKotlinで表現できない場合は &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aabca03bdef260f1cffd784ffe10c2b762503211" translate="yes" xml:space="preserve">
          <source>Visibility rules regarding complex class hierarchies with companion objects</source>
          <target state="translated">コンパニオンオブジェクトを持つ複雑なクラス階層に関する可視化ルール</target>
        </trans-unit>
        <trans-unit id="ac3022e113442db8619d262ae03fa9c0097a6e0d" translate="yes" xml:space="preserve">
          <source>Volatile</source>
          <target state="translated">Volatile</target>
        </trans-unit>
        <trans-unit id="74365b04f91d0aa9f5cfe78a2b9d8c743270db07" translate="yes" xml:space="preserve">
          <source>Volatiles are of no help</source>
          <target state="translated">揮発性物質は役に立たない</target>
        </trans-unit>
        <trans-unit id="fd3edc641024a335a508fdacefb5f51ded5905cc" translate="yes" xml:space="preserve">
          <source>WARNING</source>
          <target state="translated">WARNING</target>
        </trans-unit>
        <trans-unit id="4e946026a7ff331eb2b9dc124f891817863bd199" translate="yes" xml:space="preserve">
          <source>WASM</source>
          <target state="translated">WASM</target>
        </trans-unit>
        <trans-unit id="25ca2ee13f635d58b0c2cff69efbc6a4f1b88f58" translate="yes" xml:space="preserve">
          <source>WASM32</source>
          <target state="translated">WASM32</target>
        </trans-unit>
        <trans-unit id="406538ae6cd24bca924c59857d3c75a306aa56eb" translate="yes" xml:space="preserve">
          <source>WATCHOS</source>
          <target state="translated">WATCHOS</target>
        </trans-unit>
        <trans-unit id="b9fac4aec6291b1c5ab0f9569e59e39d2636356c" translate="yes" xml:space="preserve">
          <source>WCString</source>
          <target state="translated">WCString</target>
        </trans-unit>
        <trans-unit id="c1cd547450ddf19820dbba6198904ce66087e598" translate="yes" xml:space="preserve">
          <source>WHITESPACE</source>
          <target state="translated">WHITESPACE</target>
        </trans-unit>
        <trans-unit id="2e31950e28a56c4fe6e7025b187b2fd4fefe4871" translate="yes" xml:space="preserve">
          <source>WINDOWS</source>
          <target state="translated">WINDOWS</target>
        </trans-unit>
        <trans-unit id="d9fff1c0dfb1298ad2bb377a3be85896a8fef6d6" translate="yes" xml:space="preserve">
          <source>Waiting for a job</source>
          <target state="translated">仕事を待っている</target>
        </trans-unit>
        <trans-unit id="43754c49f6c1a5cc1ea3d54dbf166c296a415ea2" translate="yes" xml:space="preserve">
          <source>Warning! Annotating your API with &lt;code&gt;@JvmDefault&lt;/code&gt; has serious implications on binary compatibility. Make sure to carefully read the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.jvm/-jvm-default/index&quot;&gt;reference page&lt;/a&gt; before using &lt;code&gt;@JvmDefault&lt;/code&gt; in production.</source>
          <target state="translated">警告！ &lt;code&gt;@JvmDefault&lt;/code&gt; を使用してAPIに注釈を付けると、バイナリ互換性に重大な影響があります。本番 &lt;code&gt;@JvmDefault&lt;/code&gt; で@JvmDefaultを使用する前に、&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.jvm/-jvm-default/index&quot;&gt;リファレンスページ&lt;/a&gt;をよくお読みください。</target>
        </trans-unit>
        <trans-unit id="7d38e4cd7c43347e6b57a76218aeff28900c3be2" translate="yes" xml:space="preserve">
          <source>Warning: using reflection is usually the wrong way to solve problems in Kotlin! In particular, if you have several classes that all have some common properties/functions and you want to write a function that can take an instance of any of those classes and use those properties, the correct approach is to define an interface with the common properties/functions and make all the relevant classes implement it; the function can then take that interface as a parameter. If you don't control those classes, you can use the &lt;a href=&quot;https://en.wikipedia.org/wiki/Adapter_pattern&quot;&gt;Adapter pattern&lt;/a&gt; and write wrapper classes that implement the interface - this is very easy thanks to Kotlin's &lt;a href=&quot;inheritance#delegation&quot;&gt;delegation feature&lt;/a&gt;. You can also get a lot of leverage out of using generics in clever ways.</source>
          <target state="translated">警告：リフレクションの使用は、通常、Kotlinの問題を解決するための間違った方法です。特に、すべてにいくつかの共通のプロパティ/関数を持ついくつかのクラスがあり、それらのクラスのインスタンスを取得してそれらのプロパティを使用できる関数を記述したい場合、正しいアプローチは、共通のプロパティを持つインターフェイスを定義することです/関数を使用して、関連するすべてのクラスにそれを実装させます。次に、関数はそのインターフェースをパラメーターとして使用できます。これらのクラスを制御しない場合は、&lt;a href=&quot;https://en.wikipedia.org/wiki/Adapter_pattern&quot;&gt;アダプターパターン&lt;/a&gt;を使用して、インターフェイスを実装するラッパークラスを作成できます。これは、Kotlinの&lt;a href=&quot;inheritance#delegation&quot;&gt;委任機能&lt;/a&gt;のおかげで非常に簡単です。また、ジェネリックを巧妙に使用することで、多くの効果を得ることができます。</target>
        </trans-unit>
        <trans-unit id="5869fc3835710be9dffa94b09164944fe6c00863" translate="yes" xml:space="preserve">
          <source>Warnings as errors</source>
          <target state="translated">エラーとしての警告</target>
        </trans-unit>
        <trans-unit id="7d7a6c37ae0a89dc47c6393b7b23a560c9ff63a7" translate="yes" xml:space="preserve">
          <source>Watch for deprecation warnings in advance for the best update experience.</source>
          <target state="translated">最高のアップデート体験のために、事前に非推奨の警告に注意してください。</target>
        </trans-unit>
        <trans-unit id="621508220c73315e0bfc68d68f589c562907f45d" translate="yes" xml:space="preserve">
          <source>We add the &lt;code&gt;SharedCode&lt;/code&gt; framework to the Xcode project. For that let's click on the root node of the &lt;em&gt;project navigator&lt;/em&gt; and select the &lt;em&gt;target&lt;/em&gt; settings. Next, we click on the &lt;code&gt;+&lt;/code&gt; in the &lt;em&gt;Embedded Binaries&lt;/em&gt; section, click &lt;em&gt;Add Other&amp;hellip;&lt;/em&gt; button in the dialog to choose the framework from the disk. We can point to the following folder:</source>
          <target state="translated">&lt;code&gt;SharedCode&lt;/code&gt; フレームワークをXcodeプロジェクトに追加します。そのためには、&lt;em&gt;プロジェクトナビゲーターの&lt;/em&gt;ルートノードをクリックして、&lt;em&gt;ターゲット&lt;/em&gt;設定を選択します。次に、我々はをクリックしてください &lt;code&gt;+&lt;/code&gt; に&lt;em&gt;埋め込まれたバイナリ&lt;/em&gt;セクション、クリック&lt;em&gt;その他...追加&lt;/em&gt;ディスクからのフレームワークを選択するダイアログのボタンを。次のフォルダを指定できます。</target>
        </trans-unit>
        <trans-unit id="6a9f25c8723418966c0e0b17f9549ea1ce5a5f99" translate="yes" xml:space="preserve">
          <source>We also need to use the &lt;em&gt;war&lt;/em&gt; plugin that helps us generate the corresponding WAR artifacts for running/deploying</source>
          <target state="translated">また、実行/デプロイのために対応するWARアーティファクトを生成するのに役立つ&lt;em&gt;war&lt;/em&gt;プラグインを使用する必要があります</target>
        </trans-unit>
        <trans-unit id="8f769d9a3ee354265c33ea15ceda2db82197765c" translate="yes" xml:space="preserve">
          <source>We are just trying out an idea and want some users to play with it and give feedback. If it doesn't work out, we may drop it any minute.</source>
          <target state="translated">私たちはアイデアを試しているだけで、何人かのユーザーに遊んでもらい、フィードバックをしてもらいたいと思っています。それがうまくいかない場合は、我々はいつでもそれをドロップすることがあります。</target>
        </trans-unit>
        <trans-unit id="f808d588d4d3fcebee5f5b3ff2c14b3f46e0e3a6" translate="yes" xml:space="preserve">
          <source>We are now migrating Kotlin/JVM and Kotlin/JS to the same IR. As a result, all three backends share a lot of logic and have a unified pipeline. This allows us to implement most features, optimizations, and bug fixes only once for all platforms. Both new IR-based back-ends are in &lt;a href=&quot;evolution/components-stability&quot;&gt;Alpha&lt;/a&gt;.</source>
          <target state="translated">現在、Kotlin / JVMとKotlin / JSを同じIRに移行しています。その結果、3つのバックエンドすべてが多くのロジックを共有し、統一されたパイプラインを備えています。これにより、ほとんどの機能、最適化、バグ修正をすべてのプラットフォームに1回だけ実装できます。新しいIRベースのバックエンドは両方とも&lt;a href=&quot;evolution/components-stability&quot;&gt;Alpha&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="05a06031f1e06a7952c57e44121ca5e185850421" translate="yes" xml:space="preserve">
          <source>We are now ready to start coding the iOS application and to use the Kotlin code from it</source>
          <target state="translated">これでiOSアプリのコーディングを開始し、そこからKotlinのコードを使用する準備が整いました。</target>
        </trans-unit>
        <trans-unit id="cff8cb63586d851860fe613c1e521ee0461e4b2e" translate="yes" xml:space="preserve">
          <source>We are ready to use the &lt;code&gt;SharedCode&lt;/code&gt; library from our Android and iOS applications.</source>
          <target state="translated">AndroidおよびiOSアプリケーションから &lt;code&gt;SharedCode&lt;/code&gt; ライブラリーを使用する準備が整いました。</target>
        </trans-unit>
        <trans-unit id="14edea8060ff3b0350a868b06c73ba61ae235890" translate="yes" xml:space="preserve">
          <source>We are starting with an implementation for the JVM. Let's create a file &lt;code&gt;Base64.kt&lt;/code&gt; in &lt;code&gt;jvmMain/kotlin/jetbrains/base64&lt;/code&gt; folder and provide a simple implementation, which delegates to &lt;code&gt;java.util.Base64&lt;/code&gt;:</source>
          <target state="translated">JVMの実装から始めます。のは、ファイルを作成してみましょう &lt;code&gt;Base64.kt&lt;/code&gt; をして &lt;code&gt;jvmMain/kotlin/jetbrains/base64&lt;/code&gt; フォルダとに委譲簡単な実装、提供 &lt;code&gt;java.util.Base64&lt;/code&gt; を：</target>
        </trans-unit>
        <trans-unit id="b38f2316b8757428d73f475d7c1fadf769b873b4" translate="yes" xml:space="preserve">
          <source>We are using &lt;a href=&quot;https://jetbrains.com/idea&quot;&gt;IntelliJ IDEA&lt;/a&gt; for this tutorial. Both the &lt;a href=&quot;https://www.jetbrains.com/idea/features/editions_comparison_matrix.html&quot;&gt;free and open source&lt;/a&gt; IntelliJ IDEA &lt;a href=&quot;https://www.jetbrains.com/idea/download&quot;&gt;Community Edition&lt;/a&gt; and IntelliJ IDEA Ultimate Edition work for this tutorial. We can download and install both of them from &lt;a href=&quot;https://jetbrains.com/idea/download&quot;&gt;https://jetbrains.com/idea/download&lt;/a&gt; if necessary. The Kotlin plugin is included with IntelliJ IDEA by default, but still, we need to make sure the Kotlin plugin version is 1.3.41 (or newer) in the &lt;em&gt;Settings&lt;/em&gt; or &lt;em&gt;Preferences&lt;/em&gt; dialog, under the Language &amp;amp; Frameworks | Kotlin section.</source>
          <target state="translated">このチュートリアルでは&lt;a href=&quot;https://jetbrains.com/idea&quot;&gt;IntelliJ IDEA&lt;/a&gt;を使用しています。このチュートリアルでは、&lt;a href=&quot;https://www.jetbrains.com/idea/features/editions_comparison_matrix.html&quot;&gt;フリーソースとオープンソースの&lt;/a&gt; IntelliJ IDEA &lt;a href=&quot;https://www.jetbrains.com/idea/download&quot;&gt;Community Edition&lt;/a&gt;とIntelliJ IDEA Ultimate Editionの両方が機能します。必要に応じて、&lt;a href=&quot;https://jetbrains.com/idea/download&quot;&gt;https：//jetbrains.com/idea/download&lt;/a&gt;から両方をダウンロードしてインストールできます。 KotlinプラグインはデフォルトでIntelliJ IDEAに含まれていますが、それでも、&lt;em&gt;[設定]&lt;/em&gt;または[ &lt;em&gt;設定&lt;/em&gt; ]ダイアログの[言語とフレームワーク]でKotlinプラグインのバージョンが1.3.41以降であることを確認する必要があります。 Kotlinセクション。</target>
        </trans-unit>
        <trans-unit id="55cc632a1ea27e5e64ad2495a5384f62f48dbc86" translate="yes" xml:space="preserve">
          <source>We are using the &lt;code&gt;delay()&lt;/code&gt; function that's like &lt;code&gt;Thread.sleep()&lt;/code&gt;, but better: it &lt;em&gt;doesn't block a thread&lt;/em&gt;, but only suspends the coroutine itself. The thread is returned to the pool while the coroutine is waiting, and when the waiting is done, the coroutine resumes on a free thread in the pool.</source>
          <target state="translated">&lt;code&gt;Thread.sleep()&lt;/code&gt; のような &lt;code&gt;delay()&lt;/code&gt; 関数を使用して&lt;em&gt;いますが&lt;/em&gt;、これ&lt;em&gt;はスレッドをブロックせず&lt;/em&gt;、コルーチン自体を一時停止するだけです。コルーチンの待機中にスレッドがプールに戻され、待機が完了すると、コルーチンはプール内の空きスレッドで再開されます。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="da1efc61212d59164e482ecaadd2d5e755cb8ec9" translate="yes" xml:space="preserve">
          <source>We believe that a lot of users could use a much faster cycle, where critical compiler bug fixes arrive immediately, making the code more safe and correct. So, Kotlin 1.3 introduces &lt;em&gt;progressive&lt;/em&gt; compiler mode, which can be enabled by passing the argument &lt;code&gt;-progressive&lt;/code&gt; to the compiler.</source>
          <target state="translated">多くのユーザーは、より高速なサイクルを使用でき、重要なコンパイラのバグ修正がすぐに到着し、コードをより安全かつ正確にすることができると考えています。したがって、Kotlin 1.3では&lt;em&gt;プログレッシブ&lt;/em&gt;コンパイラモードが導入されています。これは、引数 &lt;code&gt;-progressive&lt;/code&gt; をコンパイラに渡すことで有効にできます。</target>
        </trans-unit>
        <trans-unit id="0e996e5615a264af995c203eaebe6185c018bf0a" translate="yes" xml:space="preserve">
          <source>We believe that the words &lt;strong&gt;in&lt;/strong&gt; and &lt;strong&gt;out&lt;/strong&gt; are self-explaining (as they were successfully used in C# for quite some time already), thus the mnemonic mentioned above is not really needed, and one can rephrase it for a higher purpose:</source>
          <target state="translated">私たちは、&lt;strong&gt;in&lt;/strong&gt;と&lt;strong&gt;out&lt;/strong&gt;の単語は自明&lt;strong&gt;である&lt;/strong&gt;と信じています（C＃でかなり長い間使用されていたため）。したがって、上記のニーモニックは実際には必要ではなく、より高い目的で言い換えることができます。</target>
        </trans-unit>
        <trans-unit id="a4b5a076e237cd86b9569bc0bd72070895b09bdf" translate="yes" xml:space="preserve">
          <source>We call &lt;code&gt;lib.exe&lt;/code&gt; from the toolchain to generate the static library wrapper &lt;code&gt;libnative.lib&lt;/code&gt; that automates the DLL usage from the code:</source>
          <target state="translated">ツールチェーンから &lt;code&gt;lib.exe&lt;/code&gt; を呼び出して、コードからDLLの使用を自動化する静的ライブラリラッパー &lt;code&gt;libnative.lib&lt;/code&gt; を生成します。</target>
        </trans-unit>
        <trans-unit id="b380a7bf1b634600b0c261666fb452d97fe21714" translate="yes" xml:space="preserve">
          <source>We call Kotlin classes directly from Objective-C code. A Kotlin &lt;code&gt;object&lt;/code&gt; has the class method function &lt;code&gt;object&lt;/code&gt;, which allows us to get the only instance of the object and to call &lt;code&gt;Object&lt;/code&gt; methods on it. The widespread pattern is used to create an instance of the &lt;code&gt;Clazz&lt;/code&gt; class. We call the &lt;code&gt;[[ DemoClazz alloc] init]&lt;/code&gt; on Objective-C. We may also use &lt;code&gt;[DemoClazz new]&lt;/code&gt; for constructors without parameters. Global declarations from the Kotlin sources are scoped under the &lt;code&gt;DemoLibKt&lt;/code&gt; class in Objective-C. All methods are turned into class methods of that class. The &lt;code&gt;strings&lt;/code&gt; function is turned into &lt;code&gt;DemoLibKt.stringsStr&lt;/code&gt; function in Objective-C, we can pass &lt;code&gt;NSString&lt;/code&gt; directly to it. The return is visible as &lt;code&gt;NSString&lt;/code&gt; too.</source>
          <target state="translated">Objective-Cコードから直接Kotlinクラスを呼び出します。 Kotlin &lt;code&gt;object&lt;/code&gt; は、クラスメソッドfunction &lt;code&gt;object&lt;/code&gt; があります。これにより、オブジェクトの唯一のインスタンスを取得し、そのオブジェクトの &lt;code&gt;Object&lt;/code&gt; メソッドを呼び出すことができます。広く使われているパターンは、 &lt;code&gt;Clazz&lt;/code&gt; クラスのインスタンスを作成するために使用されます。Objective-C では &lt;code&gt;[[ DemoClazz alloc] init]&lt;/code&gt; と呼んでいます。また、パラメーターのないコンストラクターに &lt;code&gt;[DemoClazz new]&lt;/code&gt; を使用する場合もあります。 Kotlinソースからのグローバル宣言は、Objective-Cの &lt;code&gt;DemoLibKt&lt;/code&gt; クラスにスコープされます。すべてのメソッドは、そのクラスのクラスメソッドに変換されます。 &lt;code&gt;strings&lt;/code&gt; 関数は、になっている &lt;code&gt;DemoLibKt.stringsStr&lt;/code&gt; Objective-Cの関数では、 &lt;code&gt;NSString&lt;/code&gt; を直接それに渡すことができます。戻り値も &lt;code&gt;NSString&lt;/code&gt; として表示されます。</target>
        </trans-unit>
        <trans-unit id="6efbfc50d097338c67f6c25e5a2530e00802bbf1" translate="yes" xml:space="preserve">
          <source>We can also check a value for being &lt;em&gt;in&lt;/em&gt; or &lt;em&gt;!in&lt;/em&gt; a &lt;a href=&quot;ranges&quot;&gt;range&lt;/a&gt; or a collection:</source>
          <target state="translated">我々はまた、さの値を確認することができます&lt;em&gt;に&lt;/em&gt;か&lt;em&gt;！で&lt;/em&gt;&lt;a href=&quot;ranges&quot;&gt;範囲&lt;/a&gt;またはコレクション：</target>
        </trans-unit>
        <trans-unit id="6d48b261007df82564fff9e248b32f0b0877a7db" translate="yes" xml:space="preserve">
          <source>We can also run the project from the command line, without using IntelliJ IDEA Ultimate, if we apply the gretty plugin. In order to do this, we need to make the following changes to build.gradle:</source>
          <target state="translated">また、grettyプラグインを適用すれば、IntelliJ IDEA Ultimateを使わずに、コマンドラインからプロジェクトを実行することもできます。そのためには、build.gradleに以下の変更を加える必要があります。</target>
        </trans-unit>
        <trans-unit id="be71c4616ae57b989081464748078b992e6a499b" translate="yes" xml:space="preserve">
          <source>We can also see how we can define whether we want the compiler to generate sourcemaps for us by indicating this via the &lt;code&gt;sourceMap&lt;/code&gt; option.</source>
          <target state="translated">また、 &lt;code&gt;sourceMap&lt;/code&gt; オプションでこれを示すことにより、コンパイラーにソースマップを生成させるかどうかを定義する方法も確認できます。</target>
        </trans-unit>
        <trans-unit id="db36be1716cde1f09b5bb491a1d29f546a1af582" translate="yes" xml:space="preserve">
          <source>We can also see how we can define whether we want the compiler to generate sourcemaps for us by indicating this via the &lt;code&gt;sourceMap&lt;/code&gt; parameter.</source>
          <target state="translated">また、 &lt;code&gt;sourceMap&lt;/code&gt; パラメーターでこれを示すことにより、コンパイラーにソースマップを生成させるかどうかを定義する方法も確認できます。</target>
        </trans-unit>
        <trans-unit id="b5bd60fd46fe6ea1c5b448761b2e310af9a2b34e" translate="yes" xml:space="preserve">
          <source>We can check whether an object conforms to a given type at runtime by using the &lt;code&gt;is&lt;/code&gt; operator or its negated form &lt;code&gt;!is&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;is&lt;/code&gt; 演算子またはその否定形式 &lt;code&gt;!is&lt;/code&gt; を使用して、実行時にオブジェクトが特定の型に準拠しているかどうかを確認できます。</target>
        </trans-unit>
        <trans-unit id="80fca726c567776685be62a6f296ba802e4a0c48" translate="yes" xml:space="preserve">
          <source>We can choose to let &lt;code&gt;MotorVehicle&lt;/code&gt; implement that interface, since it's got the required members - but now we need to mark those members with &lt;code&gt;override&lt;/code&gt;, and we can remove &lt;code&gt;open&lt;/code&gt; since an overridden function is implicitly open:</source>
          <target state="translated">&lt;code&gt;MotorVehicle&lt;/code&gt; に必要なメンバーがあるので、そのインターフェースを実装することを選択できます。ただし、これらのメンバーを &lt;code&gt;override&lt;/code&gt; でマークする必要があります。オーバーライドされた関数は暗黙的に開いて &lt;code&gt;open&lt;/code&gt; ため、openを削除できます。</target>
        </trans-unit>
        <trans-unit id="b29aa01092a4a2f64bc0e5bf97de56d6e4257337" translate="yes" xml:space="preserve">
          <source>We can click the file reference on the right to navigate directly to the corresponding statement. Alternatively, we can manually switch to the &lt;em&gt;Sources&lt;/em&gt; tab, and find the correct file in the file tree. Navigating to the Kotlin file actually shows us regular Kotlin code (as opposed to minified JavaScript):</source>
          <target state="translated">右側のファイル参照をクリックして、対応するステートメントに直接移動できます。または、手動で[&lt;em&gt;ソース&lt;/em&gt;]タブに切り替えて、ファイルツリーで正しいファイルを見つけることもできます。Kotlinファイルに移動すると、実際には通常のKotlinコードが表示されます（縮小されたJavaScriptではありません）。</target>
        </trans-unit>
        <trans-unit id="3df63e38e36909132576c3c502bfc7296d767131" translate="yes" xml:space="preserve">
          <source>We can combine the declarative nature of the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/catch.html&quot;&gt;catch&lt;/a&gt; operator with a desire to handle all the exceptions, by moving the body of the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/collect.html&quot;&gt;collect&lt;/a&gt; operator into &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/on-each.html&quot;&gt;onEach&lt;/a&gt; and putting it before the &lt;code&gt;catch&lt;/code&gt; operator. Collection of this flow must be triggered by a call to &lt;code&gt;collect()&lt;/code&gt; without parameters:</source>
          <target state="translated">私たちは、宣言型の性質を組み合わせることができます&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/catch.html&quot;&gt;キャッチ&lt;/a&gt;の体動かすことで、すべての例外を処理する欲求をオペレータに&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/collect.html&quot;&gt;収集&lt;/a&gt;にオペレータを&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/on-each.html&quot;&gt;onEach&lt;/a&gt;とする前にそれを置く &lt;code&gt;catch&lt;/code&gt; 演算子。このフローの収集は、パラメーターなしで &lt;code&gt;collect()&lt;/code&gt; を呼び出すことによってトリガーする必要があります。</target>
        </trans-unit>
        <trans-unit id="6ab28e12a4329ff5188bb6bb1c34f1f3bf4ce258" translate="yes" xml:space="preserve">
          <source>We can configure the Kotlin compiler option to use any of these. The last option (UMD) will generate UMD and fallback to the other options if one is not available. Currently Kotlin compiler options are per IntelliJ IDEA project as opposed to a Kotlin module.</source>
          <target state="translated">Kotlin コンパイラのオプションは、これらのいずれかを使用するように設定することができます。最後のオプション(UMD)はUMDを生成し、利用できない場合は他のオプションにフォールバックします。現在、KotlinコンパイラオプションはKotlinモジュールとは対照的にIntelliJ IDEAプロジェクトごとに設定されています。</target>
        </trans-unit>
        <trans-unit id="5b4c1b5549ed7b71f56b6d1ba48bd66bf46537dc" translate="yes" xml:space="preserve">
          <source>We can define async-style functions that invoke &lt;code&gt;doSomethingUsefulOne&lt;/code&gt; and &lt;code&gt;doSomethingUsefulTwo&lt;/code&gt;&lt;em&gt;asynchronously&lt;/em&gt; using &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html&quot;&gt;async&lt;/a&gt; coroutine builder with an explicit &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope&lt;/a&gt; reference. We name such functions with &quot;Async&quot; suffix to highlight the fact that they only start asynchronous computation and one needs to use the resulting deferred value to get the result.</source>
          <target state="translated">私たちは、Invokeことを非同期スタイルの機能を定義することができます &lt;code&gt;doSomethingUsefulOne&lt;/code&gt; と &lt;code&gt;doSomethingUsefulTwo&lt;/code&gt; &lt;em&gt;非同期で&lt;/em&gt;使用して&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html&quot;&gt;非同期&lt;/a&gt;明示的にコルーチンビルダーを&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScopeの&lt;/a&gt;参照を。そのような関数には「非同期」接尾辞を付けて、それらが非同期計算のみを開始し、結果の遅延値を使用して結果を取得する必要があることを強調します。</target>
        </trans-unit>
        <trans-unit id="452dc3c84f7cabd350d9558a57e866a1cf25ff79" translate="yes" xml:space="preserve">
          <source>We can define async-style functions that invoke &lt;code&gt;doSomethingUsefulOne&lt;/code&gt; and &lt;code&gt;doSomethingUsefulTwo&lt;/code&gt;&lt;em&gt;asynchronously&lt;/em&gt; using the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html&quot;&gt;async&lt;/a&gt; coroutine builder with an explicit &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope&lt;/a&gt; reference. We name such functions with the &quot;&amp;hellip;Async&quot; suffix to highlight the fact that they only start asynchronous computation and one needs to use the resulting deferred value to get the result.</source>
          <target state="translated">私たちは、Invokeことを非同期スタイルの関数を定義することができ &lt;code&gt;doSomethingUsefulOne&lt;/code&gt; と &lt;code&gt;doSomethingUsefulTwo&lt;/code&gt; &lt;em&gt;非同期で&lt;/em&gt;使用して&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html&quot;&gt;非同期&lt;/a&gt;明示的にコルーチンビルダーを&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScopeを&lt;/a&gt;参照。このような関数には「&amp;hellip;Async」という接尾辞を付けて、非同期計算のみを開始し、結果を取得するには結果の遅延値を使用する必要があるという事実を強調します。</target>
        </trans-unit>
        <trans-unit id="4ecb356b303055242a64963a7b2a1f314c6be1d3" translate="yes" xml:space="preserve">
          <source>We can define custom accessors for a property. If we define a custom getter, it will be called every time we access the property (this allows us to implement a computed property). Here's an example of a custom getter:</source>
          <target state="translated">プロパティにカスタム・アクセサを定義することができます。カスタム・ゲッターを定義すると、プロパティにアクセスするたびに呼び出されます (これにより、計算されたプロパティを実装することができます)。ここでは、カスタム・ゲッターの例を示します。</target>
        </trans-unit>
        <trans-unit id="b31aa9761950ea554c775fecf5e0c018baf882fd" translate="yes" xml:space="preserve">
          <source>We can easily call it directly (&lt;code&gt;isOdd(5)&lt;/code&gt;), but we can also use it as a function type value, e.g. pass it to another function. To do this, we use the &lt;code&gt;::&lt;/code&gt; operator:</source>
          <target state="translated">簡単に直接呼び出すことができます（ &lt;code&gt;isOdd(5)&lt;/code&gt; ）が、関数タイプの値として使用することもできます。たとえば、別の関数に渡すことができます。これを行うには、 &lt;code&gt;::&lt;/code&gt; 演算子を使用します。</target>
        </trans-unit>
        <trans-unit id="ae17c1ca56657ad30866237b96021ef47b3cda29" translate="yes" xml:space="preserve">
          <source>We can explicitly convert a character to an &lt;code&gt;Int&lt;/code&gt; number:</source>
          <target state="translated">文字を明示的に &lt;code&gt;Int&lt;/code&gt; 数に変換できます。</target>
        </trans-unit>
        <trans-unit id="d31ec9f07f4bc208cadad8ae2ec0b5f65d7cdf75" translate="yes" xml:space="preserve">
          <source>We can explicitly return a value from the lambda using the &lt;a href=&quot;returns#return-at-labels&quot;&gt;qualified return&lt;/a&gt; syntax. Otherwise, the value of the last expression is implicitly returned.</source>
          <target state="translated">&lt;a href=&quot;returns#return-at-labels&quot;&gt;修飾された戻り&lt;/a&gt;構文を使用して、ラムダから明示的に値を返すことができます。それ以外の場合、最後の式の値が暗黙的に返されます。</target>
        </trans-unit>
        <trans-unit id="5af6b3dce006afd131588be4e84caa508a65cc20" translate="yes" xml:space="preserve">
          <source>We can import either a single name, e.g.</source>
          <target state="translated">単一の名前をインポートすることができます。</target>
        </trans-unit>
        <trans-unit id="8a9f3b72eb46629a298e0a057eccfdabab01c204" translate="yes" xml:space="preserve">
          <source>We can install &lt;code&gt;kotlinizer&lt;/code&gt; to the default repository:</source>
          <target state="translated">&lt;code&gt;kotlinizer&lt;/code&gt; をデフォルトのリポジトリにインストールできます。</target>
        </trans-unit>
        <trans-unit id="6d3bad56e3c4235f442b8c993bfc65c9b26cdc43" translate="yes" xml:space="preserve">
          <source>We can now add our first Kotlin source code file and IntelliJ IDEA will prompt us to configure the project for Kotlin. On doing so, we should select as target JavaScript</source>
          <target state="translated">最初のKotlinのソースコードファイルを追加すると、IntelliJ IDEAがKotlin用のプロジェクトを設定するように促してくる。その際、ターゲットとしてJavaScriptの</target>
        </trans-unit>
        <trans-unit id="dc96081c653c84bb3dd3b5b83bfc524f3cd03b65" translate="yes" xml:space="preserve">
          <source>We can now do this (but it's still possible to call the function the normal way):</source>
          <target state="translated">これでできるようになりました(ただし、普通に関数を呼び出すことは可能です)。</target>
        </trans-unit>
        <trans-unit id="2028680260413907a6ff455452315ba4c9be7fe7" translate="yes" xml:space="preserve">
          <source>We can now start debugging our program. For example, we can set a breakpoint by clicking on one of the line numbers. The developer tools even support setting breakpoints within a statement. As with regular JavaScript code, any set breakpoints will persist across page reloads. This also makes it possible to debug Kotlin's main method which is executed when the script is first loaded.</source>
          <target state="translated">これでプログラムのデバッグを開始することができます。例えば、行番号をクリックしてブレークポイントを設定することができます。開発者ツールでは、ステートメント内でのブレークポイントの設定もサポートしています。通常の JavaScript コードと同様に、設定されたブレークポイントはページのリロードを繰り返しても持続します。これにより、スクリプトが最初に読み込まれたときに実行される Kotlin のメインメソッドのデバッグも可能になります。</target>
        </trans-unit>
        <trans-unit id="bb97bda68a25be3b25091829fa426075294c2d71" translate="yes" xml:space="preserve">
          <source>We can now use any of the standard Gradle tasks for Spring Boot to run the application. As such, running</source>
          <target state="translated">これで、Spring Boot用の標準的なGradleタスクを使ってアプリケーションを実行できるようになりました。このように</target>
        </trans-unit>
        <trans-unit id="c6898463443208b858c46602bd14f4fe18a2e216" translate="yes" xml:space="preserve">
          <source>We can override a non-abstract open member with an abstract one</source>
          <target state="translated">抽象的ではないオープンメンバを抽象的なものでオーバーライドすることができます。</target>
        </trans-unit>
        <trans-unit id="443dbeb7b5959da838f042d1c795f241e1156ec7" translate="yes" xml:space="preserve">
          <source>We can replace &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/delay.html&quot;&gt;delay&lt;/a&gt; with &lt;code&gt;Thread.sleep&lt;/code&gt; in the body of &lt;code&gt;simple&lt;/code&gt;'s &lt;code&gt;flow { ... }&lt;/code&gt; and see that the main thread is blocked in this case.</source>
          <target state="translated">&lt;code&gt;simple&lt;/code&gt; &lt;code&gt;flow { ... }&lt;/code&gt; の本体で&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/delay.html&quot;&gt;delay&lt;/a&gt;を &lt;code&gt;Thread.sleep&lt;/code&gt; に置き換えることができ、この場合、メインスレッドがブロックされていることがわかります。</target>
        </trans-unit>
        <trans-unit id="ec8ade084fb51f7b34b89fae3c572fe0de063884" translate="yes" xml:space="preserve">
          <source>We can run the compiler without parameters to have an interactive shell. We can type any valid Kotlin code and see the results.</source>
          <target state="translated">パラメータなしでコンパイラを実行して、インタラクティブなシェルを作ることができます。有効なKotlinコードを入力して結果を見ることができます。</target>
        </trans-unit>
        <trans-unit id="f29622b395465874ab1409644634bdf5bd547c3e" translate="yes" xml:space="preserve">
          <source>We can see how the API is created. To start with, we need to initialize the &lt;code&gt;libnative_ExportedSymbols&lt;/code&gt; structure. Let's take a look at the latest part of the &lt;code&gt;libnative_api.h&lt;/code&gt; for this:</source>
          <target state="translated">APIの作成方法を確認できます。まず、 &lt;code&gt;libnative_ExportedSymbols&lt;/code&gt; 構造体を初期化する必要があります。これについて、 &lt;code&gt;libnative_api.h&lt;/code&gt; の最新部分を見てみましょう。</target>
        </trans-unit>
        <trans-unit id="3d6f52d4243822ccee088838c7cbe381743f9a4c" translate="yes" xml:space="preserve">
          <source>We can see the completion cause is not null, because the flow was aborted due to downstream exception:</source>
          <target state="translated">下流の例外でフローがアボートされたので、完了原因がNULLではないことがわかります。</target>
        </trans-unit>
        <trans-unit id="d27d56a268fbe45c1d0688c4606abf60011997ba" translate="yes" xml:space="preserve">
          <source>We can simply refer to any class or member function inside our node.js code by simply importing the module using &lt;code&gt;require&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;require&lt;/code&gt; を使用してモジュールをインポートするだけで、node.jsコード内のクラスまたはメンバー関数を単に参照できます。</target>
        </trans-unit>
        <trans-unit id="831ccd2e7105b549d27fa757caf8f798b465ce95" translate="yes" xml:space="preserve">
          <source>We can simulate custom infix operations by using &lt;a href=&quot;functions#infix-notation&quot;&gt;infix function calls&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;functions#infix-notation&quot;&gt;infix関数呼び出し&lt;/a&gt;を使用して、カスタムのinfix操作をシミュレートできます。</target>
        </trans-unit>
        <trans-unit id="509f912bd5b5b6af65e5240f9ef362cc1a5f0b3f" translate="yes" xml:space="preserve">
          <source>We can start by creating a library file in Kotlin and save it as &lt;code&gt;hello.kt&lt;/code&gt;:</source>
          <target state="translated">まず、Kotlinでライブラリファイルを作成し、 &lt;code&gt;hello.kt&lt;/code&gt; として保存します。</target>
        </trans-unit>
        <trans-unit id="89f8fe8ceb180f0a0bdf079538aa483abb6121b4" translate="yes" xml:space="preserve">
          <source>We can then do this:</source>
          <target state="translated">そうすれば、こうすればいいのです。</target>
        </trans-unit>
        <trans-unit id="ce9fbf3c0deb149f881d772488fa422e85d659ce" translate="yes" xml:space="preserve">
          <source>We can tune how tests are executed in Kotlin/JS by adjusting the settings available in the &lt;code&gt;testTask&lt;/code&gt; block in our &lt;code&gt;build.gradle.kts&lt;/code&gt;. For example, using the Karma test runner together with a headless instance of Chrome and an instance of Firefox looks like this:</source>
          <target state="translated">&lt;code&gt;build.gradle.kts&lt;/code&gt; の &lt;code&gt;testTask&lt;/code&gt; ブロックで使用可能な設定を調整することで、Kotlin / JSでのテストの実行方法を調整できます。たとえば、KarmaテストランナーをChromeのヘッドレスインスタンスとFirefoxのインスタンスと一緒に使用すると、次のようになります。</target>
        </trans-unit>
        <trans-unit id="b16a2933e2edce96547337fb1fedcb97e299ea34" translate="yes" xml:space="preserve">
          <source>We can use a &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/buffer.html&quot;&gt;buffer&lt;/a&gt; operator on a flow to run emitting code of the &lt;code&gt;simple&lt;/code&gt; flow concurrently with collecting code, as opposed to running them sequentially:</source>
          <target state="translated">フローで&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/buffer.html&quot;&gt;バッファー&lt;/a&gt;演算子を使用して、コードを順番に実行するのではなく、コードの収集と同時に &lt;code&gt;simple&lt;/code&gt; フローの発行コードを実行できます。</target>
        </trans-unit>
        <trans-unit id="67a4cc600951e3a005f1c78d3f5d6ddad7aa6cbe" translate="yes" xml:space="preserve">
          <source>We can use arbitrary expressions (not only constants) as branch conditions</source>
          <target state="translated">任意の式(定数だけでなく)を分岐条件として使用することができます。</target>
        </trans-unit>
        <trans-unit id="1d0515ada05fe82e395d7a6707b6351170a6e35a" translate="yes" xml:space="preserve">
          <source>We can use classes or functions from a Kotlin project, in our scratches and worksheets.</source>
          <target state="translated">スクラッチやワークシートでは、Kotlinプロジェクトのクラスや関数を使うことができます。</target>
        </trans-unit>
        <trans-unit id="8b191724788dd23ede6b8c2149628b7a54092d58" translate="yes" xml:space="preserve">
          <source>We can use explicit conversions to widen numbers</source>
          <target state="translated">明示的な変換を使用して数を広げることができます。</target>
        </trans-unit>
        <trans-unit id="dfb0038c9e10b5e80574a36666be3c3e86aa4353" translate="yes" xml:space="preserve">
          <source>We collectively refer to &lt;em&gt;Experimental&lt;/em&gt;, &lt;em&gt;Alpha&lt;/em&gt; and &lt;em&gt;Beta&lt;/em&gt; as &lt;strong&gt;pre-stable&lt;/strong&gt; levels.</source>
          <target state="translated">我々は総称を指し&lt;em&gt;、実験&lt;/em&gt;、&lt;em&gt;アルファ&lt;/em&gt;および&lt;em&gt;ベータ版&lt;/em&gt;として&lt;strong&gt;事前安定の&lt;/strong&gt;レベル。</target>
        </trans-unit>
        <trans-unit id="fca14a2211b4e71b478b08b4747bfb20c5dc2a24" translate="yes" xml:space="preserve">
          <source>We continue to explore more C language types and their representation in Kotlin/Native in our other tutorials:</source>
          <target state="translated">Kotlin/Native の他のチュートリアルでは、さらに多くの C 言語タイプとその表現を探求しています。</target>
        </trans-unit>
        <trans-unit id="51b6f004886664d749f4d2984398143458f52375" translate="yes" xml:space="preserve">
          <source>We could call this using default arguments:</source>
          <target state="translated">これはデフォルトの引数を使って呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="8ae10259ccef551da0909b6299a0fa1b0a4f1215" translate="yes" xml:space="preserve">
          <source>We could do a similar thing with contravariant projection by using &lt;code&gt;in&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;in&lt;/code&gt; を使用して、反変射影でも同様のことができます。</target>
        </trans-unit>
        <trans-unit id="39a9864b239884664ddf63f83dbaeb179ea24a10" translate="yes" xml:space="preserve">
          <source>We could use the same means of synchronization that are applicable to threads (a &lt;code&gt;CountDownLatch&lt;/code&gt; is what crosses my mind in this case), but let's take a safer and cleaner path.</source>
          <target state="translated">スレッドに適用できるのと同じ同期方法を使用することもできます（この場合、 &lt;code&gt;CountDownLatch&lt;/code&gt; が私の頭を横切るものです）。しかし、より安全でクリーンな方法をとりましょう。</target>
        </trans-unit>
        <trans-unit id="d12b57fa3f5ee09d20d2af80c6064fa21722785e" translate="yes" xml:space="preserve">
          <source>We covered the basics of setting up an IDE compatible project with Gradle in the &lt;a href=&quot;basic-kotlin-native-app#create-gradle-project&quot;&gt;A Basic Kotlin/Native Application&lt;/a&gt; tutorial. Please check it out if you are looking for detailed first steps and instructions on how to start a new Kotlin/Native project and open it in IntelliJ IDEA. In this tutorial, we'll look at the advanced C interop related usages of Kotlin/Native and &lt;a href=&quot;../../reference/building-mpp-with-gradle&quot;&gt;multiplatform&lt;/a&gt; builds with Gradle.</source>
          <target state="translated">&lt;a href=&quot;basic-kotlin-native-app#create-gradle-project&quot;&gt;基本的なKotlin /ネイティブアプリケーション&lt;/a&gt;チュートリアルで、Gradleを使用したIDE互換プロジェクトの設定の基本について説明しました。新しいKotlin / Nativeプロジェクトを開始し、IntelliJ IDEAで開く方法の詳細な最初のステップと手順を探している場合は、チェックしてください。このチュートリアルでは、Gotleを使用したKotlin / Nativeおよび&lt;a href=&quot;../../reference/building-mpp-with-gradle&quot;&gt;マルチプラットフォーム&lt;/a&gt;ビルドの高度なC相互運用関連の使用法について説明します。</target>
        </trans-unit>
        <trans-unit id="34c7674c59bff58842f8120c227b39dfc459b5e2" translate="yes" xml:space="preserve">
          <source>We covered the basics of setting up an IDE compatible project with Gradle in the &lt;a href=&quot;using-gradle&quot;&gt;A Basic Kotlin/Native Application&lt;/a&gt; tutorial. Please check it out if you are looking for detailed first steps and instructions on how to start a new Kotlin/Native project and open it in IntelliJ IDEA. In this tutorial, we'll look at the advanced C interop related usages of Kotlin/Native and &lt;a href=&quot;../../reference/mpp-discover-project#multiplatform-plugin&quot;&gt;multiplatform&lt;/a&gt; builds with Gradle.</source>
          <target state="translated">&lt;a href=&quot;using-gradle&quot;&gt;基本的なKotlin /ネイティブアプリケーションの&lt;/a&gt;チュートリアルでは、Gradleを使用してIDE互換プロジェクトを設定するための基本について説明しました。新しいKotlin / Nativeプロジェクトを開始し、IntelliJ IDEAで開く方法の詳細な最初の手順と手順をお探しの場合は、こちらをご覧ください。このチュートリアルでは、Kotlin / NativeおよびGradleを使用した&lt;a href=&quot;../../reference/mpp-discover-project#multiplatform-plugin&quot;&gt;マルチプラットフォーム&lt;/a&gt;ビルドの高度なC相互運用関連の使用法について説明します。</target>
        </trans-unit>
        <trans-unit id="6b1e2f897849388e9b5afd5f5e40ff3ed5d9341c" translate="yes" xml:space="preserve">
          <source>We create &lt;code&gt;build.gradle&lt;/code&gt;&lt;code&gt;build.gradle.kts&lt;/code&gt; Gradle build file with the following contents:</source>
          <target state="translated">次の内容で &lt;code&gt;build.gradle&lt;/code&gt; &lt;code&gt;build.gradle.kts&lt;/code&gt; Gradleビルドファイルを作成します。</target>
        </trans-unit>
        <trans-unit id="d792e0e9b2d61d7c507d6ac3c55fb78219ae3d1b" translate="yes" xml:space="preserve">
          <source>We create a &lt;code&gt;lib.h&lt;/code&gt; file to see how C functions are mapped into Kotlin:</source>
          <target state="translated">&lt;code&gt;lib.h&lt;/code&gt; ファイルを作成して、C関数がKotlinにどのようにマップされるかを確認します。</target>
        </trans-unit>
        <trans-unit id="b48d0f7550a4bac04ad5285d58e805e5af18955b" translate="yes" xml:space="preserve">
          <source>We create a similar implementation file (and missing directories) for the iOS target in the &lt;code&gt;SharedCode/src/iosMain/kotlin/actual.kt&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;SharedCode/src/iosMain/kotlin/actual.kt&lt;/code&gt; に、iOSターゲット用の同様の実装ファイル（および不足しているディレクトリ）を作成します。</target>
        </trans-unit>
        <trans-unit id="785942d151a588aee24ed9a38ee1d8176b8dc181" translate="yes" xml:space="preserve">
          <source>We create the &lt;code&gt;hello.kt&lt;/code&gt; file with the library contents:</source>
          <target state="translated">ライブラリの内容を &lt;code&gt;hello.kt&lt;/code&gt; ファイルを作成します。</target>
        </trans-unit>
        <trans-unit id="fcb050d7cd97c1f800f9df98029b55284f1e77b7" translate="yes" xml:space="preserve">
          <source>We decided to productize this idea, but it hasn't reached the final shape yet.</source>
          <target state="translated">このアイデアを製品化することにしたのですが、まだ最終的な形には至っていません。</target>
        </trans-unit>
        <trans-unit id="a6ed76b8d0d9018634906744837677e15921589b" translate="yes" xml:space="preserve">
          <source>We declare the generic type parameter before the function name for it to be available in the receiver type expression. See &lt;a href=&quot;generics&quot;&gt;Generic functions&lt;/a&gt;.</source>
          <target state="translated">関数名の前にジェネリック型パラメーターを宣言して、レシーバー型式で使用できるようにします。&lt;a href=&quot;generics&quot;&gt;ジェネリック関数を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="908a5325e4c7755c51db166d96c5a188313020b0" translate="yes" xml:space="preserve">
          <source>We don&amp;rsquo;t currently support sharing a source set for these combinations:</source>
          <target state="translated">現在、これらの組み合わせのソースセットの共有はサポートされていません。</target>
        </trans-unit>
        <trans-unit id="e038eb8a21b3199cc32241632b06a3909918bfe9" translate="yes" xml:space="preserve">
          <source>We don't have to annotate the &lt;code&gt;HTML&lt;/code&gt; or &lt;code&gt;Head&lt;/code&gt; classes with &lt;code&gt;@HtmlTagMarker&lt;/code&gt; because their superclass is already annotated:</source>
          <target state="translated">スーパークラスには既にアノテーションが付けられているため、 &lt;code&gt;HTML&lt;/code&gt; または &lt;code&gt;Head&lt;/code&gt; クラスに &lt;code&gt;@HtmlTagMarker&lt;/code&gt; でアノテーションを付ける必要はありません。</target>
        </trans-unit>
        <trans-unit id="0d7e408c93316e02af7f4048c236f0b36f5b8539" translate="yes" xml:space="preserve">
          <source>We encourage you to try out the new Kotlin/JVM backend, which is currently in Alpha, and to file any issues and feature requests to our &lt;a href=&quot;https://youtrack.jetbrains.com/issues/KT&quot;&gt;issue tracker&lt;/a&gt;. This will help us to unify the compiler pipelines and bring compiler extensions like Jetpack Compose to the Kotlin community more quickly.</source>
          <target state="translated">現在Alphaにある新しいKotlin / JVMバックエンドを試して、問題や機能のリクエストを&lt;a href=&quot;https://youtrack.jetbrains.com/issues/KT&quot;&gt;問題追跡システムに&lt;/a&gt;提出することをお勧めします。これにより、コンパイラパイプラインを統合し、JetpackComposeなどのコンパイラ拡張機能をKotlinコミュニティに迅速に提供できるようになります。</target>
        </trans-unit>
        <trans-unit id="efdd6ede6c8f3bf00110a9f180aa0db3e0e10e52" translate="yes" xml:space="preserve">
          <source>We encourage you to use our new &lt;a href=&quot;#new-jvm-ir-backend&quot;&gt;JVM IR&lt;/a&gt; and &lt;a href=&quot;#new-js-ir-backend&quot;&gt;JS IR&lt;/a&gt; backends, which are currently in Alpha, and share your feedback with us.</source>
          <target state="translated">私たちは、新しい使用することをお勧め&lt;a href=&quot;#new-jvm-ir-backend&quot;&gt;JVM IR&lt;/a&gt;と&lt;a href=&quot;#new-js-ir-backend&quot;&gt;JS IR&lt;/a&gt;アルファに現在あるバックエンドを、私たちとあなたのフィードバックを共有しています。</target>
        </trans-unit>
        <trans-unit id="8e3df53e494bf93b03698e74de62415d2b98fbd8" translate="yes" xml:space="preserve">
          <source>We evolve the Kotlin Standard Library (kotlin-stdlib) for stable platforms according to the principles stated above. Changes to the contracts for its API undergo the same procedures as changes in the language itself.</source>
          <target state="translated">Kotlin標準ライブラリ(kotlin-stdlib)は、上記の原則に基づいて安定したプラットフォーム向けに進化させています。そのAPIの契約の変更は、言語自体の変更と同じ手続きを経て行われます。</target>
        </trans-unit>
        <trans-unit id="a2535fe7404df5a6eb12c3a3917ab80b4135dbff" translate="yes" xml:space="preserve">
          <source>We frequently create classes whose main purpose is to hold data. In such a class some standard functionality and utility functions are often mechanically derivable from the data. In Kotlin, this is called a &lt;em&gt;data class&lt;/em&gt; and is marked as &lt;code&gt;data&lt;/code&gt;:</source>
          <target state="translated">データを保持することを主な目的とするクラスを頻繁に作成しています。このようなクラスでは、いくつかの標準機能とユーティリティ関数がデータから機械的に導出できることがよくあります。Kotlinでは、これは&lt;em&gt;データクラス&lt;/em&gt;と呼ばれ、&lt;em&gt;data&lt;/em&gt;としてマークされ &lt;code&gt;data&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1a30f61b55b7b7e943a650a6aabc19b05c3bdf8d" translate="yes" xml:space="preserve">
          <source>We get only numbers up to 3 and a &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-cancellation-exception/index.html&quot;&gt;CancellationException&lt;/a&gt; after trying to emit number 4:</source>
          <target state="translated">番号4を発行しようとすると、3までの番号と&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-cancellation-exception/index.html&quot;&gt;CancellationException&lt;/a&gt;のみが発生します。</target>
        </trans-unit>
        <trans-unit id="24aab8ad063fec7c5b2558d6a061d3a136f3a35e" translate="yes" xml:space="preserve">
          <source>We get quite a different output, where a line is printed at each emission from either &lt;code&gt;nums&lt;/code&gt; or &lt;code&gt;strs&lt;/code&gt; flows:</source>
          <target state="translated">私たちは、ラインがいずれかから各発光で印刷されて全く異なる出力、取得 &lt;code&gt;nums&lt;/code&gt; または &lt;code&gt;strs&lt;/code&gt; 流れを：</target>
        </trans-unit>
        <trans-unit id="5ee091486d809b243b18a19355b403e23f19e065" translate="yes" xml:space="preserve">
          <source>We have significantly reworked the API for JSON serialization to make it more consistent and easier to use. From now on, we'll continue developing the JSON serialization API in a backward-compatible manner. However, if you have used previous versions of it, you'll need to rewrite some of your code when migrating to 1.0.0-RC. To help you with this, we also offer the &lt;a href=&quot;https://github.com/Kotlin/kotlinx.serialization/blob/master/docs/serialization-guide.md&quot;&gt;Kotlin Serialization Guide&lt;/a&gt; &amp;ndash; the complete set of documentation for &lt;code&gt;kotlinx.serialization&lt;/code&gt;. It will guide you through the process of using the most important features and it can help you address any issues that you might face.</source>
          <target state="translated">JSONシリアル化のAPIを大幅に作り直して、一貫性を高め、使いやすくしました。今後も、下位互換性のある方法でJSONシリアル化APIの開発を続けていきます。ただし、以前のバージョンを使用したことがある場合は、1.0.0-RCに移行するときにコードの一部を書き直す必要があります。これを支援するために、&lt;a href=&quot;https://github.com/Kotlin/kotlinx.serialization/blob/master/docs/serialization-guide.md&quot;&gt;Kotlin&lt;/a&gt; &lt;code&gt;kotlinx.serialization&lt;/code&gt; 化ガイドも提供しています。これはkotlinx.serializationのドキュメント一式です。最も重要な機能を使用するプロセスをガイドし、直面する可能性のある問題に対処するのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="1094efa9f8fd00ffe04a3c7c86c1ceab68f5986d" translate="yes" xml:space="preserve">
          <source>We make sure to document precisely which subcomponents are not stable. We also do our best to warn users where possible and ask to opt in explicitly to avoid accidental usages of features that have not been released as stable.</source>
          <target state="translated">私たちは、どのサブコンポーネントが安定していないかを正確に文書化するようにしています。また、安定版としてリリースされていない機能が誤って使用されることを避けるために、可能な限りユーザーに警告し、明示的にオプトインするようにお願いしています。</target>
        </trans-unit>
        <trans-unit id="a128ace07ce2a614969d8901fa6d436be396c723" translate="yes" xml:space="preserve">
          <source>We manage a lifecycle of our coroutines by creating an instance of &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html&quot;&gt;CoroutineScope&lt;/a&gt; that is tied to the lifecycle of our activity. &lt;code&gt;CoroutineScope&lt;/code&gt; instance can be created by &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope.html&quot;&gt;CoroutineScope()&lt;/a&gt; or &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-main-scope.html&quot;&gt;MainScope()&lt;/a&gt; factory functions. The former creates a general-purpose scope, while the latter creates scope for UI applications and uses &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-main.html&quot;&gt;Dispatchers.Main&lt;/a&gt; as default dispatcher:</source>
          <target state="translated">アクティビティのライフサイクルに関連付けられた&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html&quot;&gt;CoroutineScopeの&lt;/a&gt;インスタンスを作成することにより、コルーチンのライフサイクルを管理します。 &lt;code&gt;CoroutineScope&lt;/code&gt; インスタンスは、&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope.html&quot;&gt;CoroutineScope（）&lt;/a&gt;または&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-main-scope.html&quot;&gt;MainScope（）&lt;/a&gt;ファクトリ関数によって作成できます。前者は汎用スコープを作成し、後者はUIアプリケーションのスコープを作成し、&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-main.html&quot;&gt;Dispatchers.Main&lt;/a&gt;をデフォルトのディスパッチャーとして使用します。</target>
        </trans-unit>
        <trans-unit id="ccd2d1dce53a36cd421422934713d352fc3aea2f" translate="yes" xml:space="preserve">
          <source>We manage the lifecycles of our coroutines by creating an instance of &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html&quot;&gt;CoroutineScope&lt;/a&gt; tied to the lifecycle of our activity. A &lt;code&gt;CoroutineScope&lt;/code&gt; instance can be created by the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope.html&quot;&gt;CoroutineScope()&lt;/a&gt; or &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-main-scope.html&quot;&gt;MainScope()&lt;/a&gt; factory functions. The former creates a general-purpose scope, while the latter creates a scope for UI applications and uses &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-main.html&quot;&gt;Dispatchers.Main&lt;/a&gt; as the default dispatcher:</source>
          <target state="translated">コルーチンのライフサイクルを管理するには、アクティビティのライフサイクルに関連付けられた&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html&quot;&gt;CoroutineScopeの&lt;/a&gt;インスタンスを作成します。 &lt;code&gt;CoroutineScope&lt;/code&gt; のインスタンスにより作成することができる&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope.html&quot;&gt;CoroutineScope（）&lt;/a&gt;または&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-main-scope.html&quot;&gt;MainScope（）&lt;/a&gt;ファクトリ関数。前者は汎用スコープを作成し、後者はUIアプリケーションのスコープを作成し、デフォルトの&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-main.html&quot;&gt;ディスパッチャー&lt;/a&gt;としてDispatchers.Mainを使用します。</target>
        </trans-unit>
        <trans-unit id="b2f8eb551efabdb4e2888f30edf606cbdfff7bc8" translate="yes" xml:space="preserve">
          <source>We may find the whole sources from that tutorial on &lt;a href=&quot;https://github.com/JetBrains/kotlin-examples/tree/master/tutorials/mpp-iOS-Android&quot;&gt;GitHub&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/JetBrains/kotlin-examples/tree/master/tutorials/mpp-iOS-Android&quot;&gt;GitHubで&lt;/a&gt;そのチュートリアルの全ソースを見つけることができます。</target>
        </trans-unit>
        <trans-unit id="990e3fee35a9a6ae47d7273521920489a64503a8" translate="yes" xml:space="preserve">
          <source>We may include all declarations directly into the &lt;code&gt;.def&lt;/code&gt; file after a &lt;code&gt;---&lt;/code&gt; separator. It can be helpful to include macros or other C defines into the code generated by the &lt;code&gt;cinterop&lt;/code&gt; tool. Method bodies are compiled and fully included into the binary too. Let's use that feature to have a runnable example without a need for a C compiler. To implement that, we need to add implementations to the C functions from the &lt;code&gt;lib.h&lt;/code&gt; file, and place these functions into a &lt;code&gt;.def&lt;/code&gt; file. We will have the following &lt;code&gt;interop.def&lt;/code&gt; result:</source>
          <target state="translated">&lt;code&gt;---&lt;/code&gt; セパレータの後、すべての宣言を &lt;code&gt;.def&lt;/code&gt; ファイルに直接含めることができます。 &lt;code&gt;cinterop&lt;/code&gt; ツールで生成されたコードにマクロやその他のC定義を含めると便利です。メソッド本体もコンパイルされ、完全にバイナリーに組み込まれます。その機能を使用して、Cコンパイラーを必要とせずに実行可能な例を見てみましょう。これを実装するには、 &lt;code&gt;lib.h&lt;/code&gt; ファイルからC関数に実装を追加し、これらの関数を &lt;code&gt;.def&lt;/code&gt; ファイルに配置する必要があります。次の &lt;code&gt;interop.def&lt;/code&gt; の結果が得られます。</target>
        </trans-unit>
        <trans-unit id="bb703fd0c61569a76d50c3b521794196aa1b8db0" translate="yes" xml:space="preserve">
          <source>We need to assign the &lt;code&gt;id&lt;/code&gt; to the &lt;code&gt;TextView&lt;/code&gt; control of our activity to access it from the code. Let's patch the &lt;code&gt;app/src/main/res/layout/activity_main.xml&lt;/code&gt; file (the name may be different if we changed it in the new project wizard) and add several more attributes to the &lt;code&gt;&amp;lt;TextView&amp;gt;&lt;/code&gt; element:</source>
          <target state="translated">私たちは、割り当てる必要があります &lt;code&gt;id&lt;/code&gt; へ &lt;code&gt;TextView&lt;/code&gt; コードからアクセスするために私たちの活動の制御。 &lt;code&gt;app/src/main/res/layout/activity_main.xml&lt;/code&gt; ファイルにパッチを適用し（新しいプロジェクトウィザードで変更した場合は名前が異なる場合があります）、 &lt;code&gt;&amp;lt;TextView&amp;gt;&lt;/code&gt; 要素にさらにいくつかの属性を追加します。</target>
        </trans-unit>
        <trans-unit id="6b59ffea87e48a8dddabef126cfdaa1e77887d03" translate="yes" xml:space="preserve">
          <source>We need to configure an Xcode project to use our framework. The configuration depends on the target platform.</source>
          <target state="translated">フレームワークを使用するためにXcodeプロジェクトを設定する必要があります。設定はターゲットプラットフォームに依存します。</target>
        </trans-unit>
        <trans-unit id="8c3349f607cc5a810a187a7d773102a89d925fbd" translate="yes" xml:space="preserve">
          <source>We need to have a Kotlin compiler on our machines. The &lt;a href=&quot;basic-kotlin-native-app#obtaining-the-compiler&quot;&gt;A Basic Kotlin Application&lt;/a&gt; tutorial contains more explanations for that step. Let's assume, we have a console, where the &lt;code&gt;kotlinc-native&lt;/code&gt;, &lt;code&gt;cinterop&lt;/code&gt;, and &lt;code&gt;klib&lt;/code&gt; commands are available.</source>
          <target state="translated">私たちのマシンにはKotlinコンパイラーが必要です。&lt;a href=&quot;basic-kotlin-native-app#obtaining-the-compiler&quot;&gt;A基本Kotlinアプリケーション&lt;/a&gt;チュートリアルでは、そのステップのためのより多くの説明が含まれています。コンソールがあり、 &lt;code&gt;kotlinc-native&lt;/code&gt; 、 &lt;code&gt;cinterop&lt;/code&gt; 、および &lt;code&gt;klib&lt;/code&gt; コマンドを使用できると仮定します。</target>
        </trans-unit>
        <trans-unit id="027177ad8c50f7e3918b01a86e99731d536a90cd" translate="yes" xml:space="preserve">
          <source>We need to have a Kotlin compiler on our machines. The &lt;a href=&quot;basic-kotlin-native-app#obtaining-the-compiler&quot;&gt;A Basic Kotlin Application&lt;/a&gt; tutorial covers that step in details. Let's assume that we have a console, where the &lt;code&gt;kotlinc-native&lt;/code&gt;, &lt;code&gt;cinterop&lt;/code&gt;, and &lt;code&gt;klib&lt;/code&gt; commands are available.</source>
          <target state="translated">私たちのマシンにはKotlinコンパイラーが必要です。&lt;a href=&quot;basic-kotlin-native-app#obtaining-the-compiler&quot;&gt;A基本Kotlinアプリケーション&lt;/a&gt;という内容のステップのチュートリアルのカバー。コンソールがあり、 &lt;code&gt;kotlinc-native&lt;/code&gt; 、 &lt;code&gt;cinterop&lt;/code&gt; 、および &lt;code&gt;klib&lt;/code&gt; コマンドが使用できると仮定します。</target>
        </trans-unit>
        <trans-unit id="3c043e1a723b8be73d20799e39d49b6268885069" translate="yes" xml:space="preserve">
          <source>We need to have a Kotlin compiler on our machines. The &lt;a href=&quot;basic-kotlin-native-app#obtaining-the-compiler&quot;&gt;A Basic Kotlin Application&lt;/a&gt; tutorial explains the steps in detail. Let's assume we have a console, where the &lt;code&gt;kotlinc-native&lt;/code&gt;, &lt;code&gt;cinterop&lt;/code&gt;, and &lt;code&gt;klib&lt;/code&gt; commands are available.</source>
          <target state="translated">私たちのマシンにはKotlinコンパイラーが必要です。&lt;a href=&quot;basic-kotlin-native-app#obtaining-the-compiler&quot;&gt;A基本Kotlinアプリケーション&lt;/a&gt;チュートリアルでは、詳細な手順を説明します。コンソールがあり、ここで &lt;code&gt;kotlinc-native&lt;/code&gt; 、 &lt;code&gt;cinterop&lt;/code&gt; 、および &lt;code&gt;klib&lt;/code&gt; コマンドを使用できるとします。</target>
        </trans-unit>
        <trans-unit id="ab5784dabb9482fdb660b478b956f2503674f995" translate="yes" xml:space="preserve">
          <source>We need to refresh the Gradle Project settings to apply these changes. Click on the &lt;code&gt;Sync Now&lt;/code&gt; link or use the &lt;em&gt;Gradle&lt;/em&gt; tool window and click the refresh action from the context menu on the root Gradle project.</source>
          <target state="translated">これらの変更を適用するには、Gradle Project設定を更新する必要があります。[ &lt;code&gt;Sync Now&lt;/code&gt; リンクをクリックするか、&lt;em&gt;Gradle&lt;/em&gt;ツールウィンドウを使用して、ルートGradleプロジェクトのコンテキストメニューから更新アクションをクリックします。</target>
        </trans-unit>
        <trans-unit id="e0a25a2206a6fb40af56c49d12ab94e8fd653881" translate="yes" xml:space="preserve">
          <source>We need to supply the right Framework out of those four depending on the selected target in the Xcode project. It depends on the target configuration selected in Xcode. Also, we'd like to make Xcode compile the Framework for us before the build. We need to include the additional task to the end of the &lt;code&gt;SharedCode/build.gradle&lt;/code&gt; Gradle file:</source>
          <target state="translated">Xcodeプロジェクトで選択したターゲットに応じて、これら4つのうち適切なフレームワークを提供する必要があります。これは、Xcodeで選択したターゲット構成によって異なります。また、ビルドの前にXcodeにフレームワークをコンパイルさせます。 &lt;code&gt;SharedCode/build.gradle&lt;/code&gt; Gradleファイルの最後に追加のタスクを含める必要があります。</target>
        </trans-unit>
        <trans-unit id="27d58e7d45f1a7f3fbb5989a56fe0b4132ca9bca" translate="yes" xml:space="preserve">
          <source>We now define the &lt;em&gt;GreetingController&lt;/em&gt; which serves requests of the form &lt;em&gt;/greeting?name={value}&lt;/em&gt; and returns a JSON object representing an instance of &lt;em&gt;Greeting&lt;/em&gt;</source>
          <target state="translated">現在、定義&lt;em&gt;GreetingController&lt;/em&gt;形態の要求役立つ&lt;em&gt;/挨拶？名前= {値}&lt;/em&gt;とリターンのインスタンスを表すJSONオブジェクト&lt;em&gt;挨拶します&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5172c1ac8d2fad040b4dc376d3d08d8d24a279b3" translate="yes" xml:space="preserve">
          <source>We now have a local variable &lt;code&gt;number&lt;/code&gt; whose value is 42 and whose type is &lt;code&gt;Int&lt;/code&gt; (because that's the type of the literal &lt;code&gt;42&lt;/code&gt;), and another local variable &lt;code&gt;message&lt;/code&gt; whose value is &lt;code&gt;&quot;Hello&quot;&lt;/code&gt; and whose type is &lt;code&gt;String&lt;/code&gt;. Subsequent usages of the variable must use only the name, not &lt;code&gt;var&lt;/code&gt;:</source>
          <target state="translated">これで、値が42でタイプが &lt;code&gt;Int&lt;/code&gt; のローカル変数 &lt;code&gt;number&lt;/code&gt; （リテラル &lt;code&gt;42&lt;/code&gt; のタイプであるため）と、値が &lt;code&gt;&quot;Hello&quot;&lt;/code&gt; でタイプが &lt;code&gt;String&lt;/code&gt; の別のローカル変数 &lt;code&gt;message&lt;/code&gt; あります。以降の変数の使用では、 &lt;code&gt;var&lt;/code&gt; ではなく、名前のみを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="dfb0f090289673dd1e3bce3bdb08b454f3c07da9" translate="yes" xml:space="preserve">
          <source>We now need an HTML page to load the code, so we'll create a file called &lt;code&gt;index.html&lt;/code&gt;. If you want more information on how Kotlin compiles to JavaScript and the output generated, check out the &lt;a href=&quot;../kotlin-to-javascript/kotlin-to-javascript&quot;&gt;Kotlin to JavaScript&lt;/a&gt; tutorial.</source>
          <target state="translated">次に、コードをロードするためのHTMLページが必要なので、 &lt;code&gt;index.html&lt;/code&gt; というファイルを作成します。KotlinをJavaScriptにコンパイルする方法と生成された出力の詳細については、&lt;a href=&quot;../kotlin-to-javascript/kotlin-to-javascript&quot;&gt;Kotlin to JavaScript&lt;/a&gt;チュートリアルをご覧ください。</target>
        </trans-unit>
        <trans-unit id="8ae2c927826795d420c34c1b15ddab31d41644c0" translate="yes" xml:space="preserve">
          <source>We observed that annotating your code almost hasn't changed when you switched to Kotlin. Now let's see what changes should be made to the build script.</source>
          <target state="translated">Kotlinに切り替えてもコードのアノテーションはほとんど変わっていないことが観察できました。では、ビルドスクリプトにどのような変更を加えるべきかを見てみましょう。</target>
        </trans-unit>
        <trans-unit id="8ffa6d76c8e1bf7a1c5dd4d42cd1a6d0515ef81b" translate="yes" xml:space="preserve">
          <source>We open Xcode and select &lt;em&gt;Create a new Xcode project&lt;/em&gt; option. In the dialog, we choose the iOS target and select the &lt;em&gt;Single View App&lt;/em&gt;. Fill the next page with defaults, and use the &lt;code&gt;KotlinIOS&lt;/code&gt; (or something else) as the &lt;em&gt;Product Name&lt;/em&gt;. Let's select Swift as the language (it is possible to use Objective-C too). We should instruct Xcode to place the project into the &lt;code&gt;native&lt;/code&gt; folder under our project, later we will use relative paths in the configuration files.</source>
          <target state="translated">Xcodeを開き、[ &lt;em&gt;新しいXcodeプロジェクトを作成&lt;/em&gt; ]オプションを選択します。ダイアログで、iOSターゲットを選択し、&lt;em&gt;Single View App&lt;/em&gt;を選択します。次のページにデフォルトを入力し、 &lt;code&gt;KotlinIOS&lt;/code&gt; （またはその他）を&lt;em&gt;製品名&lt;/em&gt;として使用します。言語としてSwiftを選択しましょう（Objective-Cも使用できます）。Xcodeに、プロジェクトをプロジェクトの下の &lt;code&gt;native&lt;/code&gt; フォルダーに配置するように指示する必要があります。後で、構成ファイルで相対パスを使用します。</target>
        </trans-unit>
        <trans-unit id="a2530cc820c7c771c8fc29995c153d4bf24643ea" translate="yes" xml:space="preserve">
          <source>We provide &lt;em&gt;all-open&lt;/em&gt; plugin support both for Gradle and Maven with the complete IDE integration.</source>
          <target state="translated">完全なIDE統合により、GradleとMavenの両方に&lt;em&gt;すべてオープンな&lt;/em&gt;プラグインサポートを提供し&lt;em&gt;ます&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="8737e3b3a5c293a6cb9372838dbc9870d668570a" translate="yes" xml:space="preserve">
          <source>We provide the -language-version and -api-version flags that make a new version emulate the behaviour of an old one, for compatibility purposes. Normally, at least one previous version is supported. This effectively leaves a time span of two full feature release cycles for migration (which usually amounts to about two years). Using an older kotlin-stdlib or kotlin-reflect with a newer compiler without specifying compatibility flags is not recommended, and the compiler will report a &lt;a href=&quot;compatibility-modes&quot;&gt;warning&lt;/a&gt; when this happens.</source>
          <target state="translated">互換性のために、新しいバージョンで古いバージョンの動作をエミュレートする-language-versionおよび-api-versionフラグを提供しています。通常、少なくとも1つの以前のバージョンがサポートされています。これにより、移行には2つの完全な機能リリースサイクルの期間が事実上残ります（通常は約2年になります）。互換性フラグを指定せずに古いコンパイラーで古いkotlin-stdlibまたはkotlin-reflectを使用することはお勧めできません。これが発生すると、コンパイラーは&lt;a href=&quot;compatibility-modes&quot;&gt;警告&lt;/a&gt;を報告します。</target>
        </trans-unit>
        <trans-unit id="e91c098e8aab839aef30caa8d584e2cae0663d0e" translate="yes" xml:space="preserve">
          <source>We qualified the type parameter with the &lt;code&gt;reified&lt;/code&gt; modifier, now it&amp;rsquo;s accessible inside the function, almost as if it were a normal class. Since the function is inlined, no reflection is needed, normal operators like &lt;code&gt;!is&lt;/code&gt; and &lt;code&gt;as&lt;/code&gt; are working now. Also, we can call it as mentioned above: &lt;code&gt;myTree.findParentOfType&amp;lt;MyTreeNodeType&amp;gt;()&lt;/code&gt;.</source>
          <target state="translated">型パラメーターを &lt;code&gt;reified&lt;/code&gt; 修飾子で修飾しました。これで、通常のクラスのように、関数内からアクセスできます。関数はインライン化されているため、リフレクションは必要ありません &lt;code&gt;!is&lt;/code&gt; や &lt;code&gt;as&lt;/code&gt; などの通常の演算子は現在機能しています。また、前述のように &lt;code&gt;myTree.findParentOfType&amp;lt;MyTreeNodeType&amp;gt;()&lt;/code&gt; と呼ぶこともできます。</target>
        </trans-unit>
        <trans-unit id="7840bc09de48b5cc97bf23a9db5d15e17420d9fa" translate="yes" xml:space="preserve">
          <source>We recommend &lt;code&gt;with&lt;/code&gt; for calling functions on the context object without providing the lambda result. In the code, &lt;code&gt;with&lt;/code&gt; can be read as &amp;ldquo;&lt;em&gt;with this object, do the following.&lt;/em&gt;&amp;rdquo;</source>
          <target state="translated">ラムダ結果を提供せずに、コンテキストオブジェクトの関数を呼び出すために &lt;code&gt;with&lt;/code&gt; をお勧めします。コードでは、 &lt;code&gt;with&lt;/code&gt; は「&lt;em&gt;このオブジェクトを使用して次の&lt;/em&gt;ように読み取ることができ&lt;em&gt;ます。&lt;/em&gt;」</target>
        </trans-unit>
        <trans-unit id="ee965fb5c972bf1b84c2210f41280ef6b6a7b02d" translate="yes" xml:space="preserve">
          <source>We recommend that you use expected and actual declarations only for Kotlin declarations that have platform-specific dependencies. It is better to implement as much functionality as possible in the shared module even if doing so takes more time.</source>
          <target state="translated">プラットフォーム固有の依存関係を持つKotlinの宣言にのみ、期待される宣言と実際の宣言を使うことをお勧めします。たとえ時間がかかったとしても、できるだけ多くの機能を共有モジュールに実装した方が良いでしょう。</target>
        </trans-unit>
        <trans-unit id="55acd20cd8a96e52ff245292bd60de85bd57b76c" translate="yes" xml:space="preserve">
          <source>We see from these definitions that the Kotlin object &lt;code&gt;Object&lt;/code&gt; is mapped into &lt;code&gt;libnative_kref_example_Object&lt;/code&gt;, and &lt;code&gt;Clazz&lt;/code&gt; is mapped into &lt;code&gt;libnative_kref_example_Clazz&lt;/code&gt;. Both structs contain nothing but the &lt;code&gt;pinned&lt;/code&gt; field with a pointer, the field type &lt;code&gt;libnative_KNativePtr&lt;/code&gt; is defined as &lt;code&gt;void*&lt;/code&gt; above.</source>
          <target state="translated">私たちは、Kotlinのオブジェクトのことを、これらの定義から参照 &lt;code&gt;Object&lt;/code&gt; にマップされ &lt;code&gt;libnative_kref_example_Object&lt;/code&gt; 、および &lt;code&gt;Clazz&lt;/code&gt; はにマッピングされている &lt;code&gt;libnative_kref_example_Clazz&lt;/code&gt; 。どちらの構造体にも、ポインターが &lt;code&gt;pinned&lt;/code&gt; フィールドしか含まれていません。フィールドタイプ &lt;code&gt;libnative_KNativePtr&lt;/code&gt; は、上記の &lt;code&gt;void*&lt;/code&gt; として定義されています。</target>
        </trans-unit>
        <trans-unit id="e6899aab23e93f36bbb67e40e2a50b9ebcd2d51b" translate="yes" xml:space="preserve">
          <source>We see that &lt;code&gt;cinterop&lt;/code&gt; generated wrapper types for our &lt;code&gt;struct&lt;/code&gt; and &lt;code&gt;union&lt;/code&gt; types. For &lt;code&gt;MyStruct&lt;/code&gt; and &lt;code&gt;MyUnion&lt;/code&gt; type declarations in C, we have the Kotlin classes &lt;code&gt;MyStruct&lt;/code&gt; and &lt;code&gt;MyUnion&lt;/code&gt; generated respectively. The wrappers inherit from the &lt;code&gt;CStructVar&lt;/code&gt; base class and declare all fields as Kotlin properties. It uses &lt;code&gt;CValue&amp;lt;T&amp;gt;&lt;/code&gt; to represent a by-value structure parameter and &lt;code&gt;CValuesRef&amp;lt;T&amp;gt;?&lt;/code&gt; to represent passing a pointer to a structure or a union.</source>
          <target state="translated">私たちは、その参照 &lt;code&gt;cinterop&lt;/code&gt; 私たちのために生成されたラッパー型 &lt;code&gt;struct&lt;/code&gt; と &lt;code&gt;union&lt;/code&gt; の種類を。以下のために &lt;code&gt;MyStruct&lt;/code&gt; と &lt;code&gt;MyUnion&lt;/code&gt; Cでの型宣言、我々はKotlinクラス持た &lt;code&gt;MyStruct&lt;/code&gt; と &lt;code&gt;MyUnion&lt;/code&gt; がそれぞれ生成します。ラッパーは &lt;code&gt;CStructVar&lt;/code&gt; 基本クラスから継承し、すべてのフィールドをKotlinプロパティとして宣言します。これは、 &lt;code&gt;CValue&amp;lt;T&amp;gt;&lt;/code&gt; を使用して値 &lt;code&gt;CValuesRef&amp;lt;T&amp;gt;?&lt;/code&gt; 構造パラメーターを表し、CValuesRef &amp;lt;T&amp;gt;？構造体または共用体へのポインタの受け渡しを表す。</target>
        </trans-unit>
        <trans-unit id="f057034bf9d5d678ae656c6371649fbb0395e9c1" translate="yes" xml:space="preserve">
          <source>We see that Kotlin &lt;code&gt;String&lt;/code&gt; and Objective-C &lt;code&gt;NSString*&lt;/code&gt; are mapped transparently. Similarly, &lt;code&gt;Unit&lt;/code&gt; type from Kotlin is mapped to &lt;code&gt;void&lt;/code&gt;. We see primitive types are mapped directly. Non-nullable primitive types are mapped transparently. Nullable primitive types are mapped into &lt;code&gt;Kotlin&amp;lt;TYPE&amp;gt;*&lt;/code&gt; types, as shown in the table &lt;a href=&quot;#kotlin-numbers-and-nsnumber&quot;&gt;above&lt;/a&gt;. Both higher order functions &lt;code&gt;acceptFunF&lt;/code&gt; and &lt;code&gt;supplyFun&lt;/code&gt; are included, and accept Objective-C blocks.</source>
          <target state="translated">Kotlin &lt;code&gt;String&lt;/code&gt; とObjective-C &lt;code&gt;NSString*&lt;/code&gt; が透過的にマッピングされていることがわかります。同様に、Kotlinの &lt;code&gt;Unit&lt;/code&gt; タイプは &lt;code&gt;void&lt;/code&gt; にマップされます。プリミティブ型が直接マッピングされていることがわかります。 nullにできないプリミティブ型は透過的にマップされます。&lt;a href=&quot;#kotlin-numbers-and-nsnumber&quot;&gt;上記&lt;/a&gt;の表に示すように、null可能なプリミティブ型は &lt;code&gt;Kotlin&amp;lt;TYPE&amp;gt;*&lt;/code&gt; 型にマップされます。高次関数 &lt;code&gt;acceptFunF&lt;/code&gt; と &lt;code&gt;supplyFun&lt;/code&gt; の両方が含まれ、Objective-Cブロックを受け入れます。</target>
        </trans-unit>
        <trans-unit id="35a16af72746a4a3a02afc71cbee1736ad51d23a" translate="yes" xml:space="preserve">
          <source>We see that our function typedef from C has been turned into Kotlin &lt;code&gt;typealias&lt;/code&gt;. It uses &lt;code&gt;CPointer&amp;lt;..&amp;gt;&lt;/code&gt; type to represent the pointer parameters, and &lt;code&gt;CFunction&amp;lt;(Int)-&amp;gt;Int&amp;gt;&lt;/code&gt; to represent the function signature. There is an &lt;code&gt;invoke&lt;/code&gt; operator extension function available for all &lt;code&gt;CPointer&amp;lt;CFunction&amp;lt;..&amp;gt;&lt;/code&gt; types, so that it is possible to call it as we would call any other function in Kotlin.</source>
          <target state="translated">Cの関数typedefがKotlin &lt;code&gt;typealias&lt;/code&gt; に変換されていることがわかります。 &lt;code&gt;CPointer&amp;lt;..&amp;gt;&lt;/code&gt; タイプを使用してポインターパラメーターを表し、 &lt;code&gt;CFunction&amp;lt;(Int)-&amp;gt;Int&amp;gt;&lt;/code&gt; を使用して関数のシグネチャを表します。ある &lt;code&gt;invoke&lt;/code&gt; すべてのために利用可能なオペレータ拡張機能 &lt;code&gt;CPointer&amp;lt;CFunction&amp;lt;..&amp;gt;&lt;/code&gt; タイプなので、我々がKotlinに他の関数を呼び出すと同じようにそれを呼び出すことが可能であること。</target>
        </trans-unit>
        <trans-unit id="28a890b04741a752c8a070159a08ecb4fb5a731d" translate="yes" xml:space="preserve">
          <source>We see that while the first number was still being processed the second, and third were already produced, so the second one was &lt;em&gt;conflated&lt;/em&gt; and only the most recent (the third one) was delivered to the collector:</source>
          <target state="translated">最初の番号がまだ処理されている間に、2番目と3番目がすでに生成されていることがわかります。そのため、2番目の番号は&lt;em&gt;混同され&lt;/em&gt;、最新の番号（3番目の番号）のみがコレクターに配信されました。</target>
        </trans-unit>
        <trans-unit id="c2878a9c7f0b432f6ca797d421e5946bffba2e7e" translate="yes" xml:space="preserve">
          <source>We should drag the created build phase to the top of the list</source>
          <target state="translated">作成したビルドフェーズをリストの一番上にドラッグします。</target>
        </trans-unit>
        <trans-unit id="96dd80304356c421140b6cec43e73736a5d2cf73" translate="yes" xml:space="preserve">
          <source>We simply take every coroutine and await its result here, then all results are added together by the standard library function &lt;code&gt;sumBy()&lt;/code&gt;. But the compiler rightfully complains:</source>
          <target state="translated">すべてのコルーチンを取得して、その結果をここで待つだけで、すべての結果が標準ライブラリ関数 &lt;code&gt;sumBy()&lt;/code&gt; によって一緒に追加されます。しかし、コンパイラは当然文句を言います：</target>
        </trans-unit>
        <trans-unit id="256672724470d83204a91011d31c7585e8e896c2" translate="yes" xml:space="preserve">
          <source>We simply take every coroutine and await its result here, then all results are added together by the standard library function &lt;code&gt;sumOf()&lt;/code&gt;. But the compiler rightfully complains:</source>
          <target state="translated">ここですべてのコルーチンを取得してその結果を待つだけで、すべての結果が標準ライブラリ関数 &lt;code&gt;sumOf()&lt;/code&gt; によって加算されます。しかし、コンパイラは当然不平を言います：</target>
        </trans-unit>
        <trans-unit id="7d4baf88fc00c2c6a8043a4496a26dfca6b633d7" translate="yes" xml:space="preserve">
          <source>We start with a very simple action that increments a shared mutable variable using multi-threaded &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-default.html&quot;&gt;Dispatchers.Default&lt;/a&gt;.</source>
          <target state="translated">マルチスレッドの&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-default.html&quot;&gt;Dispatchers.Default&lt;/a&gt;を使用して共有可変変数をインクリメントする非常に単純なアクションから始めます。</target>
        </trans-unit>
        <trans-unit id="d6e2ee50e438c21fd164031d81fcec588a999b4f" translate="yes" xml:space="preserve">
          <source>We still have concurrent execution of both operations as evident from the output of the above main function:</source>
          <target state="translated">上記のメイン関数の出力から明らかなように、両方の処理を並行して実行しています。</target>
        </trans-unit>
        <trans-unit id="d309cfebc83a39f58f865d0bd1891f05f3570150" translate="yes" xml:space="preserve">
          <source>We still have concurrent execution of both operations, as evident from the output of the above &lt;code&gt;main&lt;/code&gt; function:</source>
          <target state="translated">上記の &lt;code&gt;main&lt;/code&gt; 関数の出力から明らかなように、まだ両方の操作を同時に実行しています。</target>
        </trans-unit>
        <trans-unit id="c7c80eca3836dfb2ec346ec74a1498c04b650629" translate="yes" xml:space="preserve">
          <source>We suggest you try the method &lt;a href=&quot;../java.io.-file/use-lines&quot;&gt;useLines&lt;/a&gt; instead which closes the stream when the processing is complete.</source>
          <target state="translated">代わりに、処理が完了したときにストリームを閉じるメソッド&lt;a href=&quot;../java.io.-file/use-lines&quot;&gt;useLines&lt;/a&gt;を試すことをお勧めします。</target>
        </trans-unit>
        <trans-unit id="1f5ae8ba8a817df47cdd30f0d60e67f7842b5f3f" translate="yes" xml:space="preserve">
          <source>We use a &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/on-each.html&quot;&gt;onEach&lt;/a&gt; intermediate operator in this example to delay each element and make the code that emits sample flows more declarative and shorter.</source>
          <target state="translated">この例では、&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/on-each.html&quot;&gt;onEach&lt;/a&gt;中間演算子を使用して各要素を遅延させ、サンプルフローを発行するコードをより宣言的かつ短くします。</target>
        </trans-unit>
        <trans-unit id="d00e20f64ce7aa51453973eb86f6197d3fb8aac0" translate="yes" xml:space="preserve">
          <source>We use a normal sequential invocation, because the code in the coroutine, just like in the regular code, is &lt;em&gt;sequential&lt;/em&gt; by default. The following example demonstrates it by measuring the total time it takes to execute both suspending functions:</source>
          <target state="translated">通常のコードと同様に、コルーチン内のコードはデフォルトで&lt;em&gt;順次&lt;/em&gt;であるため、通常の順次呼び出しを使用します。次の例は、両方の一時停止機能を実行するのにかかる合計時間を測定することによってそれを示しています。</target>
        </trans-unit>
        <trans-unit id="aadde77016fbc4d33f0abaca395b0e32828abddd" translate="yes" xml:space="preserve">
          <source>We use the &lt;code&gt;import SharedCode&lt;/code&gt; to import our Framework, which we compiled with Kotlin/Native from Kotlin code. Next, we call the Kotlin function from it as &lt;code&gt;CommonKt.createApplicationScreenMessage()&lt;/code&gt;. Follow the &lt;a href=&quot;apple-framework&quot;&gt;Kotlin/Native as an Apple Framework&lt;/a&gt; tutorial for more details on the Kotlin/Native to Swift (or Objective-C) interop.</source>
          <target state="translated">&lt;code&gt;import SharedCode&lt;/code&gt; を使用して、KotlinコードからKotlin / Nativeでコンパイルしたフレームワークをインポートします。次に、Kotlin関数を &lt;code&gt;CommonKt.createApplicationScreenMessage()&lt;/code&gt; として呼び出します。Kotlin / Native to Swift（またはObjective-C）の相互運用の詳細については&lt;a href=&quot;apple-framework&quot;&gt;、Apple Framework&lt;/a&gt;チュートリアルとしてのKotlin / Nativeに従ってください。</target>
        </trans-unit>
        <trans-unit id="085b9979a689e14ecd3808ec279a6c3ad33ba2ea" translate="yes" xml:space="preserve">
          <source>We use the &lt;code&gt;staticCFunction{..}&lt;/code&gt; helper function from Kotlin/Native to wrap a Kotlin lambda function into a C function pointer. It only allows having unbound and non-capturing lambda functions. For example, it is not able to use a local variable from the function. We may only use globally visible declarations. Throwing exceptions from a &lt;code&gt;staticCFunction{..}&lt;/code&gt; will end up in non-deterministic side-effects. It is vital to make sure that we are not throwing any sudden exceptions from it.</source>
          <target state="translated">Kotlin / Native の &lt;code&gt;staticCFunction{..}&lt;/code&gt; ヘルパー関数を使用して、Kotlinラムダ関数をC関数ポインターにラップします。バインドされていない非キャプチャラムダ関数のみが許可されます。たとえば、関数からローカル変数を使用することはできません。グローバルに見える宣言のみを使用できます。 &lt;code&gt;staticCFunction{..}&lt;/code&gt; から例外をスローすると、確定的でない副作用が発生します。突然の例外が発生しないようにすることが重要です。</target>
        </trans-unit>
        <trans-unit id="6d750a9144d219b73169d8ec8ee3282a5ce16530" translate="yes" xml:space="preserve">
          <source>We use the condition in the Gradle script to select the target platform for the framework. It is either &lt;code&gt;iOS arm64&lt;/code&gt; or &lt;code&gt;iOS x86_64&lt;/code&gt; depending on environment variables.</source>
          <target state="translated">Gradleスクリプトの条件を使用して、フレームワークのターゲットプラットフォームを選択します。環境変数に応じて、 &lt;code&gt;iOS arm64&lt;/code&gt; または &lt;code&gt;iOS x86_64&lt;/code&gt; になります。</target>
        </trans-unit>
        <trans-unit id="87ead7e377be828bc8f924111dcab22679cf1455" translate="yes" xml:space="preserve">
          <source>We use the extension property &lt;code&gt;ptr&lt;/code&gt; which comes from &lt;code&gt;memScoped&lt;/code&gt; lambda receiver type to turn &lt;code&gt;MyStruct&lt;/code&gt; and &lt;code&gt;MyUnion&lt;/code&gt; instances into native pointers. Those pointers are only valid inside the &lt;code&gt;memScoped&lt;/code&gt; block.</source>
          <target state="translated">&lt;code&gt;memScoped&lt;/code&gt; ラムダレシーバータイプからの拡張プロパティ &lt;code&gt;ptr&lt;/code&gt; を使用して、 &lt;code&gt;MyStruct&lt;/code&gt; および &lt;code&gt;MyUnion&lt;/code&gt; インスタンスをネイティブポインターに変換します。これらのポインターは、 &lt;code&gt;memScoped&lt;/code&gt; ブロック内でのみ有効です。</target>
        </trans-unit>
        <trans-unit id="3d19fb9c3674e9e7d03350ce663d175de7004c2d" translate="yes" xml:space="preserve">
          <source>We will be using &lt;a href=&quot;https://developer.android.com/studio/&quot;&gt;Android Studio&lt;/a&gt; for the Android part of the tutorial. It is also possible to use &lt;a href=&quot;https://jetbrains.com/idea&quot;&gt;IntelliJ IDEA&lt;/a&gt; Community or Ultimate edition.</source>
          <target state="translated">チュートリアルのAndroidの部分では、&lt;a href=&quot;https://developer.android.com/studio/&quot;&gt;Android Studio&lt;/a&gt;を使用します。&lt;a href=&quot;https://jetbrains.com/idea&quot;&gt;IntelliJ IDEA&lt;/a&gt; CommunityまたはUltimateエディションを使用することも可能です。</target>
        </trans-unit>
        <trans-unit id="495de00f60f65274c47ffb67586fe526a49cb4f3" translate="yes" xml:space="preserve">
          <source>We will be using IntelliJ IDEA Community Edition for the example. You need to make sure you have the latest version of the Kotlin plugin installed, 1.3.x or newer. We select &lt;em&gt;File | New | Project&lt;/em&gt;, select &lt;em&gt;Kotlin | Kotlin (Multiplatform Library)&lt;/em&gt; and configure the project in the way we want.</source>
          <target state="translated">この例ではIntelliJ IDEA Community Editionを使用します。 Kotlinプラグインの最新バージョン1.3.x以降がインストールされていることを確認する必要があります。&lt;em&gt;ファイル&lt;/em&gt;を選択し&lt;em&gt;ます|新規|プロジェクト&lt;/em&gt;、&lt;em&gt;Kotlinを&lt;/em&gt;選択&lt;em&gt;| Kotlin（マルチプラットフォームライブラリ）&lt;/em&gt;を使用して、プロジェクトを希望&lt;em&gt;どおりに&lt;/em&gt;構成します。</target>
        </trans-unit>
        <trans-unit id="9c7906ddfb7d83aa5b930b2241b862ba86c46dd5" translate="yes" xml:space="preserve">
          <source>We will be using IntelliJ IDEA Community Edition for this tutorial, though using Ultimate edition is possible as well.</source>
          <target state="translated">このチュートリアルではIntelliJ IDEA Community Editionを使用しますが、Ultimate Editionを使用することも可能です。</target>
        </trans-unit>
        <trans-unit id="240e26cd69c673ca5063d1fec6c288458947715f" translate="yes" xml:space="preserve">
          <source>We will be using IntelliJ IDEA Community Edition for this tutorial, though using Ultimate edition is possible as well. The Kotlin plugin 1.3.x or higher should be installed in the IDE. This can be verified via the &lt;em&gt;Language &amp;amp; Frameworks | Kotlin Updates&lt;/em&gt; section in the &lt;em&gt;Settings&lt;/em&gt; (or &lt;em&gt;Preferences&lt;/em&gt;) of the IDE. Native part of this project is written using Mac OS X, but don't worry if you are using another platform, the platform affects only directory names in this particular tutorial.</source>
          <target state="translated">このチュートリアルではIntelliJ IDEA Community Editionを使用しますが、Ultimateエディションを使用することもできます。Kotlinプラグイン1.3.x以降がIDEにインストールされている必要があります。&lt;em&gt;言語とフレームワーク&lt;/em&gt;で確認できます&lt;em&gt;| &lt;/em&gt;IDEの&lt;em&gt;[設定]&lt;/em&gt;（または&lt;em&gt;[設定&lt;/em&gt;&lt;em&gt;]&lt;/em&gt;）の&lt;em&gt;Kotlin更新&lt;/em&gt;セクション。このプロジェクトのネイティブ部分はMac OS Xを使用して記述されていますが、別のプラットフォームを使用している場合でも心配する必要はありません。この特定のチュートリアルでは、プラットフォームはディレクトリ名にのみ影響します。</target>
        </trans-unit>
        <trans-unit id="a5df86530b0f4b4eea42ee317054bed9ca2a9e03" translate="yes" xml:space="preserve">
          <source>We will be using the &lt;code&gt;x64 Native Tools Command Prompt &amp;lt;VERSION&amp;gt;&lt;/code&gt; console. We'll see the shortcut to open the console in the start menu. It comes with a Microsoft Visual Studio package.</source>
          <target state="translated">私たちは、使用する &lt;code&gt;x64 Native Tools Command Prompt &amp;lt;VERSION&amp;gt;&lt;/code&gt; コンソールを。スタートメニューにコンソールを開くためのショートカットが表示されます。Microsoft Visual Studioパッケージが付属しています。</target>
        </trans-unit>
        <trans-unit id="356ae5746574838fa3924ac6e010e44bd7dc600e" translate="yes" xml:space="preserve">
          <source>We will continue exploring more C language types and their representation in Kotlin/Native in next tutorials:</source>
          <target state="translated">次回のチュートリアルでは、さらに多くのC言語の型とKotlin/Nativeでの表現を探求していきます。</target>
        </trans-unit>
        <trans-unit id="d5797487ddb0eb41e5d2e9c68ced4d766fd86f98" translate="yes" xml:space="preserve">
          <source>We will continue to explore more complicated C language types and their representation in Kotlin/Native in the next tutorials:</source>
          <target state="translated">次回のチュートリアルでは、より複雑なC言語の型とKotlin/Nativeでの表現を探求していきます。</target>
        </trans-unit>
        <trans-unit id="6cf9027aa102f6f0a5c64a43d077861c549d000f" translate="yes" xml:space="preserve">
          <source>We will cover this functionality with common tests and then publish the final library to Maven.</source>
          <target state="translated">この機能を一般的なテストでカバーし、最終的なライブラリをMavenに公開します。</target>
        </trans-unit>
        <trans-unit id="23c2f2e6b1a14ab9c7e2d8312c7379c2ecdd3c02" translate="yes" xml:space="preserve">
          <source>We will create a simple Kotlin/JavaScript library.</source>
          <target state="translated">簡単なKotlin/JavaScriptライブラリを作成します。</target>
        </trans-unit>
        <trans-unit id="194f5ab4f85b03618fc04358b4a842a9d1306f59" translate="yes" xml:space="preserve">
          <source>We will then see something similar to this:</source>
          <target state="translated">すると、これに似たようなものが出てきます。</target>
        </trans-unit>
        <trans-unit id="3a29960a39a18059d04b2735de83331640c538de" translate="yes" xml:space="preserve">
          <source>We would like to emphasize that extension functions are dispatched &lt;strong&gt;statically&lt;/strong&gt;, i.e. they are not virtual by receiver type. This means that the extension function being called is determined by the type of the expression on which the function is invoked, not by the type of the result of evaluating that expression at runtime. For example:</source>
          <target state="translated">拡張機能は&lt;strong&gt;静的&lt;/strong&gt;にディスパッチされる、つまり、レシーバータイプによって仮想化されないことを強調しておきます。つまり、呼び出される拡張関数は、実行時にその式を評価した結果の型ではなく、関数が呼び出される式の型によって決まります。例えば：</target>
        </trans-unit>
        <trans-unit id="b83946b87080a81db62683de18b3b00c28f7ba2c" translate="yes" xml:space="preserve">
          <source>We wouldn't know if this function would be invoked on only activities from our sources or on plain Java activities also. Because of this, we don&amp;rsquo;t use caching there, even if &lt;code&gt;MyActivity&lt;/code&gt; instance from the previous example is passed as a receiver.</source>
          <target state="translated">この関数が、ソースからのアクティビティのみで呼び出されるのか、プレーンなJavaアクティビティでも呼び出されるのかはわかりません。このため、前の例の &lt;code&gt;MyActivity&lt;/code&gt; インスタンスがレシーバーとして渡されたとしても、そこではキャッシュを使用しません。</target>
        </trans-unit>
        <trans-unit id="64fbc9430739427e8ecff708c04a32c1ecf8e64f" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve added a new API to &lt;code&gt;kotlin-reflect&lt;/code&gt; that can be used to enumerate all the direct subtypes of a &lt;code&gt;sealed&lt;/code&gt; class, namely &lt;code&gt;KClass.sealedSubclasses&lt;/code&gt;.</source>
          <target state="translated">新しいAPIを &lt;code&gt;kotlin-reflect&lt;/code&gt; に追加しました。これを使用して、 &lt;code&gt;sealed&lt;/code&gt; クラスのすべての直接サブタイプ、つまり &lt;code&gt;KClass.sealedSubclasses&lt;/code&gt; を列挙できます。</target>
        </trans-unit>
        <trans-unit id="8104ed41ba0ad6b8cb42477062cc9a8702abbeec" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve added one more action in IntelliJ IDEA 2020.1 with Gradle 6.0 and above &amp;ndash; &lt;strong&gt;Load Script Configurations&lt;/strong&gt;, which loads changes to the script configurations without updating the whole project. This takes much less time than reimporting the whole project.</source>
          <target state="translated">Gradle6.0以降を搭載したIntelliJIDEA 2020.1にもう1つのアクションを追加しました。これは、プロジェクト全体を更新せずにスクリプト構成への変更をロードする&lt;strong&gt;スクリプト構成のロード&lt;/strong&gt;です。これは、プロジェクト全体を再インポートするよりもはるかに短い時間で済みます。</target>
        </trans-unit>
        <trans-unit id="40438146e777422ec29b09a135f9a4faaaaf0ee2" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve reworked how C interop libraries are built. With the new tooling, Kotlin/Native produces interop libraries up to 4 times as fast as before, and artifacts are 25% to 30% the size they used to be.</source>
          <target state="translated">C相互運用ライブラリの構築方法を作り直しました。新しいツールを使用すると、Kotlin / Nativeは以前の最大4倍の速度で相互運用ライブラリを生成し、アーティファクトは以前のサイズの25％から30％になります。</target>
        </trans-unit>
        <trans-unit id="280290f99293d030e512b76f98e946df19f3aa24" translate="yes" xml:space="preserve">
          <source>We'd start solving it by creating a Kotlin source file with an arbitrary name. &lt;code&gt;A.kt&lt;/code&gt; will do well. First, we need to implement a function specified in the problem statement as:</source>
          <target state="translated">まず、任意の名前でKotlinソースファイルを作成することで解決します。 &lt;code&gt;A.kt&lt;/code&gt; はうまくいきます。まず、問題ステートメントで指定された関数を次のように実装する必要があります。</target>
        </trans-unit>
        <trans-unit id="48dd517a499e14c158e9fa4782184f8188502e0f" translate="yes" xml:space="preserve">
          <source>We'll be using IntelliJ IDEA (Ultimate or Community edition). To learn how to start a new Kotlin project in IntelliJ IDEA, see the &lt;a href=&quot;getting-started&quot;&gt;Getting Started with IntellJ IDEA&lt;/a&gt; tutorial. If you are using build tools, please see the corresponding entry under &lt;a href=&quot;build-tools&quot;&gt;Build Tools&lt;/a&gt;.</source>
          <target state="translated">IntelliJ IDEA（UltimateまたはCommunityエディション）を使用します。IntelliJ IDEAで新しいKotlinプロジェクトを開始する方法については&lt;a href=&quot;getting-started&quot;&gt;、IntellJ IDEA入門&lt;/a&gt;チュートリアルを参照してください。ビルドツールを使用している場合は、&lt;a href=&quot;build-tools&quot;&gt;ビルドツールの&lt;/a&gt;下の対応するエントリを参照してください。</target>
        </trans-unit>
        <trans-unit id="13befb7a01cdbb85144f68b9efce98f561e6a626" translate="yes" xml:space="preserve">
          <source>We'll be using IntelliJ IDEA (Ultimate or Community edition). To learn how to start a new Kotlin project in IntelliJ IDEA, see the &lt;a href=&quot;jvm-get-started&quot;&gt;Getting Started with IntellJ IDEA&lt;/a&gt; tutorial. If you are using build tools, please see the corresponding entry under &lt;a href=&quot;build-tools&quot;&gt;Build Tools&lt;/a&gt;.</source>
          <target state="translated">IntelliJ IDEA（UltimateまたはCommunityエディション）を使用します。IntelliJ IDEAで新しいKotlinプロジェクトを開始する方法については、「&lt;a href=&quot;jvm-get-started&quot;&gt;IntellJIDEA入門」&lt;/a&gt;チュートリアルを参照してください。ビルドツールを使用している場合は、&lt;a href=&quot;build-tools&quot;&gt;ビルドツールの&lt;/a&gt;下の対応するエントリを参照してください。</target>
        </trans-unit>
        <trans-unit id="1f7aa73d697a63f1be8df9974161860c77d7f65f" translate="yes" xml:space="preserve">
          <source>We'll create a new Android project via &lt;em&gt;Start New Android Project&lt;/em&gt; item. If using IntelliJ IDEA, we need to select &lt;em&gt;Android&lt;/em&gt; in the left panel of the &lt;em&gt;New Project&lt;/em&gt; wizard.</source>
          <target state="translated">&lt;em&gt;[&lt;/em&gt;新しいAndroidプロジェクトを&lt;em&gt;開始]&lt;/em&gt;アイテムを使用して、新しいAndroidプロジェクトを作成します。IntelliJ IDEAを使用している場合は、&lt;em&gt;新規プロジェクト&lt;/em&gt;ウィザードの左側のパネルで&lt;em&gt;Android&lt;/em&gt;を選択する必要があります。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="adbf109def75db2c462938914849c5eb6eed73eb" translate="yes" xml:space="preserve">
          <source>We'll learn how to:</source>
          <target state="translated">その方法を学びます。</target>
        </trans-unit>
        <trans-unit id="65dfa3289b9a70c638718585acaabd5931d1b082" translate="yes" xml:space="preserve">
          <source>We'll look at &lt;a href=&quot;android-frameworks#dagger&quot;&gt;Dagger&lt;/a&gt;, &lt;a href=&quot;android-frameworks#butterknife&quot;&gt;Butterknife&lt;/a&gt;, &lt;a href=&quot;android-frameworks#data-binding&quot;&gt;Data Binding&lt;/a&gt; and &lt;a href=&quot;android-frameworks#dbflow&quot;&gt;DBFlow&lt;/a&gt; (other frameworks can be set up similarly). All these frameworks work through annotation processing: you annotate the code to have the boiler-plate code generated for you. Annotations allow to hide all the verbosity and keep your code simple, and if you need to understand what actually happens at runtime, you can look at the generated code. Note that all these frameworks generate source code in Java, not Kotlin.</source>
          <target state="translated">&lt;a href=&quot;android-frameworks#dagger&quot;&gt;Dagger&lt;/a&gt;、&lt;a href=&quot;android-frameworks#butterknife&quot;&gt;Butterknife&lt;/a&gt;、&lt;a href=&quot;android-frameworks#data-binding&quot;&gt;Data Binding&lt;/a&gt;、および&lt;a href=&quot;android-frameworks#dbflow&quot;&gt;DBFlowを&lt;/a&gt;見ていきます（他のフレームワークも同様に設定できます）。これらのすべてのフレームワークは注釈処理を通じて機能します。コードに注釈を付けて、ボイラープレートコードを生成します。注釈を使用すると、すべての冗長性を非表示にしてコードをシンプルに保つことができます。実行時に実際に何が起こるかを理解する必要がある場合は、生成されたコードを確認できます。これらのフレームワークはすべて、KotlinではなくJavaでソースコードを生成することに注意してください。</target>
        </trans-unit>
        <trans-unit id="c7ac9f8cb4bffee3deae462c300ad8acc7b22566" translate="yes" xml:space="preserve">
          <source>We'll use the following &lt;code&gt;build.gradle&lt;/code&gt;&lt;code&gt;build.gradle.kts&lt;/code&gt; Gradle build file with the following contents:</source>
          <target state="translated">次の &lt;code&gt;build.gradle&lt;/code&gt; &lt;code&gt;build.gradle.kts&lt;/code&gt; Gradleビルドファイルを使用し、次の内容を含めます。</target>
        </trans-unit>
        <trans-unit id="35e9daf2777de53728fdd63d8121926825802dd9" translate="yes" xml:space="preserve">
          <source>We're allowed to pass a &lt;code&gt;Car&lt;/code&gt; to &lt;code&gt;boast()&lt;/code&gt; because &lt;code&gt;Car&lt;/code&gt; is a subclass of &lt;code&gt;MotorVehicle&lt;/code&gt;. We're allowed to pass a &lt;code&gt;Car&lt;/code&gt; to &lt;code&gt;ride()&lt;/code&gt; because &lt;code&gt;Car&lt;/code&gt; implements &lt;code&gt;Driveable&lt;/code&gt; (thanks to being a subclass &lt;code&gt;MotorVehicle&lt;/code&gt;). Inside &lt;code&gt;boast()&lt;/code&gt;, we're only allowed to access the members of the declared parameter type &lt;code&gt;MotorVehicle&lt;/code&gt;, even if we're in a situation where we know that it's really a &lt;code&gt;Car&lt;/code&gt; (because there could be other callers that pass a non-&lt;code&gt;Car&lt;/code&gt;). Inside &lt;code&gt;ride()&lt;/code&gt;, we're only allowed to access the members of the declared parameter type &lt;code&gt;Driveable&lt;/code&gt;. This ensures that every member lookup is safe - the compiler only allows you to pass objects that are guaranteed to have the necessary members. The downside is that you will sometimes be forced to declare &quot;unnecessary&quot; interfaces or wrapper classes in order to make a function accept instances of different classes.</source>
          <target state="translated">私たちは、通過を許可している &lt;code&gt;Car&lt;/code&gt; する &lt;code&gt;boast()&lt;/code&gt; ので、 &lt;code&gt;Car&lt;/code&gt; のサブクラスである &lt;code&gt;MotorVehicle&lt;/code&gt; 。 &lt;code&gt;Car&lt;/code&gt; は &lt;code&gt;Driveable&lt;/code&gt; を実装しているため、 &lt;code&gt;Car&lt;/code&gt; を &lt;code&gt;ride()&lt;/code&gt; に渡すことができます（サブクラス &lt;code&gt;MotorVehicle&lt;/code&gt; であることに感謝します）。 &lt;code&gt;MotorVehicle&lt;/code&gt; &lt;code&gt;boast()&lt;/code&gt; 内では、宣言されたパラメーター型MotorVehicleのメンバーへのアクセスのみが許可されます。たとえそれが本当に &lt;code&gt;Car&lt;/code&gt; であることがわかっている場合でも（非 &lt;code&gt;Car&lt;/code&gt; を渡す他の呼び出し元が存在する可能性があるため））。インサイド &lt;code&gt;ride()&lt;/code&gt; 、宣言されたパラメーター型 &lt;code&gt;Driveable&lt;/code&gt; のメンバーへのアクセスのみが許可されます。これにより、すべてのメンバーのルックアップが安全になります。コンパイラーは、必要なメンバーを持つことが保証されているオブジェクトのみを渡すことができます。欠点は、関数が異なるクラスのインスタンスを受け入れるようにするために、「不要な」インターフェースまたはラッパークラスを宣言しなければならない場合があることです。</target>
        </trans-unit>
        <trans-unit id="a12f1bb4ce7d202790746259d8059bc20b4c1c93" translate="yes" xml:space="preserve">
          <source>We're going to see how to set up TeamCity to build our Kotlin project. For more information and basics of TeamCity please check the &lt;a href=&quot;https://www.jetbrains.com/teamcity/documentation/&quot;&gt;Documentation page&lt;/a&gt; which contains information about installation, basic configuration, etc.</source>
          <target state="translated">TeamCityをセットアップしてKotlinプロジェクトを構築する方法を見ていきます。TeamCityの詳細と基本については、インストール、基本構成などに関する情報が含まれている&lt;a href=&quot;https://www.jetbrains.com/teamcity/documentation/&quot;&gt;ドキュメントページ&lt;/a&gt;を確認してください。</target>
        </trans-unit>
        <trans-unit id="dfe8cb673d9e8e417b1ac641d5d52b9b44cf3e8b" translate="yes" xml:space="preserve">
          <source>We're not going to cover the &lt;a href=&quot;../../reference/control-flow#when-expression&quot;&gt;&lt;code&gt;when&lt;/code&gt; expression&lt;/a&gt; in depth here since it doesn't have a close equivalent in Python, but check it out - it's pretty nifty, as it lets you compare one expression against many kinds of expressions in a very compact way (but it's not a full functional-programming-style pattern matcher). For example:</source>
          <target state="translated">私たちは、カバーするつもりはない&lt;a href=&quot;../../reference/control-flow#when-expression&quot;&gt; &lt;code&gt;when&lt;/code&gt; の式&lt;/a&gt;にはPythonで近い同等のものを持っていますが、それをチェックアウトしていないので、ここで深さを-それはかなり気の利いただ、それはあなたが非常にコンパクトに表現の多くの種類に対して一つの発現を比較することができますよう方法（ただし、完全な関数型プログラミングスタイルのパターンマッチャーではありません）。例えば：</target>
        </trans-unit>
        <trans-unit id="859b2e88a4b107551034ec5b70f0408cd92fac5e" translate="yes" xml:space="preserve">
          <source>We've also added the &lt;code&gt;ArrayDeque&lt;/code&gt; class &amp;ndash; an implementation of a double-ended queue. Double-ended queue lets you can add or remove elements both at the beginning and the end of the queue in an amortized constant time. You can use a double-ended queue by default when you need a queue or a stack in your code.</source>
          <target state="translated">また、 &lt;code&gt;ArrayDeque&lt;/code&gt; キューの実装であるArrayDequeクラスも追加しました。両端キューを使用すると、償却された一定時間内にキューの最初と最後の両方で要素を追加または削除できます。コードにキューまたはスタックが必要な場合は、デフォルトで両端キューを使用できます。</target>
        </trans-unit>
        <trans-unit id="7a6d4821c53a1c0b88e02c8ce15a60335e60fc0a" translate="yes" xml:space="preserve">
          <source>We've converted the ButterKnife &lt;a href=&quot;https://github.com/JakeWharton/butterknife/tree/master/sample/app/src/main/java/com/example&quot;&gt;sample&lt;/a&gt; to Kotlin. The resulting code can be found &lt;a href=&quot;https://github.com/JetBrains/kotlin-examples/tree/master/gradle/android-butterknife&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">ButterKnife &lt;a href=&quot;https://github.com/JakeWharton/butterknife/tree/master/sample/app/src/main/java/com/example&quot;&gt;サンプル&lt;/a&gt;をKotlinに変換しました。結果のコードは&lt;a href=&quot;https://github.com/JetBrains/kotlin-examples/tree/master/gradle/android-butterknife&quot;&gt;ここにあります&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="30d2a23216aee2ca42dc00c09139bd8bf210d9fc" translate="yes" xml:space="preserve">
          <source>We've deprecated the &lt;code&gt;contains()&lt;/code&gt;, &lt;code&gt;indexOf()&lt;/code&gt;, and &lt;code&gt;lastIndexOf()&lt;/code&gt; extension functions of &lt;code&gt;FloatArray&lt;/code&gt; and &lt;code&gt;DoubleArray&lt;/code&gt; because they use the &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754&quot;&gt;IEEE 754&lt;/a&gt; standard equality, which contradicts the total order equality in some corner cases. See &lt;a href=&quot;https://youtrack.jetbrains.com/issue/KT-28753&quot;&gt;this issue&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;FloatArray&lt;/code&gt; および &lt;code&gt;DoubleArray&lt;/code&gt; の &lt;code&gt;contains()&lt;/code&gt; 、 &lt;code&gt;indexOf()&lt;/code&gt; 、および &lt;code&gt;lastIndexOf()&lt;/code&gt; 拡張関数は、&lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754&quot;&gt;IEEE 754&lt;/a&gt;標準の等式を使用しているため、非推奨になりました。これは、一部のコーナーケースで全順序の等式と矛盾します。詳細については、&lt;a href=&quot;https://youtrack.jetbrains.com/issue/KT-28753&quot;&gt;この問題&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="9565458367bc75e7700ec47534de831e4a66b878" translate="yes" xml:space="preserve">
          <source>We've deprecated the &lt;code&gt;min()&lt;/code&gt; and &lt;code&gt;max()&lt;/code&gt; collection functions in favor of &lt;code&gt;minOrNull()&lt;/code&gt; and &lt;code&gt;maxOrNull()&lt;/code&gt;, which more properly reflect their behavior &amp;ndash; returning &lt;code&gt;null&lt;/code&gt; on empty collections. See &lt;a href=&quot;https://youtrack.jetbrains.com/issue/KT-38854&quot;&gt;this issue&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;min()&lt;/code&gt; および &lt;code&gt;max()&lt;/code&gt; コレクション関数は非推奨になりました &lt;code&gt;minOrNull()&lt;/code&gt; および &lt;code&gt;maxOrNull()&lt;/code&gt; は、それらの動作をより適切に反映し、空のコレクションで &lt;code&gt;null&lt;/code&gt; を返します。詳細については、&lt;a href=&quot;https://youtrack.jetbrains.com/issue/KT-38854&quot;&gt;この問題&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="215b5a7efdc1c89ee7092df264b96d7d1f704519" translate="yes" xml:space="preserve">
          <source>We've deprecated the functions &lt;code&gt;toShort()&lt;/code&gt; and &lt;code&gt;toByte()&lt;/code&gt; on &lt;code&gt;Double&lt;/code&gt; and &lt;code&gt;Float&lt;/code&gt; because they could lead to unexpected results because of the narrow value range and smaller variable size.</source>
          <target state="translated">私たちは、機能非推奨まし &lt;code&gt;toShort()&lt;/code&gt; と &lt;code&gt;toByte()&lt;/code&gt; の &lt;code&gt;Double&lt;/code&gt; と &lt;code&gt;Float&lt;/code&gt; 、彼らはので、狭い値の範囲と小さく、可変サイズの予期しない結果につながる可能性があるため。</target>
        </trans-unit>
        <trans-unit id="61c686dd7fee7d596ed3150966a1df858b5684ea" translate="yes" xml:space="preserve">
          <source>We've now seen all the definitions and it is time to fix the code. Let's run the &lt;code&gt;runDebugExecutableNative&lt;/code&gt; Gradle task &lt;a href=&quot;basic-kotlin-native-app#run-in-ide&quot;&gt;in the IDE&lt;/a&gt; or use the following command to run the code:</source>
          <target state="translated">これですべての定義を確認できたので、コードを修正します。&lt;a href=&quot;basic-kotlin-native-app#run-in-ide&quot;&gt;IDEで&lt;/a&gt; &lt;code&gt;runDebugExecutableNative&lt;/code&gt; Gradleタスクを実行するか、次のコマンドを使用してコードを実行します。</target>
        </trans-unit>
        <trans-unit id="7303eeb28a81c2ad71ddaf7a7ef26c96a5d46db5" translate="yes" xml:space="preserve">
          <source>We've now seen all the definitions and it is time to fix the code. Let's run the &lt;code&gt;runDebugExecutableNative&lt;/code&gt; Gradle task &lt;a href=&quot;using-intellij-idea&quot;&gt;in the IDE&lt;/a&gt; or use the following command to run the code:</source>
          <target state="translated">これですべての定義が確認できたので、コードを修正します。&lt;a href=&quot;using-intellij-idea&quot;&gt;IDEで&lt;/a&gt; &lt;code&gt;runDebugExecutableNative&lt;/code&gt; Gradleタスクを実行するか、次のコマンドを使用してコードを実行してみましょう。</target>
        </trans-unit>
        <trans-unit id="8159d531b6661d9ca1d3ee3cd78cdb26173e7e20" translate="yes" xml:space="preserve">
          <source>We've seen all definitions and it is the time to fix the code. Let's run the &lt;code&gt;runDebugExecutableNative&lt;/code&gt; Gradle task &lt;a href=&quot;basic-kotlin-native-app#run-in-ide&quot;&gt;in IDE&lt;/a&gt; or use the following command to run the code:</source>
          <target state="translated">すべての定義を見てきましたが、今こそコードを修正する時です。&lt;a href=&quot;basic-kotlin-native-app#run-in-ide&quot;&gt;IDEで&lt;/a&gt; &lt;code&gt;runDebugExecutableNative&lt;/code&gt; Gradleタスクを実行するか、次のコマンドを使用してコードを実行します。</target>
        </trans-unit>
        <trans-unit id="5060dcbe8547bb3d7e1fb6bf0d1175fce384646a" translate="yes" xml:space="preserve">
          <source>We've seen all definitions and it is the time to fix the code. Let's run the &lt;code&gt;runDebugExecutableNative&lt;/code&gt; Gradle task &lt;a href=&quot;using-intellij-idea&quot;&gt;in IDE&lt;/a&gt; or use the following command to run the code:</source>
          <target state="translated">すべての定義を確認したので、コードを修正するときが来ました。&lt;a href=&quot;using-intellij-idea&quot;&gt;IDEで&lt;/a&gt; &lt;code&gt;runDebugExecutableNative&lt;/code&gt; Gradleタスクを実行するか、次のコマンドを使用してコードを実行してみましょう。</target>
        </trans-unit>
        <trans-unit id="d875c328d56b6ba3de658fff30f901e7a7dadd62" translate="yes" xml:space="preserve">
          <source>We've seen all definitions and it is time to fix and run the code. Let's run the &lt;code&gt;runDebugExecutableNative&lt;/code&gt; Gradle task &lt;a href=&quot;basic-kotlin-native-app#run-in-ide&quot;&gt;in the IDE&lt;/a&gt; or use the following command to run the code:</source>
          <target state="translated">すべての定義を見てきました。コードを修正して実行する時が来ました。&lt;a href=&quot;basic-kotlin-native-app#run-in-ide&quot;&gt;IDEで&lt;/a&gt; &lt;code&gt;runDebugExecutableNative&lt;/code&gt; Gradleタスクを実行するか、次のコマンドを使用してコードを実行します。</target>
        </trans-unit>
        <trans-unit id="6a79043503070152826fab6d2dc8528967704ffa" translate="yes" xml:space="preserve">
          <source>We've seen all definitions and it is time to fix and run the code. Let's run the &lt;code&gt;runDebugExecutableNative&lt;/code&gt; Gradle task &lt;a href=&quot;using-intellij-idea&quot;&gt;in the IDE&lt;/a&gt; or use the following command to run the code:</source>
          <target state="translated">すべての定義を確認したので、コードを修正して実行します。&lt;a href=&quot;using-intellij-idea&quot;&gt;IDEで&lt;/a&gt; &lt;code&gt;runDebugExecutableNative&lt;/code&gt; Gradleタスクを実行するか、次のコマンドを使用してコードを実行してみましょう。</target>
        </trans-unit>
        <trans-unit id="a792d756a38347597c27360412bb8f8fa517b753" translate="yes" xml:space="preserve">
          <source>Weak bidirectional character type &quot;AN&quot; in the Unicode specification.</source>
          <target state="translated">Unicode仕様の弱い双方向性文字型「AN」。</target>
        </trans-unit>
        <trans-unit id="24dbecca4697c39dcb12d83d3e21e053a4fbf4ac" translate="yes" xml:space="preserve">
          <source>Weak bidirectional character type &quot;BN&quot; in the Unicode specification.</source>
          <target state="translated">Unicode仕様の弱い双方向性文字型「BN」。</target>
        </trans-unit>
        <trans-unit id="b592dbfa74287749b5b330052c7e3f462ec0a974" translate="yes" xml:space="preserve">
          <source>Weak bidirectional character type &quot;CS&quot; in the Unicode specification.</source>
          <target state="translated">Unicode仕様の弱い双方向性文字型「CS」。</target>
        </trans-unit>
        <trans-unit id="d484194528c4965d5cfe46ac4072c437b4f7364f" translate="yes" xml:space="preserve">
          <source>Weak bidirectional character type &quot;EN&quot; in the Unicode specification.</source>
          <target state="translated">Unicode仕様の弱い双方向性文字型「EN」。</target>
        </trans-unit>
        <trans-unit id="73f96fcc50384aeb2e177d07991c8003c66a6753" translate="yes" xml:space="preserve">
          <source>Weak bidirectional character type &quot;ES&quot; in the Unicode specification.</source>
          <target state="translated">Unicode仕様の弱い双方向性文字型「ES」。</target>
        </trans-unit>
        <trans-unit id="818ef5444e8d72a94e14f04b5d6b122d1830655b" translate="yes" xml:space="preserve">
          <source>Weak bidirectional character type &quot;ET&quot; in the Unicode specification.</source>
          <target state="translated">Unicode仕様の弱い双方向性文字型「ET」。</target>
        </trans-unit>
        <trans-unit id="34c6763955af9013896491090181dbcd5a8dd74c" translate="yes" xml:space="preserve">
          <source>Weak bidirectional character type &quot;NSM&quot; in the Unicode specification.</source>
          <target state="translated">Unicode仕様の弱い双方向性文字型「NSM」。</target>
        </trans-unit>
        <trans-unit id="956c2a4c465d4b08d54fa1ddb34419c1810351ef" translate="yes" xml:space="preserve">
          <source>Weak bidirectional character type &quot;PDF&quot; in the Unicode specification.</source>
          <target state="translated">Unicode仕様の弱い双方向性文字型「PDF」。</target>
        </trans-unit>
        <trans-unit id="5ea903ebda4f9f28f642d78e916dc09051395c95" translate="yes" xml:space="preserve">
          <source>WeakReference</source>
          <target state="translated">WeakReference</target>
        </trans-unit>
        <trans-unit id="051061c35dede06e751f127657cfd8dabc9b47ce" translate="yes" xml:space="preserve">
          <source>WebAssembly</source>
          <target state="translated">WebAssembly</target>
        </trans-unit>
        <trans-unit id="10cf3089a5d1b6f0fd308ab8ea55feb903fcea98" translate="yes" xml:space="preserve">
          <source>WebAssembly (wasm32)</source>
          <target state="translated">WebAssembly (wasm32)</target>
        </trans-unit>
        <trans-unit id="54a290ccb466e5479f81f8b2a84a8c409c89300b" translate="yes" xml:space="preserve">
          <source>WebGLActiveInfo</source>
          <target state="translated">WebGLActiveInfo</target>
        </trans-unit>
        <trans-unit id="e6b73caf842064140299b1ca0b4460e6e2d7b8db" translate="yes" xml:space="preserve">
          <source>WebGLContextAttributes</source>
          <target state="translated">WebGLContextAttributes</target>
        </trans-unit>
        <trans-unit id="4270da2ffdc4cd7b0f031d7be5d3da6756d9f418" translate="yes" xml:space="preserve">
          <source>WebGLContextEventInit</source>
          <target state="translated">WebGLContextEventInit</target>
        </trans-unit>
        <trans-unit id="40e776dc5c04c24ed694e56559baff72c6650985" translate="yes" xml:space="preserve">
          <source>WebGLObject</source>
          <target state="translated">WebGLObject</target>
        </trans-unit>
        <trans-unit id="21ae6cd2acfef9ca69acf1201e1d6a74d9cbc06a" translate="yes" xml:space="preserve">
          <source>WebGLRenderingContext</source>
          <target state="translated">WebGLRenderingContext</target>
        </trans-unit>
        <trans-unit id="4801b56eb1b5d686e9a1febe6821b4d7326421a2" translate="yes" xml:space="preserve">
          <source>WebGLRenderingContextBase</source>
          <target state="translated">WebGLRenderingContextBase</target>
        </trans-unit>
        <trans-unit id="5484abb27b9c8304c0334e77ca1817b8faf244f4" translate="yes" xml:space="preserve">
          <source>WebGLShaderPrecisionFormat</source>
          <target state="translated">WebGLShaderPrecisionFormat</target>
        </trans-unit>
        <trans-unit id="598b5bbd37e1ce6914df736dcaf0620916e3e37e" translate="yes" xml:space="preserve">
          <source>WebGLUniformLocation</source>
          <target state="translated">WebGLUniformLocation</target>
        </trans-unit>
        <trans-unit id="3a3301048780c886766fd5f9fc46f7ed9edce741" translate="yes" xml:space="preserve">
          <source>Webpack provides two different &quot;flavors&quot; of CommonJS, &lt;code&gt;commonjs&lt;/code&gt; and &lt;code&gt;commonjs2&lt;/code&gt;, which affect the way your declarations are made available. While in most cases, you probably want &lt;code&gt;commonjs2&lt;/code&gt;, which adds the &lt;code&gt;module.exports&lt;/code&gt; syntax to the generated library, you can also opt for the &quot;pure&quot; &lt;code&gt;commonjs&lt;/code&gt; option, which implements the CommonJS specification exactly. To learn more about the difference between &lt;code&gt;commonjs&lt;/code&gt; and &lt;code&gt;commonjs2&lt;/code&gt;, check &lt;a href=&quot;https://github.com/webpack/webpack/issues/1114&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">Webpackは、CommonJSの2つの異なる「フレーバー」、 &lt;code&gt;commonjs&lt;/code&gt; と &lt;code&gt;commonjs2&lt;/code&gt; を提供します。これらは、宣言を使用可能にする方法に影響を与えます。ほとんどの場合、あなたはおそらくしたいものの &lt;code&gt;commonjs2&lt;/code&gt; 追加し、 &lt;code&gt;module.exports&lt;/code&gt; はの生成されたライブラリに構文を、あなたはまた、「純粋」を選ぶことができます &lt;code&gt;commonjs&lt;/code&gt; CommonJSは正確に仕様どおり実装オプション、。 &lt;code&gt;commonjs&lt;/code&gt; と &lt;code&gt;commonjs2&lt;/code&gt; の違いの詳細については、&lt;a href=&quot;https://github.com/webpack/webpack/issues/1114&quot;&gt;こちらを&lt;/a&gt;確認してください。</target>
        </trans-unit>
        <trans-unit id="ee12f5d174e362fdee2c3d0937fed7a0a0418b29" translate="yes" xml:space="preserve">
          <source>What IDEs support Kotlin?</source>
          <target state="translated">Kotlin をサポートしている IDE は?</target>
        </trans-unit>
        <trans-unit id="f19e03186b38de86427a604326b5e20ce36b16e0" translate="yes" xml:space="preserve">
          <source>What Java has that Kotlin does not</source>
          <target state="translated">JavaにはKotlinにはないものがある</target>
        </trans-unit>
        <trans-unit id="7c25e3810f499ecbecfd573d100c2992ec85dfee" translate="yes" xml:space="preserve">
          <source>What Kotlin has that Java does not</source>
          <target state="translated">KotlinにはJavaにはないものがある</target>
        </trans-unit>
        <trans-unit id="a0618cd665f03aa3f49f142cd97a9d8c33d6f6d0" translate="yes" xml:space="preserve">
          <source>What advantages does Kotlin give me over the Java programming language?</source>
          <target state="translated">KotlinはJavaプログラミング言語に比べてどんなメリットがあるの?</target>
        </trans-unit>
        <trans-unit id="2ec574e0a3bc1f92310ec6597730108793dbab22" translate="yes" xml:space="preserve">
          <source>What are we building?</source>
          <target state="translated">何を作っているのか?</target>
        </trans-unit>
        <trans-unit id="54d0e194d6d22dc2c5cc598434a07c74290a1df0" translate="yes" xml:space="preserve">
          <source>What build tools support Kotlin?</source>
          <target state="translated">Kotlin をサポートするビルドツールは?</target>
        </trans-unit>
        <trans-unit id="b663cb1b85b44f2ed22f76f75c249fd71cd30ee5" translate="yes" xml:space="preserve">
          <source>What can I use Kotlin for?</source>
          <target state="translated">Kotlinは何に使えますか?</target>
        </trans-unit>
        <trans-unit id="1c253aa8f7093e6c010267944ec10ed903d9b3d6" translate="yes" xml:space="preserve">
          <source>What companies are using Kotlin?</source>
          <target state="translated">Kotlinを利用している企業は?</target>
        </trans-unit>
        <trans-unit id="05e8ab4ca375bf042d9384276202b934420c2059" translate="yes" xml:space="preserve">
          <source>What do we do if need to invoke them &lt;em&gt;sequentially&lt;/em&gt; &amp;ndash; first &lt;code&gt;doSomethingUsefulOne&lt;/code&gt;&lt;em&gt;and then&lt;/em&gt;&lt;code&gt;doSomethingUsefulTwo&lt;/code&gt; and compute the sum of their results? In practice we do this if we use the results of the first function to make a decision on whether we need to invoke the second one or to decide on how to invoke it.</source>
          <target state="translated">それらを&lt;em&gt;順次&lt;/em&gt;呼び出す必要がある場合はどうしますか？最初に &lt;code&gt;doSomethingUsefulOne&lt;/code&gt; を実行し&lt;em&gt;、次に&lt;/em&gt; &lt;code&gt;doSomethingUsefulTwo&lt;/code&gt; を実行して結果の合計を計算しますか？実際には、最初の関数の結果を使用して2番目の関数を呼び出す必要があるかどうか、または2番目の関数を呼び出す方法を決定する場合に、これを行います。</target>
        </trans-unit>
        <trans-unit id="ec5e65d31d420634cb6bd22727661d2a91c1e71b" translate="yes" xml:space="preserve">
          <source>What do we do if we need them to be invoked &lt;em&gt;sequentially&lt;/em&gt; &amp;mdash; first &lt;code&gt;doSomethingUsefulOne&lt;/code&gt;&lt;em&gt;and then&lt;/em&gt;&lt;code&gt;doSomethingUsefulTwo&lt;/code&gt;, and compute the sum of their results? In practice we do this if we use the result of the first function to make a decision on whether we need to invoke the second one or to decide on how to invoke it.</source>
          <target state="translated">それらを&lt;em&gt;順番&lt;/em&gt;に呼び出す必要がある場合はどうすればよいですか？最初に &lt;code&gt;doSomethingUsefulOne&lt;/code&gt; &lt;em&gt;、次に&lt;/em&gt; &lt;code&gt;doSomethingUsefulTwo&lt;/code&gt; を実行し、それらの結果の合計を計算しますか？実際には、最初の関数の結果を使用して、2番目の関数を呼び出す必要があるかどうかを決定するか、それを呼び出す方法を決定する場合にこれを行います。</target>
        </trans-unit>
        <trans-unit id="e75dc4fbbde8bc3398e1fc23b66dca3f704f50fe" translate="yes" xml:space="preserve">
          <source>What does Kotlin compile down to?</source>
          <target state="translated">コトリンは何のためにコンパイルしているのでしょうか?</target>
        </trans-unit>
        <trans-unit id="cbc1b72459c6cd091c4b5fc250725f50ac98c379" translate="yes" xml:space="preserve">
          <source>What does it print at the end? It is highly unlikely to ever print &quot;Counter = 100000&quot;, because a hundred coroutines increment the &lt;code&gt;counter&lt;/code&gt; concurrently from multiple threads without any synchronization.</source>
          <target state="translated">最後に何を印刷しますか？100のコルーチンが同期せずに複数のスレッドから同時に &lt;code&gt;counter&lt;/code&gt; インクリメントするため、「Counter = 100000」を出力することはほとんどありません。</target>
        </trans-unit>
        <trans-unit id="18807a12b7e25a451e442847837857201bfc7505" translate="yes" xml:space="preserve">
          <source>What does this signature say? It says that every time I append a string to something (a &lt;code&gt;StringBuilder&lt;/code&gt;, some kind of a log, a console, etc.) I have to catch those &lt;code&gt;IOExceptions&lt;/code&gt;. Why? Because it might be performing IO (&lt;code&gt;Writer&lt;/code&gt; also implements &lt;code&gt;Appendable&lt;/code&gt;)&amp;hellip; So it results in this kind of code all over the place:</source>
          <target state="translated">この署名は何と言っていますか？何か（ &lt;code&gt;StringBuilder&lt;/code&gt; 、ある種のログ、コンソールなど）に文字列を追加するたびに、それらの &lt;code&gt;IOExceptions&lt;/code&gt; をキャッチする必要があると書かれています。どうして？IOを実行している可能性があるため（ &lt;code&gt;Writer&lt;/code&gt; は &lt;code&gt;Appendable&lt;/code&gt; も実装しています）&amp;hellip;したがって、この種のコードがいたるところに発生します。</target>
        </trans-unit>
        <trans-unit id="7f65d1bc84288a4305aabbbfaad8cd7fe25a6b3d" translate="yes" xml:space="preserve">
          <source>What does this signature say? It says that every time I append a string to something (a &lt;code&gt;StringBuilder&lt;/code&gt;, some kind of a log, a console, etc.) I have to catch those &lt;code&gt;IOExceptions&lt;/code&gt;. Why? Because it might be performing IO (&lt;code&gt;Writer&lt;/code&gt; also implements &lt;code&gt;Appendable&lt;/code&gt;)&amp;hellip; So it results into this kind of code all over the place:</source>
          <target state="translated">この署名は何と言っていますか？文字列を何か（ &lt;code&gt;StringBuilder&lt;/code&gt; 、ある種のログ、コンソールなど）に追加するたびに、それらの &lt;code&gt;IOExceptions&lt;/code&gt; をキャッチする必要があると書かれています。どうして？IOを実行している可能性があるため（ &lt;code&gt;Writer&lt;/code&gt; は &lt;code&gt;Appendable&lt;/code&gt; も実装します）&amp;hellip;したがって、このようなコードが至るところに発生します。</target>
        </trans-unit>
        <trans-unit id="683b8d36e158b49d7282ac38785e02d0ec00e146" translate="yes" xml:space="preserve">
          <source>What happens if multiple children of a coroutine throw an exception? The general rule is &quot;the first exception wins&quot;, so the first thrown exception is exposed to the handler. But that may cause lost exceptions, for example if coroutine throws an exception in its &lt;code&gt;finally&lt;/code&gt; block. So, additional exceptions are suppressed.</source>
          <target state="translated">コルーチンの複数の子が例外をスローするとどうなりますか？一般的なルールは「最初の例外が優先される」であるため、最初にスローされた例外はハンドラーに公開されます。ただし、たとえば、コルーチンが &lt;code&gt;finally&lt;/code&gt; ブロックで例外をスローした場合など、例外が失われる可能性があります。したがって、追加の例外は抑制されます。</target>
        </trans-unit>
        <trans-unit id="365b6a79e0879610a6d21849bc8cc5cf6d51d197" translate="yes" xml:space="preserve">
          <source>What has happened here is called &lt;strong&gt;type projection&lt;/strong&gt;: we said that &lt;code&gt;from&lt;/code&gt; is not simply an array, but a restricted (&lt;strong&gt;projected&lt;/strong&gt;) one: we can only call those methods that return the type parameter &lt;code&gt;T&lt;/code&gt;, in this case it means that we can only call &lt;code&gt;get()&lt;/code&gt;. This is our approach to &lt;strong&gt;use-site variance&lt;/strong&gt;, and corresponds to Java's &lt;code&gt;Array&amp;lt;? extends Object&amp;gt;&lt;/code&gt;, but in a slightly simpler way.</source>
          <target state="translated">ここで起こったことは&lt;strong&gt;型投影&lt;/strong&gt;と呼ばれます： &lt;code&gt;from&lt;/code&gt; は単なる配列ではなく、制限された（&lt;strong&gt;投影された&lt;/strong&gt;）配列であると言いました：型パラメーター &lt;code&gt;T&lt;/code&gt; を返すメソッドのみを呼び出すことができます。この場合、 &lt;code&gt;get()&lt;/code&gt; 。これは&lt;strong&gt;use-site variance&lt;/strong&gt;への私たちのアプローチであり、Javaの &lt;code&gt;Array&amp;lt;? extends Object&amp;gt;&lt;/code&gt; 対応しています&amp;lt;？Object&amp;gt;を拡張しますが、少し簡単な方法で行います。</target>
        </trans-unit>
        <trans-unit id="77aa02de8be96f4d1a2d486916d80f88707bf2e0" translate="yes" xml:space="preserve">
          <source>What if there are no dependencies between invocation of &lt;code&gt;doSomethingUsefulOne&lt;/code&gt; and &lt;code&gt;doSomethingUsefulTwo&lt;/code&gt; and we want to get the answer faster, by doing both &lt;em&gt;concurrently&lt;/em&gt;? This is where &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html&quot;&gt;async&lt;/a&gt; comes to help.</source>
          <target state="translated">&lt;code&gt;doSomethingUsefulOne&lt;/code&gt; と &lt;code&gt;doSomethingUsefulTwo&lt;/code&gt; の呼び出しの間に依存関係がなく、両方を&lt;em&gt;同時に実行&lt;/em&gt;することで、より速く答えを取得したい場合はどうなりますか？ここで&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html&quot;&gt;非同期&lt;/a&gt;が役立ちます。</target>
        </trans-unit>
        <trans-unit id="6a9d26c1d8e7803f441abc75ddaa9a3cb6ee5810" translate="yes" xml:space="preserve">
          <source>What if there are no dependencies between invocations of &lt;code&gt;doSomethingUsefulOne&lt;/code&gt; and &lt;code&gt;doSomethingUsefulTwo&lt;/code&gt; and we want to get the answer faster, by doing both &lt;em&gt;concurrently&lt;/em&gt;? This is where &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html&quot;&gt;async&lt;/a&gt; comes to help.</source>
          <target state="translated">&lt;code&gt;doSomethingUsefulOne&lt;/code&gt; と &lt;code&gt;doSomethingUsefulTwo&lt;/code&gt; の呼び出しの間に依存関係がなく、両方を&lt;em&gt;同時に実行&lt;/em&gt;することで、より速く答えを取得したい場合はどうなりますか？ここで&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html&quot;&gt;非同期&lt;/a&gt;が役立ちます。</target>
        </trans-unit>
        <trans-unit id="e3c61df73a1cd1792c66d92381a767d6d084db44" translate="yes" xml:space="preserve">
          <source>What is Kotlin?</source>
          <target state="translated">コトリンとは?</target>
        </trans-unit>
        <trans-unit id="9c97b9a8111f68ce8c52dfe8c2a3959e4d0cfd92" translate="yes" xml:space="preserve">
          <source>What is the current version of Kotlin?</source>
          <target state="translated">コトリンの現在のバージョンは?</target>
        </trans-unit>
        <trans-unit id="72b9dc537736b5c80161df96b96d566c2340d8ed" translate="yes" xml:space="preserve">
          <source>What types do we have in the C language? Let's first list all of them. I have used the &lt;a href=&quot;https://en.wikipedia.org/wiki/C_data_types&quot;&gt;C data types&lt;/a&gt; article from Wikipedia as a basis. There are following types in the C programming language:</source>
          <target state="translated">C言語にはどのような型がありますか？まず、それらすべてをリストしましょう。私が使用している&lt;a href=&quot;https://en.wikipedia.org/wiki/C_data_types&quot;&gt;Cデータ型の&lt;/a&gt;基礎としてウィキペディアから記事を。Cプログラミング言語には次のタイプがあります。</target>
        </trans-unit>
        <trans-unit id="b3a3d061e51769639781e9a3b9954e0ba115ec4b" translate="yes" xml:space="preserve">
          <source>What we actually want is simply pass a type to this function, i.e. call it like this:</source>
          <target state="translated">実際に必要なのは、この関数に型を渡すことです。</target>
        </trans-unit>
        <trans-unit id="a50c7ef1f0fafc2256df6585bc99119f3c512a67" translate="yes" xml:space="preserve">
          <source>What&amp;#x27;s New in Kotlin 1.1</source>
          <target state="translated">Kotlin 1.1の新機能</target>
        </trans-unit>
        <trans-unit id="9a4d9d06c26d113727033d8ae4c1b63e386642d5" translate="yes" xml:space="preserve">
          <source>What&amp;#x27;s New in Kotlin 1.2</source>
          <target state="translated">Kotlin 1.2の新機能</target>
        </trans-unit>
        <trans-unit id="293419c5954282d33701ae5e04016a88fddb332a" translate="yes" xml:space="preserve">
          <source>What&amp;#x27;s New in Kotlin 1.3</source>
          <target state="translated">Kotlin 1.3の新機能</target>
        </trans-unit>
        <trans-unit id="9389cd373bffcc015f87751d1dc27567fa32b8ba" translate="yes" xml:space="preserve">
          <source>What's New in Kotlin 1.1</source>
          <target state="translated">Kotlin 1.1 の新機能</target>
        </trans-unit>
        <trans-unit id="39982142e8f2af3375fc2ff57e8c12a82c314d40" translate="yes" xml:space="preserve">
          <source>What's New in Kotlin 1.2</source>
          <target state="translated">Kotlin 1.2 の新機能</target>
        </trans-unit>
        <trans-unit id="215e0c6f310ade62568bdc051de3a2c9b6801880" translate="yes" xml:space="preserve">
          <source>What's New in Kotlin 1.3</source>
          <target state="translated">Kotlin 1.3 の新機能</target>
        </trans-unit>
        <trans-unit id="5d9f851e585b75f9f88496923e3d47ca44295647" translate="yes" xml:space="preserve">
          <source>What's New in Kotlin 1.4.0</source>
          <target state="translated">Kotlin 1.4.0 の新機能</target>
        </trans-unit>
        <trans-unit id="3d4b36bc57457b9920995102b0eb6da42363fb68" translate="yes" xml:space="preserve">
          <source>What's next?</source>
          <target state="translated">次は何をするの?</target>
        </trans-unit>
        <trans-unit id="18389155bba5ed3245c0f065f5a1c5b22a9f917a" translate="yes" xml:space="preserve">
          <source>Whatever way you choose to solve koans, you can see the solution for each task: in the online version click on &quot;Show answer&quot;, inside EduTools plugin choose &quot;Peek solution&quot;. We recommend checking the solution after you implement the task to compare your solution with the proposed one. Make sure you don't cheat!</source>
          <target state="translated">オンライン版では &quot;Show answer &quot;をクリックし、EduToolsプラグインでは &quot;Peek solution &quot;を選択してください。タスクを実装した後に解答を確認して、提案された解答と比較することをお勧めします。ズルをしないように注意してください。</target>
        </trans-unit>
        <trans-unit id="00a0667e561fb370ec041d741f3ea97adc25dc28" translate="yes" xml:space="preserve">
          <source>WheelEventInit</source>
          <target state="translated">WheelEventInit</target>
        </trans-unit>
        <trans-unit id="e3117f509259d5d29ab1ad441436b902cca8f031" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;copy-to#kotlin.io%24copyTo%28java.io.File%2C+java.io.File%2C+kotlin.Boolean%2C+kotlin.Int%29%2Foverwrite&quot;&gt;overwrite&lt;/a&gt; is &lt;code&gt;true&lt;/code&gt; and &lt;a href=&quot;copy-to#kotlin.io%24copyTo%28java.io.File%2C+java.io.File%2C+kotlin.Boolean%2C+kotlin.Int%29%2Ftarget&quot;&gt;target&lt;/a&gt; is a directory, it is replaced only if it is empty.</source>
          <target state="translated">ときに&lt;a href=&quot;copy-to#kotlin.io%24copyTo%28java.io.File%2C+java.io.File%2C+kotlin.Boolean%2C+kotlin.Int%29%2Foverwrite&quot;&gt;上書きが&lt;/a&gt;あり &lt;code&gt;true&lt;/code&gt; と&lt;a href=&quot;copy-to#kotlin.io%24copyTo%28java.io.File%2C+java.io.File%2C+kotlin.Boolean%2C+kotlin.Int%29%2Ftarget&quot;&gt;ターゲットが&lt;/a&gt;ディレクトリである、空の場合にのみ置き換えられます。</target>
        </trans-unit>
        <trans-unit id="f0d8a684192ba53b6aed7c801b9b7ef648714954" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;copy-to#kotlin.io%24copyTo(java.io.File,%20java.io.File,%20kotlin.Boolean,%20kotlin.Int)/overwrite&quot;&gt;overwrite&lt;/a&gt; is &lt;code&gt;true&lt;/code&gt; and &lt;a href=&quot;copy-to#kotlin.io%24copyTo(java.io.File,%20java.io.File,%20kotlin.Boolean,%20kotlin.Int)/target&quot;&gt;target&lt;/a&gt; is a directory, it is replaced only if it is empty.</source>
          <target state="translated">ときに&lt;a href=&quot;copy-to#kotlin.io%24copyTo(java.io.File,%20java.io.File,%20kotlin.Boolean,%20kotlin.Int)/overwrite&quot;&gt;上書きが&lt;/a&gt;あり &lt;code&gt;true&lt;/code&gt; と&lt;a href=&quot;copy-to#kotlin.io%24copyTo(java.io.File,%20java.io.File,%20kotlin.Boolean,%20kotlin.Int)/target&quot;&gt;ターゲットが&lt;/a&gt;ディレクトリである、空の場合にのみ置き換えられます。</target>
        </trans-unit>
        <trans-unit id="2d29ca92f5092a739732a54c47f3da4e556b36a7" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;mpp-create-lib&quot;&gt;creating a project with the Project Wizard&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;mpp-create-lib&quot;&gt;プロジェクトウィザードでプロジェクトを作成する&lt;/a&gt;場合。</target>
        </trans-unit>
        <trans-unit id="9f50fe0838c0d3908e85b9819f34dd2e3eeee8c8" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;launch { ... }&lt;/code&gt; is used without parameters, it inherits the context (and thus dispatcher) from the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html&quot;&gt;CoroutineScope&lt;/a&gt; it is being launched from. In this case, it inherits the context of the main &lt;code&gt;runBlocking&lt;/code&gt; coroutine which runs in the &lt;code&gt;main&lt;/code&gt; thread.</source>
          <target state="translated">&lt;code&gt;launch { ... }&lt;/code&gt; がパラメーターなしで使用される場合、起動元の&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html&quot;&gt;CoroutineScope&lt;/a&gt;からコンテキスト（したがってディスパッチャー）を継承します。この場合、 &lt;code&gt;main&lt;/code&gt; スレッドで実行されるメインの &lt;code&gt;runBlocking&lt;/code&gt; コルーチンのコンテキストを継承します。</target>
        </trans-unit>
        <trans-unit id="44dcaec5d16f5bf398df957b0d47d8f09a80f320" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;launch { ... }&lt;/code&gt; is used without parameters, it inherits the context (and thus dispatcher) from the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html&quot;&gt;CoroutineScope&lt;/a&gt; that it is being launched from. In this case, it inherits the context of the main &lt;code&gt;runBlocking&lt;/code&gt; coroutine which runs in the &lt;code&gt;main&lt;/code&gt; thread.</source>
          <target state="translated">&lt;code&gt;launch { ... }&lt;/code&gt; をパラメーターなしで使用すると、起動元の&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html&quot;&gt;CoroutineScope&lt;/a&gt;からコンテキスト（つまり、ディスパッチャー）が継承されます。この場合、 &lt;code&gt;main&lt;/code&gt; スレッドで実行されるメインの &lt;code&gt;runBlocking&lt;/code&gt; コルーチンのコンテキストを継承します。</target>
        </trans-unit>
        <trans-unit id="a67ed24b676d6021025f2b0f67bd9c35fd94aa47" translate="yes" xml:space="preserve">
          <source>When Expression</source>
          <target state="translated">表情をするとき</target>
        </trans-unit>
        <trans-unit id="e8a56a195bc479e7e07a6420a30ef594182bfdc7" translate="yes" xml:space="preserve">
          <source>When Java types are imported into Kotlin, all the references of the type &lt;code&gt;java.lang.Object&lt;/code&gt; are turned into &lt;code&gt;Any&lt;/code&gt;. Since &lt;code&gt;Any&lt;/code&gt; is not platform-specific, it only declares &lt;code&gt;toString()&lt;/code&gt;, &lt;code&gt;hashCode()&lt;/code&gt; and &lt;code&gt;equals()&lt;/code&gt; as its members, so to make other members of &lt;code&gt;java.lang.Object&lt;/code&gt; available, Kotlin uses &lt;a href=&quot;extensions&quot;&gt;extension functions&lt;/a&gt;.</source>
          <target state="translated">JavaタイプがKotlinにインポートされると、タイプ &lt;code&gt;java.lang.Object&lt;/code&gt; のすべての参照が &lt;code&gt;Any&lt;/code&gt; に変わります。 &lt;code&gt;Any&lt;/code&gt; はプラットフォーム固有ではないため、 &lt;code&gt;toString()&lt;/code&gt; 、 &lt;code&gt;hashCode()&lt;/code&gt; 、および &lt;code&gt;equals()&lt;/code&gt; をメンバーとして宣言するだけなので、 &lt;code&gt;java.lang.Object&lt;/code&gt; の他のメンバーを使用可能にするために、Kotlinは&lt;a href=&quot;extensions&quot;&gt;拡張関数を&lt;/a&gt;使用します。</target>
        </trans-unit>
        <trans-unit id="de657bff6abe90a927125239467dfc7f66aa4d06" translate="yes" xml:space="preserve">
          <source>When Kotlin classes make use of &lt;a href=&quot;generics#declaration-site-variance&quot;&gt;declaration-site variance&lt;/a&gt;, there are two options of how their usages are seen from the Java code. Let's say we have the following class and two functions that use it:</source>
          <target state="translated">Kotlinクラスが&lt;a href=&quot;generics#declaration-site-variance&quot;&gt;宣言サイト差異&lt;/a&gt;を利用する場合、Javaコードからそれらの使用法をどのように見るかについて2つのオプションがあります。次のクラスとそれを使用する2つの関数があるとします。</target>
        </trans-unit>
        <trans-unit id="752a77d62b6432105ad9d079610666a77a3a539f" translate="yes" xml:space="preserve">
          <source>When Kotlin function called from Swift/Objective-C code throws an exception which is an instance of one of the &lt;a href=&quot;exception-classes#kotlin.Throws%24exceptionClasses&quot;&gt;exceptionClasses&lt;/a&gt; or their subclasses, it is propagated as &lt;code&gt;NSError&lt;/code&gt;. Other Kotlin exceptions reaching Swift/Objective-C are considered unhandled and cause program termination.</source>
          <target state="translated">Swift / Objective-Cコードから呼び出されたKotlin関数が、&lt;a href=&quot;exception-classes#kotlin.Throws%24exceptionClasses&quot;&gt;exceptionClasses&lt;/a&gt;またはそのサブクラスの1つのインスタンスである例外をスローすると、 &lt;code&gt;NSError&lt;/code&gt; として伝播されます。Swift / Objective-Cに到達する他のKotlin例外は未処理と見なされ、プログラムが終了します。</target>
        </trans-unit>
        <trans-unit id="8df342c27a1154aea786d8fd951c9e3bea894932" translate="yes" xml:space="preserve">
          <source>When Kotlin function called from Swift/Objective-C code throws an exception which is an instance of one of the &lt;code&gt;@Throws&lt;/code&gt;-specified classes or their subclasses, it is propagated as &lt;code&gt;NSError&lt;/code&gt;. Other Kotlin exceptions reaching Swift/Objective-C are considered unhandled and cause program termination.</source>
          <target state="translated">スウィフト/ Objective-Cのコードから呼び出さKotlin機能のいずれかのインスタンスである例外スロー場合 &lt;code&gt;@Throws&lt;/code&gt; クラスまたはそのサブクラスを-specifiedが、それはのように伝播される &lt;code&gt;NSError&lt;/code&gt; 。 Swift / Objective-Cに到達する他のKotlin例外は未処理と見なされ、プログラムが終了します。</target>
        </trans-unit>
        <trans-unit id="32316c9a35a40c6afef037fd3a597555044f54d5" translate="yes" xml:space="preserve">
          <source>When a C function takes or returns a struct / union &lt;code&gt;T&lt;/code&gt; by value, the corresponding argument type or return type is represented as &lt;code&gt;CValue&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">C関数が構造体/ユニオン &lt;code&gt;T&lt;/code&gt; を値で取得または返す場合、対応する引数の型または戻り値の型は &lt;code&gt;CValue&amp;lt;T&amp;gt;&lt;/code&gt; として表されます。</target>
        </trans-unit>
        <trans-unit id="dbdcfd2e9efefb419f2bd9e89cb02a695c22cf07" translate="yes" xml:space="preserve">
          <source>When a big team is migrating onto a new version, it may appear in a &quot;inconsistent state&quot; at some point, when some developers have already updated, and others haven't. To prevent the former from writing and committing code that others may not be able to compile, we provide the following command line switches (also available in the IDE and &lt;a href=&quot;../using-gradle#compiler-options&quot;&gt;Gradle&lt;/a&gt;/&lt;a href=&quot;../using-maven#specifying-compiler-options&quot;&gt;Maven&lt;/a&gt;):</source>
          <target state="translated">大きなチームが新しいバージョンに移行するとき、一部の開発者がすでに更新していて、他の開発者が更新していないときに、ある時点で「一貫性のない状態」になることがあります。前者が他の人がコンパイルできないコードを記述およびコミットしないようにするために、次のコマンドラインスイッチを提供しています（IDEおよび&lt;a href=&quot;../using-gradle#compiler-options&quot;&gt;Gradle&lt;/a&gt; / &lt;a href=&quot;../using-maven#specifying-compiler-options&quot;&gt;Maven&lt;/a&gt;でも利用可能）：</target>
        </trans-unit>
        <trans-unit id="18b8e63399abd55d3bbbdde25d3e2fcb80bd3160" translate="yes" xml:space="preserve">
          <source>When a coroutine is launched in the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html&quot;&gt;CoroutineScope&lt;/a&gt; of another coroutine, it inherits its context via &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/coroutine-context.html&quot;&gt;CoroutineScope.coroutineContext&lt;/a&gt; and the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html&quot;&gt;Job&lt;/a&gt; of the new coroutine becomes a &lt;em&gt;child&lt;/em&gt; of the parent coroutine's job. When the parent coroutine is cancelled, all its children are recursively cancelled, too.</source>
          <target state="translated">コルーチンがで発売されている場合&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html&quot;&gt;CoroutineScope&lt;/a&gt;別のコルーチンの、それは経由してそのコンテキストを継承し&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/coroutine-context.html&quot;&gt;CoroutineScope.coroutineContext&lt;/a&gt;と&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html&quot;&gt;仕事&lt;/a&gt;の新しいコルーチンのになり&lt;em&gt;、子&lt;/em&gt;、親コルーチンの仕事の。親コルーチンがキャンセルされると、そのすべての子も再帰的にキャンセルされます。</target>
        </trans-unit>
        <trans-unit id="8b40f9ca947a81bd12ef472c030664610317efac" translate="yes" xml:space="preserve">
          <source>When a data class derived from a type that already had the &lt;code&gt;copy&lt;/code&gt; function with the same signature, the &lt;code&gt;copy&lt;/code&gt; implementation generated for the data class used the defaults from the supertype, leading to counter-intuitive behavior, or failed at runtime if there were no default parameters in the supertype.</source>
          <target state="translated">同じシグネチャを持つ &lt;code&gt;copy&lt;/code&gt; 関数がすでにある型から派生したデータクラスの場合、データクラス用に生成された &lt;code&gt;copy&lt;/code&gt; 実装はスーパータイプのデフォルトを使用し、直感に反する動作につながるか、デフォルトがない場合は実行時に失敗しましたスーパータイプのパラメータ。</target>
        </trans-unit>
        <trans-unit id="e1f3667f48b1b3a74567f895c3f805750be29c9e" translate="yes" xml:space="preserve">
          <source>When a declaration has &lt;code&gt;@JsModule&lt;/code&gt;, you can't use it from Kotlin code when you don't compile it to a JavaScript module. Usually, developers distribute their libraries both as JavaScript modules and downloadable &lt;code&gt;.js&lt;/code&gt; files that you can copy to project's static resources and include via &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; element. To tell Kotlin that it's ok to use a &lt;code&gt;@JsModule&lt;/code&gt; declaration from non-module environment, you should put &lt;code&gt;@JsNonModule&lt;/code&gt; declaration. For example, given JavaScript code:</source>
          <target state="translated">宣言に &lt;code&gt;@JsModule&lt;/code&gt; がある場合、それをJavaScriptモジュールにコンパイルしないと、Kotlinコードから使用できません。通常、開発者はライブラリをJavaScriptモジュールとダウンロード可能な &lt;code&gt;.js&lt;/code&gt; ファイルの両方として配布し、プロジェクトの静的リソースにコピーして、 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 要素を介して含めることができます。それは使用しても大丈夫だとKotlinを伝えるために &lt;code&gt;@JsModule&lt;/code&gt; の非モジュールの環境からの宣言を、あなたは置くべき &lt;code&gt;@JsNonModule&lt;/code&gt; 宣言を。たとえば、JavaScriptコードが与えられた場合：</target>
        </trans-unit>
        <trans-unit id="cdc056f54b314225b42eb84b111e0f374e0f43fb" translate="yes" xml:space="preserve">
          <source>When a declaration is marked as &lt;code&gt;@JsModule&lt;/code&gt;, you can't use it from Kotlin code when you don't compile it to a JavaScript module. Usually, developers distribute their libraries both as JavaScript modules and downloadable &lt;code&gt;.js&lt;/code&gt; files that you can copy to your project's static resources and include via a &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag. To tell Kotlin that it's okay to use a &lt;code&gt;@JsModule&lt;/code&gt; declaration from a non-module environment, add the &lt;code&gt;@JsNonModule&lt;/code&gt; annotation. For example, consider the following JavaScript code:</source>
          <target state="translated">宣言が &lt;code&gt;@JsModule&lt;/code&gt; としてマークされている場合、JavaScriptモジュールにコンパイルしないと、Kotlinコードから宣言を使用することはできません。通常、開発者はライブラリをJavaScriptモジュールとダウンロード可能な &lt;code&gt;.js&lt;/code&gt; ファイルの両方として配布します。これらのファイルは、プロジェクトの静的リソースにコピーして、 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; タグを介して含めることができます。モジュール以外の環境から &lt;code&gt;@JsModule&lt;/code&gt; 宣言を使用しても問題がないことをKotlinに伝えるには、 &lt;code&gt;@JsNonModule&lt;/code&gt; アノテーションを追加します。たとえば、次のJavaScriptコードについて考えてみます。</target>
        </trans-unit>
        <trans-unit id="6b2a92ee663b6eefd13c4799f36aa168f8eb6c67" translate="yes" xml:space="preserve">
          <source>When a flow represents partial results of the operation or operation status updates, it may not be necessary to process each value, but instead, only most recent ones. In this case, the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/conflate.html&quot;&gt;conflate&lt;/a&gt; operator can be used to skip intermediate values when a collector is too slow to process them. Building on the previous example:</source>
          <target state="translated">フローが操作または操作ステータスの更新の部分的な結果を表す場合、各値を処理する必要はなく、最新の値のみを処理する必要がある場合があります。この場合、コレクターが中間値を処理するには遅すぎるときに、&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/conflate.html&quot;&gt;conflate&lt;/a&gt;演算子を使用して中間値をスキップできます。前の例に基づいて構築：</target>
        </trans-unit>
        <trans-unit id="06eb4fdaeb1116ee0773fa0c7742573f91abd273" translate="yes" xml:space="preserve">
          <source>When a function is called with both positional and named arguments, all the positional arguments should be placed before the first named one. For example, the call &lt;code&gt;f(1, y = 2)&lt;/code&gt; is allowed, but &lt;code&gt;f(x = 1, 2)&lt;/code&gt; is not.</source>
          <target state="translated">関数が位置引数と名前付き引数の両方で呼び出される場合、すべての位置引数は最初の名前付き引数の前に配置する必要があります。たとえば、呼び出し &lt;code&gt;f(1, y = 2)&lt;/code&gt; は許可されますが、 &lt;code&gt;f(x = 1, 2)&lt;/code&gt; 1、2）は許可されません。</target>
        </trans-unit>
        <trans-unit id="c39ba3c630d6c34d1a8dfc3a61b0e9ace62da655" translate="yes" xml:space="preserve">
          <source>When a function of an external base class is overloaded by signature, you can't override it in a derived class.</source>
          <target state="translated">外部基底クラスの関数がシグネチャでオーバーロードされている場合、派生クラスではオーバーライドできません。</target>
        </trans-unit>
        <trans-unit id="f0551e05b4cdcabc413ed022b08af90ba98955ec" translate="yes" xml:space="preserve">
          <source>When a function of external base class is overloaded by signature, you can't override it in a derived class.</source>
          <target state="translated">外部基底クラスの関数がシグネチャでオーバーロードされている場合、派生クラスではオーバーライドできません。</target>
        </trans-unit>
        <trans-unit id="1cc5a0d8a7f78114a2ac1e09f9cb178d1a485871" translate="yes" xml:space="preserve">
          <source>When a function returns a single expression, the curly braces can be omitted and the body is specified after a &lt;strong&gt;=&lt;/strong&gt; symbol:</source>
          <target state="translated">関数が単一の式を返す場合、中括弧は省略でき、本文は&lt;strong&gt;=&lt;/strong&gt;記号の後に指定します。</target>
        </trans-unit>
        <trans-unit id="4d60c7b0c4e08585362731f2e3c9cea8a0422110" translate="yes" xml:space="preserve">
          <source>When a variable is assigned from a safe call expression and checked for null, the smart cast is now applied to the safe call receiver as well:</source>
          <target state="translated">安全な呼び出し式から変数が代入され、NULLをチェックすると、安全な呼び出しの受信機にもスマートキャストが適用されるようになりました。</target>
        </trans-unit>
        <trans-unit id="75ac04198276b2032c15af24079f880bbc7d4548" translate="yes" xml:space="preserve">
          <source>When an abstract class implements one or more interfaces, it is not required to provide definitions of the members of its interfaces (but it can if it wants to). It must still &lt;em&gt;declare&lt;/em&gt; such members, using &lt;code&gt;abstract override&lt;/code&gt; and not providing any body for the function or property:</source>
          <target state="translated">抽象クラスが1つ以上のインターフェースを実装する場合、そのインターフェースのメンバーの定義を提供する必要はありません（必要な場合は可能です）。 &lt;code&gt;abstract override&lt;/code&gt; を使用し、関数またはプロパティの本体を提供せずに、そのようなメンバーを&lt;em&gt;宣言する&lt;/em&gt;必要があります。</target>
        </trans-unit>
        <trans-unit id="78ca79aa88621d9e1ad1b6380be2be6eed3fd311" translate="yes" xml:space="preserve">
          <source>When an equality check operands are statically known to be &lt;code&gt;Float&lt;/code&gt; or &lt;code&gt;Double&lt;/code&gt; (nullable or not), the check follows the IEEE 754 Standard for Floating-Point Arithmetic.</source>
          <target state="translated">等価性チェックのオペランドが &lt;code&gt;Float&lt;/code&gt; または &lt;code&gt;Double&lt;/code&gt; （null可能かどうか）であることが静的にわかっている場合、チェックはIEEE 754浮動小数点演算の標準に準拠しています。</target>
        </trans-unit>
        <trans-unit id="a72bfaeeae8d98102d2bd16c961c912a01957df4" translate="yes" xml:space="preserve">
          <source>When an inline function is &lt;code&gt;public&lt;/code&gt; or &lt;code&gt;protected&lt;/code&gt; and is not a part of a &lt;code&gt;private&lt;/code&gt; or &lt;code&gt;internal&lt;/code&gt; declaration, it is considered a &lt;a href=&quot;visibility-modifiers#modules&quot;&gt;module&lt;/a&gt;'s public API. It can be called in other modules and is inlined at such call sites as well.</source>
          <target state="translated">インライン関数が &lt;code&gt;public&lt;/code&gt; または &lt;code&gt;protected&lt;/code&gt; ていて、 &lt;code&gt;private&lt;/code&gt; または &lt;code&gt;internal&lt;/code&gt; 宣言の一部ではない場合、それは&lt;a href=&quot;visibility-modifiers#modules&quot;&gt;モジュール&lt;/a&gt;のパブリックAPI と見なされます。他のモジュールで呼び出すことができ、そのような呼び出しサイトでもインライン化されます。</target>
        </trans-unit>
        <trans-unit id="a8b8b82c3468010f3b6d8941f07253746e1af976" translate="yes" xml:space="preserve">
          <source>When an instance of a subclass is constructed, the superclass &quot;part&quot; is constructed first (via the superclass constructor). This means that during execution of the constructor of an open class, it could be that the object being constructed is an instance of a subclass, in which case the subclass-specific properties have not been initialized yet. For that reason, calling an open function from a constructor is risky: it might be overridden in the subclass, and if it is accessing subclass-specific properties, those won't be initialized yet.</source>
          <target state="translated">サブクラスのインスタンスが構築されるとき、スーパークラスの「部分」が最初に構築されます (スーパークラスのコンストラクタを介して)。つまり、オープンクラスのコンストラクタの実行中に、構築されるオブジェクトがサブクラスのインスタンスである可能性があり、その場合、サブクラス固有のプロパティはまだ初期化されていません。そのため、コンストラクタからオープン関数を呼び出すのは危険です。サブクラスでオーバーライドされる可能性があり、サブクラス固有のプロパティにアクセスしている場合は、それらはまだ初期化されていません。</target>
        </trans-unit>
        <trans-unit id="5b0f246d38c7c57581718b09879ae1a9f3dd0cfb" translate="yes" xml:space="preserve">
          <source>When applied to a class or a member with internal visibility allows to use it from public inline functions and makes it effectively public.</source>
          <target state="translated">内部可視性を持つクラスやメンバに適用すると、インラインのパブリック関数から使用することができ、実質的にパブリックになります。</target>
        </trans-unit>
        <trans-unit id="b2719f8cfa129fbdd0adc701d2dba400cfb7a4df" translate="yes" xml:space="preserve">
          <source>When applied to annotation class X specifies that X defines a DSL language</source>
          <target state="translated">アノテーションクラスXに適用すると、XはDSL言語を定義していることを指定します。</target>
        </trans-unit>
        <trans-unit id="4383cdeb336d893261a8fd71ba6fa7f60d10ca1e" translate="yes" xml:space="preserve">
          <source>When applied, the CocoaPods plugin does the following:</source>
          <target state="translated">適用すると、CocoaPodsプラグインは以下のようになります。</target>
        </trans-unit>
        <trans-unit id="d3cb13a5dd74d5989c8544a9bd856469cfe20ca8" translate="yes" xml:space="preserve">
          <source>When both &lt;code&gt;excludeDependentModules&lt;/code&gt; and &lt;code&gt;headerFilter&lt;/code&gt; are used, they are applied as an intersection.</source>
          <target state="translated">&lt;code&gt;excludeDependentModules&lt;/code&gt; と &lt;code&gt;headerFilter&lt;/code&gt; の両方が使用される場合、それらは共通部分として適用されます。</target>
        </trans-unit>
        <trans-unit id="5bd916e17d31ae892ecde1eb2457f0a21c18c0ca" translate="yes" xml:space="preserve">
          <source>When building a Kotlin/JS project using Kotlin 1.3.xx, you may encounter a Gradle error if one of your dependencies (or any transitive dependency) was built using Kotlin 1.4 or higher: &lt;code&gt;Could not determine the dependencies of task ':client:jsTestPackageJson'.&lt;/code&gt; / &lt;code&gt;Cannot choose between the following variants&lt;/code&gt;. This is a known problem, a workaround is provided &lt;a href=&quot;https://youtrack.jetbrains.com/issue/KT-40226&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">Kotlin1.3.xxを使用してKotlin / JSプロジェクトをビルドするときに、依存関係の1つ（または一時的な依存関係）がKotlin 1.4以降を使用してビルドされた場合、Gradleエラーが発生することがあり &lt;code&gt;Could not determine the dependencies of task ':client:jsTestPackageJson'.&lt;/code&gt; / &lt;code&gt;Cannot choose between the following variants&lt;/code&gt; 。これは既知の問題&lt;a href=&quot;https://youtrack.jetbrains.com/issue/KT-40226&quot;&gt;です&lt;/a&gt;。回避策をここに示します。</target>
        </trans-unit>
        <trans-unit id="7f14a9a00a723afb155894bffae89af46e21d16f" translate="yes" xml:space="preserve">
          <source>When building an Objective-C framework or a native library (shared or static), you may need to pack not just the classes of the current project, but also the classes of its dependencies. Specify which dependencies to export to a binary using the &lt;code&gt;export&lt;/code&gt; method.</source>
          <target state="translated">Objective-Cフレームワークまたはネイティブライブラリ（共有または静的）を構築する場合、現在のプロジェクトのクラスだけでなく、その依存関係のクラスもパックする必要がある場合があります。 &lt;code&gt;export&lt;/code&gt; メソッドを使用してバイナリにエクスポートする依存関係を指定します。</target>
        </trans-unit>
        <trans-unit id="c05de934df0888bf3a4ea0106e90f35a575c92fc" translate="yes" xml:space="preserve">
          <source>When building an Objective-C framework, it is often necessary to pack not just the classes of the current project, but also the classes of some of its dependencies. The Binaries DSL allows one to specify which dependencies will be exported in the framework using the &lt;code&gt;export&lt;/code&gt; method. Note that only API dependencies of a corresponding source set can be exported.</source>
          <target state="translated">Objective-Cフレームワークを構築する場合、現在のプロジェクトのクラスだけでなく、その依存関係の一部のクラスもパックする必要があることがよくあります。 Binaries DSLでは、 &lt;code&gt;export&lt;/code&gt; メソッドを使用して、フレームワークでエクスポートされる依存関係を指定できます。エクスポートできるのは、対応するソースセットのAPI依存関係のみです。</target>
        </trans-unit>
        <trans-unit id="6c939554f4725c1c653be2725d54eb9e654761fc" translate="yes" xml:space="preserve">
          <source>When building from Xcode, you can use CocoaPods libraries without writing .def files manually and setting cinterop tool parameters. In this case, all required parameters can be obtained from the Xcode project configured by CocoaPods.</source>
          <target state="translated">Xcodeからビルドする場合、.defファイルを手動で書いてcinteropツールのパラメータを設定しなくても、CocoaPodsのライブラリを使用することができます。この場合、必要なパラメータはすべてCocoaPodsで設定したXcodeプロジェクトから取得できます。</target>
        </trans-unit>
        <trans-unit id="c700148c224a841d5e4fb27c316b7b0f072a2aee" translate="yes" xml:space="preserve">
          <source>When called on an object with a predicate provided, &lt;code&gt;takeIf&lt;/code&gt; returns this object if it matches the predicate. Otherwise, it returns &lt;code&gt;null&lt;/code&gt;. So, &lt;code&gt;takeIf&lt;/code&gt; is a filtering function for a single object. In turn, &lt;code&gt;takeUnless&lt;/code&gt; returns the object if it doesn't match the predicate and &lt;code&gt;null&lt;/code&gt; if it does. The object is available as a lambda argument (&lt;code&gt;it&lt;/code&gt;).</source>
          <target state="translated">述語が指定されたオブジェクトで呼び出されると、 &lt;code&gt;takeIf&lt;/code&gt; は、述語と一致する場合にこのオブジェクトを返します。それ以外の場合は、 &lt;code&gt;null&lt;/code&gt; を返します。つまり、 &lt;code&gt;takeIf&lt;/code&gt; は単一オブジェクトのフィルタリング関数です。次に、 &lt;code&gt;takeUnless&lt;/code&gt; は、オブジェクトが述語と一致しない場合はオブジェクトを返し、一致する場合は &lt;code&gt;null&lt;/code&gt; を返します。オブジェクトはラムダ引数（ &lt;code&gt;it&lt;/code&gt; ）として使用できます。</target>
        </trans-unit>
        <trans-unit id="70ae5c844919498cf5a44f8ce155a9c7029cae97" translate="yes" xml:space="preserve">
          <source>When called on lists, &lt;code&gt;addAll()&lt;/code&gt; adds new elements in the same order as they go in the argument. You can also call &lt;code&gt;addAll()&lt;/code&gt; specifying an element position as the first argument. The first element of the argument collection will be inserted at this position. Other elements of the argument collection will follow it, shifting the receiver elements to the end.</source>
          <target state="translated">リストで呼び出されると、 &lt;code&gt;addAll()&lt;/code&gt; は、引数に入力されたのと同じ順序で新しい要素を追加します。要素の位置を最初の引数として指定して &lt;code&gt;addAll()&lt;/code&gt; を呼び出すこともできます。引数コレクションの最初の要素がこの位置に挿入されます。引数コレクションの他の要素がそれに続き、レシーバー要素を最後に移動します。</target>
        </trans-unit>
        <trans-unit id="4503c0345f7f96c5163267795a01f8ff6d6296b7" translate="yes" xml:space="preserve">
          <source>When called with the default arguments, the functions return the result similar to calling &lt;code&gt;toString()&lt;/code&gt; on the collection: a &lt;code&gt;String&lt;/code&gt; of elements' string representations separated by commas with spaces.</source>
          <target state="translated">デフォルト引数で呼び出されると、関数は呼び出しと同様の結果を返す &lt;code&gt;toString()&lt;/code&gt; をコレクションにする： &lt;code&gt;String&lt;/code&gt; 要素の文字列表現のは、スペースをカンマで区切って指定します。</target>
        </trans-unit>
        <trans-unit id="4f800ac9ce646dbfd1c595ccbbdab36f597cb7a9" translate="yes" xml:space="preserve">
          <source>When called with the key present in the map, operators overwrite the values of the corresponding entries.</source>
          <target state="translated">マップに存在するキーで呼び出されると、演算子は対応するエントリの値を上書きします。</target>
        </trans-unit>
        <trans-unit id="0e3f5ee2c33fac5afe961b2bc4ee6475eb75da8a" translate="yes" xml:space="preserve">
          <source>When calling Kotlin functions from Java, nobody prevents us from passing &lt;em&gt;null&lt;/em&gt; as a non-null parameter. That's why Kotlin generates runtime checks for all public functions that expect non-nulls. This way we get a &lt;code&gt;NullPointerException&lt;/code&gt; in the Java code immediately.</source>
          <target state="translated">JavaからKotlin関数を呼び出す場合、&lt;em&gt;null&lt;/em&gt;を&lt;em&gt;null&lt;/em&gt;以外のパラメーターとして渡すことはできます。Kotlinがnull以外を期待するすべてのパブリック関数のランタイムチェックを生成するのはそのためです。このようにして、Javaコードですぐに &lt;code&gt;NullPointerException&lt;/code&gt; を取得します。</target>
        </trans-unit>
        <trans-unit id="5bf4931382d70d2a150fc1284b61bdc2c9c96f9a" translate="yes" xml:space="preserve">
          <source>When calling a function, you can name one or more of its arguments. This may be helpful when a function has a large number of arguments, and it's difficult to associate a value with an argument, especially if it's a boolean or &lt;code&gt;null&lt;/code&gt; value.</source>
          <target state="translated">関数を呼び出すときに、1つ以上の引数に名前を付けることができます。これは、関数に多数の引数があり、値を引数に関連付けることが難しい場合、特にブール値または &lt;code&gt;null&lt;/code&gt; 値の場合に役立つことがあります。</target>
        </trans-unit>
        <trans-unit id="afccfc52da19240ad334120985339616ba8ee626" translate="yes" xml:space="preserve">
          <source>When calling functions written in Kotlin on values of &lt;code&gt;dynamic&lt;/code&gt; type, keep in mind the name mangling performed by the Kotlin to JavaScript compiler. You may need to use the &lt;a href=&quot;js-to-kotlin-interop#jsname-annotation&quot;&gt;@JsName annotation&lt;/a&gt; or the &lt;a href=&quot;js-to-kotlin-interop#jsexport-annotation&quot;&gt;@JsExport annotation&lt;/a&gt; to assign well-defined names to the functions that you want to call.</source>
          <target state="translated">&lt;code&gt;dynamic&lt;/code&gt; 型の値に対してKotlinで記述された関数を呼び出すときは、KotlinからJavaScriptへのコンパイラーによって実行される名前マングリングに注意してください。あなたは使用する必要があり&lt;a href=&quot;js-to-kotlin-interop#jsname-annotation&quot;&gt;@JsName注釈&lt;/a&gt;や&lt;a href=&quot;js-to-kotlin-interop#jsexport-annotation&quot;&gt;@JsExport注釈を&lt;/a&gt;呼び出したいという機能に明確に定義された名前を割り当てること。</target>
        </trans-unit>
        <trans-unit id="a66c232a7677f7941a6400aa2f6dc79238791bec" translate="yes" xml:space="preserve">
          <source>When calling functions written in Kotlin on values of &lt;code&gt;dynamic&lt;/code&gt; type, keep in mind the name mangling performed by the Kotlin to JavaScript compiler. You may need to use the &lt;a href=&quot;js-to-kotlin-interop#jsname-annotation&quot;&gt;@JsName annotation&lt;/a&gt; to assign well-defined names to the functions that you need to call.</source>
          <target state="translated">&lt;code&gt;dynamic&lt;/code&gt; 型の値でKotlinで記述された関数を呼び出すときは、KotlinからJavaScriptコンパイラーによって実行される名前のマングリングに注意してください。&lt;a href=&quot;js-to-kotlin-interop#jsname-annotation&quot;&gt;@JsNameアノテーション&lt;/a&gt;を使用して、呼び出す必要がある関数に明確な名前を割り当てる必要がある場合があります。</target>
        </trans-unit>
        <trans-unit id="f401901149779f5935d80aef38d169d9b80565b3" translate="yes" xml:space="preserve">
          <source>When calling this function, you don&amp;rsquo;t have to name all its arguments:</source>
          <target state="translated">この関数を呼び出すときに、すべての引数に名前を付ける必要はありません。</target>
        </trans-unit>
        <trans-unit id="a144ef75b391ae884d7e13a94311bf67580a2244" translate="yes" xml:space="preserve">
          <source>When chaining other functions after &lt;code&gt;takeIf&lt;/code&gt; and &lt;code&gt;takeUnless&lt;/code&gt;, don't forget to perform the null check or the safe call (&lt;code&gt;?.&lt;/code&gt;) because their return value is nullable.</source>
          <target state="translated">&lt;code&gt;takeIf&lt;/code&gt; および &lt;code&gt;takeUnless&lt;/code&gt; の後に他の関数をチェーンするときは、戻り値がnull可能であるため、nullチェックまたはセーフコール（ &lt;code&gt;?.&lt;/code&gt; ）を実行することを忘れないでください。</target>
        </trans-unit>
        <trans-unit id="c0a48c6031f8ea84f7db041425c7fe40478df5e8" translate="yes" xml:space="preserve">
          <source>When compiling (we'll use this term interchangeably with &lt;a href=&quot;https://en.wiktionary.org/wiki/transpile&quot;&gt;transpiling&lt;/a&gt;) to JavaScript, Kotlin outputs two main files:</source>
          <target state="translated">Kotlinは、JavaScriptにコンパイルするとき（この用語を&lt;a href=&quot;https://en.wiktionary.org/wiki/transpile&quot;&gt;transpiling&lt;/a&gt;と同じ意味で使用します）、2つのメインファイルを出力します。</target>
        </trans-unit>
        <trans-unit id="9a71722d03195d233742cd235099b2a024ee3092" translate="yes" xml:space="preserve">
          <source>When compiling Kotlin code to targets JVM 1.8 and above, you could compile non-abstract methods of Kotlin interfaces into Java's &lt;code&gt;default&lt;/code&gt; methods. For this purpose, there was a mechanism that includes the &lt;code&gt;@JvmDefault&lt;/code&gt; annotation for marking such methods and the &lt;code&gt;-Xjvm-default&lt;/code&gt; compiler option that enables processing of this annotation.</source>
          <target state="translated">KotlinコードをJVM1.8以降をターゲットにコンパイルする場合、Kotlinインターフェースの非抽象メソッドをJavaの &lt;code&gt;default&lt;/code&gt; メソッドにコンパイルできます。この目的のために、そのようなメソッドをマークするための &lt;code&gt;@JvmDefault&lt;/code&gt; アノテーションと、このアノテーションの処理を可能にする &lt;code&gt;-Xjvm-default&lt;/code&gt; コンパイラオプションを含むメカニズムがありました。</target>
        </trans-unit>
        <trans-unit id="8c097f144946019495809506583d55bf5b42ced5" translate="yes" xml:space="preserve">
          <source>When compiling to JVM byte codes, the compiler optimizes access to arrays so that there's no overhead introduced:</source>
          <target state="translated">JVMバイトコードにコンパイルする場合、コンパイラは、オーバーヘッドが発生しないように配列へのアクセスを最適化します。</target>
        </trans-unit>
        <trans-unit id="d5652ef4fdb2127a183b6f70658b4242e9138b50" translate="yes" xml:space="preserve">
          <source>When compiling to Objective-C/Swift framework, methods having or inheriting this annotation are represented as &lt;code&gt;NSError*&lt;/code&gt;-producing methods in Objective-C and as &lt;code&gt;throws&lt;/code&gt; methods in Swift. When such a method called through framework API throws an exception, it is either propagated as &lt;code&gt;NSError&lt;/code&gt; or considered unhandled (if exception &lt;code&gt;is&lt;/code&gt;&lt;a href=&quot;../../kotlin/-error/index#kotlin.Error&quot;&gt;kotlin.Error&lt;/a&gt; or &lt;a href=&quot;../../kotlin/-runtime-exception/index#kotlin.RuntimeException&quot;&gt;kotlin.RuntimeException&lt;/a&gt;). In any case exception is not checked to be instance of one of the &lt;a href=&quot;exception-classes&quot;&gt;exceptionClasses&lt;/a&gt;.</source>
          <target state="translated">Objective-C / Swiftフレームワークにコンパイルする場合、このアノテーションを持つまたは継承するメソッドは、Objective-Cでは &lt;code&gt;NSError*&lt;/code&gt; メソッドとして、Swift では &lt;code&gt;throws&lt;/code&gt; メソッドとして表されます。フレームワークAPIを介して呼び出されたそのようなメソッドが例外をスローすると、それは &lt;code&gt;NSError&lt;/code&gt; として伝達されるか、未処理と見なされます（例外 &lt;code&gt;is&lt;/code&gt; &lt;a href=&quot;../../kotlin/-error/index#kotlin.Error&quot;&gt;kotlin.Error&lt;/a&gt;または&lt;a href=&quot;../../kotlin/-runtime-exception/index#kotlin.RuntimeException&quot;&gt;kotlin.RuntimeExceptionの場合&lt;/a&gt;）。いずれの場合も例外では、のいずれかのインスタンスであることを確認されていません&lt;a href=&quot;exception-classes&quot;&gt;exceptionClasses&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6587d9ea4d853cd6df9a3004ea764022f98d9281" translate="yes" xml:space="preserve">
          <source>When compiling to Objective-C/Swift framework, non-&lt;code&gt;suspend&lt;/code&gt; functions having or inheriting &lt;code&gt;@Throws&lt;/code&gt; annotation are represented as &lt;code&gt;NSError*&lt;/code&gt;-producing methods in Objective-C and as &lt;code&gt;throws&lt;/code&gt; methods in Swift. Representations for &lt;code&gt;suspend&lt;/code&gt; functions always have &lt;code&gt;NSError*&lt;/code&gt;/&lt;code&gt;Error&lt;/code&gt; parameter in completion handler.</source>
          <target state="translated">Objective-C / Swiftフレームワークにコンパイルする場合、 &lt;code&gt;@Throws&lt;/code&gt; アノテーションを持つ、または継承 &lt;code&gt;suspend&lt;/code&gt; 非サスペンド関数は、Objective-Cでは &lt;code&gt;NSError*&lt;/code&gt; メソッドとして、Swiftでは &lt;code&gt;throws&lt;/code&gt; メソッドとして表されます。 &lt;code&gt;suspend&lt;/code&gt; 関数の表現には、完了ハンドラーに常に &lt;code&gt;NSError*&lt;/code&gt; / &lt;code&gt;Error&lt;/code&gt; パラメーターがあります。</target>
        </trans-unit>
        <trans-unit id="488e4ca566eb9082ca3b6286ce0e3243bb17b8f2" translate="yes" xml:space="preserve">
          <source>When compiling to Objective-C/Swift framework, non-&lt;code&gt;suspend&lt;/code&gt; functions having or inheriting this annotation are represented as &lt;code&gt;NSError*&lt;/code&gt;-producing methods in Objective-C and as &lt;code&gt;throws&lt;/code&gt; methods in Swift. Representations for &lt;code&gt;suspend&lt;/code&gt; functions always have &lt;code&gt;NSError*&lt;/code&gt;/&lt;code&gt;Error&lt;/code&gt; parameter in completion handler</source>
          <target state="translated">Objective-C / Swiftフレームワークにコンパイルする場合、このアノテーションを持つ、または継承 &lt;code&gt;suspend&lt;/code&gt; 非サスペンド関数は、Objective-Cでは &lt;code&gt;NSError*&lt;/code&gt; メソッドとして、Swiftでは &lt;code&gt;throws&lt;/code&gt; メソッドとして表されます。 &lt;code&gt;suspend&lt;/code&gt; 関数の表現には、完了ハンドラーに常に &lt;code&gt;NSError*&lt;/code&gt; / &lt;code&gt;Error&lt;/code&gt; パラメーターがあります</target>
        </trans-unit>
        <trans-unit id="0a9ee7ef1045f5338ee8701cbc0ba2b21b7f1d68" translate="yes" xml:space="preserve">
          <source>When compiling to Swift or the Objective-C framework, functions that have or are inheriting &lt;code&gt;@Throws&lt;/code&gt; annotation are represented as &lt;code&gt;NSError*&lt;/code&gt;-producing methods in Objective-C and as &lt;code&gt;throws&lt;/code&gt; methods in Swift.</source>
          <target state="translated">SwiftまたはObjective-Cフレームワークにコンパイルする場合、 &lt;code&gt;@Throws&lt;/code&gt; アノテーションを持つ、または継承している関数は、Objective-Cでは &lt;code&gt;NSError*&lt;/code&gt; メソッドとして、Swiftでは &lt;code&gt;throws&lt;/code&gt; メソッドとして表されます。</target>
        </trans-unit>
        <trans-unit id="b96c28145bcb8f6ff8815136a3e9f396b218615b" translate="yes" xml:space="preserve">
          <source>When compiling, the compiler always outputs the kotlin.js file. The easiest way to reference this without having to refer to paths, is to set the output library folder for the compiler options to &lt;code&gt;node_modules&lt;/code&gt;. This way, Node will automatically pick it up as it does an exhaustive search for files under these folders</source>
          <target state="translated">コンパイル時、コンパイラーは常にkotlin.jsファイルを出力します。パスを参照せずにこれを参照する最も簡単な方法は、コンパイラオプションの出力ライブラリフォルダーを &lt;code&gt;node_modules&lt;/code&gt; に設定することです。このようにして、ノードはこれらのフォルダーの下のファイルを徹底的に検索するときに、ノードを自動的にピックアップします</target>
        </trans-unit>
        <trans-unit id="5b6df5ad94ece159e4d2e7854f633a08ec2ced8b" translate="yes" xml:space="preserve">
          <source>When creating a new application or module that targets JavaScript, we need to select &lt;code&gt;Kotlin - JavaScript&lt;/code&gt; as the target</source>
          <target state="translated">JavaScriptをターゲットとする新しいアプリケーションまたはモジュールを作成する場合、ターゲットとして &lt;code&gt;Kotlin - JavaScript&lt;/code&gt; を選択する必要があります</target>
        </trans-unit>
        <trans-unit id="40c235de508210259df882cfb516e8a1d647fb3f" translate="yes" xml:space="preserve">
          <source>When declaring dependencies on npm packages, you are now required to explicitly specify a version or version range based on &lt;a href=&quot;https://docs.npmjs.com/misc/semver#versions&quot;&gt;npm&amp;rsquo;s semver syntax&lt;/a&gt;. Specifying multiple version ranges is also supported.</source>
          <target state="translated">npmパッケージへの依存関係を宣言する場合、&lt;a href=&quot;https://docs.npmjs.com/misc/semver#versions&quot;&gt;npmのsemver構文に&lt;/a&gt;基づいてバージョンまたはバージョン範囲を明示的に指定する必要があります。複数のバージョン範囲の指定もサポートされています。</target>
        </trans-unit>
        <trans-unit id="03565eec78cb8bfb0c999a9b15ff0e6c755df92b" translate="yes" xml:space="preserve">
          <source>When declaring parameter names in a multiline lambda, put the names on the first line, followed by the arrow and the newline:</source>
          <target state="translated">複数行のラムダでパラメータ名を宣言する場合は、最初の行に名前を入れ、その後に矢印と改行を入れます。</target>
        </trans-unit>
        <trans-unit id="3ef5c76bfa4e43b35f38295e1d456c70ff2408cf" translate="yes" xml:space="preserve">
          <source>When executing this run configuration, we can note that the Gradle process continues watching for changes to the program:</source>
          <target state="translated">この実行設定を実行すると、Gradleプロセスがプログラムの変更を監視し続けていることに注意することができます。</target>
        </trans-unit>
        <trans-unit id="04dc660c0cd261412da813263e6942fbca96f489" translate="yes" xml:space="preserve">
          <source>When flow collection completes (normally or exceptionally) it may need to execute an action. As you may have already noticed, it can be done in two ways: imperative or declarative.</source>
          <target state="translated">フローコレクションが(通常または例外的に)完了すると、アクションを実行する必要がある場合があります。すでにお気づきかもしれませんが、これには命令的なものと宣言的なものの2つの方法があります。</target>
        </trans-unit>
        <trans-unit id="210a72ecd64e91bda5f9f64c7a09dfe81ca0e12e" translate="yes" xml:space="preserve">
          <source>When flow represents the most recent value of a variable or operation (see also the related section on &lt;a href=&quot;#conflation&quot;&gt;conflation&lt;/a&gt;), it might be needed to perform a computation that depends on the most recent values of the corresponding flows and to recompute it whenever any of the upstream flows emit a value. The corresponding family of operators is called &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/combine.html&quot;&gt;combine&lt;/a&gt;.</source>
          <target state="translated">フローが変数または操作の最新の値を表す場合（&lt;a href=&quot;#conflation&quot;&gt;conflation&lt;/a&gt;の関連セクションも参照）、対応するフローの最新の値に依存する計算を実行し、アップストリームのいずれかが発生するたびに再計算する必要がある場合があります。フローは値を放出します。対応する演算子のファミリーは&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/combine.html&quot;&gt;combine&lt;/a&gt;と呼ばれます。</target>
        </trans-unit>
        <trans-unit id="16ca0ed2cf53ba99dfc24939c39b34cc8182bea3" translate="yes" xml:space="preserve">
          <source>When given a &lt;code&gt;-library foo&lt;/code&gt; flag, the compiler searches the &lt;code&gt;foo&lt;/code&gt; library in the following order:</source>
          <target state="translated">&lt;code&gt;-library foo&lt;/code&gt; フラグを指定すると、コンパイラーは &lt;code&gt;foo&lt;/code&gt; ライブラリーを次の順序で検索します。</target>
        </trans-unit>
        <trans-unit id="dd5a17a3b22c6470172a587dc5be67c1d1df4d62" translate="yes" xml:space="preserve">
          <source>When given the above snippet the &lt;code&gt;cinterop&lt;/code&gt; tool will search &lt;code&gt;libfoo.a&lt;/code&gt; in &lt;code&gt;/opt/local/lib&lt;/code&gt; and &lt;code&gt;/usr/local/opt/curl/lib&lt;/code&gt;, and if it is found include the library binary into &lt;code&gt;klib&lt;/code&gt;.</source>
          <target state="translated">与えられた場合には上記のスニペット &lt;code&gt;cinterop&lt;/code&gt; のツールを検索します &lt;code&gt;libfoo.a&lt;/code&gt; をで &lt;code&gt;/opt/local/lib&lt;/code&gt; と &lt;code&gt;/usr/local/opt/curl/lib&lt;/code&gt; 、そしてそれが発見された場合に、ライブラリのバイナリが含まれ &lt;code&gt;klib&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="010f9a9f094ca37e15156897e51ac67f748d0305" translate="yes" xml:space="preserve">
          <source>When implementing an interface, keep the implementing members in the same order as members of the interface (if necessary, interspersed with additional private methods used for the implementation)</source>
          <target state="translated">インターフェースを実装する際には、実装メンバーをインターフェースのメンバーと同じ順序で保持する(必要に応じて、実装に使用される追加のプライベートメソッドを挟む)。</target>
        </trans-unit>
        <trans-unit id="27dfae03dd6477eb5611a6a8eca02c237e81ed5f" translate="yes" xml:space="preserve">
          <source>When in &lt;code&gt;both&lt;/code&gt; mode, the IR compiler backend and default compiler backend are both used when building a library from your sources (hence the name). This means that both &lt;code&gt;klib&lt;/code&gt; files with Kotlin IR as well as &lt;code&gt;jar&lt;/code&gt; files for the default compiler will be generated. When published under the same Maven coordinate, Gradle will automatically choose the right artifact depending on the use case &amp;ndash; &lt;code&gt;js&lt;/code&gt; for the old compiler, &lt;code&gt;klib&lt;/code&gt; for the new one. This enables you to compile and publish your library for projects that are using either of the two compiler backends.</source>
          <target state="translated">&lt;code&gt;both&lt;/code&gt; モードの場合、ソースからライブラリを構築するときに、IRコンパイラバックエンドとデフォルトコンパイラバックエンドの両方が使用されます（そのため、この名前が付けられています）。これは、Kotlin IRを使用した &lt;code&gt;klib&lt;/code&gt; ファイルと、デフォルトのコンパイラ用の &lt;code&gt;jar&lt;/code&gt; ファイルの両方が生成されることを意味します。同じMaven座標で公開された場合、Gradleはユースケースに応じて適切なアーティファクトを自動的に選択します。古いコンパイラの場合は &lt;code&gt;js&lt;/code&gt; 、新しいコンパイラの場合は &lt;code&gt;klib&lt;/code&gt; です。これにより、2つのコンパイラバックエンドのいずれかを使用しているプロジェクト用にライブラリをコンパイルして公開できます。</target>
        </trans-unit>
        <trans-unit id="0d8190bf6bb340fcc1bfe9465dd44a27ec0f22ba" translate="yes" xml:space="preserve">
          <source>When installed for the first time, EduTools plugin asks if you're a Learner or an Educator. Please choose &lt;strong&gt;Educator&lt;/strong&gt; to enable course creation functionality:</source>
          <target state="translated">EduToolsプラグインを初めてインストールすると、学習者か教育者かを尋ねられます。コース作成機能を有効にするには、&lt;strong&gt;教育者&lt;/strong&gt;を選択してください：</target>
        </trans-unit>
        <trans-unit id="8932a8146c0a90dc2dd58707de728ef7a12acaa8" translate="yes" xml:space="preserve">
          <source>When installed for the first time, the EduTools plugin asks if you're a Learner or an Educator. Please choose &lt;strong&gt;Learner&lt;/strong&gt;:</source>
          <target state="translated">EduToolsプラグインは、初めてインストールしたときに、学習者か教育者かを尋ねます。&lt;strong&gt;学習者を&lt;/strong&gt;選択してください：</target>
        </trans-unit>
        <trans-unit id="10a5b3cb7bba7c274d069162e0ee74e696f381e7" translate="yes" xml:space="preserve">
          <source>When library headers are imported to a C program with the &lt;code&gt;#include&lt;/code&gt; directive, all of the headers included by these headers are also included in the program. So all header dependencies are included in generated stubs as well.</source>
          <target state="translated">&lt;code&gt;#include&lt;/code&gt; ディレクティブを使用してライブラリヘッダーをCプログラムにインポートすると、これらのヘッダーに含まれるすべてのヘッダーもプログラムに含まれます。したがって、ヘッダーの依存関係はすべて、生成されたスタブにも含まれます。</target>
        </trans-unit>
        <trans-unit id="3922383306a8a09a6b0e8b2eb8f9a1db1f1ab0db" translate="yes" xml:space="preserve">
          <source>When list elements aren't &lt;code&gt;Comparable&lt;/code&gt;, you should provide a &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-comparator&quot;&gt;&lt;code&gt;Comparator&lt;/code&gt;&lt;/a&gt; to use in the binary search. The list must be sorted in ascending order according to this &lt;code&gt;Comparator&lt;/code&gt;. Let's have a look at an example:</source>
          <target state="translated">リストの要素が &lt;code&gt;Comparable&lt;/code&gt; ではない場合、バイナリ検索で使用する&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-comparator&quot;&gt; &lt;code&gt;Comparator&lt;/code&gt; &lt;/a&gt;を提供する必要があります。リストは、この &lt;code&gt;Comparator&lt;/code&gt; に従って昇順でソートする必要があります。例を見てみましょう：</target>
        </trans-unit>
        <trans-unit id="eb20fed2a040f5bec7d775d79d512be41c67a260" translate="yes" xml:space="preserve">
          <source>When making a choice between a complex expression using multiple higher-order functions and a loop, understand the cost of the operations being performed in each case and keep performance considerations in mind.</source>
          <target state="translated">複数の高次関数を用いた複雑な式とループを選択する際には、それぞれのケースで実行される演算のコストを理解し、性能を考慮した上で選択してください。</target>
        </trans-unit>
        <trans-unit id="34a85c247b6ac08983d01a72671ac866f48daed6" translate="yes" xml:space="preserve">
          <source>When multiple children of a coroutine fail with an exception, the general rule is &quot;the first exception wins&quot;, so the first exception gets handled. All additional exceptions that happen after the first one are attached to the first exception as suppressed ones.</source>
          <target state="translated">コアーチンの複数の子プロセスが例外で失敗した場合、一般的なルールは「最初の例外が勝つ」ので、最初の例外が処理されます。最初の例外の後に発生するすべての追加の例外は、抑制された例外として最初の例外に添付されます。</target>
        </trans-unit>
        <trans-unit id="2970ac1e3a2dbc090d5bfcbffc924f278b84baec" translate="yes" xml:space="preserve">
          <source>When returning a value, the parser gives preference to the qualified return, i.e.</source>
          <target state="translated">値を返すとき、パーサは修飾された戻り値を優先します。</target>
        </trans-unit>
        <trans-unit id="91e0d5690967c5e3915ccf3388a11d3d82da8814" translate="yes" xml:space="preserve">
          <source>When running this example in the browser, the DOM will be assembled in a straightforward way. This is easily confirmed by checking the Elements of the website using the developer tools of our browser:</source>
          <target state="translated">この例をブラウザで実行すると、DOM は簡単な方法で組み立てられます。これは、ブラウザの開発者ツールを使ってウェブサイトの要素を確認することで簡単に確認できます。</target>
        </trans-unit>
        <trans-unit id="6b57a6650ec36adfcbda42de47e0a60e863df953" translate="yes" xml:space="preserve">
          <source>When somebody calls the function &lt;code&gt;getDate()&lt;/code&gt;, they won't be informed about the experimental API used in its body.</source>
          <target state="translated">誰かが関数 &lt;code&gt;getDate()&lt;/code&gt; を呼び出しても、本体で使用されている実験的なAPIについては通知されません。</target>
        </trans-unit>
        <trans-unit id="bfa8681d13a7c615930222f478ec4f7aeac79c5a" translate="yes" xml:space="preserve">
          <source>When somebody calls the function &lt;code&gt;getDate()&lt;/code&gt;, they won't be informed about the opt-in requirements for APIs used in its body.</source>
          <target state="translated">誰かが関数 &lt;code&gt;getDate()&lt;/code&gt; を呼び出しても、その本体で使用されているAPIのオプトイン要件については通知されません。</target>
        </trans-unit>
        <trans-unit id="6e6f8bdf23dc342f6366d0ca972d7d991572a9e7" translate="yes" xml:space="preserve">
          <source>When supported by the platform adds the specified exception to the list of exceptions that were suppressed in order to deliver this exception.</source>
          <target state="translated">プラットフォームがサポートしている場合、指定した例外を、この例外を配信するために抑制された例外のリストに追加します。</target>
        </trans-unit>
        <trans-unit id="6393b31c82857a557e8af4f2a0be0aaf5d58b5c5" translate="yes" xml:space="preserve">
          <source>When supported by the platform, adds the specified exception to the list of exceptions that were suppressed in order to deliver this exception.</source>
          <target state="translated">プラットフォームでサポートされている場合、この例外を配信するために抑制された例外のリストに、指定された例外を追加します。</target>
        </trans-unit>
        <trans-unit id="3c40217c2fbf96f7f32af012e76efee928b75c4a" translate="yes" xml:space="preserve">
          <source>When targeting JavaScript, a different plugin should be applied:</source>
          <target state="translated">JavaScriptを対象とする場合は、別のプラグインを適用する必要があります。</target>
        </trans-unit>
        <trans-unit id="6febffb6e2904e4bbf90391b0727f1dbf05ee0c1" translate="yes" xml:space="preserve">
          <source>When targeting JavaScript, the tasks are called &lt;code&gt;compileKotlin2Js&lt;/code&gt; and &lt;code&gt;compileTestKotlin2Js&lt;/code&gt; respectively, and &lt;code&gt;compile&amp;lt;Name&amp;gt;Kotlin2Js&lt;/code&gt; for custom source sets.</source>
          <target state="translated">JavaScriptを対象とする場合、タスクはそれぞれ &lt;code&gt;compileKotlin2Js&lt;/code&gt; および &lt;code&gt;compileTestKotlin2Js&lt;/code&gt; と呼ばれ、カスタムソースセットの &lt;code&gt;compile&amp;lt;Name&amp;gt;Kotlin2Js&lt;/code&gt; はcompile &amp;lt;Name&amp;gt; Kotlin2Jsです。</target>
        </trans-unit>
        <trans-unit id="fb89dbb9f04dc9361c7746b53e92457b21476e1a" translate="yes" xml:space="preserve">
          <source>When targeting JavaScript, the tasks are called &lt;code&gt;compileKotlinJs&lt;/code&gt; and &lt;code&gt;compileTestKotlinJs&lt;/code&gt; respectively, and &lt;code&gt;compile&amp;lt;Name&amp;gt;KotlinJs&lt;/code&gt; for custom source sets.</source>
          <target state="translated">JavaScriptを対象とする場合、タスクはそれぞれ &lt;code&gt;compileKotlinJs&lt;/code&gt; および &lt;code&gt;compileTestKotlinJs&lt;/code&gt; と呼ばれ、カスタムソースセットの &lt;code&gt;compile&amp;lt;Name&amp;gt;KotlinJs&lt;/code&gt; はcompile &amp;lt;Name&amp;gt; KotlinJsと呼ばれます。</target>
        </trans-unit>
        <trans-unit id="68caa257adc3424d8615357e16a81ae92f1364f3" translate="yes" xml:space="preserve">
          <source>When targeting Node.js with Kotlin/JS, we can simply execute the &lt;code&gt;run&lt;/code&gt; Gradle task. This can be done for example via the command line, using the Gradle wrapper:</source>
          <target state="translated">Kotlin / JSでのNode.jsをターゲットにすると、我々は単純に実行することができ &lt;code&gt;run&lt;/code&gt; Gradleのタスクを。これは、たとえばコマンドラインからGradleラッパーを使用して実行できます。</target>
        </trans-unit>
        <trans-unit id="8307ea9f68fd265bde506b102ae1144dc569ce2b" translate="yes" xml:space="preserve">
          <source>When targeting only JavaScript, use the &lt;code&gt;kotlin-js&lt;/code&gt; plugin. &lt;a href=&quot;js-project-setup&quot;&gt;Learn more&lt;/a&gt;</source>
          <target state="translated">JavaScriptのみを対象とする場合は、 &lt;code&gt;kotlin-js&lt;/code&gt; プラグインを使用してください。&lt;a href=&quot;js-project-setup&quot;&gt;もっと詳しく知る&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3700a9140aca950bb22b2b6e73a90e60e275240a" translate="yes" xml:space="preserve">
          <source>When targeting the JVM, Kotlin produces Java compatible bytecode. When targeting JavaScript, Kotlin transpiles to ES5.1 and generates code which is compatible with module systems including AMD and CommonJS. When targeting native, Kotlin will produce platform-specific code (via LLVM).</source>
          <target state="translated">JVMをターゲットにした場合、KotlinはJava互換のバイトコードを生成します。JavaScriptをターゲットにしている場合、KotlinはES5.1にトランスパイルし、AMDやCommonJSを含むモジュールシステムと互換性のあるコードを生成します。ネイティブをターゲットにしている場合、Kotlinはプラットフォーム固有のコードを生成します(LLVM経由)。</target>
        </trans-unit>
        <trans-unit id="2fd9751d3f79fd88ae2a197e9ec6c24a47840b01" translate="yes" xml:space="preserve">
          <source>When targeting the JVM, the tasks are called &lt;code&gt;compileKotlin&lt;/code&gt; for production code and &lt;code&gt;compileTestKotlin&lt;/code&gt; for test code. The tasks for custom source sets are called accordingly to the &lt;code&gt;compile&amp;lt;Name&amp;gt;Kotlin&lt;/code&gt; pattern.</source>
          <target state="translated">JVMをターゲットにすると、タスクが呼び出され &lt;code&gt;compileKotlin&lt;/code&gt; 生産コードとのために &lt;code&gt;compileTestKotlin&lt;/code&gt; テストコードのために。カスタムソースセットのタスクは、 &lt;code&gt;compile&amp;lt;Name&amp;gt;Kotlin&lt;/code&gt; パターンに応じて呼び出されます。</target>
        </trans-unit>
        <trans-unit id="cb9436a471e8dbc8503c3b6e6a7c9d3c34f6ebb0" translate="yes" xml:space="preserve">
          <source>When targeting the browser, our project is required to have an HTML page. This page will be served by the development server while we are working on our application, and should embed our compiled Kotlin/JS file. Create and fill an HTML file &lt;code&gt;/src/main/resources/index.html&lt;/code&gt;:</source>
          <target state="translated">ブラウザをターゲットにする場合、プロジェクトにはHTMLページが必要です。このページは、アプリケーションの作業中に開発サーバーによって提供され、コンパイルされたKotlin / JSファイルを埋め込む必要があります。HTMLファイル &lt;code&gt;/src/main/resources/index.html&lt;/code&gt; を作成して入力します。</target>
        </trans-unit>
        <trans-unit id="f18755d5fafc0688db03f9113e5e8aba876e9f17" translate="yes" xml:space="preserve">
          <source>When the argument type is final, there's usually no point in generating the wildcard, so &lt;code&gt;Box&amp;lt;String&amp;gt;&lt;/code&gt; is always &lt;code&gt;Box&amp;lt;String&amp;gt;&lt;/code&gt;, no matter what position it takes.</source>
          <target state="translated">引数の型がfinalの場合、通常はワイルドカードを生成しても意味がないため、 &lt;code&gt;Box&amp;lt;String&amp;gt;&lt;/code&gt; は、どのような位置であっても常に &lt;code&gt;Box&amp;lt;String&amp;gt;&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="4260e7c630e27226c5f3f5f47519e7ba6fce2dbf" translate="yes" xml:space="preserve">
          <source>When the operands &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are statically known to be &lt;code&gt;Float&lt;/code&gt; or &lt;code&gt;Double&lt;/code&gt; or their nullable counterparts (the type is declared or inferred or is a result of a &lt;a href=&quot;typecasts#smart-casts&quot;&gt;smart cast&lt;/a&gt;), the operations on the numbers and the range that they form follow the IEEE 754 Standard for Floating-Point Arithmetic.</source>
          <target state="translated">オペランド &lt;code&gt;a&lt;/code&gt; および &lt;code&gt;b&lt;/code&gt; が静的に &lt;code&gt;Float&lt;/code&gt; または &lt;code&gt;Double&lt;/code&gt; 、またはそれらのnull可能な対応物であることがわかっている（型が宣言または推論されている、または&lt;a href=&quot;typecasts#smart-casts&quot;&gt;スマートキャストの&lt;/a&gt;結果である）場合、それらが形成する数値および範囲に対する演算は、IEEE 754に従います浮動小数点演算の標準。</target>
        </trans-unit>
        <trans-unit id="50fe39e80afdb0bafe5609ac0ee60d49bbca274d" translate="yes" xml:space="preserve">
          <source>When the original &lt;a href=&quot;intercept-continuation#kotlin.coroutines.ContinuationInterceptor%24interceptContinuation%28kotlin.coroutines.Continuation%28%28kotlin.coroutines.ContinuationInterceptor.interceptContinuation.T%29%29%29%2Fcontinuation&quot;&gt;continuation&lt;/a&gt; completes, coroutine framework invokes &lt;a href=&quot;release-intercepted-continuation&quot;&gt;releaseInterceptedContinuation&lt;/a&gt; with the resulting continuation if it was intercepted, that is if &lt;code&gt;interceptContinuation&lt;/code&gt; had previously returned a different continuation instance.</source>
          <target state="translated">元の&lt;a href=&quot;intercept-continuation#kotlin.coroutines.ContinuationInterceptor%24interceptContinuation%28kotlin.coroutines.Continuation%28%28kotlin.coroutines.ContinuationInterceptor.interceptContinuation.T%29%29%29%2Fcontinuation&quot;&gt;継続が&lt;/a&gt;完了すると、コルーチンフレームワークは&lt;a href=&quot;release-intercepted-continuation&quot;&gt;releaseInterceptedContinuation&lt;/a&gt;を呼び出します。 &lt;code&gt;interceptContinuation&lt;/code&gt; た場合、つまり、interceptContinuationが以前に別の継続インスタンスを返していた場合、結果の継続が発生します。</target>
        </trans-unit>
        <trans-unit id="41195e5948b5d9d14accce4fb777d5a5399f88d7" translate="yes" xml:space="preserve">
          <source>When the original &lt;a href=&quot;intercept-continuation#kotlin.coroutines.ContinuationInterceptor%24interceptContinuation(kotlin.coroutines.Continuation((kotlin.coroutines.ContinuationInterceptor.interceptContinuation.T)))/continuation&quot;&gt;continuation&lt;/a&gt; completes, coroutine framework invokes &lt;a href=&quot;release-intercepted-continuation&quot;&gt;releaseInterceptedContinuation&lt;/a&gt; with the resulting continuation if it was intercepted, that is if &lt;code&gt;interceptContinuation&lt;/code&gt; had previously returned a different continuation instance.</source>
          <target state="translated">元の&lt;a href=&quot;intercept-continuation#kotlin.coroutines.ContinuationInterceptor%24interceptContinuation(kotlin.coroutines.Continuation((kotlin.coroutines.ContinuationInterceptor.interceptContinuation.T)))/continuation&quot;&gt;継続が&lt;/a&gt;完了すると、コルーチンフレームワークは&lt;a href=&quot;release-intercepted-continuation&quot;&gt;releaseInterceptedContinuation&lt;/a&gt;を呼び出し、 &lt;code&gt;interceptContinuation&lt;/code&gt; た場合、つまり、interceptContinuationが以前に別の継続インスタンスを返した場合に結果の継続を返します。</target>
        </trans-unit>
        <trans-unit id="aee129400c7cdc16a95ec0912c8a4fd0a5a9f195" translate="yes" xml:space="preserve">
          <source>When the processing of an &lt;code&gt;Iterable&lt;/code&gt; includes multiple steps, they are executed eagerly: each processing step completes and returns its result &amp;ndash; an intermediate collection. The following step executes on this collection. In turn, multi-step processing of sequences is executed lazily when possible: actual computing happens only when the result of the whole processing chain is requested.</source>
          <target state="translated">&lt;code&gt;Iterable&lt;/code&gt; の処理に複数のステップが含まれる場合、それらは熱心に実行されます。各処理ステップは完了し、その結果（中間コレクション）を返します。次のステップは、このコレクションで実行されます。次に、シーケンスのマルチステップ処理は、可能な場合は遅延実行されます。実際の計算は、処理チェーン全体の結果が要求されたときにのみ行われます。</target>
        </trans-unit>
        <trans-unit id="45bf077d097fcdb663238684f69205850ecd18da" translate="yes" xml:space="preserve">
          <source>When the project consists of exclusively Kotlin source code, the easiest way to compile the project is to use the &lt;em&gt;kotlinc&lt;/em&gt; task:</source>
          <target state="translated">プロジェクトがKotlinソースコードのみで構成されている場合、プロジェクトをコンパイルする最も簡単な方法は、&lt;em&gt;kotlinc&lt;/em&gt;タスクを使用することです。</target>
        </trans-unit>
        <trans-unit id="de3a7fefd9c0e4fdceeb9aa1f2016defc2704512" translate="yes" xml:space="preserve">
          <source>When this annotation is placed on a generic function parameter of a function, it enables to infer the type arguments of that generic function from the lambda body passed to that parameter.</source>
          <target state="translated">このアノテーションを関数の汎用関数のパラメータに配置すると、パラメータに渡されたラムダボディから汎用関数の型引数を推論することができます。</target>
        </trans-unit>
        <trans-unit id="4048f5f513aab453351704d3921c71dee68c7768" translate="yes" xml:space="preserve">
          <source>When this char sequence starts with and ends with the given &lt;a href=&quot;../../kotlin.text/remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fdelimiter&quot;&gt;delimiter&lt;/a&gt;, returns a new char sequence having this &lt;a href=&quot;../../kotlin.text/remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fdelimiter&quot;&gt;delimiter&lt;/a&gt; removed both from the start and end. Otherwise returns a new char sequence with the same characters.</source>
          <target state="translated">この文字シーケンスが指定さ&lt;a href=&quot;../../kotlin.text/remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fdelimiter&quot;&gt;れた区切り文字&lt;/a&gt;で開始および終了する場合、この&lt;a href=&quot;../../kotlin.text/remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fdelimiter&quot;&gt;区切り文字を&lt;/a&gt;開始と終了の両方から削除した新しい文字シーケンスを返します。それ以外の場合は、同じ文字を含む新しい文字シーケンスを返します。</target>
        </trans-unit>
        <trans-unit id="71738510e58b58513693f2e894d632554b8f850d" translate="yes" xml:space="preserve">
          <source>When this char sequence starts with and ends with the given &lt;a href=&quot;../../kotlin.text/remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence)/delimiter&quot;&gt;delimiter&lt;/a&gt;, returns a new char sequence having this &lt;a href=&quot;../../kotlin.text/remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence)/delimiter&quot;&gt;delimiter&lt;/a&gt; removed both from the start and end. Otherwise returns a new char sequence with the same characters.</source>
          <target state="translated">このcharシーケンスが指定さ&lt;a href=&quot;../../kotlin.text/remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence)/delimiter&quot;&gt;れた区切り文字&lt;/a&gt;で始まり、終わる場合、この&lt;a href=&quot;../../kotlin.text/remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence)/delimiter&quot;&gt;区切り文字&lt;/a&gt;が開始と終了の両方から削除された新しいcharシーケンスを返します。それ以外の場合は、同じ文字の新しいcharシーケンスを返します。</target>
        </trans-unit>
        <trans-unit id="662d6d4b8c6d089b2ede0be25f7514459a1a7dc8" translate="yes" xml:space="preserve">
          <source>When this char sequence starts with and ends with the given &lt;a href=&quot;../remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fdelimiter&quot;&gt;delimiter&lt;/a&gt;, returns a new char sequence having this &lt;a href=&quot;../remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fdelimiter&quot;&gt;delimiter&lt;/a&gt; removed both from the start and end. Otherwise returns a new char sequence with the same characters.</source>
          <target state="translated">この文字シーケンスが指定さ&lt;a href=&quot;../remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fdelimiter&quot;&gt;れた区切り文字&lt;/a&gt;で開始および終了する場合、この&lt;a href=&quot;../remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fdelimiter&quot;&gt;区切り文字を&lt;/a&gt;開始と終了の両方から削除した新しい文字シーケンスを返します。それ以外の場合は、同じ文字を含む新しい文字シーケンスを返します。</target>
        </trans-unit>
        <trans-unit id="7019a5ff21fc052821e44fe7b2517fb2a7e50ce1" translate="yes" xml:space="preserve">
          <source>When this char sequence starts with and ends with the given &lt;a href=&quot;../remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence)/delimiter&quot;&gt;delimiter&lt;/a&gt;, returns a new char sequence having this &lt;a href=&quot;../remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence)/delimiter&quot;&gt;delimiter&lt;/a&gt; removed both from the start and end. Otherwise returns a new char sequence with the same characters.</source>
          <target state="translated">このcharシーケンスが指定さ&lt;a href=&quot;../remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence)/delimiter&quot;&gt;れた区切り文字&lt;/a&gt;で始まり、終わる場合、この&lt;a href=&quot;../remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence)/delimiter&quot;&gt;区切り文字&lt;/a&gt;が開始と終了の両方から削除された新しいcharシーケンスを返します。それ以外の場合は、同じ文字の新しいcharシーケンスを返します。</target>
        </trans-unit>
        <trans-unit id="f0f3cdbdc4358626eb141b88edd210afb71fcf1c" translate="yes" xml:space="preserve">
          <source>When this char sequence starts with and ends with the given &lt;a href=&quot;remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fdelimiter&quot;&gt;delimiter&lt;/a&gt;, returns a new char sequence having this &lt;a href=&quot;remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fdelimiter&quot;&gt;delimiter&lt;/a&gt; removed both from the start and end. Otherwise returns a new char sequence with the same characters.</source>
          <target state="translated">この文字シーケンスが指定さ&lt;a href=&quot;remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fdelimiter&quot;&gt;れた区切り文字&lt;/a&gt;で開始および終了する場合、この&lt;a href=&quot;remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fdelimiter&quot;&gt;区切り文字を&lt;/a&gt;開始と終了の両方から削除した新しい文字シーケンスを返します。それ以外の場合は、同じ文字を含む新しい文字シーケンスを返します。</target>
        </trans-unit>
        <trans-unit id="1343302e14e8f4c4b12b4a77e8795e48eee2bf82" translate="yes" xml:space="preserve">
          <source>When this char sequence starts with and ends with the given &lt;a href=&quot;remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence)/delimiter&quot;&gt;delimiter&lt;/a&gt;, returns a new char sequence having this &lt;a href=&quot;remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence)/delimiter&quot;&gt;delimiter&lt;/a&gt; removed both from the start and end. Otherwise returns a new char sequence with the same characters.</source>
          <target state="translated">このcharシーケンスが指定さ&lt;a href=&quot;remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence)/delimiter&quot;&gt;れた区切り文字&lt;/a&gt;で始まり、終わる場合、この&lt;a href=&quot;remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence)/delimiter&quot;&gt;区切り文字&lt;/a&gt;が開始と終了の両方から削除された新しいcharシーケンスを返します。それ以外の場合は、同じ文字の新しいcharシーケンスを返します。</target>
        </trans-unit>
        <trans-unit id="451a99a6d4be3b4584fd97e74744059ae797634b" translate="yes" xml:space="preserve">
          <source>When this char sequence starts with the given &lt;a href=&quot;../../kotlin.text/remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fprefix&quot;&gt;prefix&lt;/a&gt; and ends with the given &lt;a href=&quot;../../kotlin.text/remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fsuffix&quot;&gt;suffix&lt;/a&gt;, returns a new char sequence having both the given &lt;a href=&quot;../../kotlin.text/remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fprefix&quot;&gt;prefix&lt;/a&gt; and &lt;a href=&quot;../../kotlin.text/remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fsuffix&quot;&gt;suffix&lt;/a&gt; removed. Otherwise returns a new char sequence with the same characters.</source>
          <target state="translated">この文字シーケンスが指定された&lt;a href=&quot;../../kotlin.text/remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fprefix&quot;&gt;接頭辞&lt;/a&gt;で始まり、指定された&lt;a href=&quot;../../kotlin.text/remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fsuffix&quot;&gt;接尾&lt;/a&gt;辞で終わる場合、指定された&lt;a href=&quot;../../kotlin.text/remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fprefix&quot;&gt;接頭辞&lt;/a&gt;と&lt;a href=&quot;../../kotlin.text/remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fsuffix&quot;&gt;接尾辞の&lt;/a&gt;両方が削除された新しい文字シーケンスを返します。それ以外の場合は、同じ文字を含む新しい文字シーケンスを返します。</target>
        </trans-unit>
        <trans-unit id="21ec09c18e0e164102ac5fa7a001d480731fe38a" translate="yes" xml:space="preserve">
          <source>When this char sequence starts with the given &lt;a href=&quot;../../kotlin.text/remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence)/prefix&quot;&gt;prefix&lt;/a&gt; and ends with the given &lt;a href=&quot;../../kotlin.text/remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence)/suffix&quot;&gt;suffix&lt;/a&gt;, returns a new char sequence having both the given &lt;a href=&quot;../../kotlin.text/remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence)/prefix&quot;&gt;prefix&lt;/a&gt; and &lt;a href=&quot;../../kotlin.text/remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence)/suffix&quot;&gt;suffix&lt;/a&gt; removed. Otherwise returns a new char sequence with the same characters.</source>
          <target state="translated">このcharシーケンスが指定された&lt;a href=&quot;../../kotlin.text/remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence)/prefix&quot;&gt;プレフィックス&lt;/a&gt;で始まり、指定された&lt;a href=&quot;../../kotlin.text/remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence)/suffix&quot;&gt;サフィックス&lt;/a&gt;で終わる場合、指定された&lt;a href=&quot;../../kotlin.text/remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence)/prefix&quot;&gt;プレフィックス&lt;/a&gt;と&lt;a href=&quot;../../kotlin.text/remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence)/suffix&quot;&gt;サフィックスの&lt;/a&gt;両方が削除された新しいcharシーケンスを返します。それ以外の場合は、同じ文字の新しいcharシーケンスを返します。</target>
        </trans-unit>
        <trans-unit id="474027059649f995528fdc9848631cfc13badca6" translate="yes" xml:space="preserve">
          <source>When this char sequence starts with the given &lt;a href=&quot;../remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fprefix&quot;&gt;prefix&lt;/a&gt; and ends with the given &lt;a href=&quot;../remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fsuffix&quot;&gt;suffix&lt;/a&gt;, returns a new char sequence having both the given &lt;a href=&quot;../remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fprefix&quot;&gt;prefix&lt;/a&gt; and &lt;a href=&quot;../remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fsuffix&quot;&gt;suffix&lt;/a&gt; removed. Otherwise returns a new char sequence with the same characters.</source>
          <target state="translated">この文字シーケンスが指定された&lt;a href=&quot;../remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fprefix&quot;&gt;接頭辞&lt;/a&gt;で始まり、指定された&lt;a href=&quot;../remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fsuffix&quot;&gt;接尾&lt;/a&gt;辞で終わる場合、指定された&lt;a href=&quot;../remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fprefix&quot;&gt;接頭辞&lt;/a&gt;と&lt;a href=&quot;../remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fsuffix&quot;&gt;接尾辞の&lt;/a&gt;両方が削除された新しい文字シーケンスを返します。それ以外の場合は、同じ文字を含む新しい文字シーケンスを返します。</target>
        </trans-unit>
        <trans-unit id="e1059589b0f168a1d76360357b34244200d2d5f4" translate="yes" xml:space="preserve">
          <source>When this char sequence starts with the given &lt;a href=&quot;../remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence)/prefix&quot;&gt;prefix&lt;/a&gt; and ends with the given &lt;a href=&quot;../remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence)/suffix&quot;&gt;suffix&lt;/a&gt;, returns a new char sequence having both the given &lt;a href=&quot;../remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence)/prefix&quot;&gt;prefix&lt;/a&gt; and &lt;a href=&quot;../remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence)/suffix&quot;&gt;suffix&lt;/a&gt; removed. Otherwise returns a new char sequence with the same characters.</source>
          <target state="translated">このcharシーケンスが指定された&lt;a href=&quot;../remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence)/prefix&quot;&gt;プレフィックス&lt;/a&gt;で始まり、指定された&lt;a href=&quot;../remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence)/suffix&quot;&gt;サフィックス&lt;/a&gt;で終わる場合、指定された&lt;a href=&quot;../remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence)/prefix&quot;&gt;プレフィックス&lt;/a&gt;と&lt;a href=&quot;../remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence)/suffix&quot;&gt;サフィックスの&lt;/a&gt;両方が削除された新しいcharシーケンスを返します。それ以外の場合は、同じ文字の新しいcharシーケンスを返します。</target>
        </trans-unit>
        <trans-unit id="b4f20b674cd62de8c48c773a81ba6fdddb62b434" translate="yes" xml:space="preserve">
          <source>When this char sequence starts with the given &lt;a href=&quot;remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fprefix&quot;&gt;prefix&lt;/a&gt; and ends with the given &lt;a href=&quot;remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fsuffix&quot;&gt;suffix&lt;/a&gt;, returns a new char sequence having both the given &lt;a href=&quot;remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fprefix&quot;&gt;prefix&lt;/a&gt; and &lt;a href=&quot;remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fsuffix&quot;&gt;suffix&lt;/a&gt; removed. Otherwise returns a new char sequence with the same characters.</source>
          <target state="translated">この文字シーケンスが指定された&lt;a href=&quot;remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fprefix&quot;&gt;接頭辞&lt;/a&gt;で始まり、指定された&lt;a href=&quot;remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fsuffix&quot;&gt;接尾&lt;/a&gt;辞で終わる場合、指定された&lt;a href=&quot;remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fprefix&quot;&gt;接頭辞&lt;/a&gt;と&lt;a href=&quot;remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fsuffix&quot;&gt;接尾辞の&lt;/a&gt;両方が削除された新しい文字シーケンスを返します。それ以外の場合は、同じ文字を含む新しい文字シーケンスを返します。</target>
        </trans-unit>
        <trans-unit id="cdb86094485044abedbde00e051a13f9d6e30f2e" translate="yes" xml:space="preserve">
          <source>When this char sequence starts with the given &lt;a href=&quot;remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence)/prefix&quot;&gt;prefix&lt;/a&gt; and ends with the given &lt;a href=&quot;remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence)/suffix&quot;&gt;suffix&lt;/a&gt;, returns a new char sequence having both the given &lt;a href=&quot;remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence)/prefix&quot;&gt;prefix&lt;/a&gt; and &lt;a href=&quot;remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence)/suffix&quot;&gt;suffix&lt;/a&gt; removed. Otherwise returns a new char sequence with the same characters.</source>
          <target state="translated">このcharシーケンスが指定された&lt;a href=&quot;remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence)/prefix&quot;&gt;プレフィックス&lt;/a&gt;で始まり、指定された&lt;a href=&quot;remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence)/suffix&quot;&gt;サフィックス&lt;/a&gt;で終わる場合、指定された&lt;a href=&quot;remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence)/prefix&quot;&gt;プレフィックス&lt;/a&gt;と&lt;a href=&quot;remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence)/suffix&quot;&gt;サフィックスの&lt;/a&gt;両方が削除された新しいcharシーケンスを返します。それ以外の場合は、同じ文字の新しいcharシーケンスを返します。</target>
        </trans-unit>
        <trans-unit id="81b6ffb12763bc2138c97cf448035b6d9b90a8a2" translate="yes" xml:space="preserve">
          <source>When this map already has an implicit default value provided with a former call to &lt;a href=&quot;with-default&quot;&gt;withDefault&lt;/a&gt;, it is being replaced by this call.</source>
          <target state="translated">このマップに、以前の&lt;a href=&quot;with-default&quot;&gt;withDefaultの&lt;/a&gt;呼び出しで提供された暗黙のデフォルト値がすでにある場合、この呼び出しに置き換えられます。</target>
        </trans-unit>
        <trans-unit id="4cb6af1ae576c542ddecdff3ea4125d59a9ee8e7" translate="yes" xml:space="preserve">
          <source>When to use</source>
          <target state="translated">使用する場合</target>
        </trans-unit>
        <trans-unit id="d17ab536e904cdcbae105ffd675f6f9b2f2e25d6" translate="yes" xml:space="preserve">
          <source>When transforming maps, you have two options: transform keys leaving values unchanged and vice versa. To apply a given transformation to keys, use &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/map-keys&quot;&gt;&lt;code&gt;mapKeys()&lt;/code&gt;&lt;/a&gt;; in turn, &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/map-values&quot;&gt;&lt;code&gt;mapValues()&lt;/code&gt;&lt;/a&gt; transforms values. Both functions use the transformations that take a map entry as an argument, so you can operate both its key and value.</source>
          <target state="translated">マップを変換する場合、2つのオプションがあります。値を変更せずにキーを変換すること、およびその逆です。特定の変換をキーに適用するには、&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/map-keys&quot;&gt; &lt;code&gt;mapKeys()&lt;/code&gt; を&lt;/a&gt;使用します。次に、&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/map-values&quot;&gt; &lt;code&gt;mapValues()&lt;/code&gt; &lt;/a&gt;は値を変換します。どちらの関数も、マップエントリを引数として使用する変換を使用するため、キーと値の両方を操作できます。</target>
        </trans-unit>
        <trans-unit id="8770eb3127ee3d553d5540c7c283a25cbf45081e" translate="yes" xml:space="preserve">
          <source>When two or more function overloads have otherwise the same parameter lists that differ only in the return type of a functional parameter, this annotation enables overload selection by the type of the value returned from the lambda function passed to this functional parameter.</source>
          <target state="translated">2 つ以上の関数オーバーロードが同じパラメータ・リストを持つ場合、関数パラメータの戻り値の型だけが異なる場合、このアノテーションを使用すると、この関数パラメータに渡されたラムダ関数から返される値の型でオーバーロードを選択できるようになります。</target>
        </trans-unit>
        <trans-unit id="3c33f3916421868809be7997c01c86f79f8dba67" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;https://github.com/gradle/kotlin-dsl&quot;&gt;Gradle Kotlin DSL&lt;/a&gt;, apply the Kotlin plugins using the &lt;code&gt;plugins { ... }&lt;/code&gt; block. If you apply them with &lt;code&gt;apply { plugin(...) }&lt;/code&gt; instead, you may encounter unresolved references to the extensions generated by Gradle Kotlin DSL. To resolve that, you can comment out the erroneous usages, run the Gradle task &lt;code&gt;kotlinDslAccessorsSnapshot&lt;/code&gt;, then uncomment the usages back and rerun the build or reimport the project into the IDE.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/gradle/kotlin-dsl&quot;&gt;Gradle Kotlin DSL&lt;/a&gt;を使用する場合は、 &lt;code&gt;plugins { ... }&lt;/code&gt; ブロックを使用してKotlinプラグインを適用します。代わりに &lt;code&gt;apply { plugin(...) }&lt;/code&gt; を使用して適用すると、Gradle Kotlin DSLによって生成された拡張機能への未解決の参照が発生する可能性があります。これを解決するには、誤った使用法をコメント化し、Gradleタスク &lt;code&gt;kotlinDslAccessorsSnapshot&lt;/code&gt; を実行してから、使用法のコメントを解除してビルドを再実行するか、プロジェクトをIDEに再インポートします。</target>
        </trans-unit>
        <trans-unit id="969e0f1eba169f04310601e387fff4607230faf4" translate="yes" xml:space="preserve">
          <source>When using AMD, we set the compiler option to use AMD. Once we do that, we can then reference any modules that we've defined as if they were regular AMD ones.</source>
          <target state="translated">AMD を使用する場合は、コンパイラオプションを AMD を使用するように設定します。これを行うと、定義したモジュールを通常のAMDモジュールのように参照することができます。</target>
        </trans-unit>
        <trans-unit id="53fe6e4bace8d3f91a163b97ab403728f060528c" translate="yes" xml:space="preserve">
          <source>When using DSLs, one might have come across the problem that too many functions can be called in the context. We can call methods of every available implicit receiver inside a lambda and therefore get an inconsistent result, like the tag &lt;code&gt;head&lt;/code&gt; inside another &lt;code&gt;head&lt;/code&gt;:</source>
          <target state="translated">DSLを使用する場合、コンテキスト内で呼び出される関数が多すぎるという問題に遭遇した可能性があります。私たちは、ラムダ内部のすべての可能な暗黙のレシーバのメソッドを呼び出すため、タグのように、一貫性のない結果を得ることができる &lt;code&gt;head&lt;/code&gt; 別の内部の &lt;code&gt;head&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="fac3c8199ff8ff114bd0a9de76148fcb9a8c3dbd" translate="yes" xml:space="preserve">
          <source>When using UMD or CommonJS, for example, your callsite could look like this:</source>
          <target state="translated">例えば、UMDやCommonJSを使用している場合、コールサイトは以下のようになります。</target>
        </trans-unit>
        <trans-unit id="7c361123f4c7cb5fe21faa0f281e0ce914b368c3" translate="yes" xml:space="preserve">
          <source>When using a generic type where you have star-projected one or more of its type parameters, you can:</source>
          <target state="translated">1つ以上の型パラメータをスタープロジェクションした汎用型を使用している場合、以下のようなことができます。</target>
        </trans-unit>
        <trans-unit id="7db42a19309e043040b1f118ec7a9ccf3b7c095b" translate="yes" xml:space="preserve">
          <source>When using an acronym as part of a declaration name, capitalize it if it consists of two letters (&lt;code&gt;IOStream&lt;/code&gt;); capitalize only the first letter if it is longer (&lt;code&gt;XmlFormatter&lt;/code&gt;, &lt;code&gt;HttpInputStream&lt;/code&gt;).</source>
          <target state="translated">宣言名の一部として頭字語を使用する場合、2つの文字（ &lt;code&gt;IOStream&lt;/code&gt; ）で構成されている場合はそれを大文字にします。長い場合は、最初の文字のみを大文字にします（ &lt;code&gt;XmlFormatter&lt;/code&gt; 、 &lt;code&gt;HttpInputStream&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="c3685d4fda3e975e4ad59872db610504afb8dcbd" translate="yes" xml:space="preserve">
          <source>When using if/else as an expression, the &lt;code&gt;else&lt;/code&gt; part is mandatory (but there can also be &lt;code&gt;else if&lt;/code&gt; parts). If the body that ends up being evaluated contains more than one line, it's the result of the last line that becomes the result of the &lt;code&gt;if&lt;/code&gt;/&lt;code&gt;else&lt;/code&gt;.</source>
          <target state="translated">if / elseを式として使用する場合、 &lt;code&gt;else&lt;/code&gt; 部分は必須です（ただし、 &lt;code&gt;else if&lt;/code&gt; 部分が存在する場合もあります）。最終的に評価される本文に複数の行が含まれている場合は、最後の行の結果が &lt;code&gt;if&lt;/code&gt; / &lt;code&gt;else&lt;/code&gt; の結果になります。</target>
        </trans-unit>
        <trans-unit id="c13d37c9e596a2177cf34971de8b2f9ef301b366" translate="yes" xml:space="preserve">
          <source>When using such &lt;code&gt;klib&lt;/code&gt; in your program, the library is linked automatically.</source>
          <target state="translated">プログラムでそのような &lt;code&gt;klib&lt;/code&gt; を使用すると、ライブラリは自動的にリンクされます。</target>
        </trans-unit>
        <trans-unit id="de988175b9de40e29ae018fb8ec5826b1dac85a5" translate="yes" xml:space="preserve">
          <source>When using the IR compiler, the &lt;code&gt;binaries.executable()&lt;/code&gt; instruction must be present in the &lt;code&gt;js&lt;/code&gt; target configuration block of your &lt;code&gt;build.gradle(.kts)&lt;/code&gt;. If this option is omitted, only Kotlin-internal library files are generated. These files can be used from other projects, but not run on their own.</source>
          <target state="translated">IRコンパイラを使用する場合、 &lt;code&gt;binaries.executable()&lt;/code&gt; 命令は、 &lt;code&gt;build.gradle(.kts)&lt;/code&gt; の &lt;code&gt;js&lt;/code&gt; ターゲット構成ブロックに存在する必要があります。このオプションを省略すると、Kotlin内部ライブラリファイルのみが生成されます。これらのファイルは他のプロジェクトから使用できますが、単独で実行することはできません。</target>
        </trans-unit>
        <trans-unit id="6eb8f752ff8f2ca50e7eef437c4f1437c5c24a5d" translate="yes" xml:space="preserve">
          <source>When using the command-line compiler, add the compiler option &lt;code&gt;-Xuse-ir&lt;/code&gt;.</source>
          <target state="translated">コマンドラインコンパイラを使用する場合は、コンパイラオプション &lt;code&gt;-Xuse-ir&lt;/code&gt; を追加します。</target>
        </trans-unit>
        <trans-unit id="23eb1fb1d8c12c86796891c59eb085c47d128eb5" translate="yes" xml:space="preserve">
          <source>When using the command-line compiler, switch to explicit API mode by adding the &lt;code&gt;-Xexplicit-api&lt;/code&gt; compiler option with the value &lt;code&gt;strict&lt;/code&gt; or &lt;code&gt;warning&lt;/code&gt;.</source>
          <target state="translated">コマンドラインコンパイラを使用する場合は、 &lt;code&gt;-Xexplicit-api&lt;/code&gt; コンパイラオプションに値 &lt;code&gt;strict&lt;/code&gt; または &lt;code&gt;warning&lt;/code&gt; を追加して、明示的なAPIモードに切り替えます。</target>
        </trans-unit>
        <trans-unit id="0acd4ad721ee61253910c4ba13a8be0c94889bbe" translate="yes" xml:space="preserve">
          <source>When we call a &lt;code&gt;vararg&lt;/code&gt;-function, we can pass arguments one-by-one, e.g. &lt;code&gt;asList(1, 2, 3)&lt;/code&gt;, or, if we already have an array and want to pass its contents to the function, we use the &lt;strong&gt;spread&lt;/strong&gt; operator (prefix the array with &lt;code&gt;*&lt;/code&gt;):</source>
          <target state="translated">&lt;code&gt;vararg&lt;/code&gt; -functionを呼び出すときに、引数を1つずつ渡すことができます &lt;code&gt;asList(1, 2, 3)&lt;/code&gt; 例：asList（1、2、3））。または、すでに配列があり、その内容を関数に渡したい場合は、&lt;strong&gt;スプレッド&lt;/strong&gt;を使用します。演算子（配列の前に &lt;code&gt;*&lt;/code&gt; を付けます）：</target>
        </trans-unit>
        <trans-unit id="79dc6e08abcd7d48d398a4ca21168dbf49b9bdf0" translate="yes" xml:space="preserve">
          <source>When we call methods on variables of platform types, Kotlin does not issue nullability errors at compile time, but the call may fail at runtime, because of a null-pointer exception or an assertion that Kotlin generates to prevent nulls from propagating:</source>
          <target state="translated">プラットフォーム型の変数に対してメソッドを呼び出す場合、Kotlinはコンパイル時にヌル可能性エラーを発行しませんが、実行時にヌルポインタ例外が発生したり、Kotlinがヌルの伝播を防ぐために生成するアサーションが発生したりして、呼び出しが失敗することがあります。</target>
        </trans-unit>
        <trans-unit id="ad1fe34b679899f7dee6782797e3bf361c2fe90a" translate="yes" xml:space="preserve">
          <source>When we declare many types in our supertype list, it may appear that we inherit more than one implementation of the same method. For example</source>
          <target state="translated">スーパータイプリストで多くの型を宣言すると、同じメソッドの複数の実装を継承しているように見えるかもしれません。例えば</target>
        </trans-unit>
        <trans-unit id="08c1783813dd9fc626a089b7cae223c9d065db16" translate="yes" xml:space="preserve">
          <source>When we have a named function declared like this:</source>
          <target state="translated">このように名前付き関数を宣言している場合</target>
        </trans-unit>
        <trans-unit id="61f9a57deb03c55b45ac7741559138e62485b782" translate="yes" xml:space="preserve">
          <source>When we have a nullable reference &lt;code&gt;b&lt;/code&gt;, we can say &quot;if &lt;code&gt;b&lt;/code&gt; is not null, use it, otherwise use some non-null value&quot;:</source>
          <target state="translated">null許容の参照 &lt;code&gt;b&lt;/code&gt; がある場合、「 &lt;code&gt;b&lt;/code&gt; がnullでない場合はそれを使用し、そうでない場合はnull以外の値を使用する」と言うことができます。</target>
        </trans-unit>
        <trans-unit id="fbc0820779d8db91f205b3ecbf7db0ccf41073a0" translate="yes" xml:space="preserve">
          <source>When we have a nullable reference &lt;code&gt;r&lt;/code&gt;, we can say &quot;if &lt;code&gt;r&lt;/code&gt; is not null, use it, otherwise use some non-null value &lt;code&gt;x&lt;/code&gt;&quot;:</source>
          <target state="translated">null可能な参照 &lt;code&gt;r&lt;/code&gt; がある場合、「 &lt;code&gt;r&lt;/code&gt; がnullでない場合はそれを使用し、それ以外の場合は非null値 &lt;code&gt;x&lt;/code&gt; を使用する」と言うことができます。</target>
        </trans-unit>
        <trans-unit id="5732d17582b0ef91e5bb01d205646ae68f3db2fc" translate="yes" xml:space="preserve">
          <source>When we pass a lambda to a dynamic call, all of its parameters by default have the type &lt;code&gt;dynamic&lt;/code&gt;:</source>
          <target state="translated">ラムダを動的呼び出しに渡すと、そのすべてのパラメーターのデフォルトの型は &lt;code&gt;dynamic&lt;/code&gt; になります。</target>
        </trans-unit>
        <trans-unit id="0be162a260a9be965f47e4e14ba8852bd8d1fa24" translate="yes" xml:space="preserve">
          <source>When we read from &lt;code&gt;p&lt;/code&gt; that delegates to an instance of &lt;code&gt;Delegate&lt;/code&gt;, the &lt;code&gt;getValue()&lt;/code&gt; function from &lt;code&gt;Delegate&lt;/code&gt; is called, so that its first parameter is the object we read &lt;code&gt;p&lt;/code&gt; from and the second parameter holds a description of &lt;code&gt;p&lt;/code&gt; itself (e.g. you can take its name). For example:</source>
          <target state="translated">私たちは、から読むと &lt;code&gt;p&lt;/code&gt; のインスタンスに委譲することを &lt;code&gt;Delegate&lt;/code&gt; 、 &lt;code&gt;getValue()&lt;/code&gt; から関数 &lt;code&gt;Delegate&lt;/code&gt; 、その最初のパラメータは、我々が読んオブジェクトであるように、と呼ばれ &lt;code&gt;p&lt;/code&gt; から、2番目のパラメータは、の説明を保持 &lt;code&gt;p&lt;/code&gt; 自体が（例えば、あなたが取ることができますその名前）。例えば：</target>
        </trans-unit>
        <trans-unit id="111d8dd13a5f3aef5861ae64c3f6c02ff4cb90bb" translate="yes" xml:space="preserve">
          <source>When working from IntelliJ IDEA, we can find the &lt;code&gt;run&lt;/code&gt; action in the Gradle tool window.</source>
          <target state="translated">IntelliJ IDEAから作業している場合、 &lt;code&gt;run&lt;/code&gt; アクションはGradleツールウィンドウにあります。</target>
        </trans-unit>
        <trans-unit id="ad6c6017c96852fa45cd533d083255cb214a9f4c" translate="yes" xml:space="preserve">
          <source>When wrapping chained calls, put the &lt;code&gt;.&lt;/code&gt; character or the &lt;code&gt;?.&lt;/code&gt; operator on the next line, with a single indent:</source>
          <target state="translated">チェーンされた呼び出しをラップするときは、 &lt;code&gt;.&lt;/code&gt; 文字または &lt;code&gt;?.&lt;/code&gt; 次の行の演算子、単一のインデント：</target>
        </trans-unit>
        <trans-unit id="9f05d7113cc0860bca9dd1b2c8b1f2efc8346629" translate="yes" xml:space="preserve">
          <source>When writing Kotlin code, an object may need to be converted from a Kotlin type to the equivalent Swift/Objective-C type (or vice versa). In this case a plain old Kotlin cast can be used, e.g.</source>
          <target state="translated">Kotlinのコードを書くとき、オブジェクトをKotlinの型から同等のSwift/Objective-Cの型に変換する必要があるかもしれません(またはその逆)。この場合、古いKotlinのキャストを使うことができます。</target>
        </trans-unit>
        <trans-unit id="9cafd8bf742afb2fbc35d3c6537af8b35836e156" translate="yes" xml:space="preserve">
          <source>When writing libraries, it's recommended to follow an additional set of rules to ensure API stability:</source>
          <target state="translated">ライブラリを書く際には、APIの安定性を確保するために、追加のルールに従うことをお勧めします。</target>
        </trans-unit>
        <trans-unit id="d741918b948509f4aba6408fd1ef9e8a1136bd6e" translate="yes" xml:space="preserve">
          <source>When writing native applications, oftentimes we need to access certain functionality that is not included in the Kotlin standard library, such as making HTTP requests, reading and writing from disk, etc.</source>
          <target state="translated">ネイティブアプリケーションを書くとき、HTTPリクエストの作成、ディスクからの読み書きなど、Kotlin標準ライブラリに含まれていない機能にアクセスする必要があることがよくあります。</target>
        </trans-unit>
        <trans-unit id="463d09586d01fae3ba7cf55cbbc35d4b7f20011b" translate="yes" xml:space="preserve">
          <source>When you &lt;a href=&quot;mpp-create-lib&quot;&gt;create a multiplatform project&lt;/a&gt;, the Project Wizard automatically applies the &lt;code&gt;kotlin-multiplatform&lt;/code&gt; Gradle plugin in the file &lt;code&gt;build.gradle&lt;/code&gt;(&lt;code&gt;.kts&lt;/code&gt;).</source>
          <target state="translated">&lt;a href=&quot;mpp-create-lib&quot;&gt;マルチプラットフォームプロジェクト&lt;/a&gt;を作成すると、プロジェクトウィザードは自動的に &lt;code&gt;kotlin-multiplatform&lt;/code&gt; Gradleプラグインをファイル &lt;code&gt;build.gradle&lt;/code&gt; （ &lt;code&gt;.kts&lt;/code&gt; ）に適用します。</target>
        </trans-unit>
        <trans-unit id="f3156a4be9cfb99131296400d8e473f56e52183c" translate="yes" xml:space="preserve">
          <source>When you are ready, verify the task with the &lt;strong&gt;Check&lt;/strong&gt; icon at the top of &lt;strong&gt;Task Description&lt;/strong&gt; panel. If you passed, there will be the &lt;strong&gt;Congratulations!&lt;/strong&gt; message:</source>
          <target state="translated">準備ができたら、&lt;strong&gt;タスクの説明&lt;/strong&gt;パネルの上部にある&lt;strong&gt;チェック&lt;/strong&gt;アイコンでタスクを&lt;strong&gt;確認し&lt;/strong&gt;ます。合格したら、&lt;strong&gt;おめでとうございます！&lt;/strong&gt;メッセージ：&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="598dab40b3272c1fb9a453390cd6e6de1808ea5d" translate="yes" xml:space="preserve">
          <source>When you call a member function on &lt;code&gt;this&lt;/code&gt;, you can skip the &lt;code&gt;this.&lt;/code&gt; part. If you have a non-member function with the same name, use this with caution, because in some cases it can be called instead:</source>
          <target state="translated">あなたは上のメンバ関数を呼び出すと &lt;code&gt;this&lt;/code&gt; 、あなたはスキップすることができ &lt;code&gt;this.&lt;/code&gt; 部。同じ名前の非メンバー関数がある場合は、代わりに呼び出すことができる場合があるため、これは注意して使用してください。</target>
        </trans-unit>
        <trans-unit id="bd4f91db759426c5c027f930c965bc523e90edeb" translate="yes" xml:space="preserve">
          <source>When you call this function, the compiler will know that the execution doesn't continue beyond the call:</source>
          <target state="translated">この関数を呼び出すと、コンパイラは呼び出しを超えて実行が続かないことを知ることになります。</target>
        </trans-unit>
        <trans-unit id="ebc718bb513c3e899345e0a1f6bade26496caf51" translate="yes" xml:space="preserve">
          <source>When you choose the JavaScript target, any Kotlin code that is part of the project as well as the standard library that ships with Kotlin is transpiled to JavaScript. However, this excludes the JDK and any JVM or Java framework or library used. Any file that is not Kotlin will be ignored during compilation.</source>
          <target state="translated">JavaScriptターゲットを選択すると、プロジェクトの一部であるKotlinのコードとKotlinに同梱されている標準ライブラリはすべてJavaScriptにトランスパイルされます。ただし、これには JDK や使用されている JVM や Java フレームワーク、ライブラリは含まれません。Kotlin以外のファイルはコンパイル時に無視されます。</target>
        </trans-unit>
        <trans-unit id="61cb3b5bb55f1ec33f90df7914d7d8c5178a623a" translate="yes" xml:space="preserve">
          <source>When you compile a multiplatform project for a specific platform, the code for both the common and platform-specific parts is generated.</source>
          <target state="translated">特定のプラットフォーム向けにマルチプラットフォーム プロジェクトをコンパイルすると、共通部分とプラットフォーム固有の部分の両方のコードが生成されます。</target>
        </trans-unit>
        <trans-unit id="a4955e4afeb340ef9f82c25ba0af627acbecccfb" translate="yes" xml:space="preserve">
          <source>When you create a multiplatform project, targets are added to the &lt;code&gt;kotlin&lt;/code&gt; block in the file &lt;code&gt;build.gradle&lt;/code&gt; (&lt;code&gt;build.gradle.kts&lt;/code&gt;).</source>
          <target state="translated">マルチプラットフォームプロジェクトを作成すると、ターゲットはファイル &lt;code&gt;build.gradle&lt;/code&gt; （ &lt;code&gt;build.gradle.kts&lt;/code&gt; ）の &lt;code&gt;kotlin&lt;/code&gt; ブロックに追加されます。</target>
        </trans-unit>
        <trans-unit id="487f53e65f3e40a392960d7ffe8fb70d789db81a" translate="yes" xml:space="preserve">
          <source>When you create a progression implicitly by iterating a range, this progression's &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;last&lt;/code&gt; elements are the range's endpoints, and the &lt;code&gt;step&lt;/code&gt; is 1.</source>
          <target state="translated">範囲を反復して暗黙的に進行を作成する場合、この進行の &lt;code&gt;first&lt;/code&gt; と &lt;code&gt;last&lt;/code&gt; 要素は範囲のエンドポイントであり、 &lt;code&gt;step&lt;/code&gt; は1です。</target>
        </trans-unit>
        <trans-unit id="51bafee0f48839d4b74895eeb5d22b3bc95f6844" translate="yes" xml:space="preserve">
          <source>When you create own implementations of collection interfaces, you must implement their member functions. To make the creation of new implementations easier, use the skeletal implementations of collection interfaces from the standard library: &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-abstract-collection/index&quot;&gt;&lt;code&gt;AbstractCollection&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-abstract-list/index&quot;&gt;&lt;code&gt;AbstractList&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-abstract-set/index&quot;&gt;&lt;code&gt;AbstractSet&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-abstract-map/index&quot;&gt;&lt;code&gt;AbstractMap&lt;/code&gt;&lt;/a&gt;, and their mutable counterparts.</source>
          <target state="translated">コレクションインターフェイスの独自の実装を作成する場合、それらのメンバー関数を実装する必要があります。：新しい実装の作成を簡単にするために、標準ライブラリからコレクションインタフェースの骨格実装を使用&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-abstract-collection/index&quot;&gt; &lt;code&gt;AbstractCollection&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-abstract-list/index&quot;&gt; &lt;code&gt;AbstractList&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-abstract-set/index&quot;&gt; &lt;code&gt;AbstractSet&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-abstract-map/index&quot;&gt; &lt;code&gt;AbstractMap&lt;/code&gt; の&lt;/a&gt;、そしてその可変対応。</target>
        </trans-unit>
        <trans-unit id="de5ca0060f568734c25c44dc064e42505647a415" translate="yes" xml:space="preserve">
          <source>When you create your own implementations of collection interfaces, you must implement their member functions. To make the creation of new implementations easier, use the skeletal implementations of collection interfaces from the standard library: &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-abstract-collection/index&quot;&gt;&lt;code&gt;AbstractCollection&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-abstract-list/index&quot;&gt;&lt;code&gt;AbstractList&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-abstract-set/index&quot;&gt;&lt;code&gt;AbstractSet&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-abstract-map/index&quot;&gt;&lt;code&gt;AbstractMap&lt;/code&gt;&lt;/a&gt;, and their mutable counterparts.</source>
          <target state="translated">コレクションインターフェイスの独自の実装を作成するときは、それらのメンバー関数を実装する必要があります。新しい実装の作成を容易にするために、標準ライブラリのコレクションインターフェイスの骨格実装を使用します：&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-abstract-collection/index&quot;&gt; &lt;code&gt;AbstractCollection&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-abstract-list/index&quot;&gt; &lt;code&gt;AbstractList&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-abstract-set/index&quot;&gt; &lt;code&gt;AbstractSet&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-abstract-map/index&quot;&gt; &lt;code&gt;AbstractMap&lt;/code&gt; &lt;/a&gt;、およびそれらの可変の対応物。</target>
        </trans-unit>
        <trans-unit id="dc3c8353ca1e574cdd5fef24454fb4fda2fc3277" translate="yes" xml:space="preserve">
          <source>When you have a &lt;code&gt;List&lt;/code&gt; of &lt;code&gt;Pair&lt;/code&gt;s, you can do the reverse transformation &amp;ndash; &lt;em&gt;unzipping&lt;/em&gt; &amp;ndash; that builds two lists from these pairs:</source>
          <target state="translated">あなたが持っている場合は &lt;code&gt;List&lt;/code&gt; の &lt;code&gt;Pair&lt;/code&gt; - Sを、あなたは逆変換を行うことができます&lt;em&gt;解凍&lt;/em&gt; -これらのペアから二つのリストを作成します：</target>
        </trans-unit>
        <trans-unit id="5c27d02fe0802eb2c5dc736c355913900c0370a9" translate="yes" xml:space="preserve">
          <source>When you have a variable or parameter of function type (sometimes called a &lt;em&gt;function reference&lt;/em&gt;), you can call it as if it were an ordinary function, and that will cause the referenced function to be called:</source>
          <target state="translated">関数タイプの変数またはパラメーター（&lt;em&gt;関数参照&lt;/em&gt;と呼ばれることもあり&lt;em&gt;ます&lt;/em&gt;）がある場合、それを通常の関数のように呼び出すことができます。これにより、参照される関数が呼び出されます。</target>
        </trans-unit>
        <trans-unit id="e1aaa92f5ddb308d5297a444696d8b7457b69a72" translate="yes" xml:space="preserve">
          <source>When you have finished creating your course, it's a good idea to view your course from a learner's perspective and test it. Right-click on the course view and go to &lt;strong&gt;Course Creator -&amp;gt; Create Course Preview&lt;/strong&gt; to open your course in learner mode:</source>
          <target state="translated">コースの作成が終了したら、学習者の視点からコースを表示してテストすることをお勧めします。コースビューを右クリックし、&lt;strong&gt;コースクリエーター-&amp;gt;コースプレビューの作成に移動&lt;/strong&gt;して、コースを学習者モードで開きます。</target>
        </trans-unit>
        <trans-unit id="a3250cc79c522d1ac623227bb111869e351b8f95" translate="yes" xml:space="preserve">
          <source>When you run this code, you'll see that the &lt;code&gt;filter()&lt;/code&gt; and &lt;code&gt;map()&lt;/code&gt; functions are executed in the same order as they appear in the code. First, you see &lt;code&gt;filter:&lt;/code&gt; for all elements, then &lt;code&gt;length:&lt;/code&gt; for the elements left after filtering, and then the output of the two last lines. This is how the list processing goes:</source>
          <target state="translated">このコードを実行すると、 &lt;code&gt;filter()&lt;/code&gt; &lt;code&gt;map()&lt;/code&gt; 関数とmap（）関数がコードに表示されているのと同じ順序で実行されることがわかります。最初に、 &lt;code&gt;filter:&lt;/code&gt; すべての要素、次に &lt;code&gt;length:&lt;/code&gt; フィルタリング後に残った要素、そして最後の2行の出力が表示されます。これがリスト処理の方法です。</target>
        </trans-unit>
        <trans-unit id="05ad4ed8cb6fd5863366c2a4f1abcdd6e5010b48" translate="yes" xml:space="preserve">
          <source>When you see &lt;code&gt;also&lt;/code&gt; in the code, you can read it as &amp;ldquo;&lt;em&gt;and also do the following with the object.&lt;/em&gt;&amp;rdquo;</source>
          <target state="translated">あなたが見たとき &lt;code&gt;also&lt;/code&gt; コードで、あなたは「としてそれを読むことができます&lt;em&gt;し、また、オブジェクトと次の操作を行います。&lt;/em&gt;」</target>
        </trans-unit>
        <trans-unit id="6928284bef91c96791612dd21e00cae5d64a5053" translate="yes" xml:space="preserve">
          <source>When you see &lt;code&gt;also&lt;/code&gt; in the code, you can read it as &amp;ldquo;&lt;em&gt;and also do the following&lt;/em&gt;&amp;rdquo;.</source>
          <target state="translated">あなたが見たとき &lt;code&gt;also&lt;/code&gt; コードで、あなたはとしてそれを読む「ことができ&lt;em&gt;、また、次の操作を行います&lt;/em&gt;」。</target>
        </trans-unit>
        <trans-unit id="8d24e43a2e1296ae8492ad2425aad4e306037e84" translate="yes" xml:space="preserve">
          <source>When you switch to Kotlin, your xml layout files don't change at all. For instance, you use &lt;code&gt;variable&lt;/code&gt; within &lt;code&gt;data&lt;/code&gt; to describe a variable that may be used within the layout. You can declare a variable of a Kotlin type:</source>
          <target state="translated">Kotlinに切り替えても、XMLレイアウトファイルはまったく変更されません。たとえば、あなたが使う &lt;code&gt;variable&lt;/code&gt; 内の &lt;code&gt;data&lt;/code&gt; レイアウト内で使用できる変数を記述すること。Kotlin型の変数を宣言できます。</target>
        </trans-unit>
        <trans-unit id="1239262e94d3c7df345c600c729ad2ad431b78a5" translate="yes" xml:space="preserve">
          <source>When you take an interface or an open class as a parameter, you generally don't know the real type of the parameter at runtime, since it could be an instance of a subclass or of any class that implements the interface. It is possible to check what the exact type is, but like in Python, you should generally avoid it and instead design your class hierarchy such that you can do what you need by proper overriding of functions or properties.</source>
          <target state="translated">インターフェースやオープンクラスをパラメータとして受け取る場合、一般的には実行時にパラメータの本当の型はわかりません。正確な型を確認することは可能ですが、Pythonのように、一般的にはそれを避け、代わりに関数やプロパティを適切にオーバーライドすることで必要なことができるようにクラス階層を設計するべきです。</target>
        </trans-unit>
        <trans-unit id="08daa6c22199d25d4c67e8e2145164a79b9c18ed" translate="yes" xml:space="preserve">
          <source>When you use an API in the code intended for third-party use (a library), you can propagate its opt-in requirement to your API as well. To do this, annotate your declaration with the &lt;a href=&quot;#opt-in-requirement-annotations&quot;&gt;&lt;em&gt;opt-in requirement annotation&lt;/em&gt;&lt;/a&gt; of the API used in its body. This enables you to use the API elements marked with this annotation.</source>
          <target state="translated">サードパーティの使用を目的としたコード（ライブラリ）でAPIを使用する場合、そのオプトイン要件をAPIに伝達することもできます。これを行うには、本体で使用されているAPIの&lt;a href=&quot;#opt-in-requirement-annotations&quot;&gt;&lt;em&gt;オプトイン要件アノテーション&lt;/em&gt;&lt;/a&gt;を使用して宣言にアノテーションを付けます。これにより、このアノテーションでマークされたAPI要素を使用できます。</target>
        </trans-unit>
        <trans-unit id="9a7fe00cf3644a358da554d74666746417284178" translate="yes" xml:space="preserve">
          <source>When you use an arithmetic operator on two integers of different types, the result is &quot;upgraded&quot; to the widest type. Note that the result might still overflow.</source>
          <target state="translated">異なる型の 2 つの整数に対して算術演算子を使用すると、結果は最も広い型に「アップグレード」されます。結果がオーバーフローする可能性があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="3c62a163cbef716d256d43a2d19d876bb12a78c5" translate="yes" xml:space="preserve">
          <source>When you use an experimental API in the code intended for third-party use (a library), you can mark your API as experimental as well. To do this, annotate your declaration with the &lt;em&gt;experimental marker annotation&lt;/em&gt; of the API used in its body. This enables you to use the API elements annotated with this marker.</source>
          <target state="translated">サードパーティが使用することを目的としたコード（ライブラリ）で試験的なAPIを使用する場合、APIを試験的なものとしてマークすることもできます。これを行うには、本文で使用されているAPIの&lt;em&gt;実験的なマーカーアノテーション&lt;/em&gt;で宣言に注釈を付けます。これにより、このマーカーで注釈が付けられたAPIエレメントを使用できるようになります。</target>
        </trans-unit>
        <trans-unit id="06b65a21854b89868579d67b03180df54f3544a9" translate="yes" xml:space="preserve">
          <source>When you use named arguments in a function call, you can freely change the order they are listed in, and if you want to use their default values you can just leave them out altogether.</source>
          <target state="translated">関数呼び出しで名前付き引数を使用する場合、引数の並び順を自由に変更することができます。</target>
        </trans-unit>
        <trans-unit id="48d4e3a5ba4e31277cb9f0e61d2e54f709bf8961" translate="yes" xml:space="preserve">
          <source>When you're annotating a property or a primary constructor parameter, there are multiple Java elements which are generated from the corresponding Kotlin element, and therefore multiple possible locations for the annotation in the generated Java bytecode. To specify how exactly the annotation should be generated, use the following syntax:</source>
          <target state="translated">プロパティやプライマリ・コンストラクタのパラメータにアノテーションを付ける場合、対応するKotlin要素から生成されるJava要素が複数存在し、生成されるJavaバイトコードの中にアノテーションを付ける場所が複数存在します。アノテーションを正確に生成する方法を指定するには、以下の構文を使用します。</target>
        </trans-unit>
        <trans-unit id="b61884cef7d3f26b08581a78b91851698ab0fd2b" translate="yes" xml:space="preserve">
          <source>Whenever &lt;code&gt;jvmMain&lt;/code&gt; is compiled for a certain target, &lt;code&gt;commonMain&lt;/code&gt; takes part in that compilation as well and is also compiled into the same target binary form, such as JVM class files.</source>
          <target state="translated">&lt;code&gt;jvmMain&lt;/code&gt; が特定のターゲット用にコンパイルされるたびに、 &lt;code&gt;commonMain&lt;/code&gt; もそのコンパイルに参加し、JVMクラスファイルなどの同じターゲットバイナリ形式にもコンパイルされます。</target>
        </trans-unit>
        <trans-unit id="89ad1e4f32412313aa6f0bd650dfc39dcb173e7f" translate="yes" xml:space="preserve">
          <source>Whenever it is invoked on the same object more than once, the &lt;code&gt;hashCode&lt;/code&gt; method must consistently return the same integer, provided no information used in &lt;code&gt;equals&lt;/code&gt; comparisons on the object is modified.</source>
          <target state="translated">同じオブジェクトで複数回呼び出される場合は常に、オブジェクトの &lt;code&gt;equals&lt;/code&gt; 比較で使用される情報が変更されていなければ、 &lt;code&gt;hashCode&lt;/code&gt; メソッドは常に同じ整数を返す必要があります。</target>
        </trans-unit>
        <trans-unit id="55d78075233bceac802e1984993c3d3b3088601f" translate="yes" xml:space="preserve">
          <source>Whenever you create an instance of this class, you must specify an actual type in place of &lt;code&gt;T&lt;/code&gt;, unless the compiler can infer it from the constructor parameters: &lt;code&gt;TreeNode(&quot;foo&quot;)&lt;/code&gt; or &lt;code&gt;TreeNode&amp;lt;String&amp;gt;(null)&lt;/code&gt;. Every use of this instance will act as if it were an instance of a class that looks like this:</source>
          <target state="translated">このクラスのインスタンスを作成するときは常に、コンパイラーがコンストラクターパラメーター &lt;code&gt;TreeNode(&quot;foo&quot;)&lt;/code&gt; または &lt;code&gt;TreeNode&amp;lt;String&amp;gt;(null)&lt;/code&gt; から推測できない限り、 &lt;code&gt;T&lt;/code&gt; の代わりに実際の型を指定する必要があります。このインスタンスを使用するたびに、次のようなクラスのインスタンスであるかのように動作します。</target>
        </trans-unit>
        <trans-unit id="8ca39f6f0f111844ff04d02c9f4bf0efee656845" translate="yes" xml:space="preserve">
          <source>Whenever you use an arithmetic operator on two integers of the same type (or when you use a unary operator like negation), &lt;em&gt;there is no automatic &quot;upgrading&quot; if the result doesn't fit in the type of the operands!&lt;/em&gt; Try this:</source>
          <target state="translated">同じ型の2つの整数に対して算術演算子を使用する場合（または否定のような単項演算子を使用する&lt;em&gt;場合）は、結果がオペランドの型に適合しない場合、自動「アップグレード」は行われません。&lt;/em&gt;これを試して：</target>
        </trans-unit>
        <trans-unit id="b65896c2c2c1091be4cf3076a04d4d7b1bc8f223" translate="yes" xml:space="preserve">
          <source>Whenever you want a variable that can only take on a limited number of values where the only feature of each value is that it's distinct from all the other values, you can create an &lt;em&gt;enum class&lt;/em&gt;:</source>
          <target state="translated">各値の唯一の機能が他のすべての値とは異なるという限られた数の値のみを取ることができる変数が必要な場合はいつでも、&lt;em&gt;列挙型クラスを&lt;/em&gt;作成できます。</target>
        </trans-unit>
        <trans-unit id="b72a1d211e3475b177a16c0ad833aad00f45de47" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;__TYPE__&lt;/code&gt; is one of the simple type names and &lt;code&gt;__CTYPE__&lt;/code&gt; is the related Objective-C type, e.g. &lt;code&gt;initWithChar(char)&lt;/code&gt;.</source>
          <target state="translated">ここで、 &lt;code&gt;__TYPE__&lt;/code&gt; は単純型名の1つであり、 &lt;code&gt;__CTYPE__&lt;/code&gt; は関連するObjective-C型 &lt;code&gt;initWithChar(char)&lt;/code&gt; 例：initWithChar（char））。</target>
        </trans-unit>
        <trans-unit id="279ee64e67a8a3e973e45233e8ce0a407cbaf608" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;declarationToKeep&lt;/code&gt; has the following syntax:</source>
          <target state="translated">ここで、 &lt;code&gt;declarationToKeep&lt;/code&gt; の構文は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="eb06827a60ce404697c981082d7a9ff58779079e" translate="yes" xml:space="preserve">
          <source>Where can I get an HD Kotlin logo?</source>
          <target state="translated">HDのKotlinのロゴはどこで手に入るの?</target>
        </trans-unit>
        <trans-unit id="00d532d7604042ff0388fc0d8b327eb21555113f" translate="yes" xml:space="preserve">
          <source>Where can I learn more about Kotlin?</source>
          <target state="translated">コトリンについて詳しく知りたいのですが?</target>
        </trans-unit>
        <trans-unit id="60dc3003b0157a1bb3a0084a1e562958004b1c24" translate="yes" xml:space="preserve">
          <source>Whether a main function should be called</source>
          <target state="translated">メイン関数を呼び出すかどうか</target>
        </trans-unit>
        <trans-unit id="350fceb3b43601161521c9570f080755bec5203a" translate="yes" xml:space="preserve">
          <source>Whether metadata file with binary descriptors should be generated</source>
          <target state="translated">バイナリ記述子を持つメタデータファイルを生成するかどうか</target>
        </trans-unit>
        <trans-unit id="b1689158ae06f88b863b7fd9b887d675c25f4bd4" translate="yes" xml:space="preserve">
          <source>Whether sourcemap file should be generated</source>
          <target state="translated">ソースマップファイルを生成するかどうか</target>
        </trans-unit>
        <trans-unit id="e52f46f155653a3c2a2e009ba12b0ccd1ff43ab6" translate="yes" xml:space="preserve">
          <source>Which prints:</source>
          <target state="translated">どの指紋だ</target>
        </trans-unit>
        <trans-unit id="c668af734b8bab593fb373580041499369e8214b" translate="yes" xml:space="preserve">
          <source>Which versions of JVM does Kotlin target?</source>
          <target state="translated">KotlinはどのバージョンのJVMをターゲットにしていますか?</target>
        </trans-unit>
        <trans-unit id="02402c88e9d606c5d9042e0b0c12d1739344aeb9" translate="yes" xml:space="preserve">
          <source>While Kotlin annotations look like Python decorators, they are far less flexible: they can generally only be used for metadata. They are pure data-containing classes, and do not contain any executable code. Some built-in annotations have an effect on the compilation process (such as &lt;code&gt;@JvmStatic&lt;/code&gt;), but custom annotations are only useful for providing metadata that can be inspected at runtime by the reflection system. We won't delve deeply into annotations here, but here is an example. The annotations on the annotation declaration itself specify what constructs the annotation may be applied to and whether it is available for runtime inspection.</source>
          <target state="translated">KotlinアノテーションはPythonデコレータのように見えますが、柔軟性ははるかに低く、一般にメタデータにのみ使用できます。これらは純粋なデータを含むクラスであり、実行可能コードは含まれていません。一部の組み込みアノテーションはコンパイルプロセスに影響を与えますが（ &lt;code&gt;@JvmStatic&lt;/code&gt; など）、カスタムアノテーションは、リフレクションシステムによって実行時に検査できるメタデータを提供する場合にのみ役立ちます。ここではアノテーションについて深く掘り下げることはしませんが、ここでは例を示します。アノテーション宣言自体のアノテーションは、アノテーションを適用できる構成と、ランタイム検査に使用できるかどうかを指定します。</target>
        </trans-unit>
        <trans-unit id="a68a67a970d91d390715c4a5723442211582200e" translate="yes" xml:space="preserve">
          <source>While Loops</source>
          <target state="translated">Whileループ</target>
        </trans-unit>
        <trans-unit id="c1b7c19248a78707f3905a80fc2242e3ecc22b20" translate="yes" xml:space="preserve">
          <source>While being different, conceptually, Flow &lt;em&gt;is&lt;/em&gt; a reactive stream and it is possible to convert it to the reactive (spec and TCK compliant) Publisher and vice versa. Such converters are provided by &lt;code&gt;kotlinx.coroutines&lt;/code&gt; out-of-the-box and can be found in corresponding reactive modules (&lt;code&gt;kotlinx-coroutines-reactive&lt;/code&gt; for Reactive Streams, &lt;code&gt;kotlinx-coroutines-reactor&lt;/code&gt; for Project Reactor and &lt;code&gt;kotlinx-coroutines-rx2&lt;/code&gt;/&lt;code&gt;kotlinx-coroutines-rx3&lt;/code&gt; for RxJava2/RxJava3). Integration modules include conversions from and to &lt;code&gt;Flow&lt;/code&gt;, integration with Reactor's &lt;code&gt;Context&lt;/code&gt; and suspension-friendly ways to work with various reactive entities.</source>
          <target state="translated">概念的に&lt;em&gt;は&lt;/em&gt;異なります&lt;em&gt;が&lt;/em&gt;、フロー&lt;em&gt;は&lt;/em&gt;リアクティブストリームであり、リアクティブ（仕様およびTCK準拠）パブリッシャーに変換したり、その逆を行うことができます。このようなコンバーターは、 &lt;code&gt;kotlinx.coroutines&lt;/code&gt; によって提供され、対応するリアクティブモジュール（ &lt;code&gt;kotlinx-coroutines-reactive&lt;/code&gt; Streamsの場合、 &lt;code&gt;kotlinx-coroutines-reactor&lt;/code&gt; for Project Reactor、および &lt;code&gt;kotlinx-coroutines-rx2&lt;/code&gt; / &lt;code&gt;kotlinx-coroutines-rx3&lt;/code&gt; -RxJava2 / RxJava3の場合はrx3）。統合モジュールには、 &lt;code&gt;Flow&lt;/code&gt; との間の変換、Reactorの &lt;code&gt;Context&lt;/code&gt; との統合、さまざまなリアクティブエンティティを操作するためのサスペンションに適した方法が含まれます。</target>
        </trans-unit>
        <trans-unit id="178ea4ef9776a99f280cbce3c37b6808c99bffb3" translate="yes" xml:space="preserve">
          <source>While compilation from the console seems to be easy and clear, it does not scale well for larger projects with hundreds of files and libraries. For real-world projects it is recommended to use a &lt;a href=&quot;using-gradle&quot;&gt;build system&lt;/a&gt; and &lt;a href=&quot;using-intellij-idea&quot;&gt;IDE&lt;/a&gt;.</source>
          <target state="translated">コンソールからのコンパイルは簡単で明確なように見えますが、数百のファイルとライブラリを含む大規模なプロジェクトには適切に拡張できません。実際のプロジェクトでは、&lt;a href=&quot;using-gradle&quot;&gt;ビルドシステム&lt;/a&gt;と&lt;a href=&quot;using-intellij-idea&quot;&gt;IDE&lt;/a&gt;を使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="405a10cf31f596bca1e965bfbd41f2ec04a34af9" translate="yes" xml:space="preserve">
          <source>While compilation from the console seems to be easy and clear, we should notice, that it does not scale well for bigger projects with hundreds of files and libraries. In addition to this, the command line approach does not explain to an IDE how to open such a project, where the sources are located, what dependencies are used, or how the dependencies are downloaded and so on.</source>
          <target state="translated">コンソールからのコンパイルは簡単で明確に見えますが、何百ものファイルやライブラリを持つ大規模なプロジェクトではうまくスケールできないことに気づくべきです。これに加えて、コマンドラインのアプローチでは、IDEに対して、どのようにプロジェクトを開くのか、ソースがどこにあるのか、どのような依存関係が使われているのか、どのように依存関係がダウンロードされているのか、などを説明していません。</target>
        </trans-unit>
        <trans-unit id="1e744f3d4d9082a8982116fd4e4676866618d662" translate="yes" xml:space="preserve">
          <source>While cross-platform compilation is possible, which means using one platform to compile for a different one, in this case we'll be targeting the same platform we're compiling on.</source>
          <target state="translated">クロスプラットフォームでのコンパイルは可能ですが、あるプラットフォームを使って別のプラットフォーム用にコンパイルすることを意味しますが、この場合はコンパイルするプラットフォームをターゲットにします。</target>
        </trans-unit>
        <trans-unit id="6ce105800554de67a92cb5eed4d6aabf562edfb9" translate="yes" xml:space="preserve">
          <source>While doing so was not useful in this particular example, one could get interesting effects by adding an unprojected parameter type &lt;code&gt;via: Bowl&amp;lt;T&amp;gt;&lt;/code&gt;, in which case the generic type parameter of &lt;code&gt;via&lt;/code&gt; would be forced to be &quot;in-between&quot; those of &lt;code&gt;from&lt;/code&gt; and &lt;code&gt;to&lt;/code&gt;.</source>
          <target state="translated">この特定の例ではそうすることは役に立ちませんでしたが、非投影のパラメータータイプ &lt;code&gt;via: Bowl&amp;lt;T&amp;gt;&lt;/code&gt; 追加することで興味深い効果を得ることができます：Bowl &amp;lt;T&amp;gt;。この場合、 &lt;code&gt;via&lt;/code&gt; のジェネリック型パラメーターは、 &lt;code&gt;from&lt;/code&gt; と &lt;code&gt;to&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="74f25352205ca76e991ebde88bff4a464449ff37" translate="yes" xml:space="preserve">
          <source>While it is possible in Kotlin to dynamically create new classes at runtime or to add members to a class, it's tricky and slow, and generally discouraged. However, it is easy to dynamically inspect an object to see e.g. what properties and functions it contains and which annotations exist on them. This is called &lt;em&gt;reflection&lt;/em&gt;, and it's not very performant, so avoid it unless you really need it.</source>
          <target state="translated">Kotlinでは、実行時に新しいクラスを動的に作成したり、クラスにメンバーを追加したりすることは可能ですが、トリッキーで時間がかかり、一般的には推奨されません。ただし、オブジェクトを動的に検査して、オブジェクトに含まれているプロパティや関数、それらに存在する注釈などを簡単に確認できます。これは&lt;em&gt;リフレクション&lt;/em&gt;と呼ばれ、パフォーマンスはそれほど高くないため、本当に必要でない限り避けてください。</target>
        </trans-unit>
        <trans-unit id="00ebcc3032e38c0f9dbd212c37ea7b7605032b6f" translate="yes" xml:space="preserve">
          <source>While it is possible to use the command line, either directly or by combining it with a script file (i.e., sh or bat file), we should notice, that it does not scale well for big projects that have hundreds of files and libraries. It is then better to use the Kotlin/Native compiler with a build system, as it helps to download and cache the Kotlin/Native compiler binaries and libraries with transitive dependencies and run the compiler and tests. Kotlin/Native can use the &lt;a href=&quot;https://gradle.org&quot;&gt;Gradle&lt;/a&gt; build system through the &lt;a href=&quot;../../reference/building-mpp-with-gradle&quot;&gt;kotlin-multiplatform&lt;/a&gt; plugin.</source>
          <target state="translated">コマンドラインを直接、またはスクリプトファイル（shファイルまたはbatファイル）と組み合わせて使用​​することは可能ですが、数百のファイルやライブラリを含む大規模なプロジェクトでは適切にスケーリングされないことに注意してください。次に、ビルドシステムでKotlin / Nativeコンパイラを使用することをお勧めします。これは、推移的な依存関係を持つKotlin / Nativeコンパイラのバイナリとライブラリをダウンロードしてキャッシュし、コンパイラとテストを実行するのに役立ちます。 Kotlin / Nativeは、&lt;a href=&quot;../../reference/building-mpp-with-gradle&quot;&gt;kotlin-multiplatform&lt;/a&gt;プラグインを介して&lt;a href=&quot;https://gradle.org&quot;&gt;Gradle&lt;/a&gt;ビルドシステムを使用できます。</target>
        </trans-unit>
        <trans-unit id="ccb7cdd4315f54dc22cc954a705304d8025d4496" translate="yes" xml:space="preserve">
          <source>While it is possible to use the command line, either directly or by combining it with a script file (i.e., sh or bat file), we should notice, that it does not scale well for big projects that have hundreds of files and libraries. It is then better to use the Kotlin/Native compiler with a build system, as it helps to download and cache the Kotlin/Native compiler binaries and libraries with transitive dependencies and run the compiler and tests. Kotlin/Native can use the &lt;a href=&quot;https://gradle.org&quot;&gt;Gradle&lt;/a&gt; build system through the &lt;a href=&quot;../../reference/mpp-discover-project#multiplatform-plugin&quot;&gt;kotlin-multiplatform&lt;/a&gt; plugin.</source>
          <target state="translated">コマンドラインは、直接使用することも、スクリプトファイル（shまたはbatファイルなど）と組み合わせて使用​​することもできますが、数百のファイルやライブラリを含む大規模なプロジェクトでは適切に拡張できないことに注意してください。その後、ビルドシステムでKotlin / Nativeコンパイラを使用することをお勧めします。これは、Kotlin / Nativeコンパイラのバイナリとライブラリを一時的な依存関係でダウンロードしてキャッシュし、コンパイラとテストを実行するのに役立ちます。 Kotlin / Nativeは、&lt;a href=&quot;../../reference/mpp-discover-project#multiplatform-plugin&quot;&gt;kotlin-multiplatform&lt;/a&gt;プラグインを介して&lt;a href=&quot;https://gradle.org&quot;&gt;Gradle&lt;/a&gt;ビルドシステムを使用できます。</target>
        </trans-unit>
        <trans-unit id="4688c1c9cfee712dab9268862c4aa04c7274850f" translate="yes" xml:space="preserve">
          <source>While it was already possible to extract this variable just before &lt;code&gt;when&lt;/code&gt; , &lt;code&gt;val&lt;/code&gt; in &lt;code&gt;when&lt;/code&gt; has its scope properly restricted to the body of &lt;code&gt;when&lt;/code&gt;, and so preventing namespace pollution. See the full documentation on &lt;code&gt;when&lt;/code&gt;&lt;a href=&quot;control-flow#when-expression&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">ちょうど前にこの変数を抽出するために、既にできたものの &lt;code&gt;when&lt;/code&gt; 、 &lt;code&gt;val&lt;/code&gt; では、 &lt;code&gt;when&lt;/code&gt; にその範囲が正しく本体に制限した &lt;code&gt;when&lt;/code&gt; 名前空間の汚染を防止し、そしてそう。 &lt;code&gt;when&lt;/code&gt; &lt;a href=&quot;control-flow#when-expression&quot;&gt;ここで&lt;/a&gt;完全なドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="18fc211f02fff65fa62198ec0d6b2196f5fda852" translate="yes" xml:space="preserve">
          <source>While most IDE's including &lt;a href=&quot;https://www.jetbrains.com/idea&quot;&gt;IntelliJ IDEA&lt;/a&gt; can generate the corresponding Gradle file, we're going to take a look at how to create this manually, to have a better understanding of how things work under the covers. If you'd like to use the IDE, check out &lt;a href=&quot;using-intellij-idea&quot;&gt;Using IntelliJ IDEA&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.jetbrains.com/idea&quot;&gt;IntelliJ IDEA&lt;/a&gt;を含むほとんどのIDEは、対応するGradleファイルを生成できますが、これを手動で作成する方法を見て、内部でどのように機能するかをよりよく理解します。IDEを使用したい場合は、&lt;a href=&quot;using-intellij-idea&quot;&gt;IntelliJIDEAの使用を&lt;/a&gt;確認してください。</target>
        </trans-unit>
        <trans-unit id="edf1dfe40b0f0a7f06896b58374c31b6b8d9a056" translate="yes" xml:space="preserve">
          <source>While most of the language changes were already announced through other channels, like update changelogs or compiler warnings, this document summarizes them all, providing a complete reference for migration from Kotlin 1.2 to Kotlin 1.3</source>
          <target state="translated">ほとんどの言語の変更点は、アップデートの変更ログやコンパイラの警告など、他のチャネルですでに発表されていましたが、このドキュメントではそれらの変更点をすべてまとめ、Kotlin 1.2 から Kotlin 1.3 への移行のための完全なリファレンスを提供しています。</target>
        </trans-unit>
        <trans-unit id="b3798978e8389c22f139d4b97896bde1b7b9685d" translate="yes" xml:space="preserve">
          <source>While most of the language changes were already announced through other channels, like update changelogs or compiler warnings, this document summarizes them all, providing a complete reference for migration from Kotlin 1.3 to Kotlin 1.4.</source>
          <target state="translated">ほとんどの言語の変更は、アップデートの変更ログやコンパイラの警告など、他のチャンネルですでに発表されていますが、このドキュメントではそれらをまとめ、Kotlin 1.3 から Kotlin 1.4 への移行のための完全なリファレンスを提供しています。</target>
        </trans-unit>
        <trans-unit id="399ba37d2ce977b9a644dbef3594c75ca535f65a" translate="yes" xml:space="preserve">
          <source>While the above solution works well for situations in which we have a corresponding header file (be this something we've defined ourselves or converted from a TypeScript header), often times we need to work with some library that does not have a header. For instance, let's say we want to use a jQuery plugin, that allows us to convert an HTML table to a nice looking navigable grid.</source>
          <target state="translated">上記の解決策は、対応するヘッダファイル(自分で定義したものであれ、TypeScriptのヘッダから変換したものであれ)がある場合にはうまく機能しますが、多くの場合、ヘッダを持たないライブラリを使用しなければならないことがあります。例えば、HTML テーブルを見栄えの良いナビゲーション可能なグリッドに変換できる jQuery プラグインを使用したいとします。</target>
        </trans-unit>
        <trans-unit id="7193542d5cd6b24f8c9a4e41a255c37b1a878838" translate="yes" xml:space="preserve">
          <source>While the converter is not fool-proof, it does a pretty decent job of converting most boilerplate code from Java to Kotlin. Some manual tweaking however is sometimes required.</source>
          <target state="translated">このコンバータは馬鹿にできないものではありませんが、JavaからKotlinにほとんどの定型的なコードを変換するのにはかなりまともな仕事をしてくれます。しかし、時には手動での微調整が必要になることもあります。</target>
        </trans-unit>
        <trans-unit id="d3c9392710d351a08ea5a20fd29014ffdd0dc8f8" translate="yes" xml:space="preserve">
          <source>While the dots suggest that packages are nested inside each other, that's not actually the case from a language standpoint. While it's a good idea to organize your code such that the &quot;subpackages&quot; of &lt;code&gt;content&lt;/code&gt;, such as &lt;code&gt;content.exercises&lt;/code&gt; and &lt;code&gt;content.articles&lt;/code&gt;, both contain content-related code, these three packages are unrelated from a language standpoint. However, if you use &lt;em&gt;modules&lt;/em&gt; (as defined by your build system), it is typically the case that all &quot;subpackages&quot; go in the same module, in which case symbols with &lt;a href=&quot;visibility-modifiers&quot;&gt;&lt;code&gt;internal&lt;/code&gt; visibility&lt;/a&gt; are visible throughout the subpackages.</source>
          <target state="translated">ドットはパッケージが相互にネストされていることを示唆していますが、実際には言語の観点からはそうではありません。 &lt;code&gt;content.exercises&lt;/code&gt; や &lt;code&gt;content.articles&lt;/code&gt; などの &lt;code&gt;content&lt;/code&gt; 「サブパッケージ」にコンテンツ関連のコードが含まれるようにコードを編成することをお勧めしますが、これら3つのパッケージは言語の観点からは無関係です。ただし、（ビルドシステムで定義された）&lt;em&gt;モジュール&lt;/em&gt;を使用する場合、通常はすべての「サブパッケージ」が同じモジュールに含まれます。この場合、&lt;a href=&quot;visibility-modifiers&quot;&gt; &lt;code&gt;internal&lt;/code&gt; &lt;/a&gt;可視性を持つシンボルがサブパッケージ全体に表示されます。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6f4289b089753c293140e137503818ca7bef2f53" translate="yes" xml:space="preserve">
          <source>While the output of the compiler does not have any dependencies or virtual machine requirements, the compiler itself and the Gradle build system require a Java 1.8 or 11 runtime. Check out the &lt;a href=&quot;https://jdk.java.net/11/&quot;&gt;https://jdk.java.net/11&lt;/a&gt; or another resource for the best JRE, OpenJDK, or JDK distribution.</source>
          <target state="translated">コンパイラの出力には依存関係や仮想マシンの要件はありませんが、コンパイラ自体とGradleビルドシステムにはJava 1.8または11ランタイムが必要です。最適なJRE、OpenJDK、またはJDKディストリビューションについては、&lt;a href=&quot;https://jdk.java.net/11/&quot;&gt;https：//jdk.java.net/11&lt;/a&gt;または別のリソースを確認してください。</target>
        </trans-unit>
        <trans-unit id="10c2d0246f094d4009ab7bad0367365f4bcc7c84" translate="yes" xml:space="preserve">
          <source>While the output of the compiler does not have any dependencies or virtual machine requirements, the compiler itself requires &lt;a href=&quot;https://jdk.java.net/11/&quot;&gt;Java 1.8 or higher runtime&lt;/a&gt;.</source>
          <target state="translated">コンパイラの出力には依存関係や仮想マシンの要件はありませんが、コンパイラ自体には&lt;a href=&quot;https://jdk.java.net/11/&quot;&gt;Java1.8以降のランタイム&lt;/a&gt;が必要です。</target>
        </trans-unit>
        <trans-unit id="34d621226a511f26c66770b36d29a5c867fde780" translate="yes" xml:space="preserve">
          <source>While this example happened to use the same expression, that is not necessary - overloaded functions can do completely different things if need be (although your code can get confusing if you make functions that have very different behavior be overloads of each other).</source>
          <target state="translated">この例ではたまたま同じ式を使用していましたが、その必要はありません。オーバーロードされた関数は必要に応じて全く異なる動作をすることができます(ただし、動作が全く異なる関数をお互いのオーバーロードにするとコードが混乱します)。</target>
        </trans-unit>
        <trans-unit id="68ab041f58d77da2145ef925bbf99b70a47a9c63" translate="yes" xml:space="preserve">
          <source>While uploading your library to Bintray, you will see multiple versions for each artifact (such as &lt;code&gt;my-library-jvm&lt;/code&gt;, &lt;code&gt;my-library-metadata&lt;/code&gt;, etc.). To fix this, add &lt;code&gt;systemProp.org.gradle.internal.publish.checksums.insecure=true&lt;/code&gt;. See &lt;a href=&quot;https://github.com/gradle/gradle/issues/11412&quot;&gt;this issue&lt;/a&gt; for details. This is a common Gradle 6.0 issue that is neither MPP nor Kotlin specific.</source>
          <target state="translated">ライブラリをBintrayにアップロードしている間、アーティファクトごとに複数のバージョンが表示されます（ &lt;code&gt;my-library-jvm&lt;/code&gt; 、 &lt;code&gt;my-library-metadata&lt;/code&gt; など）。これを修正するには、 &lt;code&gt;systemProp.org.gradle.internal.publish.checksums.insecure=true&lt;/code&gt; を追加します。詳細については、&lt;a href=&quot;https://github.com/gradle/gradle/issues/11412&quot;&gt;この問題&lt;/a&gt;を参照してください。これは一般的なGradle6.0の問題であり、MPPにもKotlinにも固有ではありません。</target>
        </trans-unit>
        <trans-unit id="29d4507848ac2db4dd040b8f1b98e137154ce676" translate="yes" xml:space="preserve">
          <source>While we don&amp;rsquo;t recommend it, you can use a wildcard &lt;code&gt;*&lt;/code&gt; in place of a version number if you do not want to specify a version or version range explicitly.</source>
          <target state="translated">推奨しませんが、バージョンまたはバージョン範囲を明示的に指定したくない場合は、バージョン番号の代わりにワイルドカード &lt;code&gt;*&lt;/code&gt; を使用できます。</target>
        </trans-unit>
        <trans-unit id="79482c24120b8d210f4051a8c238d3feb29fa237" translate="yes" xml:space="preserve">
          <source>Who develops Kotlin?</source>
          <target state="translated">Kotlinを開発しているのは誰ですか?</target>
        </trans-unit>
        <trans-unit id="6b8ca7e4bd278a327d17a1ff62cc87137c652d74" translate="yes" xml:space="preserve">
          <source>Why Kotlin/Native?</source>
          <target state="translated">なぜKotlin/Nativeなのか?</target>
        </trans-unit>
        <trans-unit id="5327cb3e3f7820311f240e8254b2120a882043dc" translate="yes" xml:space="preserve">
          <source>Why not just add required manifest options to all Kotlin libraries</source>
          <target state="translated">すべての Kotlin ライブラリに必須のマニフェストオプションを追加すればよいのではないでしょうか?</target>
        </trans-unit>
        <trans-unit id="dc289721e21b7419371258307342fbd161fffe25" translate="yes" xml:space="preserve">
          <source>Wildcard-types</source>
          <target state="translated">Wildcard-types</target>
        </trans-unit>
        <trans-unit id="1a6e732a37845c36fcda3afa6f1ba0d920b0ebca" translate="yes" xml:space="preserve">
          <source>WindowEventHandlers</source>
          <target state="translated">WindowEventHandlers</target>
        </trans-unit>
        <trans-unit id="0be6c8c411ba30d8cffb7e90ca7acef58e77aa71" translate="yes" xml:space="preserve">
          <source>WindowLocalStorage</source>
          <target state="translated">WindowLocalStorage</target>
        </trans-unit>
        <trans-unit id="4695cae95157eec4a2f36b8710914191b7160a60" translate="yes" xml:space="preserve">
          <source>WindowOrWorkerGlobalScope</source>
          <target state="translated">WindowOrWorkerGlobalScope</target>
        </trans-unit>
        <trans-unit id="837e70bad69f4bf6bd4622325d1fb73918d9e99b" translate="yes" xml:space="preserve">
          <source>WindowSessionStorage</source>
          <target state="translated">WindowSessionStorage</target>
        </trans-unit>
        <trans-unit id="7d22ecce0385c959845f551d5a3b5ab183398dfa" translate="yes" xml:space="preserve">
          <source>Windowed</source>
          <target state="translated">Windowed</target>
        </trans-unit>
        <trans-unit id="26d9c28d789c254f71ea99a3463b99a7ccc2f4fa" translate="yes" xml:space="preserve">
          <source>Windows</source>
          <target state="translated">Windows</target>
        </trans-unit>
        <trans-unit id="628596087f96fc1704310fa20e91f817ad0907ae" translate="yes" xml:space="preserve">
          <source>Windows (mingw x86_64, x86)</source>
          <target state="translated">Windows (mingw x86_64,x86)</target>
        </trans-unit>
        <trans-unit id="3501a24aebe2c74160390742479cffed6294f769" translate="yes" xml:space="preserve">
          <source>Windows targets require a Windows host;</source>
          <target state="translated">Windows ターゲットには Windows ホストが必要です。</target>
        </trans-unit>
        <trans-unit id="ce9d44e441b23e1629b147f917e9518ae0913959" translate="yes" xml:space="preserve">
          <source>Windows: &lt;code&gt;libnative_api.h&lt;/code&gt;, &lt;code&gt;libnative_symbols.def&lt;/code&gt; and &lt;code&gt;libnative.dll&lt;/code&gt;</source>
          <target state="translated">Windows： &lt;code&gt;libnative_api.h&lt;/code&gt; 、 &lt;code&gt;libnative_symbols.def&lt;/code&gt; および &lt;code&gt;libnative.dll&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e1a374d672ab75b4235e338c90ddfcf6afbecca5" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;https://plugins.jetbrains.com/plugin/10081-edutools&quot;&gt;EduTools&lt;/a&gt; plugin you can learn and teach Kotlin through code practicing tasks. It is available both in &lt;a href=&quot;https://developer.android.com/studio&quot;&gt;Android Studio&lt;/a&gt; and &lt;a href=&quot;https://www.jetbrains.com/idea/&quot;&gt;IntelliJ IDEA&lt;/a&gt;. This tutorial describes course creation for an educator. If you want to use EduTools plugin for learning, read &lt;a href=&quot;edu-tools-learner&quot;&gt;&quot;Learning Kotlin with EduTools plugin&quot;&lt;/a&gt;.</source>
          <target state="translated">では&lt;a href=&quot;https://plugins.jetbrains.com/plugin/10081-edutools&quot;&gt;EduTools&lt;/a&gt;あなたがタスクを練習コードをKotlinを学び、教えることができるプラグイン。&lt;a href=&quot;https://developer.android.com/studio&quot;&gt;Android Studio&lt;/a&gt;と&lt;a href=&quot;https://www.jetbrains.com/idea/&quot;&gt;IntelliJ IDEAの&lt;/a&gt;両方で利用できます。このチュートリアルでは、教育者向けのコース作成について説明します。EduToolsプラグインを学習に使用する場合は、&lt;a href=&quot;edu-tools-learner&quot;&gt;「EduToolsプラグインによるKotlinの学習」をお&lt;/a&gt;読みください。</target>
        </trans-unit>
        <trans-unit id="d7e4afdf3ca90295d086cf8bfcf9a9049903e7a2" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;https://plugins.jetbrains.com/plugin/10081-edutools&quot;&gt;EduTools&lt;/a&gt; plugin you can learn and teach Kotlin through code practicing tasks. It is available both in &lt;a href=&quot;https://developer.android.com/studio&quot;&gt;Android Studio&lt;/a&gt; and &lt;a href=&quot;https://www.jetbrains.com/idea/&quot;&gt;IntelliJ IDEA&lt;/a&gt;. This tutorial describes the interactive learning. If you want to use the EduTools plugin for teaching, read &lt;a href=&quot;edu-tools-educator&quot;&gt;&quot;Teaching Kotlin with EduTools plugin&quot;&lt;/a&gt;.</source>
          <target state="translated">では&lt;a href=&quot;https://plugins.jetbrains.com/plugin/10081-edutools&quot;&gt;EduTools&lt;/a&gt;あなたがタスクを練習コードをKotlinを学び、教えることができるプラグイン。&lt;a href=&quot;https://developer.android.com/studio&quot;&gt;Android Studio&lt;/a&gt;と&lt;a href=&quot;https://www.jetbrains.com/idea/&quot;&gt;IntelliJ IDEAの&lt;/a&gt;両方で利用できます。このチュートリアルでは、インタラクティブな学習について説明します。教育にEduToolsプラグインを使用する場合は、「EduToolsプラグインを使用した&lt;a href=&quot;edu-tools-educator&quot;&gt;Kotlinの教育」をお&lt;/a&gt;読みください。</target>
        </trans-unit>
        <trans-unit id="ddbee1008f9f20e446d88d4f79956907a6b4c399" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;mpp-share-on-platforms#share-code-on-similar-platforms&quot;&gt;the new hierarchical project structure support&lt;/a&gt;, you can share code among several targets in a multiplatform project. You can use platform-dependent libraries, such as &lt;code&gt;Foundation&lt;/code&gt;, &lt;code&gt;UIKit&lt;/code&gt;, and &lt;code&gt;posix&lt;/code&gt; in source sets shared among several native targets. This can help you share more native code without being limited by platform-specific dependencies.</source>
          <target state="translated">で&lt;a href=&quot;mpp-share-on-platforms#share-code-on-similar-platforms&quot;&gt;新しい階層プロジェクト構造のサポート&lt;/a&gt;は、マルチプロジェクト内の複数のターゲット間でコードを共有することができます。複数のネイティブターゲット間で共有されるソースセットで、 &lt;code&gt;Foundation&lt;/code&gt; 、 &lt;code&gt;UIKit&lt;/code&gt; 、 &lt;code&gt;posix&lt;/code&gt; などのプラットフォーム依存のライブラリを使用できます。これにより、プラットフォーム固有の依存関係に制限されることなく、より多くのネイティブコードを共有できます。</target>
        </trans-unit>
        <trans-unit id="91c32707acceb3a92d660aaa2664e3b3b359ee59" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;let&lt;/code&gt;, you can rewrite it:</source>
          <target state="translated">では &lt;code&gt;let&lt;/code&gt; 、あなたはそれを書き換えることができます。</target>
        </trans-unit>
        <trans-unit id="af688b954f4540e476c35b0f74f11c5204100c85" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;lisa&lt;/code&gt; and &lt;code&gt;anne&lt;/code&gt; from the infix example, you can now do:</source>
          <target state="translated">&lt;code&gt;lisa&lt;/code&gt; と &lt;code&gt;anne&lt;/code&gt; 中置例から、あなたが今行うことができます。</target>
        </trans-unit>
        <trans-unit id="32acfa5cff03b7f1ee491ea16213412942069586" translate="yes" xml:space="preserve">
          <source>With Gradle 6.0 and above, you are now able to load all scripts at once as opposed to the previous implementation where they were loaded individually. Since each request requires the Gradle configuration phase to be executed, this could be resource-intensive for large Gradle projects.</source>
          <target state="translated">Gradle 6.0 以降では、以前の実装では個別にスクリプトをロードしていたのに対し、すべてのスクリプトを一度にロードできるようになりました。各リクエストは Gradle の設定フェーズを実行する必要があるため、大規模な Gradle プロジェクトではリソースを消費する可能性があります。</target>
        </trans-unit>
        <trans-unit id="c2bc622686f7933d6457fe256aa33e7162dce61a" translate="yes" xml:space="preserve">
          <source>With Gradle Kotlin DSL, configure source sets with &lt;code&gt;java.sourceSets { ... }&lt;/code&gt; instead.</source>
          <target state="translated">Gradle Kotlin DSLでは、代わりに &lt;code&gt;java.sourceSets { ... }&lt;/code&gt; を使用してソースセットを構成します。</target>
        </trans-unit>
        <trans-unit id="bf21fbd8ac94a33fdcdb64a0972b9b5c1c2c5132" translate="yes" xml:space="preserve">
          <source>With Gradle metadata enabled, an additional 'root' publication named &lt;code&gt;kotlinMultiplatform&lt;/code&gt; is added to the project's publications. The default artifact ID of this publication matches the project name without any additional suffix. To configure this publication, access it via the &lt;code&gt;publishing { ... }&lt;/code&gt; DSL of the &lt;code&gt;maven-publish&lt;/code&gt; plugin:</source>
          <target state="translated">Gradleメタデータを有効にすると、 &lt;code&gt;kotlinMultiplatform&lt;/code&gt; という名前の追加の「ルート」パブリケーションがプロジェクトのパブリケーションに追加されます。このパブリケーションのデフォルトの案件IDは、追加のサフィックスなしでプロジェクト名と一致します。このパブリケーションを構成するには、 &lt;code&gt;maven-publish&lt;/code&gt; プラグインの &lt;code&gt;publishing { ... }&lt;/code&gt; DSLを介してアクセスします。</target>
        </trans-unit>
        <trans-unit id="cfc45b937026fd4fbaf26509635a71da2f380172" translate="yes" xml:space="preserve">
          <source>With Kotlin 1.3, it is possible to mark members of a &lt;code&gt;companion&lt;/code&gt; object of interfaces with annotations &lt;code&gt;@JvmStatic&lt;/code&gt; and &lt;code&gt;@JvmField&lt;/code&gt;. In the classfile, such members will be lifted to the corresponding interface and marked as &lt;code&gt;static&lt;/code&gt;.</source>
          <target state="translated">Kotlin 1.3では、インターフェースの &lt;code&gt;companion&lt;/code&gt; オブジェクトのメンバーに &lt;code&gt;@JvmStatic&lt;/code&gt; および &lt;code&gt;@JvmField&lt;/code&gt; アノテーションを付けることができます。クラスファイルでは、そのようなメンバーは対応するインターフェースに持ち上げられ、 &lt;code&gt;static&lt;/code&gt; としてマークされます。</target>
        </trans-unit>
        <trans-unit id="3b65590d91561b1b8e789678b4dd06427d7909a3" translate="yes" xml:space="preserve">
          <source>With Kotlin 1.4 you can now add a trailing comma in enumerations such as argument and parameter lists, &lt;code&gt;when&lt;/code&gt; entries, and components of destructuring declarations. With a trailing comma, you can add new items and change their order without adding or removing commas.</source>
          <target state="translated">Kotlin 1.4では、引数やパラメーターリスト、エントリの &lt;code&gt;when&lt;/code&gt; 、および非構造化宣言のコンポーネントなどの列挙に末尾のコンマを追加できるようになりました。末尾にカンマを使用すると、カンマを追加または削除せずに、新しいアイテムを追加したり、順序を変更したりできます。</target>
        </trans-unit>
        <trans-unit id="492f25a9a5171ae34e810e40b21b2cb1efcdaaeb" translate="yes" xml:space="preserve">
          <source>With Kotlin 1.4, you can use the new tools in IntelliJ IDEA to simplify Kotlin development:</source>
          <target state="translated">Kotlin 1.4では、IntelliJ IDEAの新しいツールを使用してKotlinの開発を簡素化することができます。</target>
        </trans-unit>
        <trans-unit id="0ed9b754f624185d343cb02b0b8d34dd9ae4ed13" translate="yes" xml:space="preserve">
          <source>With Kotlin 1.4.0, we are shipping the first stable version of &lt;a href=&quot;https://github.com/Kotlin/kotlinx.serialization&quot;&gt;kotlinx.serialization&lt;/a&gt; - 1.0.0-RC. Now we are pleased to declare the JSON serialization API in &lt;code&gt;kotlinx-serialization-core&lt;/code&gt; (previously known as &lt;code&gt;kotlinx-serialization-runtime&lt;/code&gt;) stable. Libraries for other serialization formats remain experimental, along with some advanced parts of the core library.</source>
          <target state="translated">Kotlin 1.4.0では、&lt;a href=&quot;https://github.com/Kotlin/kotlinx.serialization&quot;&gt;kotlinx.serializationの&lt;/a&gt;最初の安定バージョン-1.0.0 -RCを出荷しています。これで、 &lt;code&gt;kotlinx-serialization-core&lt;/code&gt; （以前は &lt;code&gt;kotlinx-serialization-runtime&lt;/code&gt; と呼ばれていました）のJSONシリアル化APIが安定していると宣言できることをうれしく思います。他のシリアル化形式のライブラリは、コアライブラリのいくつかの高度な部分とともに、実験的なままです。</target>
        </trans-unit>
        <trans-unit id="5b6d7af5fe3aafc8094b8a2cfd86e6ef8192a99f" translate="yes" xml:space="preserve">
          <source>With Kotlin &lt;a href=&quot;../../reference/multiplatform&quot;&gt;multiplatform&lt;/a&gt; projects, it is possible to share the same Kotlin code between all the supported platforms. Check out the tutorial on &lt;a href=&quot;mpp-ios-android&quot;&gt;sharing Kotlin code between iOS and Android&lt;/a&gt; or have a look at how to build your own &lt;a href=&quot;../multiplatform-library&quot;&gt;multiplatform library&lt;/a&gt;.</source>
          <target state="translated">Kotlin &lt;a href=&quot;../../reference/multiplatform&quot;&gt;マルチプラットフォーム&lt;/a&gt;プロジェクトでは、サポートされているすべてのプラットフォーム間で同じKotlinコードを共有できます。&lt;a href=&quot;mpp-ios-android&quot;&gt;iOSとAndroid間でのKotlinコードの共有&lt;/a&gt;に関するチュートリアルを確認するか、独自の&lt;a href=&quot;../multiplatform-library&quot;&gt;マルチプラットフォームライブラリ&lt;/a&gt;を構築する方法をご覧ください。</target>
        </trans-unit>
        <trans-unit id="63565c10375a2623a1558273ad959c355a70e5ce" translate="yes" xml:space="preserve">
          <source>With Kotlin Gradle DSL, the sections of predefined source sets should be marked &lt;code&gt;by getting&lt;/code&gt;.</source>
          <target state="translated">Kotlin Gradle DSLでは、事前定義されたソースセットのセクションを &lt;code&gt;by getting&lt;/code&gt; マークする必要があります。</target>
        </trans-unit>
        <trans-unit id="ec7fe3c48a3cadc6919466836bffd195ba2a63be" translate="yes" xml:space="preserve">
          <source>With Kotlin Multiplatform libraries, you can reuse the multiplatform logic in common and platform-specific code. Common code can rely on a set of libraries that cover everyday tasks such as &lt;a href=&quot;http://ktor.io/clients/http-client/multiplatform.html&quot;&gt;HTTP&lt;/a&gt;, &lt;a href=&quot;https://github.com/Kotlin/kotlinx.serialization&quot;&gt;serialization&lt;/a&gt;, and &lt;a href=&quot;https://github.com/Kotlin/kotlinx.coroutines&quot;&gt;managing coroutines&lt;/a&gt;.</source>
          <target state="translated">Kotlinマルチプラットフォームライブラリを使用すると、共通のプラットフォーム固有のコードでマルチプラットフォームロジックを再利用できます。一般的なコードは、&lt;a href=&quot;http://ktor.io/clients/http-client/multiplatform.html&quot;&gt;HTTP&lt;/a&gt;、&lt;a href=&quot;https://github.com/Kotlin/kotlinx.serialization&quot;&gt;シリアル化&lt;/a&gt;、&lt;a href=&quot;https://github.com/Kotlin/kotlinx.coroutines&quot;&gt;コルーチンの管理&lt;/a&gt;などの日常的なタスクをカバーする一連のライブラリに依存できます。</target>
        </trans-unit>
        <trans-unit id="5f3221afc2f20039e82884001a629bfe8610d1ab" translate="yes" xml:space="preserve">
          <source>With Kotlin Multiplatform, share the code using the mechanisms Kotlin provides:</source>
          <target state="translated">Kotlin Multiplatformでは、Kotlinが提供するメカニズムを使ってコードを共有することができます。</target>
        </trans-unit>
        <trans-unit id="adbab2d42979bafe508a0df0d9f59300200f67c7" translate="yes" xml:space="preserve">
          <source>With Kotlin Multiplatform, spend less time on writing and maintaining the same code for &lt;a href=&quot;mpp-supported-platforms&quot;&gt;different platforms&lt;/a&gt; &amp;ndash; just share it using the mechanisms Kotlin provides:</source>
          <target state="translated">Kotlin Multiplatformを使用すると、&lt;a href=&quot;mpp-supported-platforms&quot;&gt;異なるプラットフォームで&lt;/a&gt;同じコードを記述して維持するために費やす時間を短縮できます。Kotlinが提供するメカニズムを使用してコードを共有するだけです。</target>
        </trans-unit>
        <trans-unit id="0e972123cd69ffcab96ad056c6c91d5aacf5be07" translate="yes" xml:space="preserve">
          <source>With Kotlin Multiplatform, you can share the code using the mechanisms Kotlin provides:</source>
          <target state="translated">Kotlin Multiplatformでは、Kotlinが提供するメカニズムを使ってコードを共有することができます。</target>
        </trans-unit>
        <trans-unit id="3962fde44c4aec537b82dcd2abfc22db4cc626fa" translate="yes" xml:space="preserve">
          <source>With a value of 1, walker visits only the origin directory and all its immediate children, with a value of 2 also grandchildren, etc.</source>
          <target state="translated">1の値を持つウォーカーは、原点ディレクトリとその直系の子のみを訪問し、2の値を持つ孫なども訪問します。</target>
        </trans-unit>
        <trans-unit id="ef51393788d21d74c116e9c29eea336ed0a6d471" translate="yes" xml:space="preserve">
          <source>With callbacks, the idea is to pass one function as a parameter to another function, and have this one invoked once the process has completed.</source>
          <target state="translated">コールバックでは、ある関数を別の関数のパラメータとして渡し、プロセスが完了した後に別の関数が呼び出されるようにします。</target>
        </trans-unit>
        <trans-unit id="016040b5eae4bf27f5a939a1b5c8156662185437" translate="yes" xml:space="preserve">
          <source>With collections and functions, polymorphism becomes more complicated - see the section on &lt;a href=&quot;generics&quot;&gt;generics&lt;/a&gt;.</source>
          <target state="translated">コレクションと関数を使用すると、ポリモーフィズムがより複雑になります。&lt;a href=&quot;generics&quot;&gt;ジェネリック&lt;/a&gt;のセクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="c1dcb9e12e7f211f30c8a5176d8ae68de49c58b9" translate="yes" xml:space="preserve">
          <source>With either version of the import, you can now simply do:</source>
          <target state="translated">どちらのバージョンのインポートでも、簡単にできるようになりました。</target>
        </trans-unit>
        <trans-unit id="fe95a6fd3800d1f0d89afcda519d105e6e6110b2" translate="yes" xml:space="preserve">
          <source>With function literals, local functions and object expression, functions can be nested in Kotlin. Qualified &lt;em&gt;return&lt;/em&gt;s allow us to return from an outer function. The most important use case is returning from a lambda expression. Recall that when we write this:</source>
          <target state="translated">関数リテラル、ローカル関数、オブジェクト式を使用すると、Kotlinで関数をネストできます。資格の&lt;em&gt;リターン&lt;/em&gt;のは、私たちは外側の関数から復帰することができます。最も重要なユースケースは、ラムダ式からの戻りです。これを書いたときのことを思い出してください：</target>
        </trans-unit>
        <trans-unit id="eb6ed75ff29820dbdcda23941139d4c1d4ba7dd2" translate="yes" xml:space="preserve">
          <source>With named arguments we can make the code much more readable:</source>
          <target state="translated">名前付き引数を使うことで、コードをより読みやすくすることができます。</target>
        </trans-unit>
        <trans-unit id="3450c7c71d6bf1ddf49a4323aca70311d456d430" translate="yes" xml:space="preserve">
          <source>With that, our project should now build and produce the corresponding artifacts.</source>
          <target state="translated">これで、私たちのプロジェクトは、対応する成果物を構築し、生成することができます。</target>
        </trans-unit>
        <trans-unit id="355ad4d87e7870b0c272b188aa3ef65d4dc920f9" translate="yes" xml:space="preserve">
          <source>With the &lt;a href=&quot;https://plugins.jetbrains.com/plugin/10081-edutools&quot;&gt;EduTools plugin&lt;/a&gt;, available both in &lt;a href=&quot;https://developer.android.com/studio&quot;&gt;Android Studio&lt;/a&gt; and &lt;a href=&quot;https://www.jetbrains.com/idea/&quot;&gt;IntelliJ IDEA&lt;/a&gt;, you can learn Kotlin through code practicing tasks.</source>
          <target state="translated">&lt;a href=&quot;https://plugins.jetbrains.com/plugin/10081-edutools&quot;&gt;プラグインEduTools&lt;/a&gt;の両方で利用できる、&lt;a href=&quot;https://developer.android.com/studio&quot;&gt;Androidのメーカー&lt;/a&gt;と&lt;a href=&quot;https://www.jetbrains.com/idea/&quot;&gt;のIntelliJ IDEA&lt;/a&gt;は、タスクを実践コードをKotlinを学ぶことができます。</target>
        </trans-unit>
        <trans-unit id="36b14af153f14d3f9734df37394a46678fa4ba5c" translate="yes" xml:space="preserve">
          <source>With the &lt;a href=&quot;https://plugins.jetbrains.com/plugin/10081-edutools&quot;&gt;EduTools plugin&lt;/a&gt;, available both in &lt;a href=&quot;https://developer.android.com/studio&quot;&gt;Android Studio&lt;/a&gt; and &lt;a href=&quot;https://www.jetbrains.com/idea/&quot;&gt;IntelliJ IDEA&lt;/a&gt;, you can teach Kotlin through code practicing tasks. Take a look at the &lt;a href=&quot;https://www.jetbrains.com/help/education/educator-start-guide.html?section=Kotlin&quot;&gt;Educator Start Guide&lt;/a&gt; to learn how to create a simple Kotlin course that includes a set of programming tasks and integrated tests.</source>
          <target state="translated">&lt;a href=&quot;https://plugins.jetbrains.com/plugin/10081-edutools&quot;&gt;プラグインEduTools&lt;/a&gt;の両方で利用できる、&lt;a href=&quot;https://developer.android.com/studio&quot;&gt;Androidのメーカー&lt;/a&gt;と&lt;a href=&quot;https://www.jetbrains.com/idea/&quot;&gt;のIntelliJ IDEA&lt;/a&gt;は、タスクを実践コードをKotlinを教えることができます。一連のプログラミングタスクと統合テストを含む簡単なKotlinコースを作成する方法については、&lt;a href=&quot;https://www.jetbrains.com/help/education/educator-start-guide.html?section=Kotlin&quot;&gt;Educator&lt;/a&gt; StartGuideをご覧ください。</target>
        </trans-unit>
        <trans-unit id="f5382fb55641e05a034b3ea5d0c0d4be768aee31" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;PropertyDelegateProvider&lt;/code&gt; interface from the standard library, you can create delegate providers without creating new classes.</source>
          <target state="translated">標準ライブラリの &lt;code&gt;PropertyDelegateProvider&lt;/code&gt; インターフェイスを使用すると、新しいクラスを作成せずにデリゲートプロバイダーを作成できます。</target>
        </trans-unit>
        <trans-unit id="dadda346a2629bde84d619a153f6df49f573d66b" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;cancellable&lt;/code&gt; operator only the numbers from 1 to 3 are collected:</source>
          <target state="translated">で &lt;code&gt;cancellable&lt;/code&gt; オペレータ1から3の数字のみが収集されます。</target>
        </trans-unit>
        <trans-unit id="7f45b301e2a74f1dd5893d4a531ceba47efa69ee" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;kotlin-multiplatform&lt;/code&gt; plugin &lt;strong&gt;source&lt;/strong&gt;&lt;strong&gt;sets&lt;/strong&gt; are also used to group sources but source files for different platforms are located in different source sets. For each declared target two source sets are created: &lt;code&gt;&amp;lt;target-name&amp;gt;Main&lt;/code&gt; and &lt;code&gt;&amp;lt;target-name&amp;gt;Test&lt;/code&gt; containing product and test sources for this platform. Common for all platforms sources are located in &lt;code&gt;commonMain&lt;/code&gt; and &lt;code&gt;commonTest&lt;/code&gt; source sets created by default. More information about source sets can be found &lt;a href=&quot;../building-mpp-with-gradle#configuring-source-sets&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;kotlin-multiplatform&lt;/code&gt; プラグインの&lt;strong&gt;ソース&lt;/strong&gt;&lt;strong&gt;セットは&lt;/strong&gt;また、グループのソースに使用されているが、異なるプラットフォームのソースファイルは、異なるソースのセットに配置されています。宣言されたターゲットごとに、2つのソースセットが作成されます： &lt;code&gt;&amp;lt;target-name&amp;gt;Main&lt;/code&gt; と &lt;code&gt;&amp;lt;target-name&amp;gt;Test&lt;/code&gt; このプラットフォームの製品とテストソースを含むテスト。すべてのプラットフォームに共通のソースは、デフォルトで作成された &lt;code&gt;commonMain&lt;/code&gt; および &lt;code&gt;commonTest&lt;/code&gt; ソースセットにあります。ソースセットの詳細については、&lt;a href=&quot;../building-mpp-with-gradle#configuring-source-sets&quot;&gt;こちらをご覧ください&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c5d94234e74f15ed4145669bdb5e37f9dfb14ae3" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;kotlin-multiplatform&lt;/code&gt; plugin a compilation always produces a &lt;code&gt;*.klib&lt;/code&gt; file. A separate &lt;code&gt;binaries&lt;/code&gt; block is used to configure what final native binaries should be produced by each target. Each binary can be configured independently including linker options, executable entry point etc.</source>
          <target state="translated">&lt;code&gt;kotlin-multiplatform&lt;/code&gt; コンパイルプラグインは常に生成 &lt;code&gt;*.klib&lt;/code&gt; のファイルを。個別の &lt;code&gt;binaries&lt;/code&gt; ブロックを使用して、各ターゲットによって生成される最終的なネイティブバイナリを構成します。各バイナリは、リンカーオプション、実行可能エントリポイントなどを含めて、個別に構成できます。</target>
        </trans-unit>
        <trans-unit id="c6cb3a91147cfe093062a0839b721e658dabc4bd" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;kotlin-multiplatform&lt;/code&gt; plugin interops are configured as a part of a compilation (see details &lt;a href=&quot;../building-mpp-with-gradle#cinterop-support&quot;&gt;here&lt;/a&gt;). The rest of an interop configuration is the same as for the &lt;code&gt;kotlin-platform-native&lt;/code&gt; plugin.</source>
          <target state="translated">&lt;code&gt;kotlin-multiplatform&lt;/code&gt; プラグインinteropsは、コンパイルの一部として構成されている（詳細&lt;a href=&quot;../building-mpp-with-gradle#cinterop-support&quot;&gt;こちら&lt;/a&gt;）。相互運用設定の残りの部分は、 &lt;code&gt;kotlin-platform-native&lt;/code&gt; プラグインの場合と同じです。</target>
        </trans-unit>
        <trans-unit id="1706d3b6b7ce15bdbf71dc7c9e04a857f530061f" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;kotlin-multiplatform&lt;/code&gt; plugin target platforms can be added into a project using special methods available in the &lt;code&gt;kotlin&lt;/code&gt; extension. Each method adds into a project one &lt;strong&gt;target&lt;/strong&gt; which can be accessed using the &lt;code&gt;targets&lt;/code&gt; property. Each target can be configured independently including output kinds, additional compiler options etc. See details about targets at the &lt;a href=&quot;../building-mpp-with-gradle#setting-up-targets&quot;&gt;corresponding page&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;kotlin-multiplatform&lt;/code&gt; プラグインのターゲットプラットフォームが利用可能で、特殊な方法を使用してプロジェクトに追加することができ &lt;code&gt;kotlin&lt;/code&gt; 拡張子を。各メソッドは、 &lt;code&gt;targets&lt;/code&gt; プロパティを使用してアクセスできる1つの&lt;strong&gt;ターゲット&lt;/strong&gt;をプロジェクトに追加します。各ターゲットは、出力の種類、追加のコンパイラオプションなどを含めて、個別に構成できます。ターゲットの詳細については、&lt;a href=&quot;../building-mpp-with-gradle#setting-up-targets&quot;&gt;対応するページを参照してください&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="71022b4d02eeeda0e92ce39399dff9342c3334b7" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;kotlin-platform-native&lt;/code&gt; plugin a set of target platforms is specified as a list in properties of the main component:</source>
          <target state="translated">&lt;code&gt;kotlin-platform-native&lt;/code&gt; プラグインのターゲットプラットフォームのセットは、主要コンポーネントのプロパティでリストとして指定されています。</target>
        </trans-unit>
        <trans-unit id="6a03f6034b00496a7bad530da3196155a72cc860" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;kotlin-platform-native&lt;/code&gt; plugin dependencies are configured in a traditional for Gradle way by grouping them into configurations using the project &lt;code&gt;dependencies&lt;/code&gt; block:</source>
          <target state="translated">&lt;code&gt;kotlin-platform-native&lt;/code&gt; プラグインの依存関係は、プロジェクトの使用設定にそれらをグループ化することによって、Gradleの道のために伝統的に構成された &lt;code&gt;dependencies&lt;/code&gt; ブロックを：</target>
        </trans-unit>
        <trans-unit id="e33e92feed8df1d895d9a97b45aacf36671d526c" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;kotlin-platform-native&lt;/code&gt; plugin interop with a native library can be declared in component dependencies:</source>
          <target state="translated">&lt;code&gt;kotlin-platform-native&lt;/code&gt; ネイティブライブラリとプラグイン相互運用機能コンポーネントの依存関係に宣言することができます。</target>
        </trans-unit>
        <trans-unit id="a97bf25e776050662c47b29cee8cd98d22ea2c1d" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;kotlin-platform-native&lt;/code&gt; plugin output kinds are specified as a list in properties of a component:</source>
          <target state="translated">&lt;code&gt;kotlin-platform-native&lt;/code&gt; プラグインの出力種類の成分の特性のリストとして指定されています。</target>
        </trans-unit>
        <trans-unit id="32e186967f7559f8d4cf421fcfd2faf96d838898" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;kotlin-platform-native&lt;/code&gt; plugin source sets are used to separate test and product sources. Also you can specify different sources for different platforms in the same source set:</source>
          <target state="translated">&lt;code&gt;kotlin-platform-native&lt;/code&gt; プラグインソースセットは、別の試験及び製品の供給源に使用されます。また、同じソースセット内の異なるプラットフォームに異なるソースを指定することもできます。</target>
        </trans-unit>
        <trans-unit id="7fa674450fbd80d59d43844df0d5a16d3f6b263d" translate="yes" xml:space="preserve">
          <source>With the coroutine debugger, you can:</source>
          <target state="translated">coroutine デバッガを使うと、以下のようなことができます。</target>
        </trans-unit>
        <trans-unit id="29b0fbf80a9fbc5a69ad66b25c87ece38e49f33b" translate="yes" xml:space="preserve">
          <source>With the flexible new Kotlin Project Wizard, you have a place to easily create and configure different types of Kotlin projects, including multiplatform projects, which can be difficult to configure without a UI.</source>
          <target state="translated">柔軟性の高い新しいKotlinプロジェクトウィザードを使えば、UIなしでは設定が難しいマルチプラットフォームプロジェクトを含め、さまざまな種類のKotlinプロジェクトを簡単に作成して設定することができます。</target>
        </trans-unit>
        <trans-unit id="a5c6c878f4a74b6cd56b16a6f707da3f34b03dce" translate="yes" xml:space="preserve">
          <source>With the help of IntelliJ IDEA's &lt;em&gt;Goto Declaration&lt;/em&gt; or compiler errors we see the following declarations for our C functions:</source>
          <target state="translated">IntelliJ IDEAの&lt;em&gt;Goto宣言&lt;/em&gt;またはコンパイラエラーの助けを借りて、C関数の次の宣言を確認します。</target>
        </trans-unit>
        <trans-unit id="cf252d7abb4fe418f54b8621d262b977ba904b60" translate="yes" xml:space="preserve">
          <source>With the help of IntelliJ IDEA's &lt;em&gt;Goto Declaration&lt;/em&gt; or compiler errors we see the following generated API for our C functions, &lt;code&gt;struct&lt;/code&gt;, and &lt;code&gt;union&lt;/code&gt;:</source>
          <target state="translated">IntelliJ IDEAの&lt;em&gt;Goto宣言&lt;/em&gt;またはコンパイラエラーの助けを借りて、C関数、 &lt;code&gt;struct&lt;/code&gt; 、および &lt;code&gt;union&lt;/code&gt; に対して次の生成されたAPIを確認します。</target>
        </trans-unit>
        <trans-unit id="874119f71c620e91c1bb9c2e75fd174caab63b63" translate="yes" xml:space="preserve">
          <source>With the help of IntelliJ IDEA's &lt;em&gt;Goto Declaration&lt;/em&gt; or compiler errors we see the following generated API for our C functions:</source>
          <target state="translated">IntelliJ IDEAの&lt;em&gt;Goto宣言&lt;/em&gt;またはコンパイラエラーの助けを借りて、C関数に対して次の生成されたAPIを確認します。</target>
        </trans-unit>
        <trans-unit id="566c1425784d4c2e6ede1f7dfe672ee70373f129" translate="yes" xml:space="preserve">
          <source>With the new &lt;a href=&quot;js-to-kotlin-interop#jsexport-annotation&quot;&gt;&lt;code&gt;@JsExport&lt;/code&gt;&lt;/a&gt; annotation and the ability to &lt;strong&gt;&lt;a href=&quot;js-ir-compiler#preview-generation-of-typescript-declaration-files-dts&quot;&gt;generate TypeScript definitions&lt;/a&gt; from Kotlin code&lt;/strong&gt;, the Kotlin/JS IR compiler backend improves JavaScript &amp;amp; TypeScript interoperability. This also makes it easier to integrate Kotlin/JS code with existing tooling, to create &lt;strong&gt;hybrid applications&lt;/strong&gt; and leverage code-sharing functionality in multiplatform projects.</source>
          <target state="translated">新しい&lt;a href=&quot;js-to-kotlin-interop#jsexport-annotation&quot;&gt; &lt;code&gt;@JsExport&lt;/code&gt; &lt;/a&gt;アノテーションと&lt;strong&gt;Kotlinコードから&lt;/strong&gt;&lt;strong&gt;&lt;a href=&quot;js-ir-compiler#preview-generation-of-typescript-declaration-files-dts&quot;&gt;TypeScript定義&lt;/a&gt;&lt;/strong&gt;を&lt;strong&gt;生成&lt;/strong&gt;する機能により、Kotlin / JSIRコンパイラバックエンドはJavaScriptとTypeScriptの相互運用性を向上させます。これにより、Kotlin / JSコードを既存のツールと統合し、&lt;strong&gt;ハイブリッドアプリケーション&lt;/strong&gt;を作成し、マルチプラットフォームプロジェクトでコード共有機能を活用することも容易になります。</target>
        </trans-unit>
        <trans-unit id="5bc753b11e4bb4891a70a654bb57daca9017fc7f" translate="yes" xml:space="preserve">
          <source>With the new hierarchical project structure support, you can share code among &lt;a href=&quot;mpp-supported-platforms&quot;&gt;several platforms&lt;/a&gt; in a &lt;a href=&quot;mpp-discover-project&quot;&gt;multiplatform project&lt;/a&gt;.</source>
          <target state="translated">新しい階層プロジェクト構造のサポートにより、&lt;a href=&quot;mpp-discover-project&quot;&gt;マルチ&lt;/a&gt;&lt;a href=&quot;mpp-supported-platforms&quot;&gt;プラットフォーム&lt;/a&gt;プロジェクトの複数のプラットフォーム間でコードを共有できます。</target>
        </trans-unit>
        <trans-unit id="574c1c740a16fa65a0f397005ee3b1c60f44325d" translate="yes" xml:space="preserve">
          <source>With these features, you can make your Gradle build file much more concise and easy to read:</source>
          <target state="translated">これらの機能を使えば、Gradleのビルドファイルをより簡潔で読みやすくすることができます。</target>
        </trans-unit>
        <trans-unit id="55c0b9fe68cd1e4b20ebebcee0ed1689356c0a07" translate="yes" xml:space="preserve">
          <source>With these helpers, the part of code for reading input becomes simpler, closely following the input specification in the problem statement line by line:</source>
          <target state="translated">これらのヘルパーを使用すると、入力を読み取るコードの部分がよりシンプルになり、問題文の入力仕様を一行一行忠実に追いかけることができるようになります。</target>
        </trans-unit>
        <trans-unit id="a228c17a745863a462bf780050c335cd1bf004e4" translate="yes" xml:space="preserve">
          <source>With these two interfaces, we can make a more versatile fruit bowl. The bowl itself needs to both produce and consume its generic type, so it can neither be covariant nor contravariant, but it can implement our covariant and contravariant interfaces:</source>
          <target state="translated">この二つのインタフェースを使えば、より汎用性の高いフルーツボウルを作ることができます。ボウル自体は汎用型を生成して消費する必要があるので、共変でも対変でもありませんが、共変と対変のインタフェースを実装することができます。</target>
        </trans-unit>
        <trans-unit id="4a7d204c839bbeda2e10e199023fa5b9c64dcb76" translate="yes" xml:space="preserve">
          <source>With this external declaration, you can call &lt;code&gt;myFunWithOptionalArgs&lt;/code&gt; with one required argument and two optional arguments, where the default values are calculated by the JavaScript implementation of &lt;code&gt;myFunWithOptionalArgs&lt;/code&gt;.</source>
          <target state="translated">この外部宣言を使用すると、1つの必須引数と2つのオプション引数を使用して &lt;code&gt;myFunWithOptionalArgs&lt;/code&gt; を呼び出すことができます。デフォルト値は、 &lt;code&gt;myFunWithOptionalArgs&lt;/code&gt; のJavaScript実装によって計算されます。</target>
        </trans-unit>
        <trans-unit id="72d67501a892da363116927ae13a84e4aecbce70" translate="yes" xml:space="preserve">
          <source>With this mechanism, a common source set defines an &lt;em&gt;expected declaration&lt;/em&gt;, and platform source sets must provide the &lt;em&gt;actual declaration&lt;/em&gt; that corresponds to the expected declaration. This works for most Kotlin declarations, such as functions, classes, interfaces, enumerations, properties, and annotations.</source>
          <target state="translated">このメカニズムでは、共通のソースセットが&lt;em&gt;期待される宣言を&lt;/em&gt;定義し、プラットフォームソースセットは期待される宣言に対応する&lt;em&gt;実際の宣言&lt;/em&gt;を提供する必要があります。これは、関数、クラス、インターフェース、列挙、プロパティ、アノテーションなど、ほとんどのKotlin宣言で機能します。</target>
        </trans-unit>
        <trans-unit id="717e11f293d4b13a9a59d035d72d380a87efce32" translate="yes" xml:space="preserve">
          <source>With this setup, we can access elements of our DOM. To access the properties of the &lt;code&gt;input&lt;/code&gt; field, we invoke &lt;code&gt;getElementById&lt;/code&gt; and cast it to &lt;code&gt;HTMLInputElement&lt;/code&gt;. We can then safely access its properties, such as &lt;code&gt;value&lt;/code&gt;:</source>
          <target state="translated">この設定により、DOMの要素にアクセスできます。 &lt;code&gt;input&lt;/code&gt; フィールドのプロパティにアクセスするには、 &lt;code&gt;getElementById&lt;/code&gt; を呼び出し、それを &lt;code&gt;HTMLInputElement&lt;/code&gt; にキャストします。その後、 &lt;code&gt;value&lt;/code&gt; などのプロパティに安全にアクセスできます。</target>
        </trans-unit>
        <trans-unit id="41b77f41d3f8979c93fc79a64e556733e4160ef4" translate="yes" xml:space="preserve">
          <source>With this setup, we can recompile our project after each code change to see our changes. Kotlin/JS also supports a more convenient way of automatically rebuilding our application while we are developing it. To find out how to set up this &lt;em&gt;continuous mode&lt;/em&gt;, check out the &lt;a href=&quot;dev-server-continuous-compilation&quot;&gt;corresponding tutorial&lt;/a&gt;.</source>
          <target state="translated">この設定により、コードが変更されるたびにプロジェクトを再コンパイルして、変更を確認できます。Kotlin / JSは、アプリケーションの開発中にアプリケーションを自動的に再構築する、より便利な方法もサポートしています。この&lt;em&gt;連続モードの&lt;/em&gt;設定方法については、&lt;a href=&quot;dev-server-continuous-compilation&quot;&gt;対応するチュートリアルをご覧ください&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f9928576b159a395a58ce4f2d7b6c66f40874468" translate="yes" xml:space="preserve">
          <source>With this, we can then access any of the functionality defined inside &lt;code&gt;customerBL&lt;/code&gt;.</source>
          <target state="translated">これにより、 &lt;code&gt;customerBL&lt;/code&gt; 内で定義された任意の機能にアクセスできます。</target>
        </trans-unit>
        <trans-unit id="8dacc9ec11c6c308f4e37da6d574002e02a0ff3a" translate="yes" xml:space="preserve">
          <source>Without the curly braces, only the first line is a part of the body. Indentation in Kotlin matters only for human readers, so the second print is outside the if and will always be executed.</source>
          <target state="translated">くるくる中括弧がないと、1行目だけが本体の一部になってしまいます。Kotlinでのインデントは人間の読者にとってのみ重要なので、2番目の印刷はifの外側にあり、常に実行されます。</target>
        </trans-unit>
        <trans-unit id="d2ecf10500acdd56e5aa15cdc3d632f4d1b83484" translate="yes" xml:space="preserve">
          <source>Without this ability to intercept the binding between the property and its delegate, to achieve the same functionality you'd have to pass the property name explicitly, which isn't very convenient:</source>
          <target state="translated">この機能がなければ、同じ機能を実現するためには、プロパティ名を明示的に渡す必要があり、あまり便利ではありません。</target>
        </trans-unit>
        <trans-unit id="99edd8c8e615e373739d2cdd38a8942b8a573113" translate="yes" xml:space="preserve">
          <source>Worker</source>
          <target state="translated">Worker</target>
        </trans-unit>
        <trans-unit id="b539d8a8b3ce433f937b71658160ff7e5f64cd4c" translate="yes" xml:space="preserve">
          <source>Worker that &lt;a href=&quot;value&quot;&gt;value&lt;/a&gt; is bound to.</source>
          <target state="translated">その&lt;a href=&quot;value&quot;&gt;価値&lt;/a&gt;がバインドされているワーカー。</target>
        </trans-unit>
        <trans-unit id="a502b8bb9786901c6dc61e82d98c92b4b73ae927" translate="yes" xml:space="preserve">
          <source>WorkerBoundReference</source>
          <target state="translated">WorkerBoundReference</target>
        </trans-unit>
        <trans-unit id="74a0d635bad8cb921832f022e80f37a47e5b135d" translate="yes" xml:space="preserve">
          <source>WorkerLocation</source>
          <target state="translated">WorkerLocation</target>
        </trans-unit>
        <trans-unit id="315e6d0000af41369aa07e54a100988d3fd17dee" translate="yes" xml:space="preserve">
          <source>WorkerNavigator</source>
          <target state="translated">WorkerNavigator</target>
        </trans-unit>
        <trans-unit id="2c80abf6e395bd6f326cb30a261f19ee445cba02" translate="yes" xml:space="preserve">
          <source>WorkerOptions</source>
          <target state="translated">WorkerOptions</target>
        </trans-unit>
        <trans-unit id="87bb291b389446f9344ad088d8d62a7a62a19eca" translate="yes" xml:space="preserve">
          <source>WorkerType</source>
          <target state="translated">WorkerType</target>
        </trans-unit>
        <trans-unit id="b6ef3acd0f91c0c6e2a6bad2692c8aa84dfc4c73" translate="yes" xml:space="preserve">
          <source>Workers</source>
          <target state="translated">Workers</target>
        </trans-unit>
        <trans-unit id="4854bbfffb40975ef729e9def93b58f75765479a" translate="yes" xml:space="preserve">
          <source>Workers with message passing</source>
          <target state="translated">メッセージの通過を伴う労働者</target>
        </trans-unit>
        <trans-unit id="d7a484140f5f9f7f5427e1f2c44dbfc1d3ad9eea" translate="yes" xml:space="preserve">
          <source>Workflow</source>
          <target state="translated">Workflow</target>
        </trans-unit>
        <trans-unit id="7323cd213254c74db3a887f36bfadb481e7d4c0e" translate="yes" xml:space="preserve">
          <source>Working on all platforms is an explicit goal for Kotlin, but we see it as a premise to a much more important goal: sharing code between platforms. With support for JVM, Android, JavaScript, iOS, Linux, Windows, Mac and even embedded systems like STM32, Kotlin can handle any and all components of a modern application. And this brings the invaluable benefit of reuse for code and expertise, saving the effort for tasks more challenging than implementing everything twice or multiple times.</source>
          <target state="translated">Kotlinはすべてのプラットフォームで動作することを明確な目標としていますが、プラットフォーム間でコードを共有するという、より重要な目標の前提として捉えています。JVM、Android、JavaScript、iOS、Linux、Windows、Mac、さらにはSTM32のような組み込みシステムにも対応しており、Kotlinは最新のアプリケーションのあらゆるコンポーネントを扱うことができます。これにより、コードや専門知識を再利用できるという貴重なメリットがもたらされ、すべてを二度、三度と実装するよりも困難なタスクのための労力を節約できます。</target>
        </trans-unit>
        <trans-unit id="f538870f3ed8ccb71b1f28d4023b06274de86076" translate="yes" xml:space="preserve">
          <source>Working with Build Tools</source>
          <target state="translated">ビルドツールでの作業</target>
        </trans-unit>
        <trans-unit id="4c5d22ef62b4e454bd0bf1e1374aa13390ad7ed1" translate="yes" xml:space="preserve">
          <source>Working with C strings</source>
          <target state="translated">Cの文字列を使った作業</target>
        </trans-unit>
        <trans-unit id="9ac89fee8e06569c4ebc756f83cddf2bbd9a8ca8" translate="yes" xml:space="preserve">
          <source>Working with Enum Constants</source>
          <target state="translated">列挙定数を使った作業</target>
        </trans-unit>
        <trans-unit id="1f8482b2bf142fad82a2f635e71a135183f56a5d" translate="yes" xml:space="preserve">
          <source>Working with JavaScript</source>
          <target state="translated">JavaScriptでの作業</target>
        </trans-unit>
        <trans-unit id="8fc3285c1f9933f649e39499a1f3946c5619cf72" translate="yes" xml:space="preserve">
          <source>Working with Kotlin and JavaScript Modules</source>
          <target state="translated">KotlinとJavaScriptモジュールを使った作業</target>
        </trans-unit>
        <trans-unit id="9a49aac8293420ff01c5e9c031ff773d05799074" translate="yes" xml:space="preserve">
          <source>Working with nulls</source>
          <target state="translated">ヌルを使った作業</target>
        </trans-unit>
        <trans-unit id="e5c0c5bddfae833279acedcc9a537af19daf0f06" translate="yes" xml:space="preserve">
          <source>Working with tasks</source>
          <target state="translated">タスクを使った作業</target>
        </trans-unit>
        <trans-unit id="7d46e00971b365b4ef3386294882d7496a7f75ed" translate="yes" xml:space="preserve">
          <source>Working with the Command Line Compiler</source>
          <target state="translated">コマンドラインコンパイラでの作業</target>
        </trans-unit>
        <trans-unit id="f2a7db7b02d37c7f54b499213bb3a991f17a1744" translate="yes" xml:space="preserve">
          <source>Working with the strings</source>
          <target state="translated">弦を使った作業</target>
        </trans-unit>
        <trans-unit id="075cb3c4378fe512dd51ed618315bfebed19ab49" translate="yes" xml:space="preserve">
          <source>Worksheets automatically get access to classes and functions from the module where they reside.</source>
          <target state="translated">ワークシートは、それらが存在するモジュールからクラスや関数へのアクセスを自動的に取得します。</target>
        </trans-unit>
        <trans-unit id="298b3785e2ae406d29010843be91172dd4b7a909" translate="yes" xml:space="preserve">
          <source>Wraps the specified &lt;a href=&quot;timer-task#kotlin.concurrent%24timerTask%28kotlin.Function1%28%28java.util.TimerTask%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;action&lt;/a&gt; in a &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/util/TimerTask.html&quot;&gt;TimerTask&lt;/a&gt;.</source>
          <target state="translated">指定された&lt;a href=&quot;timer-task#kotlin.concurrent%24timerTask%28kotlin.Function1%28%28java.util.TimerTask%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;アクション&lt;/a&gt;を&lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/util/TimerTask.html&quot;&gt;TimerTask&lt;/a&gt;でラップします。</target>
        </trans-unit>
        <trans-unit id="bc7e6a2c63b3a339c10a75fe3c57e0e79aab2702" translate="yes" xml:space="preserve">
          <source>Wraps the specified &lt;a href=&quot;timer-task#kotlin.concurrent%24timerTask(kotlin.Function1((java.util.TimerTask,%20kotlin.Unit)))/action&quot;&gt;action&lt;/a&gt; in a &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/TimerTask.html&quot;&gt;TimerTask&lt;/a&gt;.</source>
          <target state="translated">指定された&lt;a href=&quot;timer-task#kotlin.concurrent%24timerTask(kotlin.Function1((java.util.TimerTask,%20kotlin.Unit)))/action&quot;&gt;アクション&lt;/a&gt;を&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/TimerTask.html&quot;&gt;TimerTask&lt;/a&gt;でラップします。</target>
        </trans-unit>
        <trans-unit id="2525837a1ad8d7e8a649a7a5e6c45999c5553523" translate="yes" xml:space="preserve">
          <source>Write &lt;strong&gt;full, type-safe React applications with Kotlin/JS&lt;/strong&gt; using the &lt;a href=&quot;https://github.com/JetBrains/kotlin-wrappers&quot;&gt;&lt;code&gt;kotlin-wrappers&lt;/code&gt;&lt;/a&gt; provided by JetBrains, which provide convenient abstractions and deep integrations for one of the most popular JavaScript frameworks. &lt;code&gt;kotlin-wrappers&lt;/code&gt; also provides support for a select number of adjacent technologies like &lt;code&gt;react-redux&lt;/code&gt;, &lt;code&gt;react-router&lt;/code&gt;, or &lt;code&gt;styled-components&lt;/code&gt;. Interoperability with the JavaScript ecosystem also means that you can also use third-party React components and component libraries.</source>
          <target state="translated">ライト&lt;strong&gt;フル、タイプセーフではKotlin / JSを使用したアプリケーションリアクト&lt;/strong&gt;使用&lt;a href=&quot;https://github.com/JetBrains/kotlin-wrappers&quot;&gt; &lt;code&gt;kotlin-wrappers&lt;/code&gt; &lt;/a&gt;最も人気のあるJavaScriptフレームワークの1のための便利な抽象化と深い統合を提供JetBrainsの、で提供します。 &lt;code&gt;kotlin-wrappers&lt;/code&gt; は、 &lt;code&gt;react-router&lt;/code&gt; &lt;code&gt;react-redux&lt;/code&gt; 、react-router、 &lt;code&gt;styled-components&lt;/code&gt; などの隣接するテクノロジーの選択された数のサポートも提供します。 JavaScriptエコシステムとの相互運用性は、サードパーティのReactコンポーネントとコンポーネントライブラリも使用できることを意味します。</target>
        </trans-unit>
        <trans-unit id="ff7df02929ed6ce55a8f16204596caaf82c53075" translate="yes" xml:space="preserve">
          <source>Write operations</source>
          <target state="translated">書き込み操作</target>
        </trans-unit>
        <trans-unit id="16f06037425e5570c7fb6c4cb0b8e9b025bb037c" translate="yes" xml:space="preserve">
          <source>Write the application</source>
          <target state="translated">アプリケーションを書く</target>
        </trans-unit>
        <trans-unit id="5c829704c2a3eee8b986648971ed06cb5f976567" translate="yes" xml:space="preserve">
          <source>Write your code in the scratch and click &lt;strong&gt;Run&lt;/strong&gt;. The execution results will appear opposite the lines of your code.</source>
          <target state="translated">コードを最初から作成し、[ &lt;strong&gt;実行&lt;/strong&gt; ]をクリックし&lt;strong&gt;ます&lt;/strong&gt;。実行結果は、コードの行の反対側に表示されます。</target>
        </trans-unit>
        <trans-unit id="d5a79e41535865d72222565d75328e9ec50eab15" translate="yes" xml:space="preserve">
          <source>Writeable Objective-C properties overriding read-only properties of the superclass are represented as &lt;code&gt;setFoo()&lt;/code&gt; method for the property &lt;code&gt;foo&lt;/code&gt;. Same goes for a protocol's read-only properties that are implemented as mutable.</source>
          <target state="translated">スーパークラスの読み取り専用プロパティをオーバーライドする書き込み可能なObjective-Cプロパティは、プロパティ &lt;code&gt;foo&lt;/code&gt; の &lt;code&gt;setFoo()&lt;/code&gt; メソッドとして表されます。可変として実装されているプロトコルの読み取り専用プロパティについても同じことが言えます。</target>
        </trans-unit>
        <trans-unit id="b96451968bc66bdb3ac0027e8c45718ed0567089" translate="yes" xml:space="preserve">
          <source>Writing output in Kotlin is usually straightforward with &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.io/println&quot;&gt;println(&amp;hellip;)&lt;/a&gt; calls and using Kotlin's &lt;a href=&quot;../reference/basic-types#string-templates&quot;&gt;string templates&lt;/a&gt;. However, care must be taken when output contains on order of 10&lt;sup&gt;5&lt;/sup&gt; lines or more. Issuing so many &lt;code&gt;println&lt;/code&gt; calls is too slow, since the output in Kotlin is automatically flushed after each line. A faster way to write many lines from an array or a list is using &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/join-to-string&quot;&gt;joinToString()&lt;/a&gt; function with &lt;code&gt;&quot;\n&quot;&lt;/code&gt; as the separator, like this:</source>
          <target state="translated">Kotlinでの出力の書き込みは、通常、&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.io/println&quot;&gt;println（&amp;hellip;）&lt;/a&gt;呼び出しとKotlinの&lt;a href=&quot;../reference/basic-types#string-templates&quot;&gt;文字列テンプレート&lt;/a&gt;を使用すると簡単です。ただし、出力に10 &lt;sup&gt;5&lt;/sup&gt;行以上含まれる場合は注意が必要です。Kotlinの出力は各行の後に自動的にフラッシュされるため、非常に多くの &lt;code&gt;println&lt;/code&gt; 呼び出しを発行するのは遅すぎます。配列またはリストから多くの行を書き込むより速い方法は、次のように、 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; をセパレーターとして&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/join-to-string&quot;&gt;joinToString（）&lt;/a&gt;関数を使用することです。</target>
        </trans-unit>
        <trans-unit id="ab2816d4bb9622be7220e5163963f6a9c487ee4d" translate="yes" xml:space="preserve">
          <source>Writing tests</source>
          <target state="translated">筆記試験</target>
        </trans-unit>
        <trans-unit id="9ef22deec2645bc05aadf8f135a7bff939813776" translate="yes" xml:space="preserve">
          <source>Written common tests which are executed on every platform.</source>
          <target state="translated">すべてのプラットフォームで実行される共通テストを記述しました。</target>
        </trans-unit>
        <trans-unit id="fd2be2d7287c5cdb16fe41c84b1e6ca191ff755e" translate="yes" xml:space="preserve">
          <source>Wrong common supertype between raw and integer literal type leads to unsound code</source>
          <target state="translated">raw リテラル型と整数リテラル型の間に誤った共通のスーパー型があると、不健全なコードになります。</target>
        </trans-unit>
        <trans-unit id="854c8fc48ee154c6555f79a9bf3716b40f710db3" translate="yes" xml:space="preserve">
          <source>Wrong emission withContext</source>
          <target state="translated">誤った排出とContext</target>
        </trans-unit>
        <trans-unit id="541421193abf48f2287369752c7bf0243245c291" translate="yes" xml:space="preserve">
          <source>Wrong overload resolution for contravariant types with nullable type arguments</source>
          <target state="translated">ヌル可能な型引数を持つ矛盾型に対する誤ったオーバーロード解決</target>
        </trans-unit>
        <trans-unit id="f216eec525b148735e7bf76a9146b212361d45a9" translate="yes" xml:space="preserve">
          <source>Wrote common tests which are executed on every platform.</source>
          <target state="translated">すべてのプラットフォームで実行される共通テストを書きました。</target>
        </trans-unit>
        <trans-unit id="8bc69ef99140607442e7db36f023118fd57bd0f0" translate="yes" xml:space="preserve">
          <source>X64</source>
          <target state="translated">X64</target>
        </trans-unit>
        <trans-unit id="c5b176396b5ad771a343d5324e35e073e54c2249" translate="yes" xml:space="preserve">
          <source>X86</source>
          <target state="translated">X86</target>
        </trans-unit>
        <trans-unit id="5fff9cda50156cd056976ef35552984685930eca" translate="yes" xml:space="preserve">
          <source>XMLHttpRequestResponseType</source>
          <target state="translated">XMLHttpRequestResponseType</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
