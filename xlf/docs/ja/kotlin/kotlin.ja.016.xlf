<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="kotlin">
    <body>
      <group id="kotlin">
        <trans-unit id="c5fa62c81704299df516dd7c041a8d480c196b9b" translate="yes" xml:space="preserve">
          <source>If a default type qualifier uses a type qualifier nickname and they are both &lt;code&gt;@UnderMigration&lt;/code&gt;, the status from the default type qualifier is used.</source>
          <target state="translated">デフォルトのタイプ修飾子がタイプ修飾子のニックネームを使用し、両方が &lt;code&gt;@UnderMigration&lt;/code&gt; である場合、デフォルトのタイプ修飾子のステータスが使用されます。</target>
        </trans-unit>
        <trans-unit id="8fb1b7879228c51bc49251497614be1617615253" translate="yes" xml:space="preserve">
          <source>If a file doesn't declare a package, it belongs to the nameless &lt;em&gt;default package&lt;/em&gt;. This should be avoided, as it will make it hard to reference the symbols from that file in case of naming conflicts (you can't explicitly import the empty package).</source>
          <target state="translated">ファイルがパッケージを宣言していない場合、そのファイルは名前のない&lt;em&gt;デフォルトパッケージに&lt;/em&gt;属してい&lt;em&gt;ます&lt;/em&gt;。名前の競合が発生した場合にそのファイルからシンボルを参照することが困難になるため、これは避けてください（空のパッケージを明示的にインポートすることはできません）。</target>
        </trans-unit>
        <trans-unit id="f5fbea4c3aea4496e7e7b00414d2fcaa5869dd61" translate="yes" xml:space="preserve">
          <source>If a function does not return any useful value, its return type is &lt;code&gt;Unit&lt;/code&gt;. &lt;code&gt;Unit&lt;/code&gt; is a type with only one value - &lt;code&gt;Unit&lt;/code&gt;. This value does not have to be returned explicitly:</source>
          <target state="translated">関数が有用な値を返さない場合、その戻り値の型は &lt;code&gt;Unit&lt;/code&gt; です。 &lt;code&gt;Unit&lt;/code&gt; 一つの値だけを持つタイプである- &lt;code&gt;Unit&lt;/code&gt; 。この値は明示的に返される必要はありません：</target>
        </trans-unit>
        <trans-unit id="586ae5a6f0a2e9992a680dbe096f9f0a203405b4" translate="yes" xml:space="preserve">
          <source>If a function returns Unit, the return type should be omitted:</source>
          <target state="translated">関数がUnitを返す場合は、戻り値の型を省略します。</target>
        </trans-unit>
        <trans-unit id="26ffbbf2f8c7a69e516fd6f5e5fb01c4807e2577" translate="yes" xml:space="preserve">
          <source>If a generic type has several type parameters each of them can be projected independently. For example, if the type is declared as &lt;code&gt;interface Function&amp;lt;in T, out U&amp;gt;&lt;/code&gt; we can imagine the following star-projections:</source>
          <target state="translated">ジェネリック型に複数の型パラメーターがある場合、それぞれを独立して投影できます。たとえば、型が &lt;code&gt;interface Function&amp;lt;in T, out U&amp;gt;&lt;/code&gt; として宣言されている場合、次の星型投影を想像できます。</target>
        </trans-unit>
        <trans-unit id="70975e077538a847ffe5a0e5b87f2c6b9c2f7e0c" translate="yes" xml:space="preserve">
          <source>If a library author marks a declaration from a library's API as &lt;a href=&quot;#requiring-opt-in-for-api&quot;&gt;&lt;em&gt;requiring opt-in&lt;/em&gt;&lt;/a&gt;, you should give an explicit consent for using it in your code. There are several ways to opt in to such APIs, all applicable without technical limitations. You are free to choose the way that you find best for your situation.</source>
          <target state="translated">ライブラリの作成者がライブラリのAPIからの宣言&lt;a href=&quot;#requiring-opt-in-for-api&quot;&gt;&lt;em&gt;をオプトインが必要であると&lt;/em&gt;&lt;/a&gt;マークした場合は、コードでそれを使用することに明示的に同意する必要があります。このようなAPIにオプトインする方法はいくつかあり、すべて技術的な制限なしに適用できます。自分の状況に最適な方法を自由に選択できます。</target>
        </trans-unit>
        <trans-unit id="c54bed7a1e50c0cec37b385196df44d20ab05f40" translate="yes" xml:space="preserve">
          <source>If a library consumer defines variants that are missing in the library, they need to provide matching fallbacks. For example, if a library does not have or does not publish a staging build type, the library consumer must provide a fallback for the consumers who have such a build type, specifying at least one of the build types that the library publishes:</source>
          <target state="translated">ライブラリのコンシューマがライブラリにないバリアントを定義した場合、ライブラリのコンシューマは一致するフォールバックを提供する必要があります。例えば、ライブラリがステージングビルドタイプを持っていない、または公開していない場合、ライブラリのコンシューマは、そのようなビルドタイプを持っているコンシューマのために、ライブラリが公開しているビルドタイプのうち少なくとも一つを指定してフォールバックを提供しなければなりません。</target>
        </trans-unit>
        <trans-unit id="de5d80fa791bb5a89bb7999f43e44154d9f7a1b7" translate="yes" xml:space="preserve">
          <source>If a library has a 'root' publication, the consumer may specify a single dependency on the library as a whole in a common source set, and a corresponding platform-specific variant will be chosen, if available, for each of the compilations that include this dependency. Consider a &lt;code&gt;sample-lib&lt;/code&gt; library built for the JVM and JS and published with a 'root' publication:</source>
          <target state="translated">ライブラリに「ルート」パブリケーションがある場合、コンシューマは共通のソースセットでライブラリ全体に対する単一の依存関係を指定でき、対応するプラットフォーム固有のバリアントが利用可能な場合は、以下を含むコンパイルごとに選択されますこの依存関係。JVMとJS用にビルドされ、「ルート」パブリケーションで公開された &lt;code&gt;sample-lib&lt;/code&gt; ライブラリライブラリを考えます。</target>
        </trans-unit>
        <trans-unit id="2b6d1027059f87a94c39781325c4a38d3fd36ee6" translate="yes" xml:space="preserve">
          <source>If a member function or property is declared as &lt;code&gt;open&lt;/code&gt;, subclasses may &lt;em&gt;override&lt;/em&gt; it by providing a new implementation. Let's say that &lt;code&gt;MotorVehicle&lt;/code&gt; declares this function:</source>
          <target state="translated">メンバー関数またはプロパティが &lt;code&gt;open&lt;/code&gt; として宣言されている場合、サブクラスは新しい実装を提供することによってそれを&lt;em&gt;オーバーライド&lt;/em&gt;でき&lt;em&gt;ます&lt;/em&gt;。ことをしてみましょうと言う &lt;code&gt;MotorVehicle&lt;/code&gt; は、この関数を宣言します。</target>
        </trans-unit>
        <trans-unit id="3b05658c0676c78c2f6ecac73f01698365f225fb" translate="yes" xml:space="preserve">
          <source>If a method has N parameters and M of which have default values, M overloads are generated: the first one takes N-1 parameters (all but the last one that takes a default value), the second takes N-2 parameters, and so on.</source>
          <target state="translated">あるメソッドがN個のパラメータを持ち、そのうちのM個がデフォルト値を持つ場合、M個のオーバーロードが生成されます:最初のものはN-1個のパラメータを取り(デフォルト値を取る最後のものを除いてすべて)、2番目のものはN-2個のパラメータを取ります。</target>
        </trans-unit>
        <trans-unit id="a6a3dbe7a3c930fff25db8be2ac42bb4869e7083" translate="yes" xml:space="preserve">
          <source>If a module is an endpoint application which is not published, use &lt;code&gt;implementation&lt;/code&gt; dependencies instead of &lt;code&gt;api&lt;/code&gt; dependencies.</source>
          <target state="translated">モジュールが公開されていないエンドポイントアプリケーションである場合は、 &lt;code&gt;api&lt;/code&gt; 依存関係の代わりに &lt;code&gt;implementation&lt;/code&gt; 依存関係を使用してください。</target>
        </trans-unit>
        <trans-unit id="187f8c5b91bd6882618c5a62bdf223a239fa7e78" translate="yes" xml:space="preserve">
          <source>If a non-abstract class does not declare any constructors (primary or secondary), it will have a generated primary constructor with no arguments. The visibility of the constructor will be public. If you do not want your class to have a public constructor, you need to declare an empty primary constructor with non-default visibility:</source>
          <target state="translated">抽象クラスではないクラスがコンストラクタ (プライマリまたはセカンダリ)を宣言していない場合は、引数を持たないプライマリコンストラクタが生成されます。コンストラクタの可視性はパブリックになります。クラスにパブリックなコンストラクタを持たせたくない場合は、 デフォルトではない可視性を持つ空のプライマリコンストラクタを宣言する必要があります。</target>
        </trans-unit>
        <trans-unit id="29905ed43abbefe9d905d1bc7ab8a797a47bb7d9" translate="yes" xml:space="preserve">
          <source>If a project consists of both Kotlin and Java source code, while it is possible to use &lt;em&gt;kotlinc&lt;/em&gt;, to avoid repetition of task parameters, it is recommended to use &lt;em&gt;withKotlin&lt;/em&gt; task:</source>
          <target state="translated">プロジェクトがKotlinとJavaソースコードの両方で構成されている場合、&lt;em&gt;kotlinc&lt;/em&gt;を使用することは可能ですが、タスクパラメーターの繰り返しを避けるため、&lt;em&gt;withKotlin&lt;/em&gt;タスクを使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="609654c2fad938d0263a48e6bf332c23223482ab" translate="yes" xml:space="preserve">
          <source>If a project consists of multiple source roots, use &lt;em&gt;src&lt;/em&gt; as elements to define paths:</source>
          <target state="translated">プロジェクトが複数のソースルートで構成されている場合は、&lt;em&gt;src&lt;/em&gt;を要素として使用してパスを定義します。</target>
        </trans-unit>
        <trans-unit id="6ed938136219853ee5b7c06664d635c5b5eff6f0" translate="yes" xml:space="preserve">
          <source>If a sequence operation returns another sequence, which is produced lazily, it's called &lt;em&gt;intermediate&lt;/em&gt;. Otherwise, the operation is &lt;em&gt;terminal&lt;/em&gt;. Examples of terminal operations are &lt;a href=&quot;constructing-collections#copying&quot;&gt;&lt;code&gt;toList()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;collection-aggregate&quot;&gt;&lt;code&gt;sum()&lt;/code&gt;&lt;/a&gt;. Sequence elements can be retrieved only with terminal operations.</source>
          <target state="translated">シーケンス操作が遅延生成される別のシーケンスを返す場合、それは&lt;em&gt;中間&lt;/em&gt;と呼ばれます。それ以外の場合、操作は&lt;em&gt;terminal&lt;/em&gt;です。端末操作の例は、&lt;a href=&quot;constructing-collections#copying&quot;&gt; &lt;code&gt;toList()&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;collection-aggregate&quot;&gt; &lt;code&gt;sum()&lt;/code&gt; &lt;/a&gt;です。シーケンス要素は、ターミナル操作でのみ取得できます。</target>
        </trans-unit>
        <trans-unit id="30e6ccb06323d447af741e2670a8825971c56bf1" translate="yes" xml:space="preserve">
          <source>If a supertype has a constructor, appropriate constructor parameters must be passed to it. Many supertypes may be specified as a comma-separated list after the colon:</source>
          <target state="translated">スーパータイプがコンストラクタを持っている場合は、適切なコンストラクタのパラメータを渡さなければなりません。多くのスーパータイプは、コロンの後にカンマ区切りのリストとして指定することができます。</target>
        </trans-unit>
        <trans-unit id="71ee75455c68258fcc7798b0e5a90d8dadcef5cd" translate="yes" xml:space="preserve">
          <source>If a supertype has the &lt;code&gt;componentN()&lt;/code&gt; functions that are &lt;em&gt;open&lt;/em&gt; and return compatible types, the corresponding functions are generated for the data class and override those of the supertype. If the functions of the supertype cannot be overridden due to incompatible signatures or being final, an error is reported;</source>
          <target state="translated">スーパータイプに、&lt;em&gt;オープン&lt;/em&gt;で互換性のあるタイプを返す &lt;code&gt;componentN()&lt;/code&gt; 関数がある場合、対応する関数がデータクラスに対して生成され、スーパータイプの関数をオーバーライドします。互換性のないシグネチャまたはfinalであるためにスーパータイプの関数をオーバーライドできない場合、エラーが報告されます。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="28f4bb4cbd876a2710b0efbbf4b0592357748708" translate="yes" xml:space="preserve">
          <source>If a top-level declaration is marked &lt;em&gt;private&lt;/em&gt;, it is private to the file it's declared in (see &lt;a href=&quot;visibility-modifiers&quot;&gt;Visibility Modifiers&lt;/a&gt;).</source>
          <target state="translated">トップレベルの宣言が&lt;em&gt;private&lt;/em&gt;とマークされている場合、宣言されたファイルに対してプライベートです（&lt;a href=&quot;visibility-modifiers&quot;&gt;Visibility Modifiersを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="8f9335847e2c530d21bcd3080b073f4d1f543f5f" translate="yes" xml:space="preserve">
          <source>If all you want to do with a constructor parameter value is to assign it to a property with the same name, you can declare the property in the primary constructor parameter list (the oneliner below is sufficient for both declaring the properties, declaring the constructor parameters, and initializing the properties with the parameters):</source>
          <target state="translated">コンストラクタのパラメータ値を同じ名前のプロパティに代入するだけの場合は、そのプロパティをプライマリ コンストラクタのパラメータ リストで宣言することができます (プロパティの宣言、コンストラクタのパラメータの宣言、およびパラメータを使用したプロパティの初期化の両方を行うには、以下のオネリで十分です)。</target>
        </trans-unit>
        <trans-unit id="286a0bf4d2cc8a5a12f2292b0ceccc9207bc4770" translate="yes" xml:space="preserve">
          <source>If an annotation is used as a parameter of another annotation, its name is not prefixed with the @ character:</source>
          <target state="translated">アノテーションが別のアノテーションのパラメータとして使用されている場合、その名前の前には @ 文字は付けられません。</target>
        </trans-unit>
        <trans-unit id="10147e3b40c783598d2bd9a60f764d64051cd74f" translate="yes" xml:space="preserve">
          <source>If an annotation type is annotated with both &lt;a href=&quot;https://aalmiray.github.io/jsr-305/apidocs/javax/annotation/meta/TypeQualifierNickname.html&quot;&gt;&lt;code&gt;@TypeQualifierNickname&lt;/code&gt;&lt;/a&gt; and JSR-305 &lt;code&gt;@Nonnull&lt;/code&gt; (or its another nickname, such as &lt;code&gt;@CheckForNull&lt;/code&gt;), then the annotation type is itself used for retrieving precise nullability and has the same meaning as that nullability annotation:</source>
          <target state="translated">注釈型に&lt;a href=&quot;https://aalmiray.github.io/jsr-305/apidocs/javax/annotation/meta/TypeQualifierNickname.html&quot;&gt; &lt;code&gt;@TypeQualifierNickname&lt;/code&gt; &lt;/a&gt;とJSR-305 &lt;code&gt;@Nonnull&lt;/code&gt; （または@CheckForNullなどの別のニックネーム）の両方が注釈されている場合、注釈型自体が正確な &lt;code&gt;@CheckForNull&lt;/code&gt; 取得に使用され、null可能性注釈と同じ意味になります。</target>
        </trans-unit>
        <trans-unit id="f981f8a8e6f98948229b86561835f71dd548b23d" translate="yes" xml:space="preserve">
          <source>If an extension is declared outside its receiver type, such an extension cannot access the receiver's &lt;code&gt;private&lt;/code&gt; members.</source>
          <target state="translated">エクステンションがそのレシーバータイプ外で宣言されている場合、そのようなエクステンションはレシーバーの &lt;code&gt;private&lt;/code&gt; メンバーにアクセスできません。</target>
        </trans-unit>
        <trans-unit id="61dcbc44eee3bab1f0e103c1b87baa369fec0f94" translate="yes" xml:space="preserve">
          <source>If an external build system is used for configuring the project, and it's been decided not to share &lt;code&gt;.idea/codeStyle&lt;/code&gt; folder, Kotlin Coding Conventions can be forced with an additional property:</source>
          <target state="translated">プロジェクトの構成に外部ビルドシステムが使用され、 &lt;code&gt;.idea/codeStyle&lt;/code&gt; フォルダーを共有しないことが決定された場合、追加のプロパティを使用してKotlinコーディング規約を強制できます。</target>
        </trans-unit>
        <trans-unit id="d93cee5a226e1db8584fc451a3062eec2e7267d3" translate="yes" xml:space="preserve">
          <source>If an object is frozen it can be checked with an extension property &lt;code&gt;isFrozen&lt;/code&gt;, and if it is, object sharing is allowed. Currently, Kotlin/Native runtime only freezes the enum objects after creation, although additional autofreezing of certain provably immutable objects could be implemented in the future.</source>
          <target state="translated">オブジェクトがフリーズしている場合は、拡張プロパティ &lt;code&gt;isFrozen&lt;/code&gt; で確認できます。フリーズしている場合は、オブジェクトの共有が許可されます。現在、Kotlin / Nativeランタイムは、作成後にenumオブジェクトのみをフリーズしますが、特定の不変のオブジェクトの追加の自動フリーズは将来実装される可能性があります。</target>
        </trans-unit>
        <trans-unit id="d745839ade06f63274de839883364751868e1c68" translate="yes" xml:space="preserve">
          <source>If an object is transferred in &lt;code&gt;UNSAFE&lt;/code&gt; mode and is still accessible from multiple concurrent executors, program will likely crash unexpectedly, so consider that last resort in optimizing, not a general purpose mechanism.</source>
          <target state="translated">オブジェクトが &lt;code&gt;UNSAFE&lt;/code&gt; モードで転送され、複数の同時実行プログラムから引き続きアクセスできる場合、プログラムが予期せずクラッシュする可能性があるため、汎用メカニズムではなく、最適化の最後の手段を検討してください。</target>
        </trans-unit>
        <trans-unit id="2fbb13db366dcb9336c03ff5dd678511b1b8d160" translate="yes" xml:space="preserve">
          <source>If any errors occur during the copying, then further actions will depend on the result of the call to &lt;code&gt;onError(File, IOException)&lt;/code&gt; function, that will be called with arguments, specifying the file that caused the error and the exception itself. By default this function rethrows exceptions.</source>
          <target state="translated">コピー中にエラーが発生した場合、その後のアクションは &lt;code&gt;onError(File, IOException)&lt;/code&gt; 関数の呼び出しの結果によって異なります。これは、エラーの原因となったファイルと例外自体を指定して、引数で呼び出されます。デフォルトでは、この関数は例外を再スローします。</target>
        </trans-unit>
        <trans-unit id="aad3cd8dfcbdf7511572b2939855bed2ac55b99b" translate="yes" xml:space="preserve">
          <source>If any of arrays contains itself on any nesting level that reference is rendered as &lt;code&gt;&quot;[...]&quot;&lt;/code&gt; to prevent recursion.</source>
          <target state="translated">配列のいずれかがネストレベルでそれ自体を含む場合、その参照は再帰を防ぐために &lt;code&gt;&quot;[...]&quot;&lt;/code&gt; としてレンダリングされます。</target>
        </trans-unit>
        <trans-unit id="e3f9db9bf25bbec3f31f98164a22576425cc669b" translate="yes" xml:space="preserve">
          <source>If any of arrays contains itself on any nesting level the behavior is undefined.</source>
          <target state="translated">配列のいずれかがどの入れ子レベルにもそれ自身を含む場合、動作は未定義です。</target>
        </trans-unit>
        <trans-unit id="9c5d9097483a5bb9ad684d81ab29afc4db54e1ed" translate="yes" xml:space="preserve">
          <source>If any of elements is &lt;code&gt;NaN&lt;/code&gt; returns &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">要素のいずれかがある場合は &lt;code&gt;NaN&lt;/code&gt; を返す &lt;code&gt;NaN&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="97176cd6bad6dda53932f8ad2eae19bbc9012e41" translate="yes" xml:space="preserve">
          <source>If any of two pairs would have the same key the last one gets added to the map.</source>
          <target state="translated">同じキーを持つペアが2つある場合、最後のペアがマップに追加されます。</target>
        </trans-unit>
        <trans-unit id="6fdd79609c8f85fa31ce635ac8b9cd8b21fe6cf8" translate="yes" xml:space="preserve">
          <source>If any of values produced by &lt;a href=&quot;max-of#kotlin.collections%24maxOf(kotlin.Array((kotlin.collections.maxOf.T)),%20kotlin.Function1((kotlin.collections.maxOf.T,%20kotlin.Double)))/selector&quot;&gt;selector&lt;/a&gt; function is &lt;code&gt;NaN&lt;/code&gt;, the returned result is &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;max-of#kotlin.collections%24maxOf(kotlin.Array((kotlin.collections.maxOf.T)),%20kotlin.Function1((kotlin.collections.maxOf.T,%20kotlin.Double)))/selector&quot;&gt;セレクター&lt;/a&gt;関数によって生成された値のいずれかが &lt;code&gt;NaN&lt;/code&gt; の場合、返される結果は &lt;code&gt;NaN&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="cd1a69eb514868f3014ac9ebddc5f5d735edf89e" translate="yes" xml:space="preserve">
          <source>If any of values produced by &lt;a href=&quot;max-of#kotlin.collections%24maxOf(kotlin.collections.Iterable((kotlin.collections.maxOf.T)),%20kotlin.Function1((kotlin.collections.maxOf.T,%20kotlin.Double)))/selector&quot;&gt;selector&lt;/a&gt; function is &lt;code&gt;NaN&lt;/code&gt;, the returned result is &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;max-of#kotlin.collections%24maxOf(kotlin.collections.Iterable((kotlin.collections.maxOf.T)),%20kotlin.Function1((kotlin.collections.maxOf.T,%20kotlin.Double)))/selector&quot;&gt;セレクター&lt;/a&gt;関数によって生成された値のいずれかが &lt;code&gt;NaN&lt;/code&gt; の場合、返される結果は &lt;code&gt;NaN&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="6e189e501066f4ac42ca51a4be243a3ad0abadf5" translate="yes" xml:space="preserve">
          <source>If any of values produced by &lt;a href=&quot;max-of#kotlin.collections%24maxOf(kotlin.collections.Map((kotlin.collections.maxOf.K,%20kotlin.collections.maxOf.V)),%20kotlin.Function1((kotlin.collections.Map.Entry((kotlin.collections.maxOf.K,%20kotlin.collections.maxOf.V)),%20kotlin.Double)))/selector&quot;&gt;selector&lt;/a&gt; function is &lt;code&gt;NaN&lt;/code&gt;, the returned result is &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;max-of#kotlin.collections%24maxOf(kotlin.collections.Map((kotlin.collections.maxOf.K,%20kotlin.collections.maxOf.V)),%20kotlin.Function1((kotlin.collections.Map.Entry((kotlin.collections.maxOf.K,%20kotlin.collections.maxOf.V)),%20kotlin.Double)))/selector&quot;&gt;セレクター&lt;/a&gt;関数によって生成された値のいずれかが &lt;code&gt;NaN&lt;/code&gt; の場合、返される結果は &lt;code&gt;NaN&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="96b36a40f387f4c8df6c324c6dc2b703f21da3c2" translate="yes" xml:space="preserve">
          <source>If any of values produced by &lt;a href=&quot;max-of#kotlin.sequences%24maxOf(kotlin.sequences.Sequence((kotlin.sequences.maxOf.T)),%20kotlin.Function1((kotlin.sequences.maxOf.T,%20kotlin.Double)))/selector&quot;&gt;selector&lt;/a&gt; function is &lt;code&gt;NaN&lt;/code&gt;, the returned result is &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;max-of#kotlin.sequences%24maxOf(kotlin.sequences.Sequence((kotlin.sequences.maxOf.T)),%20kotlin.Function1((kotlin.sequences.maxOf.T,%20kotlin.Double)))/selector&quot;&gt;セレクター&lt;/a&gt;関数によって生成された値のいずれかが &lt;code&gt;NaN&lt;/code&gt; の場合、返される結果は &lt;code&gt;NaN&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="b32c87f07f448e5c852864c4c07255913a33f154" translate="yes" xml:space="preserve">
          <source>If any of values produced by &lt;a href=&quot;max-of#kotlin.text%24maxOf(kotlin.CharSequence,%20kotlin.Function1((kotlin.Char,%20kotlin.Double)))/selector&quot;&gt;selector&lt;/a&gt; function is &lt;code&gt;NaN&lt;/code&gt;, the returned result is &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;max-of#kotlin.text%24maxOf(kotlin.CharSequence,%20kotlin.Function1((kotlin.Char,%20kotlin.Double)))/selector&quot;&gt;セレクター&lt;/a&gt;関数によって生成された値のいずれかが &lt;code&gt;NaN&lt;/code&gt; の場合、返される結果は &lt;code&gt;NaN&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="973ed91938d379c81da13b3ca48e010cd6c1309f" translate="yes" xml:space="preserve">
          <source>If any of values produced by &lt;a href=&quot;max-of-or-null#kotlin.collections%24maxOfOrNull(kotlin.Array((kotlin.collections.maxOfOrNull.T)),%20kotlin.Function1((kotlin.collections.maxOfOrNull.T,%20kotlin.Double)))/selector&quot;&gt;selector&lt;/a&gt; function is &lt;code&gt;NaN&lt;/code&gt;, the returned result is &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;max-of-or-null#kotlin.collections%24maxOfOrNull(kotlin.Array((kotlin.collections.maxOfOrNull.T)),%20kotlin.Function1((kotlin.collections.maxOfOrNull.T,%20kotlin.Double)))/selector&quot;&gt;セレクター&lt;/a&gt;関数によって生成された値のいずれかが &lt;code&gt;NaN&lt;/code&gt; の場合、返される結果は &lt;code&gt;NaN&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="2466fddfdfd68288ce0227609640affb7f9beb8c" translate="yes" xml:space="preserve">
          <source>If any of values produced by &lt;a href=&quot;max-of-or-null#kotlin.collections%24maxOfOrNull(kotlin.collections.Iterable((kotlin.collections.maxOfOrNull.T)),%20kotlin.Function1((kotlin.collections.maxOfOrNull.T,%20kotlin.Double)))/selector&quot;&gt;selector&lt;/a&gt; function is &lt;code&gt;NaN&lt;/code&gt;, the returned result is &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;max-of-or-null#kotlin.collections%24maxOfOrNull(kotlin.collections.Iterable((kotlin.collections.maxOfOrNull.T)),%20kotlin.Function1((kotlin.collections.maxOfOrNull.T,%20kotlin.Double)))/selector&quot;&gt;セレクター&lt;/a&gt;関数によって生成された値のいずれかが &lt;code&gt;NaN&lt;/code&gt; の場合、返される結果は &lt;code&gt;NaN&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="30f52c50e23a311e6818d0613ec256f55699413d" translate="yes" xml:space="preserve">
          <source>If any of values produced by &lt;a href=&quot;max-of-or-null#kotlin.collections%24maxOfOrNull(kotlin.collections.Map((kotlin.collections.maxOfOrNull.K,%20kotlin.collections.maxOfOrNull.V)),%20kotlin.Function1((kotlin.collections.Map.Entry((kotlin.collections.maxOfOrNull.K,%20kotlin.collections.maxOfOrNull.V)),%20kotlin.Double)))/selector&quot;&gt;selector&lt;/a&gt; function is &lt;code&gt;NaN&lt;/code&gt;, the returned result is &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;max-of-or-null#kotlin.collections%24maxOfOrNull(kotlin.collections.Map((kotlin.collections.maxOfOrNull.K,%20kotlin.collections.maxOfOrNull.V)),%20kotlin.Function1((kotlin.collections.Map.Entry((kotlin.collections.maxOfOrNull.K,%20kotlin.collections.maxOfOrNull.V)),%20kotlin.Double)))/selector&quot;&gt;セレクター&lt;/a&gt;関数によって生成された値のいずれかが &lt;code&gt;NaN&lt;/code&gt; の場合、返される結果は &lt;code&gt;NaN&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="ccf1c9aefb939e391c556149e3b88356bdd369b8" translate="yes" xml:space="preserve">
          <source>If any of values produced by &lt;a href=&quot;max-of-or-null#kotlin.sequences%24maxOfOrNull(kotlin.sequences.Sequence((kotlin.sequences.maxOfOrNull.T)),%20kotlin.Function1((kotlin.sequences.maxOfOrNull.T,%20kotlin.Double)))/selector&quot;&gt;selector&lt;/a&gt; function is &lt;code&gt;NaN&lt;/code&gt;, the returned result is &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;max-of-or-null#kotlin.sequences%24maxOfOrNull(kotlin.sequences.Sequence((kotlin.sequences.maxOfOrNull.T)),%20kotlin.Function1((kotlin.sequences.maxOfOrNull.T,%20kotlin.Double)))/selector&quot;&gt;セレクター&lt;/a&gt;関数によって生成された値のいずれかが &lt;code&gt;NaN&lt;/code&gt; の場合、返される結果は &lt;code&gt;NaN&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="c39e75bf5be9b08a47160d2b17149dae147dbe4d" translate="yes" xml:space="preserve">
          <source>If any of values produced by &lt;a href=&quot;max-of-or-null#kotlin.text%24maxOfOrNull(kotlin.CharSequence,%20kotlin.Function1((kotlin.Char,%20kotlin.Double)))/selector&quot;&gt;selector&lt;/a&gt; function is &lt;code&gt;NaN&lt;/code&gt;, the returned result is &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;max-of-or-null#kotlin.text%24maxOfOrNull(kotlin.CharSequence,%20kotlin.Function1((kotlin.Char,%20kotlin.Double)))/selector&quot;&gt;セレクター&lt;/a&gt;関数によって生成された値のいずれかが &lt;code&gt;NaN&lt;/code&gt; の場合、返される結果は &lt;code&gt;NaN&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="a3801e7c556a007fa15fa5fdf086b701342f4493" translate="yes" xml:space="preserve">
          <source>If any of values produced by &lt;a href=&quot;min-of#kotlin.collections%24minOf(kotlin.Array((kotlin.collections.minOf.T)),%20kotlin.Function1((kotlin.collections.minOf.T,%20kotlin.Double)))/selector&quot;&gt;selector&lt;/a&gt; function is &lt;code&gt;NaN&lt;/code&gt;, the returned result is &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;min-of#kotlin.collections%24minOf(kotlin.Array((kotlin.collections.minOf.T)),%20kotlin.Function1((kotlin.collections.minOf.T,%20kotlin.Double)))/selector&quot;&gt;セレクター&lt;/a&gt;関数によって生成された値のいずれかが &lt;code&gt;NaN&lt;/code&gt; の場合、返される結果は &lt;code&gt;NaN&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="4f54dcaf8c15a4fde48f9f8e9fd9ddcdcff34c0f" translate="yes" xml:space="preserve">
          <source>If any of values produced by &lt;a href=&quot;min-of#kotlin.collections%24minOf(kotlin.collections.Iterable((kotlin.collections.minOf.T)),%20kotlin.Function1((kotlin.collections.minOf.T,%20kotlin.Double)))/selector&quot;&gt;selector&lt;/a&gt; function is &lt;code&gt;NaN&lt;/code&gt;, the returned result is &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;min-of#kotlin.collections%24minOf(kotlin.collections.Iterable((kotlin.collections.minOf.T)),%20kotlin.Function1((kotlin.collections.minOf.T,%20kotlin.Double)))/selector&quot;&gt;セレクター&lt;/a&gt;関数によって生成された値のいずれかが &lt;code&gt;NaN&lt;/code&gt; の場合、返される結果は &lt;code&gt;NaN&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="59f702b5ac5ebb0f583e7b36eff4014222ccd52b" translate="yes" xml:space="preserve">
          <source>If any of values produced by &lt;a href=&quot;min-of#kotlin.collections%24minOf(kotlin.collections.Map((kotlin.collections.minOf.K,%20kotlin.collections.minOf.V)),%20kotlin.Function1((kotlin.collections.Map.Entry((kotlin.collections.minOf.K,%20kotlin.collections.minOf.V)),%20kotlin.Double)))/selector&quot;&gt;selector&lt;/a&gt; function is &lt;code&gt;NaN&lt;/code&gt;, the returned result is &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;min-of#kotlin.collections%24minOf(kotlin.collections.Map((kotlin.collections.minOf.K,%20kotlin.collections.minOf.V)),%20kotlin.Function1((kotlin.collections.Map.Entry((kotlin.collections.minOf.K,%20kotlin.collections.minOf.V)),%20kotlin.Double)))/selector&quot;&gt;セレクター&lt;/a&gt;関数によって生成された値のいずれかが &lt;code&gt;NaN&lt;/code&gt; の場合、返される結果は &lt;code&gt;NaN&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="36401114fbe626769f0b61474ddddd4a4ed62ae5" translate="yes" xml:space="preserve">
          <source>If any of values produced by &lt;a href=&quot;min-of#kotlin.sequences%24minOf(kotlin.sequences.Sequence((kotlin.sequences.minOf.T)),%20kotlin.Function1((kotlin.sequences.minOf.T,%20kotlin.Double)))/selector&quot;&gt;selector&lt;/a&gt; function is &lt;code&gt;NaN&lt;/code&gt;, the returned result is &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;min-of#kotlin.sequences%24minOf(kotlin.sequences.Sequence((kotlin.sequences.minOf.T)),%20kotlin.Function1((kotlin.sequences.minOf.T,%20kotlin.Double)))/selector&quot;&gt;セレクター&lt;/a&gt;関数によって生成された値のいずれかが &lt;code&gt;NaN&lt;/code&gt; の場合、返される結果は &lt;code&gt;NaN&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="5171cee310607ada547cb3abbac9f3369902a249" translate="yes" xml:space="preserve">
          <source>If any of values produced by &lt;a href=&quot;min-of#kotlin.text%24minOf(kotlin.CharSequence,%20kotlin.Function1((kotlin.Char,%20kotlin.Double)))/selector&quot;&gt;selector&lt;/a&gt; function is &lt;code&gt;NaN&lt;/code&gt;, the returned result is &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;min-of#kotlin.text%24minOf(kotlin.CharSequence,%20kotlin.Function1((kotlin.Char,%20kotlin.Double)))/selector&quot;&gt;セレクター&lt;/a&gt;関数によって生成された値のいずれかが &lt;code&gt;NaN&lt;/code&gt; の場合、返される結果は &lt;code&gt;NaN&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="b49ed92744163e0134f5a22997e4ff3f21ace05b" translate="yes" xml:space="preserve">
          <source>If any of values produced by &lt;a href=&quot;min-of-or-null#kotlin.collections%24minOfOrNull(kotlin.Array((kotlin.collections.minOfOrNull.T)),%20kotlin.Function1((kotlin.collections.minOfOrNull.T,%20kotlin.Double)))/selector&quot;&gt;selector&lt;/a&gt; function is &lt;code&gt;NaN&lt;/code&gt;, the returned result is &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;min-of-or-null#kotlin.collections%24minOfOrNull(kotlin.Array((kotlin.collections.minOfOrNull.T)),%20kotlin.Function1((kotlin.collections.minOfOrNull.T,%20kotlin.Double)))/selector&quot;&gt;セレクター&lt;/a&gt;関数によって生成された値のいずれかが &lt;code&gt;NaN&lt;/code&gt; の場合、返される結果は &lt;code&gt;NaN&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="e9e966ce954bca5aa6b1bada8a82e7e213dd4409" translate="yes" xml:space="preserve">
          <source>If any of values produced by &lt;a href=&quot;min-of-or-null#kotlin.collections%24minOfOrNull(kotlin.collections.Iterable((kotlin.collections.minOfOrNull.T)),%20kotlin.Function1((kotlin.collections.minOfOrNull.T,%20kotlin.Double)))/selector&quot;&gt;selector&lt;/a&gt; function is &lt;code&gt;NaN&lt;/code&gt;, the returned result is &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;min-of-or-null#kotlin.collections%24minOfOrNull(kotlin.collections.Iterable((kotlin.collections.minOfOrNull.T)),%20kotlin.Function1((kotlin.collections.minOfOrNull.T,%20kotlin.Double)))/selector&quot;&gt;セレクター&lt;/a&gt;関数によって生成された値のいずれかが &lt;code&gt;NaN&lt;/code&gt; の場合、返される結果は &lt;code&gt;NaN&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="365af754bf462620905ac7411eb64305bc2de60a" translate="yes" xml:space="preserve">
          <source>If any of values produced by &lt;a href=&quot;min-of-or-null#kotlin.collections%24minOfOrNull(kotlin.collections.Map((kotlin.collections.minOfOrNull.K,%20kotlin.collections.minOfOrNull.V)),%20kotlin.Function1((kotlin.collections.Map.Entry((kotlin.collections.minOfOrNull.K,%20kotlin.collections.minOfOrNull.V)),%20kotlin.Double)))/selector&quot;&gt;selector&lt;/a&gt; function is &lt;code&gt;NaN&lt;/code&gt;, the returned result is &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;min-of-or-null#kotlin.collections%24minOfOrNull(kotlin.collections.Map((kotlin.collections.minOfOrNull.K,%20kotlin.collections.minOfOrNull.V)),%20kotlin.Function1((kotlin.collections.Map.Entry((kotlin.collections.minOfOrNull.K,%20kotlin.collections.minOfOrNull.V)),%20kotlin.Double)))/selector&quot;&gt;セレクター&lt;/a&gt;関数によって生成された値のいずれかが &lt;code&gt;NaN&lt;/code&gt; の場合、返される結果は &lt;code&gt;NaN&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="27e14e82baa65c311737fe2d312029df3d459372" translate="yes" xml:space="preserve">
          <source>If any of values produced by &lt;a href=&quot;min-of-or-null#kotlin.sequences%24minOfOrNull(kotlin.sequences.Sequence((kotlin.sequences.minOfOrNull.T)),%20kotlin.Function1((kotlin.sequences.minOfOrNull.T,%20kotlin.Double)))/selector&quot;&gt;selector&lt;/a&gt; function is &lt;code&gt;NaN&lt;/code&gt;, the returned result is &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;min-of-or-null#kotlin.sequences%24minOfOrNull(kotlin.sequences.Sequence((kotlin.sequences.minOfOrNull.T)),%20kotlin.Function1((kotlin.sequences.minOfOrNull.T,%20kotlin.Double)))/selector&quot;&gt;セレクター&lt;/a&gt;関数によって生成された値のいずれかが &lt;code&gt;NaN&lt;/code&gt; の場合、返される結果は &lt;code&gt;NaN&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="7bf89b40a8581dc5e193197a15170ae1446fe0c8" translate="yes" xml:space="preserve">
          <source>If any of values produced by &lt;a href=&quot;min-of-or-null#kotlin.text%24minOfOrNull(kotlin.CharSequence,%20kotlin.Function1((kotlin.Char,%20kotlin.Double)))/selector&quot;&gt;selector&lt;/a&gt; function is &lt;code&gt;NaN&lt;/code&gt;, the returned result is &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;min-of-or-null#kotlin.text%24minOfOrNull(kotlin.CharSequence,%20kotlin.Function1((kotlin.Char,%20kotlin.Double)))/selector&quot;&gt;セレクター&lt;/a&gt;関数によって生成された値のいずれかが &lt;code&gt;NaN&lt;/code&gt; の場合、返される結果は &lt;code&gt;NaN&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="79cd9f8134bc36e93ee0b5b0096e84d02bfcaf30" translate="yes" xml:space="preserve">
          <source>If any two characters are equal, the last one gets added to the map.</source>
          <target state="translated">2つの文字が等しい場合、最後の文字がマップに追加されます。</target>
        </trans-unit>
        <trans-unit id="c0c6357923841ba1ceaab6f1a6e9f84f8606ef1c" translate="yes" xml:space="preserve">
          <source>If any two characters are equal, the last one overwrites the former value in the map.</source>
          <target state="translated">2 つの文字が等しい場合、最後の文字がマップ内の前の値を上書きします。</target>
        </trans-unit>
        <trans-unit id="2f26706708ad295a2d4220fcac5447f101089a9f" translate="yes" xml:space="preserve">
          <source>If any two characters would have the same key returned by &lt;a href=&quot;associate-by#kotlin.text%24associateBy%28kotlin.CharSequence%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.text.associateBy.K%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt; the last one gets added to the map.</source>
          <target state="translated">&lt;a href=&quot;associate-by#kotlin.text%24associateBy%28kotlin.CharSequence%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.text.associateBy.K%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt;によって返される同じキーが2つの文字に含まれる場合、最後の文字がマップに追加されます。</target>
        </trans-unit>
        <trans-unit id="5497c944eda344c5ee4cce041575eba3fa47949a" translate="yes" xml:space="preserve">
          <source>If any two characters would have the same key returned by &lt;a href=&quot;associate-by#kotlin.text%24associateBy%28kotlin.CharSequence%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.text.associateBy.K%29%29%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.text.associateBy.V%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt; the last one gets added to the map.</source>
          <target state="translated">&lt;a href=&quot;associate-by#kotlin.text%24associateBy%28kotlin.CharSequence%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.text.associateBy.K%29%29%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.text.associateBy.V%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt;によって返される同じキーが2つの文字に含まれる場合、最後の文字がマップに追加されます。</target>
        </trans-unit>
        <trans-unit id="7367590726f3c52d91d710c14fe80d9003935516" translate="yes" xml:space="preserve">
          <source>If any two characters would have the same key returned by &lt;a href=&quot;associate-by#kotlin.text%24associateBy(kotlin.CharSequence,%20kotlin.Function1((kotlin.Char,%20kotlin.text.associateBy.K)))/keySelector&quot;&gt;keySelector&lt;/a&gt; the last one gets added to the map.</source>
          <target state="translated">2つのキャラクターが&lt;a href=&quot;associate-by#kotlin.text%24associateBy(kotlin.CharSequence,%20kotlin.Function1((kotlin.Char,%20kotlin.text.associateBy.K)))/keySelector&quot;&gt;keySelector&lt;/a&gt;によって返される同じキーを持っている場合、最後のキャラクターがマップに追加されます。</target>
        </trans-unit>
        <trans-unit id="f4bfe6665fd01c25b2660723aa26cfcba03b745a" translate="yes" xml:space="preserve">
          <source>If any two characters would have the same key returned by &lt;a href=&quot;associate-by#kotlin.text%24associateBy(kotlin.CharSequence,%20kotlin.Function1((kotlin.Char,%20kotlin.text.associateBy.K)),%20kotlin.Function1((kotlin.Char,%20kotlin.text.associateBy.V)))/keySelector&quot;&gt;keySelector&lt;/a&gt; the last one gets added to the map.</source>
          <target state="translated">2つのキャラクターが&lt;a href=&quot;associate-by#kotlin.text%24associateBy(kotlin.CharSequence,%20kotlin.Function1((kotlin.Char,%20kotlin.text.associateBy.K)),%20kotlin.Function1((kotlin.Char,%20kotlin.text.associateBy.V)))/keySelector&quot;&gt;keySelector&lt;/a&gt;によって返される同じキーを持っている場合、最後のキャラクターがマップに追加されます。</target>
        </trans-unit>
        <trans-unit id="00f0b6493f2eb1f51451a75f987e59fc400e809f" translate="yes" xml:space="preserve">
          <source>If any two characters would have the same key returned by &lt;a href=&quot;associate-by-to#kotlin.text%24associateByTo%28kotlin.CharSequence%2C+kotlin.text.associateByTo.M%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.text.associateByTo.K%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt; the last one gets added to the map.</source>
          <target state="translated">&lt;a href=&quot;associate-by-to#kotlin.text%24associateByTo%28kotlin.CharSequence%2C+kotlin.text.associateByTo.M%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.text.associateByTo.K%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt;によって返される同じキーが2つの文字に含まれる場合、最後の文字がマップに追加されます。</target>
        </trans-unit>
        <trans-unit id="e75792e6117ae62d34357ae99163b28e3ae87d39" translate="yes" xml:space="preserve">
          <source>If any two characters would have the same key returned by &lt;a href=&quot;associate-by-to#kotlin.text%24associateByTo%28kotlin.CharSequence%2C+kotlin.text.associateByTo.M%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.text.associateByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.text.associateByTo.V%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt; the last one gets added to the map.</source>
          <target state="translated">&lt;a href=&quot;associate-by-to#kotlin.text%24associateByTo%28kotlin.CharSequence%2C+kotlin.text.associateByTo.M%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.text.associateByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.text.associateByTo.V%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt;によって返される同じキーが2つの文字に含まれる場合、最後の文字がマップに追加されます。</target>
        </trans-unit>
        <trans-unit id="6c92aff3ac1f8cdea6651367e77533f526cbf74d" translate="yes" xml:space="preserve">
          <source>If any two characters would have the same key returned by &lt;a href=&quot;associate-by-to#kotlin.text%24associateByTo(kotlin.CharSequence,%20kotlin.text.associateByTo.M,%20kotlin.Function1((kotlin.Char,%20kotlin.text.associateByTo.K)))/keySelector&quot;&gt;keySelector&lt;/a&gt; the last one gets added to the map.</source>
          <target state="translated">2つのキャラクターが&lt;a href=&quot;associate-by-to#kotlin.text%24associateByTo(kotlin.CharSequence,%20kotlin.text.associateByTo.M,%20kotlin.Function1((kotlin.Char,%20kotlin.text.associateByTo.K)))/keySelector&quot;&gt;keySelector&lt;/a&gt;によって返される同じキーを持っている場合、最後のキャラクターがマップに追加されます。</target>
        </trans-unit>
        <trans-unit id="d21785fb11026ac029e1cf094d66a51ca1f63f36" translate="yes" xml:space="preserve">
          <source>If any two characters would have the same key returned by &lt;a href=&quot;associate-by-to#kotlin.text%24associateByTo(kotlin.CharSequence,%20kotlin.text.associateByTo.M,%20kotlin.Function1((kotlin.Char,%20kotlin.text.associateByTo.K)),%20kotlin.Function1((kotlin.Char,%20kotlin.text.associateByTo.V)))/keySelector&quot;&gt;keySelector&lt;/a&gt; the last one gets added to the map.</source>
          <target state="translated">2つのキャラクターが&lt;a href=&quot;associate-by-to#kotlin.text%24associateByTo(kotlin.CharSequence,%20kotlin.text.associateByTo.M,%20kotlin.Function1((kotlin.Char,%20kotlin.text.associateByTo.K)),%20kotlin.Function1((kotlin.Char,%20kotlin.text.associateByTo.V)))/keySelector&quot;&gt;keySelector&lt;/a&gt;によって返される同じキーを持っている場合、最後のキャラクターがマップに追加されます。</target>
        </trans-unit>
        <trans-unit id="4222526855776d5fea3d288e6bf28ef40486cfda" translate="yes" xml:space="preserve">
          <source>If any two elements are equal, the last one gets added to the map.</source>
          <target state="translated">2 つの要素が等しい場合、最後の要素がマップに追加されます。</target>
        </trans-unit>
        <trans-unit id="52ae8f33e4fce4d2bff00b2205f42a03dc6b6dc5" translate="yes" xml:space="preserve">
          <source>If any two elements are equal, the last one overwrites the former value in the map.</source>
          <target state="translated">2 つの要素が等しい場合、最後の要素がマップ内の前の値を上書きします。</target>
        </trans-unit>
        <trans-unit id="b0b36918b10e47a460b56e912f87552132811b0f" translate="yes" xml:space="preserve">
          <source>If any two elements would have the same key returned by &lt;a href=&quot;associate-by#kotlin.collections%24associateBy%28kotlin.Array%28%28kotlin.collections.associateBy.T%29%29%2C+kotlin.Function1%28%28kotlin.collections.associateBy.T%2C+kotlin.collections.associateBy.K%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt; the last one gets added to the map.</source>
          <target state="translated">2つの要素が&lt;a href=&quot;associate-by#kotlin.collections%24associateBy%28kotlin.Array%28%28kotlin.collections.associateBy.T%29%29%2C+kotlin.Function1%28%28kotlin.collections.associateBy.T%2C+kotlin.collections.associateBy.K%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt;によって返される同じキーを持つ場合、最後の要素がマップに追加されます。</target>
        </trans-unit>
        <trans-unit id="e4f7e861149810b95e4b66a62c5652d10a7c2b34" translate="yes" xml:space="preserve">
          <source>If any two elements would have the same key returned by &lt;a href=&quot;associate-by#kotlin.collections%24associateBy%28kotlin.Array%28%28kotlin.collections.associateBy.T%29%29%2C+kotlin.Function1%28%28kotlin.collections.associateBy.T%2C+kotlin.collections.associateBy.K%29%29%2C+kotlin.Function1%28%28kotlin.collections.associateBy.T%2C+kotlin.collections.associateBy.V%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt; the last one gets added to the map.</source>
          <target state="translated">2つの要素が&lt;a href=&quot;associate-by#kotlin.collections%24associateBy%28kotlin.Array%28%28kotlin.collections.associateBy.T%29%29%2C+kotlin.Function1%28%28kotlin.collections.associateBy.T%2C+kotlin.collections.associateBy.K%29%29%2C+kotlin.Function1%28%28kotlin.collections.associateBy.T%2C+kotlin.collections.associateBy.V%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt;によって返される同じキーを持つ場合、最後の要素がマップに追加されます。</target>
        </trans-unit>
        <trans-unit id="346c57febb657aa512596a792a1d6c53c4a5c173" translate="yes" xml:space="preserve">
          <source>If any two elements would have the same key returned by &lt;a href=&quot;associate-by#kotlin.collections%24associateBy%28kotlin.collections.Iterable%28%28kotlin.collections.associateBy.T%29%29%2C+kotlin.Function1%28%28kotlin.collections.associateBy.T%2C+kotlin.collections.associateBy.K%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt; the last one gets added to the map.</source>
          <target state="translated">2つの要素が&lt;a href=&quot;associate-by#kotlin.collections%24associateBy%28kotlin.collections.Iterable%28%28kotlin.collections.associateBy.T%29%29%2C+kotlin.Function1%28%28kotlin.collections.associateBy.T%2C+kotlin.collections.associateBy.K%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt;によって返される同じキーを持つ場合、最後の要素がマップに追加されます。</target>
        </trans-unit>
        <trans-unit id="3287da59db6cb14700469a6de2aad1297af6a1ee" translate="yes" xml:space="preserve">
          <source>If any two elements would have the same key returned by &lt;a href=&quot;associate-by#kotlin.collections%24associateBy%28kotlin.collections.Iterable%28%28kotlin.collections.associateBy.T%29%29%2C+kotlin.Function1%28%28kotlin.collections.associateBy.T%2C+kotlin.collections.associateBy.K%29%29%2C+kotlin.Function1%28%28kotlin.collections.associateBy.T%2C+kotlin.collections.associateBy.V%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt; the last one gets added to the map.</source>
          <target state="translated">2つの要素が&lt;a href=&quot;associate-by#kotlin.collections%24associateBy%28kotlin.collections.Iterable%28%28kotlin.collections.associateBy.T%29%29%2C+kotlin.Function1%28%28kotlin.collections.associateBy.T%2C+kotlin.collections.associateBy.K%29%29%2C+kotlin.Function1%28%28kotlin.collections.associateBy.T%2C+kotlin.collections.associateBy.V%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt;によって返される同じキーを持つ場合、最後の要素がマップに追加されます。</target>
        </trans-unit>
        <trans-unit id="2c619123b46fe6a76412a4dab4a539323c02514b" translate="yes" xml:space="preserve">
          <source>If any two elements would have the same key returned by &lt;a href=&quot;associate-by#kotlin.collections%24associateBy(kotlin.Array((kotlin.collections.associateBy.T)),%20kotlin.Function1((kotlin.collections.associateBy.T,%20kotlin.collections.associateBy.K)))/keySelector&quot;&gt;keySelector&lt;/a&gt; the last one gets added to the map.</source>
          <target state="translated">2つの要素のいずれかが&lt;a href=&quot;associate-by#kotlin.collections%24associateBy(kotlin.Array((kotlin.collections.associateBy.T)),%20kotlin.Function1((kotlin.collections.associateBy.T,%20kotlin.collections.associateBy.K)))/keySelector&quot;&gt;keySelector&lt;/a&gt;によって返される同じキーを持つ場合、最後の要素がマップに追加されます。</target>
        </trans-unit>
        <trans-unit id="2babce65c3c6822f47e0eae410ad672aa2260fa3" translate="yes" xml:space="preserve">
          <source>If any two elements would have the same key returned by &lt;a href=&quot;associate-by#kotlin.collections%24associateBy(kotlin.Array((kotlin.collections.associateBy.T)),%20kotlin.Function1((kotlin.collections.associateBy.T,%20kotlin.collections.associateBy.K)),%20kotlin.Function1((kotlin.collections.associateBy.T,%20kotlin.collections.associateBy.V)))/keySelector&quot;&gt;keySelector&lt;/a&gt; the last one gets added to the map.</source>
          <target state="translated">2つの要素のいずれかが&lt;a href=&quot;associate-by#kotlin.collections%24associateBy(kotlin.Array((kotlin.collections.associateBy.T)),%20kotlin.Function1((kotlin.collections.associateBy.T,%20kotlin.collections.associateBy.K)),%20kotlin.Function1((kotlin.collections.associateBy.T,%20kotlin.collections.associateBy.V)))/keySelector&quot;&gt;keySelector&lt;/a&gt;によって返される同じキーを持つ場合、最後の要素がマップに追加されます。</target>
        </trans-unit>
        <trans-unit id="00d01f2707a1118799d1a79e26193669d53741bc" translate="yes" xml:space="preserve">
          <source>If any two elements would have the same key returned by &lt;a href=&quot;associate-by#kotlin.collections%24associateBy(kotlin.collections.Iterable((kotlin.collections.associateBy.T)),%20kotlin.Function1((kotlin.collections.associateBy.T,%20kotlin.collections.associateBy.K)))/keySelector&quot;&gt;keySelector&lt;/a&gt; the last one gets added to the map.</source>
          <target state="translated">2つの要素のいずれかが&lt;a href=&quot;associate-by#kotlin.collections%24associateBy(kotlin.collections.Iterable((kotlin.collections.associateBy.T)),%20kotlin.Function1((kotlin.collections.associateBy.T,%20kotlin.collections.associateBy.K)))/keySelector&quot;&gt;keySelector&lt;/a&gt;によって返される同じキーを持つ場合、最後の要素がマップに追加されます。</target>
        </trans-unit>
        <trans-unit id="aec1ca56633469f54f0e46f095a2dbcb21ce1243" translate="yes" xml:space="preserve">
          <source>If any two elements would have the same key returned by &lt;a href=&quot;associate-by#kotlin.collections%24associateBy(kotlin.collections.Iterable((kotlin.collections.associateBy.T)),%20kotlin.Function1((kotlin.collections.associateBy.T,%20kotlin.collections.associateBy.K)),%20kotlin.Function1((kotlin.collections.associateBy.T,%20kotlin.collections.associateBy.V)))/keySelector&quot;&gt;keySelector&lt;/a&gt; the last one gets added to the map.</source>
          <target state="translated">2つの要素のいずれかが&lt;a href=&quot;associate-by#kotlin.collections%24associateBy(kotlin.collections.Iterable((kotlin.collections.associateBy.T)),%20kotlin.Function1((kotlin.collections.associateBy.T,%20kotlin.collections.associateBy.K)),%20kotlin.Function1((kotlin.collections.associateBy.T,%20kotlin.collections.associateBy.V)))/keySelector&quot;&gt;keySelector&lt;/a&gt;によって返される同じキーを持つ場合、最後の要素がマップに追加されます。</target>
        </trans-unit>
        <trans-unit id="00e86e26effea5e2019fdb8f013dd65c8b5af777" translate="yes" xml:space="preserve">
          <source>If any two elements would have the same key returned by &lt;a href=&quot;associate-by#kotlin.sequences%24associateBy%28kotlin.sequences.Sequence%28%28kotlin.sequences.associateBy.T%29%29%2C+kotlin.Function1%28%28kotlin.sequences.associateBy.T%2C+kotlin.sequences.associateBy.K%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt; the last one gets added to the map.</source>
          <target state="translated">2つの要素が&lt;a href=&quot;associate-by#kotlin.sequences%24associateBy%28kotlin.sequences.Sequence%28%28kotlin.sequences.associateBy.T%29%29%2C+kotlin.Function1%28%28kotlin.sequences.associateBy.T%2C+kotlin.sequences.associateBy.K%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt;によって返される同じキーを持つ場合、最後の要素がマップに追加されます。</target>
        </trans-unit>
        <trans-unit id="aa4e0bb8aab998beb153e618c68711e8ed1f5b4f" translate="yes" xml:space="preserve">
          <source>If any two elements would have the same key returned by &lt;a href=&quot;associate-by#kotlin.sequences%24associateBy%28kotlin.sequences.Sequence%28%28kotlin.sequences.associateBy.T%29%29%2C+kotlin.Function1%28%28kotlin.sequences.associateBy.T%2C+kotlin.sequences.associateBy.K%29%29%2C+kotlin.Function1%28%28kotlin.sequences.associateBy.T%2C+kotlin.sequences.associateBy.V%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt; the last one gets added to the map.</source>
          <target state="translated">2つの要素が&lt;a href=&quot;associate-by#kotlin.sequences%24associateBy%28kotlin.sequences.Sequence%28%28kotlin.sequences.associateBy.T%29%29%2C+kotlin.Function1%28%28kotlin.sequences.associateBy.T%2C+kotlin.sequences.associateBy.K%29%29%2C+kotlin.Function1%28%28kotlin.sequences.associateBy.T%2C+kotlin.sequences.associateBy.V%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt;によって返される同じキーを持つ場合、最後の要素がマップに追加されます。</target>
        </trans-unit>
        <trans-unit id="cb5d5aa23c9cfd8ca4685ccfe7640b8caaa4a65d" translate="yes" xml:space="preserve">
          <source>If any two elements would have the same key returned by &lt;a href=&quot;associate-by#kotlin.sequences%24associateBy(kotlin.sequences.Sequence((kotlin.sequences.associateBy.T)),%20kotlin.Function1((kotlin.sequences.associateBy.T,%20kotlin.sequences.associateBy.K)))/keySelector&quot;&gt;keySelector&lt;/a&gt; the last one gets added to the map.</source>
          <target state="translated">2つの要素のいずれかが&lt;a href=&quot;associate-by#kotlin.sequences%24associateBy(kotlin.sequences.Sequence((kotlin.sequences.associateBy.T)),%20kotlin.Function1((kotlin.sequences.associateBy.T,%20kotlin.sequences.associateBy.K)))/keySelector&quot;&gt;keySelector&lt;/a&gt;によって返される同じキーを持つ場合、最後の要素がマップに追加されます。</target>
        </trans-unit>
        <trans-unit id="76aca80e5881d814494f769e4c11ea9e94782b66" translate="yes" xml:space="preserve">
          <source>If any two elements would have the same key returned by &lt;a href=&quot;associate-by#kotlin.sequences%24associateBy(kotlin.sequences.Sequence((kotlin.sequences.associateBy.T)),%20kotlin.Function1((kotlin.sequences.associateBy.T,%20kotlin.sequences.associateBy.K)),%20kotlin.Function1((kotlin.sequences.associateBy.T,%20kotlin.sequences.associateBy.V)))/keySelector&quot;&gt;keySelector&lt;/a&gt; the last one gets added to the map.</source>
          <target state="translated">2つの要素のいずれかが&lt;a href=&quot;associate-by#kotlin.sequences%24associateBy(kotlin.sequences.Sequence((kotlin.sequences.associateBy.T)),%20kotlin.Function1((kotlin.sequences.associateBy.T,%20kotlin.sequences.associateBy.K)),%20kotlin.Function1((kotlin.sequences.associateBy.T,%20kotlin.sequences.associateBy.V)))/keySelector&quot;&gt;keySelector&lt;/a&gt;によって返される同じキーを持つ場合、最後の要素がマップに追加されます。</target>
        </trans-unit>
        <trans-unit id="c3d37381e9e97d902481d1677ee619ffffeec57b" translate="yes" xml:space="preserve">
          <source>If any two elements would have the same key returned by &lt;a href=&quot;associate-by-to#kotlin.collections%24associateByTo%28kotlin.Array%28%28kotlin.collections.associateByTo.T%29%29%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.collections.associateByTo.T%2C+kotlin.collections.associateByTo.K%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt; the last one gets added to the map.</source>
          <target state="translated">2つの要素が&lt;a href=&quot;associate-by-to#kotlin.collections%24associateByTo%28kotlin.Array%28%28kotlin.collections.associateByTo.T%29%29%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.collections.associateByTo.T%2C+kotlin.collections.associateByTo.K%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt;によって返される同じキーを持つ場合、最後の要素がマップに追加されます。</target>
        </trans-unit>
        <trans-unit id="8a54ba887f98592eb00ea24f27934531d1671f80" translate="yes" xml:space="preserve">
          <source>If any two elements would have the same key returned by &lt;a href=&quot;associate-by-to#kotlin.collections%24associateByTo%28kotlin.Array%28%28kotlin.collections.associateByTo.T%29%29%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.collections.associateByTo.T%2C+kotlin.collections.associateByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.collections.associateByTo.T%2C+kotlin.collections.associateByTo.V%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt; the last one gets added to the map.</source>
          <target state="translated">2つの要素が&lt;a href=&quot;associate-by-to#kotlin.collections%24associateByTo%28kotlin.Array%28%28kotlin.collections.associateByTo.T%29%29%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.collections.associateByTo.T%2C+kotlin.collections.associateByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.collections.associateByTo.T%2C+kotlin.collections.associateByTo.V%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt;によって返される同じキーを持つ場合、最後の要素がマップに追加されます。</target>
        </trans-unit>
        <trans-unit id="ab1f15270d6a111ddaa8968f8a8f226b8f79ddf4" translate="yes" xml:space="preserve">
          <source>If any two elements would have the same key returned by &lt;a href=&quot;associate-by-to#kotlin.collections%24associateByTo%28kotlin.collections.Iterable%28%28kotlin.collections.associateByTo.T%29%29%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.collections.associateByTo.T%2C+kotlin.collections.associateByTo.K%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt; the last one gets added to the map.</source>
          <target state="translated">2つの要素が&lt;a href=&quot;associate-by-to#kotlin.collections%24associateByTo%28kotlin.collections.Iterable%28%28kotlin.collections.associateByTo.T%29%29%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.collections.associateByTo.T%2C+kotlin.collections.associateByTo.K%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt;によって返される同じキーを持つ場合、最後の要素がマップに追加されます。</target>
        </trans-unit>
        <trans-unit id="d0f68c68a34d4b5715504c8f74b425b62b183fef" translate="yes" xml:space="preserve">
          <source>If any two elements would have the same key returned by &lt;a href=&quot;associate-by-to#kotlin.collections%24associateByTo%28kotlin.collections.Iterable%28%28kotlin.collections.associateByTo.T%29%29%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.collections.associateByTo.T%2C+kotlin.collections.associateByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.collections.associateByTo.T%2C+kotlin.collections.associateByTo.V%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt; the last one gets added to the map.</source>
          <target state="translated">2つの要素が&lt;a href=&quot;associate-by-to#kotlin.collections%24associateByTo%28kotlin.collections.Iterable%28%28kotlin.collections.associateByTo.T%29%29%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.collections.associateByTo.T%2C+kotlin.collections.associateByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.collections.associateByTo.T%2C+kotlin.collections.associateByTo.V%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt;によって返される同じキーを持つ場合、最後の要素がマップに追加されます。</target>
        </trans-unit>
        <trans-unit id="8b2386ebd4075f829eb97b39509e81199143026c" translate="yes" xml:space="preserve">
          <source>If any two elements would have the same key returned by &lt;a href=&quot;associate-by-to#kotlin.collections%24associateByTo(kotlin.Array((kotlin.collections.associateByTo.T)),%20kotlin.collections.associateByTo.M,%20kotlin.Function1((kotlin.collections.associateByTo.T,%20kotlin.collections.associateByTo.K)))/keySelector&quot;&gt;keySelector&lt;/a&gt; the last one gets added to the map.</source>
          <target state="translated">2つの要素のいずれかが&lt;a href=&quot;associate-by-to#kotlin.collections%24associateByTo(kotlin.Array((kotlin.collections.associateByTo.T)),%20kotlin.collections.associateByTo.M,%20kotlin.Function1((kotlin.collections.associateByTo.T,%20kotlin.collections.associateByTo.K)))/keySelector&quot;&gt;keySelector&lt;/a&gt;によって返される同じキーを持つ場合、最後の要素がマップに追加されます。</target>
        </trans-unit>
        <trans-unit id="a5bda745e6086dfd43e37448ecd0f17912a83dae" translate="yes" xml:space="preserve">
          <source>If any two elements would have the same key returned by &lt;a href=&quot;associate-by-to#kotlin.collections%24associateByTo(kotlin.Array((kotlin.collections.associateByTo.T)),%20kotlin.collections.associateByTo.M,%20kotlin.Function1((kotlin.collections.associateByTo.T,%20kotlin.collections.associateByTo.K)),%20kotlin.Function1((kotlin.collections.associateByTo.T,%20kotlin.collections.associateByTo.V)))/keySelector&quot;&gt;keySelector&lt;/a&gt; the last one gets added to the map.</source>
          <target state="translated">2つの要素のいずれかが&lt;a href=&quot;associate-by-to#kotlin.collections%24associateByTo(kotlin.Array((kotlin.collections.associateByTo.T)),%20kotlin.collections.associateByTo.M,%20kotlin.Function1((kotlin.collections.associateByTo.T,%20kotlin.collections.associateByTo.K)),%20kotlin.Function1((kotlin.collections.associateByTo.T,%20kotlin.collections.associateByTo.V)))/keySelector&quot;&gt;keySelector&lt;/a&gt;によって返される同じキーを持つ場合、最後の要素がマップに追加されます。</target>
        </trans-unit>
        <trans-unit id="b8b9cc802fea2f7d48329645a48c226c92d43891" translate="yes" xml:space="preserve">
          <source>If any two elements would have the same key returned by &lt;a href=&quot;associate-by-to#kotlin.collections%24associateByTo(kotlin.collections.Iterable((kotlin.collections.associateByTo.T)),%20kotlin.collections.associateByTo.M,%20kotlin.Function1((kotlin.collections.associateByTo.T,%20kotlin.collections.associateByTo.K)))/keySelector&quot;&gt;keySelector&lt;/a&gt; the last one gets added to the map.</source>
          <target state="translated">2つの要素のいずれかが&lt;a href=&quot;associate-by-to#kotlin.collections%24associateByTo(kotlin.collections.Iterable((kotlin.collections.associateByTo.T)),%20kotlin.collections.associateByTo.M,%20kotlin.Function1((kotlin.collections.associateByTo.T,%20kotlin.collections.associateByTo.K)))/keySelector&quot;&gt;keySelector&lt;/a&gt;によって返される同じキーを持つ場合、最後の要素がマップに追加されます。</target>
        </trans-unit>
        <trans-unit id="069e0778324065ee5d06336752a03ef494d33fe8" translate="yes" xml:space="preserve">
          <source>If any two elements would have the same key returned by &lt;a href=&quot;associate-by-to#kotlin.collections%24associateByTo(kotlin.collections.Iterable((kotlin.collections.associateByTo.T)),%20kotlin.collections.associateByTo.M,%20kotlin.Function1((kotlin.collections.associateByTo.T,%20kotlin.collections.associateByTo.K)),%20kotlin.Function1((kotlin.collections.associateByTo.T,%20kotlin.collections.associateByTo.V)))/keySelector&quot;&gt;keySelector&lt;/a&gt; the last one gets added to the map.</source>
          <target state="translated">2つの要素のいずれかが&lt;a href=&quot;associate-by-to#kotlin.collections%24associateByTo(kotlin.collections.Iterable((kotlin.collections.associateByTo.T)),%20kotlin.collections.associateByTo.M,%20kotlin.Function1((kotlin.collections.associateByTo.T,%20kotlin.collections.associateByTo.K)),%20kotlin.Function1((kotlin.collections.associateByTo.T,%20kotlin.collections.associateByTo.V)))/keySelector&quot;&gt;keySelector&lt;/a&gt;によって返される同じキーを持つ場合、最後の要素がマップに追加されます。</target>
        </trans-unit>
        <trans-unit id="7fef979d1100c793011b653d677a5f4789c9ce5c" translate="yes" xml:space="preserve">
          <source>If any two elements would have the same key returned by &lt;a href=&quot;associate-by-to#kotlin.sequences%24associateByTo%28kotlin.sequences.Sequence%28%28kotlin.sequences.associateByTo.T%29%29%2C+kotlin.sequences.associateByTo.M%2C+kotlin.Function1%28%28kotlin.sequences.associateByTo.T%2C+kotlin.sequences.associateByTo.K%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt; the last one gets added to the map.</source>
          <target state="translated">2つの要素が&lt;a href=&quot;associate-by-to#kotlin.sequences%24associateByTo%28kotlin.sequences.Sequence%28%28kotlin.sequences.associateByTo.T%29%29%2C+kotlin.sequences.associateByTo.M%2C+kotlin.Function1%28%28kotlin.sequences.associateByTo.T%2C+kotlin.sequences.associateByTo.K%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt;によって返される同じキーを持つ場合、最後の要素がマップに追加されます。</target>
        </trans-unit>
        <trans-unit id="0f4cd25d85f79262f8b0d5f4a453055241040829" translate="yes" xml:space="preserve">
          <source>If any two elements would have the same key returned by &lt;a href=&quot;associate-by-to#kotlin.sequences%24associateByTo%28kotlin.sequences.Sequence%28%28kotlin.sequences.associateByTo.T%29%29%2C+kotlin.sequences.associateByTo.M%2C+kotlin.Function1%28%28kotlin.sequences.associateByTo.T%2C+kotlin.sequences.associateByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.sequences.associateByTo.T%2C+kotlin.sequences.associateByTo.V%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt; the last one gets added to the map.</source>
          <target state="translated">2つの要素が&lt;a href=&quot;associate-by-to#kotlin.sequences%24associateByTo%28kotlin.sequences.Sequence%28%28kotlin.sequences.associateByTo.T%29%29%2C+kotlin.sequences.associateByTo.M%2C+kotlin.Function1%28%28kotlin.sequences.associateByTo.T%2C+kotlin.sequences.associateByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.sequences.associateByTo.T%2C+kotlin.sequences.associateByTo.V%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt;によって返される同じキーを持つ場合、最後の要素がマップに追加されます。</target>
        </trans-unit>
        <trans-unit id="65555fa738d49de3541dbc9b7c338a18ba8e97bd" translate="yes" xml:space="preserve">
          <source>If any two elements would have the same key returned by &lt;a href=&quot;associate-by-to#kotlin.sequences%24associateByTo(kotlin.sequences.Sequence((kotlin.sequences.associateByTo.T)),%20kotlin.sequences.associateByTo.M,%20kotlin.Function1((kotlin.sequences.associateByTo.T,%20kotlin.sequences.associateByTo.K)))/keySelector&quot;&gt;keySelector&lt;/a&gt; the last one gets added to the map.</source>
          <target state="translated">2つの要素のいずれかが&lt;a href=&quot;associate-by-to#kotlin.sequences%24associateByTo(kotlin.sequences.Sequence((kotlin.sequences.associateByTo.T)),%20kotlin.sequences.associateByTo.M,%20kotlin.Function1((kotlin.sequences.associateByTo.T,%20kotlin.sequences.associateByTo.K)))/keySelector&quot;&gt;keySelector&lt;/a&gt;によって返される同じキーを持つ場合、最後の要素がマップに追加されます。</target>
        </trans-unit>
        <trans-unit id="96ed486305c1c1d3ee98ba620ab2f351eaa38c63" translate="yes" xml:space="preserve">
          <source>If any two elements would have the same key returned by &lt;a href=&quot;associate-by-to#kotlin.sequences%24associateByTo(kotlin.sequences.Sequence((kotlin.sequences.associateByTo.T)),%20kotlin.sequences.associateByTo.M,%20kotlin.Function1((kotlin.sequences.associateByTo.T,%20kotlin.sequences.associateByTo.K)),%20kotlin.Function1((kotlin.sequences.associateByTo.T,%20kotlin.sequences.associateByTo.V)))/keySelector&quot;&gt;keySelector&lt;/a&gt; the last one gets added to the map.</source>
          <target state="translated">2つの要素のいずれかが&lt;a href=&quot;associate-by-to#kotlin.sequences%24associateByTo(kotlin.sequences.Sequence((kotlin.sequences.associateByTo.T)),%20kotlin.sequences.associateByTo.M,%20kotlin.Function1((kotlin.sequences.associateByTo.T,%20kotlin.sequences.associateByTo.K)),%20kotlin.Function1((kotlin.sequences.associateByTo.T,%20kotlin.sequences.associateByTo.V)))/keySelector&quot;&gt;keySelector&lt;/a&gt;によって返される同じキーを持つ場合、最後の要素がマップに追加されます。</target>
        </trans-unit>
        <trans-unit id="110a007329fb036d6903df69176601b85d25191e" translate="yes" xml:space="preserve">
          <source>If any type from a dependency is used in the public API of the current module, use an &lt;code&gt;api&lt;/code&gt; dependency.</source>
          <target state="translated">依存関係のいずれかのタイプが現在のモジュールのパブリックAPIで使用されている場合は、 &lt;code&gt;api&lt;/code&gt; 依存関係を使用します。</target>
        </trans-unit>
        <trans-unit id="eca190cfc6a29e9601e43afc0d741e161268772e" translate="yes" xml:space="preserve">
          <source>If any value is &lt;code&gt;NaN&lt;/code&gt;, returns &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">任意の値である場合は &lt;code&gt;NaN&lt;/code&gt; を返し、 &lt;code&gt;NaN&lt;/code&gt; は。</target>
        </trans-unit>
        <trans-unit id="15a7c9b40dd906acf8613adf81beb5022ec43a6e" translate="yes" xml:space="preserve">
          <source>If assigning a label for a lambda, do not put a space between the label and the opening curly brace:</source>
          <target state="translated">ラムダにラベルを代入する場合は、ラベルと中括弧の間にスペースを入れないでください。</target>
        </trans-unit>
        <trans-unit id="a820210cdda09e6106a20c2689836d5711b2d033" translate="yes" xml:space="preserve">
          <source>If atomic reference value is attempted to be set to non-frozen value runtime exception is thrown.</source>
          <target state="translated">アトミック参照値を非凍結値に設定しようとした場合、実行時例外がスローされます。</target>
        </trans-unit>
        <trans-unit id="f6340b7de91bcf9810532c03cd005ea252c107ff" translate="yes" xml:space="preserve">
          <source>If binary was compiled in debug mode.</source>
          <target state="translated">バイナリがデバッグモードでコンパイルされていた場合。</target>
        </trans-unit>
        <trans-unit id="2d8589cc3e699ddd4e97fa2ba29db1785486ed75" translate="yes" xml:space="preserve">
          <source>If either value is &lt;code&gt;NaN&lt;/code&gt;, returns &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">どちらかの値がある場合 &lt;code&gt;NaN&lt;/code&gt; 、返し &lt;code&gt;NaN&lt;/code&gt; は。</target>
        </trans-unit>
        <trans-unit id="a91c0067bcc4bc2dc899d9a2f5799f4eb73c4ee3" translate="yes" xml:space="preserve">
          <source>If either value is &lt;code&gt;NaN&lt;/code&gt;, then the result is &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">いずれかの値が &lt;code&gt;NaN&lt;/code&gt; の場合、結果は &lt;code&gt;NaN&lt;/code&gt; になります。</target>
        </trans-unit>
        <trans-unit id="7f3e1f12baf2d25f74fb62aefb55ff3c7223ad4c" translate="yes" xml:space="preserve">
          <source>If everything went well, you'll see the result in the &lt;strong&gt;Console&lt;/strong&gt; window.</source>
          <target state="translated">すべてがうまくいくと、&lt;strong&gt;コンソール&lt;/strong&gt;ウィンドウに結果が表示されます。</target>
        </trans-unit>
        <trans-unit id="b99457c74d09db32d851769270d759bf6b0bed1e" translate="yes" xml:space="preserve">
          <source>If everything went well, you'll see the result in the &lt;strong&gt;Run&lt;/strong&gt; tool window.</source>
          <target state="translated">すべてが順調に進んだ場合、&lt;strong&gt;実行&lt;/strong&gt;ツールウィンドウに結果が表示されます。</target>
        </trans-unit>
        <trans-unit id="f44e8e73afacbc926ee5ae8b0a40c2caa8a431c0" translate="yes" xml:space="preserve">
          <source>If for some reason you want to store a different value in the backing field than the value that is being assigned to the property, you're free to do that, but then you will probably want a getter to give the calling code back what they expect: if you say &lt;code&gt;field = value * 2&lt;/code&gt; in the setter and &lt;code&gt;this.age = age * 2&lt;/code&gt; in the initializer block, you should also have &lt;code&gt;get() = field / 2&lt;/code&gt;.</source>
          <target state="translated">なんらかの理由で、プロパティに割り当てられている値とは異なる値をバッキングフィールドに格納する場合は、自由に実行できますが、おそらく、ゲッターに呼び出しコードにそれらの値を返させたいと思うでしょう。予想：セッターで &lt;code&gt;field = value * 2&lt;/code&gt; と言い、初期化ブロックで &lt;code&gt;this.age = age * 2&lt;/code&gt; すると、 &lt;code&gt;get() = field / 2&lt;/code&gt; も必要です。</target>
        </trans-unit>
        <trans-unit id="4edefded820cd80aae935341ea1dcb1006c317d1" translate="yes" xml:space="preserve">
          <source>If many cases should be handled in the same way, the branch conditions may be combined with a comma:</source>
          <target state="translated">多くのケースを同じように扱う必要がある場合は、分岐条件をカンマで結合してもよい。</target>
        </trans-unit>
        <trans-unit id="fce48d9ac76717b44d2ca9ae647c75c587720e7e" translate="yes" xml:space="preserve">
          <source>If multiple pairs have the same key, the resulting map will contain the value from the last of those pairs.</source>
          <target state="translated">複数のペアが同じキーを持つ場合、結果として得られるマップには、それらのペアの最後のペアの値が含まれます。</target>
        </trans-unit>
        <trans-unit id="f2ea3319b4e276d7c3ea13314c77acc34629c044" translate="yes" xml:space="preserve">
          <source>If necessary, specify dependencies between modules:</source>
          <target state="translated">必要に応じて、モジュール間の依存関係を指定します。</target>
        </trans-unit>
        <trans-unit id="c2f6abafe51dcf05f7cf659caae54fb0bbb624da" translate="yes" xml:space="preserve">
          <source>If no elements match the predicate, both functions throw exceptions. To avoid them, use &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/first-or-null&quot;&gt;&lt;code&gt;firstOrNull()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/last-or-null&quot;&gt;&lt;code&gt;lastOrNull()&lt;/code&gt;&lt;/a&gt; instead: they return &lt;code&gt;null&lt;/code&gt; if no matching elements are found.</source>
          <target state="translated">述語に一致する要素がない場合、両方の関数が例外をスローします。それらを回避するには、代わりに&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/first-or-null&quot;&gt; &lt;code&gt;firstOrNull()&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/last-or-null&quot;&gt; &lt;code&gt;lastOrNull()&lt;/code&gt; を&lt;/a&gt;使用し &lt;code&gt;null&lt;/code&gt; 。一致する要素が見つからない場合はnullを返します。</target>
        </trans-unit>
        <trans-unit id="8ce45b90b7ed5e84a37f6079dd50b9e40c3acc1b" translate="yes" xml:space="preserve">
          <source>If not null and else shorthand</source>
          <target state="translated">nullではなく、他の場合は省略可能です。</target>
        </trans-unit>
        <trans-unit id="c3119c5c318b3c1bb9ef4c81af371e666f2e1406" translate="yes" xml:space="preserve">
          <source>If not null shorthand</source>
          <target state="translated">nullではない場合の速記法</target>
        </trans-unit>
        <trans-unit id="f0a31ecbf625068fa2a79a659389ab370dd6f36e" translate="yes" xml:space="preserve">
          <source>If present, specifies a code fragment which should be used as a replacement for the deprecated API usage.</source>
          <target state="translated">存在する場合は、非推奨のAPIの使用法の代替として使用するコードフラグメントを指定します。</target>
        </trans-unit>
        <trans-unit id="9664a874b8c0300219353ed51ac375519b83e9fe" translate="yes" xml:space="preserve">
          <source>If rebuilding is performed on App Store side, then &lt;code&gt;.dSYM&lt;/code&gt; of rebuilt &lt;em&gt;dynamic&lt;/em&gt; framework seems discarded and not downloadable from App Store Connect. So in this case it may be required to make the framework static, e.g. with</source>
          <target state="translated">再構築が &lt;code&gt;.dSYM&lt;/code&gt; 側で実行される場合、再構築された&lt;em&gt;動的&lt;/em&gt;フレームワークの.dSYMは破棄され、App StoreConnectからダウンロードできないように見えます。したがって、この場合、フレームワークを静的にする必要があります。</target>
        </trans-unit>
        <trans-unit id="b5b87a1191a07e9f1f10d2d86fbeef8f4c6e6b20" translate="yes" xml:space="preserve">
          <source>If some directories on a way to the &lt;a href=&quot;copy-to#kotlin.io%24copyTo%28java.io.File%2C+java.io.File%2C+kotlin.Boolean%2C+kotlin.Int%29%2Ftarget&quot;&gt;target&lt;/a&gt; are missing, then they will be created. If the &lt;a href=&quot;copy-to#kotlin.io%24copyTo%28java.io.File%2C+java.io.File%2C+kotlin.Boolean%2C+kotlin.Int%29%2Ftarget&quot;&gt;target&lt;/a&gt; file already exists, this function will fail unless &lt;a href=&quot;copy-to#kotlin.io%24copyTo%28java.io.File%2C+java.io.File%2C+kotlin.Boolean%2C+kotlin.Int%29%2Foverwrite&quot;&gt;overwrite&lt;/a&gt; argument is set to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;copy-to#kotlin.io%24copyTo%28java.io.File%2C+java.io.File%2C+kotlin.Boolean%2C+kotlin.Int%29%2Ftarget&quot;&gt;ターゲット&lt;/a&gt;への途中のいくつかのディレクトリが見つからない場合は、作成されます。&lt;a href=&quot;copy-to#kotlin.io%24copyTo%28java.io.File%2C+java.io.File%2C+kotlin.Boolean%2C+kotlin.Int%29%2Ftarget&quot;&gt;ターゲット&lt;/a&gt;ファイルがすでに存在する場合、引数&lt;a href=&quot;copy-to#kotlin.io%24copyTo%28java.io.File%2C+java.io.File%2C+kotlin.Boolean%2C+kotlin.Int%29%2Foverwrite&quot;&gt;overwrite&lt;/a&gt;が &lt;code&gt;true&lt;/code&gt; に設定されていない限り、この関数は失敗します。</target>
        </trans-unit>
        <trans-unit id="f01a59b3c6eaf0fa829c89cc9cc51b75a98bb1df" translate="yes" xml:space="preserve">
          <source>If some directories on a way to the &lt;a href=&quot;copy-to#kotlin.io%24copyTo(java.io.File,%20java.io.File,%20kotlin.Boolean,%20kotlin.Int)/target&quot;&gt;target&lt;/a&gt; are missing, then they will be created. If the &lt;a href=&quot;copy-to#kotlin.io%24copyTo(java.io.File,%20java.io.File,%20kotlin.Boolean,%20kotlin.Int)/target&quot;&gt;target&lt;/a&gt; file already exists, this function will fail unless &lt;a href=&quot;copy-to#kotlin.io%24copyTo(java.io.File,%20java.io.File,%20kotlin.Boolean,%20kotlin.Int)/overwrite&quot;&gt;overwrite&lt;/a&gt; argument is set to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;copy-to#kotlin.io%24copyTo(java.io.File,%20java.io.File,%20kotlin.Boolean,%20kotlin.Int)/target&quot;&gt;ターゲットに&lt;/a&gt;向かう途中のいくつかのディレクトリが欠落している場合、それらは作成されます。&lt;a href=&quot;copy-to#kotlin.io%24copyTo(java.io.File,%20java.io.File,%20kotlin.Boolean,%20kotlin.Int)/target&quot;&gt;ターゲット&lt;/a&gt;ファイルがすでに存在する場合、&lt;a href=&quot;copy-to#kotlin.io%24copyTo(java.io.File,%20java.io.File,%20kotlin.Boolean,%20kotlin.Int)/overwrite&quot;&gt;overwrite&lt;/a&gt;引数が &lt;code&gt;true&lt;/code&gt; に設定されていない限り、この関数は失敗します。</target>
        </trans-unit>
        <trans-unit id="69564edb6644d0771a0b53f00a1f0ee73a8d9530" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;aggregate-to#kotlin.collections%24aggregateTo%28kotlin.collections.Grouping%28%28kotlin.collections.aggregateTo.T%2C+kotlin.collections.aggregateTo.K%29%29%2C+kotlin.collections.aggregateTo.M%2C+kotlin.Function4%28%28kotlin.collections.aggregateTo.K%2C+kotlin.collections.aggregateTo.R%2C+kotlin.collections.aggregateTo.T%2C+kotlin.Boolean%2C+kotlin.collections.aggregateTo.R%29%29%29%2Fdestination&quot;&gt;destination&lt;/a&gt; map already has a value corresponding to some key, then the elements being aggregated for that key are never considered as &lt;code&gt;first&lt;/code&gt;.</source>
          <target state="translated">場合&lt;a href=&quot;aggregate-to#kotlin.collections%24aggregateTo%28kotlin.collections.Grouping%28%28kotlin.collections.aggregateTo.T%2C+kotlin.collections.aggregateTo.K%29%29%2C+kotlin.collections.aggregateTo.M%2C+kotlin.Function4%28%28kotlin.collections.aggregateTo.K%2C+kotlin.collections.aggregateTo.R%2C+kotlin.collections.aggregateTo.T%2C+kotlin.Boolean%2C+kotlin.collections.aggregateTo.R%29%29%29%2Fdestination&quot;&gt;宛先&lt;/a&gt;マップは、すでにいくつかのキーに対応する値を有し、そのキーに集約されている要素は、と考えることはありません &lt;code&gt;first&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b97d2cb76e358bd05b416fac37404ef523495356" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;aggregate-to#kotlin.collections%24aggregateTo(kotlin.collections.Grouping((kotlin.collections.aggregateTo.T,%20kotlin.collections.aggregateTo.K)),%20kotlin.collections.aggregateTo.M,%20kotlin.Function4((kotlin.collections.aggregateTo.K,%20kotlin.collections.aggregateTo.R?,%20kotlin.collections.aggregateTo.T,%20kotlin.Boolean,%20kotlin.collections.aggregateTo.R)))/destination&quot;&gt;destination&lt;/a&gt; map already has a value corresponding to some key, then the elements being aggregated for that key are never considered as &lt;code&gt;first&lt;/code&gt;.</source>
          <target state="translated">場合&lt;a href=&quot;aggregate-to#kotlin.collections%24aggregateTo(kotlin.collections.Grouping((kotlin.collections.aggregateTo.T,%20kotlin.collections.aggregateTo.K)),%20kotlin.collections.aggregateTo.M,%20kotlin.Function4((kotlin.collections.aggregateTo.K,%20kotlin.collections.aggregateTo.R?,%20kotlin.collections.aggregateTo.T,%20kotlin.Boolean,%20kotlin.collections.aggregateTo.R)))/destination&quot;&gt;宛先&lt;/a&gt;マップは、すでにいくつかのキーに対応する値を有し、そのキーに集約されている要素は、と考えることはありません &lt;code&gt;first&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f0b6595d56ce18db4a67782306e25689cafd4cbf" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;copy-recursively#kotlin.io%24copyRecursively%28java.io.File%2C+java.io.File%2C+kotlin.Boolean%2C+kotlin.Function2%28%28java.io.File%2C+java.io.IOException%2C+kotlin.io.OnErrorAction%29%29%29%2Ftarget&quot;&gt;target&lt;/a&gt; already exists, it will be deleted before copying when the &lt;a href=&quot;copy-recursively#kotlin.io%24copyRecursively%28java.io.File%2C+java.io.File%2C+kotlin.Boolean%2C+kotlin.Function2%28%28java.io.File%2C+java.io.IOException%2C+kotlin.io.OnErrorAction%29%29%29%2Foverwrite&quot;&gt;overwrite&lt;/a&gt; parameter permits so.</source>
          <target state="translated">場合は&lt;a href=&quot;copy-recursively#kotlin.io%24copyRecursively%28java.io.File%2C+java.io.File%2C+kotlin.Boolean%2C+kotlin.Function2%28%28java.io.File%2C+java.io.IOException%2C+kotlin.io.OnErrorAction%29%29%29%2Ftarget&quot;&gt;、ターゲットが&lt;/a&gt;すでに存在している、それは時にコピーする前に削除されます&lt;a href=&quot;copy-recursively#kotlin.io%24copyRecursively%28java.io.File%2C+java.io.File%2C+kotlin.Boolean%2C+kotlin.Function2%28%28java.io.File%2C+java.io.IOException%2C+kotlin.io.OnErrorAction%29%29%29%2Foverwrite&quot;&gt;上書き&lt;/a&gt;パラメータがそうできます。</target>
        </trans-unit>
        <trans-unit id="72642c2dc2e392596a7e9e14969c3eba6a9b65c7" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;copy-recursively#kotlin.io%24copyRecursively(java.io.File,%20java.io.File,%20kotlin.Boolean,%20kotlin.Function2((java.io.File,%20java.io.IOException,%20kotlin.io.OnErrorAction)))/target&quot;&gt;target&lt;/a&gt; already exists, it will be deleted before copying when the &lt;a href=&quot;copy-recursively#kotlin.io%24copyRecursively(java.io.File,%20java.io.File,%20kotlin.Boolean,%20kotlin.Function2((java.io.File,%20java.io.IOException,%20kotlin.io.OnErrorAction)))/overwrite&quot;&gt;overwrite&lt;/a&gt; parameter permits so.</source>
          <target state="translated">場合は&lt;a href=&quot;copy-recursively#kotlin.io%24copyRecursively(java.io.File,%20java.io.File,%20kotlin.Boolean,%20kotlin.Function2((java.io.File,%20java.io.IOException,%20kotlin.io.OnErrorAction)))/target&quot;&gt;、ターゲットが&lt;/a&gt;すでに存在している、それは時にコピーする前に削除されます&lt;a href=&quot;copy-recursively#kotlin.io%24copyRecursively(java.io.File,%20java.io.File,%20kotlin.Boolean,%20kotlin.Function2((java.io.File,%20java.io.IOException,%20kotlin.io.OnErrorAction)))/overwrite&quot;&gt;上書き&lt;/a&gt;パラメータがそうできます。</target>
        </trans-unit>
        <trans-unit id="9f9b5e8d1feceda52168174d03a6fd1853068274" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;each-count-to#kotlin.collections%24eachCountTo%28kotlin.collections.Grouping%28%28kotlin.collections.eachCountTo.T%2C+kotlin.collections.eachCountTo.K%29%29%2C+kotlin.collections.eachCountTo.M%29%2Fdestination&quot;&gt;destination&lt;/a&gt; map already has a value corresponding to the key of some group, that value is used as an initial value of the counter for that group.</source>
          <target state="translated">場合&lt;a href=&quot;each-count-to#kotlin.collections%24eachCountTo%28kotlin.collections.Grouping%28%28kotlin.collections.eachCountTo.T%2C+kotlin.collections.eachCountTo.K%29%29%2C+kotlin.collections.eachCountTo.M%29%2Fdestination&quot;&gt;宛先&lt;/a&gt;マップは、すでにいくつかのグループのキーに対応する値を有し、その値は、そのグループのためのカウンタの初期値として使用されます。</target>
        </trans-unit>
        <trans-unit id="294cca51ae0758313aa7d288e6e1a35754d699c1" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;each-count-to#kotlin.collections%24eachCountTo(kotlin.collections.Grouping((kotlin.collections.eachCountTo.T,%20kotlin.collections.eachCountTo.K)),%20kotlin.collections.eachCountTo.M)/destination&quot;&gt;destination&lt;/a&gt; map already has a value corresponding to the key of some group, that value is used as an initial value of the counter for that group.</source>
          <target state="translated">場合&lt;a href=&quot;each-count-to#kotlin.collections%24eachCountTo(kotlin.collections.Grouping((kotlin.collections.eachCountTo.T,%20kotlin.collections.eachCountTo.K)),%20kotlin.collections.eachCountTo.M)/destination&quot;&gt;宛先&lt;/a&gt;マップは、すでにいくつかのグループのキーに対応する値を有し、その値は、そのグループのためのカウンタの初期値として使用されます。</target>
        </trans-unit>
        <trans-unit id="8e5524567ae268875bd1ad8d3089898977c657ab" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;fold-to#kotlin.collections%24foldTo%28kotlin.collections.Grouping%28%28kotlin.collections.foldTo.T%2C+kotlin.collections.foldTo.K%29%29%2C+kotlin.collections.foldTo.M%2C+kotlin.Function2%28%28kotlin.collections.foldTo.K%2C+kotlin.collections.foldTo.T%2C+kotlin.collections.foldTo.R%29%29%2C+kotlin.Function3%28%28kotlin.collections.foldTo.K%2C+kotlin.collections.foldTo.R%2C+kotlin.collections.foldTo.T%2C+%29%29%29%2Fdestination&quot;&gt;destination&lt;/a&gt; map already has a value corresponding to some key, that value is used as an initial value of the accumulator for that group and the &lt;a href=&quot;fold-to#kotlin.collections%24foldTo%28kotlin.collections.Grouping%28%28kotlin.collections.foldTo.T%2C+kotlin.collections.foldTo.K%29%29%2C+kotlin.collections.foldTo.M%2C+kotlin.Function2%28%28kotlin.collections.foldTo.K%2C+kotlin.collections.foldTo.T%2C+kotlin.collections.foldTo.R%29%29%2C+kotlin.Function3%28%28kotlin.collections.foldTo.K%2C+kotlin.collections.foldTo.R%2C+kotlin.collections.foldTo.T%2C+%29%29%29%2FinitialValueSelector&quot;&gt;initialValueSelector&lt;/a&gt; function is not called for that group.</source>
          <target state="translated">場合&lt;a href=&quot;fold-to#kotlin.collections%24foldTo%28kotlin.collections.Grouping%28%28kotlin.collections.foldTo.T%2C+kotlin.collections.foldTo.K%29%29%2C+kotlin.collections.foldTo.M%2C+kotlin.Function2%28%28kotlin.collections.foldTo.K%2C+kotlin.collections.foldTo.T%2C+kotlin.collections.foldTo.R%29%29%2C+kotlin.Function3%28%28kotlin.collections.foldTo.K%2C+kotlin.collections.foldTo.R%2C+kotlin.collections.foldTo.T%2C+%29%29%29%2Fdestination&quot;&gt;宛先&lt;/a&gt;マップは、すでにいくつかのキーに対応する値を有し、そのグループのためのアキュムレータの初期値として、その値が使用され&lt;a href=&quot;fold-to#kotlin.collections%24foldTo%28kotlin.collections.Grouping%28%28kotlin.collections.foldTo.T%2C+kotlin.collections.foldTo.K%29%29%2C+kotlin.collections.foldTo.M%2C+kotlin.Function2%28%28kotlin.collections.foldTo.K%2C+kotlin.collections.foldTo.T%2C+kotlin.collections.foldTo.R%29%29%2C+kotlin.Function3%28%28kotlin.collections.foldTo.K%2C+kotlin.collections.foldTo.R%2C+kotlin.collections.foldTo.T%2C+%29%29%29%2FinitialValueSelector&quot;&gt;initialValueSelectorの&lt;/a&gt;機能は、そのグループのために呼び出されません。</target>
        </trans-unit>
        <trans-unit id="c2e00bc5fd9ad4886018856e815daa5b47301e4d" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;fold-to#kotlin.collections%24foldTo%28kotlin.collections.Grouping%28%28kotlin.collections.foldTo.T%2C+kotlin.collections.foldTo.K%29%29%2C+kotlin.collections.foldTo.M%2C+kotlin.collections.foldTo.R%2C+kotlin.Function2%28%28kotlin.collections.foldTo.R%2C+kotlin.collections.foldTo.T%2C+%29%29%29%2Fdestination&quot;&gt;destination&lt;/a&gt; map already has a value corresponding to the key of some group, that value is used as an initial value of the accumulator for that group.</source>
          <target state="translated">場合&lt;a href=&quot;fold-to#kotlin.collections%24foldTo%28kotlin.collections.Grouping%28%28kotlin.collections.foldTo.T%2C+kotlin.collections.foldTo.K%29%29%2C+kotlin.collections.foldTo.M%2C+kotlin.collections.foldTo.R%2C+kotlin.Function2%28%28kotlin.collections.foldTo.R%2C+kotlin.collections.foldTo.T%2C+%29%29%29%2Fdestination&quot;&gt;宛先&lt;/a&gt;マップは、すでにいくつかのグループのキーと対応する値を有し、その値は、そのグループのためのアキュムレータの初期値として使用されます。</target>
        </trans-unit>
        <trans-unit id="92a0a868acf0fdba94e948380117659b082b2d8a" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;fold-to#kotlin.collections%24foldTo(kotlin.collections.Grouping((kotlin.collections.foldTo.T,%20kotlin.collections.foldTo.K)),%20kotlin.collections.foldTo.M,%20kotlin.Function2((kotlin.collections.foldTo.K,%20kotlin.collections.foldTo.T,%20kotlin.collections.foldTo.R)),%20kotlin.Function3((kotlin.collections.foldTo.K,%20kotlin.collections.foldTo.R,%20kotlin.collections.foldTo.T,%20)))/destination&quot;&gt;destination&lt;/a&gt; map already has a value corresponding to some key, that value is used as an initial value of the accumulator for that group and the &lt;a href=&quot;fold-to#kotlin.collections%24foldTo(kotlin.collections.Grouping((kotlin.collections.foldTo.T,%20kotlin.collections.foldTo.K)),%20kotlin.collections.foldTo.M,%20kotlin.Function2((kotlin.collections.foldTo.K,%20kotlin.collections.foldTo.T,%20kotlin.collections.foldTo.R)),%20kotlin.Function3((kotlin.collections.foldTo.K,%20kotlin.collections.foldTo.R,%20kotlin.collections.foldTo.T,%20)))/initialValueSelector&quot;&gt;initialValueSelector&lt;/a&gt; function is not called for that group.</source>
          <target state="translated">場合&lt;a href=&quot;fold-to#kotlin.collections%24foldTo(kotlin.collections.Grouping((kotlin.collections.foldTo.T,%20kotlin.collections.foldTo.K)),%20kotlin.collections.foldTo.M,%20kotlin.Function2((kotlin.collections.foldTo.K,%20kotlin.collections.foldTo.T,%20kotlin.collections.foldTo.R)),%20kotlin.Function3((kotlin.collections.foldTo.K,%20kotlin.collections.foldTo.R,%20kotlin.collections.foldTo.T,%20)))/destination&quot;&gt;宛先&lt;/a&gt;マップは、すでにいくつかのキーに対応する値を有し、そのグループのためのアキュムレータの初期値として、その値が使用され&lt;a href=&quot;fold-to#kotlin.collections%24foldTo(kotlin.collections.Grouping((kotlin.collections.foldTo.T,%20kotlin.collections.foldTo.K)),%20kotlin.collections.foldTo.M,%20kotlin.Function2((kotlin.collections.foldTo.K,%20kotlin.collections.foldTo.T,%20kotlin.collections.foldTo.R)),%20kotlin.Function3((kotlin.collections.foldTo.K,%20kotlin.collections.foldTo.R,%20kotlin.collections.foldTo.T,%20)))/initialValueSelector&quot;&gt;initialValueSelectorの&lt;/a&gt;機能は、そのグループのために呼び出されません。</target>
        </trans-unit>
        <trans-unit id="61fb3080e7ad416c3c4c97afdd9493927e20f8d4" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;fold-to#kotlin.collections%24foldTo(kotlin.collections.Grouping((kotlin.collections.foldTo.T,%20kotlin.collections.foldTo.K)),%20kotlin.collections.foldTo.M,%20kotlin.collections.foldTo.R,%20kotlin.Function2((kotlin.collections.foldTo.R,%20kotlin.collections.foldTo.T,%20)))/destination&quot;&gt;destination&lt;/a&gt; map already has a value corresponding to the key of some group, that value is used as an initial value of the accumulator for that group.</source>
          <target state="translated">場合&lt;a href=&quot;fold-to#kotlin.collections%24foldTo(kotlin.collections.Grouping((kotlin.collections.foldTo.T,%20kotlin.collections.foldTo.K)),%20kotlin.collections.foldTo.M,%20kotlin.collections.foldTo.R,%20kotlin.Function2((kotlin.collections.foldTo.R,%20kotlin.collections.foldTo.T,%20)))/destination&quot;&gt;宛先&lt;/a&gt;マップは、すでにいくつかのグループのキーに対応する値を有し、その値は、そのグループのためのアキュムレータの初期値として使用されます。</target>
        </trans-unit>
        <trans-unit id="a5e416dc2da9d5eff4e49855727e16479b47d6e8" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.Array%24get%28kotlin.Int%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">場合&lt;a href=&quot;get#kotlin.Array%24get%28kotlin.Int%29%2Findex&quot;&gt;インデックスが&lt;/a&gt;この配列の範囲外である、スロー&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;はIndexOutOfBoundsExceptionの&lt;/a&gt;動作が指定されていないKotlin / JSを除い。</target>
        </trans-unit>
        <trans-unit id="a66362906cf4418648a9a5554323ed383b8c8eea" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.Array%24get%28kotlin.Int%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;get#kotlin.Array%24get%28kotlin.Int%29%2Findex&quot;&gt;インデックス&lt;/a&gt;がこの配列の範囲外の場合、&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsExceptionをスローし&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="659f4cba1d89d61c23bd0ba52a22f40e8ccd83db" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.Array%24get(kotlin.Int)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">場合&lt;a href=&quot;get#kotlin.Array%24get(kotlin.Int)/index&quot;&gt;インデックスが&lt;/a&gt;この配列の範囲外である、スロー&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;はIndexOutOfBoundsExceptionの&lt;/a&gt;動作が指定されていないKotlin / JSを除い。</target>
        </trans-unit>
        <trans-unit id="8871905aa80191cdc602c425bf96156ef25f5e60" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.Array%24get(kotlin.Int)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;get#kotlin.Array%24get(kotlin.Int)/index&quot;&gt;インデックス&lt;/a&gt;がこの配列の範囲外である場合、&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsExceptionをスローし&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="e297805d5d494bda3a0385ad18c3569e75f14c7d" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.BooleanArray%24get%28kotlin.Int%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">場合&lt;a href=&quot;get#kotlin.BooleanArray%24get%28kotlin.Int%29%2Findex&quot;&gt;インデックスが&lt;/a&gt;この配列の範囲外である、スロー&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;はIndexOutOfBoundsExceptionの&lt;/a&gt;動作が指定されていないKotlin / JSを除い。</target>
        </trans-unit>
        <trans-unit id="4c007633067610794e36b0b3cc51865ca8352f19" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.BooleanArray%24get%28kotlin.Int%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;get#kotlin.BooleanArray%24get%28kotlin.Int%29%2Findex&quot;&gt;インデックス&lt;/a&gt;がこの配列の範囲外の場合、&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsExceptionをスローし&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="6039a3964776e721bd806c0a81307a0abf13a4c0" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.BooleanArray%24get(kotlin.Int)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">場合&lt;a href=&quot;get#kotlin.BooleanArray%24get(kotlin.Int)/index&quot;&gt;インデックスが&lt;/a&gt;この配列の範囲外である、スロー&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;はIndexOutOfBoundsExceptionの&lt;/a&gt;動作が指定されていないKotlin / JSを除い。</target>
        </trans-unit>
        <trans-unit id="fc5816f698f9795e7dd6086d1ef8ccfaae63b27a" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.BooleanArray%24get(kotlin.Int)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;get#kotlin.BooleanArray%24get(kotlin.Int)/index&quot;&gt;インデックス&lt;/a&gt;がこの配列の範囲外である場合、&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsExceptionをスローし&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="ef7d2330d71db6f764d35eea14e9ab73aac72b9c" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.ByteArray%24get%28kotlin.Int%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">場合&lt;a href=&quot;get#kotlin.ByteArray%24get%28kotlin.Int%29%2Findex&quot;&gt;インデックスが&lt;/a&gt;この配列の範囲外である、スロー&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;はIndexOutOfBoundsExceptionの&lt;/a&gt;動作が指定されていないKotlin / JSを除い。</target>
        </trans-unit>
        <trans-unit id="8b70a8c2ba34131364e28b2512d35483af00f19a" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.ByteArray%24get%28kotlin.Int%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;get#kotlin.ByteArray%24get%28kotlin.Int%29%2Findex&quot;&gt;インデックス&lt;/a&gt;がこの配列の範囲外の場合、&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsExceptionをスローし&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="44768c507a4b76808d52b98c0254864df2b87ee5" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.ByteArray%24get(kotlin.Int)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">場合&lt;a href=&quot;get#kotlin.ByteArray%24get(kotlin.Int)/index&quot;&gt;インデックスが&lt;/a&gt;この配列の範囲外である、スロー&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;はIndexOutOfBoundsExceptionの&lt;/a&gt;動作が指定されていないKotlin / JSを除い。</target>
        </trans-unit>
        <trans-unit id="f43d6c6804b42a2af7611d19f88a2487e6000d7d" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.ByteArray%24get(kotlin.Int)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;get#kotlin.ByteArray%24get(kotlin.Int)/index&quot;&gt;インデックス&lt;/a&gt;がこの配列の範囲外である場合、&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsExceptionをスローし&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="b2c1eabbbf7b712271d653fdcbd433c34590b4d2" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.CharArray%24get%28kotlin.Int%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">場合&lt;a href=&quot;get#kotlin.CharArray%24get%28kotlin.Int%29%2Findex&quot;&gt;インデックスが&lt;/a&gt;この配列の範囲外である、スロー&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;はIndexOutOfBoundsExceptionの&lt;/a&gt;動作が指定されていないKotlin / JSを除い。</target>
        </trans-unit>
        <trans-unit id="87b690a93b6a351a33df7161fb636a57f37c003d" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.CharArray%24get%28kotlin.Int%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;get#kotlin.CharArray%24get%28kotlin.Int%29%2Findex&quot;&gt;インデックス&lt;/a&gt;がこの配列の範囲外の場合、&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsExceptionをスローし&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="241fbd990a613b4ddb1929a451c61d8c2e0d5edd" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.CharArray%24get(kotlin.Int)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">場合&lt;a href=&quot;get#kotlin.CharArray%24get(kotlin.Int)/index&quot;&gt;インデックスが&lt;/a&gt;この配列の範囲外である、スロー&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;はIndexOutOfBoundsExceptionの&lt;/a&gt;動作が指定されていないKotlin / JSを除い。</target>
        </trans-unit>
        <trans-unit id="b8b15067f57d32d666005f69272a8002614e5c40" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.CharArray%24get(kotlin.Int)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;get#kotlin.CharArray%24get(kotlin.Int)/index&quot;&gt;インデックス&lt;/a&gt;がこの配列の範囲外である場合、&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsExceptionをスローし&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="9330d9da57aef0aed8c13aee6dc337fbeb829bff" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.DoubleArray%24get%28kotlin.Int%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">場合&lt;a href=&quot;get#kotlin.DoubleArray%24get%28kotlin.Int%29%2Findex&quot;&gt;インデックスが&lt;/a&gt;この配列の範囲外である、スロー&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;はIndexOutOfBoundsExceptionの&lt;/a&gt;動作が指定されていないKotlin / JSを除い。</target>
        </trans-unit>
        <trans-unit id="6c4f88ba4389bfc9a900b68407e80b12b5ae9b02" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.DoubleArray%24get%28kotlin.Int%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;get#kotlin.DoubleArray%24get%28kotlin.Int%29%2Findex&quot;&gt;インデックス&lt;/a&gt;がこの配列の範囲外の場合、&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsExceptionをスローし&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="10f0cc22e805af048a8e1811a9b67195fd374456" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.DoubleArray%24get(kotlin.Int)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">場合&lt;a href=&quot;get#kotlin.DoubleArray%24get(kotlin.Int)/index&quot;&gt;インデックスが&lt;/a&gt;この配列の範囲外である、スロー&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;はIndexOutOfBoundsExceptionの&lt;/a&gt;動作が指定されていないKotlin / JSを除い。</target>
        </trans-unit>
        <trans-unit id="4dfbdf3e234c922a5068cafdfeeced9cce315c84" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.DoubleArray%24get(kotlin.Int)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;get#kotlin.DoubleArray%24get(kotlin.Int)/index&quot;&gt;インデックス&lt;/a&gt;がこの配列の範囲外である場合、&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsExceptionをスローし&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="4839668bfa4ee00994900630081eeb5714f95752" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.FloatArray%24get%28kotlin.Int%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">場合&lt;a href=&quot;get#kotlin.FloatArray%24get%28kotlin.Int%29%2Findex&quot;&gt;インデックスが&lt;/a&gt;この配列の範囲外である、スロー&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;はIndexOutOfBoundsExceptionの&lt;/a&gt;動作が指定されていないKotlin / JSを除い。</target>
        </trans-unit>
        <trans-unit id="0e047d5c3d28e4eb74b19b8706f2359f4a496d1c" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.FloatArray%24get%28kotlin.Int%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;get#kotlin.FloatArray%24get%28kotlin.Int%29%2Findex&quot;&gt;インデックス&lt;/a&gt;がこの配列の範囲外の場合、&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsExceptionをスローし&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="36ed57a482212b43296278a3f740dad9f4d581db" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.FloatArray%24get(kotlin.Int)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">場合&lt;a href=&quot;get#kotlin.FloatArray%24get(kotlin.Int)/index&quot;&gt;インデックスが&lt;/a&gt;この配列の範囲外である、スロー&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;はIndexOutOfBoundsExceptionの&lt;/a&gt;動作が指定されていないKotlin / JSを除い。</target>
        </trans-unit>
        <trans-unit id="00d6097085f2efeb6f60d64620ecac34ef7d8a30" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.FloatArray%24get(kotlin.Int)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;get#kotlin.FloatArray%24get(kotlin.Int)/index&quot;&gt;インデックス&lt;/a&gt;がこの配列の範囲外である場合、&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsExceptionをスローし&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="33490febae2a178f4655be7a154612da34a0c4a5" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.IntArray%24get%28kotlin.Int%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">場合&lt;a href=&quot;get#kotlin.IntArray%24get%28kotlin.Int%29%2Findex&quot;&gt;インデックスが&lt;/a&gt;この配列の範囲外である、スロー&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;はIndexOutOfBoundsExceptionの&lt;/a&gt;動作が指定されていないKotlin / JSを除い。</target>
        </trans-unit>
        <trans-unit id="9d2ed5d24fc59700154e317864d8c0e6739505a7" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.IntArray%24get%28kotlin.Int%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;get#kotlin.IntArray%24get%28kotlin.Int%29%2Findex&quot;&gt;インデックス&lt;/a&gt;がこの配列の範囲外の場合、&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsExceptionをスローし&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="c696e216e6286ada0cb5195502952a789b32f98a" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.IntArray%24get(kotlin.Int)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">場合&lt;a href=&quot;get#kotlin.IntArray%24get(kotlin.Int)/index&quot;&gt;インデックスが&lt;/a&gt;この配列の範囲外である、スロー&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;はIndexOutOfBoundsExceptionの&lt;/a&gt;動作が指定されていないKotlin / JSを除い。</target>
        </trans-unit>
        <trans-unit id="292f4907701770c13a3d993a8fbab1351a08f93b" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.IntArray%24get(kotlin.Int)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;get#kotlin.IntArray%24get(kotlin.Int)/index&quot;&gt;インデックス&lt;/a&gt;がこの配列の範囲外である場合、&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsExceptionをスローし&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="b5f087deed2fca1a1e09b14c363914201ae8d71a" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.LongArray%24get%28kotlin.Int%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">場合&lt;a href=&quot;get#kotlin.LongArray%24get%28kotlin.Int%29%2Findex&quot;&gt;インデックスが&lt;/a&gt;この配列の範囲外である、スロー&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;はIndexOutOfBoundsExceptionの&lt;/a&gt;動作が指定されていないKotlin / JSを除い。</target>
        </trans-unit>
        <trans-unit id="256c8bdcf7db878fc6b6b13f96f3eeecab8e97a4" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.LongArray%24get%28kotlin.Int%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;get#kotlin.LongArray%24get%28kotlin.Int%29%2Findex&quot;&gt;インデックス&lt;/a&gt;がこの配列の範囲外の場合、&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsExceptionをスローし&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="a243908860038c9462a433c221a21a1025d24e0f" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.LongArray%24get(kotlin.Int)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">場合&lt;a href=&quot;get#kotlin.LongArray%24get(kotlin.Int)/index&quot;&gt;インデックスが&lt;/a&gt;この配列の範囲外である、スロー&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;はIndexOutOfBoundsExceptionの&lt;/a&gt;動作が指定されていないKotlin / JSを除い。</target>
        </trans-unit>
        <trans-unit id="78cc83cee81cdb56f83d5139ff270e833535dfdf" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.LongArray%24get(kotlin.Int)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;get#kotlin.LongArray%24get(kotlin.Int)/index&quot;&gt;インデックス&lt;/a&gt;がこの配列の範囲外である場合、&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsExceptionをスローし&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="999680793def1bf95ce65d25a967348c34b8ed9d" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.ShortArray%24get%28kotlin.Int%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">場合&lt;a href=&quot;get#kotlin.ShortArray%24get%28kotlin.Int%29%2Findex&quot;&gt;インデックスが&lt;/a&gt;この配列の範囲外である、スロー&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;はIndexOutOfBoundsExceptionの&lt;/a&gt;動作が指定されていないKotlin / JSを除い。</target>
        </trans-unit>
        <trans-unit id="343f876e9f1eb0b0c40cd9f7901fcfe6d86bd975" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.ShortArray%24get%28kotlin.Int%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;get#kotlin.ShortArray%24get%28kotlin.Int%29%2Findex&quot;&gt;インデックス&lt;/a&gt;がこの配列の範囲外の場合、&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsExceptionをスローし&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="3f013fc6e90baae75eb837993cde762ea2af5800" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.ShortArray%24get(kotlin.Int)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">場合&lt;a href=&quot;get#kotlin.ShortArray%24get(kotlin.Int)/index&quot;&gt;インデックスが&lt;/a&gt;この配列の範囲外である、スロー&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;はIndexOutOfBoundsExceptionの&lt;/a&gt;動作が指定されていないKotlin / JSを除い。</target>
        </trans-unit>
        <trans-unit id="58754cd9e0e7d7a8702d78a5c9ba2d2f0156bea9" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.ShortArray%24get(kotlin.Int)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;get#kotlin.ShortArray%24get(kotlin.Int)/index&quot;&gt;インデックス&lt;/a&gt;がこの配列の範囲外である場合、&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsExceptionをスローし&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="2e96f00fc82613fc72e45bd901e49fdbd42b006e" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.String%24get%28kotlin.Int%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this string, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">場合は&lt;a href=&quot;get#kotlin.String%24get%28kotlin.Int%29%2Findex&quot;&gt;、インデックスが&lt;/a&gt;この文字列の範囲外である、スロー&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;はIndexOutOfBoundsExceptionを&lt;/a&gt;動作が指定されていないKotlin / JSを除き。</target>
        </trans-unit>
        <trans-unit id="121146c1773ced51b85c510f0c9a740fcee4401a" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.String%24get%28kotlin.Int%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this string, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;get#kotlin.String%24get%28kotlin.Int%29%2Findex&quot;&gt;インデックス&lt;/a&gt;がこの文字列の範囲外の場合、&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsExceptionをスローし&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="7f767176ab77d40deae0e60f62a498403a05d542" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.String%24get(kotlin.Int)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this string, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">場合は&lt;a href=&quot;get#kotlin.String%24get(kotlin.Int)/index&quot;&gt;、インデックスが&lt;/a&gt;この文字列の範囲外である、スロー&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;はIndexOutOfBoundsExceptionを&lt;/a&gt;動作が指定されていないKotlin / JSを除き。</target>
        </trans-unit>
        <trans-unit id="46f07635940947a7d146432e3e2c1f7467a6f5db" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.String%24get(kotlin.Int)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this string, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;get#kotlin.String%24get(kotlin.Int)/index&quot;&gt;インデックス&lt;/a&gt;がこの文字列の範囲外である場合、&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsExceptionをスローし&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="d9b4a8848b9c8e64b348afb59840b8348887cc19" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.UByteArray%24get%28kotlin.Int%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">場合&lt;a href=&quot;get#kotlin.UByteArray%24get%28kotlin.Int%29%2Findex&quot;&gt;インデックスが&lt;/a&gt;この配列の範囲外である、スロー&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;はIndexOutOfBoundsExceptionの&lt;/a&gt;動作が指定されていないKotlin / JSを除い。</target>
        </trans-unit>
        <trans-unit id="1e7b8e174e484d14d4beffbac84f58ae1fb244d4" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.UByteArray%24get(kotlin.Int)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">場合&lt;a href=&quot;get#kotlin.UByteArray%24get(kotlin.Int)/index&quot;&gt;インデックスが&lt;/a&gt;この配列の範囲外である、スロー&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;はIndexOutOfBoundsExceptionの&lt;/a&gt;動作が指定されていないKotlin / JSを除い。</target>
        </trans-unit>
        <trans-unit id="c42b44be3aa2af1c6b520077f8536d89266d3575" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.UIntArray%24get%28kotlin.Int%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">場合&lt;a href=&quot;get#kotlin.UIntArray%24get%28kotlin.Int%29%2Findex&quot;&gt;インデックスが&lt;/a&gt;この配列の範囲外である、スロー&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;はIndexOutOfBoundsExceptionの&lt;/a&gt;動作が指定されていないKotlin / JSを除い。</target>
        </trans-unit>
        <trans-unit id="2e0b0214b72fe8c7cf14b755a41ea870bd89d740" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.UIntArray%24get(kotlin.Int)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">場合&lt;a href=&quot;get#kotlin.UIntArray%24get(kotlin.Int)/index&quot;&gt;インデックスが&lt;/a&gt;この配列の範囲外である、スロー&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;はIndexOutOfBoundsExceptionの&lt;/a&gt;動作が指定されていないKotlin / JSを除い。</target>
        </trans-unit>
        <trans-unit id="9aa63b031868d224c7a7f44af55292bbb50b21f2" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.ULongArray%24get%28kotlin.Int%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">場合&lt;a href=&quot;get#kotlin.ULongArray%24get%28kotlin.Int%29%2Findex&quot;&gt;インデックスが&lt;/a&gt;この配列の範囲外である、スロー&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;はIndexOutOfBoundsExceptionの&lt;/a&gt;動作が指定されていないKotlin / JSを除い。</target>
        </trans-unit>
        <trans-unit id="f9de9e44f5252019b83cabd1b363c2f8b0aa829b" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.ULongArray%24get(kotlin.Int)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">場合&lt;a href=&quot;get#kotlin.ULongArray%24get(kotlin.Int)/index&quot;&gt;インデックスが&lt;/a&gt;この配列の範囲外である、スロー&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;はIndexOutOfBoundsExceptionの&lt;/a&gt;動作が指定されていないKotlin / JSを除い。</target>
        </trans-unit>
        <trans-unit id="5f0b48aa5778c165df7d576ad84fb99a045c6acc" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.UShortArray%24get%28kotlin.Int%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">場合&lt;a href=&quot;get#kotlin.UShortArray%24get%28kotlin.Int%29%2Findex&quot;&gt;インデックスが&lt;/a&gt;この配列の範囲外である、スロー&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;はIndexOutOfBoundsExceptionの&lt;/a&gt;動作が指定されていないKotlin / JSを除い。</target>
        </trans-unit>
        <trans-unit id="75d4175ea3cfca94ca7e47438e4bdab18fab5198" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.UShortArray%24get(kotlin.Int)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">場合&lt;a href=&quot;get#kotlin.UShortArray%24get(kotlin.Int)/index&quot;&gt;インデックスが&lt;/a&gt;この配列の範囲外である、スロー&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;はIndexOutOfBoundsExceptionの&lt;/a&gt;動作が指定されていないKotlin / JSを除い。</target>
        </trans-unit>
        <trans-unit id="3832840323d1968de06c86d1668de66bc5395923" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;on-enter#kotlin.io.FileTreeWalk%24onEnter%28kotlin.Function1%28%28java.io.File%2C+kotlin.Boolean%29%29%29%2Ffunction&quot;&gt;function&lt;/a&gt; returns &lt;code&gt;false&lt;/code&gt; the directory is not entered and neither it nor its files are visited.</source>
          <target state="translated">&lt;a href=&quot;on-enter#kotlin.io.FileTreeWalk%24onEnter%28kotlin.Function1%28%28java.io.File%2C+kotlin.Boolean%29%29%29%2Ffunction&quot;&gt;関数&lt;/a&gt;が &lt;code&gt;false&lt;/code&gt; を返す場合、ディレクトリには入れず、ディレクトリもファイルも訪問しません。</target>
        </trans-unit>
        <trans-unit id="76181a81bd674f99c87a97a3e1468fb754d1fc87" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;on-enter#kotlin.io.FileTreeWalk%24onEnter(kotlin.Function1((java.io.File,%20kotlin.Boolean)))/function&quot;&gt;function&lt;/a&gt; returns &lt;code&gt;false&lt;/code&gt; the directory is not entered and neither it nor its files are visited.</source>
          <target state="translated">&lt;a href=&quot;on-enter#kotlin.io.FileTreeWalk%24onEnter(kotlin.Function1((java.io.File,%20kotlin.Boolean)))/function&quot;&gt;関数&lt;/a&gt;が &lt;code&gt;false&lt;/code&gt; を返す場合、ディレクトリは入力されず、ディレクトリもそのファイルもアクセスされません。</target>
        </trans-unit>
        <trans-unit id="0a2285dd49856fe4825e17e694cf3fa18696091c" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;reduce-to#kotlin.collections%24reduceTo%28kotlin.collections.Grouping%28%28kotlin.collections.reduceTo.T%2C+kotlin.collections.reduceTo.K%29%29%2C+kotlin.collections.reduceTo.M%2C+kotlin.Function3%28%28kotlin.collections.reduceTo.K%2C+kotlin.collections.reduceTo.S%2C+kotlin.collections.reduceTo.T%2C+%29%29%29%2Fdestination&quot;&gt;destination&lt;/a&gt; map already has a value corresponding to the key of some group, that value is used as an initial value of the accumulator for that group and the first element of that group is also subjected to the &lt;a href=&quot;reduce-to#kotlin.collections%24reduceTo%28kotlin.collections.Grouping%28%28kotlin.collections.reduceTo.T%2C+kotlin.collections.reduceTo.K%29%29%2C+kotlin.collections.reduceTo.M%2C+kotlin.Function3%28%28kotlin.collections.reduceTo.K%2C+kotlin.collections.reduceTo.S%2C+kotlin.collections.reduceTo.T%2C+%29%29%29%2Foperation&quot;&gt;operation&lt;/a&gt;.</source>
          <target state="translated">場合&lt;a href=&quot;reduce-to#kotlin.collections%24reduceTo%28kotlin.collections.Grouping%28%28kotlin.collections.reduceTo.T%2C+kotlin.collections.reduceTo.K%29%29%2C+kotlin.collections.reduceTo.M%2C+kotlin.Function3%28%28kotlin.collections.reduceTo.K%2C+kotlin.collections.reduceTo.S%2C+kotlin.collections.reduceTo.T%2C+%29%29%29%2Fdestination&quot;&gt;宛先&lt;/a&gt;マップは、すでにいくつかのグループのキーに対応する値を有し、その値は、そのグループのためのアキュムレータの初期値として使用され、そのグループの最初の要素は、に供される&lt;a href=&quot;reduce-to#kotlin.collections%24reduceTo%28kotlin.collections.Grouping%28%28kotlin.collections.reduceTo.T%2C+kotlin.collections.reduceTo.K%29%29%2C+kotlin.collections.reduceTo.M%2C+kotlin.Function3%28%28kotlin.collections.reduceTo.K%2C+kotlin.collections.reduceTo.S%2C+kotlin.collections.reduceTo.T%2C+%29%29%29%2Foperation&quot;&gt;操作&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="aaabd446cf116a2750ab94bb32f8d62327631fb7" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;reduce-to#kotlin.collections%24reduceTo(kotlin.collections.Grouping((kotlin.collections.reduceTo.T,%20kotlin.collections.reduceTo.K)),%20kotlin.collections.reduceTo.M,%20kotlin.Function3((kotlin.collections.reduceTo.K,%20kotlin.collections.reduceTo.S,%20kotlin.collections.reduceTo.T,%20)))/destination&quot;&gt;destination&lt;/a&gt; map already has a value corresponding to the key of some group, that value is used as an initial value of the accumulator for that group and the first element of that group is also subjected to the &lt;a href=&quot;reduce-to#kotlin.collections%24reduceTo(kotlin.collections.Grouping((kotlin.collections.reduceTo.T,%20kotlin.collections.reduceTo.K)),%20kotlin.collections.reduceTo.M,%20kotlin.Function3((kotlin.collections.reduceTo.K,%20kotlin.collections.reduceTo.S,%20kotlin.collections.reduceTo.T,%20)))/operation&quot;&gt;operation&lt;/a&gt;.</source>
          <target state="translated">場合&lt;a href=&quot;reduce-to#kotlin.collections%24reduceTo(kotlin.collections.Grouping((kotlin.collections.reduceTo.T,%20kotlin.collections.reduceTo.K)),%20kotlin.collections.reduceTo.M,%20kotlin.Function3((kotlin.collections.reduceTo.K,%20kotlin.collections.reduceTo.S,%20kotlin.collections.reduceTo.T,%20)))/destination&quot;&gt;宛先&lt;/a&gt;マップは、すでにいくつかのグループのキーに対応する値を有し、その値は、そのグループのためのアキュムレータの初期値として使用され、そのグループの最初の要素は、に供される&lt;a href=&quot;reduce-to#kotlin.collections%24reduceTo(kotlin.collections.Grouping((kotlin.collections.reduceTo.T,%20kotlin.collections.reduceTo.K)),%20kotlin.collections.reduceTo.M,%20kotlin.Function3((kotlin.collections.reduceTo.K,%20kotlin.collections.reduceTo.S,%20kotlin.collections.reduceTo.T,%20)))/operation&quot;&gt;操作&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9c1cf29eaa37e1a848f362e9496c70a7361cc3c0" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.Array%24set%28kotlin.Int%2C+kotlin.Array.T%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">場合&lt;a href=&quot;set#kotlin.Array%24set%28kotlin.Int%2C+kotlin.Array.T%29%2Findex&quot;&gt;インデックスが&lt;/a&gt;この配列の範囲外である、スロー&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;はIndexOutOfBoundsExceptionの&lt;/a&gt;動作が指定されていないKotlin / JSを除い。</target>
        </trans-unit>
        <trans-unit id="b4795422de28a107d2b93ad77a19fea520c69382" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.Array%24set%28kotlin.Int%2C+kotlin.Array.T%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;set#kotlin.Array%24set%28kotlin.Int%2C+kotlin.Array.T%29%2Findex&quot;&gt;インデックス&lt;/a&gt;がこの配列の範囲外の場合、&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsExceptionをスローし&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="3500c6a3ccdfdd558e70d61568491d24a57dba35" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.Array%24set(kotlin.Int,%20kotlin.Array.T)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">場合&lt;a href=&quot;set#kotlin.Array%24set(kotlin.Int,%20kotlin.Array.T)/index&quot;&gt;インデックスが&lt;/a&gt;この配列の範囲外である、スロー&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;はIndexOutOfBoundsExceptionの&lt;/a&gt;動作が指定されていないKotlin / JSを除い。</target>
        </trans-unit>
        <trans-unit id="07848e5d2cb6b751154cf49081d01d01ad9a0467" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.Array%24set(kotlin.Int,%20kotlin.Array.T)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;set#kotlin.Array%24set(kotlin.Int,%20kotlin.Array.T)/index&quot;&gt;インデックス&lt;/a&gt;がこの配列の範囲外である場合、&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsExceptionをスローし&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="ad0c6c091ccda18739aa6f3577cd89dd09841078" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.BooleanArray%24set%28kotlin.Int%2C+kotlin.Boolean%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">場合&lt;a href=&quot;set#kotlin.BooleanArray%24set%28kotlin.Int%2C+kotlin.Boolean%29%2Findex&quot;&gt;インデックスが&lt;/a&gt;この配列の範囲外である、スロー&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;はIndexOutOfBoundsExceptionの&lt;/a&gt;動作が指定されていないKotlin / JSを除い。</target>
        </trans-unit>
        <trans-unit id="835319d043a0f65a5eee60807011570250691591" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.BooleanArray%24set%28kotlin.Int%2C+kotlin.Boolean%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;set#kotlin.BooleanArray%24set%28kotlin.Int%2C+kotlin.Boolean%29%2Findex&quot;&gt;インデックス&lt;/a&gt;がこの配列の範囲外の場合、&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsExceptionをスローし&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="7b50c553e7ac61ad18a55fb2deb2fd76235f23fd" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.BooleanArray%24set(kotlin.Int,%20kotlin.Boolean)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">場合&lt;a href=&quot;set#kotlin.BooleanArray%24set(kotlin.Int,%20kotlin.Boolean)/index&quot;&gt;インデックスが&lt;/a&gt;この配列の範囲外である、スロー&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;はIndexOutOfBoundsExceptionの&lt;/a&gt;動作が指定されていないKotlin / JSを除い。</target>
        </trans-unit>
        <trans-unit id="07ab11928fd8cb50782aa576d57f34d36dac144c" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.BooleanArray%24set(kotlin.Int,%20kotlin.Boolean)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;set#kotlin.BooleanArray%24set(kotlin.Int,%20kotlin.Boolean)/index&quot;&gt;インデックス&lt;/a&gt;がこの配列の範囲外である場合、&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsExceptionをスローし&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="527f471fdf4e268be1d4b9f1ebfd516bc71f229b" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.ByteArray%24set%28kotlin.Int%2C+kotlin.Byte%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">場合&lt;a href=&quot;set#kotlin.ByteArray%24set%28kotlin.Int%2C+kotlin.Byte%29%2Findex&quot;&gt;インデックスが&lt;/a&gt;この配列の範囲外である、スロー&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;はIndexOutOfBoundsExceptionの&lt;/a&gt;動作が指定されていないKotlin / JSを除い。</target>
        </trans-unit>
        <trans-unit id="42963185cae43f2e758e143f41ae72d95b5c4100" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.ByteArray%24set%28kotlin.Int%2C+kotlin.Byte%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;set#kotlin.ByteArray%24set%28kotlin.Int%2C+kotlin.Byte%29%2Findex&quot;&gt;インデックス&lt;/a&gt;がこの配列の範囲外の場合、&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsExceptionをスローし&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="cdf2a2f9fb25aa14921ec99b9c2441f2f3aa607b" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.ByteArray%24set(kotlin.Int,%20kotlin.Byte)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">場合&lt;a href=&quot;set#kotlin.ByteArray%24set(kotlin.Int,%20kotlin.Byte)/index&quot;&gt;インデックスが&lt;/a&gt;この配列の範囲外である、スロー&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;はIndexOutOfBoundsExceptionの&lt;/a&gt;動作が指定されていないKotlin / JSを除い。</target>
        </trans-unit>
        <trans-unit id="e63aef66dc4f176a6824753a6cdeb0ca0faba262" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.ByteArray%24set(kotlin.Int,%20kotlin.Byte)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;set#kotlin.ByteArray%24set(kotlin.Int,%20kotlin.Byte)/index&quot;&gt;インデックス&lt;/a&gt;がこの配列の範囲外である場合、&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsExceptionをスローし&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="c8618ed56cd06c8c291f923aab1b1a054f5002b8" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.CharArray%24set%28kotlin.Int%2C+kotlin.Char%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">場合&lt;a href=&quot;set#kotlin.CharArray%24set%28kotlin.Int%2C+kotlin.Char%29%2Findex&quot;&gt;インデックスが&lt;/a&gt;この配列の範囲外である、スロー&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;はIndexOutOfBoundsExceptionの&lt;/a&gt;動作が指定されていないKotlin / JSを除い。</target>
        </trans-unit>
        <trans-unit id="16b81d70965f40eb90b072a5e9edb009e7b41db0" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.CharArray%24set%28kotlin.Int%2C+kotlin.Char%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;set#kotlin.CharArray%24set%28kotlin.Int%2C+kotlin.Char%29%2Findex&quot;&gt;インデックス&lt;/a&gt;がこの配列の範囲外の場合、&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsExceptionをスローし&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="ff5ba893f49fd7a741281bd097b53c6298362fcd" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.CharArray%24set(kotlin.Int,%20kotlin.Char)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">場合&lt;a href=&quot;set#kotlin.CharArray%24set(kotlin.Int,%20kotlin.Char)/index&quot;&gt;インデックスが&lt;/a&gt;この配列の範囲外である、スロー&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;はIndexOutOfBoundsExceptionの&lt;/a&gt;動作が指定されていないKotlin / JSを除い。</target>
        </trans-unit>
        <trans-unit id="3e60264d0d2c56881b96bac79b4666814c5f9bc5" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.CharArray%24set(kotlin.Int,%20kotlin.Char)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;set#kotlin.CharArray%24set(kotlin.Int,%20kotlin.Char)/index&quot;&gt;インデックス&lt;/a&gt;がこの配列の範囲外である場合、&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsExceptionをスローし&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="684c4e170a424d705f9e13c5cda4d575a1e09f13" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.DoubleArray%24set%28kotlin.Int%2C+kotlin.Double%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">場合&lt;a href=&quot;set#kotlin.DoubleArray%24set%28kotlin.Int%2C+kotlin.Double%29%2Findex&quot;&gt;インデックスが&lt;/a&gt;この配列の範囲外である、スロー&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;はIndexOutOfBoundsExceptionの&lt;/a&gt;動作が指定されていないKotlin / JSを除い。</target>
        </trans-unit>
        <trans-unit id="f733c2a99de30ff7689107b0fce91469fa4b4623" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.DoubleArray%24set%28kotlin.Int%2C+kotlin.Double%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;set#kotlin.DoubleArray%24set%28kotlin.Int%2C+kotlin.Double%29%2Findex&quot;&gt;インデックス&lt;/a&gt;がこの配列の範囲外の場合、&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsExceptionをスローし&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="b3adc428d0247ef8e64e3b606fc8678debad6823" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.DoubleArray%24set(kotlin.Int,%20kotlin.Double)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">場合&lt;a href=&quot;set#kotlin.DoubleArray%24set(kotlin.Int,%20kotlin.Double)/index&quot;&gt;インデックスが&lt;/a&gt;この配列の範囲外である、スロー&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;はIndexOutOfBoundsExceptionの&lt;/a&gt;動作が指定されていないKotlin / JSを除い。</target>
        </trans-unit>
        <trans-unit id="1f1fe770f48c4c991ab6ba93f5448bca6a109d8e" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.DoubleArray%24set(kotlin.Int,%20kotlin.Double)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;set#kotlin.DoubleArray%24set(kotlin.Int,%20kotlin.Double)/index&quot;&gt;インデックス&lt;/a&gt;がこの配列の範囲外である場合、&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsExceptionをスローし&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="09664e73fde927f6d22f3ea9f4070e59236e924f" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.FloatArray%24set%28kotlin.Int%2C+kotlin.Float%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">場合&lt;a href=&quot;set#kotlin.FloatArray%24set%28kotlin.Int%2C+kotlin.Float%29%2Findex&quot;&gt;インデックスが&lt;/a&gt;この配列の範囲外である、スロー&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;はIndexOutOfBoundsExceptionの&lt;/a&gt;動作が指定されていないKotlin / JSを除い。</target>
        </trans-unit>
        <trans-unit id="dde11a436e59034272f619d39049718d3c4685e2" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.FloatArray%24set%28kotlin.Int%2C+kotlin.Float%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;set#kotlin.FloatArray%24set%28kotlin.Int%2C+kotlin.Float%29%2Findex&quot;&gt;インデックス&lt;/a&gt;がこの配列の範囲外の場合、&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsExceptionをスローし&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="ab4dcb980391ca205a536de0ce8e05a3c6d15d9b" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.FloatArray%24set(kotlin.Int,%20kotlin.Float)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">場合&lt;a href=&quot;set#kotlin.FloatArray%24set(kotlin.Int,%20kotlin.Float)/index&quot;&gt;インデックスが&lt;/a&gt;この配列の範囲外である、スロー&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;はIndexOutOfBoundsExceptionの&lt;/a&gt;動作が指定されていないKotlin / JSを除い。</target>
        </trans-unit>
        <trans-unit id="d5712029ee942822232df2cd5dbe660126d19048" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.FloatArray%24set(kotlin.Int,%20kotlin.Float)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;set#kotlin.FloatArray%24set(kotlin.Int,%20kotlin.Float)/index&quot;&gt;インデックス&lt;/a&gt;がこの配列の範囲外である場合、&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsExceptionをスローし&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="1000d31cc93809459dc4dbcc455954d9ddc757d2" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.IntArray%24set%28kotlin.Int%2C+kotlin.Int%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">場合&lt;a href=&quot;set#kotlin.IntArray%24set%28kotlin.Int%2C+kotlin.Int%29%2Findex&quot;&gt;インデックスが&lt;/a&gt;この配列の範囲外である、スロー&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;はIndexOutOfBoundsExceptionの&lt;/a&gt;動作が指定されていないKotlin / JSを除い。</target>
        </trans-unit>
        <trans-unit id="ab2984691cfff299ebe407e2aee780db1db59dff" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.IntArray%24set%28kotlin.Int%2C+kotlin.Int%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;set#kotlin.IntArray%24set%28kotlin.Int%2C+kotlin.Int%29%2Findex&quot;&gt;インデックス&lt;/a&gt;がこの配列の範囲外の場合、&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsExceptionをスローし&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="a3d5f8f3a49afff92d2de250d1c268d9641231e3" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.IntArray%24set(kotlin.Int,%20kotlin.Int)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">場合&lt;a href=&quot;set#kotlin.IntArray%24set(kotlin.Int,%20kotlin.Int)/index&quot;&gt;インデックスが&lt;/a&gt;この配列の範囲外である、スロー&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;はIndexOutOfBoundsExceptionの&lt;/a&gt;動作が指定されていないKotlin / JSを除い。</target>
        </trans-unit>
        <trans-unit id="b0d669004672e2a64c3a7a12296c03199c121a94" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.IntArray%24set(kotlin.Int,%20kotlin.Int)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;set#kotlin.IntArray%24set(kotlin.Int,%20kotlin.Int)/index&quot;&gt;インデックス&lt;/a&gt;がこの配列の範囲外である場合、&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsExceptionをスローし&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="f173e322ccd56addf649214d8ae7803d5dfa5b94" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.LongArray%24set%28kotlin.Int%2C+kotlin.Long%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">場合&lt;a href=&quot;set#kotlin.LongArray%24set%28kotlin.Int%2C+kotlin.Long%29%2Findex&quot;&gt;インデックスが&lt;/a&gt;この配列の範囲外である、スロー&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;はIndexOutOfBoundsExceptionの&lt;/a&gt;動作が指定されていないKotlin / JSを除い。</target>
        </trans-unit>
        <trans-unit id="f409e29966bb054dfd47826d8dd2e870d206d24a" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.LongArray%24set%28kotlin.Int%2C+kotlin.Long%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;set#kotlin.LongArray%24set%28kotlin.Int%2C+kotlin.Long%29%2Findex&quot;&gt;インデックス&lt;/a&gt;がこの配列の範囲外の場合、&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsExceptionをスローし&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="1fba4254a8fc486709d4c8d0c1ff6c237b4ac68e" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.LongArray%24set(kotlin.Int,%20kotlin.Long)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">場合&lt;a href=&quot;set#kotlin.LongArray%24set(kotlin.Int,%20kotlin.Long)/index&quot;&gt;インデックスが&lt;/a&gt;この配列の範囲外である、スロー&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;はIndexOutOfBoundsExceptionの&lt;/a&gt;動作が指定されていないKotlin / JSを除い。</target>
        </trans-unit>
        <trans-unit id="64c2d595bfbfd6b07a001299c27dab6257d421de" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.LongArray%24set(kotlin.Int,%20kotlin.Long)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;set#kotlin.LongArray%24set(kotlin.Int,%20kotlin.Long)/index&quot;&gt;インデックス&lt;/a&gt;がこの配列の範囲外である場合、&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsExceptionをスローし&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="7a8044147072cea61ae2e90888654fdcbbe920ee" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.ShortArray%24set%28kotlin.Int%2C+kotlin.Short%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">場合&lt;a href=&quot;set#kotlin.ShortArray%24set%28kotlin.Int%2C+kotlin.Short%29%2Findex&quot;&gt;インデックスが&lt;/a&gt;この配列の範囲外である、スロー&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;はIndexOutOfBoundsExceptionの&lt;/a&gt;動作が指定されていないKotlin / JSを除い。</target>
        </trans-unit>
        <trans-unit id="382bd7e3336be8af1102464e37fa8b63b568ca7c" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.ShortArray%24set%28kotlin.Int%2C+kotlin.Short%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;set#kotlin.ShortArray%24set%28kotlin.Int%2C+kotlin.Short%29%2Findex&quot;&gt;インデックス&lt;/a&gt;がこの配列の範囲外の場合、&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsExceptionをスローし&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="a1175979092412882336d28661ca4a85fdaf319b" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.ShortArray%24set(kotlin.Int,%20kotlin.Short)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">場合&lt;a href=&quot;set#kotlin.ShortArray%24set(kotlin.Int,%20kotlin.Short)/index&quot;&gt;インデックスが&lt;/a&gt;この配列の範囲外である、スロー&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;はIndexOutOfBoundsExceptionの&lt;/a&gt;動作が指定されていないKotlin / JSを除い。</target>
        </trans-unit>
        <trans-unit id="e23f36b4d54bf9c3c45bcbc7bf634715deb9f3f1" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.ShortArray%24set(kotlin.Int,%20kotlin.Short)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;set#kotlin.ShortArray%24set(kotlin.Int,%20kotlin.Short)/index&quot;&gt;インデックス&lt;/a&gt;がこの配列の範囲外である場合、&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsExceptionをスローし&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="bb1e18b251850707f84797db758d97e17b714305" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.UByteArray%24set%28kotlin.Int%2C+kotlin.UByte%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">場合&lt;a href=&quot;set#kotlin.UByteArray%24set%28kotlin.Int%2C+kotlin.UByte%29%2Findex&quot;&gt;インデックスが&lt;/a&gt;この配列の範囲外である、スロー&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;はIndexOutOfBoundsExceptionの&lt;/a&gt;動作が指定されていないKotlin / JSを除い。</target>
        </trans-unit>
        <trans-unit id="adbaf189ba58957d0a7656eeb77ad6d9cf651830" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.UByteArray%24set(kotlin.Int,%20kotlin.UByte)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">場合&lt;a href=&quot;set#kotlin.UByteArray%24set(kotlin.Int,%20kotlin.UByte)/index&quot;&gt;インデックスが&lt;/a&gt;この配列の範囲外である、スロー&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;はIndexOutOfBoundsExceptionの&lt;/a&gt;動作が指定されていないKotlin / JSを除い。</target>
        </trans-unit>
        <trans-unit id="2b01aefe6d05f741cac19ebae49684d8f27b7c15" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.UIntArray%24set%28kotlin.Int%2C+kotlin.UInt%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">場合&lt;a href=&quot;set#kotlin.UIntArray%24set%28kotlin.Int%2C+kotlin.UInt%29%2Findex&quot;&gt;インデックスが&lt;/a&gt;この配列の範囲外である、スロー&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;はIndexOutOfBoundsExceptionの&lt;/a&gt;動作が指定されていないKotlin / JSを除い。</target>
        </trans-unit>
        <trans-unit id="2f924e8f004a96424c06cbbda49ed1c933ecc51d" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.UIntArray%24set(kotlin.Int,%20kotlin.UInt)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">場合&lt;a href=&quot;set#kotlin.UIntArray%24set(kotlin.Int,%20kotlin.UInt)/index&quot;&gt;インデックスが&lt;/a&gt;この配列の範囲外である、スロー&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;はIndexOutOfBoundsExceptionの&lt;/a&gt;動作が指定されていないKotlin / JSを除い。</target>
        </trans-unit>
        <trans-unit id="e0298f72be4df89660cb3cbfa8ca0b544a87436d" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.ULongArray%24set%28kotlin.Int%2C+kotlin.ULong%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">場合&lt;a href=&quot;set#kotlin.ULongArray%24set%28kotlin.Int%2C+kotlin.ULong%29%2Findex&quot;&gt;インデックスが&lt;/a&gt;この配列の範囲外である、スロー&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;はIndexOutOfBoundsExceptionの&lt;/a&gt;動作が指定されていないKotlin / JSを除い。</target>
        </trans-unit>
        <trans-unit id="e62a1584079789f235cbabd8612798e3939dc325" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.ULongArray%24set(kotlin.Int,%20kotlin.ULong)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">場合&lt;a href=&quot;set#kotlin.ULongArray%24set(kotlin.Int,%20kotlin.ULong)/index&quot;&gt;インデックスが&lt;/a&gt;この配列の範囲外である、スロー&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;はIndexOutOfBoundsExceptionの&lt;/a&gt;動作が指定されていないKotlin / JSを除い。</target>
        </trans-unit>
        <trans-unit id="c204bddc743f17a6a83f3273732caa9abcce98a1" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.UShortArray%24set%28kotlin.Int%2C+kotlin.UShort%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">場合&lt;a href=&quot;set#kotlin.UShortArray%24set%28kotlin.Int%2C+kotlin.UShort%29%2Findex&quot;&gt;インデックスが&lt;/a&gt;この配列の範囲外である、スロー&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;はIndexOutOfBoundsExceptionの&lt;/a&gt;動作が指定されていないKotlin / JSを除い。</target>
        </trans-unit>
        <trans-unit id="0fe9e7ed96bb0f5a9326e0294c5697a26a4745c9" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.UShortArray%24set(kotlin.Int,%20kotlin.UShort)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">場合&lt;a href=&quot;set#kotlin.UShortArray%24set(kotlin.Int,%20kotlin.UShort)/index&quot;&gt;インデックスが&lt;/a&gt;この配列の範囲外である、スロー&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;はIndexOutOfBoundsExceptionの&lt;/a&gt;動作が指定されていないKotlin / JSを除い。</target>
        </trans-unit>
        <trans-unit id="fd938f2e10e2d0fb410305f424f6360cc9c56338" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set-length#kotlin.text.StringBuilder%24setLength(kotlin.Int)/newLength&quot;&gt;newLength&lt;/a&gt; is less than the current length, it is changed to the specified &lt;a href=&quot;set-length#kotlin.text.StringBuilder%24setLength(kotlin.Int)/newLength&quot;&gt;newLength&lt;/a&gt;. Otherwise, null characters '\u0000' are appended to this string builder until its length is less than the &lt;a href=&quot;set-length#kotlin.text.StringBuilder%24setLength(kotlin.Int)/newLength&quot;&gt;newLength&lt;/a&gt;.</source>
          <target state="translated">場合は&lt;a href=&quot;set-length#kotlin.text.StringBuilder%24setLength(kotlin.Int)/newLength&quot;&gt;newLengthが&lt;/a&gt;現在の長さよりも短い、それは指定に変更され&lt;a href=&quot;set-length#kotlin.text.StringBuilder%24setLength(kotlin.Int)/newLength&quot;&gt;newLength&lt;/a&gt;。それ以外の場合は、ヌル文字 '\ u0000'が、その長さが&lt;a href=&quot;set-length#kotlin.text.StringBuilder%24setLength(kotlin.Int)/newLength&quot;&gt;newLength&lt;/a&gt;より小さくなるまでこの文字列ビルダーに追加されます。</target>
        </trans-unit>
        <trans-unit id="fd0d3eb59459a0737a168b08758efee370cf55de" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;suspend-coroutine-or-return#kotlin.coroutines.experimental.intrinsics%24suspendCoroutineOrReturn%28kotlin.Function1%28%28kotlin.coroutines.experimental.Continuation%28%28kotlin.coroutines.experimental.intrinsics.suspendCoroutineOrReturn.T%29%29%2C+kotlin.Any%29%29%29%2Fblock&quot;&gt;block&lt;/a&gt; returns the special &lt;a href=&quot;-c-o-r-o-u-t-i-n-e_-s-u-s-p-e-n-d-e-d#kotlin.coroutines.experimental.intrinsics%24COROUTINE_SUSPENDED&quot;&gt;COROUTINE_SUSPENDED&lt;/a&gt; value, it means that suspend function did suspend the execution and will not return any result immediately. In this case, the &lt;a href=&quot;../kotlin.coroutines.experimental/-continuation/index&quot;&gt;Continuation&lt;/a&gt; provided to the &lt;a href=&quot;suspend-coroutine-or-return#kotlin.coroutines.experimental.intrinsics%24suspendCoroutineOrReturn%28kotlin.Function1%28%28kotlin.coroutines.experimental.Continuation%28%28kotlin.coroutines.experimental.intrinsics.suspendCoroutineOrReturn.T%29%29%2C+kotlin.Any%29%29%29%2Fblock&quot;&gt;block&lt;/a&gt; shall be invoked at some moment in the future when the result becomes available to resume the computation.</source>
          <target state="translated">&lt;a href=&quot;suspend-coroutine-or-return#kotlin.coroutines.experimental.intrinsics%24suspendCoroutineOrReturn%28kotlin.Function1%28%28kotlin.coroutines.experimental.Continuation%28%28kotlin.coroutines.experimental.intrinsics.suspendCoroutineOrReturn.T%29%29%2C+kotlin.Any%29%29%29%2Fblock&quot;&gt;ブロック&lt;/a&gt;が特別な&lt;a href=&quot;-c-o-r-o-u-t-i-n-e_-s-u-s-p-e-n-d-e-d#kotlin.coroutines.experimental.intrinsics%24COROUTINE_SUSPENDED&quot;&gt;COROUTINE_SUSPENDED&lt;/a&gt;値を返す場合は、suspend関数が実行を一時停止し、すぐには結果を返さないことを意味します。この場合、&lt;a href=&quot;suspend-coroutine-or-return#kotlin.coroutines.experimental.intrinsics%24suspendCoroutineOrReturn%28kotlin.Function1%28%28kotlin.coroutines.experimental.Continuation%28%28kotlin.coroutines.experimental.intrinsics.suspendCoroutineOrReturn.T%29%29%2C+kotlin.Any%29%29%29%2Fblock&quot;&gt;ブロックに&lt;/a&gt;提供された&lt;a href=&quot;../kotlin.coroutines.experimental/-continuation/index&quot;&gt;Continuation&lt;/a&gt;は、結果が計算を再開するために利用可能になる将来のある時点で呼び出されます。</target>
        </trans-unit>
        <trans-unit id="05d3b99631a5ed6456bedf676a61766834d5fac4" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;suspend-coroutine-unintercepted-or-return#kotlin.coroutines.intrinsics%24suspendCoroutineUninterceptedOrReturn%28kotlin.Function1%28%28kotlin.coroutines.Continuation%28%28kotlin.coroutines.intrinsics.suspendCoroutineUninterceptedOrReturn.T%29%29%2C+kotlin.Any%29%29%29%2Fblock&quot;&gt;block&lt;/a&gt; returns the special &lt;a href=&quot;-c-o-r-o-u-t-i-n-e_-s-u-s-p-e-n-d-e-d&quot;&gt;COROUTINE_SUSPENDED&lt;/a&gt; value, it means that suspend function did suspend the execution and will not return any result immediately. In this case, the &lt;a href=&quot;../kotlin.coroutines/-continuation/index&quot;&gt;Continuation&lt;/a&gt; provided to the &lt;a href=&quot;suspend-coroutine-unintercepted-or-return#kotlin.coroutines.intrinsics%24suspendCoroutineUninterceptedOrReturn%28kotlin.Function1%28%28kotlin.coroutines.Continuation%28%28kotlin.coroutines.intrinsics.suspendCoroutineUninterceptedOrReturn.T%29%29%2C+kotlin.Any%29%29%29%2Fblock&quot;&gt;block&lt;/a&gt; shall be resumed by invoking &lt;a href=&quot;../kotlin.coroutines/-continuation/resume-with&quot;&gt;Continuation.resumeWith&lt;/a&gt; at some moment in the future when the result becomes available to resume the computation.</source>
          <target state="translated">&lt;a href=&quot;suspend-coroutine-unintercepted-or-return#kotlin.coroutines.intrinsics%24suspendCoroutineUninterceptedOrReturn%28kotlin.Function1%28%28kotlin.coroutines.Continuation%28%28kotlin.coroutines.intrinsics.suspendCoroutineUninterceptedOrReturn.T%29%29%2C+kotlin.Any%29%29%29%2Fblock&quot;&gt;ブロック&lt;/a&gt;が特別な&lt;a href=&quot;-c-o-r-o-u-t-i-n-e_-s-u-s-p-e-n-d-e-d&quot;&gt;COROUTINE_SUSPENDED&lt;/a&gt;値を返す場合は、suspend関数が実行を一時停止し、すぐには結果を返さないことを意味します。この場合、&lt;a href=&quot;suspend-coroutine-unintercepted-or-return#kotlin.coroutines.intrinsics%24suspendCoroutineUninterceptedOrReturn%28kotlin.Function1%28%28kotlin.coroutines.Continuation%28%28kotlin.coroutines.intrinsics.suspendCoroutineUninterceptedOrReturn.T%29%29%2C+kotlin.Any%29%29%29%2Fblock&quot;&gt;ブロックに&lt;/a&gt;提供された&lt;a href=&quot;../kotlin.coroutines/-continuation/index&quot;&gt;Continuation&lt;/a&gt;は、計算を再開するために結果が利用可能になる将来のある時点で&lt;a href=&quot;../kotlin.coroutines/-continuation/resume-with&quot;&gt;Continuation.resumeWith&lt;/a&gt;を呼び出すことによって再開されます。</target>
        </trans-unit>
        <trans-unit id="ef7f7d6c898b2802fb6d15ca777d3c99d22a1440" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;suspend-coroutine-unintercepted-or-return#kotlin.coroutines.intrinsics%24suspendCoroutineUninterceptedOrReturn(kotlin.Function1((kotlin.coroutines.Continuation((kotlin.coroutines.intrinsics.suspendCoroutineUninterceptedOrReturn.T)),%20kotlin.Any?)))/block&quot;&gt;block&lt;/a&gt; returns the special &lt;a href=&quot;-c-o-r-o-u-t-i-n-e_-s-u-s-p-e-n-d-e-d&quot;&gt;COROUTINE_SUSPENDED&lt;/a&gt; value, it means that suspend function did suspend the execution and will not return any result immediately. In this case, the &lt;a href=&quot;../kotlin.coroutines/-continuation/index&quot;&gt;Continuation&lt;/a&gt; provided to the &lt;a href=&quot;suspend-coroutine-unintercepted-or-return#kotlin.coroutines.intrinsics%24suspendCoroutineUninterceptedOrReturn(kotlin.Function1((kotlin.coroutines.Continuation((kotlin.coroutines.intrinsics.suspendCoroutineUninterceptedOrReturn.T)),%20kotlin.Any?)))/block&quot;&gt;block&lt;/a&gt; shall be resumed by invoking &lt;a href=&quot;../kotlin.coroutines/-continuation/resume-with&quot;&gt;Continuation.resumeWith&lt;/a&gt; at some moment in the future when the result becomes available to resume the computation.</source>
          <target state="translated">場合&lt;a href=&quot;suspend-coroutine-unintercepted-or-return#kotlin.coroutines.intrinsics%24suspendCoroutineUninterceptedOrReturn(kotlin.Function1((kotlin.coroutines.Continuation((kotlin.coroutines.intrinsics.suspendCoroutineUninterceptedOrReturn.T)),%20kotlin.Any?)))/block&quot;&gt;ブロックは&lt;/a&gt;特別返し&lt;a href=&quot;-c-o-r-o-u-t-i-n-e_-s-u-s-p-e-n-d-e-d&quot;&gt;COROUTINE_SUSPENDED&lt;/a&gt;値を、機能を一時停止し、それ手段は、実行を中断しなかったし、すぐにすべての結果を返しません。この場合には、&lt;a href=&quot;../kotlin.coroutines/-continuation/index&quot;&gt;継続&lt;/a&gt;に提供&lt;a href=&quot;suspend-coroutine-unintercepted-or-return#kotlin.coroutines.intrinsics%24suspendCoroutineUninterceptedOrReturn(kotlin.Function1((kotlin.coroutines.Continuation((kotlin.coroutines.intrinsics.suspendCoroutineUninterceptedOrReturn.T)),%20kotlin.Any?)))/block&quot;&gt;ブロックが&lt;/a&gt;呼び出すことによって再開されなければならない&lt;a href=&quot;../kotlin.coroutines/-continuation/resume-with&quot;&gt;Continuation.resumeWithの&lt;/a&gt;結果は計算を再開するために利用可能になる将来のある時点で。</target>
        </trans-unit>
        <trans-unit id="8c3e8a5ebbcd7a703e634eecad27bcd0557ad20c" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;until#kotlin.ranges%24until%28kotlin.Int%2C+kotlin.Byte%29%2Fto&quot;&gt;to&lt;/a&gt; value is less than or equal to &lt;code&gt;this&lt;/code&gt; value, then the returned range is empty.</source>
          <target state="translated">場合&lt;a href=&quot;until#kotlin.ranges%24until%28kotlin.Int%2C+kotlin.Byte%29%2Fto&quot;&gt;の&lt;/a&gt;値よりも小さいか等しい &lt;code&gt;this&lt;/code&gt; 値は、返される範囲は空です。</target>
        </trans-unit>
        <trans-unit id="fc10efd6ed805281fe18f00e48398e62a4bc01b4" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;until#kotlin.ranges%24until(kotlin.Int,%20kotlin.Byte)/to&quot;&gt;to&lt;/a&gt; value is less than or equal to &lt;code&gt;this&lt;/code&gt; value, then the returned range is empty.</source>
          <target state="translated">場合&lt;a href=&quot;until#kotlin.ranges%24until(kotlin.Int,%20kotlin.Byte)/to&quot;&gt;の&lt;/a&gt;値よりも小さいか等しい &lt;code&gt;this&lt;/code&gt; 値は、返される範囲は空です。</target>
        </trans-unit>
        <trans-unit id="5345ec6188f99db607179fac5ae96cec3bb7c52f" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;@Nonnull(when = ...)&lt;/code&gt; value is &lt;code&gt;When.ALWAYS&lt;/code&gt;, the annotated type is treated as non-null; &lt;code&gt;When.MAYBE&lt;/code&gt; and &lt;code&gt;When.NEVER&lt;/code&gt; denote a nullable type; and &lt;code&gt;When.UNKNOWN&lt;/code&gt; forces the type to be &lt;a href=&quot;#null-safety-and-platform-types&quot;&gt;platform one&lt;/a&gt;.</source>
          <target state="translated">場合 &lt;code&gt;@Nonnull(when = ...)&lt;/code&gt; 値である &lt;code&gt;When.ALWAYS&lt;/code&gt; 、注釈付きタイプは、非ヌルとして扱われます。 &lt;code&gt;When.MAYBE&lt;/code&gt; および &lt;code&gt;When.NEVER&lt;/code&gt; はnull許容型を示します。そして &lt;code&gt;When.UNKNOWN&lt;/code&gt; するタイプを強制的に&lt;a href=&quot;#null-safety-and-platform-types&quot;&gt;プラットフォーム1&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="45b12756de222f5e29c382cd94f13f3b7d5d58e7" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Char&lt;/code&gt; at the specified &lt;a href=&quot;delete-at#kotlin.text%24deleteAt(java.lang.StringBuilder,%20kotlin.Int)/index&quot;&gt;index&lt;/a&gt; is part of a supplementary code point, this method does not remove the entire supplementary character.</source>
          <target state="translated">場合 &lt;code&gt;Char&lt;/code&gt; 指定された時&lt;a href=&quot;delete-at#kotlin.text%24deleteAt(java.lang.StringBuilder,%20kotlin.Int)/index&quot;&gt;のインデックスが&lt;/a&gt;補助コードポイントの一部であり、この方法は、全体の補助文字を削除しません。</target>
        </trans-unit>
        <trans-unit id="688090999735051d0000ff7dba5c2c4568402fb2" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Char&lt;/code&gt; at the specified &lt;a href=&quot;delete-at#kotlin.text%24deleteAt(kotlin.text.StringBuilder,%20kotlin.Int)/index&quot;&gt;index&lt;/a&gt; is part of a supplementary code point, this method does not remove the entire supplementary character.</source>
          <target state="translated">場合 &lt;code&gt;Char&lt;/code&gt; 指定された時&lt;a href=&quot;delete-at#kotlin.text%24deleteAt(kotlin.text.StringBuilder,%20kotlin.Int)/index&quot;&gt;のインデックスが&lt;/a&gt;補助コードポイントの一部であり、この方法は、全体の補助文字を削除しません。</target>
        </trans-unit>
        <trans-unit id="19c4aa235fc87bd1ef34ff709c6ee8e008a72969" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Char&lt;/code&gt; at the specified &lt;a href=&quot;delete-at#kotlin.text.StringBuilder%24deleteAt(kotlin.Int)/index&quot;&gt;index&lt;/a&gt; is part of a supplementary code point, this method does not remove the entire supplementary character.</source>
          <target state="translated">場合 &lt;code&gt;Char&lt;/code&gt; 指定された時&lt;a href=&quot;delete-at#kotlin.text.StringBuilder%24deleteAt(kotlin.Int)/index&quot;&gt;のインデックスが&lt;/a&gt;補助コードポイントの一部であり、この方法は、全体の補助文字を削除しません。</target>
        </trans-unit>
        <trans-unit id="64b90c92ca7b8330c526871505c4db9b681716bb" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Char&lt;/code&gt; at the specified &lt;a href=&quot;delete-char-at#kotlin.text%24deleteCharAt(kotlin.text.StringBuilder,%20kotlin.Int)/index&quot;&gt;index&lt;/a&gt; is part of a supplementary code point, this method does not remove the entire supplementary character.</source>
          <target state="translated">場合 &lt;code&gt;Char&lt;/code&gt; 指定された時&lt;a href=&quot;delete-char-at#kotlin.text%24deleteCharAt(kotlin.text.StringBuilder,%20kotlin.Int)/index&quot;&gt;のインデックスが&lt;/a&gt;補助コードポイントの一部であり、この方法は、全体の補助文字を削除しません。</target>
        </trans-unit>
        <trans-unit id="1ab41cb28f87df4bf85af33067d923e82cb67834" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;value&lt;/code&gt; argument in Java has an array type, it becomes a &lt;code&gt;vararg&lt;/code&gt; parameter in Kotlin:</source>
          <target state="translated">Java の &lt;code&gt;value&lt;/code&gt; 引数が配列型の場合、それはKotlinの &lt;code&gt;vararg&lt;/code&gt; パラメータになります。</target>
        </trans-unit>
        <trans-unit id="c6ef38c717fdd1e4d50094959ff3c7a5a376b3eb" translate="yes" xml:space="preserve">
          <source>If the Java class has multiple methods taking functional interfaces, you can choose the one you need to call by using an adapter function that converts a lambda to a specific SAM type. Those adapter functions are also generated by the compiler when needed:</source>
          <target state="translated">Java クラスが機能インタフェースを取る複数のメソッドを持っている場合、ラムダを特定の SAM 型に変換するアダプタ関数を使用して、呼び出す必要のあるものを選択することができます。これらのアダプタ関数は必要に応じてコンパイラによって生成されます。</target>
        </trans-unit>
        <trans-unit id="ced4c8b1c0812e2f37b8f765b9bf671545680b65" translate="yes" xml:space="preserve">
          <source>If the array contains multiple elements equal to the specified &lt;a href=&quot;binary-search#kotlin.collections%24binarySearch%28kotlin.Array%28%28kotlin.collections.binarySearch.T%29%29%2C+kotlin.collections.binarySearch.T%2C+java.util.Comparator%28%28kotlin.collections.binarySearch.T%29%29%2C+kotlin.Int%2C+kotlin.Int%29%2Felement&quot;&gt;element&lt;/a&gt;, there is no guarantee which one will be found.</source>
          <target state="translated">配列に指定された&lt;a href=&quot;binary-search#kotlin.collections%24binarySearch%28kotlin.Array%28%28kotlin.collections.binarySearch.T%29%29%2C+kotlin.collections.binarySearch.T%2C+java.util.Comparator%28%28kotlin.collections.binarySearch.T%29%29%2C+kotlin.Int%2C+kotlin.Int%29%2Felement&quot;&gt;element&lt;/a&gt;と等しい複数の要素が含まれている場合、どの要素が見つかるかは保証されません。</target>
        </trans-unit>
        <trans-unit id="6466c3976ded360fb3b54d0482a0da85fa3ffd46" translate="yes" xml:space="preserve">
          <source>If the array contains multiple elements equal to the specified &lt;a href=&quot;binary-search#kotlin.collections%24binarySearch%28kotlin.Array%28%28kotlin.collections.binarySearch.T%29%29%2C+kotlin.collections.binarySearch.T%2C+kotlin.Int%2C+kotlin.Int%29%2Felement&quot;&gt;element&lt;/a&gt;, there is no guarantee which one will be found.</source>
          <target state="translated">配列に指定された&lt;a href=&quot;binary-search#kotlin.collections%24binarySearch%28kotlin.Array%28%28kotlin.collections.binarySearch.T%29%29%2C+kotlin.collections.binarySearch.T%2C+kotlin.Int%2C+kotlin.Int%29%2Felement&quot;&gt;element&lt;/a&gt;と等しい複数の要素が含まれている場合、どの要素が見つかるかは保証されません。</target>
        </trans-unit>
        <trans-unit id="d5cf73d9390119493522582bc92cc73759f93e8a" translate="yes" xml:space="preserve">
          <source>If the array contains multiple elements equal to the specified &lt;a href=&quot;binary-search#kotlin.collections%24binarySearch(kotlin.Array((kotlin.collections.binarySearch.T)),%20kotlin.collections.binarySearch.T,%20java.util.Comparator((kotlin.collections.binarySearch.T)),%20kotlin.Int,%20kotlin.Int)/element&quot;&gt;element&lt;/a&gt;, there is no guarantee which one will be found.</source>
          <target state="translated">アレイは、複数の要素が指定さに等しく含まれている場合は&lt;a href=&quot;binary-search#kotlin.collections%24binarySearch(kotlin.Array((kotlin.collections.binarySearch.T)),%20kotlin.collections.binarySearch.T,%20java.util.Comparator((kotlin.collections.binarySearch.T)),%20kotlin.Int,%20kotlin.Int)/element&quot;&gt;要素&lt;/a&gt;、一方が発見される保証はありません。</target>
        </trans-unit>
        <trans-unit id="2bd4827f31d12e8989eabcece2a2e85f2897dbd2" translate="yes" xml:space="preserve">
          <source>If the array contains multiple elements equal to the specified &lt;a href=&quot;binary-search#kotlin.collections%24binarySearch(kotlin.Array((kotlin.collections.binarySearch.T)),%20kotlin.collections.binarySearch.T,%20kotlin.Int,%20kotlin.Int)/element&quot;&gt;element&lt;/a&gt;, there is no guarantee which one will be found.</source>
          <target state="translated">アレイは、複数の要素が指定さに等しく含まれている場合は&lt;a href=&quot;binary-search#kotlin.collections%24binarySearch(kotlin.Array((kotlin.collections.binarySearch.T)),%20kotlin.collections.binarySearch.T,%20kotlin.Int,%20kotlin.Int)/element&quot;&gt;要素&lt;/a&gt;、一方が発見される保証はありません。</target>
        </trans-unit>
        <trans-unit id="857a406fa492096552a539094a05e74a8ae0e4fe" translate="yes" xml:space="preserve">
          <source>If the backing storage of this string builder is larger than necessary to hold its current contents, then it may be resized to become more space efficient. Calling this method may, but is not required to, affect the value of the &lt;a href=&quot;capacity#kotlin.text.StringBuilder%24capacity()&quot;&gt;capacity&lt;/a&gt; property.</source>
          <target state="translated">この文字列ビルダーのバッキングストレージが現在のコンテンツを保持するために必要なサイズよりも大きい場合は、スペース効率を高めるためにサイズを変更できます。このメソッドを呼び出すと、&lt;a href=&quot;capacity#kotlin.text.StringBuilder%24capacity()&quot;&gt;容量&lt;/a&gt;プロパティの値に影響を与える可能性がありますが、必須ではありません。</target>
        </trans-unit>
        <trans-unit id="fa8581b13c8fdd01f13e98c50d4e7d29550396fc" translate="yes" xml:space="preserve">
          <source>If the behavior for a certain platform needs to be modified, you can use a format like &lt;code&gt;compilerOpts.osx&lt;/code&gt; or &lt;code&gt;compilerOpts.linux&lt;/code&gt; to provide platform-specific values to the options.</source>
          <target state="translated">特定のプラットフォームの動作を変更する必要がある場合は、 &lt;code&gt;compilerOpts.osx&lt;/code&gt; や &lt;code&gt;compilerOpts.linux&lt;/code&gt; のような形式を使用して、プラットフォーム固有の値をオプションに提供できます。</target>
        </trans-unit>
        <trans-unit id="996cca3563bf26540aaf4288dff8af8f84e60dcc" translate="yes" xml:space="preserve">
          <source>If the callback doesn't run in the main thread, it is mandatory to init the &lt;em&gt;Kotlin/Native&lt;/em&gt; runtime by calling &lt;code&gt;kotlin.native.initRuntimeIfNeeded()&lt;/code&gt;.</source>
          <target state="translated">コールバックがメインスレッドで実行されない場合は、 &lt;code&gt;kotlin.native.initRuntimeIfNeeded()&lt;/code&gt; を呼び出して&lt;em&gt;Kotlin / Native&lt;/em&gt;ランタイムを初期化する必要があります。</target>
        </trans-unit>
        <trans-unit id="71e01fbddfaf8e865fcef95f03a855f99eabb469" translate="yes" xml:space="preserve">
          <source>If the class (or any of its superclasses) is annotated with &lt;code&gt;com.my.Annotation&lt;/code&gt;, the class itself and all its members will become open.</source>
          <target state="translated">クラス（またはそのスーパークラス）に &lt;code&gt;com.my.Annotation&lt;/code&gt; で注釈が付けられている場合、クラス自体とそのすべてのメンバーが開かれます。</target>
        </trans-unit>
        <trans-unit id="1d6fb5abda1df282cf7b793af04d339e6c8b07ca" translate="yes" xml:space="preserve">
          <source>If the class has a primary constructor, each secondary constructor needs to delegate to the primary constructor, either directly or indirectly through another secondary constructor(s). Delegation to another constructor of the same class is done using the &lt;em&gt;this&lt;/em&gt; keyword:</source>
          <target state="translated">クラスにプライマリコンストラクターがある場合、各セカンダリコンストラクターは、直接または別のセカンダリコンストラクターを介して間接的にプライマリコンストラクターに委任する必要があります。同じクラスの別のコンストラクターへの委任は、&lt;em&gt;this&lt;/em&gt;キーワードを使用して行われます。</target>
        </trans-unit>
        <trans-unit id="1becbc997c1b9834ca68a14f7454678bc5ce31a3" translate="yes" xml:space="preserve">
          <source>If the classes represent &lt;a href=&quot;../../kotlin/-array/index#kotlin.Array&quot;&gt;Array&lt;/a&gt;, then &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/lang/Class.html&quot;&gt;Class&lt;/a&gt; objects of their element types are equal.</source>
          <target state="translated">クラスが表す場合は&lt;a href=&quot;../../kotlin/-array/index#kotlin.Array&quot;&gt;配列を&lt;/a&gt;、その&lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/lang/Class.html&quot;&gt;クラスは、&lt;/a&gt;その要素の型が等しいのオブジェクト。</target>
        </trans-unit>
        <trans-unit id="77b2beaaa166a8ca8a0f2117bf08b50328d632d2" translate="yes" xml:space="preserve">
          <source>If the classes represent &lt;a href=&quot;../../kotlin/-array/index#kotlin.Array&quot;&gt;Array&lt;/a&gt;, then &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html&quot;&gt;Class&lt;/a&gt; objects of their element types are equal.</source>
          <target state="translated">クラスが表す場合は&lt;a href=&quot;../../kotlin/-array/index#kotlin.Array&quot;&gt;配列を&lt;/a&gt;、その&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html&quot;&gt;クラスは、&lt;/a&gt;その要素の型が等しいのオブジェクト。</target>
        </trans-unit>
        <trans-unit id="944291945314272d9d50e4311dd336ba21bad448" translate="yes" xml:space="preserve">
          <source>If the classes represent Array, then Class objects of their element types are equal.</source>
          <target state="translated">クラスがArrayを表している場合、その要素型のClassオブジェクトは等しくなります。</target>
        </trans-unit>
        <trans-unit id="79031f7fd8baac9875032a654d3a81aa8ce76daf" translate="yes" xml:space="preserve">
          <source>If the code block contains a single function with &lt;code&gt;it&lt;/code&gt; as an argument, you can use the method reference (&lt;code&gt;::&lt;/code&gt;) instead of the lambda:</source>
          <target state="translated">コードブロックが持つ単一の機能が含まれている場合 &lt;code&gt;it&lt;/code&gt; 引数として、あなたはメソッド参照（使用することができます &lt;code&gt;::&lt;/code&gt; を代わりにラムダの）：</target>
        </trans-unit>
        <trans-unit id="d97d691977b15199380af830d5ad236bbf75524c" translate="yes" xml:space="preserve">
          <source>If the collection could be huge, you can specify a non-negative value of &lt;a href=&quot;join-to#kotlin.collections%24joinTo%28kotlin.Array%28%28kotlin.collections.joinTo.T%29%29%2C+kotlin.collections.joinTo.A%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.CharSequence%2C+kotlin.Function1%28%28kotlin.collections.joinTo.T%2C+kotlin.CharSequence%29%29%29%2Flimit&quot;&gt;limit&lt;/a&gt;, in which case only the first &lt;a href=&quot;join-to#kotlin.collections%24joinTo%28kotlin.Array%28%28kotlin.collections.joinTo.T%29%29%2C+kotlin.collections.joinTo.A%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.CharSequence%2C+kotlin.Function1%28%28kotlin.collections.joinTo.T%2C+kotlin.CharSequence%29%29%29%2Flimit&quot;&gt;limit&lt;/a&gt; elements will be appended, followed by the &lt;a href=&quot;join-to#kotlin.collections%24joinTo%28kotlin.Array%28%28kotlin.collections.joinTo.T%29%29%2C+kotlin.collections.joinTo.A%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.CharSequence%2C+kotlin.Function1%28%28kotlin.collections.joinTo.T%2C+kotlin.CharSequence%29%29%29%2Ftruncated&quot;&gt;truncated&lt;/a&gt; string (which defaults to &quot;...&quot;).</source>
          <target state="translated">コレクションが膨大になる可能性がある場合は、負でない値の&lt;a href=&quot;join-to#kotlin.collections%24joinTo%28kotlin.Array%28%28kotlin.collections.joinTo.T%29%29%2C+kotlin.collections.joinTo.A%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.CharSequence%2C+kotlin.Function1%28%28kotlin.collections.joinTo.T%2C+kotlin.CharSequence%29%29%29%2Flimit&quot;&gt;limitを&lt;/a&gt;指定できます。この場合、最初の&lt;a href=&quot;join-to#kotlin.collections%24joinTo%28kotlin.Array%28%28kotlin.collections.joinTo.T%29%29%2C+kotlin.collections.joinTo.A%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.CharSequence%2C+kotlin.Function1%28%28kotlin.collections.joinTo.T%2C+kotlin.CharSequence%29%29%29%2Flimit&quot;&gt;limit&lt;/a&gt;要素のみが追加され、その後に&lt;a href=&quot;join-to#kotlin.collections%24joinTo%28kotlin.Array%28%28kotlin.collections.joinTo.T%29%29%2C+kotlin.collections.joinTo.A%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.CharSequence%2C+kotlin.Function1%28%28kotlin.collections.joinTo.T%2C+kotlin.CharSequence%29%29%29%2Ftruncated&quot;&gt;切り捨てられた&lt;/a&gt;文字列が続きます（デフォルトは &quot;...&quot;）。</target>
        </trans-unit>
        <trans-unit id="e8468dd252fe0ffd6b4a3af71f464889fa3a1a39" translate="yes" xml:space="preserve">
          <source>If the collection could be huge, you can specify a non-negative value of &lt;a href=&quot;join-to#kotlin.collections%24joinTo(kotlin.Array((kotlin.collections.joinTo.T)),%20kotlin.collections.joinTo.A,%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Function1?((kotlin.collections.joinTo.T,%20kotlin.CharSequence)))/limit&quot;&gt;limit&lt;/a&gt;, in which case only the first &lt;a href=&quot;join-to#kotlin.collections%24joinTo(kotlin.Array((kotlin.collections.joinTo.T)),%20kotlin.collections.joinTo.A,%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Function1?((kotlin.collections.joinTo.T,%20kotlin.CharSequence)))/limit&quot;&gt;limit&lt;/a&gt; elements will be appended, followed by the &lt;a href=&quot;join-to#kotlin.collections%24joinTo(kotlin.Array((kotlin.collections.joinTo.T)),%20kotlin.collections.joinTo.A,%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Function1?((kotlin.collections.joinTo.T,%20kotlin.CharSequence)))/truncated&quot;&gt;truncated&lt;/a&gt; string (which defaults to &quot;...&quot;).</source>
          <target state="translated">コレクションが膨大になる可能性がある場合は、&lt;a href=&quot;join-to#kotlin.collections%24joinTo(kotlin.Array((kotlin.collections.joinTo.T)),%20kotlin.collections.joinTo.A,%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Function1?((kotlin.collections.joinTo.T,%20kotlin.CharSequence)))/limit&quot;&gt;limitの&lt;/a&gt;負でない値を指定できます。この場合、最初の&lt;a href=&quot;join-to#kotlin.collections%24joinTo(kotlin.Array((kotlin.collections.joinTo.T)),%20kotlin.collections.joinTo.A,%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Function1?((kotlin.collections.joinTo.T,%20kotlin.CharSequence)))/limit&quot;&gt;limit&lt;/a&gt;要素のみが追加され、その後に&lt;a href=&quot;join-to#kotlin.collections%24joinTo(kotlin.Array((kotlin.collections.joinTo.T)),%20kotlin.collections.joinTo.A,%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Function1?((kotlin.collections.joinTo.T,%20kotlin.CharSequence)))/truncated&quot;&gt;切り捨てられた&lt;/a&gt;文字列（デフォルトは「...」）が続きます。</target>
        </trans-unit>
        <trans-unit id="8f5b1dc0c41182773d56507020b349e5e7ed653a" translate="yes" xml:space="preserve">
          <source>If the collection could be huge, you can specify a non-negative value of &lt;a href=&quot;join-to#kotlin.sequences%24joinTo%28kotlin.sequences.Sequence%28%28kotlin.sequences.joinTo.T%29%29%2C+kotlin.sequences.joinTo.A%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.CharSequence%2C+kotlin.Function1%28%28kotlin.sequences.joinTo.T%2C+kotlin.CharSequence%29%29%29%2Flimit&quot;&gt;limit&lt;/a&gt;, in which case only the first &lt;a href=&quot;join-to#kotlin.sequences%24joinTo%28kotlin.sequences.Sequence%28%28kotlin.sequences.joinTo.T%29%29%2C+kotlin.sequences.joinTo.A%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.CharSequence%2C+kotlin.Function1%28%28kotlin.sequences.joinTo.T%2C+kotlin.CharSequence%29%29%29%2Flimit&quot;&gt;limit&lt;/a&gt; elements will be appended, followed by the &lt;a href=&quot;join-to#kotlin.sequences%24joinTo%28kotlin.sequences.Sequence%28%28kotlin.sequences.joinTo.T%29%29%2C+kotlin.sequences.joinTo.A%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.CharSequence%2C+kotlin.Function1%28%28kotlin.sequences.joinTo.T%2C+kotlin.CharSequence%29%29%29%2Ftruncated&quot;&gt;truncated&lt;/a&gt; string (which defaults to &quot;...&quot;).</source>
          <target state="translated">コレクションが膨大になる可能性がある場合は、負でない値の&lt;a href=&quot;join-to#kotlin.sequences%24joinTo%28kotlin.sequences.Sequence%28%28kotlin.sequences.joinTo.T%29%29%2C+kotlin.sequences.joinTo.A%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.CharSequence%2C+kotlin.Function1%28%28kotlin.sequences.joinTo.T%2C+kotlin.CharSequence%29%29%29%2Flimit&quot;&gt;limitを&lt;/a&gt;指定できます。この場合、最初の&lt;a href=&quot;join-to#kotlin.sequences%24joinTo%28kotlin.sequences.Sequence%28%28kotlin.sequences.joinTo.T%29%29%2C+kotlin.sequences.joinTo.A%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.CharSequence%2C+kotlin.Function1%28%28kotlin.sequences.joinTo.T%2C+kotlin.CharSequence%29%29%29%2Flimit&quot;&gt;limit&lt;/a&gt;要素のみが追加され、その後に&lt;a href=&quot;join-to#kotlin.sequences%24joinTo%28kotlin.sequences.Sequence%28%28kotlin.sequences.joinTo.T%29%29%2C+kotlin.sequences.joinTo.A%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.CharSequence%2C+kotlin.Function1%28%28kotlin.sequences.joinTo.T%2C+kotlin.CharSequence%29%29%29%2Ftruncated&quot;&gt;切り捨てられた&lt;/a&gt;文字列が続きます（デフォルトは &quot;...&quot;）。</target>
        </trans-unit>
        <trans-unit id="08d4d8884be2c52559e13b59134a10b3b85cf098" translate="yes" xml:space="preserve">
          <source>If the collection could be huge, you can specify a non-negative value of &lt;a href=&quot;join-to#kotlin.sequences%24joinTo(kotlin.sequences.Sequence((kotlin.sequences.joinTo.T)),%20kotlin.sequences.joinTo.A,%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Function1?((kotlin.sequences.joinTo.T,%20kotlin.CharSequence)))/limit&quot;&gt;limit&lt;/a&gt;, in which case only the first &lt;a href=&quot;join-to#kotlin.sequences%24joinTo(kotlin.sequences.Sequence((kotlin.sequences.joinTo.T)),%20kotlin.sequences.joinTo.A,%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Function1?((kotlin.sequences.joinTo.T,%20kotlin.CharSequence)))/limit&quot;&gt;limit&lt;/a&gt; elements will be appended, followed by the &lt;a href=&quot;join-to#kotlin.sequences%24joinTo(kotlin.sequences.Sequence((kotlin.sequences.joinTo.T)),%20kotlin.sequences.joinTo.A,%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Function1?((kotlin.sequences.joinTo.T,%20kotlin.CharSequence)))/truncated&quot;&gt;truncated&lt;/a&gt; string (which defaults to &quot;...&quot;).</source>
          <target state="translated">コレクションが膨大になる可能性がある場合は、&lt;a href=&quot;join-to#kotlin.sequences%24joinTo(kotlin.sequences.Sequence((kotlin.sequences.joinTo.T)),%20kotlin.sequences.joinTo.A,%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Function1?((kotlin.sequences.joinTo.T,%20kotlin.CharSequence)))/limit&quot;&gt;limitの&lt;/a&gt;負でない値を指定できます。この場合、最初の&lt;a href=&quot;join-to#kotlin.sequences%24joinTo(kotlin.sequences.Sequence((kotlin.sequences.joinTo.T)),%20kotlin.sequences.joinTo.A,%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Function1?((kotlin.sequences.joinTo.T,%20kotlin.CharSequence)))/limit&quot;&gt;limit&lt;/a&gt;要素のみが追加され、その後に&lt;a href=&quot;join-to#kotlin.sequences%24joinTo(kotlin.sequences.Sequence((kotlin.sequences.joinTo.T)),%20kotlin.sequences.joinTo.A,%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Function1?((kotlin.sequences.joinTo.T,%20kotlin.CharSequence)))/truncated&quot;&gt;切り捨てられた&lt;/a&gt;文字列（デフォルトは「...」）が続きます。</target>
        </trans-unit>
        <trans-unit id="9cb18d53f708d0c262ed97ec04392d87077ad40e" translate="yes" xml:space="preserve">
          <source>If the collection could be huge, you can specify a non-negative value of &lt;a href=&quot;join-to-string#kotlin.collections%24joinToString%28kotlin.Array%28%28kotlin.collections.joinToString.T%29%29%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.CharSequence%2C+kotlin.Function1%28%28kotlin.collections.joinToString.T%2C+kotlin.CharSequence%29%29%29%2Flimit&quot;&gt;limit&lt;/a&gt;, in which case only the first &lt;a href=&quot;join-to-string#kotlin.collections%24joinToString%28kotlin.Array%28%28kotlin.collections.joinToString.T%29%29%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.CharSequence%2C+kotlin.Function1%28%28kotlin.collections.joinToString.T%2C+kotlin.CharSequence%29%29%29%2Flimit&quot;&gt;limit&lt;/a&gt; elements will be appended, followed by the &lt;a href=&quot;join-to-string#kotlin.collections%24joinToString%28kotlin.Array%28%28kotlin.collections.joinToString.T%29%29%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.CharSequence%2C+kotlin.Function1%28%28kotlin.collections.joinToString.T%2C+kotlin.CharSequence%29%29%29%2Ftruncated&quot;&gt;truncated&lt;/a&gt; string (which defaults to &quot;...&quot;).</source>
          <target state="translated">コレクションが膨大になる可能性がある場合は、負でない値の&lt;a href=&quot;join-to-string#kotlin.collections%24joinToString%28kotlin.Array%28%28kotlin.collections.joinToString.T%29%29%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.CharSequence%2C+kotlin.Function1%28%28kotlin.collections.joinToString.T%2C+kotlin.CharSequence%29%29%29%2Flimit&quot;&gt;limitを&lt;/a&gt;指定できます。この場合、最初の&lt;a href=&quot;join-to-string#kotlin.collections%24joinToString%28kotlin.Array%28%28kotlin.collections.joinToString.T%29%29%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.CharSequence%2C+kotlin.Function1%28%28kotlin.collections.joinToString.T%2C+kotlin.CharSequence%29%29%29%2Flimit&quot;&gt;limit&lt;/a&gt;要素のみが追加され、その後に&lt;a href=&quot;join-to-string#kotlin.collections%24joinToString%28kotlin.Array%28%28kotlin.collections.joinToString.T%29%29%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.CharSequence%2C+kotlin.Function1%28%28kotlin.collections.joinToString.T%2C+kotlin.CharSequence%29%29%29%2Ftruncated&quot;&gt;切り捨てられた&lt;/a&gt;文字列が続きます（デフォルトは &quot;...&quot;）。</target>
        </trans-unit>
        <trans-unit id="1d93c35f86678bc28fc865390dd8cf2eb747038c" translate="yes" xml:space="preserve">
          <source>If the collection could be huge, you can specify a non-negative value of &lt;a href=&quot;join-to-string#kotlin.collections%24joinToString(kotlin.Array((kotlin.collections.joinToString.T)),%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Function1?((kotlin.collections.joinToString.T,%20kotlin.CharSequence)))/limit&quot;&gt;limit&lt;/a&gt;, in which case only the first &lt;a href=&quot;join-to-string#kotlin.collections%24joinToString(kotlin.Array((kotlin.collections.joinToString.T)),%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Function1?((kotlin.collections.joinToString.T,%20kotlin.CharSequence)))/limit&quot;&gt;limit&lt;/a&gt; elements will be appended, followed by the &lt;a href=&quot;join-to-string#kotlin.collections%24joinToString(kotlin.Array((kotlin.collections.joinToString.T)),%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Function1?((kotlin.collections.joinToString.T,%20kotlin.CharSequence)))/truncated&quot;&gt;truncated&lt;/a&gt; string (which defaults to &quot;...&quot;).</source>
          <target state="translated">コレクションが膨大になる可能性がある場合は、&lt;a href=&quot;join-to-string#kotlin.collections%24joinToString(kotlin.Array((kotlin.collections.joinToString.T)),%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Function1?((kotlin.collections.joinToString.T,%20kotlin.CharSequence)))/limit&quot;&gt;limitの&lt;/a&gt;負でない値を指定できます。この場合、最初の&lt;a href=&quot;join-to-string#kotlin.collections%24joinToString(kotlin.Array((kotlin.collections.joinToString.T)),%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Function1?((kotlin.collections.joinToString.T,%20kotlin.CharSequence)))/limit&quot;&gt;limit&lt;/a&gt;要素のみが追加され、その後に&lt;a href=&quot;join-to-string#kotlin.collections%24joinToString(kotlin.Array((kotlin.collections.joinToString.T)),%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Function1?((kotlin.collections.joinToString.T,%20kotlin.CharSequence)))/truncated&quot;&gt;切り捨てられた&lt;/a&gt;文字列（デフォルトは「...」）が続きます。</target>
        </trans-unit>
        <trans-unit id="bbf01993f693a43b2b5c8b4e4105a26cb7dc269a" translate="yes" xml:space="preserve">
          <source>If the collection could be huge, you can specify a non-negative value of &lt;a href=&quot;join-to-string#kotlin.sequences%24joinToString%28kotlin.sequences.Sequence%28%28kotlin.sequences.joinToString.T%29%29%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.CharSequence%2C+kotlin.Function1%28%28kotlin.sequences.joinToString.T%2C+kotlin.CharSequence%29%29%29%2Flimit&quot;&gt;limit&lt;/a&gt;, in which case only the first &lt;a href=&quot;join-to-string#kotlin.sequences%24joinToString%28kotlin.sequences.Sequence%28%28kotlin.sequences.joinToString.T%29%29%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.CharSequence%2C+kotlin.Function1%28%28kotlin.sequences.joinToString.T%2C+kotlin.CharSequence%29%29%29%2Flimit&quot;&gt;limit&lt;/a&gt; elements will be appended, followed by the &lt;a href=&quot;join-to-string#kotlin.sequences%24joinToString%28kotlin.sequences.Sequence%28%28kotlin.sequences.joinToString.T%29%29%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.CharSequence%2C+kotlin.Function1%28%28kotlin.sequences.joinToString.T%2C+kotlin.CharSequence%29%29%29%2Ftruncated&quot;&gt;truncated&lt;/a&gt; string (which defaults to &quot;...&quot;).</source>
          <target state="translated">コレクションが膨大になる可能性がある場合は、負でない値の&lt;a href=&quot;join-to-string#kotlin.sequences%24joinToString%28kotlin.sequences.Sequence%28%28kotlin.sequences.joinToString.T%29%29%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.CharSequence%2C+kotlin.Function1%28%28kotlin.sequences.joinToString.T%2C+kotlin.CharSequence%29%29%29%2Flimit&quot;&gt;limitを&lt;/a&gt;指定できます。この場合、最初の&lt;a href=&quot;join-to-string#kotlin.sequences%24joinToString%28kotlin.sequences.Sequence%28%28kotlin.sequences.joinToString.T%29%29%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.CharSequence%2C+kotlin.Function1%28%28kotlin.sequences.joinToString.T%2C+kotlin.CharSequence%29%29%29%2Flimit&quot;&gt;limit&lt;/a&gt;要素のみが追加され、その後に&lt;a href=&quot;join-to-string#kotlin.sequences%24joinToString%28kotlin.sequences.Sequence%28%28kotlin.sequences.joinToString.T%29%29%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.CharSequence%2C+kotlin.Function1%28%28kotlin.sequences.joinToString.T%2C+kotlin.CharSequence%29%29%29%2Ftruncated&quot;&gt;切り捨てられた&lt;/a&gt;文字列が続きます（デフォルトは &quot;...&quot;）。</target>
        </trans-unit>
        <trans-unit id="9854e1b0b2258416f93294b380cf1572214c823f" translate="yes" xml:space="preserve">
          <source>If the collection could be huge, you can specify a non-negative value of &lt;a href=&quot;join-to-string#kotlin.sequences%24joinToString(kotlin.sequences.Sequence((kotlin.sequences.joinToString.T)),%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Function1?((kotlin.sequences.joinToString.T,%20kotlin.CharSequence)))/limit&quot;&gt;limit&lt;/a&gt;, in which case only the first &lt;a href=&quot;join-to-string#kotlin.sequences%24joinToString(kotlin.sequences.Sequence((kotlin.sequences.joinToString.T)),%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Function1?((kotlin.sequences.joinToString.T,%20kotlin.CharSequence)))/limit&quot;&gt;limit&lt;/a&gt; elements will be appended, followed by the &lt;a href=&quot;join-to-string#kotlin.sequences%24joinToString(kotlin.sequences.Sequence((kotlin.sequences.joinToString.T)),%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Function1?((kotlin.sequences.joinToString.T,%20kotlin.CharSequence)))/truncated&quot;&gt;truncated&lt;/a&gt; string (which defaults to &quot;...&quot;).</source>
          <target state="translated">コレクションが膨大になる可能性がある場合は、&lt;a href=&quot;join-to-string#kotlin.sequences%24joinToString(kotlin.sequences.Sequence((kotlin.sequences.joinToString.T)),%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Function1?((kotlin.sequences.joinToString.T,%20kotlin.CharSequence)))/limit&quot;&gt;limitの&lt;/a&gt;負でない値を指定できます。この場合、最初の&lt;a href=&quot;join-to-string#kotlin.sequences%24joinToString(kotlin.sequences.Sequence((kotlin.sequences.joinToString.T)),%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Function1?((kotlin.sequences.joinToString.T,%20kotlin.CharSequence)))/limit&quot;&gt;limit&lt;/a&gt;要素のみが追加され、その後に&lt;a href=&quot;join-to-string#kotlin.sequences%24joinToString(kotlin.sequences.Sequence((kotlin.sequences.joinToString.T)),%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Function1?((kotlin.sequences.joinToString.T,%20kotlin.CharSequence)))/truncated&quot;&gt;切り捨てられた&lt;/a&gt;文字列（デフォルトは「...」）が続きます。</target>
        </trans-unit>
        <trans-unit id="da05b4ffa7db8223c058fb5dd70605340f6d4abf" translate="yes" xml:space="preserve">
          <source>If the compiler can figure the signature out itself, it is allowed not to declare the only parameter and omit &lt;code&gt;-&amp;gt;&lt;/code&gt;. The parameter will be implicitly declared under the name &lt;code&gt;it&lt;/code&gt;:</source>
          <target state="translated">コンパイラがシグネチャ自体を把握できる場合、唯一のパラメータを宣言せずに &lt;code&gt;-&amp;gt;&lt;/code&gt; を省略できます。パラメータは、 &lt;code&gt;it&lt;/code&gt; という名前で暗黙的に宣言されます。</target>
        </trans-unit>
        <trans-unit id="599643b28c2249744c642d762df9eef25c3f1489" translate="yes" xml:space="preserve">
          <source>If the condition of an &lt;code&gt;if&lt;/code&gt; or &lt;code&gt;when&lt;/code&gt; statement is multiline, always use curly braces around the body of the statement. Indent each subsequent line of the condition by 4 spaces relative to statement begin. Put the closing parentheses of the condition together with the opening curly brace on a separate line:</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; または &lt;code&gt;when&lt;/code&gt; ステートメントの条件が複数行の場合は、常にステートメントの本文を中括弧で囲みます。条件の後続の各行を、ステートメント開始から4つのスペースでインデントします。条件の閉じ括弧を開始中括弧と一緒に別の行に置きます。</target>
        </trans-unit>
        <trans-unit id="98f9b69afd4c5b26ac6e15a0b936fff143ad40e0" translate="yes" xml:space="preserve">
          <source>If the condition of an &lt;code&gt;if&lt;/code&gt; or &lt;code&gt;when&lt;/code&gt; statement is multiline, always use curly braces around the body of the statement. Indent each subsequent line of the condition by four spaces relative to statement begin. Put the closing parentheses of the condition together with the opening curly brace on a separate line:</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; または &lt;code&gt;when&lt;/code&gt; ステートメントの条件が複数行の場合は、ステートメントの本体を常に中括弧で囲んでください。ステートメントの開始を基準にして、条件の後続の各行を4つのスペースでインデントします。条件の閉じ括弧と開始中括弧を別の行に配置します。</target>
        </trans-unit>
        <trans-unit id="2257c88010b27895c6524d9c1e2196bb7e536709" translate="yes" xml:space="preserve">
          <source>If the constructor has annotations or visibility modifiers, the &lt;em&gt;constructor&lt;/em&gt; keyword is required, and the modifiers go before it:</source>
          <target state="translated">コンストラクターに注釈または可視性修飾子がある場合、コンストラク&lt;em&gt;ター&lt;/em&gt;キーワードは必須であり、修飾子はその前に配置されます。</target>
        </trans-unit>
        <trans-unit id="8e6824b3ec6e98e5575247ecc8ff5b7a4046e476" translate="yes" xml:space="preserve">
          <source>If the corresponding binary function (i.e. &lt;code&gt;plus()&lt;/code&gt; for &lt;code&gt;plusAssign()&lt;/code&gt;) is available too, report error (ambiguity),</source>
          <target state="translated">もし対応するバイナリ機能（すなわち &lt;code&gt;plus()&lt;/code&gt; のための &lt;code&gt;plusAssign()&lt;/code&gt; ）エラー報告（曖昧）、あまりにも利用可能です、</target>
        </trans-unit>
        <trans-unit id="750feaab46d025f60b60595fd5b6464a238bc26d" translate="yes" xml:space="preserve">
          <source>If the current capacity is less than the &lt;a href=&quot;ensure-capacity#kotlin.text.StringBuilder%24ensureCapacity(kotlin.Int)/minimumCapacity&quot;&gt;minimumCapacity&lt;/a&gt;, a new backing storage is allocated with greater capacity. Otherwise, this method takes no action and simply returns.</source>
          <target state="translated">現在の容量が&lt;a href=&quot;ensure-capacity#kotlin.text.StringBuilder%24ensureCapacity(kotlin.Int)/minimumCapacity&quot;&gt;minimumCapacityより小さい&lt;/a&gt;場合、新しいバッキングストレージに大きな容量が割り当てられます。それ以外の場合、このメソッドはアクションを実行せず、単に戻ります。</target>
        </trans-unit>
        <trans-unit id="3beb3ca0f76030c28cffd99a1ef390c7748ebe7c" translate="yes" xml:space="preserve">
          <source>If the derived class has a primary constructor, the base class can (and must) be initialized right there, using the parameters of the primary constructor.</source>
          <target state="translated">派生クラスに一次コンストラクタがある場合、基底クラスはその場で一次コンストラクタのパラメータを使用して初期化することができます (そして、初期化しなければなりません)。</target>
        </trans-unit>
        <trans-unit id="81ea87c7c846a5bc82b765d82616bbeeb4342e98" translate="yes" xml:space="preserve">
          <source>If the derived class has no primary constructor, then each secondary constructor has to initialize the base type using the &lt;em&gt;super&lt;/em&gt; keyword, or to delegate to another constructor which does that. Note that in this case different secondary constructors can call different constructors of the base type:</source>
          <target state="translated">派生クラスにプライマリコンストラクタがない場合、各セカンダリコンストラクタは、&lt;em&gt;super&lt;/em&gt;キーワードを使用して基本型を初期化するか、それを行う別のコンストラクタに委任する必要があります。この場合、異なるセカンダリコンストラクターが基本型の異なるコンストラクターを呼び出すことができることに注意してください。</target>
        </trans-unit>
        <trans-unit id="4bdcd3a2cd6234626ea8fd7aebd3dff5dd746817" translate="yes" xml:space="preserve">
          <source>If the enum class defines any members, separate the enum constant definitions from the member definitions with a semicolon.</source>
          <target state="translated">列挙型クラスがメンバを定義している場合は、列挙型定数の定義とメンバの定義をセミコロンで区切ってください。</target>
        </trans-unit>
        <trans-unit id="4f83e9cb6ca713b30ca5975229637ad37ddf0b2e" translate="yes" xml:space="preserve">
          <source>If the expression to the left of &lt;code&gt;?:&lt;/code&gt; is not null, the elvis operator returns it, otherwise it returns the expression to the right. Note that the right-hand side expression is evaluated only if the left-hand side is null.</source>
          <target state="translated">&lt;code&gt;?:&lt;/code&gt; の左側の式がnullでない場合、elvis演算子はそれを返します。それ以外の場合は、右側の式を返します。右側の式は、左側がnullの場合にのみ評価されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="435bd7ef9c1ca0e75781f37812da8cdd0434ce4a" translate="yes" xml:space="preserve">
          <source>If the file path given is just a file, walker iterates only it. If the file path given does not exist, walker iterates nothing, i.e. it's equivalent to an empty sequence.</source>
          <target state="translated">与えられたファイルパスが単なるファイルであれば、walkerはそのファイルのみを処理します。与えられたファイルパスが存在しない場合、walkerは何も処理しません。</target>
        </trans-unit>
        <trans-unit id="950981d3a093a2bbe4e3f81e6b27e0b947e8539d" translate="yes" xml:space="preserve">
          <source>If the files reside in locations different from the current directory, use relative paths.</source>
          <target state="translated">ファイルがカレントディレクトリとは異なる場所にある場合は、相対パスを使用します。</target>
        </trans-unit>
        <trans-unit id="341f4361aea5609d460e0b76db7e4ec05c60a0bb" translate="yes" xml:space="preserve">
          <source>If the function from the right column is available</source>
          <target state="translated">右側の列からの関数が利用できる場合</target>
        </trans-unit>
        <trans-unit id="baaa08a62689c9d8bfb298957d5ecaaa332cecf1" translate="yes" xml:space="preserve">
          <source>If the function has an expression body that doesn't fit in the same line as the declaration, put the &lt;code&gt;=&lt;/code&gt; sign on the first line. Indent the expression body by 4 spaces.</source>
          <target state="translated">関数の式本体が宣言と同じ行に収まらない場合は、最初の行に &lt;code&gt;=&lt;/code&gt; 記号を付けます。式の本文を4つのスペースでインデントします。</target>
        </trans-unit>
        <trans-unit id="70135d84f18dddfdfe73a753ae1ea55edda69b5b" translate="yes" xml:space="preserve">
          <source>If the function has an expression body that doesn't fit in the same line as the declaration, put the &lt;code&gt;=&lt;/code&gt; sign on the first line. Indent the expression body by four spaces.</source>
          <target state="translated">関数に宣言と同じ行に収まらない式本体がある場合は、最初の行に &lt;code&gt;=&lt;/code&gt; 記号を付けます。式本体を4つのスペースでインデントします。</target>
        </trans-unit>
        <trans-unit id="29229e1e579d9295bd8f3ae80b55b98deb32a290" translate="yes" xml:space="preserve">
          <source>If the function is absent or ambiguous, it is a compilation error;</source>
          <target state="translated">関数が存在しないか曖昧な場合はコンパイルエラーです。</target>
        </trans-unit>
        <trans-unit id="6df6274a785959a141d5be93cbbade7433fe3f26" translate="yes" xml:space="preserve">
          <source>If the function is present and its return type is &lt;code&gt;R&lt;/code&gt;, the expression &lt;code&gt;+a&lt;/code&gt; has type &lt;code&gt;R&lt;/code&gt;;</source>
          <target state="translated">関数が存在し、その戻り型が &lt;code&gt;R&lt;/code&gt; の場合、式 &lt;code&gt;+a&lt;/code&gt; の型は &lt;code&gt;R&lt;/code&gt; になります。</target>
        </trans-unit>
        <trans-unit id="0e5095d3d7b34d609b680d7fa5506874cf55c9e5" translate="yes" xml:space="preserve">
          <source>If the function signature doesn't fit on a single line, use the following syntax:</source>
          <target state="translated">関数のシグネチャが一行に収まらない場合は、以下の構文を使用します。</target>
        </trans-unit>
        <trans-unit id="da5a14c8b54552ea732a4d4e6142a3943b4cd96d" translate="yes" xml:space="preserve">
          <source>If the group in the regular expression is optional and there were no match captured by that group, corresponding component value is an empty string.</source>
          <target state="translated">正規表現内のグループがオプションであり、そのグループによって捕捉された一致がなかった場合、対応するコンポーネントの値は空文字列となります。</target>
        </trans-unit>
        <trans-unit id="d430ff9c1ba01bf9a8c783998530df052f55721e" translate="yes" xml:space="preserve">
          <source>If the group in the regular expression is optional and there were no match captured by that group, corresponding item in &lt;a href=&quot;group-values&quot;&gt;groupValues&lt;/a&gt; is an empty string.</source>
          <target state="translated">正規表現のグループがオプションであり、そのグループによってキャプチャされた一致がなかった場合、&lt;a href=&quot;group-values&quot;&gt;groupValuesの&lt;/a&gt;対応する項目は空の文字列です。</target>
        </trans-unit>
        <trans-unit id="2c92efac4e6ff6397d8d9d74602f3a7f95aa695d" translate="yes" xml:space="preserve">
          <source>If the hours component absolute value of this duration is greater than &lt;a href=&quot;../../kotlin/-int/-m-a-x_-v-a-l-u-e#kotlin.Int.Companion%24MAX_VALUE&quot;&gt;Int.MAX_VALUE&lt;/a&gt;, it is replaced with &lt;a href=&quot;../../kotlin/-int/-m-a-x_-v-a-l-u-e#kotlin.Int.Companion%24MAX_VALUE&quot;&gt;Int.MAX_VALUE&lt;/a&gt;, so the infinite duration is formatted as `&quot;PT2147483647H&quot;.</source>
          <target state="translated">この期間の時間成分絶対値がより大きい場合&lt;a href=&quot;../../kotlin/-int/-m-a-x_-v-a-l-u-e#kotlin.Int.Companion%24MAX_VALUE&quot;&gt;Int.MAX_VALUE&lt;/a&gt;、それに置き換えられ&lt;a href=&quot;../../kotlin/-int/-m-a-x_-v-a-l-u-e#kotlin.Int.Companion%24MAX_VALUE&quot;&gt;Int.MAX_VALUE&lt;/a&gt;ので、無限の持続時間は`「PT2147483647H」としてフォーマットされています。</target>
        </trans-unit>
        <trans-unit id="643fa02b9a8df93d52958425162d28c0e98f33e6" translate="yes" xml:space="preserve">
          <source>If the initialization of a value throws an exception, it will attempt to reinitialize the value at next access.</source>
          <target state="translated">値の初期化で例外が発生した場合、次回のアクセス時に値の再初期化を試みます。</target>
        </trans-unit>
        <trans-unit id="70f53db00bc0a33bccdcb28704c5331a818e66f8" translate="yes" xml:space="preserve">
          <source>If the innermost applied &lt;code&gt;@JvmSuppressWildcards&lt;/code&gt; has &lt;code&gt;suppress=true&lt;/code&gt;, the type is generated without wildcards. If the innermost applied &lt;code&gt;@JvmSuppressWildcards&lt;/code&gt; has &lt;code&gt;suppress=false&lt;/code&gt;, the type is generated with wildcards.</source>
          <target state="translated">最も内側に適用された &lt;code&gt;@JvmSuppressWildcards&lt;/code&gt; に &lt;code&gt;suppress=true&lt;/code&gt; がある場合、タイプはワイルドカードなしで生成されます。最も内側に適用された &lt;code&gt;@JvmSuppressWildcards&lt;/code&gt; に &lt;code&gt;suppress=false&lt;/code&gt; がある場合、タイプはワイルドカードを使用して生成されます。</target>
        </trans-unit>
        <trans-unit id="eee51b4527104383bc254754abf4668fd83fd300" translate="yes" xml:space="preserve">
          <source>If the lambda is the only argument to that call, the parentheses can be omitted entirely:</source>
          <target state="translated">ラムダがその呼び出しの唯一の引数である場合、括弧は完全に省略することができます。</target>
        </trans-unit>
        <trans-unit id="1de53ed9727d06b3c7bd0607d6d4643e9b89c9f3" translate="yes" xml:space="preserve">
          <source>If the lambda parameter is unused, you can place an underscore instead of its name:</source>
          <target state="translated">lambda パラメータが使用されていない場合は、その名前の代わりにアンダースコアを置くことができます。</target>
        </trans-unit>
        <trans-unit id="a9c6142f7e98803bfddded146b81383e4a0f40e4" translate="yes" xml:space="preserve">
          <source>If the last argument after default parameters is a &lt;a href=&quot;lambdas#lambda-expression-syntax&quot;&gt;lambda&lt;/a&gt;, it can be passed in either as a named argument or &lt;a href=&quot;lambdas#passing-a-lambda-to-the-last-parameter&quot;&gt;outside the parentheses&lt;/a&gt;:</source>
          <target state="translated">デフォルトのパラメータの後の最後の引数が&lt;a href=&quot;lambdas#lambda-expression-syntax&quot;&gt;lambdaの&lt;/a&gt;場合、名前付き引数として、または&lt;a href=&quot;lambdas#passing-a-lambda-to-the-last-parameter&quot;&gt;括弧の外&lt;/a&gt;で渡すことができます。</target>
        </trans-unit>
        <trans-unit id="228e14748a5781e0c8dfea5c0e0f424d49c4dd7a" translate="yes" xml:space="preserve">
          <source>If the last argument after default parameters is a &lt;a href=&quot;lambdas#lambda-expression-syntax&quot;&gt;lambda&lt;/a&gt;, you can pass it either as a named argument or &lt;a href=&quot;lambdas#passing-a-lambda-to-the-last-parameter&quot;&gt;outside the parentheses&lt;/a&gt;:</source>
          <target state="translated">デフォルトパラメータの後の最後の引数が&lt;a href=&quot;lambdas#lambda-expression-syntax&quot;&gt;ラムダの&lt;/a&gt;場合、名前付き引数として、または&lt;a href=&quot;lambdas#passing-a-lambda-to-the-last-parameter&quot;&gt;括弧の外に&lt;/a&gt;渡すことができます。</target>
        </trans-unit>
        <trans-unit id="b64359d957702bc4133d8dddc95300b39134cda9" translate="yes" xml:space="preserve">
          <source>If the library you are adding has dependencies on &lt;a href=&quot;#npm-dependencies&quot;&gt;packages from npm&lt;/a&gt;, Gradle will automatically resolve these transitive dependencies as well.</source>
          <target state="translated">追加するライブラリに&lt;a href=&quot;#npm-dependencies&quot;&gt;npmのパッケージ&lt;/a&gt;への依存関係がある場合、Gradleはこれらの推移的な依存関係も自動的に解決します。</target>
        </trans-unit>
        <trans-unit id="bc94874fad8d6a3f9e943d1975b7337b73e5e96a" translate="yes" xml:space="preserve">
          <source>If the list contains multiple elements equal to the specified &lt;a href=&quot;binary-search#kotlin.collections%24binarySearch%28kotlin.collections.List%28%28kotlin.collections.binarySearch.T%29%29%2C+kotlin.collections.binarySearch.T%2C+kotlin.Comparator%28%28kotlin.collections.binarySearch.T%29%29%2C+kotlin.Int%2C+kotlin.Int%29%2Felement&quot;&gt;element&lt;/a&gt;, there is no guarantee which one will be found.</source>
          <target state="translated">リストに指定された&lt;a href=&quot;binary-search#kotlin.collections%24binarySearch%28kotlin.collections.List%28%28kotlin.collections.binarySearch.T%29%29%2C+kotlin.collections.binarySearch.T%2C+kotlin.Comparator%28%28kotlin.collections.binarySearch.T%29%29%2C+kotlin.Int%2C+kotlin.Int%29%2Felement&quot;&gt;element&lt;/a&gt;と等しい複数の要素が含まれている場合、どの要素が見つかるかは保証されません。</target>
        </trans-unit>
        <trans-unit id="283094cd40b3e90a305fdcb2b91ad3b0c2c41453" translate="yes" xml:space="preserve">
          <source>If the list contains multiple elements equal to the specified &lt;a href=&quot;binary-search#kotlin.collections%24binarySearch%28kotlin.collections.List%28%28kotlin.collections.binarySearch.T%29%29%2C+kotlin.collections.binarySearch.T%2C+kotlin.Int%2C+kotlin.Int%29%2Felement&quot;&gt;element&lt;/a&gt;, there is no guarantee which one will be found.</source>
          <target state="translated">リストに指定された&lt;a href=&quot;binary-search#kotlin.collections%24binarySearch%28kotlin.collections.List%28%28kotlin.collections.binarySearch.T%29%29%2C+kotlin.collections.binarySearch.T%2C+kotlin.Int%2C+kotlin.Int%29%2Felement&quot;&gt;element&lt;/a&gt;と等しい複数の要素が含まれている場合、どの要素が見つかるかは保証されません。</target>
        </trans-unit>
        <trans-unit id="791c40d36929cc71b9e4bc35ccf6279a3a20c0ac" translate="yes" xml:space="preserve">
          <source>If the list contains multiple elements equal to the specified &lt;a href=&quot;binary-search#kotlin.collections%24binarySearch(kotlin.collections.List((kotlin.collections.binarySearch.T)),%20kotlin.collections.binarySearch.T,%20kotlin.Comparator((kotlin.collections.binarySearch.T)),%20kotlin.Int,%20kotlin.Int)/element&quot;&gt;element&lt;/a&gt;, there is no guarantee which one will be found.</source>
          <target state="translated">リストには、複数の要素が指定されたに等しい含まれている場合&lt;a href=&quot;binary-search#kotlin.collections%24binarySearch(kotlin.collections.List((kotlin.collections.binarySearch.T)),%20kotlin.collections.binarySearch.T,%20kotlin.Comparator((kotlin.collections.binarySearch.T)),%20kotlin.Int,%20kotlin.Int)/element&quot;&gt;の要素&lt;/a&gt;、1が発見される保証はありません。</target>
        </trans-unit>
        <trans-unit id="44a57d6c0b8b204d89d02d382bc44b25184c5e7e" translate="yes" xml:space="preserve">
          <source>If the list contains multiple elements equal to the specified &lt;a href=&quot;binary-search#kotlin.collections%24binarySearch(kotlin.collections.List((kotlin.collections.binarySearch.T?)),%20kotlin.collections.binarySearch.T?,%20kotlin.Int,%20kotlin.Int)/element&quot;&gt;element&lt;/a&gt;, there is no guarantee which one will be found.</source>
          <target state="translated">リストには、複数の要素が指定されたに等しい含まれている場合&lt;a href=&quot;binary-search#kotlin.collections%24binarySearch(kotlin.collections.List((kotlin.collections.binarySearch.T?)),%20kotlin.collections.binarySearch.T?,%20kotlin.Int,%20kotlin.Int)/element&quot;&gt;の要素&lt;/a&gt;、1が発見される保証はありません。</target>
        </trans-unit>
        <trans-unit id="79a654f17dffc6680bd32da28acb61ad45511a3b" translate="yes" xml:space="preserve">
          <source>If the list contains multiple elements for which &lt;a href=&quot;binary-search#kotlin.collections%24binarySearch%28kotlin.collections.List%28%28kotlin.collections.binarySearch.T%29%29%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.collections.binarySearch.T%2C+kotlin.Int%29%29%29%2Fcomparison&quot;&gt;comparison&lt;/a&gt; returns zero, there is no guarantee which one will be found.</source>
          <target state="translated">リストに&lt;a href=&quot;binary-search#kotlin.collections%24binarySearch%28kotlin.collections.List%28%28kotlin.collections.binarySearch.T%29%29%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.collections.binarySearch.T%2C+kotlin.Int%29%29%29%2Fcomparison&quot;&gt;比較で&lt;/a&gt;ゼロが返される複数の要素が含まれている場合、どの要素が見つかるかは保証されません。</target>
        </trans-unit>
        <trans-unit id="196e625da9b2a4c97eb60bc8e8aa4a4acff994c2" translate="yes" xml:space="preserve">
          <source>If the list contains multiple elements for which &lt;a href=&quot;binary-search#kotlin.collections%24binarySearch(kotlin.collections.List((kotlin.collections.binarySearch.T)),%20kotlin.Int,%20kotlin.Int,%20kotlin.Function1((kotlin.collections.binarySearch.T,%20kotlin.Int)))/comparison&quot;&gt;comparison&lt;/a&gt; returns zero, there is no guarantee which one will be found.</source>
          <target state="translated">&lt;a href=&quot;binary-search#kotlin.collections%24binarySearch(kotlin.collections.List((kotlin.collections.binarySearch.T)),%20kotlin.Int,%20kotlin.Int,%20kotlin.Function1((kotlin.collections.binarySearch.T,%20kotlin.Int)))/comparison&quot;&gt;比較で&lt;/a&gt;ゼロが返される要素がリストに複数含まれている場合、どれが見つかるかは保証されません。</target>
        </trans-unit>
        <trans-unit id="3c27e8d39625b1f210692fb3e472e2e70d219112" translate="yes" xml:space="preserve">
          <source>If the list contains multiple elements with the specified &lt;a href=&quot;binary-search-by#kotlin.collections%24binarySearchBy%28kotlin.collections.List%28%28kotlin.collections.binarySearchBy.T%29%29%2C+kotlin.collections.binarySearchBy.K%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.collections.binarySearchBy.T%2C+kotlin.collections.binarySearchBy.K%29%29%29%2Fkey&quot;&gt;key&lt;/a&gt;, there is no guarantee which one will be found.</source>
          <target state="translated">リストに指定された&lt;a href=&quot;binary-search-by#kotlin.collections%24binarySearchBy%28kotlin.collections.List%28%28kotlin.collections.binarySearchBy.T%29%29%2C+kotlin.collections.binarySearchBy.K%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.collections.binarySearchBy.T%2C+kotlin.collections.binarySearchBy.K%29%29%29%2Fkey&quot;&gt;キーを&lt;/a&gt;持つ複数の要素が含まれている場合、どの要素が見つかるかは保証されません。</target>
        </trans-unit>
        <trans-unit id="954563aad1a60c6b8d078907859e9fc7093c613a" translate="yes" xml:space="preserve">
          <source>If the list contains multiple elements with the specified &lt;a href=&quot;binary-search-by#kotlin.collections%24binarySearchBy(kotlin.collections.List((kotlin.collections.binarySearchBy.T)),%20kotlin.collections.binarySearchBy.K?,%20kotlin.Int,%20kotlin.Int,%20kotlin.Function1((kotlin.collections.binarySearchBy.T,%20kotlin.collections.binarySearchBy.K?)))/key&quot;&gt;key&lt;/a&gt;, there is no guarantee which one will be found.</source>
          <target state="translated">リストに指定された&lt;a href=&quot;binary-search-by#kotlin.collections%24binarySearchBy(kotlin.collections.List((kotlin.collections.binarySearchBy.T)),%20kotlin.collections.binarySearchBy.K?,%20kotlin.Int,%20kotlin.Int,%20kotlin.Function1((kotlin.collections.binarySearchBy.T,%20kotlin.collections.binarySearchBy.K?)))/key&quot;&gt;キーを&lt;/a&gt;持つ複数の要素が含まれている場合、どれが見つかるかは保証されません。</target>
        </trans-unit>
        <trans-unit id="faaba4525f66a7ceffb2e5046c2260e6c103509f" translate="yes" xml:space="preserve">
          <source>If the list size is less than the specified index, an exception is thrown. There are two other functions that help you avoid such exceptions:</source>
          <target state="translated">リストのサイズが指定したインデックスよりも小さい場合は例外がスローされます。このような例外を回避するのに役立つ関数が他に2つあります。</target>
        </trans-unit>
        <trans-unit id="eb9933a4cb9e8666aba0e0d81ce03883cc01e6a2" translate="yes" xml:space="preserve">
          <source>If the map was created by &lt;a href=&quot;with-default&quot;&gt;withDefault&lt;/a&gt;, resorts to its &lt;code&gt;defaultValue&lt;/code&gt; provider function instead of throwing an exception.</source>
          <target state="translated">マップが&lt;a href=&quot;with-default&quot;&gt;withDefault&lt;/a&gt;によって作成された場合、例外をスローする代わりに、その &lt;code&gt;defaultValue&lt;/code&gt; プロバイダー関数を使用します。</target>
        </trans-unit>
        <trans-unit id="b065f87a2aa4168218c6dc371595cc4dd1e98fe7" translate="yes" xml:space="preserve">
          <source>If the memory leak checker is activated, by default &lt;code&gt;true&lt;/code&gt; in debug mode, &lt;code&gt;false&lt;/code&gt; in release. When memory leak checker is activated, and leak is detected during last Kotlin context deinitialization process - error message with leak information is printed and application execution is aborted.</source>
          <target state="translated">メモリリークチェッカーがアクティブになっている場合、デフォルト &lt;code&gt;true&lt;/code&gt; はデバッグモードでは &lt;code&gt;false&lt;/code&gt; 、リリースではfalseです。メモリリークチェッカーがアクティブ化され、最後のKotlinコンテキストの初期化解除プロセス中にリークが検出されると、リーク情報を含むエラーメッセージが出力され、アプリケーションの実行が中止されます。</target>
        </trans-unit>
        <trans-unit id="c1f1e713ff8c23832b76dce0f833606cef70aca6" translate="yes" xml:space="preserve">
          <source>If the name of the property starts with &lt;code&gt;is&lt;/code&gt;, a different name mapping rule is used: the name of the getter will be the same as the property name, and the name of the setter will be obtained by replacing &lt;code&gt;is&lt;/code&gt; with &lt;code&gt;set&lt;/code&gt;. For example, for a property &lt;code&gt;isOpen&lt;/code&gt;, the getter will be called &lt;code&gt;isOpen()&lt;/code&gt; and the setter will be called &lt;code&gt;setOpen()&lt;/code&gt;. This rule applies for properties of any type, not just &lt;code&gt;Boolean&lt;/code&gt;.</source>
          <target state="translated">プロパティの名前が &lt;code&gt;is&lt;/code&gt; で始まる場合、別の名前マッピングルールが使用されます。ゲッターの名前はプロパティ名と同じになり、セッターの名前は &lt;code&gt;is&lt;/code&gt; を &lt;code&gt;set&lt;/code&gt; に置き換えることで取得されます。たとえば、プロパティ &lt;code&gt;isOpen&lt;/code&gt; の場合、ゲッターは &lt;code&gt;isOpen()&lt;/code&gt; と呼ばれ、セッターは &lt;code&gt;setOpen()&lt;/code&gt; と呼ばれます。このルールは、 &lt;code&gt;Boolean&lt;/code&gt; 型だけでなく、あらゆるタイプのプロパティに適用されます。</target>
        </trans-unit>
        <trans-unit id="3332fa3bdec15301400b043f38b9641d591bc5f4" translate="yes" xml:space="preserve">
          <source>If the object is an instance of a functional Java interface (i.e. a Java interface with a single abstract method), you can create it using a lambda expression prefixed with the type of the interface:</source>
          <target state="translated">オブジェクトが機能的な Java インターフェース(つまり、単一の抽象メソッドを持つ Java インターフェース)のインスタンスである場合は、インターフェースの型を先頭にしたラムダ式を使用して作成することができます。</target>
        </trans-unit>
        <trans-unit id="079d14d9fa4b11b9fed1da4e6938934fb59ac4b3" translate="yes" xml:space="preserve">
          <source>If the original list is mutable, all its changes reflect in its reversed views and vice versa.</source>
          <target state="translated">元のリストが突然変異可能な場合、その変更はすべて反転表示に反映され、その逆もまた然りです。</target>
        </trans-unit>
        <trans-unit id="f199eb80255475df9da84da09551f8bd23017106" translate="yes" xml:space="preserve">
          <source>If the package is not specified, the contents of such a file belong to &quot;default&quot; package that has no name.</source>
          <target state="translated">パッケージが指定されていない場合、そのようなファイルの内容は、名前のない &quot;default &quot;パッケージに属します。</target>
        </trans-unit>
        <trans-unit id="607e0590c98b31f775522f050ca8e1b54f20a06e" translate="yes" xml:space="preserve">
          <source>If the package is not specified, the contents of such a file belong to the default package that has no name.</source>
          <target state="translated">パッケージが指定されていない場合、そのようなファイルの内容は、名前のないデフォルトのパッケージに属します。</target>
        </trans-unit>
        <trans-unit id="e2bbcc7a5d6ec12b113958618724012f588f92a6" translate="yes" xml:space="preserve">
          <source>If the parameter list is too long to fit on a line, put the arrow on a separate line:</source>
          <target state="translated">パラメータリストが長すぎて一行に収まらない場合は、矢印を別の行に配置します。</target>
        </trans-unit>
        <trans-unit id="65d840640485aeb56113ca2dcd5f195cfe9368f9" translate="yes" xml:space="preserve">
          <source>If the parameters or return types of the members of a variant type are themselves variant, it gets a bit complicated. Function types in parameters and return types make it even more challenging. If you're wondering whether it's safe to use a variant type parameter &lt;code&gt;T&lt;/code&gt; in a particular position, ask yourself:</source>
          <target state="translated">バリアント型のメンバーのパラメーターまたは戻り値の型自体がバリアント型である場合、少し複雑になります。パラメータの型と戻り値の型は、さらに難しいものにします。特定の位置でバリアント型パラメーター &lt;code&gt;T&lt;/code&gt; を使用しても安全かどうか疑問に思っている場合は、次の点を確認してください。</target>
        </trans-unit>
        <trans-unit id="a18d633a4ebf37f8c95ff8f80627508e8e6e0a0d" translate="yes" xml:space="preserve">
          <source>If the primary constructor does not have any annotations or visibility modifiers, the &lt;em&gt;constructor&lt;/em&gt; keyword can be omitted:</source>
          <target state="translated">プライマリコンストラクターに注釈または可視性修飾子がない場合は、&lt;em&gt;コンストラクター&lt;/em&gt;キーワードを省略できます。</target>
        </trans-unit>
        <trans-unit id="a6331b4a5547ad93c58b05b7df58bb3cc81e3498" translate="yes" xml:space="preserve">
          <source>If the repository of the dependency you wish to use does not provide TypeScript definitions, you can also use types provided via the &lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped&quot;&gt;DefinitelyTyped&lt;/a&gt; repository. In this case, make sure you add &lt;code&gt;npm&lt;/code&gt; dependencies for both &lt;code&gt;your-package&lt;/code&gt; and &lt;code&gt;@types/your-package&lt;/code&gt; (with &lt;code&gt;generateExternals = true&lt;/code&gt;).</source>
          <target state="translated">使用したい依存関係のリポジトリがTypeScript定義を提供していない場合は、&lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped&quot;&gt;DefinitelyTyped&lt;/a&gt;リポジトリを介して提供されたタイプを使用することもできます。この場合、 &lt;code&gt;your-package&lt;/code&gt; と &lt;code&gt;@types/your-package&lt;/code&gt; 両方に &lt;code&gt;npm&lt;/code&gt; 依存関係を追加してください（ &lt;code&gt;generateExternals = true&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="47e17a53862f3b306373aab1293af010a48f2c36" translate="yes" xml:space="preserve">
          <source>If the same kind of ambiguity arises when a dependency is added to a custom configuration rather than one of the configurations created by the plugin, you can add the attributes to the configuration in the same way:</source>
          <target state="translated">プラグインが作成した設定のいずれかではなく、カスタム設定に依存関係を追加したときに同じような曖昧さが生じた場合は、同じように属性を設定に追加することができます。</target>
        </trans-unit>
        <trans-unit id="c2003e3c2a4c342bc0df488d2992403b24e0a68f" translate="yes" xml:space="preserve">
          <source>If the second-to-last line compiled, it would allow us to put a pear into what is ostensibly a bowl of only apples, and your code would explode when it tried to extract the &quot;apple&quot; from the bowl. However, it's frequently useful to be able to let the type hierarchy of a generic type parameter &quot;flow&quot; to the generic class. As we saw above, though, some care must be taken - the solution is to restrict the direction in which you can move data in and out of the generic object.</source>
          <target state="translated">2行目から最後の1行目がコンパイルされた場合、表向きはリンゴだけのボウルに梨を入れることができ、ボウルから &quot;リンゴ &quot;を抽出しようとしたときにコードが爆発することになります。しかし、汎用型パラメータの型階層を汎用クラスに「フロー」させることができると便利なことがよくあります。しかし、上で見たように、いくつかの注意を払わなければなりません-解決策は、ジェネリックオブジェクトにデータを出し入れする方向を制限することです。</target>
        </trans-unit>
        <trans-unit id="5e1d01b7eb886e9322c190422643ee87c94b9cb3" translate="yes" xml:space="preserve">
          <source>If the sequence operation returns another sequence, which is produced lazily, it's called &lt;em&gt;intermediate&lt;/em&gt;, and otherwise the operation is &lt;em&gt;terminal&lt;/em&gt;. Examples of terminal operations are &lt;a href=&quot;to-list&quot;&gt;kotlin.sequences.Sequence.toList&lt;/a&gt;, kotlin.sequences.Sequence.max.</source>
          <target state="translated">シーケンス操作が遅延生成される別のシーケンスを返す場合、それは&lt;em&gt;中間&lt;/em&gt;と呼ばれます。それ以外の場合、操作は&lt;em&gt;terminal&lt;/em&gt;です。端末の動作例は、&lt;a href=&quot;to-list&quot;&gt;kotlin.sequences.Sequence.toList&lt;/a&gt;、kotlin.sequences.Sequence.max。</target>
        </trans-unit>
        <trans-unit id="44fdc9a07256ffbf20d393bac49e51adf9b4b7af" translate="yes" xml:space="preserve">
          <source>If the size of this array is less than 1, throws an &lt;a href=&quot;../kotlin/-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">この配列のサイズが1未満の場合、動作が指定されていないKotlin / JSを除いて、&lt;a href=&quot;../kotlin/-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsExceptionがスロー&lt;/a&gt;されます。</target>
        </trans-unit>
        <trans-unit id="2773fd03bef38a23b5651a21ca7d831595d79640" translate="yes" xml:space="preserve">
          <source>If the size of this array is less than 2, throws an &lt;a href=&quot;../kotlin/-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">この配列のサイズが2未満の場合、動作が指定されていないKotlin / JSを除いて、&lt;a href=&quot;../kotlin/-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsExceptionがスロー&lt;/a&gt;されます。</target>
        </trans-unit>
        <trans-unit id="0a0294e2f74afcb56591a07671514765850b0c72" translate="yes" xml:space="preserve">
          <source>If the size of this array is less than 3, throws an &lt;a href=&quot;../kotlin/-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">この配列のサイズが3未満の場合、動作が指定されていないKotlin / JSを除いて、&lt;a href=&quot;../kotlin/-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsExceptionがスロー&lt;/a&gt;されます。</target>
        </trans-unit>
        <trans-unit id="da2e1fd0a51d8f47f0a64c24600fb4365faadd98" translate="yes" xml:space="preserve">
          <source>If the size of this array is less than 4, throws an &lt;a href=&quot;../kotlin/-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">この配列のサイズが4未満の場合、動作が指定されていないKotlin / JSを除いて、&lt;a href=&quot;../kotlin/-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsExceptionがスロー&lt;/a&gt;されます。</target>
        </trans-unit>
        <trans-unit id="9b9ee92ddb8bbb5a34fed19ad7463f35b65299f8" translate="yes" xml:space="preserve">
          <source>If the size of this array is less than 5, throws an &lt;a href=&quot;../kotlin/-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">この配列のサイズが5未満の場合、動作が指定されていないKotlin / JSを除いて、&lt;a href=&quot;../kotlin/-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsExceptionがスロー&lt;/a&gt;されます。</target>
        </trans-unit>
        <trans-unit id="2f129a501ea48f8a97397e0402d32e22a0e66393" translate="yes" xml:space="preserve">
          <source>If the source set &lt;code&gt;jvmMain&lt;/code&gt; depends on a source set &lt;code&gt;commonMain&lt;/code&gt; then:</source>
          <target state="translated">ソースセット &lt;code&gt;jvmMain&lt;/code&gt; がソースセットcommonMainに依存している場合、 &lt;code&gt;commonMain&lt;/code&gt; なります。</target>
        </trans-unit>
        <trans-unit id="aea8a32a75a7deb90bc9b2784a7bca89130df6d4" translate="yes" xml:space="preserve">
          <source>If the supertype has a constructor, it must be invoked with parentheses after the supertype name. You can specify multiple supertypes if need be (but as usual, at most one superclass).</source>
          <target state="translated">スーパータイプにコンストラクタがある場合は、スーパータイプ名の後に括弧をつけて呼び出さなければなりません。必要に応じて複数のスーパータイプを指定することができます(ただし、通常通り、スーパークラスは最大1つです)。</target>
        </trans-unit>
        <trans-unit id="f754e813201e3d3c1d7a4229841ecfb54eadad53" translate="yes" xml:space="preserve">
          <source>If the target meta-annotation is not present on an annotation declaration, the annotation is applicable to the following elements: &lt;a href=&quot;../-annotation-target/-c-l-a-s-s#kotlin.annotation.AnnotationTarget.CLASS&quot;&gt;CLASS&lt;/a&gt;, &lt;a href=&quot;../-annotation-target/-p-r-o-p-e-r-t-y#kotlin.annotation.AnnotationTarget.PROPERTY&quot;&gt;PROPERTY&lt;/a&gt;, &lt;a href=&quot;../-annotation-target/-f-i-e-l-d#kotlin.annotation.AnnotationTarget.FIELD&quot;&gt;FIELD&lt;/a&gt;, &lt;a href=&quot;../-annotation-target/-l-o-c-a-l_-v-a-r-i-a-b-l-e#kotlin.annotation.AnnotationTarget.LOCAL_VARIABLE&quot;&gt;LOCAL_VARIABLE&lt;/a&gt;, &lt;a href=&quot;../-annotation-target/-v-a-l-u-e_-p-a-r-a-m-e-t-e-r#kotlin.annotation.AnnotationTarget.VALUE_PARAMETER&quot;&gt;VALUE_PARAMETER&lt;/a&gt;, &lt;a href=&quot;../-annotation-target/-c-o-n-s-t-r-u-c-t-o-r#kotlin.annotation.AnnotationTarget.CONSTRUCTOR&quot;&gt;CONSTRUCTOR&lt;/a&gt;, &lt;a href=&quot;../-annotation-target/-f-u-n-c-t-i-o-n#kotlin.annotation.AnnotationTarget.FUNCTION&quot;&gt;FUNCTION&lt;/a&gt;, &lt;a href=&quot;../-annotation-target/-p-r-o-p-e-r-t-y_-g-e-t-t-e-r#kotlin.annotation.AnnotationTarget.PROPERTY_GETTER&quot;&gt;PROPERTY_GETTER&lt;/a&gt;, &lt;a href=&quot;../-annotation-target/-p-r-o-p-e-r-t-y_-s-e-t-t-e-r#kotlin.annotation.AnnotationTarget.PROPERTY_SETTER&quot;&gt;PROPERTY_SETTER&lt;/a&gt;.</source>
          <target state="translated">ターゲットのメタ注釈が注釈宣言に存在しない場合、注釈は次の要素に適用できます：&lt;a href=&quot;../-annotation-target/-c-l-a-s-s#kotlin.annotation.AnnotationTarget.CLASS&quot;&gt;CLASS&lt;/a&gt;、&lt;a href=&quot;../-annotation-target/-p-r-o-p-e-r-t-y#kotlin.annotation.AnnotationTarget.PROPERTY&quot;&gt;PROPERTY&lt;/a&gt;、&lt;a href=&quot;../-annotation-target/-f-i-e-l-d#kotlin.annotation.AnnotationTarget.FIELD&quot;&gt;FIELD&lt;/a&gt;、&lt;a href=&quot;../-annotation-target/-l-o-c-a-l_-v-a-r-i-a-b-l-e#kotlin.annotation.AnnotationTarget.LOCAL_VARIABLE&quot;&gt;LOCAL_VARIABLE&lt;/a&gt;、&lt;a href=&quot;../-annotation-target/-v-a-l-u-e_-p-a-r-a-m-e-t-e-r#kotlin.annotation.AnnotationTarget.VALUE_PARAMETER&quot;&gt;VALUE_PARAMETER&lt;/a&gt;、&lt;a href=&quot;../-annotation-target/-c-o-n-s-t-r-u-c-t-o-r#kotlin.annotation.AnnotationTarget.CONSTRUCTOR&quot;&gt;CONSTRUCTOR&lt;/a&gt;、&lt;a href=&quot;../-annotation-target/-f-u-n-c-t-i-o-n#kotlin.annotation.AnnotationTarget.FUNCTION&quot;&gt;FUNCTION&lt;/a&gt;、&lt;a href=&quot;../-annotation-target/-p-r-o-p-e-r-t-y_-g-e-t-t-e-r#kotlin.annotation.AnnotationTarget.PROPERTY_GETTER&quot;&gt;PROPERTY_GETTER&lt;/a&gt;、&lt;a href=&quot;../-annotation-target/-p-r-o-p-e-r-t-y_-s-e-t-t-e-r#kotlin.annotation.AnnotationTarget.PROPERTY_SETTER&quot;&gt;PROPERTY_SETTER&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8a35d20b281a1e85d8a06fc803c1646e572b36e8" translate="yes" xml:space="preserve">
          <source>If the transformation produces &lt;code&gt;null&lt;/code&gt; on certain elements, you can filter out the &lt;code&gt;null&lt;/code&gt;s from the result collection by calling the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/map-not-null&quot;&gt;&lt;code&gt;mapNotNull()&lt;/code&gt;&lt;/a&gt; function instead of &lt;code&gt;map()&lt;/code&gt;, or &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/map-indexed-not-null&quot;&gt;&lt;code&gt;mapIndexedNotNull()&lt;/code&gt;&lt;/a&gt; instead of &lt;code&gt;mapIndexed()&lt;/code&gt;.</source>
          <target state="translated">変換が生じた場合 &lt;code&gt;null&lt;/code&gt; 特定の要素に、あなたは除外でき &lt;code&gt;null&lt;/code&gt; 呼び出すことにより、結果コレクションからSを&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/map-not-null&quot;&gt; &lt;code&gt;mapNotNull()&lt;/code&gt; &lt;/a&gt;の代わりに、機能 &lt;code&gt;map()&lt;/code&gt; 、または&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/map-indexed-not-null&quot;&gt; &lt;code&gt;mapIndexedNotNull()&lt;/code&gt; &lt;/a&gt;の代わりに &lt;code&gt;mapIndexed()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a9296b27a4d8120036a7decf816cb92c4373c8a8" translate="yes" xml:space="preserve">
          <source>If the type of the last parameter to a function is a function type and you want to supply a lambda expression, you can place the lambda expression &lt;em&gt;outside&lt;/em&gt; of the parameter parentheses. If the lambda expression is the only parameter, you can omit the parentheses entirely. This is very useful for &lt;a href=&quot;functional-programming#receivers&quot;&gt;constructing DSLs&lt;/a&gt;.</source>
          <target state="translated">関数の最後のパラメーターの型が関数型であり、ラムダ式を指定する場合は、パラメーターの括弧の&lt;em&gt;外側&lt;/em&gt;にラムダ式を配置できます。ラムダ式が唯一のパラメーターである場合は、括弧を完全に省略できます。これは&lt;a href=&quot;functional-programming#receivers&quot;&gt;DSL&lt;/a&gt;を構築するのに非常に役立ちます。</target>
        </trans-unit>
        <trans-unit id="a6b8f4ffb4740b781007cf6d0bbe0282c0376673" translate="yes" xml:space="preserve">
          <source>If the value doesn't fit in the range of &lt;a href=&quot;../../kotlin/-int/index#kotlin.Int&quot;&gt;Int&lt;/a&gt; type, it is coerced into that range, see the conversion &lt;a href=&quot;../../kotlin/-double/to-int#kotlin.Double%24toInt()&quot;&gt;Double.toInt&lt;/a&gt; for details.</source>
          <target state="translated">値が&lt;a href=&quot;../../kotlin/-int/index#kotlin.Int&quot;&gt;Int&lt;/a&gt;タイプの範囲に収まらない場合は、その範囲に強制変換&lt;a href=&quot;../../kotlin/-double/to-int#kotlin.Double%24toInt()&quot;&gt;さ&lt;/a&gt;れます。詳細については、変換Double.toIntを参照してください。</target>
        </trans-unit>
        <trans-unit id="e29d1de77f34d3695193f07bd125bf5fcf617a87" translate="yes" xml:space="preserve">
          <source>If the value doesn't fit in the range of &lt;a href=&quot;../../kotlin/-long/index#kotlin.Long&quot;&gt;Long&lt;/a&gt; type, it is coerced into that range, see the conversion &lt;a href=&quot;../../kotlin/-double/to-long#kotlin.Double%24toLong()&quot;&gt;Double.toLong&lt;/a&gt; for details.</source>
          <target state="translated">値が&lt;a href=&quot;../../kotlin/-long/index#kotlin.Long&quot;&gt;Long&lt;/a&gt;タイプの範囲に収まらない場合は、その範囲に強制変換&lt;a href=&quot;../../kotlin/-double/to-long#kotlin.Double%24toLong()&quot;&gt;さ&lt;/a&gt;れます。詳細については、変換Double.toLongを参照してください。</target>
        </trans-unit>
        <trans-unit id="d77bf30b739c2514d63ed87849b1332700a2c8b6" translate="yes" xml:space="preserve">
          <source>If the value has a receiver type, the receiver object should be passed as the first argument. Another way to invoke a value of a function type with receiver is to prepend it with the receiver object, as if the value were an &lt;a href=&quot;extensions&quot;&gt;extension function&lt;/a&gt;: &lt;code&gt;1.foo(2)&lt;/code&gt;,</source>
          <target state="translated">値にレシーバータイプがある場合、レシーバーオブジェクトを最初の引数として渡す必要があります。レシーバーで関数タイプの値を呼び出す別の方法は、値が&lt;a href=&quot;extensions&quot;&gt;拡張関数で&lt;/a&gt;あるかのように、レシーバーオブジェクトを付加することです： &lt;code&gt;1.foo(2)&lt;/code&gt; 、</target>
        </trans-unit>
        <trans-unit id="08b10da0a2b6c0dae39cbc760c047dc614066a39" translate="yes" xml:space="preserve">
          <source>If the value of a read-only property is known at the compile time, mark it as a &lt;em&gt;compile time constant&lt;/em&gt; using the &lt;em&gt;const&lt;/em&gt; modifier. Such properties need to fulfil the following requirements:</source>
          <target state="translated">読み取り専用プロパティの値がコンパイル時にわかっている場合は、&lt;em&gt;const&lt;/em&gt;修飾子を使用して&lt;em&gt;コンパイル時定数&lt;/em&gt;としてマークします。このようなプロパティは、次の要件を満たす必要があります。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ec8c7f7b7e4402c0d35a4121dd40caffc8d7c935" translate="yes" xml:space="preserve">
          <source>If the variable has no value for the current thread, it is first initialized to the value returned by an invocation of the &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/lang/ThreadLocal.html#initialValue()&quot;&gt;ThreadLocal.initialValue&lt;/a&gt; method. Then if it is still &lt;code&gt;null&lt;/code&gt;, the provided &lt;a href=&quot;get-or-set#kotlin.concurrent%24getOrSet%28java.lang.ThreadLocal%28%28kotlin.concurrent.getOrSet.T%29%29%2C+kotlin.Function0%28%28kotlin.concurrent.getOrSet.T%29%29%29%2Fdefault&quot;&gt;default&lt;/a&gt; function is called and its result is stored for the current thread and then returned.</source>
          <target state="translated">変数に現在のスレッドの値がない場合は、最初に&lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/lang/ThreadLocal.html#initialValue()&quot;&gt;ThreadLocal.initialValue&lt;/a&gt;メソッドの呼び出しによって返される値に初期化されます。次に、それが &lt;code&gt;null&lt;/code&gt; のままの場合、提供された&lt;a href=&quot;get-or-set#kotlin.concurrent%24getOrSet%28java.lang.ThreadLocal%28%28kotlin.concurrent.getOrSet.T%29%29%2C+kotlin.Function0%28%28kotlin.concurrent.getOrSet.T%29%29%29%2Fdefault&quot;&gt;デフォルト&lt;/a&gt;関数が呼び出され、その結果が現在のスレッドに格納されて返されます。</target>
        </trans-unit>
        <trans-unit id="55d02f7ccfe9e99651ab411f3283f4f1c75cff68" translate="yes" xml:space="preserve">
          <source>If the variable has no value for the current thread, it is first initialized to the value returned by an invocation of the ThreadLocal.initialValue method. Then if it is still &lt;code&gt;null&lt;/code&gt;, the provided &lt;a href=&quot;get-or-set#kotlin.concurrent%24getOrSet(java.lang.ThreadLocal((kotlin.concurrent.getOrSet.T)),%20kotlin.Function0((kotlin.concurrent.getOrSet.T)))/default&quot;&gt;default&lt;/a&gt; function is called and its result is stored for the current thread and then returned.</source>
          <target state="translated">変数に現在のスレッドの値がない場合、最初にThreadLocal.initialValueメソッドの呼び出しによって返される値に初期化されます。それでも &lt;code&gt;null&lt;/code&gt; の場合は、指定された&lt;a href=&quot;get-or-set#kotlin.concurrent%24getOrSet(java.lang.ThreadLocal((kotlin.concurrent.getOrSet.T)),%20kotlin.Function0((kotlin.concurrent.getOrSet.T)))/default&quot;&gt;デフォルト&lt;/a&gt;関数が呼び出され、その結果が現在のスレッドに保存されてから返されます。</target>
        </trans-unit>
        <trans-unit id="3f98dbe730a8c5b27f6e85f63d1bb117f2681dde" translate="yes" xml:space="preserve">
          <source>If there are clients that use your Kotlin interfaces compiled without the new &lt;code&gt;-Xjvm-default=all&lt;/code&gt; option, then they can be incompatible with the same code compiled with this option.</source>
          <target state="translated">新しい &lt;code&gt;-Xjvm-default=all&lt;/code&gt; オプションなしでコンパイルされたKotlinインターフェースを使用するクライアントがある場合、それらはこのオプションでコンパイルされた同じコードと互換性がない可能性があります。</target>
        </trans-unit>
        <trans-unit id="dcc77a995f63cb6e01033f3a55686b845948a61a" translate="yes" xml:space="preserve">
          <source>If there are explicit implementations of &lt;code&gt;equals()&lt;/code&gt;, &lt;code&gt;hashCode()&lt;/code&gt; or &lt;code&gt;toString()&lt;/code&gt; in the data class body or &lt;em&gt;final&lt;/em&gt; implementations in a superclass, then these functions are not generated, and the existing implementations are used;</source>
          <target state="translated">&lt;code&gt;equals()&lt;/code&gt; 、 &lt;code&gt;hashCode()&lt;/code&gt; 、または &lt;code&gt;toString()&lt;/code&gt; の明示的な実装がデータクラス本体にある場合、またはスーパークラスの&lt;em&gt;最終&lt;/em&gt;実装がある場合、これらの関数は生成されず、既存の実装が使用されます。</target>
        </trans-unit>
        <trans-unit id="706d1394b60969b44602412d2be62295a909c4ef" translate="yes" xml:space="preserve">
          <source>If there are multiple equal maximal values, returns the first of them.</source>
          <target state="translated">等しい最大値が複数ある場合は、そのうちの最初の値を返します。</target>
        </trans-unit>
        <trans-unit id="ca6054fd048270c35ac42f250ec06387cb65b331" translate="yes" xml:space="preserve">
          <source>If there are multiple equal minimal values, returns the first of them.</source>
          <target state="translated">複数の等しい最小値がある場合は、そのうちの最初の値を返します。</target>
        </trans-unit>
        <trans-unit id="a22fd4a7c09aa2ff0cda3088cc25dcaf533edd1f" translate="yes" xml:space="preserve">
          <source>If there are no errors during compilation, we should see the result of the execution of our program, which on execution should output the contents of the site &lt;code&gt;http://example.com&lt;/code&gt;</source>
          <target state="translated">コンパイル中にエラーがなければ、プログラムの実行結果が表示されます。実行すると、サイト &lt;code&gt;http://example.com&lt;/code&gt; のコンテンツが出力されます。</target>
        </trans-unit>
        <trans-unit id="9edcba1fdea56091b72b70d9544284be2a9b118c" translate="yes" xml:space="preserve">
          <source>If there is a name clash, we can disambiguate by using &lt;em&gt;as&lt;/em&gt; keyword to locally rename the clashing entity:</source>
          <target state="translated">名前の競合がある場合は、キーワード&lt;em&gt;としてas&lt;/em&gt;を使用&lt;em&gt;し&lt;/em&gt;て競合するエンティティの名前をローカルで変更することにより、曖昧さをなくすことができます。</target>
        </trans-unit>
        <trans-unit id="b4b2b7e97af6db9e9aed9e5719f03ea30bf0227c" translate="yes" xml:space="preserve">
          <source>If there is a naming conflict, you should usually import just one of the symbols and fully qualify the usages of the other. If both are heavily used, you can rename the symbol at import time:</source>
          <target state="translated">命名の競合がある場合は、通常はどちらか一方のシンボルだけをインポートして、もう一方のシンボルの使用法を完全に確認する必要があります。両方が多用されている場合は、インポート時にシンボルの名前を変更することができます。</target>
        </trans-unit>
        <trans-unit id="a65b66d3772f31ab93bac26e3026245f1a24b319" translate="yes" xml:space="preserve">
          <source>If there's no nice way around it, and you need to take special actions based on what type something is or to access functions/properties that only exist on some classes, you can use &lt;code&gt;is&lt;/code&gt; to check if the real type of an object is a particular class or a subclass thereof (or an implementor of an interface). When this is used as the condition in an &lt;code&gt;if&lt;/code&gt;, the compiler will let you perform type-specific operations on the object inside the &lt;code&gt;if&lt;/code&gt; body:</source>
          <target state="translated">それを回避する良い方法がなく、何かが何かのタイプに基づいて特別なアクションを実行する必要がある場合、または一部のクラスにのみ存在する関数/プロパティにアクセスする必要がある場合 &lt;code&gt;is&lt;/code&gt; 、オブジェクトの実際のタイプが特定であるかどうかを確認することができますクラスまたはそのサブクラス（またはインターフェースのインプリメンター）。これを &lt;code&gt;if&lt;/code&gt; の条件として使用すると、コンパイラーは &lt;code&gt;if&lt;/code&gt; 本体内のオブジェクトに対して型固有の操作を実行できます。</target>
        </trans-unit>
        <trans-unit id="c2cd9a7ecd8b049bc616a7923c1daf215620a583" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;depth&lt;/code&gt; function is called for a &lt;code&gt;deepTree&lt;/code&gt; it produces StackOverflowError because of deep recursion. However, the &lt;code&gt;depth&lt;/code&gt; function can be rewritten using &lt;code&gt;DeepRecursiveFunction&lt;/code&gt; in the following way, and then it successfully computes &lt;a href=&quot;../invoke&quot;&gt;&lt;code&gt;depth(deepTree)&lt;/code&gt;&lt;/a&gt; expression:</source>
          <target state="translated">この &lt;code&gt;depth&lt;/code&gt; 関数が &lt;code&gt;deepTree&lt;/code&gt; に対して呼び出されると、深い再帰のためにStackOverflowErrorが生成されます。ただし、 &lt;code&gt;depth&lt;/code&gt; 関数は、 &lt;code&gt;DeepRecursiveFunction&lt;/code&gt; を使用して次のように書き直すことができ、その後、&lt;a href=&quot;../invoke&quot;&gt; &lt;code&gt;depth(deepTree)&lt;/code&gt; &lt;/a&gt;式を正常に計算します。</target>
        </trans-unit>
        <trans-unit id="83d0b5382998741d7aeea7ea3925f51e48120ef6" translate="yes" xml:space="preserve">
          <source>If this char sequence ends with the given &lt;a href=&quot;../../kotlin.text/remove-suffix#kotlin.text%24removeSuffix%28kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fsuffix&quot;&gt;suffix&lt;/a&gt;, returns a new char sequence with the suffix removed. Otherwise, returns a new char sequence with the same characters.</source>
          <target state="translated">この文字シーケンスが指定された&lt;a href=&quot;../../kotlin.text/remove-suffix#kotlin.text%24removeSuffix%28kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fsuffix&quot;&gt;suffix&lt;/a&gt;で終わる場合は、接尾辞を削除した新しい文字シーケンスを返します。それ以外の場合は、同じ文字を含む新しい文字シーケンスを返します。</target>
        </trans-unit>
        <trans-unit id="2980e3e7312daa7fe514fbd075be82c6980d9ab3" translate="yes" xml:space="preserve">
          <source>If this char sequence ends with the given &lt;a href=&quot;../../kotlin.text/remove-suffix#kotlin.text%24removeSuffix(kotlin.CharSequence,%20kotlin.CharSequence)/suffix&quot;&gt;suffix&lt;/a&gt;, returns a new char sequence with the suffix removed. Otherwise, returns a new char sequence with the same characters.</source>
          <target state="translated">このcharシーケンスが指定された&lt;a href=&quot;../../kotlin.text/remove-suffix#kotlin.text%24removeSuffix(kotlin.CharSequence,%20kotlin.CharSequence)/suffix&quot;&gt;サフィックス&lt;/a&gt;で終わる場合、サフィックスが削除された新しいcharシーケンスを返します。それ以外の場合は、同じ文字の新しいcharシーケンスを返します。</target>
        </trans-unit>
        <trans-unit id="1f68e5f9283a11982ac4d9ee4f72f23e35be2e15" translate="yes" xml:space="preserve">
          <source>If this char sequence ends with the given &lt;a href=&quot;../remove-suffix#kotlin.text%24removeSuffix%28kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fsuffix&quot;&gt;suffix&lt;/a&gt;, returns a new char sequence with the suffix removed. Otherwise, returns a new char sequence with the same characters.</source>
          <target state="translated">この文字シーケンスが指定された&lt;a href=&quot;../remove-suffix#kotlin.text%24removeSuffix%28kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fsuffix&quot;&gt;suffix&lt;/a&gt;で終わる場合は、接尾辞を削除した新しい文字シーケンスを返します。それ以外の場合は、同じ文字を含む新しい文字シーケンスを返します。</target>
        </trans-unit>
        <trans-unit id="a30b2abbbd6e4e6955f1d30edef72f53b5797930" translate="yes" xml:space="preserve">
          <source>If this char sequence ends with the given &lt;a href=&quot;../remove-suffix#kotlin.text%24removeSuffix(kotlin.CharSequence,%20kotlin.CharSequence)/suffix&quot;&gt;suffix&lt;/a&gt;, returns a new char sequence with the suffix removed. Otherwise, returns a new char sequence with the same characters.</source>
          <target state="translated">このcharシーケンスが指定された&lt;a href=&quot;../remove-suffix#kotlin.text%24removeSuffix(kotlin.CharSequence,%20kotlin.CharSequence)/suffix&quot;&gt;サフィックス&lt;/a&gt;で終わる場合、サフィックスが削除された新しいcharシーケンスを返します。それ以外の場合は、同じ文字の新しいcharシーケンスを返します。</target>
        </trans-unit>
        <trans-unit id="f1d9aa147865687623fa05e3a2703d76d90d9924" translate="yes" xml:space="preserve">
          <source>If this char sequence ends with the given &lt;a href=&quot;remove-suffix#kotlin.text%24removeSuffix%28kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fsuffix&quot;&gt;suffix&lt;/a&gt;, returns a new char sequence with the suffix removed. Otherwise, returns a new char sequence with the same characters.</source>
          <target state="translated">この文字シーケンスが指定された&lt;a href=&quot;remove-suffix#kotlin.text%24removeSuffix%28kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fsuffix&quot;&gt;suffix&lt;/a&gt;で終わる場合は、接尾辞を削除した新しい文字シーケンスを返します。それ以外の場合は、同じ文字を含む新しい文字シーケンスを返します。</target>
        </trans-unit>
        <trans-unit id="066696f2f807a663e1d7eba4412c839322bfaa9e" translate="yes" xml:space="preserve">
          <source>If this char sequence ends with the given &lt;a href=&quot;remove-suffix#kotlin.text%24removeSuffix(kotlin.CharSequence,%20kotlin.CharSequence)/suffix&quot;&gt;suffix&lt;/a&gt;, returns a new char sequence with the suffix removed. Otherwise, returns a new char sequence with the same characters.</source>
          <target state="translated">このcharシーケンスが指定された&lt;a href=&quot;remove-suffix#kotlin.text%24removeSuffix(kotlin.CharSequence,%20kotlin.CharSequence)/suffix&quot;&gt;サフィックス&lt;/a&gt;で終わる場合、サフィックスが削除された新しいcharシーケンスを返します。それ以外の場合は、同じ文字の新しいcharシーケンスを返します。</target>
        </trans-unit>
        <trans-unit id="393978ca2e4989e43b2a725707449d745979c2c2" translate="yes" xml:space="preserve">
          <source>If this char sequence starts with the given &lt;a href=&quot;../../kotlin.text/remove-prefix#kotlin.text%24removePrefix%28kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fprefix&quot;&gt;prefix&lt;/a&gt;, returns a new char sequence with the prefix removed. Otherwise, returns a new char sequence with the same characters.</source>
          <target state="translated">この文字シーケンスが指定された&lt;a href=&quot;../../kotlin.text/remove-prefix#kotlin.text%24removePrefix%28kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fprefix&quot;&gt;プレフィックス&lt;/a&gt;で始まる場合、プレフィックスを削除した新しい文字シーケンスを返します。それ以外の場合は、同じ文字を含む新しい文字シーケンスを返します。</target>
        </trans-unit>
        <trans-unit id="fbd91d26d2ddcfad42a009559f504981281599d6" translate="yes" xml:space="preserve">
          <source>If this char sequence starts with the given &lt;a href=&quot;../../kotlin.text/remove-prefix#kotlin.text%24removePrefix(kotlin.CharSequence,%20kotlin.CharSequence)/prefix&quot;&gt;prefix&lt;/a&gt;, returns a new char sequence with the prefix removed. Otherwise, returns a new char sequence with the same characters.</source>
          <target state="translated">このcharシーケンスが指定された&lt;a href=&quot;../../kotlin.text/remove-prefix#kotlin.text%24removePrefix(kotlin.CharSequence,%20kotlin.CharSequence)/prefix&quot;&gt;プレフィックス&lt;/a&gt;で始まる場合、プレフィックスが削除された新しいcharシーケンスを返します。それ以外の場合は、同じ文字の新しいcharシーケンスを返します。</target>
        </trans-unit>
        <trans-unit id="c4551b66808b7a93bcbea0cb98dbc6cf03713996" translate="yes" xml:space="preserve">
          <source>If this char sequence starts with the given &lt;a href=&quot;../remove-prefix#kotlin.text%24removePrefix%28kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fprefix&quot;&gt;prefix&lt;/a&gt;, returns a new char sequence with the prefix removed. Otherwise, returns a new char sequence with the same characters.</source>
          <target state="translated">この文字シーケンスが指定された&lt;a href=&quot;../remove-prefix#kotlin.text%24removePrefix%28kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fprefix&quot;&gt;プレフィックス&lt;/a&gt;で始まる場合、プレフィックスを削除した新しい文字シーケンスを返します。それ以外の場合は、同じ文字を含む新しい文字シーケンスを返します。</target>
        </trans-unit>
        <trans-unit id="e1cdbb98160c7143e8a1010edb16577923755a13" translate="yes" xml:space="preserve">
          <source>If this char sequence starts with the given &lt;a href=&quot;../remove-prefix#kotlin.text%24removePrefix(kotlin.CharSequence,%20kotlin.CharSequence)/prefix&quot;&gt;prefix&lt;/a&gt;, returns a new char sequence with the prefix removed. Otherwise, returns a new char sequence with the same characters.</source>
          <target state="translated">このcharシーケンスが指定された&lt;a href=&quot;../remove-prefix#kotlin.text%24removePrefix(kotlin.CharSequence,%20kotlin.CharSequence)/prefix&quot;&gt;プレフィックス&lt;/a&gt;で始まる場合、プレフィックスが削除された新しいcharシーケンスを返します。それ以外の場合は、同じ文字の新しいcharシーケンスを返します。</target>
        </trans-unit>
        <trans-unit id="e5eb3f5440c96a359b2e662128e4b4a2fe2e0c6d" translate="yes" xml:space="preserve">
          <source>If this char sequence starts with the given &lt;a href=&quot;remove-prefix#kotlin.text%24removePrefix%28kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fprefix&quot;&gt;prefix&lt;/a&gt;, returns a new char sequence with the prefix removed. Otherwise, returns a new char sequence with the same characters.</source>
          <target state="translated">この文字シーケンスが指定された&lt;a href=&quot;remove-prefix#kotlin.text%24removePrefix%28kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fprefix&quot;&gt;プレフィックス&lt;/a&gt;で始まる場合、プレフィックスを削除した新しい文字シーケンスを返します。それ以外の場合は、同じ文字を含む新しい文字シーケンスを返します。</target>
        </trans-unit>
        <trans-unit id="18964490a2097748cf26c9bc99dc2e1219bd1083" translate="yes" xml:space="preserve">
          <source>If this char sequence starts with the given &lt;a href=&quot;remove-prefix#kotlin.text%24removePrefix(kotlin.CharSequence,%20kotlin.CharSequence)/prefix&quot;&gt;prefix&lt;/a&gt;, returns a new char sequence with the prefix removed. Otherwise, returns a new char sequence with the same characters.</source>
          <target state="translated">このcharシーケンスが指定された&lt;a href=&quot;remove-prefix#kotlin.text%24removePrefix(kotlin.CharSequence,%20kotlin.CharSequence)/prefix&quot;&gt;プレフィックス&lt;/a&gt;で始まる場合、プレフィックスが削除された新しいcharシーケンスを返します。それ以外の場合は、同じ文字の新しいcharシーケンスを返します。</target>
        </trans-unit>
        <trans-unit id="e50b89219e8ed48483bbf130e9adaab263424db1" translate="yes" xml:space="preserve">
          <source>If this file is a directory, it is copied without its content, i.e. an empty &lt;a href=&quot;copy-to#kotlin.io%24copyTo%28java.io.File%2C+java.io.File%2C+kotlin.Boolean%2C+kotlin.Int%29%2Ftarget&quot;&gt;target&lt;/a&gt; directory is created. If you want to copy directory including its contents, use &lt;a href=&quot;copy-recursively&quot;&gt;copyRecursively&lt;/a&gt;.</source>
          <target state="translated">このファイルがディレクトリの場合、その内容なしでコピーされます。つまり、空の&lt;a href=&quot;copy-to#kotlin.io%24copyTo%28java.io.File%2C+java.io.File%2C+kotlin.Boolean%2C+kotlin.Int%29%2Ftarget&quot;&gt;ターゲット&lt;/a&gt;ディレクトリが作成されます。内容を含めてディレクトリをコピーする場合は、&lt;a href=&quot;copy-recursively&quot;&gt;copyRecursivelyを&lt;/a&gt;使用します。</target>
        </trans-unit>
        <trans-unit id="794fbb14ba44c0a10efb47ff1391acfc97fac0ad" translate="yes" xml:space="preserve">
          <source>If this file is a directory, it is copied without its content, i.e. an empty &lt;a href=&quot;copy-to#kotlin.io%24copyTo(java.io.File,%20java.io.File,%20kotlin.Boolean,%20kotlin.Int)/target&quot;&gt;target&lt;/a&gt; directory is created. If you want to copy directory including its contents, use &lt;a href=&quot;copy-recursively&quot;&gt;copyRecursively&lt;/a&gt;.</source>
          <target state="translated">このファイルがディレクトリの場合、コンテンツなしでコピーされます。つまり、空の&lt;a href=&quot;copy-to#kotlin.io%24copyTo(java.io.File,%20java.io.File,%20kotlin.Boolean,%20kotlin.Int)/target&quot;&gt;ターゲット&lt;/a&gt;ディレクトリが作成されます。その内容を含むディレクトリをコピーする場合は、&lt;a href=&quot;copy-recursively&quot;&gt;copyRecursivelyを&lt;/a&gt;使用します。</target>
        </trans-unit>
        <trans-unit id="696bc35b6b7c9124fdae8a289c38873049e01372" translate="yes" xml:space="preserve">
          <source>If this file path points to a single file, then it will be copied to a file with the path &lt;a href=&quot;copy-recursively#kotlin.io%24copyRecursively%28java.io.File%2C+java.io.File%2C+kotlin.Boolean%2C+kotlin.Function2%28%28java.io.File%2C+java.io.IOException%2C+kotlin.io.OnErrorAction%29%29%29%2Ftarget&quot;&gt;target&lt;/a&gt;. If this file path points to a directory, then its children will be copied to a directory with the path &lt;a href=&quot;copy-recursively#kotlin.io%24copyRecursively%28java.io.File%2C+java.io.File%2C+kotlin.Boolean%2C+kotlin.Function2%28%28java.io.File%2C+java.io.IOException%2C+kotlin.io.OnErrorAction%29%29%29%2Ftarget&quot;&gt;target&lt;/a&gt;.</source>
          <target state="translated">このファイルパスが単一のファイルを指している場合は、パスが&lt;a href=&quot;copy-recursively#kotlin.io%24copyRecursively%28java.io.File%2C+java.io.File%2C+kotlin.Boolean%2C+kotlin.Function2%28%28java.io.File%2C+java.io.IOException%2C+kotlin.io.OnErrorAction%29%29%29%2Ftarget&quot;&gt;targetの&lt;/a&gt;ファイルにコピーされます。このファイルパスがディレクトリを指している場合、その子はパス&lt;a href=&quot;copy-recursively#kotlin.io%24copyRecursively%28java.io.File%2C+java.io.File%2C+kotlin.Boolean%2C+kotlin.Function2%28%28java.io.File%2C+java.io.IOException%2C+kotlin.io.OnErrorAction%29%29%29%2Ftarget&quot;&gt;target&lt;/a&gt;を持つディレクトリにコピーされます。</target>
        </trans-unit>
        <trans-unit id="f19f7f0e9647874289c7ec01aa0daf1c28a6e17f" translate="yes" xml:space="preserve">
          <source>If this file path points to a single file, then it will be copied to a file with the path &lt;a href=&quot;copy-recursively#kotlin.io%24copyRecursively(java.io.File,%20java.io.File,%20kotlin.Boolean,%20kotlin.Function2((java.io.File,%20java.io.IOException,%20kotlin.io.OnErrorAction)))/target&quot;&gt;target&lt;/a&gt;. If this file path points to a directory, then its children will be copied to a directory with the path &lt;a href=&quot;copy-recursively#kotlin.io%24copyRecursively(java.io.File,%20java.io.File,%20kotlin.Boolean,%20kotlin.Function2((java.io.File,%20java.io.IOException,%20kotlin.io.OnErrorAction)))/target&quot;&gt;target&lt;/a&gt;.</source>
          <target state="translated">このファイルパスが単一のファイルを指している場合は、パス&lt;a href=&quot;copy-recursively#kotlin.io%24copyRecursively(java.io.File,%20java.io.File,%20kotlin.Boolean,%20kotlin.Function2((java.io.File,%20java.io.IOException,%20kotlin.io.OnErrorAction)))/target&quot;&gt;ターゲット&lt;/a&gt;を持つファイルにコピーされます。このファイルパスがディレクトリを指している場合、その子はパス&lt;a href=&quot;copy-recursively#kotlin.io%24copyRecursively(java.io.File,%20java.io.File,%20kotlin.Boolean,%20kotlin.Function2((java.io.File,%20java.io.IOException,%20kotlin.io.OnErrorAction)))/target&quot;&gt;ターゲットの&lt;/a&gt;あるディレクトリにコピーされます。</target>
        </trans-unit>
        <trans-unit id="822fa875865380bffd3780f735dc7821bbfbc1dd" translate="yes" xml:space="preserve">
          <source>If this function is invoked on other &lt;a href=&quot;../kotlin.coroutines/-continuation/index&quot;&gt;Continuation&lt;/a&gt; instances it returns &lt;code&gt;this&lt;/code&gt; continuation unchanged.</source>
          <target state="translated">この関数が他の&lt;a href=&quot;../kotlin.coroutines/-continuation/index&quot;&gt;継続&lt;/a&gt;インスタンスで呼び出された場合、 &lt;code&gt;this&lt;/code&gt; 継続を変更せずに返します。</target>
        </trans-unit>
        <trans-unit id="000d49e516219b57649db3a4add8aedc933ac12a" translate="yes" xml:space="preserve">
          <source>If this is the first time you're adding a Kotlin file to this project, IntelliJ IDEA will prompt you to add the required Kotlin runtime. For a Java project, configure the Kotlin runtime as a &lt;strong&gt;Kotlin Java Module&lt;/strong&gt;.</source>
          <target state="translated">このプロジェクトにKotlinファイルを初めて追加する場合は、IntelliJ IDEAから必要なKotlinランタイムを追加するように求められます。Javaプロジェクトの場合、Kotlinランタイムを&lt;strong&gt;Kotlin Javaモジュール&lt;/strong&gt;として構成します。</target>
        </trans-unit>
        <trans-unit id="5452ff7f47b8e841bbf674d6743480276ef5195d" translate="yes" xml:space="preserve">
          <source>If this list doesn&amp;rsquo;t cover your needs, you can find more options in the &lt;a href=&quot;https://github.com/thomasnield/kotlin-data-science-resources&quot;&gt;&lt;strong&gt;Kotlin Data Science Resources&lt;/strong&gt;&lt;/a&gt; digest from Thomas Nield.</source>
          <target state="translated">このリストは、あなたのニーズをカバーしていない場合は、でより多くのオプションを見つけることができます&lt;a href=&quot;https://github.com/thomasnield/kotlin-data-science-resources&quot;&gt;&lt;strong&gt;Kotlinデータ・サイエンス・リソース&lt;/strong&gt;&lt;/a&gt;・トーマスNieldからダイジェストを。</target>
        </trans-unit>
        <trans-unit id="8ef8c14fd9985248743a7603b2080574686a18ae" translate="yes" xml:space="preserve">
          <source>If this reference is &lt;a href=&quot;../-c-pointer/index&quot;&gt;CPointer&lt;/a&gt;, returns this pointer, otherwise allocate storage value in the scope and return it.</source>
          <target state="translated">この参照が&lt;a href=&quot;../-c-pointer/index&quot;&gt;CPointerの&lt;/a&gt;場合、このポインターを返します。それ以外の場合は、スコープにストレージ値を割り当てて返します。</target>
        </trans-unit>
        <trans-unit id="b3b7f842b5ea81c3f4b90a34bcfe922201e07ced" translate="yes" xml:space="preserve">
          <source>If this reference is &lt;a href=&quot;index&quot;&gt;CPointer&lt;/a&gt;, returns this pointer, otherwise allocate storage value in the scope and return it.</source>
          <target state="translated">この参照が&lt;a href=&quot;index&quot;&gt;CPointerの&lt;/a&gt;場合、このポインターを返します。それ以外の場合は、スコープにストレージ値を割り当てて返します。</target>
        </trans-unit>
        <trans-unit id="daa765d4ed09a47719a46eaa22921d3d6383a5b1" translate="yes" xml:space="preserve">
          <source>If this string ends with the given &lt;a href=&quot;../../kotlin.text/remove-suffix#kotlin.text%24removeSuffix%28kotlin.String%2C+kotlin.CharSequence%29%2Fsuffix&quot;&gt;suffix&lt;/a&gt;, returns a copy of this string with the suffix removed. Otherwise, returns this string.</source>
          <target state="translated">この文字列が指定された&lt;a href=&quot;../../kotlin.text/remove-suffix#kotlin.text%24removeSuffix%28kotlin.String%2C+kotlin.CharSequence%29%2Fsuffix&quot;&gt;suffix&lt;/a&gt;で終わる場合、この文字列のコピーを、サフィックスを削除して返します。それ以外の場合は、この文字列を返します。</target>
        </trans-unit>
        <trans-unit id="d7dc1cbcb6a32aa88b8d844adc9e841c43d6e6b8" translate="yes" xml:space="preserve">
          <source>If this string ends with the given &lt;a href=&quot;../../kotlin.text/remove-suffix#kotlin.text%24removeSuffix(kotlin.String,%20kotlin.CharSequence)/suffix&quot;&gt;suffix&lt;/a&gt;, returns a copy of this string with the suffix removed. Otherwise, returns this string.</source>
          <target state="translated">この文字列が指定された&lt;a href=&quot;../../kotlin.text/remove-suffix#kotlin.text%24removeSuffix(kotlin.String,%20kotlin.CharSequence)/suffix&quot;&gt;サフィックス&lt;/a&gt;で終わる場合、サフィックスが削除されたこの文字列のコピーを返します。それ以外の場合は、この文字列を返します。</target>
        </trans-unit>
        <trans-unit id="fe146357dbe5d233f80385c4622bdabdf282c2ff" translate="yes" xml:space="preserve">
          <source>If this string ends with the given &lt;a href=&quot;remove-suffix#kotlin.text%24removeSuffix%28kotlin.String%2C+kotlin.CharSequence%29%2Fsuffix&quot;&gt;suffix&lt;/a&gt;, returns a copy of this string with the suffix removed. Otherwise, returns this string.</source>
          <target state="translated">この文字列が指定された&lt;a href=&quot;remove-suffix#kotlin.text%24removeSuffix%28kotlin.String%2C+kotlin.CharSequence%29%2Fsuffix&quot;&gt;suffix&lt;/a&gt;で終わる場合、この文字列のコピーを、サフィックスを削除して返します。それ以外の場合は、この文字列を返します。</target>
        </trans-unit>
        <trans-unit id="709bfa613cc84c58d0e77dbf11164343f90ebae6" translate="yes" xml:space="preserve">
          <source>If this string ends with the given &lt;a href=&quot;remove-suffix#kotlin.text%24removeSuffix(kotlin.String,%20kotlin.CharSequence)/suffix&quot;&gt;suffix&lt;/a&gt;, returns a copy of this string with the suffix removed. Otherwise, returns this string.</source>
          <target state="translated">この文字列が指定された&lt;a href=&quot;remove-suffix#kotlin.text%24removeSuffix(kotlin.String,%20kotlin.CharSequence)/suffix&quot;&gt;サフィックス&lt;/a&gt;で終わる場合、サフィックスが削除されたこの文字列のコピーを返します。それ以外の場合は、この文字列を返します。</target>
        </trans-unit>
        <trans-unit id="eef5abc7cbd0224a64b4e2e54624e8e1396be8a5" translate="yes" xml:space="preserve">
          <source>If this string starts with the given &lt;a href=&quot;../../kotlin.text/remove-prefix#kotlin.text%24removePrefix%28kotlin.String%2C+kotlin.CharSequence%29%2Fprefix&quot;&gt;prefix&lt;/a&gt;, returns a copy of this string with the prefix removed. Otherwise, returns this string.</source>
          <target state="translated">この文字列が指定された&lt;a href=&quot;../../kotlin.text/remove-prefix#kotlin.text%24removePrefix%28kotlin.String%2C+kotlin.CharSequence%29%2Fprefix&quot;&gt;prefix&lt;/a&gt;で始まる場合、接頭辞を削除したこの文字列のコピーを返します。それ以外の場合は、この文字列を返します。</target>
        </trans-unit>
        <trans-unit id="92c6be29a5671e41239ef25ada1ea6fe1003a0b7" translate="yes" xml:space="preserve">
          <source>If this string starts with the given &lt;a href=&quot;../../kotlin.text/remove-prefix#kotlin.text%24removePrefix(kotlin.String,%20kotlin.CharSequence)/prefix&quot;&gt;prefix&lt;/a&gt;, returns a copy of this string with the prefix removed. Otherwise, returns this string.</source>
          <target state="translated">この文字列が指定された&lt;a href=&quot;../../kotlin.text/remove-prefix#kotlin.text%24removePrefix(kotlin.String,%20kotlin.CharSequence)/prefix&quot;&gt;プレフィックス&lt;/a&gt;で始まる場合、プレフィックスが削除されたこの文字列のコピーを返します。それ以外の場合は、この文字列を返します。</target>
        </trans-unit>
        <trans-unit id="9adf224f013e9757a5b20a24dd0cebbc9d578cc5" translate="yes" xml:space="preserve">
          <source>If this string starts with the given &lt;a href=&quot;remove-prefix#kotlin.text%24removePrefix%28kotlin.String%2C+kotlin.CharSequence%29%2Fprefix&quot;&gt;prefix&lt;/a&gt;, returns a copy of this string with the prefix removed. Otherwise, returns this string.</source>
          <target state="translated">この文字列が指定された&lt;a href=&quot;remove-prefix#kotlin.text%24removePrefix%28kotlin.String%2C+kotlin.CharSequence%29%2Fprefix&quot;&gt;prefix&lt;/a&gt;で始まる場合、接頭辞を削除したこの文字列のコピーを返します。それ以外の場合は、この文字列を返します。</target>
        </trans-unit>
        <trans-unit id="1e98d4d193636df70b1b850a20d5da773ecb938f" translate="yes" xml:space="preserve">
          <source>If this string starts with the given &lt;a href=&quot;remove-prefix#kotlin.text%24removePrefix(kotlin.String,%20kotlin.CharSequence)/prefix&quot;&gt;prefix&lt;/a&gt;, returns a copy of this string with the prefix removed. Otherwise, returns this string.</source>
          <target state="translated">この文字列が指定された&lt;a href=&quot;remove-prefix#kotlin.text%24removePrefix(kotlin.String,%20kotlin.CharSequence)/prefix&quot;&gt;プレフィックス&lt;/a&gt;で始まる場合、プレフィックスが削除されたこの文字列のコピーを返します。それ以外の場合は、この文字列を返します。</target>
        </trans-unit>
        <trans-unit id="eaa08b32eac3b33ecf492f621bff941ea4a9fcd4" translate="yes" xml:space="preserve">
          <source>If this value is in &lt;a href=&quot;../-byte/-m-i-n_-v-a-l-u-e#kotlin.Byte.Companion%24MIN_VALUE&quot;&gt;Byte.MIN_VALUE&lt;/a&gt;..&lt;a href=&quot;../-byte/-m-a-x_-v-a-l-u-e#kotlin.Byte.Companion%24MAX_VALUE&quot;&gt;Byte.MAX_VALUE&lt;/a&gt;, the resulting &lt;code&gt;Byte&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Int&lt;/code&gt;.</source>
          <target state="translated">この値が&lt;a href=&quot;../-byte/-m-i-n_-v-a-l-u-e#kotlin.Byte.Companion%24MIN_VALUE&quot;&gt;Byte.MIN_VALUE&lt;/a&gt; .. &lt;a href=&quot;../-byte/-m-a-x_-v-a-l-u-e#kotlin.Byte.Companion%24MAX_VALUE&quot;&gt;Byte.MAX_VALUEにある&lt;/a&gt;場合、結果の &lt;code&gt;Byte&lt;/code&gt; 値はこの &lt;code&gt;Int&lt;/code&gt; と同じ数値を表します。</target>
        </trans-unit>
        <trans-unit id="fc02da33b8b0ff318b09d189a23b770163982e91" translate="yes" xml:space="preserve">
          <source>If this value is in &lt;a href=&quot;../-byte/-m-i-n_-v-a-l-u-e#kotlin.Byte.Companion%24MIN_VALUE&quot;&gt;Byte.MIN_VALUE&lt;/a&gt;..&lt;a href=&quot;../-byte/-m-a-x_-v-a-l-u-e#kotlin.Byte.Companion%24MAX_VALUE&quot;&gt;Byte.MAX_VALUE&lt;/a&gt;, the resulting &lt;code&gt;Byte&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Long&lt;/code&gt;.</source>
          <target state="translated">この値が&lt;a href=&quot;../-byte/-m-i-n_-v-a-l-u-e#kotlin.Byte.Companion%24MIN_VALUE&quot;&gt;Byte.MIN_VALUE&lt;/a&gt; .. &lt;a href=&quot;../-byte/-m-a-x_-v-a-l-u-e#kotlin.Byte.Companion%24MAX_VALUE&quot;&gt;Byte.MAX_VALUEにある&lt;/a&gt;場合、結果の &lt;code&gt;Byte&lt;/code&gt; 値はこの &lt;code&gt;Long&lt;/code&gt; と同じ数値を表します。</target>
        </trans-unit>
        <trans-unit id="490305470096f372ac8119db4e004b84e91a7481" translate="yes" xml:space="preserve">
          <source>If this value is in &lt;a href=&quot;../-byte/-m-i-n_-v-a-l-u-e#kotlin.Byte.Companion%24MIN_VALUE&quot;&gt;Byte.MIN_VALUE&lt;/a&gt;..&lt;a href=&quot;../-byte/-m-a-x_-v-a-l-u-e#kotlin.Byte.Companion%24MAX_VALUE&quot;&gt;Byte.MAX_VALUE&lt;/a&gt;, the resulting &lt;code&gt;Byte&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Short&lt;/code&gt;.</source>
          <target state="translated">この値が&lt;a href=&quot;../-byte/-m-i-n_-v-a-l-u-e#kotlin.Byte.Companion%24MIN_VALUE&quot;&gt;Byte.MIN_VALUE&lt;/a&gt; .. &lt;a href=&quot;../-byte/-m-a-x_-v-a-l-u-e#kotlin.Byte.Companion%24MAX_VALUE&quot;&gt;Byte.MAX_VALUEにある&lt;/a&gt;場合、結果の &lt;code&gt;Byte&lt;/code&gt; 値はこの &lt;code&gt;Short&lt;/code&gt; と同じ数値を表します。</target>
        </trans-unit>
        <trans-unit id="f92846150c40dce3860615a8d63e6d463453288e" translate="yes" xml:space="preserve">
          <source>If this value is in &lt;a href=&quot;../-int/-m-i-n_-v-a-l-u-e#kotlin.Int.Companion%24MIN_VALUE&quot;&gt;Int.MIN_VALUE&lt;/a&gt;..&lt;a href=&quot;../-int/-m-a-x_-v-a-l-u-e#kotlin.Int.Companion%24MAX_VALUE&quot;&gt;Int.MAX_VALUE&lt;/a&gt;, the resulting &lt;code&gt;Int&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Long&lt;/code&gt;.</source>
          <target state="translated">この値が&lt;a href=&quot;../-int/-m-i-n_-v-a-l-u-e#kotlin.Int.Companion%24MIN_VALUE&quot;&gt;Int.MIN_VALUE&lt;/a&gt; .. &lt;a href=&quot;../-int/-m-a-x_-v-a-l-u-e#kotlin.Int.Companion%24MAX_VALUE&quot;&gt;Int.MAX_VALUEにある&lt;/a&gt;場合、結果の &lt;code&gt;Int&lt;/code&gt; 値はこの &lt;code&gt;Long&lt;/code&gt; と同じ数値を表します。</target>
        </trans-unit>
        <trans-unit id="6a741800a8dda50919fa61b7fa403325e77f2e0d" translate="yes" xml:space="preserve">
          <source>If this value is in &lt;a href=&quot;../-short/-m-i-n_-v-a-l-u-e#kotlin.Short.Companion%24MIN_VALUE&quot;&gt;Short.MIN_VALUE&lt;/a&gt;..&lt;a href=&quot;../-short/-m-a-x_-v-a-l-u-e#kotlin.Short.Companion%24MAX_VALUE&quot;&gt;Short.MAX_VALUE&lt;/a&gt;, the resulting &lt;code&gt;Short&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Int&lt;/code&gt;.</source>
          <target state="translated">この値が&lt;a href=&quot;../-short/-m-i-n_-v-a-l-u-e#kotlin.Short.Companion%24MIN_VALUE&quot;&gt;Short.MIN_VALUE&lt;/a&gt; .. &lt;a href=&quot;../-short/-m-a-x_-v-a-l-u-e#kotlin.Short.Companion%24MAX_VALUE&quot;&gt;Short.MAX_VALUEにある&lt;/a&gt;場合、結果の &lt;code&gt;Short&lt;/code&gt; 値はこの &lt;code&gt;Int&lt;/code&gt; と同じ数値を表します。</target>
        </trans-unit>
        <trans-unit id="005b91e001ae975c4aa32f3aea7b1ec2812c965b" translate="yes" xml:space="preserve">
          <source>If this value is in &lt;a href=&quot;../-short/-m-i-n_-v-a-l-u-e#kotlin.Short.Companion%24MIN_VALUE&quot;&gt;Short.MIN_VALUE&lt;/a&gt;..&lt;a href=&quot;../-short/-m-a-x_-v-a-l-u-e#kotlin.Short.Companion%24MAX_VALUE&quot;&gt;Short.MAX_VALUE&lt;/a&gt;, the resulting &lt;code&gt;Short&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Long&lt;/code&gt;.</source>
          <target state="translated">この値が&lt;a href=&quot;../-short/-m-i-n_-v-a-l-u-e#kotlin.Short.Companion%24MIN_VALUE&quot;&gt;Short.MIN_VALUE&lt;/a&gt; .. &lt;a href=&quot;../-short/-m-a-x_-v-a-l-u-e#kotlin.Short.Companion%24MAX_VALUE&quot;&gt;Short.MAX_VALUEにある&lt;/a&gt;場合、結果の &lt;code&gt;Short&lt;/code&gt; 値はこの &lt;code&gt;Long&lt;/code&gt; と同じ数値を表します。</target>
        </trans-unit>
        <trans-unit id="db0284f249225c9c93443ff06ef1c4250bc05e17" translate="yes" xml:space="preserve">
          <source>If this value is in the range of &lt;code&gt;Char&lt;/code&gt; codes &lt;code&gt;Char.MIN_VALUE..Char.MAX_VALUE&lt;/code&gt;, the resulting &lt;code&gt;Char&lt;/code&gt; code is equal to this value.</source>
          <target state="translated">この値が &lt;code&gt;Char&lt;/code&gt; コード &lt;code&gt;Char.MIN_VALUE..Char.MAX_VALUE&lt;/code&gt; の範囲内にある場合、結果の &lt;code&gt;Char&lt;/code&gt; コードはこの値と等しくなります。</target>
        </trans-unit>
        <trans-unit id="ba8d6d461e9008017be587a9202d1b43cf4ff54e" translate="yes" xml:space="preserve">
          <source>If this value is less than or equals to &lt;a href=&quot;../-byte/-m-a-x_-v-a-l-u-e#kotlin.Byte.Companion%24MAX_VALUE&quot;&gt;Byte.MAX_VALUE&lt;/a&gt;, the resulting &lt;code&gt;Byte&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UByte&lt;/code&gt;. Otherwise the result is negative.</source>
          <target state="translated">この値が&lt;a href=&quot;../-byte/-m-a-x_-v-a-l-u-e#kotlin.Byte.Companion%24MAX_VALUE&quot;&gt;Byte.MAX_VALUE&lt;/a&gt;以下の場合、結果の &lt;code&gt;Byte&lt;/code&gt; 値はこの &lt;code&gt;UByte&lt;/code&gt; と同じ数値を表します。そうでない場合、結果は負になります。</target>
        </trans-unit>
        <trans-unit id="df39050abae12f0e8e01436504cfef55ec387e2d" translate="yes" xml:space="preserve">
          <source>If this value is less than or equals to &lt;a href=&quot;../-byte/-m-a-x_-v-a-l-u-e#kotlin.Byte.Companion%24MAX_VALUE&quot;&gt;Byte.MAX_VALUE&lt;/a&gt;, the resulting &lt;code&gt;Byte&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UInt&lt;/code&gt;.</source>
          <target state="translated">この値が&lt;a href=&quot;../-byte/-m-a-x_-v-a-l-u-e#kotlin.Byte.Companion%24MAX_VALUE&quot;&gt;Byte.MAX_VALUE&lt;/a&gt;以下の場合、結果の &lt;code&gt;Byte&lt;/code&gt; 値はこの &lt;code&gt;UInt&lt;/code&gt; と同じ数値を表します。</target>
        </trans-unit>
        <trans-unit id="4978f90a7ed1a79fd218cf1590a5d83b0509d961" translate="yes" xml:space="preserve">
          <source>If this value is less than or equals to &lt;a href=&quot;../-byte/-m-a-x_-v-a-l-u-e#kotlin.Byte.Companion%24MAX_VALUE&quot;&gt;Byte.MAX_VALUE&lt;/a&gt;, the resulting &lt;code&gt;Byte&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;ULong&lt;/code&gt;.</source>
          <target state="translated">この値が&lt;a href=&quot;../-byte/-m-a-x_-v-a-l-u-e#kotlin.Byte.Companion%24MAX_VALUE&quot;&gt;Byte.MAX_VALUE&lt;/a&gt;以下の場合、結果の &lt;code&gt;Byte&lt;/code&gt; 値はこの &lt;code&gt;ULong&lt;/code&gt; と同じ数値を表します。</target>
        </trans-unit>
        <trans-unit id="6ca047505e5da8d6c0e87f024f03aaab76397dfc" translate="yes" xml:space="preserve">
          <source>If this value is less than or equals to &lt;a href=&quot;../-byte/-m-a-x_-v-a-l-u-e#kotlin.Byte.Companion%24MAX_VALUE&quot;&gt;Byte.MAX_VALUE&lt;/a&gt;, the resulting &lt;code&gt;Byte&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UShort&lt;/code&gt;.</source>
          <target state="translated">この値が&lt;a href=&quot;../-byte/-m-a-x_-v-a-l-u-e#kotlin.Byte.Companion%24MAX_VALUE&quot;&gt;Byte.MAX_VALUE&lt;/a&gt;以下の場合、結果の &lt;code&gt;Byte&lt;/code&gt; 値はこの &lt;code&gt;UShort&lt;/code&gt; と同じ数値を表します。</target>
        </trans-unit>
        <trans-unit id="e4c48fdf984577c7db86ab572e1f6df4cdbfd866" translate="yes" xml:space="preserve">
          <source>If this value is less than or equals to &lt;a href=&quot;../-int/-m-a-x_-v-a-l-u-e#kotlin.Int.Companion%24MAX_VALUE&quot;&gt;Int.MAX_VALUE&lt;/a&gt;, the resulting &lt;code&gt;Int&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UInt&lt;/code&gt;. Otherwise the result is negative.</source>
          <target state="translated">この値が&lt;a href=&quot;../-int/-m-a-x_-v-a-l-u-e#kotlin.Int.Companion%24MAX_VALUE&quot;&gt;Int.MAX_VALUE&lt;/a&gt;以下の場合、結果の &lt;code&gt;Int&lt;/code&gt; 値はこの &lt;code&gt;UInt&lt;/code&gt; と同じ数値を表します。そうでない場合、結果は負になります。</target>
        </trans-unit>
        <trans-unit id="558a6d1dd84324e1f32448d5639a910b9702fe85" translate="yes" xml:space="preserve">
          <source>If this value is less than or equals to &lt;a href=&quot;../-int/-m-a-x_-v-a-l-u-e#kotlin.Int.Companion%24MAX_VALUE&quot;&gt;Int.MAX_VALUE&lt;/a&gt;, the resulting &lt;code&gt;Int&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;ULong&lt;/code&gt;.</source>
          <target state="translated">この値が&lt;a href=&quot;../-int/-m-a-x_-v-a-l-u-e#kotlin.Int.Companion%24MAX_VALUE&quot;&gt;Int.MAX_VALUE&lt;/a&gt;以下の場合、結果の &lt;code&gt;Int&lt;/code&gt; 値はこの &lt;code&gt;ULong&lt;/code&gt; と同じ数値を表します。</target>
        </trans-unit>
        <trans-unit id="d5c7b7a5156a004ef779605c60b74b3e30f938ab" translate="yes" xml:space="preserve">
          <source>If this value is less than or equals to &lt;a href=&quot;../-long/-m-a-x_-v-a-l-u-e#kotlin.Long.Companion%24MAX_VALUE&quot;&gt;Long.MAX_VALUE&lt;/a&gt;, the resulting &lt;code&gt;Long&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;ULong&lt;/code&gt;. Otherwise the result is negative.</source>
          <target state="translated">この値が&lt;a href=&quot;../-long/-m-a-x_-v-a-l-u-e#kotlin.Long.Companion%24MAX_VALUE&quot;&gt;Long.MAX_VALUE&lt;/a&gt;以下の場合、結果の &lt;code&gt;Long&lt;/code&gt; 値はこの &lt;code&gt;ULong&lt;/code&gt; と同じ数値を表します。そうでない場合、結果は負になります。</target>
        </trans-unit>
        <trans-unit id="4d043b90606414b70c2e38bef9430e4d147c520b" translate="yes" xml:space="preserve">
          <source>If this value is less than or equals to &lt;a href=&quot;../-short/-m-a-x_-v-a-l-u-e#kotlin.Short.Companion%24MAX_VALUE&quot;&gt;Short.MAX_VALUE&lt;/a&gt;, the resulting &lt;code&gt;Short&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UInt&lt;/code&gt;.</source>
          <target state="translated">この値が&lt;a href=&quot;../-short/-m-a-x_-v-a-l-u-e#kotlin.Short.Companion%24MAX_VALUE&quot;&gt;Short.MAX_VALUE&lt;/a&gt;以下の場合、結果の &lt;code&gt;Short&lt;/code&gt; 値はこの &lt;code&gt;UInt&lt;/code&gt; と同じ数値を表します。</target>
        </trans-unit>
        <trans-unit id="30cf5a989061d05ea8b8590b44fff20c1be5f179" translate="yes" xml:space="preserve">
          <source>If this value is less than or equals to &lt;a href=&quot;../-short/-m-a-x_-v-a-l-u-e#kotlin.Short.Companion%24MAX_VALUE&quot;&gt;Short.MAX_VALUE&lt;/a&gt;, the resulting &lt;code&gt;Short&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;ULong&lt;/code&gt;.</source>
          <target state="translated">この値が&lt;a href=&quot;../-short/-m-a-x_-v-a-l-u-e#kotlin.Short.Companion%24MAX_VALUE&quot;&gt;Short.MAX_VALUE&lt;/a&gt;以下の場合、結果の &lt;code&gt;Short&lt;/code&gt; 値はこの &lt;code&gt;ULong&lt;/code&gt; と同じ数値を表します。</target>
        </trans-unit>
        <trans-unit id="1a549db6113eee376be4eec1673b56713351397d" translate="yes" xml:space="preserve">
          <source>If this value is less than or equals to &lt;a href=&quot;../-short/-m-a-x_-v-a-l-u-e#kotlin.Short.Companion%24MAX_VALUE&quot;&gt;Short.MAX_VALUE&lt;/a&gt;, the resulting &lt;code&gt;Short&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UShort&lt;/code&gt;. Otherwise the result is negative.</source>
          <target state="translated">この値が&lt;a href=&quot;../-short/-m-a-x_-v-a-l-u-e#kotlin.Short.Companion%24MAX_VALUE&quot;&gt;Short.MAX_VALUE&lt;/a&gt;以下の場合、結果の &lt;code&gt;Short&lt;/code&gt; 値はこの &lt;code&gt;UShort&lt;/code&gt; と同じ数値を表します。そうでない場合、結果は負になります。</target>
        </trans-unit>
        <trans-unit id="7879809b5daf67a980acd328829f4454ce83b90e" translate="yes" xml:space="preserve">
          <source>If this value is less than or equals to &lt;a href=&quot;../-u-byte/-m-a-x_-v-a-l-u-e&quot;&gt;UByte.MAX_VALUE&lt;/a&gt;, the resulting &lt;code&gt;UByte&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UInt&lt;/code&gt;.</source>
          <target state="translated">この値が&lt;a href=&quot;../-u-byte/-m-a-x_-v-a-l-u-e&quot;&gt;UByte.MAX_VALUE&lt;/a&gt;以下の場合、結果の &lt;code&gt;UByte&lt;/code&gt; 値はこの &lt;code&gt;UInt&lt;/code&gt; と同じ数値を表します。</target>
        </trans-unit>
        <trans-unit id="bcead8032199b4164256add596a32cf9db97266e" translate="yes" xml:space="preserve">
          <source>If this value is less than or equals to &lt;a href=&quot;../-u-byte/-m-a-x_-v-a-l-u-e&quot;&gt;UByte.MAX_VALUE&lt;/a&gt;, the resulting &lt;code&gt;UByte&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;ULong&lt;/code&gt;.</source>
          <target state="translated">この値が&lt;a href=&quot;../-u-byte/-m-a-x_-v-a-l-u-e&quot;&gt;UByte.MAX_VALUE&lt;/a&gt;以下の場合、結果の &lt;code&gt;UByte&lt;/code&gt; 値はこの &lt;code&gt;ULong&lt;/code&gt; と同じ数値を表します。</target>
        </trans-unit>
        <trans-unit id="1121ef81db7e8693e07be091631a7082321f06c6" translate="yes" xml:space="preserve">
          <source>If this value is less than or equals to &lt;a href=&quot;../-u-byte/-m-a-x_-v-a-l-u-e&quot;&gt;UByte.MAX_VALUE&lt;/a&gt;, the resulting &lt;code&gt;UByte&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UShort&lt;/code&gt;.</source>
          <target state="translated">この値が&lt;a href=&quot;../-u-byte/-m-a-x_-v-a-l-u-e&quot;&gt;UByte.MAX_VALUE&lt;/a&gt;以下の場合、結果の &lt;code&gt;UByte&lt;/code&gt; 値はこの &lt;code&gt;UShort&lt;/code&gt; と同じ数値を表します。</target>
        </trans-unit>
        <trans-unit id="81dc4365e9ac822eeb6e28d60dee107cd6132748" translate="yes" xml:space="preserve">
          <source>If this value is less than or equals to &lt;a href=&quot;../-u-int/-m-a-x_-v-a-l-u-e&quot;&gt;UInt.MAX_VALUE&lt;/a&gt;, the resulting &lt;code&gt;UInt&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;ULong&lt;/code&gt;.</source>
          <target state="translated">この値が&lt;a href=&quot;../-u-int/-m-a-x_-v-a-l-u-e&quot;&gt;UInt.MAX_VALUE&lt;/a&gt;以下の場合、結果の &lt;code&gt;UInt&lt;/code&gt; 値はこの &lt;code&gt;ULong&lt;/code&gt; と同じ数値を表します。</target>
        </trans-unit>
        <trans-unit id="3c9c01de18ce638bd129bff08018567a3e4127c6" translate="yes" xml:space="preserve">
          <source>If this value is less than or equals to &lt;a href=&quot;../-u-short/-m-a-x_-v-a-l-u-e&quot;&gt;UShort.MAX_VALUE&lt;/a&gt;, the resulting &lt;code&gt;UShort&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UInt&lt;/code&gt;.</source>
          <target state="translated">この値が&lt;a href=&quot;../-u-short/-m-a-x_-v-a-l-u-e&quot;&gt;UShort.MAX_VALUE&lt;/a&gt;以下の場合、結果の &lt;code&gt;UShort&lt;/code&gt; 値はこの &lt;code&gt;UInt&lt;/code&gt; と同じ数値を表します。</target>
        </trans-unit>
        <trans-unit id="a6f6b5210b89a3892e478e42ca97672805905a83" translate="yes" xml:space="preserve">
          <source>If this value is less than or equals to &lt;a href=&quot;../-u-short/-m-a-x_-v-a-l-u-e&quot;&gt;UShort.MAX_VALUE&lt;/a&gt;, the resulting &lt;code&gt;UShort&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;ULong&lt;/code&gt;.</source>
          <target state="translated">この値が&lt;a href=&quot;../-u-short/-m-a-x_-v-a-l-u-e&quot;&gt;UShort.MAX_VALUE&lt;/a&gt;以下の場合、結果の &lt;code&gt;UShort&lt;/code&gt; 値はこの &lt;code&gt;ULong&lt;/code&gt; と同じ数値を表します。</target>
        </trans-unit>
        <trans-unit id="b503698fc5df8a655c9e1e6ad1697e72a8fc230d" translate="yes" xml:space="preserve">
          <source>If this value is non-negative, the resulting &lt;code&gt;Char&lt;/code&gt; code is equal to this value.</source>
          <target state="translated">この値が負でない場合、結果の &lt;code&gt;Char&lt;/code&gt; コードはこの値と等しくなります。</target>
        </trans-unit>
        <trans-unit id="2db0fef9187625217d9cbad099e4b7a81b501888" translate="yes" xml:space="preserve">
          <source>If this value is positive and less than or equals to &lt;a href=&quot;-u-byte/-m-a-x_-v-a-l-u-e&quot;&gt;UByte.MAX_VALUE&lt;/a&gt;, the resulting &lt;code&gt;UByte&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Int&lt;/code&gt;.</source>
          <target state="translated">この値が正で&lt;a href=&quot;-u-byte/-m-a-x_-v-a-l-u-e&quot;&gt;UByte.MAX_VALUE&lt;/a&gt;以下の場合、結果の &lt;code&gt;UByte&lt;/code&gt; 値はこの &lt;code&gt;Int&lt;/code&gt; と同じ数値を表します。</target>
        </trans-unit>
        <trans-unit id="92dfb012b562ce6d901306be8ab16c8954d89a73" translate="yes" xml:space="preserve">
          <source>If this value is positive and less than or equals to &lt;a href=&quot;-u-byte/-m-a-x_-v-a-l-u-e&quot;&gt;UByte.MAX_VALUE&lt;/a&gt;, the resulting &lt;code&gt;UByte&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Long&lt;/code&gt;.</source>
          <target state="translated">この値が正で&lt;a href=&quot;-u-byte/-m-a-x_-v-a-l-u-e&quot;&gt;UByte.MAX_VALUE&lt;/a&gt;以下の場合、結果の &lt;code&gt;UByte&lt;/code&gt; 値はこの &lt;code&gt;Long&lt;/code&gt; と同じ数値を表します。</target>
        </trans-unit>
        <trans-unit id="953da8b824c2844b89e1295212fa13c1e2d80e5e" translate="yes" xml:space="preserve">
          <source>If this value is positive and less than or equals to &lt;a href=&quot;-u-byte/-m-a-x_-v-a-l-u-e&quot;&gt;UByte.MAX_VALUE&lt;/a&gt;, the resulting &lt;code&gt;UByte&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Short&lt;/code&gt;.</source>
          <target state="translated">この値が正で&lt;a href=&quot;-u-byte/-m-a-x_-v-a-l-u-e&quot;&gt;UByte.MAX_VALUE&lt;/a&gt;以下の場合、結果の &lt;code&gt;UByte&lt;/code&gt; 値はこの &lt;code&gt;Short&lt;/code&gt; と同じ数値を表します。</target>
        </trans-unit>
        <trans-unit id="9fa06c56030e25a9536cc3f63946d539809dea9f" translate="yes" xml:space="preserve">
          <source>If this value is positive and less than or equals to &lt;a href=&quot;-u-int/-m-a-x_-v-a-l-u-e&quot;&gt;UInt.MAX_VALUE&lt;/a&gt;, the resulting &lt;code&gt;UInt&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Long&lt;/code&gt;.</source>
          <target state="translated">この値が正で&lt;a href=&quot;-u-int/-m-a-x_-v-a-l-u-e&quot;&gt;UInt.MAX_VALUE&lt;/a&gt;以下の場合、結果の &lt;code&gt;UInt&lt;/code&gt; 値はこの &lt;code&gt;Long&lt;/code&gt; と同じ数値を表します。</target>
        </trans-unit>
        <trans-unit id="50d4512f22b639993dc1259c1108fdebd639d406" translate="yes" xml:space="preserve">
          <source>If this value is positive and less than or equals to &lt;a href=&quot;-u-short/-m-a-x_-v-a-l-u-e&quot;&gt;UShort.MAX_VALUE&lt;/a&gt;, the resulting &lt;code&gt;UShort&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Int&lt;/code&gt;.</source>
          <target state="translated">この値が正で&lt;a href=&quot;-u-short/-m-a-x_-v-a-l-u-e&quot;&gt;UShort.MAX_VALUE&lt;/a&gt;以下の場合、結果の &lt;code&gt;UShort&lt;/code&gt; 値はこの &lt;code&gt;Int&lt;/code&gt; と同じ数値を表します。</target>
        </trans-unit>
        <trans-unit id="8dadb1990a07a6ce6e741d4f630eb1d46e9ed4a3" translate="yes" xml:space="preserve">
          <source>If this value is positive and less than or equals to &lt;a href=&quot;-u-short/-m-a-x_-v-a-l-u-e&quot;&gt;UShort.MAX_VALUE&lt;/a&gt;, the resulting &lt;code&gt;UShort&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Long&lt;/code&gt;.</source>
          <target state="translated">この値が正で&lt;a href=&quot;-u-short/-m-a-x_-v-a-l-u-e&quot;&gt;UShort.MAX_VALUE&lt;/a&gt;以下の場合、結果の &lt;code&gt;UShort&lt;/code&gt; 値はこの &lt;code&gt;Long&lt;/code&gt; と同じ数値を表します。</target>
        </trans-unit>
        <trans-unit id="f89685f072ef956cdc798c29edd60c19b535cdfe" translate="yes" xml:space="preserve">
          <source>If this value is positive, the resulting &lt;code&gt;UByte&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Byte&lt;/code&gt;.</source>
          <target state="translated">この値が正の場合、結果の &lt;code&gt;UByte&lt;/code&gt; 値はこの &lt;code&gt;Byte&lt;/code&gt; と同じ数値を表します。</target>
        </trans-unit>
        <trans-unit id="509d2f430404b1731ac6b4aaf8d343dae3f0754b" translate="yes" xml:space="preserve">
          <source>If this value is positive, the resulting &lt;code&gt;UInt&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Byte&lt;/code&gt;.</source>
          <target state="translated">この値が正の場合、結果の &lt;code&gt;UInt&lt;/code&gt; 値はこの &lt;code&gt;Byte&lt;/code&gt; と同じ数値を表します。</target>
        </trans-unit>
        <trans-unit id="273aa3ecdd133965b3ad433946ad9ef5ed7f4eee" translate="yes" xml:space="preserve">
          <source>If this value is positive, the resulting &lt;code&gt;UInt&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Int&lt;/code&gt;.</source>
          <target state="translated">この値が正の場合、結果の &lt;code&gt;UInt&lt;/code&gt; 値はこの &lt;code&gt;Int&lt;/code&gt; と同じ数値を表します。</target>
        </trans-unit>
        <trans-unit id="2607741fe174b50565a03e15e9436cf3b0a3f525" translate="yes" xml:space="preserve">
          <source>If this value is positive, the resulting &lt;code&gt;UInt&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Short&lt;/code&gt;.</source>
          <target state="translated">この値が正の場合、結果の &lt;code&gt;UInt&lt;/code&gt; 値はこの &lt;code&gt;Short&lt;/code&gt; と同じ数値を表します。</target>
        </trans-unit>
        <trans-unit id="0f095f5bb49dc6a53286dbebb4a62e97505f3fa8" translate="yes" xml:space="preserve">
          <source>If this value is positive, the resulting &lt;code&gt;ULong&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Byte&lt;/code&gt;.</source>
          <target state="translated">この値が正の場合、結果の &lt;code&gt;ULong&lt;/code&gt; 値はこの &lt;code&gt;Byte&lt;/code&gt; と同じ数値を表します。</target>
        </trans-unit>
        <trans-unit id="c42bf5546a05357422f652dbab02ab2c5562b1b9" translate="yes" xml:space="preserve">
          <source>If this value is positive, the resulting &lt;code&gt;ULong&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Int&lt;/code&gt;.</source>
          <target state="translated">この値が正の場合、結果の &lt;code&gt;ULong&lt;/code&gt; 値はこの &lt;code&gt;Int&lt;/code&gt; と同じ数値を表します。</target>
        </trans-unit>
        <trans-unit id="1c908d0ebe8742d6be314405ace34fa252b6ec7d" translate="yes" xml:space="preserve">
          <source>If this value is positive, the resulting &lt;code&gt;ULong&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Long&lt;/code&gt;.</source>
          <target state="translated">この値が正の場合、結果の &lt;code&gt;ULong&lt;/code&gt; 値はこの &lt;code&gt;Long&lt;/code&gt; と同じ数値を表します。</target>
        </trans-unit>
        <trans-unit id="b851c29ac8506df58c238a4d6e63ef0a6ce3bf18" translate="yes" xml:space="preserve">
          <source>If this value is positive, the resulting &lt;code&gt;ULong&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Short&lt;/code&gt;.</source>
          <target state="translated">この値が正の場合、結果の &lt;code&gt;ULong&lt;/code&gt; 値はこの &lt;code&gt;Short&lt;/code&gt; と同じ数値を表します。</target>
        </trans-unit>
        <trans-unit id="a4186277a2fae421e55cc11af12fc473065dce40" translate="yes" xml:space="preserve">
          <source>If this value is positive, the resulting &lt;code&gt;UShort&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Byte&lt;/code&gt;.</source>
          <target state="translated">この値が正の場合、結果の &lt;code&gt;UShort&lt;/code&gt; 値はこの &lt;code&gt;Byte&lt;/code&gt; と同じ数値を表します。</target>
        </trans-unit>
        <trans-unit id="f91f720debed186fe9dc1691606e3420ca01e262" translate="yes" xml:space="preserve">
          <source>If this value is positive, the resulting &lt;code&gt;UShort&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Short&lt;/code&gt;.</source>
          <target state="translated">この値が正の場合、結果の &lt;code&gt;UShort&lt;/code&gt; 値はこの &lt;code&gt;Short&lt;/code&gt; と同じ数値を表します。</target>
        </trans-unit>
        <trans-unit id="b92f3912f030b245b906c1d0285095411d239059" translate="yes" xml:space="preserve">
          <source>If two corresponding elements are nested arrays, they are also compared deeply. If any of arrays contains itself on any nesting level the behavior is undefined.</source>
          <target state="translated">2つの対応する要素が入れ子になっている配列の場合,それらも深く比較されます.配列のいずれかが,いずれかの入れ子レベルにそれ自身を含んでいる場合,動作は未定義です.</target>
        </trans-unit>
        <trans-unit id="5c426df69b29a4f2a8f05ed102d4c7c508452b26" translate="yes" xml:space="preserve">
          <source>If two objects are equal according to the &lt;code&gt;equals()&lt;/code&gt; method, then calling the &lt;code&gt;hashCode&lt;/code&gt; method on each of the two objects must produce the same integer result.</source>
          <target state="translated">&lt;code&gt;equals()&lt;/code&gt; メソッドに従って2つのオブジェクトが等しい場合、2つのオブジェクトのそれぞれで &lt;code&gt;hashCode&lt;/code&gt; メソッドを呼び出すと、同じ整数の結果が生成される必要があります。</target>
        </trans-unit>
        <trans-unit id="848bd4767d40a5b040578d4b4acc3831b4a5c116" translate="yes" xml:space="preserve">
          <source>If using Android Studio, the following needs to be added under android:</source>
          <target state="translated">Android Studioを使用している場合は、androidの下に以下を追加する必要があります。</target>
        </trans-unit>
        <trans-unit id="835af367bcaa35713fbb44c63e3433507604b4f9" translate="yes" xml:space="preserve">
          <source>If using Ant or Maven, the same configuration applies. The only difference being that the Runner Type would be Ant or Maven respectively.</source>
          <target state="translated">AntやMavenを使用している場合は、同じ設定が適用されます。唯一の違いは、ランナーのタイプがそれぞれAntとMavenになることです。</target>
        </trans-unit>
        <trans-unit id="00e086822c4cc4c3d86e846ccfc2b1c6bbc7e5e5" translate="yes" xml:space="preserve">
          <source>If using Ant, Maven or Gradle, the setup process is straightforward. All that is needed is to define the Build Step. In our case, if using Gradle we'd simply define the required parameters such as the Step Name and Gradle tasks that need executing for the Runner Type.</source>
          <target state="translated">Ant,Maven,Gradleを使用している場合、セットアップのプロセスは簡単です。必要なのは、ビルドステップを定義することです。この例では、Gradleを使用している場合は、ステップ名やランナータイプに必要なGradleタスクなどの必要なパラメータを定義します。</target>
        </trans-unit>
        <trans-unit id="6d1aa0dbbc7faa5d8c75c6b538e6bd8ea6617548" translate="yes" xml:space="preserve">
          <source>If using IntelliJ IDEA build system with TeamCity, we need to make sure that the version of Kotlin being used by IntelliJ IDEA is the same as that that TeamCity runs. This would mean that we need to download the specific version of the Kotlin plugin and install it on TeamCity.</source>
          <target state="translated">IntelliJ IDEAビルドシステムをTeamCityで使用する場合、IntelliJ IDEAで使用しているKotlinのバージョンがTeamCityで動作しているものと同じであることを確認する必要があります。これは、Kotlin プラグインの特定のバージョンをダウンロードして、TeamCity にインストールする必要があることを意味します。</target>
        </trans-unit>
        <trans-unit id="1ff8b36dc1a6a3cc57b717edeaeb3788168f606b" translate="yes" xml:space="preserve">
          <source>If using Maven or Gradle, we can also configure the module output format. For more information see &lt;a href=&quot;http://kotlinlang.org/docs/reference/js-modules.html&quot;&gt;JavaScript Modules&lt;/a&gt;.</source>
          <target state="translated">MavenまたはGradleを使用している場合は、モジュールの出力形式も構成できます。詳細については、&lt;a href=&quot;http://kotlinlang.org/docs/reference/js-modules.html&quot;&gt;JavaScriptモジュールを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="a5a4dc0ed9963550c2c79f4e04423d9486f9f6cf" translate="yes" xml:space="preserve">
          <source>If using a Continuous Integration tool different to TeamCity, as long as it supports any of the build tools, or calling command line tools, compiling Kotlin and automating things as part of a CI process should be possible.</source>
          <target state="translated">TeamCityとは別の継続的インテグレーションツールを使用している場合、ビルドツールのいずれかをサポートしているか、コマンドラインツールを呼び出すことができれば、KotlinをコンパイルしてCIプロセスの一部として物事を自動化することは可能なはずです。</target>
        </trans-unit>
        <trans-unit id="6bd5591695bc9bb315e16734b0ff743bacc22bbf" translate="yes" xml:space="preserve">
          <source>If using a previous version, refer to the &lt;a href=&quot;https://confluence.jetbrains.com/display/TCD9/Working+with+Meta-Runner&quot;&gt;documentation on how to add meta-runners&lt;/a&gt;.</source>
          <target state="translated">以前のバージョンを使用している場合は、&lt;a href=&quot;https://confluence.jetbrains.com/display/TCD9/Working+with+Meta-Runner&quot;&gt;メタランナーの追加方法に関するドキュメントを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="449042335ccaad499545704799876f951b9d4d55" translate="yes" xml:space="preserve">
          <source>If values are equal, returns the first one.</source>
          <target state="translated">値が等しい場合は、最初の値を返します。</target>
        </trans-unit>
        <trans-unit id="f746ae601b0ca7798611e8dc917365449e6e394e" translate="yes" xml:space="preserve">
          <source>If we are computing the numbers with some CPU-consuming blocking code (each computation taking 100ms), then we can represent the numbers using a &lt;a href=&quot;../../../api/latest/jvm/stdlib/kotlin.sequences/index&quot;&gt;Sequence&lt;/a&gt;:</source>
          <target state="translated">CPUを消費するブロッキングコードを使用して数値を計算している場合（各計算には100ミリ秒かかります）、&lt;a href=&quot;../../../api/latest/jvm/stdlib/kotlin.sequences/index&quot;&gt;シーケンス&lt;/a&gt;を使用して数値を表すことができます。</target>
        </trans-unit>
        <trans-unit id="5b672336c863c791a792cf43720020da0742ad23" translate="yes" xml:space="preserve">
          <source>If we are using IntelliJ IDEA as our development environment, we can find the &lt;code&gt;run&lt;/code&gt; action in the Gradle tool window:</source>
          <target state="translated">開発環境としてIntelliJIDEAを使用している場合、 &lt;code&gt;run&lt;/code&gt; アクションはGradleツールウィンドウにあります。</target>
        </trans-unit>
        <trans-unit id="f5d0a72271531597b020177163056bb930e197fe" translate="yes" xml:space="preserve">
          <source>If we are using the set of example tests shown in the snippet above, one test passes, and one test breaks, which gives us the resulting total of 50% successful tests. To get more information about individual test cases, we can navigate via the provided hyperlinks:</source>
          <target state="translated">上記のスニペットに示されたテスト例のセットを使用している場合、1つのテストが通過し、1つのテストが中断し、結果として合計50%のテストが成功したことになります。個々のテストケースについての詳細な情報を得るために、提供されたハイパーリンクを介してナビゲートすることができます。</target>
        </trans-unit>
        <trans-unit id="6bba64879e65ddd90a5f852a3b397bb4e81ce686" translate="yes" xml:space="preserve">
          <source>If we are working from inside IntelliJ IDEA, we can pass the same flag via the &lt;em&gt;run configuration&lt;/em&gt;. After running the Gradle &lt;code&gt;run&lt;/code&gt; task for the first time from the IDE, IntelliJ IDEA automatically generates a run configuration for it, which we can edit:</source>
          <target state="translated">IntelliJ IDEA内から作業している場合は、&lt;em&gt;実行構成を&lt;/em&gt;介して同じフラグを渡すことができ&lt;em&gt;ます&lt;/em&gt;。IDEからGradle &lt;code&gt;run&lt;/code&gt; タスクを初めて実行した後、IntelliJIDEAはその実行構成を自動的に生成します。これを編集できます。</target>
        </trans-unit>
        <trans-unit id="83ff93c719c3677a5febd54d97d72cdccbce6a99" translate="yes" xml:space="preserve">
          <source>If we call &lt;code&gt;c.foo()&lt;/code&gt; of any &lt;code&gt;c&lt;/code&gt; of type &lt;code&gt;C&lt;/code&gt;, it will print &quot;member&quot;, not &quot;extension&quot;.</source>
          <target state="translated">我々は呼び出す場合 &lt;code&gt;c.foo()&lt;/code&gt; いずれかの &lt;code&gt;c&lt;/code&gt; 型の &lt;code&gt;C&lt;/code&gt; を、それが「メンバー」ではなく、「拡張子」を印刷します。</target>
        </trans-unit>
        <trans-unit id="379283767448c54e1e97c1028507253f860becb5" translate="yes" xml:space="preserve">
          <source>If we choose a non-null type, the compiler will emit an assertion upon assignment. This prevents Kotlin's non-null variables from holding nulls. Assertions are also emitted when we pass platform values to Kotlin functions expecting non-null values etc. Overall, the compiler does its best to prevent nulls from propagating far through the program (although sometimes this is impossible to eliminate entirely, because of generics).</source>
          <target state="translated">非ヌル型を選択すると、コンパイラは代入時にアサーションを出します。これにより、Kotlinの非ヌル型変数がヌル型を保持することを防ぎます。アサーションは、非 null 型の値を期待して Kotlin の関数にプラットフォームの値を渡した場合などにも発行されます。全体的には、コンパイラはnullがプログラムの中で遠くまで伝搬するのを防ぐために最善を尽くしています (ただし、ジェネリックのために完全に排除することは不可能な場合もあります)。</target>
        </trans-unit>
        <trans-unit id="bdbae50858519197b3fe083596ba04b9db8edf5b" translate="yes" xml:space="preserve">
          <source>If we define a custom setter, it will be called every time we assign a value to the property. A custom setter looks like this:</source>
          <target state="translated">カスタム・セッターを定義すると、プロパティに値を代入するたびに呼び出されます。カスタムセッターは次のようになります。</target>
        </trans-unit>
        <trans-unit id="d5788a5cd4b3c40d8ba64eb6708ad2b0a9b603bc" translate="yes" xml:space="preserve">
          <source>If we didn't specify the &lt;code&gt;@JsName&lt;/code&gt; annotation, the name of the corresponding function would contain a suffix calculated from the function signature, for example &lt;code&gt;hello_61zpoe$&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;@JsName&lt;/code&gt; アノテーションを指定しなかった場合、対応する関数の名前には、関数のシグネチャから計算されたサフィックスが含まれます（例： &lt;code&gt;hello_61zpoe$&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="966f788e727a4b595780377e8042611cc0480c54" translate="yes" xml:space="preserve">
          <source>If we had wanted to express the same thing in Python, it would have looked like this, and we would be hamstrung by the fact that lambda functions can only contain one expression, so we need explicit function definitions for everything but the oneliners:</source>
          <target state="translated">同じことをPythonで表現しようとしたら、こんな感じになっていたでしょうし、ラムダ関数は1つの式しか入れられないので、オネリナ以外は明示的な関数定義が必要になります。</target>
        </trans-unit>
        <trans-unit id="dc0fca0f296a8cb428a1796bfc197561c1551e47" translate="yes" xml:space="preserve">
          <source>If we leave all the optional annotations out, what's left looks like this:</source>
          <target state="translated">オプションの注釈をすべて削除すると、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="7f0622f86bfe1754250cfd5960f42eb9787c1baa" translate="yes" xml:space="preserve">
          <source>If we need to use a member of a class, or an extension function, it needs to be qualified, e.g. &lt;code&gt;String::toCharArray&lt;/code&gt;.</source>
          <target state="translated">クラスのメンバーまたは拡張関数を使用する必要がある場合は、例えば &lt;code&gt;String::toCharArray&lt;/code&gt; ように修飾する必要があります。</target>
        </trans-unit>
        <trans-unit id="06f2f1ba4877a89d728de7b4cb1810c2c9646349" translate="yes" xml:space="preserve">
          <source>If we need wildcards where they are not generated by default, we can use the &lt;code&gt;@JvmWildcard&lt;/code&gt; annotation:</source>
          <target state="translated">デフォルトで生成されないワイルドカードが必要な場合は、 &lt;code&gt;@JvmWildcard&lt;/code&gt; アノテーションを使用できます。</target>
        </trans-unit>
        <trans-unit id="8622531a5c0429cfdda336ff31f83fe890fe02ca" translate="yes" xml:space="preserve">
          <source>If we try to use the same non-blocking &lt;code&gt;delay()&lt;/code&gt; function directly inside &lt;code&gt;main()&lt;/code&gt;, we'll get a compiler error:</source>
          <target state="translated">同じ非ブロッキング &lt;code&gt;delay()&lt;/code&gt; 関数を &lt;code&gt;main()&lt;/code&gt; 内で直接使用しようとすると、コンパイラエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="40479a99caad7c4a33dc795543afa14441ffca7a" translate="yes" xml:space="preserve">
          <source>If we use the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/collect.html&quot;&gt;collect&lt;/a&gt; terminal operator after &lt;code&gt;onEach&lt;/code&gt;, then the code after it will wait until the flow is collected:</source>
          <target state="translated">&lt;code&gt;onEach&lt;/code&gt; の後に&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/collect.html&quot;&gt;collect&lt;/a&gt;ターミナル演算子を使用すると、その後のコードはフローが収集されるまで待機します。</target>
        </trans-unit>
        <trans-unit id="eec42d7483409e40f6e340d8a3d88fe567b92801" translate="yes" xml:space="preserve">
          <source>If we want to call the synthetic properties on &lt;code&gt;View&lt;/code&gt;, we should also import &lt;code&gt;kotlinx.android.synthetic.main.activity_main.view.*&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;View&lt;/code&gt; で合成プロパティを呼び出す場合は、 &lt;code&gt;kotlinx.android.synthetic.main.activity_main.view.*&lt;/code&gt; もインポートする必要があります。</target>
        </trans-unit>
        <trans-unit id="b22d5f997bc9d10a51a59c8d992a6139a9878201" translate="yes" xml:space="preserve">
          <source>If we want, we can add tests to a specific platform, then it will be executed only as part of these platform tests.</source>
          <target state="translated">必要であれば、特定のプラットフォームにテストを追加することができ、これらのプラットフォームのテストの一部としてのみ実行されます。</target>
        </trans-unit>
        <trans-unit id="df31a64d374ba97c421367b3cdcce507cbe75299" translate="yes" xml:space="preserve">
          <source>If we want, we can add tests to a specific platform, then it will be executed only as part of these platform tests. For example, we can add UTF-16 tests on JVM. Just follow the same steps as before, but create file in &lt;code&gt;jvmTest/kotlin/jetbrains/base64&lt;/code&gt;:</source>
          <target state="translated">必要に応じて、特定のプラットフォームにテストを追加すると、これらのプラットフォームテストの一部としてのみ実行されます。たとえば、JVMにUTF-16テストを追加できます。前と同じ手順を実行しますが、 &lt;code&gt;jvmTest/kotlin/jetbrains/base64&lt;/code&gt; にファイルを作成します。</target>
        </trans-unit>
        <trans-unit id="ba8fe72a36f3192d28c0b1bb2a6adebf2c73a672" translate="yes" xml:space="preserve">
          <source>If we were to introduce another class &lt;code&gt;Bicycle&lt;/code&gt;, which should be neither a subclass nor a superclass of &lt;code&gt;MotorVehicle&lt;/code&gt;, we could still make it implement &lt;code&gt;Driveable&lt;/code&gt;, as long as we declare &lt;code&gt;maxSpeed&lt;/code&gt; and &lt;code&gt;drive&lt;/code&gt; in &lt;code&gt;Bicycle&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;MotorVehicle&lt;/code&gt; のサブクラスでもスーパークラスでもない別のクラス &lt;code&gt;Bicycle&lt;/code&gt; を導入する場合でも、 &lt;code&gt;maxSpeed&lt;/code&gt; と &lt;code&gt;drive&lt;/code&gt; を &lt;code&gt;Bicycle&lt;/code&gt; で宣言する限り、 &lt;code&gt;Driveable&lt;/code&gt; を実装することができます。</target>
        </trans-unit>
        <trans-unit id="84ed0f9beb7f91564144926831adc67accd41344" translate="yes" xml:space="preserve">
          <source>If we're not using IntelliJ IDEA, we can configure the &lt;code&gt;pom.xml&lt;/code&gt; file manually to target JavaScript, by adding the following entries</source>
          <target state="translated">IntelliJ IDEAを使用していない場合は、次のエントリを追加することで、JavaScriptをターゲットとするように &lt;code&gt;pom.xml&lt;/code&gt; ファイルを手動で構成できます。</target>
        </trans-unit>
        <trans-unit id="f4acfe17479a9d138aec02a2b5400d83b9dbad62" translate="yes" xml:space="preserve">
          <source>If what the overriding function wants to do is an extension of what the overridden function did, you can call the overridden function via &lt;code&gt;super&lt;/code&gt; (either before, after, or between other code):</source>
          <target state="translated">オーバーライドする関数が実行したいことは、オーバーライドされた関数が行ったことの拡張である場合、オーバーライドされた関数を &lt;code&gt;super&lt;/code&gt; を介して呼び出すことができます（前、後、または他のコード間）。</target>
        </trans-unit>
        <trans-unit id="4e616deeae977bea1b9ac2aaff006d6b429ca59f" translate="yes" xml:space="preserve">
          <source>If you &lt;a href=&quot;https://developer.android.com/jetpack/compose/setup?hl=en&quot;&gt;enable Jetpack Compose&lt;/a&gt;, you will automatically be opted in to the new JVM backend without needing to specify the compiler option in &lt;code&gt;kotlinOptions&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://developer.android.com/jetpack/compose/setup?hl=en&quot;&gt;Jetpack Compose&lt;/a&gt;を有効にすると、 &lt;code&gt;kotlinOptions&lt;/code&gt; でコンパイラオプションを指定しなくても、新しいJVMバックエンドに自動的にオプトインされます。</target>
        </trans-unit>
        <trans-unit id="d45490f38e7e6ac42b22f89099d8ed55b7cb4a46" translate="yes" xml:space="preserve">
          <source>If you agree, it will run migration code inspections that will check your code and suggest corrections for anything that doesn't work or that is not recommended in 1.4.0.</source>
          <target state="translated">同意する場合は、マイグレーションコードの検査を実行し、コードをチェックし、1.4.0で動作しないものや1.4.0で推奨されていないものの修正を提案してくれます。</target>
        </trans-unit>
        <trans-unit id="859a34cc0f1bc449ccdc83a5bb060605e6dcaa25" translate="yes" xml:space="preserve">
          <source>If you already &lt;strong&gt;have a Java project&lt;/strong&gt;, you can:</source>
          <target state="translated">すでに&lt;strong&gt;Javaプロジェクト&lt;/strong&gt;がある場合は、次のことができます。</target>
        </trans-unit>
        <trans-unit id="c93cd73e42edadff5832f929c0b9aee1adf9c114" translate="yes" xml:space="preserve">
          <source>If you already have an &lt;code&gt;Iterable&lt;/code&gt; object (such as a &lt;code&gt;List&lt;/code&gt; or a &lt;code&gt;Set&lt;/code&gt;), you can create a sequence from it by calling &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/as-sequence&quot;&gt;&lt;code&gt;asSequence()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Iterable&lt;/code&gt; オブジェクト（ &lt;code&gt;List&lt;/code&gt; や &lt;code&gt;Set&lt;/code&gt; など）がすでにある場合は、&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/as-sequence&quot;&gt; &lt;code&gt;asSequence()&lt;/code&gt; を&lt;/a&gt;呼び出して、そこからシーケンスを作成できます。</target>
        </trans-unit>
        <trans-unit id="fc29b28eefcc5ecff8f112f0914c7751c0121584" translate="yes" xml:space="preserve">
          <source>If you already have the Java classes, you can just copy them to the project directories.</source>
          <target state="translated">すでにJavaクラスを持っている場合は、プロジェクトディレクトリにコピーしてください。</target>
        </trans-unit>
        <trans-unit id="6b839b9469fa700514c4a020dc91dfcc6a1e8d21" translate="yes" xml:space="preserve">
          <source>If you are creating a library that will be consumed from JavaScript or a Node.js file, and want to use a different module system, the instructions are slightly different.</source>
          <target state="translated">JavaScriptやNode.jsファイルから消費されるライブラリを作成していて、別のモジュールシステムを使用したい場合は、手順が少し異なります。</target>
        </trans-unit>
        <trans-unit id="4e80a816776f6d15384568dae346e099a9c4bc29" translate="yes" xml:space="preserve">
          <source>If you are new to the JVM and Java, check out the &lt;a href=&quot;http://hadihariri.com/2013/12/29/jvm-minimal-survival-guide-for-the-dotnet-developer/&quot;&gt;JVM Minimal Survival Guide&lt;/a&gt;. If you are new to IntelliJ IDEA, check out the &lt;a href=&quot;http://hadihariri.com/2014/01/06/intellij-idea-minimal-survival-guide/&quot;&gt;The IntelliJ IDEA Minimal Survival Guide&lt;/a&gt;.</source>
          <target state="translated">JVMとJavaを初めて使用する場合は、&lt;a href=&quot;http://hadihariri.com/2013/12/29/jvm-minimal-survival-guide-for-the-dotnet-developer/&quot;&gt;JVM Minimal Survival Guideを&lt;/a&gt;確認してください。IntelliJ IDEAを初めて使用する場合は&lt;a href=&quot;http://hadihariri.com/2014/01/06/intellij-idea-minimal-survival-guide/&quot;&gt;、IntelliJ IDEA Minimal Survival Guideを&lt;/a&gt;確認してください。</target>
        </trans-unit>
        <trans-unit id="3a098b59cc7c828b6cf7a7a722a6433f92888a1c" translate="yes" xml:space="preserve">
          <source>If you are using IntelliJ IDEA, start with &lt;a href=&quot;getting-started&quot;&gt;Getting Started&lt;/a&gt; and then work your way through the &lt;a href=&quot;koans&quot;&gt;Kotlin Koans&lt;/a&gt;.</source>
          <target state="translated">IntelliJ IDEAを使用している場合は、&lt;a href=&quot;getting-started&quot;&gt;「はじめに」から始め&lt;/a&gt;て、&lt;a href=&quot;koans&quot;&gt;Kotlin Koansを進め&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="92c9f5001a0b1041d30c375e3f64079f5f4024cf" translate="yes" xml:space="preserve">
          <source>If you are using IntelliJ IDEA, start with &lt;a href=&quot;getting-started&quot;&gt;Getting Started&lt;/a&gt;.</source>
          <target state="translated">IntelliJ IDEAを使用している場合は、&lt;a href=&quot;getting-started&quot;&gt;「はじめに」から始めてください&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="288920b3c9422f077df54c1f4e25ceb3fa6051e0" translate="yes" xml:space="preserve">
          <source>If you are using the command line compiler, start with &lt;a href=&quot;command-line&quot;&gt;Working with the Command Line Compiler&lt;/a&gt; and then work your way through the &lt;a href=&quot;koans&quot;&gt;Kotlin Koans&lt;/a&gt;;</source>
          <target state="translated">あなたは、コマンドラインコンパイラを使用している場合は、で始まる&lt;a href=&quot;command-line&quot;&gt;コマンドラインコンパイラで作業&lt;/a&gt;し、その後を通してあなたの方法を動作し&lt;a href=&quot;koans&quot;&gt;Kotlin Koans&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="30938b7e8379a33204d1fef78a0ab9d4d4d9e21f" translate="yes" xml:space="preserve">
          <source>If you are writing an external declaration for a JavaScript function which has an optional parameter, use &lt;code&gt;definedExternally&lt;/code&gt;. This delegates the generation of the default values to the JavaScript function itself:</source>
          <target state="translated">オプションのパラメーターを持つJavaScript関数の外部宣言を作成する場合は、 &lt;code&gt;definedExternally&lt;/code&gt; を使用します。これにより、デフォルト値の生成がJavaScript関数自体に委任されます。</target>
        </trans-unit>
        <trans-unit id="f2a50c48e84ca80688cd2b0e1b9297326e7b2f1d" translate="yes" xml:space="preserve">
          <source>If you build your module with Gradle, you can add arguments like this:</source>
          <target state="translated">Gradleでモジュールを構築する場合は、以下のように引数を追加することができます。</target>
        </trans-unit>
        <trans-unit id="cd3aa7d69244f58e95e8689b9c6402ed443bb559" translate="yes" xml:space="preserve">
          <source>If you consider all the APIs of your module experimental, you can mark the entire module as such with the compiler argument &lt;code&gt;-Xexperimental&lt;/code&gt; as described in &lt;a href=&quot;#module-wide-use&quot;&gt;Module-wide use&lt;/a&gt;.</source>
          <target state="translated">モジュールのすべてのAPIを実験的に検討する場合は、モジュール全体の&lt;a href=&quot;#module-wide-use&quot;&gt;使用で&lt;/a&gt;説明されているように、コンパイラー引数 &lt;code&gt;-Xexperimental&lt;/code&gt; を使用してモジュール全体をそのようにマークできます。</target>
        </trans-unit>
        <trans-unit id="e700eece24a382c6a466861314d880f1c63adba4" translate="yes" xml:space="preserve">
          <source>If you declare a factory function for a class, avoid giving it the same name as the class itself. Prefer using a distinct name making it clear why the behavior of the factory function is special. Only if there is really no special semantics, you can use the same name as the class.</source>
          <target state="translated">クラスのファクトリ関数を宣言する場合、クラス自体と同じ名前を付けることは避けてください。ファクトリ関数の動作が特別なものである理由を明確にするために、明確な名前を使用することをお勧めします。本当に特別なセマンティクスがない場合に限り、クラスと同じ名前を使うことができます。</target>
        </trans-unit>
        <trans-unit id="e1ed8ae699e2f0e0c43725a76e755048bb606787" translate="yes" xml:space="preserve">
          <source>If you declare a standard library dependency explicitly (for example, if you need a different version), the Kotlin Gradle plugin won&amp;rsquo;t override it or add a second standard library.</source>
          <target state="translated">標準ライブラリの依存関係を明示的に宣言した場合（たとえば、別のバージョンが必要な場合）、Kotlin Gradleプラグインはそれをオーバーライドしたり、2番目の標準ライブラリを追加したりしません。</target>
        </trans-unit>
        <trans-unit id="a09dc2e7a857fda68536a28e258f8622ea168f72" translate="yes" xml:space="preserve">
          <source>If you declare your Kotlin code in a package, &lt;code&gt;main&lt;/code&gt; would be followed by a package definition part. For example, this goes after the &lt;code&gt;main&lt;/code&gt; declaration if you put your &lt;code&gt;main&lt;/code&gt; function in the &lt;code&gt;org.example.hellojs&lt;/code&gt; package:</source>
          <target state="translated">Kotlinコードをパッケージで宣言すると、 &lt;code&gt;main&lt;/code&gt; の後にパッケージ定義部分が続きます。たとえば、 &lt;code&gt;main&lt;/code&gt; 関数を &lt;code&gt;org.example.hellojs&lt;/code&gt; パッケージに配置した場合、これは &lt;code&gt;main&lt;/code&gt; 宣言の後にあります。</target>
        </trans-unit>
        <trans-unit id="9bc82014d1e005bd252c8fd44c4f86ea4b0260b5" translate="yes" xml:space="preserve">
          <source>If you didn&amp;rsquo;t use the Project Wizard to create your project, you can &lt;a href=&quot;using-gradle#set-dependencies-on-test-libraries&quot;&gt;add the dependencies manually&lt;/a&gt;.</source>
          <target state="translated">プロジェクトウィザードを使用してプロジェクトを作成しなかった場合は&lt;a href=&quot;using-gradle#set-dependencies-on-test-libraries&quot;&gt;、依存関係を手動で追加&lt;/a&gt;できます。</target>
        </trans-unit>
        <trans-unit id="c9f4c0d0e98edca70ce37e016401b88c44c12e52" translate="yes" xml:space="preserve">
          <source>If you do not need a standard library at all, you can add the opt-out flag to the &lt;code&gt;gradle.properties&lt;/code&gt;:</source>
          <target state="translated">標準ライブラリがまったく必要ない場合は、オプトアウトフラグを &lt;code&gt;gradle.properties&lt;/code&gt; に追加できます。</target>
        </trans-unit>
        <trans-unit id="2d0c772b88930f846f25631788c26caf89a248c8" translate="yes" xml:space="preserve">
          <source>If you do not specify any visibility modifier, &lt;code&gt;public&lt;/code&gt; is used by default, which means that your declarations will be visible everywhere;</source>
          <target state="translated">可視性修飾子を指定しない場合、デフォルトで &lt;code&gt;public&lt;/code&gt; が使用されます。つまり、宣言はどこにでも表示されます。</target>
        </trans-unit>
        <trans-unit id="cadfb46ca63577b7ac5a59ea3e20f042f8a1e23b" translate="yes" xml:space="preserve">
          <source>If you don't care about the return value from the function, but you want to make one or more calls involving something that might be null and then keep on using that value, try &lt;code&gt;apply()&lt;/code&gt;, which returns the value it's called on. This is particularly useful if you want to work with many members of the object in question:</source>
          <target state="translated">関数からの戻り値は気にしないが、nullの可能性があるものを含む1つ以上の呼び出しを行い、その値を使い続けたい場合は、 &lt;code&gt;apply()&lt;/code&gt; を呼び出します。apply（）は呼び出された値を返します。これは、問題のオブジェクトの多くのメンバーを操作する場合に特に便利です。</target>
        </trans-unit>
        <trans-unit id="25be6af74cab7ee5d3f6a46048e18b2c9c41852a" translate="yes" xml:space="preserve">
          <source>If you don't care about the return value, you don't need to assign it to anything.</source>
          <target state="translated">戻り値を気にしないのであれば、何も代入する必要はありません。</target>
        </trans-unit>
        <trans-unit id="b5e43077cfafc57268582f5f13c46e3f8aaffa0e" translate="yes" xml:space="preserve">
          <source>If you don't have an instance of the class, you can get the class metadata with &lt;code&gt;String::class.java&lt;/code&gt; (but you can't invoke any of its members until you have an instance).</source>
          <target state="translated">クラスのインスタンスがない場合は、 &lt;code&gt;String::class.java&lt;/code&gt; してクラスメタデータを取得できます（ただし、インスタンスが作成されるまで、そのメンバーを呼び出すことはできません）。</target>
        </trans-unit>
        <trans-unit id="ef8266bd47e097890ef64d7166bd8dd100eb20ff" translate="yes" xml:space="preserve">
          <source>If you don't have any idea (or don't care) what the generic type might be, you can use a &lt;em&gt;star-projection&lt;/em&gt;:</source>
          <target state="translated">ジェネリック型が何であるかわからない（または気にしない）場合は、&lt;em&gt;スター投影を&lt;/em&gt;使用できます。</target>
        </trans-unit>
        <trans-unit id="3e3d1700eb36e84d61d0cc0f83792e108ac15508" translate="yes" xml:space="preserve">
          <source>If you don't need a variable in the destructuring declaration, you can place an underscore instead of its name:</source>
          <target state="translated">破壊宣言で変数を必要としない場合は、その名前の代わりにアンダースコアを置くことができます。</target>
        </trans-unit>
        <trans-unit id="22b00c7537a626ef39f32b96fa84adefd77db83f" translate="yes" xml:space="preserve">
          <source>If you don't specify a use-site target, the target is chosen according to the &lt;code&gt;@Target&lt;/code&gt; annotation of the annotation being used. If there are multiple applicable targets, the first applicable target from the following list is used:</source>
          <target state="translated">use-siteターゲットを指定しない場合、ターゲットは、使用されて &lt;code&gt;@Target&lt;/code&gt; アノテーションの@Targetアノテーションに従って選択されます。該当するターゲットが複数ある場合は、以下のリストから最初に該当するターゲットが使用されます。</target>
        </trans-unit>
        <trans-unit id="311d02e910900437e250a96c50bd0e61d68e28d2" translate="yes" xml:space="preserve">
          <source>If you don't specify the minimum target version and a dependency Pod requires a higher deployment target, you may get an error.</source>
          <target state="translated">最小ターゲットバージョンを指定せず、依存関係のあるPodがより高いデプロイターゲットを必要とする場合、エラーが出ることがあります。</target>
        </trans-unit>
        <trans-unit id="91ea08ad1a525edd6dec0bb4e202636f7932a646" translate="yes" xml:space="preserve">
          <source>If you don't use Gradle or Maven, make sure you have &lt;code&gt;kotlin-reflect.jar&lt;/code&gt; in the classpath of your project. In other supported cases (IntelliJ IDEA projects, using command-line compiler or Ant), it is added by default. In command-line compiler and Ant, you can use &lt;code&gt;-no-reflect&lt;/code&gt; compiler option to exclude &lt;code&gt;kotlin-reflect.jar&lt;/code&gt; from the classpath.</source>
          <target state="translated">GradleまたはMavenを使用しない場合は、プロジェクトのクラスパスに &lt;code&gt;kotlin-reflect.jar&lt;/code&gt; があることを確認してください。その他のサポートされているケース（IntelliJ IDEAプロジェクト、コマンドラインコンパイラまたはAntを使用）では、デフォルトで追加されます。コマンドラインコンパイラとAntでは、 &lt;code&gt;-no-reflect&lt;/code&gt; コンパイラオプションを使用して、クラスパスから &lt;code&gt;kotlin-reflect.jar&lt;/code&gt; を除外できます。</target>
        </trans-unit>
        <trans-unit id="508516363f92e5f2f533651260b76217ec5964d8" translate="yes" xml:space="preserve">
          <source>If you don't use a SAM conversion, you will need to write code like this:</source>
          <target state="translated">SAM変換を使わない場合は、このようなコードを書く必要があります。</target>
        </trans-unit>
        <trans-unit id="3774ed57fc20d87b5d40f08286d6544810927195" translate="yes" xml:space="preserve">
          <source>If you don't want to annotate every usage of APIs that require opt-in, you can opt in to them for your whole module. To opt in to using an API in a module, compile it with the argument &lt;code&gt;-Xopt-in&lt;/code&gt;, specifying the fully qualified name of the opt-in requirement annotation of the API you use: &lt;code&gt;-Xopt-in=org.mylibrary.OptInAnnotation&lt;/code&gt;. Compiling with this argument has the same effect as if every declaration in the module had the annotation&lt;code&gt;@OptIn(OptInAnnotation::class)&lt;/code&gt;.</source>
          <target state="translated">オプトインを必要とするAPIのすべての使用法に注釈を付けたくない場合は、モジュール全体でそれらにオプトインできます。モジュールでAPIを使用することをオプトインするには、引数 &lt;code&gt;-Xopt-in&lt;/code&gt; inを使用してコンパイルし、使用するAPIのオプトイン要件アノテーションの完全修飾名を指定します： &lt;code&gt;-Xopt-in=org.mylibrary.OptInAnnotation&lt;/code&gt; 。この引数を使用してコンパイルすると、モジュール内のすべての宣言にアノテーション &lt;code&gt;@OptIn(OptInAnnotation::class)&lt;/code&gt; 場合と同じ効果があります。</target>
        </trans-unit>
        <trans-unit id="3fedc784120817cc87cdecd3df22bdeb6a5e4e0c" translate="yes" xml:space="preserve">
          <source>If you don't want to annotate every usage of experimental APIs in your code, you can accept the experimental status for your whole module. Module-wide use of experimental APIs can be propagating and non-propagating as well:</source>
          <target state="translated">コード中の実験的 API の使用法をすべてアノテーションしたくない場合は、モジュール全体の実験的ステータスを受け入れることができます。モジュール全体での実験的 API の使用は、伝播するものと伝播しないものがあります。</target>
        </trans-unit>
        <trans-unit id="43a0c51574e240459eda5d6b9335be253ee68042" translate="yes" xml:space="preserve">
          <source>If you find that an interface that you want a class to implement is already implemented by one of the properties of the class, you can &lt;em&gt;delegate&lt;/em&gt; the implementation of that interface to that property with &lt;code&gt;by&lt;/code&gt;:</source>
          <target state="translated">あなたが実装するクラスがすでにクラスのプロパティのいずれかによって実現されたいとのインターフェイスは、あなたができることが判明した場合&lt;em&gt;に委任&lt;/em&gt;してそのプロパティにそのインターフェイスの実装を &lt;code&gt;by&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="8261f1da9a2137ff384a6fcdb0fdc9e9eb256bac" translate="yes" xml:space="preserve">
          <source>If you find the &lt;code&gt;this&lt;/code&gt; syntax to be confusing, you can use &lt;code&gt;also&lt;/code&gt; instead, which takes ordinary lambdas:</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; 構文がわかりにくい場合は、代わりに通常のラムダを使用すること &lt;code&gt;also&lt;/code&gt; できます。</target>
        </trans-unit>
        <trans-unit id="6fec69f93ca0bc139456ed1755b8b6f4c32f1863" translate="yes" xml:space="preserve">
          <source>If you have a backend written in Kotlin, you can &lt;strong&gt;share common code&lt;/strong&gt; such as data models or validation logic with a frontend written in Kotlin/JS, allowing you to &lt;strong&gt;write and maintain full-stack web applications&lt;/strong&gt;.</source>
          <target state="translated">Kotlinで記述されたバックエンドがある場合は、データモデルや検証ロジックなどの&lt;strong&gt;共通コード&lt;/strong&gt;をKotlin / JSで記述されたフロントエンドと&lt;strong&gt;共有&lt;/strong&gt;し&lt;strong&gt;て、フルスタックWebアプリケーション&lt;/strong&gt;を&lt;strong&gt;記述および維持できます&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="b72e9d9abf32110dc1b1cda54fc1754195041c56" translate="yes" xml:space="preserve">
          <source>If you have a collection of elements of a nullable type and want to filter non-null elements, you can do so by using &lt;code&gt;filterNotNull&lt;/code&gt;:</source>
          <target state="translated">null許容型の要素のコレクションがあり、null以外の要素をフィルタリングする場合は、 &lt;code&gt;filterNotNull&lt;/code&gt; を使用して行うことができます。</target>
        </trans-unit>
        <trans-unit id="3854a89fb1eb0d55d0045c79155df3bda3823777" translate="yes" xml:space="preserve">
          <source>If you have a functional type or a type with type parameters which is used multiple times in a codebase, prefer defining a type alias for it:</source>
          <target state="translated">コードベース内で複数回使用される機能型や型パラメータを持つ型がある場合は、その型のエイリアスを定義することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="160be5812cd4b3879f4656323f6abb0ca91c7f96" translate="yes" xml:space="preserve">
          <source>If you have a platform-specific library that you want to use in common code while providing your own implementation for another platform, you can provide a typealias to an existing class as the actual declaration:</source>
          <target state="translated">他のプラットフォーム向けに独自の実装を提供しつつ、共通コードで使用したいプラットフォーム固有のライブラリがある場合は、実際の宣言として既存のクラスにtypealiasを提供することができます。</target>
        </trans-unit>
        <trans-unit id="322a5539762befa5e3e19013d91d7e3d04d9849f" translate="yes" xml:space="preserve">
          <source>If you have a platform-specific library that you want to use in shared code while providing your own implementation for another platform, you can provide a &lt;code&gt;typealias&lt;/code&gt; to an existing class as the actual declaration:</source>
          <target state="translated">別のプラットフォームに独自の実装を提供しながら共有コードで使用するプラットフォーム固有のライブラリがある場合は、実際の宣言として既存のクラスに型 &lt;code&gt;typealias&lt;/code&gt; を提供できます。</target>
        </trans-unit>
        <trans-unit id="c6e93137d89d2551a056f737e4db196d1978cfc3" translate="yes" xml:space="preserve">
          <source>If you have a value that is truly constant, and the value is a string or a primitive type (see below) that is known at compile-time, you can declare an actual constant instead. You can only do this at the top level of a file or inside an &lt;a href=&quot;objects-and-companion-objects#object-declarations&quot;&gt;object declaration&lt;/a&gt; (but not inside a class declaration):</source>
          <target state="translated">真に定数である値があり、その値がコンパイル時にわかっている文字列またはプリミティブ型（以下を参照）である場合、代わりに実際の定数を宣言できます。これを行うことができるのは、ファイルの最上位または&lt;a href=&quot;objects-and-companion-objects#object-declarations&quot;&gt;オブジェクト宣言の&lt;/a&gt;内部のみです（クラス宣言の内部ではできません）。</target>
        </trans-unit>
        <trans-unit id="b3734595028b6b703699f95d53623d869e9b5b43" translate="yes" xml:space="preserve">
          <source>If you have an account on &lt;a href=&quot;https://stepik.org/&quot;&gt;Stepik&lt;/a&gt;, you can easily upload your course there, update it anytime you need, and &lt;a href=&quot;https://blog.jetbrains.com/pycharm/2017/06/integration-with-stepik-for-educators/&quot;&gt;share publicly or privately&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://stepik.org/&quot;&gt;Stepik&lt;/a&gt;にアカウントがあれば、そこにコースを簡単にアップロードし、必要なときにいつでも更新して、&lt;a href=&quot;https://blog.jetbrains.com/pycharm/2017/06/integration-with-stepik-for-educators/&quot;&gt;公開または非公開で共有&lt;/a&gt;できます。</target>
        </trans-unit>
        <trans-unit id="07988c0863287cce070542583bc572c93b997f2d" translate="yes" xml:space="preserve">
          <source>If you have an archive &lt;code&gt;sample-library.jar&lt;/code&gt;, which contains &lt;code&gt;sample-library.js&lt;/code&gt; and &lt;code&gt;sample-library.meta.js&lt;/code&gt;, you can use the following command</source>
          <target state="translated">&lt;code&gt;sample-library.js&lt;/code&gt; と &lt;code&gt;sample-library.meta.js&lt;/code&gt; を含むアーカイブ &lt;code&gt;sample-library.jar&lt;/code&gt; がある場合は、次のコマンドを使用できます。</target>
        </trans-unit>
        <trans-unit id="8ca8fa744fdcf13cab8a2d83ad8ba290dd0853cd" translate="yes" xml:space="preserve">
          <source>If you have an instance of &lt;code&gt;Generic&amp;lt;Subtype&amp;gt;&lt;/code&gt;, and you want to refer to it as a &lt;code&gt;Generic&amp;lt;Supertype&amp;gt;&lt;/code&gt;, you can safely &lt;em&gt;get&lt;/em&gt; instances of the generic type parameter from it - these will truly be instances of &lt;code&gt;Subtype&lt;/code&gt; (because they come from an instance of &lt;code&gt;Generic&amp;lt;Subtype&amp;gt;&lt;/code&gt;), but they will appear to you as instances of &lt;code&gt;Supertype&lt;/code&gt; (because you've told the compiler that you have a &lt;code&gt;Generic&amp;lt;Supertype&amp;gt;&lt;/code&gt;). This is safe; it is called &lt;em&gt;covariance&lt;/em&gt;, and Kotlin lets you do &lt;em&gt;declaration-site covariance&lt;/em&gt; by putting &lt;code&gt;out&lt;/code&gt; in front of the generic type parameter. If you do, you may only use that type parameter as a return type, not as a parameter type. Here is the simplest useful covariant interface:</source>
          <target state="translated">&lt;code&gt;Generic&amp;lt;Subtype&amp;gt;&lt;/code&gt; インスタンスがあり、それを &lt;code&gt;Generic&amp;lt;Supertype&amp;gt;&lt;/code&gt; として参照したい場合は、そこからジェネリック型パラメーターのインスタンスを安全に&lt;em&gt;取得でき&lt;/em&gt;ます-これらは本当に &lt;code&gt;Subtype&lt;/code&gt; インスタンスになります（これらはインスタンス &lt;code&gt;Generic&amp;lt;Subtype&amp;gt;&lt;/code&gt; ）が、彼らはのインスタンスとしてあなたに表示される &lt;code&gt;Supertype&lt;/code&gt; あなたは、あなたが持っていることをコンパイラに指示しましたので（ &lt;code&gt;Generic&amp;lt;Supertype&amp;gt;&lt;/code&gt; ）。これは安全です。それが呼び出され&lt;em&gt;、共分散&lt;/em&gt;、およびKotlinはあなたが行うことができます&lt;em&gt;宣言サイトの共分散を&lt;/em&gt;入れて &lt;code&gt;out&lt;/code&gt; ジェネリック型パラメーターの前。その場合、その型パラメーターは戻り値の型としてのみ使用でき、パラメーター型としては使用できません。以下は、最も単純で有用な共変インターフェースです。</target>
        </trans-unit>
        <trans-unit id="76b81d78f8b362115f861d43270c94c40851a654" translate="yes" xml:space="preserve">
          <source>If you have an object with multiple overloaded constructors that don't call different superclass constructors and can't be reduced to a single constructor with default argument values, prefer to replace the overloaded constructors with factory functions.</source>
          <target state="translated">複数のオーバーロードされたコンストラクタを持つオブジェクトで、異なるスーパークラスのコンストラクタを呼ばず、デフォルトの引数値を持つ単一のコンストラクタに還元できない場合は、オーバーロードされたコンストラクタをファクトリー関数に置き換えることを好みます。</target>
        </trans-unit>
        <trans-unit id="70df85ffca23dcd7199954503a1af44f76e8932e" translate="yes" xml:space="preserve">
          <source>If you have business logic that is common for all platforms, you don&amp;rsquo;t need to write the same code for each platform &amp;ndash; just share it in the common source set.</source>
          <target state="translated">すべてのプラットフォームに共通のビジネスロジックがある場合は、プラットフォームごとに同じコードを記述する必要はありません。共通のソースセットで共有するだけです。</target>
        </trans-unit>
        <trans-unit id="639c565d65e0763691e2c7a9e8d90030330f0cc8" translate="yes" xml:space="preserve">
          <source>If you have explicitly set your module kind to be &lt;code&gt;plain&lt;/code&gt;, Kotlin creates an object that contains all Kotlin declarations from the current module. This is done to prevent spoiling the global object. This means that for a module &lt;code&gt;myModule&lt;/code&gt;, all declarations are available to JavaScript via the &lt;code&gt;myModule&lt;/code&gt; object. For example:</source>
          <target state="translated">モジュールの種類を &lt;code&gt;plain&lt;/code&gt; に明示的に設定した場合、Kotlinは、現在のモジュールからのすべてのKotlin宣言を含むオブジェクトを作成します。これは、グローバルオブジェクトの破損を防ぐために行われます。これは、モジュール &lt;code&gt;myModule&lt;/code&gt; の場合、すべての宣言が &lt;code&gt;myModule&lt;/code&gt; オブジェクトを介してJavaScriptで使用できることを意味します。例えば：</target>
        </trans-unit>
        <trans-unit id="c8853dee9818f39e3759ffe7b639b9f7bc068972" translate="yes" xml:space="preserve">
          <source>If you have multiple annotations with the same target, you can avoid repeating the target by adding brackets after the target and putting all the annotations inside the brackets:</source>
          <target state="translated">同じターゲットを持つ複数のアノテーションがある場合は、ターゲットの後に括弧を付けて、すべてのアノテーションを括弧の中に入れることで、ターゲットの繰り返しを避けることができます。</target>
        </trans-unit>
        <trans-unit id="f4458460acc96ecaa2c9621b4261e57a18ecc54c" translate="yes" xml:space="preserve">
          <source>If you insist on using a plain editor and the command line, see &lt;a href=&quot;../command-line&quot;&gt;these instructions instead&lt;/a&gt;. In short, you need to &lt;em&gt;compile&lt;/em&gt; your Kotlin code before running it. Assuming that your Kotlin file is called &lt;code&gt;program.kt&lt;/code&gt;:</source>
          <target state="translated">プレーンエディタとコマンドラインの使用を主張する場合は、&lt;a href=&quot;../command-line&quot;&gt;代わりにこれらの手順を&lt;/a&gt;参照してください。つまり、実行する前にKotlinコードを&lt;em&gt;コンパイル&lt;/em&gt;する必要があります。あなたKotlinファイルが呼び出されると仮定すると &lt;code&gt;program.kt&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="ef2b7c0495898685e9252662cc7dfb4430876f43" translate="yes" xml:space="preserve">
          <source>If you intend to use the APIs from the 1.1 Standard Library, or language features that depend on those APIs, you should upgrade the dependency to the version 1.1.</source>
          <target state="translated">1.1 Standard Library の API や、その API に依存する言語機能を使用する場合は、依存関係をバージョン 1.1 にアップグレードする必要があります。</target>
        </trans-unit>
        <trans-unit id="9dac576da363f8811fb3df384398b7619989e0f8" translate="yes" xml:space="preserve">
          <source>If you like a &amp;ldquo;hands-on&amp;rdquo; learning, try &lt;a href=&quot;https://play.kotlinlang.org/koans&quot;&gt;Kotlin Koans online&lt;/a&gt; to get familiar with Kotlin;</source>
          <target state="translated">「実践的な」学習が好きな場合は、&lt;a href=&quot;https://play.kotlinlang.org/koans&quot;&gt;Kotlin Koansをオンライン&lt;/a&gt;で試して、Kotlinに慣れてください。</target>
        </trans-unit>
        <trans-unit id="d82ca3a290ad528cc2bae1e2cb08d2ecdafea630" translate="yes" xml:space="preserve">
          <source>If you mark a declaration &lt;code&gt;private&lt;/code&gt;, it will only be visible inside the file containing the declaration;</source>
          <target state="translated">宣言を &lt;code&gt;private&lt;/code&gt; とマークすると、宣言を含むファイル内でのみ表示されます。</target>
        </trans-unit>
        <trans-unit id="1b38ef20d54a5b26492d65004e55d4d4d8807d1f" translate="yes" xml:space="preserve">
          <source>If you mark it &lt;code&gt;internal&lt;/code&gt;, it is visible everywhere in the same &lt;a href=&quot;#modules&quot;&gt;module&lt;/a&gt;;</source>
          <target state="translated">&lt;code&gt;internal&lt;/code&gt; としてマークすると、同じ&lt;a href=&quot;#modules&quot;&gt;モジュールの&lt;/a&gt;どこにでも表示されます。</target>
        </trans-unit>
        <trans-unit id="23d6510bb7782c43d563dd375dee713e5d305e0b" translate="yes" xml:space="preserve">
          <source>If you need a &lt;em&gt;singleton&lt;/em&gt; - a class that only has got one instance - you can declare the class in the usual way, but use the &lt;code&gt;object&lt;/code&gt; keyword instead of &lt;code&gt;class&lt;/code&gt;:</source>
          <target state="translated">あなたが必要な場合は&lt;em&gt;シングルトン&lt;/em&gt;インスタンスを1つだけ持っているクラスを- -あなたは、通常の方法でクラスを宣言しますが、使用することができ &lt;code&gt;object&lt;/code&gt; の代わりにキーワードを &lt;code&gt;class&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="a043b2872924b750f016ebe9ba4d0f3aca66ca85" translate="yes" xml:space="preserve">
          <source>If you need a dependency only for a specific platform, you can still use platform-specific variants of standard and kotlinx libraries with such suffixes as &lt;code&gt;-jvm&lt;/code&gt; or&lt;code&gt; -js&lt;/code&gt;, for example &lt;code&gt;kotlinx-coroutines-core-jvm&lt;/code&gt;.</source>
          <target state="translated">あなたが唯一の特定のプラットフォームの依存関係が必要な場合でも、プラットフォーム固有のような接尾辞の標準とkotlinxライブラリのバリアントを使用することができます &lt;code&gt;-jvm&lt;/code&gt; または &lt;code&gt; -js&lt;/code&gt; 例えば、 &lt;code&gt;kotlinx-coroutines-core-jvm&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fc8467398b87bfa40771e50f53a8a177a25657b1" translate="yes" xml:space="preserve">
          <source>If you need a fancier way of reading or writing file data, you have access to the full Java suite of I/O classes - in particular, &lt;code&gt;Scanner&lt;/code&gt;, which can parse numbers and other data types from files or other streams, and &lt;code&gt;BufferedReader&lt;/code&gt; (which is good for efficient reading of large amounts of data), which you can obtain by calling &lt;code&gt;bufferedReader()&lt;/code&gt; on a file or stream. See any Java tutorial for how to use these.</source>
          <target state="translated">ファイルデータの読み書きをより洗練された方法で行う必要がある場合は、I / Oクラスの完全なJavaスイートにアクセスできます。特に、ファイルやその他のストリームから数値やその他のデータ型を解析できる &lt;code&gt;Scanner&lt;/code&gt; や、 &lt;code&gt;BufferedReader&lt;/code&gt; （これには大量のデータを効率的に読み取るのに適しています）。これは、ファイルまたはストリームで &lt;code&gt;bufferedReader()&lt;/code&gt; を呼び出すことで取得できます。これらの使用方法については、Javaチュートリアルを参照してください。</target>
        </trans-unit>
        <trans-unit id="6f682f64379a16ca3dc7552b97dee19da35ecf1f" translate="yes" xml:space="preserve">
          <source>If you need a full report containing the state of each coroutine and its stack, right-click inside the &lt;strong&gt;Coroutines&lt;/strong&gt; tab, and then click &lt;strong&gt;Get Coroutines Dump&lt;/strong&gt;. Currently, the coroutines dump is rather simple, but we&amp;rsquo;re going to make it more readable and helpful in future versions of Kotlin.</source>
          <target state="translated">各コルーチンとそのスタックの状態を含む完全なレポートが必要な場合は、[&lt;strong&gt;コルーチン&lt;/strong&gt;]タブ内を右クリックし、[&lt;strong&gt;コルーチンダンプを取得&lt;/strong&gt;]をクリックします。現在、コルーチンダンプはかなり単純ですが、Kotlinの将来のバージョンでは、より読みやすく、役立つようにする予定です。</target>
        </trans-unit>
        <trans-unit id="54e87845252769ababaaab1c06f5bd872659abd6" translate="yes" xml:space="preserve">
          <source>If you need a function or a property to be tied to a class rather than to instances of it (similar to &lt;code&gt;@staticmethod&lt;/code&gt; in Python), you can declare it inside a &lt;em&gt;companion object&lt;/em&gt;:</source>
          <target state="translated">関数またはプロパティをインスタンスではなくクラスに &lt;code&gt;@staticmethod&lt;/code&gt; がある場合（Pythonの@staticmethodと同様）、&lt;em&gt;コンパニオンオブジェクト&lt;/em&gt;内で宣言でき&lt;em&gt;ます&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="8de1431e2a233483ba705c03102c9221f4f2f632" translate="yes" xml:space="preserve">
          <source>If you need multiple ways to initialize a class, you can create &lt;em&gt;secondary constructors&lt;/em&gt;, each of which looks like a function whose name is &lt;code&gt;constructor&lt;/code&gt;. Every secondary constructor must invoke another (primary or secondary) constructor by using the &lt;code&gt;this&lt;/code&gt; keyword as if it were a function (so that every instance construction eventually calls the primary constructor).</source>
          <target state="translated">クラスを初期化するために複数の方法が必要な場合は、それぞれ &lt;code&gt;constructor&lt;/code&gt; という名前の関数のように見える、&lt;em&gt;2次コンストラクター&lt;/em&gt;を作成できます。すべての2次コンストラクターは、関数のように &lt;code&gt;this&lt;/code&gt; キーワードを使用して、別の（1次または2次）コンストラクターを呼び出す必要があります（そのため、すべてのインスタンス構築が最終的に1次コンストラクターを呼び出します）。</target>
        </trans-unit>
        <trans-unit id="e23221640befe2f0b60d6c58ea9b02d7e3a97b07" translate="yes" xml:space="preserve">
          <source>If you need to access a class implemented in JavaScript from Kotlin in a typesafe way, you can write a Kotlin declaration using the &lt;code&gt;external&lt;/code&gt; modifier. (In Kotlin 1.0, the &lt;code&gt;@native&lt;/code&gt; annotation was used instead.) Unlike the JVM target, the JS one permits to use external modifier with classes and properties. For example, here's how you can declare the DOM &lt;code&gt;Node&lt;/code&gt; class:</source>
          <target state="translated">タイプセーフな方法でKotlinからJavaScriptで実装されたクラスにアクセスする必要がある場合は、 &lt;code&gt;external&lt;/code&gt; 修飾子を使用してKotlin宣言を記述できます。（Kotlin 1.0では、代わりに &lt;code&gt;@native&lt;/code&gt; アノテーションが使用されていました。）JVMターゲットとは異なり、JSはクラスとプロパティで外部修飾子を使用することを許可します。たとえば、DOM &lt;code&gt;Node&lt;/code&gt; クラスを宣言する方法は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="88668422727a4a9adc62e3d3eeac4b8edf7e7d30" translate="yes" xml:space="preserve">
          <source>If you need to access platform-specific APIs from a shared native source set, IntelliJ IDEA will help you detect common declarations that you can use in the shared native code. For other cases, use the Kotlin mechanism of &lt;a href=&quot;mpp-connect-to-apis&quot;&gt;expected and actual declarations&lt;/a&gt;.</source>
          <target state="translated">共有ネイティブソースセットからプラットフォーム固有のAPIにアクセスする必要がある場合、IntelliJ IDEAは、共有ネイティブコードで使用できる一般的な宣言を検出するのに役立ちます。その他の場合は、&lt;a href=&quot;mpp-connect-to-apis&quot;&gt;期待される宣言と実際の宣言の&lt;/a&gt;Kotlinメカニズムを使用します。</target>
        </trans-unit>
        <trans-unit id="f99443af480d55217c4ce0d28159d54e4f7cf72b" translate="yes" xml:space="preserve">
          <source>If you need to access platform-specific APIs from the shared code, use the Kotlin mechanism of &lt;a href=&quot;mpp-connect-to-apis&quot;&gt;expected and actual declarations&lt;/a&gt;.</source>
          <target state="translated">共有コードからプラットフォーム固有のAPIにアクセスする必要がある場合は、&lt;a href=&quot;mpp-connect-to-apis&quot;&gt;予想される宣言と実際の宣言の&lt;/a&gt;Kotlinメカニズムを使用してください。</target>
        </trans-unit>
        <trans-unit id="d4e8082dbfdacd1170b034e190a7f81841b9039b" translate="yes" xml:space="preserve">
          <source>If you need to annotate the primary constructor of a class, you need to add the &lt;em&gt;constructor&lt;/em&gt; keyword to the constructor declaration, and add the annotations before it:</source>
          <target state="translated">クラスのプライマリコンストラクターに注釈を付ける必要がある場合は、&lt;em&gt;コンストラクター&lt;/em&gt;キーワードをコンストラクター宣言に追加し、その前に注釈を追加する必要があります。</target>
        </trans-unit>
        <trans-unit id="e462275c07255513e75672de08e598bdce5e271f" translate="yes" xml:space="preserve">
          <source>If you need to change the visibility of an accessor or to annotate it, but don't need to change the default implementation, you can define the accessor without defining its body:</source>
          <target state="translated">アクセサの可視性を変更したり注釈を付けたりする必要があるが、デフォルトの実装を変更する必要がない場合は、アクセサのボディを定義せずにアクセサを定義することができます。</target>
        </trans-unit>
        <trans-unit id="3059f730cef9912ce6c198f14d3446e4eb2b9509" translate="yes" xml:space="preserve">
          <source>If you need to compile something other than production code and unit tests, for example, integration or performance tests, create a custom compilation.</source>
          <target state="translated">統合テストやパフォーマンステストなど、本番用のコードやユニットテスト以外のものをコンパイルする必要がある場合は、カスタムコンパイルを作成します。</target>
        </trans-unit>
        <trans-unit id="a9bce9b39aad7abcf18408f893ff0de2f69a4bc8" translate="yes" xml:space="preserve">
          <source>If you need to compile something other than production code and unit tests, for example, integration or performance tests, you can &lt;a href=&quot;#create-a-custom-compilation&quot;&gt;create a custom compilation&lt;/a&gt;.</source>
          <target state="translated">統合テストやパフォーマンステストなど、本番コードと単体テスト以外のものをコンパイルする必要がある場合は&lt;a href=&quot;#create-a-custom-compilation&quot;&gt;、カスタムコンパイルを作成&lt;/a&gt;できます。</target>
        </trans-unit>
        <trans-unit id="4613a8244834c0ecb89ce0d825ca742a6fa51707" translate="yes" xml:space="preserve">
          <source>If you need to expose a Kotlin property as a field in Java, annotate it with the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.jvm/-jvm-field/index&quot;&gt;&lt;code&gt;@JvmField&lt;/code&gt;&lt;/a&gt; annotation. The field will have the same visibility as the underlying property. You can annotate a property with &lt;code&gt;@JvmField&lt;/code&gt; if it has a backing field, is not private, does not have &lt;code&gt;open&lt;/code&gt;, &lt;code&gt;override&lt;/code&gt; or &lt;code&gt;const&lt;/code&gt; modifiers, and is not a delegated property.</source>
          <target state="translated">KotlinプロパティをJavaのフィールドとして公開する必要がある場合は、&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.jvm/-jvm-field/index&quot;&gt; &lt;code&gt;@JvmField&lt;/code&gt; &lt;/a&gt;アノテーションを付けます。フィールドは、基になるプロパティと同じ可視性を持ちます。プロパティにバッキングフィールドがあり、プライベートではなく、 &lt;code&gt;open&lt;/code&gt; 、 &lt;code&gt;override&lt;/code&gt; または &lt;code&gt;const&lt;/code&gt; 修飾子がなく、委任されたプロパティでない場合、 &lt;code&gt;@JvmField&lt;/code&gt; プロパティに注釈を付けることができます。</target>
        </trans-unit>
        <trans-unit id="b3648463615f31d33dec14dff446661a5d42afc8" translate="yes" xml:space="preserve">
          <source>If you need to know the index of the current element when you're iterating over something, you can use &lt;code&gt;withIndex()&lt;/code&gt;, which corresponds to &lt;code&gt;enumerate()&lt;/code&gt;. It produces a sequence of objects that have got two properties (the index and the value) and two specially-named accessor functions called &lt;code&gt;component1()&lt;/code&gt; and &lt;code&gt;component2()&lt;/code&gt;; Kotlin lets you destructure such an object into a declaration:</source>
          <target state="translated">何かを反復処理するときに現在の要素のインデックスを知る必要がある場合は、 &lt;code&gt;enumerate()&lt;/code&gt; に対応する &lt;code&gt;withIndex()&lt;/code&gt; を使用できます。これは、2つのプロパティ（インデックスと値）と、 &lt;code&gt;component1()&lt;/code&gt; および &lt;code&gt;component2()&lt;/code&gt; と呼ばれる2つの特別な名前のアクセサ関数を持つオブジェクトのシーケンスを生成します。Kotlinを使用すると、このようなオブジェクトを宣言に分解できます。</target>
        </trans-unit>
        <trans-unit id="89e90e48358e19dcdf7d70c38acd3455ecae2039" translate="yes" xml:space="preserve">
          <source>If you need to know the index of the current element when you're iterating through something, you can use &lt;code&gt;withIndex()&lt;/code&gt;, which corresponds to &lt;code&gt;enumerate()&lt;/code&gt;. It produces a sequence of objects that have got two properties (the index and the value) and two specially-named accessor functions called &lt;code&gt;component1()&lt;/code&gt; and &lt;code&gt;component2()&lt;/code&gt;; Kotlin lets you destructure such an object into a declaration:</source>
          <target state="translated">何かを反復しているときに現在の要素のインデックスを知る必要がある場合は、 &lt;code&gt;enumerate()&lt;/code&gt; に対応する &lt;code&gt;withIndex()&lt;/code&gt; を使用できます。これは、2つのプロパティ（インデックスと値）と、 &lt;code&gt;component1()&lt;/code&gt; および &lt;code&gt;component2()&lt;/code&gt; と呼ばれる2つの特別な名前のアクセサ関数を持つオブジェクトのシーケンスを生成します。Kotlinでは、そのようなオブジェクトを宣言に分解できます。</target>
        </trans-unit>
        <trans-unit id="4c304182ad4dffb827b2cd5041835d4a1290ba5c" translate="yes" xml:space="preserve">
          <source>If you need to look up the class dynamically as well, you can use &lt;code&gt;Class.forName()&lt;/code&gt; and supply the fully-qualified name of the class.</source>
          <target state="translated">クラスも動的に検索する必要がある場合は、 &lt;code&gt;Class.forName()&lt;/code&gt; を使用して、クラスの完全修飾名を指定できます。</target>
        </trans-unit>
        <trans-unit id="fb05e76a6c128f62bf211b270ee1f300cbc3d9aa" translate="yes" xml:space="preserve">
          <source>If you need to retrieve an arbitrary element of a collection, call the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/random&quot;&gt;&lt;code&gt;random()&lt;/code&gt;&lt;/a&gt; function. You can call it without arguments or with a &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.random/-random/index&quot;&gt;&lt;code&gt;Random&lt;/code&gt;&lt;/a&gt; object as a source of the randomness.</source>
          <target state="translated">コレクションの任意の要素を取得する必要がある場合は、&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/random&quot;&gt; &lt;code&gt;random()&lt;/code&gt; &lt;/a&gt;関数を呼び出します。引数なしで、またはランダム性のソースとして&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.random/-random/index&quot;&gt; &lt;code&gt;Random&lt;/code&gt; &lt;/a&gt;オブジェクトを使用して呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="2c6c6ff6a76abad65e2d1d67dae2bda5a0418cb0" translate="yes" xml:space="preserve">
          <source>If you need to retrieve the collection content in a readable format, use functions that transform the collections to strings: &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/join-to-string&quot;&gt;&lt;code&gt;joinToString()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/join-to&quot;&gt;&lt;code&gt;joinTo()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">コレクションのコンテンツを読み取り可能な形式で取得する必要がある場合は、コレクションを文字列に変換する関数&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/join-to-string&quot;&gt; &lt;code&gt;joinToString()&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/join-to&quot;&gt; &lt;code&gt;joinTo()&lt;/code&gt; を使用し&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="27633af274eff8d8c59fb2e4a25231c59018307c" translate="yes" xml:space="preserve">
          <source>If you need to specify a class as an argument of an annotation, use a Kotlin class (&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.reflect/-k-class/index&quot;&gt;KClass&lt;/a&gt;). The Kotlin compiler will automatically convert it to a Java class, so that the Java code can access the annotations and arguments normally.</source>
          <target state="translated">アノテーションの引数としてクラスを指定する必要がある場合は、Kotlinクラス（&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.reflect/-k-class/index&quot;&gt;KClass&lt;/a&gt;）を使用してください。Kotlinコンパイラはそれを自動的にJavaクラスに変換するため、Javaコードは通常どおりアノテーションと引数にアクセスできます。</target>
        </trans-unit>
        <trans-unit id="993106f4a5b27e1d574e1151066452d4ad416447" translate="yes" xml:space="preserve">
          <source>If you need to specify a class as an argument of an annotation, use a Kotlin class (&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.reflect/-k-class/index&quot;&gt;KClass&lt;/a&gt;). The Kotlin compiler will automatically convert it to a Java class, so that the Java code will be able to see the annotations and arguments normally.</source>
          <target state="translated">アノテーションの引数としてクラスを指定する必要がある場合は、Kotlinクラス（&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.reflect/-k-class/index&quot;&gt;KClass&lt;/a&gt;）を使用します。Kotlinコンパイラーはそれを自動的にJavaクラスに変換するため、Javaコードは通常、注釈と引数を見ることができます。</target>
        </trans-unit>
        <trans-unit id="7448bb25e266494ddde684c5929327a96a8fb964" translate="yes" xml:space="preserve">
          <source>If you need to use a nullable &lt;code&gt;Boolean&lt;/code&gt; in a conditional statement, use &lt;code&gt;if (value == true)&lt;/code&gt; or &lt;code&gt;if (value == false)&lt;/code&gt; checks.</source>
          <target state="translated">条件ステートメントでnull許容の &lt;code&gt;Boolean&lt;/code&gt; を使用する必要がある場合は、 &lt;code&gt;if (value == true)&lt;/code&gt; または &lt;code&gt;if (value == false)&lt;/code&gt; チェックを使用します。</target>
        </trans-unit>
        <trans-unit id="2c201a6c8803ec9d0564e44a48fc6ef8489585c2" translate="yes" xml:space="preserve">
          <source>If you need to write a function that can be called without having a class instance but needs access to the internals of a class (for example, a factory method), you can write it as a member of an &lt;a href=&quot;object-declarations&quot;&gt;object declaration&lt;/a&gt; inside that class.</source>
          <target state="translated">クラスインスタンスがなくても呼び出すことができるが、クラスの内部（たとえば、ファクトリメソッド）にアクセスする必要がある関数を記述する必要がある場合は、そのクラス内の&lt;a href=&quot;object-declarations&quot;&gt;オブジェクト宣言の&lt;/a&gt;メンバーとして関数を記述できます。</target>
        </trans-unit>
        <trans-unit id="5f584df433485780683ca571ae5a89e659948c6b" translate="yes" xml:space="preserve">
          <source>If you only want to call the function and don't care about the metadata, use a function type, e.g. &lt;code&gt;(A, B) -&amp;gt; V&lt;/code&gt; for an ordinary function reference or a bound member function reference, or &lt;code&gt;A.(B, C) -&amp;gt; V&lt;/code&gt; for an unbound member function reference on &lt;code&gt;A&lt;/code&gt;. Note that &lt;code&gt;KFunction&amp;lt;V&amp;gt;&lt;/code&gt; and its subinterfaces are only available for declared functions (obtained either by explicitly referencing it in the code, or through reflection, as shown later) - only function types are available for function literals (lambda expressions or anonymous functions).</source>
          <target state="translated">関数を呼び出すだけでメタデータを気にしない場合は、関数タイプを使用します。例： &lt;code&gt;(A, B) -&amp;gt; V&lt;/code&gt; 通常の関数参照またはバインドされたメンバー関数参照、または &lt;code&gt;A.(B, C) -&amp;gt; V&lt;/code&gt; に結合していないメンバ関数参照の &lt;code&gt;A&lt;/code&gt; 。 &lt;code&gt;KFunction&amp;lt;V&amp;gt;&lt;/code&gt; とそのサブインターフェースは、宣言された関数（コードで明示的に参照するか、後で示すようにリフレクションによって取得）でのみ使用できることに注意してください-関数リテラル（ラムダ式または無名関数）で使用できるのは関数タイプのみです。 。</target>
        </trans-unit>
        <trans-unit id="8014e84399844604d4127e5bfb102e3054b9b7f6" translate="yes" xml:space="preserve">
          <source>If you operate nested collections, you may find the standard library functions that provide flat access to nested collection elements useful.</source>
          <target state="translated">入れ子になったコレクションを操作する場合、入れ子になったコレクション要素へのフラットアクセスを提供する標準ライブラリ関数が便利です。</target>
        </trans-unit>
        <trans-unit id="aa8d397c2c2050d55c50d82eec1a501b49617481" translate="yes" xml:space="preserve">
          <source>If you override a &lt;code&gt;protected&lt;/code&gt; member and do not specify the visibility explicitly, the overriding member will also have &lt;code&gt;protected&lt;/code&gt; visibility.</source>
          <target state="translated">&lt;code&gt;protected&lt;/code&gt; メンバーをオーバーライドし、可視性を明示的に指定しない場合、オーバーライドするメンバーも可視性を &lt;code&gt;protected&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="bd8f947a24ab8c99f576a413b868a14fd70348dc" translate="yes" xml:space="preserve">
          <source>If you previously used the &lt;a href=&quot;https://developer.android.com/studio/build/gradle-plugin-3-0-0-migration.html#annotationProcessor_config&quot;&gt;Android support&lt;/a&gt; for annotation processors, replace usages of the &lt;code&gt;annotationProcessor&lt;/code&gt; configuration with &lt;code&gt;kapt&lt;/code&gt;. If your project contains Java classes, &lt;code&gt;kapt&lt;/code&gt; will also take care of them.</source>
          <target state="translated">以前にアノテーションプロセッサの&lt;a href=&quot;https://developer.android.com/studio/build/gradle-plugin-3-0-0-migration.html#annotationProcessor_config&quot;&gt;Androidサポート&lt;/a&gt;を使用していた場合は、 &lt;code&gt;annotationProcessor&lt;/code&gt; 構成の使用法を &lt;code&gt;kapt&lt;/code&gt; に置き換えます。プロジェクトにJavaクラスが含まれている場合、 &lt;code&gt;kapt&lt;/code&gt; もそれらを処理します。</target>
        </trans-unit>
        <trans-unit id="94aa78de26a564fc468e55c702b46b061a65c43e" translate="yes" xml:space="preserve">
          <source>If you publish multiple independent features that require opt-in, declare an annotation for each. This makes the use of API safer for your clients: they can use only the features that they explicitly accept. This also lets you remove the opt-in requirements from the features independently.</source>
          <target state="translated">オプトインが必要な独立した機能を複数公開する場合は、それぞれにアノテーションを宣言します。これにより、クライアントは明示的に受け入れた機能のみを使用することができ、APIをより安全に使用することができます。これにより、機能から独立してオプトイン要件を削除することもできます。</target>
        </trans-unit>
        <trans-unit id="3126f475d393c0188e7088d866ab3c517a722979" translate="yes" xml:space="preserve">
          <source>If you publish several features in the experimental state, declare a marker for each. Separate markers make the use of experimental features safer for your clients: they'll be able to use only the features that they explicitly accept. This also lets you graduate the features to stable independently.</source>
          <target state="translated">実験的な状態で複数の機能を公開する場合は、それぞれにマーカーを宣言します。マーカーを分けておくことで、実験的な機能をより安全に使用することができます。これにより、機能を独立して安定版に移行させることができます。</target>
        </trans-unit>
        <trans-unit id="df8a586d7260c254feebf62ecf6abe57e497a3fe" translate="yes" xml:space="preserve">
          <source>If you really really need a mixed-type collection, you can use the element type &lt;code&gt;Any&lt;/code&gt; - but you'll need typecasting to get the elements back to their proper type again, so if what you want is a multiple-value return from a function, please use the per-element-typed &lt;code&gt;Pair&lt;/code&gt; or &lt;code&gt;Triple&lt;/code&gt; instead. If you need four or more elements, consider making a &lt;a href=&quot;classes#data-classes&quot;&gt;data class&lt;/a&gt; for the return type instead (which you should ideally do for two or three elements as well, especially if it's a public function, since it gives you proper names for the elements) - it's very easy and usually a oneliner.</source>
          <target state="translated">本当に混合型のコレクションが必要な場合は、要素型 &lt;code&gt;Any&lt;/code&gt; を使用できますが、要素を適切な型に戻すには型キャストが必要になるため、関数から複数の値を返す場合は、代わりに要素ごとに型指定された &lt;code&gt;Pair&lt;/code&gt; または &lt;code&gt;Triple&lt;/code&gt; を使用してください。4つ以上の要素が必要な場合は、代わりに戻り値の型の&lt;a href=&quot;classes#data-classes&quot;&gt;データクラス&lt;/a&gt;を作成することを検討してください（2つまたは3つの要素にも理想的です。特に、それが要素の適切な名前を提供するため、パブリック関数の場合）。とても簡単で、通常はワンライナーです。</target>
        </trans-unit>
        <trans-unit id="cbc8324a9f6502600707b1d372c5b0e01758d5e6" translate="yes" xml:space="preserve">
          <source>If you really want to, you can both initialize and specify the type on the same line. This is mostly useful if you're dealing with a class hierarchy (more on that later) and you want the variable type to be a base type of the value's class:</source>
          <target state="translated">本当に必要ならば、初期化と型の指定を同じ行で行うことができます。これは、クラス階層を扱っていて(これについては後述します)、変数の型を値のクラスのベース型にしたい場合に便利です。</target>
        </trans-unit>
        <trans-unit id="c6599b66c1550e4e193ba560f565b728a822797c" translate="yes" xml:space="preserve">
          <source>If you run a command-line compiler, add the compiler arguments directly to the utility call or write them into an &lt;a href=&quot;#argfile&quot;&gt;argfile&lt;/a&gt;. For example:</source>
          <target state="translated">コマンドラインコンパイラを実行する場合は、コンパイラ引数をユーティリティ呼び出しに直接追加するか、&lt;a href=&quot;#argfile&quot;&gt;argfileに&lt;/a&gt;書き込みます。例えば：</target>
        </trans-unit>
        <trans-unit id="13648197906f478e28c0bcf3383cb817c3e322b6" translate="yes" xml:space="preserve">
          <source>If you run the above code you'll see that it does not always print zero, though it may depend on the timings of your machine you may need to tweak timeouts in this example to actually see non-zero values.</source>
          <target state="translated">上記のコードを実行してみると、常にゼロを表示しているわけではないことがわかるでしょう。</target>
        </trans-unit>
        <trans-unit id="dd3a00df64d22ebf69e57bb704a9d62539a93298" translate="yes" xml:space="preserve">
          <source>If you start by replacing &lt;code&gt;GlobalScope.launch&lt;/code&gt; by &lt;code&gt;thread&lt;/code&gt;, the compiler produces the following error:</source>
          <target state="translated">&lt;code&gt;GlobalScope.launch&lt;/code&gt; を &lt;code&gt;thread&lt;/code&gt; で置き換えることから始めると、コンパイラーは次のエラーを生成します。</target>
        </trans-unit>
        <trans-unit id="1244c242be7001db0fa42d5a34807cd464a4c723" translate="yes" xml:space="preserve">
          <source>If you start by replacing &lt;code&gt;GlobalScope.launch&lt;/code&gt; with &lt;code&gt;thread&lt;/code&gt;, the compiler produces the following error:</source>
          <target state="translated">&lt;code&gt;GlobalScope.launch&lt;/code&gt; を &lt;code&gt;thread&lt;/code&gt; に置き換えることから始めると、コンパイラーは次のエラーを生成します。</target>
        </trans-unit>
        <trans-unit id="589b4c81823f6922542c45e2902c148531d2b494" translate="yes" xml:space="preserve">
          <source>If you target JavaScript, use the &lt;code&gt;stdlib-js&lt;/code&gt; dependency.</source>
          <target state="translated">JavaScriptをターゲットにする場合は、 &lt;code&gt;stdlib-js&lt;/code&gt; 依存関係を使用します。</target>
        </trans-unit>
        <trans-unit id="bf587872264afbd1369b320aaae73dd1b3673d1b" translate="yes" xml:space="preserve">
          <source>If you use &lt;a href=&quot;kapt&quot;&gt;kapt&lt;/a&gt;, note that the kapt annotation processing tasks are not cached by default. However, you can &lt;a href=&quot;kapt#gradle-build-cache-support-since-1220&quot;&gt;enable caching for them manually&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;kapt&quot;&gt;kapt&lt;/a&gt;を使用する場合、kaptアノテーション処理タスクはデフォルトではキャッシュされないことに注意してください。ただし、&lt;a href=&quot;kapt#gradle-build-cache-support-since-1220&quot;&gt;手動でキャッシュを有効にする&lt;/a&gt;ことができます。</target>
        </trans-unit>
        <trans-unit id="39efa722c74de834ad1bd8a4e4c201bd7dac494b" translate="yes" xml:space="preserve">
          <source>If you use &lt;a href=&quot;kapt&quot;&gt;kapt&lt;/a&gt;, note that the kapt annotation processing tasks are not cached by default. However, you can enable caching for them manually. See the &lt;a href=&quot;kapt#gradle-build-cache-support-since-1220&quot;&gt;kapt page&lt;/a&gt; for details.</source>
          <target state="translated">&lt;a href=&quot;kapt&quot;&gt;kapt&lt;/a&gt;を使用する場合、kaptアノテーション処理タスクはデフォルトではキャッシュされないことに注意してください。ただし、それらのキャッシュを手動で有効にすることができます。詳細については、&lt;a href=&quot;kapt#gradle-build-cache-support-since-1220&quot;&gt;kaptページ&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="a73c7aeee6bdc5c7806d3e53e9294fc8ac4610bf" translate="yes" xml:space="preserve">
          <source>If you use Spring, you can enable the &lt;em&gt;kotlin-spring&lt;/em&gt; compiler plugin instead of specifying Spring annotations manually. The kotlin-spring is a wrapper on top of all-open, and it behaves exactly the same way.</source>
          <target state="translated">Springを使用する場合は、Springアノテーションを手動で指定する代わりに、&lt;em&gt;kotlin-spring&lt;/em&gt;コンパイラプラグインを有効にすることができます。kotlin-springはall-openのラッパーであり、まったく同じように動作します。</target>
        </trans-unit>
        <trans-unit id="611d8f619bf7a7948c981fe9d16f096526d50981" translate="yes" xml:space="preserve">
          <source>If you use a kotlinx library and need a platform-specific dependency, you can use platform-specific variants of libraries with suffixes such as &lt;code&gt;-jvm&lt;/code&gt; or &lt;code&gt;-js&lt;/code&gt;, for example, &lt;code&gt;kotlinx-coroutines-core-jvm&lt;/code&gt;. You can also use the library base artifact name instead &amp;ndash; &lt;code&gt;kotlinx-coroutines-core&lt;/code&gt;.</source>
          <target state="translated">kotlinxライブラリを使用していて、プラットフォーム固有の依存関係が必要な場合は、 &lt;code&gt;-jvm&lt;/code&gt; や &lt;code&gt;-js&lt;/code&gt; などのサフィックスが付いたライブラリのプラットフォーム固有のバリアントを使用できます（例： &lt;code&gt;kotlinx-coroutines-core-jvm&lt;/code&gt; )。代わりに、ライブラリベースのアーティファクト名 &lt;code&gt;kotlinx-coroutines-core&lt;/code&gt; 使用することもできます。</target>
        </trans-unit>
        <trans-unit id="7efa55746211a1f8112a9a60777f3c462da2efbd" translate="yes" xml:space="preserve">
          <source>If you use a multiplatform library and need to depend on the shared code, set the dependency only once in the shared source set. Use the library base artifact name, such as &lt;code&gt;kotlinx-coroutines-core&lt;/code&gt; or &lt;code&gt;ktor-client-core&lt;/code&gt;.</source>
          <target state="translated">マルチプラットフォームライブラリを使用していて、共有コードに依存する必要がある場合は、共有ソースセットで依存関係を1回だけ設定してください。 &lt;code&gt;kotlinx-coroutines-core&lt;/code&gt; や &lt;code&gt;ktor-client-core&lt;/code&gt; などのライブラリベースアーティファクト名を使用します。</target>
        </trans-unit>
        <trans-unit id="1bce77e8c93a7ca161789d86b2fef454e9ed0e0f" translate="yes" xml:space="preserve">
          <source>If you use annotation processors for your &lt;code&gt;androidTest&lt;/code&gt; or &lt;code&gt;test&lt;/code&gt; sources, the respective &lt;code&gt;kapt&lt;/code&gt; configurations are named &lt;code&gt;kaptAndroidTest&lt;/code&gt; and &lt;code&gt;kaptTest&lt;/code&gt;. Note that &lt;code&gt;kaptAndroidTest&lt;/code&gt; and &lt;code&gt;kaptTest&lt;/code&gt; extends &lt;code&gt;kapt&lt;/code&gt;, so you can just provide the &lt;code&gt;kapt&lt;/code&gt; dependency and it will be available both for production sources and tests.</source>
          <target state="translated">&lt;code&gt;androidTest&lt;/code&gt; または &lt;code&gt;test&lt;/code&gt; ソースにアノテーションプロセッサを使用する場合、それぞれの &lt;code&gt;kapt&lt;/code&gt; 構成は &lt;code&gt;kaptAndroidTest&lt;/code&gt; および &lt;code&gt;kaptTest&lt;/code&gt; という名前になります。ことを注意 &lt;code&gt;kaptAndroidTest&lt;/code&gt; と &lt;code&gt;kaptTest&lt;/code&gt; が拡張 &lt;code&gt;kapt&lt;/code&gt; を、あなたはただ提供することができます &lt;code&gt;kapt&lt;/code&gt; の依存関係を、それが両方の生産源とテストのために利用できるようになります。</target>
        </trans-unit>
        <trans-unit id="e98efb35675e1c9619917853c6319e94bee5daa4" translate="yes" xml:space="preserve">
          <source>If you use libraries published with metadata, you only have to specify dependencies on them only once in the shared source set, as opposed to specifying dependencies on different variants of the same library in the shared and platform-specific source sets prior to 1.4.0.</source>
          <target state="translated">メタデータ付きで公開されているライブラリを使用する場合、1.4.0以前の共有ソースセットとプラットフォーム固有のソースセットでは、同じライブラリの異なるバリアントの依存関係を指定していたのに対し、共有ソースセットでは1回だけ依存関係を指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="33f8dde1a7f866c06f2a153c28219ec09cc0d77e" translate="yes" xml:space="preserve">
          <source>If you use opt-in requirements for features that are not stable yet, carefully handle the API graduation to avoid breaking the client code.</source>
          <target state="translated">まだ安定していない機能にオプトイン要件を使用する場合は、クライアントコードを壊さないようにAPIの卒業を慎重に処理してください。</target>
        </trans-unit>
        <trans-unit id="8e5fa9bba802b4996dceed857e221c7dc79c3552" translate="yes" xml:space="preserve">
          <source>If you use the NV Kotlin compiler and have the OV standard library or the OV reflection library in the classpath, it can be a sign that the project is misconfigured. To prevent unexpected problems during compilation or at runtime, we suggest either updating the dependencies to NV, or specifying the API version / language version arguments explicitly. Otherwise the compiler detects that something can go wrong and reports a warning.</source>
          <target state="translated">NVのKotlinコンパイラを使用していて、クラスパスにOV標準ライブラリやOV反射ライブラリがある場合、プロジェクトの設定が間違っているサインである可能性があります。コンパイル中や実行時の予期せぬ問題を防ぐために、依存関係をNVに更新するか、APIバージョン/言語バージョンの引数を明示的に指定することをお勧めします。そうしないと、コンパイラは何かが間違っている可能性があることを検出し、警告を報告します。</target>
        </trans-unit>
        <trans-unit id="f69388ccfa9be1025c7351e156b510d0110f1b95" translate="yes" xml:space="preserve">
          <source>If you want a literal &lt;code&gt;$&lt;/code&gt;, you need to escape it: &lt;code&gt;\$&lt;/code&gt;. Escaping generally works the same way as in Python, with a similar set of standard escape sequences.</source>
          <target state="translated">リテラル &lt;code&gt;$&lt;/code&gt; が必要な場合は、エスケープする必要があります： &lt;code&gt;\$&lt;/code&gt; 。エスケープは通常、Pythonと同じように機能し、類似した標準エスケープシーケンスのセットを使用します。</target>
        </trans-unit>
        <trans-unit id="542e15c450e9d7499e5b8e3fd1eff9a8b7386f93" translate="yes" xml:space="preserve">
          <source>If you want to &lt;strong&gt;start from scratch&lt;/strong&gt;, you can &lt;a href=&quot;jvm-get-started&quot;&gt;create a basic Kotlin application&lt;/a&gt;. Once you&amp;rsquo;ve created the application, you can dive deeper into Kotlin syntax:</source>
          <target state="translated">&lt;strong&gt;ゼロ&lt;/strong&gt;から&lt;strong&gt;始め&lt;/strong&gt;たい場合は&lt;a href=&quot;jvm-get-started&quot;&gt;、基本的なKotlinアプリケーションを作成&lt;/a&gt;できます。アプリケーションを作成したら、Kotlin構文をさらに深く掘り下げることができます。</target>
        </trans-unit>
        <trans-unit id="dcc75b83f1a6aedb14b4da0cf0332f54ec31285c" translate="yes" xml:space="preserve">
          <source>If you want to alert callers of possible exceptions when calling Kotlin code from Java, Swift, or Objective-C, you can use the &lt;code&gt;@Throws&lt;/code&gt; annotation. Read more about using this annotation &lt;a href=&quot;java-to-kotlin-interop#checked-exceptions&quot;&gt;for Java&lt;/a&gt; as well as &lt;a href=&quot;native/objc_interop#errors-and-exceptions&quot;&gt;for Swift and Objective-C&lt;/a&gt;.</source>
          <target state="translated">Java、Swift、またはObjective-CからKotlinコードを呼び出すときに発生する可能性のある例外について発信者に警告する場合は、 &lt;code&gt;@Throws&lt;/code&gt; アノテーションを使用できます。このアノテーション&lt;a href=&quot;java-to-kotlin-interop#checked-exceptions&quot;&gt;をJava&lt;/a&gt;だけでなく&lt;a href=&quot;native/objc_interop#errors-and-exceptions&quot;&gt;、SwiftとObjective-Cに&lt;/a&gt;も使用する方法の詳細をご覧ください。</target>
        </trans-unit>
        <trans-unit id="aeb2cd1321a6da714d1670aa5db99ba2841082d1" translate="yes" xml:space="preserve">
          <source>If you want to be able to intercept an assignment and &quot;veto&quot; it, use &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.properties/-delegates/vetoable&quot;&gt;&lt;code&gt;vetoable()&lt;/code&gt;&lt;/a&gt; instead of &lt;code&gt;observable()&lt;/code&gt;. The handler passed to the &lt;code&gt;vetoable&lt;/code&gt; is called &lt;em&gt;before&lt;/em&gt; the assignment of a new property value has been performed.</source>
          <target state="translated">割り当てをインターセプトして「拒否」できるようにするには、 &lt;code&gt;observable()&lt;/code&gt; ではなく&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.properties/-delegates/vetoable&quot;&gt; &lt;code&gt;vetoable()&lt;/code&gt; を&lt;/a&gt;使用します。 &lt;code&gt;vetoable&lt;/code&gt; 渡されたハンドラーは、新しいプロパティ値の割り当てが実行される&lt;em&gt;前&lt;/em&gt;に呼び出されます。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bfcb549b385e785251e8b67f2103cc999018679b" translate="yes" xml:space="preserve">
          <source>If you want to be more explicit about the fact that you're creating a function, you can make an &lt;em&gt;anonymous function&lt;/em&gt;, which is still an expression rather than a declaration:</source>
          <target state="translated">関数を作成しているという事実をより明確にしたい場合は、宣言ではなく式である&lt;em&gt;無名関数&lt;/em&gt;を作成できます。</target>
        </trans-unit>
        <trans-unit id="696e4536ad6464f41098a1506dbe37ed6e039609" translate="yes" xml:space="preserve">
          <source>If you want to check for &lt;em&gt;not&lt;/em&gt; being an instance of a type, use &lt;code&gt;!is&lt;/code&gt;. Note that &lt;code&gt;null&lt;/code&gt; is never an instance of any non-nullable type, but it is always an &quot;instance&quot; of any nullable type (even though it technically isn't an instance, but an absence of any instance).</source>
          <target state="translated">タイプのインスタンスで&lt;em&gt;ない&lt;/em&gt;ことを確認する場合は、 &lt;code&gt;!is&lt;/code&gt; を使用します。 &lt;code&gt;null&lt;/code&gt; はnull可能ではない型のインスタンスではないことに注意してください。ただし、null可能な型の「インスタンス」であることに注意してください（技術的にはインスタンスではなく、インスタンスがない場合でも）。</target>
        </trans-unit>
        <trans-unit id="da257f8128fc0a8ca8d706e6f33a71205b6846f0" translate="yes" xml:space="preserve">
          <source>If you want to customize your builds or run configuration, refer to the Android Studio &lt;a href=&quot;https://developer.android.com/studio/run&quot;&gt;documentation&lt;/a&gt;.</source>
          <target state="translated">ビルドまたは実行構成をカスタマイズする場合は、Android Studioの&lt;a href=&quot;https://developer.android.com/studio/run&quot;&gt;ドキュメントを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="6811d9ac7923673de93e7c6cb86e0dcf12f4b539" translate="yes" xml:space="preserve">
          <source>If you want to declare your module's API as experimental, create an annotation class to use as its &lt;em&gt;experimental marker&lt;/em&gt;. This class must be annotated with &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-experimental/index&quot;&gt;@Experimental&lt;/a&gt;:</source>
          <target state="translated">モジュールのAPIを実験的として宣言する場合は、&lt;em&gt;実験的マーカー&lt;/em&gt;として使用する注釈クラスを作成し&lt;em&gt;ます&lt;/em&gt;。このクラスには&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-experimental/index&quot;&gt;@Experimental&lt;/a&gt;アノテーションを付ける必要があります：</target>
        </trans-unit>
        <trans-unit id="03930681c826a10c017d1c305e0dfdcd631eb099" translate="yes" xml:space="preserve">
          <source>If you want to do something that does not fit into this &quot;implicit backing field&quot; scheme, you can always fall back to having a &lt;em&gt;backing property&lt;/em&gt;:</source>
          <target state="translated">この「暗黙のバッキングフィールド」のスキームに当てはまらないことをしたい場合は、常に&lt;em&gt;バッキングプロパティ&lt;/em&gt;を使用するようにフォールバックでき&lt;em&gt;ます&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="469cbead1816f95552e8fb9afc4584e38910eba1" translate="yes" xml:space="preserve">
          <source>If you want to exclude the last value, use &lt;code&gt;until&lt;/code&gt;:</source>
          <target state="translated">最後の値を除外する場合は、 &lt;code&gt;until&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="21db5d6173e4569eae43123218189b3a3fd619bd" translate="yes" xml:space="preserve">
          <source>If you want to group elements and then apply an operation to all groups at one time, use the function &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/grouping-by&quot;&gt;&lt;code&gt;groupingBy()&lt;/code&gt;&lt;/a&gt;. It returns an instance of the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-grouping/index&quot;&gt;&lt;code&gt;Grouping&lt;/code&gt;&lt;/a&gt; type. The &lt;code&gt;Grouping&lt;/code&gt; instance lets you apply operations to all groups in a lazy manner: the groups are actually built right before the operation execution.</source>
          <target state="translated">要素を&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/grouping-by&quot;&gt; &lt;code&gt;groupingBy()&lt;/code&gt; &lt;/a&gt;から、一度にすべてのグループに操作を適用する場合は、関数groupingBy（）を使用します。これは、&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-grouping/index&quot;&gt; &lt;code&gt;Grouping&lt;/code&gt; &lt;/a&gt;タイプのインスタンスを返します。 &lt;code&gt;Grouping&lt;/code&gt; グループが実際に右の操作を実行する前に構築されています：インスタンスは、あなたが怠惰な方法で、すべてのグループに操作を適用することができます。</target>
        </trans-unit>
        <trans-unit id="03cd0cd3cc1cb5ea27db0072e091a1e185cd704d" translate="yes" xml:space="preserve">
          <source>If you want to have full control over the declarations generated by Dukat, want to apply manual adjustments, or if you're running into trouble with the auto-generated externals, you can also trigger the creation of the declarations for all your npm dependencies manually via the Gradle task &lt;code&gt;generateExternals&lt;/code&gt;. This will generate declarations in a directory titled &lt;code&gt;externals&lt;/code&gt; in your project root. Here, you can review the generated code and copy any parts you would like to use to your source directories.</source>
          <target state="translated">Dukatによって生成された宣言を完全に制御したい場合、手動調整を適用したい場合、または自動生成された外部で問題が発生した場合は、すべてのnpm依存関係の宣言の作成を手動でトリガーすることもできますGradleタスク &lt;code&gt;generateExternals&lt;/code&gt; を介して。これにより、プロジェクトルートの &lt;code&gt;externals&lt;/code&gt; というタイトルのディレクトリに宣言が生成されます。ここで、生成されたコードを確認し、使用するパーツをソースディレクトリにコピーできます。</target>
        </trans-unit>
        <trans-unit id="28c8357f8e591acaadaa35ef0312974da5893976" translate="yes" xml:space="preserve">
          <source>If you want to impose additional constraints, you must use a separate &lt;code&gt;where&lt;/code&gt; clause, in which case the type parameter must be a subclass of the given class (if you specify a class, and you can specify at most one) &lt;em&gt;and&lt;/em&gt; implement all the given interfaces. You may then access all the public members of all the given types whenever you've got a value of type &lt;code&gt;T&lt;/code&gt;:</source>
          <target state="translated">追加の制約を課したい場合は、別個の &lt;code&gt;where&lt;/code&gt; 句を使用する必要があります。その場合、typeパラメータは特定のクラスのサブクラスでなければならず（クラスを指定し、最大で1つを指定できる場合）、特定のすべて&lt;em&gt;を&lt;/em&gt;実装します。インターフェース。その後、型 &lt;code&gt;T&lt;/code&gt; の値を取得すると、指定されたすべての型のすべてのパブリックメンバーにアクセスできます。</target>
        </trans-unit>
        <trans-unit id="1e91febbc6ec64c3a83c00953396a7246b3b6ef2" translate="yes" xml:space="preserve">
          <source>If you want to intercept assignments and &quot;veto&quot; them, use &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.properties/-delegates/vetoable&quot;&gt;&lt;code&gt;vetoable()&lt;/code&gt;&lt;/a&gt; instead of &lt;code&gt;observable()&lt;/code&gt;. The handler passed to the &lt;code&gt;vetoable&lt;/code&gt; is called &lt;em&gt;before&lt;/em&gt; the assignment of a new property value has been performed.</source>
          <target state="translated">割り当てをインターセプトして「拒否」する場合は、 &lt;code&gt;observable()&lt;/code&gt; の代わりに&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.properties/-delegates/vetoable&quot;&gt; &lt;code&gt;vetoable()&lt;/code&gt; を&lt;/a&gt;使用します。 &lt;code&gt;vetoable&lt;/code&gt; に渡されたハンドラーは、新しいプロパティ値の割り当てが実行される&lt;em&gt;前&lt;/em&gt;に呼び出されます。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ad4ce20803bf2d9ea3efb4e51b2111ecb76db405" translate="yes" xml:space="preserve">
          <source>If you want to iterate through an array or a list with an index, you can do it this way:</source>
          <target state="translated">インデックスを持つ配列やリストを反復処理したい場合は、このようにします。</target>
        </trans-unit>
        <trans-unit id="125c434fa84549730a675353dd139689f7b256f9" translate="yes" xml:space="preserve">
          <source>If you want to keep a whole package or module from elimination, you can use its fully qualified name as it appears in the generated JavaScript code.</source>
          <target state="translated">パッケージやモジュール全体を削除しないようにしたい場合は、生成された JavaScript コードに表示される完全修飾名を使うことができます。</target>
        </trans-unit>
        <trans-unit id="c6675875ca0e15a9e0e94e4e62bcc35aa2271753" translate="yes" xml:space="preserve">
          <source>If you want to keep your code compatible with the 1.0 standard library, you can pass &lt;code&gt;-api-version 1.0&lt;/code&gt;.</source>
          <target state="translated">コードを1.0標準ライブラリと互換性を維持したい場合は、 &lt;code&gt;-api-version 1.0&lt;/code&gt; を渡すことができます。</target>
        </trans-unit>
        <trans-unit id="a90f40cf003c1ca63835c4f5252dade99a0b6302" translate="yes" xml:space="preserve">
          <source>If you want to learn different Kotlin features, try &lt;a href=&quot;koans&quot;&gt;Kotlin Koans&lt;/a&gt;.</source>
          <target state="translated">Kotlinのさまざまな機能を学びたい場合は、&lt;a href=&quot;koans&quot;&gt;Kotlin Koansを&lt;/a&gt;試してください。</target>
        </trans-unit>
        <trans-unit id="00db4d51336388a60b35cfdb52f35a642fd46d81" translate="yes" xml:space="preserve">
          <source>If you want to look at the metadata of a function (e.g. its name), use &lt;code&gt;KFunction&amp;lt;V&amp;gt;&lt;/code&gt; or one of its subinterfaces, where &lt;code&gt;V&lt;/code&gt; is the function's return type. Here's a basic example:</source>
          <target state="translated">あなたは、関数のメタデータ（例えば、名前）、使用を見たい場合は &lt;code&gt;KFunction&amp;lt;V&amp;gt;&lt;/code&gt; またはそのサブインタフェースの1、 &lt;code&gt;V&lt;/code&gt; は、関数の戻り値の型です。基本的な例は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="5b301496262ace39d5d4ef8977ee4d6171448d2c" translate="yes" xml:space="preserve">
          <source>If you want to make further adjustments to the webpack configuration, place your additional configuration files inside a directory called &lt;code&gt;webpack.config.d&lt;/code&gt; in the root of your project. When building your project, all &lt;code&gt;.js&lt;/code&gt; configuration files will automatically be merged into the &lt;code&gt;build/js/packages/projectName/webpack.config.js&lt;/code&gt; file. To add a new &lt;a href=&quot;https://webpack.js.org/loaders/&quot;&gt;webpack loader&lt;/a&gt;, for example, add the following to a &lt;code&gt;.js&lt;/code&gt; file inside the &lt;code&gt;webpack.config.d&lt;/code&gt;:</source>
          <target state="translated">webpack構成をさらに調整する場合は、プロジェクトのルートにある &lt;code&gt;webpack.config.d&lt;/code&gt; というディレクトリ内に追加の構成ファイルを配置します。プロジェクトをビルドすると、すべての &lt;code&gt;.js&lt;/code&gt; 構成ファイルが自動的に &lt;code&gt;build/js/packages/projectName/webpack.config.js&lt;/code&gt; ファイルにマージされます。たとえば、新しい&lt;a href=&quot;https://webpack.js.org/loaders/&quot;&gt;webpackローダー&lt;/a&gt;を追加するには、 &lt;code&gt;webpack.config.d&lt;/code&gt; 内の &lt;code&gt;.js&lt;/code&gt; ファイルに以下を追加します。</target>
        </trans-unit>
        <trans-unit id="49c6ac403c1f5c69a934ea0d8c7e8d3612d277ad" translate="yes" xml:space="preserve">
          <source>If you want to require explicit consent to using your module's API, create an annotation class to use as an &lt;em&gt;opt-in requirement annotation&lt;/em&gt;. This class must be annotated with &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-requires-opt-in/index&quot;&gt;@RequiresOptIn&lt;/a&gt;:</source>
          <target state="translated">モジュールのAPIの使用に明示的な同意が必要な場合は、&lt;em&gt;オプトイン要件アノテーション&lt;/em&gt;として使用するアノテーションクラスを作成&lt;em&gt;します&lt;/em&gt;。このクラスには&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-requires-opt-in/index&quot;&gt;@RequiresOptIn&lt;/a&gt;アノテーションを付ける必要があります：</target>
        </trans-unit>
        <trans-unit id="1d1730df83789869c0eec8797d86c76b973936cd" translate="yes" xml:space="preserve">
          <source>If you want to restrict the set of subclasses of a base class, you can declare the base class to be &lt;code&gt;sealed&lt;/code&gt; (which also makes it abstract), in which case you can only declare subclasses in the same file. The compiler then knows the complete set of possible subclasses, which will let you do exhaustive &lt;code&gt;when&lt;/code&gt; expression for all the possible subtypes without the need for an &lt;code&gt;else&lt;/code&gt; clause (and if you add another subclass in the future and forget to update the &lt;code&gt;when&lt;/code&gt;, the compiler will let you know).</source>
          <target state="translated">基本クラスのサブクラスのセットを制限したい場合は、基本クラスを &lt;code&gt;sealed&lt;/code&gt; するように宣言できます（これにより抽象化もできます）。この場合、同じファイルでサブクラスのみを宣言できます。コンパイラーは次に、可能なサブクラスの完全なセットを認識します。これにより、 &lt;code&gt;else&lt;/code&gt; 節を必要とせずにすべての可能なサブタイプの &lt;code&gt;when&lt;/code&gt; 式を網羅的に実行できます（将来、別のサブクラスを追加して &lt;code&gt;when&lt;/code&gt; の更新を忘れた場合、コンパイラーお知らせします）。</target>
        </trans-unit>
        <trans-unit id="24aa907f13ca700b9ceeaa1262123234a9393fc1" translate="yes" xml:space="preserve">
          <source>If you want to see all available options run</source>
          <target state="translated">利用可能なオプションをすべて表示したい場合は、次のように実行してください。</target>
        </trans-unit>
        <trans-unit id="2d21aa936de4e7ff46724ca50ee4a418c4b5e521" translate="yes" xml:space="preserve">
          <source>If you want to see how your task will be look to the learner, right-click the &lt;code&gt;Task.kt&lt;/code&gt; file in the &lt;strong&gt;Project&lt;/strong&gt; tool window, and choose &lt;strong&gt;Course Creator -&amp;gt; Show Preview&lt;/strong&gt;:</source>
          <target state="translated">タスクが学習者にどのように見えるかを確認したい場合は、&lt;strong&gt;プロジェクト&lt;/strong&gt;ツールウィンドウで &lt;code&gt;Task.kt&lt;/code&gt; ファイルを右クリックし、&lt;strong&gt;コース作成者-&amp;gt;プレビューを表示&lt;/strong&gt;を選択します。&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9a25bc71220d18fbd536e1d59a05a1130584e1bb" translate="yes" xml:space="preserve">
          <source>If you want to skip tests, add the line &lt;code&gt;enabled = false&lt;/code&gt; to the &lt;code&gt;testTask&lt;/code&gt;.</source>
          <target state="translated">あなたは、テストをスキップする行を追加したい場合は &lt;code&gt;enabled = false&lt;/code&gt; の &lt;code&gt;testTask&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="81dec7b57d1ae160cc859398f6b261d2b3f48fa4" translate="yes" xml:space="preserve">
          <source>If you want to specify a custom label for the link, use the Markdown reference-style syntax:</source>
          <target state="translated">リンクにカスタムラベルを指定したい場合は、Markdown参照スタイルの構文を使用します。</target>
        </trans-unit>
        <trans-unit id="e8b98cb29aff85793ce838953d8ec8871fe09a05" translate="yes" xml:space="preserve">
          <source>If you want to start from scratch with the task, use the &lt;strong&gt;Reset&lt;/strong&gt; icon at the top of &lt;strong&gt;Task Description&lt;/strong&gt; panel:</source>
          <target state="translated">タスクを最初から開始する場合は、&lt;strong&gt;タスクの説明&lt;/strong&gt;パネルの上部にある&lt;strong&gt;リセット&lt;/strong&gt;アイコンを使用します。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c377ee38e06516840389b0006f62da827c729d93" translate="yes" xml:space="preserve">
          <source>If you want to start using Kotlin for Android development, read &lt;a href=&quot;https://developer.android.com/kotlin/get-started&quot;&gt;Google&amp;rsquo;s recommendation for getting started with Kotlin on Android&lt;/a&gt;.</source>
          <target state="translated">Android開発でKotlinの使用を開始する場合は、AndroidでKotlinの使用を開始するための&lt;a href=&quot;https://developer.android.com/kotlin/get-started&quot;&gt;Googleの推奨事項をお&lt;/a&gt;読みください。</target>
        </trans-unit>
        <trans-unit id="ef089a53351dae0337ca675a4a633d10abb6eccf" translate="yes" xml:space="preserve">
          <source>If you want to use a value only if it satisfies a certain condition, try &lt;code&gt;takeIf()&lt;/code&gt;, which returns the value it's called on if it satisfies the given predicate, and null otherwise. There's also &lt;code&gt;takeUnless()&lt;/code&gt;, which inverts the logic. You can follow this with a &lt;code&gt;?.&lt;/code&gt; to perform an operation on the value only if it satisfies the predicate. Below, we compute the square of some expression, but only if the expression value is at least 42:</source>
          <target state="translated">特定の条件を満たす場合にのみ値を使用したい場合は、 &lt;code&gt;takeIf()&lt;/code&gt; を試してください。これは、指定された述部を満たす場合に呼び出された値を返し、それ以外の場合はnullを返します。ロジックを反転させる &lt;code&gt;takeUnless()&lt;/code&gt; もあります。これに &lt;code&gt;?.&lt;/code&gt; 付けることができます。述語を満たす場合にのみ、値に対して演算を実行します。以下では、式の2乗を計算しますが、式の値が少なくとも42の場合のみです。</target>
        </trans-unit>
        <trans-unit id="39803479c2452982a2bf2e4068e689f82660ee9c" translate="yes" xml:space="preserve">
          <source>If you want to use dependencies on local pods from Kotlin code, import the corresponding packages.</source>
          <target state="translated">Kotlinコードからローカルポッドへの依存関係を利用したい場合は、対応するパッケージをインポートします。</target>
        </trans-unit>
        <trans-unit id="be96354e6d849f99091812f51218336ab205ca9c" translate="yes" xml:space="preserve">
          <source>If you want to use the EduTools plugin for teaching, read &lt;a href=&quot;edu-tools-educator&quot;&gt;Teaching Kotlin with EduTools plugin&lt;/a&gt;.</source>
          <target state="translated">教育にEduToolsプラグインを使用する場合は、EduToolsプラグインを使用した&lt;a href=&quot;edu-tools-educator&quot;&gt;TeachingKotlinをお&lt;/a&gt;読みください。</target>
        </trans-unit>
        <trans-unit id="67fb2febabe66895070c2641c4d6f978cdb57747" translate="yes" xml:space="preserve">
          <source>If you want to use the EduTools plugin to learn Kotlin, read &lt;a href=&quot;edu-tools-learner&quot;&gt;Learning Kotlin with EduTools plugin&lt;/a&gt;.</source>
          <target state="translated">EduToolsプラグインを使用してKotlinを学習する場合は、EduToolsプラグインを使用したKotlinの&lt;a href=&quot;edu-tools-learner&quot;&gt;学習をお&lt;/a&gt;読みください。</target>
        </trans-unit>
        <trans-unit id="4008289e8be7206e3604bd36b66d2e732e4dca59" translate="yes" xml:space="preserve">
          <source>If you want to use the IR compiler backend for your project, you need to &lt;strong&gt;update all Kotlin dependencies to versions that support this new backend&lt;/strong&gt;. Libraries published by JetBrains for Kotlin 1.4+ targeting Kotlin/JS already contain all artifacts required for usage with the new IR compiler backend.</source>
          <target state="translated">プロジェクトでIRコンパイラバックエンドを使用する場合は、&lt;strong&gt;すべてのKotlin依存関係をこの新しいバックエンドをサポートするバージョン&lt;/strong&gt;に&lt;strong&gt;更新&lt;/strong&gt;する必要があります。JetBrainsがKotlin / JSを対象としてKotlin1.4 +用に公開したライブラリには、新しいIRコンパイラバックエンドでの使用に必要なすべてのアーティファクトがすでに含まれています。</target>
        </trans-unit>
        <trans-unit id="87bc643ce85513f6868cb2e9de9823d1f4369259" translate="yes" xml:space="preserve">
          <source>If you want to write strings gradually, you need to create an &lt;code&gt;OutputStreamWriter&lt;/code&gt; by calling &lt;code&gt;writer()&lt;/code&gt; on the file object. You can write binary data to a file by calling &lt;code&gt;outputStream()&lt;/code&gt; on a file object and use the resulting &lt;code&gt;OutputStream&lt;/code&gt; to write bytes.</source>
          <target state="translated">文字列を徐々に書き込む場合は、ファイルオブジェクトで &lt;code&gt;writer()&lt;/code&gt; を呼び出して、 &lt;code&gt;OutputStreamWriter&lt;/code&gt; を作成する必要があります。ファイルオブジェクトで &lt;code&gt;outputStream()&lt;/code&gt; を呼び出してバイナリデータをファイルに書き込み、結果の &lt;code&gt;OutputStream&lt;/code&gt; を使用してバイトを書き込むことができます。</target>
        </trans-unit>
        <trans-unit id="a41befb145b42cbf8131f21728e484a8a91115d2" translate="yes" xml:space="preserve">
          <source>If you write the same without &lt;code&gt;let&lt;/code&gt;, you'll have to introduce a new variable and repeat its name whenever you use it.</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; なしで同じものを書く場合、新しい変数を導入し、使用するたびにその名前を繰り返す必要があります。</target>
        </trans-unit>
        <trans-unit id="3ea1c290d713b3b54603ea5a070a3770513b0c88" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re developing a multiplatform application that needs to access platform-specific APIs that implement the required functionality, use the Kotlin mechanism of &lt;em&gt;expected and actual declarations&lt;/em&gt;.</source>
          <target state="translated">必要な機能を実装するプラットフォーム固有のAPIにアクセスする必要があるマルチプラットフォームアプリケーションを開発している場合は、&lt;em&gt;予想される宣言と実際の宣言の&lt;/em&gt;Kotlinメカニズムを使用してください。</target>
        </trans-unit>
        <trans-unit id="0a3aaf1f9dd9fea6023de83a437602a5eadebf5e" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re on Ubuntu 16.04 or later, you can install the compiler from the command line:</source>
          <target state="translated">Ubuntu 16.04以降を使用している場合は、コマンドラインからコンパイラをインストールできます。</target>
        </trans-unit>
        <trans-unit id="4ef3b492d472d99a86a122fa8edba6106fbe3c08" translate="yes" xml:space="preserve">
          <source>If you'd rather do &lt;code&gt;x.unsigned&lt;/code&gt;, you can define an extension property:</source>
          <target state="translated">あなたはむしろないと思います場合 &lt;code&gt;x.unsigned&lt;/code&gt; 、あなたは拡張プロパティを定義することができます。</target>
        </trans-unit>
        <trans-unit id="07dd95cbbfcdccfc3f0d530d8306040139f15ae7" translate="yes" xml:space="preserve">
          <source>If you're a &lt;a href=&quot;https://www.macports.org/&quot;&gt;MacPorts&lt;/a&gt; user, you can install the compiler with:</source>
          <target state="translated">あなたがいる場合は&lt;a href=&quot;https://www.macports.org/&quot;&gt;MacPortsのの&lt;/a&gt;ユーザー、あなたがコンパイラをインストールすることができます。</target>
        </trans-unit>
        <trans-unit id="d4d4dba6c4489bae4eb7e70ee6038d13984170c1" translate="yes" xml:space="preserve">
          <source>If you're a library maintainer who is looking to provide compatibility with the default backend as well as the new IR compiler backend, a setting for the compiler selection is available that allows you to create artifacts for both backends, allowing you to keep compatibility for your existing users while providing support for the next generation of Kotlin compiler. This so-called &lt;code&gt;both&lt;/code&gt;-mode can be turned on using the &lt;code&gt;kotlin.js.compiler=both&lt;/code&gt; setting in your &lt;code&gt;gradle.properties&lt;/code&gt; file, or can be set as one of the project-specific options inside your &lt;code&gt;js&lt;/code&gt; block inside the &lt;code&gt;build.gradle(.kts)&lt;/code&gt; file:</source>
          <target state="translated">デフォルトのバックエンドと新しいIRコンパイラバックエンドとの互換性を提供しようとしているライブラリメンテナの場合は、両方のバックエンドのアーティファクトを作成できるコンパイラ選択の設定を使用して、次世代のKotlinコンパイラのサポートを提供しながら、既存のユーザー。このいわゆる &lt;code&gt;both&lt;/code&gt; &lt;code&gt;kotlin.js.compiler=both&lt;/code&gt; は、 &lt;code&gt;gradle.properties&lt;/code&gt; ファイルのkotlin.js.compiler = both設定を使用してオンにするか、 &lt;code&gt;build.gradle(.kts)&lt;/code&gt; 内の &lt;code&gt;js&lt;/code&gt; ブロック内のプロジェクト固有のオプションの1つとして設定できます。.kts）ファイル：</target>
        </trans-unit>
        <trans-unit id="0509d81eee59f0e681a0c3f0c84d5a54a79b4f26" translate="yes" xml:space="preserve">
          <source>If you're developing a library to be used by other Kotlin applications, you can build the &lt;em&gt;.jar&lt;/em&gt; file without including the Kotlin runtime into it.</source>
          <target state="translated">他のKotlinアプリケーションで使用するライブラリを開発している場合は、Kotlinランタイムを含めずに&lt;em&gt;.jar&lt;/em&gt;ファイルをビルドできます。</target>
        </trans-unit>
        <trans-unit id="368782cf6eaff197b952127bcc0c0565b3479378" translate="yes" xml:space="preserve">
          <source>If you're developing a library to be used by other Kotlin applications, you can produce the .jar file without including the Kotlin runtime into it.</source>
          <target state="translated">他のKotlinアプリケーションで使用するライブラリを開発している場合は、Kotlinランタイムを含まずに.jarファイルを作成することができます。</target>
        </trans-unit>
        <trans-unit id="9da5d517a7b5384e2a44811f79965cdbfc0afba2" translate="yes" xml:space="preserve">
          <source>If you're new to Android and want to learn to create applications with Kotlin, check out &lt;a href=&quot;https://www.udacity.com/course/developing-android-apps-with-kotlin--ud9012&quot;&gt;this Udacity course&lt;/a&gt;.</source>
          <target state="translated">Androidを初めて使用し、Kotlinを使用してアプリケーションを作成する方法を学びたい場合は、&lt;a href=&quot;https://www.udacity.com/course/developing-android-apps-with-kotlin--ud9012&quot;&gt;このUdacityコースを&lt;/a&gt;確認してください。</target>
        </trans-unit>
        <trans-unit id="f128e1fe8c8eb81ea54217b5ba66f82b1c59b061" translate="yes" xml:space="preserve">
          <source>If you're new to Kotlin, a good first step would be to familiarise yourself with the &lt;a href=&quot;basic-syntax&quot;&gt;Basic Syntax&lt;/a&gt; of the language.</source>
          <target state="translated">Kotlinを初めて使用する場合、最初のステップとして、言語の&lt;a href=&quot;basic-syntax&quot;&gt;基本構文&lt;/a&gt;を理解することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="766f702953f8980e6bc50e185cc1d656f34dfbc1" translate="yes" xml:space="preserve">
          <source>If you're targeting JDK 7 or JDK 8, you can use extended versions of the Kotlin standard library which contain additional extension functions for APIs added in new JDK versions. Instead of &lt;code&gt;kotlin-stdlib&lt;/code&gt;, use &lt;code&gt;kotlin-stdlib-jdk7&lt;/code&gt; or &lt;code&gt;kotlin-stdlib-jdk8&lt;/code&gt;, depending on your JDK version (for Kotlin 1.1.x use &lt;code&gt;kotlin-stdlib-jre7&lt;/code&gt; and &lt;code&gt;kotlin-stdlib-jre8&lt;/code&gt; as the &lt;code&gt;jdk&lt;/code&gt; counterparts were introduced in 1.2.0).</source>
          <target state="translated">JDK 7またはJDK 8を対象としている場合は、新しいJDKバージョンで追加されたAPIの追加の拡張関数を含むKotlin標準ライブラリの拡張バージョンを使用できます。代わりに &lt;code&gt;kotlin-stdlib&lt;/code&gt; 、使用 &lt;code&gt;kotlin-stdlib-jdk7&lt;/code&gt; または &lt;code&gt;kotlin-stdlib-jdk8&lt;/code&gt; （お使いのJDKのバージョンに応じて、Kotlin 1.1.xの使用を &lt;code&gt;kotlin-stdlib-jre7&lt;/code&gt; と &lt;code&gt;kotlin-stdlib-jre8&lt;/code&gt; として &lt;code&gt;jdk&lt;/code&gt; のカウンターパートは1.2で導入されました.0）。</target>
        </trans-unit>
        <trans-unit id="b775395194955c271aef49dac84498fbe90d7450" translate="yes" xml:space="preserve">
          <source>If you're targeting the JVM platform, you can also use Java's reflection system directly. In this example, we grab a function reference from an object's class by specifying the function's name as a string (if the function takes parameters, you also need to specify their types), and then we call it. Note that we didn't mention &lt;code&gt;String&lt;/code&gt; anywhere - this technique works without knowing what the object's class is, but it will raise an exception if the object's class doesn't have the requested function. However, Java-style function references do not have type information, so you won't get verification of the parameter types, and you must cast the return value:</source>
          <target state="translated">JVMプラットフォームをターゲットにしている場合は、Javaのリフレクションシステムを直接使用することもできます。この例では、関数の名前を文字列として指定してオブジェクトのクラスから関数参照を取得し（関数がパラメーターを取る場合は、その型も指定する必要があります）、それを呼び出します。 &lt;code&gt;String&lt;/code&gt; についてはどこにも触れなかったことに注意してください。この手法はオブジェクトのクラスが何であるかを知らなくても機能しますが、オブジェクトのクラスに要求された関数がない場合は例外が発生します。ただし、Javaスタイルの関数参照には型情報がないため、パラメーターの型の検証は行われず、戻り値をキャストする必要があります。</target>
        </trans-unit>
        <trans-unit id="3a761f12674bd3c30efe00ec7ea6eb2be1927a55" translate="yes" xml:space="preserve">
          <source>If you're targeting the browser and want to use a different module system than UMD, you can specify the desired module type in the &lt;code&gt;webpackTask&lt;/code&gt; configuration block. For example, to switch to CommonJS, use:</source>
          <target state="translated">ブラウザを対象としていて、UMDとは異なるモジュールシステムを使用する場合は、 &lt;code&gt;webpackTask&lt;/code&gt; 構成ブロックで目的のモジュールタイプを指定できます。たとえば、CommonJSに切り替えるには、次を使用します。</target>
        </trans-unit>
        <trans-unit id="5d2933676dc2f7e28b956599b006e00954f9395f" translate="yes" xml:space="preserve">
          <source>If you're using &lt;em&gt;if&lt;/em&gt; as an expression rather than a statement (for example, returning its value or assigning it to a variable), the expression is required to have an &lt;code&gt;else&lt;/code&gt; branch.</source>
          <target state="translated">ステートメントではなく式として&lt;em&gt;if&lt;/em&gt;を使用している&lt;em&gt;場合&lt;/em&gt;（たとえば、その値を返す、または変数に割り当てる）、式には &lt;code&gt;else&lt;/code&gt; 分岐が必要です。</target>
        </trans-unit>
        <trans-unit id="54106dba9eedca9003087d15e44d20a53dd58c38" translate="yes" xml:space="preserve">
          <source>If you're using Gradle, specify the compiler arguments in the &lt;code&gt;kotlinOptions&lt;/code&gt; property of the Kotlin compilation task. For details, see &lt;a href=&quot;using-gradle#compiler-options&quot;&gt;Using Gradle&lt;/a&gt;.</source>
          <target state="translated">Gradleを使用している場合は、Kotlinコンパイルタスクの &lt;code&gt;kotlinOptions&lt;/code&gt; プロパティでコンパイラ引数を指定します。詳細については、&lt;a href=&quot;using-gradle#compiler-options&quot;&gt;Gradleの使用を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="a7e4c1b85a590c2220f5ee4ee7e8642ea497c364" translate="yes" xml:space="preserve">
          <source>If you're using Maven, specify the compiler arguments in the &lt;code&gt;&amp;lt;configuration&amp;gt;&lt;/code&gt; element of the Maven plugin node. For details, see &lt;a href=&quot;using-maven#specifying-compiler-options&quot;&gt;Using Maven&lt;/a&gt;.</source>
          <target state="translated">Mavenを使用している場合は、Mavenプラグインノードの &lt;code&gt;&amp;lt;configuration&amp;gt;&lt;/code&gt; 要素でコンパイラー引数を指定します。詳細については、&lt;a href=&quot;using-maven#specifying-compiler-options&quot;&gt;Mavenの使用を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="51fc2cadbf8df70dee87fb5d749d2ee884d218b0" translate="yes" xml:space="preserve">
          <source>If you're using a generic class whose type parameters haven't been declared in a variant way (either because its authors didn't think of it, or because the type parameters can't have either variance kind because they are used both as parameter types and return types), you can still use it in a variant way thanks to &lt;em&gt;type projection&lt;/em&gt;. The term &quot;projection&quot; refers to the fact that when you do this, you might restrict yourself to using only some of its members - so you're in a sense only seeing a partial, or &quot;projected&quot; version of the class. Let's look again at our &lt;code&gt;Bowl&lt;/code&gt; class, but without the variant interfaces this time:</source>
          <target state="translated">型パラメーターがさまざまな方法で宣言されていないジェネリッククラスを使用している場合（その作成者がそれを考慮していなかったため、または型パラメーターが両方として使用されているため、型パラメーターに分散の種類を指定できないため）パラメータ型と戻り値型）、&lt;em&gt;型プロジェクションの&lt;/em&gt;おかげで、まださまざまな方法で使用できます。 「プロジェクション」という用語は、これを行うと、一部のメンバーのみを使用するように制限する場合があるという事実を意味します。つまり、ある意味では、クラスの部分バージョンまたは「プロジェクション」バージョンのみが表示されます。もう一度、 &lt;code&gt;Bowl&lt;/code&gt; クラスを見てみましょう。ただし、今回はバリアントインターフェイスはありません。</target>
        </trans-unit>
        <trans-unit id="f6e51da97890d2ae9ab3d189065498b378cc4fb2" translate="yes" xml:space="preserve">
          <source>If you've got one string that you want to write to a file, overwriting the existing contents if the file already exists, do this (again, UTF-8 is the default encoding):</source>
          <target state="translated">ファイルに書き込みたい文字列が1つある場合、ファイルがすでに存在する場合は既存の内容を上書きして、このようにします (ここでもデフォルトのエンコーディングは UTF-8 です)。</target>
        </trans-unit>
        <trans-unit id="d91079d5275bf77f335cf6cb84c315d0b54d9ee8" translate="yes" xml:space="preserve">
          <source>If you've just upgraded to Kotlin 1.1 but can not use new language features yet (e.g. because some of your teammates may not have upgraded), you can pass &lt;code&gt;-language-version 1.0&lt;/code&gt;, which will restrict all APIs and language features to 1.0.</source>
          <target state="translated">Kotlin 1.1にアップグレードしたばかりで、まだ新しい言語機能を使用できない場合（たとえば、チームメートの一部がアップグレードしていない可能性があるため）、 &lt;code&gt;-language-version 1.0&lt;/code&gt; を渡すと、すべてのAPIと言語機能が1.0に制限されます。</target>
        </trans-unit>
        <trans-unit id="0bb0fce206872389875749705970d5e6f4cde62d" translate="yes" xml:space="preserve">
          <source>If your Gradle module is a multiplatform module, use the &lt;code&gt;useExperimentalAnnotation&lt;/code&gt; method:</source>
          <target state="translated">Gradleモジュールがマルチプラットフォームモジュールの場合は、 &lt;code&gt;useExperimentalAnnotation&lt;/code&gt; メソッドを使用します。</target>
        </trans-unit>
        <trans-unit id="6a4d49a0aa58db91f5538f1484a110d84d269171" translate="yes" xml:space="preserve">
          <source>If your application already uses DBFlow, you can safely introduce Kotlin into your project. You can gradually convert existing code to Kotlin (ensuring that everything compiles along the way). The converted code doesn't differ much from Java. For instance, declaring a table looks similar to Java with the small difference that default values for properties must be specified explicitly:</source>
          <target state="translated">もしあなたのアプリケーションが既に DBFlow を使用しているのであれば、Kotlin をプロジェクトに安全に導入することができます。既存のコードを徐々にKotlinに変換していくことができます(途中ですべてのコードがコンパイルされることを確認してください)。変換されたコードはJavaとあまり変わりません。例えば、テーブルの宣言は Java と似ていますが、プロパティのデフォルト値を明示的に指定しなければならないという小さな違いがあります。</target>
        </trans-unit>
        <trans-unit id="f63962aa6cf85ec6f47c280bebab4a954c284cd2" translate="yes" xml:space="preserve">
          <source>If your class requires more advanced serialization logic, write it inside a companion class:</source>
          <target state="translated">クラスでより高度なシリアライズ・ロジックが必要な場合は、コンパニオン・クラスの中に記述します。</target>
        </trans-unit>
        <trans-unit id="3503de21b9cb0b7cba965dc4634f2918727f903d" translate="yes" xml:space="preserve">
          <source>If your class requires more advanced serialization logic, you can write it inside a companion class:</source>
          <target state="translated">クラスでより高度なシリアライズロジックが必要な場合は、コンパニオンクラスの中に書くことができます。</target>
        </trans-unit>
        <trans-unit id="eacc53066a886e6486df3248d96a52d89fd95863" translate="yes" xml:space="preserve">
          <source>If your code is too clever for the compiler, and you know without the help of &lt;code&gt;is&lt;/code&gt; that &lt;code&gt;x&lt;/code&gt; is an instance of &lt;code&gt;Person&lt;/code&gt; but the compiler doesn't, you can &lt;em&gt;cast&lt;/em&gt; your value with &lt;code&gt;as&lt;/code&gt;:</source>
          <target state="translated">あなたのコードは、コンパイラのためにあまりにも巧妙で、そしてあなたがの助けなし知っている場合 &lt;code&gt;is&lt;/code&gt; ことを &lt;code&gt;x&lt;/code&gt; のインスタンスである &lt;code&gt;Person&lt;/code&gt; しかし、コンパイラは、次のことができていない&lt;em&gt;キャスト&lt;/em&gt;を使用して値を &lt;code&gt;as&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="2ecf8bd14ee3aa94f5fa13c2b5cd616c3b320e5a" translate="yes" xml:space="preserve">
          <source>If your project uses &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.reflect.full/index&quot;&gt;Kotlin reflection&lt;/a&gt; or testing facilities, you need to add the corresponding dependencies as well. The artifact IDs are &lt;code&gt;kotlin-reflect&lt;/code&gt; for the reflection library, and &lt;code&gt;kotlin-test&lt;/code&gt; and &lt;code&gt;kotlin-test-junit&lt;/code&gt; for the testing libraries.</source>
          <target state="translated">プロジェクトで&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.reflect.full/index&quot;&gt;Kotlinリフレクション&lt;/a&gt;またはテスト機能を使用している場合は、対応する依存関係も追加する必要があります。アーティファクトIDは、リフレクションライブラリの場合は &lt;code&gt;kotlin-reflect&lt;/code&gt; 、テストライブラリの場合は &lt;code&gt;kotlin-test&lt;/code&gt; および &lt;code&gt;kotlin-test-junit&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="aaffb39c3271a99cd3c6b1dcd26285bb7f6d4133" translate="yes" xml:space="preserve">
          <source>If your project uses &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.reflect.full/index&quot;&gt;Kotlin reflection&lt;/a&gt; or testing facilities, you need to add the corresponding dependencies as well:</source>
          <target state="translated">プロジェクトで&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.reflect.full/index&quot;&gt;Kotlinリフレクション&lt;/a&gt;またはテスト機能を使用している場合は、対応する依存関係も追加する必要があります。</target>
        </trans-unit>
        <trans-unit id="ff4ecabd35e3e545f9518b5b102d6fa77c32607a" translate="yes" xml:space="preserve">
          <source>If, by any chance, we need &quot;just an object&quot;, with no nontrivial supertypes, we can simply say:</source>
          <target state="translated">ひょっとして、非自明なスーパータイプを持たない「ただのオブジェクト」が必要な場合は、単純に言えば、「ただのオブジェクト」と言えます。</target>
        </trans-unit>
        <trans-unit id="f78ba0d5d02014df85f65107c7688ad5093fc4b0" translate="yes" xml:space="preserve">
          <source>If, upon updating from one version to another, some code that used to work doesn't work any more, it is an &lt;em&gt;incompatible change&lt;/em&gt; in the language (sometimes referred to as &quot;breaking change&quot;). There can be debates as to what &quot;doesn't work any more&quot; means precisely in some cases, but it definitely includes the following:</source>
          <target state="translated">あるバージョンから別のバージョンに更新したときに、以前は機能していた一部のコードが機能しなくなった場合、それは言語の&lt;em&gt;互換性のない変更&lt;/em&gt;です（「重大な変更」と呼ばれることもあります）。 「これ以上機能しない」が何を意味するのかについては、場合によっては正確に論争がある可能性がありますが、これには間違いなく以下が含まれます。</target>
        </trans-unit>
        <trans-unit id="ea0b39c7ffc510626fe28212437d8a57285e5a4c" translate="yes" xml:space="preserve">
          <source>IllegalArgumentException</source>
          <target state="translated">IllegalArgumentException</target>
        </trans-unit>
        <trans-unit id="906f0c92cf03edbafe4a5d12e37d92701ba25962" translate="yes" xml:space="preserve">
          <source>IllegalCallableAccessException</source>
          <target state="translated">IllegalCallableAccessException</target>
        </trans-unit>
        <trans-unit id="6bfee05d69b5aa826fde5d373d8ebea121200b58" translate="yes" xml:space="preserve">
          <source>IllegalCharacterConversionException</source>
          <target state="translated">IllegalCharacterConversionException</target>
        </trans-unit>
        <trans-unit id="6d13e3edbafba5c6ba6e57ae6bc8267296d1bf66" translate="yes" xml:space="preserve">
          <source>IllegalPropertyDelegateAccessException</source>
          <target state="translated">IllegalPropertyDelegateAccessException</target>
        </trans-unit>
        <trans-unit id="63b3abc14a5b2c9db143083b94887cb72910c4de" translate="yes" xml:space="preserve">
          <source>IllegalStateException</source>
          <target state="translated">IllegalStateException</target>
        </trans-unit>
        <trans-unit id="0ef9de975cdef9d9d9b896b68103ad59db30e33a" translate="yes" xml:space="preserve">
          <source>ImageBitmap</source>
          <target state="translated">ImageBitmap</target>
        </trans-unit>
        <trans-unit id="33f05a29887232f2adef5f1b64b04d6cf8bd78f2" translate="yes" xml:space="preserve">
          <source>ImageBitmapOptions</source>
          <target state="translated">ImageBitmapOptions</target>
        </trans-unit>
        <trans-unit id="91a39bdc5a33f203d5c2f138f0da931369fac84f" translate="yes" xml:space="preserve">
          <source>ImageBitmapRenderingContext</source>
          <target state="translated">ImageBitmapRenderingContext</target>
        </trans-unit>
        <trans-unit id="1a722437bfbd0c07b7f837b5b4332fd5d966ead2" translate="yes" xml:space="preserve">
          <source>ImageBitmapRenderingContextSettings</source>
          <target state="translated">ImageBitmapRenderingContextSettings</target>
        </trans-unit>
        <trans-unit id="b28af413c72a2e03556905d9b27766a80ae5dd7b" translate="yes" xml:space="preserve">
          <source>ImageBitmapSource</source>
          <target state="translated">ImageBitmapSource</target>
        </trans-unit>
        <trans-unit id="682b65e19d67a5e783299b757e21bec2832c6fb5" translate="yes" xml:space="preserve">
          <source>ImageData</source>
          <target state="translated">ImageData</target>
        </trans-unit>
        <trans-unit id="2217055c382ca08984df9c834dee428b5ed7c541" translate="yes" xml:space="preserve">
          <source>ImageOrientation</source>
          <target state="translated">ImageOrientation</target>
        </trans-unit>
        <trans-unit id="3394b71415cd8bd55fc9255b5d6beaf734d6f770" translate="yes" xml:space="preserve">
          <source>ImageSmoothingQuality</source>
          <target state="translated">ImageSmoothingQuality</target>
        </trans-unit>
        <trans-unit id="f98fd49f8f974a3886c42cb3693e5ffdf40539ee" translate="yes" xml:space="preserve">
          <source>Immediate superclasses of this class, in the order they are listed in the source code. Includes superclasses and superinterfaces of the class, but does not include the class itself.</source>
          <target state="translated">このクラスの即時のスーパークラスを、ソース・コードに記載されている順に示します。このクラスのスーパークラスとスーパーインターフェースを含みますが、クラス自体は含まれません。</target>
        </trans-unit>
        <trans-unit id="70af22099196223b8485c95684bbf8824a9afa2b" translate="yes" xml:space="preserve">
          <source>Immutability</source>
          <target state="translated">Immutability</target>
        </trans-unit>
        <trans-unit id="bb86d1b762a23d9068f4510901eeff7d18242638" translate="yes" xml:space="preserve">
          <source>Immutability in Kotlin/Native</source>
          <target state="translated">コトリン/ネイティブの不変性</target>
        </trans-unit>
        <trans-unit id="7f8782e7a667262dd5095f5ff184ddd709f4772b" translate="yes" xml:space="preserve">
          <source>Immutability is a runtime property in Kotlin/Native, and can be applied to an arbitrary object subgraph using the &lt;code&gt;kotlin.native.concurrent.freeze&lt;/code&gt; function. It makes all the objects reachable from the given one immutable, such a transition is a one-way operation (i.e., objects cannot be unfrozen later). Some naturally immutable objects such as &lt;code&gt;kotlin.String&lt;/code&gt;, &lt;code&gt;kotlin.Int&lt;/code&gt;, and other primitive types, along with &lt;code&gt;AtomicInt&lt;/code&gt; and &lt;code&gt;AtomicReference&lt;/code&gt; are frozen by default. If a mutating operation is applied to a frozen object, an &lt;code&gt;InvalidMutabilityException&lt;/code&gt; is thrown.</source>
          <target state="translated">不変性はKotlin / Nativeのランタイムプロパティであり、 &lt;code&gt;kotlin.native.concurrent.freeze&lt;/code&gt; 関数を使用して任意のオブジェクトサブグラフに適用できます。指定された1つの不変オブジェクトからすべてのオブジェクトに到達可能にします。このような遷移は一方向の操作です（つまり、オブジェクトを後でフリーズ解除することはできません）。 &lt;code&gt;kotlin.String&lt;/code&gt; 、 &lt;code&gt;kotlin.Int&lt;/code&gt; 、およびその他のプリミティブ型などの一部の自然に不変のオブジェクトは、 &lt;code&gt;AtomicInt&lt;/code&gt; および &lt;code&gt;AtomicReference&lt;/code&gt; とともに、デフォルトでフリーズされています。変更された操作がフリーズされたオブジェクトに適用されると、 &lt;code&gt;InvalidMutabilityException&lt;/code&gt; がスローされます。</target>
        </trans-unit>
        <trans-unit id="ed22a68de3c3f3cb15e1268df39db4a167fd746d" translate="yes" xml:space="preserve">
          <source>ImmutableBlob</source>
          <target state="translated">ImmutableBlob</target>
        </trans-unit>
        <trans-unit id="575d550105355ba3be5a6608f83817426c2bd97c" translate="yes" xml:space="preserve">
          <source>Imperative finally block</source>
          <target state="translated">インパーティブ最終的にブロック</target>
        </trans-unit>
        <trans-unit id="56a6489b53e94ff44d4b5586ba1f1332d73844a1" translate="yes" xml:space="preserve">
          <source>Imperative versus declarative</source>
          <target state="translated">命令的対宣言的</target>
        </trans-unit>
        <trans-unit id="ee7341a728a58d68c7532bf18aeb0fac4452b6b5" translate="yes" xml:space="preserve">
          <source>Implementation by Delegation</source>
          <target state="translated">委任による実施</target>
        </trans-unit>
        <trans-unit id="c0f0a132ab68a72286213758ce660b7e042cb87b" translate="yes" xml:space="preserve">
          <source>Implementation note: the current reading value is stored as a &lt;a href=&quot;../../kotlin/-long/index#kotlin.Long&quot;&gt;Long&lt;/a&gt; number of nanoseconds, thus it's capable to represent a time range of approximately &amp;plusmn;292 years. Should the reading value overflow as the result of &lt;a href=&quot;plus-assign&quot;&gt;plusAssign&lt;/a&gt; operation, an &lt;a href=&quot;../../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt; is thrown.</source>
          <target state="translated">実装上の注意：現在の読み取り値は&lt;a href=&quot;../../kotlin/-long/index#kotlin.Long&quot;&gt;長い&lt;/a&gt;ナノ秒数として保存されるため、約&amp;plusmn;292年の時間範囲を表すことができます。&lt;a href=&quot;plus-assign&quot;&gt;plusAssign&lt;/a&gt;操作の結果として読み取り値がオーバーフローした場合、&lt;a href=&quot;../../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt;がスローされます。</target>
        </trans-unit>
        <trans-unit id="dc1735ad8ce42355f885445d5ba551e409b9c86b" translate="yes" xml:space="preserve">
          <source>Implementations of the interface can override default methods.</source>
          <target state="translated">インターフェースの実装は、デフォルトのメソッドをオーバーライドすることができます。</target>
        </trans-unit>
        <trans-unit id="00d5f96768fee4f4899fb4ea94381d1c87db0a66" translate="yes" xml:space="preserve">
          <source>Implementing Interfaces</source>
          <target state="translated">インターフェースの実装</target>
        </trans-unit>
        <trans-unit id="d640e1d5eb2b7a283f3bc3070dd151afc512fb6c" translate="yes" xml:space="preserve">
          <source>Implementing Interfaces in Enum Classes</source>
          <target state="translated">Enum クラスでのインターフェイスの実装</target>
        </trans-unit>
        <trans-unit id="b2153d6fa67762548da1f8fe28f3d481ede48834" translate="yes" xml:space="preserve">
          <source>Implements the core logic of a property delegate for a read/write property that calls callback functions when changed.</source>
          <target state="translated">変更されたときにコールバック関数を呼び出す読み書きプロパティのデリゲートのコア・ロジックを実装します。</target>
        </trans-unit>
        <trans-unit id="b1af49118602d4ab9bd26831d35fc303f95ea13f" translate="yes" xml:space="preserve">
          <source>Implicit &lt;code&gt;this&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; 暗示する</target>
        </trans-unit>
        <trans-unit id="febd7a841f47bb67cef7b18f13ac806c637192b6" translate="yes" xml:space="preserve">
          <source>Important: files marked with &lt;code&gt;@file:JsModule&lt;/code&gt; annotation can't declare non-external members. The example below produces compile-time error:</source>
          <target state="translated">重要： &lt;code&gt;@file:JsModule&lt;/code&gt; アノテーションが付けられたファイルは、非外部メンバーを宣言できません。次の例では、コンパイル時エラーが発生します。</target>
        </trans-unit>
        <trans-unit id="e45479a7a7959d4875b5ea4acddae533ace5e782" translate="yes" xml:space="preserve">
          <source>Importing deeper package hierarchies</source>
          <target state="translated">より深いパッケージ階層のインポート</target>
        </trans-unit>
        <trans-unit id="a932c1ce87f097109d85ae710ba5975b2888a20e" translate="yes" xml:space="preserve">
          <source>Importing synthetic properties</source>
          <target state="translated">合成プロパティのインポート</target>
        </trans-unit>
        <trans-unit id="e42328ac01cd03a47978f064c93b392caf3861f0" translate="yes" xml:space="preserve">
          <source>Imports</source>
          <target state="translated">Imports</target>
        </trans-unit>
        <trans-unit id="3b7090ba2b2cc222b6a645f1eb051b20d9654d8e" translate="yes" xml:space="preserve">
          <source>Improved *.gradle.kts support in the IDE</source>
          <target state="translated">IDE での *.gradle.kts のサポートを改善しました。</target>
        </trans-unit>
        <trans-unit id="513df22c9887b1f085e00ef3b729d3f007cfd9d9" translate="yes" xml:space="preserve">
          <source>Improved import handling</source>
          <target state="translated">インポート処理の改善</target>
        </trans-unit>
        <trans-unit id="315a432d3c7693ed151796f4c20766973b95d237" translate="yes" xml:space="preserve">
          <source>Improved management for npm dependencies, with mandatory version numbers or &lt;a href=&quot;https://docs.npmjs.com/misc/semver#versions&quot;&gt;semver&lt;/a&gt; version ranges, as well as support for &lt;em&gt;development&lt;/em&gt;, &lt;em&gt;peer&lt;/em&gt;, and &lt;em&gt;optional&lt;/em&gt; npm dependencies using &lt;code&gt;devNpm&lt;/code&gt;, &lt;code&gt;optionalNpm&lt;/code&gt; and &lt;code&gt;peerNpm&lt;/code&gt;. Read more about dependency management for npm packages directly from Gradle &lt;a href=&quot;js-project-setup#npm-dependencies&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">必須のバージョン番号または&lt;a href=&quot;https://docs.npmjs.com/misc/semver#versions&quot;&gt;semver&lt;/a&gt;バージョン範囲を使用した、npm依存関係の管理の改善、および &lt;code&gt;devNpm&lt;/code&gt; 、 &lt;code&gt;optionalNpm&lt;/code&gt; 、 &lt;code&gt;peerNpm&lt;/code&gt; を使用した&lt;em&gt;開発&lt;/em&gt;、&lt;em&gt;ピア&lt;/em&gt;、および&lt;em&gt;オプションの&lt;/em&gt;npm依存関係のサポート。npmパッケージの依存関係管理について詳しくは、Gradleから直接お読み&lt;a href=&quot;js-project-setup#npm-dependencies&quot;&gt;ください&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fd53d3f3315c4c0f3364235c04212b30cd118e2f" translate="yes" xml:space="preserve">
          <source>Improved support for Kotlin Gradle DSL in the IDE</source>
          <target state="translated">IDEでのKotlin Gradle DSLのサポートが改善されました。</target>
        </trans-unit>
        <trans-unit id="d8972a1f28a588591d73ee09ddd836428eaca222" translate="yes" xml:space="preserve">
          <source>Improving smartcasts analysis by declaring the relation between a function's call outcome and the passed arguments values:</source>
          <target state="translated">関数の呼び出し結果と渡された引数の値の関係を宣言することで、スマートキャストの解析を改善します。</target>
        </trans-unit>
        <trans-unit id="c202358d520e5f37257d179570305668ee990cdc" translate="yes" xml:space="preserve">
          <source>Improving the existing API</source>
          <target state="translated">既存APIの改善</target>
        </trans-unit>
        <trans-unit id="3ea84fc4dca92bbd95cba0393e768bc0dbac665a" translate="yes" xml:space="preserve">
          <source>Improving the variable initialization analysis in the presence of high-order functions:</source>
          <target state="translated">高次関数の存在下での変数初期化解析の改善</target>
        </trans-unit>
        <trans-unit id="1a9aa64fd2cf728e6a54a37ad269e224c4406ae7" translate="yes" xml:space="preserve">
          <source>In &quot;clever words&quot; they say that the class &lt;code&gt;C&lt;/code&gt; is &lt;strong&gt;covariant&lt;/strong&gt; in the parameter &lt;code&gt;T&lt;/code&gt;, or that &lt;code&gt;T&lt;/code&gt; is a &lt;strong&gt;covariant&lt;/strong&gt; type parameter. You can think of &lt;code&gt;C&lt;/code&gt; as being a &lt;strong&gt;producer&lt;/strong&gt; of &lt;code&gt;T&lt;/code&gt;'s, and NOT a &lt;strong&gt;consumer&lt;/strong&gt; of &lt;code&gt;T&lt;/code&gt;'s.</source>
          <target state="translated">「賢い言葉」では、クラス &lt;code&gt;C&lt;/code&gt; はパラメーター &lt;code&gt;T&lt;/code&gt; で&lt;strong&gt;共変&lt;/strong&gt;である、または &lt;code&gt;T&lt;/code&gt; は&lt;strong&gt;共変型&lt;/strong&gt;パラメーターであると述べています。あなたは考えることができます &lt;code&gt;C&lt;/code&gt; として&lt;strong&gt;プロデューサー&lt;/strong&gt;の &lt;code&gt;T&lt;/code&gt; さん、およびNOT &lt;strong&gt;消費者&lt;/strong&gt;の &lt;code&gt;T&lt;/code&gt; さん。&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6019b82a793e669523c1435271b5d51f4ccb4ffc" translate="yes" xml:space="preserve">
          <source>In 1.3 we reworked the entire multiplatform model. The &lt;a href=&quot;building-mpp-with-gradle&quot;&gt;new DSL&lt;/a&gt; we have for describing multiplatform Gradle projects is much more flexible, and we'll keep working on it to make project configuration straightforward.</source>
          <target state="translated">1.3では、マルチプラットフォームモデル全体を作り直しました。&lt;a href=&quot;building-mpp-with-gradle&quot;&gt;新しいDSL&lt;/a&gt;マルチGradleのプロジェクトを記述するため、我々は持っているがはるかに柔軟であり、我々は、プロジェクトの設定は簡単に作ってそれに取り組んでおこう。</target>
        </trans-unit>
        <trans-unit id="08f9bdd95bef61c2c357a6e138e1e9a913682812" translate="yes" xml:space="preserve">
          <source>In 1.3, we've completely reworked the model of multiplatform projects in order to improve expressiveness and flexibility, and to make sharing common code easier. Also, Kotlin/Native is now supported as one of the targets!</source>
          <target state="translated">1.3では、表現力と柔軟性を向上させ、共通のコードを共有しやすくするために、マルチプラットフォームプロジェクトのモデルを完全に作り直しました。また、Kotlin/Native がターゲットの一つとしてサポートされるようになりました。</target>
        </trans-unit>
        <trans-unit id="213381945926ceb74a0743ef803e1aae21bbb519" translate="yes" xml:space="preserve">
          <source>In 1.3.70 we introduced two new features for improving the performance of Kotlin/Native compilation: &lt;a href=&quot;https://blog.jetbrains.com/kotlin/2020/03/kotlin-1-3-70-released/#kotlin-native&quot;&gt;caching project dependencies and running the compiler from the Gradle daemon&lt;/a&gt;. Since that time, we&amp;rsquo;ve managed to fix numerous issues and improve the overall stability of these features.</source>
          <target state="translated">1.3.70では、Kotlin / Nativeコンパイルのパフォーマンスを向上させるために、&lt;a href=&quot;https://blog.jetbrains.com/kotlin/2020/03/kotlin-1-3-70-released/#kotlin-native&quot;&gt;プロジェクトの依存関係をキャッシュすることと、Gradleデーモンからコンパイラを実行する&lt;/a&gt;ことの2つの新機能を導入しました。それ以来、私たちは多くの問題を修正し、これらの機能の全体的な安定性を改善することに成功しました。</target>
        </trans-unit>
        <trans-unit id="f8879cf64a06b7b628772713a32dffa84200aa1c" translate="yes" xml:space="preserve">
          <source>In 1.4.0, Kotlin/Native got a significant number of new features and improvements, including:</source>
          <target state="translated">1.4.0では、Kotlin/Nativeは以下のような多くの新機能と改善を受けました。</target>
        </trans-unit>
        <trans-unit id="a15eb3cdff900df751ecc01f9df494a4b1d439fc" translate="yes" xml:space="preserve">
          <source>In 1.4.0, scripting in Kotlin benefits from a number of functional and performance improvements along with other updates. Here are some of the key changes:</source>
          <target state="translated">1.4.0では、Kotlinのスクリプトは、その他のアップデートに加えて、多くの機能とパフォーマンスの改善が行われています。主な変更点は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="2f9c2fe76d2a17f7c4f9ec731f1abfee212c135b" translate="yes" xml:space="preserve">
          <source>In 1.4.0, the standard library includes a number of useful functions for working with &lt;strong&gt;collections&lt;/strong&gt;:</source>
          <target state="translated">1.4.0では、標準ライブラリに&lt;strong&gt;コレクションを&lt;/strong&gt;操作するための便利な関数がいくつか含まれてい&lt;strong&gt;ます&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="033b388a365ea25e3654d39784a4aac0e59b6a41" translate="yes" xml:space="preserve">
          <source>In 1.4.0, we add the basic support for suspending functions in Swift and Objective-C. Now, when you compile a Kotlin module into an Apple framework, suspending functions are available in it as functions with callbacks (&lt;code&gt;completionHandler&lt;/code&gt; in the Swift/Objective-C terminology). When you have such functions in the generated framework&amp;rsquo;s header, you can call them from your Swift or Objective-C code and even override them.</source>
          <target state="translated">1.4.0では、SwiftとObjective-Cの機能を一時停止するための基本的なサポートを追加します。これで、KotlinモジュールをAppleフレームワークにコンパイルすると、サスペンド関数がコールバック付きの関数（Swift / Objective-Cの用語では &lt;code&gt;completionHandler&lt;/code&gt; )として使用できるようになりました。生成されたフレームワークのヘッダーにそのような関数がある場合、SwiftまたはObjective-Cコードからそれらを呼び出したり、オーバーライドしたりすることもできます。</target>
        </trans-unit>
        <trans-unit id="4a6df711b0b9f7fdf8c3bc58b1703c03d295ebc7" translate="yes" xml:space="preserve">
          <source>In 1.4.0, we continued improving the IDE support for Gradle Kotlin DSL scripts (&lt;code&gt;*.gradle.kts&lt;/code&gt; files). Here is what the new version brings:</source>
          <target state="translated">1.4.0では、Gradle Kotlin DSLスクリプト（ &lt;code&gt;*.gradle.kts&lt;/code&gt; ファイル）のIDEサポートを引き続き改善しました。新しいバージョンがもたらすものは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="eac832f0ecfb5c80421d8f75ff875507a4728bfb" translate="yes" xml:space="preserve">
          <source>In 1.4.0, we have added new features to improve your experience with delegated properties in Kotlin:</source>
          <target state="translated">1.4.0では、Kotlinの委任プロパティの使用感を向上させるための新機能が追加されました。</target>
        </trans-unit>
        <trans-unit id="3d296b88303d152ba0a9aadb06847e0102aa46ad" translate="yes" xml:space="preserve">
          <source>In 1.4.0, we slightly change the Swift API generated from Kotlin with respect to the way exceptions are translated. There is a fundamental difference in error handling between Kotlin and Swift. All Kotlin exceptions are unchecked, while Swift has only checked errors. Thus, to make Swift code aware of expected exceptions, Kotlin functions should be marked with a &lt;code&gt;@Throws&lt;/code&gt; annotation specifying a list of potential exception classes.</source>
          <target state="translated">1.4.0では、例外の変換方法に関して、Kotlinから生成されたSwiftAPIをわずかに変更します。 KotlinとSwiftのエラー処理には根本的な違いがあります。 Kotlinの例外はすべてチェックされていませんが、Swiftはエラーのみをチェックしています。したがって、Swiftコードに予期される例外を認識させるには、Kotlin関数に、潜在的な例外クラスのリストを指定する &lt;code&gt;@Throws&lt;/code&gt; アノテーションを付ける必要があります。</target>
        </trans-unit>
        <trans-unit id="939973482b04c9dfe37b17beb6dea441e65e3874" translate="yes" xml:space="preserve">
          <source>In 1.4.0, we&amp;rsquo;ve introduced a new API for resolving external dependencies (such as Maven artifacts), along with implementations for it. This API is published in the new artifacts &lt;code&gt;kotlin-scripting-dependencies&lt;/code&gt; and &lt;code&gt;kotlin-scripting-dependencies-maven&lt;/code&gt;. The previous dependency resolution functionality in &lt;code&gt;kotlin-script-util&lt;/code&gt; library is now deprecated.</source>
          <target state="translated">1.4.0では、外部依存関係（Mavenアーティファクトなど）を解決するための新しいAPIと、その実装が導入されました。このAPIは、新しいアーティファクト &lt;code&gt;kotlin-scripting-dependencies&lt;/code&gt; および &lt;code&gt;kotlin-scripting-dependencies-maven&lt;/code&gt; で公開されています。 &lt;code&gt;kotlin-script-util&lt;/code&gt; ライブラリの以前の依存関係解決機能は非推奨になりました。</target>
        </trans-unit>
        <trans-unit id="2fe67da7ef7bd9edb03b06fd394c5b605f7d8102" translate="yes" xml:space="preserve">
          <source>In 1.4.0, we've added a new mode for generating default methods: &lt;code&gt;-Xjvm-default=all&lt;/code&gt; compiles &lt;em&gt;all&lt;/em&gt; non-abstract methods of Kotlin interfaces to &lt;code&gt;default&lt;/code&gt; Java methods. For compatibility with the code that uses the interfaces compiled without &lt;code&gt;default&lt;/code&gt;, we also added &lt;code&gt;all-compatibility&lt;/code&gt; mode.</source>
          <target state="translated">1.4.0では、デフォルトのメソッドを生成するための新しいモードが追加されました。 &lt;code&gt;-Xjvm-default=all&lt;/code&gt; は、Kotlinインターフェースの&lt;em&gt;すべての&lt;/em&gt;非抽象メソッドを &lt;code&gt;default&lt;/code&gt; Javaメソッドにコンパイルします。 &lt;code&gt;default&lt;/code&gt; なしでコンパイルされたインターフェースを使用するコードとの互換性のために、 &lt;code&gt;all-compatibility&lt;/code&gt; モードも追加しました。</target>
        </trans-unit>
        <trans-unit id="5745802255877abfa046b72cbccdadc8221d5622" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;collection-ordering&quot;&gt;Collection Ordering&lt;/a&gt;, we describe operations that retrieve collection elements in specific orders. For mutable lists, the standard library offers similar extension functions that perform the same ordering operations in place. When you apply such an operation to a list instance, it changes the order of elements in that exact instance.</source>
          <target state="translated">で&lt;a href=&quot;collection-ordering&quot;&gt;コレクションの注文&lt;/a&gt;、我々は特定の順序でコレクション要素を取得する操作について説明します。可変リストの場合、標準ライブラリは、同じ順序付け操作を実行する同様の拡張関数を提供します。このような操作をリストインスタンスに適用すると、その正確なインスタンス内の要素の順序が変更されます。</target>
        </trans-unit>
        <trans-unit id="be8a31aea4fdca8e3b9bdedb1958918e98cae1d2" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;collections-overview#map&quot;&gt;maps&lt;/a&gt;, types of both keys and values are user-defined. Key-based access to map entries enables various map-specific processing capabilities from getting a value by key to separate filtering of keys and values. On this page, we provide descriptions of the map processing functions from the standard library.</source>
          <target state="translated">では&lt;a href=&quot;collections-overview#map&quot;&gt;マップ&lt;/a&gt;、キーと値の両方のタイプは、ユーザが定義しています。マップエントリへのキーベースのアクセスにより、キーごとの値の取得から、キーと値のフィルタリングの分離まで、さまざまなマップ固有の処理機能が可能になります。このページでは、標準ライブラリのマップ処理関数について説明します。</target>
        </trans-unit>
        <trans-unit id="7454358e40f9eaf26ccc7cd55f4c30f555918de5" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;mapping-primitive-data-types-from-c&quot;&gt;the previous tutorial&lt;/a&gt; we created a &lt;code&gt;lib.h&lt;/code&gt; file. This time, we are going to include those declarations directly into the &lt;code&gt;interop.def&lt;/code&gt; file, after the &lt;code&gt;---&lt;/code&gt; separator line:</source>
          <target state="translated">で&lt;a href=&quot;mapping-primitive-data-types-from-c&quot;&gt;前のチュートリアル&lt;/a&gt;、我々は、作成 &lt;code&gt;lib.h&lt;/code&gt; ファイルを。今回は、それらの宣言を &lt;code&gt;interop.def&lt;/code&gt; ファイルの &lt;code&gt;---&lt;/code&gt; セパレータ行の後に直接含めます。</target>
        </trans-unit>
        <trans-unit id="f0454a21172602b262219293f4778fc730c2daf2" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;build.gradle.kts&lt;/code&gt; (or &lt;code&gt;build.gradle&lt;/code&gt;) of your IDEA project, apply the CocoaPods plugin as well as the Kotlin Multiplatform plugin.</source>
          <target state="translated">で &lt;code&gt;build.gradle.kts&lt;/code&gt; （または &lt;code&gt;build.gradle&lt;/code&gt; あなたIDEAプロジェクトの）、プラグインCocoaPodsだけでなく、Kotlinマルチプラグインを適用します。</target>
        </trans-unit>
        <trans-unit id="4f2d8d96fc34753484a87526254e4a4f003f9c05" translate="yes" xml:space="preserve">
          <source>In Android projects, additional Kotlin source sets are created for each &lt;a href=&quot;https://developer.android.com/studio/build/#sourcesets&quot;&gt;Android source set&lt;/a&gt;. If the Android target has a name &lt;code&gt;foo&lt;/code&gt;, the Android source set &lt;code&gt;bar&lt;/code&gt; gets a Kotlin source set counterpart &lt;code&gt;fooBar&lt;/code&gt;. The Kotlin compilations, however, are able to consume Kotlin sources from all of the directories &lt;code&gt;src/bar/java&lt;/code&gt;, &lt;code&gt;src/bar/kotlin&lt;/code&gt;, and &lt;code&gt;src/fooBar/kotlin&lt;/code&gt;. Java sources are only read from the first of these directories.</source>
          <target state="translated">Androidプロジェクトでは、&lt;a href=&quot;https://developer.android.com/studio/build/#sourcesets&quot;&gt;Androidソースセット&lt;/a&gt;ごとに追加のKotlinソースセットが作成されます。 Androidターゲットの名前が &lt;code&gt;foo&lt;/code&gt; の場合、Androidソースセット &lt;code&gt;bar&lt;/code&gt; はKotlinソースセットの対応する &lt;code&gt;fooBar&lt;/code&gt; を取得します。ただし、Kotlinのコンパイルでは、 &lt;code&gt;src/bar/java&lt;/code&gt; 、 &lt;code&gt;src/bar/kotlin&lt;/code&gt; 、および &lt;code&gt;src/fooBar/kotlin&lt;/code&gt; のすべてのディレクトリからKotlinソースを利用できます。 Javaソースは、これらのディレクトリの最初からのみ読み取られます。</target>
        </trans-unit>
        <trans-unit id="257732c8dc478843fa9cbb50bd51c9bd28228b70" translate="yes" xml:space="preserve">
          <source>In Android, make sure you use the Android Gradle plugin version 3.2 or higher, which can correctly process jar files with module-info.</source>
          <target state="translated">Androidでは、module-infoでjarファイルを正しく処理できるAndroid Gradleプラグインのバージョン3.2以上を使用していることを確認してください。</target>
        </trans-unit>
        <trans-unit id="33342ff8fe9e060731185ad7c136d99b9461055f" translate="yes" xml:space="preserve">
          <source>In Gradle</source>
          <target state="translated">グラドルでは</target>
        </trans-unit>
        <trans-unit id="9ffad76a20436e6770075c18f7fc5a623588a28f" translate="yes" xml:space="preserve">
          <source>In Gradle 5.3 and above, the module metadata is always used during dependency resolution, but publications don't include any module metadata by default. To enable module metadata publishing, add &lt;code&gt;enableFeaturePreview(&quot;GRADLE_METADATA&quot;)&lt;/code&gt; to the root project's &lt;code&gt;settings.gradle&lt;/code&gt; file. With older Gradle versions, this is also required for module metadata consumption.</source>
          <target state="translated">Gradle 5.3以降では、依存関係の解決中にモジュールメタデータが常に使用されますが、パブリケーションにはデフォルトでモジュールメタデータが含まれていません。モジュールのメタデータの公開を有効にするには、ルートプロジェクトの &lt;code&gt;settings.gradle&lt;/code&gt; ファイルに &lt;code&gt;enableFeaturePreview(&quot;GRADLE_METADATA&quot;)&lt;/code&gt; を追加します。古いGradleバージョンでは、これはモジュールメタデータの消費にも必要です。</target>
        </trans-unit>
        <trans-unit id="689d572315ca41a5147e4a6e26331b2145e72a29" translate="yes" xml:space="preserve">
          <source>In Gradle 6.0 and above, you can explicitly apply changes by clicking &lt;strong&gt;Load Gradle Changes&lt;/strong&gt; or by reimporting the Gradle project.</source>
          <target state="translated">Gradle 6.0以降では、[ &lt;strong&gt;Gradle変更のロード&lt;/strong&gt;]をクリックするか、Gradleプロジェクトを再インポートすることで、&lt;strong&gt;変更&lt;/strong&gt;を明示的に適用できます。</target>
        </trans-unit>
        <trans-unit id="db8d93f584f6cd9be9c19cceb09290c42348f8b6" translate="yes" xml:space="preserve">
          <source>In Gradle command line parameters: add the parameter &lt;code&gt;-Pkotlin.incremental&lt;/code&gt; or &lt;code&gt;-Pkotlin.incremental.js&lt;/code&gt; with the boolean value reflecting the usage of incremental compilation. Note that in this case the parameter should be added to each subsequent build, and any build with disabled incremental compilation invalidates incremental caches.</source>
          <target state="translated">Gradleコマンドラインパラメータで、パラメータ &lt;code&gt;-Pkotlin.incremental&lt;/code&gt; または &lt;code&gt;-Pkotlin.incremental.js&lt;/code&gt; を追加して、増分コンパイルの使用を反映するブール値を指定します。この場合、パラメーターは後続の各ビルドに追加する必要があることに注意してください。増分コンパイルが無効になっているビルドは、増分キャッシュを無効にします。</target>
        </trans-unit>
        <trans-unit id="d95af6982c4662ae34dc8dfd04c6f3d77bb71544" translate="yes" xml:space="preserve">
          <source>In Gradle configuration files: add the line &lt;code&gt;kotlin.incremental=&amp;lt;value&amp;gt;&lt;/code&gt; for Kotlin/JVM or &lt;code&gt;kotlin.incremental.js=&amp;lt;value&amp;gt;&lt;/code&gt; for Kotlin/JS projects either to &lt;code&gt;gradle.properties&lt;/code&gt; or to &lt;code&gt;local.properties&lt;/code&gt; file. &lt;code&gt;&amp;lt;value&amp;gt;&lt;/code&gt; is a boolean value reflecting the usage of incremental compilation.</source>
          <target state="translated">Gradleの設定ファイルでは：行を追加 &lt;code&gt;kotlin.incremental=&amp;lt;value&amp;gt;&lt;/code&gt; Kotlin / JVMまたはのため &lt;code&gt;kotlin.incremental.js=&amp;lt;value&amp;gt;&lt;/code&gt; のいずれかにKotlin / JSプロジェクトのため &lt;code&gt;gradle.properties&lt;/code&gt; かに &lt;code&gt;local.properties&lt;/code&gt; のファイル。 &lt;code&gt;&amp;lt;value&amp;gt;&lt;/code&gt; は、増分コンパイルの使用を反映するブール値です。</target>
        </trans-unit>
        <trans-unit id="1f0dee881e670d1f97f2d917d6284d13c20aff3f" translate="yes" xml:space="preserve">
          <source>In Gradle versions earlier than 6.0, you need to manually load the script configuration by clicking &lt;strong&gt;Load Configuration&lt;/strong&gt; in the editor.</source>
          <target state="translated">6.0より前のGradleバージョンでは、エディターで[&lt;strong&gt;構成のロード&lt;/strong&gt;]をクリックして、スクリプト構成を手動でロードする必要があります。</target>
        </trans-unit>
        <trans-unit id="537c1a3af537507e4b627b3261006ddbdae522fd" translate="yes" xml:space="preserve">
          <source>In Gradle:</source>
          <target state="translated">Gradleで。</target>
        </trans-unit>
        <trans-unit id="d2d1d0c783432497ec07d157b951c4e78d7cc0b8" translate="yes" xml:space="preserve">
          <source>In IntelliJ IDEA go to &lt;em&gt;File -&amp;gt; New &amp;gt; Project&amp;hellip;&lt;/em&gt; and check the &lt;em&gt;Create from archetype&lt;/em&gt; box:</source>
          <target state="translated">IntelliJ IDEAでに行き&lt;em&gt;、ファイル- &amp;gt;新規&amp;gt;プロジェクト...&lt;/em&gt;とチェック&lt;em&gt;原型から作成&lt;/em&gt;ボックス：</target>
        </trans-unit>
        <trans-unit id="4d485a76c7a3760895d18fab529fc51f77b28063" translate="yes" xml:space="preserve">
          <source>In IntelliJ IDEA go to &lt;em&gt;File -&amp;gt; New &amp;gt; Project&amp;hellip;&lt;/em&gt;:</source>
          <target state="translated">IntelliJ IDEAで、&lt;em&gt;[ファイル]-&amp;gt; [新規]&amp;gt; [プロジェクト]に移動します&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="1602732a6a8d6badfddfb46b91b51e47005a6da3" translate="yes" xml:space="preserve">
          <source>In IntelliJ IDEA, select &lt;strong&gt;File&lt;/strong&gt; | &lt;strong&gt;New&lt;/strong&gt; | &lt;strong&gt;Project&lt;/strong&gt;.</source>
          <target state="translated">IntelliJ IDEAで、[&lt;strong&gt;ファイル]&lt;/strong&gt;、[&lt;strong&gt;ファイル]の順&lt;/strong&gt;に選択し&lt;strong&gt;ます&lt;/strong&gt;。&lt;strong&gt;新規&lt;/strong&gt;| &lt;strong&gt;プロジェクト&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="c5abe7664486d0a3820c82f8b82f8f0d75b700ae" translate="yes" xml:space="preserve">
          <source>In IntelliJ IDEA, write in the compiler arguments in the &lt;strong&gt;Additional command-line parameters&lt;/strong&gt; text box in &lt;strong&gt;Settings | Build, Execution, Deployment | Compilers | Kotlin Compiler&lt;/strong&gt;</source>
          <target state="translated">IntelliJ IDEAでは、&lt;strong&gt;[設定] | [設定]の[&lt;/strong&gt;&lt;strong&gt;追加のコマンドラインパラメーター&lt;/strong&gt;&lt;strong&gt;]&lt;/strong&gt;テキストボックスにコンパイラー引数を&lt;strong&gt;記述し&lt;/strong&gt;ます&lt;strong&gt;。ビルド、実行、展開| コンパイラ| Kotlinコンパイラ&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9cc14db5a6e801d7da035df405c7d7827fc53b41" translate="yes" xml:space="preserve">
          <source>In JVM platform code:</source>
          <target state="translated">JVMプラットフォームのコードで。</target>
        </trans-unit>
        <trans-unit id="513ad5f28a98a53d38c2cd4b1ebf3e53ba78a0e9" translate="yes" xml:space="preserve">
          <source>In Java you specify &lt;code&gt;Dagger&lt;/code&gt; as &lt;code&gt;annotationProcessor&lt;/code&gt; (or &lt;code&gt;apt&lt;/code&gt;) dependency:</source>
          <target state="translated">Javaでは、 &lt;code&gt;Dagger&lt;/code&gt; を &lt;code&gt;annotationProcessor&lt;/code&gt; （または &lt;code&gt;apt&lt;/code&gt; ）依存関係として指定します。</target>
        </trans-unit>
        <trans-unit id="e76e330054ec3492dbde5d95b20d3d1c9ac12e6f" translate="yes" xml:space="preserve">
          <source>In Java, we are used to classes named &quot;*Utils&quot;: &lt;code&gt;FileUtils&lt;/code&gt;, &lt;code&gt;StringUtils&lt;/code&gt; and so on. The famous &lt;code&gt;java.util.Collections&lt;/code&gt; belongs to the same breed. And the unpleasant part about these Utils-classes is that the code that uses them looks like this:</source>
          <target state="translated">Javaでは、「* Utils」という名前のクラスに慣れています： &lt;code&gt;FileUtils&lt;/code&gt; 、 &lt;code&gt;StringUtils&lt;/code&gt; など。有名な &lt;code&gt;java.util.Collections&lt;/code&gt; は同じ品種に属しています。また、これらのUtilsクラスの不愉快な点は、それらを使用するコードが次のようになっていることです。</target>
        </trans-unit>
        <trans-unit id="8310a54b24568803ae04cc82e73e4ed7d64a2ce9" translate="yes" xml:space="preserve">
          <source>In Java:</source>
          <target state="translated">Javaでは。</target>
        </trans-unit>
        <trans-unit id="abb66954294d1e4253f6894befd4961b0fc88ece" translate="yes" xml:space="preserve">
          <source>In JavaScript you can define members either on a prototype or a class itself. I.e.:</source>
          <target state="translated">JavaScriptでは、プロトタイプやクラス自体にメンバーを定義することができます。例えば</target>
        </trans-unit>
        <trans-unit id="592ce5c07c0fe6dc9a4e0ec16760d4af84a287b3" translate="yes" xml:space="preserve">
          <source>In JavaScript you can define members either on a prototype or a class itself:</source>
          <target state="translated">JavaScriptでは、プロトタイプやクラス自体にメンバーを定義することができます。</target>
        </trans-unit>
        <trans-unit id="b73e80ab874eb4a673c8b0548f2f4b1a57e2e5b0" translate="yes" xml:space="preserve">
          <source>In Kotlin 1.0, code in the lambda passed to &lt;code&gt;td&lt;/code&gt; has access to three implicit receivers: the one passed to &lt;code&gt;table&lt;/code&gt;, to &lt;code&gt;tr&lt;/code&gt; and to &lt;code&gt;td&lt;/code&gt;. This allows you to call methods that make no sense in the context - for example to call &lt;code&gt;tr&lt;/code&gt; inside &lt;code&gt;td&lt;/code&gt; and thus to put a &lt;code&gt;&amp;lt;tr&amp;gt;&lt;/code&gt; tag in a &lt;code&gt;&amp;lt;td&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Kotlin 1.0では、 &lt;code&gt;td&lt;/code&gt; に渡されるラムダ内のコードは、3つの暗黙的なレシーバー（ &lt;code&gt;table&lt;/code&gt; 、 &lt;code&gt;tr&lt;/code&gt; 、および &lt;code&gt;td&lt;/code&gt; に渡されるレシーバー）にアクセスできます。これにより、コンテキスト内で意味のないメソッドを呼び出すことができます。たとえば、 &lt;code&gt;td&lt;/code&gt; 内で &lt;code&gt;tr&lt;/code&gt; を呼び出して、 &lt;code&gt;&amp;lt;tr&amp;gt;&lt;/code&gt; タグを &lt;code&gt;&amp;lt;td&amp;gt;&lt;/code&gt; に配置できます。</target>
        </trans-unit>
        <trans-unit id="faca07a0c2f2dcf45e7526d00d395e3cdc377fcb" translate="yes" xml:space="preserve">
          <source>In Kotlin 1.1, you can restrict that, so that only methods defined on the implicit receiver of &lt;code&gt;td&lt;/code&gt; will be available inside the lambda passed to &lt;code&gt;td&lt;/code&gt;. You do that by defining your annotation marked with the &lt;code&gt;@DslMarker&lt;/code&gt; meta-annotation and applying it to the base class of the tag classes.</source>
          <target state="translated">Kotlin 1.1では、 &lt;code&gt;td&lt;/code&gt; に渡されたラムダ内で &lt;code&gt;td&lt;/code&gt; の暗黙のレシーバーで定義されたメソッドのみが使用できるように、それを制限できます。 &lt;code&gt;@DslMarker&lt;/code&gt; メタ注釈でマークされた注釈を定義し、それをタグクラスの基本クラスに適用することにより、これを行います。</target>
        </trans-unit>
        <trans-unit id="24a213ee88ffeaa2bec3378db48986b075744611" translate="yes" xml:space="preserve">
          <source>In Kotlin 1.1.x, use &lt;code&gt;kotlin-stdlib-jre7&lt;/code&gt; and &lt;code&gt;kotlin-stdlib-jre8&lt;/code&gt; instead.</source>
          <target state="translated">Kotlin 1.1.xでは、 &lt;code&gt;kotlin-stdlib-jre7&lt;/code&gt; と &lt;code&gt;kotlin-stdlib-jre8&lt;/code&gt; を使用してください。</target>
        </trans-unit>
        <trans-unit id="6ea3af6627b279c964f114bd464c51ab696c689f" translate="yes" xml:space="preserve">
          <source>In Kotlin 1.3 it is possible for annotations to have nested classes, interfaces, objects, and companions:</source>
          <target state="translated">Kotlin 1.3では、アノテーションにネストされたクラス、インターフェース、オブジェクト、コンパニオンを持たせることができます。</target>
        </trans-unit>
        <trans-unit id="3098d1aa730f31e91846c87eaae7ac71342cdc7e" translate="yes" xml:space="preserve">
          <source>In Kotlin 1.3, it is now possible to capture the &lt;code&gt;when&lt;/code&gt; subject into variable:</source>
          <target state="translated">Kotlin 1.3では、サブジェクトを変数にキャプチャすることが可能 &lt;code&gt;when&lt;/code&gt; なりました。</target>
        </trans-unit>
        <trans-unit id="5f37a85c51fbb026184df241508ddfb560773d59" translate="yes" xml:space="preserve">
          <source>In Kotlin 1.3, the last expression inside a lambda wasn&amp;rsquo;t smart cast unless you specified the expected type. Thus, in the following example, Kotlin 1.3 infers &lt;code&gt;String?&lt;/code&gt; as the type of the &lt;code&gt;result&lt;/code&gt; variable:</source>
          <target state="translated">Kotlin 1.3では、ラムダ内の最後の式は、予期される型を指定しない限り、スマートキャストではありませんでした。したがって、次の例では、Kotlin 1.3は &lt;code&gt;String?&lt;/code&gt; 推測しますか？ &lt;code&gt;result&lt;/code&gt; 変数のタイプとして：</target>
        </trans-unit>
        <trans-unit id="22e077400784df8fb4e1901ad7292c2554138fbc" translate="yes" xml:space="preserve">
          <source>In Kotlin 1.3, when you called a function with &lt;a href=&quot;functions#named-arguments&quot;&gt;named arguments&lt;/a&gt;, you had to place all the arguments without names (positional arguments) before the first named argument. For example, you could call &lt;code&gt;f(1, y = 2)&lt;/code&gt;, but you couldn't call &lt;code&gt;f(x = 1, 2)&lt;/code&gt;.</source>
          <target state="translated">Kotlin 1.3では、&lt;a href=&quot;functions#named-arguments&quot;&gt;名前付き引数を使用し&lt;/a&gt;て関数を呼び出すと、最初の名前付き引数の前に、名前のないすべての引数（位置引数）を配置する必要がありました。たとえば、 &lt;code&gt;f(1, y = 2)&lt;/code&gt; 呼び出すことはできますが、 &lt;code&gt;f(x = 1, 2)&lt;/code&gt; 呼び出すことはできません。</target>
        </trans-unit>
        <trans-unit id="a475b20752c24d40f5224875251af51b65720545" translate="yes" xml:space="preserve">
          <source>In Kotlin 1.3, you could not use unqualified &lt;code&gt;break&lt;/code&gt; and &lt;code&gt;continue&lt;/code&gt; inside &lt;code&gt;when&lt;/code&gt; expressions included in loops. The reason was that these keywords were reserved for possible &lt;a href=&quot;https://en.wikipedia.org/wiki/Switch_statement#Fallthrough&quot;&gt;fall-through behavior&lt;/a&gt; in &lt;code&gt;when&lt;/code&gt; expressions.</source>
          <target state="translated">Kotlin 1.3では、式がループに含まれている &lt;code&gt;when&lt;/code&gt; 、修飾されていない &lt;code&gt;break&lt;/code&gt; を使用して内部を &lt;code&gt;continue&lt;/code&gt; することはできませんでした。その理由は、これらのキーワードは、 &lt;code&gt;when&lt;/code&gt; 式で発生する可能性のある&lt;a href=&quot;https://en.wikipedia.org/wiki/Switch_statement#Fallthrough&quot;&gt;フォールスルー動作の&lt;/a&gt;ために予約されていたためです。</target>
        </trans-unit>
        <trans-unit id="b974ce10e6832a604b02d997fda0b13d1262981d" translate="yes" xml:space="preserve">
          <source>In Kotlin 1.3, you couldn&amp;rsquo;t access a member reference of a smart cast type. Now in Kotlin 1.4 you can:</source>
          <target state="translated">Kotlin 1.3では、スマートキャストタイプのメンバー参照にアクセスできませんでした。Kotlin 1.4では、次のことができます。</target>
        </trans-unit>
        <trans-unit id="59a10d530fe4140dc151e0b8f7cbd865add4eedd" translate="yes" xml:space="preserve">
          <source>In Kotlin 1.3, you needed to introduce an explicit lambda parameter or replace &lt;code&gt;to&lt;/code&gt; with a &lt;code&gt;Pair&lt;/code&gt; constructor with explicit generic arguments to make it work.</source>
          <target state="translated">Kotlin 1.3では、明示的なラムダパラメータを導入または交換するのに必要 &lt;code&gt;to&lt;/code&gt; して &lt;code&gt;Pair&lt;/code&gt; それを動作させるために、明示的なジェネリック引数を持つコンストラクタ。</target>
        </trans-unit>
        <trans-unit id="459625eab3e8c1c93d88f051a772819b50973feb" translate="yes" xml:space="preserve">
          <source>In Kotlin 1.3, you often needed to add explicit casts (either &lt;code&gt;!!&lt;/code&gt; or type casts like &lt;code&gt;as String&lt;/code&gt;) to make such cases work, and now these casts have become unnecessary.</source>
          <target state="translated">Kotlin 1.3では、このようなケースを機能させるために、明示的なキャスト（ &lt;code&gt;!!&lt;/code&gt; または &lt;code&gt;as String&lt;/code&gt; ような型キャスト）を追加する必要がありましたが、これらのキャストは不要になりました。</target>
        </trans-unit>
        <trans-unit id="b1e46759775714e2bcf79ff28b8ed72dd56567d1" translate="yes" xml:space="preserve">
          <source>In Kotlin 1.3, you would have had to declare the function &lt;code&gt;foo&lt;/code&gt; above in Java code to perform a SAM conversion.</source>
          <target state="translated">Kotlin 1.3では、SAM変換を実行するには、上記の関数 &lt;code&gt;foo&lt;/code&gt; をJavaコードで宣言する必要がありました。</target>
        </trans-unit>
        <trans-unit id="4780e01f08d257fbc2b0ac706bfcbbb52154825a" translate="yes" xml:space="preserve">
          <source>In Kotlin 1.4, debugging coroutines is now much more convenient with the new functionality shipped with the Kotlin plugin.</source>
          <target state="translated">Kotlin 1.4では、Kotlinプラグインに同梱されている新機能により、コアーチンのデバッグがより便利になりました。</target>
        </trans-unit>
        <trans-unit id="c83ca71d5cf2a3ede274dccc4461018d08bea733" translate="yes" xml:space="preserve">
          <source>In Kotlin 1.4, thanks to the new inference algorithm, the last expression inside a lambda gets smart cast, and this new, more precise type is used to infer the resulting lambda type. Thus, the type of the &lt;code&gt;result&lt;/code&gt; variable becomes &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">Kotlin 1.4では、新しい推論アルゴリズムのおかげで、ラムダ内の最後の式がスマートキャストされ、この新しい、より正確な型を使用して、結果のラムダ型が推論されます。したがって、 &lt;code&gt;result&lt;/code&gt; 変数の型は &lt;code&gt;String&lt;/code&gt; になります。</target>
        </trans-unit>
        <trans-unit id="c138e260059efc2e42dd28d292a8e504c0bd71f8" translate="yes" xml:space="preserve">
          <source>In Kotlin 1.4, there is no such limitation &amp;ndash; you can now specify a name for an argument in the middle of a set of positional arguments. Moreover, you can mix positional and named arguments any way you like, as long as they remain in the correct order.</source>
          <target state="translated">Kotlin 1.4では、そのような制限はありません。一連の位置引数の途中で引数の名前を指定できるようになりました。さらに、位置引数と名前付き引数は、正しい順序のままである限り、好きなように組み合わせることができます。</target>
        </trans-unit>
        <trans-unit id="17850e337195432d24d049a8cddcfff57e5bda7d" translate="yes" xml:space="preserve">
          <source>In Kotlin 1.4, you can use &lt;code&gt;break&lt;/code&gt; and &lt;code&gt;continue&lt;/code&gt; without labels inside &lt;code&gt;when&lt;/code&gt; expressions included in loops. They behave as expected by terminating the nearest enclosing loop or proceeding to its next step.</source>
          <target state="translated">Kotlin 1.4では、式がループに含まれている &lt;code&gt;when&lt;/code&gt; &lt;code&gt;break&lt;/code&gt; を使用して、内部にラベルを付けずに &lt;code&gt;continue&lt;/code&gt; できます。最も近い囲みループを終了するか、次のステップに進むことで、期待どおりに動作します。</target>
        </trans-unit>
        <trans-unit id="a91dfb7becc799d0a4c9f2c3750f3bb6f56f95da" translate="yes" xml:space="preserve">
          <source>In Kotlin 1.4, you can use Java SAM interfaces in Kotlin and apply SAM conversions to them.</source>
          <target state="translated">Kotlin 1.4では、KotlinでJavaのSAMインターフェースを使用して、SAM変換を適用することができます。</target>
        </trans-unit>
        <trans-unit id="3bcf048388e07b049f121a6138fdee8bc3c8bbd0" translate="yes" xml:space="preserve">
          <source>In Kotlin 1.4, you can use callable references to functions returning any type in &lt;code&gt;Unit&lt;/code&gt;-returning functions. Before Kotlin 1.4, you could only use lambda arguments in this case. Now you can use both lambda arguments and callable references.</source>
          <target state="translated">Kotlin 1.4では、 &lt;code&gt;Unit&lt;/code&gt; 返す関数で任意の型を返す関数への呼び出し可能な参照を使用できます。Kotlin 1.4より前は、この場合はラムダ引数しか使用できませんでした。これで、ラムダ引数と呼び出し可能な参照の両方を使用できます。</target>
        </trans-unit>
        <trans-unit id="4d6cbd7b692f016e4b1961c027250fe1af453741" translate="yes" xml:space="preserve">
          <source>In Kotlin 1.4.0, we ship a number of improvements in all of its components, with the &lt;a href=&quot;https://blog.jetbrains.com/kotlin/2020/08/kotlin-1-4-released-with-a-focus-on-quality-and-performance/&quot;&gt;focus on quality and performance&lt;/a&gt;. Below you will find the list of the most important changes in Kotlin 1.4.0.</source>
          <target state="translated">Kotlin 1.4.0では、&lt;a href=&quot;https://blog.jetbrains.com/kotlin/2020/08/kotlin-1-4-released-with-a-focus-on-quality-and-performance/&quot;&gt;品質とパフォーマンスに重点を置いて&lt;/a&gt;、すべてのコンポーネントに多くの改良が加えられています。以下に、Kotlin1.4.0での最も重要な変更のリストを示します。</target>
        </trans-unit>
        <trans-unit id="2a99d2573a55fb319e350044cce69239e344a488" translate="yes" xml:space="preserve">
          <source>In Kotlin functions can be declared at top level in a file, meaning you do not need to create a class to hold a function, which you are required to do in languages such as Java, C# or Scala. In addition to top level functions, Kotlin functions can also be declared local, as member functions and extension functions.</source>
          <target state="translated">つまり、JavaやC#、Scalaなどの言語で必要とされるような、関数を保持するためのクラスを作成する必要がありません。トップレベルの関数に加えて、Kotlinの関数はメンバー関数や拡張関数としてローカルに宣言することもできます。</target>
        </trans-unit>
        <trans-unit id="d5176ee2358fd7911cf590e90f48fd7d921131e2" translate="yes" xml:space="preserve">
          <source>In Kotlin there are two types of equality:</source>
          <target state="translated">コトリンでは2種類の平等があります。</target>
        </trans-unit>
        <trans-unit id="1307e7346626ce5c88b95620e1843731ae3969f4" translate="yes" xml:space="preserve">
          <source>In Kotlin this line can be concisely parsed with the following statement using &lt;a href=&quot;../reference/multi-declarations#destructuring-declarations&quot;&gt;destructuring declaration&lt;/a&gt; from a list of integers:</source>
          <target state="translated">Kotlinでは、この行は整数のリストからの構造化&lt;a href=&quot;../reference/multi-declarations#destructuring-declarations&quot;&gt;宣言&lt;/a&gt;を使用して、次のステートメントで簡潔に解析できます。</target>
        </trans-unit>
        <trans-unit id="d2cb95a39c5087932a02f405cc63f954a5dedc22" translate="yes" xml:space="preserve">
          <source>In Kotlin you can provide upper bounds for a generic type. Objective-C also supports this, but that support is unavailable in more complex cases, and is currently not supported in the Kotlin - Objective-C interop. The exception here being a non-null upper bound will make Objective-C methods/properties non-null.</source>
          <target state="translated">Kotlinでは、一般的な型の上限を指定することができます。Objective-Cもこれをサポートしていますが、より複雑なケースではサポートされておらず、現在のところKotlin-Objective-Cの相互運用ではサポートされていません。ここでの例外は、非 null 上限を指定すると Objective-C のメソッドやプロパティが非 null になることです。</target>
        </trans-unit>
        <trans-unit id="ef29e345af9c063df71b3f01a21f78a928c57611" translate="yes" xml:space="preserve">
          <source>In Kotlin you can't work with fields directly, you work with &lt;a href=&quot;../reference/properties&quot;&gt;properties&lt;/a&gt;. You annotate the property:</source>
          <target state="translated">Kotlinでは、フィールドを直接操作することはできません。&lt;a href=&quot;../reference/properties&quot;&gt;プロパティを操作&lt;/a&gt;します。プロパティに注釈を付けます。</target>
        </trans-unit>
        <trans-unit id="b1411aa40ea7c5b9a0de303333e37baf632f1665" translate="yes" xml:space="preserve">
          <source>In Kotlin you have to add the &lt;code&gt;kotlin-kapt&lt;/code&gt; plugin to enable &lt;code&gt;kapt&lt;/code&gt;, and then replace &lt;code&gt;annotationProcessor&lt;/code&gt; with &lt;code&gt;kapt&lt;/code&gt;:</source>
          <target state="translated">Kotlinでは、 &lt;code&gt;kotlin-kapt&lt;/code&gt; プラグインを追加してkaptを有効にして &lt;code&gt;kapt&lt;/code&gt; 、 &lt;code&gt;annotationProcessor&lt;/code&gt; を &lt;code&gt;kapt&lt;/code&gt; に置き換える必要があります。</target>
        </trans-unit>
        <trans-unit id="da7a2b73e175cb7362740b3fbdff60c8cc8e5724" translate="yes" xml:space="preserve">
          <source>In Kotlin you specify the dependencies in a similar to Java way using &lt;a href=&quot;../reference/kapt&quot;&gt;Kotlin Annotation processing tool&lt;/a&gt; (&lt;code&gt;kapt&lt;/code&gt;) instead of &lt;code&gt;annotationProcessor&lt;/code&gt;.</source>
          <target state="translated">Kotlin では、 &lt;code&gt;annotationProcessor&lt;/code&gt; の代わりに&lt;a href=&quot;../reference/kapt&quot;&gt;Kotlin注釈処理ツール&lt;/a&gt;（ &lt;code&gt;kapt&lt;/code&gt; ）を使用して、Javaと同様の方法で依存関係を指定します。</target>
        </trans-unit>
        <trans-unit id="0a2601b06937bb12c0744830de8e7b372473464e" translate="yes" xml:space="preserve">
          <source>In Kotlin, &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/plus&quot;&gt;&lt;code&gt;plus&lt;/code&gt;&lt;/a&gt; (&lt;code&gt;+&lt;/code&gt;) and &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/minus&quot;&gt;&lt;code&gt;minus&lt;/code&gt;&lt;/a&gt; (&lt;code&gt;-&lt;/code&gt;) operators are defined for collections. They take a collection as the first operand; the second operand can be either an element or another collection. The return value is a new read-only collection:</source>
          <target state="translated">Kotlinでは、&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/plus&quot;&gt; &lt;code&gt;plus&lt;/code&gt; &lt;/a&gt;（ &lt;code&gt;+&lt;/code&gt; ）および&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/minus&quot;&gt; &lt;code&gt;minus&lt;/code&gt; &lt;/a&gt;（ &lt;code&gt;-&lt;/code&gt; ）演算子がコレクションに定義されています。彼らは最初のオペランドとしてコレクションを取ります。2番目のオペランドは、要素または別のコレクションです。戻り値は、新しい読み取り専用のコレクションです。</target>
        </trans-unit>
        <trans-unit id="78f4990d53a6e7c8067b2fe1adea30492b815286" translate="yes" xml:space="preserve">
          <source>In Kotlin, &lt;em&gt;if&lt;/em&gt; can also be used as an expression:</source>
          <target state="translated">Kotlinでは、&lt;em&gt;if&lt;/em&gt;を式として使用&lt;em&gt;する&lt;/em&gt;こともできます。</target>
        </trans-unit>
        <trans-unit id="630fd5574aed5de24f8dfa12e49c30f220082837" translate="yes" xml:space="preserve">
          <source>In Kotlin, &lt;em&gt;if&lt;/em&gt; is an expression, i.e. it returns a value. Therefore there is no ternary operator (condition ? then : else), because ordinary &lt;em&gt;if&lt;/em&gt; works fine in this role.</source>
          <target state="translated">Kotlinでは、&lt;em&gt;if&lt;/em&gt;が式、つまり値を返します。したがって、通常の&lt;em&gt;if&lt;/em&gt;がこの役割でうまく機能するため、3項演算子（条件？then：else）はありません。</target>
        </trans-unit>
        <trans-unit id="449834b1db02375da0148e9e57aea36e01ccf956" translate="yes" xml:space="preserve">
          <source>In Kotlin, all exceptions are unchecked, meaning that the compiler does not force you to catch any of them. So, when you call a Java method that declares a checked exception, Kotlin does not force you to do anything:</source>
          <target state="translated">Kotlinでは、すべての例外はチェックされていないので、コンパイラが強制的に例外をキャッチすることはありません。つまり、チェックされた例外を宣言するJavaメソッドを呼び出しても、Kotlinは何も強制しません。</target>
        </trans-unit>
        <trans-unit id="c1bf5763a1f21717d603f8b9877cdae5c9f323e3" translate="yes" xml:space="preserve">
          <source>In Kotlin, data serialization tools are available in a separate component, &lt;a href=&quot;https://github.com/Kotlin/kotlinx.serialization&quot;&gt;&lt;em&gt;kotlinx.serialization&lt;/em&gt;&lt;/a&gt;. It consists of two main parts: the Gradle plugin &amp;ndash;&lt;code&gt;org.jetbrains.kotlin.plugin.serialization&lt;/code&gt; and the runtime libraries.</source>
          <target state="translated">Kotlinでは、データシリアル化ツールは別のコンポーネント&lt;a href=&quot;https://github.com/Kotlin/kotlinx.serialization&quot;&gt;&lt;em&gt;kotlinx.serializationで&lt;/em&gt;&lt;/a&gt;利用できます。これは、Gradleプラグイン &lt;code&gt;org.jetbrains.kotlin.plugin.serialization&lt;/code&gt; とランタイムライブラリの2つの主要部分で構成されています。</target>
        </trans-unit>
        <trans-unit id="ccb7acc6feff10a66296746e0c93a95c37a6267f" translate="yes" xml:space="preserve">
          <source>In Kotlin, everything is an object in the sense that we can call member functions and properties on any variable. Some of the types can have a special internal representation - for example, numbers, characters and booleans can be represented as primitive values at runtime - but to the user they look like ordinary classes. In this section we describe the basic types used in Kotlin: numbers, characters, booleans, arrays, and strings.</source>
          <target state="translated">Kotlinでは、あらゆる変数のメンバ関数やプロパティを呼び出すことができるという意味で、すべてのものがオブジェクトです。型の中には特別な内部表現が可能なものもあります-例えば、数値、文字、ブーリアンは実行時にプリミティブ値として表現できますが、ユーザには普通のクラスのように見えます。このセクションでは、Kotlin で使われる基本的な型について説明します:数字、文字、ブーリアン、配列、文字列です。</target>
        </trans-unit>
        <trans-unit id="bcc1b8c2a992c6c34b455f92da91c74149cd8719" translate="yes" xml:space="preserve">
          <source>In Kotlin, functional types are represented as generic classes taking a different number of parameters: &lt;code&gt;Function0&amp;lt;R&amp;gt;&lt;/code&gt;, &lt;code&gt;Function1&amp;lt;P0, R&amp;gt;&lt;/code&gt;, &lt;code&gt;Function2&amp;lt;P0, P1, R&amp;gt;&lt;/code&gt;, &amp;hellip; This approach has a problem in that this list is finite, and it currently ends with &lt;code&gt;Function22&lt;/code&gt;.</source>
          <target state="translated">Kotlinでは、関数型は異なる数のパラメーターを取る汎用クラスとして表されます &lt;code&gt;Function0&amp;lt;R&amp;gt;&lt;/code&gt; 、 &lt;code&gt;Function1&amp;lt;P0, R&amp;gt;&lt;/code&gt; 、 &lt;code&gt;Function2&amp;lt;P0, P1, R&amp;gt;&lt;/code&gt; 、&amp;hellip;このアプローチには、このリストが有限であるという問題があります。 、現在は &lt;code&gt;Function22&lt;/code&gt; で終わります。</target>
        </trans-unit>
        <trans-unit id="dda94f8bd95fbc2c5d984c18e048611fb7b42dbc" translate="yes" xml:space="preserve">
          <source>In Kotlin, implementation inheritance is regulated by the following rule: if a class inherits many implementations of the same member from its immediate superclasses, it must override this member and provide its own implementation (perhaps, using one of the inherited ones). To denote the supertype from which the inherited implementation is taken, we use &lt;em&gt;super&lt;/em&gt; qualified by the supertype name in angle brackets, e.g. &lt;code&gt;super&amp;lt;Base&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">Kotlinでは、実装の継承は次のルールによって規制されています。クラスが同じメンバーの多くの実装を直接のスーパークラスから継承する場合、クラスはこのメンバーをオーバーライドし、独自の実装を提供する必要があります（おそらく、継承された実装の1つを使用します）。継承された実装の取得元のスーパータイプを示すために、山かっこで囲まれたスーパータイプ名で&lt;em&gt;スーパー&lt;/em&gt;修飾を使用します。例： &lt;code&gt;super&amp;lt;Base&amp;gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="7e8de20bd90cf59ff062bcee3a6b6475fd0af4bb" translate="yes" xml:space="preserve">
          <source>In Kotlin, implementation inheritance is regulated by the following rule: if a class inherits multiple implementations of the same member from its immediate superclasses, it must override this member and provide its own implementation (perhaps, using one of the inherited ones). To denote the supertype from which the inherited implementation is taken, we use &lt;em&gt;super&lt;/em&gt; qualified by the supertype name in angle brackets, e.g. &lt;code&gt;super&amp;lt;Base&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">Kotlinでは、実装の継承は次のルールによって規制されています。クラスがその直接のスーパークラスから同じメンバーの複数の実装を継承する場合、このメンバーをオーバーライドして、独自の実装を提供する必要があります（おそらく、継承されたものの1つを使用します）。継承された実装が取られているから、スーパータイプを示すために、私たちが使用する&lt;em&gt;スーパー&lt;/em&gt;角括弧内のスーパータイプ名によって修飾、例えば &lt;code&gt;super&amp;lt;Base&amp;gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="7dcc76eece2b8bf2e4ff6b5b682eb767b78c7f50" translate="yes" xml:space="preserve">
          <source>In Kotlin, importing is a compile-time concept - importing something does not actually cause any code to run (unlike Python, where all top-level statements in a file are executed at import time). Therefore, circular imports are allowed, but they might suggest a design problem in your code. However, during execution, a class will be loaded the first time it (or any of its properties or functions) is referenced, and class loading causes &lt;a href=&quot;objects-and-companion-objects#companion-objects&quot;&gt;companion objects&lt;/a&gt; to be initialized - this can lead to runtime exceptions if you have circular dependencies.</source>
          <target state="translated">Kotlinでは、インポートはコンパイル時の概念です。何かをインポートしても、実際にはコードが実行されません（Pythonとは異なり、ファイル内のすべてのトップレベルのステートメントがインポート時に実行されます）。したがって、循環インポートは許可されますが、コードの設計上の問題を示唆している可能性があります。ただし、実行時には、クラス（またはそのプロパティや関数）が最初に参照されたときにクラスが読み込まれ、クラスの読み込みによって&lt;a href=&quot;objects-and-companion-objects#companion-objects&quot;&gt;コンパニオンオブジェクト&lt;/a&gt;が初期化されます。これにより、循環依存関係がある場合、ランタイム例外が発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="9724d2f4d0f2fb74f7ee2235878c749f495a0bad" translate="yes" xml:space="preserve">
          <source>In Kotlin, polymorphism is achieved via the class hierarchy, in such a way that it is impossible to run into a situation where a property or function is missing. The basic rule is that a variable/property/parameter whose declared type is &lt;code&gt;A&lt;/code&gt; may refer to an instance of a class &lt;code&gt;B&lt;/code&gt; if and only if &lt;code&gt;B&lt;/code&gt; is a subtype of &lt;code&gt;A&lt;/code&gt;. This means that either, &lt;code&gt;A&lt;/code&gt; must be a class and &lt;code&gt;B&lt;/code&gt; must be a subclass of &lt;code&gt;A&lt;/code&gt;, or that &lt;code&gt;A&lt;/code&gt; must be an interface and &lt;code&gt;B&lt;/code&gt; must be a class that implements that interface or be a subclass of a class that does. With our classes and interfaces from the previous sections, we can define these functions:</source>
          <target state="translated">Kotlinでは、ポリモーフィズムはクラス階層を介して実現され、プロパティまたは関数が欠落している状況に遭遇することは不可能です。基本的なルールは、宣言されたタイプが &lt;code&gt;A&lt;/code&gt; である変数/プロパティ/パラメータは、 &lt;code&gt;B&lt;/code&gt; が &lt;code&gt;A&lt;/code&gt; のサブタイプである場合に限り、クラス &lt;code&gt;B&lt;/code&gt; のインスタンスを参照することができるということです。これは、 &lt;code&gt;A&lt;/code&gt; がクラスであり、 &lt;code&gt;B&lt;/code&gt; が &lt;code&gt;A&lt;/code&gt; のサブクラスであるか、または &lt;code&gt;A&lt;/code&gt; がインターフェースであり、 &lt;code&gt;B&lt;/code&gt; がそのインターフェースを実装するクラスであるか、またはそのクラスのサブクラスである必要があることを意味します。前のセクションのクラスとインターフェースを使用して、次の関数を定義できます。</target>
        </trans-unit>
        <trans-unit id="0ea4efcee086c70a1dc18d5edfeb999729e27f06" translate="yes" xml:space="preserve">
          <source>In Kotlin, semicolons are optional, and therefore line breaks are significant. The language design assumes Java-style braces, and you may encounter surprising behavior if you try to use a different formatting style.</source>
          <target state="translated">Kotlinではセミコロンはオプションなので、改行は重要です。言語設計ではJavaスタイルの中括弧を前提としているため、異なる書式スタイルを使おうとすると驚くような動作をするかもしれません。</target>
        </trans-unit>
        <trans-unit id="1ea952e978cda6b66f0b076e1bf4afae5776a252" translate="yes" xml:space="preserve">
          <source>In Kotlin, the default implementation of &lt;code&gt;List&lt;/code&gt; is &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-array-list/index&quot;&gt;&lt;code&gt;ArrayList&lt;/code&gt;&lt;/a&gt; which you can think of as a resizable array.</source>
          <target state="translated">Kotlinでは、 &lt;code&gt;List&lt;/code&gt; のデフォルト実装は&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-array-list/index&quot;&gt; &lt;code&gt;ArrayList&lt;/code&gt; で&lt;/a&gt;あり、サイズ変更可能な配列と考えることができます。</target>
        </trans-unit>
        <trans-unit id="b0f2e47b033955ac0009c7acc59029af121c0f6e" translate="yes" xml:space="preserve">
          <source>In Kotlin, the expression for a default value is evaluated every time the function is invoked. Therefore, you will avoid the above trap as long as you use an expression that produces a new list every time it is evaluated:</source>
          <target state="translated">Kotlinでは、デフォルト値の式は関数が呼び出されるたびに評価されます。したがって、評価されるたびに新しいリストを生成する式を使用している限り、上記の罠を回避することができます。</target>
        </trans-unit>
        <trans-unit id="1f711d573309109397667a32c94fd541ceecdc60" translate="yes" xml:space="preserve">
          <source>In Kotlin, the orders of objects can be defined in several ways.</source>
          <target state="translated">Kotlinでは、オブジェクトの順序をいくつかの方法で定義することができます。</target>
        </trans-unit>
        <trans-unit id="2339e3beff8d4c7968bd5b14328be82bd9a5b046" translate="yes" xml:space="preserve">
          <source>In Kotlin, the type system distinguishes between references that can hold &lt;em&gt;null&lt;/em&gt; (nullable references) and those that can not (non-null references). For example, a regular variable of type &lt;code&gt;String&lt;/code&gt; can not hold &lt;em&gt;null&lt;/em&gt;:</source>
          <target state="translated">Kotlinでは、型システムは&lt;em&gt;null&lt;/em&gt;を保持できる参照（null可能な参照）と保持できない参照（null以外の参照）を区別し&lt;em&gt;ます&lt;/em&gt;。たとえば、 &lt;code&gt;String&lt;/code&gt; 型の通常の変数は&lt;em&gt;nullを&lt;/em&gt;保持できません。</target>
        </trans-unit>
        <trans-unit id="832014b08edc07489a35f79862dd60fe09daab6f" translate="yes" xml:space="preserve">
          <source>In Kotlin, there is a convention: if the last parameter of a function is a function, then a lambda expression passed as the corresponding argument can be placed outside the parentheses:</source>
          <target state="translated">Kotlinでは、関数の最後のパラメータが関数の場合、対応する引数として渡されたラムダ式を括弧の外に置くことができます。</target>
        </trans-unit>
        <trans-unit id="c2a3923bf671e235e84ea1d045b896ec7fad1d7d" translate="yes" xml:space="preserve">
          <source>In Kotlin, there is a way to explain this sort of thing to the compiler. This is called &lt;strong&gt;declaration-site variance&lt;/strong&gt;: we can annotate the &lt;strong&gt;type parameter&lt;/strong&gt;&lt;code&gt;T&lt;/code&gt; of Source to make sure that it is only &lt;strong&gt;returned&lt;/strong&gt; (produced) from members of &lt;code&gt;Source&amp;lt;T&amp;gt;&lt;/code&gt;, and never consumed. To do this we provide the &lt;strong&gt;out&lt;/strong&gt; modifier:</source>
          <target state="translated">Kotlinには、この種のことをコンパイラーに説明する方法があります。これは&lt;strong&gt;宣言サイトバリアンス&lt;/strong&gt;と呼ばれます。Sourceの&lt;strong&gt;型パラメーター&lt;/strong&gt; &lt;code&gt;T&lt;/code&gt; に注釈を付けて、 &lt;code&gt;Source&amp;lt;T&amp;gt;&lt;/code&gt; メンバーからのみ&lt;strong&gt;返され&lt;/strong&gt;（生成され）、消費されないようにすることができます。これを行うには、&lt;strong&gt;out&lt;/strong&gt;修飾子を提供します。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="feddf47fe54f2c3f729a6d26efa190cb7e973f88" translate="yes" xml:space="preserve">
          <source>In Kotlin, unlike Java or C#, classes do not have static methods. In most cases, it's recommended to simply use package-level functions instead.</source>
          <target state="translated">Kotlin では、Java や C#とは異なり、クラスは静的メソッドを持ちません。ほとんどの場合、代わりに単にパッケージレベルの関数を使うことをお勧めします。</target>
        </trans-unit>
        <trans-unit id="d5e92ec06e3b15b62ad5ec58ebeffa93765ab71a" translate="yes" xml:space="preserve">
          <source>In Kotlin, we can only use a normal, unqualified &lt;code&gt;return&lt;/code&gt; to exit a named function or an anonymous function. This means that to exit a lambda, we have to use a &lt;a href=&quot;returns#return-at-labels&quot;&gt;label&lt;/a&gt;, and a bare &lt;code&gt;return&lt;/code&gt; is forbidden inside a lambda, because a lambda cannot make the enclosing function return:</source>
          <target state="translated">Kotlinでは、名前の付いた関数または無名関数を終了するために、通常の修飾されていない &lt;code&gt;return&lt;/code&gt; のみを使用できます。これは、ラムダを終了するには&lt;a href=&quot;returns#return-at-labels&quot;&gt;label&lt;/a&gt;を使用する必要があることを意味します。ラムダは囲み関数を返すことができないため、ラムダ内でのベア &lt;code&gt;return&lt;/code&gt; は禁止されています。</target>
        </trans-unit>
        <trans-unit id="d39c4582a1b13add9eb003022ccb3a007508d4c5" translate="yes" xml:space="preserve">
          <source>In Kotlin, we have three backends that generate executables: Kotlin/JVM, Kotlin/JS, and Kotlin/Native. Kotlin/JVM and Kotlin/JS don't share much code since they were developed independently of each other. Kotlin/Native is based on a new infrastructure built around an intermediate representation (IR) for Kotlin code.</source>
          <target state="translated">Kotlinでは、実行ファイルを生成する3つのバックエンドがあります。Kotlin/JVM、Kotlin/JS、Kotlin/Nativeです。Kotlin/JVMとKotlin/JSはそれぞれ独立して開発されているため、あまりコードを共有していません。Kotlin/Native は Kotlin コードの中間表現 (IR)を中心に構築された新しいインフラストラクチャに基づいています。</target>
        </trans-unit>
        <trans-unit id="0bc591251b1866272d3defd4ab24986b180f3e99" translate="yes" xml:space="preserve">
          <source>In Kotlin/JS implementation of StringBuilder the initial capacity has no effect on the further performance of operations.</source>
          <target state="translated">Kotlin/JSのStringBuilderの実装では、初期容量はそれ以降の操作のパフォーマンスに影響を与えません。</target>
        </trans-unit>
        <trans-unit id="3d25d5f146a0d36095ac2d2fbada4dfa30e5c1b3" translate="yes" xml:space="preserve">
          <source>In Kotlin/JS implementation of StringBuilder the size of the backing storage is always equal to the length of the string builder.</source>
          <target state="translated">Kotlin/JSのStringBuilderの実装では、バッキングストレージのサイズは常に文字列ビルダーの長さと等しくなります。</target>
        </trans-unit>
        <trans-unit id="9c5a4446d1a6bca7a876f80da83f707725750c3e" translate="yes" xml:space="preserve">
          <source>In Kotlin/JS implementation of StringBuilder the size of the backing storage is not extended to comply the given &lt;a href=&quot;ensure-capacity#kotlin.text.StringBuilder%24ensureCapacity(kotlin.Int)/minimumCapacity&quot;&gt;minimumCapacity&lt;/a&gt;, thus calling this method has no effect on the further performance of operations.</source>
          <target state="translated">StringBuilderのKotlin / JS実装では、バッキングストレージのサイズは、指定された&lt;a href=&quot;ensure-capacity#kotlin.text.StringBuilder%24ensureCapacity(kotlin.Int)/minimumCapacity&quot;&gt;minimumCapacity&lt;/a&gt;に準拠するように拡張されないため、このメソッドを呼び出しても、操作のさらなるパフォーマンスには影響しません。</target>
        </trans-unit>
        <trans-unit id="be7a0e0448f643a881b7fca70d06192aeb1ec087" translate="yes" xml:space="preserve">
          <source>In Kotlin/JS implementation of StringBuilder the value returned from this method may not indicate the actual size of the backing storage.</source>
          <target state="translated">Kotlin/JSのStringBuilderの実装では、このメソッドから返される値は、バッキングストレージの実際のサイズを示していない場合があります。</target>
        </trans-unit>
        <trans-unit id="07d924e5bfc344bb39ea0863e63e91640453cecc" translate="yes" xml:space="preserve">
          <source>In Kotlin/JS projects, all dependencies can be managed through the Gradle plugin. This includes Kotlin/Multiplatform libraries such as &lt;code&gt;kotlinx.coroutines&lt;/code&gt;, &lt;code&gt;kotlinx.serialization&lt;/code&gt;, or &lt;code&gt;ktor-client&lt;/code&gt;.</source>
          <target state="translated">Kotlin / JSプロジェクトでは、すべての依存関係をGradleプラグインで管理できます。これには、 &lt;code&gt;kotlinx.coroutines&lt;/code&gt; 、 &lt;code&gt;kotlinx.serialization&lt;/code&gt; 、 &lt;code&gt;ktor-client&lt;/code&gt; などのKotlin /マルチプラットフォームライブラリが含まれます。</target>
        </trans-unit>
        <trans-unit id="6b416b284c329b83d138fdf71a7f58ad406d7c9b" translate="yes" xml:space="preserve">
          <source>In Maven</source>
          <target state="translated">メイヴンでは</target>
        </trans-unit>
        <trans-unit id="9ce095374b679dfd053dccebdba1f6ce80a67e34" translate="yes" xml:space="preserve">
          <source>In Maven, enable the &lt;code&gt;jpa&lt;/code&gt; plugin:</source>
          <target state="translated">Mavenで &lt;code&gt;jpa&lt;/code&gt; プラグインを有効にします。</target>
        </trans-unit>
        <trans-unit id="4cf1f43e65b88c5f6958702897fafbb7af63f2e9" translate="yes" xml:space="preserve">
          <source>In Maven, enable the &lt;code&gt;spring&lt;/code&gt; plugin:</source>
          <target state="translated">Mavenのでは、有効 &lt;code&gt;spring&lt;/code&gt; プラグインを：</target>
        </trans-unit>
        <trans-unit id="14be0db4481edc4ab423c4343db7ab0c7cfdc4a9" translate="yes" xml:space="preserve">
          <source>In Maven, the &lt;code&gt;spring&lt;/code&gt; plugin is provided by the &lt;code&gt;kotlin-maven-allopen&lt;/code&gt; plugin dependency, so to enable it:</source>
          <target state="translated">Mavenのでは、 &lt;code&gt;spring&lt;/code&gt; プラグインはによって提供される &lt;code&gt;kotlin-maven-allopen&lt;/code&gt; ので、それを可能にするために、プラグインの依存：</target>
        </trans-unit>
        <trans-unit id="2fde5916b654de021cf5316e7c8446b2d071c3b3" translate="yes" xml:space="preserve">
          <source>In Maven:</source>
          <target state="translated">Mavenで。</target>
        </trans-unit>
        <trans-unit id="6dc887971001bc1cd4775889e759bfb59211b14c" translate="yes" xml:space="preserve">
          <source>In Python, function names must be unique within a module or a class. In Kotlin, we can &lt;em&gt;overload&lt;/em&gt; functions: there can be multiple declarations of functions that have the same name. Overloaded functions must be distinguishable from each other through their parameter lists. (The types of the parameter list, together with the return type, is known as a function's &lt;em&gt;signature&lt;/em&gt;, but the return type cannot be used to disambiguate overloaded functions.) For example, we can have both of these functions in the same file:</source>
          <target state="translated">Pythonでは、関数名はモジュールまたはクラス内で一意である必要があります。Kotlinでは、関数を&lt;em&gt;オーバーロード&lt;/em&gt;できます。同じ名前の関数が複数宣言されている可能性があります。オーバーロードされた関数は、パラメーターリストを通じて互いに区別できる必要があります。（パラメーターリストの型は、戻り値の型と合わせて関数の&lt;em&gt;シグネチャ&lt;/em&gt;と呼ばれますが、戻り値の型を使用して、オーバーロードされた関数を明確にすることはできません。）たとえば、これらの両方の関数を同じファイルに含めることができます。</target>
        </trans-unit>
        <trans-unit id="1c0f7f91981a6ecf109d226f21e3069c8aabc15a" translate="yes" xml:space="preserve">
          <source>In Python, the expression for a default value is evaluated once, at function definition time. That leads to this classic trap, where the developer hopes to get a new, empty list every time the function is called without a value for &lt;code&gt;numbers&lt;/code&gt;, but instead, the same list is being used every time:</source>
          <target state="translated">Pythonでは、デフォルト値の式は関数定義時に1回評価されます。これはこの古典的なトラップにつながります。開発者は、数値の値なしで関数が呼び出されるたびに新しい空のリストを取得することを望んでい &lt;code&gt;numbers&lt;/code&gt; が、代わりに同じリストが毎回使用されています。</target>
        </trans-unit>
        <trans-unit id="cd3d02ed8996a5f9eaf8b21aad3a4aaadb80de18" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;when&lt;/code&gt; statement, if a branch is more than a single line, consider separating it from adjacent case blocks with a blank line:</source>
          <target state="translated">で &lt;code&gt;when&lt;/code&gt; 、分岐は1行以上であれば文、空白行と隣接するケースブロックからそれを分離する検討します。</target>
        </trans-unit>
        <trans-unit id="3a1b36cf0bd1ee7bba19fe0760cca000ad48b849" translate="yes" xml:space="preserve">
          <source>In a long-running application you might need fine-grained control on your background coroutines. For example, a user might have closed the page that launched a coroutine and now its result is no longer needed and its operation can be cancelled. The &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/launch.html&quot;&gt;launch&lt;/a&gt; function returns a &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html&quot;&gt;Job&lt;/a&gt; that can be used to cancel the running coroutine:</source>
          <target state="translated">実行時間の長いアプリケーションでは、バックグラウンドコルーチンをきめ細かく制御する必要がある場合があります。たとえば、ユーザーがコルーチンを起動したページを閉じたために、結果が不要になり、その操作をキャンセルできる場合があります。&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/launch.html&quot;&gt;打ち上げ&lt;/a&gt;関数は返し&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html&quot;&gt;ジョブ&lt;/a&gt;実行中のコルーチンをキャンセルするために使用することができます。</target>
        </trans-unit>
        <trans-unit id="e333c99581fbe52762649b5ab0c35c55ffcd093c" translate="yes" xml:space="preserve">
          <source>In a member of a &lt;a href=&quot;classes#inheritance&quot;&gt;class&lt;/a&gt;, &lt;em&gt;this&lt;/em&gt; refers to the current object of that class.</source>
          <target state="translated">&lt;a href=&quot;classes#inheritance&quot;&gt;クラスの&lt;/a&gt;メンバーでは、&lt;em&gt;これ&lt;/em&gt;はそのクラスの現在のオブジェクトを指します。</target>
        </trans-unit>
        <trans-unit id="15a56874c4866fabbe734af8a3fb102f28e0b12f" translate="yes" xml:space="preserve">
          <source>In a nutshell, you can use libraries such as &lt;a href=&quot;https://google.github.io/dagger/&quot;&gt;Dagger&lt;/a&gt; or &lt;a href=&quot;https://developer.android.com/topic/libraries/data-binding/index.html&quot;&gt;Data Binding&lt;/a&gt; in your Kotlin projects.</source>
          <target state="translated">簡単に言えば、Kotlinプロジェクトで&lt;a href=&quot;https://google.github.io/dagger/&quot;&gt;Dagger&lt;/a&gt;や&lt;a href=&quot;https://developer.android.com/topic/libraries/data-binding/index.html&quot;&gt;Data Binding&lt;/a&gt;などのライブラリを使用できます。</target>
        </trans-unit>
        <trans-unit id="93e3893822831ac714d40df8280535305e6147f7" translate="yes" xml:space="preserve">
          <source>In a similar way to the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/collect-latest.html&quot;&gt;collectLatest&lt;/a&gt; operator, that was shown in &lt;a href=&quot;#processing-the-latest-value&quot;&gt;&quot;Processing the latest value&quot;&lt;/a&gt; section, there is the corresponding &quot;Latest&quot; flattening mode where a collection of the previous flow is cancelled as soon as new flow is emitted. It is implemented by the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flat-map-latest.html&quot;&gt;flatMapLatest&lt;/a&gt; operator.</source>
          <target state="translated">&lt;a href=&quot;#processing-the-latest-value&quot;&gt;「最新値の処理」&lt;/a&gt;セクションで示した&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/collect-latest.html&quot;&gt;collectLatest&lt;/a&gt;オペレーターと同様に、対応する「最新」フラット化モードがあり、新しいフローが発行されるとすぐに前のフローの収集がキャンセルされます。これは、&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flat-map-latest.html&quot;&gt;flatMapLatest&lt;/a&gt;オペレーターによって実装されます。</target>
        </trans-unit>
        <trans-unit id="15ca24684023d67ef7c14fca042f392a78539627" translate="yes" xml:space="preserve">
          <source>In a typical multiplatform project with two iOS-related targets &amp;ndash; &lt;code&gt;iosArm64&lt;/code&gt; and &lt;code&gt;iosX64&lt;/code&gt;, the hierarchical structure includes an intermediate source set (&lt;code&gt;iosMain&lt;/code&gt;), which is used by the platform-specific source sets.</source>
          <target state="translated">2つのiOS関連ターゲット（ &lt;code&gt;iosArm64&lt;/code&gt; と &lt;code&gt;iosX64&lt;/code&gt; ）を持つ典型的なマルチプラットフォームプロジェクトでは、階層構造には、プラットフォーム固有のソースセットによって使用される中間ソースセット（ &lt;code&gt;iosMain&lt;/code&gt; ）が含まれます。</target>
        </trans-unit>
        <trans-unit id="bc60b5f1d9e8600ceb6b31da789280579a4f556c" translate="yes" xml:space="preserve">
          <source>In actual applications a scope will come from an entity with a limited lifetime. As soon as the lifetime of this entity is terminated the corresponding scope is cancelled, cancelling the collection of the corresponding flow. This way the pair of &lt;code&gt;onEach { ... }.launchIn(scope)&lt;/code&gt; works like the &lt;code&gt;addEventListener&lt;/code&gt;. However, there is no need for the corresponding &lt;code&gt;removeEventListener&lt;/code&gt; function, as cancellation and structured concurrency serve this purpose.</source>
          <target state="translated">実際のアプリケーションでは、スコープは有効期間が制限されたエンティティから取得されます。このエンティティの存続期間が終了するとすぐに、対応するスコープがキャンセルされ、対応するフローの収集がキャンセルされます。このように、 &lt;code&gt;onEach { ... }.launchIn(scope)&lt;/code&gt; のペアは &lt;code&gt;addEventListener&lt;/code&gt; のように機能します。ただし、キャンセルと構造化された同時実行がこの目的を果たすため、対応する &lt;code&gt;removeEventListener&lt;/code&gt; 関数は必要ありません。</target>
        </trans-unit>
        <trans-unit id="6b7464c5f857646c373051a91afcc2339f5f7b93" translate="yes" xml:space="preserve">
          <source>In addition to &lt;a href=&quot;#common-target-configuration&quot;&gt;common target configuration&lt;/a&gt;, &lt;code&gt;jvm&lt;/code&gt; targets have a specific function:</source>
          <target state="translated">&lt;a href=&quot;#common-target-configuration&quot;&gt;一般的なターゲット構成に&lt;/a&gt;加えて、 &lt;code&gt;jvm&lt;/code&gt; ターゲットには特定の機能があります。</target>
        </trans-unit>
        <trans-unit id="b9d98c12799fcb8ef0ae80c451d81a3c8245f3f0" translate="yes" xml:space="preserve">
          <source>In addition to &lt;code&gt;try&lt;/code&gt;/&lt;code&gt;catch&lt;/code&gt;, a collector can also use a &lt;code&gt;finally&lt;/code&gt; block to execute an action upon &lt;code&gt;collect&lt;/code&gt; completion.</source>
          <target state="translated">&lt;code&gt;try&lt;/code&gt; / &lt;code&gt;catch&lt;/code&gt; に加えて、コレクターは &lt;code&gt;finally&lt;/code&gt; ブロックを使用して、 &lt;code&gt;collect&lt;/code&gt; 完了時にアクションを実行することもできます。</target>
        </trans-unit>
        <trans-unit id="5544e7dcfdd04da3eceaae6a1614ec1e4f550da9" translate="yes" xml:space="preserve">
          <source>In addition to &lt;strong&gt;out&lt;/strong&gt;, Kotlin provides a complementary variance annotation: &lt;strong&gt;in&lt;/strong&gt;. It makes a type parameter &lt;strong&gt;contravariant&lt;/strong&gt;: it can only be consumed and never produced. A good example of a contravariant type is &lt;code&gt;Comparable&lt;/code&gt;:</source>
          <target state="translated">&lt;strong&gt;out&lt;/strong&gt;に加え&lt;strong&gt;て&lt;/strong&gt;、Kotlinは補完的な分散アノテーションを提供します：&lt;strong&gt;in&lt;/strong&gt;。型パラメーターを&lt;strong&gt;反変に&lt;/strong&gt;します。消費のみ可能で、生成はできません。反変型の良い例は &lt;code&gt;Comparable&lt;/code&gt; です：</target>
        </trans-unit>
        <trans-unit id="c6329f208d955601deb101d4b33fc1acdf8accac" translate="yes" xml:space="preserve">
          <source>In addition to common operations for &lt;a href=&quot;collection-parts&quot;&gt;Retrieving Collection Parts&lt;/a&gt;, lists provide the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-list/sub-list&quot;&gt;&lt;code&gt;subList()&lt;/code&gt;&lt;/a&gt; function that returns a view of the specified elements range as a list. Thus, if an element of the original collection changes, it also changes in the previously created sublists and vice versa.</source>
          <target state="translated">&lt;a href=&quot;collection-parts&quot;&gt;コレクションパーツ&lt;/a&gt;を取得するための一般的な操作に加えて、リストは、指定された要素の範囲のビューをリストとして返す&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-list/sub-list&quot;&gt; &lt;code&gt;subList()&lt;/code&gt; &lt;/a&gt;関数を提供します。したがって、元のコレクションの要素が変更されると、以前に作成されたサブリストでも変更され、逆も同様です。</target>
        </trans-unit>
        <trans-unit id="f8a12fad9d12380d0581bf388509c212413ee01b" translate="yes" xml:space="preserve">
          <source>In addition to predefined compilations, you can create your own custom compilations. To create a custom compilation, add a new item into the &lt;code&gt;compilations&lt;/code&gt; collection. If using Kotlin Gradle DSL, mark custom compilations &lt;code&gt;by creating&lt;/code&gt;.</source>
          <target state="translated">事前定義されたコンパイルに加えて、独自のカスタムコンパイルを作成できます。カスタムコンパイルを作成するには、 &lt;code&gt;compilations&lt;/code&gt; コレクションに新しいアイテムを追加します。Kotlin Gradle DSLを使用している場合は、を &lt;code&gt;by creating&lt;/code&gt; カスタムコンパイルにマークを付けます。</target>
        </trans-unit>
        <trans-unit id="9674c96ddd7757af7200ad4daae22ce260bb2047" translate="yes" xml:space="preserve">
          <source>In addition to removing elements, the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-mutable-list-iterator/index&quot;&gt;&lt;code&gt;MutableListIterator&lt;/code&gt;&lt;/a&gt; can also insert and replace elements while iterating the list.</source>
          <target state="translated">要素の削除に加えて、&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-mutable-list-iterator/index&quot;&gt; &lt;code&gt;MutableListIterator&lt;/code&gt; &lt;/a&gt;はリストの反復中に要素を挿入および置換することもできます。</target>
        </trans-unit>
        <trans-unit id="38a6e3c954dde3e3eb6edba41ad0b83ce52bd70c" translate="yes" xml:space="preserve">
          <source>In addition to scope functions, the standard library contains the functions &lt;code&gt;takeIf&lt;/code&gt; and &lt;code&gt;takeUnless&lt;/code&gt;. These functions let you embed checks of the object state in call chains.</source>
          <target state="translated">スコープ関数に加えて、標準ライブラリには関数 &lt;code&gt;takeIf&lt;/code&gt; および &lt;code&gt;takeUnless&lt;/code&gt; が含まれています。これらの関数を使用すると、オブジェクト状態のチェックを呼び出しチェーンに埋め込むことができます。</target>
        </trans-unit>
        <trans-unit id="f1257110cb9cb8a007e2fdc06c4e2227ea7a3c26" translate="yes" xml:space="preserve">
          <source>In addition to suspend conversion on lambdas, Kotlin now supports suspend conversion on callable references starting from version 1.4.0.</source>
          <target state="translated">ラムダへのサスペンド変換に加えて、Kotlinはバージョン1.4.0から呼び出し可能な参照へのサスペンド変換をサポートするようになりました。</target>
        </trans-unit>
        <trans-unit id="acfd15e725bcfef6236f16c4782a0f3dc2126f4d" translate="yes" xml:space="preserve">
          <source>In addition to that, you can use &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.js/js&quot;&gt;KClass.js&lt;/a&gt; to access the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.js/-js-class/index&quot;&gt;JsClass&lt;/a&gt; instance corresponding to the class. The &lt;code&gt;JsClass&lt;/code&gt; instance itself is a reference to the constructor function. This can be used to interoperate with JS functions that expect a reference to a constructor.</source>
          <target state="translated">さらに、&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.js/js&quot;&gt;KClass.js&lt;/a&gt;を使用して、クラスに対応する&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.js/-js-class/index&quot;&gt;JsClass&lt;/a&gt;インスタンスにアクセスできます。 &lt;code&gt;JsClass&lt;/code&gt; のインスタンス自体は、コンストラクタ関数への参照です。これは、コンストラクターへの参照を期待するJS関数と相互運用するために使用できます。</target>
        </trans-unit>
        <trans-unit id="e90b7801c53c4e41da0228b0d27c84622a6be4c2" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;a href=&quot;#common-options&quot;&gt;common options&lt;/a&gt;, Kotlin/JS compiler has the options listed below.</source>
          <target state="translated">&lt;a href=&quot;#common-options&quot;&gt;一般的なオプションに&lt;/a&gt;加えて、Kotlin / JSコンパイラには以下のオプションがあります。</target>
        </trans-unit>
        <trans-unit id="858ccef9738a93100e88ac347adf42b1aff3915a" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;a href=&quot;#common-options&quot;&gt;common options&lt;/a&gt;, Kotlin/JVM compiler has the options listed below.</source>
          <target state="translated">&lt;a href=&quot;#common-options&quot;&gt;一般的なオプションに&lt;/a&gt;加えて、Kotlin / JVMコンパイラには以下のオプションがあります。</target>
        </trans-unit>
        <trans-unit id="0c87fecf2d35b4b8f103d9e391aeb9f3722b8880" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;a href=&quot;#common-options&quot;&gt;common options&lt;/a&gt;, Kotlin/Native compiler has the options listed below.</source>
          <target state="translated">&lt;a href=&quot;#common-options&quot;&gt;一般的なオプションに&lt;/a&gt;加えて、Kotlin / Nativeコンパイラには以下のオプションがあります。</target>
        </trans-unit>
        <trans-unit id="36b7ccec26bcb88294baf54023cc9ae72ecaa90f" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;a href=&quot;typecasts#unsafe-cast-operator&quot;&gt;&quot;unsafe&quot; cast operator&lt;/a&gt;&lt;code&gt;as&lt;/code&gt;, which throws a &lt;code&gt;ClassCastException&lt;/code&gt; in case a cast is not possible, Kotlin/JS also provides &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.js/unsafe-cast&quot;&gt;&lt;code&gt;unsafeCast&amp;lt;T&amp;gt;()&lt;/code&gt;&lt;/a&gt;. When using &lt;code&gt;unsafeCast&lt;/code&gt;, &lt;em&gt;no type checking is done at all&lt;/em&gt; during runtime. For example, consider the following two methods:</source>
          <target state="translated">キャストが不可能な場合に &lt;code&gt;ClassCastException&lt;/code&gt; をスローする&lt;a href=&quot;typecasts#unsafe-cast-operator&quot;&gt;「安全でない」キャスト演算子&lt;/a&gt; &lt;code&gt;as&lt;/code&gt; に加えて、Kotlin / JSは&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.js/unsafe-cast&quot;&gt; &lt;code&gt;unsafeCast&amp;lt;T&amp;gt;()&lt;/code&gt; &lt;/a&gt;も提供します。 &lt;code&gt;unsafeCast&lt;/code&gt; を使用する場合、実行時に&lt;em&gt;型チェックはまったく行われません&lt;/em&gt;。たとえば、次の2つの方法について考えてみます。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5594aa712f7692fd1a48c40180fe2939a4654a66" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;code&gt;kotlin-gradle-plugin&lt;/code&gt; dependency shown above, you need to add a dependency on the Kotlin standard library:</source>
          <target state="translated">上記の &lt;code&gt;kotlin-gradle-plugin&lt;/code&gt; 依存関係に加えて、Kotlin標準ライブラリへの依存関係を追加する必要があります。</target>
        </trans-unit>
        <trans-unit id="ea7c2f23dd342e78eba03e7edea502fd9fbb6ef4" translate="yes" xml:space="preserve">
          <source>In addition to the build tasks, the Gradle build includes helpful tasks to run the application directly via &lt;code&gt;runDebugExecutableNative&lt;/code&gt; and &lt;code&gt;runReleaseExecutableNative&lt;/code&gt;.</source>
          <target state="translated">ビルドタスクに加えて、Gradleビルドには、 &lt;code&gt;runDebugExecutableNative&lt;/code&gt; および &lt;code&gt;runReleaseExecutableNative&lt;/code&gt; を介してアプリケーションを直接実行するための便利なタスクが含まれています。</target>
        </trans-unit>
        <trans-unit id="1d5b7f7ad1a1556c56ce8e8eb4580dccfbc4c337" translate="yes" xml:space="preserve">
          <source>In addition to the collection modification operations described in &lt;a href=&quot;collection-write&quot;&gt;Collection Write Operations&lt;/a&gt;, &lt;a href=&quot;collections-overview#collection-types&quot;&gt;mutable&lt;/a&gt; lists support specific write operations. Such operations use the index to access elements to broaden the list modification capabilities.</source>
          <target state="translated">&lt;a href=&quot;collection-write&quot;&gt;コレクションの書き込み&lt;/a&gt;操作で説明されているコレクションの変更操作に加えて、&lt;a href=&quot;collections-overview#collection-types&quot;&gt;可変&lt;/a&gt;リストは特定の書き込み操作をサポートしています。このような操作では、インデックスを使用して要素にアクセスし、リスト変更機能を拡張します。</target>
        </trans-unit>
        <trans-unit id="edff8af41569526ee6f34e250c39b84435f2d3a3" translate="yes" xml:space="preserve">
          <source>In addition to the command line compiler and IntelliJ IDEA, you can also build Kotlin projects with Ant, Maven, and Gradle.</source>
          <target state="translated">コマンドラインコンパイラやIntelliJ IDEAに加えて、Ant、Maven、Gradleを使ってKotlinプロジェクトを構築することができます。</target>
        </trans-unit>
        <trans-unit id="13939289a96ed1a1e50225139ac3fbd7b0bc2be9" translate="yes" xml:space="preserve">
          <source>In addition to the coroutine scope provided by different builders, it is possible to declare your own scope using &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;coroutineScope&lt;/a&gt; builder. It creates a coroutine scope and does not complete until all launched children complete. The main difference between &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt; and &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;coroutineScope&lt;/a&gt; is that the latter does not block the current thread while waiting for all children to complete.</source>
          <target state="translated">別のビルダーによって提供さコルーチン範囲に加えて、使用して独自のスコープを宣言することが可能である&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;coroutineScopeの&lt;/a&gt;ビルダーを。コルーチンスコープを作成し、起動されたすべての子が完了するまで完了しません。主な違い&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt;と&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;coroutineScopeは&lt;/a&gt;完全にすべての子供たちを待っている間に、後者は現在のスレッドをブロックしていないということです。</target>
        </trans-unit>
        <trans-unit id="e5077ac7f8cceff0957d255db71b0d1a0a24a0ba" translate="yes" xml:space="preserve">
          <source>In addition to the coroutine scope provided by different builders, it is possible to declare your own scope using the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;coroutineScope&lt;/a&gt; builder. It creates a coroutine scope and does not complete until all launched children complete.</source>
          <target state="translated">別のビルダーによって提供さコルーチン範囲に加えて、使用して独自のスコープを宣言することが可能である&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;coroutineScopeの&lt;/a&gt;ビルダーを。コルーチンスコープを作成し、起動されたすべての子が完了するまで完了しません。</target>
        </trans-unit>
        <trans-unit id="063fa2441ff30c74a010fc27ec5f2018d7ca4ef2" translate="yes" xml:space="preserve">
          <source>In addition to the output JavaScript file, the plugin by default creates an additional JS file with binary descriptors. This file is required if you're building a reusable library that other Kotlin modules can depend on, and should be distributed together with the result of translation. The generation is controlled by the &lt;code&gt;kotlinOptions.metaInfo&lt;/code&gt; option:</source>
          <target state="translated">出力JavaScriptファイルに加えて、プラグインはデフォルトでバイナリ記述子を含む追加のJSファイルを作成します。このファイルは、他のKotlinモジュールが依存できる再利用可能なライブラリを構築する場合に必要であり、変換の結果とともに配布する必要があります。生成は、 &lt;code&gt;kotlinOptions.metaInfo&lt;/code&gt; オプションによって制御されます。</target>
        </trans-unit>
        <trans-unit id="4c8c93a8699f08045725902510444a7e2a812bf3" translate="yes" xml:space="preserve">
          <source>In addition, Rx does introduce a somewhat nicer approach to error handling.</source>
          <target state="translated">加えて、Rx はエラー処理に多少マシなアプローチを導入しています。</target>
        </trans-unit>
        <trans-unit id="3434b058fadc1fd97196abc0cd226b5de0eff131" translate="yes" xml:space="preserve">
          <source>In addition, each of these also have a corresponding &lt;code&gt;{file}.meta.js&lt;/code&gt; meta file which will be used for reflection and other functionality.</source>
          <target state="translated">さらに、これらのそれぞれには対応する &lt;code&gt;{file}.meta.js&lt;/code&gt; メタファイルがあり、リフレクションやその他の機能に使用されます。</target>
        </trans-unit>
        <trans-unit id="adf05c9d4a5ea22db47de9f6cd0f0a1f61618f95" translate="yes" xml:space="preserve">
          <source>In all cases, the C string is supposed to be encoded as UTF-8.</source>
          <target state="translated">いずれの場合も、Cの文字列はUTF-8でエンコードされることになっています。</target>
        </trans-unit>
        <trans-unit id="2ad8a2cde437dc29e925bd2e2608bcf1efd428d2" translate="yes" xml:space="preserve">
          <source>In all respects, this is just the same as in Java since access to private properties with default getters and setters is optimized so that no function call overhead is introduced.</source>
          <target state="translated">デフォルトのゲッターやセッターを使ったプライベート・プロパティへのアクセスが最適化されているため、関数呼び出しのオーバーヘッドが発生しません。</target>
        </trans-unit>
        <trans-unit id="af3fb6a2c1c95a7bcc9ea3f79ae7998d4cb1b27a" translate="yes" xml:space="preserve">
          <source>In an &lt;a href=&quot;extensions&quot;&gt;extension function&lt;/a&gt; or a &lt;a href=&quot;lambdas#function-literals-with-receiver&quot;&gt;function literal with receiver&lt;/a&gt;&lt;em&gt;this&lt;/em&gt; denotes the &lt;em&gt;receiver&lt;/em&gt; parameter that is passed on the left-hand side of a dot.</source>
          <target state="translated">で&lt;a href=&quot;extensions&quot;&gt;拡張機能&lt;/a&gt;または&lt;a href=&quot;lambdas#function-literals-with-receiver&quot;&gt;受信機と関数リテラル&lt;/a&gt;&lt;em&gt;この&lt;/em&gt;意味&lt;em&gt;受信&lt;/em&gt;ドットの左側に渡されるパラメータ。</target>
        </trans-unit>
        <trans-unit id="751813b87d30d6501d1bf6ea23fd73a02ca28ea0" translate="yes" xml:space="preserve">
          <source>In an inline function definition, you can use &lt;code&gt;noinline&lt;/code&gt; in front of any function-typed parameter to prevent the lambda that will be passed to it from also being inlined.</source>
          <target state="translated">インライン関数定義では、関数型パラメーターの前に &lt;code&gt;noinline&lt;/code&gt; を使用して、渡されるラムダもインライン化されないようにすることができます。</target>
        </trans-unit>
        <trans-unit id="751fca68ff5e9efd6f13ba9f691a416e15e88e6e" translate="yes" xml:space="preserve">
          <source>In any lists, you can find the position of an element using the functions &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/index-of&quot;&gt;&lt;code&gt;indexOf()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/last-index-of&quot;&gt;&lt;code&gt;lastIndexOf()&lt;/code&gt;&lt;/a&gt;. They return the first and the last position of an element equal to the given argument in the list. If there are no such elements, both functions return &lt;code&gt;-1&lt;/code&gt;.</source>
          <target state="translated">どのリストでも、関数&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/index-of&quot;&gt; &lt;code&gt;indexOf()&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/last-index-of&quot;&gt; &lt;code&gt;lastIndexOf()&lt;/code&gt; &lt;/a&gt;を使用して要素の位置を見つけることができます。それらは、リスト内の指定された引数に等しい要素の最初と最後の位置を返します。そのような要素がない場合、どちらの関数も &lt;code&gt;-1&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="28ad7357688ca2a3f1fc903df2a6eb9517f15794" translate="yes" xml:space="preserve">
          <source>In any target block, you can use the following declarations:</source>
          <target state="translated">任意のターゲットブロックでは、以下の宣言を使用することができます。</target>
        </trans-unit>
        <trans-unit id="c3c35f058a2881495687f9b24556ffc42c9b3b89" translate="yes" xml:space="preserve">
          <source>In approach it's quite similar to Futures, but one can think of a Future as returning a discrete element, whereby Rx returns a stream. However, similar to the previous, it also introduces a complete new way of thinking about our programming model, famously phrased as</source>
          <target state="translated">アプローチとしてはFuturesに非常に似ていますが、Futureは離散的な要素を返すと考えることができ、Rxはストリームを返すことになります。しかし、前のものと似ていますが、これはプログラミングモデルについての全く新しい考え方を導入しています。</target>
        </trans-unit>
        <trans-unit id="afaa57d188a4de777b467f6dcde31f2f2cfb5700" translate="yes" xml:space="preserve">
          <source>In case if any two entries are mapped to the equal keys, the value of the latter one will overwrite the value associated with the former one.</source>
          <target state="translated">2つのエントリがイコールキーにマッピングされている場合、後者の値が前者の値を上書きします。</target>
        </trans-unit>
        <trans-unit id="ab773dc6434fe9e51f59bd2f39f7407e2e315f54" translate="yes" xml:space="preserve">
          <source>In case if the resource is being closed due to an exception occurred in &lt;a href=&quot;use#kotlin%24use%28kotlin.use.T%2C+kotlin.Function1%28%28kotlin.use.T%2C+kotlin.use.R%29%29%29%2Fblock&quot;&gt;block&lt;/a&gt;, and the closing also fails with an exception, the latter is added to the &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/lang/Throwable.html#addSuppressed(java.lang.Throwable)&quot;&gt;suppressed&lt;/a&gt; exceptions of the former.</source>
          <target state="translated">&lt;a href=&quot;use#kotlin%24use%28kotlin.use.T%2C+kotlin.Function1%28%28kotlin.use.T%2C+kotlin.use.R%29%29%29%2Fblock&quot;&gt;ブロック&lt;/a&gt;で発生した例外が原因でリソースが閉じられていて、そのクローズも例外で失敗した場合、後者は前者の&lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/lang/Throwable.html#addSuppressed(java.lang.Throwable)&quot;&gt;抑制&lt;/a&gt;された例外に追加されます。</target>
        </trans-unit>
        <trans-unit id="753affb3f26053a8d6fe6a50898f37935f2da6a8" translate="yes" xml:space="preserve">
          <source>In case if the resource is being closed due to an exception occurred in &lt;a href=&quot;use#kotlin%24use(kotlin.use.T,%20kotlin.Function1((kotlin.use.T,%20kotlin.use.R)))/block&quot;&gt;block&lt;/a&gt;, and the closing also fails with an exception, the latter is added to the suppressed exceptions of the former.</source>
          <target state="translated">&lt;a href=&quot;use#kotlin%24use(kotlin.use.T,%20kotlin.Function1((kotlin.use.T,%20kotlin.use.R)))/block&quot;&gt;ブロック&lt;/a&gt;で例外が発生したためにリソースがクローズされていて、例外でクローズも失敗した場合、前者の抑制された例外に後者が追加されます。</target>
        </trans-unit>
        <trans-unit id="a99d3de27a9334d7d61ccdc4fea1d3937e232802" translate="yes" xml:space="preserve">
          <source>In case if there are non-blank lines with no leading whitespace characters (no indent at all) then the common indent is 0, and therefore this function doesn't change the indentation.</source>
          <target state="translated">空白でない行で先頭の空白文字がない(インデントが全くない)場合は、共通のインデントは0になりますので、この関数はインデントを変更しません。</target>
        </trans-unit>
        <trans-unit id="c60b20e0301bd757b71bb24ccc047d80b78f21b1" translate="yes" xml:space="preserve">
          <source>In case of a name conflict between the members of the dispatch receiver and the extension receiver, the extension receiver takes precedence. To refer to the member of the dispatch receiver you can use the &lt;a href=&quot;this-expressions#qualified&quot;&gt;qualified &lt;code&gt;this&lt;/code&gt; syntax&lt;/a&gt;.</source>
          <target state="translated">ディスパッチレシーバーと拡張レシーバーのメンバー間で名前が競合する場合、拡張レシーバーが優先されます。ディスパッチレシーバーのメンバーを参照するには、&lt;a href=&quot;this-expressions#qualified&quot;&gt;修飾された &lt;code&gt;this&lt;/code&gt; 構文を&lt;/a&gt;使用できます。</target>
        </trans-unit>
        <trans-unit id="2564f2a33e66657de3341732c5e625e51d4323de" translate="yes" xml:space="preserve">
          <source>In case of the extension property in a class, the instance of the class should be passed first and the instance of the extension receiver second.</source>
          <target state="translated">クラス内の拡張プロパティの場合は、そのクラスのインスタンスを先に渡し、拡張受信側のインスタンスを後に渡します。</target>
        </trans-unit>
        <trans-unit id="1a1fb30f33e29cde0e4a9adce651bb450975c80d" translate="yes" xml:space="preserve">
          <source>In case this type is based on an inner class, the returned list contains the type arguments provided for the innermost class first, then its outer class, and so on. For example, in the type &lt;code&gt;Outer&amp;lt;A, B&amp;gt;.Inner&amp;lt;C, D&amp;gt;&lt;/code&gt; the returned list is &lt;code&gt;[C, D, A, B]&lt;/code&gt;.</source>
          <target state="translated">この型が内部クラスに基づいている場合、返されるリストには、最初に最も内側のクラス、次にその外部クラスなどに提供される型引数が含まれます。たとえば、タイプ &lt;code&gt;Outer&amp;lt;A, B&amp;gt;.Inner&amp;lt;C, D&amp;gt;&lt;/code&gt; では、返されるリストは &lt;code&gt;[C, D, A, B]&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="744293bc64c3188af17bab32f33333fe2cad85c9" translate="yes" xml:space="preserve">
          <source>In case you want only some of the lambdas passed to an inline function to be inlined, you can mark some of your function parameters with the &lt;code&gt;noinline&lt;/code&gt; modifier:</source>
          <target state="translated">インライン関数に渡されるラムダの一部のみをインライン化する場合は、関数パラメーターの一部を &lt;code&gt;noinline&lt;/code&gt; 修飾子でマークできます。</target>
        </trans-unit>
        <trans-unit id="816f79d2ddebc85fd82a80af3cc580e6eeb81694" translate="yes" xml:space="preserve">
          <source>In case you're wondering about how &lt;code&gt;use&lt;/code&gt;, which is a function, can just be followed by a block like that, see the section on &lt;a href=&quot;functional-programming#receivers&quot;&gt;DSL support&lt;/a&gt;.</source>
          <target state="translated">関数である &lt;code&gt;use&lt;/code&gt; の後に、そのようなブロックを続ける方法について疑問がある場合は、&lt;a href=&quot;functional-programming#receivers&quot;&gt;DSLサポート&lt;/a&gt;に関するセクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="de1e14373afc30cdce829d5ccf1028c05a1345bf" translate="yes" xml:space="preserve">
          <source>In common code:</source>
          <target state="translated">共通のコードで</target>
        </trans-unit>
        <trans-unit id="dbd13320c78fae25fd6f48673f77aea087d10896" translate="yes" xml:space="preserve">
          <source>In essence, this allows for the following code:</source>
          <target state="translated">本質的には、これにより以下のようなコードが可能になります。</target>
        </trans-unit>
        <trans-unit id="b797e297636a01e5f39faa44903e3922322a2f0c" translate="yes" xml:space="preserve">
          <source>In fact, for declaring properties and initializing them from the primary constructor, Kotlin has a concise syntax:</source>
          <target state="translated">実際、プロパティの宣言やプライマリコンストラクタからの初期化については、Kotlinには簡潔な構文があります。</target>
        </trans-unit>
        <trans-unit id="8575e5bc9be645637c35224eaab5422d26408ea8" translate="yes" xml:space="preserve">
          <source>In further sections, these concepts are described in more detail along with the DSL to configure them in a project.</source>
          <target state="translated">後のセクションでは、これらの概念をプロジェクトで設定するためのDSLと一緒に、より詳細に説明します。</target>
        </trans-unit>
        <trans-unit id="b8f977357563759de0c40c521cc75a6bcef24abd" translate="yes" xml:space="preserve">
          <source>In future versions, the hierarchical project structure will become default for Kotlin multiplatform project, so we strongly encourage you to start using it now.</source>
          <target state="translated">将来のバージョンでは、Kotlinのマルチプラットフォームプロジェクトでは階層的なプロジェクト構造がデフォルトになりますので、今から使い始めることを強くお勧めします。</target>
        </trans-unit>
        <trans-unit id="7ca8fe04f8968119833a10d8a0204e9737ceb843" translate="yes" xml:space="preserve">
          <source>In future versions, the hierarchical project structure with the usage of platform-dependent libraries in shared source sets will be the default in multiplatform projects. So the sooner you support it, the sooner users will be able to migrate. We&amp;rsquo;ll also be very grateful if you report any bugs you find to our &lt;a href=&quot;http://kotl.in/issue&quot;&gt;issue tracker.&lt;/a&gt;</source>
          <target state="translated">将来のバージョンでは、共有ソースセットでプラットフォームに依存するライブラリを使用する階層プロジェクト構造が、マルチプラットフォームプロジェクトのデフォルトになります。したがって、サポートが早ければ早いほど、ユーザーはより早く移行できるようになります。また、発見したバグを&lt;a href=&quot;http://kotl.in/issue&quot;&gt;問題追跡システムに&lt;/a&gt;報告していただければ幸いです。</target>
        </trans-unit>
        <trans-unit id="093d33db378ee271b0948a0579ab35389d4e97d5" translate="yes" xml:space="preserve">
          <source>In general, for small projects, we recommend converting all the files at once.</source>
          <target state="translated">一般的に、小規模なプロジェクトの場合は、一度にすべてのファイルを変換することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="2ad6bf46a8b188e9bc3522dea93919d7678b502b" translate="yes" xml:space="preserve">
          <source>In general, identifiers may consist of letters, digits, and underscores, and may not begin with a digit. However, if you are writing code that e.g. autogenerates JSON based on identifiers and you want the JSON key to be a string that does not conform to these rules or that collides with a keyword, you can enclose it in backticks: &lt;code&gt;`I can't believe this is not an error!`&lt;/code&gt; is a valid identifier.</source>
          <target state="translated">一般に、識別子は文字、数字、アンダースコアで構成され、数字で始めることはできません。あなたが例えば自動生成識別子に基づいてJSONやキーワードでこれらの規則やその衝突に準拠していない文字列になるようにJSONのキーが欲しいというコードを書いている場合は、あなたはバッククォートで囲むことができます： &lt;code&gt;`I can't believe this is not an error!`&lt;/code&gt; は有効な識別子です。</target>
        </trans-unit>
        <trans-unit id="def8cf1480d12ae42f29a02a77be00f6fa6a05e6" translate="yes" xml:space="preserve">
          <source>In general, if a certain syntactic construction in Kotlin is optional and highlighted by the IDE as redundant, you should omit it in your code. Do not leave unnecessary syntactic elements in code just &quot;for clarity&quot;.</source>
          <target state="translated">一般的に、Kotlin のある構文の構成がオプションであり、IDE によって冗長であると強調されている場合は、コードの中でそれを省略するべきです。コードの中に不要な構文的要素を「わかりやすくするため」に残してはいけません。</target>
        </trans-unit>
        <trans-unit id="01b3fb6a7b9e95b734c635ce49024c6d660e14c4" translate="yes" xml:space="preserve">
          <source>In general, to create an instance of such a class, we need to provide the type arguments:</source>
          <target state="translated">一般的に、このようなクラスのインスタンスを作成するには、型の引数を提供する必要があります。</target>
        </trans-unit>
        <trans-unit id="450c32ce21d7e1cf7d82473c6445b4ccee4985e3" translate="yes" xml:space="preserve">
          <source>In generated code, the Kotlin compiler keeps a &lt;em&gt;wrapper&lt;/em&gt; for each inline class. Inline class instances can be represented at runtime either as wrappers or as the underlying type. This is similar to how &lt;code&gt;Int&lt;/code&gt; can be &lt;a href=&quot;basic-types#representation&quot;&gt;represented&lt;/a&gt; either as a primitive &lt;code&gt;int&lt;/code&gt; or as the wrapper &lt;code&gt;Integer&lt;/code&gt;.</source>
          <target state="translated">生成されたコードでは、Kotlinコンパイラは各インラインクラスの&lt;em&gt;ラッパー&lt;/em&gt;を保持し&lt;em&gt;ます&lt;/em&gt;。インラインクラスインスタンスは、実行時にラッパーまたは基になる型として表すことができます。これは、 &lt;code&gt;Int&lt;/code&gt; をプリミティブ &lt;code&gt;int&lt;/code&gt; またはラッパー &lt;code&gt;Integer&lt;/code&gt; として&lt;a href=&quot;basic-types#representation&quot;&gt;表す&lt;/a&gt;方法と似ています。</target>
        </trans-unit>
        <trans-unit id="fd80bee1bf4ef4cc9fdfdeda947dd40e1e56db38" translate="yes" xml:space="preserve">
          <source>In lambda expressions, spaces should be used around the curly braces, as well as around the arrow which separates the parameters from the body. If a call takes a single lambda, it should be passed outside of parentheses whenever possible.</source>
          <target state="translated">ラムダ式では、中括弧の周りや、パラメータと本文を区切る矢印の周りにスペースを使用する必要があります。呼び出しが単一のラムダを取る場合は、可能な限り括弧の外に渡さなければなりません。</target>
        </trans-unit>
        <trans-unit id="80c8a890c9d273e819066140d09ce2d0bc285c7d" translate="yes" xml:space="preserve">
          <source>In lambdas which are short and not nested, it's recommended to use the &lt;code&gt;it&lt;/code&gt; convention instead of declaring the parameter explicitly. In nested lambdas with parameters, parameters should be always declared explicitly.</source>
          <target state="translated">短く、ネストされていないラムダでは、パラメーターを明示的に宣言する代わりに &lt;code&gt;it&lt;/code&gt; 規則を使用することをお勧めします。パラメータを持つネストされたラムダでは、パラメータは常に明示的に宣言する必要があります。</target>
        </trans-unit>
        <trans-unit id="0f96591676e8e90474bcc2e9cbd0fe550a87c6d7" translate="yes" xml:space="preserve">
          <source>In long argument lists, put a line break after the opening parenthesis. Indent arguments by 4 spaces. Group multiple closely related arguments on the same line.</source>
          <target state="translated">長い引数リストでは、最初の括弧の後に改行を入れます。引数を4スペースでインデントする。密接に関連する複数の引数を同じ行にグループ化する。</target>
        </trans-unit>
        <trans-unit id="e70f274fab45a9ad1cf0f5234b5a4c58fefd78f6" translate="yes" xml:space="preserve">
          <source>In many cases, one does not need to use explicit cast operators in Kotlin, because the compiler tracks the &lt;code&gt;is&lt;/code&gt;-checks and &lt;a href=&quot;#unsafe-cast-operator&quot;&gt;explicit casts&lt;/a&gt; for immutable values and inserts (safe) casts automatically when needed:</source>
          <target state="translated">多くの場合、Kotlinで明示的なキャスト演算子を使用する必要はありません。これは、コンパイラが不変値の &lt;code&gt;is&lt;/code&gt; チェックと&lt;a href=&quot;#unsafe-cast-operator&quot;&gt;明示的なキャスト&lt;/a&gt;を追跡し、必要に応じて（安全な）キャストを自動的に挿入するためです。</target>
        </trans-unit>
        <trans-unit id="d05a001b4fb4f64cd4a87d987f4f265545ae66a8" translate="yes" xml:space="preserve">
          <source>In mixed-language projects, Kotlin source files should reside in the same source root as the Java source files, and follow the same directory structure (each file should be stored in the directory corresponding to each package statement).</source>
          <target state="translated">混合言語プロジェクトでは、Kotlin のソースファイルは Java のソースファイルと同じソースルートに存在し、同じディレクトリ構造に従うべきです (各ファイルは各パッケージ文に対応するディレクトリに格納されるべきです)。</target>
        </trans-unit>
        <trans-unit id="75f610c8e81d1558fc92e1b43e9b512e7f4028a1" translate="yes" xml:space="preserve">
          <source>In modules that don't expose their own API, such as applications, you can opt in to using APIs without propagating the opt-in requirement to your code. In this case, mark your declaration with &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-opt-in/index&quot;&gt;@OptIn&lt;/a&gt; passing the opt-in requirement annotation as its argument:</source>
          <target state="translated">アプリケーションなど、独自のAPIを公開しないモジュールでは、オプトイン要件をコードに伝達せずにAPIの使用をオプトインできます。この場合、引数としてオプトイン要件アノテーションを渡す&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-opt-in/index&quot;&gt;@OptInで&lt;/a&gt;宣言をマークします。</target>
        </trans-unit>
        <trans-unit id="a772373d726c1ea1dd1e4b5bd74e75bb5171d98d" translate="yes" xml:space="preserve">
          <source>In modules that don't provide their own API, such as application modules, you can use experimental APIs without propagating the experimental status to your code. In this case, mark your code with the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-use-experimental/index&quot;&gt;@UseExperimental(Marker::class)&lt;/a&gt; annotation specifying the marker annotation of the experimental API:</source>
          <target state="translated">アプリケーションモジュールなど、独自のAPIを提供しないモジュールでは、試験的なステータスをコードに伝播せずに試験的なAPIを使用できます。この場合、実験的なAPIのマーカーアノテーションを指定する&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-use-experimental/index&quot;&gt;@UseExperimental（Marker :: class）&lt;/a&gt;アノテーションでコードをマークします。</target>
        </trans-unit>
        <trans-unit id="cfed7f25e3bb00e2797542765d6c2ca96af68b87" translate="yes" xml:space="preserve">
          <source>In most cases, Kotlin follows the Java coding conventions.</source>
          <target state="translated">ほとんどの場合、KotlinはJavaのコーディング規約に従っています。</target>
        </trans-unit>
        <trans-unit id="d126b0359662ea6c66b61b9e3af53b0d85339044" translate="yes" xml:space="preserve">
          <source>In multiline mode the expressions &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;$&lt;/code&gt; match just after or just before, respectively, a line terminator or the end of the input sequence.</source>
          <target state="translated">複数行モードでは、式 &lt;code&gt;^&lt;/code&gt; および &lt;code&gt;$&lt;/code&gt; は、それぞれ行末記号または入力シーケンスの終わりの直後または直前に一致します。</target>
        </trans-unit>
        <trans-unit id="6667a323602babcf47c04e12460b410e75814d22" translate="yes" xml:space="preserve">
          <source>In order to assemble an application, we also need to include the Kotlin standard library, i.e. &lt;code&gt;kotlin.js&lt;/code&gt;, which was included as a dependency, and the other libraries if any.</source>
          <target state="translated">アプリケーションをアセンブルするには、依存関係として含まれていたKotlin標準ライブラリ、つまり &lt;code&gt;kotlin.js&lt;/code&gt; と、存在する場合は他のライブラリも含める必要があります。</target>
        </trans-unit>
        <trans-unit id="034cc52464c28236e3f8c4183a0d3673ce621a3f" translate="yes" xml:space="preserve">
          <source>In order to avoid compatibility issues during an Xcode build, the plugin requires using a &lt;a href=&quot;https://docs.gradle.org/current/userguide/gradle_wrapper.html&quot;&gt;Gradle wrapper&lt;/a&gt;. To generate the wrapper automatically during execution of the &lt;code&gt;podspec&lt;/code&gt; task, run it with the parameter &lt;code&gt;-Pkotlin.native.cocoapods.generate.wrapper=true&lt;/code&gt;.</source>
          <target state="translated">Xcodeビルド中の互換性の問題を回避するために、プラグインは&lt;a href=&quot;https://docs.gradle.org/current/userguide/gradle_wrapper.html&quot;&gt;Gradleラッパー&lt;/a&gt;を使用する必要があります。 &lt;code&gt;podspec&lt;/code&gt; タスクの実行中にラッパーを自動的に生成するには、パラメーター &lt;code&gt;-Pkotlin.native.cocoapods.generate.wrapper=true&lt;/code&gt; を指定してラッパーを実行します。</target>
        </trans-unit>
        <trans-unit id="c80bd17bf7329417ed7785f5f956f7d5c5ca2880" translate="yes" xml:space="preserve">
          <source>In order to avoid confusion about artifact names, we&amp;rsquo;ve renamed &lt;code&gt;kotlin-scripting-jsr223-embeddable&lt;/code&gt; and &lt;code&gt;kotlin-scripting-jvm-host-embeddable&lt;/code&gt; to just &lt;code&gt;kotlin-scripting-jsr223&lt;/code&gt; and &lt;code&gt;kotlin-scripting-jvm-host&lt;/code&gt;. These artifacts depend on the &lt;code&gt;kotlin-compiler-embeddable&lt;/code&gt; artifact, which shades the bundled third-party libraries to avoid usage conflicts. With this renaming, we&amp;rsquo;re making the usage of &lt;code&gt;kotlin-compiler-embeddable&lt;/code&gt; (which is safer in general) the default for scripting artifacts. If, for some reason, you need artifacts that depend on the unshaded &lt;code&gt;kotlin-compiler&lt;/code&gt;, use the artifact versions with the &lt;code&gt;-unshaded&lt;/code&gt; suffix, such as &lt;code&gt;kotlin-scripting-jsr223-unshaded&lt;/code&gt;. Note that this renaming affects only the scripting artifacts that are supposed to be used directly; names of other artifacts remain unchanged.</source>
          <target state="translated">アーティファクト名について回避混乱するために、我々は、名前を変更しました &lt;code&gt;kotlin-scripting-jsr223-embeddable&lt;/code&gt; と &lt;code&gt;kotlin-scripting-jvm-host-embeddable&lt;/code&gt; ジャストに &lt;code&gt;kotlin-scripting-jsr223&lt;/code&gt; と &lt;code&gt;kotlin-scripting-jvm-host&lt;/code&gt; 。これらのアーティファクトは、 &lt;code&gt;kotlin-compiler-embeddable&lt;/code&gt; アーティファクトに依存しています。これは、バンドルされたサードパーティライブラリをシェーディングして、使用法の競合を回避します。この名前変更により、 &lt;code&gt;kotlin-compiler-embeddable&lt;/code&gt; （一般的に安全）の使用法がスクリプトアーティファクトのデフォルトになります。何らかの理由で、 &lt;code&gt;kotlin-compiler&lt;/code&gt; れていないkotlin-compilerに依存するアーティファクトが必要な場合は、 &lt;code&gt;-unshaded&lt;/code&gt; サフィックスが付いたアーティファクトバージョンを使用してください。 &lt;code&gt;kotlin-scripting-jsr223-unshaded&lt;/code&gt; 。この名前変更は、直接使用されることになっているスクリプトアーティファクトにのみ影響することに注意してください。他のアーティファクトの名前は変更されません。</target>
        </trans-unit>
        <trans-unit id="320ea67fc7a407c39652cf848b66d1bac7958814" translate="yes" xml:space="preserve">
          <source>In order to build a Kotlin project with Gradle, you should &lt;a href=&quot;#plugin-and-versions&quot;&gt;apply the Kotlin Gradle plugin to your project&lt;/a&gt; and &lt;a href=&quot;#configuring-dependencies&quot;&gt;configure dependencies&lt;/a&gt;.</source>
          <target state="translated">Gradleを使用してKotlinプロジェクトをビルド&lt;a href=&quot;#plugin-and-versions&quot;&gt;するには、Kotlin Gradleプラグインをプロジェクトに適用し、&lt;/a&gt;&lt;a href=&quot;#configuring-dependencies&quot;&gt;依存関係&lt;/a&gt;を構成する必要があります。</target>
        </trans-unit>
        <trans-unit id="4a047d1f6392366b3f681991fe461367b7be253f" translate="yes" xml:space="preserve">
          <source>In order to build a Kotlin project with Gradle, you should &lt;a href=&quot;#plugin-and-versions&quot;&gt;set up the &lt;em&gt;kotlin-gradle&lt;/em&gt; plugin&lt;/a&gt;, &lt;a href=&quot;#targeting-the-jvm&quot;&gt;apply it&lt;/a&gt; to your project and &lt;a href=&quot;#configuring-dependencies&quot;&gt;add &lt;em&gt;kotlin-stdlib&lt;/em&gt; dependencies&lt;/a&gt;. Those actions may also be performed automatically in IntelliJ IDEA by invoking &lt;strong&gt;Tools | Kotlin | Configure Kotlin&lt;/strong&gt; in &lt;strong&gt;Project&lt;/strong&gt; action.</source>
          <target state="translated">GradleのでKotlinのプロジェクトをビルドするためには、あなたがすべき&lt;a href=&quot;#plugin-and-versions&quot;&gt;設定&lt;em&gt;kotlin-のGradle&lt;/em&gt;プラグインを&lt;/a&gt;、&lt;a href=&quot;#targeting-the-jvm&quot;&gt;それを適用する&lt;/a&gt;プロジェクトにし、&lt;a href=&quot;#configuring-dependencies&quot;&gt;追加&lt;em&gt;kotlin-STDLIBの&lt;/em&gt;依存関係を&lt;/a&gt;。これらのアクションは、IntelliJ IDEAで&lt;strong&gt;Tools | コトリン| &lt;/strong&gt;&lt;strong&gt;プロジェクト&lt;/strong&gt;アクションで&lt;strong&gt;Kotlin&lt;/strong&gt;を&lt;strong&gt;構成し&lt;/strong&gt;ます。</target>
        </trans-unit>
        <trans-unit id="e347f51a9c40cc493b347c1bed8c2d5285726dad" translate="yes" xml:space="preserve">
          <source>In order to compile JavaScript code, you need to use the &lt;code&gt;js&lt;/code&gt; and &lt;code&gt;test-js&lt;/code&gt; goals for the &lt;code&gt;compile&lt;/code&gt; execution:</source>
          <target state="translated">JavaScriptコードをコンパイルするには、 &lt;code&gt;compile&lt;/code&gt; 実行に &lt;code&gt;js&lt;/code&gt; および &lt;code&gt;test-js&lt;/code&gt; ゴールを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="7888ab5509b34a7615518c3269c358c32f2dd548" translate="yes" xml:space="preserve">
          <source>In order to debug the application using IntelliJ IDEA, we need to perform two steps:</source>
          <target state="translated">IntelliJ IDEAを使ってアプリケーションをデバッグするためには、2つのステップを実行する必要があります。</target>
        </trans-unit>
        <trans-unit id="0d60abc6454bf0506cb62dd1ac746f025ab62610" translate="yes" xml:space="preserve">
          <source>In order to generate these bindings, we need to create a library definition &lt;code&gt;.def&lt;/code&gt; file that contains some information about the headers we need to generate. In our case we want to use the famous &lt;code&gt;libcurl&lt;/code&gt; library to make some HTTP calls, so we'll create a file named &lt;code&gt;libcurl.def&lt;/code&gt; with the following contents</source>
          <target state="translated">これらのバインディングを生成するには、生成する必要があるヘッダーに関する情報を含むライブラリ定義 &lt;code&gt;.def&lt;/code&gt; ファイルを作成する必要があります。この例では、有名な &lt;code&gt;libcurl&lt;/code&gt; ライブラリを使用してHTTP呼び出しを行いたいので、次の内容で &lt;code&gt;libcurl.def&lt;/code&gt; という名前のファイルを作成します。</target>
        </trans-unit>
        <trans-unit id="ffbf97f9cc48e7603dadd7a45b25bf4f6b7e3989" translate="yes" xml:space="preserve">
          <source>In order to run, we need the corresponding WAR(s) for deploying. We can generate these using the &lt;em&gt;war&lt;/em&gt; task in Gradle which can easily be executed via the Gradle tool window in IntelliJ IDEA.</source>
          <target state="translated">実行するには、デプロイするための対応するWARが必要です。これらはGradleで&lt;em&gt;war&lt;/em&gt;タスクを使用して生成できます。これはIntelliJ IDEAのGradleツールウィンドウから簡単に実行できます。</target>
        </trans-unit>
        <trans-unit id="24dcbfd34df21e70b79c4b2191a485e90cc3e450" translate="yes" xml:space="preserve">
          <source>In order to share the changes across the project developers &lt;code&gt;.idea/codeStyle&lt;/code&gt; folder, it has to be committed to VCS. Alternatively &lt;strong&gt;kotlin.code.style&lt;/strong&gt;=&lt;strong&gt;obsolete&lt;/strong&gt; can be used for projects configured with Gradle or Maven.</source>
          <target state="translated">プロジェクト開発者の &lt;code&gt;.idea/codeStyle&lt;/code&gt; フォルダー間で変更を共有するには、VCSにコミットする必要があります。あるいは、&lt;strong&gt;kotlin.code.style&lt;/strong&gt; = &lt;strong&gt;obsolete&lt;/strong&gt;は、GradleまたはMavenで構成されたプロジェクトに使用できます。</target>
        </trans-unit>
        <trans-unit id="155fb0f00f3221a063feea137fb0401c04ce9dd5" translate="yes" xml:space="preserve">
          <source>In order to share those changes for all project developers &lt;code&gt;.idea/codeStyle&lt;/code&gt; folder have to be committed to VCS.</source>
          <target state="translated">すべてのプロジェクト開発者がこれらの変更を共有するには、 &lt;code&gt;.idea/codeStyle&lt;/code&gt; フォルダーをVCSにコミットする必要があります。</target>
        </trans-unit>
        <trans-unit id="fa88cf692336fd455afd07788cc5c7d6ab06d938" translate="yes" xml:space="preserve">
          <source>In order to specify the module kind, we can add a configuration to our plugin as below</source>
          <target state="translated">モジュールの種類を指定するには、以下のようにプラグインに設定を追加します。</target>
        </trans-unit>
        <trans-unit id="59607fe0baf1ba77b3f9ca8983f516dc1d471c45" translate="yes" xml:space="preserve">
          <source>In order to support a potentially nullable type, the Objc header needs to define &lt;code&gt;myVal&lt;/code&gt; with a nullable return value.</source>
          <target state="translated">null可能性のある型をサポートするために、Objcヘッダーはnull可能の戻り値で &lt;code&gt;myVal&lt;/code&gt; を定義する必要があります。</target>
        </trans-unit>
        <trans-unit id="de88f4d0de61705bae1956451c94335904114bb9" translate="yes" xml:space="preserve">
          <source>In order to support a potentially nullable type, the Objective-C header needs to define &lt;code&gt;myVal&lt;/code&gt; with a nullable return value.</source>
          <target state="translated">潜在的にnull許容型をサポートするには、Objective-Cヘッダーで &lt;code&gt;myVal&lt;/code&gt; をnull許容戻り値で定義する必要があります。</target>
        </trans-unit>
        <trans-unit id="9aac89688353374371a7ae0f65a4346b1a58df3a" translate="yes" xml:space="preserve">
          <source>In order to use Gradle to target JavaScript, we need to use the &lt;code&gt;kotlin2js&lt;/code&gt; plugin as opposed to the &lt;code&gt;kotlin&lt;/code&gt; plugin.</source>
          <target state="translated">JavaScriptをターゲットにするのGradleを使用するために、我々は、使用する必要が &lt;code&gt;kotlin2js&lt;/code&gt; とは対照的に、プラグインを &lt;code&gt;kotlin&lt;/code&gt; プラグイン。</target>
        </trans-unit>
        <trans-unit id="33526a8ed38f3fde7c6b4f6af71779367c169bbc" translate="yes" xml:space="preserve">
          <source>In order to use Kotlin with node.js, we need to set the compiler option to use CommonJS. Once we do that, the output of the application should be accessible using the node module system.</source>
          <target state="translated">Kotlinをnode.jsで使うためには、コンパイラのオプションでCommonJSを使うように設定する必要があります。そうすれば、アプリケーションの出力はnodeモジュールシステムを使ってアクセスできるようになるはずです。</target>
        </trans-unit>
        <trans-unit id="5bdfd7a958cb3b5e6a62acec15106d2a72aa846c" translate="yes" xml:space="preserve">
          <source>In order to use coroutines as well as follow the examples in this guide, you need to add a dependency on &lt;code&gt;kotlinx-coroutines-core&lt;/code&gt; module as explained &lt;a href=&quot;https://github.com/kotlin/kotlinx.coroutines/blob/master/README.md#using-in-your-projects&quot;&gt;in the project README&lt;/a&gt;.</source>
          <target state="translated">このガイドの例に加えてコルーチンを使用するに&lt;a href=&quot;https://github.com/kotlin/kotlinx.coroutines/blob/master/README.md#using-in-your-projects&quot;&gt;は、プロジェクトのREADMEで&lt;/a&gt;説明されているように、 &lt;code&gt;kotlinx-coroutines-core&lt;/code&gt; モジュールへの依存関係を追加する必要があります。</target>
        </trans-unit>
        <trans-unit id="cc71e5241592939229f3aa2e6f5ed18f17024e17" translate="yes" xml:space="preserve">
          <source>In order to use coroutines as well as follow the examples in this guide, you need to add a dependency on the &lt;code&gt;kotlinx-coroutines-core&lt;/code&gt; module as explained &lt;a href=&quot;https://github.com/kotlin/kotlinx.coroutines/blob/master/README.md#using-in-your-projects&quot;&gt;in the project README&lt;/a&gt;.</source>
          <target state="translated">コルーチンを使用し、このガイドの例に従うには&lt;a href=&quot;https://github.com/kotlin/kotlinx.coroutines/blob/master/README.md#using-in-your-projects&quot;&gt;、プロジェクトREADMEで&lt;/a&gt;説明されているように、 &lt;code&gt;kotlinx-coroutines-core&lt;/code&gt; モジュールへの依存関係を追加する必要があります。</target>
        </trans-unit>
        <trans-unit id="1cc60ead46c9defc457295413372bae706d2254f" translate="yes" xml:space="preserve">
          <source>In order to use something from a package, it is sufficient to use the package name to fully qualify the name of the symbol at the place where you use the symbol:</source>
          <target state="translated">パッケージから何かを使用するためには、そのシンボルを使用する場所のシンボルの名前を完全に修飾するためにパッケージ名を使用すれば十分です。</target>
        </trans-unit>
        <trans-unit id="9abc8ef7836ac20fac6436adb16fe6c5da1f6518" translate="yes" xml:space="preserve">
          <source>In order to use this, we also need to include the Kotlin standard library in our application, i.e. &lt;code&gt;kotlin.js&lt;/code&gt;, which was included as a dependency. By default, Maven does not expand the JAR as part of the build process, so we would need to add an additional step in our build to do so.</source>
          <target state="translated">これを使用するには、アプリケーションにKotlin標準ライブラリ、つまり依存関係として含まれていた &lt;code&gt;kotlin.js&lt;/code&gt; も含める必要があります。デフォルトでは、Mavenはビルドプロセスの一部としてJARを拡張しないため、ビルドに追加のステップを追加する必要があります。</target>
        </trans-unit>
        <trans-unit id="a5c6ba86278357c55cc58dbde4e4e54ec8ffad3f" translate="yes" xml:space="preserve">
          <source>In other words, inline classes introduce a truly &lt;em&gt;new&lt;/em&gt; type, contrary to type aliases which only introduce an alternative name (alias) for an existing type:</source>
          <target state="translated">言い換えると、インラインクラスは、既存のタイプの代替名（エイリアス）のみを導入するタイプエイリアスとは対照的に、真に&lt;em&gt;新しい&lt;/em&gt;タイプを導入します。</target>
        </trans-unit>
        <trans-unit id="2fcd261cf566bdf17c9a0226c120616065441d92" translate="yes" xml:space="preserve">
          <source>In our DSL all the tag classes extend the same superclass &lt;code&gt;Tag&lt;/code&gt;. It's enough to annotate only the superclass with &lt;code&gt;@HtmlTagMarker&lt;/code&gt; and after that the Kotlin compiler will treat all the inherited classes as annotated:</source>
          <target state="translated">DSLでは、すべてのタグクラスが同じスーパークラス &lt;code&gt;Tag&lt;/code&gt; 拡張しています。 &lt;code&gt;@HtmlTagMarker&lt;/code&gt; でスーパークラスのみに注釈を付けるだけで十分です。その後、Kotlinコンパイラは継承されたすべてのクラスを注釈付きとして扱います。</target>
        </trans-unit>
        <trans-unit id="055ba8d22e98a479f59a07d7a075048bb0a20fe4" translate="yes" xml:space="preserve">
          <source>In our example, we have &lt;code&gt;main&lt;/code&gt; function that is turned into a coroutine using &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt; coroutine builder. Every coroutine builder, including &lt;code&gt;runBlocking&lt;/code&gt;, adds an instance of &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;CoroutineScope&lt;/a&gt; to the scope of its code block. We can launch coroutines in this scope without having to &lt;code&gt;join&lt;/code&gt; them explicitly, because an outer coroutine (&lt;code&gt;runBlocking&lt;/code&gt; in our example) does not complete until all the coroutines launched in its scope complete. Thus, we can make our example simpler:</source>
          <target state="translated">この例では、&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt;コルーチンビルダーを使用してコルーチンに変換される &lt;code&gt;main&lt;/code&gt; 関数があります。 &lt;code&gt;runBlocking&lt;/code&gt; を含むすべてのコルーチンビルダーは、コードブロックのスコープに&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;CoroutineScopeの&lt;/a&gt;インスタンスを追加します。外側のコルーチン（この例では &lt;code&gt;runBlocking&lt;/code&gt; ）は、そのスコープで起動されたすべてのコルーチンが完了するまで完了しないため、明示的に &lt;code&gt;join&lt;/code&gt; 必要なく、このスコープでコルーチンを起動できます。したがって、例をより単純にすることができます。</target>
        </trans-unit>
        <trans-unit id="a2b76b0743b9831752920932ff5a5625568afac3" translate="yes" xml:space="preserve">
          <source>In our example, we have a &lt;code&gt;main&lt;/code&gt; function that is turned into a coroutine using the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt; coroutine builder. Every coroutine builder, including &lt;code&gt;runBlocking&lt;/code&gt;, adds an instance of &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html&quot;&gt;CoroutineScope&lt;/a&gt; to the scope of its code block. We can launch coroutines in this scope without having to &lt;code&gt;join&lt;/code&gt; them explicitly, because an outer coroutine (&lt;code&gt;runBlocking&lt;/code&gt; in our example) does not complete until all the coroutines launched in its scope complete. Thus, we can make our example simpler:</source>
          <target state="translated">この例では、&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt;コルーチンビルダーを使用してコルーチンに変換される &lt;code&gt;main&lt;/code&gt; 関数があります。 &lt;code&gt;runBlocking&lt;/code&gt; を含むすべてのコルーチンビルダーは、&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html&quot;&gt;CoroutineScopeの&lt;/a&gt;インスタンスをそのコードブロックのスコープに追加します。スコープ内で起動されたすべてのコルーチンが完了するまで外部コルーチン（この例では &lt;code&gt;runBlocking&lt;/code&gt; ）が完了しないため、明示的に &lt;code&gt;join&lt;/code&gt; しなくても、このスコープ内でコルーチンを起動できます。したがって、例をより単純にすることができます。</target>
        </trans-unit>
        <trans-unit id="99c50d394fc235f8eeca8f1ea6662b1ec125d6bd" translate="yes" xml:space="preserve">
          <source>In our main function we create activity, call our test &lt;code&gt;doSomething&lt;/code&gt; function, and destroy activity after 500ms. This cancels all the coroutines that were launched which we can confirm by noting that it does not print onto the screen anymore if we wait:</source>
          <target state="translated">メイン関数でアクティビティを作成し、テストの &lt;code&gt;doSomething&lt;/code&gt; 関数を呼び出し、500ミリ秒後にアクティビティを破棄します。これにより、起動されたすべてのコルーチンがキャンセルされます。これを待つと、画面に印刷されなくなることに注意して確認できます。</target>
        </trans-unit>
        <trans-unit id="8567ecf52dbb46832894d62cc3534eccec93e924" translate="yes" xml:space="preserve">
          <source>In our main function we create the activity, call our test &lt;code&gt;doSomething&lt;/code&gt; function, and destroy the activity after 500ms. This cancels all the coroutines that were launched from &lt;code&gt;doSomething&lt;/code&gt;. We can see that because after the destruction of the activity no more messages are printed, even if we wait a little longer.</source>
          <target state="translated">メイン関数では、アクティビティを作成し、テスト &lt;code&gt;doSomething&lt;/code&gt; 関数を呼び出し、500ミリ秒後にアクティビティを破棄します。これにより、 &lt;code&gt;doSomething&lt;/code&gt; から起動されたすべてのコルーチンがキャンセルされます。アクティビティが破棄された後、もう少し待ってもメッセージが出力されないことがわかります。</target>
        </trans-unit>
        <trans-unit id="4e33cfe3a798666f120dafc2300d3a53a316781b" translate="yes" xml:space="preserve">
          <source>In particular, when defining extension functions for a class which are relevant for all clients of this class, put them in the same file where the class itself is defined. When defining extension functions that make sense only for a specific client, put them next to the code of that client. Do not create files just to hold &quot;all extensions of Foo&quot;.</source>
          <target state="translated">特に、あるクラスの拡張関数で、そのクラスのすべてのクライアントに関連するものを定義する場合は、そのクラス自体が定義されているのと同じファイルに記述してください。特定のクライアントにのみ意味のある拡張関数を定義する場合は、そのクライアントのコードの隣に置くようにしてください。Fooのすべての拡張子」を保持するためだけにファイルを作成しないでください。</target>
        </trans-unit>
        <trans-unit id="2683ff56288a092d85a9176c5ad7bb38fce09a9b" translate="yes" xml:space="preserve">
          <source>In practice some changes can't be accurately detected at compile time, so no warnings can be reported, but at least the users will be notified through Release notes of version A that a change is coming in version B.</source>
          <target state="translated">実際には、コンパイル時に正確に検出できない変更もあるので、警告を報告することはできませんが、少なくともユーザにはバージョンAのリリースノートを通して、バージョンBに変更があることが通知されます。</target>
        </trans-unit>
        <trans-unit id="1e5d38479fe45d55c10d169d2b3903a772bc6139" translate="yes" xml:space="preserve">
          <source>In practice, quite a bit of code is affected, so this can be considered a major code style update.</source>
          <target state="translated">実際には、かなりのコードが影響を受けているので、これはコードスタイルのメジャーな更新と考えることができます。</target>
        </trans-unit>
        <trans-unit id="57e5b70de31acdb27d8d2c67fea04b3d16fdd8a7" translate="yes" xml:space="preserve">
          <source>In practice, thread confinement is performed in large chunks, e.g. big pieces of state-updating business logic are confined to the single thread. The following example does it like that, running each coroutine in the single-threaded context to start with.</source>
          <target state="translated">実際には、大きな塊でスレッドを閉じ込めることが行われます。例えば、状態を更新するビジネスロジックの大きな部分はシングルスレッドに閉じ込められます。以下の例では、各コルーチンをシングルスレッドのコンテキストで実行しています。</target>
        </trans-unit>
        <trans-unit id="40969ff7e4fed85e58f626291a67f5273e20a573" translate="yes" xml:space="preserve">
          <source>In progressive mode, some fixes in language semantics can arrive immediately. All these fixes have two important properties:</source>
          <target state="translated">プログレッシブモードでは、言語セマンティクスのいくつかの修正がすぐに到着することがあります。これらの修正はすべて、2つの重要な性質を持っています。</target>
        </trans-unit>
        <trans-unit id="fe450a289b0de3b7d5e96c5607691481e36cec05" translate="yes" xml:space="preserve">
          <source>In projects created from IntelliJ IDEA or AppCode templates these &lt;code&gt;.dSYM&lt;/code&gt; bundles are then discovered by Xcode automatically.</source>
          <target state="translated">IntelliJ IDEAまたはAppCodeテンプレートから作成されたプロジェクトでは、これらの &lt;code&gt;.dSYM&lt;/code&gt; バンドルはXcodeによって自動的に検出されます。</target>
        </trans-unit>
        <trans-unit id="eff40107a95c01dec77eae6fb0ec0b96a075ea6f" translate="yes" xml:space="preserve">
          <source>In pure Kotlin projects, the recommended directory structure follows the package structure with the common root package omitted. For example, if all the code in the project is in the &lt;code&gt;org.example.kotlin&lt;/code&gt; package and its subpackages, files with the &lt;code&gt;org.example.kotlin&lt;/code&gt; package should be placed directly under the source root, and files in &lt;code&gt;org.example.kotlin.network.socket&lt;/code&gt; should be in the &lt;code&gt;network/socket&lt;/code&gt; subdirectory of the source root.</source>
          <target state="translated">純粋なKotlinプロジェクトでは、推奨されるディレクトリ構造は、共通のルートパッケージが省略されたパッケージ構造に従います。たとえば、プロジェクト内のすべてのコードが &lt;code&gt;org.example.kotlin&lt;/code&gt; パッケージとそのサブパッケージにある場合、 &lt;code&gt;org.example.kotlin&lt;/code&gt; パッケージのファイルはソースルートの直下に配置し、ファイルはorg.example.kotlinに配置する必要があります &lt;code&gt;org.example.kotlin.network.socket&lt;/code&gt; は、ソースルートの &lt;code&gt;network/socket&lt;/code&gt; サブディレクトリにある必要があります。</target>
        </trans-unit>
        <trans-unit id="d10877f2d49f4fb7859f1ddc63051feb0cebe60b" translate="yes" xml:space="preserve">
          <source>In pure Kotlin projects, the recommended directory structure is to follow the package structure with the common root package omitted (e.g. if all the code in the project is in the &quot;org.example.kotlin&quot; package and its subpackages, files with the &quot;org.example.kotlin&quot; package should be placed directly under the source root, and files in &quot;org.example.kotlin.foo.bar&quot; should be in the &quot;foo/bar&quot; subdirectory of the source root).</source>
          <target state="translated">純粋なKotlinプロジェクトでは、共通のルートパッケージを省略したパッケージ構造に従うことが推奨されます (例えば、プロジェクト内のすべてのコードが &quot;org.example.kotlin &quot;パッケージとそのサブパッケージに含まれている場合、&quot;org.example.kotlin &quot;パッケージのファイルはソースルートの直下に、&quot;org.example.kotlin.foo.bar &quot;のファイルはソースルートの &quot;foo/bar &quot;サブディレクトリに置くべきです)。</target>
        </trans-unit>
        <trans-unit id="c30c378469f41e6f1d1072007ebada7e490b3451" translate="yes" xml:space="preserve">
          <source>In scratches and worksheets, you can write any valid Kotlin code. Syntax highlighting, auto-completion, and the other IntelliJ IDEA code editing features are all supported too. Note that there's no need for declaring the &lt;code&gt;main&lt;/code&gt; function: all the code you write is executed as if it would be in the body of &lt;code&gt;main&lt;/code&gt;.</source>
          <target state="translated">スクラッチとワークシートには、有効なKotlinコードを記述できます。構文の強調表示、オートコンプリート、およびその他のIntelliJIDEAコード編集機能もすべてサポートされています。 &lt;code&gt;main&lt;/code&gt; 関数を宣言する必要はないことに注意してください。作成するすべてのコードは、 &lt;code&gt;main&lt;/code&gt; の本体にあるかのように実行されます。</target>
        </trans-unit>
        <trans-unit id="7a5be9888b7ba5a318d3261861baf4d32fa8861a" translate="yes" xml:space="preserve">
          <source>In short: &lt;em&gt;think carefully through your declarations of integers, and be absolutely certain that the value will never ever need to be larger than the limits of the type!&lt;/em&gt; If you need an integer of unlimited size, use the non-primitive type &lt;code&gt;BigInteger&lt;/code&gt;.</source>
          <target state="translated">つまり&lt;em&gt;、整数の宣言を注意深く検討し、値が型の制限よりも大きくなる必要がないことを絶対に確認してください。&lt;/em&gt;サイズが無制限の整数が必要な場合は、非プリミティブ型 &lt;code&gt;BigInteger&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="4a3b75ce2c9b15401d05148e77e0306873596e7e" translate="yes" xml:space="preserve">
          <source>In situations like this we can use the &lt;code&gt;dynamic&lt;/code&gt; type, which allows us to work with dynamic types when targeting JavaScript. The following variable is declared as &lt;code&gt;dynamic&lt;/code&gt; meaning that whatever we invoke on it will not result in a compile-time error:</source>
          <target state="translated">このような状況では、 &lt;code&gt;dynamic&lt;/code&gt; タイプを使用できます。これにより、JavaScriptをターゲットにするときに動的タイプを操作できます。次の変数は &lt;code&gt;dynamic&lt;/code&gt; として宣言されています。これは、その変数を呼び出してもコンパイル時エラーが発生しないことを意味します。</target>
        </trans-unit>
        <trans-unit id="55bd36b85c22e6a1c4d10234a638ea714c3940ad" translate="yes" xml:space="preserve">
          <source>In some cases (for example, to support overloads), Kotlin compiler mangles names of generated functions and attributes in JavaScript code. To control the generated names, you can use the &lt;code&gt;@JsName&lt;/code&gt; annotation:</source>
          <target state="translated">場合によっては（たとえば、オーバーロードをサポートするために）、KotlinコンパイラーはJavaScriptコードで生成された関数と属性の名前をマングルします。生成された名前を制御するには、 &lt;code&gt;@JsName&lt;/code&gt; アノテーションを使用できます。</target>
        </trans-unit>
        <trans-unit id="f1f62f22b0a379feb738d1ada9b061745859834e" translate="yes" xml:space="preserve">
          <source>In some cases (for example, to support overloads), the Kotlin compiler mangles the names of generated functions and attributes in JavaScript code. To control the generated names, you can use the &lt;code&gt;@JsName&lt;/code&gt; annotation:</source>
          <target state="translated">場合によっては（たとえば、オーバーロードをサポートするために）、KotlinコンパイラーはJavaScriptコードで生成された関数と属性の名前をマングルします。生成される名前を制御するには、 &lt;code&gt;@JsName&lt;/code&gt; アノテーションを使用できます。</target>
        </trans-unit>
        <trans-unit id="8f1f57175de66b286d8ac98729c81851940d41f3" translate="yes" xml:space="preserve">
          <source>In some cases functions with no arguments might be interchangeable with read-only properties. Although the semantics are similar, there are some stylistic conventions on when to prefer one to another.</source>
          <target state="translated">場合によっては、引数を持たない関数が読み取り専用のプロパティと互換性があるかもしれません。セマンティクスは似ていますが、いつ別のものを好むかについては、いくつかの文体上の決まりがあります。</target>
        </trans-unit>
        <trans-unit id="4526b2f446cfa690eb7c5baadbe7c8dea021438f" translate="yes" xml:space="preserve">
          <source>In some ways, this is easier to read because the operations are specified in the order they are applied to the values. The result will be an immutable &lt;code&gt;List&amp;lt;T&amp;gt;&lt;/code&gt;, where &lt;code&gt;T&lt;/code&gt; is whichever type is produced by the transformations you use (in this case, &lt;code&gt;String&lt;/code&gt;). If you need a mutable list, call &lt;code&gt;toMutableList()&lt;/code&gt; at the end. If you want a set, call &lt;code&gt;toSet()&lt;/code&gt; or &lt;code&gt;toMutableSet()&lt;/code&gt; at the end. If you want to transform a collection into a map, call &lt;code&gt;associateBy()&lt;/code&gt;, which takes two lambdas that specify how to extract the key and the value from each element: &lt;code&gt;people.associateBy({it.ssn}, {it.name})&lt;/code&gt; (you can omit the second lambda if you want the entire element to be the value, and you can call &lt;code&gt;toMutableMap()&lt;/code&gt; at the end if you want the result to be mutable).</source>
          <target state="translated">いくつかの点で、操作は値に適用される順序で指定されるため、これは読みやすくなります。結果は不変の &lt;code&gt;List&amp;lt;T&amp;gt;&lt;/code&gt; になります &lt;code&gt;T&lt;/code&gt; は、使用する変換（この場合は &lt;code&gt;String&lt;/code&gt; ）によって生成されるタイプです。変更可能なリストが必要な場合は、最後に &lt;code&gt;toMutableList()&lt;/code&gt; を呼び出します。セットが必要な場合は、最後に &lt;code&gt;toSet()&lt;/code&gt; または &lt;code&gt;toMutableSet()&lt;/code&gt; を呼び出します。コレクションをマップに変換する場合は、 &lt;code&gt;associateBy()&lt;/code&gt; 呼び出します。これは、各要素からキーと値を抽出する方法を指定する2つのラムダを取得します &lt;code&gt;people.associateBy({it.ssn}, {it.name})&lt;/code&gt; （要素全体を値にする場合は、2番目のラムダを省略できます。結果を変更可能にする場合は、最後に &lt;code&gt;toMutableMap()&lt;/code&gt; を呼び出します）。</target>
        </trans-unit>
        <trans-unit id="482c7a83b939d337af8bf0cb41a70749c1cb67ed" translate="yes" xml:space="preserve">
          <source>In spite of the &lt;code&gt;object&lt;/code&gt; keyword being used, a new instance of the anonymous class will be created whenever the object expression is evaluated.</source>
          <target state="translated">&lt;code&gt;object&lt;/code&gt; キーワードが使用されているにもかかわらず、オブジェクト式が評価されるたびに、匿名クラスの新しいインスタンスが作成されます。</target>
        </trans-unit>
        <trans-unit id="10fed13cfcbccf5e09d7648e3ceabcf9a0d8e2f5" translate="yes" xml:space="preserve">
          <source>In spite of this syntactical convenience, the companion object is a proper object on its own, and can have its own supertypes - and you can assign it to a variable and pass it around. If you're integrating with Java code and need a true &lt;code&gt;static&lt;/code&gt; member, you can &lt;a href=&quot;annotations&quot;&gt;annotate&lt;/a&gt; a member inside a companion object with &lt;code&gt;@JvmStatic&lt;/code&gt;.</source>
          <target state="translated">この構文上の便利さにもかかわらず、コンパニオンオブジェクトはそれ自体が適切なオブジェクトであり、独自のスーパータイプを持つことができます。また、それを変数に割り当てて渡すことができます。Javaコードと統合していて、真の &lt;code&gt;static&lt;/code&gt; メンバーが必要な場合は、コンパニオンオブジェクト内のメンバーに &lt;code&gt;@JvmStatic&lt;/code&gt; で&lt;a href=&quot;annotations&quot;&gt;注釈を付ける&lt;/a&gt;ことができます。</target>
        </trans-unit>
        <trans-unit id="8be34c3c318a79f1a61390cd86ad3bb03f42aee7" translate="yes" xml:space="preserve">
          <source>In subsequent tutorials we'll show how you can influence the files generated, for example, change location, prefix and suffixes, and how you can work with modules.</source>
          <target state="translated">以降のチュートリアルでは、生成されたファイルにどのように影響を与えることができるのか、例えば場所の変更、接頭辞や接尾辞の変更、モジュールの操作方法などを説明します。</target>
        </trans-unit>
        <trans-unit id="bc19aea0692b9f67e799748ba127b1fc2dfa9708" translate="yes" xml:space="preserve">
          <source>In tests (and &lt;strong&gt;only&lt;/strong&gt; in tests), it's acceptable to use method names with spaces enclosed in backticks. (Note that such method names are currently not supported by the Android runtime.) Underscores in method names are also allowed in test code.</source>
          <target state="translated">テスト（およびテスト&lt;strong&gt;のみ&lt;/strong&gt;）では、スペースをバッククォートで囲んだメソッド名を使用できます。（このようなメソッド名は現在、Androidランタイムではサポートされていないことに注意してください。）メソッド名のアンダースコアは、テストコードでも許可されています。</target>
        </trans-unit>
        <trans-unit id="de0700bb726b0915ca84006a652a9bb020053b41" translate="yes" xml:space="preserve">
          <source>In tests (and only in tests), it's acceptable to use method names with spaces enclosed in backticks. (Note that such method names are currently not supported by the Android runtime.) Underscores in method names are also allowed in test code.</source>
          <target state="translated">テストでは(テストでのみ)、バックトークで囲まれたスペース付きのメソッド名を使用しても構いません。(このようなメソッド名は現在のところ Android ランタイムではサポートされていないことに注意してください)。メソッド名のアンダースコアはテストコードでも使用可能です。</target>
        </trans-unit>
        <trans-unit id="e4ad3e9e93913c50444eb70a3c6d491b3cf74240" translate="yes" xml:space="preserve">
          <source>In that case you need to use the spread operator &lt;code&gt;*&lt;/code&gt; to pass the &lt;code&gt;IntArray&lt;/code&gt;:</source>
          <target state="translated">その場合は、スプレッド演算子 &lt;code&gt;*&lt;/code&gt; を使用して &lt;code&gt;IntArray&lt;/code&gt; を渡す必要があります。</target>
        </trans-unit>
        <trans-unit id="a1e90ae09efa8b0693d6eb0e54489eb2ffa5613b" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;#debugging-coroutines-and-threads&quot;&gt;debug mode&lt;/a&gt;, it outputs something like this:</source>
          <target state="translated">で&lt;a href=&quot;#debugging-coroutines-and-threads&quot;&gt;、デバッグモードで&lt;/a&gt;は、このようなものを出力します。</target>
        </trans-unit>
        <trans-unit id="dfa4bedab09a124fc51fd33f0b20a721f3509f7a" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;#enabling-experimental-features&quot;&gt;experimental mode&lt;/a&gt;, you can specify any variant name (not only flavor), e.g. &lt;code&gt;freeDebug&lt;/code&gt; or &lt;code&gt;freeRelease&lt;/code&gt; will work as well.</source>
          <target state="translated">では&lt;a href=&quot;#enabling-experimental-features&quot;&gt;、実験モードで&lt;/a&gt;使用すると、任意のバリアント名（味だけではなく）を指定することができ、例えば、 &lt;code&gt;freeDebug&lt;/code&gt; または &lt;code&gt;freeRelease&lt;/code&gt; は同様に動作します。</target>
        </trans-unit>
        <trans-unit id="34502d3bacebdc9ab51090cbc1ee8b5aa02dcb57" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;libnative_api.h&lt;/code&gt;, we'll find the following code. We will discuss the code in parts to make it easier to understand.</source>
          <target state="translated">で &lt;code&gt;libnative_api.h&lt;/code&gt; 、我々は次のコードを見つけることができます。わかりやすくするために、コードを部分的に説明します。</target>
        </trans-unit>
        <trans-unit id="6da10c50e0a522e1434416a4209979f6b0add877" translate="yes" xml:space="preserve">
          <source>In the &lt;strong&gt;Coroutines&lt;/strong&gt; tab, you can see that there are two coroutines running concurrently. The flow collector and emitter run in separate coroutines because of the &lt;code&gt;buffer()&lt;/code&gt; function. The &lt;code&gt;buffer()&lt;/code&gt; function buffers emitted values from the flow. The emitter coroutine has the &lt;strong&gt;RUNNING&lt;/strong&gt; status, and the collector coroutine has the &lt;strong&gt;SUSPENDED&lt;/strong&gt; status.</source>
          <target state="translated">で&lt;strong&gt;コルーチン&lt;/strong&gt;タブで、あなたは、同時に実行している2つのコルーチンがあることがわかります。 &lt;code&gt;buffer()&lt;/code&gt; 関数により、フローコレクターとエミッターは別々のコルーチンで実行されます。 &lt;code&gt;buffer()&lt;/code&gt; 関数バッファは、フローからの値を放出されました。エミッターコルーチンは&lt;strong&gt;RUNNING&lt;/strong&gt;ステータスであり、コレクターコルーチンは&lt;strong&gt;SUSPENDED&lt;/strong&gt;ステータスです。</target>
        </trans-unit>
        <trans-unit id="97cbe1bbd40fde30fcff61322aab402c1acd97ce" translate="yes" xml:space="preserve">
          <source>In the Gradle dependencies you use add the &lt;code&gt;kotlin-kapt&lt;/code&gt; plugin and replace &lt;code&gt;annotationProcessor&lt;/code&gt; with &lt;code&gt;kapt&lt;/code&gt;:</source>
          <target state="translated">Gradleの依存関係では、 &lt;code&gt;kotlin-kapt&lt;/code&gt; プラグインを追加し、 &lt;code&gt;annotationProcessor&lt;/code&gt; を &lt;code&gt;kapt&lt;/code&gt; に置き換えます。</target>
        </trans-unit>
        <trans-unit id="a87144873c9b9ee0a65c1c2fda83f3948fb32756" translate="yes" xml:space="preserve">
          <source>In the JavaScript world, a completely different set of APIs is availiable, so one could instead implement logging to the console:</source>
          <target state="translated">JavaScript の世界では、全く異なる API のセットが利用可能なので、代わりにコンソールへのロギングを実装することができます。</target>
        </trans-unit>
        <trans-unit id="028c1035d4940563c6ebb4f5acb53d3747a67767" translate="yes" xml:space="preserve">
          <source>In the JavaScript world, the most common way to manage dependencies is &lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm&lt;/a&gt;. It offers the biggest public repository of JavaScript modules.</source>
          <target state="translated">JavaScriptの世界では、依存関係を管理する最も一般的な方法は&lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm&lt;/a&gt;です。JavaScriptモジュールの最大のパブリックリポジトリを提供します。</target>
        </trans-unit>
        <trans-unit id="cc47ebd8b09857b2d92aa6e80c268cb28a620e3a" translate="yes" xml:space="preserve">
          <source>In the Kotlin Gradle DSL, there is also a shortcut for setting the CommonJS module kind:</source>
          <target state="translated">Kotlin Gradle DSLでは、CommonJSモジュールの種類を設定するショートカットもあります。</target>
        </trans-unit>
        <trans-unit id="f4819cf70d4fd8479a3ad5972f4f49ad73e7b787" translate="yes" xml:space="preserve">
          <source>In the build script of an existing project.</source>
          <target state="translated">既存のプロジェクトのビルドスクリプトで</target>
        </trans-unit>
        <trans-unit id="f33ac82cc0a362095e9dc9d1c2c9f6a2f067dea1" translate="yes" xml:space="preserve">
          <source>In the case where you have a busy loop with coroutines you must explicitly check for cancellation. You can add &lt;code&gt;.onEach { currentCoroutineContext().ensureActive() }&lt;/code&gt;, but there is a ready-to-use &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/cancellable.html&quot;&gt;cancellable&lt;/a&gt; operator provided to do that:</source>
          <target state="translated">コルーチンでビジーループがある場合は、キャンセルを明示的に確認する必要があります。 &lt;code&gt;.onEach { currentCoroutineContext().ensureActive() }&lt;/code&gt; を追加できますが、それを行うためにすぐに使用できる&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/cancellable.html&quot;&gt;キャンセル可能な&lt;/a&gt;演算子が用意されています。</target>
        </trans-unit>
        <trans-unit id="952c75185ceff6a4ea2264e236a32b30e1121e70" translate="yes" xml:space="preserve">
          <source>In the code above, the parameter &lt;code&gt;combine&lt;/code&gt; has a &lt;a href=&quot;#function-types&quot;&gt;function type&lt;/a&gt;&lt;code&gt;(R, T) -&amp;gt; R&lt;/code&gt;, so it accepts a function that takes two arguments of types &lt;code&gt;R&lt;/code&gt; and &lt;code&gt;T&lt;/code&gt; and returns a value of type &lt;code&gt;R&lt;/code&gt;. It is &lt;a href=&quot;#invoking-a-function-type-instance&quot;&gt;invoked&lt;/a&gt; inside the &lt;em&gt;for&lt;/em&gt;-loop, and the return value is then assigned to &lt;code&gt;accumulator&lt;/code&gt;.</source>
          <target state="translated">上記のコードでは、パラメータは &lt;code&gt;combine&lt;/code&gt; 持つ&lt;a href=&quot;#function-types&quot;&gt;機能タイプ&lt;/a&gt; &lt;code&gt;(R, T) -&amp;gt; R&lt;/code&gt; が受け入れるように、種類の二つの引数を取る関数は &lt;code&gt;R&lt;/code&gt; と &lt;code&gt;T&lt;/code&gt; 型の戻り値 &lt;code&gt;R&lt;/code&gt; を。これは&lt;em&gt;for&lt;/em&gt;ループ内で&lt;a href=&quot;#invoking-a-function-type-instance&quot;&gt;呼び出さ&lt;/a&gt;れ、戻り値は &lt;code&gt;accumulator&lt;/code&gt; に割り当てられます。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="983dc81454e62d4d8dfeb15d4d6704ae3670a9b1" translate="yes" xml:space="preserve">
          <source>In the example above, the production sources for the JVM target are compiled by its &lt;code&gt;main&lt;/code&gt; compilation and therefore include the sources and dependencies from the source sets &lt;code&gt;jvmMain&lt;/code&gt; and &lt;code&gt;commonMain&lt;/code&gt; (due to the &lt;em&gt;depends on&lt;/em&gt; relation):</source>
          <target state="translated">上記の例では、JVMターゲットの本番ソースは &lt;code&gt;main&lt;/code&gt; コンパイルによってコンパイルされるため、ソースセット &lt;code&gt;jvmMain&lt;/code&gt; および &lt;code&gt;commonMain&lt;/code&gt; からのソースと依存関係が含まれます（&lt;em&gt;依存&lt;/em&gt;関係による）。</target>
        </trans-unit>
        <trans-unit id="92a4732d4ba58bb8eb4b7a1a153809f54718cd39" translate="yes" xml:space="preserve">
          <source>In the example below, we assume that there is a &lt;code&gt;DbModel&lt;/code&gt; base class, and that every subclass has got a parameterless primary constructor. In the inline function, &lt;code&gt;T&lt;/code&gt; is reified, so we can get the class metadata. We pass this to the function that does the real work of talking to the database.</source>
          <target state="translated">以下の例では、 &lt;code&gt;DbModel&lt;/code&gt; 基本クラスがあり、すべてのサブクラスがパラメーターなしのプライマリコンストラクターを持っていると想定しています。インライン関数では &lt;code&gt;T&lt;/code&gt; が具体化されているため、クラスのメタデータを取得できます。これを、データベースと対話する実際の作業を行う関数に渡します。</target>
        </trans-unit>
        <trans-unit id="f9725b5629cf5c05b1dabad8df3abc795d27f14a" translate="yes" xml:space="preserve">
          <source>In the example we have the most popular ways to pass or receive a string in the C language. We should take the return of &lt;code&gt;return_string&lt;/code&gt; with care. In general, it is best to make sure we use the right function to dispose the returned &lt;code&gt;char*&lt;/code&gt; with the right &lt;code&gt;free(..)&lt;/code&gt; function call.</source>
          <target state="translated">この例では、C言語で文字列を渡したり受け取ったりする最も一般的な方法があります。 &lt;code&gt;return_string&lt;/code&gt; の戻りには注意が必要です。一般に、正しい関数を使用して、返された &lt;code&gt;char*&lt;/code&gt; を正しい &lt;code&gt;free(..)&lt;/code&gt; 関数呼び出しで破棄することを確認することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="9c4a8189e026c3c979db7e1d0680469a7fc5819f" translate="yes" xml:space="preserve">
          <source>In the file &lt;code&gt;build.gradle&lt;/code&gt;(&lt;code&gt;.kts&lt;/code&gt;), it creates the &lt;code&gt;kotlin&lt;/code&gt; extension at the top level, which includes configuration for &lt;a href=&quot;#targets&quot;&gt;targets&lt;/a&gt;, &lt;a href=&quot;#source-sets&quot;&gt;source sets&lt;/a&gt;, and dependencies.</source>
          <target state="translated">ファイル &lt;code&gt;build.gradle&lt;/code&gt; （ &lt;code&gt;.kts&lt;/code&gt; ）で、トップレベルに &lt;code&gt;kotlin&lt;/code&gt; 拡張子を作成します。これには、&lt;a href=&quot;#targets&quot;&gt;ターゲット&lt;/a&gt;、&lt;a href=&quot;#source-sets&quot;&gt;ソースセット&lt;/a&gt;、および依存関係の構成が含まれます。</target>
        </trans-unit>
        <trans-unit id="45b64e498fcd11490ca143779a88435b7d9e0b0c" translate="yes" xml:space="preserve">
          <source>In the following example, &lt;code&gt;findViewById()&lt;/code&gt; is only invoked once:</source>
          <target state="translated">次の例では、 &lt;code&gt;findViewById()&lt;/code&gt; は1回だけ呼び出されます。</target>
        </trans-unit>
        <trans-unit id="85d9d8db073dbd0210787c9cf3ee16c0de44fcc4" translate="yes" xml:space="preserve">
          <source>In the following example, the &lt;code&gt;@Foo&lt;/code&gt; annotation on the &lt;code&gt;String&lt;/code&gt; type can be emitted to the bytecode and then used by the library code:</source>
          <target state="translated">次の例では、 &lt;code&gt;String&lt;/code&gt; 型の &lt;code&gt;@Foo&lt;/code&gt; アノテーションをバイトコードに出力して、ライブラリコードで使用できます。</target>
        </trans-unit>
        <trans-unit id="b6112ecb85c5a211c4961aa021f824a1d2e0e8f5" translate="yes" xml:space="preserve">
          <source>In the future, we are going to make the Kotlin Project Wizard even more flexible by adding more configuration options and templates.</source>
          <target state="translated">将来的には、設定オプションやテンプレートを追加することで、Kotlin Project Wizardをさらに柔軟にしていきたいと考えています。</target>
        </trans-unit>
        <trans-unit id="8cf0c93c6e85cb80e10b5e71f71e2e6899fc70c7" translate="yes" xml:space="preserve">
          <source>In the generated Kotlin declarations, we see that &lt;code&gt;str&lt;/code&gt; is represented as &lt;code&gt;CValuesRef&amp;lt;ByteVar/&amp;gt;?&lt;/code&gt;. The type is nullable, and we can simply pass Kotlin &lt;code&gt;null&lt;/code&gt; as the parameter value.</source>
          <target state="translated">生成されたKotlin宣言では、 &lt;code&gt;str&lt;/code&gt; が &lt;code&gt;CValuesRef&amp;lt;ByteVar/&amp;gt;?&lt;/code&gt; として表されていることがわかりますか？。タイプはnull可能で、パラメーター値としてKotlin &lt;code&gt;null&lt;/code&gt; を単に渡すことができます。</target>
        </trans-unit>
        <trans-unit id="6ffd682e74db1be23092050eecf5e03af23b3260" translate="yes" xml:space="preserve">
          <source>In the generated code, the &lt;code&gt;provideDelegate&lt;/code&gt; method is called to initialize the auxiliary &lt;code&gt;prop$delegate&lt;/code&gt; property. Compare the generated code for the property declaration &lt;code&gt;val prop: Type by MyDelegate()&lt;/code&gt; with the generated code &lt;a href=&quot;delegated-properties#translation-rules&quot;&gt;above&lt;/a&gt; (when the &lt;code&gt;provideDelegate&lt;/code&gt; method is not present):</source>
          <target state="translated">生成されたコードで、 &lt;code&gt;provideDelegate&lt;/code&gt; メソッドが呼び出され、補助 &lt;code&gt;prop$delegate&lt;/code&gt; プロパティが初期化されます。プロパティ宣言のために生成されたコードを比較 &lt;code&gt;val prop: Type by MyDelegate()&lt;/code&gt; 生成されたコードを有する&lt;a href=&quot;delegated-properties#translation-rules&quot;&gt;上記&lt;/a&gt;（場合 &lt;code&gt;provideDelegate&lt;/code&gt; の方法が存在しません）。</target>
        </trans-unit>
        <trans-unit id="f86f30c4d84e613891c93b386289b1fcc35ce4d5" translate="yes" xml:space="preserve">
          <source>In the last line &lt;code&gt;button&lt;/code&gt; is referenced by &lt;code&gt;id&lt;/code&gt; using the &lt;a href=&quot;android-plugin&quot;&gt;Kotlin Android Extensions&lt;/a&gt; plugin. Consider using this plugin as an alternative which allows you to keep binding logic in code and have the concise syntax at the same time.</source>
          <target state="translated">最後の行では、 &lt;code&gt;button&lt;/code&gt; は&lt;a href=&quot;android-plugin&quot;&gt;Kotlin Android Extensions&lt;/a&gt;プラグインを使用して &lt;code&gt;id&lt;/code&gt; によって参照されます。このプラグインを代替ロジックとして使用することを検討してください。これにより、コードのバインディングロジックを維持し、同時に簡潔な構文を使用できます。</target>
        </trans-unit>
        <trans-unit id="7da80e212e3fb5a8c2cf3d597abb266f174acf51" translate="yes" xml:space="preserve">
          <source>In the last line, there's an implicit &lt;code&gt;this.&lt;/code&gt; in front of both &lt;code&gt;memberFunction()&lt;/code&gt; and &lt;code&gt;memberProperty&lt;/code&gt; (if these exist on the type of &lt;code&gt;someExpression&lt;/code&gt;). The return value is that of the last expression.</source>
          <target state="translated">最後の行には、暗黙の &lt;code&gt;this.&lt;/code&gt; &lt;code&gt;memberFunction()&lt;/code&gt; と &lt;code&gt;memberProperty&lt;/code&gt; の両方の前（これらが &lt;code&gt;someExpression&lt;/code&gt; の型に存在する場合）。戻り値は最後の式の戻り値です。</target>
        </trans-unit>
        <trans-unit id="21de312c94f28c9a74e944cc50e80500b0df440a" translate="yes" xml:space="preserve">
          <source>In the next dialog, provide the project details:</source>
          <target state="translated">次のダイアログでは、プロジェクトの詳細を入力します。</target>
        </trans-unit>
        <trans-unit id="fb8d123847c0bf27cf6ffe6e978d7163ff9a921d" translate="yes" xml:space="preserve">
          <source>In the old model, common and platform-specific code needed to be placed in separate modules, linked by &lt;code&gt;expectedBy&lt;/code&gt; dependencies. Now, common and platform-specific code is placed in different source roots of the same module, making projects easier to configure.</source>
          <target state="translated">古いモデルでは、一般的なコードとプラットフォーム固有のコードを、 &lt;code&gt;expectedBy&lt;/code&gt; 依存関係によってリンクされた別々のモジュールに配置する必要がありました。現在、共通のプラットフォーム固有のコードは、同じモジュールの異なるソースルートに配置されており、プロジェクトの構成が容易になっています。</target>
        </trans-unit>
        <trans-unit id="f4616b5b5607f26fa0ff8085e2e0b28efc427ec9" translate="yes" xml:space="preserve">
          <source>In the panel on the left, select &lt;strong&gt;Kotlin&lt;/strong&gt;.</source>
          <target state="translated">左側のパネルで、&lt;strong&gt;Kotlinを&lt;/strong&gt;選択します。</target>
        </trans-unit>
        <trans-unit id="ca766f4efd26534c30d9c87798187848fcb65628" translate="yes" xml:space="preserve">
          <source>In the presence of &lt;code&gt;maven-publish&lt;/code&gt; plugin the publications for all the binaries built are created. The plugin uses Gradle metadata to publish the artifacts so this feature must be enabled (see the &lt;a href=&quot;#dependencies&quot;&gt;dependencies&lt;/a&gt; section).</source>
          <target state="translated">&lt;code&gt;maven-publish&lt;/code&gt; プラグインが存在する場合、ビルドされたすべてのバイナリのパブリケーションが作成されます。プラグインはGradleメタデータを使用してアーティファクトを公開するため、この機能を有効にする必要があります（&lt;a href=&quot;#dependencies&quot;&gt;依存関係の&lt;/a&gt;セクションを参照）。</target>
        </trans-unit>
        <trans-unit id="d60dd59e4676a95bd7097287912e2ec3768e0f9a" translate="yes" xml:space="preserve">
          <source>In the previous example the JavaScript module exports a single package. However, some JavaScript libraries export multiple packages from within a module. This case is also supported by Kotlin, though you have to declare a new &lt;code&gt;.kt&lt;/code&gt; file for each package you import.</source>
          <target state="translated">前の例では、JavaScriptモジュールは単一のパッケージをエクスポートします。ただし、一部のJavaScriptライブラリは、モジュール内から複数のパッケージをエクスポートします。このケースはKotlinでもサポートされていますが、インポートするパッケージごとに新しい &lt;code&gt;.kt&lt;/code&gt; ファイルを宣言する必要があります。</target>
        </trans-unit>
        <trans-unit id="2335f133bdfdd7a364b034cd26ff1377b715b5ad" translate="yes" xml:space="preserve">
          <source>In the progressive mode, deprecations and bug fixes for unstable code take effect immediately, instead of going through a graceful migration cycle. Code written in the progressive mode is backwards compatible; however, code written in a non-progressive mode may cause compilation errors in the progressive mode.</source>
          <target state="translated">プログレッシブモードでは、不安定なコードに対する非推奨事項やバグ修正は、 優雅な移行サイクルを経るのではなく、即座に適用されます。プログレッシブモードで書かれたコードは後方互換性がありますが、非プログレッシブモードで書かれたコードはプログレッシブモードでコンパイルエラーを起こす可能性があります。</target>
        </trans-unit>
        <trans-unit id="42d1f7acaeec00a73953ae801ded4c35e710f59f" translate="yes" xml:space="preserve">
          <source>In the tutorial we will learn:</source>
          <target state="translated">チュートリアルでは、私たちは学びます。</target>
        </trans-unit>
        <trans-unit id="5c983473a452d20ce90bb4b7f97f64c188d78e2f" translate="yes" xml:space="preserve">
          <source>In the tutorial we:</source>
          <target state="translated">チュートリアルでは、私たち。</target>
        </trans-unit>
        <trans-unit id="91d34ec07b8ea3ab8718a88b953168add8f0c256" translate="yes" xml:space="preserve">
          <source>In these examples &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-exception-handler/index.html&quot;&gt;CoroutineExceptionHandler&lt;/a&gt; is always installed to a coroutine that is created in &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope&lt;/a&gt;. It does not make sense to install an exception handler to a coroutine that is launched in the scope of the main &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt;, since the main coroutine is going to be always cancelled when its child completes with exception despite the installed handler.</source>
          <target state="translated">これらの例では、&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-exception-handler/index.html&quot;&gt;CoroutineExceptionHandler&lt;/a&gt;は常に&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope&lt;/a&gt;で作成されたコルーチンにインストールされます。メインの&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlockingの&lt;/a&gt;スコープで起動されたコルーチンに例外ハンドラーをインストールすることは意味がありません。これは、インストールされたハンドラーにもかかわらず、子が例外を完了したときにメインコルーチンが常にキャンセルされるためです。</target>
        </trans-unit>
        <trans-unit id="095e7f10496f59e9c1f965ea0b808ca458b5529c" translate="yes" xml:space="preserve">
          <source>In this case the compiler will not be downloaded by the plugin.</source>
          <target state="translated">この場合、コンパイラはプラグインからダウンロードされません。</target>
        </trans-unit>
        <trans-unit id="f1f881dff617021acda0968035a0c51bb38a1c2d" translate="yes" xml:space="preserve">
          <source>In this case, JQuery will be imported as a module named &lt;code&gt;jquery&lt;/code&gt;. Alternatively, it can be used as a $-object, depending on what module system Kotlin compiler is configured to use.</source>
          <target state="translated">この場合、JQueryは &lt;code&gt;jquery&lt;/code&gt; という名前のモジュールとしてインポートされます。または、Kotlinコンパイラーが使用するように構成されているモジュールシステムに応じて、$オブジェクトとして使用できます。</target>
        </trans-unit>
        <trans-unit id="c032e19443eb1eff2c0c1528c6eb2e5d72dfce23" translate="yes" xml:space="preserve">
          <source>In this case, we've set the output of our compilation to the &lt;code&gt;scripts&lt;/code&gt; folder. On running the application we should see the following output:</source>
          <target state="translated">この例では、コンパイルの出力を &lt;code&gt;scripts&lt;/code&gt; フォルダーに設定しています。アプリケーションを実行すると、次の出力が表示されます。</target>
        </trans-unit>
        <trans-unit id="b5a6a88d0b58461497da6e47e4eb3bdd5fbf2b22" translate="yes" xml:space="preserve">
          <source>In this case, you can share code across native targets in your project using the hierarchical structure.</source>
          <target state="translated">この場合、階層構造を利用して、プロジェクト内のネイティブターゲット間でコードを共有することができます。</target>
        </trans-unit>
        <trans-unit id="de0ac72463e7c41b8825d92484726f740a2112b2" translate="yes" xml:space="preserve">
          <source>In this dense code, in addition to collection transformations, you can see such handy Kotlin features as local functions and the &lt;a href=&quot;../reference/null-safety#elvis-operator&quot;&gt;elvis operator&lt;/a&gt;&lt;code&gt;?:&lt;/code&gt; that allow to express &lt;a href=&quot;../reference/idioms&quot;&gt;idioms&lt;/a&gt; like &quot;take the value if it is positive or else use length&quot; with a concise and readable expressions like &lt;code&gt;.takeIf { it &amp;gt;= 0 } ?: s.length&lt;/code&gt;, yet it is perfectly fine with Kotlin to create additional mutable variables and express the same code in imperative style, too.</source>
          <target state="translated">この密なコードでは、コレクションの変換に加えて、あなたは、このような便利なKotlinは地元の機能として備えており、見ることができる&lt;a href=&quot;../reference/null-safety#elvis-operator&quot;&gt;演算子をELVIS &lt;/a&gt; &lt;code&gt;?:&lt;/code&gt; 表現することを可能にするという&lt;a href=&quot;../reference/idioms&quot;&gt;イディオム&lt;/a&gt;簡潔で、「それは、正または他の使用の長さがある場合は、値を取る」などを &lt;code&gt;.takeIf { it &amp;gt;= 0 } ?: s.length&lt;/code&gt; ような読み取り可能な式ですが、追加の可変変数を作成して同じコードを命令型スタイルで表現することもKotlinでは完全に問題ありません。</target>
        </trans-unit>
        <trans-unit id="e691bb86d414ab1eeeac0ce8d8cf107c13b24d6b" translate="yes" xml:space="preserve">
          <source>In this doc, we'll sometimes specify the type unnecessarily, in order to highlight what type is produced by an expression. (Also, a good IDE will be able to show you the resulting type.)</source>
          <target state="translated">このドキュメントでは、式によってどのような型が生成されるかを強調するために、不必要に型を指定することがあります。(また、優れたIDEであれば、結果の型を表示することができます)。</target>
        </trans-unit>
        <trans-unit id="7d12593ba02967f080622029b34989f6d346aaf9" translate="yes" xml:space="preserve">
          <source>In this document we introduce several kinds of compatibility:</source>
          <target state="translated">このドキュメントでは、いくつかの種類の互換性を紹介します。</target>
        </trans-unit>
        <trans-unit id="537f8c16fc8f03cc135b33707b31eb29f9995ea0" translate="yes" xml:space="preserve">
          <source>In this example only members of the nearest implicit receiver &lt;code&gt;this@head&lt;/code&gt; must be available; &lt;code&gt;head()&lt;/code&gt; is a member of the outer receiver &lt;code&gt;this@html&lt;/code&gt;, so it must be illegal to call it.</source>
          <target state="translated">この例では、最も近い暗黙のレシーバー &lt;code&gt;this@head&lt;/code&gt; メンバーのみが使用可能でなければなりません。 &lt;code&gt;head()&lt;/code&gt; は、外側のレシーバ &lt;code&gt;this@html&lt;/code&gt; メンバーなので、呼び出すことは違法でなければなりません。</target>
        </trans-unit>
        <trans-unit id="9c36d65c210f75f6cba412252945fedc98c222bc" translate="yes" xml:space="preserve">
          <source>In this example we launch a new coroutine in a background thread pool using &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-default.html&quot;&gt;Dispatchers.Default&lt;/a&gt;, so it works on a different thread from the thread pool, but it still has the value of the thread local variable that we specified using &lt;code&gt;threadLocal.asContextElement(value = &quot;launch&quot;)&lt;/code&gt;, no matter which thread the coroutine is executed on. Thus, the output (with &lt;a href=&quot;#debugging-coroutines-and-threads&quot;&gt;debug&lt;/a&gt;) is:</source>
          <target state="translated">この例では、&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-default.html&quot;&gt;Dispatchers.Default&lt;/a&gt;を使用してバックグラウンドスレッドプールで新しいコルーチンを起動するため、スレッドプールとは異なるスレッドで機能しますが、 &lt;code&gt;threadLocal.asContextElement(value = &quot;launch&quot;)&lt;/code&gt; を使用して指定したスレッドローカル変数の値は引き続き保持されます。 = &quot;launch&quot;）、コルーチンが実行されるスレッドに関係なく。したがって、出力（&lt;a href=&quot;#debugging-coroutines-and-threads&quot;&gt;デバッグあり&lt;/a&gt;）は次のようになります。</target>
        </trans-unit>
        <trans-unit id="67582c167007a9ba92244086b3d65c9a9e9700f4" translate="yes" xml:space="preserve">
          <source>In this example we launch a new coroutine in a background thread pool using &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-default.html&quot;&gt;Dispatchers.Default&lt;/a&gt;, so it works on a different threads from a thread pool, but it still has the value of thread local variable, that we've specified using &lt;code&gt;threadLocal.asContextElement(value = &quot;launch&quot;)&lt;/code&gt;, no matter on what thread the coroutine is executed. Thus, output (with &lt;a href=&quot;#debugging-coroutines-and-threads&quot;&gt;debug&lt;/a&gt;) is:</source>
          <target state="translated">この例では、&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-default.html&quot;&gt;Dispatchers.Default&lt;/a&gt;を使用してバックグラウンドスレッドプールで新しいコルーチンを起動します。これにより、スレッドコルーチンは、スレッドプールとは異なるスレッドで機能しますが、 &lt;code&gt;threadLocal.asContextElement(value = &quot;launch&quot;)&lt;/code&gt; を使用して指定したスレッドローカル変数の値を保持します。 （値= &quot;launch&quot;）、コルーチンが実行されるスレッドに関係なく。したがって、（&lt;a href=&quot;#debugging-coroutines-and-threads&quot;&gt;debugを使用した&lt;/a&gt;）出力は次のようになります。</target>
        </trans-unit>
        <trans-unit id="872d3ddd1be8b8c4ec3ab8cc792f3b5cde57d822" translate="yes" xml:space="preserve">
          <source>In this example, all values passed to the C API &lt;code&gt;new_menu()&lt;/code&gt; have a lifetime of the innermost &lt;code&gt;memScope&lt;/code&gt; it belongs to. Once the control flow leaves the &lt;code&gt;memScoped&lt;/code&gt; scope the C pointers become invalid.</source>
          <target state="translated">この例では、C API &lt;code&gt;new_menu()&lt;/code&gt; に渡されるすべての値は、それが属する最も内側の &lt;code&gt;memScope&lt;/code&gt; の有効期間を持っています。制御フローが &lt;code&gt;memScoped&lt;/code&gt; スコープを離れると、Cポインターは無効になります。</target>
        </trans-unit>
        <trans-unit id="5b70f0a7dd260f72c7acee91c3f5762c472a459a" translate="yes" xml:space="preserve">
          <source>In this example, the constructor takes a map:</source>
          <target state="translated">この例では、コンストラクタはマップを受け取ります。</target>
        </trans-unit>
        <trans-unit id="06698ce38b883fc740d14dcc830fa9e382960eb5" translate="yes" xml:space="preserve">
          <source>In this example, the sequence processing takes 18 steps instead of 23 steps for doing the same with lists.</source>
          <target state="translated">この例では、リストで同様の処理を行う場合の23ステップの代わりに、18ステップのシーケンス処理を行う。</target>
        </trans-unit>
        <trans-unit id="550b3c67b81cc4d4252fe83306649fc1df1e86da" translate="yes" xml:space="preserve">
          <source>In this example, using &lt;code&gt;Person&lt;/code&gt; and &lt;code&gt;callAndPrintTwoParam()&lt;/code&gt; from the previous section, we locate a member function reference by name and call it:</source>
          <target state="translated">この例では、前のセクションの &lt;code&gt;Person&lt;/code&gt; および &lt;code&gt;callAndPrintTwoParam()&lt;/code&gt; を使用して、メンバー関数参照を名前で検索し、呼び出します。</target>
        </trans-unit>
        <trans-unit id="25017fcbb3e37d1b9106fc29788136cb1c456365" translate="yes" xml:space="preserve">
          <source>In this function both &lt;a href=&quot;-continuation/resume&quot;&gt;Continuation.resume&lt;/a&gt; and &lt;a href=&quot;-continuation/resume-with-exception&quot;&gt;Continuation.resumeWithException&lt;/a&gt; can be used either synchronously in the same stack-frame where suspension function is run or asynchronously later in the same thread or from a different thread of execution. Repeated invocation of any resume function produces &lt;a href=&quot;../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt;.</source>
          <target state="translated">この関数では、&lt;a href=&quot;-continuation/resume&quot;&gt;Continuation.resume&lt;/a&gt;と&lt;a href=&quot;-continuation/resume-with-exception&quot;&gt;Continuation.resumeWithExceptionの&lt;/a&gt;両方を、サスペンション関数が実行されている同じスタックフレームで同期的に使用することも、後で同じスレッドでまたは非同期に別の実行スレッドから使​​用することもできます。再開関数を繰り返し呼び出すと、&lt;a href=&quot;../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateExceptionが発生し&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="a802dce08d5c39703b387f16a864974235e44de0" translate="yes" xml:space="preserve">
          <source>In this function both &lt;a href=&quot;resume&quot;&gt;Continuation.resume&lt;/a&gt; and &lt;a href=&quot;resume-with-exception&quot;&gt;Continuation.resumeWithException&lt;/a&gt; can be used either synchronously in the same stack-frame where the suspension function is run or asynchronously later in the same thread or from a different thread of execution. Subsequent invocation of any resume function will produce an &lt;a href=&quot;../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt;.</source>
          <target state="translated">この関数では、&lt;a href=&quot;resume&quot;&gt;Continuation.resume&lt;/a&gt;と&lt;a href=&quot;resume-with-exception&quot;&gt;Continuation.resumeWithExceptionの&lt;/a&gt;両方を、suspend関数が実行される同じスタックフレームで同期的に使用することも、同じスレッドで後で非同期に、または別の実行スレッドから使​​用することもできます。その後に再開機能を呼び出すと、&lt;a href=&quot;../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt;が発生します。</target>
        </trans-unit>
        <trans-unit id="677125a2bada551194ff25d8eec9f1b62a3c4ba4" translate="yes" xml:space="preserve">
          <source>In this section a commented DSL is shown. See also the example projects that use this plugin, e.g. &lt;a href=&quot;https://github.com/Kotlin/kotlinx.coroutines&quot;&gt;Kotlinx.coroutines&lt;/a&gt;, &lt;a href=&quot;https://github.com/e5l/http-client-common/tree/master/samples/ios-test-application&quot;&gt;MPP http client&lt;/a&gt;</source>
          <target state="translated">このセクションでは、コメント付きのDSLが表示されます。このプラグインを使用するサンプルプロジェクトも参照してください。例：&lt;a href=&quot;https://github.com/Kotlin/kotlinx.coroutines&quot;&gt;Kotlinx.coroutines&lt;/a&gt;、&lt;a href=&quot;https://github.com/e5l/http-client-common/tree/master/samples/ios-test-application&quot;&gt;MPP httpクライアント&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="45d0e31509240af7f0d899e0847fb308f3f6c3d9" translate="yes" xml:space="preserve">
          <source>In this tutorial We will learn how to:</source>
          <target state="translated">このチュートリアルでは、以下の方法を学びます。</target>
        </trans-unit>
        <trans-unit id="b8d78e48aa113b25ef679f219669ead0543c6d9d" translate="yes" xml:space="preserve">
          <source>In this tutorial however, we'll see how to use some specific libraries, such as &lt;code&gt;libcurl&lt;/code&gt;. We'll learn to</source>
          <target state="translated">ただし、このチュートリアルでは、 &lt;code&gt;libcurl&lt;/code&gt; などの特定のライブラリの使用方法について説明します。私たちは学びます</target>
        </trans-unit>
        <trans-unit id="38ae904b992e64be7d6f1c95db212a698e90d2ef" translate="yes" xml:space="preserve">
          <source>In this tutorial we have:</source>
          <target state="translated">このチュートリアルでは</target>
        </trans-unit>
        <trans-unit id="814c4fd32a87a880ed24663823d0826f5fba0218" translate="yes" xml:space="preserve">
          <source>In this tutorial we see how to deal with C strings in Kotlin/Native. We will learn how to:</source>
          <target state="translated">このチュートリアルでは、Kotlin/NativeでC言語の文字列を扱う方法を見ていきます。その方法を学んでいきます。</target>
        </trans-unit>
        <trans-unit id="f187570814c6d6abda5a2c00ead30d73ef74a12e" translate="yes" xml:space="preserve">
          <source>In this tutorial we will create an iOS and Android application, by making use of Kotlin's code sharing features. For Android we'll be using Kotlin/JVM, while for iOS it will be Kotlin/Native.</source>
          <target state="translated">このチュートリアルでは、Kotlinのコード共有機能を利用して、iOSとAndroidのアプリケーションを作成します。AndroidではKotlin/JVMを使用し、iOSではKotlin/Nativeを使用します。</target>
        </trans-unit>
        <trans-unit id="e75dd7cce5c41f63288c1748bd5bfd1c78d1ff1b" translate="yes" xml:space="preserve">
          <source>In this tutorial we'll see how to</source>
          <target state="translated">このチュートリアルでは</target>
        </trans-unit>
        <trans-unit id="73192ff47f695a8d1b74a36ad93cdb6ae37eb2de" translate="yes" xml:space="preserve">
          <source>In this tutorial we'll walk through the steps required to use the Kotlin Android Extensions plugin, enhancing the experience of Android development.</source>
          <target state="translated">このチュートリアルでは、Kotlin Android Extensionsプラグインを使用するために必要な手順を説明します。</target>
        </trans-unit>
        <trans-unit id="f0e340bf119483d38d43d3af161837206adf260c" translate="yes" xml:space="preserve">
          <source>In this tutorial we'll walk through the steps required. For a more thorough explanation of Spring Boot and Kotlin, please see &lt;a href=&quot;https://spring.io/guides/tutorials/spring-boot-kotlin/&quot;&gt;Building web applications with Spring Boot and Kotlin&lt;/a&gt;.</source>
          <target state="translated">このチュートリアルでは、必要な手順について説明します。Spring BootとKotlinの詳細については&lt;a href=&quot;https://spring.io/guides/tutorials/spring-boot-kotlin/&quot;&gt;、Spring BootとKotlinを使用したウェブアプリケーションの構築&lt;/a&gt;をご覧ください。</target>
        </trans-unit>
        <trans-unit id="04ead99e3026a0a00111c1c9a4f51b0c3c739752" translate="yes" xml:space="preserve">
          <source>In this tutorial we'll:</source>
          <target state="translated">このチュートリアルでは</target>
        </trans-unit>
        <trans-unit id="0f464678d81fef87702589d2f00f58596a930600" translate="yes" xml:space="preserve">
          <source>In this tutorial we're going to use IntelliJ IDEA. For instructions on how to compile and execute Kotlin applications using the command line compiler, see &lt;a href=&quot;command-line&quot;&gt;Working with the Command Line Compiler&lt;/a&gt;.</source>
          <target state="translated">このチュートリアルでは、IntelliJ IDEAを使用します。コマンドラインコンパイラを使用してKotlinアプリケーションをコンパイルして実行する方法については、参照&lt;a href=&quot;command-line&quot;&gt;コマンドラインコンパイラを使用した作業を&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a5d5b9a27b34d95239a0c33821d0a9b033c40bd3" translate="yes" xml:space="preserve">
          <source>In this tutorial we've seen how to create a Kotlin application that targets JavaScript, debug it as well as set compiler options. In other tutorials we'll cover more in-depth topics such as interacting with the DOM, etc.</source>
          <target state="translated">このチュートリアルでは、JavaScriptをターゲットにしたKotlinアプリケーションの作成方法、デバッグ方法、コンパイラオプションの設定方法を見てきました。他のチュートリアルでは、DOM との対話など、より深いトピックを取り上げていきます。</target>
        </trans-unit>
        <trans-unit id="15ab8dc4bd9f08f596ae63880b3958cb4434a6d7" translate="yes" xml:space="preserve">
          <source>In this tutorial, we learn what C data types are visible in Kotlin/Native and vice versa. We will:</source>
          <target state="translated">このチュートリアルでは、Kotlin/Native ではどのような C 言語のデータ型が表示されるのか、またその逆の場合はどのようなデータ型が表示されるのかを学びます。このチュートリアルでは、以下のことを学びます。</target>
        </trans-unit>
        <trans-unit id="8a05d2cdb1fd77bc1ee6b2a0bfc489f7b20f51b2" translate="yes" xml:space="preserve">
          <source>In this tutorial, we look at how we can use the Kotlin/Native code from existing native applications or libraries. For this, we need to compile our Kotlin code into a dynamic library, &lt;code&gt;.so&lt;/code&gt;, &lt;code&gt;.dylib&lt;/code&gt;, and &lt;code&gt;.dll&lt;/code&gt;.</source>
          <target state="translated">このチュートリアルでは、既存のネイティブアプリケーションまたはライブラリからKotlin / Nativeコードを使用する方法について説明します。これを行うには、Kotlinコードを動的ライブラリ &lt;code&gt;.so&lt;/code&gt; 、 &lt;code&gt;.dylib&lt;/code&gt; 、および &lt;code&gt;.dll&lt;/code&gt; にコンパイルする必要があります。</target>
        </trans-unit>
        <trans-unit id="0865fef18032d86f743ee83bf90f480e5f932289" translate="yes" xml:space="preserve">
          <source>In this tutorial, we will build a small library available from the worlds of JVM, JS, and Native.</source>
          <target state="translated">このチュートリアルでは、JVM、JS、Nativeの世界から利用可能な小さなライブラリを構築します。</target>
        </trans-unit>
        <trans-unit id="701903e9f376cd1d8503774a4d299554e97196a0" translate="yes" xml:space="preserve">
          <source>In this tutorial, we will build a small library available from the worlds of JVM, JS, and Native. You will learn step-by-step how to create a multiplatform library which can be used from any other common code (e.g., one shared with Android and iOS), and how to write tests which will be executed on all platforms and use an efficient implementation provided by the concrete platform.</source>
          <target state="translated">このチュートリアルでは、JVM、JS、Native の世界から利用可能な小さなライブラリを構築します。他のどのような共通コード(例えば、AndroidやiOSと共有されているもの)からでも利用できるマルチプラットフォームライブラリを作成する方法や、すべてのプラットフォームで実行され、具体的なプラットフォームが提供する効率的な実装を利用するテストの書き方をステップバイステップで学びます。</target>
        </trans-unit>
        <trans-unit id="8459da0cf638e813dae1e5c0fa95e9568c3582bd" translate="yes" xml:space="preserve">
          <source>In this tutorial, we will look at how to use Kotlin/Native code from Objective-C and Swift applications on macOS and iOS. We will build a framework from Kotlin code.</source>
          <target state="translated">このチュートリアルでは、Objective-CやSwiftアプリのKotlin/NativeコードをmacOSやiOSで利用する方法を見ていきます。Kotlinのコードからフレームワークを構築していきます。</target>
        </trans-unit>
        <trans-unit id="864dde628feba0ddb56fa697c290d183bee8b077" translate="yes" xml:space="preserve">
          <source>In this tutorial, we will:</source>
          <target state="translated">このチュートリアルでは、次のことを行います。</target>
        </trans-unit>
        <trans-unit id="98c10d04454a966f67cb1dfe790300722810cd2d" translate="yes" xml:space="preserve">
          <source>In this tutorial, we'll look at how to</source>
          <target state="translated">このチュートリアルでは、以下の方法を見ていきます。</target>
        </trans-unit>
        <trans-unit id="0c3ebd5f96036d4c23f2a9d6d5dd9911faa69aff" translate="yes" xml:space="preserve">
          <source>In this tutorial, we're going to be using Gradle but the same can be accomplished using either IntelliJ IDEA project structure or Maven. For details on setting up Gradle to work with Kotlin, see &lt;a href=&quot;../reference/using-gradle&quot;&gt;Using Gradle&lt;/a&gt;.</source>
          <target state="translated">このチュートリアルでは、Gradleを使用しますが、IntelliJ IDEAプロジェクト構造またはMavenを使用しても同じことができます。Kotlinで動作するようにGradleを設定する方法の詳細については、「&lt;a href=&quot;../reference/using-gradle&quot;&gt;Gradleの使用&lt;/a&gt;」を参照してください。</target>
        </trans-unit>
        <trans-unit id="aa1a5fa948935055fc078b1993ec8baed9df514c" translate="yes" xml:space="preserve">
          <source>In this tutorial, we're going to be using Gradle but the same can be accomplished using either IntelliJ IDEA project structure or Maven. For details on setting up Gradle to work with Kotlin, see &lt;a href=&quot;../reference/using-gradle&quot;&gt;Using Gradle&lt;/a&gt;. The main dependency required for using HTTP servlets is the JavaEE API:</source>
          <target state="translated">このチュートリアルでは、Gradleを使用しますが、IntelliJ IDEAプロジェクト構造またはMavenを使用しても同じことができます。Kotlinで動作するようにGradleを設定する方法の詳細については、「&lt;a href=&quot;../reference/using-gradle&quot;&gt;Gradleの使用&lt;/a&gt;」を参照してください。HTTPサーブレットを使用するために必要な主な依存関係は、JavaEE APIです。</target>
        </trans-unit>
        <trans-unit id="40ab0f9121b36c46d899b6425de4821ece3db190" translate="yes" xml:space="preserve">
          <source>In this video, Kotlin Developer Advocate Sebastian Aigner will explain the main Kotlin/JS benefits to you, share some tips and use cases, and also tell you about the plans and upcoming features for Kotlin/JS.</source>
          <target state="translated">このビデオでは、Kotlin Developer AdvocateのSebastian AignerがKotlin/JSの主な利点を説明し、いくつかのヒントやユースケースを共有し、Kotlin/JSの計画や今後の機能についてもお伝えします。</target>
        </trans-unit>
        <trans-unit id="23e1b785f9b5814cd84a43b0c10801c0740b41ac" translate="yes" xml:space="preserve">
          <source>In turn, &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;also&lt;/code&gt; have the context object as a lambda argument. If the argument name is not specified, the object is accessed by the implicit default name &lt;code&gt;it&lt;/code&gt;. &lt;code&gt;it&lt;/code&gt; is shorter than &lt;code&gt;this&lt;/code&gt; and expressions with &lt;code&gt;it&lt;/code&gt; are usually easier for reading. However, when calling the object functions or properties you don't have the object available implicitly like &lt;code&gt;this&lt;/code&gt;. Hence, having the context object as &lt;code&gt;it&lt;/code&gt; is better when the object is mostly used as an argument in function calls. &lt;code&gt;it&lt;/code&gt; is also better if you use multiple variables in the code block.</source>
          <target state="translated">ターンでは、 &lt;code&gt;let&lt;/code&gt; と &lt;code&gt;also&lt;/code&gt; ラムダ引数としてコンテキストオブジェクトを持っています。引数名が指定されていない場合、オブジェクトは暗黙のデフォルト名 &lt;code&gt;it&lt;/code&gt; でアクセスされます。 &lt;code&gt;it&lt;/code&gt; は &lt;code&gt;this&lt;/code&gt; よりも短く、通常、 &lt;code&gt;it&lt;/code&gt; を含む式は読みやすくなります。ただし、オブジェクトの関数またはプロパティを呼び出す場合、 &lt;code&gt;this&lt;/code&gt; ように暗黙的に使用できるオブジェクトはありません。したがって、オブジェクトが関数呼び出しの引数として主に使用される場合は、コンテキストオブジェクトを使用 &lt;code&gt;it&lt;/code&gt; 方が適切です。 &lt;code&gt;it&lt;/code&gt; あなたがコードブロックに複数の変数を使用している場合にも優れています。</target>
        </trans-unit>
        <trans-unit id="812b574e96ace8dd4cdbeccd6ad6e3f2e4f0aabb" translate="yes" xml:space="preserve">
          <source>In turn, mutable collections aren't covariant; otherwise, this would lead to runtime failures. If &lt;code&gt;MutableList&amp;lt;Rectangle&amp;gt;&lt;/code&gt; was a subtype of &lt;code&gt;MutableList&amp;lt;Shape&amp;gt;&lt;/code&gt;, you could insert other &lt;code&gt;Shape&lt;/code&gt; inheritors (for example, &lt;code&gt;Circle&lt;/code&gt;) into it, thus violating its &lt;code&gt;Rectangle&lt;/code&gt; type argument.</source>
          <target state="translated">一方、変更可能なコレクションは共変ではありません。そうしないと、ランタイムエラーが発生します。場合 &lt;code&gt;MutableList&amp;lt;Rectangle&amp;gt;&lt;/code&gt; のサブタイプだった &lt;code&gt;MutableList&amp;lt;Shape&amp;gt;&lt;/code&gt; 、あなたは他の挿入可能性 &lt;code&gt;Shape&lt;/code&gt; （例えば、相続を &lt;code&gt;Circle&lt;/code&gt; したがって、その違反し、その中に） &lt;code&gt;Rectangle&lt;/code&gt; 型引数を。</target>
        </trans-unit>
        <trans-unit id="2a50d6665033bbbaf15909f2a8b12edea9bb1926" translate="yes" xml:space="preserve">
          <source>In turn, set is not an ordered collection by &lt;a href=&quot;collections-overview&quot;&gt;definition&lt;/a&gt;. However, the Kotlin &lt;code&gt;Set&lt;/code&gt; stores elements in certain orders. These can be the order of insertion (in &lt;code&gt;LinkedHashSet&lt;/code&gt;), natural sorting order (in &lt;code&gt;SortedSet&lt;/code&gt;), or another order. The order of a set of elements can also be unknown. In such cases, the elements are still ordered somehow, so the functions that rely on the element positions still return their results. However, such results are unpredictable to the caller unless they know the specific implementation of &lt;code&gt;Set&lt;/code&gt; used.</source>
          <target state="translated">同様に、セットは&lt;a href=&quot;collections-overview&quot;&gt;定義&lt;/a&gt;により順序付けられたコレクションではありません。ただし、Kotlin &lt;code&gt;Set&lt;/code&gt; は特定の順序で要素を格納します。これらは、挿入の順序（ &lt;code&gt;LinkedHashSet&lt;/code&gt; 内）、自然なソート順（ &lt;code&gt;SortedSet&lt;/code&gt; 内）、または別の順序にすることができます。要素のセットの順序も不明な場合があります。そのような場合でも、要素はなんらかの方法で順序付けられているため、要素の位置に依存する関数は結果を返します。ただし、このような結果は、使用される &lt;code&gt;Set&lt;/code&gt; の特定の実装を知らない限り、呼び出し元には予測できません。</target>
        </trans-unit>
        <trans-unit id="26d300702c75a3b26e8ba1f4228f68dc28aca421" translate="yes" xml:space="preserve">
          <source>In turn, worksheets are project files: they are stored in project directories and tied to the project modules. Worksheets are useful for writing code parts that don't actually make a software unit but should still be stored together in a project. For example, you can use worksheets for education or demo materials.</source>
          <target state="translated">ワークシートはプロジェクトディレクトリに格納され、プロジェクトモジュールに関連付けられています。ワークシートは、実際にはソフトウェアユニットを作らないが、プロジェクトに一緒に保存されるべきコード部分を書くのに便利です。例えば、教育用やデモ用の教材にワークシートを使うことができます。</target>
        </trans-unit>
        <trans-unit id="01b654ef30cda18991ddded390d4b967ccf9e9a4" translate="yes" xml:space="preserve">
          <source>In your scratch, you can write any valid Kotlin code, including new functions and classes. Syntax highlighting, auto-completion, and other code editing features of IntelliJ IDEA are supported in scratches.</source>
          <target state="translated">スクラッチでは、新しい関数やクラスを含む有効なKotlinコードを書くことができます。スクラッチでは、IntelliJ IDEAのシンタックスハイライト、自動補完、その他のコード編集機能がサポートされています。</target>
        </trans-unit>
        <trans-unit id="5ab1113b4018a56db06428b02b9d9a142cf8f11e" translate="yes" xml:space="preserve">
          <source>Include Java sources in JVM compilations</source>
          <target state="translated">JVMコンパイルにJavaソースを含める</target>
        </trans-unit>
        <trans-unit id="3348bba79393338a33249573a6e3c773462946f1" translate="yes" xml:space="preserve">
          <source>Include a custom JDK from the specified location into the classpath instead of the default JAVA_HOME</source>
          <target state="translated">デフォルトの JAVA_HOME の代わりに、指定した場所のカスタム JDK をクラスパスに含めます。</target>
        </trans-unit>
        <trans-unit id="a9e17f8d5ea37546d212a719c404957805afefc8" translate="yes" xml:space="preserve">
          <source>Include the Kotlin runtime into the resulting JAR file. Makes the resulting archive runnable on any Java-enabled environment.</source>
          <target state="translated">結果の JAR ファイルに Kotlin ランタイムをインクルードします。生成されたアーカイブは、Javaが使用可能な環境であれば、どのような環境でも実行可能になります。</target>
        </trans-unit>
        <trans-unit id="bcb9fe75af30595cd7b7cb634e1bb8d624522edb" translate="yes" xml:space="preserve">
          <source>Include the native bitcode library.</source>
          <target state="translated">ネイティブビットコードライブラリをインクルードします。</target>
        </trans-unit>
        <trans-unit id="e2d58567583dee9bd57b8d9341149118d1dbe174" translate="yes" xml:space="preserve">
          <source>Includes Java sources into the JVM target&amp;rsquo;s compilations.</source>
          <target state="translated">JavaソースをJVMターゲットのコンパイルに含めます。</target>
        </trans-unit>
        <trans-unit id="f2699078d9287cbd90f76ee50448a4fec028de87" translate="yes" xml:space="preserve">
          <source>Including static library in your klib</source>
          <target state="translated">klibにスタティックライブラリを含める</target>
        </trans-unit>
        <trans-unit id="84996d5891b1f1a645c33eb5c3b22433a18e3eec" translate="yes" xml:space="preserve">
          <source>Incompatible Changes</source>
          <target state="translated">互換性のない変更</target>
        </trans-unit>
        <trans-unit id="c39322316343eb0abd4a312f2f7bc80b85919258" translate="yes" xml:space="preserve">
          <source>Inconsistent behavior of floating-point number comparisons</source>
          <target state="translated">浮動小数点数比較の一貫性のない挙動</target>
        </trans-unit>
        <trans-unit id="972d0a464d55eb6f53d336a20851a05ba6148f80" translate="yes" xml:space="preserve">
          <source>Incorrect generic signature in annotations when KClass is used as a generic parameter</source>
          <target state="translated">KClass がジェネリック・パラメータとして使用されている場合のアノテーションでのジェネリック・シグネチャが正しくありません。</target>
        </trans-unit>
        <trans-unit id="8d41722fdaa1b8acfa42d80a00302ec1d80e560e" translate="yes" xml:space="preserve">
          <source>IncorrectDereferenceException</source>
          <target state="translated">IncorrectDereferenceException</target>
        </trans-unit>
        <trans-unit id="7c15aa041f9a78e640a95e3034dce236ee5d488b" translate="yes" xml:space="preserve">
          <source>Incremental Compilation</source>
          <target state="translated">インクリメンタルコンパイル</target>
        </trans-unit>
        <trans-unit id="1d25e364e8dc05079a68a8ada56d8fbeda70bc16" translate="yes" xml:space="preserve">
          <source>Incremental annotation processing (since 1.3.30)</source>
          <target state="translated">増分アノテーション処理(1.3.30以降</target>
        </trans-unit>
        <trans-unit id="29106d30f82b4fbf8a046db084591a963e0208cc" translate="yes" xml:space="preserve">
          <source>Incremental annotation processing is enabled by default starting from version 1.3.50. To disable incremental annotation processing, add this line to your &lt;code&gt;gradle.properties&lt;/code&gt; file:</source>
          <target state="translated">バージョン1.3.50以降、増分注釈処理はデフォルトで有効になっています。インクリメンタルアノテーション処理を無効にするには、次の行を &lt;code&gt;gradle.properties&lt;/code&gt; ファイルに追加します。</target>
        </trans-unit>
        <trans-unit id="b1262b9eb921db266028505964086f28ad7e7f94" translate="yes" xml:space="preserve">
          <source>Incremental compilation</source>
          <target state="translated">インクリメンタルコンパイル</target>
        </trans-unit>
        <trans-unit id="3bb3cfba326a2bdc90f381639a6d53003c8fb9e7" translate="yes" xml:space="preserve">
          <source>Incremental compilation is supported for Kotlin/JVM and Kotlin/JS projects.</source>
          <target state="translated">インクリメンタルコンパイルはKotlin/JVMとKotlin/JSプロジェクトでサポートされています。</target>
        </trans-unit>
        <trans-unit id="33b5061796594b36b41f624484bcfb3853bb6d0c" translate="yes" xml:space="preserve">
          <source>Incremental compilation is supported for Kotlin/JVM and Kotlin/JS projects. It's enabled by default since Kotlin 1.1.1 for Kotlin/JVM and 1.3.20 for Kotlin/JS.</source>
          <target state="translated">インクリメンタルコンパイルはKotlin/JVMとKotlin/JSプロジェクトでサポートされています。Kotlin/JVMではKotlin 1.1.1、Kotlin/JSでは1.3.20からデフォルトで有効になっています。</target>
        </trans-unit>
        <trans-unit id="d6dbea2b53708e66e73d3f1a6a99defec97fa2a9" translate="yes" xml:space="preserve">
          <source>Incremental releases bring updates in the tooling (often including features), performance improvements and bug fixes. We try to keep such versions compatible with each other, so changes to the compiler are mostly optimizations and warning additions/removals. Experimental features may, of course, be added, removed or changed at any time.</source>
          <target state="translated">インクリメンタルリリースでは、ツールの更新 (多くの場合、機能を含む)、パフォーマンスの向上、バグの修正が行われます。このようなバージョンはお互いに互換性を保つようにしていますので、コンパイラの変更はほとんどが最適化と警告の追加/削除です。もちろん、実験的な機能はいつでも追加、削除、変更される可能性があります。</target>
        </trans-unit>
        <trans-unit id="36431db4a12e3c14e9de849f36b5befe35ed62b5" translate="yes" xml:space="preserve">
          <source>Incremental releases bring updates in the tooling (often including features), performance improvements and bug fixes. We try to keep such versions compatible with each other, so changes to the compiler are mostly optimizations and warning additions/removals. Pre-stable features may, of course, be added, removed or changed at any time.</source>
          <target state="translated">インクリメンタルリリースでは、ツールの更新 (多くの場合、機能を含む)、パフォーマンスの向上、バグの修正が行われます。このようなバージョンはお互いに互換性を保つようにしているので、コンパイラへの変更はほとんどが最適化と警告の追加/削除です。もちろん、安定化前の機能はいつでも追加、削除、変更される可能性があります。</target>
        </trans-unit>
        <trans-unit id="9c0b336ea67b1169e696bcad497094e1948f51aa" translate="yes" xml:space="preserve">
          <source>Increments and decrements</source>
          <target state="translated">インクリメントとデクリメント</target>
        </trans-unit>
        <trans-unit id="51065cc396f6ec67a2538e872f538ab2d9ab75c9" translate="yes" xml:space="preserve">
          <source>Increments the value by &lt;a href=&quot;add-and-get#kotlin.native.concurrent.AtomicInt%24addAndGet%28kotlin.Int%29%2Fdelta&quot;&gt;delta&lt;/a&gt; and returns the new value.</source>
          <target state="translated">&lt;a href=&quot;add-and-get#kotlin.native.concurrent.AtomicInt%24addAndGet%28kotlin.Int%29%2Fdelta&quot;&gt;デルタ&lt;/a&gt;によって値を増分し、新しい値を返します。</target>
        </trans-unit>
        <trans-unit id="b0f32b37b99e84f7a892589880d018ef9b908ef9" translate="yes" xml:space="preserve">
          <source>Increments the value by &lt;a href=&quot;add-and-get#kotlin.native.concurrent.AtomicInt%24addAndGet(kotlin.Int)/delta&quot;&gt;delta&lt;/a&gt; and returns the new value.</source>
          <target state="translated">値を&lt;a href=&quot;add-and-get#kotlin.native.concurrent.AtomicInt%24addAndGet(kotlin.Int)/delta&quot;&gt;デルタ&lt;/a&gt;単位でインクリメントし、新しい値を返します。</target>
        </trans-unit>
        <trans-unit id="44233843d94836d1fccccf70b3b2b867d9acc067" translate="yes" xml:space="preserve">
          <source>Increments the value by &lt;a href=&quot;add-and-get#kotlin.native.concurrent.AtomicLong%24addAndGet%28kotlin.Long%29%2Fdelta&quot;&gt;delta&lt;/a&gt; and returns the new value.</source>
          <target state="translated">&lt;a href=&quot;add-and-get#kotlin.native.concurrent.AtomicLong%24addAndGet%28kotlin.Long%29%2Fdelta&quot;&gt;デルタ&lt;/a&gt;によって値を増分し、新しい値を返します。</target>
        </trans-unit>
        <trans-unit id="166f962aa69e44913e0b39e6fa68583a02fd3a79" translate="yes" xml:space="preserve">
          <source>Increments the value by &lt;a href=&quot;add-and-get#kotlin.native.concurrent.AtomicLong%24addAndGet(kotlin.Long)/delta&quot;&gt;delta&lt;/a&gt; and returns the new value.</source>
          <target state="translated">値を&lt;a href=&quot;add-and-get#kotlin.native.concurrent.AtomicLong%24addAndGet(kotlin.Long)/delta&quot;&gt;デルタ&lt;/a&gt;単位でインクリメントし、新しい値を返します。</target>
        </trans-unit>
        <trans-unit id="28411949be3415589036a91826011ccfec40fbd4" translate="yes" xml:space="preserve">
          <source>Increments this value.</source>
          <target state="translated">この値を増加させます。</target>
        </trans-unit>
        <trans-unit id="b8fcfd847cda35bcb6945261dd3c4eb8f88f412a" translate="yes" xml:space="preserve">
          <source>Increments value by one.</source>
          <target state="translated">値を1つインクリメントします。</target>
        </trans-unit>
        <trans-unit id="e3d31147233f60ba2779d580d821b70c26574217" translate="yes" xml:space="preserve">
          <source>Indeed, its design was inspired by Reactive Streams and its various implementations. But Flow main goal is to have as simple design as possible, be Kotlin and suspension friendly and respect structured concurrency. Achieving this goal would be impossible without reactive pioneers and their tremendous work. You can read the complete story in &lt;a href=&quot;https://medium.com/@elizarov/reactive-streams-and-kotlin-flows-bfd12772cda4&quot;&gt;Reactive Streams and Kotlin Flows&lt;/a&gt; article.</source>
          <target state="translated">実際、その設計はReactiveStreamsとそのさまざまな実装に触発されました。ただし、Flowの主な目標は、可能な限りシンプルな設計にし、Kotlinとサスペンションに対応し、構造化された同時実行性を尊重することです。この目標を達成することは、反応的な先駆者と彼らの多大な努力なしには不可能です。ストーリー&lt;a href=&quot;https://medium.com/@elizarov/reactive-streams-and-kotlin-flows-bfd12772cda4&quot;&gt;全体&lt;/a&gt;は、ReactiveStreamsとKotlinFlowsの記事で読むことができます。</target>
        </trans-unit>
        <trans-unit id="c2df9b932637fe9d32a0f16da1c11873398f873d" translate="yes" xml:space="preserve">
          <source>Index</source>
          <target state="translated">Index</target>
        </trans-unit>
        <trans-unit id="83f705f84f3e506a637956b9907406ba6fe9f41e" translate="yes" xml:space="preserve">
          <source>IndexOutOfBoundsException</source>
          <target state="translated">IndexOutOfBoundsException</target>
        </trans-unit>
        <trans-unit id="4a12f879063aea0813ebab8015ddf21b727cd7af" translate="yes" xml:space="preserve">
          <source>Indexed access operator</source>
          <target state="translated">インデックス化されたアクセス演算子</target>
        </trans-unit>
        <trans-unit id="d4e1cf8d774b0c0bb9b5921ec7fa833544082d60" translate="yes" xml:space="preserve">
          <source>IndexedValue</source>
          <target state="translated">IndexedValue</target>
        </trans-unit>
        <trans-unit id="2606e49e237c315e21ba9ad3205e46744904acbb" translate="yes" xml:space="preserve">
          <source>Indexing suffix</source>
          <target state="translated">インデックス接尾辞</target>
        </trans-unit>
        <trans-unit id="4ad24986a96806bcf716cdb15281ed398b1a31f5" translate="yes" xml:space="preserve">
          <source>Indicates whether some other object is &quot;equal to&quot; this one. Implementations must fulfil the following requirements:</source>
          <target state="translated">他のオブジェクトがこのオブジェクトと「等しい」かどうかを示す。実装は以下の要件を満たさなければならない。</target>
        </trans-unit>
        <trans-unit id="53f09d01b93a3110068a373094e1fb376a10c3c8" translate="yes" xml:space="preserve">
          <source>Indicates whether the regular expression can find at least one match in the specified &lt;a href=&quot;contains-match-in#kotlin.text.Regex%24containsMatchIn%28kotlin.CharSequence%29%2Finput&quot;&gt;input&lt;/a&gt;.</source>
          <target state="translated">正規表現が指定された&lt;a href=&quot;contains-match-in#kotlin.text.Regex%24containsMatchIn%28kotlin.CharSequence%29%2Finput&quot;&gt;入力&lt;/a&gt;で少なくとも1つの一致を見つけることができるかどうかを示します。</target>
        </trans-unit>
        <trans-unit id="51429e87bd819bb2f3942329861eee4721f512b8" translate="yes" xml:space="preserve">
          <source>Indicates whether the regular expression can find at least one match in the specified &lt;a href=&quot;contains-match-in#kotlin.text.Regex%24containsMatchIn(kotlin.CharSequence)/input&quot;&gt;input&lt;/a&gt;.</source>
          <target state="translated">正規表現が指定された&lt;a href=&quot;contains-match-in#kotlin.text.Regex%24containsMatchIn(kotlin.CharSequence)/input&quot;&gt;入力&lt;/a&gt;で少なくとも1つの一致を見つけることができるかどうかを示します。</target>
        </trans-unit>
        <trans-unit id="cc670204f79af50c97c85084d6a41b77270ab6a4" translate="yes" xml:space="preserve">
          <source>Indicates whether the regular expression matches the entire &lt;a href=&quot;matches#kotlin.text.Regex%24matches%28kotlin.CharSequence%29%2Finput&quot;&gt;input&lt;/a&gt;.</source>
          <target state="translated">正規表現が&lt;a href=&quot;matches#kotlin.text.Regex%24matches%28kotlin.CharSequence%29%2Finput&quot;&gt;入力&lt;/a&gt;全体と一致するかどうかを示します。</target>
        </trans-unit>
        <trans-unit id="b98c0b71834f5e2d5a0d8cf79e50cdeebb2945aa" translate="yes" xml:space="preserve">
          <source>Indicates whether the regular expression matches the entire &lt;a href=&quot;matches#kotlin.text.Regex%24matches(kotlin.CharSequence)/input&quot;&gt;input&lt;/a&gt;.</source>
          <target state="translated">正規表現が&lt;a href=&quot;matches#kotlin.text.Regex%24matches(kotlin.CharSequence)/input&quot;&gt;入力&lt;/a&gt;全体に一致するかどうかを示します。</target>
        </trans-unit>
        <trans-unit id="767a32bb6d83112e90455e54a6dd8a16300ca86c" translate="yes" xml:space="preserve">
          <source>Infix calls for named functions</source>
          <target state="translated">名前付き関数のインフィックス呼び出し</target>
        </trans-unit>
        <trans-unit id="1cea4b28540c3fbdd2e2436ba68910be38a3f387" translate="yes" xml:space="preserve">
          <source>Infix function calls have lower precedence than the arithmetic operators, type casts, and the &lt;code&gt;rangeTo&lt;/code&gt; operator. The following expressions are equivalent:</source>
          <target state="translated">Infix関数呼び出しは、算術演算子、型キャスト、および &lt;code&gt;rangeTo&lt;/code&gt; 演算子よりも優先順位が低くなります。次の式は同等です。</target>
        </trans-unit>
        <trans-unit id="c345bbff4a1e1fc76b2e4ede7fbe52f5de947e6b" translate="yes" xml:space="preserve">
          <source>Infix functions</source>
          <target state="translated">インフィックス機能</target>
        </trans-unit>
        <trans-unit id="19c6abcd2f2f19793afb1f4565bae99cd5d50667" translate="yes" xml:space="preserve">
          <source>Infix notation</source>
          <target state="translated">インフィックス表記法</target>
        </trans-unit>
        <trans-unit id="c5a135f955f6a2349a2d4263f326ff3a2a3304ed" translate="yes" xml:space="preserve">
          <source>Information from explicit casts is used for type inference</source>
          <target state="translated">明示的なキャストからの情報は型推論に利用されます。</target>
        </trans-unit>
        <trans-unit id="fdaddb9ce367c2ca746a97cc24d2e8817a51f27d" translate="yes" xml:space="preserve">
          <source>Inheritance</source>
          <target state="translated">Inheritance</target>
        </trans-unit>
        <trans-unit id="fc3ff49d31fe091e3831cd8bc1f2e6d38992276d" translate="yes" xml:space="preserve">
          <source>Inheritance from Java classes</source>
          <target state="translated">Javaクラスからの継承</target>
        </trans-unit>
        <trans-unit id="060c830dba717926ce4d26ef9693decc297e0680" translate="yes" xml:space="preserve">
          <source>Inheritance that leads to a &lt;code&gt;copy&lt;/code&gt; conflict has become deprecated with a warning in Kotlin 1.2 and will be an error in Kotlin 1.3.</source>
          <target state="translated">&lt;code&gt;copy&lt;/code&gt; 競合につながる継承は、Kotlin 1.2では警告とともに廃止され、Kotlin 1.3ではエラーになります。</target>
        </trans-unit>
        <trans-unit id="fe8f308745a21bdbf9c67ae8f86198813253366c" translate="yes" xml:space="preserve">
          <source>Inherited Functions</source>
          <target state="translated">継承機能</target>
        </trans-unit>
        <trans-unit id="a97b2d009dc11ee2399b0468fc72e941eebbf165" translate="yes" xml:space="preserve">
          <source>Inherited Properties</source>
          <target state="translated">継承されたプロパティ</target>
        </trans-unit>
        <trans-unit id="f54b5bc69098e64d7fae998cd4e9df2d4fa8e7af" translate="yes" xml:space="preserve">
          <source>Inherited built-in functions</source>
          <target state="translated">継承された組み込み機能</target>
        </trans-unit>
        <trans-unit id="af6ed82fe139bda1a895add0ffee5c78ca3dcf12" translate="yes" xml:space="preserve">
          <source>Inheritors</source>
          <target state="translated">Inheritors</target>
        </trans-unit>
        <trans-unit id="68fa16ffd48f366e4fa8d57fea78ff03fcab0191" translate="yes" xml:space="preserve">
          <source>Initialization</source>
          <target state="translated">Initialization</target>
        </trans-unit>
        <trans-unit id="100b184b34b9bc80bfe5761ad8aa4a5db3c27036" translate="yes" xml:space="preserve">
          <source>Initialized with a value of type &lt;code&gt;String&lt;/code&gt; or a primitive type</source>
          <target state="translated">&lt;code&gt;String&lt;/code&gt; 型またはプリミティブ型の値で初期化されました</target>
        </trans-unit>
        <trans-unit id="0c55ba13e2bd9dbfd35641ebe93792c6061e39cd" translate="yes" xml:space="preserve">
          <source>Initializer</source>
          <target state="translated">Initializer</target>
        </trans-unit>
        <trans-unit id="cddbd43ce85bc15d27c1f2848a884d7030458b88" translate="yes" xml:space="preserve">
          <source>Initializer function can be called several times on concurrent access to uninitialized &lt;a href=&quot;../-lazy/index&quot;&gt;Lazy&lt;/a&gt; instance value, but only the first returned value will be used as the value of &lt;a href=&quot;../-lazy/index&quot;&gt;Lazy&lt;/a&gt; instance.</source>
          <target state="translated">初期化関数は、初期化されていないへの同時アクセスに複数回呼び出すことができます&lt;a href=&quot;../-lazy/index&quot;&gt;怠惰な&lt;/a&gt;インスタンス値が、唯一の最初の戻り値は、の値として使用されます&lt;a href=&quot;../-lazy/index&quot;&gt;レイジー&lt;/a&gt;インスタンス。</target>
        </trans-unit>
        <trans-unit id="8de9a4ea59b21de32db609afcfc607895faed0de" translate="yes" xml:space="preserve">
          <source>Initializer functions for lists</source>
          <target state="translated">リストの初期化関数</target>
        </trans-unit>
        <trans-unit id="db5e65d8fc7dddd98f6860c2416bcbcc90ec0fba" translate="yes" xml:space="preserve">
          <source>Initializers</source>
          <target state="translated">Initializers</target>
        </trans-unit>
        <trans-unit id="96e412fcc42808e35495dbc64ebcde5c69c261de" translate="yes" xml:space="preserve">
          <source>Initializes Kotlin runtime for the current thread, if not inited already.</source>
          <target state="translated">まだ起動していない場合は、現在のスレッドの Kotlin ランタイムを初期化します。</target>
        </trans-unit>
        <trans-unit id="4bf76bf156ef56b953245fb5da4ea73be4ae4d91" translate="yes" xml:space="preserve">
          <source>Initiates a call to this deep recursive function, forming a root of the call tree.</source>
          <target state="translated">この深い再帰関数の呼び出しを開始し、呼び出しツリーのルートを形成します。</target>
        </trans-unit>
        <trans-unit id="be787dbbf62b5076f4a13439769f15509c2967ea" translate="yes" xml:space="preserve">
          <source>Inlinable lambdas can only be called inside the inline functions or passed as inlinable arguments, but &lt;code&gt;noinline&lt;/code&gt; ones can be manipulated in any way we like: stored in fields, passed around etc.</source>
          <target state="translated">INLINABLEラムダは、インライン関数内と呼ばれるかINLINABLE引数として渡すことができるが &lt;code&gt;noinline&lt;/code&gt; ものは、私たちのような任意の方法で操作することができます。周りに渡され、フィールドに保存されているなど</target>
        </trans-unit>
        <trans-unit id="b60019f47df04ae92897fa912c6748a6013313fa" translate="yes" xml:space="preserve">
          <source>Inline Functions</source>
          <target state="translated">インライン関数</target>
        </trans-unit>
        <trans-unit id="77dc1cce985d17f15f3bb54896d9ab82a2428c34" translate="yes" xml:space="preserve">
          <source>Inline JavaScript</source>
          <target state="translated">インライン JavaScript</target>
        </trans-unit>
        <trans-unit id="62d048ab15fe71589a192aa32dfde8cfed8f778a" translate="yes" xml:space="preserve">
          <source>Inline Markup</source>
          <target state="translated">インラインマークアップ</target>
        </trans-unit>
        <trans-unit id="5d360c4149ca0224f961067c92c26613a7104175" translate="yes" xml:space="preserve">
          <source>Inline classes</source>
          <target state="translated">インラインクラス</target>
        </trans-unit>
        <trans-unit id="9286e6770b0362425ca42b0e3ebc568ac630fc5b" translate="yes" xml:space="preserve">
          <source>Inline classes are allowed to inherit from interfaces:</source>
          <target state="translated">インラインクラスはインターフェイスを継承することができます。</target>
        </trans-unit>
        <trans-unit id="4c5881ab063c0ce817cf6f52ab599309c2d3110f" translate="yes" xml:space="preserve">
          <source>Inline classes are available only since Kotlin 1.3 and currently are &lt;em&gt;experimental&lt;/em&gt;. See details &lt;a href=&quot;#experimental-status-of-inline-classes&quot;&gt;below&lt;/a&gt;</source>
          <target state="translated">インラインクラスは、Kotlin 1.3以降でのみ使用でき、現在&lt;em&gt;実験&lt;/em&gt;段階です。&lt;a href=&quot;#experimental-status-of-inline-classes&quot;&gt;以下の&lt;/a&gt;詳細をご覧ください</target>
        </trans-unit>
        <trans-unit id="f253e2ca96472e7c3372c8639328c1d3867dc3b6" translate="yes" xml:space="preserve">
          <source>Inline classes are available only since Kotlin 1.3 and currently are &lt;em&gt;experimental&lt;/em&gt;. See details in the &lt;a href=&quot;inline-classes#experimental-status-of-inline-classes&quot;&gt;reference&lt;/a&gt;.</source>
          <target state="translated">インラインクラスは、Kotlin 1.3以降でのみ使用でき、現在&lt;em&gt;実験&lt;/em&gt;段階です。詳細は&lt;a href=&quot;inline-classes#experimental-status-of-inline-classes&quot;&gt;リファレンスを&lt;/a&gt;ご覧ください。</target>
        </trans-unit>
        <trans-unit id="1fe109e560117398094720f2c3a634950943781d" translate="yes" xml:space="preserve">
          <source>Inline classes are available only since Kotlin 1.3 and currently are in &lt;a href=&quot;evolution/components-stability&quot;&gt;Alpha&lt;/a&gt;. See details in the &lt;a href=&quot;inline-classes#alpha-status-of-inline-classes&quot;&gt;reference&lt;/a&gt;.</source>
          <target state="translated">インラインクラスはKotlin1.3以降でのみ利用可能で、現在は&lt;a href=&quot;evolution/components-stability&quot;&gt;Alpha&lt;/a&gt;です。詳細については、&lt;a href=&quot;inline-classes#alpha-status-of-inline-classes&quot;&gt;リファレンス&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="6ad02ddc63db8ea1a5da350db44423e72064462a" translate="yes" xml:space="preserve">
          <source>Inline classes are available only since Kotlin 1.3 and currently in &lt;a href=&quot;evolution/components-stability&quot;&gt;Alpha&lt;/a&gt;. See details &lt;a href=&quot;#alpha-status-of-inline-classes&quot;&gt;below&lt;/a&gt;</source>
          <target state="translated">インラインクラスは、Kotlin 1.3以降、現在&lt;a href=&quot;evolution/components-stability&quot;&gt;Alphaで&lt;/a&gt;のみ使用できます。&lt;a href=&quot;#alpha-status-of-inline-classes&quot;&gt;以下の&lt;/a&gt;詳細を参照してください</target>
        </trans-unit>
        <trans-unit id="a7a2cb12c8331fe8180ea13004fae9e89ef3e1fd" translate="yes" xml:space="preserve">
          <source>Inline classes support some functionality of regular classes. In particular, they are allowed to declare properties and functions:</source>
          <target state="translated">インライン・クラスは、通常のクラスのいくつかの機能をサポートしています。特に、プロパティや関数を宣言することができます。</target>
        </trans-unit>
        <trans-unit id="6c7769b31582b2d304756a0e1ee20904b47b72a0" translate="yes" xml:space="preserve">
          <source>Inline classes vs type aliases</source>
          <target state="translated">インラインクラスと型のエイリアス</target>
        </trans-unit>
        <trans-unit id="126b7ff7e58c488c8dbbe2c35dcf311f885d0926" translate="yes" xml:space="preserve">
          <source>Inline extension functions that were called on a null value of a platform type did not check the receiver for null and would thus allow null to escape into the other code. Kotlin 1.2 forces this check at the call sites, throwing an exception if the receiver is null.</source>
          <target state="translated">プラットフォーム型のNULL値で呼び出されるインライン拡張関数は、レシーバーがNULLであるかどうかをチェックしないため、NULLが他のコードに逃げてしまうことがありました。Kotlin 1.2 では、コールサイトでこのチェックを強制的に行い、レシーバーが null の場合は例外をスローします。</target>
        </trans-unit>
        <trans-unit id="5c804513cadec43c33b180af13b2e9aec456a962" translate="yes" xml:space="preserve">
          <source>Inline functions</source>
          <target state="translated">インライン関数</target>
        </trans-unit>
        <trans-unit id="9d0d1200e09d5fde96bd026c2e6ca0b2d04d5ad5" translate="yes" xml:space="preserve">
          <source>Inline functions are explained &lt;a href=&quot;inline-functions&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;inline-functions&quot;&gt;ここで&lt;/a&gt;はインライン関数について説明します。</target>
        </trans-unit>
        <trans-unit id="aa8db13612a09f046bbacee8122bb577b38d70fa" translate="yes" xml:space="preserve">
          <source>Inline functions are now allowed to have default values for their inlined functional parameters:</source>
          <target state="translated">インライン関数は、そのインライン関数のパラメータにデフォルト値を持つことができるようになりました。</target>
        </trans-unit>
        <trans-unit id="d6c978967701dd3225fcc54de37cf91805dd0b8d" translate="yes" xml:space="preserve">
          <source>Inline functions with &lt;a href=&quot;inline-functions#reified-type-parameters&quot;&gt;reified type parameters&lt;/a&gt; have their actual type arguments inlined at each call site, which enables &lt;code&gt;arg is T&lt;/code&gt; checks for the type parameters, but if &lt;code&gt;arg&lt;/code&gt; is an instance of a generic type itself, &lt;em&gt;its&lt;/em&gt; type arguments are still erased. Example:</source>
          <target state="translated">&lt;a href=&quot;inline-functions#reified-type-parameters&quot;&gt;型パラメーター&lt;/a&gt;を具体化したインライン関数は、実際の型引数が各呼び出しサイトでインライン化されます。これにより、 &lt;code&gt;arg is T&lt;/code&gt; が型パラメーターをチェックできるようになりますが、 &lt;code&gt;arg&lt;/code&gt; がジェネリック型自体のインスタンスである場合&lt;em&gt;、&lt;/em&gt;型引数は消去されます。例：</target>
        </trans-unit>
        <trans-unit id="dad40d691cb152e5ea04161c10815db00953ebbb" translate="yes" xml:space="preserve">
          <source>Inline functions with default functional parameters</source>
          <target state="translated">デフォルトの機能パラメータを持つインライン関数</target>
        </trans-unit>
        <trans-unit id="e60dd1451a60d33b2eca72439470d0150cb5cb84" translate="yes" xml:space="preserve">
          <source>Inline properties (since 1.1)</source>
          <target state="translated">インラインプロパティ(1.1以降</target>
        </trans-unit>
        <trans-unit id="6fec8c0d06ca4be7ff0c4bc9fa753ee420aa8bbc" translate="yes" xml:space="preserve">
          <source>Inline property accessors</source>
          <target state="translated">インラインプロパティアクセサ</target>
        </trans-unit>
        <trans-unit id="01185d7fc605bc19fbe95771073571a841e3e817" translate="yes" xml:space="preserve">
          <source>Inlining may cause the generated code to grow; however, if we do it in a reasonable way (i.e. avoiding inlining large functions), it will pay off in performance, especially at &quot;megamorphic&quot; call-sites inside loops.</source>
          <target state="translated">インライン化は生成されたコードを大きくする原因になるかもしれませんが、合理的な方法で行えば(大きな関数のインライン化を避けるなど)、特にループ内の「メガモルフィック」なコールサイトでは、パフォーマンスの面で報われます。</target>
        </trans-unit>
        <trans-unit id="aacf14c4398ec9fe537fae7e92753856f34743cb" translate="yes" xml:space="preserve">
          <source>Inner classes</source>
          <target state="translated">インナークラス</target>
        </trans-unit>
        <trans-unit id="bc3fa717af37b9f1e13149ace0b8f86497367e3c" translate="yes" xml:space="preserve">
          <source>Inner classes inheriting &lt;code&gt;Throwable&lt;/code&gt; that capture generic parameters from the outer class</source>
          <target state="translated">外部クラスからジェネリックパラメーターをキャプチャする &lt;code&gt;Throwable&lt;/code&gt; を継承する内部クラス</target>
        </trans-unit>
        <trans-unit id="258becf2f7c7396759bd76072890548fa224b9a4" translate="yes" xml:space="preserve">
          <source>Inner classes of generic types that inherit from &lt;code&gt;Throwable&lt;/code&gt; could violate type-safety in a throw-catch scenario and thus have been deprecated, with a warning in Kotlin 1.2 and an error in Kotlin 1.3.</source>
          <target state="translated">&lt;code&gt;Throwable&lt;/code&gt; から継承するジェネリック型の内部クラスは、throw-catchシナリオの型安全性に違反する可能性があるため、Kotlin 1.2の警告とKotlin 1.3のエラーで非推奨になりました。</target>
        </trans-unit>
        <trans-unit id="b14a7c09e5913aa9efafcb8d3f6e59361da51506" translate="yes" xml:space="preserve">
          <source>InputEventInit</source>
          <target state="translated">InputEventInit</target>
        </trans-unit>
        <trans-unit id="081e0fb72f26260fc891fc2cb6cbf71cf9e0d97f" translate="yes" xml:space="preserve">
          <source>Inserts all of the elements of the specified collection &lt;a href=&quot;../-mutable-list/add-all#kotlin.collections.MutableList%24addAll%28kotlin.Int%2C+kotlin.collections.Collection%28%28kotlin.collections.MutableList.E%29%29%29%2Felements&quot;&gt;elements&lt;/a&gt; into this list at the specified &lt;a href=&quot;../-mutable-list/add-all#kotlin.collections.MutableList%24addAll%28kotlin.Int%2C+kotlin.collections.Collection%28%28kotlin.collections.MutableList.E%29%29%29%2Findex&quot;&gt;index&lt;/a&gt;.</source>
          <target state="translated">指定されたコレクション&lt;a href=&quot;../-mutable-list/add-all#kotlin.collections.MutableList%24addAll%28kotlin.Int%2C+kotlin.collections.Collection%28%28kotlin.collections.MutableList.E%29%29%29%2Felements&quot;&gt;要素の&lt;/a&gt;すべての要素を、このリストの指定された&lt;a href=&quot;../-mutable-list/add-all#kotlin.collections.MutableList%24addAll%28kotlin.Int%2C+kotlin.collections.Collection%28%28kotlin.collections.MutableList.E%29%29%29%2Findex&quot;&gt;インデックスに&lt;/a&gt;挿入します。</target>
        </trans-unit>
        <trans-unit id="005fc2603487998262e6a4431116600f620b75a0" translate="yes" xml:space="preserve">
          <source>Inserts all of the elements of the specified collection &lt;a href=&quot;../-mutable-list/add-all#kotlin.collections.MutableList%24addAll(kotlin.Int,%20kotlin.collections.Collection((kotlin.collections.MutableList.E)))/elements&quot;&gt;elements&lt;/a&gt; into this list at the specified &lt;a href=&quot;../-mutable-list/add-all#kotlin.collections.MutableList%24addAll(kotlin.Int,%20kotlin.collections.Collection((kotlin.collections.MutableList.E)))/index&quot;&gt;index&lt;/a&gt;.</source>
          <target state="translated">指定されたコレクション&lt;a href=&quot;../-mutable-list/add-all#kotlin.collections.MutableList%24addAll(kotlin.Int,%20kotlin.collections.Collection((kotlin.collections.MutableList.E)))/elements&quot;&gt;要素の&lt;/a&gt;すべての要素を、このリストの指定された&lt;a href=&quot;../-mutable-list/add-all#kotlin.collections.MutableList%24addAll(kotlin.Int,%20kotlin.collections.Collection((kotlin.collections.MutableList.E)))/index&quot;&gt;インデックスに&lt;/a&gt;挿入します。</target>
        </trans-unit>
        <trans-unit id="887d8e7112f2b5499df8e54becfa68d97d70bd00" translate="yes" xml:space="preserve">
          <source>Inserts all of the elements of the specified collection &lt;a href=&quot;add-all#kotlin.collections.MutableList%24addAll%28kotlin.Int%2C+kotlin.collections.Collection%28%28kotlin.collections.MutableList.E%29%29%29%2Felements&quot;&gt;elements&lt;/a&gt; into this list at the specified &lt;a href=&quot;add-all#kotlin.collections.MutableList%24addAll%28kotlin.Int%2C+kotlin.collections.Collection%28%28kotlin.collections.MutableList.E%29%29%29%2Findex&quot;&gt;index&lt;/a&gt;.</source>
          <target state="translated">指定されたコレクション&lt;a href=&quot;add-all#kotlin.collections.MutableList%24addAll%28kotlin.Int%2C+kotlin.collections.Collection%28%28kotlin.collections.MutableList.E%29%29%29%2Felements&quot;&gt;要素の&lt;/a&gt;すべての要素を、このリストの指定された&lt;a href=&quot;add-all#kotlin.collections.MutableList%24addAll%28kotlin.Int%2C+kotlin.collections.Collection%28%28kotlin.collections.MutableList.E%29%29%29%2Findex&quot;&gt;インデックスに&lt;/a&gt;挿入します。</target>
        </trans-unit>
        <trans-unit id="602fbcd913879c3c9b700203739e32c4a9b2050d" translate="yes" xml:space="preserve">
          <source>Inserts all of the elements of the specified collection &lt;a href=&quot;add-all#kotlin.collections.MutableList%24addAll(kotlin.Int,%20kotlin.collections.Collection((kotlin.collections.MutableList.E)))/elements&quot;&gt;elements&lt;/a&gt; into this list at the specified &lt;a href=&quot;add-all#kotlin.collections.MutableList%24addAll(kotlin.Int,%20kotlin.collections.Collection((kotlin.collections.MutableList.E)))/index&quot;&gt;index&lt;/a&gt;.</source>
          <target state="translated">指定されたコレクション&lt;a href=&quot;add-all#kotlin.collections.MutableList%24addAll(kotlin.Int,%20kotlin.collections.Collection((kotlin.collections.MutableList.E)))/elements&quot;&gt;要素の&lt;/a&gt;すべての要素を、このリストの指定された&lt;a href=&quot;add-all#kotlin.collections.MutableList%24addAll(kotlin.Int,%20kotlin.collections.Collection((kotlin.collections.MutableList.E)))/index&quot;&gt;インデックスに&lt;/a&gt;挿入します。</target>
        </trans-unit>
        <trans-unit id="d0c7a2de4f7654463ee73faa30f98d50a3b73e7e" translate="yes" xml:space="preserve">
          <source>Inserts an element into the list at the specified &lt;a href=&quot;../-mutable-list/add#kotlin.collections.MutableList%24add%28kotlin.Int%2C+kotlin.collections.MutableList.E%29%2Findex&quot;&gt;index&lt;/a&gt;.</source>
          <target state="translated">リストの指定された&lt;a href=&quot;../-mutable-list/add#kotlin.collections.MutableList%24add%28kotlin.Int%2C+kotlin.collections.MutableList.E%29%2Findex&quot;&gt;インデックスに&lt;/a&gt;要素を挿入します。</target>
        </trans-unit>
        <trans-unit id="043751f897f4eb9dc49253608d3dad5a3c113e89" translate="yes" xml:space="preserve">
          <source>Inserts an element into the list at the specified &lt;a href=&quot;../-mutable-list/add#kotlin.collections.MutableList%24add(kotlin.Int,%20kotlin.collections.MutableList.E)/index&quot;&gt;index&lt;/a&gt;.</source>
          <target state="translated">指定された&lt;a href=&quot;../-mutable-list/add#kotlin.collections.MutableList%24add(kotlin.Int,%20kotlin.collections.MutableList.E)/index&quot;&gt;インデックスで&lt;/a&gt;リストに要素を挿入します。</target>
        </trans-unit>
        <trans-unit id="f6b6ae35f6d9d56e894884fb222d27eda900dc09" translate="yes" xml:space="preserve">
          <source>Inserts an element into the list at the specified &lt;a href=&quot;add#kotlin.collections.AbstractMutableList%24add%28kotlin.Int%2C+kotlin.collections.AbstractMutableList.E%29%2Findex&quot;&gt;index&lt;/a&gt;.</source>
          <target state="translated">リストの指定された&lt;a href=&quot;add#kotlin.collections.AbstractMutableList%24add%28kotlin.Int%2C+kotlin.collections.AbstractMutableList.E%29%2Findex&quot;&gt;インデックスに&lt;/a&gt;要素を挿入します。</target>
        </trans-unit>
        <trans-unit id="dc5d1b50a39baeed86e36617a548438e3f127155" translate="yes" xml:space="preserve">
          <source>Inserts an element into the list at the specified &lt;a href=&quot;add#kotlin.collections.AbstractMutableList%24add(kotlin.Int,%20kotlin.collections.AbstractMutableList.E)/index&quot;&gt;index&lt;/a&gt;.</source>
          <target state="translated">指定された&lt;a href=&quot;add#kotlin.collections.AbstractMutableList%24add(kotlin.Int,%20kotlin.collections.AbstractMutableList.E)/index&quot;&gt;インデックスで&lt;/a&gt;リストに要素を挿入します。</target>
        </trans-unit>
        <trans-unit id="6c1226de8bd8dc851fb3874b9c31e306f3fa56c5" translate="yes" xml:space="preserve">
          <source>Inserts an element into the list at the specified &lt;a href=&quot;add#kotlin.collections.MutableList%24add%28kotlin.Int%2C+kotlin.collections.MutableList.E%29%2Findex&quot;&gt;index&lt;/a&gt;.</source>
          <target state="translated">リストの指定された&lt;a href=&quot;add#kotlin.collections.MutableList%24add%28kotlin.Int%2C+kotlin.collections.MutableList.E%29%2Findex&quot;&gt;インデックスに&lt;/a&gt;要素を挿入します。</target>
        </trans-unit>
        <trans-unit id="8e37de1820797a87c23300e79e4b0ed919d09e2a" translate="yes" xml:space="preserve">
          <source>Inserts an element into the list at the specified &lt;a href=&quot;add#kotlin.collections.MutableList%24add(kotlin.Int,%20kotlin.collections.MutableList.E)/index&quot;&gt;index&lt;/a&gt;.</source>
          <target state="translated">指定された&lt;a href=&quot;add#kotlin.collections.MutableList%24add(kotlin.Int,%20kotlin.collections.MutableList.E)/index&quot;&gt;インデックスで&lt;/a&gt;リストに要素を挿入します。</target>
        </trans-unit>
        <trans-unit id="27480ec1869e9733f33a48ab29f659fcb2a460a3" translate="yes" xml:space="preserve">
          <source>Inserts characters in a subarray of the specified character array &lt;a href=&quot;insert-range#kotlin.text%24insertRange(java.lang.StringBuilder,%20kotlin.Int,%20kotlin.CharArray,%20kotlin.Int,%20kotlin.Int)/value&quot;&gt;value&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert-range#kotlin.text%24insertRange(java.lang.StringBuilder,%20kotlin.Int,%20kotlin.CharArray,%20kotlin.Int,%20kotlin.Int)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</source>
          <target state="translated">指定された文字配列&lt;a href=&quot;insert-range#kotlin.text%24insertRange(java.lang.StringBuilder,%20kotlin.Int,%20kotlin.CharArray,%20kotlin.Int,%20kotlin.Int)/value&quot;&gt;値の&lt;/a&gt;サブ配列内の文字を、指定された&lt;a href=&quot;insert-range#kotlin.text%24insertRange(java.lang.StringBuilder,%20kotlin.Int,%20kotlin.CharArray,%20kotlin.Int,%20kotlin.Int)/index&quot;&gt;インデックス&lt;/a&gt;でこの文字列ビルダーに挿入し、このインスタンスを返します。</target>
        </trans-unit>
        <trans-unit id="0751e96b7b08da95e20ff3bc7df0567c20077897" translate="yes" xml:space="preserve">
          <source>Inserts characters in a subarray of the specified character array &lt;a href=&quot;insert-range#kotlin.text%24insertRange(kotlin.text.StringBuilder,%20kotlin.Int,%20kotlin.CharArray,%20kotlin.Int,%20kotlin.Int)/value&quot;&gt;value&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert-range#kotlin.text%24insertRange(kotlin.text.StringBuilder,%20kotlin.Int,%20kotlin.CharArray,%20kotlin.Int,%20kotlin.Int)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</source>
          <target state="translated">指定された文字配列&lt;a href=&quot;insert-range#kotlin.text%24insertRange(kotlin.text.StringBuilder,%20kotlin.Int,%20kotlin.CharArray,%20kotlin.Int,%20kotlin.Int)/value&quot;&gt;値の&lt;/a&gt;サブ配列内の文字を、指定された&lt;a href=&quot;insert-range#kotlin.text%24insertRange(kotlin.text.StringBuilder,%20kotlin.Int,%20kotlin.CharArray,%20kotlin.Int,%20kotlin.Int)/index&quot;&gt;インデックス&lt;/a&gt;でこの文字列ビルダーに挿入し、このインスタンスを返します。</target>
        </trans-unit>
        <trans-unit id="3e04a0c39fa9e9ba6f8f7b53f66419ea35f91587" translate="yes" xml:space="preserve">
          <source>Inserts characters in a subarray of the specified character array &lt;a href=&quot;insert-range#kotlin.text.StringBuilder%24insertRange(kotlin.Int,%20kotlin.CharArray,%20kotlin.Int,%20kotlin.Int)/value&quot;&gt;value&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert-range#kotlin.text.StringBuilder%24insertRange(kotlin.Int,%20kotlin.CharArray,%20kotlin.Int,%20kotlin.Int)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</source>
          <target state="translated">指定された文字配列&lt;a href=&quot;insert-range#kotlin.text.StringBuilder%24insertRange(kotlin.Int,%20kotlin.CharArray,%20kotlin.Int,%20kotlin.Int)/value&quot;&gt;値の&lt;/a&gt;サブ配列内の文字を、指定された&lt;a href=&quot;insert-range#kotlin.text.StringBuilder%24insertRange(kotlin.Int,%20kotlin.CharArray,%20kotlin.Int,%20kotlin.Int)/index&quot;&gt;インデックス&lt;/a&gt;でこの文字列ビルダーに挿入し、このインスタンスを返します。</target>
        </trans-unit>
        <trans-unit id="990caaef55fa9369abe10fe21e08b659ee5241e9" translate="yes" xml:space="preserve">
          <source>Inserts characters in a subsequence of the specified character sequence &lt;a href=&quot;../insert#kotlin.text%24insert(kotlin.text.StringBuilder,%20kotlin.Int,%20kotlin.CharSequence?,%20kotlin.Int,%20kotlin.Int)/csq&quot;&gt;csq&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;../insert#kotlin.text%24insert(kotlin.text.StringBuilder,%20kotlin.Int,%20kotlin.CharSequence?,%20kotlin.Int,%20kotlin.Int)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</source>
          <target state="translated">指定された文字シーケンス&lt;a href=&quot;../insert#kotlin.text%24insert(kotlin.text.StringBuilder,%20kotlin.Int,%20kotlin.CharSequence?,%20kotlin.Int,%20kotlin.Int)/csq&quot;&gt;csqのサブ&lt;/a&gt;シーケンス内の文字を、指定された&lt;a href=&quot;../insert#kotlin.text%24insert(kotlin.text.StringBuilder,%20kotlin.Int,%20kotlin.CharSequence?,%20kotlin.Int,%20kotlin.Int)/index&quot;&gt;インデックス&lt;/a&gt;でこの文字列ビルダーに挿入し、このインスタンスを返します。</target>
        </trans-unit>
        <trans-unit id="56381b6576df78ab7498f4c21ed74ffb38fce356" translate="yes" xml:space="preserve">
          <source>Inserts characters in a subsequence of the specified character sequence &lt;a href=&quot;insert#kotlin.text%24insert(kotlin.text.StringBuilder,%20kotlin.Int,%20kotlin.CharSequence?,%20kotlin.Int,%20kotlin.Int)/csq&quot;&gt;csq&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert#kotlin.text%24insert(kotlin.text.StringBuilder,%20kotlin.Int,%20kotlin.CharSequence?,%20kotlin.Int,%20kotlin.Int)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</source>
          <target state="translated">指定された文字シーケンス&lt;a href=&quot;insert#kotlin.text%24insert(kotlin.text.StringBuilder,%20kotlin.Int,%20kotlin.CharSequence?,%20kotlin.Int,%20kotlin.Int)/csq&quot;&gt;csqのサブ&lt;/a&gt;シーケンス内の文字を、指定された&lt;a href=&quot;insert#kotlin.text%24insert(kotlin.text.StringBuilder,%20kotlin.Int,%20kotlin.CharSequence?,%20kotlin.Int,%20kotlin.Int)/index&quot;&gt;インデックス&lt;/a&gt;でこの文字列ビルダーに挿入し、このインスタンスを返します。</target>
        </trans-unit>
        <trans-unit id="13ca00255e68344adaf9baf7d5fd54a64418b339" translate="yes" xml:space="preserve">
          <source>Inserts characters in a subsequence of the specified character sequence &lt;a href=&quot;insert-range#kotlin.text%24insertRange(java.lang.StringBuilder,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.Int)/value&quot;&gt;value&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert-range#kotlin.text%24insertRange(java.lang.StringBuilder,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.Int)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</source>
          <target state="translated">指定された文字シーケンス&lt;a href=&quot;insert-range#kotlin.text%24insertRange(java.lang.StringBuilder,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.Int)/value&quot;&gt;値の&lt;/a&gt;サブシーケンス内の文字を、指定された&lt;a href=&quot;insert-range#kotlin.text%24insertRange(java.lang.StringBuilder,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.Int)/index&quot;&gt;インデックス&lt;/a&gt;でこの文字列ビルダーに挿入し、このインスタンスを返します。</target>
        </trans-unit>
        <trans-unit id="f16ec6bfc81f5c607f3cb9b48f5e7a410c32c025" translate="yes" xml:space="preserve">
          <source>Inserts characters in a subsequence of the specified character sequence &lt;a href=&quot;insert-range#kotlin.text%24insertRange(kotlin.text.StringBuilder,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.Int)/value&quot;&gt;value&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert-range#kotlin.text%24insertRange(kotlin.text.StringBuilder,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.Int)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</source>
          <target state="translated">指定された文字シーケンス&lt;a href=&quot;insert-range#kotlin.text%24insertRange(kotlin.text.StringBuilder,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.Int)/value&quot;&gt;値の&lt;/a&gt;サブシーケンス内の文字を、指定された&lt;a href=&quot;insert-range#kotlin.text%24insertRange(kotlin.text.StringBuilder,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.Int)/index&quot;&gt;インデックス&lt;/a&gt;でこの文字列ビルダーに挿入し、このインスタンスを返します。</target>
        </trans-unit>
        <trans-unit id="b15a142e3f1c0e94cad906174d3311d39fef798f" translate="yes" xml:space="preserve">
          <source>Inserts characters in a subsequence of the specified character sequence &lt;a href=&quot;insert-range#kotlin.text.StringBuilder%24insertRange(kotlin.Int,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.Int)/value&quot;&gt;value&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert-range#kotlin.text.StringBuilder%24insertRange(kotlin.Int,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.Int)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</source>
          <target state="translated">指定された文字シーケンス&lt;a href=&quot;insert-range#kotlin.text.StringBuilder%24insertRange(kotlin.Int,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.Int)/value&quot;&gt;値の&lt;/a&gt;サブシーケンス内の文字を、指定された&lt;a href=&quot;insert-range#kotlin.text.StringBuilder%24insertRange(kotlin.Int,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.Int)/index&quot;&gt;インデックス&lt;/a&gt;でこの文字列ビルダーに挿入し、このインスタンスを返します。</target>
        </trans-unit>
        <trans-unit id="98e8ddbbdefb8f6d9c8e1f1a1ec159981fb75050" translate="yes" xml:space="preserve">
          <source>Inserts characters in the specified character array &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.CharArray)/value&quot;&gt;value&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.CharArray)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</source>
          <target state="translated">指定された文字配列&lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.CharArray)/value&quot;&gt;値の&lt;/a&gt;文字を、指定された&lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.CharArray)/index&quot;&gt;インデックス&lt;/a&gt;でこの文字列ビルダーに挿入し、このインスタンスを返します。</target>
        </trans-unit>
        <trans-unit id="8bd299382c17ed7be741a94000ce27e3cb569545" translate="yes" xml:space="preserve">
          <source>Inserts characters in the specified character sequence &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.CharSequence?)/value&quot;&gt;value&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.CharSequence?)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</source>
          <target state="translated">指定された文字シーケンス&lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.CharSequence?)/value&quot;&gt;値の&lt;/a&gt;文字を、指定された&lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.CharSequence?)/index&quot;&gt;インデックス&lt;/a&gt;でこの文字列ビルダーに挿入し、このインスタンスを返します。</target>
        </trans-unit>
        <trans-unit id="c10488d941ff5f739e50f3ed8d100fc28145f09c" translate="yes" xml:space="preserve">
          <source>Inserts the specified character &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.Char)/value&quot;&gt;value&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.Char)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</source>
          <target state="translated">指定された文字&lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.Char)/value&quot;&gt;値&lt;/a&gt;をこの文字列ビルダーの指定された&lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.Char)/index&quot;&gt;インデックスに&lt;/a&gt;挿入し、このインスタンスを返します。</target>
        </trans-unit>
        <trans-unit id="ad678e17f874b23d4231a5cb1e5b3edfa0684922" translate="yes" xml:space="preserve">
          <source>Inserts the string &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.String?)/value&quot;&gt;value&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.String?)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</source>
          <target state="translated">指定された&lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.String?)/index&quot;&gt;インデックス&lt;/a&gt;でこの文字列ビルダーに文字列&lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.String?)/value&quot;&gt;値&lt;/a&gt;を挿入し、このインスタンスを返します。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
