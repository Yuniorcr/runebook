<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="kotlin">
    <body>
      <group id="kotlin">
        <trans-unit id="bc555107bc3ab29b699e3ac57e1fb75bce2155ce" translate="yes" xml:space="preserve">
          <source>Kotlin/JS is also compatible with the most common module systems: UMD, CommonJS, and AMD. Being able to &lt;a href=&quot;../tutorials/javascript/working-with-modules/working-with-modules&quot;&gt;produce and consume modules&lt;/a&gt; means that you can interact with the JavaScript ecosystem in a structured manner.</source>
          <target state="translated">Kotlin / JSは、最も一般的なモジュールシステムであるUMD、CommonJS、AMDとも互換性があります。&lt;a href=&quot;../tutorials/javascript/working-with-modules/working-with-modules&quot;&gt;モジュール&lt;/a&gt;を生成および消費できるということは、構造化された方法でJavaScriptエコシステムと対話できることを意味します。</target>
        </trans-unit>
        <trans-unit id="73e221948b2977f48bf5440d552a61a97802b3f2" translate="yes" xml:space="preserve">
          <source>Kotlin/JS provides the ability to transpile your Kotlin code, the Kotlin standard library, and any compatible dependencies to JavaScript. The current implementation of Kotlin/JS targets &lt;a href=&quot;https://www.ecma-international.org/ecma-262/5.1/&quot;&gt;ES5&lt;/a&gt;.</source>
          <target state="translated">Kotlin / JSは、Kotlinコード、Kotlin標準ライブラリ、およびJavaScriptとの互換性のある依存関係をトランスパイルする機能を提供します。Kotlin / JSの現在の実装は、&lt;a href=&quot;https://www.ecma-international.org/ecma-262/5.1/&quot;&gt;ES5を&lt;/a&gt;対象としています。</target>
        </trans-unit>
        <trans-unit id="e161bf22c4b5c5951be23fef6f0ff257426ebe17" translate="yes" xml:space="preserve">
          <source>Kotlin/JS, Today and Tomorrow</source>
          <target state="translated">Kotlin/JS、今日と明日</target>
        </trans-unit>
        <trans-unit id="44cbff389316ebfe00ceb67daf169189d44ae420" translate="yes" xml:space="preserve">
          <source>Kotlin/JVM</source>
          <target state="translated">Kotlin/JVM</target>
        </trans-unit>
        <trans-unit id="629649c3a6fde50e4105c70afe705d63afa55224" translate="yes" xml:space="preserve">
          <source>Kotlin/JVM (IR-based)</source>
          <target state="translated">Kotlin/JVM (IRベース)</target>
        </trans-unit>
        <trans-unit id="59ce5e2461e87e30bf83a0eb1faafe214139a6af" translate="yes" xml:space="preserve">
          <source>Kotlin/Native</source>
          <target state="translated">Kotlin/Native</target>
        </trans-unit>
        <trans-unit id="ba24fc19201f933494d7dd5a5c0dfc8e159aaf9b" translate="yes" xml:space="preserve">
          <source>Kotlin/Native &lt;a href=&quot;native/platform_libs&quot;&gt;libraries&lt;/a&gt; help to share Kotlin code between projects. POSIX, gzip, OpenGL, Metal, Foundation, and many other popular libraries and Apple frameworks are pre-imported and included as Kotlin/Native libraries into the compiler package.</source>
          <target state="translated">Kotlin /ネイティブ&lt;a href=&quot;native/platform_libs&quot;&gt;ライブラリは&lt;/a&gt;、プロジェクト間でKotlinコードを共有するのに役立ちます。POSIX、gzip、OpenGL、Metal、Foundation、およびその他の多くの一般的なライブラリとAppleフレームワークが事前にインポートされ、Kotlin / Nativeライブラリとしてコンパイラパッケージに含まれています。</target>
        </trans-unit>
        <trans-unit id="87f61b22867c181628a95e8886f5b445415a504e" translate="yes" xml:space="preserve">
          <source>Kotlin/Native Gradle plugin</source>
          <target state="translated">Kotlin/Native Gradle プラグイン</target>
        </trans-unit>
        <trans-unit id="c83dbff85c7c1cfb09790c18b941a770c8cb6d04" translate="yes" xml:space="preserve">
          <source>Kotlin/Native Runtime</source>
          <target state="translated">Kotlin/ネイティブランタイム</target>
        </trans-unit>
        <trans-unit id="df149e18227e20b3ab9482b52698611b0a6fc13c" translate="yes" xml:space="preserve">
          <source>Kotlin/Native Runtime Declarations</source>
          <target state="translated">Kotlin/ネイティブランタイム宣言</target>
        </trans-unit>
        <trans-unit id="491c504edd0672427d971480838eef4206234894" translate="yes" xml:space="preserve">
          <source>Kotlin/Native also has tight integration with Apple technologies. The &lt;a href=&quot;apple-framework&quot;&gt;Kotlin/Native as an Apple Framework&lt;/a&gt; tutorial explains how to compile Kotlin code into a framework for Swift and Objective-C.</source>
          <target state="translated">Kotlin / NativeもAppleテクノロジーと緊密に統合されています。&lt;a href=&quot;apple-framework&quot;&gt;Appleフレームワークとして&lt;/a&gt;のKotlin / Nativeチュートリアルでは、KotlinコードをSwiftとObjective-Cのフレームワークにコンパイルする方法について説明しています。</target>
        </trans-unit>
        <trans-unit id="1d512deb7d342683898c6350ed1a11736984886b" translate="yes" xml:space="preserve">
          <source>Kotlin/Native also has tight integration with Objective-C and Swift. It is covered in the &lt;a href=&quot;apple-framework&quot;&gt;Kotlin/Native as an Apple Framework&lt;/a&gt; tutorial.</source>
          <target state="translated">Kotlin / Nativeは、Objective-CおよびSwiftとも緊密に統合されています。これは&lt;a href=&quot;apple-framework&quot;&gt;、Apple Framework&lt;/a&gt;チュートリアルとしてKotlin / Nativeでカバーされています。</target>
        </trans-unit>
        <trans-unit id="08982dde24268c672ff4e00ffc1e0aa78c3c7edf" translate="yes" xml:space="preserve">
          <source>Kotlin/Native as a Dynamic Library</source>
          <target state="translated">動的ライブラリとしてのKotlin/Native</target>
        </trans-unit>
        <trans-unit id="9337f3778507f31504f20c46b400d4ffe737a776" translate="yes" xml:space="preserve">
          <source>Kotlin/Native as an Apple Framework</source>
          <target state="translated">AppleフレームワークとしてのKotlin/Native</target>
        </trans-unit>
        <trans-unit id="5920643ed2bd803efde8c74d41d4425c7caa2ab6" translate="yes" xml:space="preserve">
          <source>Kotlin/Native can be used for many &lt;a href=&quot;basic-kotlin-native-app&quot;&gt;targets&lt;/a&gt; and applications, including, but not limited to macOS, Windows, Linux, and &lt;a href=&quot;mpp-ios-android&quot;&gt;iOS&lt;/a&gt;.</source>
          <target state="translated">Kotlin / Nativeは、macOS、Windows、Linux、&lt;a href=&quot;mpp-ios-android&quot;&gt;iOS&lt;/a&gt;など、多くの&lt;a href=&quot;basic-kotlin-native-app&quot;&gt;ターゲット&lt;/a&gt;およびアプリケーションで使用できます。</target>
        </trans-unit>
        <trans-unit id="5a86ebad61bd5c0feb7bd99b7af759453735031a" translate="yes" xml:space="preserve">
          <source>Kotlin/Native comes with the &lt;code&gt;cinterop&lt;/code&gt; tool, the tool generates bindings between the C language and Kotlin. It uses a &lt;code&gt;.def&lt;/code&gt; file to specify a C library to import. More details are discussed in the &lt;a href=&quot;../../reference/native/c_interop&quot;&gt;Interop with C Libraries&lt;/a&gt; tutorial.</source>
          <target state="translated">Kotlin / Nativeには &lt;code&gt;cinterop&lt;/code&gt; ツールが付属しており、このツールはC言語とKotlin間のバインディングを生成します。 &lt;code&gt;.def&lt;/code&gt; ファイルを使用して、インポートするCライブラリを指定します。詳細は&lt;a href=&quot;../../reference/native/c_interop&quot;&gt;、Cライブラリと&lt;/a&gt;の相互運用のチュートリアルで説明されています。</target>
        </trans-unit>
        <trans-unit id="c8a9d6995d5deeb05943192825e878fac0954ca5" translate="yes" xml:space="preserve">
          <source>Kotlin/Native comes with the &lt;code&gt;cinterop&lt;/code&gt; tool; the tool generates bindings between the C language and Kotlin. It uses a &lt;code&gt;.def&lt;/code&gt; file to specify a C library to import. More details on this are in the &lt;a href=&quot;../../reference/native/c_interop&quot;&gt;Interop with C Libraries&lt;/a&gt; tutorial.</source>
          <target state="translated">Kotlin / Nativeには &lt;code&gt;cinterop&lt;/code&gt; ツールが付属しています。このツールは、C言語とKotlinの間のバインディングを生成します。 &lt;code&gt;.def&lt;/code&gt; ファイルを使用して、インポートするCライブラリを指定します。これに関する詳細は、&lt;a href=&quot;../../reference/native/c_interop&quot;&gt;Cライブラリと&lt;/a&gt;の相互運用のチュートリアルにあります。</target>
        </trans-unit>
        <trans-unit id="f608852356bc7f03f212743cacdba0d3e22a135a" translate="yes" xml:space="preserve">
          <source>Kotlin/Native comes with the &lt;code&gt;cinterop&lt;/code&gt; tool; the tool generates bindings between the C language and Kotlin. It uses a &lt;code&gt;.def&lt;/code&gt; file to specify a C library to import. More details on this are in the &lt;a href=&quot;../../reference/native/c_interop&quot;&gt;Interop with C Libraries&lt;/a&gt; tutorial. The quickest way to try out C API mapping is to have all C declarations in the &lt;code&gt;interop.def&lt;/code&gt; file, without creating any &lt;code&gt;.h&lt;/code&gt; of &lt;code&gt;.c&lt;/code&gt; files at all. Then place the C declarations in a &lt;code&gt;interop.def&lt;/code&gt; file after the special &lt;code&gt;---&lt;/code&gt; separator line:</source>
          <target state="translated">Kotlin / Nativeには &lt;code&gt;cinterop&lt;/code&gt; ツールが付属しています。このツールは、C言語とKotlinの間のバインディングを生成します。 &lt;code&gt;.def&lt;/code&gt; ファイルを使用して、インポートするCライブラリを指定します。これに関する詳細は、&lt;a href=&quot;../../reference/native/c_interop&quot;&gt;Cライブラリと&lt;/a&gt;の相互運用のチュートリアルにあります。 C APIマッピングを試す最も簡単な方法は、 &lt;code&gt;.c&lt;/code&gt; ファイルの &lt;code&gt;.h&lt;/code&gt; をまったく作成せずに、すべてのC宣言を &lt;code&gt;interop.def&lt;/code&gt; ファイルに含めることです。次に、C宣言を &lt;code&gt;interop.def&lt;/code&gt; ファイルの特別な &lt;code&gt;---&lt;/code&gt; セパレータ行の後に配置します。</target>
        </trans-unit>
        <trans-unit id="02527cf62d35559073254c9faa21884b055d8fe5" translate="yes" xml:space="preserve">
          <source>Kotlin/Native compiler can produce a dynamic library out of the Kotlin code we have. A dynamic library often comes with a header file, a &lt;code&gt;.h&lt;/code&gt; file, which we will use to call compiled code from C.</source>
          <target state="translated">Kotlin /ネイティブコンパイラは、私たちが持っているKotlinコードから動的ライブラリを生成できます。ダイナミックライブラリには、多くの場合、ヘッダーファイルである &lt;code&gt;.h&lt;/code&gt; ファイルが付属しています。このファイルを使用して、Cからコンパイル済みコードを呼び出します。</target>
        </trans-unit>
        <trans-unit id="aa4881e31bc09168e1508d74717ea87e97808663" translate="yes" xml:space="preserve">
          <source>Kotlin/Native compiler can produce a framework for macOS and iOS out of the Kotlin code. The created framework contains all declarations and binaries needed to use it with Objective-C and Swift. The best way to understand the techniques is to try it for ourselves. Let's create a tiny Kotlin library first and use it from an Objective-C program.</source>
          <target state="translated">Kotlin/Nativeコンパイラは、KotlinのコードからmacOSやiOS用のフレームワークを作成することができます。作成されたフレームワークには、Objective-CやSwiftで使用するために必要なすべての宣言とバイナリが含まれています。テクニックを理解するには、実際に試してみるのが一番です。まずは小さなKotlinライブラリを作って、Objective-Cプログラムから使ってみましょう。</target>
        </trans-unit>
        <trans-unit id="4e70e70db2bb73d6cf1636bc883f8b53e7b6e7cb" translate="yes" xml:space="preserve">
          <source>Kotlin/Native for Native</source>
          <target state="translated">コトリン/ネイティブのためのネイティブ</target>
        </trans-unit>
        <trans-unit id="7c2c0a3630334c277a8dc79b0ff364b848f6cdc2" translate="yes" xml:space="preserve">
          <source>Kotlin/Native has bidirectional interop with Objective-C and Swift languages. Kotlin objects integrate with Objective-C/Swift reference counting. Unused Kotlin objects are automatically removed. The &lt;a href=&quot;https://github.com/JetBrains/kotlin-native/blob/master/OBJC_INTEROP.md&quot;&gt;Objective-C Interop&lt;/a&gt; article contains more information on the interop implementation details. Of course, it is possible to import an existing framework and use it from Kotlin. Kotlin/Native comes with a good set of pre-imported system frameworks.</source>
          <target state="translated">Kotlin / Nativeには、Objective-CおよびSwift言語との双方向の相互運用機能があります。Kotlinオブジェクトは、Objective-C / Swift参照カウントと統合されます。未使用のKotlinオブジェクトは自動的に削除されます。&lt;a href=&quot;https://github.com/JetBrains/kotlin-native/blob/master/OBJC_INTEROP.md&quot;&gt;Objective-Cの相互運用の&lt;/a&gt;記事は、相互運用機能実装の詳細についての詳細情報が含まれています。もちろん、既存のフレームワークをインポートしてKotlinから使用することもできます。Kotlin / Nativeには、事前にインポートされたシステムフレームワークの優れたセットが付属しています。</target>
        </trans-unit>
        <trans-unit id="fb79704d30655deeda4430e028a0903e865692a2" translate="yes" xml:space="preserve">
          <source>Kotlin/Native has garbage collection, but it does not help us deal with Kotlin objects from the C language. Kotlin/Native has interop with Objective-C and Swift and integrates with their reference counters. The &lt;a href=&quot;../../reference/native/objc_interop&quot;&gt;Objective-C Interop&lt;/a&gt; documentation article contains more details on it. Also, there is the tutorial &lt;a href=&quot;apple-framework&quot;&gt;Kotlin/Native as an Apple Framework&lt;/a&gt;.</source>
          <target state="translated">Kotlin / Nativeにはガベージコレクションがありますが、C言語のKotlinオブジェクトの処理には役立ちません。Kotlin / NativeはObjective-CおよびSwiftと相互運用性があり、それらの参照カウンターと統合します。&lt;a href=&quot;../../reference/native/objc_interop&quot;&gt;Objective-Cの相互運用&lt;/a&gt;ドキュメントの記事は、それについての詳細が含まれています。また、&lt;a href=&quot;apple-framework&quot;&gt;Apple Frameworkとしての&lt;/a&gt;チュートリアルKotlin / Nativeもあります。</target>
        </trans-unit>
        <trans-unit id="c4bedc3bea01878b4fcc1d82e743d0490ea2316b" translate="yes" xml:space="preserve">
          <source>Kotlin/Native implements strict mutability checks, ensuring the important invariant that the object is either immutable or accessible from the single thread at that moment in time (&lt;code&gt;mutable XOR global&lt;/code&gt;).</source>
          <target state="translated">Kotlin / Nativeは厳密な &lt;code&gt;mutable XOR global&lt;/code&gt; 性チェックを実装し、オブジェクトが不変であるか、その時点で単一のスレッドからアクセス可能であるという重要な不変条件を保証します（可変XORグローバル）。</target>
        </trans-unit>
        <trans-unit id="36a59900f037725e245ca430f51e42774fdb92b1" translate="yes" xml:space="preserve">
          <source>Kotlin/Native interop with Swift and Objective-C is covered in the &lt;a href=&quot;../../reference/native/objc_interop&quot;&gt;documentation&lt;/a&gt; article. Also, the same topic is covered in the &lt;a href=&quot;apple-framework&quot;&gt;Kotlin/Native as an Apple Framework&lt;/a&gt; tutorial.</source>
          <target state="translated">SwiftおよびObjective-CとのKotlin / Native相互運用については、&lt;a href=&quot;../../reference/native/objc_interop&quot;&gt;ドキュメントの&lt;/a&gt;記事で説明しています。また、同じトピックが&lt;a href=&quot;apple-framework&quot;&gt;Kotlin / NativeでApple Framework&lt;/a&gt;チュートリアルとしてカバーされています。</target>
        </trans-unit>
        <trans-unit id="9fbae7a065c905b4b51aef1c8da31351fd4627d4" translate="yes" xml:space="preserve">
          <source>Kotlin/Native interoperability</source>
          <target state="translated">Kotlin/ネイティブの相互運用性</target>
        </trans-unit>
        <trans-unit id="1610b5a5d3e7a47921adb6d92cccbad92bdc99b6" translate="yes" xml:space="preserve">
          <source>Kotlin/Native interoperability with Swift/Objective-C</source>
          <target state="translated">Kotlin/Swift/Objective-Cとのネイティブ相互運用性</target>
        </trans-unit>
        <trans-unit id="d8be23859d14973d71698ea0e5cefbc7c40946a7" translate="yes" xml:space="preserve">
          <source>Kotlin/Native is a technology for compiling Kotlin code to native binaries, which can run without a virtual machine. It is an &lt;a href=&quot;https://llvm.org/&quot;&gt;LLVM&lt;/a&gt; based backend for the Kotlin compiler and native implementation of the Kotlin standard library.</source>
          <target state="translated">Kotlin / Nativeは、Kotlinコードをネイティブバイナリにコンパイルするテクノロジーであり、仮想マシンなしで実行できます。これは、KotlinコンパイラーおよびKotlin標準ライブラリーのネイティブ実装用の&lt;a href=&quot;https://llvm.org/&quot;&gt;LLVM&lt;/a&gt;ベースのバックエンドです。</target>
        </trans-unit>
        <trans-unit id="f0c84f3b6f232babbc963e394f0dc8678a4ccc49" translate="yes" xml:space="preserve">
          <source>Kotlin/Native is currently &lt;a href=&quot;https://blog.jetbrains.com/kotlin/tag/native/&quot;&gt;in the works&lt;/a&gt;. It compiles Kotlin to native code that can run without a VM. There is a Technology Preview released but it is not production-ready yet, and doesn&amp;rsquo;t yet target all the platforms that we plan to support for 1.0. For more information check out the &lt;a href=&quot;https://blog.jetbrains.com/kotlin/2017/04/kotlinnative-tech-preview-kotlin-without-a-vm/&quot;&gt;blog post announcing Kotlin/Native&lt;/a&gt;.</source>
          <target state="translated">Kotlin / Nativeは現在&lt;a href=&quot;https://blog.jetbrains.com/kotlin/tag/native/&quot;&gt;作業中&lt;/a&gt;です。KotlinをVMなしで実行できるネイティブコードにコンパイルします。テクノロジープレビューがリリースされましたが、まだ本番環境には対応しておらず、1.0をサポートする予定のすべてのプラットフォームをまだターゲットにしていません。詳細については、&lt;a href=&quot;https://blog.jetbrains.com/kotlin/2017/04/kotlinnative-tech-preview-kotlin-without-a-vm/&quot;&gt;Kotlin / Nativeを発表&lt;/a&gt;したブログ投稿をご覧ください。</target>
        </trans-unit>
        <trans-unit id="2e6e839c9eb016aad26e87b63395598581d37d86" translate="yes" xml:space="preserve">
          <source>Kotlin/Native is primarily designed to allow compilation for platforms where &lt;em&gt;virtual machines&lt;/em&gt; are not desirable or possible, for example, embedded devices or iOS. It solves the situations when a developer needs to produce a self-contained program that does not require an additional runtime or virtual machine.</source>
          <target state="translated">Kotlin / Nativeは主に、組み込みデバイスやiOSなど、&lt;em&gt;仮想マシン&lt;/em&gt;が望ましくない、または不可能であるプラットフォームでのコンパイルを可能にするように設計されています。追加のランタイムや仮想マシンを必要としない自己完結型プログラムを開発者が作成する必要がある状況を解決します。</target>
        </trans-unit>
        <trans-unit id="0a635a513919c15b75bf38827975739bea97d9aa" translate="yes" xml:space="preserve">
          <source>Kotlin/Native libraries</source>
          <target state="translated">Kotlin/ネイティブライブラリ</target>
        </trans-unit>
        <trans-unit id="e52aa2cf9fdcb60b58b2f9cbee9d5268ded14cfd" translate="yes" xml:space="preserve">
          <source>Kotlin/Native libraries are zip files containing a predefined directory structure, with the following layout:</source>
          <target state="translated">Kotlin/Native ライブラリは、あらかじめ定義されたディレクトリ構造を含む zip ファイルで、以下のようなレイアウトになっています。</target>
        </trans-unit>
        <trans-unit id="0c6f4cb92f825877d15d4e0409193ad150464dfb" translate="yes" xml:space="preserve">
          <source>Kotlin/Native plugin requires a newer version of Gradle, let's patch the &lt;code&gt;gradle/wrapper/gradle-wrapper.properties&lt;/code&gt; and use the following &lt;code&gt;distrubutionUrl&lt;/code&gt;:</source>
          <target state="translated">Kotlin /ネイティブプラグインは、レッツ・パッチ、のGradleの新しいバージョンを必要とする &lt;code&gt;gradle/wrapper/gradle-wrapper.properties&lt;/code&gt; と、次の使用 &lt;code&gt;distrubutionUrl&lt;/code&gt; を：</target>
        </trans-unit>
        <trans-unit id="bc9ab4e314800dbff8307a948abe9a382ccbda9f" translate="yes" xml:space="preserve">
          <source>Kotlin/Native provides bi-directional interoperability with Objective-C/Swift. Objective-C frameworks and libraries can be used in Kotlin code. Kotlin modules can be used in Swift/Objective-C code too. Besides that, Kotlin/Native has &lt;a href=&quot;https://github.com/JetBrains/kotlin-native/blob/master/INTEROP.md&quot;&gt;C Interop&lt;/a&gt;. There is also the &lt;a href=&quot;dynamic-libraries&quot;&gt;Kotlin/Native as a Dynamic Library&lt;/a&gt; tutorial for more information.</source>
          <target state="translated">Kotlin / Nativeは、Objective-C / Swiftとの双方向の相互運用性を提供します。Objective-CフレームワークとライブラリはKotlinコードで使用できます。Kotlinモジュールは、Swift / Objective-Cコードでも使用できます。それ以外に、Kotlin / Nativeには&lt;a href=&quot;https://github.com/JetBrains/kotlin-native/blob/master/INTEROP.md&quot;&gt;C Interopがあり&lt;/a&gt;ます。詳細については&lt;a href=&quot;dynamic-libraries&quot;&gt;、ダイナミックライブラリ&lt;/a&gt;チュートリアルとしてのKotlin / Nativeもあります。</target>
        </trans-unit>
        <trans-unit id="c6b2dc69e2661f2073dd575f2affbfbd48e1816c" translate="yes" xml:space="preserve">
          <source>Kotlin/Native provides bidirectional interoperability with Objective-C. Objective-C frameworks and libraries can be used in Kotlin code if properly imported to the build (system frameworks are imported by default). See e.g. &quot;Using cinterop&quot; in &lt;a href=&quot;gradle_plugin#using-cinterop&quot;&gt;Gradle plugin documentation&lt;/a&gt;. A Swift library can be used in Kotlin code if its API is exported to Objective-C with &lt;code&gt;@objc&lt;/code&gt;. Pure Swift modules are not yet supported.</source>
          <target state="translated">Kotlin / Nativeは、Objective-Cとの双方向の相互運用性を提供します。Objective-Cフレームワークとライブラリは、ビルドに適切にインポートされた場合、Kotlinコードで使用できます（システムフレームワークはデフォルトでインポートされます）。たとえば、&lt;a href=&quot;gradle_plugin#using-cinterop&quot;&gt;Gradleプラグインのドキュメントの&lt;/a&gt;「cinteropの使用」を参照してください。Swiftライブラリは、そのAPIが &lt;code&gt;@objc&lt;/code&gt; を使用してObjective-Cにエクスポートされている場合、Kotlinコードで使用できます。Pure Swiftモジュールはまだサポートされていません。</target>
        </trans-unit>
        <trans-unit id="70a326aefb047308c0a09cf46a7be9e9cca8e58e" translate="yes" xml:space="preserve">
          <source>Kotlin/Native provides integration with the &lt;a href=&quot;https://cocoapods.org/&quot;&gt;CocoaPods dependency manager&lt;/a&gt;. You can add dependencies on Pod libraries stored in the CocoaPods repository or locally as well as use a multiplatform project with native targets as a CocoaPods dependency (Kotlin Pod).</source>
          <target state="translated">Kotlin / Nativeは、&lt;a href=&quot;https://cocoapods.org/&quot;&gt;CocoaPods依存関係マネージャー&lt;/a&gt;との統合を提供します。CocoaPodsリポジトリまたはローカルに保存されているPodライブラリへの依存関係を追加したり、ネイティブターゲットを使用したマルチプラットフォームプロジェクトをCocoaPods依存関係（Kotlin Pod）として使用したりできます。</target>
        </trans-unit>
        <trans-unit id="b1c01f6b8c6b07e3bae6f070059599f6036610db" translate="yes" xml:space="preserve">
          <source>Kotlin/Native provides us with the ability to consume standard C libraries, opening up an entire ecosystem of functionality that exists for pretty much anything we could need. In fact, Kotlin/Native already ships with a set of prebuilt &lt;a href=&quot;https://github.com/JetBrains/kotlin-native/blob/master/PLATFORM_LIBS.md&quot;&gt;platform libraries&lt;/a&gt; which provide some additional common functionality to that of the standard library.</source>
          <target state="translated">Kotlin / Nativeは、標準のCライブラリを利用する機能を提供し、必要なほぼすべてのもののために存在する機能のエコシステム全体を開きます。実際、Kotlin / Nativeには、標準ライブラリの機能にいくつかの追加の共通機能を提供する一連のビルド済み&lt;a href=&quot;https://github.com/JetBrains/kotlin-native/blob/master/PLATFORM_LIBS.md&quot;&gt;プラットフォームライブラリ&lt;/a&gt;がすでに付属しています。</target>
        </trans-unit>
        <trans-unit id="d5389b5d85aa38736c73eb5aa9a313b033cc4d19" translate="yes" xml:space="preserve">
          <source>Kotlin/Native runtime doesn't encourage a classical thread-oriented concurrency model with mutually exclusive code blocks and conditional variables, as this model is known to be error-prone and unreliable. Instead, we suggest a collection of alternative approaches, allowing you to use hardware concurrency and implement blocking IO. Those approaches are as follows, and they will be elaborated on in further sections:</source>
          <target state="translated">Kotlin/Native ランタイムでは、相互に排他的なコードブロックと条件変数を持つ古典的なスレッド指向の同時実行モデルを推奨していません。このモデルはエラーが発生しやすく信頼性が低いことが知られているからです。その代わりに、ハードウェア同時実行を使用して IO をブロッキングすることを可能にする代替アプローチを提案します。これらのアプローチは以下の通りで、さらに詳しく説明します。</target>
        </trans-unit>
        <trans-unit id="ac06a1726ed52d913d8c1eb5dbb2c82e723e185d" translate="yes" xml:space="preserve">
          <source>Kotlin/Native sources and examples</source>
          <target state="translated">コトリン/ネイティブのソースと例</target>
        </trans-unit>
        <trans-unit id="c4fa13c8ae49679dc61a192fdfe13c1f15f778dd" translate="yes" xml:space="preserve">
          <source>Kotlin/Native sources and examples (.tgz)</source>
          <target state="translated">Kotlin/ネイティブのソースと例 (.tgz)</target>
        </trans-unit>
        <trans-unit id="950455929874daa5e49199f24231f9f317130873" translate="yes" xml:space="preserve">
          <source>Kotlin/Native sources and examples (.zip)</source>
          <target state="translated">Kotlin/ネイティブのソースとサンプル (.zip)</target>
        </trans-unit>
        <trans-unit id="5729c05577d9982b3fa36c76507104ea69c51357" translate="yes" xml:space="preserve">
          <source>Kotlin/Native standard library provides primitives for safe working with concurrently mutable data, namely &lt;code&gt;AtomicInt&lt;/code&gt;, &lt;code&gt;AtomicLong&lt;/code&gt;, &lt;code&gt;AtomicNativePtr&lt;/code&gt;, &lt;code&gt;AtomicReference&lt;/code&gt; and &lt;code&gt;FreezableAtomicReference&lt;/code&gt; in the package &lt;code&gt;kotlin.native.concurrent&lt;/code&gt;. Atomic primitives allows concurrency-safe update operations, such as increment, decrement and compare-and-swap, along with value setters and getters. Atomic primitives are considered always frozen by the runtime, and while their fields can be updated with the regular &lt;code&gt;field.value += 1&lt;/code&gt;, it is not concurrency safe. Value must be be changed using dedicated operations, so it is possible to perform concurrent-safe global counters and similar data structures.</source>
          <target state="translated">Kotlin / Native標準ライブラリは、同時に変更可能なデータ、つまり &lt;code&gt;AtomicInt&lt;/code&gt; 、 &lt;code&gt;AtomicLong&lt;/code&gt; 、 &lt;code&gt;AtomicNativePtr&lt;/code&gt; 、 &lt;code&gt;AtomicReference&lt;/code&gt; 、 &lt;code&gt;FreezableAtomicReference&lt;/code&gt; をパッケージ &lt;code&gt;kotlin.native.concurrent&lt;/code&gt; で安全に操作するためのプリミティブを提供します。アトミックプリミティブを使用すると、値セッターとゲッターに加えて、インクリメント、デクリメント、コンペアアンドスワップなどの並行性に安全な更新操作が可能になります。アトミックプリミティブは、ランタイムによって常にフリーズされていると見なされますが、それらのフィールドは通常の &lt;code&gt;field.value += 1&lt;/code&gt; 更新できます。、並行性は安全ではありません。専用の操作を使用して値を変更する必要があるため、同時安全なグローバルカウンターや同様のデータ構造を実行できます。</target>
        </trans-unit>
        <trans-unit id="120d75c1b3c3fba55f52d619ebc338f3dea2b2f3" translate="yes" xml:space="preserve">
          <source>Kotlin/Native supports C interop too. Check out the &lt;a href=&quot;dynamic-libraries&quot;&gt;Kotlin/Native as a Dynamic Library&lt;/a&gt; tutorial for that, or have a look at the &lt;a href=&quot;../../reference/native/c_interop&quot;&gt;C Interop&lt;/a&gt; documentation article</source>
          <target state="translated">Kotlin / NativeもC相互運用性をサポートしています。そのための&lt;a href=&quot;dynamic-libraries&quot;&gt;ダイナミックライブラリ&lt;/a&gt;チュートリアルとしてのKotlin / Nativeを確認するか、&lt;a href=&quot;../../reference/native/c_interop&quot;&gt;C Interopの&lt;/a&gt;ドキュメント記事をご覧ください。</target>
        </trans-unit>
        <trans-unit id="8011eb11da7ebe065e7322454c19657ef14fbebd" translate="yes" xml:space="preserve">
          <source>Kotlin/Native supports the following platforms:</source>
          <target state="translated">Kotlin/Native は以下のプラットフォームに対応しています。</target>
        </trans-unit>
        <trans-unit id="ab1b874667f8863029a4700ab21570b44d78ad0e" translate="yes" xml:space="preserve">
          <source>Kotlin/Native supports two-way interoperability with the Native world. On the one hand, the compiler creates:</source>
          <target state="translated">Kotlin/Native はネイティブの世界との双方向の相互運用性をサポートしています。一方ではコンパイラが作成します。</target>
        </trans-unit>
        <trans-unit id="6804afabbebdb0087394548cd2a9146eb760288b" translate="yes" xml:space="preserve">
          <source>Kotlin/Native target presets (see the &lt;a href=&quot;#using-kotlinnative-targets&quot;&gt;notes&lt;/a&gt; below):</source>
          <target state="translated">Kotlin /ネイティブターゲットプリセット（下記の&lt;a href=&quot;#using-kotlinnative-targets&quot;&gt;注を&lt;/a&gt;参照）：</target>
        </trans-unit>
        <trans-unit id="48119a00acf039b3da2d7a8a891256a947a47f3e" translate="yes" xml:space="preserve">
          <source>Kotlin/Native targets do not require additional test dependencies, and the &lt;code&gt;kotlin.test&lt;/code&gt; API implementations are built-in.</source>
          <target state="translated">Kotlin /ネイティブターゲットには追加のテスト依存関係は必要なく、 &lt;code&gt;kotlin.test&lt;/code&gt; API実装が組み込まれています。</target>
        </trans-unit>
        <trans-unit id="5a2754b26e3f7ed0f09f6ac7ae0bd6b529fb311d" translate="yes" xml:space="preserve">
          <source>Kotlin/Native uses the &lt;a href=&quot;https://gradle.org&quot;&gt;Gradle&lt;/a&gt; build system through the &lt;a href=&quot;../../reference/building-mpp-with-gradle&quot;&gt;kotlin-multiplatform&lt;/a&gt; plugin. We'll look at how to configure a Gradle build below. For some corner cases, a Kotlin/Native compiler can still be obtained manually (not recommended) from the &lt;a href=&quot;https://github.com/JetBrains/kotlin/releases&quot;&gt;Kotlin releases page on GitHub&lt;/a&gt;. In the tutorial, we are focusing on using the Gradle builds.</source>
          <target state="translated">Kotlin / Nativeは、&lt;a href=&quot;../../reference/building-mpp-with-gradle&quot;&gt;kotlin-multiplatform&lt;/a&gt;プラグインを介して&lt;a href=&quot;https://gradle.org&quot;&gt;Gradle&lt;/a&gt;ビルドシステムを使用します。以下で、Gradleビルドを構成する方法を見ていきます。一部のまれなケースでは、&lt;a href=&quot;https://github.com/JetBrains/kotlin/releases&quot;&gt;GitHubのKotlinリリースページ&lt;/a&gt;からKotlin / Nativeコンパイラーを手動で取得できます（非推奨）。チュートリアルでは、Gradleビルドの使用に重点を置いています。</target>
        </trans-unit>
        <trans-unit id="8a3c5258f5b49cfb85ed7f0dcaee614a131a77c3" translate="yes" xml:space="preserve">
          <source>Kotlin:</source>
          <target state="translated">Kotlin:</target>
        </trans-unit>
        <trans-unit id="b43ff6724657fd16732a9b1a55f67abda3312ad7" translate="yes" xml:space="preserve">
          <source>KotlinConf Spinner app</source>
          <target state="translated">KotlinConfスピナーアプリ</target>
        </trans-unit>
        <trans-unit id="b1cd61d796dd3aa3454e388dffcf47f0812af913" translate="yes" xml:space="preserve">
          <source>KotlinConf app</source>
          <target state="translated">KotlinConf アプリ</target>
        </trans-unit>
        <trans-unit id="6047c8afd00f076fe5dfb352137d01b27268ea83" translate="yes" xml:space="preserve">
          <source>KotlinNullPointerException</source>
          <target state="translated">KotlinNullPointerException</target>
        </trans-unit>
        <trans-unit id="ee7e86f4510f7d7092cbe3960fdb6815985528a4" translate="yes" xml:space="preserve">
          <source>KotlinReflectionNotSupportedError</source>
          <target state="translated">KotlinReflectionNotSupportedError</target>
        </trans-unit>
        <trans-unit id="4b1b0c248352273cdb7b000d38d1c480106dbb58" translate="yes" xml:space="preserve">
          <source>KotlinVersion</source>
          <target state="translated">KotlinVersion</target>
        </trans-unit>
        <trans-unit id="399d4d156e1a5773fbf3b4b0cfd04b6e517c9fca" translate="yes" xml:space="preserve">
          <source>KtFunction</source>
          <target state="translated">KtFunction</target>
        </trans-unit>
        <trans-unit id="57da6543f61562be137bdbd9c9e157724aeffda4" translate="yes" xml:space="preserve">
          <source>LEFT_TO_RIGHT</source>
          <target state="translated">LEFT_TO_RIGHT</target>
        </trans-unit>
        <trans-unit id="a75ecccfbf31bd489981a90341d7e832ee10f3c8" translate="yes" xml:space="preserve">
          <source>LEFT_TO_RIGHT_EMBEDDING</source>
          <target state="translated">LEFT_TO_RIGHT_EMBEDDING</target>
        </trans-unit>
        <trans-unit id="51859752bb5b0316e072d757734043db04448fc4" translate="yes" xml:space="preserve">
          <source>LEFT_TO_RIGHT_OVERRIDE</source>
          <target state="translated">LEFT_TO_RIGHT_OVERRIDE</target>
        </trans-unit>
        <trans-unit id="758213c577cf41a86fde124f3b88be88d415048d" translate="yes" xml:space="preserve">
          <source>LETTER_NUMBER</source>
          <target state="translated">LETTER_NUMBER</target>
        </trans-unit>
        <trans-unit id="e8e9a4d54a1399696ec25a431fcc0c615fbc2e7a" translate="yes" xml:space="preserve">
          <source>LINE_SEPARATOR</source>
          <target state="translated">LINE_SEPARATOR</target>
        </trans-unit>
        <trans-unit id="e84f54372586b1a789f2b6cf056c7a1173be8141" translate="yes" xml:space="preserve">
          <source>LINUX</source>
          <target state="translated">LINUX</target>
        </trans-unit>
        <trans-unit id="7ec99800d18c128a406891a50a13ae7030c97a75" translate="yes" xml:space="preserve">
          <source>LITERAL</source>
          <target state="translated">LITERAL</target>
        </trans-unit>
        <trans-unit id="e893e5d306bb8ac993e8000a6af037f4725105be" translate="yes" xml:space="preserve">
          <source>LOCAL_VARIABLE</source>
          <target state="translated">LOCAL_VARIABLE</target>
        </trans-unit>
        <trans-unit id="99de6ad7c4876501b047c66fac1fc218394c8386" translate="yes" xml:space="preserve">
          <source>LOWERCASE_LETTER</source>
          <target state="translated">LOWERCASE_LETTER</target>
        </trans-unit>
        <trans-unit id="ebb1178c70d79da7a0d8f3efa343b4f1b5b8c8bd" translate="yes" xml:space="preserve">
          <source>Lambda Expressions and Anonymous Functions</source>
          <target state="translated">ラムダ式と匿名関数</target>
        </trans-unit>
        <trans-unit id="41d636c884bc5c4615a06b36835ca61116f4c96a" translate="yes" xml:space="preserve">
          <source>Lambda expression syntax</source>
          <target state="translated">ラムダ式の構文</target>
        </trans-unit>
        <trans-unit id="0b86dab2bd78e474cfa2ccedae83439dde48687c" translate="yes" xml:space="preserve">
          <source>Lambda expressions and anonymous functions are 'function literals', i.e. functions that are not declared, but passed immediately as an expression. Consider the following example:</source>
          <target state="translated">ラムダ式や匿名関数は「関数リテラル」、つまり宣言されずに式としてすぐに渡される関数です。次の例を考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="5688b8dc62f61bfb17ef962f1f3970299059391c" translate="yes" xml:space="preserve">
          <source>Lambda expressions and anonymous functions are collectively called &lt;em&gt;function literals&lt;/em&gt;.</source>
          <target state="translated">ラムダ式と無名関数は、まとめて&lt;em&gt;関数リテラル&lt;/em&gt;と呼ばれ&lt;em&gt;ます&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="7575b2907cada2fd0b97a753d13dd1b9c1b841f5" translate="yes" xml:space="preserve">
          <source>Lambda expressions can be used as function literals with receiver when the receiver type can be inferred from context. One of the most important examples of their usage is &lt;a href=&quot;type-safe-builders&quot;&gt;type-safe builders&lt;/a&gt;:</source>
          <target state="translated">ラムダ式は、レシーバータイプをコンテキストから推測できる場合、レシーバーで関数リテラルとして使用できます。その使用法の最も重要な例の1つは、&lt;a href=&quot;type-safe-builders&quot;&gt;タイプセーフなビルダー&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="ad3d3ff2619991da585042e4417d2462b7beccf2" translate="yes" xml:space="preserve">
          <source>Lambda formatting</source>
          <target state="translated">ラムダフォーマット</target>
        </trans-unit>
        <trans-unit id="13d6fc1369e9172c884961d85e8a1601ad741c0d" translate="yes" xml:space="preserve">
          <source>Lambda parameters</source>
          <target state="translated">ラムダパラメータ</target>
        </trans-unit>
        <trans-unit id="b220e56144b93a1600b71766a84e029644f0540d" translate="yes" xml:space="preserve">
          <source>Lambda result</source>
          <target state="translated">ラムダ結果</target>
        </trans-unit>
        <trans-unit id="ba9dfe5041cd205445df5b843e8a9dc628256415" translate="yes" xml:space="preserve">
          <source>Lambdas</source>
          <target state="translated">Lambdas</target>
        </trans-unit>
        <trans-unit id="49ddf0eb799de42693040dadaac202ba4004f236" translate="yes" xml:space="preserve">
          <source>Language settings</source>
          <target state="translated">言語設定</target>
        </trans-unit>
        <trans-unit id="1ff5129754f331271a9a3fac5165d942c8cc5ff1" translate="yes" xml:space="preserve">
          <source>Language settings of a source set affect how the sources are analyzed in the IDE. Due to the current limitations, in a Gradle build, only the language settings of the compilation's default source set are used and are applied to all of the sources participating in the compilation.</source>
          <target state="translated">ソースセットの言語設定は、IDEでソースがどのように解析されるかに影響します。現在の制限のため、Gradle のビルドでは、コンパイルのデフォルトソースセットの言語設定のみが使用され、コンパイルに参加しているすべてのソースに適用されます。</target>
        </trans-unit>
        <trans-unit id="d6774da675388cdd08014c6406478bff14597287" translate="yes" xml:space="preserve">
          <source>Late-Initialized Properties and Variables</source>
          <target state="translated">初期化されたプロパティと変数</target>
        </trans-unit>
        <trans-unit id="99322069c074a7f591d86eb26eeac43fa69f34bd" translate="yes" xml:space="preserve">
          <source>Lateinit</source>
          <target state="translated">Lateinit</target>
        </trans-unit>
        <trans-unit id="f84a3ef3e20f72377a42e84bdb45e09bb7b7843f" translate="yes" xml:space="preserve">
          <source>Lateinit top-level properties and local variables</source>
          <target state="translated">Lateinit トップレベルのプロパティとローカル変数</target>
        </trans-unit>
        <trans-unit id="b3bb9d6cae3f462e729059bd666f0ea34bc0ea80" translate="yes" xml:space="preserve">
          <source>Lazily started async</source>
          <target state="translated">怠惰に非同期を開始</target>
        </trans-unit>
        <trans-unit id="84e98cf97551805d46a1030b73cb47aa40988008" translate="yes" xml:space="preserve">
          <source>Lazy</source>
          <target state="translated">Lazy</target>
        </trans-unit>
        <trans-unit id="be5e08be6cf0006ff0c341fef7d3f6b41fb802ed" translate="yes" xml:space="preserve">
          <source>Lazy property</source>
          <target state="translated">怠惰な性質</target>
        </trans-unit>
        <trans-unit id="54579fdbee70b6cb28a03b9cca5ce503dbf0fab9" translate="yes" xml:space="preserve">
          <source>LazyThreadSafetyMode</source>
          <target state="translated">LazyThreadSafetyMode</target>
        </trans-unit>
        <trans-unit id="aca4dc328f8e03ba7e98c1efbf5068f7d83287c3" translate="yes" xml:space="preserve">
          <source>Learn Kotlin</source>
          <target state="translated">ベースンを学ぶ</target>
        </trans-unit>
        <trans-unit id="802c13534d20e4859719f8999764811676dc2ecd" translate="yes" xml:space="preserve">
          <source>Learn more about coroutines debugging in the &lt;a href=&quot;../../tutorials/coroutines/debug-coroutines-with-idea&quot;&gt;tutorial&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../tutorials/coroutines/debug-coroutines-with-idea&quot;&gt;チュートリアルで&lt;/a&gt;コルーチンのデバッグの詳細をご覧ください。</target>
        </trans-unit>
        <trans-unit id="b28b1c4866b45b6c232187eb0f49c55bd90b8a14" translate="yes" xml:space="preserve">
          <source>Learning Kotlin</source>
          <target state="translated">コトリンを学ぶ</target>
        </trans-unit>
        <trans-unit id="23f50e0c99ce18545a5c0af46eb7b9685859fd37" translate="yes" xml:space="preserve">
          <source>Learning Kotlin with EduTools plugin</source>
          <target state="translated">EduToolsプラグインでKotlinを学ぶ</target>
        </trans-unit>
        <trans-unit id="e19a030656541f97ece0fe153ca0f1966796261d" translate="yes" xml:space="preserve">
          <source>Leave other options with their default values and click &lt;strong&gt;Finish&lt;/strong&gt;.</source>
          <target state="translated">他のオプションはデフォルト値のままにし、[ &lt;strong&gt;完了&lt;/strong&gt; ]をクリックします。</target>
        </trans-unit>
        <trans-unit id="b8d43e4d61d6a5ac38163dd5c6fce699c5294311" translate="yes" xml:space="preserve">
          <source>Let us have two producers of strings: &lt;code&gt;fizz&lt;/code&gt; and &lt;code&gt;buzz&lt;/code&gt;. The &lt;code&gt;fizz&lt;/code&gt; produces &quot;Fizz&quot; string every 300 ms:</source>
          <target state="translated">文字列の2つのプロデューサー、 &lt;code&gt;fizz&lt;/code&gt; と &lt;code&gt;buzz&lt;/code&gt; があるとします。 &lt;code&gt;fizz&lt;/code&gt; 、すべて300ミリ「フィズ」の文字列を生成します。</target>
        </trans-unit>
        <trans-unit id="d5d7818bcabda3185325fd62a8d08d65a192e5b3" translate="yes" xml:space="preserve">
          <source>Let us launch a hundred coroutines all doing the same action a thousand times. We'll also measure their completion time for further comparisons:</source>
          <target state="translated">同じ動作を1000回行う100個のコルーチンを起動してみましょう。さらに比較のために、それらの完了時間も測定してみましょう。</target>
        </trans-unit>
        <trans-unit id="97c13d20ca41b326b3be0985ea83f77551576d93" translate="yes" xml:space="preserve">
          <source>Let us launch a hundred coroutines all doing the same action thousand times. We'll also measure their completion time for further comparisons:</source>
          <target state="translated">100個のコルーチンを起動して、同じ動作を1000回行ってみましょう。さらに比較のために、それらの完了時間も測定してみましょう。</target>
        </trans-unit>
        <trans-unit id="00337a32763192378fa8ed88a3475bc09950f868" translate="yes" xml:space="preserve">
          <source>Let us put our knowledge about contexts, children and jobs together. Assume that our application has an object with a lifecycle, but that object is not a coroutine. For example, we are writing an Android application and launch various coroutines in the context of an Android activity to perform asynchronous operations to fetch and update data, do animations, etc. All of these coroutines must be cancelled when activity is destroyed to avoid memory leaks. We, of course, can manipulate contexts and jobs manually to tie activity's and coroutines lifecycles, but &lt;code&gt;kotlinx.coroutines&lt;/code&gt; provides an abstraction that encapsulates that: &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html&quot;&gt;CoroutineScope&lt;/a&gt;. You should be already familiar with coroutine scope as all coroutine builders are declared as extensions on it.</source>
          <target state="translated">コンテキスト、子供、仕事についての知識をまとめましょう。アプリケーションにライフサイクルを持つオブジェクトがあると仮定しますが、そのオブジェクトはコルーチンではありません。たとえば、Androidアプリケーションを作成し、Androidアクティビティのコンテキストでさまざまなコルーチンを起動して、データのフェッチや更新、アニメーションなどの非同期操作を実行します。メモリリークを回避するには、アクティビティが破棄されたときに、これらのコルーチンをすべてキャンセルする必要があります。 。私たちは、当然のことながら、活動のとコルーチンのライフサイクルを結びつけるために、手動でコンテキストとジョブを操作することができますが、 &lt;code&gt;kotlinx.coroutines&lt;/code&gt; は抽象化を提供するカプセル化し：&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html&quot;&gt;CoroutineScope&lt;/a&gt;。コルーチンスコープはすべてコルーチンビルダーに拡張として宣言されているため、コルーチンスコープに精通している必要があります。</target>
        </trans-unit>
        <trans-unit id="0f1725d0b230accb8eeb7b1ecce985617d4f3a5c" translate="yes" xml:space="preserve">
          <source>Let us put our knowledge about contexts, children and jobs together. Assume that our application has an object with a lifecycle, but that object is not a coroutine. For example, we are writing an Android application and launch various coroutines in the context of an Android activity to perform asynchronous operations to fetch and update data, do animations, etc. All of these coroutines must be cancelled when the activity is destroyed to avoid memory leaks. We, of course, can manipulate contexts and jobs manually to tie the lifecycles of the activity and its coroutines, but &lt;code&gt;kotlinx.coroutines&lt;/code&gt; provides an abstraction encapsulating that: &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html&quot;&gt;CoroutineScope&lt;/a&gt;. You should be already familiar with the coroutine scope as all coroutine builders are declared as extensions on it.</source>
          <target state="translated">文脈、子供、仕事についての知識をまとめましょう。アプリケーションにライフサイクルを持つオブジェクトがありますが、そのオブジェクトはコルーチンではないとします。たとえば、Androidアプリケーションを作成し、Androidアクティビティのコンテキストでさまざまなコルーチンを起動して、データのフェッチと更新、アニメーションの実行などの非同期操作を実行します。メモリを避けるために、アクティビティが破棄されたら、これらのコルーチンをすべてキャンセルする必要があります。リーク。私たちは、当然のことながら、活動及びそのコルーチンのライフサイクルを結びつけるために、手動でコンテキストとジョブを操作することができますが、 &lt;code&gt;kotlinx.coroutines&lt;/code&gt; はそれをカプセル化する抽象化を提供します：&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html&quot;&gt;CoroutineScope&lt;/a&gt;。すべてのコルーチンビルダーはその拡張機能として宣言されているため、コルーチンスコープについてはすでに理解している必要があります。</target>
        </trans-unit>
        <trans-unit id="f17004be77e3f7094989ac66ca7a6fcece2d7637" translate="yes" xml:space="preserve">
          <source>Let us run it all seven times:</source>
          <target state="translated">全部で7回走らせてみましょう。</target>
        </trans-unit>
        <trans-unit id="887399487cb35f46c356a942974d9aca65f7d75b" translate="yes" xml:space="preserve">
          <source>Let us start a dozen of them with a random delay.</source>
          <target state="translated">ランダム遅延で十数個始めてみよう。</target>
        </trans-unit>
        <trans-unit id="413db7e1244403c1e2eef1bc015d6f2b29e5c10d" translate="yes" xml:space="preserve">
          <source>Let us take &lt;a href=&quot;#concurrent-using-async&quot;&gt;Concurrent using async&lt;/a&gt; example and extract a function that concurrently performs &lt;code&gt;doSomethingUsefulOne&lt;/code&gt; and &lt;code&gt;doSomethingUsefulTwo&lt;/code&gt; and returns the sum of their results. Because &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html&quot;&gt;async&lt;/a&gt; coroutines builder is defined as extension on &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;CoroutineScope&lt;/a&gt; we need to have it in the scope and that is what &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;coroutineScope&lt;/a&gt; function provides:</source>
          <target state="translated">&lt;a href=&quot;#concurrent-using-async&quot;&gt;非同期の&lt;/a&gt;例を使用してConcurrentを取り上げ、 &lt;code&gt;doSomethingUsefulTwo&lt;/code&gt; と &lt;code&gt;doSomethingUsefulOne&lt;/code&gt; を同時に実行して結果の合計を返す関数を抽出してみましょう。ので&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html&quot;&gt;非同期&lt;/a&gt;コルーチンビルダーは、上の拡張として定義されて&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;CoroutineScope&lt;/a&gt;我々はスコープでそれを持っている必要があり、それが何である&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;coroutineScopeの&lt;/a&gt;機能が用意されています。</target>
        </trans-unit>
        <trans-unit id="bcdef397c512533845238594a2c065ab9f9b9332" translate="yes" xml:space="preserve">
          <source>Let us take the &lt;a href=&quot;#concurrent-using-async&quot;&gt;Concurrent using async&lt;/a&gt; example and extract a function that concurrently performs &lt;code&gt;doSomethingUsefulOne&lt;/code&gt; and &lt;code&gt;doSomethingUsefulTwo&lt;/code&gt; and returns the sum of their results. Because the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html&quot;&gt;async&lt;/a&gt; coroutine builder is defined as an extension on &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html&quot;&gt;CoroutineScope&lt;/a&gt;, we need to have it in the scope and that is what the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;coroutineScope&lt;/a&gt; function provides:</source>
          <target state="translated">&lt;a href=&quot;#concurrent-using-async&quot;&gt;非同期の&lt;/a&gt;例を使用して並行を取り、 &lt;code&gt;doSomethingUsefulOne&lt;/code&gt; と &lt;code&gt;doSomethingUsefulTwo&lt;/code&gt; を同時に実行し、それらの結果の合計を返す関数を抽出してみましょう。ので&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html&quot;&gt;非同期&lt;/a&gt;コルーチンビルダーは、上の拡張として定義されて&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html&quot;&gt;CoroutineScope&lt;/a&gt;、我々はスコープでそれを持っている必要があり、それが何である&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;coroutineScopeの&lt;/a&gt;機能が用意されています。</target>
        </trans-unit>
        <trans-unit id="4952c7e38d872a3739e9ba60b2855b8019e8b9ca" translate="yes" xml:space="preserve">
          <source>Let us write a channel producer function that consumes a channel of deferred string values, waits for each received deferred value, but only until the next deferred value comes over or the channel is closed. This example puts together &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/on-receive-or-null.html&quot;&gt;onReceiveOrNull&lt;/a&gt; and &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/on-await.html&quot;&gt;onAwait&lt;/a&gt; clauses in the same &lt;code&gt;select&lt;/code&gt;:</source>
          <target state="translated">遅延文字列値のチャネルを消費し、受信した各遅延値を待機するチャネルプロデューサー関数を記述してみましょう。ただし、次の遅延値が発生するか、チャネルが閉じられるまでのみです。この例プット一緒&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/on-receive-or-null.html&quot;&gt;onReceiveOrNull&lt;/a&gt;と&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/on-await.html&quot;&gt;onAwait&lt;/a&gt;同じで句 &lt;code&gt;select&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="4731fc0f08644e9fc8c26a8f5800aec92b69f2ee" translate="yes" xml:space="preserve">
          <source>Let us write an example of producer of integers that sends its values to a &lt;code&gt;side&lt;/code&gt; channel when the consumers on its primary channel cannot keep up with it:</source>
          <target state="translated">プライマリチャネルのコンシューマーが対応できない場合に、値を &lt;code&gt;side&lt;/code&gt; チャネルに送信する整数のプロデューサーの例を書いてみましょう。</target>
        </trans-unit>
        <trans-unit id="9ad40ae1c76d7921aa80d947aae7e4174122ffe9" translate="yes" xml:space="preserve">
          <source>Let's also make sure that our coroutines actually run in parallel. If we add a 1-second &lt;code&gt;delay()&lt;/code&gt; to each of the &lt;code&gt;async&lt;/code&gt;'s, the resulting program won't run for 1'000'000 seconds (over 11,5 days):</source>
          <target state="translated">また、コルーチンが実際に並行して実行されることを確認しましょう。各 &lt;code&gt;async&lt;/code&gt; に 1秒の &lt;code&gt;delay()&lt;/code&gt; を追加すると、結果のプログラムは1'000'000秒（11.5日以上）実行されません。</target>
        </trans-unit>
        <trans-unit id="d5f68d829cd771ce134770e031cf5bf3966ac35a" translate="yes" xml:space="preserve">
          <source>Let's assume in the code above that &lt;code&gt;preparePost&lt;/code&gt; is a long-running process and consequently would block the user interface. What we can do is launch it in a separate thread. This would then allow us to avoid the UI from blocking. This is a very common technique, but has a series of drawbacks:</source>
          <target state="translated">上記のコードで &lt;code&gt;preparePost&lt;/code&gt; が長時間実行されるプロセスであり、その結果ユーザーインターフェイスがブロックされると仮定しましょう。私たちができることは、別のスレッドでそれを起動することです。これにより、UIのブロックを回避できます。これは非常に一般的な手法ですが、一連の欠点があります。</target>
        </trans-unit>
        <trans-unit id="0b36e6d9aeacb6946bbe6f44c31eebe2f8d34c7f" translate="yes" xml:space="preserve">
          <source>Let's call the framework from Objective-C. For that we create the &lt;code&gt;main.m&lt;/code&gt; file with the following content:</source>
          <target state="translated">Objective-Cからフレームワークを呼び出しましょう。そのために、次の内容の &lt;code&gt;main.m&lt;/code&gt; ファイルを作成します。</target>
        </trans-unit>
        <trans-unit id="de2db89a9bd54d886863702055b65232c802ea65" translate="yes" xml:space="preserve">
          <source>Let's check out the C API of our Kotlin library.`</source>
          <target state="translated">Kotlin ライブラリの C API を見てみましょう。</target>
        </trans-unit>
        <trans-unit id="ccdc7274b76228eb418fb01b25e4e0b2b1a04fe1" translate="yes" xml:space="preserve">
          <source>Let's click on the &lt;code&gt;App&lt;/code&gt; run configuration to get our project running either on a real Android Device or on the emulator.</source>
          <target state="translated">&lt;code&gt;App&lt;/code&gt; 実行構成をクリックして、実際のAndroidデバイスまたはエミュレーターでプロジェクトを実行します。</target>
        </trans-unit>
        <trans-unit id="1f650b1ab54a0b4e48ce9f7def949cc9e4127516" translate="yes" xml:space="preserve">
          <source>Let's click the &lt;em&gt;Run&lt;/em&gt; button in Xcode, and we'll see our application running</source>
          <target state="translated">Xcodeの「&lt;em&gt;実行」&lt;/em&gt;ボタンをクリックしてみましょう。アプリケーションが実行されているのがわかります。</target>
        </trans-unit>
        <trans-unit id="735664d189535b1add7a525bb222b33a786f953e" translate="yes" xml:space="preserve">
          <source>Let's create a &lt;code&gt;src/nativeMain/kotlin/hello.kt&lt;/code&gt; stub file with the following content to see how C primitive type declarations are visible from Kotlin:</source>
          <target state="translated">次の内容で &lt;code&gt;src/nativeMain/kotlin/hello.kt&lt;/code&gt; スタブファイルを作成して、Cプリミティブ型宣言がKotlinからどのように見えるかを確認してみましょう。</target>
        </trans-unit>
        <trans-unit id="10159fd0817061a10325f96cf0c251b77597ee1f" translate="yes" xml:space="preserve">
          <source>Let's create a &lt;code&gt;src/nativeMain/kotlin/hello.kt&lt;/code&gt; stub file with the following content to see how our C declarations are visible from Kotlin:</source>
          <target state="translated">次の内容の &lt;code&gt;src/nativeMain/kotlin/hello.kt&lt;/code&gt; スタブファイルを作成して、C宣言がKotlinからどのように見えるかを確認してみましょう。</target>
        </trans-unit>
        <trans-unit id="a7acdfe9286fc908f1acf3c36443211f26fc104a" translate="yes" xml:space="preserve">
          <source>Let's create a million coroutines again, keeping their &lt;code&gt;Deferred&lt;/code&gt; objects. Now there's no need in the atomic counter, as we can just return the numbers to be added from our coroutines:</source>
          <target state="translated">&lt;code&gt;Deferred&lt;/code&gt; オブジェクトを保持したまま、100万個のコルーチンを作成してみましょう。これで、追加する数値をコルーチンから返すことができるため、アトミックカウンターは必要ありません。</target>
        </trans-unit>
        <trans-unit id="996aed5293f16fb62ea0b0ffc195f181e0ae218e" translate="yes" xml:space="preserve">
          <source>Let's create the class &lt;code&gt;Base64Test&lt;/code&gt; in &lt;code&gt;commonTest/kotlin/jetbrains/base64&lt;/code&gt; folder and write the basic tests for Base64.</source>
          <target state="translated">クラスを作成してみましょう &lt;code&gt;Base64Test&lt;/code&gt; をして &lt;code&gt;commonTest/kotlin/jetbrains/base64&lt;/code&gt; フォルダやBase64のための基本的なテストを書きます。</target>
        </trans-unit>
        <trans-unit id="bbdbbcfe4f2f14866b323983f8f8272c8a107004" translate="yes" xml:space="preserve">
          <source>Let's denote a function f(x) in such a way: we add 1 to x, then, while there is at least one trailing zero in the resulting number, we remove that zero.</source>
          <target state="translated">関数f(x)をこのように表してみましょう:xに1を加え、その結果として得られる数の最後に少なくとも1つのゼロがある間に、そのゼロを除去します。</target>
        </trans-unit>
        <trans-unit id="b41c2ae19915325ca1208b1c0d9b4b01df9a8df1" translate="yes" xml:space="preserve">
          <source>Let's dig a little into what it means. The biggest merit of coroutines is that they can &lt;em&gt;suspend&lt;/em&gt; without blocking a thread. The compiler has to emit some special code to make this possible, so we have to mark functions that &lt;em&gt;may suspend&lt;/em&gt; explicitly in the code. We use the &lt;code&gt;suspend&lt;/code&gt; modifier for it:</source>
          <target state="translated">それが何を意味するかを少し掘り下げましょう。コルーチンの最大のメリットは、スレッドをブロックせずに&lt;em&gt;中断&lt;/em&gt;できることです。これを可能にするには、コンパイラーが特別なコードを発行する必要があるため、コード内で明示的に&lt;em&gt;中断さ&lt;/em&gt;れる&lt;em&gt;可能性のある&lt;/em&gt;関数をマークする必要&lt;em&gt;が&lt;/em&gt;あります。そのために &lt;code&gt;suspend&lt;/code&gt; 修飾子を使用します。</target>
        </trans-unit>
        <trans-unit id="b909fa7b179bbce71ededd8361a6bf68ecb8e547" translate="yes" xml:space="preserve">
          <source>Let's extract the block of code inside &lt;code&gt;launch { ... }&lt;/code&gt; into a separate function. When you perform &quot;Extract function&quot; refactoring on this code you get a new function with &lt;code&gt;suspend&lt;/code&gt; modifier. That is your first &lt;em&gt;suspending function&lt;/em&gt;. Suspending functions can be used inside coroutines just like regular functions, but their additional feature is that they can, in turn, use other suspending functions, like &lt;code&gt;delay&lt;/code&gt; in this example, to &lt;em&gt;suspend&lt;/em&gt; execution of a coroutine.</source>
          <target state="translated">&lt;code&gt;launch { ... }&lt;/code&gt; 内のコードのブロックを別の関数に抽出してみましょう。このコードで「関数の抽出」リファクタリングを実行すると、 &lt;code&gt;suspend&lt;/code&gt; 修飾子を持つ新しい関数が得られます。これが最初の&lt;em&gt;一時停止機能&lt;/em&gt;です。一時停止関数は、通常の関数と同じようにコルーチン内で使用できますが、追加機能として、この例の &lt;code&gt;delay&lt;/code&gt; などの他の一時停止関数を使用して、コルーチンの実行を&lt;em&gt;一時停止でき&lt;/em&gt;ます。</target>
        </trans-unit>
        <trans-unit id="61bad05f01a2e90a1664c7ea21ea22130405aa4e" translate="yes" xml:space="preserve">
          <source>Let's extract the block of code inside &lt;code&gt;launch { ... }&lt;/code&gt; into a separate function. When you perform &quot;Extract function&quot; refactoring on this code, you get a new function with the &lt;code&gt;suspend&lt;/code&gt; modifier. This is your first &lt;em&gt;suspending function&lt;/em&gt;. Suspending functions can be used inside coroutines just like regular functions, but their additional feature is that they can, in turn, use other suspending functions (like &lt;code&gt;delay&lt;/code&gt; in this example) to &lt;em&gt;suspend&lt;/em&gt; execution of a coroutine.</source>
          <target state="translated">&lt;code&gt;launch { ... }&lt;/code&gt; 内のコードブロックを別の関数に抽出してみましょう。このコードで「関数の抽出」リファクタリングを実行すると、 &lt;code&gt;suspend&lt;/code&gt; 修飾子を使用して新しい関数を取得します。これは最初の&lt;em&gt;一時停止機能&lt;/em&gt;です。一時停止関数は、通常の関数と同じようにコルーチン内で使用できますが、追加の機能として、他の一時停止関数（この例では &lt;code&gt;delay&lt;/code&gt; など）を使用してコルーチンの実行を&lt;em&gt;一時停止でき&lt;/em&gt;ます。</target>
        </trans-unit>
        <trans-unit id="e7122eef62315ddd178e19521346dcd7b3d4f4ef" translate="yes" xml:space="preserve">
          <source>Let's first create a project folder. All the paths in this tutorial will be relative to this folder. Sometimes the missing directories will have to be created before new files are added.</source>
          <target state="translated">まず、プロジェクトフォルダを作成しましょう。このチュートリアルのすべてのパスは、このフォルダからの相対パスになります。時々、新しいファイルを追加する前に不足しているディレクトリを作成しなければならないことがあります。</target>
        </trans-unit>
        <trans-unit id="8cb38e1408559447345a86b525296d1eabcbbd05" translate="yes" xml:space="preserve">
          <source>Let's get straight to the point - type this into a file with the extension &lt;code&gt;.kt&lt;/code&gt;:</source>
          <target state="translated">ポイントにまっすぐに行きましょう-これを拡張子 &lt;code&gt;.kt&lt;/code&gt; のファイルに入力します：</target>
        </trans-unit>
        <trans-unit id="bd86f7e49e4cf62602c569422996655dedc19452" translate="yes" xml:space="preserve">
          <source>Let's include the dependency from the &lt;code&gt;SharedCode&lt;/code&gt; project to the Android project. We need to patch the &lt;code&gt;app/build.gradle&lt;/code&gt; file and include the following line into the &lt;code&gt;dependencies { .. }&lt;/code&gt; block:</source>
          <target state="translated">&lt;code&gt;SharedCode&lt;/code&gt; プロジェクトからAndroidプロジェクトへの依存関係を含めましょう。 &lt;code&gt;app/build.gradle&lt;/code&gt; ファイルにパッチを適用し、次の行を &lt;code&gt;dependencies { .. }&lt;/code&gt; ブロックに含める必要があります。</target>
        </trans-unit>
        <trans-unit id="3031affd63f3a34c70e027c9fb0083b3841cbbd1" translate="yes" xml:space="preserve">
          <source>Let's look at &lt;code&gt;async&lt;/code&gt;/&lt;code&gt;await&lt;/code&gt; which is implemented in an external library, &lt;a href=&quot;https://github.com/kotlin/kotlinx.coroutines&quot;&gt;kotlinx.coroutines&lt;/a&gt;:</source>
          <target state="translated">外部ライブラリ&lt;a href=&quot;https://github.com/kotlin/kotlinx.coroutines&quot;&gt;kotlinx.coroutinesに&lt;/a&gt;実装され &lt;code&gt;await&lt;/code&gt; いる &lt;code&gt;async&lt;/code&gt; / awaitを見てみましょう。</target>
        </trans-unit>
        <trans-unit id="957a84aa6afafd513ebe49ba72fc204fd5a6b335" translate="yes" xml:space="preserve">
          <source>Let's look at a full program that uses &lt;code&gt;launch&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;launch&lt;/code&gt; を使用する完全なプログラムを見てみましょう。</target>
        </trans-unit>
        <trans-unit id="4e571fdb95d6ede65232f8b540598b12acfcf120" translate="yes" xml:space="preserve">
          <source>Let's look over it to spot what has changed. In Java you annotated the field, binding it with the corresponding view:</source>
          <target state="translated">何が変わったのかを見てみましょう。Javaでは、フィールドにアノテーションを付け、対応するビューにバインドしていました。</target>
        </trans-unit>
        <trans-unit id="1fb40ced67af4648c46e396667df192d29c4d5c8" translate="yes" xml:space="preserve">
          <source>Let's make sure we can run the application on the iPhone emulator or device.</source>
          <target state="translated">iPhoneのエミュレータやデバイスでアプリを実行できることを確認してみましょう。</target>
        </trans-unit>
        <trans-unit id="4c1369d1fff2907e87dbe0e51a95a4a2b1d68308" translate="yes" xml:space="preserve">
          <source>Let's move the sources file into the &lt;code&gt;src/nativeMain/kotlin&lt;/code&gt; folder under the project. That is the default path, where sources are located, when the &lt;a href=&quot;../../reference/building-mpp-with-gradle&quot;&gt;kotlin-multiplatform&lt;/a&gt; plugin is used. We use the following block to instruct configure the project to generate a dynamic or shared library for us:</source>
          <target state="translated">sourcesファイルをプロジェクトの &lt;code&gt;src/nativeMain/kotlin&lt;/code&gt; フォルダーに移動します。これは、&lt;a href=&quot;../../reference/building-mpp-with-gradle&quot;&gt;kotlin-multiplatform&lt;/a&gt;プラグインが使用されている場合の、ソースが配置されているデフォルトのパスです。次のブロックを使用して、動的または共有ライブラリを生成するようにプロジェクトを構成します。</target>
        </trans-unit>
        <trans-unit id="254d91019bfe0a24fa67828566bb23aeecf078e8" translate="yes" xml:space="preserve">
          <source>Let's move the sources file into the &lt;code&gt;src/nativeMain/kotlin&lt;/code&gt; folder under the project. That is the default path, where sources are located, when the &lt;a href=&quot;../../reference/mpp-discover-project&quot;&gt;kotlin-multiplatform&lt;/a&gt; plugin is used. We use the following block to instruct configure the project to generate a dynamic or shared library for us:</source>
          <target state="translated">ソースファイルをプロジェクトの下の &lt;code&gt;src/nativeMain/kotlin&lt;/code&gt; フォルダーに移動しましょう。これは、&lt;a href=&quot;../../reference/mpp-discover-project&quot;&gt;kotlin-multiplatform&lt;/a&gt;プラグインが使用される場合の、ソースが配置されるデフォルトのパスです。次のブロックを使用して、動的ライブラリまたは共有ライブラリを生成するようにプロジェクトを構成するように指示します。</target>
        </trans-unit>
        <trans-unit id="684a72371b803184f7a1d16df5fdf49dd7a6a0de" translate="yes" xml:space="preserve">
          <source>Let's move the sources file into the &lt;code&gt;src/nativeMain/kotlin&lt;/code&gt; folder under the project. This is the default path, for where sources are located, when the &lt;a href=&quot;../../reference/building-mpp-with-gradle&quot;&gt;kotlin-multiplatform&lt;/a&gt; plugin is used. We use the following block to instruct and configure the project to generate a dynamic or shared library for us:</source>
          <target state="translated">sourcesファイルをプロジェクトの &lt;code&gt;src/nativeMain/kotlin&lt;/code&gt; フォルダーに移動します。これは、&lt;a href=&quot;../../reference/building-mpp-with-gradle&quot;&gt;kotlin-multiplatform&lt;/a&gt;プラグインを使用する場合の、ソースが配置されるデフォルトのパスです。次のブロックを使用して、動的または共有ライブラリを生成するようにプロジェクトに指示および構成します。</target>
        </trans-unit>
        <trans-unit id="034d9c3c346b06a98e0db9b883376985d9d3fdc3" translate="yes" xml:space="preserve">
          <source>Let's move the sources file into the &lt;code&gt;src/nativeMain/kotlin&lt;/code&gt; folder under the project. This is the default path, for where sources are located, when the &lt;a href=&quot;../../reference/mpp-discover-project&quot;&gt;kotlin-multiplatform&lt;/a&gt; plugin is used. We use the following block to instruct and configure the project to generate a dynamic or shared library for us:</source>
          <target state="translated">ソースファイルをプロジェクトの下の &lt;code&gt;src/nativeMain/kotlin&lt;/code&gt; フォルダーに移動しましょう。これは、&lt;a href=&quot;../../reference/mpp-discover-project&quot;&gt;kotlin-multiplatform&lt;/a&gt;プラグインが使用される場合の、ソースが配置されるデフォルトのパスです。次のブロックを使用して、動的ライブラリまたは共有ライブラリを生成するようにプロジェクトを指示および構成します。</target>
        </trans-unit>
        <trans-unit id="a942f64f48ea1ece8880513eaa81ddefeb619b0a" translate="yes" xml:space="preserve">
          <source>Let's replace &lt;code&gt;testSolution()&lt;/code&gt; function content with the following:</source>
          <target state="translated">&lt;code&gt;testSolution()&lt;/code&gt; 関数の内容を次のように置き換えましょう。</target>
        </trans-unit>
        <trans-unit id="4a173594d073c26a036c43463ffde9097189a153" translate="yes" xml:space="preserve">
          <source>Let's run a lot of them</source>
          <target state="translated">たくさん走らせましょう</target>
        </trans-unit>
        <trans-unit id="4b01757c4af3890b2686d482b6ad16159167a6f9" translate="yes" xml:space="preserve">
          <source>Let's run the &lt;code&gt;linkNative&lt;/code&gt; Gradle task to build the library &lt;a href=&quot;basic-kotlin-native-app#run-in-ide&quot;&gt;in the IDE&lt;/a&gt; or by calling the following console command:</source>
          <target state="translated">&lt;code&gt;linkNative&lt;/code&gt; Gradleタスクを実行&lt;a href=&quot;basic-kotlin-native-app#run-in-ide&quot;&gt;して、IDEで&lt;/a&gt;ライブラリをビルドするか、次のコンソールコマンドを呼び出します。</target>
        </trans-unit>
        <trans-unit id="106249141867c6b57bd6484ccdc821cb560f7f5d" translate="yes" xml:space="preserve">
          <source>Let's run the &lt;code&gt;linkNative&lt;/code&gt; Gradle task to build the library &lt;a href=&quot;using-intellij-idea&quot;&gt;in the IDE&lt;/a&gt; or by calling the following console command:</source>
          <target state="translated">&lt;code&gt;linkNative&lt;/code&gt; Gradleタスクを実行&lt;a href=&quot;using-intellij-idea&quot;&gt;して、IDEで&lt;/a&gt;ライブラリをビルドするか、次のコンソールコマンドを呼び出します。</target>
        </trans-unit>
        <trans-unit id="0027507ed05fb5770a6709f41c759d4f8b675c55" translate="yes" xml:space="preserve">
          <source>Let's run the &lt;code&gt;linkNative&lt;/code&gt; Gradle task to build the library in the IDE or by calling the following console command:</source>
          <target state="translated">&lt;code&gt;linkNative&lt;/code&gt; Gradleタスクを実行して、IDEでライブラリをビルドするか、次のコンソールコマンドを呼び出します。</target>
        </trans-unit>
        <trans-unit id="ced335cd9fa401cb82913f0326e2577c06919225" translate="yes" xml:space="preserve">
          <source>Let's say that you're writing a simple ORM. Your database library represents a row as instances of a class &lt;code&gt;Entity&lt;/code&gt;, with functions like &lt;code&gt;getString(&quot;name&quot;)&lt;/code&gt; and &lt;code&gt;getLong(&quot;age&quot;)&lt;/code&gt; for getting typed values from the given columns. We could create a typed wrapper class like this:</source>
          <target state="translated">単純なORMを作成しているとしましょう。データベースライブラリは、行をクラス &lt;code&gt;Entity&lt;/code&gt; のインスタンスとして表し、指定された列から型付き値を取得するための &lt;code&gt;getString(&quot;name&quot;)&lt;/code&gt; や &lt;code&gt;getLong(&quot;age&quot;)&lt;/code&gt; などの関数を備えています。次のような型付きラッパークラスを作成できます。</target>
        </trans-unit>
        <trans-unit id="a18f6d560df8733728d2795ff272c64a409b9516" translate="yes" xml:space="preserve">
          <source>Let's say we need to return two things from a function. For example, a result object and a status of some sort. A compact way of doing this in Kotlin is to declare a &lt;a href=&quot;data-classes&quot;&gt;&lt;em&gt;data class&lt;/em&gt;&lt;/a&gt; and return its instance:</source>
          <target state="translated">関数から2つのものを返す必要があるとしましょう。たとえば、結果オブジェクトとある種のステータス。Kotlinでこれを行うコンパクトな方法は、&lt;a href=&quot;data-classes&quot;&gt;&lt;em&gt;データクラス&lt;/em&gt;&lt;/a&gt;を宣言してそのインスタンスを返すことです。</target>
        </trans-unit>
        <trans-unit id="8eba6223ee182cc016df2825ffe27a1806c3d5dd" translate="yes" xml:space="preserve">
          <source>Let's see how &lt;code&gt;class&lt;/code&gt; and &lt;code&gt;object&lt;/code&gt; are mapped to Objective-C and Swift. The generated &lt;code&gt;&amp;lt;Framework&amp;gt;/Headers/Demo.h&lt;/code&gt; file contains the exact definitions for &lt;code&gt;Class&lt;/code&gt;, &lt;code&gt;Interface&lt;/code&gt;, and &lt;code&gt;Object&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;class&lt;/code&gt; と &lt;code&gt;object&lt;/code&gt; がどのようにObjective-CとSwiftにマッピングされるか見てみましょう。生成された &lt;code&gt;&amp;lt;Framework&amp;gt;/Headers/Demo.h&lt;/code&gt; ファイルには、 &lt;code&gt;Class&lt;/code&gt; 、 &lt;code&gt;Interface&lt;/code&gt; 、および &lt;code&gt;Object&lt;/code&gt; の正確な定義が含まれています。</target>
        </trans-unit>
        <trans-unit id="2abb7f43d07915bd385a08f6f8eca1904f202535" translate="yes" xml:space="preserve">
          <source>Let's see now &lt;code&gt;CValue&amp;lt;T&amp;gt;&lt;/code&gt; is turned to a pointer first:</source>
          <target state="translated">&lt;code&gt;CValue&amp;lt;T&amp;gt;&lt;/code&gt; が最初にポインターになっているところを見てみましょう。</target>
        </trans-unit>
        <trans-unit id="0da8a1853bc3aa9296a82e748b06afcd60c8ff39" translate="yes" xml:space="preserve">
          <source>Let's summarize what we have in the table:</source>
          <target state="translated">表にあるものをまとめてみましょう。</target>
        </trans-unit>
        <trans-unit id="29489a663f002abc7aabbc10da61ddf3922c9137" translate="yes" xml:space="preserve">
          <source>Let's switch back to the Android Studio and execute the &lt;code&gt;build&lt;/code&gt; target of the &lt;code&gt;SharedCode&lt;/code&gt; project from the &lt;em&gt;Gradle&lt;/em&gt; tool window. The task looks for environment variables set by the Xcode build and copies the right variant of the framework into the &lt;code&gt;SharedCode/build/xcode-frameworks&lt;/code&gt; folder. We then include the framework from that folder into the build</source>
          <target state="translated">Android Studioに切り替えて、&lt;em&gt;Gradle&lt;/em&gt;ツールウィンドウから &lt;code&gt;SharedCode&lt;/code&gt; プロジェクトの &lt;code&gt;build&lt;/code&gt; ターゲットを実行します。タスクは、Xcodeビルドによって設定された環境変数を探し、フレームワークの適切なバリアントを &lt;code&gt;SharedCode/build/xcode-frameworks&lt;/code&gt; フォルダーにコピーします。次に、そのフォルダーのフレームワークをビルドに含めます&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="aa5c06386e1b74a742a7f7576c52eff2fd2031ee" translate="yes" xml:space="preserve">
          <source>Let's take a look at Kotlin runtime declarations first:</source>
          <target state="translated">まずはKotlinのランタイム宣言を見てみましょう。</target>
        </trans-unit>
        <trans-unit id="0d3a04db62b13c25688a0e50c618e3bec15eb02a" translate="yes" xml:space="preserve">
          <source>Let's take a look at a concrete example.</source>
          <target state="translated">具体的な例を見てみましょう。</target>
        </trans-unit>
        <trans-unit id="d83be9a947c4ef371bac95dfdb52ba3f51a09f86" translate="yes" xml:space="preserve">
          <source>Let's take a look at the &lt;code&gt;kotlin.root.example&lt;/code&gt; field, it mimics the package structure of our Kotlin code with a &lt;code&gt;kotlin.root.&lt;/code&gt; prefix.</source>
          <target state="translated">&lt;code&gt;kotlin.root.example&lt;/code&gt; フィールドを見てみましょう &lt;code&gt;kotlin.root.&lt;/code&gt; は、kotlin.rootを使用してKotlinコードのパッケージ構造を模倣しています。接頭辞。</target>
        </trans-unit>
        <trans-unit id="7a1c41eab269c88a145c3bcd2eacac0f706a1202" translate="yes" xml:space="preserve">
          <source>Let's take a look at the difference between &lt;code&gt;Iterable&lt;/code&gt; and &lt;code&gt;Sequence&lt;/code&gt; with an example.</source>
          <target state="translated">&lt;code&gt;Iterable&lt;/code&gt; と &lt;code&gt;Sequence&lt;/code&gt; の違いを例で見てみましょう。</target>
        </trans-unit>
        <trans-unit id="683ff410a92468b732cdb32c98685fb25b7caa78" translate="yes" xml:space="preserve">
          <source>Let's take a look at the generated functions that take our &lt;code&gt;MyStruct&lt;/code&gt; and &lt;code&gt;MyUnion&lt;/code&gt; as parameters. We see that by-value parameters are represented as &lt;code&gt;kotlinx.cinterop.CValue&amp;lt;T&amp;gt;&lt;/code&gt;. And for typed pointer parameters we see &lt;code&gt;kotlinx.cinterop.CValuesRef&amp;lt;T&amp;gt;&lt;/code&gt;. Kotlin provides us with an API to deal with both types easily, let's try it and see.</source>
          <target state="translated">&lt;code&gt;MyStruct&lt;/code&gt; と &lt;code&gt;MyUnion&lt;/code&gt; をパラメーターとして取る生成された関数を見てみましょう。値 &lt;code&gt;kotlinx.cinterop.CValue&amp;lt;T&amp;gt;&lt;/code&gt; パラメーターがkotlinx.cinterop.CValue &amp;lt;T&amp;gt;として表されていることがわかります。また、型付きポインターパラメーターの場合、 &lt;code&gt;kotlinx.cinterop.CValuesRef&amp;lt;T&amp;gt;&lt;/code&gt; 表示されます。Kotlinは、両方のタイプを簡単に処理するためのAPIを提供しています。試して見てみましょう。</target>
        </trans-unit>
        <trans-unit id="640f277dd088f13964789f8075c590d21d6b9dfc" translate="yes" xml:space="preserve">
          <source>Let's take pipelines to the extreme with an example that generates prime numbers using a pipeline of coroutines. We start with an infinite sequence of numbers.</source>
          <target state="translated">パイプラインを極端にして、コアーチンのパイプラインを使って素数を生成する例を挙げてみましょう。まず、無限の数列から始めます。</target>
        </trans-unit>
        <trans-unit id="3a85f4e1e0328af1a77f3960a6412ca2106e30f9" translate="yes" xml:space="preserve">
          <source>Let's try the same with coroutines:</source>
          <target state="translated">コルチンでも同じようにやってみましょう。</target>
        </trans-unit>
        <trans-unit id="7edcd7d839fe1e0dfdcd3a0fe161ec6c231e6fb0" translate="yes" xml:space="preserve">
          <source>Let's try to use the API from Kotlin. Let's call &lt;code&gt;pass_string&lt;/code&gt; first:</source>
          <target state="translated">KotlinのAPIを使ってみましょう。最初に &lt;code&gt;pass_string&lt;/code&gt; を呼び出しましょう：</target>
        </trans-unit>
        <trans-unit id="0627f0965e7ec33cbf1e065c2d05108d4f888350" translate="yes" xml:space="preserve">
          <source>Let's update the Gradle scripts now to implement that and configure our IDE.</source>
          <target state="translated">それでは、Gradleスクリプトを更新して実装し、IDEを設定してみましょう。</target>
        </trans-unit>
        <trans-unit id="cd1102ed7118f5a51e4a3d98942ad07717eaabd4" translate="yes" xml:space="preserve">
          <source>Let's use it with channel &lt;code&gt;a&lt;/code&gt; that produces &quot;Hello&quot; string four times and channel &lt;code&gt;b&lt;/code&gt; that produces &quot;World&quot; four times:</source>
          <target state="translated">チャネルで使用してみましょう &lt;code&gt;a&lt;/code&gt; 「こんにちは」の文字列の4倍とチャネル生成 &lt;code&gt;b&lt;/code&gt; 4回「世界」を生成します。</target>
        </trans-unit>
        <trans-unit id="9dbe6646e8e9a0c1dd5558c986bbdc08c0c317a1" translate="yes" xml:space="preserve">
          <source>Let's walk through the interfaces and their implementations.</source>
          <target state="translated">インターフェイスとその実装を見ていきましょう。</target>
        </trans-unit>
        <trans-unit id="83d65fd8bdf3a04f906b52d7b1ba67e299c6332e" translate="yes" xml:space="preserve">
          <source>Let's walk through the mechanisms of implementing type-safe builders in Kotlin. First of all, we need to define the model we want to build, in this case we need to model HTML tags. It is easily done with a bunch of classes. For example, &lt;code&gt;HTML&lt;/code&gt; is a class that describes the &lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt; tag, i.e. it defines children like &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt;. (See its declaration &lt;a href=&quot;#full-definition-of-the-comexamplehtml-package&quot;&gt;below&lt;/a&gt;.)</source>
          <target state="translated">Kotlinでタイプセーフなビルダーを実装するメカニズムについて見ていきましょう。まず、構築するモデルを定義する必要があります。この場合は、HTMLタグをモデル化する必要があります。たくさんのクラスで簡単にできます。たとえば、 &lt;code&gt;HTML&lt;/code&gt; は &lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt; タグを記述するクラスです。つまり、HTMLは &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; や &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt; などの子を定義します。 （&lt;a href=&quot;#full-definition-of-the-comexamplehtml-package&quot;&gt;以下の&lt;/a&gt;宣言を参照してください。）</target>
        </trans-unit>
        <trans-unit id="7c7f5d049fad2569721d446c4a811f9bd5da5393" translate="yes" xml:space="preserve">
          <source>Level</source>
          <target state="translated">Level</target>
        </trans-unit>
        <trans-unit id="27c968e6692b41bf6e1a241b870dc41ff1a51b17" translate="yes" xml:space="preserve">
          <source>Libraries</source>
          <target state="translated">Libraries</target>
        </trans-unit>
        <trans-unit id="00f72e56b5ae78fda32dcd4978d25a113af870e2" translate="yes" xml:space="preserve">
          <source>Library authors can use the @Deprecated and &lt;a href=&quot;../opt-in-requirements&quot;&gt;@RequiresOptIn&lt;/a&gt; annotations to control the evolution of their API surface. Note that @Deprecated(level=HIDDEN) can be used to preserve binary compatibility even for declarations removed from the API.</source>
          <target state="translated">ライブラリの作成者は、@ Deprecatedおよび&lt;a href=&quot;../opt-in-requirements&quot;&gt;@RequiresOptIn&lt;/a&gt;アノテーションを使用して、APIサーフェスの進化を制御できます。@Deprecated（level = HIDDEN）を使用すると、APIから削除された宣言であっても、バイナリ互換性を維持できることに注意してください。</target>
        </trans-unit>
        <trans-unit id="74fbbbbc56ff7a0c7c22c830abedb5e3565e5058" translate="yes" xml:space="preserve">
          <source>Library authors can use the @Deprecated and @Experimental annotations to control the evolution of their API surface. Note that @Deprecated(level=HIDDEN) can be used to preserve binary compatibility even for declarations removed from the API.</source>
          <target state="translated">ライブラリの作者は、@Deprecatedアノテーションと@Experimentalアノテーションを使用して、API表面の進化を制御することができます。Deprecated(level=HIDDEN)は、APIから削除された宣言に対してもバイナリ互換性を維持するために使用できることに注意してください。</target>
        </trans-unit>
        <trans-unit id="0405ca8057bdd26aa8a71ed5b78eaef11cd20a80" translate="yes" xml:space="preserve">
          <source>Library code should always specify return types of public/protected functions and properties explicitly thus never relying on type inference for public API. Subtle changes in type inference may cause return types to change inadvertently, leading to binary compatibility issues.</source>
          <target state="translated">ライブラリコードでは、公開/保護された関数やプロパティの戻り値の型を常に明示的に指定しなければなりませんので、公開APIの型推論には決して依存しません。型推論の微妙な変更は、うっかりリターン型を変更してしまい、バイナリ互換性の問題につながる可能性があります。</target>
        </trans-unit>
        <trans-unit id="2fc01b5cc1b2ec00feddd7cb533ccfb023b55321" translate="yes" xml:space="preserve">
          <source>Library search sequence</source>
          <target state="translated">ライブラリ検索シーケンス</target>
        </trans-unit>
        <trans-unit id="141acdd651d31f900ce141517e6e5b768c6f9865" translate="yes" xml:space="preserve">
          <source>Library support for the Kotlin annotation facility.</source>
          <target state="translated">Kotlin注釈機能のライブラリサポート。</target>
        </trans-unit>
        <trans-unit id="ec793eb7fd1d6c9106d97e622f4fcbf89e666960" translate="yes" xml:space="preserve">
          <source>Licensed under the Apache License, Version 2.0.</source>
          <target state="translated">Apache License,Version 2.0の下でライセンスされています。</target>
        </trans-unit>
        <trans-unit id="8ca0dc8586d3cb640a4422d4f36e3b18f79a2fc2" translate="yes" xml:space="preserve">
          <source>Like Java's, Kotlin's generics are not retained at runtime, i.e. objects do not carry information about actual type arguments passed to their constructors, i.e. &lt;code&gt;ArrayList&amp;lt;Integer&amp;gt;()&lt;/code&gt; is indistinguishable from &lt;code&gt;ArrayList&amp;lt;Character&amp;gt;()&lt;/code&gt;. This makes it impossible to perform &lt;em&gt;is&lt;/em&gt;-checks that take generics into account. Kotlin only allows &lt;em&gt;is&lt;/em&gt;-checks for star-projected generic types:</source>
          <target state="translated">Javaと同様に、Kotlinのジェネリックは実行時に保持されません。つまり、オブジェクトはコンストラクターに渡される実際の型引数に関する情報を保持しません。つまり、 &lt;code&gt;ArrayList&amp;lt;Integer&amp;gt;()&lt;/code&gt; は &lt;code&gt;ArrayList&amp;lt;Character&amp;gt;()&lt;/code&gt; と区別できません。これにより、ジェネリックを考慮した&lt;em&gt;is&lt;/em&gt;チェックを実行できなくなります。Kotlin &lt;em&gt;は&lt;/em&gt;、スター投影されたジェネリック型の&lt;em&gt;is&lt;/em&gt; -checks のみを許可します。</target>
        </trans-unit>
        <trans-unit id="134fca0c09908f36860692b90dc834d35d2666e9" translate="yes" xml:space="preserve">
          <source>Like in Python, functions in Kotlin are first-class values - they can be assigned to variables and passed around as parameters. The type a function is a &lt;em&gt;function type&lt;/em&gt;, which is indicated with a parenthesized parameter type list and an arrow to the return type. Consider this function:</source>
          <target state="translated">Pythonと同様に、Kotlinの関数は一流の値です。これらは変数に割り当てられ、パラメーターとして渡されます。&lt;em&gt;関数の型&lt;/em&gt;は&lt;em&gt;関数の型&lt;/em&gt;であり、括弧で囲まれたパラメーターの型リストと戻り値の型への矢印で示されます。この関数を考えてみましょう：</target>
        </trans-unit>
        <trans-unit id="4ddd56354c9749dcb1f4e69de6ab93bcbbe060ca" translate="yes" xml:space="preserve">
          <source>Like in Python, statements may be terminated by a semicolon, but it's discouraged. There is no line continuation character; instead, a line is automatically joined with one or more of the subsequent lines if that's the only way to make the code parse correctly. In practice, that means that a statement continues on the next line if we're inside an open parenthesis (like in Python), or if the line ends with a &quot;dangling operator&quot; (unlike in Python) or the following line doesn't parse unless it's joined to the previous one (also unlike in Python). Note that this is pretty much &lt;a href=&quot;https://stackoverflow.com/questions/2846283/what-are-the-rules-for-javascripts-automatic-semicolon-insertion-asi#2846298&quot;&gt;the opposite of JavaScript&lt;/a&gt;, which generally will keep joining lines as long as the resulting code still parses. Thus, the following is two expressions in Kotlin and in Python (because &lt;code&gt;+&lt;/code&gt; can be unary, so the second line parses on its own), but one in JavaScript:</source>
          <target state="translated">Pythonと同様に、ステートメントはセミコロンで終了する場合がありますが、お勧めしません。行継続文字はありません。代わりに、コードを正しく解析する唯一の方法である場合、行は後続の1つ以上の行と自動的に結合されます。実際には、それは、（Pythonのように）左括弧の中にいる場合、または行が「ダングリングオペレーター」で終わる場合（Pythonの場合とは異なります）、または次の行が次の行にない場合、次の行に続くことを意味します。前のものに結合されていない限り解析します（これもPythonとは異なります）。これは&lt;a href=&quot;https://stackoverflow.com/questions/2846283/what-are-the-rules-for-javascripts-automatic-semicolon-insertion-asi#2846298&quot;&gt;JavaScriptの反対で&lt;/a&gt;あることに注意してください。JavaScriptは通常、結果のコードが解析される限り、行を結合し続けます。したがって、次はKotlinとPythonの2つの式です（ &lt;code&gt;+&lt;/code&gt; 単項の場合もあるため、2行目はそれ自体で解析されますが、JavaScriptでは1行です。</target>
        </trans-unit>
        <trans-unit id="36d262d6365f0d350e9446c742577b066fb40895" translate="yes" xml:space="preserve">
          <source>Like in Python, you can write &lt;em&gt;lambda expressions&lt;/em&gt;: unnamed function declarations with a very compact syntax, which evaluate to callable function objects. In Kotlin, lambdas can contain multiple statements, which make them useful for &lt;a href=&quot;functional-programming#receivers&quot;&gt;more complex tasks&lt;/a&gt; than the single-expression lambdas of Python. The last statement must be an expression, whose result will become the return value of the lambda (unless &lt;code&gt;Unit&lt;/code&gt; is the return type of the variable/parameter that the lambda expression is assigned to, in which case the lambda has no return value). A lambda expression is enclosed in curly braces, and begins by listing its parameter names and possibly their types (unless the types can be inferred from context):</source>
          <target state="translated">Pythonの場合と同様に、&lt;em&gt;ラムダ式&lt;/em&gt;を記述できます。非常にコンパクトな構文を使用した名前のない関数宣言であり、呼び出し可能な関数オブジェクトとして評価されます。Kotlinでは、ラムダに複数のステートメントを含めることができるため、Pythonの単一式ラムダよりも&lt;a href=&quot;functional-programming#receivers&quot;&gt;複雑なタスクに&lt;/a&gt;役立ちます。最後のステートメントは式である必要があり、その結果はラムダの戻り値になります（ただし、 &lt;code&gt;Unit&lt;/code&gt; がラムダ式が割り当てられている変数/パラメーターの戻り値の型である場合を除きます。この場合、ラムダには戻り値がありません）。ラムダ式は中括弧で囲まれ、パラメーター名と、場合によってはそれらのタイプをリストすることから始まります（コンテキストからタイプを推測できない場合）。</target>
        </trans-unit>
        <trans-unit id="4ee83e74db24116986fa00ee2921b9703634e255" translate="yes" xml:space="preserve">
          <source>Like numbers, characters are boxed when a nullable reference is needed. Identity is not preserved by the boxing operation.</source>
          <target state="translated">数字と同様に、文字はヌル可能な参照が必要な場合に箱詰めされます。箱詰めの操作では同一性は保持されません。</target>
        </trans-unit>
        <trans-unit id="dc3b674f534270e494afa035103eb57b636704df" translate="yes" xml:space="preserve">
          <source>Likewise, if a multiplatform library is published in the experimental &lt;a href=&quot;#experimental-metadata-publishing-mode&quot;&gt;Gradle metadata publishing mode&lt;/a&gt; and the project is set up to consume the metadata as well, then it is enough to specify a dependency only once, for the common source set. Otherwise, each platform-specific source set should be provided with a corresponding platform module of the library, in addition to the common module, as shown above.</source>
          <target state="translated">同様に、マルチプラットフォームライブラリが試験的な&lt;a href=&quot;#experimental-metadata-publishing-mode&quot;&gt;Gradleメタデータ公開モードで&lt;/a&gt;公開され、プロジェクトがメタデータも使用するように設定されている場合、共通のソースセットに対して依存関係を1回だけ指定するだけで十分です。それ以外の場合は、上記のように、各プラットフォーム固有のソースセットに、共通モジュールに加えて、ライブラリの対応するプラットフォームモジュールを提供する必要があります。</target>
        </trans-unit>
        <trans-unit id="a7c04c64ed3f2a9374590c76c50d3b7f1b18e3da" translate="yes" xml:space="preserve">
          <source>Limitations</source>
          <target state="translated">Limitations</target>
        </trans-unit>
        <trans-unit id="f8233d6f380a149df94d518228f2e14afd396052" translate="yes" xml:space="preserve">
          <source>Linear search</source>
          <target state="translated">線形検索</target>
        </trans-unit>
        <trans-unit id="b867f8dc43342a216856620ba5a0d8c96b534757" translate="yes" xml:space="preserve">
          <source>Link the library into the application</source>
          <target state="translated">ライブラリをアプリケーションにリンクする</target>
        </trans-unit>
        <trans-unit id="0084b300581a4369f50268c2c401f96431ea7f31" translate="yes" xml:space="preserve">
          <source>LinkStyle</source>
          <target state="translated">LinkStyle</target>
        </trans-unit>
        <trans-unit id="07410b317023eeb58eba0c065fa4e8416575a68f" translate="yes" xml:space="preserve">
          <source>LinkedHashMap</source>
          <target state="translated">LinkedHashMap</target>
        </trans-unit>
        <trans-unit id="9e6a957a7c69081b233af13d7e01702499988584" translate="yes" xml:space="preserve">
          <source>LinkedHashSet</source>
          <target state="translated">LinkedHashSet</target>
        </trans-unit>
        <trans-unit id="778915b1ca69b860077b72be4fd2810162ac2e59" translate="yes" xml:space="preserve">
          <source>Linking to Elements</source>
          <target state="translated">要素へのリンク</target>
        </trans-unit>
        <trans-unit id="ff0484f6287dafcb08eb0a886ac73a7153824af7" translate="yes" xml:space="preserve">
          <source>Linux (x86_64, arm32, MIPS, MIPS little endian, Raspberry Pi)</source>
          <target state="translated">Linux (x86_64,arm32,MIPS,MIPSリトルエンディアン,Raspberry Pi)</target>
        </trans-unit>
        <trans-unit id="c8306ed1ec95ef01523eab6c3a95dbeb9f6511fb" translate="yes" xml:space="preserve">
          <source>Linux (x86_64, arm32, arm64, MIPS, MIPS little endian)</source>
          <target state="translated">Linux (x86_64,arm32,arm64,MIPS,MIPSリトルエンディアン)</target>
        </trans-unit>
        <trans-unit id="430e92ad771f5c7d80b45e64d2d47aa39cd97e1b" translate="yes" xml:space="preserve">
          <source>Linux MIPS targets (&lt;code&gt;linuxMips32&lt;/code&gt; and &lt;code&gt;linuxMipsel32&lt;/code&gt;) require a Linux host. Other Linux targets can be built on any supported host;</source>
          <target state="translated">Linux MIPSターゲット（ &lt;code&gt;linuxMips32&lt;/code&gt; および &lt;code&gt;linuxMipsel32&lt;/code&gt; ）にはLinuxホストが必要です。その他のLinuxターゲットは、サポートされている任意のホスト上に構築できます。</target>
        </trans-unit>
        <trans-unit id="bfb299cccd6e6b52b05aad6a92f9e230c0c907cf" translate="yes" xml:space="preserve">
          <source>Linux: &lt;code&gt;libnative_api.h&lt;/code&gt; and &lt;code&gt;libnative.so&lt;/code&gt;</source>
          <target state="translated">Linux： &lt;code&gt;libnative_api.h&lt;/code&gt; および &lt;code&gt;libnative.so&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a1fffaaafb7cc996685bceb829c053cc4f7de43d" translate="yes" xml:space="preserve">
          <source>List</source>
          <target state="translated">List</target>
        </trans-unit>
        <trans-unit id="1cf922153258f477bc71540c57fe2b01a501cd22" translate="yes" xml:space="preserve">
          <source>List Specific Operations</source>
          <target state="translated">特定の操作をリストアップ</target>
        </trans-unit>
        <trans-unit id="a159771f6ea4355d13f8450d01c0373e1562c782" translate="yes" xml:space="preserve">
          <source>List elements (including nulls) can duplicate: a list can contain any number of equal objects or occurrences of a single object. Two lists are considered equal if they have the same sizes and &lt;a href=&quot;equality#structural-equality&quot;&gt;structurally equal&lt;/a&gt; elements at the same positions.</source>
          <target state="translated">リスト要素（nullを含む）は複製できます。リストには、任意の数の等しいオブジェクトまたは単一のオブジェクトのオカレンスを含めることができます。 2つのリストは、同じサイズで同じ位置に&lt;a href=&quot;equality#structural-equality&quot;&gt;構造的に等しい&lt;/a&gt;要素がある場合、等しいと見なされます。</target>
        </trans-unit>
        <trans-unit id="06c25d6b7dd57683933b41c5deaf09d2d0ac5990" translate="yes" xml:space="preserve">
          <source>List iterators</source>
          <target state="translated">リストイテレータ</target>
        </trans-unit>
        <trans-unit id="18c411381841a95d683318d92c209a2833825015" translate="yes" xml:space="preserve">
          <source>List write operations</source>
          <target state="translated">リスト書き込み操作</target>
        </trans-unit>
        <trans-unit id="7c5f57edf1aaa5196cbc6ba79770c80aef15f3e5" translate="yes" xml:space="preserve">
          <source>List.listIterator</source>
          <target state="translated">List.listIterator</target>
        </trans-unit>
        <trans-unit id="48fb7de1e7f4ec62a77ab4aa73ec82916ebe8c3e" translate="yes" xml:space="preserve">
          <source>ListIterator</source>
          <target state="translated">ListIterator</target>
        </trans-unit>
        <trans-unit id="a204aa282b7f9617db30e92246b8efaf427d19cd" translate="yes" xml:space="preserve">
          <source>Lists also offer a function to replace an element at a given position - &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-mutable-list/set&quot;&gt;&lt;code&gt;set()&lt;/code&gt;&lt;/a&gt; and its operator form &lt;code&gt;[]&lt;/code&gt;. &lt;code&gt;set()&lt;/code&gt; doesn't change the indexes of other elements.</source>
          <target state="translated">リストは、指定された位置にある要素を置き換える関数も提供します-set &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-mutable-list/set&quot;&gt; &lt;code&gt;set()&lt;/code&gt; &lt;/a&gt;とその演算子形式 &lt;code&gt;[]&lt;/code&gt; 。 &lt;code&gt;set()&lt;/code&gt; は他の要素のインデックスを変更しません。</target>
        </trans-unit>
        <trans-unit id="d5a0dae9f70ca77cfff82765784d806c80043676" translate="yes" xml:space="preserve">
          <source>Lists and maps also provide operations for updating elements. They are described in &lt;a href=&quot;list-operations&quot;&gt;List Specific Operations&lt;/a&gt; and &lt;a href=&quot;map-operations&quot;&gt;Map Specific Operations&lt;/a&gt;. For sets, updating doesn't make sense since it's actually removing an element and adding another one.</source>
          <target state="translated">リストとマップは、要素を更新するための操作も提供します。これらについては、&lt;a href=&quot;list-operations&quot;&gt;リスト固有の操作&lt;/a&gt;と&lt;a href=&quot;map-operations&quot;&gt;マップ固有の操作で説明してい&lt;/a&gt;ます。セットの場合、更新は実際には要素を削除して別の要素を追加するため、意味がありません。</target>
        </trans-unit>
        <trans-unit id="290d0482de491a9f1d45c4e717b747b40f336dfe" translate="yes" xml:space="preserve">
          <source>Lists and sets also provide operations for updating elements. They are described in &lt;a href=&quot;list-operations&quot;&gt;List Specific Operations&lt;/a&gt; and &lt;a href=&quot;map-operations&quot;&gt;Map Specific Operations&lt;/a&gt;. For sets, updating doesn't make sense since it's actually removing an element and adding another one.</source>
          <target state="translated">リストとセットは、要素を更新するための操作も提供します。これらについては、&lt;a href=&quot;list-operations&quot;&gt;リスト固有の操作&lt;/a&gt;と&lt;a href=&quot;map-operations&quot;&gt;マップ固有の操作で説明してい&lt;/a&gt;ます。セットの場合、実際には要素を削除して別の要素を追加するため、更新しても意味がありません。</target>
        </trans-unit>
        <trans-unit id="f70b0e65f09114560be2730b53b6dbbae2e2bd80" translate="yes" xml:space="preserve">
          <source>Lists support all common operations for element retrieval: &lt;code&gt;elementAt()&lt;/code&gt;, &lt;code&gt;first()&lt;/code&gt;, &lt;code&gt;last()&lt;/code&gt;, and others listed in &lt;a href=&quot;collection-elements&quot;&gt;Retrieving Single Elements&lt;/a&gt;. What is specific for lists is index access to the elements, so the simplest way to read an element is retrieving it by index. That is done with the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-list/get&quot;&gt;&lt;code&gt;get()&lt;/code&gt;&lt;/a&gt; function with the index passed in the argument or the shorthand &lt;code&gt;[index]&lt;/code&gt; syntax.</source>
          <target state="translated">リストは、要素取得のすべての一般的な操作をサポートします &lt;code&gt;elementAt()&lt;/code&gt; 、 &lt;code&gt;first()&lt;/code&gt; 、 &lt;code&gt;last()&lt;/code&gt; 、および&lt;a href=&quot;collection-elements&quot;&gt;単一要素の取得に&lt;/a&gt;リストされているその他の操作です。リストに固有なのは、要素へのインデックスアクセスであるため、要素を読み取る最も簡単な方法は、要素をインデックスで取得することです。これは、引数で渡されたインデックスを使用した&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-list/get&quot;&gt; &lt;code&gt;get()&lt;/code&gt; &lt;/a&gt;関数または短縮形の &lt;code&gt;[index]&lt;/code&gt; 構文で行われます。</target>
        </trans-unit>
        <trans-unit id="1b8cc7b0ac11bf88cf97ed5fc81444ae44893988" translate="yes" xml:space="preserve">
          <source>Literal Constants</source>
          <target state="translated">リテラル定数</target>
        </trans-unit>
        <trans-unit id="4da0019bff16f0b757af8c7d691632f05ab7ce73" translate="yes" xml:space="preserve">
          <source>Literal constants</source>
          <target state="translated">リテラル定数</target>
        </trans-unit>
        <trans-unit id="c7ba7dcf662374aafe652b03d75cb8f6024519d9" translate="yes" xml:space="preserve">
          <source>Literals</source>
          <target state="translated">Literals</target>
        </trans-unit>
        <trans-unit id="a354c605a19a501459267f5d2d15e3813a2622ea" translate="yes" xml:space="preserve">
          <source>Local Delegated Properties (since 1.1)</source>
          <target state="translated">ローカル委任プロパティ (1.1 以降)</target>
        </trans-unit>
        <trans-unit id="f5689c7ad8ad393161f3aa4e09dcfcbe8dae0b7c" translate="yes" xml:space="preserve">
          <source>Local Functions</source>
          <target state="translated">ローカル機能</target>
        </trans-unit>
        <trans-unit id="d7250510c8081d4daaa6df727eb914db9c33da3c" translate="yes" xml:space="preserve">
          <source>Local annotation classes</source>
          <target state="translated">ローカルアノテーションクラス</target>
        </trans-unit>
        <trans-unit id="69ebd822a58983be422bb598dba3c478ccd777d9" translate="yes" xml:space="preserve">
          <source>Local declarations</source>
          <target state="translated">ローカル宣言</target>
        </trans-unit>
        <trans-unit id="a1899e5981d8e839cbbac5a4b6b87631ee259818" translate="yes" xml:space="preserve">
          <source>Local delegated properties</source>
          <target state="translated">ローカルデリゲートされたプロパティ</target>
        </trans-unit>
        <trans-unit id="bcdcbb7562bc0be9df365ffa539169787154eb55" translate="yes" xml:space="preserve">
          <source>Local function can access local variables of outer functions (i.e. the closure), so in the case above, the &lt;em&gt;visited&lt;/em&gt; can be a local variable:</source>
          <target state="translated">ローカル関数は外部関数のローカル変数（つまり、クロージャ）にアクセスできるため、上記の場合、&lt;em&gt;visited&lt;/em&gt;はローカル変数になる可能性があります。</target>
        </trans-unit>
        <trans-unit id="c81d1a5213298e456992ce397aa51ab435e7f9b2" translate="yes" xml:space="preserve">
          <source>Local functions</source>
          <target state="translated">ローカル機能</target>
        </trans-unit>
        <trans-unit id="7a8cbb48d88b807f7bfba9d309d29524b5f02383" translate="yes" xml:space="preserve">
          <source>Local variable</source>
          <target state="translated">ローカル変数</target>
        </trans-unit>
        <trans-unit id="e41667e2ac3ba5cde0fdffb1b6bacda9d66718d9" translate="yes" xml:space="preserve">
          <source>Local variables are typically declared and initialized at the same time, in which case the type of the variable is &lt;em&gt;inferred&lt;/em&gt; to be the type of the expression you initialize it with:</source>
          <target state="translated">ローカル変数は通常、同時に宣言および初期化されます。この場合、変数のタイプは、変数を使用して初期化した式のタイプであると&lt;em&gt;推定さ&lt;/em&gt;れます。</target>
        </trans-unit>
        <trans-unit id="ac8a58b4422a8352e1dd6a3c1ee5296717d9a865" translate="yes" xml:space="preserve">
          <source>Local variables, functions and classes can not have visibility modifiers.</source>
          <target state="translated">ローカル変数、関数、クラスは可視性修飾子を持つことができません。</target>
        </trans-unit>
        <trans-unit id="a78aea5b0abb85e3e611fbf1ec8a29dd64f3f7a3" translate="yes" xml:space="preserve">
          <source>LocaleOptions</source>
          <target state="translated">LocaleOptions</target>
        </trans-unit>
        <trans-unit id="d219c68101f532de10add2cf42fb9dbeca73d3be" translate="yes" xml:space="preserve">
          <source>Location</source>
          <target state="translated">Location</target>
        </trans-unit>
        <trans-unit id="4a56ee9bffd6aa6b4bd69f9a8fcf34ef4736447e" translate="yes" xml:space="preserve">
          <source>Locks are used to ensure that only a single thread can initialize the &lt;a href=&quot;../-lazy/index&quot;&gt;Lazy&lt;/a&gt; instance.</source>
          <target state="translated">ロックは、単一のスレッドのみが&lt;a href=&quot;../-lazy/index&quot;&gt;Lazy&lt;/a&gt;インスタンスを初期化できるようにするために使用されます。</target>
        </trans-unit>
        <trans-unit id="0003a9c1d32ac7d8fddd983e062e51e3d0daa934" translate="yes" xml:space="preserve">
          <source>Logarithms: &lt;code&gt;log&lt;/code&gt;, &lt;code&gt;log2&lt;/code&gt;, &lt;code&gt;log10&lt;/code&gt;, &lt;code&gt;ln&lt;/code&gt;, &lt;code&gt;ln1p&lt;/code&gt;;</source>
          <target state="translated">対数： &lt;code&gt;log&lt;/code&gt; 、 &lt;code&gt;log2&lt;/code&gt; 、 &lt;code&gt;log10&lt;/code&gt; の、 &lt;code&gt;ln&lt;/code&gt; 、 &lt;code&gt;ln1p&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3496a775372b202cf19086b7723a8ba07a1c1c15" translate="yes" xml:space="preserve">
          <source>Logos can be downloaded &lt;a href=&quot;https://resources.jetbrains.com/storage/products/kotlin/docs/kotlin_logos.zip&quot;&gt;here&lt;/a&gt;. When using the logos, please follow simple rules in the &lt;code&gt;guidelines.pdf&lt;/code&gt; inside the archive and &lt;a href=&quot;https://kotlinlang.org/foundation/guidelines.html&quot;&gt;Kotlin brand usage guidelines&lt;/a&gt;.</source>
          <target state="translated">ロゴは&lt;a href=&quot;https://resources.jetbrains.com/storage/products/kotlin/docs/kotlin_logos.zip&quot;&gt;ここから&lt;/a&gt;ダウンロードできます。ロゴを使用する場合は、アーカイブ内の &lt;code&gt;guidelines.pdf&lt;/code&gt; の簡単なルールと&lt;a href=&quot;https://kotlinlang.org/foundation/guidelines.html&quot;&gt;Kotlinブランドの使用ガイドラインに&lt;/a&gt;従ってください。</target>
        </trans-unit>
        <trans-unit id="3171584f38872fa4d8f17811d91544f7756eaffd" translate="yes" xml:space="preserve">
          <source>Lombok (&lt;code&gt;lombok.NonNull&lt;/code&gt;).</source>
          <target state="translated">ロンボク（ &lt;code&gt;lombok.NonNull&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="11eda67f9b15a760342f8e98a3fc78d8d3ea9945" translate="yes" xml:space="preserve">
          <source>Long</source>
          <target state="translated">Long</target>
        </trans-unit>
        <trans-unit id="28da0e058738129fbcd7e6f45b76bc71f8a53660" translate="yes" xml:space="preserve">
          <source>LongArray</source>
          <target state="translated">LongArray</target>
        </trans-unit>
        <trans-unit id="4fccaadf63b5fc52428c158f51d57e23e947d24e" translate="yes" xml:space="preserve">
          <source>LongIterator</source>
          <target state="translated">LongIterator</target>
        </trans-unit>
        <trans-unit id="5845d554e07454310db9770fb728d9756ce6dae1" translate="yes" xml:space="preserve">
          <source>LongProgression</source>
          <target state="translated">LongProgression</target>
        </trans-unit>
        <trans-unit id="4fb8ec4ef48e7913a58002b0e63b73c29bff9f39" translate="yes" xml:space="preserve">
          <source>LongRange</source>
          <target state="translated">LongRange</target>
        </trans-unit>
        <trans-unit id="0b1c8c87dc520b4e01071e91d1f6a9ceb7e0e408" translate="yes" xml:space="preserve">
          <source>LongVar</source>
          <target state="translated">LongVar</target>
        </trans-unit>
        <trans-unit id="181cf892b1895d898b9744877c740407129f49dc" translate="yes" xml:space="preserve">
          <source>LongVarOf</source>
          <target state="translated">LongVarOf</target>
        </trans-unit>
        <trans-unit id="fd6299f672ee9cc3b8def57411eb0d0d9a44147d" translate="yes" xml:space="preserve">
          <source>Longs are tagged by a capital &lt;code&gt;L&lt;/code&gt;: &lt;code&gt;123L&lt;/code&gt;</source>
          <target state="translated">ロングは大文字の &lt;code&gt;L&lt;/code&gt; でタグ付けされています： &lt;code&gt;123L&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3e38e907fc0523189431e466a50de278a09267fc" translate="yes" xml:space="preserve">
          <source>Looking for more APIs? It is easy to create a &lt;a href=&quot;../multiplatform-library&quot;&gt;multiplatform library&lt;/a&gt; and share it!</source>
          <target state="translated">他のAPIをお探しですか？&lt;a href=&quot;../multiplatform-library&quot;&gt;マルチプラットフォームライブラリ&lt;/a&gt;を作成して共有するのは簡単です。</target>
        </trans-unit>
        <trans-unit id="0c661eae6b65f74e27c40369060777e2f1a666bd" translate="yes" xml:space="preserve">
          <source>Looks up a function &lt;code&gt;inc()&lt;/code&gt; with the &lt;code&gt;operator&lt;/code&gt; modifier and no parameters, applicable to the receiver of type &lt;code&gt;T&lt;/code&gt;;</source>
          <target state="translated">タイプ &lt;code&gt;T&lt;/code&gt; のレシーバーに適用可能な、 &lt;code&gt;operator&lt;/code&gt; 修飾子を使用してパラメーターを指定せずに関数 &lt;code&gt;inc()&lt;/code&gt; を検索します。</target>
        </trans-unit>
        <trans-unit id="06f3cb08bca38254cb72407f33d24848ac5110e5" translate="yes" xml:space="preserve">
          <source>Looks up a function &lt;code&gt;unaryPlus()&lt;/code&gt; with the &lt;code&gt;operator&lt;/code&gt; modifier and no parameters for the receiver &lt;code&gt;T&lt;/code&gt;, i.e. a member function or an extension function;</source>
          <target state="translated">&lt;code&gt;operator&lt;/code&gt; 修飾子があり、レシーバー &lt;code&gt;T&lt;/code&gt; のパラメーターがない関数 &lt;code&gt;unaryPlus()&lt;/code&gt; を検索します（メンバー関数または拡張関数など）。</target>
        </trans-unit>
        <trans-unit id="02720f9d38bf4f35e84ed5228689898bee176418" translate="yes" xml:space="preserve">
          <source>Loops</source>
          <target state="translated">Loops</target>
        </trans-unit>
        <trans-unit id="4c2bd8b7625ef46e049dcc97f3e97069511fe26a" translate="yes" xml:space="preserve">
          <source>Loops on ranges</source>
          <target state="translated">レンジのループ</target>
        </trans-unit>
        <trans-unit id="60369ad7d8b48a14f3d191172cf41bcfb71741f2" translate="yes" xml:space="preserve">
          <source>Low-level building blocks for libraries that provide coroutine-based APIs.</source>
          <target state="translated">コアラインベースのAPIを提供するライブラリのための低レベルのビルディングブロック。</target>
        </trans-unit>
        <trans-unit id="33c64772edef0388f14ce1b4adb0c6c1bb1aa8e4" translate="yes" xml:space="preserve">
          <source>Luckily, Kotlin has got &lt;em&gt;reified type parameters&lt;/em&gt;, which alleviates some of these problems. By writing &lt;code&gt;reified&lt;/code&gt; in front of a generic type parameter, it does become available at runtime, and you'll get to write &lt;code&gt;T::class&lt;/code&gt; to get the &lt;a href=&quot;member-references-and-reflection#obtaining-member-references-from-a-class-reference&quot;&gt;class metadata&lt;/a&gt;. You can only do this in inline functions (because an inline function will be compiled into its callsite, where the type information &lt;em&gt;is&lt;/em&gt; available at runtime), but it still goes a long way. For example, you can make an inline wrapper function for a big function that has got a less elegant signature.</source>
          <target state="translated">幸いなことに、Kotlinには&lt;em&gt;具体化された型パラメーター&lt;/em&gt;があり、これらの問題の一部が軽減されます。ジェネリック型パラメーターの前に &lt;code&gt;reified&lt;/code&gt; を書き込むと、実行時に使用可能になり、&lt;a href=&quot;member-references-and-reflection#obtaining-member-references-from-a-class-reference&quot;&gt;クラスメタデータ&lt;/a&gt;を取得するために &lt;code&gt;T::class&lt;/code&gt; を書き込むことができます。これはインライン関数でのみ実行できます（インライン関数はそのコールサイトにコンパイルされるため、実行時に型情報&lt;em&gt;が&lt;/em&gt;利用可能です）が、それでも長い道のりです。たとえば、あまりエレガントでないシグネチャを持つ大きな関数に対してインラインラッパー関数を作成できます。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2dc6e5580de3bf07607e19a673cd1f05b259b2bd" translate="yes" xml:space="preserve">
          <source>MACOSX</source>
          <target state="translated">MACOSX</target>
        </trans-unit>
        <trans-unit id="c8341a27b6d81ce4872ef2e5c74c71c1fa656185" translate="yes" xml:space="preserve">
          <source>MATH_SYMBOL</source>
          <target state="translated">MATH_SYMBOL</target>
        </trans-unit>
        <trans-unit id="ccd2cb474249294edd8d61576efe0ac7d7c17d4c" translate="yes" xml:space="preserve">
          <source>MAX_CODE_POINT</source>
          <target state="translated">MAX_CODE_POINT</target>
        </trans-unit>
        <trans-unit id="1a9fd1b3912908145111964e328d77ecf366fc06" translate="yes" xml:space="preserve">
          <source>MAX_COMPONENT_VALUE</source>
          <target state="translated">MAX_COMPONENT_VALUE</target>
        </trans-unit>
        <trans-unit id="6a3f20e248cb8672ba053480b2e5604ed15471fb" translate="yes" xml:space="preserve">
          <source>MAX_HIGH_SURROGATE</source>
          <target state="translated">MAX_HIGH_SURROGATE</target>
        </trans-unit>
        <trans-unit id="93b95c89e3f09a5c822039fdb274e4e9543f7b4d" translate="yes" xml:space="preserve">
          <source>MAX_LOW_SURROGATE</source>
          <target state="translated">MAX_LOW_SURROGATE</target>
        </trans-unit>
        <trans-unit id="723df4d178ea35581b90fb4dff97fa4d9e1295a6" translate="yes" xml:space="preserve">
          <source>MAX_RADIX</source>
          <target state="translated">MAX_RADIX</target>
        </trans-unit>
        <trans-unit id="e1273ad446270c0c9cf3fd5cad44848e8250ffba" translate="yes" xml:space="preserve">
          <source>MAX_SURROGATE</source>
          <target state="translated">MAX_SURROGATE</target>
        </trans-unit>
        <trans-unit id="24fdbf54e8bc77709b6bd7478c1804e90d84d0ca" translate="yes" xml:space="preserve">
          <source>MAX_VALUE</source>
          <target state="translated">MAX_VALUE</target>
        </trans-unit>
        <trans-unit id="030147a88935a9397a9625c627fb1af71a30209e" translate="yes" xml:space="preserve">
          <source>MF</source>
          <target state="translated">MF</target>
        </trans-unit>
        <trans-unit id="c93eded712b6299da78db6d4eb86c71d455d7389" translate="yes" xml:space="preserve">
          <source>MIN_CODE_POINT</source>
          <target state="translated">MIN_CODE_POINT</target>
        </trans-unit>
        <trans-unit id="a8865ad11853a6b46e09f6d1cdddfd073f7d4851" translate="yes" xml:space="preserve">
          <source>MIN_HIGH_SURROGATE</source>
          <target state="translated">MIN_HIGH_SURROGATE</target>
        </trans-unit>
        <trans-unit id="bd2ef64ddf3863a50e14b7b72bf632b54603d300" translate="yes" xml:space="preserve">
          <source>MIN_LOW_SURROGATE</source>
          <target state="translated">MIN_LOW_SURROGATE</target>
        </trans-unit>
        <trans-unit id="91631ed7ebe4f66d93a855f168fd993a18bbb9ae" translate="yes" xml:space="preserve">
          <source>MIN_RADIX</source>
          <target state="translated">MIN_RADIX</target>
        </trans-unit>
        <trans-unit id="ff3ed914be4d85796f20ffe750d11ae41f0c093d" translate="yes" xml:space="preserve">
          <source>MIN_SUPPLEMENTARY_CODE_POINT</source>
          <target state="translated">MIN_SUPPLEMENTARY_CODE_POINT</target>
        </trans-unit>
        <trans-unit id="5aa1c9c7ed6ef1169c3e694d2e0558e797993672" translate="yes" xml:space="preserve">
          <source>MIN_SURROGATE</source>
          <target state="translated">MIN_SURROGATE</target>
        </trans-unit>
        <trans-unit id="ac7a7603646aca67877b81e10b36687c24f7d10a" translate="yes" xml:space="preserve">
          <source>MIN_VALUE</source>
          <target state="translated">MIN_VALUE</target>
        </trans-unit>
        <trans-unit id="9028a909c025cf9d16590fd055950504b793f600" translate="yes" xml:space="preserve">
          <source>MIPS32</source>
          <target state="translated">MIPS32</target>
        </trans-unit>
        <trans-unit id="ac1d1ed5dec64feab585fa1220864d5680a5811e" translate="yes" xml:space="preserve">
          <source>MIPSEL32</source>
          <target state="translated">MIPSEL32</target>
        </trans-unit>
        <trans-unit id="7b5afc2e6529ad3bd8e57a7791978e690003bcdd" translate="yes" xml:space="preserve">
          <source>MODIFIER_LETTER</source>
          <target state="translated">MODIFIER_LETTER</target>
        </trans-unit>
        <trans-unit id="8f6a3829c268c3a50caa5a3744901aba89c88358" translate="yes" xml:space="preserve">
          <source>MODIFIER_SYMBOL</source>
          <target state="translated">MODIFIER_SYMBOL</target>
        </trans-unit>
        <trans-unit id="84757851065b4eb5ddf781037790225276f37d3e" translate="yes" xml:space="preserve">
          <source>MULTILINE</source>
          <target state="translated">MULTILINE</target>
        </trans-unit>
        <trans-unit id="37a6f811775e72996553c62c5ef2ab8e4e658bea" translate="yes" xml:space="preserve">
          <source>MacOS (x86_64)</source>
          <target state="translated">マックオス</target>
        </trans-unit>
        <trans-unit id="07a4d61f0acbbb95318a8a2d2e1f3a3b76934273" translate="yes" xml:space="preserve">
          <source>MacPorts</source>
          <target state="translated">MacPorts</target>
        </trans-unit>
        <trans-unit id="899bd694d29ace1be956ab35177075021977560b" translate="yes" xml:space="preserve">
          <source>Macros</source>
          <target state="translated">Macros</target>
        </trans-unit>
        <trans-unit id="c22d87ecdb73737e3e9e79d9b2b16c5c79a06654" translate="yes" xml:space="preserve">
          <source>Make sure its return type is &lt;code&gt;Unit&lt;/code&gt;, and report an error otherwise,</source>
          <target state="translated">戻り値の型が &lt;code&gt;Unit&lt;/code&gt; であることを確認し、それ以外の場合はエラーを報告します。</target>
        </trans-unit>
        <trans-unit id="2fba991ad8d6b5e98b20f4c1f0a7d640d19bbf4f" translate="yes" xml:space="preserve">
          <source>Make sure that you have CocoaPods &lt;a href=&quot;https://guides.cocoapods.org/using/getting-started.html#installation&quot;&gt;installed&lt;/a&gt;. We recommend using CocoaPods 1.6.1 or later.</source>
          <target state="translated">CocoaPodsが&lt;a href=&quot;https://guides.cocoapods.org/using/getting-started.html#installation&quot;&gt;インストールされ&lt;/a&gt;ていることを確認してください。CocoaPods 1.6.1以降の使用をお勧めします。</target>
        </trans-unit>
        <trans-unit id="872ea4c8c9e3e67462cf45519bbed3ec439a01dd" translate="yes" xml:space="preserve">
          <source>Make sure that you load the &lt;code&gt;kotlin.js&lt;/code&gt; runtime first, and then your application.</source>
          <target state="translated">最初に &lt;code&gt;kotlin.js&lt;/code&gt; ランタイムをロードしてから、アプリケーションをロードしてください。</target>
        </trans-unit>
        <trans-unit id="eb5ad277768300cd65b74ec021eb800da7b06237" translate="yes" xml:space="preserve">
          <source>Make updating to new versions comfortable for the users.</source>
          <target state="translated">新しいバージョンへのアップデートをユーザーにとって快適なものにします。</target>
        </trans-unit>
        <trans-unit id="f677748d219b353836ae9469d4c8eb0bcdf46ffb" translate="yes" xml:space="preserve">
          <source>Makes Kotlin method in Objective-C class accessible through Objective-C dispatch to be used as action sent by control in UIKit or AppKit.</source>
          <target state="translated">Objective-CクラスのKotlinメソッドをObjective-Cディスパッチでアクセス可能にし、UIKitやAppKitのコントロールから送信されるアクションとして利用できるようにします。</target>
        </trans-unit>
        <trans-unit id="09f808d1435cc07cd95f3ecbee1a2efed0c87454" translate="yes" xml:space="preserve">
          <source>Makes Kotlin property in Objective-C class settable through Objective-C dispatch to be used as IB outlet.</source>
          <target state="translated">Objective-C クラスの Kotlin プロパティを Objective-C ディスパッチで設定できるようにし、IB アウトレットとして使用できるようにします。</target>
        </trans-unit>
        <trans-unit id="79cbb2384899cfe766ce2633e3ff22d2f36982b6" translate="yes" xml:space="preserve">
          <source>Makes Kotlin subclass of Objective-C class visible for runtime lookup after Kotlin &lt;code&gt;main&lt;/code&gt; function gets invoked.</source>
          <target state="translated">Kotlin &lt;code&gt;main&lt;/code&gt; 関数が呼び出された後、Objective-CクラスのKotlinサブクラスをランタイムルックアップで表示できるようにします。</target>
        </trans-unit>
        <trans-unit id="34b5071a9847a34a44b37d8ab94597a0b604b867" translate="yes" xml:space="preserve">
          <source>Makes the annotated annotation class an associated object key.</source>
          <target state="translated">注釈付き注釈クラスを関連付けられたオブジェクト・キーにします。</target>
        </trans-unit>
        <trans-unit id="c05c0a0b46c6d81aa3deae4e473b3f5b195d9dae" translate="yes" xml:space="preserve">
          <source>Makes top level function available from C/C++ code with the given name.</source>
          <target state="translated">与えられた名前でC/C++コードからトップレベルの関数を利用できるようにします。</target>
        </trans-unit>
        <trans-unit id="3dc9b78fb75740d031749aa0e1f6c2f20915be09" translate="yes" xml:space="preserve">
          <source>Making computation code cancellable</source>
          <target state="translated">計算コードをキャンセル可能にする</target>
        </trans-unit>
        <trans-unit id="d26e8b17246e39f5acbd44ce84cfe44e4708e7bc" translate="yes" xml:space="preserve">
          <source>Making frequent null checks is annoying, so if you have to allow for the possibility of nulls, there are several very useful operators in Kotlin to ease working with values that might be null, as described below.</source>
          <target state="translated">頻繁にヌルチェックをするのは面倒なので、ヌルの可能性を許容しなければならない場合、Kotlinには、以下に説明するように、ヌルになる可能性のある値の処理を簡単にするための非常に便利な演算子がいくつかあります。</target>
        </trans-unit>
        <trans-unit id="f35727fd1febb5955e04a96a85cfbf28b11e18a0" translate="yes" xml:space="preserve">
          <source>Malformed byte sequences are replaced by the replacement char &lt;code&gt;\uFFFD&lt;/code&gt;.</source>
          <target state="translated">不正なバイトシーケンスは、置換文字 &lt;code&gt;\uFFFD&lt;/code&gt; 置き換えられます。</target>
        </trans-unit>
        <trans-unit id="b2aee73bd2e79677bed872d3980e254bec42f2c5" translate="yes" xml:space="preserve">
          <source>Managing dependencies</source>
          <target state="translated">依存関係の管理</target>
        </trans-unit>
        <trans-unit id="f45216dfe5658802d5da85dd6691495f1dd5ee41" translate="yes" xml:space="preserve">
          <source>Managing sources</source>
          <target state="translated">ソースの管理</target>
        </trans-unit>
        <trans-unit id="b0426429a44f47228605bdec162f6e1798c46d34" translate="yes" xml:space="preserve">
          <source>Managing targets</source>
          <target state="translated">目標管理</target>
        </trans-unit>
        <trans-unit id="dc1586db5c7b55a74cd10223f2e3a7fe8bf95caa" translate="yes" xml:space="preserve">
          <source>Mangling</source>
          <target state="translated">Mangling</target>
        </trans-unit>
        <trans-unit id="76f58e9ae1ecc3bcd5734ccddd0e7976cd032c5b" translate="yes" xml:space="preserve">
          <source>Manual Configuration</source>
          <target state="translated">手動設定</target>
        </trans-unit>
        <trans-unit id="724adbdc3ff0031b5c79ad867a79546b920a65f6" translate="yes" xml:space="preserve">
          <source>Manual Install</source>
          <target state="translated">マニュアルインストール</target>
        </trans-unit>
        <trans-unit id="65a73e4ea7721ba692baf916576f5d262d09eb6e" translate="yes" xml:space="preserve">
          <source>Many modern IDEs support Kotlin and help in writing idiomatic Kotlin code:</source>
          <target state="translated">最近の多くのIDEはKotlinをサポートしており、慣用的なKotlinコードを書くのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="564f728d4accd1cab1faa6abd0808aa411a7afbc" translate="yes" xml:space="preserve">
          <source>Many of the options can also be configured through properties:</source>
          <target state="translated">オプションの多くは、プロパティからも設定できます。</target>
        </trans-unit>
        <trans-unit id="fe81b734a40201fad1b163bd75e5e8866ba447fc" translate="yes" xml:space="preserve">
          <source>Many startups and Fortune 500 companies have already developed Android applications using Kotlin &amp;ndash; see the list at &lt;a href=&quot;https://developer.android.com/kotlin&quot;&gt;the Google website for Kotlin developers&lt;/a&gt;.</source>
          <target state="translated">多くの新興企業やフォーチュン500企業はすでにKotlinを使用してAndroidアプリケーションを開発しています&lt;a href=&quot;https://developer.android.com/kotlin&quot;&gt;。Kotlin開発者向けのGoogleWebサイトの&lt;/a&gt;リストを参照してください。</target>
        </trans-unit>
        <trans-unit id="ab478f3efc840eebab919dff1b9512286f70c10c" translate="yes" xml:space="preserve">
          <source>Map</source>
          <target state="translated">Map</target>
        </trans-unit>
        <trans-unit id="1a3e682ff2754ef0b1db9651d934d18042efd51a" translate="yes" xml:space="preserve">
          <source>Map Specific Operations</source>
          <target state="translated">マップ固有の操作</target>
        </trans-unit>
        <trans-unit id="8a55ba4dc9c56793f4d86eafccdf893ff4dfc510" translate="yes" xml:space="preserve">
          <source>Map nullable value if not null</source>
          <target state="translated">null でない場合は、nullable 値をマップします。</target>
        </trans-unit>
        <trans-unit id="154baeb185088267d2e04dd13fb49c8faf1731b4" translate="yes" xml:space="preserve">
          <source>Map write operations</source>
          <target state="translated">マップ書き込み操作</target>
        </trans-unit>
        <trans-unit id="7c78455b5524d54dd5717439fdd75a3564e3b05c" translate="yes" xml:space="preserve">
          <source>Map.getValue()</source>
          <target state="translated">Map.getValue()</target>
        </trans-unit>
        <trans-unit id="ab6d914f12b0209ae12f1eaa021fab679f71fbd9" translate="yes" xml:space="preserve">
          <source>Map.minus(key)</source>
          <target state="translated">Map.minus(key)</target>
        </trans-unit>
        <trans-unit id="a1e3b9de38695948c83390c6219ada2b49d0eb03" translate="yes" xml:space="preserve">
          <source>Map.toMap() and Map.toMutableMap()</source>
          <target state="translated">Map.toMap()および Map.toMutableMap()</target>
        </trans-unit>
        <trans-unit id="f5503e0acfd60752001069a9088cb22064b114de" translate="yes" xml:space="preserve">
          <source>Mapped types</source>
          <target state="translated">マップされたタイプ</target>
        </trans-unit>
        <trans-unit id="def2eba59562958fa4a005f8070d692ef8502312" translate="yes" xml:space="preserve">
          <source>Mapping</source>
          <target state="translated">Mapping</target>
        </trans-unit>
        <trans-unit id="ae3c45c6220c54a755f63c613acc1f9b440f728e" translate="yes" xml:space="preserve">
          <source>Mapping Function Pointer Types from C</source>
          <target state="translated">C言語からの関数ポインタ型のマッピング</target>
        </trans-unit>
        <trans-unit id="3629da3c88dfc6308c1eb31a6616f2493b1b3a4a" translate="yes" xml:space="preserve">
          <source>Mapping Function Pointers from C</source>
          <target state="translated">Cからの関数ポインタのマッピング</target>
        </trans-unit>
        <trans-unit id="1ab023f41f65f5d65722a6148006ad3ade089fb2" translate="yes" xml:space="preserve">
          <source>Mapping Primitive Data Types from C</source>
          <target state="translated">Cからのプリミティブデータ型のマッピング</target>
        </trans-unit>
        <trans-unit id="d6b4467553c4b4c986cbd21872e97a3c8e8ea762" translate="yes" xml:space="preserve">
          <source>Mapping Strings from C</source>
          <target state="translated">Cからの文字列のマッピング</target>
        </trans-unit>
        <trans-unit id="76a029f685d2ba76aaeecfdb2224f273ebee328a" translate="yes" xml:space="preserve">
          <source>Mapping Struct and Union C types</source>
          <target state="translated">マッピング構造とユニオンCタイプ</target>
        </trans-unit>
        <trans-unit id="565e074c9f98132ef0f9b4a1395ca391399b5fc8" translate="yes" xml:space="preserve">
          <source>Mapping Struct and Union Types from C</source>
          <target state="translated">Cから構造体とユニオンタイプのマッピング</target>
        </trans-unit>
        <trans-unit id="1cbcdd98d1b5744757244f463b7f939b4869f3e4" translate="yes" xml:space="preserve">
          <source>Mappings</source>
          <target state="translated">Mappings</target>
        </trans-unit>
        <trans-unit id="4811d5bdec38d0b9bed7265f0e3355c78194b1ff" translate="yes" xml:space="preserve">
          <source>Marker interface indicating that the &lt;a href=&quot;-list/index#kotlin.collections.List&quot;&gt;List&lt;/a&gt; implementation supports fast indexed access.</source>
          <target state="translated">&lt;a href=&quot;-list/index#kotlin.collections.List&quot;&gt;Listの&lt;/a&gt;実装が高速なインデックス付きアクセスをサポートすることを示すマーカーインターフェイス。</target>
        </trans-unit>
        <trans-unit id="79f92c6a2f9b55de94523a0137df26f32b271fc3" translate="yes" xml:space="preserve">
          <source>Marker interface indicating that the &lt;a href=&quot;../../kotlin.collections/-list/index#kotlin.collections.List&quot;&gt;List&lt;/a&gt; implementation supports fast indexed access.</source>
          <target state="translated">&lt;a href=&quot;../../kotlin.collections/-list/index#kotlin.collections.List&quot;&gt;Listの&lt;/a&gt;実装が高速なインデックス付きアクセスをサポートすることを示すマーカーインターフェイス。</target>
        </trans-unit>
        <trans-unit id="deb9ed7bb61b8698d73e57af565358059241e0bd" translate="yes" xml:space="preserve">
          <source>Marking API elements</source>
          <target state="translated">API要素のマーキング</target>
        </trans-unit>
        <trans-unit id="39acae63028d11938c7d9a75f3ad9099e5f79972" translate="yes" xml:space="preserve">
          <source>Marking experimental API</source>
          <target state="translated">実験用APIのマーキング</target>
        </trans-unit>
        <trans-unit id="72ca39cc361248a73db4aa376ff098d3162e32bf" translate="yes" xml:space="preserve">
          <source>Marking rules: an implicit receiver is considered marked with @Ann if</source>
          <target state="translated">マーキングルール:暗黙のレシーバは、@Ann でマークされているとみなされます。</target>
        </trans-unit>
        <trans-unit id="d4db1b9cfb765a0420560d33f4c49a590513a4d0" translate="yes" xml:space="preserve">
          <source>Marks a top level property with a backing field as immutable. It is possible to share the value of such property between multiple threads, but it becomes deeply frozen, so no changes can be made to its state or the state of objects it refers to.</source>
          <target state="translated">バッキングフィールドを持つトップレベルのプロパティを不変としてマークします。このようなプロパティの値を複数のスレッド間で共有することは可能ですが、深く凍結されてしまうため、その状態や参照しているオブジェクトの状態を変更することはできません。</target>
        </trans-unit>
        <trans-unit id="a224cc22214be0edab83e29fa79b9dd2dd10f50f" translate="yes" xml:space="preserve">
          <source>Marks a top level property with a backing field or an object as thread local. The object remains mutable and it is possible to change its state, but every thread will have a distinct copy of this object, so changes in one thread are not reflected in another.</source>
          <target state="translated">バッキングフィールドまたはオブジェクトを持つトップレベルのプロパティをスレッドローカルとしてマークします。オブジェクトは変更可能なままで、その状態を変更することができますが、すべてのスレッドはこのオブジェクトの個別のコピーを持つことになるので、あるスレッドでの変更は別のスレッドには反映されません。</target>
        </trans-unit>
        <trans-unit id="33d0711db8fea3ba5bf0ebfba79cfe0cf8264458" translate="yes" xml:space="preserve">
          <source>Marks a top level variable with a backing field or an object as immutable. It is possible to share such object between multiple threads, but it becomes deeply frozen, so no changes can be made to its state or the state of objects it refers to.</source>
          <target state="translated">バッキングフィールドを持つトップレベルの変数やオブジェクトに不変のマークを付けます。このようなオブジェクトを複数のスレッド間で共有することは可能ですが、深く凍結されてしまうため、その状態や参照しているオブジェクトの状態を変更することはできません。</target>
        </trans-unit>
        <trans-unit id="9c86911fdb83bb1e6cafe3509aa437cd672c34a9" translate="yes" xml:space="preserve">
          <source>Marks a top level variable with a backing field or an object as thread local. The object remains mutable and it is possible to change its state, but every thread will have a distinct copy of this object, so changes in one thread are not reflected in another.</source>
          <target state="translated">バッキングフィールドやオブジェクトを持つトップレベルの変数をスレッドローカルとしてマークします。オブジェクトは変更可能なままで、その状態を変更することができますが、すべてのスレッドがこのオブジェクトの個別のコピーを持つことになるので、あるスレッドでの変更は別のスレッドには反映されません。</target>
        </trans-unit>
        <trans-unit id="6ec4d266890af2cb0a6aa9e1810055ba658008f8" translate="yes" xml:space="preserve">
          <source>Marks an expected annotation class that it isn't required to have actual counterparts in all platforms.</source>
          <target state="translated">すべてのプラットフォームで実際の対応するものを持つ必要がないことを期待される注釈クラスにマークを付けます。</target>
        </trans-unit>
        <trans-unit id="5c6f17834ff35593c5226191e98557d99d755e77" translate="yes" xml:space="preserve">
          <source>Marks coroutine context element that intercepts coroutine continuations. The coroutines framework uses &lt;a href=&quot;-continuation-interceptor/-key&quot;&gt;ContinuationInterceptor.Key&lt;/a&gt; to retrieve the interceptor and intercepts all coroutine continuations with &lt;a href=&quot;-continuation-interceptor/intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt; invocations.</source>
          <target state="translated">コルーチンの継続をインターセプトするコルーチンコンテキスト要素をマークします。コルーチンフレームワークは&lt;a href=&quot;-continuation-interceptor/-key&quot;&gt;ContinuationInterceptor.Key&lt;/a&gt;を使用してインターセプターを取得し、&lt;a href=&quot;-continuation-interceptor/intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt;呼び出しですべてのコルーチンの継続をインターセプトします。</target>
        </trans-unit>
        <trans-unit id="292a3151e7a72885408caf9ee437ad5d8673be4a" translate="yes" xml:space="preserve">
          <source>Marks coroutine context element that intercepts coroutine continuations. The coroutines framework uses &lt;a href=&quot;-key&quot;&gt;ContinuationInterceptor.Key&lt;/a&gt; to retrieve the interceptor and intercepts all coroutine continuations with &lt;a href=&quot;intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt; invocations.</source>
          <target state="translated">コルーチンの継続をインターセプトするコルーチンコンテキスト要素をマークします。コルーチンフレームワークは&lt;a href=&quot;-key&quot;&gt;ContinuationInterceptor.Key&lt;/a&gt;を使用してインターセプターを取得し、&lt;a href=&quot;intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt;呼び出しですべてのコルーチンの継続をインターセプトします。</target>
        </trans-unit>
        <trans-unit id="5be31e799227d8931dded0eeace958d0a3e43418" translate="yes" xml:space="preserve">
          <source>Marks coroutine context element that intercepts coroutine continuations. The coroutines framework uses &lt;a href=&quot;../../kotlin.coroutines.experimental/-continuation-interceptor/-key&quot;&gt;ContinuationInterceptor.Key&lt;/a&gt; to retrieve the interceptor and intercepts all coroutine continuations with &lt;a href=&quot;../../kotlin.coroutines.experimental/-continuation-interceptor/intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt; invocations.</source>
          <target state="translated">コルーチンの継続をインターセプトするコルーチンコンテキスト要素をマークします。コルーチンフレームワークは&lt;a href=&quot;../../kotlin.coroutines.experimental/-continuation-interceptor/-key&quot;&gt;ContinuationInterceptor.Key&lt;/a&gt;を使用してインターセプターを取得し、&lt;a href=&quot;../../kotlin.coroutines.experimental/-continuation-interceptor/intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt;呼び出しですべてのコルーチンの継続をインターセプトします。</target>
        </trans-unit>
        <trans-unit id="589152c67b668bc3a0e5e851927c4f25196aa066" translate="yes" xml:space="preserve">
          <source>Marks coroutine context element that intercepts coroutine continuations. The coroutines framework uses &lt;a href=&quot;../../kotlin.coroutines/-continuation-interceptor/-key&quot;&gt;ContinuationInterceptor.Key&lt;/a&gt; to retrieve the interceptor and intercepts all coroutine continuations with &lt;a href=&quot;../../kotlin.coroutines/-continuation-interceptor/intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt; invocations.</source>
          <target state="translated">コルーチンの継続をインターセプトするコルーチンコンテキスト要素をマークします。コルーチンフレームワークは&lt;a href=&quot;../../kotlin.coroutines/-continuation-interceptor/-key&quot;&gt;ContinuationInterceptor.Key&lt;/a&gt;を使用してインターセプターを取得し、&lt;a href=&quot;../../kotlin.coroutines/-continuation-interceptor/intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt;呼び出しですべてのコルーチンの継続をインターセプトします。</target>
        </trans-unit>
        <trans-unit id="e74d580f7febe5c2f5fce47ebee5f4b2a5e537e3" translate="yes" xml:space="preserve">
          <source>Marks experimental JS export annotations.</source>
          <target state="translated">実験的なJSエクスポートアノテーションをマークします。</target>
        </trans-unit>
        <trans-unit id="2df77c28828a089a19fdffaa1789ccacc76664f7" translate="yes" xml:space="preserve">
          <source>Marks the API that is dependent on the experimental unsigned types, including those types themselves.</source>
          <target state="translated">実験的な符号なし型に依存するAPIをマークします。</target>
        </trans-unit>
        <trans-unit id="73273d6a95cad7e50a139041438fbf00005e8089" translate="yes" xml:space="preserve">
          <source>Marks the JVM backing field of the annotated property as &lt;code&gt;transient&lt;/code&gt;, meaning that it is not part of the default serialized form of the object.</source>
          <target state="translated">注釈付きプロパティのJVMバッキングフィールドを &lt;code&gt;transient&lt;/code&gt; としてマークします。これは、オブジェクトのデフォルトのシリアル化された形式の一部ではないことを意味します。</target>
        </trans-unit>
        <trans-unit id="fd02a709ebd5dfcba6e63db7078d9717fce347a3" translate="yes" xml:space="preserve">
          <source>Marks the JVM backing field of the annotated property as &lt;code&gt;volatile&lt;/code&gt;, meaning that writes to this field are immediately made visible to other threads.</source>
          <target state="translated">注釈付きプロパティのJVMバッキングフィールドを &lt;code&gt;volatile&lt;/code&gt; としてマークします。つまり、このフィールドへの書き込みはすぐに他のスレッドから見えるようになります。</target>
        </trans-unit>
        <trans-unit id="1c403a59019182391a8ff7eb648d56329fc1e05f" translate="yes" xml:space="preserve">
          <source>Marks the JVM method generated from the annotated function as &lt;code&gt;strictfp&lt;/code&gt;, meaning that the precision of floating point operations performed inside the method needs to be restricted in order to achieve better portability.</source>
          <target state="translated">アノテーション付き関数から生成されたJVMメソッドを &lt;code&gt;strictfp&lt;/code&gt; としてマークします。つまり、メソッド内で実行される浮動小数点演算の精度を制限して、移植性を向上させる必要があります。</target>
        </trans-unit>
        <trans-unit id="58ecb1a8fc60ff73e8fc37346fd83ecb47a77bf8" translate="yes" xml:space="preserve">
          <source>Marks the JVM method generated from the annotated function as &lt;code&gt;synchronized&lt;/code&gt;, meaning that the method will be protected from concurrent execution by multiple threads by the monitor of the instance (or, for static methods, the class) on which the method is defined.</source>
          <target state="translated">注釈付き関数から生成されたJVMメソッドを &lt;code&gt;synchronized&lt;/code&gt; としてマークします。つまり、メソッドが定義されているインスタンス（または静的メソッドの場合はクラス）のモニターによって、メソッドが複数のスレッドによる同時実行から保護されます。</target>
        </trans-unit>
        <trans-unit id="fb96fdd73420dc05c701eb6e0838bd95d38438a9" translate="yes" xml:space="preserve">
          <source>Marks the annotated declaration as deprecated.</source>
          <target state="translated">アノテーション宣言を非推奨とするマークを付けます。</target>
        </trans-unit>
        <trans-unit id="7d98c397e94ce7053df95bf37d1da503360432a5" translate="yes" xml:space="preserve">
          <source>Marks the annotated declaration as deprecated. In contrast to &lt;a href=&quot;-deprecated/index#kotlin.Deprecated&quot;&gt;Deprecated&lt;/a&gt;, severity of the reported diagnostic is not a constant value, but differs depending on the API version of the usage (the value of the &lt;code&gt;-api-version&lt;/code&gt; argument when compiling the module where the usage is located). If the API version is greater or equal than &lt;a href=&quot;-deprecated-since-kotlin/hidden-since#kotlin.DeprecatedSinceKotlin%24hiddenSince&quot;&gt;hiddenSince&lt;/a&gt;, the declaration will not be accessible from the code (as if it was deprecated with level &lt;a href=&quot;-deprecation-level/-h-i-d-d-e-n#kotlin.DeprecationLevel.HIDDEN&quot;&gt;DeprecationLevel.HIDDEN&lt;/a&gt;), otherwise if the API version is greater or equal than &lt;a href=&quot;-deprecated-since-kotlin/error-since#kotlin.DeprecatedSinceKotlin%24errorSince&quot;&gt;errorSince&lt;/a&gt;, the usage will be marked as an error (as with &lt;a href=&quot;-deprecation-level/-e-r-r-o-r#kotlin.DeprecationLevel.ERROR&quot;&gt;DeprecationLevel.ERROR&lt;/a&gt;), otherwise if the API version is greater or equal than &lt;a href=&quot;-deprecated-since-kotlin/warning-since#kotlin.DeprecatedSinceKotlin%24warningSince&quot;&gt;warningSince&lt;/a&gt;, the usage will be marked as a warning (as with &lt;a href=&quot;-deprecation-level/-w-a-r-n-i-n-g#kotlin.DeprecationLevel.WARNING&quot;&gt;DeprecationLevel.WARNING&lt;/a&gt;), otherwise the annotation is ignored.</source>
          <target state="translated">注釈付きの宣言を非推奨としてマークします。非&lt;a href=&quot;-deprecated/index#kotlin.Deprecated&quot;&gt;推奨&lt;/a&gt;とは対照的に、報告される診断の重大度は一定の値ではありませんが、使用法のAPIバージョン（使用法が配置されているモジュールをコンパイルするときの &lt;code&gt;-api-version&lt;/code&gt; 引数の値）によって異なります。 APIバージョンが&lt;a href=&quot;-deprecated-since-kotlin/hidden-since#kotlin.DeprecatedSinceKotlin%24hiddenSince&quot;&gt;hiddenSince&lt;/a&gt;以上の場合、宣言はコードからアクセスできません（レベル&lt;a href=&quot;-deprecation-level/-h-i-d-d-e-n#kotlin.DeprecationLevel.HIDDEN&quot;&gt;DeprecationLevel.HIDDENで&lt;/a&gt;非推奨になったかのように）。それ以外の場合、APIバージョンが&lt;a href=&quot;-deprecated-since-kotlin/error-since#kotlin.DeprecatedSinceKotlin%24errorSince&quot;&gt;errorSince&lt;/a&gt;以上の場合、使用量がマークされます。エラーとして（&lt;a href=&quot;-deprecation-level/-e-r-r-o-r#kotlin.DeprecationLevel.ERROR&quot;&gt;DeprecationLevel.ERRORと&lt;/a&gt;同様）、それ以外の場合、APIバージョンが&lt;a href=&quot;-deprecated-since-kotlin/warning-since#kotlin.DeprecatedSinceKotlin%24warningSince&quot;&gt;warningSince&lt;/a&gt;以上の場合、使用法は警告としてマークされます（&lt;a href=&quot;-deprecation-level/-w-a-r-n-i-n-g#kotlin.DeprecationLevel.WARNING&quot;&gt;DeprecationLevel.WARNINGと&lt;/a&gt;同様）。それ以外の場合、注釈は無視されます。</target>
        </trans-unit>
        <trans-unit id="80f9c066c4fb389bf5a2648a88b9da8d8a5af0b6" translate="yes" xml:space="preserve">
          <source>Marks the annotated declaration as deprecated. In contrast to &lt;a href=&quot;../-deprecated/index#kotlin.Deprecated&quot;&gt;Deprecated&lt;/a&gt;, severity of the reported diagnostic is not a constant value, but differs depending on the API version of the usage (the value of the &lt;code&gt;-api-version&lt;/code&gt; argument when compiling the module where the usage is located). If the API version is greater or equal than &lt;a href=&quot;../-deprecated-since-kotlin/hidden-since#kotlin.DeprecatedSinceKotlin%24hiddenSince&quot;&gt;hiddenSince&lt;/a&gt;, the declaration will not be accessible from the code (as if it was deprecated with level &lt;a href=&quot;../-deprecation-level/-h-i-d-d-e-n#kotlin.DeprecationLevel.HIDDEN&quot;&gt;DeprecationLevel.HIDDEN&lt;/a&gt;), otherwise if the API version is greater or equal than &lt;a href=&quot;../-deprecated-since-kotlin/error-since#kotlin.DeprecatedSinceKotlin%24errorSince&quot;&gt;errorSince&lt;/a&gt;, the usage will be marked as an error (as with &lt;a href=&quot;../-deprecation-level/-e-r-r-o-r#kotlin.DeprecationLevel.ERROR&quot;&gt;DeprecationLevel.ERROR&lt;/a&gt;), otherwise if the API version is greater or equal than &lt;a href=&quot;../-deprecated-since-kotlin/warning-since#kotlin.DeprecatedSinceKotlin%24warningSince&quot;&gt;warningSince&lt;/a&gt;, the usage will be marked as a warning (as with &lt;a href=&quot;../-deprecation-level/-w-a-r-n-i-n-g#kotlin.DeprecationLevel.WARNING&quot;&gt;DeprecationLevel.WARNING&lt;/a&gt;), otherwise the annotation is ignored.</source>
          <target state="translated">注釈付きの宣言を非推奨としてマークします。非&lt;a href=&quot;../-deprecated/index#kotlin.Deprecated&quot;&gt;推奨&lt;/a&gt;とは対照的に、報告される診断の重大度は一定の値ではありませんが、使用法のAPIバージョン（使用法が配置されているモジュールをコンパイルするときの &lt;code&gt;-api-version&lt;/code&gt; 引数の値）によって異なります。 APIバージョンが&lt;a href=&quot;../-deprecated-since-kotlin/hidden-since#kotlin.DeprecatedSinceKotlin%24hiddenSince&quot;&gt;hiddenSince&lt;/a&gt;以上の場合、宣言はコードからアクセスできません（レベル&lt;a href=&quot;../-deprecation-level/-h-i-d-d-e-n#kotlin.DeprecationLevel.HIDDEN&quot;&gt;DeprecationLevel.HIDDENで&lt;/a&gt;非推奨になったかのように）。それ以外の場合、APIバージョンが&lt;a href=&quot;../-deprecated-since-kotlin/error-since#kotlin.DeprecatedSinceKotlin%24errorSince&quot;&gt;errorSince&lt;/a&gt;以上の場合、使用量がマークされます。エラーとして（&lt;a href=&quot;../-deprecation-level/-e-r-r-o-r#kotlin.DeprecationLevel.ERROR&quot;&gt;DeprecationLevel.ERRORと&lt;/a&gt;同様）、それ以外の場合、APIバージョンが&lt;a href=&quot;../-deprecated-since-kotlin/warning-since#kotlin.DeprecatedSinceKotlin%24warningSince&quot;&gt;warningSince&lt;/a&gt;以上の場合、使用法は警告としてマークされます（&lt;a href=&quot;../-deprecation-level/-w-a-r-n-i-n-g#kotlin.DeprecationLevel.WARNING&quot;&gt;DeprecationLevel.WARNINGと&lt;/a&gt;同様）。それ以外の場合、注釈は無視されます。</target>
        </trans-unit>
        <trans-unit id="849bb03707fb20c75be09bfab7269367951a2e2c" translate="yes" xml:space="preserve">
          <source>MatchGroup</source>
          <target state="translated">MatchGroup</target>
        </trans-unit>
        <trans-unit id="dca62bbed6a25edcb571ec2b8d04d93aa72d3b21" translate="yes" xml:space="preserve">
          <source>MatchGroupCollection</source>
          <target state="translated">MatchGroupCollection</target>
        </trans-unit>
        <trans-unit id="40ee7a3cd8703b1f6d5c39fe97ef7bdbddff913a" translate="yes" xml:space="preserve">
          <source>MatchNamedGroupCollection</source>
          <target state="translated">MatchNamedGroupCollection</target>
        </trans-unit>
        <trans-unit id="e5e10479d7e48ed2ed4d8e1de8fc8b3e40fd01eb" translate="yes" xml:space="preserve">
          <source>MatchResult</source>
          <target state="translated">MatchResult</target>
        </trans-unit>
        <trans-unit id="3edf0df49942da6d11a1a217e4d3af4a5a8e64f2" translate="yes" xml:space="preserve">
          <source>Math</source>
          <target state="translated">Math</target>
        </trans-unit>
        <trans-unit id="386de788c6f8f526adcdfcc95893611a4f0f2a05" translate="yes" xml:space="preserve">
          <source>Math operations in kotlin-stdlib</source>
          <target state="translated">kotlin-stdlib での数学演算</target>
        </trans-unit>
        <trans-unit id="0ada0ff6418289ab78ea96388455f7b6c8654ca4" translate="yes" xml:space="preserve">
          <source>Mathematical functions and constants.</source>
          <target state="translated">数学的な関数と定数。</target>
        </trans-unit>
        <trans-unit id="6af37177e65c1a71744a7cb984d51ba2f07f5140" translate="yes" xml:space="preserve">
          <source>Maven</source>
          <target state="translated">Maven</target>
        </trans-unit>
        <trans-unit id="b522db69b358e8fce0593518fbe3b0d7db36d2d4" translate="yes" xml:space="preserve">
          <source>Maven configuration</source>
          <target state="translated">Mavenの設定</target>
        </trans-unit>
        <trans-unit id="71edee9db1ff5b8ff75c1bfdc3477115c9cadb2f" translate="yes" xml:space="preserve">
          <source>Max value</source>
          <target state="translated">最大値</target>
        </trans-unit>
        <trans-unit id="6f26174801b4fb329b7b4754a956851117212509" translate="yes" xml:space="preserve">
          <source>Maximum value a version component can have, a constant value 255.</source>
          <target state="translated">バージョンコンポーネントが持つことができる最大値、定数値255。</target>
        </trans-unit>
        <trans-unit id="258389887a049fd789e8d5c0611eb448fb932cc4" translate="yes" xml:space="preserve">
          <source>MediaDeviceInfo</source>
          <target state="translated">MediaDeviceInfo</target>
        </trans-unit>
        <trans-unit id="6134c6977e97c143c3e4282792a6fe2d4e4a8d3d" translate="yes" xml:space="preserve">
          <source>MediaDeviceKind</source>
          <target state="translated">MediaDeviceKind</target>
        </trans-unit>
        <trans-unit id="42773779c7725a712497e1de443b3526292ee7c5" translate="yes" xml:space="preserve">
          <source>MediaEncryptedEventInit</source>
          <target state="translated">MediaEncryptedEventInit</target>
        </trans-unit>
        <trans-unit id="5e9d9c4423f0ac299fce82e9517c3425a061ddb4" translate="yes" xml:space="preserve">
          <source>MediaError</source>
          <target state="translated">MediaError</target>
        </trans-unit>
        <trans-unit id="edc3252539f2977307059639af16d93b62f83e89" translate="yes" xml:space="preserve">
          <source>MediaKeyMessageEventInit</source>
          <target state="translated">MediaKeyMessageEventInit</target>
        </trans-unit>
        <trans-unit id="0f9940df0a60e74d9f81259c874d8fc5cf90b250" translate="yes" xml:space="preserve">
          <source>MediaKeyMessageType</source>
          <target state="translated">MediaKeyMessageType</target>
        </trans-unit>
        <trans-unit id="f6d29b82c487515b0ed4941f8440be7338b9cdd9" translate="yes" xml:space="preserve">
          <source>MediaKeySessionType</source>
          <target state="translated">MediaKeySessionType</target>
        </trans-unit>
        <trans-unit id="6a72b850014dcb01724de3815824e738f2a289e8" translate="yes" xml:space="preserve">
          <source>MediaKeyStatus</source>
          <target state="translated">MediaKeyStatus</target>
        </trans-unit>
        <trans-unit id="06b28afbee38c4e57833221839b448745bf0272f" translate="yes" xml:space="preserve">
          <source>MediaKeyStatusMap</source>
          <target state="translated">MediaKeyStatusMap</target>
        </trans-unit>
        <trans-unit id="334845d31e06fd797025ffec6b0e947ced1eee27" translate="yes" xml:space="preserve">
          <source>MediaKeySystemAccess</source>
          <target state="translated">MediaKeySystemAccess</target>
        </trans-unit>
        <trans-unit id="13b324678ad4a42d1cf13183ec5703ba89067f0a" translate="yes" xml:space="preserve">
          <source>MediaKeySystemConfiguration</source>
          <target state="translated">MediaKeySystemConfiguration</target>
        </trans-unit>
        <trans-unit id="261d7bee8c2a3f2851483973000c454b56a6d2f7" translate="yes" xml:space="preserve">
          <source>MediaKeySystemMediaCapability</source>
          <target state="translated">MediaKeySystemMediaCapability</target>
        </trans-unit>
        <trans-unit id="04bf6109f69f0241e714dae0a1bff955d8bb5503" translate="yes" xml:space="preserve">
          <source>MediaKeys</source>
          <target state="translated">MediaKeys</target>
        </trans-unit>
        <trans-unit id="0204337f58a70624acab6d8767bba63e305a6319" translate="yes" xml:space="preserve">
          <source>MediaKeysRequirement</source>
          <target state="translated">MediaKeysRequirement</target>
        </trans-unit>
        <trans-unit id="f30d349fe509ab2452d9ff5db776c749eb21115d" translate="yes" xml:space="preserve">
          <source>MediaList</source>
          <target state="translated">MediaList</target>
        </trans-unit>
        <trans-unit id="fb2396dadb0919fa005cf6b516e3b748e938e528" translate="yes" xml:space="preserve">
          <source>MediaProvider</source>
          <target state="translated">MediaProvider</target>
        </trans-unit>
        <trans-unit id="5264b922a464ea5a9f88144f8b72f9626c1db269" translate="yes" xml:space="preserve">
          <source>MediaQueryListEventInit</source>
          <target state="translated">MediaQueryListEventInit</target>
        </trans-unit>
        <trans-unit id="70dcd56d399d2e12aa2533dd163497d5ff6362fd" translate="yes" xml:space="preserve">
          <source>MediaStreamConstraints</source>
          <target state="translated">MediaStreamConstraints</target>
        </trans-unit>
        <trans-unit id="c74168a0d6b99bbcdaff6005366c94dc042ddd9e" translate="yes" xml:space="preserve">
          <source>MediaStreamTrackEventInit</source>
          <target state="translated">MediaStreamTrackEventInit</target>
        </trans-unit>
        <trans-unit id="f6268479064052c02a6fe8b1b48bf8011df3d770" translate="yes" xml:space="preserve">
          <source>MediaStreamTrackState</source>
          <target state="translated">MediaStreamTrackState</target>
        </trans-unit>
        <trans-unit id="10f95ad72ba533133d954c473a07f3f67fdac829" translate="yes" xml:space="preserve">
          <source>MediaTrackCapabilities</source>
          <target state="translated">MediaTrackCapabilities</target>
        </trans-unit>
        <trans-unit id="bb47b7b2d8ef429be15b6e0dad452a4f8b48f974" translate="yes" xml:space="preserve">
          <source>MediaTrackConstraintSet</source>
          <target state="translated">MediaTrackConstraintSet</target>
        </trans-unit>
        <trans-unit id="8054e6c6485f93790f303ed390e1cba5c2743911" translate="yes" xml:space="preserve">
          <source>MediaTrackConstraints</source>
          <target state="translated">MediaTrackConstraints</target>
        </trans-unit>
        <trans-unit id="43ae2bb87ab91212c29f9b3badd22fa54472dcc6" translate="yes" xml:space="preserve">
          <source>MediaTrackSettings</source>
          <target state="translated">MediaTrackSettings</target>
        </trans-unit>
        <trans-unit id="7e941f3e34c1287f6e0e3fa6973fe4daf92e6bf1" translate="yes" xml:space="preserve">
          <source>MediaTrackSupportedConstraints</source>
          <target state="translated">MediaTrackSupportedConstraints</target>
        </trans-unit>
        <trans-unit id="0821090b6a2b08e3c2088bad74f0cd7597a2e61c" translate="yes" xml:space="preserve">
          <source>MemScope</source>
          <target state="translated">MemScope</target>
        </trans-unit>
        <trans-unit id="13754495aca84346deb594b0d23bc4d086989ee4" translate="yes" xml:space="preserve">
          <source>Member Functions</source>
          <target state="translated">メンバー機能</target>
        </trans-unit>
        <trans-unit id="2675e87b859fb2d5772f0ea8bf6c203afefdde62" translate="yes" xml:space="preserve">
          <source>Member function names should use &lt;code&gt;lowerCamelCase&lt;/code&gt; instead of &lt;code&gt;snake_case&lt;/code&gt;.</source>
          <target state="translated">メンバー関数名を使うべき &lt;code&gt;lowerCamelCase&lt;/code&gt; の代わりに &lt;code&gt;snake_case&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b217f7514e4e69fd38aa7c54a821e91e41f619c3" translate="yes" xml:space="preserve">
          <source>Member functions</source>
          <target state="translated">メンバー機能</target>
        </trans-unit>
        <trans-unit id="d58072c4501a38b0ae1c8099bd6324750503224c" translate="yes" xml:space="preserve">
          <source>Member functions are called with dot notation:</source>
          <target state="translated">メンバ関数はドット表記で呼び出されます。</target>
        </trans-unit>
        <trans-unit id="90302bd1ef8edadba09a04d671c6ada71d5d8a46" translate="yes" xml:space="preserve">
          <source>Member functions define operations that are essential for a collection type. For example, &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-collection/index&quot;&gt;&lt;code&gt;Collection&lt;/code&gt;&lt;/a&gt; contains the function &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-collection/is-empty&quot;&gt;&lt;code&gt;isEmpty()&lt;/code&gt;&lt;/a&gt; for checking its emptiness; &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-list/index&quot;&gt;&lt;code&gt;List&lt;/code&gt;&lt;/a&gt; contains &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-list/get&quot;&gt;&lt;code&gt;get()&lt;/code&gt;&lt;/a&gt; for index access to elements, and so on.</source>
          <target state="translated">メンバー関数は、コレクション型に不可欠な操作を定義します。たとえば、&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-collection/index&quot;&gt; &lt;code&gt;Collection&lt;/code&gt; に&lt;/a&gt;は、空をチェックするための関数&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-collection/is-empty&quot;&gt; &lt;code&gt;isEmpty()&lt;/code&gt; &lt;/a&gt;が含まれています。&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-list/index&quot;&gt; &lt;code&gt;List&lt;/code&gt; &lt;/a&gt;は、要素へのインデックスアクセスのための&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-list/get&quot;&gt; &lt;code&gt;get()&lt;/code&gt; &lt;/a&gt;などが含まれます。</target>
        </trans-unit>
        <trans-unit id="a569ddca50a19b2205ceb3e1f59db2a7ba968aef" translate="yes" xml:space="preserve">
          <source>Member properties and member functions inside a generic class may for the most part use the class' generic type parameters as if they were ordinary types, without having to redeclare them. It is also possible to make functions that take more generic parameters than the class does, and to make generic functions inside nongeneric classes, and to make generic top-level functions (which is what we'll do in the next example). Note the different placement of the generic type parameter in generic function declarations:</source>
          <target state="translated">ジェネリック・クラス内のメンバ・プロパティやメンバ関数は、大抵の場合、そのクラスのジェネリック・タイプ・パラメータを再宣言することなく、通常のタイプであるかのように使用することができます。また、クラスよりも多くの汎用型パラメータを取る関数を作成したり、非汎用クラス内で汎用型関数を作成したり、汎用トップレベル関数を作成したりすることも可能です(これは次の例で説明します)。ジェネリック関数の宣言におけるジェネリック型パラメータの配置の違いに注意してください。</target>
        </trans-unit>
        <trans-unit id="74971806b05c2768bdffa67bcc7b89b958d7edea" translate="yes" xml:space="preserve">
          <source>Member references and reflection</source>
          <target state="translated">メンバーの参照と反省</target>
        </trans-unit>
        <trans-unit id="10aac04b8647c134bc4873cf9a0d33a0bd4048e1" translate="yes" xml:space="preserve">
          <source>MemberAt</source>
          <target state="translated">MemberAt</target>
        </trans-unit>
        <trans-unit id="1cb449c1126609b4b41e1d87f65f0d7cd19b49b9" translate="yes" xml:space="preserve">
          <source>Members</source>
          <target state="translated">Members</target>
        </trans-unit>
        <trans-unit id="2fd5b3fb4a679664c9a47a448257d9fa802a22f3" translate="yes" xml:space="preserve">
          <source>Members of Objective-C categories and Swift extensions are imported to Kotlin as extensions. That's why these declarations can't be overridden in Kotlin. And the extension initializers aren't available as Kotlin constructors.</source>
          <target state="translated">Objective-CのカテゴリのメンバーやSwiftの拡張機能は拡張機能としてKotlinにインポートされます。そのため、これらの宣言はKotlinではオーバーライドできません。また、拡張機能のイニシャライザはKotlinのコンストラクタとして利用できません。</target>
        </trans-unit>
        <trans-unit id="c590aa47cb148126a7aed2e0252e6e56de2e1fb5" translate="yes" xml:space="preserve">
          <source>Members of the companion object can be called by using simply the class name as the qualifier:</source>
          <target state="translated">コンパニオン・オブジェクトのメンバは、単にクラス名を修飾子として使用することで呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="b61b70edbe3a97caa2ecb5ac100b7aca209a1cba" translate="yes" xml:space="preserve">
          <source>Memory allocation</source>
          <target state="translated">メモリの割り当て</target>
        </trans-unit>
        <trans-unit id="0c2ee25c3007f8df17e0050402341b2f4ae697bc" translate="yes" xml:space="preserve">
          <source>Memory model binary was compiled with.</source>
          <target state="translated">メモリモデルのバイナリをコンパイルしました。</target>
        </trans-unit>
        <trans-unit id="e73a4635af37ee3ef43681ca08ff16f60452ecfe" translate="yes" xml:space="preserve">
          <source>Memory model.</source>
          <target state="translated">メモリモデル。</target>
        </trans-unit>
        <trans-unit id="69164a09919e64cc770d2e92a315c7be5fe9ce87" translate="yes" xml:space="preserve">
          <source>MemoryModel</source>
          <target state="translated">MemoryModel</target>
        </trans-unit>
        <trans-unit id="2a2bb3d6a7f5790d759cba72823f3811d734fe09" translate="yes" xml:space="preserve">
          <source>MessageChannel</source>
          <target state="translated">MessageChannel</target>
        </trans-unit>
        <trans-unit id="ccca7aad0aa3bbb87c9ea30bfca4cd685ee282a6" translate="yes" xml:space="preserve">
          <source>MessageEventInit</source>
          <target state="translated">MessageEventInit</target>
        </trans-unit>
        <trans-unit id="da50feb28afa8ee6b84decde6712247ff2db1356" translate="yes" xml:space="preserve">
          <source>Metacharacters or escape sequences in the input sequence will be given no special meaning.</source>
          <target state="translated">入力シーケンス内のメタキャラクタやエスケープシーケンスには特別な意味は与えられません。</target>
        </trans-unit>
        <trans-unit id="251edc0eb5a820646bda4e103f0f007fd55321f3" translate="yes" xml:space="preserve">
          <source>Metadata</source>
          <target state="translated">Metadata</target>
        </trans-unit>
        <trans-unit id="00c97618202a4d85cdcf254062dd76c688bb9937" translate="yes" xml:space="preserve">
          <source>Metadata in a custom format. The format may be different (or even absent) for different kinds.</source>
          <target state="translated">カスタムフォーマットのメタデータ。フォーマットは種類によって異なる(あるいは存在しない)場合があります。</target>
        </trans-unit>
        <trans-unit id="88306943fea7e76f9cd57cae0ea6d8b32d2e8434" translate="yes" xml:space="preserve">
          <source>Method</source>
          <target state="translated">Method</target>
        </trans-unit>
        <trans-unit id="6ef376dbda2a9dfd9fe8fb9172d6ea36380a325e" translate="yes" xml:space="preserve">
          <source>Method call formatting</source>
          <target state="translated">メソッド呼び出しの書式設定</target>
        </trans-unit>
        <trans-unit id="3643c572e5a5065b656aa6b5fce445bafca060de" translate="yes" xml:space="preserve">
          <source>Method declarations</source>
          <target state="translated">メソッド宣言</target>
        </trans-unit>
        <trans-unit id="6c23f25a80838dd8e19f20f6fec8854933be69db" translate="yes" xml:space="preserve">
          <source>Method names translation</source>
          <target state="translated">メソッド名の翻訳</target>
        </trans-unit>
        <trans-unit id="88533fb91c329fcc07daac7abd293e3d2ef386bf" translate="yes" xml:space="preserve">
          <source>Methods &lt;code&gt;wait()&lt;/code&gt; and &lt;code&gt;notify()&lt;/code&gt; are not available on references of type &lt;code&gt;Any&lt;/code&gt;. Their usage is generally discouraged in favor of &lt;code&gt;java.util.concurrent&lt;/code&gt;. If you really need to call these methods, you can cast to &lt;code&gt;java.lang.Object&lt;/code&gt;:</source>
          <target state="translated">メソッド &lt;code&gt;wait()&lt;/code&gt; および &lt;code&gt;notify()&lt;/code&gt; は、タイプ &lt;code&gt;Any&lt;/code&gt; の参照では使用できません。通常、 &lt;code&gt;java.util.concurrent&lt;/code&gt; を使用することをお勧めします。これらのメソッドを呼び出す必要がある場合は、 &lt;code&gt;java.lang.Object&lt;/code&gt; にキャストできます。</target>
        </trans-unit>
        <trans-unit id="04764bae2f3b42e32503d658246fd786e62d1716" translate="yes" xml:space="preserve">
          <source>Methods defined in &lt;code&gt;MyList&amp;lt;T&amp;gt;&lt;/code&gt; use &lt;code&gt;T&lt;/code&gt; as platform, i.e. it's possible to perform unsafe operation in Kotlin:</source>
          <target state="translated">&lt;code&gt;MyList&amp;lt;T&amp;gt;&lt;/code&gt; 定義されたメソッドは、プラットフォームとして &lt;code&gt;T&lt;/code&gt; を使用します。つまり、Kotlinで安全でない操作を実行することが可能です。</target>
        </trans-unit>
        <trans-unit id="2362d4b5d61680189ee786359c95c772832ea599" translate="yes" xml:space="preserve">
          <source>Methods defined in &lt;code&gt;MyPureList&amp;lt;T&amp;gt;&lt;/code&gt; overriding methods in &lt;code&gt;MutableList&lt;/code&gt; use &lt;code&gt;T&lt;/code&gt; as non-platform types:</source>
          <target state="translated">で定義されているメソッド &lt;code&gt;MyPureList&amp;lt;T&amp;gt;&lt;/code&gt; のメソッドのオーバーライド &lt;code&gt;MutableList&lt;/code&gt; 使用 &lt;code&gt;T&lt;/code&gt; を非プラットフォーム型として：</target>
        </trans-unit>
        <trans-unit id="1643049f5673b4e1c5eb74d112c9611cf055d3c5" translate="yes" xml:space="preserve">
          <source>Methods returning void</source>
          <target state="translated">void を返すメソッド</target>
        </trans-unit>
        <trans-unit id="a8027f1188b3014c0f8995cd7120023b72397d3d" translate="yes" xml:space="preserve">
          <source>Methods that follow the Java conventions for getters and setters (no-argument methods with names starting with &lt;code&gt;get&lt;/code&gt; and single-argument methods with names starting with &lt;code&gt;set&lt;/code&gt;) are represented as properties in Kotlin. &lt;code&gt;Boolean&lt;/code&gt; accessor methods (where the name of the getter starts with &lt;code&gt;is&lt;/code&gt; and the name of the setter starts with &lt;code&gt;set&lt;/code&gt;) are represented as properties which have the same name as the getter method.</source>
          <target state="translated">getterとsetterのJava規則に従うメソッド（名前が &lt;code&gt;get&lt;/code&gt; で始まる引数のないメソッドと名前が &lt;code&gt;set&lt;/code&gt; で始まる単一引数のメソッド）は、Kotlinではプロパティとして表されます。 &lt;code&gt;Boolean&lt;/code&gt; アクセサーメソッド（ゲッターの名前が &lt;code&gt;is&lt;/code&gt; で始まり、セッターの名前が &lt;code&gt;set&lt;/code&gt; で始まる）は、ゲッターメソッドと同じ名前を持つプロパティとして表されます。</target>
        </trans-unit>
        <trans-unit id="a23dee2288fafb96e4e3f4b56c185b2062a8905b" translate="yes" xml:space="preserve">
          <source>Micronaut also has a lot of well-detailed &lt;a href=&quot;https://guides.micronaut.io/tags/kotlin.html&quot;&gt;guides&lt;/a&gt;, showing how you can build microservices in Kotlin.</source>
          <target state="translated">Micronautには、Kotlinでマイクロサービスを構築する方法を示す詳細な&lt;a href=&quot;https://guides.micronaut.io/tags/kotlin.html&quot;&gt;ガイド&lt;/a&gt;も多数あります。</target>
        </trans-unit>
        <trans-unit id="2474109210e0ea672543f6c977728ae54b8f124d" translate="yes" xml:space="preserve">
          <source>Migrate the code with the help of the tooling</source>
          <target state="translated">ツールの助けを借りてコードを移行する</target>
        </trans-unit>
        <trans-unit id="708b9cf32b4bb9e8e85c01bf95c0ef78c92becb6" translate="yes" xml:space="preserve">
          <source>Migrating from Java</source>
          <target state="translated">Javaからの移行</target>
        </trans-unit>
        <trans-unit id="b9d3a9e9670f7240a77d83260fefdcb2501bc774" translate="yes" xml:space="preserve">
          <source>Migrating to Kotlin</source>
          <target state="translated">コトリンへの移行</target>
        </trans-unit>
        <trans-unit id="f44d82dafb548c8ad9d6490ef0e69cd3d1ba217d" translate="yes" xml:space="preserve">
          <source>Migration to a new code style</source>
          <target state="translated">新しいコードスタイルへの移行</target>
        </trans-unit>
        <trans-unit id="d0a1c8e409ae53cb281e66770ad717b9178d43ce" translate="yes" xml:space="preserve">
          <source>Migration to a new code style discussion</source>
          <target state="translated">新しいコードスタイルへの移行議論</target>
        </trans-unit>
        <trans-unit id="1bd7ccbde8d3077fec1f549017e747393223a900" translate="yes" xml:space="preserve">
          <source>MimeType</source>
          <target state="translated">MimeType</target>
        </trans-unit>
        <trans-unit id="ed52d3a5f9993b67e83d292332a8f9a1d86ebf44" translate="yes" xml:space="preserve">
          <source>MimeTypeArray</source>
          <target state="translated">MimeTypeArray</target>
        </trans-unit>
        <trans-unit id="98f205e04abca4bbe7595051d07e6eb3a4abe953" translate="yes" xml:space="preserve">
          <source>Min value</source>
          <target state="translated">最小値</target>
        </trans-unit>
        <trans-unit id="222d1f694d764125a7a7a5786d11a04234b0be8d" translate="yes" xml:space="preserve">
          <source>Missing errors in class constructor&amp;rsquo;s &lt;code&gt;@get:&lt;/code&gt; annotations</source>
          <target state="translated">クラスコンストラクターの &lt;code&gt;@get:&lt;/code&gt; アノテーションに欠落しているエラー</target>
        </trans-unit>
        <trans-unit id="47e4750870ece5e5c348eda89bdc8e3fbb4c6cff" translate="yes" xml:space="preserve">
          <source>Missing getter-targeted annotations on annotation constructor parameters</source>
          <target state="translated">アノテーション コンストラクタのパラメータにゲッターをターゲットにしたアノテーションが存在しない</target>
        </trans-unit>
        <trans-unit id="52b91c038ffc21a08d48959a44ba1c6fddb114f2" translate="yes" xml:space="preserve">
          <source>Mixed Java and Kotlin</source>
          <target state="translated">JavaとKotlinの混合</target>
        </trans-unit>
        <trans-unit id="86c40367cc1e1c53a8c10c73ada1f29fd66c1405" translate="yes" xml:space="preserve">
          <source>Mixing Java and Kotlin in one project</source>
          <target state="translated">JavaとKotlinを一つのプロジェクトに混ぜる</target>
        </trans-unit>
        <trans-unit id="404ab93e44ed76b5232ab6931dd26299f542e43d" translate="yes" xml:space="preserve">
          <source>Modern debuggers provide several ways to set a breakpoint, see below for a tool-by-tool breakdown:</source>
          <target state="translated">最近のデバッガはブレークポイントを設定する方法をいくつか提供しています。</target>
        </trans-unit>
        <trans-unit id="5ba6ee64964304bc6c3c5424baba2b34cd73ea5d" translate="yes" xml:space="preserve">
          <source>Modifier Keywords</source>
          <target state="translated">修飾キーワード</target>
        </trans-unit>
        <trans-unit id="3a7ea294bf33134dce4b142b8b7182de29b978b2" translate="yes" xml:space="preserve">
          <source>Modifiers</source>
          <target state="translated">Modifiers</target>
        </trans-unit>
        <trans-unit id="42cd86d0e702bd27bcb835a0b162fb95197132a2" translate="yes" xml:space="preserve">
          <source>Modifies the value of the property.</source>
          <target state="translated">プロパティの値を変更します。</target>
        </trans-unit>
        <trans-unit id="723a9a05eb17a0ec38db3b56d4b0ea18be0358a6" translate="yes" xml:space="preserve">
          <source>Module and Package Documentation</source>
          <target state="translated">モジュールとパッケージのドキュメント</target>
        </trans-unit>
        <trans-unit id="ed8def074470e81fe96b7cdd8aac08ec3fff3bc6" translate="yes" xml:space="preserve">
          <source>Module system used by the Kotlin Standard Library</source>
          <target state="translated">Kotlin 標準ライブラリで使用されているモジュールシステム</target>
        </trans-unit>
        <trans-unit id="ec446b6ebb15f053c4868dce62c242283cf04673" translate="yes" xml:space="preserve">
          <source>Module-wide markers</source>
          <target state="translated">モジュール全体のマーカー</target>
        </trans-unit>
        <trans-unit id="738fa33a16ad3f30c737fafc42459e4a03f30470" translate="yes" xml:space="preserve">
          <source>Module-wide use</source>
          <target state="translated">モジュール全体での使用</target>
        </trans-unit>
        <trans-unit id="04e9462c0ff02bb9032b92abd45881a3c7e15fb7" translate="yes" xml:space="preserve">
          <source>Modules</source>
          <target state="translated">Modules</target>
        </trans-unit>
        <trans-unit id="d62ac0bf808c354dcb97b6778e8aaae4635a7c9f" translate="yes" xml:space="preserve">
          <source>More details and advanced use-cases are presented in the</source>
          <target state="translated">詳細と高度なユースケースについては、以下を参照してください。</target>
        </trans-unit>
        <trans-unit id="91aa2ec21d9f2bac781876761e04b45d52ef74fe" translate="yes" xml:space="preserve">
          <source>More documentation on the types mapping can be found in the &lt;a href=&quot;../../reference/native/objc_interop&quot;&gt;Objective-C Interop&lt;/a&gt; article.</source>
          <target state="translated">型マッピングの詳細については、&lt;a href=&quot;../../reference/native/objc_interop&quot;&gt;Objective-C Interopの&lt;/a&gt;記事をご覧ください。</target>
        </trans-unit>
        <trans-unit id="b5c09addc98121bf0f9aad66c228b38f1430aecf" translate="yes" xml:space="preserve">
          <source>More information about all other types mapping details can be found in the &lt;a href=&quot;../../reference/native/objc_interop&quot;&gt;Objective-C Interop&lt;/a&gt; documentation article</source>
          <target state="translated">他のすべてのタイプマッピングの詳細については、&lt;a href=&quot;../../reference/native/objc_interop&quot;&gt;Objective-C Interopの&lt;/a&gt;ドキュメントの記事をご覧ください。</target>
        </trans-unit>
        <trans-unit id="b061f32f9ec8d43b64e344ed5485c4d9f7caf378" translate="yes" xml:space="preserve">
          <source>More tips and tricks</source>
          <target state="translated">より多くのヒントとトリック</target>
        </trans-unit>
        <trans-unit id="e9792383929cbb7b1909aa88012c0f218c0c51f8" translate="yes" xml:space="preserve">
          <source>Most built-in types are comparable:</source>
          <target state="translated">ビルトインタイプはほとんどが比較対象となります。</target>
        </trans-unit>
        <trans-unit id="f9f0f6eb5ddb49db8f8ae5d8eb9cab0176d9ace5" translate="yes" xml:space="preserve">
          <source>Most of the functionality of signed types are supported for unsigned counterparts too:</source>
          <target state="translated">符号付き型の機能のほとんどは、符号なしの対応するものでもサポートされています。</target>
        </trans-unit>
        <trans-unit id="cb91c080f7b68ae6a8bbb2b702b1059a13b12c96" translate="yes" xml:space="preserve">
          <source>Most of the operators that are recognized by Kotlin's syntax have predefined textual names and are available for implementation in your classes, just like you can do with Python's double-underscore operator names. For example, the binary &lt;code&gt;+&lt;/code&gt; operator is called &lt;code&gt;plus&lt;/code&gt;. Similarly to the infix example, if you do this inside a &lt;code&gt;Person&lt;/code&gt; class that has got a &lt;code&gt;name&lt;/code&gt; property:</source>
          <target state="translated">Kotlinの構文で認識されるほとんどの演算子には、定義済みのテキスト名があり、Pythonの二重下線演算子名と同じように、クラスに実装できます。たとえば、二項 &lt;code&gt;+&lt;/code&gt; 演算子は &lt;code&gt;plus&lt;/code&gt; と呼ばれます。infixの例と同様に、 &lt;code&gt;name&lt;/code&gt; プロパティを持つ &lt;code&gt;Person&lt;/code&gt; クラス内でこれを行うと、次のようになります。</target>
        </trans-unit>
        <trans-unit id="ef0792097f4b2ac5841fae23eda77fe48d6f36a5" translate="yes" xml:space="preserve">
          <source>Most of the time we define extensions on the top level - directly under packages:</source>
          <target state="translated">ほとんどの場合、パッケージの直下にあるトップレベルの拡張機能を定義しています。</target>
        </trans-unit>
        <trans-unit id="3edbae2a158aaf025c7463b2890fdba1f30e0552" translate="yes" xml:space="preserve">
          <source>Most of the time we define extensions on the top level, i.e. directly under packages:</source>
          <target state="translated">ほとんどの場合、トップレベル、つまりパッケージの直下で拡張機能を定義します。</target>
        </trans-unit>
        <trans-unit id="d6a06199cc127e571d3588aef63c79108675eabc" translate="yes" xml:space="preserve">
          <source>Motivation</source>
          <target state="translated">Motivation</target>
        </trans-unit>
        <trans-unit id="e5f579f208747beb161cf00d47a3a0c086f81dbe" translate="yes" xml:space="preserve">
          <source>MouseEventInit</source>
          <target state="translated">MouseEventInit</target>
        </trans-unit>
        <trans-unit id="19754c53e87ae21affdf187e21540a29ec7c1fa2" translate="yes" xml:space="preserve">
          <source>Much like we reference an input element, we can access other elements on the page, casting them to the appropriate types.</source>
          <target state="translated">入力要素を参照するのと同じように、ページ上の他の要素にアクセスし、それらを適切な型にキャストすることができます。</target>
        </trans-unit>
        <trans-unit id="85e61eaa48d6be8dae51bf80212b85c25bd2b301" translate="yes" xml:space="preserve">
          <source>Much the same way as regular properties, the properties declared in the primary constructor can be mutable (&lt;em&gt;var&lt;/em&gt;) or read-only (&lt;em&gt;val&lt;/em&gt;).</source>
          <target state="translated">通常のプロパティとほとんど同じように、プライマリコンストラクタで宣言されたプロパティは、変更可能（&lt;em&gt;var&lt;/em&gt;）または読み取り専用（&lt;em&gt;val&lt;/em&gt;）にすることができます。</target>
        </trans-unit>
        <trans-unit id="bf10a69dc3111e2f0b70a7a3b5fcde0eb5de58f0" translate="yes" xml:space="preserve">
          <source>Multiplatform &lt;code&gt;Random&lt;/code&gt;</source>
          <target state="translated">マルチプラットフォーム &lt;code&gt;Random&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4d27d69385dad1ecc38485d70b593ff3be6501e1" translate="yes" xml:space="preserve">
          <source>Multiplatform Gradle Project</source>
          <target state="translated">マルチプラットフォームのGradleプロジェクト</target>
        </trans-unit>
        <trans-unit id="b476304566bdb2c8284f4c5fabc7060e30563d1f" translate="yes" xml:space="preserve">
          <source>Multiplatform Kotlin Library</source>
          <target state="translated">マルチプラットフォームのKotlinライブラリ</target>
        </trans-unit>
        <trans-unit id="594342484b7fa8723561cd74a56adf5ed5eecd56" translate="yes" xml:space="preserve">
          <source>Multiplatform Kotlin library</source>
          <target state="translated">マルチプラットフォームのKotlinライブラリ</target>
        </trans-unit>
        <trans-unit id="abdd2b4ca66085ea36500996c307f3c54d5bee0a" translate="yes" xml:space="preserve">
          <source>Multiplatform Libraries</source>
          <target state="translated">マルチプラットフォームライブラリ</target>
        </trans-unit>
        <trans-unit id="49bdb75dde412727c37ad9cfdc25f84b9800e1ee" translate="yes" xml:space="preserve">
          <source>Multiplatform Programming</source>
          <target state="translated">マルチプラットフォームプログラミング</target>
        </trans-unit>
        <trans-unit id="8831ff8afbd886576a6d26e7a38c2a2945370e5f" translate="yes" xml:space="preserve">
          <source>Multiplatform Project: iOS and Android</source>
          <target state="translated">マルチプラットフォームプロジェクト:iOSとAndroid</target>
        </trans-unit>
        <trans-unit id="5cff52171a748c24fbdfa2675a9193d1e17c8b90" translate="yes" xml:space="preserve">
          <source>Multiplatform Projects</source>
          <target state="translated">マルチプラットフォームプロジェクト</target>
        </trans-unit>
        <trans-unit id="30ece0cd52430a4d7a64233600e1721dbcbbe2bf" translate="yes" xml:space="preserve">
          <source>Multiplatform Projects (experimental)</source>
          <target state="translated">マルチプラットフォームプロジェクト(実験的</target>
        </trans-unit>
        <trans-unit id="0198731e127deda4e2a86e65a7c2c819b3c35ae8" translate="yes" xml:space="preserve">
          <source>Multiplatform documentation</source>
          <target state="translated">マルチプラットフォームのドキュメント</target>
        </trans-unit>
        <trans-unit id="8f424e82581dd0443f6b1cfe8761404b9445347c" translate="yes" xml:space="preserve">
          <source>Multiplatform programming</source>
          <target state="translated">マルチプラットフォームプログラミング</target>
        </trans-unit>
        <trans-unit id="dce33eff96bb2026a847a2a553a328f131ebdfe5" translate="yes" xml:space="preserve">
          <source>Multiplatform projects</source>
          <target state="translated">マルチプラットフォーム プロジェクト</target>
        </trans-unit>
        <trans-unit id="48104e942ea0eb10a48e224f17bd6af63a0f01ad" translate="yes" xml:space="preserve">
          <source>Multiplatform projects are a new &lt;strong&gt;experimental&lt;/strong&gt; feature in Kotlin 1.2, allowing you to reuse code between target platforms supported by Kotlin &amp;ndash; JVM, JavaScript and (in the future) Native. In a multiplatform project, you have three kinds of modules:</source>
          <target state="translated">マルチプラットフォームプロジェクトはKotlin 1.2の新しい&lt;strong&gt;実験的&lt;/strong&gt;機能であり、Kotlinでサポートされているターゲットプラットフォーム間でコードを再利用できます&amp;ndash; JVM、JavaScript、および（将来的には）ネイティブ。マルチプラットフォームプロジェクトには、3種類のモジュールがあります。</target>
        </trans-unit>
        <trans-unit id="56c55ee3ca3b8c8dc0a5fe577d6b3cbe7b6bf668" translate="yes" xml:space="preserve">
          <source>Multiplatform projects are an experimental feature in Kotlin 1.2 and 1.3. All of the language and tooling features described in this document are subject to change in future Kotlin versions.</source>
          <target state="translated">マルチプラットフォームプロジェクトはKotlin 1.2と1.3では実験的な機能です。このドキュメントに記載されている言語やツールの機能はすべて、将来のKotlinのバージョンで変更される可能性があります。</target>
        </trans-unit>
        <trans-unit id="7e1b4e8641ccf9f8084108431aa99a93d1fa43a8" translate="yes" xml:space="preserve">
          <source>Multiplatform projects are in &lt;a href=&quot;evolution/components-stability&quot;&gt;Alpha&lt;/a&gt;. Language features and tooling may change in future Kotlin versions.</source>
          <target state="translated">マルチプラットフォームプロジェクトは&lt;a href=&quot;evolution/components-stability&quot;&gt;アルファ版&lt;/a&gt;です。言語機能とツールは、将来のKotlinバージョンで変更される可能性があります。</target>
        </trans-unit>
        <trans-unit id="a47f8ee1f56229364d475a5b4995314b84d9fc4e" translate="yes" xml:space="preserve">
          <source>Multiple coroutines may receive from the same channel, distributing work between themselves. Let us start with a producer coroutine that is periodically producing integers (ten numbers per second):</source>
          <target state="translated">複数のコルーチンは、同じチャネルから受信して、自分たちの間で作業を分配することができます。ここでは、周期的に整数(毎秒10個の数)を生成しているプロデューサー・コルーチンから始めてみましょう。</target>
        </trans-unit>
        <trans-unit id="264744e655406950142eec2a53dc539eed8a5fd7" translate="yes" xml:space="preserve">
          <source>Multiple coroutines may send to the same channel. For example, let us have a channel of strings, and a suspending function that repeatedly sends a specified string to this channel with a specified delay:</source>
          <target state="translated">複数のコルーチンが同じチャンネルに送信することがあります。例えば、文字列のチャンネルがあり、このチャンネルに指定された文字列を指定された遅延時間で繰り返し送信するサスペンド関数があるとします。</target>
        </trans-unit>
        <trans-unit id="9d79d3118202ae1d668fb56014f9cb20b36159e5" translate="yes" xml:space="preserve">
          <source>Multiplies this value by the other value.</source>
          <target state="translated">この値に他の値を乗算します。</target>
        </trans-unit>
        <trans-unit id="f342e79f479c63b3a6f1a4035901daea4fbf30b9" translate="yes" xml:space="preserve">
          <source>MustBeDocumented</source>
          <target state="translated">MustBeDocumented</target>
        </trans-unit>
        <trans-unit id="07b00606431523d4ebea7077981984b607d973e8" translate="yes" xml:space="preserve">
          <source>Mutable closure variables</source>
          <target state="translated">変形可能なクロージャ変数</target>
        </trans-unit>
        <trans-unit id="e427611262df2a9a50ee135e0fceaecfa0c80c7f" translate="yes" xml:space="preserve">
          <source>Mutable concurrently accessible data buffer. Could be accessed from several workers simulteniously.</source>
          <target state="translated">同時アクセス可能なデータバッファ。複数のワーカーから同時にアクセス可能。</target>
        </trans-unit>
        <trans-unit id="46fb0a3dd2497d28351f3b643be68bf38c4dcf04" translate="yes" xml:space="preserve">
          <source>Mutable iterators</source>
          <target state="translated">可換イテレータ</target>
        </trans-unit>
        <trans-unit id="9b7b2307fe92cd7c012fa39281f7b175b249dd6e" translate="yes" xml:space="preserve">
          <source>MutableCollection</source>
          <target state="translated">MutableCollection</target>
        </trans-unit>
        <trans-unit id="42724994b4f6f408170a142d4bb3a6bfa7198849" translate="yes" xml:space="preserve">
          <source>MutableCollection.iterator</source>
          <target state="translated">MutableCollection.iterator</target>
        </trans-unit>
        <trans-unit id="1a5033d42eefb58adbea823fa5255b0aed1d662e" translate="yes" xml:space="preserve">
          <source>MutableData</source>
          <target state="translated">MutableData</target>
        </trans-unit>
        <trans-unit id="5e9e097c14385f745d368faabbd3854a67b05b46" translate="yes" xml:space="preserve">
          <source>MutableEntry</source>
          <target state="translated">MutableEntry</target>
        </trans-unit>
        <trans-unit id="8a4f4102af09300cf876f9a6460618caaa96575a" translate="yes" xml:space="preserve">
          <source>MutableIterable</source>
          <target state="translated">MutableIterable</target>
        </trans-unit>
        <trans-unit id="a652e5941b9ff793ccc9e659b88bf1a8f5227c3a" translate="yes" xml:space="preserve">
          <source>MutableIterator</source>
          <target state="translated">MutableIterator</target>
        </trans-unit>
        <trans-unit id="49e02d16b11d601b6e4902190c5bca350a9202fc" translate="yes" xml:space="preserve">
          <source>MutableList</source>
          <target state="translated">MutableList</target>
        </trans-unit>
        <trans-unit id="4c650d57f6075cf5940d694638ac9e4ec8e77bc6" translate="yes" xml:space="preserve">
          <source>MutableListIterator</source>
          <target state="translated">MutableListIterator</target>
        </trans-unit>
        <trans-unit id="f20ff48f1ceb7119a78b4b13a251cf2c7628b7ac" translate="yes" xml:space="preserve">
          <source>MutableMap</source>
          <target state="translated">MutableMap</target>
        </trans-unit>
        <trans-unit id="c0a289c1f11c0248072d86bca1271c7246850c9c" translate="yes" xml:space="preserve">
          <source>MutableSet</source>
          <target state="translated">MutableSet</target>
        </trans-unit>
        <trans-unit id="0b5d551add97f7ca81d05d95c5a9f114421d02ad" translate="yes" xml:space="preserve">
          <source>Mutating the backing field of a read-only property by assigning &lt;code&gt;field = ...&lt;/code&gt; in the custom getter has been deprecated, with a warning in Kotlin 1.2 and an error in Kotlin 1.3.</source>
          <target state="translated">カスタムゲッターで &lt;code&gt;field = ...&lt;/code&gt; を割り当てることによる読み取り専用プロパティのバッキングフィールドの変更は非推奨になりました。Kotlin1.2では警告が表示され、Kotlin 1.3ではエラーが表示されます。</target>
        </trans-unit>
        <trans-unit id="d9e09542ba7562ba06b3618d585343bb16717cc0" translate="yes" xml:space="preserve">
          <source>MutationObserver</source>
          <target state="translated">MutationObserver</target>
        </trans-unit>
        <trans-unit id="bf760ce86085d0556b58a1fb2886ad6300cf25c9" translate="yes" xml:space="preserve">
          <source>MutationObserverInit</source>
          <target state="translated">MutationObserverInit</target>
        </trans-unit>
        <trans-unit id="902e161ec72b34937173fb6ae6f1167c6c4b933a" translate="yes" xml:space="preserve">
          <source>MutationRecord</source>
          <target state="translated">MutationRecord</target>
        </trans-unit>
        <trans-unit id="bd89464f515bc7c1945f885ef807721ee91c256b" translate="yes" xml:space="preserve">
          <source>Mutual exclusion</source>
          <target state="translated">相互排除</target>
        </trans-unit>
        <trans-unit id="f2a0cc7430b6ab201c123d93595f5409656e44aa" translate="yes" xml:space="preserve">
          <source>Mutual exclusion solution to the problem is to protect all modifications of the shared state with a &lt;em&gt;critical section&lt;/em&gt; that is never executed concurrently. In a blocking world you'd typically use &lt;code&gt;synchronized&lt;/code&gt; or &lt;code&gt;ReentrantLock&lt;/code&gt; for that. Coroutine's alternative is called &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.sync/-mutex/index.html&quot;&gt;Mutex&lt;/a&gt;. It has &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.sync/-mutex/lock.html&quot;&gt;lock&lt;/a&gt; and &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.sync/-mutex/unlock.html&quot;&gt;unlock&lt;/a&gt; functions to delimit a critical section. The key difference is that &lt;code&gt;Mutex.lock()&lt;/code&gt; is a suspending function. It does not block a thread.</source>
          <target state="translated">この問題に対する相互排除ソリューションは、共有状態のすべての変更を、同時に実行されることのない&lt;em&gt;クリティカルセクション&lt;/em&gt;で保護することです。ブロッキングの世界では、通常、 &lt;code&gt;synchronized&lt;/code&gt; または &lt;code&gt;ReentrantLock&lt;/code&gt; を使用します。コルーチンの代替は&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.sync/-mutex/index.html&quot;&gt;ミューテックス&lt;/a&gt;と呼ばれています。重要なセクションを区切るための&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.sync/-mutex/lock.html&quot;&gt;ロック&lt;/a&gt;および&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.sync/-mutex/unlock.html&quot;&gt;ロック解除&lt;/a&gt;機能があります。主な違いは、 &lt;code&gt;Mutex.lock()&lt;/code&gt; が中断関数であることです。スレッドをブロックしません。</target>
        </trans-unit>
        <trans-unit id="e6a87480ef216b736cda78776d20937ae965a5a1" translate="yes" xml:space="preserve">
          <source>My first coroutine</source>
          <target state="translated">私の最初のコルチン</target>
        </trans-unit>
        <trans-unit id="08d2e98e6754af941484848930ccbaddfefe13d6" translate="yes" xml:space="preserve">
          <source>N/A</source>
          <target state="translated">N/A</target>
        </trans-unit>
        <trans-unit id="ac5af3d78fb9a248a0c8878049fa45cb722c5609" translate="yes" xml:space="preserve">
          <source>NEGATIVE_INFINITY</source>
          <target state="translated">NEGATIVE_INFINITY</target>
        </trans-unit>
        <trans-unit id="0654a028e5aea48c8fbb09871b8f397a186c883b" translate="yes" xml:space="preserve">
          <source>NONE</source>
          <target state="translated">NONE</target>
        </trans-unit>
        <trans-unit id="19b5db1284eda5fe55423cf6ff666bbd91d48790" translate="yes" xml:space="preserve">
          <source>NONSPACING_MARK</source>
          <target state="translated">NONSPACING_MARK</target>
        </trans-unit>
        <trans-unit id="a711913b07f219db3720165b1cc42ba33ab84d07" translate="yes" xml:space="preserve">
          <source>NON_SPACING_MARK</source>
          <target state="translated">NON_SPACING_MARK</target>
        </trans-unit>
        <trans-unit id="b12d9f3adce16f3c42e185c9323b0f2c05d0d02a" translate="yes" xml:space="preserve">
          <source>NOTE: Octal literals are not supported.</source>
          <target state="translated">注:八進数リテラルはサポートされていません。</target>
        </trans-unit>
        <trans-unit id="c820cc676951d2a6935d55d3c748ef2d4229e0ef" translate="yes" xml:space="preserve">
          <source>NSArray</source>
          <target state="translated">NSArray</target>
        </trans-unit>
        <trans-unit id="850a25e67ede967c8226916d9435ee3fa9fe30c0" translate="yes" xml:space="preserve">
          <source>NSDictionary</source>
          <target state="translated">NSDictionary</target>
        </trans-unit>
        <trans-unit id="88142d93bc155af7430eda23b521adf5177befb3" translate="yes" xml:space="preserve">
          <source>NSMutableArray</source>
          <target state="translated">NSMutableArray</target>
        </trans-unit>
        <trans-unit id="093cc39541f1d88e9c8d7815809e04abdc468222" translate="yes" xml:space="preserve">
          <source>NSMutableDictionary</source>
          <target state="translated">NSMutableDictionary</target>
        </trans-unit>
        <trans-unit id="6f353d0803276b29f669e8e00d5912e0735d118f" translate="yes" xml:space="preserve">
          <source>NSMutableString</source>
          <target state="translated">NSMutableString</target>
        </trans-unit>
        <trans-unit id="21b6f3d1ecc982003af64b405b1aec1eeffcbd63" translate="yes" xml:space="preserve">
          <source>NSNumber</source>
          <target state="translated">NSNumber</target>
        </trans-unit>
        <trans-unit id="6049050154f9c68876906ec983b62a8beb7bfd87" translate="yes" xml:space="preserve">
          <source>NSSet</source>
          <target state="translated">NSSet</target>
        </trans-unit>
        <trans-unit id="f7fd9c68f804acda665d2ab082217bb1583318f2" translate="yes" xml:space="preserve">
          <source>NaN</source>
          <target state="translated">NaN</target>
        </trans-unit>
        <trans-unit id="709a23220f2c3d64d1e1d6d18c4d5280f8d82fca" translate="yes" xml:space="preserve">
          <source>Name</source>
          <target state="translated">Name</target>
        </trans-unit>
        <trans-unit id="ed2a70884b6ea61a0ea998c7fe86ebc6c43c39e1" translate="yes" xml:space="preserve">
          <source>Name of the module being compiled</source>
          <target state="translated">コンパイルされるモジュールの名前</target>
        </trans-unit>
        <trans-unit id="bd9b36517a10ed825bfe97b96fd841ffbfd62dda" translate="yes" xml:space="preserve">
          <source>Name of the worker, as specified in &lt;a href=&quot;start&quot;&gt;Worker.start&lt;/a&gt; or &quot;worker $id&quot; by default,</source>
          <target state="translated">デフォルトで&lt;a href=&quot;start&quot;&gt;Worker.start&lt;/a&gt;または「worker $ id」で指定されているワーカーの名前、</target>
        </trans-unit>
        <trans-unit id="4efab9c724a7839dff5f1e0118b1a9b242fe8997" translate="yes" xml:space="preserve">
          <source>Name of this parameter as it was declared in the source code, or &lt;code&gt;null&lt;/code&gt; if the parameter has no name or its name is not available at runtime. Examples of nameless parameters include &lt;code&gt;this&lt;/code&gt; instance for member functions, extension receiver for extension functions or properties, parameters of Java methods compiled without the debug information, and others.</source>
          <target state="translated">ソースコードで宣言されたこのパラメーターの名前。パラメーターに名前がないか、実行時にその名前を使用できない場合は &lt;code&gt;null&lt;/code&gt; 。名前のないパラメーターの例には、メンバー関数の &lt;code&gt;this&lt;/code&gt; インスタンス、拡張関数またはプロパティの拡張レシーバー、デバッグ情報なしでコンパイルされたJavaメソッドのパラメーターなどがあります。</target>
        </trans-unit>
        <trans-unit id="9e0268761f1a46defda13527e24a738481491b83" translate="yes" xml:space="preserve">
          <source>Name translation</source>
          <target state="translated">名前の翻訳</target>
        </trans-unit>
        <trans-unit id="80a1546459fb296b75e903b673f8cc0ad0b7638a" translate="yes" xml:space="preserve">
          <source>Named Arguments</source>
          <target state="translated">名前付き引数</target>
        </trans-unit>
        <trans-unit id="f2ab34573e168918bf72dc73ec10c4b5b1ba3f14" translate="yes" xml:space="preserve">
          <source>Named arguments</source>
          <target state="translated">名前付き引数</target>
        </trans-unit>
        <trans-unit id="7eee412e511b81f184e8fdcdd0d16df4490ee091" translate="yes" xml:space="preserve">
          <source>NamedNodeMap</source>
          <target state="translated">NamedNodeMap</target>
        </trans-unit>
        <trans-unit id="89ed0927522265d199caf008b2d935b4dc13e4ec" translate="yes" xml:space="preserve">
          <source>Namely, &lt;code&gt;Grouping&lt;/code&gt; supports the following operations:</source>
          <target state="translated">つまり、 &lt;code&gt;Grouping&lt;/code&gt; は次の操作をサポートします。</target>
        </trans-unit>
        <trans-unit id="ce7873d11ca1350ea35c4e7edcc86d0f3faedfbb" translate="yes" xml:space="preserve">
          <source>Names for backing properties</source>
          <target state="translated">バッキングプロパティの名称</target>
        </trans-unit>
        <trans-unit id="d5e90b6eaa5ac7d68bfe0de19720901740a9662f" translate="yes" xml:space="preserve">
          <source>Names for test methods</source>
          <target state="translated">試験方法の名称</target>
        </trans-unit>
        <trans-unit id="1bbe1b5bbc9b48ae056a0ba828b7773769b4e6a7" translate="yes" xml:space="preserve">
          <source>Names in links are resolved using the same rules as if the name was used inside the element being documented. In particular, this means that if you have imported a name into the current file, you don't need to fully qualify it when you use it in a KDoc comment.</source>
          <target state="translated">リンク内の名前は、その名前が文書化されている要素の内部で使用されている場合と同じルールで解決されます。特に、現在のファイルに名前をインポートしている場合は、KDocのコメントで名前を使用する際に完全に修飾する必要がないことを意味します。</target>
        </trans-unit>
        <trans-unit id="c5380f68245bbc672ad92afb09b8fb6715ad3ca6" translate="yes" xml:space="preserve">
          <source>Names of classes and objects start with an upper case letter and use camel humps:</source>
          <target state="translated">クラスやオブジェクトの名前は大文字で始まり、ラクダのこぶを使用します。</target>
        </trans-unit>
        <trans-unit id="3b4a6dab1202620b73c1005110fe77d753a54e9f" translate="yes" xml:space="preserve">
          <source>Names of classes and objects start with an upper case letter and use the camel case:</source>
          <target state="translated">クラスやオブジェクトの名前は大文字から始まり、キャメルケースを使用します。</target>
        </trans-unit>
        <trans-unit id="fc15464a07c43531a73eacebb7c301c643be9755" translate="yes" xml:space="preserve">
          <source>Names of constants (properties marked with &lt;code&gt;const&lt;/code&gt;, or top-level or object &lt;code&gt;val&lt;/code&gt; properties with no custom &lt;code&gt;get&lt;/code&gt; function that hold deeply immutable data) should use uppercase underscore-separated names:</source>
          <target state="translated">定数の名前（ &lt;code&gt;const&lt;/code&gt; でマークされたプロパティ、または深く不変のデータを保持するカスタム &lt;code&gt;get&lt;/code&gt; 関数のないトップレベルまたはオブジェクト &lt;code&gt;val&lt;/code&gt; プロパティ）は、アンダースコアで区切られた大文字の名前を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="ed152e23d368497078b7ae5dc12a67a09aef9537" translate="yes" xml:space="preserve">
          <source>Names of functions, properties and local variables start with a lower case letter and use camel humps and no underscores:</source>
          <target state="translated">関数、プロパティ、ローカル変数の名前は小文字で始まり、キャメルハンプを使用し、アンダースコアは使用しません。</target>
        </trans-unit>
        <trans-unit id="1e715a573269457e03280d22e2a0d8e880e4fdae" translate="yes" xml:space="preserve">
          <source>Names of functions, properties and local variables start with a lower case letter and use the camel case and no underscores:</source>
          <target state="translated">関数名、プロパティ名、ローカル変数名は小文字で始まり、キャメルケースを使用し、アンダースコアは使用しません。</target>
        </trans-unit>
        <trans-unit id="2fe2ff19a7f565c3d30edceae570abf2351b799b" translate="yes" xml:space="preserve">
          <source>Names of packages are always lower case and do not use underscores (&lt;code&gt;org.example.myproject&lt;/code&gt;). Using multi-word names is generally discouraged, but if you do need to use multiple words, you can either simply concatenate them together or use camel humps (&lt;code&gt;org.example.myProject&lt;/code&gt;).</source>
          <target state="translated">パッケージの名前は常に小文字で、アンダースコア（ &lt;code&gt;org.example.myproject&lt;/code&gt; ）を使用しません。通常、複数の単語を使用することはお勧めしませんが、複数の単語を使用する必要がある場合は、それらを単に連結するか、ラクダのこぶ（ &lt;code&gt;org.example.myProject&lt;/code&gt; ）を使用できます。</target>
        </trans-unit>
        <trans-unit id="d506a4b97208834d8b60a4f447f3486fac1cf5be" translate="yes" xml:space="preserve">
          <source>Names of packages are always lower case and do not use underscores (&lt;code&gt;org.example.project&lt;/code&gt;). Using multi-word names is generally discouraged, but if you do need to use multiple words, you can either simply concatenate them together or use the camel case (&lt;code&gt;org.example.myProject&lt;/code&gt;).</source>
          <target state="translated">パッケージの名前は常に小文字であり、アンダースコアは使用しません（ &lt;code&gt;org.example.project&lt;/code&gt; ）。通常、複数単語の名前を使用することはお勧めしませんが、複数の単語を使用する必要がある場合は、単にそれらを連結するか、キャメルケース（ &lt;code&gt;org.example.myProject&lt;/code&gt; ）を使用できます。</target>
        </trans-unit>
        <trans-unit id="7f7adf5dd484e8eda6819e4b4ab1a277a17337ee" translate="yes" xml:space="preserve">
          <source>Names of properties holding references to singleton objects can use the same naming style as &lt;code&gt;object&lt;/code&gt; declarations:</source>
          <target state="translated">シングルトンオブジェクトへの参照を保持するプロパティの名前には、 &lt;code&gt;object&lt;/code&gt; 宣言と同じ命名スタイルを使用できます。</target>
        </trans-unit>
        <trans-unit id="ae79cc54e87e697302be7b45dcff0dc1ad4a5a71" translate="yes" xml:space="preserve">
          <source>Names of top-level or object properties which hold objects with behavior or mutable data should use camel-case names:</source>
          <target state="translated">ビヘイビアやミューータブルデータを持つオブジェクトを保持するトップレベルまたはオブジェクトプロパティの名前には、キャメルケースの名前を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="2dd1c430f56a1096d7535c6bff1f0b002bb217ee" translate="yes" xml:space="preserve">
          <source>Names of top-level or object properties which hold objects with behavior or mutable data should use regular camel-hump names:</source>
          <target state="translated">挙動を持つオブジェクトや変異可能なデータを持つオブジェクトを保持するトップレベルまたはオブジェクトプロパティの名前には、通常のキャメルハンプ名を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="a821637ed465037f50fb45146c7157533ce303ab" translate="yes" xml:space="preserve">
          <source>Naming coroutines for debugging</source>
          <target state="translated">デバッグ用のコアーチンの命名</target>
        </trans-unit>
        <trans-unit id="b8f89bc873847bc6acb441471008e2ef77f271a2" translate="yes" xml:space="preserve">
          <source>Naming rules</source>
          <target state="translated">ネーミングルール</target>
        </trans-unit>
        <trans-unit id="4fc6e7f740abb8af896ebedebf941a3f8d7076b5" translate="yes" xml:space="preserve">
          <source>Native</source>
          <target state="translated">Native</target>
        </trans-unit>
        <trans-unit id="712b0ca62af66efef9be01024a01163935118cd1" translate="yes" xml:space="preserve">
          <source>NativeFreeablePlacement</source>
          <target state="translated">NativeFreeablePlacement</target>
        </trans-unit>
        <trans-unit id="8c2ed68939229f0bed6cd8b6f2cb9306658a5c17" translate="yes" xml:space="preserve">
          <source>NativePlacement</source>
          <target state="translated">NativePlacement</target>
        </trans-unit>
        <trans-unit id="f6500269f9c3fb94b4438bc913d694314febde22" translate="yes" xml:space="preserve">
          <source>NativePointed</source>
          <target state="translated">NativePointed</target>
        </trans-unit>
        <trans-unit id="82e059ceb59aa7b7713c457045493d8d28dcc3f4" translate="yes" xml:space="preserve">
          <source>NativePtr</source>
          <target state="translated">NativePtr</target>
        </trans-unit>
        <trans-unit id="f504a9f397b7b30ca39f0ef1407b932940292f78" translate="yes" xml:space="preserve">
          <source>Natural order</source>
          <target state="translated">自然秩序</target>
        </trans-unit>
        <trans-unit id="c8e6f949b8ada118fdafbdc6ee8783d697f007cb" translate="yes" xml:space="preserve">
          <source>Navigator</source>
          <target state="translated">Navigator</target>
        </trans-unit>
        <trans-unit id="e7b5edc7e8cb311a0b039335c594c9a957eb3175" translate="yes" xml:space="preserve">
          <source>NavigatorConcurrentHardware</source>
          <target state="translated">NavigatorConcurrentHardware</target>
        </trans-unit>
        <trans-unit id="c539be135337dd03c6301959fad0ce1bee475889" translate="yes" xml:space="preserve">
          <source>NavigatorContentUtils</source>
          <target state="translated">NavigatorContentUtils</target>
        </trans-unit>
        <trans-unit id="00b43738cf147df0c752dcea119b953d47ded336" translate="yes" xml:space="preserve">
          <source>NavigatorCookies</source>
          <target state="translated">NavigatorCookies</target>
        </trans-unit>
        <trans-unit id="ca09397d83fa076ca8fa71c95007223165d66fb5" translate="yes" xml:space="preserve">
          <source>NavigatorID</source>
          <target state="translated">NavigatorID</target>
        </trans-unit>
        <trans-unit id="1c556456dba6623478e38282faadace5b5f02feb" translate="yes" xml:space="preserve">
          <source>NavigatorLanguage</source>
          <target state="translated">NavigatorLanguage</target>
        </trans-unit>
        <trans-unit id="b3ab2a10f83370ceafad9f996d8048d28d1a1363" translate="yes" xml:space="preserve">
          <source>NavigatorOnLine</source>
          <target state="translated">NavigatorOnLine</target>
        </trans-unit>
        <trans-unit id="e94d6507f620430ae9754053564c70782f33c7c9" translate="yes" xml:space="preserve">
          <source>NavigatorPlugins</source>
          <target state="translated">NavigatorPlugins</target>
        </trans-unit>
        <trans-unit id="e7f4b2c609e0e06e378710e78e2e3f9dbec6df11" translate="yes" xml:space="preserve">
          <source>Negative values show that it's less than the argument.</source>
          <target state="translated">マイナスの値は論よりも少ないことを示しています。</target>
        </trans-unit>
        <trans-unit id="789280e01339d5a915f0345cf138b9b4fb941c8e" translate="yes" xml:space="preserve">
          <source>Nested and Inner Classes</source>
          <target state="translated">入れ子クラスと内部クラス</target>
        </trans-unit>
        <trans-unit id="ee69ace2d0864bd815e214e20536f1f61364fc0f" translate="yes" xml:space="preserve">
          <source>Nested classifiers in enum entries</source>
          <target state="translated">列挙エントリ内のネストされた分類子</target>
        </trans-unit>
        <trans-unit id="40c58381d790a3e7eec655ca2a16667d8a074dd3" translate="yes" xml:space="preserve">
          <source>Nested declarations in annotation classes</source>
          <target state="translated">アノテーションクラスのネストされた宣言</target>
        </trans-unit>
        <trans-unit id="d053911ed6d5cc20ee675fd6a4520e78c20b1efb" translate="yes" xml:space="preserve">
          <source>Neutral bidirectional character type &quot;B&quot; in the Unicode specification.</source>
          <target state="translated">Unicode 仕様の中立双方向文字型「B」。</target>
        </trans-unit>
        <trans-unit id="8fd58ea9d9361ae87799e3e0adb497216a8850cd" translate="yes" xml:space="preserve">
          <source>Neutral bidirectional character type &quot;ON&quot; in the Unicode specification.</source>
          <target state="translated">Unicode仕様の中立双方向文字型「ON」。</target>
        </trans-unit>
        <trans-unit id="cc8492cfce3dced2f8758c8c41b89e84144de788" translate="yes" xml:space="preserve">
          <source>Neutral bidirectional character type &quot;S&quot; in the Unicode specification.</source>
          <target state="translated">Unicode 仕様の中立双方向文字型「S」。</target>
        </trans-unit>
        <trans-unit id="61ee633fcd6ff884b460c34fd4f698e42b8d1f57" translate="yes" xml:space="preserve">
          <source>Neutral bidirectional character type &quot;WS&quot; in the Unicode specification.</source>
          <target state="translated">Unicode仕様における中立双方向文字型「WS」。</target>
        </trans-unit>
        <trans-unit id="9ac5f98640f23386ec33233fa4af214ae29bb68c" translate="yes" xml:space="preserve">
          <source>Never equal to null: for any non-null value &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;x.equals(null)&lt;/code&gt; should return false.</source>
          <target state="translated">nullに等しくない：null以外の値 &lt;code&gt;x&lt;/code&gt; の場合、 &lt;code&gt;x.equals(null)&lt;/code&gt; はfalseを返す必要があります。</target>
        </trans-unit>
        <trans-unit id="c8ca579cfa2a0bc063bd07e3a4d9c7f65e8e3087" translate="yes" xml:space="preserve">
          <source>Never put a space after &lt;code&gt;(&lt;/code&gt;, &lt;code&gt;[&lt;/code&gt;, or before &lt;code&gt;]&lt;/code&gt;, &lt;code&gt;)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;(&lt;/code&gt; 、 &lt;code&gt;[&lt;/code&gt; 、または前 &lt;code&gt;]&lt;/code&gt; 、 &lt;code&gt;)&lt;/code&gt; の後にスペースを入れないでください。</target>
        </trans-unit>
        <trans-unit id="9294e60ab9df0dbecb3a72a47335eee294748f65" translate="yes" xml:space="preserve">
          <source>Never put a space around &lt;code&gt;.&lt;/code&gt; or &lt;code&gt;?.&lt;/code&gt;: &lt;code&gt;foo.bar().filter { it &amp;gt; 2 }.joinToString()&lt;/code&gt;, &lt;code&gt;foo?.bar()&lt;/code&gt;</source>
          <target state="translated">周りにスペースを置かないでください &lt;code&gt;.&lt;/code&gt; または &lt;code&gt;?.&lt;/code&gt; ： &lt;code&gt;foo.bar().filter { it &amp;gt; 2 }.joinToString()&lt;/code&gt; 、 &lt;code&gt;foo?.bar()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="989c5da0440d6ef3c75ca61d82d832246ce632de" translate="yes" xml:space="preserve">
          <source>New Kotlin/JS IR compiler</source>
          <target state="translated">新しいKotlin/JS IRコンパイラ</target>
        </trans-unit>
        <trans-unit id="845d99d67846936e2a2ecffc0c1f73a93b077848" translate="yes" xml:space="preserve">
          <source>New extensions for &lt;code&gt;Iterable&amp;lt;T&amp;gt;&lt;/code&gt;, &lt;code&gt;Sequence&amp;lt;T&amp;gt;&lt;/code&gt;, and &lt;code&gt;CharSequence&lt;/code&gt; cover such use cases as buffering or batch processing (&lt;code&gt;chunked&lt;/code&gt;), sliding window and computing sliding average (&lt;code&gt;windowed&lt;/code&gt;) , and processing pairs of subsequent items (&lt;code&gt;zipWithNext&lt;/code&gt;):</source>
          <target state="translated">&lt;code&gt;Iterable&amp;lt;T&amp;gt;&lt;/code&gt; 、 &lt;code&gt;Sequence&amp;lt;T&amp;gt;&lt;/code&gt; 、および &lt;code&gt;CharSequence&lt;/code&gt; の新しい拡張機能は、バッファリングまたはバッチ処理（ &lt;code&gt;chunked&lt;/code&gt; ）、スライディングウィンドウとスライディング平均の計算（ &lt;code&gt;windowed&lt;/code&gt; ）、および後続のアイテムのペアの処理（ &lt;code&gt;zipWithNext&lt;/code&gt; ）などのユースケースをカバーします。</target>
        </trans-unit>
        <trans-unit id="e22e233ab95d5952f18b874d9870e1b80280d15d" translate="yes" xml:space="preserve">
          <source>New functions were added for converting &lt;code&gt;Double&lt;/code&gt; and &lt;code&gt;Float&lt;/code&gt; to and from their bit representations:</source>
          <target state="translated">&lt;code&gt;Double&lt;/code&gt; と &lt;code&gt;Float&lt;/code&gt; をビット表現間で変換するための新しい関数が追加されました。</target>
        </trans-unit>
        <trans-unit id="1c41e8d2c414e76e3966946fcc4d1e55e43e96ed" translate="yes" xml:space="preserve">
          <source>New to Kotlin? Take a look at the &lt;a href=&quot;../tutorials/getting-started&quot;&gt;Getting Started&lt;/a&gt; page.</source>
          <target state="translated">Kotlinは初めてですか？見てみましょう&lt;a href=&quot;../tutorials/getting-started&quot;&gt;スタート&lt;/a&gt;ページを。</target>
        </trans-unit>
        <trans-unit id="28dcc6d65c266a50c3f667c9e5ea8aa135aa58a6" translate="yes" xml:space="preserve">
          <source>New to Kotlin? Take a look at the &lt;a href=&quot;basic-syntax&quot;&gt;Getting Started&lt;/a&gt; page.</source>
          <target state="translated">Kotlinは初めてですか？見てみましょう&lt;a href=&quot;basic-syntax&quot;&gt;スタート&lt;/a&gt;ページを。</target>
        </trans-unit>
        <trans-unit id="e9559254cbe41a97686cb7a5c40de455ecdf8ee6" translate="yes" xml:space="preserve">
          <source>New to Kotlin? Visit &lt;a href=&quot;../tutorials/getting-started&quot;&gt;Getting started with Kotlin&lt;/a&gt;.</source>
          <target state="translated">Kotlinは初めてですか？&lt;a href=&quot;../tutorials/getting-started&quot;&gt;Kotlin入門にアクセスして&lt;/a&gt;ください。</target>
        </trans-unit>
        <trans-unit id="3f170caead65df254d786032a409a6f6d204bca6" translate="yes" xml:space="preserve">
          <source>Next Steps</source>
          <target state="translated">次のステップ</target>
        </trans-unit>
        <trans-unit id="5079a9846101e11db84a1abb592a9473e268055f" translate="yes" xml:space="preserve">
          <source>Next open a new terminal and install Kotlin with:</source>
          <target state="translated">次に新しいターミナルを開き、Kotlinをインストールします。</target>
        </trans-unit>
        <trans-unit id="2f460c75911314c0c9543c3367959a31445cb463" translate="yes" xml:space="preserve">
          <source>Next, let's include the following line of code into the &lt;code&gt;MainActivity&lt;/code&gt; class from the &lt;code&gt;/app/src/main/java/&amp;lt;package&amp;gt;/MainActivity.kt&lt;/code&gt; file, to the end of the &lt;code&gt;onCreate&lt;/code&gt; method:</source>
          <target state="translated">次に、 &lt;code&gt;/app/src/main/java/&amp;lt;package&amp;gt;/MainActivity.kt&lt;/code&gt; ファイルから &lt;code&gt;onCreate&lt;/code&gt; メソッドの最後まで、 &lt;code&gt;MainActivity&lt;/code&gt; クラスに次のコード行を含めます。</target>
        </trans-unit>
        <trans-unit id="61e1f7fc790c5246a6e519f4f67f422c4a517358" translate="yes" xml:space="preserve">
          <source>Next, we need to create the &lt;code&gt;SharedCode/build.gradle&lt;/code&gt; file with the following content:</source>
          <target state="translated">次に、次の内容で &lt;code&gt;SharedCode/build.gradle&lt;/code&gt; ファイルを作成する必要があります。</target>
        </trans-unit>
        <trans-unit id="fba44f74cfbe24d927a6f2e32c74f105a6d9ca00" translate="yes" xml:space="preserve">
          <source>Next: Annotations &amp;rarr;</source>
          <target state="translated">次：注釈&amp;rarr;</target>
        </trans-unit>
        <trans-unit id="00ef744e43f0f9ea134186c2ef008876b94cfb5d" translate="yes" xml:space="preserve">
          <source>Next: Classes &amp;rarr;</source>
          <target state="translated">次：クラス&amp;rarr;</target>
        </trans-unit>
        <trans-unit id="c8735b85302131b9db681cecd1fb40aa277a0558" translate="yes" xml:space="preserve">
          <source>Next: Collections &amp;rarr;</source>
          <target state="translated">次：コレクション&amp;rarr;</target>
        </trans-unit>
        <trans-unit id="07999039cc4614cf9d9c83d8a64e7926f8829364" translate="yes" xml:space="preserve">
          <source>Next: Compiling and running &amp;rarr;</source>
          <target state="translated">次：コンパイルと実行&amp;rarr;</target>
        </trans-unit>
        <trans-unit id="f20d28acc929c74946791930cf9c56d2978b64a8" translate="yes" xml:space="preserve">
          <source>Next: Conditionals &amp;rarr;</source>
          <target state="translated">次：条件文&amp;rarr;</target>
        </trans-unit>
        <trans-unit id="840074b0ba8fd90b4e90aa33d45718551b373169" translate="yes" xml:space="preserve">
          <source>Next: Declaring variables &amp;rarr;</source>
          <target state="translated">次：変数の宣言&amp;rarr;</target>
        </trans-unit>
        <trans-unit id="cce5126b0175141ca7a8267a7936ebe65fe68d5f" translate="yes" xml:space="preserve">
          <source>Next: Documentation &amp;rarr;</source>
          <target state="translated">次：ドキュメント&amp;rarr;</target>
        </trans-unit>
        <trans-unit id="fa55701df6604b3cecc0d604af09a04554d557b6" translate="yes" xml:space="preserve">
          <source>Next: Exceptions &amp;rarr;</source>
          <target state="translated">次：例外&amp;rarr;</target>
        </trans-unit>
        <trans-unit id="6b6aa34eef4e603a14fc427c78ce11728dd25836" translate="yes" xml:space="preserve">
          <source>Next: Extension functions/properties &amp;rarr;</source>
          <target state="translated">次：拡張関数/プロパティ&amp;rarr;</target>
        </trans-unit>
        <trans-unit id="085547cea36d9036af28992fd35c78130fafdd20" translate="yes" xml:space="preserve">
          <source>Next: File I/O &amp;rarr;</source>
          <target state="translated">次へ：ファイルI / O&amp;rarr;</target>
        </trans-unit>
        <trans-unit id="1ad7d1fc04a3f8f5bb3171b2738d368b2e7962ea" translate="yes" xml:space="preserve">
          <source>Next: Functional programming &amp;rarr;</source>
          <target state="translated">次：関数型プログラミング&amp;rarr;</target>
        </trans-unit>
        <trans-unit id="4ca230bdec76005c5c8ecf036e517045996d632a" translate="yes" xml:space="preserve">
          <source>Next: Functions &amp;rarr;</source>
          <target state="translated">次：関数&amp;rarr;</target>
        </trans-unit>
        <trans-unit id="ee174e846c5088dfbb38266ba627304b28a4e778" translate="yes" xml:space="preserve">
          <source>Next: Generics &amp;rarr;</source>
          <target state="translated">次：ジェネリックス&amp;rarr;</target>
        </trans-unit>
        <trans-unit id="1fc3a42a52feb37755a354083cafdc34a3336119" translate="yes" xml:space="preserve">
          <source>Next: Hello World &amp;rarr;</source>
          <target state="translated">次：ハローワールド&amp;rarr;</target>
        </trans-unit>
        <trans-unit id="3e18f658842ac7800584f5830d0086c6615ba81e" translate="yes" xml:space="preserve">
          <source>Next: Inheritance &amp;rarr;</source>
          <target state="translated">次：継承&amp;rarr;</target>
        </trans-unit>
        <trans-unit id="e300f7cf6a03c09bab1b47c326855a60fe6e07fb" translate="yes" xml:space="preserve">
          <source>Next: Loops &amp;rarr;</source>
          <target state="translated">次：ループ&amp;rarr;</target>
        </trans-unit>
        <trans-unit id="42aae1e29d68a1d88913d08cee33e89180a579d7" translate="yes" xml:space="preserve">
          <source>Next: Member references and reflection &amp;rarr;</source>
          <target state="translated">次：メンバーの参照とリフレクション&amp;rarr;</target>
        </trans-unit>
        <trans-unit id="47130dd2717d7971c3c94623669be8f3f6e6f3ff" translate="yes" xml:space="preserve">
          <source>Next: Null safety &amp;rarr;</source>
          <target state="translated">次：ヌルセーフティ&amp;rarr;</target>
        </trans-unit>
        <trans-unit id="86e91a1d2169b2b6d5f0e4158807082816cf024d" translate="yes" xml:space="preserve">
          <source>Next: Objects and companion objects &amp;rarr;</source>
          <target state="translated">次：オブジェクトとコンパニオンオブジェクト&amp;rarr;</target>
        </trans-unit>
        <trans-unit id="6bfa5e253a9933523c52548db5718fffcec08ff4" translate="yes" xml:space="preserve">
          <source>Next: Packages and imports &amp;rarr;</source>
          <target state="translated">次：パッケージとインポート&amp;rarr;</target>
        </trans-unit>
        <trans-unit id="61b315e1a975491d53d3e93505ae2e73a35eccf9" translate="yes" xml:space="preserve">
          <source>Next: Primitive data types and their limitations &amp;rarr;</source>
          <target state="translated">次へ：プリミティブデータ型とその制限&amp;rarr;</target>
        </trans-unit>
        <trans-unit id="a8e3f58e4df0923f458764df8d805bc1daaebc52" translate="yes" xml:space="preserve">
          <source>Next: Scoped resource usage &amp;rarr;</source>
          <target state="translated">次：スコープ指定リソースの使用&amp;rarr;</target>
        </trans-unit>
        <trans-unit id="d22ef24051b74c0f8f3a98dbd34b162df22e8d8a" translate="yes" xml:space="preserve">
          <source>Next: Strings &amp;rarr;</source>
          <target state="translated">次：文字列&amp;rarr;</target>
        </trans-unit>
        <trans-unit id="df94caa7ffe6e8dba6f94ac077da12da6df4dd88" translate="yes" xml:space="preserve">
          <source>Next: Visibility modifiers &amp;rarr;</source>
          <target state="translated">次：可視性修飾子&amp;rarr;</target>
        </trans-unit>
        <trans-unit id="dd6dd817ee9557c6ebd9ce223abe7e65e35724c3" translate="yes" xml:space="preserve">
          <source>Nice utility functions</source>
          <target state="translated">優れたユーティリティー機能</target>
        </trans-unit>
        <trans-unit id="816c52fd2bdd94a63cd0944823a6c0aa9384c103" translate="yes" xml:space="preserve">
          <source>No</source>
          <target state="translated">No</target>
        </trans-unit>
        <trans-unit id="fc6d6d07a9da4b1cf8d3f863c9932b05d0b9d378" translate="yes" xml:space="preserve">
          <source>No &lt;code&gt;EXPRESSION&lt;/code&gt; and &lt;code&gt;FILE&lt;/code&gt; among &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.annotation/-annotation-target/index&quot;&gt;targets&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.annotation/-annotation-target/index&quot;&gt;ターゲット&lt;/a&gt;間で &lt;code&gt;EXPRESSION&lt;/code&gt; および &lt;code&gt;FILE&lt;/code&gt; はありません</target>
        </trans-unit>
        <trans-unit id="d50a5c00dba30dbb17216b740546f411fd49910a" translate="yes" xml:space="preserve">
          <source>No custom getter</source>
          <target state="translated">カスタムゲッターなし</target>
        </trans-unit>
        <trans-unit id="c2792086f80dff691fc70c60e9944bd70ee578bb" translate="yes" xml:space="preserve">
          <source>No locks are used to synchronize an access to the &lt;a href=&quot;../-lazy/index&quot;&gt;Lazy&lt;/a&gt; instance value; if the instance is accessed from multiple threads, its behavior is undefined.</source>
          <target state="translated">&lt;a href=&quot;../-lazy/index&quot;&gt;Lazy&lt;/a&gt;インスタンス値へのアクセスを同期するためにロックは使用されません。インスタンスが複数のスレッドからアクセスされる場合、その動作は未定義です。</target>
        </trans-unit>
        <trans-unit id="1576fb8454236b0d4fa99182ffbcc64b6805f9d7" translate="yes" xml:space="preserve">
          <source>No need to mark the Application class as &lt;em&gt;open&lt;/em&gt; since we are using the &lt;em&gt;kotlin-spring&lt;/em&gt; Gradle plugin which does that automatically.</source>
          <target state="translated">自動的にそれを行う&lt;em&gt;kotlin-spring&lt;/em&gt; Gradleプラグインを使用して&lt;em&gt;いる&lt;/em&gt;ため、Applicationクラスを&lt;em&gt;オープン&lt;/em&gt;としてマークする必要はありません。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1ea178000db803133ca4ed5bf0f26cf40a2ac141" translate="yes" xml:space="preserve">
          <source>No parameters.</source>
          <target state="translated">パラメータはありません。</target>
        </trans-unit>
        <trans-unit id="a39dbb3db1c73d98fb6e9bf0a6cc7fe2780640aa" translate="yes" xml:space="preserve">
          <source>No raw types</source>
          <target state="translated">生タイプなし</target>
        </trans-unit>
        <trans-unit id="4512f94421443be3bb6fe68bb037823683ccfd0a" translate="yes" xml:space="preserve">
          <source>No-arg compiler plugin</source>
          <target state="translated">引数なしのコンパイラプラグイン</target>
        </trans-unit>
        <trans-unit id="ec11a5bdeaa38cafa1809cd0b1418fa7f8f3cfef" translate="yes" xml:space="preserve">
          <source>No. Kotlin lets you choose between generating Java 6 and Java 8 compatible bytecode. More optimal byte code may be generated for higher versions of the platform.</source>
          <target state="translated">いいえ。Kotlinでは、Java 6とJava 8の互換性のあるバイトコードを生成するかどうかを選択できます。プラットフォームの上位バージョンでは、より最適なバイトコードが生成される場合があります。</target>
        </trans-unit>
        <trans-unit id="ce3234172e6888dbe6cf68e5d69aca93bdbdb6aa" translate="yes" xml:space="preserve">
          <source>No: called without the context object</source>
          <target state="translated">いいえ:コンテキストオブジェクトなしで呼び出されます。</target>
        </trans-unit>
        <trans-unit id="44924246111ca028f4b377861fa8b1a56b2f8f3f" translate="yes" xml:space="preserve">
          <source>No: takes the context object as an argument.</source>
          <target state="translated">いいえ:コンテキストオブジェクトを引数に取ります。</target>
        </trans-unit>
        <trans-unit id="23a71e363ee25bc12526201fd5e1559555edeab5" translate="yes" xml:space="preserve">
          <source>NoSuchElementException</source>
          <target state="translated">NoSuchElementException</target>
        </trans-unit>
        <trans-unit id="9a296716d89fec45e837ec162f0a3cdfae0666f6" translate="yes" xml:space="preserve">
          <source>NoSuchFileException</source>
          <target state="translated">NoSuchFileException</target>
        </trans-unit>
        <trans-unit id="8e965431f22047ddfc939473709e81428fafe4f0" translate="yes" xml:space="preserve">
          <source>NoSuchPropertyException</source>
          <target state="translated">NoSuchPropertyException</target>
        </trans-unit>
        <trans-unit id="dd82911bf9c2f7cf6fe3c3a3a0486e6fd4980949" translate="yes" xml:space="preserve">
          <source>NoWhenBranchMatchedException</source>
          <target state="translated">NoWhenBranchMatchedException</target>
        </trans-unit>
        <trans-unit id="6d1452836a5e358d27de613d82985d8f206e4345" translate="yes" xml:space="preserve">
          <source>NodeFilter</source>
          <target state="translated">NodeFilter</target>
        </trans-unit>
        <trans-unit id="749f705e68c34826a7cc3dffa5cbbe3e73f820de" translate="yes" xml:space="preserve">
          <source>NodeIterator</source>
          <target state="translated">NodeIterator</target>
        </trans-unit>
        <trans-unit id="05a2a8746fe10231011b4d6850be527a41c1c732" translate="yes" xml:space="preserve">
          <source>NodeList</source>
          <target state="translated">NodeList</target>
        </trans-unit>
        <trans-unit id="683af661ab161f85e9822c648db026a9cf30dda6" translate="yes" xml:space="preserve">
          <source>Non-constant vararg annotation parameters</source>
          <target state="translated">非定数の vararg 注釈パラメータ</target>
        </trans-unit>
        <trans-unit id="dc9767217a1c7b0bf421fbdc439c549407505217" translate="yes" xml:space="preserve">
          <source>Non-existent type correction</source>
          <target state="translated">存在しないタイプの修正</target>
        </trans-unit>
        <trans-unit id="fe155a80a88ca53a5855fdd7ccb55154dece22f7" translate="yes" xml:space="preserve">
          <source>Non-external classes can't be extended by external classes.</source>
          <target state="translated">非外部クラスは外部クラスでは拡張できません。</target>
        </trans-unit>
        <trans-unit id="4faaccd91d30b37f731dad2f02cd8a91e9099b87" translate="yes" xml:space="preserve">
          <source>Non-local returns</source>
          <target state="translated">非ローカルリターン</target>
        </trans-unit>
        <trans-unit id="92dc2c3bbe1e4d97caf60f89e03fd837acb72669" translate="yes" xml:space="preserve">
          <source>Non-private fields</source>
          <target state="translated">プライベート以外の分野</target>
        </trans-unit>
        <trans-unit id="f8f526d37ae54edc0292fa3b9fb52e0ef28cf4f3" translate="yes" xml:space="preserve">
          <source>Non-propagating use</source>
          <target state="translated">非増殖的な使用</target>
        </trans-unit>
        <trans-unit id="806c74a6dd444e7b581fe8d0651c3b583f7e4a35" translate="yes" xml:space="preserve">
          <source>NonDocumentTypeChildNode</source>
          <target state="translated">NonDocumentTypeChildNode</target>
        </trans-unit>
        <trans-unit id="928c9a9956e3637b60b5e9617db297b95e7290fd" translate="yes" xml:space="preserve">
          <source>NonElementParentNode</source>
          <target state="translated">NonElementParentNode</target>
        </trans-unit>
        <trans-unit id="d75dfc52cb45227dc75a26a76fe24ef6aeb82f70" translate="yes" xml:space="preserve">
          <source>Normal functions (not marked as inline) cannot have reified parameters. A type that does not have a run-time representation (e.g. a non-reified type parameter or a fictitious type like &lt;code&gt;Nothing&lt;/code&gt;) cannot be used as an argument for a reified type parameter.</source>
          <target state="translated">通常の関数（インラインとしてマークされていない）は、具体化されたパラメーターを持つことができません。ランタイム表現を持たない型（たとえば、非具体化型パラメーターまたは &lt;code&gt;Nothing&lt;/code&gt; などの架空の型）は、具体化型パラメーターの引数として使用できません。</target>
        </trans-unit>
        <trans-unit id="49a45a50e6244c47619f28727155a0cbe41bd131" translate="yes" xml:space="preserve">
          <source>Normal methods can be overridden using the &lt;code&gt;override&lt;/code&gt; Kotlin keyword. In this case the overriding method must have the same parameter names as the overridden one.</source>
          <target state="translated">通常のメソッドは、 &lt;code&gt;override&lt;/code&gt; Kotlinキーワードを使用してオーバーライドできます。この場合、オーバーライドするメソッドには、オーバーライドされるメソッドと同じパラメーター名が必要です。</target>
        </trans-unit>
        <trans-unit id="a916e7bdcd294dc74af71b748cdce7d82df98e31" translate="yes" xml:space="preserve">
          <source>Normally, if you write a Kotlin function with default parameter values, it will be visible in Java only as a full signature, with all parameters present. If you wish to expose multiple overloads to Java callers, you can use the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.jvm/-jvm-overloads/index&quot;&gt;&lt;code&gt;@JvmOverloads&lt;/code&gt;&lt;/a&gt; annotation.</source>
          <target state="translated">通常、デフォルトのパラメーター値を使用してKotlin関数を作成すると、Javaでは完全なシグニチャーとしてのみ表示され、すべてのパラメーターが存在します。複数のオーバーロードをJava呼び出し元に公開する場合は、&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.jvm/-jvm-overloads/index&quot;&gt; &lt;code&gt;@JvmOverloads&lt;/code&gt; &lt;/a&gt;アノテーションを使用できます。</target>
        </trans-unit>
        <trans-unit id="6a89db40e0b8cfbd047b44012190c470a3ee8af7" translate="yes" xml:space="preserve">
          <source>Normally, properties declared as having a non-null type must be initialized in the constructor. However, fairly often this is not convenient. For example, properties can be initialized through dependency injection, or in the setup method of a unit test. In this case, you cannot supply a non-null initializer in the constructor, but you still want to avoid null checks when referencing the property inside the body of a class.</source>
          <target state="translated">通常、非 null 型を持つと宣言されたプロパティはコンストラクタで初期化しなければなりません。しかし、これは便利ではないことがよくあります。例えば、依存関係の注入や、ユニットテストのセットアップメソッドでプロパティを初期化することができます。この場合、コンストラクタで非 null 型のイニシャライザを指定することはできませんが、クラスのボディ内でプロパティを参照する際に null チェックを回避したい場合もあります。</target>
        </trans-unit>
        <trans-unit id="a967d31a488ea79d5210d74fd176b0b854f6d231" translate="yes" xml:space="preserve">
          <source>Not only classes can have type parameters. Functions can, too. Type parameters are placed &lt;strong&gt;before&lt;/strong&gt; the name of the function:</source>
          <target state="translated">クラスだけが型パラメーターを持つことができるわけではありません。関数もできます。型パラメーターは、関数の名前の&lt;strong&gt;前&lt;/strong&gt;に配置されます。</target>
        </trans-unit>
        <trans-unit id="2efce3f5aa2c271d194d1082031602e01c017249" translate="yes" xml:space="preserve">
          <source>Not use any members that take a star-projected type as a parameter</source>
          <target state="translated">星形投影型をパラメータとするメンバを使用しない。</target>
        </trans-unit>
        <trans-unit id="68b62df2b207d9543eb97cef507795cf7a5eb731" translate="yes" xml:space="preserve">
          <source>Not-null assertion operator</source>
          <target state="translated">ノットヌルアサーション演算子</target>
        </trans-unit>
        <trans-unit id="8850b3bd61499741c05bd500ea7929ed489941ca" translate="yes" xml:space="preserve">
          <source>NotImplementedError</source>
          <target state="translated">NotImplementedError</target>
        </trans-unit>
        <trans-unit id="0525b1fa9e28d14aa40cc8644228138fdab333ad" translate="yes" xml:space="preserve">
          <source>Notation for Platform Types</source>
          <target state="translated">プラットフォームタイプの表記法</target>
        </trans-unit>
        <trans-unit id="346c210a245c6f4ac5e207e281e87f32eaf27522" translate="yes" xml:space="preserve">
          <source>Note how &lt;a href=&quot;../reference/properties#late-initialized-properties-and-variables&quot;&gt;the lateinit modifier&lt;/a&gt; allows to declare a non-null type initialized after the object is created (after the constructor call). Without &lt;code&gt;lateinit&lt;/code&gt; you'd have to declare a &lt;a href=&quot;../reference/null-safety&quot;&gt;nullable type&lt;/a&gt; and add additional nullability checks.</source>
          <target state="translated">オブジェクトの作成後（コンストラクターの呼び出し後）&lt;a href=&quot;../reference/properties#late-initialized-properties-and-variables&quot;&gt;、lateinit修飾子を&lt;/a&gt;使用して初期化されたnull以外の型を宣言できることに注意してください。なけれ &lt;code&gt;lateinit&lt;/code&gt; あなたは宣言する必要があると思い&lt;a href=&quot;../reference/null-safety&quot;&gt;NULL可能タイプを&lt;/a&gt;、追加のNULL値を許容するかどうかのチェックを追加します。</target>
        </trans-unit>
        <trans-unit id="8d92da0b04ba642342db49ac8931c42f19e47f68" translate="yes" xml:space="preserve">
          <source>Note how both the first &lt;code&gt;async&lt;/code&gt; and the awaiting parent are cancelled on failure of one of the children (namely, &lt;code&gt;two&lt;/code&gt;):</source>
          <target state="translated">子の1つ（つまり、 &lt;code&gt;two&lt;/code&gt; ）に障害が発生すると、最初の &lt;code&gt;async&lt;/code&gt; と待機中の親の両方がキャンセルされることに注意してください。</target>
        </trans-unit>
        <trans-unit id="ece9aff9cfec4f422a4dd193e67bb220717aeb47" translate="yes" xml:space="preserve">
          <source>Note how easily one may forget the corresponding context element and then still safely access thread local. To avoid such situations, it is recommended to use &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/java.lang.-thread-local/ensure-present.html&quot;&gt;ensurePresent&lt;/a&gt; method and fail-fast on improper usages.</source>
          <target state="translated">対応するコンテキスト要素を忘れても、ローカルのスレッドに安全にアクセスできることに注意してください。このような状況を回避するには、&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/java.lang.-thread-local/ensure-present.html&quot;&gt;ensurePresent&lt;/a&gt;メソッドを使用し、不適切な使用法ではフェイルファストすることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="27e144234fbe29431367eab42a112f44ba9e6e90" translate="yes" xml:space="preserve">
          <source>Note on visibility</source>
          <target state="translated">視認性に関する注意事項</target>
        </trans-unit>
        <trans-unit id="f7e11b4556b13f0f82fdc5bafcd108c64e182fe4" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;android-plugin&quot;&gt;Kotlin Android Extensions&lt;/a&gt; plugin (automatically bundled into the Kotlin plugin in Android Studio) solves the same issue: replacing &lt;code&gt;findViewById&lt;/code&gt; with a concise and straightforward code. Consider using it unless you're already using ButterKnife and don't want to migrate.</source>
          <target state="translated">注こと&lt;a href=&quot;android-plugin&quot;&gt;Kotlin Androidの拡張機能&lt;/a&gt;（自動アンドロイドStudioでKotlinプラグインにバンドル）プラグインが同じ問題を解決：交換 &lt;code&gt;findViewById&lt;/code&gt; を簡潔で分かりやすいコードで。すでにButterKnifeを使用していて、移行したくない場合以外は、使用を検討してください。</target>
        </trans-unit>
        <trans-unit id="b10bef8aca468769cab7ca0f31c1ca35bfeef062" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/on-receive-or-null.html&quot;&gt;onReceiveOrNull&lt;/a&gt; is an extension function defined only for channels with non-nullable elements so that there is no accidental confusion between a closed channel and a null value.</source>
          <target state="translated">&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/on-receive-or-null.html&quot;&gt;onReceiveOrNull&lt;/a&gt;はnull関数を使用できない要素を持つチャネルに対してのみ定義される拡張関数であるため、閉じたチャネルとnull値が誤って混同しないように注意してください。</target>
        </trans-unit>
        <trans-unit id="23cd4a64981ce83f9769929d7af16453dd2385a0" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/ticker.html&quot;&gt;ticker&lt;/a&gt; is aware of possible consumer pauses and, by default, adjusts next produced element delay if a pause occurs, trying to maintain a fixed rate of produced elements.</source>
          <target state="translated">そのノート&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/ticker.html&quot;&gt;ティッカーが&lt;/a&gt;可能消費者が一時停止を認識しており、一時停止が発生した場合、デフォルトで、生成要素の固定速度を維持しようとすると、次生成素子遅延を調整します。</target>
        </trans-unit>
        <trans-unit id="e4f574aa6b81a2a53d14300616da27a08406bc5d" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/is-active.html&quot;&gt;isActive&lt;/a&gt; in &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html&quot;&gt;CoroutineScope&lt;/a&gt; is just a convenient shortcut for &lt;code&gt;coroutineContext[Job]?.isActive == true&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html&quot;&gt;CoroutineScopeの&lt;/a&gt;&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/is-active.html&quot;&gt;isActive&lt;/a&gt;は、coroutineContext &lt;code&gt;coroutineContext[Job]?.isActive == true&lt;/code&gt; 便利なショートカットにすぎないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="643f0957c5be70b41f4b5877b3662ee68c79f859" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;-&lt;/code&gt; is an &lt;em&gt;invalid&lt;/em&gt; symbol in Java, meaning that it's impossible to call functions which accept inline classes from Java.</source>
          <target state="translated">こと注 &lt;code&gt;-&lt;/code&gt; で&lt;em&gt;無効&lt;/em&gt;それはJavaからインラインクラスを受け入れる関数を呼び出すことは不可能だということを意味し、Javaでのシンボル。</target>
        </trans-unit>
        <trans-unit id="326418c4e5742c7d5633cf6eb21a36a9bd5007fa" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;associate()&lt;/code&gt; produces short-living &lt;code&gt;Pair&lt;/code&gt; objects which may affect the performance. Thus, &lt;code&gt;associate()&lt;/code&gt; should be used when the performance isn't critical or it's more preferable than other options.</source>
          <target state="translated">assign &lt;code&gt;associate()&lt;/code&gt; は、パフォーマンスに影響する可能性のある短命の &lt;code&gt;Pair&lt;/code&gt; オブジェクトを生成することに注意してください。したがって、パフォーマンスが重要でない場合、または他のオプションよりも好ましい場合は、 &lt;code&gt;associate()&lt;/code&gt; を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="4712744d1c59fe11b666d701399f2acdde076310" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;external&lt;/code&gt; modifier is inherited by nested declarations, i.e. in &lt;code&gt;Node&lt;/code&gt; class we do not put &lt;code&gt;external&lt;/code&gt; before member functions and properties.</source>
          <target state="translated">&lt;code&gt;external&lt;/code&gt; 修飾子はネストされた宣言によって継承されることに注意してください。つまり、 &lt;code&gt;Node&lt;/code&gt; クラスでは、メンバー関数とプロパティの前に &lt;code&gt;external&lt;/code&gt; を配置しません。</target>
        </trans-unit>
        <trans-unit id="7c2abf53e89201db42a6d7da34bd24e5d79ffb90" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;jQuery&lt;/code&gt; needs to be included in the corresponding HTML:</source>
          <target state="translated">&lt;code&gt;jQuery&lt;/code&gt; を対応するHTMLに含める必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="a130b307700ca7edccdf73fda8c49be967259f51" translate="yes" xml:space="preserve">
          <source>Note that &lt;em&gt;null&lt;/em&gt; cannot be cast to &lt;code&gt;String&lt;/code&gt; as this type is not &lt;a href=&quot;null-safety&quot;&gt;nullable&lt;/a&gt;, i.e. if &lt;code&gt;y&lt;/code&gt; is null, the code above throws an exception. In order to match Java cast semantics we have to have nullable type at cast right hand side, like:</source>
          <target state="translated">そのノート&lt;em&gt;ヌル&lt;/em&gt;にキャストすることができない &lt;code&gt;String&lt;/code&gt; このタイプではないように&lt;a href=&quot;null-safety&quot;&gt;NULL可能で&lt;/a&gt;あれば、すなわち &lt;code&gt;y&lt;/code&gt; がヌルである、上記のコードは例外をスロー。Javaキャストセマンティクスに一致させるには、次のようにキャストの右側にnull許容型が必要です。</target>
        </trans-unit>
        <trans-unit id="50af001ffdcccd71b90632cabd329ef39ee390e5" translate="yes" xml:space="preserve">
          <source>Note that &lt;em&gt;null&lt;/em&gt; cannot be cast to &lt;code&gt;String&lt;/code&gt; as this type is not &lt;a href=&quot;null-safety&quot;&gt;nullable&lt;/a&gt;, i.e. if &lt;code&gt;y&lt;/code&gt; is null, the code above throws an exception. To make such code correct for null values, use the nullable type on the right hand side of the cast:</source>
          <target state="translated">そのノート&lt;em&gt;ヌル&lt;/em&gt;にキャストすることができない &lt;code&gt;String&lt;/code&gt; このタイプではないように&lt;a href=&quot;null-safety&quot;&gt;NULL可能で&lt;/a&gt;あれば、すなわち &lt;code&gt;y&lt;/code&gt; がヌルである、上記のコードは例外をスロー。このようなコードをnull値に対して正しくするには、キャストの右側にあるnull許容型を使用します。</target>
        </trans-unit>
        <trans-unit id="3b25bca041a3db971a025c2e5df5df075febfd74" translate="yes" xml:space="preserve">
          <source>Note that KDoc does not have any syntax for resolving overloaded members in links. Since the Kotlin documentation generation tool puts the documentation for all overloads of a function on the same page, identifying a specific overloaded function is not required for the link to work.</source>
          <target state="translated">KDocには、リンク内のオーバーロードされたメンバを解決するための構文がないことに注意してください。Kotlinのドキュメント生成ツールは、ある関数のすべてのオーバーロードのドキュメントを同じページに配置するので、特定のオーバーロードされた関数を特定する必要はなく、リンクが機能するようになります。</target>
        </trans-unit>
        <trans-unit id="378fb47127c89ebfae61cf028d6a1d9ec0aaa851" translate="yes" xml:space="preserve">
          <source>Note that Kapt does not support multiple rounds for the generated Kotlin files.</source>
          <target state="translated">Kaptは生成されたKotlinファイルの複数ラウンドをサポートしていないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="f3383898decca7a9f7b6deb5d495a2e5e68df372" translate="yes" xml:space="preserve">
          <source>Note that Kotlin compiler does not apply such mangling to &lt;code&gt;external&lt;/code&gt; declarations, so you don't have to use &lt;code&gt;@JsName&lt;/code&gt; on them. Another case worth noticing is inheriting non-external classes from external classes. In this case any overridden functions won't be mangled as well.</source>
          <target state="translated">Kotlinコンパイラーはこのようなマングリングを &lt;code&gt;external&lt;/code&gt; 宣言に適用しないため、それら &lt;code&gt;@JsName&lt;/code&gt; を使用する必要がないことに注意してください。注目に値するもう1つのケースは、外部クラスから非外部クラスを継承することです。この場合、オーバーライドされた関数もマングルされません。</target>
        </trans-unit>
        <trans-unit id="123a11d8fa5ed53f8ac07b91892dff993cf556e9" translate="yes" xml:space="preserve">
          <source>Note that Kotlin does not have a &lt;em&gt;new&lt;/em&gt; keyword.</source>
          <target state="translated">Kotlinには&lt;em&gt;新しい&lt;/em&gt;キーワードがないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="24cefba751ca3442834b1d28297766c4dedb14f5" translate="yes" xml:space="preserve">
          <source>Note that SAM conversions only work for interfaces, not for abstract classes, even if those also have just a single abstract method.</source>
          <target state="translated">SAMの変換はインタフェースに対してのみ機能し、抽象クラスに対しては機能しないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="50497e29cee31d617bb240dff5362b9731a558da" translate="yes" xml:space="preserve">
          <source>Note that a &lt;code&gt;for&lt;/code&gt; loop always implicitly declares a new read-only variable (in this example, &lt;code&gt;name&lt;/code&gt;) - if the outer scope already contains a variable with the same name, it will be shadowed by the unrelated loop variable. For the same reason, the final value of the loop variable is not accessible after the loop.</source>
          <target state="translated">&lt;code&gt;for&lt;/code&gt; ループは常に新しい読み取り専用変数（この例では &lt;code&gt;name&lt;/code&gt; ）を暗黙的に宣言することに注意してください。外側のスコープに同じ名前の変数がすでに含まれている場合、無関係なループ変数によってシャドウされます。同じ理由で、ループ変数の最終値はループ後にアクセスできません。</target>
        </trans-unit>
        <trans-unit id="f345c0305c039a5c5d92b2679df3ab69307a3616" translate="yes" xml:space="preserve">
          <source>Note that a Kotlin class reference is not the same as a Java class reference. To obtain a Java class reference, use the &lt;code&gt;.java&lt;/code&gt; property on a &lt;code&gt;KClass&lt;/code&gt; instance.</source>
          <target state="translated">Kotlinクラス参照はJavaクラス参照と同じではないことに注意してください。Javaクラス参照を取得するには、 &lt;code&gt;KClass&lt;/code&gt; インスタンスで &lt;code&gt;.java&lt;/code&gt; プロパティを使用します。</target>
        </trans-unit>
        <trans-unit id="0206a8d998dc749c92f53c56e6d927b2e3bb8c96" translate="yes" xml:space="preserve">
          <source>Note that a boxed primitive type used as a type parameter is mapped to a platform type: for example, &lt;code&gt;List&amp;lt;java.lang.Integer&amp;gt;&lt;/code&gt; becomes a &lt;code&gt;List&amp;lt;Int!&amp;gt;&lt;/code&gt; in Kotlin.</source>
          <target state="translated">型パラメータとして使用箱入りプリミティブ型は、プラットフォームの種類にマッピングされていることに注意してください。例えば、 &lt;code&gt;List&amp;lt;java.lang.Integer&amp;gt;&lt;/code&gt; となり &lt;code&gt;List&amp;lt;Int!&amp;gt;&lt;/code&gt; Kotlinインチ</target>
        </trans-unit>
        <trans-unit id="cda0f8a2d7cf131c070c968ead3e02616cc75710" translate="yes" xml:space="preserve">
          <source>Note that a file marked with the &lt;code&gt;@JsQualifier(...)&lt;/code&gt; annotation can't contain non-&lt;code&gt;external&lt;/code&gt; declarations.</source>
          <target state="translated">でマークされたファイルという注意 &lt;code&gt;@JsQualifier(...)&lt;/code&gt; 注釈が非含めることはできません &lt;code&gt;external&lt;/code&gt; 宣言を。</target>
        </trans-unit>
        <trans-unit id="406525d21e4a3c81c722c7741ff866f95a0130cf" translate="yes" xml:space="preserve">
          <source>Note that a function type with no receiver is inferred by default, even if a variable is initialized with a reference to an extension function. To alter that, specify the variable type explicitly.</source>
          <target state="translated">変数が拡張関数への参照で初期化されていても、デフォルトでは受信機のない関数型が推論されることに注意してください。これを変更するには、変数の型を明示的に指定します。</target>
        </trans-unit>
        <trans-unit id="b53df8b9afb9e806e949a0d6af036fa85a8a9db9" translate="yes" xml:space="preserve">
          <source>Note that a module referenced by a dependency declared for &lt;code&gt;commonMain&lt;/code&gt; or &lt;code&gt;commonTest&lt;/code&gt; source set must be published using the &lt;code&gt;kotlin-multiplatform&lt;/code&gt; plugin. If you want to use libraries published by the &lt;code&gt;kotlin-platform-native&lt;/code&gt; plugin, you need to declare a separate source set for common native sources.</source>
          <target state="translated">&lt;code&gt;commonMain&lt;/code&gt; または &lt;code&gt;commonTest&lt;/code&gt; ソースセットに対して宣言された依存関係によって参照されるモジュールは、 &lt;code&gt;kotlin-multiplatform&lt;/code&gt; プラグインを使用して公開する必要があることに注意してください。 &lt;code&gt;kotlin-platform-native&lt;/code&gt; プラグインによって公開されたライブラリを使用する場合は、一般的なネイティブソース用に個別のソースセットを宣言する必要があります。</target>
        </trans-unit>
        <trans-unit id="07dbd163eca990505b14bc6390f514e8f9d894c6" translate="yes" xml:space="preserve">
          <source>Note that a read-only variable is not a constant per se: it can be initialized with the value of a variable (so its value doesn't need to be known at compile-time), and if it is declared inside a construct that is repeatedly invoked (such as a function or a loop), it can take on a different value on each invocation. Also, while the read-only variable may not be reassigned while it is in scope, it can still refer to an object which is in itself mutable (such as a list).</source>
          <target state="translated">読み取り専用変数はそれ自体が定数ではないことに注意してください。変数の値で初期化することができ(コンパイル時にその値を知る必要はありません)、繰り返し呼び出される構造体(関数やループなど)の内部で宣言されている場合は、呼び出しのたびに異なる値を取ることができます。また、読み取り専用変数がスコープ内にある間は再代入されないかもしれませんが、それ自体が変異可能なオブジェクト (リストなど)を参照することができます。</target>
        </trans-unit>
        <trans-unit id="89edad7d707ce970adc3246bd03659328accf5e4" translate="yes" xml:space="preserve">
          <source>Note that all classes in this tutorial are in the &lt;code&gt;org.jetbrains.kotlin.demo&lt;/code&gt; package.</source>
          <target state="translated">このチュートリアルのすべてのクラスは &lt;code&gt;org.jetbrains.kotlin.demo&lt;/code&gt; パッケージにあることに注意してください。</target>
        </trans-unit>
        <trans-unit id="e339722ad427ded0a06508490a0f24fc47b54f2b" translate="yes" xml:space="preserve">
          <source>Note that altering a mutable collection doesn't require it to be a &lt;a href=&quot;basic-syntax#defining-variables&quot;&gt;&lt;code&gt;var&lt;/code&gt;&lt;/a&gt;: write operations modify the same mutable collection object, so the reference doesn't change. Although, if you try to reassign a &lt;code&gt;val&lt;/code&gt; collection, you'll get a compilation error.</source>
          <target state="translated">可変コレクションを変更するために、それが&lt;a href=&quot;basic-syntax#defining-variables&quot;&gt; &lt;code&gt;var&lt;/code&gt; &lt;/a&gt;である必要はないことに注意してください。書き込み操作は、同じ可変コレクションオブジェクトを変更するため、参照は変更されません。ただし、 &lt;code&gt;val&lt;/code&gt; コレクションを再割り当てしようとすると、コンパイルエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="402c9cc77c78831d6ef7a6f5b12edeefd76b9797" translate="yes" xml:space="preserve">
          <source>Note that an &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/actor.html&quot;&gt;actor&lt;/a&gt; coroutine builder is a dual of &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/produce.html&quot;&gt;produce&lt;/a&gt; coroutine builder. An actor is associated with the channel that it receives messages from, while a producer is associated with the channel that it sends elements to.</source>
          <target state="translated">&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/actor.html&quot;&gt;アクター&lt;/a&gt;コルーチンビルダーは、&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/produce.html&quot;&gt;プロデュース&lt;/a&gt;コルーチンビルダーのデュアルであることに注意してください。アクターはメッセージを受信するチャネルに関連付けられていますが、プロデューサーは要素を送信するチャネルに関連付けられています。</target>
        </trans-unit>
        <trans-unit id="3f7eda5be515629fb292c86295db20e329d1452f" translate="yes" xml:space="preserve">
          <source>Note that an order of &lt;a href=&quot;compare-by-descending#kotlin.comparisons%24compareByDescending%28kotlin.Comparator%28%28kotlin.comparisons.compareByDescending.K%29%29%2C+kotlin.Function1%28%28kotlin.comparisons.compareByDescending.T%2C+kotlin.comparisons.compareByDescending.K%29%29%29%2Fcomparator&quot;&gt;comparator&lt;/a&gt; is reversed by this wrapper.</source>
          <target state="translated">このラッパーによって&lt;a href=&quot;compare-by-descending#kotlin.comparisons%24compareByDescending%28kotlin.Comparator%28%28kotlin.comparisons.compareByDescending.K%29%29%2C+kotlin.Function1%28%28kotlin.comparisons.compareByDescending.T%2C+kotlin.comparisons.compareByDescending.K%29%29%29%2Fcomparator&quot;&gt;コンパレーターの&lt;/a&gt;順序が逆になることに注意してください。</target>
        </trans-unit>
        <trans-unit id="5d17efed58ea9f37046b141c69cdea45b1227096" translate="yes" xml:space="preserve">
          <source>Note that an order of &lt;a href=&quot;compare-by-descending#kotlin.comparisons%24compareByDescending(kotlin.Comparator((kotlin.comparisons.compareByDescending.K)),%20kotlin.Function1((kotlin.comparisons.compareByDescending.T,%20kotlin.comparisons.compareByDescending.K)))/comparator&quot;&gt;comparator&lt;/a&gt; is reversed by this wrapper.</source>
          <target state="translated">このラッパーによって&lt;a href=&quot;compare-by-descending#kotlin.comparisons%24compareByDescending(kotlin.Comparator((kotlin.comparisons.compareByDescending.K)),%20kotlin.Function1((kotlin.comparisons.compareByDescending.T,%20kotlin.comparisons.compareByDescending.K)))/comparator&quot;&gt;コンパレータの&lt;/a&gt;順序が逆になることに注意してください。</target>
        </trans-unit>
        <trans-unit id="e5cfcc2bcacb2464eb49e0f0ddd2d5c9c0f5de73" translate="yes" xml:space="preserve">
          <source>Note that anonymous function parameters are always passed inside the parentheses. The shorthand syntax allowing to leave the function outside the parentheses works only for lambda expressions.</source>
          <target state="translated">匿名関数のパラメータは常に括弧内に渡されることに注意してください。括弧の外に関数を残すことができる短縮構文は、ラムダ式でのみ機能します。</target>
        </trans-unit>
        <trans-unit id="9217d029286f8cd07e91756805e90b92b90c8d04" translate="yes" xml:space="preserve">
          <source>Note that anonymous objects can be used as types only in local and private declarations. If you use an anonymous object as a return type of a public function or the type of a public property, the actual type of that function or property will be the declared supertype of the anonymous object, or &lt;code&gt;Any&lt;/code&gt; if you didn't declare any supertype. Members added in the anonymous object will not be accessible.</source>
          <target state="translated">匿名オブジェクトは、ローカルおよびプライベート宣言でのみ型として使用できることに注意してください。匿名関数をパブリック関数の戻り値の型またはパブリックプロパティの型として使用する場合、その関数またはプロパティの実際の型は匿名オブジェクトの宣言されたスーパータイプ、またはスーパータイプを宣言しなかった場合は &lt;code&gt;Any&lt;/code&gt; になります。 。匿名オブジェクトに追加されたメンバーにはアクセスできません。</target>
        </trans-unit>
        <trans-unit id="58e17f85bfcb71bf347b7f266c8bad279b3e8c99" translate="yes" xml:space="preserve">
          <source>Note that another regular expression constructed from the same pattern string may have different &lt;a href=&quot;options#kotlin.text.Regex%24options&quot;&gt;options&lt;/a&gt; and may match strings differently.</source>
          <target state="translated">同じパターン文字列から作成された別の正規表現は、&lt;a href=&quot;options#kotlin.text.Regex%24options&quot;&gt;オプション&lt;/a&gt;が異なり、文字列の一致が異なる場合があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="0e1195c36b54acff13f3bf0d0c44bfdb9ba62965" translate="yes" xml:space="preserve">
          <source>Note that blank lines do not affect the detected indent level.</source>
          <target state="translated">空行は検出されたインデントレベルに影響しないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="901eb90b706fa87b74726ae4ca585fc8ee1df3bd" translate="yes" xml:space="preserve">
          <source>Note that both the target platform and the name matter: if a target was created as &lt;code&gt;jvm('jvm6')&lt;/code&gt;, using &lt;code&gt;jvm()&lt;/code&gt; will create a separate target (with the default name &lt;code&gt;jvm&lt;/code&gt;). If the preset function used to create the target under that name was different, an error is reported.</source>
          <target state="translated">注両方のターゲットプラットフォームと名の問題であること：ターゲットは、次のように作成された場合 &lt;code&gt;jvm('jvm6')&lt;/code&gt; 使用して、 &lt;code&gt;jvm()&lt;/code&gt; （デフォルト名を持つ別のターゲットが作成されます &lt;code&gt;jvm&lt;/code&gt; ）。その名前でターゲットを作成するために使用されたプリセット関数が異なる場合、エラーが報告されます。</target>
        </trans-unit>
        <trans-unit id="20a8a158a1c056ad5cea3eaeda038189df025fb8" translate="yes" xml:space="preserve">
          <source>Note that boxing of numbers does not necessarily preserve identity:</source>
          <target state="translated">数字の箱詰めは必ずしも同一性を維持するわけではないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="18f0c3bd108e4fca3d9b4ad0c92853cb37af67e8" translate="yes" xml:space="preserve">
          <source>Note that cancelling a producer coroutine closes its channel, thus eventually terminating iteration over the channel that processor coroutines are doing.</source>
          <target state="translated">プロデューサ・コルーチンをキャンセルすると、そのチャネルが閉じてしまうので、最終的にはプロセッサ・コルーチンが行っているチャネルに対する反復処理が終了してしまうことに注意してください。</target>
        </trans-unit>
        <trans-unit id="a4257481b27fd911ec2dc62a1694406a02635294" translate="yes" xml:space="preserve">
          <source>Note that changing type from unsigned type to signed counterpart (and vice versa) is a &lt;em&gt;binary incompatible&lt;/em&gt; change</source>
          <target state="translated">符号なしの型から符号付きの型に（およびその逆に）型を変更すると、&lt;em&gt;バイナリ互換性のない&lt;/em&gt;変更になることに注意してください。</target>
        </trans-unit>
        <trans-unit id="fb531691886575d5d0b4f4f27624c19223bae127" translate="yes" xml:space="preserve">
          <source>Note that characters are not numbers in Kotlin.</source>
          <target state="translated">Kotlinでは文字は数字ではないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="224781b538ad44d496b4eb9848adbb611bc7607f" translate="yes" xml:space="preserve">
          <source>Note that classes which extend subclasses of a sealed class (indirect inheritors) can be placed anywhere, not necessarily in the same file.</source>
          <target state="translated">封印されたクラスのサブクラスを拡張するクラス(間接的な継承者)は、同じファイル内である必要はなく、どこにでも配置することができることに注意してください。</target>
        </trans-unit>
        <trans-unit id="4b347074d3d760a0df60b87ff4401c3b2a375933" translate="yes" xml:space="preserve">
          <source>Note that code in initializer blocks effectively becomes part of the primary constructor. Delegation to the primary constructor happens as the first statement of a secondary constructor, so the code in all initializer blocks and property initializers is executed before the secondary constructor body. Even if the class has no primary constructor, the delegation still happens implicitly, and the initializer blocks are still executed:</source>
          <target state="translated">イニシャライザ ブロック内のコードは、事実上プライマリ コンストラクタの一部になることに注意してください。プライマリ コンストラクタへの委任はセカンダリ コンストラクタの最初のステートメントとして行われるため、すべてのイニシャライザ ブロックとプロパティ イニシャライザのコードはセカンダリ コンストラクタの本体よりも前に実行されます。クラスに一次コンストラクタがない場合でも、委任は暗黙のうちに行われ、イニシャライザ ブロックは実行されます。</target>
        </trans-unit>
        <trans-unit id="b01c476864e020a6b3bdf6a577c404757a04f763" translate="yes" xml:space="preserve">
          <source>Note that code in initializer blocks effectively becomes part of the primary constructor. Delegation to the primary constructor happens as the first statement of a secondary constructor, so the code in all initializer blocks is executed before the secondary constructor body. Even if the class has no primary constructor, the delegation still happens implicitly, and the initializer blocks are still executed:</source>
          <target state="translated">初期化ブロック内のコードは、事実上プライマリ コンストラクタの一部になることに注意してください。プライマリ コンストラクタへの委任はセカンダリ コンストラクタの最初のステートメントとして行われるため、すべてのイニシャライザ ブロック内のコードはセカンダリ コンストラクタのボディよりも前に実行されます。クラスに一次コンストラクタがない場合でも、委任は暗黙のうちに行われ、初期化ブロックは実行されます。</target>
        </trans-unit>
        <trans-unit id="40662d03b687698fb7e2efe397dfb49179bd8a28" translate="yes" xml:space="preserve">
          <source>Note that coroutines are currently considered an &lt;strong&gt;experimental feature&lt;/strong&gt;, meaning that the Kotlin team is not committing to supporting the backwards compatibility of this feature after the final 1.1 release.</source>
          <target state="translated">コルーチンは現在&lt;strong&gt;実験的な機能&lt;/strong&gt;と見なされていることに注意してください。つまり、Kotlinチームは、最終的な1.1リリース以降、この機能の下位互換性をサポートすることを約束していません。</target>
        </trans-unit>
        <trans-unit id="abdd0e9fc4f6072582fff7f11143b17405eee64f" translate="yes" xml:space="preserve">
          <source>Note that despite the fact that the right-hand side of &lt;em&gt;as?&lt;/em&gt; is a non-null type &lt;code&gt;String&lt;/code&gt; the result of the cast is nullable.</source>
          <target state="translated">&lt;em&gt;asの&lt;/em&gt;右側にあるという事実にもかかわらず、null以外の型の &lt;code&gt;String&lt;/code&gt; です。キャストの結果はnull可能です。</target>
        </trans-unit>
        <trans-unit id="d2338fe045f1f2d5efa433b2cf56bf15940234fd" translate="yes" xml:space="preserve">
          <source>Note that division between integers always returns an integer. Any fractional part is discarded. For example:</source>
          <target state="translated">整数同士の除算は常に整数を返すことに注意してください。端数部分はすべて破棄されます。例えば</target>
        </trans-unit>
        <trans-unit id="984acf59abb99e6edf5501246d83e1bc7951b21e" translate="yes" xml:space="preserve">
          <source>Note that even if &lt;a href=&quot;is-marked-nullable#kotlin.reflect.KType%24isMarkedNullable&quot;&gt;isMarkedNullable&lt;/a&gt; is false, values of the type can still be &lt;code&gt;null&lt;/code&gt;. This may happen if it is a type of the type parameter with a nullable upper bound:</source>
          <target state="translated">&lt;a href=&quot;is-marked-nullable#kotlin.reflect.KType%24isMarkedNullable&quot;&gt;isMarkedNullable&lt;/a&gt;がfalseの場合でも、型の値が &lt;code&gt;null&lt;/code&gt; になる可能性があることに注意してください。これは、null許容の上限を持つ型パラメーターの型である場合に発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="f9717ca7605239239d9b446b8d8baf568533a62a" translate="yes" xml:space="preserve">
          <source>Note that even if you initialize a variable with a reference to an extension function, the inferred function type will have no receiver (it will have an additional parameter accepting a receiver object). To have a function type with receiver instead, specify the type explicitly:</source>
          <target state="translated">拡張関数への参照で変数を初期化した場合でも、推論された関数型にはレシーバがないことに注意してください(レシーバオブジェクトを受け取る追加のパラメータを持つことになります)。代わりにレシーバを持つ関数型を持つようにするには、明示的に型を指定します。</target>
        </trans-unit>
        <trans-unit id="e1859932d9a0b691a9fc9411f62e5506be7f8a66" translate="yes" xml:space="preserve">
          <source>Note that even though this is a read-only property due to declaring it with &lt;code&gt;val&lt;/code&gt; (in which case you may not provide a setter), its value can still change since it reads from a mutable property - you just can't assign to the property. Also, note that the property type is inferred from the return value of the getter.</source>
          <target state="translated">これは &lt;code&gt;val&lt;/code&gt; で宣言されているため読み取り専用プロパティですが（その場合、セッターを指定できない場合があります）、変更可能なプロパティから読み取るため、その値は変更される可能性があることに注意してください。プロパティ。また、プロパティタイプはゲッターの戻り値から推測されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="fd6bde9af50a41c1d5f97ea7b48311cc0527806c" translate="yes" xml:space="preserve">
          <source>Note that exceptions are somewhat discouraged in Kotlin except when interacting with Java code. Instead of throwing exceptions in your own code, consider using special return types like &lt;a href=&quot;https://arrow-kt.io/docs/datatypes/option/&quot;&gt;Option&lt;/a&gt; or &lt;a href=&quot;https://arrow-kt.io/docs/datatypes/either/&quot;&gt;Either&lt;/a&gt; from the &lt;a href=&quot;https://arrow-kt.io/&quot;&gt;Arrow library&lt;/a&gt;.</source>
          <target state="translated">Javaコードとやり取りする場合を除いて、Kotlinでは例外がやや推奨されないことに注意してください。独自のコードで例外をスローする代わりに、&lt;a href=&quot;https://arrow-kt.io/&quot;&gt;矢印ライブラリの&lt;/a&gt;&lt;a href=&quot;https://arrow-kt.io/docs/datatypes/option/&quot;&gt;Option&lt;/a&gt;または&lt;a href=&quot;https://arrow-kt.io/docs/datatypes/either/&quot;&gt;Either&lt;/a&gt;などの特別な戻り値の型を使用することを検討してください。</target>
        </trans-unit>
        <trans-unit id="33e073ab069310793fb905b91ca3476dc4caf23c" translate="yes" xml:space="preserve">
          <source>Note that expected declarations are not restricted to interfaces and interface members. In this example, the expected class has a constructor and can be created directly from common code. You can apply the &lt;code&gt;expect&lt;/code&gt; modifier to other declarations as well, including top-level declarations and annotations:</source>
          <target state="translated">予期される宣言は、インターフェースとインターフェースメンバーに限定されないことに注意してください。この例では、予期されるクラスにコンストラクターがあり、一般的なコードから直接作成できます。 &lt;code&gt;expect&lt;/code&gt; 修飾子は、トップレベルの宣言や注釈を含む他の宣言にも適用できます。</target>
        </trans-unit>
        <trans-unit id="45215a2c612cfc18ca0212e4816f62d8f14fe5b3" translate="yes" xml:space="preserve">
          <source>Note that extensions can be defined with a nullable receiver type. Such extensions can be called on an object variable even if its value is null, and can check for &lt;code&gt;this == null&lt;/code&gt; inside the body. This is what allows you to call toString() in Kotlin without checking for null: the check happens inside the extension function.</source>
          <target state="translated">拡張はnull許容のレシーバータイプで定義できることに注意してください。そのような拡張機能は、その値がnullであってもオブジェクト変数で呼び出すことができ、本文の中で &lt;code&gt;this == null&lt;/code&gt; かどうかを確認できます。これにより、nullをチェックせずにKotlinでtoString（）を呼び出すことができます。チェックは拡張関数内で行われます。</target>
        </trans-unit>
        <trans-unit id="519b88833afa591c638bec3f6bbeb8adf1aa4ab7" translate="yes" xml:space="preserve">
          <source>Note that for a top level &lt;strong&gt;extension&lt;/strong&gt; property, the delegate is the same for all extension receivers, so the actual &lt;a href=&quot;get-delegate#kotlin.reflect.KProperty1%24getDelegate%28kotlin.reflect.KProperty1.T%29%2Freceiver&quot;&gt;receiver&lt;/a&gt; instance passed in is not going to make any difference, it must only be a value of &lt;a href=&quot;index#T&quot;&gt;T&lt;/a&gt;.</source>
          <target state="translated">トップレベルの&lt;strong&gt;拡張&lt;/strong&gt;プロパティの場合、デリゲートはすべての拡張レシーバーで同じであるため、渡された実際の&lt;a href=&quot;get-delegate#kotlin.reflect.KProperty1%24getDelegate%28kotlin.reflect.KProperty1.T%29%2Freceiver&quot;&gt;レシーバー&lt;/a&gt;インスタンスは何の違いも生じないことに注意してください。値は&lt;a href=&quot;index#T&quot;&gt;T&lt;/a&gt;でなければなりません。</target>
        </trans-unit>
        <trans-unit id="d2defd349af6dc7f8207169257d4b38f3d3fe54d" translate="yes" xml:space="preserve">
          <source>Note that for a top level &lt;strong&gt;extension&lt;/strong&gt; property, the delegate is the same for all extension receivers, so the actual &lt;a href=&quot;get-delegate#kotlin.reflect.KProperty1%24getDelegate(kotlin.reflect.KProperty1.T)/receiver&quot;&gt;receiver&lt;/a&gt; instance passed in is not going to make any difference, it must only be a value of &lt;a href=&quot;index#T&quot;&gt;T&lt;/a&gt;.</source>
          <target state="translated">トップレベルの&lt;strong&gt;拡張&lt;/strong&gt;プロパティの場合、デリゲートはすべての拡張レシーバーで同じであるため、渡される実際の&lt;a href=&quot;get-delegate#kotlin.reflect.KProperty1%24getDelegate(kotlin.reflect.KProperty1.T)/receiver&quot;&gt;レシーバー&lt;/a&gt;インスタンスは何の違いも生じず、&lt;a href=&quot;index#T&quot;&gt;Tの&lt;/a&gt;値のみである必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="c0ed19157d69e7092350d01754dff2c913099ef4" translate="yes" xml:space="preserve">
          <source>Note that for the IDE to correctly analyze the dependencies of the common sources, the common source sets need to have corresponding dependencies on the Kotlin metadata packages in addition to the platform-specific artifact dependencies of the platform-specific source sets. Usually, an artifact with a suffix &lt;code&gt;-common&lt;/code&gt; (as in &lt;code&gt;kotlin-stdlib-common&lt;/code&gt;) or &lt;code&gt;-metadata&lt;/code&gt; is required when using a published library (unless it is published with Gradle metadata, as described below).</source>
          <target state="translated">IDEが共通ソースの依存関係を正しく分析するには、共通ソースセットに、プラットフォーム固有のソースセットのプラットフォーム固有のアーティファクト依存関係に加えて、Kotlinメタデータパッケージに対する対応する依存関係が必要であることに注意してください。通常、公開されたライブラリを使用する場合は、 &lt;code&gt;-common&lt;/code&gt; （ &lt;code&gt;kotlin-stdlib-common&lt;/code&gt; など）または &lt;code&gt;-metadata&lt;/code&gt; のアーティファクトが必要です（以下で説明するように、Gradleメタデータで公開されている場合を除く）。</target>
        </trans-unit>
        <trans-unit id="ef903749bbe41c983b27f632974567077577929e" translate="yes" xml:space="preserve">
          <source>Note that for the purpose of this tutorial, we've done a line by line literal translation. Obviously we could write this in a more Kotlin idiomatic way.</source>
          <target state="translated">このチュートリアルの目的のために、一行一行のリテラル翻訳を行っていることに注意してください。明らかにもっとKotlinの慣用的な方法で書くことができます。</target>
        </trans-unit>
        <trans-unit id="2712e3816fc9fe0e5aede4e3fca67cc623f69a68" translate="yes" xml:space="preserve">
          <source>Note that if a class has got a primary constructor, it is no longer possible to create an instance of it without supplying any parameters (unless one of the secondary constructors is parameterless).</source>
          <target state="translated">クラスが一次コンストラクタを持っている場合は、パラメータを与えずにそのクラスのインスタンスを作成することはできないことに注意してください (二次コンストラクタの一つがパラメータレスでない限り)。</target>
        </trans-unit>
        <trans-unit id="3b1296c9d04a31b1fde17dffa086ef1b8acdb6c3" translate="yes" xml:space="preserve">
          <source>Note that if a library consumer defines variants that are missing in the library, they need to provide &lt;a href=&quot;https://developer.android.com/studio/build/dependencies#resolve_matching_errors&quot;&gt;matching fallbacks&lt;/a&gt;. For example, if a library does not have or does not publish a &lt;code&gt;staging&lt;/code&gt; build type, it will be necessary to provide a fallback for the consumers who have such a build type, specifying at least one of the build types that the library publishes:</source>
          <target state="translated">ライブラリの利用者がライブラリに欠けているバリアントを定義する場合、それらは&lt;a href=&quot;https://developer.android.com/studio/build/dependencies#resolve_matching_errors&quot;&gt;一致するフォールバック&lt;/a&gt;を提供する必要があることに注意してください。たとえば、ライブラリに &lt;code&gt;staging&lt;/code&gt; ビルドタイプがないか公開されていない場合、そのようなビルドタイプを持つコンシューマーにフォールバックを提供し、ライブラリが公開するビルドタイプの少なくとも1つを指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="6c82c92fd55806c5e9d8d4f7e9db855fd43d5a7a" translate="yes" xml:space="preserve">
          <source>Note that if an inline function has no inlinable function parameters and no &lt;a href=&quot;#reified-type-parameters&quot;&gt;reified type parameters&lt;/a&gt;, the compiler will issue a warning, since inlining such functions is very unlikely to be beneficial (you can suppress the warning if you are sure the inlining is needed using the annotation &lt;code&gt;@Suppress(&quot;NOTHING_TO_INLINE&quot;)&lt;/code&gt;).</source>
          <target state="translated">インライン関数にインライン可能な関数パラメーターがなく、具体&lt;a href=&quot;#reified-type-parameters&quot;&gt;化された型パラメーター&lt;/a&gt;がない場合、そのような関数のインライン化が有益である可能性は非常に低いため、コンパイラーは警告を発行します（インライン化がアノテーション &lt;code&gt;@Suppress(&quot;NOTHING_TO_INLINE&quot;)&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="ac1401dfe931b50e5500ce4b2ebac5d2aaf6e00c" translate="yes" xml:space="preserve">
          <source>Note that if an interface with &lt;code&gt;@JvmDefault&lt;/code&gt; methods is used as a &lt;a href=&quot;delegation&quot;&gt;delegate&lt;/a&gt;, the default method implementations are called even if the actual delegate type provides its own implementations.</source>
          <target state="translated">界面場合、その音符 &lt;code&gt;@JvmDefault&lt;/code&gt; の方法として使用される&lt;a href=&quot;delegation&quot;&gt;デリゲート&lt;/a&gt;、デフォルトのメソッドの実装は、実際のデリゲート型は、独自の実装を提供しても呼ばれています。</target>
        </trans-unit>
        <trans-unit id="5c363669dd6ed31274f54972ddb75e1fa04284aa" translate="yes" xml:space="preserve">
          <source>Note that if the &lt;code&gt;comparator&lt;/code&gt; considers any two keys of this map equal, only the value associated with the last of them gets into the resulting map.</source>
          <target state="translated">&lt;code&gt;comparator&lt;/code&gt; がこのマップの2つのキーを等しいと見なした場合、それらの最後のキーに関連付けられた値のみが結果のマップに入ることに注意してください。</target>
        </trans-unit>
        <trans-unit id="169507f367051a5b585a09223134ff4c0faab6be" translate="yes" xml:space="preserve">
          <source>Note that if the natural sorting order of keys considers any two keys of this map equal (this could happen if the equality of keys according to &lt;a href=&quot;../kotlin/-comparable/compare-to#kotlin.Comparable%24compareTo%28kotlin.Comparable.T%29&quot;&gt;Comparable.compareTo&lt;/a&gt; is inconsistent with the equality according to &lt;a href=&quot;../kotlin/-any/equals#kotlin.Any%24equals%28kotlin.Any%29&quot;&gt;Any.equals&lt;/a&gt;), only the value associated with the last of them gets into the resulting map.</source>
          <target state="translated">キーの自然なソート順がこのマップの任意の2つのキーを等しいと見なす場合（これは、&lt;a href=&quot;../kotlin/-comparable/compare-to#kotlin.Comparable%24compareTo%28kotlin.Comparable.T%29&quot;&gt;Comparable.compareTo&lt;/a&gt;によるキーの等価性が&lt;a href=&quot;../kotlin/-any/equals#kotlin.Any%24equals%28kotlin.Any%29&quot;&gt;Any.equals&lt;/a&gt;による等価性と一致しない場合に発生する可能性があります）、最後のキーに関連付けられた値のみそれらの結果のマップに入ります。</target>
        </trans-unit>
        <trans-unit id="e0314127afde0714d8e6361a9b85bacb2fcd7ce9" translate="yes" xml:space="preserve">
          <source>Note that if the natural sorting order of keys considers any two keys of this map equal (this could happen if the equality of keys according to &lt;a href=&quot;../kotlin/-comparable/compare-to#kotlin.Comparable%24compareTo(kotlin.Comparable.T)&quot;&gt;Comparable.compareTo&lt;/a&gt; is inconsistent with the equality according to &lt;a href=&quot;../kotlin/-any/equals#kotlin.Any%24equals(kotlin.Any?)&quot;&gt;Any.equals&lt;/a&gt;), only the value associated with the last of them gets into the resulting map.</source>
          <target state="translated">キーの自然順順がこのマップの任意の2つのキーが等しいと見なす場合（これは、&lt;a href=&quot;../kotlin/-comparable/compare-to#kotlin.Comparable%24compareTo(kotlin.Comparable.T)&quot;&gt;Comparable.compareTo&lt;/a&gt;によるキーの同等性が&lt;a href=&quot;../kotlin/-any/equals#kotlin.Any%24equals(kotlin.Any?)&quot;&gt;Any.equals&lt;/a&gt;による同等性と矛盾する場合に発生する可能性があります）、最後に関連付けられた値のみであることに注意してください。それらのうちの1つが結果のマップに入ります。</target>
        </trans-unit>
        <trans-unit id="fdeead972a4f0dc85a954b4ef35d091c4109a874" translate="yes" xml:space="preserve">
          <source>Note that if the type of the result is known from the context, the type argument can be omitted as usual due to the type inference.</source>
          <target state="translated">コンテキストから結果の型がわかっている場合は、型推論のため、通常通り型引数を省略することができることに注意してください。</target>
        </trans-unit>
        <trans-unit id="3df7a58b11ae9c7f677f019b7e29ec36da986c3e" translate="yes" xml:space="preserve">
          <source>Note that if this function fails, then partial copying may have taken place.</source>
          <target state="translated">この関数が失敗した場合は、部分的なコピーが行われている可能性があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="e537ff121d99004384d6b13ae0784e74c296eabf" translate="yes" xml:space="preserve">
          <source>Note that if we have called &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/await.html&quot;&gt;await&lt;/a&gt; in &lt;code&gt;println&lt;/code&gt; and omitted &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/start.html&quot;&gt;start&lt;/a&gt; on individual coroutines, then we would have got the sequential behaviour as &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/await.html&quot;&gt;await&lt;/a&gt; starts the coroutine execution and waits for the execution to finish, which is not the intended use-case for laziness. The use-case for &lt;code&gt;async(start = CoroutineStart.LAZY)&lt;/code&gt; is a replacement for the standard &lt;code&gt;lazy&lt;/code&gt; function in cases when computation of the value involves suspending functions.</source>
          <target state="translated">私たちが呼び出されている場合は、そのノート&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/await.html&quot;&gt;のawait&lt;/a&gt;で &lt;code&gt;println&lt;/code&gt; 省略&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/start.html&quot;&gt;開始を&lt;/a&gt;個々のコルーチンにとして、我々はシーケンシャルな行動を持っているだろう&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/await.html&quot;&gt;のawaitは&lt;/a&gt;怠惰のために意図されたユースケースではありません最後まで実行のためのコルーチンの実行を待機し、開始します。 &lt;code&gt;async(start = CoroutineStart.LAZY)&lt;/code&gt; の使用例は、値の計算に関数の中断が含まれる場合の標準の &lt;code&gt;lazy&lt;/code&gt; 関数の代わりです。</target>
        </trans-unit>
        <trans-unit id="ca8da6b3b0810e7069d1865b81c075dccb66b2c6" translate="yes" xml:space="preserve">
          <source>Note that if we just call &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/await.html&quot;&gt;await&lt;/a&gt; in &lt;code&gt;println&lt;/code&gt; without first calling &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/start.html&quot;&gt;start&lt;/a&gt; on individual coroutines, this will lead to sequential behavior, since &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/await.html&quot;&gt;await&lt;/a&gt; starts the coroutine execution and waits for its finish, which is not the intended use-case for laziness. The use-case for &lt;code&gt;async(start = CoroutineStart.LAZY)&lt;/code&gt; is a replacement for the standard &lt;code&gt;lazy&lt;/code&gt; function in cases when computation of the value involves suspending functions.</source>
          <target state="translated">個々のコルーチンで最初に&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/start.html&quot;&gt;start&lt;/a&gt;を呼び出さずに &lt;code&gt;println&lt;/code&gt; で&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/await.html&quot;&gt;await&lt;/a&gt;を呼び出すと、&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/await.html&quot;&gt;await&lt;/a&gt;がコルーチンの実行を開始して終了を待機するため、シーケンシャルな動作が発生することに注意してください。これは、怠惰の意図されたユースケースではありません。 &lt;code&gt;async(start = CoroutineStart.LAZY)&lt;/code&gt; のユースケースは、値の計算に関数の一時停止が含まれる場合の標準の &lt;code&gt;lazy&lt;/code&gt; 関数の代わりになります。</target>
        </trans-unit>
        <trans-unit id="1e82a73f61c52b17d7e3c65e8e99e11241b677f8" translate="yes" xml:space="preserve">
          <source>Note that if you are using multi-project build, you should apply plugin to the main project that is an entry point to your application.</source>
          <target state="translated">マルチプロジェクトビルドを使用している場合は、アプリケーションのエントリーポイントとなるメインプロジェクトにプラグインを適用する必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="e39d91f028c6c4bc3b768c071107ff617a7a7685" translate="yes" xml:space="preserve">
          <source>Note that if you use the project template generated by the &lt;a href=&quot;http://start.spring.io/#!language=kotlin&quot;&gt;start.spring.io&lt;/a&gt; service, the &lt;code&gt;kotlin-spring&lt;/code&gt; plugin will be enabled by default.</source>
          <target state="translated">&lt;a href=&quot;http://start.spring.io/#!language=kotlin&quot;&gt;start.spring.io&lt;/a&gt;サービスによって生成されたプロジェクトテンプレートを使用する場合、 &lt;code&gt;kotlin-spring&lt;/code&gt; プラグインがデフォルトで有効になることに注意してください。</target>
        </trans-unit>
        <trans-unit id="261071b80b92f5599125de0c5212f010938aeec4" translate="yes" xml:space="preserve">
          <source>Note that if your function has parameters, its name will be mangled, so the mangled name should be used in the keep directive.</source>
          <target state="translated">関数がパラメータを持っている場合は、その名前が変更されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="6917f47d5bafd263295f3acf8a1ef7ab9d827116" translate="yes" xml:space="preserve">
          <source>Note that in Kotlin, outer class does not see private members of its inner classes.</source>
          <target state="translated">Kotlinでは、外側のクラスは内側のクラスのプライベートメンバを見ないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="659e4fb54490f44ab2332ce79f12e2c6749032d5" translate="yes" xml:space="preserve">
          <source>Note that in Kotlin/JS &lt;a href=&quot;../set#kotlin.text%24set(kotlin.text.StringBuilder,%20kotlin.Int,%20kotlin.Char)&quot;&gt;set&lt;/a&gt; operator function has non-constant execution time complexity. Therefore, increasing length of this string builder and then updating each character by index may slow down your program.</source>
          <target state="translated">Kotlin / JSの&lt;a href=&quot;../set#kotlin.text%24set(kotlin.text.StringBuilder,%20kotlin.Int,%20kotlin.Char)&quot;&gt;集合&lt;/a&gt;演算子関数では、実行時間が一定ではないことに注意してください。したがって、この文字列ビルダーの長さを増やしてから、インデックスで各文字を更新すると、プログラムの速度が低下する可能性があります。</target>
        </trans-unit>
        <trans-unit id="4c99e0a3c39d8997895800da0e15222c8aa2ad3b" translate="yes" xml:space="preserve">
          <source>Note that in Kotlin/JS Float range is wider than &quot;single format&quot; bit layout can represent, so some Float values may overflow, underflow or loose their accuracy after conversion to bits and back.</source>
          <target state="translated">Kotlin/JSの場合、Floatの範囲は「単一フォーマット」のビットレイアウトが表現できる範囲よりも広いので、ビットに変換して戻ってきた後にFloatの値がオーバーフローしたり、アンダーフローしたり、精度が落ちたりすることがあることに注意してください。</target>
        </trans-unit>
        <trans-unit id="88d47ad6334c013775aba391a38df6074a6dc3f4" translate="yes" xml:space="preserve">
          <source>Note that in competitive programming it is customary to give variables shorter names than it is typical in industrial programming practice, since the code is to be written just once and not supported thereafter. However, these names are usually still mnemonic &amp;mdash; &lt;code&gt;a&lt;/code&gt; for arrays, &lt;code&gt;i&lt;/code&gt;, &lt;code&gt;j&lt;/code&gt;, etc for indices, &lt;code&gt;r&lt;/code&gt;, and &lt;code&gt;c&lt;/code&gt; for row and column numbers in tables, &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; for coordinates, etc. It is easier to keep the same names for input data as it is given in the problem statement. However, more complex problems require more code which leads to using longer self-explanatory variable and function names.</source>
          <target state="translated">競合プログラミングでは、コードは1回だけ記述され、その後はサポートされないため、工業用プログラミングの慣例よりも短い名前を変数に付けるのが通例であることに注意してください。ただし、これらの名前は通常、まだニーモニックです。配列の場合は &lt;code&gt;a&lt;/code&gt; 、インデックスの場合は &lt;code&gt;i&lt;/code&gt; 、 &lt;code&gt;j&lt;/code&gt; 、テーブルの行番号と列番号の場合は &lt;code&gt;r&lt;/code&gt; 、 &lt;code&gt;c&lt;/code&gt; 、座標の場合は &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; です。同じ名前を保持する方が簡単です問題の説明に記載されている入力データ。ただし、より複雑な問題にはより多くのコードが必要であり、そのため自明の変数名と関数名が長くなります。</target>
        </trans-unit>
        <trans-unit id="24fc67264648157b787a9e1d8a1aee247379a870" translate="yes" xml:space="preserve">
          <source>Note that in many cases there's no need to use custom interoperability library creation mechanisms described below, as for APIs available on the platform standardized bindings called &lt;a href=&quot;platform_libs&quot;&gt;platform libraries&lt;/a&gt; could be used. For example, POSIX on Linux/macOS platforms, Win32 on Windows platform, or Apple frameworks on macOS/iOS are available this way.</source>
          <target state="translated">多くの場合、以下で説明するカスタムの相互運用性ライブラリ作成メカニズムを使用する必要がないことに注意してください。&lt;a href=&quot;platform_libs&quot;&gt;プラットフォームライブラリで&lt;/a&gt;利用可能なAPIについては、プラットフォームライブラリと呼ばれる標準化されたバインディングを使用できます。たとえば、Linux / macOSプラットフォームのPOSIX、WindowsプラットフォームのWin32、またはmacOS / iOSのAppleフレームワークは、この方法で利用できます。</target>
        </trans-unit>
        <trans-unit id="4c3031faf8b33ed043c9d69fe73ae60488938a50" translate="yes" xml:space="preserve">
          <source>Note that in most cases using &lt;a href=&quot;#string-templates&quot;&gt;string templates&lt;/a&gt; or raw strings is preferable to string concatenation.</source>
          <target state="translated">ほとんどの場合、&lt;a href=&quot;#string-templates&quot;&gt;文字&lt;/a&gt;列の連結よりも文字列テンプレートまたは生の文字列を使用する方が望ましいことに注意してください。</target>
        </trans-unit>
        <trans-unit id="8d1e2fa9797125ae266c1521c6c52af5e4d67c8b" translate="yes" xml:space="preserve">
          <source>Note that in this case the parameter should be added to each subsequent build, and any build with disabled incremental compilation invalidates incremental caches.</source>
          <target state="translated">この場合、このパラメータは後続のビルドのたびに追加されるべきであり、インクリメンタル・コンパイルを無効にしたビルドはインクリメンタル・キャッシュを無効にすることに注意してください。</target>
        </trans-unit>
        <trans-unit id="6addd273834de7f83ab126536995cca9dd6643b2" translate="yes" xml:space="preserve">
          <source>Note that incremental annotation processing requires &lt;a href=&quot;using-gradle#incremental-compilation&quot;&gt;incremental compilation&lt;/a&gt; to be enabled as well.</source>
          <target state="translated">増分アノテーション処理では、&lt;a href=&quot;using-gradle#incremental-compilation&quot;&gt;増分コンパイル&lt;/a&gt;も有効にする必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="6b7588c134bcd5e8f4a5da82d120b4047c151b76" translate="yes" xml:space="preserve">
          <source>Note that infix functions always require both the receiver and the parameter to be specified. When you're calling a method on the current receiver using the infix notation, you need to use &lt;code&gt;this&lt;/code&gt; explicitly; unlike regular method calls, it cannot be omitted. This is required to ensure unambiguous parsing.</source>
          <target state="translated">中置関数では常にレシーバーとパラメーターの両方を指定する必要があることに注意してください。インフィックス表記を使用して現在のレシーバーでメソッドを呼び出す場合は、 &lt;code&gt;this&lt;/code&gt; 明示的に使用する必要があります。通常のメソッド呼び出しとは異なり、省略できません。これは、明確な解析を確実にするために必要です。</target>
        </trans-unit>
        <trans-unit id="ad1d05af6c1aa655f7d3f68b893652c8d8011b1f" translate="yes" xml:space="preserve">
          <source>Note that instead of declaring lambdas in xml like in the following example, you can can bind actions directly in the code:</source>
          <target state="translated">次の例のようにラムダをxmlで宣言するのではなく、コード内で直接アクションをバインドすることができることに注意してください。</target>
        </trans-unit>
        <trans-unit id="5d76391f0c3ceb2cfa6bd1897bb1920148848dd2" translate="yes" xml:space="preserve">
          <source>Note that invoking &lt;code&gt;js()&lt;/code&gt; returns a result of type &lt;a href=&quot;dynamic-type&quot;&gt;&lt;code&gt;dynamic&lt;/code&gt;&lt;/a&gt;, which provides no type safety at compile time.</source>
          <target state="translated">&lt;code&gt;js()&lt;/code&gt; を呼び出すと、&lt;a href=&quot;dynamic-type&quot;&gt; &lt;code&gt;dynamic&lt;/code&gt; &lt;/a&gt;型の結果が返されることに注意してください。これは、コンパイル時に型の安全性を提供しません。</target>
        </trans-unit>
        <trans-unit id="2de64757cb014df0ce60c045d22eb608329bdbb9" translate="yes" xml:space="preserve">
          <source>Note that it is not recommended to call either &lt;a href=&quot;../kotlin.coroutines.experimental/-continuation/resume&quot;&gt;Continuation.resume&lt;/a&gt; nor &lt;a href=&quot;../kotlin.coroutines.experimental/-continuation/resume-with-exception&quot;&gt;Continuation.resumeWithException&lt;/a&gt; functions synchronously in the same stackframe where suspension function is run. Use &lt;a href=&quot;../kotlin.coroutines.experimental/suspend-coroutine&quot;&gt;suspendCoroutine&lt;/a&gt; as a safer way to obtain current continuation instance.</source>
          <target state="translated">&lt;a href=&quot;../kotlin.coroutines.experimental/-continuation/resume-with-exception&quot;&gt;Continuation.resume&lt;/a&gt;関数またはContinuation.resumeWithException関数のいずれかを、一時停止関数が実行されている同じスタックフレームで同期&lt;a href=&quot;../kotlin.coroutines.experimental/-continuation/resume&quot;&gt;的&lt;/a&gt;に呼び出すことはお勧めしません。現在の継続インスタンスを取得するより安全な方法として、&lt;a href=&quot;../kotlin.coroutines.experimental/suspend-coroutine&quot;&gt;suspendCoroutine&lt;/a&gt;を使用してください。</target>
        </trans-unit>
        <trans-unit id="9d6ffb0207257e6147b3a7dc3f05f4b2eb90ba26" translate="yes" xml:space="preserve">
          <source>Note that it is not recommended to call either &lt;a href=&quot;../kotlin.coroutines/resume&quot;&gt;Continuation.resume&lt;/a&gt; nor &lt;a href=&quot;../kotlin.coroutines/resume-with-exception&quot;&gt;Continuation.resumeWithException&lt;/a&gt; functions synchronously in the same stackframe where suspension function is run. Use &lt;a href=&quot;../kotlin.coroutines/suspend-coroutine&quot;&gt;suspendCoroutine&lt;/a&gt; as a safer way to obtain current continuation instance.</source>
          <target state="translated">&lt;a href=&quot;../kotlin.coroutines/resume-with-exception&quot;&gt;Continuation.resume&lt;/a&gt;関数またはContinuation.resumeWithException関数のいずれかを、一時停止関数が実行されている同じスタックフレームで同期&lt;a href=&quot;../kotlin.coroutines/resume&quot;&gt;的&lt;/a&gt;に呼び出すことはお勧めしません。現在の継続インスタンスを取得するより安全な方法として、&lt;a href=&quot;../kotlin.coroutines/suspend-coroutine&quot;&gt;suspendCoroutine&lt;/a&gt;を使用してください。</target>
        </trans-unit>
        <trans-unit id="ef6ff08c8afdc4c88bfce216a4201b44bef8d337" translate="yes" xml:space="preserve">
          <source>Note that it's still possible to call the members of the outer receiver, but to do that you have to specify this receiver explicitly:</source>
          <target state="translated">外部レシーバのメンバを呼び出すことは可能ですが、そのためにはこのレシーバを明示的に指定しなければならないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="1a8a5665bc44d5cdbf2531c3d2423dcbe7d87681" translate="yes" xml:space="preserve">
          <source>Note that parameters of the primary constructor can be used in the initializer blocks. They can also be used in property initializers declared in the class body:</source>
          <target state="translated">プライマリ・コンストラクタのパラメータは、イニシャライザ・ブロックで使用できることに注意してください。また、クラス本体で宣言されたプロパティのイニシャライザでも使用することができます。</target>
        </trans-unit>
        <trans-unit id="88ac6b28b3a3b8435f7eba9f01321df2f731f34d" translate="yes" xml:space="preserve">
          <source>Note that right after the &quot;Task from coroutine scope&quot; message (while waiting for nested launch) &quot;Task from runBlocking&quot; is executed and printed &amp;mdash; even though the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;coroutineScope&lt;/a&gt; is not completed yet.</source>
          <target state="translated">にもかかわらず-右の「タスクコルーチンスコープからの」メッセージの後に「runBlockingからタスク」が実行して印刷する（入れ子の打ち上げを待っている間に）という注意&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;coroutineScopeは&lt;/a&gt;まだ完了していません。</target>
        </trans-unit>
        <trans-unit id="c0c4053dbcf27c46808a2ab0e8b3303b9f7cbf9a" translate="yes" xml:space="preserve">
          <source>Note that set operations are supported by &lt;code&gt;List&lt;/code&gt; as well. However, the result of set operations on lists is still a &lt;code&gt;Set&lt;/code&gt;, so all the duplicate elements are removed.</source>
          <target state="translated">集合演算は &lt;code&gt;List&lt;/code&gt; でもサポートされていることに注意してください。ただし、リストに対する集合演算の結果は依然として &lt;code&gt;Set&lt;/code&gt; であるため、重複する要素はすべて削除されます。</target>
        </trans-unit>
        <trans-unit id="205ca8f88f3bcbd4d7774a26be00ee48e66a2ebf" translate="yes" xml:space="preserve">
          <source>Note that since Kotlin 1.1 you can declare a delegated property inside a function or code block, it shouldn't necessarily be a member of a class. Below you can find &lt;a href=&quot;delegated-properties#local-delegated-properties&quot;&gt;an example&lt;/a&gt;.</source>
          <target state="translated">Kotlin 1.1以降、関数またはコードブロック内で委任されたプロパティを宣言できるため、必ずしもクラスのメンバーである必要はないことに注意してください。以下に&lt;a href=&quot;delegated-properties#local-delegated-properties&quot;&gt;例を示し&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="ecba1bd96686456eab8e7e25340f9f56c1cd293b" translate="yes" xml:space="preserve">
          <source>Note that since Kotlin 1.1 you can declare a delegated property inside a function or code block, it shouldn't necessarily be a member of a class. Below you can find &lt;a href=&quot;delegated-properties#local-delegated-properties-since-11&quot;&gt;the example&lt;/a&gt;.</source>
          <target state="translated">Kotlin 1.1以降では、委任されたプロパティを関数またはコードブロック内で宣言できるため、必ずしもクラスのメンバーである必要はありません。以下に&lt;a href=&quot;delegated-properties#local-delegated-properties-since-11&quot;&gt;例を示し&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="8f27fe847dccbaf44c3e83c0485bdf6be308f0d6" translate="yes" xml:space="preserve">
          <source>Note that smart casts do not work when the compiler cannot guarantee that the variable cannot change between the check and the usage. More specifically, smart casts are applicable according to the following rules:</source>
          <target state="translated">スマート・キャストは、チェックと使用の間に変数が変更されないことをコンパイラが保証できない場合には動作しないことに注意してください。具体的には、以下のルールに従ってスマートキャストが適用されます。</target>
        </trans-unit>
        <trans-unit id="8d16f91fe350efdfdab6da644c90340156b7ba22" translate="yes" xml:space="preserve">
          <source>Note that some Java visibilities such as package-private and protected (which also gives access to items from the same package) cannot be represented in Kotlin, so there's no &lt;a href=&quot;index&quot;&gt;KVisibility&lt;/a&gt; value corresponding to them.</source>
          <target state="translated">package-privateやprotected（同じパッケージのアイテムへのアクセスも提供する）などの一部のJava可視性は、Kotlinで表現できないため、それらに対応する&lt;a href=&quot;index&quot;&gt;KVisibility&lt;/a&gt;値がないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="1c295c01c9e6a32796148120ae2cf2ae77c47235" translate="yes" xml:space="preserve">
          <source>Note that some Java visibilities such as package-private and protected (which also gives access to items from the same package) cannot be represented in Kotlin, so there's no &lt;a href=&quot;index#kotlin.reflect.KVisibility&quot;&gt;KVisibility&lt;/a&gt; value corresponding to them.</source>
          <target state="translated">package-privateやprotected（同じパッケージのアイテムへのアクセスも可能にする）などの一部のJavaの可視性はKotlinで表現できないため、それらに対応する&lt;a href=&quot;index#kotlin.reflect.KVisibility&quot;&gt;KVisibility&lt;/a&gt;値がないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="a13526efa441f113eff7267561f09b5212747a9d" translate="yes" xml:space="preserve">
          <source>Note that some inline functions may call the lambdas passed to them as parameters not directly from the function body, but from another execution context, such as a local object or a nested function. In such cases, non-local control flow is also not allowed in the lambdas. To indicate that, the lambda parameter needs to be marked with the &lt;code&gt;crossinline&lt;/code&gt; modifier:</source>
          <target state="translated">一部のインライン関数は、関数本体から直接ではなく、ローカルオブジェクトやネストされた関数などの別の実行コンテキストからパラメーターとして渡されたラムダを呼び出す場合があることに注意してください。このような場合、ラムダでは非ローカル制御フローも許可されません。これを示すために、ラムダパラメータは &lt;code&gt;crossinline&lt;/code&gt; 修飾子でマークする必要があります。</target>
        </trans-unit>
        <trans-unit id="c7e376b19704536e280b87471b9d2f1935ff22e7" translate="yes" xml:space="preserve">
          <source>Note that some of the Kotlin/Native targets require an &lt;a href=&quot;#using-kotlinnative-targets&quot;&gt;appropriate host machine&lt;/a&gt; to build on.</source>
          <target state="translated">Kotlin /ネイティブターゲットの一部は、&lt;a href=&quot;#using-kotlinnative-targets&quot;&gt;適切なホストマシン&lt;/a&gt;を構築する必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="36013172d7bed76a773c2a3e7f523422dd3a224f" translate="yes" xml:space="preserve">
          <source>Note that sometimes channels may produce executions that look unfair due to the nature of the executor that is being used. See &lt;a href=&quot;https://github.com/Kotlin/kotlinx.coroutines/issues/111&quot;&gt;this issue&lt;/a&gt; for details.</source>
          <target state="translated">使用されているエグゼキューターの性質により、チャネルが不公平に見える実行を生成する場合があることに注意してください。詳細については、&lt;a href=&quot;https://github.com/Kotlin/kotlinx.coroutines/issues/111&quot;&gt;この問題&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="1c3b5c2f9f97ede3b692c00928df156ad477b585" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;../-string/index#kotlin.String&quot;&gt;String&lt;/a&gt; implementation of this interface in Kotlin/JS has unspecified behavior if the &lt;a href=&quot;get#kotlin.CharSequence%24get%28kotlin.Int%29%2Findex&quot;&gt;index&lt;/a&gt; is out of its bounds.</source>
          <target state="translated">&lt;a href=&quot;get#kotlin.CharSequence%24get%28kotlin.Int%29%2Findex&quot;&gt;インデックス&lt;/a&gt;が範囲外の場合、Kotlin / JSでのこのインターフェースの&lt;a href=&quot;../-string/index#kotlin.String&quot;&gt;String&lt;/a&gt;実装は不特定の動作をすることに注意してください。</target>
        </trans-unit>
        <trans-unit id="459ff0aa9d321691761e4a91e298d7fd73dfd1d5" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;../-string/index#kotlin.String&quot;&gt;String&lt;/a&gt; implementation of this interface in Kotlin/JS has unspecified behavior if the &lt;a href=&quot;get#kotlin.CharSequence%24get(kotlin.Int)/index&quot;&gt;index&lt;/a&gt; is out of its bounds.</source>
          <target state="translated">Kotlin / JSでのこのインターフェースの&lt;a href=&quot;../-string/index#kotlin.String&quot;&gt;String&lt;/a&gt;実装は、&lt;a href=&quot;get#kotlin.CharSequence%24get(kotlin.Int)/index&quot;&gt;インデックス&lt;/a&gt;が範囲外の場合、不特定の動作をすることに注意してください。</target>
        </trans-unit>
        <trans-unit id="656f0ee95d7b273c3b267aed0322b60e181f19cb" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;../../kotlin/-string/index#kotlin.String&quot;&gt;String&lt;/a&gt; implementation of this interface in Kotlin/JS has unspecified behavior if the &lt;a href=&quot;../../kotlin/-char-sequence/get#kotlin.CharSequence%24get%28kotlin.Int%29%2Findex&quot;&gt;index&lt;/a&gt; is out of its bounds.</source>
          <target state="translated">&lt;a href=&quot;../../kotlin/-char-sequence/get#kotlin.CharSequence%24get%28kotlin.Int%29%2Findex&quot;&gt;インデックス&lt;/a&gt;が範囲外の場合、Kotlin / JSでのこのインターフェースの&lt;a href=&quot;../../kotlin/-string/index#kotlin.String&quot;&gt;String&lt;/a&gt;実装は不特定の動作をすることに注意してください。</target>
        </trans-unit>
        <trans-unit id="86d97d17b217564ee55541f4e63de5ad16ee2c54" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;@DslMarker&lt;/code&gt; annotation is available only since Kotlin 1.1.</source>
          <target state="translated">&lt;code&gt;@DslMarker&lt;/code&gt; アノテーションはKotlin 1.1以降でのみ使用できることに注意してください。</target>
        </trans-unit>
        <trans-unit id="e7b3f809dbbb0b87e0e79d9712336f436e1ff493" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;componentN()&lt;/code&gt; functions need to be marked with the &lt;code&gt;operator&lt;/code&gt; keyword to allow using them in a destructuring declaration.</source>
          <target state="translated">構造化宣言でそれらを使用できるようにするには、 &lt;code&gt;componentN()&lt;/code&gt; 関数を &lt;code&gt;operator&lt;/code&gt; キーワードでマークする必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="4929a13b1b30f84a327018335edc5ac7a8c0ec7a" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;external&lt;/code&gt; modifier is inherited by nested declarations. This is why in the example &lt;code&gt;Node&lt;/code&gt; class, we do not need to add the &lt;code&gt;external&lt;/code&gt; modifier before member functions and properties.</source>
          <target state="translated">&lt;code&gt;external&lt;/code&gt; 修飾子はネストされた宣言によって継承されることに注意してください。これが、サンプルの &lt;code&gt;Node&lt;/code&gt; クラスで、メンバーの関数とプロパティの前に &lt;code&gt;external&lt;/code&gt; 修飾子を追加する必要がない理由です。</target>
        </trans-unit>
        <trans-unit id="d942ddfab9f982a7bff6988ad53e1b8f734657f3" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;kotlin-multiplaform&lt;/code&gt; plugin doesn't create any production binaries by default. The only binary available by default is a debug executable allowing one to run tests from the &lt;code&gt;test&lt;/code&gt; compilation.</source>
          <target state="translated">&lt;code&gt;kotlin-multiplaform&lt;/code&gt; プラグインは、デフォルトではプロダクションバイナリを作成しないことに注意してください。デフォルトで使用できる唯一のバイナリは、 &lt;code&gt;test&lt;/code&gt; コンパイルからテストを実行できるデバッグ実行可能ファイルです。</target>
        </trans-unit>
        <trans-unit id="c656240136213ce9805ea2877dde6b34a8442c1b" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;provideDelegate&lt;/code&gt; method affects only the creation of the auxiliary property and doesn't affect the code generated for getter or setter.</source>
          <target state="translated">&lt;code&gt;provideDelegate&lt;/code&gt; メソッドは補助プロパティの作成にのみ影響し、getterまたはsetter用に生成されたコードには影響しないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="eaabc3c1b973d9e58d5da5690136b6ca64e5f983" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;rem&lt;/code&gt; operator is supported since Kotlin 1.1. Kotlin 1.0 uses the &lt;code&gt;mod&lt;/code&gt; operator, which is deprecated in Kotlin 1.1.</source>
          <target state="translated">&lt;code&gt;rem&lt;/code&gt; 演算子はKotlin 1.1以降でサポートされていることに注意してください。Kotlin 1.0は、Kotlin 1.1で廃止された &lt;code&gt;mod&lt;/code&gt; 演算子を使用します。</target>
        </trans-unit>
        <trans-unit id="72e01dcbd71cc06e15070eae50092b4b7e9eed02" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;to&lt;/code&gt; notation creates a short-living &lt;code&gt;Pair&lt;/code&gt; object, so it's recommended that you use it only if performance isn't critical. To avoid excessive memory usage, use alternative ways. For example, you can create a mutable map and populate it using the write operations. The &lt;a href=&quot;scope-functions#apply&quot;&gt;&lt;code&gt;apply()&lt;/code&gt;&lt;/a&gt; function can help to keep the initialization fluent here.</source>
          <target state="translated">注こと &lt;code&gt;to&lt;/code&gt; 表記は、短い生活作成 &lt;code&gt;Pair&lt;/code&gt; あなたがパフォーマンスが重要でない場合にのみ、それを使用することをお勧めしますので、オブジェクトを。過度のメモリ使用を回避するには、別の方法を使用します。たとえば、変更可能なマップを作成し、書き込み操作を使用してそれを生成できます。&lt;a href=&quot;scope-functions#apply&quot;&gt; &lt;code&gt;apply()&lt;/code&gt; &lt;/a&gt;関数は、ここでは、初期化流暢を保つのを助けることができます。</target>
        </trans-unit>
        <trans-unit id="14f09727b2d752324269a0d82ae94535e1c1e4e5" translate="yes" xml:space="preserve">
          <source>Note that the String implementation of this interface in Kotlin/JS has unspecified behavior if the &lt;a href=&quot;../../kotlin/-char-sequence/get#kotlin.CharSequence%24get(kotlin.Int)/index&quot;&gt;index&lt;/a&gt; is out of its bounds.</source>
          <target state="translated">Kotlin / JSでのこのインターフェースのString実装は、&lt;a href=&quot;../../kotlin/-char-sequence/get#kotlin.CharSequence%24get(kotlin.Int)/index&quot;&gt;インデックス&lt;/a&gt;が範囲外の場合、不特定の動作をすることに注意してください。</target>
        </trans-unit>
        <trans-unit id="ae0cdfd1c642695da1e12ec7f632f89942b6add0" translate="yes" xml:space="preserve">
          <source>Note that the char sequence passed to the &lt;a href=&quot;chunked#kotlin.text%24chunked%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.CharSequence%2C+kotlin.text.chunked.R%29%29%29%2Ftransform&quot;&gt;transform&lt;/a&gt; function is ephemeral and is valid only inside that function. You should not store it or allow it to escape in some way, unless you made a snapshot of it. The last char sequence may have less characters than the given &lt;a href=&quot;chunked#kotlin.text%24chunked%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.CharSequence%2C+kotlin.text.chunked.R%29%29%29%2Fsize&quot;&gt;size&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;chunked#kotlin.text%24chunked%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.CharSequence%2C+kotlin.text.chunked.R%29%29%29%2Ftransform&quot;&gt;変換&lt;/a&gt;関数に渡される文字シーケンスは一時的なものであり、その関数内でのみ有効であることに注意してください。スナップショットを作成しない限り、保存したり、何らかの方法でエスケープさせたりしないでください。最後の文字シーケンスは、指定&lt;a href=&quot;chunked#kotlin.text%24chunked%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.CharSequence%2C+kotlin.text.chunked.R%29%29%29%2Fsize&quot;&gt;さ&lt;/a&gt;れたサイズよりも文字数が少ない場合があります。</target>
        </trans-unit>
        <trans-unit id="cd01abddf25872ce916797664b86dae36d2cc1ac" translate="yes" xml:space="preserve">
          <source>Note that the char sequence passed to the &lt;a href=&quot;chunked#kotlin.text%24chunked(kotlin.CharSequence,%20kotlin.Int,%20kotlin.Function1((kotlin.CharSequence,%20kotlin.text.chunked.R)))/transform&quot;&gt;transform&lt;/a&gt; function is ephemeral and is valid only inside that function. You should not store it or allow it to escape in some way, unless you made a snapshot of it. The last char sequence may have less characters than the given &lt;a href=&quot;chunked#kotlin.text%24chunked(kotlin.CharSequence,%20kotlin.Int,%20kotlin.Function1((kotlin.CharSequence,%20kotlin.text.chunked.R)))/size&quot;&gt;size&lt;/a&gt;.</source>
          <target state="translated">Note that the char sequence passed to the &lt;a href=&quot;chunked#kotlin.text%24chunked(kotlin.CharSequence,%20kotlin.Int,%20kotlin.Function1((kotlin.CharSequence,%20kotlin.text.chunked.R)))/transform&quot;&gt;transform&lt;/a&gt; function is ephemeral and is valid only inside that function. You should not store it or allow it to escape in some way, unless you made a snapshot of it. The last char sequence may have less characters than the given &lt;a href=&quot;chunked#kotlin.text%24chunked(kotlin.CharSequence,%20kotlin.Int,%20kotlin.Function1((kotlin.CharSequence,%20kotlin.text.chunked.R)))/size&quot;&gt;size&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="691b0c57806763a4b2bdecce9c41e605803c5ebe" translate="yes" xml:space="preserve">
          <source>Note that the char sequence passed to the &lt;a href=&quot;chunked-sequence#kotlin.text%24chunkedSequence%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.CharSequence%2C+kotlin.text.chunkedSequence.R%29%29%29%2Ftransform&quot;&gt;transform&lt;/a&gt; function is ephemeral and is valid only inside that function. You should not store it or allow it to escape in some way, unless you made a snapshot of it. The last char sequence may have less characters than the given &lt;a href=&quot;chunked-sequence#kotlin.text%24chunkedSequence%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.CharSequence%2C+kotlin.text.chunkedSequence.R%29%29%29%2Fsize&quot;&gt;size&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;chunked-sequence#kotlin.text%24chunkedSequence%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.CharSequence%2C+kotlin.text.chunkedSequence.R%29%29%29%2Ftransform&quot;&gt;変換&lt;/a&gt;関数に渡される文字シーケンスは一時的なものであり、その関数内でのみ有効であることに注意してください。スナップショットを作成しない限り、保存したり、何らかの方法でエスケープさせたりしないでください。最後の文字シーケンスは、指定&lt;a href=&quot;chunked-sequence#kotlin.text%24chunkedSequence%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.CharSequence%2C+kotlin.text.chunkedSequence.R%29%29%29%2Fsize&quot;&gt;さ&lt;/a&gt;れたサイズよりも文字数が少ない場合があります。</target>
        </trans-unit>
        <trans-unit id="66c2ad296d8e177430bc0fa68ba7b9eb97117778" translate="yes" xml:space="preserve">
          <source>Note that the char sequence passed to the &lt;a href=&quot;chunked-sequence#kotlin.text%24chunkedSequence(kotlin.CharSequence,%20kotlin.Int,%20kotlin.Function1((kotlin.CharSequence,%20kotlin.text.chunkedSequence.R)))/transform&quot;&gt;transform&lt;/a&gt; function is ephemeral and is valid only inside that function. You should not store it or allow it to escape in some way, unless you made a snapshot of it. The last char sequence may have less characters than the given &lt;a href=&quot;chunked-sequence#kotlin.text%24chunkedSequence(kotlin.CharSequence,%20kotlin.Int,%20kotlin.Function1((kotlin.CharSequence,%20kotlin.text.chunkedSequence.R)))/size&quot;&gt;size&lt;/a&gt;.</source>
          <target state="translated">Note that the char sequence passed to the &lt;a href=&quot;chunked-sequence#kotlin.text%24chunkedSequence(kotlin.CharSequence,%20kotlin.Int,%20kotlin.Function1((kotlin.CharSequence,%20kotlin.text.chunkedSequence.R)))/transform&quot;&gt;transform&lt;/a&gt; function is ephemeral and is valid only inside that function. You should not store it or allow it to escape in some way, unless you made a snapshot of it. The last char sequence may have less characters than the given &lt;a href=&quot;chunked-sequence#kotlin.text%24chunkedSequence(kotlin.CharSequence,%20kotlin.Int,%20kotlin.Function1((kotlin.CharSequence,%20kotlin.text.chunkedSequence.R)))/size&quot;&gt;size&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="1754418c79853b8c6ec574fcc023dbf40a7d737e" translate="yes" xml:space="preserve">
          <source>Note that the char sequence passed to the &lt;a href=&quot;windowed#kotlin.text%24windowed%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Boolean%2C+kotlin.Function1%28%28kotlin.CharSequence%2C+kotlin.text.windowed.R%29%29%29%2Ftransform&quot;&gt;transform&lt;/a&gt; function is ephemeral and is valid only inside that function. You should not store it or allow it to escape in some way, unless you made a snapshot of it. Several last char sequences may have less characters than the given &lt;a href=&quot;windowed#kotlin.text%24windowed%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Boolean%2C+kotlin.Function1%28%28kotlin.CharSequence%2C+kotlin.text.windowed.R%29%29%29%2Fsize&quot;&gt;size&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;windowed#kotlin.text%24windowed%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Boolean%2C+kotlin.Function1%28%28kotlin.CharSequence%2C+kotlin.text.windowed.R%29%29%29%2Ftransform&quot;&gt;変換&lt;/a&gt;関数に渡される文字シーケンスは一時的なものであり、その関数内でのみ有効であることに注意してください。スナップショットを作成しない限り、保存したり、何らかの方法でエスケープさせたりしないでください。最後のいくつかの文字シーケンスは、指定&lt;a href=&quot;windowed#kotlin.text%24windowed%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Boolean%2C+kotlin.Function1%28%28kotlin.CharSequence%2C+kotlin.text.windowed.R%29%29%29%2Fsize&quot;&gt;さ&lt;/a&gt;れたサイズよりも文字数が少ない場合があります。</target>
        </trans-unit>
        <trans-unit id="8a3008d758022d0b209de4899387968b8ac78ed4" translate="yes" xml:space="preserve">
          <source>Note that the char sequence passed to the &lt;a href=&quot;windowed#kotlin.text%24windowed(kotlin.CharSequence,%20kotlin.Int,%20kotlin.Int,%20kotlin.Boolean,%20kotlin.Function1((kotlin.CharSequence,%20kotlin.text.windowed.R)))/transform&quot;&gt;transform&lt;/a&gt; function is ephemeral and is valid only inside that function. You should not store it or allow it to escape in some way, unless you made a snapshot of it. Several last char sequences may have less characters than the given &lt;a href=&quot;windowed#kotlin.text%24windowed(kotlin.CharSequence,%20kotlin.Int,%20kotlin.Int,%20kotlin.Boolean,%20kotlin.Function1((kotlin.CharSequence,%20kotlin.text.windowed.R)))/size&quot;&gt;size&lt;/a&gt;.</source>
          <target state="translated">Note that the char sequence passed to the &lt;a href=&quot;windowed#kotlin.text%24windowed(kotlin.CharSequence,%20kotlin.Int,%20kotlin.Int,%20kotlin.Boolean,%20kotlin.Function1((kotlin.CharSequence,%20kotlin.text.windowed.R)))/transform&quot;&gt;transform&lt;/a&gt; function is ephemeral and is valid only inside that function. You should not store it or allow it to escape in some way, unless you made a snapshot of it. Several last char sequences may have less characters than the given &lt;a href=&quot;windowed#kotlin.text%24windowed(kotlin.CharSequence,%20kotlin.Int,%20kotlin.Int,%20kotlin.Boolean,%20kotlin.Function1((kotlin.CharSequence,%20kotlin.text.windowed.R)))/size&quot;&gt;size&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="266d21f640d721c4dd41a4ded8abb4f2b56ec11c" translate="yes" xml:space="preserve">
          <source>Note that the char sequence passed to the &lt;a href=&quot;windowed-sequence#kotlin.text%24windowedSequence%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Boolean%2C+kotlin.Function1%28%28kotlin.CharSequence%2C+kotlin.text.windowedSequence.R%29%29%29%2Ftransform&quot;&gt;transform&lt;/a&gt; function is ephemeral and is valid only inside that function. You should not store it or allow it to escape in some way, unless you made a snapshot of it. Several last char sequences may have less characters than the given &lt;a href=&quot;windowed-sequence#kotlin.text%24windowedSequence%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Boolean%2C+kotlin.Function1%28%28kotlin.CharSequence%2C+kotlin.text.windowedSequence.R%29%29%29%2Fsize&quot;&gt;size&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;windowed-sequence#kotlin.text%24windowedSequence%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Boolean%2C+kotlin.Function1%28%28kotlin.CharSequence%2C+kotlin.text.windowedSequence.R%29%29%29%2Ftransform&quot;&gt;変換&lt;/a&gt;関数に渡される文字シーケンスは一時的なものであり、その関数内でのみ有効であることに注意してください。スナップショットを作成しない限り、保存したり、何らかの方法でエスケープさせたりしないでください。最後のいくつかの文字シーケンスは、指定&lt;a href=&quot;windowed-sequence#kotlin.text%24windowedSequence%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Boolean%2C+kotlin.Function1%28%28kotlin.CharSequence%2C+kotlin.text.windowedSequence.R%29%29%29%2Fsize&quot;&gt;さ&lt;/a&gt;れたサイズよりも文字数が少ない場合があります。</target>
        </trans-unit>
        <trans-unit id="e51326b0cfaf636fb6a7d19970d3f5dc2bf4c4ac" translate="yes" xml:space="preserve">
          <source>Note that the char sequence passed to the &lt;a href=&quot;windowed-sequence#kotlin.text%24windowedSequence(kotlin.CharSequence,%20kotlin.Int,%20kotlin.Int,%20kotlin.Boolean,%20kotlin.Function1((kotlin.CharSequence,%20kotlin.text.windowedSequence.R)))/transform&quot;&gt;transform&lt;/a&gt; function is ephemeral and is valid only inside that function. You should not store it or allow it to escape in some way, unless you made a snapshot of it. Several last char sequences may have less characters than the given &lt;a href=&quot;windowed-sequence#kotlin.text%24windowedSequence(kotlin.CharSequence,%20kotlin.Int,%20kotlin.Int,%20kotlin.Boolean,%20kotlin.Function1((kotlin.CharSequence,%20kotlin.text.windowedSequence.R)))/size&quot;&gt;size&lt;/a&gt;.</source>
          <target state="translated">Note that the char sequence passed to the &lt;a href=&quot;windowed-sequence#kotlin.text%24windowedSequence(kotlin.CharSequence,%20kotlin.Int,%20kotlin.Int,%20kotlin.Boolean,%20kotlin.Function1((kotlin.CharSequence,%20kotlin.text.windowedSequence.R)))/transform&quot;&gt;transform&lt;/a&gt; function is ephemeral and is valid only inside that function. You should not store it or allow it to escape in some way, unless you made a snapshot of it. Several last char sequences may have less characters than the given &lt;a href=&quot;windowed-sequence#kotlin.text%24windowedSequence(kotlin.CharSequence,%20kotlin.Int,%20kotlin.Int,%20kotlin.Boolean,%20kotlin.Function1((kotlin.CharSequence,%20kotlin.text.windowedSequence.R)))/size&quot;&gt;size&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="eeca19ffbd81bf7218d5ce25611e87d001f58db2" translate="yes" xml:space="preserve">
          <source>Note that the compiler only uses the properties defined inside the primary constructor for the automatically generated functions. To exclude a property from the generated implementations, declare it inside the class body:</source>
          <target state="translated">コンパイラは、自動的に生成される関数のプライマリ・コンストラクタ内で定義されたプロパティのみを使用することに注意してください。生成される実装からプロパティを除外するには、クラス本体内で宣言します。</target>
        </trans-unit>
        <trans-unit id="29a5989520a2bf8fd601f2d782fa7b5f4d18221d" translate="yes" xml:space="preserve">
          <source>Note that the content of &lt;code&gt;platform.posix&lt;/code&gt; is NOT identical on different platforms, in the same way as different &lt;code&gt;POSIX&lt;/code&gt; implementations are a little different.</source>
          <target state="translated">&lt;code&gt;platform.posix&lt;/code&gt; の内容は、異なる &lt;code&gt;POSIX&lt;/code&gt; 実装が少し異なるのと同じように、異なるプラットフォームでは同一ではないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="6e0ba2d2cb4d8f4a9dbc1b85a017969941095acd" translate="yes" xml:space="preserve">
          <source>Note that the databinding expression language uses the same syntax for referring to properties as Kotlin: &lt;code&gt;data.imageUrl&lt;/code&gt;. In Kotlin you can write &lt;code&gt;v.prop&lt;/code&gt; instead of &lt;code&gt;v.getProp()&lt;/code&gt; even if &lt;code&gt;getProp()&lt;/code&gt; is a Java method. Similarly, instead of calling a setter directly, you may use an assignment:</source>
          <target state="translated">データバインディング式言語は、プロパティを参照するためにKotlinと同じ構文を使用することに注意してください： &lt;code&gt;data.imageUrl&lt;/code&gt; 。Kotlinでは、書くことができます &lt;code&gt;v.prop&lt;/code&gt; 代わりの &lt;code&gt;v.getProp()&lt;/code&gt; 場合でも &lt;code&gt;getProp()&lt;/code&gt; Javaメソッドです。同様に、セッターを直接呼び出す代わりに、割り当てを使用できます。</target>
        </trans-unit>
        <trans-unit id="e38cb3723f44256fc4af27d394f0da73badd7310" translate="yes" xml:space="preserve">
          <source>Note that the first build isn't incremental in any case.</source>
          <target state="translated">最初のビルドはいずれにしてもインクリメンタルではないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="3539b1a59eaf5408904eb51b677999543b8a5f8e" translate="yes" xml:space="preserve">
          <source>Note that the list passed to the &lt;a href=&quot;chunked#kotlin.collections%24chunked%28kotlin.collections.Iterable%28%28kotlin.collections.chunked.T%29%29%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.collections.List%28%28kotlin.collections.chunked.T%29%29%2C+kotlin.collections.chunked.R%29%29%29%2Ftransform&quot;&gt;transform&lt;/a&gt; function is ephemeral and is valid only inside that function. You should not store it or allow it to escape in some way, unless you made a snapshot of it. The last list may have less elements than the given &lt;a href=&quot;chunked#kotlin.collections%24chunked%28kotlin.collections.Iterable%28%28kotlin.collections.chunked.T%29%29%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.collections.List%28%28kotlin.collections.chunked.T%29%29%2C+kotlin.collections.chunked.R%29%29%29%2Fsize&quot;&gt;size&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;chunked#kotlin.collections%24chunked%28kotlin.collections.Iterable%28%28kotlin.collections.chunked.T%29%29%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.collections.List%28%28kotlin.collections.chunked.T%29%29%2C+kotlin.collections.chunked.R%29%29%29%2Ftransform&quot;&gt;変換&lt;/a&gt;関数に渡されるリストは一時的なものであり、その関数内でのみ有効であることに注意してください。スナップショットを作成しない限り、保存したり、何らかの方法でエスケープさせたりしないでください。最後のリストは、指定&lt;a href=&quot;chunked#kotlin.collections%24chunked%28kotlin.collections.Iterable%28%28kotlin.collections.chunked.T%29%29%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.collections.List%28%28kotlin.collections.chunked.T%29%29%2C+kotlin.collections.chunked.R%29%29%29%2Fsize&quot;&gt;さ&lt;/a&gt;れたサイズよりも要素が少ない場合があります。</target>
        </trans-unit>
        <trans-unit id="36bd5508df864c7458e1fccd9c81158cc477d507" translate="yes" xml:space="preserve">
          <source>Note that the list passed to the &lt;a href=&quot;chunked#kotlin.collections%24chunked(kotlin.collections.Iterable((kotlin.collections.chunked.T)),%20kotlin.Int,%20kotlin.Function1((kotlin.collections.List((kotlin.collections.chunked.T)),%20kotlin.collections.chunked.R)))/transform&quot;&gt;transform&lt;/a&gt; function is ephemeral and is valid only inside that function. You should not store it or allow it to escape in some way, unless you made a snapshot of it. The last list may have less elements than the given &lt;a href=&quot;chunked#kotlin.collections%24chunked(kotlin.collections.Iterable((kotlin.collections.chunked.T)),%20kotlin.Int,%20kotlin.Function1((kotlin.collections.List((kotlin.collections.chunked.T)),%20kotlin.collections.chunked.R)))/size&quot;&gt;size&lt;/a&gt;.</source>
          <target state="translated">Note that the list passed to the &lt;a href=&quot;chunked#kotlin.collections%24chunked(kotlin.collections.Iterable((kotlin.collections.chunked.T)),%20kotlin.Int,%20kotlin.Function1((kotlin.collections.List((kotlin.collections.chunked.T)),%20kotlin.collections.chunked.R)))/transform&quot;&gt;transform&lt;/a&gt; function is ephemeral and is valid only inside that function. You should not store it or allow it to escape in some way, unless you made a snapshot of it. The last list may have less elements than the given &lt;a href=&quot;chunked#kotlin.collections%24chunked(kotlin.collections.Iterable((kotlin.collections.chunked.T)),%20kotlin.Int,%20kotlin.Function1((kotlin.collections.List((kotlin.collections.chunked.T)),%20kotlin.collections.chunked.R)))/size&quot;&gt;size&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="7d6ec3f60ea3d3f0e1450f4fd127d92b3dabc464" translate="yes" xml:space="preserve">
          <source>Note that the list passed to the &lt;a href=&quot;chunked#kotlin.sequences%24chunked%28kotlin.sequences.Sequence%28%28kotlin.sequences.chunked.T%29%29%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.collections.List%28%28kotlin.sequences.chunked.T%29%29%2C+kotlin.sequences.chunked.R%29%29%29%2Ftransform&quot;&gt;transform&lt;/a&gt; function is ephemeral and is valid only inside that function. You should not store it or allow it to escape in some way, unless you made a snapshot of it. The last list may have less elements than the given &lt;a href=&quot;chunked#kotlin.sequences%24chunked%28kotlin.sequences.Sequence%28%28kotlin.sequences.chunked.T%29%29%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.collections.List%28%28kotlin.sequences.chunked.T%29%29%2C+kotlin.sequences.chunked.R%29%29%29%2Fsize&quot;&gt;size&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;chunked#kotlin.sequences%24chunked%28kotlin.sequences.Sequence%28%28kotlin.sequences.chunked.T%29%29%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.collections.List%28%28kotlin.sequences.chunked.T%29%29%2C+kotlin.sequences.chunked.R%29%29%29%2Ftransform&quot;&gt;変換&lt;/a&gt;関数に渡されるリストは一時的なものであり、その関数内でのみ有効であることに注意してください。スナップショットを作成しない限り、保存したり、何らかの方法でエスケープさせたりしないでください。最後のリストは、指定&lt;a href=&quot;chunked#kotlin.sequences%24chunked%28kotlin.sequences.Sequence%28%28kotlin.sequences.chunked.T%29%29%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.collections.List%28%28kotlin.sequences.chunked.T%29%29%2C+kotlin.sequences.chunked.R%29%29%29%2Fsize&quot;&gt;さ&lt;/a&gt;れたサイズよりも要素が少ない場合があります。</target>
        </trans-unit>
        <trans-unit id="b4dd0c4a7944c546ed18e9237812f399b9a75bb2" translate="yes" xml:space="preserve">
          <source>Note that the list passed to the &lt;a href=&quot;chunked#kotlin.sequences%24chunked(kotlin.sequences.Sequence((kotlin.sequences.chunked.T)),%20kotlin.Int,%20kotlin.Function1((kotlin.collections.List((kotlin.sequences.chunked.T)),%20kotlin.sequences.chunked.R)))/transform&quot;&gt;transform&lt;/a&gt; function is ephemeral and is valid only inside that function. You should not store it or allow it to escape in some way, unless you made a snapshot of it. The last list may have less elements than the given &lt;a href=&quot;chunked#kotlin.sequences%24chunked(kotlin.sequences.Sequence((kotlin.sequences.chunked.T)),%20kotlin.Int,%20kotlin.Function1((kotlin.collections.List((kotlin.sequences.chunked.T)),%20kotlin.sequences.chunked.R)))/size&quot;&gt;size&lt;/a&gt;.</source>
          <target state="translated">Note that the list passed to the &lt;a href=&quot;chunked#kotlin.sequences%24chunked(kotlin.sequences.Sequence((kotlin.sequences.chunked.T)),%20kotlin.Int,%20kotlin.Function1((kotlin.collections.List((kotlin.sequences.chunked.T)),%20kotlin.sequences.chunked.R)))/transform&quot;&gt;transform&lt;/a&gt; function is ephemeral and is valid only inside that function. You should not store it or allow it to escape in some way, unless you made a snapshot of it. The last list may have less elements than the given &lt;a href=&quot;chunked#kotlin.sequences%24chunked(kotlin.sequences.Sequence((kotlin.sequences.chunked.T)),%20kotlin.Int,%20kotlin.Function1((kotlin.collections.List((kotlin.sequences.chunked.T)),%20kotlin.sequences.chunked.R)))/size&quot;&gt;size&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="a0c9e1743347f1aa8d11316573c39fab1f4d2b86" translate="yes" xml:space="preserve">
          <source>Note that the list passed to the &lt;a href=&quot;windowed#kotlin.collections%24windowed%28kotlin.collections.Iterable%28%28kotlin.collections.windowed.T%29%29%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Boolean%2C+kotlin.Function1%28%28kotlin.collections.List%28%28kotlin.collections.windowed.T%29%29%2C+kotlin.collections.windowed.R%29%29%29%2Ftransform&quot;&gt;transform&lt;/a&gt; function is ephemeral and is valid only inside that function. You should not store it or allow it to escape in some way, unless you made a snapshot of it. Several last lists may have less elements than the given &lt;a href=&quot;windowed#kotlin.collections%24windowed%28kotlin.collections.Iterable%28%28kotlin.collections.windowed.T%29%29%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Boolean%2C+kotlin.Function1%28%28kotlin.collections.List%28%28kotlin.collections.windowed.T%29%29%2C+kotlin.collections.windowed.R%29%29%29%2Fsize&quot;&gt;size&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;windowed#kotlin.collections%24windowed%28kotlin.collections.Iterable%28%28kotlin.collections.windowed.T%29%29%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Boolean%2C+kotlin.Function1%28%28kotlin.collections.List%28%28kotlin.collections.windowed.T%29%29%2C+kotlin.collections.windowed.R%29%29%29%2Ftransform&quot;&gt;変換&lt;/a&gt;関数に渡されるリストは一時的なものであり、その関数内でのみ有効であることに注意してください。スナップショットを作成しない限り、保存したり、何らかの方法でエスケープさせたりしないでください。最後のいくつかのリストは、指定&lt;a href=&quot;windowed#kotlin.collections%24windowed%28kotlin.collections.Iterable%28%28kotlin.collections.windowed.T%29%29%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Boolean%2C+kotlin.Function1%28%28kotlin.collections.List%28%28kotlin.collections.windowed.T%29%29%2C+kotlin.collections.windowed.R%29%29%29%2Fsize&quot;&gt;さ&lt;/a&gt;れたサイズよりも要素が少ない場合があります。</target>
        </trans-unit>
        <trans-unit id="fccc14666a62fb388999ea11066179edff1c4d5e" translate="yes" xml:space="preserve">
          <source>Note that the list passed to the &lt;a href=&quot;windowed#kotlin.collections%24windowed(kotlin.collections.Iterable((kotlin.collections.windowed.T)),%20kotlin.Int,%20kotlin.Int,%20kotlin.Boolean,%20kotlin.Function1((kotlin.collections.List((kotlin.collections.windowed.T)),%20kotlin.collections.windowed.R)))/transform&quot;&gt;transform&lt;/a&gt; function is ephemeral and is valid only inside that function. You should not store it or allow it to escape in some way, unless you made a snapshot of it. Several last lists may have less elements than the given &lt;a href=&quot;windowed#kotlin.collections%24windowed(kotlin.collections.Iterable((kotlin.collections.windowed.T)),%20kotlin.Int,%20kotlin.Int,%20kotlin.Boolean,%20kotlin.Function1((kotlin.collections.List((kotlin.collections.windowed.T)),%20kotlin.collections.windowed.R)))/size&quot;&gt;size&lt;/a&gt;.</source>
          <target state="translated">Note that the list passed to the &lt;a href=&quot;windowed#kotlin.collections%24windowed(kotlin.collections.Iterable((kotlin.collections.windowed.T)),%20kotlin.Int,%20kotlin.Int,%20kotlin.Boolean,%20kotlin.Function1((kotlin.collections.List((kotlin.collections.windowed.T)),%20kotlin.collections.windowed.R)))/transform&quot;&gt;transform&lt;/a&gt; function is ephemeral and is valid only inside that function. You should not store it or allow it to escape in some way, unless you made a snapshot of it. Several last lists may have less elements than the given &lt;a href=&quot;windowed#kotlin.collections%24windowed(kotlin.collections.Iterable((kotlin.collections.windowed.T)),%20kotlin.Int,%20kotlin.Int,%20kotlin.Boolean,%20kotlin.Function1((kotlin.collections.List((kotlin.collections.windowed.T)),%20kotlin.collections.windowed.R)))/size&quot;&gt;size&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="b9a01e230c14a996ac73932af98798f763d520bb" translate="yes" xml:space="preserve">
          <source>Note that the list passed to the &lt;a href=&quot;windowed#kotlin.sequences%24windowed%28kotlin.sequences.Sequence%28%28kotlin.sequences.windowed.T%29%29%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Boolean%2C+kotlin.Function1%28%28kotlin.collections.List%28%28kotlin.sequences.windowed.T%29%29%2C+kotlin.sequences.windowed.R%29%29%29%2Ftransform&quot;&gt;transform&lt;/a&gt; function is ephemeral and is valid only inside that function. You should not store it or allow it to escape in some way, unless you made a snapshot of it. Several last lists may have less elements than the given &lt;a href=&quot;windowed#kotlin.sequences%24windowed%28kotlin.sequences.Sequence%28%28kotlin.sequences.windowed.T%29%29%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Boolean%2C+kotlin.Function1%28%28kotlin.collections.List%28%28kotlin.sequences.windowed.T%29%29%2C+kotlin.sequences.windowed.R%29%29%29%2Fsize&quot;&gt;size&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;windowed#kotlin.sequences%24windowed%28kotlin.sequences.Sequence%28%28kotlin.sequences.windowed.T%29%29%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Boolean%2C+kotlin.Function1%28%28kotlin.collections.List%28%28kotlin.sequences.windowed.T%29%29%2C+kotlin.sequences.windowed.R%29%29%29%2Ftransform&quot;&gt;変換&lt;/a&gt;関数に渡されるリストは一時的なものであり、その関数内でのみ有効であることに注意してください。スナップショットを作成しない限り、保存したり、何らかの方法でエスケープさせたりしないでください。最後のいくつかのリストは、指定&lt;a href=&quot;windowed#kotlin.sequences%24windowed%28kotlin.sequences.Sequence%28%28kotlin.sequences.windowed.T%29%29%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Boolean%2C+kotlin.Function1%28%28kotlin.collections.List%28%28kotlin.sequences.windowed.T%29%29%2C+kotlin.sequences.windowed.R%29%29%29%2Fsize&quot;&gt;さ&lt;/a&gt;れたサイズよりも要素が少ない場合があります。</target>
        </trans-unit>
        <trans-unit id="01be197fd2cc3bdf986de65122c65771b937478d" translate="yes" xml:space="preserve">
          <source>Note that the list passed to the &lt;a href=&quot;windowed#kotlin.sequences%24windowed(kotlin.sequences.Sequence((kotlin.sequences.windowed.T)),%20kotlin.Int,%20kotlin.Int,%20kotlin.Boolean,%20kotlin.Function1((kotlin.collections.List((kotlin.sequences.windowed.T)),%20kotlin.sequences.windowed.R)))/transform&quot;&gt;transform&lt;/a&gt; function is ephemeral and is valid only inside that function. You should not store it or allow it to escape in some way, unless you made a snapshot of it. Several last lists may have less elements than the given &lt;a href=&quot;windowed#kotlin.sequences%24windowed(kotlin.sequences.Sequence((kotlin.sequences.windowed.T)),%20kotlin.Int,%20kotlin.Int,%20kotlin.Boolean,%20kotlin.Function1((kotlin.collections.List((kotlin.sequences.windowed.T)),%20kotlin.sequences.windowed.R)))/size&quot;&gt;size&lt;/a&gt;.</source>
          <target state="translated">Note that the list passed to the &lt;a href=&quot;windowed#kotlin.sequences%24windowed(kotlin.sequences.Sequence((kotlin.sequences.windowed.T)),%20kotlin.Int,%20kotlin.Int,%20kotlin.Boolean,%20kotlin.Function1((kotlin.collections.List((kotlin.sequences.windowed.T)),%20kotlin.sequences.windowed.R)))/transform&quot;&gt;transform&lt;/a&gt; function is ephemeral and is valid only inside that function. You should not store it or allow it to escape in some way, unless you made a snapshot of it. Several last lists may have less elements than the given &lt;a href=&quot;windowed#kotlin.sequences%24windowed(kotlin.sequences.Sequence((kotlin.sequences.windowed.T)),%20kotlin.Int,%20kotlin.Int,%20kotlin.Boolean,%20kotlin.Function1((kotlin.collections.List((kotlin.sequences.windowed.T)),%20kotlin.sequences.windowed.R)))/size&quot;&gt;size&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="d6259e89a9a4c0b547dbd66ff1bea24b671ef991" translate="yes" xml:space="preserve">
          <source>Note that the module metadata published by Gradle 5.3 and above cannot be read by Gradle versions older than 5.3.</source>
          <target state="translated">Gradle 5.3以上で公開されているモジュールのメタデータは、5.3より古いバージョンのGradleでは読み取れないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="289248f23bcb06f8e447242c0fc575e0c1a20430" translate="yes" xml:space="preserve">
          <source>Note that the named argument syntax cannot be used when calling Java functions, because Java bytecode does not always preserve names of function parameters.</source>
          <target state="translated">Javaバイトコードは常に関数パラメータの名前を保持しているとは限らないため、Java関数を呼び出す際に名前付き引数構文を使用することはできないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="7b39b5b0c66187e76139e4031731bcf6a323f589" translate="yes" xml:space="preserve">
          <source>Note that the operation is not guaranteed to be atomic if the map is being modified concurrently.</source>
          <target state="translated">マップが同時に変更されている場合、操作がアトミックであることは保証されないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="f1adf6c7e534562475c3f5e5643436265ce9a453" translate="yes" xml:space="preserve">
          <source>Note that the opposite reversed translation is not implemented yet: Swift/Objective-C error-throwing methods aren't imported to Kotlin as exception-throwing.</source>
          <target state="translated">逆の逆変換はまだ実装されていないので注意してください。Swift/Objective-Cのエラースローイングメソッドは例外スローイングとしてKotlinにはインポートされません。</target>
        </trans-unit>
        <trans-unit id="13e4f5805154eec53798d94ef883500f35ad56a4" translate="yes" xml:space="preserve">
          <source>Note that the other uses of curly braces in Kotlin, such as in function and class definitions and after &lt;code&gt;if&lt;/code&gt;/&lt;code&gt;else&lt;/code&gt;/&lt;code&gt;for&lt;/code&gt;/&lt;code&gt;while&lt;/code&gt; statements, are not lambda expressions (so it is &lt;em&gt;not&lt;/em&gt; the case that &lt;code&gt;if&lt;/code&gt; is a function that conditionally executes a lambda function).</source>
          <target state="translated">このような機能やクラス定義のようKotlinに中括弧の他の用途および後ことに留意されたい &lt;code&gt;if&lt;/code&gt; / &lt;code&gt;else&lt;/code&gt; / &lt;code&gt;for&lt;/code&gt; / &lt;code&gt;while&lt;/code&gt; 文、ラムダ式ではない（それがあるよう&lt;em&gt;ではない&lt;/em&gt;ことが場合 &lt;code&gt;if&lt;/code&gt; 条件付きラムダを実行する機能であります関数）。</target>
        </trans-unit>
        <trans-unit id="29cdb0fff079bd2313b913b84a243b2ced642967" translate="yes" xml:space="preserve">
          <source>Note that the returned instance uses itself to synchronize on. Do not synchronize from external code on the returned instance as it may cause accidental deadlock. Also this behavior can be changed in the future.</source>
          <target state="translated">返されたインスタンスは自分自身を使用して同期することに注意してください。誤ってデッドロックを起こす可能性があるので、返されたインスタンス上で外部コードから同期しないようにしてください。また、この動作は将来的に変更することができます。</target>
        </trans-unit>
        <trans-unit id="ab68d93b5c9158ca99b7d3217cfebeb0bc1dbe0f" translate="yes" xml:space="preserve">
          <source>Note that the reverse operation may produce new surrogate pairs that were unpaired low-surrogates and high-surrogates before the operation. For example, reversing &lt;code&gt;&quot;\uDC00\uD800&quot;&lt;/code&gt; produces &lt;code&gt;&quot;\uD800\uDC00&quot;&lt;/code&gt; which is a valid surrogate pair.</source>
          <target state="translated">Note that the reverse operation may produce new surrogate pairs that were unpaired low-surrogates and high-surrogates before the operation. For example, reversing &lt;code&gt;&quot;\uDC00\uD800&quot;&lt;/code&gt; produces &lt;code&gt;&quot;\uD800\uDC00&quot;&lt;/code&gt; which is a valid surrogate pair.</target>
        </trans-unit>
        <trans-unit id="99bb4d1e09ed7e1f3f7c48bd69bd7281f7032077" translate="yes" xml:space="preserve">
          <source>Note that the source sequence and the array being added are iterated only when an &lt;code&gt;iterator&lt;/code&gt; is requested from the resulting sequence. Changing any of them between successive calls to &lt;code&gt;iterator&lt;/code&gt; may affect the result.</source>
          <target state="translated">追加されるソースシーケンスと配列は、結果のシーケンスから &lt;code&gt;iterator&lt;/code&gt; が要求された場合にのみ反復されることに注意してください。 &lt;code&gt;iterator&lt;/code&gt; 連続する呼び出し間でそれらのいずれかを変更すると、結果に影響を与える可能性があります。</target>
        </trans-unit>
        <trans-unit id="4bc2850950af5238d132e57cd0616b073acff952" translate="yes" xml:space="preserve">
          <source>Note that the source sequence and the array being subtracted are iterated only when an &lt;code&gt;iterator&lt;/code&gt; is requested from the resulting sequence. Changing any of them between successive calls to &lt;code&gt;iterator&lt;/code&gt; may affect the result.</source>
          <target state="translated">ソースシーケンスと減算される配列は、結果のシーケンスから &lt;code&gt;iterator&lt;/code&gt; が要求された場合にのみ反復されることに注意してください。 &lt;code&gt;iterator&lt;/code&gt; 連続する呼び出し間でそれらのいずれかを変更すると、結果に影響を与える可能性があります。</target>
        </trans-unit>
        <trans-unit id="8cd8b63a074395eb7bac096117fd2d1a65ca128f" translate="yes" xml:space="preserve">
          <source>Note that the source sequence and the collection being added are iterated only when an &lt;code&gt;iterator&lt;/code&gt; is requested from the resulting sequence. Changing any of them between successive calls to &lt;code&gt;iterator&lt;/code&gt; may affect the result.</source>
          <target state="translated">追加されるソースシーケンスとコレクションは、結果のシーケンスから &lt;code&gt;iterator&lt;/code&gt; が要求された場合にのみ反復されることに注意してください。 &lt;code&gt;iterator&lt;/code&gt; 連続する呼び出し間でそれらのいずれかを変更すると、結果に影響を与える可能性があります。</target>
        </trans-unit>
        <trans-unit id="230e838a21a0d86d33ae636264aea12d232d60bc" translate="yes" xml:space="preserve">
          <source>Note that the source sequence and the collection being subtracted are iterated only when an &lt;code&gt;iterator&lt;/code&gt; is requested from the resulting sequence. Changing any of them between successive calls to &lt;code&gt;iterator&lt;/code&gt; may affect the result.</source>
          <target state="translated">ソースシーケンスと減算されるコレクションは、結果のシーケンスから &lt;code&gt;iterator&lt;/code&gt; が要求された場合にのみ反復されることに注意してください。 &lt;code&gt;iterator&lt;/code&gt; 連続する呼び出し間でそれらのいずれかを変更すると、結果に影響を与える可能性があります。</target>
        </trans-unit>
        <trans-unit id="1d7a2c8875e7a4328f4bc1cb1a337451636c5765" translate="yes" xml:space="preserve">
          <source>Note that the source sequence and the sequence being added are iterated only when an &lt;code&gt;iterator&lt;/code&gt; is requested from the resulting sequence. Changing any of them between successive calls to &lt;code&gt;iterator&lt;/code&gt; may affect the result.</source>
          <target state="translated">ソースシーケンスと追加されるシーケンスは、結果のシーケンスから &lt;code&gt;iterator&lt;/code&gt; が要求された場合にのみ反復されることに注意してください。 &lt;code&gt;iterator&lt;/code&gt; 連続する呼び出し間でそれらのいずれかを変更すると、結果に影響を与える可能性があります。</target>
        </trans-unit>
        <trans-unit id="9b6c8e7b439f69f32239265aaaa738e3fcea0362" translate="yes" xml:space="preserve">
          <source>Note that the source sequence and the sequence being subtracted are iterated only when an &lt;code&gt;iterator&lt;/code&gt; is requested from the resulting sequence. Changing any of them between successive calls to &lt;code&gt;iterator&lt;/code&gt; may affect the result.</source>
          <target state="translated">ソースシーケンスと減算されるシーケンスは、結果のシーケンスから &lt;code&gt;iterator&lt;/code&gt; が要求された場合にのみ反復されることに注意してください。 &lt;code&gt;iterator&lt;/code&gt; 連続する呼び出し間でそれらのいずれかを変更すると、結果に影響を与える可能性があります。</target>
        </trans-unit>
        <trans-unit id="0f3815a86501d3751673db13b1bc40b17a55063d" translate="yes" xml:space="preserve">
          <source>Note that the syntax &lt;code&gt;this::prop&lt;/code&gt; to refer a &lt;a href=&quot;reflection#bound-function-and-property-references-since-11&quot;&gt;bound callable reference&lt;/a&gt; in the code directly has only been available since Kotlin 1.1.</source>
          <target state="translated">Note that the syntax &lt;code&gt;this::prop&lt;/code&gt; to refer a &lt;a href=&quot;reflection#bound-function-and-property-references-since-11&quot;&gt;bound callable reference&lt;/a&gt; in the code directly has only been available since Kotlin 1.1.</target>
        </trans-unit>
        <trans-unit id="be4783ce40fed5c138c67544445542f050cb0f80" translate="yes" xml:space="preserve">
          <source>Note that the syntax &lt;code&gt;this::prop&lt;/code&gt; to refer a &lt;a href=&quot;reflection#bound-function-and-property-references-since-11&quot;&gt;bound callable reference&lt;/a&gt; in the code directly is available only since Kotlin 1.1.</source>
          <target state="translated">コードで&lt;a href=&quot;reflection#bound-function-and-property-references-since-11&quot;&gt;バインドされた呼び出し可能な参照&lt;/a&gt;を直接参照する構文 &lt;code&gt;this::prop&lt;/code&gt; は、Kotlin 1.1以降でのみ使用できることに注意してください。</target>
        </trans-unit>
        <trans-unit id="2949a431bbdf8be1e322b0911e16815ddc68d4b3" translate="yes" xml:space="preserve">
          <source>Note that the terms &quot;subclass&quot; and &quot;superclass&quot; can span multiple levels of inheritance - &lt;code&gt;Car&lt;/code&gt; is a subclass of &lt;code&gt;Any&lt;/code&gt;, and &lt;code&gt;Any&lt;/code&gt; is the superclass of everything. If we want to restrict ourselves to one level of inheritance, we will say &quot;direct subclass&quot; or &quot;direct superclass&quot;.</source>
          <target state="translated">用語「サブクラス」と「スーパークラス」の継承の複数のレベルにまたがることができること注- &lt;code&gt;Car&lt;/code&gt; のサブクラスで &lt;code&gt;Any&lt;/code&gt; 、および &lt;code&gt;Any&lt;/code&gt; すべてのスーパークラスです。継承のレベルを1つに制限したい場合は、「直接サブクラス」または「直接スーパークラス」と言います。</target>
        </trans-unit>
        <trans-unit id="6f04df739b130f057070e51840257477306e9abb" translate="yes" xml:space="preserve">
          <source>Note that the trailing newline of each line is stripped. You can also call &lt;code&gt;readLines()&lt;/code&gt; on a file object to get a list of all the lines, or &lt;code&gt;useLines()&lt;/code&gt; to supply a function that will be called on every line. If you simply want the entire file contents as one string or byte array, call &lt;code&gt;readText()&lt;/code&gt; or &lt;code&gt;readBytes()&lt;/code&gt;, respectively.</source>
          <target state="translated">各行の末尾の改行が削除されることに注意してください。また、ファイルオブジェクトで &lt;code&gt;readLines()&lt;/code&gt; を呼び出してすべての行のリストを取得したり、 &lt;code&gt;useLines()&lt;/code&gt; ですべての行で呼び出される関数を提供したりすることもできます。ファイルの内容全体を1つの文字列またはバイト配列として単純に必要な場合は、それぞれ &lt;code&gt;readText()&lt;/code&gt; または &lt;code&gt;readBytes()&lt;/code&gt; を呼び出します。</target>
        </trans-unit>
        <trans-unit id="3233b123410bb0637d15ef36074b9c50ad6be8ca" translate="yes" xml:space="preserve">
          <source>Note that the type of a property must be explicitly specified. As opposed to Python, declaring a property directly inside the class does not create a class-level property, but an instance-level one: every instance of &lt;code&gt;Person&lt;/code&gt; will have &lt;em&gt;its own&lt;/em&gt;&lt;code&gt;name&lt;/code&gt; and &lt;code&gt;age&lt;/code&gt;. Their values will start out in every instance as &lt;code&gt;&quot;Anne&quot;&lt;/code&gt; and &lt;code&gt;32&lt;/code&gt;, respectively, but the value in each instance can be modified independently of the others:</source>
          <target state="translated">プロパティのタイプは明示的に指定する必要があることに注意してください。Pythonのとは対照的に、クラス内で直接プロパティを宣言すると、クラスレベルのプロパティを作成しますが、インスタンス・レベルのものではないんのすべてのインスタンス &lt;code&gt;Person&lt;/code&gt; 持っているだろう&lt;em&gt;、独自の&lt;/em&gt; &lt;code&gt;name&lt;/code&gt; と &lt;code&gt;age&lt;/code&gt; 。それらの値は、すべてのインスタンスでそれぞれ &lt;code&gt;&quot;Anne&quot;&lt;/code&gt; および &lt;code&gt;32&lt;/code&gt; として始まりますが、各インスタンスの値は他のインスタンスとは独立して変更できます。</target>
        </trans-unit>
        <trans-unit id="f7f16b8fd146ff06d4c86373cb61d32bd374065c" translate="yes" xml:space="preserve">
          <source>Note that the type systems of TypeScript and Kotlin do not match exactly, so you may need to edit the generated headers in case you encounter difficulties with using the APIs from Kotlin.</source>
          <target state="translated">TypeScript と Kotlin の型システムは完全に一致していないので、Kotlin の API を使用する際に問題が発生した場合は、生成されたヘッダを編集する必要があるかもしれないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="b0f31d7eb5e41ba2d64378a5f837d7e8fe985ed7" translate="yes" xml:space="preserve">
          <source>Note that the use of local returns in previous three examples is similar to the use of &lt;em&gt;continue&lt;/em&gt; in regular loops. There is no direct equivalent for &lt;em&gt;break&lt;/em&gt;, but it can be simulated by adding another nesting lambda and non-locally returning from it:</source>
          <target state="translated">前の3つの例でのローカルリターンの使用は、通常のループでの&lt;em&gt;continue&lt;/em&gt;の使用に似ていることに注意してください。&lt;em&gt;break&lt;/em&gt;に直接相当するものはありませんが、別の入れ子のラムダを追加し、それから非ローカルに戻ることでシミュレートできます。</target>
        </trans-unit>
        <trans-unit id="3f8c27f5e2c38c0c780333a188295d27c17547ca" translate="yes" xml:space="preserve">
          <source>Note that there are some cases in which the Kotlin compiler does not apply mangling:</source>
          <target state="translated">Kotlin コンパイラがマングリングを適用しない場合があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="c4baab91a6183da58c03d16fdff1a5962cf6d45a" translate="yes" xml:space="preserve">
          <source>Note that there must be no space between &lt;code&gt;continue&lt;/code&gt;/&lt;code&gt;break&lt;/code&gt; and &lt;code&gt;@&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;continue&lt;/code&gt; / &lt;code&gt;break&lt;/code&gt; と &lt;code&gt;@&lt;/code&gt; の間にスペースがあってはならないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="9d4ed672615deb4b3ea8e8cf90856dae61208644" translate="yes" xml:space="preserve">
          <source>Note that there's no point in optimizing your code when comparing to &lt;code&gt;null&lt;/code&gt; explicitly: &lt;code&gt;a == null&lt;/code&gt; will be automatically translated to &lt;code&gt;a === null&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;null&lt;/code&gt; と明示的に比較する場合、コードを最適化しても意味がないことに注意してください &lt;code&gt;a == null&lt;/code&gt; は自動的に &lt;code&gt;a === null&lt;/code&gt; 変換されます。</target>
        </trans-unit>
        <trans-unit id="29bbb70efdb2913fbd8c12ace3a60040ce02ee39" translate="yes" xml:space="preserve">
          <source>Note that these &lt;code&gt;xxxAsync&lt;/code&gt; functions are &lt;strong&gt;not&lt;/strong&gt;&lt;em&gt;suspending&lt;/em&gt; functions. They can be used from anywhere. However, their use always implies asynchronous (here meaning &lt;em&gt;concurrent&lt;/em&gt;) execution of their action with the invoking code.</source>
          <target state="translated">これらの &lt;code&gt;xxxAsync&lt;/code&gt; 関数は&lt;em&gt;一時停止&lt;/em&gt;関数では&lt;strong&gt;ない&lt;/strong&gt;&lt;em&gt;ことに&lt;/em&gt;注意してください。どこからでも使えます。ただし、これらの使用は常に、呼び出しコードでのアクションの非同期（ここでは&lt;em&gt;並行を&lt;/em&gt;意味する）実行を意味&lt;em&gt;し&lt;/em&gt;ます。</target>
        </trans-unit>
        <trans-unit id="d091dbc112d0275a030bcbf9509f2a82ef36aedb" translate="yes" xml:space="preserve">
          <source>Note that this Comparator does not take locale into account, and will result in an unsatisfactory ordering for certain locales.</source>
          <target state="translated">このコンパレータはロケールを考慮していないため、特定のロケールでは満足のいく注文ができないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="bf9957e9675cc2706846aa1653497d6600b98d94" translate="yes" xml:space="preserve">
          <source>Note that this example also uses &lt;code&gt;use&lt;/code&gt; function from the Kotlin standard library to release threads that are created with &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/new-single-thread-context.html&quot;&gt;newSingleThreadContext&lt;/a&gt; when they are no longer needed.</source>
          <target state="translated">この例では、Kotlin標準ライブラリの &lt;code&gt;use&lt;/code&gt; 関数も使用して、&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/new-single-thread-context.html&quot;&gt;newSingleThreadContextで&lt;/a&gt;作成されたスレッドが不要になったときに解放することに注意してください。</target>
        </trans-unit>
        <trans-unit id="75aded832e4b3dd5a16b56a1e23cf328870005d2" translate="yes" xml:space="preserve">
          <source>Note that this example also uses the &lt;code&gt;use&lt;/code&gt; function from the Kotlin standard library to release threads created with &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/new-single-thread-context.html&quot;&gt;newSingleThreadContext&lt;/a&gt; when they are no longer needed.</source>
          <target state="translated">Note that this example also uses the &lt;code&gt;use&lt;/code&gt; function from the Kotlin standard library to release threads created with &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/new-single-thread-context.html&quot;&gt;newSingleThreadContext&lt;/a&gt; when they are no longer needed.</target>
        </trans-unit>
        <trans-unit id="ec685b693941d4e96b2af1eef69e4363925a8b20" translate="yes" xml:space="preserve">
          <source>Note that this mechanism currently only works on Java version 1.7+. The JS and Native restrictions are temporary and will be lifted in the future.</source>
          <target state="translated">このメカニズムは現在Javaバージョン1.7+でのみ動作することに注意してください。JSとNativeの制限は一時的なもので、将来的には解除される予定です。</target>
        </trans-unit>
        <trans-unit id="f0cc5e3b07875e2d5bb6712ec59bb2224c29a52e" translate="yes" xml:space="preserve">
          <source>Note that this only works where &lt;code&gt;b&lt;/code&gt; is immutable (i.e. a local variable which is not modified between the check and the usage or a member &lt;em&gt;val&lt;/em&gt; which has a backing field and is not overridable), because otherwise it might happen that &lt;code&gt;b&lt;/code&gt; changes to &lt;em&gt;null&lt;/em&gt; after the check.</source>
          <target state="translated">これは、 &lt;code&gt;b&lt;/code&gt; が不変（つまり、チェックと使用法の間で変更されないローカル変数、またはバッキングフィールドがあり、オーバーライドできないメンバー&lt;em&gt;val&lt;/em&gt;）の場合にのみ機能することに注意してください。そうしないと、後に &lt;code&gt;b&lt;/code&gt; が&lt;em&gt;null&lt;/em&gt;に変わる可能性があり&lt;em&gt;ます。&lt;/em&gt;チェック。</target>
        </trans-unit>
        <trans-unit id="02cb3aecbee6ce81505199ced32233815d499b61" translate="yes" xml:space="preserve">
          <source>Note that this part of the &lt;code&gt;.def&lt;/code&gt; file is treated as part of the header file, so functions with the body should be declared as &lt;code&gt;static&lt;/code&gt;. The declarations are parsed after including the files from the &lt;code&gt;headers&lt;/code&gt; list.</source>
          <target state="translated">&lt;code&gt;.def&lt;/code&gt; ファイルのこの部分はヘッダーファイルの一部として扱われるため、本文を含む関数は &lt;code&gt;static&lt;/code&gt; として宣言する必要があります。宣言は、 &lt;code&gt;headers&lt;/code&gt; リストからファイルを含めた後に解析されます。</target>
        </trans-unit>
        <trans-unit id="632fe2c8e3130a19688049106ee9e7cf2e3fa004" translate="yes" xml:space="preserve">
          <source>Note that this way of applying the Kotlin/JS plugin requires adding the following code to Gradle settings file (&lt;code&gt;settings.gradle&lt;/code&gt;):</source>
          <target state="translated">Kotlin / JSプラグインを適用するこの方法では、次のコードをGradle設定ファイル（ &lt;code&gt;settings.gradle&lt;/code&gt; ）に追加する必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="3e08e867fd041797206da0cee5969714ae5576c9" translate="yes" xml:space="preserve">
          <source>Note that unlike some other languages, there are no implicit widening conversions for numbers in Kotlin. For example, a function with a &lt;code&gt;Double&lt;/code&gt; parameter can be called only on &lt;code&gt;Double&lt;/code&gt; values, but not &lt;code&gt;Float&lt;/code&gt;, &lt;code&gt;Int&lt;/code&gt;, or other numeric values.</source>
          <target state="translated">Note that unlike some other languages, there are no implicit widening conversions for numbers in Kotlin. For example, a function with a &lt;code&gt;Double&lt;/code&gt; parameter can be called only on &lt;code&gt;Double&lt;/code&gt; values, but not &lt;code&gt;Float&lt;/code&gt; , &lt;code&gt;Int&lt;/code&gt; , or other numeric values.</target>
        </trans-unit>
        <trans-unit id="5d89b0ac97e4e72ec3a56a39219f1c2ad6cf8c5b" translate="yes" xml:space="preserve">
          <source>Note that we do not use &lt;code&gt;val&lt;/code&gt; in front of &lt;code&gt;maxSpeed&lt;/code&gt; in &lt;code&gt;Car&lt;/code&gt; - doing so would have introduced a distinct property in &lt;code&gt;Car&lt;/code&gt; that would have &lt;em&gt;shadowed&lt;/em&gt; the one inherited from &lt;code&gt;MotorVehicle&lt;/code&gt;. As written, it's just a constructor parameter that we pass on to the superconstructor.</source>
          <target state="translated">私たちが使用していないことを注意 &lt;code&gt;val&lt;/code&gt; の前で &lt;code&gt;maxSpeed&lt;/code&gt; で &lt;code&gt;Car&lt;/code&gt; -そうすることで明確な財産導入しているでしょう &lt;code&gt;Car&lt;/code&gt; だろう&lt;em&gt;影の&lt;/em&gt;から継承された1 &lt;code&gt;MotorVehicle&lt;/code&gt; を。書かれているように、これはスーパーコンストラクターに渡すコンストラクターパラメーターです。</target>
        </trans-unit>
        <trans-unit id="32efdf9e14f64cdc5ac4ce116b4cf7f1f66b160c" translate="yes" xml:space="preserve">
          <source>Note that when the LazyThreadSafetyMode.SYNCHRONIZED mode is specified the returned instance uses itself to synchronize on. Do not synchronize from external code on the returned instance as it may cause accidental deadlock. Also this behavior can be changed in the future.</source>
          <target state="translated">LazyThreadSafetyMode.SYNCHRONIZED モードが指定されている場合、返されたインスタンスは自分自身を使用して同期することに注意してください。誤ってデッドロックを起こす可能性があるので、返されたインスタンス上で外部コードから同期しないようにしてください。また、この動作は将来的に変更することも可能です。</target>
        </trans-unit>
        <trans-unit id="d89d8b71e027e7e428c09aada677d55add6a81f5" translate="yes" xml:space="preserve">
          <source>Note that while &lt;code&gt;File()&lt;/code&gt; does create a &quot;file object&quot;, it doesn't actually open the file - the file object is just a reference to the file path; opening the file is a separate action. The preceding functions open and close the file automatically, whereas other functions separately open and close the file. For example, if you're parsing binary data and you don't want to read the entire file at once, you must create an &lt;em&gt;input stream&lt;/em&gt; (for binary data) or an &lt;em&gt;input stream reader&lt;/em&gt; (for strings) - the example below will read 16 bytes:</source>
          <target state="translated">&lt;code&gt;File()&lt;/code&gt; は「ファイルオブジェクト」を作成しますが、実際にはファイルを開かないことに注意してください。ファイルオブジェクトはファイルパスへの参照にすぎません。ファイルを開くことは別のアクションです。上記の関数はファイルを自動的に開いたり閉じたりしますが、他の関数はファイルを個別に開いたり閉じたりします。たとえば、バイナリデータを解析していて、ファイル全体を一度に読みたくない場合は、&lt;em&gt;入力ストリーム&lt;/em&gt;（バイナリデータの場合）または&lt;em&gt;入力ストリームリーダー&lt;/em&gt;（文字列の場合）を作成する必要があります。以下の例では、 16バイト：</target>
        </trans-unit>
        <trans-unit id="14f5320c56ff81654d679ede920646b9dc75066a" translate="yes" xml:space="preserve">
          <source>Note that with Gradle Kotlin DSL, you should get the task from the project's &lt;code&gt;tasks&lt;/code&gt; first.</source>
          <target state="translated">Gradle Kotlin DSLでは、最初にプロジェクトの &lt;code&gt;tasks&lt;/code&gt; からタスクを取得する必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="c40d9fcf3b6b2afa85b538678b5ccf141165484f" translate="yes" xml:space="preserve">
          <source>Note that you can build the same pipeline using &lt;a href=&quot;../../../api/latest/jvm/stdlib/kotlin.sequences/iterator&quot;&gt;&lt;code&gt;iterator&lt;/code&gt;&lt;/a&gt; coroutine builder from the standard library. Replace &lt;code&gt;produce&lt;/code&gt; with &lt;code&gt;iterator&lt;/code&gt;, &lt;code&gt;send&lt;/code&gt; with &lt;code&gt;yield&lt;/code&gt;, &lt;code&gt;receive&lt;/code&gt; with &lt;code&gt;next&lt;/code&gt;, &lt;code&gt;ReceiveChannel&lt;/code&gt; with &lt;code&gt;Iterator&lt;/code&gt;, and get rid of the coroutine scope. You will not need &lt;code&gt;runBlocking&lt;/code&gt; either. However, the benefit of a pipeline that uses channels as shown above is that it can actually use multiple CPU cores if you run it in &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-default.html&quot;&gt;Dispatchers.Default&lt;/a&gt; context.</source>
          <target state="translated">標準ライブラリの&lt;a href=&quot;../../../api/latest/jvm/stdlib/kotlin.sequences/iterator&quot;&gt; &lt;code&gt;iterator&lt;/code&gt; &lt;/a&gt;コルーチンビルダーを使用して同じパイプラインを構築できることに注意してください。 &lt;code&gt;produce&lt;/code&gt; を &lt;code&gt;iterator&lt;/code&gt; に置き換え、 &lt;code&gt;send&lt;/code&gt; を &lt;code&gt;yield&lt;/code&gt; に、 &lt;code&gt;receive&lt;/code&gt; を &lt;code&gt;next&lt;/code&gt; に、 &lt;code&gt;ReceiveChannel&lt;/code&gt; を &lt;code&gt;Iterator&lt;/code&gt; に置き換え、コルーチンスコープを削除します。 &lt;code&gt;runBlocking&lt;/code&gt; も必要ありません。ただし、上記のようにチャネルを使用するパイプラインの利点は、&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-default.html&quot;&gt;Dispatchers.Default&lt;/a&gt;コンテキストで実行すると、実際に複数のCPUコアを使用できることです。</target>
        </trans-unit>
        <trans-unit id="fb9e894663a37dff3bfdff25d326ba2089261968" translate="yes" xml:space="preserve">
          <source>Note that you can open folders in the Source tab and see sources of libraries you are using in your project, including Kotlin standard library (&lt;code&gt;kotlin.js&lt;/code&gt;). This, however, requires that libraries are compiled with source maps enabled, as well as sources embedded into source maps. So the good practice is: if you share a library for Kotlin/JS, please, include source map into distribution.</source>
          <target state="translated">[ソース]タブでフォルダーを開いて、Kotlin標準ライブラリ（ &lt;code&gt;kotlin.js&lt;/code&gt; ）を含む、プロジェクトで使用しているライブラリのソースを表示できることに注意してください。ただし、これには、ソースマップを有効にしてライブラリをコンパイルすること、およびソースマップに埋め込まれたソースが必要です。ですから、Kotlin / JSのライブラリを共有する場合は、ソースマップを配布に含めてください。</target>
        </trans-unit>
        <trans-unit id="f3d310ef82c3c4cf7ec6ba7c31c24dfd55f8f136" translate="yes" xml:space="preserve">
          <source>Note that you can use the &lt;em&gt;override&lt;/em&gt; keyword as part of the property declaration in a primary constructor.</source>
          <target state="translated">プライマリコンストラクターのプロパティ宣言の一部として、&lt;em&gt;override&lt;/em&gt;キーワードを使用できることに注意してください。</target>
        </trans-unit>
        <trans-unit id="49136291f4ccdd63f93ac650ad3552f2ac330a1e" translate="yes" xml:space="preserve">
          <source>Note that you can't extend a non-external class by external classes.</source>
          <target state="translated">外部クラスではないクラスを外部クラスで拡張することはできないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="3e28231afdd7ac958845e417ade6744d2f5c90c1" translate="yes" xml:space="preserve">
          <source>Note that you need to turn on the &lt;a href=&quot;#enabling-experimental-features&quot;&gt;experimental flag&lt;/a&gt; to use &lt;code&gt;LayoutContainer&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;LayoutContainer&lt;/code&gt; を使用するには、&lt;a href=&quot;#enabling-experimental-features&quot;&gt;実験的なフラグ&lt;/a&gt;をオンにする必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="7606870a12c3125873b69f0dbf82ae21f8b6f6b5" translate="yes" xml:space="preserve">
          <source>Note that, as described in &lt;a href=&quot;classes#secondary-constructors&quot;&gt;Secondary Constructors&lt;/a&gt;, if a class has default values for all constructor parameters, a public no-argument constructor will be generated for it. This works even if the &lt;code&gt;@JvmOverloads&lt;/code&gt; annotation is not specified.</source>
          <target state="translated">&lt;a href=&quot;classes#secondary-constructors&quot;&gt;セカンダリコンストラクター&lt;/a&gt;で説明されているように、クラスにすべてのコンストラクターパラメーターのデフォルト値がある場合、引数のないパブリックコンストラクターが生成されます。これは、 &lt;code&gt;@JvmOverloads&lt;/code&gt; アノテーションが指定されていなくても機能します。</target>
        </trans-unit>
        <trans-unit id="bcfd3d4bc13c4d196d89ced424f8f78ed6df819a" translate="yes" xml:space="preserve">
          <source>Note that, even though the members of companion objects look like static members in other languages, at runtime those are still instance members of real objects, and can, for example, implement interfaces:</source>
          <target state="translated">コンパニオンオブジェクトのメンバは、他の言語では静的なメンバのように見えても、実行時には実際のオブジェクトのインスタンスメンバであり、例えばインターフェイスを実装することができることに注意してください。</target>
        </trans-unit>
        <trans-unit id="63673aeff981591d75550c2f1b2c84d22a058b57" translate="yes" xml:space="preserve">
          <source>Note that, if the Java class only has a setter, it will not be visible as a property in Kotlin, because Kotlin does not support set-only properties at this time.</source>
          <target state="translated">Javaクラスがセッターのみを持っている場合、Kotlinではそれがプロパティとして表示されないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="4ff451e50da6bbf10519c4f38e0ec36c818d0c89" translate="yes" xml:space="preserve">
          <source>Note that, since &lt;em&gt;throw&lt;/em&gt; and &lt;em&gt;return&lt;/em&gt; are expressions in Kotlin, they can also be used on the right hand side of the elvis operator. This can be very handy, for example, for checking function arguments:</source>
          <target state="translated">以来、なお&lt;em&gt;スロー&lt;/em&gt;と&lt;em&gt;リターンが&lt;/em&gt; Kotlinで式をしている、彼らはまた、エルビス演算子の右側に使用することができます。これは、たとえば、関数の引数をチェックする場合に非常に便利です。</target>
        </trans-unit>
        <trans-unit id="ff2652dcfc51e4dc3d549eb0a81df9a68d2667cc" translate="yes" xml:space="preserve">
          <source>Note that, since extensions do not actually insert members into classes, there's no efficient way for an extension property to have a &lt;a href=&quot;properties#backing-fields&quot;&gt;backing field&lt;/a&gt;. This is why &lt;strong&gt;initializers are not allowed for extension properties&lt;/strong&gt;. Their behavior can only be defined by explicitly providing getters/setters.</source>
          <target state="translated">拡張は実際にはクラスにメンバーを挿入しないため、拡張プロパティが&lt;a href=&quot;properties#backing-fields&quot;&gt;バッキングフィールド&lt;/a&gt;を持つ効率的な方法はないことに注意してください。これが&lt;strong&gt;、拡張プロパティに対してイニシャライザが許可されない&lt;/strong&gt;理由です。それらの動作は、ゲッター/セッターを明示的に提供することによってのみ定義できます。</target>
        </trans-unit>
        <trans-unit id="410e3cbb9102efe17f7c84d061da15f92debf764" translate="yes" xml:space="preserve">
          <source>Note the &lt;code&gt;@NotNull&lt;/code&gt; annotations on &lt;code&gt;String&lt;/code&gt; type arguments. Without them, we get platform types in the type arguments:</source>
          <target state="translated">&lt;code&gt;String&lt;/code&gt; 型の引数の &lt;code&gt;@NotNull&lt;/code&gt; アノテーションに注意してください。それらがなければ、型引数でプラットフォーム型を取得します。</target>
        </trans-unit>
        <trans-unit id="c5849a883ad401340758801d94c3c8fe5489e593" translate="yes" xml:space="preserve">
          <source>Note the difference between declaring two parameters and declaring a destructuring pair instead of a parameter:</source>
          <target state="translated">2つのパラメータを宣言することと、パラメータの代わりに破壊ペアを宣言することの違いに注意してください。</target>
        </trans-unit>
        <trans-unit id="fe84360ef08152f70a600e469dd1daf46f251b07" translate="yes" xml:space="preserve">
          <source>Note the use of &lt;code&gt;private&lt;/code&gt;&lt;a href=&quot;../reference/visibility-modifiers&quot;&gt;visibility modifier&lt;/a&gt; here. While the concept of visibility modifier is not relevant for competitive programming at all, it allows you to place multiple solution files based on the same template without getting an error for conflicting public declarations in the same package.</source>
          <target state="translated">ここでは &lt;code&gt;private&lt;/code&gt; &lt;a href=&quot;../reference/visibility-modifiers&quot;&gt;可視性修飾子の&lt;/a&gt;使用に注意してください。可視性修飾子の概念は競合プログラミングにはまったく関係ありませんが、同じパッケージで競合するパブリック宣言のエラーが発生することなく、同じテンプレートに基づく複数のソリューションファイルを配置できます。</target>
        </trans-unit>
        <trans-unit id="32363778a2d483af8b5e294fa0d257703c3636de" translate="yes" xml:space="preserve">
          <source>Note the use of Kotlin's &lt;a href=&quot;../reference/null-safety#the--operator&quot;&gt;null-assertion operator&lt;/a&gt;&lt;code&gt;!!&lt;/code&gt; after the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.io/read-line&quot;&gt;readLine()&lt;/a&gt; function call. Kotlin's &lt;code&gt;readLine()&lt;/code&gt; function is defined to return a &lt;a href=&quot;../reference/null-safety#nullable-types-and-non-null-types&quot;&gt;nullable type&lt;/a&gt;&lt;code&gt;String?&lt;/code&gt; and returns &lt;code&gt;null&lt;/code&gt; on the end of the input, which explicitly forces the developer to handle the case of missing input.</source>
          <target state="translated">Kotlinの&lt;a href=&quot;../reference/null-safety#the--operator&quot;&gt;nullアサーション演算子&lt;/a&gt;の使用に注意してください &lt;code&gt;!!&lt;/code&gt; 後&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.io/read-line&quot;&gt;のreadLine（）&lt;/a&gt;関数呼び出し。Kotlinの &lt;code&gt;readLine()&lt;/code&gt; 関数は、&lt;a href=&quot;../reference/null-safety#nullable-types-and-non-null-types&quot;&gt;null許容型の&lt;/a&gt; &lt;code&gt;String?&lt;/code&gt; を返すように定義されていますか？そして、入力の最後に &lt;code&gt;null&lt;/code&gt; を返します。これにより、開発者は入力がない場合の処理​​を明示的に強制します。</target>
        </trans-unit>
        <trans-unit id="ac2f2aad869d626d4d52fe790ab55573fcf5e8e3" translate="yes" xml:space="preserve">
          <source>Note, Kotlin/Native object references do not support multi-threaded access. Hosting the returned &lt;code&gt;libnative_ExportedSymbols*&lt;/code&gt; pointer per thread might be necessary.</source>
          <target state="translated">Kotlin / Nativeオブジェクト参照はマルチスレッドアクセスをサポートしていないことに注意してください。返された &lt;code&gt;libnative_ExportedSymbols*&lt;/code&gt; ポインターをスレッドごとにホストする必要がある場合があります。</target>
        </trans-unit>
        <trans-unit id="2b78a1550dcdacf66568124ca1b7e49361c24581" translate="yes" xml:space="preserve">
          <source>Note, here we use the &lt;code&gt;$SRCROOT/../..&lt;/code&gt; as the path to the root of our Gradle project. It can depend on the way the Xcode project was created. Also, we use the generated &lt;code&gt;SharedCode/build/xcode-frameworks/gradlew&lt;/code&gt; script, the &lt;code&gt;packForXCode&lt;/code&gt; task generates it. We assumed that the Gradle build is executed at least once, before opening the Xcode project on a fresh machine</source>
          <target state="translated">ここでは、 &lt;code&gt;$SRCROOT/../..&lt;/code&gt; をGradleプロジェクトのルートへのパスとして使用しています。Xcodeプロジェクトの作成方法によって異なります。また、生成された &lt;code&gt;SharedCode/build/xcode-frameworks/gradlew&lt;/code&gt; スクリプトを使用し、 &lt;code&gt;packForXCode&lt;/code&gt; タスクがそれを生成します。新しいマシンでXcodeプロジェクトを開く前に、Gradleビルドが少なくとも1回実行されると想定しました</target>
        </trans-unit>
        <trans-unit id="e681d434ce2d0ba5fe65e1c3eb9e64a72c2114ad" translate="yes" xml:space="preserve">
          <source>Note, how both first &lt;code&gt;async&lt;/code&gt; and awaiting parent are cancelled on the one child failure:</source>
          <target state="translated">最初の &lt;code&gt;async&lt;/code&gt; と待機中の親の両方が1つの子の失敗でキャンセルされる方法に注意してください。</target>
        </trans-unit>
        <trans-unit id="fa14e718dbed55afbde738f5e7d1fbd2fe0275f6" translate="yes" xml:space="preserve">
          <source>Note, however, that members overridden in this way do not get called from the members of the delegate object, which can only access its own implementations of the interface members:</source>
          <target state="translated">しかし、この方法でオーバーライドされたメンバはデリゲートオブジェクトのメンバからは呼び出されないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="63c0fd4e85cb25d5c9ec03f575f81a0e9dd952a9" translate="yes" xml:space="preserve">
          <source>Note, that Android has first-party support for coroutine scope in all entities with the lifecycle. See &lt;a href=&quot;https://developer.android.com/topic/libraries/architecture/coroutines#lifecyclescope&quot;&gt;the corresponding documentation&lt;/a&gt;.</source>
          <target state="translated">Note, that Android has first-party support for coroutine scope in all entities with the lifecycle. See &lt;a href=&quot;https://developer.android.com/topic/libraries/architecture/coroutines#lifecyclescope&quot;&gt;the corresponding documentation&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="9016aa7ea4f2b1fc5592a3d2b46f69f0ff3c825e" translate="yes" xml:space="preserve">
          <source>Note, that an exception thrown by &lt;a href=&quot;recover#kotlin%24recover%28kotlin.Result%28%28kotlin.recover.T%29%29%2C+kotlin.Function1%28%28kotlin.Throwable%2C+kotlin.recover.R%29%29%29%2Ftransform&quot;&gt;transform&lt;/a&gt; function is rethrown by this function. See &lt;a href=&quot;recover-catching&quot;&gt;recoverCatching&lt;/a&gt; for an alternative that encapsulates exceptions.</source>
          <target state="translated">&lt;a href=&quot;recover#kotlin%24recover%28kotlin.Result%28%28kotlin.recover.T%29%29%2C+kotlin.Function1%28%28kotlin.Throwable%2C+kotlin.recover.R%29%29%29%2Ftransform&quot;&gt;変換&lt;/a&gt;関数によってスローされた例外は、この関数によって再スローされることに注意してください。例外をカプセル化する別の方法については、&lt;a href=&quot;recover-catching&quot;&gt;recoverCatching&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="ab4261a565eea01ddcb4378ad59c0c58898851cf" translate="yes" xml:space="preserve">
          <source>Note, that for some cases cycle collection need to be done to ensure that dead cycles do not affect reachability of passed object graph.</source>
          <target state="translated">いくつかのケースでは、デッドサイクルが渡されたオブジェクトグラフの到達性に影響を与えないように、サイクルの収集を行う必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="cb746582c1d18af800034f12e0c2fb36cf93a443" translate="yes" xml:space="preserve">
          <source>Note, that incrementing and decrementing &lt;code&gt;acquired&lt;/code&gt; counter here from 100K coroutines is completely safe, since it always happens from the same main thread. More on that will be explained in the next chapter on coroutine context.</source>
          <target state="translated">Note, that incrementing and decrementing &lt;code&gt;acquired&lt;/code&gt; counter here from 100K coroutines is completely safe, since it always happens from the same main thread. More on that will be explained in the next chapter on coroutine context.</target>
        </trans-unit>
        <trans-unit id="b6259b2eebc86f15dafec32912cdde080c4e1580" translate="yes" xml:space="preserve">
          <source>Note, that the generated bindings are generally platform-specific, so if you are developing for multiple targets, the bindings need to be regenerated.</source>
          <target state="translated">生成されたバインディングは一般的にプラットフォーム固有のものなので、複数のターゲット向けに開発している場合は、バインディングを再生成する必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="7b7682c3f874c25b43973c6dea774be8a4df50c1" translate="yes" xml:space="preserve">
          <source>Note, that this function rethrows any &lt;a href=&quot;-throwable/index#kotlin.Throwable&quot;&gt;Throwable&lt;/a&gt; exception thrown by &lt;a href=&quot;recover#kotlin%24recover(kotlin.Result((kotlin.recover.T)),%20kotlin.Function1((kotlin.Throwable,%20kotlin.recover.R)))/transform&quot;&gt;transform&lt;/a&gt; function. See &lt;a href=&quot;recover-catching&quot;&gt;recoverCatching&lt;/a&gt; for an alternative that encapsulates exceptions.</source>
          <target state="translated">Note, that this function rethrows any &lt;a href=&quot;-throwable/index#kotlin.Throwable&quot;&gt;Throwable&lt;/a&gt; exception thrown by &lt;a href=&quot;recover#kotlin%24recover(kotlin.Result((kotlin.recover.T)),%20kotlin.Function1((kotlin.Throwable,%20kotlin.recover.R)))/transform&quot;&gt;transform&lt;/a&gt; function. See &lt;a href=&quot;recover-catching&quot;&gt;recoverCatching&lt;/a&gt; for an alternative that encapsulates exceptions.</target>
        </trans-unit>
        <trans-unit id="fe80340489c5eb8bbb1e5235c463cea51b0d96bc" translate="yes" xml:space="preserve">
          <source>Note, the task may not work &lt;a href=&quot;https://github.com/gradle/gradle/issues/6330&quot;&gt;correctly&lt;/a&gt; if you use Gradle older than 4.10. In this tutorial we have already &lt;a href=&quot;#gradle-upgrade&quot;&gt;upgraded it to 4.7&lt;/a&gt;.</source>
          <target state="translated">4.10より前のGradleを使用すると、タスクが&lt;a href=&quot;https://github.com/gradle/gradle/issues/6330&quot;&gt;正しく&lt;/a&gt;機能しない場合があります。このチュートリアルでは、すでに&lt;a href=&quot;#gradle-upgrade&quot;&gt;4.7にアップグレードし&lt;/a&gt;ています。</target>
        </trans-unit>
        <trans-unit id="cdfb7f6c960fbbb54ec2a22474d762eebb5eb578" translate="yes" xml:space="preserve">
          <source>Note, the way Kotlin/Native exports symbols is subject to change without notice.</source>
          <target state="translated">Kotlin/Nativeがシンボルをエクスポートする方法は、予告なく変更されることがあります。</target>
        </trans-unit>
        <trans-unit id="a421385920384e5f4a176ab3c70967301467e475" translate="yes" xml:space="preserve">
          <source>Note, this mechanism currently works only on Java version 1.7+. Limitation on JS and Native is temporary and will be fixed in the future.</source>
          <target state="translated">注:このメカニズムは現在のところJavaバージョン1.7以上でのみ動作します。JSとNativeの制限は一時的なもので、将来的には修正される予定です。</target>
        </trans-unit>
        <trans-unit id="12618a61ea26af57372d00837c08269ccff8b13d" translate="yes" xml:space="preserve">
          <source>Note, we use the extension property &lt;code&gt;ptr&lt;/code&gt; which comes from a &lt;code&gt;memScoped&lt;/code&gt; lambda receiver type, to turn &lt;code&gt;MyStruct&lt;/code&gt; and &lt;code&gt;MyUnion&lt;/code&gt; instances into native pointers.</source>
          <target state="translated">&lt;code&gt;MyStruct&lt;/code&gt; および &lt;code&gt;MyUnion&lt;/code&gt; インスタンスをネイティブポインターに変換するために、 &lt;code&gt;memScoped&lt;/code&gt; ラムダレシーバータイプからの拡張プロパティ &lt;code&gt;ptr&lt;/code&gt; を使用することに注意してください。</target>
        </trans-unit>
        <trans-unit id="928235a3ea58117b013d6814e6ae398b8d106eb5" translate="yes" xml:space="preserve">
          <source>Note: &lt;a href=&quot;implies#kotlin.contracts.SimpleEffect%24implies%28kotlin.Boolean%29%2FbooleanExpression&quot;&gt;booleanExpression&lt;/a&gt; can accept only a subset of boolean expressions, where a function parameter or receiver (&lt;code&gt;this&lt;/code&gt;) undergoes</source>
          <target state="translated">注：&lt;a href=&quot;implies#kotlin.contracts.SimpleEffect%24implies%28kotlin.Boolean%29%2FbooleanExpression&quot;&gt;booleanExpression&lt;/a&gt;は、関数パラメーターまたはレシーバー（ &lt;code&gt;this&lt;/code&gt; ）が実行されるブール式のサブセットのみを受け入れることができます。</target>
        </trans-unit>
        <trans-unit id="154a86bc22d004fb84d8a8a0b6c888692235178f" translate="yes" xml:space="preserve">
          <source>Note: &lt;a href=&quot;implies#kotlin.contracts.SimpleEffect%24implies(kotlin.Boolean)/booleanExpression&quot;&gt;booleanExpression&lt;/a&gt; can accept only a subset of boolean expressions, where a function parameter or receiver (&lt;code&gt;this&lt;/code&gt;) undergoes</source>
          <target state="translated">Note: &lt;a href=&quot;implies#kotlin.contracts.SimpleEffect%24implies(kotlin.Boolean)/booleanExpression&quot;&gt;booleanExpression&lt;/a&gt; can accept only a subset of boolean expressions, where a function parameter or receiver ( &lt;code&gt;this&lt;/code&gt; ) undergoes</target>
        </trans-unit>
        <trans-unit id="6981f24296bbc00cf0e0f8db9ec6624b3daecbcc" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;Any&lt;/code&gt; is not &lt;code&gt;java.lang.Object&lt;/code&gt;; in particular, it does not have any members other than &lt;code&gt;equals()&lt;/code&gt;, &lt;code&gt;hashCode()&lt;/code&gt; and &lt;code&gt;toString()&lt;/code&gt;. Please consult the &lt;a href=&quot;java-interop#object-methods&quot;&gt;Java interoperability&lt;/a&gt; section for more details.</source>
          <target state="translated">注： &lt;code&gt;Any&lt;/code&gt; は &lt;code&gt;java.lang.Object&lt;/code&gt; ではありません。特に、 &lt;code&gt;equals()&lt;/code&gt; 、 &lt;code&gt;hashCode()&lt;/code&gt; 、および &lt;code&gt;toString()&lt;/code&gt; 以外のメンバーはありません。詳細については、&lt;a href=&quot;java-interop#object-methods&quot;&gt;Javaの相互運用性の&lt;/a&gt;セクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="7cea38b31131e5f3bc473b1806a7dadc1df3f76c" translate="yes" xml:space="preserve">
          <source>Note: Before 1.3.40, both test and product executables were represented by the same binary type. Thus to access the default test binary created by the plugin, the following line was used:</source>
          <target state="translated">注意:1.3.40以前では、テスト実行ファイルと製品実行ファイルの両方が同じバイナリタイプで表現されていました。そのため、プラグインによって作成されたデフォルトのテストバイナリにアクセスするには、以下の行を使用していました。</target>
        </trans-unit>
        <trans-unit id="fb3a30630df8eec859177fc75c5dd700ee60baec" translate="yes" xml:space="preserve">
          <source>Note: For Spring you can use the &lt;code&gt;kotlin-spring&lt;/code&gt; compiler plugin (&lt;a href=&quot;compiler-plugins#spring-support&quot;&gt;see below&lt;/a&gt;).</source>
          <target state="translated">注：Springの場合、 &lt;code&gt;kotlin-spring&lt;/code&gt; コンパイラプラグインを使用できます（&lt;a href=&quot;compiler-plugins#spring-support&quot;&gt;以下を参照&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="d6a0dc39a4a138257b96c621b751cc052081b76a" translate="yes" xml:space="preserve">
          <source>Note: This above code will work properly only on JDK7+ that supports &lt;code&gt;suppressed&lt;/code&gt; exceptions</source>
          <target state="translated">注：この上記のコードは、 &lt;code&gt;suppressed&lt;/code&gt; 例外をサポートする JDK7 +でのみ正しく動作します</target>
        </trans-unit>
        <trans-unit id="484cdded81040d7cac731a5df3e0b2162661d2db" translate="yes" xml:space="preserve">
          <source>Note: creating a source set does not link it to any target. Some source sets are &lt;a href=&quot;#default-project-layout&quot;&gt;predefined&lt;/a&gt; and thus compiled by default. However, custom source sets always need to be explicitly directed to the compilations. See: &lt;a href=&quot;#connecting-source-sets&quot;&gt;Connecting source sets&lt;/a&gt;.</source>
          <target state="translated">注：ソースセットを作成しても、ターゲットにリンクされません。一部のソースセットは&lt;a href=&quot;#default-project-layout&quot;&gt;事前定義され&lt;/a&gt;ているため、デフォルトでコンパイルされます。ただし、カスタムソースセットは常に明示的にコンパイルする必要があります。参照：&lt;a href=&quot;#connecting-source-sets&quot;&gt;ソースセットの接続&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3d3cb30c99fb08c5217d1cecd77b25e0a37cf168" translate="yes" xml:space="preserve">
          <source>Note: due to the current technical limitations, the IDE does not correctly recognize these annotations on type arguments in compiled Java libraries that are used as dependencies.</source>
          <target state="translated">注:現在の技術的な制限のため、IDE は依存関係として使用されるコンパイル済みの Java ライブラリの型引数のこれらのアノテーションを正しく認識しません。</target>
        </trans-unit>
        <trans-unit id="43526e690a06b94dffa5d82ef9ea46b38220defe" translate="yes" xml:space="preserve">
          <source>Note: runtime lookup can be forced even when the class is referenced statically from Objective-C source code by adding &lt;code&gt;__attribute__((objc_runtime_visible))&lt;/code&gt; to its &lt;code&gt;@interface&lt;/code&gt;.</source>
          <target state="translated">注： &lt;code&gt;__attribute__((objc_runtime_visible))&lt;/code&gt; を &lt;code&gt;@interface&lt;/code&gt; に追加することにより、クラスがObjective-Cソースコードから静的に参照されている場合でも、ランタイムルックアップを強制できます。</target>
        </trans-unit>
        <trans-unit id="961c619d9fb3964975b4b9e69245c681552524a7" translate="yes" xml:space="preserve">
          <source>Note: static and shared libraries has suffixes &lt;code&gt;static&lt;/code&gt; and &lt;code&gt;shared&lt;/code&gt; respectively, e.g. &lt;code&gt;fooDebugStatic&lt;/code&gt; or &lt;code&gt;barReleaseShared&lt;/code&gt;</source>
          <target state="translated">注：静的ライブラリと共有ライブラリには、それぞれ &lt;code&gt;static&lt;/code&gt; と &lt;code&gt;shared&lt;/code&gt; サフィックスがあります。たとえば、 &lt;code&gt;fooDebugStatic&lt;/code&gt; または &lt;code&gt;barReleaseShared&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0ba0ca9c0ff727e2f159f9a318e2b4838c970baa" translate="yes" xml:space="preserve">
          <source>Note: the &lt;code&gt;lib&lt;/code&gt; directory which contains &lt;code&gt;kotlin.js&lt;/code&gt; and other library files is only created in IntelliJ IDEA-based projects and is controlled by the &lt;em&gt;Copy library runtime files&lt;/em&gt; flag in the Kotlin &lt;a href=&quot;https://www.jetbrains.com/help/idea/facets.html&quot;&gt;facet settings&lt;/a&gt;. In a Maven or Gradle build (including multiplatform projects), no library files are copied by default to the compilation output directory. See the corresponding tutorials for the instructions on how to achieve the same with those build systems.</source>
          <target state="translated">注： &lt;code&gt;kotlin.js&lt;/code&gt; およびその他のライブラリファイルを含む &lt;code&gt;lib&lt;/code&gt; ディレクトリは、IntelliJ IDEAベースのプロジェクトでのみ作成され、Kotlin &lt;a href=&quot;https://www.jetbrains.com/help/idea/facets.html&quot;&gt;ファセット設定の&lt;/a&gt;&lt;em&gt;ライブラリランタイムファイル&lt;/em&gt;の&lt;em&gt;コピー&lt;/em&gt;フラグによって制御されます。 MavenまたはGradleビルド（マルチプラットフォームプロジェクトを含む）では、ライブラリファイルはデフォルトでコンパイル出力ディレクトリにコピーされません。これらのビルドシステムで同じことを行う方法については、対応するチュートリアルを参照してください。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7a0e64e270b153ff90968e1ff6456ea22567f491" translate="yes" xml:space="preserve">
          <source>Note: the built-in JSR-305 annotations &lt;a href=&quot;https://aalmiray.github.io/jsr-305/apidocs/javax/annotation/Nonnull.html&quot;&gt;&lt;code&gt;@Nonnull&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://aalmiray.github.io/jsr-305/apidocs/javax/annotation/Nullable.html&quot;&gt;&lt;code&gt;@Nullable&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://aalmiray.github.io/jsr-305/apidocs/javax/annotation/CheckForNull.html&quot;&gt;&lt;code&gt;@CheckForNull&lt;/code&gt;&lt;/a&gt; are always enabled and affect the types of the annotated declarations in Kotlin, regardless of compiler configuration with the &lt;code&gt;-Xjsr305&lt;/code&gt; flag.</source>
          <target state="translated">注：組み込みのJSR-305アノテーション&lt;a href=&quot;https://aalmiray.github.io/jsr-305/apidocs/javax/annotation/Nonnull.html&quot;&gt; &lt;code&gt;@Nonnull&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;https://aalmiray.github.io/jsr-305/apidocs/javax/annotation/Nullable.html&quot;&gt; &lt;code&gt;@Nullable&lt;/code&gt; &lt;/a&gt;、および&lt;a href=&quot;https://aalmiray.github.io/jsr-305/apidocs/javax/annotation/CheckForNull.html&quot;&gt; &lt;code&gt;@CheckForNull&lt;/code&gt; &lt;/a&gt;は常に有効であり、 &lt;code&gt;-Xjsr305&lt;/code&gt; フラグを使用したコンパイラー構成に関係なく、Kotlinのアノテーション付き宣言のタイプに影響します。</target>
        </trans-unit>
        <trans-unit id="70ea34d1da722222e140a53cf5465f6882b21617" translate="yes" xml:space="preserve">
          <source>Note: the migration status of a nullability annotation is not inherited by its type qualifier nicknames but is applied to its usages in default type qualifiers.</source>
          <target state="translated">注意:nullabilityアノテーションの移行ステータスは、その型修飾子のニックネームによって継承されるのではなく、デフォルトの型修飾子での使用に適用されます。</target>
        </trans-unit>
        <trans-unit id="c0edc7da32b33f24605529da7af1e0f20a415a52" translate="yes" xml:space="preserve">
          <source>Note: the static members of these Java types are not directly accessible on the &lt;a href=&quot;object-declarations#companion-objects&quot;&gt;companion objects&lt;/a&gt; of the Kotlin types. To call them, use the full qualified names of the Java types, e.g. &lt;code&gt;java.lang.Integer.toHexString(foo)&lt;/code&gt;.</source>
          <target state="translated">注：これらのJava型の静的メンバーは、Kotlin型の&lt;a href=&quot;object-declarations#companion-objects&quot;&gt;コンパニオンオブジェクト&lt;/a&gt;では直接アクセスできません。それらを呼び出すには、Java型の完全修飾名を使用し &lt;code&gt;java.lang.Integer.toHexString(foo)&lt;/code&gt; 例：java.lang.Integer.toHexString（foo））。</target>
        </trans-unit>
        <trans-unit id="58d630dc0f3f2c164372b5befca4a458dbf430dc" translate="yes" xml:space="preserve">
          <source>Note: the types in this example only take place with the strict mode enabled, otherwise, the platform types remain. See the &lt;a href=&quot;#undermigration-annotation-since-1160&quot;&gt;&lt;code&gt;@UnderMigration&lt;/code&gt; annotation&lt;/a&gt; and &lt;a href=&quot;#compiler-configuration&quot;&gt;Compiler configuration&lt;/a&gt; sections.</source>
          <target state="translated">注：この例のタイプは、strictモードが有効になっている場合にのみ発生します。それ以外の場合、プラットフォームタイプは残ります。&lt;a href=&quot;#undermigration-annotation-since-1160&quot;&gt; &lt;code&gt;@UnderMigration&lt;/code&gt; アノテーション&lt;/a&gt;と&lt;a href=&quot;#compiler-configuration&quot;&gt;コンパイラ設定&lt;/a&gt;セクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="1897db2fc3536b91b9cf29ef737cb27b1a12735f" translate="yes" xml:space="preserve">
          <source>Note: this annotation is experimental, see &lt;a href=&quot;../-experimental-multiplatform/index&quot;&gt;ExperimentalMultiplatform&lt;/a&gt; on how to opt-in for it.</source>
          <target state="translated">注：このアノテーションは実験的なものです。オプトインする方法については、&lt;a href=&quot;../-experimental-multiplatform/index&quot;&gt;ExperimentalMultiplatform&lt;/a&gt;をご覧ください。</target>
        </trans-unit>
        <trans-unit id="0b4255d1b07a5ecec5778c495ae7e465e074b5b4" translate="yes" xml:space="preserve">
          <source>Note: this annotation is experimental, see &lt;a href=&quot;../../kotlin.experimental/-experimental-type-inference/index&quot;&gt;ExperimentalTypeInference&lt;/a&gt; on how to opt-in for it.</source>
          <target state="translated">注：このアノテーションは実験的なものです。オプトインする方法については、&lt;a href=&quot;../../kotlin.experimental/-experimental-type-inference/index&quot;&gt;ExperimentalTypeInference&lt;/a&gt;をご覧ください。</target>
        </trans-unit>
        <trans-unit id="357bf8828e4f466867f5aa8f9b5bb6f1a07b487b" translate="yes" xml:space="preserve">
          <source>Note: to use a visible top-level declaration from another package, you should still &lt;a href=&quot;packages#imports&quot;&gt;import&lt;/a&gt; it.</source>
          <target state="translated">注：別のパッケージから可視のトップレベル宣言を使用するには、それを&lt;a href=&quot;packages#imports&quot;&gt;インポート&lt;/a&gt;する必要があります。</target>
        </trans-unit>
        <trans-unit id="4f0d56c46129caef4c0e06f3c8334481a847bd34" translate="yes" xml:space="preserve">
          <source>Note: unlike Java, arrays in Kotlin are invariant. This means that Kotlin does not let us assign an &lt;code&gt;Array&amp;lt;String&amp;gt;&lt;/code&gt; to an &lt;code&gt;Array&amp;lt;Any&amp;gt;&lt;/code&gt;, which prevents a possible runtime failure (but you can use &lt;code&gt;Array&amp;lt;out Any&amp;gt;&lt;/code&gt;, see &lt;a href=&quot;generics#type-projections&quot;&gt;Type Projections&lt;/a&gt;).</source>
          <target state="translated">注：Javaとは異なり、Kotlinの配列は不変です。つまり、Kotlinは &lt;code&gt;Array&amp;lt;String&amp;gt;&lt;/code&gt; を &lt;code&gt;Array&amp;lt;Any&amp;gt;&lt;/code&gt; に割り当てることができないため、実行時の失敗を防ぐことができます（ただし、 &lt;code&gt;Array&amp;lt;out Any&amp;gt;&lt;/code&gt; 使用できます。&lt;a href=&quot;generics#type-projections&quot;&gt;型の射影を&lt;/a&gt;参照してください）。</target>
        </trans-unit>
        <trans-unit id="70440046a3dc2e079f23ee1c57dfa76669b732aa" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">Notes</target>
        </trans-unit>
        <trans-unit id="4481948392a8846400c954e77f58d76cdaa73963" translate="yes" xml:space="preserve">
          <source>Nothing</source>
          <target state="translated">Nothing</target>
        </trans-unit>
        <trans-unit id="79090fccdb94d09e1c560c62dc8ff6d888bc7489" translate="yes" xml:space="preserve">
          <source>Nothing has no instances. You can use Nothing to represent &quot;a value that never exists&quot;: for example, if a function has the return type of Nothing, it means that it never returns (always throws an exception).</source>
          <target state="translated">Nothingにはインスタンスがありません。Nothingを使って「存在しない値」を表現することができます:例えば、関数がNothingのreturn型を持っている場合、それは決して返さない(常に例外を投げる)ことを意味します。</target>
        </trans-unit>
        <trans-unit id="a531e5857d96a6fe172e33a54636fa2c5e7837a4" translate="yes" xml:space="preserve">
          <source>Notice that the implementation on &lt;em&gt;every&lt;/em&gt; platform can encode byte arrays to a string. If we want we can provide a more efficient implementation for this method, for example, let's specialize it on the JVM:</source>
          <target state="translated">&lt;em&gt;すべての&lt;/em&gt;プラットフォームの実装がバイト配列を文字列にエンコードできることに注意してください。たとえば、このメソッドをより効率的に実装できるようにしたい場合は、JVMに特化します。</target>
        </trans-unit>
        <trans-unit id="ac46cd6bf2ec7e9d90f5e3709af6c843ffd8a6af" translate="yes" xml:space="preserve">
          <source>NotificationAction</source>
          <target state="translated">NotificationAction</target>
        </trans-unit>
        <trans-unit id="f541255e0e0d091ef01be7d639674756d30f41bc" translate="yes" xml:space="preserve">
          <source>NotificationDirection</source>
          <target state="translated">NotificationDirection</target>
        </trans-unit>
        <trans-unit id="596349e0f504aa4e6ec1f31115a62914042449e8" translate="yes" xml:space="preserve">
          <source>NotificationEventInit</source>
          <target state="translated">NotificationEventInit</target>
        </trans-unit>
        <trans-unit id="2a1a4c24d8e083b47b4ff678b4cd0997219c060e" translate="yes" xml:space="preserve">
          <source>NotificationOptions</source>
          <target state="translated">NotificationOptions</target>
        </trans-unit>
        <trans-unit id="93c639dc73db96edc66ede2299276f652971fac6" translate="yes" xml:space="preserve">
          <source>NotificationPermission</source>
          <target state="translated">NotificationPermission</target>
        </trans-unit>
        <trans-unit id="94e838061a82a5ce0b113db3557cf9f9730866ea" translate="yes" xml:space="preserve">
          <source>Now check it with the command &lt;code&gt;./gradlew publishToMavenLocal&lt;/code&gt; and you should see a successful build. That's it, our library is now successfully published and any Kotlin project can depend on it, whether it is another common library, JVM, JS, or Native application.</source>
          <target state="translated">コマンド &lt;code&gt;./gradlew publishToMavenLocal&lt;/code&gt; で確認すると、正常にビルドされているはずです。これで、ライブラリは正常に公開され、Kotlinプロジェクトは、別の共通ライブラリ、JVM、JS、ネイティブアプリケーションのいずれであっても、それに依存できます。</target>
        </trans-unit>
        <trans-unit id="4c6fdd021c50c395969a31c37923d25d734b30ed" translate="yes" xml:space="preserve">
          <source>Now compile the program linking with the library we have just created:</source>
          <target state="translated">では、先ほど作成したライブラリとリンクするプログラムをコンパイルしてみましょう。</target>
        </trans-unit>
        <trans-unit id="7fd938355a267ec17f411c8d98d04708e4180da6" translate="yes" xml:space="preserve">
          <source>Now it is time to provide an &lt;code&gt;actual&lt;/code&gt; implementation of &lt;code&gt;Base64Factory&lt;/code&gt; for every platform.</source>
          <target state="translated">今度は、すべてのプラットフォームに &lt;code&gt;Base64Factory&lt;/code&gt; の &lt;code&gt;actual&lt;/code&gt; 実装を提供する時です。</target>
        </trans-unit>
        <trans-unit id="ef159996af2b9215562c38a942c2f8905195f55d" translate="yes" xml:space="preserve">
          <source>Now it is time to refresh the Gradle project again in Android Studio. Click &lt;em&gt;Sync Now&lt;/em&gt; on the yellow stripe or use the &lt;em&gt;Gradle&lt;/em&gt; tool window and click the &lt;code&gt;Refresh&lt;/code&gt; action in the context menu on the root Gradle project. The &lt;code&gt;:SharedCode&lt;/code&gt; project should be recognized by the IDE now.</source>
          <target state="translated">次に、Android StudioでGradleプロジェクトを再度更新します。黄色のストライプで[ &lt;em&gt;今すぐ同期&lt;/em&gt; ]をクリックするか、&lt;em&gt;Gradle&lt;/em&gt;ツールウィンドウを使用して、ルートGradleプロジェクトのコンテキストメニューで[ &lt;code&gt;Refresh&lt;/code&gt; ] アクションをクリックします。 &lt;code&gt;:SharedCode&lt;/code&gt; のプロジェクトは現在、IDEによって認識されるべきです。</target>
        </trans-unit>
        <trans-unit id="9eb8c10ce256de217fd7408c5d0fa2be1c81f16b" translate="yes" xml:space="preserve">
          <source>Now it is time to see how to use &lt;code&gt;cValue&lt;/code&gt; and pass by-value parameters:</source>
          <target state="translated">次に、 &lt;code&gt;cValue&lt;/code&gt; を使用して値渡しパラメーターを渡す方法を確認します。</target>
        </trans-unit>
        <trans-unit id="f62049422e34abdef8fb40e736ddaa894413b1d4" translate="yes" xml:space="preserve">
          <source>Now it prints something sensible: &lt;code&gt;1784293664&lt;/code&gt;, because all coroutines complete.</source>
          <target state="translated">すべてのコルーチンが完了しているため、現在は &lt;code&gt;1784293664&lt;/code&gt; のように賢明なものを出力しています。</target>
        </trans-unit>
        <trans-unit id="144f2d2ebae18220179fd1c455d34a68896fdfc7" translate="yes" xml:space="preserve">
          <source>Now it prints something sensible: &lt;code&gt;500000500000&lt;/code&gt;, because all coroutines complete.</source>
          <target state="translated">Now it prints something sensible: &lt;code&gt;500000500000&lt;/code&gt; , because all coroutines complete.</target>
        </trans-unit>
        <trans-unit id="9c3c5f110103dcae6c7a1c5048ae4801a489102c" translate="yes" xml:space="preserve">
          <source>Now it's time to add the task description. Click the &lt;strong&gt;Edit&lt;/strong&gt; icon at the top of &lt;strong&gt;Task Description&lt;/strong&gt; panel to switch to the editing mode:</source>
          <target state="translated">次に、タスクの説明を追加します。&lt;strong&gt;タスクの説明&lt;/strong&gt;パネルの上部にある&lt;strong&gt;編集&lt;/strong&gt;アイコンをクリックして、編集モードに切り替えます。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f21a6f3ded0ce3ad0d37be7f610a6bcde3237278" translate="yes" xml:space="preserve">
          <source>Now let us launch five processors and let them work for almost a second. See what happens:</source>
          <target state="translated">では、5つのプロセッサを起動して、ほぼ1秒間動作させてみましょう。何が起こるか見てみましょう。</target>
        </trans-unit>
        <trans-unit id="3a85707fc6ed973d97aee272da025f72a2062245" translate="yes" xml:space="preserve">
          <source>Now let's check out the contents of the library:</source>
          <target state="translated">では、図書館の中身をチェックしてみましょう。</target>
        </trans-unit>
        <trans-unit id="06f1756ff063bdd720deb57bebdc098cbb1f3682" translate="yes" xml:space="preserve">
          <source>Now let's open the project in IntelliJ IDEA. For that we click on the File | Open&amp;hellip; and select our &lt;code&gt;build.gradle.kts&lt;/code&gt;&lt;code&gt;build.gradle&lt;/code&gt; project file.</source>
          <target state="translated">次に、IntelliJ IDEAでプロジェクトを開きます。そのために、ファイルをクリックします。開いて&amp;hellip; &lt;code&gt;build.gradle.kts&lt;/code&gt; &lt;code&gt;build.gradle&lt;/code&gt; プロジェクトファイルを選択します。</target>
        </trans-unit>
        <trans-unit id="62863dbb3bcee301c0e208573e6e92993330cf1e" translate="yes" xml:space="preserve">
          <source>Now let's see how it works in practice:</source>
          <target state="translated">では、実際にどのような効果があるのか見てみましょう。</target>
        </trans-unit>
        <trans-unit id="316006c9bf1b6b4efc24b9287e973de18a0cd5b2" translate="yes" xml:space="preserve">
          <source>Now let's write the same with sequences:</source>
          <target state="translated">今度はシーケンスで同じように書いてみましょう。</target>
        </trans-unit>
        <trans-unit id="a94f1a0ca142aa8eb48c8af48afa3350f83b1400" translate="yes" xml:space="preserve">
          <source>Now need to create an empty &lt;code&gt;settings.gradle.kts&lt;/code&gt;&lt;code&gt;settings.gradle&lt;/code&gt; file in the project root directory.</source>
          <target state="translated">次に、プロジェクトのルートディレクトリに空の &lt;code&gt;settings.gradle.kts&lt;/code&gt; &lt;code&gt;settings.gradle&lt;/code&gt; ファイルを作成する必要があります。</target>
        </trans-unit>
        <trans-unit id="6c9080cd76ec0143ae2c7fdafc332586543b3c8a" translate="yes" xml:space="preserve">
          <source>Now the application is ready to run. The easiest way is to click the green &lt;strong&gt;Run&lt;/strong&gt; icon in the gutter and select &lt;strong&gt;Run 'AppKt'&lt;/strong&gt;.</source>
          <target state="translated">これで、アプリケーションを実行する準備ができました。最も簡単な方法は、ガターの緑色の&lt;strong&gt;実行&lt;/strong&gt;アイコンをクリックして、&lt;strong&gt;「AppKtを実行」&lt;/strong&gt;を選択することです。</target>
        </trans-unit>
        <trans-unit id="a4dea9f6780cb4b1fb116abe461c884b2fc3e6f5" translate="yes" xml:space="preserve">
          <source>Now the classic &lt;code&gt;maven-publish&lt;/code&gt; Gradle &lt;a href=&quot;https://docs.gradle.org/current/userguide/publishing_maven.html&quot;&gt;plugin&lt;/a&gt; can be used. Don't forget to specify the group and version of your library along with the plugin in &lt;code&gt;build.gradle&lt;/code&gt;:</source>
          <target state="translated">これで、古典的な &lt;code&gt;maven-publish&lt;/code&gt; Gradle &lt;a href=&quot;https://docs.gradle.org/current/userguide/publishing_maven.html&quot;&gt;プラグイン&lt;/a&gt;を使用できます。 &lt;code&gt;build.gradle&lt;/code&gt; でプラグインとともにライブラリのグループとバージョンを指定することを忘れないでください：</target>
        </trans-unit>
        <trans-unit id="c36da2f63965003675ecd4f90e9e76c88deea8db" translate="yes" xml:space="preserve">
          <source>Now the main function awaits for the first of them to complete and counts the number of deferred values that are still active. Note that we've used here the fact that &lt;code&gt;select&lt;/code&gt; expression is a Kotlin DSL, so we can provide clauses for it using an arbitrary code. In this case we iterate over a list of deferred values to provide &lt;code&gt;onAwait&lt;/code&gt; clause for each deferred value.</source>
          <target state="translated">これで、メイン関数は最初の関数が完了するのを待って、まだアクティブな遅延値の数をカウントします。ここでは、 &lt;code&gt;select&lt;/code&gt; 式がKotlin DSLであるという事実を使用しているため、任意のコードを使用してその句を提供できることに注意してください。この場合、遅延値のリストを反復処理して、各遅延値に &lt;code&gt;onAwait&lt;/code&gt; 句を提供します。</target>
        </trans-unit>
        <trans-unit id="fafa6b7e1e97bd8d0310f07c3ffc916e9bc52c4e" translate="yes" xml:space="preserve">
          <source>Now the result is still the same, but the code of the main coroutine is not tied to the duration of the background job in any way. Much better.</source>
          <target state="translated">これで結果は変わりませんが、メインのコルーチンのコードはバックグラウンドジョブの期間とは関係ありません。だいぶ良くなりました。</target>
        </trans-unit>
        <trans-unit id="68e76914b57b2c484d2fcdeac9dacb63ea15843e" translate="yes" xml:space="preserve">
          <source>Now we are ready to &lt;a href=&quot;basic-kotlin-native-app#open-in-ide&quot;&gt;open the project in IntelliJ IDEA&lt;/a&gt; and to see how to fix the example project. While doing that, we'll examine how C functions are mapped into Kotlin/Native declarations.</source>
          <target state="translated">これ&lt;a href=&quot;basic-kotlin-native-app#open-in-ide&quot;&gt;で、IntelliJ IDEAでプロジェクト&lt;/a&gt;を開き、サンプルプロジェクトを修正する方法を確認する準備ができました。その際、C関数がKotlin / Native宣言にどのようにマップされるかを調べます。</target>
        </trans-unit>
        <trans-unit id="0cc37329b152a7d48d832f02d3782a3273c9a922" translate="yes" xml:space="preserve">
          <source>Now we are ready to &lt;a href=&quot;basic-kotlin-native-app#open-in-ide&quot;&gt;open the project in IntelliJ IDEA&lt;/a&gt; and to see how to fix the example project. While doing that, we'll examine how C primitive types are mapped into Kotlin/Native.</source>
          <target state="translated">これ&lt;a href=&quot;basic-kotlin-native-app#open-in-ide&quot;&gt;で、IntelliJ IDEAでプロジェクト&lt;/a&gt;を開き、サンプルプロジェクトを修正する方法を確認する準備ができました。その際、Cプリミティブ型がKotlin / Nativeにどのようにマップされるかを調べます。</target>
        </trans-unit>
        <trans-unit id="280651c06a20fde5cc37b475316ca2430a0a1d40" translate="yes" xml:space="preserve">
          <source>Now we are ready to &lt;a href=&quot;basic-kotlin-native-app#open-in-ide&quot;&gt;open the project in IntelliJ IDEA&lt;/a&gt; and to see how to fix the example project. While doing this, we'll examine how C functions are mapped into Kotlin/Native declarations.</source>
          <target state="translated">これ&lt;a href=&quot;basic-kotlin-native-app#open-in-ide&quot;&gt;で、IntelliJ IDEAでプロジェクト&lt;/a&gt;を開き、サンプルプロジェクトを修正する方法を確認する準備ができました。これを行いながら、C関数がKotlin / Native宣言にどのようにマップされるかを調べます。</target>
        </trans-unit>
        <trans-unit id="323fc12d5da11d2d2fc025d2cb42257bb510df5c" translate="yes" xml:space="preserve">
          <source>Now we are ready to &lt;a href=&quot;using-intellij-idea&quot;&gt;open the project in IntelliJ IDEA&lt;/a&gt; and to see how to fix the example project. While doing that, we'll examine how C functions are mapped into Kotlin/Native declarations.</source>
          <target state="translated">Now we are ready to &lt;a href=&quot;using-intellij-idea&quot;&gt;open the project in IntelliJ IDEA&lt;/a&gt; and to see how to fix the example project. While doing that, we'll examine how C functions are mapped into Kotlin/Native declarations.</target>
        </trans-unit>
        <trans-unit id="b20c24d185e4d030be0d0a6f1a94b265b8692d27" translate="yes" xml:space="preserve">
          <source>Now we are ready to &lt;a href=&quot;using-intellij-idea&quot;&gt;open the project in IntelliJ IDEA&lt;/a&gt; and to see how to fix the example project. While doing that, we'll examine how C primitive types are mapped into Kotlin/Native.</source>
          <target state="translated">Now we are ready to &lt;a href=&quot;using-intellij-idea&quot;&gt;open the project in IntelliJ IDEA&lt;/a&gt; and to see how to fix the example project. While doing that, we'll examine how C primitive types are mapped into Kotlin/Native.</target>
        </trans-unit>
        <trans-unit id="3c161d0d7217a9d942a7808aa2fde773f92818a9" translate="yes" xml:space="preserve">
          <source>Now we are ready to &lt;a href=&quot;using-intellij-idea&quot;&gt;open the project in IntelliJ IDEA&lt;/a&gt; and to see how to fix the example project. While doing this, we'll examine how C functions are mapped into Kotlin/Native declarations.</source>
          <target state="translated">Now we are ready to &lt;a href=&quot;using-intellij-idea&quot;&gt;open the project in IntelliJ IDEA&lt;/a&gt; and to see how to fix the example project. While doing this, we'll examine how C functions are mapped into Kotlin/Native declarations.</target>
        </trans-unit>
        <trans-unit id="8514872c5f66d71d839c86ef7b8ede3a7f8b037f" translate="yes" xml:space="preserve">
          <source>Now we are ready to compile our &lt;code&gt;main.c&lt;/code&gt; into an executable. We include the generated &lt;code&gt;libnative.lib&lt;/code&gt; into the build command and start:</source>
          <target state="translated">これで、 &lt;code&gt;main.c&lt;/code&gt; を実行可能ファイルにコンパイルする準備ができました。生成された &lt;code&gt;libnative.lib&lt;/code&gt; をビルドコマンドに含めて開始します。</target>
        </trans-unit>
        <trans-unit id="bd615a740472938a27e61f3e5ad1d8c088398a62" translate="yes" xml:space="preserve">
          <source>Now we build our pipeline by starting a stream of numbers from 2, taking a prime number from the current channel, and launching new pipeline stage for each prime number found:</source>
          <target state="translated">現在のチャンネルから素数を取り出し、素数が見つかるたびに新しいパイプラインを起動することで、パイプラインを構築します。</target>
        </trans-unit>
        <trans-unit id="b09d5a8ac24e62ac515e5408d015b6449705f5ff" translate="yes" xml:space="preserve">
          <source>Now we have implementations on all the platforms and it is time to move to testing of our library.</source>
          <target state="translated">これですべてのプラットフォームでの実装が完了したので、いよいよライブラリのテストに移ります。</target>
        </trans-unit>
        <trans-unit id="6fc43d604b99f2dfefc014ae5ff71405690d454a" translate="yes" xml:space="preserve">
          <source>Now we have learned how to use C declarations in our code, we are ready to try it out on a real example. Let's fix our code and see how it runs by calling the &lt;code&gt;runDebugExecutableNative&lt;/code&gt; Gradle task &lt;a href=&quot;basic-kotlin-native-app#run-in-ide&quot;&gt;in the IDE&lt;/a&gt; or by using the following console command:</source>
          <target state="translated">コードでC宣言を使用する方法を学習したので、実際の例でそれを試す準備ができました。コードを修正&lt;a href=&quot;basic-kotlin-native-app#run-in-ide&quot;&gt;して、IDEで&lt;/a&gt; &lt;code&gt;runDebugExecutableNative&lt;/code&gt; Gradleタスクを呼び出すか、次のコンソールコマンドを使用して、コードがどのように実行されるかを見てみましょう。</target>
        </trans-unit>
        <trans-unit id="50d459965bcc6d81fd4d90553a544db8ca2bdb40" translate="yes" xml:space="preserve">
          <source>Now we have learned how to use C declarations in our code, we are ready to try it out on a real example. Let's fix our code and see how it runs by calling the &lt;code&gt;runDebugExecutableNative&lt;/code&gt; Gradle task &lt;a href=&quot;using-intellij-idea&quot;&gt;in the IDE&lt;/a&gt; or by using the following console command:</source>
          <target state="translated">Now we have learned how to use C declarations in our code, we are ready to try it out on a real example. Let's fix our code and see how it runs by calling the &lt;code&gt;runDebugExecutableNative&lt;/code&gt; Gradle task &lt;a href=&quot;using-intellij-idea&quot;&gt;in the IDE&lt;/a&gt; or by using the following console command:</target>
        </trans-unit>
        <trans-unit id="dcdaca8bf7117a3b069ebd97d9d500bbee893084" translate="yes" xml:space="preserve">
          <source>Now we have our library and Kotlin stubs, we can consume them from our application. To keep things simple, in this tutorial we're going to convert one of the simplest &lt;code&gt;libcurl&lt;/code&gt; examples over to Kotlin.</source>
          <target state="translated">これでライブラリとKotlinスタブができたので、アプリケーションからそれらを使用できます。物事をシンプルに保つために、このチュートリアルでは、最も単純な &lt;code&gt;libcurl&lt;/code&gt; の例の1つをKotlin に変換します。</target>
        </trans-unit>
        <trans-unit id="56a410308bdaa182b925a6dff7fc3ba66711f037" translate="yes" xml:space="preserve">
          <source>Now we have the &lt;code&gt;TextView&lt;/code&gt; that will show us the text created by the shared code function &lt;code&gt;createApplicationScreenMessage()&lt;/code&gt;. It shows &lt;code&gt;Kotlin Rocks on Android&lt;/code&gt;. Let's see how it works.</source>
          <target state="translated">これで、共有コード関数 &lt;code&gt;createApplicationScreenMessage()&lt;/code&gt; によって作成されたテキストを表示する &lt;code&gt;TextView&lt;/code&gt; ができました。それは示し &lt;code&gt;Kotlin Rocks on Android&lt;/code&gt; 。それがどのように機能するか見てみましょう。</target>
        </trans-unit>
        <trans-unit id="ff70a609caee6a29932d7e21240cf4b92c28370c" translate="yes" xml:space="preserve">
          <source>Now we need to define the classes and interfaces we want to implement. Create the file &lt;code&gt;Base64.kt&lt;/code&gt; in the &lt;code&gt;commonMain/kotlin/jetbrains/base64&lt;/code&gt; folder. Core primitive will be the &lt;code&gt;Base64Encoder&lt;/code&gt; interface which knows how to convert bytes to bytes in &lt;code&gt;Base64&lt;/code&gt; format:</source>
          <target state="translated">次に、実装したいクラスとインターフェースを定義する必要があります。 &lt;code&gt;commonMain/kotlin/jetbrains/base64&lt;/code&gt; フォルダーにファイル &lt;code&gt;Base64.kt&lt;/code&gt; を作成します。コアプリミティブは、バイトを &lt;code&gt;Base64&lt;/code&gt; 形式のバイトに変換する方法を知っている &lt;code&gt;Base64Encoder&lt;/code&gt; インターフェイスです。</target>
        </trans-unit>
        <trans-unit id="6ca6511b451c4bb08b2161576b6d00b309bd636f" translate="yes" xml:space="preserve">
          <source>Now we need to explain to Xcode, where to look for frameworks. We need to add the &lt;em&gt;relative&lt;/em&gt; path &lt;code&gt;$(SRCROOT)/../../SharedCode/build/xcode-frameworks&lt;/code&gt; into the &lt;em&gt;Search Paths | Framework Search Paths&lt;/em&gt; section. Open the &lt;em&gt;Build Settings&lt;/em&gt; tab again, pick the &lt;em&gt;All&lt;/em&gt; sub-tab below, and type the &lt;em&gt;Framework Search Paths&lt;/em&gt; into the search field to easily find the option. Xcode will then show the substituted path in the UI for it.</source>
          <target state="translated">次に、フレームワークを探す場所をXcodeに説明する必要があります。&lt;em&gt;相対&lt;/em&gt;パス &lt;code&gt;$(SRCROOT)/../../SharedCode/build/xcode-frameworks&lt;/code&gt; を&lt;em&gt;検索パス&lt;/em&gt;に追加する必要があります&lt;em&gt;| &lt;/em&gt;&lt;em&gt;フレームワーク検索パス&lt;/em&gt;セクション。[ &lt;em&gt;ビルド設定&lt;/em&gt; ]タブを再度開き、下の[ &lt;em&gt;すべて&lt;/em&gt;&lt;em&gt;]&lt;/em&gt;サブタブを選択し、検索フィールドに&lt;em&gt;フレームワーク検索パス&lt;/em&gt;を入力して、オプションを簡単に見つけます。Xcodeは、UIに代替パスを表示します。</target>
        </trans-unit>
        <trans-unit id="bbdba5d4735168e3785e68f7843040b781bf6309" translate="yes" xml:space="preserve">
          <source>Now when we call &lt;code&gt;workload()&lt;/code&gt; from a coroutine, the compiler knows that it may suspend and will prepare accordingly:</source>
          <target state="translated">これで、コルーチンからworkload &lt;code&gt;workload()&lt;/code&gt; を呼び出すと、コンパイラはそれが一時停止する可能性があることを認識し、それに応じて準備します。</target>
        </trans-unit>
        <trans-unit id="1d24cd9e38cbefb079dd50a49d7d7f03311c7bf3" translate="yes" xml:space="preserve">
          <source>Now you are ready to create a new Kotlin project.</source>
          <target state="translated">これで新しいKotlinプロジェクトを作成する準備が整いました。</target>
        </trans-unit>
        <trans-unit id="290dbe288d985515eeabffa880759f9b6702dbd0" translate="yes" xml:space="preserve">
          <source>Now you can declare a dependency on a Kotlin/Native library in the traditional &lt;code&gt;group:artifact:version&lt;/code&gt; notation:</source>
          <target state="translated">これで、従来の &lt;code&gt;group:artifact:version&lt;/code&gt; 表記でKotlin / Nativeライブラリへの依存関係を宣言できます。</target>
        </trans-unit>
        <trans-unit id="21f7ffde9424834101062b3a3b4388e5becd0386" translate="yes" xml:space="preserve">
          <source>Now you can publish the artifacts with the standard Gradle &lt;code&gt;publish&lt;/code&gt; task:</source>
          <target state="translated">これで、標準のGradle &lt;code&gt;publish&lt;/code&gt; タスクでアーティファクトを公開できます。</target>
        </trans-unit>
        <trans-unit id="1f0e0a97af9c78bc7052cbc7558b0c5721564a3e" translate="yes" xml:space="preserve">
          <source>Now you can use this class from JavaScript in the following way:</source>
          <target state="translated">これでこのクラスをJavaScriptから以下のように使うことができるようになりました。</target>
        </trans-unit>
        <trans-unit id="d5043215278e17616ae1356fe9712ab2361ec4d2" translate="yes" xml:space="preserve">
          <source>Now you have the new project created with the following folder structure:</source>
          <target state="translated">これで、以下のようなフォルダ構造で新しいプロジェクトが作成されました。</target>
        </trans-unit>
        <trans-unit id="3e24bac49840414b90995c5cbd33ee7b86539a1d" translate="yes" xml:space="preserve">
          <source>Now you're ready to start learning. Read the first task description and the exercise code. You will find a placeholder in the exercise code which you need to complete to solve the task:</source>
          <target state="translated">これで学習を始める準備ができました。最初のタスクの説明と練習問題のコードを読んでください。演習コードの中には、タスクを解くために必要なプレースホルダがあります。</target>
        </trans-unit>
        <trans-unit id="5cb44051b734fae4af55ffe5224978dec7c87251" translate="yes" xml:space="preserve">
          <source>Now, &lt;code&gt;callStatic()&lt;/code&gt; is static in Java, while &lt;code&gt;callNonStatic()&lt;/code&gt; is not:</source>
          <target state="translated">現在、 &lt;code&gt;callStatic()&lt;/code&gt; はJavaでは静的ですが、 &lt;code&gt;callNonStatic()&lt;/code&gt; はそうではありません。</target>
        </trans-unit>
        <trans-unit id="a13d0fb128d24db7d3bb5f2f36926ba1c128f4f2" translate="yes" xml:space="preserve">
          <source>Now, &lt;em&gt;this&lt;/em&gt; can be omitted, as usual, and we get something that looks very much like a builder already:</source>
          <target state="translated">これで、&lt;em&gt;これ&lt;/em&gt;は通常どおり省略でき、すでにビルダーに非常によく似たものが得られます。</target>
        </trans-unit>
        <trans-unit id="f0a82c0a40d22072db820930c190224b73ea978f" translate="yes" xml:space="preserve">
          <source>Now, all is left is to write the main function that reads the input and implements the rest of the algorithm that the problem statement asks for &amp;mdash; to compute the number of different integers that are produced while repeatedly applying function &lt;code&gt;f&lt;/code&gt; to the initial number &lt;code&gt;n&lt;/code&gt; that is given in the standard input.</source>
          <target state="translated">繰り返し機能を付与しながら製造されている異なる整数の数を計算するために-今、残っているすべては、問題文がを要求することを、アルゴリズムの残りの入力や道具を読み込み、メイン関数を記述することである &lt;code&gt;f&lt;/code&gt; 初期値に &lt;code&gt;n&lt;/code&gt; 個あることを標準入力で与えられます。</target>
        </trans-unit>
        <trans-unit id="fb6047e18f4bc8d11bc30e4fd65fb8d503da1662" translate="yes" xml:space="preserve">
          <source>Now, if you call a method or access a property on &lt;code&gt;a&lt;/code&gt;, it's guaranteed not to cause an NPE, so you can safely say:</source>
          <target state="translated">あなたがメソッドを呼び出すかのプロパティにアクセスする場合さて、あなたは安全に言うことができるので、NPEが発生しないことが保証です。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="20f3d5cd33eec60a8a8002b141a9b28a6b9b7682" translate="yes" xml:space="preserve">
          <source>Now, if you do:</source>
          <target state="translated">さて、そうすると</target>
        </trans-unit>
        <trans-unit id="f71ccd18f05da02b03c8a2c32b3e5cdf31e2366b" translate="yes" xml:space="preserve">
          <source>Now, if you open DevTools, you should see both JavaScript and Kotlin files in Sources tab, as shown in the picture below.</source>
          <target state="translated">さて、DevToolsを開くと、下の図のようにSourcesタブにJavaScriptとKotlinの両方のファイルが表示されているはずです。</target>
        </trans-unit>
        <trans-unit id="a83d9e77f9456d18d8a05fd327f1e236de7060bd" translate="yes" xml:space="preserve">
          <source>Now, if you rebuild the project, you should see both &lt;code&gt;.js&lt;/code&gt; and &lt;code&gt;.js.map&lt;/code&gt; files generated.</source>
          <target state="translated">これで、プロジェクトを再ビルドすると、生成された &lt;code&gt;.js&lt;/code&gt; ファイルと &lt;code&gt;.js.map&lt;/code&gt; ファイルの両方が表示されます。</target>
        </trans-unit>
        <trans-unit id="76f6cc5aafdabd68e55d4250b74b32cd977c308a" translate="yes" xml:space="preserve">
          <source>Now, it returns only from the lambda expression. Oftentimes it is more convenient to use implicit labels: such a label has the same name as the function to which the lambda is passed.</source>
          <target state="translated">これで、ラムダ式からのみ返されるようになりました。暗黙のラベルを使った方が便利なことがよくあります:このようなラベルはラムダが渡される関数と同じ名前を持ちます。</target>
        </trans-unit>
        <trans-unit id="94f815aeffcc5ac17241b513b6e20a9f1cdaea31" translate="yes" xml:space="preserve">
          <source>Now, let us see what happens if we launch a couple of coroutines sending strings (in this example we launch them in the context of the main thread as main coroutine's children):</source>
          <target state="translated">さて、文字列を送信するいくつかのコルーチンを起動するとどうなるか見てみましょう(この例では、メインスレッドのコンテキストでメインコルーチンの子として起動しています)。</target>
        </trans-unit>
        <trans-unit id="71d025254fd20926043d356611276f9c88403338" translate="yes" xml:space="preserve">
          <source>Now, let's make sure that coroutines are really cheaper than threads. How about starting a million of them? Let's try starting a million threads first:</source>
          <target state="translated">さて、スレッドよりもコアチンの方が本当に安いのかを確認してみましょう。100万個のスレッドを立ち上げてみるのはどうでしょうか?まずは100万個のスレッドを起動してみましょう。</target>
        </trans-unit>
        <trans-unit id="16dd7a2ec4c182b0f69f31fe9543eb28189fc230" translate="yes" xml:space="preserve">
          <source>Now, let's recall why we can say something like this in the code:</source>
          <target state="translated">では、なぜこのようなことをコードで言えるのかを思い出してみましょう。</target>
        </trans-unit>
        <trans-unit id="544d487017d11ee4001cb80b112987fd1c122959" translate="yes" xml:space="preserve">
          <source>Now, let's say we want to extract our &lt;em&gt;workload&lt;/em&gt; (which is &quot;wait 1 second and return a number&quot;) into a separate function:</source>
          <target state="translated">ここで、&lt;em&gt;ワークロード&lt;/em&gt;（「1秒待って数値を返す」）を別の関数に抽出するとします。</target>
        </trans-unit>
        <trans-unit id="c750281f584acadba2af58cffcc8c1305b106c0d" translate="yes" xml:space="preserve">
          <source>Now, the type parameter of &lt;code&gt;to&lt;/code&gt; must be a supertype of that of &lt;code&gt;from&lt;/code&gt;. This time, we're losing the ability to call &lt;code&gt;get()&lt;/code&gt; on &lt;code&gt;to&lt;/code&gt;.</source>
          <target state="translated">ここで、 &lt;code&gt;to&lt;/code&gt; の型パラメーターは、 &lt;code&gt;from&lt;/code&gt; のスーパータイプでなければなりません。今回は、呼び出す機能失っている &lt;code&gt;get()&lt;/code&gt; は上 &lt;code&gt;to&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="66aa36fc01590becc140967b82e52fb54836cefb" translate="yes" xml:space="preserve">
          <source>Now, try that with threads. What would happen? (Most likely your code will produce some sort of out-of-memory error)</source>
          <target state="translated">では、それをスレッドで試してみてください。何が起こるでしょうか?(たいていの場合、あなたのコードはある種のメモリ切れのエラーを出すでしょう)</target>
        </trans-unit>
        <trans-unit id="43de32521253364ea5d09558750dd9502168f58f" translate="yes" xml:space="preserve">
          <source>Now, we can launch coroutines in the scope of this &lt;code&gt;Activity&lt;/code&gt; using the defined &lt;code&gt;scope&lt;/code&gt;. For the demo, we launch ten coroutines that delay for a different time:</source>
          <target state="translated">Now, we can launch coroutines in the scope of this &lt;code&gt;Activity&lt;/code&gt; using the defined &lt;code&gt;scope&lt;/code&gt; . For the demo, we launch ten coroutines that delay for a different time:</target>
        </trans-unit>
        <trans-unit id="841ea7e84248eb13447bb49e5c5c6dbc24123f33" translate="yes" xml:space="preserve">
          <source>Now, we can launch coroutines in the scope of this &lt;code&gt;Activity&lt;/code&gt; without having to explicitly specify their context. For the demo, we launch ten coroutines that delay for a different time:</source>
          <target state="translated">これで、コンテキストを明示的に指定しなくても、この &lt;code&gt;Activity&lt;/code&gt; のスコープでコルーチンを起動できます。デモでは、異なる時間遅延する10個のコルーチンを起動します。</target>
        </trans-unit>
        <trans-unit id="b7b794f9844126d9635b31ec7a7259faff61ea34" translate="yes" xml:space="preserve">
          <source>Now, we can qualify a &lt;em&gt;break&lt;/em&gt; or a &lt;em&gt;continue&lt;/em&gt; with a label:</source>
          <target state="translated">これで、ラベルで&lt;em&gt;中断&lt;/em&gt;または&lt;em&gt;継続&lt;/em&gt;を修飾できます。</target>
        </trans-unit>
        <trans-unit id="4009ace22d0b31f5461708301ff321a7b41e34f1" translate="yes" xml:space="preserve">
          <source>Now, we need to create the implementation file (and missing directories) for Android in the &lt;code&gt;SharedCode/src/androidMain/kotlin/actual.kt&lt;/code&gt;:</source>
          <target state="translated">次に、 &lt;code&gt;SharedCode/src/androidMain/kotlin/actual.kt&lt;/code&gt; にAndroidの実装ファイル（および不足しているディレクトリ）を作成する必要があります。</target>
        </trans-unit>
        <trans-unit id="cc32792e1ffb6994d09d3ccc5850fcde297ab5b1" translate="yes" xml:space="preserve">
          <source>Now, whenever anyone reads &lt;code&gt;p.name&lt;/code&gt;, &lt;code&gt;getValue()&lt;/code&gt; will be invoked with &lt;code&gt;p&lt;/code&gt; as &lt;code&gt;thisRef&lt;/code&gt; and metadata about the &lt;code&gt;name&lt;/code&gt; property as &lt;code&gt;property&lt;/code&gt;. Since &lt;code&gt;thisRef&lt;/code&gt; is a &lt;code&gt;DbModel&lt;/code&gt;, this delegated property can only be used inside &lt;code&gt;DbModel&lt;/code&gt; and its subclasses.</source>
          <target state="translated">これで、誰かが &lt;code&gt;p.name&lt;/code&gt; を読み取ると、 &lt;code&gt;getValue()&lt;/code&gt; が &lt;code&gt;thisRef&lt;/code&gt; として &lt;code&gt;p&lt;/code&gt; を、 &lt;code&gt;name&lt;/code&gt; プロパティに関するメタデータをpropertyとして呼び出され &lt;code&gt;property&lt;/code&gt; 。以来 &lt;code&gt;thisRef&lt;/code&gt; がある &lt;code&gt;DbModel&lt;/code&gt; 、この委任プロパティは内部で使用することができる &lt;code&gt;DbModel&lt;/code&gt; とそのサブクラス。</target>
        </trans-unit>
        <trans-unit id="1ddfae4b18596b2854071f83733087767ffb2d01" translate="yes" xml:space="preserve">
          <source>Now, you can do:</source>
          <target state="translated">これで、できるようになりました。</target>
        </trans-unit>
        <trans-unit id="c62d757ce7f75d3f121e4c4fec1867b7958bd009" translate="yes" xml:space="preserve">
          <source>Now, you can no longer say &lt;code&gt;val mv = MotorVehicle(100, 4)&lt;/code&gt;.</source>
          <target state="translated">これで、 &lt;code&gt;val mv = MotorVehicle(100, 4)&lt;/code&gt; と言うことはできなくなりました。</target>
        </trans-unit>
        <trans-unit id="6c97d282b328adc12f3e5a556471451c0554c8b2" translate="yes" xml:space="preserve">
          <source>Now, you can say &lt;code&gt;loadFromDb&amp;lt;Exercise&amp;gt;(&quot;x01234567&quot;)&lt;/code&gt; to load an object from the &lt;code&gt;Exercise&lt;/code&gt; database table.</source>
          <target state="translated">これで、 &lt;code&gt;loadFromDb&amp;lt;Exercise&amp;gt;(&quot;x01234567&quot;)&lt;/code&gt; と言って、 &lt;code&gt;Exercise&lt;/code&gt; データベーステーブルからオブジェクトをロードできます。</target>
        </trans-unit>
        <trans-unit id="93baa80c955acf188a4912f62d9bfabe1e89cde4" translate="yes" xml:space="preserve">
          <source>Now, you can treat a bowl of &lt;code&gt;T&lt;/code&gt; as a producer of any superclass of &lt;code&gt;T&lt;/code&gt;, and as a consumer of any subclass of &lt;code&gt;T&lt;/code&gt;:</source>
          <target state="translated">さて、あなたはのボウル扱うことができる &lt;code&gt;T&lt;/code&gt; を任意のスーパークラスのプロデューサーとして &lt;code&gt;T&lt;/code&gt; 、および任意のサブクラスの消費者としての &lt;code&gt;T&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="cb06774e37de315de0f5603f0b4fd0176b0b42a0" translate="yes" xml:space="preserve">
          <source>Now, you may not create a &lt;code&gt;TreeNode&lt;/code&gt; of a type that is not a subclass/implementor of &lt;code&gt;Vehicle&lt;/code&gt;. Inside the class, whenever you've got a value of type &lt;code&gt;T&lt;/code&gt;, you may access all the public members of &lt;code&gt;Vehicle&lt;/code&gt; on it.</source>
          <target state="translated">ここで、 &lt;code&gt;Vehicle&lt;/code&gt; のサブクラス/インプリ &lt;code&gt;TreeNode&lt;/code&gt; ではないタイプのTreeNodeを作成することはできません。クラス内では、 &lt;code&gt;T&lt;/code&gt; 型の値を取得するたびに、 &lt;code&gt;Vehicle&lt;/code&gt; のすべてのパブリックメンバーにアクセスできます。</target>
        </trans-unit>
        <trans-unit id="e66b62de2c45ca7a1dafaa470efed27db40c8abf" translate="yes" xml:space="preserve">
          <source>Null Safety</source>
          <target state="translated">ヌル安全</target>
        </trans-unit>
        <trans-unit id="961437d22902a2f7dfd53365cc313f4a8b919ec9" translate="yes" xml:space="preserve">
          <source>Null references are &lt;a href=&quot;null-safety&quot;&gt;controlled by the type system&lt;/a&gt;.</source>
          <target state="translated">null参照は&lt;a href=&quot;null-safety&quot;&gt;型システムによって制御されます&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a2b2542f64eaa222fbfda6a1a4f6d0850cf59a88" translate="yes" xml:space="preserve">
          <source>Null safety</source>
          <target state="translated">ヌル安全</target>
        </trans-unit>
        <trans-unit id="39f94d225bc04bec959b32c61b7c0b099f1b3de4" translate="yes" xml:space="preserve">
          <source>Null safety is enforced as usual, so a variable of type &lt;code&gt;ContentKind&lt;/code&gt; can not be null, unlike in Java.</source>
          <target state="translated">nullの安全性は通常どおり適用されるため、Javaとは異なり、 &lt;code&gt;ContentKind&lt;/code&gt; 型の変数をnullにすることはできません。</target>
        </trans-unit>
        <trans-unit id="c768f27b8cd368aac53b3bf7b3466119f4aeaaad" translate="yes" xml:space="preserve">
          <source>Null-Safety and Platform Types</source>
          <target state="translated">ヌルセーフとプラットフォームタイプ</target>
        </trans-unit>
        <trans-unit id="7b2e605360643dd896eff359d1535b4e4db34c3d" translate="yes" xml:space="preserve">
          <source>Null-safety</source>
          <target state="translated">Null-safety</target>
        </trans-unit>
        <trans-unit id="e96a81e5fc6aa1615fc78a379fdad68b748bc26c" translate="yes" xml:space="preserve">
          <source>NullPointerException</source>
          <target state="translated">NullPointerException</target>
        </trans-unit>
        <trans-unit id="7cfd44db910fd8b20253bc74265b31aeaf45384c" translate="yes" xml:space="preserve">
          <source>Nullability</source>
          <target state="translated">Nullability</target>
        </trans-unit>
        <trans-unit id="13c99d5e49300b52aefe21f12764921df1d1f93f" translate="yes" xml:space="preserve">
          <source>Nullability annotations</source>
          <target state="translated">ヌルアビリティーアノテーション</target>
        </trans-unit>
        <trans-unit id="e5e6784edcd14305d294e06ecb03d642a0a57873" translate="yes" xml:space="preserve">
          <source>Nullability assertions on access to Java types annotated with &lt;code&gt;@NotNull&lt;/code&gt;</source>
          <target state="translated">注釈付きJavaタイプへのアクセスにNULL可能アサーション &lt;code&gt;@NotNull&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1e5389deab4b42bc503c62cbba549bbb26b00be1" translate="yes" xml:space="preserve">
          <source>Nullable Receiver</source>
          <target state="translated">ヌル可能受信機</target>
        </trans-unit>
        <trans-unit id="29ff5a1131fe0933e804809fec54eb9e91bf1512" translate="yes" xml:space="preserve">
          <source>Nullable receiver</source>
          <target state="translated">ヌル可能な受信機</target>
        </trans-unit>
        <trans-unit id="ea692fde5fad8fec43d27ab3923928d9c3e4f762" translate="yes" xml:space="preserve">
          <source>Nullable types and Non-Null Types</source>
          <target state="translated">ヌル可能な型と非ヌル型</target>
        </trans-unit>
        <trans-unit id="eda4c49c3f8e3f49857bedaeb7bb3c5e705b11d9" translate="yes" xml:space="preserve">
          <source>Nullable values and &lt;em&gt;null&lt;/em&gt; checks</source>
          <target state="translated">Nullable values and &lt;em&gt;null&lt;/em&gt; checks</target>
        </trans-unit>
        <trans-unit id="b7baa1d40c4ea29afc9098732bffee2a861a6c44" translate="yes" xml:space="preserve">
          <source>Number</source>
          <target state="translated">Number</target>
        </trans-unit>
        <trans-unit id="2e1ee95668fd5f69d1925d4acd4d52b859469b82" translate="yes" xml:space="preserve">
          <source>NumberFormatException</source>
          <target state="translated">NumberFormatException</target>
        </trans-unit>
        <trans-unit id="7e53821f70ae16079c4a6a64c52a91fae645bc5f" translate="yes" xml:space="preserve">
          <source>Numbers</source>
          <target state="translated">Numbers</target>
        </trans-unit>
        <trans-unit id="b7b3deb2440db7b27508e61ad6b6526ba91d78a1" translate="yes" xml:space="preserve">
          <source>Numbers are compared with the ends of this range according to IEEE-754.</source>
          <target state="translated">数値はIEEE-754に準拠して、この範囲の端と比較しています。</target>
        </trans-unit>
        <trans-unit id="b1c2afbaeee52797fa3a437d9c480e4a05cf0193" translate="yes" xml:space="preserve">
          <source>Numeric types use the traditional numerical order: &lt;code&gt;1&lt;/code&gt; is greater than &lt;code&gt;0&lt;/code&gt;; &lt;code&gt;-3.4f&lt;/code&gt; is greater than &lt;code&gt;-5f&lt;/code&gt;, an so on.</source>
          <target state="translated">数値タイプは、従来の数値順序を使用します &lt;code&gt;1&lt;/code&gt; は &lt;code&gt;0&lt;/code&gt; より大きいです。 &lt;code&gt;-3.4f&lt;/code&gt; はより大きくなる &lt;code&gt;-5f&lt;/code&gt; ように、。</target>
        </trans-unit>
        <trans-unit id="aadf9b6283ac66e1e51fce7a8cfe42781b4ea431" translate="yes" xml:space="preserve">
          <source>Numeric types use the traditional numerical order: &lt;code&gt;1&lt;/code&gt; is greater than &lt;code&gt;0&lt;/code&gt;; &lt;code&gt;-3.4f&lt;/code&gt; is greater than &lt;code&gt;-5f&lt;/code&gt;, and so on.</source>
          <target state="translated">Numeric types use the traditional numerical order: &lt;code&gt;1&lt;/code&gt; is greater than &lt;code&gt;0&lt;/code&gt; ; &lt;code&gt;-3.4f&lt;/code&gt; is greater than &lt;code&gt;-5f&lt;/code&gt; , and so on.</target>
        </trans-unit>
        <trans-unit id="132a0e722f57154d901e124e4cb8e8bc570f7174" translate="yes" xml:space="preserve">
          <source>Numerous use cases are covered by just the default source sets and don't require custom source sets.</source>
          <target state="translated">多くのユースケースはデフォルトのソースセットだけでカバーされており、カスタムソースセットを必要としません。</target>
        </trans-unit>
        <trans-unit id="f5bd86a2929ff840c45d76159d984c1239906a9d" translate="yes" xml:space="preserve">
          <source>OSGi</source>
          <target state="translated">OSGi</target>
        </trans-unit>
        <trans-unit id="802bfbdcec1e0873ee0e4b3f43f68d3022244543" translate="yes" xml:space="preserve">
          <source>OTHER_LETTER</source>
          <target state="translated">OTHER_LETTER</target>
        </trans-unit>
        <trans-unit id="c526c1a55d3a7d1197fc54064f8aa775a085df54" translate="yes" xml:space="preserve">
          <source>OTHER_NEUTRALS</source>
          <target state="translated">OTHER_NEUTRALS</target>
        </trans-unit>
        <trans-unit id="0528be3a553ee55304545e3df532c16619f9a75f" translate="yes" xml:space="preserve">
          <source>OTHER_NUMBER</source>
          <target state="translated">OTHER_NUMBER</target>
        </trans-unit>
        <trans-unit id="a79f18b5ad7c3bc6ad0e1685c0b9f1d91e9ea75c" translate="yes" xml:space="preserve">
          <source>OTHER_PUNCTUATION</source>
          <target state="translated">OTHER_PUNCTUATION</target>
        </trans-unit>
        <trans-unit id="5dcd7535199ae15a813d866ef04e762cfaa07f6c" translate="yes" xml:space="preserve">
          <source>OTHER_SYMBOL</source>
          <target state="translated">OTHER_SYMBOL</target>
        </trans-unit>
        <trans-unit id="5d84eb9e92dc661a577d3adfba33f1d74c56b13f" translate="yes" xml:space="preserve">
          <source>OUT</source>
          <target state="translated">OUT</target>
        </trans-unit>
        <trans-unit id="91920f1b8433472c27ea07aeaf636cc60ba181dc" translate="yes" xml:space="preserve">
          <source>ObjCAction</source>
          <target state="translated">ObjCAction</target>
        </trans-unit>
        <trans-unit id="e75d1b861d64404390b1044e805e449a8200ca83" translate="yes" xml:space="preserve">
          <source>ObjCBlockVar</source>
          <target state="translated">ObjCBlockVar</target>
        </trans-unit>
        <trans-unit id="e9af1c5fc6d5face32a12e24e19f7721bddde5b0" translate="yes" xml:space="preserve">
          <source>ObjCClass</source>
          <target state="translated">ObjCClass</target>
        </trans-unit>
        <trans-unit id="f25e8c7f51c9fbd76d5d3f0065c1777ea9957679" translate="yes" xml:space="preserve">
          <source>ObjCClassOf</source>
          <target state="translated">ObjCClassOf</target>
        </trans-unit>
        <trans-unit id="f6a51cb987439b8eee022689cce7766c56796d55" translate="yes" xml:space="preserve">
          <source>ObjCConstructor</source>
          <target state="translated">ObjCConstructor</target>
        </trans-unit>
        <trans-unit id="174b16a8130fefe11ed27381abeeb2de5f620114" translate="yes" xml:space="preserve">
          <source>ObjCFactory</source>
          <target state="translated">ObjCFactory</target>
        </trans-unit>
        <trans-unit id="b26295bcadcc4d23542076fe5cb26969093b0b48" translate="yes" xml:space="preserve">
          <source>ObjCMethod</source>
          <target state="translated">ObjCMethod</target>
        </trans-unit>
        <trans-unit id="07d9267ddaf9a5ade080cb2ba3e61a2c1db5834c" translate="yes" xml:space="preserve">
          <source>ObjCNotImplementedVar</source>
          <target state="translated">ObjCNotImplementedVar</target>
        </trans-unit>
        <trans-unit id="88fce822e198e83b3ad7f5c732a4ec9995f176b3" translate="yes" xml:space="preserve">
          <source>ObjCObject</source>
          <target state="translated">ObjCObject</target>
        </trans-unit>
        <trans-unit id="c3946e9e7a5b7a873393f4068d626ccc17017e1d" translate="yes" xml:space="preserve">
          <source>ObjCObjectBase</source>
          <target state="translated">ObjCObjectBase</target>
        </trans-unit>
        <trans-unit id="f2b935ffe4e074cda5d9854c568bff792bd27525" translate="yes" xml:space="preserve">
          <source>ObjCObjectBaseMeta</source>
          <target state="translated">ObjCObjectBaseMeta</target>
        </trans-unit>
        <trans-unit id="968b48c24c631a6e3656fa344166e2e696dac30a" translate="yes" xml:space="preserve">
          <source>ObjCObjectMeta</source>
          <target state="translated">ObjCObjectMeta</target>
        </trans-unit>
        <trans-unit id="877c2fba97f85ebcbe0815d3dd7f9aa9abf27eb2" translate="yes" xml:space="preserve">
          <source>ObjCObjectVar</source>
          <target state="translated">ObjCObjectVar</target>
        </trans-unit>
        <trans-unit id="380d9e7d32a5ea9a8f4a45d77367a2bd6224641f" translate="yes" xml:space="preserve">
          <source>ObjCOutlet</source>
          <target state="translated">ObjCOutlet</target>
        </trans-unit>
        <trans-unit id="6ad1a2f860c17b61aedf856b4ee3682acdaa8417" translate="yes" xml:space="preserve">
          <source>ObjCProtocol</source>
          <target state="translated">ObjCProtocol</target>
        </trans-unit>
        <trans-unit id="7ddeec08c37b0e1684597f07f64a856e9d5996d5" translate="yes" xml:space="preserve">
          <source>ObjCStringVarOf</source>
          <target state="translated">ObjCStringVarOf</target>
        </trans-unit>
        <trans-unit id="2883f191bc5ebfdc16c0813eff659b35363ea69b" translate="yes" xml:space="preserve">
          <source>Object</source>
          <target state="translated">Object</target>
        </trans-unit>
        <trans-unit id="9cf5c3411eb513b108884e51c19ba17172ea9665" translate="yes" xml:space="preserve">
          <source>Object Declarations</source>
          <target state="translated">オブジェクト宣言</target>
        </trans-unit>
        <trans-unit id="7c97f9bd791112ffa2e31c34e5efe261bd493bd5" translate="yes" xml:space="preserve">
          <source>Object Expressions and Declarations</source>
          <target state="translated">オブジェクト表現と宣言</target>
        </trans-unit>
        <trans-unit id="f0e2a5cc2614159a14f8d24f77aff8cedbb91395" translate="yes" xml:space="preserve">
          <source>Object Methods</source>
          <target state="translated">オブジェクトメソッド</target>
        </trans-unit>
        <trans-unit id="da5029a017fab6364fe3776821fcb6e385dc5dee" translate="yes" xml:space="preserve">
          <source>Object Transfer Basics.</source>
          <target state="translated">オブジェクト転送の基本。</target>
        </trans-unit>
        <trans-unit id="720b937cd9168a2afdad295cde0f6e29e57ba3f8" translate="yes" xml:space="preserve">
          <source>Object configuration and computing the result: &lt;code&gt;run&lt;/code&gt;</source>
          <target state="translated">オブジェクトの構成と結果の計算： &lt;code&gt;run&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1602dbe04f927f110613a2ff025fac15d0ab85e1" translate="yes" xml:space="preserve">
          <source>Object configuration: &lt;code&gt;apply&lt;/code&gt;</source>
          <target state="translated">オブジェクト構成： &lt;code&gt;apply&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b3d1d8d22ba8224cd8039f6fb03638fcc7cc89d7" translate="yes" xml:space="preserve">
          <source>Object declaration's initialization is thread-safe and done at first access.</source>
          <target state="translated">オブジェクト宣言の初期化はスレッドセーフで、最初のアクセス時に行われます。</target>
        </trans-unit>
        <trans-unit id="a447624065dc9ff0a50d2837d5bc597740342d7d" translate="yes" xml:space="preserve">
          <source>Object declaration's initialization is thread-safe.</source>
          <target state="translated">オブジェクト宣言の初期化はスレッドセーフです。</target>
        </trans-unit>
        <trans-unit id="628c7c8804cdd6233ca4db93a682c55cf0920e38" translate="yes" xml:space="preserve">
          <source>Object declarations</source>
          <target state="translated">オブジェクト宣言</target>
        </trans-unit>
        <trans-unit id="cae8f3bd29605b55880171db0511493e6eb7c132" translate="yes" xml:space="preserve">
          <source>Object describing the current platform program executes upon.</source>
          <target state="translated">現在のプラットフォームプログラムが実行される際に記述されているオブジェクト。</target>
        </trans-unit>
        <trans-unit id="652916453e90e519555e6ab21189e4862e16ddc5" translate="yes" xml:space="preserve">
          <source>Object expressions</source>
          <target state="translated">オブジェクト表現</target>
        </trans-unit>
        <trans-unit id="a5005a7247de5e6b7399fc2c0fe58f85332088cd" translate="yes" xml:space="preserve">
          <source>Object pinning</source>
          <target state="translated">オブジェクトのピン留め</target>
        </trans-unit>
        <trans-unit id="bd34180a1517f8541977dbe1575129ec09ee4ed0" translate="yes" xml:space="preserve">
          <source>Object reference</source>
          <target state="translated">オブジェクト参照</target>
        </trans-unit>
        <trans-unit id="c74457d6502afea678cde0191acb0c28174b3019" translate="yes" xml:space="preserve">
          <source>Object subgraph detachment</source>
          <target state="translated">オブジェクトサブグラフの切り離し</target>
        </trans-unit>
        <trans-unit id="9e612181ece96085e9c01a6c4c75420948e3db15" translate="yes" xml:space="preserve">
          <source>Object subgraph freezing</source>
          <target state="translated">オブジェクトサブグラフのフリーズ</target>
        </trans-unit>
        <trans-unit id="f714255fe9b4b0abd289766d10b307beefd8bdca" translate="yes" xml:space="preserve">
          <source>Object subgraph ownership transfer</source>
          <target state="translated">オブジェクトサブグラフの所有権移転</target>
        </trans-unit>
        <trans-unit id="f7e1ff28ab70fc23071798b8c0343f8a27fa8277" translate="yes" xml:space="preserve">
          <source>Object transfer and freezing</source>
          <target state="translated">オブジェクトの転送とフリーズ</target>
        </trans-unit>
        <trans-unit id="9cf4af30df052d80876381f9ec0e05811ecd3d08" translate="yes" xml:space="preserve">
          <source>Objective-C</source>
          <target state="translated">Objective-C</target>
        </trans-unit>
        <trans-unit id="f624b8a4ac060c545ced78fe5b569d299005d811" translate="yes" xml:space="preserve">
          <source>Objective-C allows generics to be declared covariant or contravariant. Swift has no support for variance. Generic classes coming from Objective-C can be force-cast as needed.</source>
          <target state="translated">Objective-Cでは、ジェネリックを共分散または逆分散で宣言することができます。Swiftは分散をサポートしていません。Objective-C からのジェネリッククラスは、必要に応じて強制的にキャストすることができます。</target>
        </trans-unit>
        <trans-unit id="c34ace6f5a2b6e2147c689be6867500eabe88ca9" translate="yes" xml:space="preserve">
          <source>Objective-C and Swift use reference counting. Kotlin/Native has its own garbage collection too. Kotlin/Native garbage collection is integrated with Objective-C/Swift reference counting. We do not need to use anything special to control the lifetime of Kotlin/Native instances from Swift or Objective-C.</source>
          <target state="translated">Objective-CやSwiftは参照カウントを使っています。Kotlin/Native は独自のガベージコレクションも持っています。Kotlin/NativeのガベージコレクションはObjective-C/Swiftの参照カウントと統合されています。Kotlin/Nativeのインスタンスの寿命をSwiftやObjective-Cから制御するために特別なものを使う必要はありません。</target>
        </trans-unit>
        <trans-unit id="81b529433016c0d2c2b79263ff487c0612e2136f" translate="yes" xml:space="preserve">
          <source>Objective-C classes and protocols</source>
          <target state="translated">Objective-C のクラスとプロトコル</target>
        </trans-unit>
        <trans-unit id="42d9bdb0193a26ed15d57450ee6f73bec2393ce7" translate="yes" xml:space="preserve">
          <source>Objective-C classes are imported into Kotlin with their original names. Protocols are imported as interfaces with &lt;code&gt;Protocol&lt;/code&gt; name suffix, i.e. &lt;code&gt;@protocol Foo&lt;/code&gt; -&amp;gt; &lt;code&gt;interface FooProtocol&lt;/code&gt;. These classes and interfaces are placed into a package &lt;a href=&quot;#usage&quot;&gt;specified in build configuration&lt;/a&gt; (&lt;code&gt;platform.*&lt;/code&gt; packages for preconfigured system frameworks).</source>
          <target state="translated">Objective-Cクラスは、元の名前でKotlinにインポートされます。プロトコルは、 &lt;code&gt;Protocol&lt;/code&gt; 名のサフィックスが付いたインターフェースとしてインポートされます。つまり、 &lt;code&gt;@protocol Foo&lt;/code&gt; - &amp;gt; &lt;code&gt;interface FooProtocol&lt;/code&gt; です。これらのクラスとインターフェースは&lt;a href=&quot;#usage&quot;&gt;、ビルド構成で指定さ&lt;/a&gt;れたパッケージ（事前構成されたシステムフレームワーク用の &lt;code&gt;platform.*&lt;/code&gt; パッケージ）に配置されます。</target>
        </trans-unit>
        <trans-unit id="e28ecca8c4c63098937f693b564f06106597a69f" translate="yes" xml:space="preserve">
          <source>Objective-C generics do not support all features of either Kotlin or Swift, so there will be some information lost in the translation.</source>
          <target state="translated">Objective-CジェネリックはKotlinやSwiftのすべての機能をサポートしているわけではないので、翻訳の際に失われる情報があります。</target>
        </trans-unit>
        <trans-unit id="edc50c4e6d2116d2eefbad12ba8e08e873a18c54" translate="yes" xml:space="preserve">
          <source>Objective-C supports &quot;lightweight generics&quot; defined on classes, with a relatively limited feature set. Swift can import generics defined on classes to help provide additional type information to the compiler.</source>
          <target state="translated">Objective-C はクラス上で定義された「軽量なジェネリック」をサポートしていますが、機能は比較的限られています。Swift は、コンパイラに追加の型情報を提供するのに役立つように、クラス上で定義されたジェネリックをインポートすることができます。</target>
        </trans-unit>
        <trans-unit id="872324a80a8df1d396c94677f04ea994d1ae3329" translate="yes" xml:space="preserve">
          <source>Objects and companion objects</source>
          <target state="translated">オブジェクトとコンパニオンオブジェクト</target>
        </trans-unit>
        <trans-unit id="baa64e9ea92fa8d9f0990d9b1a5bc22ee025b445" translate="yes" xml:space="preserve">
          <source>Objects can be passed between threads in one of two possible modes.</source>
          <target state="translated">オブジェクトは、2 つのモードのいずれかでスレッド間で渡すことができます。</target>
        </trans-unit>
        <trans-unit id="c92258fa87a7fd87bfb0eac39b2cad3876c1531d" translate="yes" xml:space="preserve">
          <source>Observable</source>
          <target state="translated">Observable</target>
        </trans-unit>
        <trans-unit id="53d6bf00994a7a961b92ecd0048f0ecd77a13ddf" translate="yes" xml:space="preserve">
          <source>ObservableProperty</source>
          <target state="translated">ObservableProperty</target>
        </trans-unit>
        <trans-unit id="1145800f1de30eba6d1df3a4fd2cc70c1f07f939" translate="yes" xml:space="preserve">
          <source>Obtain the Kotlin/Native compiler</source>
          <target state="translated">Kotlin/Native コンパイラを入手する</target>
        </trans-unit>
        <trans-unit id="cdf71ecbbe212f441c04603a28909072a535e232" translate="yes" xml:space="preserve">
          <source>Obtaining member references from a class reference</source>
          <target state="translated">クラス参照からのメンバ参照の取得</target>
        </trans-unit>
        <trans-unit id="df8298dcee7334200280003820f9875dbf3c187b" translate="yes" xml:space="preserve">
          <source>Obtaining the Compiler</source>
          <target state="translated">コンパイラの取得</target>
        </trans-unit>
        <trans-unit id="b10db2a36e46741d4da85b74ece4b6f72fb9bfd8" translate="yes" xml:space="preserve">
          <source>Obtains a &lt;code&gt;KClass&lt;/code&gt; instance for the given constructor reference.</source>
          <target state="translated">取得 &lt;code&gt;KClass&lt;/code&gt; の所与のコンストラクタ参照のインスタンス。</target>
        </trans-unit>
        <trans-unit id="9910159f8fee624aa4548124f031d4745a86c889" translate="yes" xml:space="preserve">
          <source>Obtains a constructor reference for the given &lt;code&gt;KClass&lt;/code&gt;.</source>
          <target state="translated">指定された &lt;code&gt;KClass&lt;/code&gt; のコンストラクタ参照を取得します。</target>
        </trans-unit>
        <trans-unit id="0219b4a8ea1da937bc70be9c1ab95184f21fc8c4" translate="yes" xml:space="preserve">
          <source>Obtains the current continuation instance inside suspend functions and either suspends currently running coroutine or returns result immediately without suspension.</source>
          <target state="translated">サスペンド関数内の現在の継続インスタンスを取得し、現在実行中のコルーチンをサスペンドするか、サスペンドせずに直ちに結果を返します。</target>
        </trans-unit>
        <trans-unit id="646fc575bcb6c35847d73d3b2dd2cc5db56f01df" translate="yes" xml:space="preserve">
          <source>Obtains the current continuation instance inside suspend functions and suspends currently running coroutine.</source>
          <target state="translated">サスペンド関数内の現在の継続インスタンスを取得し、現在実行中のcoroutineをサスペンドします。</target>
        </trans-unit>
        <trans-unit id="dedd1425a40b177d169a6eb17080f5f8210d2fe7" translate="yes" xml:space="preserve">
          <source>Obtains the current continuation instance inside suspend functions and suspends the currently running coroutine.</source>
          <target state="translated">サスペンド関数内の現在の継続インスタンスを取得し、現在実行中のコルーチンをサスペンドします。</target>
        </trans-unit>
        <trans-unit id="0e481b647fccdeaa073311d1f3e53a76a5713079" translate="yes" xml:space="preserve">
          <source>Of course, there are use cases, where we need to pass a struct as a value to one call, and then, to pass the same struct as a reference to another call. This is possible in Kotlin/Native too. A &lt;code&gt;NativePlacement&lt;/code&gt; will be needed here.</source>
          <target state="translated">もちろん、構造体を値として1つの呼び出しに渡し、次に同じ構造体を別の呼び出しへの参照として渡す必要があるユースケースがあります。これはKotlin / Nativeでも可能です。ここには &lt;code&gt;NativePlacement&lt;/code&gt; が必要です。</target>
        </trans-unit>
        <trans-unit id="31883564163ba418ee2d22f8e75f951da14db61c" translate="yes" xml:space="preserve">
          <source>Of course, this function makes sense for any &lt;code&gt;MutableList&amp;lt;T&amp;gt;&lt;/code&gt;, and we can make it generic:</source>
          <target state="translated">もちろん、この関数はすべての &lt;code&gt;MutableList&amp;lt;T&amp;gt;&lt;/code&gt; に意味があり、一般的にすることができます。</target>
        </trans-unit>
        <trans-unit id="a8b4afe53634485a00aaaa6addcb6e74df14c763" translate="yes" xml:space="preserve">
          <source>Of course, this is not a complete list of how you can use Kotlin/JS to your advantage, but merely a selection of cherry-picked cases. We invite you to experiment with combinations of these use cases, and find out what works best for your project.</source>
          <target state="translated">もちろん、これはKotlin/JSをどのように利用するかの完全なリストではありません。これらのユースケースの組み合わせを試してみて、あなたのプロジェクトに最適なものを見つけてください。</target>
        </trans-unit>
        <trans-unit id="01fad7001a3bd3884c94e7702bc3df04daa71091" translate="yes" xml:space="preserve">
          <source>Of course, you can use both &lt;code&gt;kotlin-allopen&lt;/code&gt; and &lt;code&gt;kotlin-spring&lt;/code&gt; in the same project.</source>
          <target state="translated">もちろん、同じプロジェクトで &lt;code&gt;kotlin-allopen&lt;/code&gt; と &lt;code&gt;kotlin-spring&lt;/code&gt; の両方を使用できます。</target>
        </trans-unit>
        <trans-unit id="42c11258f0fc4616029dfe363fc90cedc10dac00" translate="yes" xml:space="preserve">
          <source>Often C APIs allow passing some user data to callbacks. Such data is usually provided by the user when configuring the callback. It is passed to some C function (or written to the struct) as e.g. &lt;code&gt;void*&lt;/code&gt;. However, references to Kotlin objects can't be directly passed to C. So they require wrapping before configuring the callback and then unwrapping in the callback itself, to safely swim from Kotlin to Kotlin through the C world. Such wrapping is possible with &lt;code&gt;StableRef&lt;/code&gt; class.</source>
          <target state="translated">多くの場合、C APIでは、一部のユーザーデータをコールバックに渡すことができます。このようなデータは通常、コールバックの構成時にユーザーによって提供されます。これは、たとえば &lt;code&gt;void*&lt;/code&gt; としてC関数に渡されます（または構造体に書き込まれます）。ただし、Kotlinオブジェクトへの参照を直接Cに渡すことはできません。そのため、コールバックを構成する前にラップし、コールバック自体でラップ解除して、Cワールドを介してKotlinからKotlinに安全に泳ぐ必要があります。このようなラッピングは、 &lt;code&gt;StableRef&lt;/code&gt; クラスで可能です。</target>
        </trans-unit>
        <trans-unit id="242f4c07d8050ddde5e50538c080e4ec4486413c" translate="yes" xml:space="preserve">
          <source>Often it's necessary to specify target-specific linker options for a Kotlin/Native binary using an interop. It can be done using the &lt;code&gt;target&lt;/code&gt; script block:</source>
          <target state="translated">多くの場合、相互運用機能を使用してKotlin / Nativeバイナリのターゲット固有のリンカーオプションを指定する必要があります。これは、 &lt;code&gt;target&lt;/code&gt; スクリプトブロックを使用して実行できます。</target>
        </trans-unit>
        <trans-unit id="954df0a6263002ad270cb3cbc1c777c4a6fac8a1" translate="yes" xml:space="preserve">
          <source>Often it's necessary to specify target-specific linker options for a binary which uses a native library. It can by done using the &lt;code&gt;linkerOpts&lt;/code&gt; property of the binary. See the &lt;a href=&quot;#configuring-binaries&quot;&gt;Configuring binaries&lt;/a&gt; section for details.</source>
          <target state="translated">多くの場合、ネイティブライブラリを使用するバイナリのターゲット固有のリンカーオプションを指定する必要があります。バイナリの &lt;code&gt;linkerOpts&lt;/code&gt; プロパティを使用して行うことができます。詳細については、&lt;a href=&quot;#configuring-binaries&quot;&gt;バイナリ&lt;/a&gt;の構成セクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="17450dcb9110eb38f3fe2d512c09098b5921aef0" translate="yes" xml:space="preserve">
          <source>Older compilers reject binaries that rely on new features (e.g. a 1.0 compiler rejects binaries that use coroutines).</source>
          <target state="translated">古いコンパイラは新しい機能に依存するバイナリを拒否します (例えば 1.0 のコンパイラはコアーチンを使用するバイナリを拒否します)。</target>
        </trans-unit>
        <trans-unit id="622d524446394c09abc4f2559c91821dbd352982" translate="yes" xml:space="preserve">
          <source>Omit semicolons whenever possible.</source>
          <target state="translated">可能な限りセミコロンを省略してください。</target>
        </trans-unit>
        <trans-unit id="902eb259efe55ed5caa3e21ba3397c994cd51091" translate="yes" xml:space="preserve">
          <source>On Apple platforms &lt;code&gt;objc&lt;/code&gt; library is provided for interoperability with &lt;a href=&quot;https://en.wikipedia.org/wiki/Objective-C&quot;&gt;Objective-C&lt;/a&gt;.</source>
          <target state="translated">Appleプラットフォームでは、&lt;a href=&quot;https://en.wikipedia.org/wiki/Objective-C&quot;&gt;Objective-C&lt;/a&gt;との相互運用性のために &lt;code&gt;objc&lt;/code&gt; ライブラリが提供されています。</target>
        </trans-unit>
        <trans-unit id="3a12a3cf1289b0209f29a4a3a5bf9dabfcdb8788" translate="yes" xml:space="preserve">
          <source>On GitHub</source>
          <target state="translated">GitHubで</target>
        </trans-unit>
        <trans-unit id="c0ab16d7d10cfcca8fa016bc8b366c04e76c5016" translate="yes" xml:space="preserve">
          <source>On JVM it is possible to redefine global exception handler for all coroutines by registering &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-exception-handler/index.html&quot;&gt;CoroutineExceptionHandler&lt;/a&gt; via &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/ServiceLoader.html&quot;&gt;&lt;code&gt;ServiceLoader&lt;/code&gt;&lt;/a&gt;. Global exception handler is similar to &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html#setDefaultUncaughtExceptionHandler(java.lang.Thread.UncaughtExceptionHandler)&quot;&gt;&lt;code&gt;Thread.defaultUncaughtExceptionHandler&lt;/code&gt;&lt;/a&gt; which is used when no more specific handlers are registered. On Android, &lt;code&gt;uncaughtExceptionPreHandler&lt;/code&gt; is installed as a global coroutine exception handler.</source>
          <target state="translated">JVMでは、&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/ServiceLoader.html&quot;&gt; &lt;code&gt;ServiceLoader&lt;/code&gt; &lt;/a&gt;を介して&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-exception-handler/index.html&quot;&gt;CoroutineExceptionHandler&lt;/a&gt;を登録することにより、すべてのコルーチンのグローバル例外ハンドラを再定義できます。グローバル例外ハンドラは、特定のハンドラが登録されていないときに使用される&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html#setDefaultUncaughtExceptionHandler(java.lang.Thread.UncaughtExceptionHandler)&quot;&gt; &lt;code&gt;Thread.defaultUncaughtExceptionHandler&lt;/code&gt; に&lt;/a&gt;似ています。Androidでは、 &lt;code&gt;uncaughtExceptionPreHandler&lt;/code&gt; がグローバルコルーチン例外ハンドラーとしてインストールされます。</target>
        </trans-unit>
        <trans-unit id="52a2cc9b4e5cfa91fe617932ce29f7d004cf9460" translate="yes" xml:space="preserve">
          <source>On JVM the returned generator is NOT thread-safe. Do not invoke it from multiple threads without proper synchronization.</source>
          <target state="translated">JVM上では、返されたジェネレータはスレッドセーフではありません。適切な同期を取らずに複数のスレッドから呼び出してはいけません。</target>
        </trans-unit>
        <trans-unit id="d634a94c081c286c31c7efa035cd25a12a05ea49" translate="yes" xml:space="preserve">
          <source>On JVM this generator is thread-safe, its methods can be invoked from multiple threads.</source>
          <target state="translated">JVM上では、このジェネレータはスレッドセーフであり、そのメソッドは複数のスレッドから呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="82b7124cbe78a1bd0ee0229af53226a5b9d9303c" translate="yes" xml:space="preserve">
          <source>On Linux we call a similar command:</source>
          <target state="translated">Linuxでは、同様のコマンドを呼び出します。</target>
        </trans-unit>
        <trans-unit id="debaeb12f7add41593464f7eef76b63e195de057" translate="yes" xml:space="preserve">
          <source>On Windows, Dynamic libraries are included either via a generated static library wrapper or with manual code, which deals with the &lt;a href=&quot;https://docs.microsoft.com/en-gb/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya&quot;&gt;LoadLibrary&lt;/a&gt; or similar Win32API functions. We will follow the first option and generate the static wrapper library for the &lt;code&gt;libnative.dll&lt;/code&gt; on our own.</source>
          <target state="translated">On Windows, Dynamic libraries are included either via a generated static library wrapper or with manual code, which deals with the &lt;a href=&quot;https://docs.microsoft.com/en-gb/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya&quot;&gt;LoadLibrary&lt;/a&gt; or similar Win32API functions. We will follow the first option and generate the static wrapper library for the &lt;code&gt;libnative.dll&lt;/code&gt; on our own.</target>
        </trans-unit>
        <trans-unit id="f32995a2978fac4fc27ca1ef6f69f7fd0261ff6b" translate="yes" xml:space="preserve">
          <source>On Windows, Dynamic libraries are included either via a generated static library wrapper or with manual code, which deals with the &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/ms684175.aspx&quot;&gt;LoadLibrary&lt;/a&gt; or similar Win32API functions. We will follow the first option and generate the static wrapper library for the &lt;code&gt;libnative.dll&lt;/code&gt; on our own.</source>
          <target state="translated">Windowsでは、動的ライブラリは、生成された静的ライブラリラッパーを介して、または&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/ms684175.aspx&quot;&gt;LoadLibrary&lt;/a&gt;または類似のWin32API関数を処理する手動コードに含まれます。最初のオプションに従い、自分で &lt;code&gt;libnative.dll&lt;/code&gt; の静的ラッパーライブラリを生成します。</target>
        </trans-unit>
        <trans-unit id="215b62ee2a4bb5fa218d3c640f454cdd3fd9a459" translate="yes" xml:space="preserve">
          <source>On a &lt;code&gt;dynamic&lt;/code&gt; variable, you can call &lt;strong&gt;any&lt;/strong&gt; property or function, with any parameters:</source>
          <target state="translated">On a &lt;code&gt;dynamic&lt;/code&gt; variable, you can call &lt;strong&gt;any&lt;/strong&gt; property or function, with any parameters:</target>
        </trans-unit>
        <trans-unit id="d7653dc191105be976f3e4142a119bd4841c071b" translate="yes" xml:space="preserve">
          <source>On compiling, Gradle will produce the output of our application, which is by default placed under the &lt;code&gt;build/classes/main&lt;/code&gt; directory. This can be overridden using &lt;a href=&quot;#configuring-compiler-options&quot;&gt;the compiler options&lt;/a&gt;.</source>
          <target state="translated">コンパイル時に、Gradleはアプリケーションの出力を生成します。これはデフォルトで &lt;code&gt;build/classes/main&lt;/code&gt; ディレクトリの下に配置されます。これは&lt;a href=&quot;#configuring-compiler-options&quot;&gt;、コンパイラオプション&lt;/a&gt;を使用してオーバーライドできます。</target>
        </trans-unit>
        <trans-unit id="c14acaa8726202e56fd6764b8d4c4f4bf976a344" translate="yes" xml:space="preserve">
          <source>On compiling, Maven will produce the following output</source>
          <target state="translated">コンパイルすると、Mavenは以下の出力を生成します。</target>
        </trans-unit>
        <trans-unit id="605e2cebf9185d39a487f4db48ecd6fb230665c8" translate="yes" xml:space="preserve">
          <source>On empty collections, &lt;code&gt;random()&lt;/code&gt; throws an exception. To receive &lt;code&gt;null&lt;/code&gt; instead, use &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/random-or-null&quot;&gt;&lt;code&gt;randomOrNull()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">On empty collections, &lt;code&gt;random()&lt;/code&gt; throws an exception. To receive &lt;code&gt;null&lt;/code&gt; instead, use &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/random-or-null&quot;&gt; &lt;code&gt;randomOrNull()&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2882a4f2583407f0619da2020ec98bec3d44466d" translate="yes" xml:space="preserve">
          <source>On macOS 10.13 with Xcode, we compile the C code and link it with the dynamic library with the following command:</source>
          <target state="translated">macOS 10.13のXcodeでは、以下のコマンドでCコードをコンパイルしてダイナミックライブラリと連携させています。</target>
        </trans-unit>
        <trans-unit id="29573262d66dff209bb25d8ca0d7651c0e4d12be" translate="yes" xml:space="preserve">
          <source>On the JVM platform, standard library contains extensions for reflection classes that provide a mapping to and from Java reflection objects (see package &lt;code&gt;kotlin.reflect.jvm&lt;/code&gt;). For example, to find a backing field or a Java method that serves as a getter for a Kotlin property, you can say something like this:</source>
          <target state="translated">On the JVM platform, standard library contains extensions for reflection classes that provide a mapping to and from Java reflection objects (see package &lt;code&gt;kotlin.reflect.jvm&lt;/code&gt; ). For example, to find a backing field or a Java method that serves as a getter for a Kotlin property, you can say something like this:</target>
        </trans-unit>
        <trans-unit id="b99e2927eb300e8d0d8fcf2adae0bb05f7e1dd48" translate="yes" xml:space="preserve">
          <source>On the JVM platform, the runtime component required for using the reflection features is distributed as a separate artifact &lt;code&gt;kotlin-reflect.jar&lt;/code&gt; in the Kotlin compiler distribution. This is done to reduce the required size of the runtime library for applications that do not use reflection features.</source>
          <target state="translated">On the JVM platform, the runtime component required for using the reflection features is distributed as a separate artifact &lt;code&gt;kotlin-reflect.jar&lt;/code&gt; in the Kotlin compiler distribution. This is done to reduce the required size of the runtime library for applications that do not use reflection features.</target>
        </trans-unit>
        <trans-unit id="fb4ddd201d36fd87940a13588d6e11985482252b" translate="yes" xml:space="preserve">
          <source>On the JVM side, the main build tools include &lt;a href=&quot;using-gradle&quot;&gt;Gradle&lt;/a&gt;, &lt;a href=&quot;using-maven&quot;&gt;Maven&lt;/a&gt;, &lt;a href=&quot;using-ant&quot;&gt;Ant&lt;/a&gt;, and &lt;a href=&quot;http://beust.com/kobalt/home/index.html&quot;&gt;Kobalt&lt;/a&gt;. There are also some build tools available that target client-side JavaScript.</source>
          <target state="translated">JVM側の主なビルドツールには、&lt;a href=&quot;using-gradle&quot;&gt;Gradle&lt;/a&gt;、&lt;a href=&quot;using-maven&quot;&gt;Maven&lt;/a&gt;、&lt;a href=&quot;using-ant&quot;&gt;Ant&lt;/a&gt;、および&lt;a href=&quot;http://beust.com/kobalt/home/index.html&quot;&gt;Kobaltがあり&lt;/a&gt;ます。クライアント側のJavaScriptを対象とするビルドツールもいくつかあります。</target>
        </trans-unit>
        <trans-unit id="8a846654c5fb7b58771a6c8aa68e2bb8f0431b17" translate="yes" xml:space="preserve">
          <source>On the JVM, if the generated class needs to have a parameterless constructor, default values for all properties have to be specified (see &lt;a href=&quot;classes#constructors&quot;&gt;Constructors&lt;/a&gt;).</source>
          <target state="translated">JVMでは、生成されたクラスにパラメーターなしのコンストラクターが必要な場合、すべてのプロパティのデフォルト値を指定する必要があります（&lt;a href=&quot;classes#constructors&quot;&gt;コンストラクターを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="22f3441381be355a57b0344800020b03a2e7fba9" translate="yes" xml:space="preserve">
          <source>On the JVM, non-nullable values of this type are represented as values of the primitive type &lt;code&gt;char&lt;/code&gt;.</source>
          <target state="translated">JVMでは、このタイプのnullにできない値は、プリミティブタイプ &lt;code&gt;char&lt;/code&gt; の値として表されます。</target>
        </trans-unit>
        <trans-unit id="c36ad8bfe3e9b420b17609f7d80f8fe5d46e556b" translate="yes" xml:space="preserve">
          <source>On the JVM, one could provide an implementation that writes the log to the standard output:</source>
          <target state="translated">JVM上では、ログを標準出力に書き込む実装を提供することができます。</target>
        </trans-unit>
        <trans-unit id="37c721a8e1ab899d231ec42baf253266e008d200" translate="yes" xml:space="preserve">
          <source>On the JVM, the &lt;a href=&quot;basic-types#arrays&quot;&gt;array types&lt;/a&gt; (&lt;code&gt;Array&amp;lt;Foo&amp;gt;&lt;/code&gt;) retain the information about the erased type of their elements, and the type casts to an array type are partially checked: the nullability and actual type arguments of the elements type are still erased. For example, the cast &lt;code&gt;foo as Array&amp;lt;List&amp;lt;String&amp;gt;?&amp;gt;&lt;/code&gt; will succeed if &lt;code&gt;foo&lt;/code&gt; is an array holding any &lt;code&gt;List&amp;lt;*&amp;gt;&lt;/code&gt;, nullable or not.</source>
          <target state="translated">JVMでは、&lt;a href=&quot;basic-types#arrays&quot;&gt;配列型&lt;/a&gt;（ &lt;code&gt;Array&amp;lt;Foo&amp;gt;&lt;/code&gt; ）は要素の消去された型に関する情報を保持し、配列型への型キャストは部分的にチェックされます。要素型のnull可能性と実際の型引数は引き続き消去されます。たとえば、 &lt;code&gt;foo as Array&amp;lt;List&amp;lt;String&amp;gt;?&amp;gt;&lt;/code&gt; キャストされた場合、 &lt;code&gt;foo&lt;/code&gt; が任意の &lt;code&gt;List&amp;lt;*&amp;gt;&lt;/code&gt; 保持する配列であり、null可能かどうかは成功します。</target>
        </trans-unit>
        <trans-unit id="5506431e2bb120557c874e7652f1a65950568290" translate="yes" xml:space="preserve">
          <source>On the Java platform, numbers are physically stored as JVM primitive types, unless we need a nullable number reference (e.g. &lt;code&gt;Int?&lt;/code&gt;) or generics are involved. In the latter cases numbers are boxed.</source>
          <target state="translated">Javaプラットフォームでは、null許容の数値参照（ &lt;code&gt;Int?&lt;/code&gt; など）が必要な場合やジェネリックが含まれていない限り、数値はJVMプリミティブ型として物理的に格納されます。後者の場合、数字はボックスで囲まれます。</target>
        </trans-unit>
        <trans-unit id="fc1cc156e617b185ed0f40e773e41bff1f85a104" translate="yes" xml:space="preserve">
          <source>On the Java platform, standard library contains extensions for reflection classes that provide a mapping to and from Java reflection objects (see package &lt;code&gt;kotlin.reflect.jvm&lt;/code&gt;). For example, to find a backing field or a Java method that serves as a getter for a Kotlin property, you can say something like this:</source>
          <target state="translated">Javaプラットフォームでは、標準ライブラリには、Javaリフレクションオブジェクトとの間のマッピングを提供するリフレクションクラスの拡張機能が含まれています（パッケージ &lt;code&gt;kotlin.reflect.jvm&lt;/code&gt; を参照）。たとえば、Kotlinプロパティのゲッターとして機能するバッキングフィールドまたはJavaメソッドを見つけるには、次のようにします。</target>
        </trans-unit>
        <trans-unit id="2a19f51c47052a4b52d4d3a45688012ff83885d4" translate="yes" xml:space="preserve">
          <source>On the Java platform, the runtime component required for using the reflection features is distributed as a separate JAR file (&lt;code&gt;kotlin-reflect.jar&lt;/code&gt;). This is done to reduce the required size of the runtime library for applications that do not use reflection features. If you do use reflection, please make sure that the .jar file is added to the classpath of your project.</source>
          <target state="translated">Javaプラットフォームでは、リフレクション機能を使用するために必要なランタイムコンポーネントは、個別のJARファイル（ &lt;code&gt;kotlin-reflect.jar&lt;/code&gt; ）として配布されます。これは、リフレクション機能を使用しないアプリケーションに必要なランタイムライブラリのサイズを削減するために行われます。リフレクションを使用する場合は、プロジェクトのクラスパスに.jarファイルが追加されていることを確認してください。</target>
        </trans-unit>
        <trans-unit id="5d535cc279349339edec2b28152e5485a7cce0a0" translate="yes" xml:space="preserve">
          <source>On the JavaScript platform this code will be compiled &quot;as is&quot;: &lt;code&gt;dyn.whatever(1)&lt;/code&gt; in Kotlin becomes &lt;code&gt;dyn.whatever(1)&lt;/code&gt; in the generated JavaScript code.</source>
          <target state="translated">「そのまま」のコードがコンパイルされたJavaScriptプラットフォーム上： &lt;code&gt;dyn.whatever(1)&lt;/code&gt; Kotlinになる &lt;code&gt;dyn.whatever(1)&lt;/code&gt; 生成されたJavaScriptコードです。</target>
        </trans-unit>
        <trans-unit id="5b66a81be58a9639896f5746359a7ffeeb1b2933" translate="yes" xml:space="preserve">
          <source>On the JavaScript platform, only class references are currently supported. &lt;a href=&quot;js-reflection&quot;&gt;Learn more about reflection in Kotlin/JS&lt;/a&gt;.</source>
          <target state="translated">On the JavaScript platform, only class references are currently supported. &lt;a href=&quot;js-reflection&quot;&gt;Learn more about reflection in Kotlin/JS&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="7710454ff099464789e309cce04c505a88cd2a29" translate="yes" xml:space="preserve">
          <source>On the generic Native platform we don't have the luxury to use someone else's implementation, so we will have to write one ourselves. I won't explain the implementation details here, but it's pretty straightforward and follows Base64 format description without any optimizations:</source>
          <target state="translated">一般的なNativeプラットフォームでは、誰かの実装を使う余裕がないので、自分たちで実装を書かなければなりません。ここでは実装の詳細は説明しませんが、非常に簡単で、最適化されていないBase64フォーマットの記述に従っています。</target>
        </trans-unit>
        <trans-unit id="dc341284a94c1ff306b2072d23ec90c8ced7deca" translate="yes" xml:space="preserve">
          <source>On the one hand, to achieve this, the compiler has to provide certain ABI stability guarantees under the constraints of separate compilation. This is why every change in the language is examined from the point of view of binary compatibility.</source>
          <target state="translated">一方で、これを実現するためには、コンパイラは分離コンパイルの制約の下で、ある種のABI安定性保証を提供しなければなりません。これが、言語のすべての変更がバイナリ互換性の観点から検討される理由です。</target>
        </trans-unit>
        <trans-unit id="000c75f582537e6c16176741f98b45d2d110bbb3" translate="yes" xml:space="preserve">
          <source>On the other hand, Kotlin/Native supports interoperability to use existing libraries directly from Kotlin/Native:</source>
          <target state="translated">一方、Kotlin/Nativeは既存のライブラリをKotlin/Nativeから直接利用するための相互運用性をサポートしています。</target>
        </trans-unit>
        <trans-unit id="60f0f1b25c5dff1f04424f892492e20e71e1b66d" translate="yes" xml:space="preserve">
          <source>On the other hand, a lot depends on the library authors being careful about which changes are safe to make. Thus it's very important that library authors understand how source changes affect compatibility and follow certain best practices to keep both APIs and ABIs of their libraries stable. Here are some assumptions that we make when considering language changes from the library evolution standpoint:</source>
          <target state="translated">一方で、ライブラリの作者がどのような変更を行っても安全であるかについて注意を払うかどうかに大きく依存しています。したがって、ライブラリの作者がソースの変更が互換性にどのような影響を与えるかを理解し、ライブラリのAPIとABIの両方を安定的に保つために、ある種のベストプラクティスに従うことが非常に重要です。ここでは、ライブラリの進化の観点から言語の変更を検討する際に、いくつかの仮定をしています。</target>
        </trans-unit>
        <trans-unit id="24a6b58cfe3e05a456f0e657a9154e03adab1e36" translate="yes" xml:space="preserve">
          <source>On the other hand, if we don't need wildcards where they are generated, we can use &lt;code&gt;@JvmSuppressWildcards&lt;/code&gt;:</source>
          <target state="translated">一方、ワイルドカードが生成される場所で必要ない場合は、 &lt;code&gt;@JvmSuppressWildcards&lt;/code&gt; を使用できます。</target>
        </trans-unit>
        <trans-unit id="9fe83b5bff0a5d4a34dc3a1fd60b88652cfd8998" translate="yes" xml:space="preserve">
          <source>On the other hand, infix function call's precedence is higher than that of the boolean operators &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt;, &lt;code&gt;is&lt;/code&gt;- and &lt;code&gt;in&lt;/code&gt;-checks, and some other operators. These expressions are equivalent as well:</source>
          <target state="translated">一方、infix関数呼び出しの優先順位は、ブール演算子 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; および &lt;code&gt;||&lt;/code&gt; の優先順位よりも高くなっています。、 &lt;code&gt;is&lt;/code&gt; -と &lt;code&gt;in&lt;/code&gt; -checks、およびいくつかの他の演算子。これらの式も同等です。</target>
        </trans-unit>
        <trans-unit id="4b4a432df45f297429fbc3cee76b5f8d7f65a8e2" translate="yes" xml:space="preserve">
          <source>On the other hand, it preserves equality:</source>
          <target state="translated">一方で、平等性を保っている。</target>
        </trans-unit>
        <trans-unit id="7e3c3918cd7bead7b21ab07c18b704638f85c9a4" translate="yes" xml:space="preserve">
          <source>On the other hand, the platform libs in the distribution are merely just wrappers and bindings to the native libraries. That means the native libraries themselves (&lt;code&gt;.so&lt;/code&gt;, &lt;code&gt;.a&lt;/code&gt;, &lt;code&gt;.dylib&lt;/code&gt;, &lt;code&gt;.dll&lt;/code&gt; etc) should be installed on the machine.</source>
          <target state="translated">一方、ディストリビューションのプラットフォームライブラリは、単なるラッパーであり、ネイティブライブラリへのバインディングです。つまり、ネイティブライブラリ自体（ &lt;code&gt;.so&lt;/code&gt; 、 &lt;code&gt;.a&lt;/code&gt; 、 &lt;code&gt;.dylib&lt;/code&gt; 、 &lt;code&gt;.dll&lt;/code&gt; など）をマシンにインストールする必要があります。</target>
        </trans-unit>
        <trans-unit id="a4bdeb370dbf1cefb8a423a42914a31fcb4ec6d9" translate="yes" xml:space="preserve">
          <source>On the other side, by default, a dispatcher for the outer &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html&quot;&gt;CoroutineScope&lt;/a&gt; is inherited. The default dispatcher for &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt; coroutine, in particular, is confined to the invoker thread, so inheriting it has the effect of confining execution to this thread with a predictable FIFO scheduling.</source>
          <target state="translated">一方、デフォルトでは、外側の&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html&quot;&gt;CoroutineScopeの&lt;/a&gt;ディスパッチャーが継承されます。特に、&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt;コルーチンのデフォルトディスパッチャーは呼び出しスレッドに限定されているため、これを継承すると、予測可能なFIFOスケジューリングで実行がこのスレッドに限定されます。</target>
        </trans-unit>
        <trans-unit id="425d42a58936f61d420710d94f729d1304fe83b3" translate="yes" xml:space="preserve">
          <source>On the other side, the dispatcher is inherited from the outer &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html&quot;&gt;CoroutineScope&lt;/a&gt; by default. The default dispatcher for the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt; coroutine, in particular, is confined to the invoker thread, so inheriting it has the effect of confining execution to this thread with predictable FIFO scheduling.</source>
          <target state="translated">On the other side, the dispatcher is inherited from the outer &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html&quot;&gt;CoroutineScope&lt;/a&gt; by default. The default dispatcher for the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt; coroutine, in particular, is confined to the invoker thread, so inheriting it has the effect of confining execution to this thread with predictable FIFO scheduling.</target>
        </trans-unit>
        <trans-unit id="40268462bf212f39b8385da7e84960f17dde7ce2" translate="yes" xml:space="preserve">
          <source>On this page, you'll learn how the modifiers apply to different types of declaring scopes.</source>
          <target state="translated">このページでは、さまざまなタイプの宣言スコープに修飾子がどのように適用されるかについて説明します。</target>
        </trans-unit>
        <trans-unit id="0097b825a22364e0ed5d52b543c2c2d7417ac42f" translate="yes" xml:space="preserve">
          <source>OnErrorAction</source>
          <target state="translated">OnErrorAction</target>
        </trans-unit>
        <trans-unit id="af3390fd9bdb1b1f1af829e06104c3364aeb4907" translate="yes" xml:space="preserve">
          <source>Once a worker is started with the &lt;code&gt;Worker.start&lt;/code&gt; function call, it can be addressed with its own unique integer worker id. Other workers, or non-worker concurrency primitives, such as OS threads, can send a message to the worker with the &lt;code&gt;execute&lt;/code&gt; call.</source>
          <target state="translated">&lt;code&gt;Worker.start&lt;/code&gt; 関数呼び出しでワーカーが開始されると、独自の一意の整数ワーカーIDでアドレス指定できます。他のワーカー、またはOSスレッドなどのワーカー以外の同時実行プリミティブは、 &lt;code&gt;execute&lt;/code&gt; 呼び出しでワーカーにメッセージを送信できます。</target>
        </trans-unit>
        <trans-unit id="df99b41ffc8e8869530eb6fc788d462a8f350ad0" translate="yes" xml:space="preserve">
          <source>Once that's done, we simply right-click on our &lt;code&gt;index.html&lt;/code&gt; file and select the Debug option. This launches Chrome and then stops at the breakpoint defined in our code inside IntelliJ IDEA, from where we can evaluate expressions, step through code, etc.</source>
          <target state="translated">それが完了したら、 &lt;code&gt;index.html&lt;/code&gt; ファイルを右クリックし、[デバッグ]オプションを選択します。これによりChromeが起動し、IntelliJ IDEA内のコードで定義されたブレークポイントで停止します。ブレークポイントから式を評価したり、コードをステップスルーしたりできます。</target>
        </trans-unit>
        <trans-unit id="3775c8ff21ba04eef02e13e8e82e7fea59a82c9d" translate="yes" xml:space="preserve">
          <source>Once the IDE has finished creating the new project, we should be left with the following layout</source>
          <target state="translated">IDE で新しいプロジェクトの作成が完了すると、次のようなレイアウトになります。</target>
        </trans-unit>
        <trans-unit id="d9769c12f9ad9598db953dee152f3b5b5ad3daf0" translate="yes" xml:space="preserve">
          <source>Once the code is ready, select a fragment you want a learner to fill in, invoke &lt;strong&gt;Add Answer Placeholder&lt;/strong&gt; command from the right-click menu and add the placeholder text and some hints to help the learner find the right solution:</source>
          <target state="translated">コードの準備ができたら、学習者に入力してほしいフラグメントを選択し、右クリックメニューから[ &lt;strong&gt;回答のプレースホルダー&lt;/strong&gt;を&lt;strong&gt;追加&lt;/strong&gt; ]コマンドを呼び出し、プレースホルダーテキストといくつかのヒントを追加して、学習者が適切な解決策を見つけられるようにします。</target>
        </trans-unit>
        <trans-unit id="46c1b63ed4fbeaebfc1fd631405807b64e959941" translate="yes" xml:space="preserve">
          <source>Once the dependency is included, we can access the different interfaces provided to generate DOM. The code below will add a new &lt;code&gt;span&lt;/code&gt; tag with the text &lt;code&gt;Hello&lt;/code&gt; inside a &lt;code&gt;div&lt;/code&gt; on the &lt;code&gt;window.load&lt;/code&gt; event.</source>
          <target state="translated">依存関係が含まれると、DOMを生成するために提供されるさまざまなインターフェースにアクセスできます。以下のコードは、新規に追加されます &lt;code&gt;span&lt;/code&gt; テキストとタグを &lt;code&gt;Hello&lt;/code&gt; 内側 &lt;code&gt;div&lt;/code&gt; に &lt;code&gt;window.load&lt;/code&gt; のイベント。</target>
        </trans-unit>
        <trans-unit id="5f0142e56236eba7d0f9779ea0961db259aa8e0d" translate="yes" xml:space="preserve">
          <source>Once the file is created, add the &lt;code&gt;main&lt;/code&gt; function which is the entry point to a Kotlin application. IntelliJ IDEA offers a template to do this quickly. Just type &lt;em&gt;main&lt;/em&gt; and press tab.</source>
          <target state="translated">ファイルが作成されたら、Kotlinアプリケーションへのエントリポイントである &lt;code&gt;main&lt;/code&gt; 関数を追加します。IntelliJ IDEAは、これをすばやく行うためのテンプレートを提供しています。&lt;em&gt;main&lt;/em&gt;と入力してTabキーを押すだけです。</target>
        </trans-unit>
        <trans-unit id="c73312381dcc07c6b7a625ba7ed9e57ac7440a0f" translate="yes" xml:space="preserve">
          <source>Once the plugin is installed and Eclipse is restarted, make sure the plugin is installed correctly: open the &lt;strong&gt;Kotlin perspective&lt;/strong&gt; in the menu &lt;strong&gt;Window | Open Perspective | Other&amp;hellip;&lt;/strong&gt;</source>
          <target state="translated">プラグインをインストールしてEclipseを再起動したら、プラグインが正しくインストールされていることを確認します。メニュー&lt;strong&gt;ウィンドウ&lt;/strong&gt;で&lt;strong&gt;Kotlinパースペクティブ&lt;/strong&gt;を開きます&lt;strong&gt;。パースペクティブを開く| その他&amp;hellip;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ea14fe002f3a94c4720dab1f2d5b5523e7e10653" translate="yes" xml:space="preserve">
          <source>Once we do that, we can start the app by running the following command</source>
          <target state="translated">これを実行したら、次のコマンドを実行してアプリを起動します。</target>
        </trans-unit>
        <trans-unit id="0796366ca4be24e6c9cb8aea2efb2652251fe7de" translate="yes" xml:space="preserve">
          <source>Once we do that, we can then invoke the corresponding extensions, which are properties named after the views in the XML file. For example, for this view:</source>
          <target state="translated">これを実行すると、対応する拡張子を呼び出すことができます。例えば、このビューの場合。</target>
        </trans-unit>
        <trans-unit id="1c271397461aeb676abb2a2efff251e0af0e8c64" translate="yes" xml:space="preserve">
          <source>Once we have the build script defined with the correct dependencies, we can now create a controller</source>
          <target state="translated">ビルドスクリプトを正しい依存関係で定義したら、次はコントローラを作成します。</target>
        </trans-unit>
        <trans-unit id="a08b600d20b04c79c7a79b722bf898a01cce7fce" translate="yes" xml:space="preserve">
          <source>Once we have the definition file ready, we can create project files and open the project in an IDE.</source>
          <target state="translated">定義ファイルの準備ができたら、プロジェクトファイルを作成し、IDEでプロジェクトを開くことができます。</target>
        </trans-unit>
        <trans-unit id="d8045dca300b9f4677fd2c5dc7702ace1a03cfe2" translate="yes" xml:space="preserve">
          <source>Once we have the file generated, we can simply include it in our project and use it:</source>
          <target state="translated">生成されたファイルをプロジェクトにインクルードして使用することができます。</target>
        </trans-unit>
        <trans-unit id="bd56b1bd7445724ec0021ec14943c2a384d08186" translate="yes" xml:space="preserve">
          <source>Once we run the application (using this previous run configuration), and on successful deployment, we should be able to navigate to the browser with the correct url and see the response:</source>
          <target state="translated">アプリケーションを実行し(この前の実行設定を使用して)、デプロイが成功したら、正しい URL でブラウザに移動してレスポンスを見ることができるはずです。</target>
        </trans-unit>
        <trans-unit id="1b6604db47f0dce985d7de59d4f23c0c4c5c9cca" translate="yes" xml:space="preserve">
          <source>Once you complete the steps, Android Studio creates a project. The project already contains all the code and resources for building an application that can run on your Android device or an emulator.</source>
          <target state="translated">ステップを完了すると、Android Studioはプロジェクトを作成します。プロジェクトには、Androidデバイスまたはエミュレータ上で実行できるアプリケーションを構築するためのすべてのコードとリソースがすでに含まれています。</target>
        </trans-unit>
        <trans-unit id="07c62572d32f4ddef7a4fab02344f0c5993a4073" translate="yes" xml:space="preserve">
          <source>Once you have IntelliJ IDEA installed, it's time to create your first Kotlin application.</source>
          <target state="translated">IntelliJ IDEAをインストールしたら、最初のKotlinアプリケーションを作成しましょう。</target>
        </trans-unit>
        <trans-unit id="57c7fbdcf305fcf640a6242dec4553b583c17b02" translate="yes" xml:space="preserve">
          <source>Once you have a source file, add the &lt;code&gt;main&lt;/code&gt; function - the entry point to a Kotlin application. You can simply type &lt;code&gt;main&lt;/code&gt; and invoke code completion by hitting &lt;code&gt;Ctrl + Space&lt;/code&gt;.</source>
          <target state="translated">ソースファイルを取得したら、 &lt;code&gt;main&lt;/code&gt; 機能であるKotlinアプリケーションへのエントリポイントを追加します。単に &lt;code&gt;main&lt;/code&gt; と &lt;code&gt;Ctrl + Space&lt;/code&gt; を押すことでコード補完を呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="5e85f75a1aece4509c955931a0b0a7c85d0dc463" translate="yes" xml:space="preserve">
          <source>Once you have finished writing your code in a scratch or a worksheet, click &lt;strong&gt;Run&lt;/strong&gt;. The execution results will appear in the lines opposite your code.</source>
          <target state="translated">Once you have finished writing your code in a scratch or a worksheet, click &lt;strong&gt;Run&lt;/strong&gt;. The execution results will appear in the lines opposite your code.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
