<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="qt">
    <body>
      <group id="qt">
        <trans-unit id="7ca650c784a62d89aa1bd61df5a5c661ba25f79c" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; receives a &lt;a href=&quot;qevent&quot;&gt;QEvent&lt;/a&gt; of type &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent::ToolTip&lt;/a&gt;, it creates a &lt;a href=&quot;qgraphicsscenehelpevent&quot;&gt;QGraphicsSceneHelpEvent&lt;/a&gt;, which is forwarded to the scene. You can set a tooltip on a &lt;a href=&quot;qgraphicsitem&quot;&gt;QGraphicsItem&lt;/a&gt; with &lt;a href=&quot;qgraphicsitem#setToolTip&quot;&gt;setToolTip()&lt;/a&gt;; by default &lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt; displays the tooltip of the &lt;a href=&quot;qgraphicsitem&quot;&gt;QGraphicsItem&lt;/a&gt; with the highest z-value (i.e, the top-most item) under the mouse position.</source>
          <target state="translated">とき&lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsViewが&lt;/a&gt;受信&lt;a href=&quot;qevent&quot;&gt;QEvent&lt;/a&gt;型の&lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent ::ツールヒントを&lt;/a&gt;、それが作成されます&lt;a href=&quot;qgraphicsscenehelpevent&quot;&gt;QGraphicsSceneHelpEvent&lt;/a&gt;シーンに転送され、。あなたは上のツールチップを設定することができます&lt;a href=&quot;qgraphicsitem&quot;&gt;QGraphicsItem&lt;/a&gt;と&lt;a href=&quot;qgraphicsitem#setToolTip&quot;&gt;setToolTip（）&lt;/a&gt; ; デフォルトで&lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt;のツールチップが表示さ&lt;a href=&quot;qgraphicsitem&quot;&gt;QGraphicsItem&lt;/a&gt;マウス位置の下で最も高いZ値を有する（すなわち、一番上の項目）。</target>
        </trans-unit>
        <trans-unit id="405906d74ba9d56a4a09585d6f6ec8dd6144ef07" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; receives a &lt;a href=&quot;qevent&quot;&gt;QEvent&lt;/a&gt; of type &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent::ToolTip&lt;/a&gt;, it creates a QGraphicsSceneHelpEvent, which is forwarded to the scene. You can set a tooltip on a &lt;a href=&quot;qgraphicsitem&quot;&gt;QGraphicsItem&lt;/a&gt; with &lt;a href=&quot;qgraphicsitem#setToolTip&quot;&gt;setToolTip()&lt;/a&gt;; by default &lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt; displays the tooltip of the &lt;a href=&quot;qgraphicsitem&quot;&gt;QGraphicsItem&lt;/a&gt; with the highest z-value (i.e, the top-most item) under the mouse position.</source>
          <target state="translated">とき&lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsViewが&lt;/a&gt;受信&lt;a href=&quot;qevent&quot;&gt;QEvent&lt;/a&gt;型の&lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent ::ツールヒントを&lt;/a&gt;、それがシーンに転送されQGraphicsSceneHelpEventを作成します。&lt;a href=&quot;qgraphicsitem#setToolTip&quot;&gt;setToolTip（）&lt;/a&gt;を使用して&lt;a href=&quot;qgraphicsitem&quot;&gt;QGraphicsItemに&lt;/a&gt;ツールチップを設定できます。デフォルトで&lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt;のツールチップが表示さ&lt;a href=&quot;qgraphicsitem&quot;&gt;QGraphicsItem&lt;/a&gt;マウス位置の下で最も高いZ値を有する（すなわち、一番上の項目）。</target>
        </trans-unit>
        <trans-unit id="393e354c9ea9f2a89f579509e189a24bb7a827a0" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; receives a &lt;a href=&quot;qhoverevent&quot;&gt;QHoverEvent&lt;/a&gt; event, it translates it into &lt;a href=&quot;qgraphicsscenehoverevent&quot;&gt;QGraphicsSceneHoverEvent&lt;/a&gt;. The event is then forwarded to the &lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt; associated with the view.</source>
          <target state="translated">とき&lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsViewが&lt;/a&gt;受信&lt;a href=&quot;qhoverevent&quot;&gt;QHoverEventの&lt;/a&gt;イベントを、それがに変換し&lt;a href=&quot;qgraphicsscenehoverevent&quot;&gt;QGraphicsSceneHoverEvent&lt;/a&gt;。その後、イベントはビューに関連付けられた&lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsSceneに&lt;/a&gt;転送されます。</target>
        </trans-unit>
        <trans-unit id="3ae68b18a5e42b2ce917dd23d94ec19620288dec" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; receives a &lt;a href=&quot;qhoverevent&quot;&gt;QHoverEvent&lt;/a&gt; event, it translates it into QGraphicsSceneHoverEvent. The event is then forwarded to the &lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt; associated with the view.</source>
          <target state="translated">とき&lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsViewが&lt;/a&gt;受信&lt;a href=&quot;qhoverevent&quot;&gt;QHoverEventの&lt;/a&gt;イベントを、それがQGraphicsSceneHoverEventに変換します。次に、イベントはビューに関連付けられた&lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsSceneに&lt;/a&gt;転送されます。</target>
        </trans-unit>
        <trans-unit id="beba9444d0901cd09b88793cbb92e83a0fb0a4c8" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; receives a &lt;a href=&quot;qmouseevent&quot;&gt;QMouseEvent&lt;/a&gt;, it translates it to a &lt;a href=&quot;qgraphicsscenemouseevent&quot;&gt;QGraphicsSceneMouseEvent&lt;/a&gt;. The event is then forwarded to the &lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt; associated with the view. If the event is not handled by the scene, the view may use it, e.g., for the &lt;a href=&quot;qgraphicsview#DragMode-enum&quot;&gt;DragMode&lt;/a&gt;.</source>
          <target state="translated">とき&lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsViewが&lt;/a&gt;受信&lt;a href=&quot;qmouseevent&quot;&gt;QMouseEventを&lt;/a&gt;、それがに変換し&lt;a href=&quot;qgraphicsscenemouseevent&quot;&gt;QGraphicsSceneMouseEvent&lt;/a&gt;。その後、イベントはビューに関連付けられた&lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsSceneに&lt;/a&gt;転送されます。イベントがシーンで処理されない場合、ビューはそれを使用する場合があります（例：&lt;a href=&quot;qgraphicsview#DragMode-enum&quot;&gt;DragMode）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0d58e00a0b32556ea464156ee58eaa63878af86f" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; receives a &lt;a href=&quot;qmouseevent&quot;&gt;QMouseEvent&lt;/a&gt;, it translates it to a QGraphicsSceneMouseEvent. The event is then forwarded to the &lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt; associated with the view. If the event is not handled by the scene, the view may use it, e.g., for the &lt;a href=&quot;qgraphicsview#DragMode-enum&quot;&gt;DragMode&lt;/a&gt;.</source>
          <target state="translated">とき&lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsViewが&lt;/a&gt;受信&lt;a href=&quot;qmouseevent&quot;&gt;QMouseEventを&lt;/a&gt;、それがQGraphicsSceneMouseEventにそれを変換します。次に、イベントはビューに関連付けられた&lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsSceneに&lt;/a&gt;転送されます。イベントがシーンによって処理されない場合、ビューは、たとえば&lt;a href=&quot;qgraphicsview#DragMode-enum&quot;&gt;DragModeに&lt;/a&gt;それを使用する場合があります。</target>
        </trans-unit>
        <trans-unit id="b1aa704cf88adf38927fd01a2a14f929a34849e2" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qml-qt3d-render-nodraw&quot;&gt;NoDraw&lt;/a&gt; node is present in a FrameGraph branch, this prevents the renderer from rendering any primitive. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;qml-qt3d-render-nodraw&quot;&gt;NoDraw&lt;/a&gt;ノードがFrameGraphブランチに存在する場合、これにより、レンダラーがプリミティブをレンダリングできなくなります。&lt;a href=&quot;#details&quot;&gt;もっと...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d712cc482a400f11481ce544723b23f89d2fced9" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; calls &lt;a href=&quot;https://doc.qt.io/qt-5.13/qaccessible-obsolete.html#updateAccessibility&quot;&gt;updateAccessibility()&lt;/a&gt;, clients that are listening to events are notified of the change. The function is used to post events to the assistive technology, and accessible &lt;a href=&quot;qaccessible#Event-enum&quot;&gt;events&lt;/a&gt; are posted by &lt;a href=&quot;https://doc.qt.io/qt-5.13/qaccessible-obsolete.html#updateAccessibility&quot;&gt;updateAccessibility()&lt;/a&gt;.</source>
          <target state="translated">とき&lt;a href=&quot;qobject&quot;&gt;にQObjectを&lt;/a&gt;呼び出す&lt;a href=&quot;https://doc.qt.io/qt-5.13/qaccessible-obsolete.html#updateAccessibility&quot;&gt;updateAccessibilityを（） &lt;/a&gt;、イベントを聞いているクライアントは、変更が通知されます。この関数は、イベントを支援技術にポストするために使用され、アクセス可能な&lt;a href=&quot;qaccessible#Event-enum&quot;&gt;イベント&lt;/a&gt;は&lt;a href=&quot;https://doc.qt.io/qt-5.13/qaccessible-obsolete.html#updateAccessibility&quot;&gt;updateAccessibility（）&lt;/a&gt;によってポストされます。</target>
        </trans-unit>
        <trans-unit id="a44c30b5bf2354f4fd8f996e028fe8735a8ada05" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; calls &lt;a href=&quot;https://doc.qt.io/qt-5.15/qaccessible-obsolete.html#updateAccessibility&quot;&gt;updateAccessibility()&lt;/a&gt;, clients that are listening to events are notified of the change. The function is used to post events to the assistive technology, and accessible &lt;a href=&quot;qaccessible#Event-enum&quot;&gt;events&lt;/a&gt; are posted by &lt;a href=&quot;https://doc.qt.io/qt-5.15/qaccessible-obsolete.html#updateAccessibility&quot;&gt;updateAccessibility()&lt;/a&gt;.</source>
          <target state="translated">とき&lt;a href=&quot;qobject&quot;&gt;にQObjectを&lt;/a&gt;呼び出す&lt;a href=&quot;https://doc.qt.io/qt-5.15/qaccessible-obsolete.html#updateAccessibility&quot;&gt;updateAccessibilityを（） &lt;/a&gt;、イベントを聞いているクライアントは、変更が通知されます。この関数は、支援技術に&lt;a href=&quot;qaccessible#Event-enum&quot;&gt;イベント&lt;/a&gt;を投稿するために&lt;a href=&quot;https://doc.qt.io/qt-5.15/qaccessible-obsolete.html#updateAccessibility&quot;&gt;使用&lt;/a&gt;され、アクセス可能なイベントはupdateAccessibility（）によって投稿されます。</target>
        </trans-unit>
        <trans-unit id="abe25525c8927613ab9c260ebd469a11b85a3f96" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; calls &lt;a href=&quot;qaccessible#updateAccessibility&quot;&gt;updateAccessibility()&lt;/a&gt;, clients that are listening to events are notified of the change. The function is used to post events to the assistive technology, and accessible &lt;a href=&quot;qaccessible#Event-enum&quot;&gt;events&lt;/a&gt; are posted by &lt;a href=&quot;qaccessible#updateAccessibility&quot;&gt;updateAccessibility()&lt;/a&gt;.</source>
          <target state="translated">とき&lt;a href=&quot;qobject&quot;&gt;にQObjectを&lt;/a&gt;呼び出す&lt;a href=&quot;qaccessible#updateAccessibility&quot;&gt;updateAccessibilityを（） &lt;/a&gt;、イベントを聞いているクライアントは、変更が通知されます。この関数は、支援技術に&lt;a href=&quot;qaccessible#Event-enum&quot;&gt;イベント&lt;/a&gt;を投稿するために&lt;a href=&quot;qaccessible#updateAccessibility&quot;&gt;使用&lt;/a&gt;され、アクセス可能なイベントはupdateAccessibility（）によって投稿されます。</target>
        </trans-unit>
        <trans-unit id="bc5c853e12ceaddd145dd8068a3f01709b57c0cc" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; is deleted, it emits this &lt;a href=&quot;qobject#destroyed&quot;&gt;QObject::destroyed&lt;/a&gt;() signal. We want to catch this signal, wherever we might have a dangling reference to the deleted &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt;, so we can clean it up. A suitable slot signature might be:</source>
          <target state="translated">場合&lt;a href=&quot;qobject&quot;&gt;QObjectのが&lt;/a&gt;削除され、この出射&lt;a href=&quot;qobject#destroyed&quot;&gt;QObjectを::破壊&lt;/a&gt;（）信号を出力します。削除された&lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt;へのぶら下がっている参照がある場合はいつでも、この信号をキャッチして、クリーンアップできるようにします。適切なスロット署名は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="d5dd864966ee74351524f25c84e86e7278c96ac6" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; is moved to another thread, all its children will be automatically moved too.</source>
          <target state="translated">とき&lt;a href=&quot;qobject&quot;&gt;にQObjectが&lt;/a&gt;別のスレッドに移動され、そのすべての子も自動的に移動されます。</target>
        </trans-unit>
        <trans-unit id="5954371cae64cc8ee9901844bd7778dc5d52aaf5" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; is passed to the &lt;a href=&quot;qjsengine#newQObject&quot;&gt;QJSEngine::newQObject&lt;/a&gt;() function, a Qt Script wrapper object is created that can be used to make the &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt;'s signals, slots, properties, and child objects available to scripts.</source>
          <target state="translated">とき&lt;a href=&quot;qobject&quot;&gt;にQObjectが&lt;/a&gt;に渡され&lt;a href=&quot;qjsengine#newQObject&quot;&gt;QJSEngine :: newQObject&lt;/a&gt;（）関数で、Qtのスクリプトのラッパーオブジェクトを作るために使用することができるように作成され&lt;a href=&quot;qobject&quot;&gt;QObjectを&lt;/a&gt;のシグナル、スロット、プロパティを、そして子供がスクリプトに使用可能なオブジェクト。</target>
        </trans-unit>
        <trans-unit id="3af90ba954a525651c11676587fb2037323acba5" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow&lt;/a&gt; instance is deliberately hidden with &lt;a href=&quot;qwindow#hide&quot;&gt;hide&lt;/a&gt;() or &lt;a href=&quot;qwindow#visible-prop&quot;&gt;setVisible&lt;/a&gt;(false), it will stop rendering and its scene graph and graphics context might be released. The &lt;a href=&quot;qquickwindow#sceneGraphInvalidated&quot;&gt;sceneGraphInvalidated&lt;/a&gt;() signal will be emitted when this happens.</source>
          <target state="translated">とき&lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindowの&lt;/a&gt;インスタンスが意図的に隠されている&lt;a href=&quot;qwindow#hide&quot;&gt;非表示&lt;/a&gt;（）または&lt;a href=&quot;qwindow#visible-prop&quot;&gt;のsetVisible&lt;/a&gt;（false）を、それがレンダリングを停止し、そのシーングラフとグラフィックスコンテキストが解放される可能性があります。これが発生すると、&lt;a href=&quot;qquickwindow#sceneGraphInvalidated&quot;&gt;sceneGraphInvalidated&lt;/a&gt;（）シグナルが発行されます。</target>
        </trans-unit>
        <trans-unit id="5554553d845c524ddee2156401f7cea7ba23f3a7" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qt3drender-qmemorybarrier&quot;&gt;QMemoryBarrier&lt;/a&gt; node is found in a FrameGraph branch, the barrier will be enforced prior to any draw or compute command even if these are defined deeper in the branch.</source>
          <target state="translated">とき&lt;a href=&quot;qt3drender-qmemorybarrier&quot;&gt;QMemoryBarrierの&lt;/a&gt;ノードがFrameGraph枝で発見され、バリアは、これらがより深いブランチで定義されている場合でも任意の描画や計算命令に先立って実施されます。</target>
        </trans-unit>
        <trans-unit id="ba17b5ca58006cf8654bdb06b74fa570795c9e22" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qt3drender-qnodraw&quot;&gt;Qt3DRender::QNoDraw&lt;/a&gt; node is present in a FrameGraph branch, this prevents the renderer from rendering any primitive. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">とき&lt;a href=&quot;qt3drender-qnodraw&quot;&gt;Qt3DRender :: QNoDrawの&lt;/a&gt;ノードは、任意のプリミティブをレンダリングするから、この防止レンダラFrameGraphブランチに存在しています。&lt;a href=&quot;#details&quot;&gt;もっと...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="548a84d157a52956b642a6c79fa3b16cff4cbb88" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qt3drender-qnodraw&quot;&gt;Qt3DRender::QNoDraw&lt;/a&gt; node is present in a FrameGraph branch, this prevents the renderer from rendering any primitive. &lt;a href=&quot;qt3drender-qnodraw#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">とき&lt;a href=&quot;qt3drender-qnodraw&quot;&gt;Qt3DRender :: QNoDrawの&lt;/a&gt;ノードは、任意のプリミティブをレンダリングするから、この防止レンダラFrameGraphブランチに存在しています。&lt;a href=&quot;qt3drender-qnodraw#details&quot;&gt;もっと...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3cd19e17aad321610c519687f38dc05666afdeec" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qt3drender-qnopicking&quot;&gt;Qt3DRender::QNoPicking&lt;/a&gt; node is present in a FrameGraph branch, this prevents the render aspect from performing picking selection for the given branch. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">場合&lt;a href=&quot;qt3drender-qnopicking&quot;&gt;Qt3DRender :: QNoPickingの&lt;/a&gt;ノードがFrameGraph分岐中に存在する、この防止は、所与のブランチに対してピッキング選択を行うの局面をレンダリング。&lt;a href=&quot;#details&quot;&gt;もっと...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="48029ceeb2e178ce68055405481fb634ea787fe6" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qt3drender-qnopicking&quot;&gt;Qt3DRender::QNoPicking&lt;/a&gt; node is present in a FrameGraph branch, this prevents the render aspect from performing picking selection for the given branch. &lt;a href=&quot;qt3drender-qnopicking#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">場合&lt;a href=&quot;qt3drender-qnopicking&quot;&gt;Qt3DRender :: QNoPickingの&lt;/a&gt;ノードがFrameGraph分岐中に存在する、この防止は、所与のブランチに対してピッキング選択を行うの局面をレンダリング。&lt;a href=&quot;qt3drender-qnopicking#details&quot;&gt;もっと...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="88153895f9568d781c480af110178d98fc9ac494" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qtoolbar&quot;&gt;QToolBar&lt;/a&gt; is not a child of a &lt;a href=&quot;qmainwindow&quot;&gt;QMainWindow&lt;/a&gt;, it loses the ability to populate the extension pop up with widgets added to the toolbar using &lt;a href=&quot;qtoolbar#addWidget&quot;&gt;addWidget&lt;/a&gt;(). Please use widget actions created by inheriting &lt;a href=&quot;qwidgetaction&quot;&gt;QWidgetAction&lt;/a&gt; and implementing &lt;a href=&quot;qwidgetaction#createWidget&quot;&gt;QWidgetAction::createWidget&lt;/a&gt;() instead.</source>
          <target state="translated">とき&lt;a href=&quot;qtoolbar&quot;&gt;QToolBarは&lt;/a&gt;の子ではない&lt;a href=&quot;qmainwindow&quot;&gt;QMainWindow&lt;/a&gt;、それは使用してツールバーに追加するウィジェットをポップアップ表示拡張子を移入する能力を失う&lt;a href=&quot;qtoolbar#addWidget&quot;&gt;addWidgetを&lt;/a&gt;（）。継承して作成したウィジェットアクションを使用してください&lt;a href=&quot;qwidgetaction&quot;&gt;QWidgetActionを&lt;/a&gt;して実装&lt;a href=&quot;qwidgetaction#createWidget&quot;&gt;QWidgetActionを:: createWidgetを&lt;/a&gt;代わりに（）。</target>
        </trans-unit>
        <trans-unit id="ea339d196247f8a4535ab539b791214e5503ae1d" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qwizardpage#subTitle-prop&quot;&gt;subTitle&lt;/a&gt; is set, &lt;a href=&quot;qwizard&quot;&gt;QWizard&lt;/a&gt; displays it in a header, in which case it also uses the &lt;a href=&quot;qwizard#WizardPixmap-enum&quot;&gt;BannerPixmap&lt;/a&gt; and the &lt;a href=&quot;qwizard#WizardPixmap-enum&quot;&gt;LogoPixmap&lt;/a&gt; to decorate the header. The &lt;a href=&quot;qwizard#WizardPixmap-enum&quot;&gt;WatermarkPixmap&lt;/a&gt; is displayed on the left side, below the header. At the bottom, there is a row of buttons allowing the user to navigate through the pages.</source>
          <target state="translated">場合&lt;a href=&quot;qwizardpage#subTitle-prop&quot;&gt;字幕&lt;/a&gt;セット、ある&lt;a href=&quot;qwizard&quot;&gt;QWizardの&lt;/a&gt;それはまた、使用する場合にはヘッダ内のディスプレイを、&lt;a href=&quot;qwizard#WizardPixmap-enum&quot;&gt;BannerPixmap&lt;/a&gt;と&lt;a href=&quot;qwizard#WizardPixmap-enum&quot;&gt;LogoPixmapの&lt;/a&gt;ヘッダを飾ります。&lt;a href=&quot;qwizard#WizardPixmap-enum&quot;&gt;WatermarkPixmapは&lt;/a&gt;ヘッダの下、左側に表示されています。下部には、ユーザーがページ間を移動できるボタンの列があります。</target>
        </trans-unit>
        <trans-unit id="399d5e73a4a8b06dd36c1720633609c913f08193" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qwizardpage#subTitle-prop&quot;&gt;subTitle&lt;/a&gt; is set, QWizard displays it in a header, in which case it also uses the &lt;a href=&quot;qwizard#WizardPixmap-enum&quot;&gt;BannerPixmap&lt;/a&gt; and the &lt;a href=&quot;qwizard#WizardPixmap-enum&quot;&gt;LogoPixmap&lt;/a&gt; to decorate the header. The &lt;a href=&quot;qwizard#WizardPixmap-enum&quot;&gt;WatermarkPixmap&lt;/a&gt; is displayed on the left side, below the header. At the bottom, there is a row of buttons allowing the user to navigate through the pages.</source>
          <target state="translated">場合&lt;a href=&quot;qwizardpage#subTitle-prop&quot;&gt;字幕&lt;/a&gt;セット、それはまた、使用する場合にはヘッダ内QWizardディスプレイを、ある&lt;a href=&quot;qwizard#WizardPixmap-enum&quot;&gt;BannerPixmap&lt;/a&gt;と&lt;a href=&quot;qwizard#WizardPixmap-enum&quot;&gt;LogoPixmapの&lt;/a&gt;ヘッダを飾ります。&lt;a href=&quot;qwizard#WizardPixmap-enum&quot;&gt;WatermarkPixmapは&lt;/a&gt;ヘッダの下、左側に表示されています。下部には、ユーザーがページをナビゲートできるようにするボタンの列があります。</target>
        </trans-unit>
        <trans-unit id="7322771e8958658ead503160124f934fb65197f8" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;&amp;lt;content&amp;gt;&lt;/code&gt; element is used, the data will contain a single item with either the value of the</source>
          <target state="translated">場合 &lt;code&gt;&amp;lt;content&amp;gt;&lt;/code&gt; 要素が使用され、データは、値のいずれかで単一の項目を含むであろう</target>
        </trans-unit>
        <trans-unit id="2672663ccea1c72ceff571e1774f7c56bc159e61" translate="yes" xml:space="preserve">
          <source>When a D-Bus function returns a D-Bus variant, it can be retrieved as follows:</source>
          <target state="translated">D-Bus関数がD-Busバリアントを返す場合、以下のように取得することができます。</target>
        </trans-unit>
        <trans-unit id="1017702957d7db1428d00195f1759c2c2ce9ca31" translate="yes" xml:space="preserve">
          <source>When a JavaScript file is imported this way, it is imported with a qualifier. The functions in that file are then accessible from the importing script via the qualifier (that is, as &lt;code&gt;Qualifier.functionName(params)&lt;/code&gt;).</source>
          <target state="translated">この方法でJavaScriptファイルをインポートすると、修飾子付きでインポートされます。そのファイル内の関数は、修飾子を介して（つまり、 &lt;code&gt;Qualifier.functionName(params)&lt;/code&gt; として）インポートスクリプトからアクセスできます。</target>
        </trans-unit>
        <trans-unit id="8955c961f4e03b5b4c423d7e27242490dcc367cd" translate="yes" xml:space="preserve">
          <source>When a NoDraw node is present in a FrameGraph branch, this prevents the renderer from rendering any primitive. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">NoDrawノードがFrameGraphブランチに存在する場合、これにより、レンダラーはプリミティブをレンダリングできなくなります。&lt;a href=&quot;#details&quot;&gt;もっと...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9346322a98372696210b54e5c6837cb02553ab5b" translate="yes" xml:space="preserve">
          <source>When a NoPicking node is present in a FrameGraph branch, this prevents the render aspect from performing picking selection for the given branch. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">NoPickingノードがFrameGraphブランチに存在する場合、これにより、レンダーアスペクトが特定のブランチのピッキング選択を実行できなくなります。&lt;a href=&quot;#details&quot;&gt;もっと...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b5239011b0ce80a40d0520fced8dbad82a40aa0a" translate="yes" xml:space="preserve">
          <source>When a Plugin object is created, it is &quot;detached&quot; and not associated with any actual service plugin. Once it has received information via setting its &lt;a href=&quot;qml-qtlocation-plugin#name-prop&quot;&gt;name&lt;/a&gt;, &lt;a href=&quot;qml-qtlocation-plugin#preferred-prop&quot;&gt;preferred&lt;/a&gt;, or &lt;a href=&quot;qml-qtlocation-plugin#required-prop&quot;&gt;required&lt;/a&gt; properties, it will choose an appropriate service plugin to attach to. Plugin objects can only be attached once; to use multiple plugins, create multiple Plugin objects.</source>
          <target state="translated">プラグインオブジェクトが作成されると、「デタッチ」され、実際のサービスプラグインには関連付けられません。&lt;a href=&quot;qml-qtlocation-plugin#name-prop&quot;&gt;name&lt;/a&gt;、&lt;a href=&quot;qml-qtlocation-plugin#preferred-prop&quot;&gt;preferred&lt;/a&gt;、または&lt;a href=&quot;qml-qtlocation-plugin#required-prop&quot;&gt;required&lt;/a&gt;プロパティを設定して情報を受け取ると、接続する適切なサービスプラグインを選択します。プラグインオブジェクトは一度だけアタッチできます。複数のプラグインを使用するには、複数のプラグインオブジェクトを作成します。</target>
        </trans-unit>
        <trans-unit id="b6f220e6e802d62e7eddcb10a35ca79f2887d75d" translate="yes" xml:space="preserve">
          <source>When a QML &lt;a href=&quot;qml-qtquick-item&quot;&gt;Item&lt;/a&gt; explicitly relinquishes focus (by setting its &lt;code&gt;focus&lt;/code&gt; property to &lt;code&gt;false&lt;/code&gt; while it has active focus), the system does not automatically select another type to receive focus. That is, it is possible for there to be no currently active focus.</source>
          <target state="translated">QML &lt;a href=&quot;qml-qtquick-item&quot;&gt;アイテムが&lt;/a&gt;明示的にフォーカスを放棄するとき（アクティブなフォーカスがある間に &lt;code&gt;focus&lt;/code&gt; プロパティを &lt;code&gt;false&lt;/code&gt; に設定することにより）、システムはフォーカスを受け取る別のタイプを自動的に選択しません。つまり、現在アクティブなフォーカスがない可能性があります。</target>
        </trans-unit>
        <trans-unit id="7001a12de2df6c574e67e9da9ad3f2fc320aad4f" translate="yes" xml:space="preserve">
          <source>When a QML object type is used as a signal parameter, the parameter should use &lt;a href=&quot;qml-var&quot;&gt;var&lt;/a&gt; as the type, and the value should be received in C++ using the &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; type:</source>
          <target state="translated">QMLオブジェクトタイプがシグナルパラメーターとして使用される場合、パラメーターはタイプとして&lt;a href=&quot;qml-var&quot;&gt;var&lt;/a&gt;を使用し、値は&lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt;タイプを使用してC ++で受信される必要があります。</target>
        </trans-unit>
        <trans-unit id="15f000278e72ce7b8d6c307887252da7193e1ede" translate="yes" xml:space="preserve">
          <source>When a QMemoryBarrier node is found in a FrameGraph branch, the barrier will be enforced prior to any draw or compute command even if these are defined deeper in the branch.</source>
          <target state="translated">QMemoryBarrier ノードが FrameGraph ブランチの中で見つかった場合、たとえこれらのノードがブランチの奥深くで定義されていたとしても、そのバリアは描画や計算コマンドの前に適用されます。</target>
        </trans-unit>
        <trans-unit id="d860d62ecdfb8b15dcaa97f6730ceece19277c00" translate="yes" xml:space="preserve">
          <source>When a QObject is moved to another thread, all its children will be automatically moved too.</source>
          <target state="translated">QObject を別のスレッドに移動させると、その子も自動的に移動されます。</target>
        </trans-unit>
        <trans-unit id="ea1c515ed9acd99ab3e2af205a882f706575ebe6" translate="yes" xml:space="preserve">
          <source>When a QQuickWindow instance is deliberately hidden with &lt;a href=&quot;qwindow#hide&quot;&gt;hide&lt;/a&gt;() or &lt;a href=&quot;qwindow#visible-prop&quot;&gt;setVisible&lt;/a&gt;(false), it will stop rendering and its scene graph and graphics context might be released as well. This depends on the settings configured by &lt;a href=&quot;qquickwindow#setPersistentGraphics&quot;&gt;setPersistentGraphics&lt;/a&gt;() and &lt;a href=&quot;qquickwindow#setPersistentSceneGraph&quot;&gt;setPersistentSceneGraph&lt;/a&gt;(). The behavior in this respect is identical to explicitly calling the &lt;a href=&quot;qquickwindow#releaseResources&quot;&gt;releaseResources&lt;/a&gt;() function. A window can become not exposed, in other words non-renderable, by other means as well. This depends on the platform and windowing system. For example, on Windows minimizing a window makes it stop rendering. On macOS fully obscuring a window by other windows on top triggers the same. On Linux/X11, the behavior is dependent on the window manager.</source>
          <target state="translated">QQuickWindowインスタンスが&lt;a href=&quot;qwindow#hide&quot;&gt;hide&lt;/a&gt;（）または&lt;a href=&quot;qwindow#visible-prop&quot;&gt;setVisible&lt;/a&gt;（false）で意図的に非表示にされると、レンダリングが停止し、シーングラフとグラフィックスコンテキストも解放される可能性があります。これは、&lt;a href=&quot;qquickwindow#setPersistentGraphics&quot;&gt;setPersistentGraphics&lt;/a&gt;（）および&lt;a href=&quot;qquickwindow#setPersistentSceneGraph&quot;&gt;setPersistentSceneGraph&lt;/a&gt;（）によって構成された設定によって異なります。この点での動作は、&lt;a href=&quot;qquickwindow#releaseResources&quot;&gt;releaseResources&lt;/a&gt;を明示的に呼び出すことと同じです。（） 関数。他の方法でも、ウィンドウが露出しない、つまりレンダリングできなくなる可能性があります。これは、プラットフォームとウィンドウシステムによって異なります。たとえば、Windowsでは、ウィンドウを最小化するとレンダリングが停止します。macOSでは、上部の他のウィンドウによってウィンドウを完全に隠すと、同じようにトリガーされます。Linux / X11では、動作はウィンドウマネージャーに依存します。</target>
        </trans-unit>
        <trans-unit id="9bcadc0cb5a7c58faa28e7459e38798e9f6a2b6b" translate="yes" xml:space="preserve">
          <source>When a QQuickWindow instance is deliberately hidden with &lt;a href=&quot;qwindow#hide&quot;&gt;hide&lt;/a&gt;() or &lt;a href=&quot;qwindow#visible-prop&quot;&gt;setVisible&lt;/a&gt;(false), it will stop rendering and its scene graph and graphics context might be released. The &lt;a href=&quot;qquickwindow#sceneGraphInvalidated&quot;&gt;sceneGraphInvalidated&lt;/a&gt;() signal will be emitted when this happens.</source>
          <target state="translated">QQuickWindowインスタンスが&lt;a href=&quot;qwindow#hide&quot;&gt;hide&lt;/a&gt;（）または&lt;a href=&quot;qwindow#visible-prop&quot;&gt;setVisible&lt;/a&gt;（false）で意図的に非表示にされると、レンダリングが停止し、シーングラフとグラフィックスコンテキストが解放される可能性があります。これが発生すると、&lt;a href=&quot;qquickwindow#sceneGraphInvalidated&quot;&gt;sceneGraphInvalidated&lt;/a&gt;（）シグナルが発行されます。</target>
        </trans-unit>
        <trans-unit id="fc28ed271581b3aeebbcb657c64d87496cc2b2e9" translate="yes" xml:space="preserve">
          <source>When a QToolBar is not a child of a &lt;a href=&quot;qmainwindow&quot;&gt;QMainWindow&lt;/a&gt;, it loses the ability to populate the extension pop up with widgets added to the toolbar using &lt;a href=&quot;qtoolbar#addWidget&quot;&gt;addWidget&lt;/a&gt;(). Please use widget actions created by inheriting &lt;a href=&quot;qwidgetaction&quot;&gt;QWidgetAction&lt;/a&gt; and implementing &lt;a href=&quot;qwidgetaction#createWidget&quot;&gt;QWidgetAction::createWidget&lt;/a&gt;() instead.</source>
          <target state="translated">QToolBarはの子でない場合は&lt;a href=&quot;qmainwindow&quot;&gt;QMainWindow&lt;/a&gt;、それは使用してツールバーに追加するウィジェットをポップアップ表示拡張子を移入する能力を失う&lt;a href=&quot;qtoolbar#addWidget&quot;&gt;addWidgetを&lt;/a&gt;（）。継承して作成したウィジェットアクションを使用してください&lt;a href=&quot;qwidgetaction&quot;&gt;QWidgetActionを&lt;/a&gt;して実装&lt;a href=&quot;qwidgetaction#createWidget&quot;&gt;QWidgetActionを:: createWidgetを&lt;/a&gt;代わりに（）。</target>
        </trans-unit>
        <trans-unit id="f8aa88cb70cc32f83b8553c1a39321db3fc1b25e" translate="yes" xml:space="preserve">
          <source>When a Qt3DRender::QNoDraw node is present in a FrameGraph branch, this prevents the renderer from rendering any primitive</source>
          <target state="translated">Qt3DRender::QNoDraw ノードが FrameGraph ブランチに存在する場合、これによりレンダラーはプリミティブな</target>
        </trans-unit>
        <trans-unit id="7f62ed373c0ee65b35bdb2fc2d57ef6032e4e244" translate="yes" xml:space="preserve">
          <source>When a Qt3DRender::QNoPicking node is present in a FrameGraph branch, this prevents the render aspect from performing picking selection for the given branch</source>
          <target state="translated">Qt3DRender::QNoPicking ノードが FrameGraph ブランチに存在する場合、これにより、レンダリングアスペクトが指定されたブランチのピッキング選択を実行できなくなります。</target>
        </trans-unit>
        <trans-unit id="80a5e58bd25120521267d228a0fa00372555a677" translate="yes" xml:space="preserve">
          <source>When a TextureInput property is declared in an &lt;a href=&quot;qml-qtquick3d-effect&quot;&gt;Effect&lt;/a&gt; or a &lt;a href=&quot;qml-qtquick3d-custommaterial&quot;&gt;CustomMaterial&lt;/a&gt;, it will automatically be available as a sampler in all shaders by its property name.</source>
          <target state="translated">TextureInputプロパティが&lt;a href=&quot;qml-qtquick3d-effect&quot;&gt;Effect&lt;/a&gt;または&lt;a href=&quot;qml-qtquick3d-custommaterial&quot;&gt;CustomMaterial&lt;/a&gt;で宣言されている場合、そのプロパティ名によってすべてのシェーダーでサンプラーとして自動的に使用可能になります。</target>
        </trans-unit>
        <trans-unit id="40263f24ec17a09841c1926737df4393300f3b67" translate="yes" xml:space="preserve">
          <source>When a button is clicked in the button box, the &lt;a href=&quot;qdialogbuttonbox#clicked&quot;&gt;clicked&lt;/a&gt;() signal is emitted for the actual button is that is pressed. For convenience, if the button has an &lt;a href=&quot;qdialogbuttonbox#ButtonRole-enum&quot;&gt;AcceptRole&lt;/a&gt;, &lt;a href=&quot;qdialogbuttonbox#ButtonRole-enum&quot;&gt;RejectRole&lt;/a&gt;, or &lt;a href=&quot;qdialogbuttonbox#ButtonRole-enum&quot;&gt;HelpRole&lt;/a&gt;, the &lt;a href=&quot;qdialogbuttonbox#accepted&quot;&gt;accepted&lt;/a&gt;(), &lt;a href=&quot;qdialogbuttonbox#rejected&quot;&gt;rejected&lt;/a&gt;(), or &lt;a href=&quot;qdialogbuttonbox#helpRequested&quot;&gt;helpRequested&lt;/a&gt;() signals are emitted respectively.</source>
          <target state="translated">ボタンがボタンボックスで&lt;a href=&quot;qdialogbuttonbox#clicked&quot;&gt;クリック&lt;/a&gt;されると、クリックされた（）信号は、押された実際のボタンに対して発行されます。便宜上、ボタンに&lt;a href=&quot;qdialogbuttonbox#ButtonRole-enum&quot;&gt;AcceptRole&lt;/a&gt;、&lt;a href=&quot;qdialogbuttonbox#ButtonRole-enum&quot;&gt;RejectRole&lt;/a&gt;、または&lt;a href=&quot;qdialogbuttonbox#ButtonRole-enum&quot;&gt;HelpRoleがある&lt;/a&gt;場合、&lt;a href=&quot;qdialogbuttonbox#accepted&quot;&gt;accepted&lt;/a&gt;（）、&lt;a href=&quot;qdialogbuttonbox#rejected&quot;&gt;rejected&lt;/a&gt;（）、または&lt;a href=&quot;qdialogbuttonbox#helpRequested&quot;&gt;helpRequested&lt;/a&gt;（）のシグナルがそれぞれ発行されます。</target>
        </trans-unit>
        <trans-unit id="3391d8c7ccaaea73a623e4d861dba6f56e546160" translate="yes" xml:space="preserve">
          <source>When a button is clicked in the button box, the &lt;a href=&quot;qml-qtquick-controls2-dialogbuttonbox#clicked-signal&quot;&gt;clicked()&lt;/a&gt; signal is emitted for the actual button that is pressed. In addition, the following signals are automatically emitted when a button with the respective role(s) is pressed:</source>
          <target state="translated">ボタンボックスでボタンがクリックされると、&lt;a href=&quot;qml-qtquick-controls2-dialogbuttonbox#clicked-signal&quot;&gt;クリック&lt;/a&gt;された実際のボタンに対してclicked（）シグナルが発行されます。さらに、それぞれの役割を持つボタンが押されると、次の信号が自動的に送信されます。</target>
        </trans-unit>
        <trans-unit id="06c02f6a9dbac4345d72fdb9bb347db0a2b3bcdc" translate="yes" xml:space="preserve">
          <source>When a category is removed, the &lt;a href=&quot;qplacemanager&quot;&gt;QPlaceManager&lt;/a&gt; may emit the &lt;a href=&quot;qplacemanager#categoryRemoved&quot;&gt;QPlaceManager::categoryRemoved&lt;/a&gt;() signal. Whether a manager does so is provider specific. Managers accessing places from a web service will typically not emit these signals, while managers accessing places stored locally generally will.</source>
          <target state="translated">カテゴリが削除されると、&lt;a href=&quot;qplacemanager&quot;&gt;QPlaceManager&lt;/a&gt;は&lt;a href=&quot;qplacemanager#categoryRemoved&quot;&gt;QPlaceManager :: categoryRemoved&lt;/a&gt;（）シグナルを発行する場合があります。マネージャーがそうするかどうかはプロバイダー固有です。通常、Webサービスから場所にアクセスするマネージャーはこれらの信号を発行しませんが、ローカルに保存されている場所にアクセスするマネージャーは通常は送信します。</target>
        </trans-unit>
        <trans-unit id="2153d9fed3f02a16b6a6ca1c21681db29241b851" translate="yes" xml:space="preserve">
          <source>When a category is saved, the &lt;a href=&quot;qplacemanager&quot;&gt;QPlaceManager&lt;/a&gt; may emit &lt;a href=&quot;qplacemanager#categoryAdded&quot;&gt;QPlaceManager::categoryAdded&lt;/a&gt;() or &lt;a href=&quot;qplacemanager#categoryUpdated&quot;&gt;QPlaceManager::categoryUpdated&lt;/a&gt;() signals. However whether a manager does so or not is provider specific, managers accessing places from a web service will typically not emit these signals while managers accessing places locally stored generally will.</source>
          <target state="translated">カテゴリーが保存されると、&lt;a href=&quot;qplacemanager&quot;&gt;QPlaceManager&lt;/a&gt;は&lt;a href=&quot;qplacemanager#categoryAdded&quot;&gt;QPlaceManager :: categoryAdded&lt;/a&gt;（）または&lt;a href=&quot;qplacemanager#categoryUpdated&quot;&gt;QPlaceManager :: categoryUpdated&lt;/a&gt;（）シグナルを発行します。ただし、マネージャーがそうであるかどうかはプロバイダー固有であり、Webサービスから場所にアクセスするマネージャーは通常、これらの信号を発行しませんが、ローカルに保存されている場所にアクセスするマネージャーは通常は送信します。</target>
        </trans-unit>
        <trans-unit id="74e1cabc1808cac1af0ca6415a34d8121f46bf6d" translate="yes" xml:space="preserve">
          <source>When a certain configuration is requested explicitly, no checks are done at application startup, that is, the system-provided opengl32.dll will not be examined.</source>
          <target state="translated">特定の設定が明示的に要求された場合、アプリケーションの起動時にチェックは行われず、システムが提供するopengl32.dllは検査されません。</target>
        </trans-unit>
        <trans-unit id="0d7ef2995bb1b9278679a4db6eb4f1c8a80df088" translate="yes" xml:space="preserve">
          <source>When a child layout object is selected, its parent layout object can be selected by pressing down the &lt;b&gt;Shift&lt;/b&gt; key while clicking on it. This makes it possible to select a specific layout in a hierarchy, which is otherwise difficult due to the small frame.</source>
          <target state="translated">子レイアウトオブジェクトを選択すると、&lt;b&gt;Shift&lt;/b&gt;キーを押しながらクリックすると、その親レイアウトオブジェクトを選択できます。これにより、フレームが小さいために困難な階層内の特定のレイアウトを選択できるようになります。</target>
        </trans-unit>
        <trans-unit id="4d44facce222efbda291b9b00896c00605e23c4d" translate="yes" xml:space="preserve">
          <source>When a class is marked &lt;a href=&quot;#reentrant-command&quot;&gt;\reentrant&lt;/a&gt; or &lt;a href=&quot;#threadsafe-command&quot;&gt;\threadsafe&lt;/a&gt;, functions in that class can be marked &lt;code&gt;nonreentrant&lt;/code&gt; using the &lt;a href=&quot;#nonreentrant-command&quot;&gt;\nonreentrant&lt;/a&gt; command.</source>
          <target state="translated">クラスがマークされている場合は&lt;a href=&quot;#reentrant-command&quot;&gt;、\リエントラント&lt;/a&gt;または&lt;a href=&quot;#threadsafe-command&quot;&gt;\スレッドセーフは&lt;/a&gt;、そのクラス内の関数をマークすることができる &lt;code&gt;nonreentrant&lt;/code&gt; 使用して&lt;a href=&quot;#nonreentrant-command&quot;&gt;\非リエントラント&lt;/a&gt;コマンドを。</target>
        </trans-unit>
        <trans-unit id="0630e10d812ca6a44e69948c6fbb1d3fde2d9e6c" translate="yes" xml:space="preserve">
          <source>When a class is marked &lt;a href=&quot;#reentrant-command&quot;&gt;\reentrant&lt;/a&gt; or &lt;a href=&quot;#threadsafe-command&quot;&gt;\threadsafe&lt;/a&gt;, functions in that class can be marked &lt;code&gt;nonreentrant&lt;/code&gt; using this command in the &lt;a href=&quot;https://doc.qt.io/qt-5.13/13-qdoc-commands-topics.html#fn-command&quot;&gt;\fn&lt;/a&gt; comment of the functions to be excluded.</source>
          <target state="translated">クラスが&lt;a href=&quot;#reentrant-command&quot;&gt;\ &lt;/a&gt; &lt;code&gt;nonreentrant&lt;/code&gt; または&lt;a href=&quot;#threadsafe-command&quot;&gt;\ threadsafe&lt;/a&gt;とマークされている場合、そのクラスの関数は、除外する関数の&lt;a href=&quot;https://doc.qt.io/qt-5.13/13-qdoc-commands-topics.html#fn-command&quot;&gt;\ fn&lt;/a&gt;コメントでこのコマンドを使用して、非再入可能とマークできます。</target>
        </trans-unit>
        <trans-unit id="2cd634a18329e27eaf5d023e852ce4e96a7d4f77" translate="yes" xml:space="preserve">
          <source>When a class is marked &lt;a href=&quot;17-qdoc-commands-thread#reentrant-command&quot;&gt;\reentrant&lt;/a&gt; or &lt;a href=&quot;17-qdoc-commands-thread#threadsafe-command&quot;&gt;\threadsafe&lt;/a&gt;, functions in that class can be marked &lt;code&gt;nonreentrant&lt;/code&gt; using the &lt;a href=&quot;17-qdoc-commands-thread#nonreentrant-command&quot;&gt;\nonreentrant&lt;/a&gt; command.</source>
          <target state="translated">クラスがマークされている場合は&lt;a href=&quot;17-qdoc-commands-thread#reentrant-command&quot;&gt;、\リエントラント&lt;/a&gt;または&lt;a href=&quot;17-qdoc-commands-thread#threadsafe-command&quot;&gt;\スレッドセーフは&lt;/a&gt;、そのクラス内の関数をマークすることができる &lt;code&gt;nonreentrant&lt;/code&gt; 使用して&lt;a href=&quot;17-qdoc-commands-thread#nonreentrant-command&quot;&gt;\非リエントラント&lt;/a&gt;コマンドを。</target>
        </trans-unit>
        <trans-unit id="c7d7a9372711646e9a74f31e8f75f68b4197251e" translate="yes" xml:space="preserve">
          <source>When a class is marked &lt;a href=&quot;17-qdoc-commands-thread#reentrant-command&quot;&gt;\reentrant&lt;/a&gt; or &lt;a href=&quot;17-qdoc-commands-thread#threadsafe-command&quot;&gt;\threadsafe&lt;/a&gt;, functions in that class can be marked &lt;code&gt;nonreentrant&lt;/code&gt; using this command in the &lt;a href=&quot;https://doc.qt.io/qt-5.15/13-qdoc-commands-topics.html#fn-command&quot;&gt;\fn&lt;/a&gt; comment of the functions to be excluded.</source>
          <target state="translated">クラスが&lt;a href=&quot;17-qdoc-commands-thread#reentrant-command&quot;&gt;\ &lt;/a&gt; &lt;code&gt;nonreentrant&lt;/code&gt; または&lt;a href=&quot;17-qdoc-commands-thread#threadsafe-command&quot;&gt;\ threadsafe&lt;/a&gt;とマークされている場合、除外する関数の&lt;a href=&quot;https://doc.qt.io/qt-5.15/13-qdoc-commands-topics.html#fn-command&quot;&gt;\ fn&lt;/a&gt;コメントでこのコマンドを使用して、そのクラスの関数を非再入可能とマークできます。</target>
        </trans-unit>
        <trans-unit id="8204c9b3a557911ce4c0ccc0839328bb77424f63" translate="yes" xml:space="preserve">
          <source>When a class is marked &lt;a href=&quot;17-qdoc-commands-thread#reentrant-command&quot;&gt;\reentrant&lt;/a&gt; or &lt;a href=&quot;17-qdoc-commands-thread#threadsafe-command&quot;&gt;\threadsafe&lt;/a&gt;, functions in that class can be marked &lt;code&gt;nonreentrant&lt;/code&gt; using this command in the &lt;a href=&quot;https://doc.qt.io/qt-6.0/13-qdoc-commands-topics.html#fn-command&quot;&gt;\fn&lt;/a&gt; comment of the functions to be excluded.</source>
          <target state="translated">クラスが&lt;a href=&quot;17-qdoc-commands-thread#reentrant-command&quot;&gt;\ &lt;/a&gt; &lt;code&gt;nonreentrant&lt;/code&gt; または&lt;a href=&quot;17-qdoc-commands-thread#threadsafe-command&quot;&gt;\ threadsafe&lt;/a&gt;とマークされている場合、除外する関数の&lt;a href=&quot;https://doc.qt.io/qt-6.0/13-qdoc-commands-topics.html#fn-command&quot;&gt;\ fn&lt;/a&gt;コメントでこのコマンドを使用して、そのクラスの関数を非再入可能としてマークできます。</target>
        </trans-unit>
        <trans-unit id="cb8493d30c9e50739fc7b9788b39ac10cc03ca43" translate="yes" xml:space="preserve">
          <source>When a composition mode is set it applies to all painting operator, pens, brushes, gradients and pixmap/image drawing.</source>
          <target state="translated">構図モードが設定されている場合、それはすべてのペイント演算子、ペン、ブラシ、グラデーション、およびpixmap/画像描画に適用されます。</target>
        </trans-unit>
        <trans-unit id="38b6f0bc81c40f221944d8b87c8853be0ed28449" translate="yes" xml:space="preserve">
          <source>When a container extension is required,</source>
          <target state="translated">コンテナの拡張が必要な場合</target>
        </trans-unit>
        <trans-unit id="3d9cf71db83196446628da0ad23fab2682179bc2" translate="yes" xml:space="preserve">
          <source>When a custom shader snippet uses the &lt;code&gt;DEPTH_TEXTURE&lt;/code&gt; or &lt;code&gt;SCREEN_TEXTURE&lt;/code&gt; keywords, it opts in to generating the corresponding textures in a separate render pass, which is not necessarily a cheap operation, but allows implementing a variety of techniques, such as refraction for glass-like materials.</source>
          <target state="translated">カスタムシェーダースニペットが &lt;code&gt;DEPTH_TEXTURE&lt;/code&gt; または &lt;code&gt;SCREEN_TEXTURE&lt;/code&gt; キーワードを使用する場合、対応するテクスチャを別のレンダーパスで生成することを選択します。これは必ずしも安価な操作ではありませんが、ガラスのようなマテリアルの屈折など、さまざまな手法を実装できます。 。</target>
        </trans-unit>
        <trans-unit id="0e4a24a47776590b3614eff94072d51c15c8244d" translate="yes" xml:space="preserve">
          <source>When a custom valueBar is defined, its &lt;a href=&quot;qml-qtquick-item#implicitWidth-prop&quot;&gt;implicitWidth&lt;/a&gt; property must be set.</source>
          <target state="translated">カスタムvalueBarが定義されている場合、&lt;a href=&quot;qml-qtquick-item#implicitWidth-prop&quot;&gt;implicitWidth&lt;/a&gt;プロパティを設定する必要があります。</target>
        </trans-unit>
        <trans-unit id="6c4b40a6fbd23b160b7fe00aefbf0818b8bf8785" translate="yes" xml:space="preserve">
          <source>When a data stream operates on an asynchronous device, the chunks of data can arrive at arbitrary points in time. The &lt;a href=&quot;qdatastream&quot;&gt;QDataStream&lt;/a&gt; class implements a transaction mechanism that provides the ability to read the data atomically with a series of stream operators. As an example, you can handle incomplete reads from a socket by using a transaction in a slot connected to the readyRead() signal:</source>
          <target state="translated">データストリームが非同期デバイスで動作する場合、データのチャンクは任意の時点に到達できます。&lt;a href=&quot;qdatastream&quot;&gt;QDataStreamの&lt;/a&gt;クラスが実装ストリーム演算子一連のアトミックデータを読み取る機能を提供し、取引メカニズム。例として、readyRead（）シグナルに接続されたスロットでトランザクションを使用して、ソケットからの不完全な読み取りを処理できます。</target>
        </trans-unit>
        <trans-unit id="2309abfd6e3825de006d2babd2f4bdd6e5bf7873" translate="yes" xml:space="preserve">
          <source>When a data stream operates on an asynchronous device, the chunks of data can arrive at arbitrary points in time. The QDataStream class implements a transaction mechanism that provides the ability to read the data atomically with a series of stream operators. As an example, you can handle incomplete reads from a socket by using a transaction in a slot connected to the readyRead() signal:</source>
          <target state="translated">データストリームが非同期デバイス上で動作する場合、データの塊は任意の時点で到着することができます。QDataStreamクラスは、一連のストリーム演算子を使ってアトミックにデータを読み取る機能を提供するトランザクションメカニズムを実装しています。例として、readyRead()シグナルに接続されたスロット内のトランザクションを使用することで、ソケットからの不完全な読み込みを処理することができます。</target>
        </trans-unit>
        <trans-unit id="2b820cde4dc4a7341cb53aee76f1d46245199229" translate="yes" xml:space="preserve">
          <source>When a delay is set, the event will be queued for delivery after the timeout has passed. The state machine takes ownership of</source>
          <target state="translated">遅延が設定されている場合、タイムアウトが経過した後、イベントは配信のためにキューに入れられます。ステートマシンは</target>
        </trans-unit>
        <trans-unit id="23bd60283b08b2b77caeefa53fd2bdd658b2b566" translate="yes" xml:space="preserve">
          <source>When a delay is set, the event will be queued for delivery after the timeout has passed. The state machine takes ownership of the event and deletes it after processing.</source>
          <target state="translated">遅延が設定されている場合、イベントはタイムアウトが経過した後に配信のためにキューに入れられます。ステートマシンはイベントの所有権を取得し、処理後にイベントを削除します。</target>
        </trans-unit>
        <trans-unit id="d09fa2d377e5a85c50e883812625f0a7a5fde3e3" translate="yes" xml:space="preserve">
          <source>When a dock widget or tool bar is dragged over the main window, the main window adjusts its contents to indicate where the dock widget or tool bar will be docked if it is dropped. Setting this property causes &lt;a href=&quot;qmainwindow&quot;&gt;QMainWindow&lt;/a&gt; to move its contents in a smooth animation. Clearing this property causes the contents to snap into their new positions.</source>
          <target state="translated">ドックウィジェットまたはツールバーがメインウィンドウ上にドラッグされると、メインウィンドウはそのコンテンツを調整して、ドロップされたときにドックウィジェットまたはツールバーがドッキングされる場所を示します。このプロパティを設定すると、&lt;a href=&quot;qmainwindow&quot;&gt;QMainWindowの&lt;/a&gt;コンテンツがスムーズなアニメーションで移動します。このプロパティをクリアすると、コンテンツが新しい位置にスナップされます。</target>
        </trans-unit>
        <trans-unit id="da9490d3c1f9946041e7eb1512b2be2ffa63a1b3" translate="yes" xml:space="preserve">
          <source>When a drag and drop operation is performed over a view, the underlying model is queried to determine which types of operation it supports and the MIME types it can accept. This information is provided by the &lt;a href=&quot;qabstractitemmodel#supportedDropActions&quot;&gt;QAbstractItemModel::supportedDropActions&lt;/a&gt;() and &lt;a href=&quot;qabstractitemmodel#mimeTypes&quot;&gt;QAbstractItemModel::mimeTypes&lt;/a&gt;() functions. Models that do not override the implementations provided by &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt; support copy operations and the default internal MIME type for items.</source>
          <target state="translated">ビュー上でドラッグアンドドロップ操作が実行されると、基になるモデルが照会され、サポートされている操作のタイプと受け入れることができるMIMEタイプが決定されます。この情報は、&lt;a href=&quot;qabstractitemmodel#supportedDropActions&quot;&gt;QAbstractItemModel :: supportedDropActions&lt;/a&gt;（）および&lt;a href=&quot;qabstractitemmodel#mimeTypes&quot;&gt;QAbstractItemModel :: mimeTypes&lt;/a&gt;（）関数によって提供されます。&lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt;によって提供される実装をオーバーライドしないモデルは、コピー操作とアイテムのデフォルトの内部MIMEタイプをサポートします。</target>
        </trans-unit>
        <trans-unit id="e9b8c9681d5d37404723c8f5a9ebfc9d97539a77" translate="yes" xml:space="preserve">
          <source>When a drag is &lt;a href=&quot;qml-qtquick-drag#active-attached-prop&quot;&gt;active&lt;/a&gt; on an item, any change in that item's position will generate a drag event that will be sent to any &lt;a href=&quot;qml-qtquick-droparea&quot;&gt;DropArea&lt;/a&gt; that intersects with the new position of the item. Other items which implement drag and drop event handlers can also receive these events.</source>
          <target state="translated">アイテムでドラッグが&lt;a href=&quot;qml-qtquick-drag#active-attached-prop&quot;&gt;アクティブな&lt;/a&gt;場合、そのアイテムの位置を変更するとドラッグイベントが生成され、アイテムの新しい位置と交差する&lt;a href=&quot;qml-qtquick-droparea&quot;&gt;DropAreaに&lt;/a&gt;送信されます。ドラッグアンドドロップイベントハンドラーを実装する他のアイテムも、これらのイベントを受け取ることができます。</target>
        </trans-unit>
        <trans-unit id="c95a54f3a1918c06f2cbe85cf290554fb693d8ac" translate="yes" xml:space="preserve">
          <source>When a drag is not active this property holds the object that accepted the drop event that ended the drag, if no object accepted the drop or the drag was canceled the target will then be null.</source>
          <target state="translated">ドラッグがアクティブでない場合、このプロパティはドラッグを終了したドロップイベントを受け入れたオブジェクトを保持します。</target>
        </trans-unit>
        <trans-unit id="8dd9d07c03937978798b7bb1627270a6ea3c810d" translate="yes" xml:space="preserve">
          <source>When a drop occurs elsewhere in the view, and the row number is unusable, we append items to the top level of the model.</source>
          <target state="translated">ビュー内の他の場所でドロップが発生し、行番号が使用できない場合は、モデルの最上位レベルにアイテムを追加します。</target>
        </trans-unit>
        <trans-unit id="f51c41bb148e0dd3152b4f6f3f9915d8028fe189" translate="yes" xml:space="preserve">
          <source>When a drop occurs in the widget, the dropEvent() handler function is called, and we can deal with each possible action in turn. First, we deal with drag and drop operations within the same widget:</source>
          <target state="translated">ウィジェット内でドロップが発生すると、dropEvent()ハンドラ関数が呼び出され、それぞれの可能なアクションを順番に処理していきます。まず、同じウィジェット内でのドラッグ&amp;ドロップ操作を扱います。</target>
        </trans-unit>
        <trans-unit id="b42ee2ab5c63e4e31745c7c35ebc8cf0bcf255bd" translate="yes" xml:space="preserve">
          <source>When a drop occurs, the model index corresponding to the parent item will either be valid, indicating that the drop occurred on an item, or it will be invalid, indicating that the drop occurred somewhere in the view that corresponds to top level of the model.</source>
          <target state="translated">ドロップが発生した場合、親アイテムに対応するモデルインデックスは、アイテム上でドロップが発生したことを示す有効なインデックスか、モデルのトップレベルに対応するビューのどこかでドロップが発生したことを示す無効なインデックスのどちらかになります。</target>
        </trans-unit>
        <trans-unit id="fa514711ce33d2215ed2e3d6a6f7e5ed0189a13b" translate="yes" xml:space="preserve">
          <source>When a focus scope receives active focus, the contained type with &lt;code&gt;focus&lt;/code&gt; set (if any) also gets the active focus. If this type is also a &lt;a href=&quot;qml-qtquick-focusscope&quot;&gt;FocusScope&lt;/a&gt;, the proxying behavior continues. Both the focus scope and the sub-focused item will have the &lt;code&gt;activeFocus&lt;/code&gt; property set.</source>
          <target state="translated">フォーカススコープがアクティブフォーカスを受け取ると、 &lt;code&gt;focus&lt;/code&gt; セットが含まれている型（存在する場合）もアクティブフォーカスを取得します。このタイプが&lt;a href=&quot;qml-qtquick-focusscope&quot;&gt;FocusScope&lt;/a&gt;でもある場合、プロキシの動作は続行されます。フォーカススコープとサブフォーカスアイテムの &lt;code&gt;activeFocus&lt;/code&gt; 、activeFocusプロパティが設定されます。</target>
        </trans-unit>
        <trans-unit id="9e613a8bc60ebbcd1e9e0949919a88ee9070005d" translate="yes" xml:space="preserve">
          <source>When a formatter is attached to a value axis, the axis range cannot include negative values or the zero.</source>
          <target state="translated">フォーマッタが値軸にアタッチされている場合、軸の範囲には負の値やゼロを含めることはできません。</target>
        </trans-unit>
        <trans-unit id="6f6b92c6c88b8efb6145fe6bc4f3bfc2d29e118a" translate="yes" xml:space="preserve">
          <source>When a gesture is canceled, the &lt;a href=&quot;qgesturerecognizer#reset&quot;&gt;reset&lt;/a&gt;() function is called, giving the recognizer the chance to update the appropriate properties in the corresponding &lt;a href=&quot;qgesture&quot;&gt;QGesture&lt;/a&gt; object.</source>
          <target state="translated">ジェスチャがキャンセルされると、&lt;a href=&quot;qgesturerecognizer#reset&quot;&gt;reset&lt;/a&gt;（）関数が呼び出され、認識機能が対応する&lt;a href=&quot;qgesture&quot;&gt;QGesture&lt;/a&gt;オブジェクトの適切なプロパティを更新する機会を与えます。</target>
        </trans-unit>
        <trans-unit id="428d7789009cbf1fc7ea52cad52f4379b3aabfc7" translate="yes" xml:space="preserve">
          <source>When a highlighted item is activated, the popup is closed, &lt;a href=&quot;qml-qtquick-controls2-combobox#currentIndex-prop&quot;&gt;currentIndex&lt;/a&gt; is set to &lt;code&gt;highlightedIndex&lt;/code&gt;, and the value of this property is reset to &lt;code&gt;-1&lt;/code&gt;, as there is no longer a highlighted item.</source>
          <target state="translated">ハイライト表示されたアイテムがアクティブになると、ポップアップが閉じ、&lt;a href=&quot;qml-qtquick-controls2-combobox#currentIndex-prop&quot;&gt;currentIndex&lt;/a&gt;が &lt;code&gt;highlightedIndex&lt;/code&gt; に設定され、ハイライト表示されたアイテムがなくなるため、このプロパティの値は &lt;code&gt;-1&lt;/code&gt; にリセットされます。</target>
        </trans-unit>
        <trans-unit id="4eebccda1013bfd9e4d9b4103626dd2994ae925f" translate="yes" xml:space="preserve">
          <source>When a key is pressed or released, a key event is generated and delivered to the focused Qt Quick &lt;a href=&quot;qml-qtquick-item&quot;&gt;Item&lt;/a&gt;. To facilitate the construction of reusable components and to address some of the cases unique to fluid user interfaces, the Qt Quick items add a scope based extension to Qt's traditional keyboard focus model.</source>
          <target state="translated">キーが押されるか離されると、キーイベントが生成され、フォーカスされたQtクイック&lt;a href=&quot;qml-qtquick-item&quot;&gt;アイテムに&lt;/a&gt;配信されます。再利用可能なコンポーネントの構築を容易にし、流動的なユーザーインターフェイスに固有のいくつかのケースに対処するために、Qt Quickアイテムは、スコープベースの拡張機能をQtの従来のキーボードフォーカスモデルに追加します。</target>
        </trans-unit>
        <trans-unit id="5280aa5c73ecda9d4fb3b4f001bfc13d6e4c77a0" translate="yes" xml:space="preserve">
          <source>When a key sequence is being typed at the keyboard, it is said to be ambiguous as long as it matches the start of more than one shortcut.</source>
          <target state="translated">キーボードでキー配列が入力されている場合、複数のショートカットの先頭と一致している限り、曖昧なキー配列になると言われています。</target>
        </trans-unit>
        <trans-unit id="332bb39a2cb3399af84efd51d32cde06e1b10d08" translate="yes" xml:space="preserve">
          <source>When a language/country pair is specified in the constructor, one of three things can happen:</source>
          <target state="translated">コンストラクタで言語と国のペアを指定すると、次の 3 つのうちのいずれかが発生します。</target>
        </trans-unit>
        <trans-unit id="8c010514fe89fada083c82bb7ef5814f38b6c278" translate="yes" xml:space="preserve">
          <source>When a layout is resized, items may grow or shrink. Due to this, items have a &lt;a href=&quot;qml-qtquick-layouts-layout#minimumWidth-attached-prop&quot;&gt;minimum size&lt;/a&gt;, &lt;a href=&quot;qml-qtquick-layouts-layout#preferredWidth-attached-prop&quot;&gt;preferred size&lt;/a&gt; and a &lt;a href=&quot;qml-qtquick-layouts-layout#maximumWidth-attached-prop&quot;&gt;maximum size&lt;/a&gt;.</source>
          <target state="translated">レイアウトのサイズを変更すると、アイテムが拡大または縮小する場合があります。このため、アイテムには&lt;a href=&quot;qml-qtquick-layouts-layout#minimumWidth-attached-prop&quot;&gt;最小サイズ&lt;/a&gt;、&lt;a href=&quot;qml-qtquick-layouts-layout#preferredWidth-attached-prop&quot;&gt;推奨サイズ&lt;/a&gt;、&lt;a href=&quot;qml-qtquick-layouts-layout#maximumWidth-attached-prop&quot;&gt;最大サイズがあり&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="2aaeb9d71f67c32d894e19f355e445af1f673900" translate="yes" xml:space="preserve">
          <source>When a low-level graphics API is in use, the scenegraph will make sure there is a CPU-side wait for the GPU to complete all work submitted to the scenegraph's graphics command queue before the scenegraph's nodes are deleted. Therefore there is no need to issue additional waits here, unless the &lt;a href=&quot;qsgrendernode#render&quot;&gt;render&lt;/a&gt;() implementation is using additional command queues.</source>
          <target state="translated">低レベルのグラフィックAPIが使用されている場合、シーングラフは、GPUがシーングラフのグラフィックコマンドキューに送信されたすべての作業を完了するまで、CPU側で待機してから、シーングラフのノードを削除します。したがって、&lt;a href=&quot;qsgrendernode#render&quot;&gt;render&lt;/a&gt;（）実装が追加のコマンドキューを使用していない限り、ここで追加の待機を発行する必要はありません。</target>
        </trans-unit>
        <trans-unit id="c845af89f01e419749914b45895c1bb235d5ce01" translate="yes" xml:space="preserve">
          <source>When a menu is torn off a second menu is shown to display the menu contents in a new window. When the menu is in this mode and the menu is visible returns &lt;code&gt;true&lt;/code&gt;; otherwise false.</source>
          <target state="translated">メニューが切り離されると、2番目のメニューが表示され、メニューの内容が新しいウィンドウに表示されます。メニューがこのモードにあり、メニューが表示されている &lt;code&gt;true&lt;/code&gt; 、trueを返します。それ以外の場合はfalse。</target>
        </trans-unit>
        <trans-unit id="728dd6daea54bbbc47c1c0afd43ec24383ab26a3" translate="yes" xml:space="preserve">
          <source>When a model is reset it means that any previous data reported from the model is now invalid and has to be queried for again. This also means that the current item and any selected items will become invalid.</source>
          <target state="translated">モデルがリセットされると、モデルから報告された以前のデータは無効になり、再度問い合わせをしなければならないことを意味します。これはまた、現在の項目と選択された項目が無効になることを意味します。</target>
        </trans-unit>
        <trans-unit id="5f301e5dc3d747cffb379d30922ea2160d2c0277" translate="yes" xml:space="preserve">
          <source>When a model radically changes its data it can sometimes be easier to just call this function rather than emit &lt;a href=&quot;qabstractitemmodel#dataChanged&quot;&gt;dataChanged&lt;/a&gt;() to inform other components when the underlying data source, or its structure, has changed.</source>
          <target state="translated">モデルがデータを根本的に変更する場合、基礎となるデータソースまたはその構造が変更されたときに他のコンポーネントに通知する&lt;a href=&quot;qabstractitemmodel#dataChanged&quot;&gt;dataChanged&lt;/a&gt;（）を発行するよりも、この関数を呼び出す方が簡単な場合があります。</target>
        </trans-unit>
        <trans-unit id="798d38793d411f71af72b3a052c51c022e51937d" translate="yes" xml:space="preserve">
          <source>When a module name is used as the</source>
          <target state="translated">モジュール名を</target>
        </trans-unit>
        <trans-unit id="c8bb4a36e1cc58b9d2f69c2e0e1701bc5743d489" translate="yes" xml:space="preserve">
          <source>When a new &lt;a href=&quot;q3dcamera&quot;&gt;Q3DCamera&lt;/a&gt; object is set, it is automatically added as child of the scene.</source>
          <target state="translated">新しい&lt;a href=&quot;q3dcamera&quot;&gt;Q3DCamera&lt;/a&gt;オブジェクトが設定されると、自動的にシーンの子として追加されます。</target>
        </trans-unit>
        <trans-unit id="8b455ee9f46ef6792f12c0936577f332d927c927" translate="yes" xml:space="preserve">
          <source>When a new &lt;a href=&quot;q3dlight&quot;&gt;Q3DLight&lt;/a&gt; objects is set, it is automatically added as child of the scene.</source>
          <target state="translated">新しい&lt;a href=&quot;q3dlight&quot;&gt;Q3DLight&lt;/a&gt;オブジェクトが設定されると、自動的にシーンの子として追加されます。</target>
        </trans-unit>
        <trans-unit id="92c136ff15dc3f6e6eb98af265af4b77642b9592" translate="yes" xml:space="preserve">
          <source>When a new column is flicked into view, &lt;a href=&quot;qml-qtquick-tableview&quot;&gt;TableView&lt;/a&gt; will determine its width by calling the &lt;a href=&quot;qml-qtquick-tableview#columnWidthProvider-prop&quot;&gt;columnWidthProvider&lt;/a&gt; function. &lt;a href=&quot;qml-qtquick-tableview&quot;&gt;TableView&lt;/a&gt; itself will never store row height or column width, as it's designed to support large models containing any number of rows and columns. Instead, it will ask the application whenever it needs to know.</source>
          <target state="translated">新しい列がフリックして表示されると、&lt;a href=&quot;qml-qtquick-tableview&quot;&gt;TableView&lt;/a&gt;は&lt;a href=&quot;qml-qtquick-tableview#columnWidthProvider-prop&quot;&gt;columnWidthProvider&lt;/a&gt;関数を呼び出してその幅を決定します。&lt;a href=&quot;qml-qtquick-tableview&quot;&gt;TableView&lt;/a&gt;自体は行の高さや列の幅を格納しません。行と列をいくつでも含む大きなモデルをサポートするように設計されているためです。代わりに、知る必要があるときはいつでもアプリケーションに尋ねます。</target>
        </trans-unit>
        <trans-unit id="bd3977fd3b9d0fff4ce92833839e9fd254909e52" translate="yes" xml:space="preserve">
          <source>When a new column is flicked into view, TableView will determine its width by calling the &lt;a href=&quot;qml-qtquick-tableview#columnWidthProvider-prop&quot;&gt;columnWidthProvider&lt;/a&gt; function. TableView does not store row height or column width, as it's designed to support large models containing any number of rows and columns. Instead, it will ask the application whenever it needs to know.</source>
          <target state="translated">新しい列がビューにフリックされると、TableViewは&lt;a href=&quot;qml-qtquick-tableview#columnWidthProvider-prop&quot;&gt;columnWidthProvider&lt;/a&gt;関数を呼び出してその幅を決定します。TableViewは、任意の数の行と列を含む大きなモデルをサポートするように設計されているため、行の高さや列の幅を格納しません。代わりに、知る必要があるときはいつでもアプリケーションに尋ねます。</target>
        </trans-unit>
        <trans-unit id="be74d7e819d89ccb9b1b730a61146409cce1e842" translate="yes" xml:space="preserve">
          <source>When a new connection is received, the client &lt;a href=&quot;qwebsocket&quot;&gt;QWebSocket&lt;/a&gt; is retrieved (`nextPendingConnection()`), and the signals we are interested in are connected to our slots (`textMessageReceived()`, `binaryMessageReceived()` and `disconnected()`). The client socket is remembered in a list, in case we would like to use it later (in this example, nothing is done with it).</source>
          <target state="translated">新しい接続が受信されると、クライアント&lt;a href=&quot;qwebsocket&quot;&gt;QWebSocket&lt;/a&gt;が取得され（ `nextPendingConnection（）`）、関心のある信号がスロットに接続されます（ `textMessageReceived（）`、 `binaryMessageReceived（）`および `disconnected（）` ）。クライアントソケットは、後で使用する場合に備えてリストに記憶されます（この例では、何も行われません）。</target>
        </trans-unit>
        <trans-unit id="bda773011b553996318d1ca0425ceb0218190f09" translate="yes" xml:space="preserve">
          <source>When a new group is pushed onto the debug groups stack, it will inherit the configuration of the group that was previously on the top of the stack. Vice versa, popping a debug group will restore the configuration of the debug group that becomes the new top.</source>
          <target state="translated">新しいグループがデバッググループスタックにプッシュされると、それまでスタックのトップにあったグループの設定が継承されます。逆に、デバッググループをポップすると、新しいトップになったデバッググループの設定が復元されます。</target>
        </trans-unit>
        <trans-unit id="df3850f1d8b8a727c24246d0834526698fe4caf6" translate="yes" xml:space="preserve">
          <source>When a new value is assigned to the &lt;code&gt;firstname&lt;/code&gt; property, the binding expression for &lt;code&gt;fullname&lt;/code&gt; is marked as dirty. So when the last &lt;code&gt;qDebug()&lt;/code&gt; statement tries to read the name value of the &lt;code&gt;fullname&lt;/code&gt; property, the expression is evaluated again, &lt;code&gt;firstname()&lt;/code&gt; will be called again and return the new value.</source>
          <target state="translated">新しい値が &lt;code&gt;firstname&lt;/code&gt; プロパティに割り当てられると、 &lt;code&gt;fullname&lt;/code&gt; のバインディング式はダーティとしてマークされます。最後のときに &lt;code&gt;qDebug()&lt;/code&gt; 文はの名前値読み取ろうと &lt;code&gt;fullname&lt;/code&gt; プロパティを、式が再び評価され、 &lt;code&gt;firstname()&lt;/code&gt; を再び呼び出されると、新しい値を返します。</target>
        </trans-unit>
        <trans-unit id="ec32af560002a3f2954d27992ea538e7e19a3001" translate="yes" xml:space="preserve">
          <source>When a node acquires a replica for a known source, it sends a request for that source to the host node. Upon receipt of this request, the host will create a reply packet with the current values of all properties of the source. If the requested replica is dynamic, it will include the API definition for the source. The replica's node will be included in the list of connections that receive changes to that source from then on.</source>
          <target state="translated">ノードが既知のソースのレプリカを取得すると、そのソースに対する要求をホストノードに送信します。この要求を受信すると、ホストはソースのすべてのプロパティの現在の値を含む応答パケットを作成します。要求されたレプリカが動的なものである場合、ソースのAPI定義が含まれます。レプリカのノードは、それ以降、そのソースへの変更を受け取る接続のリストに含まれます。</target>
        </trans-unit>
        <trans-unit id="2f9bbe722b869b83db0e2263dc70c8abde11f7e3" translate="yes" xml:space="preserve">
          <source>When a node acquires a replica for a known source, it sends a request for that source to the host node. Upon receiving this request, the host creates a reply packet with the current values for all properties of that source. If the requested replica is &lt;a href=&quot;qremoteobjectdynamicreplica&quot;&gt;dynamic&lt;/a&gt;, the reply packet includes the API definition for the source. From then on, the replica's node will be included in the list of connections that receive changes to that source.</source>
          <target state="translated">ノードが既知のソースのレプリカを取得すると、そのソースのリクエストをホストノードに送信します。この要求を受信すると、ホストはそのソースのすべてのプロパティの現在の値を使用して応答パケットを作成します。要求されたレプリカが&lt;a href=&quot;qremoteobjectdynamicreplica&quot;&gt;動的&lt;/a&gt;である場合、応答パケットにはソースのAPI定義が含まれます。それ以降、レプリカのノードは、そのソースへの変更を受信する接続のリストに含まれます。</target>
        </trans-unit>
        <trans-unit id="d63ba8e6603b8cbc973323b39127ee0bc0ad55ba" translate="yes" xml:space="preserve">
          <source>When a page is about to be shown, &lt;a href=&quot;qwizard&quot;&gt;QWizard&lt;/a&gt; calls &lt;a href=&quot;qwizard#initializePage&quot;&gt;initializePage&lt;/a&gt;() (which in turn calls &lt;a href=&quot;qwizardpage#initializePage&quot;&gt;QWizardPage::initializePage&lt;/a&gt;()) to fill the page with default values. By default, this function does nothing, but it can be reimplemented to initialize the page's contents based on other pages' fields (see the &lt;a href=&quot;qwizard#initialize-page&quot;&gt;example above&lt;/a&gt;).</source>
          <target state="translated">ページが表示されようとしているとき、&lt;a href=&quot;qwizard&quot;&gt;QWizard&lt;/a&gt;は&lt;a href=&quot;qwizard#initializePage&quot;&gt;initializePage&lt;/a&gt;（）を呼び出し（次に&lt;a href=&quot;qwizardpage#initializePage&quot;&gt;QWizardPage :: initializePage&lt;/a&gt;（）を呼び出し）、ページにデフォルト値を入力します。デフォルトでは、この関数は何もしませんが、他のページのフィールドに基づいてページのコンテンツを初期化するために再実装できます（&lt;a href=&quot;qwizard#initialize-page&quot;&gt;上記&lt;/a&gt;の例を参照）。</target>
        </trans-unit>
        <trans-unit id="52b8a1c2a004bc4ae73bcc37ab97f637d0e15877" translate="yes" xml:space="preserve">
          <source>When a page is about to be shown, QWizard calls &lt;a href=&quot;qwizard#initializePage&quot;&gt;initializePage&lt;/a&gt;() (which in turn calls &lt;a href=&quot;qwizardpage#initializePage&quot;&gt;QWizardPage::initializePage&lt;/a&gt;()) to fill the page with default values. By default, this function does nothing, but it can be reimplemented to initialize the page's contents based on other pages' fields (see the &lt;a href=&quot;qwizard#initialize-page&quot;&gt;example above&lt;/a&gt;).</source>
          <target state="translated">ページが表示されようとしているとき、QWizardは&lt;a href=&quot;qwizard#initializePage&quot;&gt;initializePage&lt;/a&gt;（）を呼び出し（次に&lt;a href=&quot;qwizardpage#initializePage&quot;&gt;QWizardPage :: initializePage&lt;/a&gt;（）を呼び出します）、ページをデフォルト値で埋めます。デフォルトでは、この関数は何もしませんが、他のページのフィールドに基づいてページのコンテンツを初期化するために再実装できます（&lt;a href=&quot;qwizard#initialize-page&quot;&gt;上記&lt;/a&gt;の例を参照）。</target>
        </trans-unit>
        <trans-unit id="c63e8b4686c2ce6ea480da0dde82d96ac157403d" translate="yes" xml:space="preserve">
          <source>When a parallel state group is entered, all its child states will be simultaneously entered. Transitions within the individual child states operate normally. However, any of the child states may take a transition which exits the parent state. When this happens, the parent state and all of its child states are exited.</source>
          <target state="translated">パラレルステートグループが入力されると、そのすべての子ステートが同時に入力されます。個々の子ステート内の遷移は通常通りに動作します。ただし、子ステートのいずれかが親ステートを抜けるトランジションを取ることがあります。この場合、親ステートとそのすべての子ステートが終了します。</target>
        </trans-unit>
        <trans-unit id="f1b2b5f7aefbb0cb0ec4ae4792cb7356d5cdee30" translate="yes" xml:space="preserve">
          <source>When a partial match is found, no captured substrings are returned, and the (implicit) capturing group 0 corresponding to the whole match captures the partially matched substring of the subject string.</source>
          <target state="translated">部分一致が見つかった場合、捕捉された部分文字列は返されず、全体一致に対応する(暗黙の)捕捉グループ0が対象文字列の部分一致の部分文字列を捕捉します。</target>
        </trans-unit>
        <trans-unit id="949ea8688bbfcd915778d80bb9ad32883794d483" translate="yes" xml:space="preserve">
          <source>When a pinch gesture is started, the rotation is &lt;code&gt;0.0&lt;/code&gt;.</source>
          <target state="translated">ピンチジェスチャーが開始されると、回転は &lt;code&gt;0.0&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="6eeed75e83f5493322e8f521ba32040bf1a5bd87" translate="yes" xml:space="preserve">
          <source>When a pinch gesture is started, the scale is &lt;code&gt;1.0&lt;/code&gt;.</source>
          <target state="translated">ピンチジェスチャーが開始されると、スケールは &lt;code&gt;1.0&lt;/code&gt; になります。</target>
        </trans-unit>
        <trans-unit id="3947f323d774ee42a9f53aab29ffa36c8280798a" translate="yes" xml:space="preserve">
          <source>When a pixmap is inserted and the cache is about to exceed its limit, it removes pixmaps until there is enough room for the pixmap to be inserted.</source>
          <target state="translated">pixmapを挿入してキャッシュが限界を超えそうになったら、余裕ができるまでpixmapを削除します。</target>
        </trans-unit>
        <trans-unit id="14e43d5273a0f220d3f6cca0d60985a5d4b8fc21" translate="yes" xml:space="preserve">
          <source>When a place is removed, the &lt;a href=&quot;qplacemanager&quot;&gt;QPlaceManager&lt;/a&gt; may emit the &lt;a href=&quot;qplacemanager#placeRemoved&quot;&gt;QPlaceManager::placeRemoved&lt;/a&gt;() signal. Whether a manager does so is provider specific. Managers accessing places from a web service will typically not emit these signals, while managers accessing places stored locally generally will.</source>
          <target state="translated">場所が削除されると、&lt;a href=&quot;qplacemanager&quot;&gt;QPlaceManager&lt;/a&gt;は&lt;a href=&quot;qplacemanager#placeRemoved&quot;&gt;QPlaceManager :: placeRemoved&lt;/a&gt;（）シグナルを発行する場合があります。マネージャーがそうするかどうかはプロバイダー固有です。通常、Webサービスから場所にアクセスするマネージャーはこれらの信号を発行しませんが、ローカルに保存されている場所にアクセスするマネージャーは通常は送信します。</target>
        </trans-unit>
        <trans-unit id="955b392e62b44331ff658695f8bca3787dde24b9" translate="yes" xml:space="preserve">
          <source>When a place is saved, the &lt;a href=&quot;qplacemanager&quot;&gt;QPlaceManager&lt;/a&gt; may emit QPlaceManager::placedAdded() or &lt;a href=&quot;qplacemanager#placeUpdated&quot;&gt;QPlaceManager::placeUpdated&lt;/a&gt;() signals. However whether a manager does so or not is provider specific, managers accessing places from a web service will typically not emit these signals while managers accessing places locally stored generally will.</source>
          <target state="translated">場所が保存されると、&lt;a href=&quot;qplacemanager&quot;&gt;QPlaceManager&lt;/a&gt;はQPlaceManager :: placedAdded（）または&lt;a href=&quot;qplacemanager#placeUpdated&quot;&gt;QPlaceManager :: placeUpdated&lt;/a&gt;（）シグナルを発行する場合があります。ただし、マネージャーがそうであるかどうかはプロバイダー固有であり、Webサービスから場所にアクセスするマネージャーは通常、これらの信号を発行しませんが、ローカルに保存されている場所にアクセスするマネージャーは通常は送信します。</target>
        </trans-unit>
        <trans-unit id="bb76ccab6b6330b8216b91871b1f1a7518967e70" translate="yes" xml:space="preserve">
          <source>When a preprocessor symbol is specified using the &lt;code&gt;defines&lt;/code&gt; variable, you can also use the &lt;a href=&quot;12-0-qdoc-commands-miscellaneous#if-command&quot;&gt;\if&lt;/a&gt; command to enclose documentation that only will be included if the preprocessor symbol is defined.</source>
          <target state="translated">&lt;code&gt;defines&lt;/code&gt; 変数を使用してプリプロセッサシンボルを指定する&lt;a href=&quot;12-0-qdoc-commands-miscellaneous#if-command&quot;&gt;場合&lt;/a&gt;、\ ifコマンドを使用して、プリプロセッサシンボルが定義されている場合にのみ含まれるドキュメントを囲むこともできます。</target>
        </trans-unit>
        <trans-unit id="f785beae5730b83f41acbcf90ef75b7556aac2f1" translate="yes" xml:space="preserve">
          <source>When a press event occurs, each instance of &lt;a href=&quot;qml-qtquick-pointhandler&quot;&gt;PointHandler&lt;/a&gt; chooses a single point which is not yet &quot;taken&quot; at that moment: if the press occurs within the bounds of the &lt;a href=&quot;qml-qtquick-pointhandler#parent-prop&quot;&gt;PointerHandler::parent&lt;/a&gt;, and no sibling &lt;a href=&quot;qml-qtquick-pointhandler&quot;&gt;PointHandler&lt;/a&gt; within the same &lt;a href=&quot;qml-qtquick-pointhandler#parent-prop&quot;&gt;PointerHandler::parent&lt;/a&gt; has yet acquired a passive grab on that point, and if the other constraints such as &lt;a href=&quot;qml-qtquick-pointhandler#acceptedButtons-prop&quot;&gt;acceptedButtons&lt;/a&gt;, &lt;a href=&quot;qml-qtquick-pointhandler#acceptedDevices-prop&quot;&gt;acceptedDevices&lt;/a&gt; etc. are satisfied, it's eligible, and the &lt;a href=&quot;qml-qtquick-pointhandler&quot;&gt;PointHandler&lt;/a&gt; then acquires a passive grab. In this way, the &lt;a href=&quot;qml-qtquick-pointhandler#parent-prop&quot;&gt;PointerHandler::parent&lt;/a&gt; acts like an exclusive group: there can be multiple instances of &lt;a href=&quot;qml-qtquick-pointhandler&quot;&gt;PointHandler&lt;/a&gt;, and the set of pressed touchpoints will be distributed among them. Each &lt;a href=&quot;qml-qtquick-pointhandler&quot;&gt;PointHandler&lt;/a&gt; which has chosen a point to track has its &lt;a href=&quot;stylesheet-reference#active&quot;&gt;active&lt;/a&gt; property &lt;code&gt;true&lt;/code&gt;. It then continues to track its chosen point until release: the properties of the &lt;a href=&quot;qml-point&quot;&gt;point&lt;/a&gt; will be kept up-to-date. Any Item can bind to these properties, and thereby follow the point's movements.</source>
          <target state="translated">プレスイベントが発生すると、&lt;a href=&quot;qml-qtquick-pointhandler&quot;&gt;PointHandlerの&lt;/a&gt;各インスタンスは、その時点ではまだ「取得」されていない単一のポイントを選択します。プレスが&lt;a href=&quot;qml-qtquick-pointhandler#parent-prop&quot;&gt;PointerHandler :: parentの&lt;/a&gt;境界内で発生し、同じ&lt;a href=&quot;qml-qtquick-pointhandler#parent-prop&quot;&gt;PointerHandler :: parent&lt;/a&gt;内に兄弟の&lt;a href=&quot;qml-qtquick-pointhandler&quot;&gt;PointHandlerが&lt;/a&gt;ない場合まだその時点での受動的なグラブを獲得し、そしてなど、他の制約場合た&lt;a href=&quot;qml-qtquick-pointhandler#acceptedButtons-prop&quot;&gt;acceptedButtons&lt;/a&gt;、&lt;a href=&quot;qml-qtquick-pointhandler#acceptedDevices-prop&quot;&gt;acceptedDevices&lt;/a&gt;などが満たされ、それが適格だ、と&lt;a href=&quot;qml-qtquick-pointhandler&quot;&gt;PointHandlerは&lt;/a&gt;その後、パッシブなグラブを獲得します。このように、&lt;a href=&quot;qml-qtquick-pointhandler#parent-prop&quot;&gt;PointerHandler :: parent&lt;/a&gt;は排他的なグループのように機能します&lt;a href=&quot;qml-qtquick-pointhandler&quot;&gt;。PointHandlerの&lt;/a&gt;複数のインスタンスが存在する可能性があります、そして押されたタッチポイントのセットはそれらの間で分配されます。追跡するポイントを選択した各&lt;a href=&quot;qml-qtquick-pointhandler&quot;&gt;PointHandlerの&lt;/a&gt;&lt;a href=&quot;stylesheet-reference#active&quot;&gt;アクティブ&lt;/a&gt;プロパティは &lt;code&gt;true&lt;/code&gt; です。その後、選択したポイントをリリースまで追跡し続けます。&lt;a href=&quot;qml-point&quot;&gt;ポイント&lt;/a&gt;のプロパティは最新の状態に保たれます。すべてのアイテムはこれらのプロパティにバインドできるため、ポイントの動きを追跡できます。</target>
        </trans-unit>
        <trans-unit id="10016a67871d70f0506ab0f762c8c06369cdb0ed" translate="yes" xml:space="preserve">
          <source>When a press event occurs, each instance of PointHandler chooses a single point which is not yet &quot;taken&quot; at that moment: if the press occurs within the bounds of the &lt;a href=&quot;qml-qtquick-pointhandler#parent-prop&quot;&gt;PointerHandler::parent&lt;/a&gt;, and no sibling PointHandler within the same &lt;a href=&quot;qml-qtquick-pointhandler#parent-prop&quot;&gt;PointerHandler::parent&lt;/a&gt; has yet acquired a passive grab on that point, and if the other constraints such as &lt;a href=&quot;qml-qtquick-pointhandler#acceptedButtons-prop&quot;&gt;acceptedButtons&lt;/a&gt;, &lt;a href=&quot;qml-qtquick-pointhandler#acceptedDevices-prop&quot;&gt;acceptedDevices&lt;/a&gt; etc. are satisfied, it's eligible, and the PointHandler then acquires a passive grab. In this way, the &lt;a href=&quot;qml-qtquick-pointhandler#parent-prop&quot;&gt;PointerHandler::parent&lt;/a&gt; acts like an exclusive group: there can be multiple instances of PointHandler, and the set of pressed touchpoints will be distributed among them. Each PointHandler which has chosen a point to track has its &lt;a href=&quot;stylesheet-reference#active&quot;&gt;active&lt;/a&gt; property &lt;code&gt;true&lt;/code&gt;. It then continues to track its chosen point until release: the properties of the &lt;a href=&quot;qml-point&quot;&gt;point&lt;/a&gt; will be kept up-to-date. Any Item can bind to these properties, and thereby follow the point's movements.</source>
          <target state="translated">プレスイベントが発生すると、PointHandlerの各インスタンスは、その時点でまだ「取得」されていない単一のポイントを選択します。プレスが&lt;a href=&quot;qml-qtquick-pointhandler#parent-prop&quot;&gt;PointerHandler :: parentの&lt;/a&gt;境界内で発生し、同じ&lt;a href=&quot;qml-qtquick-pointhandler#parent-prop&quot;&gt;PointerHandler :: parent&lt;/a&gt;内に兄弟PointHandlerがない場合はまだそのポイントでパッシブグラブを取得しており、&lt;a href=&quot;qml-qtquick-pointhandler#acceptedButtons-prop&quot;&gt;acceptedButtons&lt;/a&gt;、&lt;a href=&quot;qml-qtquick-pointhandler#acceptedDevices-prop&quot;&gt;acceptedDevices&lt;/a&gt;などの他の制約が満たされている場合、それは適格であり、PointHandlerはパッシブグラブを取得します。このように、&lt;a href=&quot;qml-qtquick-pointhandler#parent-prop&quot;&gt;PointerHandler :: parent&lt;/a&gt;は排他的なグループのように機能します。つまり、PointHandlerのインスタンスが複数存在する可能性があり、押されたタッチポイントのセットがそれらの間で分散されます。追跡するポイントを選択した各PointHandlerには、&lt;a href=&quot;stylesheet-reference#active&quot;&gt;アクティブ&lt;/a&gt;プロパティ &lt;code&gt;true&lt;/code&gt; 。その後、リリースされるまで、選択したポイントを追跡し続けます。&lt;a href=&quot;qml-point&quot;&gt;ポイント&lt;/a&gt;のプロパティは最新に保たれます。どのアイテムもこれらのプロパティにバインドできるため、ポイントの動きを追跡できます。</target>
        </trans-unit>
        <trans-unit id="cfbfb0ebbd6646025b981fa339de3293519a353e" translate="yes" xml:space="preserve">
          <source>When a print request is accepted, the printer status would change, triggering a change in the status property. This would then be reported to all Replicas.</source>
          <target state="translated">印刷要求が受理されると、プリンタの状態が変化し、status プロパティの変更がトリガーされます。これは、すべてのレプリカに報告されます。</target>
        </trans-unit>
        <trans-unit id="666537301706b87af8a406d9ea46793d0d017481" translate="yes" xml:space="preserve">
          <source>When a process using &lt;a href=&quot;qsystemsemaphore&quot;&gt;QSystemSemaphore&lt;/a&gt; terminates for any reason, Unix automatically reverses the effect of all acquire operations that were not released. Thus if the process acquires a resource and then exits without releasing it, Unix will release that resource.</source>
          <target state="translated">&lt;a href=&quot;qsystemsemaphore&quot;&gt;QSystemSemaphore&lt;/a&gt;を使用するプロセスが何らかの理由で終了すると、Unixは解放されなかったすべての取得操作の影響を自動的に元に戻します。したがって、プロセスがリソースを取得し、それを解放せずに終了した場合、Unixはそのリソースを解放します。</target>
        </trans-unit>
        <trans-unit id="df1a65bbb3d9b167018ca0c5cdabe5195c1a5eea" translate="yes" xml:space="preserve">
          <source>When a process using QSystemSemaphore terminates for any reason, Unix automatically reverses the effect of all acquire operations that were not released. Thus if the process acquires a resource and then exits without releasing it, Unix will release that resource.</source>
          <target state="translated">QSystemSemaphoreを使用しているプロセスが何らかの理由で終了すると、Unixは解放されなかったすべての取得操作の効果を自動的に反転させます。したがって、プロセスがリソースを取得した後、それを解放せずに終了した場合、Unixはそのリソースを解放します。</target>
        </trans-unit>
        <trans-unit id="3fb2e9f6ef5f613c87a38c8fd666c38c8b51fe6f" translate="yes" xml:space="preserve">
          <source>When a property sheet extension is required,</source>
          <target state="translated">物件シートの延長が必要な場合</target>
        </trans-unit>
        <trans-unit id="a0431b9169541b5942ac50072a09a56ca2303178" translate="yes" xml:space="preserve">
          <source>When a property value source object is assigned to a property, QML first tries to assign it normally, as though it were a regular QML type. Only if this assignment fails does the engine call the &lt;a href=&quot;qqmlpropertyvaluesource#setTarget&quot;&gt;setTarget()&lt;/a&gt; method. This allows the type to also be used in contexts other than just as a value source.</source>
          <target state="translated">プロパティ値のソースオブジェクトがプロパティに割り当てられると、QMLは、通常のQMLタイプであるかのように、最初に通常の割り当てを試みます。この割り当てが失敗した場合のみ、エンジンは&lt;a href=&quot;qqmlpropertyvaluesource#setTarget&quot;&gt;setTarget（）&lt;/a&gt;メソッドを呼び出します。これにより、型を単なる値のソースとして以外のコンテキストでも使用できます。</target>
        </trans-unit>
        <trans-unit id="5c0c5db3829a8327c7d24036abbfab378bf7a77f" translate="yes" xml:space="preserve">
          <source>When a query is run on XML data, as in the snippet above, the &lt;code&gt;doc()&lt;/code&gt; function returns the node in the built-in data model where the query evaluation will begin. But when a query is run on a custom node model containing non-XML data, one of the &lt;a href=&quot;qxmlquery#bindVariable&quot;&gt;bindVariable&lt;/a&gt;() functions must be called to bind a variable name to a starting node in the custom model. A $variable reference is used in the &lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt; text to access the starting node in the custom model. It is not necessary to declare the variable name external in the query. See the example in the documentation for &lt;a href=&quot;qabstractxmlnodemodel&quot;&gt;QAbstractXmlNodeModel&lt;/a&gt;.</source>
          <target state="translated">上記のスニペットのように、クエリがXMLデータに対して実行されると、 &lt;code&gt;doc()&lt;/code&gt; 関数は、クエリの評価が開始される組み込みデータモデルのノードを返します。ただし、非XMLデータを含むカスタムノードモデルでクエリを実行する場合は、&lt;a href=&quot;qxmlquery#bindVariable&quot;&gt;bindVariable&lt;/a&gt;（）関数の1つを呼び出して、変数名をカスタムモデルの開始ノードにバインドする必要があります。 $ variable参照は、カスタムモデルの開始ノードにアクセスするために&lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt;テキストで使用されます。クエリで変数名を外部で宣言する必要はありません。&lt;a href=&quot;qabstractxmlnodemodel&quot;&gt;QAbstractXmlNodeModel&lt;/a&gt;のドキュメントの例を参照してください。</target>
        </trans-unit>
        <trans-unit id="865208c91375893b92d822994a4204209a37ba98" translate="yes" xml:space="preserve">
          <source>When a query is run on XML data, as in the snippet above, the &lt;code&gt;doc()&lt;/code&gt; function returns the node in the built-in data model where the query evaluation will begin. But when a query is run on a custom node model containing non-XML data, one of the &lt;a href=&quot;qxmlquery#bindVariable&quot;&gt;bindVariable&lt;/a&gt;() functions must be called to bind a variable name to a starting node in the custom model. A $variable reference is used in the &lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery&lt;/a&gt; text to access the starting node in the custom model. It is not necessary to declare the variable name external in the query. See the example in the documentation for &lt;a href=&quot;qabstractxmlnodemodel&quot;&gt;QAbstractXmlNodeModel&lt;/a&gt;.</source>
          <target state="translated">上記のスニペットのように、XMLデータに対してクエリが実行されると、 &lt;code&gt;doc()&lt;/code&gt; 関数は、クエリ評価が開始される組み込みデータモデルのノードを返します。ただし、非XMLデータを含むカスタムノードモデルでクエリを実行する場合、&lt;a href=&quot;qxmlquery#bindVariable&quot;&gt;bindVariable&lt;/a&gt;（）関数の1つを呼び出して、変数名をカスタムモデルの開始ノードにバインドする必要があります。&lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery&lt;/a&gt;テキストで$ variable参照を使用して、カスタムモデルの開始ノードにアクセスします。クエリで変数名を外部で宣言する必要はありません。&lt;a href=&quot;qabstractxmlnodemodel&quot;&gt;QAbstractXmlNodeModel&lt;/a&gt;のドキュメントの例を参照してください。</target>
        </trans-unit>
        <trans-unit id="4b9712c67436ef44e2898fc4063b230c597593f7" translate="yes" xml:space="preserve">
          <source>When a query runs, it parses documents, allocating internal data structures to hold them, and it may load other resources over the network. It reuses these allocated resources when possible, to avoid having to reload and reparse them.</source>
          <target state="translated">クエリが実行されると、ドキュメントを解析し、それらを保持するための内部データ構造を割り当て、ネットワーク経由で他のリソースをロードすることがあります。可能な限り、割り当てられたリソースを再利用して、再読み込みや再解析の必要性を回避します。</target>
        </trans-unit>
        <trans-unit id="8a593010a6662d2b59e4a72e57582a95f2f8033f" translate="yes" xml:space="preserve">
          <source>When a rectangular clip is set in combination with &lt;a href=&quot;qsgclipnode#setIsRectangular&quot;&gt;setIsRectangular&lt;/a&gt; the renderer may in some cases use a more optimal clip method.</source>
          <target state="translated">長方形のクリップが&lt;a href=&quot;qsgclipnode#setIsRectangular&quot;&gt;setIsRectangular&lt;/a&gt;と組み合わせて設定されると、レンダラーはより最適なクリップメソッドを使用する場合があります。</target>
        </trans-unit>
        <trans-unit id="65c8e122245f9ff6c381bb4990517a1724e6f958" translate="yes" xml:space="preserve">
          <source>When a relative URL is written to a &lt;code&gt;url&lt;/code&gt; type property, it is converted into a URL object, so &lt;b&gt;matching the URL value against the input string value will fail&lt;/b&gt;. Instead, convert the string to a URL using Qt.resolvedUrl() for means of comparison, and use &lt;code&gt;toString()&lt;/code&gt; to get the contents of the URL:</source>
          <target state="translated">相対URLが &lt;code&gt;url&lt;/code&gt; タイププロパティに書き込まれると、URLオブジェクトに変換されるため&lt;b&gt;、URL値と入力文字列値の照合は失敗し&lt;/b&gt;ます。代わりに、比較のためにQt.resolvedUrl（）を使用して文字列をURLに変換し、 &lt;code&gt;toString()&lt;/code&gt; を使用してURLのコンテンツを取得します。</target>
        </trans-unit>
        <trans-unit id="fccc71619fd1248dd374a7ce2288a8bbb7a01715" translate="yes" xml:space="preserve">
          <source>When a scene is set on a view, the &lt;a href=&quot;qgraphicsscene#changed&quot;&gt;QGraphicsScene::changed&lt;/a&gt;() signal is automatically connected to this view's &lt;a href=&quot;qgraphicsview#updateScene&quot;&gt;updateScene&lt;/a&gt;() slot, and the view's scroll bars are adjusted to fit the size of the scene.</source>
          <target state="translated">ビューにシーンが設定されると、&lt;a href=&quot;qgraphicsscene#changed&quot;&gt;QGraphicsScene :: changed&lt;/a&gt;（）信号がこのビューの&lt;a href=&quot;qgraphicsview#updateScene&quot;&gt;updateScene&lt;/a&gt;（）スロットに自動的に接続され、ビューのスクロールバーがシーンのサイズに合わせて調整されます。</target>
        </trans-unit>
        <trans-unit id="a9d5b266152d0f4cd9bb69c2a4c651cf03cd822b" translate="yes" xml:space="preserve">
          <source>When a shared object is created, it sets the reference count to 1. The reference count is incremented whenever a new object references the shared data, and decremented when the object dereferences the shared data. The shared data is deleted when the reference count becomes zero.</source>
          <target state="translated">共有オブジェクトが作成されると、参照カウントが1に設定されます。 参照カウントは、新しいオブジェクトが共有データを参照するたびにインクリメントされ、オブジェクトが共有データを参照しなくなるとデクリメントされます。参照カウントがゼロになると、共有データは削除されます。</target>
        </trans-unit>
        <trans-unit id="cc3649a6da4b8adb60932067105d0642a4d24c46" translate="yes" xml:space="preserve">
          <source>When a shortcut's key sequence is completed, activatedAmbiguously() is emitted if the key sequence is still ambiguous (i.e., it is the start of one or more other shortcuts). The &lt;a href=&quot;qshortcut#activated&quot;&gt;activated&lt;/a&gt;() signal is not emitted in this case.</source>
          <target state="translated">ショートカットのキーシーケンスが完了すると、キーシーケンスがまだあいまいな場合（つまり、1つ以上の他のショートカットの開始である場合）は、activatedAmbiguously（）が発行されます。&lt;a href=&quot;qshortcut#activated&quot;&gt;活性化された&lt;/a&gt;（）信号は、この場合には出射されません。</target>
        </trans-unit>
        <trans-unit id="6332ae030a9135a45f7906377ec58084cbfab446" translate="yes" xml:space="preserve">
          <source>When a signal is emitted, the slots connected to it are usually executed immediately, just like a normal function call. When this happens, the signals and slots mechanism is totally independent of any GUI event loop. Execution of the code following the &lt;code&gt;emit&lt;/code&gt; statement will occur once all slots have returned. The situation is slightly different when using &lt;a href=&quot;qt#ConnectionType-enum&quot;&gt;queued connections&lt;/a&gt;; in such a case, the code following the &lt;code&gt;emit&lt;/code&gt; keyword will continue immediately, and the slots will be executed later.</source>
          <target state="translated">シグナルが発信されると、通常、それに接続されているスロットは、通常の関数呼び出しと同じようにすぐに実行されます。これが発生した場合、信号とスロットのメカニズムは、GUIイベントループから完全に独立しています。すべてのスロットが戻ると、 &lt;code&gt;emit&lt;/code&gt; ステートメントに続くコードが実行されます。&lt;a href=&quot;qt#ConnectionType-enum&quot;&gt;キューに入れられた接続&lt;/a&gt;を使用する場合、状況は少し異なります。このような場合、 &lt;code&gt;emit&lt;/code&gt; キーワードに続くコードはすぐに続行され、スロットは後で実行されます。</target>
        </trans-unit>
        <trans-unit id="9ddb05e9c434f565919399ed11ae59e44adc1a53" translate="yes" xml:space="preserve">
          <source>When a slot is called in an object due to a signal delivery or due to a remote method call, it is sometimes necessary to know the context in which that happened. In particular, if the slot determines that it wants to send the reply at a later opportunity or if it wants to reply with an error, the context is needed.</source>
          <target state="translated">シグナルの配信やリモートメソッドの呼び出しによってスロットがオブジェクト内で呼び出された場合、それがどのようなコンテキストで起こったのかを知る必要があることがあります。特に、スロットが後の機会に返信を送信したいと判断した場合や、エラーで返信したいと判断した場合には、コンテキストが必要です。</target>
        </trans-unit>
        <trans-unit id="b82f70b447a179232f4e12d074947bc0969bd039" translate="yes" xml:space="preserve">
          <source>When a split handle is dragged, the &lt;code&gt;SplitView.preferredWidth&lt;/code&gt; or &lt;code&gt;SplitView.preferredHeight&lt;/code&gt; property is overwritten, depending on the &lt;a href=&quot;qml-qtquick-controls2-splitview#orientation-prop&quot;&gt;orientation&lt;/a&gt; of the view.</source>
          <target state="translated">分割ハンドルがドラッグされると、ビューの&lt;a href=&quot;qml-qtquick-controls2-splitview#orientation-prop&quot;&gt;方向&lt;/a&gt;に応じて、 &lt;code&gt;SplitView.preferredWidth&lt;/code&gt; または &lt;code&gt;SplitView.preferredHeight&lt;/code&gt; プロパティが上書きされます。</target>
        </trans-unit>
        <trans-unit id="7d4d5ea445229544da0d5338a305894b8698bdd0" translate="yes" xml:space="preserve">
          <source>When a split item is resized, the preferredHeight will be set in order to keep track of the new size.</source>
          <target state="translated">分割されたアイテムのサイズが変更されると、新しいサイズを追跡するためにpreferredHeightが設定されます。</target>
        </trans-unit>
        <trans-unit id="161235a5aac72fca97ccfb11b438ac5fe662b266" translate="yes" xml:space="preserve">
          <source>When a split item is resized, the preferredWidth will be set in order to keep track of the new size.</source>
          <target state="translated">分割されたアイテムのサイズが変更された場合、新しいサイズを追跡するためにpreferredWidthが設定されます。</target>
        </trans-unit>
        <trans-unit id="2a09b738b648e2f453338d46763c1dca7735230f" translate="yes" xml:space="preserve">
          <source>When a stack is added to a group using &lt;a href=&quot;qundogroup#addStack&quot;&gt;addStack&lt;/a&gt;(), the group does not take ownership of the stack. This means the stack has to be deleted separately from the group. When a stack is deleted, it is automatically removed from a group. A stack may belong to only one group. Adding it to another group will cause it to be removed from the previous group.</source>
          <target state="translated">&lt;a href=&quot;qundogroup#addStack&quot;&gt;addStack&lt;/a&gt;（）を使用してグループにスタックを追加すると、グループはスタックの所有権を取得しません。つまり、スタックはグループとは別に削除する必要があります。スタックが削除されると、グループから自動的に削除されます。スタックは1つのグループにのみ属することができます。別のグループに追加すると、前のグループから削除されます。</target>
        </trans-unit>
        <trans-unit id="3d6e4a2b53c50f2891abb48a8f6f6cc25d79ab52" translate="yes" xml:space="preserve">
          <source>When a state extends another state, it inherits all the changes of that state.</source>
          <target state="translated">ある状態が他の状態を拡張したとき、その状態のすべての変更を継承します。</target>
        </trans-unit>
        <trans-unit id="6a4a099453c8a8d91cb5a5c167ee9f1538c09b8c" translate="yes" xml:space="preserve">
          <source>When a state is active, all its parent states are active by definition. When</source>
          <target state="translated">状態がアクティブな場合、定義により、すべての親状態がアクティブになります。状態がアクティブになると</target>
        </trans-unit>
        <trans-unit id="ba9d99ab4b7d6deb7d6417df3035d1441aabe91d" translate="yes" xml:space="preserve">
          <source>When a state is exited prior to the animation finishing, the behavior of the state machine depends on the target state of the transition. If the target state explicitly assigns a value to the property, no additional action will be taken. The property will be assigned the value defined by the target state.</source>
          <target state="translated">アニメーションが終了する前に状態が終了した場合、ステートマシンの動作は遷移のターゲット状態に依存します。ターゲット状態が明示的にプロパティに値を割り当てている場合は、追加の動作は行われません。プロパティには、ターゲット状態で定義された値が割り当てられます。</target>
        </trans-unit>
        <trans-unit id="537b863aa4165206f1678fd45b68c897e7e5bb32" translate="yes" xml:space="preserve">
          <source>When a string is surrounded by slashes, it is interpreted as a &lt;a href=&quot;qregularexpression&quot;&gt;regular expression&lt;/a&gt;.</source>
          <target state="translated">文字列がスラッシュで囲まれている場合、&lt;a href=&quot;qregularexpression&quot;&gt;正規表現&lt;/a&gt;として解釈されます。</target>
        </trans-unit>
        <trans-unit id="f4d38a1eefb6595f564c6b5c58858271837243de" translate="yes" xml:space="preserve">
          <source>When a style sheet is active, the &lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt; returned by &lt;a href=&quot;qwidget#style&quot;&gt;QWidget::style&lt;/a&gt;() is a wrapper &quot;style sheet&quot; style,</source>
          <target state="translated">スタイルシートがアクティブな場合、&lt;a href=&quot;qwidget#style&quot;&gt;QWidget :: style&lt;/a&gt;（）によって返される&lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt;はラッパー「スタイルシート」スタイルです。</target>
        </trans-unit>
        <trans-unit id="e7f2cf6a190dccb2e1846d702f8b4fdcc1492b48" translate="yes" xml:space="preserve">
          <source>When a task menu extension is required,</source>
          <target state="translated">タスクメニューの拡張が必要な場合</target>
        </trans-unit>
        <trans-unit id="b2160c5e21033a9cae7267b16da76e63faf558c9" translate="yes" xml:space="preserve">
          <source>When a texture is sub-sampled, fewer pixels than in the original are displayed, resulting in undesirable artifacts based on which pixels are chosen. This effect is worsened when the model is moving, as different pixels are chosen at different times. In the image below, notice how the line between E3 and F3 is missing, strongly present between G3 and H3, then gone for the next 5 columns, and so on.</source>
          <target state="translated">テクスチャがサブサンプリングされると、オリジナルよりも少ないピクセルが表示され、どのピクセルが選択されたかに基づいて望ましくないアーチファクトが発生します。この効果は、モデルが移動しているときに異なるピクセルが異なるタイミングで選択されるため、悪化します。下の画像では、E3とF3の間の線が欠けていて、G3とH3の間に強く存在していて、次の5つの列まで消えていることに注目してください。</target>
        </trans-unit>
        <trans-unit id="67462236b92450150e95164abdc0c9f99abaed6b" translate="yes" xml:space="preserve">
          <source>When a timer is started, the first trigger is usually after the specified interval has elapsed. It is sometimes desirable to trigger immediately when the timer is started; for example, to establish an initial state.</source>
          <target state="translated">タイマーが開始されると、最初のトリガは通常、指定された間隔が経過した後に行われます。タイマーが開始されたときにすぐにトリガすることが望ましい場合もあります;例えば、初期状態を確立するために。</target>
        </trans-unit>
        <trans-unit id="af89fc9ae90b687bd3803dfbbaa74da9d0b068bb" translate="yes" xml:space="preserve">
          <source>When a toolbar is resized in such a way that it is too small to show all the items it contains, an extension button will appear as the last item in the toolbar. Pressing the extension button will pop up a menu containing the items that do not currently fit in the toolbar.</source>
          <target state="translated">ツールバーのサイズを変更した場合、ツールバーに含まれるすべてのアイテムを表示するには小さすぎるため、拡張ボタンがツールバーの最後のアイテムとして表示されます。拡張ボタンを押すと、現在ツールバーに収まらないアイテムを含むメニューがポップアップ表示されます。</target>
        </trans-unit>
        <trans-unit id="fd7d3a341e5fbdb2b1a43242fcba495d019b0218" translate="yes" xml:space="preserve">
          <source>When a validator is set, the text field will only accept input which leaves the text property in an intermediate state. The &lt;a href=&quot;qml-qtquick-controls2-combobox#accepted-signal&quot;&gt;accepted&lt;/a&gt; signal will only be emitted if the text is in an acceptable state when the &lt;b&gt;Return&lt;/b&gt; or &lt;b&gt;Enter&lt;/b&gt; key is pressed.</source>
          <target state="translated">バリデーターが設定されている場合、テキストフィールドは、テキストプロパティを中間状態のままにする入力のみを受け入れます。&lt;a href=&quot;qml-qtquick-controls2-combobox#accepted-signal&quot;&gt;受け入れられた&lt;/a&gt;ときにテキストが受け入れ可能な状態にある場合、信号にのみ放出される&lt;b&gt;リターン&lt;/b&gt;またはを&lt;b&gt;入力し&lt;/b&gt;、キーが押されています。</target>
        </trans-unit>
        <trans-unit id="9881f5360fc059aa0376cd9d05bbf2f898c14217" translate="yes" xml:space="preserve">
          <source>When a variable or property holds a basic type and it is assigned to another variable or property, then a copy of the value is made. In JavaScript, this value is called a primitive value.</source>
          <target state="translated">ある変数やプロパティが基本型を保持していて、それが他の変数やプロパティに代入されると、その値のコピーが作られます。JavaScriptでは、この値をプリミティブ値と呼びます。</target>
        </trans-unit>
        <trans-unit id="c53c2d5ff931b774b8c26a43310ae5dc80383c71" translate="yes" xml:space="preserve">
          <source>When a version number is specified (using the &lt;code&gt;&lt;a href=&quot;#version&quot;&gt;version&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#versionsym&quot;&gt;versionsym&lt;/a&gt;&lt;/code&gt; variables in a &lt;code&gt;.qdocconf&lt;/code&gt; file), it is accessible through the corresponding \version command for use in the documentation.</source>
          <target state="translated">バージョン番号を指定すると（ &lt;code&gt;.qdocconf&lt;/code&gt; ファイルの &lt;code&gt;&lt;a href=&quot;#version&quot;&gt;version&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;#versionsym&quot;&gt;versionsym&lt;/a&gt;&lt;/code&gt; 変数を使用）、ドキュメントで使用するために、対応する\ versionコマンドを介してアクセスできます。</target>
        </trans-unit>
        <trans-unit id="684ca00eacddf983276d3d465bca149ba5b62e18" translate="yes" xml:space="preserve">
          <source>When a version number is specified (using the &lt;code&gt;&lt;a href=&quot;22-qdoc-configuration-generalvariables#version&quot;&gt;version&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;22-qdoc-configuration-generalvariables#versionsym&quot;&gt;versionsym&lt;/a&gt;&lt;/code&gt; variables in a &lt;code&gt;.qdocconf&lt;/code&gt; file), it is accessible through the corresponding \version command for use in the documentation.</source>
          <target state="translated">バージョン番号が指定されている場合（ &lt;code&gt;.qdocconf&lt;/code&gt; ファイルの &lt;code&gt;&lt;a href=&quot;22-qdoc-configuration-generalvariables#version&quot;&gt;version&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;22-qdoc-configuration-generalvariables#versionsym&quot;&gt;versionsym&lt;/a&gt;&lt;/code&gt; 変数を使用）、ドキュメントで使用するために、対応する\ versionコマンドからアクセスできます。</target>
        </trans-unit>
        <trans-unit id="1aed6e59537ae181997a746ca0c8b7b7d30d9468" translate="yes" xml:space="preserve">
          <source>When a view transition is initialized, any property bindings that refer to the &lt;a href=&quot;qml-qtquick-viewtransition&quot;&gt;ViewTransition&lt;/a&gt; attached property are evaluated in preparation for the transition. Due to the nature of the internal construction of a view transition, the attributes of the &lt;a href=&quot;qml-qtquick-viewtransition&quot;&gt;ViewTransition&lt;/a&gt; attached property are only valid for the relevant item when the transition is initialized, and may not be valid when the transition is actually run.</source>
          <target state="translated">ビュー遷移が初期化されると、&lt;a href=&quot;qml-qtquick-viewtransition&quot;&gt;ViewTransition&lt;/a&gt;添付プロパティを参照するプロパティバインディングが、遷移の準備として評価されます。ビュートランジションの内部構造の性質上、&lt;a href=&quot;qml-qtquick-viewtransition&quot;&gt;ViewTransition&lt;/a&gt;添付プロパティの属性は、トランジションが初期化されるときに関連するアイテムに対してのみ有効であり、トランジションが実際に実行されるときには無効になる場合があります。</target>
        </trans-unit>
        <trans-unit id="2f1582c86a02339dce081b982fa7bf2aabd7e9cf" translate="yes" xml:space="preserve">
          <source>When a view transition is initialized, any property bindings that refer to the ViewTransition attached property are evaluated in preparation for the transition. Due to the nature of the internal construction of a view transition, the attributes of the ViewTransition attached property are only valid for the relevant item when the transition is initialized, and may not be valid when the transition is actually run.</source>
          <target state="translated">ビュー遷移が初期化されると、ViewTransition付属プロパティを参照するプロパティバインディングは、遷移に備えて評価されます。ビュートランジションの内部構造の性質上、ViewTransition付属プロパティの属性は、トランジションが初期化されたときに関連する項目に対してのみ有効であり、実際にトランジションが実行されたときには有効ではない場合があります。</target>
        </trans-unit>
        <trans-unit id="079663e19f7c1ba992af80c0570d23237432e8c5" translate="yes" xml:space="preserve">
          <source>When a web site requests an SSL client certificate, and one or more certificates are found in the system's client certificate store, this class provides access to the certificates to choose from, as well as a method for selecting one.</source>
          <target state="translated">Web サイトが SSL クライアント証明書を要求し、システムのクライアント証明書ストアに 1 つ以上の証明書がある場合、このクラスは証明書を選択するためのアクセスと、その証明書を選択するためのメソッドを提供します。</target>
        </trans-unit>
        <trans-unit id="47f6110b5cfc30bcf437b8673336a30eccbb3a9e" translate="yes" xml:space="preserve">
          <source>When a web site requests an SSL client certificate, and one or more certificates are found in the system's client certificate store, this type provides access to the certificates to choose from, as well as a method for selecting one.</source>
          <target state="translated">Web サイトが SSL クライアント証明書を要求し、システムのクライアント証明書ストアに 1 つ以上の証明書がある場合、このタイプは、証明書を選択するためのアクセスと、証明書を選択する方法を提供します。</target>
        </trans-unit>
        <trans-unit id="1a0abde4adaf9ada28bc188c310ca57b1baed315" translate="yes" xml:space="preserve">
          <source>When a widget &lt;a href=&quot;qwidget#acceptDrops-prop&quot;&gt;accepts drop events&lt;/a&gt;, it will receive this event if it has accepted the most recent &lt;a href=&quot;qdragenterevent&quot;&gt;QDragEnterEvent&lt;/a&gt; or &lt;a href=&quot;qdragmoveevent&quot;&gt;QDragMoveEvent&lt;/a&gt; sent to it.</source>
          <target state="translated">ウィジェットが&lt;a href=&quot;qwidget#acceptDrops-prop&quot;&gt;ドロップイベントを受け入れる&lt;/a&gt;とき、ウィジェットに送信された最新の&lt;a href=&quot;qdragenterevent&quot;&gt;QDragEnterEvent&lt;/a&gt;または&lt;a href=&quot;qdragmoveevent&quot;&gt;QDragMoveEventを&lt;/a&gt;受け入れた場合、ウィジェットはこのイベントを受け取ります。</target>
        </trans-unit>
        <trans-unit id="460e4079ae7809950eebb7e9e8f3fa669aaa1958" translate="yes" xml:space="preserve">
          <source>When a widget asks a style to draw an element, it provides the style with a &lt;a href=&quot;qstyleoption&quot;&gt;QStyleOption&lt;/a&gt;, which is a class that contains the information necessary for drawing. Thanks to &lt;a href=&quot;qstyleoption&quot;&gt;QStyleOption&lt;/a&gt;, it is possible to make &lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt; draw widgets without linking in any code for the widget. This makes it possible to use &lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt;'s draw functions on any paint device, i.e., you can draw a combobox on any widget, not just on a &lt;a href=&quot;qcombobox&quot;&gt;QComboBox&lt;/a&gt;.</source>
          <target state="translated">ウィジェットがスタイルに要素の描画を要求すると、ウィジェットは、描画に必要な情報を含むクラスである&lt;a href=&quot;qstyleoption&quot;&gt;QStyleOption&lt;/a&gt;でスタイルを提供します。&lt;a href=&quot;qstyleoption&quot;&gt;QStyleOptionの&lt;/a&gt;おかげで、ウィジェットのコードをリンクせずに&lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt;ウィジェットを作成することができます。これにより、任意のペイントデバイスで&lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt;の描画関数を使用できるようになります。つまり、&lt;a href=&quot;qcombobox&quot;&gt;QComboBox&lt;/a&gt;だけでなく、任意のウィジェットにコンボボックスを描画できます。</target>
        </trans-unit>
        <trans-unit id="18244731262c183108a3e2f7ccadcf53e5fc48af" translate="yes" xml:space="preserve">
          <source>When a widget asks a style to draw an element, it provides the style with a &lt;a href=&quot;qstyleoption&quot;&gt;QStyleOption&lt;/a&gt;, which is a class that contains the information necessary for drawing. Thanks to &lt;a href=&quot;qstyleoption&quot;&gt;QStyleOption&lt;/a&gt;, it is possible to make &lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt; draw widgets without linking in any code for the widget. This makes it possible to use &lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt;'s draw functions on any paint device, i.e., you can draw a combobox on any widget, not just on a &lt;a href=&quot;widgets-changes-qt6#qcombobox&quot;&gt;QComboBox&lt;/a&gt;.</source>
          <target state="translated">ウィジェットがスタイルに要素の描画を要求すると、ウィジェットはスタイルに&lt;a href=&quot;qstyleoption&quot;&gt;QStyleOptionを&lt;/a&gt;提供します。これは、描画に必要な情報を含むクラスです。&lt;a href=&quot;qstyleoption&quot;&gt;QStyleOptionの&lt;/a&gt;おかげで、ウィジェットのコードをリンクせずに&lt;a href=&quot;qstyle&quot;&gt;QStyleに&lt;/a&gt;ウィジェットを描画させることができます。これにより、&lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt;の描画関数を任意のペイントデバイスで使用できるようになります。つまり、&lt;a href=&quot;widgets-changes-qt6#qcombobox&quot;&gt;QComboBox&lt;/a&gt;だけでなく、任意のウィジェットでコンボボックスを描画できます。</target>
        </trans-unit>
        <trans-unit id="e6f3f2c1aa86e2bdbf72b92865fad22cdf8f8992" translate="yes" xml:space="preserve">
          <source>When a widget is selected, normal clipboard operations such as cut, copy, and paste can be performed on it. All of these operations can be done and undone, as necessary.</source>
          <target state="translated">ウィジェットが選択されている場合、切り取り、コピー、貼り付けなどの通常のクリップボード操作を行うことができます。これらの操作はすべて、必要に応じて行ったり、取り消したりすることができます。</target>
        </trans-unit>
        <trans-unit id="32939db177a40f178792d1ab4a3586964a02a117" translate="yes" xml:space="preserve">
          <source>When a widget is used as a container to group a number of child widgets, it is known as a composite widget. These can be created by constructing a widget with the required visual properties - a &lt;a href=&quot;qframe&quot;&gt;QFrame&lt;/a&gt;, for example - and adding child widgets to it, usually managed by a layout. The above diagram shows such a composite widget that was created using Qt Designer.</source>
          <target state="translated">ウィジェットが多数の子ウィジェットをグループ化するコンテナーとして使用される場合、それは複合ウィジェットとして知られています。これらは、必要な視覚的プロパティ（&lt;a href=&quot;qframe&quot;&gt;QFrame&lt;/a&gt;など）を使用してウィジェットを作成し、それに通常はレイアウトによって管理される子ウィジェットを追加することによって作成できます。上の図は、Qt Designerを使用して作成されたそのような複合ウィジェットを示しています。</target>
        </trans-unit>
        <trans-unit id="752f1a934fb7040e2a75e0adc0d7c4e3b00e3529" translate="yes" xml:space="preserve">
          <source>When a widget's font changes, it resolves its entries against its parent widget. If the widget does not have a parent widget, it resolves its entries against the scene. The widget then sends itself a &lt;a href=&quot;qevent#Type-enum&quot;&gt;FontChange&lt;/a&gt; event and notifies all its descendants so that they can resolve their fonts as well.</source>
          <target state="translated">ウィジェットのフォントが変更されると、そのウィジェットは親ウィジェットに対してエントリを解決します。ウィジェットに親ウィジェットがない場合は、シーンに対してエントリを解決します。次に、ウィジェットは自身に&lt;a href=&quot;qevent#Type-enum&quot;&gt;FontChange&lt;/a&gt;イベントを送信し、すべての子孫に通知して、フォントを解決できるようにします。</target>
        </trans-unit>
        <trans-unit id="8a4c47081bd0d78ce71a943dd5b9dd67bf60e6f3" translate="yes" xml:space="preserve">
          <source>When a widget's palette changes, it resolves its entries against its parent widget, or if it doesn't have a parent widget, it resolves against the scene. It then sends itself a &lt;a href=&quot;qevent#Type-enum&quot;&gt;PaletteChange&lt;/a&gt; event, and notifies all its descendants so they can resolve their palettes as well.</source>
          <target state="translated">ウィジェットのパレットが変更されると、そのウィジェットは親ウィジェットに対してエントリを解決します。または、ウィジェットに親ウィジェットがない場合は、シーンに対して解決します。次に、自身に&lt;a href=&quot;qevent#Type-enum&quot;&gt;PaletteChange&lt;/a&gt;イベントを送信し、すべての子孫に通知して、パレットも解決できるようにします。</target>
        </trans-unit>
        <trans-unit id="6c935a584189a93e055ba79f2173aba07e5d505b" translate="yes" xml:space="preserve">
          <source>When a window is not visible its visibility is Hidden, and setting visibility to &lt;a href=&quot;qwindow#Visibility-enum&quot;&gt;Hidden&lt;/a&gt; is the same as setting &lt;a href=&quot;qml-qtquick-window-window#visible-prop&quot;&gt;visible&lt;/a&gt; to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">ウィンドウが非表示の場合、その可視性はHiddenであり、可視性を&lt;a href=&quot;qwindow#Visibility-enum&quot;&gt;Hiddenに&lt;/a&gt;設定する&lt;a href=&quot;qml-qtquick-window-window#visible-prop&quot;&gt;ことはvisible&lt;/a&gt;を &lt;code&gt;false&lt;/code&gt; に設定することと同じです。</target>
        </trans-unit>
        <trans-unit id="f00f9a36cab0fd127d8e73ba8beab37d6aef658e" translate="yes" xml:space="preserve">
          <source>When a window is not visible its visibility is Hidden, and setting visibility to &lt;a href=&quot;qwindow#Visibility-enum&quot;&gt;Hidden&lt;/a&gt; is the same as setting &lt;a href=&quot;qml-window#visible-prop&quot;&gt;visible&lt;/a&gt; to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">ウィンドウが表示されていない場合、その視認性が隠され、及びに設定視認される&lt;a href=&quot;qwindow#Visibility-enum&quot;&gt;隠し&lt;/a&gt;設定と同じで&lt;a href=&quot;qml-window#visible-prop&quot;&gt;可視&lt;/a&gt;に &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="328cfe9dc26b3602c3dd93834eca6371ca53bcbc" translate="yes" xml:space="preserve">
          <source>When a window is using an OpenGL based surface and is appearing in full screen mode, problems can occur with other top-level windows which are part of the application. Due to limitations of the Windows DWM, compositing is not handled correctly for OpenGL based windows when going into full screen mode. As a result, other top-level windows are not placed on top of the full screen window when they are made visible. For example, menus may not appear correctly, or dialogs fail to show up.</source>
          <target state="translated">ウィンドウがOpenGLベースのサーフェスを使用していて、フルスクリーンモードで表示されている場合、アプリケーションの一部である他のトップレベルのウィンドウで問題が発生する可能性があります。Windows DWMの制限により、全画面モードになると、OpenGLベースのウィンドウの合成が正しく処理されません。その結果、他のトップレベルのウィンドウが表示されても、フルスクリーンウィンドウの上に配置されません。例えば、メニューが正しく表示されなかったり、ダイアログが表示されなかったりすることがあります。</target>
        </trans-unit>
        <trans-unit id="e6e925bbf3d90d27901234a3378310aa8ca76a99" translate="yes" xml:space="preserve">
          <source>When absolutely necessary, this limitation can be overcome by setting the &lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qt::WA_AlwaysStackOnTop&lt;/a&gt; attribute on the &lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidget&lt;/a&gt;. Be aware however that this breaks stacking order, for example it will not be possible to have other widgets on top of the &lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidget&lt;/a&gt;, so it should only be used in situations where a semi-transparent &lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidget&lt;/a&gt; with other widgets visible underneath is required.</source>
          <target state="translated">どうしても必要な場合、この制限は設定することによって克服することができる&lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qtの:: WA_AlwaysStackOnTopの&lt;/a&gt;上の属性を&lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidget&lt;/a&gt;。ただし、これによりスタック順序が崩れることに注意してください。たとえば、&lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidgetの&lt;/a&gt;上に他のウィジェットを配置することはできないため、下に表示される他のウィジェットを持つ半透明の&lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidget&lt;/a&gt;が必要な場合にのみ使用してください。</target>
        </trans-unit>
        <trans-unit id="b6f91c3f1d20bbeecc7d389e5ae573aae0f28831" translate="yes" xml:space="preserve">
          <source>When absolutely necessary, this limitation can be overcome by setting the &lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qt::WA_AlwaysStackOnTop&lt;/a&gt; attribute on the &lt;a href=&quot;qquickwidget&quot;&gt;QQuickWidget&lt;/a&gt;. Be aware, however that this breaks stacking order. For example it will not be possible to have other widgets on top of the &lt;a href=&quot;qquickwidget&quot;&gt;QQuickWidget&lt;/a&gt;, so it should only be used in situations where a semi-transparent &lt;a href=&quot;qquickwidget&quot;&gt;QQuickWidget&lt;/a&gt; with other widgets visible underneath is required.</source>
          <target state="translated">どうしても必要な場合、この制限は設定することによって克服することができる&lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qtの:: WA_AlwaysStackOnTopの&lt;/a&gt;上の属性を&lt;a href=&quot;qquickwidget&quot;&gt;QQuickWidget&lt;/a&gt;。ただし、これによりスタック順序が崩れることに注意してください。たとえば、&lt;a href=&quot;qquickwidget&quot;&gt;QQuickWidgetの&lt;/a&gt;上に他のウィジェットを配置することはできません。そのため、他のウィジェットが下に表示されている半透明の&lt;a href=&quot;qquickwidget&quot;&gt;QQuickWidget&lt;/a&gt;が必要な場合にのみ使用してください。</target>
        </trans-unit>
        <trans-unit id="dd97e50e2c67a4ead279bf8d8832fc9a85185034" translate="yes" xml:space="preserve">
          <source>When absolutely necessary, this limitation can be overcome by setting the &lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qt::WA_AlwaysStackOnTop&lt;/a&gt; attribute on the QOpenGLWidget. Be aware however that this breaks stacking order, for example it will not be possible to have other widgets on top of the QOpenGLWidget, so it should only be used in situations where a semi-transparent QOpenGLWidget with other widgets visible underneath is required.</source>
          <target state="translated">どうしても必要な場合は、&lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;QOpenGLWidgetでQt :: WA_AlwaysStackOnTop&lt;/a&gt;属性を設定することでこの制限を克服できます。ただし、これによりスタックの順序が崩れることに注意してください。たとえば、QOpenGLWidgetの上に他のウィジェットを配置することはできないため、他のウィジェットが下に表示されている半透明のQOpenGLWidgetが必要な場合にのみ使用してください。</target>
        </trans-unit>
        <trans-unit id="e79a7fffcc2719cd295404f96fe561b573e17000" translate="yes" xml:space="preserve">
          <source>When absolutely necessary, this limitation can be overcome by setting the &lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qt::WA_AlwaysStackOnTop&lt;/a&gt; attribute on the QQuickWidget. Be aware, however that this breaks stacking order. For example it will not be possible to have other widgets on top of the QQuickWidget, so it should only be used in situations where a semi-transparent QQuickWidget with other widgets visible underneath is required.</source>
          <target state="translated">どうしても必要な場合は、&lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;QQuickWidgetでQt :: WA_AlwaysStackOnTop&lt;/a&gt;属性を設定することでこの制限を克服できます。ただし、これによりスタックの順序が崩れることに注意してください。たとえば、QQuickWidgetの上に他のウィジェットを配置することはできないため、他のウィジェットが下に表示されている半透明のQQuickWidgetが必要な場合にのみ使用してください。</target>
        </trans-unit>
        <trans-unit id="9df5199ed73ebbcc06766d6511a4572850a19641" translate="yes" xml:space="preserve">
          <source>When access to the data is no longer needed be sure to call the &lt;a href=&quot;qabstractvideobuffer#unmap&quot;&gt;unmap&lt;/a&gt;() function to release the mapped memory and possibly update the buffer contents.</source>
          <target state="translated">データへのアクセスが不要になった場合は、必ず&lt;a href=&quot;qabstractvideobuffer#unmap&quot;&gt;unmap&lt;/a&gt;（）関数を呼び出して、マップされたメモリを解放し、バッファの内容を更新してください。</target>
        </trans-unit>
        <trans-unit id="7f19c431a0d32b110924683908433279ea139496" translate="yes" xml:space="preserve">
          <source>When access to the data is no longer needed, be sure to call the &lt;a href=&quot;qvideoframe#unmap&quot;&gt;unmap&lt;/a&gt;() function to release the mapped memory and possibly update the video frame contents.</source>
          <target state="translated">データへのアクセスが不要になった場合は、必ず&lt;a href=&quot;qvideoframe#unmap&quot;&gt;unmap&lt;/a&gt;（）関数を呼び出して、マップされたメモリを解放し、ビデオフレームの内容を更新してください。</target>
        </trans-unit>
        <trans-unit id="76c2596888d85f6b2c006508a41b7c104d68f3e1" translate="yes" xml:space="preserve">
          <source>When active is &lt;code&gt;true&lt;/code&gt;, and the delegate component is ready, the Instantiator will create objects according to the model. When active is &lt;code&gt;false&lt;/code&gt;, no objects will be created and any previously created objects will be destroyed.</source>
          <target state="translated">activeが &lt;code&gt;true&lt;/code&gt; で、デリゲートコンポーネントの準備ができている場合、Instantiatorはモデルに従ってオブジェクトを作成します。activeが &lt;code&gt;false&lt;/code&gt; の場合、オブジェクトは作成されず、以前に作成されたオブジェクトは破棄されます。</target>
        </trans-unit>
        <trans-unit id="12b8ae889e8cb41399d2e7e574fc759816dcd949" translate="yes" xml:space="preserve">
          <source>When active is true, and the delegate component is ready, the Instantiator will create objects according to the model. When active is false, no objects will be created and any previously created objects will be destroyed.</source>
          <target state="translated">active が true で、デリゲート・コンポーネントの準備ができている場合、インスタンシエータはモデルに従ってオブジェクトを作成します。active が false の場合、オブジェクトは作成されず、以前に作成されたオブジェクトは破棄されます。</target>
        </trans-unit>
        <trans-unit id="bb891bbb3b1590bf7288c70b1d889bb5699abbfb" translate="yes" xml:space="preserve">
          <source>When adding or removing intervals from the time range, existing intervals within the range may be expanded, trimmed, deleted, merged or split to ensure that all intervals within the time range remain distinct and disjoint. As a consequence, all intervals added or removed from a time range must be &lt;a href=&quot;qmediatimeinterval#isNormal&quot;&gt;normal&lt;/a&gt;.</source>
          <target state="translated">時間範囲内の間隔を追加または削除する場合、時間範囲内のすべての間隔が明確に分離されたままになるように、範囲内の既存の間隔を拡張、トリム、削除、マージ、または分割できます。結果として、時間範囲に追加または削除されるすべての間隔は&lt;a href=&quot;qmediatimeinterval#isNormal&quot;&gt;正常である&lt;/a&gt;必要があります。</target>
        </trans-unit>
        <trans-unit id="0d4f3812ee3ea698da8238994dd265c1c75c9c45" translate="yes" xml:space="preserve">
          <source>When adding text to a text edit, it is an advantage to add it in an edit block (see example below). The result is that the text edit does not need to build the entire document structure at once.</source>
          <target state="translated">テキスト編集にテキストを追加する場合は、編集ブロックで追加するのが有利です(下記の例を参照)。その結果、テキスト編集では文書構造全体を一度に構築する必要がなくなります。</target>
        </trans-unit>
        <trans-unit id="bb84371278c0809ff19ae10f5e09e0a84286da38" translate="yes" xml:space="preserve">
          <source>When adding touch events to the sequence,</source>
          <target state="translated">シーケンスにタッチイベントを追加する場合</target>
        </trans-unit>
        <trans-unit id="f1538eed1aaf041d2e66701f8146b1df9ccdc51d" translate="yes" xml:space="preserve">
          <source>When additional touch points are detected, Qt first looks to see if there are any active touch points on any ancestor or descendent of the widget under the new touch point. If there are, the new touch point is grouped with the first, and the new touch point will be sent in a single &lt;a href=&quot;qtouchevent&quot;&gt;QTouchEvent&lt;/a&gt; to the widget that handled the first touch point. (The widget under the new touch point will not receive an event).</source>
          <target state="translated">追加のタッチポイントが検出されると、Qtはまず、新しいタッチポイントの下のウィジェットの祖先または子孫にアクティブなタッチポイントがあるかどうかを確認します。存在する場合、新しいタッチポイントは最初のタッチポイントとグループ化され、新しいタッチポイントは単一の&lt;a href=&quot;qtouchevent&quot;&gt;QTouchEventで&lt;/a&gt;最初のタッチポイントを処理したウィジェットに送信されます。（新しいタッチポイントの下のウィジェットはイベントを受け取りません）。</target>
        </trans-unit>
        <trans-unit id="e556c9c43b8715d0148015f22447dd2e38354307" translate="yes" xml:space="preserve">
          <source>When additional touch points are detected, Qt first looks to see if there are any active touch points on any ancestor or descendent of the widget under the new touch point. If there are, the new touch point is grouped with the first, and the new touch point will be sent in a single QTouchEvent to the widget that handled the first touch point. (The widget under the new touch point will not receive an event).</source>
          <target state="translated">追加のタッチポイントが検出されると、Qt はまず、新しいタッチポイントの下にあるウィジェットの祖先または子孫にアクティブなタッチポイントがあるかどうかを確認します。もしあれば、新しいタッチポイントは最初のタッチポイントとグループ化され、新しいタッチポイントは、最初のタッチポイントを処理したウィジェットに単一のQTouchEventで送信されます。新しいタッチポイントの下のウィジェットはイベントを受信しません)。</target>
        </trans-unit>
        <trans-unit id="7e4c9f17f04f10fedd1f9fd887395ad46b2aa135" translate="yes" xml:space="preserve">
          <source>When all content of the scene has stopped moving, the camera is jiggled very slightly between frames, and the result of each new frame is blended with the previous frames. The more frames you accumulate, the better looking the result.</source>
          <target state="translated">シーンのすべてのコンテンツの動きが止まっているとき、カメラはフレーム間で非常にわずかに揺れ、各新しいフレームの結果は、前のフレームとブレンドされます。フレーム数が多いほど見栄えが良くなります。</target>
        </trans-unit>
        <trans-unit id="e831f4eb7ef019746768c98e62442552c2eec2dc" translate="yes" xml:space="preserve">
          <source>When all the class attribute values are defined as they are in the style.css file that is used for rendering the Qt documentation, the above example is rendered as:</source>
          <target state="translated">Qt ドキュメントのレンダリングに使用される style.css ファイルで、すべてのクラス属性値が定義されている場合、上記の例は次のようにレンダリングされます。</target>
        </trans-unit>
        <trans-unit id="bddff14c450c718712b8166ec8a19a179f1d175d" translate="yes" xml:space="preserve">
          <source>When an &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtqml-modules-identifiedmodules.html#&quot;&gt;identified module&lt;/a&gt; is imported, the QML engine searches the</source>
          <target state="translated">&lt;a href=&quot;https://doc.qt.io/qt-5.13/qtqml-modules-identifiedmodules.html#&quot;&gt;識別されたモジュールが&lt;/a&gt;インポートされ、QMLエンジンの検索</target>
        </trans-unit>
        <trans-unit id="9add852e9635e48ec41c6e958905759815f12454" translate="yes" xml:space="preserve">
          <source>When an &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtqml-modules-identifiedmodules.html&quot;&gt;identified module&lt;/a&gt; is imported, the QML engine searches the</source>
          <target state="translated">&lt;a href=&quot;https://doc.qt.io/qt-5.15/qtqml-modules-identifiedmodules.html&quot;&gt;識別されたモジュールが&lt;/a&gt;インポートされ、QMLエンジンの検索</target>
        </trans-unit>
        <trans-unit id="d40c465f050b8db28c4c35f598504d6759b5fa63" translate="yes" xml:space="preserve">
          <source>When an &lt;a href=&quot;https://doc.qt.io/qt-6.0/qtqml-modules-identifiedmodules.html&quot;&gt;identified module&lt;/a&gt; is imported, the QML engine searches the</source>
          <target state="translated">&lt;a href=&quot;https://doc.qt.io/qt-6.0/qtqml-modules-identifiedmodules.html&quot;&gt;識別されたモジュールが&lt;/a&gt;インポートされ、QMLエンジンの検索</target>
        </trans-unit>
        <trans-unit id="0cb0af928cd358589c97b0ea36760a95bf56bf0a" translate="yes" xml:space="preserve">
          <source>When an &lt;a href=&quot;qml-qtquick-anchoranimation&quot;&gt;AnchorAnimation&lt;/a&gt; is used in a &lt;a href=&quot;https://doc.qt.io/qt-5.13/qmlexampletoggleswitch.html#transition&quot;&gt;Transition&lt;/a&gt;, it will animate any &lt;a href=&quot;qml-qtquick-anchorchanges&quot;&gt;AnchorChanges&lt;/a&gt; that have occurred during the state change. This can be overridden by setting a specific target item using the &lt;a href=&quot;qml-qtquick-anchorchanges#target-prop&quot;&gt;AnchorChanges.target&lt;/a&gt; property.</source>
          <target state="translated">とき&lt;a href=&quot;qml-qtquick-anchoranimation&quot;&gt;AnchorAnimationが&lt;/a&gt;で使用されている&lt;a href=&quot;https://doc.qt.io/qt-5.13/qmlexampletoggleswitch.html#transition&quot;&gt;移行&lt;/a&gt;、それはどんなアニメーションします&lt;a href=&quot;qml-qtquick-anchorchanges&quot;&gt;AnchorChanges&lt;/a&gt;状態変化時に発生しています。これは、&lt;a href=&quot;qml-qtquick-anchorchanges#target-prop&quot;&gt;AnchorChanges.target&lt;/a&gt;プロパティを使用して特定のターゲットアイテムを設定することでオーバーライドできます。</target>
        </trans-unit>
        <trans-unit id="f7ee3afe1168f0981bdb0b13f0d2799a8598f876" translate="yes" xml:space="preserve">
          <source>When an AnchorAnimation is used in a &lt;a href=&quot;https://doc.qt.io/qt-5.15/qmlexampletoggleswitch.html#transition&quot;&gt;Transition&lt;/a&gt;, it will animate any &lt;a href=&quot;qml-qtquick-anchorchanges&quot;&gt;AnchorChanges&lt;/a&gt; that have occurred during the state change. This can be overridden by setting a specific target item using the &lt;a href=&quot;qml-qtquick-anchorchanges#target-prop&quot;&gt;AnchorChanges.target&lt;/a&gt; property.</source>
          <target state="translated">AnchorAnimationが&lt;a href=&quot;https://doc.qt.io/qt-5.15/qmlexampletoggleswitch.html#transition&quot;&gt;Transition&lt;/a&gt;で使用されると、状態の変更中に発生した&lt;a href=&quot;qml-qtquick-anchorchanges&quot;&gt;AnchorChanges&lt;/a&gt;がアニメーション化されます。これは、&lt;a href=&quot;qml-qtquick-anchorchanges#target-prop&quot;&gt;AnchorChanges.target&lt;/a&gt;プロパティを使用して特定のターゲットアイテムを設定することでオーバーライドできます。</target>
        </trans-unit>
        <trans-unit id="faee301ab5657c0c6f33c4ac97a1da25b8e245c3" translate="yes" xml:space="preserve">
          <source>When an AnchorAnimation is used in a &lt;a href=&quot;https://doc.qt.io/qt-6.0/qmlexampletoggleswitch.html#transition&quot;&gt;Transition&lt;/a&gt;, it will animate any &lt;a href=&quot;qml-qtquick-anchorchanges&quot;&gt;AnchorChanges&lt;/a&gt; that have occurred during the state change. This can be overridden by setting a specific target item using the &lt;a href=&quot;qml-qtquick-anchorchanges#target-prop&quot;&gt;AnchorChanges.target&lt;/a&gt; property.</source>
          <target state="translated">AnchorAnimationが&lt;a href=&quot;https://doc.qt.io/qt-6.0/qmlexampletoggleswitch.html#transition&quot;&gt;Transition&lt;/a&gt;で使用されると、状態の変更中に発生した&lt;a href=&quot;qml-qtquick-anchorchanges&quot;&gt;AnchorChanges&lt;/a&gt;がアニメーション化されます。これは、&lt;a href=&quot;qml-qtquick-anchorchanges#target-prop&quot;&gt;AnchorChanges.target&lt;/a&gt;プロパティを使用して特定のターゲットアイテムを設定することでオーバーライドできます。</target>
        </trans-unit>
        <trans-unit id="3ba28642fdd34030f92c386fbe056673579dd0c3" translate="yes" xml:space="preserve">
          <source>When an accessible object is changed in a way that users need to know about, it notifies clients of the change by sending them an event via the accessible interface. This is how &lt;a href=&quot;qslider&quot;&gt;QSlider&lt;/a&gt; calls &lt;a href=&quot;https://doc.qt.io/qt-5.13/qaccessible-obsolete.html#updateAccessibility&quot;&gt;updateAccessibility()&lt;/a&gt; to indicate that its value has changed:</source>
          <target state="translated">ユーザーが知る必要のある方法でユーザー補助オブジェクトが変更されると、ユーザー補助オブジェクトを介してイベントを送信することで、クライアントに変更を通知します。これは、&lt;a href=&quot;qslider&quot;&gt;QSlider&lt;/a&gt;が&lt;a href=&quot;https://doc.qt.io/qt-5.13/qaccessible-obsolete.html#updateAccessibility&quot;&gt;updateAccessibility（）&lt;/a&gt;を呼び出して、その値が変更されたことを示す方法です。</target>
        </trans-unit>
        <trans-unit id="b37fb5dbdfd3c126b6bb96b69ea36eec43900147" translate="yes" xml:space="preserve">
          <source>When an accessible object is changed in a way that users need to know about, it notifies clients of the change by sending them an event via the accessible interface. This is how &lt;a href=&quot;qslider&quot;&gt;QSlider&lt;/a&gt; calls &lt;a href=&quot;https://doc.qt.io/qt-5.15/qaccessible-obsolete.html#updateAccessibility&quot;&gt;updateAccessibility()&lt;/a&gt; to indicate that its value has changed:</source>
          <target state="translated">アクセス可能なオブジェクトがユーザーが知る必要のある方法で変更されると、アクセス可能なインターフェイスを介してイベントをクライアントに送信することにより、変更をクライアントに通知します。これは、&lt;a href=&quot;qslider&quot;&gt;QSlider&lt;/a&gt;が&lt;a href=&quot;https://doc.qt.io/qt-5.15/qaccessible-obsolete.html#updateAccessibility&quot;&gt;updateAccessibility（）&lt;/a&gt;を呼び出して、その値が変更されたことを示す方法です。</target>
        </trans-unit>
        <trans-unit id="00d1038d5d102e70428982041f3613d0e5cf5771" translate="yes" xml:space="preserve">
          <source>When an accessible object is changed in a way that users need to know about, it notifies clients of the change by sending them an event via the accessible interface. This is how &lt;a href=&quot;qslider&quot;&gt;QSlider&lt;/a&gt; calls &lt;a href=&quot;qaccessible#updateAccessibility&quot;&gt;updateAccessibility()&lt;/a&gt; to indicate that its value has changed:</source>
          <target state="translated">アクセス可能なオブジェクトがユーザーが知る必要のある方法で変更されると、アクセス可能なインターフェイスを介してイベントをクライアントに送信することにより、変更をクライアントに通知します。これは、&lt;a href=&quot;qslider&quot;&gt;QSlider&lt;/a&gt;が&lt;a href=&quot;qaccessible#updateAccessibility&quot;&gt;updateAccessibility（）&lt;/a&gt;を呼び出して、その値が変更されたことを示す方法です。</target>
        </trans-unit>
        <trans-unit id="6576db350133d85ab8ecdf7d5ae903317f8a0480" translate="yes" xml:space="preserve">
          <source>When an action is paired with buttons and menu items, the &lt;code&gt;enabled&lt;/code&gt;, &lt;code&gt;checkable&lt;/code&gt;, and &lt;code&gt;checked&lt;/code&gt; states are synced automatically. For example, in a word processor, if the user clicks a &quot;Bold&quot; toolbar button, the &quot;Bold&quot; menu item will automatically be checked. Buttons and menu items get their &lt;code&gt;text&lt;/code&gt; and &lt;code&gt;icon&lt;/code&gt; from the action by default. An action-specific &lt;code&gt;text&lt;/code&gt; or &lt;code&gt;icon&lt;/code&gt; can be overridden for a specific control by specifying &lt;code&gt;text&lt;/code&gt; or &lt;code&gt;icon&lt;/code&gt; directly on the control.</source>
          <target state="translated">アクションがボタンおよびメニュー項目とペアになると、 &lt;code&gt;enabled&lt;/code&gt; 、 &lt;code&gt;checked&lt;/code&gt; &lt;code&gt;checkable&lt;/code&gt; 、およびチェック済みの状態が自動的に同期されます。たとえば、ワードプロセッサでは、ユーザーが[太字]ツールバーボタンをクリックすると、[太字]メニュー項目が自動的にチェックされます。ボタンとメニュー項目は、デフォルトでアクションから &lt;code&gt;text&lt;/code&gt; と &lt;code&gt;icon&lt;/code&gt; 取得します。コントロールで &lt;code&gt;text&lt;/code&gt; または &lt;code&gt;icon&lt;/code&gt; 直接指定することにより、特定のコントロールのアクション固有の &lt;code&gt;text&lt;/code&gt; または &lt;code&gt;icon&lt;/code&gt; をオーバーライドできます。</target>
        </trans-unit>
        <trans-unit id="afbbfa71a43b518eb49ebc7fe0e3a201130db196" translate="yes" xml:space="preserve">
          <source>When an animation is used as a value source or in a Behavior, the default target and property name to be animated can both be inferred.</source>
          <target state="translated">アニメーションが値のソースとして使用されている場合、またはビヘイビア内で使用されている場合、アニメーションのデフォルトのターゲットとプロパティ名の両方を推測することができます。</target>
        </trans-unit>
        <trans-unit id="336fbed65cc485dcf3185a5f916cafb70ff1cbed" translate="yes" xml:space="preserve">
          <source>When an animation is used standalone, both the target and property need to be explicitly specified.</source>
          <target state="translated">アニメーションをスタンドアロンで使用する場合は、ターゲットとプロパティの両方を明示的に指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="3e063384f01e7cc982fe175643205033a89ac5c6" translate="yes" xml:space="preserve">
          <source>When an application modal dialog is opened, the user must finish interacting with the dialog and close it before they can access any other window in the application. Window modal dialogs only block access to the window associated with the dialog, allowing the user to continue to use other windows in an application.</source>
          <target state="translated">アプリケーションのモーダルダイアログが開かれている場合、ユーザーは、アプリケーション内の他のウィンドウにアクセスする前に、ダイアログとの対話を終了し、ダイアログを閉じなければなりません。ウィンドウモーダルダイアログは、ダイアログに関連付けられたウィンドウへのアクセスをブロックするだけで、ユーザーはアプリケーション内の他のウィンドウを使用し続けることができます。</target>
        </trans-unit>
        <trans-unit id="03f1ac029efa0e89898412a8bc3f237fc158d829" translate="yes" xml:space="preserve">
          <source>When an error occurs during a transaction (including an inner transaction failing), reading from the data stream is suspended (all subsequent read operations return empty/zero values) and subsequent inner transactions are forced to fail. Starting a new outermost transaction recovers from this state. This behavior makes it unnecessary to error-check every read operation separately.</source>
          <target state="translated">トランザクション中にエラーが発生すると(内部トランザクションの失敗を含む)、データ・ストリームからの読み取りが中断され(それ以降のすべての読み取り操作は空/ゼロ値を返す)、それ以降の内部トランザクションは強制的に失敗します。新しい最外周のトランザクションを開始すると、この状態から回復します。この動作により、すべての読み取り操作を個別にエラーチェックする必要がなくなります。</target>
        </trans-unit>
        <trans-unit id="d4d4dd6c5a276f9a88210865c11ad3239fc05498" translate="yes" xml:space="preserve">
          <source>When an escape button can't be determined using these rules, pressing &lt;b&gt;Esc&lt;/b&gt; has no effect.</source>
          <target state="translated">これらのルールを使用してエスケープボタンを決定できない場合、&lt;b&gt;Escキーを押し&lt;/b&gt;ても効果はありません。</target>
        </trans-unit>
        <trans-unit id="88e91d6c3ac2f70e9dc327611729bb3fc23462f4" translate="yes" xml:space="preserve">
          <source>When an escape button could not be automatically detected, pressing &lt;b&gt;Esc&lt;/b&gt; has no effect.</source>
          <target state="translated">エスケープボタンが自動的に検出されなかった場合、&lt;b&gt;Escキーを押し&lt;/b&gt;ても何も&lt;b&gt;起こり&lt;/b&gt;ません。</target>
        </trans-unit>
        <trans-unit id="60deb4d5ec6470a1989d6f1aae50fd37df3fb27a" translate="yes" xml:space="preserve">
          <source>When an event notification identified by</source>
          <target state="translated">で識別されたイベント通知がある場合</target>
        </trans-unit>
        <trans-unit id="cc1c8c604562d809abc5eea2fc6d1c3875525ea6" translate="yes" xml:space="preserve">
          <source>When an event occurs, Qt creates an event object to represent it by constructing an instance of the appropriate &lt;a href=&quot;qevent&quot;&gt;QEvent&lt;/a&gt; subclass, and delivers it to a particular instance of &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; (or one of its subclasses) by calling its &lt;a href=&quot;qobject#event&quot;&gt;event()&lt;/a&gt; function.</source>
          <target state="translated">イベントが発生すると、Qtは適切な&lt;a href=&quot;qevent&quot;&gt;QEvent&lt;/a&gt;サブクラスのインスタンスを作成してそれを表すイベントオブジェクトを作成し、&lt;a href=&quot;qobject#event&quot;&gt;event（）&lt;/a&gt;関数を呼び出してそれを&lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt;（またはそのサブクラスの1つ）の特定のインスタンスに配信します。</target>
        </trans-unit>
        <trans-unit id="de6f46d25c54bf3f5ae53599544aff515fdc8c6f" translate="yes" xml:space="preserve">
          <source>When an extension is requested,</source>
          <target state="translated">延長を要求された場合。</target>
        </trans-unit>
        <trans-unit id="82176d3ebc0806a90e56a238f12634352670b5cd" translate="yes" xml:space="preserve">
          <source>When an extension is required,</source>
          <target state="translated">延長が必要な場合。</target>
        </trans-unit>
        <trans-unit id="15891740de686f6443de37f1b681bce112b87311" translate="yes" xml:space="preserve">
          <source>When an input mask is set, the &lt;a href=&quot;qlineedit#text-prop&quot;&gt;text&lt;/a&gt;() method returns a modified copy of the line edit content where all the</source>
          <target state="translated">入力マスクが設定されている場合、&lt;a href=&quot;qlineedit#text-prop&quot;&gt;text&lt;/a&gt;（）メソッドは、行編集コンテンツの変更されたコピーを返します。</target>
        </trans-unit>
        <trans-unit id="e58900421752248eb5fa9c7e1a8662c806ac6e45" translate="yes" xml:space="preserve">
          <source>When an item becomes the child of another item:</source>
          <target state="translated">アイテムが他のアイテムの子になった場合。</target>
        </trans-unit>
        <trans-unit id="6de19d2590d4fe0fe6e06630c40b5632e67df7b0" translate="yes" xml:space="preserve">
          <source>When an item gains the keyboard grab, it receives a &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent::GrabKeyboard&lt;/a&gt; event. When it loses the keyboard grab, it receives a &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent::UngrabKeyboard&lt;/a&gt; event. These events can be used to detect when your item gains or loses the keyboard grab through other means than gaining input focus.</source>
          <target state="translated">アイテムがキーボードを取得すると、&lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent :: GrabKeyboard&lt;/a&gt;イベントを受け取ります。キーボードグラブを失うと、&lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent :: UngrabKeyboard&lt;/a&gt;イベントを受け取ります。これらのイベントを使用して、入力フォーカスを取得する以外の方法でアイテムがキーボードグラブを取得または喪失したことを検出できます。</target>
        </trans-unit>
        <trans-unit id="64c535dc14ed7e2aa62d21df9de2e71bdefba665" translate="yes" xml:space="preserve">
          <source>When an item gains the mouse grab, it receives a &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent::GrabMouse&lt;/a&gt; event. When it loses the mouse grab, it receives a &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent::UngrabMouse&lt;/a&gt; event. These events can be used to detect when your item gains or loses the mouse grab through other means than receiving mouse button events.</source>
          <target state="translated">アイテムがマウスグラブを取得すると、&lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent :: GrabMouse&lt;/a&gt;イベントを受け取ります。マウスグラブを失うと、&lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent :: UngrabMouse&lt;/a&gt;イベントを受け取ります。これらのイベントを使用して、マウスボタンイベントを受け取る以外の方法でアイテムがマウスグラブを獲得または喪失したことを検出できます。</target>
        </trans-unit>
        <trans-unit id="6f8dc2c7ef923f949343da800eb159af2c1dde1c" translate="yes" xml:space="preserve">
          <source>When an item in an item view is selected, also highlight the branch or other decoration.</source>
          <target state="translated">アイテムビューのアイテムが選択されている場合は、枝などの装飾も強調表示されます。</target>
        </trans-unit>
        <trans-unit id="fcc2ea9c9f7cae3dd849abe3ca69b4158eef37eb" translate="yes" xml:space="preserve">
          <source>When an item is disabled, it is not possible to trigger it through its &lt;a href=&quot;qml-qt-labs-platform-menuitem#shortcut-prop&quot;&gt;shortcut&lt;/a&gt;.</source>
          <target state="translated">アイテムが無効になっている場合、&lt;a href=&quot;qml-qt-labs-platform-menuitem#shortcut-prop&quot;&gt;ショートカット&lt;/a&gt;からアイテムをトリガーすることはできません。</target>
        </trans-unit>
        <trans-unit id="452a0cf012b3cb9c186457a25f7cb1b1b7718e16" translate="yes" xml:space="preserve">
          <source>When an item is editable (and enabled), the user can edit the item by invoking one of the view's edit triggers; see &lt;a href=&quot;qabstractitemview#editTriggers-prop&quot;&gt;QAbstractItemView::editTriggers&lt;/a&gt;.</source>
          <target state="translated">アイテムが編集可能（かつ有効）である場合、ユーザーはビューの編集トリガーの1つを呼び出すことによってアイテムを編集できます。&lt;a href=&quot;qabstractitemview#editTriggers-prop&quot;&gt;QAbstractItemView :: editTriggersを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="53f7062365ff27f397c1a00527a4d2f3130aae95" translate="yes" xml:space="preserve">
          <source>When an item is enabled, the user can interact with it. The possible types of interaction are specified by the other item flags, such as &lt;a href=&quot;qstandarditem#isEditable&quot;&gt;isEditable&lt;/a&gt;() and &lt;a href=&quot;qstandarditem#isSelectable&quot;&gt;isSelectable&lt;/a&gt;().</source>
          <target state="translated">アイテムが有効になると、ユーザーはそのアイテムを操作できます。可能な相互作用のタイプは、&lt;a href=&quot;qstandarditem#isEditable&quot;&gt;isEditable&lt;/a&gt;（）や&lt;a href=&quot;qstandarditem#isSelectable&quot;&gt;isSelectable&lt;/a&gt;（）などの他の項目フラグによって指定されます。</target>
        </trans-unit>
        <trans-unit id="cc78ed51b3f4dd69fbf5c809ac07b2202ac93036" translate="yes" xml:space="preserve">
          <source>When an item is flicked out, it moves to the</source>
          <target state="translated">アイテムをフリックアウトすると</target>
        </trans-unit>
        <trans-unit id="edf649890497fe5584e977a2ddf9e845a6d9adbb" translate="yes" xml:space="preserve">
          <source>When an item's layer is enabled, the scene graph will allocate memory in the GPU equal to &lt;code&gt;width x height x 4&lt;/code&gt;. In memory constrained configurations, large layers should be used with care.</source>
          <target state="translated">アイテムのレイヤーが有効な場合、シーングラフはGPUに &lt;code&gt;width x height x 4&lt;/code&gt; 等しいメモリを割り当てます。メモリに制約のある構成では、大きなレイヤーを注意して使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="01223f794ced4ae7d5d61d347c9ab920ed50ad46" translate="yes" xml:space="preserve">
          <source>When an object is deleted, it emits a &lt;a href=&quot;qobject#destroyed&quot;&gt;destroyed&lt;/a&gt;() signal. You can catch this signal to avoid dangling references to QObjects.</source>
          <target state="translated">オブジェクトが削除されると、&lt;a href=&quot;qobject#destroyed&quot;&gt;destroyed&lt;/a&gt;（）シグナルが発生します。このシグナルをキャッチして、QObjectsへの参照がぶら下がることを回避できます。</target>
        </trans-unit>
        <trans-unit id="b5486876fa77fcc351c0468b0f817e3d9df8a75d" translate="yes" xml:space="preserve">
          <source>When and whether you actually</source>
          <target state="translated">実際にいつ、どのような場合に</target>
        </trans-unit>
        <trans-unit id="9d01348a9aece3a4b6e828d26241b1bbac417b30" translate="yes" xml:space="preserve">
          <source>When animations are used to assign properties, a state no longer defines the exact values that a property will have when the machine is in the given state. While the animation is running, the property can potentially have any value, depending on the animation.</source>
          <target state="translated">アニメーションがプロパティの割り当てに使用されている場合、マシンが指定された状態にあるときにプロパティが持つ正確な値は、状態によって定義されなくなります。アニメーションが実行されている間は、アニメーションに応じて、プロパティが任意の値を持つ可能性があります。</target>
        </trans-unit>
        <trans-unit id="e2fc21797749a0f52070944bd489489ff6abab01" translate="yes" xml:space="preserve">
          <source>When any item is added, moved or removed within the above view, the items below it are displaced, causing them to move down (or sideways, if horizontally orientated) within the view. As this displacement occurs, the items' movement to their new x,y positions within the view will be animated by a &lt;a href=&quot;qml-qtquick-numberanimation&quot;&gt;NumberAnimation&lt;/a&gt; over one second, as specified.</source>
          <target state="translated">上のビュー内でアイテムが追加、移動、または削除されると、その下のアイテムが移動し、ビュー内で下方向（または横向きの場合は横）に移動します。この変位が発生すると、ビュー内の項目の新しいx、y位置への移動は、指定された&lt;a href=&quot;qml-qtquick-numberanimation&quot;&gt;ように&lt;/a&gt;、1秒間、NumberAnimationによってアニメーション化されます。</target>
        </trans-unit>
        <trans-unit id="6ad254e9576e1f6e7ddb5f7d88c66a573a0635ac" translate="yes" xml:space="preserve">
          <source>When any of the states is entered, the label's text will be changed accordingly.</source>
          <target state="translated">いずれかの州が入力されると、それに応じてラベルのテキストが変更されます。</target>
        </trans-unit>
        <trans-unit id="92871574343d3169789071570bca986c9cf96ef4" translate="yes" xml:space="preserve">
          <source>When any of these are needed, the Connections type can be used instead.</source>
          <target state="translated">これらのいずれかが必要な場合は、代わりに Connections タイプを使用することができます。</target>
        </trans-unit>
        <trans-unit id="684810257cd0aed1db1716426f1de0a6c11c6d93" translate="yes" xml:space="preserve">
          <source>When any visible part of the scene changes or is reexposed, &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; will update the entire viewport. This approach is fastest when &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; spends more time figuring out what to draw than it would spend drawing (e.g., when very many small items are repeatedly updated). This is the preferred update mode for viewports that do not support partial updates, such as &lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidget&lt;/a&gt;, and for viewports that need to disable scroll optimization.</source>
          <target state="translated">シーンの表示されている部分が変更または再&lt;a href=&quot;qgraphicsview&quot;&gt;公開&lt;/a&gt;されると、QGraphicsViewはビューポート全体を更新します。このアプローチは、&lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsViewが描画に&lt;/a&gt;費やすよりも何を描画するかを理解するのに多くの時間を費やす場合（たとえば、非常に多くの小さなアイテムが繰り返し更新される場合）に最速です。これは、&lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidget&lt;/a&gt;などの部分的な更新をサポートしないビューポート、およびスクロールの最適化を無効にする必要があるビューポートに推奨される更新モードです。</target>
        </trans-unit>
        <trans-unit id="217cf31f7ecab879e6aeaf0c5c92b52eaff625db" translate="yes" xml:space="preserve">
          <source>When any visible part of the scene changes or is reexposed, &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; will update the entire viewport. This approach is fastest when &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; spends more time figuring out what to draw than it would spend drawing (e.g., when very many small items are repeatedly updated). This is the preferred update mode for viewports that do not support partial updates, such as QGLWidget, and for viewports that need to disable scroll optimization.</source>
          <target state="translated">シーンの表示されている部分が変更または再&lt;a href=&quot;qgraphicsview&quot;&gt;表示&lt;/a&gt;されると、QGraphicsViewはビューポート全体を更新します。このアプローチは、&lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsViewが描画に&lt;/a&gt;費やすよりも何を描画するかを考えるのに多くの時間を費やす場合に最も高速です（たとえば、非常に多くの小さなアイテムが繰り返し更新される場合）。これは、QGLWidgetなどの部分更新をサポートしていないビューポートや、スクロール最適化を無効にする必要があるビューポートで推奨される更新モードです。</target>
        </trans-unit>
        <trans-unit id="06d3ae994a8edf1ab3ef099d6fd125e756542e75" translate="yes" xml:space="preserve">
          <source>When any visible part of the scene changes or is reexposed, &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; will update the entire viewport. This approach is fastest when &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; spends more time figuring out what to draw than it would spend drawing (e.g., when very many small items are repeatedly updated). This is the preferred update mode for viewports that do not support partial updates, such as QOpenGLWidget, and for viewports that need to disable scroll optimization.</source>
          <target state="translated">シーンの表示されている部分が変更または再&lt;a href=&quot;qgraphicsview&quot;&gt;公開&lt;/a&gt;されると、QGraphicsViewはビューポート全体を更新します。このアプローチは、&lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsViewが描画に&lt;/a&gt;費やすよりも何を描画するかを理解するのに多くの時間を費やす場合（たとえば、非常に多くの小さなアイテムが繰り返し更新される場合）に最速です。これは、QOpenGLWidgetなどの部分的な更新をサポートしないビューポート、およびスクロールの最適化を無効にする必要があるビューポートに推奨される更新モードです。</target>
        </trans-unit>
        <trans-unit id="a06bc6d7390ca623b0217a85f5d3800a53cff310" translate="yes" xml:space="preserve">
          <source>When applying &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtquick-effects-topic.html#opacity&quot;&gt;opacity&lt;/a&gt; to an item hierarchy the opacity is applied to each item individually. This can lead to undesired visual results when the opacity is applied to a subtree. Consider the following example:</source>
          <target state="translated">適用するときに&lt;a href=&quot;https://doc.qt.io/qt-5.13/qtquick-effects-topic.html#opacity&quot;&gt;不透明度を&lt;/a&gt;不透明度は、個々の項目に適用される階層の項目に。これにより、不透明度がサブツリーに適用されると、望ましくない視覚結果が生じる可能性があります。次の例を検討してください。</target>
        </trans-unit>
        <trans-unit id="5a74e7e50f43c1fdec3974065e7b6a9d890d2418" translate="yes" xml:space="preserve">
          <source>When applying &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtquick-effects-topic.html#opacity&quot;&gt;opacity&lt;/a&gt; to an item hierarchy the opacity is applied to each item individually. This can lead to undesired visual results when the opacity is applied to a subtree. Consider the following example:</source>
          <target state="translated">適用するときに&lt;a href=&quot;https://doc.qt.io/qt-5.15/qtquick-effects-topic.html#opacity&quot;&gt;不透明度を&lt;/a&gt;不透明度は、個々の項目に適用される階層の項目に。これにより、不透明度がサブツリーに適用されたときに、望ましくない視覚的な結果が生じる可能性があります。次の例を考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="78679de72c9d4b1f3d2b134f2faa28f329cfbb7a" translate="yes" xml:space="preserve">
          <source>When applying &lt;a href=&quot;https://doc.qt.io/qt-6.0/qtquick-effects-topic.html#opacity&quot;&gt;opacity&lt;/a&gt; to an item hierarchy the opacity is applied to each item individually. This can lead to undesired visual results when the opacity is applied to a subtree. Consider the following example:</source>
          <target state="translated">適用するときに&lt;a href=&quot;https://doc.qt.io/qt-6.0/qtquick-effects-topic.html#opacity&quot;&gt;不透明度を&lt;/a&gt;不透明度は、個々の項目に適用される階層の項目に。これにより、不透明度がサブツリーに適用されたときに、望ましくない視覚的な結果が生じる可能性があります。次の例を考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="03f4da2f8d439defdd9e3b555f171b3b3c94fa9c" translate="yes" xml:space="preserve">
          <source>When applying a clip to a subtree, that subtree needs to be rendered with a unique OpenGL state. This means that when &lt;a href=&quot;qml-qtquick-item#clip-prop&quot;&gt;Item::clip&lt;/a&gt; is true, batching of that item is limited to its children. When there are many children, like a &lt;a href=&quot;qml-qtquick-listview&quot;&gt;ListView&lt;/a&gt; or &lt;a href=&quot;qml-qtquick-gridview&quot;&gt;GridView&lt;/a&gt;, or complex children, like a &lt;a href=&quot;qml-qtquick-controls-textarea&quot;&gt;TextArea&lt;/a&gt;, this is fine. One should, however, use clip on smaller items with caution as it prevents batching. This includes button label, text field or list delegate and table cells.</source>
          <target state="translated">クリップをサブツリーに適用する場合、そのサブツリーは一意のOpenGL状態でレンダリングする必要があります。つまり、&lt;a href=&quot;qml-qtquick-item#clip-prop&quot;&gt;Item :: clip&lt;/a&gt;がtrueの場合、そのアイテムのバッチ処理はその子に限定されます。&lt;a href=&quot;qml-qtquick-listview&quot;&gt;ListView&lt;/a&gt;や&lt;a href=&quot;qml-qtquick-gridview&quot;&gt;GridViewの&lt;/a&gt;ような多くの子、または&lt;a href=&quot;qml-qtquick-controls-textarea&quot;&gt;TextAreaの&lt;/a&gt;ような複雑な子がある場合、これは問題ありません。ただし、バッチ処理を防ぐため、小さいアイテムにはクリップを使用する必要があります。これには、ボタンラベル、テキストフィールドまたはリストデリゲート、およびテーブルセルが含まれます。</target>
        </trans-unit>
        <trans-unit id="74f4063795ab227fe7ae24a79df545f1ccc36474" translate="yes" xml:space="preserve">
          <source>When applying a clip to a subtree, that subtree needs to be rendered with a unique OpenGL state. This means that when &lt;a href=&quot;qml-qtquick-item#clip-prop&quot;&gt;Item::clip&lt;/a&gt; is true, batching of that item is limited to its children. When there are many children, like a &lt;a href=&quot;qml-qtquick-listview&quot;&gt;ListView&lt;/a&gt; or &lt;a href=&quot;qml-qtquick-gridview&quot;&gt;GridView&lt;/a&gt;, or complex children, like a &lt;a href=&quot;qml-qtquick-controls2-textarea&quot;&gt;TextArea&lt;/a&gt;, this is fine. One should, however, use clip on smaller items with caution as it prevents batching. This includes button label, text field or list delegate and table cells.</source>
          <target state="translated">クリップをサブツリーに適用する場合、そのサブツリーは一意のOpenGL状態でレンダリングする必要があります。これは、&lt;a href=&quot;qml-qtquick-item#clip-prop&quot;&gt;Item :: clip&lt;/a&gt;がtrueの場合、そのアイテムのバッチ処理はその子に限定されることを意味します。&lt;a href=&quot;qml-qtquick-listview&quot;&gt;ListView&lt;/a&gt;や&lt;a href=&quot;qml-qtquick-gridview&quot;&gt;GridViewの&lt;/a&gt;ように多くの子がある場合、または&lt;a href=&quot;qml-qtquick-controls2-textarea&quot;&gt;TextAreaの&lt;/a&gt;ように複雑な子がある場合、これは問題ありません。ただし、小さなアイテムには、バッチ処理を妨げるため、クリップを使用する場合は注意が必要です。これには、ボタンラベル、テキストフィールド、またはリストデリゲートとテーブルセルが含まれます。</target>
        </trans-unit>
        <trans-unit id="b46cb236869034e639f5c98ef59e6e0dc79b743e" translate="yes" xml:space="preserve">
          <source>When assigning values to properties in QML, any layouting the item must do as a result of the assignment might not take effect immediately, but can instead be postponed until the item is polished. For these cases, you can use this function to ensure that the item has been polished before the execution of the test continues. For example:</source>
          <target state="translated">QML のプロパティに値を代入する際に、代入の結果、その項目で行わなければならないレイアウトがすぐには反映されず、その項目が洗練されるまで延期されることがあります。このような場合には、この関数を使用することで、テストの実行を継続する前に項目が磨かれていることを確認することができます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="9aade8d1fb980c82f7d60913e871590165c272dc" translate="yes" xml:space="preserve">
          <source>When asynchronous is true the Instantiator will attempt to create objects asynchronously. This means that objects may not be available immediately, even if active is set to true.</source>
          <target state="translated">asynchronous が true の場合、インスタンシエータは非同期にオブジェクトを作成しようとします。つまり、active が true に設定されていても、オブジェクトがすぐに利用できるとは限らないということです。</target>
        </trans-unit>
        <trans-unit id="ed095d8711f54124e3343d3e3564a7eefda4e48d" translate="yes" xml:space="preserve">
          <source>When atEnd() and &lt;a href=&quot;qxmlstreamreader#hasError&quot;&gt;hasError&lt;/a&gt;() return true and &lt;a href=&quot;qxmlstreamreader#error&quot;&gt;error&lt;/a&gt;() returns &lt;a href=&quot;qxmlstreamreader#Error-enum&quot;&gt;PrematureEndOfDocumentError&lt;/a&gt;, it means the XML has been well-formed so far, but a complete XML document has not been parsed. The next chunk of XML can be added with &lt;a href=&quot;qxmlstreamreader#addData&quot;&gt;addData&lt;/a&gt;(), if the XML is being read from a &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt;, or by waiting for more data to arrive if the XML is being read from a &lt;a href=&quot;qiodevice&quot;&gt;QIODevice&lt;/a&gt;. Either way, atEnd() will return false once more data is available.</source>
          <target state="translated">atEnd（）および&lt;a href=&quot;qxmlstreamreader#hasError&quot;&gt;hasError&lt;/a&gt;（）がtrueを返し、&lt;a href=&quot;qxmlstreamreader#error&quot;&gt;エラー&lt;/a&gt;（）が&lt;a href=&quot;qxmlstreamreader#Error-enum&quot;&gt;PrematureEndOfDocumentErrorを&lt;/a&gt;返す場合、それはこれまでのところXMLは整形式であるが、完全なXMLドキュメントは解析されていないことを意味します。XMLの次のチャンクを用いて加えることができる&lt;a href=&quot;qxmlstreamreader#addData&quot;&gt;は、addData&lt;/a&gt; XMLから読み出されている場合、（）&lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt;、またはXMLから読み出されている場合、より多くのデータが到着するのを待つことによって&lt;a href=&quot;qiodevice&quot;&gt;のQIODevice&lt;/a&gt;。どちらの方法でも、atEnd（）は、さらにデータが利用可能になるとfalseを返します。</target>
        </trans-unit>
        <trans-unit id="b3157310c43a1e88b9499e85e194d29092d5e110" translate="yes" xml:space="preserve">
          <source>When automatically registering QML types defined in C++, register an additional version of the module using this minor version. Generally, minor versions to be registered are inferred from the meta objects.</source>
          <target state="translated">C++で定義されたQML型を自動的に登録する場合、このマイナーバージョンを用いてモジュールの追加バージョンを登録する。一般的に、登録するマイナーバージョンはメタオブジェクトから推測される。</target>
        </trans-unit>
        <trans-unit id="769b89390fbaab8a30caa729005e13bd89dd70b2" translate="yes" xml:space="preserve">
          <source>When both the &lt;a href=&quot;qml-qtpurchasing-product#identifier-prop&quot;&gt;identifier&lt;/a&gt; and type is set, the product is queried from the external market place, and its other properties are updated asynchronously. At this point, the identifier and type can no longer be changed.</source>
          <target state="translated">&lt;a href=&quot;qml-qtpurchasing-product#identifier-prop&quot;&gt;識別子&lt;/a&gt;とタイプの両方が設定されている場合、製品は外部市場から照会され、その他のプロパティは非同期で更新されます。この時点で、識別子とタイプは変更できなくなります。</target>
        </trans-unit>
        <trans-unit id="e66ead871376ec31f6b0bdabc0d22f6168fd30da" translate="yes" xml:space="preserve">
          <source>When both the identifier and &lt;a href=&quot;qml-qtpurchasing-product#type-prop&quot;&gt;type&lt;/a&gt; is set, the product is queried from the external market place, and its other properties are updated asynchronously. At this point, the identifier and type can no longer be changed.</source>
          <target state="translated">識別子と&lt;a href=&quot;qml-qtpurchasing-product#type-prop&quot;&gt;タイプの&lt;/a&gt;両方が設定されている場合、製品は外部市場から照会され、その他のプロパティは非同期で更新されます。この時点で、識別子とタイプは変更できなくなります。</target>
        </trans-unit>
        <trans-unit id="a77db60a6597f85a3430717a9225f81f9e8efd43" translate="yes" xml:space="preserve">
          <source>When building Qt from source, the configuration system checks for the presence of the &lt;code&gt;openssl/opensslv.h&lt;/code&gt; header provided by source or developer packages of OpenSSL.</source>
          <target state="translated">ソースからQtをビルドするとき、構成システムは、OpenSSLのソースまたは開発者パッケージによって提供される &lt;code&gt;openssl/opensslv.h&lt;/code&gt; ヘッダーの存在を確認します。</target>
        </trans-unit>
        <trans-unit id="481f920a35be00bb71b2fc213b17ba321c9ce91c" translate="yes" xml:space="preserve">
          <source>When building a list or a tree that has only one column, this function provides a convenient way to append a single new</source>
          <target state="translated">列しかないリストやツリーを作成する際に、この関数を使用すると、新しい</target>
        </trans-unit>
        <trans-unit id="f4d252c2c2fbed789c886d3ea6d5aac266ab2c26" translate="yes" xml:space="preserve">
          <source>When building a list or a tree that has only one column, this function provides a convenient way to append a single new item.</source>
          <target state="translated">列しかないリストやツリーを作成する場合、この関数は新しい項目を一つ追加する便利な方法を提供します。</target>
        </trans-unit>
        <trans-unit id="c2ec3d7c6f7c3543ad312c99f702307e4ac89f3b" translate="yes" xml:space="preserve">
          <source>When building a list or a tree that has only one column, this function provides a convenient way to insert a single new item.</source>
          <target state="translated">1列しかないリストやツリーを作成する場合、この関数は1つの新しい項目を挿入する便利な方法を提供します。</target>
        </trans-unit>
        <trans-unit id="c58a8be8048f77481eaaa01a5f80fa127a65c9b2" translate="yes" xml:space="preserve">
          <source>When building a version of Qt linked against OpenSSL, Qt's build system will use CMake's &lt;code&gt;FindOpenSSL&lt;/code&gt; command to find OpenSSL in several standard locations. You can set the CMake variable OPENSSL_ROOT_DIR to force a specific location.</source>
          <target state="translated">OpenSSLに対してリンクされたバージョンのQtをビルドする場合、QtのビルドシステムはCMakeの &lt;code&gt;FindOpenSSL&lt;/code&gt; コマンドを使用して、いくつかの標準的な場所でOpenSSLを検索します。CMake変数OPENSSL_ROOT_DIRを設定して、特定の場所を強制することができます。</target>
        </trans-unit>
        <trans-unit id="6c09737d74d2162e6fdbbf52bfd0b26549723d50" translate="yes" xml:space="preserve">
          <source>When building a version of Qt linked against OpenSSL, the build system will attempt to link with libssl and libcrypt libraries located in the default location on the developer's system. This location is configurable: set the &lt;code&gt;OPENSSL_LIBS&lt;/code&gt; environment variable to contain the linker options required to link Qt against the installed library. For example, on a Unix/Linux system:</source>
          <target state="translated">OpenSSLにリンクされたQtのバージョンをビルドする場合、ビルドシステムは、開発者のシステムのデフォルトの場所にあるlibsslおよびlibcryptライブラリとリンクしようとします。この場所は構成可能です。インストールされているライブラリに対してQtをリンクするために必要なリンカーオプションを含むように &lt;code&gt;OPENSSL_LIBS&lt;/code&gt; 環境変数を設定します。たとえば、Unix / Linuxシステムの場合：</target>
        </trans-unit>
        <trans-unit id="c9861e5ecd8580ac9329bf8a380f56f7c6afce34" translate="yes" xml:space="preserve">
          <source>When building from source, ensure that the</source>
          <target state="translated">ソースからビルドする場合は</target>
        </trans-unit>
        <trans-unit id="62819592f1c6df3a87bed54e97d13fd158256db9" translate="yes" xml:space="preserve">
          <source>When building from source, ensure that the &lt;a href=&quot;qtgraphicaleffects-index&quot;&gt;Qt Graphical Effects&lt;/a&gt; module is also built, as Qt Quick Controls 2 requires it.</source>
          <target state="translated">ソースからビルドする場合は、Qt Quick Controls 2で必要になるため、&lt;a href=&quot;qtgraphicaleffects-index&quot;&gt;Qt Graphical Effects&lt;/a&gt;モジュールもビルドされていることを確認してください。</target>
        </trans-unit>
        <trans-unit id="d0d5ad78ee0d3c591ef53c8a838b7b5e7736a74d" translate="yes" xml:space="preserve">
          <source>When building from source, ensure that the &lt;a href=&quot;qtgraphicaleffects-index&quot;&gt;Qt Graphical Effects&lt;/a&gt; module is also built, as Qt Quick Controls requires it.</source>
          <target state="translated">ソースからビルドする場合は、Qt Quick Controlsで必要とされるため、&lt;a href=&quot;qtgraphicaleffects-index&quot;&gt;Qt GraphicalEffects&lt;/a&gt;モジュールもビルドされていることを確認してください。</target>
        </trans-unit>
        <trans-unit id="7dbc1546897b44a424c69bc67e3cb704ad96c53a" translate="yes" xml:space="preserve">
          <source>When building from source, ensure that the modules and tools from the</source>
          <target state="translated">ソースからビルドする場合、モジュールとツールが</target>
        </trans-unit>
        <trans-unit id="7251f805a1544f17a9559e9785d85be1aae09528" translate="yes" xml:space="preserve">
          <source>When building user interfaces with the &lt;a href=&quot;qtquick-index&quot;&gt;Qt Quick&lt;/a&gt; module, all QML objects that are to be visually rendered must derive from the &lt;a href=&quot;qml-qtquick-item&quot;&gt;Item&lt;/a&gt; type, as it is the base type for all visual objects in &lt;a href=&quot;qtquick-index&quot;&gt;Qt Quick&lt;/a&gt;. This &lt;a href=&quot;qml-qtquick-item&quot;&gt;Item&lt;/a&gt; type is implemented by the &lt;a href=&quot;qquickitem&quot;&gt;QQuickItem&lt;/a&gt; C++ class, which is provided by the &lt;a href=&quot;qtquick-index&quot;&gt;Qt Quick&lt;/a&gt; module. Therefore, this class should be subclassed when it is necessary to implement a visual type in C++ that can be integrated into a QML-based user interface.</source>
          <target state="translated">&lt;a href=&quot;qtquick-index&quot;&gt;Qt Quick&lt;/a&gt;モジュールでユーザーインターフェースを構築する場合、視覚的にレンダリングされるすべてのQMLオブジェクトは、&lt;a href=&quot;qtquick-index&quot;&gt;Qt Quickの&lt;/a&gt;すべての視覚オブジェクトの基本型であるため、&lt;a href=&quot;qml-qtquick-item&quot;&gt;項目&lt;/a&gt;タイプから派生する必要があります。この&lt;a href=&quot;qml-qtquick-item&quot;&gt;項目&lt;/a&gt;タイプは、&lt;a href=&quot;qtquick-index&quot;&gt;Qt Quick&lt;/a&gt;モジュールによって提供される&lt;a href=&quot;qquickitem&quot;&gt;QQuickItem&lt;/a&gt; C ++クラスによって実装されます。したがって、QMLベースのユーザーインターフェイスに統合できるビジュアルタイプをC ++で実装する必要がある場合は、このクラスをサブクラス化する必要があります。</target>
        </trans-unit>
        <trans-unit id="573536b41f02e737bb17c87ec630c4949eebe25a" translate="yes" xml:space="preserve">
          <source>When built, the Qt Image Formats plugins are located as dynamic libraries in the runtime plugin directory (typically &lt;code&gt;plugins/imageformats&lt;/code&gt;), together with the default image format plugins. They may be deployed to the target system in the same way as other plugins, see the &lt;a href=&quot;https://doc.qt.io/qt-5.13/deployment-plugins.html&quot;&gt;Deploying Plugins&lt;/a&gt; documentation.</source>
          <target state="translated">ビルドすると、Qt Image Formatsプラグインは、デフォルトの画像フォーマットプラグインとともに、ランタイムプラグインディレクトリ（通常は &lt;code&gt;plugins/imageformats&lt;/code&gt; ）の動的ライブラリとして配置されます。他のプラグインと同じ方法でターゲットシステムに&lt;a href=&quot;https://doc.qt.io/qt-5.13/deployment-plugins.html&quot;&gt;デプロイでき&lt;/a&gt;ます。プラグインのデプロイのドキュメントをご覧ください。</target>
        </trans-unit>
        <trans-unit id="1e398ca745e5b7e0d76604dae601be679e6ea3ec" translate="yes" xml:space="preserve">
          <source>When built, the Qt Image Formats plugins are located as dynamic libraries in the runtime plugin directory (typically &lt;code&gt;plugins/imageformats&lt;/code&gt;), together with the default image format plugins. They may be deployed to the target system in the same way as other plugins, see the &lt;a href=&quot;https://doc.qt.io/qt-5.15/deployment-plugins.html&quot;&gt;Deploying Plugins&lt;/a&gt; documentation.</source>
          <target state="translated">ビルドされると、Qt Image Formatsプラグインは、デフォルトの画像形式プラグインとともに、ランタイムプラグインディレクトリ（通常は &lt;code&gt;plugins/imageformats&lt;/code&gt; ）にダイナミックライブラリとして配置されます。これらは、他のプラグインと同じ方法でターゲットシステムに&lt;a href=&quot;https://doc.qt.io/qt-5.15/deployment-plugins.html&quot;&gt;デプロイでき&lt;/a&gt;ます。プラグインのデプロイのドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="c262fdab9d5bbc4800f05d4b19c4606922c93521" translate="yes" xml:space="preserve">
          <source>When built, the Qt Image Formats plugins are located as dynamic libraries in the runtime plugin directory (typically &lt;code&gt;plugins/imageformats&lt;/code&gt;), together with the default image format plugins. They may be deployed to the target system in the same way as other plugins, see the &lt;a href=&quot;https://doc.qt.io/qt-6.0/deployment-plugins.html&quot;&gt;Deploying Plugins&lt;/a&gt; documentation.</source>
          <target state="translated">ビルドされると、Qt Image Formatsプラグインは、デフォルトの画像形式プラグインとともに、ランタイムプラグインディレクトリ（通常は &lt;code&gt;plugins/imageformats&lt;/code&gt; ）にダイナミックライブラリとして配置されます。これらは、他のプラグインと同じ方法でターゲットシステムに&lt;a href=&quot;https://doc.qt.io/qt-6.0/deployment-plugins.html&quot;&gt;デプロイでき&lt;/a&gt;ます。プラグインのデプロイのドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="85c65eea35b46ad9adc8aa9df7e19d248494566d" translate="yes" xml:space="preserve">
          <source>When caching is enabled, &lt;a href=&quot;qfileinfo&quot;&gt;QFileInfo&lt;/a&gt; reads the file information from the file system the first time it's needed, but generally not later.</source>
          <target state="translated">キャッシュが有効になっている場合、&lt;a href=&quot;qfileinfo&quot;&gt;QFileInfo&lt;/a&gt;は最初に必要になったときにファイルシステムからファイル情報を読み取りますが、通常は後でありません。</target>
        </trans-unit>
        <trans-unit id="63f929311e0c136280261b1674d609c45952f607" translate="yes" xml:space="preserve">
          <source>When caching is enabled, an item's &lt;a href=&quot;qgraphicsitem#paint&quot;&gt;paint&lt;/a&gt;() function will generally draw into an offscreen pixmap cache; for any subsequent repaint requests, the Graphics View framework will redraw from the cache. This approach works particularly well with QGLWidget, which stores all the cache as OpenGL textures.</source>
          <target state="translated">キャッシュが有効な場合、アイテムの&lt;a href=&quot;qgraphicsitem#paint&quot;&gt;paint&lt;/a&gt;（）関数は、通常、オフスクリーンのピックスマップキャッシュに描画します。後続の再描画要求の場合、グラフィックスビューフレームワークはキャッシュから再描画します。このアプローチは、すべてのキャッシュをOpenGLテクスチャとして保存するQGLWidgetで特にうまく機能します。</target>
        </trans-unit>
        <trans-unit id="49d3402980e692757da4d25c7f056cfbcbc4090c" translate="yes" xml:space="preserve">
          <source>When calculating the size hint, &lt;a href=&quot;qgroupbox&quot;&gt;QGroupBox&lt;/a&gt; fetches three pixel metrics from the style: &lt;code&gt;PM_IndicatorWidth&lt;/code&gt;, &lt;code&gt;PM_CheckBoxLabelSpacing&lt;/code&gt;, and &lt;code&gt;PM_IndicatorHeight&lt;/code&gt;. &lt;a href=&quot;qgroupbox&quot;&gt;QGroupBox&lt;/a&gt; has the following style element tree:</source>
          <target state="translated">サイズのヒントを計算するとき、&lt;a href=&quot;qgroupbox&quot;&gt;QGroupBox&lt;/a&gt;はスタイルから3つのピクセルメトリック（ &lt;code&gt;PM_IndicatorWidth&lt;/code&gt; 、 &lt;code&gt;PM_CheckBoxLabelSpacing&lt;/code&gt; 、および &lt;code&gt;PM_IndicatorHeight&lt;/code&gt; ）をフェッチします。&lt;a href=&quot;qgroupbox&quot;&gt;QGroupBox&lt;/a&gt;には次のスタイル要素ツリーがあります。</target>
        </trans-unit>
        <trans-unit id="21b955b352a198452eb600dee09c98ed26feb22d" translate="yes" xml:space="preserve">
          <source>When calculating the slider's size hint, &lt;code&gt;PM_SliderThickness&lt;/code&gt; and &lt;code&gt;PM_SliderLength&lt;/code&gt; are queried from the style. As with scroll bars, the &lt;a href=&quot;qslider&quot;&gt;QSlider&lt;/a&gt; only lets the user move the handle if the mouse is within &lt;code&gt;PM_MaximumDragDistance&lt;/code&gt; from the slider bounds. When it draws itself, it creates the style option and calls &lt;code&gt;drawComplexControl()&lt;/code&gt; with &lt;code&gt;CC_Slider&lt;/code&gt;:</source>
          <target state="translated">スライダーのサイズのヒントを計算するとき、 &lt;code&gt;PM_SliderThickness&lt;/code&gt; と &lt;code&gt;PM_SliderLength&lt;/code&gt; がスタイルから照会されます。スクロールバーと同様に、&lt;a href=&quot;qslider&quot;&gt;QSlider&lt;/a&gt;では、マウスがスライダーの境界から &lt;code&gt;PM_MaximumDragDistance&lt;/code&gt; 内にある場合にのみ、ユーザーがハンドルを移動できます。自分自身を描画するときは、スタイルオプションを作成し、 &lt;code&gt;drawComplexControl()&lt;/code&gt; を &lt;code&gt;CC_Slider&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="1d40ba7fa0fde8f8ba84bf5f3be3928589a792a0" translate="yes" xml:space="preserve">
          <source>When called as a constructor, a new instance of the class will be created. Only constructors exposed by &lt;a href=&quot;qobject#Q_INVOKABLE&quot;&gt;Q_INVOKABLE&lt;/a&gt; will be visible from the script engine.</source>
          <target state="translated">コンストラクターとして呼び出されると、クラスの新しいインスタンスが作成されます。&lt;a href=&quot;qobject#Q_INVOKABLE&quot;&gt;Q_INVOKABLE&lt;/a&gt;によって公開されるコンストラクターのみがスクリプトエンジンから表示されます。</target>
        </trans-unit>
        <trans-unit id="1a17521f28b13cf15c64f48b6b71bf71a004d243" translate="yes" xml:space="preserve">
          <source>When called by Qt,</source>
          <target state="translated">Qtで呼び出された場合。</target>
        </trans-unit>
        <trans-unit id="f924cfbead8cb8e42622d4f7e73c2c8531c825b9" translate="yes" xml:space="preserve">
          <source>When calling &lt;a href=&quot;qquickwindow#releaseResources&quot;&gt;releaseResources&lt;/a&gt;(), or when the window gets hidden (more specifically, not renderable), some render loops have the possibility to release all, not just the cached, graphics resources. This can free up memory temporarily, but it also means the rendering engine will have to do a full, potentially costly reinitialization of the resources when the window needs to render again.</source>
          <target state="translated">&lt;a href=&quot;qquickwindow#releaseResources&quot;&gt;releaseResources&lt;/a&gt;（）を呼び出すとき、またはウィンドウが非表示になると（より具体的には、レンダリングできなくなります）、一部のレンダリングループでは、キャッシュされたグラフィックリソースだけでなく、すべてを解放する可能性があります。これにより、メモリが一時的に解放される可能性がありますが、ウィンドウを再度レンダリングする必要がある場合は、レンダリングエンジンがリソースを完全に再初期化する必要があり、コストがかかる可能性があります。</target>
        </trans-unit>
        <trans-unit id="1f97347d6c83c0d6afe15b4ae0af8fee46e568aa" translate="yes" xml:space="preserve">
          <source>When calling &lt;a href=&quot;qquickwindow#releaseResources&quot;&gt;releaseResources&lt;/a&gt;(), when the window gets hidden (more specifically, not renderable), some render loops have the possibility to release the scene graph nodes and related graphics resources. This frees up memory temporarily, but will also mean the scene graph has to be rebuilt when the window renders next time.</source>
          <target state="translated">&lt;a href=&quot;qquickwindow#releaseResources&quot;&gt;releaseResources&lt;/a&gt;（）を呼び出すときに、ウィンドウが非表示になると（より具体的には、レンダリングできなくなります）、一部のレンダリングループでは、シーングラフノードと関連するグラフィックリソースを解放する可能性があります。これにより、メモリが一時的に解放されますが、次回ウィンドウがレンダリングされるときにシーングラフを再構築する必要があることも意味します。</target>
        </trans-unit>
        <trans-unit id="914ad22810e57e0a208c0b39ab77807e77834ddd" translate="yes" xml:space="preserve">
          <source>When calling Java functions that might throw an exception, it is important that you check, handle and clear out the exception before continuing.</source>
          <target state="translated">例外が発生する可能性のあるJava関数を呼び出す際には、例外をチェックし、処理し、クリアしてから続行することが重要です。</target>
        </trans-unit>
        <trans-unit id="2a2e7ae65f87e90c76479fdc5ff2e4326b27c302" translate="yes" xml:space="preserve">
          <source>When calling this function, you can use the &lt;code&gt;SIGNAL()&lt;/code&gt; macro to pass a specific signal:</source>
          <target state="translated">この関数を呼び出すときに、 &lt;code&gt;SIGNAL()&lt;/code&gt; マクロを使用して特定のシグナルを渡すことができます。</target>
        </trans-unit>
        <trans-unit id="16fd68ecc7c1ca2e0fddbce432b5a471d518bb57" translate="yes" xml:space="preserve">
          <source>When changing properties with values that may be defined within a resource file,</source>
          <target state="translated">リソースファイル内で定義されている可能性のある値を持つプロパティを変更する場合。</target>
        </trans-unit>
        <trans-unit id="10172d955b561d851a1e685787b7d1f3cc20d57f" translate="yes" xml:space="preserve">
          <source>When changing the geometry, the widget, if visible, receives a move event (&lt;a href=&quot;qwidget#moveEvent&quot;&gt;moveEvent&lt;/a&gt;()) and/or a resize event (&lt;a href=&quot;qwidget#resizeEvent&quot;&gt;resizeEvent&lt;/a&gt;()) immediately. If the widget is not currently visible, it is guaranteed to receive appropriate events before it is shown.</source>
          <target state="translated">ジオメトリを変更すると、ウィジェットは、表示されている場合、移動イベント（&lt;a href=&quot;qwidget#moveEvent&quot;&gt;moveEvent&lt;/a&gt;（））またはサイズ変更イベント（&lt;a href=&quot;qwidget#resizeEvent&quot;&gt;resizeEvent&lt;/a&gt;（））を即座に受け取ります。ウィジェットが現在表示されていない場合は、表示される前に適切なイベントを受け取ることが保証されています。</target>
        </trans-unit>
        <trans-unit id="3dcc6167c4c8ec1a522615dcd2a97bfd046a2f80" translate="yes" xml:space="preserve">
          <source>When changing the position, the widget, if visible, receives a move event (&lt;a href=&quot;qwidget#moveEvent&quot;&gt;moveEvent&lt;/a&gt;()) immediately. If the widget is not currently visible, it is guaranteed to receive an event before it is shown.</source>
          <target state="translated">位置を変更すると、ウィジェットは、表示されている場合、移動イベント（&lt;a href=&quot;qwidget#moveEvent&quot;&gt;moveEvent&lt;/a&gt;（））をすぐに受け取ります。ウィジェットが現在表示されていない場合は、表示される前にイベントを受け取ることが保証されています。</target>
        </trans-unit>
        <trans-unit id="d10e878de0de661440ee8d64ce4885521ddfa38a" translate="yes" xml:space="preserve">
          <source>When checking the signatures of its arguments, &lt;a href=&quot;qobject#connect&quot;&gt;QObject::connect&lt;/a&gt;() compares the data types literally. Thus, &lt;a href=&quot;qt#AlignmentFlag-enum&quot;&gt;Alignment&lt;/a&gt; and &lt;a href=&quot;qt#AlignmentFlag-enum&quot;&gt;Qt::Alignment&lt;/a&gt; are treated as two distinct types. To work around this limitation, make sure to fully qualify the data types when declaring signals and slots, and when establishing connections. For example:</source>
          <target state="translated">引数の署名をチェックするとき、&lt;a href=&quot;qobject#connect&quot;&gt;QObject :: connect&lt;/a&gt;（）はデータ型を文字通り比較します。したがって、&lt;a href=&quot;qt#AlignmentFlag-enum&quot;&gt;Alignment&lt;/a&gt;と&lt;a href=&quot;qt#AlignmentFlag-enum&quot;&gt;Qt :: Alignment&lt;/a&gt;は2つの異なる型として扱われます。この制限を回避するには、信号とスロットを宣言するとき、および接続を確立するときに、データ型を完全に修飾してください。例えば：</target>
        </trans-unit>
        <trans-unit id="6c76cad238f22ed5e500ffc1b09ea0553c302ab3" translate="yes" xml:space="preserve">
          <source>When choosing a widget to use as a placeholder, it is useful to compare the API of the missing widget with those of standard Qt widgets. For specialized widgets that subclass standard classes, the obvious choice of placeholder is the base class of the custom widget; for example, &lt;a href=&quot;qslider&quot;&gt;QSlider&lt;/a&gt; might be used for specialized &lt;a href=&quot;qslider&quot;&gt;QSlider&lt;/a&gt; subclasses.</source>
          <target state="translated">プレースホルダーとして使用するウィジェットを選択する場合、欠落しているウィジェットのAPIを標準のQtウィジェットのAPIと比較すると便利です。標準クラスをサブクラス化する特殊なウィジェットの場合、プレースホルダーの明らかな選択は、カスタムウィジェットの基本クラスです。たとえば、&lt;a href=&quot;qslider&quot;&gt;QSlider&lt;/a&gt;は特殊な&lt;a href=&quot;qslider&quot;&gt;QSlider&lt;/a&gt;サブクラスに使用できます。</target>
        </trans-unit>
        <trans-unit id="16d44be4536ee05b1e19ae36cfa871d577dd74c9" translate="yes" xml:space="preserve">
          <source>When client code handling the &lt;a href=&quot;qnetworkreply#redirected&quot;&gt;redirected&lt;/a&gt;() signal has verified the new URL, it emits this signal to allow the redirect to go ahead. This protocol applies to network requests whose redirects policy is set to &lt;a href=&quot;qnetworkrequest#RedirectPolicy-enum&quot;&gt;QNetworkRequest::UserVerifiedRedirectPolicy&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;qnetworkreply#redirected&quot;&gt;リダイレクトされた&lt;/a&gt;（）シグナルを処理するクライアントコードが新しいURLを確認すると、リダイレクトを進めるためにこのシグナルを発行します。このプロトコルは、リダイレクトポリシーが&lt;a href=&quot;qnetworkrequest#RedirectPolicy-enum&quot;&gt;QNetworkRequest :: UserVerifiedRedirectPolicyに&lt;/a&gt;設定されているネットワークリクエストに適用されます。</target>
        </trans-unit>
        <trans-unit id="a496bd66ef281f3e102e4c15780975eb23b209d8" translate="yes" xml:space="preserve">
          <source>When combined with Subdirectories, this flag enables iterating through all subdirectories of the assigned path, following all symbolic links. Symbolic link loops (e.g., &quot;link&quot; =&amp;gt; &quot;.&quot; or &quot;link&quot; =&amp;gt; &quot;..&quot;) are automatically detected and ignored.</source>
          <target state="translated">このフラグをサブディレクトリと組み合わせると、すべてのシンボリックリンクをたどって、割り当てられたパスのすべてのサブディレクトリを反復できます。シンボリックリンクループ（たとえば、 &quot;link&quot; =&amp;gt; &quot;。&quot;または &quot;link&quot; =&amp;gt; &quot;..&quot;）は自動的に検出され、無視されます。</target>
        </trans-unit>
        <trans-unit id="b152fe7b18bfb7ca1bd752cf950491f1cf2f642f" translate="yes" xml:space="preserve">
          <source>When communicating over a bus, applications obtain what is called a &quot;service name&quot;: it is how that application chooses to be known by other applications on the same bus. The service names are brokered by the D-Bus bus daemon and are used to route messages from one application to another. An analogous concept to service names are IP addresses and hostnames: a computer normally has one IP address and may have one or more hostnames associated with it, according to the services that it provides to the network.</source>
          <target state="translated">バス上で通信するとき、アプリケーションは「サービス名」と呼ばれるものを取得します。サービス名はD-Busバスデーモンによって仲介され、あるアプリケーションから別のアプリケーションへのメッセージのルーティングに使用されます。サービス名に類似した概念にIPアドレスとホスト名があります。コンピュータは通常1つのIPアドレスを持ち、ネットワークに提供するサービスに応じて1つ以上のホスト名を持つことがあります。</target>
        </trans-unit>
        <trans-unit id="2fa846a6fbf1d2acbf9baf6b25678819c4fcf27a" translate="yes" xml:space="preserve">
          <source>When compared to Qt Quick's 2D &lt;a href=&quot;qml-qtquick-shadereffect&quot;&gt;ShaderEffect&lt;/a&gt;, the 3D post-processing effects have the advantage of being able to work with depth buffer data, as well as the ability to implement multiple passes with intermediate buffers. In addition, the texture-related capabilities are extended: Qt Quick 3D allows more fine-grained control over filtering modes, and allows effects to work with texture formats other than RGBA8, for example, floating point formats.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-shadereffect&quot;&gt;QtQuickの2DShaderEffect&lt;/a&gt;と比較すると、3D後処理効果には、深度バッファーデータを処理できるという利点と、中間バッファーを使用して複数のパスを実装できるという利点があります。さらに、テクスチャ関連の機能が拡張されています。QtQuick3Dを使用すると、フィルタリングモードをよりきめ細かく制御でき、浮動小数点形式など、RGBA8以外のテクスチャ形式でエフェクトを操作できます。</target>
        </trans-unit>
        <trans-unit id="126be04937319506b64a5a64cc708426b1cfcb4c" translate="yes" xml:space="preserve">
          <source>When comparing &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt;, arrays and initializer lists of the value type can be passed as expected value:</source>
          <target state="translated">&lt;a href=&quot;qlist&quot;&gt;QListを&lt;/a&gt;比較する場合、値型の配列と初期化子リストを期待値として渡すことができます。</target>
        </trans-unit>
        <trans-unit id="504bd4b97e16da478eebaa7d208820d715529e5e" translate="yes" xml:space="preserve">
          <source>When comparing floating-point types (&lt;code&gt;float&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, and &lt;code&gt;qfloat16&lt;/code&gt;), &lt;a href=&quot;qtglobal#qFuzzyCompare&quot;&gt;qFuzzyCompare&lt;/a&gt;() is used for finite values. If &lt;a href=&quot;qtglobal#qFuzzyIsNull&quot;&gt;qFuzzyIsNull&lt;/a&gt;() is true for both values, they are also considered equal. Infinities match if they have the same sign, and any NaN as actual value matches with any NaN as expected value (even though NaN != NaN, even when they're identical).</source>
          <target state="translated">浮動小数点型（ &lt;code&gt;float&lt;/code&gt; 、 &lt;code&gt;double&lt;/code&gt; 、および &lt;code&gt;qfloat16&lt;/code&gt; ）を比較する場合、有限値には&lt;a href=&quot;qtglobal#qFuzzyCompare&quot;&gt;qFuzzyCompare&lt;/a&gt;（）が使用されます。場合&lt;a href=&quot;qtglobal#qFuzzyIsNull&quot;&gt;qFuzzyIsNullは&lt;/a&gt;（）両方の値について真である、彼らも等しいと見なされます。無限大は、それらが同じ符号を持っている場合に一致し、実際の値としての任意のNaNは、期待値としての任意のNaNと一致します（NaN！= NaNであっても、それらが同一であっても）。</target>
        </trans-unit>
        <trans-unit id="4ae6fe5944e7f5e553d8111bc79c5d3e6ba7dace" translate="yes" xml:space="preserve">
          <source>When complete is &lt;code&gt;true&lt;/code&gt;, any interactive items declared in &lt;code&gt;left&lt;/code&gt;, &lt;code&gt;right&lt;/code&gt;, or &lt;code&gt;behind&lt;/code&gt; will receive mouse events.</source>
          <target state="translated">completeが &lt;code&gt;true&lt;/code&gt; の場合、 &lt;code&gt;left&lt;/code&gt; 、 &lt;code&gt;right&lt;/code&gt; 、または &lt;code&gt;behind&lt;/code&gt; で宣言されたインタラクティブアイテムはすべてマウスイベントを受け取ります。</target>
        </trans-unit>
        <trans-unit id="976e1921ad1ea5927a3b8bbd6237c76e52f7d321" translate="yes" xml:space="preserve">
          <source>When configured with &lt;code&gt;-opengl dynamic&lt;/code&gt;, neither Qt nor the applications built using &lt;code&gt;qmake&lt;/code&gt; or &lt;code&gt;CMake&lt;/code&gt; will link to opengl32.lib. Instead, the library is chosen and loaded at runtime. By default, Qt will determine whether the system's opengl32.dll provides OpenGL 2 functions. If these are present, opengl32.dll is used, otherwise it attempts to load &lt;code&gt;opengl32sw.dll&lt;/code&gt;. See below for details.</source>
          <target state="translated">&lt;code&gt;-opengl dynamic&lt;/code&gt; で構成されている場合、Qtも &lt;code&gt;qmake&lt;/code&gt; または &lt;code&gt;CMake&lt;/code&gt; を使用して構築されたアプリケーションもopengl32.libにリンクしません。代わりに、ライブラリが選択され、実行時にロードされます。デフォルトでは、Qtはシステムのopengl32.dllがOpenGL2機能を提供するかどうかを決定します。これらが存在する場合はopengl32.dllが使用され、存在しない場合は &lt;code&gt;opengl32sw.dll&lt;/code&gt; を読み込もうとします。詳細については、以下を参照してください。</target>
        </trans-unit>
        <trans-unit id="fbdde588f2333734eac7dbf667c998b588ec285f" translate="yes" xml:space="preserve">
          <source>When configured with &lt;code&gt;-opengl dynamic&lt;/code&gt;, neither Qt nor the applications built using &lt;code&gt;qmake&lt;/code&gt; will link to the opengl32 (standard desktop OpenGL) or QtANGLE libraries. Instead, the appropriate library is chosen at runtime. By default, Qt will determine whether the system's opengl32.dll provides OpenGL 2 functions. If these are present, opengl32.dll is used, otherwise the ANGLE libraries (libEGL.dll and libGLESv2.dll) will be used. In case the ANGLE libraries are missing or initialization fails for some reason, an additional fallback is attempted by trying to load &lt;code&gt;opengl32sw.dll&lt;/code&gt;. See below for details.</source>
          <target state="translated">&lt;code&gt;-opengl dynamic&lt;/code&gt; で構成されている場合、Qtも &lt;code&gt;qmake&lt;/code&gt; を使用して構築されたアプリケーションも、opengl32（標準デスクトップOpenGL）またはQtANGLEライブラリにリンクしません。代わりに、実行時に適切なライブラリが選択されます。デフォルトでは、Qtはシステムのopengl32.dllがOpenGL2機能を提供するかどうかを決定します。これらが存在する場合はopengl32.dllが使用され、存在しない場合はANGLEライブラリ（libEGL.dllおよびlibGLESv2.dll）が使用されます。 ANGLEライブラリが見つからないか、何らかの理由で初期化が失敗した場合、 &lt;code&gt;opengl32sw.dll&lt;/code&gt; をロードしようとして、追加のフォールバックが試行されます。詳細については、以下を参照してください。</target>
        </trans-unit>
        <trans-unit id="c83d34a16b202ede327779ea8f89700f458b6d2a" translate="yes" xml:space="preserve">
          <source>When configuring, you can select a CMake generator. Note that CMake supports generators that cannot be used with Qt. Therefore, configure automatically selects a generator for you.</source>
          <target state="translated">設定時に、CMake ジェネレータを選択することができます。CMake は Qt で使用できないジェネレータをサポートしていることに注意してください。そのため、configure は自動的にジェネレータを選択します。</target>
        </trans-unit>
        <trans-unit id="1731f47b651e66fd70df77e065cbada56a586326" translate="yes" xml:space="preserve">
          <source>When conflicts arise, the widget's own style sheet is always preferred to any inherited style sheet, irrespective of the specificity of the conflicting rules. Likewise, the parent widget's style sheet is preferred to the grandparent's, etc.</source>
          <target state="translated">競合が発生した場合、競合するルールの特定性に関係なく、ウィジェット自身のスタイルシートは継承されたスタイルシートよりも常に優先されます。同様に、親ウィジェットのスタイルシートは祖父母のスタイルシートよりも優先されます。</target>
        </trans-unit>
        <trans-unit id="0ee6235e959f1c122804e1ee8f220bac499a0e14" translate="yes" xml:space="preserve">
          <source>When connecting to an ODBC datasource, you should pass the name of the ODBC datasource to the &lt;a href=&quot;qsqldatabase#setDatabaseName&quot;&gt;QSqlDatabase::setDatabaseName&lt;/a&gt;() function, rather than the actual database name.</source>
          <target state="translated">ODBCデータソースに接続するときは、実際のデータベース名ではなく、ODBCデータソースの名前を&lt;a href=&quot;qsqldatabase#setDatabaseName&quot;&gt;QSqlDatabase :: setDatabaseName&lt;/a&gt;（）関数に渡す必要があります。</target>
        </trans-unit>
        <trans-unit id="2f2cbe1c8aedff9ebebfb5ee6584df1a788d8183" translate="yes" xml:space="preserve">
          <source>When connecting to signals in QML, the usual way is to create an &quot;on&amp;lt;Signal&amp;gt;&quot; handler that reacts when a signal is received, like this:</source>
          <target state="translated">QMLの信号に接続する場合、通常の方法は、次のように、信号を受信したときに反応する「on &amp;lt;Signal&amp;gt;」ハンドラーを作成することです。</target>
        </trans-unit>
        <trans-unit id="50ad6900d430167293c28de8c15b55b92afdb96d" translate="yes" xml:space="preserve">
          <source>When considering the above example, there are several parties involved:</source>
          <target state="translated">上記の例を考えると、いくつかの当事者が存在します。</target>
        </trans-unit>
        <trans-unit id="1f8be66302822ad43cb41370fe8ce296df9c5d56" translate="yes" xml:space="preserve">
          <source>When constructing and showing a &lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow&lt;/a&gt; that uses Vulkan to render, a Vulkan instance (&lt;code&gt;VkInstance&lt;/code&gt;), a physical device (&lt;code&gt;VkPhysicalDevice&lt;/code&gt;), a device (&lt;code&gt;VkDevice&lt;/code&gt;) and associated objects (queues, pools) are initialized through the Vulkan API. The same is mostly true when using &lt;a href=&quot;qquickrendercontrol&quot;&gt;QQuickRenderControl&lt;/a&gt; to redirect the rendering into a custom render target, such as a texture. While &lt;a href=&quot;qvulkaninstance&quot;&gt;QVulkanInstance&lt;/a&gt; construction is under the application's control then, the initialization of other graphics objects happen the same way in &lt;a href=&quot;qquickrendercontrol#initialize&quot;&gt;QQuickRenderControl::initialize&lt;/a&gt;() as with an on-screen &lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow&lt;/a&gt;.</source>
          <target state="translated">Vulkanを使用してレンダリングする&lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow&lt;/a&gt;を構築して表示する場合、Vulkanインスタンス（ &lt;code&gt;VkInstance&lt;/code&gt; ）、物理デバイス（ &lt;code&gt;VkPhysicalDevice&lt;/code&gt; ）、デバイス（ &lt;code&gt;VkDevice&lt;/code&gt; ）、および関連するオブジェクト（キュー、プール）はVulkanAPIを介して初期化されます。&lt;a href=&quot;qquickrendercontrol&quot;&gt;QQuickRenderControl&lt;/a&gt;を使用してレンダリングをテクスチャなどのカスタムレンダーターゲットにリダイレクトする場合も、ほとんど同じことが言えます。ながら&lt;a href=&quot;qvulkaninstance&quot;&gt;QVulkanInstanceの&lt;/a&gt;構造は、アプリケーションの制御下にある、他のグラフィックスオブジェクトの初期化中に同様起こる&lt;a href=&quot;qquickrendercontrol#initialize&quot;&gt;QQuickRenderControlを::初期化&lt;/a&gt;（）画面上と同様&lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="490cc9bd30b6bceb26457d2a8efbb90a6b3f5fe5" translate="yes" xml:space="preserve">
          <source>When control returns to the main event loop, all events that are stored in the queue will be sent using the &lt;a href=&quot;qcoreapplication#notify&quot;&gt;notify&lt;/a&gt;() function.</source>
          <target state="translated">制御がメインイベントループに戻ると、キューに格納されているすべてのイベントは、&lt;a href=&quot;qcoreapplication#notify&quot;&gt;notify&lt;/a&gt;（）関数を使用して送信されます。</target>
        </trans-unit>
        <trans-unit id="e0b92b7bfb7f8d04dcfbfbb18f560acc8b93fd1f" translate="yes" xml:space="preserve">
          <source>When converting from a &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; to an output encoding, write a &lt;a href=&quot;qchar#SpecialCharacter-enum&quot;&gt;QChar::ByteOrderMark&lt;/a&gt; as the first character if the output encoding supports this. This is the case for UTF-8, UTF-16 and UTF-32 encodings.</source>
          <target state="translated">&lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;から出力エンコーディングに変換するとき、出力エンコーディングがこれをサポートしている場合は、最初の文字として&lt;a href=&quot;qchar#SpecialCharacter-enum&quot;&gt;QChar :: ByteOrderMark&lt;/a&gt;を記述します。これは、UTF-8、UTF-16、およびUTF-32エンコーディングの場合です。</target>
        </trans-unit>
        <trans-unit id="a3a27bb53c99d0c2bcc135843d6530ba3852ad3b" translate="yes" xml:space="preserve">
          <source>When converting from an input encoding to a &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; the &lt;a href=&quot;qstringdecoder&quot;&gt;QStringDecoder&lt;/a&gt; usually skips an leading &lt;a href=&quot;qchar#SpecialCharacter-enum&quot;&gt;QChar::ByteOrderMark&lt;/a&gt;. When this flag is set, the byte order mark will not be skipped, but converted to utf-16 and inserted at the start of the created &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;.</source>
          <target state="translated">入力エンコーディングから&lt;a href=&quot;qstring&quot;&gt;QStringに&lt;/a&gt;変換する場合、&lt;a href=&quot;qstringdecoder&quot;&gt;QStringDecoder&lt;/a&gt;は通常、先頭の&lt;a href=&quot;qchar#SpecialCharacter-enum&quot;&gt;QChar :: ByteOrderMarkを&lt;/a&gt;スキップします。このフラグが設定されている場合、バイト順マークはスキップされませんが、utf-16に変換され、作成された&lt;a href=&quot;qstring&quot;&gt;QStringの&lt;/a&gt;先頭に挿入されます。</target>
        </trans-unit>
        <trans-unit id="a617205988b57dea8c2826ac4ae64f29a514cd0a" translate="yes" xml:space="preserve">
          <source>When created or cleared, the line edit will be filled with a copy of the input mask string where the meta characters have been removed, and the mask characters have been replaced with the</source>
          <target state="translated">作成またはクリアされると、行編集はメタ文字が削除された入力マスク文字列のコピーで埋められ、マスク文字は</target>
        </trans-unit>
        <trans-unit id="0aae57f52813e54337f9b3ba12b5d957d0e7706b" translate="yes" xml:space="preserve">
          <source>When creating a &lt;a href=&quot;qpagesize&quot;&gt;QPageSize&lt;/a&gt; using a custom &lt;a href=&quot;qsize&quot;&gt;QSize&lt;/a&gt; you can choose if you want &lt;a href=&quot;qpagesize&quot;&gt;QPageSize&lt;/a&gt; to try match the size to a standard page size. By default QPaperSize uses a &lt;a href=&quot;qpagesize#SizeMatchPolicy-enum&quot;&gt;FuzzyMatch&lt;/a&gt; mode where it will match a given page size to a standard page size if it falls within 3 postscript points of a defined standard size. You can override this to request only an exact match but this is not recommended as conversions between units can easily lose 3 points and result in incorrect page sizes.</source>
          <target state="translated">作成するとき&lt;a href=&quot;qpagesize&quot;&gt;QPageSizeを&lt;/a&gt;カスタムを使用して&lt;a href=&quot;qsize&quot;&gt;QSIZE&lt;/a&gt;したい場合は、選択することができます&lt;a href=&quot;qpagesize&quot;&gt;QPageSizeは、&lt;/a&gt;標準のページサイズにサイズと一致しようとします。デフォルトでは、&lt;a href=&quot;qpagesize#SizeMatchPolicy-enum&quot;&gt;QPaperSize&lt;/a&gt;はFuzzyMatchモードを使用します。このモードでは、指定された標準サイズの3つのポストスクリプトポイント内に収まる場合、指定されたページサイズを標準ページサイズに一致させます。これをオーバーライドして完全一致のみを要求することもできますが、単位間の変換により3ポイントが簡単に失われ、ページサイズが正しくなくなる可能性があるため、これはお勧めできません。</target>
        </trans-unit>
        <trans-unit id="9ac98a689f6faf1b4d4a231d05990beaabb87945" translate="yes" xml:space="preserve">
          <source>When creating a &lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt; object, you must pass the name of your company or organization as well as the name of your application. For example, if your product is called Star Runner and your company is called MySoft, you would construct the &lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt; object as follows:</source>
          <target state="translated">&lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt;オブジェクトを作成するときは、会社または組織の名前とアプリケーションの名前を渡す必要があります。たとえば、製品の名前がStar Runnerで会社の&lt;a href=&quot;qsettings&quot;&gt;名前がMySoftの&lt;/a&gt;場合、次のようにQSettingsオブジェクトを作成します。</target>
        </trans-unit>
        <trans-unit id="acdb8c3cb9399aef996527a1d8f6a87298ec82bb" translate="yes" xml:space="preserve">
          <source>When creating a &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; to contain a URL from a &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt; or a char*, always use &lt;a href=&quot;qstring#fromUtf8&quot;&gt;QString::fromUtf8&lt;/a&gt;().</source>
          <target state="translated">&lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt;またはchar * からのURLを含む&lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;を作成するときは、常に&lt;a href=&quot;qstring#fromUtf8&quot;&gt;QString :: fromUtf8&lt;/a&gt;（）を使用してください。</target>
        </trans-unit>
        <trans-unit id="bbe42e39685b882db1d3c259aea5067777985606" translate="yes" xml:space="preserve">
          <source>When creating a QPageSize using a custom &lt;a href=&quot;qsize&quot;&gt;QSize&lt;/a&gt; you can choose if you want QPageSize to try match the size to a standard page size. By default QPaperSize uses a &lt;a href=&quot;qpagesize#SizeMatchPolicy-enum&quot;&gt;FuzzyMatch&lt;/a&gt; mode where it will match a given page size to a standard page size if it falls within 3 postscript points of a defined standard size. You can override this to request only an exact match but this is not recommended as conversions between units can easily lose 3 points and result in incorrect page sizes.</source>
          <target state="translated">カスタム&lt;a href=&quot;qsize&quot;&gt;QSize&lt;/a&gt;を使用してQPageSizeを作成する場合、QPageSizeでサイズを標準のページサイズに一致させるかどうかを選択できます。デフォルトでは、&lt;a href=&quot;qpagesize#SizeMatchPolicy-enum&quot;&gt;QPaperSize&lt;/a&gt;はFuzzyMatchモードを使用します。このモードでは、定義された標準サイズの3つのポストスクリプトポイント内にある場合、特定のページサイズが標準ページサイズに一致します。これをオーバーライドして完全一致のみを要求できますが、ユニット間の変換で3ポイントが簡単に失われ、ページサイズが正しくなくなる可能性があるため、これはお勧めしません。</target>
        </trans-unit>
        <trans-unit id="2f4afccd147883bbee26d5e202b95e0e3a068c0b" translate="yes" xml:space="preserve">
          <source>When creating a QSettings object, you must pass the name of your company or organization as well as the name of your application. For example, if your product is called Star Runner and your company is called MySoft, you would construct the QSettings object as follows:</source>
          <target state="translated">QSettingsオブジェクトを作成する際には、アプリケーションの名前だけでなく、会社や組織の名前も渡さなければなりません。例えば、製品名がスターランナー、会社名がマイソフトの場合、以下のようにQSettingsオブジェクトを構築します。</target>
        </trans-unit>
        <trans-unit id="5d773d0579d473100a4c07b005ea00f7960a8020" translate="yes" xml:space="preserve">
          <source>When creating a custom help viewer the viewer can be configured by writing a custom collection file which could contain various keywords to be used to configure the help engine. These keywords and values and their meaning can be found in the help information for &lt;a href=&quot;https://doc.qt.io/qt-5.13/assistant-custom-help-viewer.html&quot;&gt;creating a custom help collection file&lt;/a&gt; for Assistant.</source>
          <target state="translated">カスタムヘルプビューアを作成する場合、ビューアは、ヘルプエンジンの構成に使用されるさまざまなキーワードを含むカスタムコレクションファイルを作成することによって構成できます。これらのキーワードと値、およびその意味は、アシスタント用の&lt;a href=&quot;https://doc.qt.io/qt-5.13/assistant-custom-help-viewer.html&quot;&gt;カスタムヘルプコレクションファイル&lt;/a&gt;を作成するためのヘルプ情報に記載されています。</target>
        </trans-unit>
        <trans-unit id="ed02b2b618cca08d2bfb9bef8750c41344446144" translate="yes" xml:space="preserve">
          <source>When creating a custom help viewer the viewer can be configured by writing a custom collection file which could contain various keywords to be used to configure the help engine. These keywords and values and their meaning can be found in the help information for &lt;a href=&quot;https://doc.qt.io/qt-5.15/assistant-custom-help-viewer.html&quot;&gt;creating a custom help collection file&lt;/a&gt; for Assistant.</source>
          <target state="translated">カスタムヘルプビューアを作成する場合、ヘルプエンジンの設定に使用するさまざまなキーワードを含むカスタムコレクションファイルを作成することで、ビューアを設定できます。これらのキーワードと値、およびそれらの意味は、アシスタントの&lt;a href=&quot;https://doc.qt.io/qt-5.15/assistant-custom-help-viewer.html&quot;&gt;カスタムヘルプコレクションファイル&lt;/a&gt;を作成するためのヘルプ情報に記載されています。</target>
        </trans-unit>
        <trans-unit id="65bcfdb381290d9bee6e16ff1d2353f984f24d0f" translate="yes" xml:space="preserve">
          <source>When creating a custom item, item coordinates are all you need to worry about; &lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt; and &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; will perform all transformations for you. This makes it very easy to implement custom items. For example, if you receive a mouse press or a drag enter event, the event position is given in item coordinates. The &lt;a href=&quot;qgraphicsitem#contains&quot;&gt;QGraphicsItem::contains&lt;/a&gt;() virtual function, which returns &lt;code&gt;true&lt;/code&gt; if a certain point is inside your item, and false otherwise, takes a point argument in item coordinates. Similarly, an item's bounding rect and shape are in item coordinates.</source>
          <target state="translated">カスタムアイテムを作成する場合、心配する必要があるのはアイテムの座標だけです。&lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt;と&lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt;がすべての変換を実行します。これにより、カスタムアイテムの実装が非常に簡単になります。たとえば、マウスプレスイベントまたはドラッグEnterイベントを受け取った場合、イベントの位置はアイテム座標で示されます。&lt;a href=&quot;qgraphicsitem#contains&quot;&gt;QGraphicsItem ::含まれている&lt;/a&gt;（）仮想返す関数、 &lt;code&gt;true&lt;/code&gt; 特定のポイントは、あなたの項目内にある場合は、それ以外の場合はfalse、アイテムの座標でポイント引数を取ります。同様に、アイテムの境界の四角形と形状はアイテム座標にあります。</target>
        </trans-unit>
        <trans-unit id="9e08552b85a95188c1665a4dafe6b362ee82355f" translate="yes" xml:space="preserve">
          <source>When creating a map from sorted data inserting the largest key first with &lt;a href=&quot;qmap#constBegin&quot;&gt;constBegin&lt;/a&gt;() is faster than inserting in sorted order with &lt;a href=&quot;qmap#constEnd&quot;&gt;constEnd&lt;/a&gt;(), since &lt;a href=&quot;qmap#constEnd&quot;&gt;constEnd&lt;/a&gt;() - 1 (which is needed to check if the hint is valid) needs &lt;a href=&quot;containers#logarithmic-time&quot;&gt;logarithmic time&lt;/a&gt;.</source>
          <target state="translated">ソートされたデータからマップを作成する場合、&lt;a href=&quot;qmap#constBegin&quot;&gt;constBegin&lt;/a&gt;（）を使用して最大のキーを最初に挿入すると、&lt;a href=&quot;qmap#constEnd&quot;&gt;constEnd&lt;/a&gt;（）を使用してソートされた順序で挿入するよりも高速です。これは、&lt;a href=&quot;qmap#constEnd&quot;&gt;constEnd&lt;/a&gt;（）-1（ヒントが有効かどうかを確認するために必要）が&lt;a href=&quot;containers#logarithmic-time&quot;&gt;対数時間を&lt;/a&gt;必要とするためです。</target>
        </trans-unit>
        <trans-unit id="277dae289340726b1f2f3cb7a7f1963aac1390e5" translate="yes" xml:space="preserve">
          <source>When creating a multi map from sorted data inserting the largest key first with &lt;a href=&quot;qmultimap#constBegin&quot;&gt;constBegin&lt;/a&gt;() is faster than inserting in sorted order with &lt;a href=&quot;qmultimap#constEnd&quot;&gt;constEnd&lt;/a&gt;(), since &lt;a href=&quot;qmultimap#constEnd&quot;&gt;constEnd&lt;/a&gt;() - 1 (which is needed to check if the hint is valid) needs &lt;a href=&quot;containers#logarithmic-time&quot;&gt;logarithmic time&lt;/a&gt;.</source>
          <target state="translated">ソートされたデータからマルチマップを作成する場合、&lt;a href=&quot;qmultimap#constEnd&quot;&gt;constEnd&lt;/a&gt;（）-1（ヒントが有効かどうかを確認するために必要）には&lt;a href=&quot;containers#logarithmic-time&quot;&gt;対数時間&lt;/a&gt;が必要なため、&lt;a href=&quot;qmultimap#constEnd&quot;&gt;constBegin&lt;/a&gt;（）で最初に最大のキーを挿入する方が&lt;a href=&quot;qmultimap#constBegin&quot;&gt;constEnd&lt;/a&gt;（）でソートされた順序で挿入するよりも高速です。。</target>
        </trans-unit>
        <trans-unit id="da378fc2f1f498e22d7abb9c20072ff5f0d3d3c4" translate="yes" xml:space="preserve">
          <source>When creating a new model for an existing data structure, it is important to consider which type of model should be used to provide an interface onto the data. If the data structure can be represented as a list or table of items, you can subclass &lt;a href=&quot;qabstractlistmodel&quot;&gt;QAbstractListModel&lt;/a&gt; or &lt;a href=&quot;qabstracttablemodel&quot;&gt;QAbstractTableModel&lt;/a&gt; since these classes provide suitable default implementations for many functions.</source>
          <target state="translated">既存のデータ構造に新しいモデルを作成する場合、データへのインターフェースを提供するためにどのタイプのモデルを使用する必要があるかを考慮することが重要です。データ構造を項目のリストまたはテーブルとして表すことができる場合、&lt;a href=&quot;qabstractlistmodel&quot;&gt;QAbstractListModel&lt;/a&gt;または&lt;a href=&quot;qabstracttablemodel&quot;&gt;QAbstractTableModelを&lt;/a&gt;サブクラス化できます。これらのクラスは、多くの関数に適切なデフォルト実装を提供するためです。</target>
        </trans-unit>
        <trans-unit id="8500b569b9e4d2538da567830ca173bb7a100287" translate="yes" xml:space="preserve">
          <source>When creating a property binding from JavaScript, the &lt;code&gt;this&lt;/code&gt; keyword can be used to refer to the object which receives the binding. This is helpful for resolving ambiguities with property names.</source>
          <target state="translated">JavaScriptからプロパティバインディングを作成する場合、 &lt;code&gt;this&lt;/code&gt; キーワードを使用して、バインディングを受け取るオブジェクトを参照できます。これは、プロパティ名のあいまいさを解決するのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="a4acef9238768bf956778e2a447e1184f2109294" translate="yes" xml:space="preserve">
          <source>When creating an &lt;a href=&quot;qt3drender-qeffect&quot;&gt;QEffect&lt;/a&gt; that targets several versions of a graphics API, it is useful to create several &lt;a href=&quot;qt3drender-qtechnique&quot;&gt;QTechnique&lt;/a&gt; nodes each with a &lt;a href=&quot;qt3drender-qtechnique#graphicsApiFilter-prop&quot;&gt;graphicsApiFilter&lt;/a&gt; set to match one of the targeted GL versions. At runtime, the Qt3D renderer will select the most appropriate &lt;a href=&quot;qt3drender-qtechnique&quot;&gt;QTechnique&lt;/a&gt; based on which graphics API versions are supported and (if specified) the &lt;a href=&quot;qt3drender-qfilterkey&quot;&gt;QFilterKey&lt;/a&gt; nodes that satisfy a given &lt;a href=&quot;qt3drender-qtechniquefilter&quot;&gt;QTechniqueFilter&lt;/a&gt; in the FrameGraph.</source>
          <target state="translated">グラフィックAPIの複数のバージョンを対象とする&lt;a href=&quot;qt3drender-qeffect&quot;&gt;QEffect&lt;/a&gt;を作成する場合、対象のGLバージョンの1つと一致するように&lt;a href=&quot;qt3drender-qtechnique#graphicsApiFilter-prop&quot;&gt;graphicsApiFilterが&lt;/a&gt;設定された複数の&lt;a href=&quot;qt3drender-qtechnique&quot;&gt;QTechnique&lt;/a&gt;ノードを作成すると便利です。実行時に、Qt3Dレンダラは、最も適切な選択であろう&lt;a href=&quot;qt3drender-qtechnique&quot;&gt;QTechnique&lt;/a&gt;（指定されている場合）、グラフィックスAPIのバージョンがサポートされ、これに基づいて&lt;a href=&quot;qt3drender-qfilterkey&quot;&gt;QFilterKeyの&lt;/a&gt;所与満たすノード&lt;a href=&quot;qt3drender-qtechniquefilter&quot;&gt;QTechniqueFilterを&lt;/a&gt; FrameGraphにします。</target>
        </trans-unit>
        <trans-unit id="74fe2d261fd9daef09d6ad1cf9640099d84a6e3f" translate="yes" xml:space="preserve">
          <source>When creating an &lt;a href=&quot;qt3drender-qeffect&quot;&gt;QEffect&lt;/a&gt; that targets several versions of a graphics API, it is useful to create several QTechnique nodes each with a &lt;a href=&quot;qt3drender-qtechnique#graphicsApiFilter-prop&quot;&gt;graphicsApiFilter&lt;/a&gt; set to match one of the targeted GL versions. At runtime, the Qt3D renderer will select the most appropriate QTechnique based on which graphics API versions are supported and (if specified) the &lt;a href=&quot;qt3drender-qfilterkey&quot;&gt;QFilterKey&lt;/a&gt; nodes that satisfy a given &lt;a href=&quot;qt3drender-qtechniquefilter&quot;&gt;QTechniqueFilter&lt;/a&gt; in the FrameGraph.</source>
          <target state="translated">グラフィックAPIの複数のバージョンを対象とする&lt;a href=&quot;qt3drender-qeffect&quot;&gt;QEffect&lt;/a&gt;を作成する場合、対象のGLバージョンの1つと一致するようにそれぞれ&lt;a href=&quot;qt3drender-qtechnique#graphicsApiFilter-prop&quot;&gt;graphicsApiFilterが&lt;/a&gt;設定された複数のQTechniqueノードを作成すると便利です。実行時に、Qt3Dレンダラーは、（指定されている場合）、グラフィックスAPIのバージョンがサポートされ、それに基づいて最も適切なQTechnique選択する&lt;a href=&quot;qt3drender-qfilterkey&quot;&gt;QFilterKeyの&lt;/a&gt;所与満たすノード&lt;a href=&quot;qt3drender-qtechniquefilter&quot;&gt;QTechniqueFilterを&lt;/a&gt;FrameGraphにします。</target>
        </trans-unit>
        <trans-unit id="bd5a5c9f752ad47937d6434e44c62e97758c6944" translate="yes" xml:space="preserve">
          <source>When creating an Effect that targets several versions of a graphics API, it is useful to create several Technique nodes each with a &lt;a href=&quot;qml-qt3d-render-technique#graphicsApiFilter-prop&quot;&gt;graphicsApiFilter&lt;/a&gt; set to match one of the targeted versions. At runtime, the Qt3D renderer will select the most appropriate Technique based on which graphics API versions are supported and (if specified) the &lt;a href=&quot;qml-qt3d-render-filterkey&quot;&gt;FilterKey&lt;/a&gt; nodes that satisfy a given &lt;a href=&quot;qml-qt3d-render-techniquefilter&quot;&gt;TechniqueFilter&lt;/a&gt; in the FrameGraph.</source>
          <target state="translated">グラフィックAPIの複数のバージョンを対象とするエフェクトを作成する場合、対象のバージョンのいずれかに一致するように&lt;a href=&quot;qml-qt3d-render-technique#graphicsApiFilter-prop&quot;&gt;graphicsApiFilterが&lt;/a&gt;設定された複数のTechniqueノードを作成すると便利です。実行時に、Qt3Dレンダラーは、（指定されている場合）、グラフィックスAPIのバージョンがサポートされ、それに基づいて最も適切な方法を選択します&lt;a href=&quot;qml-qt3d-render-filterkey&quot;&gt;FilterKeyの&lt;/a&gt;所与満たすノード&lt;a href=&quot;qml-qt3d-render-techniquefilter&quot;&gt;TechniqueFilterを&lt;/a&gt; FrameGraphにします。</target>
        </trans-unit>
        <trans-unit id="f722c75ee9a2de387fc8f2d451fedcecaaa57d68" translate="yes" xml:space="preserve">
          <source>When creating custom items, use the new &lt;a href=&quot;qsgrectanglenode&quot;&gt;QSGRectangleNode&lt;/a&gt; and &lt;a href=&quot;qsgimagenode&quot;&gt;QSGImageNode&lt;/a&gt; classes. These replace the now deprecated QSGSimpleRectNode and QSGSimpleTextureNode. Unlike their predecessors, these new classes are interfaces, and implementations are created via the &lt;a href=&quot;qquickwindow#createRectangleNode&quot;&gt;QQuickWindow::createRectangleNode&lt;/a&gt;() and &lt;a href=&quot;qquickwindow#createImageNode&quot;&gt;QQuickWindow::createImageNode&lt;/a&gt;() factory functions.</source>
          <target state="translated">カスタム項目を作成する場合、新しい使用&lt;a href=&quot;qsgrectanglenode&quot;&gt;QSGRectangleNode&lt;/a&gt;と&lt;a href=&quot;qsgimagenode&quot;&gt;QSGImageNode&lt;/a&gt;クラスを。これらは、現在非推奨のQSGSimpleRectNodeおよびQSGSimpleTextureNodeに代わるものです。&lt;a href=&quot;qquickwindow#createRectangleNode&quot;&gt;以前のバージョン&lt;/a&gt;とは異なり、これらの新しいクラスはインターフェースであり、実装はQQuickWindow :: createRectangleNode（）および&lt;a href=&quot;qquickwindow#createImageNode&quot;&gt;QQuickWindow :: createImageNode&lt;/a&gt;（）ファクトリー関数を介して作成されます。</target>
        </trans-unit>
        <trans-unit id="ad1ca55154d7a13bb0a82b3ada46b98f3f2fa71a" translate="yes" xml:space="preserve">
          <source>When creating textures via C++ scene graph APIs like &lt;a href=&quot;qquickwindow#createTextureFromImage&quot;&gt;QQuickWindow::createTextureFromImage&lt;/a&gt;(), 32-bit formats won't involve any conversion, they'll map directly to the corresponding &lt;code&gt;R8G8B8A8_UNORM&lt;/code&gt; or &lt;code&gt;B8G8R8A8_UNORM&lt;/code&gt; format. Everything else will trigger a &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt;-based format conversion on the CPU first.</source>
          <target state="translated">&lt;a href=&quot;qquickwindow#createTextureFromImage&quot;&gt;QQuickWindow :: createTextureFromImage&lt;/a&gt;（）などのC ++シーングラフAPIを介してテクスチャを作成する場合、32ビット形式は変換を含まず、対応する &lt;code&gt;R8G8B8A8_UNORM&lt;/code&gt; または &lt;code&gt;B8G8R8A8_UNORM&lt;/code&gt; 形式に直接マッピングされます。それ以外はすべて、最初にCPUで&lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt;ベースのフォーマット変換をトリガーします。</target>
        </trans-unit>
        <trans-unit id="ac8c6318f0656d7823865940204d8f34b4f9e2dc" translate="yes" xml:space="preserve">
          <source>When creating user interfaces with Qt, particularly those with specialized controls and features, developers sometimes need to create new data types that can be used alongside or in place of Qt's existing set of value types.</source>
          <target state="translated">Qt でユーザーインターフェースを作成する際、特に特殊なコントロールや機能を持つユーザーインターフェースを作成する場合、開発者は Qt の既存の値の型のセットと一緒に、またはそれに代えて使用できる新しいデータ型を作成する必要があることがあります。</target>
        </trans-unit>
        <trans-unit id="7c5cad017177801067fb33fec32abbde43a2a0a2" translate="yes" xml:space="preserve">
          <source>When creating visual scenes with Qt Quick, it is important to understand the concept of the</source>
          <target state="translated">Qt Quickでビジュアルシーンを作成する際には</target>
        </trans-unit>
        <trans-unit id="50bc4a3f36be94206381ac944ed54f7e8e7a7edb" translate="yes" xml:space="preserve">
          <source>When data is transferred from C++ to QML, the ownership of the data always remains with C++. The exception to this rule is when a &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; is returned from an explicit C++ method call: in this case, the QML engine assumes ownership of the object, unless the ownership of the object has explicitly been set to remain with C++ by invoking &lt;a href=&quot;qjsengine#setObjectOwnership&quot;&gt;QQmlEngine::setObjectOwnership&lt;/a&gt;() with &lt;a href=&quot;qjsengine#ObjectOwnership-enum&quot;&gt;QQmlEngine::CppOwnership&lt;/a&gt; specified.</source>
          <target state="translated">データがC ++からQMLに転送される場合、データの所有権は常にC ++に残ります。このルールの例外は、&lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt;が明示的なC ++メソッド呼び出しから返される場合です。この場合、&lt;a href=&quot;qjsengine#setObjectOwnership&quot;&gt;QQmlEngine&lt;/a&gt;を呼び出してオブジェクトの所有権がC ++に残るように明示的に設定されていない限り、QMLエンジンがオブジェクトの所有権を引き継ぎます。&lt;a href=&quot;qjsengine#ObjectOwnership-enum&quot;&gt;QQmlEngine :: CppOwnershipが&lt;/a&gt;指定されたsetObjectOwnership（）。</target>
        </trans-unit>
        <trans-unit id="d8deccb0e684f6ccb3eb82d7b6672c38b9e7d190" translate="yes" xml:space="preserve">
          <source>When data is transferred from C++ to QML, the ownership of the data always remains with C++. The exception to this rule is when a &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; is returned from an explicit C++ method call: in this case, the QML engine assumes ownership of the object, unless the ownership of the object has explicitly been set to remain with C++ by invoking &lt;a href=&quot;qqmlengine#setObjectOwnership&quot;&gt;QQmlEngine::setObjectOwnership&lt;/a&gt;() with &lt;a href=&quot;qqmlengine#ObjectOwnership-enum&quot;&gt;QQmlEngine::CppOwnership&lt;/a&gt; specified.</source>
          <target state="translated">データがC ++からQMLに転送されるとき、データの所有権は常にC ++に残ります。このルールの例外は、明示的なC ++メソッド呼び出しから&lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt;が返される場合です。この場合、&lt;a href=&quot;qqmlengine#setObjectOwnership&quot;&gt;QQmlEngine&lt;/a&gt;を呼び出してオブジェクトの所有権がC ++に残るように明示的に設定されていない限り、QMLエンジンはオブジェクトの所有権を想定します。&lt;a href=&quot;qqmlengine#ObjectOwnership-enum&quot;&gt;QQmlEngine :: CppOwnershipを&lt;/a&gt;指定したsetObjectOwnership（）。</target>
        </trans-unit>
        <trans-unit id="833825b15200463ac0253e002ab1f7246eda7871" translate="yes" xml:space="preserve">
          <source>When data values are exchanged between QML and C++, they are converted by the QML engine to have the correct data types as appropriate for use in QML or C++. This requires the exchanged data to be of a type that is recognizable by the engine.</source>
          <target state="translated">QMLとC++の間でデータ値を交換する際には、QMLエンジンがQMLやC++での使用に適した正しいデータ型に変換します。そのためには、交換されるデータはエンジンが認識できる型である必要があります。</target>
        </trans-unit>
        <trans-unit id="884fbee58eaf141d201605823b7b1107d132d1f7" translate="yes" xml:space="preserve">
          <source>When data-modifying functions increase the size of the array, they may lead to reallocation of memory for the QByteArray object. When this happens, QByteArray expands by more than it immediately needs so as to have space for further expansion without reallocation until the size of the array has greatly increased.</source>
          <target state="translated">データ変更関数が配列のサイズを大きくすると、QByteArray オブジェクトのメモリの再割り当てが発生することがあります。このような場合、QByteArrayは、配列のサイズが大幅に大きくなるまで再割り当てを行わずに、さらに拡張するためのスペースを確保するために、すぐに必要とする以上に拡張します。</target>
        </trans-unit>
        <trans-unit id="88de44478b8ed2bd120794db0b7d5b455c64de25" translate="yes" xml:space="preserve">
          <source>When dealing with shared objects, there are two ways of copying an object. We usually speak about</source>
          <target state="translated">共有オブジェクトを扱う場合、オブジェクトをコピーするには2つの方法があります。通常は</target>
        </trans-unit>
        <trans-unit id="880f2e372d228c68b46fdc809205b92833a51398" translate="yes" xml:space="preserve">
          <source>When dealing with the D-Bus bus service or with remote applications over D-Bus, a number of error conditions can happen. This error conditions are sometimes signalled by a returned error value or by a &lt;a href=&quot;qdbuserror&quot;&gt;QDBusError&lt;/a&gt;.</source>
          <target state="translated">D-BusバスサービスまたはD-Bus経由のリモートアプリケーションを処理する場合、多くのエラー状態が発生する可能性があります。このエラー状態は、返されたエラー値または&lt;a href=&quot;qdbuserror&quot;&gt;QDBusError&lt;/a&gt;によって通知されることがあります。</target>
        </trans-unit>
        <trans-unit id="74f0ca37c9cc12fbb98f9f5310dd3caadcb27473" translate="yes" xml:space="preserve">
          <source>When dealing with the D-Bus bus service or with remote applications over D-Bus, a number of error conditions can happen. This error conditions are sometimes signalled by a returned error value or by a QDBusError.</source>
          <target state="translated">D-Bus バスサービスや D-Bus 上のリモートアプリケーションを扱う場合、多くのエラー状態が発生する可能性があります。このエラー状態は、返されたエラー値や QDBusError によって通知されることがあります。</target>
        </trans-unit>
        <trans-unit id="37e1660403429a1797eb4c0aeb989abc574ce656" translate="yes" xml:space="preserve">
          <source>When declaring properties in QML, it's easy and convenient to use the &quot;var&quot; type:</source>
          <target state="translated">QMLでプロパティを宣言する際には、&quot;var &quot;型を使うのが簡単で便利です。</target>
        </trans-unit>
        <trans-unit id="499464bd993035896d274262364a35979c761cc8" translate="yes" xml:space="preserve">
          <source>When decoding Base64-encoded data, ignores errors in the input; invalid characters are simply skipped. This enum value has been added in Qt 5.15.</source>
          <target state="translated">Base64でエンコードされたデータをデコードする際に、入力中のエラーを無視します。この列挙値は Qt 5.15 で追加されました。</target>
        </trans-unit>
        <trans-unit id="ee82abeedacfd233e0f6aece53f4beda554b1af8" translate="yes" xml:space="preserve">
          <source>When decoding Base64-encoded data, stops at the first decoding error. This enum value has been added in Qt 5.15.</source>
          <target state="translated">Base64エンコードされたデータをデコードする際、最初のデコードエラーで停止します。この列挙値は Qt 5.15 で追加されました。</target>
        </trans-unit>
        <trans-unit id="f6c7b9b1412f471c238127a4b55f7698c8fb1c87" translate="yes" xml:space="preserve">
          <source>When defining your own needle component, the only properties that the style requires you to set are the &lt;a href=&quot;qml-qtquick-item#implicitWidth-prop&quot;&gt;implicitWidth&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-item#implicitHeight-prop&quot;&gt;implicitHeight&lt;/a&gt;.</source>
          <target state="translated">独自の針コンポーネントを定義する場合、スタイルで設定する必要があるプロパティは、&lt;a href=&quot;qml-qtquick-item#implicitWidth-prop&quot;&gt;implicitWidth&lt;/a&gt;と&lt;a href=&quot;qml-qtquick-item#implicitHeight-prop&quot;&gt;implicitHeightだけ&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="a11f2000ac0edf67c2b20ae00acff6fb70863dbe" translate="yes" xml:space="preserve">
          <source>When deploying Qt applications built using Visual Studio 2005, or later, make sure that the manifest file that was created when the application was linked is handled correctly. This is handled automatically for projects that generate DLLs.</source>
          <target state="translated">Visual Studio 2005以降で構築されたQtアプリケーションをデプロイする際には、アプリケーションをリンクした際に作成されたマニフェストファイルが正しく処理されていることを確認してください。DLLを生成するプロジェクトでは自動的に処理されます。</target>
        </trans-unit>
        <trans-unit id="e3f2fc2611c302aed3276f1510a9d174ba6db392" translate="yes" xml:space="preserve">
          <source>When deploying the app, the compression is typically handled on the server side. We recommend to compress the wasm binaries because this typically reduces the size of the binary by 50 %.</source>
          <target state="translated">アプリをデプロイする際、圧縮は通常サーバー側で処理されます。Wasm バイナリを圧縮することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="fc8ea9ac8ca6cf4cf6b3b5f4d012ccb4493d9e28" translate="yes" xml:space="preserve">
          <source>When developing applications that use D-Bus, it is sometimes useful to be able to see information about the messages that are sent and received across the bus by each application.</source>
          <target state="translated">D-Busを使用するアプリケーションを開発する際に、各アプリケーションがバス上で送受信するメッセージの情報を見ることができると便利な場合があります。</target>
        </trans-unit>
        <trans-unit id="1a1c1be356204dfd455ba7ec0d01e973b146ec67" translate="yes" xml:space="preserve">
          <source>When disabled, a &lt;a href=&quot;qml-qt3d-render-nodraw&quot;&gt;NoDraw&lt;/a&gt; node won't prevent the scene from being rendered. Toggling the enabled property is therefore a way to make a &lt;a href=&quot;qml-qt3d-render-nodraw&quot;&gt;NoDraw&lt;/a&gt; active or inactive.</source>
          <target state="translated">無効にすると、&lt;a href=&quot;qml-qt3d-render-nodraw&quot;&gt;NoDraw&lt;/a&gt;ノードはシーンのレンダリングを妨げません。したがって、enabledプロパティを&lt;a href=&quot;qml-qt3d-render-nodraw&quot;&gt;切り替える&lt;/a&gt;ことは、NoDrawをアクティブまたは非アクティブにする方法です。</target>
        </trans-unit>
        <trans-unit id="857e0ffe6bd1478d0544df44c2c658d65e015926" translate="yes" xml:space="preserve">
          <source>When disabled, a &lt;a href=&quot;qt3drender-qnodraw&quot;&gt;Qt3DRender::QNoDraw&lt;/a&gt; node won't prevent the scene from being rendered. Toggling the enabled property is therefore a way to make a &lt;a href=&quot;qt3drender-qnodraw&quot;&gt;Qt3DRender::QNoDraw&lt;/a&gt; active or inactive.</source>
          <target state="translated">無効にすると、&lt;a href=&quot;qt3drender-qnodraw&quot;&gt;Qt3DRender :: QNoDraw&lt;/a&gt;ノードはシーンのレンダリングを妨げません。したがって、enabledプロパティを&lt;a href=&quot;qt3drender-qnodraw&quot;&gt;切り替える&lt;/a&gt;ことで、Qt3DRender :: QNoDrawをアクティブまたは非アクティブにすることができます。</target>
        </trans-unit>
        <trans-unit id="a705f9e79dc5e0d4da74710091ca3394fb3c8ff6" translate="yes" xml:space="preserve">
          <source>When disabled, a &lt;a href=&quot;qt3drender-qnopicking&quot;&gt;Qt3DRender::QNoPicking&lt;/a&gt; node won't prevent picking from being performed. Toggling the enabled property is therefore a way to make a &lt;a href=&quot;qt3drender-qnopicking&quot;&gt;Qt3DRender::QNoPicking&lt;/a&gt; active or inactive.</source>
          <target state="translated">無効にすると、&lt;a href=&quot;qt3drender-qnopicking&quot;&gt;Qt3DRender :: QNoPicking&lt;/a&gt;ノードはピッキングの実行を妨げません。したがって、enabledプロパティを&lt;a href=&quot;qt3drender-qnopicking&quot;&gt;切り替える&lt;/a&gt;ことは、Qt3DRender :: QNoPickingをアクティブまたは非アクティブにする方法です。</target>
        </trans-unit>
        <trans-unit id="c03a7230ca07cd92ed1e2c5c76edb68253bdb253" translate="yes" xml:space="preserve">
          <source>When disabled, a NoDraw node won't prevent the scene from being rendered. Toggling the enabled property is therefore a way to make a NoDraw active or inactive.</source>
          <target state="translated">無効にすると、NoDraw ノードはシーンのレンダリングを妨げません。そのため、Enable プロパティをトグルすることで、NoDraw をアクティブにしたり、非アクティブにしたりすることができます。</target>
        </trans-unit>
        <trans-unit id="7e738f36ac893e8cd586e71209d223aa4927c0d5" translate="yes" xml:space="preserve">
          <source>When disabled, a NoPicking node won't prevent picking from being performed. Toggling the enabled property is therefore a way to make a NoPicking active or inactive.</source>
          <target state="translated">無効にすると、NoPickingノードはピッキングの実行を妨げません。したがって、このプロパティを有効にすることで、NoPickingをアクティブまたは非アクティブにすることができます。</target>
        </trans-unit>
        <trans-unit id="382c790d1bb1d0cf3f278efbd5066d3785f4f5c9" translate="yes" xml:space="preserve">
          <source>When disabled, the &lt;a href=&quot;qml-qtquick3d-sceneenvironment#depthTestEnabled-prop&quot;&gt;depthTestEnabled&lt;/a&gt; property can be used to simultaneously override depth testing and the order of rendering the objects. The operation of this property is not as obvious as many of the other properties in the system so this page offers some insight into when, where, and why this property can be used.</source>
          <target state="translated">無効にすると、&lt;a href=&quot;qml-qtquick3d-sceneenvironment#depthTestEnabled-prop&quot;&gt;depthTestEnabled&lt;/a&gt;プロパティを使用して、深度テストとオブジェクトのレンダリング順序を同時にオーバーライドできます。このプロパティの操作は、システム内の他の多くのプロパティほど明白ではないため、このページでは、このプロパティをいつ、どこで、なぜ使用できるかについての洞察を提供します。</target>
        </trans-unit>
        <trans-unit id="bc1e687319c686b682a905da3e6616cd03084a73" translate="yes" xml:space="preserve">
          <source>When disabled, the normals on the surface are interpolated making the edges look round. When enabled, the normals are kept the same on a triangle making the color of the triangle solid. This makes the data more readable from the model.</source>
          <target state="translated">無効にすると、サーフェスの法線が補間され、エッジが丸く見えます。有効にすると、三角形の法線は同じままで、三角形の色はソリッドになります。これにより、モデルからのデータがより読みやすくなります。</target>
        </trans-unit>
        <trans-unit id="24f4c0f2f49fed31d9cd8577cea9ab05b39be5e3" translate="yes" xml:space="preserve">
          <source>When displaying data from models in Qt item views, e.g., a &lt;a href=&quot;qtableview&quot;&gt;QTableView&lt;/a&gt;, the individual items are drawn by a delegate. Also, when an item is edited, it provides an editor widget, which is placed on top of the item view while editing takes place. &lt;a href=&quot;qstyleditemdelegate&quot;&gt;QStyledItemDelegate&lt;/a&gt; is the default delegate for all Qt item views, and is installed upon them when they are created.</source>
          <target state="translated">&lt;a href=&quot;qtableview&quot;&gt;QTableView&lt;/a&gt;などのQtアイテムビューでモデルのデータを表示する場合、個々のアイテムはデリゲートによって描画されます。また、アイテムが編集されると、エディターウィジェットが提供され、編集が行われている間はアイテムビューの上に配置されます。&lt;a href=&quot;qstyleditemdelegate&quot;&gt;QStyledItemDelegate&lt;/a&gt;はすべてのQtアイテムビューのデフォルトのデリゲートであり、作成時にビューにインストールされます。</target>
        </trans-unit>
        <trans-unit id="e6e55cf5ea63dc5db3857d7ad604b687dae8d030" translate="yes" xml:space="preserve">
          <source>When displaying data from models in Qt item views, e.g., a &lt;a href=&quot;qtableview&quot;&gt;QTableView&lt;/a&gt;, the individual items are drawn by a delegate. Also, when an item is edited, it provides an editor widget, which is placed on top of the item view while editing takes place. QStyledItemDelegate is the default delegate for all Qt item views, and is installed upon them when they are created.</source>
          <target state="translated">&lt;a href=&quot;qtableview&quot;&gt;QTableView&lt;/a&gt;などのQtアイテムビューでモデルのデータを表示する場合、個々のアイテムはデリゲートによって描画されます。また、アイテムを編集すると、編集ウィジェットが提供されます。このウィジェットは、編集中にアイテムビューの上に配置されます。QStyledItemDelegateは、すべてのQtアイテムビューのデフォルトのデリゲートであり、作成時にインストールされます。</target>
        </trans-unit>
        <trans-unit id="0352c49318cb9d0b30ba555050217480183cb03e" translate="yes" xml:space="preserve">
          <source>When displaying items from a custom model in a standard view, it is often sufficient to simply ensure that the model returns appropriate data for each of the &lt;a href=&quot;qt#ItemDataRole-enum&quot;&gt;roles&lt;/a&gt; that determine the appearance of items in views. The default delegate used by Qt's standard views uses this role information to display items in most of the common forms expected by users. However, it is sometimes necessary to have even more control over the appearance of items than the default delegate can provide.</source>
          <target state="translated">カスタムビューのアイテムを標準ビューで表示する場合、ビューでのアイテムの外観を決定する各&lt;a href=&quot;qt#ItemDataRole-enum&quot;&gt;ロールの&lt;/a&gt;適切なデータをモデルが返すことを確認するだけで十分です。 Qtの標準ビューで使用されるデフォルトのデリゲートは、このロール情報を使用して、ユーザーが期待するほとんどの一般的なフォームでアイテムを表示します。ただし、デフォルトのデリゲートが提供できるよりもさらに多くの項目の外観を制御する必要がある場合があります。</target>
        </trans-unit>
        <trans-unit id="159720c88af83f5ac94a174365550a72f0765067" translate="yes" xml:space="preserve">
          <source>When documenting a QML type in a</source>
          <target state="translated">QML型を</target>
        </trans-unit>
        <trans-unit id="b7e55292b4abae3e9e4e7263b6533ed85abbb41e" translate="yes" xml:space="preserve">
          <source>When documenting a QML type in the</source>
          <target state="translated">QML型を</target>
        </trans-unit>
        <trans-unit id="fd4be1f4d3d4fe684047540a2b498b3e14a564e5" translate="yes" xml:space="preserve">
          <source>When doing replacement the area of the preedit string is ignored, thus a replacement starting at -1 with a length of 2 will remove the last character before the preedit string and the first character afterwards, and insert the commit string directly before the preedit string.</source>
          <target state="translated">置換を行う場合、前編集文字列の領域は無視されます。したがって、-1 で始まる長さ 2 の置換は、前編集文字列の前の最後の文字と後の最初の文字を削除し、前編集文字列の前に直接コミット文字列を挿入します。</target>
        </trans-unit>
        <trans-unit id="7b591bbff5ab07d40d7612a73ab5fcdc537e41fa" translate="yes" xml:space="preserve">
          <source>When doubleclicking an item, the item will first receive a mouse press event, followed by a release event (i.e., a click), then a doubleclick event, and finally a release event.</source>
          <target state="translated">アイテムをダブルクリックすると、アイテムは最初にマウスのプレスイベントを受け、その後リリースイベント(つまりクリック)、ダブルクリックイベント、そして最後にリリースイベントを受けます。</target>
        </trans-unit>
        <trans-unit id="a02484f5ce286a79ae6a871b9106f5799cb1d5dc" translate="yes" xml:space="preserve">
          <source>When dragging the titlebar of a dock, all the tabs that are tabbed with it are going to be dragged. Implies AllowTabbedDocks. Does not work well if some QDockWidgets have restrictions in which area they are allowed. (This enum value was added in Qt 5.6.)</source>
          <target state="translated">ドックのタイトルバーをドラッグすると、それと一緒にタブになっているすべてのタブがドラッグされるようになります。AllowTabbedDocksを意味します。一部のQDockWidgetsが許可する領域に制限がある場合にはうまく動作しません。(この列挙値は Qt 5.6 で追加されました)</target>
        </trans-unit>
        <trans-unit id="19649a7c3fc63002d50d3cb1460af355d223d55e" translate="yes" xml:space="preserve">
          <source>When drawStaticText() is called, the layout of the &lt;a href=&quot;qstatictext&quot;&gt;QStaticText&lt;/a&gt; will be recalculated if any part of the &lt;a href=&quot;qstatictext&quot;&gt;QStaticText&lt;/a&gt; object has changed since the last time it was drawn. It will also be recalculated if the painter's font is not the same as when the &lt;a href=&quot;qstatictext&quot;&gt;QStaticText&lt;/a&gt; was last drawn, or, on any other paint engine than the OpenGL2 engine, if the painter's matrix has been altered since the static text was last drawn.</source>
          <target state="translated">drawStaticText（）が呼び出されると、最後に描画されてから&lt;a href=&quot;qstatictext&quot;&gt;QStaticText&lt;/a&gt;オブジェクトの一部が変更された場合、&lt;a href=&quot;qstatictext&quot;&gt;QStaticText&lt;/a&gt;のレイアウトが再計算されます。ペインタのフォントが&lt;a href=&quot;qstatictext&quot;&gt;QStaticText&lt;/a&gt;が最後に描画されたときと同じでない場合、またはOpenGL2エンジン以外のペイントエンジンで、静的テキストが最後に描画されてからペインタのマトリックスが変更された場合も、再計算されます。</target>
        </trans-unit>
        <trans-unit id="6f25e8af439c89e58b576aa15a0a79c869106881" translate="yes" xml:space="preserve">
          <source>When drawing text, the font is specified using the &lt;a href=&quot;gui-changes-qt6#qfont&quot;&gt;QFont&lt;/a&gt; class. Qt will use the font with the specified attributes, or if no matching font exists, Qt will use the closest matching installed font. The attributes of the font that is actually used can be retrieved using the &lt;a href=&quot;qfontinfo&quot;&gt;QFontInfo&lt;/a&gt; class. In addition, the &lt;a href=&quot;qfontmetrics&quot;&gt;QFontMetrics&lt;/a&gt; class provides the font measurements, and the &lt;a href=&quot;gui-changes-qt6#qfontdatabase&quot;&gt;QFontDatabase&lt;/a&gt; class provides information about the fonts available in the underlying window system.</source>
          <target state="translated">テキストを描画する場合、フォントは&lt;a href=&quot;gui-changes-qt6#qfont&quot;&gt;QFont&lt;/a&gt;クラスを使用して指定されます。 Qtは、指定された属性のフォントを使用します。一致するフォントが存在しない場合、Qtは最も一致するインストール済みフォントを使用します。実際に使用されているフォントの属性は、&lt;a href=&quot;qfontinfo&quot;&gt;QFontInfo&lt;/a&gt;クラスを使用して取得できます。さらに、&lt;a href=&quot;qfontmetrics&quot;&gt;QFontMetrics&lt;/a&gt;クラスはフォントの測定値を提供し、&lt;a href=&quot;gui-changes-qt6#qfontdatabase&quot;&gt;QFontDatabase&lt;/a&gt;クラスは基になるウィンドウシステムで使用可能なフォントに関する情報を提供します。</target>
        </trans-unit>
        <trans-unit id="bb13eb36af2066f03f57ae49bb001cd98eedd84c" translate="yes" xml:space="preserve">
          <source>When drawing text, the font is specified using the &lt;a href=&quot;qfont&quot;&gt;QFont&lt;/a&gt; class. Qt will use the font with the specified attributes, or if no matching font exists, Qt will use the closest matching installed font. The attributes of the font that is actually used can be retrieved using the &lt;a href=&quot;qfontinfo&quot;&gt;QFontInfo&lt;/a&gt; class. In addition, the &lt;a href=&quot;qfontmetrics&quot;&gt;QFontMetrics&lt;/a&gt; class provides the font measurements, and the &lt;a href=&quot;qfontdatabase&quot;&gt;QFontDatabase&lt;/a&gt; class provides information about the fonts available in the underlying window system.</source>
          <target state="translated">テキストを描画するとき、フォントは&lt;a href=&quot;qfont&quot;&gt;QFont&lt;/a&gt;クラスを使用して指定されます。Qtは指定された属性を持つフォントを使用します。または、一致するフォントが存在しない場合、Qtは最も近いインストール済みフォントを使用します。実際に使用されるフォントの属性は、&lt;a href=&quot;qfontinfo&quot;&gt;QFontInfo&lt;/a&gt;クラスを使用して取得できます。さらに、&lt;a href=&quot;qfontmetrics&quot;&gt;QFontMetrics&lt;/a&gt;クラスはフォントの測定値を提供し、&lt;a href=&quot;qfontdatabase&quot;&gt;QFontDatabase&lt;/a&gt;クラスは基になるウィンドウシステムで使用可能なフォントに関する情報を提供します。</target>
        </trans-unit>
        <trans-unit id="2b8fa7bd4261a029b6f3fdf343d1e4a3de0c8942" translate="yes" xml:space="preserve">
          <source>When drawing with &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt;, we specify points using logical coordinates which then are converted into the physical coordinates of the paint device.</source>
          <target state="translated">&lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt;で描画する場合、論理座標を使用して点を指定します。論理座標は、ペイントデバイスの物理座標に変換されます。</target>
        </trans-unit>
        <trans-unit id="410e5ecacd6f13933f5b02a517c03bf075b15730" translate="yes" xml:space="preserve">
          <source>When drawing with &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt;, we specify points using logical coordinates which then are converted into the physical coordinates of the paint device. The mapping of the logical coordinates to the physical coordinates are handled by &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt;'s &lt;a href=&quot;qpainter#combinedTransform&quot;&gt;combinedTransform&lt;/a&gt;(), a combination of &lt;a href=&quot;qpainter#viewport&quot;&gt;viewport&lt;/a&gt;() and &lt;a href=&quot;qpainter#window&quot;&gt;window&lt;/a&gt;() and &lt;a href=&quot;qpainter#worldTransform&quot;&gt;worldTransform&lt;/a&gt;(). The &lt;a href=&quot;qpainter#viewport&quot;&gt;viewport&lt;/a&gt;() represents the physical coordinates specifying an arbitrary rectangle, the &lt;a href=&quot;qpainter#window&quot;&gt;window&lt;/a&gt;() describes the same rectangle in logical coordinates, and the &lt;a href=&quot;qpainter#worldTransform&quot;&gt;worldTransform&lt;/a&gt;() is identical with the transformation matrix.</source>
          <target state="translated">&lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt;で描画する場合、論理座標を使用して点を指定します。論理座標は、ペイントデバイスの物理座標に変換されます。物理座標に論理座標のマッピングは、によって処理され&lt;a href=&quot;qpainter&quot;&gt;QPainterの&lt;/a&gt;の&lt;a href=&quot;qpainter#combinedTransform&quot;&gt;combinedTransform&lt;/a&gt;（）、の組み合わせ&lt;a href=&quot;qpainter#viewport&quot;&gt;ビューポート&lt;/a&gt;（）と&lt;a href=&quot;qpainter#window&quot;&gt;窓&lt;/a&gt;（）と&lt;a href=&quot;qpainter#worldTransform&quot;&gt;worldTransform&lt;/a&gt;（）。&lt;a href=&quot;qpainter#viewport&quot;&gt;ビューポート&lt;/a&gt;（）、任意の矩形を特定の物理的座標を表す&lt;a href=&quot;qpainter#window&quot;&gt;ウィンドウが&lt;/a&gt;（）論理座標に同じ長方形を記述し、&lt;a href=&quot;qpainter#worldTransform&quot;&gt;worldTransform&lt;/a&gt;（）は変換行列と同じです。</target>
        </trans-unit>
        <trans-unit id="fa068ff4a5704af2221f41b1b4da90e1a41df12c" translate="yes" xml:space="preserve">
          <source>When drawing with QPainter, we specify points using logical coordinates which then are converted into the physical coordinates of the paint device. The mapping of the logical coordinates to the physical coordinates are handled by QPainter's &lt;a href=&quot;qpainter#combinedTransform&quot;&gt;combinedTransform&lt;/a&gt;(), a combination of &lt;a href=&quot;qpainter#viewport&quot;&gt;viewport&lt;/a&gt;() and &lt;a href=&quot;qpainter#window&quot;&gt;window&lt;/a&gt;() and &lt;a href=&quot;qpainter#worldTransform&quot;&gt;worldTransform&lt;/a&gt;(). The &lt;a href=&quot;qpainter#viewport&quot;&gt;viewport&lt;/a&gt;() represents the physical coordinates specifying an arbitrary rectangle, the &lt;a href=&quot;qpainter#window&quot;&gt;window&lt;/a&gt;() describes the same rectangle in logical coordinates, and the &lt;a href=&quot;qpainter#worldTransform&quot;&gt;worldTransform&lt;/a&gt;() is identical with the transformation matrix.</source>
          <target state="translated">QPainterで描画する場合、論理座標を使用してポイントを指定し、それをペイントデバイスの物理座標に変換します。論理座標から物理座標へのマッピングは、&lt;a href=&quot;qpainter#worldTransform&quot;&gt;QPainter&lt;/a&gt;の&lt;a href=&quot;qpainter#combinedTransform&quot;&gt;combinedTransform&lt;/a&gt;（）、&lt;a href=&quot;qpainter#viewport&quot;&gt;ビューポート&lt;/a&gt;（）と&lt;a href=&quot;qpainter#window&quot;&gt;ウィンドウ&lt;/a&gt;（）およびworldTransform（）の組み合わせによって処理されます。&lt;a href=&quot;qpainter#viewport&quot;&gt;ビューポート&lt;/a&gt;（）、任意の矩形を特定の物理的座標を表す&lt;a href=&quot;qpainter#window&quot;&gt;ウィンドウが&lt;/a&gt;（）論理座標に同じ長方形を記述し、&lt;a href=&quot;qpainter#worldTransform&quot;&gt;worldTransform&lt;/a&gt;（）は変換行列と同じです。</target>
        </trans-unit>
        <trans-unit id="c5ed330ed405cc570c36b8d34b32b0e9f282124b" translate="yes" xml:space="preserve">
          <source>When drawing, the pixel rendering is controlled by the &lt;a href=&quot;qpainter#RenderHint-enum&quot;&gt;QPainter::Antialiasing&lt;/a&gt; render hint.</source>
          <target state="translated">描画時のピクセルレンダリングは、&lt;a href=&quot;qpainter#RenderHint-enum&quot;&gt;QPainter :: Antialiasing&lt;/a&gt;レンダリングヒントによって制御されます。</target>
        </trans-unit>
        <trans-unit id="d15b0d71322e99bde4953dbe90c85c3ef7baf9a0" translate="yes" xml:space="preserve">
          <source>When drawing, the pixel rendering is controlled by the &lt;a href=&quot;qpainter#RenderHint-enum&quot;&gt;QPainter::Antialiasing&lt;/a&gt; render hint. The &lt;a href=&quot;qpainter#RenderHint-enum&quot;&gt;QPainter::RenderHint&lt;/a&gt; enum is used to specify flags to &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; that may or may not be respected by any given engine.</source>
          <target state="translated">描画時のピクセルレンダリングは、&lt;a href=&quot;qpainter#RenderHint-enum&quot;&gt;QPainter :: Antialiasing&lt;/a&gt;レンダリングヒントによって制御されます。&lt;a href=&quot;qpainter#RenderHint-enum&quot;&gt;QPainterの:: RenderHintの&lt;/a&gt;列挙は、フラグに指定するために使用され&lt;a href=&quot;qpainter&quot;&gt;QPainterの&lt;/a&gt;又は任意のエンジンから尊敬してもしなくてもよいです。</target>
        </trans-unit>
        <trans-unit id="6ebdf8b96fea44b5a3aed78415b3fda3d62aa0c1" translate="yes" xml:space="preserve">
          <source>When driving animations, this function should be called once after drawing has completed. Calling this function multiple times will result in a single event being delivered to the window.</source>
          <target state="translated">アニメーションを駆動する場合、この関数は描画が完了した後に一度だけ呼び出す必要があります。この関数を複数回呼び出すと、1つのイベントがウィンドウに配信されます。</target>
        </trans-unit>
        <trans-unit id="1ce5dba37bb8921ab742160f013368e5f3259059" translate="yes" xml:space="preserve">
          <source>When duplicate skipping is enabled, successive readings with the same or very similar values are omitted. This helps reducing the amount of processing done, as less sensor readings are made available. As a consequence, readings arrive at an irregular interval.</source>
          <target state="translated">重複スキップが有効になっている場合、同じ値または非常に類似した値を持つ連続した測定値は省略されます。これは、センサの読み取り値が少なくなるため、処理量を削減するのに役立ちます。その結果、読み取り値は不規則な間隔で表示されます。</target>
        </trans-unit>
        <trans-unit id="d5e3a8786c0102ae5523b4a9dad7cca51f61d1c8" translate="yes" xml:space="preserve">
          <source>When each primitive is large, this overhead is negligible, but in the case of a typical UI, there are many small items which add up to a considerable overhead.</source>
          <target state="translated">各プリミティブが大きい場合、このオーバーヘッドは無視できるほどのものですが、一般的なUIの場合、小さな項目が多く、それがかなりのオーバーヘッドになります。</target>
        </trans-unit>
        <trans-unit id="cbc38d0da8ee345ba2fd00eef535419aae91f344" translate="yes" xml:space="preserve">
          <source>When editing data in an item view, &lt;a href=&quot;qitemdelegate&quot;&gt;QItemDelegate&lt;/a&gt; provides an editor widget, which is a widget that is placed on top of the view while editing takes place. Editors are created with a &lt;a href=&quot;qitemeditorfactory&quot;&gt;QItemEditorFactory&lt;/a&gt;; a default static instance provided by &lt;a href=&quot;qitemeditorfactory&quot;&gt;QItemEditorFactory&lt;/a&gt; is installed on all item delegates. You can set a custom factory using &lt;a href=&quot;qitemdelegate#setItemEditorFactory&quot;&gt;setItemEditorFactory&lt;/a&gt;() or set a new default factory with &lt;a href=&quot;qitemeditorfactory#setDefaultFactory&quot;&gt;QItemEditorFactory::setDefaultFactory&lt;/a&gt;(). It is the data stored in the item model with the &lt;a href=&quot;qt#ItemDataRole-enum&quot;&gt;Qt::EditRole&lt;/a&gt; that is edited.</source>
          <target state="translated">アイテムビューでデータを編集するとき、&lt;a href=&quot;qitemdelegate&quot;&gt;QItemDelegate&lt;/a&gt;はエディターウィジェットを提供します。これは、編集が行われている間、ビューの上部に配置されるウィジェットです。エディターは&lt;a href=&quot;qitemeditorfactory&quot;&gt;QItemEditorFactoryで&lt;/a&gt;作成されます。&lt;a href=&quot;qitemeditorfactory&quot;&gt;QItemEditorFactory&lt;/a&gt;によって提供されるデフォルトの静的インスタンスは、すべての項目デリゲートにインストールされます。&lt;a href=&quot;qitemdelegate#setItemEditorFactory&quot;&gt;setItemEditorFactory&lt;/a&gt;（）を使用してカスタムファクトリを設定するか、&lt;a href=&quot;qitemeditorfactory#setDefaultFactory&quot;&gt;QItemEditorFactory :: setDefaultFactory&lt;/a&gt;（）を使用して新しいデフォルトファクトリを設定できます。編集されるのは、&lt;a href=&quot;qt#ItemDataRole-enum&quot;&gt;Qt :: EditRole&lt;/a&gt;を使用してアイテムモデルに格納されたデータです。</target>
        </trans-unit>
        <trans-unit id="e3121493bb1879d53220fddb4bd4e0247d179ffd" translate="yes" xml:space="preserve">
          <source>When editing data in an item view, QItemDelegate provides an editor widget, which is a widget that is placed on top of the view while editing takes place. Editors are created with a &lt;a href=&quot;qitemeditorfactory&quot;&gt;QItemEditorFactory&lt;/a&gt;; a default static instance provided by &lt;a href=&quot;qitemeditorfactory&quot;&gt;QItemEditorFactory&lt;/a&gt; is installed on all item delegates. You can set a custom factory using &lt;a href=&quot;qitemdelegate#setItemEditorFactory&quot;&gt;setItemEditorFactory&lt;/a&gt;() or set a new default factory with &lt;a href=&quot;qitemeditorfactory#setDefaultFactory&quot;&gt;QItemEditorFactory::setDefaultFactory&lt;/a&gt;(). It is the data stored in the item model with the &lt;a href=&quot;qt#ItemDataRole-enum&quot;&gt;Qt::EditRole&lt;/a&gt; that is edited.</source>
          <target state="translated">アイテムビューでデータを編集する場合、QItemDelegateはエディターウィジェットを提供します。これは、編集中にビューの上に配置されるウィジェットです。エディタは&lt;a href=&quot;qitemeditorfactory&quot;&gt;QItemEditorFactoryで&lt;/a&gt;作成されます; &lt;a href=&quot;qitemeditorfactory&quot;&gt;QItemEditorFactory&lt;/a&gt;によって提供されるデフォルトの静的インスタンスは、すべてのアイテムデリゲートにインストールされます。&lt;a href=&quot;qitemdelegate#setItemEditorFactory&quot;&gt;setItemEditorFactory&lt;/a&gt;（）を使用してカスタムファクトリを設定するか、&lt;a href=&quot;qitemeditorfactory#setDefaultFactory&quot;&gt;QItemEditorFactory :: setDefaultFactory&lt;/a&gt;（）を使用して新しいデフォルトファクトリを設定できます。編集されるのは、&lt;a href=&quot;qt#ItemDataRole-enum&quot;&gt;Qt :: EditRole&lt;/a&gt;でアイテムモデルに保存されているデータです。</target>
        </trans-unit>
        <trans-unit id="6f6344a0186d030dc605de997efbebf65f1b9a99" translate="yes" xml:space="preserve">
          <source>When editing data in an item view, editors are created and displayed by a delegate. &lt;a href=&quot;qstyleditemdelegate&quot;&gt;QStyledItemDelegate&lt;/a&gt;, which is the delegate by default installed on Qt's item views, uses a &lt;a href=&quot;qitemeditorfactory&quot;&gt;QItemEditorFactory&lt;/a&gt; to create editors for it. A default unique instance provided by &lt;a href=&quot;qitemeditorfactory&quot;&gt;QItemEditorFactory&lt;/a&gt; is used by all item delegates. If you set a new default factory with &lt;a href=&quot;qitemeditorfactory#setDefaultFactory&quot;&gt;setDefaultFactory&lt;/a&gt;(), the new factory will be used by existing and new delegates.</source>
          <target state="translated">アイテムビューでデータを編集する場合、エディターが作成され、デリゲートによって表示されます。&lt;a href=&quot;qstyleditemdelegate&quot;&gt;QStyle&lt;/a&gt;のアイテムビューにデフォルトでインストールされるデリゲートである&lt;a href=&quot;qitemeditorfactory&quot;&gt;QStyledItemDelegate&lt;/a&gt;は、QItemEditorFactoryを使用してそのエディターを作成します。&lt;a href=&quot;qitemeditorfactory&quot;&gt;QItemEditorFactory&lt;/a&gt;によって提供されるデフォルトの一意のインスタンスは、すべての項目デリゲートによって使用されます。&lt;a href=&quot;qitemeditorfactory#setDefaultFactory&quot;&gt;setDefaultFactory&lt;/a&gt;（）で新しいデフォルトファクトリを設定すると、新しいファクトリは既存のデリゲートと新しいデリゲートによって使用されます。</target>
        </trans-unit>
        <trans-unit id="4e2f4a385e37cf62cf1b97e80df94ad25fd55a99" translate="yes" xml:space="preserve">
          <source>When editing data in an item view, editors are created and displayed by a delegate. &lt;a href=&quot;qstyleditemdelegate&quot;&gt;QStyledItemDelegate&lt;/a&gt;, which is the delegate by default installed on Qt's item views, uses a QItemEditorFactory to create editors for it. A default unique instance provided by QItemEditorFactory is used by all item delegates. If you set a new default factory with &lt;a href=&quot;qitemeditorfactory#setDefaultFactory&quot;&gt;setDefaultFactory&lt;/a&gt;(), the new factory will be used by existing and new delegates.</source>
          <target state="translated">アイテムビューでデータを編集する場合、エディターはデリゲートによって作成および表示されます。&lt;a href=&quot;qstyleditemdelegate&quot;&gt;QStyledItemDelegate&lt;/a&gt; Qtのアイテムビューにインストールデフォルトでは、デリゲートで、それについてのエディターを作成するためにQItemEditorFactoryを使用しています。QItemEditorFactoryによって提供されるデフォルトの一意のインスタンスは、すべてのアイテムデリゲートによって使用されます。&lt;a href=&quot;qitemeditorfactory#setDefaultFactory&quot;&gt;setDefaultFactory&lt;/a&gt;（）を使用して新しいデフォルトファクトリを設定すると、新しいファクトリは既存のデリゲートと新しいデリゲートによって使用されます。</target>
        </trans-unit>
        <trans-unit id="c0e7a6ec88186d061ca22e9701050d741f30a191" translate="yes" xml:space="preserve">
          <source>When editing is finished, either because the line edit lost focus or Return/Enter is pressed the &lt;a href=&quot;qlineedit#editingFinished&quot;&gt;editingFinished&lt;/a&gt;() signal is emitted.</source>
          <target state="translated">編集が終了すると、ラインエディットフォーカスが失われたか、Return / Enterキーが押されたため、&lt;a href=&quot;qlineedit#editingFinished&quot;&gt;editingFinished&lt;/a&gt;（）シグナルが発行されます。</target>
        </trans-unit>
        <trans-unit id="d66bfe606de9465976bab385d92db6b5ec57c788" translate="yes" xml:space="preserve">
          <source>When editing of an item starts, this function is called with the</source>
          <target state="translated">アイテムの編集が開始されると、この関数は</target>
        </trans-unit>
        <trans-unit id="b9a4a24a7b2e2cf96998146b51d4cf55a3e5c82a" translate="yes" xml:space="preserve">
          <source>When enabled and the label shows a pixmap, it will scale the pixmap to fill the available space.</source>
          <target state="translated">この機能を有効にして、ラベルがpixmapを表示すると、利用可能なスペースを埋めるようにpixmapを拡大縮小します。</target>
        </trans-unit>
        <trans-unit id="ad099014b60b35f0bc78bdb765b7842a9c27ccc5" translate="yes" xml:space="preserve">
          <source>When enabled, making a Shape visible will not wait for the content to become available. Instead, the GUI/main thread is not blocked and the results of the path rendering are shown only when all the asynchronous work has been finished.</source>
          <target state="translated">この機能を有効にすると、シェイプを可視化してもコンテンツが利用可能になるのを待つことはありません。その代わり、GUI/メインスレッドはブロックされず、非同期の作業がすべて終了したときにのみパスレンダリングの結果が表示されます。</target>
        </trans-unit>
        <trans-unit id="809e3c2e92b5437339d00438d8ac5682f3c1094a" translate="yes" xml:space="preserve">
          <source>When enabled, making a Shape visible will not wait for the content to become available. Instead, the gui/main thread is not blocked and the results of the path rendering are shown only when all the asynchronous work has been finished.</source>
          <target state="translated">この機能を有効にすると、シェイプを可視化しても、コンテンツが利用可能になるのを待つことはありません。その代わり、GUI/メインスレッドはブロックされず、非同期の作業がすべて終了したときにのみ、パスレンダリングの結果が表示されます。</target>
        </trans-unit>
        <trans-unit id="fee807f59e511b5dcbfdf0c512929f1021ab0586" translate="yes" xml:space="preserve">
          <source>When enabled, the renderer performs a Z-prepass for opaque objects, meaning it renders them with a simple shader and color write disabled in order to get the depth buffer pre-filled before issuing draw calls for the main rendering passes.</source>
          <target state="translated">これを有効にすると、レンダラーは不透明オブジェクトに対して Z-プリパスを実行します。つまり、メインのレンダリング パスのための描画呼び出しを発行する前に深度バッファをプリフィルするために、シンプルなシェーダとカラー書き込みを無効にした状態でレンダリングします。</target>
        </trans-unit>
        <trans-unit id="fef9dffa012fb5631fc857fa121adc562514620b" translate="yes" xml:space="preserve">
          <source>When enabled, this attribute disables the delivery of mouse events to the widget and its children. Mouse events are delivered to other widgets as if the widget and its children were not present in the widget hierarchy; mouse clicks and other events effectively &quot;pass through&quot; them. This attribute is disabled by default.</source>
          <target state="translated">有効にすると、この属性は、ウィジェットとその子ウィジェットへのマウスイベントの配信を無効にします。マウスイベントは、ウィジェットとその子ウィジェットがウィジェット階層に存在しないかのように他のウィジェットに配信されます。この属性はデフォルトでは無効になっています。</target>
        </trans-unit>
        <trans-unit id="482662a30996d40d4a1c18a3374e7b2c360e9d38" translate="yes" xml:space="preserve">
          <source>When entering &quot;What's This?&quot; mode, a &lt;a href=&quot;qevent&quot;&gt;QEvent&lt;/a&gt; of type Qt::EnterWhatsThisMode is sent to all toplevel widgets.</source>
          <target state="translated">「これは何？」と入力すると モード、&lt;a href=&quot;qevent&quot;&gt;QEvent&lt;/a&gt;タイプのQtの:: EnterWhatsThisModeは、すべてのトップレベルのウィジェットに送信されます。</target>
        </trans-unit>
        <trans-unit id="6190eb6bb23c0ba0b8cd55075c9df2ea7f1a0eef" translate="yes" xml:space="preserve">
          <source>When executed together with the source-side example, the output is identical to &lt;a href=&quot;#qtro-example1&quot;&gt;Example 1&lt;/a&gt;.</source>
          <target state="translated">ソース側の例と一緒に実行すると、出力は&lt;a href=&quot;#qtro-example1&quot;&gt;例1&lt;/a&gt;と同じになります。</target>
        </trans-unit>
        <trans-unit id="c6558b3205936d1c2767fe9741a81481ab905734" translate="yes" xml:space="preserve">
          <source>When executed, QDoc will exclude the listed directories from further consideration. Files in these directories will not be read by QDoc.</source>
          <target state="translated">実行すると、QDocはリストされたディレクトリを検討対象から除外します。これらのディレクトリ内のファイルはQDocによって読み込まれません。</target>
        </trans-unit>
        <trans-unit id="c9a96d672de3f61af853bd3fb2b4ddb09401c17a" translate="yes" xml:space="preserve">
          <source>When executed, QDoc will exclude the listed directories from further consideration. Files in these directories will not be read by qdoc.</source>
          <target state="translated">実行されると、QDocはリストされたディレクトリを検討の対象から除外します。これらのディレクトリ内のファイルは qdoc によって読み込まれません。</target>
        </trans-unit>
        <trans-unit id="f0b8e30c664f1e368519b1a60f634e4ae26e999b" translate="yes" xml:space="preserve">
          <source>When executed, QDoc will ignore the directories listed. &lt;b&gt;See also&lt;/b&gt;: &lt;a href=&quot;22-qdoc-configuration-generalvariables#excludefiles&quot;&gt;excludefiles&lt;/a&gt;.</source>
          <target state="translated">実行すると、QDocはリストされたディレクトリを無視します。&lt;b&gt;参照してください&lt;/b&gt;：&lt;a href=&quot;22-qdoc-configuration-generalvariables#excludefiles&quot;&gt;excludefilesを&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ca04becdda83845f40b583b367041236f99a3f37" translate="yes" xml:space="preserve">
          <source>When executed, the first thing QDoc will do is to read through the headers specified in the &lt;a href=&quot;#headers&quot;&gt;&lt;code&gt;headers&lt;/code&gt;&lt;/a&gt; variable, and the ones located in the directories specified in the &lt;code&gt;headerdir&lt;/code&gt; variable (including all subdirectories), building an internal structure of the classes and their functions.</source>
          <target state="translated">実行されると、QDocが最初に行うことは、&lt;a href=&quot;#headers&quot;&gt; &lt;code&gt;headers&lt;/code&gt; &lt;/a&gt;変数で指定されたヘッダーと、 &lt;code&gt;headerdir&lt;/code&gt; 変数で指定されたディレクトリ（すべてのサブディレクトリを含む）にあるものを読み、クラスとその関数の内部構造を構築することです。</target>
        </trans-unit>
        <trans-unit id="5cb7e1f93541ac06ba092ca034af95b10f030b3f" translate="yes" xml:space="preserve">
          <source>When executed, the first thing QDoc will do is to read through the headers specified in the &lt;a href=&quot;10-qdoc-commands-tablesandlists#header-command&quot;&gt;&lt;code&gt;header&lt;/code&gt;&lt;/a&gt; variable, and the ones located in the directories specified in the &lt;code&gt;headerdir&lt;/code&gt; variable (including all subdirectories), building an internal structure of the classes and their functions.</source>
          <target state="translated">実行されると、QDocが最初に行うことは、&lt;a href=&quot;10-qdoc-commands-tablesandlists#header-command&quot;&gt; &lt;code&gt;header&lt;/code&gt; &lt;/a&gt;変数で指定されたヘッダーと、 &lt;code&gt;headerdir&lt;/code&gt; 変数で指定されたディレクトリ（すべてのサブディレクトリを含む）にあるものを読み取り、クラスとその関数の内部構造を構築することです。</target>
        </trans-unit>
        <trans-unit id="6f35fb24ec304ed2925435889439bd5ef8cff940" translate="yes" xml:space="preserve">
          <source>When executed, the first thing QDoc will do is to read through the headers specified in the &lt;a href=&quot;22-qdoc-configuration-generalvariables#headers&quot;&gt;&lt;code&gt;headers&lt;/code&gt;&lt;/a&gt; variable, and the ones located in the directories specified in the &lt;code&gt;headerdir&lt;/code&gt; variable (including all subdirectories), building an internal structure of the classes and their functions.</source>
          <target state="translated">実行されると、QDocが最初に行うことは、&lt;a href=&quot;22-qdoc-configuration-generalvariables#headers&quot;&gt; &lt;code&gt;headers&lt;/code&gt; &lt;/a&gt;変数で指定されたヘッダーと、 &lt;code&gt;headerdir&lt;/code&gt; 変数で指定されたディレクトリ（すべてのサブディレクトリを含む）にあるヘッダーを読み取り、クラスとその関数の内部構造を構築することです。</target>
        </trans-unit>
        <trans-unit id="5c560866c3cc063739dbdcc11819b706f643936b" translate="yes" xml:space="preserve">
          <source>When expanding environment variables, the &lt;code&gt;${variable}&lt;/code&gt; syntax has different behavior compared to &lt;code&gt;$variable&lt;/code&gt;. The former expands the content of the variable in place to be parsed as part of the configuration file, while the latter simply assigns the content as a value for the current configuration variable. This has implications if the environment variable contains a list of elements separated by whitespace, or other formatting recognized by QDoc.</source>
          <target state="translated">環境変数を展開する場合、 &lt;code&gt;${variable}&lt;/code&gt; 構文は &lt;code&gt;$variable&lt;/code&gt; とは異なる動作をします。前者は、構成ファイルの一部として解析されるように変数のコンテンツを展開しますが、後者は、現在の構成変数の値としてコンテンツを割り当てるだけです。これは、環境変数に空白で区切られた要素のリスト、またはQDocによって認識されるその他のフォーマットが含まれている場合に影響します。</target>
        </trans-unit>
        <trans-unit id="09ffff96391333a52eee7a9ad80e057863c3ba11" translate="yes" xml:space="preserve">
          <source>When expanding is true &lt;a href=&quot;qtabbar&quot;&gt;QTabBar&lt;/a&gt; will expand the tabs to use the empty space.</source>
          <target state="translated">展開がtrueの場合、&lt;a href=&quot;qtabbar&quot;&gt;QTabBar&lt;/a&gt;はタブを展開して空のスペースを使用します。</target>
        </trans-unit>
        <trans-unit id="2620b86db1234798b63f39503859611b9649e059" translate="yes" xml:space="preserve">
          <source>When exporting 9-patch images in several DPI variants (&lt;code&gt;@2x&lt;/code&gt;, &lt;code&gt;@3x&lt;/code&gt;, etc.), the 9-patch lines will typically be scaled up along with the image. There are several ways to fix this, but perhaps the simplest approach is to use &lt;a href=&quot;https://www.imagemagick.org/script/mogrify.php&quot;&gt;ImageMagick's mogrify&lt;/a&gt; tool. The tool has a &lt;code&gt;-shave&lt;/code&gt; feature that can be used to crop the image to reduce the thickness of the 9-patch lines:</source>
          <target state="translated">いくつかのDPIバリアント（ &lt;code&gt;@2x&lt;/code&gt; 、 &lt;code&gt;@3x&lt;/code&gt; など）で9パッチ画像をエクスポートする場合、通常、9パッチラインは画像とともに拡大されます。これを修正する方法はいくつかありますが、おそらく最も簡単な方法は、&lt;a href=&quot;https://www.imagemagick.org/script/mogrify.php&quot;&gt;ImageMagickのmogrify&lt;/a&gt;ツールを使用することです。このツールには、画像をトリミングして9パッチラインの太さを減らすために使用できる &lt;code&gt;-shave&lt;/code&gt; 機能があります。</target>
        </trans-unit>
        <trans-unit id="70acf7a58788a901870142345c474b753e5c2cea" translate="yes" xml:space="preserve">
          <source>When extending &lt;code&gt;QtService&lt;/code&gt;, you need to declare other items for loading all the necessary libs required for Qt, mainly the same items as in &lt;code&gt;&amp;lt;activity&amp;gt;&lt;/code&gt; section for &lt;code&gt;QtActivity&lt;/code&gt;. Add the following:</source>
          <target state="translated">&lt;code&gt;QtService&lt;/code&gt; を拡張するときは、Qtに必要なすべてのライブラリをロードするための他のアイテムを宣言する必要があります。主に &lt;code&gt;QtActivity&lt;/code&gt; の &lt;code&gt;&amp;lt;activity&amp;gt;&lt;/code&gt; セクションと同じアイテムです。以下を追加します。</target>
        </trans-unit>
        <trans-unit id="e5abd3482bf0f9993496037be30182385378e5e2" translate="yes" xml:space="preserve">
          <source>When extending &lt;code&gt;Service&lt;/code&gt;, just declare the service section as a normal Android service. Add the following inside the &lt;code&gt;&amp;lt;application&amp;gt;&lt;/code&gt; section:</source>
          <target state="translated">&lt;code&gt;Service&lt;/code&gt; 拡張するときは、サービスセクションを通常のAndroidサービスとして宣言するだけです。 &lt;code&gt;&amp;lt;application&amp;gt;&lt;/code&gt; セクション内に以下を追加します。</target>
        </trans-unit>
        <trans-unit id="dd92947bef2cbe270c8052641e8c3450b891b43e" translate="yes" xml:space="preserve">
          <source>When extending QML with C++ code, a C++ class can be registered with the QML type system to enable the class to be used as a data type within QML code. While the properties, methods and signals of any &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt;-derived class are accessible from QML, as discussed in &lt;a href=&quot;qtqml-cppintegration-exposecppattributes&quot;&gt;Exposing Attributes of C++ Types to QML&lt;/a&gt;, such a class cannot be used as a data type from QML until it is registered with the type system. Additionally registration can provide other features, such as allowing a class to be used as an instantiable &lt;a href=&quot;qtqml-typesystem-objecttypes&quot;&gt;QML object type&lt;/a&gt; from QML, or enabling a singleton instance of the class to be imported and used from QML.</source>
          <target state="translated">QMLをC ++コードで拡張する場合、C ++クラスをQML型システムに登録して、クラスをQMLコード内のデータ型として使用できるようにすることができます。&lt;a href=&quot;qtqml-cppintegration-exposecppattributes&quot;&gt;C ++タイプの属性を&lt;/a&gt;QMLに公開するで説明したように、&lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt;から派生したクラスのプロパティ、メソッド、およびシグナルにはQMLからアクセスできますが、そのようなクラスは、型システムに登録されるまでQMLからデータ型として使用できません。さらに、登録により、クラスを&lt;a href=&quot;qtqml-typesystem-objecttypes&quot;&gt;QML&lt;/a&gt;からインスタンス化可能なQMLオブジェクトタイプとして使用できるようにしたり、クラスのシングルトンインスタンスをQMLからインポートして使用できるようにしたりするなど、他の機能を提供できます。</target>
        </trans-unit>
        <trans-unit id="426d2b133ccf9d0aab48e582602ba3229910acac" translate="yes" xml:space="preserve">
          <source>When extending QML with C++ code, a C++ class can be registered with the QML type system to enable the class to be used as a data type within QML code. While the properties, methods and signals of any &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt;-derived class are accessible from QML, as discussed in &lt;a href=&quot;qtqml-cppintegration-exposecppattributes#&quot;&gt;Exposing Attributes of C++ Types to QML&lt;/a&gt;, such a class cannot be used as a data type from QML until it is registered with the type system. Additionally registration can provide other features, such as allowing a class to be used as an instantiable &lt;a href=&quot;qtqml-typesystem-objecttypes#&quot;&gt;QML object type&lt;/a&gt; from QML, or enabling a singleton instance of the class to be imported and used from QML.</source>
          <target state="translated">C ++コードでQMLを拡張する場合、C ++クラスをQML型システムに登録して、クラスをQMLコード内のデータ型として使用できるようにすることができます。&lt;a href=&quot;qtqml-cppintegration-exposecppattributes#&quot;&gt;C ++型の属性を&lt;/a&gt; QMLに公開するで説明されているように、&lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt;から派生したクラスのプロパティ、メソッド、信号にはQMLからアクセスできますが、そのようなクラスは、型システムに登録されるまでQMLからのデータ型として使用できません。さらに、登録により、クラスを&lt;a href=&quot;qtqml-typesystem-objecttypes#&quot;&gt;QML&lt;/a&gt;からインスタンス化可能なQMLオブジェクトタイプとして使用できるようにする、クラスのシングルトンインスタンスをQMLからインポートして使用できるようにするなど、他の機能を提供できます。</target>
        </trans-unit>
        <trans-unit id="9db3502d0d4498df3a64124b7eb7242bd03e84ad" translate="yes" xml:space="preserve">
          <source>When generating DITA XML, qdoc outputs the nested</source>
          <target state="translated">DITA XMLを生成する際、qdocはネストされた</target>
        </trans-unit>
        <trans-unit id="6359268011bd2e23ea07a88afa77e4d08fbb1147" translate="yes" xml:space="preserve">
          <source>When generating the reference documentation for a class, QDoc will create and link to a separate page documenting its obsolete functions. Usually an equivalent function is provided as an alternative.</source>
          <target state="translated">クラスの参照ドキュメントを生成する際、QDocはそのクラスの廃止された関数をドキュメント化した別のページを作成してリンクします。通常は、同等の関数が代替として提供されます。</target>
        </trans-unit>
        <trans-unit id="71f447939a909dfa27ce949444c9508a3a7d93da" translate="yes" xml:space="preserve">
          <source>When getting started with developing on a given embedded device, it is often necessary to verify the behavior of the device and drivers, and that the connected displays are working as they should. One easy way is to use the hellowindow example. Launching it with &lt;code&gt;-platform eglfs --multiscreen --timeout&lt;/code&gt; arguments shows a rotating Qt logo on each connected screen for a few seconds.</source>
          <target state="translated">特定の組み込みデバイスで開発を開始するとき、デバイスとドライバーの動作を確認し、接続されたディスプレイが正常に機能していることを確認する必要があることがよくあります。簡単な方法の1つは、hellowindowの例を使用することです。 &lt;code&gt;-platform eglfs --multiscreen --timeout&lt;/code&gt; 引数を指定して起動すると、接続されている各画面にQtロゴが数秒間回転します。</target>
        </trans-unit>
        <trans-unit id="b8ddc3778afe40355df31ec30ad7ce29680583ba" translate="yes" xml:space="preserve">
          <source>When handling the signal with &lt;code&gt;onLoadingChanged&lt;/code&gt;, various read-only parameters are available on the &lt;a href=&quot;qml-qtwebengine-webengineloadrequest&quot;&gt;WebEngineLoadRequest&lt;/a&gt; specified by</source>
          <target state="translated">信号取り扱う場合 &lt;code&gt;onLoadingChanged&lt;/code&gt; を、種々の読み取り専用のパラメータは、上で利用可能である&lt;a href=&quot;qml-qtwebengine-webengineloadrequest&quot;&gt;WebEngineLoadRequest&lt;/a&gt;で指定</target>
        </trans-unit>
        <trans-unit id="dd3376f42ea41d22705767c518b03411a09688ef" translate="yes" xml:space="preserve">
          <source>When handling this signal, changing the &lt;a href=&quot;qml-qtquick-mouseevent#accepted-prop&quot;&gt;accepted&lt;/a&gt; property of the</source>
          <target state="translated">この信号を処理するとき、&lt;a href=&quot;qml-qtquick-mouseevent#accepted-prop&quot;&gt;受け入れられた&lt;/a&gt;プロパティの変更</target>
        </trans-unit>
        <trans-unit id="6609fd77e98998e1210abc85df3c2fabea25a8b3" translate="yes" xml:space="preserve">
          <source>When handling this signal, if the &lt;a href=&quot;qml-qtquick-mouseevent#accepted-prop&quot;&gt;accepted&lt;/a&gt; property of the</source>
          <target state="translated">この信号を処理し、もし&lt;a href=&quot;qml-qtquick-mouseevent#accepted-prop&quot;&gt;受け入れられた&lt;/a&gt;のプロパティ</target>
        </trans-unit>
        <trans-unit id="b478004d57f010bec2ae3794bb546849c254693f" translate="yes" xml:space="preserve">
          <source>When handling this signal, use the &lt;a href=&quot;qml-qtquick-mouseevent#accepted-prop&quot;&gt;accepted&lt;/a&gt; property of the</source>
          <target state="translated">この信号を扱う場合には、使用して&lt;a href=&quot;qml-qtquick-mouseevent#accepted-prop&quot;&gt;受け入れられた&lt;/a&gt;のプロパティを</target>
        </trans-unit>
        <trans-unit id="6295b7b616f0d9112be806cf906b2998b3813947" translate="yes" xml:space="preserve">
          <source>When having multiple displays connected, the level of support for targeting one or more of these from one single Qt application varies between the platform plugins and often depends on the device and its graphics stack.</source>
          <target state="translated">複数のディスプレイを接続している場合、1つのQtアプリケーションから1つ以上のディスプレイをターゲットにするためのサポートのレベルはプラットフォームプラグインによって異なり、デバイスとそのグラフィックススタックに依存することが多いです。</target>
        </trans-unit>
        <trans-unit id="33cb76c34e5dfbfadb36579df2b883f159a00960" translate="yes" xml:space="preserve">
          <source>When implemented, this function is responsible for checking the paint engine's current</source>
          <target state="translated">実装されている場合、この関数はペイントエンジンの現在の</target>
        </trans-unit>
        <trans-unit id="cb84a9cfef6f8292ec44602b7462e414abc9870a" translate="yes" xml:space="preserve">
          <source>When implementing a custom extension class, you must use Q_DECLARE_EXTENSION_INTERFACE() to enable usage of the &lt;a href=&quot;qextensionmanager#qt_extension&quot;&gt;qt_extension&lt;/a&gt;() function. The macro is normally located right after the class definition for</source>
          <target state="translated">カスタム拡張クラスを実装するときは、Q_DECLARE_EXTENSION_INTERFACE（）を使用して&lt;a href=&quot;qextensionmanager#qt_extension&quot;&gt;qt_extension&lt;/a&gt;（）関数の使用を有効にする必要があります。マクロは通常、クラス定義の直後にあります。</target>
        </trans-unit>
        <trans-unit id="84772bea2f59837a3da39c7af78975341f21eb2b" translate="yes" xml:space="preserve">
          <source>When implementing a custom style, you cannot assume that the widget is a &lt;a href=&quot;qspinbox&quot;&gt;QSpinBox&lt;/a&gt; just because the enum value is called &lt;a href=&quot;qstyle#PrimitiveElement-enum&quot;&gt;PE_IndicatorSpinUp&lt;/a&gt; or &lt;a href=&quot;qstyle#PrimitiveElement-enum&quot;&gt;PE_IndicatorSpinDown&lt;/a&gt;.</source>
          <target state="translated">カスタムスタイルを実装する場合、列挙値が&lt;a href=&quot;qstyle#PrimitiveElement-enum&quot;&gt;PE_IndicatorSpinUp&lt;/a&gt;または&lt;a href=&quot;qstyle#PrimitiveElement-enum&quot;&gt;PE_IndicatorSpinDown&lt;/a&gt;と呼ばれているからといって、ウィジェットが&lt;a href=&quot;qspinbox&quot;&gt;QSpinBoxである&lt;/a&gt;と想定することはできません。</target>
        </trans-unit>
        <trans-unit id="869ecc6a6e96e1eee7be87f15ad29e53d15bface" translate="yes" xml:space="preserve">
          <source>When implementing a custom widget plugin, a pointer to</source>
          <target state="translated">カスタムウィジェットのプラグインを実装する際には</target>
        </trans-unit>
        <trans-unit id="b5e58b90ddc89647665b1bcd29b18d24dcef1559" translate="yes" xml:space="preserve">
          <source>When implementing a custom widget plugin, you build it as a separate library. If you want to include several custom widget plugins in the same library, you must in addition subclass &lt;a href=&quot;qdesignercustomwidgetcollectioninterface&quot;&gt;QDesignerCustomWidgetCollectionInterface&lt;/a&gt;.</source>
          <target state="translated">カスタムウィジェットプラグインを実装する場合は、別のライブラリとしてビルドします。同じライブラリに複数のカスタムウィジェットプラグインを含める場合は、さらに&lt;a href=&quot;qdesignercustomwidgetcollectioninterface&quot;&gt;QDesignerCustomWidgetCollectionInterfaceを&lt;/a&gt;サブクラス化する必要があります。</target>
        </trans-unit>
        <trans-unit id="5ea9264234b2724850203d32239a91745a3b4bcd" translate="yes" xml:space="preserve">
          <source>When implementing a custom widget plugin, you build it as a separate library. If you want to include several custom widget plugins in the same library, you must in addition subclass QDesignerCustomWidgetCollectionInterface.</source>
          <target state="translated">カスタムウィジェットプラグインを実装する場合は、別のライブラリとしてビルドします。複数のカスタムウィジェットプラグインを同じライブラリに入れたい場合は、QDesignerCustomWidgetCollectionInterfaceをサブクラス化する必要があります。</target>
        </trans-unit>
        <trans-unit id="4c647a12112d8ed46e7c8ca84107c20d588614b0" translate="yes" xml:space="preserve">
          <source>When implementing a custom widget plugin, you must subclass the &lt;a href=&quot;qdesignercustomwidgetinterface&quot;&gt;QDesignerCustomWidgetInterface&lt;/a&gt; to expose your plugin to</source>
          <target state="translated">カスタムウィジェットプラグインを実装するときは、&lt;a href=&quot;qdesignercustomwidgetinterface&quot;&gt;QDesignerCustomWidgetInterface&lt;/a&gt;をサブクラス化してプラグインを公開する必要があります。</target>
        </trans-unit>
        <trans-unit id="91021ae6ff5dfe6164732e25da258734b737eb88" translate="yes" xml:space="preserve">
          <source>When implementing a custom widget you must subclass &lt;a href=&quot;qdesignercustomwidgetinterface&quot;&gt;QDesignerCustomWidgetInterface&lt;/a&gt; to expose your widget to</source>
          <target state="translated">カスタムウィジェットを実装するときは、ウィジェットを公​​開するために&lt;a href=&quot;qdesignercustomwidgetinterface&quot;&gt;QDesignerCustomWidgetInterface&lt;/a&gt;をサブクラス化する必要があります</target>
        </trans-unit>
        <trans-unit id="98de48237e2610b3ed96ebfc3b4b3e1647ecb00b" translate="yes" xml:space="preserve">
          <source>When implementing a custom widget you must subclass QDesignerCustomWidgetInterface to expose your widget to</source>
          <target state="translated">カスタムウィジェットを実装する際には、QDesignerCustomWidgetInterfaceをサブクラス化して、ウィジェットを</target>
        </trans-unit>
        <trans-unit id="595ba0ecf978bd65b6513cd7266fa82465645c81" translate="yes" xml:space="preserve">
          <source>When implementing a model it is important to remember that &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt; does not store any data itself, it merely presents an interface that the views use to access the data. For a minimal read-only model it is only necessary to implement a few functions as there are default implementations for most of the interface. The class declaration is as follows:</source>
          <target state="translated">モデルを実装する場合、&lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt;はデータ自体を格納せず、ビューがデータにアクセスするために使用するインターフェースを提示するだけであることを覚えておくことは重要です。最小限の読み取り専用モデルでは、ほとんどのインターフェースにデフォルトの実装があるため、いくつかの関数を実装するだけで済みます。クラス宣言は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="445cd07d2a0506cd16ff907563ea7c0e381a4ac2" translate="yes" xml:space="preserve">
          <source>When implementing a new widget, it is almost always useful to reimplement &lt;a href=&quot;qwidget#sizeHint-prop&quot;&gt;sizeHint&lt;/a&gt;() to provide a reasonable default size for the widget and to set the correct size policy with &lt;a href=&quot;qwidget#sizePolicy-prop&quot;&gt;setSizePolicy&lt;/a&gt;().</source>
          <target state="translated">新しいウィジェットを実装する場合、ほとんどの場合、&lt;a href=&quot;qwidget#sizeHint-prop&quot;&gt;sizeHint&lt;/a&gt;（）を再実装してウィジェットに適切なデフォルトサイズを提供し、setSizePolicy（）で正しいサイズポリシーを設定すると&lt;a href=&quot;qwidget#sizePolicy-prop&quot;&gt;便利&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="4c9d446fde723c06b31550398f72ba270ba5a90c" translate="yes" xml:space="preserve">
          <source>When implementing a subclass of this interface, there are only a handful of functions to implement, broken down into two classes:</source>
          <target state="translated">このインターフェイスのサブクラスを実装する場合、実装する関数は2つのクラスに分解されて一握りしかありません。</target>
        </trans-unit>
        <trans-unit id="d65384984581a6d6fbb1f4f4bccbb7923f82cdc1" translate="yes" xml:space="preserve">
          <source>When implementing a subclass, you must call this function</source>
          <target state="translated">サブクラスを実装する際には、この関数を呼び出す必要があります。</target>
        </trans-unit>
        <trans-unit id="7c18f33bf2a59c6087f18cc24038056a308ad7f2" translate="yes" xml:space="preserve">
          <source>When implementing an accessibility interface for widgets, one would as a rule inherit &lt;a href=&quot;qaccessiblewidget&quot;&gt;QAccessibleWidget&lt;/a&gt;, which is a convenience class for widgets. Another available convenience class, which is inherited by &lt;a href=&quot;qaccessiblewidget&quot;&gt;QAccessibleWidget&lt;/a&gt;, is the &lt;a href=&quot;qaccessibleobject&quot;&gt;QAccessibleObject&lt;/a&gt;, which implements part of the interface for QObjects.</source>
          <target state="translated">ウィジェットの&lt;a href=&quot;qaccessiblewidget&quot;&gt;アクセシビリティー&lt;/a&gt;インターフェースを実装する場合、原則としてウィジェットの便利なクラスであるQAccessibleWidgetを継承します。&lt;a href=&quot;qaccessiblewidget&quot;&gt;QAccessibleWidget&lt;/a&gt;によって継承されるもう1つの利用可能なコンビニエンスクラスは、&lt;a href=&quot;qaccessibleobject&quot;&gt;QObjects&lt;/a&gt;のインターフェースの一部を実装するQAccessibleObjectです。</target>
        </trans-unit>
        <trans-unit id="4e43675b73f85281cf7ffd4c9feb92576f97c666" translate="yes" xml:space="preserve">
          <source>When implementing an item model (that is, a concrete &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt; subclass) one must abide to a very strict set of rules that ensure consistency for users of the model (views, proxy models, and so on).</source>
          <target state="translated">アイテムモデル（つまり、具体的な&lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt;サブクラス）を実装する場合、モデルのユーザー（ビュー、プロキシモデルなど）の一貫性を保証する非常に厳密なルールセットに従う必要があります。</target>
        </trans-unit>
        <trans-unit id="71c25ae80d1eb821bd312d0369953f3099005788" translate="yes" xml:space="preserve">
          <source>When implementing drag and drop support in a custom model, if you will return data in formats other than the default internal MIME type, reimplement this function to return your list of MIME types.</source>
          <target state="translated">カスタムモデルにドラッグ&amp;ドロップサポートを実装する際に、デフォルトの内部 MIME タイプ以外の形式でデータを返す場合は、この関数を再実装して MIME タイプのリストを返すようにしてください。</target>
        </trans-unit>
        <trans-unit id="3e1de2caa20c3401ccd297583ca14adb9e36f89e" translate="yes" xml:space="preserve">
          <source>When implementing drag and drop support in a custom model, it is possible to export items of data in specialized formats by reimplementing the following function:</source>
          <target state="translated">カスタムモデルでドラッグ&amp;ドロップ対応を実装する場合、以下の関数を再実装することで、データの項目を特殊な形式でエクスポートすることが可能です。</target>
        </trans-unit>
        <trans-unit id="891ebe7dedc591934a24e2e5c92f98ba49623d2e" translate="yes" xml:space="preserve">
          <source>When implementing styles, it is necessary to look through the code of the widgets and code of the base class and its ancestors. This is because the widgets use the style differently, because the implementation in the different styles' virtual functions can affect the state of the drawing (e.g., by altering the &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; state without restoring it and drawing some elements without using the appropriate pixel metrics and sub elements).</source>
          <target state="translated">スタイルを実装するときは、ウィジェットのコードと、基本クラスとその祖先のコードを調べる必要があります。これは、さまざまなスタイルの仮想関数の実装が描画の状態に影響を与える可能性があるため（たとえば、復元せずに&lt;a href=&quot;qpainter&quot;&gt;QPainterの&lt;/a&gt;状態を変更し、適切なピクセルメトリックとサブを使用せずに一部の要素を描画することにより）、ウィジェットが異なる方法でスタイルを使用するためです。要素）。</target>
        </trans-unit>
        <trans-unit id="1c4d91075815fdbbae33aba2b667fd4633c4c3da" translate="yes" xml:space="preserve">
          <source>When implementing the property write function, use &lt;a href=&quot;qaxbindable#requestPropertyChange&quot;&gt;requestPropertyChange&lt;/a&gt;() to get permission from the ActiveX client application to change this property. When the property changes, call &lt;a href=&quot;qaxbindable#propertyChanged&quot;&gt;propertyChanged&lt;/a&gt;() to notify the ActiveX client application about the change. If a fatal error occurs in the control, use the static &lt;a href=&quot;qaxbindable#reportError&quot;&gt;reportError&lt;/a&gt;() function to notify the client.</source>
          <target state="translated">プロパティ書き込み関数を実装するときは、&lt;a href=&quot;qaxbindable#requestPropertyChange&quot;&gt;requestPropertyChange&lt;/a&gt;（）を使用して、ActiveXクライアントアプリケーションからこのプロパティを変更するための権限を取得します。プロパティが変更されると、呼び出し&lt;a href=&quot;qaxbindable#propertyChanged&quot;&gt;にPropertyChangedを&lt;/a&gt;変更についてのActiveXクライアント・アプリケーションに通知するために（）。コントロールで致命的なエラーが発生した場合は、静的な&lt;a href=&quot;qaxbindable#reportError&quot;&gt;reportError&lt;/a&gt;（）関数を使用してクライアントに通知します。</target>
        </trans-unit>
        <trans-unit id="5c75a646668a787fcace5c55f81aa7bf0b70d1c6" translate="yes" xml:space="preserve">
          <source>When implementing the property write functions, use the &lt;a href=&quot;qaxbindable&quot;&gt;QAxBindable&lt;/a&gt; class's requestPropertyChange() and propertyChanged() functions to allow ActiveX clients to bind to the control properties.</source>
          <target state="translated">プロパティ書き込み関数を実装するときは、&lt;a href=&quot;qaxbindable&quot;&gt;QAxBindable&lt;/a&gt;クラスのrequestPropertyChange（）およびpropertyChanged（）関数を使用して、ActiveXクライアントがコントロールプロパティにバインドできるようにします。</target>
        </trans-unit>
        <trans-unit id="7b41031e55866a68b8184e142ce7198e2e1fe7ec" translate="yes" xml:space="preserve">
          <source>When implementing this function in subclasses of this class, you must construct and return new editor widgets with the parent widget specified.</source>
          <target state="translated">このクラスのサブクラスでこの関数を実装する場合は、親ウィジェットを指定して新しいエディタウィジェットを構築して返す必要があります。</target>
        </trans-unit>
        <trans-unit id="ca2afb7bc6684dc128113496ad1b730a33a4cb98" translate="yes" xml:space="preserve">
          <source>When implementing this function in subclasses, you must ensure that the editor widget's property specified by this function can accept the type the creator is registered for. For example, a creator which constructs &lt;a href=&quot;qcheckbox&quot;&gt;QCheckBox&lt;/a&gt; widgets to edit boolean values would return the &lt;a href=&quot;qabstractbutton#checkable-prop&quot;&gt;checkable&lt;/a&gt; property name from this function, and must be registered in the item editor factory for the &lt;a href=&quot;qmetatype#Type-enum&quot;&gt;QMetaType::Bool&lt;/a&gt; type.</source>
          <target state="translated">この関数をサブクラスに実装する場合、この関数で指定されたエディターウィジェットのプロパティが、作成者が登録されているタイプを受け入れることができることを確認する必要があります。たとえば、ブール値を編集するために&lt;a href=&quot;qcheckbox&quot;&gt;QCheckBox&lt;/a&gt;ウィジェットを作成する作成者は、この関数から&lt;a href=&quot;qabstractbutton#checkable-prop&quot;&gt;チェック可能な&lt;/a&gt;プロパティ名を返し、&lt;a href=&quot;qmetatype#Type-enum&quot;&gt;QMetaType :: Bool&lt;/a&gt;タイプのアイテムエディターファクトリに登録する必要があります。</target>
        </trans-unit>
        <trans-unit id="1591d2c3ab41219fe3e148cfbb0593be15c3c678" translate="yes" xml:space="preserve">
          <source>When implementing this function in subclasses, you must ensure that the editor widget's property specified by this function can accept the type the creator is registered for. For example, a creator which constructs &lt;a href=&quot;qcheckbox&quot;&gt;QCheckBox&lt;/a&gt; widgets to edit boolean values would return the &lt;a href=&quot;qabstractbutton#checkable-prop&quot;&gt;checkable&lt;/a&gt; property name from this function, and must be registered in the item editor factory for the QVariant::Bool type.</source>
          <target state="translated">この関数をサブクラスで実装する場合、この関数で指定されたエディターウィジェットのプロパティが、作成者が登録されているタイプを受け入れることができることを確認する必要があります。たとえば、ブール値を編集する&lt;a href=&quot;qcheckbox&quot;&gt;QCheckBox&lt;/a&gt;ウィジェットを作成する作成者は、この関数から&lt;a href=&quot;qabstractbutton#checkable-prop&quot;&gt;チェック可能な&lt;/a&gt;プロパティ名を返し、QVariant :: Bool型のアイテムエディターファクトリに登録する必要があります。</target>
        </trans-unit>
        <trans-unit id="8ce39d7538e9c5292578832459d332de3effbff1" translate="yes" xml:space="preserve">
          <source>When implementing this interface you will almost certainly also want to implement &lt;a href=&quot;qaccessibletextinterface&quot;&gt;QAccessibleTextInterface&lt;/a&gt;.</source>
          <target state="translated">このインターフェイスを実装するときは、ほぼ確実に&lt;a href=&quot;qaccessibletextinterface&quot;&gt;QAccessibleTextInterface&lt;/a&gt;も実装する必要があります。</target>
        </trans-unit>
        <trans-unit id="6268d96d04a4d653a0acc9732f0ac32216ce55c6" translate="yes" xml:space="preserve">
          <source>When implementing you own custom graphics transform, you must call this function every time you change a parameter, to let &lt;a href=&quot;qgraphicsitem&quot;&gt;QGraphicsItem&lt;/a&gt; know that its transformation needs to be updated.</source>
          <target state="translated">独自のカスタムグラフィック変換を実装する場合、パラメーターを変更するたびにこの関数を呼び出して、変換を更新する必要があることを&lt;a href=&quot;qgraphicsitem&quot;&gt;QGraphicsItemに通知&lt;/a&gt;する必要があります。</target>
        </trans-unit>
        <trans-unit id="e0faa4d1d0c8b9ed5d373ba76a73de237e335d71" translate="yes" xml:space="preserve">
          <source>When implementing your own implicitly shared classes, use the &lt;a href=&quot;qshareddata&quot;&gt;QSharedData&lt;/a&gt; and &lt;a href=&quot;qshareddatapointer&quot;&gt;QSharedDataPointer&lt;/a&gt; classes.</source>
          <target state="translated">独自の暗黙のうちに共有クラスを実装する場合、使用&lt;a href=&quot;qshareddata&quot;&gt;QSharedData&lt;/a&gt;と&lt;a href=&quot;qshareddatapointer&quot;&gt;QSharedDataPointer&lt;/a&gt;クラスを。</target>
        </trans-unit>
        <trans-unit id="ed089988e57c5a0f9eb64a54af80f4e4cc7da5be" translate="yes" xml:space="preserve">
          <source>When implementing your own itemview setSelection should call &lt;a href=&quot;qabstractitemview#selectionModel&quot;&gt;selectionModel&lt;/a&gt;()-&amp;gt;select(selection, flags) where selection is either an empty &lt;a href=&quot;qmodelindex&quot;&gt;QModelIndex&lt;/a&gt; or a &lt;a href=&quot;qitemselection&quot;&gt;QItemSelection&lt;/a&gt; that contains all items that are contained in</source>
          <target state="translated">独自のitemviewのsetSelectionを実装する場合は呼び出す必要があり&lt;a href=&quot;qabstractitemview#selectionModel&quot;&gt;selectionModelのを&lt;/a&gt;（） - &amp;gt;選択範囲が空のどちらかである（選択、フラグ）を選択&lt;a href=&quot;qmodelindex&quot;&gt;QModelIndex&lt;/a&gt;または&lt;a href=&quot;qitemselection&quot;&gt;QItemSelection&lt;/a&gt;に含まれているすべての項目が含まれていることを</target>
        </trans-unit>
        <trans-unit id="90d1ebe5eabb55f03ec9c6da6079f40a2ff77a3d" translate="yes" xml:space="preserve">
          <source>When implementing your own style and customizing controls, there are some points to keep in mind to ensure that your application is as performant as possible.</source>
          <target state="translated">独自のスタイルを実装し、コントロールをカスタマイズする際には、アプリケーションが可能な限りパフォーマンスを発揮できるようにするために、心に留めておくべきポイントがいくつかあります。</target>
        </trans-unit>
        <trans-unit id="b13759dc0478b7385db4120f936b29bbec97142e" translate="yes" xml:space="preserve">
          <source>When importing a &lt;a href=&quot;qtqml-typesystem-objecttypes&quot;&gt;QML object type&lt;/a&gt; with a property alias in the root object, however, the property appear as a regular Qt property and consequently can be used in alias references.</source>
          <target state="translated">ただし、ルートオブジェクトにプロパティエイリアスを持つ&lt;a href=&quot;qtqml-typesystem-objecttypes&quot;&gt;QMLオブジェクトタイプ&lt;/a&gt;をインポートすると、プロパティは通常のQtプロパティとして表示されるため、エイリアス参照で使用できます。</target>
        </trans-unit>
        <trans-unit id="6d2c6cac0080194cff24d54acaddace27ee77592" translate="yes" xml:space="preserve">
          <source>When importing a &lt;a href=&quot;qtqml-typesystem-objecttypes#&quot;&gt;QML object type&lt;/a&gt; with a property alias in the root object, however, the property appear as a regular Qt property and consequently can be used in alias references.</source>
          <target state="translated">ただし、ルートオブジェクトにプロパティエイリアスを持つ&lt;a href=&quot;qtqml-typesystem-objecttypes#&quot;&gt;QMLオブジェクトタイプ&lt;/a&gt;をインポートすると、プロパティは通常のQtプロパティとして表示されるため、エイリアス参照で使用できます。</target>
        </trans-unit>
        <trans-unit id="63972382ca72bfae9a1039f20443d3527d3f328d" translate="yes" xml:space="preserve">
          <source>When in Running state, &lt;a href=&quot;qtimeline&quot;&gt;QTimeLine&lt;/a&gt; also emits the &lt;a href=&quot;qtimeline#frameChanged&quot;&gt;frameChanged&lt;/a&gt;() signal when the frame changes.</source>
          <target state="translated">稼動状態に、場合&lt;a href=&quot;qtimeline&quot;&gt;QTimeLineは&lt;/a&gt;また発する&lt;a href=&quot;qtimeline#frameChanged&quot;&gt;frameChanged&lt;/a&gt;（）信号フレームを変更したとき。</target>
        </trans-unit>
        <trans-unit id="ef3e888a5ecf29cb8462a72debc447a17e27543a" translate="yes" xml:space="preserve">
          <source>When in StrictMode, if a parsing error is found, &lt;a href=&quot;qurl#isValid&quot;&gt;isValid&lt;/a&gt;() will return &lt;code&gt;false&lt;/code&gt; and &lt;a href=&quot;qurl#errorString&quot;&gt;errorString&lt;/a&gt;() will return a message describing the error. If more than one error is detected, it is undefined which error gets reported.</source>
          <target state="translated">StrictModeでは、解析エラーが見つかった場合、&lt;a href=&quot;qurl#isValid&quot;&gt;isValid&lt;/a&gt;（）は &lt;code&gt;false&lt;/code&gt; を返し、&lt;a href=&quot;qurl#errorString&quot;&gt;errorString&lt;/a&gt;（）はエラーを説明するメッセージを返します。複数のエラーが検出された場合、どのエラーが報告されるかは未定義です。</target>
        </trans-unit>
        <trans-unit id="3456c56afa83ec7dbd61d985f62e50c29f6549e1" translate="yes" xml:space="preserve">
          <source>When in keyboard-interactive mode, you can use the arrow and page keys to either move or resize the window. This property controls the arrow keys. The common way to enter keyboard interactive mode is to enter the subwindow menu, and select either &quot;resize&quot; or &quot;move&quot;.</source>
          <target state="translated">キーボード・インタラクティブ・モードの場合、矢印キーとページ・キーを使用して、ウィンドウの移動またはサイズ変更を行うことができます。このプロパティは、矢印キーを制御します。キーボードインタラクティブモードに入る一般的な方法は、サブウィンドウメニューに入り、「サイズ変更」または「移動」のいずれかを選択することです。</target>
        </trans-unit>
        <trans-unit id="3fb322ebc9c9cd2d657c0fb9d224a6635a538d7d" translate="yes" xml:space="preserve">
          <source>When in keyboard-interactive mode, you can use the arrow and page keys to either move or resize the window. This property controls the page keys. The common way to enter keyboard interactive mode is to enter the subwindow menu, and select either &quot;resize&quot; or &quot;move&quot;.</source>
          <target state="translated">キーボード・インタラクティブ・モードでは、矢印キーとページ・キーを使用して、ウィンドウの移動またはサイズ変更を行うことができます。このプロパティは、ページキーを制御します。キーボードインタラクティブモードに入る一般的な方法は、サブウィンドウメニューに入り、「サイズ変更」または「移動」のいずれかを選択することです。</target>
        </trans-unit>
        <trans-unit id="2c08753db2a8aa137364ee7093529568335fe121" translate="yes" xml:space="preserve">
          <source>When inheriting &lt;a href=&quot;qabstractscrollarea&quot;&gt;QAbstractScrollArea&lt;/a&gt;, you need to do the following:</source>
          <target state="translated">&lt;a href=&quot;qabstractscrollarea&quot;&gt;QAbstractScrollAreaを&lt;/a&gt;継承する場合、次のことを行う必要があります。</target>
        </trans-unit>
        <trans-unit id="9110d9a8dc385178c6df16681bf45970bc611881" translate="yes" xml:space="preserve">
          <source>When inheriting QAbstractScrollArea, you need to do the following:</source>
          <target state="translated">QAbstractScrollAreaを継承する場合は、以下のようにする必要があります。</target>
        </trans-unit>
        <trans-unit id="ef5ec1307e1565c3ba533b6306e4c4fb6e84f432" translate="yes" xml:space="preserve">
          <source>When inserting action items you usually specify a receiver and a slot. The receiver will be notifed whenever the item is &lt;a href=&quot;qaction#triggered&quot;&gt;triggered()&lt;/a&gt;. In addition, &lt;a href=&quot;qmenu&quot;&gt;QMenu&lt;/a&gt; provides two signals, &lt;a href=&quot;qmenu#triggered&quot;&gt;triggered&lt;/a&gt;() and &lt;a href=&quot;qmenu#hovered&quot;&gt;hovered&lt;/a&gt;(), which signal the &lt;a href=&quot;qaction&quot;&gt;QAction&lt;/a&gt; that was triggered from the menu.</source>
          <target state="translated">アクションアイテムを挿入するときは、通常、レシーバーとスロットを指定します。アイテムが&lt;a href=&quot;qaction#triggered&quot;&gt;triggered（）に&lt;/a&gt;なると、レシーバーに通知されます。また、&lt;a href=&quot;qmenu&quot;&gt;QMenuは、&lt;/a&gt; 2つの信号を提供&lt;a href=&quot;qmenu#triggered&quot;&gt;トリガ&lt;/a&gt;（）と&lt;a href=&quot;qmenu#hovered&quot;&gt;推移&lt;/a&gt;信号（）、&lt;a href=&quot;qaction&quot;&gt;QAction&lt;/a&gt;メニューからトリガされました。</target>
        </trans-unit>
        <trans-unit id="b0a12f123004137273217a41fe960ac1382b53f8" translate="yes" xml:space="preserve">
          <source>When inserting action items you usually specify a receiver and a slot. The receiver will be notifed whenever the item is &lt;a href=&quot;qaction#triggered&quot;&gt;triggered()&lt;/a&gt;. In addition, QMenu provides two signals, &lt;a href=&quot;qmenu#triggered&quot;&gt;triggered&lt;/a&gt;() and &lt;a href=&quot;qmenu#hovered&quot;&gt;hovered&lt;/a&gt;(), which signal the &lt;a href=&quot;qaction&quot;&gt;QAction&lt;/a&gt; that was triggered from the menu.</source>
          <target state="translated">アクションアイテムを挿入するときは、通常、レシーバーとスロットを指定します。アイテムが&lt;a href=&quot;qaction#triggered&quot;&gt;triggered（）さ&lt;/a&gt;れるたびに、レシーバーに通知されます。また、QMenuは、2つの信号提供&lt;a href=&quot;qmenu#triggered&quot;&gt;トリガ&lt;/a&gt;（）と&lt;a href=&quot;qmenu#hovered&quot;&gt;推移&lt;/a&gt;信号（）、&lt;a href=&quot;qaction&quot;&gt;QAction&lt;/a&gt;メニューからトリガされました。</target>
        </trans-unit>
        <trans-unit id="864005fb46a1674119933552576b5eb471667e9c" translate="yes" xml:space="preserve">
          <source>When inserting multiple records, you only need to call &lt;a href=&quot;qsqlquery#prepare&quot;&gt;QSqlQuery::prepare&lt;/a&gt;() once. Then you call &lt;a href=&quot;qsqlquery#bindValue&quot;&gt;bindValue()&lt;/a&gt; or &lt;a href=&quot;qsqlquery#addBindValue&quot;&gt;addBindValue()&lt;/a&gt; followed by &lt;a href=&quot;qsqlquery#exec-1&quot;&gt;exec()&lt;/a&gt; as many times as necessary.</source>
          <target state="translated">複数のレコードを挿入するときは、&lt;a href=&quot;qsqlquery#prepare&quot;&gt;QSqlQuery :: prepare&lt;/a&gt;（）を一度だけ呼び出す必要があります。次に、&lt;a href=&quot;qsqlquery#bindValue&quot;&gt;bindValue（）&lt;/a&gt;または&lt;a href=&quot;qsqlquery#addBindValue&quot;&gt;addBindValue（）&lt;/a&gt;を呼び出し、続いて必要な回数だけ&lt;a href=&quot;qsqlquery#exec-1&quot;&gt;exec（）&lt;/a&gt;を呼び出します。</target>
        </trans-unit>
        <trans-unit id="f4a6a2c17602b8ef1614b658343d290c1bd56516" translate="yes" xml:space="preserve">
          <source>When inserting such a fragment into a &lt;a href=&quot;qtextdocument&quot;&gt;QTextDocument&lt;/a&gt; the current char format of the &lt;a href=&quot;qtextcursor&quot;&gt;QTextCursor&lt;/a&gt; used for insertion is used as format for the text.</source>
          <target state="translated">挿入するときに、そのような断片&lt;a href=&quot;qtextdocument&quot;&gt;QTextDocument&lt;/a&gt;の現在チャーフォーマット&lt;a href=&quot;qtextcursor&quot;&gt;QTextCursorは、&lt;/a&gt;挿入のために使用されるが、テキストの形式として使用されます。</target>
        </trans-unit>
        <trans-unit id="6ee49651f87fc18143f2662752cc1cf4e9cb8b10" translate="yes" xml:space="preserve">
          <source>When integrating existing classes and technology into QML, APIs will often need tweaking to fit better into the declarative environment. Although the best results are usually obtained by modifying the original classes directly, if this is either not possible or is complicated by some other concerns, extension objects allow limited extension possibilities without direct modifications.</source>
          <target state="translated">既存のクラスや技術をQMLに統合する際には、APIをより良い宣言環境に適合させるための調整が必要になることがよくあります。通常は元のクラスを直接変更することで最良の結果を得ることができますが、それが不可能であったり、他の問題があって複雑であったりする場合には、拡張オブジェクトを使用することで、直接変更せずに制限された拡張の可能性を得ることができます。</target>
        </trans-unit>
        <trans-unit id="a1d7f8c8a007cd8aa13b4d3a21b00e026e596090" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;gui-changes-qt6#qfont&quot;&gt;QFont&lt;/a&gt; value &lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into a &lt;code&gt;font&lt;/code&gt; value, and vice-versa.</source>
          <target state="translated">C ++と統合する場合、C ++&lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;からQMLに渡された&lt;/a&gt;&lt;a href=&quot;gui-changes-qt6#qfont&quot;&gt;QFont&lt;/a&gt;値は自動的に &lt;code&gt;font&lt;/code&gt; 値に変換され、その逆も同様であることに注意してください。</target>
        </trans-unit>
        <trans-unit id="46cd534349e4b4409b3a901102a23c1cbd1d64c6" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qcolor&quot;&gt;QColor&lt;/a&gt; value &lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into a &lt;code&gt;color&lt;/code&gt; value, and vice-versa.</source>
          <target state="translated">C ++と統合する場合、C ++ &lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;からQMLに渡される&lt;/a&gt;&lt;a href=&quot;qcolor&quot;&gt;QColor&lt;/a&gt;値はすべて自動的に &lt;code&gt;color&lt;/code&gt; 値に変換され、その逆も同様です。</target>
        </trans-unit>
        <trans-unit id="59e07d9cc2cac329614b7169422187bba763b0d8" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt; or &lt;a href=&quot;qdatetime&quot;&gt;QDateTime&lt;/a&gt; value &lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into a &lt;code&gt;date&lt;/code&gt; value, and vice-versa. Note, however, that converting a &lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt; will result in UTC's start of the day, which falls on a different date in some other time-zones. It is usually more robust to convert the &lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt; via a &lt;a href=&quot;qdatetime&quot;&gt;QDateTime&lt;/a&gt; explicitly, specifying local-time or a relevant time-zone and selecting a time of day (such as noon) that reliably exists (daylight-savings transitions skip an hour, near one end or the other of a day).</source>
          <target state="translated">C ++と統合する場合、C ++&lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;からQMLに渡された&lt;/a&gt;&lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt;または&lt;a href=&quot;qdatetime&quot;&gt;QDateTime&lt;/a&gt;値は、自動的に &lt;code&gt;date&lt;/code&gt; 値に変換され、その逆も同様であることに注意してください。ただし、&lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt;を変換すると、UTCの1日の始まりが発生し、他の一部のタイムゾーンでは異なる日付になることに注意してください。通常、&lt;a href=&quot;qdate&quot;&gt;QDateTime&lt;/a&gt;を介して&lt;a href=&quot;qdatetime&quot;&gt;QDateを&lt;/a&gt;明示的に変換し、現地時間または関連するタイムゾーンを指定し、確実に存在する時刻（正午など）を選択する方が堅牢です（夏時間の遷移は、一方の端の近くで1時間スキップします）または他の日）。</target>
        </trans-unit>
        <trans-unit id="94f4f40b3918cac601587862fbf8acc3e95d325a" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt; or &lt;a href=&quot;qdatetime&quot;&gt;QDateTime&lt;/a&gt; value &lt;a href=&quot;qtqml-cppintegration-data#&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into a &lt;code&gt;date&lt;/code&gt; value, and vice-versa. Note, however, that converting a &lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt; will result in UTC's start of the day, which falls on a different date in some other time-zones. It is usually more robust to convert the &lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt; via a &lt;a href=&quot;qdatetime&quot;&gt;QDateTime&lt;/a&gt; explicitly, specifying local-time or a relevant time-zone and selecting a time of day (such as noon) that reliably exists (daylight-savings transitions skip an hour, near one end or the other of a day).</source>
          <target state="translated">C ++と統合する場合、C ++ &lt;a href=&quot;qtqml-cppintegration-data#&quot;&gt;からQMLに渡された&lt;/a&gt;&lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt;または&lt;a href=&quot;qdatetime&quot;&gt;QDateTime&lt;/a&gt;値はすべて自動的に &lt;code&gt;date&lt;/code&gt; 値に変換され、その逆も同様です。ただし、&lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt;を変換するとUTCの1日の始まりとなり、他のタイムゾーンでは異なる日付になることに注意してください。通常、&lt;a href=&quot;qdate&quot;&gt;QDateTime&lt;/a&gt;を介して&lt;a href=&quot;qdatetime&quot;&gt;QDateを&lt;/a&gt;明示的に変換し、現地時間または関連するタイムゾーンを指定し、確実に存在する時刻（正午など）を選択する方がより堅牢です（夏時間の移行では、1時間近くで1時間スキップされますまたはその他の1日）。</target>
        </trans-unit>
        <trans-unit id="2a3e9ea44f85bb16e221814f180ac27358c1f643" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qfont&quot;&gt;QFont&lt;/a&gt; value &lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into a &lt;code&gt;font&lt;/code&gt; value, and vice-versa.</source>
          <target state="translated">C ++と統合する場合、C ++ &lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;からQMLに渡される&lt;/a&gt;&lt;a href=&quot;qfont&quot;&gt;QFont&lt;/a&gt;値はすべて自動的に &lt;code&gt;font&lt;/code&gt; 値に変換され、その逆も同様です。</target>
        </trans-unit>
        <trans-unit id="c80b7cd162c43b0104ef58b6d7d770bb2b3dc0c9" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qgeocircle&quot;&gt;QGeoCircle&lt;/a&gt; value passed into QML from C++ is automatically converted into a &lt;code&gt;geocircle&lt;/code&gt; value, and vise-versa.</source>
          <target state="translated">C ++と統合する場合、C ++ からQMLに渡される&lt;a href=&quot;qgeocircle&quot;&gt;QGeoCircle&lt;/a&gt;値は自動的に &lt;code&gt;geocircle&lt;/code&gt; 値に変換され、逆も同様です。</target>
        </trans-unit>
        <trans-unit id="f90dc519be0e60fb444dc1c5260f47cc6cd907ee" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qgeocoordinate&quot;&gt;QGeoCoordinate&lt;/a&gt; value passed into QML from C++ is automatically converted into a &lt;code&gt;coordinate&lt;/code&gt; value, and vice-versa.</source>
          <target state="translated">C ++と統合する場合、C ++ からQMLに渡される&lt;a href=&quot;qgeocoordinate&quot;&gt;QGeoCoordinate&lt;/a&gt;値は自動的に &lt;code&gt;coordinate&lt;/code&gt; 値に変換され、その逆も同様です。</target>
        </trans-unit>
        <trans-unit id="c5bbf6333d877f577a96dba2b55b5c884f293ae5" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qgeopath&quot;&gt;QGeoPath&lt;/a&gt; value passed into QML from C++ is automatically converted into a &lt;code&gt;geopath&lt;/code&gt; value, and vice versa.</source>
          <target state="translated">C ++と統合する場合、C ++ からQMLに渡される&lt;a href=&quot;qgeopath&quot;&gt;QGeoPath&lt;/a&gt;値は自動的に &lt;code&gt;geopath&lt;/code&gt; 値に変換され、その逆も同様です。</target>
        </trans-unit>
        <trans-unit id="fc4029c75e55b88c42d4329274584c8e9c0128eb" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qgeopolygon&quot;&gt;QGeoPolygon&lt;/a&gt; value passed into QML is automatically converted into a &lt;code&gt;geopolygon&lt;/code&gt;, and vice versa.</source>
          <target state="translated">C ++と統合する場合、QMLに渡される&lt;a href=&quot;qgeopolygon&quot;&gt;QGeoPolygon&lt;/a&gt;値は自動的に &lt;code&gt;geopolygon&lt;/code&gt; に変換され、その逆も同様です。</target>
        </trans-unit>
        <trans-unit id="a7dba58612710895f3116ae91ec3e71bc80778eb" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qgeorectangle&quot;&gt;QGeoRectangle&lt;/a&gt; value passed into QML from C++ is automatically converted into a &lt;code&gt;georectangle&lt;/code&gt; value, and vice-versa.</source>
          <target state="translated">C ++と統合する場合、C ++ からQMLに渡される&lt;a href=&quot;qgeorectangle&quot;&gt;QGeoRectangle&lt;/a&gt;値は自動的に &lt;code&gt;georectangle&lt;/code&gt; 値に変換され、その逆も同様です。</target>
        </trans-unit>
        <trans-unit id="4d5c3d73097853ceb2db3f5a71a11d6fad5cb8d2" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qgeoshape&quot;&gt;QGeoShape&lt;/a&gt; value passed into QML from C++ is automatically converted into a &lt;code&gt;geoshape&lt;/code&gt; value, and vice-versa.</source>
          <target state="translated">C ++と統合する場合、C ++ からQMLに渡される&lt;a href=&quot;qgeoshape&quot;&gt;QGeoShape&lt;/a&gt;値は自動的に &lt;code&gt;geoshape&lt;/code&gt; 値に変換され、その逆も同様です。</target>
        </trans-unit>
        <trans-unit id="babd158b5780227850bc5ed9c758d5d58d7cd1f2" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qpoint&quot;&gt;QPoint&lt;/a&gt; or &lt;a href=&quot;qpointf&quot;&gt;QPointF&lt;/a&gt; value &lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into a &lt;code&gt;point&lt;/code&gt; value. When a &lt;code&gt;point&lt;/code&gt; value is passed to C++, it is automatically converted into a &lt;a href=&quot;qpointf&quot;&gt;QPointF&lt;/a&gt; value.</source>
          <target state="translated">C ++と統合する場合、C ++&lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;からQMLに渡された&lt;/a&gt;&lt;a href=&quot;qpoint&quot;&gt;QPoint&lt;/a&gt;または&lt;a href=&quot;qpointf&quot;&gt;QPointF&lt;/a&gt;値は、自動的に &lt;code&gt;point&lt;/code&gt; 値に変換されることに注意してください。場合 &lt;code&gt;point&lt;/code&gt; 値をC ++に渡され、それが自動的に変換され&lt;a href=&quot;qpointf&quot;&gt;QPointFの&lt;/a&gt;値。</target>
        </trans-unit>
        <trans-unit id="06f6b135e98805bdd8065da59a778cd9f4c5215e" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qpoint&quot;&gt;QPoint&lt;/a&gt; or &lt;a href=&quot;qpointf&quot;&gt;QPointF&lt;/a&gt; value &lt;a href=&quot;qtqml-cppintegration-data#&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into a &lt;code&gt;point&lt;/code&gt; value. When a &lt;code&gt;point&lt;/code&gt; value is passed to C++, it is automatically converted into a &lt;a href=&quot;qpointf&quot;&gt;QPointF&lt;/a&gt; value.</source>
          <target state="translated">C ++と統合する場合、C ++ &lt;a href=&quot;qtqml-cppintegration-data#&quot;&gt;からQMLに渡される&lt;/a&gt;&lt;a href=&quot;qpoint&quot;&gt;QPoint&lt;/a&gt;または&lt;a href=&quot;qpointf&quot;&gt;QPointF&lt;/a&gt;値は自動的に &lt;code&gt;point&lt;/code&gt; 値に変換されることに注意してください。場合 &lt;code&gt;point&lt;/code&gt; 値をC ++に渡され、それが自動的に変換され&lt;a href=&quot;qpointf&quot;&gt;QPointFの&lt;/a&gt;値。</target>
        </trans-unit>
        <trans-unit id="a84623eea3626c41bb0f62625b89382e6a0884d2" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qqmllistproperty&quot;&gt;QQmlListProperty&lt;/a&gt; value &lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into a &lt;code&gt;list&lt;/code&gt; value, and vice-versa.</source>
          <target state="translated">C ++と統合する場合、C ++&lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;からQMLに渡された&lt;/a&gt;&lt;a href=&quot;qqmllistproperty&quot;&gt;QQmlListProperty&lt;/a&gt;値は自動的に &lt;code&gt;list&lt;/code&gt; 値に変換され、その逆も同様であることに注意してください。</target>
        </trans-unit>
        <trans-unit id="4537d2f61ed5eb33aa48c28e4d1f2cbe5739fee6" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qqmllistproperty&quot;&gt;QQmlListProperty&lt;/a&gt; value &lt;a href=&quot;qtqml-cppintegration-data#&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into a &lt;code&gt;list&lt;/code&gt; value, and vice-versa.</source>
          <target state="translated">C ++と統合する場合、C ++ &lt;a href=&quot;qtqml-cppintegration-data#&quot;&gt;からQMLに渡される&lt;/a&gt;&lt;a href=&quot;qqmllistproperty&quot;&gt;QQmlListProperty&lt;/a&gt;値はすべて自動的に &lt;code&gt;list&lt;/code&gt; 値に変換され、その逆も同様です。</target>
        </trans-unit>
        <trans-unit id="892030f32ca7d95430d43e3adb51ab41646ac62c" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qrect&quot;&gt;QRect&lt;/a&gt; or &lt;a href=&quot;qrectf&quot;&gt;QRectF&lt;/a&gt; value &lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into a &lt;code&gt;rect&lt;/code&gt; value, and vice-versa. When a &lt;code&gt;rect&lt;/code&gt; value is passed to C++, it is automatically converted into a &lt;a href=&quot;qrectf&quot;&gt;QRectF&lt;/a&gt; value.</source>
          <target state="translated">C ++と統合する場合、C ++&lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;からQMLに渡された&lt;/a&gt;&lt;a href=&quot;qrect&quot;&gt;QRect&lt;/a&gt;または&lt;a href=&quot;qrectf&quot;&gt;QRectF&lt;/a&gt;値は、自動的に &lt;code&gt;rect&lt;/code&gt; 値に変換され、その逆も同様であることに注意してください。場合 &lt;code&gt;rect&lt;/code&gt; 値をC ++に渡され、それが自動的に変換され&lt;a href=&quot;qrectf&quot;&gt;QRectFの&lt;/a&gt;値。</target>
        </trans-unit>
        <trans-unit id="bde76fc240f3c1a3b45734a6b9372df275b0771e" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qrect&quot;&gt;QRect&lt;/a&gt; or &lt;a href=&quot;qrectf&quot;&gt;QRectF&lt;/a&gt; value &lt;a href=&quot;qtqml-cppintegration-data#&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into a &lt;code&gt;rect&lt;/code&gt; value, and vice-versa. When a &lt;code&gt;rect&lt;/code&gt; value is passed to C++, it is automatically converted into a &lt;a href=&quot;qrectf&quot;&gt;QRectF&lt;/a&gt; value.</source>
          <target state="translated">C ++と統合する場合、C ++ &lt;a href=&quot;qtqml-cppintegration-data#&quot;&gt;からQMLに渡される&lt;/a&gt;すべての&lt;a href=&quot;qrect&quot;&gt;QRect&lt;/a&gt;または&lt;a href=&quot;qrectf&quot;&gt;QRectF&lt;/a&gt;値は自動的に &lt;code&gt;rect&lt;/code&gt; 値に変換され、その逆も同様です。場合 &lt;code&gt;rect&lt;/code&gt; 値をC ++に渡され、それが自動的に変換され&lt;a href=&quot;qrectf&quot;&gt;QRectFの&lt;/a&gt;値。</target>
        </trans-unit>
        <trans-unit id="e7418f4bf29ec0eb129b2a465879400da12bc2de" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qsize&quot;&gt;QSize&lt;/a&gt; or &lt;a href=&quot;qsizef&quot;&gt;QSizeF&lt;/a&gt; value &lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into a &lt;code&gt;size&lt;/code&gt; value, and vice-versa. When a &lt;code&gt;size&lt;/code&gt; value is passed to C++, it is automatically converted into a &lt;a href=&quot;qsizef&quot;&gt;QSizeF&lt;/a&gt; value.</source>
          <target state="translated">C ++と統合する場合、C ++&lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;からQMLに渡された&lt;/a&gt;&lt;a href=&quot;qsize&quot;&gt;QSize&lt;/a&gt;または&lt;a href=&quot;qsizef&quot;&gt;QSizeF&lt;/a&gt;値は、自動的に &lt;code&gt;size&lt;/code&gt; 値に変換され、その逆も同様であることに注意してください。場合 &lt;code&gt;size&lt;/code&gt; 値をC ++に渡され、それが自動的に変換され&lt;a href=&quot;qsizef&quot;&gt;QSizeFの&lt;/a&gt;値。</target>
        </trans-unit>
        <trans-unit id="efe91bec14c646d63c8cb49b132911ca4fb70cf2" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qsize&quot;&gt;QSize&lt;/a&gt; or &lt;a href=&quot;qsizef&quot;&gt;QSizeF&lt;/a&gt; value &lt;a href=&quot;qtqml-cppintegration-data#&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into a &lt;code&gt;size&lt;/code&gt; value, and vice-versa. When a &lt;code&gt;size&lt;/code&gt; value is passed to C++, it is automatically converted into a &lt;a href=&quot;qsizef&quot;&gt;QSizeF&lt;/a&gt; value.</source>
          <target state="translated">C ++と統合する場合、C ++ &lt;a href=&quot;qtqml-cppintegration-data#&quot;&gt;からQMLに渡される&lt;/a&gt;&lt;a href=&quot;qsize&quot;&gt;QSize&lt;/a&gt;または&lt;a href=&quot;qsizef&quot;&gt;QSizeFの&lt;/a&gt;値は自動的に &lt;code&gt;size&lt;/code&gt; 値に変換され、その逆も同様です。場合 &lt;code&gt;size&lt;/code&gt; 値をC ++に渡され、それが自動的に変換され&lt;a href=&quot;qsizef&quot;&gt;QSizeFの&lt;/a&gt;値。</target>
        </trans-unit>
        <trans-unit id="3ce59b6a0f0b4b392e20d60442b247d4ac83798d" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; value &lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into a &lt;code&gt;string&lt;/code&gt; value, and vice-versa.</source>
          <target state="translated">C ++と統合する場合、C ++&lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;からQMLに渡された&lt;/a&gt;&lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;値は自動的に &lt;code&gt;string&lt;/code&gt; 値に変換され、その逆も同様であることに注意してください。</target>
        </trans-unit>
        <trans-unit id="7fd4e1a3e2c35dda93f104508cebf19c9ae03217" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; value &lt;a href=&quot;qtqml-cppintegration-data#&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into a &lt;code&gt;string&lt;/code&gt; value, and vice-versa.</source>
          <target state="translated">C ++と統合する場合、C ++ &lt;a href=&quot;qtqml-cppintegration-data#&quot;&gt;からQMLに渡された&lt;/a&gt;&lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;値はすべて自動的に &lt;code&gt;string&lt;/code&gt; 値に変換され、その逆も同様です。</target>
        </trans-unit>
        <trans-unit id="c9d28617421e54fcce89cbef003fdb53a193660b" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qurl&quot;&gt;QUrl&lt;/a&gt; value &lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into a &lt;code&gt;url&lt;/code&gt; value, and vice-versa.</source>
          <target state="translated">C ++と統合する場合、C ++&lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;からQMLに渡された&lt;/a&gt;&lt;a href=&quot;qurl&quot;&gt;QUrl&lt;/a&gt;値は自動的に &lt;code&gt;url&lt;/code&gt; 値に変換され、その逆も同様であることに注意してください。</target>
        </trans-unit>
        <trans-unit id="b5784d74b9c118ae7229636ff92faf312a5dfe71" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qurl&quot;&gt;QUrl&lt;/a&gt; value &lt;a href=&quot;qtqml-cppintegration-data#&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into a &lt;code&gt;url&lt;/code&gt; value, and vice-versa.</source>
          <target state="translated">C ++と統合する場合、C ++ &lt;a href=&quot;qtqml-cppintegration-data#&quot;&gt;からQMLに渡される&lt;/a&gt;&lt;a href=&quot;qurl&quot;&gt;QUrl&lt;/a&gt;値は自動的に &lt;code&gt;url&lt;/code&gt; 値に変換され、その逆も同様です。</target>
        </trans-unit>
        <trans-unit id="ed02fd90e62a507cb5dc19431423e1b9374d396b" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; value &lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into a &lt;code&gt;variant&lt;/code&gt; value, and vice-versa.</source>
          <target state="translated">C ++と統合する場合、C ++&lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;からQMLに渡された&lt;/a&gt;&lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt;値は、自動的に &lt;code&gt;variant&lt;/code&gt; 値に変換され、その逆も同様であることに注意してください。</target>
        </trans-unit>
        <trans-unit id="4782c07688335b98c18e7337dd4cb33a506d5caa" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; value &lt;a href=&quot;qtqml-cppintegration-data#&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into a &lt;code&gt;variant&lt;/code&gt; value, and vice-versa.</source>
          <target state="translated">C ++と統合する場合、C ++ &lt;a href=&quot;qtqml-cppintegration-data#&quot;&gt;からQMLに渡される&lt;/a&gt;&lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt;値は自動的に &lt;code&gt;variant&lt;/code&gt; 値に変換され、その逆も同様です。</target>
        </trans-unit>
        <trans-unit id="0f08c295ab9d317506d3417a8c5ed2ce92dffe9c" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qvector3d&quot;&gt;QVector3D&lt;/a&gt; value &lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into a &lt;code&gt;vector3d&lt;/code&gt; value, and vice-versa.</source>
          <target state="translated">C ++と統合する場合、C ++ &lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;からQMLに渡される&lt;/a&gt;&lt;a href=&quot;qvector3d&quot;&gt;QVector3D&lt;/a&gt;値はすべて自動的に &lt;code&gt;vector3d&lt;/code&gt; 値に変換され、その逆も同様です。</target>
        </trans-unit>
        <trans-unit id="91da3853e2ebc605267bec0ae228daafb92fc978" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;code&gt;enum&lt;/code&gt; value &lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into an &lt;code&gt;enumeration&lt;/code&gt; value, and vice-versa.</source>
          <target state="translated">C ++と統合する場合、C ++&lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;からQMLに渡された&lt;/a&gt; &lt;code&gt;enum&lt;/code&gt; 値は自動的に &lt;code&gt;enumeration&lt;/code&gt; 値に変換され、その逆も同様であることに注意してください。</target>
        </trans-unit>
        <trans-unit id="174229e59467abdea54b7e746d86e6764e7d6c9d" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;code&gt;enum&lt;/code&gt; value &lt;a href=&quot;qtqml-cppintegration-data#&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into an &lt;code&gt;enumeration&lt;/code&gt; value, and vice-versa.</source>
          <target state="translated">C ++と統合する場合、C ++ &lt;a href=&quot;qtqml-cppintegration-data#&quot;&gt;からQMLに渡される&lt;/a&gt; &lt;code&gt;enum&lt;/code&gt; 値はすべて自動的に &lt;code&gt;enumeration&lt;/code&gt; 値に変換され、その逆も同様です。</target>
        </trans-unit>
        <trans-unit id="f7482e71bbdd52848ddeffbe95fcd0b8e2b5663e" translate="yes" xml:space="preserve">
          <source>When interacted with a mouse device, flicking is disabled and the scroll bars are interactive.</source>
          <target state="translated">マウスデバイスと対話すると、フリックは無効になり、スクロールバーは対話的になります。</target>
        </trans-unit>
        <trans-unit id="8777d7fa43f475169d9e2b3537e4248eaedbf1d8" translate="yes" xml:space="preserve">
          <source>When intermixing &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; and OpenGL, it is important to notify &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; that the OpenGL state may have been cluttered so it can restore its internal state. This is achieved by calling &lt;a href=&quot;qpainter#beginNativePainting&quot;&gt;QPainter::beginNativePainting&lt;/a&gt;() before starting the OpenGL rendering and calling &lt;a href=&quot;qpainter#endNativePainting&quot;&gt;QPainter::endNativePainting&lt;/a&gt;() after finishing.</source>
          <target state="translated">&lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt;とOpenGLを混合するときは、OpenGLの状態が乱雑になっている可能性があることを&lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt;に通知して、内部状態を復元できるようにすることが重要です。これは、OpenGLレンダリングを開始する前に&lt;a href=&quot;qpainter#beginNativePainting&quot;&gt;QPainter :: beginNativePainting&lt;/a&gt;（）を呼び出し、終了後に&lt;a href=&quot;qpainter#endNativePainting&quot;&gt;QPainter :: endNativePainting&lt;/a&gt;（）を呼び出すことによって実現されます。</target>
        </trans-unit>
        <trans-unit id="3c3351ce7fa4daf3d510e3944f9c0b1cd89614d0" translate="yes" xml:space="preserve">
          <source>When interoperating with another graphics engine, it may be necessary to get a QRhi instance that uses the same Metal device. This can be achieved by passing a pointer to a &lt;a href=&quot;qrhimetalnativehandles&quot;&gt;QRhiMetalNativeHandles&lt;/a&gt; to &lt;a href=&quot;qrhi#create&quot;&gt;QRhi::create&lt;/a&gt;(). The device must be set to a non-null value then. Optionally, a command queue object can be specified as well.</source>
          <target state="translated">別のグラフィックエンジンと相互運用する場合、同じMetalデバイスを使用するQRhiインスタンスを取得する必要がある場合があります。これは、&lt;a href=&quot;qrhimetalnativehandles&quot;&gt;QRhiMetalNativeHandles&lt;/a&gt;へのポインターを&lt;a href=&quot;qrhi#create&quot;&gt;QRhi :: create&lt;/a&gt;（）に渡すことで実現できます。その場合、デバイスをnull以外の値に設定する必要があります。オプションで、コマンドキューオブジェクトも指定できます。</target>
        </trans-unit>
        <trans-unit id="61bd4cd2f160b9517401ee938d1cc345306ee16b" translate="yes" xml:space="preserve">
          <source>When invoking QDoc on a project that has dependencies and uses the &lt;code&gt;depends&lt;/code&gt; variable, one or more &lt;code&gt;-indexdir&lt;/code&gt; path(s) must be passed as command line option(s). QDoc uses these paths to search for the dependencies' index files.</source>
          <target state="translated">依存関係があり、 &lt;code&gt;depends&lt;/code&gt; 変数を使用するプロジェクトでQDocを呼び出す場合、1つ以上の &lt;code&gt;-indexdir&lt;/code&gt; パスをコマンドラインオプションとして渡す必要があります。QDocはこれらのパスを使用して、依存関係のインデックスファイルを検索します。</target>
        </trans-unit>
        <trans-unit id="19950d97cb8c934f1e5c65f401298cb13bebd643" translate="yes" xml:space="preserve">
          <source>When invoking one of these options, or when an error happens (for instance an unknown option was passed), the current process will then stop, using the exit() function.</source>
          <target state="translated">これらのオプションのいずれかを実行したとき、あるいはエラーが発生したとき (たとえば不明なオプションが渡されたときなど)、現在のプロセスは exit()関数を使用して停止します。</target>
        </trans-unit>
        <trans-unit id="929e40a78bc8a0bfef832d1e3a9f16143f9379e2" translate="yes" xml:space="preserve">
          <source>When it comes from a &lt;a href=&quot;qtabletevent&quot;&gt;QTabletEvent&lt;/a&gt;, it identifies the serial number of the stylus in use.</source>
          <target state="translated">&lt;a href=&quot;qtabletevent&quot;&gt;QTabletEvent&lt;/a&gt;から取得される場合、使用中のスタイラスのシリアル番号を識別します。</target>
        </trans-unit>
        <trans-unit id="071c0d6d52ee604f468daeb0ab63c0a2099e201d" translate="yes" xml:space="preserve">
          <source>When it comes to more complex controls, it is sometimes better to split them up into separate building blocks. As an example, the complex &lt;a href=&quot;qml-qtquick-controls2-scrollview&quot;&gt;ScrollView&lt;/a&gt; control:</source>
          <target state="translated">より複雑なコントロールになると、それらを別々のビルディングブロックに分割する方が良い場合があります。例として、複雑な&lt;a href=&quot;qml-qtquick-controls2-scrollview&quot;&gt;ScrollView&lt;/a&gt;コントロール：</target>
        </trans-unit>
        <trans-unit id="8e8c72fd29bc00795105647d117aa1d234784718" translate="yes" xml:space="preserve">
          <source>When it comes to rendering, deferred rendering is a different beast in terms of renderer configuration compared to forward rendering. Instead of drawing each mesh and applying a shader effect to shade it, deferred rendering adopts a</source>
          <target state="translated">レンダリングに関して言えば、繰延レンダリングはフォワードレンダリングと比較してレンダラーの設定という点では別物です。各メッシュを描画してシェーダ効果を適用してシェーディングするのではなく、繰延レンダリングでは</target>
        </trans-unit>
        <trans-unit id="626ed890d480d0a4b856052f27b67e8d0b322b1a" translate="yes" xml:space="preserve">
          <source>When it comes to texture support, the &lt;a href=&quot;qt3drender-qparameter&quot;&gt;QParameter&lt;/a&gt; value should be set to the appropriate &lt;a href=&quot;qt3drender-qabstracttexture&quot;&gt;QAbstractTexture&lt;/a&gt; subclass that matches the sampler type of the shader uniform.</source>
          <target state="translated">テクスチャサポートに関しては、&lt;a href=&quot;qt3drender-qparameter&quot;&gt;QParameter&lt;/a&gt;値を、シェーダーのユニフォームのサンプラータイプと一致する適切な&lt;a href=&quot;qt3drender-qabstracttexture&quot;&gt;QAbstractTexture&lt;/a&gt;サブクラスに設定する必要があります。</target>
        </trans-unit>
        <trans-unit id="5979b40af94b30c33380148b42cb7fe798d86843" translate="yes" xml:space="preserve">
          <source>When it comes to texture support, the Parameter value should be set to the appropriate &lt;a href=&quot;qt3drender-qabstracttexture&quot;&gt;texture&lt;/a&gt; subclass that matches the sampler type of the shader uniform.</source>
          <target state="translated">テクスチャサポートに関しては、パラメーター値を、シェーダーのユニフォームのサンプラータイプと一致する適切な&lt;a href=&quot;qt3drender-qabstracttexture&quot;&gt;テクスチャ&lt;/a&gt;サブクラスに設定する必要があります。</target>
        </trans-unit>
        <trans-unit id="71c851f5c2d819a86267b67c443581d3b3d61a3e" translate="yes" xml:space="preserve">
          <source>When it comes to texture support, the QParameter value should be set to the appropriate &lt;a href=&quot;qt3drender-qabstracttexture&quot;&gt;QAbstractTexture&lt;/a&gt; subclass that matches the sampler type of the shader uniform.</source>
          <target state="translated">テクスチャサポートに関しては、QParameter値を、シェーダーユニフォームのサンプラータイプに一致する適切な&lt;a href=&quot;qt3drender-qabstracttexture&quot;&gt;QAbstractTexture&lt;/a&gt;サブクラスに設定する必要があります。</target>
        </trans-unit>
        <trans-unit id="4b02d0bcf48f8ce6e8c4aa1efbf35437d4baed40" translate="yes" xml:space="preserve">
          <source>When it comes to uniform values from properties, all passes in the Effect read the same values in their shaders. If necessary it is possible to override the value of a uniform just for a given pass. This is achieved by adding the &lt;a href=&quot;qml-qtquick3d-setuniformvalue&quot;&gt;SetUniformValue&lt;/a&gt; command to the list of commands for the pass.</source>
          <target state="translated">プロパティからの均一な値に関しては、エフェクトのすべてのパスがシェーダーで同じ値を読み取ります。必要に応じて、特定のパスに対してユニフォームの値をオーバーライドすることができます。これは、パスのコマンドのリストに&lt;a href=&quot;qml-qtquick3d-setuniformvalue&quot;&gt;SetUniformValue&lt;/a&gt;コマンドを追加することで実現されます。</target>
        </trans-unit>
        <trans-unit id="ac390c6893275dbab12f259c5a78a8285bc68bc5" translate="yes" xml:space="preserve">
          <source>When it does not call &lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt;, Shape interacts with &lt;a href=&quot;qframe#Shadow-enum&quot;&gt;QFrame::Shadow&lt;/a&gt;, the &lt;a href=&quot;qframe#lineWidth-prop&quot;&gt;lineWidth&lt;/a&gt;() and the &lt;a href=&quot;qframe#midLineWidth-prop&quot;&gt;midLineWidth&lt;/a&gt;() to create the total result. See the picture of the frames in the main class documentation.</source>
          <target state="translated">それは呼んでいない場合は&lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt;、とシェイプ相互作用&lt;a href=&quot;qframe#Shadow-enum&quot;&gt;QFrame ::影&lt;/a&gt;、&lt;a href=&quot;qframe#lineWidth-prop&quot;&gt;線幅&lt;/a&gt;（）と&lt;a href=&quot;qframe#midLineWidth-prop&quot;&gt;midLineWidth&lt;/a&gt;集計結果を作成します（）。メインクラスのドキュメントのフレームの画像を参照してください。</target>
        </trans-unit>
        <trans-unit id="4261303376e29e827bb3d9ad715c1736160cb00b" translate="yes" xml:space="preserve">
          <source>When it is necessary to reimplement the &lt;a href=&quot;qaccessibleinterface#child&quot;&gt;QAccessibleInterface::child&lt;/a&gt;() function and returning the child after constructing it, this function needs to be called.</source>
          <target state="translated">&lt;a href=&quot;qaccessibleinterface#child&quot;&gt;QAccessibleInterface :: child&lt;/a&gt;（）関数を再実装して子を作成した後に返す必要がある場合は、この関数を呼び出す必要があります。</target>
        </trans-unit>
        <trans-unit id="638905df9b46e03441949d29b36f66dcb7394603" translate="yes" xml:space="preserve">
          <source>When items of data are exported from a model in a drag and drop operation, they are encoded into an appropriate format corresponding to one or more MIME types. Models declare the MIME types that they can use to supply items by reimplementing the &lt;a href=&quot;qabstractitemmodel#mimeTypes&quot;&gt;QAbstractItemModel::mimeTypes&lt;/a&gt;() function, returning a list of standard MIME types.</source>
          <target state="translated">データのアイテムがドラッグアンドドロップ操作でモデルからエクスポートされると、それらは1つ以上のMIMEタイプに対応する適切な形式にエンコードされます。モデルは、&lt;a href=&quot;qabstractitemmodel#mimeTypes&quot;&gt;QAbstractItemModel :: mimeTypes&lt;/a&gt;（）関数を再実装して標準のMIMEタイプのリストを返すことにより、アイテムを提供するために使用できるMIMEタイプを宣言します。</target>
        </trans-unit>
        <trans-unit id="3d596a81dc328e917e2efe8c14460f7b21b5e36e" translate="yes" xml:space="preserve">
          <source>When iterating from 0 and up, it will return the items in the visual arranged order.</source>
          <target state="translated">0から上への反復処理を行うと、視覚的に配置された順番で項目を返してくれます。</target>
        </trans-unit>
        <trans-unit id="f808486c7714b611743ef8e1139711cba9bfa51a" translate="yes" xml:space="preserve">
          <source>When iterating over a &lt;a href=&quot;qhash#qhash&quot;&gt;QHash&lt;/a&gt;, the items are arbitrarily ordered. With &lt;a href=&quot;qmap&quot;&gt;QMap&lt;/a&gt;, the items are always sorted by key.</source>
          <target state="translated">&lt;a href=&quot;qhash#qhash&quot;&gt;QHashを&lt;/a&gt;反復するとき、アイテムは任意に順序付けられます。で&lt;a href=&quot;qmap&quot;&gt;QMap&lt;/a&gt;、アイテムは常にキーでソートされています。</target>
        </trans-unit>
        <trans-unit id="8c6bd39523d6a042b14b93d88385549366872e15" translate="yes" xml:space="preserve">
          <source>When iterating over a &lt;a href=&quot;qhash#qhash&quot;&gt;QHash&lt;/a&gt;, the items are arbitrarily ordered. With QMap, the items are always sorted by key.</source>
          <target state="translated">&lt;a href=&quot;qhash#qhash&quot;&gt;QHashを&lt;/a&gt;反復処理する場合、アイテムは任意に順序付けられます。QMapでは、アイテムは常にキーで並べ替えられます。</target>
        </trans-unit>
        <trans-unit id="c8708ebbe834470a66afd3e678569b47f4a25996" translate="yes" xml:space="preserve">
          <source>When iterating over a &lt;a href=&quot;qmap&quot;&gt;QMap&lt;/a&gt;, the items are always sorted by key. With &lt;a href=&quot;qhash#qhash&quot;&gt;QHash&lt;/a&gt;, the items are arbitrarily ordered.</source>
          <target state="translated">&lt;a href=&quot;qmap&quot;&gt;QMapを&lt;/a&gt;反復するとき、項目は常にキーでソートされます。&lt;a href=&quot;qhash#qhash&quot;&gt;QHash&lt;/a&gt;、項目を任意に並べられます。</target>
        </trans-unit>
        <trans-unit id="908bbde912a8e2a5301227f6ea15bedbeee803e0" translate="yes" xml:space="preserve">
          <source>When iterating over a &lt;a href=&quot;qmap&quot;&gt;QMap&lt;/a&gt;, the items are always sorted by key. With QHash, the items are arbitrarily ordered.</source>
          <target state="translated">&lt;a href=&quot;qmap&quot;&gt;QMapを&lt;/a&gt;反復処理する場合、アイテムは常にキーで並べ替えられます。QHashでは、アイテムは任意に注文されます。</target>
        </trans-unit>
        <trans-unit id="209836588351362f7e1be7058630803263938614" translate="yes" xml:space="preserve">
          <source>When iterating over a &lt;a href=&quot;qmultihash&quot;&gt;QMultiHash&lt;/a&gt;, the items are arbitrarily ordered. With QMultiMap, the items are always sorted by key.</source>
          <target state="translated">&lt;a href=&quot;qmultihash&quot;&gt;QMultiHashを&lt;/a&gt;反復処理する場合、アイテムは任意に順序付けられます。QMultiMapを使用すると、アイテムは常にキーで並べ替えられます。</target>
        </trans-unit>
        <trans-unit id="9a98982cb360d3887455667bec14b4371ac7fe09" translate="yes" xml:space="preserve">
          <source>When kerning is enabled, glyph metrics do not add up anymore, even for Latin text. In other words, the assumption that width('a') + width('b') is equal to width(&quot;ab&quot;) is not neccesairly true.</source>
          <target state="translated">カーニングを有効にすると、ラテン語テキストであってもグリフメトリクスは加算されなくなります。言い換えれば、width('a')+width('b')が width(&quot;ab&quot;)と等しいという仮定は、必ずしも真ではありません。</target>
        </trans-unit>
        <trans-unit id="c7c90cd5b86c3de4a86dbc5bca9301f0623600e2" translate="yes" xml:space="preserve">
          <source>When kerning is enabled, glyph metrics do not add up anymore, even for Latin text. In other words, the assumption that width('a') + width('b') is equal to width(&quot;ab&quot;) is not necessarily true.</source>
          <target state="translated">カーニングを有効にすると、ラテン語テキストであってもグリフメトリクスは加算されなくなります。つまり、width('a')+width('b')が width(&quot;ab&quot;)と等しくなるという仮定は、必ずしも真ではありません。</target>
        </trans-unit>
        <trans-unit id="1a521e51c1250eb56a9a96122f4249b5a5690e59" translate="yes" xml:space="preserve">
          <source>When keyboard tracking is disabled, changes are only signalled when focus leaves the text field after edits have modified the content. This allows the user to edit via an invalid date-time to reach a valid one.</source>
          <target state="translated">キーボードトラッキングが無効になっている場合、変更は、編集が内容を変更した後にフォーカスがテキストフィールドから離れたときにのみ表示されます。これにより、ユーザーは無効な日付時間を経由して編集し、有効な日付時間に到達することができます。</target>
        </trans-unit>
        <trans-unit id="4935f0a00031f4e75a93ae9dcce7afc6159f9c52" translate="yes" xml:space="preserve">
          <source>When leaving &quot;What's This?&quot; mode, a &lt;a href=&quot;qevent&quot;&gt;QEvent&lt;/a&gt; of type Qt::LeaveWhatsThisMode is sent to all toplevel widgets.</source>
          <target state="translated">「これは何？」を離れるとき モード、&lt;a href=&quot;qevent&quot;&gt;QEvent&lt;/a&gt;タイプのQtの:: LeaveWhatsThisModeは、すべてのトップレベルのウィジェットに送信されます。</target>
        </trans-unit>
        <trans-unit id="68c47022708d018c6f6b21000a13611ed6e90869" translate="yes" xml:space="preserve">
          <source>When linking a library, qmake relies on the underlying platform to know what other libraries this library links against. However, if linking statically, qmake will not get this information unless we use the following &lt;code&gt;CONFIG&lt;/code&gt; options:</source>
          <target state="translated">ライブラリをリンクするとき、qmakeは、このライブラリがリンクする他のライブラリを知るために、基盤となるプラットフォームに依存します。ただし、静的にリンクする場合、次の &lt;code&gt;CONFIG&lt;/code&gt; オプションを使用しない限り、qmakeはこの情報を取得しません。</target>
        </trans-unit>
        <trans-unit id="a540dbd6e20238800d7ddd333a082e8843bed862" translate="yes" xml:space="preserve">
          <source>When listening for connections, the address and port on which the server is listening are available as &lt;a href=&quot;qtcpserver#serverAddress&quot;&gt;serverAddress&lt;/a&gt;() and &lt;a href=&quot;qtcpserver#serverPort&quot;&gt;serverPort&lt;/a&gt;().</source>
          <target state="translated">接続をリッスンするとき、サーバーがリッスンしているアドレスとポートは、&lt;a href=&quot;qtcpserver#serverAddress&quot;&gt;serverAddress&lt;/a&gt;（）および&lt;a href=&quot;qtcpserver#serverPort&quot;&gt;serverPort&lt;/a&gt;（）として使用できます。</target>
        </trans-unit>
        <trans-unit id="e0c7db0652d32fbb04e043b9bb98640d9fdf9268" translate="yes" xml:space="preserve">
          <source>When listening for connections, the address and port on which the server is listening are available as &lt;a href=&quot;qwebsocketserver#serverAddress&quot;&gt;serverAddress&lt;/a&gt;() and &lt;a href=&quot;qwebsocketserver#serverPort&quot;&gt;serverPort&lt;/a&gt;().</source>
          <target state="translated">接続をリッスンするとき、サーバーがリッスンしているアドレスとポートは、&lt;a href=&quot;qwebsocketserver#serverAddress&quot;&gt;serverAddress&lt;/a&gt;（）および&lt;a href=&quot;qwebsocketserver#serverPort&quot;&gt;serverPort&lt;/a&gt;（）として使用できます。</target>
        </trans-unit>
        <trans-unit id="31ca6375539521ce018e40aba55ef1cfd8ac0a7b" translate="yes" xml:space="preserve">
          <source>When listening for connections, the name which the server is listening on is available through &lt;a href=&quot;qlocalserver#serverName&quot;&gt;serverName&lt;/a&gt;().</source>
          <target state="translated">接続をリッスンするとき、サーバーがリッスンしている名前は&lt;a href=&quot;qlocalserver#serverName&quot;&gt;serverName&lt;/a&gt;（）を介して利用できます。</target>
        </trans-unit>
        <trans-unit id="f562b333fc7588768d7b731fad5e57e2bf351983" translate="yes" xml:space="preserve">
          <source>When loading a QML object into a C++ application, it can be useful to directly embed some C++ data that can be used from within the QML code. This makes it possible, for example, to invoke a C++ method on the embedded object, or use a C++ object instance as a data model for a QML view.</source>
          <target state="translated">C++アプリケーションにQMLオブジェクトを読み込む際に、QMLコード内から利用可能なC++データを直接埋め込むと便利です。これにより、例えば、埋め込んだオブジェクト上で C++のメソッドを呼び出したり、C++オブジェクトのインスタンスをQMLビューのデータモデルとして利用したりすることが可能になります。</target>
        </trans-unit>
        <trans-unit id="5937553b7180f604506425e217e2f3d3eb8c1b4d" translate="yes" xml:space="preserve">
          <source>When loading the library, &lt;a href=&quot;qlibrary&quot;&gt;QLibrary&lt;/a&gt; searches in all system-specific library locations (for example, &lt;code&gt;LD_LIBRARY_PATH&lt;/code&gt; on Unix), unless the file name has an absolute path. After loading the library successfully, fileName() returns the fully-qualified file name of the library, including the full path to the library if one was given in the constructor or passed to setFileName().</source>
          <target state="translated">ライブラリをロードするとき、ファイル名に絶対パスがない限り、&lt;a href=&quot;qlibrary&quot;&gt;QLibrary&lt;/a&gt;はシステム固有のすべてのライブラリの場所（たとえば、UNIXの &lt;code&gt;LD_LIBRARY_PATH&lt;/code&gt; ）を検索します。ライブラリを正常にロードした後、fileName（）はライブラリの完全修飾ファイル名を返します。コンストラクターで指定された場合、またはsetFileName（）に渡された場合は、ライブラリへの完全パスを含みます。</target>
        </trans-unit>
        <trans-unit id="90725888073e38b3afa3349da5a1b31dfd6e2335" translate="yes" xml:space="preserve">
          <source>When loading the plugin, &lt;a href=&quot;qpluginloader&quot;&gt;QPluginLoader&lt;/a&gt; searches in all plugin locations specified by &lt;a href=&quot;qcoreapplication#libraryPaths&quot;&gt;QCoreApplication::libraryPaths&lt;/a&gt;(), unless the file name has an absolute path. After loading the plugin successfully, fileName() returns the fully-qualified file name of the plugin, including the full path to the plugin if one was given in the constructor or passed to setFileName().</source>
          <target state="translated">プラグインをロードするとき、&lt;a href=&quot;qpluginloader&quot;&gt;QPluginLoader&lt;/a&gt;は、ファイル名に絶対パスがない限り、&lt;a href=&quot;qcoreapplication#libraryPaths&quot;&gt;QCoreApplication :: libraryPaths&lt;/a&gt;（）で指定されたすべてのプラグインの場所を検索します。プラグインを正常にロードした後、fileName（）は、プラグインの完全修飾ファイル名を返します。これには、コンストラクターで指定された、またはsetFileName（）に渡されたプラグインへのフルパスが含まれます。</target>
        </trans-unit>
        <trans-unit id="07f1533b7f9a425f6f190f84dd677e6063996b77" translate="yes" xml:space="preserve">
          <source>When loading the plugin, &lt;a href=&quot;qpluginloader&quot;&gt;QPluginLoader&lt;/a&gt; searches in the current directory and in all plugin locations specified by &lt;a href=&quot;qcoreapplication#libraryPaths&quot;&gt;QCoreApplication::libraryPaths&lt;/a&gt;(), unless the file name has an absolute path. After loading the plugin successfully, fileName() returns the fully-qualified file name of the plugin, including the full path to the plugin if one was given in the constructor or passed to setFileName().</source>
          <target state="translated">プラグインをロードし、&lt;a href=&quot;qpluginloader&quot;&gt;QPluginLoaderの&lt;/a&gt;現在のディレクトリ内とで指定されたすべてのプラグインの場所で検索し&lt;a href=&quot;qcoreapplication#libraryPaths&quot;&gt;QCoreApplication :: libraryPaths&lt;/a&gt;（）、ファイル名は絶対パスを持っていない限り。プラグインを正常にロードした後、fileName（）はプラグインの完全修飾ファイル名を返します。コンストラクターで指定された場合、またはsetFileName（）に渡された場合、プラグインへの完全パスが含まれます。</target>
        </trans-unit>
        <trans-unit id="fed00e705cb06cd3fa7ef9acd6a2a5b4614acebf" translate="yes" xml:space="preserve">
          <source>When making OpenGL function calls, it is strongly recommended to avoid calling the functions directly. Instead, prefer using &lt;a href=&quot;https://doc.qt.io/qt-5.13/qopenglfunctions.html&quot;&gt;QOpenGLFunctions&lt;/a&gt; (when making portable applications) or the versioned variants (for example, &lt;a href=&quot;https://doc.qt.io/qt-5.13/qopenglfunctions-3-2-core.html&quot;&gt;QOpenGLFunctions_3_2_Core&lt;/a&gt; and similar, when targeting modern, desktop-only OpenGL). This way the application will work correctly in all Qt build configurations, including the ones that perform dynamic OpenGL implementation loading which means applications are not directly linking to an GL implementation and thus direct function calls are not feasible.</source>
          <target state="translated">OpenGL関数呼び出しを行うときは、関数を直接呼び出さないようにすることを強くお勧めします。代わりに、&lt;a href=&quot;https://doc.qt.io/qt-5.13/qopenglfunctions.html&quot;&gt;QOpenGLFunctions&lt;/a&gt;（ポータブルアプリケーションを作成する場合）またはバージョン付きのバリアント（たとえば、&lt;a href=&quot;https://doc.qt.io/qt-5.13/qopenglfunctions-3-2-core.html&quot;&gt;最新の&lt;/a&gt;デスクトップのみのOpenGLを対象とする場合はQOpenGLFunctions_3_2_Coreなど）を使用することをお勧めします。このようにして、アプリケーションは動的なOpenGL実装のロードを実行するものを含むすべてのQtビルド構成で正しく機能します。つまり、アプリケーションはGL実装に直接リンクしていないため、直接の関数呼び出しは実行できません。</target>
        </trans-unit>
        <trans-unit id="f276cbbad1d8799cadf78ef781192531dc7ead31" translate="yes" xml:space="preserve">
          <source>When making OpenGL function calls, it is strongly recommended to avoid calling the functions directly. Instead, prefer using &lt;a href=&quot;https://doc.qt.io/qt-5.15/qopenglfunctions.html&quot;&gt;QOpenGLFunctions&lt;/a&gt; (when making portable applications) or the versioned variants (for example, &lt;a href=&quot;https://doc.qt.io/qt-5.15/qopenglfunctions-3-2-core.html&quot;&gt;QOpenGLFunctions_3_2_Core&lt;/a&gt; and similar, when targeting modern, desktop-only OpenGL). This way the application will work correctly in all Qt build configurations, including the ones that perform dynamic OpenGL implementation loading which means applications are not directly linking to an GL implementation and thus direct function calls are not feasible.</source>
          <target state="translated">OpenGL関数呼び出しを行うときは、関数を直接呼び出さないようにすることを強くお勧めします。代わりに、&lt;a href=&quot;https://doc.qt.io/qt-5.15/qopenglfunctions.html&quot;&gt;QOpenGLFunctions&lt;/a&gt;（ポータブルアプリケーションを作成する場合）またはバージョン管理されたバリアント（たとえば、&lt;a href=&quot;https://doc.qt.io/qt-5.15/qopenglfunctions-3-2-core.html&quot;&gt;最新の&lt;/a&gt;デスクトップのみのOpenGLを対象とする場合はQOpenGLFunctions_3_2_Coreなど）を使用することをお勧めします。このようにして、アプリケーションはすべてのQtビルド構成で正しく機能します。これには、動的なOpenGL実装の読み込みを実行する構成も含まれます。つまり、アプリケーションはGL実装に直接リンクされていないため、直接の関数呼び出しは実行できません。</target>
        </trans-unit>
        <trans-unit id="5b88e78507dd59fcfeb60168e7f95fe6bc3faf69" translate="yes" xml:space="preserve">
          <source>When making OpenGL function calls, it is strongly recommended to avoid calling the functions directly. Instead, prefer using &lt;a href=&quot;https://doc.qt.io/qt-6.0/qopenglfunctions.html&quot;&gt;QOpenGLFunctions&lt;/a&gt; (when making portable applications) or the versioned variants (for example, &lt;a href=&quot;https://doc.qt.io/qt-6.0/qopenglfunctions-3-2-core.html&quot;&gt;QOpenGLFunctions_3_2_Core&lt;/a&gt; and similar, when targeting modern, desktop-only OpenGL). This way the application will work correctly in all Qt build configurations, including the ones that perform dynamic OpenGL implementation loading which means applications are not directly linking to an GL implementation and thus direct function calls are not feasible.</source>
          <target state="translated">OpenGL関数呼び出しを行うときは、関数を直接呼び出さないようにすることを強くお勧めします。代わりに、&lt;a href=&quot;https://doc.qt.io/qt-6.0/qopenglfunctions.html&quot;&gt;QOpenGLFunctions&lt;/a&gt;（ポータブルアプリケーションを作成する場合）またはバージョン管理されたバリアント（たとえば、&lt;a href=&quot;https://doc.qt.io/qt-6.0/qopenglfunctions-3-2-core.html&quot;&gt;最新の&lt;/a&gt;デスクトップのみのOpenGLを対象とする場合はQOpenGLFunctions_3_2_Coreなど）を使用することをお勧めします。このようにして、アプリケーションは、動的なOpenGL実装の読み込みを実行する構成を含め、すべてのQtビルド構成で正しく機能します。つまり、アプリケーションはGL実装に直接リンクしていないため、直接の関数呼び出しは実行できません。</target>
        </trans-unit>
        <trans-unit id="e13241aa10bcc1564d523c6d4166d3b0339b40a0" translate="yes" xml:space="preserve">
          <source>When making a context current using &lt;a href=&quot;gui-changes-qt6#qopenglcontext&quot;&gt;QOpenGLContext&lt;/a&gt;, do not check that the &lt;a href=&quot;qobject#thread-affinity&quot;&gt;QObject thread affinity&lt;/a&gt; of the &lt;a href=&quot;gui-changes-qt6#qopenglcontext&quot;&gt;QOpenGLContext&lt;/a&gt; object is the same thread calling &lt;a href=&quot;qopenglcontext#makeCurrent&quot;&gt;makeCurrent()&lt;/a&gt;. This value was added in Qt 5.8.</source>
          <target state="translated">&lt;a href=&quot;gui-changes-qt6#qopenglcontext&quot;&gt;QOpenGLContext&lt;/a&gt;を使用してコンテキストを最新にする場合、&lt;a href=&quot;gui-changes-qt6#qopenglcontext&quot;&gt;QOpenGLContext&lt;/a&gt;オブジェクトの&lt;a href=&quot;qobject#thread-affinity&quot;&gt;QObjectスレッドアフィニティ&lt;/a&gt;が&lt;a href=&quot;qopenglcontext#makeCurrent&quot;&gt;makeCurrent（）を&lt;/a&gt;呼び出す同じスレッドであることを確認しないでください。この値はQt5.8で追加されました。</target>
        </trans-unit>
        <trans-unit id="d7812b8e5267196ba2ad8e65b065aaa80e3d29f0" translate="yes" xml:space="preserve">
          <source>When making a context current using &lt;a href=&quot;qopenglcontext&quot;&gt;QOpenGLContext&lt;/a&gt;, do not check that the &lt;a href=&quot;qobject#thread-affinity&quot;&gt;QObject thread affinity&lt;/a&gt; of the &lt;a href=&quot;qopenglcontext&quot;&gt;QOpenGLContext&lt;/a&gt; object is the same thread calling &lt;a href=&quot;qopenglcontext#makeCurrent&quot;&gt;makeCurrent()&lt;/a&gt;. This value was added in Qt 5.8.</source>
          <target state="translated">&lt;a href=&quot;qopenglcontext&quot;&gt;QOpenGLContext&lt;/a&gt;を使用して現在のコンテキストを作成する場合、&lt;a href=&quot;qopenglcontext&quot;&gt;QOpenGLContext&lt;/a&gt;オブジェクトの&lt;a href=&quot;qobject#thread-affinity&quot;&gt;QObjectスレッドアフィニティ&lt;/a&gt;が&lt;a href=&quot;qopenglcontext#makeCurrent&quot;&gt;makeCurrent（）を&lt;/a&gt;呼び出すスレッドと同じであることを確認しないでください。この値はQt 5.8で追加されました。</target>
        </trans-unit>
        <trans-unit id="3d457ffc5179988c0d911e245311c267b3667157" translate="yes" xml:space="preserve">
          <source>When making the temporary credentials request, the client authenticates using only the client credentials. When making the token request, the client authenticates using the client credentials as well as the temporary credentials. Once the client receives and stores the token credentials, it can proceed to access protected resources on behalf of the resource owner by making authenticated requests using the client credentials together with the token credentials received.</source>
          <target state="translated">一時的なクレデンシャル要求を行う場合、クライアントはクライアントのクレデンシャルのみを使用して認証する。トークン要求を行うとき、クライアントは一時的なクレデンシャルと同様にクライアントのクレデンシャルを使用して認証する。クライアントがトークン資格情報を受信して保存すると、クライアントは、受信したトークン資格情報とともにクライアント資格情報を使用して認証された要求を行うことで、リソース所有者に代わって保護されたリソースへのアクセスを進めることができます。</target>
        </trans-unit>
        <trans-unit id="810316d46e7d600660a66af0e59fa7e02d7433b6" translate="yes" xml:space="preserve">
          <source>When managing dynamically created objects, you must ensure the creation context outlives the created object. Otherwise, if the creation context is destroyed first, the bindings and signal handlers in the dynamic object will no longer work.</source>
          <target state="translated">動的に作成されたオブジェクトを管理する場合、作成コンテキストが作成されたオブジェクトよりも長持ちするようにする必要があります。そうしないと、作成コンテキストが先に破棄されてしまうと、動的オブジェクトのバインディングやシグナルハンドラが機能しなくなってしまいます。</target>
        </trans-unit>
        <trans-unit id="b19286d402c202adf58ff1b66a30b97e15b4a785" translate="yes" xml:space="preserve">
          <source>When manipulating selections, it is often helpful to think of &lt;a href=&quot;qitemselectionmodel&quot;&gt;QItemSelectionModel&lt;/a&gt; as a record of the selection state of all the items in an item model. Once a selection model is set up, collections of items can be selected, deselected, or their selection states can be toggled without the need to know which items are already selected. The indexes of all selected items can be retrieved at any time, and other components can be informed of changes to the selection model via the signals and slots mechanism.</source>
          <target state="translated">選択を操作するとき、&lt;a href=&quot;qitemselectionmodel&quot;&gt;QItemSelectionModel&lt;/a&gt;をアイテムモデル内のすべてのアイテムの選択状態の記録と考えると役立つことがよくあります。選択モデルが設定されると、アイテムのコレクションを選択、選択解除したり、選択状態を切り替えることができます。どのアイテムがすでに選択されているかを知る必要はありません。選択されたすべてのアイテムのインデックスはいつでも取得でき、他のコンポーネントには、信号とスロットのメカニズムを介して選択モデルへの変更を通知できます。</target>
        </trans-unit>
        <trans-unit id="d4893cb0b2ef7620d287061a0515bab60d47b9b9" translate="yes" xml:space="preserve">
          <source>When memory allocation fails, QByteArray throws a &lt;code&gt;std::bad_alloc&lt;/code&gt; exception if the application is being compiled with exception support. Out of memory conditions in Qt containers are the only case where Qt will throw exceptions. If exceptions are disabled, then running out of memory is undefined behavior.</source>
          <target state="translated">メモリ割り当てが失敗した場合、アプリケーションが例外サポート付きでコンパイルされていると、QByteArrayは &lt;code&gt;std::bad_alloc&lt;/code&gt; 例外をスローします。Qtコンテナのメモリ不足状態は、Qtが例外をスローする唯一のケースです。例外が無効になっている場合、メモリ不足は未定義の動作です。</target>
        </trans-unit>
        <trans-unit id="4fe612b6914bd28d3a91c181ce17418b66edda3f" translate="yes" xml:space="preserve">
          <source>When mirroring the layout using either the attached property &lt;a href=&quot;qml-qtquick-layoutmirroring#enabled-prop&quot;&gt;LayoutMirroring::enabled&lt;/a&gt; or by setting the &lt;a href=&quot;qml-qtquick-grid#layoutDirection-prop&quot;&gt;layoutDirection&lt;/a&gt;, the horizontal alignment of items will be mirrored as well. However, the property &lt;code&gt;horizontalItemAlignment&lt;/code&gt; will remain unchanged. To query the effective horizontal alignment of items, use the read-only property &lt;code&gt;effectiveHorizontalItemAlignment&lt;/code&gt;.</source>
          <target state="translated">添付プロパティ&lt;a href=&quot;qml-qtquick-layoutmirroring#enabled-prop&quot;&gt;LayoutMirroring :: enabledを使用する&lt;/a&gt;か、&lt;a href=&quot;qml-qtquick-grid#layoutDirection-prop&quot;&gt;layoutDirectionを&lt;/a&gt;設定してレイアウトをミラーリングすると、アイテムの水平方向の配置もミラーリングされます。ただし、プロパティ &lt;code&gt;horizontalItemAlignment&lt;/code&gt; は変更されません。アイテムの効果的な水平方向の配置を照会するには、読み取り専用プロパティ &lt;code&gt;effectiveHorizontalItemAlignment&lt;/code&gt; 使用します。</target>
        </trans-unit>
        <trans-unit id="e9debebd9aa12f2d598528bbeb0d545c66987f90" translate="yes" xml:space="preserve">
          <source>When mixing raw graphics (OpenGL, Vulkan, Metal, etc.) commands with scene graph rendering, it is necessary to call this function after recording commands to the command buffer used by the scene graph to render its main render pass. This is to avoid clobbering state.</source>
          <target state="translated">生のグラフィックス(OpenGL、Vulkan、Metalなど)コマンドとシーングラフのレンダリングを混在させる場合、シーングラフが使用するコマンドバッファにコマンドを記録してからこの関数を呼び出す必要がありますが、これは、シーングラフがメインのレンダリングパスをレンダリングする際に使用するコマンドバッファにコマンドを記録してから呼び出す必要があります。これは、クロバリング状態を避けるためです。</target>
        </trans-unit>
        <trans-unit id="48e30ffa6a01f7853331128d4cf7b56aeea01dcd" translate="yes" xml:space="preserve">
          <source>When mixing raw graphics (OpenGL, Vulkan, Metal, etc.) commands with scene graph rendering, it is necessary to call this function before recording commands to the command buffer used by the scene graph to render its main render pass. This is to avoid clobbering state.</source>
          <target state="translated">生のグラフィックス(OpenGL、Vulkan、Metalなど)のコマンドをシーングラフのレンダリングに混ぜる場合、シーングラフがメインのレンダリングパスをレンダリングするために使用するコマンドバッファにコマンドを記録する前に、この関数を呼び出す必要があります。これは、クロバリング状態を避けるためです。</target>
        </trans-unit>
        <trans-unit id="98292e6a711c0a97d142c6900df0dd3a1198f215" translate="yes" xml:space="preserve">
          <source>When model is not explicitly set, it will be synchronized with &lt;a href=&quot;qml-qtquick-controls2-verticalheaderview#syncView-prop&quot;&gt;syncView&lt;/a&gt;'s model once &lt;a href=&quot;qml-qtquick-controls2-verticalheaderview#syncView-prop&quot;&gt;syncView&lt;/a&gt; is set.</source>
          <target state="translated">モデルが明示的に設定されていない場合は、と同期されます&lt;a href=&quot;qml-qtquick-controls2-verticalheaderview#syncView-prop&quot;&gt;syncView&lt;/a&gt;一度のモデル&lt;a href=&quot;qml-qtquick-controls2-verticalheaderview#syncView-prop&quot;&gt;syncViewが&lt;/a&gt;設定されています。</target>
        </trans-unit>
        <trans-unit id="67c4954bd29b0a4fd959263898f6a26791b7a7d0" translate="yes" xml:space="preserve">
          <source>When model is not explicitly set, the header will use the &lt;a href=&quot;qml-qtquick-controls2-horizontalheaderview#syncView-prop&quot;&gt;syncView&lt;/a&gt;'s model once &lt;a href=&quot;qml-qtquick-controls2-horizontalheaderview#syncView-prop&quot;&gt;syncView&lt;/a&gt; is set.</source>
          <target state="translated">モデルが明示的に設定されていない場合は、ヘッダーが使用されます&lt;a href=&quot;qml-qtquick-controls2-horizontalheaderview#syncView-prop&quot;&gt;syncView&lt;/a&gt;一度のモデルを&lt;a href=&quot;qml-qtquick-controls2-horizontalheaderview#syncView-prop&quot;&gt;syncViewが&lt;/a&gt;設定されています。</target>
        </trans-unit>
        <trans-unit id="ac2b797ba9d6873b70d7cdcf2a1e41cbc388241c" translate="yes" xml:space="preserve">
          <source>When multiple &lt;a href=&quot;opengl-changes-qt6#qopenglwidgets&quot;&gt;QOpenGLWidgets&lt;/a&gt; are added as children to the same top-level widget, their contexts will share with each other. This does not apply for QOpenGLWidget instances that belong to different windows.</source>
          <target state="translated">複数の&lt;a href=&quot;opengl-changes-qt6#qopenglwidgets&quot;&gt;QOpenGLWidgetsが子&lt;/a&gt;として同じトップレベルウィジェットに追加されると、それらのコンテキストは互いに共有されます。これは、異なるウィンドウに属するQOpenGLWidgetインスタンスには適用されません。</target>
        </trans-unit>
        <trans-unit id="b20aa7e6cd799e3bf7fad3e47e4d5468b0303506" translate="yes" xml:space="preserve">
          <source>When multiple QOpenGLWidgets are added as children to the same top-level widget, their contexts will share with each other. This does not apply for &lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidget&lt;/a&gt; instances that belong to different windows.</source>
          <target state="translated">複数のQOpenGLWidgetが同じ最上位ウィジェットに子として追加されると、それらのコンテキストは互いに共有されます。これは、異なるウィンドウに属する&lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidget&lt;/a&gt;インスタンスには適用されません。</target>
        </trans-unit>
        <trans-unit id="a052e77d465746dc1474a9b2e904f81e2b5f4c64" translate="yes" xml:space="preserve">
          <source>When multiple QOpenGLWidgets are added as children to the same top-level widget, their contexts will share with each other. This does not apply for QOpenGLWidget instances that belong to different windows.</source>
          <target state="translated">複数のQOpenGLWidgetsが同じトップレベルのウィジェットの子として追加された場合、そのコンテキストは互いに共有されます。これは、異なるウィンドウに属する QOpenGLWidget インスタンスには適用されません。</target>
        </trans-unit>
        <trans-unit id="be71f48901e09c1cafec1c8d3da6f3f42996e8be" translate="yes" xml:space="preserve">
          <source>When multiple render targets are in use,</source>
          <target state="translated">複数のレンダーターゲットが使用されている場合</target>
        </trans-unit>
        <trans-unit id="cca7faed1dcf3acb3787eb6ed52f3e078b4e846e" translate="yes" xml:space="preserve">
          <source>When multiple selectors could be applied to the same file, the first matching selector is chosen. The order selectors are checked in are:</source>
          <target state="translated">複数のセレクタが同じファイルに適用された場合、最初にマッチしたセレクタが選択されます。セレクタがチェックされる順番は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="a2d60a792f80124c96dcd07ddb164770dfe0ca59" translate="yes" xml:space="preserve">
          <source>When multiple series are added to a graph, selecting an item in one of them will clear the selection on other series.</source>
          <target state="translated">グラフに複数の系列が追加されている場合、そのうちの1つの系列の項目を選択すると、他の系列の項目の選択がクリアされます。</target>
        </trans-unit>
        <trans-unit id="b98c31c0b36eccbc7c80561d52175a75bcc24aef" translate="yes" xml:space="preserve">
          <source>When multiple textures are attached, the return value is the ID of the first one.</source>
          <target state="translated">複数のテクスチャが添付されている場合は、最初のテクスチャのIDが戻り値となります。</target>
        </trans-unit>
        <trans-unit id="5ea247c1f56cf273fe99668ba49d31b1b499bfbe" translate="yes" xml:space="preserve">
          <source>When multisample antialiasing is used, content rendered into framebuffer objects need additional extensions to support multisampling of framebuffers. Typically &lt;code&gt;GL_EXT_framebuffer_multisample&lt;/code&gt; and &lt;code&gt;GL_EXT_framebuffer_blit&lt;/code&gt;. Most desktop chips have these extensions present, but they are less common in embedded chips. When framebuffer multisampling is not available in the hardware, content rendered into framebuffer objects will not be antialiased, including the content of a &lt;a href=&quot;qml-qtquick-shadereffectsource&quot;&gt;ShaderEffectSource&lt;/a&gt;.</source>
          <target state="translated">マルチサンプルアンチエイリアスを使用する場合、フレームバッファーオブジェクトにレンダリングされるコンテンツには、フレームバッファーのマルチサンプリングをサポートするための追加の拡張機能が必要です。通常は &lt;code&gt;GL_EXT_framebuffer_multisample&lt;/code&gt; および &lt;code&gt;GL_EXT_framebuffer_blit&lt;/code&gt; です。ほとんどのデスクトップチップにはこれらの拡張機能が存在しますが、組み込みチップではあまり一般的ではありません。ハードウェアでフレームバッファーマルチサンプリングが利用できない場合、フレームバッファーオブジェクトにレンダリングされたコンテンツは、&lt;a href=&quot;qml-qtquick-shadereffectsource&quot;&gt;ShaderEffectSourceの&lt;/a&gt;コンテンツを含め、アンチエイリアス処理されません。</target>
        </trans-unit>
        <trans-unit id="fccefc8901100b2f82142ca7d8bb3223d24d7501" translate="yes" xml:space="preserve">
          <source>When navigating the document structure, it is useful to begin at the root frame because it provides access to the entire document structure.</source>
          <target state="translated">ドキュメント構造をナビゲートするときは、ルートフレームから始めると便利です。</target>
        </trans-unit>
        <trans-unit id="3e0a254e08acf9d6be4fd4d7a634988147b26055" translate="yes" xml:space="preserve">
          <source>When nested opacity gets below a certain threshold, the subtree might be marked as blocked, causing &lt;a href=&quot;qsgnode#isSubtreeBlocked&quot;&gt;isSubtreeBlocked&lt;/a&gt;() to return true. This is done for performance reasons.</source>
          <target state="translated">ネストされた不透明度が特定のしきい値を下回ると、サブツリーがブロックされているとマークされ、&lt;a href=&quot;qsgnode#isSubtreeBlocked&quot;&gt;isSubtreeBlocked&lt;/a&gt;（）がtrueを返すことがあります。これは、パフォーマンス上の理由で行われます。</target>
        </trans-unit>
        <trans-unit id="4d85ccf2069fc6eae18e11975d88bfe1fadc019f" translate="yes" xml:space="preserve">
          <source>When no windowing system is present, the mouse, keyboard and touch input are read directly via &lt;code&gt;evdev&lt;/code&gt;. Note that this requires that devices nodes &lt;code&gt;/input/event*&lt;/code&gt; are readable by the user. eglfs and vxworksfb has all the evdev input handling code built-in.</source>
          <target state="translated">ウィンドウシステムが存在しない場合、マウス、キーボード、タッチ入力は &lt;code&gt;evdev&lt;/code&gt; を介して直接読み取られます。これには、デバイスノード &lt;code&gt;/input/event*&lt;/code&gt; がユーザーによって読み取り可能である必要があることに注意してください。eglfsおよびvxworksfbには、すべてのevdev入力処理コードが組み込まれています。</target>
        </trans-unit>
        <trans-unit id="5b0f164920aba9354f027a11efdb935f7ff22e14" translate="yes" xml:space="preserve">
          <source>When no windowing system is present, the mouse, keyboard, and touch input are read directly via &lt;code&gt;evdev&lt;/code&gt; or using helper libraries such as &lt;code&gt;libinput&lt;/code&gt; or &lt;code&gt;tslib&lt;/code&gt;. Note that this requires that device nodes &lt;code&gt;/dev/input/event*&lt;/code&gt; are readable by the user. &lt;code&gt;eglfs&lt;/code&gt; and &lt;code&gt;linuxfb&lt;/code&gt; have all the input handling code compiled-in.</source>
          <target state="translated">ウィンドウシステムが存在しない場合、マウス、キーボード、およびタッチ入力は、 &lt;code&gt;evdev&lt;/code&gt; を介して、または &lt;code&gt;libinput&lt;/code&gt; や &lt;code&gt;tslib&lt;/code&gt; などのヘルパーライブラリを使用して直接読み取られます。これには、デバイスノード &lt;code&gt;/dev/input/event*&lt;/code&gt; がユーザーによって読み取り可能である必要があることに注意してください。 &lt;code&gt;eglfs&lt;/code&gt; と &lt;code&gt;linuxfb&lt;/code&gt; には、すべての入力処理コードがコンパイルされています。</target>
        </trans-unit>
        <trans-unit id="18d39e71149ec53d71da5bdfa496288bb4064e73" translate="yes" xml:space="preserve">
          <source>When not running with the RHI (and using OpenGL directly), the signal is emitted after the renderer has cleared the render target. This makes it possible to create applications that function identically both with and without the RHI.</source>
          <target state="translated">RHIを使用していない場合(OpenGLを直接使用している場合)は、レンダラがレンダーターゲットをクリアした後にシグナルが発せられます。これにより、RHIの有無にかかわらず、同じ機能を持つアプリケーションを作成することが可能になります。</target>
        </trans-unit>
        <trans-unit id="a0721c385a99233431f8667a3ee0ae4fedf149b4" translate="yes" xml:space="preserve">
          <source>When not running with the RHI (and using OpenGL directly), the signal is emitted after the renderer has finished its rendering, but before &lt;a href=&quot;qquickwindow#afterRendering&quot;&gt;afterRendering&lt;/a&gt;(). This makes it possible to create applications that function identically both with and without the RHI.</source>
          <target state="translated">RHIで実行されていない場合（およびOpenGLを直接使用している場合）、信号はレンダラーがレンダリングを終了した後、&lt;a href=&quot;qquickwindow#afterRendering&quot;&gt;afterRendering&lt;/a&gt;（）の前に発行されます。これにより、RHIの有無にかかわらず同じように機能するアプリケーションを作成できます。</target>
        </trans-unit>
        <trans-unit id="dca5d911ae2265eef32ee4fee8077e25696a9db8" translate="yes" xml:space="preserve">
          <source>When one of the statements is a non-select statement a count of affected rows may be available instead of a result set.</source>
          <target state="translated">文の一つが非選択文である場合、結果セットの代わりに影響を受けた行のカウントが利用できるかもしれません。</target>
        </trans-unit>
        <trans-unit id="e9136aaa0ef09df9e9f07e3241b2a9f838fd494d" translate="yes" xml:space="preserve">
          <source>When operating in deterministic mode, &lt;a href=&quot;qrandomgenerator&quot;&gt;QRandomGenerator&lt;/a&gt; may be used for bulk data generation. In fact, applications that do not need cryptographically-secure or true random data are advised to use a regular &lt;a href=&quot;qrandomgenerator&quot;&gt;QRandomGenerator&lt;/a&gt; instead of &lt;a href=&quot;qrandomgenerator#system&quot;&gt;QRandomGenerator::system&lt;/a&gt;() for their random data needs.</source>
          <target state="translated">確定的モードで動作する場合、&lt;a href=&quot;qrandomgenerator&quot;&gt;QRandomGenerator&lt;/a&gt;を使用してバルクデータを生成できます。実際、暗号で保護されたデータや真のランダムデータを必要としないアプリケーションでは、ランダムデータのニーズに応じて&lt;a href=&quot;qrandomgenerator#system&quot;&gt;QRandomGenerator :: system&lt;/a&gt;（）ではなく通常の&lt;a href=&quot;qrandomgenerator&quot;&gt;QRandomGenerator&lt;/a&gt;を使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="601025c900ae42d4debb597407723c06012bd462" translate="yes" xml:space="preserve">
          <source>When operating in deterministic mode, QRandomGenerator may be used for bulk data generation. In fact, applications that do not need cryptographically-secure or true random data are advised to use a regular QRandomGenerator instead of &lt;a href=&quot;qrandomgenerator#system&quot;&gt;QRandomGenerator::system&lt;/a&gt;() for their random data needs.</source>
          <target state="translated">決定論的モードで動作している場合、QRandomGeneratorをバルク・データ生成に使用できます。実際、暗号的に安全なデータや真のランダムデータを必要としないアプリケーションでは、ランダムデータのニーズに&lt;a href=&quot;qrandomgenerator#system&quot;&gt;QRandomGenerator :: system&lt;/a&gt;（）ではなく通常のQRandomGeneratorを使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="ca0c853a6a3df272210d1c9d0c36c813572cdfe7" translate="yes" xml:space="preserve">
          <source>When operating on managed objects in normal C++ code, a little extra care must be taken because of the CLR's garbage collection. A normal pointer variable should not</source>
          <target state="translated">通常の C++コードで管理オブジェクトを操作する場合は、CLR のガベージコレクションのため、少し注意が必要です。通常のポインタ変数は</target>
        </trans-unit>
        <trans-unit id="ea7e897063825784978303959c1455b5d44412c2" translate="yes" xml:space="preserve">
          <source>When options can be grouped, you can use a partially checked &lt;a href=&quot;qml-qtquick-controls2-checkbox&quot;&gt;CheckBox&lt;/a&gt; to represent the whole group. Use the checkbox's &lt;a href=&quot;qml-qtquick-controls2-checkbox#checkState-prop&quot;&gt;partially checked state&lt;/a&gt; when a user selects some, but not all, sub-items in the group.</source>
          <target state="translated">オプションをグループ化できる場合、部分的にチェックされた&lt;a href=&quot;qml-qtquick-controls2-checkbox&quot;&gt;CheckBox&lt;/a&gt;を使用してグループ全体を表すことができます。ユーザーがグループ内のすべてではなく一部のサブアイテムを選択した場合、&lt;a href=&quot;qml-qtquick-controls2-checkbox#checkState-prop&quot;&gt;チェック&lt;/a&gt;ボックスの部分的にチェックされた状態を使用します。</target>
        </trans-unit>
        <trans-unit id="fe4c38cfe45b7ff5d5ad3092c911b19539b422d2" translate="yes" xml:space="preserve">
          <source>When painting to a &lt;a href=&quot;qopenglpaintdevice&quot;&gt;QOpenGLPaintDevice&lt;/a&gt; using &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt;, the state of the current OpenGL context will be altered by the paint engine to reflect its needs. Applications should not rely upon the OpenGL state being reset to its original conditions, particularly the current shader program, OpenGL viewport, texture units, and drawing modes.</source>
          <target state="translated">塗装するとき&lt;a href=&quot;qopenglpaintdevice&quot;&gt;QOpenGLPaintDevice&lt;/a&gt;使用&lt;a href=&quot;qpainter&quot;&gt;QPainterのを&lt;/a&gt;、現在のOpenGLコンテキストの状態は、そのニーズを反映するようにペイントエンジンによって変更されます。アプリケーションは、OpenGLの状態が元の状態にリセットされることに依存すべきではありません。特に、現在のシェーダープログラム、OpenGLビューポート、テクスチャユニット、描画モードなどです。</target>
        </trans-unit>
        <trans-unit id="76720392a96856f8c1e5f2c5c0b848262c8e8089" translate="yes" xml:space="preserve">
          <source>When painting to a QOpenGLPaintDevice using &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt;, the state of the current OpenGL context will be altered by the paint engine to reflect its needs. Applications should not rely upon the OpenGL state being reset to its original conditions, particularly the current shader program, OpenGL viewport, texture units, and drawing modes.</source>
          <target state="translated">使用QOpenGLPaintDeviceに塗装するとき&lt;a href=&quot;qpainter&quot;&gt;QPainterのを&lt;/a&gt;、現在のOpenGLコンテキストの状態は、そのニーズを反映するようにペイントエンジンによって変更されます。アプリケーションは、OpenGLの状態が元の状態、特に現在のシェーダープログラム、OpenGLビューポート、テクスチャユニット、および描画モードにリセットされることに依存しないでください。</target>
        </trans-unit>
        <trans-unit id="8e4b844ee7e4c5be1b0dab1bbe7aaa712b977db0" translate="yes" xml:space="preserve">
          <source>When paused, the current frame can be advanced manually by setting this property or calling &lt;a href=&quot;qml-qtquick-animatedsprite#advance-method&quot;&gt;advance()&lt;/a&gt;.</source>
          <target state="translated">一時停止すると、このプロパティを設定するか、&lt;a href=&quot;qml-qtquick-animatedsprite#advance-method&quot;&gt;advance（）を&lt;/a&gt;呼び出すことにより、現在のフレームを手動で進めることができます。</target>
        </trans-unit>
        <trans-unit id="36bc00e334ac8aa1eea3755d12934f7608da4dea" translate="yes" xml:space="preserve">
          <source>When paused, the current frame can be advanced manually.</source>
          <target state="translated">一時停止時には、現在のフレームを手動で進めることができます。</target>
        </trans-unit>
        <trans-unit id="40753593df1bbb77361dbb8a61ae51ec564eb417" translate="yes" xml:space="preserve">
          <source>When performing a lookup on a service, zero or more records will be returned. Each record is represented by a &lt;a href=&quot;qdnsmailexchangerecord&quot;&gt;QDnsMailExchangeRecord&lt;/a&gt; instance.</source>
          <target state="translated">サービスで検索を実行すると、0個以上のレコードが返されます。各レコードは、&lt;a href=&quot;qdnsmailexchangerecord&quot;&gt;QDnsMailExchangeRecord&lt;/a&gt;インスタンスによって表されます。</target>
        </trans-unit>
        <trans-unit id="745159504ea8964595662dfda6ea6803520cab14" translate="yes" xml:space="preserve">
          <source>When performing a lookup on a service, zero or more records will be returned. Each record is represented by a &lt;a href=&quot;qdnsservicerecord&quot;&gt;QDnsServiceRecord&lt;/a&gt; instance.</source>
          <target state="translated">サービスで検索を実行すると、0個以上のレコードが返されます。各レコードは&lt;a href=&quot;qdnsservicerecord&quot;&gt;QDnsServiceRecord&lt;/a&gt;インスタンスによって表されます。</target>
        </trans-unit>
        <trans-unit id="6d6001a94eae9d4e4679d672b10ebf1476ba4b97" translate="yes" xml:space="preserve">
          <source>When performing a lookup on a service, zero or more records will be returned. Each record is represented by a QDnsMailExchangeRecord instance.</source>
          <target state="translated">サービスでルックアップを実行すると、0個以上のレコードが返されます。各レコードは QDnsMailExchangeRecord インスタンスで表されます。</target>
        </trans-unit>
        <trans-unit id="183c9e6bf9945fe2d7c4f1ece374cc4634d591ca" translate="yes" xml:space="preserve">
          <source>When performing a lookup on a service, zero or more records will be returned. Each record is represented by a QDnsServiceRecord instance.</source>
          <target state="translated">サービスのルックアップを実行すると、0 個以上のレコードが返されます。各レコードは QDnsServiceRecord インスタンスで表されます。</target>
        </trans-unit>
        <trans-unit id="89b6dd291204471e81a34c81e897e2eae987238a" translate="yes" xml:space="preserve">
          <source>When performing a name server lookup, zero or more records will be returned. Each record is represented by a &lt;a href=&quot;qdnsdomainnamerecord&quot;&gt;QDnsDomainNameRecord&lt;/a&gt; instance.</source>
          <target state="translated">ネームサーバーのルックアップを実行すると、0個以上のレコードが返されます。各レコードは&lt;a href=&quot;qdnsdomainnamerecord&quot;&gt;QDnsDomainNameRecord&lt;/a&gt;インスタンスによって表されます。</target>
        </trans-unit>
        <trans-unit id="d31385d56b863dd8dbd104e645dc9977d21a36cc" translate="yes" xml:space="preserve">
          <source>When performing a name server lookup, zero or more records will be returned. Each record is represented by a QDnsDomainNameRecord instance.</source>
          <target state="translated">ネームサーバーの検索を実行すると、0 個以上のレコードが返されます。各レコードは QDnsDomainNameRecord インスタンスで表されます。</target>
        </trans-unit>
        <trans-unit id="3612e920959430b2f4633a7ed7ecb7c74231f462" translate="yes" xml:space="preserve">
          <source>When performing a text lookup, zero or more records will be returned. Each record is represented by a &lt;a href=&quot;qdnstextrecord&quot;&gt;QDnsTextRecord&lt;/a&gt; instance.</source>
          <target state="translated">テキスト検索を実行すると、0個以上のレコードが返されます。各レコードは&lt;a href=&quot;qdnstextrecord&quot;&gt;QDnsTextRecord&lt;/a&gt;インスタンスで表されます。</target>
        </trans-unit>
        <trans-unit id="909f4885c9471951ef724c0551ca405b8644c385" translate="yes" xml:space="preserve">
          <source>When performing a text lookup, zero or more records will be returned. Each record is represented by a QDnsTextRecord instance.</source>
          <target state="translated">テキスト検索を実行すると、0個以上のレコードが返されます。各レコードは QDnsTextRecord インスタンスで表されます。</target>
        </trans-unit>
        <trans-unit id="711a9f71466771c6e4aade7928b9960c7cefd54f" translate="yes" xml:space="preserve">
          <source>When performing an address lookup, zero or more records will be returned. Each record is represented by a &lt;a href=&quot;qdnshostaddressrecord&quot;&gt;QDnsHostAddressRecord&lt;/a&gt; instance.</source>
          <target state="translated">アドレス検索を実行すると、0個以上のレコードが返されます。各レコードは&lt;a href=&quot;qdnshostaddressrecord&quot;&gt;QDnsHostAddressRecord&lt;/a&gt;インスタンスによって表されます。</target>
        </trans-unit>
        <trans-unit id="be3ad2654f5fa7ba6e1f52aec206ab62cc47cc26" translate="yes" xml:space="preserve">
          <source>When performing an address lookup, zero or more records will be returned. Each record is represented by a QDnsHostAddressRecord instance.</source>
          <target state="translated">アドレス検索を実行すると、0 個以上のレコードが返されます。各レコードは QDnsHostAddressRecord インスタンスで表されます。</target>
        </trans-unit>
        <trans-unit id="63db06c50e58a3513cea1497dec1ed7741831f0b" translate="yes" xml:space="preserve">
          <source>When performing drawing using &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; only, it is also possible to perform the painting like it is done for ordinary widgets: by reimplementing &lt;a href=&quot;qopenglwidget#paintEvent&quot;&gt;paintEvent&lt;/a&gt;().</source>
          <target state="translated">&lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt;のみを使用して描画を実行する場合、通常のウィジェットの場合と同様に、&lt;a href=&quot;qopenglwidget#paintEvent&quot;&gt;paintEvent&lt;/a&gt;（）を再実装することにより、描画を実行することもできます。</target>
        </trans-unit>
        <trans-unit id="4873852a94448fd952353de01e74e6bb7112405f" translate="yes" xml:space="preserve">
          <source>When performing verification steps in an autotest using &lt;a href=&quot;qtest#QCOMPARE&quot;&gt;QCOMPARE&lt;/a&gt;(), &lt;a href=&quot;qtest#QVERIFY&quot;&gt;QVERIFY&lt;/a&gt;(), and so on, side-effects should be avoided. Side-effects in verification steps can make a test difficult to understand. Also, they can easily break a test in ways that are difficult to diagnose when the test is changed to use &lt;a href=&quot;qtest#QTRY_VERIFY&quot;&gt;QTRY_VERIFY&lt;/a&gt;(), &lt;a href=&quot;qtest#QTRY_COMPARE&quot;&gt;QTRY_COMPARE&lt;/a&gt;() or &lt;a href=&quot;qtest#QBENCHMARK&quot;&gt;QBENCHMARK&lt;/a&gt;(). These can execute the passed expression multiple times, thus repeating any side-effects.</source>
          <target state="translated">&lt;a href=&quot;qtest#QCOMPARE&quot;&gt;QCOMPARE&lt;/a&gt;（）、&lt;a href=&quot;qtest#QVERIFY&quot;&gt;QVERIFY&lt;/a&gt;（）などを使用して自動テストで検証手順を実行する場合は、副作用を回避する必要があります。検証ステップの副作用により、テストが理解しにくくなる可能性があります。また、&lt;a href=&quot;qtest#QTRY_VERIFY&quot;&gt;QTRY_VERIFY&lt;/a&gt;（）、&lt;a href=&quot;qtest#QTRY_COMPARE&quot;&gt;QTRY_COMPARE&lt;/a&gt;（）、または&lt;a href=&quot;qtest#QBENCHMARK&quot;&gt;QBENCHMARK&lt;/a&gt;（）を使用するようにテストを変更すると、診断が難しい方法でテストを簡単に中断できます。これらは渡された式を複数回実行できるため、副作用が繰り返されます。</target>
        </trans-unit>
        <trans-unit id="38db5be01962103a3cc7ed36e0dd26d7c49283ec" translate="yes" xml:space="preserve">
          <source>When placed into a &lt;code&gt;.qml&lt;/code&gt; file and loaded by the QML engine, the above code creates a &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle&lt;/a&gt; object using the &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle&lt;/a&gt; type supplied by the &lt;code&gt;QtQuick&lt;/code&gt; module:</source>
          <target state="translated">置かれたとき &lt;code&gt;.qml&lt;/code&gt; ファイルとQMLエンジンによってロードされ、上記のコードは作成&lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;矩形&lt;/a&gt;使用してオブジェクトを&lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;矩形&lt;/a&gt;によって供給されるタイプ &lt;code&gt;QtQuick&lt;/code&gt; のモジュール。</target>
        </trans-unit>
        <trans-unit id="6927c0eac9201c4bf4c31b692534ebe1bbcfa831" translate="yes" xml:space="preserve">
          <source>When populating a layout, the widgets are added to an internal list. The &lt;a href=&quot;qlayout#indexOf&quot;&gt;indexOf&lt;/a&gt;() function returns the index of a widget in that list. The widgets can either be added to the end of the list using the &lt;a href=&quot;qstackedlayout#addWidget&quot;&gt;addWidget&lt;/a&gt;() function, or inserted at a given index using the &lt;a href=&quot;qstackedlayout#insertWidget&quot;&gt;insertWidget&lt;/a&gt;() function. The &lt;a href=&quot;qlayout#removeWidget&quot;&gt;removeWidget&lt;/a&gt;() function removes the widget at the given index from the layout. The number of widgets contained in the layout, can be obtained using the &lt;a href=&quot;qstackedlayout#count-prop&quot;&gt;count&lt;/a&gt;() function.</source>
          <target state="translated">レイアウトにデータを入力すると、ウィジェットが内部リストに追加されます。&lt;a href=&quot;qlayout#indexOf&quot;&gt;indexOf&lt;/a&gt;（）関数は、そのリスト内のウィジェットのインデックスを返します。ウィジェットは、いずれかを使用して、リストの末尾に追加することができる&lt;a href=&quot;qstackedlayout#addWidget&quot;&gt;addWidget&lt;/a&gt;（）関数、または使用して、指定されたインデックスに挿入&lt;a href=&quot;qstackedlayout#insertWidget&quot;&gt;insertWidget&lt;/a&gt;（）関数。&lt;a href=&quot;qlayout#removeWidget&quot;&gt;removeWidget&lt;/a&gt;（）関数は、レイアウトから指定されたインデックスのウィジェットを削除します。レイアウトに含まれるウィジェットの数は、&lt;a href=&quot;qstackedlayout#count-prop&quot;&gt;count&lt;/a&gt;（）関数を使用して取得できます。</target>
        </trans-unit>
        <trans-unit id="9c28b221f7e83baed059e2a307e039e7c948b005" translate="yes" xml:space="preserve">
          <source>When populating a stacked widget, the widgets are added to an internal list. The &lt;a href=&quot;qstackedwidget#indexOf&quot;&gt;indexOf&lt;/a&gt;() function returns the index of a widget in that list. The widgets can either be added to the end of the list using the &lt;a href=&quot;qstackedwidget#addWidget&quot;&gt;addWidget&lt;/a&gt;() function, or inserted at a given index using the &lt;a href=&quot;qstackedwidget#insertWidget&quot;&gt;insertWidget&lt;/a&gt;() function. The &lt;a href=&quot;qstackedwidget#removeWidget&quot;&gt;removeWidget&lt;/a&gt;() function removes a widget from the stacked widget. The number of widgets contained in the stacked widget can be obtained using the &lt;a href=&quot;qstackedwidget#count-prop&quot;&gt;count&lt;/a&gt;() function.</source>
          <target state="translated">スタックされたウィジェットにデータを入力すると、ウィジェットは内部リストに追加されます。&lt;a href=&quot;qstackedwidget#indexOf&quot;&gt;indexOf&lt;/a&gt;（）関数は、そのリスト内のウィジェットのインデックスを返します。ウィジェットは、いずれかを使用して、リストの末尾に追加することができる&lt;a href=&quot;qstackedwidget#addWidget&quot;&gt;addWidget&lt;/a&gt;（）関数、または使用して、指定されたインデックスに挿入&lt;a href=&quot;qstackedwidget#insertWidget&quot;&gt;insertWidget&lt;/a&gt;（）関数。&lt;a href=&quot;qstackedwidget#removeWidget&quot;&gt;removeWidget&lt;/a&gt;（）関数は、積層ウィジェットからウィジェットを除去します。スタックされたウィジェットに含まれるウィジェットの数は、&lt;a href=&quot;qstackedwidget#count-prop&quot;&gt;count&lt;/a&gt;（）関数を使用して取得できます。</target>
        </trans-unit>
        <trans-unit id="543155192f84c64b5b7246452a09145b18b3004c" translate="yes" xml:space="preserve">
          <source>When popup windows are visible, this property is &lt;code&gt;true&lt;/code&gt; for both the active window</source>
          <target state="translated">ポップアップウィンドウが表示されている場合、このプロパティはアクティブウィンドウの両方で &lt;code&gt;true&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="bf9f03d6670f0731b056deb6a40d087fcc1eaf19" translate="yes" xml:space="preserve">
          <source>When positioning a menu with &lt;a href=&quot;qmenu#exec&quot;&gt;exec&lt;/a&gt;() or &lt;a href=&quot;qmenu#popup&quot;&gt;popup&lt;/a&gt;(), bear in mind that you cannot rely on the menu's current &lt;a href=&quot;qwidget#size-prop&quot;&gt;size&lt;/a&gt;(). For performance reasons, the menu adapts its size only when necessary. So in many cases, the size before and after the show is different. Instead, use &lt;a href=&quot;qmenu#sizeHint&quot;&gt;sizeHint&lt;/a&gt;() which calculates the proper size depending on the menu's current contents.</source>
          <target state="translated">&lt;a href=&quot;qmenu#exec&quot;&gt;exec&lt;/a&gt;（）または&lt;a href=&quot;qmenu#popup&quot;&gt;popup&lt;/a&gt;（）でメニューを配置する場合、メニューの現在の&lt;a href=&quot;qwidget#size-prop&quot;&gt;サイズ&lt;/a&gt;（）に依存できないことに注意してください。パフォーマンス上の理由から、メニューは必要な場合にのみサイズを調整します。したがって、多くの場合、ショーの前後でサイズが異なります。代わりに、メニューの現在の内容に応じて適切なサイズを計算する&lt;a href=&quot;qmenu#sizeHint&quot;&gt;sizeHint&lt;/a&gt;（）を使用します。</target>
        </trans-unit>
        <trans-unit id="d446cf9e4868843729e697b92b7ac122b7540da1" translate="yes" xml:space="preserve">
          <source>When positioning a menu with &lt;a href=&quot;qmenu#exec&quot;&gt;exec&lt;/a&gt;() or popup(), bear in mind that you cannot rely on the menu's current &lt;a href=&quot;qwidget#size-prop&quot;&gt;size&lt;/a&gt;(). For performance reasons, the menu adapts its size only when necessary, so in many cases, the size before and after the show is different. Instead, use &lt;a href=&quot;qmenu#sizeHint&quot;&gt;sizeHint&lt;/a&gt;() which calculates the proper size depending on the menu's current contents.</source>
          <target state="translated">&lt;a href=&quot;qmenu#exec&quot;&gt;exec&lt;/a&gt;（）またはpopup（）を使用してメニューを配置する場合、メニューの現在の&lt;a href=&quot;qwidget#size-prop&quot;&gt;サイズ&lt;/a&gt;（）に依存できないことに注意してください。パフォーマンス上の理由から、メニューは必要な場合にのみサイズを調整するため、多くの場合、ショーの前後のサイズは異なります。代わりに、メニューの現在の内容に応じて適切なサイズを計算する&lt;a href=&quot;qmenu#sizeHint&quot;&gt;sizeHint&lt;/a&gt;（）を使用します。</target>
        </trans-unit>
        <trans-unit id="7029c6cc034ef3f728d2bd0679222f0a517d5042" translate="yes" xml:space="preserve">
          <source>When positioning a menu with exec() or &lt;a href=&quot;qmenu#popup&quot;&gt;popup&lt;/a&gt;(), bear in mind that you cannot rely on the menu's current &lt;a href=&quot;qwidget#size-prop&quot;&gt;size&lt;/a&gt;(). For performance reasons, the menu adapts its size only when necessary. So in many cases, the size before and after the show is different. Instead, use &lt;a href=&quot;qmenu#sizeHint&quot;&gt;sizeHint&lt;/a&gt;() which calculates the proper size depending on the menu's current contents.</source>
          <target state="translated">exec（）または&lt;a href=&quot;qmenu#popup&quot;&gt;popup&lt;/a&gt;（）を使用してメニューを配置する場合、メニューの現在の&lt;a href=&quot;qwidget#size-prop&quot;&gt;サイズ&lt;/a&gt;（）に依存できないことに注意してください。パフォーマンス上の理由から、メニューは必要な場合にのみサイズを調整します。そのため、多くの場合、ショーの前後でサイズが異なります。代わりに、メニューの現在の内容に応じて適切なサイズを計算する&lt;a href=&quot;qmenu#sizeHint&quot;&gt;sizeHint&lt;/a&gt;（）を使用してください。</target>
        </trans-unit>
        <trans-unit id="b83e6f455038d9e44dcc627b24af2f87bdc39ec9" translate="yes" xml:space="preserve">
          <source>When possible, it is usually better style to disable the &lt;b&gt;Next&lt;/b&gt; or &lt;b&gt;Finish&lt;/b&gt; button (by specifying &lt;a href=&quot;qwizard#mandatory-fields&quot;&gt;mandatory fields&lt;/a&gt; or by reimplementing &lt;a href=&quot;qwizardpage#isComplete&quot;&gt;QWizardPage::isComplete&lt;/a&gt;()) than to reimplement validateCurrentPage().</source>
          <target state="translated">可能であれば、validateCurrentPage（）を再実装するよりも、（&lt;a href=&quot;qwizard#mandatory-fields&quot;&gt;必須フィールドを&lt;/a&gt;指定するか&lt;a href=&quot;qwizardpage#isComplete&quot;&gt;QWizardPage :: isComplete&lt;/a&gt;（）を再実装することによって）[ &lt;b&gt;次へ]&lt;/b&gt;または[ &lt;b&gt;完了&lt;/b&gt; ]ボタンを無効にするほうが通常は良いスタイルです。</target>
        </trans-unit>
        <trans-unit id="73d1c2ff7aa2a64e8d25144a78e96a2f710b582a" translate="yes" xml:space="preserve">
          <source>When possible, it is usually better style to disable the &lt;b&gt;Next&lt;/b&gt; or &lt;b&gt;Finish&lt;/b&gt; button (by specifying &lt;a href=&quot;qwizard#mandatory-fields&quot;&gt;mandatory fields&lt;/a&gt; or reimplementing &lt;a href=&quot;qwizardpage#isComplete&quot;&gt;isComplete&lt;/a&gt;()) than to reimplement validatePage().</source>
          <target state="translated">可能であれば、validatePage（）を再実装するよりも、（&lt;a href=&quot;qwizard#mandatory-fields&quot;&gt;必須フィールドを&lt;/a&gt;指定するか、&lt;a href=&quot;qwizardpage#isComplete&quot;&gt;isComplete&lt;/a&gt;（）を再実装することによって）[ &lt;b&gt;次へ]&lt;/b&gt;または[ &lt;b&gt;完了&lt;/b&gt; ]ボタンを無効にする方が通常は良いスタイルです。</target>
        </trans-unit>
        <trans-unit id="4c25870dd84e6151f006f88996bd899f2da5153f" translate="yes" xml:space="preserve">
          <source>When possible, this static function will use the native file dialog and not a &lt;a href=&quot;qfiledialog&quot;&gt;QFileDialog&lt;/a&gt;. On platforms which don't support selecting remote files, Qt will allow to select only local files.</source>
          <target state="translated">可能な場合、この静的関数は&lt;a href=&quot;qfiledialog&quot;&gt;QFileDialog&lt;/a&gt;ではなく、ネイティブファイルダイアログを使用します。リモートファイルの選択をサポートしていないプラットフォームでは、Qtはローカルファイルのみを選択できます。</target>
        </trans-unit>
        <trans-unit id="0b489fbd5401aea28516b412c3104164f51acbe1" translate="yes" xml:space="preserve">
          <source>When posting a custom event to the state machine, you typically also have one or more custom transitions that can be triggered from events of that type. To create such a transition, you subclass &lt;a href=&quot;qabstracttransition&quot;&gt;QAbstractTransition&lt;/a&gt; and reimplement &lt;a href=&quot;qabstracttransition#eventTest&quot;&gt;QAbstractTransition::eventTest&lt;/a&gt;(), where you check if an event matches your event type (and optionally other criteria, e.g. attributes of the event object).</source>
          <target state="translated">カスタムイベントをステートマシンにポストする場合、通常、そのタイプのイベントからトリガーできる1つまたは複数のカスタム遷移も用意されています。このような遷移を作成するには、&lt;a href=&quot;qabstracttransition&quot;&gt;QAbstractTransition&lt;/a&gt;をサブクラス化して&lt;a href=&quot;qabstracttransition#eventTest&quot;&gt;QAbstractTransition :: eventTest&lt;/a&gt;（）を再実装します。ここで、イベントがイベントタイプ（およびオプションでイベントオブジェクトの属性などの他の基準）と一致するかどうかを確認します。</target>
        </trans-unit>
        <trans-unit id="c0626bfe8658560f4b9456379db258ae7347f2e4" translate="yes" xml:space="preserve">
          <source>When present in a state set, enables the seamless cubemap texture filtering as provided by the GL_ARB_seamless_cubemap extension (if available).</source>
          <target state="translated">ステートセットに存在する場合、GL_ARB_seamless_cubemapエクステンションで提供されているシームレスなキューブマップテクスチャフィルタリングを有効にします(利用可能な場合)。</target>
        </trans-unit>
        <trans-unit id="dd42c97f91ca6cd533ba12641c6d6512a8021b98" translate="yes" xml:space="preserve">
          <source>When pressing the &quot;Pick Screen Color&quot; button, the cursor changes to a haircross and the colors on the screen are scanned. The user can pick up one by clicking the mouse or the Enter button. Pressing Escape restores the last color selected before entering this mode.</source>
          <target state="translated">Pick Screen Color」ボタンを押すと、カーソルがヘアクロスに変わり、画面上の色をスキャンします。ユーザーは、マウスをクリックするか、Enterボタンをクリックすることで、1つの色をピックアップすることができます。Escapeを押すと、このモードに入る前に選択された最後の色が復元されます。</target>
        </trans-unit>
        <trans-unit id="365ed507c80ed465082d4faf723c11a4f4a529f9" translate="yes" xml:space="preserve">
          <source>When printing directly to a printer on Windows or &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt;, &lt;a href=&quot;qprinter&quot;&gt;QPrinter&lt;/a&gt; uses the built-in printer drivers. On X11, &lt;a href=&quot;qprinter&quot;&gt;QPrinter&lt;/a&gt; uses the &lt;a href=&quot;http://www.cups.org/&quot;&gt;Common Unix Printing System (CUPS)&lt;/a&gt; to send PDF output to the printer. As an alternative, the &lt;a href=&quot;qprinter#printProgram&quot;&gt;printProgram&lt;/a&gt;() function can be used to specify the command or utility to use instead of the system default.</source>
          <target state="translated">Windowsまたは&lt;a href=&quot;internationalization#macos&quot;&gt;macOSの&lt;/a&gt;プリンターに直接印刷する場合、&lt;a href=&quot;qprinter&quot;&gt;QPrinter&lt;/a&gt;は組み込みのプリンタードライバーを使用します。X11では、&lt;a href=&quot;qprinter&quot;&gt;QPrinter&lt;/a&gt;は&lt;a href=&quot;http://www.cups.org/&quot;&gt;Common Unix Printing System（CUPS）&lt;/a&gt;を使用してPDF出力をプリンターに送信します。代わりに、&lt;a href=&quot;qprinter#printProgram&quot;&gt;printProgram&lt;/a&gt;（）関数を使用して、システムのデフォルトの代わりに使用するコマンドまたはユーティリティを指定できます。</target>
        </trans-unit>
        <trans-unit id="9cee561b8e10ced76ed482af9619144ea4d1c14b" translate="yes" xml:space="preserve">
          <source>When printing directly to a printer on Windows or macOS, QPrinter uses the built-in printer drivers. On X11, QPrinter uses the &lt;a href=&quot;http://www.cups.org/&quot;&gt;Common Unix Printing System (CUPS)&lt;/a&gt; to send PDF output to the printer. As an alternative, the &lt;a href=&quot;qprinter#printProgram&quot;&gt;printProgram&lt;/a&gt;() function can be used to specify the command or utility to use instead of the system default.</source>
          <target state="translated">WindowsまたはmacOSのプリンターに直接印刷する場合、QPrinterは組み込みのプリンタードライバーを使用します。X11では、QPrinterは&lt;a href=&quot;http://www.cups.org/&quot;&gt;Common Unix Printing System（CUPS）&lt;/a&gt;を使用してPDF出力をプリンターに送信します。別の方法として、&lt;a href=&quot;qprinter#printProgram&quot;&gt;printProgram&lt;/a&gt;（）関数を使用して、システムのデフォルトの代わりに使用するコマンドまたはユーティリティを指定できます。</target>
        </trans-unit>
        <trans-unit id="7baf1526ab727030bb94d023b433c10155cb76be" translate="yes" xml:space="preserve">
          <source>When processing</source>
          <target state="translated">加工する場合</target>
        </trans-unit>
        <trans-unit id="6d2106bb45d40ac84dd2228f91e6e53dfdbe85fe" translate="yes" xml:space="preserve">
          <source>When processing any of the \code, &lt;a href=&quot;#newcode-command&quot;&gt;\newcode&lt;/a&gt; or &lt;a href=&quot;#oldcode-command&quot;&gt;\oldcode&lt;/a&gt; commands, QDoc removes all indentation that is common for the verbatim code blocks within a &lt;code&gt;/&lt;/code&gt;&lt;code&gt;*!&lt;/code&gt; ... &lt;code&gt;*&lt;/code&gt;&lt;code&gt;/&lt;/code&gt; comment before it adds the standard indentation.</source>
          <target state="translated">\ code、&lt;a href=&quot;#newcode-command&quot;&gt;\ newcode&lt;/a&gt;、&lt;a href=&quot;#oldcode-command&quot;&gt;\ oldcode&lt;/a&gt;コマンドのいずれかを処理するとき、QDocは &lt;code&gt;/&lt;/code&gt; &lt;code&gt;*!&lt;/code&gt; 内の逐語的コードブロックに共通するすべてのインデントを削除します。... &lt;code&gt;*&lt;/code&gt; &lt;code&gt;/&lt;/code&gt; 標準のインデントを追加する前のコメント。</target>
        </trans-unit>
        <trans-unit id="8ac017cc68b793557123c9ce971931fa3dec416c" translate="yes" xml:space="preserve">
          <source>When processing any of the \code, &lt;a href=&quot;06-qdoc-commands-includecodeinline#newcode-command&quot;&gt;\newcode&lt;/a&gt; or &lt;a href=&quot;06-qdoc-commands-includecodeinline#oldcode-command&quot;&gt;\oldcode&lt;/a&gt; commands, QDoc removes all indentation that is common for the verbatim code blocks within a &lt;code&gt;/&lt;/code&gt;&lt;code&gt;*!&lt;/code&gt; ... &lt;code&gt;*&lt;/code&gt;&lt;code&gt;/&lt;/code&gt; comment before it adds the standard indentation.</source>
          <target state="translated">\ code、&lt;a href=&quot;06-qdoc-commands-includecodeinline#newcode-command&quot;&gt;\ newcode、&lt;/a&gt;または&lt;a href=&quot;06-qdoc-commands-includecodeinline#oldcode-command&quot;&gt;\ oldcode&lt;/a&gt;コマンドのいずれかを処理するとき、QDocは &lt;code&gt;/&lt;/code&gt; &lt;code&gt;*!&lt;/code&gt; 内の逐語的なコードブロックに共通するすべてのインデントを削除します。... &lt;code&gt;*&lt;/code&gt; &lt;code&gt;/&lt;/code&gt; 標準のインデントを追加する前にコメントします。</target>
        </trans-unit>
        <trans-unit id="0cc162586167c5dda9673822a3e347c76baa904e" translate="yes" xml:space="preserve">
          <source>When processing the &lt;code&gt;headers&lt;/code&gt; variable, QDoc behaves in the same way as it does when processing the &lt;a href=&quot;#headerdirs&quot;&gt;&lt;code&gt;headerdirs&lt;/code&gt;&lt;/a&gt; variable. For more information, see the &lt;a href=&quot;#headerdirs&quot;&gt;&lt;code&gt;headerdirs&lt;/code&gt;&lt;/a&gt; variable.</source>
          <target state="translated">&lt;code&gt;headers&lt;/code&gt; 変数を処理するとき、QDocは&lt;a href=&quot;#headerdirs&quot;&gt; &lt;code&gt;headerdirs&lt;/code&gt; &lt;/a&gt;変数を処理するときと同じように動作します。詳細については、&lt;a href=&quot;#headerdirs&quot;&gt; &lt;code&gt;headerdirs&lt;/code&gt; &lt;/a&gt;変数を参照してください。</target>
        </trans-unit>
        <trans-unit id="9f6649e82a5699a0360075ae40dd46b9e5c7a464" translate="yes" xml:space="preserve">
          <source>When processing the &lt;code&gt;headers&lt;/code&gt; variable, QDoc behaves in the same way as it does when processing the &lt;a href=&quot;22-qdoc-configuration-generalvariables#headerdirs&quot;&gt;&lt;code&gt;headerdirs&lt;/code&gt;&lt;/a&gt; variable. For more information, see the &lt;a href=&quot;22-qdoc-configuration-generalvariables#headerdirs&quot;&gt;&lt;code&gt;headerdirs&lt;/code&gt;&lt;/a&gt; variable.</source>
          <target state="translated">&lt;code&gt;headers&lt;/code&gt; 変数を処理する場合、QDocは&lt;a href=&quot;22-qdoc-configuration-generalvariables#headerdirs&quot;&gt; &lt;code&gt;headerdirs&lt;/code&gt; &lt;/a&gt;変数を処理する場合と同じように動作します。詳細については、&lt;a href=&quot;22-qdoc-configuration-generalvariables#headerdirs&quot;&gt; &lt;code&gt;headerdirs&lt;/code&gt; &lt;/a&gt;変数を参照してください。</target>
        </trans-unit>
        <trans-unit id="8485caf25338b1f76aa184669dce3005f004482c" translate="yes" xml:space="preserve">
          <source>When processing the &lt;code&gt;images&lt;/code&gt; variable, QDoc behaves in the same way as it does when processing the &lt;a href=&quot;#imagedirs&quot;&gt;&lt;code&gt;imagedirs&lt;/code&gt;&lt;/a&gt; variable. For more information, see the &lt;a href=&quot;#imagedirs&quot;&gt;&lt;code&gt;imagedirs&lt;/code&gt;&lt;/a&gt; variable.</source>
          <target state="translated">&lt;code&gt;images&lt;/code&gt; 変数を処理するとき、QDocは&lt;a href=&quot;#imagedirs&quot;&gt; &lt;code&gt;imagedirs&lt;/code&gt; &lt;/a&gt;変数を処理するときと同じように動作します。詳細については、&lt;a href=&quot;#imagedirs&quot;&gt; &lt;code&gt;imagedirs&lt;/code&gt; &lt;/a&gt;変数を参照してください。</target>
        </trans-unit>
        <trans-unit id="83b7b87983b264f92514be824ef568bf74fc4531" translate="yes" xml:space="preserve">
          <source>When processing the &lt;code&gt;images&lt;/code&gt; variable, QDoc behaves in the same way as it does when processing the &lt;a href=&quot;22-qdoc-configuration-generalvariables#imagedirs&quot;&gt;&lt;code&gt;imagedirs&lt;/code&gt;&lt;/a&gt; variable. For more information, see the &lt;a href=&quot;22-qdoc-configuration-generalvariables#imagedirs&quot;&gt;&lt;code&gt;imagedirs&lt;/code&gt;&lt;/a&gt; variable.</source>
          <target state="translated">&lt;code&gt;images&lt;/code&gt; 変数を処理するとき、QDocは&lt;a href=&quot;22-qdoc-configuration-generalvariables#imagedirs&quot;&gt; &lt;code&gt;imagedirs&lt;/code&gt; &lt;/a&gt;変数を処理するときと同じように動作します。詳細については、&lt;a href=&quot;22-qdoc-configuration-generalvariables#imagedirs&quot;&gt; &lt;code&gt;imagedirs&lt;/code&gt; &lt;/a&gt;変数を参照してください。</target>
        </trans-unit>
        <trans-unit id="02ac4cb127779361e46edccdd9715135c772a6b4" translate="yes" xml:space="preserve">
          <source>When processing the &lt;code&gt;sources&lt;/code&gt; variable, QDoc behaves in the same way as it does when processing the &lt;a href=&quot;#sourcedirs-variable&quot;&gt;sourcedirs&lt;/a&gt; variable. For more information, see the &lt;a href=&quot;#sourcedirs-variable&quot;&gt;sourcedirs&lt;/a&gt; variable.</source>
          <target state="translated">&lt;code&gt;sources&lt;/code&gt; 変数を処理するとき、QDocは&lt;a href=&quot;#sourcedirs-variable&quot;&gt;sourcedirs&lt;/a&gt;変数を処理するときと同じように動作します。詳細については、&lt;a href=&quot;#sourcedirs-variable&quot;&gt;sourcedirs&lt;/a&gt;変数を参照してください。</target>
        </trans-unit>
        <trans-unit id="cad134d8c8f7cf34f150e5381504660ade1079a5" translate="yes" xml:space="preserve">
          <source>When processing the &lt;code&gt;sources&lt;/code&gt; variable, QDoc behaves in the same way as it does when processing the &lt;a href=&quot;22-qdoc-configuration-generalvariables#sourcedirs-variable&quot;&gt;sourcedirs&lt;/a&gt; variable. For more information, see the &lt;a href=&quot;22-qdoc-configuration-generalvariables#sourcedirs-variable&quot;&gt;sourcedirs&lt;/a&gt; variable.</source>
          <target state="translated">&lt;code&gt;sources&lt;/code&gt; 変数を処理する場合、QDocは&lt;a href=&quot;22-qdoc-configuration-generalvariables#sourcedirs-variable&quot;&gt;sourcedirs&lt;/a&gt;変数を処理する場合と同じように動作します。詳細については、&lt;a href=&quot;22-qdoc-configuration-generalvariables#sourcedirs-variable&quot;&gt;sourcedirs&lt;/a&gt;変数を参照してください。</target>
        </trans-unit>
        <trans-unit id="d2f6258fc95387a5c4367b7340551e8c1e093ed8" translate="yes" xml:space="preserve">
          <source>When processing the header files specified in the &lt;a href=&quot;#headerdirs&quot;&gt;&lt;code&gt;headerdirs&lt;/code&gt;&lt;/a&gt; variable, QDoc will only read the files with the fileextensions specified in the &lt;code&gt;headers.fileextensions&lt;/code&gt; variable. In this way QDoc avoids spending time reading irrelevant files.</source>
          <target state="translated">で指定されたヘッダファイル処理するとき&lt;a href=&quot;#headerdirs&quot;&gt; &lt;code&gt;headerdirs&lt;/code&gt; &lt;/a&gt;変数を、のQDocはfileextensionsでファイルを読み込みますに指定された &lt;code&gt;headers.fileextensions&lt;/code&gt; の変数。このようにして、QDocは無関係なファイルの読み取りに時間を費やすことを回避します。</target>
        </trans-unit>
        <trans-unit id="e6e737bd0bca30837e70dbf0ba50e38a69eda1ae" translate="yes" xml:space="preserve">
          <source>When processing the header files specified in the &lt;a href=&quot;22-qdoc-configuration-generalvariables#headerdirs&quot;&gt;&lt;code&gt;headerdirs&lt;/code&gt;&lt;/a&gt; variable, QDoc will only read the files with the fileextensions specified in the &lt;code&gt;headers.fileextensions&lt;/code&gt; variable. In this way QDoc avoids spending time reading irrelevant files.</source>
          <target state="translated">で指定されたヘッダファイル処理するとき&lt;a href=&quot;22-qdoc-configuration-generalvariables#headerdirs&quot;&gt; &lt;code&gt;headerdirs&lt;/code&gt; &lt;/a&gt;変数を、のQDocはfileextensionsでファイルを読み込みますに指定された &lt;code&gt;headers.fileextensions&lt;/code&gt; の変数。このようにして、QDocは無関係なファイルの読み取りに時間を費やすことを回避します。</target>
        </trans-unit>
        <trans-unit id="4ed979007a1c43ad6e1c65933f5ff78d1bf33f42" translate="yes" xml:space="preserve">
          <source>When processing the source files specified in the &lt;a href=&quot;#sourcedirs&quot;&gt;&lt;code&gt;sourcedirs&lt;/code&gt;&lt;/a&gt; variable, QDoc will only read the files with the fileextensions specified in the &lt;code&gt;sources.fileextensions&lt;/code&gt; variable. In this way QDoc avoid spending time reading irrelevant files.</source>
          <target state="translated">&lt;a href=&quot;#sourcedirs&quot;&gt; &lt;code&gt;sourcedirs&lt;/code&gt; &lt;/a&gt;変数で指定されたソースファイルを処理するとき、QDocは &lt;code&gt;sources.fileextensions&lt;/code&gt; 変数で指定されたファイル拡張子を持つファイルのみを読み取ります。このようにして、QDocは無関係なファイルの読み取りに時間を費やすことを避けます。</target>
        </trans-unit>
        <trans-unit id="cfdcd3052995a6aaff22f71ef5141edb96daddb2" translate="yes" xml:space="preserve">
          <source>When processing the source files specified in the &lt;a href=&quot;22-qdoc-configuration-generalvariables#sourcedirs&quot;&gt;&lt;code&gt;sourcedirs&lt;/code&gt;&lt;/a&gt; variable, QDoc will only read the files with the fileextensions specified in the &lt;code&gt;sources.fileextensions&lt;/code&gt; variable. In this way QDoc avoid spending time reading irrelevant files.</source>
          <target state="translated">&lt;a href=&quot;22-qdoc-configuration-generalvariables#sourcedirs&quot;&gt; &lt;code&gt;sourcedirs&lt;/code&gt; &lt;/a&gt;変数で指定されたソースファイルを処理する場合、QDocは &lt;code&gt;sources.fileextensions&lt;/code&gt; 変数で指定されたfileextensionsを持つファイルのみを読み取ります。このようにして、QDocは無関係なファイルの読み取りに時間を費やすことを回避します。</target>
        </trans-unit>
        <trans-unit id="f3b3725626f2e2c1e184c3a3386769f3ccdb3009" translate="yes" xml:space="preserve">
          <source>When properties are defined on a &lt;a href=&quot;qt3dcore-qnode&quot;&gt;QNode&lt;/a&gt; subclass, their NOTIFY signal will automatically generate notifications that the Qt3D backend aspects will receive.</source>
          <target state="translated">プロパティが&lt;a href=&quot;qt3dcore-qnode&quot;&gt;QNode&lt;/a&gt;サブクラスで定義されると、それらのNOTIFYシグナルはQt3Dバックエンドアスペクトが受け取る通知を自動的に生成します。</target>
        </trans-unit>
        <trans-unit id="c17f593088b99a91dc585e42d8e3fdd068f8c76c" translate="yes" xml:space="preserve">
          <source>When properties are defined on a QNode subclass, their NOTIFY signal will automatically generate notifications that the Qt3D backend aspects will receive.</source>
          <target state="translated">QNodeサブクラス上でプロパティが定義されている場合、そのNOTIFYシグナルは自動的にQt3Dバックエンドのアスペクトが受け取る通知を生成します。</target>
        </trans-unit>
        <trans-unit id="22650f203b3bc55d65cd8bcc3c197b3e1ae94f80" translate="yes" xml:space="preserve">
          <source>When protecting for a short-term operation, it is acceptable to call &lt;a href=&quot;qlockfile#lock&quot;&gt;lock&lt;/a&gt;() and wait until any running operation finishes. When protecting a resource over a long time, however, the application should always call &lt;a href=&quot;qlockfile#setStaleLockTime&quot;&gt;setStaleLockTime&lt;/a&gt;(0) and then &lt;a href=&quot;qlockfile#tryLock&quot;&gt;tryLock&lt;/a&gt;() with a short timeout, in order to warn the user that the resource is locked.</source>
          <target state="translated">短期間の操作を保護する場合は、&lt;a href=&quot;qlockfile#lock&quot;&gt;lock&lt;/a&gt;（）を呼び出して、実行中の操作が完了するまで待つことは許容されます。ただし、リソースを長期間保護する場合は、リソースがロックされていることをユーザーに警告するために、アプリケーションは常に&lt;a href=&quot;qlockfile#setStaleLockTime&quot;&gt;setStaleLockTime&lt;/a&gt;（0）を呼び出してから、短いタイムアウトで&lt;a href=&quot;qlockfile#tryLock&quot;&gt;tryLock&lt;/a&gt;（）を呼び出す必要があります。</target>
        </trans-unit>
        <trans-unit id="a64c630f83dc14fe3268c28b76ebc5e8374c55e6" translate="yes" xml:space="preserve">
          <source>When providing your own attributes, it may make sense to name your attribute using helpers such as &lt;a href=&quot;qt3dcore-qattribute#defaultPositionAttributeName&quot;&gt;QAttribute::defaultPositionAttributeName&lt;/a&gt;() as that will ensure your geometry will be compatible with picking and the various materials provided in the &lt;a href=&quot;https://doc.qt.io/qt-6.0/qt3dextras-module.html&quot;&gt;Qt3DExtras&lt;/a&gt; module.</source>
          <target state="translated">独自の属性を提供する場合は、&lt;a href=&quot;qt3dcore-qattribute#defaultPositionAttributeName&quot;&gt;QAttribute :: defaultPositionAttributeName&lt;/a&gt;（）などのヘルパーを使用して属性に名前を付けると、ジオメトリがピッキングや&lt;a href=&quot;https://doc.qt.io/qt-6.0/qt3dextras-module.html&quot;&gt;Qt3DExtras&lt;/a&gt;モジュールで提供されるさまざまなマテリアルと互換性があることを確認できます。</target>
        </trans-unit>
        <trans-unit id="12b6bb01343a6f269ac19359f22a3d9b836dd641" translate="yes" xml:space="preserve">
          <source>When providing your own attributes, it may make sense to name your attribute using helpers such as &lt;a href=&quot;qt3drender-qattribute#defaultPositionAttributeName&quot;&gt;QAttribute::defaultPositionAttributeName&lt;/a&gt;() as that will ensure your geometry will be compatible with picking and the various materials provided in the &lt;a href=&quot;https://doc.qt.io/qt-5.13/qt3dextras-module.html&quot;&gt;Qt3DExtras&lt;/a&gt; module.</source>
          <target state="translated">独自の属性を提供する場合、&lt;a href=&quot;qt3drender-qattribute#defaultPositionAttributeName&quot;&gt;QAttribute :: defaultPositionAttributeName&lt;/a&gt;（）などのヘルパーを使用して属性に名前を付けると、ジオメトリがピッキングおよび&lt;a href=&quot;https://doc.qt.io/qt-5.13/qt3dextras-module.html&quot;&gt;Qt3DExtras&lt;/a&gt;モジュールで提供されるさまざまなマテリアルと互換性を持つようになります。</target>
        </trans-unit>
        <trans-unit id="1c5031580380ec45abd2184625b064726bd7956e" translate="yes" xml:space="preserve">
          <source>When providing your own attributes, it may make sense to name your attribute using helpers such as &lt;a href=&quot;qt3drender-qattribute#defaultPositionAttributeName&quot;&gt;QAttribute::defaultPositionAttributeName&lt;/a&gt;() as that will ensure your geometry will be compatible with picking and the various materials provided in the &lt;a href=&quot;https://doc.qt.io/qt-5.15/qt3dextras-module.html&quot;&gt;Qt3DExtras&lt;/a&gt; module.</source>
          <target state="translated">独自の属性を提供する場合は、&lt;a href=&quot;qt3drender-qattribute#defaultPositionAttributeName&quot;&gt;QAttribute :: defaultPositionAttributeName&lt;/a&gt;（）などのヘルパーを使用して属性に名前を付けると、ジオメトリがピッキングや&lt;a href=&quot;https://doc.qt.io/qt-5.15/qt3dextras-module.html&quot;&gt;Qt3DExtras&lt;/a&gt;モジュールで提供されるさまざまなマテリアルと互換性があることを確認できます。</target>
        </trans-unit>
        <trans-unit id="83204666112336ac2cd938437ecd85c2c9e42c43" translate="yes" xml:space="preserve">
          <source>When providing your own attributes, it may make sense to name your attribute using helpers such as QAttribute::defaultPositionAttributeName() as that will ensure your geometry will be compatible with picking and the various materials provided in the &lt;a href=&quot;https://doc.qt.io/qt-5.13/qt3dextras-module.html&quot;&gt;Qt3DExtras&lt;/a&gt; module.</source>
          <target state="translated">独自の属性を提供する場合、QAttribute :: defaultPositionAttributeName（）などのヘルパーを使用して属性に名前を付けると、ジオメトリがピッキングおよび&lt;a href=&quot;https://doc.qt.io/qt-5.13/qt3dextras-module.html&quot;&gt;Qt3DExtras&lt;/a&gt;モジュールで提供されるさまざまなマテリアルと互換性を持つようになるため、意味がある場合があります。</target>
        </trans-unit>
        <trans-unit id="7f0b771b8b6122f451fd39a4eec632c95f8abf9c" translate="yes" xml:space="preserve">
          <source>When providing your own attributes, it may make sense to name your attribute using helpers such as QAttribute::defaultPositionAttributeName() as that will ensure your geometry will be compatible with picking and the various materials provided in the &lt;a href=&quot;https://doc.qt.io/qt-5.15/qt3dextras-module.html&quot;&gt;Qt3DExtras&lt;/a&gt; module.</source>
          <target state="translated">独自の属性を提供する場合は、QAttribute :: defaultPositionAttributeName（）などのヘルパーを使用して属性に名前を付けると、ジオメトリがピッキングや&lt;a href=&quot;https://doc.qt.io/qt-5.15/qt3dextras-module.html&quot;&gt;Qt3DExtras&lt;/a&gt;モジュールで提供されるさまざまなマテリアルと互換性があることを確認できます。</target>
        </trans-unit>
        <trans-unit id="4d403f2b317d8a25ea1daa5531b9d0846e0f0138" translate="yes" xml:space="preserve">
          <source>When providing your own attributes, it may make sense to name your attribute using helpers such as QAttribute::defaultPositionAttributeName() as that will ensure your geometry will be compatible with picking and the various materials provided in the &lt;a href=&quot;https://doc.qt.io/qt-6.0/qt3dextras-module.html&quot;&gt;Qt3DExtras&lt;/a&gt; module.</source>
          <target state="translated">独自の属性を提供する場合は、QAttribute :: defaultPositionAttributeName（）などのヘルパーを使用して属性に名前を付けると、ジオメトリがピッキングや&lt;a href=&quot;https://doc.qt.io/qt-6.0/qt3dextras-module.html&quot;&gt;Qt3DExtras&lt;/a&gt;モジュールで提供されるさまざまなマテリアルと互換性があることを確認できます。</target>
        </trans-unit>
        <trans-unit id="7be4e2868f53c5c712c37033765565589dd9a696" translate="yes" xml:space="preserve">
          <source>When qmake is run, an &lt;code&gt;Info.plist&lt;/code&gt; file is generated with appropriate default values.</source>
          <target state="translated">qmakeを実行すると、 &lt;code&gt;Info.plist&lt;/code&gt; ファイルが適切なデフォルト値で生成されます。</target>
        </trans-unit>
        <trans-unit id="deaab1579f95ca0cb54a7c45e2f6602842f9bf55" translate="yes" xml:space="preserve">
          <source>When qmake processes the project file, it will generate a Makefile rule to allow the project to be built in both modes. This can be invoked in the following way:</source>
          <target state="translated">qmake がプロジェクトファイルを処理すると、両方のモードでプロジェクトをビルドできるように Makefile ルールが生成されます。これは以下の方法で呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="433bf4e26978749cad77ae5bdc38533c0acb441e" translate="yes" xml:space="preserve">
          <source>When queries are generated to be executed on the database only those fields for which &lt;a href=&quot;qsqlrecord#isGenerated&quot;&gt;isGenerated&lt;/a&gt;() is true are included in the generated SQL.</source>
          <target state="translated">クエリが生成されてデータベースで実行されると、&lt;a href=&quot;qsqlrecord#isGenerated&quot;&gt;isGenerated&lt;/a&gt;（）がtrue であるフィールドのみが生成されたSQLに含まれます。</target>
        </trans-unit>
        <trans-unit id="9333afa0fced835478399e93823c406d22de675b" translate="yes" xml:space="preserve">
          <source>When quoting is disabled, these types are printed without quotation characters and without escaping of non-printable characters.</source>
          <target state="translated">引用符を無効にすると、これらのタイプは引用符なしで印刷され、印刷不可能な文字のエスケープなしで印刷されます。</target>
        </trans-unit>
        <trans-unit id="2e3a5904501c88a29777d21a5ea08bedba058dd9" translate="yes" xml:space="preserve">
          <source>When reading from QByteArray(), the &lt;a href=&quot;qcborstreamreader#addData&quot;&gt;addData&lt;/a&gt;() function automatically calls this function. Calling it when the reading had not failed is a no-op.</source>
          <target state="translated">QByteArray（）から読み取る場合、&lt;a href=&quot;qcborstreamreader#addData&quot;&gt;addData&lt;/a&gt;（）関数はこの関数を自動的に呼び出します。読み取りが失敗しなかったときにそれを呼び出すことはノーオペレーションです。</target>
        </trans-unit>
        <trans-unit id="2961583e309be088817f7af5160b0e7c63f99641" translate="yes" xml:space="preserve">
          <source>When reading, the end-of-line terminators are translated to '\n'. When writing, the end-of-line terminators are translated to the local encoding, for example '\r\n' for Win32.</source>
          <target state="translated">読む時は、行末締めは'\n'に翻訳される。書くときには、行末の終端文字は、ローカルのエンコーディングに翻訳されます。</target>
        </trans-unit>
        <trans-unit id="0178fb06130fa3ace5f0116314a30ba2905b8155" translate="yes" xml:space="preserve">
          <source>When receiving an input method event, the text widget has to performs the following steps:</source>
          <target state="translated">入力メソッドイベントを受信すると、テキストウィジェットは以下のステップを実行しなければなりません。</target>
        </trans-unit>
        <trans-unit id="bc54aed1354ce805c861b084074c4b15f2941b02" translate="yes" xml:space="preserve">
          <source>When registered with QML in this way, they can be used as property types:</source>
          <target state="translated">このように QML に登録すると、プロパティタイプとして使用することができます。</target>
        </trans-unit>
        <trans-unit id="6de85969ab467e39090e43789eb7746771150552" translate="yes" xml:space="preserve">
          <source>When registered with the QML engine in this way, they can be used as property types:</source>
          <target state="translated">このように QML エンジンに登録すると、プロパティタイプとして使用することができます。</target>
        </trans-unit>
        <trans-unit id="658aa3d331e786b5cf19cdc003900fc565a01ebd" translate="yes" xml:space="preserve">
          <source>When reimplementing &lt;a href=&quot;qabstractitemmodel#insertColumns&quot;&gt;insertColumns&lt;/a&gt;() in a subclass, you must call this function</source>
          <target state="translated">サブクラスで&lt;a href=&quot;qabstractitemmodel#insertColumns&quot;&gt;insertColumns&lt;/a&gt;（）を再実装する場合は、この関数を呼び出す必要があります</target>
        </trans-unit>
        <trans-unit id="4c93d0d6698e3e63d88035f6f5efca5fb6102f1c" translate="yes" xml:space="preserve">
          <source>When reimplementing &lt;a href=&quot;qabstractitemmodel#insertRows&quot;&gt;insertRows&lt;/a&gt;() in a subclass, you must call this function</source>
          <target state="translated">サブクラスで&lt;a href=&quot;qabstractitemmodel#insertRows&quot;&gt;insertRows&lt;/a&gt;（）を再実装する場合は、この関数を呼び出す必要があります</target>
        </trans-unit>
        <trans-unit id="85d1f3aba6b52c7b19fa00f7d1afc309113e34b8" translate="yes" xml:space="preserve">
          <source>When reimplementing &lt;a href=&quot;qabstractitemmodel#removeColumns&quot;&gt;removeColumns&lt;/a&gt;() in a subclass, you must call this function</source>
          <target state="translated">サブクラスで&lt;a href=&quot;qabstractitemmodel#removeColumns&quot;&gt;removeColumns&lt;/a&gt;（）を再実装する場合は、この関数を呼び出す必要があります</target>
        </trans-unit>
        <trans-unit id="f37a182e5a69ec7aec2bf70e9e8e6c7db8177d59" translate="yes" xml:space="preserve">
          <source>When reimplementing &lt;a href=&quot;qabstractitemmodel#removeRows&quot;&gt;removeRows&lt;/a&gt;() in a subclass, you must call this function</source>
          <target state="translated">サブクラスで&lt;a href=&quot;qabstractitemmodel#removeRows&quot;&gt;removeRows&lt;/a&gt;（）を再実装する場合は、この関数を呼び出す必要があります</target>
        </trans-unit>
        <trans-unit id="9b0330becdc29ff2c73cb6957330004540cba4dd" translate="yes" xml:space="preserve">
          <source>When reimplementing &lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt; functions that take a &lt;a href=&quot;qstyleoption&quot;&gt;QStyleOption&lt;/a&gt; parameter, you often need to cast the &lt;a href=&quot;qstyleoption&quot;&gt;QStyleOption&lt;/a&gt; to a subclass (e.g., &lt;a href=&quot;qstyleoptionfocusrect&quot;&gt;QStyleOptionFocusRect&lt;/a&gt;). For safety, you can use &lt;a href=&quot;qstyleoption#qstyleoption_cast&quot;&gt;qstyleoption_cast&lt;/a&gt;() to ensure that the pointer type is correct. If the object isn't of the right type, &lt;a href=&quot;qstyleoption#qstyleoption_cast&quot;&gt;qstyleoption_cast&lt;/a&gt;() returns &lt;code&gt;nullptr&lt;/code&gt;. For example:</source>
          <target state="translated">&lt;a href=&quot;qstyleoption&quot;&gt;QStyleOption&lt;/a&gt;パラメータを取る&lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt;関数を再実装する場合、&lt;a href=&quot;qstyleoption&quot;&gt;QStyleOption&lt;/a&gt;をサブクラス（例：&lt;a href=&quot;qstyleoptionfocusrect&quot;&gt;QStyleOptionFocusRect&lt;/a&gt;）にキャストする必要があることがよくあります。安全のために、&lt;a href=&quot;qstyleoption#qstyleoption_cast&quot;&gt;qstyleoption_cast&lt;/a&gt;（）を使用して、ポインター型が正しいことを確認できます。オブジェクトのタイプが&lt;a href=&quot;qstyleoption#qstyleoption_cast&quot;&gt;正しく&lt;/a&gt;ない場合、qstyleoption_cast（）は &lt;code&gt;nullptr&lt;/code&gt; を返します。例えば：</target>
        </trans-unit>
        <trans-unit id="9dfc851c4dac23e39db3f903a4238131999a47c4" translate="yes" xml:space="preserve">
          <source>When reimplementing &lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt; functions that take a &lt;a href=&quot;qstyleoption&quot;&gt;QStyleOption&lt;/a&gt; parameter, you often need to cast the &lt;a href=&quot;qstyleoption&quot;&gt;QStyleOption&lt;/a&gt; to a subclass. For safety, you can use &lt;a href=&quot;qstyleoption#qstyleoption_cast&quot;&gt;qstyleoption_cast&lt;/a&gt;() to ensure that the pointer type is correct. For example:</source>
          <target state="translated">&lt;a href=&quot;qstyleoption&quot;&gt;QStyleOption&lt;/a&gt;パラメータを取る&lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt;関数を再実装する場合、&lt;a href=&quot;qstyleoption&quot;&gt;QStyleOption&lt;/a&gt;をサブクラスにキャストする必要があることがよくあります。安全のために、&lt;a href=&quot;qstyleoption#qstyleoption_cast&quot;&gt;qstyleoption_cast&lt;/a&gt;（）を使用して、ポインター型が正しいことを確認できます。例えば：</target>
        </trans-unit>
        <trans-unit id="7c3a36cf890d4e609cd3054eba937187efb84074" translate="yes" xml:space="preserve">
          <source>When reimplementing &lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt; functions that take a QStyleOption parameter, you often need to cast the QStyleOption to a subclass. For safety, you can use &lt;a href=&quot;qstyleoption#qstyleoption_cast&quot;&gt;qstyleoption_cast&lt;/a&gt;() to ensure that the pointer type is correct. For example:</source>
          <target state="translated">QStyleOptionパラメーターを&lt;a href=&quot;qstyle&quot;&gt;受け取るQStyle&lt;/a&gt;関数を再実装する場合、多くの場合、QStyleOptionをサブクラスにキャストする必要があります。安全のために、&lt;a href=&quot;qstyleoption#qstyleoption_cast&quot;&gt;qstyleoption_cast&lt;/a&gt;（）を使用して、ポインターのタイプが正しいことを確認できます。例えば：</target>
        </trans-unit>
        <trans-unit id="ec235ac06dbbca492dcbe4cfde2eff2f73ed2863" translate="yes" xml:space="preserve">
          <source>When reimplementing &lt;a href=&quot;qstyleditemdelegate#paint&quot;&gt;paint&lt;/a&gt;(), one would typically handle the datatypes one would like to draw and use the superclass implementation for other types.</source>
          <target state="translated">&lt;a href=&quot;qstyleditemdelegate#paint&quot;&gt;paint&lt;/a&gt;（）を再実装する場合、通常は、描画したいデータ型を処理し、他の型のスーパークラス実装を使用します。</target>
        </trans-unit>
        <trans-unit id="fb3e42362330e9b7392e5e0ebae5fafed9a1a17a" translate="yes" xml:space="preserve">
          <source>When reimplementing a subclass, this method simplifies moving entities in your model. This method is responsible for moving persistent indexes in the model, which you would otherwise be required to do yourself. Using beginMoveColumns and &lt;a href=&quot;qabstractitemmodel#endMoveColumns&quot;&gt;endMoveColumns&lt;/a&gt; is an alternative to emitting &lt;a href=&quot;qabstractitemmodel#layoutAboutToBeChanged&quot;&gt;layoutAboutToBeChanged&lt;/a&gt; and &lt;a href=&quot;qabstractitemmodel#layoutChanged&quot;&gt;layoutChanged&lt;/a&gt; directly along with &lt;a href=&quot;qabstractitemmodel#changePersistentIndex&quot;&gt;changePersistentIndex&lt;/a&gt;.</source>
          <target state="translated">サブクラスを再実装する場合、このメソッドはモデル内のエンティティの移動を簡素化します。このメソッドは、モデル内の永続インデックスの移動を担当します。そうしないと、自分で行う必要があります。beginMoveColumns及び使用&lt;a href=&quot;qabstractitemmodel#endMoveColumns&quot;&gt;endMoveColumnsは&lt;/a&gt;発光に代わるもの&lt;a href=&quot;qabstractitemmodel#layoutAboutToBeChanged&quot;&gt;layoutAboutToBeChanged&lt;/a&gt;と&lt;a href=&quot;qabstractitemmodel#layoutChanged&quot;&gt;layoutChanged&lt;/a&gt;と共に直接&lt;a href=&quot;qabstractitemmodel#changePersistentIndex&quot;&gt;changePersistentIndex&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="37d54556abfd5846d3b883b6100f1fa44ae8b968" translate="yes" xml:space="preserve">
          <source>When reimplementing a subclass, this method simplifies moving entities in your model. This method is responsible for moving persistent indexes in the model, which you would otherwise be required to do yourself. Using beginMoveRows and &lt;a href=&quot;qabstractitemmodel#endMoveRows&quot;&gt;endMoveRows&lt;/a&gt; is an alternative to emitting &lt;a href=&quot;qabstractitemmodel#layoutAboutToBeChanged&quot;&gt;layoutAboutToBeChanged&lt;/a&gt; and &lt;a href=&quot;qabstractitemmodel#layoutChanged&quot;&gt;layoutChanged&lt;/a&gt; directly along with &lt;a href=&quot;qabstractitemmodel#changePersistentIndex&quot;&gt;changePersistentIndex&lt;/a&gt;.</source>
          <target state="translated">サブクラスを再実装する場合、このメソッドはモデル内のエンティティの移動を簡素化します。このメソッドは、モデル内の永続インデックスの移動を担当します。そうしないと、自分で行う必要があります。beginMoveRowsと&lt;a href=&quot;qabstractitemmodel#endMoveRows&quot;&gt;endMoveRows&lt;/a&gt;を使用することは、&lt;a href=&quot;qabstractitemmodel#layoutAboutToBeChanged&quot;&gt;changePersistentIndex&lt;/a&gt;と&lt;a href=&quot;qabstractitemmodel#layoutChanged&quot;&gt;一緒に&lt;/a&gt;直接layoutAboutToBeChangedとlayoutChangedを発行する代わりに&lt;a href=&quot;qabstractitemmodel#changePersistentIndex&quot;&gt;なり&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="ca95dc0c0eb787c2eeed20255a0cb245f62492af" translate="yes" xml:space="preserve">
          <source>When reimplementing canRead(), make sure that the I/O device (&lt;a href=&quot;qimageiohandler#device&quot;&gt;device&lt;/a&gt;()) is left in its original state (e.g., by using peek() rather than &lt;a href=&quot;qimageiohandler#read&quot;&gt;read&lt;/a&gt;()).</source>
          <target state="translated">canRead（）を再実装するときは、I / Oデバイス（&lt;a href=&quot;qimageiohandler#device&quot;&gt;device&lt;/a&gt;（））が元の状態のままであることを確認してください（たとえば、&lt;a href=&quot;qimageiohandler#read&quot;&gt;read&lt;/a&gt;（）ではなくpeek（）を使用して）。</target>
        </trans-unit>
        <trans-unit id="028d93193544c8ed47ad98dfeadb939c5667b03b" translate="yes" xml:space="preserve">
          <source>When reimplementing paint in a subclass. Use the &lt;a href=&quot;qstyleditemdelegate#initStyleOption&quot;&gt;initStyleOption&lt;/a&gt;() to set up the</source>
          <target state="translated">サブクラスでペイントを再実装する場合。&lt;a href=&quot;qstyleditemdelegate#initStyleOption&quot;&gt;initStyleOption&lt;/a&gt;（）を使用して、</target>
        </trans-unit>
        <trans-unit id="df7f5f683e515c4160cc8d6065b4b4913422655c" translate="yes" xml:space="preserve">
          <source>When reimplementing the &lt;a href=&quot;qabstractitemmodel#setData&quot;&gt;setData&lt;/a&gt;() function, this signal must be emitted explicitly.</source>
          <target state="translated">&lt;a href=&quot;qabstractitemmodel#setData&quot;&gt;setData&lt;/a&gt;（）関数を再実装する場合、このシグナルは明示的に発行する必要があります。</target>
        </trans-unit>
        <trans-unit id="6f516d38e016de108e31954fe638b31e63f64384" translate="yes" xml:space="preserve">
          <source>When reimplementing the &lt;a href=&quot;qabstractitemmodel#setHeaderData&quot;&gt;setHeaderData&lt;/a&gt;() function, this signal must be emitted explicitly.</source>
          <target state="translated">&lt;a href=&quot;qabstractitemmodel#setHeaderData&quot;&gt;setHeaderData&lt;/a&gt;（）関数を再実装する場合、このシグナルは明示的に発行する必要があります。</target>
        </trans-unit>
        <trans-unit id="8bb42c54f45079c9c25f1595264e446c8f5dae51" translate="yes" xml:space="preserve">
          <source>When reimplementing the &lt;a href=&quot;qeventtransition#eventTest&quot;&gt;eventTest&lt;/a&gt;() function, you should first call the base implementation to verify that the event is a &lt;a href=&quot;qstatemachine-wrappedevent&quot;&gt;QStateMachine::WrappedEvent&lt;/a&gt; for the proper object and event type. You may then cast the event to a &lt;a href=&quot;qstatemachine-wrappedevent&quot;&gt;QStateMachine::WrappedEvent&lt;/a&gt; and get the original event by calling &lt;a href=&quot;qstatemachine-wrappedevent#event&quot;&gt;QStateMachine::WrappedEvent::event&lt;/a&gt;(), and perform additional checks on that object.</source>
          <target state="translated">&lt;a href=&quot;qeventtransition#eventTest&quot;&gt;eventTest&lt;/a&gt;（）関数を再実装する場合、最初に基本実装を呼び出して、イベントが適切なオブジェクトとイベントタイプの&lt;a href=&quot;qstatemachine-wrappedevent&quot;&gt;QStateMachine :: WrappedEvent&lt;/a&gt;であることを確認する必要があります。次に、イベントを&lt;a href=&quot;qstatemachine-wrappedevent&quot;&gt;QStateMachine :: WrappedEventに&lt;/a&gt;キャストし、&lt;a href=&quot;qstatemachine-wrappedevent#event&quot;&gt;QStateMachine :: WrappedEvent :: event&lt;/a&gt;（）を呼び出して元のイベントを取得し、そのオブジェクトに対して追加のチェックを実行します。</target>
        </trans-unit>
        <trans-unit id="b124ac10b911b199139a9b1396e9a53e131374c7" translate="yes" xml:space="preserve">
          <source>When reimplementing this class, take care to return at least one element.</source>
          <target state="translated">このクラスを再実装する際には、少なくとも1つの要素を返すように注意してください。</target>
        </trans-unit>
        <trans-unit id="55e2b93bd22d4647e3de872d6613c4f4629fae05" translate="yes" xml:space="preserve">
          <source>When reimplementing this function in a subclass, be careful to avoid calling &lt;a href=&quot;qmodelindex&quot;&gt;QModelIndex&lt;/a&gt; member functions, such as &lt;a href=&quot;qmodelindex#parent&quot;&gt;QModelIndex::parent&lt;/a&gt;(), since indexes belonging to your model will simply call your implementation, leading to infinite recursion.</source>
          <target state="translated">この関数をサブクラスで再実装するときは、&lt;a href=&quot;qmodelindex#parent&quot;&gt;QModelIndex :: parent&lt;/a&gt;（）などの&lt;a href=&quot;qmodelindex&quot;&gt;QModelIndex&lt;/a&gt;メンバー関数を呼び出さないように注意してください。モデルに属するインデックスが実装を呼び出すだけなので、無限再帰が発生します。</target>
        </trans-unit>
        <trans-unit id="70e5caa7bbddd6d74b4efb7d8a7005f9825d497b" translate="yes" xml:space="preserve">
          <source>When reimplementing this function in a subclass, call &lt;a href=&quot;qabstractitemmodel#createIndex&quot;&gt;createIndex&lt;/a&gt;() to generate model indexes that other components can use to refer to items in your model.</source>
          <target state="translated">この関数をサブクラスで再実装する場合は、&lt;a href=&quot;qabstractitemmodel#createIndex&quot;&gt;createIndex&lt;/a&gt;（）を呼び出して、他のコンポーネントがモデル内のアイテムを参照するために使用できるモデルインデックスを生成します。</target>
        </trans-unit>
        <trans-unit id="ba7f9d147f366305cacefe9a55e635566170bc6d" translate="yes" xml:space="preserve">
          <source>When reimplementing this function in a subclass, you should update the area held by the option's &lt;a href=&quot;qstyleoption#rect-var&quot;&gt;rect&lt;/a&gt; variable, using the option's &lt;a href=&quot;qstyleoption#state-var&quot;&gt;state&lt;/a&gt; variable to determine the state of the item to be displayed, and adjust the way it is painted accordingly.</source>
          <target state="translated">この関数をサブクラスで再実装するときは、オプションの&lt;a href=&quot;qstyleoption#rect-var&quot;&gt;rect&lt;/a&gt;変数が保持する領域を更新し、オプションの&lt;a href=&quot;qstyleoption#state-var&quot;&gt;状態&lt;/a&gt;変数を使用して表示する項目の状態を決定し、それに応じて描画される方法を調整する必要があります。</target>
        </trans-unit>
        <trans-unit id="4e2d2f89b79fefee58d5613beec7b9bd5dde6fb5" translate="yes" xml:space="preserve">
          <source>When reimplementing this function it is important that this function reads all the required data before returning. This is required in order for &lt;a href=&quot;qdatastream&quot;&gt;QDataStream&lt;/a&gt; to be able to operate on the class. &lt;a href=&quot;qdatastream&quot;&gt;QDataStream&lt;/a&gt; assumes all the requested information was read and therefore does not retry reading if there was a problem.</source>
          <target state="translated">この関数を再実装する場合、この関数が戻る前に必要なすべてのデータを読み取ることが重要です。これは、&lt;a href=&quot;qdatastream&quot;&gt;QDataStream&lt;/a&gt;がクラスを操作できるようにするために必要です。&lt;a href=&quot;qdatastream&quot;&gt;QDataStream&lt;/a&gt;は、要求されたすべての情報が読み取られたと想定しているため、問題が発生しても読み取りを再試行しません。</target>
        </trans-unit>
        <trans-unit id="e93d19bd100346fac19905c7b4a51959378ca55b" translate="yes" xml:space="preserve">
          <source>When reimplementing this function it is important that this function writes all the data available before returning. This is required in order for &lt;a href=&quot;qdatastream&quot;&gt;QDataStream&lt;/a&gt; to be able to operate on the class. &lt;a href=&quot;qdatastream&quot;&gt;QDataStream&lt;/a&gt; assumes all the information was written and therefore does not retry writing if there was a problem.</source>
          <target state="translated">この関数を再実装する場合、戻る前に、この関数が使用可能なすべてのデータを書き込むことが重要です。これは、&lt;a href=&quot;qdatastream&quot;&gt;QDataStream&lt;/a&gt;がクラスを操作できるようにするために必要です。&lt;a href=&quot;qdatastream&quot;&gt;QDataStream&lt;/a&gt;はすべての情報が書き込まれたと想定しているため、問題が発生しても書き込みを再試行しません。</target>
        </trans-unit>
        <trans-unit id="dbe06314296a3392519e885c147e88b10b0594de" translate="yes" xml:space="preserve">
          <source>When reimplementing this function, note that in case of text items, &lt;a href=&quot;qitemdelegate&quot;&gt;QItemDelegate&lt;/a&gt; adds a margin (i.e. 2 * &lt;a href=&quot;qstyle#PixelMetric-enum&quot;&gt;QStyle::PM_FocusFrameHMargin&lt;/a&gt;) to the length of the text.</source>
          <target state="translated">この関数を再実装する場合、テキスト項目の場合、&lt;a href=&quot;qitemdelegate&quot;&gt;QItemDelegate&lt;/a&gt;はテキストの長さにマージン（つまり2 * &lt;a href=&quot;qstyle#PixelMetric-enum&quot;&gt;QStyle :: PM_FocusFrameHMargin&lt;/a&gt;）を追加することに注意してください。</target>
        </trans-unit>
        <trans-unit id="197ccf9da55fd735f9643d4ab74a6bddeec9dfb0" translate="yes" xml:space="preserve">
          <source>When reimplementing this function, the &lt;a href=&quot;qabstractitemmodel#headerDataChanged&quot;&gt;headerDataChanged&lt;/a&gt;() signal must be emitted explicitly.</source>
          <target state="translated">この関数を再実装する場合、&lt;a href=&quot;qabstractitemmodel#headerDataChanged&quot;&gt;headerDataChanged&lt;/a&gt;（）シグナルを明示的に発行する必要があります。</target>
        </trans-unit>
        <trans-unit id="89a145bd42509fd307493a0a0013f21ce6e0557c" translate="yes" xml:space="preserve">
          <source>When relative paths are specified, qmake will mangle them into a form understood by the dynamic linker to be relative to the location of the referring executable or library. This is supported only by some platforms (currently Linux and Darwin-based ones) and is detectable by checking whether &lt;a href=&quot;#qmake-rel-rpath-base&quot;&gt;QMAKE_REL_RPATH_BASE&lt;/a&gt; is set.</source>
          <target state="translated">相対パスを指定すると、qmakeは、それらを参照元の実行可能ファイルまたはライブラリの場所を基準にして動的リンカーが理解できる形式に変換します。これは一部のプラットフォーム（現在はLinuxおよびDarwinベースのプラットフォーム）でのみサポートされており、&lt;a href=&quot;#qmake-rel-rpath-base&quot;&gt;QMAKE_REL_RPATH_BASE&lt;/a&gt;が設定されているかどうかを確認することで検出できます。</target>
        </trans-unit>
        <trans-unit id="c2230aceb836e5f2b704deb69243134974a878df" translate="yes" xml:space="preserve">
          <source>When relative paths are specified, qmake will mangle them into a form understood by the dynamic linker to be relative to the location of the referring executable or library. This is supported only by some platforms (currently Linux and Darwin-based ones) and is detectable by checking whether &lt;a href=&quot;qmake-variable-reference#qmake-rel-rpath-base&quot;&gt;QMAKE_REL_RPATH_BASE&lt;/a&gt; is set.</source>
          <target state="translated">相対パスが指定されている場合、qmakeはそれらを、参照している実行可能ファイルまたはライブラリの場所に相対的であるとダイナミックリンカが理解できる形式にマングルします。これは一部のプラットフォーム（現在はLinuxおよびDarwinベースのプラットフォーム）でのみサポートされており、&lt;a href=&quot;qmake-variable-reference#qmake-rel-rpath-base&quot;&gt;QMAKE_REL_RPATH_BASE&lt;/a&gt;が設定されているかどうかを確認することで検出できます。</target>
        </trans-unit>
        <trans-unit id="9719c3fc7ea7358a427a328cfee1c891b8f4d398" translate="yes" xml:space="preserve">
          <source>When rendering a 3D scene, there are many scenarios where there is a need to embed 2D elements into 3D. There are two different ways to integrate 2D content inside of 3D scenes, each of which has its own path to get to the screen.</source>
          <target state="translated">3Dシーンをレンダリングする際に、2D要素を3Dに埋め込む必要があるシナリオはたくさんあります。3Dシーンの中に2Dコンテンツを組み込むには、2つの異なる方法があり、それぞれが画面に到達するまでのパスを持っています。</target>
        </trans-unit>
        <trans-unit id="b737ba18762f9d815ad8cc904c2c8daeaec43e4b" translate="yes" xml:space="preserve">
          <source>When rendering graphics, the matrix defines the transformations but the actual transformation is performed by the drawing routines in &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt;.</source>
          <target state="translated">グラフィックスをレンダリングするとき、マトリックスは変換を定義しますが、実際の変換は&lt;a href=&quot;qpainter&quot;&gt;QPainterの&lt;/a&gt;描画ルーチンによって実行されます。</target>
        </trans-unit>
        <trans-unit id="376ba91e9e24af226abc158db0a7aa54457a58c9" translate="yes" xml:space="preserve">
          <source>When rendering with OpenGL, the &lt;a href=&quot;gui-changes-qt6#qopenglcontext&quot;&gt;QOpenGLContext&lt;/a&gt; of this window will be bound when this function is called. The only exception is if the native OpenGL has been destroyed outside Qt's control, for instance through EGL_CONTEXT_LOST.</source>
          <target state="translated">OpenGLでレンダリングする場合、この関数が呼び出されると、このウィンドウの&lt;a href=&quot;gui-changes-qt6#qopenglcontext&quot;&gt;QOpenGLContext&lt;/a&gt;がバインドされます。唯一の例外は、ネイティブOpenGLがQtの制御外で、たとえばEGL_CONTEXT_LOSTによって破棄された場合です。</target>
        </trans-unit>
        <trans-unit id="e5653d7216920813d6171f95584427875defe394" translate="yes" xml:space="preserve">
          <source>When rendering with a graphics API where the concept is not applicable,</source>
          <target state="translated">概念が適用されないグラフィックスAPIでレンダリングする場合</target>
        </trans-unit>
        <trans-unit id="7c5109171a737854a9ba5a71e30fd9bd78572ca4" translate="yes" xml:space="preserve">
          <source>When rendering with a pen with an even number of pixels, the pixels will be rendered symetrically around the mathematical defined points, while rendering with a pen with an odd number of pixels, the spare pixel will be rendered to the right and below the mathematical point as in the one pixel case. See the &lt;a href=&quot;qrectf&quot;&gt;QRectF&lt;/a&gt; diagrams below for concrete examples.</source>
          <target state="translated">偶数のピクセルを持つペンでレンダリングする場合、ピクセルは数学的に定義された点の周りに対称的にレンダリングされますが、奇数のピクセルを持つペンでレンダリングする場合、予備のピクセルは数学的なポイントの右下にレンダリングされます1ピクセルの場合と同様です。具体的な例については、以下の&lt;a href=&quot;qrectf&quot;&gt;QRectF&lt;/a&gt;図を参照してください。</target>
        </trans-unit>
        <trans-unit id="f6bb9fd28f420249ac748ef0297e189cfdea3c23" translate="yes" xml:space="preserve">
          <source>When rendering with a two pixels wide pen the boundary line will be split in the middle by the mathematical rectangle. This will be the case whenever the pen is set to an even number of pixels, while rendering with a pen with an odd number of pixels, the spare pixel will be rendered to the right and below the mathematical rectangle as in the one pixel case.</source>
          <target state="translated">幅が 2 ピクセルのペンでレンダリングすると、 境界線は数学的な矩形によって中央で分割されます。これは、ペンが偶数ピクセルに設定されている場合にはいつでもそうなりますが、奇数ピクセルのペンでレンダリングする場合には、1 ピクセルの場合と同様に予備のピクセルが数学的矩形の右下にレンダリングされます。</target>
        </trans-unit>
        <trans-unit id="d7e0077b12f54b280554348b8d31ed612bede88e" translate="yes" xml:space="preserve">
          <source>When rendering, &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; protects the painter state (see &lt;a href=&quot;qpainter#save&quot;&gt;QPainter::save&lt;/a&gt;()) when rendering the background or foreground, and when rendering each item. This allows you to leave the painter in an altered state (i.e., you can call &lt;a href=&quot;qpainter#setPen&quot;&gt;QPainter::setPen&lt;/a&gt;() or &lt;a href=&quot;qpainter#setBrush&quot;&gt;QPainter::setBrush&lt;/a&gt;() without restoring the state after painting). However, if the items consistently do restore the state, you should enable this flag to prevent &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; from doing the same.</source>
          <target state="translated">レンダリング時、&lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt;は、背景または前景をレンダリングするとき、および各項目をレンダリングするときに、ペインターの状態（QPainter &lt;a href=&quot;qpainter#save&quot;&gt;:: save&lt;/a&gt;（）を参照）を保護します。これにより、ペインタを変更した状態のままにすることができます（つまり、ペイント後に状態を復元せずに&lt;a href=&quot;qpainter#setBrush&quot;&gt;QPainter &lt;/a&gt;&lt;a href=&quot;qpainter#setPen&quot;&gt;:: setPen&lt;/a&gt;（）またはQPainter :: setBrush（）を呼び出すことができます）。ただし、アイテムが常に状態を復元する場合は、このフラグを有効にして&lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt;が同じ状態にならないようにする必要があります。</target>
        </trans-unit>
        <trans-unit id="d51a24d95c26c19a346a37f3dd7e864ef01ea9d8" translate="yes" xml:space="preserve">
          <source>When rendering, Graphics View's scene coordinates correspond to &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt;'s</source>
          <target state="translated">レンダリング時、グラフィックスビューのシーン座標は&lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt;の</target>
        </trans-unit>
        <trans-unit id="b351cd57358f6774989d1cb0e0f8f4b5f818e8c3" translate="yes" xml:space="preserve">
          <source>When requesting an index for a model item, we must provide some information about the item's parent. Outside the model, the only way to refer to an item is through a model index, so a parent model index must also be given:</source>
          <target state="translated">モデル・アイテムのインデックスを要求するとき、アイテムの親についての情報を提供しなければなりません。モデルの外では、アイテムを参照する唯一の方法はモデル・インデックスを介しているので、親モデル・インデックスも与えなければなりません。</target>
        </trans-unit>
        <trans-unit id="e3462b37efc9ed9435b6be891fff238475c5b943" translate="yes" xml:space="preserve">
          <source>When resizeEvent() is called, the viewport already has its new geometry: Its new size is accessible through the &lt;a href=&quot;qresizeevent#size&quot;&gt;QResizeEvent::size&lt;/a&gt;() function, and the old size through &lt;a href=&quot;qresizeevent#oldSize&quot;&gt;QResizeEvent::oldSize&lt;/a&gt;().</source>
          <target state="translated">resizeEvent（）が呼び出されると、ビューポートにはすでに新しいジオメトリがあります。その新しいサイズには&lt;a href=&quot;qresizeevent#size&quot;&gt;QResizeEvent :: size&lt;/a&gt;（）関数を使用してアクセスでき、古いサイズには&lt;a href=&quot;qresizeevent#oldSize&quot;&gt;QResizeEvent :: oldSize&lt;/a&gt;（）を使用してアクセスできます。</target>
        </trans-unit>
        <trans-unit id="459145d7e5e0a2dddcfe14e374a8a522472aa332" translate="yes" xml:space="preserve">
          <source>When returning from C++, the engine will interrupt the normal flow of execution and call the the next pre-registered exception handler with an error object that contains the given</source>
          <target state="translated">C++から戻るとき、エンジンは通常の実行フローを中断し、与えられた</target>
        </trans-unit>
        <trans-unit id="90d305ada35629da8b28508d253830cb3271219a" translate="yes" xml:space="preserve">
          <source>When rubberband selection ends this signal will be emitted with null vales.</source>
          <target state="translated">ラバーバンド選択が終了すると、この信号はヌルベ-ルで出力されます。</target>
        </trans-unit>
        <trans-unit id="d7d3ba7b84a869b7ec4d6428c30a1e381f521d40" translate="yes" xml:space="preserve">
          <source>When run in a Norwegian locale, this code could for instance display &quot;Price is kr 6,00&quot; for a one-dollar product.</source>
          <target state="translated">ノルウェーのロケールで実行した場合、このコードは、例えば、1ドルの商品について「価格はkr 6,00です」と表示することができます。</target>
        </trans-unit>
        <trans-unit id="f4b4ea8160e44027a1643f73bd2b4fc24a630c0f" translate="yes" xml:space="preserve">
          <source>When running QDoc to generate HTML, the example above will have no effect on the generated output, but if you run QDoc to generate DITA XML, the example will generate the following:</source>
          <target state="translated">QDocを実行してHTMLを生成する場合、上記の例では生成された出力に影響はありませんが、QDocを実行してDITA XMLを生成する場合は以下のようになります。</target>
        </trans-unit>
        <trans-unit id="313916658b849b20eb8b38c2b36d5a604ba7482c" translate="yes" xml:space="preserve">
          <source>When running QDoc to generate HTML, the example above will have no effect on the generated output.</source>
          <target state="translated">QDocを実行してHTMLを生成する場合、上記の例では生成された出力に影響はありません。</target>
        </trans-unit>
        <trans-unit id="68eca509dfd034e35a8f7fa47ec0779beae30c64" translate="yes" xml:space="preserve">
          <source>When running Qt Web Engine examples in a Docker container and browsing content-heavy sites, BUS errors (SIGBUS) might be reported. Typically, this is caused by Docker running a container with a too small memory space (such as 64MB). To fix this problem, increase the memory space size.</source>
          <target state="translated">DockerコンテナでQt Web Engineのサンプルを実行してコンテンツの多いサイトを閲覧すると、BUSエラー(SIGBUS)が報告されることがあります。一般的に、これはDockerでコンテナを実行しているときにメモリ容量が小さすぎる(64MBなど)ことが原因です。この問題を解決するには、メモリスペースのサイズを大きくします。</target>
        </trans-unit>
        <trans-unit id="e7b5c8f813c3abfb4aaffaf280cd321b1b8726b4" translate="yes" xml:space="preserve">
          <source>When running Qt-based applications without a windowing system, such as X11 or Wayland, some devices require vendor-specific adaptation code for EGL and OpenGL ES support. This is provided in form of backends for the EGLFS platform plugin. This is not relevant for non-accelerated platforms, such as those that use the &lt;a href=&quot;embedded-linux#linuxfb&quot;&gt;LinuxFB&lt;/a&gt; platform plugin, which is meant for software-based rendering only. As of Qt 6, many embedded systems use &lt;a href=&quot;https://en.wikipedia.org/wiki/Direct_Rendering_Manager&quot;&gt;drm&lt;/a&gt; to set a video mode, manage display connectors and graphical surfaces. For example, an NXP i.MX8-based device or a Raspberry Pi 4 will use this approach, and therefore the most commonly used backend for EGLFS is &lt;b&gt;eglfs_kms&lt;/b&gt;, which enables EGL and OpenGL ES based rendering with &lt;code&gt;drm&lt;/code&gt;, using &lt;code&gt;gbm&lt;/code&gt; for surface and buffer management. Older devices, such as the NXP i.MX6, will continue to use the legacy, GPU vendor-specific approach to connect EGL window surfaces to the framebuffer, using dedicated eglfs backends, such as &lt;code&gt;eglfs_viv&lt;/code&gt;.</source>
          <target state="translated">X11やWaylandなどのウィンドウシステムなしでQtベースのアプリケーションを実行する場合、一部のデバイスでは、EGLおよびOpenGLESをサポートするためにベンダー固有の適応コードが必要です。これは、EGLFSプラットフォームプラグインのバックエンドの形式で提供されます。これは、ソフトウェアベースのレンダリングのみを目的とした&lt;a href=&quot;embedded-linux#linuxfb&quot;&gt;LinuxFB&lt;/a&gt;プラットフォームプラグインを使用するプラットフォームなど、高速化されていないプラットフォームには関係ありません。 Qt 6の時点で、多くの組み込みシステムは&lt;a href=&quot;https://en.wikipedia.org/wiki/Direct_Rendering_Manager&quot;&gt;drm&lt;/a&gt;を使用してビデオモードを設定し、ディスプレイコネクタとグラフィックサーフェスを管理します。たとえば、NXPi.MX8ベースのデバイスまたはRaspberryPi 4はこのアプローチを使用するため、EGLFSで最も一般的に使用されるバックエンドはeglfs_kmsです。これにより、 &lt;code&gt;gbm&lt;/code&gt; を使用して &lt;code&gt;drm&lt;/code&gt; でEGLおよび&lt;b&gt;OpenGLES&lt;/b&gt;ベースのレンダリングが可能になります。表面およびバッファ管理用。例えばNXP i.MX6などの古いデバイスは、例えば、専用eglfsバックエンド、使用して、フレームバッファに接続EGLウィンドウ面にレガシー、GPUベンダー固有のアプローチを使用し続ける &lt;code&gt;eglfs_viv&lt;/code&gt; を。</target>
        </trans-unit>
        <trans-unit id="ba74a44a4fe513e0e864500ccf8b7805d12bdf2c" translate="yes" xml:space="preserve">
          <source>When running the advertising procedure, a number of parameters can be configured, such as how fast to advertise or which clients, if any, can connect to the advertising device. These parameters are set via this class, and their values will be used when advertising is started by calling &lt;a href=&quot;qlowenergycontroller#startAdvertising&quot;&gt;QLowEnergyController::startAdvertising&lt;/a&gt;().</source>
          <target state="translated">アドバタイズ手順を実行するときに、アドバタイズの速度や、クライアントがある場合はアドバタイズデバイスに接続できるクライアントなど、多くのパラメータを設定できます。これらのパラメーターはこのクラスを介して設定され、それらの値は&lt;a href=&quot;qlowenergycontroller#startAdvertising&quot;&gt;QLowEnergyController :: startAdvertising&lt;/a&gt;（）を呼び出して広告が開始されるときに使用されます。</target>
        </trans-unit>
        <trans-unit id="1e481bcca4c1c2d1651c8ca7889240a246da99ad" translate="yes" xml:space="preserve">
          <source>When running with the OpenGL backend of Qt Quick, both the generic, triangulation-based and the NVIDIA-specific &lt;code&gt;GL_NV_path_rendering&lt;/code&gt; methods are available. By default only the generic approach is used. Setting Shape.&lt;a href=&quot;qml-qtquick-shapes-shape#vendorExtensionsEnabled-prop&quot;&gt;vendorExtensionsEnabled&lt;/a&gt; property to &lt;code&gt;true&lt;/code&gt; leads to using NV_path_rendering on NVIDIA systems when running directly on OpenGL, and the generic method on others. When OpenGL is not used directly by the scene graph, for example because it is using the graphics abstraction layer (QRhi), only the generic shape renderer is available.</source>
          <target state="translated">Qt QuickのOpenGLバックエンドで実行する場合、汎用の三角測量ベースのメソッドとNVIDIA固有の &lt;code&gt;GL_NV_path_rendering&lt;/code&gt; メソッドの両方を使用できます。デフォルトでは、一般的なアプローチのみが使用されます。形状の設定。&lt;a href=&quot;qml-qtquick-shapes-shape#vendorExtensionsEnabled-prop&quot;&gt;vendorExtensionsEnabled&lt;/a&gt;プロパティを &lt;code&gt;true&lt;/code&gt; にすると、OpenGLで直接実行する場合はNVIDIAシステムでNV_path_renderingを使用し、その他のシステムでは汎用メソッドを使用します。OpenGLがシーングラフで直接使用されていない場合、たとえば、グラフィックス抽象化レイヤー（QRhi）を使用している場合、汎用のシェイプレンダラーのみが使用可能です。</target>
        </trans-unit>
        <trans-unit id="419ca242c0e809f26e319a45853b06288d62f271" translate="yes" xml:space="preserve">
          <source>When running with the OpenGL backend of the scene graph, &lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow&lt;/a&gt; offers the possibility to disable persistent OpenGL contexts as well. This setting is currently ignored by &lt;a href=&quot;qquickwidget&quot;&gt;QQuickWidget&lt;/a&gt; and the context is always persistent. The OpenGL context is thus not destroyed when hiding the widget. The context is destroyed only when the widget is destroyed or when the widget gets reparented into another top-level widget's child hierarchy. However, some applications, in particular those that have their own graphics resources due to performing custom OpenGL rendering in the Qt Quick scene, may wish to disable the latter since they may not be prepared to handle the loss of the context when moving a &lt;a href=&quot;qquickwidget&quot;&gt;QQuickWidget&lt;/a&gt; into another window. Such applications can set the QCoreApplication::AA_ShareOpenGLContexts attribute. For a discussion on the details of resource initialization and cleanup, refer to the &lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidget&lt;/a&gt; documentation.</source>
          <target state="translated">&lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow&lt;/a&gt;は、シーングラフのOpenGLバックエンドで実行する場合、永続的なOpenGLコンテキストを無効にすることもできます。この設定は現在&lt;a href=&quot;qquickwidget&quot;&gt;QQuickWidget&lt;/a&gt;によって無視され、コンテキストは常に永続的です。したがって、ウィジェットを非表示にしても、OpenGLコンテキストは破棄されません。コンテキストが破棄されるのは、ウィジェットが破棄されたとき、またはウィジェットが別の最上位ウィジェットの子階層に親化されたときだけです。ただし、一部のアプリケーション、特にQt QuickシーンでカスタムOpenGLレンダリングを実行するために独自のグラフィックリソースを備えているアプリケーションは、&lt;a href=&quot;qquickwidget&quot;&gt;QQuickWidgetを&lt;/a&gt;移動するときにコンテキストの損失を処理する準備ができていないため、後者を無効にしたい場合があります別のウィンドウに。このようなアプリケーションは、QCoreApplication :: AA_ShareOpenGLContexts属性を設定できます。リソースの初期化とクリーンアップの詳細については、&lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidgetの&lt;/a&gt;ドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="31fa69229e2655989faeea8c24fbc639c55aaf43" translate="yes" xml:space="preserve">
          <source>When running with the OpenGL backend of the scene graph, &lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow&lt;/a&gt; offers the possibility to disable persistent OpenGL contexts as well. This setting is currently ignored by QQuickWidget and the context is always persistent. The OpenGL context is thus not destroyed when hiding the widget. The context is destroyed only when the widget is destroyed or when the widget gets reparented into another top-level widget's child hierarchy. However, some applications, in particular those that have their own graphics resources due to performing custom OpenGL rendering in the Qt Quick scene, may wish to disable the latter since they may not be prepared to handle the loss of the context when moving a QQuickWidget into another window. Such applications can set the QCoreApplication::AA_ShareOpenGLContexts attribute. For a discussion on the details of resource initialization and cleanup, refer to the &lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidget&lt;/a&gt; documentation.</source>
          <target state="translated">シーングラフのOpenGLバックエンドで実行する場合、&lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow&lt;/a&gt;永続的なOpenGLコンテキストも無効にする可能性を提供します。この設定は現在QQuickWidgetによって無視され、コンテキストは常に永続的です。したがって、ウィジェットを非表示にしても、OpenGLコンテキストは破棄されません。コンテキストは、ウィジェットが破棄されたとき、またはウィジェットが別の最上位ウィジェットの子階層に再ペアレント化されたときにのみ破棄されます。ただし、一部のアプリケーション、特にQt QuickシーンでカスタムOpenGLレンダリングを実行するために独自のグラフィックリソースを持っているアプリケーションでは、QQuickWidgetをに移動するときにコンテキストの損失を処理する準備ができていないため、後者を無効にすることができます。別のウィンドウ。このようなアプリケーションは、QCoreApplication :: AA_ShareOpenGLContexts属性を設定できます。リソースの初期化とクリーンアップの詳細については、&lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidgetの&lt;/a&gt;ドキュメント。</target>
        </trans-unit>
        <trans-unit id="c2dc3890a6015b8657ffa4853aa53e53b5b8b626" translate="yes" xml:space="preserve">
          <source>When running with the OpenGL backend of the scene graph, &lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow&lt;/a&gt; offers the possibility to disable persistent OpenGL contexts as well. This setting is currently ignored by QQuickWidget and the context is always persistent. The OpenGL context is thus not destroyed when hiding the widget. The context is destroyed only when the widget is destroyed or when the widget gets reparented into another top-level widget's child hierarchy. However, some applications, in particular those that have their own graphics resources due to performing custom OpenGL rendering in the Qt Quick scene, may wish to disable the latter since they may not be prepared to handle the loss of the context when moving a QQuickWidget into another window. Such applications can set the QCoreApplication::AA_ShareOpenGLContexts attribute. For a discussion on the details of resource initialization and cleanup, refer to the QOpenGLWidget documentation.</source>
          <target state="translated">シーングラフのOpenGLバックエンドで実行する場合、&lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow&lt;/a&gt;永続的なOpenGLコンテキストも無効にする可能性を提供します。この設定は現在QQuickWidgetによって無視され、コンテキストは常に永続的です。したがって、ウィジェットを非表示にしても、OpenGLコンテキストは破棄されません。コンテキストは、ウィジェットが破棄されたとき、またはウィジェットが別の最上位ウィジェットの子階層に再ペアレント化されたときにのみ破棄されます。ただし、一部のアプリケーション、特にQt QuickシーンでカスタムOpenGLレンダリングを実行するために独自のグラフィックリソースを持っているアプリケーションでは、QQuickWidgetをに移動するときにコンテキストの損失を処理する準備ができていないため、後者を無効にすることができます。別のウィンドウ。このようなアプリケーションは、QCoreApplication :: AA_ShareOpenGLContexts属性を設定できます。リソースの初期化とクリーンアップの詳細については、QOpenGLWidgetのドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="4180cc40e3670129f26ab3b8aa7583731a04bc4b" translate="yes" xml:space="preserve">
          <source>When running with the default, OpenGL backend of Qt Quick, both the generic, triangulation-based and the NVIDIA-specific &lt;code&gt;GL_NV_path_rendering&lt;/code&gt; methods are available. By default only the generic approach is used. Setting Shape.&lt;a href=&quot;qml-qtquick-shapes-shape#vendorExtensionsEnabled-prop&quot;&gt;vendorExtensionsEnabled&lt;/a&gt; property to &lt;code&gt;true&lt;/code&gt; leads to using NV_path_rendering on NVIDIA systems, and the generic method on others.</source>
          <target state="translated">Qt QuickのデフォルトのOpenGLバックエンドで実行する場合、一般的な三角測量ベースのメソッドとNVIDIA固有の &lt;code&gt;GL_NV_path_rendering&lt;/code&gt; メソッドの両方を使用できます。デフォルトでは、一般的なアプローチのみが使用されます。形状を設定します。&lt;a href=&quot;qml-qtquick-shapes-shape#vendorExtensionsEnabled-prop&quot;&gt;vendorExtensionsEnabled&lt;/a&gt;プロパティを &lt;code&gt;true&lt;/code&gt; に設定すると、NVIDIAシステムでNV_path_renderingが使用され、他のシステムではジェネリックメソッドが使用されます。</target>
        </trans-unit>
        <trans-unit id="22c17b7b950b81783fdb923684eedfd560adcd81" translate="yes" xml:space="preserve">
          <source>When runtime compilation is not in use and the shader properties refer to files with bytecode, the status is always Compiled. The contents of the shader is not examined (apart from basic reflection to discover vertex input elements and constant buffer data) until later in the rendering pipeline so potential errors (like layout or root signature mismatches) will only be detected at a later point.</source>
          <target state="translated">ランタイムコンパイルが使用されておらず、シェーダのプロパティがバイトコードのファイルを参照している場合、ステータスは常にコンパイルされています。シェーダの内容は(頂点入力要素や定数バッファデータを検出するための基本的な反射を除いて)レンダリングパイプラインの後半になるまで検査されないため、潜在的なエラー(レイアウトやルートシグネチャのミスマッチなど)が検出されるのは後になってからになります。</target>
        </trans-unit>
        <trans-unit id="58111d4b497d62daae3e0a09bff9a306f73c232a" translate="yes" xml:space="preserve">
          <source>When sampling textures other than &lt;code&gt;SCREEN_TEXTURE&lt;/code&gt; and &lt;code&gt;DEPTH_TEXTURE&lt;/code&gt;, or when &lt;code&gt;FRAGCOORD&lt;/code&gt; is used to calculate the texture coordinate (which would be the typical use case for accessing the screen and depth textures), such an adjustment is not necessary.</source>
          <target state="translated">&lt;code&gt;SCREEN_TEXTURE&lt;/code&gt; と &lt;code&gt;DEPTH_TEXTURE&lt;/code&gt; 以外のテクスチャをサンプリングする場合、または &lt;code&gt;FRAGCOORD&lt;/code&gt; を使用してテクスチャ座標を計算する場合（画面と深度のテクスチャにアクセスするための一般的な使用例）、このような調整は必要ありません。</target>
        </trans-unit>
        <trans-unit id="1cf799c203f3447ab5ee733162b36bb8365e9dec" translate="yes" xml:space="preserve">
          <source>When saving a form in</source>
          <target state="translated">でフォームを保存する場合</target>
        </trans-unit>
        <trans-unit id="1e9c03991883db6f31187fbe5c35791a719629dc" translate="yes" xml:space="preserve">
          <source>When saving places between managers, there are a few things to be aware of. Some fields of a place such as the id, categories and icons are manager specific entities for example the categories in one manager may not be recognized in another. Therefore trying to save a place directly from one manager to another is not possible.</source>
          <target state="translated">マネージャ間で場所を保存する際には、いくつか注意すべき点があります。例えば、あるマネージャーのカテゴリは別のマネージャーでは認識されないかもしれません。そのため、あるマネージャーから別のマネージャーへ直接場所を保存しようとすることは不可能です。</target>
        </trans-unit>
        <trans-unit id="65dee2f6abcd14dfb6ffc451b8eef9d4e59664a3" translate="yes" xml:space="preserve">
          <source>When saving places between plugins, there are a few things to be aware of. Some fields of a place such as the id, categories and icons are plugin specific entities. For example the categories in one manager may not be recognised in another. Therefore trying to save a place directly from one plugin to another is not possible.</source>
          <target state="translated">プラグイン間で場所を保存する際には、いくつか注意すべき点があります。id、カテゴリ、アイコンのような場所のいくつかのフィールドは、プラグイン固有のエンティティです。例えば、あるマネージャーのカテゴリは別のマネージャーでは認識されないかもしれません。そのため、あるプラグインから別のプラグインに直接保存することはできません。</target>
        </trans-unit>
        <trans-unit id="16335d2940c0a9a4d44f0bf7877e3be7c7a4c25b" translate="yes" xml:space="preserve">
          <source>When scheduling cleanup of graphics resources using &lt;a href=&quot;qquickwindow#scheduleRenderJob&quot;&gt;QQuickWindow::scheduleRenderJob&lt;/a&gt;(), one should use either &lt;a href=&quot;qquickwindow#RenderStage-enum&quot;&gt;QQuickWindow::BeforeSynchronizingStage&lt;/a&gt; or &lt;a href=&quot;qquickwindow#RenderStage-enum&quot;&gt;QQuickWindow::AfterSynchronizingStage&lt;/a&gt;. The &lt;a href=&quot;qtquick-visualcanvas-scenegraph#scene-graph-and-rendering&quot;&gt;synchronization stage&lt;/a&gt; is where the scene graph is changed as a result of changes to the QML tree. If cleanup is scheduled at any other time, it may result in other parts of the scene graph referencing the newly deleted objects as these parts have not been updated.</source>
          <target state="translated">&lt;a href=&quot;qquickwindow#scheduleRenderJob&quot;&gt;QQuickWindow :: scheduleRenderJob&lt;/a&gt;（）を使用してグラフィックリソースのクリーンアップをスケジュールする場合、&lt;a href=&quot;qquickwindow#RenderStage-enum&quot;&gt;QQuickWindow :: BeforeSynchronizingStage&lt;/a&gt;または&lt;a href=&quot;qquickwindow#RenderStage-enum&quot;&gt;QQuickWindow :: AfterSynchronizingStageの&lt;/a&gt;いずれかを使用する必要があります。&lt;a href=&quot;qtquick-visualcanvas-scenegraph#scene-graph-and-rendering&quot;&gt;同期段階は、&lt;/a&gt;シーングラフがQMLツリーへの変更の結果として変更される場合です。他の時間にクリーンアップがスケジュールされている場合、シーングラフの他の部分が更新されていないため、新しく削除されたオブジェクトを参照する可能性があります。</target>
        </trans-unit>
        <trans-unit id="0470cdb483508ebc7b70959dbd94540db4bc9c18" translate="yes" xml:space="preserve">
          <source>When sections are used, the first section command should be &lt;code&gt;section1&lt;/code&gt;.</source>
          <target state="translated">セクションを使用する場合、最初のセクションコマンドは &lt;code&gt;section1&lt;/code&gt; にする必要があります。</target>
        </trans-unit>
        <trans-unit id="f5eedde8058556feb6cb3beeca59e7888ae6ece9" translate="yes" xml:space="preserve">
          <source>When selection is changed by clicking on the graph</source>
          <target state="translated">グラフをクリックして選択範囲を変更した場合</target>
        </trans-unit>
        <trans-unit id="00867511fe8868752b9e077a7707775ae9c1971d" translate="yes" xml:space="preserve">
          <source>When selection is changed explicitly via series API to a visible item</source>
          <target state="translated">系列APIで明示的に選択範囲を可視項目に変更した場合</target>
        </trans-unit>
        <trans-unit id="2e1af7d1ebff8ce0a52ad99867add45c86a6ae89" translate="yes" xml:space="preserve">
          <source>When sending CAN FD frames, this flag is automatically set by the CAN FD hardware. &lt;code&gt;QCanBusFrame::setErrorStateIndicator()&lt;/code&gt; should only be used for application testing, e.g. on virtual CAN FD busses.</source>
          <target state="translated">CAN FDフレームを送信すると、このフラグはCAN FDハードウェアによって自動的に設定されます。 &lt;code&gt;QCanBusFrame::setErrorStateIndicator()&lt;/code&gt; は、仮想CAN FDバスなどのアプリケーションテストにのみ使用してください。</target>
        </trans-unit>
        <trans-unit id="357729db045ad04ca40ebade91b854125d77106d" translate="yes" xml:space="preserve">
          <source>When sending CAN bus frames with &lt;a href=&quot;qcanbusdevice#ConfigurationKey-enum&quot;&gt;QCanBusDevice::ReceiveOwnKey&lt;/a&gt; enabled, all successfully sent frames are echoed to the receive queue and marked as local echo frames. &lt;code&gt;QCanBusFrame::setLocalEcho&lt;/code&gt; should therefore only be used for application testing, e.g. on virtual CAN busses.</source>
          <target state="translated">&lt;a href=&quot;qcanbusdevice#ConfigurationKey-enum&quot;&gt;QCanBusDevice :: ReceiveOwnKeyを&lt;/a&gt;有効にしてCANバスフレームを送信すると、正常に送信されたすべてのフレームが受信キューにエコーされ、ローカルエコーフレームとしてマークされます。したがって、 &lt;code&gt;QCanBusFrame::setLocalEcho&lt;/code&gt; は、仮想CANバスなどのアプリケーションテストにのみ使用してください。</target>
        </trans-unit>
        <trans-unit id="8bae5e50b5bdda4bb33ef7b2b1936a5c7112c234" translate="yes" xml:space="preserve">
          <source>When sending requests, to control the preference of when to use the cache and when to use the network, consider the following:</source>
          <target state="translated">リクエストを送信する際に、キャッシュを使用するタイミングとネットワークを使用するタイミングの優先順位を制御するために、以下のようなことを考えてください。</target>
        </trans-unit>
        <trans-unit id="73e7c0c4bd2ed4ad850a956107fc733151db2cb3" translate="yes" xml:space="preserve">
          <source>When sending, the &lt;a href=&quot;qnetworkdatagram#senderAddress&quot;&gt;senderAddress&lt;/a&gt;() and &lt;a href=&quot;qnetworkdatagram#senderPort&quot;&gt;senderPort&lt;/a&gt;() should contain the local address to be used when sending. The sender address must be an address that is assigned to this machine, which can be obtained using &lt;a href=&quot;qnetworkinterface&quot;&gt;QNetworkInterface&lt;/a&gt;, and the port number must be the port number that the socket is bound to. Either field can be left unset and will be filled in by the operating system with default values. The &lt;a href=&quot;qnetworkdatagram#destinationAddress&quot;&gt;destinationAddress&lt;/a&gt;() and &lt;a href=&quot;qnetworkdatagram#destinationPort&quot;&gt;destinationPort&lt;/a&gt;() fields may be set to a target address different from the one the UDP socket is currently associated with.</source>
          <target state="translated">送信時には、&lt;a href=&quot;qnetworkdatagram#senderAddress&quot;&gt;senderAddress&lt;/a&gt;（）および&lt;a href=&quot;qnetworkdatagram#senderPort&quot;&gt;senderPort&lt;/a&gt;（）に、送信時に使用するローカルアドレスを含める必要があります。送信者アドレスは、このマシンに割り当てられているアドレスである必要があり、&lt;a href=&quot;qnetworkinterface&quot;&gt;QNetworkInterface&lt;/a&gt;を使用して取得できます。ポート番号は、ソケットがバインドされているポート番号でなければなりません。どちらのフィールドも設定しないでおくことができ、オペレーティングシステムによってデフォルト値が入力されます。&lt;a href=&quot;qnetworkdatagram#destinationAddress&quot;&gt;宛先アドレス&lt;/a&gt;（）と&lt;a href=&quot;qnetworkdatagram#destinationPort&quot;&gt;destinationPort&lt;/a&gt;（）フィールドはUDPソケットが現在関連付けられているものからターゲットアドレス別に設定されてもよいです。</target>
        </trans-unit>
        <trans-unit id="bbc34b6972fd5a95f0e17a1bedd0814ddeba5170" translate="yes" xml:space="preserve">
          <source>When serialized item data is dropped onto a view, the data is inserted into the current model using its implementation of &lt;a href=&quot;qabstractitemmodel#dropMimeData&quot;&gt;QAbstractItemModel::dropMimeData&lt;/a&gt;(). The default implementation of this function will never overwrite any data in the model; instead, it tries to insert the items of data either as siblings of an item, or as children of that item.</source>
          <target state="translated">シリアル化されたアイテムデータがビューにドロップされると、&lt;a href=&quot;qabstractitemmodel#dropMimeData&quot;&gt;QAbstractItemModel :: dropMimeData&lt;/a&gt;（）の実装を使用して、データが現在のモデルに挿入されます。この関数のデフォルトの実装は、モデル内のデータを上書きすることはありません。代わりに、データのアイテムを、アイテムの兄弟またはそのアイテムの子として挿入しようとします。</target>
        </trans-unit>
        <trans-unit id="beb64bc37ef9e620c83f8575bbe6997166c3df77" translate="yes" xml:space="preserve">
          <source>When set on the characterFormat of a selection, the whole width of the text will be shown selected.</source>
          <target state="translated">選択範囲の文字書式に設定すると、選択範囲のテキストの全幅が選択された状態で表示されます。</target>
        </trans-unit>
        <trans-unit id="270afeac1ae23334323cbd52bdb23f45e70ed478" translate="yes" xml:space="preserve">
          <source>When set to &lt;a href=&quot;qsensor#AxesOrientationMode-enum&quot;&gt;AutomaticOrientation&lt;/a&gt;, the reading values are automatically rotated when the screen orientation changes. In effect, the screen orientation is canceled out.</source>
          <target state="translated">&lt;a href=&quot;qsensor#AxesOrientationMode-enum&quot;&gt;AutomaticOrientation&lt;/a&gt;に設定すると、画面の向きが変わると、読み取り値が自動的に回転します。実際には、画面の向きはキャンセルされます。</target>
        </trans-unit>
        <trans-unit id="e194e2df3cef00cb337af8c19d0b1fb4566ff905" translate="yes" xml:space="preserve">
          <source>When set to &lt;a href=&quot;qsensor#AxesOrientationMode-enum&quot;&gt;FixedOrientation&lt;/a&gt;, which is the default mode, no automatic rotation is applied to the reading. This is the only mode available for backends that do not support the &lt;a href=&quot;qsensor#Feature-enum&quot;&gt;QSensor::AxesOrientation&lt;/a&gt; feature.</source>
          <target state="translated">デフォルトモードである&lt;a href=&quot;qsensor#AxesOrientationMode-enum&quot;&gt;FixedOrientation&lt;/a&gt;に設定すると、読み取り値に自動回転は適用されません。これは、&lt;a href=&quot;qsensor#Feature-enum&quot;&gt;QSensor :: AxesOrientation&lt;/a&gt;機能をサポートしないバックエンドで使用できる唯一のモードです。</target>
        </trans-unit>
        <trans-unit id="f8c2be01f19679d844258975f1b00add910e8c48" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;1&lt;/code&gt;, Qt grabs the device for exclusive use.</source>
          <target state="translated">&lt;code&gt;1&lt;/code&gt; に設定すると、Qtは専用のデバイスを取得します。</target>
        </trans-unit>
        <trans-unit id="35fbd74909144bf9e11c35c0ff6fab64956af13b" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;false&lt;/code&gt;, rendering is done in single pass. In this mode the depth buffer is not used at all, and all objects are rendered in a single back to front pass.</source>
          <target state="translated">&lt;code&gt;false&lt;/code&gt; に設定すると、レンダリングはシングルパスで実行されます。このモードでは、深度バッファはまったく使用されず、すべてのオブジェクトが1回のバックツーフロントパスでレンダリングされます。</target>
        </trans-unit>
        <trans-unit id="f1c4e86e296a0003f811fe8398c8194c0172e276" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;transparent&lt;/code&gt;, no filling occurs.</source>
          <target state="translated">&lt;code&gt;transparent&lt;/code&gt; に設定すると、塗りつぶしは行われません。</target>
        </trans-unit>
        <trans-unit id="a494091a2d78c1c83239a6f4b1f78cd17e064c58" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;transparent&lt;/code&gt;, no stroking occurs.</source>
          <target state="translated">&lt;code&gt;transparent&lt;/code&gt; に設定すると、ストロークは発生しません。</target>
        </trans-unit>
        <trans-unit id="d01263f2091d195480c96c2d03450e33391dffb1" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;true&lt;/code&gt;, the exterior of the item is padded with a 1 pixel wide transparent edge, making sampling outside the source texture use transparency instead of the edge pixels. Without this property, an image which has opaque edges will not get a blurred shadow.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; に設定すると、アイテムの外側に1ピクセル幅の透明なエッジが埋め込まれ、ソーステクスチャの外側のサンプリングではエッジピクセルの代わりに透明度が使用されます。このプロパティがないと、エッジが不透明な画像にぼやけた影が付きません。</target>
        </trans-unit>
        <trans-unit id="b450467a36089b6e8cc7c9384688033053a7e1e0" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;true&lt;/code&gt;, the exterior of the item is padded with a transparent edge, making sampling outside the source texture use transparency instead of the edge pixels. Without this property, an image which has opaque edges will not get a blurred edge.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; に設定すると、アイテムの外側が透明なエッジで埋め込まれ、ソーステクスチャの外側のサンプリングでエッジピクセルの代わりに透明度が使用されます。このプロパティがないと、不透明なエッジを持つ画像はぼやけたエッジになりません。</target>
        </trans-unit>
        <trans-unit id="e4147d132167beace31a7c2f2898d532610dfada" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;true&lt;/code&gt;, the mapping ignores any explicitly set column categories and overwrites them with automatically generated ones whenever the data from model is resolved. Defaults to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; に設定すると、マッピングは明示的に設定された列カテゴリを無視し、モデルからのデータが解決されるたびに自動的に生成されたものでそれらを上書きします。デフォルトは &lt;code&gt;true&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="36e27ee6dcb20f63a267c063b5f0dd2344ea8112" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;true&lt;/code&gt;, the mapping ignores any explicitly set column categories and overwrites them with automatically generated ones whenever the data from the model is resolved. Defaults to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; に設定すると、マッピングは明示的に設定された列カテゴリを無視し、モデルからのデータが解決されるたびに自動的に生成されたものでそれらを上書きします。デフォルトは &lt;code&gt;true&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="aeaf1add3a3c03b3752ea390e4de636b57ce02e7" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;true&lt;/code&gt;, the mapping ignores any explicitly set column categories and overwrites them with automatically generated ones whenever the data from the model is resolved. Proxy minimum and maximum column values are also autogenerated from the data when this is set to &lt;code&gt;true&lt;/code&gt;. Defaults to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; に設定すると、マッピングは明示的に設定された列カテゴリを無視し、モデルからのデータが解決されるたびに自動的に生成されたものでそれらを上書きします。これが &lt;code&gt;true&lt;/code&gt; に設定されている場合、プロキシの最小列値と最大列値もデータから自動生成されます。デフォルトは &lt;code&gt;true&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="c86619e8213d5bed1738d02c582750355d6522a4" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;true&lt;/code&gt;, the mapping ignores any explicitly set row categories and overwrites them with automatically generated ones whenever the data from model is resolved. Defaults to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; に設定すると、マッピングは明示的に設定された行カテゴリを無視し、モデルからのデータが解決されるたびに、それらを自動的に生成されたもので上書きします。デフォルトは &lt;code&gt;true&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="d11c86fa7ccfd6ba9e683cd50f0c094403577ac1" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;true&lt;/code&gt;, the mapping ignores any explicitly set row categories and overwrites them with automatically generated ones whenever the data from the model is resolved. Defaults to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; に設定すると、マッピングは明示的に設定された行カテゴリを無視し、モデルからのデータが解決されるたびに自動的に生成されたものでそれらを上書きします。デフォルトは &lt;code&gt;true&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="1301757ff1650814b570b349ec4348010d05817d" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;true&lt;/code&gt;, the mapping ignores any explicitly set row categories and overwrites them with automatically generated ones whenever the data from the model is resolved. Proxy minimum and maximum row values are also autogenerated from the data when this is set to &lt;code&gt;true&lt;/code&gt;. Defaults to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; に設定すると、マッピングは明示的に設定された行カテゴリを無視し、モデルからのデータが解決されるたびに自動的に生成されたものでそれらを上書きします。これが &lt;code&gt;true&lt;/code&gt; に設定されている場合、プロキシの最小および最大行値もデータから自動生成されます。デフォルトは &lt;code&gt;true&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="7acc0959296f9d8e8c2e2b6cb1d3a66719167a16" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;true&lt;/code&gt;, the mapping ignores row and column roles and categories, and uses the rows and columns from the model instead. Defaults to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; に設定すると、マッピングは行と列の役割とカテゴリを無視し、代わりにモデルの行と列を使用します。デフォルトは &lt;code&gt;false&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="5f951719e1af643c50c67762d555cf0e850cebdd" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;true&lt;/code&gt;, the mapping ignores row and column roles and categories, and uses the rows and columns from the model instead. Row and column headers are used for row and column labels. Defaults to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; に設定すると、マッピングは行と列の役割とカテゴリを無視し、代わりにモデルの行と列を使用します。行と列のヘッダーは、行と列のラベルに使用されます。デフォルトは &lt;code&gt;false&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="3496a774f53b66ac5b73d84b633a1d9d7d924d85" translate="yes" xml:space="preserve">
          <source>When set to a negative value, no stroking occurs.</source>
          <target state="translated">負の値に設定すると、ストロークは発生しません。</target>
        </trans-unit>
        <trans-unit id="4e4ee14f2ec2d88c31367b1d93f593e8267881e4" translate="yes" xml:space="preserve">
          <source>When set to an empty string, the default label of the underlying platform is used. The default label is typically &lt;b&gt;Cancel&lt;/b&gt;.</source>
          <target state="translated">空の文字列に設定すると、基盤となるプラットフォームのデフォルトのラベルが使用されます。デフォルトのラベルは通常、&lt;b&gt;キャンセル&lt;/b&gt;です。</target>
        </trans-unit>
        <trans-unit id="71b7a30cacf1f3a3ee6a4172e8fb4bd21a402ed0" translate="yes" xml:space="preserve">
          <source>When set to an empty string, the default label of the underlying platform is used. The default label is typically &lt;b&gt;Open&lt;/b&gt; or &lt;b&gt;Save&lt;/b&gt; depending on which &lt;a href=&quot;qml-qt-labs-platform-filedialog#fileMode-prop&quot;&gt;fileMode&lt;/a&gt; the dialog is used in.</source>
          <target state="translated">空の文字列に設定すると、基盤となるプラットフォームのデフォルトのラベルが使用されます。デフォルトのラベルは通常、ダイアログが使用されている&lt;a href=&quot;qml-qt-labs-platform-filedialog#fileMode-prop&quot;&gt;fileModeに&lt;/a&gt;応じて、&lt;b&gt;Open&lt;/b&gt;または&lt;b&gt;Save&lt;/b&gt;です。</target>
        </trans-unit>
        <trans-unit id="fa9215824a888cc448b2b5104b3e0edb6ca3f827" translate="yes" xml:space="preserve">
          <source>When set to an empty string, the default label of the underlying platform is used. The default label is typically &lt;b&gt;Open&lt;/b&gt;.</source>
          <target state="translated">空の文字列に設定すると、基盤となるプラットフォームのデフォルトのラベルが使用されます。デフォルトのラベルは通常&lt;b&gt;Open&lt;/b&gt;です。</target>
        </trans-unit>
        <trans-unit id="da31d475a6141d1527e3930e3b780117133be781" translate="yes" xml:space="preserve">
          <source>When set to true, a connection is made to the server with the given url. When set to false, the connection is closed. The default value is false.</source>
          <target state="translated">true に設定すると、指定された URL でサーバへの接続が行われます。falseに設定すると、接続は閉じられます。デフォルト値は false です。</target>
        </trans-unit>
        <trans-unit id="d356d95380e0a7be709c939454d729283fff95fe" translate="yes" xml:space="preserve">
          <source>When set to true, updates are blocked and remote clients will not be notified about property changes.</source>
          <target state="translated">trueに設定すると、更新はブロックされ、リモートクライアントはプロパティの変更について通知されません。</target>
        </trans-unit>
        <trans-unit id="9070c24af14ff16b55ce450d03070776a1d63544" translate="yes" xml:space="preserve">
          <source>When set, &lt;a href=&quot;qml-qtquick-shapes-shapepath&quot;&gt;ShapePath&lt;/a&gt;.&lt;a href=&quot;qml-qtquick-shapes-shapepath#fillColor-prop&quot;&gt;fillColor&lt;/a&gt; is ignored and filling is done using one of the &lt;a href=&quot;qml-qtquick-shapes-shapegradient&quot;&gt;ShapeGradient&lt;/a&gt; subtypes.</source>
          <target state="translated">設定されている場合、&lt;a href=&quot;qml-qtquick-shapes-shapepath&quot;&gt;ShapePath&lt;/a&gt;。&lt;a href=&quot;qml-qtquick-shapes-shapepath#fillColor-prop&quot;&gt;fillColor&lt;/a&gt;は無視され、&lt;a href=&quot;qml-qtquick-shapes-shapegradient&quot;&gt;ShapeGradient&lt;/a&gt;サブタイプの1つを使用して塗りつぶしが行われます。</target>
        </trans-unit>
        <trans-unit id="1d5a93253ef1915d6faa59a1fad7ff2aba883814" translate="yes" xml:space="preserve">
          <source>When set, &lt;code&gt;eglfs&lt;/code&gt; requests &lt;code&gt;FBIO_WAITFORVSYNC&lt;/code&gt; on the framebuffer device after each call to eglSwapBuffers(). This variable is only relevant for backends relying on the legacy Linux &lt;code&gt;fbdev&lt;/code&gt; subsystem. Normally, with a default swap interval of 1, Qt assumes that calling eglSwapBuffers() takes care of vsync; if it doesn't (for example, due to driver bugs), try setting &lt;code&gt;QT_QPA_EGLFS_FORCEVSYNC&lt;/code&gt; to a non-zero value.</source>
          <target state="translated">設定すると、 &lt;code&gt;eglfs&lt;/code&gt; は、eglSwapBuffers（）を呼び出す &lt;code&gt;FBIO_WAITFORVSYNC&lt;/code&gt; に、フレームバッファーデバイスでFBIO_WAITFORVSYNCを要求します。この変数は、レガシーLinux &lt;code&gt;fbdev&lt;/code&gt; サブシステムに依存するバックエンドにのみ関連します。通常、デフォルトのスワップ間隔が1の場合、QtはeglSwapBuffers（）の呼び出しがvsyncを処理すると想定します。そうでない場合（ドライバーのバグなどが原因）、 &lt;code&gt;QT_QPA_EGLFS_FORCEVSYNC&lt;/code&gt; をゼロ以外の値に設定してみてください。</target>
        </trans-unit>
        <trans-unit id="9744299b5e8df688636dffff69d9ac6cfe828468" translate="yes" xml:space="preserve">
          <source>When set, a search and replace is done on the value mapped by column role before it is used as a column category. This property specifies the regular expression to find the portion of the mapped value to replace and &lt;a href=&quot;qml-qtdatavisualization-itemmodelbardataproxy#columnRoleReplace-prop&quot;&gt;columnRoleReplace&lt;/a&gt; property contains the replacement string. This is useful for example in parsing row and column categories from a single timestamp field in the item model.</source>
          <target state="translated">設定すると、列の役割としてマップされた値が列カテゴリとして使用される前に、検索と置換が行われます。このプロパティは、置換するマップされた値の部分を見つけるための正規表現を指定し、&lt;a href=&quot;qml-qtdatavisualization-itemmodelbardataproxy#columnRoleReplace-prop&quot;&gt;columnRoleReplace&lt;/a&gt;プロパティは置換文字列を含みます。これは、たとえば、アイテムモデルの単一のタイムスタンプフィールドから行と列のカテゴリを解析する場合に役立ちます。</target>
        </trans-unit>
        <trans-unit id="8a131bdf52627ee3b863efe9743b906a421ee8f9" translate="yes" xml:space="preserve">
          <source>When set, a search and replace is done on the value mapped by rotation role before it is used as a bar rotation angle. This property specifies the regular expression to find the portion of the mapped value to replace and &lt;a href=&quot;qml-qtdatavisualization-itemmodelbardataproxy#rotationRoleReplace-prop&quot;&gt;rotationRoleReplace&lt;/a&gt; property contains the replacement string.</source>
          <target state="translated">設定すると、棒の回転​​角度として使用される前に、回転の役割によってマップされた値に対して検索と置換が行われます。このプロパティは、置換するマップされた値の部分を見つけるための正規表現を指定し、&lt;a href=&quot;qml-qtdatavisualization-itemmodelbardataproxy#rotationRoleReplace-prop&quot;&gt;rotationRoleReplace&lt;/a&gt;プロパティには置換文字列が含まれます。</target>
        </trans-unit>
        <trans-unit id="9108433232a1c54c0f0add6d2c59552f382b7483" translate="yes" xml:space="preserve">
          <source>When set, a search and replace is done on the value mapped by row role before it is used as a row category. This property specifies the regular expression to find the portion of the mapped value to replace and &lt;a href=&quot;qml-qtdatavisualization-itemmodelbardataproxy#rowRoleReplace-prop&quot;&gt;rowRoleReplace&lt;/a&gt; property contains the replacement string. This is useful for example in parsing row and column categories from a single timestamp field in the item model.</source>
          <target state="translated">設定されている場合、行のカテゴリーとして使用される前に、行ロールによってマップされた値に対して検索と置換が行われます。このプロパティは、置換するマップされた値の部分を見つけるための正規表現を指定し、&lt;a href=&quot;qml-qtdatavisualization-itemmodelbardataproxy#rowRoleReplace-prop&quot;&gt;rowRoleReplace&lt;/a&gt;プロパティは置換文字列を含みます。これは、たとえば、アイテムモデルの単一のタイムスタンプフィールドから行と列のカテゴリを解析する場合に役立ちます。</target>
        </trans-unit>
        <trans-unit id="bc9c1cbcb787214aaefb29b1ef7ac7fde2064a50" translate="yes" xml:space="preserve">
          <source>When set, a search and replace is done on the value mapped by the column role before it is used as a column category. This property specifies the regular expression to find the portion of the mapped value to replace and the &lt;a href=&quot;qml-qtdatavisualization-itemmodelsurfacedataproxy#columnRoleReplace-prop&quot;&gt;columnRoleReplace&lt;/a&gt; property contains the replacement string.</source>
          <target state="translated">設定すると、列ロールとしてマップされた値が列カテゴリとして使用される前に、検索と置換が行われます。このプロパティは、マップされた値の置換する部分を見つけるための正規表現を指定し、&lt;a href=&quot;qml-qtdatavisualization-itemmodelsurfacedataproxy#columnRoleReplace-prop&quot;&gt;columnRoleReplace&lt;/a&gt;プロパティには置換文字列が含まれています。</target>
        </trans-unit>
        <trans-unit id="6c6f75996ea55b81eb144da97f4ddbf1f7b8d2df" translate="yes" xml:space="preserve">
          <source>When set, a search and replace is done on the value mapped by the rotation role before it is used as item rotation. This property specifies the regular expression to find the portion of the mapped value to replace and &lt;a href=&quot;qml-qtdatavisualization-itemmodelscatterdataproxy#rotationRoleReplace-prop&quot;&gt;rotationRoleReplace&lt;/a&gt; property contains the replacement string.</source>
          <target state="translated">設定すると、ローテーションロールによってマップされた値に対して検索と置換が行われてから、アイテムのローテーションとして使用されます。このプロパティは、置換するマップされた値の部分を見つけるための正規表現を指定し、&lt;a href=&quot;qml-qtdatavisualization-itemmodelscatterdataproxy#rotationRoleReplace-prop&quot;&gt;rotationRoleReplace&lt;/a&gt;プロパティには置換文字列が含まれます。</target>
        </trans-unit>
        <trans-unit id="4d7bce4ff7100e6fa830173aafe199aab62b818f" translate="yes" xml:space="preserve">
          <source>When set, a search and replace is done on the value mapped by the row role before it is used as a row category. This property specifies the regular expression to find the portion of the mapped value to replace and the &lt;a href=&quot;qml-qtdatavisualization-itemmodelsurfacedataproxy#rowRoleReplace-prop&quot;&gt;rowRoleReplace&lt;/a&gt; property contains the replacement string.</source>
          <target state="translated">設定すると、行カテゴリとして使用される前に、行ロールによってマップされた値に対して検索と置換が行われます。このプロパティは、マッピングする値の置換する部分を見つけるための正規表現を指定し、&lt;a href=&quot;qml-qtdatavisualization-itemmodelsurfacedataproxy#rowRoleReplace-prop&quot;&gt;rowRoleReplace&lt;/a&gt;プロパティには置換文字列が含まれます。</target>
        </trans-unit>
        <trans-unit id="885cf3aa8085356e119ac0af240743c4239afe83" translate="yes" xml:space="preserve">
          <source>When set, a search and replace is done on the value mapped by the x position role before it is used as an item position value. This property specifies the regular expression to find the portion of the mapped value to replace and &lt;a href=&quot;qml-qtdatavisualization-itemmodelscatterdataproxy#xPosRoleReplace-prop&quot;&gt;xPosRoleReplace&lt;/a&gt; property contains the replacement string.</source>
          <target state="translated">設定すると、x位置ロールによってマップされた値に対して検索と置換が実行されてから、アイテムの位置値として使用されます。このプロパティは、置換するマップされた値の部分を見つけるための正規表現を指定し、&lt;a href=&quot;qml-qtdatavisualization-itemmodelscatterdataproxy#xPosRoleReplace-prop&quot;&gt;xPosRoleReplace&lt;/a&gt;プロパティは置換文字列を含みます。</target>
        </trans-unit>
        <trans-unit id="66303afda7fe28b42306b119120f8c9d8ffe13b2" translate="yes" xml:space="preserve">
          <source>When set, a search and replace is done on the value mapped by the x position role before it is used as an item position value. This property specifies the regular expression to find the portion of the mapped value to replace and the &lt;a href=&quot;qml-qtdatavisualization-itemmodelsurfacedataproxy#xPosRoleReplace-prop&quot;&gt;xPosRoleReplace&lt;/a&gt; property contains the replacement string.</source>
          <target state="translated">設定すると、x位置ロールによってマップされた値に対して検索と置換が実行されてから、アイテムの位置値として使用されます。このプロパティは、マップされた値の置換する部分を見つけるための正規表現を指定し、&lt;a href=&quot;qml-qtdatavisualization-itemmodelsurfacedataproxy#xPosRoleReplace-prop&quot;&gt;xPosRoleReplace&lt;/a&gt;プロパティには置換文字列が含まれています。</target>
        </trans-unit>
        <trans-unit id="177b7625ed57441e9caab15b1ba52de1056c1697" translate="yes" xml:space="preserve">
          <source>When set, a search and replace is done on the value mapped by the y position role before it is used as an item position value. This property specifies the regular expression to find the portion of the mapped value to replace and &lt;a href=&quot;qml-qtdatavisualization-itemmodelscatterdataproxy#yPosRoleReplace-prop&quot;&gt;yPosRoleReplace&lt;/a&gt; property contains the replacement string.</source>
          <target state="translated">設定されている場合、検索と置換は、y位置ロールによってマップされた値に対して実行されてから、アイテムの位置値として使用されます。このプロパティは、置換するマップされた値の部分を見つけるための正規表現を指定し、&lt;a href=&quot;qml-qtdatavisualization-itemmodelscatterdataproxy#yPosRoleReplace-prop&quot;&gt;yPosRoleReplace&lt;/a&gt;プロパティは置換文字列を含みます。</target>
        </trans-unit>
        <trans-unit id="4cd4628ea893e9ef8db7b0e103b8b8eb84582ee7" translate="yes" xml:space="preserve">
          <source>When set, a search and replace is done on the value mapped by the y position role before it is used as an item position value. This property specifies the regular expression to find the portion of the mapped value to replace and the &lt;a href=&quot;qml-qtdatavisualization-itemmodelsurfacedataproxy#yPosRoleReplace-prop&quot;&gt;yPosRoleReplace&lt;/a&gt; property contains the replacement string.</source>
          <target state="translated">設定されている場合、検索と置換は、y位置ロールによってマップされた値に対して実行されてから、アイテムの位置値として使用されます。このプロパティは、置換するマップされた値の部分を見つけるための正規表現を指定し、&lt;a href=&quot;qml-qtdatavisualization-itemmodelsurfacedataproxy#yPosRoleReplace-prop&quot;&gt;yPosRoleReplace&lt;/a&gt;プロパティは置換文字列を含みます。</target>
        </trans-unit>
        <trans-unit id="e690058b1d8c0f0ea729f77975b58803689a29ce" translate="yes" xml:space="preserve">
          <source>When set, a search and replace is done on the value mapped by the z position role before it is used as an item position value. This property specifies the regular expression to find the portion of the mapped value to replace and &lt;a href=&quot;qml-qtdatavisualization-itemmodelscatterdataproxy#zPosRoleReplace-prop&quot;&gt;zPosRoleReplace&lt;/a&gt; property contains the replacement string.</source>
          <target state="translated">設定すると、z位置ロールによってマップされた値に対して検索と置換が行われてから、アイテムの位置値として使用されます。このプロパティは、置換するマップされた値の部分を見つけるための正規表現を指定し、&lt;a href=&quot;qml-qtdatavisualization-itemmodelscatterdataproxy#zPosRoleReplace-prop&quot;&gt;zPosRoleReplace&lt;/a&gt;プロパティは置換文字列を含みます。</target>
        </trans-unit>
        <trans-unit id="8a50a48a136eb418621caa5d9975fa8698821525" translate="yes" xml:space="preserve">
          <source>When set, a search and replace is done on the value mapped by the z position role before it is used as an item position value. This property specifies the regular expression to find the portion of the mapped value to replace and the &lt;a href=&quot;qml-qtdatavisualization-itemmodelsurfacedataproxy#zPosRoleReplace-prop&quot;&gt;zPosRoleReplace&lt;/a&gt; property contains the replacement string.</source>
          <target state="translated">設定すると、z位置ロールによってマップされた値に対して検索と置換が行われてから、アイテムの位置値として使用されます。このプロパティは、マップされた値の置換する部分を見つけるための正規表現を指定し、&lt;a href=&quot;qml-qtdatavisualization-itemmodelsurfacedataproxy#zPosRoleReplace-prop&quot;&gt;zPosRoleReplace&lt;/a&gt;プロパティには置換文字列が含まれています。</target>
        </trans-unit>
        <trans-unit id="9e6e26fa69d41d9769f5fde960eb52cd2c8473db" translate="yes" xml:space="preserve">
          <source>When set, a search and replace is done on the value mapped by value role before it is used as a bar value. This property specifies the regular expression to find the portion of the mapped value to replace and &lt;a href=&quot;qml-qtdatavisualization-itemmodelbardataproxy#valueRoleReplace-prop&quot;&gt;valueRoleReplace&lt;/a&gt; property contains the replacement string.</source>
          <target state="translated">設定すると、値の役割によってマップされた値が検索され、それがバーの値として使用される前に置換されます。このプロパティは、置換するマップされた値の部分を見つけるための正規表現を指定し、&lt;a href=&quot;qml-qtdatavisualization-itemmodelbardataproxy#valueRoleReplace-prop&quot;&gt;valueRoleReplace&lt;/a&gt;プロパティは置換文字列を含みます。</target>
        </trans-unit>
        <trans-unit id="57e671691d58c18370650113c81b9894428ab1c0" translate="yes" xml:space="preserve">
          <source>When set, some debugging information is printed on the debug output. For example, the input &lt;a href=&quot;qsurfaceformat&quot;&gt;QSurfaceFormat&lt;/a&gt; and the properties of the chosen EGL configuration are printed while creating a new context. When used together with Qt Quick's &lt;code&gt;QSG_INFO&lt;/code&gt; variable, you can get useful information for troubleshooting issues related to the EGL configuration.</source>
          <target state="translated">設定すると、一部のデバッグ情報がデバッグ出力に出力されます。例えば、新しいコンテキストの作成中に、入力された&lt;a href=&quot;qsurfaceformat&quot;&gt;QSurfaceFormat&lt;/a&gt;および選択されたEGL構成のプロパティーが出力されます。Qt Quickの &lt;code&gt;QSG_INFO&lt;/code&gt; 変数と一緒に使用すると、EGL構成に関連する問題のトラブルシューティングに役立つ情報を取得できます。</target>
        </trans-unit>
        <trans-unit id="c63ec68c079a9bce145854c06f681928a4a99fb9" translate="yes" xml:space="preserve">
          <source>When set, the red, green, and blue color channel sizes are ignored when &lt;code&gt;eglfs&lt;/code&gt; creates a new context, window or offscreen surface. Instead, the plugin requests a configuration with 8 bits per channel. This can be helpful on devices where configurations with less than 32 or 24 bits per pixel (for example, 5-6-5 or 4-4-4) are chosen by default despite knowing they are not ideal, for example, due to banding effects. Instead of changing application code, this variable provides a shortcut to force 24 or 32 bpp configurations.</source>
          <target state="translated">設定すると、 &lt;code&gt;eglfs&lt;/code&gt; が新しいコンテキスト、ウィンドウ、またはオフスクリーンサーフェスを作成するときに、赤、緑、青のカラーチャネルサイズが無視されます。代わりに、プラグインはチャネルごとに8ビットの構成を要求します。これは、たとえばバンディングが原因で理想的ではないことを知っていても、ピクセルあたり32または24ビット未満の構成（たとえば、5-6-5または4-4-4）がデフォルトで選択されているデバイスで役立ちます。効果。アプリケーション変数を変更する代わりに、この変数は24または32 bpp構成を強制するショートカットを提供します。</target>
        </trans-unit>
        <trans-unit id="33b3bd9431a5daf3aec6eea2743d997f576dc8d8" translate="yes" xml:space="preserve">
          <source>When setting &lt;a href=&quot;qml-qtquick-item#clip-prop&quot;&gt;Item::clip&lt;/a&gt; to true, it will create a &lt;a href=&quot;qsgclipnode&quot;&gt;QSGClipNode&lt;/a&gt; with a rectangle in its geometry. The default renderer will apply this clip by using scissoring in OpenGL. If the item is rotated by a non-90-degree angle, the OpenGL's stencil buffer is used. Qt Quick Item only supports setting a rectangle as clip through QML, but the scene graph API and the default renderer can use any shape for clipping.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-item#clip-prop&quot;&gt;Item :: clip&lt;/a&gt;をtrueに設定すると、ジオメトリに長方形の&lt;a href=&quot;qsgclipnode&quot;&gt;QSGClipNode&lt;/a&gt;が作成されます。デフォルトのレンダラーは、OpenGLでシザリングを使用してこのクリップを適用します。アイテムが90度以外の角度で回転した場合、OpenGLのステンシルバッファーが使用されます。Qtクイックアイテムは、QMLを介して四角形をクリップとして設定することのみをサポートしますが、シーングラフAPIおよびデフォルトレンダラーは、任意の形状をクリッピングに使用できます。</target>
        </trans-unit>
        <trans-unit id="a5ed62e892daca59bcdf47a39598aaed448ddccb" translate="yes" xml:space="preserve">
          <source>When setting a maximum date, the &lt;a href=&quot;qcalendarwidget#minimumDate-prop&quot;&gt;minimumDate&lt;/a&gt; and &lt;a href=&quot;qcalendarwidget#selectedDate-prop&quot;&gt;selectedDate&lt;/a&gt; properties are adjusted if the selection range becomes invalid. If the provided date is not a valid &lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt; object, the setMaximumDate() function does nothing.</source>
          <target state="translated">最大日付を設定する場合、選択範囲が無効になると、&lt;a href=&quot;qcalendarwidget#minimumDate-prop&quot;&gt;minimumDate&lt;/a&gt;プロパティと&lt;a href=&quot;qcalendarwidget#selectedDate-prop&quot;&gt;selectedDate&lt;/a&gt;プロパティが調整されます。指定された日付が有効な&lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt;オブジェクトでない場合、setMaximumDate（）関数は何もしません。</target>
        </trans-unit>
        <trans-unit id="c4ae2d023320be5119694dfde25d7c2125941c8d" translate="yes" xml:space="preserve">
          <source>When setting a minimum date, the &lt;a href=&quot;qcalendarwidget#maximumDate-prop&quot;&gt;maximumDate&lt;/a&gt; and &lt;a href=&quot;qcalendarwidget#selectedDate-prop&quot;&gt;selectedDate&lt;/a&gt; properties are adjusted if the selection range becomes invalid. If the provided date is not a valid &lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt; object, the setMinimumDate() function does nothing.</source>
          <target state="translated">最小日付を設定する場合、選択範囲が無効になると&lt;a href=&quot;qcalendarwidget#maximumDate-prop&quot;&gt;maximumDate&lt;/a&gt;プロパティと&lt;a href=&quot;qcalendarwidget#selectedDate-prop&quot;&gt;selectedDate&lt;/a&gt;プロパティが調整されます。指定された日付が有効な&lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt;オブジェクトではない場合、setMinimumDate（）関数は何もしません。</target>
        </trans-unit>
        <trans-unit id="6eeb8a01ae2a0c99098eee6b5e541fd874b03835" translate="yes" xml:space="preserve">
          <source>When setting the fragment or vertex shader source code, the status will become Uncompiled. The first time the &lt;a href=&quot;qml-qtquick-shadereffect&quot;&gt;ShaderEffect&lt;/a&gt; is rendered with new shader source code, the shaders are compiled and linked, and the status is updated to Compiled or Error.</source>
          <target state="translated">フラグメントまたは頂点シェーダーのソースコードを設定すると、ステータスが[未コンパイル]になります。&lt;a href=&quot;qml-qtquick-shadereffect&quot;&gt;ShaderEffect&lt;/a&gt;が新しいシェーダーソースコードで初めてレンダリングされるときに、シェーダーがコンパイルおよびリンクされ、ステータスがCompiledまたはErrorに更新されます。</target>
        </trans-unit>
        <trans-unit id="12bc8cc3889504df656aec89fdae8d32b48b48bd" translate="yes" xml:space="preserve">
          <source>When setting the pick method to &lt;a href=&quot;qt3drender-qpickingsettings#PickResultMode-enum&quot;&gt;AllPicks&lt;/a&gt;, events will be triggered for all the entities with a &lt;a href=&quot;qt3drender-qobjectpicker&quot;&gt;QObjectPicker&lt;/a&gt; along the ray.</source>
          <target state="translated">pickメソッドを&lt;a href=&quot;qt3drender-qpickingsettings#PickResultMode-enum&quot;&gt;AllPicksに&lt;/a&gt;設定すると、&lt;a href=&quot;qt3drender-qobjectpicker&quot;&gt;レイに&lt;/a&gt;沿ってQObjectPickerを持つすべてのエンティティに対してイベントがトリガーされます。</target>
        </trans-unit>
        <trans-unit id="faf0f4e80eb610da479dd49899491179142a9cfd" translate="yes" xml:space="preserve">
          <source>When setting the pick method to &lt;a href=&quot;qt3drender-qpickingsettings#PickResultMode-enum&quot;&gt;NearestPriorityPick&lt;/a&gt;, events will be triggered for the nearest highest priority picker. This can be used when a given element should always be selected even if others are in front of it.</source>
          <target state="translated">pickメソッドを&lt;a href=&quot;qt3drender-qpickingsettings#PickResultMode-enum&quot;&gt;NearestPriorityPickに&lt;/a&gt;設定すると、最も近い最も優先度の高いピッカーに対してイベントがトリガーされます。これは、他の要素がその前にある場合でも、特定の要素を常に選択する必要がある場合に使用できます。</target>
        </trans-unit>
        <trans-unit id="46eaad0ccb2bedbfcbdda653384c06947cbb2dbb" translate="yes" xml:space="preserve">
          <source>When setting the year using the Date constructor or set(UTC)FullYear(), the convention set by ISO 8601 is used and 0 is a valid year. This means negative years set with the constructor or set(UTC)FullYear() are zero-based and thus offset by one year from what is printed with toString() and friends. Parsing the output of any of the to*String() methods will yield the same date value you printed from. Date.parse() will recognize the different formats and their convention on the existence of year 0.</source>
          <target state="translated">Date コンストラクタや set(UTC)FullYear()を使用して年を設定する場合は、ISO 8601 で定められた規約が使用され、0 が有効な年となります。つまり、コンストラクタや set(UTC)FullYear()で設定した負の年はゼロ・ベースであり、toString()や friends で出力されるものから 1 年分オフセットされます。to*String()メソッドの出力をパースすると、印刷した日付と同じ値が得られます。Date.parse()は、異なるフォーマットと 0 年の存在に関する規約を認識します。</target>
        </trans-unit>
        <trans-unit id="99af14a2050e900c54b4cf4320044307dba2671c" translate="yes" xml:space="preserve">
          <source>When setting this property &lt;a href=&quot;qtextbrowser&quot;&gt;QTextBrowser&lt;/a&gt; tries to find a document with the specified name in the paths of the &lt;a href=&quot;qtextbrowser#searchPaths-prop&quot;&gt;searchPaths&lt;/a&gt; property and directory of the current source, unless the value is an absolute file path. It also checks for optional anchors and scrolls the document accordingly</source>
          <target state="translated">このプロパティを設定すると、値が絶対ファイルパスでない限り、&lt;a href=&quot;qtextbrowser&quot;&gt;QTextBrowser&lt;/a&gt;は&lt;a href=&quot;qtextbrowser#searchPaths-prop&quot;&gt;searchPaths&lt;/a&gt;プロパティのパスと現在のソースのディレクトリで指定された名前のドキュメントを検索しようとします。また、オプションのアンカーをチェックし、それに応じてドキュメントをスクロールします</target>
        </trans-unit>
        <trans-unit id="fce20a64ddb9efcd0a6072a5a5807d0354c99c5b" translate="yes" xml:space="preserve">
          <source>When setting this property the &lt;a href=&quot;qdatetimeedit#maximumDate-prop&quot;&gt;maximumDate&lt;/a&gt; is adjusted if necessary, to ensure that the range remains valid. If the date is not a valid &lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt; object, this function does nothing.</source>
          <target state="translated">このプロパティを設定するとき、必要に応じて&lt;a href=&quot;qdatetimeedit#maximumDate-prop&quot;&gt;maximumDate&lt;/a&gt;が調整され、範囲が有効なままであることを確認します。日付が有効な&lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt;オブジェクトでない場合、この関数は何もしません。</target>
        </trans-unit>
        <trans-unit id="f3536a246a03f23af815f636527d6ffa980281bd" translate="yes" xml:space="preserve">
          <source>When setting this property the &lt;a href=&quot;qdatetimeedit#maximumDateTime-prop&quot;&gt;maximumDateTime&lt;/a&gt;() is adjusted if necessary to ensure that the range remains valid. If the datetime is not a valid &lt;a href=&quot;qdatetime&quot;&gt;QDateTime&lt;/a&gt; object, this function does nothing.</source>
          <target state="translated">このプロパティを設定する場合、必要に応じて&lt;a href=&quot;qdatetimeedit#maximumDateTime-prop&quot;&gt;maximumDateTime&lt;/a&gt;（）が調整され、範囲が有効なままであることを確認します。日時が有効な&lt;a href=&quot;qdatetime&quot;&gt;QDateTime&lt;/a&gt;オブジェクトでない場合、この関数は何もしません。</target>
        </trans-unit>
        <trans-unit id="1d3985b1214032de5548d5f37a050ce05224466f" translate="yes" xml:space="preserve">
          <source>When setting this property the &lt;a href=&quot;qdatetimeedit#maximumTime-prop&quot;&gt;maximumTime&lt;/a&gt; is adjusted if necessary, to ensure that the range remains valid. If the time is not a valid &lt;a href=&quot;qtime&quot;&gt;QTime&lt;/a&gt; object, this function does nothing.</source>
          <target state="translated">このプロパティを設定する場合、必要に応じて&lt;a href=&quot;qdatetimeedit#maximumTime-prop&quot;&gt;maximumTime&lt;/a&gt;が調整され、範囲が有効なままであることを確認します。時間が有効な&lt;a href=&quot;qtime&quot;&gt;QTime&lt;/a&gt;オブジェクトでない場合、この関数は何もしません。</target>
        </trans-unit>
        <trans-unit id="3a94d8175867d402a4937ec027013411408a4199" translate="yes" xml:space="preserve">
          <source>When setting this property the &lt;a href=&quot;qdatetimeedit#minimumDate-prop&quot;&gt;minimumDate&lt;/a&gt; is adjusted if necessary to ensure that the range remains valid. If the date is not a valid &lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt; object, this function does nothing.</source>
          <target state="translated">このプロパティを設定する場合、必要に応じて&lt;a href=&quot;qdatetimeedit#minimumDate-prop&quot;&gt;minimumDate&lt;/a&gt;が調整され、範囲が有効なままであることを確認します。日付が有効な&lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt;オブジェクトでない場合、この関数は何もしません。</target>
        </trans-unit>
        <trans-unit id="d00e3ae41e62b165ec366eabf69c76f997cb71bc" translate="yes" xml:space="preserve">
          <source>When setting this property the &lt;a href=&quot;qdatetimeedit#minimumDateTime-prop&quot;&gt;minimumDateTime&lt;/a&gt;() is adjusted if necessary to ensure that the range remains valid. If the datetime is not a valid &lt;a href=&quot;qdatetime&quot;&gt;QDateTime&lt;/a&gt; object, this function does nothing.</source>
          <target state="translated">このプロパティを設定する場合、必要に応じて&lt;a href=&quot;qdatetimeedit#minimumDateTime-prop&quot;&gt;minimumDateTime&lt;/a&gt;（）が調整され、範囲が有効なままであることを確認します。日時が有効な&lt;a href=&quot;qdatetime&quot;&gt;QDateTime&lt;/a&gt;オブジェクトでない場合、この関数は何もしません。</target>
        </trans-unit>
        <trans-unit id="fd101378453eccdf2e848a4824798dd5c0a85b7e" translate="yes" xml:space="preserve">
          <source>When setting this property the &lt;a href=&quot;qdoublespinbox#maximum-prop&quot;&gt;maximum&lt;/a&gt; is adjusted if necessary to ensure that the range remains valid.</source>
          <target state="translated">このプロパティを設定する場合、必要に応じて&lt;a href=&quot;qdoublespinbox#maximum-prop&quot;&gt;最大値&lt;/a&gt;が調整され、範囲が有効なままであることを確認します。</target>
        </trans-unit>
        <trans-unit id="d52e2cb44d7f2ae6749696edb496d673ee39757f" translate="yes" xml:space="preserve">
          <source>When setting this property the &lt;a href=&quot;qdoublespinbox#minimum-prop&quot;&gt;minimum&lt;/a&gt; is adjusted if necessary, to ensure that the range remains valid.</source>
          <target state="translated">このプロパティを設定するとき、範囲が有効なままであることを保証するために、必要に応じて&lt;a href=&quot;qdoublespinbox#minimum-prop&quot;&gt;最小値&lt;/a&gt;が調整されます。</target>
        </trans-unit>
        <trans-unit id="47cfedf6ef21c709f13ba69a81ab6789fc8a9fd1" translate="yes" xml:space="preserve">
          <source>When setting this property the &lt;a href=&quot;qspinbox#maximum-prop&quot;&gt;maximum&lt;/a&gt; is adjusted if necessary to ensure that the range remains valid.</source>
          <target state="translated">このプロパティを設定する場合、必要に応じて&lt;a href=&quot;qspinbox#maximum-prop&quot;&gt;最大値&lt;/a&gt;が調整され、範囲が有効なままであることを確認します。</target>
        </trans-unit>
        <trans-unit id="9b3aa09d9d597d2ccc6d81186f12b9dee43bde16" translate="yes" xml:space="preserve">
          <source>When setting this property the corresponding maximum value is adjusted if necessary, to ensure that the range remains valid.</source>
          <target state="translated">このプロパティを設定すると、必要に応じて対応する最大値が調整され、範囲が有効に保たれるようになります。</target>
        </trans-unit>
        <trans-unit id="ed5abb02b8b1a236c42c80272c5d4f7b5e792484" translate="yes" xml:space="preserve">
          <source>When setting this property the corresponding minimum value is adjusted if necessary, to ensure that the range remains valid.</source>
          <target state="translated">このプロパティを設定すると、必要に応じて対応する最小値が調整され、範囲が有効に保たれるようになります。</target>
        </trans-unit>
        <trans-unit id="0e2d22ffaa8c87cce0769e98c3a06583fa170f8d" translate="yes" xml:space="preserve">
          <source>When setting this property the minimum is adjusted if necessary, to ensure that the range remains valid.</source>
          <target state="translated">このプロパティを設定すると、必要に応じて最小値が調整され、範囲が有効に保たれるようになります。</target>
        </trans-unit>
        <trans-unit id="10bbb03412564a8a76a7faa470981f3e92871bb0" translate="yes" xml:space="preserve">
          <source>When setting this property the timespec of the &lt;a href=&quot;qdatetimeedit&quot;&gt;QDateTimeEdit&lt;/a&gt; remains the same and the timespec of the new &lt;a href=&quot;qdatetime&quot;&gt;QDateTime&lt;/a&gt; is ignored.</source>
          <target state="translated">このプロパティを設定すると、&lt;a href=&quot;qdatetimeedit&quot;&gt;QDateTimeEdit&lt;/a&gt;のtimespecは同じままになり、新しい&lt;a href=&quot;qdatetime&quot;&gt;QDateTimeの&lt;/a&gt; timespec は無視されます。</target>
        </trans-unit>
        <trans-unit id="2375a6809ff71a69632c1ba6bc4411bcbd56175e" translate="yes" xml:space="preserve">
          <source>When setting this property to a list of waypoints, each waypoint can be either a &lt;a href=&quot;qml-coordinate&quot;&gt;coordinate&lt;/a&gt; or a &lt;a href=&quot;qml-qtlocation-waypoint&quot;&gt;Waypoint&lt;/a&gt;, interchangeably. If a &lt;a href=&quot;qml-coordinate&quot;&gt;coordinate&lt;/a&gt; is passed, it will be internally converted to a &lt;a href=&quot;qml-qtlocation-waypoint&quot;&gt;Waypoint&lt;/a&gt;.</source>
          <target state="translated">このプロパティをウェイポイントのリストに設定する場合、各ウェイポイントは、&lt;a href=&quot;qml-coordinate&quot;&gt;座標&lt;/a&gt;または&lt;a href=&quot;qml-qtlocation-waypoint&quot;&gt;ウェイポイントの&lt;/a&gt;いずれかにすることができます。場合は&lt;a href=&quot;qml-coordinate&quot;&gt;座標が&lt;/a&gt;渡され、それが内部に変換されます&lt;a href=&quot;qml-qtlocation-waypoint&quot;&gt;ウェイポイント&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8c08c05c4f9a6cc8ebd2fa6d3ff3659b0e8d5359" translate="yes" xml:space="preserve">
          <source>When setting this property, the &lt;a href=&quot;qabstractslider#maximum-prop&quot;&gt;maximum&lt;/a&gt; is adjusted if necessary to ensure that the range remains valid. Also the slider's current value is adjusted to be within the new range.</source>
          <target state="translated">このプロパティを設定する場合、必要に応じて&lt;a href=&quot;qabstractslider#maximum-prop&quot;&gt;最大値&lt;/a&gt;が調整され、範囲が有効なままであることを確認します。また、スライダーの現在の値が新しい範囲内になるように調整されます。</target>
        </trans-unit>
        <trans-unit id="083344e77b31d85a0b5a8a8283eca8fda3876952" translate="yes" xml:space="preserve">
          <source>When setting this property, the &lt;a href=&quot;qabstractslider#minimum-prop&quot;&gt;minimum&lt;/a&gt; is adjusted if necessary to ensure that the range remains valid. Also the slider's current value is adjusted to be within the new range.</source>
          <target state="translated">このプロパティを設定する場合、必要に応じて&lt;a href=&quot;qabstractslider#minimum-prop&quot;&gt;最小値&lt;/a&gt;が調整され、範囲が有効なままであることを確認します。また、スライダーの現在の値が新しい範囲内になるように調整されます。</target>
        </trans-unit>
        <trans-unit id="890b98dfbcb1358977a7219adcd63ac2cd2c0980" translate="yes" xml:space="preserve">
          <source>When setting this property, the &lt;a href=&quot;qdatetimeedit#minimumTime-prop&quot;&gt;minimumTime&lt;/a&gt; is adjusted if necessary to ensure that the range remains valid. If the time is not a valid &lt;a href=&quot;qtime&quot;&gt;QTime&lt;/a&gt; object, this function does nothing.</source>
          <target state="translated">このプロパティを設定する場合、必要に応じて&lt;a href=&quot;qdatetimeedit#minimumTime-prop&quot;&gt;minimumTime&lt;/a&gt;が調整され、範囲が有効なままであることを確認します。時間が有効な&lt;a href=&quot;qtime&quot;&gt;QTime&lt;/a&gt;オブジェクトでない場合、この関数は何もしません。</target>
        </trans-unit>
        <trans-unit id="fa2c9bb906ff3305eef76e88d6b8655a32b982f4" translate="yes" xml:space="preserve">
          <source>When setting this property, the &lt;a href=&quot;qml-qtcharts-pieseries#holeSize-prop&quot;&gt;holeSize&lt;/a&gt; property is adjusted if necessary, to ensure that the hole size is not greater than the pie size.</source>
          <target state="translated">このプロパティを設定するとき、必要に応じて&lt;a href=&quot;qml-qtcharts-pieseries#holeSize-prop&quot;&gt;holeSize&lt;/a&gt;プロパティを調整し、穴のサイズがパイのサイズを超えないようにします。</target>
        </trans-unit>
        <trans-unit id="f435a68f9316a9aad8d0bd9214e3829a97c2384f" translate="yes" xml:space="preserve">
          <source>When setting this property, the &lt;a href=&quot;qml-qtcharts-pieseries#size-prop&quot;&gt;size&lt;/a&gt; property is adjusted if necessary, to ensure that the hole size is not greater than the pie size.</source>
          <target state="translated">このプロパティを設定する場合、必要に応じて&lt;a href=&quot;qml-qtcharts-pieseries#size-prop&quot;&gt;サイズ&lt;/a&gt;プロパティを調整し、穴のサイズがパイのサイズより大きくならないようにします。</target>
        </trans-unit>
        <trans-unit id="2614229e0748ff7798a30ec6c9a32c8bd564129c" translate="yes" xml:space="preserve">
          <source>When setting this property, the &lt;a href=&quot;qpieseries#holeSize-prop&quot;&gt;holeSize&lt;/a&gt; property is adjusted if necessary, to ensure that the hole size is not greater than the pie size.</source>
          <target state="translated">このプロパティを設定するとき、必要に応じて&lt;a href=&quot;qpieseries#holeSize-prop&quot;&gt;holeSize&lt;/a&gt;プロパティを調整し、穴のサイズがパイのサイズを超えないようにします。</target>
        </trans-unit>
        <trans-unit id="9676bb4e1b94754c72406b0dd8f30c9729452b6c" translate="yes" xml:space="preserve">
          <source>When setting this property, the &lt;a href=&quot;qpieseries#size-prop&quot;&gt;size&lt;/a&gt; property is adjusted if necessary, to ensure that the hole size is not greater than the pie size.</source>
          <target state="translated">このプロパティを設定する場合、必要に応じて&lt;a href=&quot;qpieseries#size-prop&quot;&gt;サイズ&lt;/a&gt;プロパティを調整し、穴のサイズがパイのサイズより大きくならないようにします。</target>
        </trans-unit>
        <trans-unit id="5c4c814181687e53992d25bc4a345c8885416475" translate="yes" xml:space="preserve">
          <source>When setting this property, the &lt;a href=&quot;qprogressbar#maximum-prop&quot;&gt;maximum&lt;/a&gt; is adjusted if necessary to ensure that the range remains valid. If the current value falls outside the new range, the progress bar is reset with &lt;a href=&quot;qprogressbar#reset&quot;&gt;reset&lt;/a&gt;().</source>
          <target state="translated">このプロパティを設定する場合、必要に応じて&lt;a href=&quot;qprogressbar#maximum-prop&quot;&gt;最大値&lt;/a&gt;が調整され、範囲が有効なままであることを確認します。現在の値が新しい範囲の外にある場合、プログレスバーは&lt;a href=&quot;qprogressbar#reset&quot;&gt;リセット&lt;/a&gt;（）でリセットされます。</target>
        </trans-unit>
        <trans-unit id="d10bb2cee1aba8ceaf054055bf90ceea6821e2bc" translate="yes" xml:space="preserve">
          <source>When setting this property, the &lt;a href=&quot;qprogressbar#minimum-prop&quot;&gt;minimum&lt;/a&gt; is adjusted if necessary to ensure that the range remains valid. If the current value falls outside the new range, the progress bar is reset with &lt;a href=&quot;qprogressbar#reset&quot;&gt;reset&lt;/a&gt;().</source>
          <target state="translated">このプロパティを設定する場合、必要に応じて&lt;a href=&quot;qprogressbar#minimum-prop&quot;&gt;最小値&lt;/a&gt;が調整され、範囲が有効なままであることを確認します。現在の値が新しい範囲の外にある場合、プログレスバーは&lt;a href=&quot;qprogressbar#reset&quot;&gt;リセット&lt;/a&gt;（）でリセットされます。</target>
        </trans-unit>
        <trans-unit id="32aea66ca6d6da71cb41f4c7cc9dc10b08e8577f" translate="yes" xml:space="preserve">
          <source>When setting this property, the maximum value is adjusted if necessary, to ensure that the range remains valid.</source>
          <target state="translated">このプロパティを設定すると、必要に応じて最大値が調整され、範囲が有効に保たれるようになります。</target>
        </trans-unit>
        <trans-unit id="b951c983b0aee73e158712980739ff70f149887e" translate="yes" xml:space="preserve">
          <source>When setting this property, the maximum value is adjusted if necessary, to ensure that the range remains valid. The value has to be greater than 0.</source>
          <target state="translated">このプロパティを設定すると、必要に応じて最大値が調整され、範囲が有効に保たれるようになります。値は0より大きくなければなりません。</target>
        </trans-unit>
        <trans-unit id="7a55bcbc9be43eedc7805bdbb3ee9e54f14990ff" translate="yes" xml:space="preserve">
          <source>When setting this property, the minimum value is adjusted if necessary, to ensure that the range remains valid.</source>
          <target state="translated">このプロパティを設定すると、必要に応じて最小値が調整され、範囲が有効に保たれるようになります。</target>
        </trans-unit>
        <trans-unit id="c7876cf5d914de6fdd878ac65bed31fe69eb59c2" translate="yes" xml:space="preserve">
          <source>When setting this property, the minimum value is adjusted if necessary, to ensure that the range remains valid. The value has to be greater than 0.</source>
          <target state="translated">このプロパティを設定すると、必要に応じて最小値が調整され、範囲が有効に保たれるようになります。値は0より大きくなければなりません。</target>
        </trans-unit>
        <trans-unit id="5cd6dbda7cf0ef9fd68544a0e1bb706ce0a9be68" translate="yes" xml:space="preserve">
          <source>When setting this property, the new &lt;a href=&quot;qdatetime&quot;&gt;QDateTime&lt;/a&gt; is converted to the timespec of the &lt;a href=&quot;qdatetimeedit&quot;&gt;QDateTimeEdit&lt;/a&gt;, which thus remains unchanged.</source>
          <target state="translated">このプロパティを設定するときは、新しい&lt;a href=&quot;qdatetime&quot;&gt;QDateTimeは&lt;/a&gt;のTIMESPECに変換され&lt;a href=&quot;qdatetimeedit&quot;&gt;QDateTimeEdit&lt;/a&gt;ので変更されないまま、。</target>
        </trans-unit>
        <trans-unit id="5de4dc53f812589029ed9067e97355562cb0e1d3" translate="yes" xml:space="preserve">
          <source>When setting up the rendering pipeline, call &lt;a href=&quot;qvulkanwindow#sampleCountFlagBits&quot;&gt;sampleCountFlagBits&lt;/a&gt;() to query the active sample count as a &lt;code&gt;VkSampleCountFlagBits&lt;/code&gt; value.</source>
          <target state="translated">レンダリングパイプラインを設定するときに、&lt;a href=&quot;qvulkanwindow#sampleCountFlagBits&quot;&gt;sampleCountFlagBits&lt;/a&gt;（）を呼び出して、アクティブなサンプル数を &lt;code&gt;VkSampleCountFlagBits&lt;/code&gt; 値としてクエリします。</target>
        </trans-unit>
        <trans-unit id="dfcd5a5c296c55f96b9ee5da99d93a616d2b11fc" translate="yes" xml:space="preserve">
          <source>When shaders were added to this program via &lt;a href=&quot;qopenglshaderprogram#addCacheableShaderFromSourceCode&quot;&gt;addCacheableShaderFromSourceCode&lt;/a&gt;() or &lt;a href=&quot;qopenglshaderprogram#addCacheableShaderFromSourceFile&quot;&gt;addCacheableShaderFromSourceFile&lt;/a&gt;(), program binaries are supported, and a cached binary is available on disk, actual compilation and linking are skipped. Instead, link() will initialize the program with the binary blob via glProgramBinary(). If there is no cached version of the program or it was generated with a different driver version, the shaders will be compiled from source and the program will get linked normally. This allows seamless upgrading of the graphics drivers, without having to worry about potentially incompatible binary formats.</source>
          <target state="translated">シェーダーが&lt;a href=&quot;qopenglshaderprogram#addCacheableShaderFromSourceCode&quot;&gt;addCacheableShaderFromSourceCode&lt;/a&gt;（）または&lt;a href=&quot;qopenglshaderprogram#addCacheableShaderFromSourceFile&quot;&gt;addCacheableShaderFromSourceFile&lt;/a&gt;（）を介してこのプログラムに追加された場合、プログラムバイナリがサポートされ、キャッシュされたバイナリがディスク上で使用できるため、実際のコンパイルとリンクはスキップされます。代わりに、link（）はglProgramBinary（）を介してバイナリBLOBでプログラムを初期化します。プログラムのキャッシュされたバージョンがない場合、または異なるドライバーバージョンで生成された場合、シェーダーはソースからコンパイルされ、プログラムは通常どおりリンクされます。これにより、互換性のない可能性のあるバイナリ形式を心配することなく、グラフィックスドライバーをシームレスにアップグレードできます。</target>
        </trans-unit>
        <trans-unit id="87d3d39130885f5e5c6a9174de6513c3d33b6b27" translate="yes" xml:space="preserve">
          <source>When side-effects are unavoidable, ensure that the prior state is restored at the end of the test function, even if the test fails. This commonly requires use of an RAII (resource acquisition is initialization) class that restores state when the function returns, or a &lt;code&gt;cleanup()&lt;/code&gt; method. Do not simply put the restoration code at the end of the test. If part of the test fails, such code will be skipped and the prior state will not be restored.</source>
          <target state="translated">副作用が避けられない場合は、テストが失敗した場合でも、テスト機能の終了時に前の状態が復元されることを確認してください。これには通常、関数が戻ったときに状態を復元するRAII（リソース取得は初期化）クラス、または &lt;code&gt;cleanup()&lt;/code&gt; メソッドを使用する必要があります。テストの最後に復元コードを単純に配置しないでください。テストの一部が失敗した場合、そのようなコードはスキップされ、以前の状態は復元されません。</target>
        </trans-unit>
        <trans-unit id="64b2c21463a05b372aacfedaa2026900f87448ca" translate="yes" xml:space="preserve">
          <source>When subclassing &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt; or &lt;a href=&quot;qabstractproxymodel&quot;&gt;QAbstractProxyModel&lt;/a&gt;, ensure that you emit &lt;a href=&quot;qabstractitemmodel#layoutAboutToBeChanged&quot;&gt;layoutAboutToBeChanged&lt;/a&gt;() before changing the order of items or altering the structure of the data you expose to views, and emit layoutChanged() after changing the layout.</source>
          <target state="translated">サブクラス場合&lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt;又は&lt;a href=&quot;qabstractproxymodel&quot;&gt;QAbstractProxyModelを&lt;/a&gt;、あなたが発することを確認&lt;a href=&quot;qabstractitemmodel#layoutAboutToBeChanged&quot;&gt;layoutAboutToBeChangedの&lt;/a&gt;レイアウトを変更した後（）の項目の順序を変更したり、ビューに公開するデータの構造を変更する前に（）、及びEMITはlayoutChanged。</target>
        </trans-unit>
        <trans-unit id="29ad4f995056d1ccd3dcee88f2d1086d0349dbfd" translate="yes" xml:space="preserve">
          <source>When subclassing &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt;, at the very least you must implement &lt;a href=&quot;qabstractitemmodel#index&quot;&gt;index&lt;/a&gt;(), &lt;a href=&quot;qabstractitemmodel#parent&quot;&gt;parent&lt;/a&gt;(), &lt;a href=&quot;qabstractitemmodel#rowCount&quot;&gt;rowCount&lt;/a&gt;(), &lt;a href=&quot;qabstractitemmodel#columnCount&quot;&gt;columnCount&lt;/a&gt;(), and &lt;a href=&quot;qabstractitemmodel#data&quot;&gt;data&lt;/a&gt;(). These functions are used in all read-only models, and form the basis of editable models.</source>
          <target state="translated">サブクラス化すると&lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModelを&lt;/a&gt;、非常に少なくとも、あなたが実装する必要があります&lt;a href=&quot;qabstractitemmodel#index&quot;&gt;インデックス&lt;/a&gt;（）、&lt;a href=&quot;qabstractitemmodel#parent&quot;&gt;親&lt;/a&gt;（）、&lt;a href=&quot;qabstractitemmodel#rowCount&quot;&gt;をrowCount&lt;/a&gt;（）、&lt;a href=&quot;qabstractitemmodel#columnCount&quot;&gt;columnCountの&lt;/a&gt;（）、および&lt;a href=&quot;qabstractitemmodel#data&quot;&gt;データを&lt;/a&gt;（）。これらの関数はすべての読み取り専用モデルで使用され、編集可能なモデルの基礎を形成します。</target>
        </trans-unit>
        <trans-unit id="a191eed727edc2ae03b2ab93852a02163a6c05e0" translate="yes" xml:space="preserve">
          <source>When subclassing &lt;a href=&quot;qabstractlistmodel&quot;&gt;QAbstractListModel&lt;/a&gt;, you must provide implementations of the &lt;a href=&quot;qabstractitemmodel#rowCount&quot;&gt;rowCount&lt;/a&gt;() and &lt;a href=&quot;qabstractitemmodel#data&quot;&gt;data&lt;/a&gt;() functions. Well behaved models also provide a &lt;a href=&quot;qabstractitemmodel#headerData&quot;&gt;headerData&lt;/a&gt;() implementation.</source>
          <target state="translated">&lt;a href=&quot;qabstractlistmodel&quot;&gt;QAbstractListModelを&lt;/a&gt;サブクラス化するとき、&lt;a href=&quot;qabstractitemmodel#rowCount&quot;&gt;rowCount&lt;/a&gt;（）および&lt;a href=&quot;qabstractitemmodel#data&quot;&gt;data&lt;/a&gt;（）関数の実装を提供する必要があります。適切に動作するモデルは、&lt;a href=&quot;qabstractitemmodel#headerData&quot;&gt;headerData&lt;/a&gt;（）実装も提供します。</target>
        </trans-unit>
        <trans-unit id="34ee94bbac1ecea4e8ddb454d400be8aae1e7968" translate="yes" xml:space="preserve">
          <source>When subclassing &lt;a href=&quot;qabstracttablemodel&quot;&gt;QAbstractTableModel&lt;/a&gt;, you must implement &lt;a href=&quot;qabstractitemmodel#rowCount&quot;&gt;rowCount&lt;/a&gt;(), &lt;a href=&quot;qabstractitemmodel#columnCount&quot;&gt;columnCount&lt;/a&gt;(), and &lt;a href=&quot;qabstractitemmodel#data&quot;&gt;data&lt;/a&gt;(). Default implementations of the &lt;a href=&quot;qabstracttablemodel#index&quot;&gt;index&lt;/a&gt;() and &lt;a href=&quot;qabstractitemmodel#parent&quot;&gt;parent&lt;/a&gt;() functions are provided by &lt;a href=&quot;qabstracttablemodel&quot;&gt;QAbstractTableModel&lt;/a&gt;. Well behaved models will also implement &lt;a href=&quot;qabstractitemmodel#headerData&quot;&gt;headerData&lt;/a&gt;().</source>
          <target state="translated">&lt;a href=&quot;qabstracttablemodel&quot;&gt;QAbstractTableModelを&lt;/a&gt;サブクラス化するとき、&lt;a href=&quot;qabstractitemmodel#rowCount&quot;&gt;rowCount&lt;/a&gt;（）、&lt;a href=&quot;qabstractitemmodel#columnCount&quot;&gt;columnCount&lt;/a&gt;（）、および&lt;a href=&quot;qabstractitemmodel#data&quot;&gt;data&lt;/a&gt;（）を実装する必要があります。&lt;a href=&quot;qabstracttablemodel#index&quot;&gt;index&lt;/a&gt;（）および&lt;a href=&quot;qabstractitemmodel#parent&quot;&gt;parent&lt;/a&gt;（）関数のデフォルトの実装は&lt;a href=&quot;qabstracttablemodel&quot;&gt;QAbstractTableModel&lt;/a&gt;によって提供されます。適切に動作するモデルは、&lt;a href=&quot;qabstractitemmodel#headerData&quot;&gt;headerData&lt;/a&gt;（）も実装します。</target>
        </trans-unit>
        <trans-unit id="bc5ed4ae258b22a232b577325d7a45d5a74a6ae6" translate="yes" xml:space="preserve">
          <source>When subclassing &lt;a href=&quot;qaccessibleactioninterface&quot;&gt;QAccessibleActionInterface&lt;/a&gt; you need to provide a list of &lt;a href=&quot;qaccessibleactioninterface#actionNames&quot;&gt;actionNames&lt;/a&gt; which is the primary means to discover the available actions. Action names are never localized. In order to present actions to the user there are two functions that need to return localized versions of the name and give a description of the action. For the predefined action names use &lt;a href=&quot;qaccessibleactioninterface#localizedActionName&quot;&gt;QAccessibleActionInterface::localizedActionName&lt;/a&gt;() and &lt;a href=&quot;qaccessibleactioninterface#localizedActionDescription&quot;&gt;QAccessibleActionInterface::localizedActionDescription&lt;/a&gt;() to return their localized counterparts.</source>
          <target state="translated">&lt;a href=&quot;qaccessibleactioninterface&quot;&gt;QAccessibleActionInterface&lt;/a&gt;をサブクラス化するとき、利用可能なアクションを発見するための主要な手段である&lt;a href=&quot;qaccessibleactioninterface#actionNames&quot;&gt;actionNamesの&lt;/a&gt;リストを提供する必要があります。アクション名はローカライズされません。ユーザーにアクションを提示するために、名前のローカライズバージョンを返し、アクションの説明を提供する必要がある2つの関数があります。事前定義されたアクション名については、&lt;a href=&quot;qaccessibleactioninterface#localizedActionName&quot;&gt;QAccessibleActionInterface :: localizedActionName&lt;/a&gt;（）および&lt;a href=&quot;qaccessibleactioninterface#localizedActionDescription&quot;&gt;QAccessibleActionInterface :: localizedActionDescription&lt;/a&gt;（）を使用して、対応するローカライズされたものを返します。</target>
        </trans-unit>
        <trans-unit id="a25edef8cc00a94f017f1d9cbc6945550b8bf450" translate="yes" xml:space="preserve">
          <source>When subclassing &lt;a href=&quot;qiodevice&quot;&gt;QIODevice&lt;/a&gt;, you must call QIODevice::seek() at the start of your function to ensure integrity with &lt;a href=&quot;qiodevice&quot;&gt;QIODevice&lt;/a&gt;'s built-in buffer.</source>
          <target state="translated">&lt;a href=&quot;qiodevice&quot;&gt;QIODeviceを&lt;/a&gt;サブクラス化する場合、関数の開始時にQIODevice :: seek（）を呼び出して、&lt;a href=&quot;qiodevice&quot;&gt;QIODevice&lt;/a&gt;の組み込みバッファーとの整合性を確保する必要があります。</target>
        </trans-unit>
        <trans-unit id="d195ef9dc4d6a9738e6783d4bc0696c9278d4ef4" translate="yes" xml:space="preserve">
          <source>When subclassing &lt;a href=&quot;qitemdelegate&quot;&gt;QItemDelegate&lt;/a&gt; to create a delegate that displays items using a custom renderer, it is important to ensure that the delegate can render items suitably for all the required states; e.g. selected, disabled, checked. The documentation for the &lt;a href=&quot;qitemdelegate#paint&quot;&gt;paint&lt;/a&gt;() function contains some hints to show how this can be achieved.</source>
          <target state="translated">&lt;a href=&quot;qitemdelegate&quot;&gt;QItemDelegate&lt;/a&gt;をサブクラス化して、カスタムレンダラーを使用してアイテムを表示するデリゲートを作成する場合、デリゲートが必要なすべての状態に適切にアイテムをレンダリングできることを確認することが重要です。たとえば、選択、無効化、チェック。&lt;a href=&quot;qitemdelegate#paint&quot;&gt;paint&lt;/a&gt;（）関数のドキュメントには、これを実現する方法を示すヒントが含まれています。</target>
        </trans-unit>
        <trans-unit id="bdfab8a00f506ea4624c5ba05bcfdffa0be88abb" translate="yes" xml:space="preserve">
          <source>When subclassing &lt;a href=&quot;qlistwidgetitem&quot;&gt;QListWidgetItem&lt;/a&gt; to provide custom items, it is possible to define new types for them enabling them to be distinguished from standard items. For subclasses that require this feature, ensure that you call the base class constructor with a new type value equal to or greater than &lt;a href=&quot;qlistwidgetitem#ItemType-enum&quot;&gt;UserType&lt;/a&gt;, within</source>
          <target state="translated">&lt;a href=&quot;qlistwidgetitem&quot;&gt;QListWidgetItem&lt;/a&gt;をサブクラス化してカスタムアイテムを提供する場合、それらに新しいタイプを定義して、標準アイテムと区別することができます。この機能を必要とするサブクラスについては、新しいタイプの値を持つ基底クラスのコンストラクタは、以上に呼び出すことを確認する&lt;a href=&quot;qlistwidgetitem#ItemType-enum&quot;&gt;のUserType&lt;/a&gt;内、</target>
        </trans-unit>
        <trans-unit id="25983c5d275d61a5768d14102127d7627a6f2db7" translate="yes" xml:space="preserve">
          <source>When subclassing &lt;a href=&quot;qstandarditem&quot;&gt;QStandardItem&lt;/a&gt; to provide custom items, it is possible to define new types for them so that they can be distinguished from the base class. The &lt;a href=&quot;qstandarditem#type&quot;&gt;type&lt;/a&gt;() function should be reimplemented to return a new type value equal to or greater than &lt;a href=&quot;qstandarditem#ItemType-enum&quot;&gt;UserType&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qstandarditem&quot;&gt;QStandardItem&lt;/a&gt;をサブクラス化してカスタム項目を提供する場合、基本クラスと区別できるように、それらに新しいタイプを定義することができます。&lt;a href=&quot;qstandarditem#type&quot;&gt;タイプ&lt;/a&gt;（）関数は、に等しいか又はより大きい新しいタイプの値を返すように再実装しなければならない&lt;a href=&quot;qstandarditem#ItemType-enum&quot;&gt;のUserType&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e6fbf6fe9133647e06d0faf1437cba6ca2cedd98" translate="yes" xml:space="preserve">
          <source>When subclassing &lt;a href=&quot;qstandarditem&quot;&gt;QStandardItem&lt;/a&gt;, you can reimplement this function to provide &lt;a href=&quot;qstandarditemmodel&quot;&gt;QStandardItemModel&lt;/a&gt; with a factory that it can use to create new items on demand.</source>
          <target state="translated">&lt;a href=&quot;qstandarditem&quot;&gt;QStandardItemを&lt;/a&gt;サブクラス化するとき、この関数を再実装して、&lt;a href=&quot;qstandarditemmodel&quot;&gt;QStandardItemModel&lt;/a&gt;に、オンデマンドで新しいアイテムを作成するために使用できるファクトリを提供できます。</target>
        </trans-unit>
        <trans-unit id="f2286413d50d08d040929b6ec39c68a3dddaf3c0" translate="yes" xml:space="preserve">
          <source>When subclassing &lt;a href=&quot;qtablewidgetitem&quot;&gt;QTableWidgetItem&lt;/a&gt; to provide custom items, it is possible to define new types for them so that they can be distinguished from standard items. The constructors for subclasses that require this feature need to call the base class constructor with a new type value equal to or greater than &lt;a href=&quot;qtablewidgetitem#ItemType-enum&quot;&gt;UserType&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qtablewidgetitem&quot;&gt;QTableWidgetItem&lt;/a&gt;をサブクラス化してカスタムアイテムを提供する場合、標準アイテムと区別できるように、新しいタイプを定義することができます。この機能を必要とするサブクラスのコンストラクターは、&lt;a href=&quot;qtablewidgetitem#ItemType-enum&quot;&gt;UserType&lt;/a&gt;以上の新しい型の値で基本クラスコンストラクターを呼び出す必要があります。</target>
        </trans-unit>
        <trans-unit id="1002dc2f9f72071b49f3bc6989364ec60eb22d54" translate="yes" xml:space="preserve">
          <source>When subclassing &lt;a href=&quot;qtreewidgetitem&quot;&gt;QTreeWidgetItem&lt;/a&gt; to provide custom items, it is possible to define new types for them so that they can be distinguished from standard items. The constructors for subclasses that require this feature need to call the base class constructor with a new type value equal to or greater than &lt;a href=&quot;qtreewidgetitem#ItemType-enum&quot;&gt;UserType&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qtreewidgetitem&quot;&gt;QTreeWidgetItem&lt;/a&gt;をサブクラス化してカスタムアイテムを提供する場合、それらに新しいタイプを定義して、標準アイテムと区別できるようにすることができます。この機能を必要とするサブクラスのコンストラクターは、&lt;a href=&quot;qtreewidgetitem#ItemType-enum&quot;&gt;UserType&lt;/a&gt;以上の新しい型の値で基本クラスコンストラクターを呼び出す必要があります。</target>
        </trans-unit>
        <trans-unit id="59520faecedf14305609ce71b43c92f419907198" translate="yes" xml:space="preserve">
          <source>When subclassing QAbstractItemModel, at the very least you must implement &lt;a href=&quot;qabstractitemmodel#index&quot;&gt;index&lt;/a&gt;(), &lt;a href=&quot;qabstractitemmodel#parent&quot;&gt;parent&lt;/a&gt;(), &lt;a href=&quot;qabstractitemmodel#rowCount&quot;&gt;rowCount&lt;/a&gt;(), &lt;a href=&quot;qabstractitemmodel#columnCount&quot;&gt;columnCount&lt;/a&gt;(), and &lt;a href=&quot;qabstractitemmodel#data&quot;&gt;data&lt;/a&gt;(). These functions are used in all read-only models, and form the basis of editable models.</source>
          <target state="translated">QAbstractItemModelをサブクラス化するときは、少なくとも&lt;a href=&quot;qabstractitemmodel#index&quot;&gt;index&lt;/a&gt;（）、&lt;a href=&quot;qabstractitemmodel#parent&quot;&gt;parent&lt;/a&gt;（）、&lt;a href=&quot;qabstractitemmodel#rowCount&quot;&gt;rowCount&lt;/a&gt;（）、&lt;a href=&quot;qabstractitemmodel#columnCount&quot;&gt;columnCount&lt;/a&gt;（）、および&lt;a href=&quot;qabstractitemmodel#data&quot;&gt;data&lt;/a&gt;（）を実装する必要があります。これらの関数はすべての読み取り専用モデルで使用され、編集可能なモデルの基礎を形成します。</target>
        </trans-unit>
        <trans-unit id="3699b269f018546bac2b237f4b1ba2d9ba58cd5a" translate="yes" xml:space="preserve">
          <source>When subclassing QAbstractListModel, you must provide implementations of the &lt;a href=&quot;qabstractitemmodel#rowCount&quot;&gt;rowCount&lt;/a&gt;() and &lt;a href=&quot;qabstractitemmodel#data&quot;&gt;data&lt;/a&gt;() functions. Well behaved models also provide a &lt;a href=&quot;qabstractitemmodel#headerData&quot;&gt;headerData&lt;/a&gt;() implementation.</source>
          <target state="translated">When subclassing QAbstractListModel, you must provide implementations of the &lt;a href=&quot;qabstractitemmodel#rowCount&quot;&gt;rowCount&lt;/a&gt;() and &lt;a href=&quot;qabstractitemmodel#data&quot;&gt;data&lt;/a&gt;() functions. Well behaved models also provide a &lt;a href=&quot;qabstractitemmodel#headerData&quot;&gt;headerData&lt;/a&gt;() implementation.</target>
        </trans-unit>
        <trans-unit id="b1062aef636e41c878017026955b733a82f0e58d" translate="yes" xml:space="preserve">
          <source>When subclassing QAbstractTableModel, you must implement &lt;a href=&quot;qabstractitemmodel#rowCount&quot;&gt;rowCount&lt;/a&gt;(), &lt;a href=&quot;qabstractitemmodel#columnCount&quot;&gt;columnCount&lt;/a&gt;(), and &lt;a href=&quot;qabstractitemmodel#data&quot;&gt;data&lt;/a&gt;(). Default implementations of the &lt;a href=&quot;qabstracttablemodel#index&quot;&gt;index&lt;/a&gt;() and &lt;a href=&quot;qabstractitemmodel#parent&quot;&gt;parent&lt;/a&gt;() functions are provided by QAbstractTableModel. Well behaved models will also implement &lt;a href=&quot;qabstractitemmodel#headerData&quot;&gt;headerData&lt;/a&gt;().</source>
          <target state="translated">When subclassing QAbstractTableModel, you must implement &lt;a href=&quot;qabstractitemmodel#rowCount&quot;&gt;rowCount&lt;/a&gt;(), &lt;a href=&quot;qabstractitemmodel#columnCount&quot;&gt;columnCount&lt;/a&gt;(), and &lt;a href=&quot;qabstractitemmodel#data&quot;&gt;data&lt;/a&gt;(). Default implementations of the &lt;a href=&quot;qabstracttablemodel#index&quot;&gt;index&lt;/a&gt;() and &lt;a href=&quot;qabstractitemmodel#parent&quot;&gt;parent&lt;/a&gt;() functions are provided by QAbstractTableModel. Well behaved models will also implement &lt;a href=&quot;qabstractitemmodel#headerData&quot;&gt;headerData&lt;/a&gt;().</target>
        </trans-unit>
        <trans-unit id="26b79d67e5a46121dc5b166539f6602a7e665200" translate="yes" xml:space="preserve">
          <source>When subclassing QAccessibleActionInterface you need to provide a list of &lt;a href=&quot;qaccessibleactioninterface#actionNames&quot;&gt;actionNames&lt;/a&gt; which is the primary means to discover the available actions. Action names are never localized. In order to present actions to the user there are two functions that need to return localized versions of the name and give a description of the action. For the predefined action names use &lt;a href=&quot;qaccessibleactioninterface#localizedActionName&quot;&gt;QAccessibleActionInterface::localizedActionName&lt;/a&gt;() and &lt;a href=&quot;qaccessibleactioninterface#localizedActionDescription&quot;&gt;QAccessibleActionInterface::localizedActionDescription&lt;/a&gt;() to return their localized counterparts.</source>
          <target state="translated">When subclassing QAccessibleActionInterface you need to provide a list of &lt;a href=&quot;qaccessibleactioninterface#actionNames&quot;&gt;actionNames&lt;/a&gt; which is the primary means to discover the available actions. Action names are never localized. In order to present actions to the user there are two functions that need to return localized versions of the name and give a description of the action. For the predefined action names use &lt;a href=&quot;qaccessibleactioninterface#localizedActionName&quot;&gt;QAccessibleActionInterface::localizedActionName&lt;/a&gt;() and &lt;a href=&quot;qaccessibleactioninterface#localizedActionDescription&quot;&gt;QAccessibleActionInterface::localizedActionDescription&lt;/a&gt;() to return their localized counterparts.</target>
        </trans-unit>
        <trans-unit id="1fd6e4c37e600fd73592fb3b27ecd0ad7ca47a17" translate="yes" xml:space="preserve">
          <source>When subclassing QItemDelegate to create a delegate that displays items using a custom renderer, it is important to ensure that the delegate can render items suitably for all the required states; e.g. selected, disabled, checked. The documentation for the &lt;a href=&quot;qitemdelegate#paint&quot;&gt;paint&lt;/a&gt;() function contains some hints to show how this can be achieved.</source>
          <target state="translated">When subclassing QItemDelegate to create a delegate that displays items using a custom renderer, it is important to ensure that the delegate can render items suitably for all the required states; e.g. selected, disabled, checked. The documentation for the &lt;a href=&quot;qitemdelegate#paint&quot;&gt;paint&lt;/a&gt;() function contains some hints to show how this can be achieved.</target>
        </trans-unit>
        <trans-unit id="9e0f5aa88b44938c261cc9eef6f6e4a41afa7675" translate="yes" xml:space="preserve">
          <source>When subclassing QListWidgetItem to provide custom items, it is possible to define new types for them enabling them to be distinguished from standard items. For subclasses that require this feature, ensure that you call the base class constructor with a new type value equal to or greater than &lt;a href=&quot;qlistwidgetitem#ItemType-enum&quot;&gt;UserType&lt;/a&gt;, within</source>
          <target state="translated">When subclassing QListWidgetItem to provide custom items, it is possible to define new types for them enabling them to be distinguished from standard items. For subclasses that require this feature, ensure that you call the base class constructor with a new type value equal to or greater than &lt;a href=&quot;qlistwidgetitem#ItemType-enum&quot;&gt;UserType&lt;/a&gt;, within</target>
        </trans-unit>
        <trans-unit id="72aca5e914ed9fefcaccb35499bea805b895d281" translate="yes" xml:space="preserve">
          <source>When subclassing QStandardItem to provide custom items, it is possible to define new types for them so that they can be distinguished from the base class. The &lt;a href=&quot;qstandarditem#type&quot;&gt;type&lt;/a&gt;() function should be reimplemented to return a new type value equal to or greater than &lt;a href=&quot;qstandarditem#ItemType-enum&quot;&gt;UserType&lt;/a&gt;.</source>
          <target state="translated">When subclassing QStandardItem to provide custom items, it is possible to define new types for them so that they can be distinguished from the base class. The &lt;a href=&quot;qstandarditem#type&quot;&gt;type&lt;/a&gt;() function should be reimplemented to return a new type value equal to or greater than &lt;a href=&quot;qstandarditem#ItemType-enum&quot;&gt;UserType&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="42b0b4032d93d4857496512b038b0674cfd26f89" translate="yes" xml:space="preserve">
          <source>When subclassing QTableWidgetItem to provide custom items, it is possible to define new types for them so that they can be distinguished from standard items. The constructors for subclasses that require this feature need to call the base class constructor with a new type value equal to or greater than &lt;a href=&quot;qtablewidgetitem#ItemType-enum&quot;&gt;UserType&lt;/a&gt;.</source>
          <target state="translated">When subclassing QTableWidgetItem to provide custom items, it is possible to define new types for them so that they can be distinguished from standard items. The constructors for subclasses that require this feature need to call the base class constructor with a new type value equal to or greater than &lt;a href=&quot;qtablewidgetitem#ItemType-enum&quot;&gt;UserType&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="3a47ebf3a47f4b0b127eba34804babe9e0cf37bc" translate="yes" xml:space="preserve">
          <source>When subclassing QTreeWidgetItem to provide custom items, it is possible to define new types for them so that they can be distinguished from standard items. The constructors for subclasses that require this feature need to call the base class constructor with a new type value equal to or greater than &lt;a href=&quot;qtreewidgetitem#ItemType-enum&quot;&gt;UserType&lt;/a&gt;.</source>
          <target state="translated">When subclassing QTreeWidgetItem to provide custom items, it is possible to define new types for them so that they can be distinguished from standard items. The constructors for subclasses that require this feature need to call the base class constructor with a new type value equal to or greater than &lt;a href=&quot;qtreewidgetitem#ItemType-enum&quot;&gt;UserType&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="706f7b1df0260af3c55347db3db3d7c9292cb895" translate="yes" xml:space="preserve">
          <source>When successful, the pointer to this &lt;a href=&quot;qvulkaninstance&quot;&gt;QVulkanInstance&lt;/a&gt; is retrievable via the static function current().</source>
          <target state="translated">成功すると、この&lt;a href=&quot;qvulkaninstance&quot;&gt;QVulkanInstance&lt;/a&gt;へのポインタは、静的関数current（）を介して取得できます。</target>
        </trans-unit>
        <trans-unit id="52f02029e2dd95fea6c58bc7c6dd438e3036694c" translate="yes" xml:space="preserve">
          <source>When successful, the returned pointer is either a direct pointer to an interface (and can be cast, for example, to &lt;code&gt;ID3D12Device *&lt;/code&gt;) or a pointer to an opaque handle that needs to be dereferenced first (for example, &lt;code&gt;VkDevice dev = *static_cast&amp;lt;VkDevice *&amp;gt;(result)&lt;/code&gt;). The latter is necessary since such handles may have sizes different from a pointer.</source>
          <target state="translated">成功した場合、返されるポインターは、インターフェイスへの直接ポインター（および、たとえば、 &lt;code&gt;ID3D12Device *&lt;/code&gt; にキャストできます）、または最初に逆参照する必要がある不透明なハンドルへのポインター（たとえば、 &lt;code&gt;VkDevice dev = *static_cast&amp;lt;VkDevice *&amp;gt;(result)&lt;/code&gt; ）。そのようなハンドルはポインタとは異なるサイズを持つ可能性があるため、後者が必要です。</target>
        </trans-unit>
        <trans-unit id="6a402a0ed822ea8251e3c7b0324b6fe2e26b6b26" translate="yes" xml:space="preserve">
          <source>When successful, the returned pointer is either a direct pointer to an interface, or a pointer to an opaque handle that needs to be dereferenced first (for example, &lt;code&gt;VkDevice dev = *static_cast&amp;lt;VkDevice *&amp;gt;(result)&lt;/code&gt;). The latter is necessary since such handles may have sizes different from a pointer.</source>
          <target state="translated">成功すると、返されるポインターは、インターフェースへの直接ポインター、または最初に逆参照する必要がある不透明なハンドルへのポインターのいずれかです（たとえば、 &lt;code&gt;VkDevice dev = *static_cast&amp;lt;VkDevice *&amp;gt;(result)&lt;/code&gt; ）。このようなハンドルはポインタとはサイズが異なる場合があるため、後者が必要です。</target>
        </trans-unit>
        <trans-unit id="a17d1a89a27b012ae83e8f31b7d65d34068e4f39" translate="yes" xml:space="preserve">
          <source>When supported by the implementation of the underlying graphics API at run time, images can also be supplied in compressed texture files. The content must be a simple RGB(A) format 2D texture. Supported compression schemes are only limited by the underlying driver and GPU. The following container file formats are supported:</source>
          <target state="translated">実行時に基礎となるグラフィックスAPIの実装がサポートしている場合、画像は圧縮されたテクスチャファイルで提供することもできます。コンテンツはシンプルな RGB(A)フォーマットの 2D テクスチャでなければなりません。サポートされている圧縮方式は、基礎となるドライバと GPU によってのみ制限されます。以下のコンテナファイル形式がサポートされています。</target>
        </trans-unit>
        <trans-unit id="b61533f5bfe4f41a281b6739619bbe40223b42c1" translate="yes" xml:space="preserve">
          <source>When supported, the spot metering point is the (normalized) position of the point of the image where exposure metering will be performed. This is typically used to indicate an &quot;interesting&quot; area of the image that should be exposed properly.</source>
          <target state="translated">サポートされている場合、スポット測光ポイントは、露出測光が実行される画像のポイントの(正規化された)位置である。これは通常、適切な露出が必要な画像の「興味深い」領域を示すために使用されます。</target>
        </trans-unit>
        <trans-unit id="ac6596f61ffb518b7cc53fdaa21ca7ddbe003ebf" translate="yes" xml:space="preserve">
          <source>When suspended, you can resume or cancel the awaiting computation:</source>
          <target state="translated">サスペンドされた場合は、計算待ちを再開またはキャンセルすることができます。</target>
        </trans-unit>
        <trans-unit id="5f88abce90e32dce271b35e9107fb601ec017c62" translate="yes" xml:space="preserve">
          <source>When switching application styles, the color palette is set back to the initial colors or the system defaults. This is necessary since certain styles have to adapt the color palette to be fully style-guide compliant.</source>
          <target state="translated">アプリケーションスタイルを切り替えるとき、カラーパレットは初期色またはシステムのデフォルトに戻されます。これは、特定のスタイルがスタイルガイドに完全に準拠するためにカラーパレットを適応させなければならないために必要です。</target>
        </trans-unit>
        <trans-unit id="67873ce37a5513b0e5ae88b75e6f033ba8bb99f4" translate="yes" xml:space="preserve">
          <source>When tabsClosable is set to true a close button will appear on the tab on either the left or right hand side depending upon the style. When the button is clicked the tab the signal &lt;a href=&quot;qtabbar#tabCloseRequested&quot;&gt;tabCloseRequested&lt;/a&gt; will be emitted.</source>
          <target state="translated">tabsClosableをtrueに設定すると、スタイルに応じて左側または右側のタブに閉じるボタンが表示されます。ボタンがクリックされると、シグナル&lt;a href=&quot;qtabbar#tabCloseRequested&quot;&gt;tabClos​​eRequested&lt;/a&gt;が発行されます。</target>
        </trans-unit>
        <trans-unit id="edd34e00a0649a39928db867a61af0bdd3698a54" translate="yes" xml:space="preserve">
          <source>When talking about version support on macOS, it's important to distinguish between the &lt;a href=&quot;#build-environment&quot;&gt;build environment&lt;/a&gt;; the platform you're building on or with, and the &lt;a href=&quot;#target-platforms&quot;&gt;target platforms&lt;/a&gt;; the platforms you are building for. The following macOS versions are supported.</source>
          <target state="translated">macOSでのバージョンサポートについて説明する場合、&lt;a href=&quot;#build-environment&quot;&gt;ビルド環境&lt;/a&gt;を区別することが重要です。ビルドしている、または一緒に使用して&lt;a href=&quot;#target-platforms&quot;&gt;いるプラットフォーム&lt;/a&gt;、およびターゲットプラットフォーム。構築するプラットフォーム。次のmacOSバージョンがサポートされています。</target>
        </trans-unit>
        <trans-unit id="46e5a0bd94336c26034fab948fd2202518bbe3a7" translate="yes" xml:space="preserve">
          <source>When talking about version support on macOS, it's important to distinguish between the &lt;a href=&quot;macos#build-environment&quot;&gt;build environment&lt;/a&gt;; the platform you're building on or with, and the &lt;a href=&quot;macos#target-platforms&quot;&gt;target platforms&lt;/a&gt;; the platforms you are building for. The following macOS versions are supported.</source>
          <target state="translated">When talking about version support on macOS, it's important to distinguish between the &lt;a href=&quot;macos#build-environment&quot;&gt;build environment&lt;/a&gt;; the platform you're building on or with, and the &lt;a href=&quot;macos#target-platforms&quot;&gt;target platforms&lt;/a&gt;; the platforms you are building for. The following macOS versions are supported.</target>
        </trans-unit>
        <trans-unit id="12b09dba91f90a77f1c0f316bc1593767614f52d" translate="yes" xml:space="preserve">
          <source>When targeting the default render target, the &lt;code&gt;rasterizationSamples&lt;/code&gt; field of &lt;code&gt;VkPipelineMultisampleStateCreateInfo&lt;/code&gt; must be set to this value.</source>
          <target state="translated">デフォルトのレンダーターゲットをターゲットにすると、 &lt;code&gt;rasterizationSamples&lt;/code&gt; のフィールド &lt;code&gt;VkPipelineMultisampleStateCreateInfo&lt;/code&gt; は、この値に設定する必要があります。</target>
        </trans-unit>
        <trans-unit id="01a0c4cf5ca0b1b36842c832e9f49ed747142008" translate="yes" xml:space="preserve">
          <source>When testing classes that change their state based on timer events, the timer-based behavior needs to be taken into account when performing verification steps. Due to the variety of timing-dependent behavior, there is no single generic solution to this testing problem.</source>
          <target state="translated">タイマーイベントに基づいて状態を変化させるクラスをテストする場合、検証ステップを実行する際には、タイマーに基づく動作を考慮に入れる必要があります。タイミングに依存する動作が多様であるため、このテスト問題に対する単一の汎用的な解決策はありません。</target>
        </trans-unit>
        <trans-unit id="977796166650ef7b381034a2e5ab66d22d9fde20" translate="yes" xml:space="preserve">
          <source>When text is selected this signal will be emitted with</source>
          <target state="translated">テキストが選択されると、この信号は</target>
        </trans-unit>
        <trans-unit id="55f3e3f1e06a97818ce0ffb33865599309fb29ae" translate="yes" xml:space="preserve">
          <source>When the</source>
          <target state="translated">になったときに</target>
        </trans-unit>
        <trans-unit id="277e96c69a29982435c9191c9b7dc60d6543c8df" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;qcombobox&quot;&gt;QComboBox&lt;/a&gt; is editable, use &lt;a href=&quot;qlineedit#placeholderText-prop&quot;&gt;QLineEdit::setPlaceholderText&lt;/a&gt;() instead.</source>
          <target state="translated">When the &lt;a href=&quot;qcombobox&quot;&gt;QComboBox&lt;/a&gt; is editable, use &lt;a href=&quot;qlineedit#placeholderText-prop&quot;&gt;QLineEdit::setPlaceholderText&lt;/a&gt;() instead.</target>
        </trans-unit>
        <trans-unit id="96148eaf4c167de1a5cc9cb151bbca87c607e4e7" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;qlogvalue3daxisformatter#base-prop&quot;&gt;base&lt;/a&gt; property value is non-zero, the whole axis range is often not equally divided into segments. The first and last segments are often smaller than the other segments. In extreme cases, this can lead to overlapping labels on the first and last two grid lines. By setting this property to &lt;code&gt;false&lt;/code&gt;, you can suppress showing the minimum and maximum labels for the axis in cases where the segments do not exactly fit the axis. Defaults to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">場合&lt;a href=&quot;qlogvalue3daxisformatter#base-prop&quot;&gt;ベース&lt;/a&gt;プロパティ値が非ゼロであり、全体の軸範囲は、多くの場合、均等にセグメントに分割されていません。多くの場合、最初と最後のセグメントは他のセグメントよりも小さくなります。極端な場合、最初と最後の2つのグリッド線でラベルが重複する可能性があります。このプロパティを &lt;code&gt;false&lt;/code&gt; に設定すると、セグメントが軸に正確に適合しない場合に、軸の最小ラベルと最大ラベルの表示を抑制できます。デフォルトは &lt;code&gt;true&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="fcebf5705064ce0455ad2b9bec751e51c083ccf2" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;qml-qt3d-render-pointsize#sizeMode-prop&quot;&gt;sizeMode&lt;/a&gt; property is set to SizeMode::Fixed, the value is set using glPointSize(), if available. When using SizeMode::Programmable, gl_PointSize must be set within shader programs, the value provided to this &lt;a href=&quot;qml-qt3d-render-renderstate&quot;&gt;RenderState&lt;/a&gt; is ignored in that case.</source>
          <target state="translated">When the &lt;a href=&quot;qml-qt3d-render-pointsize#sizeMode-prop&quot;&gt;sizeMode&lt;/a&gt; property is set to SizeMode::Fixed, the value is set using glPointSize(), if available. When using SizeMode::Programmable, gl_PointSize must be set within shader programs, the value provided to this &lt;a href=&quot;qml-qt3d-render-renderstate&quot;&gt;RenderState&lt;/a&gt; is ignored in that case.</target>
        </trans-unit>
        <trans-unit id="01c131bddcc8fa92f9f3b0a589fa47980eb2d439" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;qml-qt3d-render-pointsize#sizeMode-prop&quot;&gt;sizeMode&lt;/a&gt; property is set to SizeMode::Fixed, the value is set using glPointSize(), if available. When using SizeMode::Programmable, gl_PointSize must be set within shader programs, the value provided to this &lt;a href=&quot;qml-renderstate&quot;&gt;RenderState&lt;/a&gt; is ignored in that case.</source>
          <target state="translated">とき&lt;a href=&quot;qml-qt3d-render-pointsize#sizeMode-prop&quot;&gt;のSizeModeの&lt;/a&gt;プロパティが::のSizeModeに設定された固定されて利用可能な場合、値はglPointSize（）を使用して設定されています。SizeMode :: Programmableを使用する場合、シェーダープログラム内でgl_PointSizeを設定する必要があります。この場合、この&lt;a href=&quot;qml-renderstate&quot;&gt;RenderStateに&lt;/a&gt;提供される値は無視されます。</target>
        </trans-unit>
        <trans-unit id="31b0eaa228f2b88891ce3db774ff73a70a98110c" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;qml-qtdatavisualization-logvalueaxis3dformatter#base-prop&quot;&gt;base&lt;/a&gt; property value is non-zero, the whole axis range is often not equally divided into segments. The first and last segments are often smaller than the other segments. In extreme cases, this can lead to overlapping labels on the first and last two grid lines. By setting this property to &lt;code&gt;false&lt;/code&gt;, you can suppress showing the minimum and maximum labels for the axis in cases where the segments do not exactly fit the axis. Defaults to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">場合&lt;a href=&quot;qml-qtdatavisualization-logvalueaxis3dformatter#base-prop&quot;&gt;ベース&lt;/a&gt;プロパティ値が非ゼロであり、全体の軸範囲は、多くの場合、均等にセグメントに分割されていません。多くの場合、最初と最後のセグメントは他のセグメントよりも小さくなります。極端な場合、最初と最後の2つのグリッド線でラベルが重複する可能性があります。このプロパティを &lt;code&gt;false&lt;/code&gt; に設定すると、セグメントが軸に正確に適合しない場合に、軸の最小ラベルと最大ラベルの表示を抑制できます。デフォルトは &lt;code&gt;true&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="987fec2f0c2c258849a742c9e14f0174fef55ec2" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;qml-qtpositioning-positionsource&quot;&gt;PositionSource&lt;/a&gt; is active, position updates can be retrieved either by simply using the &lt;a href=&quot;qml-qtpositioning-positionsource#position-prop&quot;&gt;position&lt;/a&gt; property in a binding (as the value of another item's property), or by providing an implementation of the &lt;code&gt;onPositionChanged&lt;/code&gt; signal-handler.</source>
          <target state="translated">場合&lt;a href=&quot;qml-qtpositioning-positionsource&quot;&gt;PositionSourceが&lt;/a&gt;アクティブであり、位置の更新は、単に使用することによってのいずれかで取得することができる&lt;a href=&quot;qml-qtpositioning-positionsource#position-prop&quot;&gt;位置&lt;/a&gt;（別のアイテムのプロパティの値として）、または実装提供することにより、結合にプロパティを &lt;code&gt;onPositionChanged&lt;/code&gt; シグナルハンドラ。</target>
        </trans-unit>
        <trans-unit id="d6b06a8b392f311abc92743e16b8eaf852385858" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;qml-qtquick-controls-stackview&quot;&gt;StackView&lt;/a&gt; needs a new transition, it first calls &lt;a href=&quot;qml-qtquick-controls-stackviewdelegate#getTransition-method&quot;&gt;StackViewDelegate.getTransition()&lt;/a&gt;. The base implementation of this function just looks for a property named &lt;code&gt;properties.name&lt;/code&gt; inside itself (root), which is how it finds &lt;code&gt;property Component pushTransition&lt;/code&gt; in the examples above.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-controls-stackview&quot;&gt;StackView&lt;/a&gt;が新しい遷移を必要とする場合、最初に&lt;a href=&quot;qml-qtquick-controls-stackviewdelegate#getTransition-method&quot;&gt;StackViewDelegate.getTransition（）を&lt;/a&gt;呼び出します。この関数の基本実装は、それ自体（ルート）内で &lt;code&gt;properties.name&lt;/code&gt; という名前のプロパティを探し &lt;code&gt;property Component pushTransition&lt;/code&gt; 。これは、上記の例でプロパティComponent pushTransitionを見つける方法です。</target>
        </trans-unit>
        <trans-unit id="13b2463be39cc72e16c7d4ca58b0c4d0edaade26" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;qml-qtquick-flickable#boundsMovement-prop&quot;&gt;boundsMovement&lt;/a&gt; is &lt;code&gt;Flickable.FollowBoundsBehavior&lt;/code&gt;, a value other than &lt;code&gt;Flickable.StopAtBounds&lt;/code&gt; will give a feeling that the edges of the view are soft, rather than a hard physical boundary.</source>
          <target state="translated">とき&lt;a href=&quot;qml-qtquick-flickable#boundsMovement-prop&quot;&gt;boundsMovementは&lt;/a&gt;ある &lt;code&gt;Flickable.FollowBoundsBehavior&lt;/code&gt; 、以外の値 &lt;code&gt;Flickable.StopAtBounds&lt;/code&gt; かなりハード物理的境界よりも、ビューのエッジがソフトであることを感じを与えます。</target>
        </trans-unit>
        <trans-unit id="bdd086e0b6a8d49e2b2713bf9ea24b942d740d18" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;qml-qtquick-mousearea&quot;&gt;MouseArea&lt;/a&gt; is clicked, &lt;code&gt;fruitModel&lt;/code&gt; will have two roles,</source>
          <target state="translated">とき&lt;a href=&quot;qml-qtquick-mousearea&quot;&gt;MouseAreaを&lt;/a&gt;クリックすると、 &lt;code&gt;fruitModel&lt;/code&gt; は、2つの役割があります</target>
        </trans-unit>
        <trans-unit id="531648fe487a96145ce0801a6bc88b47ddc3d5fa" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;qml-qtquick-text&quot;&gt;Text&lt;/a&gt; object refers to its &lt;a href=&quot;qml-qtquick-item#parent-prop&quot;&gt;parent&lt;/a&gt; value in the above code, it is referring to its</source>
          <target state="translated">場合&lt;a href=&quot;qml-qtquick-text&quot;&gt;テキスト&lt;/a&gt;オブジェクトが指す&lt;a href=&quot;qml-qtquick-item#parent-prop&quot;&gt;親&lt;/a&gt;上記のコードの値は、その参照しています</target>
        </trans-unit>
        <trans-unit id="cfbd43c514e575cbd44c06a9f1befeb8fbc6aa47" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;qml-qtquick-virtualkeyboard-keyboardlayoutloader&quot;&gt;KeyboardLayoutLoader&lt;/a&gt; is used as a root item of a keyboard layout, the actual keyboard layouts are wrapped inside Component elements. The keyboard layout is activated by assigning the id of an active component to the sourceComponent property.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-virtualkeyboard-keyboardlayoutloader&quot;&gt;KeyboardLayoutLoader&lt;/a&gt;がキーボードレイアウトのルート項目として使用される場合、実際のキーボードレイアウトはComponent要素内にラップされます。キーボードレイアウトをアクティブにするには、アクティブなコンポーネントのIDをsourceComponentプロパティに割り当てます。</target>
        </trans-unit>
        <trans-unit id="f043241c3f7cc581207444dcc1dc86dbdeb3ef7b" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;qpushbutton&quot;&gt;QPushButton&lt;/a&gt; is clicked, the console prints,</source>
          <target state="translated">とき&lt;a href=&quot;qpushbutton&quot;&gt;のQPushButtonは&lt;/a&gt;、コンソールのプリントをクリックすると、</target>
        </trans-unit>
        <trans-unit id="d450f4ff62c8dd3eda6ad3d118faffcc34e07662" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;qqmlengine&quot;&gt;QQmlEngine&lt;/a&gt; instantiates a &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt;, the context is set automatically.</source>
          <target state="translated">とき&lt;a href=&quot;qqmlengine&quot;&gt;QQmlEngineが&lt;/a&gt;インスタンス化&lt;a href=&quot;qobject&quot;&gt;にQObjectを&lt;/a&gt;、コンテキストが自動的に設定されています。</target>
        </trans-unit>
        <trans-unit id="1a3ec88b091fae5c593926fbff02a507863cf15b" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;qsensor#axesOrientationMode-prop&quot;&gt;axesOrientationMode&lt;/a&gt; property is set to &lt;a href=&quot;qsensor#AxesOrientationMode-enum&quot;&gt;UserOrientation&lt;/a&gt;, the angle for rotating the reading values is taken from this property. In other modes, the property has no effect.</source>
          <target state="translated">場合&lt;a href=&quot;qsensor#axesOrientationMode-prop&quot;&gt;axesOrientationModeの&lt;/a&gt;プロパティに設定されている&lt;a href=&quot;qsensor#AxesOrientationMode-enum&quot;&gt;UserOrientation&lt;/a&gt;、読み取り値を回転させる角度は、このプロパティから取り出されます。他のモードでは、プロパティは効果がありません。</target>
        </trans-unit>
        <trans-unit id="f8b6764b784c8d16407b8358832df499fd592a45" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;qsgmaterial&quot;&gt;QSGMaterial&lt;/a&gt; reports &lt;a href=&quot;qsgmaterial#Flag-enum&quot;&gt;SupportsRhiShader&lt;/a&gt; in &lt;a href=&quot;qsgmaterial#flags&quot;&gt;flags&lt;/a&gt;(), the scene graph may request a &lt;a href=&quot;qsgmaterialrhishader&quot;&gt;QSGMaterialRhiShader&lt;/a&gt; instead of &lt;a href=&quot;qsgmaterialshader&quot;&gt;QSGMaterialShader&lt;/a&gt;. This is indicated by having the &lt;a href=&quot;qsgmaterial#Flag-enum&quot;&gt;RhiShaderWanted&lt;/a&gt; flag set. In this case the return value must be a QSGRhiMaterialShader subclass.</source>
          <target state="translated">When the &lt;a href=&quot;qsgmaterial&quot;&gt;QSGMaterial&lt;/a&gt; reports &lt;a href=&quot;qsgmaterial#Flag-enum&quot;&gt;SupportsRhiShader&lt;/a&gt; in &lt;a href=&quot;qsgmaterial#flags&quot;&gt;flags&lt;/a&gt;(), the scene graph may request a &lt;a href=&quot;qsgmaterialrhishader&quot;&gt;QSGMaterialRhiShader&lt;/a&gt; instead of &lt;a href=&quot;qsgmaterialshader&quot;&gt;QSGMaterialShader&lt;/a&gt;. This is indicated by having the &lt;a href=&quot;qsgmaterial#Flag-enum&quot;&gt;RhiShaderWanted&lt;/a&gt; flag set. In this case the return value must be a QSGRhiMaterialShader subclass.</target>
        </trans-unit>
        <trans-unit id="3ec06e7607af8f8760e7b965130ca0af1c7c4afa" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;qt#PenJoinStyle-enum&quot;&gt;Qt::MiterJoin&lt;/a&gt; style is applied, it is possible to use the &lt;a href=&quot;qpen#setMiterLimit&quot;&gt;setMiterLimit&lt;/a&gt;() function to specify how far the miter join can extend from the join point. The &lt;a href=&quot;qpen#miterLimit&quot;&gt;miterLimit&lt;/a&gt;() is used to reduce artifacts between line joins where the lines are close to parallel.</source>
          <target state="translated">とき&lt;a href=&quot;qt#PenJoinStyle-enum&quot;&gt;はQt :: MiterJoinの&lt;/a&gt;スタイルが適用され、それを使用することが可能である&lt;a href=&quot;qpen#setMiterLimit&quot;&gt;setMiterLimit&lt;/a&gt;マイター結合どれだけ指定する（）関数を拡張することができますから、ポイントに参加。&lt;a href=&quot;qpen#miterLimit&quot;&gt;miterLimitのは&lt;/a&gt;（）ラインが平行に近いライン間アーチファクトジョインを低減するために使用されます。</target>
        </trans-unit>
        <trans-unit id="8cff9e77f59469425f8797ff7538a94cb9830def" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;qt3drender-qpointsize#sizeMode-prop&quot;&gt;sizeMode&lt;/a&gt; property is set to SizeMode::Fixed, the value is set using glPointSize(), if available. When using SizeMode::Programmable, gl_PointSize must be set within shader programs, the value provided to this &lt;a href=&quot;qml-qt3d-render-renderstate&quot;&gt;RenderState&lt;/a&gt; is ignored in that case.</source>
          <target state="translated">When the &lt;a href=&quot;qt3drender-qpointsize#sizeMode-prop&quot;&gt;sizeMode&lt;/a&gt; property is set to SizeMode::Fixed, the value is set using glPointSize(), if available. When using SizeMode::Programmable, gl_PointSize must be set within shader programs, the value provided to this &lt;a href=&quot;qml-qt3d-render-renderstate&quot;&gt;RenderState&lt;/a&gt; is ignored in that case.</target>
        </trans-unit>
        <trans-unit id="8109269e175dc39675b846ed563d3f286803d82a" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;qt3drender-qpointsize#sizeMode-prop&quot;&gt;sizeMode&lt;/a&gt; property is set to SizeMode::Fixed, the value is set using glPointSize(), if available. When using SizeMode::Programmable, gl_PointSize must be set within shader programs, the value provided to this &lt;a href=&quot;qml-renderstate&quot;&gt;RenderState&lt;/a&gt; is ignored in that case.</source>
          <target state="translated">とき&lt;a href=&quot;qt3drender-qpointsize#sizeMode-prop&quot;&gt;のSizeModeの&lt;/a&gt;プロパティが::のSizeModeに設定された固定されて利用可能な場合、値はglPointSize（）を使用して設定されています。SizeMode :: Programmableを使用する場合、シェーダープログラム内でgl_PointSizeを設定する必要があります。この場合、この&lt;a href=&quot;qml-renderstate&quot;&gt;RenderStateに&lt;/a&gt;提供される値は無視されます。</target>
        </trans-unit>
        <trans-unit id="ef51d747b8fb0e1aaf24623fb2724ee2f97056ec" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;qtoolbutton&quot;&gt;QToolButton&lt;/a&gt; displays arrows, the &lt;a href=&quot;#up-arrow-sub&quot;&gt;::up-arrow&lt;/a&gt;, &lt;a href=&quot;#down-arrow-sub&quot;&gt;::down-arrow&lt;/a&gt;, &lt;a href=&quot;#left-arrow-sub&quot;&gt;::left-arrow&lt;/a&gt; and &lt;a href=&quot;#right-arrow-sub&quot;&gt;::right-arrow&lt;/a&gt; subcontrols are used.</source>
          <target state="translated">&lt;a href=&quot;qtoolbutton&quot;&gt;QToolButton&lt;/a&gt;が矢印を表示するとき、&lt;a href=&quot;#up-arrow-sub&quot;&gt;:: up-arrow&lt;/a&gt;、&lt;a href=&quot;#down-arrow-sub&quot;&gt;:: down-arrow&lt;/a&gt;、&lt;a href=&quot;#left-arrow-sub&quot;&gt;:: left-arrow&lt;/a&gt;および&lt;a href=&quot;#right-arrow-sub&quot;&gt;:: right-arrow&lt;/a&gt;サブコントロールが使用されます。</target>
        </trans-unit>
        <trans-unit id="233835321d7949264542584e5872cf0f2ee5c9ad" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;qtoolbutton&quot;&gt;QToolButton&lt;/a&gt; displays arrows, the &lt;a href=&quot;stylesheet-reference#up-arrow-sub&quot;&gt;::up-arrow&lt;/a&gt;, &lt;a href=&quot;stylesheet-reference#down-arrow-sub&quot;&gt;::down-arrow&lt;/a&gt;, &lt;a href=&quot;stylesheet-reference#left-arrow-sub&quot;&gt;::left-arrow&lt;/a&gt; and &lt;a href=&quot;stylesheet-reference#right-arrow-sub&quot;&gt;::right-arrow&lt;/a&gt; subcontrols are used.</source>
          <target state="translated">When the &lt;a href=&quot;qtoolbutton&quot;&gt;QToolButton&lt;/a&gt; displays arrows, the &lt;a href=&quot;stylesheet-reference#up-arrow-sub&quot;&gt;::up-arrow&lt;/a&gt;, &lt;a href=&quot;stylesheet-reference#down-arrow-sub&quot;&gt;::down-arrow&lt;/a&gt;, &lt;a href=&quot;stylesheet-reference#left-arrow-sub&quot;&gt;::left-arrow&lt;/a&gt; and &lt;a href=&quot;stylesheet-reference#right-arrow-sub&quot;&gt;::right-arrow&lt;/a&gt; subcontrols are used.</target>
        </trans-unit>
        <trans-unit id="a51ead804c63868aa6b0c7c0b5911080ee61da02" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;widgets-changes-qt6#qcombobox&quot;&gt;QComboBox&lt;/a&gt; is editable, use &lt;a href=&quot;qlineedit#placeholderText-prop&quot;&gt;QLineEdit::setPlaceholderText&lt;/a&gt;() instead.</source>
          <target state="translated">&lt;a href=&quot;widgets-changes-qt6#qcombobox&quot;&gt;QComboBox&lt;/a&gt;が編集可能な場合は、代わりに&lt;a href=&quot;qlineedit#placeholderText-prop&quot;&gt;QLineEdit :: setPlaceholderText&lt;/a&gt;（）を使用してください。</target>
        </trans-unit>
        <trans-unit id="a1a6fb9f01b0846bb260ddb329a9c95bfca49b3e" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;subdirs&lt;/code&gt; template is used, qmake generates a Makefile to examine each specified subdirectory, process any project file it finds there, and run the platform's &lt;code&gt;make&lt;/code&gt; tool on the newly-created Makefile. The &lt;code&gt;SUBDIRS&lt;/code&gt; variable is used to contain a list of all the subdirectories to be processed.</source>
          <target state="translated">ときに &lt;code&gt;subdirs&lt;/code&gt; テンプレートが使用され、qmakeのは、指定された各サブディレクトリを調べ、それが見つかったプロジェクトファイルを処理し、プラットフォームの実行にMakefileを生成 &lt;code&gt;make&lt;/code&gt; 新しく作成されたMakefileでツールを。 &lt;code&gt;SUBDIRS&lt;/code&gt; の変数を処理するすべてのサブディレクトリのリストを格納するために使用されます。</target>
        </trans-unit>
        <trans-unit id="5b64d4e10455a073c6c16a2676284bd8b55dc704" translate="yes" xml:space="preserve">
          <source>When the KMS/DRM backend is in use, EGLFS reports all available screens in &lt;a href=&quot;qguiapplication#screens&quot;&gt;QGuiApplication::screens&lt;/a&gt;(). Applications can target different screens with different windows via &lt;a href=&quot;qwindow#setScreen&quot;&gt;QWindow::setScreen&lt;/a&gt;().</source>
          <target state="translated">When the KMS/DRM backend is in use, EGLFS reports all available screens in &lt;a href=&quot;qguiapplication#screens&quot;&gt;QGuiApplication::screens&lt;/a&gt;(). Applications can target different screens with different windows via &lt;a href=&quot;qwindow#setScreen&quot;&gt;QWindow::setScreen&lt;/a&gt;().</target>
        </trans-unit>
        <trans-unit id="13cb608250173ac51a45d65525231f711e5ba267" translate="yes" xml:space="preserve">
          <source>When the KMS/DRM backend is in use, eglfs reports all available screens in &lt;a href=&quot;qguiapplication#screens&quot;&gt;QGuiApplication::screens&lt;/a&gt;(). Applications can target different screens with different windows via &lt;a href=&quot;qwindow#setScreen&quot;&gt;QWindow::setScreen&lt;/a&gt;().</source>
          <target state="translated">KMS / DRMバックエンドが使用されている場合、eglfsは&lt;a href=&quot;qguiapplication#screens&quot;&gt;QGuiApplication :: screens&lt;/a&gt;（）で利用可能なすべての画面を報告します。アプリケーションは、&lt;a href=&quot;qwindow#setScreen&quot;&gt;QWindow :: setScreen&lt;/a&gt;（）を介して、さまざまなウィンドウでさまざまな画面をターゲットにすることができます。</target>
        </trans-unit>
        <trans-unit id="e9c697bf2c44fd91eecd755192f28a6e88860c7e" translate="yes" xml:space="preserve">
          <source>When the PositionSource is active, position updates can be retrieved either by simply using the &lt;a href=&quot;qml-qtpositioning-positionsource#position-prop&quot;&gt;position&lt;/a&gt; property in a binding (as the value of another item's property), or by providing an implementation of the &lt;code&gt;onPositionChanged&lt;/code&gt; signal-handler.</source>
          <target state="translated">When the PositionSource is active, position updates can be retrieved either by simply using the &lt;a href=&quot;qml-qtpositioning-positionsource#position-prop&quot;&gt;position&lt;/a&gt; property in a binding (as the value of another item's property), or by providing an implementation of the &lt;code&gt;onPositionChanged&lt;/code&gt; signal-handler.</target>
        </trans-unit>
        <trans-unit id="590e6b713b7124a325673c8560f716815fb45204" translate="yes" xml:space="preserve">
          <source>When the QML engine encounters a use of &lt;code&gt;RandomNumberGenerator&lt;/code&gt; as a property value source, it invokes &lt;code&gt;RandomNumberGenerator::setTarget()&lt;/code&gt; to provide the type with the property to which the value source has been applied. When the internal timer in &lt;code&gt;RandomNumberGenerator&lt;/code&gt; triggers every 500 milliseconds, it will write a new number value to that specified property.</source>
          <target state="translated">QMLエンジンは、プロパティ値のソースとして &lt;code&gt;RandomNumberGenerator&lt;/code&gt; の使用を検出すると、 &lt;code&gt;RandomNumberGenerator::setTarget()&lt;/code&gt; を呼び出して、値のソースが適用されているプロパティを備えた型を提供します。 &lt;code&gt;RandomNumberGenerator&lt;/code&gt; の内部タイマーが500ミリ秒ごとにトリガーすると、指定したプロパティに新しい数値が書き込まれます。</target>
        </trans-unit>
        <trans-unit id="55bdd73045f54c63cca63284c91153ecc1e0e57c" translate="yes" xml:space="preserve">
          <source>When the QML engine processes this code, it creates a single instance of the</source>
          <target state="translated">QML エンジンがこのコードを処理する際には</target>
        </trans-unit>
        <trans-unit id="2200e5bee9d5bde2ef75b92345abdbbd47de48d7" translate="yes" xml:space="preserve">
          <source>When the Space key is pressed, the &lt;a href=&quot;qml-qtquick-item#visible-prop&quot;&gt;visible&lt;/a&gt; value of the green &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle&lt;/a&gt; is toggled. As it appears and disappears, the blue &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle&lt;/a&gt; moves within the Column, and the &lt;a href=&quot;qml-qtquick-column#move-prop&quot;&gt;move&lt;/a&gt; transition is automatically applied to the blue &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle&lt;/a&gt;:</source>
          <target state="translated">Spaceキーを押すと、緑色の&lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;長方形の&lt;/a&gt;&lt;a href=&quot;qml-qtquick-item#visible-prop&quot;&gt;表示&lt;/a&gt;値が切り替わります。表示されたり消えたりすると、青い&lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;四角形&lt;/a&gt;が列内で移動し、&lt;a href=&quot;qml-qtquick-column#move-prop&quot;&gt;移動&lt;/a&gt;遷移が青い&lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;四角形に&lt;/a&gt;自動的に適用されます。</target>
        </trans-unit>
        <trans-unit id="9c6490ecb547781d0dc7402f03b49e5ff063c783" translate="yes" xml:space="preserve">
          <source>When the StackView needs a new transition, it first calls &lt;a href=&quot;qml-qtquick-controls-stackviewdelegate#getTransition-method&quot;&gt;StackViewDelegate.getTransition()&lt;/a&gt;. The base implementation of this function just looks for a property named &lt;code&gt;properties.name&lt;/code&gt; inside itself (root), which is how it finds &lt;code&gt;property Component pushTransition&lt;/code&gt; in the examples above.</source>
          <target state="translated">When the StackView needs a new transition, it first calls &lt;a href=&quot;qml-qtquick-controls-stackviewdelegate#getTransition-method&quot;&gt;StackViewDelegate.getTransition()&lt;/a&gt;. The base implementation of this function just looks for a property named &lt;code&gt;properties.name&lt;/code&gt; inside itself (root), which is how it finds &lt;code&gt;property Component pushTransition&lt;/code&gt; in the examples above.</target>
        </trans-unit>
        <trans-unit id="6a3ce649d4099a8096022c6c669c9176b6fc57ee" translate="yes" xml:space="preserve">
          <source>When the \brief command is used to describe a class, we recommend using a complete sentence like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="557b6338e75a33d13fe088abb975f18a855ab911" translate="yes" xml:space="preserve">
          <source>When the \brief command is used to describe a property or a variable, the brief text must be a sentence fragment starting with &quot;whether&quot; (for a boolean property or variable) or starting with &quot;the&quot; (for any other property or variable).</source>
          <target state="translated">\briefコマンドがプロパティまたは変数を記述するために使用される場合、簡潔なテキストは、&quot;whoice &quot;で始まる文の断片でなければならない(ブーリアンプロパティまたは変数の場合)、または &quot;the &quot;で始まる文の断片でなければならない(他のプロパティまたは変数の場合)。</target>
        </trans-unit>
        <trans-unit id="68de879942c076ccf49dec3b35482feaabb2b36a" translate="yes" xml:space="preserve">
          <source>When the above view is flicked beyond its bounds, it will return to its bounds using the transition specified:</source>
          <target state="translated">上記のビューがその境界を越えてフリックされた場合、指定されたトランジションを使用してその境界に戻ります。</target>
        </trans-unit>
        <trans-unit id="589227a0f3172c2f19894c29348f6198f079bcbc" translate="yes" xml:space="preserve">
          <source>When the active subwindow is maximized, the default behavior is to maximize the next subwindow that is activated. Set this option if you do not want this behavior.</source>
          <target state="translated">アクティブなサブウィンドウが最大化されると、デフォルトの動作はアクティブになっている次のサブウィンドウを最大化することになります。この動作をしたくない場合は、このオプションを設定します。</target>
        </trans-unit>
        <trans-unit id="ab36dbc74560565de3f4f93285f3477fd906523a" translate="yes" xml:space="preserve">
          <source>When the allowed &lt;a href=&quot;qdatetimeedit#setDateTimeRange&quot;&gt;range&lt;/a&gt; is narrower than some time interval whose end it straddles, keyboard tracking prevents the user editing the date or time to access the later part of the interval. For example, for a range from 29.04.2020 to 02.05.2020 and an initial date of 30.04.2020, the user can change neither the month (May 30th is outside the range) nor the day (April 2nd is outside the range).</source>
          <target state="translated">When the allowed &lt;a href=&quot;qdatetimeedit#setDateTimeRange&quot;&gt;range&lt;/a&gt; is narrower than some time interval whose end it straddles, keyboard tracking prevents the user editing the date or time to access the later part of the interval. For example, for a range from 29.04.2020 to 02.05.2020 and an initial date of 30.04.2020, the user can change neither the month (May 30th is outside the range) nor the day (April 2nd is outside the range).</target>
        </trans-unit>
        <trans-unit id="5a7ce62c114b1cc52094be5a1851abc5fc7f2e64" translate="yes" xml:space="preserve">
          <source>When the alpha channel is enabled either via &lt;a href=&quot;qquickwindow#setDefaultAlphaBuffer&quot;&gt;QQuickWindow::setDefaultAlphaBuffer&lt;/a&gt;() or by setting alphaBufferSize to a non-zero value in the window's &lt;a href=&quot;qsurfaceformat&quot;&gt;QSurfaceFormat&lt;/a&gt; or in the global format managed by &lt;a href=&quot;qsurfaceformat#setDefaultFormat&quot;&gt;QSurfaceFormat::setDefaultFormat&lt;/a&gt;(), the D3D12 backend will create a swapchain for composition and go through DirectComposition. This is necessary, because the mandatory flip model swapchain wouldn't support transparency otherwise.</source>
          <target state="translated">&lt;a href=&quot;qquickwindow#setDefaultAlphaBuffer&quot;&gt;QQuickWindow :: setDefaultAlphaBuffer&lt;/a&gt;（）を介して、またはウィンドウの&lt;a href=&quot;qsurfaceformat&quot;&gt;QSurfaceFormat&lt;/a&gt;または&lt;a href=&quot;qsurfaceformat#setDefaultFormat&quot;&gt;QSurfaceFormat :: setDefaultFormat&lt;/a&gt;（）によって管理されるグローバルフォーマットでalphaBufferSizeをゼロ以外の値に設定してアルファチャネルを有効にすると、D3D12バックエンドは構成し、DirectCompositionを実行します。必須のフリップモデルスワップチェーンは透明性をサポートしないため、これは必要です。</target>
        </trans-unit>
        <trans-unit id="9a1e6809f3ea75f0ed2e58d51575459791e1afbc" translate="yes" xml:space="preserve">
          <source>When the animation finishes it returns to the initial frame. This is the default behavior.</source>
          <target state="translated">アニメーションが終了すると、最初のフレームに戻ります。これがデフォルトの動作です。</target>
        </trans-unit>
        <trans-unit id="c2c6e776224aaea188a4e49fe2b71d9eeacafa46" translate="yes" xml:space="preserve">
          <source>When the animation finishes it stays on the final frame.</source>
          <target state="translated">アニメーションが終了すると、最終フレームのままになります。</target>
        </trans-unit>
        <trans-unit id="abead2ff8ba68473ab0f073d1c6b50c8ad980ea5" translate="yes" xml:space="preserve">
          <source>When the application is running with the generic, triangulation-based Shape implementation, the geometry generation happens entirely on the CPU. This is potentially expensive. Changing the set of path elements, changing the properties of these elements, or changing certain properties of the Shape itself all lead to retriangulation of the affected paths on every change. Therefore, applying animation to such properties can affect performance on less powerful systems.</source>
          <target state="translated">アプリケーションが一般的な三角測量ベースのシェイプ実装で実行されている場合、ジオメトリの生成はすべてCPU上で行われます。これにはコストがかかる可能性があります。パス要素のセットを変更したり、それらの要素のプロパティを変更したり、シェイプ自体の特定のプロパティを変更したりすると、変更のたびに影響を受けるパスの再三角化が発生します。そのため、このようなプロパティにアニメーションを適用すると、パワーの低いシステムではパフォーマンスに影響を与える可能性があります。</target>
        </trans-unit>
        <trans-unit id="2dc59efa2f06087183eee0fb11a7e9582ff61062" translate="yes" xml:space="preserve">
          <source>When the application is running, an IDE or a tool that implements the binary protocol can connect to the open port.</source>
          <target state="translated">アプリケーションが起動している場合、IDEやバイナリプロトコルを実装したツールがオープンポートに接続することができます。</target>
        </trans-unit>
        <trans-unit id="c469e679911aae260b7551ead885271015ff56e7" translate="yes" xml:space="preserve">
          <source>When the application is started it has to register an message handler with &lt;a href=&quot;qnearfieldmanager#registerNdefMessageHandler&quot;&gt;registerNdefMessageHandler()&lt;/a&gt; The first NDEF message arriving in the handler is the message that started the application. See the &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtnfc-corkboard-example.html#&quot;&gt;CorkBoard&lt;/a&gt; application for an example.</source>
          <target state="translated">アプリケーションが起動すると、&lt;a href=&quot;qnearfieldmanager#registerNdefMessageHandler&quot;&gt;registerNdefMessageHandler（）を&lt;/a&gt;使用してメッセージハンドラーを登録する必要があります。ハンドラーに到着する最初のNDEFメッセージは、アプリケーションを起動したメッセージです。例については、&lt;a href=&quot;https://doc.qt.io/qt-5.13/qtnfc-corkboard-example.html#&quot;&gt;CorkBoard&lt;/a&gt;アプリケーションを参照してください。</target>
        </trans-unit>
        <trans-unit id="bf9811db4bca65a70c4bf17f4e8c83205ce8fbdb" translate="yes" xml:space="preserve">
          <source>When the application is started it has to register an message handler with &lt;a href=&quot;qnearfieldmanager#registerNdefMessageHandler&quot;&gt;registerNdefMessageHandler()&lt;/a&gt; The first NDEF message arriving in the handler is the message that started the application. See the &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtnfc-corkboard-example.html&quot;&gt;CorkBoard&lt;/a&gt; application for an example.</source>
          <target state="translated">When the application is started it has to register an message handler with &lt;a href=&quot;qnearfieldmanager#registerNdefMessageHandler&quot;&gt;registerNdefMessageHandler()&lt;/a&gt; The first NDEF message arriving in the handler is the message that started the application. See the &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtnfc-corkboard-example.html&quot;&gt;CorkBoard&lt;/a&gt; application for an example.</target>
        </trans-unit>
        <trans-unit id="50a549dc65fe725b80a97de046a5a0dc3b6c6fb6" translate="yes" xml:space="preserve">
          <source>When the binding becomes inactive again, any direct bindings that were previously set on the property will be restored.</source>
          <target state="translated">バインディングが再び非アクティブになると、以前にプロパティに設定されていたダイレクトバインディングはすべて復元されます。</target>
        </trans-unit>
        <trans-unit id="9392393f9bb1d7b61b1f25e10ec17290326feeb8" translate="yes" xml:space="preserve">
          <source>When the built-in, default graphics adaptation is used,</source>
          <target state="translated">ビルトインの場合は、デフォルトのグラフィック適応が使用されます。</target>
        </trans-unit>
        <trans-unit id="447dd45f7b45ede6829150c673fe906621c3daff" translate="yes" xml:space="preserve">
          <source>When the button is clicked, the purchase process is started. At some point in the future, either the &lt;a href=&quot;qml-qtpurchasing-product#onPurchaseFailed-signal&quot;&gt;onPurchaseFailed&lt;/a&gt; handler will be called (for example if the user cancels the transaction), or the &lt;a href=&quot;qml-qtpurchasing-product#onPurchaseSucceeded-signal&quot;&gt;onPurchaseSucceeded&lt;/a&gt; handler will be called.</source>
          <target state="translated">ボタンをクリックすると、購入プロセスが開始されます。将来のある時点で、&lt;a href=&quot;qml-qtpurchasing-product#onPurchaseFailed-signal&quot;&gt;onPurchaseFailed&lt;/a&gt;ハンドラーが呼び出されるか（ユーザーがトランザクションをキャンセルした場合など）、または&lt;a href=&quot;qml-qtpurchasing-product#onPurchaseSucceeded-signal&quot;&gt;onPurchaseSucceeded&lt;/a&gt;ハンドラーが呼び出されます。</target>
        </trans-unit>
        <trans-unit id="4ebbf8f547dd292e8432493d1f5c0d39a31ffd9b" translate="yes" xml:space="preserve">
          <source>When the client is connected successfully, we connect to the `onTextMessageReceived()` signal, and send out &quot;Hello, world!&quot;. If connected with the EchoServer, we will receive the same message back.</source>
          <target state="translated">クライアントとの接続に成功したら、`onTextMessageReceived()`シグナルに接続して「Hello,world! EchoServerと接続した場合は、同じメッセージが返ってくる。</target>
        </trans-unit>
        <trans-unit id="5d66decd4409859b0e6cc5ba70ca923d5222b329" translate="yes" xml:space="preserve">
          <source>When the connection to the &lt;a href=&quot;qtremoteobjects-source#source&quot;&gt;Source&lt;/a&gt; object is made, the initialization step passes the current property values (see &lt;a href=&quot;qtremoteobjects-replica#replica-initialization&quot;&gt;Replica Initialization&lt;/a&gt;). In a DynamicReplica, the property/signal/slot details are also sent, allowing the replica object to be created on-the-fly. This can be conventient in QML or scripting, but has two primary disadvantages. First, the object is in effect &quot;empty&quot; until it is successfully initialized by the &lt;a href=&quot;qtremoteobjects-source#source&quot;&gt;Source&lt;/a&gt;. Second, in C++, calls must be made using &lt;a href=&quot;qmetaobject#invokeMethod&quot;&gt;QMetaObject::invokeMethod&lt;/a&gt;(), as the moc generated lookup will not be available.</source>
          <target state="translated">&lt;a href=&quot;qtremoteobjects-source#source&quot;&gt;Source&lt;/a&gt;オブジェクトへの接続が行われると、初期化ステップは現在のプロパティ値を渡します（&lt;a href=&quot;qtremoteobjects-replica#replica-initialization&quot;&gt;レプリカの初期化を&lt;/a&gt;参照）。 DynamicReplicaでは、プロパティ/信号/スロットの詳細も送信されるため、レプリカオブジェクトをその場で作成できます。これはQMLまたはスクリプトで便利な場合がありますが、主な欠点が2つあります。まず、オブジェクトは、&lt;a href=&quot;qtremoteobjects-source#source&quot;&gt;Source&lt;/a&gt;によって正常に初期化されるまで、実質的に「空」です。次に、C ++では、mocで生成されたルックアップを使用できないため、&lt;a href=&quot;qmetaobject#invokeMethod&quot;&gt;QMetaObject :: invokeMethod&lt;/a&gt;（）を使用して呼び出しを行う必要があります。</target>
        </trans-unit>
        <trans-unit id="08ec6e33eebed26c7c57c8ed22fb0ac60abd982e" translate="yes" xml:space="preserve">
          <source>When the content is changed using any of these functions, any previous content is cleared.</source>
          <target state="translated">これらの機能を使用してコンテンツを変更すると、それまでのコンテンツはクリアされます。</target>
        </trans-unit>
        <trans-unit id="098eff2cee4bb06ded290defca5ca43aedeb73b3" translate="yes" xml:space="preserve">
          <source>When the current element is a map, you may also call &lt;a href=&quot;qcborstreamreader#isLengthKnown&quot;&gt;isLengthKnown&lt;/a&gt;() to find out if the map's size is explicit in the CBOR stream. If it is, that size can be obtained by calling &lt;a href=&quot;qcborstreamreader#length&quot;&gt;length&lt;/a&gt;().</source>
          <target state="translated">現在の要素がマップの場合は、&lt;a href=&quot;qcborstreamreader#isLengthKnown&quot;&gt;isLengthKnown&lt;/a&gt;（）を呼び出して、CBORストリームでマップのサイズが明示的かどうかを確認することもできます。もしそうなら、そのサイズは&lt;a href=&quot;qcborstreamreader#length&quot;&gt;length&lt;/a&gt;（）を呼び出すことで取得できます。</target>
        </trans-unit>
        <trans-unit id="bea6a9143e97cc060ee75f79678b23a7773047e8" translate="yes" xml:space="preserve">
          <source>When the current element is an array, you may also call &lt;a href=&quot;qcborstreamreader#isLengthKnown&quot;&gt;isLengthKnown&lt;/a&gt;() to find out if the array's size is explicit in the CBOR stream. If it is, that size can be obtained by calling &lt;a href=&quot;qcborstreamreader#length&quot;&gt;length&lt;/a&gt;().</source>
          <target state="translated">現在の要素が配列の場合は、&lt;a href=&quot;qcborstreamreader#isLengthKnown&quot;&gt;isLengthKnown&lt;/a&gt;（）を呼び出して、配列のサイズがCBORストリームで明示的かどうかを確認することもできます。もしそうなら、そのサイズは&lt;a href=&quot;qcborstreamreader#length&quot;&gt;length&lt;/a&gt;（）を呼び出すことで取得できます。</target>
        </trans-unit>
        <trans-unit id="f84400c746d8fc0a5a48647d3e3c7ab1cfd364c9" translate="yes" xml:space="preserve">
          <source>When the current file changes for local operations, this signal is emitted with the new file name as the</source>
          <target state="translated">ローカル操作のために現在のファイルが変更された場合、この信号は新しいファイル名で</target>
        </trans-unit>
        <trans-unit id="0a86295fc3e43e6a47bc831aed3e39216c7b217d" translate="yes" xml:space="preserve">
          <source>When the current file changes, this signal is emitted with the new file URL as the</source>
          <target state="translated">現在のファイルが変更されると、このシグナルは新しいファイルの URL を</target>
        </trans-unit>
        <trans-unit id="8d02ddfa1e09fd4df4941f2aea01335858653f59" translate="yes" xml:space="preserve">
          <source>When the current loop changes, &lt;a href=&quot;qabstractanimation&quot;&gt;QAbstractAnimation&lt;/a&gt; emits the &lt;a href=&quot;qabstractanimation#currentLoopChanged&quot;&gt;currentLoopChanged&lt;/a&gt;() signal.</source>
          <target state="translated">現在のループが変化すると、&lt;a href=&quot;qabstractanimation&quot;&gt;QAbstractAnimation&lt;/a&gt;は&lt;a href=&quot;qabstractanimation#currentLoopChanged&quot;&gt;currentLoopChanged&lt;/a&gt;（）シグナルを発行します。</target>
        </trans-unit>
        <trans-unit id="0cfe43b8f234528af4d27981c91186f3fac30622" translate="yes" xml:space="preserve">
          <source>When the current size of the cache is greater than the &lt;a href=&quot;qnetworkdiskcache#maximumCacheSize&quot;&gt;maximumCacheSize&lt;/a&gt;() older cache files are removed until the total size is less then 90% of &lt;a href=&quot;qnetworkdiskcache#maximumCacheSize&quot;&gt;maximumCacheSize&lt;/a&gt;() starting with the oldest ones first using the file creation date to determine how old a cache file is.</source>
          <target state="translated">キャッシュの現在のサイズが&lt;a href=&quot;qnetworkdiskcache#maximumCacheSize&quot;&gt;maximumCacheSize&lt;/a&gt;（）より大きい場合、古いキャッシュファイルは、合計サイズが&lt;a href=&quot;qnetworkdiskcache#maximumCacheSize&quot;&gt;maximumCacheSize&lt;/a&gt;（）の90％未満になるまで削除され、最も古いものから、最初にファイル作成日を使用してキャッシュファイルの古さを判断します。です。</target>
        </trans-unit>
        <trans-unit id="3e61c9290a3e31fccfacad9bcadb7f0ab37cb158" translate="yes" xml:space="preserve">
          <source>When the cursor is moved and the underlying formatting attributes change, the &lt;a href=&quot;qtextedit#currentCharFormatChanged&quot;&gt;currentCharFormatChanged&lt;/a&gt;() signal is emitted to reflect the new attributes at the new cursor position.</source>
          <target state="translated">カーソルが移動され、基になるフォーマット属性が変更されると、&lt;a href=&quot;qtextedit#currentCharFormatChanged&quot;&gt;currentCharFormatChanged&lt;/a&gt;（）シグナルが発行され、新しいカーソル位置の新しい属性が反映されます。</target>
        </trans-unit>
        <trans-unit id="0bcf3c2857361e33820b911b748bda8d3e8f2499" translate="yes" xml:space="preserve">
          <source>When the cursor is over an object that can be used in a connection, the object will be highlighted.</source>
          <target state="translated">カーソルが接続で使用できるオブジェクトの上にあると、そのオブジェクトがハイライトされます。</target>
        </trans-unit>
        <trans-unit id="d5828b4053e945be1fe64d76bbf73ddc4acecf13" translate="yes" xml:space="preserve">
          <source>When the dark theme is in use, different &lt;a href=&quot;#pre-defined-shades&quot;&gt;shades&lt;/a&gt; of the pre-defined colors are used by default:</source>
          <target state="translated">ダークテーマが使用されている場合、既定では、事前に定義された色の異なる&lt;a href=&quot;#pre-defined-shades&quot;&gt;色合い&lt;/a&gt;が使用されます。</target>
        </trans-unit>
        <trans-unit id="3e63c161b63a9e90882d13f563f0753fdc02220f" translate="yes" xml:space="preserve">
          <source>When the dark theme is in use, different &lt;a href=&quot;qtquickcontrols2-material#pre-defined-shades&quot;&gt;shades&lt;/a&gt; of the pre-defined colors are used by default:</source>
          <target state="translated">When the dark theme is in use, different &lt;a href=&quot;qtquickcontrols2-material#pre-defined-shades&quot;&gt;shades&lt;/a&gt; of the pre-defined colors are used by default:</target>
        </trans-unit>
        <trans-unit id="aa15325522b12e3e10e05b6e7845de4c15cc9516" translate="yes" xml:space="preserve">
          <source>When the data has been set, the model must let the views know that some data has changed. This is done by emitting the &lt;a href=&quot;qabstractitemmodel#dataChanged&quot;&gt;dataChanged()&lt;/a&gt; signal. Since only one item of data has changed, the range of items specified in the signal is limited to just one model index.</source>
          <target state="translated">データが設定されると、モデルはビューにいくつかのデータが変更されたことを通知する必要があります。これは、&lt;a href=&quot;qabstractitemmodel#dataChanged&quot;&gt;dataChanged（）&lt;/a&gt;シグナルを発行することによって行われます。変更されたデータ項目は1つだけなので、信号で指定された項目の範囲は、1つのモデルインデックスのみに制限されます。</target>
        </trans-unit>
        <trans-unit id="268c6bc406e79834c8bfc145b96838dee4c8962b" translate="yes" xml:space="preserve">
          <source>When the default OpenGL &lt;a href=&quot;qtquick-visualcanvas-scenegraph&quot;&gt;scene graph&lt;/a&gt; backend is in use, images can also be supplied in compressed texture files. The content must be a simple RGB(A) format 2D texture. Supported compression schemes are only limited by the underlying OpenGL driver and GPU. The following container file formats are supported:</source>
          <target state="translated">When the default OpenGL &lt;a href=&quot;qtquick-visualcanvas-scenegraph&quot;&gt;scene graph&lt;/a&gt; backend is in use, images can also be supplied in compressed texture files. The content must be a simple RGB(A) format 2D texture. Supported compression schemes are only limited by the underlying OpenGL driver and GPU. The following container file formats are supported:</target>
        </trans-unit>
        <trans-unit id="39d841b77292d3e68d73048948b5c24756c32f98" translate="yes" xml:space="preserve">
          <source>When the default OpenGL &lt;a href=&quot;qtquick-visualcanvas-scenegraph#&quot;&gt;scene graph&lt;/a&gt; backend is in use, images can also be supplied in compressed texture files. The content must be a simple RGB(A) format 2D texture. Supported compression schemes are only limited by the underlying OpenGL driver and GPU. The following container file formats are supported:</source>
          <target state="translated">デフォルトのOpenGL &lt;a href=&quot;qtquick-visualcanvas-scenegraph#&quot;&gt;シーングラフ&lt;/a&gt;バックエンドが使用されている場合、画像を圧縮テクスチャファイルで提供することもできます。コンテンツは単純なRGB（A）形式の2Dテクスチャでなければなりません。サポートされる圧縮スキームは、基になるOpenGLドライバーとGPUによってのみ制限されます。次のコンテナファイル形式がサポートされています。</target>
        </trans-unit>
        <trans-unit id="2d66a3ba214fb29a1df6e5b414ad7e799a6e531c" translate="yes" xml:space="preserve">
          <source>When the desired target, or associated data, such as the size, changes, call this function with a new &lt;a href=&quot;qquickrendertarget&quot;&gt;QQuickRenderTarget&lt;/a&gt;. Constructing &lt;a href=&quot;qquickrendertarget&quot;&gt;QQuickRenderTarget&lt;/a&gt; instances and calling this function is cheap, but be aware that setting a new</source>
          <target state="translated">目的のターゲット、またはサイズなどの関連データが変更された場合は、新しい&lt;a href=&quot;qquickrendertarget&quot;&gt;QQuickRenderTargetを使用&lt;/a&gt;してこの関数を呼び出します。構築&lt;a href=&quot;qquickrendertarget&quot;&gt;QQuickRenderTargetの&lt;/a&gt;インスタンスをし、この関数を呼び出すことは安いですが、新しい設定があることに注意してください</target>
        </trans-unit>
        <trans-unit id="64564ede097c86de33c3d219ff3f4d6b55c9c533" translate="yes" xml:space="preserve">
          <source>When the dialog needs to generate a set of preview pages, the &lt;a href=&quot;qprintpreviewdialog#paintRequested&quot;&gt;paintRequested&lt;/a&gt;() signal will be emitted. You can use the exact same code for the actual printing as for having the preview generated, including calling &lt;a href=&quot;qprinter#newPage&quot;&gt;QPrinter::newPage&lt;/a&gt;() to start a new page in the preview. Connect a slot to the &lt;a href=&quot;qprintpreviewdialog#paintRequested&quot;&gt;paintRequested&lt;/a&gt;() signal, where you draw onto the &lt;a href=&quot;qprinter&quot;&gt;QPrinter&lt;/a&gt; object that is passed into the slot.</source>
          <target state="translated">ダイアログがプレビューページのセットを生成する必要がある場合、&lt;a href=&quot;qprintpreviewdialog#paintRequested&quot;&gt;paintRequested&lt;/a&gt;（）シグナルが発行されます。&lt;a href=&quot;qprinter#newPage&quot;&gt;QPrinter :: newPage&lt;/a&gt;（）を呼び出してプレビューで新しいページを開始するなど、プレビューを生成する場合とまったく同じコードを実際の印刷に使用できます。スロットを&lt;a href=&quot;qprintpreviewdialog#paintRequested&quot;&gt;paintRequested&lt;/a&gt;（）シグナルに接続し、スロットに渡される&lt;a href=&quot;qprinter&quot;&gt;QPrinter&lt;/a&gt;オブジェクトに描画します。</target>
        </trans-unit>
        <trans-unit id="442b26fe36b5b6b28e8fee4c93f0f0f9179a4be0" translate="yes" xml:space="preserve">
          <source>When the disk cache is disabled, via &lt;a href=&quot;qt#ApplicationAttribute-enum&quot;&gt;Qt::AA_DisableShaderDiskCache&lt;/a&gt; for example, or the OpenGL context has no support for context binaries, calling this function is equivalent to &lt;a href=&quot;qopenglshaderprogram#addShaderFromSourceCode&quot;&gt;addShaderFromSourceCode&lt;/a&gt;().</source>
          <target state="translated">たとえば&lt;a href=&quot;qt#ApplicationAttribute-enum&quot;&gt;Qt :: AA_DisableShaderDiskCache&lt;/a&gt;を介してディスクキャッシュが無効になっている場合、またはOpenGLコンテキストがコンテキストバイナリをサポートしていない場合、この関数の呼び出しは&lt;a href=&quot;qopenglshaderprogram#addShaderFromSourceCode&quot;&gt;addShaderFromSourceCode&lt;/a&gt;（）と同等です。</target>
        </trans-unit>
        <trans-unit id="9a274b9868a858f6451036974bc85cd45ebacc98" translate="yes" xml:space="preserve">
          <source>When the disk cache is disabled, via &lt;a href=&quot;qt#ApplicationAttribute-enum&quot;&gt;Qt::AA_DisableShaderDiskCache&lt;/a&gt; for example, or the OpenGL context has no support for context binaries, calling this function is equivalent to &lt;a href=&quot;qopenglshaderprogram#addShaderFromSourceFile&quot;&gt;addShaderFromSourceFile&lt;/a&gt;().</source>
          <target state="translated">たとえば&lt;a href=&quot;qt#ApplicationAttribute-enum&quot;&gt;Qt :: AA_DisableShaderDiskCache&lt;/a&gt;を介してディスクキャッシュが無効になっている場合、またはOpenGLコンテキストがコンテキストバイナリをサポートしていない場合、この関数の呼び出しは&lt;a href=&quot;qopenglshaderprogram#addShaderFromSourceFile&quot;&gt;addShaderFromSourceFile&lt;/a&gt;（）と同等です。</target>
        </trans-unit>
        <trans-unit id="cfc128bc4fe84e02bab33b87cc2068b75786b6b9" translate="yes" xml:space="preserve">
          <source>When the dock widget lays out its contents it asks the style for these pixel metrics: &lt;code&gt;PM_DockWidgetSeparatorExtent&lt;/code&gt;, &lt;code&gt;PM_DockWidgetTitleBarButtonMargin&lt;/code&gt;, &lt;code&gt;PM_DockWidgetFrameWidth&lt;/code&gt;, and &lt;code&gt;PM_DockWidgetTitleMargin&lt;/code&gt;. It also calculates the bounding rectangles of the float and close buttons with &lt;code&gt;SE_DockWidgetCloseButton&lt;/code&gt; and &lt;code&gt;SE_DockWidgetFloatButton&lt;/code&gt;.</source>
          <target state="translated">ドックウィジェットは、コンテンツをレイアウトするときに、スタイルに次のピクセルメトリックを要求します： &lt;code&gt;PM_DockWidgetSeparatorExtent&lt;/code&gt; 、 &lt;code&gt;PM_DockWidgetTitleBarButtonMargin&lt;/code&gt; 、 &lt;code&gt;PM_DockWidgetFrameWidth&lt;/code&gt; 、および &lt;code&gt;PM_DockWidgetTitleMargin&lt;/code&gt; 。また、 &lt;code&gt;SE_DockWidgetCloseButton&lt;/code&gt; および &lt;code&gt;SE_DockWidgetFloatButton&lt;/code&gt; を使用して、フロートボタンと閉じるボタンの外接する四角形を計算します。</target>
        </trans-unit>
        <trans-unit id="dc07829ed23956686aa2110b6aa13a3a31695d82" translate="yes" xml:space="preserve">
          <source>When the edit strategy is &lt;a href=&quot;qsqltablemodel#EditStrategy-enum&quot;&gt;OnManualSubmit&lt;/a&gt;, deletion of rows from the database is delayed until &lt;a href=&quot;qsqltablemodel#submitAll&quot;&gt;submitAll&lt;/a&gt;() is called.</source>
          <target state="translated">編集戦略が&lt;a href=&quot;qsqltablemodel#EditStrategy-enum&quot;&gt;OnManualSubmitの&lt;/a&gt;場合、データベースからの行の削除は、&lt;a href=&quot;qsqltablemodel#submitAll&quot;&gt;submitAll&lt;/a&gt;（）が呼び出されるまで遅延されます。</target>
        </trans-unit>
        <trans-unit id="69d60b285999f455929d7c354ec16df415cf791e" translate="yes" xml:space="preserve">
          <source>When the error occurs in code that uses the &lt;a href=&quot;qaxfactory#QAXCLASS&quot;&gt;QAXCLASS&lt;/a&gt;() or QAXFACTORY_DEFAULT() macro, the widget class had no constructor that can be used by the default factory. Either add a standard widget constructor or implement a custom factory that doesn't require one.</source>
          <target state="translated">When the error occurs in code that uses the &lt;a href=&quot;qaxfactory#QAXCLASS&quot;&gt;QAXCLASS&lt;/a&gt;() or QAXFACTORY_DEFAULT() macro, the widget class had no constructor that can be used by the default factory. Either add a standard widget constructor or implement a custom factory that doesn't require one.</target>
        </trans-unit>
        <trans-unit id="5ce533133f051ef361f68d445640b0f45e1ae0bd" translate="yes" xml:space="preserve">
          <source>When the error occurs in code that uses the &lt;a href=&quot;qaxfactory#QAXFACTORY_DEFAULT&quot;&gt;QAXFACTORY_DEFAULT&lt;/a&gt;() macro, the widget class had no constructor that can be used by the default factory. Either add a standard widget constructor or implement a custom factory that doesn't require one.</source>
          <target state="translated">&lt;a href=&quot;qaxfactory#QAXFACTORY_DEFAULT&quot;&gt;QAXFACTORY_DEFAULT&lt;/a&gt;（）マクロを使用するコードでエラーが発生した場合、ウィジェットクラスには、デフォルトファクトリで使用できるコンストラクターがありませんでした。標準のウィジェットコンストラクターを追加するか、それを必要としないカスタムファクトリーを実装します。</target>
        </trans-unit>
        <trans-unit id="67528e55cc72382a76299d4a29a6d404185ca633" translate="yes" xml:space="preserve">
          <source>When the error occurs in code that uses the &lt;a href=&quot;qaxfactory#QAXFACTORY_EXPORT&quot;&gt;QAXFACTORY_EXPORT&lt;/a&gt;() macro, the &lt;a href=&quot;qaxfactory&quot;&gt;QAxFactory&lt;/a&gt; subclass had no appropriate constructor. Provide a public class constructor like</source>
          <target state="translated">&lt;a href=&quot;qaxfactory#QAXFACTORY_EXPORT&quot;&gt;QAXFACTORY_EXPORT&lt;/a&gt;（）マクロを使用するコードでエラーが発生すると、&lt;a href=&quot;qaxfactory&quot;&gt;QAxFactory&lt;/a&gt;サブクラスに適切なコンストラクターがありませんでした。次のようなパブリッククラスコンストラクタを提供します。</target>
        </trans-unit>
        <trans-unit id="667bcb82ac840306758fe028ef02a3142d64c33c" translate="yes" xml:space="preserve">
          <source>When the file was created (may not be not supported on UNIX).</source>
          <target state="translated">ファイルが作成されたとき(UNIXではサポートされていない場合があります)。</target>
        </trans-unit>
        <trans-unit id="b25b4b7cadd51d3809c6192d30e9736fd31ceee0" translate="yes" xml:space="preserve">
          <source>When the file was most recently accessed (e.g. read or written to).</source>
          <target state="translated">ファイルに最も最近アクセスしたとき(読み込まれたり書き込まれたりしたときなど)。</target>
        </trans-unit>
        <trans-unit id="4c27bd30e3a44efb1b186d178c93f6ceaf40ce32" translate="yes" xml:space="preserve">
          <source>When the file was most recently modified.</source>
          <target state="translated">ファイルが最も最近変更されたとき。</target>
        </trans-unit>
        <trans-unit id="d5d340431973f92573daf9a19dcdb9fd00b81737" translate="yes" xml:space="preserve">
          <source>When the file's metadata was last changed.</source>
          <target state="translated">ファイルのメタデータが最後に変更されたとき。</target>
        </trans-unit>
        <trans-unit id="0ed30361bc54f69e5900b60fbcec5e46b66fc62b" translate="yes" xml:space="preserve">
          <source>When the filter object's &lt;a href=&quot;qobject#eventFilter&quot;&gt;eventFilter()&lt;/a&gt; implementation is called, it can accept or reject the event, and allow or deny further processing of the event. If all the event filters allow further processing of an event (by each returning &lt;code&gt;false&lt;/code&gt;), the event is sent to the target object itself. If one of them stops processing (by returning &lt;code&gt;true&lt;/code&gt;), the target and any later event filters do not get to see the event at all.</source>
          <target state="translated">フィルターオブジェクトの&lt;a href=&quot;qobject#eventFilter&quot;&gt;eventFilter（）&lt;/a&gt;実装が呼び出されると、イベントを受け入れまたは拒否し、イベントの以降の処理を許可または拒否できます。すべてのイベントフィルターがイベントのさらなる処理を許可する場合（それぞれが &lt;code&gt;false&lt;/code&gt; を返すことにより）、イベントはターゲットオブジェクト自体に送信されます。それらの1つが（ &lt;code&gt;true&lt;/code&gt; を返すことによって）処理を停止すると、ターゲットおよびそれ以降のイベントフィルターはイベントをまったく表示できなくなります。</target>
        </trans-unit>
        <trans-unit id="837b081290388ef24310dab55793156db9eb9dfc" translate="yes" xml:space="preserve">
          <source>When the first touch point is detected, the destination widget is determined firstly by the location on screen and secondly by the propagation rules.</source>
          <target state="translated">第1のタッチポイントが検出されると、第1に画面上の位置、第2に伝搬ルールによって目的地ウィジェットが決定される。</target>
        </trans-unit>
        <trans-unit id="da3ee5de937f78331baaaed7a12ec8f5b5ae3e7b" translate="yes" xml:space="preserve">
          <source>When the format is extended and a</source>
          <target state="translated">フォーマットが拡張され</target>
        </trans-unit>
        <trans-unit id="60ff0e9974e90a3bb46faadb679db78b2703c023" translate="yes" xml:space="preserve">
          <source>When the format is not explicitly set via this function, the format returned by &lt;a href=&quot;qsurfaceformat#defaultFormat&quot;&gt;QSurfaceFormat::defaultFormat&lt;/a&gt;() will be used. This means that when having multiple OpenGL widgets, individual calls to this function can be replaced by one single call to &lt;a href=&quot;qsurfaceformat#setDefaultFormat&quot;&gt;QSurfaceFormat::setDefaultFormat&lt;/a&gt;() before creating the first widget.</source>
          <target state="translated">この関数を介して形式が明示的に設定されていない場合、&lt;a href=&quot;qsurfaceformat#defaultFormat&quot;&gt;QSurfaceFormat :: defaultFormat&lt;/a&gt;（）によって返される形式が使用されます。つまり、複数のOpenGLウィジェットがある場合、最初のウィジェットを作成する前に、この関数への個々の呼び出しを&lt;a href=&quot;qsurfaceformat#setDefaultFormat&quot;&gt;QSurfaceFormat :: setDefaultFormat&lt;/a&gt;（）への単一の呼び出しで置き換えることができます。</target>
        </trans-unit>
        <trans-unit id="2beb1fd6e4f28222293604d7f4d897a896d350d1" translate="yes" xml:space="preserve">
          <source>When the format is not explicitly set via this function, the format returned by &lt;a href=&quot;qsurfaceformat#defaultFormat&quot;&gt;QSurfaceFormat::defaultFormat&lt;/a&gt;() will be used. This means that when having multiple contexts, individual calls to this function can be replaced by one single call to &lt;a href=&quot;qsurfaceformat#setDefaultFormat&quot;&gt;QSurfaceFormat::setDefaultFormat&lt;/a&gt;() before creating the first context.</source>
          <target state="translated">この関数を介して形式が明示的に設定されていない場合、&lt;a href=&quot;qsurfaceformat#defaultFormat&quot;&gt;QSurfaceFormat :: defaultFormat&lt;/a&gt;（）によって返される形式が使用されます。つまり、複数のコンテキストがある場合、最初のコンテキストを作成する前に、この関数への個々の呼び出しを&lt;a href=&quot;qsurfaceformat#setDefaultFormat&quot;&gt;QSurfaceFormat :: setDefaultFormat&lt;/a&gt;（）への単一の呼び出しで置き換えることができます。</target>
        </trans-unit>
        <trans-unit id="00713dadf93099ecb982ada3e77d69bdabc871f2" translate="yes" xml:space="preserve">
          <source>When the format is not explicitly set via this function, the format returned by &lt;a href=&quot;qsurfaceformat#defaultFormat&quot;&gt;QSurfaceFormat::defaultFormat&lt;/a&gt;() will be used. This means that when having multiple windows, individual calls to this function can be replaced by one single call to &lt;a href=&quot;qsurfaceformat#setDefaultFormat&quot;&gt;QSurfaceFormat::setDefaultFormat&lt;/a&gt;() before creating the first window.</source>
          <target state="translated">この関数を介して形式が明示的に設定されていない場合、&lt;a href=&quot;qsurfaceformat#defaultFormat&quot;&gt;QSurfaceFormat :: defaultFormat&lt;/a&gt;（）によって返される形式が使用されます。つまり、複数のウィンドウがある場合、この関数への個々の呼び出しは、最初のウィンドウを作成する前に&lt;a href=&quot;qsurfaceformat#setDefaultFormat&quot;&gt;QSurfaceFormat :: setDefaultFormat&lt;/a&gt;（）への単一の呼び出しで置き換えることができます。</target>
        </trans-unit>
        <trans-unit id="e754609b648456c9f3be814c91d8b1c6d69c6124" translate="yes" xml:space="preserve">
          <source>When the geometry is being rendered, each location on its surface will be transformed to a corresponding location in the texture by transforming and interpolating the UV coordinates (texture coordinate) that have been set for the mesh's vertexes. The fragment shader program that is being used to render the active material will then typically sample the material's texture(s) at the given coordinates and use the sampled data in its light calculations.</source>
          <target state="translated">ジオメトリがレンダリングされると、メッシュの頂点に設定された UV 座標(テクスチャ座標)を変換して補間することで、サーフェス上の各位置がテクスチャ内の対応する位置に変換されます。アクティブマテリアルのレンダリングに使用されているフラグメントシェーダプログラムは、通常、指定された座標でマテリアルのテクスチャをサンプリングし、サンプリングされたデータをライト計算に使用します。</target>
        </trans-unit>
        <trans-unit id="25d8d569194c95628c8a9af91c9b0f5b8ee86128" translate="yes" xml:space="preserve">
          <source>When the given</source>
          <target state="translated">与えられた</target>
        </trans-unit>
        <trans-unit id="a84c5e22d39ffceb346211bc14286a14c79f8784" translate="yes" xml:space="preserve">
          <source>When the horizontal alignment of a text item is not explicitly set, the text element is automatically aligned to the natural reading direction of the text. By default left-to-right text like English is aligned to the left side of the text area, and right-to-left text like Arabic is aligned to the right side of the text area. The alignment of a text element with empty text takes its alignment cue from &lt;a href=&quot;qinputmethod#inputDirection-prop&quot;&gt;QInputMethod::inputDirection&lt;/a&gt;(), which is based on the active system locale.</source>
          <target state="translated">テキストアイテムの水平方向の配置が明示的に設定されていない場合、テキスト要素は自動的にテキストの自然な読み方向に配置されます。デフォルトでは、英語などの左から右へのテキストはテキスト領域の左側に配置され、アラビア語などの右から左へのテキストはテキスト領域の右側に配置されます。空のテキストを持つテキスト要素の配置は、アクティブなシステムロケールに基づく&lt;a href=&quot;qinputmethod#inputDirection-prop&quot;&gt;QInputMethod :: inputDirection&lt;/a&gt;（）からその配置キューを取得します。</target>
        </trans-unit>
        <trans-unit id="2f163bb4526ffce4c5d0c97da01d544fc9ab7648" translate="yes" xml:space="preserve">
          <source>When the image is ready, &lt;a href=&quot;qml-qtquick-canvas#imageLoaded-signal&quot;&gt;imageLoaded&lt;/a&gt; will be emitted. The loaded image can be unloaded by the &lt;a href=&quot;qml-qtquick-canvas#unloadImage-method&quot;&gt;unloadImage()&lt;/a&gt; method.</source>
          <target state="translated">画像の準備ができると、&lt;a href=&quot;qml-qtquick-canvas#imageLoaded-signal&quot;&gt;imageLoaded&lt;/a&gt;が発行されます。ロードされたイメージは、&lt;a href=&quot;qml-qtquick-canvas#unloadImage-method&quot;&gt;unloadImage（）&lt;/a&gt;メソッドによってアンロードできます。</target>
        </trans-unit>
        <trans-unit id="4722dd5405336bb1dc515fbc7e7e1db0a5d91ef2" translate="yes" xml:space="preserve">
          <source>When the image is scaled, regions of the source image are scaled or tiled to create the displayed border image in the following way:</source>
          <target state="translated">画像がスケーリングされると、元画像の領域がスケーリングされたり、タイル状になったりして、以下のように表示されるボーダー画像が作成されます。</target>
        </trans-unit>
        <trans-unit id="cb1a5c40c986de8b7e66b324c82e0775e3788bc6" translate="yes" xml:space="preserve">
          <source>When the image is used, the color table must be large enough to have entries for all the pixel/index values present in the image, otherwise the results are undefined.</source>
          <target state="translated">画像が使われているときは、カラーテーブルは、画像内に存在するすべてのピクセル/インデックス値のエントリを持つのに十分な大きさでなければならず、そうでなければ結果は未定義です。</target>
        </trans-unit>
        <trans-unit id="a62a0ab3afb30df54c7a307954a51b28f0879b31" translate="yes" xml:space="preserve">
          <source>When the indexing process has finished, the search engine can be used to search through the index for a given term using the search() function. When the search input is passed to the search engine, the &lt;a href=&quot;qhelpsearchengine#searchingStarted&quot;&gt;searchingStarted&lt;/a&gt;() signal is emitted. When the search finishes, the &lt;a href=&quot;qhelpsearchengine#searchingFinished&quot;&gt;searchingFinished&lt;/a&gt;() signal is emitted. The search process can be stopped by calling &lt;a href=&quot;qhelpsearchengine#cancelSearching&quot;&gt;cancelSearching&lt;/a&gt;().</source>
          <target state="translated">索引付けプロセスが完了すると、検索エンジンを使用して、search（）関数を使用して特定の用語の索引を検索できます。検索入力が検索エンジンに渡されると、&lt;a href=&quot;qhelpsearchengine#searchingStarted&quot;&gt;searchingStarted&lt;/a&gt;（）シグナルが発行されます。検索が完了すると、&lt;a href=&quot;qhelpsearchengine#searchingFinished&quot;&gt;searchingFinished&lt;/a&gt;（）シグナルが発行されます。&lt;a href=&quot;qhelpsearchengine#cancelSearching&quot;&gt;cancelSearching&lt;/a&gt;（）を呼び出すことにより、検索プロセスを停止できます。</target>
        </trans-unit>
        <trans-unit id="abed85d30a721e876a4399c7b26aa9eed3e46ead" translate="yes" xml:space="preserve">
          <source>When the input method requires the UI to update the contents of a selection list, it will emit the &lt;a href=&quot;qml-qtquick-virtualkeyboard-inputmethod#selectionListChanged-signal&quot;&gt;InputMethod::selectionListChanged&lt;/a&gt; signal. Likewise, if the input method requires the UI to highlight an item in the list, it will emit the &lt;a href=&quot;qml-qtquick-virtualkeyboard-inputmethod#selectionListActiveItemChanged-signal&quot;&gt;InputMethod::selectionListActiveItemChanged&lt;/a&gt; signal.</source>
          <target state="translated">入力メソッドがUIに選択リストの内容を更新するよう要求する場合、入力メソッドは&lt;a href=&quot;qml-qtquick-virtualkeyboard-inputmethod#selectionListChanged-signal&quot;&gt;InputMethod :: selectionListChanged&lt;/a&gt;シグナルを発行します。同様に、入力メソッドがリスト内の項目を強調表示するためにUIを必要とする場合は、&lt;a href=&quot;qml-qtquick-virtualkeyboard-inputmethod#selectionListActiveItemChanged-signal&quot;&gt;InputMethod :: selectionListActiveItemChanged&lt;/a&gt;シグナルを発行します。</target>
        </trans-unit>
        <trans-unit id="af13632c6936ddc6476f8bec001c16d3ccdb1b88" translate="yes" xml:space="preserve">
          <source>When the interaction is completed we strongly recommend releasing the user interaction semaphore with a call to &lt;a href=&quot;qsessionmanager#release&quot;&gt;release&lt;/a&gt;(). This way, other applications may get the chance to interact with the user while your application is still busy saving data. (The semaphore is implicitly released when the application exits.)</source>
          <target state="translated">対話が完了したら、&lt;a href=&quot;qsessionmanager#release&quot;&gt;release&lt;/a&gt;（）を呼び出してユーザー対話セマフォを解放することを強くお勧めします。このようにして、アプリケーションがデータの保存でビジー状態のときに、他のアプリケーションがユーザーと対話する機会が得られる場合があります。（セマフォは、アプリケーションの終了時に暗黙的に解放されます。）</target>
        </trans-unit>
        <trans-unit id="a08dbc79fd5ced7fe929c3d064e1b645b21d39b2" translate="yes" xml:space="preserve">
          <source>When the labels are editable the user will be able to change the range of the axis conveniently by editing any of the labels. This feature is only supported for the &lt;a href=&quot;qvalueaxis&quot;&gt;QValueAxis&lt;/a&gt; and the &lt;a href=&quot;qdatetimeaxis&quot;&gt;QDateTimeAxis&lt;/a&gt;.</source>
          <target state="translated">ラベルが編集可能な場合、ユーザーはラベルのいずれかを編集することにより、軸の範囲を簡単に変更できます。この機能は&lt;a href=&quot;qvalueaxis&quot;&gt;QValueAxis&lt;/a&gt;とQDateTimeAxisでのみサポートされてい&lt;a href=&quot;qdatetimeaxis&quot;&gt;ます&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="16aac338dd8507181525a913639f185cb93e3d46" translate="yes" xml:space="preserve">
          <source>When the layout direction is set on a widget, it will propagate to the widget's children, but not to a child that is a window and not to a child for which setLayoutDirection() has been explicitly called. Also, child widgets added</source>
          <target state="translated">ウィジェットにレイアウト方向が設定されている場合、それはウィジェットの子ウィジェットに伝搬しますが、ウィンドウである子ウィジェットや setLayoutDirection()が明示的に呼び出された子ウィジェットには伝搬しません。また、追加された子ウィジェット</target>
        </trans-unit>
        <trans-unit id="757e208faf34bd91da1b625ef70871bbc740552e" translate="yes" xml:space="preserve">
          <source>When the layout's geometry changes, &lt;a href=&quot;graphicsview#qgraphicslayout&quot;&gt;QGraphicsLayout&lt;/a&gt; immediately rearranges all of its managed items by calling &lt;a href=&quot;qgraphicslayoutitem#setGeometry&quot;&gt;setGeometry&lt;/a&gt;() on each item. This rearrangement is called</source>
          <target state="translated">レイアウトのジオメトリが変更されると、&lt;a href=&quot;graphicsview#qgraphicslayout&quot;&gt;QGraphicsLayout&lt;/a&gt;は、各アイテムで&lt;a href=&quot;qgraphicslayoutitem#setGeometry&quot;&gt;setGeometry&lt;/a&gt;（）を呼び出すことにより、そのすべての管理対象アイテムをすぐに再配置します。この再配置は</target>
        </trans-unit>
        <trans-unit id="14d52274c262e663bee4bb6936d376e01f9d9786" translate="yes" xml:space="preserve">
          <source>When the layout's geometry changes, QGraphicsLayout immediately rearranges all of its managed items by calling &lt;a href=&quot;qgraphicslayoutitem#setGeometry&quot;&gt;setGeometry&lt;/a&gt;() on each item. This rearrangement is called</source>
          <target state="translated">When the layout's geometry changes, QGraphicsLayout immediately rearranges all of its managed items by calling &lt;a href=&quot;qgraphicslayoutitem#setGeometry&quot;&gt;setGeometry&lt;/a&gt;() on each item. This rearrangement is called</target>
        </trans-unit>
        <trans-unit id="a4868cf3fc8227fd58f7cf326e3d937144f921d5" translate="yes" xml:space="preserve">
          <source>When the locale is not specified, the default system locale is used instead.</source>
          <target state="translated">ロケールを指定しない場合は、デフォルトのシステムロケールが代わりに使用されます。</target>
        </trans-unit>
        <trans-unit id="d8c8da609611d53dcc5b14869c74793f679093e3" translate="yes" xml:space="preserve">
          <source>When the machine is in state &lt;code&gt;s2&lt;/code&gt;, the machine will play the default animation for the property &lt;code&gt;fooBar&lt;/code&gt; since this property is assigned by &lt;code&gt;s2&lt;/code&gt;.</source>
          <target state="translated">マシンが &lt;code&gt;s2&lt;/code&gt; 状態の場合、このプロパティは &lt;code&gt;s2&lt;/code&gt; によって割り当てられるため、マシンはプロパティ &lt;code&gt;fooBar&lt;/code&gt; のデフォルトのアニメーションを再生します。</target>
        </trans-unit>
        <trans-unit id="e08c3bd224be28ab8da0d15a3e80244ae34b5521" translate="yes" xml:space="preserve">
          <source>When the map is displayed, each possible geographic coordinate that is visible will map to some pixel X and Y coordinate on the screen. To perform conversions between these two, Map provides the &lt;a href=&quot;qml-qtlocation-map#toCoordinate-method&quot;&gt;toCoordinate&lt;/a&gt; and &lt;a href=&quot;qml-qtlocation-map#fromCoordinate-method&quot;&gt;fromCoordinate&lt;/a&gt; functions, which are of general utility.</source>
          <target state="translated">マップが表示されると、表示される可能な各地理座標は、画面上のピクセルXおよびY座標にマップされます。これら二つの間の変換を実行するために、地図提供&lt;a href=&quot;qml-qtlocation-map#toCoordinate-method&quot;&gt;toCoordinate&lt;/a&gt;と&lt;a href=&quot;qml-qtlocation-map#fromCoordinate-method&quot;&gt;fromCoordinate&lt;/a&gt;一般的な有用な機能を、。</target>
        </trans-unit>
        <trans-unit id="c5d7b44152d91a8b1270640c20696e9ece89a8be" translate="yes" xml:space="preserve">
          <source>When the mode changes, &lt;a href=&quot;qsslsocket&quot;&gt;QSslSocket&lt;/a&gt; emits &lt;a href=&quot;qsslsocket#modeChanged&quot;&gt;modeChanged&lt;/a&gt;()</source>
          <target state="translated">モードが変更されると、&lt;a href=&quot;qsslsocket&quot;&gt;QSslSocket&lt;/a&gt;は&lt;a href=&quot;qsslsocket#modeChanged&quot;&gt;modeChanged&lt;/a&gt;（）を発行します</target>
        </trans-unit>
        <trans-unit id="f34a87a12fe283ceded3dd1abbd77031338a6cd0" translate="yes" xml:space="preserve">
          <source>When the model has multiple roles, &lt;code&gt;textRole&lt;/code&gt; can be set to determine which role should be displayed.</source>
          <target state="translated">モデルに複数のロールがある場合、 &lt;code&gt;textRole&lt;/code&gt; を設定して、表示するロールを決定できます。</target>
        </trans-unit>
        <trans-unit id="da9a781aefd18e2834be4ea55a33a7e98b410511" translate="yes" xml:space="preserve">
          <source>When the model has multiple roles, textRole can be set to determine which role should be displayed.</source>
          <target state="translated">モデルに複数のロールがある場合、どのロールを表示するかを決定するためにtextRoleを設定することができます。</target>
        </trans-unit>
        <trans-unit id="422c5c92ca52eb6e2a6538c002cc9123999cfea0" translate="yes" xml:space="preserve">
          <source>When the mouse is pressed, the &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle&lt;/a&gt; changes to the</source>
          <target state="translated">マウスを押すと、&lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;四角形&lt;/a&gt;が</target>
        </trans-unit>
        <trans-unit id="5657ede20e143f6d442db18b090e618d804d1de7" translate="yes" xml:space="preserve">
          <source>When the mouse moves over the item,</source>
          <target state="translated">マウスがアイテムの上を移動したとき</target>
        </trans-unit>
        <trans-unit id="91af59e60e5984086456c7ad2a2054d514962b50" translate="yes" xml:space="preserve">
          <source>When the number of commands on a stack exceedes the stack's undoLimit, commands are deleted from the bottom of the stack. Macro commands (commands with child commands) are treated as one command. The default value is 0, which means that there is no limit.</source>
          <target state="translated">スタック上のコマンド数がスタックの undoLimit を超えると、スタックの一番下からコマンドが削除されます。マクロコマンド(子コマンドを持つコマンド)は1つのコマンドとして扱われます。デフォルト値は0で、制限はありません。</target>
        </trans-unit>
        <trans-unit id="001d63f0ced7bf39910f29efe7f6f5fd05b477ff" translate="yes" xml:space="preserve">
          <source>When the number of matches cannot be determined in advance, a common idiom is to use &lt;a href=&quot;qregexp#cap&quot;&gt;cap&lt;/a&gt;() in a loop. For example:</source>
          <target state="translated">一致の数が事前に決定できない場合、一般的なイディオムはループで&lt;a href=&quot;qregexp#cap&quot;&gt;cap&lt;/a&gt;（）を使用することです。例えば：</target>
        </trans-unit>
        <trans-unit id="19d271264efc628bb86bca221e850d0c5cb77458" translate="yes" xml:space="preserve">
          <source>When the object supports multiple selections (e.g. in a word processor), this adds a new selection, otherwise it replaces the previous selection.</source>
          <target state="translated">オブジェクトが複数の選択をサポートしている場合 (ワープロなどで)、これは新しい選択を追加し、そうでない場合は前の選択を置き換えます。</target>
        </trans-unit>
        <trans-unit id="73cf6131f4a582c72bc9f9330edcb48af4fcc81f" translate="yes" xml:space="preserve">
          <source>When the page is inserted into a wizard using &lt;a href=&quot;qwizard#addPage&quot;&gt;QWizard::addPage&lt;/a&gt;() or &lt;a href=&quot;qwizard#setPage&quot;&gt;QWizard::setPage&lt;/a&gt;(), the parent is automatically set to be the wizard.</source>
          <target state="translated">&lt;a href=&quot;qwizard#addPage&quot;&gt;QWizard :: addPage&lt;/a&gt;（）または&lt;a href=&quot;qwizard#setPage&quot;&gt;QWizard :: setPage&lt;/a&gt;（）を使用してページをウィザードに挿入すると、親が自動的にウィザードに設定されます。</target>
        </trans-unit>
        <trans-unit id="35fc6c728ad882d547072f431eb37b1425e9f468" translate="yes" xml:space="preserve">
          <source>When the paint event occurs, the update region has normally been erased, so you are painting on the widget's background.</source>
          <target state="translated">ペイントイベントが発生すると、通常は更新領域が消去されているので、ウィジェットの背景にペイントすることになります。</target>
        </trans-unit>
        <trans-unit id="f30c7c3f40f1a872547881cd7951c22cee36c1cd" translate="yes" xml:space="preserve">
          <source>When the parameter is set to &lt;a href=&quot;qopengltexture#DepthStencilMode-enum&quot;&gt;DepthMode&lt;/a&gt;, then accessing it from the shader will access the depth component as a single float, as normal. But when the parameter is set to &lt;a href=&quot;qopengltexture#DepthStencilMode-enum&quot;&gt;StencilMode&lt;/a&gt;, the shader will access the stencil component.</source>
          <target state="translated">パラメータが&lt;a href=&quot;qopengltexture#DepthStencilMode-enum&quot;&gt;DepthMode&lt;/a&gt;に設定されている場合、シェーダからアクセスすると、通常どおり、単一のフロートとして深度コンポーネントにアクセスします。ただし、パラメーターが&lt;a href=&quot;qopengltexture#DepthStencilMode-enum&quot;&gt;StencilMode&lt;/a&gt;に設定されている場合、シェーダーはステンシルコンポーネントにアクセスします。</target>
        </trans-unit>
        <trans-unit id="2375fc19af6a76757eb823a66fb6127ba87e61c2" translate="yes" xml:space="preserve">
          <source>When the parser encounters an error, it signals the event by making &lt;a href=&quot;qurl#isValid&quot;&gt;isValid&lt;/a&gt;() return false and &lt;a href=&quot;qurl#toString&quot;&gt;toString&lt;/a&gt;() / &lt;a href=&quot;qurl#toEncoded&quot;&gt;toEncoded&lt;/a&gt;() return an empty string. If it is necessary to show the user the reason why the URL failed to parse, the error condition can be obtained from &lt;a href=&quot;qurl&quot;&gt;QUrl&lt;/a&gt; by calling &lt;a href=&quot;qurl#errorString&quot;&gt;errorString&lt;/a&gt;(). Note that this message is highly technical and may not make sense to end-users.</source>
          <target state="translated">パーサーはエラーを検出すると、&lt;a href=&quot;qurl#isValid&quot;&gt;isValid&lt;/a&gt;（）がfalseを返し、&lt;a href=&quot;qurl#toString&quot;&gt;toString&lt;/a&gt;（）/ &lt;a href=&quot;qurl#toEncoded&quot;&gt;toEncoded&lt;/a&gt;（）が空の文字列を返すようにして、イベントを通知します。URLが解析に失敗した理由をユーザーに示す必要がある場合は、&lt;a href=&quot;qurl#errorString&quot;&gt;errorString&lt;/a&gt;（）を呼び出して&lt;a href=&quot;qurl&quot;&gt;QUrl&lt;/a&gt;からエラー状態を取得できます。このメッセージは非常に技術的であり、エンドユーザーには意味がない場合があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="811d686f479044d2209c2819d361efa6d361ce38" translate="yes" xml:space="preserve">
          <source>When the parser encounters an error, it signals the event by making &lt;a href=&quot;qurl#isValid&quot;&gt;isValid&lt;/a&gt;() return false and &lt;a href=&quot;qurl#toString&quot;&gt;toString&lt;/a&gt;() / &lt;a href=&quot;qurl#toEncoded&quot;&gt;toEncoded&lt;/a&gt;() return an empty string. If it is necessary to show the user the reason why the URL failed to parse, the error condition can be obtained from QUrl by calling &lt;a href=&quot;qurl#errorString&quot;&gt;errorString&lt;/a&gt;(). Note that this message is highly technical and may not make sense to end-users.</source>
          <target state="translated">When the parser encounters an error, it signals the event by making &lt;a href=&quot;qurl#isValid&quot;&gt;isValid&lt;/a&gt;() return false and &lt;a href=&quot;qurl#toString&quot;&gt;toString&lt;/a&gt;() / &lt;a href=&quot;qurl#toEncoded&quot;&gt;toEncoded&lt;/a&gt;() return an empty string. If it is necessary to show the user the reason why the URL failed to parse, the error condition can be obtained from QUrl by calling &lt;a href=&quot;qurl#errorString&quot;&gt;errorString&lt;/a&gt;(). Note that this message is highly technical and may not make sense to end-users.</target>
        </trans-unit>
        <trans-unit id="50ba901eeb2daca251dbecc6e227457e431d3835" translate="yes" xml:space="preserve">
          <source>When the player object is buffering; this property holds the percentage of the temporary buffer that is filled. The buffer will need to reach 100% filled before playback can start or resume, at which time &lt;a href=&quot;qmediaplayer#mediaStatus-prop&quot;&gt;mediaStatus&lt;/a&gt;() will return &lt;a href=&quot;qmediaplayer#MediaStatus-enum&quot;&gt;BufferedMedia&lt;/a&gt; or &lt;a href=&quot;qmediaplayer#MediaStatus-enum&quot;&gt;BufferingMedia&lt;/a&gt;. If the value is anything lower than &lt;code&gt;100&lt;/code&gt;, &lt;a href=&quot;qmediaplayer#mediaStatus-prop&quot;&gt;mediaStatus&lt;/a&gt;() will return &lt;a href=&quot;qmediaplayer#MediaStatus-enum&quot;&gt;StalledMedia&lt;/a&gt;.</source>
          <target state="translated">プレーヤーオブジェクトがバッファリングしているとき。このプロパティは、満たされる一時バッファの割合を保持します。再生を開始または再開するには、バッファが100％満たされている必要があります。この時点で、&lt;a href=&quot;qmediaplayer#mediaStatus-prop&quot;&gt;mediaStatus&lt;/a&gt;（）は&lt;a href=&quot;qmediaplayer#MediaStatus-enum&quot;&gt;BufferedMedia&lt;/a&gt;または&lt;a href=&quot;qmediaplayer#MediaStatus-enum&quot;&gt;BufferingMedia&lt;/a&gt;を返します。値が &lt;code&gt;100&lt;/code&gt; 未満の場合、&lt;a href=&quot;qmediaplayer#mediaStatus-prop&quot;&gt;mediaStatus&lt;/a&gt;（）は&lt;a href=&quot;qmediaplayer#MediaStatus-enum&quot;&gt;StalledMedia&lt;/a&gt;を返します。</target>
        </trans-unit>
        <trans-unit id="da64dfb7cefdbeef317abcd7e43d7b305a5ee3ab" translate="yes" xml:space="preserve">
          <source>When the popup actually receives focus, &lt;a href=&quot;qml-qtquick-controls2-popup#activeFocus-prop&quot;&gt;activeFocus&lt;/a&gt; will be &lt;code&gt;true&lt;/code&gt;. For more information, see &lt;a href=&quot;qtquick-input-focus&quot;&gt;Keyboard Focus in Qt Quick&lt;/a&gt;.</source>
          <target state="translated">ポップアップが実際にフォーカスを&lt;a href=&quot;qml-qtquick-controls2-popup#activeFocus-prop&quot;&gt;受け取る&lt;/a&gt;と、activeFocusは &lt;code&gt;true&lt;/code&gt; になります。詳細について&lt;a href=&quot;qtquick-input-focus&quot;&gt;は、Qt Quickのキーボードフォーカスを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="d6f2faeb8b71e0aaa953aece87da658ef327fd51" translate="yes" xml:space="preserve">
          <source>When the popup actually receives focus, activeFocus will be &lt;code&gt;true&lt;/code&gt;. For more information, see &lt;a href=&quot;qtquick-input-focus&quot;&gt;Keyboard Focus in Qt Quick&lt;/a&gt;.</source>
          <target state="translated">ポップアップが実際にフォーカスを受け取ると、activeFocusは &lt;code&gt;true&lt;/code&gt; になります。詳細について&lt;a href=&quot;qtquick-input-focus&quot;&gt;は、Qt Quickのキーボードフォーカスを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="c1bac0637a72484b23805b1cfc6b209249217f5b" translate="yes" xml:space="preserve">
          <source>When the process exits, &lt;a href=&quot;qprocess&quot;&gt;QProcess&lt;/a&gt; reenters the &lt;a href=&quot;qprocess#ProcessState-enum&quot;&gt;NotRunning&lt;/a&gt; state (the initial state), and emits &lt;a href=&quot;qprocess#finished&quot;&gt;finished&lt;/a&gt;().</source>
          <target state="translated">プロセスの終了時、&lt;a href=&quot;qprocess&quot;&gt;QProcessは&lt;/a&gt;再び入る&lt;a href=&quot;qprocess#ProcessState-enum&quot;&gt;NotRunningの&lt;/a&gt;状態（初期状態）、そして発するは&lt;a href=&quot;qprocess#finished&quot;&gt;終了します&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="166deb4e86216777686c8338ec5e1b04fbb74123" translate="yes" xml:space="preserve">
          <source>When the process exits, QProcess reenters the &lt;a href=&quot;qprocess#ProcessState-enum&quot;&gt;NotRunning&lt;/a&gt; state (the initial state), and emits &lt;a href=&quot;qprocess#finished&quot;&gt;finished&lt;/a&gt;().</source>
          <target state="translated">When the process exits, QProcess reenters the &lt;a href=&quot;qprocess#ProcessState-enum&quot;&gt;NotRunning&lt;/a&gt; state (the initial state), and emits &lt;a href=&quot;qprocess#finished&quot;&gt;finished&lt;/a&gt;().</target>
        </trans-unit>
        <trans-unit id="48359f3ebe88aa74d829db24de3e755c6a235ddd" translate="yes" xml:space="preserve">
          <source>When the property is &lt;a href=&quot;qt#CursorMoveStyle-enum&quot;&gt;Qt::LogicalMoveStyle&lt;/a&gt; (the default), within a LTR text block, increase cursor position when pressing left arrow key, decrease cursor position when pressing the right arrow key. If the text block is right to left, the opposite behavior applies.</source>
          <target state="translated">プロパティが&lt;a href=&quot;qt#CursorMoveStyle-enum&quot;&gt;Qt :: LogicalMoveStyle&lt;/a&gt;（デフォルト）の場合、LTRテキストブロック内で、左矢印キーを押すとカーソル位置が増加し、右矢印キーを押すとカーソル位置が減少します。テキストブロックが右から左の場合、反対の動作が適用されます。</target>
        </trans-unit>
        <trans-unit id="8bce9d7a133b3737e2c5d22d038d7b3c4e7911f8" translate="yes" xml:space="preserve">
          <source>When the property is set to &lt;a href=&quot;qcalendarwidget#SelectionMode-enum&quot;&gt;NoSelection&lt;/a&gt;, the user will be unable to select dates, but they can still be selected programmatically. Note that the date that is selected when the property is set to &lt;a href=&quot;qcalendarwidget#SelectionMode-enum&quot;&gt;NoSelection&lt;/a&gt; will still be the selected date of the calendar.</source>
          <target state="translated">プロパティを&lt;a href=&quot;qcalendarwidget#SelectionMode-enum&quot;&gt;NoSelection&lt;/a&gt;に設定すると、ユーザーは日付を選択できなくなりますが、プログラムで選択することはできます。プロパティが&lt;a href=&quot;qcalendarwidget#SelectionMode-enum&quot;&gt;NoSelectionに&lt;/a&gt;設定されているときに選択された日付は、カレンダーの選択された日付のままです。</target>
        </trans-unit>
        <trans-unit id="1fdcbc355a573b53369d224635c5476baea07222" translate="yes" xml:space="preserve">
          <source>When the property is set to false, these controls are hidden.</source>
          <target state="translated">プロパティを false に設定すると、これらのコントロールは非表示になります。</target>
        </trans-unit>
        <trans-unit id="aa8094b9e2a50ed05d31d86aa20fac7cfb61c508" translate="yes" xml:space="preserve">
          <source>When the renderer reaches a leaf node of the framegraph, it collects together all of the state specified by the path from the leaf node to the root node. This defines the state used to render a section of the frame. If you are interested in the internals of Qt 3D, this collection of state is called a</source>
          <target state="translated">レンダラーがフレームグラフのリーフノードに到達すると、リーフノードからルートノードまでのパスで指定されたすべての状態を収集します。これにより、フレームのセクションのレンダリングに使用されるステートが定義されます。Qt 3D の内部に興味がある方は、このステートのコレクションを</target>
        </trans-unit>
        <trans-unit id="db214d0296a6a87ece4578bc42783f851f457093" translate="yes" xml:space="preserve">
          <source>When the request is processed and a reply is available, it should be sent using the &lt;code&gt;QDBusMessage&lt;/code&gt; object that was obtained. In our example, the reply code could be something as follows:</source>
          <target state="translated">要求が処理され、応答が利用可能な場合、取得した &lt;code&gt;QDBusMessage&lt;/code&gt; オブジェクトを使用して送信する必要があります。この例では、応答コードは次のようになります。</target>
        </trans-unit>
        <trans-unit id="e9c261a6d9a18c81b00b86054be2cb1f457e3e61" translate="yes" xml:space="preserve">
          <source>When the resource is built as part of the application.</source>
          <target state="translated">リソースがアプリケーションの一部として構築されている場合。</target>
        </trans-unit>
        <trans-unit id="d423d7c636824ae52f6ad702d48541b6157aba13" translate="yes" xml:space="preserve">
          <source>When the resource is built with CMake as part of a static library.</source>
          <target state="translated">静的ライブラリの一部として CMake でリソースをビルドした場合。</target>
        </trans-unit>
        <trans-unit id="53d591cc65e5ee2ed7378bddbef5b69a1bcfde7b" translate="yes" xml:space="preserve">
          <source>When the results of an &lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt; are returned in a sequence of &lt;a href=&quot;qxmlresultitems&quot;&gt;result items&lt;/a&gt;, atomic values in the sequence are treated as instances of &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt;. Suppose that instead of serializing the results of the &lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt; as XML, we process the results programatically. Modify the standard Qt XML Patterns code sequence to call the overload of &lt;a href=&quot;qxmlquery#evaluateTo&quot;&gt;QXmlQuery::evaluateTo&lt;/a&gt;() that populates a sequence of &lt;a href=&quot;qxmlresultitems&quot;&gt;result items&lt;/a&gt; with the &lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt; results:</source>
          <target state="translated">When the results of an &lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt; are returned in a sequence of &lt;a href=&quot;qxmlresultitems&quot;&gt;result items&lt;/a&gt;, atomic values in the sequence are treated as instances of &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt;. Suppose that instead of serializing the results of the &lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt; as XML, we process the results programatically. Modify the standard Qt XML Patterns code sequence to call the overload of &lt;a href=&quot;qxmlquery#evaluateTo&quot;&gt;QXmlQuery::evaluateTo&lt;/a&gt;() that populates a sequence of &lt;a href=&quot;qxmlresultitems&quot;&gt;result items&lt;/a&gt; with the &lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt; results:</target>
        </trans-unit>
        <trans-unit id="351834125e0c92d0f208676bc4e74950d662675c" translate="yes" xml:space="preserve">
          <source>When the results of an XQuery are returned in a sequence of &lt;a href=&quot;qxmlresultitems&quot;&gt;result items&lt;/a&gt;, atomic values in the sequence are treated as instances of &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt;. Suppose that instead of serializing the results of the XQuery as XML, we process the results programatically. Modify the standard Qt XML Patterns code sequence to call the overload of &lt;a href=&quot;qxmlquery#evaluateTo&quot;&gt;QXmlQuery::evaluateTo&lt;/a&gt;() that populates a sequence of &lt;a href=&quot;qxmlresultitems&quot;&gt;result items&lt;/a&gt; with the XQuery results:</source>
          <target state="translated">XQueryの&lt;a href=&quot;qxmlresultitems&quot;&gt;結果&lt;/a&gt;が結果アイテムのシーケンスで返される場合、シーケンスの原子値は&lt;a href=&quot;qvariant&quot;&gt;QVariantの&lt;/a&gt;インスタンスとして扱われます。XQueryの結果をXMLとしてシリアル化する代わりに、プログラムで結果を処理するとします。標準のQt XMLパターンコードシーケンスを変更して、一連の&lt;a href=&quot;qxmlresultitems&quot;&gt;結果アイテム&lt;/a&gt;にXQuery結果を設定する&lt;a href=&quot;qxmlquery#evaluateTo&quot;&gt;QXmlQuery :: evaluateTo&lt;/a&gt;（）のオーバーロードを呼び出します。</target>
        </trans-unit>
        <trans-unit id="763552f30b01b66449cf8883bed75293d360c6fc" translate="yes" xml:space="preserve">
          <source>When the return value is &lt;code&gt;false&lt;/code&gt;, vertex array object support is not available. This is not an error: on systems with OpenGL 2.x or OpenGL ES 2.0 vertex array objects may not be supported. The application is free to continue execution in this case, but it then has to be prepared to operate in a VAO-less manner too. This means that instead of merely calling &lt;a href=&quot;qopenglvertexarrayobject#bind&quot;&gt;bind&lt;/a&gt;(), the value of &lt;a href=&quot;qopenglvertexarrayobject#isCreated&quot;&gt;isCreated&lt;/a&gt;() must be checked and the vertex arrays has to be initialized in the traditional way when there is no vertex array object present.</source>
          <target state="translated">戻り値が &lt;code&gt;false&lt;/code&gt; の場合、頂点配列オブジェクトのサポートは利用できません。これはエラーではありません。OpenGL2.xまたはOpenGL ES 2.0の頂点配列オブジェクトを備えたシステムではサポートされない場合があります。この場合、アプリケーションは自由に実行を続行できますが、VAOを使用せずに動作するように準備する必要があります。つまり、単に&lt;a href=&quot;qopenglvertexarrayobject#bind&quot;&gt;bind&lt;/a&gt;（）を呼び出すのではなく、&lt;a href=&quot;qopenglvertexarrayobject#isCreated&quot;&gt;isCreated&lt;/a&gt;（）の値を確認し、頂点配列オブジェクトが存在しない場合は、従来の方法で頂点配列を初期化する必要があります。</target>
        </trans-unit>
        <trans-unit id="446681578342ec9dac4cdce0d061b46969bca33b" translate="yes" xml:space="preserve">
          <source>When the run type is set to Manual, calling trigger will make the compute command be executed for the next</source>
          <target state="translated">run typeがManualに設定されている場合、triggerを呼び出すと、次の</target>
        </trans-unit>
        <trans-unit id="cbc6fc235d0cf1450284a0b09b674e76a1fb4c28" translate="yes" xml:space="preserve">
          <source>When the sample count is greater than 1, &lt;a href=&quot;qvulkanwindow&quot;&gt;QVulkanWindow&lt;/a&gt; will create a multisample color buffer instead of simply targeting the swapchain's images. The rendering in the multisample buffer will get resolved into the non-multisample buffers at the end of each frame.</source>
          <target state="translated">サンプル数が1より大きい場合、&lt;a href=&quot;qvulkanwindow&quot;&gt;QVulkanWindow&lt;/a&gt;は、スワップチェーンのイメージをターゲットにするのではなく、マルチサンプルカラーバッファーを作成します。マルチサンプルバッファーでのレンダリングは、各フレームの終わりに非マルチサンプルバッファーに解決されます。</target>
        </trans-unit>
        <trans-unit id="76d0f8de32742e81b566f43e9a337f26a0e51322" translate="yes" xml:space="preserve">
          <source>When the scene graph is initialized, which typically happens when the window becomes exposed or, in case of redirected rendering, initialization is performed &lt;a href=&quot;qquickrendercontrol#initialize&quot;&gt;via QQuickRenderControl&lt;/a&gt;, the context or device objects necessary for rendering are created automatically. This includes OpenGL contexts, Direct3D devices and device contexts, Vulkan and Metal devices. These are also queriable by application code afterwards via &lt;a href=&quot;qsgrendererinterface#getResource&quot;&gt;QSGRendererInterface&lt;/a&gt;. When using the &lt;code&gt;basic&lt;/code&gt; render loop, which performs all rendering on the GUI thread, the same context or device is used with all visible QQuickWindows. The &lt;code&gt;threaded&lt;/code&gt; render loop uses a dedicated context or device object for each rendering thread, and so for each QQuickWindow. With some graphics APIs, there is a degree of customizability provided via &lt;a href=&quot;qquickwindow#setGraphicsConfiguration&quot;&gt;setGraphicsConfiguration&lt;/a&gt;(). This makes it possible, for example, to specify the list of Vulkan extensions to enable on the &lt;code&gt;VkDevice&lt;/code&gt;. Alternatively, it is also possible to provide a set of existing context or device objects for use by the QQuickWindow, instead of letting it construct its own. This is achieved through &lt;a href=&quot;qquickwindow#setGraphicsDevice&quot;&gt;setGraphicsDevice&lt;/a&gt;().</source>
          <target state="translated">シーングラフが初期化されると、通常はウィンドウが公開されたときに発生します。リダイレクトされたレンダリングの場合、初期化は&lt;a href=&quot;qquickrendercontrol#initialize&quot;&gt;QQuickRenderControlを介して&lt;/a&gt;実行され、レンダリングに必要なコンテキストまたはデバイスオブジェクトが自動的に作成されます。これには、OpenGLコンテキスト、Direct3Dデバイスとデバイスコンテキスト、VulkanおよびMetalデバイスが含まれます。これらは、経由して、その後、アプリケーションコードでも照会可能です&lt;a href=&quot;qsgrendererinterface#getResource&quot;&gt;QSGRendererInterface&lt;/a&gt;。GUIスレッドですべてのレンダリングを実行する &lt;code&gt;basic&lt;/code&gt; レンダリングループを使用する場合、表示されているすべてのQQuickWindowsで同じコンテキストまたはデバイスが使用されます。 &lt;code&gt;threaded&lt;/code&gt; レンダリングループは、各レンダリングスレッド、および各QQuickWindowに専用のコンテキストまたはデバイスオブジェクトを使用します。一部のグラフィックAPIでは、&lt;a href=&quot;qquickwindow#setGraphicsConfiguration&quot;&gt;setGraphicsConfiguration&lt;/a&gt;（）を介してある程度のカスタマイズが可能です。これにより、たとえば、 &lt;code&gt;VkDevice&lt;/code&gt; で有効にするVulkan拡張機能のリストを指定できます。あるいは、QQuickWindowで使用するために、独自のコンテキストまたはデバイスオブジェクトのセットを提供することもできます。これは、&lt;a href=&quot;qquickwindow#setGraphicsDevice&quot;&gt;setGraphicsDevice&lt;/a&gt;（）を介して実現されます。</target>
        </trans-unit>
        <trans-unit id="a0108434fca29b4ba915f772a93d81ad894fc73c" translate="yes" xml:space="preserve">
          <source>When the scene graph processes the request, it will call &lt;a href=&quot;qquickitem#updatePolish&quot;&gt;updatePolish&lt;/a&gt;() on this item.</source>
          <target state="translated">シーングラフがリクエストを処理すると、このアイテムで&lt;a href=&quot;qquickitem#updatePolish&quot;&gt;updatePolish&lt;/a&gt;（）が呼び出されます。</target>
        </trans-unit>
        <trans-unit id="0f8384d11074379cec34a34f700b2ed0ee337a55" translate="yes" xml:space="preserve">
          <source>When the scene graph uses OpenGL, the returned texture will be using &lt;code&gt;GL_TEXTURE_2D&lt;/code&gt; as texture target and &lt;code&gt;GL_RGBA&lt;/code&gt; as internal format. With other graphics APIs, the texture format is typically &lt;code&gt;RGBA8&lt;/code&gt;. Reimplement &lt;a href=&quot;qsgtexture&quot;&gt;QSGTexture&lt;/a&gt; to create textures with different parameters.</source>
          <target state="translated">シーングラフがOpenGLを使用する場合、返されるテクスチャはテクスチャターゲットとして &lt;code&gt;GL_TEXTURE_2D&lt;/code&gt; を使用し、内部形式として &lt;code&gt;GL_RGBA&lt;/code&gt; を使用します。他のグラフィックAPIでは、テクスチャ形式は通常 &lt;code&gt;RGBA8&lt;/code&gt; です。再実装&lt;a href=&quot;qsgtexture&quot;&gt;QSGTexture&lt;/a&gt;異なるパラメータを持つテクスチャを作成します。</target>
        </trans-unit>
        <trans-unit id="79ad0782b661b14989a03456b369b188f17379b0" translate="yes" xml:space="preserve">
          <source>When the scene is active, this functions returns the scene's current focus item, or &lt;code&gt;nullptr&lt;/code&gt; if no item currently has focus. When the scene is inactive, this functions returns the item that will gain input focus when the scene becomes active.</source>
          <target state="translated">シーンがアクティブな場合、この関数はシーンの現在のフォーカスアイテムを返すか、現在フォーカスのあるアイテムがない場合は &lt;code&gt;nullptr&lt;/code&gt; を返します。シーンが非アクティブの場合、この関数は、シーンがアクティブになったときに入力フォーカスを取得するアイテムを返します。</target>
        </trans-unit>
        <trans-unit id="9df9de9d839910e5f63e81af88c3113617106dce" translate="yes" xml:space="preserve">
          <source>When the scene is rendered, any item whose width or height, transformed to the target view, is smaller that minimumRenderSize(), will not be rendered. If an item is not rendered and it clips its children items they will also not be rendered. Set this value to speed up rendering of scenes with many objects rendered on a zoomed out view.</source>
          <target state="translated">シーンがレンダリングされるとき、ターゲットビューに変換された幅や高さが minimumRenderSize()よりも小さいアイテムはレンダリングされません。アイテムがレンダリングされず、その子アイテムがクリップされた場合、それらもレンダリングされません。この値を設定すると、ズームアウトされたビューでレンダリングされた多くのオブジェクトを持つシーンのレンダリングが高速化されます。</target>
        </trans-unit>
        <trans-unit id="0a43ef95854a2f8ebe7bf8d74d52b1e7933022c7" translate="yes" xml:space="preserve">
          <source>When the script has been executed,</source>
          <target state="translated">スクリプトが実行された場合</target>
        </trans-unit>
        <trans-unit id="d413663e989f70315f8c202cae18ed2f762ace07" translate="yes" xml:space="preserve">
          <source>When the scroll bars change value, we need to update the widget position, i.e., find the part of the widget that is to be drawn in the viewport:</source>
          <target state="translated">スクロールバーの値が変わると、ウィジェットの位置を更新する必要があります。</target>
        </trans-unit>
        <trans-unit id="7e550de4fcd183b4278cd6cc624e2d0424a701cc" translate="yes" xml:space="preserve">
          <source>When the selected test users that you have added to your alpha or beta program purchase in-app products in your application, they will make actual purchases and will be charged for them. For testing purchases, you can register the e-mail addresses that should have testing access, under &lt;b&gt;Settings&lt;/b&gt; in the developer console. The users with these e-mail addresses can purchase your in-app products without being charged for the purchase, and the transaction is canceled automatically at a later stage.</source>
          <target state="translated">アルファ版またはベータ版プログラムに追加した選択したテストユーザーがアプリケーションでアプリ内製品を購入すると、実際に購入して課金されます。購入をテストするには、開発者コンソールの&lt;b&gt;[設定]&lt;/b&gt;で、テストアクセスが必要な電子メールアドレスを登録できます。これらの電子メールアドレスを持つユーザーは、課金されることなくアプリ内アイテムを購入でき、トランザクションは後の段階で自動的にキャンセルされます。</target>
        </trans-unit>
        <trans-unit id="afec543fcd1da24c4160336959d91fe3f583bac8" translate="yes" xml:space="preserve">
          <source>When the selection changes and the dialog is accepted, this signal is emitted with the (possibly empty) list of selected</source>
          <target state="translated">選択が変更されてダイアログが受理されると、この信号は選択された(空の可能性のある)</target>
        </trans-unit>
        <trans-unit id="904758544b0861950c3ab2beb21af5f0d9b36272" translate="yes" xml:space="preserve">
          <source>When the selection changes and the dialog is accepted, this signal is emitted with the (possibly empty) selected</source>
          <target state="translated">選択範囲が変更されてダイアログが受理されると、この信号は選択された(空の可能性のある)</target>
        </trans-unit>
        <trans-unit id="e7de7d16009452344b6e4636a059a260b420895c" translate="yes" xml:space="preserve">
          <source>When the selection changes for local operations and the dialog is accepted, this signal is emitted with the (possibly empty) list of</source>
          <target state="translated">ローカル操作のために選択が変更され、ダイアログが受け付けられた場合、このシグナルは</target>
        </trans-unit>
        <trans-unit id="f75edcab2adacd739be3bdebfa6bfa280edf2de0" translate="yes" xml:space="preserve">
          <source>When the selection changes for local operations and the dialog is accepted, this signal is emitted with the (possibly empty) selected</source>
          <target state="translated">ローカル操作の選択が変更され、ダイアログが受け付けられると、この信号は選択された(空の可能性のある)</target>
        </trans-unit>
        <trans-unit id="5131d672b1bc3aac6ebdcf6c8b2ac57826b0e767" translate="yes" xml:space="preserve">
          <source>When the selection mode changes and the selected item is visible</source>
          <target state="translated">選択モードが変更され、選択された項目が表示されている場合</target>
        </trans-unit>
        <trans-unit id="31520c42359fb2cf1348100dd78b79ebb3e7ffdd" translate="yes" xml:space="preserve">
          <source>When the sensor is started with buffering option, values are collected from that moment onwards. There is no pre-existing buffer that can be utilized.</source>
          <target state="translated">バッファリングオプションでセンサーを起動すると、その時点から値が収集されます。既存のバッファを利用することはできません。</target>
        </trans-unit>
        <trans-unit id="ce0fb53c6b17959f1dc8d1d19b6e99cbdbd76451" translate="yes" xml:space="preserve">
          <source>When the server receives the ClientHello message with a cookie, it generates a new cookie as described above. This new cookie is compared to the one found in the ClientHello message.</source>
          <target state="translated">サーバがクッキー付きの ClientHello メッセージを受信すると、上述のように新しいクッキーを生成します。この新しいクッキーは ClientHello メッセージで見つかったものと比較されます。</target>
        </trans-unit>
        <trans-unit id="f10b8edd85c55e75835eb4536f6583dfa1033451" translate="yes" xml:space="preserve">
          <source>When the service that this method call is sent to is already running, the method call is sent to it. If the service is not running yet, the D-Bus daemon is requested to autostart the service that is assigned to this service name. This is handled by .service files that are placed in a directory known to the D-Bus server. These files then each contain a service name and the path to a program that should be executed when this service name is requested.</source>
          <target state="translated">このメソッドコールが送信された先のサービスが既に稼働している場合は、そのサービスにメソッドコールが送信されます。サービスがまだ実行されていない場合、D-Busデーモンは、このサービス名に割り当てられたサービスを自動起動するように要求されます。これは、D-Bus サーバが知っているディレクトリに置かれた .service ファイルによって処理されます。これらのファイルには、それぞれサービス名と、このサービス名が要求されたときに実行されるプログラムへのパスが含まれています。</target>
        </trans-unit>
        <trans-unit id="c0cd1279176cf81f0c6aca038bccf60c5d81a29f" translate="yes" xml:space="preserve">
          <source>When the shader program is used normally, the shader program's id will be created on demand.</source>
          <target state="translated">シェーダプログラムを通常使用すると、シェーダプログラムのIDがオンデマンドで作成されます。</target>
        </trans-unit>
        <trans-unit id="a62f09dbef147b4bf1f669c8ce754ebe864f003f" translate="yes" xml:space="preserve">
          <source>When the signal associated with this signal transition is emitted the guard condition is evaluated. In the guard condition the arguments of the signal can be used as demonstrated in the example below.</source>
          <target state="translated">この信号遷移に関連付けられた信号が放出されると、ガード条件が評価されます。ガード条件では、以下の例で示すように、シグナルの引数を使用することができます。</target>
        </trans-unit>
        <trans-unit id="558725310a73c041dc3d4a5f9bb58e65f3b99606" translate="yes" xml:space="preserve">
          <source>When the signal is emitted, the &lt;a href=&quot;qabstractslider#sliderPosition-prop&quot;&gt;sliderPosition&lt;/a&gt; has been adjusted according to the action, but the &lt;a href=&quot;qabstractslider#value-prop&quot;&gt;value&lt;/a&gt; has not yet been propagated (meaning the &lt;a href=&quot;qabstractslider#valueChanged&quot;&gt;valueChanged&lt;/a&gt;() signal was not yet emitted), and the visual display has not been updated. In slots connected to this signal you can thus safely adjust any action by calling &lt;a href=&quot;qabstractslider#sliderPosition-prop&quot;&gt;setSliderPosition&lt;/a&gt;() yourself, based on both the action and the slider's value.</source>
          <target state="translated">シグナルが&lt;a href=&quot;qabstractslider#sliderPosition-prop&quot;&gt;発行&lt;/a&gt;されたとき、sliderPositionはアクションに応じて調整されてい&lt;a href=&quot;qabstractslider#value-prop&quot;&gt;ます&lt;/a&gt;が、値はまだ伝達されておらず（&lt;a href=&quot;qabstractslider#valueChanged&quot;&gt;valueChanged&lt;/a&gt;（）シグナルはまだ発行されていません）、ビジュアルディスプレイは更新されていません。この信号に接続されたスロットでは、アクションとスライダーの値の両方に基づいて、自分で&lt;a href=&quot;qabstractslider#sliderPosition-prop&quot;&gt;setSliderPosition&lt;/a&gt;（）を呼び出すことにより、アクションを安全に調整できます。</target>
        </trans-unit>
        <trans-unit id="908f9032f0a18c7bfa32894d77bc808328603452" translate="yes" xml:space="preserve">
          <source>When the source and target areas' sizes do not match, the source contents are stretched to fit into the target area. By passing a &lt;a href=&quot;qt#AspectRatioMode-enum&quot;&gt;Qt::AspectRatioMode&lt;/a&gt; to the rendering function you are using, you can choose to maintain or ignore the aspect ratio of the scene when the contents are stretched.</source>
          <target state="translated">ソース領域とターゲット領域のサイズが一致しない場合、ソースコンテンツはターゲット領域に収まるように引き伸ばされます。&lt;a href=&quot;qt#AspectRatioMode-enum&quot;&gt;Qt :: AspectRatioMode&lt;/a&gt;を使用しているレンダリング関数に渡すことにより、コンテンツが引き伸ばされたときにシーンのアスペクト比を維持するか無視するかを選択できます。</target>
        </trans-unit>
        <trans-unit id="8b00e9d3dd0cfb3eafd24644444bab1097364474" translate="yes" xml:space="preserve">
          <source>When the source is static, the &lt;a href=&quot;qml-qtgraphicaleffects-dropshadow#cached-prop&quot;&gt;cached&lt;/a&gt; property can be set to allocate another buffer to avoid performing the blur every time it is drawn.</source>
          <target state="translated">ソースが静的な場合、&lt;a href=&quot;qml-qtgraphicaleffects-dropshadow#cached-prop&quot;&gt;キャッシュされる&lt;/a&gt;プロパティを設定して別のバッファーを割り当て、描画されるたびにブラーを実行しないようにすることができます。</target>
        </trans-unit>
        <trans-unit id="3ad8f5ada47559d8d884af8a03a452189fd6075c" translate="yes" xml:space="preserve">
          <source>When the space key is pressed, adding an item to the model, the new item will fade in and increase in scale over 400 milliseconds as it is added to the view. Also, any item that is displaced by the addition of a new item will animate to its new position in the view over 400 milliseconds, as specified by the &lt;code&gt;displaced&lt;/code&gt; transition.</source>
          <target state="translated">スペースキーを押してモデルにアイテムを追加すると、新しいアイテムはビューに追加されるとフェードインし、400ミリ秒以上スケールが拡大します。また、新しいアイテムの追加によってディスプレイスされたアイテムは、 &lt;code&gt;displaced&lt;/code&gt; されたトランジションで指定されているように、400ミリ秒を超えてビュー内の新しい位置にアニメーション化されます。</target>
        </trans-unit>
        <trans-unit id="a9fca68b12abe757685e2f8e3f26bf8a64e1d4fe" translate="yes" xml:space="preserve">
          <source>When the space key is pressed, three items are moved from index 5 to index 1. For each moved item, the &lt;code&gt;moveTransition&lt;/code&gt; sequence presumably animates the item's color to &quot;yellow&quot;, then animates it to its final position, then changes the item color back to &quot;lightsteelblue&quot; using a &lt;a href=&quot;qml-qtquick-scriptaction&quot;&gt;ScriptAction&lt;/a&gt;. However, when run, the transition does not produce the intended result:</source>
          <target state="translated">スペースキーを押すと、3つのアイテムがインデックス5からインデックス1に移動します。移動されたアイテムごとに、 &lt;code&gt;moveTransition&lt;/code&gt; シーケンスはおそらくアイテムの色を「黄色」にアニメーション化し、最終的な位置にアニメーション化してから、アイテムの色を元に戻しますScriptActionを使用して「lightsteelblue」に&lt;a href=&quot;qml-qtquick-scriptaction&quot;&gt;変更し&lt;/a&gt;ます。ただし、実行すると、遷移は意図した結果を生成しません。</target>
        </trans-unit>
        <trans-unit id="18e0f4ff06d659b8f94b4bfba82f6378285470e7" translate="yes" xml:space="preserve">
          <source>When the string is not already a valid URL, a best guess is performed, making various assumptions.</source>
          <target state="translated">文字列がまだ有効なURLでない場合は、様々な仮定をして最善の推測を行います。</target>
        </trans-unit>
        <trans-unit id="aed377e3125e7efb3e464b02103995ebd5fa07a4" translate="yes" xml:space="preserve">
          <source>When the string is not already a valid URL, a best guess is performed, making various web related assumptions.</source>
          <target state="translated">文字列がまだ有効なURLではない場合は、Web関連の様々な仮定をしてベストな推測を行います。</target>
        </trans-unit>
        <trans-unit id="8b456c366b0bedadf7f4c24ff98787915a0f574f" translate="yes" xml:space="preserve">
          <source>When the text changes the &lt;a href=&quot;qlineedit#textChanged&quot;&gt;textChanged&lt;/a&gt;() signal is emitted; when the text changes other than by calling &lt;a href=&quot;qlineedit#text-prop&quot;&gt;setText&lt;/a&gt;() the &lt;a href=&quot;qlineedit#textEdited&quot;&gt;textEdited&lt;/a&gt;() signal is emitted; when the cursor is moved the &lt;a href=&quot;qlineedit#cursorPositionChanged&quot;&gt;cursorPositionChanged&lt;/a&gt;() signal is emitted; and when the Return or Enter key is pressed the &lt;a href=&quot;qlineedit#returnPressed&quot;&gt;returnPressed&lt;/a&gt;() signal is emitted.</source>
          <target state="translated">テキストが変更されると、&lt;a href=&quot;qlineedit#textChanged&quot;&gt;textChanged&lt;/a&gt;（）シグナルが発行されます。&lt;a href=&quot;qlineedit#text-prop&quot;&gt;setText&lt;/a&gt;（）を呼び出す以外の方法でテキストが変更された場合、&lt;a href=&quot;qlineedit#textEdited&quot;&gt;textEdited&lt;/a&gt;（）シグナルが発行されます。カーソルが移動すると、&lt;a href=&quot;qlineedit#cursorPositionChanged&quot;&gt;cursorPositionChanged&lt;/a&gt;（）シグナルが発行されます。また、ReturnまたはEnterキーが押されると、&lt;a href=&quot;qlineedit#returnPressed&quot;&gt;returnPressed&lt;/a&gt;（）シグナルが発行されます。</target>
        </trans-unit>
        <trans-unit id="76aa286a7763afdcffbd10ec6e5b9d39bd8e0eec" translate="yes" xml:space="preserve">
          <source>When the texture coordinate is even, only the fractional part is used. When odd, the texture coordinate is set to &lt;code&gt;1 - fractional part&lt;/code&gt;. This value has been introduced in Qt 5.10.</source>
          <target state="translated">テクスチャ座標が偶数の場合、小数部分のみが使用されます。奇数の場合、テクスチャ座標は &lt;code&gt;1 - fractional part&lt;/code&gt; 設定されます。この値はQt 5.10で導入されました。</target>
        </trans-unit>
        <trans-unit id="4630c4b073fe0b95c546ea9b15793119393a3a9b" translate="yes" xml:space="preserve">
          <source>When the thread is terminated, all threads waiting for the thread to finish will be woken up.</source>
          <target state="translated">スレッドが終了すると、そのスレッドが終了するのを待っているすべてのスレッドが起こされます。</target>
        </trans-unit>
        <trans-unit id="ce5657c3b84150a03593be32c94dfb5cdc403f11" translate="yes" xml:space="preserve">
          <source>When the time comes to render the scene, these 2D items' QSGNodes are passed to the Qt Quick Renderer to generate the appropriate render commands. Because the commands are done inline and take the current 3D transformation into consideration, they are rendered exactly the same as in the 2D renderer, but show up as if they were rendered in 3D.</source>
          <target state="translated">シーンをレンダリングする時が来ると、これらの2DアイテムのQSGNodesはQt Quick Rendererに渡され、適切なレンダリングコマンドが生成されます。コマンドはインラインで行われ、現在の 3D 変換を考慮に入れているため、2D レンダラーと全く同じようにレンダリングされますが、3D でレンダリングされたかのように表示されます。</target>
        </trans-unit>
        <trans-unit id="87fd2e26c464b557c4a3c28bad0e013a2a60bdaf" translate="yes" xml:space="preserve">
          <source>When the timeline is disabled, all items will have their regular values. When the timeline is enabled, the values of items are determined by the current frame and the keyframes.</source>
          <target state="translated">タイムラインを無効にすると、すべてのアイテムの値は通常の値になります。タイムラインを有効にすると、アイテムの値は現在のフレームとキーフレームによって決定されます。</target>
        </trans-unit>
        <trans-unit id="d8b9c7726d3aff7845aa848c6697f0885c506e1a" translate="yes" xml:space="preserve">
          <source>When the title bar is vertical, the &lt;a href=&quot;#vertical-ps&quot;&gt;:vertical&lt;/a&gt; pseudo class is set. In addition, depending on &lt;a href=&quot;qdockwidget#DockWidgetFeature-enum&quot;&gt;QDockWidget::DockWidgetFeature&lt;/a&gt;, the &lt;a href=&quot;#closable-ps&quot;&gt;:closable&lt;/a&gt;, &lt;a href=&quot;#floatable-ps&quot;&gt;:floatable&lt;/a&gt; and &lt;a href=&quot;#movable-ps&quot;&gt;:movable&lt;/a&gt; pseudo states are set.</source>
          <target state="translated">タイトルバーが垂直の場合、&lt;a href=&quot;#vertical-ps&quot;&gt;：vertical&lt;/a&gt;擬似クラスが設定されます。さらに、&lt;a href=&quot;qdockwidget#DockWidgetFeature-enum&quot;&gt;QDockWidget :: DockWidgetFeature&lt;/a&gt;に応じて、&lt;a href=&quot;#closable-ps&quot;&gt;：&lt;/a&gt;closable、&lt;a href=&quot;#floatable-ps&quot;&gt;：floatable&lt;/a&gt;、および&lt;a href=&quot;#movable-ps&quot;&gt;：movableの&lt;/a&gt;疑似状態が設定されます。</target>
        </trans-unit>
        <trans-unit id="dcbf714b2e65ae5994ea2abb0210ddd12a11925f" translate="yes" xml:space="preserve">
          <source>When the title bar is vertical, the &lt;a href=&quot;stylesheet-reference#vertical-ps&quot;&gt;:vertical&lt;/a&gt; pseudo class is set. In addition, depending on &lt;a href=&quot;qdockwidget#DockWidgetFeature-enum&quot;&gt;QDockWidget::DockWidgetFeature&lt;/a&gt;, the &lt;a href=&quot;stylesheet-reference#closable-ps&quot;&gt;:closable&lt;/a&gt;, &lt;a href=&quot;stylesheet-reference#floatable-ps&quot;&gt;:floatable&lt;/a&gt; and &lt;a href=&quot;stylesheet-reference#movable-ps&quot;&gt;:movable&lt;/a&gt; pseudo states are set.</source>
          <target state="translated">When the title bar is vertical, the &lt;a href=&quot;stylesheet-reference#vertical-ps&quot;&gt;:vertical&lt;/a&gt; pseudo class is set. In addition, depending on &lt;a href=&quot;qdockwidget#DockWidgetFeature-enum&quot;&gt;QDockWidget::DockWidgetFeature&lt;/a&gt;, the &lt;a href=&quot;stylesheet-reference#closable-ps&quot;&gt;:closable&lt;/a&gt;, &lt;a href=&quot;stylesheet-reference#floatable-ps&quot;&gt;:floatable&lt;/a&gt; and &lt;a href=&quot;stylesheet-reference#movable-ps&quot;&gt;:movable&lt;/a&gt; pseudo states are set.</target>
        </trans-unit>
        <trans-unit id="cf6a38dec8a46a3efde082aa9bb646234ab5665d" translate="yes" xml:space="preserve">
          <source>When the traceEnd method is called, the input method may begin processing of the data contained in the trace object. After processing the data, the input method should destroy the object. This also removes the trace rendered to the screen.</source>
          <target state="translated">traceEndメソッドが呼ばれると、入力メソッドはトレースオブジェクトに含まれるデータの処理を開始してもよい。データを処理した後、入力メソッドはオブジェクトを破棄しなければなりません。これにより、画面にレンダリングされたトレースも削除されます。</target>
        </trans-unit>
        <trans-unit id="5ed406ff23fcc29a091f1169edcf6e63e1f2b5ea" translate="yes" xml:space="preserve">
          <source>When the transition is initialized, the &lt;a href=&quot;qml-qtquick-propertyaction&quot;&gt;PropertyAction&lt;/a&gt;&lt;code&gt;target&lt;/code&gt; will be set to the respective &lt;a href=&quot;qml-qtquick-viewtransition&quot;&gt;ViewTransition&lt;/a&gt;.item for the transition and will later run with the correct item target as expected.</source>
          <target state="translated">トランジションが初期化されると、&lt;a href=&quot;qml-qtquick-propertyaction&quot;&gt;PropertyAction &lt;/a&gt; &lt;code&gt;target&lt;/code&gt; はトランジションのそれぞれの&lt;a href=&quot;qml-qtquick-viewtransition&quot;&gt;ViewTransition&lt;/a&gt; .itemに設定され、後で予想どおりに正しいアイテムターゲットで実行されます。</target>
        </trans-unit>
        <trans-unit id="a112026d8a84f01ac36a7325fb20f0691ad743ce" translate="yes" xml:space="preserve">
          <source>When the transition is initialized, the &lt;a href=&quot;qml-qtquick-propertyaction&quot;&gt;PropertyAction&lt;/a&gt;&lt;code&gt;target&lt;/code&gt; will be set to the respective ViewTransition.item for the transition and will later run with the correct item target as expected.</source>
          <target state="translated">When the transition is initialized, the &lt;a href=&quot;qml-qtquick-propertyaction&quot;&gt;PropertyAction&lt;/a&gt; &lt;code&gt;target&lt;/code&gt; will be set to the respective ViewTransition.item for the transition and will later run with the correct item target as expected.</target>
        </trans-unit>
        <trans-unit id="61999efc5174872ead16b86264178dba1fb54b01" translate="yes" xml:space="preserve">
          <source>When the transition starts, the &lt;a href=&quot;qml-qtquick-controls-stackview&quot;&gt;StackView&lt;/a&gt; will search for a transition that matches the operation executed. There are three transitions to choose from: &lt;a href=&quot;qml-qtquick-controls-stackviewdelegate#pushTransition-prop&quot;&gt;pushTransition&lt;/a&gt;, &lt;a href=&quot;qml-qtquick-controls-stackviewdelegate#popTransition-prop&quot;&gt;popTransition&lt;/a&gt;, and &lt;a href=&quot;qml-qtquick-controls-stackviewdelegate#replaceTransition-prop&quot;&gt;replaceTransition&lt;/a&gt;. Each implements how &lt;code&gt;enterItem&lt;/code&gt; should animate in, and &lt;code&gt;exitItem&lt;/code&gt; out. The transitions are collected inside a &lt;a href=&quot;qml-qtquick-controls-stackviewdelegate&quot;&gt;StackViewDelegate&lt;/a&gt; object assigned to &lt;a href=&quot;qml-qtquick-controls-stackview#delegate-prop&quot;&gt;delegate&lt;/a&gt;. By default, popTransition and replaceTransition will be the same as pushTransition, unless you set them to something else.</source>
          <target state="translated">遷移が始まると、&lt;a href=&quot;qml-qtquick-controls-stackview&quot;&gt;StackView&lt;/a&gt;は実行された操作に一致する遷移を検索します。 3つのトランジションから選択できます：&lt;a href=&quot;qml-qtquick-controls-stackviewdelegate#pushTransition-prop&quot;&gt;pushTransition&lt;/a&gt;、&lt;a href=&quot;qml-qtquick-controls-stackviewdelegate#popTransition-prop&quot;&gt;popTransition&lt;/a&gt;、および&lt;a href=&quot;qml-qtquick-controls-stackviewdelegate#replaceTransition-prop&quot;&gt;replaceTransition&lt;/a&gt;。どのように各実装 &lt;code&gt;enterItem&lt;/code&gt; がでアニメーション化、および必要があり &lt;code&gt;exitItem&lt;/code&gt; アウト。遷移は、&lt;a href=&quot;qml-qtquick-controls-stackview#delegate-prop&quot;&gt;delegateに&lt;/a&gt;割り当てられた&lt;a href=&quot;qml-qtquick-controls-stackviewdelegate&quot;&gt;StackViewDelegate&lt;/a&gt;オブジェクト内に収集されます。デフォルトでは、popTransitionとreplaceTransitionは、他に設定しない限り、pushTransitionと同じになります。</target>
        </trans-unit>
        <trans-unit id="b481fca32b65e43470c3c94e4e0c2377f104c54a" translate="yes" xml:space="preserve">
          <source>When the transition starts, the StackView will search for a transition that matches the operation executed. There are three transitions to choose from: &lt;a href=&quot;qml-qtquick-controls-stackviewdelegate#pushTransition-prop&quot;&gt;pushTransition&lt;/a&gt;, &lt;a href=&quot;qml-qtquick-controls-stackviewdelegate#popTransition-prop&quot;&gt;popTransition&lt;/a&gt;, and &lt;a href=&quot;qml-qtquick-controls-stackviewdelegate#replaceTransition-prop&quot;&gt;replaceTransition&lt;/a&gt;. Each implements how &lt;code&gt;enterItem&lt;/code&gt; should animate in, and &lt;code&gt;exitItem&lt;/code&gt; out. The transitions are collected inside a &lt;a href=&quot;qml-qtquick-controls-stackviewdelegate&quot;&gt;StackViewDelegate&lt;/a&gt; object assigned to &lt;a href=&quot;qml-qtquick-controls-stackview#delegate-prop&quot;&gt;delegate&lt;/a&gt;. By default, popTransition and replaceTransition will be the same as pushTransition, unless you set them to something else.</source>
          <target state="translated">When the transition starts, the StackView will search for a transition that matches the operation executed. There are three transitions to choose from: &lt;a href=&quot;qml-qtquick-controls-stackviewdelegate#pushTransition-prop&quot;&gt;pushTransition&lt;/a&gt;, &lt;a href=&quot;qml-qtquick-controls-stackviewdelegate#popTransition-prop&quot;&gt;popTransition&lt;/a&gt;, and &lt;a href=&quot;qml-qtquick-controls-stackviewdelegate#replaceTransition-prop&quot;&gt;replaceTransition&lt;/a&gt;. Each implements how &lt;code&gt;enterItem&lt;/code&gt; should animate in, and &lt;code&gt;exitItem&lt;/code&gt; out. The transitions are collected inside a &lt;a href=&quot;qml-qtquick-controls-stackviewdelegate&quot;&gt;StackViewDelegate&lt;/a&gt; object assigned to &lt;a href=&quot;qml-qtquick-controls-stackview#delegate-prop&quot;&gt;delegate&lt;/a&gt;. By default, popTransition and replaceTransition will be the same as pushTransition, unless you set them to something else.</target>
        </trans-unit>
        <trans-unit id="89b086c5ef03dd1208f5e9b3c1c02fa2b6600cb5" translate="yes" xml:space="preserve">
          <source>When the type is &lt;code&gt;LineString&lt;/code&gt; the data ia a &lt;a href=&quot;qgeopath&quot;&gt;QGeoPath&lt;/a&gt;.</source>
          <target state="translated">When the type is &lt;code&gt;LineString&lt;/code&gt; the data ia a &lt;a href=&quot;qgeopath&quot;&gt;QGeoPath&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="6627a2ffbe714cf5363a2179e7f88f8aa52c1d77" translate="yes" xml:space="preserve">
          <source>When the type is &lt;code&gt;MultiLineString&lt;/code&gt;, the data is a List of LineStrings.</source>
          <target state="translated">When the type is &lt;code&gt;MultiLineString&lt;/code&gt; , the data is a List of LineStrings.</target>
        </trans-unit>
        <trans-unit id="f684debed13b1e187fdab34246a351f68171025c" translate="yes" xml:space="preserve">
          <source>When the type is &lt;code&gt;MultiPoint&lt;/code&gt;, the data is a List of Points.</source>
          <target state="translated">When the type is &lt;code&gt;MultiPoint&lt;/code&gt; , the data is a List of Points.</target>
        </trans-unit>
        <trans-unit id="65efa0e33ec24ae86c53c350f1ee9d661694a7b1" translate="yes" xml:space="preserve">
          <source>When the type is &lt;code&gt;MultiPolygon&lt;/code&gt;, the data is a List of Polygons.</source>
          <target state="translated">When the type is &lt;code&gt;MultiPolygon&lt;/code&gt; , the data is a List of Polygons.</target>
        </trans-unit>
        <trans-unit id="dbc2b0b0072c28b487940a65dedc17930539d2ec" translate="yes" xml:space="preserve">
          <source>When the type is &lt;code&gt;Point&lt;/code&gt;, the data is a &lt;a href=&quot;qgeocircle&quot;&gt;QGeoCircle&lt;/a&gt; with the point coordinates stored in the center property.</source>
          <target state="translated">When the type is &lt;code&gt;Point&lt;/code&gt; , the data is a &lt;a href=&quot;qgeocircle&quot;&gt;QGeoCircle&lt;/a&gt; with the point coordinates stored in the center property.</target>
        </trans-unit>
        <trans-unit id="23332dc4a0d7fb448b924e422877dc966cb8e77a" translate="yes" xml:space="preserve">
          <source>When the type is &lt;code&gt;Polygon&lt;/code&gt;, the data is a &lt;a href=&quot;qgeopolygon&quot;&gt;QGeoPolygon&lt;/a&gt; (holes are supported).</source>
          <target state="translated">When the type is &lt;code&gt;Polygon&lt;/code&gt; , the data is a &lt;a href=&quot;qgeopolygon&quot;&gt;QGeoPolygon&lt;/a&gt; (holes are supported).</target>
        </trans-unit>
        <trans-unit id="37e47c478e8b7cde10b9e2d57a87561d517265a6" translate="yes" xml:space="preserve">
          <source>When the underlying rendering API is OpenGL, this function should return a mask where each bit represents graphics states changed by the &lt;a href=&quot;qsgrendernode#render&quot;&gt;render&lt;/a&gt;() function:</source>
          <target state="translated">When the underlying rendering API is OpenGL, this function should return a mask where each bit represents graphics states changed by the &lt;a href=&quot;qsgrendernode#render&quot;&gt;render&lt;/a&gt;() function:</target>
        </trans-unit>
        <trans-unit id="3151bd80e155cc711d1dfb4c28d12fa02d1b602b" translate="yes" xml:space="preserve">
          <source>When the update behavior is set to &lt;code&gt;NoPartialUpdate&lt;/code&gt;, there is no separate framebuffer object. In this case the returned value is the ID of the default framebuffer.</source>
          <target state="translated">更新動作が &lt;code&gt;NoPartialUpdate&lt;/code&gt; に設定されている場合、個別のフレームバッファーオブジェクトはありません。この場合、戻り値はデフォルトのフレームバッファのIDです。</target>
        </trans-unit>
        <trans-unit id="38a70a3f9388a6d25db9221a160c7eb74efac68f" translate="yes" xml:space="preserve">
          <source>When the update mode is set to &lt;a href=&quot;qopenglwindow#UpdateBehavior-enum&quot;&gt;NoPartialUpdate&lt;/a&gt;, there is no difference between this function and &lt;a href=&quot;qopenglwindow#paintGL&quot;&gt;paintGL&lt;/a&gt;(), performing rendering in either of them leads to the same result.</source>
          <target state="translated">更新モードが&lt;a href=&quot;qopenglwindow#UpdateBehavior-enum&quot;&gt;NoPartialUpdate&lt;/a&gt;に設定されている場合、この関数と&lt;a href=&quot;qopenglwindow#paintGL&quot;&gt;paintGL&lt;/a&gt;（）の間に違いはなく、どちらかでレンダリングを実行しても同じ結果になります。</target>
        </trans-unit>
        <trans-unit id="90a4d8b7976d6357d0d51104a651d5693a247b6e" translate="yes" xml:space="preserve">
          <source>When the update mode is set to &lt;code&gt;NoPartialUpdate&lt;/code&gt;, there is no difference between this function and &lt;a href=&quot;qopenglwindow#paintGL&quot;&gt;paintGL&lt;/a&gt;(), performing rendering in either of them leads to the same result.</source>
          <target state="translated">更新モードが &lt;code&gt;NoPartialUpdate&lt;/code&gt; に設定されている場合、この関数と&lt;a href=&quot;qopenglwindow#paintGL&quot;&gt;paintGL&lt;/a&gt;（）の間に違いはなく、どちらかでレンダリングを実行しても同じ結果になります。</target>
        </trans-unit>
        <trans-unit id="7fbf049a32dd0640f6dd43ed769625f8cee33a4d" translate="yes" xml:space="preserve">
          <source>When the user attempts to close a window, the &lt;a href=&quot;qml-qtquick-window-window#closing-signal&quot;&gt;closing&lt;/a&gt; signal will be emitted. You can force the window to stay open (for example to prompt the user to save changes) by writing an &lt;code&gt;onClosing&lt;/code&gt; handler and setting &lt;code&gt;close.accepted = false&lt;/code&gt;.</source>
          <target state="translated">ユーザーがウィンドウを閉じようとすると、&lt;a href=&quot;qml-qtquick-window-window#closing-signal&quot;&gt;閉じる&lt;/a&gt;信号が送信されます。 &lt;code&gt;onClosing&lt;/code&gt; ハンドラーを記述し、 &lt;code&gt;close.accepted = false&lt;/code&gt; を設定することで、ウィンドウを強制的に開いたままにすることができます（たとえば、ユーザーに変更を保存するように求める）。</target>
        </trans-unit>
        <trans-unit id="9eeacf8e7be359603aa85acba91a0d62e601147b" translate="yes" xml:space="preserve">
          <source>When the user attempts to close a window, the &lt;a href=&quot;qml-window#closing-signal&quot;&gt;closing&lt;/a&gt; signal will be emitted. You can force the window to stay open (for example to prompt the user to save changes) by writing an &lt;code&gt;onClosing&lt;/code&gt; handler and setting &lt;code&gt;close.accepted = false&lt;/code&gt;.</source>
          <target state="translated">ユーザーがウィンドウを閉じようとすると、&lt;a href=&quot;qml-window#closing-signal&quot;&gt;閉じる&lt;/a&gt;信号が発せられます。 &lt;code&gt;onClosing&lt;/code&gt; ハンドラーを記述し、 &lt;code&gt;close.accepted = false&lt;/code&gt; を設定することで、ウィンドウを強制的に開いたままにすることができます（たとえば、ユーザーに変更を保存するように求める）。</target>
        </trans-unit>
        <trans-unit id="f089242c4828bfa1c4990e6f2f452f8aa6f68fa8" translate="yes" xml:space="preserve">
          <source>When the user clicks anywhere within the rectangle, &lt;code&gt;sendMessage()&lt;/code&gt; is called, triggering the &lt;code&gt;WorkerScript.onMessage()&lt;/code&gt; handler in &lt;code&gt;script.mjs&lt;/code&gt;. This in turn sends a reply message that is then received by the &lt;code&gt;onMessage()&lt;/code&gt; handler of &lt;code&gt;myWorker&lt;/code&gt;.</source>
          <target state="translated">ユーザーが四角形内の任意の場所をクリックすると、 &lt;code&gt;sendMessage()&lt;/code&gt; が呼び出され、 &lt;code&gt;WorkerScript.onMessage()&lt;/code&gt; ハンドラーが &lt;code&gt;script.mjs&lt;/code&gt; ます。これにより、応答メッセージが送信され、 &lt;code&gt;myWorker&lt;/code&gt; の &lt;code&gt;onMessage()&lt;/code&gt; ハンドラによって受信されます。</target>
        </trans-unit>
        <trans-unit id="9e806fe43114f8c1140dcea68026addc98aa8292" translate="yes" xml:space="preserve">
          <source>When the user enters a new string in an editable combobox, the widget may or may not insert it, and it can insert it in several locations. The default policy is &lt;a href=&quot;qcombobox#InsertPolicy-enum&quot;&gt;InsertAtBottom&lt;/a&gt; but you can change this using &lt;a href=&quot;qcombobox#insertPolicy-prop&quot;&gt;setInsertPolicy&lt;/a&gt;().</source>
          <target state="translated">ユーザーが編集可能なコンボボックスに新しい文字列を入力すると、ウィジェットはそれを挿入する場合と挿入しない場合があり、複数の場所に挿入できます。デフォルトのポリシーは&lt;a href=&quot;qcombobox#InsertPolicy-enum&quot;&gt;InsertAtBottom&lt;/a&gt;ですが、&lt;a href=&quot;qcombobox#insertPolicy-prop&quot;&gt;setInsertPolicy&lt;/a&gt;（）を使用してこれを変更できます。</target>
        </trans-unit>
        <trans-unit id="7a33c93bf7f01a0e67730291d39734d96a1a1c84" translate="yes" xml:space="preserve">
          <source>When the user has finished editing the value in the spin box, the view asks the delegate to store the edited value in the model by calling the &lt;a href=&quot;qabstractitemdelegate#setModelData&quot;&gt;setModelData()&lt;/a&gt; function.</source>
          <target state="translated">ユーザーがスピンボックスの値の編集を完了すると、ビューはデリゲートに&lt;a href=&quot;qabstractitemdelegate#setModelData&quot;&gt;setModelData（）&lt;/a&gt;関数を呼び出して編集された値をモデルに保存するように要求します。</target>
        </trans-unit>
        <trans-unit id="92fa0779d8d3b6243f1940a69448d7de41b9ecd3" translate="yes" xml:space="preserve">
          <source>When the user presses or releases a key, the following occurs:</source>
          <target state="translated">ユーザーがキーを押したり離したりすると、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="0593af2ddbf4e80d0b0321de8e5024100fcd08c9" translate="yes" xml:space="preserve">
          <source>When the user presses the first key on a keyboard, an input context is created. This input context will contain a string of the typed characters.</source>
          <target state="translated">ユーザーがキーボードの最初のキーを押すと、入力コンテキストが作成されます。この入力コンテキストには、入力された文字の文字列が含まれます。</target>
        </trans-unit>
        <trans-unit id="17b14a687e250bb8ebffd69d26cedf3fe0182667" translate="yes" xml:space="preserve">
          <source>When the user presses the shortcut key indicated by this label, the keyboard focus is transferred to the label's buddy widget.</source>
          <target state="translated">ユーザーがこのラベルで示されたショートカットキーを押すと、キーボードのフォーカスがラベルのバディウィジェットに転送されます。</target>
        </trans-unit>
        <trans-unit id="d8718161543f49d12ebfce2a24d45c7fc9cbd16e" translate="yes" xml:space="preserve">
          <source>When the user resizes the window, the size will move in steps of &lt;a href=&quot;qwindow#sizeIncrement&quot;&gt;sizeIncrement&lt;/a&gt;().&lt;a href=&quot;qwindow#width-prop&quot;&gt;width&lt;/a&gt;() pixels horizontally and &lt;a href=&quot;qwindow#sizeIncrement&quot;&gt;sizeIncrement&lt;/a&gt;().&lt;a href=&quot;qwindow#height-prop&quot;&gt;height&lt;/a&gt;() pixels vertically, with &lt;a href=&quot;qwindow#baseSize&quot;&gt;baseSize&lt;/a&gt;() as the basis.</source>
          <target state="translated">ユーザーがウィンドウのサイズを変更すると、サイズは&lt;a href=&quot;qwindow#sizeIncrement&quot;&gt;sizeIncrement&lt;/a&gt;（）のステップで移動します。水平方向の&lt;a href=&quot;qwindow#width-prop&quot;&gt;幅&lt;/a&gt;（）ピクセルと&lt;a href=&quot;qwindow#sizeIncrement&quot;&gt;サイズ増分&lt;/a&gt;（）。&lt;a href=&quot;qwindow#baseSize&quot;&gt;baseSize&lt;/a&gt;（）を基準とした垂直方向の&lt;a href=&quot;qwindow#height-prop&quot;&gt;高さ&lt;/a&gt;（）ピクセル。</target>
        </trans-unit>
        <trans-unit id="9e453a57cc507da9b2902f79db75133ddc061ac8" translate="yes" xml:space="preserve">
          <source>When the user resizes the window, the size will move in steps of sizeIncrement().&lt;a href=&quot;qwidget#width-prop&quot;&gt;width&lt;/a&gt;() pixels horizontally and sizeIncrement.&lt;a href=&quot;qwidget#height-prop&quot;&gt;height&lt;/a&gt;() pixels vertically, with &lt;a href=&quot;qwidget#baseSize-prop&quot;&gt;baseSize&lt;/a&gt;() as the basis. Preferred widget sizes are for non-negative integers</source>
          <target state="translated">ユーザーがウィンドウのサイズを変更すると、サイズはsizeIncrement（）のステップで移動します。水平方向の&lt;a href=&quot;qwidget#width-prop&quot;&gt;幅&lt;/a&gt;（）ピクセルとsizeIncrement。&lt;a href=&quot;qwidget#baseSize-prop&quot;&gt;baseSize&lt;/a&gt;（）を基準とした垂直方向の&lt;a href=&quot;qwidget#height-prop&quot;&gt;高さ&lt;/a&gt;（）ピクセル。推奨されるウィジェットサイズは負でない整数用です</target>
        </trans-unit>
        <trans-unit id="e9e23684b39294a601601a344c7bf87e80ee521d" translate="yes" xml:space="preserve">
          <source>When the user selects a new font, the &lt;a href=&quot;qfontcombobox#currentFontChanged&quot;&gt;currentFontChanged&lt;/a&gt;() signal is emitted in addition to &lt;a href=&quot;qcombobox#currentIndexChanged&quot;&gt;currentIndexChanged&lt;/a&gt;().</source>
          <target state="translated">ユーザーが新しいフォントを選択すると、&lt;a href=&quot;qcombobox#currentIndexChanged&quot;&gt;currentIndexChanged&lt;/a&gt;（）に加えて&lt;a href=&quot;qfontcombobox#currentFontChanged&quot;&gt;currentFontChanged&lt;/a&gt;（）シグナルが発行されます。</target>
        </trans-unit>
        <trans-unit id="4da46bc51fcc82534c06603bbbd59ebe7d50ebb4" translate="yes" xml:space="preserve">
          <source>When the user selects an item in the list, the input method responds to the event in the &lt;a href=&quot;qml-qtquick-virtualkeyboard-inputmethod#selectionListItemSelected-method&quot;&gt;InputMethod::selectionListItemSelected&lt;/a&gt; method callback.</source>
          <target state="translated">ユーザーがリスト内の項目を選択すると、インプットメソッドは&lt;a href=&quot;qml-qtquick-virtualkeyboard-inputmethod#selectionListItemSelected-method&quot;&gt;InputMethod :: selectionListItemSelected&lt;/a&gt;メソッドコールバックのイベントに応答します。</target>
        </trans-unit>
        <trans-unit id="c109346817c0c000e5fe1e4e0a164874e2cf7eaf" translate="yes" xml:space="preserve">
          <source>When the user selects an item in the usual way, the selection is cleared and the new item selected. However, if the user presses the Ctrl key when clicking on an item, the clicked item gets toggled and all other items are left untouched. If the user presses the Shift key while clicking on an item, all items between the current item and the clicked item are selected or unselected, depending on the state of the clicked item. Multiple items can be selected by dragging the mouse over them.</source>
          <target state="translated">通常の方法で項目を選択すると、選択されていた項目はクリアされ、新しい項目が選択されます。ただし、項目をクリックしているときに Ctrl キーを押すと、クリックした項目がトグルされ、他の項目はそのままになります。アイテムをクリックしているときに Shift キーを押すと、クリックしたアイテムの状態に応じて、現在のアイテムとクリックしたアイテムの間のアイテムがすべて選択されたり、選択されなかったりします。複数の項目をマウスでドラッグして選択することができます。</target>
        </trans-unit>
        <trans-unit id="239784d9cf52110a5610a0352def4b21651a1ec0" translate="yes" xml:space="preserve">
          <source>When the user selects an item in the usual way, the selection is cleared and the new item selected. However, if the user presses the Shift key while clicking on an item, all items between the current item and the clicked item are selected or unselected, depending on the state of the clicked item.</source>
          <target state="translated">通常の方法で項目を選択すると、選択範囲はクリアされ、新しい項目が選択されます。ただし、ユーザが項目をクリックしている状態でShiftキーを押すと、クリックした項目の状態に応じて、現在の項目とクリックした項目の間のすべての項目が選択されたり、選択されなかったりする。</target>
        </trans-unit>
        <trans-unit id="b63a60a0cef1fb52e61ed1b641072b5077221c1a" translate="yes" xml:space="preserve">
          <source>When the user selects an item in the usual way, the selection status of that item is toggled and the other items are left alone. Multiple items can be toggled by dragging the mouse over them.</source>
          <target state="translated">ユーザが通常の方法で項目を選択すると、その項目の選択状態がトグルされ、他の項目は放置されます。複数の項目は、マウスをドラッグすることで切り替えることができます。</target>
        </trans-unit>
        <trans-unit id="48e3c32ce598a7fbfd8868c52569756e58fdf828" translate="yes" xml:space="preserve">
          <source>When the user selects an item, any already-selected item becomes unselected. It is possible for the user to deselect the selected item by pressing the Ctrl key when clicking the selected item.</source>
          <target state="translated">ユーザーが項目を選択すると、既に選択されている項目は非選択状態になります。選択されている項目をクリックした状態で Ctrl キーを押すことで、選択されている項目の選択を解除することができます。</target>
        </trans-unit>
        <trans-unit id="432b100478d155eb5754fdf1b8519f514ff3bcfa" translate="yes" xml:space="preserve">
          <source>When the user selects an item, any already-selected item becomes unselected. It is possible for the user to deselect the selected item.</source>
          <target state="translated">ユーザーが項目を選択すると、既に選択されている項目は非選択状態になります。選択されている項目の選択を解除することができます。</target>
        </trans-unit>
        <trans-unit id="40c8efdfbff08c7bc6b912d42d8681b4819162a6" translate="yes" xml:space="preserve">
          <source>When the user triggers a step whilst holding the &lt;a href=&quot;qt#KeyboardModifier-enum&quot;&gt;Qt::ControlModifier&lt;/a&gt;, &lt;a href=&quot;qabstractspinbox&quot;&gt;QAbstractSpinBox&lt;/a&gt; steps by 10 instead of making a single step. This step modifier affects wheel events, key events and interaction with the spinbox buttons. Note that on &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt;, Control corresponds to the Command key.</source>
          <target state="translated">ユーザーが&lt;a href=&quot;qt#KeyboardModifier-enum&quot;&gt;Qt :: ControlModifier&lt;/a&gt;を押しながらステップをトリガーすると、&lt;a href=&quot;qabstractspinbox&quot;&gt;QAbstractSpinBox&lt;/a&gt;は1つのステップを作成する代わりに10 ずつステップします。このステップ修飾子は、ホイールイベント、キーイベント、およびスピンボックスボタンの操作に影響します。&lt;a href=&quot;internationalization#macos&quot;&gt;macOSでは&lt;/a&gt;、ControlはCommandキーに対応することに注意してください。</target>
        </trans-unit>
        <trans-unit id="34d7335e57478339ba71faccb6f2bf5634476339" translate="yes" xml:space="preserve">
          <source>When the user triggers a step whilst holding the &lt;a href=&quot;qt#KeyboardModifier-enum&quot;&gt;Qt::ControlModifier&lt;/a&gt;, QAbstractSpinBox steps by 10 instead of making a single step. This step modifier affects wheel events, key events and interaction with the spinbox buttons. Note that on macOS, Control corresponds to the Command key.</source>
          <target state="translated">When the user triggers a step whilst holding the &lt;a href=&quot;qt#KeyboardModifier-enum&quot;&gt;Qt::ControlModifier&lt;/a&gt;, QAbstractSpinBox steps by 10 instead of making a single step. This step modifier affects wheel events, key events and interaction with the spinbox buttons. Note that on macOS, Control corresponds to the Command key.</target>
        </trans-unit>
        <trans-unit id="3de1fafb709edfc8e71149ea8ddc3fd104d090bd" translate="yes" xml:space="preserve">
          <source>When the user types the &lt;a href=&quot;qkeysequence&quot;&gt;key sequence&lt;/a&gt; for a given shortcut, the shortcut's &lt;a href=&quot;qshortcut#activated&quot;&gt;activated&lt;/a&gt;() signal is emitted. (In the case of ambiguity, the &lt;a href=&quot;qshortcut#activatedAmbiguously&quot;&gt;activatedAmbiguously&lt;/a&gt;() signal is emitted.) A shortcut is &quot;listened for&quot; by Qt's event loop when the shortcut's parent widget is receiving events.</source>
          <target state="translated">ユーザーが特定のショートカットの&lt;a href=&quot;qkeysequence&quot;&gt;キーシーケンス&lt;/a&gt;を入力すると、ショートカットの&lt;a href=&quot;qshortcut#activated&quot;&gt;アクティブ化された&lt;/a&gt;（）シグナルが発行されます。（あいまいな場合は、&lt;a href=&quot;qshortcut#activatedAmbiguously&quot;&gt;activatedAmbiguously&lt;/a&gt;（）シグナルが発行されます。）ショートカットは、ショートカットの親ウィジェットがイベントを受け取っているときにQtのイベントループによって「リッスン」されます。</target>
        </trans-unit>
        <trans-unit id="07467a76ec47313778f1640f3f2853d179a4c454" translate="yes" xml:space="preserve">
          <source>When the user uses the arrows to change the spin box's value the value will be incremented/decremented by the amount of the singleStep. The default value is 1. Setting a singleStep value of less than 0 does nothing.</source>
          <target state="translated">ユーザーが矢印を使ってスピンボックスの値を変更すると、値は singleStep の値によって増減します。デフォルト値は1で、singleStepの値を0未満に設定しても何もしません。</target>
        </trans-unit>
        <trans-unit id="1a7fbae2e2cb0c5b805b7e0f23104cafdd5b43a3" translate="yes" xml:space="preserve">
          <source>When the user uses the arrows to change the spin box's value the value will be incremented/decremented by the amount of the singleStep. The default value is 1.0. Setting a singleStep value of less than 0 does nothing.</source>
          <target state="translated">ユーザーが矢印を使ってスピンボックスの値を変更すると、値はsingleStepの量だけ増減します。デフォルト値は1.0です。singleStepの値を0未満に設定しても何もしません。</target>
        </trans-unit>
        <trans-unit id="55b72162369d6d7fefe6c5eeff0d064284c9c1e9" translate="yes" xml:space="preserve">
          <source>When the user wants to purchase a product, call &lt;a href=&quot;qinappproduct#purchase&quot;&gt;QInAppProduct::purchase&lt;/a&gt;() on the product. This launches a platform-specific, asynchronous process to purchase the product, for example by requesting the user's password and confirmation of the purchase. In most cases, you must make sure that the application UI is not accepting input while the purchase request is being processed, as this is not handled automatically on all platforms.</source>
          <target state="translated">ユーザーが商品を購入する場合は、商品で&lt;a href=&quot;qinappproduct#purchase&quot;&gt;QInAppProduct :: purchase&lt;/a&gt;（）を呼び出します。これにより、たとえばユーザーのパスワードと購入の確認を要求することにより、製品を購入するためのプラットフォーム固有の非同期プロセスが起動します。ほとんどの場合、購入リクエストの処理中にアプリケーションUIが入力を受け付けないようにする必要があります。これは、すべてのプラットフォームで自動的に処理されるわけではないためです。</target>
        </trans-unit>
        <trans-unit id="53e007fcb539e15013065a7fcca5f31963711f7f" translate="yes" xml:space="preserve">
          <source>When the view changes, the &lt;code&gt;inputViewChanged&lt;/code&gt; signal is emitted.</source>
          <target state="translated">ビューが変更されると、 &lt;code&gt;inputViewChanged&lt;/code&gt; シグナルが発行されます。</target>
        </trans-unit>
        <trans-unit id="6bf292009c41ae3996b782ddaf7f2171babcb34d" translate="yes" xml:space="preserve">
          <source>When the view is initialized, the view will create all the necessary items for the view, then animate them to their correct positions within the view over one second.</source>
          <target state="translated">ビューが初期化されると、ビューに必要なすべてのアイテムが作成され、1秒間にビュー内の正しい位置にアニメートされます。</target>
        </trans-unit>
        <trans-unit id="bf9267cdf13126ffe2807371579c3234aa2c025f" translate="yes" xml:space="preserve">
          <source>When the widget is embedded, its state (e.g., visible, enabled, geometry, size hints) is copied into the proxy widget. If the embedded widget is explicitly hidden or disabled, the proxy widget will become explicitly hidden or disabled after embedding is complete. The class documentation has a full overview over the shared state.</source>
          <target state="translated">ウィジェットが埋め込まれると、その状態(可視、有効、ジオメトリ、サイズヒントなど)がプロキシウィジェットにコピーされます。埋め込まれたウィジェットが明示的に隠されているか無効化されている場合、プロキシウィジェットは埋め込み完了後に明示的に隠されているか無効化された状態になります。クラスのドキュメントには、共有状態の概要が記載されています。</target>
        </trans-unit>
        <trans-unit id="0eed7c85c5152e46b5d87508ebba22a259d445d6" translate="yes" xml:space="preserve">
          <source>When the widget needs to generate a set of preview pages, a &lt;a href=&quot;qprintpreviewwidget#paintRequested&quot;&gt;paintRequested&lt;/a&gt;() signal will be emitted from the widget. Connect a slot to this signal, and draw onto the &lt;a href=&quot;qprinter&quot;&gt;QPrinter&lt;/a&gt; passed in as a signal parameter. Call &lt;a href=&quot;qprinter#newPage&quot;&gt;QPrinter::newPage&lt;/a&gt;(), to start a new page in the preview.</source>
          <target state="translated">ウィジェットが一連のプレビューページを生成する必要がある場合、&lt;a href=&quot;qprintpreviewwidget#paintRequested&quot;&gt;paintRequested&lt;/a&gt;（）シグナルがウィジェットから発行されます。スロットをこの信号に接続し、信号パラメーターとして渡された&lt;a href=&quot;qprinter&quot;&gt;QPrinterに&lt;/a&gt;描画します。&lt;a href=&quot;qprinter#newPage&quot;&gt;QPrinter :: newPage&lt;/a&gt;（）を呼び出して、プレビューで新しいページを開始します。</target>
        </trans-unit>
        <trans-unit id="17365a086c8d8f3707090a7d37af79afa83d7862" translate="yes" xml:space="preserve">
          <source>When the widget's window and the related OpenGL resources are not yet initialized, the return value is the format that has been set via &lt;a href=&quot;qopenglwidget#setFormat&quot;&gt;setFormat&lt;/a&gt;().</source>
          <target state="translated">ウィジェットのウィンドウと関連するOpenGLリソースがまだ初期化されていない場合、戻り値は&lt;a href=&quot;qopenglwidget#setFormat&quot;&gt;setFormat&lt;/a&gt;（）で設定されたフォーマットです。</target>
        </trans-unit>
        <trans-unit id="43847dedad7e1417643232066e6b313499c2942c" translate="yes" xml:space="preserve">
          <source>When the widget-style font and palette propagation is enabled, font and palette changes made through Qt Style Sheets will behave as though the user had manually called the corresponding &lt;a href=&quot;qwidget#palette-prop&quot;&gt;QWidget::setPalette&lt;/a&gt;() and &lt;a href=&quot;qwidget#font-prop&quot;&gt;QWidget::setFont&lt;/a&gt;() methods on all of the QWidgets targeted by the style sheet. If this would have caused propagation in C++, it will cause propagation in style sheets and vice versa.</source>
          <target state="translated">ウィジェットスタイルのフォントとパレットの伝播を有効にすると、フォントとパレットは、ユーザーが手動で対応すると呼ばれたかのように動作しますQtのスタイルシートを介して行った変更&lt;a href=&quot;qwidget#palette-prop&quot;&gt;はQWidget :: setPalette&lt;/a&gt;（）と&lt;a href=&quot;qwidget#font-prop&quot;&gt;のQWidget ::のsetFont&lt;/a&gt;のすべての（）メソッドをスタイルシートの対象となるQWidgets。これによりC ++での伝播が発生した場合は、スタイルシートでの伝播が発生します。逆も同様です。</target>
        </trans-unit>
        <trans-unit id="9300bab43b3b48a079567bdbc19485dd9b08456a" translate="yes" xml:space="preserve">
          <source>When the width of a &lt;a href=&quot;qtquickcontrols-changes-qt6#combobox&quot;&gt;ComboBox&lt;/a&gt; is not large enough to display text, that text is elided. Depending on which parts of the text are elided, this can make selecting an item difficult for the end user. An efficient way of ensuring that a &lt;a href=&quot;qtquickcontrols-changes-qt6#combobox&quot;&gt;ComboBox&lt;/a&gt; is wide enough to avoid text being elided is to set a width that is known to be large enough:</source>
          <target state="translated">&lt;a href=&quot;qtquickcontrols-changes-qt6#combobox&quot;&gt;ComboBox&lt;/a&gt;の幅がテキストを表示するのに十分な大きさでない場合、そのテキストは省略されます。テキストのどの部分が省略されているかによっては、これによりエンドユーザーがアイテムを選択するのが難しくなる可能性があります。&lt;a href=&quot;qtquickcontrols-changes-qt6#combobox&quot;&gt;ComboBox&lt;/a&gt;がテキストの省略を回避するのに十分な幅であることを確認する効率的な方法は、十分に大きいことがわかっている幅を設定することです。</target>
        </trans-unit>
        <trans-unit id="d46c08525c4ed676f1a7ccbb248c7080204996de" translate="yes" xml:space="preserve">
          <source>When the window is made visible, the content is updated automatically. Further updates can be requested by calling &lt;a href=&quot;qwindow#requestUpdate&quot;&gt;QWindow::requestUpdate&lt;/a&gt;(). To render continuously, call &lt;a href=&quot;qwindow#requestUpdate&quot;&gt;requestUpdate&lt;/a&gt;() after &lt;a href=&quot;qvulkanwindow#frameReady&quot;&gt;frameReady&lt;/a&gt;().</source>
          <target state="translated">ウィンドウが表示されると、コンテンツは自動的に更新されます。&lt;a href=&quot;qwindow#requestUpdate&quot;&gt;QWindow :: requestUpdate&lt;/a&gt;（）を呼び出すことで、更なる更新をリクエストできます。継続的にレンダリングするには、&lt;a href=&quot;qwindow#requestUpdate&quot;&gt;frameReady&lt;/a&gt;（）の後に&lt;a href=&quot;qvulkanwindow#frameReady&quot;&gt;requestUpdate&lt;/a&gt;（）を呼び出します。</target>
        </trans-unit>
        <trans-unit id="5c3efeb67a9891aa4bb21e727fa3ddd55e1376a5" translate="yes" xml:space="preserve">
          <source>When the window is not exposed, it is shown by the application but it is still not showing in the windowing system, so the application should minimize animations and other graphical activities.</source>
          <target state="translated">ウィンドウが露出していない場合は、アプリケーションによって表示されているにもかかわらず、ウィンドウが表示されていない状態なので、アプリケーションはアニメーションなどのグラフィカルな動作を最小限に抑える必要があります。</target>
        </trans-unit>
        <trans-unit id="d0885d46fa70f463e2de0a22a1a8f497582d4166" translate="yes" xml:space="preserve">
          <source>When the window is not exposed, it is shown by the application but it is still not showing in the windowing system, so the application should minimize rendering and other graphical activities.</source>
          <target state="translated">ウィンドウが露出していない場合は、アプリケーションによって表示されているにもかかわらず、ウィンドウが表示されていない状態なので、アプリケーションはレンダリングなどのグラフィカルな動作を最小限に抑える必要があります。</target>
        </trans-unit>
        <trans-unit id="298ff46be999c313b755a4569e2c0f50522cc6cd" translate="yes" xml:space="preserve">
          <source>When the window state changes, the widget receives a &lt;a href=&quot;qwidget#changeEvent&quot;&gt;changeEvent&lt;/a&gt;() of type &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent::WindowStateChange&lt;/a&gt;.</source>
          <target state="translated">ウィンドウ状態の変化は、ウィジェットが受信した場合&lt;a href=&quot;qwidget#changeEvent&quot;&gt;ChangeEventの&lt;/a&gt;タイプの（）&lt;a href=&quot;qevent#Type-enum&quot;&gt;QEventを:: WindowStateChangeを&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4430665a811124c03a76c8e73574aa765dc47098" translate="yes" xml:space="preserve">
          <source>When there are too many tabs in a tab bar for its size, the tab bar can either choose to expand its size or to add buttons that allow you to scroll through the tabs.</source>
          <target state="translated">タブバーのサイズに対してタブが多すぎる場合、タブバーはサイズを拡大するか、タブをスクロールできるボタンを追加するかを選択することができます。</target>
        </trans-unit>
        <trans-unit id="328188d436a703678d89704707e3862740fee438" translate="yes" xml:space="preserve">
          <source>When these images are loaded by QML, it looks for a matching image provider and calls its &lt;a href=&quot;qquickimageprovider#requestImage&quot;&gt;requestImage&lt;/a&gt;() or &lt;a href=&quot;qquickimageprovider#requestPixmap&quot;&gt;requestPixmap&lt;/a&gt;() method (depending on its &lt;a href=&quot;qquickimageprovider#imageType&quot;&gt;imageType&lt;/a&gt;()) to load the image. The method is called with the &lt;code&gt;id&lt;/code&gt; parameter set to &quot;yellow&quot; for the first image, and &quot;red&quot; for the second.</source>
          <target state="translated">これらの画像がQMLによって読み込まれると、一致する画像プロバイダーを探し、その&lt;a href=&quot;qquickimageprovider#requestImage&quot;&gt;requestImage&lt;/a&gt;（）または&lt;a href=&quot;qquickimageprovider#requestPixmap&quot;&gt;requestPixmap&lt;/a&gt;（）メソッド（その&lt;a href=&quot;qquickimageprovider#imageType&quot;&gt;imageType&lt;/a&gt;（）に依存）を呼び出して画像を読み込みます。このメソッドは、最初の画像では &lt;code&gt;id&lt;/code&gt; パラメータを「黄色」に、2番目の画像では「赤」に設定して呼び出されます。</target>
        </trans-unit>
        <trans-unit id="280d1db6d231e9b9540bfc8acf026c5df8031216" translate="yes" xml:space="preserve">
          <source>When this argument is used, a second argument is required, which specifies the module whose classes are to be listed. QDoc generates a table containing those classes. Each class is listed with the text of its &lt;a href=&quot;11-qdoc-commands-specialcontent#brief-command&quot;&gt;\brief&lt;/a&gt; command.</source>
          <target state="translated">この引数を使用する場合、2番目の引数が必要です。これは、クラスをリストするモジュールを指定します。QDocはそれらのクラスを含むテーブルを生成します。各クラスは、&lt;a href=&quot;11-qdoc-commands-specialcontent#brief-command&quot;&gt;\ brief&lt;/a&gt;コマンドのテキストとともにリストされます。</target>
        </trans-unit>
        <trans-unit id="ed8f319625948db2e4a131ba28a779620a6396b0" translate="yes" xml:space="preserve">
          <source>When this attribute is set, the native on-screen virtual keyboard will not be shown automatically when a text input widget gains focus on a system without a physical keyboard. Currently supported on the Windows platform only. This value was added in 5.15</source>
          <target state="translated">この属性が設定されている場合、物理キーボードのないシステムでテキスト入力ウィジェットがフォーカスを獲得したときに、画面上のネイティブの仮想キーボードは自動的に表示されません。現在のところ、Windowsプラットフォームでのみサポートされています。この値は5.15で追加されました。</target>
        </trans-unit>
        <trans-unit id="f22d3c8dc2e110f12cd3eeae061d95d96bf789a7" translate="yes" xml:space="preserve">
          <source>When this attribute is true Qt will not do the remapping, and pressing the Command modifier will result in &lt;a href=&quot;qt#KeyboardModifier-enum&quot;&gt;Qt::MetaModifier&lt;/a&gt;, while pressing the Control modifier will result in &lt;a href=&quot;qt#KeyboardModifier-enum&quot;&gt;Qt::ControlModifier&lt;/a&gt;.</source>
          <target state="translated">この属性がtrueの場合、Qtは再マッピングを行わず、Commandモディファイアを押すと&lt;a href=&quot;qt#KeyboardModifier-enum&quot;&gt;Qt :: MetaModifier&lt;/a&gt;になり、Controlモディファイアを押すと&lt;a href=&quot;qt#KeyboardModifier-enum&quot;&gt;Qt :: ControlModifierになり&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="278d7e1255bd96582c739bd15df2833e0be8a868" translate="yes" xml:space="preserve">
          <source>When this code is loaded by the engine, it creates an object tree with a &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle&lt;/a&gt; object at the root; this object has a &lt;a href=&quot;qml-qtquick-gradient&quot;&gt;Gradient&lt;/a&gt; child object, which in turn has two &lt;a href=&quot;qml-qtquick-gradientstop&quot;&gt;GradientStop&lt;/a&gt; children.</source>
          <target state="translated">このコードがエンジンによって読み込まれると、ルートに&lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle&lt;/a&gt;オブジェクトを含むオブジェクトツリーが作成されます。このオブジェクトには&lt;a href=&quot;qml-qtquick-gradient&quot;&gt;Gradient&lt;/a&gt;子オブジェクトがあり、次に2つの&lt;a href=&quot;qml-qtquick-gradientstop&quot;&gt;GradientStop&lt;/a&gt;子があります。</target>
        </trans-unit>
        <trans-unit id="bef518027d6e82c3441e9a6878947589c6671093" translate="yes" xml:space="preserve">
          <source>When this event occurs it is customary to show a &lt;a href=&quot;qmenu&quot;&gt;QMenu&lt;/a&gt; with a context menu, if this is relevant to the context.</source>
          <target state="translated">このイベントが発生すると、コンテキストに関連する場合は、通常、コンテキストメニュー付きの&lt;a href=&quot;qmenu&quot;&gt;QMenu&lt;/a&gt;が表示されます。</target>
        </trans-unit>
        <trans-unit id="1c5aa92c276833ef89412fc07466f6fcff736ad0" translate="yes" xml:space="preserve">
          <source>When this feature is on (the default is off), clicking on a header section sorts the items according to that column. By clicking repeatedly, the user can alternate between ascending and descending order.</source>
          <target state="translated">この機能がオンの場合(デフォルトはオフ)、ヘッダーセクションをクリックすると、その列に応じて項目がソートされます。繰り返しクリックすることで、昇順と降順を切り替えることができます。</target>
        </trans-unit>
        <trans-unit id="5aafd154ba0fcb35eccabb15e1a7d96cc39747d6" translate="yes" xml:space="preserve">
          <source>When this function is called after the program has been linked, the program will need to be relinked for the change to take effect.</source>
          <target state="translated">プログラムがリンクされた後にこの関数を呼び出すと、変更が有効になるようにプログラムを再リンクする必要があります。</target>
        </trans-unit>
        <trans-unit id="c9186348bdc67fdf223b859066aa3c52ea35863b" translate="yes" xml:space="preserve">
          <source>When this function is called multiple times in quick succession with the same function as its first argument, that function will be called only once.</source>
          <target state="translated">この関数が同じ関数を第一引数にして複数回連続して呼び出された場合、その関数は一度だけ呼び出されます。</target>
        </trans-unit>
        <trans-unit id="5cd069345d45f7e507dfd16fbeee6b09a2a2033f" translate="yes" xml:space="preserve">
          <source>When this function is called, any graphics commands enqueued by the scenegraph are submitted to the context or command queue, whichever is applicable.</source>
          <target state="translated">この関数が呼び出されると、scenegraphで待ち受けにされている全てのグラフィックコマンドが、コンテキストまたはコマンドキューのいずれかに投入されます。</target>
        </trans-unit>
        <trans-unit id="398a779395d95b160c8ff7f5a1fe0f7602c5e153" translate="yes" xml:space="preserve">
          <source>When this function is called, the purchase process is initiated. At some point during the process, the &lt;a href=&quot;qinappstore#transactionReady&quot;&gt;QInAppStore::transactionReady&lt;/a&gt;() signal is emitted, and the slot registered earlier is called. In this function, you can save data about a successful purchase so that it survives across application runs. After verifying that the data has been stored, finalize the transaction. If the transaction fails, display information about the failure to the user and finalize the transaction.</source>
          <target state="translated">この関数が呼び出されると、購入プロセスが開始されます。プロセス中のある時点で、&lt;a href=&quot;qinappstore#transactionReady&quot;&gt;QInAppStore :: transactionReady&lt;/a&gt;（）シグナルが発行され、以前に登録されたスロットが呼び出されます。この関数では、成功した購入に関するデータを保存して、アプリケーションが実行されても存続できるようにすることができます。データが保存されたことを確認したら、トランザクションを完了します。トランザクションが失敗した場合は、失敗に関する情報をユーザーに表示し、トランザクションを完了します。</target>
        </trans-unit>
        <trans-unit id="f8d7fdf287ae94d30f4f05c7d5f8dbbfbde44b75" translate="yes" xml:space="preserve">
          <source>When this function is not called at all, and the equivalent environment variable &lt;code&gt;QSG_RHI_BACKEND&lt;/code&gt; is not set either, the scene graph will choose the graphics API to use based on the platform.</source>
          <target state="translated">この関数がまったく呼び出されず、同等の環境変数 &lt;code&gt;QSG_RHI_BACKEND&lt;/code&gt; も設定されていない場合、シーングラフはプラットフォームに基づいて使用するグラフィックAPIを選択します。</target>
        </trans-unit>
        <trans-unit id="0a8adea584e450f3c916a9833293ed806c718263" translate="yes" xml:space="preserve">
          <source>When this hint is set and it is applicable, the clip region will be generated from &lt;a href=&quot;qsgclipnode#clipRect&quot;&gt;clipRect&lt;/a&gt;() rather than &lt;a href=&quot;qsgbasicgeometrynode#geometry&quot;&gt;geometry&lt;/a&gt;().</source>
          <target state="translated">このヒントが設定されて適用可能である場合、クリップ領域は&lt;a href=&quot;qsgbasicgeometrynode#geometry&quot;&gt;ジオメトリ&lt;/a&gt;（）ではなく&lt;a href=&quot;qsgclipnode#clipRect&quot;&gt;clipRect&lt;/a&gt;（）から生成されます。</target>
        </trans-unit>
        <trans-unit id="25c548388c50d22300a6331c81e8413c5cbc46fc" translate="yes" xml:space="preserve">
          <source>When this is enabled, qmake will process all libraries linked to by the application and find their meta-information. qmake will use this to determine the relevant linking information, specifically adding values to the application project file's list of &lt;a href=&quot;qmake-variable-reference#defines&quot;&gt;DEFINES&lt;/a&gt; as well as &lt;a href=&quot;qmake-variable-reference#libs&quot;&gt;LIBS&lt;/a&gt;. Once qmake has processed this file, it will then look through the newly introduced libraries in the &lt;code&gt;LIBS&lt;/code&gt; variable, and find their dependent .prl files, continuing until all libraries have been resolved. At this point, the Makefile is created as usual, and the libraries are linked explicitly against the application.</source>
          <target state="translated">これが有効になっていると、qmakeはアプリケーションによってリンクされているすべてのライブラリを処理し、それらのメタ情報を見つけます。 qmakeは、具体的には、アプリケーションプロジェクトファイルのリストに値を追加し、関連するリンク情報を決定するためにこれを使用します&lt;a href=&quot;qmake-variable-reference#defines&quot;&gt;DEFINES&lt;/a&gt;と同様に&lt;a href=&quot;qmake-variable-reference#libs&quot;&gt;LIBS&lt;/a&gt;。 qmakeのは、このファイルを処理すると、それはその後に新たに導入されたライブラリに目を通すだろう &lt;code&gt;LIBS&lt;/code&gt; の変数、およびその依存.prlファイルを見つけ、すべてのライブラリが解決されるまで続けます。この時点で、Makefileは通常どおり作成され、ライブラリはアプリケーションに対して明示的にリンクされます。</target>
        </trans-unit>
        <trans-unit id="e1c2654888290051c11e8d6edd467ee92c8e7a88" translate="yes" xml:space="preserve">
          <source>When this is repeated for each leaf node in the framegraph, the frame is complete and the renderer calls &lt;a href=&quot;qopenglcontext#swapBuffers&quot;&gt;QOpenGLContext::swapBuffers&lt;/a&gt;() to display the frame.</source>
          <target state="translated">フレームグラフの各リーフノードでこれが繰り返されると、フレームが完成し、レンダラーが&lt;a href=&quot;qopenglcontext#swapBuffers&quot;&gt;QOpenGLContext :: swapBuffers&lt;/a&gt;（）を呼び出してフレームを表示します。</target>
        </trans-unit>
        <trans-unit id="ec52fd20354c1402a9e5c8a902314529744bb69a" translate="yes" xml:space="preserve">
          <source>When this method is called it additionally sets either the &lt;a href=&quot;qml-qtquick-controls-textarea#selectionStart-prop&quot;&gt;selectionStart&lt;/a&gt; or the &lt;a href=&quot;qml-qtquick-controls-textarea#selectionEnd-prop&quot;&gt;selectionEnd&lt;/a&gt; (whichever was at the previous cursor position) to the specified position. This allows you to easily extend and contract the selected text range.</source>
          <target state="translated">このメソッドが呼び出されると、&lt;a href=&quot;qml-qtquick-controls-textarea#selectionStart-prop&quot;&gt;selectionStart&lt;/a&gt;または&lt;a href=&quot;qml-qtquick-controls-textarea#selectionEnd-prop&quot;&gt;selectionEnd&lt;/a&gt;（前のカーソル位置にあった方）のいずれかを指定された位置にさらに設定します。これにより、選択したテキスト範囲を簡単に拡張および縮小できます。</target>
        </trans-unit>
        <trans-unit id="0b402258b559da375e5607dca734ac8dba2f14ee" translate="yes" xml:space="preserve">
          <source>When this method is called it additionally sets either the &lt;a href=&quot;qml-qtquick-textedit#selectionStart-prop&quot;&gt;selectionStart&lt;/a&gt; or the &lt;a href=&quot;qml-qtquick-textedit#selectionEnd-prop&quot;&gt;selectionEnd&lt;/a&gt; (whichever was at the previous cursor position) to the specified position. This allows you to easily extend and contract the selected text range.</source>
          <target state="translated">このメソッドが呼び出されると、&lt;a href=&quot;qml-qtquick-textedit#selectionStart-prop&quot;&gt;selectionStart&lt;/a&gt;または&lt;a href=&quot;qml-qtquick-textedit#selectionEnd-prop&quot;&gt;selectionEnd&lt;/a&gt;（前のカーソル位置にあった方）のいずれかを指定された位置にさらに設定します。これにより、選択したテキスト範囲を簡単に拡張および縮小できます。</target>
        </trans-unit>
        <trans-unit id="81183ac8bcf1dd186d0806619cf0a4b7150e1d76" translate="yes" xml:space="preserve">
          <source>When this method is called it additionally sets either the &lt;a href=&quot;qml-qtquick-textinput#selectionStart-prop&quot;&gt;selectionStart&lt;/a&gt; or the &lt;a href=&quot;qml-qtquick-textinput#selectionEnd-prop&quot;&gt;selectionEnd&lt;/a&gt; (whichever was at the previous cursor position) to the specified position. This allows you to easily extend and contract the selected text range.</source>
          <target state="translated">このメソッドが呼び出されると、&lt;a href=&quot;qml-qtquick-textinput#selectionStart-prop&quot;&gt;selectionStart&lt;/a&gt;または&lt;a href=&quot;qml-qtquick-textinput#selectionEnd-prop&quot;&gt;selectionEnd&lt;/a&gt;（前のカーソル位置にあった方）のいずれかを指定された位置にさらに設定します。これにより、選択したテキスト範囲を簡単に拡張および縮小できます。</target>
        </trans-unit>
        <trans-unit id="3be9f15b12fa7586e346464303593068b7d2ddce" translate="yes" xml:space="preserve">
          <source>When this method is called, or when the user tries to close the window by its title bar button, the &lt;a href=&quot;qml-qtquick-window-window#closing-signal&quot;&gt;closing&lt;/a&gt; signal will be emitted. If there is no handler, or the handler does not revoke permission to close, the window will subsequently close. If the &lt;a href=&quot;qguiapplication#quitOnLastWindowClosed-prop&quot;&gt;QGuiApplication::quitOnLastWindowClosed&lt;/a&gt; property is &lt;code&gt;true&lt;/code&gt;, and there are no other windows open, the application will quit.</source>
          <target state="translated">このメソッドが呼び出されるか、ユーザーがタイトルバーボタンでウィンドウを閉じようとすると、&lt;a href=&quot;qml-qtquick-window-window#closing-signal&quot;&gt;閉じる&lt;/a&gt;信号が発生します。ハンドラーがない場合、またはハンドラーが閉じる許可を取り消さない場合、ウィンドウはその後閉じます。場合&lt;a href=&quot;qguiapplication#quitOnLastWindowClosed-prop&quot;&gt;QGuiApplication :: quitOnLastWindowClosedの&lt;/a&gt;プロパティがあり &lt;code&gt;true&lt;/code&gt; 、そして他のウィンドウが開い存在しない、アプリケーションが終了します。</target>
        </trans-unit>
        <trans-unit id="a97005f25bbdd2a327396d2cf3176ffcd4f75915" translate="yes" xml:space="preserve">
          <source>When this method is called, or when the user tries to close the window by its title bar button, the &lt;a href=&quot;qml-window#closing-signal&quot;&gt;closing&lt;/a&gt; signal will be emitted. If there is no handler, or the handler does not revoke permission to close, the window will subsequently close. If the &lt;a href=&quot;qguiapplication#quitOnLastWindowClosed-prop&quot;&gt;QGuiApplication::quitOnLastWindowClosed&lt;/a&gt; property is &lt;code&gt;true&lt;/code&gt;, and there are no other windows open, the application will quit.</source>
          <target state="translated">このメソッドが呼び出されたとき、またはユーザーがタイトルバーボタンでウィンドウを閉じようとすると、&lt;a href=&quot;qml-window#closing-signal&quot;&gt;閉じる&lt;/a&gt;信号が発行されます。ハンドラーがない場合、またはハンドラーが閉じる権限を取り消さない場合、ウィンドウはその後閉じられます。場合&lt;a href=&quot;qguiapplication#quitOnLastWindowClosed-prop&quot;&gt;QGuiApplication :: quitOnLastWindowClosedの&lt;/a&gt;プロパティがあり &lt;code&gt;true&lt;/code&gt; 、そして他のウィンドウが開い存在しない、アプリケーションが終了します。</target>
        </trans-unit>
        <trans-unit id="4ca058932c3f0b4bb0aeaff104b696065bebb8ff" translate="yes" xml:space="preserve">
          <source>When this option is enabled, qmake will process all libraries linked to by the application and find their meta-information (see &lt;a href=&quot;qmake-advanced-usage#libdepend&quot;&gt;Library Dependencies&lt;/a&gt; for more info).</source>
          <target state="translated">このオプションを有効にすると、qmakeはアプリケーションによってリンクされたすべてのライブラリを処理し、それらのメタ情報を見つけます（詳細については、&lt;a href=&quot;qmake-advanced-usage#libdepend&quot;&gt;ライブラリの依存関係&lt;/a&gt;を参照してください）。</target>
        </trans-unit>
        <trans-unit id="e954b1e0533aa197768aa31122dd76fd088a3473" translate="yes" xml:space="preserve">
          <source>When this option is set, &lt;a href=&quot;qtextline#naturalTextWidth&quot;&gt;QTextLine::naturalTextWidth&lt;/a&gt;() and &lt;a href=&quot;qtextline#naturalTextRect&quot;&gt;QTextLine::naturalTextRect&lt;/a&gt;() will return a value that includes the width of trailing spaces in the text; otherwise this width is excluded.</source>
          <target state="translated">このオプションを設定すると、&lt;a href=&quot;qtextline#naturalTextWidth&quot;&gt;QTextLine :: naturalTextWidth&lt;/a&gt;（）および&lt;a href=&quot;qtextline#naturalTextRect&quot;&gt;QTextLine :: naturalTextRect&lt;/a&gt;（）は、テキストの末尾のスペースの幅を含む値を返します。それ以外の場合、この幅は除外されます。</target>
        </trans-unit>
        <trans-unit id="7e4b2c0654bf40a5f19574c6810ff26dfd4d2ceb" translate="yes" xml:space="preserve">
          <source>When this option is set, &lt;a href=&quot;qtextline#naturalTextWidth&quot;&gt;QTextLine::naturalTextWidth&lt;/a&gt;() and naturalTextRect() will return a value that includes the width of trailing spaces in the text; otherwise this width is excluded.</source>
          <target state="translated">このオプションを設定すると、&lt;a href=&quot;qtextline#naturalTextWidth&quot;&gt;QTextLine :: naturalTextWidth&lt;/a&gt;（）およびnaturalTextRect（）は、テキストの末尾のスペースの幅を含む値を返します。それ以外の場合、この幅は除外されます。</target>
        </trans-unit>
        <trans-unit id="f271981227ef20d87cc64f0259c4f19f522399df" translate="yes" xml:space="preserve">
          <source>When this property changes, a scrollable view should automatically scroll itself in such a way as to ensure that this region is visible; for example, it could try to position the upper-left corner near the upper-left of its own viewport, subject to the constraints of the scrollable area.</source>
          <target state="translated">このプロパティが変更されると、スクロール可能なビューは、この領域が確実に表示されるような方法で自動的にスクロールしなければなりません;例えば、スクロール可能な領域の制約を受けて、自身のビューポートの左上の近くに左上の角を配置しようとすることができます。</target>
        </trans-unit>
        <trans-unit id="7c42f5c456658d1e6cc7ae9de66d3b8a114c246a" translate="yes" xml:space="preserve">
          <source>When this property changes, the &lt;code&gt;topLevelChanged()&lt;/code&gt; signal is emitted.</source>
          <target state="translated">このプロパティが変更されると、 &lt;code&gt;topLevelChanged()&lt;/code&gt; シグナルが発行されます。</target>
        </trans-unit>
        <trans-unit id="2e8947f71029eebb8d494bf176ad2f080cf20f26" translate="yes" xml:space="preserve">
          <source>When this property is &lt;code&gt;false&lt;/code&gt;, it's not possible to drag the dial across the from and to values.</source>
          <target state="translated">このプロパティが &lt;code&gt;false&lt;/code&gt; の場合、ダイアルをfrom値とto値の間でドラッグすることはできません。</target>
        </trans-unit>
        <trans-unit id="2cf377eb087a92958eeac23380aef05f26d062d5" translate="yes" xml:space="preserve">
          <source>When this property is &lt;code&gt;true&lt;/code&gt; (the default), the next month, previous month, month selection, year selection controls are shown on top.</source>
          <target state="translated">このプロパティが &lt;code&gt;true&lt;/code&gt; （デフォルト）の場合、翌月、前月、月の選択、年の選択コントロールが上部に表示されます。</target>
        </trans-unit>
        <trans-unit id="e001d3612422e2e98bda1806f3de5d100dc0ffd9" translate="yes" xml:space="preserve">
          <source>When this property is &lt;code&gt;true&lt;/code&gt; and the &lt;a href=&quot;qml-qtquick3d-model#tessellationMode-prop&quot;&gt;tessellationMode&lt;/a&gt; is not Model.NoTessellation, a wireframe is displayed to highlight the additional geometry created by the tessellation generator.</source>
          <target state="translated">When this property is &lt;code&gt;true&lt;/code&gt; and the &lt;a href=&quot;qml-qtquick3d-model#tessellationMode-prop&quot;&gt;tessellationMode&lt;/a&gt; is not Model.NoTessellation, a wireframe is displayed to highlight the additional geometry created by the tessellation generator.</target>
        </trans-unit>
        <trans-unit id="7c6308ea5aac847e02c97a8f794ffa729d592dd4" translate="yes" xml:space="preserve">
          <source>When this property is &lt;code&gt;true&lt;/code&gt; object outside the frustum will be culled, meaning they will not be rendered. By default this property is set to &lt;code&gt;false&lt;/code&gt;, but for complex scene where a lot of the objects are outside the camera frustum it might be beneficial to enable frustum culling.</source>
          <target state="translated">When this property is &lt;code&gt;true&lt;/code&gt; object outside the frustum will be culled, meaning they will not be rendered. By default this property is set to &lt;code&gt;false&lt;/code&gt; , but for complex scene where a lot of the objects are outside the camera frustum it might be beneficial to enable frustum culling.</target>
        </trans-unit>
        <trans-unit id="70e8e0ceef6e0e89be2d8ebe69b7b194ca42b59e" translate="yes" xml:space="preserve">
          <source>When this property is &lt;code&gt;true&lt;/code&gt;, objects outside the camera frustum will be culled, meaning they will not be passed to the renderer. By default this property is set to &lt;code&gt;false&lt;/code&gt;. For scenes where all or most objects are inside the camera frustum, frustum culling is an unnecessary performance overhead. But for complex scenes where large parts are located outside the camera's view, enabling frustum culling may improve performance.</source>
          <target state="translated">このプロパティが &lt;code&gt;true&lt;/code&gt; の場合、カメラの錐台の外側にあるオブジェクトはカリングされます。つまり、レンダラーには渡されません。デフォルトでは、このプロパティは &lt;code&gt;false&lt;/code&gt; に設定されています。すべてまたはほとんどのオブジェクトがカメラの錐台内にあるシーンの場合、錐台カリングは不要なパフォーマンスオーバーヘッドです。ただし、大きなパーツがカメラの視野の外にある複雑なシーンでは、錐台カリングを有効にするとパフォーマンスが向上する場合があります。</target>
        </trans-unit>
        <trans-unit id="9c6d22c0bbc6a53d1f13528b30f888d0610b3d76" translate="yes" xml:space="preserve">
          <source>When this property is &lt;code&gt;true&lt;/code&gt;, shadows can be cast onto this item. So the shadow map is applied to this model by the renderer.</source>
          <target state="translated">When this property is &lt;code&gt;true&lt;/code&gt; , shadows can be cast onto this item. So the shadow map is applied to this model by the renderer.</target>
        </trans-unit>
        <trans-unit id="ae3ac6a5c511fb8757d09b3ced0b9ec19d6b694d" translate="yes" xml:space="preserve">
          <source>When this property is &lt;code&gt;true&lt;/code&gt;, the geometry of this model is used when rendering to the shadow maps.</source>
          <target state="translated">When this property is &lt;code&gt;true&lt;/code&gt; , the geometry of this model is used when rendering to the shadow maps.</target>
        </trans-unit>
        <trans-unit id="5435f7b9bf2979fd82564870b5b12500055a6cde" translate="yes" xml:space="preserve">
          <source>When this property is enabled it scatters the edges of the ambient occlusion shadow bands to improve smoothness (at the risk of sometimes producing obvious patterned artifacts).</source>
          <target state="translated">このプロパティを有効にすると、アンビエントオクルージョンシャドウバンドのエッジを散乱させて滑らかさを向上させます(明らかなパターン化されたアーチファクトが発生することがありますが)。</target>
        </trans-unit>
        <trans-unit id="0e970705b8c985988e06ca43a11e32d86795a38e" translate="yes" xml:space="preserve">
          <source>When this property is enabled more shortcuts are taken to approximate the light contributes of the light probe at the expense of quality.</source>
          <target state="translated">このプロパティを有効にすると、品質を犠牲にしてもライトプローブの光の寄与度を近似するためのショートカットが増えます。</target>
        </trans-unit>
        <trans-unit id="7dac3a5e67061b28cd41b0e9edb5be2c4bdef12b" translate="yes" xml:space="preserve">
          <source>When this property is enabled temporal antialiasing will be used.</source>
          <target state="translated">このプロパティを有効にすると、一時的なアンチエイリアシングが使用されます。</target>
        </trans-unit>
        <trans-unit id="3fd821d6a927b06c3741219adce2a495492f9002" translate="yes" xml:space="preserve">
          <source>When this property is enabled, the light will cast shadows. The default value is false.</source>
          <target state="translated">このプロパティを有効にすると、ライトは影を落とします。デフォルト値は false です。</target>
        </trans-unit>
        <trans-unit id="100dd97a4fb38bb0a31c18fad05f76672fb1531a" translate="yes" xml:space="preserve">
          <source>When this property is enabled, the material will use vertex colors from the mesh. These will be multiplied by any other colors specified for the material.</source>
          <target state="translated">このプロパティを有効にすると、マテリアルはメッシュの頂点カラーを使用します。これらの色は、マテリアルに指定された他の色と掛け合わされます。</target>
        </trans-unit>
        <trans-unit id="bf43a8d4ad0de35433838bc85feefa148dfa808b" translate="yes" xml:space="preserve">
          <source>When this property is set and the &lt;a href=&quot;qml-qtquick-springanimation#velocity-prop&quot;&gt;velocity&lt;/a&gt; value is greater than 0, the &lt;a href=&quot;qml-qtquick-springanimation#velocity-prop&quot;&gt;velocity&lt;/a&gt; limits the maximum speed.</source>
          <target state="translated">このプロパティが設定されていて、&lt;a href=&quot;qml-qtquick-springanimation#velocity-prop&quot;&gt;速度の&lt;/a&gt;値が0より大きい場合、&lt;a href=&quot;qml-qtquick-springanimation#velocity-prop&quot;&gt;速度&lt;/a&gt;は最大速度を制限します。</target>
        </trans-unit>
        <trans-unit id="bf92afa5571a2082abd019a22b3b5e076f89feca" translate="yes" xml:space="preserve">
          <source>When this property is set any current decoding is stopped, and any audio buffers are discarded.</source>
          <target state="translated">このプロパティが設定されている場合、現在のデコーディングはすべて停止され、オーディオバッファはすべて破棄されます。</target>
        </trans-unit>
        <trans-unit id="6f37ded37bad8b26d03755297e0d0d1d2d468416" translate="yes" xml:space="preserve">
          <source>When this property is set the tab widget frame is not rendered. This mode is useful for showing document-type pages where the page covers most of the tab widget area.</source>
          <target state="translated">このプロパティが設定されている場合、タブウィジェットのフレームはレンダリングされません。このモードは、タブウィジェットの領域の大部分をページが覆っているドキュメントタイプのページを表示する場合に便利です。</target>
        </trans-unit>
        <trans-unit id="bb1f39d69438f440f90e503c95bb71197010e140" translate="yes" xml:space="preserve">
          <source>When this property is set to &lt;a href=&quot;qcalendarwidget#SelectionMode-enum&quot;&gt;SingleSelection&lt;/a&gt;, the user can select a date within the minimum and maximum allowed dates, using either the mouse or the keyboard.</source>
          <target state="translated">このプロパティが&lt;a href=&quot;qcalendarwidget#SelectionMode-enum&quot;&gt;SingleSelection&lt;/a&gt;に設定されている場合、ユーザーは、マウスまたはキーボードのいずれかを使用して、許可されている最小日付と最大日付内の日付を選択できます。</target>
        </trans-unit>
        <trans-unit id="4747a4a028b83a9e0e586a4b5157956a8881beee" translate="yes" xml:space="preserve">
          <source>When this property is set to &lt;a href=&quot;qt#CursorMoveStyle-enum&quot;&gt;Qt::VisualMoveStyle&lt;/a&gt;, the line edit will use visual movement style. Pressing the left arrow key will always cause the cursor to move left, regardless of the text's writing direction. The same behavior applies to right arrow key.</source>
          <target state="translated">このプロパティが&lt;a href=&quot;qt#CursorMoveStyle-enum&quot;&gt;Qt :: VisualMoveStyleに&lt;/a&gt;設定されている場合、ラインエディットは視覚的な移動スタイルを使用します。左矢印キーを押すと、テキストの書き込み方向に関係なく、カーソルは常に左に移動します。同じ動作が右矢印キーにも当てはまります。</target>
        </trans-unit>
        <trans-unit id="6350e57b73a741c92757bc74c17a0770b6b20fee" translate="yes" xml:space="preserve">
          <source>When this property is set to &lt;code&gt;false&lt;/code&gt;, the Z-buffer is not used, the depth test is skipped, and all objects, including fully opaque ones, are rendered in one go sorted back to front.</source>
          <target state="translated">このプロパティが &lt;code&gt;false&lt;/code&gt; に設定されている場合、Zバッファは使用されず、深度テストはスキップされ、完全に不透明なオブジェクトを含むすべてのオブジェクトが一度にレンダリングされ、前後に並べ替えられます。</target>
        </trans-unit>
        <trans-unit id="f10c2ce3dfc1214b29770522b194d17ecde31cf0" translate="yes" xml:space="preserve">
          <source>When this property is set to &lt;code&gt;false&lt;/code&gt;, the Z-buffer is not written and tested against, the depth test is skipped, and all objects, including fully opaque ones, are rendered in one go, sorted back to front.</source>
          <target state="translated">このプロパティが &lt;code&gt;false&lt;/code&gt; に設定されている場合、Zバッファは書き込まれず、テストされません。深度テストはスキップされ、完全に不透明なオブジェクトを含むすべてのオブジェクトが一度にレンダリングされ、後ろから前に並べ替えられます。</target>
        </trans-unit>
        <trans-unit id="710938eb5f7574c93c37fb85ff7b7153741a117c" translate="yes" xml:space="preserve">
          <source>When this property is set to &lt;code&gt;true&lt;/code&gt;, the model's materials take shadow contribution from shadow casting lights into account.</source>
          <target state="translated">このプロパティが &lt;code&gt;true&lt;/code&gt; に設定されている場合、モデルのマテリアルはシャドウキャスティングライトからのシャドウの寄与を考慮に入れます。</target>
        </trans-unit>
        <trans-unit id="0edc644e371fc7727ba54cb716093cdd57e0cd9c" translate="yes" xml:space="preserve">
          <source>When this property is set, the given folder will be treated as the root in the file system, so that you can only traverse subfolders within it.</source>
          <target state="translated">このプロパティが設定されている場合、指定されたフォルダはファイルシステムのルートとして扱われ、その中のサブフォルダのみを辿ることができます。</target>
        </trans-unit>
        <trans-unit id="b2d44a4363149f5868c0478951229cd0f684ca40" translate="yes" xml:space="preserve">
          <source>When this property is set, the specified opacity is also applied individually to child items. This may have an unintended effect in some circumstances. For example in the second set of rectangles below, the red rectangle has specified an opacity of 0.5, which affects the opacity of its blue child rectangle even though the child has not specified an opacity.</source>
          <target state="translated">このプロパティを設定すると、指定した不透明度が子アイテムにも個別に適用されます。これは、状況によっては意図しない効果があるかもしれません。例えば、下の2つ目の長方形のセットでは、赤の長方形が0.5の不透明度を指定しており、その子が不透明度を指定していないにもかかわらず、その子の青の長方形の不透明度に影響します。</target>
        </trans-unit>
        <trans-unit id="1f016f4e737a52e8f462fcd37b82c141a90134d0" translate="yes" xml:space="preserve">
          <source>When this property is true, the Node (and its children) can be visible.</source>
          <target state="translated">このプロパティが真の場合、ノード(とその子)を表示することができます。</target>
        </trans-unit>
        <trans-unit id="d9f5748d3f3423c22760b03f83dc84f38b1f3b1f" translate="yes" xml:space="preserve">
          <source>When this propery is set to false text edit will accept only plain text input from the user. For example through clipboard or drag and drop.</source>
          <target state="translated">この適切性がfalseに設定されている場合、テキスト編集はユーザーからのプレーンテキスト入力のみを受け付けます。例えば、クリップボードやドラッグ&amp;ドロップでの入力などです。</target>
        </trans-unit>
        <trans-unit id="aec3729055d25b18cd030179a5d7fbd186ecaf3f" translate="yes" xml:space="preserve">
          <source>When this restore policy is set, the machine will automatically restore all properties. If it enters a state where a given property is not set, it will first search the hierarchy of ancestors to see if the property is defined there. If it is, the property will be restored to the value defined by the closest ancestor. If not, it will be restored to its initial value (i.e. the value of the property before any property assignments in states were executed.)</source>
          <target state="translated">この復元ポリシーを設定すると、マシンは自動的にすべてのプロパティを復元します。指定されたプロパティが設定されていない状態になると、まず先祖の階層を検索して、そのプロパティがそこで定義されているかどうかを確認します。定義されている場合、プロパティは、最も近い祖先によって定義された値にリストアされます。そうでない場合は、初期値 (つまり、ステート内のプロパティの割り当てが実行される前のプロパティの値)に復元されます。</target>
        </trans-unit>
        <trans-unit id="2cb4559c1cf0ab4e52e4f01892955e108435ae26" translate="yes" xml:space="preserve">
          <source>When this signal is emitted, the event loop has already stopped running. No more events will be processed in the thread, except for deferred deletion events. This signal can be connected to &lt;a href=&quot;qobject#deleteLater&quot;&gt;QObject::deleteLater&lt;/a&gt;(), to free objects in that thread.</source>
          <target state="translated">このシグナルが送信されたとき、イベントループは既に実行を停止しています。遅延削除イベントを除いて、スレッドで処理されるイベントはありません。このシグナルを&lt;a href=&quot;qobject#deleteLater&quot;&gt;QObject :: deleteLater&lt;/a&gt;（）に接続して、そのスレッド内のオブジェクトを解放できます。</target>
        </trans-unit>
        <trans-unit id="bc470d3a44b5fd1b983e2c2d38610b55df6e2808" translate="yes" xml:space="preserve">
          <source>When this signal is emitted, the socket may not be ready for a reconnect attempt. In that case, attempts to reconnect should be done from the event loop. For example, use a &lt;a href=&quot;qtimer#singleShot&quot;&gt;QTimer::singleShot&lt;/a&gt;() with 0 as the timeout.</source>
          <target state="translated">この信号が送信された場合、ソケットは再接続の準備ができていない可能性があります。その場合、再接続の試行はイベントループから行う必要があります。たとえば、タイムアウトとして0を&lt;a href=&quot;qtimer#singleShot&quot;&gt;指定し&lt;/a&gt;てQTimer :: singleShot（）を使用します。</target>
        </trans-unit>
        <trans-unit id="68f5a54216eb63b6271e28125c316438880cf091" translate="yes" xml:space="preserve">
          <source>When tr() is called, it looks up the translatable string using a &lt;a href=&quot;qtranslator&quot;&gt;QTranslator&lt;/a&gt; object. For translation to work, one or more of these must have been installed on the application object in the way described in &lt;a href=&quot;internationalization#enabling-translation&quot;&gt;Enabling Translation&lt;/a&gt;.</source>
          <target state="translated">tr（）が呼び出されると、&lt;a href=&quot;qtranslator&quot;&gt;QTranslator&lt;/a&gt;オブジェクトを使用して翻訳可能な文字列を検索します。翻訳が機能するには、翻訳の&lt;a href=&quot;internationalization#enabling-translation&quot;&gt;有効化で&lt;/a&gt;説明されている方法で、これらの1つ以上がアプリケーションオブジェクトにインストールされている必要があります。</target>
        </trans-unit>
        <trans-unit id="b9ebf77d443c0f3c1d237e7890cbd696ca28dded" translate="yes" xml:space="preserve">
          <source>When transforming a pixmap using the &lt;a href=&quot;qpixmap#transformed&quot;&gt;transformed&lt;/a&gt;() function, the transformation matrix is internally adjusted to compensate for unwanted translation, i.e. &lt;a href=&quot;qpixmap#transformed&quot;&gt;transformed&lt;/a&gt;() returns the smallest pixmap containing all transformed points of the original pixmap. This function returns the modified matrix, which maps points correctly from the original pixmap into the new pixmap.</source>
          <target state="translated">使用ピックスマップ変換するとき&lt;a href=&quot;qpixmap#transformed&quot;&gt;転換&lt;/a&gt;（）関数を、変換行列は、内部の不要な変換を補償するように調整され、すなわち、&lt;a href=&quot;qpixmap#transformed&quot;&gt;形質転換された&lt;/a&gt;（）は、元のピックスマップの全ての形質転換点を含む最小のピックスマップを返します。この関数は、元のピクスマップから新しいピクスマップにポイントを正しくマッピングする、変更されたマトリックスを返します。</target>
        </trans-unit>
        <trans-unit id="e797276249bcc854a69b6e49354f4d62d00c23f8" translate="yes" xml:space="preserve">
          <source>When transforming an embedded widget, Graphics View makes sure that the widget is transformed resolution independently, allowing the fonts and style to stay crisp when zoomed in. (Note that the effect of resolution independence depends on the style.)</source>
          <target state="translated">埋め込みウィジェットを変換するとき、グラフィックスビューでは、ウィジェットが解像度に依存せずに変換されることを確認し、ズームインしたときにフォントとスタイルが鮮明に保たれるようにします。(解像度に依存しない効果はスタイルに依存することに注意してください)。</target>
        </trans-unit>
        <trans-unit id="3aa1fd29b9548bcc37cb012b55271fdb19e2ee54" translate="yes" xml:space="preserve">
          <source>When transforming an image using the &lt;a href=&quot;qimage#transformed&quot;&gt;transformed&lt;/a&gt;() function, the transformation matrix is internally adjusted to compensate for unwanted translation, i.e. &lt;a href=&quot;qimage#transformed&quot;&gt;transformed&lt;/a&gt;() returns the smallest image containing all transformed points of the original image. This function returns the modified matrix, which maps points correctly from the original image into the new image.</source>
          <target state="translated">&lt;a href=&quot;qimage#transformed&quot;&gt;変換された&lt;/a&gt;（）関数を使用して画像を変換する場合、変換行列は内部で調整され、不要な変換が補正されます。つまり、&lt;a href=&quot;qimage#transformed&quot;&gt;変換された&lt;/a&gt;（）は、元の画像のすべての変換点を含む最小の画像を返します。この関数は、元の画像から新しい画像にポイントを正しくマッピングする変更された行列を返します。</target>
        </trans-unit>
        <trans-unit id="4d6a460eeff2d6a334a698745ed9d8d6a6ebeec9" translate="yes" xml:space="preserve">
          <source>When transforming an image using the transformed() function, the transformation matrix is internally adjusted to compensate for unwanted translation, i.e. transformed() returns the smallest image containing all transformed points of the original image. This function returns the modified matrix, which maps points correctly from the original image into the new image.</source>
          <target state="translated">transformed()関数を用いて画像を変換する場合,変換行列は不要な変換を補正するために内部的に調整されます.この関数は,元の画像から新しい画像に点を正しくマッピングする修正行列を返します.</target>
        </trans-unit>
        <trans-unit id="7221d90a96209f3128795a80a97a531cead2f548" translate="yes" xml:space="preserve">
          <source>When transforming from clip to normalized space, a division by the w component of the vector components takes place. To prevent dividing by 0 if w equals to 0, it is set to 1.</source>
          <target state="translated">クリップから正規化空間に変換する際に、ベクトル成分のw成分による除算が行われます。wが0に等しい場合に0で除算しないように、1に設定します。</target>
        </trans-unit>
        <trans-unit id="fbec62568b02f257db0ec31fbe2b5f21cf0c220e" translate="yes" xml:space="preserve">
          <source>When transforming from clip to normalized space, a division by the w component on the vector components takes place. To prevent dividing by 0 if w equals to 0, it is set to 1.</source>
          <target state="translated">クリップから正規化空間に変換する際、ベクトル成分上のw成分による除算が行われます。w が 0 の場合に 0 で除算しないように、1 に設定します。</target>
        </trans-unit>
        <trans-unit id="f520f592321df5d529bf39711026e14f01be91fb" translate="yes" xml:space="preserve">
          <source>When true, the menu contains a special tear-off item (often shown as a dashed line at the top of the menu) that creates a copy of the menu when it is triggered.</source>
          <target state="translated">true の場合、メニューには特別なティアオフ項目(メニューの上部に破線で表示されることが多い)が含まれており、それがトリガーされたときにメニューのコピーが作成されます。</target>
        </trans-unit>
        <trans-unit id="a89b60404dcbc2f5c915acfe02c16712d4bb61d2" translate="yes" xml:space="preserve">
          <source>When two manuals are located in the same virtual folder, it is possible to refer to sections of the other manual using relative paths. The virtual folder tag is mandatory and the folder must not contain any '/'.</source>
          <target state="translated">2 つのマニュアルが同じ仮想フォルダ内にある場合、相対パスを使用してもう一方のマニュアルのセクションを参照することができます。仮想フォルダタグは必須であり、フォルダには '/' が含まれていてはいけません。</target>
        </trans-unit>
        <trans-unit id="611300300598b513a04acdc4158b65a1b90365bd" translate="yes" xml:space="preserve">
          <source>When two widgets are adjacent to each other in a horizontal layout, setting the horizontal stretch factor of the widget on the left to 2 and the factor of widget on the right to 1 will ensure that the widget on the left will always be twice the size of the one on the right.</source>
          <target state="translated">水平レイアウトで2つのウィジェットが隣接している場合、左のウィジェットの水平ストレッチ係数を2に、右のウィジェットの水平ストレッチ係数を1に設定すると、左のウィジェットは常に右のウィジェットの2倍のサイズになります。</target>
        </trans-unit>
        <trans-unit id="33931b591564c5ce659c5439a00ac167ba2235e2" translate="yes" xml:space="preserve">
          <source>When two widgets are adjacent to each other in a vertical layout, setting the vertical stretch factor of the widget on the top to 2 and the factor of widget on the bottom to 1 will ensure that the widget on the top will always be twice the size of the one on the bottom.</source>
          <target state="translated">垂直レイアウトで2つのウィジェットが隣接している場合、上のウィジェットの垂直方向のストレッチ係数を2に、下のウィジェットの係数を1に設定すると、上のウィジェットが下のウィジェットの2倍のサイズになります。</target>
        </trans-unit>
        <trans-unit id="55c03842e144167485cbd5e8643bcbb80f6a7794" translate="yes" xml:space="preserve">
          <source>When unshared (or const version is called), this executes in &lt;a href=&quot;containers#constant-time&quot;&gt;constant time&lt;/a&gt;.</source>
          <target state="translated">非共有（またはconstバージョンが呼び出された）場合、これは&lt;a href=&quot;containers#constant-time&quot;&gt;一定の時間で&lt;/a&gt;実行されます。</target>
        </trans-unit>
        <trans-unit id="bcc9e75ff489b96d3335be53af67c254b116188b" translate="yes" xml:space="preserve">
          <source>When unshared (or const version is called), this executes in &lt;a href=&quot;containers#logarithmic-time&quot;&gt;logarithmic time&lt;/a&gt;.</source>
          <target state="translated">共有されていない場合（またはconstバージョンが呼び出された場合）、これは&lt;a href=&quot;containers#logarithmic-time&quot;&gt;対数時間で&lt;/a&gt;実行されます。</target>
        </trans-unit>
        <trans-unit id="991f02e2c91e5a7647479f2f811f8738759e3c87" translate="yes" xml:space="preserve">
          <source>When updating the current time, &lt;a href=&quot;qtimeline&quot;&gt;QTimeLine&lt;/a&gt; will emit &lt;a href=&quot;qtimeline#valueChanged&quot;&gt;valueChanged&lt;/a&gt;() if the current value changed, and &lt;a href=&quot;qtimeline#frameChanged&quot;&gt;frameChanged&lt;/a&gt;() if the frame changed.</source>
          <target state="translated">現在時刻を更新する際、&lt;a href=&quot;qtimeline&quot;&gt;QTimeLineが&lt;/a&gt;放出する&lt;a href=&quot;qtimeline#valueChanged&quot;&gt;のvalueChangedを&lt;/a&gt;現在の値が変更された場合（）、及び&lt;a href=&quot;qtimeline#frameChanged&quot;&gt;frameChanged&lt;/a&gt;フレームが変更された場合（）。</target>
        </trans-unit>
        <trans-unit id="5e145cfe947de4c48b51f93dc8297d7f125256bd" translate="yes" xml:space="preserve">
          <source>When upgrading the code base to Qt 6, this API change would most likely result in compiler warnings about narrowing type conversions. Having the following example code:</source>
          <target state="translated">コードベースを Qt 6 にアップグレードすると、この API の変更により、型の変換が狭くなるという警告が出る可能性が高くなります。以下のようなコード例を持っています。</target>
        </trans-unit>
        <trans-unit id="daf7b6e7fdbba2dfca1eadbe18a1d7de3b720e7b" translate="yes" xml:space="preserve">
          <source>When used as a context menu, the recommended way of opening the menu is to call &lt;a href=&quot;qml-qtquick-controls2-menu#popup-method&quot;&gt;popup()&lt;/a&gt;. Unless a position is explicitly specified, the menu is positioned at the mouse cursor on desktop platforms that have a mouse cursor available, and otherwise centered over its parent item.</source>
          <target state="translated">コンテキストメニューとして使用する場合、メニューを開くための推奨される方法は、&lt;a href=&quot;qml-qtquick-controls2-menu#popup-method&quot;&gt;popup（）&lt;/a&gt;を呼び出すことです。位置が明示的に指定されていない限り、メニューは、マウスカーソルが使用可能なデスクトッププラットフォームではマウスカーソルに配置され、それ以外の場合は親アイテムの中央に配置されます。</target>
        </trans-unit>
        <trans-unit id="e42ccc06c2943db340e29e9634bf18dbc9e13468" translate="yes" xml:space="preserve">
          <source>When used as a popup menu, it is easiest to specify the position by specifying the desired &lt;a href=&quot;qml-qtquick-controls2-popup#x-prop&quot;&gt;x&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-controls2-popup#y-prop&quot;&gt;y&lt;/a&gt; coordinates using the respective properties, and call &lt;a href=&quot;qml-qtquick-controls2-popup#open-method&quot;&gt;open()&lt;/a&gt; to open the menu.</source>
          <target state="translated">ポップアップメニューとして使用する場合、それぞれのプロパティを使用して目的の&lt;a href=&quot;qml-qtquick-controls2-popup#x-prop&quot;&gt;x&lt;/a&gt;座標と&lt;a href=&quot;qml-qtquick-controls2-popup#y-prop&quot;&gt;y&lt;/a&gt;座標を指定して位置を指定し、&lt;a href=&quot;qml-qtquick-controls2-popup#open-method&quot;&gt;open（）&lt;/a&gt;を呼び出してメニューを開くのが最も簡単です。</target>
        </trans-unit>
        <trans-unit id="51c1a4b96d0ac9fe7349345183028fcd340a1cf9" translate="yes" xml:space="preserve">
          <source>When used as a standalone application,</source>
          <target state="translated">スタンドアロンアプリケーションとして使用する場合。</target>
        </trans-unit>
        <trans-unit id="7c8523a9cdaa732605d1c3ca0c57e7327514b32b" translate="yes" xml:space="preserve">
          <source>When used as an interface type, &lt;a href=&quot;qstringview&quot;&gt;QStringView&lt;/a&gt; allows a single function to accept a wide variety of UTF-16 string data sources. One function accepting &lt;a href=&quot;qstringview&quot;&gt;QStringView&lt;/a&gt; thus replaces three function overloads (taking &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;, &lt;a href=&quot;qstringref&quot;&gt;QStringRef&lt;/a&gt;, and &lt;code&gt;(const QChar*, int)&lt;/code&gt;), while at the same time enabling even more string data sources to be passed to the function, such as &lt;code&gt;u&quot;Hello World&quot;&lt;/code&gt;, a &lt;code&gt;char16_t&lt;/code&gt; string literal.</source>
          <target state="translated">&lt;a href=&quot;qstringview&quot;&gt;QStringViewを&lt;/a&gt;インターフェースタイプとして使用すると、単一の関数でさまざまなUTF-16文字列データソースを受け入れることができます。したがって、&lt;a href=&quot;qstringview&quot;&gt;QStringView&lt;/a&gt;を受け入れる1つの関数は、3つの関数オーバーロード（&lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;、&lt;a href=&quot;qstringref&quot;&gt;QStringRef&lt;/a&gt;、および &lt;code&gt;(const QChar*, int)&lt;/code&gt; をとります）を置き換え、同時に &lt;code&gt;u&quot;Hello World&quot;&lt;/code&gt; などのさらに多くの文字列データソースを関数に渡すことができます。、 &lt;code&gt;char16_t&lt;/code&gt; 文字列リテラル。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
