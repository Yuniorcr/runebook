<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="tensorflow">
    <body>
      <group id="tensorflow">
        <trans-unit id="fb2c582ee71ccd0dae80f698e01ac135396f67ca" translate="yes" xml:space="preserve">
          <source>For a chief, this utility sets proper session initializer/restorer. It also creates hooks related to checkpoint and summary saving. For workers, this utility sets proper session creator which waits for the chief to initialize/restore. Please check &lt;a href=&quot;monitoredsession&quot;&gt;&lt;code&gt;tf.compat.v1.train.MonitoredSession&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">チーフにとって、このユーティリティは適切なセッション初期化子/復元者を設定します。また、チェックポイントとサマリーの保存に関連するフックも作成します。ワーカーの場合、このユーティリティは、チーフが初期化/復元するのを待つ適切なセッション作成者を設定します。詳細については、&lt;a href=&quot;monitoredsession&quot;&gt; &lt;code&gt;tf.compat.v1.train.MonitoredSession&lt;/code&gt; &lt;/a&gt;を確認してください。</target>
        </trans-unit>
        <trans-unit id="1e685a37c8c58056e8f3530b78115d9f73810c25" translate="yes" xml:space="preserve">
          <source>For a complete example showing the speed-up on training an image classification task on CIFAR10, check out this Colab notebook.</source>
          <target state="translated">CIFAR10上での画像分類タスクのトレーニングの高速化を示す完全な例は、このColabノートブックをチェックしてください。</target>
        </trans-unit>
        <trans-unit id="b151bbc686479044821007cc7d7dd7e642e9457f" translate="yes" xml:space="preserve">
          <source>For a counter-base RNG algorithm such as Philox and ThreeFry (as described in paper 'Parallel Random Numbers: As Easy as 1, 2, 3' [&lt;a href=&quot;https://www.thesalmons.org/john/random123/papers/random123sc11.pdf&quot;&gt;https://www.thesalmons.org/john/random123/papers/random123sc11.pdf&lt;/a&gt;]), the RNG state consists of two parts: counter and key. The output is generated via the formula: output=hash(key, counter), i.e. a hashing of the counter parametrized by the key. Two RNGs with two different keys can be thought as generating two independent random-number streams (a stream is formed by increasing the counter).</source>
          <target state="translated">PhiloxやThreeFryなどのカウンターベースのRNGアルゴリズムの場合（論文「ParallelRandom Numbers：As Easy as 1、2、3」[ &lt;a href=&quot;https://www.thesalmons.org/john/random123/papers/random123sc11.pdf&quot;&gt;https://www.thesalmons.org/john/random123/papers/random123sc11で説明されています。 pdf&lt;/a&gt; ]）、RNG状態は、カウンターとキーの2つの部分で構成されます。出力は次の式で生成されます：output = hash（key、c​​ounter）、つまり、キーによってパラメーター化されたカウンターのハッシュ。2つの異なるキーを持つ2つのRNGは、2つの独立した乱数ストリームを生成すると考えることができます（ストリームは、カウンターを増やすことによって形成されます）。</target>
        </trans-unit>
        <trans-unit id="c0f028ef007ecbff710e7dba8c5a5dabc991f9c1" translate="yes" xml:space="preserve">
          <source>For a counter-base RNG algorithm such as Philox and ThreeFry (as described in paper 'Parallel Random Numbers: As Easy as 1, 2, 3' [https://www.thesalmons.org/john/random123/papers/random123sc11.pdf]), the RNG state consists of two parts: counter and key. The output is generated via the formula: output=hash(key, counter), i.e. a hashing of the counter parametrized by the key. Two RNGs with two different keys can be thought as generating two independent random-number streams (a stream is formed by increasing the counter).</source>
          <target state="translated">PhiloxやThreeFryのようなカウンタベースのRNGアルゴリズムの場合(論文「Parallel Random Numbers.1,2,3と同じくらい簡単」[https://www.thesalmons.org/john/random123/papers/random123sc11.pdf]のようなカウンターベースのRNGアルゴリズムの場合、RNGの状態はカウンターとキーの2つの部分で構成されています。出力は次の式で生成されます:output=hash(key,counter)つまり、キーによってパラメトリック化されたカウンタのハッシュ化です。2つの異なるキーを持つ2つのRNGは、2つの独立した乱数ストリームを生成していると考えることができます(ストリームはカウンタを増加させることで形成されます)。</target>
        </trans-unit>
        <trans-unit id="9a5ce116616d9115cf39dfc32b5ace717bbeef6e" translate="yes" xml:space="preserve">
          <source>For a description of atrous convolution and how it can be used for dense feature extraction, please see: (Chen et al., 2015). The same operation is investigated further in (Yu et al., 2016). Previous works that effectively use atrous convolution in different ways are, among others, (Sermanet et al., 2014) and (Giusti et al., 2013). Atrous convolution is also closely related to the so-called noble identities in multi-rate signal processing.</source>
          <target state="translated">アトラス畳み込みの説明と、それが密な特徴抽出にどのように利用できるかについては、以下を参照されたい。(Chen et al.,2015)を参照のこと。(Yu et al.,2016)では、同様の操作についてさらに検討されている。異なる方法でアトロウス畳み込みを効果的に使用する以前の作品は、とりわけ、(Sermanet et al.アトラス畳み込みはまた、マルチレート信号処理におけるいわゆる高貴な同一性と密接に関連している。</target>
        </trans-unit>
        <trans-unit id="9459e940f5730676b9001d651d28cb51b42d969c" translate="yes" xml:space="preserve">
          <source>For a description of atrous convolution and how it can be used for dense feature extraction, please see: &lt;a href=&quot;http://arxiv.org/abs/1412.7062&quot;&gt;Semantic Image Segmentation with Deep Convolutional Nets and Fully Connected CRFs&lt;/a&gt;. The same operation is investigated further in &lt;a href=&quot;http://arxiv.org/abs/1511.07122&quot;&gt;Multi-Scale Context Aggregation by Dilated Convolutions&lt;/a&gt;. Previous works that effectively use atrous convolution in different ways are, among others, &lt;a href=&quot;http://arxiv.org/abs/1312.6229&quot;&gt;OverFeat: Integrated Recognition, Localization and Detection using Convolutional Networks&lt;/a&gt; and &lt;a href=&quot;http://arxiv.org/abs/1302.1700&quot;&gt;Fast Image Scanning with Deep Max-Pooling Convolutional Neural Networks&lt;/a&gt;. Atrous convolution is also closely related to the so-called noble identities in multi-rate signal processing.</source>
          <target state="translated">アトラス畳み込みの説明と、それを密な特徴抽出に使用する方法については、「&lt;a href=&quot;http://arxiv.org/abs/1412.7062&quot;&gt;深い畳み込みネットと完全に接続されたCRFによるセマンティックイメージセグメンテーション」&lt;/a&gt;を参照してください。同じ操作は&lt;a href=&quot;http://arxiv.org/abs/1511.07122&quot;&gt;、拡張された畳み込みによるマルチスケールコンテキスト集約で&lt;/a&gt;さらに調査されます。さまざまな方法でアストロ畳み込みを効果的に使用する以前の作品は、特に、&lt;a href=&quot;http://arxiv.org/abs/1312.6229&quot;&gt;OverFeat：統合認識、位置特定、および畳み込みネットワーク&lt;/a&gt;を使用した検出&lt;a href=&quot;http://arxiv.org/abs/1302.1700&quot;&gt;と、ディープマックスプールの畳み込みニューラルネットワークによる高速画像スキャンです&lt;/a&gt;。アストロ畳み込みは、マルチレート信号処理におけるいわゆる高貴なアイデンティティとも密接に関連しています。</target>
        </trans-unit>
        <trans-unit id="9395aea9a50261f21aee7ad93d28f55ca17890b1" translate="yes" xml:space="preserve">
          <source>For a detailed guide, see &lt;a href=&quot;https://tensorflow.org/guide/saved_model#savedmodels_from_estimators&quot;&gt;SavedModel from Estimators&lt;/a&gt;.</source>
          <target state="translated">詳細なガイドについては&lt;a href=&quot;https://tensorflow.org/guide/saved_model#savedmodels_from_estimators&quot;&gt;、EstimatorsのSavedModelを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="faf1eab5a6b813e3139fd4358594343e9ec1b061" translate="yes" xml:space="preserve">
          <source>For a detailed guide, see &lt;a href=&quot;https://tensorflow.org/guide/saved_model#using_savedmodel_with_estimators&quot;&gt;Using SavedModel with Estimators&lt;/a&gt;.</source>
          <target state="translated">詳細なガイドについては、「&lt;a href=&quot;https://tensorflow.org/guide/saved_model#using_savedmodel_with_estimators&quot;&gt;推定子でのSavedModelの使用」を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="57997fbb3307d6157f9ed4d1c8e94e6ae2cc97cf" translate="yes" xml:space="preserve">
          <source>For a given score-label-distribution the required precision might not be achievable, in this case 0.0 is returned as recall.</source>
          <target state="translated">与えられたスコアラベル分布では、要求された精度が達成できないかもしれませんが、この場合は0.0がリコールとして返されます。</target>
        </trans-unit>
        <trans-unit id="82871db36d8768d1a3be8c39394657eb4327cd7d" translate="yes" xml:space="preserve">
          <source>For a nested python tuple:</source>
          <target state="translated">入れ子になった python タプルの場合。</target>
        </trans-unit>
        <trans-unit id="220ccd8b164a992646be9626d306ae4431c07d07" translate="yes" xml:space="preserve">
          <source>For a profile data structure, profiler first finds the profiler nodes matching 'start_name_regexes', and starts displaying profiler nodes from there. Then, if a node matches 'show_name_regexes' and doesn't match 'hide_name_regexes', it's displayed. If a node matches 'trim_name_regexes', profiler stops further searching that branch.</source>
          <target state="translated">プロファイル・データ構造の場合、プロファイラは最初に 'start_name_regexes' にマッチするプロファイラ・ノードを見つけ、そこからプロファイラ・ノードの表示を開始します。次に、ノードが 'show_name_regexes' にマッチし、かつ 'hide_name_regexes' にマッチしない場合、そのノードが表示されます。ノードが 'trim_name_regexes' にマッチすると、プロファイラはそのブランチの検索を停止します。</target>
        </trans-unit>
        <trans-unit id="9939180266b3d93448c8fea23d0f6dfa98cc31b6" translate="yes" xml:space="preserve">
          <source>For a tutorial, see the &lt;a href=&quot;https://www.tensorflow.org/guide/function&quot;&gt;tf.function and AutoGraph guide&lt;/a&gt;. For more detailed information, see the &lt;a href=&quot;https://github.com/tensorflow/tensorflow/blob/master/tensorflow/python/autograph/g3doc/reference/index.md&quot;&gt;AutoGraph reference documentation&lt;/a&gt;.</source>
          <target state="translated">チュートリアルについては、&lt;a href=&quot;https://www.tensorflow.org/guide/function&quot;&gt;tf.functionおよびAutoGraphガイドを&lt;/a&gt;参照してください。詳細については、&lt;a href=&quot;https://github.com/tensorflow/tensorflow/blob/master/tensorflow/python/autograph/g3doc/reference/index.md&quot;&gt;オートグラフのリファレンスドキュメントを&lt;/a&gt;ご覧ください。</target>
        </trans-unit>
        <trans-unit id="3961b8c97504a885300108217230a73b23f20c07" translate="yes" xml:space="preserve">
          <source>For additional ClusterResolver properties such as task type, task index, rpc layer, environment, etc..., we will return the value from the first ClusterResolver in the union.</source>
          <target state="translated">タスクタイプ、タスクインデックス、RPCレイヤ、環境などの追加のClusterResolverプロパティについては、ユニオン内の最初のClusterResolverから値を返します。</target>
        </trans-unit>
        <trans-unit id="4710c7702380e37df383d4f1e0b6d32988898a50" translate="yes" xml:space="preserve">
          <source>For additional information about specificity and sensitivity, see &lt;a href=&quot;https://en.wikipedia.org/wiki/Sensitivity_and_specificity&quot;&gt;the following&lt;/a&gt;.</source>
          <target state="translated">特異性と感度の詳細について&lt;a href=&quot;https://en.wikipedia.org/wiki/Sensitivity_and_specificity&quot;&gt;は、以下を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="28b4f32d54970e27ef51cc570317aa7cc036c269" translate="yes" xml:space="preserve">
          <source>For additional information about specificity and sensitivity, see the following: &lt;a href=&quot;https://en.wikipedia.org/wiki/Sensitivity_and_specificity&quot;&gt;https://en.wikipedia.org/wiki/Sensitivity_and_specificity&lt;/a&gt;</source>
          <target state="translated">特異性と感度の詳細については、以下を参照して&lt;a href=&quot;https://en.wikipedia.org/wiki/Sensitivity_and_specificity&quot;&gt;ください&lt;/a&gt;：https：//en.wikipedia.org/wiki/Sensitivity_and_specificity</target>
        </trans-unit>
        <trans-unit id="8ba9a27fb906c20b62b7961623bd63a85b7a2467" translate="yes" xml:space="preserve">
          <source>For additional information about specificity and sensitivity, see the following: https://en.wikipedia.org/wiki/Sensitivity_and_specificity</source>
          <target state="translated">特異性と感度の詳細については、以下を参照してください:https://en.wikipedia.org/wiki/Sensitivity_and_specificity</target>
        </trans-unit>
        <trans-unit id="63527db3074c5cfec63b6889a3a6425bedc1846b" translate="yes" xml:space="preserve">
          <source>For advanced models, please use the full &lt;a href=&quot;lstmcell&quot;&gt;&lt;code&gt;tf.compat.v1.nn.rnn_cell.LSTMCell&lt;/code&gt;&lt;/a&gt; that follows.</source>
          <target state="translated">高度なモデルについては、以下の完全な&lt;a href=&quot;lstmcell&quot;&gt; &lt;code&gt;tf.compat.v1.nn.rnn_cell.LSTMCell&lt;/code&gt; &lt;/a&gt;を使用してください。</target>
        </trans-unit>
        <trans-unit id="343d6ea49aad072975b79ade2c38a0aa2de8f433" translate="yes" xml:space="preserve">
          <source>For an &lt;code&gt;2-D&lt;/code&gt; tensor &lt;code&gt;x&lt;/code&gt; with &lt;code&gt;axis = 0&lt;/code&gt;:</source>
          <target state="translated">以下のための &lt;code&gt;2-D&lt;/code&gt; テンソル &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;axis = 0&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="716108a64b24f9071a5ec3137f73a30034ffd3e1" translate="yes" xml:space="preserve">
          <source>For an &lt;code&gt;2-D&lt;/code&gt; tensor &lt;code&gt;x&lt;/code&gt; with &lt;code&gt;axis = 1&lt;/code&gt;:</source>
          <target state="translated">以下のための &lt;code&gt;2-D&lt;/code&gt; テンソル &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;axis = 1&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="eadb22d5f122e214c4d8d886fe174ffa6b50bd2b" translate="yes" xml:space="preserve">
          <source>For an explanation see &quot;Differentiation of the Cholesky algorithm&quot; by Iain Murray &lt;a href=&quot;http://arxiv.org/abs/1602.07527&quot;&gt;http://arxiv.org/abs/1602.07527&lt;/a&gt;</source>
          <target state="translated">説明については、IainMurrayによる「コレスキーアルゴリズムの微分」&lt;a href=&quot;http://arxiv.org/abs/1602.07527&quot;&gt;http://arxiv.org/abs/1602.07527を参照してください。&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="58bdfb47c0eae123b4f1b48443620758180eb094" translate="yes" xml:space="preserve">
          <source>For an input tensor with larger depth, here of shape &lt;code&gt;[1, 1, 1, 12]&lt;/code&gt;, e.g.</source>
          <target state="translated">より深い深度を持つ入力テンソルの場合、ここでは形状 &lt;code&gt;[1, 1, 1, 12]&lt;/code&gt; 、例えば</target>
        </trans-unit>
        <trans-unit id="73c52c9278ce524597d2c5b7b688185a99fdfc11" translate="yes" xml:space="preserve">
          <source>For an input tensor with larger depth, here of shape &lt;code&gt;[1, 2, 2, 3]&lt;/code&gt;, e.g.</source>
          <target state="translated">より深い深度を持つ入力テンソルの場合、ここでは形状 &lt;code&gt;[1, 2, 2, 3]&lt;/code&gt; 、例えば</target>
        </trans-unit>
        <trans-unit id="1f05e924ab8a0eee6cd58d652fef01bc7ebd2bac" translate="yes" xml:space="preserve">
          <source>For backward compatibility with the V1 format, this Op currently allows restoring from a V1 checkpoint as well:</source>
          <target state="translated">V1フォーマットとの下位互換性のため、現在はV1チェックポイントからのリストアも可能です。</target>
        </trans-unit>
        <trans-unit id="870b413d457e7d3b6fb91573e35aa40eaf69e580" translate="yes" xml:space="preserve">
          <source>For backwards compatibility only.</source>
          <target state="translated">下位互換性のためだけに。</target>
        </trans-unit>
        <trans-unit id="3bbf0e36ec059b3f4c0f63308a870c314c931ac4" translate="yes" xml:space="preserve">
          <source>For best results, &lt;code&gt;predictions&lt;/code&gt; should be distributed approximately uniformly in the range [0, 1] and not peaked around 0 or 1. The quality of the AUC approximation may be poor if this is not the case. Setting &lt;code&gt;summation_method&lt;/code&gt; to 'minoring' or 'majoring' can help quantify the error in the approximation by providing lower or upper bound estimate of the AUC.</source>
          <target state="translated">最良の結果を得るには、 &lt;code&gt;predictions&lt;/code&gt; は[0、1]の範囲でほぼ均一に分布し、0または1付近でピークに達しないようにする必要があります。 &lt;code&gt;summation_method&lt;/code&gt; を 'minoring'または 'majoring'に設定すると、AUCの下限または上限推定値が提供されるため、近似の誤差を定量化するのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="f78743990c17f9299a8953827006e26051a5a3fd" translate="yes" xml:space="preserve">
          <source>For best results, &lt;code&gt;predictions&lt;/code&gt; should be distributed approximately uniformly in the range [0, 1] and not peaked around 0 or 1. The quality of the AUC approximation may be poor if this is not the case. Setting &lt;code&gt;summation_method&lt;/code&gt; to 'minoring' or 'majoring' can help quantify the error in the approximation by providing lower or upper bound estimate of the AUC. The &lt;code&gt;thresholds&lt;/code&gt; parameter can be used to manually specify thresholds which split the predictions more evenly.</source>
          <target state="translated">最良の結果を得るには、 &lt;code&gt;predictions&lt;/code&gt; は[0、1]の範囲でほぼ均一に分布し、0または1付近でピークに達しないようにする必要があります。 &lt;code&gt;summation_method&lt;/code&gt; を 'minoring'または 'majoring'に設定すると、AUCの下限または上限推定値が提供されるため、近似の誤差を定量化するのに役立ちます。 &lt;code&gt;thresholds&lt;/code&gt; パラメータは、手動でより均等に予測を分割しきい値を指定するために使用することができます。</target>
        </trans-unit>
        <trans-unit id="daff1b722d0fb127a20bad0fd4ebd0412bf72bd5" translate="yes" xml:space="preserve">
          <source>For brevity, let &lt;code&gt;c = log(x) = log_input&lt;/code&gt;, &lt;code&gt;z = targets&lt;/code&gt;. The log Poisson loss is</source>
          <target state="translated">簡潔にするために、 &lt;code&gt;c = log(x) = log_input&lt;/code&gt; 、 &lt;code&gt;z = targets&lt;/code&gt; ます。ログポアソン損失は</target>
        </trans-unit>
        <trans-unit id="d6219a532f9c408cd0729ad6b959c0bbe42f179a" translate="yes" xml:space="preserve">
          <source>For brevity, let &lt;code&gt;x = logits&lt;/code&gt;, &lt;code&gt;z = labels&lt;/code&gt;, &lt;code&gt;q = pos_weight&lt;/code&gt;. The loss is:</source>
          <target state="translated">簡潔にするために、 &lt;code&gt;x = logits&lt;/code&gt; 、 &lt;code&gt;z = labels&lt;/code&gt; 、 &lt;code&gt;q = pos_weight&lt;/code&gt; ます。損失は​​：</target>
        </trans-unit>
        <trans-unit id="ff9d01f67c929c82f2ffed8b81b820d23e32b1da" translate="yes" xml:space="preserve">
          <source>For brevity, let &lt;code&gt;x = logits&lt;/code&gt;, &lt;code&gt;z = labels&lt;/code&gt;. The logistic loss is</source>
          <target state="translated">簡潔にするために、 &lt;code&gt;x = logits&lt;/code&gt; 、 &lt;code&gt;z = labels&lt;/code&gt; ます。ロジスティック損失は</target>
        </trans-unit>
        <trans-unit id="1301e2ab85c859b04f71a10ca5d0a61ed66dc9bc" translate="yes" xml:space="preserve">
          <source>For classification: binary label.</source>
          <target state="translated">分類のために:バイナリラベル。</target>
        </trans-unit>
        <trans-unit id="e22a3f22d875842280028907e515e5b1ceef3a59" translate="yes" xml:space="preserve">
          <source>For complex numbers, &lt;code&gt;y = sign(x) = x / |x|&lt;/code&gt; if &lt;code&gt;x != 0&lt;/code&gt;, otherwise &lt;code&gt;y = 0&lt;/code&gt;.</source>
          <target state="translated">複素数の場合、 &lt;code&gt;y = sign(x) = x / |x|&lt;/code&gt; 場合 &lt;code&gt;x != 0&lt;/code&gt; 、それ以外の場合は &lt;code&gt;y = 0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0b4484477dc0ad27cefcf137a2c8cf12a0ec4bd1" translate="yes" xml:space="preserve">
          <source>For complex numbers, the exponential value is calculated as \(e^{x+iy}={e^x}{e^{iy} }={e^x}{\\cos(y)+i\\sin(y)}\)</source>
          <target state="translated">複素数の場合は、指数関数の値は次のように計算されます。</target>
        </trans-unit>
        <trans-unit id="cb5d4419a8e723474e43b51cd45a962afee640c2" translate="yes" xml:space="preserve">
          <source>For complex numbers, the exponential value is calculated as follows:</source>
          <target state="translated">複素数の場合、指数の値は次のように計算されます。</target>
        </trans-unit>
        <trans-unit id="ab8f171225b6810fb2121ef3a2ccfb37c7669be7" translate="yes" xml:space="preserve">
          <source>For complex numbers, y = sign(x) = x / |x| if x != 0, otherwise y = 0.</source>
          <target state="translated">複素数の場合、x !=0 の場合は y=sign(x)=x/|x|、そうでない場合は y=0 となります。</target>
        </trans-unit>
        <trans-unit id="49462dde41ed51282a18f24b9ae73b7df90a2ba4" translate="yes" xml:space="preserve">
          <source>For convenience, The requested number of partitions does not have to divide the corresponding dimension evenly. If it does not, the shapes of the partitions are incremented by 1 starting from partition 0 until all slack is absorbed. The adjustment rules may change in the future, but as you can save/restore these variables with different slicing specifications this should not be a problem.</source>
          <target state="translated">便宜上、要求されたパーティションの数は、対応する次元を均等に分割する必要はありません。そうでない場合、パーティションの形状はパーティション0から始まり、すべてのスラックが吸収されるまで1ずつインクリメントされます。調整ルールは将来変更されるかもしれませんが、異なるスライス仕様でこれらの変数を保存/復元することができるので、これは問題ではありません。</target>
        </trans-unit>
        <trans-unit id="1350aabb6a166b4a9adc5331f9bfc6c8e1f4e703" translate="yes" xml:space="preserve">
          <source>For convenience, this function sets a default value for the &lt;code&gt;step&lt;/code&gt; parameter used in summary-writing functions elsewhere in the API so that it need not be explicitly passed in every such invocation. The value can be a constant or a variable, and can be retrieved via &lt;a href=&quot;get_step&quot;&gt;&lt;code&gt;tf.summary.experimental.get_step()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">便宜上、この関数は、APIの他の場所で要約を作成する関数で使用される &lt;code&gt;step&lt;/code&gt; パラメータのデフォルト値を設定するため、そのようなすべての呼び出しで明示的に渡す必要はありません。値は定数または変数にすることができ、&lt;a href=&quot;get_step&quot;&gt; &lt;code&gt;tf.summary.experimental.get_step()&lt;/code&gt; を&lt;/a&gt;介して取得できます。</target>
        </trans-unit>
        <trans-unit id="4334d314960569ae2e72fe3de9077256f0d3ba99" translate="yes" xml:space="preserve">
          <source>For correctness, &lt;a href=&quot;../../while_loop&quot;&gt;&lt;code&gt;tf.while_loop()&lt;/code&gt;&lt;/a&gt; strictly enforces shape invariants for the loop variables. A shape invariant is a (possibly partial) shape that is unchanged across the iterations of the loop. An error will be raised if the shape of a loop variable after an iteration is determined to be more general than or incompatible with its shape invariant. For example, a shape of [11, None] is more general than a shape of [11, 17], and [11, 21] is not compatible with [11, 17]. By default (if the argument &lt;code&gt;shape_invariants&lt;/code&gt; is not specified), it is assumed that the initial shape of each tensor in &lt;code&gt;loop_vars&lt;/code&gt; is the same in every iteration. The &lt;code&gt;shape_invariants&lt;/code&gt; argument allows the caller to specify a less specific shape invariant for each loop variable, which is needed if the shape varies between iterations. The &lt;a href=&quot;../../tensor#set_shape&quot;&gt;&lt;code&gt;tf.Tensor.set_shape&lt;/code&gt;&lt;/a&gt; function may also be used in the &lt;code&gt;body&lt;/code&gt; function to indicate that the output loop variable has a particular shape. The shape invariant for SparseTensor and IndexedSlices are treated specially as follows:</source>
          <target state="translated">正確さのために、&lt;a href=&quot;../../while_loop&quot;&gt; &lt;code&gt;tf.while_loop()&lt;/code&gt; &lt;/a&gt;は、ループ変数に対して形状不変式を厳密に実施します。シェイプインバリアントは、ループの繰り返し全体で変化しない（場合によっては部分的な）シェイプです。反復後のループ変数の形状がその形状不変式よりも一般的であるか、互換性がないと判断された場合、エラーが発生します。たとえば、[11、None]の形状は[11、17]の形状よりも一般的であり、[11、21]は[11、17]と互換性がありません。デフォルトでは（引数 &lt;code&gt;shape_invariants&lt;/code&gt; が指定されていない場合）、 &lt;code&gt;loop_vars&lt;/code&gt; の各テンソルの初期形状はすべての反復で同じであると見なされます。 &lt;code&gt;shape_invariants&lt;/code&gt; 引数により、呼び出し元はループ変数ごとに特定性の低い形状不変量を指定できます。これは、形状が反復間で異なる場合に必要です。&lt;a href=&quot;../../tensor#set_shape&quot;&gt; &lt;code&gt;tf.Tensor.set_shape&lt;/code&gt; の&lt;/a&gt;機能はまた、使用することができる &lt;code&gt;body&lt;/code&gt; 出力ループ変数が特定の形状を有していることを示すように機能します。 SparseTensorおよびIndexedSlicesの形状不変式は、次のように特別に扱われます。</target>
        </trans-unit>
        <trans-unit id="2d86798b077ac794a34c4729b8903d92155fb358" translate="yes" xml:space="preserve">
          <source>For correctness, &lt;a href=&quot;while_loop&quot;&gt;&lt;code&gt;tf.while_loop()&lt;/code&gt;&lt;/a&gt; strictly enforces shape invariants for the loop variables. A shape invariant is a (possibly partial) shape that is unchanged across the iterations of the loop. An error will be raised if the shape of a loop variable after an iteration is determined to be more general than or incompatible with its shape invariant. For example, a shape of [11, None] is more general than a shape of [11, 17], and [11, 21] is not compatible with [11, 17]. By default (if the argument &lt;code&gt;shape_invariants&lt;/code&gt; is not specified), it is assumed that the initial shape of each tensor in &lt;code&gt;loop_vars&lt;/code&gt; is the same in every iteration. The &lt;code&gt;shape_invariants&lt;/code&gt; argument allows the caller to specify a less specific shape invariant for each loop variable, which is needed if the shape varies between iterations. The &lt;a href=&quot;tensor#set_shape&quot;&gt;&lt;code&gt;tf.Tensor.set_shape&lt;/code&gt;&lt;/a&gt; function may also be used in the &lt;code&gt;body&lt;/code&gt; function to indicate that the output loop variable has a particular shape. The shape invariant for SparseTensor and IndexedSlices are treated specially as follows:</source>
          <target state="translated">正確さのために、&lt;a href=&quot;while_loop&quot;&gt; &lt;code&gt;tf.while_loop()&lt;/code&gt; &lt;/a&gt;は、ループ変数に対して形状不変式を厳密に実施します。シェイプインバリアントは、ループの繰り返し全体で変化しない（場合によっては部分的な）シェイプです。反復後のループ変数の形状がその形状不変式よりも一般的であるか、互換性がないと判断された場合、エラーが発生します。たとえば、[11、None]の形状は[11、17]の形状よりも一般的であり、[11、21]は[11、17]と互換性がありません。デフォルトでは（引数 &lt;code&gt;shape_invariants&lt;/code&gt; が指定されていない場合）、 &lt;code&gt;loop_vars&lt;/code&gt; の各テンソルの初期形状はすべての反復で同じであると見なされます。 &lt;code&gt;shape_invariants&lt;/code&gt; 引数により、呼び出し元はループ変数ごとに特定性の低い形状不変量を指定できます。これは、形状が反復間で異なる場合に必要です。&lt;a href=&quot;tensor#set_shape&quot;&gt; &lt;code&gt;tf.Tensor.set_shape&lt;/code&gt; の&lt;/a&gt;機能はまた、使用することができる &lt;code&gt;body&lt;/code&gt; 出力ループ変数が特定の形状を有していることを示すように機能します。 SparseTensorおよびIndexedSlicesの形状不変式は、次のように特別に扱われます。</target>
        </trans-unit>
        <trans-unit id="cbc00d3ab4b824f23aa4250f9ca61bea7ee84f1a" translate="yes" xml:space="preserve">
          <source>For dense results in two serialized &lt;code&gt;Example&lt;/code&gt;s:</source>
          <target state="translated">2つのシリアル化された &lt;code&gt;Example&lt;/code&gt; の密な結果の場合：</target>
        </trans-unit>
        <trans-unit id="260832edfc6e827a99bc3598303ea1cef15de510" translate="yes" xml:space="preserve">
          <source>For dense tensors, the returned &lt;code&gt;Tensor&lt;/code&gt; is identical to the output of &lt;code&gt;parse_example&lt;/code&gt;, except there is no batch dimension, the output shape is the same as the shape given in &lt;code&gt;dense_shape&lt;/code&gt;.</source>
          <target state="translated">密なテンソルの場合、返される &lt;code&gt;Tensor&lt;/code&gt; は、バッチディメンションがないことを除いて、 &lt;code&gt;parse_example&lt;/code&gt; の出力と同じです。出力の形状は、 &lt;code&gt;dense_shape&lt;/code&gt; 指定された形状と同じです。</target>
        </trans-unit>
        <trans-unit id="4cd4bd6d5ebf6a3540e2292e02f738b12afb9ed8" translate="yes" xml:space="preserve">
          <source>For detailed usage examples of TensorFlow Distributions shapes, see &lt;a href=&quot;https://github.com/tensorflow/probability/blob/master/tensorflow_probability/examples/jupyter_notebooks/Understanding_TensorFlow_Distributions_Shapes.ipynb&quot;&gt;this tutorial&lt;/a&gt;</source>
          <target state="translated">TensorFlow Distributionsシェイプの詳しい使用例については、&lt;a href=&quot;https://github.com/tensorflow/probability/blob/master/tensorflow_probability/examples/jupyter_notebooks/Understanding_TensorFlow_Distributions_Shapes.ipynb&quot;&gt;このチュートリアルを&lt;/a&gt;ご覧ください。</target>
        </trans-unit>
        <trans-unit id="868bc9411021e63ffd85c6f1e5eb98ca3d3b255f" translate="yes" xml:space="preserve">
          <source>For details on how the graph-level seed interacts with op seeds, see &lt;a href=&quot;set_random_seed&quot;&gt;&lt;code&gt;tf.compat.v1.random.set_random_seed&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">グラフレベルのシードとopシードの相互作用の詳細については、&lt;a href=&quot;set_random_seed&quot;&gt; &lt;code&gt;tf.compat.v1.random.set_random_seed&lt;/code&gt; を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="d5b62bcdafb111a4f348589cf96332ab6f0a487b" translate="yes" xml:space="preserve">
          <source>For details on the meaning of each version, see &lt;a href=&quot;https://www.tensorflow.org/code/tensorflow/core/framework/graph.proto&quot;&gt;&lt;code&gt;GraphDef&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">各バージョンの意味の詳細については、&lt;a href=&quot;https://www.tensorflow.org/code/tensorflow/core/framework/graph.proto&quot;&gt; &lt;code&gt;GraphDef&lt;/code&gt; を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="c866dd9eacd53156ef05bb3168960ebd7b5e18a3" translate="yes" xml:space="preserve">
          <source>For details, see &lt;a href=&quot;http://papers.nips.cc/paper/4824-imagenet-classification-with-deep-convolutional-neural-networks&quot;&gt;Krizhevsky et al., ImageNet classification with deep convolutional neural networks (NIPS 2012)&lt;/a&gt;.</source>
          <target state="translated">詳細については、&lt;a href=&quot;http://papers.nips.cc/paper/4824-imagenet-classification-with-deep-convolutional-neural-networks&quot;&gt;Krizhevsky et al。、深い畳み込みニューラルネットワークを使用したImageNet分類（NIPS 2012）を参照してください&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="11f72ea95f4d5434f57a9675d8fca114eb68909d" translate="yes" xml:space="preserve">
          <source>For each 3-D image &lt;code&gt;x&lt;/code&gt; in &lt;code&gt;image&lt;/code&gt;, computes &lt;code&gt;(x - mean) / adjusted_stddev&lt;/code&gt;, where</source>
          <target state="translated">imageの各3次元画像 &lt;code&gt;x&lt;/code&gt; について、 &lt;code&gt;(x - mean) / adjusted_stddev&lt;/code&gt; Adjusted_stddevを計算し &lt;code&gt;image&lt;/code&gt; 。ここで、</target>
        </trans-unit>
        <trans-unit id="3227496e32cef4b95ac21bbcfb379b6c8563c22f" translate="yes" xml:space="preserve">
          <source>For each batch &lt;code&gt;i&lt;/code&gt; and class &lt;code&gt;j&lt;/code&gt; we have</source>
          <target state="translated">各バッチ &lt;code&gt;i&lt;/code&gt; とクラス &lt;code&gt;j&lt;/code&gt; について</target>
        </trans-unit>
        <trans-unit id="38ee7d6b0b564eb41b147c9865f0b162072dea3f" translate="yes" xml:space="preserve">
          <source>For each batch of counts, &lt;code&gt;value = [n_0, ... ,n_{k-1}]&lt;/code&gt;, &lt;code&gt;P[value]&lt;/code&gt; is the probability that after sampling &lt;code&gt;self.total_count&lt;/code&gt; draws from this Multinomial distribution, the number of draws falling in class &lt;code&gt;j&lt;/code&gt; is &lt;code&gt;n_j&lt;/code&gt;. Since this definition is &lt;a href=&quot;https://en.wikipedia.org/wiki/Exchangeable_random_variables&quot;&gt;exchangeable&lt;/a&gt;; different sequences have the same counts so the probability includes a combinatorial coefficient.</source>
          <target state="translated">カウントのバッチごとに、 &lt;code&gt;value = [n_0, ... ,n_{k-1}]&lt;/code&gt; 、 &lt;code&gt;P[value]&lt;/code&gt; は、サンプリングした後、この多項分布から &lt;code&gt;self.total_count&lt;/code&gt; が抽選される確率であり、クラス &lt;code&gt;j&lt;/code&gt; に該当する抽選の数ある &lt;code&gt;n_j&lt;/code&gt; 。この定義は&lt;a href=&quot;https://en.wikipedia.org/wiki/Exchangeable_random_variables&quot;&gt;交換可能なため&lt;/a&gt;、異なるシーケンスのカウントは同じであるため、確率には組み合わせ係数が含まれます。</target>
        </trans-unit>
        <trans-unit id="62e6f600d1795850660493678c7d313f17bb03f6" translate="yes" xml:space="preserve">
          <source>For each batch of counts, &lt;code&gt;value = [n_0, ..., n_{K-1}]&lt;/code&gt;, &lt;code&gt;P[value]&lt;/code&gt; is the probability that after sampling &lt;code&gt;self.total_count&lt;/code&gt; draws from this Dirichlet-Multinomial distribution, the number of draws falling in class &lt;code&gt;j&lt;/code&gt; is &lt;code&gt;n_j&lt;/code&gt;. Since this definition is &lt;a href=&quot;https://en.wikipedia.org/wiki/Exchangeable_random_variables&quot;&gt;exchangeable&lt;/a&gt;; different sequences have the same counts so the probability includes a combinatorial coefficient.</source>
          <target state="translated">カウントの各バッチについて、 &lt;code&gt;value = [n_0, ..., n_{K-1}]&lt;/code&gt; 、 &lt;code&gt;P[value]&lt;/code&gt; は、このディリクレ多項分布から &lt;code&gt;self.total_count&lt;/code&gt; をサンプリングした後の確率です。クラス &lt;code&gt;j&lt;/code&gt; は &lt;code&gt;n_j&lt;/code&gt; です。この定義は&lt;a href=&quot;https://en.wikipedia.org/wiki/Exchangeable_random_variables&quot;&gt;交換可能なため&lt;/a&gt;、異なるシーケンスのカウントは同じであるため、確率には組み合わせ係数が含まれます。</target>
        </trans-unit>
        <trans-unit id="bb818b9007e09539540e92f84325c27b3ee59e8b" translate="yes" xml:space="preserve">
          <source>For each batch, this op picks a single set of sampled candidate labels.</source>
          <target state="translated">各バッチについて、この操作は、サンプルされた候補ラベルの単一のセットを選択します。</target>
        </trans-unit>
        <trans-unit id="cd53ff76cccc96ec695fa6a623c56b5fe4ad9802" translate="yes" xml:space="preserve">
          <source>For each channel, the Op first computes the mean of the image pixels in the channel and then adjusts each component of each pixel to &lt;code&gt;(x - mean) * contrast_factor + mean&lt;/code&gt;.</source>
          <target state="translated">各チャネルについて、Opは最初にチャネル内の画像ピクセルの平均を計算し、次に各ピクセルの各コンポーネントを &lt;code&gt;(x - mean) * contrast_factor + mean&lt;/code&gt; 調整します。</target>
        </trans-unit>
        <trans-unit id="b564f7dfac5634b944029ff0a934eb0322773539" translate="yes" xml:space="preserve">
          <source>For each channel, this Op computes the mean of the image pixels in the channel and then adjusts each component &lt;code&gt;x&lt;/code&gt; of each pixel to &lt;code&gt;(x - mean) * contrast_factor + mean&lt;/code&gt;.</source>
          <target state="translated">各チャンネルについて、このOpはチャンネル内の画像ピクセルの平均を計算してから、各ピクセルの各コンポーネント &lt;code&gt;x&lt;/code&gt; を &lt;code&gt;(x - mean) * contrast_factor + mean&lt;/code&gt; 調整します。</target>
        </trans-unit>
        <trans-unit id="ff2fe1b034bb2ad174dd976537594c894cf480ba" translate="yes" xml:space="preserve">
          <source>For each channel, this layer computes the mean of the image pixels in the channel and then adjusts each component &lt;code&gt;x&lt;/code&gt; of each pixel to &lt;code&gt;(x - mean) * contrast_factor + mean&lt;/code&gt;.</source>
          <target state="translated">このレイヤーは、チャネルごとに、チャネル内の画像ピクセルの平均を計算し、各ピクセルの各コンポーネント &lt;code&gt;x&lt;/code&gt; を &lt;code&gt;(x - mean) * contrast_factor + mean&lt;/code&gt; 調整します。</target>
        </trans-unit>
        <trans-unit id="e51add3cb58cbf81d2d2183dae647c67c4f8839c" translate="yes" xml:space="preserve">
          <source>For each element of &lt;code&gt;x&lt;/code&gt;, with probability &lt;code&gt;rate&lt;/code&gt;, outputs &lt;code&gt;0&lt;/code&gt;, and otherwise scales up the input by &lt;code&gt;1 / (1-rate)&lt;/code&gt;. The scaling is such that the expected sum is unchanged.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; の各要素について、確率 &lt;code&gt;rate&lt;/code&gt; で &lt;code&gt;0&lt;/code&gt; を出力します。それ以外の場合は、入力を &lt;code&gt;1 / (1-rate)&lt;/code&gt; スケールアップします。スケーリングは、期待される合計が変更されないようなものです。</target>
        </trans-unit>
        <trans-unit id="86602bb631fb5fb59349ca0b2955fe851ca22911" translate="yes" xml:space="preserve">
          <source>For each entry in &lt;code&gt;x&lt;/code&gt;, calculates the number of &lt;code&gt;1&lt;/code&gt; (on) bits in the binary representation of that entry.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; の各エントリについて、そのエントリのバイナリ表現の &lt;code&gt;1&lt;/code&gt; （オン）ビット数を計算します。</target>
        </trans-unit>
        <trans-unit id="28ab9495d8c09b2b7b1ceee1fc8792b4dada3fe0" translate="yes" xml:space="preserve">
          <source>For each index tuple &lt;code&gt;js&lt;/code&gt; of size &lt;code&gt;partitions.ndim&lt;/code&gt;, the slice &lt;code&gt;data[js, ...]&lt;/code&gt; becomes part of &lt;code&gt;outputs[partitions[js]]&lt;/code&gt;. The slices with &lt;code&gt;partitions[js] = i&lt;/code&gt; are placed in &lt;code&gt;outputs[i]&lt;/code&gt; in lexicographic order of &lt;code&gt;js&lt;/code&gt;, and the first dimension of &lt;code&gt;outputs[i]&lt;/code&gt; is the number of entries in &lt;code&gt;partitions&lt;/code&gt; equal to &lt;code&gt;i&lt;/code&gt;. In detail,</source>
          <target state="translated">サイズが &lt;code&gt;partitions.ndim&lt;/code&gt; のインデックスタプル &lt;code&gt;js&lt;/code&gt; ごとに、スライス &lt;code&gt;data[js, ...]&lt;/code&gt; は、 &lt;code&gt;outputs[partitions[js]]&lt;/code&gt; 一部になります。スライス &lt;code&gt;partitions[js] = i&lt;/code&gt; 内に配置される &lt;code&gt;outputs[i]&lt;/code&gt; の辞書式順序で &lt;code&gt;js&lt;/code&gt; 、との最初の寸法 &lt;code&gt;outputs[i]&lt;/code&gt; 内のエントリの数である &lt;code&gt;partitions&lt;/code&gt; 等しい &lt;code&gt;i&lt;/code&gt; 。詳細に、</target>
        </trans-unit>
        <trans-unit id="8f890fa1a354ef3fc8ec0c534b58bd8321503214" translate="yes" xml:space="preserve">
          <source>For each input submatrix of shape &lt;code&gt;[M, M]&lt;/code&gt;, L is a lower triangular matrix of shape &lt;code&gt;[M, M]&lt;/code&gt; with unit diagonal whose entries correspond to the strictly lower triangular part of LU. U is a upper triangular matrix of shape &lt;code&gt;[M, M]&lt;/code&gt; whose entries correspond to the upper triangular part, including the diagonal, of LU.</source>
          <target state="translated">形状の各入力サブ行列のために &lt;code&gt;[M, M]&lt;/code&gt; 、L形状の下三角行列であり、 &lt;code&gt;[M, M]&lt;/code&gt; エントリLUの厳密な下三角部分に対応する単位対角を有します。 Uは形状 &lt;code&gt;[M, M]&lt;/code&gt; 上三角行列であり、そのエントリはLUの対角線を含む上三角部分に対応します。</target>
        </trans-unit>
        <trans-unit id="c00b7a881865ff1e4e2196d95bae3abcdc4cd784" translate="yes" xml:space="preserve">
          <source>For each job, if the task index space is dense, the corresponding value will be a list of network addresses; otherwise it will be a dictionary mapping (sparse) task indices to the corresponding addresses.</source>
          <target state="translated">各ジョブについて、タスク・インデックス空間が密であれば、対応する値はネットワーク・アドレスのリストになります。そうでなければ、タスク・インデックスを(疎な)対応するアドレスにマッピングした辞書になります。</target>
        </trans-unit>
        <trans-unit id="aea6c2ab4366a16a529a52527d4b03de1704be35" translate="yes" xml:space="preserve">
          <source>For each key, assigns the respective value to the specified component.</source>
          <target state="translated">各キーに対して、指定されたコンポーネントにそれぞれの値を割り当てます。</target>
        </trans-unit>
        <trans-unit id="487d8b92f2cc03f24f4ba27c6c59fe187e5d7046" translate="yes" xml:space="preserve">
          <source>For each mode passed in via the &lt;code&gt;input_receiver_fn_map&lt;/code&gt;, this method builds a new graph by calling the &lt;code&gt;input_receiver_fn&lt;/code&gt; to obtain feature and label &lt;code&gt;Tensor&lt;/code&gt;s. Next, this method calls the &lt;code&gt;Estimator&lt;/code&gt;'s &lt;code&gt;model_fn&lt;/code&gt; in the passed mode to generate the model graph based on those features and labels, and restores the given checkpoint (or, lacking that, the most recent checkpoint) into the graph. Only one of the modes is used for saving variables to the &lt;code&gt;SavedModel&lt;/code&gt; (order of preference: &lt;a href=&quot;../../../../estimator/modekeys#TRAIN&quot;&gt;&lt;code&gt;tf.estimator.ModeKeys.TRAIN&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../../../estimator/modekeys#EVAL&quot;&gt;&lt;code&gt;tf.estimator.ModeKeys.EVAL&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;../../../../estimator/modekeys#PREDICT&quot;&gt;&lt;code&gt;tf.estimator.ModeKeys.PREDICT&lt;/code&gt;&lt;/a&gt;), such that up to three &lt;code&gt;tf.MetaGraphDefs&lt;/code&gt; are saved with a single set of variables in a single &lt;code&gt;SavedModel&lt;/code&gt; directory.</source>
          <target state="translated">&lt;code&gt;input_receiver_fn_map&lt;/code&gt; を介して渡される各モードについて、このメソッドは &lt;code&gt;input_receiver_fn&lt;/code&gt; を呼び出してフィーチャとラベル &lt;code&gt;Tensor&lt;/code&gt; を取得することにより、新しいグラフを作成します。次に、このメソッドは、渡されたモードで &lt;code&gt;Estimator&lt;/code&gt; の &lt;code&gt;model_fn&lt;/code&gt; を呼び出して、それらの機能とラベルに基づいてモデルグラフを生成し、指定されたチェックポイント（または、欠落している最新のチェックポイント）をグラフに復元します。変数を &lt;code&gt;SavedModel&lt;/code&gt; に保存するために使用されるモードは1つだけです（優先順位：&lt;a href=&quot;../../../../estimator/modekeys#TRAIN&quot;&gt; &lt;code&gt;tf.estimator.ModeKeys.TRAIN&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../../../../estimator/modekeys#EVAL&quot;&gt; &lt;code&gt;tf.estimator.ModeKeys.EVAL&lt;/code&gt; &lt;/a&gt;、次に&lt;a href=&quot;../../../../estimator/modekeys#PREDICT&quot;&gt; &lt;code&gt;tf.estimator.ModeKeys.PREDICT&lt;/code&gt; &lt;/a&gt;）。 &lt;code&gt;tf.MetaGraphDefs&lt;/code&gt; は、単一の &lt;code&gt;SavedModel&lt;/code&gt; ディレクトリに単一の変数セットで保存されます。</target>
        </trans-unit>
        <trans-unit id="894633909e50b7d3307fbbac8ff5cae1f413ff86" translate="yes" xml:space="preserve">
          <source>For each mode passed in via the &lt;code&gt;input_receiver_fn_map&lt;/code&gt;, this method builds a new graph by calling the &lt;code&gt;input_receiver_fn&lt;/code&gt; to obtain feature and label &lt;code&gt;Tensor&lt;/code&gt;s. Next, this method calls the &lt;code&gt;Estimator&lt;/code&gt;'s &lt;code&gt;model_fn&lt;/code&gt; in the passed mode to generate the model graph based on those features and labels, and restores the given checkpoint (or, lacking that, the most recent checkpoint) into the graph. Only one of the modes is used for saving variables to the &lt;code&gt;SavedModel&lt;/code&gt; (order of preference: &lt;a href=&quot;../../../estimator/modekeys#TRAIN&quot;&gt;&lt;code&gt;tf.estimator.ModeKeys.TRAIN&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../../estimator/modekeys#EVAL&quot;&gt;&lt;code&gt;tf.estimator.ModeKeys.EVAL&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;../../../estimator/modekeys#PREDICT&quot;&gt;&lt;code&gt;tf.estimator.ModeKeys.PREDICT&lt;/code&gt;&lt;/a&gt;), such that up to three &lt;code&gt;tf.MetaGraphDefs&lt;/code&gt; are saved with a single set of variables in a single &lt;code&gt;SavedModel&lt;/code&gt; directory.</source>
          <target state="translated">&lt;code&gt;input_receiver_fn_map&lt;/code&gt; を介して渡される各モードについて、このメソッドは &lt;code&gt;input_receiver_fn&lt;/code&gt; を呼び出してフィーチャとラベル &lt;code&gt;Tensor&lt;/code&gt; を取得することにより、新しいグラフを作成します。次に、このメソッドは、渡されたモードで &lt;code&gt;Estimator&lt;/code&gt; の &lt;code&gt;model_fn&lt;/code&gt; を呼び出して、それらの機能とラベルに基づいてモデルグラフを生成し、指定されたチェックポイント（または、欠落している最新のチェックポイント）をグラフに復元します。変数を &lt;code&gt;SavedModel&lt;/code&gt; に保存するために使用されるモードは1つだけです（優先順位：&lt;a href=&quot;../../../estimator/modekeys#TRAIN&quot;&gt; &lt;code&gt;tf.estimator.ModeKeys.TRAIN&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../../../estimator/modekeys#EVAL&quot;&gt; &lt;code&gt;tf.estimator.ModeKeys.EVAL&lt;/code&gt; &lt;/a&gt;、次に&lt;a href=&quot;../../../estimator/modekeys#PREDICT&quot;&gt; &lt;code&gt;tf.estimator.ModeKeys.PREDICT&lt;/code&gt; &lt;/a&gt;）。 &lt;code&gt;tf.MetaGraphDefs&lt;/code&gt; は、単一の &lt;code&gt;SavedModel&lt;/code&gt; ディレクトリに単一の変数セットで保存されます。</target>
        </trans-unit>
        <trans-unit id="84ad1b7c0e6d676b66b6c0000beb81f60843b517" translate="yes" xml:space="preserve">
          <source>For each mode passed in via the &lt;code&gt;input_receiver_fn_map&lt;/code&gt;, this method builds a new graph by calling the &lt;code&gt;input_receiver_fn&lt;/code&gt; to obtain feature and label &lt;code&gt;Tensor&lt;/code&gt;s. Next, this method calls the &lt;code&gt;Estimator&lt;/code&gt;'s &lt;code&gt;model_fn&lt;/code&gt; in the passed mode to generate the model graph based on those features and labels, and restores the given checkpoint (or, lacking that, the most recent checkpoint) into the graph. Only one of the modes is used for saving variables to the &lt;code&gt;SavedModel&lt;/code&gt; (order of preference: &lt;a href=&quot;../modekeys#TRAIN&quot;&gt;&lt;code&gt;tf.estimator.ModeKeys.TRAIN&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../modekeys#EVAL&quot;&gt;&lt;code&gt;tf.estimator.ModeKeys.EVAL&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;../modekeys#PREDICT&quot;&gt;&lt;code&gt;tf.estimator.ModeKeys.PREDICT&lt;/code&gt;&lt;/a&gt;), such that up to three &lt;code&gt;tf.MetaGraphDefs&lt;/code&gt; are saved with a single set of variables in a single &lt;code&gt;SavedModel&lt;/code&gt; directory.</source>
          <target state="translated">&lt;code&gt;input_receiver_fn_map&lt;/code&gt; を介して渡される各モードについて、このメソッドは &lt;code&gt;input_receiver_fn&lt;/code&gt; を呼び出してフィーチャとラベル &lt;code&gt;Tensor&lt;/code&gt; を取得することにより、新しいグラフを作成します。次に、このメソッドは、渡されたモードで &lt;code&gt;Estimator&lt;/code&gt; の &lt;code&gt;model_fn&lt;/code&gt; を呼び出して、それらの機能とラベルに基づいてモデルグラフを生成し、指定されたチェックポイント（または、欠落している最新のチェックポイント）をグラフに復元します。変数を &lt;code&gt;SavedModel&lt;/code&gt; に保存するために使用されるモードは1つだけです（優先順位：&lt;a href=&quot;../modekeys#TRAIN&quot;&gt; &lt;code&gt;tf.estimator.ModeKeys.TRAIN&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../modekeys#EVAL&quot;&gt; &lt;code&gt;tf.estimator.ModeKeys.EVAL&lt;/code&gt; &lt;/a&gt;、次に&lt;a href=&quot;../modekeys#PREDICT&quot;&gt; &lt;code&gt;tf.estimator.ModeKeys.PREDICT&lt;/code&gt; &lt;/a&gt;）。 &lt;code&gt;tf.MetaGraphDefs&lt;/code&gt; は、単一の &lt;code&gt;SavedModel&lt;/code&gt; ディレクトリに単一の変数セットで保存されます。</target>
        </trans-unit>
        <trans-unit id="b412fda993e08f3c91f400db4d8146e4d0f5bc5f" translate="yes" xml:space="preserve">
          <source>For each mode passed in via the &lt;code&gt;input_receiver_fn_map&lt;/code&gt;, this method builds a new graph by calling the &lt;code&gt;input_receiver_fn&lt;/code&gt; to obtain feature and label &lt;code&gt;Tensor&lt;/code&gt;s. Next, this method calls the &lt;code&gt;Estimator&lt;/code&gt;'s &lt;code&gt;model_fn&lt;/code&gt; in the passed mode to generate the model graph based on those features and labels, and restores the given checkpoint (or, lacking that, the most recent checkpoint) into the graph. Only one of the modes is used for saving variables to the &lt;code&gt;SavedModel&lt;/code&gt; (order of preference: &lt;a href=&quot;modekeys#TRAIN&quot;&gt;&lt;code&gt;tf.estimator.ModeKeys.TRAIN&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;modekeys#EVAL&quot;&gt;&lt;code&gt;tf.estimator.ModeKeys.EVAL&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;modekeys#PREDICT&quot;&gt;&lt;code&gt;tf.estimator.ModeKeys.PREDICT&lt;/code&gt;&lt;/a&gt;), such that up to three &lt;code&gt;tf.MetaGraphDefs&lt;/code&gt; are saved with a single set of variables in a single &lt;code&gt;SavedModel&lt;/code&gt; directory.</source>
          <target state="translated">&lt;code&gt;input_receiver_fn_map&lt;/code&gt; を介して渡される各モードについて、このメソッドは &lt;code&gt;input_receiver_fn&lt;/code&gt; を呼び出してフィーチャとラベル &lt;code&gt;Tensor&lt;/code&gt; を取得することにより、新しいグラフを作成します。次に、このメソッドは、渡されたモードで &lt;code&gt;Estimator&lt;/code&gt; の &lt;code&gt;model_fn&lt;/code&gt; を呼び出して、それらの機能とラベルに基づいてモデルグラフを生成し、指定されたチェックポイント（または、欠落している最新のチェックポイント）をグラフに復元します。変数を &lt;code&gt;SavedModel&lt;/code&gt; に保存するために使用されるモードは1つだけです（優先順位：&lt;a href=&quot;modekeys#TRAIN&quot;&gt; &lt;code&gt;tf.estimator.ModeKeys.TRAIN&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;modekeys#EVAL&quot;&gt; &lt;code&gt;tf.estimator.ModeKeys.EVAL&lt;/code&gt; &lt;/a&gt;、次に&lt;a href=&quot;modekeys#PREDICT&quot;&gt; &lt;code&gt;tf.estimator.ModeKeys.PREDICT&lt;/code&gt; &lt;/a&gt;）。 &lt;code&gt;tf.MetaGraphDefs&lt;/code&gt; は、単一の &lt;code&gt;SavedModel&lt;/code&gt; ディレクトリに単一の変数セットで保存されます。</target>
        </trans-unit>
        <trans-unit id="36b982fc21506a7f2190761f16a3f5fcc9ede9c0" translate="yes" xml:space="preserve">
          <source>For each patch, right-multiplies the filter matrix and the image patch vector.</source>
          <target state="translated">各パッチに対して,フィルタ行列と画像パッチベクトルを右倍します.</target>
        </trans-unit>
        <trans-unit id="495118d7bdd44315c26aae5e3bf24f66dcd99d0d" translate="yes" xml:space="preserve">
          <source>For each point that is sampled during kmeans++ initialization, this parameter specifies the number of additional points to draw from the current distribution before selecting the best. If a negative value is specified, a heuristic is used to sample &lt;code&gt;O(log(num_to_sample))&lt;/code&gt; additional points. Used only if &lt;code&gt;initial_clusters=KMeansClustering.KMEANS_PLUS_PLUS_INIT&lt;/code&gt;.</source>
          <target state="translated">kmeans ++の初期化中にサンプリングされる各ポイントについて、このパラメーターは、最適なものを選択する前に、現在の分布から描画する追加のポイントの数を指定します。負の値が指定された場合、ヒューリスティックを使用して &lt;code&gt;O(log(num_to_sample))&lt;/code&gt; の追加ポイントをサンプリングします。 &lt;code&gt;initial_clusters=KMeansClustering.KMEANS_PLUS_PLUS_INIT&lt;/code&gt; の場合にのみ使用されます。</target>
        </trans-unit>
        <trans-unit id="840e6ba53f4417ca11f6403319bc3e83421092e5" translate="yes" xml:space="preserve">
          <source>For each sample &lt;code&gt;x_i&lt;/code&gt; in &lt;code&gt;inputs&lt;/code&gt; with &lt;code&gt;k&lt;/code&gt; features, we compute the mean and variance of the sample:</source>
          <target state="translated">各サンプルについて &lt;code&gt;x_i&lt;/code&gt; で &lt;code&gt;inputs&lt;/code&gt; して &lt;code&gt;k&lt;/code&gt; 個の特徴を、我々は平均と標本の分散を計算します。</target>
        </trans-unit>
        <trans-unit id="1c15a30d01baef30188c69bc7ff85b21e3e935e7" translate="yes" xml:space="preserve">
          <source>For each step, calls &lt;code&gt;input_fn&lt;/code&gt;, which returns one batch of data. Evaluates until:</source>
          <target state="translated">ステップごとに、 &lt;code&gt;input_fn&lt;/code&gt; を呼び出します。これは、データの1つのバッチを返します。評価するまで：</target>
        </trans-unit>
        <trans-unit id="76eabb6e369edfcf348e56ad957e852ddec0f36e" translate="yes" xml:space="preserve">
          <source>For each string in the input &lt;code&gt;Tensor&lt;/code&gt;, creates a substring starting at index &lt;code&gt;pos&lt;/code&gt; with a total length of &lt;code&gt;len&lt;/code&gt;.</source>
          <target state="translated">入力 &lt;code&gt;Tensor&lt;/code&gt; の各文字列について、インデックス &lt;code&gt;pos&lt;/code&gt; から始まり、全長が &lt;code&gt;len&lt;/code&gt; の部分文字列を作成します。</target>
        </trans-unit>
        <trans-unit id="ad124c85b4e4ed2992f3d2d7226cc6682efb0d10" translate="yes" xml:space="preserve">
          <source>For each timestep in the input tensor (dimension #1 in the tensor), if all values in the input tensor at that timestep are equal to &lt;code&gt;mask_value&lt;/code&gt;, then the timestep will be masked (skipped) in all downstream layers (as long as they support masking).</source>
          <target state="translated">入力テンソルの各タイムステップ（テンソルの次元＃1）について、そのタイムステップでの入力テンソルのすべての値が &lt;code&gt;mask_value&lt;/code&gt; に等しい場合、タイムステップはすべてのダウンストリームレイヤーでマスクされます（スキップされます）マスキング）。</target>
        </trans-unit>
        <trans-unit id="2370b2414271135ef1678cb23ef39f45a5fc2cb3" translate="yes" xml:space="preserve">
          <source>For each value x in &lt;code&gt;error = y_true - y_pred&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;error = y_true - y_pred&lt;/code&gt; 各値xについて= y_true-y_pred：</target>
        </trans-unit>
        <trans-unit id="b30a7e920276e3b902f956f91fd308b9a443509f" translate="yes" xml:space="preserve">
          <source>For each value x in &lt;code&gt;error=labels-predictions&lt;/code&gt;, the following is calculated:</source>
          <target state="translated">&lt;code&gt;error=labels-predictions&lt;/code&gt; の各値xについて、以下が計算されます。</target>
        </trans-unit>
        <trans-unit id="0e81aa8da6e2ca9d6903d446870611925fa37da7" translate="yes" xml:space="preserve">
          <source>For estimation of the metric over a stream of data, the function creates an &lt;code&gt;update_op&lt;/code&gt; operation that updates the accuracy of each class and returns them.</source>
          <target state="translated">データのストリーム &lt;code&gt;update_op&lt;/code&gt; のメトリックを推定するために、関数は各クラスの精度を更新してそれらを返すupdate_opオペレーションを作成します。</target>
        </trans-unit>
        <trans-unit id="bbcc260a82187cfff98a34fb724a50f62fa1bb51" translate="yes" xml:space="preserve">
          <source>For estimation of the metric over a stream of data, the function creates an &lt;code&gt;update_op&lt;/code&gt; operation that updates these variables and returns the &lt;code&gt;accuracy&lt;/code&gt;. Internally, an &lt;code&gt;is_correct&lt;/code&gt; operation computes a &lt;code&gt;Tensor&lt;/code&gt; with elements 1.0 where the corresponding elements of &lt;code&gt;predictions&lt;/code&gt; and &lt;code&gt;labels&lt;/code&gt; match and 0.0 otherwise. Then &lt;code&gt;update_op&lt;/code&gt; increments &lt;code&gt;total&lt;/code&gt; with the reduced sum of the product of &lt;code&gt;weights&lt;/code&gt; and &lt;code&gt;is_correct&lt;/code&gt;, and it increments &lt;code&gt;count&lt;/code&gt; with the reduced sum of &lt;code&gt;weights&lt;/code&gt;.</source>
          <target state="translated">データのストリームに対するメトリックを推定するために、関数はこれらの変数を更新して &lt;code&gt;accuracy&lt;/code&gt; を返す &lt;code&gt;update_op&lt;/code&gt; オペレーションを作成します。内部的には、 &lt;code&gt;is_correct&lt;/code&gt; 演算は、 &lt;code&gt;predictions&lt;/code&gt; と &lt;code&gt;labels&lt;/code&gt; 対応する要素が一致する要素1.0 とそれ以外の場合0.0の &lt;code&gt;Tensor&lt;/code&gt; を計算します。次いで &lt;code&gt;update_op&lt;/code&gt; ずつ &lt;code&gt;total&lt;/code&gt; の積の減少和と &lt;code&gt;weights&lt;/code&gt; と &lt;code&gt;is_correct&lt;/code&gt; 、それが増分 &lt;code&gt;count&lt;/code&gt; の減少和と &lt;code&gt;weights&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dad08a503e11b5156a4a3427dfc7515950a48e4f" translate="yes" xml:space="preserve">
          <source>For estimation of the metric over a stream of data, the function creates an &lt;code&gt;update_op&lt;/code&gt; operation that updates these variables and returns the &lt;code&gt;auc&lt;/code&gt;.</source>
          <target state="translated">データのストリームを超えるメトリックの推定には、関数が作成されます &lt;code&gt;update_op&lt;/code&gt; のこれらの変数を更新し、返す操作 &lt;code&gt;auc&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6e6ad6df8adaafa9f6c503da039855e65bd9b58e" translate="yes" xml:space="preserve">
          <source>For estimation of the metric over a stream of data, the function creates an &lt;code&gt;update_op&lt;/code&gt; operation that updates these variables and returns the &lt;code&gt;mean&lt;/code&gt;. &lt;code&gt;update_op&lt;/code&gt; increments &lt;code&gt;total&lt;/code&gt; with the reduced sum of the product of &lt;code&gt;values&lt;/code&gt; and &lt;code&gt;weights&lt;/code&gt;, and it increments &lt;code&gt;count&lt;/code&gt; with the reduced sum of &lt;code&gt;weights&lt;/code&gt;.</source>
          <target state="translated">データのストリームに対するメトリックを推定するために、関数はこれらの変数を更新して &lt;code&gt;mean&lt;/code&gt; を返す &lt;code&gt;update_op&lt;/code&gt; 操作を作成します。 &lt;code&gt;update_op&lt;/code&gt; 増分が &lt;code&gt;total&lt;/code&gt; の積の減少和と &lt;code&gt;values&lt;/code&gt; と &lt;code&gt;weights&lt;/code&gt; 、それが増分 &lt;code&gt;count&lt;/code&gt; の減少和と &lt;code&gt;weights&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d4ab931d2efc0e42b3a757d047bf7f98096c2b78" translate="yes" xml:space="preserve">
          <source>For estimation of the metric over a stream of data, the function creates an &lt;code&gt;update_op&lt;/code&gt; operation that updates these variables and returns the &lt;code&gt;mean_absolute_error&lt;/code&gt;. Internally, an &lt;code&gt;absolute_errors&lt;/code&gt; operation computes the absolute value of the differences between &lt;code&gt;predictions&lt;/code&gt; and &lt;code&gt;labels&lt;/code&gt;. Then &lt;code&gt;update_op&lt;/code&gt; increments &lt;code&gt;total&lt;/code&gt; with the reduced sum of the product of &lt;code&gt;weights&lt;/code&gt; and &lt;code&gt;absolute_errors&lt;/code&gt;, and it increments &lt;code&gt;count&lt;/code&gt; with the reduced sum of &lt;code&gt;weights&lt;/code&gt;</source>
          <target state="translated">データのストリームに対するメトリックを推定するために、関数はこれらの変数を更新して &lt;code&gt;mean_absolute_error&lt;/code&gt; を返す &lt;code&gt;update_op&lt;/code&gt; 操作を作成します。内部的に、 &lt;code&gt;absolute_errors&lt;/code&gt; オペレーションは、 &lt;code&gt;predictions&lt;/code&gt; と &lt;code&gt;labels&lt;/code&gt; 差の絶対値を計算します。次いで &lt;code&gt;update_op&lt;/code&gt; ずつ &lt;code&gt;total&lt;/code&gt; の積の減少和と &lt;code&gt;weights&lt;/code&gt; と &lt;code&gt;absolute_errors&lt;/code&gt; 、その増分は、 &lt;code&gt;count&lt;/code&gt; の減少和と &lt;code&gt;weights&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="614a1783a568ced9d248f52d9352d35b40792a7a" translate="yes" xml:space="preserve">
          <source>For estimation of the metric over a stream of data, the function creates an &lt;code&gt;update_op&lt;/code&gt; operation that updates these variables and returns the &lt;code&gt;mean_distance&lt;/code&gt;.</source>
          <target state="translated">データのストリームに対するメトリックを推定するために、関数はこれらの変数を更新して &lt;code&gt;mean_distance&lt;/code&gt; を返す &lt;code&gt;update_op&lt;/code&gt; 操作を作成します。</target>
        </trans-unit>
        <trans-unit id="b7bdad2b2535c192103954072920dd86f8d7f97e" translate="yes" xml:space="preserve">
          <source>For estimation of the metric over a stream of data, the function creates an &lt;code&gt;update_op&lt;/code&gt; operation that updates these variables and returns the &lt;code&gt;mean_iou&lt;/code&gt;.</source>
          <target state="translated">データストリームのメトリックを推定するために、関数はこれらの変数を更新して &lt;code&gt;mean_iou&lt;/code&gt; を返す &lt;code&gt;update_op&lt;/code&gt; オペレーションを作成します。</target>
        </trans-unit>
        <trans-unit id="21a28b15071e2e3057222499cce4c758670a6204" translate="yes" xml:space="preserve">
          <source>For estimation of the metric over a stream of data, the function creates an &lt;code&gt;update_op&lt;/code&gt; operation that updates these variables and returns the &lt;code&gt;mean_reative_error&lt;/code&gt;. Internally, a &lt;code&gt;relative_errors&lt;/code&gt; operation divides the absolute value of the differences between &lt;code&gt;predictions&lt;/code&gt; and &lt;code&gt;labels&lt;/code&gt; by the &lt;code&gt;normalizer&lt;/code&gt;. Then &lt;code&gt;update_op&lt;/code&gt; increments &lt;code&gt;total&lt;/code&gt; with the reduced sum of the product of &lt;code&gt;weights&lt;/code&gt; and &lt;code&gt;relative_errors&lt;/code&gt;, and it increments &lt;code&gt;count&lt;/code&gt; with the reduced sum of &lt;code&gt;weights&lt;/code&gt;.</source>
          <target state="translated">データのストリームに対するメトリックを推定するために、関数はこれらの変数を更新して &lt;code&gt;mean_reative_error&lt;/code&gt; を返す &lt;code&gt;update_op&lt;/code&gt; 操作を作成します。内部的には、 &lt;code&gt;relative_errors&lt;/code&gt; 操作は、 &lt;code&gt;normalizer&lt;/code&gt; によって &lt;code&gt;predictions&lt;/code&gt; と &lt;code&gt;labels&lt;/code&gt; 差の絶対値を割ります。次いで &lt;code&gt;update_op&lt;/code&gt; ずつ &lt;code&gt;total&lt;/code&gt; の積の減少和と &lt;code&gt;weights&lt;/code&gt; と &lt;code&gt;relative_errors&lt;/code&gt; 、それが増分 &lt;code&gt;count&lt;/code&gt; の減少和と &lt;code&gt;weights&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2622e71a2a20b6c576fe07f66c3861f4ae1d6554" translate="yes" xml:space="preserve">
          <source>For estimation of the metric over a stream of data, the function creates an &lt;code&gt;update_op&lt;/code&gt; operation that updates these variables and returns the &lt;code&gt;mean_squared_error&lt;/code&gt;. Internally, a &lt;code&gt;squared_error&lt;/code&gt; operation computes the element-wise square of the difference between &lt;code&gt;predictions&lt;/code&gt; and &lt;code&gt;labels&lt;/code&gt;. Then &lt;code&gt;update_op&lt;/code&gt; increments &lt;code&gt;total&lt;/code&gt; with the reduced sum of the product of &lt;code&gt;weights&lt;/code&gt; and &lt;code&gt;squared_error&lt;/code&gt;, and it increments &lt;code&gt;count&lt;/code&gt; with the reduced sum of &lt;code&gt;weights&lt;/code&gt;.</source>
          <target state="translated">データストリームのメトリックを推定するために、関数はこれらの変数を更新して &lt;code&gt;mean_squared_error&lt;/code&gt; を返す &lt;code&gt;update_op&lt;/code&gt; オペレーションを作成します。内部的には、 &lt;code&gt;squared_error&lt;/code&gt; 演算は、 &lt;code&gt;predictions&lt;/code&gt; と &lt;code&gt;labels&lt;/code&gt; 差の要素ごとの二乗を計算します。次いで &lt;code&gt;update_op&lt;/code&gt; ずつ &lt;code&gt;total&lt;/code&gt; の積の減少和と &lt;code&gt;weights&lt;/code&gt; と &lt;code&gt;squared_error&lt;/code&gt; 、それが増分 &lt;code&gt;count&lt;/code&gt; の減少和と &lt;code&gt;weights&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="482044def86d900d6f880303c2541fe53cd45fe2" translate="yes" xml:space="preserve">
          <source>For estimation of the metric over a stream of data, the function creates an &lt;code&gt;update_op&lt;/code&gt; operation that updates these variables and returns the &lt;code&gt;percentage&lt;/code&gt;.</source>
          <target state="translated">データストリームのメトリックを推定するために、関数はこれらの変数を更新して &lt;code&gt;percentage&lt;/code&gt; を返す &lt;code&gt;update_op&lt;/code&gt; オペレーションを作成します。</target>
        </trans-unit>
        <trans-unit id="11887ce5609f24f245ab19a0dae14981801f1e03" translate="yes" xml:space="preserve">
          <source>For estimation of the metric over a stream of data, the function creates an &lt;code&gt;update_op&lt;/code&gt; operation that updates these variables and returns the &lt;code&gt;precision&lt;/code&gt;.</source>
          <target state="translated">データのストリームに対するメトリックを推定するために、関数はこれらの変数を更新して &lt;code&gt;precision&lt;/code&gt; を返す &lt;code&gt;update_op&lt;/code&gt; 操作を作成します。</target>
        </trans-unit>
        <trans-unit id="2073b65f678bcea68507c8aced29c54089672a4c" translate="yes" xml:space="preserve">
          <source>For estimation of the metric over a stream of data, the function creates an &lt;code&gt;update_op&lt;/code&gt; operation that updates these variables and returns the &lt;code&gt;precision&lt;/code&gt;. &lt;code&gt;update_op&lt;/code&gt; weights each prediction by the corresponding value in &lt;code&gt;weights&lt;/code&gt;.</source>
          <target state="translated">データのストリームに対するメトリックを推定するために、関数はこれらの変数を更新して &lt;code&gt;precision&lt;/code&gt; を返す &lt;code&gt;update_op&lt;/code&gt; 操作を作成します。 &lt;code&gt;update_op&lt;/code&gt; は、各予測をweightsの対応する値で &lt;code&gt;weights&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="5fa9d8aac2d1f3e8b41e5f969b7c9069f2763710" translate="yes" xml:space="preserve">
          <source>For estimation of the metric over a stream of data, the function creates an &lt;code&gt;update_op&lt;/code&gt; operation that updates these variables and returns the &lt;code&gt;precision_at_&amp;lt;k&amp;gt;&lt;/code&gt;. Internally, a &lt;code&gt;top_k&lt;/code&gt; operation computes a &lt;code&gt;Tensor&lt;/code&gt; indicating the top &lt;code&gt;k&lt;/code&gt;&lt;code&gt;predictions&lt;/code&gt;. Set operations applied to &lt;code&gt;top_k&lt;/code&gt; and &lt;code&gt;labels&lt;/code&gt; calculate the true positives and false positives weighted by &lt;code&gt;weights&lt;/code&gt;. Then &lt;code&gt;update_op&lt;/code&gt; increments &lt;code&gt;true_positive_at_&amp;lt;k&amp;gt;&lt;/code&gt; and &lt;code&gt;false_positive_at_&amp;lt;k&amp;gt;&lt;/code&gt; using these values.</source>
          <target state="translated">データストリームのメトリックを推定するために、関数はこれらの変数を更新し、 &lt;code&gt;precision_at_&amp;lt;k&amp;gt;&lt;/code&gt; を返す &lt;code&gt;update_op&lt;/code&gt; オペレーションを作成します。内部的には、 &lt;code&gt;top_k&lt;/code&gt; 演算は、上位 &lt;code&gt;k&lt;/code&gt; の &lt;code&gt;predictions&lt;/code&gt; 示す &lt;code&gt;Tensor&lt;/code&gt; を計算します。設定操作はして適用 &lt;code&gt;top_k&lt;/code&gt; と &lt;code&gt;labels&lt;/code&gt; で重み付け真陽性と偽陽性の計算 &lt;code&gt;weights&lt;/code&gt; 。次に、 &lt;code&gt;update_op&lt;/code&gt; は、これらの値を使用して &lt;code&gt;true_positive_at_&amp;lt;k&amp;gt;&lt;/code&gt; および &lt;code&gt;false_positive_at_&amp;lt;k&amp;gt;&lt;/code&gt; をインクリメントします。</target>
        </trans-unit>
        <trans-unit id="1d641bbb0bd1f36939980470649afd513c5fe109" translate="yes" xml:space="preserve">
          <source>For estimation of the metric over a stream of data, the function creates an &lt;code&gt;update_op&lt;/code&gt; operation that updates these variables and returns the &lt;code&gt;recall&lt;/code&gt;.</source>
          <target state="translated">データのストリームに対するメトリックを推定するために、関数はこれらの変数を更新して再 &lt;code&gt;recall&lt;/code&gt; を返す &lt;code&gt;update_op&lt;/code&gt; 操作を作成します。</target>
        </trans-unit>
        <trans-unit id="9e926696bf238fa1af7b7fd153c6b149672d0579" translate="yes" xml:space="preserve">
          <source>For estimation of the metric over a stream of data, the function creates an &lt;code&gt;update_op&lt;/code&gt; operation that updates these variables and returns the &lt;code&gt;recall_at_&amp;lt;k&amp;gt;&lt;/code&gt;. Internally, a &lt;code&gt;top_k&lt;/code&gt; operation computes a &lt;code&gt;Tensor&lt;/code&gt; indicating the top &lt;code&gt;k&lt;/code&gt;&lt;code&gt;predictions&lt;/code&gt;. Set operations applied to &lt;code&gt;top_k&lt;/code&gt; and &lt;code&gt;labels&lt;/code&gt; calculate the true positives and false negatives weighted by &lt;code&gt;weights&lt;/code&gt;. Then &lt;code&gt;update_op&lt;/code&gt; increments &lt;code&gt;true_positive_at_&amp;lt;k&amp;gt;&lt;/code&gt; and &lt;code&gt;false_negative_at_&amp;lt;k&amp;gt;&lt;/code&gt; using these values.</source>
          <target state="translated">データストリームのメトリックを推定するために、関数はこれらの変数を更新し、 &lt;code&gt;recall_at_&amp;lt;k&amp;gt;&lt;/code&gt; を返す &lt;code&gt;update_op&lt;/code&gt; 操作を作成します。内部的には、 &lt;code&gt;top_k&lt;/code&gt; 演算は、上位 &lt;code&gt;k&lt;/code&gt; の &lt;code&gt;predictions&lt;/code&gt; 示す &lt;code&gt;Tensor&lt;/code&gt; を計算します。設定操作はして適用 &lt;code&gt;top_k&lt;/code&gt; と &lt;code&gt;labels&lt;/code&gt; で重み付け真陽性と偽陰性の計算 &lt;code&gt;weights&lt;/code&gt; 。次に、 &lt;code&gt;update_op&lt;/code&gt; は、これらの値を使用して &lt;code&gt;true_positive_at_&amp;lt;k&amp;gt;&lt;/code&gt; および &lt;code&gt;false_negative_at_&amp;lt;k&amp;gt;&lt;/code&gt; をインクリメントします。</target>
        </trans-unit>
        <trans-unit id="e592409ad4457c95b12184bde9fb30acffe72920" translate="yes" xml:space="preserve">
          <source>For estimation of the metric over a stream of data, the function creates an &lt;code&gt;update_op&lt;/code&gt; operation that updates these variables and returns the &lt;code&gt;root_mean_squared_error&lt;/code&gt;. Internally, a &lt;code&gt;squared_error&lt;/code&gt; operation computes the element-wise square of the difference between &lt;code&gt;predictions&lt;/code&gt; and &lt;code&gt;labels&lt;/code&gt;. Then &lt;code&gt;update_op&lt;/code&gt; increments &lt;code&gt;total&lt;/code&gt; with the reduced sum of the product of &lt;code&gt;weights&lt;/code&gt; and &lt;code&gt;squared_error&lt;/code&gt;, and it increments &lt;code&gt;count&lt;/code&gt; with the reduced sum of &lt;code&gt;weights&lt;/code&gt;.</source>
          <target state="translated">データのストリームに対するメトリックを推定するために、関数はこれらの変数を更新して &lt;code&gt;root_mean_squared_error&lt;/code&gt; を返す &lt;code&gt;update_op&lt;/code&gt; 操作を作成します。内部的には、 &lt;code&gt;squared_error&lt;/code&gt; 演算は、 &lt;code&gt;predictions&lt;/code&gt; と &lt;code&gt;labels&lt;/code&gt; 差の要素ごとの二乗を計算します。次いで &lt;code&gt;update_op&lt;/code&gt; ずつ &lt;code&gt;total&lt;/code&gt; の積の減少和と &lt;code&gt;weights&lt;/code&gt; と &lt;code&gt;squared_error&lt;/code&gt; 、それが増分 &lt;code&gt;count&lt;/code&gt; の減少和と &lt;code&gt;weights&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8a7f0bed98595b5568f1d9ffe04c5cc4a5ca7387" translate="yes" xml:space="preserve">
          <source>For estimation of the metric over a stream of data, the function creates an &lt;code&gt;update_op&lt;/code&gt; operation that updates these variables and returns the &lt;code&gt;sensitivity&lt;/code&gt;. &lt;code&gt;update_op&lt;/code&gt; increments the &lt;code&gt;true_positives&lt;/code&gt;, &lt;code&gt;true_negatives&lt;/code&gt;, &lt;code&gt;false_positives&lt;/code&gt; and &lt;code&gt;false_negatives&lt;/code&gt; counts with the weight of each case found in the &lt;code&gt;predictions&lt;/code&gt; and &lt;code&gt;labels&lt;/code&gt;.</source>
          <target state="translated">データのストリームに対するメトリックを推定するために、関数はこれらの変数を更新して &lt;code&gt;sensitivity&lt;/code&gt; を返す &lt;code&gt;update_op&lt;/code&gt; 操作を作成します。 &lt;code&gt;update_op&lt;/code&gt; は、 &lt;code&gt;true_positives&lt;/code&gt; 、 &lt;code&gt;true_negatives&lt;/code&gt; 、 &lt;code&gt;false_positives&lt;/code&gt; 、および &lt;code&gt;false_negatives&lt;/code&gt; カウントを、 &lt;code&gt;predictions&lt;/code&gt; と &lt;code&gt;labels&lt;/code&gt; 見つかった各ケースの重みでインクリメントします。</target>
        </trans-unit>
        <trans-unit id="b07e75d0103c0e548428284e5efc113eab68537b" translate="yes" xml:space="preserve">
          <source>For estimation of the metric over a stream of data, the function creates an &lt;code&gt;update_op&lt;/code&gt; operation that updates these variables and returns the &lt;code&gt;specificity&lt;/code&gt;. &lt;code&gt;update_op&lt;/code&gt; increments the &lt;code&gt;true_positives&lt;/code&gt;, &lt;code&gt;true_negatives&lt;/code&gt;, &lt;code&gt;false_positives&lt;/code&gt; and &lt;code&gt;false_negatives&lt;/code&gt; counts with the weight of each case found in the &lt;code&gt;predictions&lt;/code&gt; and &lt;code&gt;labels&lt;/code&gt;.</source>
          <target state="translated">データストリームのメトリックを推定するために、関数はこれらの変数を更新して &lt;code&gt;specificity&lt;/code&gt; を返す &lt;code&gt;update_op&lt;/code&gt; オペレーションを作成します。 &lt;code&gt;update_op&lt;/code&gt; は、 &lt;code&gt;true_positives&lt;/code&gt; 、 &lt;code&gt;true_negatives&lt;/code&gt; 、 &lt;code&gt;false_positives&lt;/code&gt; 、および &lt;code&gt;false_negatives&lt;/code&gt; カウントを、 &lt;code&gt;predictions&lt;/code&gt; と &lt;code&gt;labels&lt;/code&gt; 見つかった各ケースの重みでインクリメントします。</target>
        </trans-unit>
        <trans-unit id="84f3ab8b259e10c767171cb16e1ed0bedcdf7bd6" translate="yes" xml:space="preserve">
          <source>For estimation of the metric over a stream of data, the function creates an &lt;code&gt;update_op&lt;/code&gt; that updates these variables and returns the &lt;code&gt;recall&lt;/code&gt;. &lt;code&gt;update_op&lt;/code&gt; weights each prediction by the corresponding value in &lt;code&gt;weights&lt;/code&gt;.</source>
          <target state="translated">データのストリームに対するメトリックを推定するために、関数はこれらの変数を更新して再 &lt;code&gt;recall&lt;/code&gt; を返す &lt;code&gt;update_op&lt;/code&gt; を作成します。 &lt;code&gt;update_op&lt;/code&gt; は、各予測をweightsの対応する値で &lt;code&gt;weights&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="16fe84732ca0277f0c85a01f97b90cbe49eed312" translate="yes" xml:space="preserve">
          <source>For eval, merges metrics by adding &lt;code&gt;head.name&lt;/code&gt; suffix to the keys in eval metrics, such as &lt;code&gt;precision/head1.name&lt;/code&gt;, &lt;code&gt;precision/head2.name&lt;/code&gt;.</source>
          <target state="translated">evalの場合、 &lt;code&gt;precision/head1.name&lt;/code&gt; 、 &lt;code&gt;precision/head2.name&lt;/code&gt; などのevalメトリックのキーに &lt;code&gt;head.name&lt;/code&gt; サフィックスを追加してメトリックをマージします。</target>
        </trans-unit>
        <trans-unit id="096f439eadd884160cca18be357dd236e0d9b954" translate="yes" xml:space="preserve">
          <source>For evaluation and prediction, &lt;code&gt;model_fn&lt;/code&gt; gets per-core batch size and &lt;code&gt;input_fn&lt;/code&gt; get per-host batch size.</source>
          <target state="translated">評価・予測のために、 &lt;code&gt;model_fn&lt;/code&gt; は、コア単位のバッチサイズとなります &lt;code&gt;input_fn&lt;/code&gt; GETホストごとのバッチサイズを。</target>
        </trans-unit>
        <trans-unit id="9aaddffdb76b42aacd2bb37b2bc66b758d2d660a" translate="yes" xml:space="preserve">
          <source>For evaluation, &lt;code&gt;eval_metrics&lt;/code&gt;is a tuple of &lt;code&gt;metric_fn&lt;/code&gt; and &lt;code&gt;tensors&lt;/code&gt;, where &lt;code&gt;metric_fn&lt;/code&gt; runs on CPU to generate metrics and &lt;code&gt;tensors&lt;/code&gt; represents the &lt;code&gt;Tensor&lt;/code&gt;s transferred from TPU system to CPU host and passed to &lt;code&gt;metric_fn&lt;/code&gt;. To be precise, TPU evaluation expects a slightly different signature from the &lt;a href=&quot;../../../../estimator/estimator&quot;&gt;&lt;code&gt;tf.estimator.Estimator&lt;/code&gt;&lt;/a&gt;. While &lt;a href=&quot;../../../../estimator/estimatorspec#eval_metric_ops&quot;&gt;&lt;code&gt;EstimatorSpec.eval_metric_ops&lt;/code&gt;&lt;/a&gt; expects a dict, &lt;code&gt;TPUEstimatorSpec.eval_metrics&lt;/code&gt; is a tuple of &lt;code&gt;metric_fn&lt;/code&gt; and &lt;code&gt;tensors&lt;/code&gt;. The &lt;code&gt;tensors&lt;/code&gt; could be a list of &lt;code&gt;Tensor&lt;/code&gt;s or dict of names to &lt;code&gt;Tensor&lt;/code&gt;s. The &lt;code&gt;tensors&lt;/code&gt; usually specify the model logits, which are transferred back from TPU system to CPU host. All tensors must have be batch-major, i.e., the batch size is the first dimension. Once all tensors are available at CPU host from all shards, they are concatenated (on CPU) and passed as positional arguments to the &lt;code&gt;metric_fn&lt;/code&gt; if &lt;code&gt;tensors&lt;/code&gt; is list or keyword arguments if &lt;code&gt;tensors&lt;/code&gt; is a dict. &lt;code&gt;metric_fn&lt;/code&gt; takes the &lt;code&gt;tensors&lt;/code&gt; and returns a dict from metric string name to the result of calling a metric function, namely a &lt;code&gt;(metric_tensor, update_op)&lt;/code&gt; tuple. See &lt;code&gt;TPUEstimator&lt;/code&gt; for MNIST example how to specify the &lt;code&gt;eval_metrics&lt;/code&gt;.</source>
          <target state="translated">評価のために、 &lt;code&gt;eval_metrics&lt;/code&gt; でのタプル &lt;code&gt;metric_fn&lt;/code&gt; 及び &lt;code&gt;tensors&lt;/code&gt; 、 &lt;code&gt;metric_fn&lt;/code&gt; は、メトリックとを生成するためにCPU上で実行 &lt;code&gt;tensors&lt;/code&gt; 表す &lt;code&gt;Tensor&lt;/code&gt; sがCPUホストにTPUシステムから転送され、渡さ &lt;code&gt;metric_fn&lt;/code&gt; 。正確には、TPU評価は&lt;a href=&quot;../../../../estimator/estimator&quot;&gt; &lt;code&gt;tf.estimator.Estimator&lt;/code&gt; &lt;/a&gt;とは少し異なるシグネチャを想定しています。しながら&lt;a href=&quot;../../../../estimator/estimatorspec#eval_metric_ops&quot;&gt; &lt;code&gt;EstimatorSpec.eval_metric_ops&lt;/code&gt; は&lt;/a&gt;辞書を期待し、 &lt;code&gt;TPUEstimatorSpec.eval_metrics&lt;/code&gt; はのタプルで &lt;code&gt;metric_fn&lt;/code&gt; と &lt;code&gt;tensors&lt;/code&gt; 。 &lt;code&gt;tensors&lt;/code&gt; リスト可能性があり &lt;code&gt;Tensor&lt;/code&gt; sまたは &lt;code&gt;Tensor&lt;/code&gt; への名前の辞書。 &lt;code&gt;tensors&lt;/code&gt; 通常、CPUホストにTPUシステムから戻されるモデルlogitsを指定します。すべてのテンソルは、バッチメジャーでなければなりません。つまり、バッチサイズは最初の次元です。すべてのテンソルは、すべての破片から、CPUのホストで利用可能になったら、それらが連結されている（CPUの）との位置引数として渡さ &lt;code&gt;metric_fn&lt;/code&gt; 場合 &lt;code&gt;tensors&lt;/code&gt; 場合は、リストまたはキーワード引数である &lt;code&gt;tensors&lt;/code&gt; 辞書です。 &lt;code&gt;metric_fn&lt;/code&gt; は &lt;code&gt;tensors&lt;/code&gt; を受け取り、メトリック文字列名からメトリック関数の呼び出し結果、つまり &lt;code&gt;(metric_tensor, update_op)&lt;/code&gt; タプルへのディクテーションを返します。 &lt;code&gt;TPUEstimator&lt;/code&gt; を参照してくださいMNISTの例では、 &lt;code&gt;eval_metrics&lt;/code&gt; の指定方法。</target>
        </trans-unit>
        <trans-unit id="f118a36ef432860d92562aadbab18ae4b06bc7e8" translate="yes" xml:space="preserve">
          <source>For evaluation, &lt;code&gt;eval_metrics&lt;/code&gt;is a tuple of &lt;code&gt;metric_fn&lt;/code&gt; and &lt;code&gt;tensors&lt;/code&gt;, where &lt;code&gt;metric_fn&lt;/code&gt; runs on CPU to generate metrics and &lt;code&gt;tensors&lt;/code&gt; represents the &lt;code&gt;Tensor&lt;/code&gt;s transferred from TPU system to CPU host and passed to &lt;code&gt;metric_fn&lt;/code&gt;. To be precise, TPU evaluation expects a slightly different signature from the &lt;a href=&quot;../../../../estimator/estimator&quot;&gt;&lt;code&gt;tf.estimator.Estimator&lt;/code&gt;&lt;/a&gt;. While &lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/estimator/EstimatorSpec#eval_metric_ops&quot;&gt;&lt;code&gt;EstimatorSpec.eval_metric_ops&lt;/code&gt;&lt;/a&gt; expects a dict, &lt;code&gt;TPUEstimatorSpec.eval_metrics&lt;/code&gt; is a tuple of &lt;code&gt;metric_fn&lt;/code&gt; and &lt;code&gt;tensors&lt;/code&gt;. The &lt;code&gt;tensors&lt;/code&gt; could be a list of &lt;code&gt;Tensor&lt;/code&gt;s or dict of names to &lt;code&gt;Tensor&lt;/code&gt;s. The &lt;code&gt;tensors&lt;/code&gt; usually specify the model logits, which are transferred back from TPU system to CPU host. All tensors must have be batch-major, i.e., the batch size is the first dimension. Once all tensors are available at CPU host from all shards, they are concatenated (on CPU) and passed as positional arguments to the &lt;code&gt;metric_fn&lt;/code&gt; if &lt;code&gt;tensors&lt;/code&gt; is list or keyword arguments if &lt;code&gt;tensors&lt;/code&gt; is a dict. &lt;code&gt;metric_fn&lt;/code&gt; takes the &lt;code&gt;tensors&lt;/code&gt; and returns a dict from metric string name to the result of calling a metric function, namely a &lt;code&gt;(metric_tensor, update_op)&lt;/code&gt; tuple. See &lt;code&gt;TPUEstimator&lt;/code&gt; for MNIST example how to specify the &lt;code&gt;eval_metrics&lt;/code&gt;.</source>
          <target state="translated">評価のために、 &lt;code&gt;eval_metrics&lt;/code&gt; でのタプル &lt;code&gt;metric_fn&lt;/code&gt; 及び &lt;code&gt;tensors&lt;/code&gt; 、 &lt;code&gt;metric_fn&lt;/code&gt; は、メトリックとを生成するためにCPU上で実行 &lt;code&gt;tensors&lt;/code&gt; 表す &lt;code&gt;Tensor&lt;/code&gt; sがCPUホストにTPUシステムから転送され、渡さ &lt;code&gt;metric_fn&lt;/code&gt; 。正確には、TPU評価では、&lt;a href=&quot;../../../../estimator/estimator&quot;&gt; &lt;code&gt;tf.estimator.Estimator&lt;/code&gt; &lt;/a&gt;とはわずかに異なる署名が必要です。一方で&lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/estimator/EstimatorSpec#eval_metric_ops&quot;&gt; &lt;code&gt;EstimatorSpec.eval_metric_ops&lt;/code&gt; は&lt;/a&gt;辞書を期待し、 &lt;code&gt;TPUEstimatorSpec.eval_metrics&lt;/code&gt; はのタプルで &lt;code&gt;metric_fn&lt;/code&gt; と &lt;code&gt;tensors&lt;/code&gt; 。 &lt;code&gt;tensors&lt;/code&gt; リスト可能性があり &lt;code&gt;Tensor&lt;/code&gt; sまたは &lt;code&gt;Tensor&lt;/code&gt; への名前の口述。 &lt;code&gt;tensors&lt;/code&gt; 通常、CPUホストにTPUシステムから戻されるモデルlogitsを指定します。すべてのテンソルはバッチメジャーである必要があります。つまり、バッチサイズが最初の次元です。すべてのテンソルは、すべての破片から、CPUのホストで利用可能になったら、それらが連結されている（CPUの）との位置引数として渡さ &lt;code&gt;metric_fn&lt;/code&gt; 場合 &lt;code&gt;tensors&lt;/code&gt; 場合は、リストまたはキーワード引数である &lt;code&gt;tensors&lt;/code&gt; 辞書です。 &lt;code&gt;metric_fn&lt;/code&gt; は &lt;code&gt;tensors&lt;/code&gt; を受け取り、メトリック文字列名からメトリック関数、つまり &lt;code&gt;(metric_tensor, update_op)&lt;/code&gt; タプルを呼び出した結果へのdictを返します。 &lt;code&gt;TPUEstimator&lt;/code&gt; を参照してくださいMNISTの例では、 &lt;code&gt;eval_metrics&lt;/code&gt; を指定する方法。</target>
        </trans-unit>
        <trans-unit id="233690c252f396e774e862ecef25a5d76e450f3d" translate="yes" xml:space="preserve">
          <source>For every layer, a &lt;code&gt;group&lt;/code&gt; named &lt;code&gt;layer.name&lt;/code&gt;</source>
          <target state="translated">すべてのレイヤーについて、 &lt;code&gt;layer.name&lt;/code&gt; という名前の &lt;code&gt;group&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3e630abe4632e77580d682ff1b578d80d9f94bb8" translate="yes" xml:space="preserve">
          <source>For every such layer group, a group attribute &lt;code&gt;weight_names&lt;/code&gt;, a list of strings (ordered names of weights tensor of the layer).</source>
          <target state="translated">そのようなすべてのレイヤーグループについて、グループ属性 &lt;code&gt;weight_names&lt;/code&gt; 、文字列のリスト（レイヤーの重みテンソルの順序付けられた名前）。</target>
        </trans-unit>
        <trans-unit id="922382a037863a11613e937b2f92117b3dfa1b3d" translate="yes" xml:space="preserve">
          <source>For every weight in the layer, a dataset storing the weight value, named after the weight tensor.</source>
          <target state="translated">レイヤー内のすべての重みについて,重みテンソルにちなんで命名された重み値を格納するデータセット。</target>
        </trans-unit>
        <trans-unit id="177050bf0b29fb3f08398a12bddac7a0a078af5e" translate="yes" xml:space="preserve">
          <source>For example &lt;code&gt;foo[3:5,...,4:5]&lt;/code&gt; on a shape 10x3x3x10 tensor is equivalent to &lt;code&gt;foo[3:5,:,:,4:5]&lt;/code&gt; and &lt;code&gt;foo[3:5,...]&lt;/code&gt; is equivalent to &lt;code&gt;foo[3:5,:,:,:]&lt;/code&gt;.</source>
          <target state="translated">たとえば、形状10x3x3x10テンソルの &lt;code&gt;foo[3:5,...,4:5]&lt;/code&gt; は、 &lt;code&gt;foo[3:5,:,:,4:5]&lt;/code&gt; と同等であり、 &lt;code&gt;foo[3:5,...]&lt;/code&gt; は &lt;code&gt;foo[3:5,:,:,:]&lt;/code&gt; と同等です。</target>
        </trans-unit>
        <trans-unit id="4dd7ff6a28b3c8f6de1619b3709d89a90256ca48" translate="yes" xml:space="preserve">
          <source>For example if we have a file with the following content:</source>
          <target state="translated">例えば、以下のような内容のファイルがあるとします。</target>
        </trans-unit>
        <trans-unit id="315792fe0731f8fd6c7594397b55834eb861bb3c" translate="yes" xml:space="preserve">
          <source>For example if you know all the images in a dataset have shape [28,28,3] you can set it with &lt;code&gt;tf.set_shape&lt;/code&gt;:</source>
          <target state="translated">たとえば、データセット内のすべての画像の形状が[28,28,3]であることがわかっている場合は、 &lt;code&gt;tf.set_shape&lt;/code&gt; で設定できます。</target>
        </trans-unit>
        <trans-unit id="6db6725e9e7d5c088630e348048d1e73fc7657d3" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="translated">例えば</target>
        </trans-unit>
        <trans-unit id="f7cb3885a2d5b333dd84f8883e526c3c627d832d" translate="yes" xml:space="preserve">
          <source>For example, &lt;a href=&quot;function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt;'s &lt;code&gt;input_signature&lt;/code&gt; argument accepts a list (or nested structure) of &lt;code&gt;TypeSpec&lt;/code&gt;s.</source>
          <target state="translated">たとえば、&lt;a href=&quot;function&quot;&gt; &lt;code&gt;tf.function&lt;/code&gt; &lt;/a&gt;の &lt;code&gt;input_signature&lt;/code&gt; 引数は、TypeSpecのリスト（またはネストされた構造）を &lt;code&gt;TypeSpec&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="3e0fb3305e7269deaf00a94f40306ad8dc3b8739" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;foo[:4, tf.newaxis, :2]&lt;/code&gt; would produce a shape &lt;code&gt;(4, 1, 2)&lt;/code&gt; tensor.</source>
          <target state="translated">たとえば、 &lt;code&gt;foo[:4, tf.newaxis, :2]&lt;/code&gt; は、形状 &lt;code&gt;(4, 1, 2)&lt;/code&gt; 4、1、2 ）テンソルを生成します。</target>
        </trans-unit>
        <trans-unit id="fc792685b1d9aab00aa3a406ffbf92c58d9d4cb3" translate="yes" xml:space="preserve">
          <source>For example, N = 2, source[0] is 'hello world' and source[1] is 'a b c', then the output will be</source>
          <target state="translated">例えば、N=2、ソース[0]が'hello world'、ソース[1]が'a b c'の場合、出力は次のようになります。</target>
        </trans-unit>
        <trans-unit id="4cb0994aab88328f91b6706a654056d092b65ec9" translate="yes" xml:space="preserve">
          <source>For example, a &lt;a href=&quot;../../layers/dense&quot;&gt;&lt;code&gt;tf.keras.layers.Dense&lt;/code&gt;&lt;/a&gt; layer, when run on a GPU with a float16 compute dtype, will pass float16 inputs to tf.matmul. But, tf.matmul will do use float32 intermediate math. The performance benefit of float16 is still apparent, due to increased memory bandwidth and the fact modern GPUs have specialized hardware for computing matmuls on float16 while still keeping intermediate computations in float32.</source>
          <target state="translated">たとえば、&lt;a href=&quot;../../layers/dense&quot;&gt; &lt;code&gt;tf.keras.layers.Dense&lt;/code&gt; &lt;/a&gt;レイヤーは、float16計算dtypeを使用してGPUで実行されると、float16入力をtf.matmulに渡します。ただし、tf.matmulはfloat32中間演算を使用します。メモリ帯域幅の増加と、最近のGPUがfloat32での中間計算を維持しながら、float16でのmatmulの計算に特化したハードウェアを備えているという事実により、float16のパフォーマンス上の利点は依然として明らかです。</target>
        </trans-unit>
        <trans-unit id="5f7fb0826a5a86cfd624ab2a8d7d2b8c6ddef6b1" translate="yes" xml:space="preserve">
          <source>For example, a Dense layer returns a list of two values-- per-output weights and the bias value. These can be used to set the weights of another Dense layer:</source>
          <target state="translated">例えば、密なレイヤーは、出力あたりの重みとバイアス値という2つの値のリストを返します。これらは、別の密なレイヤーの重みを設定するために使用できます。</target>
        </trans-unit>
        <trans-unit id="85a2affea67c5e39397e4468831c1fffecfdec41" translate="yes" xml:space="preserve">
          <source>For example, a blockwise &lt;code&gt;3 x 3&lt;/code&gt;&lt;code&gt;LinearOperatorBlockLowerTriangular&lt;/code&gt; is initialized with the list &lt;code&gt;[[op_00], [op_10, op_11], [op_20, op_21, op_22]]&lt;/code&gt;, where the &lt;code&gt;op_ij&lt;/code&gt;, &lt;code&gt;i &amp;lt; 3, j &amp;lt;= i&lt;/code&gt;, are &lt;code&gt;LinearOperator&lt;/code&gt; instances. The &lt;code&gt;LinearOperatorBlockLowerTriangular&lt;/code&gt; behaves as the following blockwise matrix, where &lt;code&gt;0&lt;/code&gt; represents appropriately-sized [batch] matrices of zeros:</source>
          <target state="translated">たとえば、ブロック &lt;code&gt;LinearOperatorBlockLowerTriangular&lt;/code&gt; &lt;code&gt;3 x 3&lt;/code&gt; LinearOperatorBlockLowerTriangularは、リスト &lt;code&gt;[[op_00], [op_10, op_11], [op_20, op_21, op_22]]&lt;/code&gt; で初期化されます。ここで、 &lt;code&gt;op_ij&lt;/code&gt; 、 &lt;code&gt;i &amp;lt; 3, j &amp;lt;= i&lt;/code&gt; は &lt;code&gt;LinearOperator&lt;/code&gt; インスタンスです。 。 &lt;code&gt;LinearOperatorBlockLowerTriangular&lt;/code&gt; の次のブロック単位行列として挙動 &lt;code&gt;0&lt;/code&gt; はゼロの適切なサイズの[バッチ]の行列を表します。</target>
        </trans-unit>
        <trans-unit id="fcebdd5340244173df800627bd1fd4d61eafaaf9" translate="yes" xml:space="preserve">
          <source>For example, a long-running operation (e.g. &lt;code&gt;tf.QueueBase.enqueue&lt;/code&gt; may be cancelled by running another operation (e.g. &lt;code&gt;tf.QueueBase.close&lt;/code&gt;, or by &lt;code&gt;tf.Session.close&lt;/code&gt;. A step that is running such a long-running operation will fail by raising &lt;code&gt;CancelledError&lt;/code&gt;.</source>
          <target state="translated">例えば、長時間実行される操作（例えば &lt;code&gt;tf.QueueBase.enqueue&lt;/code&gt; は、例えば（他の操作を実行することによって相殺することができる &lt;code&gt;tf.QueueBase.close&lt;/code&gt; 、またはによって &lt;code&gt;tf.Session.close&lt;/code&gt; 。例えばA長時間実行操作の意志を実行しているA工程 &lt;code&gt;CancelledError&lt;/code&gt; を送出して失敗します。</target>
        </trans-unit>
        <trans-unit id="d8e89184316bed55c53786f62c2b2ad4e3ff94d1" translate="yes" xml:space="preserve">
          <source>For example, a variable created under a &lt;code&gt;MirroredStrategy&lt;/code&gt; is a &lt;code&gt;MirroredVariable&lt;/code&gt;. If no devices are specified in the constructor argument of the strategy then it will use all the available GPUs. If no GPUs are found, it will use the available CPUs. Note that TensorFlow treats all CPUs on a machine as a single device, and uses threads internally for parallelism.</source>
          <target state="translated">たとえば、 &lt;code&gt;MirroredStrategy&lt;/code&gt; で作成された変数は &lt;code&gt;MirroredVariable&lt;/code&gt; です。ストラテジーのコンストラクター引数でデバイスが指定されていない場合、使用可能なすべてのGPUが使用されます。GPUが見つからない場合は、使用可能なCPUを使用します。TensorFlowは、マシン上のすべてのCPUを単一のデバイスとして扱い、並列処理のために内部でスレッドを使用することに注意してください。</target>
        </trans-unit>
        <trans-unit id="ef45f8f5ea52443b495bf1c4d1f242d4e99b9f14" translate="yes" xml:space="preserve">
          <source>For example, assuming that operations of type &lt;code&gt;&quot;Sub&quot;&lt;/code&gt; take two inputs &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, and return a single output &lt;code&gt;x - y&lt;/code&gt;, the following gradient function would be registered:</source>
          <target state="translated">たとえば、タイプ &lt;code&gt;&quot;Sub&quot;&lt;/code&gt; 演算が2つの入力 &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; を取り、単一の出力 &lt;code&gt;x - y&lt;/code&gt; を返すと仮定すると、次の勾配関数が登録されます。</target>
        </trans-unit>
        <trans-unit id="180f2ef709a54a11af8fe0feb0049ea09edaa93b" translate="yes" xml:space="preserve">
          <source>For example, consider the case where a new operation &lt;code&gt;MyNewAwesomeAdd&lt;/code&gt; is created with the intent of replacing the implementation of an existing Python wrapper - &lt;a href=&quot;../math/add&quot;&gt;&lt;code&gt;tf.add&lt;/code&gt;&lt;/a&gt;. The Python wrapper implementation should change from something like:</source>
          <target state="translated">たとえば、既存のPythonラッパー&lt;a href=&quot;../math/add&quot;&gt; &lt;code&gt;tf.add&lt;/code&gt; &lt;/a&gt;実装を置き換える目的で新しい操作 &lt;code&gt;MyNewAwesomeAdd&lt;/code&gt; が作成された場合を考えます。Pythonラッパーの実装は次のようなものから変更する必要があります。</target>
        </trans-unit>
        <trans-unit id="5485292a2195c6dfb3a48825eb198beefa168928" translate="yes" xml:space="preserve">
          <source>For example, consider the following feature vectors:</source>
          <target state="translated">例えば、次のような特徴ベクトルを考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="4ebe2904fc13a0afda0a0801fae06da9da930550" translate="yes" xml:space="preserve">
          <source>For example, consider the following function that commonly occurs in the computation of cross entropy and log likelihoods:</source>
          <target state="translated">例えば、クロス・エントロピーや対数尤度の計算でよく発生する以下の関数を考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="36b3d8f67113dade2a57685778931fd4aac40c92" translate="yes" xml:space="preserve">
          <source>For example, consider the function &lt;code&gt;y = x * x&lt;/code&gt;. The gradient at &lt;code&gt;x = 3.0&lt;/code&gt; can be computed as:</source>
          <target state="translated">たとえば、関数 &lt;code&gt;y = x * x&lt;/code&gt; 考えます。 &lt;code&gt;x = 3.0&lt;/code&gt; での勾配は、次のように計算できます。</target>
        </trans-unit>
        <trans-unit id="a0f0b737266cb9508dec913b7e40d2a11a33a917" translate="yes" xml:space="preserve">
          <source>For example, for a cluster set up for parameter server training, the following device filters might be specified:</source>
          <target state="translated">例えば、パラメータサーバのトレーニング用に設定されたクラスタでは、以下のデバイスフィルタが指定されているかもしれません。</target>
        </trans-unit>
        <trans-unit id="623e0c89de281259a4a76c11ecbd4f9ce138793a" translate="yes" xml:space="preserve">
          <source>For example, for a length-&lt;code&gt;k&lt;/code&gt;, vector-valued distribution, it is calculated as,</source>
          <target state="translated">たとえば、長さ &lt;code&gt;k&lt;/code&gt; のベクトル値分布の場合、次のように計算されます。</target>
        </trans-unit>
        <trans-unit id="f6368f536fbdc467faaf091386024de7a14c3cdc" translate="yes" xml:space="preserve">
          <source>For example, for a vocabulary containing 3 labels &lt;code&gt;[a, b, c]&lt;/code&gt;, &lt;code&gt;num_classes = 4&lt;/code&gt; and the labels indexing is &lt;code&gt;{a: 0, b: 1, c: 2, blank: 3}&lt;/code&gt;.</source>
          <target state="translated">例えば、3つの標識を含む語彙のために &lt;code&gt;[a, b, c]&lt;/code&gt; 、 &lt;code&gt;num_classes = 4&lt;/code&gt; とラベルの索引付けは &lt;code&gt;{a: 0, b: 1, c: 2, blank: 3}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c3115c15a9fb018968e5c6d980aaf6a85e52aa08" translate="yes" xml:space="preserve">
          <source>For example, for stride=(1,1) and padding=&quot;same&quot;:</source>
          <target state="translated">例えば、stride=(1,1)とpadding=&quot;同じ &quot;の場合。</target>
        </trans-unit>
        <trans-unit id="00cb23acbd39732b0289b04ffd814e294ed82c1d" translate="yes" xml:space="preserve">
          <source>For example, for stride=(1,1) and padding=&quot;valid&quot;:</source>
          <target state="translated">例えば、stride=(1,1)とpadding=&quot;valid &quot;の場合。</target>
        </trans-unit>
        <trans-unit id="f975567f0c60114a08dd76e03f219202f64cefff" translate="yes" xml:space="preserve">
          <source>For example, for stride=(2,2) and padding=&quot;valid&quot;:</source>
          <target state="translated">例えば、stride=(2,2)とpadding=&quot;valid &quot;の場合。</target>
        </trans-unit>
        <trans-unit id="7255e66a73d48695729736c11b4e69788bd57bb6" translate="yes" xml:space="preserve">
          <source>For example, for strides=1 and padding=&quot;same&quot;:</source>
          <target state="translated">例えば、strides=1、padding=&quot;同じ &quot;の場合。</target>
        </trans-unit>
        <trans-unit id="085e925d53c95cbefd7abeb57a30c1ff2277f50b" translate="yes" xml:space="preserve">
          <source>For example, for strides=1 and padding=&quot;valid&quot;:</source>
          <target state="translated">例えば、strides=1、padding=&quot;valid &quot;の場合。</target>
        </trans-unit>
        <trans-unit id="eb7d3255ed5f8e3928e920d565d5aea04bdcc956" translate="yes" xml:space="preserve">
          <source>For example, for strides=2 and padding=&quot;valid&quot;:</source>
          <target state="translated">例えば、strides=2、padding=&quot;valid &quot;の場合。</target>
        </trans-unit>
        <trans-unit id="9f5c38b8eb7488176cf43cc68fe176bcdaf5ad82" translate="yes" xml:space="preserve">
          <source>For example, for system with 8 logical devices, if &lt;code&gt;tensor&lt;/code&gt; is an image tensor with shape (batch_size, width, height, channel) and &lt;code&gt;partition_dimensions&lt;/code&gt; is [1, 2, 4, 1], then &lt;code&gt;tensor&lt;/code&gt; will be split 2 in width dimension and 4 way in height dimension and the split tensor values will be fed into 8 logical devices.</source>
          <target state="translated">たとえば、8つの論理デバイスを持つシステムの場合、 &lt;code&gt;tensor&lt;/code&gt; が形状（batch_size、width、height、channel）の画像テンソルであり、 &lt;code&gt;partition_dimensions&lt;/code&gt; が[ 1、2、4、1 ]の場合、 &lt;code&gt;tensor&lt;/code&gt; は幅の次元で2に分割されます。高さ次元の4ウェイと分割テンソル値は、8つの論理デバイスに供給されます。</target>
        </trans-unit>
        <trans-unit id="04995a90d2cbb2770c2b48eb75173d51eb847e39" translate="yes" xml:space="preserve">
          <source>For example, given a tensor of shape &lt;code&gt;(A, B, C, D)&lt;/code&gt;;</source>
          <target state="translated">たとえば、形状のテンソル &lt;code&gt;(A, B, C, D)&lt;/code&gt; 与えられます。</target>
        </trans-unit>
        <trans-unit id="e1b94d04ee53deb5a3f4899863cd8936a9a93808" translate="yes" xml:space="preserve">
          <source>For example, given an input of shape &lt;code&gt;[1, 1, 1, 4]&lt;/code&gt;, data_format = &quot;NHWC&quot; and block_size = 2:</source>
          <target state="translated">たとえば、形状 &lt;code&gt;[1, 1, 1, 4]&lt;/code&gt; 1、1、1、4 ]の入力が与えられた場合、data_format = &quot;NHWC&quot;およびblock_size = 2：</target>
        </trans-unit>
        <trans-unit id="73901e6b47ecbf656dbf0c63bc23506a1582b4f9" translate="yes" xml:space="preserve">
          <source>For example, given an input of shape &lt;code&gt;[1, 2, 2, 1]&lt;/code&gt;, data_format = &quot;NHWC&quot; and block_size = 2:</source>
          <target state="translated">たとえば、形状が &lt;code&gt;[1, 2, 2, 1]&lt;/code&gt; 1、2、2、1 ]の場合、data_format = &quot;NHWC&quot;およびblock_size = 2です。</target>
        </trans-unit>
        <trans-unit id="9e72f264d4068a89cde912a017b35e1218d4d07d" translate="yes" xml:space="preserve">
          <source>For example, given the following datasets:</source>
          <target state="translated">例えば、以下のようなデータセットがあるとします。</target>
        </trans-unit>
        <trans-unit id="36e6a7cc02c6b3197df385da6bc03f401a87598e" translate="yes" xml:space="preserve">
          <source>For example, given the following input:</source>
          <target state="translated">例えば、次のような入力があるとします。</target>
        </trans-unit>
        <trans-unit id="72fef8ba715160aa4ba1e8d1a7eac5b78987feac" translate="yes" xml:space="preserve">
          <source>For example, given this input:</source>
          <target state="translated">例えば、この入力が与えられたとします。</target>
        </trans-unit>
        <trans-unit id="ccbd1974587f66c012f3ce45843b4a9f5f326074" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;axis = 1&lt;/code&gt; and the inputs are</source>
          <target state="translated">たとえば、 &lt;code&gt;axis = 1&lt;/code&gt; で、入力が</target>
        </trans-unit>
        <trans-unit id="6b23a8e10aeea8f89169181db0354df162a5d3fd" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;concat_dim = 1&lt;/code&gt; and the inputs are</source>
          <target state="translated">たとえば、 &lt;code&gt;concat_dim = 1&lt;/code&gt; で、入力が</target>
        </trans-unit>
        <trans-unit id="12db4e70afdf1bc3643b5acdc6bad82dd0e10f2e" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;elems&lt;/code&gt; is &lt;code&gt;(t1, [t2, t3])&lt;/code&gt; and &lt;code&gt;initializer&lt;/code&gt; is &lt;code&gt;[i1, i2]&lt;/code&gt; then an appropriate signature for &lt;code&gt;fn&lt;/code&gt; in &lt;code&gt;python2&lt;/code&gt; is: &lt;code&gt;fn = lambda (acc_p1, acc_p2), (t1, [t2, t3]):&lt;/code&gt; and &lt;code&gt;fn&lt;/code&gt; must return a list, &lt;code&gt;[acc_n1, acc_n2]&lt;/code&gt;. An alternative correct signature for &lt;code&gt;fn&lt;/code&gt;, and the one that works in &lt;code&gt;python3&lt;/code&gt;, is: &lt;code&gt;fn = lambda a, t:&lt;/code&gt;, where &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;t&lt;/code&gt; correspond to the input tuples.</source>
          <target state="translated">たとえば、 &lt;code&gt;elems&lt;/code&gt; がある &lt;code&gt;(t1, [t2, t3])&lt;/code&gt; と &lt;code&gt;initializer&lt;/code&gt; され &lt;code&gt;[i1, i2]&lt;/code&gt; 次に適し署名 &lt;code&gt;fn&lt;/code&gt; における &lt;code&gt;python2&lt;/code&gt; は：れている &lt;code&gt;fn = lambda (acc_p1, acc_p2), (t1, [t2, t3]):&lt;/code&gt; そして &lt;code&gt;fn&lt;/code&gt; はリスト &lt;code&gt;[acc_n1, acc_n2]&lt;/code&gt; 返す必要があります。 &lt;code&gt;fn&lt;/code&gt; の代替の正しい署名、および &lt;code&gt;python3&lt;/code&gt; で機能する署名は、 &lt;code&gt;fn = lambda a, t:&lt;/code&gt; 。ここで &lt;code&gt;a&lt;/code&gt; と &lt;code&gt;t&lt;/code&gt; は入力タプルに対応します。</target>
        </trans-unit>
        <trans-unit id="cc61fc022fbf77e9b491b661c7505399625f7c88" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;labels&lt;/code&gt;=[a, b, c] and &lt;code&gt;predictions&lt;/code&gt;=[x, y, z], there are three pairs of differences are summed to compute the loss: loss = [ ((a-b) - (x-y)).^2 + ((a-c) - (x-z)).^2 + ((b-c) - (y-z)).^2 ] / 3</source>
          <target state="translated">たとえば、 &lt;code&gt;labels&lt;/code&gt; = [a、b、c]および &lt;code&gt;predictions&lt;/code&gt; = [x、y、z]の場合、損失を計算するために3つのペアの差が合計されます。loss= [（（ab）-（xy））。 ^ 2 +（（ac）-（xz））。^ 2 +（（bc）-（yz））。^ 2] / 3</target>
        </trans-unit>
        <trans-unit id="2baa9bbc1cf6bd691324f3eac32cd3df8cf8cd10" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;sp_input.dense_shape = [2, 3, 4]&lt;/code&gt; with non-empty values:</source>
          <target state="translated">たとえば、空でない値を持つ &lt;code&gt;sp_input.dense_shape = [2, 3, 4]&lt;/code&gt; 場合：</target>
        </trans-unit>
        <trans-unit id="82ef36e97447aa968dcbc0b94c3a5abad62654fd" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;sp_input&lt;/code&gt; has shape &lt;code&gt;[2, 3, 6]&lt;/code&gt; and &lt;code&gt;indices&lt;/code&gt; / &lt;code&gt;values&lt;/code&gt;:</source>
          <target state="translated">たとえば、 &lt;code&gt;sp_input&lt;/code&gt; の形状が &lt;code&gt;[2, 3, 6]&lt;/code&gt; 2、3、6 ]と &lt;code&gt;indices&lt;/code&gt; / &lt;code&gt;values&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="5fbb93d3efe7c28e2cd5aae402bb6c00323fbb4c" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;sp_input&lt;/code&gt; has shape &lt;code&gt;[3, 5]&lt;/code&gt; and non-empty string values:</source>
          <target state="translated">たとえば、 &lt;code&gt;sp_input&lt;/code&gt; の形状が &lt;code&gt;[3, 5]&lt;/code&gt; で空でない文字列値の場合：</target>
        </trans-unit>
        <trans-unit id="48e9053195f85a37348bd311aa5312c62f0d464f" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;sp_input&lt;/code&gt; has shape &lt;code&gt;[4, 5]&lt;/code&gt; and 4 non-empty string values:</source>
          <target state="translated">たとえば、 &lt;code&gt;sp_input&lt;/code&gt; の形状が &lt;code&gt;[4, 5]&lt;/code&gt; 、空でない4つの文字列値がある場合：</target>
        </trans-unit>
        <trans-unit id="c8378e24e7a2aa8a60e4c9f1dd742f0e0c198be9" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;sp_input&lt;/code&gt; has shape &lt;code&gt;[4, 5]&lt;/code&gt; and &lt;code&gt;indices&lt;/code&gt; / &lt;code&gt;values&lt;/code&gt;:</source>
          <target state="translated">たとえば、 &lt;code&gt;sp_input&lt;/code&gt; の形状が &lt;code&gt;[4, 5]&lt;/code&gt; 、 &lt;code&gt;indices&lt;/code&gt; / &lt;code&gt;values&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="079ce847d3f4ddf3969ea935f3da66bee264e67a" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;values&lt;/code&gt; is [1, 3, 5, 7] and reduction=SUM_OVER_BATCH_SIZE, then the value of &lt;code&gt;result()&lt;/code&gt; is 4. If the &lt;code&gt;sample_weight&lt;/code&gt; is specified as [1, 1, 0, 0] then value of &lt;code&gt;result()&lt;/code&gt; would be 2.</source>
          <target state="translated">たとえば、 &lt;code&gt;values&lt;/code&gt; が[1、3、5、7]で、reduction = SUM_OVER_BATCH_SIZEの場合、 &lt;code&gt;result()&lt;/code&gt; の値は4です &lt;code&gt;sample_weight&lt;/code&gt; が[ 1、1、0、0]と指定されている場合、 &lt;code&gt;result()&lt;/code&gt; は2になります。</target>
        </trans-unit>
        <trans-unit id="74c85d63fadaf2c9b5598258a9c06918b60fbc1f" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;y_true&lt;/code&gt; is [-1., 1., 1.], and &lt;code&gt;y_pred&lt;/code&gt; is [0.6, -0.7, -0.5] the hinge metric value is 1.6.</source>
          <target state="translated">たとえば、 &lt;code&gt;y_true&lt;/code&gt; が[-1。、1.、1.]で、 &lt;code&gt;y_pred&lt;/code&gt; が[0.6、-0.7、-0.5]の場合、ヒンジメトリック値は1.6です。</target>
        </trans-unit>
        <trans-unit id="042aca995b0f38a90ddefbc3e2a8e393512784fe" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;y_true&lt;/code&gt; is [-1., 1., 1.], and &lt;code&gt;y_pred&lt;/code&gt; is [0.6, -0.7, -0.5] the squared hinge metric value is 2.6.</source>
          <target state="translated">たとえば、 &lt;code&gt;y_true&lt;/code&gt; が[-1。、1.、1.]で、 &lt;code&gt;y_pred&lt;/code&gt; が[0.6、-0.7、-0.5]の場合、2乗ヒンジメトリック値は2.6です。</target>
        </trans-unit>
        <trans-unit id="d39413a8be385331298ca5abd733969e733cbbd9" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;y_true&lt;/code&gt; is [0, 1, 0, 0] and &lt;code&gt;y_pred&lt;/code&gt; is [0, 0, 1, 1] then the false positives value is 2. If the weights were specified as [0, 0, 1, 0] then the false positives value would be 1.</source>
          <target state="translated">たとえば、 &lt;code&gt;y_true&lt;/code&gt; が[ 0、1、0、0 ]で、 &lt;code&gt;y_pred&lt;/code&gt; が[ 0、0、1、1 ]の場合、誤検知値は2です。重みが[ 0、0、1、0 ]として指定された場合その場合、誤検知の値は1になります。</target>
        </trans-unit>
        <trans-unit id="01fe7d4a63a14b4e23db71a05868b30fb525abd1" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;y_true&lt;/code&gt; is [0, 1, 0, 0] and &lt;code&gt;y_pred&lt;/code&gt; is [1, 1, 0, 0] then the true negatives value is 2. If the weights were specified as [0, 0, 1, 0] then the true negatives value would be 1.</source>
          <target state="translated">たとえば、 &lt;code&gt;y_true&lt;/code&gt; が[ 0、1、0、0 ]で、 &lt;code&gt;y_pred&lt;/code&gt; が[ 1、1、0、0 ]の場合、真のネガティブ値は2です。重みが[ 0、0、1、0 ]として指定された場合その場合、真のネガティブ値は1になります。</target>
        </trans-unit>
        <trans-unit id="3ef6e2ca3f9a644f49c6e0ccb7b4d3c7a6db0fc4" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;y_true&lt;/code&gt; is [0, 1, 1, 1] and &lt;code&gt;y_pred&lt;/code&gt; is [0, 1, 0, 0] then the false negatives value is 2. If the weights were specified as [0, 0, 1, 0] then the false negatives value would be 1.</source>
          <target state="translated">たとえば、 &lt;code&gt;y_true&lt;/code&gt; が[ 0、1、1、1 ]で、 &lt;code&gt;y_pred&lt;/code&gt; が[ 0、1、0、0 ]の場合、偽陰性の値は2です。重みが[ 0、0、1、0 ]として指定された場合その場合、偽陰性の値は1になります。</target>
        </trans-unit>
        <trans-unit id="3c8c09a433fcd3271d82f0d4f5f64556a950bbfa" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;y_true&lt;/code&gt; is [0, 1, 1, 1] and &lt;code&gt;y_pred&lt;/code&gt; is [1, 0, 1, 1] then the precision value is 2/(2+1) ie. 0.66. If the weights were specified as [0, 0, 1, 0] then the precision value would be 1.</source>
          <target state="translated">たとえば、 &lt;code&gt;y_true&lt;/code&gt; が[ 0、1、1、1 ]で、 &lt;code&gt;y_pred&lt;/code&gt; が[ 1、0、1、1 ]の場合、精度値は2 /（2 + 1）です。0.66。重みが[0、0、1、0]として指定された場合、精度値は1になります。</target>
        </trans-unit>
        <trans-unit id="fd7f6e92310398a605f77c3bad5f5cad2b0e6794" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;y_true&lt;/code&gt; is [0, 1, 1, 1] and &lt;code&gt;y_pred&lt;/code&gt; is [1, 0, 1, 1] then the recall value is 2/(2+1) ie. 0.66. If the weights were specified as [0, 0, 1, 0] then the recall value would be 1.</source>
          <target state="translated">たとえば、 &lt;code&gt;y_true&lt;/code&gt; が[ 0、1、1、1 ]で、 &lt;code&gt;y_pred&lt;/code&gt; が[ 1、0、1、1 ]の場合、再現値は2 /（2 + 1）です。0.66。重みが[0、0、1、0]として指定された場合、再現率の値は1になります。</target>
        </trans-unit>
        <trans-unit id="878e23bb2323f6b8fb30fbec08a976993f265dc2" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;y_true&lt;/code&gt; is [0, 1, 1, 1] and &lt;code&gt;y_pred&lt;/code&gt; is [1, 0, 1, 1] then the true positives value is 2. If the weights were specified as [0, 0, 1, 0] then the true positives value would be 1.</source>
          <target state="translated">たとえば、 &lt;code&gt;y_true&lt;/code&gt; が[ 0、1、1、1 ]で、 &lt;code&gt;y_pred&lt;/code&gt; が[ 1、0、1、1 ]の場合、真陽性の値は2です。重みが[ 0、0、1、0 ]として指定された場合その場合、真の陽性値は1になります。</target>
        </trans-unit>
        <trans-unit id="32b3cccbb70066b6b335a50381cd94d294b3c189" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;y_true&lt;/code&gt; is [0, 1, 1], and &lt;code&gt;y_pred&lt;/code&gt; is [1, 0, 1], the cosine similarity is 0.5.</source>
          <target state="translated">たとえば、 &lt;code&gt;y_true&lt;/code&gt; が[ 0、1、1 ]で、 &lt;code&gt;y_pred&lt;/code&gt; が[ 1、0、1 ]の場合、コサイン類似度は0.5です。</target>
        </trans-unit>
        <trans-unit id="0c5ba23e60dac33d6e6ff20e271aa3704cc01f45" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;y_true&lt;/code&gt; is [0., 0., 1., 1.], and &lt;code&gt;y_pred&lt;/code&gt; is [1., 1., 1., 0.] the mean absolute error is 3/4 (0.75).</source>
          <target state="translated">たとえば、 &lt;code&gt;y_true&lt;/code&gt; が[0.、0.、1.、1.]で、 &lt;code&gt;y_pred&lt;/code&gt; が[1.、1.、1.、0.]の場合、平均絶対誤差は3/4（0.75）です。</target>
        </trans-unit>
        <trans-unit id="10a6bddbd7d48d043bb0ce687f4965fd964d600b" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;y_true&lt;/code&gt; is [0., 0., 1., 1.], and &lt;code&gt;y_pred&lt;/code&gt; is [1., 1., 1., 0.] the mean absolute percentage error is 5e+08.</source>
          <target state="translated">たとえば、 &lt;code&gt;y_true&lt;/code&gt; が[0.、0.、1.、1.]で、 &lt;code&gt;y_pred&lt;/code&gt; が[1.、1.、1.、0.]の場合、平均絶対誤差率は5e + 08です。</target>
        </trans-unit>
        <trans-unit id="1db7dfad0c8212945bcb0be81f790e3411e18049" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;y_true&lt;/code&gt; is [0., 0., 1., 1.], and &lt;code&gt;y_pred&lt;/code&gt; is [1., 1., 1., 0.] the mean squared error is 3/4 (0.75).</source>
          <target state="translated">たとえば、 &lt;code&gt;y_true&lt;/code&gt; が[0.、0.、1.、1.]で、 &lt;code&gt;y_pred&lt;/code&gt; が[1.、1.、1.、0.]の場合、平均二乗誤差は3/4（0.75）です。</target>
        </trans-unit>
        <trans-unit id="352820f40271575204f969d93b9125b9211bb111" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;y_true&lt;/code&gt; is [0., 0., 1., 1.], and &lt;code&gt;y_pred&lt;/code&gt; is [1., 1., 1., 0.] the mean squared logarithmic error is 0.36034.</source>
          <target state="translated">たとえば、 &lt;code&gt;y_true&lt;/code&gt; が[0.、0.、1.、1.]で、 &lt;code&gt;y_pred&lt;/code&gt; が[1.、1.、1.、0.]の場合、平均二乗対数誤差は0.36034です。</target>
        </trans-unit>
        <trans-unit id="92f9d133578d098af3f012a74c5de6af734aaac1" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;y_true&lt;/code&gt; is [0., 1., 1.], and &lt;code&gt;y_pred&lt;/code&gt; is [1., 0., 1.] the categorical hinge metric value is 1.0.</source>
          <target state="translated">たとえば、 &lt;code&gt;y_true&lt;/code&gt; が[0.、1.、1.]であり、 &lt;code&gt;y_pred&lt;/code&gt; が[1.、0.、1.]の場合、カテゴリーヒンジメトリック値は1.0です。</target>
        </trans-unit>
        <trans-unit id="332538af5696bac076f524f2b4f5a405f689fdfc" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;y_true&lt;/code&gt; is [1, 1, 0, 0] and &lt;code&gt;y_pred&lt;/code&gt; is [0.98, 1, 0, 0.6] then the binary accuracy is 3/4 or .75. If the weights were specified as [1, 0, 0, 1] then the binary accuracy would be 1/2 or .5.</source>
          <target state="translated">たとえば、 &lt;code&gt;y_true&lt;/code&gt; が[ 1、1、0、0 ]で、 &lt;code&gt;y_pred&lt;/code&gt; が[ 0.98、1、0、0.6 ]の場合、バイナリ精度は3/4または.75です。重みが[1、0、0、1]として指定された場合、バイナリ精度は1/2または.5になります。</target>
        </trans-unit>
        <trans-unit id="302da67695947e6cae183abb786ed1ed93793986" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;y_true&lt;/code&gt; is [1, 2, 3, 4] and &lt;code&gt;y_pred&lt;/code&gt; is [0, 2, 3, 4] then the accuracy is 3/4 or .75. If the weights were specified as [1, 1, 0, 0] then the accuracy would be 1/2 or .5.</source>
          <target state="translated">たとえば、 &lt;code&gt;y_true&lt;/code&gt; が[1、2、3、4]で、 &lt;code&gt;y_pred&lt;/code&gt; が[ 0、2、3、4 ]の場合、精度は3/4または.75です。重みが[1、1、0、0]として指定された場合、精度は1/2または.5になります。</target>
        </trans-unit>
        <trans-unit id="63dd4aed6e3f523156f4cc8450148bc3eb7f33cb" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;y_true&lt;/code&gt; is [[0, 0, 1], [0, 1, 0]] and &lt;code&gt;y_pred&lt;/code&gt; is [[0.1, 0.9, 0.8], [0.05, 0.95, 0]] then the categorical accuracy is 1/2 or .5. If the weights were specified as [0.7, 0.3] then the categorical accuracy would be .3. You can provide logits of classes as &lt;code&gt;y_pred&lt;/code&gt;, since argmax of logits and probabilities are same.</source>
          <target state="translated">たとえば、 &lt;code&gt;y_true&lt;/code&gt; が[[0、0、1]、[ &lt;code&gt;y_pred&lt;/code&gt; ]]で、y_predが[[ 0.1、0.9、0.8 ]、[ 0.05、0.95、0 ]]の場合、カテゴリカルな精度は1 / 2または.5。重みが[0.7、0.3]と指定された場合、カテゴリカルな精度は.3になります。あなたはクラスのlogitsを提供することができ &lt;code&gt;y_pred&lt;/code&gt; logitsと確率のARGMAXが同じであるため、。</target>
        </trans-unit>
        <trans-unit id="03b61c36d51ef6615cbd7e2f828167a558e16b95" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;y_true&lt;/code&gt; is [[2], [1]] and &lt;code&gt;y_pred&lt;/code&gt; is [[0.1, 0.9, 0.8], [0.05, 0.95, 0]] then the categorical accuracy is 1/2 or .5. If the weights were specified as [0.7, 0.3] then the categorical accuracy would be .3. You can provide logits of classes as &lt;code&gt;y_pred&lt;/code&gt;, since argmax of logits and probabilities are same.</source>
          <target state="translated">たとえば、 &lt;code&gt;y_true&lt;/code&gt; が[[2]、[1]]で、 &lt;code&gt;y_pred&lt;/code&gt; が[[ 0.1、0.9、0.8 ]、[ 0.05、0.95、0 ]]の場合、カテゴリカルな精度は1/2または.5です。重みが[0.7、0.3]と指定された場合、カテゴリカルな精度は.3になります。あなたはクラスのlogitsを提供することができ &lt;code&gt;y_pred&lt;/code&gt; logitsと確率のARGMAXが同じであるため、。</target>
        </trans-unit>
        <trans-unit id="8f13a7bb3ba4ef5812b22736a0c5aa5e4b5379d5" translate="yes" xml:space="preserve">
          <source>For example, if a Boolean flag was created whose long name was 'update' and whose short name was 'x', then this flag could be explicitly unset through either --noupdate or --nox.</source>
          <target state="translated">例えば、長い名前が 'update' で短い名前が 'x' であるブール値のフラグが作成された場合、このフラグは --noupdate または --nox のいずれかで明示的に設定を解除することができます。</target>
        </trans-unit>
        <trans-unit id="cc9b6d5bd1871e9c4763dd68bc17d436b61c0322" translate="yes" xml:space="preserve">
          <source>For example, if an image is 100 x 200 pixels (height x width) and the bounding box is &lt;code&gt;[0.1, 0.2, 0.5, 0.9]&lt;/code&gt;, the upper-left and bottom-right coordinates of the bounding box will be &lt;code&gt;(40, 10)&lt;/code&gt; to &lt;code&gt;(100, 50)&lt;/code&gt; (in (x,y) coordinates).</source>
          <target state="translated">たとえば、画像が100 x 200ピクセル（高さx幅）で、境界ボックスが &lt;code&gt;[0.1, 0.2, 0.5, 0.9]&lt;/code&gt; 場合、境界ボックスの左上と右下の座標は &lt;code&gt;(40, 10)&lt;/code&gt; 40、10 ）から &lt;code&gt;(100, 50)&lt;/code&gt; （（x、y）座標）。</target>
        </trans-unit>
        <trans-unit id="159c6f90d773fa258aa2ceb1607894f00e000d7c" translate="yes" xml:space="preserve">
          <source>For example, if an image is 100 x 200 pixels (height x width) and the bounding box is &lt;code&gt;[0.1, 0.2, 0.5, 0.9]&lt;/code&gt;, the upper-left and bottom-right coordinates of the bounding box will be &lt;code&gt;(40, 10)&lt;/code&gt; to &lt;code&gt;(180, 50)&lt;/code&gt; (in (x,y) coordinates).</source>
          <target state="translated">たとえば、画像が100 x 200ピクセル（高さx幅）で、境界ボックスが &lt;code&gt;[0.1, 0.2, 0.5, 0.9]&lt;/code&gt; 場合、境界ボックスの左上と右下の座標は &lt;code&gt;(40, 10)&lt;/code&gt; 40、10 ）から &lt;code&gt;(180, 50)&lt;/code&gt; （（x、y）座標）。</target>
        </trans-unit>
        <trans-unit id="07684173fdbd40bd293343faca9d012ab8c45162" translate="yes" xml:space="preserve">
          <source>For example, if an instance of &lt;code&gt;StaticVocabularyTable&lt;/code&gt; is initialized with a string-to-id initializer that maps:</source>
          <target state="translated">たとえば、 &lt;code&gt;StaticVocabularyTable&lt;/code&gt; のインスタンスが次のマップを行うstring-to-id初期化子で初期化された場合：</target>
        </trans-unit>
        <trans-unit id="eb86a4b81dfbe2a8d5b118b66c9ce83f3cdff0cb" translate="yes" xml:space="preserve">
          <source>For example, if each &lt;code&gt;indices[m]&lt;/code&gt; is scalar or vector, we have</source>
          <target state="translated">たとえば、各 &lt;code&gt;indices[m]&lt;/code&gt; がスカラーまたはベクトルの場合、次のようになります。</target>
        </trans-unit>
        <trans-unit id="14f0ac91df308245997c838649986de3acfa389b" translate="yes" xml:space="preserve">
          <source>For example, if elements of the dataset are shaped &lt;code&gt;[B, a0, a1, ...]&lt;/code&gt;, where &lt;code&gt;B&lt;/code&gt; may vary for each input element, then for each element in the dataset, the unbatched dataset will contain &lt;code&gt;B&lt;/code&gt; consecutive elements of shape &lt;code&gt;[a0, a1, ...]&lt;/code&gt;.</source>
          <target state="translated">たとえば、データセットの要素の形状が &lt;code&gt;[B, a0, a1, ...]&lt;/code&gt; 場合、 &lt;code&gt;B&lt;/code&gt; は入力要素ごとに異なる可能性があり、データセットの各要素では、バッチ処理されていないデータセットに形状の連続する &lt;code&gt;B&lt;/code&gt; 要素が含まれます &lt;code&gt;[a0, a1, ...]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b758388605970f47c42af062f7d7168a335bbc88" translate="yes" xml:space="preserve">
          <source>For example, if one expects a &lt;a href=&quot;../../../tf#float32&quot;&gt;&lt;code&gt;tf.float32&lt;/code&gt;&lt;/a&gt;&lt;code&gt;VarLenFeature&lt;/code&gt;&lt;code&gt;ft&lt;/code&gt; and three serialized &lt;code&gt;Example&lt;/code&gt;s are provided:</source>
          <target state="translated">たとえば、&lt;a href=&quot;../../../tf#float32&quot;&gt; &lt;code&gt;tf.float32&lt;/code&gt; &lt;/a&gt; &lt;code&gt;VarLenFeature&lt;/code&gt; &lt;code&gt;ft&lt;/code&gt; が必要であり、3つのシリアル化された &lt;code&gt;Example&lt;/code&gt; が提供されている場合：</target>
        </trans-unit>
        <trans-unit id="eb05669fcc3c2a0884538e3c5dcbdcad42ac9ef3" translate="yes" xml:space="preserve">
          <source>For example, if one expects a &lt;a href=&quot;../../tf#float32&quot;&gt;&lt;code&gt;tf.float32&lt;/code&gt;&lt;/a&gt;&lt;code&gt;VarLenFeature&lt;/code&gt;&lt;code&gt;ft&lt;/code&gt; and three serialized &lt;code&gt;Example&lt;/code&gt;s are provided:</source>
          <target state="translated">たとえば、&lt;a href=&quot;../../tf#float32&quot;&gt; &lt;code&gt;tf.float32&lt;/code&gt; &lt;/a&gt; &lt;code&gt;VarLenFeature&lt;/code&gt; &lt;code&gt;ft&lt;/code&gt; が必要であり、3つのシリアル化された &lt;code&gt;Example&lt;/code&gt; が提供されている場合：</target>
        </trans-unit>
        <trans-unit id="f8bdd2413e1c95149871ce390e2fbfac69482604" translate="yes" xml:space="preserve">
          <source>For example, if shape_x is [1, 2, 3] and shape_y is [5, 1, 3], the result is a Tensor whose value is [5, 2, 3].</source>
          <target state="translated">例えば、shape_xが[1,2,3]でshape_yが[5,1,3]の場合、結果は[5,2,3]の値を持つテンソルになります。</target>
        </trans-unit>
        <trans-unit id="8e1dfee76a0dd69d101ca2f4608dd28751a60789" translate="yes" xml:space="preserve">
          <source>For example, if shape_x is [1, 2, 3] and shape_y is [5, 1, 3], the result is a TensorShape whose value is [5, 2, 3].</source>
          <target state="translated">例えば、shape_xが[1,2,3]でshape_yが[5,1,3]の場合、結果は[5,2,3]の値を持つTensorShapeになります。</target>
        </trans-unit>
        <trans-unit id="baed7d2d04b5d92ba9788e9979fc3b16b8e8b4dc" translate="yes" xml:space="preserve">
          <source>For example, if the handles represent an input, which is a &lt;code&gt;[2, 3]&lt;/code&gt; matrix representing two original &lt;code&gt;SparseTensor&lt;/code&gt; objects:</source>
          <target state="translated">たとえば、ハンドルが入力を表す場合、これは2つの元の &lt;code&gt;SparseTensor&lt;/code&gt; オブジェクトを表す &lt;code&gt;[2, 3]&lt;/code&gt; 行列です。</target>
        </trans-unit>
        <trans-unit id="e2db8bec254cdfb9c2b8d35134ff51a3f64cd250" translate="yes" xml:space="preserve">
          <source>For example, if the input features are:</source>
          <target state="translated">例えば、入力された特徴量が</target>
        </trans-unit>
        <trans-unit id="0176458490bbd6de268b72418c42500856f34603" translate="yes" xml:space="preserve">
          <source>For example, if the input is</source>
          <target state="translated">例えば、入力が</target>
        </trans-unit>
        <trans-unit id="6f37e7a6ce06d95b7008768ab5281188eb588a5d" translate="yes" xml:space="preserve">
          <source>For example, if the inputs are</source>
          <target state="translated">例えば、入力が</target>
        </trans-unit>
        <trans-unit id="4a55df6baad5525fc85f361979567c6db417291a" translate="yes" xml:space="preserve">
          <source>For example, if the inputs are boundaries = [0, 10, 100] input = [[-5, 10000] [150, 10] [5, 100]]</source>
          <target state="translated">例えば、入力が境界=[0,10,100]の場合、入力=[-5,10000][150,10][5,100]となります。</target>
        </trans-unit>
        <trans-unit id="2211633f9a2518e5f826b94adb19d9161763632d" translate="yes" xml:space="preserve">
          <source>For example, if the serialized input is a &lt;code&gt;[2 x 3]&lt;/code&gt; matrix representing two original &lt;code&gt;SparseTensor&lt;/code&gt; objects:</source>
          <target state="translated">たとえば、シリアル化された入力が2つの元の &lt;code&gt;SparseTensor&lt;/code&gt; オブジェクトを表す &lt;code&gt;[2 x 3]&lt;/code&gt; 行列である場合：</target>
        </trans-unit>
        <trans-unit id="ec19dc8fbf4a531cb12fa3311a36ebe61ce15eb0" translate="yes" xml:space="preserve">
          <source>For example, if the serialized input is a &lt;code&gt;[2, 3]&lt;/code&gt; matrix representing two original &lt;code&gt;SparseTensor&lt;/code&gt; objects:</source>
          <target state="translated">たとえば、シリアル化された入力が2つの元の &lt;code&gt;SparseTensor&lt;/code&gt; オブジェクトを表す &lt;code&gt;[2, 3]&lt;/code&gt; 行列である場合：</target>
        </trans-unit>
        <trans-unit id="a70f738ece73b26c4269166b69c29af52453cd5b" translate="yes" xml:space="preserve">
          <source>For example, if values is [1, 3, 5, 7] then the mean is 4. If the weights were specified as [1, 1, 0, 0] then the mean would be 2.</source>
          <target state="translated">例えば、値が[1,3,5,7]の場合、平均は4となり、重みが[1,1,1,0,0]の場合、平均は2となります。</target>
        </trans-unit>
        <trans-unit id="e8911ee7c4d9c2878cc8d50831034ed815f5e1c3" translate="yes" xml:space="preserve">
          <source>For example, if values is [1, 3, 5, 7] then the sum is 16. If the weights were specified as [1, 1, 0, 0] then the sum would be 4.</source>
          <target state="translated">例えば、値が[1,3,5,7]の場合、和は16となります。重みを[1,1,0,0]と指定した場合、合計は4となります。</target>
        </trans-unit>
        <trans-unit id="9e1df8c42c0b9b864ddf4232778a736fd6146a8f" translate="yes" xml:space="preserve">
          <source>For example, if you had two iterators that marked the current position in a training dataset and a test dataset, you could choose which to use in each step as follows:</source>
          <target state="translated">例えば、訓練データセットとテストデータセットで現在位置をマークするイテレータが2つある場合、以下のように各ステップでどちらを使うかを選択することができます。</target>
        </trans-unit>
        <trans-unit id="059fadcaec40fcaea26bdf57bd124c4c9b8acb79" translate="yes" xml:space="preserve">
          <source>For example, in a distributed-training setting, suppose we have a master seed and a replica ID. We want to fold the replica ID into the master seed to form a &quot;replica seed&quot; to be used by that replica later on, so that different replicas will generate different random numbers but the reproducibility of the whole system can still be controlled by the master seed:</source>
          <target state="translated">例えば、分散訓練の設定で、マスターシードとレプリカIDがあるとします。レプリカIDをマスターシードに折り込んで「レプリカシード」を形成し、後でそのレプリカが使用するようにしたいと思います。</target>
        </trans-unit>
        <trans-unit id="f80318ab5209d9919d27fe805ac19a9c0931d496" translate="yes" xml:space="preserve">
          <source>For example, in the following code block:</source>
          <target state="translated">例えば、以下のコードブロックでは</target>
        </trans-unit>
        <trans-unit id="aa532f960a2ce1a036579c69315203f6c2651d89" translate="yes" xml:space="preserve">
          <source>For example, it can be used to implement the dynamic decoder of a seq2seq model.</source>
          <target state="translated">例えば、seq2seqモデルの動的デコーダを実装するために使用することができます。</target>
        </trans-unit>
        <trans-unit id="3e600c85cc6a4cecba36365c9dcfce62fdbeb235" translate="yes" xml:space="preserve">
          <source>For example, letting &lt;code&gt;{...}&lt;/code&gt; to represent a Dataset:</source>
          <target state="translated">たとえば、 &lt;code&gt;{...}&lt;/code&gt; でデータセットを表すようにします。</target>
        </trans-unit>
        <trans-unit id="bf659dc49fbc636a057c5bc8faf1b5475f6913de" translate="yes" xml:space="preserve">
          <source>For example, of loading images of a known size:</source>
          <target state="translated">例えば、既知のサイズの画像を読み込むことの</target>
        </trans-unit>
        <trans-unit id="e782088c1d829573c59eb47813c6583133dd6bf0" translate="yes" xml:space="preserve">
          <source>For example, running a &lt;code&gt;tf.QueueBase.enqueue&lt;/code&gt; operation may raise &lt;code&gt;AbortedError&lt;/code&gt; if a &lt;code&gt;tf.QueueBase.close&lt;/code&gt; operation previously ran.</source>
          <target state="translated">例えば、実行中の &lt;code&gt;tf.QueueBase.enqueue&lt;/code&gt; の操作は上げることができる &lt;code&gt;AbortedError&lt;/code&gt; を場合 &lt;code&gt;tf.QueueBase.close&lt;/code&gt; の操作は以前に走りました。</target>
        </trans-unit>
        <trans-unit id="6fb766e4eb77cad3c4ed3c20934b9966a924fe5a" translate="yes" xml:space="preserve">
          <source>For example, running an operation that saves a file (e.g. &lt;code&gt;tf.train.Saver.save&lt;/code&gt;) could potentially raise this exception if an explicit filename for an existing file was passed.</source>
          <target state="translated">たとえば、ファイルを保存する操作（例： &lt;code&gt;tf.train.Saver.save&lt;/code&gt; ）を実行すると、既存のファイルの明示的なファイル名が渡された場合に、この例外が発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="18f700fd2ce897b85fe0dede4441f3a1eacfcf00" translate="yes" xml:space="preserve">
          <source>For example, running the &lt;code&gt;tf.WholeFileReader.read&lt;/code&gt; operation could raise &lt;code&gt;NotFoundError&lt;/code&gt; if it receives the name of a file that does not exist.</source>
          <target state="translated">たとえば、 &lt;code&gt;tf.WholeFileReader.read&lt;/code&gt; オペレーションを実行すると、存在しないファイルの名前を受け取った場合に &lt;code&gt;NotFoundError&lt;/code&gt; が発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="cfa313373d48902517bbb0ec4668f45e63a5050e" translate="yes" xml:space="preserve">
          <source>For example, running the &lt;code&gt;tf.WholeFileReader.read&lt;/code&gt; operation could raise &lt;code&gt;PermissionDeniedError&lt;/code&gt; if it receives the name of a file for which the user does not have the read file permission.</source>
          <target state="translated">たとえば、 &lt;code&gt;tf.WholeFileReader.read&lt;/code&gt; 操作を実行すると、ユーザーがファイルの読み取り権限を持っていないファイルの名前を受け取った場合、 &lt;code&gt;PermissionDeniedError&lt;/code&gt; が発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="3f9fc30c26c26b9c0cc0d112a519a99605e0e840" translate="yes" xml:space="preserve">
          <source>For example, running the same function in two separate critical sections will not ensure serial execution:</source>
          <target state="translated">例えば、同じ関数を2つの別々のクリティカルセクションで実行しても、シリアル実行は保証されません。</target>
        </trans-unit>
        <trans-unit id="bef67e884ee584f664d6ae2ff6b50fa0e2467597" translate="yes" xml:space="preserve">
          <source>For example, say we want to add 4 scattered elements to a rank-1 tensor to 8 elements. In Python, that addition would look like this:</source>
          <target state="translated">例えば、ランク1のテンソルに4つの散らばった要素を8つの要素に加えたいとします。Pythonでは、この加算は次のようになります。</target>
        </trans-unit>
        <trans-unit id="1465860225753881464cf1173eca6c9061ef5e4f" translate="yes" xml:space="preserve">
          <source>For example, say we want to add 4 scattered elements to a rank-1 tensor to 8 elements. In Python, that update would look like this:</source>
          <target state="translated">例えば、ランク1のテンソルに4つの散らばった要素を8つの要素に追加したいとします。Pythonでは、この更新は次のようになります。</target>
        </trans-unit>
        <trans-unit id="27f08ff4e75bc71a4d85d762bdd869d0c386d3d7" translate="yes" xml:space="preserve">
          <source>For example, say we want to subtract 4 scattered elements from a rank-1 tensor with 8 elements. In Python, that subtraction would look like this:</source>
          <target state="translated">例えば、8つの要素を持つランク1のテンソルから4つの散在要素を減算したいとします。Pythonでは、この減算は次のようになります。</target>
        </trans-unit>
        <trans-unit id="debc3020545312e69c35338b60b8ad1a5d0f1fc6" translate="yes" xml:space="preserve">
          <source>For example, say we want to subtract 4 scattered elements from a rank-1 tensor with 8 elements. In Python, that update would look like this:</source>
          <target state="translated">例えば、8つの要素を持つランク1のテンソルから4つの散在要素を引きたいとします。Pythonでは、この更新は次のようになります。</target>
        </trans-unit>
        <trans-unit id="56ffaf4007daaf44f9fa50fd0b3fcda03d228d5e" translate="yes" xml:space="preserve">
          <source>For example, say we want to update 4 scattered elements to a rank-1 tensor to 8 elements. In Python, that update would look like this:</source>
          <target state="translated">例えば、4つの散らばった要素をランク1のテンソルに8つの要素に更新したいとします。Pythonでは、この更新は次のようになります。</target>
        </trans-unit>
        <trans-unit id="9818c958e44ded80c1b979231b05b2b1e699a832" translate="yes" xml:space="preserve">
          <source>For example, say you have a class A that compares only on its attribute x. Comparators other than &lt;strong&gt;lt&lt;/strong&gt; are omitted for brevity.</source>
          <target state="translated">たとえば、属性Aのみを比較するクラスAがあるとします。&lt;strong&gt;lt&lt;/strong&gt;以外のコンパレータは簡潔にするために省略されています。</target>
        </trans-unit>
        <trans-unit id="0b868a0b995363e52f99179ab5b2eb1da4495ee3" translate="yes" xml:space="preserve">
          <source>For example, suppose &lt;code&gt;sp_input&lt;/code&gt; has shape &lt;code&gt;[5, 6]&lt;/code&gt; and non-empty values:</source>
          <target state="translated">たとえば、 &lt;code&gt;sp_input&lt;/code&gt; の形状が &lt;code&gt;[5, 6]&lt;/code&gt; で空でない値であるとします。</target>
        </trans-unit>
        <trans-unit id="4b8890d00c239dfe3d4938b6c67d2e0e8fe86301" translate="yes" xml:space="preserve">
          <source>For example, suppose that &lt;code&gt;data&lt;/code&gt; has data type &lt;a href=&quot;../tf#int32&quot;&gt;&lt;code&gt;tf.int32&lt;/code&gt;&lt;/a&gt; and shape (2, 3, 4), and that the fingerprint method is &lt;code&gt;farmhash64&lt;/code&gt;. In this case, the output shape is (2, 8), where 2 is the batch dimension size of &lt;code&gt;data&lt;/code&gt;, and 8 is the size of each fingerprint value in bytes. &lt;code&gt;output[0, :]&lt;/code&gt; is generated from 12 integers in &lt;code&gt;data[0, :, :]&lt;/code&gt; and similarly &lt;code&gt;output[1, :]&lt;/code&gt; is generated from other 12 integers in &lt;code&gt;data[1, :, :]&lt;/code&gt;.</source>
          <target state="translated">例えば、と仮定 &lt;code&gt;data&lt;/code&gt; データ型有し&lt;a href=&quot;../tf#int32&quot;&gt; &lt;code&gt;tf.int32&lt;/code&gt; &lt;/a&gt;及び形状（2、3、4）、そして指紋法であること &lt;code&gt;farmhash64&lt;/code&gt; 。この場合、出力形状は（2、8）です。ここで、2は &lt;code&gt;data&lt;/code&gt; のバッチディメンションサイズ、8は各フィンガープリント値のバイト単位のサイズです。 &lt;code&gt;output[0, :]&lt;/code&gt; 、：]は &lt;code&gt;data[0, :, :]&lt;/code&gt; の12の整数から生成され &lt;code&gt;output[1, :]&lt;/code&gt; 同様にoutput [1、：]は &lt;code&gt;data[1, :, :]&lt;/code&gt; 他の12の整数から生成されます。</target>
        </trans-unit>
        <trans-unit id="495460b2d49d23df61667d5a8e90f92bf6025daa" translate="yes" xml:space="preserve">
          <source>For example, suppose that &lt;code&gt;data&lt;/code&gt; has data type &lt;code&gt;DT_INT32&lt;/code&gt; and shape (2, 3, 4), and that the fingerprint method is &lt;code&gt;farmhash64&lt;/code&gt;. In this case, the output shape is (2, 8), where 2 is the batch dimension size of &lt;code&gt;data&lt;/code&gt;, and 8 is the size of each fingerprint value in bytes. &lt;code&gt;output[0, :]&lt;/code&gt; is generated from 12 integers in &lt;code&gt;data[0, :, :]&lt;/code&gt; and similarly &lt;code&gt;output[1, :]&lt;/code&gt; is generated from other 12 integers in &lt;code&gt;data[1, :, :]&lt;/code&gt;.</source>
          <target state="translated">例えば、と仮定 &lt;code&gt;data&lt;/code&gt; データ型有し &lt;code&gt;DT_INT32&lt;/code&gt; 及び形状（2、3、4）、そして指紋法であること &lt;code&gt;farmhash64&lt;/code&gt; 。この場合、出力形状は（2、8）です。ここで、2は &lt;code&gt;data&lt;/code&gt; バッチ次元サイズ、8はバイト単位の各フィンガープリント値のサイズです。 &lt;code&gt;output[0, :]&lt;/code&gt; は &lt;code&gt;data[0, :, :]&lt;/code&gt; の12個の整数から生成され &lt;code&gt;output[1, :]&lt;/code&gt; 同様にoutput [1 、：]は &lt;code&gt;data[1, :, :]&lt;/code&gt; 他の12個の整数から生成されます。</target>
        </trans-unit>
        <trans-unit id="eb886fc90913d3858a07b6c81699df2c93cbae46" translate="yes" xml:space="preserve">
          <source>For example, suppose the logical sum of two sparse operands is (densified):</source>
          <target state="translated">例えば、2つの疎なオペランドの論理和が(密化された)だとします。</target>
        </trans-unit>
        <trans-unit id="4589e17a235fe89004e5860f53c4fa2f48fab5f8" translate="yes" xml:space="preserve">
          <source>For example, suppose there are 2 TPU replicas: replica 0 receives input: &lt;code&gt;[[A, B]]&lt;/code&gt; replica 1 receives input: &lt;code&gt;[[C, D]]&lt;/code&gt;</source>
          <target state="translated">たとえば、2つのTPUレプリカがあるとします。レプリカ0は入力を受け取ります： &lt;code&gt;[[A, B]]&lt;/code&gt; レプリカ1は入力を受け取ります： &lt;code&gt;[[C, D]]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="da5af5e9268978110edfe81515e943cf23149b6d" translate="yes" xml:space="preserve">
          <source>For example, suppose there are 4 TPU instances: &lt;code&gt;[A, B, C, D]&lt;/code&gt;. Passing source_target_pairs=&lt;code&gt;[[0,1],[1,2],[2,3],[3,0]]&lt;/code&gt; gets the outputs: &lt;code&gt;[D, A, B, C]&lt;/code&gt;.</source>
          <target state="translated">たとえば、4つのTPUインスタンスがあるとします： &lt;code&gt;[A, B, C, D]&lt;/code&gt; 。source_target_pairs = &lt;code&gt;[[0,1],[1,2],[2,3],[3,0]]&lt;/code&gt; 渡すと、出力 &lt;code&gt;[D, A, B, C]&lt;/code&gt; が取得されます。</target>
        </trans-unit>
        <trans-unit id="7b1da1c1eaf2bc599840d6f5ba841c57a047114f" translate="yes" xml:space="preserve">
          <source>For example, suppose there are 8 TPU instances: &lt;code&gt;[A, B, C, D, E, F, G, H]&lt;/code&gt;. Passing group_assignment=&lt;code&gt;[[0,2,4,6],[1,3,5,7]]&lt;/code&gt; sets &lt;code&gt;A, C, E, G&lt;/code&gt; as group 0, and &lt;code&gt;B, D, F, H&lt;/code&gt; as group 1. Thus we get the outputs: &lt;code&gt;[A+C+E+G, B+D+F+H, A+C+E+G, B+D+F+H, A+C+E+G, B+D+F+H, A+C+E+G, B+D+F+H]&lt;/code&gt;.</source>
          <target state="translated">たとえば、8つのTPUインスタンスがあるとします： &lt;code&gt;[A, B, C, D, E, F, G, H]&lt;/code&gt; 。group_assignment =を通過 &lt;code&gt;[[0,2,4,6],[1,3,5,7]]&lt;/code&gt; セット &lt;code&gt;A, C, E, G&lt;/code&gt; グループ0とし、 &lt;code&gt;B, D, F, H&lt;/code&gt; 、我々はこのようにグループ1として出力を取得します： &lt;code&gt;[A+C+E+G, B+D+F+H, A+C+E+G, B+D+F+H, A+C+E+G, B+D+F+H, A+C+E+G, B+D+F+H]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e241e14b323a360c93e117165ee51f625869bb65" translate="yes" xml:space="preserve">
          <source>For example, suppose we have a file 'my_file0.csv' with four CSV columns of different data types:</source>
          <target state="translated">例えば、異なるデータタイプの4つのCSVカラムを持つファイル'my_file0.csv'があるとします。</target>
        </trans-unit>
        <trans-unit id="803f7401710e9c763ad1dc8693918757b743ae6b" translate="yes" xml:space="preserve">
          <source>For example, the RMSprop optimizer for this simple model returns a list of three values-- the iteration count, followed by the root-mean-square value of the kernel and bias of the single Dense layer:</source>
          <target state="translated">例えば、この単純なモデルのRMSpropオプティマイザは、3つの値のリストを返します--反復回数、カーネルのルート-平均二乗値、単一の密層のバイアスが続きます。</target>
        </trans-unit>
        <trans-unit id="e264f201548e6c6b9b5c296149b210ac828d99c0" translate="yes" xml:space="preserve">
          <source>For example, the RMSprop optimizer for this simple model takes a list of three values-- the iteration count, followed by the root-mean-square value of the kernel and bias of the single Dense layer:</source>
          <target state="translated">例えば、この単純なモデルのRMSpropオプティマイザは、3つの値のリストを取ります--反復回数、カーネルのルート-平均二乗値、単一の密層のバイアスの順に続きます。</target>
        </trans-unit>
        <trans-unit id="f6fbd097fdd11950b7cadc34f9682795f00f4e27" translate="yes" xml:space="preserve">
          <source>For example, the desired output for the following 4-by-4 kernel:</source>
          <target state="translated">例えば、次のような4×4カーネルの出力を希望します。</target>
        </trans-unit>
        <trans-unit id="0636239203f94658f87029781558265ccc3966ab" translate="yes" xml:space="preserve">
          <source>For example, the desired output for the following 4-by-4 kernel::</source>
          <target state="translated">例えば、次の 4 x 4 カーネルの出力は次のようになります。</target>
        </trans-unit>
        <trans-unit id="dd21ccc094cad8a87d4c4eacb04b552c571f6bf7" translate="yes" xml:space="preserve">
          <source>For example, the returned matrix &lt;code&gt;A&lt;/code&gt; can be used to right-multiply a spectrogram &lt;code&gt;S&lt;/code&gt; of shape &lt;code&gt;[frames, num_spectrogram_bins]&lt;/code&gt; of linear scale spectrum values (e.g. STFT magnitudes) to generate a &quot;mel spectrogram&quot; &lt;code&gt;M&lt;/code&gt; of shape &lt;code&gt;[frames, num_mel_bins]&lt;/code&gt;.</source>
          <target state="translated">例えば、返された行列 &lt;code&gt;A&lt;/code&gt; は右乗算スペクトログラムに使用することができる &lt;code&gt;S&lt;/code&gt; 形状の &lt;code&gt;[frames, num_spectrogram_bins]&lt;/code&gt; 「MELスペクトログラム」を生成するリニアスケールのスペクトル値（例えばSTFT大きさ） &lt;code&gt;M&lt;/code&gt; 形状の &lt;code&gt;[frames, num_mel_bins]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="db3131b06d6d3d95a5212d36111977d0f86b08dc" translate="yes" xml:space="preserve">
          <source>For example, this error might be raised if a per-user quota is exhausted, or perhaps the entire file system is out of space.</source>
          <target state="translated">例えば、ユーザごとのクォータを使い切った場合や、ファイルシステム全体の容量が不足している場合にこのエラーが発生することがあります。</target>
        </trans-unit>
        <trans-unit id="54823754fbaf34b915d76fccb6e9c1dc44f28481" translate="yes" xml:space="preserve">
          <source>For example, this may be raised by running a &lt;code&gt;tf.WholeFileReader.read&lt;/code&gt; operation, if the file is truncated while it is being read.</source>
          <target state="translated">たとえば、読み取り中にファイルが切り捨てられた場合、これは &lt;code&gt;tf.WholeFileReader.read&lt;/code&gt; 操作を実行することで発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="ba4a59b5af2c2bc4994c4eadbe6ed4b4b272e9f3" translate="yes" xml:space="preserve">
          <source>For example, this simple dense layer does not require any additional work to support mixed precision or float64. Keras automatically casts the inputs and variable to the appropriate dtype.</source>
          <target state="translated">例えば、この単純な密なレイヤーでは、混合精度やfloat64をサポートするための追加作業は必要ありません。Kerasは、入力と変数を自動的に適切なdtypeにキャストします。</target>
        </trans-unit>
        <trans-unit id="9b4b0afbf5ba933c3cb43f3500122fd6f86887fd" translate="yes" xml:space="preserve">
          <source>For example, to create a 4 x 4 linear operator combined of three 2 x 2 operators:</source>
          <target state="translated">例えば、3つの2×2の演算子を組み合わせた4×4の線形演算子を作成する。</target>
        </trans-unit>
        <trans-unit id="abbb5690c25366ae4f227979e99899132fb6b656" translate="yes" xml:space="preserve">
          <source>For example, to define a new Python op called &lt;code&gt;my_op&lt;/code&gt;:</source>
          <target state="translated">たとえば、 &lt;code&gt;my_op&lt;/code&gt; という新しいPython opを定義するには、次のようにします。</target>
        </trans-unit>
        <trans-unit id="72eb7a551315d06a0972d21f1c1b460b5d38b044" translate="yes" xml:space="preserve">
          <source>For example, to define a new summary op called &lt;code&gt;my_op&lt;/code&gt;:</source>
          <target state="translated">たとえば、 &lt;code&gt;my_op&lt;/code&gt; という新しいサマリーオペレーションを定義するには、次のようにします。</target>
        </trans-unit>
        <trans-unit id="2965f0eb0a6433fd2e2e4ad410d8862a35002793" translate="yes" xml:space="preserve">
          <source>For example, to set the device filters for a parameter server cluster:</source>
          <target state="translated">例えば、パラメータサーバクラスタのデバイスフィルタを設定します。</target>
        </trans-unit>
        <trans-unit id="66fdf1bdfa059fe195251be30a7a3ab0c36ff0bc" translate="yes" xml:space="preserve">
          <source>For example, user can select profiler nodes placed on gpu:0 with: &lt;code&gt;account_type_regexes=['.*gpu:0.*']&lt;/code&gt;</source>
          <target state="translated">たとえば、ユーザーは次のようにしてgpu：0に配置されたプロファイラーノードを選択できます： &lt;code&gt;account_type_regexes=['.*gpu:0.*']&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="386f9efb3adea5d954835eac08e3b8fcac5cfc82" translate="yes" xml:space="preserve">
          <source>For example, we can represent the following 2D &lt;code&gt;SparseTensor&lt;/code&gt;</source>
          <target state="translated">たとえば、次の2D &lt;code&gt;SparseTensor&lt;/code&gt; を表すことができます</target>
        </trans-unit>
        <trans-unit id="47f6cacac9bb0941442b9ab6365d7dd1f22cf231" translate="yes" xml:space="preserve">
          <source>For example, with &lt;code&gt;W&lt;/code&gt;, &lt;code&gt;X&lt;/code&gt;, &lt;code&gt;Y&lt;/code&gt;, &lt;code&gt;Z&lt;/code&gt; each block circulant,</source>
          <target state="translated">たとえば、 &lt;code&gt;W&lt;/code&gt; 、 &lt;code&gt;X&lt;/code&gt; 、 &lt;code&gt;Y&lt;/code&gt; 、 &lt;code&gt;Z&lt;/code&gt; の各ブロック循環では、</target>
        </trans-unit>
        <trans-unit id="b91edd5cdc9ee891969b8b38deeabdcc71594122" translate="yes" xml:space="preserve">
          <source>For example, with &lt;code&gt;W&lt;/code&gt;, &lt;code&gt;X&lt;/code&gt;, &lt;code&gt;Y&lt;/code&gt;, &lt;code&gt;Z&lt;/code&gt; each circulant,</source>
          <target state="translated">たとえば、 &lt;code&gt;W&lt;/code&gt; 、 &lt;code&gt;X&lt;/code&gt; 、 &lt;code&gt;Y&lt;/code&gt; 、 &lt;code&gt;Z&lt;/code&gt; の各循環、</target>
        </trans-unit>
        <trans-unit id="4d1e66a246a36b7e8a1cc0afa1a8ecb4016d097b" translate="yes" xml:space="preserve">
          <source>For example, with &lt;code&gt;new_vocab_file&lt;/code&gt; a text file containing each of the following elements on a single line: &lt;code&gt;[f0, f1, f2, f3]&lt;/code&gt;, old_vocab_file = [f1, f0, f3], &lt;code&gt;num_new_vocab = 3, new_vocab_offset = 1&lt;/code&gt;, the returned remapping would be &lt;code&gt;[0, -1, 2]&lt;/code&gt;.</source>
          <target state="translated">たとえば、 &lt;code&gt;new_vocab_file&lt;/code&gt; の場合、次の各要素を1行に含むテキストファイル： &lt;code&gt;[f0, f1, f2, f3]&lt;/code&gt; 、old_vocab_file = [f1、f0、f3]、 &lt;code&gt;num_new_vocab = 3, new_vocab_offset = 1&lt;/code&gt; 、返される再マッピングであろう &lt;code&gt;[0, -1, 2]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="59bbe6de1d6b96b3f8288dbb5f70eca92be21e1f" translate="yes" xml:space="preserve">
          <source>For example, within a &lt;a href=&quot;function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;c = tf.matmul(a, b)&lt;/code&gt; creates an &lt;code&gt;Operation&lt;/code&gt; of type &quot;MatMul&quot; that takes tensors &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; as input, and produces &lt;code&gt;c&lt;/code&gt; as output.</source>
          <target state="translated">たとえば、&lt;a href=&quot;function&quot;&gt; &lt;code&gt;tf.function&lt;/code&gt; &lt;/a&gt;内で、 &lt;code&gt;c = tf.matmul(a, b)&lt;/code&gt; は、テンソル &lt;code&gt;a&lt;/code&gt; および &lt;code&gt;b&lt;/code&gt; を入力として取り、 &lt;code&gt;c&lt;/code&gt; を出力として生成する「MatMul」型の &lt;code&gt;Operation&lt;/code&gt; を作成します。</target>
        </trans-unit>
        <trans-unit id="798a25ee68143b917f057d252e6a3be788b95a21" translate="yes" xml:space="preserve">
          <source>For example, you can use &lt;a href=&quot;../../../../data/dataset#interleave&quot;&gt;&lt;code&gt;Dataset.interleave()&lt;/code&gt;&lt;/a&gt; to process many input files concurrently:</source>
          <target state="translated">たとえば、&lt;a href=&quot;../../../../data/dataset#interleave&quot;&gt; &lt;code&gt;Dataset.interleave()&lt;/code&gt; &lt;/a&gt;を使用して、多数の入力ファイルを同時に処理できます。</target>
        </trans-unit>
        <trans-unit id="62bc270e8147fe9b0d27fc9ede5facea85ba5170" translate="yes" xml:space="preserve">
          <source>For example, you can use &lt;a href=&quot;../../../data/dataset#interleave&quot;&gt;&lt;code&gt;Dataset.interleave()&lt;/code&gt;&lt;/a&gt; to process many input files concurrently:</source>
          <target state="translated">たとえば、&lt;a href=&quot;../../../data/dataset#interleave&quot;&gt; &lt;code&gt;Dataset.interleave()&lt;/code&gt; &lt;/a&gt;を使用して、多数の入力ファイルを同時に処理できます。</target>
        </trans-unit>
        <trans-unit id="0a8cdf19717ec8bf5f04585f7d033f7a2610e6d2" translate="yes" xml:space="preserve">
          <source>For example, you can use &lt;a href=&quot;../dataset#interleave&quot;&gt;&lt;code&gt;Dataset.interleave()&lt;/code&gt;&lt;/a&gt; to process many input files concurrently:</source>
          <target state="translated">たとえば、&lt;a href=&quot;../dataset#interleave&quot;&gt; &lt;code&gt;Dataset.interleave()&lt;/code&gt; &lt;/a&gt;を使用して、多数の入力ファイルを同時に処理できます。</target>
        </trans-unit>
        <trans-unit id="5898266aaebf0c43713533e3d18bf9ec4db717f3" translate="yes" xml:space="preserve">
          <source>For example, you can use &lt;a href=&quot;dataset#interleave&quot;&gt;&lt;code&gt;Dataset.interleave()&lt;/code&gt;&lt;/a&gt; to process many input files concurrently:</source>
          <target state="translated">たとえば、&lt;a href=&quot;dataset#interleave&quot;&gt; &lt;code&gt;Dataset.interleave()&lt;/code&gt; &lt;/a&gt;を使用して、多数の入力ファイルを同時に処理できます。</target>
        </trans-unit>
        <trans-unit id="6ded0202a2e44d8d69da3c4dc5a14b181602b6ff" translate="yes" xml:space="preserve">
          <source>For example, you can use &lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/data/Dataset#interleave&quot;&gt;&lt;code&gt;Dataset.interleave()&lt;/code&gt;&lt;/a&gt; to process many input files concurrently:</source>
          <target state="translated">たとえば、&lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/data/Dataset#interleave&quot;&gt; &lt;code&gt;Dataset.interleave()&lt;/code&gt; &lt;/a&gt;を使用して、多数の入力ファイルを同時に処理できます。</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例えば</target>
        </trans-unit>
        <trans-unit id="a925ece6d9c348c8aa9316dcdeed531900dee368" translate="yes" xml:space="preserve">
          <source>For example: if &lt;code&gt;filepath&lt;/code&gt; is &lt;code&gt;weights.{epoch:02d}-{val_loss:.2f}.hdf5&lt;/code&gt;, then the model checkpoints will be saved with the epoch number and the validation loss in the filename.</source>
          <target state="translated">例： &lt;code&gt;filepath&lt;/code&gt; が &lt;code&gt;weights.{epoch:02d}-{val_loss:.2f}.hdf5&lt;/code&gt; 場合、モデルのチェックポイントは、ファイル名にエポック番号と検証損失とともに保存されます。</target>
        </trans-unit>
        <trans-unit id="617a3ed2e3e514be878c5bb15678122dfc4d8ecd" translate="yes" xml:space="preserve">
          <source>For f(*args, **kwargs), this supports gradients with respect to args or kwargs, but kwargs are currently only supported in eager-mode. Note that for keras layer and model objects, this is handled automatically.</source>
          <target state="translated">f(*args,**kwargs)では、argsやkwargsに対するグラデーションをサポートしていますが、kwargsは現在のところイーガーモードでのみサポートされています。kerasレイヤとモデルオブジェクトでは、これは自動的に処理されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="1e701a0677a91df738cbd270184ad84b85cb6a3f" translate="yes" xml:space="preserve">
          <source>For f(*args, **kwargs), this supports gradients with respect to args, or to gradients with respect to any variables residing in the kwarg 'variables'. Note that for keras layer and model objects, this is handled automatically.</source>
          <target state="translated">f(*args,**kwargs)では、argsを基準としたグラデーション、またはkwarg 'variables'に含まれる変数を基準としたグラデーションをサポートしています。kerasレイヤやモデルオブジェクトの場合は、自動的に処理されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="f4b53b836d997d79180b7e3d91c8e783a2730a27" translate="yes" xml:space="preserve">
          <source>For floats, the default range is &lt;code&gt;[0, 1)&lt;/code&gt;. For ints, at least &lt;code&gt;maxval&lt;/code&gt; must be specified explicitly.</source>
          <target state="translated">フロートの場合、デフォルトの範囲は &lt;code&gt;[0, 1)&lt;/code&gt; です。intの場合、少なくとも &lt;code&gt;maxval&lt;/code&gt; を明示的に指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="356031776c93a08469e52e6e9a422b36aba24087" translate="yes" xml:space="preserve">
          <source>For full-range (i.e. inclusive of both max and min) random integers, pass &lt;code&gt;minval=None&lt;/code&gt; and &lt;code&gt;maxval=None&lt;/code&gt; with an integer &lt;code&gt;dtype&lt;/code&gt;. For an integer dtype either both &lt;code&gt;minval&lt;/code&gt; and &lt;code&gt;maxval&lt;/code&gt; must be &lt;code&gt;None&lt;/code&gt; or neither may be &lt;code&gt;None&lt;/code&gt;. For example:</source>
          <target state="translated">全範囲（すなわち、包括max及び最小の両方の）ランダム整数ため、通過 &lt;code&gt;minval=None&lt;/code&gt; と &lt;code&gt;maxval=None&lt;/code&gt; 整数と &lt;code&gt;dtype&lt;/code&gt; 。整数DTYPEのためにどちらかの両方 &lt;code&gt;minval&lt;/code&gt; と &lt;code&gt;maxval&lt;/code&gt; あってはなりません &lt;code&gt;None&lt;/code&gt; かでもないことはないかもしれ &lt;code&gt;None&lt;/code&gt; 。例えば：</target>
        </trans-unit>
        <trans-unit id="5a56bcc5ab9d5be952b7e9f40a7d23fa0400b6d0" translate="yes" xml:space="preserve">
          <source>For full-range random integers, pass &lt;code&gt;minval=None&lt;/code&gt; and &lt;code&gt;maxval=None&lt;/code&gt; with an integer &lt;code&gt;dtype&lt;/code&gt; (for integer dtypes, &lt;code&gt;minval&lt;/code&gt; and &lt;code&gt;maxval&lt;/code&gt; must be both &lt;code&gt;None&lt;/code&gt; or both not &lt;code&gt;None&lt;/code&gt;).</source>
          <target state="translated">フルレンジランダム整数の場合、通過 &lt;code&gt;minval=None&lt;/code&gt; と &lt;code&gt;maxval=None&lt;/code&gt; 整数と &lt;code&gt;dtype&lt;/code&gt; （整数dtypes用 &lt;code&gt;minval&lt;/code&gt; 及び &lt;code&gt;maxval&lt;/code&gt; 両方あってはならない &lt;code&gt;None&lt;/code&gt; かの両方 &lt;code&gt;None&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="04d421a51ab8b8a27bf19870cac97753296986e8" translate="yes" xml:space="preserve">
          <source>For future expansion. The axis to compute the DCT along. Must be &lt;code&gt;-1&lt;/code&gt;.</source>
          <target state="translated">将来の拡張のために。に沿ってDCTを計算する軸。 &lt;code&gt;-1&lt;/code&gt; である必要があります。</target>
        </trans-unit>
        <trans-unit id="8fd166b7a90884f7ea7652e9d0c336832f3c0f77" translate="yes" xml:space="preserve">
          <source>For future expansion. The length of the transform. Must be &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">将来の拡張のために。変換の長さ。 &lt;code&gt;None&lt;/code&gt; 必要があります。</target>
        </trans-unit>
        <trans-unit id="e111c995974685355c526b35bd247aea54214a0f" translate="yes" xml:space="preserve">
          <source>For gamma greater than 1, the histogram will shift towards left and the output image will be darker than the input image. For gamma less than 1, the histogram will shift towards right and the output image will be brighter than the input image.</source>
          <target state="translated">ガンマ値が1より大きい場合、ヒストグラムは左に向かってシフトし、出力画像は入力画像よりも暗くなります。ガンマ値が1より小さい場合、ヒストグラムは右に向かってシフトし、出力画像は入力画像よりも明るくなります。</target>
        </trans-unit>
        <trans-unit id="b943cfdd2ff2928a3736e51095c0c36b03cbbceb" translate="yes" xml:space="preserve">
          <source>For greater flexibility, use &quot;Iterator&quot; and &quot;MakeIterator&quot; to define an iterator using an arbitrary subgraph, which may capture tensors (including fed values) as parameters, and which may be reset multiple times by rerunning &quot;MakeIterator&quot;.</source>
          <target state="translated">より柔軟性を高めるには、&quot;Iterator&quot; および &quot;MakeIterator&quot; を使用して任意のサブグラフを使用したイテレータを定義します。</target>
        </trans-unit>
        <trans-unit id="2a9f804d2c5657eeaad57f76da30d8419d9f80b2" translate="yes" xml:space="preserve">
          <source>For information about the valid syntax of device name strings, see the documentation in &lt;a href=&quot;https://www.tensorflow.org/code/tensorflow/core/util/device_name_utils.h&quot;&gt;&lt;code&gt;DeviceNameUtils&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">デバイス名文字列の有効な構文については、&lt;a href=&quot;https://www.tensorflow.org/code/tensorflow/core/util/device_name_utils.h&quot;&gt; &lt;code&gt;DeviceNameUtils&lt;/code&gt; &lt;/a&gt;のドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="e34ec3911430ce7f98ae14651feabc2f68db9179" translate="yes" xml:space="preserve">
          <source>For input dictionary &lt;code&gt;features&lt;/code&gt;, &lt;code&gt;features[key]&lt;/code&gt; is either &lt;code&gt;Tensor&lt;/code&gt; or &lt;code&gt;SparseTensor&lt;/code&gt;. If &lt;code&gt;Tensor&lt;/code&gt;, missing values can be represented by &lt;code&gt;-1&lt;/code&gt; for int and &lt;code&gt;''&lt;/code&gt; for string, which will be dropped by this feature column.</source>
          <target state="translated">入力辞書 &lt;code&gt;features&lt;/code&gt; の場合、 &lt;code&gt;features[key]&lt;/code&gt; は &lt;code&gt;Tensor&lt;/code&gt; または &lt;code&gt;SparseTensor&lt;/code&gt; のいずれかです。 &lt;code&gt;Tensor&lt;/code&gt; の場合、欠損値は、intの場合は &lt;code&gt;-1&lt;/code&gt; 、文字列の場合は &lt;code&gt;''&lt;/code&gt; で表すことができます。これらはこの機能列によって削除されます。</target>
        </trans-unit>
        <trans-unit id="972f34fd8ce79a7530b5410304e5c7ff8345495d" translate="yes" xml:space="preserve">
          <source>For instance, &lt;a href=&quot;iteratorspec&quot;&gt;&lt;code&gt;tf.data.IteratorSpec&lt;/code&gt;&lt;/a&gt; can be used to define a tf.function that takes &lt;a href=&quot;iterator&quot;&gt;&lt;code&gt;tf.data.Iterator&lt;/code&gt;&lt;/a&gt; as an input argument:</source>
          <target state="translated">例えば、&lt;a href=&quot;iteratorspec&quot;&gt; &lt;code&gt;tf.data.IteratorSpec&lt;/code&gt; が&lt;/a&gt;かかりtf.function定義するために使用することができる&lt;a href=&quot;iterator&quot;&gt; &lt;code&gt;tf.data.Iterator&lt;/code&gt; を&lt;/a&gt;入力引数としてました：</target>
        </trans-unit>
        <trans-unit id="b6ac02ce36aad1c0613f5ac2778adacecfd565ae" translate="yes" xml:space="preserve">
          <source>For instance, &lt;a href=&quot;optionalspec&quot;&gt;&lt;code&gt;tf.OptionalSpec&lt;/code&gt;&lt;/a&gt; can be used to define a tf.function that takes &lt;a href=&quot;experimental/optional&quot;&gt;&lt;code&gt;tf.experimental.Optional&lt;/code&gt;&lt;/a&gt; as an input argument:</source>
          <target state="translated">例えば、&lt;a href=&quot;optionalspec&quot;&gt; &lt;code&gt;tf.OptionalSpec&lt;/code&gt; が&lt;/a&gt;かかりtf.function定義するために使用することができる&lt;a href=&quot;experimental/optional&quot;&gt; &lt;code&gt;tf.experimental.Optional&lt;/code&gt; を&lt;/a&gt;入力引数としてました：</target>
        </trans-unit>
        <trans-unit id="dd184a755e96827d1f8c5b725d00ffce6156808d" translate="yes" xml:space="preserve">
          <source>For instance, if &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt; are Keras tensors, it becomes possible to do: &lt;code&gt;model = Model(input=[a, b], output=c)&lt;/code&gt;</source>
          <target state="translated">例えば、もし、 &lt;code&gt;b&lt;/code&gt; 及び &lt;code&gt;c&lt;/code&gt; Kerasテンソルであり、それが行うことが可能となる： &lt;code&gt;model = Model(input=[a, b], output=c)&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e5e4d4d23c7dda349004192ebc96c46b6465ca75" translate="yes" xml:space="preserve">
          <source>For instance, if &lt;code&gt;params&lt;/code&gt; is a 5x2 matrix:</source>
          <target state="translated">たとえば、 &lt;code&gt;params&lt;/code&gt; が5x2行列の場合：</target>
        </trans-unit>
        <trans-unit id="3d566a2f8f613dd39800087ce7bc50e2d5f86120" translate="yes" xml:space="preserve">
          <source>For instance, if a, b and c are Keras tensors, it becomes possible to do: &lt;code&gt;model = Model(input=[a, b], output=c)&lt;/code&gt;</source>
          <target state="translated">たとえば、a、b、cがKerasテンソルの場合、次のことが可能になります。model &lt;code&gt;model = Model(input=[a, b], output=c)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0e53703556bacc5b9f2dd5c8a308f65648989002" translate="yes" xml:space="preserve">
          <source>For instance, if params is a 10x20 matrix, and sp_ids / sp_weights are</source>
          <target state="translated">例えば、params が 10x20 の行列で、sp_ids/sp_weights が</target>
        </trans-unit>
        <trans-unit id="cc75bd8580ca757aae48910bd54d05e3c0b7bbe2" translate="yes" xml:space="preserve">
          <source>For instance, if your dataset contains 10,000 elements but &lt;code&gt;buffer_size&lt;/code&gt; is set to 1,000, then &lt;code&gt;shuffle&lt;/code&gt; will initially select a random element from only the first 1,000 elements in the buffer. Once an element is selected, its space in the buffer is replaced by the next (i.e. 1,001-st) element, maintaining the 1,000 element buffer.</source>
          <target state="translated">たとえば、データセットに10,000要素が含まれているが &lt;code&gt;buffer_size&lt;/code&gt; が1,000に設定されている場合、 &lt;code&gt;shuffle&lt;/code&gt; は最初にバッファー内の最初の1,000要素のみからランダムな要素を選択します。要素が選択されると、バッファ内のそのスペースは次の（つまり、001-st）要素に置き換えられ、1,000要素のバッファが維持されます。</target>
        </trans-unit>
        <trans-unit id="abc897209b2f98b7966665fa36a5eddbbc44f66d" translate="yes" xml:space="preserve">
          <source>For instance:</source>
          <target state="translated">例えば</target>
        </trans-unit>
        <trans-unit id="0a0b5cd490edef9c44f6a6d5414aa3f055e77d75" translate="yes" xml:space="preserve">
          <source>For invalid/unknown format arguments.</source>
          <target state="translated">無効/未知のフォーマット引数の場合。</target>
        </trans-unit>
        <trans-unit id="0f9023a39798cc65b443278b72b316a68e41f333" translate="yes" xml:space="preserve">
          <source>For many models, each layer's policy will have the same compute dtype and variable dtype, which will typically be float32. In this case, we refer to the singular dtype as the layer's dtype, which can be queried by the property &lt;a href=&quot;../../layers/layer#dtype&quot;&gt;&lt;code&gt;tf.keras.layers.Layer.dtype&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">多くのモデルでは、各レイヤーのポリシーは同じ計算dtypeと変数dtypeを持ち、通常はfloat32になります。この場合、単数形のdtypeをレイヤーのdtypeと&lt;a href=&quot;../../layers/layer#dtype&quot;&gt; &lt;code&gt;tf.keras.layers.Layer.dtype&lt;/code&gt; &lt;/a&gt;ます。これは、プロパティtf.keras.layers.Layer.dtypeで照会できます。</target>
        </trans-unit>
        <trans-unit id="e88bb5e1430cab829924a15faf891ea4f1ef4619" translate="yes" xml:space="preserve">
          <source>For matrices (resp. higher rank input), computes the entries which is the nth-smallest value in each row (resp. vector along the last dimension). Thus,</source>
          <target state="translated">行列(より高いランクの入力)の場合は,各行(最後の次元に沿ったベクトル)の中でn番目に小さい値であるエントリを計算します.したがって,以下のようになります.</target>
        </trans-unit>
        <trans-unit id="0a9115e76a0ba9659e12e140504c8f7f39148287" translate="yes" xml:space="preserve">
          <source>For matrices (resp. higher rank input), computes the top &lt;code&gt;k&lt;/code&gt; entries in each row (resp. vector along the last dimension). Thus,</source>
          <target state="translated">行列（それぞれ上位の入力）の場合、各行の上位 &lt;code&gt;k&lt;/code&gt; エントリを計算します（最後の次元に沿ったベクトル）。したがって、</target>
        </trans-unit>
        <trans-unit id="f6f81428f9faf616b5f58bf1dfb8c2ee23290062" translate="yes" xml:space="preserve">
          <source>For more details on fractional max pooling, see this paper: &lt;a href=&quot;http://arxiv.org/abs/1412.6071&quot;&gt;Benjamin Graham, Fractional Max-Pooling&lt;/a&gt;</source>
          <target state="translated">フラクショナルマックスプーリングの詳細については、次のペーパーを参照してください&lt;a href=&quot;http://arxiv.org/abs/1412.6071&quot;&gt;。BenjaminGraham、フラクショナルマックスプール&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bdc341899055084bcb94f72be25a2efd912ef0ce" translate="yes" xml:space="preserve">
          <source>For more details on warm-start configuration, see &lt;a href=&quot;../../../estimator/warmstartsettings&quot;&gt;&lt;code&gt;tf.estimator.WarmStartSettings&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">ウォームスタート構成の詳細については、&lt;a href=&quot;../../../estimator/warmstartsettings&quot;&gt; &lt;code&gt;tf.estimator.WarmStartSettings&lt;/code&gt; を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="1e3c977af7155e901bdef759f3dc14b55e9fc4b7" translate="yes" xml:space="preserve">
          <source>For more details on warm-start configuration, see &lt;a href=&quot;warmstartsettings&quot;&gt;&lt;code&gt;tf.estimator.WarmStartSettings&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">ウォームスタート構成の詳細については、&lt;a href=&quot;warmstartsettings&quot;&gt; &lt;code&gt;tf.estimator.WarmStartSettings&lt;/code&gt; を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="13a2417d18055bf8846c48234727817863de443c" translate="yes" xml:space="preserve">
          <source>For more details, see the documentation for &lt;code&gt;keras_style_scope&lt;/code&gt;.</source>
          <target state="translated">詳細については、 &lt;code&gt;keras_style_scope&lt;/code&gt; のドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="bc3a84c33cbfb26e5b4fe97277347db008f299e4" translate="yes" xml:space="preserve">
          <source>For more information about creating layers, see the guide &lt;a href=&quot;https://www.tensorflow.org/guide/keras/custom_layers_and_models&quot;&gt;Writing custom layers and models with Keras&lt;/a&gt;</source>
          <target state="translated">レイヤーの作成の詳細については&lt;a href=&quot;https://www.tensorflow.org/guide/keras/custom_layers_and_models&quot;&gt;、Kerasを使用したカスタムレイヤーとモデルの&lt;/a&gt;作成ガイドを参照してください。</target>
        </trans-unit>
        <trans-unit id="152f8ea26d1cff79ab2d01228bf1bdbd0f39e953" translate="yes" xml:space="preserve">
          <source>For more information on eager execution, see the &lt;a href=&quot;https://tensorflow.org/guide/eager&quot;&gt;Eager guide&lt;/a&gt;.</source>
          <target state="translated">意欲的な実行の詳細については、&lt;a href=&quot;https://tensorflow.org/guide/eager&quot;&gt;意欲的なガイドを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="900a1418668618874090d4e9686dce63aca4019d" translate="yes" xml:space="preserve">
          <source>For more information see: &lt;a href=&quot;https://github.com/catapult-project/catapult/blob/master/tracing/README.md&quot;&gt;https://github.com/catapult-project/catapult/blob/master/tracing/README.md&lt;/a&gt;</source>
          <target state="translated">詳細については、&lt;a href=&quot;https://github.com/catapult-project/catapult/blob/master/tracing/README.md&quot;&gt;https&lt;/a&gt;：//github.com/catapult-project/catapult/blob/master/tracing/README.mdを参照してください。</target>
        </trans-unit>
        <trans-unit id="4a3c4bae8cff17665d7c40bbc999f6a1d5c25c78" translate="yes" xml:space="preserve">
          <source>For more information see: https://github.com/catapult-project/catapult/blob/master/tracing/README.md</source>
          <target state="translated">詳細については、https://github.com/catapult-project/catapult/blob/master/tracing/README.md を参照してください。</target>
        </trans-unit>
        <trans-unit id="4a2de7b882a594ae2b76e69009622fd319f6d72c" translate="yes" xml:space="preserve">
          <source>For more information, please see &lt;a href=&quot;../../../../distribute/cluster_resolver/clusterresolver&quot;&gt;&lt;code&gt;tf.distribute.cluster_resolver.ClusterResolver&lt;/code&gt;&lt;/a&gt;'s API docstring.</source>
          <target state="translated">詳細については、&lt;a href=&quot;../../../../distribute/cluster_resolver/clusterresolver&quot;&gt; &lt;code&gt;tf.distribute.cluster_resolver.ClusterResolver&lt;/code&gt; のAPIdocstring&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="1c8bf9775f80fdadad83c8c4c855a86b67b010f7" translate="yes" xml:space="preserve">
          <source>For more information, please see &lt;a href=&quot;../../../distribute/cluster_resolver/clusterresolver&quot;&gt;&lt;code&gt;tf.distribute.cluster_resolver.ClusterResolver&lt;/code&gt;&lt;/a&gt;'s API docstring.</source>
          <target state="translated">詳細については、&lt;a href=&quot;../../../distribute/cluster_resolver/clusterresolver&quot;&gt; &lt;code&gt;tf.distribute.cluster_resolver.ClusterResolver&lt;/code&gt; のAPIdocstring&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="f363dc145e0cc1796e063aa7c7c95c22e2b1d829" translate="yes" xml:space="preserve">
          <source>For more information, please see &lt;a href=&quot;../cluster_resolver/clusterresolver&quot;&gt;&lt;code&gt;tf.distribute.cluster_resolver.ClusterResolver&lt;/code&gt;&lt;/a&gt;'s API docstring.</source>
          <target state="translated">詳細については、&lt;a href=&quot;../cluster_resolver/clusterresolver&quot;&gt; &lt;code&gt;tf.distribute.cluster_resolver.ClusterResolver&lt;/code&gt; のAPIdocstring&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="f0a9d42be5d971abb321854a800de6f708fb0dd0" translate="yes" xml:space="preserve">
          <source>For more information, please see &lt;a href=&quot;cluster_resolver/clusterresolver&quot;&gt;&lt;code&gt;tf.distribute.cluster_resolver.ClusterResolver&lt;/code&gt;&lt;/a&gt;'s API docstring.</source>
          <target state="translated">詳細については、&lt;a href=&quot;cluster_resolver/clusterresolver&quot;&gt; &lt;code&gt;tf.distribute.cluster_resolver.ClusterResolver&lt;/code&gt; のAPIdocstring&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="b1a73ddb9ef63644514bdf8fb1c157f4573b5f92" translate="yes" xml:space="preserve">
          <source>For more information, please see &lt;a href=&quot;clusterresolver&quot;&gt;&lt;code&gt;tf.distribute.cluster_resolver.ClusterResolver&lt;/code&gt;&lt;/a&gt;'s class doc.</source>
          <target state="translated">詳細については、&lt;a href=&quot;clusterresolver&quot;&gt; &lt;code&gt;tf.distribute.cluster_resolver.ClusterResolver&lt;/code&gt; &lt;/a&gt;のクラスドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="55bb2f27fa02e7cb1d336fbb0fd9c36f4d1660c5" translate="yes" xml:space="preserve">
          <source>For more information, please see &lt;a href=&quot;clusterresolver&quot;&gt;&lt;code&gt;tf.distribute.cluster_resolver.ClusterResolver&lt;/code&gt;&lt;/a&gt;'s class docstring.</source>
          <target state="translated">詳細については、&lt;a href=&quot;clusterresolver&quot;&gt; &lt;code&gt;tf.distribute.cluster_resolver.ClusterResolver&lt;/code&gt; &lt;/a&gt;のクラスdocstringを参照してください。</target>
        </trans-unit>
        <trans-unit id="b43d393bddf0580f867617eb6c2e2f89c938fa23" translate="yes" xml:space="preserve">
          <source>For more information, see the &lt;a href=&quot;https://www.tensorflow.org/guide/autograph&quot;&gt;AutoGraph guide&lt;/a&gt;.</source>
          <target state="translated">詳細については、&lt;a href=&quot;https://www.tensorflow.org/guide/autograph&quot;&gt;オートグラフガイドを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="e65c930b04240141dad57bca65273288271b2809" translate="yes" xml:space="preserve">
          <source>For more on Tensors, see the &lt;a href=&quot;https://tensorflow.org/guide/tensor&quot;&gt;guide&lt;/a&gt;.</source>
          <target state="translated">テンソルの詳細については、&lt;a href=&quot;https://tensorflow.org/guide/tensor&quot;&gt;ガイドを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="6ec21b841a665c40f4c5e83efe27648e19e46e51" translate="yes" xml:space="preserve">
          <source>For ops such as matrix multiplication, inputs and weights must be of the same float type. This function validates that all &lt;code&gt;tensors&lt;/code&gt; are the same type, validates that type is &lt;code&gt;dtype&lt;/code&gt; (if supplied), and returns the type. Type must be a floating point type. If neither &lt;code&gt;tensors&lt;/code&gt; nor &lt;code&gt;dtype&lt;/code&gt; is supplied, the function will return &lt;a href=&quot;../dtypes#float32&quot;&gt;&lt;code&gt;dtypes.float32&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">行列乗算などの演算の場合、入力と重みは同じ浮動小数点型でなければなりません。この関数は、すべての &lt;code&gt;tensors&lt;/code&gt; が同じタイプであることを検証し、そのタイプが &lt;code&gt;dtype&lt;/code&gt; （指定されている場合）であることを検証し、タイプを返します。タイプは浮動小数点タイプでなければなりません。 &lt;code&gt;tensors&lt;/code&gt; も &lt;code&gt;dtype&lt;/code&gt; も指定されていない場合、関数は&lt;a href=&quot;../dtypes#float32&quot;&gt; &lt;code&gt;dtypes.float32&lt;/code&gt; &lt;/a&gt;を返します。</target>
        </trans-unit>
        <trans-unit id="825adbf912a447d1f0e6ca8ee392497c694816b6" translate="yes" xml:space="preserve">
          <source>For ops that have a well-defined gradient but are not yet implemented, no declaration should be made, and an error &lt;em&gt;must&lt;/em&gt; be thrown if an attempt to request its gradient is made.</source>
          <target state="translated">明確に定義された勾配があるが、まだ実装されていないopの場合、宣言は行われず、勾配を要求しようとするとエラーがスローされる&lt;em&gt;必要&lt;/em&gt;が&lt;em&gt;あり&lt;/em&gt;ます。</target>
        </trans-unit>
        <trans-unit id="3c54552d8b9297a0500954f1e7088d433c083309" translate="yes" xml:space="preserve">
          <source>For positive numbers, this function computes log((input - 1)!) for every element in the tensor. &lt;code&gt;lgamma(5) = log((5-1)!) = log(4!) = log(24) = 3.1780539&lt;/code&gt;</source>
          <target state="translated">正の数の場合、この関数はテンソルのすべての要素のlog（（input-1）！）を計算します。 &lt;code&gt;lgamma(5) = log((5-1)!) = log(4!) = log(24) = 3.1780539&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="17614033a9da90968bc5248bce2e63241d0b5eef" translate="yes" xml:space="preserve">
          <source>For prediction, merges predictions and updates keys in prediction dict to a 2-tuple, &lt;code&gt;(head.name, prediction_key)&lt;/code&gt;. Merges &lt;code&gt;export_outputs&lt;/code&gt; such that by default the first head is served.</source>
          <target state="translated">予測の場合、予測をマージし &lt;code&gt;(head.name, prediction_key)&lt;/code&gt; キーを2タプル（head.name、prediction_key）に更新します。マージの &lt;code&gt;export_outputs&lt;/code&gt; 、デフォルトでは最初のヘッドが提供されるようになっています。</target>
        </trans-unit>
        <trans-unit id="367d3134a5e071179a22d4af24a5885a46b948f8" translate="yes" xml:space="preserve">
          <source>For prediction, the exported &lt;code&gt;MetaGraphDef&lt;/code&gt; will provide one &lt;code&gt;SignatureDef&lt;/code&gt; for each element of the &lt;code&gt;export_outputs&lt;/code&gt; dict returned from the &lt;code&gt;model_fn&lt;/code&gt;, named using the same keys. One of these keys is always &lt;code&gt;tf.saved_model.signature_constants.DEFAULT_SERVING_SIGNATURE_DEF_KEY&lt;/code&gt;, indicating which signature will be served when a serving request does not specify one. For each signature, the outputs are provided by the corresponding &lt;a href=&quot;../../../../estimator/export/exportoutput&quot;&gt;&lt;code&gt;tf.estimator.export.ExportOutput&lt;/code&gt;&lt;/a&gt;s, and the inputs are always the input receivers provided by the &lt;code&gt;serving_input_receiver_fn&lt;/code&gt;.</source>
          <target state="translated">予測のために、エクスポートした &lt;code&gt;MetaGraphDef&lt;/code&gt; は、 1つを提供します &lt;code&gt;SignatureDef&lt;/code&gt; の各要素について &lt;code&gt;export_outputs&lt;/code&gt; がから返さDICT &lt;code&gt;model_fn&lt;/code&gt; 、同じキーを使用して命名します。これらのキーの1つは常に &lt;code&gt;tf.saved_model.signature_constants.DEFAULT_SERVING_SIGNATURE_DEF_KEY&lt;/code&gt; であり、提供するリクエストで指定されていない場合に提供される署名を示します。各署名について、出力は対応する&lt;a href=&quot;../../../../estimator/export/exportoutput&quot;&gt; &lt;code&gt;tf.estimator.export.ExportOutput&lt;/code&gt; &lt;/a&gt;によって提供され、入力は常に &lt;code&gt;serving_input_receiver_fn&lt;/code&gt; によって提供される入力レシーバーです。</target>
        </trans-unit>
        <trans-unit id="d910d10e5e5c18870b7b9be467a883825361a57a" translate="yes" xml:space="preserve">
          <source>For prediction, the exported &lt;code&gt;MetaGraphDef&lt;/code&gt; will provide one &lt;code&gt;SignatureDef&lt;/code&gt; for each element of the &lt;code&gt;export_outputs&lt;/code&gt; dict returned from the &lt;code&gt;model_fn&lt;/code&gt;, named using the same keys. One of these keys is always &lt;code&gt;tf.saved_model.signature_constants.DEFAULT_SERVING_SIGNATURE_DEF_KEY&lt;/code&gt;, indicating which signature will be served when a serving request does not specify one. For each signature, the outputs are provided by the corresponding &lt;a href=&quot;../../../estimator/export/exportoutput&quot;&gt;&lt;code&gt;tf.estimator.export.ExportOutput&lt;/code&gt;&lt;/a&gt;s, and the inputs are always the input receivers provided by the &lt;code&gt;serving_input_receiver_fn&lt;/code&gt;.</source>
          <target state="translated">予測のために、エクスポートした &lt;code&gt;MetaGraphDef&lt;/code&gt; は、 1つを提供します &lt;code&gt;SignatureDef&lt;/code&gt; の各要素について &lt;code&gt;export_outputs&lt;/code&gt; がから返さDICT &lt;code&gt;model_fn&lt;/code&gt; 、同じキーを使用して命名します。これらのキーの1つは常に &lt;code&gt;tf.saved_model.signature_constants.DEFAULT_SERVING_SIGNATURE_DEF_KEY&lt;/code&gt; であり、提供するリクエストで指定されていない場合に提供される署名を示します。各署名について、出力は対応する&lt;a href=&quot;../../../estimator/export/exportoutput&quot;&gt; &lt;code&gt;tf.estimator.export.ExportOutput&lt;/code&gt; &lt;/a&gt;によって提供され、入力は常に &lt;code&gt;serving_input_receiver_fn&lt;/code&gt; によって提供される入力レシーバーです。</target>
        </trans-unit>
        <trans-unit id="85e499998a4aff01940823b0150823a9caaab4eb" translate="yes" xml:space="preserve">
          <source>For prediction, the exported &lt;code&gt;MetaGraphDef&lt;/code&gt; will provide one &lt;code&gt;SignatureDef&lt;/code&gt; for each element of the &lt;code&gt;export_outputs&lt;/code&gt; dict returned from the &lt;code&gt;model_fn&lt;/code&gt;, named using the same keys. One of these keys is always &lt;code&gt;tf.saved_model.signature_constants.DEFAULT_SERVING_SIGNATURE_DEF_KEY&lt;/code&gt;, indicating which signature will be served when a serving request does not specify one. For each signature, the outputs are provided by the corresponding &lt;a href=&quot;../export/exportoutput&quot;&gt;&lt;code&gt;tf.estimator.export.ExportOutput&lt;/code&gt;&lt;/a&gt;s, and the inputs are always the input receivers provided by the &lt;code&gt;serving_input_receiver_fn&lt;/code&gt;.</source>
          <target state="translated">予測のために、エクスポートした &lt;code&gt;MetaGraphDef&lt;/code&gt; は、 1つを提供します &lt;code&gt;SignatureDef&lt;/code&gt; の各要素について &lt;code&gt;export_outputs&lt;/code&gt; がから返さDICT &lt;code&gt;model_fn&lt;/code&gt; 、同じキーを使用して命名します。これらのキーの1つは常に &lt;code&gt;tf.saved_model.signature_constants.DEFAULT_SERVING_SIGNATURE_DEF_KEY&lt;/code&gt; であり、提供するリクエストで指定されていない場合に提供される署名を示します。各署名について、出力は対応する&lt;a href=&quot;../export/exportoutput&quot;&gt; &lt;code&gt;tf.estimator.export.ExportOutput&lt;/code&gt; &lt;/a&gt;によって提供され、入力は常に &lt;code&gt;serving_input_receiver_fn&lt;/code&gt; によって提供される入力レシーバーです。</target>
        </trans-unit>
        <trans-unit id="4f2dca7789ee2c5012c2ae28c6f51ef0341736b8" translate="yes" xml:space="preserve">
          <source>For prediction, the exported &lt;code&gt;MetaGraphDef&lt;/code&gt; will provide one &lt;code&gt;SignatureDef&lt;/code&gt; for each element of the &lt;code&gt;export_outputs&lt;/code&gt; dict returned from the &lt;code&gt;model_fn&lt;/code&gt;, named using the same keys. One of these keys is always &lt;code&gt;tf.saved_model.signature_constants.DEFAULT_SERVING_SIGNATURE_DEF_KEY&lt;/code&gt;, indicating which signature will be served when a serving request does not specify one. For each signature, the outputs are provided by the corresponding &lt;a href=&quot;export/exportoutput&quot;&gt;&lt;code&gt;tf.estimator.export.ExportOutput&lt;/code&gt;&lt;/a&gt;s, and the inputs are always the input receivers provided by the &lt;code&gt;serving_input_receiver_fn&lt;/code&gt;.</source>
          <target state="translated">予測のために、エクスポートした &lt;code&gt;MetaGraphDef&lt;/code&gt; は、 1つを提供します &lt;code&gt;SignatureDef&lt;/code&gt; の各要素について &lt;code&gt;export_outputs&lt;/code&gt; がから返さDICT &lt;code&gt;model_fn&lt;/code&gt; 、同じキーを使用して命名します。これらのキーの1つは常に &lt;code&gt;tf.saved_model.signature_constants.DEFAULT_SERVING_SIGNATURE_DEF_KEY&lt;/code&gt; であり、提供するリクエストで指定されていない場合に提供される署名を示します。各署名について、出力は対応する&lt;a href=&quot;export/exportoutput&quot;&gt; &lt;code&gt;tf.estimator.export.ExportOutput&lt;/code&gt; &lt;/a&gt;によって提供され、入力は常に &lt;code&gt;serving_input_receiver_fn&lt;/code&gt; によって提供される入力レシーバーです。</target>
        </trans-unit>
        <trans-unit id="51b640d64056e8e41f482c3d3c805d8ad85d361d" translate="yes" xml:space="preserve">
          <source>For python 2.x.</source>
          <target state="translated">python 2.x用。</target>
        </trans-unit>
        <trans-unit id="6616ed4ca65ec91b81df8451d8cc7918059964cb" translate="yes" xml:space="preserve">
          <source>For regression: one-dimensional label.</source>
          <target state="translated">回帰の場合:一次元ラベル。</target>
        </trans-unit>
        <trans-unit id="ebc60d85f1c75542a5be8407d74123940e50f678" translate="yes" xml:space="preserve">
          <source>For saving the input pipeline checkpoint alongside the model weights use &lt;a href=&quot;make_saveable_from_iterator&quot;&gt;&lt;code&gt;tf.data.experimental.make_saveable_from_iterator&lt;/code&gt;&lt;/a&gt; directly to create a &lt;code&gt;SaveableObject&lt;/code&gt; and add to the &lt;code&gt;SAVEABLE_OBJECTS&lt;/code&gt; collection. Note, however, that you will need to be careful not to restore the training iterator during eval. You can do that by not adding the iterator to the SAVEABLE_OBJECTS collector when building the eval graph.</source>
          <target state="translated">モデルの重みと一緒に入力パイプライン・チェックポイントを保存するために使用&lt;a href=&quot;make_saveable_from_iterator&quot;&gt; &lt;code&gt;tf.data.experimental.make_saveable_from_iterator&lt;/code&gt; を&lt;/a&gt;作成するために、直接 &lt;code&gt;SaveableObject&lt;/code&gt; をしてに追加 &lt;code&gt;SAVEABLE_OBJECTS&lt;/code&gt; のコレクション。ただし、eval中にトレーニングイテレータを復元しないように注意する必要があることに注意してください。これは、評価グラフを作成するときにSAVEABLE_OBJECTSコレクターにイテレーターを追加しないことで実現できます。</target>
        </trans-unit>
        <trans-unit id="6616597fc49d1e10b07181ff6fbd22315bce9b2f" translate="yes" xml:space="preserve">
          <source>For string data, one should expect &lt;code&gt;Fingerprint(data) != Fingerprint(ReduceJoin(data))&lt;/code&gt; in general.</source>
          <target state="translated">文字列データの場合、一般的に &lt;code&gt;Fingerprint(data) != Fingerprint(ReduceJoin(data))&lt;/code&gt; を期待する必要があります。</target>
        </trans-unit>
        <trans-unit id="4040772dee03e98d438db586092ddda710d40777" translate="yes" xml:space="preserve">
          <source>For string data, one should expect &lt;code&gt;tf.fingerprint(data) != tf.fingerprint(tf.string.reduce_join(data))&lt;/code&gt; in general.</source>
          <target state="translated">文字列データの場合、 &lt;code&gt;tf.fingerprint(data) != tf.fingerprint(tf.string.reduce_join(data))&lt;/code&gt; が必要です。</target>
        </trans-unit>
        <trans-unit id="1aee93356a8ac03609dbb2efcc3b9bc6ffc3cf8f" translate="yes" xml:space="preserve">
          <source>For the above example, make_parse_example_spec would return the dict:</source>
          <target state="translated">上記の例では、make_parse_example_specはdictを返します。</target>
        </trans-unit>
        <trans-unit id="06ccd3d90a70db2dc3e63a184d4c540501fffaaf" translate="yes" xml:space="preserve">
          <source>For the advanced use cases like model parallelism, you can set &lt;code&gt;experimental_device_assignment&lt;/code&gt; argument when creating TPUStrategy to specify number of replicas and number of logical devices. Below is an example to initialize TPU system with 2 logical devices and 1 replica.</source>
          <target state="translated">モデルの並列処理などの高度なユースケースでは、TPUStrategyの作成時に &lt;code&gt;experimental_device_assignment&lt;/code&gt; 引数を設定して、レプリカの数と論理デバイスの数を指定できます。以下は、2つの論理デバイスと1つのレプリカを使用してTPUシステムを初期化する例です。</target>
        </trans-unit>
        <trans-unit id="0235be247e65fa625cc59d166e2a6820d050e19f" translate="yes" xml:space="preserve">
          <source>For the content in &lt;code&gt;TF_CONFIG&lt;/code&gt;, assume that the training cluster spec looks like:</source>
          <target state="translated">&lt;code&gt;TF_CONFIG&lt;/code&gt; の内容について、トレーニングクラスタの仕様が次のようになっていると想定します。</target>
        </trans-unit>
        <trans-unit id="d988a3e29b8ed246ee76e0c2e493b1b397597de1" translate="yes" xml:space="preserve">
          <source>For the idea of warm starts here controlled by &lt;code&gt;num_periods&lt;/code&gt;, see [Loshchilov &amp;amp; Hutter, ICLR2016] SGDR: Stochastic Gradient Descent with Warm Restarts. &lt;a href=&quot;https://arxiv.org/abs/1608.03983&quot;&gt;https://arxiv.org/abs/1608.03983&lt;/a&gt;</source>
          <target state="translated">ここで &lt;code&gt;num_periods&lt;/code&gt; によって制御されるウォームスタートの概念については、[Loshchilov＆Hutter、ICLR2016] SGDR：ウォームリスタートを伴う確率的勾配降下法を参照してください。&lt;a href=&quot;https://arxiv.org/abs/1608.03983&quot;&gt;https://arxiv.org/abs/1608.03983&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8f06a3bf9b1afd83f2dc01b9bce2b59a3031f004" translate="yes" xml:space="preserve">
          <source>For the idea of warm starts here controlled by &lt;code&gt;num_periods&lt;/code&gt;, see [Loshchilov &amp;amp; Hutter, ICLR2016] SGDR: Stochastic Gradient Descent with Warm Restarts. https://arxiv.org/abs/1608.03983</source>
          <target state="translated">ここで &lt;code&gt;num_periods&lt;/code&gt; によって制御されるウォームスタートのアイデアについては、[Loshchilov＆Hutter、ICLR2016] SGDR：ウォームリスタートによる確率的勾配降下を参照してください。https://arxiv.org/abs/1608.03983</target>
        </trans-unit>
        <trans-unit id="44813089d644664d33f4de2b9592fffa98ddb5ec" translate="yes" xml:space="preserve">
          <source>For the most part, layers will automatically support mixed precision and float64 without any additional work, due to the fact the base layer automatically casts inputs, creates variables of the correct type, and in the case of mixed precision, wraps variables with &lt;code&gt;AutoCastVariables&lt;/code&gt;.</source>
          <target state="translated">ほとんどの場合、ベースレイヤーは自動的に入力をキャストし、正しいタイプの変数を作成し、混合精度の場合は変数を &lt;code&gt;AutoCastVariables&lt;/code&gt; でラップするため、レイヤーは追加の作業なしで混合精度とfloat64を自動的にサポートします。</target>
        </trans-unit>
        <trans-unit id="cd1f2c4cb29e01e87b19426efdde9e0733dd9a05" translate="yes" xml:space="preserve">
          <source>For the most part, the mapping between Proto field types and TensorFlow dtypes is straightforward. However, there are a few special cases:</source>
          <target state="translated">ほとんどの場合、Protoフィールド型とTensorFlow d型の間のマッピングは簡単です。しかし、いくつかの特殊なケースがあります。</target>
        </trans-unit>
        <trans-unit id="c23aedef4b8e055530a87dad6ff1b4b7682cb7a9" translate="yes" xml:space="preserve">
          <source>For the purposes of this function, a valid ordered sequence type is one which can be indexed, has a length, and has an equality operator.</source>
          <target state="translated">この関数の目的のために,有効な順序付きシーケンス型とは,インデックス化が可能で,長さがあり,等値演算子を持つものを指します.</target>
        </trans-unit>
        <trans-unit id="277400dd8bda8642b7e25a7ed51e2ae99e733ee3" translate="yes" xml:space="preserve">
          <source>For the replicas:</source>
          <target state="translated">レプリカのために。</target>
        </trans-unit>
        <trans-unit id="0a61ac4581750cc1861ea15aab1f318fa5e0885d" translate="yes" xml:space="preserve">
          <source>For the variables and &lt;code&gt;tf.MetaGraphDefs&lt;/code&gt;, a timestamped export directory below &lt;code&gt;export_dir_base&lt;/code&gt;, and writes a &lt;code&gt;SavedModel&lt;/code&gt; into it containing the &lt;code&gt;tf.MetaGraphDef&lt;/code&gt; for the given mode and its associated signatures.</source>
          <target state="translated">変数とについて &lt;code&gt;tf.MetaGraphDefs&lt;/code&gt; 、以下のタイムスタンプエクスポートディレクトリ &lt;code&gt;export_dir_base&lt;/code&gt; 、および書き込み &lt;code&gt;SavedModel&lt;/code&gt; を含むことに &lt;code&gt;tf.MetaGraphDef&lt;/code&gt; を与えられたモードと、それに関連する署名を。</target>
        </trans-unit>
        <trans-unit id="56c86fc9affcdc3686a615c6369da410c6e71b43" translate="yes" xml:space="preserve">
          <source>For this function to work, the stream must have a file descriptor that can be modified using &lt;code&gt;os.dup&lt;/code&gt; and &lt;code&gt;os.dup2&lt;/code&gt;, and the stream must support a &lt;code&gt;.flush()&lt;/code&gt; method. The default python sys.stdout and sys.stderr are examples of this. Note that this does not work in Colab or Jupyter notebooks, because those use alternate stdout streams.</source>
          <target state="translated">この関数が機能するには、ストリームに &lt;code&gt;os.dup&lt;/code&gt; および &lt;code&gt;os.dup2&lt;/code&gt; を使用して変更できるファイル記述子が必要であり、ストリームは &lt;code&gt;.flush()&lt;/code&gt; メソッドをサポートしている必要があります。デフォルトのpython sys.stdoutとsys.stderrはこの例です。ColabまたはJupyterノートブックでは代替stdoutストリームを使用するため、これは機能しないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="ac41fbab77768e9b6192dc00dfce9e8a5ab1aa29" translate="yes" xml:space="preserve">
          <source>For training and evaluation, the &lt;code&gt;train_op&lt;/code&gt; is stored in an extra collection, and loss, metrics, and predictions are included in a &lt;code&gt;SignatureDef&lt;/code&gt; for the mode in question.</source>
          <target state="translated">トレーニングと評価のために、 &lt;code&gt;train_op&lt;/code&gt; は追加のコレクションに格納され、損失、メトリック、および予測は、問題のモードの &lt;code&gt;SignatureDef&lt;/code&gt; に含まれています。</target>
        </trans-unit>
        <trans-unit id="8cb90deddea49c5d8ea800cc7d640f23ce709e57" translate="yes" xml:space="preserve">
          <source>For training, &lt;code&gt;model_fn&lt;/code&gt; gets per-core batch size; &lt;code&gt;input_fn&lt;/code&gt; may get per-core or per-host batch size depending on &lt;code&gt;per_host_input_for_training&lt;/code&gt; in &lt;code&gt;TPUConfig&lt;/code&gt; (See docstring for TPUConfig for details).</source>
          <target state="translated">トレーニングの場合、 &lt;code&gt;model_fn&lt;/code&gt; はコアごとのバッチサイズを取得します。 &lt;code&gt;input_fn&lt;/code&gt; は、 &lt;code&gt;per_host_input_for_training&lt;/code&gt; に応じて、コアごとまたはホストごとのバッチサイズを取得する場合があります（詳細については、 &lt;code&gt;TPUConfig&lt;/code&gt; の docstringを参照してください）。</target>
        </trans-unit>
        <trans-unit id="851eb999d65883da2e108c88c201473ef5f90761" translate="yes" xml:space="preserve">
          <source>For training, TensorFlow stores the tensors that are produced in the forward inference and are needed in back propagation. These tensors are a main source of memory consumption and often cause OOM errors when training on GPUs. When the flag swap_memory is true, we swap out these tensors from GPU to CPU. This for example allows us to train RNN models with very long sequences and large batches.</source>
          <target state="translated">トレーニングのために、TensorFlowは前方推論で生成されたテンソルと後方伝播で必要とされるテンソルを格納します。これらのテンソルはメモリ消費の主な原因であり、GPU上での学習時にはしばしばOOMエラーを引き起こす。フラグ swap_memory が真の場合、これらのテンソルを GPU から CPU にスワップアウトします。これにより、例えば、非常に長いシーケンスや大規模なバッチを持つRNNモデルを訓練することができます。</target>
        </trans-unit>
        <trans-unit id="686652c961bb116ce8005add3ae7ed8c5b4c585b" translate="yes" xml:space="preserve">
          <source>For training, sums losses of each head, calls &lt;code&gt;train_op_fn&lt;/code&gt; with this final loss.</source>
          <target state="translated">トレーニングの場合、各ヘッドの損失を合計し、この最終的な損失で &lt;code&gt;train_op_fn&lt;/code&gt; を呼び出します。</target>
        </trans-unit>
        <trans-unit id="c963d2deb9cad268120d3bd485103d985f5495cf" translate="yes" xml:space="preserve">
          <source>For tutorial on the options, see &lt;a href=&quot;https://github.com/tensorflow/tensorflow/tree/master/tensorflow/core/profiler/g3doc/options.md&quot;&gt;https://github.com/tensorflow/tensorflow/tree/master/tensorflow/core/profiler/g3doc/options.md&lt;/a&gt;</source>
          <target state="translated">オプションのチュートリアルについては、&lt;a href=&quot;https://github.com/tensorflow/tensorflow/tree/master/tensorflow/core/profiler/g3doc/options.md&quot;&gt;https：//github.com/tensorflow/tensorflow/tree/master/tensorflow/core/profiler/g3doc/options.mdを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="249a8fecba276e5537d5687430c7832f6a097905" translate="yes" xml:space="preserve">
          <source>For tutorial on the options, see https://github.com/tensorflow/tensorflow/tree/master/tensorflow/core/profiler/g3doc/options.md</source>
          <target state="translated">オプションのチュートリアルについては、https://github.com/tensorflow/tensorflow/tree/master/tensorflow/core/profiler/g3doc/options.md を参照してください。</target>
        </trans-unit>
        <trans-unit id="e0250883f7e36fe46e791c49d58341332e74601a" translate="yes" xml:space="preserve">
          <source>For usage example, please see: &lt;a href=&quot;https://www.tensorflow.org/guide/estimators#creating_estimators_from_keras_models&quot;&gt;Creating estimators from Keras Models&lt;/a&gt;.</source>
          <target state="translated">使用例については、「&lt;a href=&quot;https://www.tensorflow.org/guide/estimators#creating_estimators_from_keras_models&quot;&gt;Kerasモデルからの推定量の作成」&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="af78702967e9ea264023f8fbaf663f2a1adc42b5" translate="yes" xml:space="preserve">
          <source>For use with &lt;a href=&quot;ctc_loss&quot;&gt;&lt;code&gt;tf.nn.ctc_loss&lt;/code&gt;&lt;/a&gt; optional argument &lt;code&gt;unique&lt;/code&gt;: This op can be used to preprocess labels in input pipeline to for better speed/memory use computing the ctc loss on TPU.</source>
          <target state="translated">&lt;code&gt;unique&lt;/code&gt; &lt;a href=&quot;ctc_loss&quot;&gt; &lt;code&gt;tf.nn.ctc_loss&lt;/code&gt; &lt;/a&gt;オプション引数で使用する場合：この演算を使用して、入力パイプラインでラベルを前処理して、TPUでのctc損失の計算をより高速/メモリで使用できます。</target>
        </trans-unit>
        <trans-unit id="740b2ee4e4d8bf4808f11e53b605666e73b665e3" translate="yes" xml:space="preserve">
          <source>For variables placed in TPU device, which includes variables created inside TPUStrategy scope, outside compilation logic must not include variable read/write. For variables placed on host, which is the case when variables created via TPUEstimator, variable read/write is only allowed if the variable is not accessed by any other ops in the TPU computation. Variable read/write from outside compilation cluster is not visible from TPU computation and vice versa. Therefore, if outside compilation logic contains such host variables read/write ops and if the variables are accessed by TPU computation as well, then this may lead to deadlock.</source>
          <target state="translated">TPUStrategyスコープ内で作成された変数を含むTPUデバイスに配置された変数については、外部のコンパイルロジックでは変数の読み書きを含めてはいけません。ホスト上に置かれた変数(これはTPUEstimatorを介して作成された変数の場合)については、変数の読み書きは、その変数がTPU計算内の他のどのOPSからもアクセスされていない場合にのみ許可されます。コンパイルクラスタの外部からの変数の読み書きはTPU計算からは見えませんし、その逆も同様です。そのため、外部のコンパイルロジックにこのようなホスト変数の読み書き操作が含まれていて、TPU計算でも変数にアクセスされている場合、デッドロックにつながる可能性があります。</target>
        </trans-unit>
        <trans-unit id="34cca35024442a2daa7b2b0c02c66c45e14c3cb9" translate="yes" xml:space="preserve">
          <source>For x &amp;lt; 0, to avoid overflow in exp(-x), we reformulate the above</source>
          <target state="translated">x &amp;lt;0の場合、exp（-x）でのオーバーフローを回避するために、上記を再公式化します</target>
        </trans-unit>
        <trans-unit id="94cdf994803be6eb936ffe2768c49aa065f6d215" translate="yes" xml:space="preserve">
          <source>For x \in (-inf, inf) =&amp;gt; sigmoid(x) \in (0, 1)</source>
          <target state="translated">x \ in（-inf、inf）=&amp;gt; sigmoid（x）\ in（0、1）の場合</target>
        </trans-unit>
        <trans-unit id="8dfe58b9051d5a627bc446c6f93be3012efd4568" translate="yes" xml:space="preserve">
          <source>Forces summary writer to send any buffered data to storage.</source>
          <target state="translated">サマリーライターがバッファリングされたデータを強制的にストレージに送信します。</target>
        </trans-unit>
        <trans-unit id="d2dccd3937aceeadad57b5db753b0a63c00ec1a4" translate="yes" xml:space="preserve">
          <source>Format to use for saving sample images (if &lt;code&gt;save_to_dir&lt;/code&gt; is set).</source>
          <target state="translated">サンプル画像の保存に使用する形式（ &lt;code&gt;save_to_dir&lt;/code&gt; が設定されている場合）。</target>
        </trans-unit>
        <trans-unit id="f9f17deb03f3afa151a329975529588281686220" translate="yes" xml:space="preserve">
          <source>Formats a string template using a list of tensors, abbreviating tensors by only printing the first and last &lt;code&gt;summarize&lt;/code&gt; elements of each dimension (recursively). If formatting only one tensor into a template, the tensor does not have to be wrapped in a list.</source>
          <target state="translated">テンソルのリストを使用して文字列テンプレートをフォーマットし、各次元の最初と最後の &lt;code&gt;summarize&lt;/code&gt; 要素のみを再帰的に出力することでテンソルを省略します。1つのテンソルのみをテンプレートにフォーマットする場合、テンソルをリストでラップする必要はありません。</target>
        </trans-unit>
        <trans-unit id="45da02b6531e4ce47da0f14f7d9b458f2933c3d0" translate="yes" xml:space="preserve">
          <source>Formats a string template using a list of tensors, pretty-printing tensor summaries.</source>
          <target state="translated">テンソルのリストを使って文字列テンプレートをフォーマットし,テンソルの要約をきれいに印刷します.</target>
        </trans-unit>
        <trans-unit id="239f72546128721c29c8c3274ac9f9554ba33807" translate="yes" xml:space="preserve">
          <source>Formats a string template using a list of tensors.</source>
          <target state="translated">テンソルのリストを用いて文字列テンプレートをフォーマットします。</target>
        </trans-unit>
        <trans-unit id="aab407c990b5dd2317ab563c02f7afc3c37496b1" translate="yes" xml:space="preserve">
          <source>Formats both the test method name and the first line of its docstring.</source>
          <target state="translated">テストメソッド名とそのdocstringの最初の行の両方をフォーマットします。</target>
        </trans-unit>
        <trans-unit id="30411971a5c7c0c65716d7a2276bc0753edc1090" translate="yes" xml:space="preserve">
          <source>Formatting a multi-tensor template:</source>
          <target state="translated">マルチテンソルテンプレートの書式設定</target>
        </trans-unit>
        <trans-unit id="8e8e20d914a22b13e7830695a5885972e5f7dd9c" translate="yes" xml:space="preserve">
          <source>Formatting a single-tensor template:</source>
          <target state="translated">シングルテンソルテンプレートの書式設定</target>
        </trans-unit>
        <trans-unit id="8d843afdf2e57d596f25990cb1c437eb7019adc0" translate="yes" xml:space="preserve">
          <source>Formula for calculating sigmoid(x): &lt;code&gt;y = 1 / (1 + exp(-x))&lt;/code&gt;.</source>
          <target state="translated">シグモイド（x）の計算式： &lt;code&gt;y = 1 / (1 + exp(-x))&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7034cfa1d998a3b54fb5b3c3fa5754f76a68399a" translate="yes" xml:space="preserve">
          <source>Forward and inverse lookup pairs</source>
          <target state="translated">順方向と逆方向のルックアップペア</target>
        </trans-unit>
        <trans-unit id="c50d21ebeb5eb1221d5f8c11b87f7e8ba73b2e5f" translate="yes" xml:space="preserve">
          <source>Forward-compatibility refers to scenarios where the producer of a TensorFlow model (a GraphDef or SavedModel) is compiled against a version of the TensorFlow library newer than what the consumer was compiled against. The &quot;producer&quot; is typically a Python program that constructs and trains a model while the &quot;consumer&quot; is typically another program that loads and serves the model.</source>
          <target state="translated">順方向互換性とは、TensorFlow モデル(GraphDef または SavedModel)のプロデューサが、コンシューマがコンパイルされたものよりも新しいバージョンの TensorFlow ライブラリに対してコンパイルされた場合のシナリオを指します。プロデューサ」は通常、モデルを構築してトレーニングする Python プログラムであり、「コンシューマ」は通常、モデルをロードしてサービスを提供する別のプログラムです。</target>
        </trans-unit>
        <trans-unit id="d85bd4cd5990fd7543a86021751d93d42f1357b3" translate="yes" xml:space="preserve">
          <source>Forwarding the variables from the underlying optimizer.</source>
          <target state="translated">基礎となるオプティマイザから変数を転送します。</target>
        </trans-unit>
        <trans-unit id="210e7c1722192470315ce4c81eb0d4f008c48b3c" translate="yes" xml:space="preserve">
          <source>Forwards &lt;code&gt;data&lt;/code&gt; to the output port determined by &lt;code&gt;pred&lt;/code&gt;.</source>
          <target state="translated">転送し &lt;code&gt;data&lt;/code&gt; 出力ポートには、によって決定さ &lt;code&gt;pred&lt;/code&gt; は。</target>
        </trans-unit>
        <trans-unit id="ac10a67355b28b15b67e466f47812ba51acf7c5d" translate="yes" xml:space="preserve">
          <source>Forwards the &lt;code&gt;index&lt;/code&gt;th element of &lt;code&gt;inputs&lt;/code&gt; to &lt;code&gt;output&lt;/code&gt;.</source>
          <target state="translated">転送し &lt;code&gt;index&lt;/code&gt; 番目の要素 &lt;code&gt;inputs&lt;/code&gt; に &lt;code&gt;output&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6864a45f002f5e6954a15ab9ef9c1a8ff52d9034" translate="yes" xml:space="preserve">
          <source>Forwards the input to the output.</source>
          <target state="translated">入力を出力に転送します。</target>
        </trans-unit>
        <trans-unit id="c39cbdd42c402f4cd1012035895e06b8964ff7a6" translate="yes" xml:space="preserve">
          <source>Forwards the ref tensor &lt;code&gt;data&lt;/code&gt; to the output port determined by &lt;code&gt;pred&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pred&lt;/code&gt; によって決定された出力ポートに参照テンソル &lt;code&gt;data&lt;/code&gt; を転送します。</target>
        </trans-unit>
        <trans-unit id="f39668f24ce7de085f554eebee46e090e3244546" translate="yes" xml:space="preserve">
          <source>Forwards the value of an available tensor from &lt;code&gt;inputs&lt;/code&gt; to &lt;code&gt;output&lt;/code&gt;.</source>
          <target state="translated">利用可能なテンソルの値を &lt;code&gt;inputs&lt;/code&gt; から &lt;code&gt;output&lt;/code&gt; 転送します。</target>
        </trans-unit>
        <trans-unit id="6c89a9afa7f5354e4a63edd2e6c0d0b4901dd765" translate="yes" xml:space="preserve">
          <source>Four &lt;code&gt;Tensor&lt;/code&gt; objects of the same type as &lt;code&gt;x&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; と同じタイプの4つの &lt;code&gt;Tensor&lt;/code&gt; オブジェクト：</target>
        </trans-unit>
        <trans-unit id="0b64e890e12a034b5e89e178fdc9f76c74a27a3b" translate="yes" xml:space="preserve">
          <source>Fractional Max-Pooling: &lt;a href=&quot;https://arxiv.org/abs/1412.6071&quot;&gt;Graham, 2015&lt;/a&gt; (&lt;a href=&quot;https://arxiv.org/pdf/1412.6071.pdf&quot;&gt;pdf&lt;/a&gt;)</source>
          <target state="translated">Fractional Max-Pooling：&lt;a href=&quot;https://arxiv.org/abs/1412.6071&quot;&gt;Graham、2015&lt;/a&gt;（&lt;a href=&quot;https://arxiv.org/pdf/1412.6071.pdf&quot;&gt;pdf&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="40d7d8597b074e3ac7474d10a611c554ad7fa982" translate="yes" xml:space="preserve">
          <source>Fractional average pooling is similar to Fractional max pooling in the pooling region generation step. The only difference is that after pooling regions are generated, a mean operation is performed instead of a max operation in each pooling region.</source>
          <target state="translated">端数平均プーリングは、プーリング領域生成ステップでの端数maxプーリングに似ています。唯一の違いは、プーリング領域が生成された後、各プーリング領域でmax演算の代わりに平均演算が実行されることです。</target>
        </trans-unit>
        <trans-unit id="5041cde3f1a2533e4659d2586c2ffe569e1d7dcf" translate="yes" xml:space="preserve">
          <source>Fractional max pooling is slightly different than regular max pooling. In regular max pooling, you downsize an input set by taking the maximum value of smaller N x N subsections of the set (often 2x2), and try to reduce the set by a factor of N, where N is an integer. Fractional max pooling, as you might expect from the word &quot;fractional&quot;, means that the overall reduction ratio N does not have to be an integer.</source>
          <target state="translated">フラクショナル最大プーリングは、通常の最大プーリングとは若干異なります。通常の最大プーリングでは、入力集合のより小さい N x N 部分の最大値 (多くの場合 2x2)を取ることで入力集合を縮小し、N の係数で集合を縮小しようとします。フラクショナル最大プーリングは、「フラクショナル」という言葉から期待されるかもしれませんが、全体的な削減率Nが整数である必要がないことを意味します。</target>
        </trans-unit>
        <trans-unit id="cdbefc98aa39ba4bd6f437fe41a59ea0b199db5e" translate="yes" xml:space="preserve">
          <source>FractionalAvgPool</source>
          <target state="translated">FractionalAvgPool</target>
        </trans-unit>
        <trans-unit id="c9267ec6a51ddbb51448594d4c2287cf4c0d1df0" translate="yes" xml:space="preserve">
          <source>FractionalAvgPoolGrad</source>
          <target state="translated">FractionalAvgPoolGrad</target>
        </trans-unit>
        <trans-unit id="0892d35605cdd9bd30150ab584d51683167ecba4" translate="yes" xml:space="preserve">
          <source>FractionalMaxPool</source>
          <target state="translated">FractionalMaxPool</target>
        </trans-unit>
        <trans-unit id="ca1d900edc749abee96c0d0dfa0680048bb9a35a" translate="yes" xml:space="preserve">
          <source>FractionalMaxPoolGrad</source>
          <target state="translated">FractionalMaxPoolGrad</target>
        </trans-unit>
        <trans-unit id="461d49107b929069fa49ed11a5d92526668968dc" translate="yes" xml:space="preserve">
          <source>FresnelCos</source>
          <target state="translated">FresnelCos</target>
        </trans-unit>
        <trans-unit id="555de53bb5c086444e4833777660b765a262a6ca" translate="yes" xml:space="preserve">
          <source>FresnelSin</source>
          <target state="translated">FresnelSin</target>
        </trans-unit>
        <trans-unit id="266f4adbdcbde038a6a989395a6469a033656f5f" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;http://www.jmlr.org/papers/volume3/gers02a/gers02a.pdf&quot;&gt;Gers et al., 2002&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;http://www.jmlr.org/papers/volume3/gers02a/gers02a.pdf&quot;&gt;ジェールら、2002&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="bd28230ef13373337ce1949fe5af0d799f846337" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;http://www.jmlr.org/papers/volume3/gers02a/gers02a.pdf&quot;&gt;Gers et al.&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;http://www.jmlr.org/papers/volume3/gers02a/gers02a.pdf&quot;&gt;ガースら&lt;/a&gt;から。：</target>
        </trans-unit>
        <trans-unit id="f121e219c269ca1dd88e0e15be45795cfb78de9b" translate="yes" xml:space="preserve">
          <source>From the specified 'num_bits' in the quantized output type, it determines minimum and maximum representable quantized values.</source>
          <target state="translated">量子化された出力タイプで指定された 'num_bits' から、量子化された値の最小値と最大値を決定します。</target>
        </trans-unit>
        <trans-unit id="4cdba04d7a9eac83a97bc8f1d7ed1afaf3de99f7" translate="yes" xml:space="preserve">
          <source>From these definitions, we see that</source>
          <target state="translated">これらの定義から、次のことがわかります。</target>
        </trans-unit>
        <trans-unit id="18752fdccfa3eb0aaa2135e8d0734a1264755927" translate="yes" xml:space="preserve">
          <source>Frozen TensorFlow GraphDef.</source>
          <target state="translated">Frozen TensorFlow GraphDef.</target>
        </trans-unit>
        <trans-unit id="e2b99f0a6d43df651b198f8a6d97f7cd7519e800" translate="yes" xml:space="preserve">
          <source>Full file name path to the checkpoint file.</source>
          <target state="translated">チェックポイントファイルのフルファイル名のパス。</target>
        </trans-unit>
        <trans-unit id="90027b2158c0e9bc2fd007d047143a65b064bfe9" translate="yes" xml:space="preserve">
          <source>Full filepath of HDF5 file containing the tf.keras model.</source>
          <target state="translated">tf.kerasモデルを含むHDF5ファイルのフルファイルパス。</target>
        </trans-unit>
        <trans-unit id="4ce670e0e4234ef3e699470703e6f834ee6fc5d0" translate="yes" xml:space="preserve">
          <source>Full filepath of file containing frozen GraphDef.</source>
          <target state="translated">凍結されたGraphDefを含むファイルのフルファイルパス。</target>
        </trans-unit>
        <trans-unit id="1e14411de008f7791c1053dac7870cb082e304ab" translate="yes" xml:space="preserve">
          <source>Full filepath of folder to dump the graphs at various stages of processing GraphViz .dot files. Preferred over --output_format=GRAPHVIZ_DOT in order to keep the requirements of the output file. (default None)</source>
          <target state="translated">GraphVizの.dotファイルを処理する際にグラフをダンプするためのフォルダのフルファイルパス。出力ファイルの要件を維持するため、--output_format=GRAPHVIZ_DOTよりも優先されます。(デフォルトはなし)</target>
        </trans-unit>
        <trans-unit id="3aca6a2cadbde9796176b9f2bdc4ddaa5883a4b4" translate="yes" xml:space="preserve">
          <source>Fully-connected RNN where the output is to be fed back to input.</source>
          <target state="translated">出力が入力にフィードバックされる完全接続型RNN。</target>
        </trans-unit>
        <trans-unit id="04613c353330a3b030cda37163970b74de725fdc" translate="yes" xml:space="preserve">
          <source>Function builder for a dnn logit_fn.</source>
          <target state="translated">dnn logit_fn の関数ビルダ。</target>
        </trans-unit>
        <trans-unit id="80bb380683226de01695aa870f90690f020ccf39" translate="yes" xml:space="preserve">
          <source>Function builder for a linear logit_fn.</source>
          <target state="translated">線形 logit_fn の関数ビルダ。</target>
        </trans-unit>
        <trans-unit id="961134f334d4e3d099fd3b88ec79f66049e02609" translate="yes" xml:space="preserve">
          <source>Function corresponding to the input string or input function.</source>
          <target state="translated">入力文字列または入力関数に対応する関数。</target>
        </trans-unit>
        <trans-unit id="84942f5d7faa1848468aa47bc1832cb4ffceb2fa" translate="yes" xml:space="preserve">
          <source>Function for &lt;code&gt;decode_bmp&lt;/code&gt;, &lt;code&gt;decode_gif&lt;/code&gt;, &lt;code&gt;decode_jpeg&lt;/code&gt;, and &lt;code&gt;decode_png&lt;/code&gt;.</source>
          <target state="translated">以下のための機能 &lt;code&gt;decode_bmp&lt;/code&gt; 、 &lt;code&gt;decode_gif&lt;/code&gt; 、 &lt;code&gt;decode_jpeg&lt;/code&gt; 、および &lt;code&gt;decode_png&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="572d2bb02e89c8f3847c21f4dc5279a374c3627b" translate="yes" xml:space="preserve">
          <source>Function object.</source>
          <target state="translated">関数オブジェクトです。</target>
        </trans-unit>
        <trans-unit id="b7e2223c959cab59ba23fe92444da8ee0470dc6a" translate="yes" xml:space="preserve">
          <source>Function or string</source>
          <target state="translated">関数または文字列</target>
        </trans-unit>
        <trans-unit id="3b4e76300f7233d9787f12ee14670f6240ff6bba" translate="yes" xml:space="preserve">
          <source>Function that joins arguments from threads that are given as PerReplica. It accepts &lt;a href=&quot;strategy&quot;&gt;&lt;code&gt;tf.distribute.Strategy&lt;/code&gt;&lt;/a&gt; object as the first argument.</source>
          <target state="translated">PerReplicaとして指定されたスレッドからの引数を結合する関数。最初の引数として&lt;a href=&quot;strategy&quot;&gt; &lt;code&gt;tf.distribute.Strategy&lt;/code&gt; &lt;/a&gt;オブジェクトを受け入れます。</target>
        </trans-unit>
        <trans-unit id="3888f1a7f7ad2a4d8e9abf43dddc4f56b91e55d9" translate="yes" xml:space="preserve">
          <source>Function that maps (input, num_spatial_dims, padding) -&amp;gt; output</source>
          <target state="translated">マップする関数（入力、num_spatial_dims、パディング）-&amp;gt;出力</target>
        </trans-unit>
        <trans-unit id="29319f13ab18651cfb7537f6a5eddbd79ca1798f" translate="yes" xml:space="preserve">
          <source>Function that takes a scalar loss &lt;code&gt;Tensor&lt;/code&gt; and returns &lt;code&gt;train_op&lt;/code&gt;. Used if &lt;code&gt;optimizer&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">スカラー損失 &lt;code&gt;Tensor&lt;/code&gt; を取り、 &lt;code&gt;train_op&lt;/code&gt; を返す関数。 &lt;code&gt;optimizer&lt;/code&gt; が &lt;code&gt;None&lt;/code&gt; の場合に使用されます。</target>
        </trans-unit>
        <trans-unit id="b91e979c56b6a5a95309b72332456efabd23f242" translate="yes" xml:space="preserve">
          <source>Function that takes a scalar loss &lt;code&gt;Tensor&lt;/code&gt; and returns an op to optimize the model with the loss in TRAIN mode. Used if &lt;code&gt;optimizer&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;. Exactly one of &lt;code&gt;train_op_fn&lt;/code&gt; and &lt;code&gt;optimizer&lt;/code&gt; must be set in TRAIN mode. By default, it is &lt;code&gt;None&lt;/code&gt; in other modes. If you want to optimize loss yourself, you can pass &lt;code&gt;lambda _: tf.no_op()&lt;/code&gt; and then use &lt;a href=&quot;estimatorspec#loss&quot;&gt;&lt;code&gt;EstimatorSpec.loss&lt;/code&gt;&lt;/a&gt; to compute and apply gradients.</source>
          <target state="translated">スカラー損失 &lt;code&gt;Tensor&lt;/code&gt; を取り、TRAINモードでの損失でモデルを最適化するためのopを返す関数。 &lt;code&gt;optimizer&lt;/code&gt; が &lt;code&gt;None&lt;/code&gt; の場合に使用されます。 &lt;code&gt;train_op_fn&lt;/code&gt; と &lt;code&gt;optimizer&lt;/code&gt; の正確に1つをTRAINモードに設定する必要があります。デフォルトでは、他のモードでは「 &lt;code&gt;None&lt;/code&gt; です。自分で損失を最適化したい場合は、 &lt;code&gt;lambda _: tf.no_op()&lt;/code&gt; を渡してから、&lt;a href=&quot;estimatorspec#loss&quot;&gt; &lt;code&gt;EstimatorSpec.loss&lt;/code&gt; &lt;/a&gt;を使用して勾配を計算して適用できます。</target>
        </trans-unit>
        <trans-unit id="8c8c9c9afc68cd4e3a21d1d0883f3c94b166cd76" translate="yes" xml:space="preserve">
          <source>Function to be called and extra positional args.</source>
          <target state="translated">呼び出される関数と追加の位置引数。</target>
        </trans-unit>
        <trans-unit id="a9668555814ce219a8e6ead49b464c78c9faea18" translate="yes" xml:space="preserve">
          <source>Function to be called, or None to return a context.</source>
          <target state="translated">呼び出される関数、またはコンテキストを返す場合は None。</target>
        </trans-unit>
        <trans-unit id="f38de77bb6b57ed6e07c1cd26484aa1832921c19" translate="yes" xml:space="preserve">
          <source>Function to call. Should take the variable as the first argument.</source>
          <target state="translated">呼び出す関数。変数を第一引数に取る必要があります。</target>
        </trans-unit>
        <trans-unit id="b46ccb902892f13f107bf66a75f9bf8327cbae4d" translate="yes" xml:space="preserve">
          <source>Function, that has signature of ()-&amp;gt;(dict of &lt;code&gt;features&lt;/code&gt;, &lt;code&gt;target&lt;/code&gt;)</source>
          <target state="translated">（）-&amp;gt;（ &lt;code&gt;features&lt;/code&gt; dict 、 &lt;code&gt;target&lt;/code&gt; ）のシグネチャを持つ関数</target>
        </trans-unit>
        <trans-unit id="52f2894799ccb50c7b33084828e4f3851ea4df75" translate="yes" xml:space="preserve">
          <source>Function, that has signature of ()-&amp;gt;(dict of &lt;code&gt;features&lt;/code&gt;, &lt;code&gt;targets&lt;/code&gt;)</source>
          <target state="translated">（）-&amp;gt;（ &lt;code&gt;features&lt;/code&gt; ディクト、 &lt;code&gt;targets&lt;/code&gt; ）のシグネチャを持つ関数</target>
        </trans-unit>
        <trans-unit id="95e988de9fb50a5cd88d6853048b67ed3a399d7b" translate="yes" xml:space="preserve">
          <source>Function. The function created by this method should accept a &lt;a href=&quot;../../data/iterator&quot;&gt;&lt;code&gt;tf.data.Iterator&lt;/code&gt;&lt;/a&gt;, and return a &lt;code&gt;dict&lt;/code&gt; containing values that will be passed to &lt;code&gt;tf.keras.Callbacks.on_test_batch_end&lt;/code&gt;.</source>
          <target state="translated">関数。この方法で作成された関数は、受け入れるべき&lt;a href=&quot;../../data/iterator&quot;&gt; &lt;code&gt;tf.data.Iterator&lt;/code&gt; を&lt;/a&gt;、と返す &lt;code&gt;dict&lt;/code&gt; に渡される値含む &lt;code&gt;tf.keras.Callbacks.on_test_batch_end&lt;/code&gt; を。</target>
        </trans-unit>
        <trans-unit id="327af3c4f94777b37a0d2449a5895e659cad6e23" translate="yes" xml:space="preserve">
          <source>Function. The function created by this method should accept a &lt;a href=&quot;../../data/iterator&quot;&gt;&lt;code&gt;tf.data.Iterator&lt;/code&gt;&lt;/a&gt;, and return a &lt;code&gt;dict&lt;/code&gt; containing values that will be passed to &lt;code&gt;tf.keras.Callbacks.on_train_batch_end&lt;/code&gt;, such as &lt;code&gt;{'loss': 0.2, 'accuracy': 0.7}&lt;/code&gt;.</source>
          <target state="translated">関数。このメソッドによって作成された関数は、&lt;a href=&quot;../../data/iterator&quot;&gt; &lt;code&gt;tf.data.Iterator&lt;/code&gt; &lt;/a&gt;を受け入れ、 &lt;code&gt;{'loss': 0.2, 'accuracy': 0.7}&lt;/code&gt; などの &lt;code&gt;tf.keras.Callbacks.on_train_batch_end&lt;/code&gt; に渡される値を含む &lt;code&gt;dict&lt;/code&gt; を返す必要があります。</target>
        </trans-unit>
        <trans-unit id="656c120741d962b4b4cb42d15057a960a5358b5f" translate="yes" xml:space="preserve">
          <source>Function. The function created by this method should accept a &lt;a href=&quot;../../data/iterator&quot;&gt;&lt;code&gt;tf.data.Iterator&lt;/code&gt;&lt;/a&gt;, and return the outputs of the &lt;code&gt;Model&lt;/code&gt;.</source>
          <target state="translated">関数。このメソッドによって作成された関数は、&lt;a href=&quot;../../data/iterator&quot;&gt; &lt;code&gt;tf.data.Iterator&lt;/code&gt; &lt;/a&gt;を受け入れ、 &lt;code&gt;Model&lt;/code&gt; 出力を返す必要があります。</target>
        </trans-unit>
        <trans-unit id="41d1aa0470499deda211a11de3b081c451856666" translate="yes" xml:space="preserve">
          <source>Function. The function created by this method should accept a &lt;a href=&quot;../data/iterator&quot;&gt;&lt;code&gt;tf.data.Iterator&lt;/code&gt;&lt;/a&gt;, and return a &lt;code&gt;dict&lt;/code&gt; containing values that will be passed to &lt;code&gt;tf.keras.Callbacks.on_test_batch_end&lt;/code&gt;.</source>
          <target state="translated">関数。この方法で作成された関数は、受け入れるべき&lt;a href=&quot;../data/iterator&quot;&gt; &lt;code&gt;tf.data.Iterator&lt;/code&gt; を&lt;/a&gt;、と返す &lt;code&gt;dict&lt;/code&gt; に渡される値含む &lt;code&gt;tf.keras.Callbacks.on_test_batch_end&lt;/code&gt; を。</target>
        </trans-unit>
        <trans-unit id="3d2eb314244e720ce4ba2da84d3ecfb8e0c92f66" translate="yes" xml:space="preserve">
          <source>Function. The function created by this method should accept a &lt;a href=&quot;../data/iterator&quot;&gt;&lt;code&gt;tf.data.Iterator&lt;/code&gt;&lt;/a&gt;, and return a &lt;code&gt;dict&lt;/code&gt; containing values that will be passed to &lt;code&gt;tf.keras.Callbacks.on_train_batch_end&lt;/code&gt;, such as &lt;code&gt;{'loss': 0.2, 'accuracy': 0.7}&lt;/code&gt;.</source>
          <target state="translated">関数。このメソッドによって作成された関数は、&lt;a href=&quot;../data/iterator&quot;&gt; &lt;code&gt;tf.data.Iterator&lt;/code&gt; &lt;/a&gt;を受け入れ、 &lt;code&gt;{'loss': 0.2, 'accuracy': 0.7}&lt;/code&gt; などの &lt;code&gt;tf.keras.Callbacks.on_train_batch_end&lt;/code&gt; に渡される値を含む &lt;code&gt;dict&lt;/code&gt; を返す必要があります。</target>
        </trans-unit>
        <trans-unit id="a8df0a9af5b857d1cf68b6c139f016618d2511fd" translate="yes" xml:space="preserve">
          <source>Function. The function created by this method should accept a &lt;a href=&quot;../data/iterator&quot;&gt;&lt;code&gt;tf.data.Iterator&lt;/code&gt;&lt;/a&gt;, and return the outputs of the &lt;code&gt;Model&lt;/code&gt;.</source>
          <target state="translated">関数。このメソッドによって作成された関数は、&lt;a href=&quot;../data/iterator&quot;&gt; &lt;code&gt;tf.data.Iterator&lt;/code&gt; &lt;/a&gt;を受け入れ、 &lt;code&gt;Model&lt;/code&gt; 出力を返す必要があります。</target>
        </trans-unit>
        <trans-unit id="fd4d97811c7aafbd87d5d51e0c6c137634e57d76" translate="yes" xml:space="preserve">
          <source>Functional interface for the batch normalization layer from_config(Ioffe et al., 2015). (deprecated)</source>
          <target state="translated">バッチ正規化レイヤのための機能インタフェース from_config(Ioffe et al.,2015)。(非推奨)</target>
        </trans-unit>
        <trans-unit id="88fcd90125004d28567d342c9f3165809fb40cbc" translate="yes" xml:space="preserve">
          <source>Functional interface for the batch normalization layer. (deprecated)</source>
          <target state="translated">バッチ正規化レイヤのための機能的なインタフェース。(廃止予定)</target>
        </trans-unit>
        <trans-unit id="3008e201e4f95d586e2d708853592636025c56ec" translate="yes" xml:space="preserve">
          <source>Functional interface for the depthwise separable 1D convolution layer. (deprecated)</source>
          <target state="translated">深さ方向に分離可能な1次元畳み込み層のための機能インタフェース.(非推奨)</target>
        </trans-unit>
        <trans-unit id="843524e6eccb65e6f3f97379f7de26c2a2f2da67" translate="yes" xml:space="preserve">
          <source>Functional interface for the depthwise separable 2D convolution layer. (deprecated)</source>
          <target state="translated">深さ方向に分離可能な2次元畳み込み層のための機能インタフェース.(非推奨)</target>
        </trans-unit>
        <trans-unit id="55f27b3100890ca22fc05334143ec1799a0365f4" translate="yes" xml:space="preserve">
          <source>Functional interface for transposed 2D convolution layer. (deprecated)</source>
          <target state="translated">転置された2次元畳み込み層のための機能的なインタフェース.(非推奨)</target>
        </trans-unit>
        <trans-unit id="cc0e25ff898bc600b9c3b618d6944b678eac556b" translate="yes" xml:space="preserve">
          <source>Functional interface for transposed 3D convolution layer. (deprecated)</source>
          <target state="translated">転置3次元畳み込み層のための機能的インタフェース.(非推奨)</target>
        </trans-unit>
        <trans-unit id="2b961dea1dc0c60ddf9a2c8e9d090f6f7d082483" translate="yes" xml:space="preserve">
          <source>Functions</source>
          <target state="translated">Functions</target>
        </trans-unit>
        <trans-unit id="abc7c3058aaf16961ae99141267b62b102b7362a" translate="yes" xml:space="preserve">
          <source>Functions are converted into new functions with converted code.</source>
          <target state="translated">関数は変換されたコードで新しい関数に変換されます。</target>
        </trans-unit>
        <trans-unit id="7f53929fbbbf3598a8477b3e21c530968bf2b1e4" translate="yes" xml:space="preserve">
          <source>Functions used to extract and analyze stacks. Faster than Python libs.</source>
          <target state="translated">スタックの抽出や解析に使われる関数。Python libsよりも高速です。</target>
        </trans-unit>
        <trans-unit id="1088f52ee06b617e019df677ae2d985ea8367ee8" translate="yes" xml:space="preserve">
          <source>Further, each thread starts with an empty variable scope. So if you wish to preserve name prefixes from a scope from the main thread, you should capture the main thread's scope and re-enter it in each thread. For e.g.</source>
          <target state="translated">さらに、各スレッドは空の変数スコープから始まります。そのため、メインスレッドからのスコープから名前の接頭辞を保存したい場合は、メインスレッドのスコープをキャプチャして各スレッドに再入力する必要があります。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="17d43e06d288fdecd9a150c3bd7e9213832b2bda" translate="yes" xml:space="preserve">
          <source>Furthermore, &lt;code&gt;fn&lt;/code&gt; may emit a different structure than its input. For example, &lt;code&gt;fn&lt;/code&gt; may look like: &lt;code&gt;fn = lambda t1: return (t1 + 1, t1 - 1)&lt;/code&gt;. In this case, the &lt;code&gt;dtype&lt;/code&gt; parameter is not optional: &lt;code&gt;dtype&lt;/code&gt; must be a type or (possibly nested) tuple of types matching the output of &lt;code&gt;fn&lt;/code&gt;.</source>
          <target state="translated">さらに、 &lt;code&gt;fn&lt;/code&gt; はその入力とは異なる構造を出力する場合があります。たとえば、 &lt;code&gt;fn&lt;/code&gt; は次のようになります &lt;code&gt;fn = lambda t1: return (t1 + 1, t1 - 1)&lt;/code&gt; 。この場合、 &lt;code&gt;dtype&lt;/code&gt; パラメーターはオプションではありません &lt;code&gt;dtype&lt;/code&gt; は、 &lt;code&gt;fn&lt;/code&gt; の出力と一致するタイプまたは（場合によってはネストされた）タプルのタイプでなければなりません。</target>
        </trans-unit>
        <trans-unit id="8eca057ed1ad79a6c34545db8e733823a73dfbda" translate="yes" xml:space="preserve">
          <source>Furthermore, each component vector of &lt;code&gt;permutation&lt;/code&gt; must be of length &lt;code&gt;N&lt;/code&gt;, containing each of the integers {0, 1, ..., N - 1} exactly once, where &lt;code&gt;N&lt;/code&gt; is the number of rows of each component of the sparse matrix.</source>
          <target state="translated">さらに、 &lt;code&gt;permutation&lt;/code&gt; 各コンポーネントベクトルは長さ &lt;code&gt;N&lt;/code&gt; でなければならず、整数{0、1、...、N -1}のそれぞれを1回だけ含みます。ここで、 &lt;code&gt;N&lt;/code&gt; はスパース行列の各コンポーネントの行数です。</target>
        </trans-unit>
        <trans-unit id="cac9ee53753b3ccba19a58872a949a03e0ed0a6d" translate="yes" xml:space="preserve">
          <source>Fused implementation of &lt;code&gt;map&lt;/code&gt; and &lt;code&gt;batch&lt;/code&gt;. (deprecated)</source>
          <target state="translated">&lt;code&gt;map&lt;/code&gt; と &lt;code&gt;batch&lt;/code&gt; 実装の融合。（非推奨）</target>
        </trans-unit>
        <trans-unit id="8fa84725122a287d0cb8f17bda5fbaa9cfd37bea" translate="yes" xml:space="preserve">
          <source>FusedBatchNorm</source>
          <target state="translated">FusedBatchNorm</target>
        </trans-unit>
        <trans-unit id="f7b8da7deea4d0087270a594c3304c5206d3bf77" translate="yes" xml:space="preserve">
          <source>FusedBatchNormGrad</source>
          <target state="translated">FusedBatchNormGrad</target>
        </trans-unit>
        <trans-unit id="ff54a465b3ddf6aad5d7277a2960454bcdf5c7dd" translate="yes" xml:space="preserve">
          <source>FusedBatchNormGradV2</source>
          <target state="translated">FusedBatchNormGradV2</target>
        </trans-unit>
        <trans-unit id="efa2db95230d193fc0b2d1a7dbc258c4dc871a3a" translate="yes" xml:space="preserve">
          <source>FusedBatchNormGradV3</source>
          <target state="translated">FusedBatchNormGradV3</target>
        </trans-unit>
        <trans-unit id="2e082980a698cbd30bfdcc577a828bee3ef142c1" translate="yes" xml:space="preserve">
          <source>FusedBatchNormV2</source>
          <target state="translated">FusedBatchNormV2</target>
        </trans-unit>
        <trans-unit id="d4b44881964c817e28926bb8505ed4b17e43045a" translate="yes" xml:space="preserve">
          <source>FusedBatchNormV3</source>
          <target state="translated">FusedBatchNormV3</target>
        </trans-unit>
        <trans-unit id="9a5938911daebb6a70c3382e959fd759e820951a" translate="yes" xml:space="preserve">
          <source>FusedPadConv2D</source>
          <target state="translated">FusedPadConv2D</target>
        </trans-unit>
        <trans-unit id="a7fee6ae8ac515a2dfd04f006bf80f40a0d24a92" translate="yes" xml:space="preserve">
          <source>FusedResizeAndPadConv2D</source>
          <target state="translated">FusedResizeAndPadConv2D</target>
        </trans-unit>
        <trans-unit id="754a365f8fd6b9ceb366bc46267e7e7fae2e01b8" translate="yes" xml:space="preserve">
          <source>Future major versions of TensorFlow will allow gradients to flow into the labels input on backprop by default.</source>
          <target state="translated">TensorFlowの将来のメジャーバージョンでは、デフォルトでBackpropに入力されたラベルにグラデーションを流すことができるようになります。</target>
        </trans-unit>
        <trans-unit id="7dbebb53731d118027dc401234e5639569fa8c60" translate="yes" xml:space="preserve">
          <source>Fuzz factor.</source>
          <target state="translated">ファズファクター。</target>
        </trans-unit>
        <trans-unit id="72267a6e30d52b94f9b577c3333196adb57b047d" translate="yes" xml:space="preserve">
          <source>GCE Credentials. If None, then we use default credentials from the oauth2client</source>
          <target state="translated">GCE の資格情報。Noneの場合は、oauth2clientのデフォルトの資格情報を使用します。</target>
        </trans-unit>
        <trans-unit id="8ad91e9a8f5cd85998e81a80a35e120f1cc77d99" translate="yes" xml:space="preserve">
          <source>GCE Credentials. If nothing is specified, this defaults to GoogleCredentials.get_application_default().</source>
          <target state="translated">GCE クレデンシャル。何も指定しない場合は、GoogleCredentials.get_application_default()がデフォルトとなります。</target>
        </trans-unit>
        <trans-unit id="51e841ad3b27b555240bd3208409784776b78d91" translate="yes" xml:space="preserve">
          <source>GIF images with frame or transparency compression are not supported. On Linux and MacOS systems, convert animated GIFs from compressed to uncompressed by running:</source>
          <target state="translated">フレーム圧縮や透明度圧縮のある GIF 画像はサポートされていません。Linux および MacOS システムでは、アニメーション GIF を実行して圧縮から非圧縮に変換します。</target>
        </trans-unit>
        <trans-unit id="9bcfc99bed88388ab08e19e25125b8df695b2ec4" translate="yes" xml:space="preserve">
          <source>GNU style allows mixing of flag and non-flag arguments. See &lt;a href=&quot;http://docs.python.org/library/getopt.html#getopt.gnu_getopt&quot;&gt;http://docs.python.org/library/getopt.html#getopt.gnu_getopt&lt;/a&gt;</source>
          <target state="translated">GNUスタイルでは、フラグ引数と非フラグ引数を混在させることができます。&lt;a href=&quot;http://docs.python.org/library/getopt.html#getopt.gnu_getopt&quot;&gt;http://docs.python.org/library/getopt.html#getopt.gnu_getoptを&lt;/a&gt;参照してください</target>
        </trans-unit>
        <trans-unit id="bc2cb7021c13ea83cc3e049d7402c76b692e0416" translate="yes" xml:space="preserve">
          <source>GNU style allows mixing of flag and non-flag arguments. See http://docs.python.org/library/getopt.html#getopt.gnu_getopt</source>
          <target state="translated">GNUスタイルでは、フラグ引数と非フラグ引数を混在させることができます。http://docs.python.org/library/getopt.html#getopt.gnu_getopt を参照してください。</target>
        </trans-unit>
        <trans-unit id="f972014286a8ef98413380743e0166a16182293b" translate="yes" xml:space="preserve">
          <source>GRU convention (whether to apply reset gate after or before matrix multiplication). False = &quot;before&quot; (default), True = &quot;after&quot; (CuDNN compatible).</source>
          <target state="translated">GRU 規約(リセットゲートを行列乗算の後に適用するか、乗算の前に適用するか)。False=&quot;before&quot;(デフォルト)、True=&quot;after&quot;(CuDNN互換)。</target>
        </trans-unit>
        <trans-unit id="f30369db80b8df66e066857b52ef066913f216c1" translate="yes" xml:space="preserve">
          <source>GRU convention (whether to apply reset gate after or before matrix multiplication). False = &quot;before&quot;, True = &quot;after&quot; (default and CuDNN compatible).</source>
          <target state="translated">GRU 規約(リセットゲートを行列乗算の後に適用するか、乗算の前に適用するか)。False=&quot;before&quot;、True=&quot;after&quot;(デフォルトでCuDNN互換)。</target>
        </trans-unit>
        <trans-unit id="f27a3272df11e6421ae7abecb1025fb3c735f83f" translate="yes" xml:space="preserve">
          <source>GRUBlockCell</source>
          <target state="translated">GRUBlockCell</target>
        </trans-unit>
        <trans-unit id="8fb826d8ab1769785d7dd590b317670658d293c0" translate="yes" xml:space="preserve">
          <source>GRUBlockCellGrad</source>
          <target state="translated">GRUBlockCellGrad</target>
        </trans-unit>
        <trans-unit id="3c8a873ea949d50ad1aac033a294a578fd5c4e69" translate="yes" xml:space="preserve">
          <source>Gamma distribution.</source>
          <target state="translated">ガンマ分布。</target>
        </trans-unit>
        <trans-unit id="9f031510b482abd8e720846e8669696f7e91ec56" translate="yes" xml:space="preserve">
          <source>Gated Recurrent Unit - Cho et al. 2014.</source>
          <target state="translated">ゲーテッドリカレントユニット-Cho et al.</target>
        </trans-unit>
        <trans-unit id="69e499dfe689408aae1f951c32b8c1bbc6c2faf0" translate="yes" xml:space="preserve">
          <source>Gated Recurrent Unit cell (cf.</source>
          <target state="translated">ゲーテッドリカレントユニットセル(cf.</target>
        </trans-unit>
        <trans-unit id="705812755333cca60e8bb82127bf5e243f85b469" translate="yes" xml:space="preserve">
          <source>Gated Recurrent Unit cell.</source>
          <target state="translated">ゲーテッド・リカレント・ユニット・セル。</target>
        </trans-unit>
        <trans-unit id="d85fb4eb9b5275137b92e9c14d3dd2b6f13641af" translate="yes" xml:space="preserve">
          <source>Gather</source>
          <target state="translated">Gather</target>
        </trans-unit>
        <trans-unit id="60f8851e1dff47acde3e681a835a618b6909d153" translate="yes" xml:space="preserve">
          <source>Gather ragged slices from &lt;code&gt;params&lt;/code&gt; axis &lt;code&gt;0&lt;/code&gt; according to &lt;code&gt;indices&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;indices&lt;/code&gt; に従って、 &lt;code&gt;params&lt;/code&gt; 軸 &lt;code&gt;0&lt;/code&gt; から不規則なスライスを収集します。</target>
        </trans-unit>
        <trans-unit id="8b3a55dbaf071c80cf233d7df7f2695129eb5aa3" translate="yes" xml:space="preserve">
          <source>Gather slices from &lt;code&gt;params&lt;/code&gt; according to &lt;code&gt;indices&lt;/code&gt;.</source>
          <target state="translated">スライスを集める &lt;code&gt;params&lt;/code&gt; に従って &lt;code&gt;indices&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c659ab9d2af864152ee3bccc51bb3c0d68f7ab80" translate="yes" xml:space="preserve">
          <source>Gather slices from &lt;code&gt;params&lt;/code&gt; axis &lt;code&gt;axis&lt;/code&gt; according to &lt;code&gt;indices&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;indices&lt;/code&gt; に従って &lt;code&gt;params&lt;/code&gt; 軸 &lt;code&gt;axis&lt;/code&gt; からスライスを収集します。</target>
        </trans-unit>
        <trans-unit id="3d20e4a3a201cb2fbb73307001cac40611d72da6" translate="yes" xml:space="preserve">
          <source>Gather slices from &lt;code&gt;params&lt;/code&gt; into a Tensor with shape specified by &lt;code&gt;indices&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;params&lt;/code&gt; からスライスを収集し、 &lt;code&gt;indices&lt;/code&gt; で指定された形状のTensorに入れます。</target>
        </trans-unit>
        <trans-unit id="299d0ae5001a60c54f445823747df39bdc8fe265" translate="yes" xml:space="preserve">
          <source>Gather slices from params according to indices with leading batch dims. (deprecated)</source>
          <target state="translated">パラムからスライスを、先行するバッチのディムを持つインデックスに従って収集します。(廃止予定)</target>
        </trans-unit>
        <trans-unit id="f262790bfae9447f613388f0f2dfc06ee3e6e9af" translate="yes" xml:space="preserve">
          <source>Gather slices from params axis &lt;code&gt;axis&lt;/code&gt; according to &lt;code&gt;indices&lt;/code&gt;. &lt;code&gt;indices&lt;/code&gt; must be an integer tensor of any dimension (usually 0-D or 1-D).</source>
          <target state="translated">&lt;code&gt;indices&lt;/code&gt; に従って、params軸 &lt;code&gt;axis&lt;/code&gt; からスライスを収集します。 &lt;code&gt;indices&lt;/code&gt; は任意の次元（通常0-Dまたは1-D）の整数テンソルでなければなりません。</target>
        </trans-unit>
        <trans-unit id="9f385f50f48df2546a7fa47ac7842fb6cb974b02" translate="yes" xml:space="preserve">
          <source>Gather slices from params axis &lt;code&gt;axis&lt;/code&gt; according to indices.</source>
          <target state="translated">インデックスに従って、params軸 &lt;code&gt;axis&lt;/code&gt; からスライスを収集します。</target>
        </trans-unit>
        <trans-unit id="e17db4db1be26624736cd7163c7e0a82b1dfd230" translate="yes" xml:space="preserve">
          <source>Gather slices from params axis axis according to indices.</source>
          <target state="translated">params軸からインデックスに応じてスライスを収集します。</target>
        </trans-unit>
        <trans-unit id="73d587e4f9866c119bef7eb8951aad10a8ad7680" translate="yes" xml:space="preserve">
          <source>Gather slices from the variable pointed to by &lt;code&gt;resource&lt;/code&gt; according to &lt;code&gt;indices&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;indices&lt;/code&gt; に従って、 &lt;code&gt;resource&lt;/code&gt; 指す変数からスライスを収集します。</target>
        </trans-unit>
        <trans-unit id="9bc621ab1a08f4a178453d70596dcee1791211d7" translate="yes" xml:space="preserve">
          <source>Gather specific elements from the TensorArray into output &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">TensorArrayから特定の要素を出力 &lt;code&gt;value&lt;/code&gt; 収集します。</target>
        </trans-unit>
        <trans-unit id="d75d7d6f79f6c643b60649fcc6961cd4aaf7d3ff" translate="yes" xml:space="preserve">
          <source>GatherNd</source>
          <target state="translated">GatherNd</target>
        </trans-unit>
        <trans-unit id="9bb2e60bbbfd1cff13478f3217fccff50b488e00" translate="yes" xml:space="preserve">
          <source>GatherV2</source>
          <target state="translated">GatherV2</target>
        </trans-unit>
        <trans-unit id="1b380773b6f24a5afe663b7e22de6423bb935598" translate="yes" xml:space="preserve">
          <source>Gating Gradients</source>
          <target state="translated">ゲーティング勾配</target>
        </trans-unit>
        <trans-unit id="44813df257901f45ff9b654c8ba3ddd39d5df9b6" translate="yes" xml:space="preserve">
          <source>Gaussian: &lt;code&gt;K(x, y) == exp(- square(x - y) / (2 * square(scale)))&lt;/code&gt;</source>
          <target state="translated">ガウス： &lt;code&gt;K(x, y) == exp(- square(x - y) / (2 * square(scale)))&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f72dabec415cca8805069ec0515ea199976c6048" translate="yes" xml:space="preserve">
          <source>General case:</source>
          <target state="translated">一般的なケース。</target>
        </trans-unit>
        <trans-unit id="6368188d3687992a62f99d6b7334f52aaac43948" translate="yes" xml:space="preserve">
          <source>Generalization of &lt;a href=&quot;scatter_update&quot;&gt;&lt;code&gt;tf.compat.v1.scatter_update&lt;/code&gt;&lt;/a&gt; to axis different than 0. (deprecated)</source>
          <target state="translated">0以外の軸への&lt;a href=&quot;scatter_update&quot;&gt; &lt;code&gt;tf.compat.v1.scatter_update&lt;/code&gt; の&lt;/a&gt;一般化。（非推奨）</target>
        </trans-unit>
        <trans-unit id="eb11ae4a716352e80393f10cd2fbf3c5ef996fc6" translate="yes" xml:space="preserve">
          <source>Generally a single example in training data is described with FeatureColumns. At the first layer of the model, this column oriented data should be converted to a single &lt;code&gt;Tensor&lt;/code&gt;.</source>
          <target state="translated">一般に、トレーニングデータの1つの例は、FeatureColumnsで説明されています。モデルの最初の層では、この列指向のデータを単一の &lt;code&gt;Tensor&lt;/code&gt; に変換する必要があります。</target>
        </trans-unit>
        <trans-unit id="7c63e0117b37d1fc0d3a2fdf6f89aed5b55248ac" translate="yes" xml:space="preserve">
          <source>Generally a single example in training data is described with FeatureColumns. At the first layer of the model, this column-oriented data should be converted to a single &lt;code&gt;Tensor&lt;/code&gt;.</source>
          <target state="translated">一般に、トレーニングデータの1つの例は、FeatureColumnsで説明されています。モデルの最初のレイヤーで、この列指向のデータを単一の &lt;code&gt;Tensor&lt;/code&gt; 変換する必要があります。</target>
        </trans-unit>
        <trans-unit id="8de3a173a70a93846ce03fd16984e4335207f7a1" translate="yes" xml:space="preserve">
          <source>Generally it is best if the shard operator is used early in the dataset pipeline. For example, when reading from a set of TFRecord files, shard before converting the dataset to input samples. This avoids reading every file on every worker. The following is an example of an efficient sharding strategy within a complete pipeline:</source>
          <target state="translated">一般的には、データセットのパイプラインの早い段階で shard 演算子を使用するのがベストです。例えば、TFRecordファイルのセットから読み込む場合、データセットを入力サンプルに変換する前にshardを使用します。これにより、すべてのワーカーですべてのファイルを読み込むことを避けることができます。以下は、完全なパイプライン内での効率的なシャーディング戦略の例です。</target>
        </trans-unit>
        <trans-unit id="e2dd4981d0a29e58e9fcc5b1a49943c316b64754" translate="yes" xml:space="preserve">
          <source>Generate a &lt;a href=&quot;https://docs.scipy.org/doc/numpy/reference/generated/numpy.kaiser.html&quot;&gt;Kaiser window&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://docs.scipy.org/doc/numpy/reference/generated/numpy.kaiser.html&quot;&gt;カイザーウィンドウ&lt;/a&gt;を生成します。</target>
        </trans-unit>
        <trans-unit id="90b4629b3e84cf9ddd69d1cfdd41ef3ba86e8a84" translate="yes" xml:space="preserve">
          <source>Generate a &lt;a href=&quot;https://en.wikipedia.org/wiki/Kaiser_window#Kaiser%E2%80%93Bessel-derived_(KBD)_window&quot;&gt;Kaiser Bessel derived window&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Kaiser_window#Kaiser%E2%80%93Bessel-derived_(KBD)_window&quot;&gt;カイザーベッセル派生ウィンドウ&lt;/a&gt;を生成します。</target>
        </trans-unit>
        <trans-unit id="11d7cd9f12caac64f12dc084266511c05d1e68e5" translate="yes" xml:space="preserve">
          <source>Generate a &lt;a href=&quot;https://en.wikipedia.org/wiki/Modified_discrete_cosine_transform#Window_functions&quot;&gt;Vorbis power complementary window&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Modified_discrete_cosine_transform#Window_functions&quot;&gt;Vorbisパワー補完ウィンドウ&lt;/a&gt;を生成します。</target>
        </trans-unit>
        <trans-unit id="34347d3edc6f1c3feaba292295a44f85ae9283b4" translate="yes" xml:space="preserve">
          <source>Generate a &lt;a href=&quot;https://en.wikipedia.org/wiki/Window_function#Hann_and_Hamming_windows&quot;&gt;Hamming&lt;/a&gt; window.</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Window_function#Hann_and_Hamming_windows&quot;&gt;ハミング&lt;/a&gt;ウィンドウを生成します。</target>
        </trans-unit>
        <trans-unit id="279c13b7205ad932f6fc77bc4c11a570af2e0643" translate="yes" xml:space="preserve">
          <source>Generate a &lt;a href=&quot;https://en.wikipedia.org/wiki/Window_function#Hann_and_Hamming_windows&quot;&gt;Hann window&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Window_function#Hann_and_Hamming_windows&quot;&gt;Hannウィンドウ&lt;/a&gt;を生成します。</target>
        </trans-unit>
        <trans-unit id="ac32a415109d1780683dc87c835b4bf44b9e214f" translate="yes" xml:space="preserve">
          <source>Generate a SignatureDef proto for inclusion in a MetaGraphDef.</source>
          <target state="translated">MetaGraphDefに含めるためのSignatureDefプロトを生成します。</target>
        </trans-unit>
        <trans-unit id="c002c4b3ce23a9d11b517e557ca82ee3b02cef6f" translate="yes" xml:space="preserve">
          <source>Generate a glob pattern matching all sharded file names.</source>
          <target state="translated">すべてのシャードされたファイル名にマッチするグロブ・パターンを生成します。</target>
        </trans-unit>
        <trans-unit id="2b79e30cedbd9d694f0b8690f5c2126451ebafb1" translate="yes" xml:space="preserve">
          <source>Generate a pprof profile gzip file.</source>
          <target state="translated">pprofプロファイルのgzipファイルを生成します。</target>
        </trans-unit>
        <trans-unit id="ffe3bd416f54a13ea7f1d20611db6869a2732c01" translate="yes" xml:space="preserve">
          <source>Generate a sharded filename. The filename is printf formatted as</source>
          <target state="translated">シャードされたファイル名を生成します。ファイル名は</target>
        </trans-unit>
        <trans-unit id="a1371c069157738d08a42f8452b9b9196d90ec61" translate="yes" xml:space="preserve">
          <source>Generate a single randomly distorted bounding box for an image.</source>
          <target state="translated">画像のためにランダムに歪んだ単一の外接箱を生成します。</target>
        </trans-unit>
        <trans-unit id="ac024cfebf615ec9550fa9639992f999e3b2ee72" translate="yes" xml:space="preserve">
          <source>Generate a single randomly distorted bounding box for an image. (deprecated)</source>
          <target state="translated">画像のためのランダムに歪んだ外接箱を生成します.(非推奨)</target>
        </trans-unit>
        <trans-unit id="a513f309f426925500e16fda01716dda1ec01c9d" translate="yes" xml:space="preserve">
          <source>Generate a timeline json file.</source>
          <target state="translated">タイムラインのjsonファイルを生成します。</target>
        </trans-unit>
        <trans-unit id="a4b61b9eadd182e79e8d7ca8f5436072061f5cd0" translate="yes" xml:space="preserve">
          <source>Generate batches of tensor image data with real-time data augmentation.</source>
          <target state="translated">リアルタイムのデータ増強でテンソル画像データのバッチを生成します。</target>
        </trans-unit>
        <trans-unit id="8e985d2b987cc5cfe48af402ebd8ddad192ec795" translate="yes" xml:space="preserve">
          <source>Generate bounding box proposals from encoded bounding boxes.</source>
          <target state="translated">エンコードされたバウンディングボックスからバウンディングボックス提案を生成します。</target>
        </trans-unit>
        <trans-unit id="c0ad06dc54e9b19d8f565750f7f75ca4b2cfa07b" translate="yes" xml:space="preserve">
          <source>Generate class predictions for the input samples.</source>
          <target state="translated">入力サンプルのクラス予測を生成します.</target>
        </trans-unit>
        <trans-unit id="e88196696cce2f195fee6d21c523e69e11454eb0" translate="yes" xml:space="preserve">
          <source>Generate class predictions for the input samples. (deprecated)</source>
          <target state="translated">入力サンプルのクラス予測値を生成します.(廃止予定)</target>
        </trans-unit>
        <trans-unit id="a7093df80f13988f753b4ffb41362fefaef5f111" translate="yes" xml:space="preserve">
          <source>Generate samples of the specified shape.</source>
          <target state="translated">指定した形状のサンプルを生成します。</target>
        </trans-unit>
        <trans-unit id="576d0866bf17ce5f09b194820a38f8952d6e4b06" translate="yes" xml:space="preserve">
          <source>Generate the bucket boundaries for each feature based on accumulated summaries.</source>
          <target state="translated">蓄積されたサマリーに基づいて、各フィーチャのバケット境界を生成します。</target>
        </trans-unit>
        <trans-unit id="9e9203d473bfc408cbd4f794fe904486104787f9" translate="yes" xml:space="preserve">
          <source>Generate the set of all classes.</source>
          <target state="translated">すべてのクラスの集合を生成します。</target>
        </trans-unit>
        <trans-unit id="23f698bd99350dfeeb28f80c4b7d56c43289deab" translate="yes" xml:space="preserve">
          <source>GenerateBoundingBoxProposals</source>
          <target state="translated">GenerateBoundingBoxProposals</target>
        </trans-unit>
        <trans-unit id="3b1c4b8d98e609c7742c5fa5ed5d888e187de455" translate="yes" xml:space="preserve">
          <source>GenerateVocabRemapping</source>
          <target state="translated">GenerateVocabRemapping</target>
        </trans-unit>
        <trans-unit id="dd09a6e5d58951f89fcc802fecad98e6223e4700" translate="yes" xml:space="preserve">
          <source>Generates &lt;a href=&quot;../distributedvalues&quot;&gt;&lt;code&gt;tf.distribute.DistributedValues&lt;/code&gt;&lt;/a&gt; from &lt;code&gt;value_fn&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;../distributedvalues&quot;&gt; &lt;code&gt;tf.distribute.DistributedValues&lt;/code&gt; &lt;/a&gt;から &lt;code&gt;value_fn&lt;/code&gt; を生成します。</target>
        </trans-unit>
        <trans-unit id="9836cccd1541d8044f475f870ee2ee77b1a6027f" translate="yes" xml:space="preserve">
          <source>Generates &lt;a href=&quot;distributedvalues&quot;&gt;&lt;code&gt;tf.distribute.DistributedValues&lt;/code&gt;&lt;/a&gt; from &lt;code&gt;value_fn&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;distributedvalues&quot;&gt; &lt;code&gt;tf.distribute.DistributedValues&lt;/code&gt; &lt;/a&gt;から &lt;code&gt;value_fn&lt;/code&gt; を生成します。</target>
        </trans-unit>
        <trans-unit id="f43bcd2870c5432e0a747c0e7e61691f6c6d69d4" translate="yes" xml:space="preserve">
          <source>Generates a &lt;a href=&quot;../../data/dataset&quot;&gt;&lt;code&gt;tf.data.Dataset&lt;/code&gt;&lt;/a&gt; from image files in a directory.</source>
          <target state="translated">生成し&lt;a href=&quot;../../data/dataset&quot;&gt; &lt;code&gt;tf.data.Dataset&lt;/code&gt; は&lt;/a&gt;、ディレクトリ内の画像ファイルから。</target>
        </trans-unit>
        <trans-unit id="6f6d1ff08babf239e90da6e16be908dfc487e187" translate="yes" xml:space="preserve">
          <source>Generates a &lt;a href=&quot;../../data/dataset&quot;&gt;&lt;code&gt;tf.data.Dataset&lt;/code&gt;&lt;/a&gt; from text files in a directory.</source>
          <target state="translated">ディレクトリ内のテキストファイルから&lt;a href=&quot;../../data/dataset&quot;&gt; &lt;code&gt;tf.data.Dataset&lt;/code&gt; &lt;/a&gt;を生成します。</target>
        </trans-unit>
        <trans-unit id="377bb61844f7989feb179e9255bc056adafe1698" translate="yes" xml:space="preserve">
          <source>Generates a &lt;code&gt;SaverDef&lt;/code&gt; representation of this saver.</source>
          <target state="translated">このセーバーの &lt;code&gt;SaverDef&lt;/code&gt; 表現を生成します。</target>
        </trans-unit>
        <trans-unit id="ebd6ec5178119ea6a1811d87dd13d57c9a6db943" translate="yes" xml:space="preserve">
          <source>Generates a MultiDeviceIterator resource from its provided string handle.</source>
          <target state="translated">指定した文字列ハンドルから MultiDeviceIterator リソースを生成します。</target>
        </trans-unit>
        <trans-unit id="45ca970a93e98f0a96c6dd41425b7de72d75abbf" translate="yes" xml:space="preserve">
          <source>Generates a checkpoint state proto.</source>
          <target state="translated">チェックポイント状態のプロトを生成します。</target>
        </trans-unit>
        <trans-unit id="2af4bf65e2bb4f1d1dd68fd49dd2b53aac1939ec" translate="yes" xml:space="preserve">
          <source>Generates a feature cross from a list of tensors, and returns it as a</source>
          <target state="translated">テンソルのリストから特徴量のクロスを生成し,それを</target>
        </trans-unit>
        <trans-unit id="825f6429255ba775713386b0d2f3a17166359e07" translate="yes" xml:space="preserve">
          <source>Generates a window function that can be used in &lt;code&gt;inverse_stft&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;inverse_stft&lt;/code&gt; で使用できるウィンドウ関数を生成します。</target>
        </trans-unit>
        <trans-unit id="47b0fd38944f765d01ecdf4f5dde5c9129216b79" translate="yes" xml:space="preserve">
          <source>Generates a word rank-based probabilistic sampling table.</source>
          <target state="translated">単語ランクに基づく確率的サンプリングテーブルを生成します。</target>
        </trans-unit>
        <trans-unit id="1eaf3ef20aca17d2ddd855b709da877935b5c644" translate="yes" xml:space="preserve">
          <source>Generates class probability predictions for the input samples.</source>
          <target state="translated">入力サンプルのクラス確率予測値を生成します.</target>
        </trans-unit>
        <trans-unit id="acbdf4f7e996764e39f5a1d460a1590720b7ffed" translate="yes" xml:space="preserve">
          <source>Generates class probability predictions for the input samples. (deprecated)</source>
          <target state="translated">入力サンプルのクラス確率予測値を生成します.(廃止予定)</target>
        </trans-unit>
        <trans-unit id="649bbae2e63ab9a653a1bbb3ef6140122196b569" translate="yes" xml:space="preserve">
          <source>Generates evenly-spaced values in an interval along a given axis.</source>
          <target state="translated">指定された軸に沿って等間隔の値を生成します。</target>
        </trans-unit>
        <trans-unit id="12a10bcf16b64dd9017853e6b82862f0dc5c5e73" translate="yes" xml:space="preserve">
          <source>Generates feature cross from a list of tensors.</source>
          <target state="translated">テンソルのリストから特徴量のクロスを生成します。</target>
        </trans-unit>
        <trans-unit id="c2e65b80cc8c5def122f20b61b5d83b821ccc7ce" translate="yes" xml:space="preserve">
          <source>Generates fingerprint values of &lt;code&gt;data&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;data&lt;/code&gt; フィンガープリント値を生成します。</target>
        </trans-unit>
        <trans-unit id="e89a59f26ad8f607008d022c7aae25b086f3ec9e" translate="yes" xml:space="preserve">
          <source>Generates fingerprint values.</source>
          <target state="translated">指紋値を生成します。</target>
        </trans-unit>
        <trans-unit id="dbdf2df393e7c5b28c8c46b716424d6d5f6d05e3" translate="yes" xml:space="preserve">
          <source>Generates hashed feature cross from a list of tensors.</source>
          <target state="translated">テンソルのリストからハッシュ化された特徴量のクロスを生成します.</target>
        </trans-unit>
        <trans-unit id="ecd2cd43082dd2fa1d698670c924b8a9339f3115" translate="yes" xml:space="preserve">
          <source>Generates hashed sparse cross from a list of sparse and dense tensors.</source>
          <target state="translated">疎なテンソルと密なテンソルのリストからハッシュ化された疎なクロスを生成します.</target>
        </trans-unit>
        <trans-unit id="39625478ffa83ceceb283552bff4daf578ea3d67" translate="yes" xml:space="preserve">
          <source>Generates labels for candidate sampling with a learned unigram distribution.</source>
          <target state="translated">学習されたユニグラム分布を用いて,候補サンプリングのためのラベルを生成します.</target>
        </trans-unit>
        <trans-unit id="494f1bcb0d30b701f7c55dd7dbcf0c95bbc04be8" translate="yes" xml:space="preserve">
          <source>Generates labels for candidate sampling with a log-uniform distribution.</source>
          <target state="translated">対数一様分布を持つ候補サンプリングのラベルを生成します。</target>
        </trans-unit>
        <trans-unit id="4d38f8146d8f4aa0acc79c3ad874070501094862" translate="yes" xml:space="preserve">
          <source>Generates labels for candidate sampling with a uniform distribution.</source>
          <target state="translated">一様分布を持つ候補サンプリングのラベルを生成します。</target>
        </trans-unit>
        <trans-unit id="d830604723f094db9bc24fb88a7e02736a2c3056" translate="yes" xml:space="preserve">
          <source>Generates output predictions for the input samples.</source>
          <target state="translated">入力サンプルの出力予測値を生成します.</target>
        </trans-unit>
        <trans-unit id="b249d65bf0f914d4110d91f913e1300c01aa2889" translate="yes" xml:space="preserve">
          <source>Generates parsing spec for tf.parse_example to be used with classifiers.</source>
          <target state="translated">分類器で使用されるtf.parse_exampleのパース仕様を生成します.</target>
        </trans-unit>
        <trans-unit id="1aae58a59256b1fc205171c419f649a6e0c1ac2c" translate="yes" xml:space="preserve">
          <source>Generates parsing spec for tf.parse_example to be used with regressors.</source>
          <target state="translated">regressorsで使用されるtf.parse_exampleのパース仕様を生成します。</target>
        </trans-unit>
        <trans-unit id="7d0f6811f98e9f7451ddd47d27cbbd2d502a54ba" translate="yes" xml:space="preserve">
          <source>Generates points from the Sobol sequence.</source>
          <target state="translated">Sobolシーケンスから点を生成します.</target>
        </trans-unit>
        <trans-unit id="a2df3b2c3bfd14ecb54ef8d497e84f89bbccb46c" translate="yes" xml:space="preserve">
          <source>Generates predictions for the input samples from a data generator. (deprecated)</source>
          <target state="translated">データジェネレータから入力サンプルの予測値を生成します。(廃止予定)</target>
        </trans-unit>
        <trans-unit id="f0b782326dc1552a60227a419a223dd58df3f275" translate="yes" xml:space="preserve">
          <source>Generates random parameters for a transformation.</source>
          <target state="translated">変換のためのランダムパラメータを生成します。</target>
        </trans-unit>
        <trans-unit id="29c08e7ff9dc1d9fd5830b7df9e2c9f201d13165" translate="yes" xml:space="preserve">
          <source>Generates seeds for stateless random ops.</source>
          <target state="translated">ステートレスなランダム作戦のための種を生成します。</target>
        </trans-unit>
        <trans-unit id="929055b21af18b1410a5ef9e6f627e2fe967eded" translate="yes" xml:space="preserve">
          <source>Generates skipgram word pairs.</source>
          <target state="translated">スキップグラムの単語ペアを生成します。</target>
        </trans-unit>
        <trans-unit id="c717f055df49ec5bd1aa8121ba707a81fd38bcab" translate="yes" xml:space="preserve">
          <source>Generates sparse cross from a list of sparse and dense tensors.</source>
          <target state="translated">疎なテンソルと密なテンソルのリストから疎なクロスを生成します.</target>
        </trans-unit>
        <trans-unit id="eee7e06216ccc809aac0d41b4d65812d7279baab" translate="yes" xml:space="preserve">
          <source>Generates the RaggedTensor &lt;code&gt;row_splits&lt;/code&gt; corresponding to a segmentation.</source>
          <target state="translated">セグメンテーションに対応するRaggedTensorの &lt;code&gt;row_splits&lt;/code&gt; を生成します。</target>
        </trans-unit>
        <trans-unit id="9c8ebc23fb3d11a9fa1612cc64fdaa5515b59f5b" translate="yes" xml:space="preserve">
          <source>Generates the segmentation corresponding to a RaggedTensor &lt;code&gt;row_splits&lt;/code&gt;.</source>
          <target state="translated">RaggedTensorの &lt;code&gt;row_splits&lt;/code&gt; に対応するセグメンテーションを生成します。</target>
        </trans-unit>
        <trans-unit id="847054fadb60634ee2f52424f471fb76a80ae831" translate="yes" xml:space="preserve">
          <source>Generates values in an interval.</source>
          <target state="translated">インターバル内の値を生成します。</target>
        </trans-unit>
        <trans-unit id="f83f1b24a7b8176a12bbd8754dc347723cff3a26" translate="yes" xml:space="preserve">
          <source>GeneratorDataset</source>
          <target state="translated">GeneratorDataset</target>
        </trans-unit>
        <trans-unit id="dd2f789a1badf7c47aa6e96fdc59fb1ae83e7fe2" translate="yes" xml:space="preserve">
          <source>Generic entry point script.</source>
          <target state="translated">一般的なエントリーポイントスクリプト。</target>
        </trans-unit>
        <trans-unit id="2c95b2ae6664568cd6a269ff2188bf2127d2b537" translate="yes" xml:space="preserve">
          <source>Get a dictionary describing TensorFlow's build environment.</source>
          <target state="translated">TensorFlowのビルド環境を記述した辞書を取得します。</target>
        </trans-unit>
        <trans-unit id="0d7e04da7f8fb8474d86e3fc36734ea9ac641c99" translate="yes" xml:space="preserve">
          <source>Get a direct path to the data files colocated with the script.</source>
          <target state="translated">スクリプトとコロケーションしたデータファイルへの直接パスを取得します。</target>
        </trans-unit>
        <trans-unit id="25e90702cc2a6266a80ebe5d73070c2394a2d997" translate="yes" xml:space="preserve">
          <source>Get a partitioner for VariableScope to keep shards below &lt;code&gt;max_shard_bytes&lt;/code&gt;.</source>
          <target state="translated">VariableScopeのパーティ &lt;code&gt;max_shard_bytes&lt;/code&gt; を取得して、シャードをmax_shard_bytes未満に保ちます。</target>
        </trans-unit>
        <trans-unit id="59040295d5cb452ad25fbe2e72127aba826b97ef" translate="yes" xml:space="preserve">
          <source>Get a root directory containing all the data attributes in the build rule.</source>
          <target state="translated">ビルドルール内のすべてのデータ属性を含むルートディレクトリを取得します。</target>
        </trans-unit>
        <trans-unit id="bb88a5384f5bc20bdadfdbaa3c133110e4b6085f" translate="yes" xml:space="preserve">
          <source>Get experimental optimizer options.</source>
          <target state="translated">実験的なオプティマイザのオプションを取得します。</target>
        </trans-unit>
        <trans-unit id="a2113882a890fee2c46d1a70f2c5138bd06f0eb7" translate="yes" xml:space="preserve">
          <source>Get from cache or create a default operation.</source>
          <target state="translated">キャッシュから取得するか、デフォルトの操作を作成します。</target>
        </trans-unit>
        <trans-unit id="b670781c96420a037469ad0934765b418deb4d2f" translate="yes" xml:space="preserve">
          <source>Get if JIT compilation is enabled.</source>
          <target state="translated">JITコンパイルが有効かどうかを取得します。</target>
        </trans-unit>
        <trans-unit id="69a0067636164f576df746229abb6b9aaceb5ae6" translate="yes" xml:space="preserve">
          <source>Get if device placements are logged.</source>
          <target state="translated">デバイスの配置が記録されているかどうかを取得します。</target>
        </trans-unit>
        <trans-unit id="498721b0192fabfcd02ce495785bf7613c9f7cee" translate="yes" xml:space="preserve">
          <source>Get if memory growth is enabled for a &lt;code&gt;PhysicalDevice&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;PhysicalDevice&lt;/code&gt; のメモリ拡張が有効かどうかを取得します。</target>
        </trans-unit>
        <trans-unit id="58ef7dbc31c00f8af4807e08acd0430c855e1d84" translate="yes" xml:space="preserve">
          <source>Get if soft device placement is enabled.</source>
          <target state="translated">ソフトデバイスの配置が有効かどうかを取得します。</target>
        </trans-unit>
        <trans-unit id="c9c7c6ec42a6b32f83fcca563a931ba4fbe0ed3b" translate="yes" xml:space="preserve">
          <source>Get number of threads used for parallelism between independent operations.</source>
          <target state="translated">独立した演算間の並列処理に使用するスレッド数を取得します。</target>
        </trans-unit>
        <trans-unit id="80b95985b48aaafa3e792986341c8b4ff88eead6" translate="yes" xml:space="preserve">
          <source>Get number of threads used within an individual op for parallelism.</source>
          <target state="translated">並列化のために個々のオペランド内で使用されるスレッド数を取得します。</target>
        </trans-unit>
        <trans-unit id="6fc794e6fd1f995204b4b699515f189ad3b79ac8" translate="yes" xml:space="preserve">
          <source>Get the &lt;code&gt;TensorShape&lt;/code&gt; representing the shape of the dense tensor.</source>
          <target state="translated">密なテンソルの形状を表す &lt;code&gt;TensorShape&lt;/code&gt; を取得します。</target>
        </trans-unit>
        <trans-unit id="53ea60d80b4295960ae12cbdab1a207aed855693" translate="yes" xml:space="preserve">
          <source>Get the KL-divergence KL(distribution_a || distribution_b). (deprecated)</source>
          <target state="translated">KL発散KL(distribution_a || distribution_b)を取得します。(非推奨)</target>
        </trans-unit>
        <trans-unit id="0bf696fef5a21374d09e8355388763caa023a426" translate="yes" xml:space="preserve">
          <source>Get the Master string to be used for the session.</source>
          <target state="translated">セッションで使用するマスター文字列を取得します。</target>
        </trans-unit>
        <trans-unit id="108dacf621a6cd835ace3ba57aa80d2b5e19236d" translate="yes" xml:space="preserve">
          <source>Get the compilation flags for custom operators.</source>
          <target state="translated">カスタム演算子のコンパイルフラグを取得します。</target>
        </trans-unit>
        <trans-unit id="b7741d8625c9ab518a4a96df253f1b4a18258c89" translate="yes" xml:space="preserve">
          <source>Get the current size of the TensorArray.</source>
          <target state="translated">TensorArrayの現在のサイズを取得します。</target>
        </trans-unit>
        <trans-unit id="3ae51f237cd7e7c81a09e6f89ce59cb258772427" translate="yes" xml:space="preserve">
          <source>Get the directory containing the TensorFlow C++ header files.</source>
          <target state="translated">TensorFlow C++ヘッダファイルが入っているディレクトリを取得します。</target>
        </trans-unit>
        <trans-unit id="359b660afd7e217497634736e8bd4bb55153be9c" translate="yes" xml:space="preserve">
          <source>Get the directory containing the TensorFlow framework library.</source>
          <target state="translated">TensorFlowフレームワークライブラリが入っているディレクトリを取得します。</target>
        </trans-unit>
        <trans-unit id="1b86ea9f05146578b1054be5bc6cba1a144e94aa" translate="yes" xml:space="preserve">
          <source>Get the dropout mask for RNN cell's input.</source>
          <target state="translated">RNNセルの入力のドロップアウトマスクを取得します。</target>
        </trans-unit>
        <trans-unit id="ac67fd4c2118b549293e874899270e15a2f87c37" translate="yes" xml:space="preserve">
          <source>Get the embedding results.</source>
          <target state="translated">埋め込み結果を取得します。</target>
        </trans-unit>
        <trans-unit id="650bdecea08ce6ef81b38eabb82f7de00f8d7991" translate="yes" xml:space="preserve">
          <source>Get the global step tensor.</source>
          <target state="translated">グローバルステップテンソルを取得します。</target>
        </trans-unit>
        <trans-unit id="fc3b1d0c5d3365a3eaff90c6cf36385cdaa1ba29" translate="yes" xml:space="preserve">
          <source>Get the link flags for custom operators.</source>
          <target state="translated">カスタム演算子のリンクフラグを取得します。</target>
        </trans-unit>
        <trans-unit id="e5b8a3ccddd79a33c1a86a133a701f8165f54b2b" translate="yes" xml:space="preserve">
          <source>Get the list of visible physical devices.</source>
          <target state="translated">表示されている物理デバイスのリストを取得します。</target>
        </trans-unit>
        <trans-unit id="921a66e34ee4a58c84a0efa213945cee146717d6" translate="yes" xml:space="preserve">
          <source>Get the path to the specified file in the data dependencies.</source>
          <target state="translated">データ依存関係で指定したファイルへのパスを取得します。</target>
        </trans-unit>
        <trans-unit id="b6dd8217ee8de67bf5164159422b42d807287473" translate="yes" xml:space="preserve">
          <source>Get the recurrent dropout mask for RNN cell.</source>
          <target state="translated">RNNセルのリカレントドロップアウトマスクを取得します。</target>
        </trans-unit>
        <trans-unit id="c31cddaa67a87523e9d1624fa98876319984d178" translate="yes" xml:space="preserve">
          <source>Get the tensor of type &lt;code&gt;dtype&lt;/code&gt; by feeding a tensor handle.</source>
          <target state="translated">テンソルハンドルをフィードして、タイプ &lt;code&gt;dtype&lt;/code&gt; のテンソルを取得します。</target>
        </trans-unit>
        <trans-unit id="c3cd44016bc9caf57517296a543e5f07cc70b58f" translate="yes" xml:space="preserve">
          <source>Get the value of the tensor from a tensor handle. The tensor is produced in a previous run() and stored in the state of the session.</source>
          <target state="translated">テンソルハンドルからテンソルの値を取得します。テンソルは前のrun()で生成され、セッションの状態に保存されます。</target>
        </trans-unit>
        <trans-unit id="0b696c4e43749193b332192827a0f793184a5d68" translate="yes" xml:space="preserve">
          <source>Get the value of the tensor specified by its handle.</source>
          <target state="translated">ハンドルで指定したテンソルの値を取得します。</target>
        </trans-unit>
        <trans-unit id="35948203feb263f7dc9fb059f6619c9f87908726" translate="yes" xml:space="preserve">
          <source>Get the virtual device configuration for a &lt;a href=&quot;physicaldevice&quot;&gt;&lt;code&gt;tf.config.PhysicalDevice&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;physicaldevice&quot;&gt; &lt;code&gt;tf.config.PhysicalDevice&lt;/code&gt; の&lt;/a&gt;仮想デバイス構成を取得します。</target>
        </trans-unit>
        <trans-unit id="0644eda96e6748128f29f7007c63dd9693a38f23" translate="yes" xml:space="preserve">
          <source>Get this scope's global variables.</source>
          <target state="translated">このスコープのグローバル変数を取得します。</target>
        </trans-unit>
        <trans-unit id="887d65a3c67be69818d4fa832142026519a1083d" translate="yes" xml:space="preserve">
          <source>Get this scope's local variables.</source>
          <target state="translated">このスコープのローカル変数を取得します。</target>
        </trans-unit>
        <trans-unit id="a308585ffe5c9c1e87f02af3bd65c090f3a450c2" translate="yes" xml:space="preserve">
          <source>Get this scope's trainable variables.</source>
          <target state="translated">このスコープの訓練可能な変数を取得します。</target>
        </trans-unit>
        <trans-unit id="057e2633d0656b1fb510dea575a522fc49d9405f" translate="yes" xml:space="preserve">
          <source>Get this scope's variables.</source>
          <target state="translated">このスコープの変数を取得します。</target>
        </trans-unit>
        <trans-unit id="5795bd8bcbae0c5fe909ec39b6d58c353b7d8911" translate="yes" xml:space="preserve">
          <source>Get unique labels and indices for batched labels for &lt;a href=&quot;ctc_loss&quot;&gt;&lt;code&gt;tf.nn.ctc_loss&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;ctc_loss&quot;&gt; &lt;code&gt;tf.nn.ctc_loss&lt;/code&gt; の&lt;/a&gt;バッチラベルの一意のラベルとインデックスを取得します。</target>
        </trans-unit>
        <trans-unit id="ad80c7ad74f9cfd40d20ded5dcca808ac13dcbc8" translate="yes" xml:space="preserve">
          <source>GetSessionHandle</source>
          <target state="translated">GetSessionHandle</target>
        </trans-unit>
        <trans-unit id="2179dea7e98769d4809990545d7093de795b9aae" translate="yes" xml:space="preserve">
          <source>GetSessionHandleV2</source>
          <target state="translated">GetSessionHandleV2</target>
        </trans-unit>
        <trans-unit id="a40b5c806adbe4a5fe6b4c1812438a81bf678aa7" translate="yes" xml:space="preserve">
          <source>GetSessionTensor</source>
          <target state="translated">GetSessionTensor</target>
        </trans-unit>
        <trans-unit id="e5f58f3a07d14b9e0032e44d6a23fe568ceffa8e" translate="yes" xml:space="preserve">
          <source>Gets a numpy-style shape tuple giving the dataset dimensions.</source>
          <target state="translated">データセットの次元を与えるnumpyスタイルの形状タプルを取得します。</target>
        </trans-unit>
        <trans-unit id="16edd56dc8f500661a54f70ff8aa5d3642a74f3d" translate="yes" xml:space="preserve">
          <source>Gets an existing &lt;em&gt;local&lt;/em&gt; variable or creates a new one.</source>
          <target state="translated">既存の&lt;em&gt;ローカル&lt;/em&gt;変数を取得するか、新しい変数を作成します。</target>
        </trans-unit>
        <trans-unit id="8363344ba8552991690effa2b825a04c73499304" translate="yes" xml:space="preserve">
          <source>Gets an existing variable with these parameters or create a new one.</source>
          <target state="translated">これらのパラメータを持つ既存の変数を取得するか、新しい変数を作成します。</target>
        </trans-unit>
        <trans-unit id="c705ed15a7fab0aed052398593737c16839589c3" translate="yes" xml:space="preserve">
          <source>Gets an existing variable with this name or create a new one.</source>
          <target state="translated">この名前を持つ既存の変数を取得するか、新しい変数を作成します。</target>
        </trans-unit>
        <trans-unit id="e6eb4b621d4c64dca0de29b3b8a401e1cd6303ba" translate="yes" xml:space="preserve">
          <source>Gets batch at position &lt;code&gt;index&lt;/code&gt;.</source>
          <target state="translated">位置 &lt;code&gt;index&lt;/code&gt; のバッチを取得します。</target>
        </trans-unit>
        <trans-unit id="9241f5d7bcc0a690cd669562fcda23fde5204e95" translate="yes" xml:space="preserve">
          <source>Gets model input details.</source>
          <target state="translated">モデル入力の詳細を取得します。</target>
        </trans-unit>
        <trans-unit id="7cb340e682cc8a13364fea269654750b9f7ffa8f" translate="yes" xml:space="preserve">
          <source>Gets model output details.</source>
          <target state="translated">モデル出力の詳細を取得します。</target>
        </trans-unit>
        <trans-unit id="12c82d522842fce5b68907e9a09973a0aa4e2bf3" translate="yes" xml:space="preserve">
          <source>Gets next element for the provided shard number.</source>
          <target state="translated">指定されたシャード番号の次の要素を取得します。</target>
        </trans-unit>
        <trans-unit id="1176b88ed9f974924ce3c2aed58b5efc5abf028f" translate="yes" xml:space="preserve">
          <source>Gets parameters for this estimator.</source>
          <target state="translated">この推定子のパラメータを取得します。</target>
        </trans-unit>
        <trans-unit id="bf1b6d34570c76b9b641b4a8fdf7b56eacc074a4" translate="yes" xml:space="preserve">
          <source>Gets tensor details for every tensor with valid tensor details.</source>
          <target state="translated">有効なテンソルの詳細を持つすべてのテンソルについて、テンソルの詳細を取得します。</target>
        </trans-unit>
        <trans-unit id="3f6f5f2772b01d65cdb20576211da5d66d43f685" translate="yes" xml:space="preserve">
          <source>Gets the &lt;a href=&quot;tensorshape&quot;&gt;&lt;code&gt;tf.TensorShape&lt;/code&gt;&lt;/a&gt; representing the shape of the dense tensor.</source>
          <target state="translated">密なテンソルの形状を表す&lt;a href=&quot;tensorshape&quot;&gt; &lt;code&gt;tf.TensorShape&lt;/code&gt; &lt;/a&gt;を取得します。</target>
        </trans-unit>
        <trans-unit id="5649b7730a87257a8bf757eb14d5d260e4d8989f" translate="yes" xml:space="preserve">
          <source>Gets the checkpoint state given the provided checkpoint_dir and looks for a corresponding TensorFlow 2 (preferred) or TensorFlow 1.x checkpoint path. The latest_filename argument is only applicable if you are saving checkpoint using &lt;code&gt;v1.Saver.save&lt;/code&gt;</source>
          <target state="translated">指定されたcheckpoint_dirを指定してチェックポイントの状態を取得し、対応するTensorFlow 2（推奨）またはTensorFlow1.xチェックポイントパスを探します。あなたが使用してチェックポイントを保存している場合latest_filename引数にのみ適用され &lt;code&gt;v1.Saver.save&lt;/code&gt; を</target>
        </trans-unit>
        <trans-unit id="edf919a5da9968403435a8f5bed01d1084154593" translate="yes" xml:space="preserve">
          <source>Gets the crossed output from a partial list/tuple of inputs.</source>
          <target state="translated">入力の部分リスト/タプルからクロスした出力を取得します。</target>
        </trans-unit>
        <trans-unit id="0911c623c2e60904843307f59585e7a371b0bc73" translate="yes" xml:space="preserve">
          <source>Gets the current device policy.</source>
          <target state="translated">現在のデバイスポリシーを取得します。</target>
        </trans-unit>
        <trans-unit id="84ad69761c8ff8c302a3208721f28483a943e063" translate="yes" xml:space="preserve">
          <source>Gets the datatype of the dataset.</source>
          <target state="translated">データセットのデータ型を取得します。</target>
        </trans-unit>
        <trans-unit id="c0ad71d1c926ecf4a236b3b9ed68592ba6894254" translate="yes" xml:space="preserve">
          <source>Gets the list of losses from the loss_collection.</source>
          <target state="translated">loss_collection から損失のリストを取得します。</target>
        </trans-unit>
        <trans-unit id="d33e19f642cb6ca8f7cdb89e56c9383004a73014" translate="yes" xml:space="preserve">
          <source>Gets the list of regularization losses.</source>
          <target state="translated">正則化損失のリストを取得します。</target>
        </trans-unit>
        <trans-unit id="3bbcd4bcf488d6f0e10e7505b28c43087a823f71" translate="yes" xml:space="preserve">
          <source>Gets the next output from the given iterator .</source>
          <target state="translated">与えられたイテレータから次の出力を取得します.</target>
        </trans-unit>
        <trans-unit id="94576ff1b1b843455454082862a97d7ef6376959" translate="yes" xml:space="preserve">
          <source>Gets the next output from the given iterator as an Optional variant.</source>
          <target state="translated">与えられたイテレータの次の出力をオプションのバリアントとして取得します。</target>
        </trans-unit>
        <trans-unit id="b6dcd4f1b64cdf911fd9f684928f1da25a6cfb7f" translate="yes" xml:space="preserve">
          <source>Gets the next output from the given iterator.</source>
          <target state="translated">与えられたイテレータから次の出力を取得します。</target>
        </trans-unit>
        <trans-unit id="994bf13750cf00f44f9b6b4c9dfb6f0028020c70" translate="yes" xml:space="preserve">
          <source>Gets the number of dimensions (rank) of the dataset.</source>
          <target state="translated">データセットの次元数(ランク)を取得します。</target>
        </trans-unit>
        <trans-unit id="f23647c68125a7ba22ae0e3518d064d1d05de6f2" translate="yes" xml:space="preserve">
          <source>Gets the total dataset size (number of elements).</source>
          <target state="translated">データセットの総サイズ(要素数)を取得します。</target>
        </trans-unit>
        <trans-unit id="9e0adaeaa293d7d6a42173107240437868052b8a" translate="yes" xml:space="preserve">
          <source>Gets the total regularization loss.</source>
          <target state="translated">正則化の総損失を取得します。</target>
        </trans-unit>
        <trans-unit id="73109b21436d1124b271c6807ebab80e82f19d20" translate="yes" xml:space="preserve">
          <source>Gets the value of the input tensor (get a copy).</source>
          <target state="translated">入力テンソルの値を取得します(コピーを取得します)。</target>
        </trans-unit>
        <trans-unit id="d0a97ae528a9e344d85b2bc74d446d4af8965e0a" translate="yes" xml:space="preserve">
          <source>Gets whether operations are executed synchronously or asynchronously.</source>
          <target state="translated">操作が同期的に実行されるか非同期的に実行されるかを取得します。</target>
        </trans-unit>
        <trans-unit id="5442e2b64fa09764b9f593867e59a97292c84059" translate="yes" xml:space="preserve">
          <source>GitHub</source>
          <target state="translated">GitHub</target>
        </trans-unit>
        <trans-unit id="6d3e28aa7a51ffcbb882909d4507c0ef3ff3db70" translate="yes" xml:space="preserve">
          <source>Given &lt;code&gt;A&lt;/code&gt; representing this &lt;code&gt;LinearOperator&lt;/code&gt;, if &lt;code&gt;A&lt;/code&gt; is positive definite self-adjoint, return &lt;code&gt;L&lt;/code&gt;, where &lt;code&gt;A = L L^T&lt;/code&gt;, i.e. the cholesky decomposition.</source>
          <target state="translated">この &lt;code&gt;LinearOperator&lt;/code&gt; を表す &lt;code&gt;A&lt;/code&gt; が与えられ、 &lt;code&gt;A&lt;/code&gt; が正定自己随伴である場合、 &lt;code&gt;L&lt;/code&gt; を返します。ここで、 &lt;code&gt;A = L L^T&lt;/code&gt; 、つまりコレスキー分解です。</target>
        </trans-unit>
        <trans-unit id="3011b88138f555206a8d8637777584fc499f20df" translate="yes" xml:space="preserve">
          <source>Given &lt;code&gt;A&lt;/code&gt; representing this &lt;code&gt;LinearOperator&lt;/code&gt;, return &lt;code&gt;A*&lt;/code&gt;. Note that calling &lt;code&gt;self.adjoint()&lt;/code&gt; and &lt;code&gt;self.H&lt;/code&gt; are equivalent.</source>
          <target state="translated">この &lt;code&gt;LinearOperator&lt;/code&gt; を表す &lt;code&gt;A&lt;/code&gt; が与えられると、 &lt;code&gt;A*&lt;/code&gt; 返します。呼び出すことに注意してください &lt;code&gt;self.adjoint()&lt;/code&gt; と &lt;code&gt;self.H&lt;/code&gt; は等価です。</target>
        </trans-unit>
        <trans-unit id="7004a0f51e6bcd7306d7fdb592b0811cb1a57ee7" translate="yes" xml:space="preserve">
          <source>Given &lt;code&gt;A&lt;/code&gt; representing this &lt;code&gt;LinearOperator&lt;/code&gt;, return a &lt;code&gt;LinearOperator&lt;/code&gt; representing &lt;code&gt;A^-1&lt;/code&gt;.</source>
          <target state="translated">与えられた &lt;code&gt;A&lt;/code&gt; この表現 &lt;code&gt;LinearOperator&lt;/code&gt; を、返す &lt;code&gt;LinearOperator&lt;/code&gt; 表す &lt;code&gt;A^-1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5ed8e56b64256346a6878837d8ee1cfda9085e69" translate="yes" xml:space="preserve">
          <source>Given &lt;code&gt;input&lt;/code&gt; and &lt;code&gt;diagonal&lt;/code&gt;, this operation returns a tensor with the same shape and values as &lt;code&gt;input&lt;/code&gt;, except for the main diagonal of the innermost matrices. These will be overwritten by the values in &lt;code&gt;diagonal&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;input&lt;/code&gt; と &lt;code&gt;diagonal&lt;/code&gt; 与えられると、この操作は、最も内側の行列の主対角を除いて、 &lt;code&gt;input&lt;/code&gt; と同じ形状と値を持つテンソルを返します。これらは &lt;code&gt;diagonal&lt;/code&gt; の値で上書きされます。</target>
        </trans-unit>
        <trans-unit id="6d4eddf991c1d74f9a5d1d05bd85b438f60be0df" translate="yes" xml:space="preserve">
          <source>Given &lt;code&gt;input&lt;/code&gt; and &lt;code&gt;diagonal&lt;/code&gt;, this operation returns a tensor with the same shape and values as &lt;code&gt;input&lt;/code&gt;, except for the specified diagonals of the innermost matrices. These will be overwritten by the values in &lt;code&gt;diagonal&lt;/code&gt;.</source>
          <target state="translated">指定された &lt;code&gt;input&lt;/code&gt; と &lt;code&gt;diagonal&lt;/code&gt; 、この操作は、最も内側の行列の指定された対角線を除いて、 &lt;code&gt;input&lt;/code&gt; と同じ形状と値を持つテンソルを返します。これらは、 &lt;code&gt;diagonal&lt;/code&gt; の値で上書きされます。</target>
        </trans-unit>
        <trans-unit id="9752e3f5f130be65433c3b1f55a7c6eed51319fb" translate="yes" xml:space="preserve">
          <source>Given &lt;code&gt;s0&lt;/code&gt; and &lt;code&gt;s1&lt;/code&gt;, tensors that represent shapes, compute &lt;code&gt;r0&lt;/code&gt;, the broadcasted shape. &lt;code&gt;s0&lt;/code&gt;, &lt;code&gt;s1&lt;/code&gt; and &lt;code&gt;r0&lt;/code&gt; are all integer vectors.</source>
          <target state="translated">形状を表すテンソル &lt;code&gt;s0&lt;/code&gt; と &lt;code&gt;s1&lt;/code&gt; が与えられると、ブロードキャストされた形状である &lt;code&gt;r0&lt;/code&gt; を計算します。 &lt;code&gt;s0&lt;/code&gt; 、 &lt;code&gt;s1&lt;/code&gt; 、 &lt;code&gt;r0&lt;/code&gt; はすべて整数ベクトルです。</target>
        </trans-unit>
        <trans-unit id="c4667868493e23c5d3be9c3d6e074ce011a1f942" translate="yes" xml:space="preserve">
          <source>Given &lt;code&gt;tensor&lt;/code&gt;, this operation returns a new &lt;a href=&quot;tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt; that has the same values as &lt;code&gt;tensor&lt;/code&gt; in the same order, except with a new shape given by &lt;code&gt;shape&lt;/code&gt;.</source>
          <target state="translated">所与 &lt;code&gt;tensor&lt;/code&gt; 、この操作は、新しい戻り&lt;a href=&quot;tensor&quot;&gt; &lt;code&gt;tf.Tensor&lt;/code&gt; &lt;/a&gt;と同じ値を有する &lt;code&gt;tensor&lt;/code&gt; によって与えられた新しい形状を除いて、同じ順序での &lt;code&gt;shape&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="be8be019b8aafa6e11f377f6a79a88780b77b43f" translate="yes" xml:space="preserve">
          <source>Given &lt;code&gt;tensor&lt;/code&gt;, this operation returns a tensor that has the same values as &lt;code&gt;tensor&lt;/code&gt; with shape &lt;code&gt;shape&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;tensor&lt;/code&gt; 与えられると、この操作は形状 &lt;code&gt;shape&lt;/code&gt; &lt;code&gt;tensor&lt;/code&gt; と同じ値を持つテンソルを返します。</target>
        </trans-unit>
        <trans-unit id="cdee36245b530dadc7a33390b261e3595f491a32" translate="yes" xml:space="preserve">
          <source>Given &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, compute &lt;code&gt;x * log1p(y)&lt;/code&gt;. This function safely returns zero when &lt;code&gt;x = 0&lt;/code&gt;, no matter what the value of &lt;code&gt;y&lt;/code&gt; is.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; が与えられた場合、 &lt;code&gt;x * log1p(y)&lt;/code&gt; 計算します。この関数は、 &lt;code&gt;y&lt;/code&gt; の値に関係なく、 &lt;code&gt;x = 0&lt;/code&gt; ときに安全にゼロを返します。</target>
        </trans-unit>
        <trans-unit id="270b80b5a40e2baf3fc36e77aed5580f95129897" translate="yes" xml:space="preserve">
          <source>Given &lt;code&gt;x&lt;/code&gt;, compute the inverse error function of &lt;code&gt;x&lt;/code&gt;. This function is the inverse of &lt;a href=&quot;erf&quot;&gt;&lt;code&gt;tf.math.erf&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">与えられた &lt;code&gt;x&lt;/code&gt; は、の逆誤差関数計算 &lt;code&gt;x&lt;/code&gt; 。この関数は&lt;a href=&quot;erf&quot;&gt; &lt;code&gt;tf.math.erf&lt;/code&gt; &lt;/a&gt;の逆です。</target>
        </trans-unit>
        <trans-unit id="9bd6c98f31a6efc0f5ca49049729b234a4e076d8" translate="yes" xml:space="preserve">
          <source>Given N one-dimensional coordinate arrays &lt;code&gt;*args&lt;/code&gt;, returns a list &lt;code&gt;outputs&lt;/code&gt; of N-D coordinate arrays for evaluating expressions on an N-D grid.</source>
          <target state="translated">N個の1次元座標配列 &lt;code&gt;*args&lt;/code&gt; を指定すると、NDグリッド上の式を評価するためのND座標配列のリスト &lt;code&gt;outputs&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="f3b95972a12a7881c9c9398cac9152e479d5c1ef" translate="yes" xml:space="preserve">
          <source>Given a 4D input tensor ('NHWC' or 'NCHW' data formats) and a filter tensor of shape &lt;code&gt;[filter_height, filter_width, in_channels, channel_multiplier]&lt;/code&gt; containing &lt;code&gt;in_channels&lt;/code&gt; convolutional filters of depth 1, &lt;code&gt;depthwise_conv2d&lt;/code&gt; applies a different filter to each input channel (expanding from 1 channel to &lt;code&gt;channel_multiplier&lt;/code&gt; channels for each), then concatenates the results together. The output has &lt;code&gt;in_channels * channel_multiplier&lt;/code&gt; channels.</source>
          <target state="translated">4D入力テンソル（「NHWC」または「NCHW」データフォーマット）と形状のフィルタテンソル所与 &lt;code&gt;[filter_height, filter_width, in_channels, channel_multiplier]&lt;/code&gt; 含有 &lt;code&gt;in_channels&lt;/code&gt; に深さ1の畳み込みフィルタを、 &lt;code&gt;depthwise_conv2d&lt;/code&gt; は拡大（各入力チャネルに異なるフィルタを適用します1チャネルから各チャネルの &lt;code&gt;channel_multiplier&lt;/code&gt; チャネルまで）、次に結果を連結します。出力には、 &lt;code&gt;in_channels * channel_multiplier&lt;/code&gt; チャネルがあります。</target>
        </trans-unit>
        <trans-unit id="094ea9bf18f0c36eba450800d4c1f7a06e4be90d" translate="yes" xml:space="preserve">
          <source>Given a &lt;code&gt;diagonal&lt;/code&gt;, this operation returns a tensor with the &lt;code&gt;diagonal&lt;/code&gt; and everything else padded with zeros. The diagonal is computed as follows:</source>
          <target state="translated">&lt;code&gt;diagonal&lt;/code&gt; 与えられると、この演算は &lt;code&gt;diagonal&lt;/code&gt; とその他すべてがゼロで埋め込まれたテンソルを返します。対角線は次のように計算されます。</target>
        </trans-unit>
        <trans-unit id="66eaeaec1eb9cbadc921ae64470886d7ed3832d0" translate="yes" xml:space="preserve">
          <source>Given a &lt;code&gt;tensor&lt;/code&gt;, and a &lt;code&gt;bool&lt;/code&gt; tensor &lt;code&gt;dims&lt;/code&gt; representing the dimensions of &lt;code&gt;tensor&lt;/code&gt;, this operation reverses each dimension i of &lt;code&gt;tensor&lt;/code&gt; where &lt;code&gt;dims[i]&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">所与 &lt;code&gt;tensor&lt;/code&gt; 、および &lt;code&gt;bool&lt;/code&gt; テンソル &lt;code&gt;dims&lt;/code&gt; の大きさを表す &lt;code&gt;tensor&lt;/code&gt; 、この動作は、各寸法I逆転 &lt;code&gt;tensor&lt;/code&gt; &lt;code&gt;dims[i]&lt;/code&gt; ある &lt;code&gt;True&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6147dea94829076776f7d46f24eec459f66088a0" translate="yes" xml:space="preserve">
          <source>Given a &lt;code&gt;tensor&lt;/code&gt;, and a &lt;code&gt;int32&lt;/code&gt; tensor &lt;code&gt;axis&lt;/code&gt; representing the set of dimensions of &lt;code&gt;tensor&lt;/code&gt; to reverse. This operation reverses each dimension &lt;code&gt;i&lt;/code&gt; for which there exists &lt;code&gt;j&lt;/code&gt; s.t. &lt;code&gt;axis[j] == i&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;tensor&lt;/code&gt; と、反転する &lt;code&gt;tensor&lt;/code&gt; の次元のセットを表す &lt;code&gt;int32&lt;/code&gt; テンソル &lt;code&gt;axis&lt;/code&gt; 与えられます。この操作は、各次元逆転 &lt;code&gt;i&lt;/code&gt; が存在するため &lt;code&gt;j&lt;/code&gt; 番目の &lt;code&gt;axis[j] == i&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1e040c53a91fa31be95603ab52d19f7c9b3eda7f" translate="yes" xml:space="preserve">
          <source>Given a Python slice &lt;code&gt;input[spec0, spec1, ..., specn]&lt;/code&gt;, this function will be called as follows.</source>
          <target state="translated">Pythonスライス &lt;code&gt;input[spec0, spec1, ..., specn]&lt;/code&gt; 、この関数は次のように呼び出されます。</target>
        </trans-unit>
        <trans-unit id="8cc9f63fb42e045b295452edd4ecb68aa07a8d87" translate="yes" xml:space="preserve">
          <source>Given a TensorSummary node_def, retrieve its SummaryDescription.</source>
          <target state="translated">TensorSummary node_defが与えられると、そのSummaryDescriptionを取得します。</target>
        </trans-unit>
        <trans-unit id="9dd17d0fb7fb4fa3b12e4e69ca28248800ac81b7" translate="yes" xml:space="preserve">
          <source>Given a list &lt;code&gt;x&lt;/code&gt; and a list &lt;code&gt;y&lt;/code&gt;, this operation returns a list &lt;code&gt;out&lt;/code&gt; that represents all values that are in &lt;code&gt;x&lt;/code&gt; but not in &lt;code&gt;y&lt;/code&gt;. The returned list &lt;code&gt;out&lt;/code&gt; is sorted in the same order that the numbers appear in &lt;code&gt;x&lt;/code&gt; (duplicates are preserved). This operation also returns a list &lt;code&gt;idx&lt;/code&gt; that represents the position of each &lt;code&gt;out&lt;/code&gt; element in &lt;code&gt;x&lt;/code&gt;. In other words:</source>
          <target state="translated">リスト &lt;code&gt;x&lt;/code&gt; とリスト &lt;code&gt;y&lt;/code&gt; を指定すると、この操作は、 &lt;code&gt;x&lt;/code&gt; にはあるが &lt;code&gt;y&lt;/code&gt; にはないすべての値を表すリスト &lt;code&gt;out&lt;/code&gt; を返します。返されたリストの &lt;code&gt;out&lt;/code&gt; 番号がに現れるのと同じ順序でソートされた &lt;code&gt;x&lt;/code&gt; （重複は保持されます）。この操作は、 &lt;code&gt;x&lt;/code&gt; 内の各 &lt;code&gt;out&lt;/code&gt; 要素の位置を表すリスト &lt;code&gt;idx&lt;/code&gt; も返します。言い換えると：</target>
        </trans-unit>
        <trans-unit id="5c5372b4dc12fe49c83eb4b2c2b91eba162834cd" translate="yes" xml:space="preserve">
          <source>Given a list of device names, this operation returns the index of the device this op runs. The length of the list is returned in two cases: (1) Device does not exist in the given device list. (2) It is in XLA compilation.</source>
          <target state="translated">デバイス名のリストが与えられると、この操作はこの操作が実行されるデバイスのインデックスを返します。リストの長さは以下の2つの場合に返される。(1)与えられたデバイスリストにデバイスが存在しない。(2)XLAコンパイル中である。</target>
        </trans-unit>
        <trans-unit id="615eb60f085e28de1449f5a5508afeb187317b05" translate="yes" xml:space="preserve">
          <source>Given a list of string tensors of same shape, performs element-wise concatenation of the strings of the same index in all tensors.</source>
          <target state="translated">同じ形状の文字列テンソルのリストが与えられると,すべてのテンソルで同じインデックスの文字列を要素ごとに連結します.</target>
        </trans-unit>
        <trans-unit id="2f469b77293ed1ff9f0eb63bb9dae24362157619" translate="yes" xml:space="preserve">
          <source>Given a list of tensors or ragged tensors with the same rank &lt;code&gt;R&lt;/code&gt; (&lt;code&gt;R &amp;gt;= axis&lt;/code&gt;), returns a rank-&lt;code&gt;R+1&lt;/code&gt;&lt;code&gt;RaggedTensor&lt;/code&gt;&lt;code&gt;result&lt;/code&gt; such that &lt;code&gt;result[i0...iaxis]&lt;/code&gt; is &lt;code&gt;[value[i0...iaxis] for value in values]&lt;/code&gt;.</source>
          <target state="translated">同じランク &lt;code&gt;R&lt;/code&gt; （ &lt;code&gt;R &amp;gt;= axis&lt;/code&gt; ）のテンソルまたは不規則なテンソルのリストを指定すると、 &lt;code&gt;result[i0...iaxis]&lt;/code&gt; が &lt;code&gt;[value[i0...iaxis] for value in values]&lt;/code&gt; ようなランク &lt;code&gt;R+1&lt;/code&gt; &lt;code&gt;RaggedTensor&lt;/code&gt; &lt;code&gt;result&lt;/code&gt; 返します値の値]。</target>
        </trans-unit>
        <trans-unit id="799df442e0baab2b82fd8e748615a45625ee8074" translate="yes" xml:space="preserve">
          <source>Given a path to new and old vocabulary files, returns a remapping Tensor of</source>
          <target state="translated">新旧のボキャブラリーファイルへのパスが与えられると</target>
        </trans-unit>
        <trans-unit id="68c5f2c079927408ee33cb3fc0df6461ed870433" translate="yes" xml:space="preserve">
          <source>Given a per-replica value returned by &lt;code&gt;experimental_run_v2&lt;/code&gt;, say a per-example loss, the batch will be divided across all the replicas. This function allows you to aggregate across replicas and optionally also across batch elements. For example, if you have a global batch size of 8 and 2 replicas, values for examples &lt;code&gt;[0, 1, 2, 3]&lt;/code&gt; will be on replica 0 and &lt;code&gt;[4, 5, 6, 7]&lt;/code&gt; will be on replica 1. By default, &lt;code&gt;reduce&lt;/code&gt; will just aggregate across replicas, returning &lt;code&gt;[0+4, 1+5, 2+6, 3+7]&lt;/code&gt;. This is useful when each replica is computing a scalar or some other value that doesn't have a &quot;batch&quot; dimension (like a gradient). More often you will want to aggregate across the global batch, which you can get by specifying the batch dimension as the &lt;code&gt;axis&lt;/code&gt;, typically &lt;code&gt;axis=0&lt;/code&gt;. In this case it would return a scalar &lt;code&gt;0+1+2+3+4+5+6+7&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;experimental_run_v2&lt;/code&gt; によって返されるレプリカごとの値、たとえば、サンプルごとの損失が与えられると、バッチはすべてのレプリカに分割されます。この関数を使用すると、レプリカ全体、およびオプションでバッチ要素全体を集約できます。たとえば、レプリカのグローバルバッチサイズが8および2の場合、例 &lt;code&gt;[0, 1, 2, 3]&lt;/code&gt; はレプリカ0にあり、 &lt;code&gt;[4, 5, 6, 7]&lt;/code&gt; 4、5、6、7 ]はレプリカ1にあります。デフォルトでは、 &lt;code&gt;reduce&lt;/code&gt; はレプリカ間で集約するだけで、 &lt;code&gt;[0+4, 1+5, 2+6, 3+7]&lt;/code&gt; 4、1 + 5、2 + 6、3 + 7]を返します。これは、各レプリカがスカラーまたは「バッチ」ディメンション（グラデーションのような）を持たないその他の値を計算している場合に役立ちます。多くの場合、グローバルバッチ全体で集計する必要があります。これは、バッチディメンションを &lt;code&gt;axis&lt;/code&gt; （通常は &lt;code&gt;axis=0&lt;/code&gt; )として指定することで取得できます。この場合、スカラー &lt;code&gt;0+1+2+3+4+5+6+7&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="fba44d6afcce2f9092396c74380f9a0d2335aa38" translate="yes" xml:space="preserve">
          <source>Given a per-replica value returned by &lt;code&gt;run&lt;/code&gt;, say a per-example loss, the batch will be divided across all the replicas. This function allows you to aggregate across replicas and optionally also across batch elements. For example, if you have a global batch size of 8 and 2 replicas, values for examples &lt;code&gt;[0, 1, 2, 3]&lt;/code&gt; will be on replica 0 and &lt;code&gt;[4, 5, 6, 7]&lt;/code&gt; will be on replica 1. By default, &lt;code&gt;reduce&lt;/code&gt; will just aggregate across replicas, returning &lt;code&gt;[0+4, 1+5, 2+6, 3+7]&lt;/code&gt;. This is useful when each replica is computing a scalar or some other value that doesn't have a &quot;batch&quot; dimension (like a gradient). More often you will want to aggregate across the global batch, which you can get by specifying the batch dimension as the &lt;code&gt;axis&lt;/code&gt;, typically &lt;code&gt;axis=0&lt;/code&gt;. In this case it would return a scalar &lt;code&gt;0+1+2+3+4+5+6+7&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;run&lt;/code&gt; によって返されるレプリカごとの値、たとえば例ごとの損失が与えられると、バッチはすべてのレプリカに分割されます。この機能を使用すると、レプリカ間、およびオプションでバッチ要素間で集計できます。たとえば、グローバルバッチサイズが8と2のレプリカである場合、例 &lt;code&gt;[0, 1, 2, 3]&lt;/code&gt; はレプリカ0にあり、 &lt;code&gt;[4, 5, 6, 7]&lt;/code&gt; 4、5、6、7 ]はレプリカ1にあります。デフォルトでは、 &lt;code&gt;reduce&lt;/code&gt; はレプリカ間で集約され、 &lt;code&gt;[0+4, 1+5, 2+6, 3+7]&lt;/code&gt; 4、1 + 5、2 + 6、3 +7]を返します。これは、各レプリカが「バッチ」次元（グラデーションなど）を持たないスカラーまたはその他の値を計算している場合に役立ちます。多くの場合、グローバルバッチ全体で集計する必要があります。これは、バッチディメンションをとして指定することで取得できます。 &lt;code&gt;axis&lt;/code&gt; 、通常は &lt;code&gt;axis=0&lt;/code&gt; 。この場合、スカラー &lt;code&gt;0+1+2+3+4+5+6+7&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="d356be63c806d4a57d873a70be815c506a549419" translate="yes" xml:space="preserve">
          <source>Given a python function &lt;code&gt;func&lt;/code&gt; wrap this function as an operation in a TensorFlow function. &lt;code&gt;func&lt;/code&gt; must take numpy arrays as its arguments and return numpy arrays as its outputs.</source>
          <target state="translated">Python関数 &lt;code&gt;func&lt;/code&gt; を指定すると、この関数はTensorFlow関数の操作としてラップされます。 &lt;code&gt;func&lt;/code&gt; はnumpy配列を引数として取り、numpy配列を出力として返す必要があります。</target>
        </trans-unit>
        <trans-unit id="3a5b52f136266fe244292b77181eab18685d5599" translate="yes" xml:space="preserve">
          <source>Given a python function &lt;code&gt;func&lt;/code&gt;, which takes numpy arrays as its arguments and returns numpy arrays as its outputs, wrap this function as an operation in a TensorFlow graph. The following snippet constructs a simple TensorFlow graph that invokes the &lt;code&gt;np.sinh()&lt;/code&gt; NumPy function as a operation in the graph:</source>
          <target state="translated">numpy配列を引数として取り、numpy配列を出力として返すPython関数 &lt;code&gt;func&lt;/code&gt; を指定すると、この関数をTensorFlowグラフの操作としてラップします。次のスニペットは、 &lt;code&gt;np.sinh()&lt;/code&gt; NumPy関数をグラフの操作として呼び出す単純なTensorFlowグラフを作成します。</target>
        </trans-unit>
        <trans-unit id="04e5711a5b38ba52b6a8792b3c7feb0ca529ddd8" translate="yes" xml:space="preserve">
          <source>Given a quantized tensor described by &lt;code&gt;(input, input_min, input_max)&lt;/code&gt;, outputs a range that covers the actual values present in that tensor. This op is typically used to produce the &lt;code&gt;requested_output_min&lt;/code&gt; and &lt;code&gt;requested_output_max&lt;/code&gt; for &lt;code&gt;Requantize&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;(input, input_min, input_max)&lt;/code&gt; で記述された量子化テンソルが与えられると、そのテンソルに存在する実際の値をカバーする範囲を出力します。このオペアンプは、一般的に生成するために使用され &lt;code&gt;requested_output_min&lt;/code&gt; と &lt;code&gt;requested_output_max&lt;/code&gt; ための &lt;code&gt;Requantize&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d3da234c855426da94c463431671a4c43997129c" translate="yes" xml:space="preserve">
          <source>Given a single tensor (&lt;code&gt;tensor&lt;/code&gt;), this operation returns a tensor of the same type and shape as &lt;code&gt;tensor&lt;/code&gt; with all elements set to 1. Optionally, you can specify a new type (&lt;code&gt;dtype&lt;/code&gt;) for the returned tensor.</source>
          <target state="translated">単一のテンソル（ &lt;code&gt;tensor&lt;/code&gt; ）を指定すると、この操作は、すべての要素が1に設定された &lt;code&gt;tensor&lt;/code&gt; と同じタイプと形状のテンソルを返します。オプションで、返されるテンソルに新しいタイプ（ &lt;code&gt;dtype&lt;/code&gt; ）を指定できます。</target>
        </trans-unit>
        <trans-unit id="cef540646f64962527a87cdc8b09906dde5432ac" translate="yes" xml:space="preserve">
          <source>Given a single tensor (&lt;code&gt;tensor&lt;/code&gt;), this operation returns a tensor of the same type and shape as &lt;code&gt;tensor&lt;/code&gt; with all elements set to 1. Optionally, you can use &lt;code&gt;dtype&lt;/code&gt; to specify a new type for the returned tensor.</source>
          <target state="translated">単一のテンソル（ &lt;code&gt;tensor&lt;/code&gt; ）を指定すると、この操作は、すべての要素が1に設定された &lt;code&gt;tensor&lt;/code&gt; と同じタイプと形状のテンソルを返します。オプションで、 &lt;code&gt;dtype&lt;/code&gt; を使用して、返されるテンソルの新しいタイプを指定できます。</target>
        </trans-unit>
        <trans-unit id="f197c0d34900084408842c4f3cb206307ffb52c6" translate="yes" xml:space="preserve">
          <source>Given a single tensor (&lt;code&gt;tensor&lt;/code&gt;), this operation returns a tensor of the same type and shape as &lt;code&gt;tensor&lt;/code&gt; with all elements set to zero. Optionally, you can use &lt;code&gt;dtype&lt;/code&gt; to specify a new type for the returned tensor.</source>
          <target state="translated">単一のテンソル（ &lt;code&gt;tensor&lt;/code&gt; ）が与えられると、この操作はすべての要素がゼロに設定された &lt;code&gt;tensor&lt;/code&gt; と同じタイプと形状のテンソルを返します。オプションで、 &lt;code&gt;dtype&lt;/code&gt; を使用して、返されるテンソルの新しいタイプを指定できます。</target>
        </trans-unit>
        <trans-unit id="f6c0b6671463b416e1fcd6a6f255b3952b13ff6a" translate="yes" xml:space="preserve">
          <source>Given a single tensor or array-like object (&lt;code&gt;input&lt;/code&gt;), this operation returns a tensor of the same type and shape as &lt;code&gt;input&lt;/code&gt; with all elements set to zero. Optionally, you can use &lt;code&gt;dtype&lt;/code&gt; to specify a new type for the returned tensor.</source>
          <target state="translated">単一のテンソルまたは配列のようなオブジェクト（ &lt;code&gt;input&lt;/code&gt; ）が与えられた場合、この操作は、すべての要素がゼロに設定された &lt;code&gt;input&lt;/code&gt; と同じタイプおよび形状のテンソルを返します。オプションで、 &lt;code&gt;dtype&lt;/code&gt; を使用して、返されるテンソルの新しいタイプを指定できます。</target>
        </trans-unit>
        <trans-unit id="10b69b4dd5bbe2b5280497f7bc6c2252eeb11d35" translate="yes" xml:space="preserve">
          <source>Given a tensor &lt;code&gt;input&lt;/code&gt; of complex numbers, this operation returns a tensor of complex numbers that are the complex conjugate of each element in &lt;code&gt;input&lt;/code&gt;. The complex numbers in &lt;code&gt;input&lt;/code&gt; must be of the form \(a + bj\), where &lt;em&gt;a&lt;/em&gt; is the real part and &lt;em&gt;b&lt;/em&gt; is the imaginary part.</source>
          <target state="translated">複素数のテンソル &lt;code&gt;input&lt;/code&gt; が与えられると、この演算は &lt;code&gt;input&lt;/code&gt; の各要素の複素共役である複素数のテンソルを返します。 &lt;code&gt;input&lt;/code&gt; の複素数は\（a + bj \）の形式でなければなりません。ここで&lt;em&gt;、&lt;/em&gt;&lt;em&gt;a&lt;/em&gt;は実数部、&lt;em&gt;b&lt;/em&gt;は虚数部です。</target>
        </trans-unit>
        <trans-unit id="f4a15667395d38500d3dfc23e818236844897a6a" translate="yes" xml:space="preserve">
          <source>Given a tensor &lt;code&gt;input&lt;/code&gt; of complex numbers, this operation returns a tensor of type &lt;code&gt;float&lt;/code&gt; that is the argument of each element in &lt;code&gt;input&lt;/code&gt;. All elements in &lt;code&gt;input&lt;/code&gt; must be complex numbers of the form \(a + bj\), where &lt;em&gt;a&lt;/em&gt; is the real part and &lt;em&gt;b&lt;/em&gt; is the imaginary part.</source>
          <target state="translated">複素数のテンソル &lt;code&gt;input&lt;/code&gt; が与えられると、この操作は &lt;code&gt;input&lt;/code&gt; の各要素の引数である &lt;code&gt;float&lt;/code&gt; 型のテンソルを返します。 &lt;code&gt;input&lt;/code&gt; すべての要素は、\（a + bj \）の形式の複素数である必要があります。ここで&lt;em&gt;、&lt;/em&gt;&lt;em&gt;a&lt;/em&gt;は実数部、&lt;em&gt;b&lt;/em&gt;は虚数部です。</target>
        </trans-unit>
        <trans-unit id="af4da35de23a457876e5d3da3d8ccad06ca104b4" translate="yes" xml:space="preserve">
          <source>Given a tensor &lt;code&gt;input&lt;/code&gt; of complex numbers, this operation returns a tensor of type &lt;code&gt;float&lt;/code&gt; that is the imaginary part of each element in &lt;code&gt;input&lt;/code&gt;. All elements in &lt;code&gt;input&lt;/code&gt; must be complex numbers of the form \(a + bj\), where &lt;em&gt;a&lt;/em&gt; is the real part and &lt;em&gt;b&lt;/em&gt; is the imaginary part returned by this operation.</source>
          <target state="translated">複素数のテンソル &lt;code&gt;input&lt;/code&gt; が与えられると、この操作は、 &lt;code&gt;input&lt;/code&gt; の各要素の虚数部であるタイプ &lt;code&gt;float&lt;/code&gt; のテンソルを返します。 &lt;code&gt;input&lt;/code&gt; 内のすべての要素は、\（a + bj \）の形式の複素数である必要があります。ここで&lt;em&gt;、&lt;/em&gt;&lt;em&gt;a&lt;/em&gt;は実数部、&lt;em&gt;b&lt;/em&gt;はこの操作によって返される虚数部です。</target>
        </trans-unit>
        <trans-unit id="7ffbcbe2d85ffbf7da6ee324f57a57f9317dabd2" translate="yes" xml:space="preserve">
          <source>Given a tensor &lt;code&gt;input&lt;/code&gt; of complex numbers, this operation returns a tensor of type &lt;code&gt;float&lt;/code&gt; that is the real part of each element in &lt;code&gt;input&lt;/code&gt;. All elements in &lt;code&gt;input&lt;/code&gt; must be complex numbers of the form \(a + bj\), where &lt;em&gt;a&lt;/em&gt; is the real part returned by this operation and &lt;em&gt;b&lt;/em&gt; is the imaginary part.</source>
          <target state="translated">複素数のテンソル &lt;code&gt;input&lt;/code&gt; が与えられると、この操作は、 &lt;code&gt;input&lt;/code&gt; の各要素の実数部である &lt;code&gt;float&lt;/code&gt; 型のテンソルを返します。 &lt;code&gt;input&lt;/code&gt; 内のすべての要素は、\（a + bj \）の形式の複素数である必要があります。ここで&lt;em&gt;、&lt;/em&gt;&lt;em&gt;a&lt;/em&gt;はこの操作によって返される実数部、&lt;em&gt;b&lt;/em&gt;は虚数部です。</target>
        </trans-unit>
        <trans-unit id="806e510667c18a0441a9ae34cf672593b9c2613d" translate="yes" xml:space="preserve">
          <source>Given a tensor &lt;code&gt;input&lt;/code&gt;, this operation inserts a dimension of 1 at the dimension index &lt;code&gt;axis&lt;/code&gt; of &lt;code&gt;input&lt;/code&gt;'s shape. The dimension index &lt;code&gt;axis&lt;/code&gt; starts at zero; if you specify a negative number for &lt;code&gt;axis&lt;/code&gt; it is counted backward from the end.</source>
          <target state="translated">テンソル &lt;code&gt;input&lt;/code&gt; 与えられると、この操作は &lt;code&gt;input&lt;/code&gt; の形状の次元インデックス &lt;code&gt;axis&lt;/code&gt; に1の次元を挿入します。次元インデックス &lt;code&gt;axis&lt;/code&gt; はゼロから始まります。 &lt;code&gt;axis&lt;/code&gt; に負の数を指定すると、最後から逆方向にカウントされます。</target>
        </trans-unit>
        <trans-unit id="d963425876592189628da6b7e7e5ed87ffb5d763" translate="yes" xml:space="preserve">
          <source>Given a tensor &lt;code&gt;input&lt;/code&gt;, this operation inserts a dimension of length 1 at the dimension index &lt;code&gt;axis&lt;/code&gt; of &lt;code&gt;input&lt;/code&gt;'s shape. The dimension index follows Python indexing rules: It's zero-based, a negative index it is counted backward from the end.</source>
          <target state="translated">テンソル &lt;code&gt;input&lt;/code&gt; 与えられると、この操作は、 &lt;code&gt;input&lt;/code&gt; の形状の寸法インデックス &lt;code&gt;axis&lt;/code&gt; に長さ1の寸法を挿入します。ディメンションインデックスはPythonインデックスルールに従います。これはゼロベースであり、最後から逆方向にカウントされる負のインデックスです。</target>
        </trans-unit>
        <trans-unit id="1431dbed06794c8031819f2ace8f4c705283bdec" translate="yes" xml:space="preserve">
          <source>Given a tensor &lt;code&gt;input&lt;/code&gt;, this operation inserts a dimension of length 1 at the dimension index &lt;code&gt;axis&lt;/code&gt; of &lt;code&gt;input&lt;/code&gt;'s shape. The dimension index follows python indexing rules: It's zero-based, a negative index it is counted backward from the end.</source>
          <target state="translated">テンソル &lt;code&gt;input&lt;/code&gt; 与えられると、この操作は、 &lt;code&gt;input&lt;/code&gt; の形状の寸法インデックス &lt;code&gt;axis&lt;/code&gt; に長さ1の寸法を挿入します。ディメンションインデックスはPythonインデックスルールに従います。これはゼロベースであり、最後から逆方向にカウントされる負のインデックスです。</target>
        </trans-unit>
        <trans-unit id="c286503b096f71983bf3319ebce75fc3df581ded" translate="yes" xml:space="preserve">
          <source>Given a tensor &lt;code&gt;input&lt;/code&gt;, this operation inserts a dimension of size 1 at the dimension index &lt;code&gt;axis&lt;/code&gt; of &lt;code&gt;input&lt;/code&gt;'s shape. The dimension index &lt;code&gt;axis&lt;/code&gt; starts at zero; if you specify a negative number for &lt;code&gt;axis&lt;/code&gt; it is counted backward from the end.</source>
          <target state="translated">テンソル &lt;code&gt;input&lt;/code&gt; 、この操作は、 &lt;code&gt;input&lt;/code&gt; の形状の次元インデックス &lt;code&gt;axis&lt;/code&gt; にサイズ1の次元を挿入します。次元インデックス &lt;code&gt;axis&lt;/code&gt; はゼロから始まります。 &lt;code&gt;axis&lt;/code&gt; に負の数を指定すると、最後から逆方向にカウントされます。</target>
        </trans-unit>
        <trans-unit id="3a1fb94877fc4770061be1a2b9c38bdc7f0532ee" translate="yes" xml:space="preserve">
          <source>Given a tensor &lt;code&gt;input&lt;/code&gt;, this operation returns a tensor of the same type with all dimensions of size 1 removed. If you don't want to remove all size 1 dimensions, you can remove specific size 1 dimensions by specifying &lt;code&gt;axis&lt;/code&gt;.</source>
          <target state="translated">テンソル &lt;code&gt;input&lt;/code&gt; 、この演算はサイズ1のすべての次元が削除された同じタイプのテンソルを返します。すべてのサイズ1の次元を削除したくない場合は、 &lt;code&gt;axis&lt;/code&gt; を指定して、特定のサイズ1の次元を削除できます。</target>
        </trans-unit>
        <trans-unit id="bbca199d5d5cd792b1dd02ead4c9b8f3ef441f45" translate="yes" xml:space="preserve">
          <source>Given a tensor &lt;code&gt;input&lt;/code&gt;, this operation returns a tensor of type &lt;code&gt;float&lt;/code&gt; that is the argument of each element in &lt;code&gt;input&lt;/code&gt; considered as a complex number.</source>
          <target state="translated">テンソル &lt;code&gt;input&lt;/code&gt; を指定すると、この操作は、 &lt;code&gt;float&lt;/code&gt; 型のテンソルを返します。これは、複素数と見なされる &lt;code&gt;input&lt;/code&gt; の各要素の引数です。</target>
        </trans-unit>
        <trans-unit id="f3c9874b7bb8857da64e590211bda623bc98b5d1" translate="yes" xml:space="preserve">
          <source>Given a tensor &lt;code&gt;input&lt;/code&gt;, this operation returns a tensor of type &lt;code&gt;float&lt;/code&gt; that is the imaginary part of each element in &lt;code&gt;input&lt;/code&gt; considered as a complex number. If &lt;code&gt;input&lt;/code&gt; is real, a tensor of all zeros is returned.</source>
          <target state="translated">テンソル &lt;code&gt;input&lt;/code&gt; を指定すると、この操作は、 &lt;code&gt;float&lt;/code&gt; 型のテンソルを返します。これは、複素数と見なされる &lt;code&gt;input&lt;/code&gt; の各要素の虚数部です。 &lt;code&gt;input&lt;/code&gt; が実数の場合、すべてゼロのテンソルが返されます。</target>
        </trans-unit>
        <trans-unit id="becaf7789b114f2fb84f8a1c908f9499f6b0068e" translate="yes" xml:space="preserve">
          <source>Given a tensor &lt;code&gt;input&lt;/code&gt;, this operation returns a tensor of type &lt;code&gt;float&lt;/code&gt; that is the real part of each element in &lt;code&gt;input&lt;/code&gt; considered as a complex number.</source>
          <target state="translated">テンソル &lt;code&gt;input&lt;/code&gt; を指定すると、この演算は、 &lt;code&gt;float&lt;/code&gt; 型のテンソルを返します。これは、複素数と見なされる &lt;code&gt;input&lt;/code&gt; の各要素の実数部です。</target>
        </trans-unit>
        <trans-unit id="a4adc764f5b83b917078bf968adc81577aa08658" translate="yes" xml:space="preserve">
          <source>Given a tensor &lt;code&gt;input&lt;/code&gt;, this operation returns a tensor that has the same buffer data as &lt;code&gt;input&lt;/code&gt; with datatype &lt;code&gt;type&lt;/code&gt;.</source>
          <target state="translated">テンソル &lt;code&gt;input&lt;/code&gt; 、この演算は、データ &lt;code&gt;type&lt;/code&gt; &lt;code&gt;input&lt;/code&gt; と同じバッファーデータを持つテンソルを返します。</target>
        </trans-unit>
        <trans-unit id="44c0e89f9a11fab2d9da2eab4b6ba9dad61347c2" translate="yes" xml:space="preserve">
          <source>Given a tensor &lt;code&gt;inputs&lt;/code&gt;, moments are calculated and normalization is performed across the axes specified in &lt;code&gt;axis&lt;/code&gt;.</source>
          <target state="translated">テンソル &lt;code&gt;inputs&lt;/code&gt; 与えられると、モーメントが計算され、軸で指定された &lt;code&gt;axis&lt;/code&gt; 全体で正規化が実行されます。</target>
        </trans-unit>
        <trans-unit id="b01a7ab9f6ce08221630a8a12ac493ef6aa5e0f2" translate="yes" xml:space="preserve">
          <source>Given a tensor &lt;code&gt;real&lt;/code&gt; representing the real part of a complex number, and a tensor &lt;code&gt;imag&lt;/code&gt; representing the imaginary part of a complex number, this operation returns complex numbers elementwise of the form \(a + bj\), where &lt;em&gt;a&lt;/em&gt; represents the &lt;code&gt;real&lt;/code&gt; part and &lt;em&gt;b&lt;/em&gt; represents the &lt;code&gt;imag&lt;/code&gt; part.</source>
          <target state="translated">複素数の実数部を表すテンソル &lt;code&gt;real&lt;/code&gt; と、複素数の虚数部を表すテンソル &lt;code&gt;imag&lt;/code&gt; が与えられると、この演算は\（a + bj \）の形式で要素ごとに複素数を返します。ここで&lt;em&gt;、a&lt;/em&gt;は &lt;code&gt;real&lt;/code&gt; 部を表し、&lt;em&gt;b&lt;/em&gt;は &lt;code&gt;imag&lt;/code&gt; パーツを表します。</target>
        </trans-unit>
        <trans-unit id="4cde684e0bf3170cd69db48357176ad6f8be05bf" translate="yes" xml:space="preserve">
          <source>Given a tensor &lt;code&gt;sp_input&lt;/code&gt;, this operation inserts a dimension of 1 at the dimension index &lt;code&gt;axis&lt;/code&gt; of &lt;code&gt;sp_input&lt;/code&gt;'s shape. The dimension index &lt;code&gt;axis&lt;/code&gt; starts at zero; if you specify a negative number for &lt;code&gt;axis&lt;/code&gt; it is counted backwards from the end.</source>
          <target state="translated">テンソル &lt;code&gt;sp_input&lt;/code&gt; を指定すると、この操作は、 &lt;code&gt;sp_input&lt;/code&gt; の形状の次元インデックス &lt;code&gt;axis&lt;/code&gt; に1の次元を挿入します。次元インデックス &lt;code&gt;axis&lt;/code&gt; はゼロから始まります。 &lt;code&gt;axis&lt;/code&gt; に負の数を指定すると、最後から逆方向にカウントされます。</target>
        </trans-unit>
        <trans-unit id="c7e431d8c1e8a94cc9f6ddda87a3198f535026e6" translate="yes" xml:space="preserve">
          <source>Given a tensor &lt;code&gt;t&lt;/code&gt;, and a maximum clip value &lt;code&gt;clip_norm&lt;/code&gt;, this operation normalizes &lt;code&gt;t&lt;/code&gt; so that its L2-norm is less than or equal to &lt;code&gt;clip_norm&lt;/code&gt;, along the dimensions given in &lt;code&gt;axes&lt;/code&gt;. Specifically, in the default case where all dimensions are used for calculation, if the L2-norm of &lt;code&gt;t&lt;/code&gt; is already less than or equal to &lt;code&gt;clip_norm&lt;/code&gt;, then &lt;code&gt;t&lt;/code&gt; is not modified. If the L2-norm is greater than &lt;code&gt;clip_norm&lt;/code&gt;, then this operation returns a tensor of the same type and shape as &lt;code&gt;t&lt;/code&gt; with its values set to:</source>
          <target state="translated">テンソル &lt;code&gt;t&lt;/code&gt; と最大クリップ値 &lt;code&gt;clip_norm&lt;/code&gt; が与えられると、この操作は &lt;code&gt;t&lt;/code&gt; を正規化して、そのL2ノルムが &lt;code&gt;axes&lt;/code&gt; 指定された次元に沿って &lt;code&gt;clip_norm&lt;/code&gt; 以下になるようにします。特に、すべての次元が計算に使用されるデフォルトのケースでは、 &lt;code&gt;t&lt;/code&gt; の L2ノルムが既に &lt;code&gt;clip_norm&lt;/code&gt; 以下である場合、 &lt;code&gt;t&lt;/code&gt; は変更されません。 L2-ノルムが &lt;code&gt;clip_norm&lt;/code&gt; より大きい場合、この操作は &lt;code&gt;t&lt;/code&gt; と同じタイプと形状のテンソルを返し、その値は次のように設定されます。</target>
        </trans-unit>
        <trans-unit id="0fb66188586afb5dfa9ed28d0d11ecbbd9aa6324" translate="yes" xml:space="preserve">
          <source>Given a tensor &lt;code&gt;t&lt;/code&gt;, and a maximum clip value &lt;code&gt;clip_norm&lt;/code&gt;, this operation normalizes &lt;code&gt;t&lt;/code&gt; so that its average L2-norm is less than or equal to &lt;code&gt;clip_norm&lt;/code&gt;. Specifically, if the average L2-norm is already less than or equal to &lt;code&gt;clip_norm&lt;/code&gt;, then &lt;code&gt;t&lt;/code&gt; is not modified. If the average L2-norm is greater than &lt;code&gt;clip_norm&lt;/code&gt;, then this operation returns a tensor of the same type and shape as &lt;code&gt;t&lt;/code&gt; with its values set to:</source>
          <target state="translated">テンソル &lt;code&gt;t&lt;/code&gt; と最大クリップ値 &lt;code&gt;clip_norm&lt;/code&gt; を指定すると、この操作は &lt;code&gt;t&lt;/code&gt; を正規化して、その平均L2ノルムが &lt;code&gt;clip_norm&lt;/code&gt; 以下になるようにします。特に、平均L2ノルムが既に &lt;code&gt;clip_norm&lt;/code&gt; 以下である場合、 &lt;code&gt;t&lt;/code&gt; は変更されません。平均L2ノルムが &lt;code&gt;clip_norm&lt;/code&gt; より大きい場合、この操作は &lt;code&gt;t&lt;/code&gt; と同じタイプと形状のテンソルを返し、その値は次のように設定されます。</target>
        </trans-unit>
        <trans-unit id="7007bafda729e071b7b16ae3d3a78dcbb3100276" translate="yes" xml:space="preserve">
          <source>Given a tensor &lt;code&gt;t&lt;/code&gt;, this operation returns a tensor of the same type and shape as &lt;code&gt;t&lt;/code&gt; with its values clipped to &lt;code&gt;clip_value_min&lt;/code&gt; and &lt;code&gt;clip_value_max&lt;/code&gt;. Any values less than &lt;code&gt;clip_value_min&lt;/code&gt; are set to &lt;code&gt;clip_value_min&lt;/code&gt;. Any values greater than &lt;code&gt;clip_value_max&lt;/code&gt; are set to &lt;code&gt;clip_value_max&lt;/code&gt;.</source>
          <target state="translated">テンソル &lt;code&gt;t&lt;/code&gt; が与えられると、この操作は &lt;code&gt;t&lt;/code&gt; と同じタイプおよび形状のテンソルを返し、その値は &lt;code&gt;clip_value_min&lt;/code&gt; および &lt;code&gt;clip_value_max&lt;/code&gt; にクリップされます。 &lt;code&gt;clip_value_min&lt;/code&gt; より小さい値はすべてclip_value_minに設定され &lt;code&gt;clip_value_min&lt;/code&gt; 。 &lt;code&gt;clip_value_max&lt;/code&gt; より大きい値はすべてclip_value_maxに設定され &lt;code&gt;clip_value_max&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4d793504d9a2641fdc838d8a324aa0f0d9bef081" translate="yes" xml:space="preserve">
          <source>Given a tensor &lt;code&gt;x&lt;/code&gt; and a tensor &lt;code&gt;y&lt;/code&gt;, this operation computes \(x^y\) for corresponding elements in &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;. For example:</source>
          <target state="translated">テンソル &lt;code&gt;x&lt;/code&gt; とテンソル &lt;code&gt;y&lt;/code&gt; を指定すると、この演算は &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; の対応する要素の\（x ^ y \）を計算します。例えば：</target>
        </trans-unit>
        <trans-unit id="1d97acda758edb9bf66a685f144f3b117ce1c753" translate="yes" xml:space="preserve">
          <source>Given a tensor &lt;code&gt;x&lt;/code&gt; of complex numbers, this operation returns a tensor of type &lt;code&gt;float32&lt;/code&gt; or &lt;code&gt;float64&lt;/code&gt; that is the absolute value of each element in &lt;code&gt;x&lt;/code&gt;. All elements in &lt;code&gt;x&lt;/code&gt; must be complex numbers of the form \(a + bj\). The absolute value is computed as \( \sqrt{a^2 + b^2}\). For example:</source>
          <target state="translated">複素数のテンソル &lt;code&gt;x&lt;/code&gt; が与えられると、この演算は &lt;code&gt;x&lt;/code&gt; の各要素の絶対値である &lt;code&gt;float32&lt;/code&gt; または &lt;code&gt;float64&lt;/code&gt; 型のテンソルを返します。 &lt;code&gt;x&lt;/code&gt; のすべての要素は、\（a + bj \）の形式の複素数でなければなりません。絶対値は\（\ sqrt {a ^ 2 + b ^ 2} \）として計算されます。例えば：</target>
        </trans-unit>
        <trans-unit id="f9f18c0deb0b747c5c85a2f0f9afacc8bc3635a6" translate="yes" xml:space="preserve">
          <source>Given a tensor &lt;code&gt;x&lt;/code&gt; of complex numbers, this operation returns a tensor of type &lt;code&gt;float32&lt;/code&gt; or &lt;code&gt;float64&lt;/code&gt; that is the absolute value of each element in &lt;code&gt;x&lt;/code&gt;. For a complex number \(a + bj\), its absolute value is computed as \(\sqrt{a^2</source>
          <target state="translated">テンソル所与 &lt;code&gt;x&lt;/code&gt; 複素数の、この動作は、型のテンソル返し &lt;code&gt;float32&lt;/code&gt; 又は &lt;code&gt;float64&lt;/code&gt; の各要素の絶対値である &lt;code&gt;x&lt;/code&gt; 。複素数\（a + bj \）の場合、その絶対値は\（\ sqrt {a ^ 2</target>
        </trans-unit>
        <trans-unit id="355cf8ae9246c456614b457edc04fdaeb78e33b1" translate="yes" xml:space="preserve">
          <source>Given a tensor &lt;code&gt;x&lt;/code&gt; of complex numbers, this operation returns a tensor of type &lt;code&gt;float&lt;/code&gt; or &lt;code&gt;double&lt;/code&gt; that is the absolute value of each element in &lt;code&gt;x&lt;/code&gt;. All elements in &lt;code&gt;x&lt;/code&gt; must be complex numbers of the form \(a + bj\). The absolute value is computed as \( \sqrt{a^2 + b^2}\).</source>
          <target state="translated">複素数のテンソル &lt;code&gt;x&lt;/code&gt; が与えられると、この操作は、 &lt;code&gt;x&lt;/code&gt; の各要素の絶対値である &lt;code&gt;float&lt;/code&gt; 型または &lt;code&gt;double&lt;/code&gt; 型のテンソルを返します。 &lt;code&gt;x&lt;/code&gt; のすべての要素は、\（a + bj \）の形式の複素数でなければなりません。絶対値は\（\ sqrt {a ^ 2 + b ^ 2} \）として計算されます。</target>
        </trans-unit>
        <trans-unit id="20000a209981bca529c2a5888aeb027dca5cb186" translate="yes" xml:space="preserve">
          <source>Given a tensor &lt;code&gt;x&lt;/code&gt;, this operation returns a tensor containing the absolute value of each element in &lt;code&gt;x&lt;/code&gt;. For example, if x is an input element and y is an output element, this operation computes \(y = |x|\).</source>
          <target state="translated">テンソル &lt;code&gt;x&lt;/code&gt; が与えられると、この操作は &lt;code&gt;x&lt;/code&gt; の各要素の絶対値を含むテンソルを返します。たとえば、xが入力要素で、yが出力要素の場合、この操作は\（y = | x | \）を計算します。</target>
        </trans-unit>
        <trans-unit id="bd81862ba7b8de323d4dc65742b6a0e0fc609451" translate="yes" xml:space="preserve">
          <source>Given a tensor of integer or floating-point values, this operation returns a tensor of the same type, where each element contains the absolute value of the corresponding element in the input.</source>
          <target state="translated">整数値または浮動小数点値のテンソルが与えられると、この操作は同じ型のテンソルを返し、各要素には入力内の対応する要素の絶対値が含まれます。</target>
        </trans-unit>
        <trans-unit id="322b12c73859d8a9e4e7944b435ecab925a5124e" translate="yes" xml:space="preserve">
          <source>Given a tuple or list of tensors &lt;code&gt;t_list&lt;/code&gt;, and a clipping ratio &lt;code&gt;clip_norm&lt;/code&gt;, this operation returns a list of clipped tensors &lt;code&gt;list_clipped&lt;/code&gt; and the global norm (&lt;code&gt;global_norm&lt;/code&gt;) of all tensors in &lt;code&gt;t_list&lt;/code&gt;. Optionally, if you've already computed the global norm for &lt;code&gt;t_list&lt;/code&gt;, you can specify the global norm with &lt;code&gt;use_norm&lt;/code&gt;.</source>
          <target state="translated">テンソル &lt;code&gt;t_list&lt;/code&gt; のタプルまたはリスト、およびクリッピング比率 &lt;code&gt;clip_norm&lt;/code&gt; を指定すると、この操作は、クリッピングされたテンソル &lt;code&gt;list_clipped&lt;/code&gt; のリストとt_list内のすべてのテンソルのグローバルノルム（ &lt;code&gt;global_norm&lt;/code&gt; ）を &lt;code&gt;t_list&lt;/code&gt; ます。あなたは既にのためのグローバルな規範を計算した場合、必要に応じて、 &lt;code&gt;t_list&lt;/code&gt; 、あなたがグローバルな規範を指定することができます &lt;code&gt;use_norm&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fb5b0e16debf84a9c22080f3acaefe368e00fdb9" translate="yes" xml:space="preserve">
          <source>Given a tuple or list of tensors &lt;code&gt;t_list&lt;/code&gt;, this operation returns the global norm of the elements in all tensors in &lt;code&gt;t_list&lt;/code&gt;. The global norm is computed as:</source>
          <target state="translated">テンソルのタプルまたはリスト &lt;code&gt;t_list&lt;/code&gt; を指定すると、この操作は &lt;code&gt;t_list&lt;/code&gt; のすべてのテンソルの要素のグローバルノルムを返します。グローバルノルムは次のように計算されます。</target>
        </trans-unit>
        <trans-unit id="73d8bb2fac3b21f66c499488e5209e33bb02392c" translate="yes" xml:space="preserve">
          <source>Given an &lt;code&gt;IndexedSlices&lt;/code&gt; instance &lt;code&gt;a&lt;/code&gt;, returns another &lt;code&gt;IndexedSlices&lt;/code&gt; that contains a subset of the slices of &lt;code&gt;a&lt;/code&gt;. Only the slices at indices not specified in &lt;code&gt;mask_indices&lt;/code&gt; are returned.</source>
          <target state="translated">所与 &lt;code&gt;IndexedSlices&lt;/code&gt; インスタンス &lt;code&gt;a&lt;/code&gt; 、別の戻り &lt;code&gt;IndexedSlices&lt;/code&gt; のスライスのサブセットを含んでいます。 &lt;code&gt;mask_indices&lt;/code&gt; で指定されていないインデックスのスライスのみが返されます。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4876f0e9062c0cf2e7752902c9a4b28f41eb1e86" translate="yes" xml:space="preserve">
          <source>Given an &lt;code&gt;input&lt;/code&gt; shaped &lt;code&gt;[s0, s1, ..., s_n]&lt;/code&gt;, the output is a &lt;code&gt;uint8&lt;/code&gt; tensor shaped &lt;code&gt;[s0, s1, ..., s_n / 8]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;[s0, s1, ..., s_n]&lt;/code&gt; 形をした &lt;code&gt;input&lt;/code&gt; 与えられると、出力は &lt;code&gt;[s0, s1, ..., s_n / 8]&lt;/code&gt; 形をした &lt;code&gt;uint8&lt;/code&gt; テンソルになります。</target>
        </trans-unit>
        <trans-unit id="6eb4a575261e442800cb08021cae257d7dca9d5e" translate="yes" xml:space="preserve">
          <source>Given an arbitrary function, wrap it so that it does variable sharing.</source>
          <target state="translated">任意の関数が与えられた場合、それが変数共有を行うようにラップします。</target>
        </trans-unit>
        <trans-unit id="18296fc4ebda93cac42fe65939317a047745ed5f" translate="yes" xml:space="preserve">
          <source>Given an input tensor of shape &lt;code&gt;[batch, in_height, in_width, in_channels]&lt;/code&gt; and a filter / kernel tensor of shape &lt;code&gt;[filter_height, filter_width, in_channels, channel_multiplier]&lt;/code&gt;, containing &lt;code&gt;in_channels&lt;/code&gt; convolutional filters of depth 1, &lt;code&gt;depthwise_conv2d&lt;/code&gt; applies a different filter to each input channel (expanding from 1 channel to &lt;code&gt;channel_multiplier&lt;/code&gt; channels for each), then concatenates the results together. Thus, the output has &lt;code&gt;in_channels * channel_multiplier&lt;/code&gt; channels.</source>
          <target state="translated">形状の入力テンソル所与 &lt;code&gt;[batch, in_height, in_width, in_channels]&lt;/code&gt; 及びフィルタ/核テンソル形状の &lt;code&gt;[filter_height, filter_width, in_channels, channel_multiplier]&lt;/code&gt; 、含有 &lt;code&gt;in_channels&lt;/code&gt; 深さ1の畳み込みフィルタは、 &lt;code&gt;depthwise_conv2d&lt;/code&gt; は、各入力チャネルに異なるフィルタを適用します（1チャネルから各チャネルの &lt;code&gt;channel_multiplier&lt;/code&gt; チャネルに拡張）、結果を一緒に連結します。したがって、出力には &lt;code&gt;in_channels * channel_multiplier&lt;/code&gt; チャネルがあります。</target>
        </trans-unit>
        <trans-unit id="3e370c68e5555d480a5c4df80fb0a1826a44057c" translate="yes" xml:space="preserve">
          <source>Given an input tensor of shape &lt;code&gt;[batch, in_height, in_width, in_channels]&lt;/code&gt; and a filter / kernel tensor of shape &lt;code&gt;[filter_height, filter_width, in_channels, out_channels]&lt;/code&gt;, this op performs the following:</source>
          <target state="translated">形状の入力テンソル &lt;code&gt;[batch, in_height, in_width, in_channels]&lt;/code&gt; と形状のフィルター/カーネルテンソル &lt;code&gt;[filter_height, filter_width, in_channels, out_channels]&lt;/code&gt; 、この操作は次のことを実行します。</target>
        </trans-unit>
        <trans-unit id="1fab9d674065ff486a1c44d98d6d558e38ce4d8f" translate="yes" xml:space="preserve">
          <source>Given an input tensor of shape &lt;code&gt;batch_shape + [in_height, in_width, in_channels]&lt;/code&gt; and a filter / kernel tensor of shape &lt;code&gt;[filter_height, filter_width, in_channels, out_channels]&lt;/code&gt;, this op performs the following:</source>
          <target state="translated">形状の入力テンソル所与 &lt;code&gt;batch_shape + [in_height, in_width, in_channels]&lt;/code&gt; 及び形状のフィルタ/核テンソル &lt;code&gt;[filter_height, filter_width, in_channels, out_channels]&lt;/code&gt; 、この演算を行うには、以下：</target>
        </trans-unit>
        <trans-unit id="ed20cb19f30785b7a38934894a0dbee86a0b0123" translate="yes" xml:space="preserve">
          <source>Given an input tensor of shape &lt;code&gt;batch_shape + [in_width, in_channels]&lt;/code&gt; if &lt;code&gt;data_format&lt;/code&gt; is &lt;code&gt;&quot;NWC&quot;&lt;/code&gt;, or &lt;code&gt;batch_shape + [in_channels, in_width]&lt;/code&gt; if &lt;code&gt;data_format&lt;/code&gt; is &lt;code&gt;&quot;NCW&quot;&lt;/code&gt;, and a filter / kernel tensor of shape &lt;code&gt;[filter_width, in_channels, out_channels]&lt;/code&gt;, this op reshapes the arguments to pass them to &lt;code&gt;conv2d&lt;/code&gt; to perform the equivalent convolution operation.</source>
          <target state="translated">形状の入力テンソル所与 &lt;code&gt;batch_shape + [in_width, in_channels]&lt;/code&gt; 場合 &lt;code&gt;data_format&lt;/code&gt; ある &lt;code&gt;&quot;NWC&quot;&lt;/code&gt; 、又は &lt;code&gt;batch_shape + [in_channels, in_width]&lt;/code&gt; 場合 &lt;code&gt;data_format&lt;/code&gt; ある &lt;code&gt;&quot;NCW&quot;&lt;/code&gt; 、及び形状のフィルタ/核テンソル &lt;code&gt;[filter_width, in_channels, out_channels]&lt;/code&gt; 、この操作は、引数を &lt;code&gt;conv2d&lt;/code&gt; してconv2dに渡し、同等の畳み込み演算を実行します。</target>
        </trans-unit>
        <trans-unit id="b1c915a4b13f35d33a94d06e3847c2365262d62c" translate="yes" xml:space="preserve">
          <source>Given an input tensor of shape [batch, in_width, in_channels] if data_format is &quot;NWC&quot;, or [batch, in_channels, in_width] if data_format is &quot;NCW&quot;, and a filter / kernel tensor of shape [filter_width, in_channels, out_channels], this op reshapes the arguments to pass them to conv2d to perform the equivalent convolution operation.</source>
          <target state="translated">data_format が &quot;NWC&quot; の場合は [batch,in_width,in_channels]、data_format が &quot;NCW&quot; の場合は [batch,in_channels,in_width]の形状の入力テンソル、そして [filter_width,in_channels,out_channels]の形状のフィルタ/カーネルテンソルが与えられた場合、この操作は引数の形状を変更して conv2d に渡し、等価な畳み込み演算を実行します。</target>
        </trans-unit>
        <trans-unit id="2eb289cc3c5755f35510bd201bb3c7ba0da0f131" translate="yes" xml:space="preserve">
          <source>Given an input tensor, the function computes inverse hyperbolic cosine of every element. Input range is &lt;code&gt;[1, inf]&lt;/code&gt;. It returns &lt;code&gt;nan&lt;/code&gt; if the input lies outside the range.</source>
          <target state="translated">入力テンソルを指定すると、関数はすべての要素の逆双曲線余弦を計算します。入力範囲は &lt;code&gt;[1, inf]&lt;/code&gt; です。入力が範囲外の場合、 &lt;code&gt;nan&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="c2276090897040e0aeeaafa324236781f22316e6" translate="yes" xml:space="preserve">
          <source>Given an input tensor, this function computes cosine of every element in the tensor. Input range is &lt;code&gt;(-inf, inf)&lt;/code&gt; and output range is &lt;code&gt;[-1,1]&lt;/code&gt;. If input lies outside the boundary, &lt;code&gt;nan&lt;/code&gt; is returned.</source>
          <target state="translated">入力テンソルを指定すると、この関数はテンソル内のすべての要素の余弦を計算します。入力範囲は &lt;code&gt;(-inf, inf)&lt;/code&gt; 、出力範囲は &lt;code&gt;[-1,1]&lt;/code&gt; です。入力が境界の外にある場合、 &lt;code&gt;nan&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="6d70ae953868ca523f92404dffa44551095f71ef" translate="yes" xml:space="preserve">
          <source>Given an input tensor, this function computes hyperbolic cosine of every element in the tensor. Input range is &lt;code&gt;[-inf, inf]&lt;/code&gt; and output range is &lt;code&gt;[1, inf]&lt;/code&gt;.</source>
          <target state="translated">入力テンソルを指定すると、この関数はテンソルのすべての要素の双曲線余弦を計算します。入力範囲は &lt;code&gt;[-inf, inf]&lt;/code&gt; 、出力範囲は &lt;code&gt;[1, inf]&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="1b488ce799eb3a33791cfbd59693b393988e595b" translate="yes" xml:space="preserve">
          <source>Given an input tensor, this function computes hyperbolic sine of every element in the tensor. Input range is &lt;code&gt;[-inf,inf]&lt;/code&gt; and output range is &lt;code&gt;[-inf,inf]&lt;/code&gt;.</source>
          <target state="translated">入力テンソルが与えられると、この関数はテンソル内のすべての要素の双曲線正弦を計算します。入力範囲は &lt;code&gt;[-inf,inf]&lt;/code&gt; 、出力範囲は &lt;code&gt;[-inf,inf]&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="59df85e0619df189d8729fee687f600a54d01480" translate="yes" xml:space="preserve">
          <source>Given an input tensor, this function computes hyperbolic tangent of every element in the tensor. Input range is &lt;code&gt;[-inf, inf]&lt;/code&gt; and output range is &lt;code&gt;[-1,1]&lt;/code&gt;.</source>
          <target state="translated">入力テンソルを指定すると、この関数はテンソル内のすべての要素の双曲線正接を計算します。入力範囲は &lt;code&gt;[-inf, inf]&lt;/code&gt; 、出力範囲は &lt;code&gt;[-1,1]&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="c73b448fa482aa6531301716ace98c25a05fd5d3" translate="yes" xml:space="preserve">
          <source>Given an input tensor, this function computes inverse hyperbolic sine for every element in the tensor. Both input and output has a range of &lt;code&gt;[-inf, inf]&lt;/code&gt;.</source>
          <target state="translated">入力テンソルを指定すると、この関数はテンソルのすべての要素の逆双曲線正弦を計算します。入力と出力の両方に &lt;code&gt;[-inf, inf]&lt;/code&gt; 範囲があります。</target>
        </trans-unit>
        <trans-unit id="c25eb5c30ec69042f14f0a07e82e62d1882abacc" translate="yes" xml:space="preserve">
          <source>Given an input tensor, this function computes inverse hyperbolic tangent for every element in the tensor. Input range is &lt;code&gt;[-1,1]&lt;/code&gt; and output range is &lt;code&gt;[-inf, inf]&lt;/code&gt;. If input is &lt;code&gt;-1&lt;/code&gt;, output will be &lt;code&gt;-inf&lt;/code&gt; and if the input is &lt;code&gt;1&lt;/code&gt;, output will be &lt;code&gt;inf&lt;/code&gt;. Values outside the range will have &lt;code&gt;nan&lt;/code&gt; as output.</source>
          <target state="translated">入力テンソルを指定すると、この関数はテンソルのすべての要素の逆双曲線正接を計算します。入力範囲は &lt;code&gt;[-1,1]&lt;/code&gt; で、出力範囲は &lt;code&gt;[-inf, inf]&lt;/code&gt; です。入力が &lt;code&gt;-1&lt;/code&gt; の場合、出力は &lt;code&gt;-inf&lt;/code&gt; になり、入力が &lt;code&gt;1&lt;/code&gt; の場合、出力は &lt;code&gt;inf&lt;/code&gt; になります。範囲外の値は &lt;code&gt;nan&lt;/code&gt; として出力されます。</target>
        </trans-unit>
        <trans-unit id="ea097a1f54202798e40231d72b57eb14a2329e8c" translate="yes" xml:space="preserve">
          <source>Given an input tensor, this function computes sine of every element in the tensor. Input range is &lt;code&gt;(-inf, inf)&lt;/code&gt; and output range is &lt;code&gt;[-1,1]&lt;/code&gt;.</source>
          <target state="translated">入力テンソルを指定すると、この関数はテンソル内のすべての要素の正弦を計算します。入力範囲は &lt;code&gt;(-inf, inf)&lt;/code&gt; 、出力範囲は &lt;code&gt;[-1,1]&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="d62f8cf300097a0e2129f20828fbd0e2b4cd35f3" translate="yes" xml:space="preserve">
          <source>Given an input tensor, this function computes tangent of every element in the tensor. Input range is &lt;code&gt;(-inf, inf)&lt;/code&gt; and output range is &lt;code&gt;(-inf, inf)&lt;/code&gt;. If input lies outside the boundary, &lt;code&gt;nan&lt;/code&gt; is returned.</source>
          <target state="translated">入力テンソルを指定すると、この関数はテンソル内のすべての要素のタンジェントを計算します。入力範囲は &lt;code&gt;(-inf, inf)&lt;/code&gt; 、出力範囲は &lt;code&gt;(-inf, inf)&lt;/code&gt; です。入力が境界の外にある場合、 &lt;code&gt;nan&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="8f8bd7293b2216f6c9572d5c819802c515a646af" translate="yes" xml:space="preserve">
          <source>Given one-dimensional $z = [z_1,...,z_K]$, we define</source>
          <target state="translated">一次元 $z=[z_1,...,z_K]$ が与えられると、次のように定義します。</target>
        </trans-unit>
        <trans-unit id="08d07ac5e8ef80d326d4f12521ff24313fbce652" translate="yes" xml:space="preserve">
          <source>Given one-dimensional &lt;code&gt;z = [z_0,...,z_{K-1}]&lt;/code&gt;, we define</source>
          <target state="translated">1次元 &lt;code&gt;z = [z_0,...,z_{K-1}]&lt;/code&gt; とすると、</target>
        </trans-unit>
        <trans-unit id="48fec20fa93f6484a4d59eef4d5240def79def02" translate="yes" xml:space="preserve">
          <source>Given operation-specific seed, &lt;code&gt;op_seed&lt;/code&gt;, this helper function returns two seeds derived from graph-level and op-level seeds. Many random operations internally use the two seeds to allow user to change the seed globally for a graph, or for only specific operations.</source>
          <target state="translated">操作固有のシード &lt;code&gt;op_seed&lt;/code&gt; を指定すると、このヘルパー関数は、グラフレベルのシードと演算レベルのシードから派生した2つのシードを返します。多くのランダム操作は内部で2つのシードを使用して、ユーザーがグラフに対してグローバルに、または特定の操作のみに対してシードを変更できるようにします。</target>
        </trans-unit>
        <trans-unit id="3c4cfb563b251c993c875f25d14c9e568e980107" translate="yes" xml:space="preserve">
          <source>Given random variable &lt;code&gt;X&lt;/code&gt; and &lt;code&gt;p in [0, 1]&lt;/code&gt;, the &lt;code&gt;quantile&lt;/code&gt; is:</source>
          <target state="translated">&lt;code&gt;p in [0, 1]&lt;/code&gt; 確率変数 &lt;code&gt;X&lt;/code&gt; とpが与えられると、 &lt;code&gt;quantile&lt;/code&gt; は次のようになります。</target>
        </trans-unit>
        <trans-unit id="11ff9e9f8b087477a5e4158b4134eac9b64e6878" translate="yes" xml:space="preserve">
          <source>Given random variable &lt;code&gt;X&lt;/code&gt;, the cumulative distribution function &lt;code&gt;cdf&lt;/code&gt; is:</source>
          <target state="translated">確率変数 &lt;code&gt;X&lt;/code&gt; が与えられると、累積分布関数 &lt;code&gt;cdf&lt;/code&gt; は次のようになります。</target>
        </trans-unit>
        <trans-unit id="fa3f3691f019bbd881a265ec5bccfb1211e3ad29" translate="yes" xml:space="preserve">
          <source>Given random variable &lt;code&gt;X&lt;/code&gt;, the survival function is defined:</source>
          <target state="translated">確率変数 &lt;code&gt;X&lt;/code&gt; が与えられると、生存関数が定義されます。</target>
        </trans-unit>
        <trans-unit id="55eaa8e915c7da17162d07889c59a5355bf928ae" translate="yes" xml:space="preserve">
          <source>Given that some ops may be partially supported, the optimal way to determine if a model's operations are supported is by converting using the TensorFlow Lite converter.</source>
          <target state="translated">一部の操作が部分的にサポートされている可能性があることを考えると、モデルの操作がサポートされているかどうかを判断する最適な方法は、TensorFlow Liteコンバータを使用して変換することです。</target>
        </trans-unit>
        <trans-unit id="9f078ae5dde89ed67ae2cd1d678f26fb93674467" translate="yes" xml:space="preserve">
          <source>Given the blockwise &lt;code&gt;n + 1&lt;/code&gt;-by-&lt;code&gt;n + 1&lt;/code&gt; linear operator:</source>
          <target state="translated">ブロック単位の &lt;code&gt;n + 1&lt;/code&gt; x &lt;code&gt;n + 1&lt;/code&gt; 線形演算子が与えられます：</target>
        </trans-unit>
        <trans-unit id="0153812f9d215780555e110de846d070c2d1cb32" translate="yes" xml:space="preserve">
          <source>Given the tensor &lt;code&gt;values&lt;/code&gt;, this operation returns a rank 1 &lt;code&gt;Tensor&lt;/code&gt; representing the indices of a histogram into which each element of &lt;code&gt;values&lt;/code&gt; would be binned. The bins are equal width and determined by the arguments &lt;code&gt;value_range&lt;/code&gt; and &lt;code&gt;nbins&lt;/code&gt;.</source>
          <target state="translated">テンソル &lt;code&gt;values&lt;/code&gt; 、この演算は、 &lt;code&gt;values&lt;/code&gt; 各要素がビニングされるヒストグラムのインデックスを表すランク1の &lt;code&gt;Tensor&lt;/code&gt; 返します。ビンは同じ幅であり、引数 &lt;code&gt;value_range&lt;/code&gt; および &lt;code&gt;nbins&lt;/code&gt; によって決定されます。</target>
        </trans-unit>
        <trans-unit id="a9c47520102d0ea0d116c89df4867da9b1a8141e" translate="yes" xml:space="preserve">
          <source>Given the tensor &lt;code&gt;values&lt;/code&gt;, this operation returns a rank 1 histogram counting the number of entries in &lt;code&gt;values&lt;/code&gt; that fall into every bin. The bins are equal width and determined by the arguments &lt;code&gt;value_range&lt;/code&gt; and &lt;code&gt;nbins&lt;/code&gt;.</source>
          <target state="translated">テンソル &lt;code&gt;values&lt;/code&gt; 与えられると、この操作は、すべてのビンに分類される &lt;code&gt;values&lt;/code&gt; のエントリ数をカウントするランク1のヒストグラムを返します。ビンは同じ幅で、引数 &lt;code&gt;value_range&lt;/code&gt; と &lt;code&gt;nbins&lt;/code&gt; によって決定されます。</target>
        </trans-unit>
        <trans-unit id="13c5e2fbdbba7fa42de391b57a0a7d1e5d7df7f6" translate="yes" xml:space="preserve">
          <source>Given the tensor &lt;code&gt;values&lt;/code&gt;, this operation returns a rank 1 histogram counting the number of entries in &lt;code&gt;values&lt;/code&gt; that fell into every bin. The bins are equal width and determined by the arguments &lt;code&gt;value_range&lt;/code&gt; and &lt;code&gt;nbins&lt;/code&gt;.</source>
          <target state="translated">テンソル &lt;code&gt;values&lt;/code&gt; 、この操作は、すべてのビンに分類された &lt;code&gt;values&lt;/code&gt; のエントリ数をカウントするランク1のヒストグラムを返します。ビンは同じ幅であり、引数 &lt;code&gt;value_range&lt;/code&gt; および &lt;code&gt;nbins&lt;/code&gt; によって決定されます。</target>
        </trans-unit>
        <trans-unit id="54fcfc2408cd2e19b0afb43ec166a6b0b45677c6" translate="yes" xml:space="preserve">
          <source>Given two &lt;code&gt;Example&lt;/code&gt; input protos in &lt;code&gt;serialized&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;serialized&lt;/code&gt; 2つの &lt;code&gt;Example&lt;/code&gt; 入力プロトコルが与えられた場合：</target>
        </trans-unit>
        <trans-unit id="a71b5320e03ef99e09301587e5062ffa0d505637" translate="yes" xml:space="preserve">
          <source>Gives a guarantee to the TF runtime that the input tensor is a constant.</source>
          <target state="translated">入力テンソルが定数であることをTFランタイムに保証します。</target>
        </trans-unit>
        <trans-unit id="802a77a26d08463b8d182d4841500cc36b1bdeb1" translate="yes" xml:space="preserve">
          <source>Gives the log-likelihood loss between the prediction and the target under the assumption that the target has a Poisson distribution. Caveat: By default, this is not the exact loss, but the loss minus a constant term [log(z!)]. That has no effect for optimization, but does not play well with relative loss comparisons. To compute an approximation of the log factorial term, specify compute_full_loss=True to enable Stirling's Approximation.</source>
          <target state="translated">ターゲットがポアソン分布を持つと仮定した場合の、予測とターゲット間の対数尤度損失を与えます。警告:デフォルトでは、これは正確な損失ではなく、定数項[log(z!)]を差し引いた損失です。これは最適化には影響しませんが、相対損失の比較ではうまくいきません。対数階乗項の近似を計算するには、スターリングの近似を有効にするために、compute_full_loss=Trueを指定してください。</target>
        </trans-unit>
        <trans-unit id="3b375b50d76db2f1ab6e919b12e87eb3c07c7837" translate="yes" xml:space="preserve">
          <source>Global Average pooling operation for 3D data.</source>
          <target state="translated">3Dデータのグローバル平均プーリング操作。</target>
        </trans-unit>
        <trans-unit id="490733d038a485e20b685885b26cd8e1c21ac8a1" translate="yes" xml:space="preserve">
          <source>Global Max pooling operation for 3D data.</source>
          <target state="translated">3Dデータのグローバルマックスプーリング操作。</target>
        </trans-unit>
        <trans-unit id="c372dfcc5aacad73c8ba932360de7dad2d1ce972" translate="yes" xml:space="preserve">
          <source>Global average pooling operation for spatial data.</source>
          <target state="translated">空間データのグローバル平均プーリング演算</target>
        </trans-unit>
        <trans-unit id="fc8c9db4015232abf19ef2f9a55435d1ea95b1de" translate="yes" xml:space="preserve">
          <source>Global average pooling operation for temporal data.</source>
          <target state="translated">一時的なデータのためのグローバル平均プーリング操作。</target>
        </trans-unit>
        <trans-unit id="167efa62c3642366c4057325e9b1f061b9517117" translate="yes" xml:space="preserve">
          <source>Global dictionary of names to classes (&lt;code&gt;_GLOBAL_CUSTOM_OBJECTS&lt;/code&gt;).</source>
          <target state="translated">クラスへの名前のグローバル辞書（ &lt;code&gt;_GLOBAL_CUSTOM_OBJECTS&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="3b675d73c44ef2c3b5ff3ee1aee82f62c38a94d3" translate="yes" xml:space="preserve">
          <source>Global id, i.e., this field, is tracking the index of the node among ALL nodes in the cluster. It is uniquely assigned. For example, for the cluster spec given above, the global ids are assigned as:</source>
          <target state="translated">グローバルID、すなわちこのフィールドは、クラスタ内のすべてのノードの中でノードのインデックスを追跡しています。これは一意に割り当てられます。例えば、上記のクラスタ仕様では、グローバル ID は以下のように割り当てられます。</target>
        </trans-unit>
        <trans-unit id="861ea43bf3e08cfa679688d9126f736408dcc945" translate="yes" xml:space="preserve">
          <source>Global max pooling operation for 1D temporal data.</source>
          <target state="translated">1次元時間データのグローバル最大プーリング演算。</target>
        </trans-unit>
        <trans-unit id="fbaffaa9e612328e1415352ab08beb6396bb657c" translate="yes" xml:space="preserve">
          <source>Global max pooling operation for spatial data.</source>
          <target state="translated">空間データのグローバル最大プーリング動作。</target>
        </trans-unit>
        <trans-unit id="f0f40685c4fd8079767cd3b5779589f20e7497c4" translate="yes" xml:space="preserve">
          <source>Global max pooling operation for temporal data.</source>
          <target state="translated">一時的なデータのためのグローバル最大プーリング操作。</target>
        </trans-unit>
        <trans-unit id="d590e8790e10ef3fdf0c5c3d8ed595c657758ce9" translate="yes" xml:space="preserve">
          <source>Global step tensor.</source>
          <target state="translated">グローバルステップテンソル。</target>
        </trans-unit>
        <trans-unit id="fa3649b2772ac1189dcef2f8c64d20be93fd805b" translate="yes" xml:space="preserve">
          <source>Global variables are variables that are shared across machines in a distributed environment. The &lt;code&gt;Variable()&lt;/code&gt; constructor or &lt;code&gt;get_variable()&lt;/code&gt; automatically adds new variables to the graph collection &lt;code&gt;GraphKeys.GLOBAL_VARIABLES&lt;/code&gt;. This convenience function returns the contents of that collection.</source>
          <target state="translated">グローバル変数は、分散環境のマシン間で共有される変数です。 &lt;code&gt;Variable()&lt;/code&gt; コンストラクタまたは &lt;code&gt;get_variable()&lt;/code&gt; が自動的にグラフコレクションに新しい変数を追加します &lt;code&gt;GraphKeys.GLOBAL_VARIABLES&lt;/code&gt; 。この便利な関数は、そのコレクションの内容を返します。</target>
        </trans-unit>
        <trans-unit id="1e368decdd07f40f158c5a306bc7f03b270de34b" translate="yes" xml:space="preserve">
          <source>Globs for the checkpoints pointed to by &lt;code&gt;checkpoint_paths&lt;/code&gt;. If the files exist, use their mtime as the checkpoint timestamp.</source>
          <target state="translated">指さチェックポイントのためのグロブ &lt;code&gt;checkpoint_paths&lt;/code&gt; 。ファイルが存在する場合は、それらのmtimeをチェックポイントのタイムスタンプとして使用します。</target>
        </trans-unit>
        <trans-unit id="a9111e714242062acf83be49c369c220ccfcf860" translate="yes" xml:space="preserve">
          <source>Globs for the checkpoints pointed to by &lt;code&gt;checkpoint_prefixes&lt;/code&gt;. If the files exist, collect their mtime. Both V2 and V1 checkpoints are considered, in that priority.</source>
          <target state="translated">指さチェックポイントのためのグロブ &lt;code&gt;checkpoint_prefixes&lt;/code&gt; 。ファイルが存在する場合は、それらのmtimeを収集します。その優先順位では、V2とV1の両方のチェックポイントが考慮されます。</target>
        </trans-unit>
        <trans-unit id="01cc712ba5777037862cf425ce81901fb067f024" translate="yes" xml:space="preserve">
          <source>Grace period for stopping:</source>
          <target state="translated">停止のための猶予期間。</target>
        </trans-unit>
        <trans-unit id="adb359f1f87c794c325871e029c1af140effe5ec" translate="yes" xml:space="preserve">
          <source>Grace period handling: When &lt;code&gt;request_stop()&lt;/code&gt; is called, threads are given 'stop_grace_period_secs' seconds to terminate. If any of them is still alive after that period expires, a &lt;code&gt;RuntimeError&lt;/code&gt; is raised. Note that if an &lt;code&gt;exc_info&lt;/code&gt; was passed to &lt;code&gt;request_stop()&lt;/code&gt; then it is raised instead of that &lt;code&gt;RuntimeError&lt;/code&gt;.</source>
          <target state="translated">猶予期間の処理： &lt;code&gt;request_stop()&lt;/code&gt; が呼び出されると、スレッドには、終了するための「stop_grace_period_secs」秒が与えられます。それらのいずれかがその期間が経過した後もまだ生きている場合、 &lt;code&gt;RuntimeError&lt;/code&gt; が発生します。 &lt;code&gt;exc_info&lt;/code&gt; が &lt;code&gt;request_stop()&lt;/code&gt; に渡された場合、その &lt;code&gt;RuntimeError&lt;/code&gt; の代わりに発生することに注意してください。</target>
        </trans-unit>
        <trans-unit id="5149e7b8f8d0f76a4477a7c343a2d7e6cb51a37d" translate="yes" xml:space="preserve">
          <source>Grace period, in seconds, given to running threads to stop when &lt;code&gt;stop()&lt;/code&gt; is called. Defaults to 120 seconds.</source>
          <target state="translated">&lt;code&gt;stop()&lt;/code&gt; が呼び出されたときに停止する実行中のスレッドに与えられる猶予期間（秒単位）。デフォルトは120秒です。</target>
        </trans-unit>
        <trans-unit id="2c61a1c122223903dabaecda115cd172b19ae575" translate="yes" xml:space="preserve">
          <source>Gradient Boosted Trees: Model understanding</source>
          <target state="translated">グラデーション・ブーステッド・ツリー モデルの理解</target>
        </trans-unit>
        <trans-unit id="328b1e9ac6d673a9731be1b0fee1aa7f2b9bd86a" translate="yes" xml:space="preserve">
          <source>Gradient descent (with momentum) optimizer.</source>
          <target state="translated">勾配降下(運動量付き)オプティマイザー。</target>
        </trans-unit>
        <trans-unit id="0ccf5db0029889f6fecb177b4847ffd92845592b" translate="yes" xml:space="preserve">
          <source>Gradient for batch normalization.</source>
          <target state="translated">バッチ正規化のための勾配。</target>
        </trans-unit>
        <trans-unit id="da1029b1e9a2a07b646e912fc9a9abfeaf36bbac" translate="yes" xml:space="preserve">
          <source>Gradient of Unbatch.</source>
          <target state="translated">アンバッチのグラデーション。</target>
        </trans-unit>
        <trans-unit id="70f9c4b00a1e9a42e50af0c5886037373d5b1dd7" translate="yes" xml:space="preserve">
          <source>Gradient op for &lt;code&gt;MirrorPad&lt;/code&gt; op. This op folds a mirror-padded tensor.</source>
          <target state="translated">&lt;code&gt;MirrorPad&lt;/code&gt; opのグラデーションop 。この操作は、ミラーパッドのテンソルを折ります。</target>
        </trans-unit>
        <trans-unit id="194bbc5ad5da84e49dad69cbb4f32f23b69a3786" translate="yes" xml:space="preserve">
          <source>GradientTapes can be nested to compute higher-order derivatives. For example,</source>
          <target state="translated">GradientTapesは、高次の導関数を計算するために入れ子にすることができます。例えば</target>
        </trans-unit>
        <trans-unit id="418595e6c8a1cac41ef43f912bdb79ac95f52c7f" translate="yes" xml:space="preserve">
          <source>Gradients for Local Response Normalization.</source>
          <target state="translated">局所応答正規化のための勾配。</target>
        </trans-unit>
        <trans-unit id="18ab0670f94b562da8b866c0ee514e88a5366f1c" translate="yes" xml:space="preserve">
          <source>Gradients for batch normalization.</source>
          <target state="translated">バッチ正規化のためのグラデーション。</target>
        </trans-unit>
        <trans-unit id="9c2ad4a85cafc13c2d1c2d3a2971b83be82a10c3" translate="yes" xml:space="preserve">
          <source>GraphDef containing a simplified version of the original.</source>
          <target state="translated">オリジナルの簡略化されたバージョンを含むGraphDef。</target>
        </trans-unit>
        <trans-unit id="f1121f5d0ae3561a0535bf5eed70bebc9b4c573d" translate="yes" xml:space="preserve">
          <source>GraphDef object holding the network.</source>
          <target state="translated">ネットワークを保持するGraphDefオブジェクト。</target>
        </trans-unit>
        <trans-unit id="88f6daec0a60e7783e784d139db2e8caa801c093" translate="yes" xml:space="preserve">
          <source>Graphically the output tensors are:</source>
          <target state="translated">グラフィカルに出力テンソルは</target>
        </trans-unit>
        <trans-unit id="29346dfd9c70ea134e70f14b812447401491ea5b" translate="yes" xml:space="preserve">
          <source>Graphically this is equivalent to doing</source>
          <target state="translated">グラフィカルには、これは</target>
        </trans-unit>
        <trans-unit id="20a2426b7947c82cb1587611210e101486083cc8" translate="yes" xml:space="preserve">
          <source>Graphs are used by &lt;a href=&quot;function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt;s to represent the function's computations. Each graph contains a set of &lt;a href=&quot;operation&quot;&gt;&lt;code&gt;tf.Operation&lt;/code&gt;&lt;/a&gt; objects, which represent units of computation; and &lt;a href=&quot;tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt; objects, which represent the units of data that flow between operations.</source>
          <target state="translated">グラフは、関数の計算を表すために&lt;a href=&quot;function&quot;&gt; &lt;code&gt;tf.function&lt;/code&gt; &lt;/a&gt;によって使用されます。各グラフには、計算の単位を表す&lt;a href=&quot;operation&quot;&gt; &lt;code&gt;tf.Operation&lt;/code&gt; &lt;/a&gt;オブジェクトのセットが含まれています。そして&lt;a href=&quot;tensor&quot;&gt; &lt;code&gt;tf.Tensor&lt;/code&gt; は、&lt;/a&gt;操作の間を流れるデータの単位を表すオブジェクト。</target>
        </trans-unit>
        <trans-unit id="c0c7d8111372100880daccbc5bf26be1b2464f9e" translate="yes" xml:space="preserve">
          <source>Greater</source>
          <target state="translated">Greater</target>
        </trans-unit>
        <trans-unit id="f20c1c201cbb34ee5875869c7087a3e926efb3b7" translate="yes" xml:space="preserve">
          <source>GreaterEqual</source>
          <target state="translated">GreaterEqual</target>
        </trans-unit>
        <trans-unit id="e5695443f7cf0378e67e28d423fc90003e20fdde" translate="yes" xml:space="preserve">
          <source>Greedily selects a subset of bounding boxes in descending order of score,</source>
          <target state="translated">貪欲にバウンディングボックスのサブセットをスコアの降順で選択します。</target>
        </trans-unit>
        <trans-unit id="58294451a76b10d6330ff549e0a6d209d1f0896b" translate="yes" xml:space="preserve">
          <source>Greedily selects a subset of bounding boxes in descending order of score.</source>
          <target state="translated">貪欲にバウンディングボックスのサブセットをスコアの降順で選択します。</target>
        </trans-unit>
        <trans-unit id="e8494d1512cc20a8fe1e52f4aa1865ea4363ab3f" translate="yes" xml:space="preserve">
          <source>Ground truth values.</source>
          <target state="translated">根拠のある真実の価値観。</target>
        </trans-unit>
        <trans-unit id="9cc2972f01b075253d91c217637ce9f71f2218ce" translate="yes" xml:space="preserve">
          <source>Ground truth values. shape = &lt;code&gt;[batch_size, d0, .. dN]&lt;/code&gt;, except sparse loss functions such as sparse categorical crossentropy where shape = &lt;code&gt;[batch_size, d0, .. dN-1]&lt;/code&gt;</source>
          <target state="translated">グラウンドトゥルース値。shape = &lt;code&gt;[batch_size, d0, .. dN]&lt;/code&gt; 、ただし、shape = &lt;code&gt;[batch_size, d0, .. dN-1]&lt;/code&gt; スパースカテゴリクロスエントロピーなどのスパース損失関数を除く</target>
        </trans-unit>
        <trans-unit id="c43440e34d61ec903c57a53c805f205165dc5754" translate="yes" xml:space="preserve">
          <source>Ground truth values. shape = &lt;code&gt;[batch_size, d0, .. dN]&lt;/code&gt;.</source>
          <target state="translated">グラウンドトゥルース値。形状= &lt;code&gt;[batch_size, d0, .. dN]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="38b0e82be14566bde59466131197fef45b274db7" translate="yes" xml:space="preserve">
          <source>Ground-truth targets to pass to &lt;code&gt;Model&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Model&lt;/code&gt; に渡すグラウンドトゥルースターゲット。</target>
        </trans-unit>
        <trans-unit id="e75eb9da321613dade49081fbb0f38725be295e1" translate="yes" xml:space="preserve">
          <source>Group objects into a training checkpoint.</source>
          <target state="translated">トレーニングチェックポイントにオブジェクトをグループ化します。</target>
        </trans-unit>
        <trans-unit id="6115c228a89d1f90769cafcbd1ad268a88285c91" translate="yes" xml:space="preserve">
          <source>Group tensors together.</source>
          <target state="translated">テンソルをグループ化して</target>
        </trans-unit>
        <trans-unit id="3e4946272ebd6af7ba4e43d36dac49e1f14d4e7c" translate="yes" xml:space="preserve">
          <source>GroupByReducerDataset</source>
          <target state="translated">GroupByReducerDataset</target>
        </trans-unit>
        <trans-unit id="be8d30eb5632b02cf8f150f0a09be3b235ef07eb" translate="yes" xml:space="preserve">
          <source>GroupByWindowDataset</source>
          <target state="translated">GroupByWindowDataset</target>
        </trans-unit>
        <trans-unit id="e354b4454dd166bc154614760aa397bafa913cb1" translate="yes" xml:space="preserve">
          <source>Groups trackable objects, saving and restoring them.</source>
          <target state="translated">追跡可能なオブジェクトをグループ化し、保存と復元を行います。</target>
        </trans-unit>
        <trans-unit id="9d7f80cd70980946ed16aeb04c9d084b9966606a" translate="yes" xml:space="preserve">
          <source>GuaranteeConst</source>
          <target state="translated">GuaranteeConst</target>
        </trans-unit>
        <trans-unit id="7ad9a6bc86d23788bf2c1d40a823516a6f0ed768" translate="yes" xml:space="preserve">
          <source>HALF_TO_EVEN: this is the default round_mode.</source>
          <target state="translated">HALF_TO_EVEN:デフォルトのラウンドモードです。</target>
        </trans-unit>
        <trans-unit id="920da21317add9910b40605a155029f67d570159" translate="yes" xml:space="preserve">
          <source>HALF_UP: round towards positive. In this mode 7.5 rounds up to 8 and -7.5 rounds up to -7.</source>
          <target state="translated">HALF_UP:プラスに向かってラウンドします。このモードでは8までは7.5ラウンド、-7までは-7.5ラウンドとなります。</target>
        </trans-unit>
        <trans-unit id="29d6a74360835e2659133e31def98e713b027ad9" translate="yes" xml:space="preserve">
          <source>HSVToRGB</source>
          <target state="translated">HSVToRGB</target>
        </trans-unit>
        <trans-unit id="11ef29d704891a60b088172f8178a63b75138495" translate="yes" xml:space="preserve">
          <source>Hard sigmoid activation function.</source>
          <target state="translated">ハードシグモイド活性化機能。</target>
        </trans-unit>
        <trans-unit id="89d0493bf3e9638199b6b1d86f1632bbe9719ae3" translate="yes" xml:space="preserve">
          <source>Has Gradient</source>
          <target state="translated">グラデーションを持っている</target>
        </trans-unit>
        <trans-unit id="a7f2a37788a5eae46019711a7835ecdefc241070" translate="yes" xml:space="preserve">
          <source>HashTable</source>
          <target state="translated">HashTable</target>
        </trans-unit>
        <trans-unit id="acf8fdc7f2d880260a7d0b7da811515282e4330f" translate="yes" xml:space="preserve">
          <source>HashTableV2</source>
          <target state="translated">HashTableV2</target>
        </trans-unit>
        <trans-unit id="b62d591ef71e520dcc0fd2d5494b2b952c2c9902" translate="yes" xml:space="preserve">
          <source>Hasim Sak, Andrew Senior, and Francoise Beaufays. &quot;Long short-term memory recurrent neural network architectures for large scale acoustic modeling.&quot; INTERSPEECH, 2014.</source>
          <target state="translated">Hasim Sak,Andrew Senior,and Francoise Beaufays.&quot;大規模音響モデリングのための長期短期記憶リカレントニューラルネットワークアーキテクチャ&quot; INTERSPEECH、2014年。</target>
        </trans-unit>
        <trans-unit id="7acbb15ccffab6beca727a0d69870bfb5c290df1" translate="yes" xml:space="preserve">
          <source>Have a &lt;code&gt;go_backwards&lt;/code&gt;, &lt;code&gt;return_sequences&lt;/code&gt; and &lt;code&gt;return_state&lt;/code&gt; attribute (with the same semantics as for the &lt;code&gt;RNN&lt;/code&gt; class).</source>
          <target state="translated">持って &lt;code&gt;go_backwards&lt;/code&gt; 、 &lt;code&gt;return_sequences&lt;/code&gt; と &lt;code&gt;return_state&lt;/code&gt; （と同じセマンティクスを持つ属性 &lt;code&gt;RNN&lt;/code&gt; のクラス）。</target>
        </trans-unit>
        <trans-unit id="b06caab1d8003a14cb6c5ee52eb330ca47603350" translate="yes" xml:space="preserve">
          <source>Have an &lt;code&gt;input_spec&lt;/code&gt; attribute.</source>
          <target state="translated">持って &lt;code&gt;input_spec&lt;/code&gt; 属性を。</target>
        </trans-unit>
        <trans-unit id="8dd6a3bb0aa8fcc99cb2926cb3630295183067dd" translate="yes" xml:space="preserve">
          <source>Having access to such information is useful when user needs to run specific code according to task types. For example,</source>
          <target state="translated">このような情報にアクセスできることは、ユーザーがタスクタイプに応じて特定のコードを実行する必要がある場合に便利です。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="c4021193208114328b08be8cf728a91eb62ae42b" translate="yes" xml:space="preserve">
          <source>He et al., 2015</source>
          <target state="translated">He et al.</target>
        </trans-unit>
        <trans-unit id="2579614b073edd33dff24698cc0ed7a9d8d9b2ff" translate="yes" xml:space="preserve">
          <source>He normal initializer.</source>
          <target state="translated">彼は通常のイニシャライザ。</target>
        </trans-unit>
        <trans-unit id="c820b6e271aeb8c0992aef844f7e9688ee27c3ff" translate="yes" xml:space="preserve">
          <source>He uniform variance scaling initializer.</source>
          <target state="translated">彼は一様分散スケーリングのイニシャライザです。</target>
        </trans-unit>
        <trans-unit id="b2a0825f5cf85b0813ba4a932833d3b427e828d7" translate="yes" xml:space="preserve">
          <source>Head sits on top of the model network and handles computing the outputs of the network. Given logits (or output of a hidden layer), a Head knows how to compute predictions, loss, train_op, metrics and export outputs. It is meant to:</source>
          <target state="translated">Head はモデルネットワークの上に位置し、ネットワークの出力を計算します。ロジット(または隠れ層の出力)が与えられると、Headは予測値、損失、train_op、メトリクス、出力の計算方法を知っています。これは次のようなことを意味します。</target>
        </trans-unit>
        <trans-unit id="110183a1eb73ab34fd4a98c264cc9d76f023cc2a" translate="yes" xml:space="preserve">
          <source>Heartbeats may be sent periodically to indicate the coordinator is still active, to retrieve the current worker status and to expedite shutdown when necessary.</source>
          <target state="translated">ハートビートは、コーディネーターがまだアクティブであることを示すために定期的に送信され、現在のワーカーのステータスを取得し、必要に応じてシャットダウンを促進することができます。</target>
        </trans-unit>
        <trans-unit id="065c2e0bd4aa8ce24245293e18fcb73620f8829e" translate="yes" xml:space="preserve">
          <source>Height of output image.</source>
          <target state="translated">出力画像の高さ。</target>
        </trans-unit>
        <trans-unit id="02e0e2ad93d9b9dfcf2dfc29c4e34a5e7ed6029e" translate="yes" xml:space="preserve">
          <source>Height of the result.</source>
          <target state="translated">結果の高さ。</target>
        </trans-unit>
        <trans-unit id="724391cae7df3c6f2f078aa757c3203246f50dfa" translate="yes" xml:space="preserve">
          <source>Helpers to manipulate a tensor graph in python.</source>
          <target state="translated">pythonでテンソルグラフを操作するためのヘルパーです。</target>
        </trans-unit>
        <trans-unit id="a9a20ef1cc1f4b45d357341f3d6bf25221e22949" translate="yes" xml:space="preserve">
          <source>Hence, the &lt;code&gt;SparseTensor&lt;/code&gt; result has exactly the same non-zero indices and shape.</source>
          <target state="translated">したがって、 &lt;code&gt;SparseTensor&lt;/code&gt; の結果は、ゼロ以外のインデックスと形状がまったく同じです。</target>
        </trans-unit>
        <trans-unit id="67314232dbebd248ae3b761c240375d141928549" translate="yes" xml:space="preserve">
          <source>Hence, to ensure stability and avoid overflow, the implementation uses this equivalent formulation</source>
          <target state="translated">したがって、安定性を確保し、オーバーフローを回避するために、実装ではこの等価な定式化を使用します。</target>
        </trans-unit>
        <trans-unit id="15496dff970b77a7dd905044c63378f4105e5937" translate="yes" xml:space="preserve">
          <source>Here is a code example for using &lt;code&gt;AdditiveAttention&lt;/code&gt; in a CNN+Attention network:</source>
          <target state="translated">以下は、CNN + Attentionネットワークで &lt;code&gt;AdditiveAttention&lt;/code&gt; を使用するためのコード例です。</target>
        </trans-unit>
        <trans-unit id="af1e9525f99564803e6dc214d93b54de55e718e8" translate="yes" xml:space="preserve">
          <source>Here is a code example for using &lt;code&gt;Attention&lt;/code&gt; in a CNN+Attention network:</source>
          <target state="translated">以下は、CNN + Attentionネットワークで &lt;code&gt;Attention&lt;/code&gt; を使用するためのコード例です。</target>
        </trans-unit>
        <trans-unit id="c2e3cf832e96b3ad2b7cfe3cb8d1e7045a255de6" translate="yes" xml:space="preserve">
          <source>Here is a table of the (roughly) expected first order behavior:</source>
          <target state="translated">ここでは、(大まかには)予想される一次の挙動を表にしてみました。</target>
        </trans-unit>
        <trans-unit id="0dcb732b904f60bb8f4fb4132ab1bc7ce4c1dc40" translate="yes" xml:space="preserve">
          <source>Here is an example embedding of two features for a DNNClassifier model:</source>
          <target state="translated">ここでは、DNNClassifierモデルに2つの特徴を埋め込む例を示します。</target>
        </trans-unit>
        <trans-unit id="b92188d0e4470161bf6ef1be354a49527229f664" translate="yes" xml:space="preserve">
          <source>Here is an example of a standard reader function a user can define. This function enables both dataset shuffling and parallel reading of datasets:</source>
          <target state="translated">ここでは、ユーザが定義できる標準的なリーダ関数の例を示します。この関数は、データセットのシャッフリングとデータセットの並列読み込みの両方を可能にします。</target>
        </trans-unit>
        <trans-unit id="b5a139c16bbbe2e00002f4ebb6bf2d7cf0a12e13" translate="yes" xml:space="preserve">
          <source>Here is an example to create a linear model with crosses of string features:</source>
          <target state="translated">ここでは、文字列の特徴を交差させた線形モデルを作成する例を示します。</target>
        </trans-unit>
        <trans-unit id="464c6369ff2a08fe078373832f4183bb8de964e9" translate="yes" xml:space="preserve">
          <source>Here is an example using &lt;code&gt;embedding_column&lt;/code&gt; with model_fn:</source>
          <target state="translated">以下は、model_fnで &lt;code&gt;embedding_column&lt;/code&gt; を使用する例です。</target>
        </trans-unit>
        <trans-unit id="bd511335f37b0684a350a25bab28497fe427dcb9" translate="yes" xml:space="preserve">
          <source>Here is an example using &lt;code&gt;shared_embedding_columns&lt;/code&gt; with model_fn:</source>
          <target state="translated">以下は、 &lt;code&gt;shared_embedding_columns&lt;/code&gt; でshared_embedding_columns を使用する例です。</target>
        </trans-unit>
        <trans-unit id="e0362ba3fd11b51dc2dbcaf3363290ca8a7b99e6" translate="yes" xml:space="preserve">
          <source>Here is simplified model_fn to build a DNN regression model.</source>
          <target state="translated">ここでは、DNN回帰モデルを構築するための単純化したmodel_fnを紹介します。</target>
        </trans-unit>
        <trans-unit id="bb290e88257943f8b204cd2522934a4d03f0b94a" translate="yes" xml:space="preserve">
          <source>Here the expectation is that the &lt;code&gt;input_fn_*&lt;/code&gt; functions passed to train and evaluate return a pair (dict, label_tensor) where dict has &lt;code&gt;example_id_column&lt;/code&gt; as &lt;code&gt;key&lt;/code&gt; whose value is a &lt;code&gt;Tensor&lt;/code&gt; of shape [batch_size] and dtype string. num_loss_partitions defines sigma' in eq (11) of [3]. Convergence of (global) loss is guaranteed if &lt;code&gt;num_loss_partitions&lt;/code&gt; is larger or equal to the product &lt;code&gt;(#concurrent train ops/per worker) x (#workers)&lt;/code&gt;. Larger values for &lt;code&gt;num_loss_partitions&lt;/code&gt; lead to slower convergence. The recommended value for &lt;code&gt;num_loss_partitions&lt;/code&gt; in &lt;a href=&quot;../../estimator&quot;&gt;&lt;code&gt;tf.estimator&lt;/code&gt;&lt;/a&gt; (where currently there is one process per worker) is the number of workers running the train steps. It defaults to 1 (single machine). &lt;code&gt;num_table_shards&lt;/code&gt; defines the number of shards for the internal state table, typically set to match the number of parameter servers for large data sets.</source>
          <target state="translated">ここでの期待があること &lt;code&gt;input_fn_*&lt;/code&gt; 機能は列車に渡され、辞書が有する一対（辞書、label_tensor）を返す評価 &lt;code&gt;example_id_column&lt;/code&gt; として &lt;code&gt;key&lt;/code&gt; 値がある &lt;code&gt;Tensor&lt;/code&gt; 形状【BATCH_SIZE]とDTYPE文字列を。 num_loss_partitionsは、[3]の式（11）でシグマを定義します。 （グローバル）損失の収束は、 &lt;code&gt;num_loss_partitions&lt;/code&gt; が製品 &lt;code&gt;(#concurrent train ops/per worker) x (#workers)&lt;/code&gt; より大きいか等しい場合に保証されます。 &lt;code&gt;num_loss_partitions&lt;/code&gt; の値を大きくすると、収束が遅くなります。推奨値 &lt;code&gt;num_loss_partitions&lt;/code&gt; で&lt;a href=&quot;../../estimator&quot;&gt; &lt;code&gt;tf.estimator&lt;/code&gt; &lt;/a&gt;（現在、ワーカーごとに1つのプロセスがある）は、トレインステップを実行しているワーカーの数です。デフォルトは1（単一マシン）です。 &lt;code&gt;num_table_shards&lt;/code&gt; は、内部状態テーブルのシャードの数を定義します。通常、大きなデータセットのパラメーターサーバーの数と一致するように設定されます。</target>
        </trans-unit>
        <trans-unit id="6fd075a1cf6908e13f7823aaaf120524aec476bf" translate="yes" xml:space="preserve">
          <source>Here the partial derivatives &lt;code&gt;g&lt;/code&gt; evaluate to &lt;code&gt;[1.0, 1.0]&lt;/code&gt;, compared to the total derivatives &lt;code&gt;tf.gradients(a + b, [a, b])&lt;/code&gt;, which take into account the influence of &lt;code&gt;a&lt;/code&gt; on &lt;code&gt;b&lt;/code&gt; and evaluate to &lt;code&gt;[3.0, 1.0]&lt;/code&gt;. Note that the above is equivalent to:</source>
          <target state="translated">ここでは、偏導関数 &lt;code&gt;g&lt;/code&gt; は &lt;code&gt;[1.0, 1.0]&lt;/code&gt; &lt;code&gt;tf.gradients(a + b, [a, b])&lt;/code&gt; ]に評価され、総導関数tf.gradients（a + b、[a、b]）と比較されます。これは &lt;code&gt;a&lt;/code&gt; &lt;code&gt;b&lt;/code&gt; に対するaの影響を考慮して[3.0、1.0]に評価されます &lt;code&gt;[3.0, 1.0]&lt;/code&gt; 。上記は以下と同等であることに注意してください。</target>
        </trans-unit>
        <trans-unit id="49c2e9085ffe62b7af2e00831b5211eb57d553ec" translate="yes" xml:space="preserve">
          <source>Here we check that this operator is &lt;em&gt;exactly&lt;/em&gt; equal to its hermitian transpose.</source>
          <target state="translated">ここで、この演算子がエルミート転置と&lt;em&gt;正確に&lt;/em&gt;等しいことを確認します。</target>
        </trans-unit>
        <trans-unit id="5f52f6e66184e816627dceffc4afecf746fff88d" translate="yes" xml:space="preserve">
          <source>Here we consider NASNet-A, the highest performance model that was found for the CIFAR-10 dataset, and then extended to ImageNet 2012 dataset, obtaining state of the art performance on CIFAR-10 and ImageNet 2012. Only the NASNet-A models, and their respective weights, which are suited for ImageNet 2012 are provided.</source>
          <target state="translated">ここでは、CIFAR-10データセットで発見された最高性能モデルであるNASNet-AをImageNet 2012データセットに拡張し、CIFAR-10およびImageNet 2012で最先端の性能を得た。ImageNet 2012に適したNASNet-Aモデルとそれぞれの重みのみを提供します。</target>
        </trans-unit>
        <trans-unit id="8a715d375560e6afb15b0e0d6332a8c3f5a410ac" translate="yes" xml:space="preserve">
          <source>Here's a basic example: a layer with two variables, &lt;code&gt;w&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;, that returns &lt;code&gt;y = w . x + b&lt;/code&gt;. It shows how to implement &lt;code&gt;build()&lt;/code&gt; and &lt;code&gt;call()&lt;/code&gt;. Variables set as attributes of a layer are tracked as weights of the layers (in &lt;code&gt;layer.weights&lt;/code&gt;).</source>
          <target state="translated">基本的な例を次に示します &lt;code&gt;y = w . x + b&lt;/code&gt; を返す2つの変数 &lt;code&gt;w&lt;/code&gt; と &lt;code&gt;b&lt;/code&gt; を持つレイヤー。x + b。 &lt;code&gt;build()&lt;/code&gt; と &lt;code&gt;call()&lt;/code&gt; を実装する方法を示しています。レイヤーの属性として設定された変数は、レイヤーの重みとして追跡されます（ &lt;code&gt;layer.weights&lt;/code&gt; 内）。</target>
        </trans-unit>
        <trans-unit id="27c376c1d7316f3407dd139c89bd36e269d0b657" translate="yes" xml:space="preserve">
          <source>Here's a simple example: a random normal initializer.</source>
          <target state="translated">ここに簡単な例があります:ランダムな通常のイニシャライザです。</target>
        </trans-unit>
        <trans-unit id="66a65bf97c24fbc1825d0d9c6cb98cb1aafb52a0" translate="yes" xml:space="preserve">
          <source>Here, 'types' means the profiler nodes' properties. Profiler by default consider device name (e.g. /job:xx/.../device:GPU:0) and operation type (e.g. MatMul) as profiler nodes' properties. User can also associate customized 'types' to profiler nodes through OpLogProto proto.</source>
          <target state="translated">ここで,「タイプ」とは,プロファイラノードのプロパティを意味します.デフォルトでは、プロファイラはデバイス名(例:/job:xx/.../device:GPU:0)と操作タイプ(例:MatMul)をプロファイラノードのプロパティとして考慮します。ユーザは、OpLogProto proto を通じて、カスタマイズされた「タイプ」をプロファイラノードに関連付けることもできます。</target>
        </trans-unit>
        <trans-unit id="17b2af2adfe30a3aef16e7ccfa94f34d6e4b3818" translate="yes" xml:space="preserve">
          <source>Here, a snapshot of &lt;code&gt;v&lt;/code&gt; is captured in &lt;code&gt;value&lt;/code&gt;; and then &lt;code&gt;v&lt;/code&gt; is updated. The snapshot value is returned.</source>
          <target state="translated">ここでは、 &lt;code&gt;v&lt;/code&gt; のスナップショットが &lt;code&gt;value&lt;/code&gt; にキャプチャされます。その後、 &lt;code&gt;v&lt;/code&gt; が更新されます。スナップショット値が返されます。</target>
        </trans-unit>
        <trans-unit id="ece63641c90490d540658510825631e924c7c84b" translate="yes" xml:space="preserve">
          <source>Here, adding &lt;code&gt;use_resource=True&lt;/code&gt; when constructing the variable will fix any nondeterminism issues:</source>
          <target state="translated">ここで、変数の作成時に &lt;code&gt;use_resource=True&lt;/code&gt; を追加すると、非決定性の問題が修正されます。</target>
        </trans-unit>
        <trans-unit id="94f786d71b2cb60eeb24aa9948d9d1f390afdf17" translate="yes" xml:space="preserve">
          <source>Here, positive definite means that the quadratic form &lt;code&gt;x^H A x&lt;/code&gt; has positive real part for all nonzero &lt;code&gt;x&lt;/code&gt;. Note that we do not require the operator to be self-adjoint to be positive definite.</source>
          <target state="translated">ここで、正定値とは、2次形式 &lt;code&gt;x^H A x&lt;/code&gt; がすべての非ゼロ &lt;code&gt;x&lt;/code&gt; に対して正の実数部を持つことを意味します。演算子が正定であるために自己随伴である必要はないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="51f5cbd0286b6bc2be5272d73eef56b1e6b7773c" translate="yes" xml:space="preserve">
          <source>Here, the input has a batch of 1 and each batch element has shape &lt;code&gt;[1, 1, 4]&lt;/code&gt;, the corresponding output will have 2x2 elements and will have a depth of 1 channel (1 = &lt;code&gt;4 / (block_size * block_size)&lt;/code&gt;). The output element shape is &lt;code&gt;[2, 2, 1]&lt;/code&gt;.</source>
          <target state="translated">ここで、入力のバッチは1で、各バッチ要素の形状は &lt;code&gt;[1, 1, 4]&lt;/code&gt; &lt;code&gt;4 / (block_size * block_size)&lt;/code&gt; ]であり、対応する出力は2x2要素を持ち、深さは1チャネルになります（1 = 4 /（block_size * block_size））。出力要素の形状は &lt;code&gt;[2, 2, 1]&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="2cace8ea6c5a3f6f36376df736083d35d45c704d" translate="yes" xml:space="preserve">
          <source>Here, the input has a batch of 1 and each batch element has shape &lt;code&gt;[2, 2, 1]&lt;/code&gt;, the corresponding output will have a single element (i.e. width and height are both 1) and will have a depth of 4 channels (1 * block_size * block_size). The output element shape is &lt;code&gt;[1, 1, 4]&lt;/code&gt;.</source>
          <target state="translated">ここでは、入力のバッチは1で、各バッチ要素の形状は &lt;code&gt;[2, 2, 1]&lt;/code&gt; 2、2、1 ]で、対応する出力は単一の要素（つまり、幅と高さが両方とも1）であり、深さは4チャネル（1 * block_size * block_size）。出力要素の形状は &lt;code&gt;[1, 1, 4]&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="0cd54db7611e23329deb591ac691703bafcd3e97" translate="yes" xml:space="preserve">
          <source>Hierarchical level of the Ophint node, a number.</source>
          <target state="translated">Ophintノードの階層レベル、数値。</target>
        </trans-unit>
        <trans-unit id="9ecfb1194a3a379261dd07bbb066a5568e6506a9" translate="yes" xml:space="preserve">
          <source>Hinton, 2012</source>
          <target state="translated">ヒントン、2012年</target>
        </trans-unit>
        <trans-unit id="61b43f0b6cf6e4d96507128fea4cd7b8a90efe5a" translate="yes" xml:space="preserve">
          <source>Hints for collective operations like AllReduce.</source>
          <target state="translated">AllReduceのような集団運用のヒント。</target>
        </trans-unit>
        <trans-unit id="7d3bab4ff1c30c8ba838d1595446d9004c083483" translate="yes" xml:space="preserve">
          <source>HistogramFixedWidth</source>
          <target state="translated">HistogramFixedWidth</target>
        </trans-unit>
        <trans-unit id="a53dafd06d1ebe965ea309d8c08e1156b67e2e5e" translate="yes" xml:space="preserve">
          <source>HistogramSummary</source>
          <target state="translated">HistogramSummary</target>
        </trans-unit>
        <trans-unit id="e8876b9619eb77ec487c16beae68d94edd272b99" translate="yes" xml:space="preserve">
          <source>Holds a defined flag.</source>
          <target state="translated">定義されたフラグを保持します。</target>
        </trans-unit>
        <trans-unit id="f41c0836949b26db8a72f139bb0d93a63f27a5d8" translate="yes" xml:space="preserve">
          <source>Holds a list of enqueue operations for a queue, each to be run in a thread.</source>
          <target state="translated">キューの enqueue 操作のリストを保持します。</target>
        </trans-unit>
        <trans-unit id="82f1d229094d8c503d561ee75fa7b2f6ebb2010b" translate="yes" xml:space="preserve">
          <source>Holds state in the form of a tensor that persists across steps.</source>
          <target state="translated">ステップを越えて持続するテンソルの形で状態を保持します。</target>
        </trans-unit>
        <trans-unit id="a7ec66187a04150d0757954c1018dca525f600f5" translate="yes" xml:space="preserve">
          <source>Hook method for deconstructing the class fixture after running all tests in the class.</source>
          <target state="translated">クラス内のすべてのテストを実行した後に、クラスのフィクスチャを分解するためのフックメソッド。</target>
        </trans-unit>
        <trans-unit id="aed79b3c251b0477f07982fb328ebad89154bf47" translate="yes" xml:space="preserve">
          <source>Hook method for deconstructing the test fixture after testing it.</source>
          <target state="translated">試験治具を試験した後に分解するためのフック方式。</target>
        </trans-unit>
        <trans-unit id="d3376d91b293e2ef0e2b7a2f9d722cde34fcb75c" translate="yes" xml:space="preserve">
          <source>Hook method for setting up class fixture before running tests in the class.</source>
          <target state="translated">クラス内でテストを実行する前に、クラスのフィクスチャを設定するためのフックメソッド。</target>
        </trans-unit>
        <trans-unit id="2f3856f3bee2218da00682ea5300db8d8a163355" translate="yes" xml:space="preserve">
          <source>Hook method for setting up the test fixture before exercising it.</source>
          <target state="translated">運動前に試験治具を設置するためのフック方式。</target>
        </trans-unit>
        <trans-unit id="8b036bc6887a5488ae47380e1e40457b96130270" translate="yes" xml:space="preserve">
          <source>Hook that counts steps per second.</source>
          <target state="translated">秒間の歩数をカウントするフック。</target>
        </trans-unit>
        <trans-unit id="c583828ba4633b5282cbe15aa8308cd7a4ae402f" translate="yes" xml:space="preserve">
          <source>Hook that requests stop at a specified step.</source>
          <target state="translated">指定したステップでの停止を要求するフック</target>
        </trans-unit>
        <trans-unit id="694af7941c3209602c7a59e4452f1ab6fd0ed608" translate="yes" xml:space="preserve">
          <source>Hook to extend calls to MonitoredSession.run().</source>
          <target state="translated">MonitoredSession.run()の呼び出しを拡張するフック。</target>
        </trans-unit>
        <trans-unit id="5e1bd302daecf16d1f3450073dcb3bb5f7b9e87f" translate="yes" xml:space="preserve">
          <source>Hook to run evaluation in training without a checkpoint.</source>
          <target state="translated">チェックポイントのないトレーニングで評価を実行するためのフック</target>
        </trans-unit>
        <trans-unit id="094e7dc095dce31db8b2d945d9b4e16d81e5603c" translate="yes" xml:space="preserve">
          <source>Hooks can use this function to request stop of iterations. &lt;code&gt;MonitoredSession&lt;/code&gt; checks whether this is called or not.</source>
          <target state="translated">フックはこの関数を使用して、反復の停止を要求できます。 &lt;code&gt;MonitoredSession&lt;/code&gt; は、これが呼び出されているかどうかを確認します。</target>
        </trans-unit>
        <trans-unit id="9b63e3c3d34964d61b02e9af3acc454228fbfd58" translate="yes" xml:space="preserve">
          <source>Hooks interact with the &lt;code&gt;run_with_hooks()&lt;/code&gt; call inside the &lt;code&gt;step_fn&lt;/code&gt; as they do with a &lt;code&gt;MonitoredSession.run&lt;/code&gt; call.</source>
          <target state="translated">フックは、 &lt;code&gt;MonitoredSession.run&lt;/code&gt; 呼び出しの場合と同様に、 &lt;code&gt;step_fn&lt;/code&gt; 内の &lt;code&gt;run_with_hooks()&lt;/code&gt; 呼び出しと対話します。</target>
        </trans-unit>
        <trans-unit id="d8fa61e89297f89e6206a39ad26727e4b2370a10" translate="yes" xml:space="preserve">
          <source>Horizontal coordinate of the top-left corner of the result in the input.</source>
          <target state="translated">入力結果の左上隅の水平座標。</target>
        </trans-unit>
        <trans-unit id="a54dcdd14e5ce50144dff46fc76cb90c2aac998a" translate="yes" xml:space="preserve">
          <source>How a layer uses its policy's compute dtype</source>
          <target state="translated">レイヤーがポリシーの計算dtypeをどのように使用するか</target>
        </trans-unit>
        <trans-unit id="8f2288d55767c1f8629065632e650bab29069f12" translate="yes" xml:space="preserve">
          <source>How a layer uses its policy's variable dtype</source>
          <target state="translated">レイヤーがポリシーの変数 dtype をどのように使うか</target>
        </trans-unit>
        <trans-unit id="fd6f229db07ef1c3400e9df85c28b2f4cdc8a8b7" translate="yes" xml:space="preserve">
          <source>How identities that are created are named.</source>
          <target state="translated">作成されたアイデンティティにどのような名前が付けられているか。</target>
        </trans-unit>
        <trans-unit id="56338367b61d14699e1f7174329b84eb9405e3d2" translate="yes" xml:space="preserve">
          <source>How often to apply decay.</source>
          <target state="translated">衰えをどのくらいの頻度で塗るか。</target>
        </trans-unit>
        <trans-unit id="18377df79aa141396de4dd094b00a669cf41e8fd" translate="yes" xml:space="preserve">
          <source>How often to keep checkpoints. Defaults to 10,000 hours.</source>
          <target state="translated">チェックポイントを維持する頻度。デフォルトは10,000時間です。</target>
        </trans-unit>
        <trans-unit id="a2d47c5b2670b24370374b073fdcc8981f93f9f3" translate="yes" xml:space="preserve">
          <source>How to choose:</source>
          <target state="translated">選び方。</target>
        </trans-unit>
        <trans-unit id="e3b73487529c5d6e94a503e64f0fdd72a394754d" translate="yes" xml:space="preserve">
          <source>How to gate the computation of gradients. Can be &lt;code&gt;GATE_NONE&lt;/code&gt;, &lt;code&gt;GATE_OP&lt;/code&gt;, or &lt;code&gt;GATE_GRAPH&lt;/code&gt;.</source>
          <target state="translated">勾配の計算をゲートする方法。 &lt;code&gt;GATE_NONE&lt;/code&gt; 、 &lt;code&gt;GATE_OP&lt;/code&gt; 、または &lt;code&gt;GATE_GRAPH&lt;/code&gt; にすることができます。</target>
        </trans-unit>
        <trans-unit id="a70232ceb55af558f2ee0aaffe46fc01d689778f" translate="yes" xml:space="preserve">
          <source>How to handle text to bytes encoding errors. Only used if &lt;code&gt;content&lt;/code&gt; is text.</source>
          <target state="translated">テキストからバイトへのエンコーディングエラーを処理する方法。 &lt;code&gt;content&lt;/code&gt; がテキストの場合にのみ使用されます。</target>
        </trans-unit>
        <trans-unit id="b43d30453d0ca08342c32b5bf9b8ce3e75e7c394" translate="yes" xml:space="preserve">
          <source>How to set &lt;a href=&quot;../session&quot;&gt;&lt;code&gt;tf.compat.v1.Session&lt;/code&gt;&lt;/a&gt; arguments:</source>
          <target state="translated">&lt;a href=&quot;../session&quot;&gt; &lt;code&gt;tf.compat.v1.Session&lt;/code&gt; &lt;/a&gt;引数を設定する方法：</target>
        </trans-unit>
        <trans-unit id="16612609ea0121d74a2ebf85615c5cd0d97d528b" translate="yes" xml:space="preserve">
          <source>How to use float64 in a Keras model</source>
          <target state="translated">Kerasモデルでfloat64を使用する方法</target>
        </trans-unit>
        <trans-unit id="5207d3c1fa3b2863bdee0225b56cf4e73f598a8c" translate="yes" xml:space="preserve">
          <source>How to use mixed precision in a Keras model</source>
          <target state="translated">Kerasモデルでの混合精度の使用方法</target>
        </trans-unit>
        <trans-unit id="e91f1ba40e84a0d707e3f45076f0f821dd55b6b7" translate="yes" xml:space="preserve">
          <source>How to write a layer that supports mixed precision and float64.</source>
          <target state="translated">混合精度とfloat64に対応したレイヤーの書き方</target>
        </trans-unit>
        <trans-unit id="cb1a3d087cf7ab9ae32a2d72ddafa8d585fa12c7" translate="yes" xml:space="preserve">
          <source>However, &lt;code&gt;broadcast_to&lt;/code&gt; does not carry with it any such benefits. The newly-created tensor takes the full memory of the broadcasted shape. (In a graph context, &lt;code&gt;broadcast_to&lt;/code&gt; might be fused to subsequent operation and then be optimized away, however.)</source>
          <target state="translated">ただし、 &lt;code&gt;broadcast_to&lt;/code&gt; にはそのような利点はありません。新しく作成されたテンソルは、ブロードキャストされた形状の完全なメモリを取ります。（ただし、グラフのコンテキストでは、 &lt;code&gt;broadcast_to&lt;/code&gt; は後続の操作に融合され、最適化される可能性があります。）</target>
        </trans-unit>
        <trans-unit id="95c24f970b239a2e8ff2902447bb8c0e66d29239" translate="yes" xml:space="preserve">
          <source>However, a few other options are available:</source>
          <target state="translated">しかし、他にもいくつかのオプションがあります。</target>
        </trans-unit>
        <trans-unit id="906c66a75c112f0781943a37770b2aadd044fd08" translate="yes" xml:space="preserve">
          <source>However, in the case of the &lt;code&gt;BatchNormalization&lt;/code&gt; layer, &lt;strong&gt;setting &lt;code&gt;trainable = False&lt;/code&gt; on the layer means that the layer will be subsequently run in inference mode&lt;/strong&gt; (meaning that it will use the moving mean and the moving variance to normalize the current batch, rather than using the mean and variance of the current batch).</source>
          <target state="translated">ただし、 &lt;code&gt;BatchNormalization&lt;/code&gt; レイヤーの場合、レイヤーでtrainable &lt;strong&gt; &lt;code&gt;trainable = False&lt;/code&gt; &lt;/strong&gt;&lt;strong&gt;を&lt;/strong&gt;&lt;strong&gt;設定すると、レイヤーはその後推論モードで実行されます&lt;/strong&gt;（つまり、移動平均と移動分散を使用して、現在のバッチを正規化するのではなく、現在のバッチを正規化します現在のバッチの平均と分散）。</target>
        </trans-unit>
        <trans-unit id="66a412ca5b09706643cf60849a60f29942f3b139" translate="yes" xml:space="preserve">
          <source>However, it is slower than &lt;code&gt;clip_by_norm()&lt;/code&gt; because all the parameters must be ready before the clipping operation can be performed.</source>
          <target state="translated">ただし、クリッピング操作を実行する前にすべてのパラメーターを準備しておく必要があるため、 &lt;code&gt;clip_by_norm()&lt;/code&gt; よりも低速です。</target>
        </trans-unit>
        <trans-unit id="6a7bc5ae946d568d89cd6bbe9faf1d5289b758f4" translate="yes" xml:space="preserve">
          <source>However, reducing using the above operator leads to a different computation tree (logs are taken repeatedly instead of only at the end), and the maximum is only computed pairwise instead of over the entire prefix. In general, this leads to a different and slightly less precise computation.</source>
          <target state="translated">しかし、上記の演算子を使って削減すると、計算ツリーが異なります(ログは最後だけではなく繰り返し取得されます)。一般的に,これは異なる精度の計算になります.</target>
        </trans-unit>
        <trans-unit id="1596f4749baf86a816336887cccc4e62582c58ee" translate="yes" xml:space="preserve">
          <source>However, sometimes the container orchestration framework will set TF_CONFIG for you. In this case, you can just create an instance without passing in any arguments. You can find an example here to let Kuburnetes set TF_CONFIG for you: https://github.com/tensorflow/ecosystem/tree/master/kubernetes. Then you can use it with &lt;a href=&quot;../strategy&quot;&gt;&lt;code&gt;tf.distribute.Strategy&lt;/code&gt;&lt;/a&gt; as:</source>
          <target state="translated">ただし、コンテナオーケストレーションフレームワークによってTF_CONFIGが設定される場合があります。この場合、引数を渡さずにインスタンスを作成できます。KuburnetesにTF_CONFIGを設定させる例は、https：//github.com/tensorflow/ecosystem/tree/master/kubernetesにあります。次に、&lt;a href=&quot;../strategy&quot;&gt; &lt;code&gt;tf.distribute.Strategy&lt;/code&gt; &lt;/a&gt;で次のように使用できます。</target>
        </trans-unit>
        <trans-unit id="ee99d120cbadc6a5aa63deb6ecfc26724317acd1" translate="yes" xml:space="preserve">
          <source>However, the number of GPUs available to the runtime may change during runtime initialization due to marking certain devices as not visible or configuring multiple logical devices.</source>
          <target state="translated">しかし、特定のデバイスを可視でないものとしてマーキングしたり、複数の論理デバイスを設定したりすることで、ランタイムの初期化中に利用可能なGPUの数が変化する可能性があります。</target>
        </trans-unit>
        <trans-unit id="f330c6ff1769454cb3a71f75c7d58d68fb24630a" translate="yes" xml:space="preserve">
          <source>However, when adding new features, one may want to unittest it before the forward compatibility window expires. This context manager enables such tests. For example:</source>
          <target state="translated">しかし、新しい機能を追加する際には、前方互換性ウィンドウの期限が切れる前にテストを解除したいと思うかもしれません。このコンテキストマネージャはそのようなテストを可能にします。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="f0583a3e5e448e8509f2cf39238e0ea21adde84e" translate="yes" xml:space="preserve">
          <source>Hyper parameters</source>
          <target state="translated">ハイパーパラメータ</target>
        </trans-unit>
        <trans-unit id="8c1ccbcd79a014503a1fc750addadaf475655020" translate="yes" xml:space="preserve">
          <source>Hyper parameters can be overwritten through user code:</source>
          <target state="translated">ハイパーパラメータはユーザーコードで上書きすることができます。</target>
        </trans-unit>
        <trans-unit id="dfe3cc7ab7e1d07c07d6f364735a8a458edbcaf8" translate="yes" xml:space="preserve">
          <source>Hyperbolic tangent activation function.</source>
          <target state="translated">双曲正接活性化関数。</target>
        </trans-unit>
        <trans-unit id="a15138d06876fc00149292405bf57e4204d00bbe" translate="yes" xml:space="preserve">
          <source>Hyperparameters</source>
          <target state="translated">Hyperparameters</target>
        </trans-unit>
        <trans-unit id="11ed6513569e71d14e0b5bbc27bbc91abe780c3c" translate="yes" xml:space="preserve">
          <source>Hyperparameters can be overwritten through user code:</source>
          <target state="translated">ハイパーパラメータはユーザーコードで上書きすることができます。</target>
        </trans-unit>
        <trans-unit id="5d739908e6b1d9515c7de084c3e63bb329523667" translate="yes" xml:space="preserve">
          <source>I.e. if we have (y1, y2, ..., y_M) = f(x1, x2, ..., x_N), then, g is (dL/dx1, dL/dx2, ..., dL/dx_N) = g(x1, x2, ..., x_N, dL/dy1, dL/dy2, ..., dL/dy_M),</source>
          <target state="translated">すなわち、(y1,y2,...,y_M)=f(x1,x2,...,x_N)とすると、gは(dL/dx1,dL/dx2,...,dL/dx_N)=g(x1,x2,...,x_N,dL/dy1,dL/dy2,...,dL/dy_M)となり、このとき、gは(dL/dx1,dL/dy2,...,dL/dy_M)となる。</target>
        </trans-unit>
        <trans-unit id="caae1c164e99fd3cee75315d0e4ac958059c8bec" translate="yes" xml:space="preserve">
          <source>I.e. returns: &lt;code&gt;output = (x - mean) / (sqrt(var) + epsilon) * gamma + beta&lt;/code&gt;</source>
          <target state="translated">すなわち、 &lt;code&gt;output = (x - mean) / (sqrt(var) + epsilon) * gamma + beta&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ebc94333451747193def37a773f19cfc358efe8b" translate="yes" xml:space="preserve">
          <source>I.e., \(y = -x\).</source>
          <target state="translated">I.e.I.e.I.e.</target>
        </trans-unit>
        <trans-unit id="d175ea7778bab88b107391a5a5e9565e50febd2b" translate="yes" xml:space="preserve">
          <source>I.e., \(y = 1 / \sqrt{x}\).</source>
          <target state="translated">I.e.I.e.I\(y=1/\sqrt{x}).</target>
        </trans-unit>
        <trans-unit id="3c2e39388106824c1d86c17eb18e27d101f691e9" translate="yes" xml:space="preserve">
          <source>I.e., \(y = 1 / x\).</source>
          <target state="translated">I.e.I.e.I\(y=1/x\).</target>
        </trans-unit>
        <trans-unit id="311b2c8a6cdecac50bdfa3324556c4c9ed69923b" translate="yes" xml:space="preserve">
          <source>I.e., \(y = \log_e (1 + x)\).</source>
          <target state="translated">I.e.I.e.I.e.I.e.I.e.</target>
        </trans-unit>
        <trans-unit id="aa71ce7ff4ae1b412d0ee6bf849a4d32aa4d9b69" translate="yes" xml:space="preserve">
          <source>I.e., \(y = \log_e x\).</source>
          <target state="translated">I.e.I.e.I.e.I.e.</target>
        </trans-unit>
        <trans-unit id="8fbd8a894d77699447894ea0b5205e8c3734a34e" translate="yes" xml:space="preserve">
          <source>I.e., \(y = \sqrt{x} = x^{1/2}\).</source>
          <target state="translated">I.e.I.e.I\(y=\sqrt{x}=x^{1/2}\).</target>
        </trans-unit>
        <trans-unit id="86e7c2902521071ed978a52a237380dc3ce4ceb1" translate="yes" xml:space="preserve">
          <source>I.e., \(y = x * x = x^2\).</source>
          <target state="translated">I.e.I.e.I\(y=x*x=x^2).</target>
        </trans-unit>
        <trans-unit id="568335e65a798d6ef3d2eab1d09d072f51075401" translate="yes" xml:space="preserve">
          <source>I.e., the size of the outermost dimension of the tensor.</source>
          <target state="translated">すなわち、テンソルの一番外側の次元の大きさ。</target>
        </trans-unit>
        <trans-unit id="6299f86715c93d989aa9695775a3b9287f113675" translate="yes" xml:space="preserve">
          <source>IFFT</source>
          <target state="translated">IFFT</target>
        </trans-unit>
        <trans-unit id="022dd53bc823f3ac17a82c70736b4706025937f5" translate="yes" xml:space="preserve">
          <source>IFFT2D</source>
          <target state="translated">IFFT2D</target>
        </trans-unit>
        <trans-unit id="fc55a7fb0443a8e9116055588513b592013129a2" translate="yes" xml:space="preserve">
          <source>IFFT3D</source>
          <target state="translated">IFFT3D</target>
        </trans-unit>
        <trans-unit id="e8e744aedc2c7c5589c77a5398c1f0d6581e556f" translate="yes" xml:space="preserve">
          <source>IMDB sentiment classification dataset.</source>
          <target state="translated">IMDBセンチメント分類データセット</target>
        </trans-unit>
        <trans-unit id="cd887c07fd5e921ac521a8f68bba0d58f4244bf2" translate="yes" xml:space="preserve">
          <source>IMPORTANT: Depending on the &lt;a href=&quot;../../../../distribute/strategy&quot;&gt;&lt;code&gt;tf.distribute.Strategy&lt;/code&gt;&lt;/a&gt; implementation being used, and whether eager execution is enabled, &lt;code&gt;fn&lt;/code&gt; may be called one or more times (once for each replica).</source>
          <target state="translated">重要：使用されている&lt;a href=&quot;../../../../distribute/strategy&quot;&gt; &lt;code&gt;tf.distribute.Strategy&lt;/code&gt; &lt;/a&gt;実装、および積極的な実行が有効になっているかどうかに応じて、 &lt;code&gt;fn&lt;/code&gt; は1回以上呼び出されることがあります（レプリカごとに1回）。</target>
        </trans-unit>
        <trans-unit id="2ed0fee938570d32f30307cc8d274895cf578884" translate="yes" xml:space="preserve">
          <source>IMPORTANT: Depending on the &lt;a href=&quot;../../../distribute/strategy&quot;&gt;&lt;code&gt;tf.distribute.Strategy&lt;/code&gt;&lt;/a&gt; implementation being used, and whether eager execution is enabled, &lt;code&gt;fn&lt;/code&gt; may be called one or more times (once for each replica).</source>
          <target state="translated">重要：使用されている&lt;a href=&quot;../../../distribute/strategy&quot;&gt; &lt;code&gt;tf.distribute.Strategy&lt;/code&gt; &lt;/a&gt;実装、および積極的な実行が有効になっているかどうかに応じて、 &lt;code&gt;fn&lt;/code&gt; は1回以上呼び出されることがあります（レプリカごとに1回）。</target>
        </trans-unit>
        <trans-unit id="a0b212e63aab3a82a290c7dc71cb4e212928f7d0" translate="yes" xml:space="preserve">
          <source>IMPORTANT: Depending on the implementation of &lt;a href=&quot;../../../../distribute/strategy&quot;&gt;&lt;code&gt;tf.distribute.Strategy&lt;/code&gt;&lt;/a&gt; and whether eager execution is enabled, &lt;code&gt;fn&lt;/code&gt; may be called one or more times ( once for each replica).</source>
          <target state="translated">重要：&lt;a href=&quot;../../../../distribute/strategy&quot;&gt; &lt;code&gt;tf.distribute.Strategy&lt;/code&gt; &lt;/a&gt;の実装と、積極的な実行が有効かどうかに応じて、 &lt;code&gt;fn&lt;/code&gt; は1回以上（レプリカごとに1回）呼び出される場合があります。</target>
        </trans-unit>
        <trans-unit id="a856b464d5ae55c9c4b023a3135a60ea8e61e4aa" translate="yes" xml:space="preserve">
          <source>IMPORTANT: Depending on the implementation of &lt;a href=&quot;../../../distribute/strategy&quot;&gt;&lt;code&gt;tf.distribute.Strategy&lt;/code&gt;&lt;/a&gt; and whether eager execution is enabled, &lt;code&gt;fn&lt;/code&gt; may be called one or more times ( once for each replica).</source>
          <target state="translated">重要：&lt;a href=&quot;../../../distribute/strategy&quot;&gt; &lt;code&gt;tf.distribute.Strategy&lt;/code&gt; &lt;/a&gt;の実装と、積極的な実行が有効かどうかに応じて、 &lt;code&gt;fn&lt;/code&gt; は1回以上（レプリカごとに1回）呼び出される場合があります。</target>
        </trans-unit>
        <trans-unit id="115e1c114d9f3681f99e56d6543c4b81c3fc3d32" translate="yes" xml:space="preserve">
          <source>IMPORTANT: Depending on the implementation of &lt;a href=&quot;../strategy&quot;&gt;&lt;code&gt;tf.distribute.Strategy&lt;/code&gt;&lt;/a&gt; and whether eager execution is enabled, &lt;code&gt;fn&lt;/code&gt; may be called one or more times ( once for each replica).</source>
          <target state="translated">重要：&lt;a href=&quot;../strategy&quot;&gt; &lt;code&gt;tf.distribute.Strategy&lt;/code&gt; &lt;/a&gt;の実装と、積極的な実行が有効かどうかに応じて、 &lt;code&gt;fn&lt;/code&gt; は1回以上（レプリカごとに1回）呼び出される場合があります。</target>
        </trans-unit>
        <trans-unit id="89f04e8da8a966a33aa44bfaa2ea3036d7113c48" translate="yes" xml:space="preserve">
          <source>IMPORTANT: Depending on the implementation of &lt;a href=&quot;strategy&quot;&gt;&lt;code&gt;tf.distribute.Strategy&lt;/code&gt;&lt;/a&gt; and whether eager execution is enabled, &lt;code&gt;fn&lt;/code&gt; may be called one or more times ( once for each replica).</source>
          <target state="translated">重要：&lt;a href=&quot;strategy&quot;&gt; &lt;code&gt;tf.distribute.Strategy&lt;/code&gt; &lt;/a&gt;の実装と、積極的な実行が有効かどうかに応じて、 &lt;code&gt;fn&lt;/code&gt; は1回以上（レプリカごとに1回）呼び出される場合があります。</target>
        </trans-unit>
        <trans-unit id="3af46570ffb6dae63862cdf22039cbe1fe550b02" translate="yes" xml:space="preserve">
          <source>IMPORTANT: The &lt;a href=&quot;../../../../data/dataset&quot;&gt;&lt;code&gt;tf.data.Dataset&lt;/code&gt;&lt;/a&gt; returned by &lt;code&gt;dataset_fn&lt;/code&gt; should have a per-replica batch size, unlike &lt;code&gt;experimental_distribute_dataset&lt;/code&gt;, which uses the global batch size. This may be computed using &lt;code&gt;input_context.get_per_replica_batch_size&lt;/code&gt;.</source>
          <target state="translated">重要：&lt;a href=&quot;../../../../data/dataset&quot;&gt; &lt;code&gt;tf.data.Dataset&lt;/code&gt; は&lt;/a&gt;で返さ &lt;code&gt;dataset_fn&lt;/code&gt; ごとのレプリカバッチサイズとは異なり、持っている必要があり &lt;code&gt;experimental_distribute_dataset&lt;/code&gt; グローバルバッチサイズを使用しています、。これは、 &lt;code&gt;input_context.get_per_replica_batch_size&lt;/code&gt; を使用して計算できます。</target>
        </trans-unit>
        <trans-unit id="387e6943d94be6545861c405c7eedd2b318559f0" translate="yes" xml:space="preserve">
          <source>IMPORTANT: The &lt;a href=&quot;../../../data/dataset&quot;&gt;&lt;code&gt;tf.data.Dataset&lt;/code&gt;&lt;/a&gt; returned by &lt;code&gt;dataset_fn&lt;/code&gt; should have a per-replica batch size, unlike &lt;code&gt;experimental_distribute_dataset&lt;/code&gt;, which uses the global batch size. This may be computed using &lt;code&gt;input_context.get_per_replica_batch_size&lt;/code&gt;.</source>
          <target state="translated">重要：&lt;a href=&quot;../../../data/dataset&quot;&gt; &lt;code&gt;tf.data.Dataset&lt;/code&gt; は&lt;/a&gt;で返さ &lt;code&gt;dataset_fn&lt;/code&gt; ごとのレプリカバッチサイズとは異なり、持っている必要があり &lt;code&gt;experimental_distribute_dataset&lt;/code&gt; グローバルバッチサイズを使用しています、。これは、 &lt;code&gt;input_context.get_per_replica_batch_size&lt;/code&gt; を使用して計算できます。</target>
        </trans-unit>
        <trans-unit id="371527ec937092bce8c5302761968a912dfa40b4" translate="yes" xml:space="preserve">
          <source>IMPORTANT: The &lt;a href=&quot;../../data/dataset&quot;&gt;&lt;code&gt;tf.data.Dataset&lt;/code&gt;&lt;/a&gt; returned by &lt;code&gt;dataset_fn&lt;/code&gt; should have a per-replica batch size, unlike &lt;code&gt;experimental_distribute_dataset&lt;/code&gt;, which uses the global batch size. This may be computed using &lt;code&gt;input_context.get_per_replica_batch_size&lt;/code&gt;.</source>
          <target state="translated">重要：&lt;a href=&quot;../../data/dataset&quot;&gt; &lt;code&gt;tf.data.Dataset&lt;/code&gt; は&lt;/a&gt;で返さ &lt;code&gt;dataset_fn&lt;/code&gt; ごとのレプリカバッチサイズとは異なり、持っている必要があり &lt;code&gt;experimental_distribute_dataset&lt;/code&gt; グローバルバッチサイズを使用しています、。これは、 &lt;code&gt;input_context.get_per_replica_batch_size&lt;/code&gt; を使用して計算できます。</target>
        </trans-unit>
        <trans-unit id="2ad1bd30c735d96ef3bf70ea7676440f0a17a75f" translate="yes" xml:space="preserve">
          <source>IMPORTANT: The &lt;a href=&quot;../data/dataset&quot;&gt;&lt;code&gt;tf.data.Dataset&lt;/code&gt;&lt;/a&gt; returned by &lt;code&gt;dataset_fn&lt;/code&gt; should have a per-replica batch size, unlike &lt;code&gt;experimental_distribute_dataset&lt;/code&gt;, which uses the global batch size. This may be computed using &lt;code&gt;input_context.get_per_replica_batch_size&lt;/code&gt;.</source>
          <target state="translated">重要：&lt;a href=&quot;../data/dataset&quot;&gt; &lt;code&gt;tf.data.Dataset&lt;/code&gt; は&lt;/a&gt;で返さ &lt;code&gt;dataset_fn&lt;/code&gt; ごとのレプリカバッチサイズとは異なり、持っている必要があり &lt;code&gt;experimental_distribute_dataset&lt;/code&gt; グローバルバッチサイズを使用しています、。これは、 &lt;code&gt;input_context.get_per_replica_batch_size&lt;/code&gt; を使用して計算できます。</target>
        </trans-unit>
        <trans-unit id="d6a0418b361073a5e7f1934efa7924dff3340f39" translate="yes" xml:space="preserve">
          <source>IMPORTANT: The ordering of communications must be identical in all replicas.</source>
          <target state="translated">重要:通信の順序は、すべてのレプリカで同じでなければなりません。</target>
        </trans-unit>
        <trans-unit id="94ef35d6e06d69b9a685928876f94b41c52dc1b8" translate="yes" xml:space="preserve">
          <source>INT8 precision and calibration with pre-built engines</source>
          <target state="translated">INT8の精度と校正は、構築済みのエンジンを使用しています。</target>
        </trans-unit>
        <trans-unit id="02f4e09badaa8dec60af1a67b17355e9f8784a58" translate="yes" xml:space="preserve">
          <source>IRFFT</source>
          <target state="translated">IRFFT</target>
        </trans-unit>
        <trans-unit id="cd7b29bbdbb4febdf272a0721f00f37ac64b2660" translate="yes" xml:space="preserve">
          <source>IRFFT2D</source>
          <target state="translated">IRFFT2D</target>
        </trans-unit>
        <trans-unit id="505b56d0dfad67f6287be15698ed8d2d0a478343" translate="yes" xml:space="preserve">
          <source>IRFFT3D</source>
          <target state="translated">IRFFT3D</target>
        </trans-unit>
        <trans-unit id="b7fb9aff273f4e7c1abf394ced0a28207f4c3ff0" translate="yes" xml:space="preserve">
          <source>Id of the logical core to which the tensor will be assigned.</source>
          <target state="translated">テンソルが割り当てられる論理コアのID。</target>
        </trans-unit>
        <trans-unit id="7e5a975b6add84fd53e3710a9ceac15eb06663b7" translate="yes" xml:space="preserve">
          <source>Identity</source>
          <target state="translated">Identity</target>
        </trans-unit>
        <trans-unit id="d80b904d270ef375a1087a947ac36d152e92b4cb" translate="yes" xml:space="preserve">
          <source>Identity op for gradient debugging.</source>
          <target state="translated">勾配デバッグのためのアイデンティティオペランド。</target>
        </trans-unit>
        <trans-unit id="bcb6f3d33c4ea39559275c930a1a34976ca902d4" translate="yes" xml:space="preserve">
          <source>Identity transformation that models performance.</source>
          <target state="translated">パフォーマンスをモデル化したアイデンティティ変換。</target>
        </trans-unit>
        <trans-unit id="a76eeb09e71e8d2d0f23e62506c812d22c2249b1" translate="yes" xml:space="preserve">
          <source>IdentityN</source>
          <target state="translated">IdentityN</target>
        </trans-unit>
        <trans-unit id="e4b9406c08cb428e87ba5ea8a378f561e51f4001" translate="yes" xml:space="preserve">
          <source>IdentityReader</source>
          <target state="translated">IdentityReader</target>
        </trans-unit>
        <trans-unit id="a0979d88b1fbcd35635c010eeafb5d1b3fed8a90" translate="yes" xml:space="preserve">
          <source>IdentityReaderV2</source>
          <target state="translated">IdentityReaderV2</target>
        </trans-unit>
        <trans-unit id="751c68a3471b1c791efaee0a8e7c24ea0c266efd" translate="yes" xml:space="preserve">
          <source>If</source>
          <target state="translated">If</target>
        </trans-unit>
        <trans-unit id="c1c674b793716e07ef9b792eb875da397416ebb5" translate="yes" xml:space="preserve">
          <source>If &quot;ortho&quot;, orthonormal inverse DCT4 is performed, if it is None, a regular dct4 followed by scaling of &lt;code&gt;1/frame_length&lt;/code&gt; is performed.</source>
          <target state="translated">「ortho」の場合、正規直交逆DCT4が実行され、Noneの場合、通常のdct4とそれに続く &lt;code&gt;1/frame_length&lt;/code&gt; のスケーリングが実行されます。</target>
        </trans-unit>
        <trans-unit id="6b472357b902f890e4087773a365cdaed808b715" translate="yes" xml:space="preserve">
          <source>If &quot;shape&quot; is None, the resulting tensor proto represents the numpy array precisely.</source>
          <target state="translated">shape&quot; が None の場合,結果として得られる tensor proto は numpy 配列を正確に表します.</target>
        </trans-unit>
        <trans-unit id="94418d02e3456ba7719cd5581956e1dd1bf97adf" translate="yes" xml:space="preserve">
          <source>If &quot;values&quot; is a python scalar or a python list, make_tensor_proto first convert it to numpy ndarray. If dtype is None, the conversion tries its best to infer the right numpy data type. Otherwise, the resulting numpy array has a compatible data type with the given dtype.</source>
          <target state="translated">もし &quot;values&quot; が python のスカラか python のリストであれば、make_tensor_proto はまずそれを numpy の ndarray に変換します。dtypeがNoneの場合、変換は正しいnumpyデータ型を推論するために最善を尽くします。そうでなければ、結果として得られる numpy 配列は、与えられた dtype と互換性のあるデータ型を持ちます。</target>
        </trans-unit>
        <trans-unit id="ce8cd0fc85fc9a1e3f9b8136172f9b19c9148972" translate="yes" xml:space="preserve">
          <source>If 'graph_def' is not a graph_pb2.GraphDef proto.</source>
          <target state="translated">graph_def' が graph_pb2.GraphDef プロトでない場合。</target>
        </trans-unit>
        <trans-unit id="abc290220c1d811dd5249ce87700169b77049924" translate="yes" xml:space="preserve">
          <source>If 3-D, the shape is &lt;code&gt;[height, width, channels]&lt;/code&gt;, and the Tensor represents one image. If 4-D, the shape is &lt;code&gt;[batch_size, height, width, channels]&lt;/code&gt;, and the Tensor represents &lt;code&gt;batch_size&lt;/code&gt; images.</source>
          <target state="translated">3Dの場合、形状は &lt;code&gt;[height, width, channels]&lt;/code&gt; であり、テンソルは1つの画像を表します。4-Dの場合、形状は &lt;code&gt;[batch_size, height, width, channels]&lt;/code&gt; であり、Tensorは &lt;code&gt;batch_size&lt;/code&gt; 画像を表します。</target>
        </trans-unit>
        <trans-unit id="d1d182960fbca1d39b731de95605b52d11d64a48" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;0 &amp;lt; min &amp;lt; max&lt;/code&gt;: &lt;code&gt;min_adj = 0&lt;/code&gt; and &lt;code&gt;max_adj = max - min&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;0 &amp;lt; min &amp;lt; max&lt;/code&gt; 場合： &lt;code&gt;min_adj = 0&lt;/code&gt; および &lt;code&gt;max_adj = max - min&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2291e4d4d0493fe7acb48d2007a3752b8f7b2d33" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is block circulant, with block sizes &lt;code&gt;N0, N1&lt;/code&gt; (&lt;code&gt;N0 * N1 = N&lt;/code&gt;): &lt;code&gt;A&lt;/code&gt; has a block circulant structure, composed of &lt;code&gt;N0 x N0&lt;/code&gt; blocks, with each block an &lt;code&gt;N1 x N1&lt;/code&gt; circulant matrix.</source>
          <target state="translated">場合 &lt;code&gt;A&lt;/code&gt; はブロックサイズと、ブロック巡回ある &lt;code&gt;N0, N1&lt;/code&gt; （ &lt;code&gt;N0 * N1 = N&lt;/code&gt; ）： &lt;code&gt;A&lt;/code&gt; は、からなるブロック巡回構造、有する &lt;code&gt;N0 x N0&lt;/code&gt; 各ブロックと、ブロック &lt;code&gt;N1 x N1&lt;/code&gt; 循環行列。</target>
        </trans-unit>
        <trans-unit id="d3f8efbf3d9e6147ecaa064f2b05f3a2250d33f3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is nested block circulant, with block sizes &lt;code&gt;N0, N1, N2&lt;/code&gt; (&lt;code&gt;N0 * N1 * N2 = N&lt;/code&gt;): &lt;code&gt;A&lt;/code&gt; has a block structure, composed of &lt;code&gt;N0 x N0&lt;/code&gt; blocks, with each block an &lt;code&gt;N1 x N1&lt;/code&gt; block circulant matrix.</source>
          <target state="translated">場合 &lt;code&gt;A&lt;/code&gt; は、ネストされたブロックを有するブロック巡回は、サイズ &lt;code&gt;N0, N1, N2&lt;/code&gt; （ &lt;code&gt;N0 * N1 * N2 = N&lt;/code&gt; ）： &lt;code&gt;A&lt;/code&gt; は、からなるブロック構造た &lt;code&gt;N0 x N0&lt;/code&gt; 各ブロックと、ブロック &lt;code&gt;N1 x N1&lt;/code&gt; 循環行列をブロックします。</target>
        </trans-unit>
        <trans-unit id="be595307418539e13ef1fb9321c103ad2f7818c8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;False&lt;/code&gt; (default) raise an error if there are no variables in the graph. Otherwise, construct the saver anyway and make it a no-op.</source>
          <target state="translated">場合 &lt;code&gt;False&lt;/code&gt; （デフォルト）グラフの変数がない場合はエラーを発生させます。それ以外の場合は、とにかくセーバーを構築し、それをノーオペレーションにします。</target>
        </trans-unit>
        <trans-unit id="76019b2232667e78369e47c4fc4d6fef16616868" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;False&lt;/code&gt;, allows the variable to be initialized with a value of unknown shape. If &lt;code&gt;True&lt;/code&gt;, the default, the shape of &lt;code&gt;initial_value&lt;/code&gt; must be known.</source>
          <target state="translated">&lt;code&gt;False&lt;/code&gt; の場合、変数を未知の形状の値で初期化できます。場合 &lt;code&gt;True&lt;/code&gt; 、既定の形状 &lt;code&gt;initial_value&lt;/code&gt; が知らなければなりません。</target>
        </trans-unit>
        <trans-unit id="1ce446f25db0af92e41fafc3bf4dab8c93e6763a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;False&lt;/code&gt;, raises an error if any of the threads are still alive after &lt;code&gt;stop_grace_period_secs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;False&lt;/code&gt; の場合、 &lt;code&gt;stop_grace_period_secs&lt;/code&gt; の後もスレッドのいずれかがまだ生きていると、エラーが発生します。</target>
        </trans-unit>
        <trans-unit id="12c5ee09ddeadea58c00f27a5fe9253ffe07db54" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;False&lt;/code&gt;, yields the whole batch as returned by the &lt;code&gt;model_fn&lt;/code&gt; instead of decomposing the batch into individual elements. This is useful if &lt;code&gt;model_fn&lt;/code&gt; returns some tensors whose first dimension is not equal to the batch size.</source>
          <target state="translated">&lt;code&gt;False&lt;/code&gt; の場合、バッチを個々の要素に分解するのではなく、 &lt;code&gt;model_fn&lt;/code&gt; によって返されるバッチ全体を生成します。これは、 &lt;code&gt;model_fn&lt;/code&gt; が最初の次元がバッチサイズと等しくないテンソルを返す場合に役立ちます。</target>
        </trans-unit>
        <trans-unit id="25587966a8e2f216b6da2cdce4060125a4291eb7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;H.shape = [N0, N1, N2]&lt;/code&gt;, (&lt;code&gt;N0 * N1 * N2 = N&lt;/code&gt;): Loosely speaking, matrix multiplication is equal to the action of a Fourier multiplier: &lt;code&gt;A u = IDFT3[ H DFT3[u] ]&lt;/code&gt;. Precisely speaking, given &lt;code&gt;[N, R]&lt;/code&gt; matrix &lt;code&gt;u&lt;/code&gt;, let &lt;code&gt;DFT3[u]&lt;/code&gt; be the &lt;code&gt;[N0, N1, N2, R]&lt;/code&gt;&lt;code&gt;Tensor&lt;/code&gt; defined by re-shaping &lt;code&gt;u&lt;/code&gt; to &lt;code&gt;[N0, N1, N2, R]&lt;/code&gt; and taking a three dimensional DFT across the first three dimensions. Let &lt;code&gt;IDFT3&lt;/code&gt; be the inverse of &lt;code&gt;DFT3&lt;/code&gt;. Matrix multiplication may be expressed columnwise:</source>
          <target state="translated">場合 &lt;code&gt;H.shape = [N0, N1, N2]&lt;/code&gt; 、（ &lt;code&gt;N0 * N1 * N2 = N&lt;/code&gt; ）：大まかに言えば、行列乗算は、フーリエ変換の乗算器の動作と同じである &lt;code&gt;A u = IDFT3[ H DFT3[u] ]&lt;/code&gt; 。正確に言えば、所与 &lt;code&gt;[N, R]&lt;/code&gt; 行列 &lt;code&gt;u&lt;/code&gt; 、聞かせて &lt;code&gt;DFT3[u]&lt;/code&gt; である &lt;code&gt;[N0, N1, N2, R]&lt;/code&gt; &lt;code&gt;Tensor&lt;/code&gt; 再成形することによって定義された &lt;code&gt;u&lt;/code&gt; する &lt;code&gt;[N0, N1, N2, R]&lt;/code&gt; と三次元を取ります最初の3次元にわたるDFT。してみましょう &lt;code&gt;IDFT3&lt;/code&gt; はの逆も &lt;code&gt;DFT3&lt;/code&gt; 。行列の乗算は列ごとに表すことができます：</target>
        </trans-unit>
        <trans-unit id="7e381afea75d47e56f3608744fb4bdb4a6e5cfdf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;H.shape = [N0, N1]&lt;/code&gt;, (&lt;code&gt;N0 * N1 = N&lt;/code&gt;): Loosely speaking, matrix multiplication is equal to the action of a Fourier multiplier: &lt;code&gt;A u = IDFT2[ H DFT2[u] ]&lt;/code&gt;. Precisely speaking, given &lt;code&gt;[N, R]&lt;/code&gt; matrix &lt;code&gt;u&lt;/code&gt;, let &lt;code&gt;DFT2[u]&lt;/code&gt; be the &lt;code&gt;[N0, N1, R]&lt;/code&gt;&lt;code&gt;Tensor&lt;/code&gt; defined by re-shaping &lt;code&gt;u&lt;/code&gt; to &lt;code&gt;[N0, N1, R]&lt;/code&gt; and taking a two dimensional DFT across the first two dimensions. Let &lt;code&gt;IDFT2&lt;/code&gt; be the inverse of &lt;code&gt;DFT2&lt;/code&gt;. Matrix multiplication may be expressed columnwise:</source>
          <target state="translated">場合 &lt;code&gt;H.shape = [N0, N1]&lt;/code&gt; 、（ &lt;code&gt;N0 * N1 = N&lt;/code&gt; ）：大まかに言えば、行列乗算は、フーリエ変換の乗算器の動作と同じである &lt;code&gt;A u = IDFT2[ H DFT2[u] ]&lt;/code&gt; 。正確に与えられ、話す &lt;code&gt;[N, R]&lt;/code&gt; 行列 &lt;code&gt;u&lt;/code&gt; 、聞かせて &lt;code&gt;DFT2[u]&lt;/code&gt; である &lt;code&gt;[N0, N1, R]&lt;/code&gt; &lt;code&gt;Tensor&lt;/code&gt; 再成形することによって定義された &lt;code&gt;u&lt;/code&gt; する &lt;code&gt;[N0, N1, R]&lt;/code&gt; 及び第横切って二次元DFTを取ります二次元。してみましょう &lt;code&gt;IDFT2&lt;/code&gt; はの逆も &lt;code&gt;DFT2&lt;/code&gt; 。行列の乗算は列ごとに表すことができます：</target>
        </trans-unit>
        <trans-unit id="4bbcbab5946b02f4bd8339afde5bc909bf23760f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;L&lt;/code&gt; is non-singular, solves and determinants are available. Solves/determinants both involve a solve/determinant of a &lt;code&gt;K x K&lt;/code&gt; system. In the event that L and D are self-adjoint positive-definite, and U = V, this can be done using a Cholesky factorization. The user should set the &lt;code&gt;is_X&lt;/code&gt; matrix property hints, which will trigger the appropriate code path.</source>
          <target state="translated">&lt;code&gt;L&lt;/code&gt; が特異でない場合、解と行列式が利用できます。解/決定要因はどちらも &lt;code&gt;K x K&lt;/code&gt; システムの解/決定要因を含みます。LとDが自己随伴正定値であり、U = Vである場合、これはコレスキー分解を使用して行うことができます。ユーザーは &lt;code&gt;is_X&lt;/code&gt; マトリックスプロパティヒントを設定する必要があります。これにより、適切なコードパスがトリガーされます。</target>
        </trans-unit>
        <trans-unit id="9426460040356d10df11f6a515a1e8a979f481d4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;M = N&lt;/code&gt;, determinants and solves are done using the matrix determinant lemma and Woodbury identities, and thus require L and D to be non-singular.</source>
          <target state="translated">&lt;code&gt;M = N&lt;/code&gt; 場合、行列式と解法は行列行列の補助定理とウッドベリーアイデンティティを使用して行われるため、LとDが非特異である必要があります。</target>
        </trans-unit>
        <trans-unit id="ad6839f42ef3ffc050c2206365782e56e109f3df" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;M=N&lt;/code&gt;, &lt;code&gt;operator.determinant()&lt;/code&gt; is &lt;code&gt;O(N^3)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;M=N&lt;/code&gt; の場合、 &lt;code&gt;operator.determinant()&lt;/code&gt; は &lt;code&gt;O(N^3)&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="7d2680f7f302962db3beec63891212a96a0cde62" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;M=N&lt;/code&gt;, &lt;code&gt;operator.solve(x)&lt;/code&gt; is &lt;code&gt;O(N^3 * R)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;M=N&lt;/code&gt; の場合、 &lt;code&gt;operator.solve(x)&lt;/code&gt; は &lt;code&gt;O(N^3 * R)&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="135f5e4b5839b28e49cfbf03c1f2e3688968e292" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;None&lt;/code&gt;, this column's graph operations will fail for out-of-range inputs. Otherwise, this value must be in the range &lt;code&gt;[0, num_buckets)&lt;/code&gt;, and will replace out-of-range inputs.</source>
          <target state="translated">&lt;code&gt;None&lt;/code&gt; の場合、この列のグラフ操作は範囲外の入力に対して失敗します。それ以外の場合、この値は &lt;code&gt;[0, num_buckets)&lt;/code&gt; 範囲内にある必要があり、範囲外の入力を置き換えます。</target>
        </trans-unit>
        <trans-unit id="ef95464404d2b393bbdf4fc6ab3d0ee4bd75e4aa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;SLICED&lt;/code&gt;, &lt;code&gt;input_fn&lt;/code&gt; is only invoked once on host 0 and the tensors are broadcasted to all other replicas. Unlike per_host_input_for_training=BROADCAST, each replica will only get a slice of the data instead of a whole copy. If &lt;code&gt;PER_HOST_V1&lt;/code&gt;, the behaviour is determined by per_host_input_for_training.</source>
          <target state="translated">&lt;code&gt;SLICED&lt;/code&gt; の場合、 &lt;code&gt;input_fn&lt;/code&gt; はホスト0で1回だけ呼び出され、テンソルは他のすべてのレプリカにブロードキャストされます。per_host_input_for_training = BROADCASTとは異なり、各レプリカは、コピー全体ではなく、データのスライスのみを取得します。場合 &lt;code&gt;PER_HOST_V1&lt;/code&gt; 、動作がper_host_input_for_trainingによって決定されます。</target>
        </trans-unit>
        <trans-unit id="e41171d0e9385cb32976695c17de0293dfc81335" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is smaller than &lt;code&gt;type&lt;/code&gt;, the operator requires that the rightmost dimension be equal to sizeof(&lt;code&gt;type&lt;/code&gt;)/sizeof(&lt;code&gt;T&lt;/code&gt;). The shape then goes from [..., sizeof(&lt;code&gt;type&lt;/code&gt;)/sizeof(&lt;code&gt;T&lt;/code&gt;)] to [...].</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; が &lt;code&gt;type&lt;/code&gt; よりも小さい場合、オペレーターは右端の次元がsizeof（ &lt;code&gt;type&lt;/code&gt; ）/ sizeof（ &lt;code&gt;T&lt;/code&gt; ）に等しいことを要求します。その後、形状は[...、sizeof（ &lt;code&gt;type&lt;/code&gt; ）/ sizeof（ &lt;code&gt;T&lt;/code&gt; ）]から[...]になります。</target>
        </trans-unit>
        <trans-unit id="f079c69e69a4356b0afc3a68a04e8a9df020a45f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt; also add the variable to the graph collection &lt;code&gt;GraphKeys.TRAINABLE_VARIABLES&lt;/code&gt; (see &lt;a href=&quot;../../../variable&quot;&gt;&lt;code&gt;tf.Variable&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;True&lt;/code&gt; の場合、変数をグラフコレクション &lt;code&gt;GraphKeys.TRAINABLE_VARIABLES&lt;/code&gt; にも追加します（&lt;a href=&quot;../../../variable&quot;&gt; &lt;code&gt;tf.Variable&lt;/code&gt; を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="e4ea3bdb19c685aaba0fdcffcc4245ede4dfe76e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt; also add the variable to the graph collection &lt;code&gt;GraphKeys.TRAINABLE_VARIABLES&lt;/code&gt; (see &lt;a href=&quot;../../variable&quot;&gt;&lt;code&gt;tf.Variable&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;True&lt;/code&gt; の場合、変数をグラフコレクション &lt;code&gt;GraphKeys.TRAINABLE_VARIABLES&lt;/code&gt; にも追加します（&lt;a href=&quot;../../variable&quot;&gt; &lt;code&gt;tf.Variable&lt;/code&gt; を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="a01f60da247392cdad0c9e7a8e6ffe0d9121cf14" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt; ignores threads that remain running after a grace period when joining threads via the coordinator, instead of raising a RuntimeError.</source>
          <target state="translated">&lt;code&gt;True&lt;/code&gt; の場合、RuntimeErrorを発生させる代わりに、コーディネーターを介してスレッドを結合するときに、猶予期間後に実行されたままのスレッドを無視します。</target>
        </trans-unit>
        <trans-unit id="946aecac475452eb0ed096696a58e4ebd59858f4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt; then left and right singular vectors will be computed and returned in &lt;code&gt;u&lt;/code&gt; and &lt;code&gt;v&lt;/code&gt;, respectively. Otherwise, only the singular values will be computed, which can be significantly faster.</source>
          <target state="translated">&lt;code&gt;True&lt;/code&gt; の場合、左と右の特異ベクトルが計算され、それぞれ &lt;code&gt;u&lt;/code&gt; と &lt;code&gt;v&lt;/code&gt; で返されます。それ以外の場合は、特異値のみが計算され、大幅に高速化されます。</target>
        </trans-unit>
        <trans-unit id="4a21cfe2fdb7abc2b66d47b4c832133c76184e58" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt; use Nesterov Momentum. See (Sutskever et al., 2013). This implementation always computes gradients at the value of the variable(s) passed to the optimizer. Using Nesterov Momentum makes the variable(s) track the values called &lt;code&gt;theta_t + mu*v_t&lt;/code&gt; in the paper. This implementation is an approximation of the original formula, valid for high values of momentum. It will compute the &quot;adjusted gradient&quot; in NAG by assuming that the new gradient will be estimated by the current average gradient plus the product of momentum and the change in the average gradient.</source>
          <target state="translated">場合は &lt;code&gt;True&lt;/code&gt; がネステロフの勢いを使用しています。（Sutskever et al。、2013）を参照してください。この実装は常に、オプティマイザーに渡された変数の値で勾配を計算します。Nesterov Momentumを使用すると、変数は、論文で &lt;code&gt;theta_t + mu*v_t&lt;/code&gt; と呼ばれる値を追跡します。この実装は元の式の近似であり、高い運動量の値に有効です。新しい勾配が現在の平均勾配に運動量と平均勾配の変化の積を加えたものによって推定されると仮定することにより、NAGの「調整された勾配」を計算します。</target>
        </trans-unit>
        <trans-unit id="86237982c3c43c35aa2590c7e6ebaefaedebe548" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt; use locks for update operations.</source>
          <target state="translated">&lt;code&gt;True&lt;/code&gt; の場合、更新操作にロックを使用します。</target>
        </trans-unit>
        <trans-unit id="94436823001587bebe4bff18b8f99b1bbfb1c438" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, &lt;code&gt;a&lt;/code&gt; is conjugated and transposed before multiplication.</source>
          <target state="translated">&lt;code&gt;True&lt;/code&gt; の場合、 &lt;code&gt;a&lt;/code&gt; は共役され、乗算の前に転置されます。</target>
        </trans-unit>
        <trans-unit id="a642a7ec441e51ecf27e357c6a9696cb5e000375" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, &lt;code&gt;a&lt;/code&gt; is transposed before multiplication.</source>
          <target state="translated">&lt;code&gt;True&lt;/code&gt; の場合、 &lt;code&gt;a&lt;/code&gt; は乗算の前に転置されます。</target>
        </trans-unit>
        <trans-unit id="7ddf60234d5af08780027290ae88b8168ae65fce" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, &lt;code&gt;a&lt;/code&gt; is treated as a sparse matrix.</source>
          <target state="translated">&lt;code&gt;True&lt;/code&gt; の場合、 &lt;code&gt;a&lt;/code&gt; はスパース行列として扱われます。</target>
        </trans-unit>
        <trans-unit id="52ec93076c6b1fffbc6ade7b8f68a02b7f68971d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, &lt;code&gt;a&lt;/code&gt; is treated as a sparse matrix. Notice, this &lt;strong&gt;does not support &lt;a href=&quot;../../sparse/sparsetensor&quot;&gt;&lt;code&gt;tf.sparse.SparseTensor&lt;/code&gt;&lt;/a&gt;&lt;/strong&gt;, it just makes optimizations that assume most values in &lt;code&gt;a&lt;/code&gt; are zero. See &lt;a href=&quot;../../sparse/sparse_dense_matmul&quot;&gt;&lt;code&gt;tf.sparse.sparse_dense_matmul&lt;/code&gt;&lt;/a&gt; for some support for &lt;a href=&quot;../../sparse/sparsetensor&quot;&gt;&lt;code&gt;tf.sparse.SparseTensor&lt;/code&gt;&lt;/a&gt; multiplication.</source>
          <target state="translated">&lt;code&gt;True&lt;/code&gt; の場合、 &lt;code&gt;a&lt;/code&gt; はスパース行列として扱われます。これ&lt;strong&gt;は&lt;a href=&quot;../../sparse/sparsetensor&quot;&gt; &lt;code&gt;tf.sparse.SparseTensor&lt;/code&gt; を&lt;/a&gt;&lt;/strong&gt;&lt;strong&gt;サポートしていないことに&lt;/strong&gt;注意してください。これ&lt;strong&gt;は&lt;/strong&gt;、 &lt;code&gt;a&lt;/code&gt; のほとんどの値がゼロであると想定する最適化を行うだけです。&lt;a href=&quot;../../sparse/sparsetensor&quot;&gt; &lt;code&gt;tf.sparse.SparseTensor&lt;/code&gt; &lt;/a&gt;乗算のサポートについては、&lt;a href=&quot;../../sparse/sparse_dense_matmul&quot;&gt; &lt;code&gt;tf.sparse.sparse_dense_matmul&lt;/code&gt; &lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="c1697ff3ee8a41dc246673fdb0bd9e9711e59c23" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, &lt;code&gt;a&lt;/code&gt; is treated as a sparse matrix. Notice, this &lt;strong&gt;does not support &lt;a href=&quot;../sparse/sparsetensor&quot;&gt;&lt;code&gt;tf.sparse.SparseTensor&lt;/code&gt;&lt;/a&gt;&lt;/strong&gt;, it just makes optimizations that assume most values in &lt;code&gt;a&lt;/code&gt; are zero. See &lt;a href=&quot;../sparse/sparse_dense_matmul&quot;&gt;&lt;code&gt;tf.sparse.sparse_dense_matmul&lt;/code&gt;&lt;/a&gt; for some support for &lt;a href=&quot;../sparse/sparsetensor&quot;&gt;&lt;code&gt;tf.sparse.SparseTensor&lt;/code&gt;&lt;/a&gt; multiplication.</source>
          <target state="translated">&lt;code&gt;True&lt;/code&gt; の場合、 &lt;code&gt;a&lt;/code&gt; はスパース行列として扱われます。これ&lt;strong&gt;は&lt;a href=&quot;../sparse/sparsetensor&quot;&gt; &lt;code&gt;tf.sparse.SparseTensor&lt;/code&gt; を&lt;/a&gt;&lt;/strong&gt;&lt;strong&gt;サポートしていないことに&lt;/strong&gt;注意してください。これ&lt;strong&gt;は&lt;/strong&gt;、 &lt;code&gt;a&lt;/code&gt; のほとんどの値がゼロであると想定する最適化を行うだけです。&lt;a href=&quot;../sparse/sparsetensor&quot;&gt; &lt;code&gt;tf.sparse.SparseTensor&lt;/code&gt; &lt;/a&gt;乗算のサポートについては、&lt;a href=&quot;../sparse/sparse_dense_matmul&quot;&gt; &lt;code&gt;tf.sparse.sparse_dense_matmul&lt;/code&gt; &lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="a1c9b8fad2ab98bd05073e40df3f5a02c810f953" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, &lt;code&gt;a&lt;/code&gt; is treated as a sparse matrix. Notice, this &lt;strong&gt;does not support &lt;a href=&quot;sparse/sparsetensor&quot;&gt;&lt;code&gt;tf.sparse.SparseTensor&lt;/code&gt;&lt;/a&gt;&lt;/strong&gt;, it just makes optimizations that assume most values in &lt;code&gt;a&lt;/code&gt; are zero. See &lt;a href=&quot;sparse/sparse_dense_matmul&quot;&gt;&lt;code&gt;tf.sparse.sparse_dense_matmul&lt;/code&gt;&lt;/a&gt; for some support for &lt;a href=&quot;sparse/sparsetensor&quot;&gt;&lt;code&gt;tf.sparse.SparseTensor&lt;/code&gt;&lt;/a&gt; multiplication.</source>
          <target state="translated">&lt;code&gt;True&lt;/code&gt; の場合、 &lt;code&gt;a&lt;/code&gt; はスパース行列として扱われます。これ&lt;strong&gt;は&lt;a href=&quot;sparse/sparsetensor&quot;&gt; &lt;code&gt;tf.sparse.SparseTensor&lt;/code&gt; を&lt;/a&gt;&lt;/strong&gt;&lt;strong&gt;サポートしていないことに&lt;/strong&gt;注意してください。これ&lt;strong&gt;は&lt;/strong&gt;、 &lt;code&gt;a&lt;/code&gt; のほとんどの値がゼロであると想定する最適化を行うだけです。&lt;a href=&quot;sparse/sparsetensor&quot;&gt; &lt;code&gt;tf.sparse.SparseTensor&lt;/code&gt; &lt;/a&gt;乗算のサポートについては、&lt;a href=&quot;sparse/sparse_dense_matmul&quot;&gt; &lt;code&gt;tf.sparse.sparse_dense_matmul&lt;/code&gt; &lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="8fad0a3980be272448053a98b2a7116e7f60c91f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; is conjugated and transposed before multiplication.</source>
          <target state="translated">&lt;code&gt;True&lt;/code&gt; の場合、 &lt;code&gt;b&lt;/code&gt; は共役され、乗算の前に転置されます。</target>
        </trans-unit>
        <trans-unit id="7ad4472b4b3225d0732d75b312044bfcf48b0406" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; is transposed before multiplication.</source>
          <target state="translated">&lt;code&gt;True&lt;/code&gt; の場合、 &lt;code&gt;b&lt;/code&gt; は乗算の前に転置されます。</target>
        </trans-unit>
        <trans-unit id="126790682ab49a5c3034dfafbd64f261a4ad3a9d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; is treated as a sparse matrix.</source>
          <target state="translated">&lt;code&gt;True&lt;/code&gt; の場合、 &lt;code&gt;b&lt;/code&gt; はスパース行列として扱われます。</target>
        </trans-unit>
        <trans-unit id="4cf6a577f44625697505a42af18c8b69cd849768" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; is treated as a sparse matrix. Notice, this &lt;strong&gt;does not support &lt;a href=&quot;../../sparse/sparsetensor&quot;&gt;&lt;code&gt;tf.sparse.SparseTensor&lt;/code&gt;&lt;/a&gt;&lt;/strong&gt;, it just makes optimizations that assume most values in &lt;code&gt;a&lt;/code&gt; are zero. See &lt;a href=&quot;../../sparse/sparse_dense_matmul&quot;&gt;&lt;code&gt;tf.sparse.sparse_dense_matmul&lt;/code&gt;&lt;/a&gt; for some support for &lt;a href=&quot;../../sparse/sparsetensor&quot;&gt;&lt;code&gt;tf.sparse.SparseTensor&lt;/code&gt;&lt;/a&gt; multiplication.</source>
          <target state="translated">&lt;code&gt;True&lt;/code&gt; の場合、 &lt;code&gt;b&lt;/code&gt; はスパース行列として扱われます。これ&lt;strong&gt;は&lt;a href=&quot;../../sparse/sparsetensor&quot;&gt; &lt;code&gt;tf.sparse.SparseTensor&lt;/code&gt; を&lt;/a&gt;&lt;/strong&gt;&lt;strong&gt;サポートしていないことに&lt;/strong&gt;注意してください。これ&lt;strong&gt;は&lt;/strong&gt;、 &lt;code&gt;a&lt;/code&gt; のほとんどの値がゼロであると想定する最適化を行うだけです。&lt;a href=&quot;../../sparse/sparsetensor&quot;&gt; &lt;code&gt;tf.sparse.SparseTensor&lt;/code&gt; &lt;/a&gt;乗算のサポートについては、&lt;a href=&quot;../../sparse/sparse_dense_matmul&quot;&gt; &lt;code&gt;tf.sparse.sparse_dense_matmul&lt;/code&gt; &lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="2ec845c050d819112e3b46bf32f89021852b963a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; is treated as a sparse matrix. Notice, this &lt;strong&gt;does not support &lt;a href=&quot;../sparse/sparsetensor&quot;&gt;&lt;code&gt;tf.sparse.SparseTensor&lt;/code&gt;&lt;/a&gt;&lt;/strong&gt;, it just makes optimizations that assume most values in &lt;code&gt;a&lt;/code&gt; are zero. See &lt;a href=&quot;../sparse/sparse_dense_matmul&quot;&gt;&lt;code&gt;tf.sparse.sparse_dense_matmul&lt;/code&gt;&lt;/a&gt; for some support for &lt;a href=&quot;../sparse/sparsetensor&quot;&gt;&lt;code&gt;tf.sparse.SparseTensor&lt;/code&gt;&lt;/a&gt; multiplication.</source>
          <target state="translated">&lt;code&gt;True&lt;/code&gt; の場合、 &lt;code&gt;b&lt;/code&gt; はスパース行列として扱われます。これ&lt;strong&gt;は&lt;a href=&quot;../sparse/sparsetensor&quot;&gt; &lt;code&gt;tf.sparse.SparseTensor&lt;/code&gt; を&lt;/a&gt;&lt;/strong&gt;&lt;strong&gt;サポートしていないことに&lt;/strong&gt;注意してください。これ&lt;strong&gt;は&lt;/strong&gt;、 &lt;code&gt;a&lt;/code&gt; のほとんどの値がゼロであると想定する最適化を行うだけです。&lt;a href=&quot;../sparse/sparsetensor&quot;&gt; &lt;code&gt;tf.sparse.SparseTensor&lt;/code&gt; &lt;/a&gt;乗算のサポートについては、&lt;a href=&quot;../sparse/sparse_dense_matmul&quot;&gt; &lt;code&gt;tf.sparse.sparse_dense_matmul&lt;/code&gt; &lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="b6d14d22c43ea44883e43139147e76fb5ad9623b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; is treated as a sparse matrix. Notice, this &lt;strong&gt;does not support &lt;a href=&quot;sparse/sparsetensor&quot;&gt;&lt;code&gt;tf.sparse.SparseTensor&lt;/code&gt;&lt;/a&gt;&lt;/strong&gt;, it just makes optimizations that assume most values in &lt;code&gt;a&lt;/code&gt; are zero. See &lt;a href=&quot;sparse/sparse_dense_matmul&quot;&gt;&lt;code&gt;tf.sparse.sparse_dense_matmul&lt;/code&gt;&lt;/a&gt; for some support for &lt;a href=&quot;sparse/sparsetensor&quot;&gt;&lt;code&gt;tf.sparse.SparseTensor&lt;/code&gt;&lt;/a&gt; multiplication.</source>
          <target state="translated">&lt;code&gt;True&lt;/code&gt; の場合、 &lt;code&gt;b&lt;/code&gt; はスパース行列として扱われます。これ&lt;strong&gt;は&lt;a href=&quot;sparse/sparsetensor&quot;&gt; &lt;code&gt;tf.sparse.SparseTensor&lt;/code&gt; を&lt;/a&gt;&lt;/strong&gt;&lt;strong&gt;サポートしていないことに&lt;/strong&gt;注意してください。これ&lt;strong&gt;は&lt;/strong&gt;、 &lt;code&gt;a&lt;/code&gt; のほとんどの値がゼロであると想定する最適化を行うだけです。&lt;a href=&quot;sparse/sparsetensor&quot;&gt; &lt;code&gt;tf.sparse.SparseTensor&lt;/code&gt; &lt;/a&gt;乗算のサポートについては、&lt;a href=&quot;sparse/sparse_dense_matmul&quot;&gt; &lt;code&gt;tf.sparse.sparse_dense_matmul&lt;/code&gt; &lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="222a09a0e7fe887672fd52c4d3f159ce40c5fb29" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, &lt;code&gt;rhs&lt;/code&gt; is conjugated before solving.</source>
          <target state="translated">&lt;code&gt;True&lt;/code&gt; の場合、 &lt;code&gt;rhs&lt;/code&gt; は解く前に共役になります。</target>
        </trans-unit>
        <trans-unit id="7ee0c3e2e6c4ac6e6797a5a36bf9ecf84d41c2a9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, &lt;code&gt;rhs&lt;/code&gt; is transposed before solving (has no effect if the shape of rhs is [..., M]).</source>
          <target state="translated">&lt;code&gt;True&lt;/code&gt; の場合、 &lt;code&gt;rhs&lt;/code&gt; は解決する前に転置されます（rhsの形状が[...、M]の場合は効果がありません）。</target>
        </trans-unit>
        <trans-unit id="233ae30a7f5e91029f31b27ee857d509b29f2bd2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, GradientTapes automatically watch uses of this variable. Defaults to &lt;code&gt;True&lt;/code&gt;, unless &lt;code&gt;synchronization&lt;/code&gt; is set to &lt;code&gt;ON_READ&lt;/code&gt;, in which case it defaults to &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;True&lt;/code&gt; の場合、GradientTapesはこの変数の使用を自動的に監視します。 &lt;code&gt;synchronization&lt;/code&gt; が &lt;code&gt;ON_READ&lt;/code&gt; に設定されていない限り、デフォルトは &lt;code&gt;True&lt;/code&gt; です。ON_READの場合、デフォルトは &lt;code&gt;False&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="0afa1955aa77eeb749a18ccebe78b8eeaccc2307" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, allows restoring parameters from a checkpoint where the variables have a different shape.</source>
          <target state="translated">&lt;code&gt;True&lt;/code&gt; の場合、変数の形状が異なるチェックポイントからパラメーターを復元できます。</target>
        </trans-unit>
        <trans-unit id="601907c4d4c0839c609aedb534e7cdab5256c862" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, also adds the variable to the graph collection &lt;code&gt;GraphKeys.TRAINABLE_VARIABLES&lt;/code&gt;. This collection is used as the default list of variables to use by the &lt;code&gt;Optimizer&lt;/code&gt; classes. Defaults to &lt;code&gt;True&lt;/code&gt;, unless &lt;code&gt;synchronization&lt;/code&gt; is set to &lt;code&gt;ON_READ&lt;/code&gt;, in which case it defaults to &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;True&lt;/code&gt; の場合、変数をグラフコレクション &lt;code&gt;GraphKeys.TRAINABLE_VARIABLES&lt;/code&gt; にも追加します。このコレクションは、 &lt;code&gt;Optimizer&lt;/code&gt; クラスで使用する変数のデフォルトリストとして使用されます。 &lt;code&gt;synchronization&lt;/code&gt; が &lt;code&gt;ON_READ&lt;/code&gt; に設定されていない限り、デフォルトは &lt;code&gt;True&lt;/code&gt; です。ON_READの場合、デフォルトは &lt;code&gt;False&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="337cb0d0d34855011c664db8787f193704be415a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, and the batch size does not evenly divide the input dataset size, the final smaller batch will be dropped. Defaults to &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;True&lt;/code&gt; の場合、バッチサイズが入力データセットサイズを均等に分割しない場合、最後の小さいバッチは削除されます。デフォルトは &lt;code&gt;False&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="db81e1cd0261358201cfc92220de12fd4f7d7ec2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, clip the input before casting (if necessary).</source>
          <target state="translated">&lt;code&gt;True&lt;/code&gt; の場合、キャストする前に入力をクリップします（必要な場合）。</target>
        </trans-unit>
        <trans-unit id="08c017b75b4c5c09adcc12047e395b03c28e54e0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, defer adding the save and restore ops to the &lt;code&gt;build()&lt;/code&gt; call. In that case &lt;code&gt;build()&lt;/code&gt; should be called before finalizing the graph or using the saver.</source>
          <target state="translated">&lt;code&gt;True&lt;/code&gt; の場合、 &lt;code&gt;build()&lt;/code&gt; 呼び出しへの保存および復元操作の追加を延期します。その場合、グラフを完成させる前、またはセーバーを使用する前に、 &lt;code&gt;build()&lt;/code&gt; を呼び出す必要があります。</target>
        </trans-unit>
        <trans-unit id="535bc3ef8bbf4f69fb7a9e1d93a9c142b1ce157b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, for &lt;code&gt;PER_HOST_V1&lt;/code&gt;, the &lt;code&gt;input_fn&lt;/code&gt; is invoked once on each host, and the number of hosts must be smaller or equal to the number of replicas. For PER_HOST_V2, the &lt;code&gt;input_fn&lt;/code&gt; is invoked once for each host (if the number of hosts is less than the number of replicas) or replica (if the number of replicas is less than the number of hosts. With the per-core input pipeline configuration, it is invoked once for each core. With a global batch size &lt;code&gt;train_batch_size&lt;/code&gt; in &lt;code&gt;TPUEstimator&lt;/code&gt; constructor, the batch size for each shard is &lt;code&gt;train_batch_size&lt;/code&gt; // #hosts in the &lt;code&gt;True&lt;/code&gt; or &lt;code&gt;PER_HOST_V1&lt;/code&gt; mode. In &lt;code&gt;PER_HOST_V2&lt;/code&gt; mode, it is &lt;code&gt;train_batch_size&lt;/code&gt; // #cores. In &lt;code&gt;BROADCAST&lt;/code&gt; mode, &lt;code&gt;input_fn&lt;/code&gt; is only invoked once on host 0 and the tensors are broadcasted to all other replicas. The batch size equals to &lt;code&gt;train_batch_size&lt;/code&gt;. With the per-core input pipeline configuration, the shard batch size is also &lt;code&gt;train_batch_size&lt;/code&gt; // #cores. Note: per_host_input_for_training==PER_SHARD_V1 only supports mode.TRAIN.</source>
          <target state="translated">&lt;code&gt;True&lt;/code&gt; の場合、 &lt;code&gt;PER_HOST_V1&lt;/code&gt; の場合、 &lt;code&gt;input_fn&lt;/code&gt; は各ホストで1回呼び出され、ホストの数はレプリカの数以下である必要があります。 PER_HOST_V2の場合、 &lt;code&gt;input_fn&lt;/code&gt; は、各ホスト（ホストの数がレプリカの数より少ない場合）またはレプリカ（レプリカの数がホストの数より少ない場合）に対して1回呼び出されます。コアごとの入力パイプライン構成では、各コアの後に呼び出されます。グローバルなバッチサイズで &lt;code&gt;train_batch_size&lt;/code&gt; で &lt;code&gt;TPUEstimator&lt;/code&gt; のコンストラクタ、各シャードのためのバッチサイズがある &lt;code&gt;train_batch_size&lt;/code&gt; で// #hosts &lt;code&gt;True&lt;/code&gt; または &lt;code&gt;PER_HOST_V1&lt;/code&gt; モード。で &lt;code&gt;PER_HOST_V2&lt;/code&gt; モードの場合、 &lt;code&gt;train_batch_size&lt;/code&gt; // ＃coresです。で &lt;code&gt;BROADCAST&lt;/code&gt; のモードで、 &lt;code&gt;input_fn&lt;/code&gt; のみホスト0に一度呼び出され、テンソルは、他のすべてのレプリカに放送されています。バッチサイズは &lt;code&gt;train_batch_size&lt;/code&gt; と同じです。コアごとの入力パイプライン構成では、シャードバッチサイズも &lt;code&gt;train_batch_size&lt;/code&gt; // ＃coresになります。注：per_host_input_for_training == PER_SHARD_V1はmode.TRAINのみをサポートします。</target>
        </trans-unit>
        <trans-unit id="0aef50b292b594a6da14b09ab9760986efee383b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, it will take care of initialization and recovery the underlying TensorFlow session. If &lt;code&gt;False&lt;/code&gt;, it will wait on a chief to initialize or recover the TensorFlow session.</source>
          <target state="translated">&lt;code&gt;True&lt;/code&gt; の場合、基盤となるTensorFlowセッションの初期化とリカバリを処理します。 &lt;code&gt;False&lt;/code&gt; の場合、チーフがTensorFlowセッションを初期化または回復するのを待ちます。</target>
        </trans-unit>
        <trans-unit id="15f6b2b84877ffa96ce2cbae90c18e832c6f120f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, loss and metric results are returned as a dict, with each key being the name of the metric. If &lt;code&gt;False&lt;/code&gt;, they are returned as a list.</source>
          <target state="translated">&lt;code&gt;True&lt;/code&gt; の場合、損失とメトリックの結果がdictとして返され、各キーがメトリックの名前になります。 &lt;code&gt;False&lt;/code&gt; の場合、それらはリストとして返されます。</target>
        </trans-unit>
        <trans-unit id="aa358cb3159f218d18da7d37c8763834650bf5be" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, perform exclusive cumprod.</source>
          <target state="translated">&lt;code&gt;True&lt;/code&gt; の場合、排他的なcumprodを実行します。</target>
        </trans-unit>
        <trans-unit id="c3b84bbb819fc7e0f87eb08a15090a3df3ad9ab9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, perform exclusive cumsum.</source>
          <target state="translated">&lt;code&gt;True&lt;/code&gt; の場合、排他的cumsumを実行します。</target>
        </trans-unit>
        <trans-unit id="66ec1c96eb14414e0c3909fcc072eace78950c80" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, perform exclusive cumulative log-sum-exp.</source>
          <target state="translated">&lt;code&gt;True&lt;/code&gt; の場合、排他的な累積log-sum-expを実行します。</target>
        </trans-unit>
        <trans-unit id="3abf56f37d62111bf5ebd198630f4ea32ea9ada1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, performs the cumulative log-sum-exp in the reverse direction.</source>
          <target state="translated">&lt;code&gt;True&lt;/code&gt; の場合、累積log-sum-expを逆方向に実行します。</target>
        </trans-unit>
        <trans-unit id="318211393bec4a40ac0da76a23ca5015e45c8c8c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, reading performance will be improved at the cost of non-deterministic ordering. If &lt;code&gt;False&lt;/code&gt;, the order of elements produced is deterministic prior to shuffling (elements are still randomized if &lt;code&gt;shuffle=True&lt;/code&gt;. Note that if the seed is set, then order of elements after shuffling is deterministic). Defaults to &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;True&lt;/code&gt; の場合、非決定論的な順序付けを犠牲にして、読み取りパフォーマンスが向上します。 &lt;code&gt;False&lt;/code&gt; の場合、生成される要素の順序はシャッフル前に決定論的です（ &lt;code&gt;shuffle=True&lt;/code&gt; の場合、要素は引き続きランダム化されます。シードが設定されている場合、シャッフル後の要素の順序は決定論的であることに注意してください）。デフォルトは &lt;code&gt;False&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="a8bb62dc74d88b8edaeb47f43964e47a5b518e53" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, save the GraphDebugInfo to a separate file, which in the same directory of filename and with &lt;code&gt;_debug&lt;/code&gt; added before the file extend.</source>
          <target state="translated">&lt;code&gt;True&lt;/code&gt; の場合、GraphDebugInfoを別のファイルに保存します。このファイルは、ファイル名の同じディレクトリにあり、ファイルが拡張される前に &lt;code&gt;_debug&lt;/code&gt; が追加されています。</target>
        </trans-unit>
        <trans-unit id="bf43d23f0ecd7bdfeb8cb8e4485edfa32ad1b03c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, save the GraphDebugInfo to a separate file, which in the same directory of filename and with &lt;code&gt;_debug&lt;/code&gt; added before the file extension.</source>
          <target state="translated">&lt;code&gt;True&lt;/code&gt; の場合、GraphDebugInfoを別のファイルに保存します。このファイルは、ファイル名の同じディレクトリにあり、ファイル拡張子の前に &lt;code&gt;_debug&lt;/code&gt; が追加されています。</target>
        </trans-unit>
        <trans-unit id="10baa9814ddfe2f402edcc6e487d3d143fa6aa42" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, save the GraphDebugInfo to a separate file, which in the same directory of save_path and with &lt;code&gt;_debug&lt;/code&gt; added before the file extension. This is only enabled when &lt;code&gt;write_meta_graph&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;</source>
          <target state="translated">If &lt;code&gt;True&lt;/code&gt; , save the GraphDebugInfo to a separate file, which in the same directory of save_path and with &lt;code&gt;_debug&lt;/code&gt; added before the file extension. This is only enabled when &lt;code&gt;write_meta_graph&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a4f90c2fb6fb2ab19be5872f2da029643e688f02" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, shard the checkpoints, one per device.</source>
          <target state="translated">If &lt;code&gt;True&lt;/code&gt; , shard the checkpoints, one per device.</target>
        </trans-unit>
        <trans-unit id="46d0c23c1b4c7f7cadb0bffb6e4cbfd1627119d5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, the TensorArray will be colocated on the same device as the Tensor used on its first write (write operations include &lt;code&gt;write&lt;/code&gt;, &lt;code&gt;unstack&lt;/code&gt;, and &lt;code&gt;split&lt;/code&gt;). If &lt;code&gt;False&lt;/code&gt;, the TensorArray will be placed on the device determined by the device context available during its initialization.</source>
          <target state="translated">If &lt;code&gt;True&lt;/code&gt; , the TensorArray will be colocated on the same device as the Tensor used on its first write (write operations include &lt;code&gt;write&lt;/code&gt; , &lt;code&gt;unstack&lt;/code&gt; , and &lt;code&gt;split&lt;/code&gt; ). If &lt;code&gt;False&lt;/code&gt; , the TensorArray will be placed on the device determined by the device context available during its initialization.</target>
        </trans-unit>
        <trans-unit id="8363894bad226438c506c5e40b7faccc3671fdb4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, the metrics returned will be only for this batch. If &lt;code&gt;False&lt;/code&gt;, the metrics will be statefully accumulated across batches.</source>
          <target state="translated">If &lt;code&gt;True&lt;/code&gt; , the metrics returned will be only for this batch. If &lt;code&gt;False&lt;/code&gt; , the metrics will be statefully accumulated across batches.</target>
        </trans-unit>
        <trans-unit id="8aa06177b2b04511f6d7ed4e6e71f5849438d5e3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, use locking during the assignment.</source>
          <target state="translated">If &lt;code&gt;True&lt;/code&gt; , use locking during the assignment.</target>
        </trans-unit>
        <trans-unit id="9d87a800a10420bfc89f6cb43f1131e20ba5d176" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, use locking during the operation.</source>
          <target state="translated">If &lt;code&gt;True&lt;/code&gt; , use locking during the operation.</target>
        </trans-unit>
        <trans-unit id="b927ef95a6c43e52135bc483aa864c92121f05e6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, we create an auxiliary name scope with the scope. If &lt;code&gt;False&lt;/code&gt;, we don't create it. Note that the argument is not inherited, and it only takes effect for once when creating. You should only use it for re-entering a premade variable scope.</source>
          <target state="translated">If &lt;code&gt;True&lt;/code&gt; , we create an auxiliary name scope with the scope. If &lt;code&gt;False&lt;/code&gt; , we don't create it. Note that the argument is not inherited, and it only takes effect for once when creating. You should only use it for re-entering a premade variable scope.</target>
        </trans-unit>
        <trans-unit id="1fcc0fa67fe23a49a5d74cb9655d9b3cb4f63ad8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, will create a scalar variable to scale the attention scores.</source>
          <target state="translated">If &lt;code&gt;True&lt;/code&gt; , will create a scalar variable to scale the attention scores.</target>
        </trans-unit>
        <trans-unit id="92385bcfeb82ed0fc98270c8ee3478c21cbd2b7b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, will create a variable to scale the attention scores.</source>
          <target state="translated">If &lt;code&gt;True&lt;/code&gt; , will create a variable to scale the attention scores.</target>
        </trans-unit>
        <trans-unit id="149c7fd8624dc8d2ba3ca596d6014d881674a0a6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, will write relative paths to the checkpoint state file. This is needed if the user wants to copy the checkpoint directory and reload from the copied directory.</source>
          <target state="translated">If &lt;code&gt;True&lt;/code&gt; , will write relative paths to the checkpoint state file. This is needed if the user wants to copy the checkpoint directory and reload from the copied directory.</target>
        </trans-unit>
        <trans-unit id="db8d9750c81e42e1484a51545102b5ed2e5301a0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, writes the &lt;code&gt;MetaGraphDef&lt;/code&gt; as an ASCII proto.</source>
          <target state="translated">If &lt;code&gt;True&lt;/code&gt; , writes the &lt;code&gt;MetaGraphDef&lt;/code&gt; as an ASCII proto.</target>
        </trans-unit>
        <trans-unit id="53f2411ed105fdc9115bbd2f5c44470569e72920" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, writes the graph as an ASCII proto.</source>
          <target state="translated">If &lt;code&gt;True&lt;/code&gt; , writes the graph as an ASCII proto.</target>
        </trans-unit>
        <trans-unit id="673940925e4bc982f03f7524775bd28a417c9a4e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, writes the meta_graph as an ASCII proto.</source>
          <target state="translated">If &lt;code&gt;True&lt;/code&gt; , writes the meta_graph as an ASCII proto.</target>
        </trans-unit>
        <trans-unit id="2b23962326191d9b25f9cdcce5f98485e099e80d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, zero debias moving-averages that are initialized with tensors.</source>
          <target state="translated">If &lt;code&gt;True&lt;/code&gt; , zero debias moving-averages that are initialized with tensors.</target>
        </trans-unit>
        <trans-unit id="29d6ce24d2935a15c7b87ceecd4d7f07ec4715cd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are unexpectedly close at all elements.</source>
          <target state="translated">If &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are unexpectedly close at all elements.</target>
        </trans-unit>
        <trans-unit id="080af896ac284ed3da9331039d890d8b9e9a6b6e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is an invalid types.</source>
          <target state="translated">If &lt;code&gt;a&lt;/code&gt; is an invalid types.</target>
        </trans-unit>
        <trans-unit id="76a2c5482f070a2a6296eb33a6b159ce01fd5df8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is determined statically to have &lt;code&gt;rank &amp;lt; 2&lt;/code&gt;.</source>
          <target state="translated">If &lt;code&gt;a&lt;/code&gt; is determined statically to have &lt;code&gt;rank &amp;lt; 2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="64972012cfa9f1bb68627595da20410a52e6b063" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is sparse and &lt;code&gt;b&lt;/code&gt; is dense.</source>
          <target state="translated">If &lt;code&gt;a&lt;/code&gt; is sparse and &lt;code&gt;b&lt;/code&gt; is dense.</target>
        </trans-unit>
        <trans-unit id="2c7a904e6acee7cc058932afbbd9186b0a891454" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;adjoint_a == false&lt;/code&gt;: &lt;code&gt;A&lt;/code&gt; should be sorted in lexicographically increasing order. Use &lt;a href=&quot;reorder&quot;&gt;&lt;code&gt;sparse.reorder&lt;/code&gt;&lt;/a&gt; if you're not sure.</source>
          <target state="translated">&lt;code&gt;adjoint_a == false&lt;/code&gt; 場合： &lt;code&gt;A&lt;/code&gt; は辞書式に昇順でソートする必要があります。&lt;a href=&quot;reorder&quot;&gt; &lt;code&gt;sparse.reorder&lt;/code&gt; &lt;/a&gt;場合は、sparse.reorderを使用してください。</target>
        </trans-unit>
        <trans-unit id="07af4a9ac21faf4286799bc8a4a85745861cc3f1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;adjoint_a == true&lt;/code&gt;: &lt;code&gt;A&lt;/code&gt; should be sorted in order of increasing dimension 1 (i.e., &quot;column major&quot; order instead of &quot;row major&quot; order).</source>
          <target state="translated">もし &lt;code&gt;adjoint_a == true&lt;/code&gt; ： &lt;code&gt;A&lt;/code&gt; は増加次元1（代わりに「行の主要な」注文のすなわち、「列の主要な」オーダー）の順にソートされなければなりません。</target>
        </trans-unit>
        <trans-unit id="bcbc484ef4b22bd434aebfe0c60fc098a6f45998" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;all_model_checkpoint_timestamps&lt;/code&gt; was provided but its length does not match &lt;code&gt;all_model_checkpoint_paths&lt;/code&gt;.</source>
          <target state="translated">If &lt;code&gt;all_model_checkpoint_timestamps&lt;/code&gt; was provided but its length does not match &lt;code&gt;all_model_checkpoint_paths&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="110ff3780b3515c9d733eede8bbe4c3bc9825cee" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;all_reduce&lt;/code&gt; is called in any replica, it must be called in all replicas. The nested structure and &lt;code&gt;Tensor&lt;/code&gt; shapes must be identical in all replicas.</source>
          <target state="translated">&lt;code&gt;all_reduce&lt;/code&gt; がいずれかのレプリカで呼び出された場合、すべてのレプリカで呼び出す必要があります。ネストされた構造と &lt;code&gt;Tensor&lt;/code&gt; 形状は、すべてのレプリカで同一でなければなりません。</target>
        </trans-unit>
        <trans-unit id="17b9b3019bf6883d5abf33ab706045e5053f610a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;allow_smaller_final_batch&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, a smaller batch value than &lt;code&gt;batch_size&lt;/code&gt; is returned when the queue is closed and there are not enough elements to fill the batch, otherwise the pending elements are discarded. In addition, all output tensors' static shapes, as accessed via the &lt;code&gt;shape&lt;/code&gt; property will have a first &lt;code&gt;Dimension&lt;/code&gt; value of &lt;code&gt;None&lt;/code&gt;, and operations that depend on fixed batch_size would fail.</source>
          <target state="translated">場合 &lt;code&gt;allow_smaller_final_batch&lt;/code&gt; がある &lt;code&gt;True&lt;/code&gt; 、より小さなバッチ値 &lt;code&gt;batch_size&lt;/code&gt; キューがそうでない場合は、保留中の要素は破棄され、閉じられ、バッチを満たすのに十分な要素が存在しないときに返されます。さらに、 &lt;code&gt;shape&lt;/code&gt; プロパティを介してアクセスされるすべての出力テンソルの静的形状は、最初の &lt;code&gt;Dimension&lt;/code&gt; 値が &lt;code&gt;None&lt;/code&gt; になり、固定のbatch_sizeに依存する操作は失敗します。</target>
        </trans-unit>
        <trans-unit id="7780a6b8fb5ede22db5a5df81a148367147b9033" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;alpha&lt;/code&gt; &amp;gt; 1.0, proportionally increases the number of filters in each layer.</source>
          <target state="translated">If &lt;code&gt;alpha&lt;/code&gt; &amp;gt; 1.0, proportionally increases the number of filters in each layer.</target>
        </trans-unit>
        <trans-unit id="4a4fea5dc80e9ef14ab6ba19796973e718278379" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;alpha&lt;/code&gt; &amp;lt; 1.0, proportionally decreases the number of filters in each layer.</source>
          <target state="translated">If &lt;code&gt;alpha&lt;/code&gt; &amp;lt; 1.0, proportionally decreases the number of filters in each layer.</target>
        </trans-unit>
        <trans-unit id="f53e0917886b19aa677a91e75faea069c634a903" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;alpha&lt;/code&gt; = 1, default number of filters from the paper are used at each layer.</source>
          <target state="translated">If &lt;code&gt;alpha&lt;/code&gt; = 1, default number of filters from the paper are used at each layer.</target>
        </trans-unit>
        <trans-unit id="dd7fbda9d4e5df2aaf326a8208be66bf6fd7816b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;as_ref&lt;/code&gt; is true, the function must return a &lt;code&gt;Tensor&lt;/code&gt; reference, such as a &lt;code&gt;Variable&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;as_ref&lt;/code&gt; が trueの場合、この関数は返す必要があり &lt;code&gt;Tensor&lt;/code&gt; など、参照を &lt;code&gt;Variable&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ebdc4f6453f07fa10351f671954a8d9cfc7adb0f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis == 0&lt;/code&gt; then the i'th tensor in &lt;code&gt;output&lt;/code&gt; is the slice &lt;code&gt;value[i, :, :, :]&lt;/code&gt; and each tensor in &lt;code&gt;output&lt;/code&gt; will have shape &lt;code&gt;(B, C, D)&lt;/code&gt;. (Note that the dimension unpacked along is gone, unlike &lt;code&gt;split&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;axis == 0&lt;/code&gt; 場合、 &lt;code&gt;output&lt;/code&gt; のi番目のテンソルはスライス &lt;code&gt;value[i, :, :, :]&lt;/code&gt; あり、 &lt;code&gt;output&lt;/code&gt; 各テンソルの形状は &lt;code&gt;(B, C, D)&lt;/code&gt; ます。（ &lt;code&gt;split&lt;/code&gt; とは異なり、アンパックされた次元はなくなっていることに注意してください）。</target>
        </trans-unit>
        <trans-unit id="88a0b065f0f00041a252be5ef4e010c2b3761be1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis == 1&lt;/code&gt; then the i'th tensor in &lt;code&gt;output&lt;/code&gt; is the slice &lt;code&gt;value[:, i, :, :]&lt;/code&gt; and each tensor in &lt;code&gt;output&lt;/code&gt; will have shape &lt;code&gt;(A, C, D)&lt;/code&gt;. Etc.</source>
          <target state="translated">&lt;code&gt;axis == 1&lt;/code&gt; 場合、 &lt;code&gt;output&lt;/code&gt; のi番目のテンソルはスライス &lt;code&gt;value[:, i, :, :]&lt;/code&gt; あり、 &lt;code&gt;output&lt;/code&gt; 各テンソルの形状は &lt;code&gt;(A, C, D)&lt;/code&gt; ます。等。</target>
        </trans-unit>
        <trans-unit id="82c15a867116f27864f6d455e86bfd0be8b87837" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis&lt;/code&gt; has no entries, all dimensions are reduced, and a tensor with a single element is returned.</source>
          <target state="translated">&lt;code&gt;axis&lt;/code&gt; にエントリがない場合、すべての次元が縮小され、単一の要素を持つテンソルが返されます。</target>
        </trans-unit>
        <trans-unit id="9a8ec21ac4d58f6a8479a92f2f74cef6e393ea5c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis&lt;/code&gt; has no entries, all dimensions are reduced, and a tensor with a single element is returned. Additionally, the axes can be negative, similar to the indexing rules in Python.</source>
          <target state="translated">&lt;code&gt;axis&lt;/code&gt; にエントリがない場合、すべての次元が縮小され、単一の要素を持つテンソルが返されます。さらに、Pythonのインデックスルールと同様に、軸は負の値になる場合があります。</target>
        </trans-unit>
        <trans-unit id="e616056a6e0ccb8800df513352231e77e4264ea6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt; (the default), the input is considered a vector and a single vector norm is computed over the entire set of values in the tensor, i.e. &lt;code&gt;norm(tensor, ord=ord)&lt;/code&gt; is equivalent to &lt;code&gt;norm(reshape(tensor, [-1]), ord=ord)&lt;/code&gt;. If &lt;code&gt;axis&lt;/code&gt; is a Python integer, the input is considered a batch of vectors, and &lt;code&gt;axis&lt;/code&gt; determines the axis in &lt;code&gt;tensor&lt;/code&gt; over which to compute vector norms. If &lt;code&gt;axis&lt;/code&gt; is a 2-tuple of Python integers it is considered a batch of matrices and &lt;code&gt;axis&lt;/code&gt; determines the axes in &lt;code&gt;tensor&lt;/code&gt; over which to compute a matrix norm. Negative indices are supported. Example: If you are passing a tensor that can be either a matrix or a batch of matrices at runtime, pass &lt;code&gt;axis=[-2,-1]&lt;/code&gt; instead of &lt;code&gt;axis=None&lt;/code&gt; to make sure that matrix norms are computed.</source>
          <target state="translated">If &lt;code&gt;axis&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt; (the default), the input is considered a vector and a single vector norm is computed over the entire set of values in the tensor, i.e. &lt;code&gt;norm(tensor, ord=ord)&lt;/code&gt; is equivalent to &lt;code&gt;norm(reshape(tensor, [-1]), ord=ord)&lt;/code&gt; . If &lt;code&gt;axis&lt;/code&gt; is a Python integer, the input is considered a batch of vectors, and &lt;code&gt;axis&lt;/code&gt; determines the axis in &lt;code&gt;tensor&lt;/code&gt; over which to compute vector norms. If &lt;code&gt;axis&lt;/code&gt; is a 2-tuple of Python integers it is considered a batch of matrices and &lt;code&gt;axis&lt;/code&gt; determines the axes in &lt;code&gt;tensor&lt;/code&gt; over which to compute a matrix norm. Negative indices are supported. Example: If you are passing a tensor that can be either a matrix or a batch of matrices at runtime, pass &lt;code&gt;axis=[-2,-1]&lt;/code&gt; instead of &lt;code&gt;axis=None&lt;/code&gt; to make sure that matrix norms are computed.</target>
        </trans-unit>
        <trans-unit id="6c3c0b53459dfc2bb4beb0a0adb6072980b26e14" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis&lt;/code&gt; is None, all dimensions are reduced, and a tensor with a single element is returned.</source>
          <target state="translated">&lt;code&gt;axis&lt;/code&gt; がNoneの場合、すべての次元が縮小され、単一の要素を持つテンソルが返されます。</target>
        </trans-unit>
        <trans-unit id="ac361bdaf1da22febee0c7b1b9dcb906feac6283" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis&lt;/code&gt; is not specified.</source>
          <target state="translated">If &lt;code&gt;axis&lt;/code&gt; is not specified.</target>
        </trans-unit>
        <trans-unit id="2a8f7fa2efde73fc9bf0b0a2fab7a317d0c8657d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis&lt;/code&gt; is out of bounds.</source>
          <target state="translated">If &lt;code&gt;axis&lt;/code&gt; is out of bounds.</target>
        </trans-unit>
        <trans-unit id="1ab6e2ed9ca8b4fd5956248951445d47d21eba68" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis&lt;/code&gt; is out of range &lt;code&gt;[-(D+1), D]&lt;/code&gt;.</source>
          <target state="translated">If &lt;code&gt;axis&lt;/code&gt; is out of range &lt;code&gt;[-(D+1), D]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="40347027eb7341be1932ae7ecf56cb946b07b101" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis&lt;/code&gt; is out of the range [-(R+1), R+1).</source>
          <target state="translated">If &lt;code&gt;axis&lt;/code&gt; is out of the range [-(R+1), R+1).</target>
        </trans-unit>
        <trans-unit id="6786f976b5b7018002f788d4d5b77f161184adfa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis&lt;/code&gt; is out of the range [-R, R).</source>
          <target state="translated">If &lt;code&gt;axis&lt;/code&gt; is out of the range [-R, R).</target>
        </trans-unit>
        <trans-unit id="4602049d19408d9325e5ff8f12f74035055b93a7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;backward_layer&lt;/code&gt; has mismatched properties compared to &lt;code&gt;layer&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;backward_layer&lt;/code&gt; が &lt;code&gt;layer&lt;/code&gt; と比較してプロパティが一致しない場合。</target>
        </trans-unit>
        <trans-unit id="c1210be14982a956118b83d39f36a2c3bc225338" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;batch_shape&lt;/code&gt; initialization arg is &lt;code&gt;None&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;batch_shape&lt;/code&gt; 初期化引数が &lt;code&gt;None&lt;/code&gt; の場合：</target>
        </trans-unit>
        <trans-unit id="0b34f5f9c6902112fe4d7b168dfca4894759e293" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;batch_shape&lt;/code&gt; initialization arg is provided, and static checks cannot rule out the need to broadcast:</source>
          <target state="translated">もし &lt;code&gt;batch_shape&lt;/code&gt; 初期argが設けられており、静的チェックは、放送に必要性を排除することはできません。</target>
        </trans-unit>
        <trans-unit id="40f813420f57b9339e0284fe5e7d670f07e9a1e7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;batch_shape&lt;/code&gt; is determined statically to not be 1-D, or negative.</source>
          <target state="translated">If &lt;code&gt;batch_shape&lt;/code&gt; is determined statically to not be 1-D, or negative.</target>
        </trans-unit>
        <trans-unit id="750b252479a4a7304dd25d5ac4c741266f546400" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;boundaries&lt;/code&gt; is not a sorted list or tuple.</source>
          <target state="translated">If &lt;code&gt;boundaries&lt;/code&gt; is not a sorted list or tuple.</target>
        </trans-unit>
        <trans-unit id="f327c86c6539bbf453fac30f2d63b53e09b0f775" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;branch_fns&lt;/code&gt; is a list but does not contain 2-tuples or callables.</source>
          <target state="translated">If &lt;code&gt;branch_fns&lt;/code&gt; is a list but does not contain 2-tuples or callables.</target>
        </trans-unit>
        <trans-unit id="ea26f65ae79b93de117abe34d6db208470fe3a9b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;branch_fns&lt;/code&gt; is not a list/dictionary.</source>
          <target state="translated">If &lt;code&gt;branch_fns&lt;/code&gt; is not a list/dictionary.</target>
        </trans-unit>
        <trans-unit id="4e0014fe3e6f4ed6ff2b3d6fdd0d4f70bafb4a1a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;by_name&lt;/code&gt; is False weights are loaded based on the network's topology. This means the architecture should be the same as when the weights were saved. Note that layers that don't have weights are not taken into account in the topological ordering, so adding or removing layers is fine as long as they don't have weights.</source>
          <target state="translated">&lt;code&gt;by_name&lt;/code&gt; がFalseの場合、重みはネットワークのトポロジに基づいて読み込まれます。これは、重みが保存されたときと同じアーキテクチャであることを意味します。ウェイトを持たないレイヤーはトポロジーの順序付けでは考慮されないため、レイヤーにウェイトがない限り、レイヤーの追加や削除は問題ありません。</target>
        </trans-unit>
        <trans-unit id="15a8bafdca0abb98187bac49dd0616a9d631c410" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;by_name&lt;/code&gt; is True, weights are loaded into layers only if they share the same name. This is useful for fine-tuning or transfer-learning models where some of the layers have changed.</source>
          <target state="translated">&lt;code&gt;by_name&lt;/code&gt; がTrueの場合、同じ名前を共有する場合にのみ、ウェイトがレイヤーにロードされます。これは、一部のレイヤーが変更された微調整モデルまたは転移学習モデルに役立ちます。</target>
        </trans-unit>
        <trans-unit id="845594347374dd00bfd7e659fdc63e7e3d5b4f06" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;bytes_or_text&lt;/code&gt; is not a binary or unicode string.</source>
          <target state="translated">If &lt;code&gt;bytes_or_text&lt;/code&gt; is not a binary or unicode string.</target>
        </trans-unit>
        <trans-unit id="8eec2900c2fb0f0251b678a361ecad074ba0af19" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;cancel_pending_enqueues&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, all pending requests will also be canceled.</source>
          <target state="translated">&lt;code&gt;cancel_pending_enqueues&lt;/code&gt; が &lt;code&gt;True&lt;/code&gt; の場合、保留中のすべてのリクエストもキャンセルされます。</target>
        </trans-unit>
        <trans-unit id="0da424a258741377ad7f1b3412ace95e1b7e087b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;categorical_column&lt;/code&gt; is not CategoricalColumn type.</source>
          <target state="translated">If &lt;code&gt;categorical_column&lt;/code&gt; is not CategoricalColumn type.</target>
        </trans-unit>
        <trans-unit id="2cb637aa705c546a113e41afd5c758c47dd8f823" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;cell&lt;/code&gt; is not an instance of RNNCell, or &lt;code&gt;loop_fn&lt;/code&gt; is not a &lt;code&gt;callable&lt;/code&gt;.</source>
          <target state="translated">If &lt;code&gt;cell&lt;/code&gt; is not an instance of RNNCell, or &lt;code&gt;loop_fn&lt;/code&gt; is not a &lt;code&gt;callable&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7d8fa2cfd25e1b41a79e7e3b6b4253739977bfe6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;cell&lt;/code&gt; is not an instance of RNNCell.</source>
          <target state="translated">If &lt;code&gt;cell&lt;/code&gt; is not an instance of RNNCell.</target>
        </trans-unit>
        <trans-unit id="2c005314f14b9be4b12102c1d51d0d8b497fafda" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;cell_fw&lt;/code&gt; or &lt;code&gt;cell_bw&lt;/code&gt; is not an instance of &lt;code&gt;RNNCell&lt;/code&gt;.</source>
          <target state="translated">If &lt;code&gt;cell_fw&lt;/code&gt; or &lt;code&gt;cell_bw&lt;/code&gt; is not an instance of &lt;code&gt;RNNCell&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d24f152ba9fe436f35ebbbc28f22afb95d7ac755" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ckpt_dir_or_file&lt;/code&gt; resolves to a directory with multiple checkpoints, reader for the latest checkpoint is returned.</source>
          <target state="translated">&lt;code&gt;ckpt_dir_or_file&lt;/code&gt; が複数のチェックポイントを持つディレクトリに解決される場合、最新のチェックポイントのリーダーが返されます。</target>
        </trans-unit>
        <trans-unit id="d2998b18d77ff28c7539e06d755706c8cf0700ef" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ckpt_dir_or_file&lt;/code&gt; resolves to a directory with no checkpoints.</source>
          <target state="translated">If &lt;code&gt;ckpt_dir_or_file&lt;/code&gt; resolves to a directory with no checkpoints.</target>
        </trans-unit>
        <trans-unit id="20bd49990b5cf72ae3b08662dd38487aaacb7b14" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;class_id&lt;/code&gt; is specified, we calculate precision by considering only the entries in the batch for which &lt;code&gt;class_id&lt;/code&gt; is above the threshold and/or in the top-k highest predictions, and computing the fraction of them for which &lt;code&gt;class_id&lt;/code&gt; is indeed a correct label.</source>
          <target state="translated">&lt;code&gt;class_id&lt;/code&gt; が指定されている場合、精度を計算するには、 &lt;code&gt;class_id&lt;/code&gt; がしきい値を超えているバッチおよび/または上位kの最も高い予測のエントリのみを考慮し、 &lt;code&gt;class_id&lt;/code&gt; が実際に正しいラベルであるそれらの割合を計算します。</target>
        </trans-unit>
        <trans-unit id="594da24c877b56fce6dcc330d36e921550f67631" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;class_id&lt;/code&gt; is specified, we calculate precision by considering only the entries in the batch for which &lt;code&gt;class_id&lt;/code&gt; is in the top-k highest &lt;code&gt;predictions&lt;/code&gt;, and computing the fraction of them for which &lt;code&gt;class_id&lt;/code&gt; is indeed a correct label. If &lt;code&gt;class_id&lt;/code&gt; is not specified, we'll calculate precision as how often on average a class among the top-k classes with the highest predicted values of a batch entry is correct and can be found in the label for that entry.</source>
          <target state="translated">&lt;code&gt;class_id&lt;/code&gt; が指定されている場合は、 &lt;code&gt;class_id&lt;/code&gt; が上位kの &lt;code&gt;predictions&lt;/code&gt; にあるバッチのエントリのみを考慮して精度を計算し、 &lt;code&gt;class_id&lt;/code&gt; が実際に正しいラベルであるそれらの割合を計算します。 &lt;code&gt;class_id&lt;/code&gt; が指定されていない場合、バッチエントリの予測値が最も高い上位k個のクラスの平均がどれほどの頻度で正確であるかを計算し、そのエントリのラベルで見つけることができます。</target>
        </trans-unit>
        <trans-unit id="a2fed35668157bd216f9480f06ebfb465420b146" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;class_id&lt;/code&gt; is specified, we calculate recall by considering only the entries in the batch for which &lt;code&gt;class_id&lt;/code&gt; is in the label, and computing the fraction of them for which &lt;code&gt;class_id&lt;/code&gt; is above the threshold and/or in the top-k predictions.</source>
          <target state="translated">場合 &lt;code&gt;class_id&lt;/code&gt; 指定されている、我々はそのためのバッチでのエントリだけ考慮してリコール計算 &lt;code&gt;class_id&lt;/code&gt; ラベルであるが、それらの割合を計算しているため &lt;code&gt;class_id&lt;/code&gt; および/またはトップk個の予測では閾値を超えています。</target>
        </trans-unit>
        <trans-unit id="0598665208e329d2285f13959a4c8a0be2108783" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;class_id&lt;/code&gt; is specified, we calculate recall by considering only the entries in the batch for which &lt;code&gt;class_id&lt;/code&gt; is in the label, and computing the fraction of them for which &lt;code&gt;class_id&lt;/code&gt; is in the top-k &lt;code&gt;predictions&lt;/code&gt;. If &lt;code&gt;class_id&lt;/code&gt; is not specified, we'll calculate recall as how often on average a class among the labels of a batch entry is in the top-k &lt;code&gt;predictions&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;class_id&lt;/code&gt; が指定されている場合は、 &lt;code&gt;class_id&lt;/code&gt; がラベルに含まれているバッチのエントリのみを考慮し、 &lt;code&gt;class_id&lt;/code&gt; が上位kの &lt;code&gt;predictions&lt;/code&gt; れているエントリの割合を計算することで、再現率を計算します。 &lt;code&gt;class_id&lt;/code&gt; が指定されていない場合は、バッチエントリのラベル間のクラスが平均して上位kの &lt;code&gt;predictions&lt;/code&gt; れる頻度として再現率を計算します。</target>
        </trans-unit>
        <trans-unit id="8ed0b9e3e88d8fb4c9485f67ff031b4dbc5fc2f1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;clip_norm &amp;gt; global_norm&lt;/code&gt; then the entries in &lt;code&gt;t_list&lt;/code&gt; remain as they are, otherwise they're all shrunk by the global ratio.</source>
          <target state="translated">&lt;code&gt;clip_norm &amp;gt; global_norm&lt;/code&gt; 場合、t_listのエントリは &lt;code&gt;t_list&lt;/code&gt; 残ります。それ以外の場合は、すべてグローバル比率で縮小されます。</target>
        </trans-unit>
        <trans-unit id="7e9530f81d1e38f5cf65209f508156d9b6769612" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;cluster&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;, and &lt;code&gt;ps_tasks&lt;/code&gt; is 0, the returned function is a no-op. Otherwise, the value of &lt;code&gt;ps_tasks&lt;/code&gt; is derived from &lt;code&gt;cluster&lt;/code&gt;.</source>
          <target state="translated">場合は &lt;code&gt;cluster&lt;/code&gt; ありません &lt;code&gt;None&lt;/code&gt; 、と &lt;code&gt;ps_tasks&lt;/code&gt; 0で、返される関数は何もしません。それ以外の場合、 &lt;code&gt;ps_tasks&lt;/code&gt; の値はclusterから派生し &lt;code&gt;cluster&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d6d7bf46850010a12ccc4b12b47b4fc474e27898" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;cluster&lt;/code&gt; is not a dictionary mapping strings to lists of strings, and not a &lt;a href=&quot;clusterdef&quot;&gt;&lt;code&gt;tf.train.ClusterDef&lt;/code&gt;&lt;/a&gt; protobuf.</source>
          <target state="translated">If &lt;code&gt;cluster&lt;/code&gt; is not a dictionary mapping strings to lists of strings, and not a &lt;a href=&quot;clusterdef&quot;&gt; &lt;code&gt;tf.train.ClusterDef&lt;/code&gt; &lt;/a&gt; protobuf.</target>
        </trans-unit>
        <trans-unit id="39cf1c8eecb1ef7b4ac070aaa23d0ecfa7f82a3b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;combiner&lt;/code&gt; is not one of {&quot;mean&quot;, &quot;sqrtn&quot;, &quot;sum&quot;}.</source>
          <target state="translated">If &lt;code&gt;combiner&lt;/code&gt; is not one of {&quot;mean&quot;, &quot;sqrtn&quot;, &quot;sum&quot;}.</target>
        </trans-unit>
        <trans-unit id="065bbd8103d747b51b68745d23b95f48f33acad0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;condition&lt;/code&gt; evaluates to false, print the list of tensors in &lt;code&gt;data&lt;/code&gt;. &lt;code&gt;summarize&lt;/code&gt; determines how many entries of the tensors to print.</source>
          <target state="translated">&lt;code&gt;condition&lt;/code&gt; がfalseと評価された場合、 &lt;code&gt;data&lt;/code&gt; 内のテンソルのリストを出力します。 &lt;code&gt;summarize&lt;/code&gt; すると、印刷するテンソルのエントリ数が決まります。</target>
        </trans-unit>
        <trans-unit id="dc7c3e5a0b26f7d25559f77e68ccbfaa5c98f33a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;condition&lt;/code&gt; is a vector and &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are higher rank matrices, then it chooses which row (outer dimension) to copy from &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;. If &lt;code&gt;condition&lt;/code&gt; has the same shape as &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, then it chooses which element to copy from &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;condition&lt;/code&gt; ベクトルであり、 &lt;code&gt;x&lt;/code&gt; 及び &lt;code&gt;y&lt;/code&gt; より高いランク行列であり、それはからコピー先の行（外形寸法）を選択 &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; 。 &lt;code&gt;condition&lt;/code&gt; が &lt;code&gt;x&lt;/code&gt; および &lt;code&gt;y&lt;/code&gt; と同じ形状の場合、それは &lt;code&gt;x&lt;/code&gt; および &lt;code&gt;y&lt;/code&gt; からコピーする要素を選択します。</target>
        </trans-unit>
        <trans-unit id="852f5ef307e7bc28b2850a54f24a33882b85de2d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;control_inputs&lt;/code&gt; is not a list of &lt;code&gt;Operation&lt;/code&gt; or &lt;code&gt;Tensor&lt;/code&gt; objects.</source>
          <target state="translated">If &lt;code&gt;control_inputs&lt;/code&gt; is not a list of &lt;code&gt;Operation&lt;/code&gt; or &lt;code&gt;Tensor&lt;/code&gt; objects.</target>
        </trans-unit>
        <trans-unit id="dc07b7d3b7d37ada7c331d72e2d06fb75d39fe59" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;core_assignment&lt;/code&gt; is not a rank 3 numpy array.</source>
          <target state="translated">If &lt;code&gt;core_assignment&lt;/code&gt; is not a rank 3 numpy array.</target>
        </trans-unit>
        <trans-unit id="85cf61e910d69324c4a7ef790c66d6a2dfd03048" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ctc_merge_repeated&lt;/code&gt; is set False, then deep within the CTC calculation, repeated non-blank labels will not be merged and are interpreted as individual labels. This is a simplified (non-standard) version of CTC.</source>
          <target state="translated">&lt;code&gt;ctc_merge_repeated&lt;/code&gt; がFalseに設定されている場合、CTC計算の奥深くで、繰り返される空白以外のラベルはマージされず、個々のラベルとして解釈されます。これは、CTCの簡易（非標準）バージョンです。</target>
        </trans-unit>
        <trans-unit id="47f2aad48c2d0f196f9ea6e64ee4554117907144" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;cycle&lt;/code&gt; is True then a multiple of &lt;code&gt;decay_steps&lt;/code&gt; is used, the first one that is bigger than &lt;code&gt;global_steps&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;cycle&lt;/code&gt; Trueで、その後の複数 &lt;code&gt;decay_steps&lt;/code&gt; は、より大きい最初のものに使用され &lt;code&gt;global_steps&lt;/code&gt; を。</target>
        </trans-unit>
        <trans-unit id="5e96124e7a04b42a83269b91d81e7e32583e381c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;cycle&lt;/code&gt; is True then a multiple of &lt;code&gt;decay_steps&lt;/code&gt; is used, the first one that is bigger than &lt;code&gt;step&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;cycle&lt;/code&gt; Trueで、その後の複数 &lt;code&gt;decay_steps&lt;/code&gt; は、より大きい最初のものを使用される &lt;code&gt;step&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ed08d044f4ced3eb43b5b5b9c435daedbc9bccbf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data_format&lt;/code&gt; is &lt;code&gt;&quot;channels_first&quot;&lt;/code&gt;: &lt;code&gt;(batch, channels, cropped_rows, cropped_cols)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;data_format&lt;/code&gt; が &lt;code&gt;&quot;channels_first&quot;&lt;/code&gt; 場合： &lt;code&gt;(batch, channels, cropped_rows, cropped_cols)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c5b04849f3239ff7f2aed6311abff3cbd6b35af1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data_format&lt;/code&gt; is &lt;code&gt;&quot;channels_first&quot;&lt;/code&gt;: &lt;code&gt;(batch, channels, dim1, dim2, dim3)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;data_format&lt;/code&gt; が &lt;code&gt;&quot;channels_first&quot;&lt;/code&gt; 場合： &lt;code&gt;(batch, channels, dim1, dim2, dim3)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f34c9b34734b9df20fbf8e979f546c9c4cc5baf4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data_format&lt;/code&gt; is &lt;code&gt;&quot;channels_first&quot;&lt;/code&gt;: &lt;code&gt;(batch, channels, padded_rows, padded_cols)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;data_format&lt;/code&gt; が &lt;code&gt;&quot;channels_first&quot;&lt;/code&gt; の場合： &lt;code&gt;(batch, channels, padded_rows, padded_cols)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="18824f32ee3435a0aaf0ab5c308c42f192295a0b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data_format&lt;/code&gt; is &lt;code&gt;&quot;channels_first&quot;&lt;/code&gt;: &lt;code&gt;(batch, channels, rows, cols)&lt;/code&gt;</source>
          <target state="translated">場合 &lt;code&gt;data_format&lt;/code&gt; ある &lt;code&gt;&quot;channels_first&quot;&lt;/code&gt; :（ &lt;code&gt;(batch, channels, rows, cols)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d97ca997b91aa66ba4112051e89b9fd1d11e0319" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data_format&lt;/code&gt; is &lt;code&gt;&quot;channels_first&quot;&lt;/code&gt;: &lt;code&gt;(batch, channels, upsampled_dim1, upsampled_dim2, upsampled_dim3)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;data_format&lt;/code&gt; が &lt;code&gt;&quot;channels_first&quot;&lt;/code&gt; 場合： &lt;code&gt;(batch, channels, upsampled_dim1, upsampled_dim2, upsampled_dim3)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e6ed1bb95109cbf4e1521d123414f77ee773a64c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data_format&lt;/code&gt; is &lt;code&gt;&quot;channels_first&quot;&lt;/code&gt;: &lt;code&gt;(batch, channels, upsampled_rows, upsampled_cols)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;data_format&lt;/code&gt; が &lt;code&gt;&quot;channels_first&quot;&lt;/code&gt; 場合： &lt;code&gt;(batch, channels, upsampled_rows, upsampled_cols)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4b398a294c2ee1defa640c1a2420cb9d283d80b8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data_format&lt;/code&gt; is &lt;code&gt;&quot;channels_first&quot;&lt;/code&gt;: &lt;code&gt;(batch, depth, first_axis_to_crop, second_axis_to_crop, third_axis_to_crop)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;data_format&lt;/code&gt; が &lt;code&gt;&quot;channels_first&quot;&lt;/code&gt; 場合： &lt;code&gt;(batch, depth, first_axis_to_crop, second_axis_to_crop, third_axis_to_crop)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cfcc85522ec5786f0f0111cb911348fd3d60aa41" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data_format&lt;/code&gt; is &lt;code&gt;&quot;channels_first&quot;&lt;/code&gt;: &lt;code&gt;(batch, depth, first_axis_to_pad, second_axis_to_pad, third_axis_to_pad)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;data_format&lt;/code&gt; が &lt;code&gt;&quot;channels_first&quot;&lt;/code&gt; 場合： &lt;code&gt;(batch, depth, first_axis_to_pad, second_axis_to_pad, third_axis_to_pad)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5b26f95b56877033c8096f8c21ee90b92dfad7a9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data_format&lt;/code&gt; is &lt;code&gt;&quot;channels_first&quot;&lt;/code&gt;: &lt;code&gt;(batch, depth, first_cropped_axis, second_cropped_axis, third_cropped_axis)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;data_format&lt;/code&gt; が &lt;code&gt;&quot;channels_first&quot;&lt;/code&gt; の場合： &lt;code&gt;(batch, depth, first_cropped_axis, second_cropped_axis, third_cropped_axis)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="40a4fb20ae2e104be54b9c38059d00d6af133ad2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data_format&lt;/code&gt; is &lt;code&gt;&quot;channels_first&quot;&lt;/code&gt;: &lt;code&gt;(batch, depth, first_padded_axis, second_padded_axis, third_axis_to_pad)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;data_format&lt;/code&gt; が &lt;code&gt;&quot;channels_first&quot;&lt;/code&gt; 場合： &lt;code&gt;(batch, depth, first_padded_axis, second_padded_axis, third_axis_to_pad)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="13dbf77e04457c4f4f2d2b1bf44035da08c15b02" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data_format&lt;/code&gt; is &lt;code&gt;&quot;channels_first&quot;&lt;/code&gt;: &lt;code&gt;(batch_size, channels, cropped_rows, cropped_cols)&lt;/code&gt;</source>
          <target state="translated">If &lt;code&gt;data_format&lt;/code&gt; is &lt;code&gt;&quot;channels_first&quot;&lt;/code&gt; : &lt;code&gt;(batch_size, channels, cropped_rows, cropped_cols)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="16c3b7ad97b58254a0f880dcb00666665f89ea7c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data_format&lt;/code&gt; is &lt;code&gt;&quot;channels_first&quot;&lt;/code&gt;: &lt;code&gt;(batch_size, channels, dim1, dim2, dim3)&lt;/code&gt;</source>
          <target state="translated">If &lt;code&gt;data_format&lt;/code&gt; is &lt;code&gt;&quot;channels_first&quot;&lt;/code&gt; : &lt;code&gt;(batch_size, channels, dim1, dim2, dim3)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1fb7c8889c720e09fcfeff626a329d774fcc3a0b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data_format&lt;/code&gt; is &lt;code&gt;&quot;channels_first&quot;&lt;/code&gt;: &lt;code&gt;(batch_size, channels, padded_rows, padded_cols)&lt;/code&gt;</source>
          <target state="translated">If &lt;code&gt;data_format&lt;/code&gt; is &lt;code&gt;&quot;channels_first&quot;&lt;/code&gt; : &lt;code&gt;(batch_size, channels, padded_rows, padded_cols)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e50baf564ca14e56683795ce398dfeea230ae434" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data_format&lt;/code&gt; is &lt;code&gt;&quot;channels_first&quot;&lt;/code&gt;: &lt;code&gt;(batch_size, channels, rows, cols)&lt;/code&gt;</source>
          <target state="translated">If &lt;code&gt;data_format&lt;/code&gt; is &lt;code&gt;&quot;channels_first&quot;&lt;/code&gt; : &lt;code&gt;(batch_size, channels, rows, cols)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9212d130a38e7aa9a9cc4c3069720d3b8a25dbdf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data_format&lt;/code&gt; is &lt;code&gt;&quot;channels_first&quot;&lt;/code&gt;: &lt;code&gt;(batch_size, channels, upsampled_dim1, upsampled_dim2, upsampled_dim3)&lt;/code&gt;</source>
          <target state="translated">If &lt;code&gt;data_format&lt;/code&gt; is &lt;code&gt;&quot;channels_first&quot;&lt;/code&gt; : &lt;code&gt;(batch_size, channels, upsampled_dim1, upsampled_dim2, upsampled_dim3)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8c965d4cefe52be58f4541312fd3e5d23c6fe18f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data_format&lt;/code&gt; is &lt;code&gt;&quot;channels_first&quot;&lt;/code&gt;: &lt;code&gt;(batch_size, channels, upsampled_rows, upsampled_cols)&lt;/code&gt;</source>
          <target state="translated">If &lt;code&gt;data_format&lt;/code&gt; is &lt;code&gt;&quot;channels_first&quot;&lt;/code&gt; : &lt;code&gt;(batch_size, channels, upsampled_rows, upsampled_cols)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6e386532c5fd8c2d8fa779b964ec07b7f0be40ed" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data_format&lt;/code&gt; is &lt;code&gt;&quot;channels_first&quot;&lt;/code&gt;: &lt;code&gt;(batch_size, depth, first_axis_to_crop, second_axis_to_crop, third_axis_to_crop)&lt;/code&gt;</source>
          <target state="translated">If &lt;code&gt;data_format&lt;/code&gt; is &lt;code&gt;&quot;channels_first&quot;&lt;/code&gt; : &lt;code&gt;(batch_size, depth, first_axis_to_crop, second_axis_to_crop, third_axis_to_crop)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ba4f67f214014ed4451c10d24c0e147e61468aaf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data_format&lt;/code&gt; is &lt;code&gt;&quot;channels_first&quot;&lt;/code&gt;: &lt;code&gt;(batch_size, depth, first_axis_to_pad, second_axis_to_pad, third_axis_to_pad)&lt;/code&gt;</source>
          <target state="translated">If &lt;code&gt;data_format&lt;/code&gt; is &lt;code&gt;&quot;channels_first&quot;&lt;/code&gt; : &lt;code&gt;(batch_size, depth, first_axis_to_pad, second_axis_to_pad, third_axis_to_pad)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0888914c679befa9b2cb2fda6a224ddf95b82d80" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data_format&lt;/code&gt; is &lt;code&gt;&quot;channels_first&quot;&lt;/code&gt;: &lt;code&gt;(batch_size, depth, first_cropped_axis, second_cropped_axis, third_cropped_axis)&lt;/code&gt;</source>
          <target state="translated">If &lt;code&gt;data_format&lt;/code&gt; is &lt;code&gt;&quot;channels_first&quot;&lt;/code&gt; : &lt;code&gt;(batch_size, depth, first_cropped_axis, second_cropped_axis, third_cropped_axis)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="30c350e594e6b51e761934912455eb294521cb46" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data_format&lt;/code&gt; is &lt;code&gt;&quot;channels_first&quot;&lt;/code&gt;: &lt;code&gt;(batch_size, depth, first_padded_axis, second_padded_axis, third_axis_to_pad)&lt;/code&gt;</source>
          <target state="translated">If &lt;code&gt;data_format&lt;/code&gt; is &lt;code&gt;&quot;channels_first&quot;&lt;/code&gt; : &lt;code&gt;(batch_size, depth, first_padded_axis, second_padded_axis, third_axis_to_pad)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="83ec0b7162cfee960e285831df5e57e17a03a60e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data_format&lt;/code&gt; is &lt;code&gt;&quot;channels_last&quot;&lt;/code&gt;: &lt;code&gt;(batch, cropped_rows, cropped_cols, channels)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;data_format&lt;/code&gt; が &lt;code&gt;&quot;channels_last&quot;&lt;/code&gt; の場合： &lt;code&gt;(batch, cropped_rows, cropped_cols, channels)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3080e83cbbe1150d4ffe3e63f9f6d620396eedd3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data_format&lt;/code&gt; is &lt;code&gt;&quot;channels_last&quot;&lt;/code&gt;: &lt;code&gt;(batch, dim1, dim2, dim3, channels)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;data_format&lt;/code&gt; が &lt;code&gt;&quot;channels_last&quot;&lt;/code&gt; の場合： &lt;code&gt;(batch, dim1, dim2, dim3, channels)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="003ead137d3f3851640c5a5a4a06d578ee1562e8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data_format&lt;/code&gt; is &lt;code&gt;&quot;channels_last&quot;&lt;/code&gt;: &lt;code&gt;(batch, first_axis_to_crop, second_axis_to_crop, third_axis_to_crop, depth)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;data_format&lt;/code&gt; が &lt;code&gt;&quot;channels_last&quot;&lt;/code&gt; 場合： &lt;code&gt;(batch, first_axis_to_crop, second_axis_to_crop, third_axis_to_crop, depth)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2d5b3587001e70040c247fd7de822807f24ae9ff" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data_format&lt;/code&gt; is &lt;code&gt;&quot;channels_last&quot;&lt;/code&gt;: &lt;code&gt;(batch, first_axis_to_pad, second_axis_to_pad, third_axis_to_pad, depth)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;data_format&lt;/code&gt; が &lt;code&gt;&quot;channels_last&quot;&lt;/code&gt; 場合： &lt;code&gt;(batch, first_axis_to_pad, second_axis_to_pad, third_axis_to_pad, depth)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="483c2efe5b6618e7f64dde6715f4895ce351e56e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data_format&lt;/code&gt; is &lt;code&gt;&quot;channels_last&quot;&lt;/code&gt;: &lt;code&gt;(batch, first_cropped_axis, second_cropped_axis, third_cropped_axis, depth)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;data_format&lt;/code&gt; が &lt;code&gt;&quot;channels_last&quot;&lt;/code&gt; 場合： &lt;code&gt;(batch, first_cropped_axis, second_cropped_axis, third_cropped_axis, depth)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="df33090fd8aa7bd86d0ae1a9759ce56513b08b8e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data_format&lt;/code&gt; is &lt;code&gt;&quot;channels_last&quot;&lt;/code&gt;: &lt;code&gt;(batch, first_padded_axis, second_padded_axis, third_axis_to_pad, depth)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;data_format&lt;/code&gt; が &lt;code&gt;&quot;channels_last&quot;&lt;/code&gt; の場合： &lt;code&gt;(batch, first_padded_axis, second_padded_axis, third_axis_to_pad, depth)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="eed95b4a9ed8b9aeb9fdbd8e1b9803e00bf2766e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data_format&lt;/code&gt; is &lt;code&gt;&quot;channels_last&quot;&lt;/code&gt;: &lt;code&gt;(batch, padded_rows, padded_cols, channels)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;data_format&lt;/code&gt; が &lt;code&gt;&quot;channels_last&quot;&lt;/code&gt; の場合： &lt;code&gt;(batch, padded_rows, padded_cols, channels)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f64e4bcccce433c9566b78b8afa1f94c8c04fcef" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data_format&lt;/code&gt; is &lt;code&gt;&quot;channels_last&quot;&lt;/code&gt;: &lt;code&gt;(batch, rows, cols, channels)&lt;/code&gt;</source>
          <target state="translated">場合 &lt;code&gt;data_format&lt;/code&gt; ある &lt;code&gt;&quot;channels_last&quot;&lt;/code&gt; :（ &lt;code&gt;(batch, rows, cols, channels)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="44f47dd0c8b0b06a1527506e0b470b0131115a5f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data_format&lt;/code&gt; is &lt;code&gt;&quot;channels_last&quot;&lt;/code&gt;: &lt;code&gt;(batch, upsampled_dim1, upsampled_dim2, upsampled_dim3, channels)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;data_format&lt;/code&gt; が &lt;code&gt;&quot;channels_last&quot;&lt;/code&gt; 場合： &lt;code&gt;(batch, upsampled_dim1, upsampled_dim2, upsampled_dim3, channels)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="830a8a4e419a5e596ab42fcfe1067a6cadcf5b6c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data_format&lt;/code&gt; is &lt;code&gt;&quot;channels_last&quot;&lt;/code&gt;: &lt;code&gt;(batch, upsampled_rows, upsampled_cols, channels)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;data_format&lt;/code&gt; が &lt;code&gt;&quot;channels_last&quot;&lt;/code&gt; 場合： &lt;code&gt;(batch, upsampled_rows, upsampled_cols, channels)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9c980e0bd3d4179a05d59b1cf890443d4ce25e57" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data_format&lt;/code&gt; is &lt;code&gt;&quot;channels_last&quot;&lt;/code&gt;: &lt;code&gt;(batch_size, cropped_rows, cropped_cols, channels)&lt;/code&gt;</source>
          <target state="translated">If &lt;code&gt;data_format&lt;/code&gt; is &lt;code&gt;&quot;channels_last&quot;&lt;/code&gt; : &lt;code&gt;(batch_size, cropped_rows, cropped_cols, channels)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e566b24c18ce9f031e746f46f8905e4b74631307" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data_format&lt;/code&gt; is &lt;code&gt;&quot;channels_last&quot;&lt;/code&gt;: &lt;code&gt;(batch_size, dim1, dim2, dim3, channels)&lt;/code&gt;</source>
          <target state="translated">If &lt;code&gt;data_format&lt;/code&gt; is &lt;code&gt;&quot;channels_last&quot;&lt;/code&gt; : &lt;code&gt;(batch_size, dim1, dim2, dim3, channels)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="22610788dff2c48e984360f638bc6947aba295ab" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data_format&lt;/code&gt; is &lt;code&gt;&quot;channels_last&quot;&lt;/code&gt;: &lt;code&gt;(batch_size, first_axis_to_crop, second_axis_to_crop, third_axis_to_crop, depth)&lt;/code&gt;</source>
          <target state="translated">If &lt;code&gt;data_format&lt;/code&gt; is &lt;code&gt;&quot;channels_last&quot;&lt;/code&gt; : &lt;code&gt;(batch_size, first_axis_to_crop, second_axis_to_crop, third_axis_to_crop, depth)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d9d6a71d79669cd17f507222aaf3cb490b770b36" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data_format&lt;/code&gt; is &lt;code&gt;&quot;channels_last&quot;&lt;/code&gt;: &lt;code&gt;(batch_size, first_axis_to_pad, second_axis_to_pad, third_axis_to_pad, depth)&lt;/code&gt;</source>
          <target state="translated">If &lt;code&gt;data_format&lt;/code&gt; is &lt;code&gt;&quot;channels_last&quot;&lt;/code&gt; : &lt;code&gt;(batch_size, first_axis_to_pad, second_axis_to_pad, third_axis_to_pad, depth)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e782b5886d40393da5db097215c23e91186e00a2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data_format&lt;/code&gt; is &lt;code&gt;&quot;channels_last&quot;&lt;/code&gt;: &lt;code&gt;(batch_size, first_cropped_axis, second_cropped_axis, third_cropped_axis, depth)&lt;/code&gt;</source>
          <target state="translated">If &lt;code&gt;data_format&lt;/code&gt; is &lt;code&gt;&quot;channels_last&quot;&lt;/code&gt; : &lt;code&gt;(batch_size, first_cropped_axis, second_cropped_axis, third_cropped_axis, depth)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="57c839aceb75dea0ea713f5bef648104cce09784" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data_format&lt;/code&gt; is &lt;code&gt;&quot;channels_last&quot;&lt;/code&gt;: &lt;code&gt;(batch_size, first_padded_axis, second_padded_axis, third_axis_to_pad, depth)&lt;/code&gt;</source>
          <target state="translated">If &lt;code&gt;data_format&lt;/code&gt; is &lt;code&gt;&quot;channels_last&quot;&lt;/code&gt; : &lt;code&gt;(batch_size, first_padded_axis, second_padded_axis, third_axis_to_pad, depth)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9ab9148a972ebadf0dd3075746714500bc8921a8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data_format&lt;/code&gt; is &lt;code&gt;&quot;channels_last&quot;&lt;/code&gt;: &lt;code&gt;(batch_size, padded_rows, padded_cols, channels)&lt;/code&gt;</source>
          <target state="translated">If &lt;code&gt;data_format&lt;/code&gt; is &lt;code&gt;&quot;channels_last&quot;&lt;/code&gt; : &lt;code&gt;(batch_size, padded_rows, padded_cols, channels)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f3c562a565912652dff405b1a14798558f017dfa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data_format&lt;/code&gt; is &lt;code&gt;&quot;channels_last&quot;&lt;/code&gt;: &lt;code&gt;(batch_size, rows, cols, channels)&lt;/code&gt;</source>
          <target state="translated">If &lt;code&gt;data_format&lt;/code&gt; is &lt;code&gt;&quot;channels_last&quot;&lt;/code&gt; : &lt;code&gt;(batch_size, rows, cols, channels)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3142a421b73450500d561ccc2d06f8b08d04e6ff" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data_format&lt;/code&gt; is &lt;code&gt;&quot;channels_last&quot;&lt;/code&gt;: &lt;code&gt;(batch_size, upsampled_dim1, upsampled_dim2, upsampled_dim3, channels)&lt;/code&gt;</source>
          <target state="translated">If &lt;code&gt;data_format&lt;/code&gt; is &lt;code&gt;&quot;channels_last&quot;&lt;/code&gt; : &lt;code&gt;(batch_size, upsampled_dim1, upsampled_dim2, upsampled_dim3, channels)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4d2ec1d843f4f81a6b756eeb5380e9936c6e1e45" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data_format&lt;/code&gt; is &lt;code&gt;&quot;channels_last&quot;&lt;/code&gt;: &lt;code&gt;(batch_size, upsampled_rows, upsampled_cols, channels)&lt;/code&gt;</source>
          <target state="translated">If &lt;code&gt;data_format&lt;/code&gt; is &lt;code&gt;&quot;channels_last&quot;&lt;/code&gt; : &lt;code&gt;(batch_size, upsampled_rows, upsampled_cols, channels)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3403ab76bb64e92cbc1ce947dc55b8c2f4c83858" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data_format='channels_first'&lt;/code&gt;: 3D tensor with shape &lt;code&gt;(batch_size, features, downsampled_steps)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;data_format='channels_first'&lt;/code&gt; の場合：形状 &lt;code&gt;(batch_size, features, downsampled_steps)&lt;/code&gt; downsampled_steps）の 3Dテンソル。</target>
        </trans-unit>
        <trans-unit id="76789aedd1e1b30e65c811b2313b49f5abac81bd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data_format='channels_first'&lt;/code&gt;: 3D tensor with shape &lt;code&gt;(batch_size, features, steps)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;data_format='channels_first'&lt;/code&gt; の場合：形状 &lt;code&gt;(batch_size, features, steps)&lt;/code&gt; 持つ3Dテンソル。</target>
        </trans-unit>
        <trans-unit id="d2c87816275e01f135bb9300e7a0edc16061dbaa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data_format='channels_first'&lt;/code&gt;: 3D tensor with shape: &lt;code&gt;(batch_size, features, steps)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;data_format='channels_first'&lt;/code&gt; の場合：形状の3Dテンソル： &lt;code&gt;(batch_size, features, steps)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d125d22c952d5e837dfbc3985718e658b08de7f8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data_format='channels_first'&lt;/code&gt;: 4D tensor with shape &lt;code&gt;(batch_size, channels, pooled_rows, pooled_cols)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;data_format='channels_first'&lt;/code&gt; の場合：形状 &lt;code&gt;(batch_size, channels, pooled_rows, pooled_cols)&lt;/code&gt; 4Dテンソル。</target>
        </trans-unit>
        <trans-unit id="efeffd222f25920652324c590da7090efc77a88f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data_format='channels_first'&lt;/code&gt;: 4D tensor with shape &lt;code&gt;(batch_size, channels, rows, cols)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;data_format='channels_first'&lt;/code&gt; の場合：形状 &lt;code&gt;(batch_size, channels, rows, cols)&lt;/code&gt; 持つ4Dテンソル。</target>
        </trans-unit>
        <trans-unit id="769dedd8ac289e52c4aa08f01592146935aca265" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data_format='channels_first'&lt;/code&gt;: 5D tensor with shape: &lt;code&gt;(batch_size, channels, pooled_dim1, pooled_dim2, pooled_dim3)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;data_format='channels_first'&lt;/code&gt; の場合：形状の5Dテンソル： &lt;code&gt;(batch_size, channels, pooled_dim1, pooled_dim2, pooled_dim3)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="64af7dda1bd74417607c23dcca4549eb64eaf842" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data_format='channels_first'&lt;/code&gt;: 5D tensor with shape: &lt;code&gt;(batch_size, channels, spatial_dim1, spatial_dim2, spatial_dim3)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;data_format='channels_first'&lt;/code&gt; の場合：形状の5Dテンソル： &lt;code&gt;(batch_size, channels, spatial_dim1, spatial_dim2, spatial_dim3)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7f181cb0cca921d90a9528a5b16866d3bc2e4a31" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data_format='channels_last'&lt;/code&gt;: 3D tensor with shape &lt;code&gt;(batch_size, downsampled_steps, features)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;data_format='channels_last'&lt;/code&gt; の場合：形状 &lt;code&gt;(batch_size, downsampled_steps, features)&lt;/code&gt; downsampled_steps 、features）の 3Dテンソル。</target>
        </trans-unit>
        <trans-unit id="8e79cfe731a2022565e9ce98c413ff3d4fea639e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data_format='channels_last'&lt;/code&gt;: 3D tensor with shape &lt;code&gt;(batch_size, steps, features)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;data_format='channels_last'&lt;/code&gt; の場合：形状 &lt;code&gt;(batch_size, steps, features)&lt;/code&gt; 持つ3Dテンソル。</target>
        </trans-unit>
        <trans-unit id="2c23ac2b777982bd7858d1585dca6d0af455ce47" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data_format='channels_last'&lt;/code&gt;: 3D tensor with shape: &lt;code&gt;(batch_size, steps, features)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;data_format='channels_last'&lt;/code&gt; の場合：形状の3Dテンソル： &lt;code&gt;(batch_size, steps, features)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5b5eae7be09c8d4e03880f99d1ad2a8a783e7aad" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data_format='channels_last'&lt;/code&gt;: 4D tensor with shape &lt;code&gt;(batch_size, pooled_rows, pooled_cols, channels)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;data_format='channels_last'&lt;/code&gt; の場合：形状 &lt;code&gt;(batch_size, pooled_rows, pooled_cols, channels)&lt;/code&gt; 持つ4Dテンソル。</target>
        </trans-unit>
        <trans-unit id="ddca25a45ba996ea23fba4bf6ca17bee3cfae493" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data_format='channels_last'&lt;/code&gt;: 4D tensor with shape &lt;code&gt;(batch_size, rows, cols, channels)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;data_format='channels_last'&lt;/code&gt; の場合：形状 &lt;code&gt;(batch_size, rows, cols, channels)&lt;/code&gt; 持つ4Dテンソル。</target>
        </trans-unit>
        <trans-unit id="d8233b6c3273cec342b518aa2c3dfc2e35e020b9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data_format='channels_last'&lt;/code&gt;: 5D tensor with shape: &lt;code&gt;(batch_size, pooled_dim1, pooled_dim2, pooled_dim3, channels)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;data_format='channels_last'&lt;/code&gt; の場合：形状の5Dテンソル： &lt;code&gt;(batch_size, pooled_dim1, pooled_dim2, pooled_dim3, channels)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2ec7e00c511e46673a4884a5b2f092291c4ad275" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data_format='channels_last'&lt;/code&gt;: 5D tensor with shape: &lt;code&gt;(batch_size, spatial_dim1, spatial_dim2, spatial_dim3, channels)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;data_format='channels_last'&lt;/code&gt; の場合：形状の5Dテンソル： &lt;code&gt;(batch_size, spatial_dim1, spatial_dim2, spatial_dim3, channels)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="101fdcb700763ac96747e4c473dfe1a8f6429022" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;dataset&lt;/code&gt; and this iterator do not have a compatible element structure.</source>
          <target state="translated">If &lt;code&gt;dataset&lt;/code&gt; and this iterator do not have a compatible element structure.</target>
        </trans-unit>
        <trans-unit id="e7d4d79f82a80c0c717b01758950d031ed5cbffb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;diag.dtype&lt;/code&gt; is not an allowed type.</source>
          <target state="translated">If &lt;code&gt;diag.dtype&lt;/code&gt; is not an allowed type.</target>
        </trans-unit>
        <trans-unit id="1a7fe4529e029d06f999f9bc38cc0d6023bbb309" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;diag.dtype&lt;/code&gt; is real, and &lt;code&gt;is_self_adjoint&lt;/code&gt; is not &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">If &lt;code&gt;diag.dtype&lt;/code&gt; is real, and &lt;code&gt;is_self_adjoint&lt;/code&gt; is not &lt;code&gt;True&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6bee3f10643b4f478b79d3f193343de525becd64" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;diagonals_format=compact&lt;/code&gt; this is a &lt;code&gt;[B1, ... Bb, 3, N]&lt;/code&gt; shaped &lt;code&gt;Tensor&lt;/code&gt; with the second to last dimension indexing the superdiagonal, diagonal and subdiagonal in that order. Note the superdiagonal is padded with an element in the last position, and the subdiagonal is padded with an element in the front.</source>
          <target state="translated">If &lt;code&gt;diagonals_format=compact&lt;/code&gt; this is a &lt;code&gt;[B1, ... Bb, 3, N]&lt;/code&gt; shaped &lt;code&gt;Tensor&lt;/code&gt; with the second to last dimension indexing the superdiagonal, diagonal and subdiagonal in that order. Note the superdiagonal is padded with an element in the last position, and the subdiagonal is padded with an element in the front.</target>
        </trans-unit>
        <trans-unit id="1bc29f8a23b899bdf0c1cb2f7f06e1af47287a14" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;diagonals_format=matrix&lt;/code&gt; this is a &lt;code&gt;[B1, ... Bb, N, N]&lt;/code&gt; shaped &lt;code&gt;Tensor&lt;/code&gt; representing the full tridiagonal matrix.</source>
          <target state="translated">If &lt;code&gt;diagonals_format=matrix&lt;/code&gt; this is a &lt;code&gt;[B1, ... Bb, N, N]&lt;/code&gt; shaped &lt;code&gt;Tensor&lt;/code&gt; representing the full tridiagonal matrix.</target>
        </trans-unit>
        <trans-unit id="e57a70a4b86996a9a5cf18c0625615bd122c34f5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;diagonals_format=sequence&lt;/code&gt;, this is a list of three &lt;code&gt;Tensor&lt;/code&gt;'s each with shape &lt;code&gt;[B1, ..., Bb, N]&lt;/code&gt;, &lt;code&gt;b &amp;gt;= 0, N &amp;gt;= 0&lt;/code&gt;, representing the superdiagonal, diagonal and subdiagonal in that order. Note the superdiagonal is padded with an element in the last position, and the subdiagonal is padded with an element in the front.</source>
          <target state="translated">If &lt;code&gt;diagonals_format=sequence&lt;/code&gt; , this is a list of three &lt;code&gt;Tensor&lt;/code&gt; 's each with shape &lt;code&gt;[B1, ..., Bb, N]&lt;/code&gt; , &lt;code&gt;b &amp;gt;= 0, N &amp;gt;= 0&lt;/code&gt; , representing the superdiagonal, diagonal and subdiagonal in that order. Note the superdiagonal is padded with an element in the last position, and the subdiagonal is padded with an element in the front.</target>
        </trans-unit>
        <trans-unit id="ed36e5e93ecd4beb399f887553834287fd94ebb3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;dtype&lt;/code&gt; does not match the element type of &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">If &lt;code&gt;dtype&lt;/code&gt; does not match the element type of &lt;code&gt;value&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e0815ded52c109dcfe592d606c078182d529cbf8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;dtype&lt;/code&gt; is integral and &lt;code&gt;maxval&lt;/code&gt; is not specified.</source>
          <target state="translated">If &lt;code&gt;dtype&lt;/code&gt; is integral and &lt;code&gt;maxval&lt;/code&gt; is not specified.</target>
        </trans-unit>
        <trans-unit id="1d91f8393ce0797c49bb3ce9117ea4ab3700a304" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;dtype&lt;/code&gt; is integral and only one of &lt;code&gt;minval&lt;/code&gt; or &lt;code&gt;maxval&lt;/code&gt; is specified.</source>
          <target state="translated">If &lt;code&gt;dtype&lt;/code&gt; is integral and only one of &lt;code&gt;minval&lt;/code&gt; or &lt;code&gt;maxval&lt;/code&gt; is specified.</target>
        </trans-unit>
        <trans-unit id="715d150b5f97b6abec4188a71fc697199a108a0c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;dtype&lt;/code&gt; is not a floating point type.</source>
          <target state="translated">If &lt;code&gt;dtype&lt;/code&gt; is not a floating point type.</target>
        </trans-unit>
        <trans-unit id="ad1d1c40df2fea11227db382ded54071f270ecec" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;dtype&lt;/code&gt; is not provided, it will attempt to assume the data type of &lt;code&gt;on_value&lt;/code&gt; or &lt;code&gt;off_value&lt;/code&gt;, if one or both are passed in. If none of &lt;code&gt;on_value&lt;/code&gt;, &lt;code&gt;off_value&lt;/code&gt;, or &lt;code&gt;dtype&lt;/code&gt; are provided, &lt;code&gt;dtype&lt;/code&gt; will default to the value &lt;a href=&quot;../tf#float32&quot;&gt;&lt;code&gt;tf.float32&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">場合 &lt;code&gt;dtype&lt;/code&gt; 提供されていない、それはのデータ型と仮定しようとします &lt;code&gt;on_value&lt;/code&gt; や &lt;code&gt;off_value&lt;/code&gt; をのどれ場合一方または両方が渡されている場合は、。 &lt;code&gt;on_value&lt;/code&gt; 、 &lt;code&gt;off_value&lt;/code&gt; 、または &lt;code&gt;dtype&lt;/code&gt; 提供されていない、 &lt;code&gt;dtype&lt;/code&gt; 値がデフォルトになります&lt;a href=&quot;../tf#float32&quot;&gt; &lt;code&gt;tf.float32&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="25b80e47772b0bfc696fbf3b5bb5ff69641199ce" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;dtype&lt;/code&gt; is real, and &lt;code&gt;is_self_adjoint&lt;/code&gt; and &lt;code&gt;is_positive_definite&lt;/code&gt;, a Cholesky factorization is used for the determinant and solve.</source>
          <target state="translated">場合 &lt;code&gt;dtype&lt;/code&gt; 本当の、そしてある &lt;code&gt;is_self_adjoint&lt;/code&gt; と &lt;code&gt;is_positive_definite&lt;/code&gt; 、コレスキー分解を決定するために使用して解決されます。</target>
        </trans-unit>
        <trans-unit id="87728c1899322de33a9ed090ef422757a31d60b9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;dtype&lt;/code&gt; is specified the resulting tensor values are cast to the requested &lt;code&gt;dtype&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;dtype&lt;/code&gt; が指定されている場合、結果のテンソル値は、要求された &lt;code&gt;dtype&lt;/code&gt; にキャストされます。</target>
        </trans-unit>
        <trans-unit id="c6bf0dabc06d37338f301de3b7a000a236395058" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;dynamic_pad&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, it is sufficient that the &lt;em&gt;rank&lt;/em&gt; of the tensors is known, but individual dimensions may have shape &lt;code&gt;None&lt;/code&gt;. In this case, for each enqueue the dimensions with value &lt;code&gt;None&lt;/code&gt; may have a variable length; upon dequeue, the output tensors will be padded on the right to the maximum shape of the tensors in the current minibatch. For numbers, this padding takes value 0. For strings, this padding is the empty string. See &lt;code&gt;PaddingFIFOQueue&lt;/code&gt; for more info.</source>
          <target state="translated">&lt;code&gt;dynamic_pad&lt;/code&gt; が &lt;code&gt;True&lt;/code&gt; の場合、テンソルの&lt;em&gt;ランク&lt;/em&gt;がわかっていれば十分ですが、個々の次元の形状は &lt;code&gt;None&lt;/code&gt; になる場合があります。この場合、エンキューごとに、値が「 &lt;code&gt;None&lt;/code&gt; のディメンションは可変長になる場合があります。デキューすると、出力テンソルの右側に現在のミニバッチのテンソルの最大形状が埋め込まれます。数値の場合、このパディングは値0をとります。文字列の場合、このパディングは空の文字列です。詳細については、 &lt;code&gt;PaddingFIFOQueue&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="c7154051f64e09243a5e2742d4bb8fb6d037dddc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;dynamic_pad&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, it is sufficient that the &lt;em&gt;rank&lt;/em&gt; of the tensors is known, but individual dimensions may have value &lt;code&gt;None&lt;/code&gt;. In this case, for each enqueue the dimensions with value &lt;code&gt;None&lt;/code&gt; may have a variable length; upon dequeue, the output tensors will be padded on the right to the maximum shape of the tensors in the current minibatch. For numbers, this padding takes value 0. For strings, this padding is the empty string. See &lt;code&gt;PaddingFIFOQueue&lt;/code&gt; for more info.</source>
          <target state="translated">&lt;code&gt;dynamic_pad&lt;/code&gt; が &lt;code&gt;True&lt;/code&gt; の場合、テンソルの&lt;em&gt;ランク&lt;/em&gt;がわかっていれば十分ですが、個々の次元の値は &lt;code&gt;None&lt;/code&gt; になる場合があります。この場合、エンキューごとに、値が「 &lt;code&gt;None&lt;/code&gt; のディメンションは可変長になる場合があります。デキューすると、出力テンソルの右側に現在のミニバッチのテンソルの最大形状が埋め込まれます。数値の場合、このパディングは値0をとります。文字列の場合、このパディングは空の文字列です。詳細については、 &lt;code&gt;PaddingFIFOQueue&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="d5c4eeb6f8493afa30012ab8c1fe8880c30e46d2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;elems&lt;/code&gt; has multiple ragged dimensions, then the values passed to &lt;code&gt;fn&lt;/code&gt; will be &lt;a href=&quot;../../raggedtensor&quot;&gt;&lt;code&gt;tf.RaggedTensor&lt;/code&gt;&lt;/a&gt;s with one fewer ragged dimension.</source>
          <target state="translated">If &lt;code&gt;elems&lt;/code&gt; has multiple ragged dimensions, then the values passed to &lt;code&gt;fn&lt;/code&gt; will be &lt;a href=&quot;../../raggedtensor&quot;&gt; &lt;code&gt;tf.RaggedTensor&lt;/code&gt; &lt;/a&gt;s with one fewer ragged dimension.</target>
        </trans-unit>
        <trans-unit id="890f3a4151caeb03adb2ed5bca108c0ccc050d09" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;elems&lt;/code&gt; has multiple ragged dimensions, then the values passed to &lt;code&gt;fn&lt;/code&gt; will be &lt;a href=&quot;raggedtensor&quot;&gt;&lt;code&gt;tf.RaggedTensor&lt;/code&gt;&lt;/a&gt;s with one fewer ragged dimension.</source>
          <target state="translated">If &lt;code&gt;elems&lt;/code&gt; has multiple ragged dimensions, then the values passed to &lt;code&gt;fn&lt;/code&gt; will be &lt;a href=&quot;raggedtensor&quot;&gt; &lt;code&gt;tf.RaggedTensor&lt;/code&gt; &lt;/a&gt;s with one fewer ragged dimension.</target>
        </trans-unit>
        <trans-unit id="a5ff4987e87872a49d04921c77285bda0adf062e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;elems&lt;/code&gt; has only one ragged dimension, then the values passed to &lt;code&gt;fn&lt;/code&gt; will be &lt;a href=&quot;../../tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt;s.</source>
          <target state="translated">If &lt;code&gt;elems&lt;/code&gt; has only one ragged dimension, then the values passed to &lt;code&gt;fn&lt;/code&gt; will be &lt;a href=&quot;../../tensor&quot;&gt; &lt;code&gt;tf.Tensor&lt;/code&gt; &lt;/a&gt;s.</target>
        </trans-unit>
        <trans-unit id="b73b5f746aec87b8f4c8e0427c04e89620bf4afc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;elems&lt;/code&gt; has only one ragged dimension, then the values passed to &lt;code&gt;fn&lt;/code&gt; will be &lt;a href=&quot;tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt;s.</source>
          <target state="translated">If &lt;code&gt;elems&lt;/code&gt; has only one ragged dimension, then the values passed to &lt;code&gt;fn&lt;/code&gt; will be &lt;a href=&quot;tensor&quot;&gt; &lt;code&gt;tf.Tensor&lt;/code&gt; &lt;/a&gt;s.</target>
        </trans-unit>
        <trans-unit id="83d267c0ab9c489452139a661e9ce438bd73ea6e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;elems&lt;/code&gt; is a &lt;code&gt;RaggedTensor&lt;/code&gt;, then &lt;code&gt;fn&lt;/code&gt; will be called with each row of that ragged tensor.</source>
          <target state="translated">If &lt;code&gt;elems&lt;/code&gt; is a &lt;code&gt;RaggedTensor&lt;/code&gt; , then &lt;code&gt;fn&lt;/code&gt; will be called with each row of that ragged tensor.</target>
        </trans-unit>
        <trans-unit id="594a6d229c5aac392ec75df05f295fde289f7215" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;elems&lt;/code&gt; is a &lt;code&gt;SparseTensor&lt;/code&gt;, then &lt;code&gt;fn&lt;/code&gt; will be called with each row of that sparse tensor. In particular, the value passed to &lt;code&gt;fn&lt;/code&gt; will be a &lt;a href=&quot;../../sparse/sparsetensor&quot;&gt;&lt;code&gt;tf.sparse.SparseTensor&lt;/code&gt;&lt;/a&gt; with one fewer dimension than &lt;code&gt;elems&lt;/code&gt;.</source>
          <target state="translated">If &lt;code&gt;elems&lt;/code&gt; is a &lt;code&gt;SparseTensor&lt;/code&gt; , then &lt;code&gt;fn&lt;/code&gt; will be called with each row of that sparse tensor. In particular, the value passed to &lt;code&gt;fn&lt;/code&gt; will be a &lt;a href=&quot;../../sparse/sparsetensor&quot;&gt; &lt;code&gt;tf.sparse.SparseTensor&lt;/code&gt; &lt;/a&gt; with one fewer dimension than &lt;code&gt;elems&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="996bb4b616839cd6682611215f67fa1c27e26efa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;elems&lt;/code&gt; is a &lt;code&gt;SparseTensor&lt;/code&gt;, then &lt;code&gt;fn&lt;/code&gt; will be called with each row of that sparse tensor. In particular, the value passed to &lt;code&gt;fn&lt;/code&gt; will be a &lt;a href=&quot;sparse/sparsetensor&quot;&gt;&lt;code&gt;tf.sparse.SparseTensor&lt;/code&gt;&lt;/a&gt; with one fewer dimension than &lt;code&gt;elems&lt;/code&gt;.</source>
          <target state="translated">If &lt;code&gt;elems&lt;/code&gt; is a &lt;code&gt;SparseTensor&lt;/code&gt; , then &lt;code&gt;fn&lt;/code&gt; will be called with each row of that sparse tensor. In particular, the value passed to &lt;code&gt;fn&lt;/code&gt; will be a &lt;a href=&quot;sparse/sparsetensor&quot;&gt; &lt;code&gt;tf.sparse.SparseTensor&lt;/code&gt; &lt;/a&gt; with one fewer dimension than &lt;code&gt;elems&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ef0d11ec70ebe7a5d7ac929ed8701c9ed4c87af9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;elems&lt;/code&gt; is a single tensor and &lt;code&gt;fn&lt;/code&gt;'s signature is &lt;code&gt;tf.Tensor-&amp;gt;tf.Tensor&lt;/code&gt;, then &lt;code&gt;map_fn(fn, elems)&lt;/code&gt; is equivalent to &lt;code&gt;tf.stack([fn(elem) for elem in tf.unstack(elems)])&lt;/code&gt;. E.g.:</source>
          <target state="translated">If &lt;code&gt;elems&lt;/code&gt; is a single tensor and &lt;code&gt;fn&lt;/code&gt; 's signature is &lt;code&gt;tf.Tensor-&amp;gt;tf.Tensor&lt;/code&gt; , then &lt;code&gt;map_fn(fn, elems)&lt;/code&gt; is equivalent to &lt;code&gt;tf.stack([fn(elem) for elem in tf.unstack(elems)])&lt;/code&gt; . E.g.:</target>
        </trans-unit>
        <trans-unit id="d0c84dfd4aca9809b33d0c963419094e255ce668" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;elems&lt;/code&gt; is a tuple (or nested structure) of tensors, then those tensors must all have the same outer-dimension size (&lt;code&gt;num_elems&lt;/code&gt;); and &lt;code&gt;fn&lt;/code&gt; is used to transform each tuple (or structure) of corresponding slices from &lt;code&gt;elems&lt;/code&gt;. E.g., if &lt;code&gt;elems&lt;/code&gt; is a tuple &lt;code&gt;(t1, t2, t3)&lt;/code&gt;, then &lt;code&gt;fn&lt;/code&gt; is used to transform each tuple of slices &lt;code&gt;(t1[i], t2[i], t3[i])&lt;/code&gt; (where &lt;code&gt;0 &amp;lt;= i &amp;lt; num_elems&lt;/code&gt;).</source>
          <target state="translated">If &lt;code&gt;elems&lt;/code&gt; is a tuple (or nested structure) of tensors, then those tensors must all have the same outer-dimension size ( &lt;code&gt;num_elems&lt;/code&gt; ); and &lt;code&gt;fn&lt;/code&gt; is used to transform each tuple (or structure) of corresponding slices from &lt;code&gt;elems&lt;/code&gt; . E.g., if &lt;code&gt;elems&lt;/code&gt; is a tuple &lt;code&gt;(t1, t2, t3)&lt;/code&gt; , then &lt;code&gt;fn&lt;/code&gt; is used to transform each tuple of slices &lt;code&gt;(t1[i], t2[i], t3[i])&lt;/code&gt; (where &lt;code&gt;0 &amp;lt;= i &amp;lt; num_elems&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="5c4b65a0810a67f6df4062a29da66142c0346f29" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;enqueue_many&lt;/code&gt; is &lt;code&gt;False&lt;/code&gt;, &lt;code&gt;tensors&lt;/code&gt; is assumed to represent a single example. An input tensor with shape &lt;code&gt;[x, y, z]&lt;/code&gt; will be output as a tensor with shape &lt;code&gt;[batch_size, x, y, z]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;enqueue_many&lt;/code&gt; が &lt;code&gt;False&lt;/code&gt; の場合、 &lt;code&gt;tensors&lt;/code&gt; は単一の例を表すと見なされます。形状 &lt;code&gt;[x, y, z]&lt;/code&gt; の入力テンソルは、形状 &lt;code&gt;[batch_size, x, y, z]&lt;/code&gt; テンソルとして出力されます。</target>
        </trans-unit>
        <trans-unit id="2f53d0408f26222dd6e2cb6b512d5cf383ecb0db" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;enqueue_many&lt;/code&gt; is &lt;code&gt;False&lt;/code&gt;, each &lt;code&gt;tensors_list[i]&lt;/code&gt; is assumed to represent a single example. An input tensor &lt;code&gt;x&lt;/code&gt; will be output as a tensor with shape &lt;code&gt;[batch_size] + x.shape&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;enqueue_many&lt;/code&gt; が &lt;code&gt;False&lt;/code&gt; の場合、各 &lt;code&gt;tensors_list[i]&lt;/code&gt; は単一の例を表すと想定されます。入力テンソル &lt;code&gt;x&lt;/code&gt; は、形状 &lt;code&gt;[batch_size] + x.shape&lt;/code&gt; テンソルとして出力されます。</target>
        </trans-unit>
        <trans-unit id="2c84e3f51d2a96b8ae5c34258f3f8f20e2f9061c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;enqueue_many&lt;/code&gt; is &lt;code&gt;False&lt;/code&gt;, each &lt;code&gt;tensors_list[i]&lt;/code&gt; is assumed to represent a single example. An input tensor with shape &lt;code&gt;[x, y, z]&lt;/code&gt; will be output as a tensor with shape &lt;code&gt;[batch_size, x, y, z]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;enqueue_many&lt;/code&gt; が &lt;code&gt;False&lt;/code&gt; の場合、各 &lt;code&gt;tensors_list[i]&lt;/code&gt; は単一の例を表すと想定されます。形状 &lt;code&gt;[x, y, z]&lt;/code&gt; の入力テンソルは、形状 &lt;code&gt;[batch_size, x, y, z]&lt;/code&gt; テンソルとして出力されます。</target>
        </trans-unit>
        <trans-unit id="341111f29e74aa8ef96f30f69cc9494a535fcfdc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;enqueue_many&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, &lt;code&gt;tensors&lt;/code&gt; is assumed to represent a batch of examples, where the first dimension is indexed by example, and all members of &lt;code&gt;tensors&lt;/code&gt; should have the same size in the first dimension. If an input tensor has shape &lt;code&gt;[*, x, y, z]&lt;/code&gt;, the output will have shape &lt;code&gt;[batch_size, x, y, z]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;enqueue_many&lt;/code&gt; が &lt;code&gt;True&lt;/code&gt; の場合、 &lt;code&gt;tensors&lt;/code&gt; は例のバッチを表すと想定され、最初の次元は例によってインデックスが付けられ、 &lt;code&gt;tensors&lt;/code&gt; すべてのメンバーは最初の次元で同じサイズでなければなりません。入力テンソルの形状が &lt;code&gt;[*, x, y, z]&lt;/code&gt; 場合、出力の形状は &lt;code&gt;[batch_size, x, y, z]&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="cdc2ab5b45f000da1295bb1b0a336e2b463d4530" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;enqueue_many&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, &lt;code&gt;tensors&lt;/code&gt; is assumed to represent a batch of examples, where the first dimension is indexed by example, and all members of &lt;code&gt;tensors&lt;/code&gt; should have the same size in the first dimension. If an input tensor has shape &lt;code&gt;[*, x, y, z]&lt;/code&gt;, the output will have shape &lt;code&gt;[batch_size, x, y, z]&lt;/code&gt;. The &lt;code&gt;capacity&lt;/code&gt; argument controls the how long the prefetching is allowed to grow the queues.</source>
          <target state="translated">&lt;code&gt;enqueue_many&lt;/code&gt; が &lt;code&gt;True&lt;/code&gt; の場合、 &lt;code&gt;tensors&lt;/code&gt; は例のバッチを表すと想定され、最初の次元は例によってインデックスが付けられ、 &lt;code&gt;tensors&lt;/code&gt; すべてのメンバーは最初の次元で同じサイズでなければなりません。入力テンソルの形状が &lt;code&gt;[*, x, y, z]&lt;/code&gt; 場合、出力の形状は &lt;code&gt;[batch_size, x, y, z]&lt;/code&gt; ます。 &lt;code&gt;capacity&lt;/code&gt; 引数は、プリフェッチがキューを成長させる期間を制御します。</target>
        </trans-unit>
        <trans-unit id="26d498f25d2a64c1fed1145d08fdecc587420e5c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;enqueue_many&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, &lt;code&gt;tensors_list[i]&lt;/code&gt; is assumed to represent a batch of examples, where the first dimension is indexed by example, and all members of &lt;code&gt;tensors_list[i]&lt;/code&gt; should have the same size in the first dimension. If an input tensor has shape &lt;code&gt;[*, x, y, z]&lt;/code&gt;, the output will have shape &lt;code&gt;[batch_size, x, y, z]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;enqueue_many&lt;/code&gt; が &lt;code&gt;True&lt;/code&gt; の場合、 &lt;code&gt;tensors_list[i]&lt;/code&gt; は例のバッチを表すと想定されます。最初の次元は例によってインデックスが付けられ、 &lt;code&gt;tensors_list[i]&lt;/code&gt; すべてのメンバーは最初の次元で同じサイズでなければなりません。入力テンソルの形状が &lt;code&gt;[*, x, y, z]&lt;/code&gt; 場合、出力の形状は &lt;code&gt;[batch_size, x, y, z]&lt;/code&gt; ます。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
