<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="tensorflow">
    <body>
      <group id="tensorflow">
        <trans-unit id="af423eb943d44142b4ba2df380bb45f9370ab357" translate="yes" xml:space="preserve">
          <source>This is useful to eliminate per-test boilerplate when context managers are used. For example, instead of decorating every test with &lt;code&gt;@mock.patch&lt;/code&gt;, simply do &lt;code&gt;self.foo = self.enter_context(mock.patch(...))' in&lt;/code&gt;setUp()`.</source>
          <target state="translated">これは、コンテキストマネージャーが使用されている場合に、テストごとのボイラープレートを削除するのに役立ちます。たとえば、 &lt;code&gt;@mock.patch&lt;/code&gt; ですべてのテストを装飾する代わりに &lt;code&gt;self.foo = self.enter_context(mock.patch(...))' in&lt;/code&gt; setUp（） `でself.foo = self.enter_context（mock.patch（...）） 'を実行するだけです。</target>
        </trans-unit>
        <trans-unit id="2f67d0f15d4bd847d95e4812f46c68a7b2ce669c" translate="yes" xml:space="preserve">
          <source>This is useful to mitigate overfitting (you could see it as a form of random data augmentation). Gaussian Noise (GS) is a natural choice as corruption process for real valued inputs.</source>
          <target state="translated">これは、オーバーフィッティングを緩和するのに便利です(ランダムデータの補強の一形態として見ることができます)。ガウスノイズ(GS)は、実値入力の破損処理として自然な選択です。</target>
        </trans-unit>
        <trans-unit id="0a10808c724fd5007563891cae49997723f67e26" translate="yes" xml:space="preserve">
          <source>This is useful when starting a dedicated dispatch process.</source>
          <target state="translated">専用の派遣処理を開始する際に便利です。</target>
        </trans-unit>
        <trans-unit id="16e0781bd49ec3a98f90bdf48daf84789ac4527c" translate="yes" xml:space="preserve">
          <source>This is useful when starting a dedicated worker process.</source>
          <target state="translated">作業員専用の作業を開始する際に便利です。</target>
        </trans-unit>
        <trans-unit id="d38a2f7346a2a0766d59c6174961d13ece4817fb" translate="yes" xml:space="preserve">
          <source>This is useful when validating the result of a broadcasting operation when the tensors do not have statically known shapes.</source>
          <target state="translated">これは、テンソルが静的に既知の形状を持たない場合に、放送操作の結果を検証する場合に便利です。</target>
        </trans-unit>
        <trans-unit id="50937613d6e3934b243fbeba16769c301a7b4618" translate="yes" xml:space="preserve">
          <source>This is useful when validating the result of a broadcasting operation when the tensors have statically known shapes.</source>
          <target state="translated">これは、テンソルが静的に既知の形状を持つ場合に、放送操作の結果を検証する場合に便利です。</target>
        </trans-unit>
        <trans-unit id="d56f48520fc92b32fe411b251279af631392c0d0" translate="yes" xml:space="preserve">
          <source>This is useful when you need to extract a subset of slices in an &lt;code&gt;IndexedSlices&lt;/code&gt; object.</source>
          <target state="translated">これは、 &lt;code&gt;IndexedSlices&lt;/code&gt; オブジェクトでスライスのサブセットを抽出する必要がある場合に役立ちます。</target>
        </trans-unit>
        <trans-unit id="7324163610c415fe69e9edf14d1514614e0096c2" translate="yes" xml:space="preserve">
          <source>This is where the layer's logic lives.</source>
          <target state="translated">ここにレイヤーの論理が生きている。</target>
        </trans-unit>
        <trans-unit id="51b266b637bd972731e9b8ded931808387760c03" translate="yes" xml:space="preserve">
          <source>This iterator-constructing method can be used to create an iterator that is reusable with many different datasets.</source>
          <target state="translated">このイテレータ構築メソッドを使用すると、多くの異なるデータセットで再利用可能なイテレータを作成することができます。</target>
        </trans-unit>
        <trans-unit id="e4b84ee23970a9ba1fae231b7f3281c7ddfd3c7d" translate="yes" xml:space="preserve">
          <source>This kernel op implements the following mathematical equations:</source>
          <target state="translated">このカーネルopは以下の数式を実装しています。</target>
        </trans-unit>
        <trans-unit id="6651501cdbb63552c7881c732a891c9b596e4cd4" translate="yes" xml:space="preserve">
          <source>This layer can add rows and columns of zeros at the top, bottom, left and right side of an image tensor.</source>
          <target state="translated">このレイヤは、画像テンソルの上下左右にゼロの行と列を追加することができます。</target>
        </trans-unit>
        <trans-unit id="c8f7de7a90e40a1acb832cfeb3e997b1fdd42909" translate="yes" xml:space="preserve">
          <source>This layer can be called multiple times with different features.</source>
          <target state="translated">このレイヤーは、異なる機能で複数回呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="b23ebdf3426b29c2bb4017b933209c527b0b2eaf" translate="yes" xml:space="preserve">
          <source>This layer can only be used as the first layer in a model.</source>
          <target state="translated">このレイヤーは、モデルの最初のレイヤーとしてのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="8d2bf436fb7b0b2292ba74c82ed9e0b6359c6446" translate="yes" xml:space="preserve">
          <source>This layer can perform einsum calculations of arbitrary dimensionality.</source>
          <target state="translated">このレイヤーは、任意の次元のアインサム計算を行うことができます。</target>
        </trans-unit>
        <trans-unit id="28df12740051102a73475796ca5f477471a88b56" translate="yes" xml:space="preserve">
          <source>This layer concatenates multiple categorical inputs into a single categorical output (similar to Cartesian product). The output dtype is string.</source>
          <target state="translated">このレイヤは、複数のカテゴリ入力を単一のカテゴリ出力に連結します(デカルト積に似ています)。出力dtypeは文字列です。</target>
        </trans-unit>
        <trans-unit id="fbd759fae81bda98338ee6eb24eac5b449a08594" translate="yes" xml:space="preserve">
          <source>This layer creates a convolution kernel that is convolved (actually cross-correlated) with the layer input to produce a tensor of outputs. If &lt;code&gt;use_bias&lt;/code&gt; is True (and a &lt;code&gt;bias_initializer&lt;/code&gt; is provided), a bias vector is created and added to the outputs. Finally, if &lt;code&gt;activation&lt;/code&gt; is not &lt;code&gt;None&lt;/code&gt;, it is applied to the outputs as well.</source>
          <target state="translated">この層は、層の入力と畳み込み（実際には相互相関）された畳み込みカーネルを作成して、出力のテンソルを生成します。 &lt;code&gt;use_bias&lt;/code&gt; がTrueである場合（そして、 &lt;code&gt;bias_initializer&lt;/code&gt; が提供されている場合）、バイアスベクトルが作成され、出力に追加されます。最後に、 &lt;code&gt;activation&lt;/code&gt; が &lt;code&gt;None&lt;/code&gt; でない場合、それは出力にも適用されます。</target>
        </trans-unit>
        <trans-unit id="a9977284bd794456f41f5d8f8d36aed1d3801d36" translate="yes" xml:space="preserve">
          <source>This layer creates a convolution kernel that is convolved with the layer input over a single spatial (or temporal) dimension to produce a tensor of outputs. If &lt;code&gt;use_bias&lt;/code&gt; is True, a bias vector is created and added to the outputs. Finally, if &lt;code&gt;activation&lt;/code&gt; is not &lt;code&gt;None&lt;/code&gt;, it is applied to the outputs as well.</source>
          <target state="translated">このレイヤーは、単一の空間（または時間）次元でレイヤー入力と畳み込み畳み込みカーネルを作成し、出力のテンソルを生成します。場合 &lt;code&gt;use_bias&lt;/code&gt; が Trueで、バイアスベクトルが作成され、出力に追加されます。最後に、 &lt;code&gt;activation&lt;/code&gt; が &lt;code&gt;None&lt;/code&gt; でない場合、それは出力にも適用されます。</target>
        </trans-unit>
        <trans-unit id="d01bf01ba17a42cbf8ad8412a4cd7bfe52f00c78" translate="yes" xml:space="preserve">
          <source>This layer creates a convolution kernel that is convolved with the layer input to produce a tensor of outputs. If &lt;code&gt;use_bias&lt;/code&gt; is True, a bias vector is created and added to the outputs. Finally, if &lt;code&gt;activation&lt;/code&gt; is not &lt;code&gt;None&lt;/code&gt;, it is applied to the outputs as well.</source>
          <target state="translated">この層は、層の入力と畳み込み畳み込みカーネルを作成して、出力のテンソルを生成します。場合 &lt;code&gt;use_bias&lt;/code&gt; が Trueで、バイアスベクトルが作成され、出力に追加されます。最後に、 &lt;code&gt;activation&lt;/code&gt; が &lt;code&gt;None&lt;/code&gt; でない場合、それは出力にも適用されます。</target>
        </trans-unit>
        <trans-unit id="884d29443e655c08f257cc412193f76628fd846b" translate="yes" xml:space="preserve">
          <source>This layer has basic options for managing text in a Keras model. It transforms a batch of strings (one sample = one string) into either a list of token indices (one sample = 1D tensor of integer token indices) or a dense representation (one sample = 1D tensor of float values representing data about the sample's tokens).</source>
          <target state="translated">このレイヤには、Kerasモデルでテキストを管理するための基本的なオプションがあります。これは,文字列のバッチ(1つのサンプル=1つの文字列)を,トークンインデックスのリスト(1つのサンプル=整数のトークンインデックスの1次元テンソル)または密な表現(1つのサンプル=サンプルのトークンに関するデータを表す浮動小数点値の1次元テンソル)のいずれかに変換します.</target>
        </trans-unit>
        <trans-unit id="0b7b099051eae116bfa4a2ca036f64c30b769c6d" translate="yes" xml:space="preserve">
          <source>This layer implements a mapping from input space to a space with &lt;code&gt;output_dim&lt;/code&gt; dimensions, which approximates shift-invariant kernels. A kernel function &lt;code&gt;K(x, y)&lt;/code&gt; is shift-invariant if &lt;code&gt;K(x, y) == k(x - y)&lt;/code&gt; for some function &lt;code&gt;k&lt;/code&gt;. Many popular Radial Basis Functions (RBF), including Gaussian and Laplacian kernels, are shift-invariant.</source>
          <target state="translated">このレイヤーは、入力スペースから &lt;code&gt;output_dim&lt;/code&gt; 次元のスペースへのマッピングを実装します。これは、シフト不変カーネルを近似します。カーネル関数 &lt;code&gt;K(x, y)&lt;/code&gt; は、ある関数 &lt;code&gt;k&lt;/code&gt; に対して &lt;code&gt;K(x, y) == k(x - y)&lt;/code&gt; 場合、シフト不変です。ガウスカーネルとラプラシアンカーネルを含む多くの一般的な動径基底関数（RBF）は、シフト不変です。</target>
        </trans-unit>
        <trans-unit id="bca79ddc4abf3d361de2fa2d5bdf3c1e02faac7e" translate="yes" xml:space="preserve">
          <source>This layer implements the operation: &lt;code&gt;outputs = activation(inputs * kernel + bias)&lt;/code&gt; Where &lt;code&gt;activation&lt;/code&gt; is the activation function passed as the &lt;code&gt;activation&lt;/code&gt; argument (if not &lt;code&gt;None&lt;/code&gt;), &lt;code&gt;kernel&lt;/code&gt; is a weights matrix created by the layer, and &lt;code&gt;bias&lt;/code&gt; is a bias vector created by the layer (only if &lt;code&gt;use_bias&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;).</source>
          <target state="translated">このレイヤーは操作を実装します： &lt;code&gt;outputs = activation(inputs * kernel + bias)&lt;/code&gt; ここで、アク &lt;code&gt;activation&lt;/code&gt; は &lt;code&gt;activation&lt;/code&gt; 引数として渡されるアクティベーション関数（ &lt;code&gt;None&lt;/code&gt; でない場合）、 &lt;code&gt;kernel&lt;/code&gt; はレイヤーによって作成される重み行列、 &lt;code&gt;bias&lt;/code&gt; は作成されるバイアスベクトルですレイヤー（ &lt;code&gt;use_bias&lt;/code&gt; が &lt;code&gt;True&lt;/code&gt; の場合のみ）。</target>
        </trans-unit>
        <trans-unit id="35e71e883bb0be18fa94fd4d0a457376805923f0" translate="yes" xml:space="preserve">
          <source>This layer performs a depthwise convolution that acts separately on channels, followed by a pointwise convolution that mixes channels. If &lt;code&gt;use_bias&lt;/code&gt; is True and a bias initializer is provided, it adds a bias vector to the output. It then optionally applies an activation function to produce the final output.</source>
          <target state="translated">このレイヤーは、チャネルに個別に作用する深さ方向のたたみ込みを実行し、続いてチャネルを混合する点ごとのたたみ込みを実行します。場合 &lt;code&gt;use_bias&lt;/code&gt; が Trueで、バイアス初期化子が提供され、それが出力するバイアスベクトルを追加します。次に、オプションでアクティベーション関数を適用して、最終出力を生成します。</target>
        </trans-unit>
        <trans-unit id="886b50c9aa90bb61796488bc8efaa41bf9f78825" translate="yes" xml:space="preserve">
          <source>This layer provides options for condensing data into a categorical encoding. It accepts integer values as inputs and outputs a dense representation (one sample = 1-index tensor of float values representing data about the sample's tokens) of those inputs.</source>
          <target state="translated">このレイヤは、データをカテゴリカルエンコーディングに凝縮するためのオプションを提供します。これは整数値を入力として受け取り、それらの入力を密な表現(サンプルのトークンに関するデータを表す float 値の 1 つのサンプル=1 インデックステンソル)で出力します。</target>
        </trans-unit>
        <trans-unit id="47be8fc04afe99661c4ed5ab6b6d7ef9885d2eff" translate="yes" xml:space="preserve">
          <source>This layer provides options for condensing input data into denser representations. It accepts either integer values or strings as inputs, allows users to map those inputs into a contiguous integer space, and outputs either those integer values (one sample = 1D tensor of integer token indices) or a dense representation (one sample = 1D tensor of float values representing data about the sample's tokens).</source>
          <target state="translated">このレイヤは、入力データをより緻密な表現に凝縮するためのオプションを提供します。このレイヤは,入力として整数値または文字列のいずれかを受け取り,それらの入力を連続する整数空間にマップし,それらの整数値(1つのサンプル=整数トークンインデックスの1次元テンソル)または密な表現(1つのサンプル=サンプルのトークンに関するデータを表す浮動小数点値の1次元テンソル)のいずれかを出力します.</target>
        </trans-unit>
        <trans-unit id="344f6b570b33a446c2eb6dc9ce40efd08ad87ee8" translate="yes" xml:space="preserve">
          <source>This layer supports masking for input data with a variable number of timesteps. To introduce masks to your data, use an [tf.keras.layers.Embedding] layer with the &lt;code&gt;mask_zero&lt;/code&gt; parameter set to &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">このレイヤーは、可変ステップ数の入力データのマスキングをサポートします。データにマスクを導入するには、 &lt;code&gt;mask_zero&lt;/code&gt; パラメーターを &lt;code&gt;True&lt;/code&gt; に設定して[tf.keras.layers.Embedding]レイヤーを使用します。</target>
        </trans-unit>
        <trans-unit id="f1e7b36e17487480357995623584b1cdfb115de4" translate="yes" xml:space="preserve">
          <source>This layer transforms single or multiple categorical inputs to hashed output. It converts a sequence of int or string to a sequence of int. The stable hash function uses tensorflow::ops::Fingerprint to produce universal output that is consistent across platforms.</source>
          <target state="translated">このレイヤは、単一または複数のカテゴリ入力をハッシュ化された出力に変換します。これは、int または文字列のシーケンスを int のシーケンスに変換します。安定したハッシュ関数は、tensorflow::ops::Fingerprint を使用して、プラットフォーム間で一貫性のある普遍的な出力を生成します。</target>
        </trans-unit>
        <trans-unit id="d1b7379fe2dc54f750afe7d401d80af36bad9408" translate="yes" xml:space="preserve">
          <source>This layer translates a set of arbitrary integers into an integer output via a table-based lookup, with optional out-of-vocabulary handling.</source>
          <target state="translated">このレイヤは、任意の整数の集合をテーブルベースのルックアップで整数出力に変換します。</target>
        </trans-unit>
        <trans-unit id="bbcf3f69a06cbdc5f32560a16983b32541e31aaf" translate="yes" xml:space="preserve">
          <source>This layer translates a set of arbitrary strings into an integer output via a table-based lookup, with optional out-of-vocabulary handling.</source>
          <target state="translated">このレイヤは、任意の文字列の集合をテーブルベースのルックアップで整数出力に変換します。</target>
        </trans-unit>
        <trans-unit id="f87526b4a527a8b2c085b4914d68a929b0016554" translate="yes" xml:space="preserve">
          <source>This layer uses &lt;a href=&quot;https://github.com/google/farmhash&quot;&gt;FarmHash64&lt;/a&gt; by default, which provides a consistent hashed output across different platforms and is stable across invocations, regardless of device and context, by mixing the input bits thoroughly.</source>
          <target state="translated">このレイヤーはデフォルトで&lt;a href=&quot;https://github.com/google/farmhash&quot;&gt;FarmHash64&lt;/a&gt;を使用します。これは、異なるプラットフォーム間で一貫したハッシュ出力を提供し、入力ビットを完全に混合することにより、デバイスやコンテキストに関係なく、呼び出し間で安定しています。</target>
        </trans-unit>
        <trans-unit id="951c6b01ab8359114ccb88b8a93d70dd8a953954" translate="yes" xml:space="preserve">
          <source>This layer will coerce its inputs into a distribution centered around 0 with standard deviation 1. It accomplishes this by precomputing the mean and variance of the data, and calling (input-mean)/sqrt(var) at runtime.</source>
          <target state="translated">このレイヤは、入力を標準偏差1の0を中心とした分布に強制的にします。これは、データの平均と分散を事前に計算し、実行時に (input-mean)/sqrt(var)を呼び出すことで実現します。</target>
        </trans-unit>
        <trans-unit id="fe1b0f3431a8ec7d138b525163f2ad9cf543ffa7" translate="yes" xml:space="preserve">
          <source>This layer will coerce its inputs into a normal distribution centered around 0 with standard deviation 1. It accomplishes this by precomputing the mean and variance of the data, and calling (input-mean)/sqrt(var) at runtime.</source>
          <target state="translated">このレイヤは、入力を標準偏差 1、0 を中心とした正規分布に強制的にします。これは、データの平均と分散を事前に計算し、実行時に (input-mean)/sqrt(var)を呼び出すことで実現します。</target>
        </trans-unit>
        <trans-unit id="bf78e85c045cf32b4df68b19ac70fe5f256ed641" translate="yes" xml:space="preserve">
          <source>This layer will crop all the images in the same batch to the same cropping location. By default, random cropping is only applied during training. At inference time, the images will be first rescaled to preserve the shorter side, and center cropped. If you need to apply random cropping at inference time, set &lt;code&gt;training&lt;/code&gt; to True when calling the layer.</source>
          <target state="translated">このレイヤーは、同じバッチ内のすべての画像を同じトリミング場所にトリミングします。デフォルトでは、ランダムトリミングはトレーニング中にのみ適用されます。推論時に、画像は最初に短辺を保持するために再スケーリングされ、中央がトリミングされます。推論時にランダムなトリミングを適用する必要がある場合は、レイヤーを呼び出すときに &lt;code&gt;training&lt;/code&gt; をTrueに設定します。</target>
        </trans-unit>
        <trans-unit id="bc9e9462205fcd047a049604a7917fbea53a1a7d" translate="yes" xml:space="preserve">
          <source>This layer will flip the images based on the &lt;code&gt;mode&lt;/code&gt; attribute. During inference time, the output will be identical to input. Call the layer with &lt;code&gt;training=True&lt;/code&gt; to flip the input.</source>
          <target state="translated">このレイヤーは、 &lt;code&gt;mode&lt;/code&gt; 属性に基づいて画像を反転します。推論時間中、出力は入力と同じになります。 &lt;code&gt;training=True&lt;/code&gt; でレイヤーを呼び出して、入力を反転します。</target>
        </trans-unit>
        <trans-unit id="a3d352f01824e505c14a980e99a24ac05a3a55ba" translate="yes" xml:space="preserve">
          <source>This layer will place each element of its input data into one of several contiguous ranges and output an integer index indicating which range each element was placed in.</source>
          <target state="translated">このレイヤは、入力データの各要素を複数の連続する範囲のいずれかに配置し、各要素がどの範囲に配置されたかを示す整数のインデックスを出力します。</target>
        </trans-unit>
        <trans-unit id="fbf50d844249a2e7240d57251d949994666050a2" translate="yes" xml:space="preserve">
          <source>This library contains all implementations of ClusterResolvers. ClusterResolvers are a way of specifying cluster information for distributed execution. Built on top of existing &lt;code&gt;ClusterSpec&lt;/code&gt; framework, ClusterResolvers are a way for TensorFlow to communicate with various cluster management systems (e.g. GCE, AWS, etc...).</source>
          <target state="translated">このライブラリには、ClusterResolversのすべての実装が含まれています。ClusterResolversは、分散実行のクラスター情報を指定する方法です。既存の &lt;code&gt;ClusterSpec&lt;/code&gt; フレームワークの上に構築されたClusterResolversは、TensorFlowがさまざまなクラスター管理システム（GCE、AWSなど）と通信するための方法です。</target>
        </trans-unit>
        <trans-unit id="b6b2d72a41e6a38bd121d03e086a0c141b5bab2a" translate="yes" xml:space="preserve">
          <source>This makes the TensorFlow Lite interpreter accessible in Python. It is possible to use this interpreter in a multithreaded Python environment, but you must be sure to call functions of a particular instance from only one thread at a time. So if you want to have 4 threads running different inferences simultaneously, create an interpreter for each one as thread-local data. Similarly, if you are calling invoke() in one thread on a single interpreter but you want to use tensor() on another thread once it is done, you must use a synchronization primitive between the threads to ensure invoke has returned before calling tensor().</source>
          <target state="translated">これにより、TensorFlow LiteインタプリタがPythonで利用できるようになりました。マルチスレッドのPython環境でもこのインタプリタを使用することは可能ですが、特定のインスタンスの関数を一度に1つのスレッドから呼び出すようにしなければなりません。そのため、4つのスレッドで同時に異なる推論を実行させたい場合は、それぞれのスレッドのインタープリタをスレッドローカルデータとして作成します。同様に、1つのスレッドで1つのインタプリタでinvoke()を呼び出しているが、それが終わったら別のスレッドでtensor()を使いたい場合は、スレッド間の同期プリミティブを使って、tensor()を呼び出す前にinvokeが戻ってきたことを確認する必要があります。</target>
        </trans-unit>
        <trans-unit id="6846fc96931fb6bb57a7f6152c9caf47e33ab2da" translate="yes" xml:space="preserve">
          <source>This makes the summary tag more predictable and consistent for the user.</source>
          <target state="translated">これにより、サマリータグはユーザーにとってより予測しやすく、一貫性のあるものになります。</target>
        </trans-unit>
        <trans-unit id="ac535677c50e98c6e0ce0364a9b0ce341c3f0a28" translate="yes" xml:space="preserve">
          <source>This matches the behavior of If and While for determining if a tensor counts as true/false for a branch condition.</source>
          <target state="translated">これは、分岐条件でテンソルが真か偽かを判断するためのIfとwhileの動作と一致します。</target>
        </trans-unit>
        <trans-unit id="99fc0b3a4e959624cfdd7190647db3380c4e327c" translate="yes" xml:space="preserve">
          <source>This may be useful for checking HTML output.</source>
          <target state="translated">HTMLの出力を確認するのに便利かもしれません。</target>
        </trans-unit>
        <trans-unit id="381d4e4134c335f7e7e4d713df90044462182059" translate="yes" xml:space="preserve">
          <source>This may occur, for example, if an operation receives an input tensor that has an invalid value or shape. For example, the &lt;a href=&quot;../linalg/matmul&quot;&gt;&lt;code&gt;tf.matmul&lt;/code&gt;&lt;/a&gt; op will raise this error if it receives an input that is not a matrix, and the &lt;a href=&quot;../reshape&quot;&gt;&lt;code&gt;tf.reshape&lt;/code&gt;&lt;/a&gt; op will raise this error if the new shape does not match the number of elements in the input tensor.</source>
          <target state="translated">これは、たとえば、操作が無効な値または形状を持つ入力テンソルを受け取った場合に発生する可能性があります。たとえば、&lt;a href=&quot;../linalg/matmul&quot;&gt; &lt;code&gt;tf.matmul&lt;/code&gt; &lt;/a&gt; opは、マトリックスではない入力を受け取るとこのエラーを発生させ、&lt;a href=&quot;../reshape&quot;&gt; &lt;code&gt;tf.reshape&lt;/code&gt; &lt;/a&gt; opは、新しい形状が入力テンソルの要素数と一致しない場合にこのエラーを発生させます。</target>
        </trans-unit>
        <trans-unit id="5c451c9f3d5af265bc5daacf860461f46903194b" translate="yes" xml:space="preserve">
          <source>This may only be used inside &lt;code&gt;self.scope()&lt;/code&gt;.</source>
          <target state="translated">これは、 &lt;code&gt;self.scope()&lt;/code&gt; 内でのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="8407349f1434fe18f1d4f684e5cf94ad12755be8" translate="yes" xml:space="preserve">
          <source>This means that the result of matrix multiplication &lt;code&gt;v = Au&lt;/code&gt; has &lt;code&gt;Lth&lt;/code&gt; column given circular convolution between &lt;code&gt;h&lt;/code&gt; with the &lt;code&gt;Lth&lt;/code&gt; column of &lt;code&gt;u&lt;/code&gt;.</source>
          <target state="translated">これは、行列乗算 &lt;code&gt;v = Au&lt;/code&gt; の結果に、 &lt;code&gt;h&lt;/code&gt; と &lt;code&gt;u&lt;/code&gt; の &lt;code&gt;Lth&lt;/code&gt; 列との間の循環たたみ込みが指定されている &lt;code&gt;Lth&lt;/code&gt; 列があることを意味します。</target>
        </trans-unit>
        <trans-unit id="54a591701bef9e5baac7a364b34d92ce1a314391" translate="yes" xml:space="preserve">
          <source>This means the layout when converted and saved as an image is rotated 90 degrees clockwise from a typical spectrogram. Time is descending down the Y axis, and the frequency decreases from left to right.</source>
          <target state="translated">これは、変換して画像として保存したときのレイアウトが、一般的なスペクトログラムから時計回りに90度回転していることを意味します。時間はY軸を下降し、周波数は左から右に減少します。</target>
        </trans-unit>
        <trans-unit id="7bac1b11600b86163afb8ed50f9d2fd7c08c803e" translate="yes" xml:space="preserve">
          <source>This method allows you to define a &quot;feedable&quot; iterator where you can choose between concrete iterators by feeding a value in a &lt;code&gt;tf.Session.run&lt;/code&gt; call. In that case, &lt;code&gt;string_handle&lt;/code&gt; would be a &lt;a href=&quot;../placeholder&quot;&gt;&lt;code&gt;tf.compat.v1.placeholder&lt;/code&gt;&lt;/a&gt;, and you would feed it with the value of &lt;code&gt;tf.data.Iterator.string_handle&lt;/code&gt; in each step.</source>
          <target state="translated">このメソッドを使用すると、「フィード可能な」イテレーターを定義できます &lt;code&gt;tf.Session.run&lt;/code&gt; 呼び出しで値をフィードすることにより、具体的なイテレーターから選択できます。その場合には、 &lt;code&gt;string_handle&lt;/code&gt; はなり&lt;a href=&quot;../placeholder&quot;&gt; &lt;code&gt;tf.compat.v1.placeholder&lt;/code&gt; &lt;/a&gt;、あなたはの値とそれを養うでしょう &lt;code&gt;tf.data.Iterator.string_handle&lt;/code&gt; 各ステップインチ</target>
        </trans-unit>
        <trans-unit id="3ed29b40d37b37daebb7172d60a5cb7452fb1937" translate="yes" xml:space="preserve">
          <source>This method also allows multi-arity &lt;code&gt;elems&lt;/code&gt; and accumulator. If &lt;code&gt;elems&lt;/code&gt; is a (possibly nested) list or tuple of tensors, then each of these tensors must have a matching first (unpack) dimension. The second argument of &lt;code&gt;fn&lt;/code&gt; must match the structure of &lt;code&gt;elems&lt;/code&gt;.</source>
          <target state="translated">この方法では、マルチアリティの &lt;code&gt;elems&lt;/code&gt; とアキュムレータも使用できます。場合 &lt;code&gt;elems&lt;/code&gt; はテンソルの（おそらくネストされた）リストまたはタプルであり、これらのテンソルのそれぞれは、マッチング最初（アンパック）の寸法を有していなければなりません。 &lt;code&gt;fn&lt;/code&gt; の2番目の引数は、 &lt;code&gt;elems&lt;/code&gt; の構造と一致する必要があります。</target>
        </trans-unit>
        <trans-unit id="11d1041ad958b2d24d55eb0ab2e6d83f39085f6b" translate="yes" xml:space="preserve">
          <source>This method also allows multi-arity &lt;code&gt;elems&lt;/code&gt; and output of &lt;code&gt;fn&lt;/code&gt;. If &lt;code&gt;elems&lt;/code&gt; is a (possibly nested) list or tuple of tensors, then each of these tensors must have a matching first (unpack) dimension. The signature of &lt;code&gt;fn&lt;/code&gt; may match the structure of &lt;code&gt;elems&lt;/code&gt;. That is, if &lt;code&gt;elems&lt;/code&gt; is &lt;code&gt;(t1, [t2, t3, [t4, t5]])&lt;/code&gt;, then an appropriate signature for &lt;code&gt;fn&lt;/code&gt; is: &lt;code&gt;fn = lambda (t1, [t2, t3, [t4, t5]]):&lt;/code&gt;.</source>
          <target state="translated">このメソッドでは、マルチアリティの &lt;code&gt;elems&lt;/code&gt; と &lt;code&gt;fn&lt;/code&gt; の出力も可能です。場合 &lt;code&gt;elems&lt;/code&gt; はテンソルの（おそらくネストされた）リストまたはタプルであり、これらのテンソルのそれぞれは、マッチング最初（アンパック）の寸法を有していなければなりません。 &lt;code&gt;fn&lt;/code&gt; の署名は &lt;code&gt;elems&lt;/code&gt; の構造と一致する場合があります。つまり、 &lt;code&gt;elems&lt;/code&gt; が &lt;code&gt;(t1, [t2, t3, [t4, t5]])&lt;/code&gt; 場合、 &lt;code&gt;fn&lt;/code&gt; の適切なシグネチャは &lt;code&gt;fn = lambda (t1, [t2, t3, [t4, t5]]):&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="766a4862e3d658751f25e8ca0813b9af0856b88d" translate="yes" xml:space="preserve">
          <source>This method behaves differently than self.session(): for performance reasons &lt;code&gt;cached_session&lt;/code&gt; will by default reuse the same session within the same test. The session returned by this function will only be closed at the end of the test (in the TearDown function).</source>
          <target state="translated">このメソッドの動作はself.session（）とは異なります。パフォーマンス上の理由から、 &lt;code&gt;cached_session&lt;/code&gt; はデフォルトで同じテスト内の同じセッションを再利用します。この関数によって返されるセッションは、テストの最後（TearDown関数内）でのみ閉じられます。</target>
        </trans-unit>
        <trans-unit id="c7294d73f60860f63726337f7edc669a47fd434f" translate="yes" xml:space="preserve">
          <source>This method builds a new graph by first calling the &lt;code&gt;serving_input_receiver_fn&lt;/code&gt; to obtain feature &lt;code&gt;Tensor&lt;/code&gt;s, and then calling this &lt;code&gt;Estimator&lt;/code&gt;'s &lt;code&gt;model_fn&lt;/code&gt; to generate the model graph based on those features. It restores the given checkpoint (or, lacking that, the most recent checkpoint) into this graph in a fresh session. Finally it creates a timestamped export directory below the given &lt;code&gt;export_dir_base&lt;/code&gt;, and writes a &lt;code&gt;SavedModel&lt;/code&gt; into it containing a single &lt;code&gt;tf.MetaGraphDef&lt;/code&gt; saved from this session.</source>
          <target state="translated">このメソッドは、最初に &lt;code&gt;serving_input_receiver_fn&lt;/code&gt; を呼び出して機能 &lt;code&gt;Tensor&lt;/code&gt; を取得し、次にこの &lt;code&gt;Estimator&lt;/code&gt; の &lt;code&gt;model_fn&lt;/code&gt; を呼び出してそれらの機能に基づいてモデルグラフを生成することにより、新しいグラフを作成します。与えられたチェックポイント（またはそれがない場合は、最新のチェックポイント）を、新しいセッションでこのグラフに復元します。最後に、指定された &lt;code&gt;export_dir_base&lt;/code&gt; の下にタイムスタンプ付きのエクスポートディレクトリを作成し、このセッションから保存された単一の &lt;code&gt;tf.MetaGraphDef&lt;/code&gt; を含む &lt;code&gt;SavedModel&lt;/code&gt; をそこに書き込みます。</target>
        </trans-unit>
        <trans-unit id="c6ee7778196b7d2b41326a073f8b56a7c8a9a62d" translate="yes" xml:space="preserve">
          <source>This method can also be called directly on a Functional Model during construction. In this case, any loss Tensors passed to this Model must be symbolic and be able to be traced back to the model's &lt;code&gt;Input&lt;/code&gt;s. These losses become part of the model's topology and are tracked in &lt;code&gt;get_config&lt;/code&gt;.</source>
          <target state="translated">このメソッドは、構築中に機能モデルで直接呼び出すこともできます。この場合、このモデルに渡される損失テンソルはすべてシンボリックで、モデルの &lt;code&gt;Input&lt;/code&gt; までたどることができる必要があります。これらの損失はモデルのトポロジの一部になり、 &lt;code&gt;get_config&lt;/code&gt; で追跡されます。</target>
        </trans-unit>
        <trans-unit id="3e9d9d9b289f8d837ef3c68f7420c8739fcddb82" translate="yes" xml:space="preserve">
          <source>This method can also be called directly on a Functional Model during construction. In this case, any tensor passed to this Model must be symbolic and be able to be traced back to the model's &lt;code&gt;Input&lt;/code&gt;s. These metrics become part of the model's topology and are tracked when you save the model via &lt;code&gt;save()&lt;/code&gt;.</source>
          <target state="translated">このメソッドは、構築中に機能モデルで直接呼び出すこともできます。この場合、このモデルに渡されるテンソルはシンボリックであり、モデルの &lt;code&gt;Input&lt;/code&gt; までさかのぼることができる必要があります。これらのメトリックはモデルのトポロジの一部になり、 &lt;code&gt;save()&lt;/code&gt; を介してモデルを保存するときに追跡されます。</target>
        </trans-unit>
        <trans-unit id="72b1f5316c49fd45d1ca1593424ee77777a4e789" translate="yes" xml:space="preserve">
          <source>This method can be called multiple times, and will merge the given &lt;code&gt;shape&lt;/code&gt; with the current shape of this tensor. It can be used to provide additional information about the shape of this tensor that cannot be inferred from the graph alone. For example, this can be used to provide additional information about the shapes of images:</source>
          <target state="translated">この方法は、複数回呼び出すことができ、所与の合併する &lt;code&gt;shape&lt;/code&gt; このテンソルの現在の形状を有します。グラフだけからは推測できないこのテンソルの形状に関する追加情報を提供するために使用できます。たとえば、これを使用して画像の形状に関する追加情報を提供できます。</target>
        </trans-unit>
        <trans-unit id="312e4a6b05fc4ebb6ca2b98fbc58b54373467b4c" translate="yes" xml:space="preserve">
          <source>This method can be overridden to support custom evaluation logic. This method is called by &lt;a href=&quot;../model#evaluate&quot;&gt;&lt;code&gt;Model.evaluate&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../model#test_on_batch&quot;&gt;&lt;code&gt;Model.test_on_batch&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">このメソッドは、カスタム評価ロジックをサポートするためにオーバーライドできます。このメソッドは、&lt;a href=&quot;../model#evaluate&quot;&gt; &lt;code&gt;Model.evaluate&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;../model#test_on_batch&quot;&gt; &lt;code&gt;Model.test_on_batch&lt;/code&gt; &lt;/a&gt;によって呼び出されます。</target>
        </trans-unit>
        <trans-unit id="ec15a46dc0420f052e7d9fc2485824bcb8d59546" translate="yes" xml:space="preserve">
          <source>This method can be overridden to support custom evaluation logic. This method is called by &lt;a href=&quot;../model#make_test_function&quot;&gt;&lt;code&gt;Model.make_test_function&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">このメソッドは、カスタム評価ロジックをサポートするためにオーバーライドできます。このメソッドは&lt;a href=&quot;../model#make_test_function&quot;&gt; &lt;code&gt;Model.make_test_function&lt;/code&gt; &lt;/a&gt;によって呼び出されます。</target>
        </trans-unit>
        <trans-unit id="24b263a87142b52faa1e21dbe53ee04255d04a75" translate="yes" xml:space="preserve">
          <source>This method can be overridden to support custom evaluation logic. This method is called by &lt;a href=&quot;model#evaluate&quot;&gt;&lt;code&gt;Model.evaluate&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;model#test_on_batch&quot;&gt;&lt;code&gt;Model.test_on_batch&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">このメソッドは、カスタム評価ロジックをサポートするためにオーバーライドできます。このメソッドは、&lt;a href=&quot;model#evaluate&quot;&gt; &lt;code&gt;Model.evaluate&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;model#test_on_batch&quot;&gt; &lt;code&gt;Model.test_on_batch&lt;/code&gt; &lt;/a&gt;によって呼び出されます。</target>
        </trans-unit>
        <trans-unit id="00b8ab943979a68d8e7d563dec5f7eda81840f4f" translate="yes" xml:space="preserve">
          <source>This method can be overridden to support custom evaluation logic. This method is called by &lt;a href=&quot;model#make_test_function&quot;&gt;&lt;code&gt;Model.make_test_function&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">このメソッドは、カスタム評価ロジックをサポートするためにオーバーライドできます。このメソッドは&lt;a href=&quot;model#make_test_function&quot;&gt; &lt;code&gt;Model.make_test_function&lt;/code&gt; &lt;/a&gt;によって呼び出されます。</target>
        </trans-unit>
        <trans-unit id="4740c061fca2f7ba4333f6609ad3d2119d60a6e9" translate="yes" xml:space="preserve">
          <source>This method can be overridden to support custom inference logic. This method is called by &lt;a href=&quot;../model#make_predict_function&quot;&gt;&lt;code&gt;Model.make_predict_function&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">このメソッドは、カスタム推論ロジックをサポートするためにオーバーライドできます。このメソッドは、&lt;a href=&quot;../model#make_predict_function&quot;&gt; &lt;code&gt;Model.make_predict_function&lt;/code&gt; &lt;/a&gt;によって呼び出されます。</target>
        </trans-unit>
        <trans-unit id="9231f9e258188fbf7d82d2b745ff3bd729ba7207" translate="yes" xml:space="preserve">
          <source>This method can be overridden to support custom inference logic. This method is called by &lt;a href=&quot;../model#predict&quot;&gt;&lt;code&gt;Model.predict&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../model#predict_on_batch&quot;&gt;&lt;code&gt;Model.predict_on_batch&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">このメソッドは、カスタム推論ロジックをサポートするためにオーバーライドできます。このメソッドは、&lt;a href=&quot;../model#predict&quot;&gt; &lt;code&gt;Model.predict&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;../model#predict_on_batch&quot;&gt; &lt;code&gt;Model.predict_on_batch&lt;/code&gt; &lt;/a&gt;によって呼び出されます。</target>
        </trans-unit>
        <trans-unit id="d12957750990229d94e78212f50e83f538705ddf" translate="yes" xml:space="preserve">
          <source>This method can be overridden to support custom inference logic. This method is called by &lt;a href=&quot;model#make_predict_function&quot;&gt;&lt;code&gt;Model.make_predict_function&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">このメソッドは、カスタム推論ロジックをサポートするためにオーバーライドできます。このメソッドは、&lt;a href=&quot;model#make_predict_function&quot;&gt; &lt;code&gt;Model.make_predict_function&lt;/code&gt; &lt;/a&gt;によって呼び出されます。</target>
        </trans-unit>
        <trans-unit id="4ecd8d8943012dca870b082ac2069dbad2ddff8d" translate="yes" xml:space="preserve">
          <source>This method can be overridden to support custom inference logic. This method is called by &lt;a href=&quot;model#predict&quot;&gt;&lt;code&gt;Model.predict&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;model#predict_on_batch&quot;&gt;&lt;code&gt;Model.predict_on_batch&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">このメソッドは、カスタム推論ロジックをサポートするためにオーバーライドできます。このメソッドは、&lt;a href=&quot;model#predict&quot;&gt; &lt;code&gt;Model.predict&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;model#predict_on_batch&quot;&gt; &lt;code&gt;Model.predict_on_batch&lt;/code&gt; &lt;/a&gt;によって呼び出されます。</target>
        </trans-unit>
        <trans-unit id="52dfa555331eece2b509081a1f3acc2117560cba" translate="yes" xml:space="preserve">
          <source>This method can be overridden to support custom training logic. This method is called by &lt;a href=&quot;../model#fit&quot;&gt;&lt;code&gt;Model.fit&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../model#train_on_batch&quot;&gt;&lt;code&gt;Model.train_on_batch&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">このメソッドは、カスタムトレーニングロジックをサポートするためにオーバーライドできます。このメソッドは、&lt;a href=&quot;../model#fit&quot;&gt; &lt;code&gt;Model.fit&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;../model#train_on_batch&quot;&gt; &lt;code&gt;Model.train_on_batch&lt;/code&gt; &lt;/a&gt;によって呼び出されます。</target>
        </trans-unit>
        <trans-unit id="655f9f9c1b7ccd7db3e5c665ed02881a9dad1b2f" translate="yes" xml:space="preserve">
          <source>This method can be overridden to support custom training logic. This method is called by &lt;a href=&quot;../model#make_train_function&quot;&gt;&lt;code&gt;Model.make_train_function&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">このメソッドは、カスタムトレーニングロジックをサポートするためにオーバーライドできます。このメソッドは、&lt;a href=&quot;../model#make_train_function&quot;&gt; &lt;code&gt;Model.make_train_function&lt;/code&gt; &lt;/a&gt;によって呼び出されます。</target>
        </trans-unit>
        <trans-unit id="678799c210cac42289c8d3efd485d53c6086509d" translate="yes" xml:space="preserve">
          <source>This method can be overridden to support custom training logic. This method is called by &lt;a href=&quot;model#fit&quot;&gt;&lt;code&gt;Model.fit&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;model#train_on_batch&quot;&gt;&lt;code&gt;Model.train_on_batch&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">このメソッドは、カスタムトレーニングロジックをサポートするためにオーバーライドできます。このメソッドは、&lt;a href=&quot;model#fit&quot;&gt; &lt;code&gt;Model.fit&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;model#train_on_batch&quot;&gt; &lt;code&gt;Model.train_on_batch&lt;/code&gt; &lt;/a&gt;によって呼び出されます。</target>
        </trans-unit>
        <trans-unit id="ab33fe36b3e6b63aa5f9d2cddc383b1eeb7bd2db" translate="yes" xml:space="preserve">
          <source>This method can be overridden to support custom training logic. This method is called by &lt;a href=&quot;model#make_train_function&quot;&gt;&lt;code&gt;Model.make_train_function&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">このメソッドは、カスタムトレーニングロジックをサポートするためにオーバーライドできます。このメソッドは、&lt;a href=&quot;model#make_train_function&quot;&gt; &lt;code&gt;Model.make_train_function&lt;/code&gt; &lt;/a&gt;によって呼び出されます。</target>
        </trans-unit>
        <trans-unit id="a7f74b2952869b5420047da9ad72bf8f755d938b" translate="yes" xml:space="preserve">
          <source>This method can be used after a call to &lt;a href=&quot;enable_check_numerics&quot;&gt;&lt;code&gt;tf.debugging.enable_check_numerics()&lt;/code&gt;&lt;/a&gt; to disable the numerics-checking mechanism that catches infinity and NaN values output by ops executed eagerly or in tf.function-compiled graphs.</source>
          <target state="translated">このメソッドは、&lt;a href=&quot;enable_check_numerics&quot;&gt; &lt;code&gt;tf.debugging.enable_check_numerics()&lt;/code&gt; &lt;/a&gt;を呼び出した後に使用して、熱心に実行されたopsまたはtf.functionでコンパイルされたグラフで出力された無限大とNaN値をキャッチする数値チェックメカニズムを無効にすることができます。</target>
        </trans-unit>
        <trans-unit id="7667fea48f6e7bf7add0c54e02f390885694a1d8" translate="yes" xml:space="preserve">
          <source>This method can be used after a call to &lt;a href=&quot;enable_check_numerics&quot;&gt;&lt;code&gt;tf.debugging.enable_check_numerics()&lt;/code&gt;&lt;/a&gt; to disable the numerics-checking mechanism that catches inifnity and NaN values output by ops executed eagerly or in tf.function-compiled graphs.</source>
          <target state="translated">このメソッドは、&lt;a href=&quot;enable_check_numerics&quot;&gt; &lt;code&gt;tf.debugging.enable_check_numerics()&lt;/code&gt; &lt;/a&gt;への呼び出しの後に使用して、熱心に実行された演算またはtf.function-compiledグラフで実行されたopsによって出力された無限性およびNaN値をキャッチする数値チェックメカニズムを無効にすることができます。</target>
        </trans-unit>
        <trans-unit id="ab134bc99ff08cb5e34c3578ec66ab8ee325437d" translate="yes" xml:space="preserve">
          <source>This method can be used for several purposes. For example, where &lt;code&gt;experimental_distribute_dataset&lt;/code&gt; is unable to shard the input files, this method might be used to manually shard the dataset (avoiding the slow fallback behavior in &lt;code&gt;experimental_distribute_dataset&lt;/code&gt;). In cases where the dataset is infinite, this sharding can be done by creating dataset replicas that differ only in their random seed. &lt;code&gt;experimental_distribute_dataset&lt;/code&gt; may also sometimes fail to split the batch across replicas on a worker. In that case, this method can be used where that limitation does not exist.</source>
          <target state="translated">このメソッドはいくつかの目的に使用できます。たとえば、 &lt;code&gt;experimental_distribute_dataset&lt;/code&gt; が入力ファイルをシャーディングできない場合、このメソッドを使用してデータセットを手動でシャーディングできます（ &lt;code&gt;experimental_distribute_dataset&lt;/code&gt; での遅いフォールバック動作を回避します）。データセットが無限の場合、ランダムシードのみが異なるデータセットのレプリカを作成することで、このシャーディングを実行できます。 &lt;code&gt;experimental_distribute_dataset&lt;/code&gt; は、ワーカーのレプリカ間でバッチを分割できない場合もあります。その場合、この方法はその制限が存在しない場合に使用できます。</target>
        </trans-unit>
        <trans-unit id="4d445a1a8ccfc13d2cbb47a0cd8852bd14137cba" translate="yes" xml:space="preserve">
          <source>This method can be used inside a subclassed layer or model's &lt;code&gt;call&lt;/code&gt; function, in which case &lt;code&gt;losses&lt;/code&gt; should be a Tensor or list of Tensors.</source>
          <target state="translated">このメソッドは、サブクラス化されたレイヤーまたはモデルの &lt;code&gt;call&lt;/code&gt; 関数の内部で使用できます。この場合、 &lt;code&gt;losses&lt;/code&gt; はTensorまたはTensorのリストでなければなりません。</target>
        </trans-unit>
        <trans-unit id="1d54c9015867d4032542a340799e853563723710" translate="yes" xml:space="preserve">
          <source>This method can be used inside the &lt;code&gt;call()&lt;/code&gt; method of a subclassed layer or model.</source>
          <target state="translated">このメソッドは、サブクラス化されたレイヤーまたはモデルの &lt;code&gt;call()&lt;/code&gt; メソッド内で使用できます。</target>
        </trans-unit>
        <trans-unit id="0a08143c632d6d9a6c3bb58abdfe351796aa7d61" translate="yes" xml:space="preserve">
          <source>This method can be used to assert that there exists a shape that both &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; represent.</source>
          <target state="translated">このメソッドは、 &lt;code&gt;self&lt;/code&gt; と &lt;code&gt;other&lt;/code&gt; 両方が表す形状が存在することを表明するために使用できます。</target>
        </trans-unit>
        <trans-unit id="311f5dd67cb7916aeab132002e12e94284e8fdb8" translate="yes" xml:space="preserve">
          <source>This method can be used to create &lt;code&gt;RaggedTensor&lt;/code&gt;s with multiple uniform outer dimensions. For example, a &lt;code&gt;RaggedTensor&lt;/code&gt; with shape &lt;code&gt;[2, 2, None]&lt;/code&gt; can be constructed with this method from a &lt;code&gt;RaggedTensor&lt;/code&gt; values with shape &lt;code&gt;[4, None]&lt;/code&gt;:</source>
          <target state="translated">このメソッドを使用して、複数の均一な外形寸法を持つ &lt;code&gt;RaggedTensor&lt;/code&gt; を作成できます。例えば、 &lt;code&gt;RaggedTensor&lt;/code&gt; 形状の &lt;code&gt;[2, 2, None]&lt;/code&gt; から、この方法を用いて構築することができる &lt;code&gt;RaggedTensor&lt;/code&gt; の形状と値 &lt;code&gt;[4, None]&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="53a52d98446448532e361c5ab0b1a6a4bc35f1f2" translate="yes" xml:space="preserve">
          <source>This method can be used to merge partitions created by &lt;code&gt;dynamic_partition&lt;/code&gt; as illustrated on the following example:</source>
          <target state="translated">このメソッドは、次の例に示すように、 &lt;code&gt;dynamic_partition&lt;/code&gt; によって作成されたパーティションをマージするために使用できます。</target>
        </trans-unit>
        <trans-unit id="d34cdddad9212e7710a82e27967cd30b8fc5e14d" translate="yes" xml:space="preserve">
          <source>This method can be used to run a step function for training a number of times using input from a dataset.</source>
          <target state="translated">この方法は、データセットからの入力を利用して、トレーニングのためのステップ関数を何回も実行することができます。</target>
        </trans-unit>
        <trans-unit id="9c709bdcba30505f75d83241dd8ba3817ec876a1" translate="yes" xml:space="preserve">
          <source>This method currently blocks forever.</source>
          <target state="translated">この方法は現在、永遠にブロックされています。</target>
        </trans-unit>
        <trans-unit id="0f39f81e0d455fd570ceb61e61e1722fce44270e" translate="yes" xml:space="preserve">
          <source>This method enables setting metadata in a trace event after it is created.</source>
          <target state="translated">このメソッドは、トレースイベント作成後のトレースイベントにメタデータを設定できるようにします。</target>
        </trans-unit>
        <trans-unit id="bc0fd4004c973da3102a123f7521a19f6c88fb03" translate="yes" xml:space="preserve">
          <source>This method generalizes to higher-dimensions by simply providing a list for both the sp_ids as well as the vocab_size. In this case the resulting &lt;code&gt;SparseTensor&lt;/code&gt; has the following properties:</source>
          <target state="translated">このメソッドは、sp_idsとvocab_sizeの両方のリストを提供するだけで、より高次元に一般化されます。この場合、結果の &lt;code&gt;SparseTensor&lt;/code&gt; には次のプロパティがあります。</target>
        </trans-unit>
        <trans-unit id="a08e7549042177e7c94f4230a7e19c5cac25a2de" translate="yes" xml:space="preserve">
          <source>This method generalizes to higher-dimensions by simply providing a list for both the sp_ids as well as the vocab_size. In this case the resulting &lt;code&gt;SparseTensor&lt;/code&gt; has the following properties: - &lt;code&gt;indices&lt;/code&gt; is equivalent to &lt;code&gt;sp_ids[0].indices&lt;/code&gt; with the last dimension discarded and concatenated with &lt;code&gt;sp_ids[0].values, sp_ids[1].values, ...&lt;/code&gt;. - &lt;code&gt;values&lt;/code&gt; is simply &lt;code&gt;sp_values.values&lt;/code&gt;. - If &lt;code&gt;sp_ids.dense_shape = [D0, D1, ..., Dn, K]&lt;/code&gt;, then &lt;code&gt;output.shape = [D0, D1, ..., Dn] + vocab_size&lt;/code&gt;.</source>
          <target state="translated">このメソッドは、sp_idとvocab_sizeの両方のリストを提供するだけで、より高い次元に一般化します。この場合には、得られた &lt;code&gt;SparseTensor&lt;/code&gt; は、以下の特性を有する： - &lt;code&gt;indices&lt;/code&gt; と等価である &lt;code&gt;sp_ids[0].indices&lt;/code&gt; と廃棄と連結最後の次元と &lt;code&gt;sp_ids[0].values, sp_ids[1].values, ...&lt;/code&gt; 。 - &lt;code&gt;values&lt;/code&gt; は単に &lt;code&gt;sp_values.values&lt;/code&gt; です。 -もし &lt;code&gt;sp_ids.dense_shape = [D0, D1, ..., Dn, K]&lt;/code&gt; 、次いで &lt;code&gt;output.shape = [D0, D1, ..., Dn] + vocab_size&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e7e44aa7677b60789a9ebef54c74a9714ec4de2a" translate="yes" xml:space="preserve">
          <source>This method has similar semantics to the built-in &lt;code&gt;zip()&lt;/code&gt; function in Python, with the main difference being that the &lt;code&gt;datasets&lt;/code&gt; argument can be an arbitrary nested structure of &lt;code&gt;Dataset&lt;/code&gt; objects.</source>
          <target state="translated">このメソッドは、Python の組み込み &lt;code&gt;zip()&lt;/code&gt; 関数と同様のセマンティクスを持っていますが、主な違いは、 &lt;code&gt;datasets&lt;/code&gt; 引数が &lt;code&gt;Dataset&lt;/code&gt; オブジェクトの任意のネストされた構造にできることです。</target>
        </trans-unit>
        <trans-unit id="1925370323ce05b6dc0cdc8787e9c0d6ebf8403a" translate="yes" xml:space="preserve">
          <source>This method is a convenience wrapper for creating a &lt;a href=&quot;server&quot;&gt;&lt;code&gt;tf.distribute.Server&lt;/code&gt;&lt;/a&gt; with a &lt;a href=&quot;../train/serverdef&quot;&gt;&lt;code&gt;tf.train.ServerDef&lt;/code&gt;&lt;/a&gt; that specifies a single-process cluster containing a single task in a job called &lt;code&gt;&quot;local&quot;&lt;/code&gt;.</source>
          <target state="translated">このメソッドは、 &lt;code&gt;&quot;local&quot;&lt;/code&gt; と呼ばれるジョブで単一のタスクを含む単一プロセスのクラスターを指定する&lt;a href=&quot;../train/serverdef&quot;&gt; &lt;code&gt;tf.train.ServerDef&lt;/code&gt; &lt;/a&gt;を&lt;a href=&quot;server&quot;&gt; &lt;code&gt;tf.distribute.Server&lt;/code&gt; &lt;/a&gt;してtf.distribute.Serverを作成するための便利なラッパーです。</target>
        </trans-unit>
        <trans-unit id="05c81c4b69f5f8cdea4eba6f7d8bb00b2d7cd37f" translate="yes" xml:space="preserve">
          <source>This method is automatically called when the StubOutForTesting() object is deleted; there is no need to call it explicitly.</source>
          <target state="translated">このメソッドは、StubOutForTesting()オブジェクトが削除されたときに自動的に呼び出されます。</target>
        </trans-unit>
        <trans-unit id="992fe7b39731079182b90eaf498e1ed5e5a20148" translate="yes" xml:space="preserve">
          <source>This method is completely compatible with the &lt;code&gt;tf.Session.run()&lt;/code&gt; method.</source>
          <target state="translated">このメソッドは、 &lt;code&gt;tf.Session.run()&lt;/code&gt; メソッドと完全に互換性があります。</target>
        </trans-unit>
        <trans-unit id="9074766f6510dcf3975a88d8985dc7d0e99f0a13" translate="yes" xml:space="preserve">
          <source>This method is deprecated, use is_alive() instead.</source>
          <target state="translated">このメソッドは非推奨です。</target>
        </trans-unit>
        <trans-unit id="a744f7951fcb63381ecb2ea91dcc061d08e7d4a0" translate="yes" xml:space="preserve">
          <source>This method is exposed in TensorFlow's API so that library developers can register dispatching for &lt;a href=&quot;tensor#__eq__&quot;&gt;&lt;code&gt;Tensor.&lt;strong&gt;eq&lt;/strong&gt;&lt;/code&gt;&lt;/a&gt; to allow it to handle custom composite tensors &amp;amp; other custom objects.</source>
          <target state="translated">このメソッドはTensorFlowのAPIで公開されているため、ライブラリ開発者は&lt;a href=&quot;tensor#__eq__&quot;&gt; &lt;code&gt;Tensor.&lt;strong&gt;eq&lt;/strong&gt;&lt;/code&gt; &lt;/a&gt;ディスパッチを登録できます。カスタム複合テンソルおよびその他のカスタムオブジェクトを処理できるようにする&lt;strong&gt;eq&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="8a699437e1c2aa279788c76128e6e5f624c7c0a7" translate="yes" xml:space="preserve">
          <source>This method is exposed in TensorFlow's API so that library developers can register dispatching for &lt;a href=&quot;tensor#__getitem__&quot;&gt;&lt;code&gt;Tensor.&lt;strong&gt;getitem&lt;/strong&gt;&lt;/code&gt;&lt;/a&gt; to allow it to handle custom composite tensors &amp;amp; other custom objects.</source>
          <target state="translated">このメソッドはTensorFlowのAPIで公開されているため、ライブラリ開発者は&lt;a href=&quot;tensor#__getitem__&quot;&gt; &lt;code&gt;Tensor.&lt;strong&gt;getitem&lt;/strong&gt;&lt;/code&gt; &lt;/a&gt;ディスパッチを登録できます。&lt;strong&gt;getitem&lt;/strong&gt;を使用して、カスタム複合テンソルおよびその他のカスタムオブジェクトを処理できるようにします。</target>
        </trans-unit>
        <trans-unit id="ca897118350393caa56db53d55d7ff23f3ea66bf" translate="yes" xml:space="preserve">
          <source>This method is exposed in TensorFlow's API so that library developers can register dispatching for &lt;a href=&quot;tensor#__ne__&quot;&gt;&lt;code&gt;Tensor.&lt;strong&gt;ne&lt;/strong&gt;&lt;/code&gt;&lt;/a&gt; to allow it to handle custom composite tensors &amp;amp; other custom objects.</source>
          <target state="translated">このメソッドはTensorFlowのAPIで公開されているため、ライブラリ開発者は&lt;a href=&quot;tensor#__ne__&quot;&gt; &lt;code&gt;Tensor.&lt;strong&gt;ne&lt;/strong&gt;&lt;/code&gt; &lt;/a&gt;ディスパッチを登録できます。&lt;strong&gt;ne&lt;/strong&gt;は、カスタム複合テンソルおよびその他のカスタムオブジェクトを処理できるようにします。</target>
        </trans-unit>
        <trans-unit id="a7dd7ea7386a00c65842a1da48fad6c58e2f712f" translate="yes" xml:space="preserve">
          <source>This method is for use by TestCase subclasses that need to register their own type equality functions to provide nicer error messages.</source>
          <target state="translated">このメソッドは、より良いエラーメッセージを提供するために独自の型の平等性関数を登録する必要があるTestCaseサブクラスが使用するためのものです。</target>
        </trans-unit>
        <trans-unit id="66283121e6883c956c7613fffa84d220528690f4" translate="yes" xml:space="preserve">
          <source>This method is idempotent. Calling it multiple times has the same effect as calling it once.</source>
          <target state="translated">このメソッドは、idempotentです。複数回呼び出しても、1回呼び出したのと同じ効果があります。</target>
        </trans-unit>
        <trans-unit id="26e25dbe646e6bb109fc819d323736b4d761ed81" translate="yes" xml:space="preserve">
          <source>This method is intended to be used to load checkpoints created by &lt;code&gt;save()&lt;/code&gt;. For checkpoints created by &lt;code&gt;write()&lt;/code&gt; use the &lt;code&gt;read()&lt;/code&gt; method which does not expect the &lt;code&gt;save_counter&lt;/code&gt; variable added by &lt;code&gt;save()&lt;/code&gt;.</source>
          <target state="translated">このメソッドは、 &lt;code&gt;save()&lt;/code&gt; によって作成されたチェックポイントをロードするために使用することを目的としています。 &lt;code&gt;write()&lt;/code&gt; によって作成されたチェックポイントの場合、 &lt;code&gt;save()&lt;/code&gt; によって追加された &lt;code&gt;save_counter&lt;/code&gt; 変数を予期しない &lt;code&gt;read()&lt;/code&gt; メソッドを使用します。</target>
        </trans-unit>
        <trans-unit id="887c8b37e88faa620b24a828f5dc104598906d79" translate="yes" xml:space="preserve">
          <source>This method is just like &lt;code&gt;restore()&lt;/code&gt; but does not expect the &lt;code&gt;save_counter&lt;/code&gt; variable in the checkpoint. It only restores the objects that the checkpoint already depends on.</source>
          <target state="translated">このメソッドは &lt;code&gt;restore()&lt;/code&gt; と同じですが、チェックポイントに &lt;code&gt;save_counter&lt;/code&gt; 変数を想定していません。チェックポイントがすでに依存しているオブジェクトのみを復元します。</target>
        </trans-unit>
        <trans-unit id="d1d2fc5aba91c121cb755ded927621c464c711dd" translate="yes" xml:space="preserve">
          <source>This method is only needed if you compute gradients manually, e.g. with &lt;a href=&quot;../../../gradienttape&quot;&gt;&lt;code&gt;tf.GradientTape&lt;/code&gt;&lt;/a&gt;. In that case, call this method to scale the loss before passing the loss to &lt;a href=&quot;../../../gradienttape&quot;&gt;&lt;code&gt;tf.GradientTape&lt;/code&gt;&lt;/a&gt;. If you use &lt;a href=&quot;../../optimizers/optimizer#minimize&quot;&gt;&lt;code&gt;LossScaleOptimizer.minimize&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;lossscaleoptimizer#get_gradients&quot;&gt;&lt;code&gt;LossScaleOptimizer.get_gradients&lt;/code&gt;&lt;/a&gt;, loss scaling is automatically applied and this method is unneeded.</source>
          <target state="translated">このメソッドは、たとえば&lt;a href=&quot;../../../gradienttape&quot;&gt; &lt;code&gt;tf.GradientTape&lt;/code&gt; &lt;/a&gt;を使用して手動でグラデーションを計算する場合にのみ必要です。その場合、損失を&lt;a href=&quot;../../../gradienttape&quot;&gt; &lt;code&gt;tf.GradientTape&lt;/code&gt; &lt;/a&gt;に渡す前に、このメソッドを呼び出して損失をスケーリングします。&lt;a href=&quot;../../optimizers/optimizer#minimize&quot;&gt; &lt;code&gt;LossScaleOptimizer.minimize&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;lossscaleoptimizer#get_gradients&quot;&gt; &lt;code&gt;LossScaleOptimizer.get_gradients&lt;/code&gt; &lt;/a&gt;を使用する場合、損失スケーリングが自動的に適用されるため、このメソッドは不要です。</target>
        </trans-unit>
        <trans-unit id="2ffe062127379160c3973cd4f84270b4f4f8ccf9" translate="yes" xml:space="preserve">
          <source>This method is only needed if you compute gradients manually, e.g. with &lt;a href=&quot;../../../gradienttape&quot;&gt;&lt;code&gt;tf.GradientTape&lt;/code&gt;&lt;/a&gt;. In that case, call this method to unscale the gradients after computing them with &lt;a href=&quot;../../../gradienttape&quot;&gt;&lt;code&gt;tf.GradientTape&lt;/code&gt;&lt;/a&gt;. If you use &lt;a href=&quot;../../optimizers/optimizer#minimize&quot;&gt;&lt;code&gt;LossScaleOptimizer.minimize&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;lossscaleoptimizer#get_gradients&quot;&gt;&lt;code&gt;LossScaleOptimizer.get_gradients&lt;/code&gt;&lt;/a&gt;, loss scaling is automatically applied and this method is unneeded.</source>
          <target state="translated">このメソッドは、たとえば&lt;a href=&quot;../../../gradienttape&quot;&gt; &lt;code&gt;tf.GradientTape&lt;/code&gt; &lt;/a&gt;を使用して手動でグラデーションを計算する場合にのみ必要です。その場合、tf.GradientTapeでグラデーションを計算した後、このメソッドを呼び出してグラデーションの&lt;a href=&quot;../../../gradienttape&quot;&gt; &lt;code&gt;tf.GradientTape&lt;/code&gt; &lt;/a&gt;を解除します。&lt;a href=&quot;../../optimizers/optimizer#minimize&quot;&gt; &lt;code&gt;LossScaleOptimizer.minimize&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;lossscaleoptimizer#get_gradients&quot;&gt; &lt;code&gt;LossScaleOptimizer.get_gradients&lt;/code&gt; &lt;/a&gt;を使用する場合、損失スケーリングが自動的に適用されるため、このメソッドは不要です。</target>
        </trans-unit>
        <trans-unit id="2d15ade5009ad723801c2c48bded790a3845587f" translate="yes" xml:space="preserve">
          <source>This method is optional if you are just training and executing models, exporting to and from SavedModels, or using weight checkpoints.</source>
          <target state="translated">モデルのトレーニングと実行、SavedModelsへのエクスポートとSavedModelsからのエクスポート、またはウェイトチェックポイントを使用するだけの場合は、このメソッドはオプションです。</target>
        </trans-unit>
        <trans-unit id="2ed4e772dabffd01cfde2b74159ef69c9f3e04f5" translate="yes" xml:space="preserve">
          <source>This method is required for Keras &lt;code&gt;model_to_estimator&lt;/code&gt;, saving and loading models to HDF5 formats, Keras model cloning, some visualization utilities, and exporting models to and from JSON.</source>
          <target state="translated">このメソッドは、 &lt;code&gt;model_to_estimator&lt;/code&gt; 、モデルのHDF5形式への保存と読み込み、Kerasモデルのクローン作成、いくつかの視覚化ユーティリティ、およびJSONとのモデルのエクスポートに必要です。</target>
        </trans-unit>
        <trans-unit id="6fdad9c5ed22f16c319e244d8261ea4ee3d279dd" translate="yes" xml:space="preserve">
          <source>This method is smart and works at the module, class, and instance level while preserving proper inheritance. It will not stub out C types however unless that has been explicitly allowed by the type.</source>
          <target state="translated">このメソッドはスマートで、適切な継承を維持しながらモジュール、クラス、インスタンスレベルで動作します。ただし、型によって明示的に許可されていない限り、C の型をスタブアウトすることはありません。</target>
        </trans-unit>
        <trans-unit id="feecb6a599cedcf2305768be36a750d8591e9329" translate="yes" xml:space="preserve">
          <source>This method is the reverse of &lt;code&gt;get_config&lt;/code&gt;, capable of instantiating the same layer from the config dictionary. It does not handle layer connectivity (handled by Network), nor weights (handled by &lt;code&gt;set_weights&lt;/code&gt;).</source>
          <target state="translated">このメソッドは &lt;code&gt;get_config&lt;/code&gt; の逆であり、構成辞書から同じレイヤーをインスタンス化できます。レイヤーの接続性（ネットワークで処理）や重み（ &lt;code&gt;set_weights&lt;/code&gt; で処理）は処理しません。</target>
        </trans-unit>
        <trans-unit id="422559cd09a8b37855dfa1becf9159996c55a88c" translate="yes" xml:space="preserve">
          <source>This method is the reverse of &lt;code&gt;get_config&lt;/code&gt;, capable of instantiating the same optimizer from the config dictionary.</source>
          <target state="translated">このメソッドは &lt;code&gt;get_config&lt;/code&gt; の逆であり、構成辞書から同じオプティマイザをインスタンス化できます。</target>
        </trans-unit>
        <trans-unit id="c7d6ed78b790787a16f4abeccc0ecd949df6cc2b" translate="yes" xml:space="preserve">
          <source>This method is the reverse of &lt;code&gt;get_config&lt;/code&gt;, capable of instantiating the same regularizer from the config dictionary.</source>
          <target state="translated">このメソッドは &lt;code&gt;get_config&lt;/code&gt; の逆であり、構成辞書から同じ正規化子をインスタンス化できます。</target>
        </trans-unit>
        <trans-unit id="64a729de3228c199e6f42ec9b13a781c1672f7d1" translate="yes" xml:space="preserve">
          <source>This method is the same as setting &lt;code&gt;minval&lt;/code&gt; and &lt;code&gt;maxval&lt;/code&gt; to &lt;code&gt;None&lt;/code&gt; in the &lt;code&gt;uniform&lt;/code&gt; method.</source>
          <target state="translated">この方法は、設定と同じである &lt;code&gt;minval&lt;/code&gt; と &lt;code&gt;maxval&lt;/code&gt; に &lt;code&gt;None&lt;/code&gt; に &lt;code&gt;uniform&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="188de6cc0c368ed4ab40eeabc0c2f0a4587200cc" translate="yes" xml:space="preserve">
          <source>This method is thread-safe.</source>
          <target state="translated">このメソッドはスレッドセーフです。</target>
        </trans-unit>
        <trans-unit id="430e31afd2b8ce36dbd30c0726de058dc4716f34" translate="yes" xml:space="preserve">
          <source>This method is used by Keras &lt;code&gt;model_to_estimator&lt;/code&gt;, saving and loading models to HDF5 formats, Keras model cloning, some visualization utilities, and exporting models to and from JSON.</source>
          <target state="translated">このメソッドは、 &lt;code&gt;model_to_estimator&lt;/code&gt; 、モデルのHDF5形式への保存と読み込み、Kerasモデルのクローン作成、いくつかの視覚化ユーティリティ、およびJSONとのモデルのエクスポートで使用されます。</target>
        </trans-unit>
        <trans-unit id="457bbe494ff8a7cc3168e5b2acb3fc1d7df09a01" translate="yes" xml:space="preserve">
          <source>This method is used to convert a dictionary into a sequence of parameters for a binary that parses arguments using this module.</source>
          <target state="translated">このメソッドは、このモジュールを使用して引数を解析するバイナリのために、辞書をパラメータのシーケンスに変換するために使用されます。</target>
        </trans-unit>
        <trans-unit id="5f40fabbeaa1bcaea8e9654a487713070e7848ee" translate="yes" xml:space="preserve">
          <source>This method is useful for recovering the &quot;self._last_checkpoints&quot; state.</source>
          <target state="translated">このメソッドは、&quot;self._last_checkpoints &quot;の状態を回復するのに便利です。</target>
        </trans-unit>
        <trans-unit id="5eb2940a1b8924b3a2b4c6c370fcb87bd404d70c" translate="yes" xml:space="preserve">
          <source>This method may be called concurrently from multiple threads.</source>
          <target state="translated">このメソッドは、複数のスレッドから同時に呼び出されることがあります。</target>
        </trans-unit>
        <trans-unit id="879b4ac0bfff915fe8733219e840864c530b0386" translate="yes" xml:space="preserve">
          <source>This method must be used as a context manager, and will yield a recording object with two attributes: &lt;code&gt;output&lt;/code&gt; and &lt;code&gt;records&lt;/code&gt;. At the end of the context manager, the &lt;code&gt;output&lt;/code&gt; attribute will be a list of the matching formatted log messages and the &lt;code&gt;records&lt;/code&gt; attribute will be a list of the corresponding LogRecord objects.</source>
          <target state="translated">このメソッドはコンテキストマネージャーとして使用する必要があり、2つの属性（ &lt;code&gt;output&lt;/code&gt; と &lt;code&gt;records&lt;/code&gt; )を持つレコーディングオブジェクトを生成します。コンテキストマネージャの最後で、 &lt;code&gt;output&lt;/code&gt; 属性は一致するフォーマット済みログメッセージのリストになり、 &lt;code&gt;records&lt;/code&gt; 属性は対応するLogRecordオブジェクトのリストになります。</target>
        </trans-unit>
        <trans-unit id="45b78faa33c30a4ca2de4d4a2a7e0ea54433a6aa" translate="yes" xml:space="preserve">
          <source>This method overrides unittest.TestCase.shortDescription(), which only returns the first line of the docstring, obscuring the name of the test upon failure.</source>
          <target state="translated">このメソッドは unittest.TestCase.shortDescription()をオーバーライドし、docstring の 1 行目のみを返し、失敗したときにテスト名が不明瞭になるようにします。</target>
        </trans-unit>
        <trans-unit id="ee5a67ef5f4ab3abd49e8e0aa6ab37b4c495718e" translate="yes" xml:space="preserve">
          <source>This method promotes a completely unknown shape to one with a known rank.</source>
          <target state="translated">この方法では、全く知られていない形状のものを、ランクが分かっているものに昇格させることができます。</target>
        </trans-unit>
        <trans-unit id="f08536c5c4bd5b0bf81a621ac1af31ff012f949c" translate="yes" xml:space="preserve">
          <source>This method requires a session in which the graph was launched. It creates a list of threads, optionally starting them. There is one thread for each op passed in &lt;code&gt;enqueue_ops&lt;/code&gt;.</source>
          <target state="translated">この方法では、グラフが起動されたセッションが必要です。スレッドのリストを作成し、オプションでスレッドを開始します。 &lt;code&gt;enqueue_ops&lt;/code&gt; で渡される各操作に対して1つのスレッドがあります。</target>
        </trans-unit>
        <trans-unit id="ed37572237615338abb9afe9f97f9e51444c9050" translate="yes" xml:space="preserve">
          <source>This method requires that you are running in eager mode and the dataset's element_spec contains only &lt;code&gt;TensorSpec&lt;/code&gt; components.</source>
          <target state="translated">このメソッドでは、eagerモードで実行していて、データセットのelement_specに &lt;code&gt;TensorSpec&lt;/code&gt; コンポーネントのみが含まれている必要があります。</target>
        </trans-unit>
        <trans-unit id="ba66428fee92af2921958313c4abbe6a414d3356" translate="yes" xml:space="preserve">
          <source>This method requires that you are running in eager mode, and that the length of the dataset is known and non-infinite. When the length may be unknown or infinite, or if you are running in graph mode, use &lt;a href=&quot;../../../../data/dataset#cardinality&quot;&gt;&lt;code&gt;tf.data.Dataset.cardinality&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">この方法では、イーガーモードで実行していること、およびデータセットの長さが既知であり、無限ではないことが必要です。長さが不明または無限である可能性がある場合、またはグラフモードで実行している場合は、代わりに&lt;a href=&quot;../../../../data/dataset#cardinality&quot;&gt; &lt;code&gt;tf.data.Dataset.cardinality&lt;/code&gt; &lt;/a&gt;を使用してください。</target>
        </trans-unit>
        <trans-unit id="c229102fa2fa8b3a631fa2db6ca01f20dd5c2adc" translate="yes" xml:space="preserve">
          <source>This method requires that you are running in eager mode, and that the length of the dataset is known and non-infinite. When the length may be unknown or infinite, or if you are running in graph mode, use &lt;a href=&quot;../../../data/dataset#cardinality&quot;&gt;&lt;code&gt;tf.data.Dataset.cardinality&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">この方法では、イーガーモードで実行していること、およびデータセットの長さが既知であり、無限ではないことが必要です。長さが不明または無限である可能性がある場合、またはグラフモードで実行している場合は、代わりに&lt;a href=&quot;../../../data/dataset#cardinality&quot;&gt; &lt;code&gt;tf.data.Dataset.cardinality&lt;/code&gt; &lt;/a&gt;を使用してください。</target>
        </trans-unit>
        <trans-unit id="2bff5648ed0712c0feea6c45e6290da036f8f217" translate="yes" xml:space="preserve">
          <source>This method requires that you are running in eager mode, and that the length of the dataset is known and non-infinite. When the length may be unknown or infinite, or if you are running in graph mode, use &lt;a href=&quot;../dataset#cardinality&quot;&gt;&lt;code&gt;tf.data.Dataset.cardinality&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">この方法では、イーガーモードで実行していること、およびデータセットの長さが既知であり、無限ではないことが必要です。長さが不明または無限である可能性がある場合、またはグラフモードで実行している場合は、代わりに&lt;a href=&quot;../dataset#cardinality&quot;&gt; &lt;code&gt;tf.data.Dataset.cardinality&lt;/code&gt; &lt;/a&gt;を使用してください。</target>
        </trans-unit>
        <trans-unit id="4d8d6fb6d8be4a1c2d9cfd5ec8103395810dc8de" translate="yes" xml:space="preserve">
          <source>This method requires that you are running in eager mode, and that the length of the dataset is known and non-infinite. When the length may be unknown or infinite, or if you are running in graph mode, use &lt;a href=&quot;dataset#cardinality&quot;&gt;&lt;code&gt;tf.data.Dataset.cardinality&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">この方法では、イーガーモードで実行していること、およびデータセットの長さが既知であり、無限ではないことが必要です。長さが不明または無限である可能性がある場合、またはグラフモードで実行している場合は、代わりに&lt;a href=&quot;dataset#cardinality&quot;&gt; &lt;code&gt;tf.data.Dataset.cardinality&lt;/code&gt; &lt;/a&gt;を使用してください。</target>
        </trans-unit>
        <trans-unit id="df938127180a900a9c0ee2c326f70990ca05bad0" translate="yes" xml:space="preserve">
          <source>This method returns True just before the run() method starts until just after the run() method terminates. The module function enumerate() returns a list of all alive threads.</source>
          <target state="translated">このメソッドは、run()メソッドが開始する直前から run()メソッドが終了する直前まで True を返します。モジュール関数 enumerate()は、生きているすべてのスレッドのリストを返します。</target>
        </trans-unit>
        <trans-unit id="843186b661a979f57d76fd131bdb6daf25004a63" translate="yes" xml:space="preserve">
          <source>This method returns a context manager, and is used as follows:</source>
          <target state="translated">このメソッドはコンテキストマネージャーを返します。</target>
        </trans-unit>
        <trans-unit id="67c5a6af4d2a477a788bf93645d98e3fc1667925" translate="yes" xml:space="preserve">
          <source>This method runs one &quot;step&quot; of TensorFlow computation, by running the necessary graph fragment to execute every &lt;code&gt;Operation&lt;/code&gt; and evaluate every &lt;code&gt;Tensor&lt;/code&gt; in &lt;code&gt;fetches&lt;/code&gt;, substituting the values in &lt;code&gt;feed_dict&lt;/code&gt; for the corresponding input values.</source>
          <target state="translated">この方法は、すべての実行に必要なグラフの断片を実行することによって、TensorFlow計算の「ステップ」を実行 &lt;code&gt;Operation&lt;/code&gt; 毎および評価 &lt;code&gt;Tensor&lt;/code&gt; で &lt;code&gt;fetches&lt;/code&gt; 、の値を代入 &lt;code&gt;feed_dict&lt;/code&gt; 対応する入力値に対して。</target>
        </trans-unit>
        <trans-unit id="7ef4f95365ffd49356edce6309d3da564feb3d3b" translate="yes" xml:space="preserve">
          <source>This method runs the ops added by the constructor for restoring variables. It requires a session in which the graph was launched. The variables to restore do not have to have been initialized, as restoring is itself a way to initialize variables.</source>
          <target state="translated">このメソッドは、変数のリストアのためにコンストラクタで追加されたオペレーションを実行します。グラフが起動されたセッションが必要です。復元する変数は初期化されている必要はありません。</target>
        </trans-unit>
        <trans-unit id="6a0628c028c0b695f5ff3c6935b2aad50149fac6" translate="yes" xml:space="preserve">
          <source>This method runs the ops added by the constructor for saving variables. It requires a session in which the graph was launched. The variables to save must also have been initialized.</source>
          <target state="translated">このメソッドは、変数を保存するためにコンストラクタで追加された操作を実行します。グラフが起動されたセッションが必要です。保存する変数も初期化されている必要があります。</target>
        </trans-unit>
        <trans-unit id="9df50570004b7fc9f261d6b98cab329e6a66afe0" translate="yes" xml:space="preserve">
          <source>This method sets the vocabulary and DF data for this layer directly, instead of analyzing a dataset through 'adapt'. It should be used whenever the vocab (and optionally document frequency) information is already known. If vocabulary data is already present in the layer, this method will either replace it, if 'append' is set to False, or append to it (if 'append' is set to True).</source>
          <target state="translated">このメソッドは、データセットを 'adapt' で分析するのではなく、このレイヤの語彙と DF データを直接設定する。このメソッドは、ボキャブラリー(およびオプションで文書頻度)情報が既に知られている場合に使用されるべきである。ボキャブラリーデータが既にそのレイヤーに存在する場合、このメソッドは、'append' が False に設定されている場合には、それを置き換えるか、またはそれに追加します('append' が True に設定されている場合)。</target>
        </trans-unit>
        <trans-unit id="98a596750a8e57f7c4dd92233c96d160228e7339" translate="yes" xml:space="preserve">
          <source>This method sets the vocabulary and DF data for this layer directly, instead of analyzing a dataset through 'adapt'. It should be used whenever the vocab (and optionally document frequency) information is already known. If vocabulary data is already present in the layer, this method will replace it.</source>
          <target state="translated">このメソッドは、データセットを 'adapt' で分析するのではなく、このレイヤの語彙と DF データを直接設定する。このメソッドは、ボキャブラリー(およびオプションで文書頻度)情報が既に知られている場合に使用されるべきである。ボキャブラリーデータが既にそのレイヤに存在する場合、このメソッドはそれを置き換えます。</target>
        </trans-unit>
        <trans-unit id="f39e288c36cc30e58aa384f98451d54174eefdc7" translate="yes" xml:space="preserve">
          <source>This method sets the vocabulary for this layer directly, instead of analyzing a dataset through 'adapt'. It should be used whenever the vocab information is already known. If vocabulary data is already present in the layer, this method will either replace it</source>
          <target state="translated">このメソッドは、データセットを 'adapt' で解析するのではなく、このレイヤーの語彙を直接設定します。このメソッドは、語彙情報が既に知られている場合に使用されるべきです。ボキャブラリー情報がすでにレイヤーに存在する場合、このメソッドはそれを置き換えるか、または</target>
        </trans-unit>
        <trans-unit id="381d5d74ef1ba876c849eaf0c748814799df311b" translate="yes" xml:space="preserve">
          <source>This method should be used if you want to create multiple graphs in the same process. For convenience, a global default graph is provided, and all ops will be added to this graph if you do not create a new graph explicitly.</source>
          <target state="translated">このメソッドは、同じプロセスで複数のグラフを作成したい場合に使用します。便宜上、グローバルなデフォルトのグラフが用意されており、新しいグラフを明示的に作成しない場合は、すべての操作がこのグラフに追加されます。</target>
        </trans-unit>
        <trans-unit id="801d04a3f8f77fe9f713a4af6184910c6103cec6" translate="yes" xml:space="preserve">
          <source>This method should be used to create all threads in test cases, as otherwise there is a risk that a thread will silently fail, and/or assertions made in the thread will not be respected.</source>
          <target state="translated">このメソッドは、テストケース内のすべてのスレッドを作成するために使用しなければなりません。そうしないと、スレッドが静かに失敗したり、スレッド内で行われたアサーションが尊重されなくなったりするリスクがあるからです。</target>
        </trans-unit>
        <trans-unit id="0840a5953e72a61137caa721b5cce35c70dbd3d8" translate="yes" xml:space="preserve">
          <source>This method should contain the mathemetical logic for one step of inference. This typically includes the forward pass.</source>
          <target state="translated">この方法は、推論の1ステップのための数学的論理を含むべきである。これには通常、フォワードパスが含まれます。</target>
        </trans-unit>
        <trans-unit id="eebfd3cd848c16a7d254cfeece5ae46941b7f986" translate="yes" xml:space="preserve">
          <source>This method should contain the mathemetical logic for one step of training. This typically includes the forward pass, loss calculation, backpropagation, and metric updates.</source>
          <target state="translated">この方法は、訓練の1ステップのための数学的論理を含むべきである。これは、典型的には、フォワードパス、損失計算、バックプロパゲーション、およびメトリック更新を含む。</target>
        </trans-unit>
        <trans-unit id="84ddde0d41fb950f979365b1dd4b04e51a4464b1" translate="yes" xml:space="preserve">
          <source>This method simply combines calls &lt;code&gt;compute_gradients()&lt;/code&gt; and &lt;code&gt;apply_gradients()&lt;/code&gt;. If you want to process the gradient before applying them call &lt;code&gt;compute_gradients()&lt;/code&gt; and &lt;code&gt;apply_gradients()&lt;/code&gt; explicitly instead of using this function.</source>
          <target state="translated">このメソッドは、単に &lt;code&gt;compute_gradients()&lt;/code&gt; と &lt;code&gt;apply_gradients()&lt;/code&gt; の呼び出しを組み合わせます。グラデーションを適用する前に処理したい場合は、この関数を使用する代わりに、 &lt;code&gt;compute_gradients()&lt;/code&gt; および &lt;code&gt;apply_gradients()&lt;/code&gt; を明示的に呼び出します。</target>
        </trans-unit>
        <trans-unit id="5f6d383158cc853c41c5bc430e4c2e31944ed6aa" translate="yes" xml:space="preserve">
          <source>This method simply computes gradient using &lt;a href=&quot;../../../gradienttape&quot;&gt;&lt;code&gt;tf.GradientTape&lt;/code&gt;&lt;/a&gt; and calls &lt;code&gt;apply_gradients()&lt;/code&gt;. If you want to process the gradient before applying then call &lt;a href=&quot;../../../gradienttape&quot;&gt;&lt;code&gt;tf.GradientTape&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;apply_gradients()&lt;/code&gt; explicitly instead of using this function.</source>
          <target state="translated">このメソッドは単に&lt;a href=&quot;../../../gradienttape&quot;&gt; &lt;code&gt;tf.GradientTape&lt;/code&gt; &lt;/a&gt;を使用して勾配を計算し、 &lt;code&gt;apply_gradients()&lt;/code&gt; を呼び出します。適用する前にグラデーションを処理する場合は、この関数を使用する代わりに、&lt;a href=&quot;../../../gradienttape&quot;&gt; &lt;code&gt;tf.GradientTape&lt;/code&gt; &lt;/a&gt;および &lt;code&gt;apply_gradients()&lt;/code&gt; を明示的に呼び出します。</target>
        </trans-unit>
        <trans-unit id="7c45540d5f88e8d63143978a302ef3be7b4897a3" translate="yes" xml:space="preserve">
          <source>This method simply computes gradient using &lt;a href=&quot;../../gradienttape&quot;&gt;&lt;code&gt;tf.GradientTape&lt;/code&gt;&lt;/a&gt; and calls &lt;code&gt;apply_gradients()&lt;/code&gt;. If you want to process the gradient before applying then call &lt;a href=&quot;../../gradienttape&quot;&gt;&lt;code&gt;tf.GradientTape&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;apply_gradients()&lt;/code&gt; explicitly instead of using this function.</source>
          <target state="translated">このメソッドは単に&lt;a href=&quot;../../gradienttape&quot;&gt; &lt;code&gt;tf.GradientTape&lt;/code&gt; &lt;/a&gt;を使用して勾配を計算し、 &lt;code&gt;apply_gradients()&lt;/code&gt; を呼び出します。適用する前にグラデーションを処理する場合は、この関数を使用する代わりに、&lt;a href=&quot;../../gradienttape&quot;&gt; &lt;code&gt;tf.GradientTape&lt;/code&gt; &lt;/a&gt;および &lt;code&gt;apply_gradients()&lt;/code&gt; を明示的に呼び出します。</target>
        </trans-unit>
        <trans-unit id="9fbf54940adbbc3b34153fb181199a19b56bd888" translate="yes" xml:space="preserve">
          <source>This method supports the case where attr_name is a staticmethod or a classmethod of obj.</source>
          <target state="translated">このメソッドは、attr_name が staticmethod または obj の classmethod である場合をサポートします。</target>
        </trans-unit>
        <trans-unit id="b1e95fe0c7a12cd011cb442b54315c64dbbef85c" translate="yes" xml:space="preserve">
          <source>This method supports the case where child_name is a staticmethod or a classmethod of parent.</source>
          <target state="translated">このメソッドは、child_name が staticmethod または parent の classmethod である場合をサポートします。</target>
        </trans-unit>
        <trans-unit id="3c5357e5e49a58f1873923787332f7877e186b5d" translate="yes" xml:space="preserve">
          <source>This method takes effect only on the thread in which it is called.</source>
          <target state="translated">このメソッドは、呼び出されたスレッドに対してのみ有効になります。</target>
        </trans-unit>
        <trans-unit id="dc69067a62ba3479c811e1ffb95925d4cb95f817" translate="yes" xml:space="preserve">
          <source>This method takes the same args as the DeviceSpec constructor</source>
          <target state="translated">このメソッドは DeviceSpec のコンストラクタと同じ引数を取ります。</target>
        </trans-unit>
        <trans-unit id="7cd6047c37611c4ef1b1add7ec4d3db22681db24" translate="yes" xml:space="preserve">
          <source>This method will also be called as a result of recovering a wrapped session, not only at the beginning of the overall session.</source>
          <target state="translated">このメソッドは、全体のセッションの開始時だけでなく、ラップされたセッションを回復した結果としても呼び出されます。</target>
        </trans-unit>
        <trans-unit id="b524a4798bc6e14abf1530810ef4205d0b748932" translate="yes" xml:space="preserve">
          <source>This method will block caller thread until it receives tracing result. This method supports CPU, GPU, and Cloud TPU. This method supports profiling a single host for CPU, GPU, TPU, as well as multiple TPU workers. The profiled results will be saved to your specified TensorBoard log directory (e.g. the directory you save your model checkpoints). Use the TensorBoard profile plugin to view the visualization and analysis results.</source>
          <target state="translated">このメソッドは、トレース結果を受け取るまで呼び出し元のスレッドをブロックします。このメソッドは、CPU、GPU、クラウドTPUをサポートしています。このメソッドは、CPU、GPU、TPU、および複数のTPUワーカーの単一ホストのプロファイリングをサポートしています。プロファイリングされた結果は、指定したTensorBoardログディレクトリ(モデルのチェックポイントを保存するディレクトリなど)に保存されます。TensorBoard profileプラグインを使用して、可視化と解析結果を表示します。</target>
        </trans-unit>
        <trans-unit id="80c9b1eb0c3b33d3a7e2274259517a077b4c895e" translate="yes" xml:space="preserve">
          <source>This method will first try to restore from the most recent checkpoint in &lt;code&gt;directory&lt;/code&gt;. If no checkpoints exist in &lt;code&gt;directory&lt;/code&gt;, and &lt;code&gt;init_fn&lt;/code&gt; is specified, this method will call &lt;code&gt;init_fn&lt;/code&gt; to do customized initialization. This can be used to support initialization from pretrained models.</source>
          <target state="translated">This method will first try to restore from the most recent checkpoint in &lt;code&gt;directory&lt;/code&gt; . If no checkpoints exist in &lt;code&gt;directory&lt;/code&gt; , and &lt;code&gt;init_fn&lt;/code&gt; is specified, this method will call &lt;code&gt;init_fn&lt;/code&gt; to do customized initialization. This can be used to support initialization from pretrained models.</target>
        </trans-unit>
        <trans-unit id="72f0ec32b5d6b0d5f31ec5a44977c2b73ae22a24" translate="yes" xml:space="preserve">
          <source>This method will raise a RuntimeError if called more than once on the same thread object.</source>
          <target state="translated">このメソッドは、同じスレッドオブジェクト上で複数回呼び出された場合、RuntimeErrorを発生させます。</target>
        </trans-unit>
        <trans-unit id="5450168f56def10b3805f1b87bf923f81daadea9" translate="yes" xml:space="preserve">
          <source>This method works similar to tf.map_fn but is optimized to run much faster, possibly with a much larger memory footprint. The speedups are obtained by vectorization (see &lt;a href=&quot;https://arxiv.org/pdf/1903.04243.pdf&quot;&gt;https://arxiv.org/pdf/1903.04243.pdf&lt;/a&gt;). The idea behind vectorization is to semantically launch all the invocations of &lt;code&gt;fn&lt;/code&gt; in parallel and fuse corresponding operations across all these invocations. This fusion is done statically at graph generation time and the generated code is often similar in performance to a manually fused version.</source>
          <target state="translated">This method works similar to tf.map_fn but is optimized to run much faster, possibly with a much larger memory footprint. The speedups are obtained by vectorization (see &lt;a href=&quot;https://arxiv.org/pdf/1903.04243.pdf&quot;&gt;https://arxiv.org/pdf/1903.04243.pdf&lt;/a&gt;). The idea behind vectorization is to semantically launch all the invocations of &lt;code&gt;fn&lt;/code&gt; in parallel and fuse corresponding operations across all these invocations. This fusion is done statically at graph generation time and the generated code is often similar in performance to a manually fused version.</target>
        </trans-unit>
        <trans-unit id="218a6eaea58d633bb4c07cebec2cce2a54164fc8" translate="yes" xml:space="preserve">
          <source>This method works similar to tf.map_fn but is optimized to run much faster, possibly with a much larger memory footprint. The speedups are obtained by vectorization (see https://arxiv.org/pdf/1903.04243.pdf). The idea behind vectorization is to semantically launch all the invocations of &lt;code&gt;fn&lt;/code&gt; in parallel and fuse corresponding operations across all these invocations. This fusion is done statically at graph generation time and the generated code is often similar in performance to a manually fused version.</source>
          <target state="translated">このメソッドはtf.map_fnと同様に機能しますが、メモリフットプリントがはるかに大きい場合に、より高速に実行するように最適化されています。高速化はベクトル化によって得られます（https://arxiv.org/pdf/1903.04243.pdfを参照）。ベクトル化の背後にある考え方は、 &lt;code&gt;fn&lt;/code&gt; のすべての呼び出しを意味的に並列に起動し、これらすべての呼び出し間で対応する操作を融合することです。この融合はグラフの生成時に静的に行われ、生成されたコードのパフォーマンスは手動で融合されたバージョンとほぼ同じです。</target>
        </trans-unit>
        <trans-unit id="fe5b3fca46a696592f5d3933d9a6c2e14a59d105" translate="yes" xml:space="preserve">
          <source>This method wraps the provided session in an &lt;code&gt;Event&lt;/code&gt; protocol buffer and adds it to the event file.</source>
          <target state="translated">このメソッドは、提供されたセッションを &lt;code&gt;Event&lt;/code&gt; プロトコルバッファーにラップし、それをイベントファイルに追加します。</target>
        </trans-unit>
        <trans-unit id="0b654fd9b9bcfd951b8584e5c172fdf88b6f87e9" translate="yes" xml:space="preserve">
          <source>This method wraps the provided summary in an &lt;code&gt;Event&lt;/code&gt; protocol buffer and adds it to the event file.</source>
          <target state="translated">このメソッドは、提供された概要を &lt;code&gt;Event&lt;/code&gt; プロトコルバッファーにラップし、それをイベントファイルに追加します。</target>
        </trans-unit>
        <trans-unit id="e573192331e3d216aaf00fffe24f089e83e9c9ad" translate="yes" xml:space="preserve">
          <source>This method, unlike assertCountEqual, doesn't care about any duplicates in the expected and actual sequences.</source>
          <target state="translated">このメソッドは、assertCountEqualとは異なり、期待される配列と実際の配列の重複を気にしません。</target>
        </trans-unit>
        <trans-unit id="0b693febd3a0c9fc69fb14a0f914449cb9729097" translate="yes" xml:space="preserve">
          <source>This metric creates four local variables, &lt;code&gt;true_positives&lt;/code&gt;, &lt;code&gt;true_negatives&lt;/code&gt;, &lt;code&gt;false_positives&lt;/code&gt; and &lt;code&gt;false_negatives&lt;/code&gt; that are used to compute the AUC. To discretize the AUC curve, a linearly spaced set of thresholds is used to compute pairs of recall and precision values. The area under the ROC-curve is therefore computed using the height of the recall values by the false positive rate, while the area under the PR-curve is the computed using the height of the precision values by the recall.</source>
          <target state="translated">このメトリックは、AUCの計算に使用される4つのローカル変数、 &lt;code&gt;true_positives&lt;/code&gt; 、 &lt;code&gt;true_negatives&lt;/code&gt; 、 &lt;code&gt;false_positives&lt;/code&gt; および &lt;code&gt;false_negatives&lt;/code&gt; を作成します。 AUC曲線を離散化するには、線形間隔のしきい値のセットを使用して、再現率と精度の値のペアを計算します。したがって、ROC曲線の下の面積は、偽陽性率による再現値の高さを使用して計算され、PR曲線の下の面積は、再現値の精度値の高さを使用して計算されます。</target>
        </trans-unit>
        <trans-unit id="8310e01ff09f3ad784585cc77cdb8fe7f1ac0213" translate="yes" xml:space="preserve">
          <source>This metric creates four local variables, &lt;code&gt;true_positives&lt;/code&gt;, &lt;code&gt;true_negatives&lt;/code&gt;, &lt;code&gt;false_positives&lt;/code&gt; and &lt;code&gt;false_negatives&lt;/code&gt; that are used to compute the precision at the given recall. The threshold for the given recall value is computed and used to evaluate the corresponding precision.</source>
          <target state="translated">このメトリックは、4つのローカル変数 &lt;code&gt;true_positives&lt;/code&gt; 、 &lt;code&gt;true_negatives&lt;/code&gt; 、 &lt;code&gt;false_positives&lt;/code&gt; 、および &lt;code&gt;false_negatives&lt;/code&gt; を作成します。これらは、指定された再現率での精度の計算に使用されます。指定された再現率のしきい値が計算され、対応する精度を評価するために使用されます。</target>
        </trans-unit>
        <trans-unit id="cd97f6783f485e9e31fe2474cb3ca5414d0a738b" translate="yes" xml:space="preserve">
          <source>This metric creates four local variables, &lt;code&gt;true_positives&lt;/code&gt;, &lt;code&gt;true_negatives&lt;/code&gt;, &lt;code&gt;false_positives&lt;/code&gt; and &lt;code&gt;false_negatives&lt;/code&gt; that are used to compute the recall at the given precision. The threshold for the given precision value is computed and used to evaluate the corresponding recall.</source>
          <target state="translated">This metric creates four local variables, &lt;code&gt;true_positives&lt;/code&gt; , &lt;code&gt;true_negatives&lt;/code&gt; , &lt;code&gt;false_positives&lt;/code&gt; and &lt;code&gt;false_negatives&lt;/code&gt; that are used to compute the recall at the given precision. The threshold for the given precision value is computed and used to evaluate the corresponding recall.</target>
        </trans-unit>
        <trans-unit id="a469d6ce618a21614949a4828cde8383fb0456e0" translate="yes" xml:space="preserve">
          <source>This metric creates four local variables, &lt;code&gt;true_positives&lt;/code&gt;, &lt;code&gt;true_negatives&lt;/code&gt;, &lt;code&gt;false_positives&lt;/code&gt; and &lt;code&gt;false_negatives&lt;/code&gt; that are used to compute the sensitivity at the given specificity. The threshold for the given specificity value is computed and used to evaluate the corresponding sensitivity.</source>
          <target state="translated">このメトリックは、4つのローカル変数、 &lt;code&gt;true_positives&lt;/code&gt; 、 &lt;code&gt;true_negatives&lt;/code&gt; 、 &lt;code&gt;false_positives&lt;/code&gt; 、および &lt;code&gt;false_negatives&lt;/code&gt; を作成します。これらは、特定の特異性での感度の計算に使用されます。指定された特異度値のしきい値が計算され、対応する感度を評価するために使用されます。</target>
        </trans-unit>
        <trans-unit id="ff9252130946c80b57ae4c5ee9b47938ca02b839" translate="yes" xml:space="preserve">
          <source>This metric creates four local variables, &lt;code&gt;true_positives&lt;/code&gt;, &lt;code&gt;true_negatives&lt;/code&gt;, &lt;code&gt;false_positives&lt;/code&gt; and &lt;code&gt;false_negatives&lt;/code&gt; that are used to compute the specificity at the given sensitivity. The threshold for the given sensitivity value is computed and used to evaluate the corresponding specificity.</source>
          <target state="translated">このメトリックは、4つのローカル変数 &lt;code&gt;true_positives&lt;/code&gt; 、 &lt;code&gt;true_negatives&lt;/code&gt; 、 &lt;code&gt;false_positives&lt;/code&gt; 、および &lt;code&gt;false_negatives&lt;/code&gt; を作成します。これらは、指定された感度で特異度を計算するために使用されます。所定の感度値のしきい値が計算され、対応する特異性を評価するために使用されます。</target>
        </trans-unit>
        <trans-unit id="fb652b4471c79604ae7dfb8ff87ca222abc482c6" translate="yes" xml:space="preserve">
          <source>This metric creates one variable, &lt;code&gt;total&lt;/code&gt;, that is used to compute the sum of &lt;code&gt;values&lt;/code&gt;. This is ultimately returned as &lt;code&gt;sum&lt;/code&gt;.</source>
          <target state="translated">このメトリックは、 &lt;code&gt;values&lt;/code&gt; の合計を計算するために使用される1つの変数 &lt;code&gt;total&lt;/code&gt; を作成します。これは最終的に &lt;code&gt;sum&lt;/code&gt; として返されます。</target>
        </trans-unit>
        <trans-unit id="77a69992763ecf548ab84fef5482d353d7a9cba3" translate="yes" xml:space="preserve">
          <source>This metric creates two local variables, &lt;code&gt;total&lt;/code&gt; and &lt;code&gt;count&lt;/code&gt; that are used to compute the frequency with which &lt;code&gt;y_pred&lt;/code&gt; matches &lt;code&gt;y_true&lt;/code&gt;. This frequency is ultimately returned as &lt;code&gt;binary accuracy&lt;/code&gt;: an idempotent operation that simply divides &lt;code&gt;total&lt;/code&gt; by &lt;code&gt;count&lt;/code&gt;.</source>
          <target state="translated">このメトリックは、 &lt;code&gt;y_pred&lt;/code&gt; がy_trueに一致する頻度を計算するために使用される2つのローカル変数、 &lt;code&gt;total&lt;/code&gt; および &lt;code&gt;count&lt;/code&gt; を &lt;code&gt;y_true&lt;/code&gt; ます。この頻度は、最終的には &lt;code&gt;binary accuracy&lt;/code&gt; として返され &lt;code&gt;count&lt;/code&gt; 。これは、 &lt;code&gt;total&lt;/code&gt; をカウントで単純に除算するべき等演算です。</target>
        </trans-unit>
        <trans-unit id="10a549b6038018b3cebc025343c39cb24e67e040" translate="yes" xml:space="preserve">
          <source>This metric creates two local variables, &lt;code&gt;total&lt;/code&gt; and &lt;code&gt;count&lt;/code&gt; that are used to compute the frequency with which &lt;code&gt;y_pred&lt;/code&gt; matches &lt;code&gt;y_true&lt;/code&gt;. This frequency is ultimately returned as &lt;code&gt;categorical accuracy&lt;/code&gt;: an idempotent operation that simply divides &lt;code&gt;total&lt;/code&gt; by &lt;code&gt;count&lt;/code&gt;.</source>
          <target state="translated">このメトリックは、 &lt;code&gt;y_pred&lt;/code&gt; がy_trueに一致する頻度を計算するために使用される2つのローカル変数、 &lt;code&gt;total&lt;/code&gt; および &lt;code&gt;count&lt;/code&gt; を &lt;code&gt;y_true&lt;/code&gt; ます。この周波数は、最終的として返される &lt;code&gt;categorical accuracy&lt;/code&gt; ：冪等の操作を単に分割すること &lt;code&gt;total&lt;/code&gt; によって &lt;code&gt;count&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2d4e9dd5712eaf45fc10b998b8c6d4caf2e34bae" translate="yes" xml:space="preserve">
          <source>This metric creates two local variables, &lt;code&gt;total&lt;/code&gt; and &lt;code&gt;count&lt;/code&gt; that are used to compute the frequency with which &lt;code&gt;y_pred&lt;/code&gt; matches &lt;code&gt;y_true&lt;/code&gt;. This frequency is ultimately returned as &lt;code&gt;sparse categorical accuracy&lt;/code&gt;: an idempotent operation that simply divides &lt;code&gt;total&lt;/code&gt; by &lt;code&gt;count&lt;/code&gt;.</source>
          <target state="translated">このメトリックは、 &lt;code&gt;y_pred&lt;/code&gt; がy_trueに一致する頻度を計算するために使用される2つのローカル変数、 &lt;code&gt;total&lt;/code&gt; および &lt;code&gt;count&lt;/code&gt; を &lt;code&gt;y_true&lt;/code&gt; ます。この頻度は、最終的には &lt;code&gt;sparse categorical accuracy&lt;/code&gt; として返され &lt;code&gt;count&lt;/code&gt; 。これは、単純に &lt;code&gt;total&lt;/code&gt; をカウントで除算するべき等演算です。</target>
        </trans-unit>
        <trans-unit id="300536328f19b08910251bd6b961009b9a37a3b7" translate="yes" xml:space="preserve">
          <source>This metric creates two local variables, &lt;code&gt;total&lt;/code&gt; and &lt;code&gt;count&lt;/code&gt; that are used to compute the mean relative absolute error. This average is weighted by &lt;code&gt;sample_weight&lt;/code&gt;, and it is ultimately returned as &lt;code&gt;mean_relative_error&lt;/code&gt;: an idempotent operation that simply divides &lt;code&gt;total&lt;/code&gt; by &lt;code&gt;count&lt;/code&gt;.</source>
          <target state="translated">このメトリックは、平均相対絶対誤差の計算に使用される &lt;code&gt;total&lt;/code&gt; と &lt;code&gt;count&lt;/code&gt; 2つのローカル変数を作成します。この平均は、 &lt;code&gt;sample_weight&lt;/code&gt; によって重み付けされ、最終的には、 &lt;code&gt;mean_relative_error&lt;/code&gt; として返され &lt;code&gt;count&lt;/code&gt; 。これは、単純に &lt;code&gt;total&lt;/code&gt; をカウントで除算するべき等演算です。</target>
        </trans-unit>
        <trans-unit id="aea998ffd50f56931370c8f2e5952f5d92b92150" translate="yes" xml:space="preserve">
          <source>This metric creates two local variables, &lt;code&gt;total&lt;/code&gt; and &lt;code&gt;count&lt;/code&gt; that are used to compute the mean relative error. This is weighted by &lt;code&gt;sample_weight&lt;/code&gt;, and it is ultimately returned as &lt;code&gt;mean_relative_error&lt;/code&gt;: an idempotent operation that simply divides &lt;code&gt;total&lt;/code&gt; by &lt;code&gt;count&lt;/code&gt;.</source>
          <target state="translated">This metric creates two local variables, &lt;code&gt;total&lt;/code&gt; and &lt;code&gt;count&lt;/code&gt; that are used to compute the mean relative error. This is weighted by &lt;code&gt;sample_weight&lt;/code&gt; , and it is ultimately returned as &lt;code&gt;mean_relative_error&lt;/code&gt; : an idempotent operation that simply divides &lt;code&gt;total&lt;/code&gt; by &lt;code&gt;count&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0bf885c318184cc4d7f8536f5a3a6cfc0be45917" translate="yes" xml:space="preserve">
          <source>This metric creates two local variables, &lt;code&gt;true_positives&lt;/code&gt; and &lt;code&gt;false_negatives&lt;/code&gt;, that are used to compute the recall. This value is ultimately returned as &lt;code&gt;recall&lt;/code&gt;, an idempotent operation that simply divides &lt;code&gt;true_positives&lt;/code&gt; by the sum of &lt;code&gt;true_positives&lt;/code&gt; and &lt;code&gt;false_negatives&lt;/code&gt;.</source>
          <target state="translated">このメトリックは、 &lt;code&gt;true_positives&lt;/code&gt; 計算に使用される2つのローカル変数true_positivesおよび &lt;code&gt;false_negatives&lt;/code&gt; を作成します。この値は最終的に、 &lt;code&gt;recall&lt;/code&gt; として返されます。これは、 &lt;code&gt;true_positives&lt;/code&gt; を &lt;code&gt;false_negatives&lt;/code&gt; の合計で単純に除算する &lt;code&gt;true_positives&lt;/code&gt; 等演算です。</target>
        </trans-unit>
        <trans-unit id="093560f8538560280d9ed1cd9a3cab29a6cbb355" translate="yes" xml:space="preserve">
          <source>This metric creates two variables, &lt;code&gt;total&lt;/code&gt; and &lt;code&gt;count&lt;/code&gt; that are used to compute the average of &lt;code&gt;values&lt;/code&gt;. This average is ultimately returned as &lt;code&gt;mean&lt;/code&gt; which is an idempotent operation that simply divides &lt;code&gt;total&lt;/code&gt; by &lt;code&gt;count&lt;/code&gt;.</source>
          <target state="translated">このメトリックは、 &lt;code&gt;values&lt;/code&gt; の平均を計算するために使用される &lt;code&gt;total&lt;/code&gt; と &lt;code&gt;count&lt;/code&gt; 2つの変数を作成します。この平均は、最終的に平均として返され &lt;code&gt;mean&lt;/code&gt; これは、単純に &lt;code&gt;total&lt;/code&gt; を &lt;code&gt;count&lt;/code&gt; 除算するべき等演算です。</target>
        </trans-unit>
        <trans-unit id="0c9b94b35f1d2e4eb96d2ecbbedfd0249ca4dde6" translate="yes" xml:space="preserve">
          <source>This metric keeps the average cosine similarity between &lt;code&gt;predictions&lt;/code&gt; and &lt;code&gt;labels&lt;/code&gt; over a stream of data.</source>
          <target state="translated">このメトリックは、データストリーム全体の &lt;code&gt;predictions&lt;/code&gt; と &lt;code&gt;labels&lt;/code&gt; 間の平均コサイン類似性を維持します。</target>
        </trans-unit>
        <trans-unit id="418d70f20044dbd3397385f2c468b1eaa3216144" translate="yes" xml:space="preserve">
          <source>This model accepts sparse float inputs as well:</source>
          <target state="translated">このモデルは、疎な浮動小数点演算子の入力も受け付けます。</target>
        </trans-unit>
        <trans-unit id="3a4737a2c04c7eb94694e1e82664a0b0d934f20d" translate="yes" xml:space="preserve">
          <source>This model approximates the following function:</source>
          <target state="translated">このモデルは次のような関数に近似しています。</target>
        </trans-unit>
        <trans-unit id="82e7fe60bedc5bc6c52d1131a24d660c1d1e5baf" translate="yes" xml:space="preserve">
          <source>This model jointly train a linear and a dnn model.</source>
          <target state="translated">このモデルは、線形モデルとnnモデルを共同で学習します。</target>
        </trans-unit>
        <trans-unit id="e8ea575479c33e1d3b54efb7336850606e620ed3" translate="yes" xml:space="preserve">
          <source>This module contains experimental &lt;code&gt;Dataset&lt;/code&gt; sources and transformations that can be used in conjunction with the &lt;a href=&quot;../../../data/dataset&quot;&gt;&lt;code&gt;tf.data.Dataset&lt;/code&gt;&lt;/a&gt; API. Note that the &lt;a href=&quot;../../../data/experimental&quot;&gt;&lt;code&gt;tf.data.experimental&lt;/code&gt;&lt;/a&gt; API is not subject to the same backwards compatibility guarantees as &lt;a href=&quot;../../../data&quot;&gt;&lt;code&gt;tf.data&lt;/code&gt;&lt;/a&gt;, but we will provide deprecation advice in advance of removing existing functionality.</source>
          <target state="translated">このモジュールには、&lt;a href=&quot;../../../data/dataset&quot;&gt; &lt;code&gt;tf.data.Dataset&lt;/code&gt; &lt;/a&gt; API と組み合わせて使用​​できる実験的な &lt;code&gt;Dataset&lt;/code&gt; ソースと変換が含まれています。ことを注意&lt;a href=&quot;../../../data/experimental&quot;&gt; &lt;code&gt;tf.data.experimental&lt;/code&gt; &lt;/a&gt; APIと同じ後方互換性を保証の対象ではありません&lt;a href=&quot;../../../data&quot;&gt; &lt;code&gt;tf.data&lt;/code&gt; &lt;/a&gt;、私たちは既存の機能を除去する前に非推奨のアドバイスを提供します。</target>
        </trans-unit>
        <trans-unit id="048da49888cbf092642d30c4a165ddde49bb4a0b" translate="yes" xml:space="preserve">
          <source>This module contains experimental &lt;code&gt;Dataset&lt;/code&gt; sources and transformations that can be used in conjunction with the &lt;a href=&quot;dataset&quot;&gt;&lt;code&gt;tf.data.Dataset&lt;/code&gt;&lt;/a&gt; API. Note that the &lt;a href=&quot;experimental&quot;&gt;&lt;code&gt;tf.data.experimental&lt;/code&gt;&lt;/a&gt; API is not subject to the same backwards compatibility guarantees as &lt;a href=&quot;../data&quot;&gt;&lt;code&gt;tf.data&lt;/code&gt;&lt;/a&gt;, but we will provide deprecation advice in advance of removing existing functionality.</source>
          <target state="translated">このモジュールには、&lt;a href=&quot;dataset&quot;&gt; &lt;code&gt;tf.data.Dataset&lt;/code&gt; &lt;/a&gt; API と組み合わせて使用​​できる実験的な &lt;code&gt;Dataset&lt;/code&gt; ソースと変換が含まれています。ことを注意&lt;a href=&quot;experimental&quot;&gt; &lt;code&gt;tf.data.experimental&lt;/code&gt; &lt;/a&gt; APIと同じ後方互換性を保証の対象ではありません&lt;a href=&quot;../data&quot;&gt; &lt;code&gt;tf.data&lt;/code&gt; &lt;/a&gt;、私たちは既存の機能を除去する前に非推奨のアドバイスを提供します。</target>
        </trans-unit>
        <trans-unit id="458fef549ca5bb1cdd37d04e9f0b5b8e3b96d46e" translate="yes" xml:space="preserve">
          <source>This must be called by the constructors of subclasses.</source>
          <target state="translated">これはサブクラスのコンストラクタで呼び出されなければなりません。</target>
        </trans-unit>
        <trans-unit id="b854be37a7975d22746ea61f4632ebd3ee101333" translate="yes" xml:space="preserve">
          <source>This must be called by the constructors of subclasses. Note that Optimizer instances should not bind to a single graph, and so shouldn't keep Tensors as member variables. Generally you should be able to use the _set_hyper()/state.get_hyper() facility instead.</source>
          <target state="translated">これはサブクラスのコンストラクタで呼び出されなければなりません。オプティマイザーのインスタンスは単一のグラフにバインドしてはいけないので、テンソルをメンバ変数として保持してはいけないことに注意してください。一般的には、代わりに _set_hyper()/state.get_hyper()を使用することができます。</target>
        </trans-unit>
        <trans-unit id="10ca194e65aab7cdbd21fa158a845dc67377d2ce" translate="yes" xml:space="preserve">
          <source>This must be set before start() is called, otherwise RuntimeError is raised. Its initial value is inherited from the creating thread; the main thread is not a daemon thread and therefore all threads created in the main thread default to daemon = False.</source>
          <target state="translated">これは start()が呼び出される前に設定する必要があり、そうでない場合は RuntimeError が発生します。メインスレッドはデーモンスレッドではないため、メインスレッドで作成されたすべてのスレッドのデフォルトは daemon=False となります。</target>
        </trans-unit>
        <trans-unit id="0329801ef1692f0ddc2ae7e5af20ed6a131c6c7c" translate="yes" xml:space="preserve">
          <source>This only ensures that the data has made its way out of the process without any guarantees on whether it's written to disk. This means that the data would survive an application crash but not necessarily an OS crash.</source>
          <target state="translated">これは、データがディスクに書き込まれているかどうかを保証するものではなく、データがプロセスの外に出たことを保証するだけです。これは、アプリケーションがクラッシュしてもデータが生き残ることを意味しますが、必ずしも OS がクラッシュするとは限りません。</target>
        </trans-unit>
        <trans-unit id="739d09cc347d37887487c132a76071a68cf15e0c" translate="yes" xml:space="preserve">
          <source>This op accepts a ragged tensor with 1 ragged dimension containing only strings and outputs a ragged tensor with 1 ragged dimension containing ngrams of that string, joined along the innermost axis.</source>
          <target state="translated">この演算子は、文字列のみを含む1つのラギング次元を持つラギングテンソルを受け付け、その文字列のngramを含む1つのラギング次元を持つラギングテンソルを、最内軸に沿って結合して出力します。</target>
        </trans-unit>
        <trans-unit id="93e1dc6b2d1103564814280c522ceb3f62da8aaa" translate="yes" xml:space="preserve">
          <source>This op adds entries with the specified &lt;code&gt;default_value&lt;/code&gt; at index &lt;code&gt;[row, 0]&lt;/code&gt; for any row in the input that does not already have a value.</source>
          <target state="translated">この操作は、指定された &lt;code&gt;default_value&lt;/code&gt; を持つエントリを、まだ値を持たない入力の任意の行のインデックス &lt;code&gt;[row, 0]&lt;/code&gt; に追加します。</target>
        </trans-unit>
        <trans-unit id="5fa1114f375b9880e62fbc5a662e7acc5ce57fbe" translate="yes" xml:space="preserve">
          <source>This op also returns an indicator vector shaped &lt;code&gt;[dense_shape[0]]&lt;/code&gt; such that</source>
          <target state="translated">This op also returns an indicator vector shaped &lt;code&gt;[dense_shape[0]]&lt;/code&gt; such that</target>
        </trans-unit>
        <trans-unit id="9c96c116d1d672bbaf2e116ec518227e07309624" translate="yes" xml:space="preserve">
          <source>This op also returns an indicator vector such that</source>
          <target state="translated">このオペランドは、次のようなインジケータベクトルも返します。</target>
        </trans-unit>
        <trans-unit id="63eba777b467e98e8d9a395e0dc5bdd68e038be1" translate="yes" xml:space="preserve">
          <source>This op also supports decoding JPEGs and PNGs, though it is cleaner to use &lt;a href=&quot;../io/decode_image&quot;&gt;&lt;code&gt;tf.io.decode_image&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">This op also supports decoding JPEGs and PNGs, though it is cleaner to use &lt;a href=&quot;../io/decode_image&quot;&gt; &lt;code&gt;tf.io.decode_image&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="f0a295b7a7559c4062aef820bad409706b47254e" translate="yes" xml:space="preserve">
          <source>This op also supports decoding JPEGs and PNGs, though it is cleaner to use &lt;a href=&quot;decode_image&quot;&gt;&lt;code&gt;tf.image.decode_image&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">このopはJPEGとPNGのデコードもサポートしますが、&lt;a href=&quot;decode_image&quot;&gt; &lt;code&gt;tf.image.decode_image&lt;/code&gt; &lt;/a&gt;を使用する方がきれいです。</target>
        </trans-unit>
        <trans-unit id="483bb07454239e8342211e5a15919059fc6155be" translate="yes" xml:space="preserve">
          <source>This op also supports decoding JPEGs and PNGs, though it is cleaner to use &lt;a href=&quot;decode_image&quot;&gt;&lt;code&gt;tf.io.decode_image&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">This op also supports decoding JPEGs and PNGs, though it is cleaner to use &lt;a href=&quot;decode_image&quot;&gt; &lt;code&gt;tf.io.decode_image&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="18fa4a39fc572b40f8f4dacf2470cf5be8ddff15" translate="yes" xml:space="preserve">
          <source>This op also supports decoding JPEGs and non-animated GIFs since the interface is the same, though it is cleaner to use &lt;a href=&quot;../io/decode_image&quot;&gt;&lt;code&gt;tf.io.decode_image&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">This op also supports decoding JPEGs and non-animated GIFs since the interface is the same, though it is cleaner to use &lt;a href=&quot;../io/decode_image&quot;&gt; &lt;code&gt;tf.io.decode_image&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="7b09a5c52da344b1eb6cdb8c06bc391b1939c62f" translate="yes" xml:space="preserve">
          <source>This op also supports decoding JPEGs and non-animated GIFs since the interface is the same, though it is cleaner to use &lt;a href=&quot;decode_image&quot;&gt;&lt;code&gt;tf.image.decode_image&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;decode_image&quot;&gt; &lt;code&gt;tf.image.decode_image&lt;/code&gt; &lt;/a&gt;を使用する方がきれいですが、インターフェイスは同じなので、このopはJPEGおよび非アニメーションGIFのデコードもサポートします。</target>
        </trans-unit>
        <trans-unit id="c9a007b21ccb02db71e5f851437184affd13ed0e" translate="yes" xml:space="preserve">
          <source>This op also supports decoding JPEGs and non-animated GIFs since the interface is the same, though it is cleaner to use &lt;a href=&quot;decode_image&quot;&gt;&lt;code&gt;tf.io.decode_image&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">This op also supports decoding JPEGs and non-animated GIFs since the interface is the same, though it is cleaner to use &lt;a href=&quot;decode_image&quot;&gt; &lt;code&gt;tf.io.decode_image&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="5122fab2d6910f76eb99cdafcfcf3c05b7df8003" translate="yes" xml:space="preserve">
          <source>This op also supports decoding PNGs and non-animated GIFs since the interface is the same, though it is cleaner to use &lt;a href=&quot;../io/decode_image&quot;&gt;&lt;code&gt;tf.io.decode_image&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">This op also supports decoding PNGs and non-animated GIFs since the interface is the same, though it is cleaner to use &lt;a href=&quot;../io/decode_image&quot;&gt; &lt;code&gt;tf.io.decode_image&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="42b9c8de7bcd9a44756c5acb1ef87661725abb7d" translate="yes" xml:space="preserve">
          <source>This op also supports decoding PNGs and non-animated GIFs since the interface is the same, though it is cleaner to use &lt;a href=&quot;decode_image&quot;&gt;&lt;code&gt;tf.image.decode_image&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;decode_image&quot;&gt; &lt;code&gt;tf.image.decode_image&lt;/code&gt; &lt;/a&gt;を使用する方がきれいですが、インターフェイスは同じなので、このopはPNGおよび非アニメーションGIFのデコードもサポートします。</target>
        </trans-unit>
        <trans-unit id="4126fd2328e7484c2f21d905e8ae694800311e37" translate="yes" xml:space="preserve">
          <source>This op also supports decoding PNGs and non-animated GIFs since the interface is the same, though it is cleaner to use &lt;a href=&quot;decode_image&quot;&gt;&lt;code&gt;tf.io.decode_image&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">This op also supports decoding PNGs and non-animated GIFs since the interface is the same, though it is cleaner to use &lt;a href=&quot;decode_image&quot;&gt; &lt;code&gt;tf.io.decode_image&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="fd4491d1a6601d1e84570bcd363e85b0e7d5c12e" translate="yes" xml:space="preserve">
          <source>This op assumes that there is at least one id for each row in the dense tensor represented by sp_ids (i.e. there are no rows with empty features), and that all the indices of sp_ids are in canonical row-major order.</source>
          <target state="translated">この操作は、sp_idsで表される密テンソルの各行に少なくとも1つのidが存在し(すなわち、空の特徴を持つ行は存在しない)、sp_idsのインデックスがすべて正規の行長順であることを前提としています。</target>
        </trans-unit>
        <trans-unit id="ff99bdd028bae5711c127316ae24a743c30a9349" translate="yes" xml:space="preserve">
          <source>This op can be substantially more efficient than &lt;a href=&quot;case&quot;&gt;&lt;code&gt;tf.case&lt;/code&gt;&lt;/a&gt; when exactly one branch will be selected. &lt;a href=&quot;switch_case&quot;&gt;&lt;code&gt;tf.switch_case&lt;/code&gt;&lt;/a&gt; is more like a C++ switch/case statement than &lt;a href=&quot;case&quot;&gt;&lt;code&gt;tf.case&lt;/code&gt;&lt;/a&gt;, which is more like an if/elif/elif/else chain.</source>
          <target state="translated">この&lt;a href=&quot;case&quot;&gt; &lt;code&gt;tf.case&lt;/code&gt; &lt;/a&gt;、1つのブランチのみが選択される場合、tf.caseよりも大幅に効率的になります。&lt;a href=&quot;switch_case&quot;&gt; &lt;code&gt;tf.switch_case&lt;/code&gt; は、&lt;/a&gt;以上のC ++スイッチ/ case文のようなものです&lt;a href=&quot;case&quot;&gt; &lt;code&gt;tf.case&lt;/code&gt; &lt;/a&gt;以上のif / elifの/のelif /他のチェーンのようなものです。</target>
        </trans-unit>
        <trans-unit id="88d4e65ada667e4924bd61aa913d0b719a3489bc" translate="yes" xml:space="preserve">
          <source>This op can be used to override the gradient for complicated functions. For example, suppose y = f(x) and we wish to apply a custom function g for backprop such that dx = g(dy). In Python,</source>
          <target state="translated">この演算子は、複雑な関数の勾配を上書きするために使用することができます。例えば、y=f(x)とし、dx=g(dy)のようなカスタム関数 g を backprop に適用したいとします。Pythonでは。</target>
        </trans-unit>
        <trans-unit id="a70d4bf94e1aa31fec2daa089308a302909ea19e" translate="yes" xml:space="preserve">
          <source>This op collects patches from the input image, as if applying a convolution. All extracted patches are stacked in the depth (last) dimension of the output.</source>
          <target state="translated">この操作は,畳み込みを適用するかのように,入力画像からパッチを収集します.抽出されたすべてのパッチは,出力の深度(最後の)次元にスタックされます.</target>
        </trans-unit>
        <trans-unit id="b607b039f446accd9cc9d66850f0e1a0f18bc805" translate="yes" xml:space="preserve">
          <source>This op consumes a lock created by &lt;code&gt;MutexLock&lt;/code&gt;.</source>
          <target state="translated">This op consumes a lock created by &lt;code&gt;MutexLock&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6c18dad5d5d6899466a10670d53475ca56625c85" translate="yes" xml:space="preserve">
          <source>This op converts between data types, scaling the values appropriately before casting.</source>
          <target state="translated">このオペランドはデータ型間の変換を行い、キャストの前に値を適切にスケーリングします。</target>
        </trans-unit>
        <trans-unit id="cc622534ae3fa62514818ea7bebb60dccd64c26d" translate="yes" xml:space="preserve">
          <source>This op creates a &lt;a href=&quot;https://www.tensorflow.org/code/tensorflow/core/framework/summary.proto&quot;&gt;&lt;code&gt;Summary&lt;/code&gt;&lt;/a&gt; protocol buffer that contains the union of all the values in the input summaries.</source>
          <target state="translated">この操作は、入力サマリーのすべての値の和集合を含む&lt;a href=&quot;https://www.tensorflow.org/code/tensorflow/core/framework/summary.proto&quot;&gt; &lt;code&gt;Summary&lt;/code&gt; &lt;/a&gt;プロトコルバッファーを作成します。</target>
        </trans-unit>
        <trans-unit id="9d0ac8a3b320dffdcce993580747b2ce812c1930" translate="yes" xml:space="preserve">
          <source>This op creates a hash table, specifying the type of its keys and values. Before using the table you will have to initialize it. After initialization the table will be immutable.</source>
          <target state="translated">この操作は、キーと値の型を指定してハッシュテーブルを作成します。テーブルを使う前に、テーブルを初期化する必要があります。初期化後のテーブルは不変です。</target>
        </trans-unit>
        <trans-unit id="656267a02d31eb1fe3e2f93fe32ae0ecba89ac70" translate="yes" xml:space="preserve">
          <source>This op creates a mutable hash table, specifying the type of its keys and values. Each value must be a scalar. Data can be inserted into the table using the insert operations. It does not support the initialization operation.</source>
          <target state="translated">このオペランドは、キーと値の型を指定して変異可能なハッシュテーブルを作成します。各値はスカラでなければなりません。データは挿入操作を使ってテーブルに挿入することができます。初期化操作はサポートしていません。</target>
        </trans-unit>
        <trans-unit id="889ef924ddf97837ebe886303d19b68a45247ddd" translate="yes" xml:space="preserve">
          <source>This op creates a mutable hash table, specifying the type of its keys and values. Each value must be a vector. Data can be inserted into the table using the insert operations. It does not support the initialization operation.</source>
          <target state="translated">このオペランドは、キーと値の型を指定して変異可能なハッシュテーブルを作成します。各値はベクトルでなければなりません。データは挿入操作を用いてテーブルに挿入することができます。初期化操作はサポートしていません。</target>
        </trans-unit>
        <trans-unit id="26981876c06a781e2a944a631697cc4482c0e90e" translate="yes" xml:space="preserve">
          <source>This op cuts a rectangular part out of &lt;code&gt;image&lt;/code&gt;. The top-left corner of the returned image is at &lt;code&gt;offset_height, offset_width&lt;/code&gt; in &lt;code&gt;image&lt;/code&gt;, and its lower-right corner is at &lt;code&gt;offset_height + target_height, offset_width + target_width&lt;/code&gt;.</source>
          <target state="translated">この操作は、 &lt;code&gt;image&lt;/code&gt; から長方形の部分を切り取ります。返された画像の左上隅がである &lt;code&gt;offset_height, offset_width&lt;/code&gt; に &lt;code&gt;image&lt;/code&gt; 、その右下隅はである &lt;code&gt;offset_height + target_height, offset_width + target_width&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b6b4a71613ffb1856f3dff1fb3fb7c9c68b7515a" translate="yes" xml:space="preserve">
          <source>This op decompresses each element of the &lt;code&gt;bytes&lt;/code&gt; input &lt;code&gt;Tensor&lt;/code&gt;, which is assumed to be compressed using the given &lt;code&gt;compression_type&lt;/code&gt;.</source>
          <target state="translated">このOPは、各要素伸張 &lt;code&gt;bytes&lt;/code&gt; 入力 &lt;code&gt;Tensor&lt;/code&gt; 与え使用して圧縮されているものと、 &lt;code&gt;compression_type&lt;/code&gt; を。</target>
        </trans-unit>
        <trans-unit id="3ca6b920060424a35214647a956bfc883925dbdc" translate="yes" xml:space="preserve">
          <source>This op determines the maximum scale_factor that would map the initial [input_min, input_max] range to a range that lies within the representable quantized range.</source>
          <target state="translated">この演算子は、初期の [input_min,input_max]範囲を、表現可能な量子化範囲内にある範囲にマップする最大の scale_factor を決定する。</target>
        </trans-unit>
        <trans-unit id="9e56e06059315b7dda1620664824a84ff8d7bc3c" translate="yes" xml:space="preserve">
          <source>This op does not &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.13.0/user/basics.broadcasting.html&quot;&gt;broadcast&lt;/a&gt; its inputs. If you need broadcasting, use &lt;a href=&quot;add&quot;&gt;&lt;code&gt;tf.math.add&lt;/code&gt;&lt;/a&gt; (or the &lt;code&gt;+&lt;/code&gt; operator) instead.</source>
          <target state="translated">この操作は入力を&lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.13.0/user/basics.broadcasting.html&quot;&gt;ブロードキャスト&lt;/a&gt;しません。ブロードキャストが必要な場合は、代わりに&lt;a href=&quot;add&quot;&gt; &lt;code&gt;tf.math.add&lt;/code&gt; &lt;/a&gt;（または &lt;code&gt;+&lt;/code&gt; 演算子）を使用してください。</target>
        </trans-unit>
        <trans-unit id="32ac8411f8421961cf71053e4e574031251a142f" translate="yes" xml:space="preserve">
          <source>This op does nothing if &lt;code&gt;offset_*&lt;/code&gt; is zero and the image already has size &lt;code&gt;target_height&lt;/code&gt; by &lt;code&gt;target_width&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;offset_*&lt;/code&gt; がゼロであり、画像のサイズがすでに &lt;code&gt;target_height&lt;/code&gt; by &lt;code&gt;target_width&lt;/code&gt; である場合、この操作は何もしません。</target>
        </trans-unit>
        <trans-unit id="59b86b1f9adf8ca0901c6f9e9aeaabfe44733a8c" translate="yes" xml:space="preserve">
          <source>This op exists to consume a tensor created by &lt;code&gt;MutexLock&lt;/code&gt; (other than direct control dependencies). It should be the only that consumes the tensor, and will raise an error if it is not. Its only purpose is to keep the mutex lock tensor alive until it is consumed by this op.</source>
          <target state="translated">This op exists to consume a tensor created by &lt;code&gt;MutexLock&lt;/code&gt; (other than direct control dependencies). It should be the only that consumes the tensor, and will raise an error if it is not. Its only purpose is to keep the mutex lock tensor alive until it is consumed by this op.</target>
        </trans-unit>
        <trans-unit id="fd2475b0227c59a4b9b579ebadb0eb003bb5c048" translate="yes" xml:space="preserve">
          <source>This op expects to receive audio data as an input, stored as floats in the range -1 to 1, together with a window width in samples, and a stride specifying how far to move the window between slices. From this it generates a three dimensional output. The first dimension is for the channels in the input, so a stereo audio input would have two here for example. The second dimension is time, with successive frequency slices. The third dimension has an amplitude value for each frequency during that time slice.</source>
          <target state="translated">このオペランドは、入力としてオーディオデータを受け取ることを想定しており、-1 から 1 の範囲のフロートとして格納されており、サンプル単位でのウィンドウ幅と、スライス間のウィンドウの移動距離を指定するストライドを指定します。これにより、3 次元の出力が生成されます。最初の次元は入力のチャンネル数で、例えばステレオオーディオ入力は2つのチャンネルを持っていることになります。2つ目の次元は時間で、連続した周波数のスライスです。第三の次元は、その時間スライスの間の各周波数の振幅値です。</target>
        </trans-unit>
        <trans-unit id="25438ddc9615e500386687f63662f19536c3cd65" translate="yes" xml:space="preserve">
          <source>This op first slices &lt;code&gt;input&lt;/code&gt; along the dimension &lt;code&gt;batch_axis&lt;/code&gt;, and for each slice &lt;code&gt;i&lt;/code&gt;, reverses the first &lt;code&gt;seq_lengths[i]&lt;/code&gt; elements along the dimension &lt;code&gt;seq_axis&lt;/code&gt;.</source>
          <target state="translated">この &lt;code&gt;batch_axis&lt;/code&gt; 、最初に次元batch_axisに沿って &lt;code&gt;input&lt;/code&gt; スライスし、各スライス &lt;code&gt;i&lt;/code&gt; について、次元seq_axisに沿って最初の &lt;code&gt;seq_lengths[i]&lt;/code&gt; 要素を &lt;code&gt;seq_axis&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="5c2da47231c9225efc906681c480ffa9fdcb8257" translate="yes" xml:space="preserve">
          <source>This op first slices &lt;code&gt;input&lt;/code&gt; along the dimension &lt;code&gt;batch_dim&lt;/code&gt;, and for each slice &lt;code&gt;i&lt;/code&gt;, reverses the first &lt;code&gt;seq_lengths[i]&lt;/code&gt; elements along the dimension &lt;code&gt;seq_dim&lt;/code&gt;.</source>
          <target state="translated">This op first slices &lt;code&gt;input&lt;/code&gt; along the dimension &lt;code&gt;batch_dim&lt;/code&gt; , and for each slice &lt;code&gt;i&lt;/code&gt; , reverses the first &lt;code&gt;seq_lengths[i]&lt;/code&gt; elements along the dimension &lt;code&gt;seq_dim&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4fb605b6d0eb10d714ac2254180881c3166d465a" translate="yes" xml:space="preserve">
          <source>This op implements the CTC loss as presented in (Graves et al., 2006).</source>
          <target state="translated">(Graves et al.,2006)で示されているように、このOPはCTC損失を実装しています。</target>
        </trans-unit>
        <trans-unit id="0d8869736a8a0caa172690fd78df7a0c80acf40c" translate="yes" xml:space="preserve">
          <source>This op implements the CTC loss as presented in (Graves et al., 2016).</source>
          <target state="translated">(Graves et al.,2016)で提示されているように、このopはCTC損失を実装しています。</target>
        </trans-unit>
        <trans-unit id="d7225b3ea22ec4deb1adfd4a695bd1a7623e154b" translate="yes" xml:space="preserve">
          <source>This op implements the CTC loss as presented in the article:</source>
          <target state="translated">このopは、記事で紹介したCTCの損失を実装しています。</target>
        </trans-unit>
        <trans-unit id="6fcde341bc16f91f21275b0c9eb0d836f06faca1" translate="yes" xml:space="preserve">
          <source>This op inserts a single entry for every row that doesn't have any values. The index is created as &lt;code&gt;[row, 0, ..., 0]&lt;/code&gt; and the inserted value is &lt;code&gt;default_value&lt;/code&gt;.</source>
          <target state="translated">This op inserts a single entry for every row that doesn't have any values. The index is created as &lt;code&gt;[row, 0, ..., 0]&lt;/code&gt; and the inserted value is &lt;code&gt;default_value&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2221b86f1776b0a82d12fa22eaebb9f19fcdaeda" translate="yes" xml:space="preserve">
          <source>This op is a convenience wrapper around &lt;code&gt;sparse_to_dense&lt;/code&gt; for &lt;code&gt;SparseTensor&lt;/code&gt;s.</source>
          <target state="translated">この操作は、 &lt;code&gt;sparse_to_dense&lt;/code&gt; の &lt;code&gt;SparseTensor&lt;/code&gt; の便利なラッパーです。</target>
        </trans-unit>
        <trans-unit id="9bcf7c2af4594b54e144cbf824cb1c395a0dff7e" translate="yes" xml:space="preserve">
          <source>This op is being phased out in favor of TensorSummaryV2, which lets callers pass a tag as well as a serialized SummaryMetadata proto string that contains plugin-specific data. We will keep this op to maintain backwards compatibility.</source>
          <target state="translated">この機能は、プラグイン固有のデータを含むシリアル化されたSummaryMetadataプロト文字列だけでなく、タグを渡すことができるTensorSummaryV2を好んで使用するために段階的に廃止されています。後方互換性を維持するために、この拡張子は残しておきます。</target>
        </trans-unit>
        <trans-unit id="498581ecde1f847b44ae5faacdf090686c5a82aa" translate="yes" xml:space="preserve">
          <source>This op is conceptually identical to,</source>
          <target state="translated">このオペは概念的には同じです。</target>
        </trans-unit>
        <trans-unit id="e11c482ba528e17a7aaf9d69ed66f29f71a93708" translate="yes" xml:space="preserve">
          <source>This op is deprecated and will be removed in the future. Prefer &lt;a href=&quot;../nn/batch_normalization&quot;&gt;&lt;code&gt;tf.nn.batch_normalization&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">This op is deprecated and will be removed in the future. Prefer &lt;a href=&quot;../nn/batch_normalization&quot;&gt; &lt;code&gt;tf.nn.batch_normalization&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="939958da045f886ccce510657fd3f21292de978d" translate="yes" xml:space="preserve">
          <source>This op is deprecated. Prefer &lt;a href=&quot;../nn/batch_normalization&quot;&gt;&lt;code&gt;tf.nn.batch_normalization&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">This op is deprecated. Prefer &lt;a href=&quot;../nn/batch_normalization&quot;&gt; &lt;code&gt;tf.nn.batch_normalization&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="d1fddd748b0417b58ea1729816edada8cf15be10" translate="yes" xml:space="preserve">
          <source>This op is deprecated. See &lt;a href=&quot;../../../nn/batch_normalization&quot;&gt;&lt;code&gt;tf.nn.batch_normalization&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この操作は非推奨です。&lt;a href=&quot;../../../nn/batch_normalization&quot;&gt; &lt;code&gt;tf.nn.batch_normalization&lt;/code&gt; を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="faec970c7a84c7f84287e5993964bd296d88974e" translate="yes" xml:space="preserve">
          <source>This op is deprecated. See &lt;a href=&quot;../nn/batch_normalization&quot;&gt;&lt;code&gt;tf.nn.batch_normalization&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">This op is deprecated. See &lt;a href=&quot;../nn/batch_normalization&quot;&gt; &lt;code&gt;tf.nn.batch_normalization&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="350e179bf73709c36862e34c13946cb30d6be41a" translate="yes" xml:space="preserve">
          <source>This op is deprecated. See &lt;a href=&quot;batch_normalization&quot;&gt;&lt;code&gt;tf.nn.batch_normalization&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この操作は非推奨です。&lt;a href=&quot;batch_normalization&quot;&gt; &lt;code&gt;tf.nn.batch_normalization&lt;/code&gt; を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="f5f21db00ede271aa47c92ca1afb2548ebae0215" translate="yes" xml:space="preserve">
          <source>This op is equivalent to applying the normal &lt;a href=&quot;../nn/softmax&quot;&gt;&lt;code&gt;tf.nn.softmax()&lt;/code&gt;&lt;/a&gt; to each innermost logical submatrix with shape &lt;code&gt;[B, C]&lt;/code&gt;, but with the catch that &lt;em&gt;the implicitly zero elements do not participate&lt;/em&gt;. Specifically, the algorithm is equivalent to the following:</source>
          <target state="translated">This op is equivalent to applying the normal &lt;a href=&quot;../nn/softmax&quot;&gt; &lt;code&gt;tf.nn.softmax()&lt;/code&gt; &lt;/a&gt; to each innermost logical submatrix with shape &lt;code&gt;[B, C]&lt;/code&gt; , but with the catch that &lt;em&gt;the implicitly zero elements do not participate&lt;/em&gt;. Specifically, the algorithm is equivalent to the following:</target>
        </trans-unit>
        <trans-unit id="bfe73bfb3165baeb1cd799227e5df39e5edc40e8" translate="yes" xml:space="preserve">
          <source>This op is equivalent to applying the normal &lt;a href=&quot;../nn/softmax&quot;&gt;&lt;code&gt;tf.nn.softmax()&lt;/code&gt;&lt;/a&gt; to each innermost logical submatrix with shape &lt;code&gt;[B, C]&lt;/code&gt;, but with the catch that &lt;em&gt;the implicitly zero elements do not participate&lt;/em&gt;. Specifically, the algorithm is equivalent to:</source>
          <target state="translated">この操作は、通常の&lt;a href=&quot;../nn/softmax&quot;&gt; &lt;code&gt;tf.nn.softmax()&lt;/code&gt; &lt;/a&gt;を形状 &lt;code&gt;[B, C]&lt;/code&gt; 最も内側の各論理サブマトリックスに適用することと同じですが&lt;em&gt;、暗黙的にゼロの要素が関与しない&lt;/em&gt;というキャッチが&lt;em&gt;あります&lt;/em&gt;。具体的には、アルゴリズムは以下と同等です。</target>
        </trans-unit>
        <trans-unit id="9f3c57195c3a48d6087d2de6a616b3e7ac7825fb" translate="yes" xml:space="preserve">
          <source>This op is hidden from public in Python. It is used by TensorFlow Debugger to register gradient tensors for gradient debugging. This op operates on non-reference-type tensors.</source>
          <target state="translated">この演算子はPythonでは非公開です。TensorFlowデバッガでは、グラデーションデバッグのためにグラデーションテンソルを登録するために使用します。このオペランドは非参照型テンソルで動作します。</target>
        </trans-unit>
        <trans-unit id="5208058dc424b56d5683c09cc9ca79f806771d57" translate="yes" xml:space="preserve">
          <source>This op is hidden from public in Python. It is used by TensorFlow Debugger to register gradient tensors for gradient debugging. This op operates on reference-type tensors.</source>
          <target state="translated">この演算子はPythonでは非公開です。TensorFlowデバッガでは、グラデーションデバッグのためにグラデーションテンソルを登録するために使用します。このオペランドは参照型テンソルで動作します。</target>
        </trans-unit>
        <trans-unit id="42f43d3073e8761b09396618e2f19e046d1dc61b" translate="yes" xml:space="preserve">
          <source>This op is meant only for debugging / testing, and its interface is not expected to be stable.</source>
          <target state="translated">このオペアンプはデバッグ/テストのためだけのものであり、そのインターフェイスは安定しているとは期待できません。</target>
        </trans-unit>
        <trans-unit id="cf3e5eda158a5f12c2f2da1b9b93833d5ff71185" translate="yes" xml:space="preserve">
          <source>This op is only defined for complex matrices. If A is positive-definite and real, then casting to a complex matrix, taking the logarithm and casting back to a real matrix will give the correct result.</source>
          <target state="translated">この演算子は複素行列に対してのみ定義されます。A が正定値で実数の場合、複素行列にキャストして対数を取り、実数行列にキャストし直すと正しい結果が得られます。</target>
        </trans-unit>
        <trans-unit id="b4088dd89f372d9134efcda4f21dccb2a4e43e51" translate="yes" xml:space="preserve">
          <source>This op is similar to &lt;code&gt;tf.strings.decode(...)&lt;/code&gt;, but it also returns the start offset for each character in its respective string. This information can be used to align the characters with the original byte sequence.</source>
          <target state="translated">この操作は &lt;code&gt;tf.strings.decode(...)&lt;/code&gt; に似ていますが、それぞれの文字列の各文字の開始オフセットも返します。この情報を使用して、文字を元のバイトシーケンスに揃えることができます。</target>
        </trans-unit>
        <trans-unit id="231193f912eb9ecede37b6d2bd24ac7965dab82e" translate="yes" xml:space="preserve">
          <source>This op is used as a placeholder in If branch functions. It doesn't provide a</source>
          <target state="translated">この op は If ブランチ関数のプレースホルダとして使用されます。これは</target>
        </trans-unit>
        <trans-unit id="30dc65726d5913cc5cf094798e27be8207b68832" translate="yes" xml:space="preserve">
          <source>This op is used during session initialization when a Scaffold is initialized without specifying the local_init_op arg. It includes &lt;a href=&quot;../local_variables_initializer&quot;&gt;&lt;code&gt;tf.compat.v1.local_variables_initializer&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../tables_initializer&quot;&gt;&lt;code&gt;tf.compat.v1.tables_initializer&lt;/code&gt;&lt;/a&gt;, and also initializes local session resources.</source>
          <target state="translated">このopは、local_init_op argを指定せずにScaffoldが初期化されるセッション初期化中に使用されます。これには、&lt;a href=&quot;../local_variables_initializer&quot;&gt; &lt;code&gt;tf.compat.v1.local_variables_initializer&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../tables_initializer&quot;&gt; &lt;code&gt;tf.compat.v1.tables_initializer&lt;/code&gt; が&lt;/a&gt;含まれており、ローカルセッションリソースも初期化します。</target>
        </trans-unit>
        <trans-unit id="27d759b10e3031b72c69cecb21d0a5f2a1e56b50" translate="yes" xml:space="preserve">
          <source>This op is used together with &lt;code&gt;Exit&lt;/code&gt; to create loops in the graph. The unique &lt;code&gt;frame_name&lt;/code&gt; is used by the &lt;code&gt;Executor&lt;/code&gt; to identify frames. If &lt;code&gt;is_constant&lt;/code&gt; is true, &lt;code&gt;output&lt;/code&gt; is a constant in the child frame; otherwise it may be changed in the child frame. At most &lt;code&gt;parallel_iterations&lt;/code&gt; iterations are run in parallel in the child frame.</source>
          <target state="translated">This op is used together with &lt;code&gt;Exit&lt;/code&gt; to create loops in the graph. The unique &lt;code&gt;frame_name&lt;/code&gt; is used by the &lt;code&gt;Executor&lt;/code&gt; to identify frames. If &lt;code&gt;is_constant&lt;/code&gt; is true, &lt;code&gt;output&lt;/code&gt; is a constant in the child frame; otherwise it may be changed in the child frame. At most &lt;code&gt;parallel_iterations&lt;/code&gt; iterations are run in parallel in the child frame.</target>
        </trans-unit>
        <trans-unit id="4d539ed4cc2d3820ae7fed70f08ee95780da8755" translate="yes" xml:space="preserve">
          <source>This op may use some OS-provided source of non-determinism (e.g. an RNG), so each execution will give different results.</source>
          <target state="translated">このopは、OSが提供する非決定性のソース(例えばRNG)を使用する場合がありますので、実行ごとに異なる結果が得られます。</target>
        </trans-unit>
        <trans-unit id="7494eb2e4d00b6f1a2a80a896b2a97c11ea84bbb" translate="yes" xml:space="preserve">
          <source>This op only parses the image header, so it is much faster than DecodeJpeg.</source>
          <target state="translated">この操作は画像のヘッダのみを解析するので、DecodeJpegよりもはるかに高速です。</target>
        </trans-unit>
        <trans-unit id="256678fd9ba7a89e98c94dad29bebb27865a6123" translate="yes" xml:space="preserve">
          <source>This op parses a serialized sequence example into a tuple of dictionaries, each mapping keys to &lt;code&gt;Tensor&lt;/code&gt; and &lt;code&gt;SparseTensor&lt;/code&gt; objects. The first dictionary contains mappings for keys appearing in &lt;code&gt;context_features&lt;/code&gt;, and the second dictionary contains mappings for keys appearing in &lt;code&gt;sequence_features&lt;/code&gt;.</source>
          <target state="translated">このopは、シリアル化されたシーケンスの例を解析して、それぞれが &lt;code&gt;Tensor&lt;/code&gt; オブジェクトと &lt;code&gt;SparseTensor&lt;/code&gt; オブジェクトにキーをマッピングする辞書のタプルにします。最初のディクショナリには、 &lt;code&gt;context_features&lt;/code&gt; に表示されるキーのマッピングが含まれ、2番目のディクショナリには、 &lt;code&gt;sequence_features&lt;/code&gt; に表示されるキーのマッピングが含まれています。</target>
        </trans-unit>
        <trans-unit id="b74d19b6cde7e379b7fc76473e78e58968efe064" translate="yes" xml:space="preserve">
          <source>This op parses serialized examples into a dictionary mapping keys to &lt;code&gt;Tensor&lt;/code&gt;, &lt;code&gt;SparseTensor&lt;/code&gt;, and &lt;code&gt;RaggedTensor&lt;/code&gt; objects. &lt;code&gt;features&lt;/code&gt; is a dict from keys to &lt;code&gt;VarLenFeature&lt;/code&gt;, &lt;code&gt;RaggedFeature&lt;/code&gt;, &lt;code&gt;SparseFeature&lt;/code&gt;, and &lt;code&gt;FixedLenFeature&lt;/code&gt; objects. Each &lt;code&gt;VarLenFeature&lt;/code&gt; and &lt;code&gt;SparseFeature&lt;/code&gt; is mapped to a &lt;code&gt;SparseTensor&lt;/code&gt;; each &lt;code&gt;RaggedFeature&lt;/code&gt; is mapped to a &lt;code&gt;RaggedTensor&lt;/code&gt;; and each &lt;code&gt;FixedLenFeature&lt;/code&gt; is mapped to a &lt;code&gt;Tensor&lt;/code&gt;. See &lt;a href=&quot;../../io/parse_example&quot;&gt;&lt;code&gt;tf.io.parse_example&lt;/code&gt;&lt;/a&gt; for more details about feature dictionaries.</source>
          <target state="translated">この &lt;code&gt;SparseTensor&lt;/code&gt; は、 &lt;code&gt;RaggedTensor&lt;/code&gt; 化された例を解析して、キーを &lt;code&gt;Tensor&lt;/code&gt; 、SparseTensor、およびRaggedTensorオブジェクトにマッピングする辞書に変換します。 &lt;code&gt;features&lt;/code&gt; は、キーから &lt;code&gt;VarLenFeature&lt;/code&gt; 、 &lt;code&gt;RaggedFeature&lt;/code&gt; 、 &lt;code&gt;SparseFeature&lt;/code&gt; 、および &lt;code&gt;FixedLenFeature&lt;/code&gt; オブジェクトへの辞書です。各 &lt;code&gt;VarLenFeature&lt;/code&gt; と &lt;code&gt;SparseFeature&lt;/code&gt; をにマッピングされ &lt;code&gt;SparseTensor&lt;/code&gt; 。各 &lt;code&gt;RaggedFeature&lt;/code&gt; をにマッピングされ &lt;code&gt;RaggedTensor&lt;/code&gt; 。各 &lt;code&gt;FixedLenFeature&lt;/code&gt; は &lt;code&gt;Tensor&lt;/code&gt; にマッピングされます。&lt;a href=&quot;../../io/parse_example&quot;&gt; &lt;code&gt;tf.io.parse_example&lt;/code&gt; を&lt;/a&gt;参照してください 機能辞書の詳細については。</target>
        </trans-unit>
        <trans-unit id="845b399d2e9c5818b169dacff650d84da1b8a72a" translate="yes" xml:space="preserve">
          <source>This op parses serialized examples into a dictionary mapping keys to &lt;code&gt;Tensor&lt;/code&gt;&lt;code&gt;SparseTensor&lt;/code&gt;, and &lt;code&gt;RaggedTensor&lt;/code&gt; objects. &lt;code&gt;features&lt;/code&gt; is a dict from keys to &lt;code&gt;VarLenFeature&lt;/code&gt;, &lt;code&gt;SparseFeature&lt;/code&gt;, &lt;code&gt;RaggedFeature&lt;/code&gt;, and &lt;code&gt;FixedLenFeature&lt;/code&gt; objects. Each &lt;code&gt;VarLenFeature&lt;/code&gt; and &lt;code&gt;SparseFeature&lt;/code&gt; is mapped to a &lt;code&gt;SparseTensor&lt;/code&gt;; each &lt;code&gt;FixedLenFeature&lt;/code&gt; is mapped to a &lt;code&gt;Tensor&lt;/code&gt;; and each &lt;code&gt;RaggedFeature&lt;/code&gt; is mapped to a &lt;code&gt;RaggedTensor&lt;/code&gt;.</source>
          <target state="translated">この &lt;code&gt;SparseTensor&lt;/code&gt; は、 &lt;code&gt;RaggedTensor&lt;/code&gt; 化された例を解析して、キーを &lt;code&gt;Tensor&lt;/code&gt; SparseTensorとRaggedTensorオブジェクトにマッピングする辞書に変換します。 &lt;code&gt;features&lt;/code&gt; は、キーから &lt;code&gt;VarLenFeature&lt;/code&gt; 、 &lt;code&gt;SparseFeature&lt;/code&gt; 、 &lt;code&gt;RaggedFeature&lt;/code&gt; 、および &lt;code&gt;FixedLenFeature&lt;/code&gt; オブジェクトへの辞書です。各 &lt;code&gt;VarLenFeature&lt;/code&gt; と &lt;code&gt;SparseFeature&lt;/code&gt; をにマッピングされ &lt;code&gt;SparseTensor&lt;/code&gt; 。各 &lt;code&gt;FixedLenFeature&lt;/code&gt; は &lt;code&gt;Tensor&lt;/code&gt; にマップされます。各 &lt;code&gt;RaggedFeature&lt;/code&gt; をにマッピングされ &lt;code&gt;RaggedTensor&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="787b46fef668ea2442d8cf59e886173e8f1beeb1" translate="yes" xml:space="preserve">
          <source>This op parses serialized sequence examples into a tuple of dictionaries, each mapping keys to &lt;code&gt;Tensor&lt;/code&gt; and &lt;code&gt;SparseTensor&lt;/code&gt; objects. The first dictionary contains mappings for keys appearing in &lt;code&gt;context_features&lt;/code&gt;, and the second dictionary contains mappings for keys appearing in &lt;code&gt;sequence_features&lt;/code&gt;.</source>
          <target state="translated">この &lt;code&gt;SparseTensor&lt;/code&gt; は、シリアル化されたシーケンスの例を解析して、それぞれが &lt;code&gt;Tensor&lt;/code&gt; オブジェクトとSparseTensorオブジェクトにキーをマッピングする辞書のタプルにします。最初のディクショナリには、 &lt;code&gt;context_features&lt;/code&gt; に表示されるキーのマッピングが含まれ、2番目のディクショナリには、 &lt;code&gt;sequence_features&lt;/code&gt; に表示されるキーのマッピングが含まれています。</target>
        </trans-unit>
        <trans-unit id="4fe7f65a801aad08671f34a64293fcb18c9780f3" translate="yes" xml:space="preserve">
          <source>This op produces Region of Interests from given bounding boxes(bbox_deltas) encoded wrt anchors according to eq.2 in arXiv:1506.01497</source>
          <target state="translated">本論文では、arXiv:1506.01497の方程式2に従ってアンカーを用いてエンコードされたバウンディングボックス(bbox_deltas)から利害関係領域を生成している。</target>
        </trans-unit>
        <trans-unit id="4ca1b1701aa5c064253c44ce1aad741cb653df7b" translate="yes" xml:space="preserve">
          <source>This op reports an &lt;code&gt;InvalidArgument&lt;/code&gt; error if any value is not finite.</source>
          <target state="translated">この操作は、値が有限でない場合、 &lt;code&gt;InvalidArgument&lt;/code&gt; エラーを報告します。</target>
        </trans-unit>
        <trans-unit id="a524bdef26722689a646035ff3a30a89b59c896f" translate="yes" xml:space="preserve">
          <source>This op runs in &lt;code&gt;O(M log M)&lt;/code&gt; time, where &lt;code&gt;M&lt;/code&gt; is the total number of non-empty values across all inputs. This is due to the need for an internal sort in order to concatenate efficiently across an arbitrary dimension.</source>
          <target state="translated">この操作は &lt;code&gt;O(M log M)&lt;/code&gt; 時間で実行されます。ここで、 &lt;code&gt;M&lt;/code&gt; はすべての入力にわたる空でない値の総数です。これは、任意の次元で効率的に連結するために内部ソートが必要なためです。</target>
        </trans-unit>
        <trans-unit id="7aad9bcdb175c316d0cd0c518023c08cbf3d7ccf" translate="yes" xml:space="preserve">
          <source>This op simply returns its first input, which is assumed to have been sliced from the Tensors returned by TPUEmbeddingDequeueActivations. The presence of this op, and its first argument being a trainable Variable, enables automatic differentiation of graphs containing embeddings via the TPU Embedding Python libraries.</source>
          <target state="translated">このオペランドは、TPUEmbeddingDequeueActivationsによって返されたテンソルからスライスされたと仮定された最初の入力を返すだけです。このopが存在し、その第一引数が訓練可能な変数であることで、TPU Embedding Pythonライブラリを介してエンベッディングを含むグラフを自動的に区別することができます。</target>
        </trans-unit>
        <trans-unit id="d483631861e7a19423d30b1c89ca7bd9af9deb77" translate="yes" xml:space="preserve">
          <source>This op simulates the precision loss from the quantized forward pass by:</source>
          <target state="translated">この演算子は、量子化されたフォワードパスによる精度損失をシミュレートします。</target>
        </trans-unit>
        <trans-unit id="82f92515415e66dd8fe55e82e86a429d52767b5f" translate="yes" xml:space="preserve">
          <source>This op takes an N-dimensional &lt;code&gt;Tensor&lt;/code&gt;, &lt;code&gt;RaggedTensor&lt;/code&gt;, or &lt;code&gt;SparseTensor&lt;/code&gt;, and returns an N-dimensional int64 SparseTensor where element &lt;code&gt;[i0...i[axis], j]&lt;/code&gt; contains the number of times the value &lt;code&gt;j&lt;/code&gt; appears in slice &lt;code&gt;[i0...i[axis], :]&lt;/code&gt; of the input tensor. Currently, only N=0 and N=-1 are supported.</source>
          <target state="translated">This op takes an N-dimensional &lt;code&gt;Tensor&lt;/code&gt; , &lt;code&gt;RaggedTensor&lt;/code&gt; , or &lt;code&gt;SparseTensor&lt;/code&gt; , and returns an N-dimensional int64 SparseTensor where element &lt;code&gt;[i0...i[axis], j]&lt;/code&gt; contains the number of times the value &lt;code&gt;j&lt;/code&gt; appears in slice &lt;code&gt;[i0...i[axis], :]&lt;/code&gt; of the input tensor. Currently, only N=0 and N=-1 are supported.</target>
        </trans-unit>
        <trans-unit id="ad5fa7632826618c2d76f2d4a4592c97b627433a" translate="yes" xml:space="preserve">
          <source>This op takes in the upstream gradient w.r.t. non-empty values of the sliced &lt;code&gt;SparseTensor&lt;/code&gt;, and outputs the gradients w.r.t. the non-empty values of input &lt;code&gt;SparseTensor&lt;/code&gt;.</source>
          <target state="translated">This op takes in the upstream gradient w.r.t. non-empty values of the sliced &lt;code&gt;SparseTensor&lt;/code&gt; , and outputs the gradients w.r.t. the non-empty values of input &lt;code&gt;SparseTensor&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="edecba4e86376242d273ba622ca63b2965a5a438" translate="yes" xml:space="preserve">
          <source>This op translates a tensor containing Example records, encoded using the &lt;a href=&quot;https://developers.google.com/protocol-buffers/docs/proto3#json&quot;&gt;standard JSON mapping&lt;/a&gt;, into a tensor containing the same records encoded as binary protocol buffers. The resulting tensor can then be fed to any of the other Example-parsing ops.</source>
          <target state="translated">この演算は、&lt;a href=&quot;https://developers.google.com/protocol-buffers/docs/proto3#json&quot;&gt;標準のJSONマッピング&lt;/a&gt;を使用してエンコードされたサンプルレコードを含むテンソルを、バイナリプロトコルバッファーとしてエンコードされた同じレコードを含むテンソルに変換します。結果のテンソルは、他の例を解析する演算のいずれかに供給することができます。</target>
        </trans-unit>
        <trans-unit id="aed6dcb7e60458715d6ef5c3c8eddc95029d6141" translate="yes" xml:space="preserve">
          <source>This op uses the algorithm by Marsaglia et al. to acquire samples via transformation-rejection from pairs of uniform and normal random variables. See &lt;a href=&quot;http://dl.acm.org/citation.cfm?id=358414&quot;&gt;http://dl.acm.org/citation.cfm?id=358414&lt;/a&gt;</source>
          <target state="translated">This op uses the algorithm by Marsaglia et al. to acquire samples via transformation-rejection from pairs of uniform and normal random variables. See &lt;a href=&quot;http://dl.acm.org/citation.cfm?id=358414&quot;&gt;http://dl.acm.org/citation.cfm?id=358414&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c381caf80ba3167793d4166edbbb6bfbc8d1b9b9" translate="yes" xml:space="preserve">
          <source>This op uses two algorithms, depending on rate. If rate &amp;gt;= 10, then the algorithm by Hormann is used to acquire samples via transformation-rejection. See &lt;a href=&quot;http://www.sciencedirect.com/science/article/pii/0167668793909974&quot;&gt;http://www.sciencedirect.com/science/article/pii/0167668793909974&lt;/a&gt;</source>
          <target state="translated">This op uses two algorithms, depending on rate. If rate &amp;gt;= 10, then the algorithm by Hormann is used to acquire samples via transformation-rejection. See &lt;a href=&quot;http://www.sciencedirect.com/science/article/pii/0167668793909974&quot;&gt;http://www.sciencedirect.com/science/article/pii/0167668793909974&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="49b534f6ddaaf2bd4e7772b31b4be9cf92fcfbd7" translate="yes" xml:space="preserve">
          <source>This operation blocks until that finishes.</source>
          <target state="translated">この操作は、それが終了するまでブロックされます。</target>
        </trans-unit>
        <trans-unit id="14d876872d62a220ab5753fd3b852a5a6bcb76ef" translate="yes" xml:space="preserve">
          <source>This operation can be used with &lt;code&gt;output_encoding = input_encoding&lt;/code&gt; to enforce correct formatting for inputs even if they are already in the desired encoding.</source>
          <target state="translated">この操作を &lt;code&gt;output_encoding = input_encoding&lt;/code&gt; と一緒に使用して、入力がすでに目的のエンコーディングである場合でも、入力に正しいフォーマットを適用できます。</target>
        </trans-unit>
        <trans-unit id="bf8af72c7ec5c03a0a302901ae0b02f8840934f4" translate="yes" xml:space="preserve">
          <source>This operation computes</source>
          <target state="translated">この操作は</target>
        </trans-unit>
        <trans-unit id="df2c8f127a35805203dd552ccd88657669212f89" translate="yes" xml:space="preserve">
          <source>This operation computes the inverse of an index permutation. It takes a 1-D integer tensor &lt;code&gt;x&lt;/code&gt;, which represents the indices of a zero-based array, and swaps each value with its index position. In other words, for an output tensor &lt;code&gt;y&lt;/code&gt; and an input tensor &lt;code&gt;x&lt;/code&gt;, this operation computes the following:</source>
          <target state="translated">この操作は、インデックス順列の逆を計算します。これは、ゼロベースの配列のインデックスを表す1次元整数テンソル &lt;code&gt;x&lt;/code&gt; を取り、各値をそのインデックス位置と交換します。言い換えると、出力テンソル &lt;code&gt;y&lt;/code&gt; と入力テンソル &lt;code&gt;x&lt;/code&gt; の場合、この演算は以下を計算します。</target>
        </trans-unit>
        <trans-unit id="9ce96baa1d2aec98a8f7f3b28803c0d5bf74ec4e" translate="yes" xml:space="preserve">
          <source>This operation concatenates completed-element component tensors along the 0th dimension to make a single component tensor.</source>
          <target state="translated">この演算は,0次元に沿った完全要素成分テンソルを連結して,1つの成分テンソルを作成します.</target>
        </trans-unit>
        <trans-unit id="d8b4d24b16bc4a84c7216a06caa8665f602e4b2d" translate="yes" xml:space="preserve">
          <source>This operation concatenates queue-element component tensors along the 0th dimension to make a single component tensor. All of the components in the dequeued tuple will have size &lt;code&gt;n&lt;/code&gt; in the 0th dimension.</source>
          <target state="translated">この演算は、0番目の次元に沿ってキュー要素コンポーネントテンソルを連結して、単一のコンポーネントテンソルを作成します。デキューされたタプルのすべてのコンポーネントは、0番目の次元でサイズ &lt;code&gt;n&lt;/code&gt; になります。</target>
        </trans-unit>
        <trans-unit id="45d38aafbd1acaa44920f79c8c0c3ecc6bbcdeda" translate="yes" xml:space="preserve">
          <source>This operation concatenates queue-element component tensors along the 0th dimension to make a single component tensor. All of the components in the dequeued tuple will have size n in the 0th dimension.</source>
          <target state="translated">この操作は,キュー要素の成分テンソルを 0 次元に沿って連結して,単一の成分テンソルを作成します.デキューされたタプル内のすべての成分は,0次元目のサイズnを持つことになります.</target>
        </trans-unit>
        <trans-unit id="50e9d3be55bb6834daac8ca12d0b390851428378" translate="yes" xml:space="preserve">
          <source>This operation concatenates queue-element component tensors along the 0th dimension to make a single component tensor. If the queue has not been closed, all of the components in the dequeued tuple will have size &lt;code&gt;n&lt;/code&gt; in the 0th dimension.</source>
          <target state="translated">この演算は、0番目の次元に沿ってキュー要素コンポーネントテンソルを連結して、単一のコンポーネントテンソルを作成します。キューが閉じられていない場合、デキューされたタプルのすべてのコンポーネントは、0番目の次元でサイズ &lt;code&gt;n&lt;/code&gt; になります。</target>
        </trans-unit>
        <trans-unit id="15bf39234c37f046f148fb34f3d92a5f21991cd5" translate="yes" xml:space="preserve">
          <source>This operation converts Unicode code points to script codes corresponding to each code point. Script codes correspond to International Components for Unicode (ICU) UScriptCode values. See &lt;a href=&quot;http://icu-project.org/apiref/icu4c/uscript_8h.html&quot;&gt;http://icu-project.org/apiref/icu4c/uscript_8h.html&lt;/a&gt; Returns -1 (USCRIPT_INVALID_CODE) for invalid codepoints. Output shape will match input shape.</source>
          <target state="translated">This operation converts Unicode code points to script codes corresponding to each code point. Script codes correspond to International Components for Unicode (ICU) UScriptCode values. See &lt;a href=&quot;http://icu-project.org/apiref/icu4c/uscript_8h.html&quot;&gt;http://icu-project.org/apiref/icu4c/uscript_8h.html&lt;/a&gt; Returns -1 (USCRIPT_INVALID_CODE) for invalid codepoints. Output shape will match input shape.</target>
        </trans-unit>
        <trans-unit id="45295c6769989505efcf8c49b52125eb620acebf" translate="yes" xml:space="preserve">
          <source>This operation converts Unicode code points to script codes corresponding to each code point. Script codes correspond to International Components for Unicode (ICU) UScriptCode values. See http://icu-project.org/apiref/icu4c/uscript_8h.html. Returns -1 (USCRIPT_INVALID_CODE) for invalid codepoints. Output shape will match input shape.</source>
          <target state="translated">こ の操作は、 Unicode コ ー ド 点を、 各 コ ー ド 点に対応す る ス ク リ プ ト コ ー ド に変換 し ます。ス ク リ プ ト コ ー ド は、International Components for Unicode (ICU)UScriptCode 値に対応しています。http://icu-project.org/apiref/icu4c/uscript_8h.html を参照してください。無効なコードポイントに対しては -1 (USCRIPT_INVALID_CODE)を返します。出力形状は入力形状と一致します。</target>
        </trans-unit>
        <trans-unit id="46e590d89bb172f52098449de9dab107e8dbb7d2" translate="yes" xml:space="preserve">
          <source>This operation corresponds to &lt;code&gt;numpy.tensordot(a, b, axes)&lt;/code&gt;.</source>
          <target state="translated">この操作は &lt;code&gt;numpy.tensordot(a, b, axes)&lt;/code&gt; 対応します。</target>
        </trans-unit>
        <trans-unit id="11cc84360970a3caa94b4965487c085edd1841b7" translate="yes" xml:space="preserve">
          <source>This operation creates a new tensor by adding sparse &lt;code&gt;updates&lt;/code&gt; to the passed in &lt;code&gt;tensor&lt;/code&gt;. This operation is very similar to &lt;code&gt;tf.scatter_nd_add&lt;/code&gt;, except that the updates are added onto an existing tensor (as opposed to a variable). If the memory for the existing tensor cannot be re-used, a copy is made and updated.</source>
          <target state="translated">この操作では、渡された &lt;code&gt;tensor&lt;/code&gt; スパース &lt;code&gt;updates&lt;/code&gt; を追加して、新しいテンソルを作成します。この操作は &lt;code&gt;tf.scatter_nd_add&lt;/code&gt; と非常に似ていますが、更新が（変数ではなく）既存のテンソルに追加される点が異なります。既存のテンソルのメモリを再利用できない場合は、コピーが作成されて更新されます。</target>
        </trans-unit>
        <trans-unit id="ffa4c89af08b8794e18efa910261002f2ad8a60e" translate="yes" xml:space="preserve">
          <source>This operation creates a new tensor by applying sparse &lt;code&gt;updates&lt;/code&gt; to the passed in &lt;code&gt;tensor&lt;/code&gt;. This operation is very similar to &lt;a href=&quot;../scatter_nd&quot;&gt;&lt;code&gt;tf.scatter_nd&lt;/code&gt;&lt;/a&gt;, except that the updates are scattered onto an existing tensor (as opposed to a zero-tensor). If the memory for the existing tensor cannot be re-used, a copy is made and updated.</source>
          <target state="translated">This operation creates a new tensor by applying sparse &lt;code&gt;updates&lt;/code&gt; to the passed in &lt;code&gt;tensor&lt;/code&gt; . This operation is very similar to &lt;a href=&quot;../scatter_nd&quot;&gt; &lt;code&gt;tf.scatter_nd&lt;/code&gt; &lt;/a&gt;, except that the updates are scattered onto an existing tensor (as opposed to a zero-tensor). If the memory for the existing tensor cannot be re-used, a copy is made and updated.</target>
        </trans-unit>
        <trans-unit id="c390e65b4cc57f97f7e73aea3a4e81f629906485" translate="yes" xml:space="preserve">
          <source>This operation creates a new tensor by applying sparse &lt;code&gt;updates&lt;/code&gt; to the passed in &lt;code&gt;tensor&lt;/code&gt;. This operation is very similar to &lt;a href=&quot;scatter_nd&quot;&gt;&lt;code&gt;tf.scatter_nd&lt;/code&gt;&lt;/a&gt;, except that the updates are scattered onto an existing tensor (as opposed to a zero-tensor). If the memory for the existing tensor cannot be re-used, a copy is made and updated.</source>
          <target state="translated">この操作は、渡された &lt;code&gt;tensor&lt;/code&gt; スパース &lt;code&gt;updates&lt;/code&gt; を適用することにより、新しいテンソルを作成します。この操作は&lt;a href=&quot;scatter_nd&quot;&gt; &lt;code&gt;tf.scatter_nd&lt;/code&gt; &lt;/a&gt;と非常に似ていますが、更新が（ゼロテンソルではなく）既存のテンソルに分散される点が異なります。既存のテンソルのメモリを再利用できない場合は、コピーが作成されて更新されます。</target>
        </trans-unit>
        <trans-unit id="35ada26abd351b9c5bf627e9862c2252c700b1b5" translate="yes" xml:space="preserve">
          <source>This operation creates a new tensor by replicating &lt;code&gt;input&lt;/code&gt;&lt;code&gt;multiples&lt;/code&gt; times. The output tensor's i'th dimension has &lt;code&gt;input.dims(i) * multiples[i]&lt;/code&gt; elements, and the values of &lt;code&gt;input&lt;/code&gt; are replicated &lt;code&gt;multiples[i]&lt;/code&gt; times along the 'i'th dimension. For example, tiling &lt;code&gt;[a b c d]&lt;/code&gt; by &lt;code&gt;[2]&lt;/code&gt; produces &lt;code&gt;[a b c d a b c d]&lt;/code&gt;.</source>
          <target state="translated">この操作は、 &lt;code&gt;input&lt;/code&gt; &lt;code&gt;multiples&lt;/code&gt; 回複製して新しいテンソルを作成します。出力テンソルのi番目の次元には &lt;code&gt;input.dims(i) * multiples[i]&lt;/code&gt; 要素があり、 &lt;code&gt;input&lt;/code&gt; の値はi番目の次元に沿って &lt;code&gt;multiples[i]&lt;/code&gt; 回複製されます。たとえば、 &lt;code&gt;[a b c d]&lt;/code&gt; を &lt;code&gt;[2]&lt;/code&gt; でタイリングすると、 &lt;code&gt;[a b c d a b c d]&lt;/code&gt; 生成されます。</target>
        </trans-unit>
        <trans-unit id="5c90c8c96fbb8b355bef6addc97e2ca668679eab" translate="yes" xml:space="preserve">
          <source>This operation creates a new tensor by subtracting sparse &lt;code&gt;updates&lt;/code&gt; from the passed in &lt;code&gt;tensor&lt;/code&gt;. This operation is very similar to &lt;code&gt;tf.scatter_nd_sub&lt;/code&gt;, except that the updates are subtracted from an existing tensor (as opposed to a variable). If the memory for the existing tensor cannot be re-used, a copy is made and updated.</source>
          <target state="translated">この操作では、渡された &lt;code&gt;tensor&lt;/code&gt; からスパース &lt;code&gt;updates&lt;/code&gt; を差し引くことにより、新しいテンソルが作成されます。この操作は &lt;code&gt;tf.scatter_nd_sub&lt;/code&gt; と非常に似ていますが、更新が（変数ではなく）既存のテンソルから減算される点が異なります。既存のテンソルのメモリを再利用できない場合は、コピーが作成されて更新されます。</target>
        </trans-unit>
        <trans-unit id="52687eaf04e092c6367552afd7b0ecbe304d63d1" translate="yes" xml:space="preserve">
          <source>This operation creates a sequence of numbers that begins at &lt;code&gt;start&lt;/code&gt; and extends by increments of &lt;code&gt;delta&lt;/code&gt; up to but not including &lt;code&gt;limit&lt;/code&gt;.</source>
          <target state="translated">This operation creates a sequence of numbers that begins at &lt;code&gt;start&lt;/code&gt; and extends by increments of &lt;code&gt;delta&lt;/code&gt; up to but not including &lt;code&gt;limit&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="92df0de1d5e9953fcab8fedab1e1918021371c50" translate="yes" xml:space="preserve">
          <source>This operation creates a tensor of &lt;code&gt;shape&lt;/code&gt; and &lt;code&gt;dtype&lt;/code&gt;.</source>
          <target state="translated">This operation creates a tensor of &lt;code&gt;shape&lt;/code&gt; and &lt;code&gt;dtype&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0aaf5e994752ce058c39711d4638a06e40443f56" translate="yes" xml:space="preserve">
          <source>This operation creates a tensor of shape &lt;code&gt;dims&lt;/code&gt; and fills it with &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">この操作は、形状を &lt;code&gt;dims&lt;/code&gt; するテンソルを作成し、それを &lt;code&gt;value&lt;/code&gt; で埋めます。</target>
        </trans-unit>
        <trans-unit id="2acd7b755c2b5e055f5081527ae8768ab15af691" translate="yes" xml:space="preserve">
          <source>This operation divides &quot;spatial&quot; dimensions &lt;code&gt;[1, ..., M]&lt;/code&gt; of the input into a grid of blocks of shape &lt;code&gt;block_shape&lt;/code&gt;, and interleaves these blocks with the &quot;batch&quot; dimension (0) such that in the output, the spatial dimensions &lt;code&gt;[1, ..., M]&lt;/code&gt; correspond to the position within the grid, and the batch dimension combines both the position within a spatial block and the original batch position. Prior to division into blocks, the spatial dimensions of the input are optionally zero padded according to &lt;code&gt;paddings&lt;/code&gt;. See below for a precise description.</source>
          <target state="translated">この操作は、入力の「空間」次元 &lt;code&gt;[1, ..., M]&lt;/code&gt; を形状 &lt;code&gt;block_shape&lt;/code&gt; のブロックのグリッドに分割し、これらのブロックを「バッチ」次元（0）でインターリーブして、出力で空間次元が &lt;code&gt;[1, ..., M]&lt;/code&gt; はグリッド内の位置に対応し、バッチディメンションは空間ブロック内の位置と元のバッチ位置の両方を組み合わせます。ブロックへの分割の前に、入力の次元空間は、必要に応じてゼロに応じて埋め込まれ &lt;code&gt;paddings&lt;/code&gt; 。正確な説明については、以下を参照してください。</target>
        </trans-unit>
        <trans-unit id="41e0f15b392354d26d2756845f1cfcd72200eb6d" translate="yes" xml:space="preserve">
          <source>This operation either returns a tensor &lt;code&gt;y&lt;/code&gt; containing unique elements along the &lt;code&gt;axis&lt;/code&gt; of a tensor. The returned unique elements is sorted in the same order as they occur along &lt;code&gt;axis&lt;/code&gt; in &lt;code&gt;x&lt;/code&gt;. This operation also returns a tensor &lt;code&gt;idx&lt;/code&gt; and a tensor &lt;code&gt;count&lt;/code&gt; that are the same size as the number of the elements in &lt;code&gt;x&lt;/code&gt; along the &lt;code&gt;axis&lt;/code&gt; dimension. The &lt;code&gt;idx&lt;/code&gt; contains the index in the unique output &lt;code&gt;y&lt;/code&gt; and the &lt;code&gt;count&lt;/code&gt; contains the count in the unique output &lt;code&gt;y&lt;/code&gt;. In other words, for an &lt;code&gt;1-D&lt;/code&gt; tensor &lt;code&gt;x&lt;/code&gt; with `axis = None:</source>
          <target state="translated">This operation either returns a tensor &lt;code&gt;y&lt;/code&gt; containing unique elements along the &lt;code&gt;axis&lt;/code&gt; of a tensor. The returned unique elements is sorted in the same order as they occur along &lt;code&gt;axis&lt;/code&gt; in &lt;code&gt;x&lt;/code&gt; . This operation also returns a tensor &lt;code&gt;idx&lt;/code&gt; and a tensor &lt;code&gt;count&lt;/code&gt; that are the same size as the number of the elements in &lt;code&gt;x&lt;/code&gt; along the &lt;code&gt;axis&lt;/code&gt; dimension. The &lt;code&gt;idx&lt;/code&gt; contains the index in the unique output &lt;code&gt;y&lt;/code&gt; and the &lt;code&gt;count&lt;/code&gt; contains the count in the unique output &lt;code&gt;y&lt;/code&gt; . In other words, for an &lt;code&gt;1-D&lt;/code&gt; tensor &lt;code&gt;x&lt;/code&gt; with `axis = None:</target>
        </trans-unit>
        <trans-unit id="2fb9300ba4c7f909238dc4fbd9e13292c10f4740" translate="yes" xml:space="preserve">
          <source>This operation either returns a tensor &lt;code&gt;y&lt;/code&gt; containing unique elements along the &lt;code&gt;axis&lt;/code&gt; of a tensor. The returned unique elements is sorted in the same order as they occur along &lt;code&gt;axis&lt;/code&gt; in &lt;code&gt;x&lt;/code&gt;. This operation also returns a tensor &lt;code&gt;idx&lt;/code&gt; that is the same size as the number of the elements in &lt;code&gt;x&lt;/code&gt; along the &lt;code&gt;axis&lt;/code&gt; dimension. It contains the index in the unique output &lt;code&gt;y&lt;/code&gt;. In other words, for an &lt;code&gt;1-D&lt;/code&gt; tensor &lt;code&gt;x&lt;/code&gt; with `axis = None:</source>
          <target state="translated">This operation either returns a tensor &lt;code&gt;y&lt;/code&gt; containing unique elements along the &lt;code&gt;axis&lt;/code&gt; of a tensor. The returned unique elements is sorted in the same order as they occur along &lt;code&gt;axis&lt;/code&gt; in &lt;code&gt;x&lt;/code&gt; . This operation also returns a tensor &lt;code&gt;idx&lt;/code&gt; that is the same size as the number of the elements in &lt;code&gt;x&lt;/code&gt; along the &lt;code&gt;axis&lt;/code&gt; dimension. It contains the index in the unique output &lt;code&gt;y&lt;/code&gt; . In other words, for an &lt;code&gt;1-D&lt;/code&gt; tensor &lt;code&gt;x&lt;/code&gt; with `axis = None:</target>
        </trans-unit>
        <trans-unit id="a631f52c0283f6c97e9168ae9c2c1920fc673e57" translate="yes" xml:space="preserve">
          <source>This operation ensures the underlying data memory is ready when returns.</source>
          <target state="translated">この操作は、リターン時に基礎となるデータメモリの準備ができていることを確認します。</target>
        </trans-unit>
        <trans-unit id="5d3e7305e25146c306e9ca9dac7912d7b2d4ded2" translate="yes" xml:space="preserve">
          <source>This operation extracts a slice of size &lt;code&gt;size&lt;/code&gt; from a tensor &lt;code&gt;input_&lt;/code&gt; starting at the location specified by &lt;code&gt;begin&lt;/code&gt;. The slice &lt;code&gt;size&lt;/code&gt; is represented as a tensor shape, where &lt;code&gt;size[i]&lt;/code&gt; is the number of elements of the 'i'th dimension of &lt;code&gt;input_&lt;/code&gt; that you want to slice. The starting location (&lt;code&gt;begin&lt;/code&gt;) for the slice is represented as an offset in each dimension of &lt;code&gt;input_&lt;/code&gt;. In other words, &lt;code&gt;begin[i]&lt;/code&gt; is the offset into the i'th dimension of &lt;code&gt;input_&lt;/code&gt; that you want to slice from.</source>
          <target state="translated">この操作は、 &lt;code&gt;begin&lt;/code&gt; で指定された場所から始まるテンソル &lt;code&gt;input_&lt;/code&gt; からサイズ &lt;code&gt;size&lt;/code&gt; のスライスを抽出します。スライス &lt;code&gt;size&lt;/code&gt; はテンソル形状として表されます。ここで、 &lt;code&gt;size[i]&lt;/code&gt; は、スライスする &lt;code&gt;input_&lt;/code&gt; のi番目の次元の要素の数です。スライスの開始位置（ &lt;code&gt;begin&lt;/code&gt; ）は、 &lt;code&gt;input_&lt;/code&gt; の各次元のオフセットとして表されます。つまり、 &lt;code&gt;begin[i]&lt;/code&gt; は、スライス &lt;code&gt;input_&lt;/code&gt; となるinput_のi番目の次元へのオフセットです。</target>
        </trans-unit>
        <trans-unit id="29ab911f3d597d49d14cf454f1533a4b19e5e15b" translate="yes" xml:space="preserve">
          <source>This operation extracts the specified region from the tensor. The notation is similar to NumPy with the restriction that currently only support basic indexing. That means that using a non-scalar tensor as input is not currently allowed.</source>
          <target state="translated">この操作はテンソルから指定された領域を抽出します。表記法はNumPyに似ていますが、現在のところ基本的なインデックス付けしかサポートしていません。つまり、入力として非スカラーテンソルを使用することは現在のところ許可されていません。</target>
        </trans-unit>
        <trans-unit id="c488d4bcca92a0ac54244fdbb1f9925da2e5d927" translate="yes" xml:space="preserve">
          <source>This operation folds the padded areas of &lt;code&gt;input&lt;/code&gt; by &lt;code&gt;MirrorPad&lt;/code&gt; according to the &lt;code&gt;paddings&lt;/code&gt; you specify. &lt;code&gt;paddings&lt;/code&gt; must be the same as &lt;code&gt;paddings&lt;/code&gt; argument given to the corresponding &lt;code&gt;MirrorPad&lt;/code&gt; op.</source>
          <target state="translated">This operation folds the padded areas of &lt;code&gt;input&lt;/code&gt; by &lt;code&gt;MirrorPad&lt;/code&gt; according to the &lt;code&gt;paddings&lt;/code&gt; you specify. &lt;code&gt;paddings&lt;/code&gt; must be the same as &lt;code&gt;paddings&lt;/code&gt; argument given to the corresponding &lt;code&gt;MirrorPad&lt;/code&gt; op.</target>
        </trans-unit>
        <trans-unit id="2f4879a7545e74fa85acacd4cf01d74137ecf234" translate="yes" xml:space="preserve">
          <source>This operation has &lt;code&gt;k&lt;/code&gt; outputs, where &lt;code&gt;k&lt;/code&gt; is the number of components in the tuples stored in the given queue, and output &lt;code&gt;i&lt;/code&gt; is the ith component of the dequeued tuple.</source>
          <target state="translated">This operation has &lt;code&gt;k&lt;/code&gt; outputs, where &lt;code&gt;k&lt;/code&gt; is the number of components in the tuples stored in the given queue, and output &lt;code&gt;i&lt;/code&gt; is the ith component of the dequeued tuple.</target>
        </trans-unit>
        <trans-unit id="2d3ec2c39ae0a5c24c1de4e22eea70e184fc371a" translate="yes" xml:space="preserve">
          <source>This operation has a gradient and thus allows for training &lt;code&gt;min&lt;/code&gt; and &lt;code&gt;max&lt;/code&gt; values.</source>
          <target state="translated">この操作は、勾配を有するため、トレーニングを可能 &lt;code&gt;min&lt;/code&gt; および &lt;code&gt;max&lt;/code&gt; 値。</target>
        </trans-unit>
        <trans-unit id="ac2e08c9a87871e0d33d02bc30d3bfc7e328d76d" translate="yes" xml:space="preserve">
          <source>This operation has k outputs, where &lt;code&gt;k&lt;/code&gt; is the number of components in the tuples stored in the given queue, and output &lt;code&gt;i&lt;/code&gt; is the ith component of the dequeued tuple.</source>
          <target state="translated">This operation has k outputs, where &lt;code&gt;k&lt;/code&gt; is the number of components in the tuples stored in the given queue, and output &lt;code&gt;i&lt;/code&gt; is the ith component of the dequeued tuple.</target>
        </trans-unit>
        <trans-unit id="701111c6d7bceddee66d3b31a146ad5d2ba5dd35" translate="yes" xml:space="preserve">
          <source>This operation has k outputs, where k is the number of components in the tuples stored in the given queue, and output i is the ith component of the dequeued tuple.</source>
          <target state="translated">この操作は、k個の出力を持ち、ここでkは与えられたキューに格納されているタプルの構成要素の数であり、出力iは、dequeuedされたタプルの第i番目の構成要素である。</target>
        </trans-unit>
        <trans-unit id="b78d17d35c34babe04bca7ab5360f7b9d4aad4d2" translate="yes" xml:space="preserve">
          <source>This operation has the same semantics as &lt;code&gt;reshape&lt;/code&gt; on the represented dense tensor. The indices of non-empty values in &lt;code&gt;sp_input&lt;/code&gt; are recomputed based on the new dense shape, and a new &lt;code&gt;SparseTensor&lt;/code&gt; is returned containing the new indices and new shape. The order of non-empty values in &lt;code&gt;sp_input&lt;/code&gt; is unchanged.</source>
          <target state="translated">この操作は、表現された密なテンソルの &lt;code&gt;reshape&lt;/code&gt; と同じセマンティクスを持っています。 &lt;code&gt;sp_input&lt;/code&gt; の空でない値のインデックスは、新しい密な形状に基づいて再計算され、新しいインデックスと新しい形状を含む新しい &lt;code&gt;SparseTensor&lt;/code&gt; が返されます。 &lt;code&gt;sp_input&lt;/code&gt; の空でない値の順序は変更されていません。</target>
        </trans-unit>
        <trans-unit id="920eea1003570a2934a5442842f0411a9537123b" translate="yes" xml:space="preserve">
          <source>This operation has the same semantics as reshape on the represented dense tensor. The &lt;code&gt;input_indices&lt;/code&gt; are recomputed based on the requested &lt;code&gt;new_shape&lt;/code&gt;.</source>
          <target state="translated">This operation has the same semantics as reshape on the represented dense tensor. The &lt;code&gt;input_indices&lt;/code&gt; are recomputed based on the requested &lt;code&gt;new_shape&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f987eeda9053c7636415898332c77d1e39acd9d4" translate="yes" xml:space="preserve">
          <source>This operation holds a replicated input to a &lt;code&gt;tpu.replicate()&lt;/code&gt; computation subgraph. Each replicated input has the same shape and type alongside the output.</source>
          <target state="translated">This operation holds a replicated input to a &lt;code&gt;tpu.replicate()&lt;/code&gt; computation subgraph. Each replicated input has the same shape and type alongside the output.</target>
        </trans-unit>
        <trans-unit id="8d663f608fa1c649097379c4a16273931656d413" translate="yes" xml:space="preserve">
          <source>This operation holds a replicated output from a &lt;code&gt;tpu.replicate()&lt;/code&gt; computation subgraph. Each replicated output has the same shape and type alongside the input.</source>
          <target state="translated">This operation holds a replicated output from a &lt;code&gt;tpu.replicate()&lt;/code&gt; computation subgraph. Each replicated output has the same shape and type alongside the input.</target>
        </trans-unit>
        <trans-unit id="ddc1067cff13fb19a5da325542d16f1e694e62d1" translate="yes" xml:space="preserve">
          <source>This operation holds the metadata common to operations of a &lt;code&gt;tpu.replicate()&lt;/code&gt; computation subgraph.</source>
          <target state="translated">This operation holds the metadata common to operations of a &lt;code&gt;tpu.replicate()&lt;/code&gt; computation subgraph.</target>
        </trans-unit>
        <trans-unit id="1bd3f36c5bf6b7e281276b8f3d298543774510a1" translate="yes" xml:space="preserve">
          <source>This operation is a no-op when executing eagerly.</source>
          <target state="translated">この操作は、熱心に実行しているときには実行されません。</target>
        </trans-unit>
        <trans-unit id="7c3a2eaa25ce85f5bc726adb4e2f6e321fc3ad96" translate="yes" xml:space="preserve">
          <source>This operation is a synchronous version IteratorGetNext. It should only be used in situations where the iterator does not block the calling thread, or where the calling thread is not a member of the thread pool used to execute parallel operations (e.g. in eager mode).</source>
          <target state="translated">この操作は、同期版の IteratorGetNext です。これは、イテレータが呼び出し元のスレッドをブロックしていない場合や、 呼び出し元のスレッドが並列処理の実行に使用されるスレッドプールのメンバではない場合 (イーガーモードなど)にのみ使用すべきです。</target>
        </trans-unit>
        <trans-unit id="834adca0b6e8190426dd82e3dc679bdfc3901af6" translate="yes" xml:space="preserve">
          <source>This operation is considered stateful. For a stateless version, see PyFuncStateless.</source>
          <target state="translated">この操作はステートフルとみなされます。ステートレス版については PyFuncStateless を参照してください。</target>
        </trans-unit>
        <trans-unit id="c77c133cb2aa87b66c50cea9b24338cf94df91e2" translate="yes" xml:space="preserve">
          <source>This operation is equivalent to the following steps:</source>
          <target state="translated">この操作は、以下の手順に相当します。</target>
        </trans-unit>
        <trans-unit id="a85336f9b64b0941e75fed8873dd343470ffb664" translate="yes" xml:space="preserve">
          <source>This operation is for training only. It is generally an underestimate of the full softmax loss.</source>
          <target state="translated">この操作はトレーニング専用です。一般的にはフルソフトマックスの損失を過小評価しています。</target>
        </trans-unit>
        <trans-unit id="197a06d7811b56e8d6bce80b3c815e4a4c56a4a7" translate="yes" xml:space="preserve">
          <source>This operation is not supported by all queues. If a queue does not support DequeueUpTo, then an Unimplemented error is returned.</source>
          <target state="translated">この操作は、すべてのキューでサポートされているわけではありません。キューが DequeueUpTo をサポートしていない場合、Unimplemented エラーが返されます。</target>
        </trans-unit>
        <trans-unit id="6db0a8622252241b3dd8e4da9fc3d6ba84977a9c" translate="yes" xml:space="preserve">
          <source>This operation is related to &lt;code&gt;squeeze()&lt;/code&gt;, which removes dimensions of size 1.</source>
          <target state="translated">この操作は、サイズ1の次元を削除する &lt;code&gt;squeeze()&lt;/code&gt; に関連しています。</target>
        </trans-unit>
        <trans-unit id="49c94ac01402b2bd4ac870cdfc937202b7e69050" translate="yes" xml:space="preserve">
          <source>This operation is related to:</source>
          <target state="translated">この操作に関連しています。</target>
        </trans-unit>
        <trans-unit id="f8a4568939439baca88acb2c04e8494963c44c55" translate="yes" xml:space="preserve">
          <source>This operation is significantly more numerically stable than the equivalent tensorflow operation &lt;code&gt;tf.math.log(tf.math.cumsum(tf.math.exp(x)))&lt;/code&gt;, although computes the same result given infinite numerical precision. However, note that in some cases, it may be less stable than &lt;a href=&quot;reduce_logsumexp&quot;&gt;&lt;code&gt;tf.math.reduce_logsumexp&lt;/code&gt;&lt;/a&gt; for a given element, as it applies the &quot;log-sum-exp trick&quot; in a different way.</source>
          <target state="translated">この演算は、同等のテンソルフロー演算 &lt;code&gt;tf.math.log(tf.math.cumsum(tf.math.exp(x)))&lt;/code&gt; よりも数値的にはるかに安定していますが、無限の数値精度が与えられた場合と同じ結果が計算されます。ただし、「log-sum-expトリック」の適用方法が異なるため、特定の要素の&lt;a href=&quot;reduce_logsumexp&quot;&gt; &lt;code&gt;tf.math.reduce_logsumexp&lt;/code&gt; &lt;/a&gt;よりも安定性が低い場合があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="c9fb91f09ebc4c3acce5ac821344d6140f7e24da" translate="yes" xml:space="preserve">
          <source>This operation is similar to tensor_scatter_add, except that the tensor is zero-initialized. Calling &lt;a href=&quot;../scatter_nd&quot;&gt;&lt;code&gt;tf.scatter_nd(indices, values, shape)&lt;/code&gt;&lt;/a&gt; is identical to &lt;code&gt;tensor_scatter_add(tf.zeros(shape, values.dtype), indices, values)&lt;/code&gt;</source>
          <target state="translated">This operation is similar to tensor_scatter_add, except that the tensor is zero-initialized. Calling &lt;a href=&quot;../scatter_nd&quot;&gt; &lt;code&gt;tf.scatter_nd(indices, values, shape)&lt;/code&gt; &lt;/a&gt; is identical to &lt;code&gt;tensor_scatter_add(tf.zeros(shape, values.dtype), indices, values)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0cce4836efcc5d3f1c90cad3d4974cf4b16512f4" translate="yes" xml:space="preserve">
          <source>This operation is similar to tensor_scatter_add, except that the tensor is zero-initialized. Calling &lt;a href=&quot;scatter_nd&quot;&gt;&lt;code&gt;tf.scatter_nd(indices, values, shape)&lt;/code&gt;&lt;/a&gt; is identical to &lt;code&gt;tensor_scatter_add(tf.zeros(shape, values.dtype), indices, values)&lt;/code&gt;</source>
          <target state="translated">この操作は、テンソルがゼロで初期化されることを除いて、tensor_scatter_addと同様です。&lt;a href=&quot;scatter_nd&quot;&gt; &lt;code&gt;tf.scatter_nd(indices, values, shape)&lt;/code&gt; &lt;/a&gt;呼び出しは、 &lt;code&gt;tensor_scatter_add(tf.zeros(shape, values.dtype), indices, values)&lt;/code&gt; と同じです</target>
        </trans-unit>
        <trans-unit id="3ef068c49d35ae40fdbd6e0290914a410da40aff" translate="yes" xml:space="preserve">
          <source>This operation is sometimes called &quot;deconvolution&quot; after (Zeiler et al., 2010), but is actually the transpose (gradient) of &lt;code&gt;conv1d&lt;/code&gt; rather than an actual deconvolution.</source>
          <target state="translated">This operation is sometimes called &quot;deconvolution&quot; after (Zeiler et al., 2010), but is actually the transpose (gradient) of &lt;code&gt;conv1d&lt;/code&gt; rather than an actual deconvolution.</target>
        </trans-unit>
        <trans-unit id="f5e02776737c55d9c6ad653f1cc95f3511e5d57b" translate="yes" xml:space="preserve">
          <source>This operation is sometimes called &quot;deconvolution&quot; after (Zeiler et al., 2010), but is really the transpose (gradient) of &lt;code&gt;atrous_conv2d&lt;/code&gt; rather than an actual deconvolution.</source>
          <target state="translated">This operation is sometimes called &quot;deconvolution&quot; after (Zeiler et al., 2010), but is really the transpose (gradient) of &lt;code&gt;atrous_conv2d&lt;/code&gt; rather than an actual deconvolution.</target>
        </trans-unit>
        <trans-unit id="00a748a99cc55d86cf7d8d7f88c1133466c7c32f" translate="yes" xml:space="preserve">
          <source>This operation is sometimes called &quot;deconvolution&quot; after (Zeiler et al., 2010), but is really the transpose (gradient) of &lt;code&gt;conv2d&lt;/code&gt; rather than an actual deconvolution.</source>
          <target state="translated">This operation is sometimes called &quot;deconvolution&quot; after (Zeiler et al., 2010), but is really the transpose (gradient) of &lt;code&gt;conv2d&lt;/code&gt; rather than an actual deconvolution.</target>
        </trans-unit>
        <trans-unit id="c47ed45caa79111f8c5fa46b428a6d5a1fe8d370" translate="yes" xml:space="preserve">
          <source>This operation is sometimes called &quot;deconvolution&quot; after (Zeiler et al., 2010), but is really the transpose (gradient) of &lt;code&gt;conv3d&lt;/code&gt; rather than an actual deconvolution.</source>
          <target state="translated">This operation is sometimes called &quot;deconvolution&quot; after (Zeiler et al., 2010), but is really the transpose (gradient) of &lt;code&gt;conv3d&lt;/code&gt; rather than an actual deconvolution.</target>
        </trans-unit>
        <trans-unit id="50f836730593fffe361ee867e1bf79d15e8af917" translate="yes" xml:space="preserve">
          <source>This operation is sometimes called &quot;deconvolution&quot; after &lt;a href=&quot;http://www.matthewzeiler.com/pubs/cvpr2010/cvpr2010.pdf&quot;&gt;Deconvolutional Networks&lt;/a&gt;, but is actually the transpose (gradient) of &lt;code&gt;conv2d&lt;/code&gt; rather than an actual deconvolution.</source>
          <target state="translated">この操作は、&lt;a href=&quot;http://www.matthewzeiler.com/pubs/cvpr2010/cvpr2010.pdf&quot;&gt;Deconvolutional Networksの&lt;/a&gt;後で「デコンボリューション」と呼ばれることもありますが、実際には、実際のデコンボリューションではなく、 &lt;code&gt;conv2d&lt;/code&gt; の転置（勾配）です。</target>
        </trans-unit>
        <trans-unit id="cdd40bbfb18d0876cdd3d1bf655721101051d082" translate="yes" xml:space="preserve">
          <source>This operation is sometimes called &quot;deconvolution&quot; after &lt;a href=&quot;http://www.matthewzeiler.com/pubs/cvpr2010/cvpr2010.pdf&quot;&gt;Deconvolutional Networks&lt;/a&gt;, but is actually the transpose (gradient) of &lt;code&gt;convolution&lt;/code&gt; rather than an actual deconvolution.</source>
          <target state="translated">この操作は、&lt;a href=&quot;http://www.matthewzeiler.com/pubs/cvpr2010/cvpr2010.pdf&quot;&gt;Deconvolutional Networksの&lt;/a&gt;後で「デコンボリューション」と呼ばれることもありますが、実際には実際のデコンボリューションではなく、 &lt;code&gt;convolution&lt;/code&gt; 転置（勾配）です。</target>
        </trans-unit>
        <trans-unit id="a80e63d8e3617ef22a7c11bc4ac5ce2aac92b83c" translate="yes" xml:space="preserve">
          <source>This operation is sometimes called &quot;deconvolution&quot; after &lt;a href=&quot;https://www.matthewzeiler.com/mattzeiler/deconvolutionalnetworks.pdf&quot;&gt;Deconvolutional Networks&lt;/a&gt;, but is really the transpose (gradient) of &lt;code&gt;atrous_conv2d&lt;/code&gt; rather than an actual deconvolution.</source>
          <target state="translated">この操作は、&lt;a href=&quot;https://www.matthewzeiler.com/mattzeiler/deconvolutionalnetworks.pdf&quot;&gt;Deconvolutional Networksの&lt;/a&gt;後で「デコンボリューション」と呼ばれることもありますが、実際には実際のデコンボリューションではなく &lt;code&gt;atrous_conv2d&lt;/code&gt; の転置（勾配）です。</target>
        </trans-unit>
        <trans-unit id="3e16e89f92d27118cbc90336d321edbdccabf257" translate="yes" xml:space="preserve">
          <source>This operation is sometimes called &quot;deconvolution&quot; after &lt;a href=&quot;https://www.matthewzeiler.com/mattzeiler/deconvolutionalnetworks.pdf&quot;&gt;Deconvolutional Networks&lt;/a&gt;, but is really the transpose (gradient) of &lt;code&gt;conv1d&lt;/code&gt; rather than an actual deconvolution.</source>
          <target state="translated">この操作は、&lt;a href=&quot;https://www.matthewzeiler.com/mattzeiler/deconvolutionalnetworks.pdf&quot;&gt;Deconvolutional Networksの&lt;/a&gt;後で「デコンボリューション」と呼ばれることもありますが、実際には、実際のデコンボリューションではなく、 &lt;code&gt;conv1d&lt;/code&gt; の転置（勾配）です。</target>
        </trans-unit>
        <trans-unit id="74c54a1240dd3ebac671477622bdae5730c68b14" translate="yes" xml:space="preserve">
          <source>This operation is sometimes called &quot;deconvolution&quot; after &lt;a href=&quot;https://www.matthewzeiler.com/mattzeiler/deconvolutionalnetworks.pdf&quot;&gt;Deconvolutional Networks&lt;/a&gt;, but is really the transpose (gradient) of &lt;code&gt;conv2d&lt;/code&gt; rather than an actual deconvolution.</source>
          <target state="translated">この操作は、&lt;a href=&quot;https://www.matthewzeiler.com/mattzeiler/deconvolutionalnetworks.pdf&quot;&gt;Deconvolutional Networksの&lt;/a&gt;後で「デコンボリューション」と呼ばれることもありますが、実際には、実際のデコンボリューションではなく、 &lt;code&gt;conv2d&lt;/code&gt; の転置（勾配）です。</target>
        </trans-unit>
        <trans-unit id="78632da26e5444bf46256b6e1c192a603e6c3c00" translate="yes" xml:space="preserve">
          <source>This operation is sometimes called &quot;deconvolution&quot; after &lt;a href=&quot;https://www.matthewzeiler.com/mattzeiler/deconvolutionalnetworks.pdf&quot;&gt;Deconvolutional Networks&lt;/a&gt;, but is really the transpose (gradient) of &lt;code&gt;conv3d&lt;/code&gt; rather than an actual deconvolution.</source>
          <target state="translated">この操作は、&lt;a href=&quot;https://www.matthewzeiler.com/mattzeiler/deconvolutionalnetworks.pdf&quot;&gt;Deconvolutional Networksの&lt;/a&gt;後で「デコンボリューション」と呼ばれることもありますが、実際には、実際のデコンボリューションではなく、 &lt;code&gt;conv3d&lt;/code&gt; の転置（勾配）です。</target>
        </trans-unit>
        <trans-unit id="20f728b5bb5e16f6250024eb3cf614e43cfbbe07" translate="yes" xml:space="preserve">
          <source>This operation is typically used to clip gradients before applying them with an optimizer.</source>
          <target state="translated">この操作は通常、オプティマイザでグラデーションを適用する前に、グラデーションをクリップするために使用されます。</target>
        </trans-unit>
        <trans-unit id="7b06c412ab3afb65378a71bcff3a6e6664ba2503" translate="yes" xml:space="preserve">
          <source>This operation is typically used to clip gradients before applying them with an optimizer. Most gradient data is a collection of different shaped tensors for different parts of the model. Thus, this is a common usage:</source>
          <target state="translated">この操作は通常、オプティマイザでグラデーションを適用する前に、グラデーションをクリップするために使用されます。ほとんどのグラデーションデータは、モデルの異なる部分の異なる形状のテンソルの集合です。したがって、これは一般的な使用法です。</target>
        </trans-unit>
        <trans-unit id="a39ff6aff1d832bca041bbe0ecd1ce428c1522da" translate="yes" xml:space="preserve">
          <source>This operation is useful for Locality-Sensitive-Hashing (LSH) and other algorithms that use hashing approximations of cosine and &lt;code&gt;L2&lt;/code&gt; distances; codes can be generated from an input via:</source>
          <target state="translated">This operation is useful for Locality-Sensitive-Hashing (LSH) and other algorithms that use hashing approximations of cosine and &lt;code&gt;L2&lt;/code&gt; distances; codes can be generated from an input via:</target>
        </trans-unit>
        <trans-unit id="5397809ea0e6b96d049101c13960159515304d67" translate="yes" xml:space="preserve">
          <source>This operation is useful for resizing the activations between convolutions (but keeping all data), e.g. instead of pooling. It is also useful for training purely convolutional models.</source>
          <target state="translated">この操作は、例えば、プーリングの代わりに畳み込みの間の活性化のサイズを変更するのに便利です(ただし、すべてのデータは保持します)。また、純粋に畳み込みモデルを訓練するのにも有用です。</target>
        </trans-unit>
        <trans-unit id="e6cbba91c74639c8cb40de16428e2bef0563e905" translate="yes" xml:space="preserve">
          <source>This operation is useful if you want to add a batch dimension to a single element. For example, if you have a single image of shape &lt;code&gt;[height, width, channels]&lt;/code&gt;, you can make it a batch of 1 image with &lt;code&gt;expand_dims(image, 0)&lt;/code&gt;, which will make the shape &lt;code&gt;[1, height, width, channels]&lt;/code&gt;.</source>
          <target state="translated">この操作は、単一の要素にバッチディメンションを追加する場合に便利です。シェイプの単一の画像がある場合、例えば、 &lt;code&gt;[height, width, channels]&lt;/code&gt; 、あなたはそれで1枚の画像のバッチを作ることができる &lt;code&gt;expand_dims(image, 0)&lt;/code&gt; の形状をします、 &lt;code&gt;[1, height, width, channels]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6316e455129ed9fa859e28aacc9886a66315035c" translate="yes" xml:space="preserve">
          <source>This operation is useful if you want to add a batch dimension to a single element. For example, if you have a single image of shape &lt;code&gt;[height, width, channels]&lt;/code&gt;, you can make it a batch of one image with &lt;code&gt;expand_dims(image, 0)&lt;/code&gt;, which will make the shape &lt;code&gt;[1, height, width, channels]&lt;/code&gt;.</source>
          <target state="translated">この操作は、単一の要素にバッチディメンションを追加する場合に便利です。たとえば、形状 &lt;code&gt;[height, width, channels]&lt;/code&gt; 単一の画像がある場合、それを &lt;code&gt;expand_dims(image, 0)&lt;/code&gt; で1つの画像のバッチにして、形状 &lt;code&gt;[1, height, width, channels]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e351d2492bb6908fd7d460e61be31a9eca71f43d" translate="yes" xml:space="preserve">
          <source>This operation is useful to:</source>
          <target state="translated">この操作は次のような場合に便利です。</target>
        </trans-unit>
        <trans-unit id="183fa485124f0558dfb1f2c40c10151a91905ce9" translate="yes" xml:space="preserve">
          <source>This operation may be executed multiple times. Each execution will reset the iterator in &lt;code&gt;iterator&lt;/code&gt; to the first element of &lt;code&gt;dataset&lt;/code&gt;.</source>
          <target state="translated">This operation may be executed multiple times. Each execution will reset the iterator in &lt;code&gt;iterator&lt;/code&gt; to the first element of &lt;code&gt;dataset&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="082051a9c25e40abb9ca51ba30204e50cec28855" translate="yes" xml:space="preserve">
          <source>This operation outputs &quot;ref&quot; after the assignment is done. This makes it easier to chain operations that need to use the reset value.</source>
          <target state="translated">この操作は、代入が完了した後に「ref」を出力します。これにより、リセット値を使用する必要のある操作を連鎖させることが容易になります。</target>
        </trans-unit>
        <trans-unit id="45e5d0f78a3a33704d46216d94caf563cfac246a" translate="yes" xml:space="preserve">
          <source>This operation outputs &quot;ref&quot; after the update is done. This makes it easier to chain operations that need to use the reset value.</source>
          <target state="translated">この操作は、更新が完了した後に「ref」を出力します。これにより、リセット値を使用する必要のある操作をチェーン化しやすくなります。</target>
        </trans-unit>
        <trans-unit id="7d1d3aca1842cf510032065cfce3509b5c793096" translate="yes" xml:space="preserve">
          <source>This operation outputs &quot;ref&quot; after the update is done. This makes it easier to chain operations that need to use the reset value. Unlike &lt;a href=&quot;../../math/add&quot;&gt;&lt;code&gt;tf.math.add&lt;/code&gt;&lt;/a&gt;, this op does not broadcast. &lt;code&gt;ref&lt;/code&gt; and &lt;code&gt;value&lt;/code&gt; must have the same shape.</source>
          <target state="translated">この操作は、更新が完了した後に「ref」を出力します。これにより、リセット値を使用する必要がある操作を簡単に連鎖させることができます。&lt;a href=&quot;../../math/add&quot;&gt; &lt;code&gt;tf.math.add&lt;/code&gt; &lt;/a&gt;とは異なり、このopはブロードキャストしません。 &lt;code&gt;ref&lt;/code&gt; と &lt;code&gt;value&lt;/code&gt; は同じ形状でなければなりません。</target>
        </trans-unit>
        <trans-unit id="7e16eef80cf37c2d9c02fad5e714a6e559684854" translate="yes" xml:space="preserve">
          <source>This operation outputs &lt;code&gt;ref&lt;/code&gt; after the update is done. This makes it easier to chain operations that need to use the reset value.</source>
          <target state="translated">この操作は、更新が完了した後に &lt;code&gt;ref&lt;/code&gt; を出力します。これにより、リセット値を使用する必要がある操作を簡単に連鎖させることができます。</target>
        </trans-unit>
        <trans-unit id="80080e1227c1f588b580293eb11f01d8754cc2fa" translate="yes" xml:space="preserve">
          <source>This operation outputs &lt;code&gt;ref&lt;/code&gt; after the update is done. This makes it easier to chain operations that need to use the reset value. Unlike &lt;a href=&quot;../../math/subtract&quot;&gt;&lt;code&gt;tf.math.subtract&lt;/code&gt;&lt;/a&gt;, this op does not broadcast. &lt;code&gt;ref&lt;/code&gt; and &lt;code&gt;value&lt;/code&gt; must have the same shape.</source>
          <target state="translated">この操作は、更新が完了した後に &lt;code&gt;ref&lt;/code&gt; を出力します。これにより、リセット値を使用する必要がある操作を簡単に連鎖させることができます。&lt;a href=&quot;../../math/subtract&quot;&gt; &lt;code&gt;tf.math.subtract&lt;/code&gt; &lt;/a&gt;とは異なり、この演算はブロードキャストされません。 &lt;code&gt;ref&lt;/code&gt; と &lt;code&gt;value&lt;/code&gt; は同じ形状でなければなりません。</target>
        </trans-unit>
        <trans-unit id="211cf88f878719f0fdbc3eba7700cfd25f62b94c" translate="yes" xml:space="preserve">
          <source>This operation outputs &lt;code&gt;ref&lt;/code&gt; after the update is done. This makes it easier to chain operations that need to use the updated value. Duplicate entries are handled correctly: if multiple &lt;code&gt;indices&lt;/code&gt; reference the same location, their contributions add.</source>
          <target state="translated">この操作は、更新が完了した後に &lt;code&gt;ref&lt;/code&gt; を出力します。これにより、更新された値を使用する必要がある操作をチェーン化することが容易になります。重複するエントリは正しく処理されます。複数の &lt;code&gt;indices&lt;/code&gt; が同じ場所を参照している場合、それらの寄与が追加されます。</target>
        </trans-unit>
        <trans-unit id="f7141134307e0a174b2d64cd3ba50899cf746d15" translate="yes" xml:space="preserve">
          <source>This operation outputs a Tensor that holds the new value of &lt;code&gt;ref&lt;/code&gt; after the value has been assigned. This makes it easier to chain operations that need to use the reset value.</source>
          <target state="translated">この操作は、値が割り当てられた後に &lt;code&gt;ref&lt;/code&gt; の新しい値を保持するTensorを出力します。これにより、リセット値を使用する必要がある操作を簡単に連鎖させることができます。</target>
        </trans-unit>
        <trans-unit id="ff9194e8e7be6d4ad4f022b42bf00a1d9dcc3aad" translate="yes" xml:space="preserve">
          <source>This operation pads &lt;code&gt;input&lt;/code&gt; according to the &lt;code&gt;paddings&lt;/code&gt; and &lt;code&gt;constant_values&lt;/code&gt; you specify. &lt;code&gt;paddings&lt;/code&gt; is an integer tensor with shape &lt;code&gt;[Dn, 2]&lt;/code&gt;, where n is the rank of &lt;code&gt;input&lt;/code&gt;. For each dimension D of &lt;code&gt;input&lt;/code&gt;, &lt;code&gt;paddings[D, 0]&lt;/code&gt; indicates how many padding values to add before the contents of &lt;code&gt;input&lt;/code&gt; in that dimension, and &lt;code&gt;paddings[D, 1]&lt;/code&gt; indicates how many padding values to add after the contents of &lt;code&gt;input&lt;/code&gt; in that dimension. &lt;code&gt;constant_values&lt;/code&gt; is a scalar tensor of the same type as &lt;code&gt;input&lt;/code&gt; that indicates the value to use for padding &lt;code&gt;input&lt;/code&gt;.</source>
          <target state="translated">This operation pads &lt;code&gt;input&lt;/code&gt; according to the &lt;code&gt;paddings&lt;/code&gt; and &lt;code&gt;constant_values&lt;/code&gt; you specify. &lt;code&gt;paddings&lt;/code&gt; is an integer tensor with shape &lt;code&gt;[Dn, 2]&lt;/code&gt; , where n is the rank of &lt;code&gt;input&lt;/code&gt; . For each dimension D of &lt;code&gt;input&lt;/code&gt; , &lt;code&gt;paddings[D, 0]&lt;/code&gt; indicates how many padding values to add before the contents of &lt;code&gt;input&lt;/code&gt; in that dimension, and &lt;code&gt;paddings[D, 1]&lt;/code&gt; indicates how many padding values to add after the contents of &lt;code&gt;input&lt;/code&gt; in that dimension. &lt;code&gt;constant_values&lt;/code&gt; is a scalar tensor of the same type as &lt;code&gt;input&lt;/code&gt; that indicates the value to use for padding &lt;code&gt;input&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c7dac094042ba8225a6a7449892b847dafe951a8" translate="yes" xml:space="preserve">
          <source>This operation pads a &lt;code&gt;input&lt;/code&gt; with mirrored values according to the &lt;code&gt;paddings&lt;/code&gt; you specify. &lt;code&gt;paddings&lt;/code&gt; is an integer tensor with shape &lt;code&gt;[n, 2]&lt;/code&gt;, where n is the rank of &lt;code&gt;input&lt;/code&gt;. For each dimension D of &lt;code&gt;input&lt;/code&gt;, &lt;code&gt;paddings[D, 0]&lt;/code&gt; indicates how many values to add before the contents of &lt;code&gt;input&lt;/code&gt; in that dimension, and &lt;code&gt;paddings[D, 1]&lt;/code&gt; indicates how many values to add after the contents of &lt;code&gt;input&lt;/code&gt; in that dimension. Both &lt;code&gt;paddings[D, 0]&lt;/code&gt; and &lt;code&gt;paddings[D, 1]&lt;/code&gt; must be no greater than &lt;code&gt;input.dim_size(D)&lt;/code&gt; (or &lt;code&gt;input.dim_size(D) - 1&lt;/code&gt;) if &lt;code&gt;copy_border&lt;/code&gt; is true (if false, respectively).</source>
          <target state="translated">This operation pads a &lt;code&gt;input&lt;/code&gt; with mirrored values according to the &lt;code&gt;paddings&lt;/code&gt; you specify. &lt;code&gt;paddings&lt;/code&gt; is an integer tensor with shape &lt;code&gt;[n, 2]&lt;/code&gt; , where n is the rank of &lt;code&gt;input&lt;/code&gt; . For each dimension D of &lt;code&gt;input&lt;/code&gt; , &lt;code&gt;paddings[D, 0]&lt;/code&gt; indicates how many values to add before the contents of &lt;code&gt;input&lt;/code&gt; in that dimension, and &lt;code&gt;paddings[D, 1]&lt;/code&gt; indicates how many values to add after the contents of &lt;code&gt;input&lt;/code&gt; in that dimension. Both &lt;code&gt;paddings[D, 0]&lt;/code&gt; and &lt;code&gt;paddings[D, 1]&lt;/code&gt; must be no greater than &lt;code&gt;input.dim_size(D)&lt;/code&gt; (or &lt;code&gt;input.dim_size(D) - 1&lt;/code&gt; ) if &lt;code&gt;copy_border&lt;/code&gt; is true (if false, respectively).</target>
        </trans-unit>
        <trans-unit id="98dc6d3604c67365b92527ae5f26da565365534d" translate="yes" xml:space="preserve">
          <source>This operation pads a &lt;code&gt;input&lt;/code&gt; with zeros according to the &lt;code&gt;paddings&lt;/code&gt; you specify. &lt;code&gt;paddings&lt;/code&gt; is an integer tensor with shape &lt;code&gt;[Dn, 2]&lt;/code&gt;, where n is the rank of &lt;code&gt;input&lt;/code&gt;. For each dimension D of &lt;code&gt;input&lt;/code&gt;, &lt;code&gt;paddings[D, 0]&lt;/code&gt; indicates how many zeros to add before the contents of &lt;code&gt;input&lt;/code&gt; in that dimension, and &lt;code&gt;paddings[D, 1]&lt;/code&gt; indicates how many zeros to add after the contents of &lt;code&gt;input&lt;/code&gt; in that dimension.</source>
          <target state="translated">This operation pads a &lt;code&gt;input&lt;/code&gt; with zeros according to the &lt;code&gt;paddings&lt;/code&gt; you specify. &lt;code&gt;paddings&lt;/code&gt; is an integer tensor with shape &lt;code&gt;[Dn, 2]&lt;/code&gt; , where n is the rank of &lt;code&gt;input&lt;/code&gt; . For each dimension D of &lt;code&gt;input&lt;/code&gt; , &lt;code&gt;paddings[D, 0]&lt;/code&gt; indicates how many zeros to add before the contents of &lt;code&gt;input&lt;/code&gt; in that dimension, and &lt;code&gt;paddings[D, 1]&lt;/code&gt; indicates how many zeros to add after the contents of &lt;code&gt;input&lt;/code&gt; in that dimension.</target>
        </trans-unit>
        <trans-unit id="d8dcb952f1fd946dc8a99ab12f18c6c9f3bad230" translate="yes" xml:space="preserve">
          <source>This operation pads a &lt;code&gt;tensor&lt;/code&gt; according to the &lt;code&gt;paddings&lt;/code&gt; you specify. &lt;code&gt;paddings&lt;/code&gt; is an integer tensor with shape &lt;code&gt;[n, 2]&lt;/code&gt;, where n is the rank of &lt;code&gt;tensor&lt;/code&gt;. For each dimension D of &lt;code&gt;input&lt;/code&gt;, &lt;code&gt;paddings[D, 0]&lt;/code&gt; indicates how many values to add before the contents of &lt;code&gt;tensor&lt;/code&gt; in that dimension, and &lt;code&gt;paddings[D, 1]&lt;/code&gt; indicates how many values to add after the contents of &lt;code&gt;tensor&lt;/code&gt; in that dimension. If &lt;code&gt;mode&lt;/code&gt; is &quot;REFLECT&quot; then both &lt;code&gt;paddings[D, 0]&lt;/code&gt; and &lt;code&gt;paddings[D, 1]&lt;/code&gt; must be no greater than &lt;code&gt;tensor.dim_size(D) - 1&lt;/code&gt;. If &lt;code&gt;mode&lt;/code&gt; is &quot;SYMMETRIC&quot; then both &lt;code&gt;paddings[D, 0]&lt;/code&gt; and &lt;code&gt;paddings[D, 1]&lt;/code&gt; must be no greater than &lt;code&gt;tensor.dim_size(D)&lt;/code&gt;.</source>
          <target state="translated">この操作は、指定した &lt;code&gt;paddings&lt;/code&gt; に従って &lt;code&gt;tensor&lt;/code&gt; をパディングします。 &lt;code&gt;paddings&lt;/code&gt; は、形状 &lt;code&gt;[n, 2]&lt;/code&gt; 整数 &lt;code&gt;tensor&lt;/code&gt; です。ここで、nはテンソルのランクです。 &lt;code&gt;input&lt;/code&gt; の各次元Dについて、 &lt;code&gt;paddings[D, 0]&lt;/code&gt; はその次元の &lt;code&gt;tensor&lt;/code&gt; の内容の前に追加する値の数を示し、 &lt;code&gt;paddings[D, 1]&lt;/code&gt; はその次元の &lt;code&gt;tensor&lt;/code&gt; の内容の後に追加する値の数を示します。場合 &lt;code&gt;mode&lt;/code&gt; あり、両方&quot;を反映&quot; &lt;code&gt;paddings[D, 0]&lt;/code&gt; 及び &lt;code&gt;paddings[D, 1]&lt;/code&gt; よりも大きくてはならない &lt;code&gt;tensor.dim_size(D) - 1&lt;/code&gt; 。場合 &lt;code&gt;mode&lt;/code&gt; &quot;対称&quot;であり、両方の &lt;code&gt;paddings[D, 0]&lt;/code&gt; 及び &lt;code&gt;paddings[D, 1]&lt;/code&gt; よりも大きくてはならない &lt;code&gt;tensor.dim_size(D)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ece6bb1bca3b5a4f71fcb2a4c7bb7def98bb6471" translate="yes" xml:space="preserve">
          <source>This operation performs non_max_suppression on the inputs per batch, across all classes. Prunes away boxes that have high intersection-over-union (IOU) overlap with previously selected boxes. Bounding boxes are supplied as [y1, x1, y2, x2], where (y1, x1) and (y2, x2) are the coordinates of any diagonal pair of box corners and the coordinates can be provided as normalized (i.e., lying in the interval [0, 1]) or absolute. Note that this algorithm is agnostic to where the origin is in the coordinate system. Also note that this algorithm is invariant to orthogonal transformations and translations of the coordinate system; thus translating or reflections of the coordinate system result in the same boxes being selected by the algorithm. The output of this operation is the final boxes, scores and classes tensor returned after performing non_max_suppression.</source>
          <target state="translated">この操作は、すべてのクラスで、バッチごとの入力に対して non_max_suppression を実行します。以前に選択されたボックスと重なり合っている IOU (Intersection-Over-union)の高いボックスを削除します。ここで,(y1,x1)と(y2,x2)は,ボックスのコーナーの対角線上の座標であり,座標は正規化されたもの(つまり,[0,1]の範囲内にあるもの),または絶対値として提供することができます.このアルゴリズムは、原点が座標系内のどこにあるかに不可知であることに注意してください。また、 こ のアルゴ リ ズ ムは座標系の直交変換 ・ 並進に対して不変であ る こ と に留意 し て く だ さ い。こ の操作の出力は、 non_max_suppression を実行した後に返される最終的な枠・得点・クラステンソルです。</target>
        </trans-unit>
        <trans-unit id="92bf8506361b0c3190382a71e7f126a1495f07cd" translate="yes" xml:space="preserve">
          <source>This operation randomly samples a tensor of sampled classes (&lt;code&gt;sampled_candidates&lt;/code&gt;) from the range of integers &lt;code&gt;[0, range_max)&lt;/code&gt;.</source>
          <target state="translated">この操作は、整数 &lt;code&gt;[0, range_max)&lt;/code&gt; 範囲から、サンプリングされたクラス（ &lt;code&gt;sampled_candidates&lt;/code&gt; ）のテンソルをランダムにサンプリングします。</target>
        </trans-unit>
        <trans-unit id="ef1ed12213e6ff487e80edd0040d70890d84414e" translate="yes" xml:space="preserve">
          <source>This operation requires that &lt;code&gt;axis&lt;/code&gt; is a valid index for &lt;code&gt;input.shape&lt;/code&gt;, following Python indexing rules:</source>
          <target state="translated">This operation requires that &lt;code&gt;axis&lt;/code&gt; is a valid index for &lt;code&gt;input.shape&lt;/code&gt; , following Python indexing rules:</target>
        </trans-unit>
        <trans-unit id="d5bc7ae5c1b93f8f5a6a390a4d228223c7c191dd" translate="yes" xml:space="preserve">
          <source>This operation requires that &lt;code&gt;axis&lt;/code&gt; is a valid index for &lt;code&gt;input.shape&lt;/code&gt;, following python indexing rules:</source>
          <target state="translated">This operation requires that &lt;code&gt;axis&lt;/code&gt; is a valid index for &lt;code&gt;input.shape&lt;/code&gt; , following python indexing rules:</target>
        </trans-unit>
        <trans-unit id="2656ea13a552cbb0836e0031c2afa8bfe371a2e1" translate="yes" xml:space="preserve">
          <source>This operation requires that:</source>
          <target state="translated">この操作には、以下のことが必要です。</target>
        </trans-unit>
        <trans-unit id="b27b171e2cb8132634ecffed1d0dfa123640e238" translate="yes" xml:space="preserve">
          <source>This operation reshapes the &quot;batch&quot; dimension 0 into &lt;code&gt;M + 1&lt;/code&gt; dimensions of shape &lt;code&gt;block_shape + [batch]&lt;/code&gt;, interleaves these blocks back into the grid defined by the spatial dimensions &lt;code&gt;[1, ..., M]&lt;/code&gt;, to obtain a result with the same rank as the input. The spatial dimensions of this intermediate result are then optionally cropped according to &lt;code&gt;crops&lt;/code&gt; to produce the output. This is the reverse of SpaceToBatch (see &lt;a href=&quot;space_to_batch&quot;&gt;&lt;code&gt;tf.space_to_batch&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">This operation reshapes the &quot;batch&quot; dimension 0 into &lt;code&gt;M + 1&lt;/code&gt; dimensions of shape &lt;code&gt;block_shape + [batch]&lt;/code&gt; , interleaves these blocks back into the grid defined by the spatial dimensions &lt;code&gt;[1, ..., M]&lt;/code&gt; , to obtain a result with the same rank as the input. The spatial dimensions of this intermediate result are then optionally cropped according to &lt;code&gt;crops&lt;/code&gt; to produce the output. This is the reverse of SpaceToBatch (see &lt;a href=&quot;space_to_batch&quot;&gt; &lt;code&gt;tf.space_to_batch&lt;/code&gt; &lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="85455e262fab5e8f9fc55d0016d69887ed46e6fb" translate="yes" xml:space="preserve">
          <source>This operation reshapes the &quot;batch&quot; dimension 0 into &lt;code&gt;M + 1&lt;/code&gt; dimensions of shape &lt;code&gt;block_shape + [batch]&lt;/code&gt;, interleaves these blocks back into the grid defined by the spatial dimensions &lt;code&gt;[1, ..., M]&lt;/code&gt;, to obtain a result with the same rank as the input. The spatial dimensions of this intermediate result are then optionally cropped according to &lt;code&gt;crops&lt;/code&gt; to produce the output. This is the reverse of SpaceToBatch. See below for a precise description.</source>
          <target state="translated">この操作は、「バッチ」次元0を形状 &lt;code&gt;block_shape + [batch]&lt;/code&gt; &lt;code&gt;M + 1&lt;/code&gt; 次元に再形成し、これらのブロックを空間次元 &lt;code&gt;[1, ..., M]&lt;/code&gt; で定義されたグリッドにインターリーブして、入力と同じランク。この中間結果の空間次元は、次いで、任意選択に応じてトリミングされている &lt;code&gt;crops&lt;/code&gt; の出力を生成します。これはSpaceToBatchの逆です。正確な説明については、以下を参照してください。</target>
        </trans-unit>
        <trans-unit id="fe8665b789d92e174b87e3b8d8b3131e0c5a95d4" translate="yes" xml:space="preserve">
          <source>This operation returns a 1-D integer tensor representing the shape of &lt;code&gt;input&lt;/code&gt;.</source>
          <target state="translated">この演算は、 &lt;code&gt;input&lt;/code&gt; の形状を表す1次元整数テンソルを返します。</target>
        </trans-unit>
        <trans-unit id="7a59463d2fe92b4018e2beec28525b7ad3bbf202" translate="yes" xml:space="preserve">
          <source>This operation returns a tensor &lt;code&gt;y&lt;/code&gt; containing all of the unique elements of &lt;code&gt;x&lt;/code&gt; sorted in the same order that they occur in &lt;code&gt;x&lt;/code&gt;. This operation also returns a tensor &lt;code&gt;idx&lt;/code&gt; the same size as &lt;code&gt;x&lt;/code&gt; that contains the index of each value of &lt;code&gt;x&lt;/code&gt; in the unique output &lt;code&gt;y&lt;/code&gt;. Finally, it returns a third tensor &lt;code&gt;count&lt;/code&gt; that contains the count of each element of &lt;code&gt;y&lt;/code&gt; in &lt;code&gt;x&lt;/code&gt;. In other words:</source>
          <target state="translated">この操作は、テンソル返し &lt;code&gt;y&lt;/code&gt; のユニークな要素の全てを含む &lt;code&gt;x&lt;/code&gt; それらが起こるのと同じ順序でソート &lt;code&gt;x&lt;/code&gt; 。この操作は、一意の出力 &lt;code&gt;y&lt;/code&gt; の &lt;code&gt;x&lt;/code&gt; の各値のインデックスを含む &lt;code&gt;x&lt;/code&gt; と同じサイズのテンソル &lt;code&gt;idx&lt;/code&gt; も返します。最後に、第三のテンソル返し &lt;code&gt;count&lt;/code&gt; の各要素のカウント含ま &lt;code&gt;y&lt;/code&gt; に &lt;code&gt;x&lt;/code&gt; 。言い換えると：</target>
        </trans-unit>
        <trans-unit id="536871e049e74061332eb50e7568b95429f16ba6" translate="yes" xml:space="preserve">
          <source>This operation returns a tensor &lt;code&gt;y&lt;/code&gt; containing all of the unique elements of &lt;code&gt;x&lt;/code&gt; sorted in the same order that they occur in &lt;code&gt;x&lt;/code&gt;; &lt;code&gt;x&lt;/code&gt; does not need to be sorted. This operation also returns a tensor &lt;code&gt;idx&lt;/code&gt; the same size as &lt;code&gt;x&lt;/code&gt; that contains the index of each value of &lt;code&gt;x&lt;/code&gt; in the unique output &lt;code&gt;y&lt;/code&gt;. In other words:</source>
          <target state="translated">この操作は、テンソル返し &lt;code&gt;y&lt;/code&gt; のユニークな要素の全てを含む &lt;code&gt;x&lt;/code&gt; それらが起こるのと同じ順序でソート &lt;code&gt;x&lt;/code&gt; 。 &lt;code&gt;x&lt;/code&gt; はソートする必要はありません。この操作は、一意の出力 &lt;code&gt;y&lt;/code&gt; の &lt;code&gt;x&lt;/code&gt; の各値のインデックスを含む &lt;code&gt;x&lt;/code&gt; と同じサイズのテンソル &lt;code&gt;idx&lt;/code&gt; も返します。言い換えると：</target>
        </trans-unit>
        <trans-unit id="08bfd9d4b0608003900efe52523c1412fe2e10f1" translate="yes" xml:space="preserve">
          <source>This operation returns a tensor of type &lt;code&gt;dtype&lt;/code&gt; with shape &lt;code&gt;shape&lt;/code&gt; and all elements set to one.</source>
          <target state="translated">この演算は、形状 &lt;code&gt;shape&lt;/code&gt; とすべての要素が1に設定されたタイプ &lt;code&gt;dtype&lt;/code&gt; のテンソルを返します。</target>
        </trans-unit>
        <trans-unit id="46403ed383d4150a23258a456b0faa0e79d56dbe" translate="yes" xml:space="preserve">
          <source>This operation returns a tensor of type &lt;code&gt;dtype&lt;/code&gt; with shape &lt;code&gt;shape&lt;/code&gt; and all elements set to zero.</source>
          <target state="translated">この演算は、形状 &lt;code&gt;shape&lt;/code&gt; とすべての要素がゼロに設定された &lt;code&gt;dtype&lt;/code&gt; 型のテンソルを返します。</target>
        </trans-unit>
        <trans-unit id="476cbc978c015f266a3353221077ac3bad3036de" translate="yes" xml:space="preserve">
          <source>This operation returns a tensor with the &lt;code&gt;diagonal&lt;/code&gt; part of the &lt;code&gt;input&lt;/code&gt;. The &lt;code&gt;diagonal&lt;/code&gt; part is computed as follows:</source>
          <target state="translated">この操作は、 &lt;code&gt;input&lt;/code&gt; &lt;code&gt;diagonal&lt;/code&gt; 部分を持つテンソルを返します。 &lt;code&gt;diagonal&lt;/code&gt; 以下のように一部が計算されます。</target>
        </trans-unit>
        <trans-unit id="4aefd218f88fe56a44f84be48601325a8bfff9a5" translate="yes" xml:space="preserve">
          <source>This operation returns a tensor with the &lt;code&gt;diagonal&lt;/code&gt; part of the batched &lt;code&gt;input&lt;/code&gt;. The &lt;code&gt;diagonal&lt;/code&gt; part is computed as follows:</source>
          <target state="translated">This operation returns a tensor with the &lt;code&gt;diagonal&lt;/code&gt; part of the batched &lt;code&gt;input&lt;/code&gt; . The &lt;code&gt;diagonal&lt;/code&gt; part is computed as follows:</target>
        </trans-unit>
        <trans-unit id="19c9a08587b8ac6d36c602ec8cf419295278168f" translate="yes" xml:space="preserve">
          <source>This operation returns an integer representing the number of elements in &lt;code&gt;input&lt;/code&gt;.</source>
          <target state="translated">This operation returns an integer representing the number of elements in &lt;code&gt;input&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="283ea59f55046522de219f0f2dc075ad8e2f3a65" translate="yes" xml:space="preserve">
          <source>This operation returns an integer representing the rank of &lt;code&gt;input&lt;/code&gt;.</source>
          <target state="translated">This operation returns an integer representing the rank of &lt;code&gt;input&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c7e2028f3f49e171315c3ed603528d9f2314c768" translate="yes" xml:space="preserve">
          <source>This operation returns the coordinates of true elements in &lt;code&gt;condition&lt;/code&gt;. The coordinates are returned in a 2-D tensor where the first dimension (rows) represents the number of true elements, and the second dimension (columns) represents the coordinates of the true elements. Keep in mind, the shape of the output tensor can vary depending on how many true values there are in &lt;code&gt;condition&lt;/code&gt;. Indices are output in row-major order.</source>
          <target state="translated">This operation returns the coordinates of true elements in &lt;code&gt;condition&lt;/code&gt; . The coordinates are returned in a 2-D tensor where the first dimension (rows) represents the number of true elements, and the second dimension (columns) represents the coordinates of the true elements. Keep in mind, the shape of the output tensor can vary depending on how many true values there are in &lt;code&gt;condition&lt;/code&gt; . Indices are output in row-major order.</target>
        </trans-unit>
        <trans-unit id="9768f017e85a1cd0efa99d0dd71cd4a51ae98fd1" translate="yes" xml:space="preserve">
          <source>This operation returns the result of a TPU compilation as a serialized CompilationResultProto, which holds a status and an error message if an error occurred during compilation.</source>
          <target state="translated">この操作は、コンパイル中にエラーが発生した場合のステータスとエラーメッセージを保持するシリアル化されたCompilationResultProtoとしてTPUコンパイルの結果を返します。</target>
        </trans-unit>
        <trans-unit id="e2b8bbf455ec7dda7bf033c368dcb34b158ee06e" translate="yes" xml:space="preserve">
          <source>This operation returns the same result as the C++ std::nextafter function.</source>
          <target state="translated">この操作は、C++の std::nextafter 関数と同じ結果を返します。</target>
        </trans-unit>
        <trans-unit id="cba2fef602700f559d54f64ca39679c7fe5a39cf" translate="yes" xml:space="preserve">
          <source>This operation returns true if the queue is closed and false if the queue is open.</source>
          <target state="translated">この操作は、キューが閉じていれば真を返し、キューが開いていれば偽を返します。</target>
        </trans-unit>
        <trans-unit id="dc131f95b04b052706f9dc5a2e0863ccce212278" translate="yes" xml:space="preserve">
          <source>This operation signals that no more elements will be enqueued in the given queue. Subsequent &lt;code&gt;enqueue&lt;/code&gt; and &lt;code&gt;enqueue_many&lt;/code&gt; operations will fail. Subsequent &lt;code&gt;dequeue&lt;/code&gt; and &lt;code&gt;dequeue_many&lt;/code&gt; operations will continue to succeed if sufficient elements remain in the queue. Subsequently dequeue and dequeue_many operations that would otherwise block waiting for more elements (if close hadn't been called) will now fail immediately.</source>
          <target state="translated">この操作は、指定されたキューにこれ以上要素がエンキューされないことを通知します。後続の &lt;code&gt;enqueue&lt;/code&gt; および &lt;code&gt;enqueue_many&lt;/code&gt; 操作は失敗します。後続の &lt;code&gt;dequeue&lt;/code&gt; および &lt;code&gt;dequeue_many&lt;/code&gt; 操作は、十分な要素がキューに残っている場合、引き続き成功します。その後、（クローズが呼び出されていなかった場合に）追加の要素の待機をブロックするdequeueおよびdequeue_many操作がすぐに失敗するようになりました。</target>
        </trans-unit>
        <trans-unit id="03d601007c00ecaaf281c99e7ccdb7f989fc3f40" translate="yes" xml:space="preserve">
          <source>This operation signals that no more elements will be enqueued in the given queue. Subsequent Enqueue(Many) operations will fail. Subsequent Dequeue(Many) operations will continue to succeed if sufficient elements remain in the queue. Subsequent Dequeue(Many) operations that would block will fail immediately.</source>
          <target state="translated">この操作は、指定されたキューにこれ以上の要素が入れられないことを通知します。後続の Enqueue(Many)操作は失敗します。十分な要素がキューに残っていれば、後続の Dequeue(Many)操作は成功し続けます。ブロックするような後続の Dequeue(Many)操作は直ちに失敗します。</target>
        </trans-unit>
        <trans-unit id="5ec52846420c7cbfc81445413d50c93e2addb827" translate="yes" xml:space="preserve">
          <source>This operation signals that no more new elements will be inserted in the given barrier. Subsequent InsertMany that try to introduce a new key will fail. Subsequent InsertMany operations that just add missing components to already existing elements will continue to succeed. Subsequent TakeMany operations will continue to succeed if sufficient completed elements remain in the barrier. Subsequent TakeMany operations that would block will fail immediately.</source>
          <target state="translated">この操作は、指定されたバリアにこれ以上新しい要素が挿入されないことを通知します。新しいキーを導入しようとする後続のInsertMany操作は失敗します。既に存在する要素に欠落しているコンポーネントを追加するだけのInsertMany操作は成功し続けます。十分に完成した要素がバリア内に残っていれば、それ以降のTakeMany操作は成功し続けます。ブロックするであろう後続のTakeMany操作は直ちに失敗します。</target>
        </trans-unit>
        <trans-unit id="ed8ef290710f5b794405ab349bc8048a526b3051" translate="yes" xml:space="preserve">
          <source>This operation slices each component tensor along the 0th dimension to make multiple queue elements. All of the tensors in &lt;code&gt;vals&lt;/code&gt; must have the same size in the 0th dimension.</source>
          <target state="translated">この操作は、各要素テンソルを0次元に沿ってスライスし、複数のキュー要素を作成します。 &lt;code&gt;vals&lt;/code&gt; のすべてのテンソルは、0番目の次元で同じサイズでなければなりません。</target>
        </trans-unit>
        <trans-unit id="b7a9602cce6855f9551ec64964df2f6660343d5e" translate="yes" xml:space="preserve">
          <source>This operation slices each component tensor along the 0th dimension to make multiple queue elements. All of the tuple components must have the same size in the 0th dimension.</source>
          <target state="translated">この操作は,複数のキュー要素を作るために,各構成要素テンソルを0次元に沿ってスライスします.タプル構成要素のすべては,0次元目で同じサイズを持たなければなりません.</target>
        </trans-unit>
        <trans-unit id="b06acef6473406f9a6972f0bdd65c856a80109e7" translate="yes" xml:space="preserve">
          <source>This operation takes variable-length sequences (&lt;code&gt;hypothesis&lt;/code&gt; and &lt;code&gt;truth&lt;/code&gt;), each provided as a &lt;code&gt;SparseTensor&lt;/code&gt;, and computes the Levenshtein distance. You can normalize the edit distance by length of &lt;code&gt;truth&lt;/code&gt; by setting &lt;code&gt;normalize&lt;/code&gt; to true.</source>
          <target state="translated">この操作は、それぞれが &lt;code&gt;SparseTensor&lt;/code&gt; として提供される可変長シーケンス（ &lt;code&gt;hypothesis&lt;/code&gt; と &lt;code&gt;truth&lt;/code&gt; ）を取り、レーベンシュタイン距離を計算します。 &lt;code&gt;normalize&lt;/code&gt; をtrueに設定すると、編集距離を &lt;code&gt;truth&lt;/code&gt; 長さで正規化できます。</target>
        </trans-unit>
        <trans-unit id="4b844fb17a610af4c2dfbda43ce1ac8c2ea894a7" translate="yes" xml:space="preserve">
          <source>This operation tends to perform well when &lt;code&gt;A&lt;/code&gt; is more sparse, if the column size of the product is small (e.g. matrix-vector multiplication), if &lt;code&gt;sp_a.dense_shape&lt;/code&gt; takes on large values.</source>
          <target state="translated">この演算は、 &lt;code&gt;sp_a.dense_shape&lt;/code&gt; が大きな値をとる場合、積の列サイズが小さい（行列とベクトルの乗算など）場合、 &lt;code&gt;A&lt;/code&gt; がスパースであるときにうまく機能する傾向があります。</target>
        </trans-unit>
        <trans-unit id="656ae1e1362cbc36310acc8deee39f6903aad8f9" translate="yes" xml:space="preserve">
          <source>This operation will block indefinitely until data is available.</source>
          <target state="translated">この操作は、データが利用可能になるまで無期限にブロックされます。</target>
        </trans-unit>
        <trans-unit id="ca0db1beb7905bc51f7f1596562bcd98102255d3" translate="yes" xml:space="preserve">
          <source>This operation will block indefinitely until data is available. Output &lt;code&gt;i&lt;/code&gt; corresponds to XLA tuple element &lt;code&gt;i&lt;/code&gt;.</source>
          <target state="translated">This operation will block indefinitely until data is available. Output &lt;code&gt;i&lt;/code&gt; corresponds to XLA tuple element &lt;code&gt;i&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1051e1cb11d005837380c93974db8cb36d834ab5" translate="yes" xml:space="preserve">
          <source>This operation will generate a string suitable to be saved out to create a .wav audio file. It will be encoded in the 16-bit PCM format. It takes in float values in the range -1.0f to 1.0f, and any outside that value will be clamped to that range.</source>
          <target state="translated">この操作は、.wav オーディオファイルを作成するために保存するのに適した文字列を生成します。この文字列は、16 ビットの PCM フォーマットでエンコードされます。この操作では、-1.0f から 1.0f の範囲の float 値を受け取り、その範囲外の値はその範囲にクランプされます。</target>
        </trans-unit>
        <trans-unit id="bf6b9f0d6051cd83422b6ad2cb1617b5b6c44a65" translate="yes" xml:space="preserve">
          <source>This operation will output a tensor of shape &lt;code&gt;[1, 1, 1, 4]&lt;/code&gt;:</source>
          <target state="translated">この操作は、形状 &lt;code&gt;[1, 1, 1, 4]&lt;/code&gt; 1、1、1、4]のテンソルを出力します。</target>
        </trans-unit>
        <trans-unit id="01c0abdcd1d63eef5d525eb4d621b9072cafca4f" translate="yes" xml:space="preserve">
          <source>This operation will output a tensor of shape &lt;code&gt;[1, 2, 2, 1]&lt;/code&gt;:</source>
          <target state="translated">この操作は、形状 &lt;code&gt;[1, 2, 2, 1]&lt;/code&gt; 1、2、2、1]のテンソルを出力します。</target>
        </trans-unit>
        <trans-unit id="f9c1bb170834121c155816075bc30535b34c3026" translate="yes" xml:space="preserve">
          <source>This operation would return the following:</source>
          <target state="translated">この操作を行うと、以下のような結果が返ってきます。</target>
        </trans-unit>
        <trans-unit id="c09d355015c640623e774187c625203da78fb3a6" translate="yes" xml:space="preserve">
          <source>This operation would return:</source>
          <target state="translated">この操作は戻ってきます。</target>
        </trans-unit>
        <trans-unit id="6585b279d1753d7936601f5ce821925656bfd5b2" translate="yes" xml:space="preserve">
          <source>This operation, for block size of 2, will return the following tensor of shape &lt;code&gt;[1, 2, 2, 3]&lt;/code&gt;</source>
          <target state="translated">この操作は、ブロックサイズが2の場合、次の形状のテンソルを返します &lt;code&gt;[1, 2, 2, 3]&lt;/code&gt; 1、2、2、3 ]</target>
        </trans-unit>
        <trans-unit id="123e5c864ddc20e423825601cb576b64af53b67e" translate="yes" xml:space="preserve">
          <source>This operation, for block_size of 2, will return the following tensor of shape &lt;code&gt;[1, 1, 1, 12]&lt;/code&gt;</source>
          <target state="translated">この操作は、block_sizeが2の場合、形状 &lt;code&gt;[1, 1, 1, 12]&lt;/code&gt; 1、1、1、12]の次のテンソルを返します。</target>
        </trans-unit>
        <trans-unit id="2a0a130eb7e8314a609a2db135e21936c4a0de8b" translate="yes" xml:space="preserve">
          <source>This operator acts like a (batch) matrix &lt;code&gt;A&lt;/code&gt; with shape &lt;code&gt;[B1,...,Bb, M, N]&lt;/code&gt; for some &lt;code&gt;b &amp;gt;= 0&lt;/code&gt;. The first &lt;code&gt;b&lt;/code&gt; indices index a batch member. For every batch index &lt;code&gt;(i1,...,ib)&lt;/code&gt;, &lt;code&gt;A[i1,...,ib, : :]&lt;/code&gt; is an &lt;code&gt;m x n&lt;/code&gt; matrix. Again, this matrix &lt;code&gt;A&lt;/code&gt; may not be materialized, but for purposes of identifying and working with compatible arguments the shape is relevant.</source>
          <target state="translated">この演算子は、いくつかの &lt;code&gt;b &amp;gt;= 0&lt;/code&gt; に対して &lt;code&gt;[B1,...,Bb, M, N]&lt;/code&gt; 形状[B1、...、Bb、M、N]を持つ（バッチ）行列 &lt;code&gt;A&lt;/code&gt; のように機能します。最初の &lt;code&gt;b&lt;/code&gt; インデックスは、バッチメンバーにインデックスを付けます。すべてのバッチインデックス &lt;code&gt;(i1,...,ib)&lt;/code&gt; 、 &lt;code&gt;A[i1,...,ib, : :]&lt;/code&gt; は &lt;code&gt;m x n&lt;/code&gt; 行列です。繰り返しになりますが、この行列 &lt;code&gt;A&lt;/code&gt; は具体化されない可能性がありますが、互換性のある引数を特定して処理するためには、形状が適切です。</target>
        </trans-unit>
        <trans-unit id="9624d2140d2af8604c19c56292430ec7141d96ff" translate="yes" xml:space="preserve">
          <source>This operator acts like a [batch] Toeplitz matrix &lt;code&gt;A&lt;/code&gt; with shape &lt;code&gt;[B1,...,Bb, N, N]&lt;/code&gt; for some &lt;code&gt;b &amp;gt;= 0&lt;/code&gt;. The first &lt;code&gt;b&lt;/code&gt; indices index a batch member. For every batch index &lt;code&gt;(i1,...,ib)&lt;/code&gt;, &lt;code&gt;A[i1,...,ib, : :]&lt;/code&gt; is an &lt;code&gt;N x N&lt;/code&gt; matrix. This matrix &lt;code&gt;A&lt;/code&gt; is not materialized, but for purposes of broadcasting this shape will be relevant.</source>
          <target state="translated">この演算子は、いくつかの &lt;code&gt;b &amp;gt;= 0&lt;/code&gt; について &lt;code&gt;[B1,...,Bb, N, N]&lt;/code&gt; 形状[B1、...、Bb、N、N]を持つ[バッチ]テプリッツ行列 &lt;code&gt;A&lt;/code&gt; のように機能します。最初の &lt;code&gt;b&lt;/code&gt; インデックスは、バッチメンバーにインデックスを付けます。すべてのバッチインデックス &lt;code&gt;(i1,...,ib)&lt;/code&gt; 、 &lt;code&gt;A[i1,...,ib, : :]&lt;/code&gt; は &lt;code&gt;N x N&lt;/code&gt; 行列です。この行列 &lt;code&gt;A&lt;/code&gt; は具体化されていませんが、ブロードキャストの目的にはこの形状が関係します。</target>
        </trans-unit>
        <trans-unit id="ae991b61103c038a5ab6e26593ecbc7152e117f2" translate="yes" xml:space="preserve">
          <source>This operator acts like a [batch] diagonal matrix &lt;code&gt;A&lt;/code&gt; with shape &lt;code&gt;[B1,...,Bb, N, N]&lt;/code&gt; for some &lt;code&gt;b &amp;gt;= 0&lt;/code&gt;. The first &lt;code&gt;b&lt;/code&gt; indices index a batch member. For every batch index &lt;code&gt;(i1,...,ib)&lt;/code&gt;, &lt;code&gt;A[i1,...,ib, : :]&lt;/code&gt; is an &lt;code&gt;N x N&lt;/code&gt; matrix. This matrix &lt;code&gt;A&lt;/code&gt; is not materialized, but for purposes of broadcasting this shape will be relevant.</source>
          <target state="translated">この演算子は、いくつかの &lt;code&gt;b &amp;gt;= 0&lt;/code&gt; に対して &lt;code&gt;[B1,...,Bb, N, N]&lt;/code&gt; 形状[B1、...、Bb、N、N]を持つ[バッチ]対角行列 &lt;code&gt;A&lt;/code&gt; のように機能します。最初の &lt;code&gt;b&lt;/code&gt; インデックスは、バッチメンバーにインデックスを付けます。すべてのバッチインデックス &lt;code&gt;(i1,...,ib)&lt;/code&gt; 、 &lt;code&gt;A[i1,...,ib, : :]&lt;/code&gt; は &lt;code&gt;N x N&lt;/code&gt; 行列です。この行列 &lt;code&gt;A&lt;/code&gt; は具体化されていませんが、ブロードキャストの目的にはこの形状が関係します。</target>
        </trans-unit>
        <trans-unit id="5eea0437af7326077ca375b7627f553585750e30" translate="yes" xml:space="preserve">
          <source>This operator acts like a [batch] identity matrix &lt;code&gt;A&lt;/code&gt; with shape &lt;code&gt;[B1,...,Bb, N, N]&lt;/code&gt; for some &lt;code&gt;b &amp;gt;= 0&lt;/code&gt;. The first &lt;code&gt;b&lt;/code&gt; indices index a batch member. For every batch index &lt;code&gt;(i1,...,ib)&lt;/code&gt;, &lt;code&gt;A[i1,...,ib, : :]&lt;/code&gt; is an &lt;code&gt;N x N&lt;/code&gt; matrix. This matrix &lt;code&gt;A&lt;/code&gt; is not materialized, but for purposes of broadcasting this shape will be relevant.</source>
          <target state="translated">この演算子は、いくつかの &lt;code&gt;b &amp;gt;= 0&lt;/code&gt; に対して &lt;code&gt;[B1,...,Bb, N, N]&lt;/code&gt; 形状[B1、...、Bb、N、N]を持つ[バッチ]単位行列 &lt;code&gt;A&lt;/code&gt; のように機能します。最初の &lt;code&gt;b&lt;/code&gt; インデックスは、バッチメンバーにインデックスを付けます。すべてのバッチインデックス &lt;code&gt;(i1,...,ib)&lt;/code&gt; 、 &lt;code&gt;A[i1,...,ib, : :]&lt;/code&gt; は &lt;code&gt;N x N&lt;/code&gt; 行列です。この行列 &lt;code&gt;A&lt;/code&gt; は具体化されていませんが、ブロードキャストの目的にはこの形状が関係します。</target>
        </trans-unit>
        <trans-unit id="7036bf9c433fed406d0eb267aee69b2fb875c75f" translate="yes" xml:space="preserve">
          <source>This operator acts like a [batch] lower triangular matrix &lt;code&gt;A&lt;/code&gt; with shape &lt;code&gt;[B1,...,Bb, N, N]&lt;/code&gt; for some &lt;code&gt;b &amp;gt;= 0&lt;/code&gt;. The first &lt;code&gt;b&lt;/code&gt; indices index a batch member. For every batch index &lt;code&gt;(i1,...,ib)&lt;/code&gt;, &lt;code&gt;A[i1,...,ib, : :]&lt;/code&gt; is an &lt;code&gt;N x N&lt;/code&gt; matrix.</source>
          <target state="translated">この演算子は、いくつかの &lt;code&gt;b &amp;gt;= 0&lt;/code&gt; について &lt;code&gt;[B1,...,Bb, N, N]&lt;/code&gt; 形状[B1、...、Bb、N、N]を持つ[バッチ]下三角行列 &lt;code&gt;A&lt;/code&gt; のように機能します。最初の &lt;code&gt;b&lt;/code&gt; インデックスは、バッチメンバーにインデックスを付けます。すべてのバッチインデックス &lt;code&gt;(i1,...,ib)&lt;/code&gt; 、 &lt;code&gt;A[i1,...,ib, : :]&lt;/code&gt; は &lt;code&gt;N x N&lt;/code&gt; 行列です。</target>
        </trans-unit>
        <trans-unit id="0d5825859d807d72eb10161ef6b5b940c6fe0b9b" translate="yes" xml:space="preserve">
          <source>This operator acts like a [batch] matrix &lt;code&gt;A&lt;/code&gt; with shape &lt;code&gt;[B1,...,Bb, M, N]&lt;/code&gt; for some &lt;code&gt;b &amp;gt;= 0&lt;/code&gt;. The first &lt;code&gt;b&lt;/code&gt; indices index a batch member. For every batch index &lt;code&gt;(i1,...,ib)&lt;/code&gt;, &lt;code&gt;A[i1,...,ib, : :]&lt;/code&gt; is an &lt;code&gt;M x N&lt;/code&gt; matrix.</source>
          <target state="translated">この演算子は、いくつかの &lt;code&gt;b &amp;gt;= 0&lt;/code&gt; について &lt;code&gt;[B1,...,Bb, M, N]&lt;/code&gt; 形状[B1、...、Bb、M、N]を持つ[バッチ]行列 &lt;code&gt;A&lt;/code&gt; のように機能します。最初の &lt;code&gt;b&lt;/code&gt; インデックスは、バッチメンバーにインデックスを付けます。すべてのバッチインデックス &lt;code&gt;(i1,...,ib)&lt;/code&gt; 、 &lt;code&gt;A[i1,...,ib, : :]&lt;/code&gt; は &lt;code&gt;M x N&lt;/code&gt; 行列です。</target>
        </trans-unit>
        <trans-unit id="6f99131310964b3eb6cd5147dace10a254e9fff2" translate="yes" xml:space="preserve">
          <source>This operator acts like a [batch] of householder reflections with shape &lt;code&gt;[B1,...,Bb, N, N]&lt;/code&gt; for some &lt;code&gt;b &amp;gt;= 0&lt;/code&gt;. The first &lt;code&gt;b&lt;/code&gt; indices index a batch member. For every batch index &lt;code&gt;(i1,...,ib)&lt;/code&gt;, &lt;code&gt;A[i1,...,ib, : :]&lt;/code&gt; is an &lt;code&gt;N x N&lt;/code&gt; matrix. This matrix &lt;code&gt;A&lt;/code&gt; is not materialized, but for purposes of broadcasting this shape will be relevant.</source>
          <target state="translated">この演算子は、いくつかの &lt;code&gt;b &amp;gt;= 0&lt;/code&gt; について &lt;code&gt;[B1,...,Bb, N, N]&lt;/code&gt; 形状[B1、...、Bb、N、N]を持つ世帯主反射の[バッチ]のように機能します。最初の &lt;code&gt;b&lt;/code&gt; インデックスは、バッチメンバーにインデックスを付けます。すべてのバッチインデックス &lt;code&gt;(i1,...,ib)&lt;/code&gt; 、 &lt;code&gt;A[i1,...,ib, : :]&lt;/code&gt; は &lt;code&gt;N x N&lt;/code&gt; 行列です。この行列 &lt;code&gt;A&lt;/code&gt; は具体化されていませんが、ブロードキャストの目的にはこの形状が関係します。</target>
        </trans-unit>
        <trans-unit id="2c9497726784db48f14f606b75baa3af89ad92c3" translate="yes" xml:space="preserve">
          <source>This operator acts like a [batch] of permutations with shape &lt;code&gt;[B1,...,Bb, N, N]&lt;/code&gt; for some &lt;code&gt;b &amp;gt;= 0&lt;/code&gt;. The first &lt;code&gt;b&lt;/code&gt; indices index a batch member. For every batch index &lt;code&gt;(i1,...,ib)&lt;/code&gt;, &lt;code&gt;A[i1,...,ib, : :]&lt;/code&gt; is an &lt;code&gt;N x N&lt;/code&gt; matrix. This matrix &lt;code&gt;A&lt;/code&gt; is not materialized, but for purposes of broadcasting this shape will be relevant.</source>
          <target state="translated">この演算子は、いくつかの &lt;code&gt;b &amp;gt;= 0&lt;/code&gt; について &lt;code&gt;[B1,...,Bb, N, N]&lt;/code&gt; 形状[B1、...、Bb、N、N]を持つ順列の[バッチ]のように機能します。最初の &lt;code&gt;b&lt;/code&gt; インデックスは、バッチメンバーにインデックスを付けます。すべてのバッチインデックス &lt;code&gt;(i1,...,ib)&lt;/code&gt; 、 &lt;code&gt;A[i1,...,ib, : :]&lt;/code&gt; は &lt;code&gt;N x N&lt;/code&gt; 行列です。この行列 &lt;code&gt;A&lt;/code&gt; は具体化されていませんが、ブロードキャストの目的にはこの形状が関係します。</target>
        </trans-unit>
        <trans-unit id="583ba682dbf34a68e239431a7d0b3d3bb383323a" translate="yes" xml:space="preserve">
          <source>This operator acts like a [batch] square tridiagonal matrix &lt;code&gt;A&lt;/code&gt; with shape &lt;code&gt;[B1,...,Bb, N, N]&lt;/code&gt; for some &lt;code&gt;b &amp;gt;= 0&lt;/code&gt;. The first &lt;code&gt;b&lt;/code&gt; indices index a batch member. For every batch index &lt;code&gt;(i1,...,ib)&lt;/code&gt;, &lt;code&gt;A[i1,...,ib, : :]&lt;/code&gt; is an &lt;code&gt;N x M&lt;/code&gt; matrix. This matrix &lt;code&gt;A&lt;/code&gt; is not materialized, but for purposes of broadcasting this shape will be relevant.</source>
          <target state="translated">This operator acts like a [batch] square tridiagonal matrix &lt;code&gt;A&lt;/code&gt; with shape &lt;code&gt;[B1,...,Bb, N, N]&lt;/code&gt; for some &lt;code&gt;b &amp;gt;= 0&lt;/code&gt; . The first &lt;code&gt;b&lt;/code&gt; indices index a batch member. For every batch index &lt;code&gt;(i1,...,ib)&lt;/code&gt; , &lt;code&gt;A[i1,...,ib, : :]&lt;/code&gt; is an &lt;code&gt;N x M&lt;/code&gt; matrix. This matrix &lt;code&gt;A&lt;/code&gt; is not materialized, but for purposes of broadcasting this shape will be relevant.</target>
        </trans-unit>
        <trans-unit id="400eb5597c413c726e34a9f1e1bb7b69ea62bb78" translate="yes" xml:space="preserve">
          <source>This operator acts like a [batch] zero matrix &lt;code&gt;A&lt;/code&gt; with shape &lt;code&gt;[B1,...,Bb, N, M]&lt;/code&gt; for some &lt;code&gt;b &amp;gt;= 0&lt;/code&gt;. The first &lt;code&gt;b&lt;/code&gt; indices index a batch member. For every batch index &lt;code&gt;(i1,...,ib)&lt;/code&gt;, &lt;code&gt;A[i1,...,ib, : :]&lt;/code&gt; is an &lt;code&gt;N x M&lt;/code&gt; matrix. This matrix &lt;code&gt;A&lt;/code&gt; is not materialized, but for purposes of broadcasting this shape will be relevant.</source>
          <target state="translated">この演算子は、いくつかの &lt;code&gt;b &amp;gt;= 0&lt;/code&gt; &lt;code&gt;[B1,...,Bb, N, M]&lt;/code&gt; 形状[B1、...、Bb、N、M]を持つ[バッチ]ゼロ行列 &lt;code&gt;A&lt;/code&gt; のように機能します。最初の &lt;code&gt;b&lt;/code&gt; インデックスは、バッチメンバーにインデックスを付けます。すべてのバッチインデックス &lt;code&gt;(i1,...,ib)&lt;/code&gt; 、 &lt;code&gt;A[i1,...,ib, : :]&lt;/code&gt; は &lt;code&gt;N x M&lt;/code&gt; 行列です。この行列 &lt;code&gt;A&lt;/code&gt; は具体化されていませんが、ブロードキャストの目的にはこの形状が関係します。</target>
        </trans-unit>
        <trans-unit id="b7102c53ecb6c13af874ea168315014a6e7dc84b" translate="yes" xml:space="preserve">
          <source>This operator acts like a block circulant matrix &lt;code&gt;A&lt;/code&gt; with shape &lt;code&gt;[B1,...,Bb, N, N]&lt;/code&gt; for some &lt;code&gt;b &amp;gt;= 0&lt;/code&gt;. The first &lt;code&gt;b&lt;/code&gt; indices index a batch member. For every batch index &lt;code&gt;(i1,...,ib)&lt;/code&gt;, &lt;code&gt;A[i1,...,ib, : :]&lt;/code&gt; is an &lt;code&gt;N x N&lt;/code&gt; matrix. This matrix &lt;code&gt;A&lt;/code&gt; is not materialized, but for purposes of broadcasting this shape will be relevant.</source>
          <target state="translated">この演算子は、いくつかの &lt;code&gt;b &amp;gt;= 0&lt;/code&gt; に対して &lt;code&gt;[B1,...,Bb, N, N]&lt;/code&gt; 形状[B1、...、Bb、N、N]を持つブロック循環行列 &lt;code&gt;A&lt;/code&gt; のように機能します。最初の &lt;code&gt;b&lt;/code&gt; インデックスは、バッチメンバーにインデックスを付けます。すべてのバッチインデックス &lt;code&gt;(i1,...,ib)&lt;/code&gt; 、 &lt;code&gt;A[i1,...,ib, : :]&lt;/code&gt; は &lt;code&gt;N x N&lt;/code&gt; 行列です。この行列 &lt;code&gt;A&lt;/code&gt; は具体化されていませんが、ブロードキャストの目的にはこの形状が関係します。</target>
        </trans-unit>
        <trans-unit id="4c216274d20b8ffa480f3dfffdabad95ff0cda74" translate="yes" xml:space="preserve">
          <source>This operator acts like a circulant matrix &lt;code&gt;A&lt;/code&gt; with shape &lt;code&gt;[B1,...,Bb, N, N]&lt;/code&gt; for some &lt;code&gt;b &amp;gt;= 0&lt;/code&gt;. The first &lt;code&gt;b&lt;/code&gt; indices index a batch member. For every batch index &lt;code&gt;(i1,...,ib)&lt;/code&gt;, &lt;code&gt;A[i1,...,ib, : :]&lt;/code&gt; is an &lt;code&gt;N x N&lt;/code&gt; matrix. This matrix &lt;code&gt;A&lt;/code&gt; is not materialized, but for purposes of broadcasting this shape will be relevant.</source>
          <target state="translated">この演算子は、いくつかの &lt;code&gt;b &amp;gt;= 0&lt;/code&gt; に対して &lt;code&gt;[B1,...,Bb, N, N]&lt;/code&gt; 形状[B1、...、Bb、N、N]を持つ循環行列 &lt;code&gt;A&lt;/code&gt; のように機能します。最初の &lt;code&gt;b&lt;/code&gt; インデックスは、バッチメンバーにインデックスを付けます。すべてのバッチインデックス &lt;code&gt;(i1,...,ib)&lt;/code&gt; 、 &lt;code&gt;A[i1,...,ib, : :]&lt;/code&gt; は &lt;code&gt;N x N&lt;/code&gt; 行列です。この行列 &lt;code&gt;A&lt;/code&gt; は具体化されていませんが、ブロードキャストの目的にはこの形状が関係します。</target>
        </trans-unit>
        <trans-unit id="0f0a750eb3c4adb095723453eef766bb4bcd89f8" translate="yes" xml:space="preserve">
          <source>This operator acts like a scaled [batch] identity matrix &lt;code&gt;A&lt;/code&gt; with shape &lt;code&gt;[B1,...,Bb, N, N]&lt;/code&gt; for some &lt;code&gt;b &amp;gt;= 0&lt;/code&gt;. The first &lt;code&gt;b&lt;/code&gt; indices index a batch member. For every batch index &lt;code&gt;(i1,...,ib)&lt;/code&gt;, &lt;code&gt;A[i1,...,ib, : :]&lt;/code&gt; is a scaled version of the &lt;code&gt;N x N&lt;/code&gt; identity matrix.</source>
          <target state="translated">この演算子は、いくつかの &lt;code&gt;b &amp;gt;= 0&lt;/code&gt; に対して &lt;code&gt;[B1,...,Bb, N, N]&lt;/code&gt; 形状[B1、...、Bb、N、N]を持つスケーリングされた[バッチ]単位行列 &lt;code&gt;A&lt;/code&gt; のように機能します。最初の &lt;code&gt;b&lt;/code&gt; インデックスは、バッチメンバーにインデックスを付けます。すべてのバッチインデックス &lt;code&gt;(i1,...,ib)&lt;/code&gt; 、 &lt;code&gt;A[i1,...,ib, : :]&lt;/code&gt; は、 &lt;code&gt;N x N&lt;/code&gt; 単位行列のスケーリングされたバージョンです。</target>
        </trans-unit>
        <trans-unit id="8b1442fc44774d80a4540791883d0146d00de836" translate="yes" xml:space="preserve">
          <source>This operator acts on [batch] matrix with compatible shape. &lt;code&gt;x&lt;/code&gt; is a batch matrix with compatible shape for &lt;code&gt;matmul&lt;/code&gt; and &lt;code&gt;solve&lt;/code&gt; if</source>
          <target state="translated">この演算子は、互換性のある形状の[バッチ]マトリックスに作用します。 &lt;code&gt;x&lt;/code&gt; はに適合形状でバッチ行列で &lt;code&gt;matmul&lt;/code&gt; と &lt;code&gt;solve&lt;/code&gt; 場合</target>
        </trans-unit>
        <trans-unit id="a4840abea8050987eeb44a958dc938a96dc5772f" translate="yes" xml:space="preserve">
          <source>This operator acts on batch matrices with compatible shape. FILL IN WHAT IS MEANT BY COMPATIBLE SHAPE</source>
          <target state="translated">この演算子は、互換性のある形状を持つバッチ行列に対して動作します。互換性のある形状の意味を記入してください。</target>
        </trans-unit>
        <trans-unit id="5cfb7dc84da5837b6c81afa0e3c1dd415d37bda4" translate="yes" xml:space="preserve">
          <source>This operator broadcasts the batch dimensions of &lt;code&gt;bands&lt;/code&gt; and the batch dimensions of &lt;code&gt;rhs&lt;/code&gt;.</source>
          <target state="translated">This operator broadcasts the batch dimensions of &lt;code&gt;bands&lt;/code&gt; and the batch dimensions of &lt;code&gt;rhs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="53228a3fac3cf2f50966b1ada24ef3b0466deb1e" translate="yes" xml:space="preserve">
          <source>This operator combines one or more linear operators &lt;code&gt;[op1,...,opJ]&lt;/code&gt;, building a new &lt;code&gt;LinearOperator&lt;/code&gt;, whose underlying matrix representation is square and has each operator &lt;code&gt;opi&lt;/code&gt; on the main diagonal, and zero's elsewhere.</source>
          <target state="translated">この演算子は、1つ以上の線形演算子 &lt;code&gt;[op1,...,opJ]&lt;/code&gt; &lt;code&gt;LinearOperator&lt;/code&gt; 、新しいLinearOperatorを構築します。その基になる行列表現は正方であり、各演算子 &lt;code&gt;opi&lt;/code&gt; は主対角線上にあり、他の場所にはゼロがあります。</target>
        </trans-unit>
        <trans-unit id="564367f646774e8a861547adb060150a45779d5f" translate="yes" xml:space="preserve">
          <source>This operator composes one or more linear operators &lt;code&gt;[op1,...,opJ]&lt;/code&gt;, building a new &lt;code&gt;LinearOperator&lt;/code&gt; representing the Kronecker product: &lt;code&gt;op1 x op2 x .. opJ&lt;/code&gt; (we omit parentheses as the Kronecker product is associative).</source>
          <target state="translated">この演算子は、1つ以上の線形演算子 &lt;code&gt;[op1,...,opJ]&lt;/code&gt; を作成し、Kronecker積を表す新しい &lt;code&gt;LinearOperator&lt;/code&gt; を作成します： &lt;code&gt;op1 x op2 x .. opJ&lt;/code&gt; （Kronecker積は結合的であるため、括弧を省略します）。</target>
        </trans-unit>
        <trans-unit id="0c0d85ebac206e74618bf7317ca7c96fff15c835" translate="yes" xml:space="preserve">
          <source>This operator composes one or more linear operators &lt;code&gt;[op1,...,opJ]&lt;/code&gt;, building a new &lt;code&gt;LinearOperator&lt;/code&gt; with action defined by:</source>
          <target state="translated">この演算子は、1つ以上の線形演算子 &lt;code&gt;[op1,...,opJ]&lt;/code&gt; を構成し、次のように定義されたアクションを持つ新しい &lt;code&gt;LinearOperator&lt;/code&gt; を構築します。</target>
        </trans-unit>
        <trans-unit id="8e7241eaa8846c5c4338cb18a140b07ab3b606ae" translate="yes" xml:space="preserve">
          <source>This operator corresponds to a real matrix if and only if &lt;code&gt;H&lt;/code&gt; is Hermitian.</source>
          <target state="translated">この演算子は、 &lt;code&gt;H&lt;/code&gt; がエルミート行列である場合に限り、実数行列に対応します。</target>
        </trans-unit>
        <trans-unit id="6f9242e838252063460c0276fd01dfac0ef01ff4" translate="yes" xml:space="preserve">
          <source>This operator corresponds to a real-valued matrix if and only if its spectrum is Hermitian.</source>
          <target state="translated">この演算子は、スペクトルがエルミシアンである場合に限り、実数行列に対応します。</target>
        </trans-unit>
        <trans-unit id="3bcff2453a32e7e855e1bf28e92cc09521b4d919" translate="yes" xml:space="preserve">
          <source>This operator has two modes: in one mode both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are provided, in another mode neither are provided. &lt;code&gt;condition&lt;/code&gt; is always expected to be a &lt;a href=&quot;tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt; of type &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="translated">This operator has two modes: in one mode both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are provided, in another mode neither are provided. &lt;code&gt;condition&lt;/code&gt; is always expected to be a &lt;a href=&quot;tensor&quot;&gt; &lt;code&gt;tf.Tensor&lt;/code&gt; &lt;/a&gt; of type &lt;code&gt;bool&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c618e51b272c823eef5139b9cc3a948f981f98e8" translate="yes" xml:space="preserve">
          <source>This operator is able to broadcast the leading (batch) dimensions, which sometimes requires copying data. If &lt;code&gt;batch_shape&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;, the operator can take arguments of any batch shape without copying. See examples.</source>
          <target state="translated">このオペレーターは、主要な（バッチ）ディメンションをブロードキャストできます。これには、データのコピーが必要な場合があります。場合 &lt;code&gt;batch_shape&lt;/code&gt; はありません &lt;code&gt;None&lt;/code&gt; 、オペレータは、コピーせずに任意のバッチの形の引数を取ることができます。例を参照してください。</target>
        </trans-unit>
        <trans-unit id="66cb218ad1e2e8f68e038b90d3bfb45bd6e74e63" translate="yes" xml:space="preserve">
          <source>This operator is able to broadcast the leading (batch) dimensions.</source>
          <target state="translated">このオペレータは、先行(バッチ)寸法をブロードキャストすることができます。</target>
        </trans-unit>
        <trans-unit id="348a23cb6559c85829c515ac4244685e0efb46f2" translate="yes" xml:space="preserve">
          <source>This operator is considered non-singular if</source>
          <target state="translated">この演算子は</target>
        </trans-unit>
        <trans-unit id="b5e0ce71bd6146dbac079f3d21ad0a2a2a8c2054" translate="yes" xml:space="preserve">
          <source>This operator is initialized with a nested list of linear operators, which are combined into a new &lt;code&gt;LinearOperator&lt;/code&gt; whose underlying matrix representation is square and has each operator on or below the main diagonal, and zero's elsewhere. Each element of the outer list is a list of &lt;code&gt;LinearOperators&lt;/code&gt; corresponding to a row-partition of the blockwise structure. The number of &lt;code&gt;LinearOperator&lt;/code&gt;s in row-partion &lt;code&gt;i&lt;/code&gt; must be equal to &lt;code&gt;i&lt;/code&gt;.</source>
          <target state="translated">This operator is initialized with a nested list of linear operators, which are combined into a new &lt;code&gt;LinearOperator&lt;/code&gt; whose underlying matrix representation is square and has each operator on or below the main diagonal, and zero's elsewhere. Each element of the outer list is a list of &lt;code&gt;LinearOperators&lt;/code&gt; corresponding to a row-partition of the blockwise structure. The number of &lt;code&gt;LinearOperator&lt;/code&gt; s in row-partion &lt;code&gt;i&lt;/code&gt; must be equal to &lt;code&gt;i&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d06a5054c0e8f5a488a0e50140ca1317d8ee8b76" translate="yes" xml:space="preserve">
          <source>This operator is positive definite if and only if &lt;code&gt;Real{H} &amp;gt; 0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Real{H} &amp;gt; 0&lt;/code&gt; 場合にのみ、この演算子は正定です。</target>
        </trans-unit>
        <trans-unit id="fa787331edbdbf77b6543a837e62e8acfa555fdd" translate="yes" xml:space="preserve">
          <source>This operator is self-adjoint if and only if &lt;code&gt;H&lt;/code&gt; is real.</source>
          <target state="translated">この演算子は、 &lt;code&gt;H&lt;/code&gt; が実数の場合にのみ自己随伴です。</target>
        </trans-unit>
        <trans-unit id="0434efb4cb6fe37aceabe23ccb563dea7d82d49a" translate="yes" xml:space="preserve">
          <source>This operator is similar to the unsorted segment sum operator found &lt;a href=&quot;https://www.tensorflow.org/api_docs/api_docs/python/math_ops#UnsortedSegmentSum&quot;&gt;(here)&lt;/a&gt;. Instead of computing the sum over segments, it computes the maximum such that:</source>
          <target state="translated">この演算子は、&lt;a href=&quot;https://www.tensorflow.org/api_docs/api_docs/python/math_ops#UnsortedSegmentSum&quot;&gt;（ここ）&lt;/a&gt;にある未ソートのセグメント合計演算子に似ています。セグメントの合計を計算する代わりに、次のような最大値を計算します。</target>
        </trans-unit>
        <trans-unit id="f0203b5b1fedf802a969aad64e740ba2ad439f1c" translate="yes" xml:space="preserve">
          <source>This operator is similar to the unsorted segment sum operator found &lt;a href=&quot;https://www.tensorflow.org/api_docs/api_docs/python/math_ops#UnsortedSegmentSum&quot;&gt;(here)&lt;/a&gt;. Instead of computing the sum over segments, it computes the minimum such that:</source>
          <target state="translated">この演算子は、&lt;a href=&quot;https://www.tensorflow.org/api_docs/api_docs/python/math_ops#UnsortedSegmentSum&quot;&gt;（ここ）&lt;/a&gt;にある未ソートのセグメント合計演算子に似ています。セグメントの合計を計算する代わりに、次のような最小値を計算します。</target>
        </trans-unit>
        <trans-unit id="9b525fce235ebc8f800bcb2ded78049fa74f120a" translate="yes" xml:space="preserve">
          <source>This operator is similar to the unsorted segment sum operator found &lt;a href=&quot;https://www.tensorflow.org/api_docs/api_docs/python/math_ops#UnsortedSegmentSum&quot;&gt;(here)&lt;/a&gt;. Instead of computing the sum over segments, it computes the product of all entries belonging to a segment such that:</source>
          <target state="translated">この演算子は、&lt;a href=&quot;https://www.tensorflow.org/api_docs/api_docs/python/math_ops#UnsortedSegmentSum&quot;&gt;（ここ）&lt;/a&gt;にある未ソートのセグメント合計演算子に似ています。セグメントの合計を計算する代わりに、次のようなセグメントに属するすべてのエントリの積を計算します。</target>
        </trans-unit>
        <trans-unit id="59fd9e153dcbd12bffedb241b5f88000e9237c11" translate="yes" xml:space="preserve">
          <source>This operator is similar to the unsorted segment sum operator found &lt;a href=&quot;https://www.tensorflow.org/api_docs/api_docs/python/math_ops#UnsortedSegmentSum&quot;&gt;here&lt;/a&gt;. Additionally to computing the sum over segments, it divides the results by sqrt(N).</source>
          <target state="translated">この演算子は、&lt;a href=&quot;https://www.tensorflow.org/api_docs/api_docs/python/math_ops#UnsortedSegmentSum&quot;&gt;ここ&lt;/a&gt;にある未ソートのセグメント合計演算子に似ています。セグメントの合計を計算することに加えて、結果をsqrt（N）で除算します。</target>
        </trans-unit>
        <trans-unit id="a4a7cb1afea6269197bd76bbd4732c1dbecdf7fc" translate="yes" xml:space="preserve">
          <source>This operator is similar to the unsorted segment sum operator found &lt;a href=&quot;https://www.tensorflow.org/api_docs/api_docs/python/math_ops#UnsortedSegmentSum&quot;&gt;here&lt;/a&gt;. Instead of computing the sum over segments, it computes the mean of all entries belonging to a segment such that:</source>
          <target state="translated">この演算子は、&lt;a href=&quot;https://www.tensorflow.org/api_docs/api_docs/python/math_ops#UnsortedSegmentSum&quot;&gt;ここ&lt;/a&gt;にある未ソートのセグメント合計演算子に似ています。セグメント全体の合計を計算する代わりに、次のようなセグメントに属するすべてのエントリの平均を計算します。</target>
        </trans-unit>
        <trans-unit id="52ed4dad04ede72e0a76f0501a2814cdc539eef1" translate="yes" xml:space="preserve">
          <source>This operator is similar to the unsorted segment sum operator found &lt;a href=&quot;https://www.tensorflow.org/versions/r2.3/api_docs/api_docs/python/math_ops#UnsortedSegmentSum&quot;&gt;(here)&lt;/a&gt;. Instead of computing the sum over segments, it computes the maximum such that:</source>
          <target state="translated">This operator is similar to the unsorted segment sum operator found &lt;a href=&quot;https://www.tensorflow.org/versions/r2.3/api_docs/api_docs/python/math_ops#UnsortedSegmentSum&quot;&gt;(here)&lt;/a&gt;. Instead of computing the sum over segments, it computes the maximum such that:</target>
        </trans-unit>
        <trans-unit id="d5555cd5610bd14e5cd5be64e806dbe517b909cf" translate="yes" xml:space="preserve">
          <source>This operator is similar to the unsorted segment sum operator found &lt;a href=&quot;https://www.tensorflow.org/versions/r2.3/api_docs/api_docs/python/math_ops#UnsortedSegmentSum&quot;&gt;(here)&lt;/a&gt;. Instead of computing the sum over segments, it computes the minimum such that:</source>
          <target state="translated">この演算子は、&lt;a href=&quot;https://www.tensorflow.org/versions/r2.3/api_docs/api_docs/python/math_ops#UnsortedSegmentSum&quot;&gt;（ここで）&lt;/a&gt;見つかったソートされていないセグメント合計演算子に似ています。セグメント全体の合計を計算する代わりに、次のように最小値を計算します。</target>
        </trans-unit>
        <trans-unit id="5626f77bd1ee157ca8ad5f5950e88d3290b6e7a5" translate="yes" xml:space="preserve">
          <source>This operator is similar to the unsorted segment sum operator found &lt;a href=&quot;https://www.tensorflow.org/versions/r2.3/api_docs/api_docs/python/math_ops#UnsortedSegmentSum&quot;&gt;(here)&lt;/a&gt;. Instead of computing the sum over segments, it computes the product of all entries belonging to a segment such that:</source>
          <target state="translated">この演算子は、&lt;a href=&quot;https://www.tensorflow.org/versions/r2.3/api_docs/api_docs/python/math_ops#UnsortedSegmentSum&quot;&gt;（ここで）&lt;/a&gt;見つかったソートされていないセグメント合計演算子に似ています。セグメント全体の合計を計算する代わりに、次のようにセグメントに属するすべてのエントリの積を計算します。</target>
        </trans-unit>
        <trans-unit id="b4490e7220bb7e840d8af406c98df4879f8c31ca" translate="yes" xml:space="preserve">
          <source>This operator is similar to the unsorted segment sum operator found &lt;a href=&quot;https://www.tensorflow.org/versions/r2.3/api_docs/api_docs/python/math_ops#UnsortedSegmentSum&quot;&gt;here&lt;/a&gt;. Additionally to computing the sum over segments, it divides the results by sqrt(N).</source>
          <target state="translated">この演算子は、&lt;a href=&quot;https://www.tensorflow.org/versions/r2.3/api_docs/api_docs/python/math_ops#UnsortedSegmentSum&quot;&gt;ここ&lt;/a&gt;にあるソートされていないセグメント合計演算子に似ています。セグメント全体の合計を計算することに加えて、結果をsqrt（N）で除算します。</target>
        </trans-unit>
        <trans-unit id="5fcc2d9bddedbecbae737fa85ec20cea5d89c2f2" translate="yes" xml:space="preserve">
          <source>This operator is similar to the unsorted segment sum operator found &lt;a href=&quot;https://www.tensorflow.org/versions/r2.3/api_docs/api_docs/python/math_ops#UnsortedSegmentSum&quot;&gt;here&lt;/a&gt;. Instead of computing the sum over segments, it computes the mean of all entries belonging to a segment such that:</source>
          <target state="translated">この演算子は、&lt;a href=&quot;https://www.tensorflow.org/versions/r2.3/api_docs/api_docs/python/math_ops#UnsortedSegmentSum&quot;&gt;ここ&lt;/a&gt;にあるソートされていないセグメント合計演算子に似ています。セグメント全体の合計を計算する代わりに、次のようにセグメントに属するすべてのエントリの平均を計算します。</target>
        </trans-unit>
        <trans-unit id="83929e057e5aae77fa1c5e82493e5f81ffd7c7d5" translate="yes" xml:space="preserve">
          <source>This operator represents the adjoint of another operator.</source>
          <target state="translated">この演算子は、別の演算子のアドジョイントを表します。</target>
        </trans-unit>
        <trans-unit id="011faa1fcbdac7f7db43d7798ee8f420d25df1c3" translate="yes" xml:space="preserve">
          <source>This operator represents the inverse of another operator.</source>
          <target state="translated">この演算子は、別の演算子の逆数を表します。</target>
        </trans-unit>
        <trans-unit id="d243b49a16809ba508894c3eb53aaf2744d8ff3a" translate="yes" xml:space="preserve">
          <source>This operator represents the loop termination condition used by the &quot;pivot&quot; switches of a loop.</source>
          <target state="translated">この演算子は、ループの「ピボット」スイッチで使用されるループ終了条件を表します。</target>
        </trans-unit>
        <trans-unit id="efbc958735ecb1b79fddfae66e71db4081b1ceb7" translate="yes" xml:space="preserve">
          <source>This operator takes the given &lt;code&gt;SparseTensor&lt;/code&gt; and adds it to a container object (a &lt;code&gt;SparseTensorsMap&lt;/code&gt;). A unique key within this container is generated in the form of an &lt;code&gt;int64&lt;/code&gt;, and this is the value that is returned.</source>
          <target state="translated">この演算子は、指定された &lt;code&gt;SparseTensor&lt;/code&gt; を取得し、それをコンテナオブジェクト（ &lt;code&gt;SparseTensorsMap&lt;/code&gt; ）に追加します。このコンテナ内の一意のキーは &lt;code&gt;int64&lt;/code&gt; の形式で生成され、これが返される値です。</target>
        </trans-unit>
        <trans-unit id="8beab818ce538eb5919197a98807ea337b127bd0" translate="yes" xml:space="preserve">
          <source>This operator tries to squeeze as much precision as possible into an output with a lower bit depth by calculating the actual min and max values found in the data. For example, maybe that quint16 input has no values lower than 16,384 and none higher than 49,152. That means only half the range is actually needed, all the float interpretations are between -0.5f and 0.5f, so if we want to compress the data into a quint8 output, we can use that range rather than the theoretical -1.0f to 1.0f that is suggested by the input min and max.</source>
          <target state="translated">この演算子は、データ中の実際の最小値と最大値を計算することで、より低いビット深度の出力に可能な限り多くの精度を絞り込もうとします。例えば、quint16の入力には16,384より低い値はなく、49,152より高い値はありません。つまり、実際に必要とされる範囲は半分だけであり、すべての浮動小数点演算は-0.5f から 0.5f の間にあるので、データを quint8 出力に圧縮したい場合は、入力の min と max によって提案される理論的な -1.0f から 1.0f の範囲ではなく、その範囲を使用することができます。</target>
        </trans-unit>
        <trans-unit id="caac5d3bbf4d0945a7bd985970cd4106cce90915" translate="yes" xml:space="preserve">
          <source>This operator wraps a [batch] matrix &lt;code&gt;A&lt;/code&gt; (which is a &lt;code&gt;Tensor&lt;/code&gt;) with shape &lt;code&gt;[B1,...,Bb, M, N]&lt;/code&gt; for some &lt;code&gt;b &amp;gt;= 0&lt;/code&gt;. The first &lt;code&gt;b&lt;/code&gt; indices index a batch member. For every batch index &lt;code&gt;(i1,...,ib)&lt;/code&gt;, &lt;code&gt;A[i1,...,ib, : :]&lt;/code&gt; is an &lt;code&gt;M x N&lt;/code&gt; matrix.</source>
          <target state="translated">この演算子は、いくつかの &lt;code&gt;b &amp;gt;= 0&lt;/code&gt; について、[バッチ]マトリックス &lt;code&gt;A&lt;/code&gt; （ &lt;code&gt;Tensor&lt;/code&gt; ）を形状 &lt;code&gt;[B1,...,Bb, M, N]&lt;/code&gt; でラップします。最初の &lt;code&gt;b&lt;/code&gt; インデックスは、バッチメンバーにインデックスを付けます。すべてのバッチインデックス &lt;code&gt;(i1,...,ib)&lt;/code&gt; 、 &lt;code&gt;A[i1,...,ib, : :]&lt;/code&gt; は &lt;code&gt;M x N&lt;/code&gt; 行列です。</target>
        </trans-unit>
        <trans-unit id="b7a64029550dddacbaa84a5c9b1e8fcd91b9538b" translate="yes" xml:space="preserve">
          <source>This optimizer class is &lt;a href=&quot;../../distribute/strategy&quot;&gt;&lt;code&gt;tf.distribute.Strategy&lt;/code&gt;&lt;/a&gt; aware, which means it automatically sums gradients across all replicas. To average gradients, you divide your loss by the global batch size, which is done automatically if you use &lt;a href=&quot;../../keras&quot;&gt;&lt;code&gt;tf.keras&lt;/code&gt;&lt;/a&gt; built-in training or evaluation loops. See the &lt;code&gt;reduction&lt;/code&gt; argument of your loss which should be set to &lt;a href=&quot;../losses/reduction#SUM_OVER_BATCH_SIZE&quot;&gt;&lt;code&gt;tf.keras.losses.Reduction.SUM_OVER_BATCH_SIZE&lt;/code&gt;&lt;/a&gt; for averaging or &lt;a href=&quot;../losses/reduction#SUM&quot;&gt;&lt;code&gt;tf.keras.losses.Reduction.SUM&lt;/code&gt;&lt;/a&gt; for not.</source>
          <target state="translated">このオプティマイザクラスは&lt;a href=&quot;../../distribute/strategy&quot;&gt; &lt;code&gt;tf.distribute.Strategy&lt;/code&gt; &lt;/a&gt;対応です。つまり、すべてのレプリカの勾配を自動的に合計します。勾配を平均化するには、損失をグローバルバッチサイズで割ります。これは、&lt;a href=&quot;../../keras&quot;&gt; &lt;code&gt;tf.keras&lt;/code&gt; &lt;/a&gt;組み込みのトレーニングループまたは評価ループを使用する場合に自動的に行われます。参照 &lt;code&gt;reduction&lt;/code&gt; に設定する必要があり、あなたの損失の引数&lt;a href=&quot;../losses/reduction#SUM_OVER_BATCH_SIZE&quot;&gt; &lt;code&gt;tf.keras.losses.Reduction.SUM_OVER_BATCH_SIZE&lt;/code&gt; &lt;/a&gt;平均化またはのために&lt;a href=&quot;../losses/reduction#SUM&quot;&gt; &lt;code&gt;tf.keras.losses.Reduction.SUM&lt;/code&gt; &lt;/a&gt;ないために。</target>
        </trans-unit>
        <trans-unit id="f9ca3ab79a1177cb06784d426253ffabbbc2a6a4" translate="yes" xml:space="preserve">
          <source>This optimizer takes care of regularization of unseen features in a mini batch by updating them when they are seen with a closed form update rule that is equivalent to having updated them on every mini-batch.</source>
          <target state="translated">このオプティマイザは、ミニバッチ内の見られない特徴を、ミニバッチごとに更新したのと同等のクローズドフォーム更新ルールで見られたときに更新することで、ミニバッチ内の見られない特徴の規則化をケアします。</target>
        </trans-unit>
        <trans-unit id="9a8b5c268bde39d241894c5b95721103ebdbc425" translate="yes" xml:space="preserve">
          <source>This optimizer wraps another optimizer and applies loss scaling to it via a &lt;code&gt;LossScale&lt;/code&gt;. Loss scaling is applied whenever gradients are computed, either through &lt;code&gt;minimize()&lt;/code&gt; or &lt;code&gt;get_gradients()&lt;/code&gt;. The loss scale is updated via &lt;a href=&quot;../../../mixed_precision/experimental/lossscale#update&quot;&gt;&lt;code&gt;LossScale.update()&lt;/code&gt;&lt;/a&gt; whenever gradients are applied, either through &lt;code&gt;minimize()&lt;/code&gt; or &lt;code&gt;apply_gradients()&lt;/code&gt;. For example:</source>
          <target state="translated">このオプティマイザーは別のオプティマイザーをラップし、 &lt;code&gt;LossScale&lt;/code&gt; を介してそれにロススケーリングを適用します。損失のスケーリングは、 &lt;code&gt;minimize()&lt;/code&gt; または &lt;code&gt;get_gradients()&lt;/code&gt; によって勾配が計算されるときに適用されます。損失スケールは、 &lt;code&gt;minimize()&lt;/code&gt; または &lt;code&gt;apply_gradients()&lt;/code&gt; のいずれかを使用してグラデーションが適用されるたびに&lt;a href=&quot;../../../mixed_precision/experimental/lossscale#update&quot;&gt; &lt;code&gt;LossScale.update()&lt;/code&gt; &lt;/a&gt;を介して更新されます。例えば：</target>
        </trans-unit>
        <trans-unit id="a13f36128710145f1603618c3c0bcd6462911f2d" translate="yes" xml:space="preserve">
          <source>This optimizer wraps another optimizer and applies loss scaling to it via a &lt;code&gt;LossScale&lt;/code&gt;. Loss scaling is applied whenever gradients are computed, such as through &lt;code&gt;minimize()&lt;/code&gt;.</source>
          <target state="translated">このオプティマイザーは別のオプティマイザーをラップし、 &lt;code&gt;LossScale&lt;/code&gt; を介してそれにロススケーリングを適用します。損失のスケーリングは、 &lt;code&gt;minimize()&lt;/code&gt; などを通じて勾配が計算されるときに適用されます。</target>
        </trans-unit>
        <trans-unit id="64e321c394397e96aca6614583438da557ccee0e" translate="yes" xml:space="preserve">
          <source>This option can be used to override the default policy for how to handle external state when serializing a dataset or checkpointing its iterator. There are three settings available - IGNORE: in which we completely ignore any state; WARN: We warn the user that some state might be thrown away; FAIL: We fail if any state is being captured.</source>
          <target state="translated">このオプションは、データセットをシリアライズしたり、イテレータをチェックポイントしたりする際に、外部の状態をどのように扱うかについてのデフォルトのポリシーをオーバーライドするために使用できます。IGNORE:あらゆる状態を完全に無視します。WARN:状態が捨てられる可能性があることを警告します。FAIL:何らかの状態が捕捉されている場合に失敗します。</target>
        </trans-unit>
        <trans-unit id="fa77eb4223231696da9576378f71e5fd1b4c5fa1" translate="yes" xml:space="preserve">
          <source>This outputs a &lt;code&gt;batch_size&lt;/code&gt; bool array, an entry &lt;code&gt;out[i]&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; if the prediction for the target class is among the top &lt;code&gt;k&lt;/code&gt; predictions among all predictions for example &lt;code&gt;i&lt;/code&gt;. Note that the behavior of &lt;code&gt;InTopK&lt;/code&gt; differs from the &lt;code&gt;TopK&lt;/code&gt; op in its handling of ties; if multiple classes have the same prediction value and straddle the top-&lt;code&gt;k&lt;/code&gt; boundary, all of those classes are considered to be in the top &lt;code&gt;k&lt;/code&gt;.</source>
          <target state="translated">これにより、 &lt;code&gt;batch_size&lt;/code&gt; ブール配列が出力されます。ターゲットクラスの予測がすべての予測の上位 &lt;code&gt;k&lt;/code&gt; 個の予測（たとえば &lt;code&gt;i&lt;/code&gt; )に含まれる場合、エントリ &lt;code&gt;out[i]&lt;/code&gt; は &lt;code&gt;true&lt;/code&gt; になります。注の行動その &lt;code&gt;InTopK&lt;/code&gt; の異なるの &lt;code&gt;TopK&lt;/code&gt; 絆の取り扱いにおけるオペアンプ。複数のクラスが同じ予測値を持っているし、トップまたぐ場合は &lt;code&gt;k&lt;/code&gt; 個の境界を、それらのクラスのすべてがトップにあるとみなされ &lt;code&gt;k&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="43b5cb445e044712f2e69a5344f02f5be0ddda93" translate="yes" xml:space="preserve">
          <source>This outputs a &lt;code&gt;batch_size&lt;/code&gt; bool array, an entry &lt;code&gt;out[i]&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; if the prediction for the target class is finite (not inf, -inf, or nan) and among the top &lt;code&gt;k&lt;/code&gt; predictions among all predictions for example &lt;code&gt;i&lt;/code&gt;. Note that the behavior of &lt;code&gt;InTopK&lt;/code&gt; differs from the &lt;code&gt;TopK&lt;/code&gt; op in its handling of ties; if multiple classes have the same prediction value and straddle the top-&lt;code&gt;k&lt;/code&gt; boundary, all of those classes are considered to be in the top &lt;code&gt;k&lt;/code&gt;.</source>
          <target state="translated">これは、 &lt;code&gt;batch_size&lt;/code&gt; bool配列を出力します。ターゲットクラスの予測が有限（inf、-inf、nanではない）であり、すべての予測（たとえば &lt;code&gt;i&lt;/code&gt; ）のうち上位 &lt;code&gt;k&lt;/code&gt; の予測の場合、エントリ &lt;code&gt;out[i]&lt;/code&gt; は &lt;code&gt;true&lt;/code&gt; です。 &lt;code&gt;InTopK&lt;/code&gt; の動作は、 &lt;code&gt;TopK&lt;/code&gt; 処理においてTopK op とは異なることに注意してください。複数のクラスが同じ予測値を持っているし、トップまたぐ場合は &lt;code&gt;k&lt;/code&gt; 個の境界を、それらのクラスのすべてがトップにあるとみなされ &lt;code&gt;k&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="345380820e023cc35c074a4e6039205226041719" translate="yes" xml:space="preserve">
          <source>This overload raises a &lt;code&gt;TypeError&lt;/code&gt; when the user inadvertently treats a &lt;code&gt;Tensor&lt;/code&gt; as a boolean (most commonly in an &lt;code&gt;if&lt;/code&gt; or &lt;code&gt;while&lt;/code&gt; statement), in code that was not converted by AutoGraph. For example:</source>
          <target state="translated">このオーバーロードは、AutoGraphによって変換されなかったコードで、ユーザーが誤って &lt;code&gt;Tensor&lt;/code&gt; をブール値（最も一般的には &lt;code&gt;if&lt;/code&gt; または &lt;code&gt;while&lt;/code&gt; ステートメント）として処理した場合に &lt;code&gt;TypeError&lt;/code&gt; を発生させます。例えば：</target>
        </trans-unit>
        <trans-unit id="5f63c68c6b6d06032eeae666e8d05a28d8b6e750" translate="yes" xml:space="preserve">
          <source>This package defines ops for manipulating ragged tensors (&lt;a href=&quot;../../raggedtensor&quot;&gt;&lt;code&gt;tf.RaggedTensor&lt;/code&gt;&lt;/a&gt;), which are tensors with non-uniform shapes. In particular, each &lt;code&gt;RaggedTensor&lt;/code&gt; has one or more &lt;em&gt;ragged dimensions&lt;/em&gt;, which are dimensions whose slices may have different lengths. For example, the inner (column) dimension of &lt;code&gt;rt=[[3, 1, 4, 1], [], [5, 9, 2], [6], []]&lt;/code&gt; is ragged, since the column slices (&lt;code&gt;rt[0, :]&lt;/code&gt;, ..., &lt;code&gt;rt[4, :]&lt;/code&gt;) have different lengths. For a more detailed description of ragged tensors, see the &lt;a href=&quot;../../raggedtensor&quot;&gt;&lt;code&gt;tf.RaggedTensor&lt;/code&gt;&lt;/a&gt; class documentation and the &lt;a href=&quot;https://www.tensorflow.org/guide/ragged_tensors&quot;&gt;Ragged Tensor Guide&lt;/a&gt;.</source>
          <target state="translated">このパッケージは、不均一な形状のテンソルである不規則なテンソル（&lt;a href=&quot;../../raggedtensor&quot;&gt; &lt;code&gt;tf.RaggedTensor&lt;/code&gt; &lt;/a&gt;）を操作するためのopsを定義します。特に、各 &lt;code&gt;RaggedTensor&lt;/code&gt; には1つ以上の&lt;em&gt;不規則な次元&lt;/em&gt;があります。これは、スライスの長さが異なる可能性のある次元です。たとえば、 &lt;code&gt;rt=[[3, 1, 4, 1], [], [5, 9, 2], [6], []]&lt;/code&gt; 5、9、2 ]、[6]、[]]の内部（列）ディメンションは、列がスライス（ &lt;code&gt;rt[0, :]&lt;/code&gt; 、...、 &lt;code&gt;rt[4, :]&lt;/code&gt; ）は長さが異なります。不規則なテンソルの詳細については、&lt;a href=&quot;../../raggedtensor&quot;&gt; &lt;code&gt;tf.RaggedTensor&lt;/code&gt; &lt;/a&gt;クラスのドキュメントと&lt;a href=&quot;https://www.tensorflow.org/guide/ragged_tensors&quot;&gt;Ragged Tensor Guideを&lt;/a&gt;ご覧ください。</target>
        </trans-unit>
        <trans-unit id="3e4f0989d73eb8b679bcdf7fff408eece47a531f" translate="yes" xml:space="preserve">
          <source>This package defines ops for manipulating ragged tensors (&lt;a href=&quot;raggedtensor&quot;&gt;&lt;code&gt;tf.RaggedTensor&lt;/code&gt;&lt;/a&gt;), which are tensors with non-uniform shapes. In particular, each &lt;code&gt;RaggedTensor&lt;/code&gt; has one or more &lt;em&gt;ragged dimensions&lt;/em&gt;, which are dimensions whose slices may have different lengths. For example, the inner (column) dimension of &lt;code&gt;rt=[[3, 1, 4, 1], [], [5, 9, 2], [6], []]&lt;/code&gt; is ragged, since the column slices (&lt;code&gt;rt[0, :]&lt;/code&gt;, ..., &lt;code&gt;rt[4, :]&lt;/code&gt;) have different lengths. For a more detailed description of ragged tensors, see the &lt;a href=&quot;raggedtensor&quot;&gt;&lt;code&gt;tf.RaggedTensor&lt;/code&gt;&lt;/a&gt; class documentation and the &lt;a href=&quot;https://www.tensorflow.org/guide/ragged_tensors&quot;&gt;Ragged Tensor Guide&lt;/a&gt;.</source>
          <target state="translated">このパッケージは、不均一な形状のテンソルである不規則なテンソル（&lt;a href=&quot;raggedtensor&quot;&gt; &lt;code&gt;tf.RaggedTensor&lt;/code&gt; &lt;/a&gt;）を操作するためのopsを定義します。特に、各 &lt;code&gt;RaggedTensor&lt;/code&gt; には1つ以上の&lt;em&gt;不規則な次元&lt;/em&gt;があります。これは、スライスの長さが異なる可能性のある次元です。たとえば、 &lt;code&gt;rt=[[3, 1, 4, 1], [], [5, 9, 2], [6], []]&lt;/code&gt; 5、9、2 ]、[6]、[]]の内部（列）ディメンションは、列がスライス（ &lt;code&gt;rt[0, :]&lt;/code&gt; 、...、 &lt;code&gt;rt[4, :]&lt;/code&gt; ）は長さが異なります。不規則なテンソルの詳細については、&lt;a href=&quot;raggedtensor&quot;&gt; &lt;code&gt;tf.RaggedTensor&lt;/code&gt; &lt;/a&gt;クラスのドキュメントと&lt;a href=&quot;https://www.tensorflow.org/guide/ragged_tensors&quot;&gt;Ragged Tensor Guideを&lt;/a&gt;ご覧ください。</target>
        </trans-unit>
        <trans-unit id="ca381bc7587c1d86ccea71cf77a3f51f18c01785" translate="yes" xml:space="preserve">
          <source>This partitioner will shard a Variable along one axis, attempting to keep the maximum shard size below &lt;code&gt;max_shard_bytes&lt;/code&gt;. In practice, this is not always possible when sharding along only one axis. When this happens, this axis is sharded as much as possible (i.e., every dimension becomes a separate shard).</source>
          <target state="translated">このパーティショナーは、変数を1つの軸に沿って分割し、最大分割サイズを &lt;code&gt;max_shard_bytes&lt;/code&gt; 未満に維持しようとします。実際には、1つの軸のみに沿ってシャーディングする場合、これは常に可能とは限りません。これが発生すると、この軸は可能な限り分割されます（つまり、すべての次元が個別の分割になります）。</target>
        </trans-unit>
        <trans-unit id="fd457ac6c886ad4d6a9b1c2c9ed70e07ea8ad467" translate="yes" xml:space="preserve">
          <source>This produces files called &quot;timeline-</source>
          <target state="translated">これにより、&quot;timeline-line &quot;と呼ばれるファイルが生成されます。</target>
        </trans-unit>
        <trans-unit id="9f7b45ed5e5688563844dafc256f1f022fd16e33" translate="yes" xml:space="preserve">
          <source>This property only works when the &lt;code&gt;TPUEmbedding&lt;/code&gt; object is created under a non-TPU strategy. This is intended to be used to for CPU based lookup when creating a serving checkpoint.</source>
          <target state="translated">このプロパティは、 &lt;code&gt;TPUEmbedding&lt;/code&gt; オブジェクトが非TPU戦略で作成された場合にのみ機能します。これは、サービングチェックポイントを作成するときにCPUベースのルックアップに使用することを目的としています。</target>
        </trans-unit>
        <trans-unit id="650852868a3688b5e43945d526af2b7a7abb7659" translate="yes" xml:space="preserve">
          <source>This regressor ignores feature values and will learn to predict the average value of each label.</source>
          <target state="translated">この回帰器は特徴量を無視し、各ラベルの平均値を予測することを学習します。</target>
        </trans-unit>
        <trans-unit id="6b4e11e2fc93d180cb8cb79e60f96113138df290" translate="yes" xml:space="preserve">
          <source>This returns a ClusterSpec object for use based on information from the specified initialization parameters and Slurm environment variables. The cluster specification is resolved each time this function is called. The resolver extract hostnames of nodes by scontrol and pack tasks in that order until a node a has number of tasks that is equal to specification. GPUs on nodes are allocated to tasks by specification through setting CUDA_VISIBLE_DEVICES environment variable.</source>
          <target state="translated">指定した初期化パラメータとSlurm環境変数の情報に基づいて使用するClusterSpecオブジェクトを返します。クラスタ仕様は、この関数が呼ばれるたびに解決されます。リゾルバはscontrolでノードのホスト名を抽出し、あるノードが仕様と同じ数のタスクを持つようになるまで順にタスクを詰めていきます。ノード上のGPUは、CUDA_VISIBLE_DEVICES環境変数を設定することで、仕様に応じてタスクに割り当てられます。</target>
        </trans-unit>
        <trans-unit id="ce42bdd47f55adee51dc4ae146a85efc32785746" translate="yes" xml:space="preserve">
          <source>This returns a ClusterSpec object for use based on information from the specified instance group. We will retrieve the information from the GCE APIs every time this method is called.</source>
          <target state="translated">指定したインスタンスグループからの情報に基づいて使用するClusterSpecオブジェクトを返します。このメソッドが呼ばれるたびにGCE APIから情報を取得します。</target>
        </trans-unit>
        <trans-unit id="d4e36425f3d932370ce3f31b5b37e6bd2c5dbb8b" translate="yes" xml:space="preserve">
          <source>This returns a function outputting &lt;code&gt;features&lt;/code&gt; and &lt;code&gt;targets&lt;/code&gt; based on the dict of numpy arrays. The dict &lt;code&gt;features&lt;/code&gt; has the same keys as the &lt;code&gt;x&lt;/code&gt;. The dict &lt;code&gt;targets&lt;/code&gt; has the same keys as the &lt;code&gt;y&lt;/code&gt; if &lt;code&gt;y&lt;/code&gt; is a dict.</source>
          <target state="translated">これは、numpy配列のdictに基づいて &lt;code&gt;features&lt;/code&gt; と &lt;code&gt;targets&lt;/code&gt; を出力する関数を返します。dict &lt;code&gt;features&lt;/code&gt; は、 &lt;code&gt;x&lt;/code&gt; と同じキーがあります。 &lt;code&gt;y&lt;/code&gt; がdictの場合、dict &lt;code&gt;targets&lt;/code&gt; は &lt;code&gt;y&lt;/code&gt; と同じキーを持ちます。</target>
        </trans-unit>
        <trans-unit id="091f487524e5d0cdc7f2f7122f0e27fecc0512d2" translate="yes" xml:space="preserve">
          <source>This returns the job name and task index for the process which calls this function according to its rank and cluster specification. The job name and task index are set after a cluster is constructed by cluster_spec otherwise defaults to None.</source>
          <target state="translated">この関数は、この関数を呼び出したプロセスのジョブ名とタスクインデックスを、そのランクとクラスタ仕様に従って返します。ジョブ名とタスクインデックスは cluster_spec によってクラスタが構築された後に設定されます。</target>
        </trans-unit>
        <trans-unit id="9e86e167f9dfaedec2287e6304deddcf9a677504" translate="yes" xml:space="preserve">
          <source>This returns the number of accelerator cores (such as GPUs and TPUs) available per worker.</source>
          <target state="translated">これは、ワーカーごとに利用可能なアクセラレータコア(GPUやTPUなど)の数を返します。</target>
        </trans-unit>
        <trans-unit id="43f97f599a6e5c9f5b6d870e441e77232b9c4ee2" translate="yes" xml:space="preserve">
          <source>This sampler is useful when the target classes approximately follow such a distribution - for example, if the classes represent words in a lexicon sorted in decreasing order of frequency. If your classes are not ordered by decreasing frequency, do not use this op.</source>
          <target state="translated">このサンプラーは,対象となるクラスがほぼこのような分布に従う場合に便利です.例えば,クラスが頻度の低い順に並べ替えられた辞書の単語を表している場合などです.クラスが頻度の低い順に並べ替えられていない場合は,このオプを使用しないでください.</target>
        </trans-unit>
        <trans-unit id="f4116f5a13b723775fce909b3d142c6ace24a3f4" translate="yes" xml:space="preserve">
          <source>This set may grow over time, so it's important the signature of creators is as mentioned above.</source>
          <target state="translated">このセットは時間の経過とともに成長する可能性があるので、上記のようにクリエイターのサインが重要です。</target>
        </trans-unit>
        <trans-unit id="642d4b5b813040e42f63e66f6c2fcb5de77a52c5" translate="yes" xml:space="preserve">
          <source>This should only be used when the if then/else body functions do not have stateful ops.</source>
          <target state="translated">これは、if then/elseボディ関数がステートフル演算を持っていない場合にのみ使用されます。</target>
        </trans-unit>
        <trans-unit id="5fc235c555c96c210745b72880b680aa6b17dbdb" translate="yes" xml:space="preserve">
          <source>This should only be used when the while condition and body functions do not have stateful ops.</source>
          <target state="translated">これは、while条件とボディ関数がステートフルな演算を持っていない場合にのみ使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="6fe6f784df295b3702cbf845894c09377130127e" translate="yes" xml:space="preserve">
          <source>This simply wraps &lt;code&gt;compute_gradients()&lt;/code&gt; from the real optimizer. The gradients will be aggregated in &lt;code&gt;apply_gradients()&lt;/code&gt; so that user can modify the gradients like clipping with per replica global norm if needed. The global norm with aggregated gradients can be bad as one replica's huge gradients can hurt the gradients from other replicas.</source>
          <target state="translated">これは、実際のオプティマイザからの &lt;code&gt;compute_gradients()&lt;/code&gt; をラップするだけです。グラデーションは &lt;code&gt;apply_gradients()&lt;/code&gt; に集約されるため、ユーザーは必要に応じてレプリカごとのグローバルノルムでクリッピングのようにグラデーションを変更できます。1つのレプリカの巨大な勾配が他のレプリカの勾配を損なう可能性があるため、勾配が集約されたグローバルノルムは悪い場合があります。</target>
        </trans-unit>
        <trans-unit id="8231e710a02b190ee62057d8ce9e6843f584733f" translate="yes" xml:space="preserve">
          <source>This simply wraps the compute_gradients() from the real optimizer. The gradients will be aggregated in the apply_gradients() so that user can modify the gradients like clipping with per replica global norm if needed. The global norm with aggregated gradients can be bad as one replica's huge gradients can hurt the gradients from other replicas.</source>
          <target state="translated">これは、実際のオプティマイザのcompute_gradients()を単純にラップしたものです。グラデーションは apply_gradients()で集約されるので、必要に応じてレプリカごとのグローバルノルムでクリッピングなどのグラデーションを変更することができます。グラディエントを集約したグローバルノルムは、あるレプリカの巨大なグラディエントが他のレプリカのグラディエントを傷つけてしまう可能性があるため、よくありません。</target>
        </trans-unit>
        <trans-unit id="9535c2c156931877173be6ce0ef4fcc7c39ade4d" translate="yes" xml:space="preserve">
          <source>This simply wraps the get_slot() from the actual optimizer.</source>
          <target state="translated">これは単に実際のオプティマイザから get_slot()をラップしているだけです。</target>
        </trans-unit>
        <trans-unit id="627b6a914c45360f47c7270bf7239e5630834ac1" translate="yes" xml:space="preserve">
          <source>This simply wraps the get_slot_names() from the actual optimizer.</source>
          <target state="translated">これは、実際のオプティマイザの get_slot_names()を単純にラップしています。</target>
        </trans-unit>
        <trans-unit id="481aba790f7180557002a29e34e41b2834d82d24" translate="yes" xml:space="preserve">
          <source>This starts services in the background. The services started depend on the parameters to the constructor and may include:</source>
          <target state="translated">これはバックグラウンドでサービスを開始します。起動するサービスはコンストラクタのパラメータに依存し、以下のようなものがあります。</target>
        </trans-unit>
        <trans-unit id="61ba97b856d34fcc84e3cd4a4201db78d7018540" translate="yes" xml:space="preserve">
          <source>This strategy implements synchronous distributed training across multiple workers, each with potentially multiple GPUs. Similar to &lt;a href=&quot;../../../../distribute/mirroredstrategy&quot;&gt;&lt;code&gt;tf.distribute.MirroredStrategy&lt;/code&gt;&lt;/a&gt;, it creates copies of all variables in the model on each device across all workers.</source>
          <target state="translated">この戦略は、複数のGPUを使用する可能性のある複数のワーカーに同期分散トレーニングを実装します。&lt;a href=&quot;../../../../distribute/mirroredstrategy&quot;&gt; &lt;code&gt;tf.distribute.MirroredStrategy&lt;/code&gt; &lt;/a&gt;と同様に、すべてのワーカーの各デバイスのモデルにすべての変数のコピーを作成します。</target>
        </trans-unit>
        <trans-unit id="f19046d3b0cb6c64ecb2b4f8764cc9d33c4854f1" translate="yes" xml:space="preserve">
          <source>This strategy implements synchronous distributed training across multiple workers, each with potentially multiple GPUs. Similar to &lt;a href=&quot;../mirroredstrategy&quot;&gt;&lt;code&gt;tf.distribute.MirroredStrategy&lt;/code&gt;&lt;/a&gt;, it creates copies of all variables in the model on each device across all workers.</source>
          <target state="translated">この戦略は、複数のGPUを使用する可能性のある複数のワーカーに同期分散トレーニングを実装します。&lt;a href=&quot;../mirroredstrategy&quot;&gt; &lt;code&gt;tf.distribute.MirroredStrategy&lt;/code&gt; &lt;/a&gt;と同様に、すべてのワーカーの各デバイスのモデルにすべての変数のコピーを作成します。</target>
        </trans-unit>
        <trans-unit id="04f8a8d0444c29ec6e24f3fc468a55853c986597" translate="yes" xml:space="preserve">
          <source>This strategy is typically used for training on one machine with multiple GPUs. For TPUs, use &lt;a href=&quot;../../../distribute/tpustrategy&quot;&gt;&lt;code&gt;tf.distribute.TPUStrategy&lt;/code&gt;&lt;/a&gt;. To use &lt;code&gt;MirroredStrategy&lt;/code&gt; with multiple workers, please refer to &lt;a href=&quot;../../../distribute/experimental/multiworkermirroredstrategy&quot;&gt;&lt;code&gt;tf.distribute.experimental.MultiWorkerMirroredStrategy&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この戦略は通常、複数のGPUを搭載した1台のマシンでのトレーニングに使用されます。TPUの場合は、&lt;a href=&quot;../../../distribute/tpustrategy&quot;&gt; &lt;code&gt;tf.distribute.TPUStrategy&lt;/code&gt; を&lt;/a&gt;使用します。複数のワーカーで &lt;code&gt;MirroredStrategy&lt;/code&gt; を使用するには、&lt;a href=&quot;../../../distribute/experimental/multiworkermirroredstrategy&quot;&gt; &lt;code&gt;tf.distribute.experimental.MultiWorkerMirroredStrategy&lt;/code&gt; &lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="7c008960642435f7f796dcc4d6d07c58ad8a9370" translate="yes" xml:space="preserve">
          <source>This strategy is typically used for training on one machine with multiple GPUs. For TPUs, use &lt;a href=&quot;tpustrategy&quot;&gt;&lt;code&gt;tf.distribute.TPUStrategy&lt;/code&gt;&lt;/a&gt;. To use &lt;code&gt;MirroredStrategy&lt;/code&gt; with multiple workers, please refer to &lt;a href=&quot;experimental/multiworkermirroredstrategy&quot;&gt;&lt;code&gt;tf.distribute.experimental.MultiWorkerMirroredStrategy&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この戦略は通常、複数のGPUを搭載した1台のマシンでのトレーニングに使用されます。TPUの場合は、&lt;a href=&quot;tpustrategy&quot;&gt; &lt;code&gt;tf.distribute.TPUStrategy&lt;/code&gt; を&lt;/a&gt;使用します。複数のワーカーで &lt;code&gt;MirroredStrategy&lt;/code&gt; を使用するには、&lt;a href=&quot;experimental/multiworkermirroredstrategy&quot;&gt; &lt;code&gt;tf.distribute.experimental.MultiWorkerMirroredStrategy&lt;/code&gt; &lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="648f5d6b8ceebd17f689c7c0ab8ef16660a7747c" translate="yes" xml:space="preserve">
          <source>This strategy requires two jobs: workers and parameter servers. Variables and updates to those variables will be assigned to parameter servers and other operations are assigned to workers.</source>
          <target state="translated">この戦略では、ワーカーとパラメータサーバの2つのジョブが必要になります。変数とその変数への更新はパラメータサーバに割り当てられ、他の操作はワーカーに割り当てられます。</target>
        </trans-unit>
        <trans-unit id="e44a68c24a5012e2f287321dc3d6da6b35bca174" translate="yes" xml:space="preserve">
          <source>This strategy requires two roles: workers and parameter servers. Variables and updates to those variables will be assigned to parameter servers and other operations are assigned to workers.</source>
          <target state="translated">この戦略では、ワーカーとパラメータサーバの2つの役割が必要です。変数とその変数への更新はパラメータサーバに割り当てられ、他の操作はワーカーに割り当てられる。</target>
        </trans-unit>
        <trans-unit id="609b539c1ba8e5fb73c25fa137b65336a8f05b90" translate="yes" xml:space="preserve">
          <source>This strategy uses one replica per device and sync replication for its multi-GPU version.</source>
          <target state="translated">この戦略では、デバイスごとに1つのレプリカを使用し、そのマルチGPU版では同期レプリケーションを使用します。</target>
        </trans-unit>
        <trans-unit id="a028b1379398bc12b06afc7b36060473f028c25d" translate="yes" xml:space="preserve">
          <source>This symbol is also exported to v2 in tf.estimator namespace. See &lt;a href=&quot;https://github.com/tensorflow/estimator/blob/master/tensorflow_estimator/python/estimator/hooks/basic_session_run_hooks.py&quot;&gt;https://github.com/tensorflow/estimator/blob/master/tensorflow_estimator/python/estimator/hooks/basic_session_run_hooks.py&lt;/a&gt;</source>
          <target state="translated">このシンボルは、tf.estimator名前空間のv2にもエクスポートされます。&lt;a href=&quot;https://github.com/tensorflow/estimator/blob/master/tensorflow_estimator/python/estimator/hooks/basic_session_run_hooks.py&quot;&gt;https://github.com/tensorflow/estimator/blob/master/tensorflow_estimator/python/estimator/hooks/basic_session_run_hooks.pyを&lt;/a&gt;参照してください</target>
        </trans-unit>
        <trans-unit id="f77a1c7f27ca177eb5967fdc02f021a08479ef96" translate="yes" xml:space="preserve">
          <source>This symbol is also exported to v2 in tf.estimator namespace. See https://github.com/tensorflow/estimator/blob/master/tensorflow_estimator/python/estimator/hooks/basic_session_run_hooks.py</source>
          <target state="translated">このシンボルは、tf.estimator名前空間のv2にもエクスポートされています。https://github.com/tensorflow/estimator/blob/master/tensorflow_estimator/python/estimator/hooks/basic_session_run_hooks.py を参照してください。</target>
        </trans-unit>
        <trans-unit id="ee30a785484036470f77ee9c09ff132832518ed4" translate="yes" xml:space="preserve">
          <source>This takes an ordinary &lt;code&gt;dataset&lt;/code&gt; and &lt;code&gt;replica_fn&lt;/code&gt; and runs it distributed using a particular &lt;a href=&quot;strategy&quot;&gt;&lt;code&gt;tf.distribute.Strategy&lt;/code&gt;&lt;/a&gt; named &lt;code&gt;my_strategy&lt;/code&gt; above. Any variables created in &lt;code&gt;replica_fn&lt;/code&gt; are created using &lt;code&gt;my_strategy&lt;/code&gt;'s policy, and library functions called by &lt;code&gt;replica_fn&lt;/code&gt; can use the &lt;code&gt;get_replica_context()&lt;/code&gt; API to implement distributed-specific behavior.</source>
          <target state="translated">これは通常の &lt;code&gt;dataset&lt;/code&gt; と &lt;code&gt;replica_fn&lt;/code&gt; を &lt;code&gt;my_strategy&lt;/code&gt; 上記の&lt;a href=&quot;strategy&quot;&gt; &lt;code&gt;tf.distribute.Strategy&lt;/code&gt; &lt;/a&gt;という名前の特定のtf.distribute.Strategyを使用して分散して実行します。で作成されたすべての変数 &lt;code&gt;replica_fn&lt;/code&gt; を使用して作成され &lt;code&gt;my_strategy&lt;/code&gt; の方針、およびによって呼び出されるライブラリ関数 &lt;code&gt;replica_fn&lt;/code&gt; 使用することができます &lt;code&gt;get_replica_context()&lt;/code&gt; 分散固有の動作を実装するためのAPIを。</target>
        </trans-unit>
        <trans-unit id="f43e50d6d041bdda53ec0ccc184fa3940b822601" translate="yes" xml:space="preserve">
          <source>This takes in a few parameters and creates a GCEClusterResolver project. It will then use these parameters to query the GCE API for the IP addresses of each instance in the instance group.</source>
          <target state="translated">これは、いくつかのパラメータを取り込み、GCEClusterResolver プロジェクトを作成します。次に、これらのパラメータを使用して、インスタンスグループ内の各インスタンスの IP アドレスのために GCE API をクエリーします。</target>
        </trans-unit>
        <trans-unit id="dcbb15c135f93b202dd4afc6d928c452a899b686" translate="yes" xml:space="preserve">
          <source>This takes in parameters and creates a SlurmClusterResolver object. It uses those parameters to check which nodes will processes reside on and resolves their hostnames. With the number of the GPUs on each node and number of GPUs for each task it offsets the port number for each process and allocates GPUs to tasks by setting environment variables. The resolver currently supports homogeneous tasks and default Slurm process allocation.</source>
          <target state="translated">これはパラメータを受け取り、SlurmClusterResolverオブジェクトを作成します。これらのパラメータを使用して、プロセスがどのノードに存在するかをチェックし、そのホスト名を解決します。各ノード上のGPUの数と各タスクのGPUの数から、各プロセスのポート番号をオフセットし、環境変数を設定してタスクにGPUを割り当てます。リゾルバは現在、同種タスクとデフォルトのSlurmプロセス割り当てをサポートしています。</target>
        </trans-unit>
        <trans-unit id="c32e52f6772f69af41778414a120795e360f2147" translate="yes" xml:space="preserve">
          <source>This thread class is intended to be used with a &lt;code&gt;Coordinator&lt;/code&gt;. It repeatedly runs code specified either as &lt;code&gt;target&lt;/code&gt; and &lt;code&gt;args&lt;/code&gt; or by the &lt;code&gt;run_loop()&lt;/code&gt; method.</source>
          <target state="translated">このスレッドクラスは、 &lt;code&gt;Coordinator&lt;/code&gt; で使用するためのものです。 &lt;code&gt;target&lt;/code&gt; と &lt;code&gt;args&lt;/code&gt; として、または &lt;code&gt;run_loop()&lt;/code&gt; メソッドによって指定されたコードを繰り返し実行します。</target>
        </trans-unit>
        <trans-unit id="cbe44aae232eb7beccd1bb717d150f53dfed09d2" translate="yes" xml:space="preserve">
          <source>This tracking then allows saving variable values to &lt;a href=&quot;https://www.tensorflow.org/guide/checkpoint&quot;&gt;training checkpoints&lt;/a&gt;, or to &lt;a href=&quot;https://www.tensorflow.org/guide/saved_model&quot;&gt;SavedModels&lt;/a&gt; which include serialized TensorFlow graphs.</source>
          <target state="translated">この追跡は、その後に変数の値を保存することができ&lt;a href=&quot;https://www.tensorflow.org/guide/checkpoint&quot;&gt;、トレーニングチェックポイント&lt;/a&gt;、またはに&lt;a href=&quot;https://www.tensorflow.org/guide/saved_model&quot;&gt;SavedModels&lt;/a&gt;シリアライズTensorFlowグラフを含みます。</target>
        </trans-unit>
        <trans-unit id="84d3d178d35882538e5cb6113338132ed1567a47" translate="yes" xml:space="preserve">
          <source>This transformation applies &lt;code&gt;map_func&lt;/code&gt; to each element of this dataset, and returns a new dataset containing the transformed elements, in the same order as they appeared in the input. &lt;code&gt;map_func&lt;/code&gt; can be used to change both the values and the structure of a dataset's elements. For example, adding 1 to each element, or projecting a subset of element components.</source>
          <target state="translated">この変換では、 &lt;code&gt;map_func&lt;/code&gt; をこのデータセットの各要素に適用し、変換された要素を含む新しいデータセットを、入力に現れたのと同じ順序で返します。 &lt;code&gt;map_func&lt;/code&gt; は、データセットの要素の値と構造の両方を変更するために使用できます。たとえば、各要素に1を追加したり、要素コンポーネントのサブセットを投影したりします。</target>
        </trans-unit>
        <trans-unit id="ba79b19e287af6ccbf373678af86969066d66587" translate="yes" xml:space="preserve">
          <source>This transformation checks whether the camel-case names (i.e. &quot;FlatMap&quot;, not &quot;flat_map&quot;) of the transformations following this transformation match the list of names in the &lt;code&gt;transformations&lt;/code&gt; argument. If there is a mismatch, the transformation raises an exception.</source>
          <target state="translated">この変換は、この変換に続く変換のキャメルケース名（つまり、「flat_map」ではなく「FlatMap」）が &lt;code&gt;transformations&lt;/code&gt; 引数の名前のリストと一致するかどうかをチェックします。不一致がある場合、変換によって例外が発生します。</target>
        </trans-unit>
        <trans-unit id="b91ea223c9ec8adff0faaecc5c9b88a252c4af69" translate="yes" xml:space="preserve">
          <source>This transformation combines multiple consecutive elements of the input dataset into a single element.</source>
          <target state="translated">この変換は、入力データセットの複数の連続した要素を1つの要素に結合する。</target>
        </trans-unit>
        <trans-unit id="35f6c3c6efa792b9215faf94c8c00f35d19886a0" translate="yes" xml:space="preserve">
          <source>This transformation is a stateful relative of &lt;a href=&quot;../dataset#map&quot;&gt;&lt;code&gt;tf.data.Dataset.map&lt;/code&gt;&lt;/a&gt;. In addition to mapping &lt;code&gt;scan_func&lt;/code&gt; across the elements of the input dataset, &lt;code&gt;scan()&lt;/code&gt; accumulates one or more state tensors, whose initial values are &lt;code&gt;initial_state&lt;/code&gt;.</source>
          <target state="translated">この変換は、&lt;a href=&quot;../dataset#map&quot;&gt; &lt;code&gt;tf.data.Dataset.map&lt;/code&gt; の&lt;/a&gt;ステートフルな関係です。 &lt;code&gt;scan()&lt;/code&gt; は、入力データセットの要素全体に &lt;code&gt;scan_func&lt;/code&gt; をマッピングすることに加えて、初期値が &lt;code&gt;initial_state&lt;/code&gt; である1つ以上の状態テンソルを蓄積します。</target>
        </trans-unit>
        <trans-unit id="8e7258027c5f693626ed2b2e68a04576c8a8c285" translate="yes" xml:space="preserve">
          <source>This transformation maps each consecutive element in a dataset to a key using &lt;code&gt;key_func&lt;/code&gt; and groups the elements by key. It then applies &lt;code&gt;reduce_func&lt;/code&gt; to at most &lt;code&gt;window_size_func(key)&lt;/code&gt; elements matching the same key. All except the final window for each key will contain &lt;code&gt;window_size_func(key)&lt;/code&gt; elements; the final window may be smaller.</source>
          <target state="translated">この変換では、 &lt;code&gt;key_func&lt;/code&gt; を使用してデータセット内の連続する各要素をキーにマップし、要素をキーごとにグループ化します。次に、同じキーに一致する多くても &lt;code&gt;window_size_func(key)&lt;/code&gt; 要素に &lt;code&gt;reduce_func&lt;/code&gt; を適用します。各キーの最終ウィンドウを除くすべてに &lt;code&gt;window_size_func(key)&lt;/code&gt; 要素が含まれます。最終ウィンドウは小さくなる場合があります。</target>
        </trans-unit>
        <trans-unit id="a21aaa6c0a7b4d11f0bde650d661805100a01ad7" translate="yes" xml:space="preserve">
          <source>This transformation maps element of a dataset to a key using &lt;code&gt;key_func&lt;/code&gt; and groups the elements by key. The &lt;code&gt;reducer&lt;/code&gt; is used to process each group; its &lt;code&gt;init_func&lt;/code&gt; is used to initialize state for each group when it is created, the &lt;code&gt;reduce_func&lt;/code&gt; is used to update the state every time an element is mapped to the matching group, and the &lt;code&gt;finalize_func&lt;/code&gt; is used to map the final state to an output value.</source>
          <target state="translated">この変換では、 &lt;code&gt;key_func&lt;/code&gt; を使用してデータセットの要素をキーにマップし、キーごとに要素をグループ化します。 &lt;code&gt;reducer&lt;/code&gt; 各グループを処理するために使用されます。その &lt;code&gt;init_func&lt;/code&gt; は、作成時に各グループの状態を初期化するために使用され、 &lt;code&gt;reduce_func&lt;/code&gt; は、要素が一致するグループにマップされるたびに状態を更新するために使用され、 &lt;code&gt;finalize_func&lt;/code&gt; は、最終状態を出力値にマップするために使用されます。</target>
        </trans-unit>
        <trans-unit id="24ab6194aaa04fc157672b906f20ba2e1b1ec8cc" translate="yes" xml:space="preserve">
          <source>This updates the checkpoint file containing a CheckpointState proto.</source>
          <target state="translated">CheckpointStateプロトを含むチェックポイントファイルを更新します。</target>
        </trans-unit>
        <trans-unit id="5bb7cb617dbb67bdd4c7f55f6d436fa2f1b33e3c" translate="yes" xml:space="preserve">
          <source>This uses &lt;a href=&quot;../norm&quot;&gt;&lt;code&gt;tf.linalg.norm&lt;/code&gt;&lt;/a&gt; to compute the norm along &lt;code&gt;axis&lt;/code&gt;.</source>
          <target state="translated">これは&lt;a href=&quot;../norm&quot;&gt; &lt;code&gt;tf.linalg.norm&lt;/code&gt; &lt;/a&gt;を使用して &lt;code&gt;axis&lt;/code&gt; 沿ったノルムを計算します。</target>
        </trans-unit>
        <trans-unit id="7945ebd1b4ae121cdd796a53759129e7e59a0846" translate="yes" xml:space="preserve">
          <source>This usually returns the master from the first ClusterResolver passed in, but you can override this by specifying the task_type and task_id.</source>
          <target state="translated">これは通常、最初に渡された ClusterResolver からマスターを返しますが、task_type と task_id を指定することでこれをオーバーライドすることができます。</target>
        </trans-unit>
        <trans-unit id="4285af5e3616d9c051e0b5382ab0649693cc39b6" translate="yes" xml:space="preserve">
          <source>This utility function provides consistent behavior for both local (non-distributed) and distributed configurations. The default distribution configuration is parameter server-based between-graph replication. For other types of distribution configurations such as all-reduce training, please use &lt;a href=&quot;https://github.com/tensorflow/tensorflow/tree/master/tensorflow/contrib/distribute&quot;&gt;DistributionStrategies&lt;/a&gt;.</source>
          <target state="translated">このユーティリティ関数は、ローカル（非分散）構成と分散構成の両方に一貫した動作を提供します。デフォルトの配布構成は、サーバーベースのグラフ間レプリケーションです。all-reduceトレーニングなど、他のタイプの配布構成については、&lt;a href=&quot;https://github.com/tensorflow/tensorflow/tree/master/tensorflow/contrib/distribute&quot;&gt;DistributionStrategies&lt;/a&gt;を使用してください。</target>
        </trans-unit>
        <trans-unit id="50e5c41b60a6dacb228de3d2a27ac083ca26570e" translate="yes" xml:space="preserve">
          <source>This utility function trains, evaluates, and (optionally) exports the model by using the given &lt;code&gt;estimator&lt;/code&gt;. All training related specification is held in &lt;code&gt;train_spec&lt;/code&gt;, including training &lt;code&gt;input_fn&lt;/code&gt; and training max steps, etc. All evaluation and export related specification is held in &lt;code&gt;eval_spec&lt;/code&gt;, including evaluation &lt;code&gt;input_fn&lt;/code&gt;, steps, etc.</source>
          <target state="translated">このユーティリティ関数は、指定された &lt;code&gt;estimator&lt;/code&gt; を使用して、モデルをトレーニング、評価、および（オプションで）エクスポートします。すべてのトレーニング関連の仕様は、 &lt;code&gt;train_spec&lt;/code&gt; に保持されます。これには、トレーニング &lt;code&gt;input_fn&lt;/code&gt; やトレーニングの最大ステップなどが含まれます。評価およびエクスポート関連のすべての仕様は、評価 &lt;code&gt;input_fn&lt;/code&gt; やstepsなどを含む &lt;code&gt;eval_spec&lt;/code&gt; に保持されます。</target>
        </trans-unit>
        <trans-unit id="370bf5deaf68ca405b51cda0b005ed741251919f" translate="yes" xml:space="preserve">
          <source>This utility method replaces the deprecated-in-V2 &lt;code&gt;tf.compat.v1.Dataset.output_classes&lt;/code&gt; property.</source>
          <target state="translated">このユーティリティメソッドは、非推奨のV2の &lt;code&gt;tf.compat.v1.Dataset.output_classes&lt;/code&gt; プロパティを置き換えます。</target>
        </trans-unit>
        <trans-unit id="46213afe2d7d2a75cd43b97252d79901207a3be4" translate="yes" xml:space="preserve">
          <source>This utility method replaces the deprecated-in-V2 &lt;code&gt;tf.compat.v1.Dataset.output_shapes&lt;/code&gt; property.</source>
          <target state="translated">このユーティリティメソッドは、非推奨のV2の &lt;code&gt;tf.compat.v1.Dataset.output_shapes&lt;/code&gt; プロパティを置き換えます。</target>
        </trans-unit>
        <trans-unit id="917e4af53cd9619ae0480dec3aee8643df47493a" translate="yes" xml:space="preserve">
          <source>This utility method replaces the deprecated-in-V2 &lt;code&gt;tf.compat.v1.Dataset.output_types&lt;/code&gt; property.</source>
          <target state="translated">このユーティリティメソッドは、V2で廃止された &lt;code&gt;tf.compat.v1.Dataset.output_types&lt;/code&gt; プロパティを置き換えます。</target>
        </trans-unit>
        <trans-unit id="e1997fea43a5c765a33c5bb8c3d18f8bd998811c" translate="yes" xml:space="preserve">
          <source>This value is ultimately returned as &lt;code&gt;auc&lt;/code&gt;, an idempotent operation that computes the area under a discretized curve of precision versus recall values (computed using the aforementioned variables). The &lt;code&gt;num_thresholds&lt;/code&gt; variable controls the degree of discretization with larger numbers of thresholds more closely approximating the true AUC. The quality of the approximation may vary dramatically depending on &lt;code&gt;num_thresholds&lt;/code&gt;.</source>
          <target state="translated">この値は、最終的に &lt;code&gt;auc&lt;/code&gt; として返されます。これは、精度と再現率の離散化曲線の下の面積を計算するべき等演算です（前述の変数を使用して計算されます）。 &lt;code&gt;num_thresholds&lt;/code&gt; 変数を制御し、より密接に真のAUCを近似しきい値の大きな番号の離散化の度合い。 &lt;code&gt;num_thresholds&lt;/code&gt; によっては、近似の品質が劇的に異なる場合があります。</target>
        </trans-unit>
        <trans-unit id="65677d697851bf6819d55d4ff4251a12696e0771" translate="yes" xml:space="preserve">
          <source>This value is ultimately returned as &lt;code&gt;auc&lt;/code&gt;, an idempotent operation that computes the area under a discretized curve of precision versus recall values (computed using the aforementioned variables). The &lt;code&gt;num_thresholds&lt;/code&gt; variable controls the degree of discretization with larger numbers of thresholds more closely approximating the true AUC. The quality of the approximation may vary dramatically depending on &lt;code&gt;num_thresholds&lt;/code&gt;. The &lt;code&gt;thresholds&lt;/code&gt; parameter can be used to manually specify thresholds which split the predictions more evenly.</source>
          <target state="translated">この値は、最終的に &lt;code&gt;auc&lt;/code&gt; として返されます。これは、精度と再現率の離散化曲線の下の面積を計算するべき等演算です（前述の変数を使用して計算されます）。 &lt;code&gt;num_thresholds&lt;/code&gt; 変数を制御し、より密接に真のAUCを近似しきい値の大きな番号の離散化の度合い。 &lt;code&gt;num_thresholds&lt;/code&gt; によっては、近似の品質が劇的に異なる場合があります。 &lt;code&gt;thresholds&lt;/code&gt; パラメータは、手動でより均等に予測を分割しきい値を指定するために使用することができます。</target>
        </trans-unit>
        <trans-unit id="ca17fcf3f560f3e845deeb7ae0f38bd32e476e10" translate="yes" xml:space="preserve">
          <source>This version enqueues a different list of tensors in different threads. It adds the following to the current &lt;code&gt;Graph&lt;/code&gt;:</source>
          <target state="translated">このバージョンは、異なるスレッドで異なるテンソルのリストをエンキューします。現在の &lt;code&gt;Graph&lt;/code&gt; 以下を追加します。</target>
        </trans-unit>
        <trans-unit id="3dd9104e524c4af8048275ef1cca44df52153ae4" translate="yes" xml:space="preserve">
          <source>This version has support for both online L2 (McMahan et al., 2013) and shrinkage-type L2, which is the addition of an L2 penalty to the loss function.</source>
          <target state="translated">このバージョンでは、オンラインL2(McMahan et al.,2013)と、損失関数にL2ペナルティを追加した縮小型L2の両方をサポートしています。</target>
        </trans-unit>
        <trans-unit id="56d946ffec0b3da9d0ec8b7171e5c9d7eac7532e" translate="yes" xml:space="preserve">
          <source>This version performs the same function as Dropout, however it drops entire 1D feature maps instead of individual elements. If adjacent frames within feature maps are strongly correlated (as is normally the case in early convolution layers) then regular dropout will not regularize the activations and will otherwise just result in an effective learning rate decrease. In this case, SpatialDropout1D will help promote independence between feature maps and should be used instead.</source>
          <target state="translated">このバージョンはドロップアウトと同じ機能を実行しますが、個々の要素ではなく、1 次元特徴マップ全体をドロップアウトします。特徴マップ内の隣接フレームが強く相関している場合(初期の畳み込み層では通常そうです)、通常のドロップアウトでは活性化が規則化されず、そうでなければ効果的な学習率の低下を招くだけです。この場合、SpatialDropout1Dは、特徴マップ間の独立性を促進するのに役立つので、代わりに使用すべきである。</target>
        </trans-unit>
        <trans-unit id="a36f7273ef31d9cbeb00b22a3f221c68cd1e40a0" translate="yes" xml:space="preserve">
          <source>This version performs the same function as Dropout, however it drops entire 2D feature maps instead of individual elements. If adjacent pixels within feature maps are strongly correlated (as is normally the case in early convolution layers) then regular dropout will not regularize the activations and will otherwise just result in an effective learning rate decrease. In this case, SpatialDropout2D will help promote independence between feature maps and should be used instead.</source>
          <target state="translated">このバージョンはドロップアウトと同じ機能を実行しますが、個々の要素ではなく、2 次元特徴量マップ全体をドロップアウトします。特徴マップ内の隣接ピクセルが強く相関している場合(初期の畳み込み層では通常そうです)、通常のドロップアウトでは活性化が規則化されず、そうでなければ効果的な学習率の低下を招くだけです。この場合、SpatialDropout2Dは、特徴マップ間の独立性を促進するのに役立つので、代わりに使用すべきである。</target>
        </trans-unit>
        <trans-unit id="d0ef991814863883d725a0aaf896bf4a46fb3d16" translate="yes" xml:space="preserve">
          <source>This version performs the same function as Dropout, however it drops entire 3D feature maps instead of individual elements. If adjacent voxels within feature maps are strongly correlated (as is normally the case in early convolution layers) then regular dropout will not regularize the activations and will otherwise just result in an effective learning rate decrease. In this case, SpatialDropout3D will help promote independence between feature maps and should be used instead.</source>
          <target state="translated">このバージョンはドロップアウトと同じ機能を持ちますが、個々の要素ではなく、3D特徴量マップ全体をドロップアウトします。特徴マップ内の隣接するボクセルが強く相関している場合(初期の畳み込み層では通常そうです)、通常のドロップアウトでは活性化が規則化されず、そうでなければ効果的な学習率が低下するだけです。この場合、SpatialDropout3Dは、特徴マップ間の独立性を促進するのに役立つので、代わりに使用すべきである。</target>
        </trans-unit>
        <trans-unit id="3b754cc618ce29bdbcce941232103d369933ab97" translate="yes" xml:space="preserve">
          <source>This version performs the same function as Dropout, however, it drops entire 1D feature maps instead of individual elements. If adjacent frames within feature maps are strongly correlated (as is normally the case in early convolution layers) then regular dropout will not regularize the activations and will otherwise just result in an effective learning rate decrease. In this case, SpatialDropout1D will help promote independence between feature maps and should be used instead.</source>
          <target state="translated">このバージョンはドロップアウトと同じ機能を実行しますが、個々の要素ではなく 1 次元特徴量マップ全体をドロップアウトします。特徴マップ内の隣接フレームが強く相関している場合(初期の畳み込み層では通常そうである)、通常のドロップアウトでは活性化が規則化されず、そうでなければ効果的な学習率の低下を招くだけです。この場合、SpatialDropout1Dは、特徴マップ間の独立性を促進するのに役立つので、代わりに使用すべきである。</target>
        </trans-unit>
        <trans-unit id="669d1fce226733b310b6c063bbb1478bd8960685" translate="yes" xml:space="preserve">
          <source>This version performs the same function as Dropout, however, it drops entire 2D feature maps instead of individual elements. If adjacent pixels within feature maps are strongly correlated (as is normally the case in early convolution layers) then regular dropout will not regularize the activations and will otherwise just result in an effective learning rate decrease. In this case, SpatialDropout2D will help promote independence between feature maps and should be used instead.</source>
          <target state="translated">このバージョンはドロップアウトと同じ機能を実行しますが、個々の要素ではなく2D特徴量マップ全体をドロップアウトします。特徴マップ内の隣接ピクセルが強く相関している場合(初期の畳み込み層では通常そうです)、通常のドロップアウトでは活性化が規則化されず、そうでなければ効果的な学習率の低下を招くだけです。この場合、SpatialDropout2Dは、特徴マップ間の独立性を促進するのに役立つので、代わりに使用すべきである。</target>
        </trans-unit>
        <trans-unit id="ef292e83a5c48c6c48f427ef4821dec22b8cd18d" translate="yes" xml:space="preserve">
          <source>This version performs the same function as Dropout, however, it drops entire 3D feature maps instead of individual elements. If adjacent voxels within feature maps are strongly correlated (as is normally the case in early convolution layers) then regular dropout will not regularize the activations and will otherwise just result in an effective learning rate decrease. In this case, SpatialDropout3D will help promote independence between feature maps and should be used instead.</source>
          <target state="translated">このバージョンはドロップアウトと同じ機能を実行しますが、個々の要素ではなく、3D特徴マップ全体をドロップアウトします。特徴マップ内の隣接するボクセルが強く相関している場合(初期の畳み込み層では通常そうです)、通常のドロップアウトでは活性化が規則化されず、そうでなければ効果的な学習率の低下を招くだけです。この場合、SpatialDropout3Dは、特徴マップ間の独立性を促進するのに役立つので、代わりに使用すべきである。</target>
        </trans-unit>
        <trans-unit id="28fed8917e83f005a3a2493f518294b2e184da80" translate="yes" xml:space="preserve">
          <source>This was originally generated by parsing and preprocessing the classic Reuters-21578 dataset, but the preprocessing code is no longer packaged with Keras. See this &lt;a href=&quot;https://github.com/keras-team/keras/issues/12072&quot;&gt;github discussion&lt;/a&gt; for more info.</source>
          <target state="translated">これは元々、従来のReuters-21578データセットを解析および前処理することによって生成されましたが、前処理コードはKerasにパッケージ化されなくなりました。詳細については、この&lt;a href=&quot;https://github.com/keras-team/keras/issues/12072&quot;&gt;githubのディスカッション&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="4d54f43064a89a76630348aa955f910392f5b82d" translate="yes" xml:space="preserve">
          <source>This will clear all caches, even those that are maintained through sequential calls to tf.tpu.experimental.initialize_tpu_system, such as the compilation cache.</source>
          <target state="translated">これにより、コンパイルキャッシュのような tf.tpu.experimental.initialize_tpu_system を連続して呼び出すことで維持されているキャッシュであっても、すべてのキャッシュがクリアされます。</target>
        </trans-unit>
        <trans-unit id="d806ab1c15562f7cef5ecfb73dfc54f37420bf0f" translate="yes" xml:space="preserve">
          <source>This will match and replace multiple sig defs iff tags is None (i.e when multiple &lt;code&gt;MetaGraph&lt;/code&gt;s have a signature_def with the same key). If tags is not None, this will only replace a single signature_def in the &lt;code&gt;MetaGraph&lt;/code&gt; with matching tags.</source>
          <target state="translated">これは、タグがNoneの場合（つまり、複数の &lt;code&gt;MetaGraph&lt;/code&gt; に同じキーのsignature_defがある場合）、複数のsig defに一致し、置き換えられます。タグがNoneでない場合、これは &lt;code&gt;MetaGraph&lt;/code&gt; 内の単一のsignature_defを一致するタグに置き換えるだけです。</target>
        </trans-unit>
        <trans-unit id="8c497916c950017d377f8b22ce65b7642e7fe656" translate="yes" xml:space="preserve">
          <source>This works for both single worker and multi-worker mode, only MirroredStrategy and MultiWorkerMirroredStrategy are supported for now.</source>
          <target state="translated">これはシングル ワーカー モードとマルチワーカー モードの両方で動作し、現在は MirroredStrategy と MultiWorkerMirroredStrategy のみがサポートされています。</target>
        </trans-unit>
        <trans-unit id="d1d5a90de0626fc107829e4415b87374a7e5143d" translate="yes" xml:space="preserve">
          <source>This wrapper allows to apply a layer to every temporal slice of an input.</source>
          <target state="translated">このラッパーは,入力の各時間的スライスにレイヤーを適用することができます.</target>
        </trans-unit>
        <trans-unit id="e4911cf935e00a37c587b392c63c4d1259cd5359" translate="yes" xml:space="preserve">
          <source>This wraps &lt;code&gt;func_&lt;/code&gt; in a Template and partially evaluates it. Templates are functions that create variables the first time they are called and reuse them thereafter. In order for &lt;code&gt;func_&lt;/code&gt; to be compatible with a &lt;code&gt;Template&lt;/code&gt; it must have the following properties:</source>
          <target state="translated">これは &lt;code&gt;func_&lt;/code&gt; をテンプレートにラップし、部分的に評価します。テンプレートは、最初に呼び出されたときに変数を作成し、その後それを再利用する関数です。ためには &lt;code&gt;func_&lt;/code&gt; と互換性を持つようにする &lt;code&gt;Template&lt;/code&gt; には、次の特性を持っている必要があります。</target>
        </trans-unit>
        <trans-unit id="9934a34210519520663a7f89fe0d027dd3ebea0c" translate="yes" xml:space="preserve">
          <source>This wraps &lt;code&gt;variables()&lt;/code&gt; from the actual optimizer. It does not include the &lt;code&gt;SyncReplicasOptimizer&lt;/code&gt;'s local step.</source>
          <target state="translated">これは実際のオプティマイザからの &lt;code&gt;variables()&lt;/code&gt; をラップします。 &lt;code&gt;SyncReplicasOptimizer&lt;/code&gt; のローカルステップは含まれません。</target>
        </trans-unit>
        <trans-unit id="cea56f6fda7d999d314aba39c0fdf92a26a4a3d0" translate="yes" xml:space="preserve">
          <source>Thread Compatibility</source>
          <target state="translated">スレッドの互換性</target>
        </trans-unit>
        <trans-unit id="c707a1c58a3c28cb78f0eb8786b82d358ba76091" translate="yes" xml:space="preserve">
          <source>Thread code:</source>
          <target state="translated">スレッドコード。</target>
        </trans-unit>
        <trans-unit id="a1bfe9290c9416a7b4254caec7ab391081602a4c" translate="yes" xml:space="preserve">
          <source>Thread identifier of this thread or None if it has not been started.</source>
          <target state="translated">このスレッドのスレッド識別子、または開始されていない場合は None。</target>
        </trans-unit>
        <trans-unit id="51781b51dab5c68c5071966ab81a91a116a5c345" translate="yes" xml:space="preserve">
          <source>ThreadPoolDataset</source>
          <target state="translated">ThreadPoolDataset</target>
        </trans-unit>
        <trans-unit id="c1e81f3f498c6f28feb25121d03bcd7897368f6a" translate="yes" xml:space="preserve">
          <source>ThreadPoolHandle</source>
          <target state="translated">ThreadPoolHandle</target>
        </trans-unit>
        <trans-unit id="b296a2588708c5eab00cc272e74d54b936f28305" translate="yes" xml:space="preserve">
          <source>ThreadUnsafeUnigramCandidateSampler</source>
          <target state="translated">ThreadUnsafeUnigramCandidateSampler</target>
        </trans-unit>
        <trans-unit id="673246c2e28b595a5660cad8b7dc6e0bcb64f903" translate="yes" xml:space="preserve">
          <source>Threshold below which the singular value is counted as 'zero'. Default value: &lt;code&gt;None&lt;/code&gt; (i.e., &lt;code&gt;eps * max(rows, cols) * max(singular_val)&lt;/code&gt;).</source>
          <target state="translated">それを下回ると、特異値が「ゼロ」としてカウントされるしきい値。デフォルト値： &lt;code&gt;None&lt;/code&gt; （つまり、 &lt;code&gt;eps * max(rows, cols) * max(singular_val)&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="bf8ab928262e89058d10a418722762edfa599e46" translate="yes" xml:space="preserve">
          <source>Thresholded Rectified Linear Unit.</source>
          <target state="translated">しきい値のある整流化されたリニアユニット。</target>
        </trans-unit>
        <trans-unit id="9c1b3e348c5e658c9f04296e21ad3e2315006119" translate="yes" xml:space="preserve">
          <source>Throws:</source>
          <target state="translated">Throws:</target>
        </trans-unit>
        <trans-unit id="19453fe8b327db6c16c490630fc6fcb997c1883b" translate="yes" xml:space="preserve">
          <source>Thus the saved model can be reinstantiated in the exact same state, without any of the code used for model definition or training.</source>
          <target state="translated">このように、保存されたモデルは、モデルの定義やトレーニングに使用されるコードを一切使用せずに、全く同じ状態で再インスタンス化することができます。</target>
        </trans-unit>
        <trans-unit id="2dd2c660983753cf7cd7ed0bfc6dd2c1219c9bc2" translate="yes" xml:space="preserve">
          <source>Tile</source>
          <target state="translated">Tile</target>
        </trans-unit>
        <trans-unit id="04d349170a16840309d778c9a6bc280d1695cf69" translate="yes" xml:space="preserve">
          <source>TileGrad</source>
          <target state="translated">TileGrad</target>
        </trans-unit>
        <trans-unit id="ec15d67c587aeda01fdee12aac8f67ec1f6fc946" translate="yes" xml:space="preserve">
          <source>Time (in seconds) to wait for process cleanup to propagate.</source>
          <target state="translated">プロセスのクリーンアップが伝播するのを待つ時間 (秒)。</target>
        </trans-unit>
        <trans-unit id="c5071117f474d7a0d851f7b8b532519d4fe0b2f5" translate="yes" xml:space="preserve">
          <source>Time boundaries at which to call Run(), or None if it should be called back to back.</source>
          <target state="translated">Run()をコールする時間の境界線、またはそれが後ろにコールされるべき場合は None を指定します。</target>
        </trans-unit>
        <trans-unit id="ea13a52ff3b11f3a3cff17d94eddba0db805c4f1" translate="yes" xml:space="preserve">
          <source>Time series forecasting</source>
          <target state="translated">時系列予測</target>
        </trans-unit>
        <trans-unit id="3e5a5aa6d16549aefb0642b61016bd76ed1a572d" translate="yes" xml:space="preserve">
          <source>Time step at which the gradient was computed.</source>
          <target state="translated">勾配が計算された時間ステップ.</target>
        </trans-unit>
        <trans-unit id="d96b16498245359e1fc62fcf077cd9c20e575ff4" translate="yes" xml:space="preserve">
          <source>Timer that triggers at most once every N seconds or once every N steps.</source>
          <target state="translated">最大でもN秒に1回、またはNステップに1回の頻度でトリガーするタイマー。</target>
        </trans-unit>
        <trans-unit id="19eabc961735d78f12fc7be906ffcb033853cf85" translate="yes" xml:space="preserve">
          <source>Timestamp</source>
          <target state="translated">Timestamp</target>
        </trans-unit>
        <trans-unit id="b0bee40a202555900d8a3e86b930a56b855407cd" translate="yes" xml:space="preserve">
          <source>To &lt;code&gt;run&lt;/code&gt; without hooks.</source>
          <target state="translated">するには &lt;code&gt;run&lt;/code&gt; フックなし。</target>
        </trans-unit>
        <trans-unit id="40336213cb93ad585f6a3a6e3ff018601cc59a2a" translate="yes" xml:space="preserve">
          <source>To achieve a performance improvement, you can also wrap the &lt;code&gt;strategy.run&lt;/code&gt; call with a &lt;a href=&quot;../range&quot;&gt;&lt;code&gt;tf.range&lt;/code&gt;&lt;/a&gt; inside a &lt;a href=&quot;../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt;. This runs multiple steps in a &lt;a href=&quot;../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt;. Autograph will convert it to a &lt;a href=&quot;../while_loop&quot;&gt;&lt;code&gt;tf.while_loop&lt;/code&gt;&lt;/a&gt; on the worker. However, it is less flexible comparing with running a single step inside &lt;a href=&quot;../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt;. For example, you cannot run things eagerly or arbitrary python code within the steps.</source>
          <target state="translated">パフォーマンスを向上させるために、 &lt;code&gt;strategy.run&lt;/code&gt; 呼び出しを&lt;a href=&quot;../range&quot;&gt; &lt;code&gt;tf.range&lt;/code&gt; &lt;/a&gt;内の&lt;a href=&quot;../function&quot;&gt; &lt;code&gt;tf.function&lt;/code&gt; &lt;/a&gt;ラップすることもできます。これは、&lt;a href=&quot;../function&quot;&gt; &lt;code&gt;tf.function&lt;/code&gt; で&lt;/a&gt;複数のステップを実行します。Autographはそれを&lt;a href=&quot;../while_loop&quot;&gt; &lt;code&gt;tf.while_loop&lt;/code&gt; &lt;/a&gt;上でtf.while_loopに変換します。ただし、&lt;a href=&quot;../function&quot;&gt; &lt;code&gt;tf.function&lt;/code&gt; &lt;/a&gt;内で単一のステップを実行する場合と比較すると、柔軟性が低くなります。たとえば、ステップ内で熱心に実行したり、任意のPythonコードを実行したりすることはできません。</target>
        </trans-unit>
        <trans-unit id="f375d91c07ec3d845eaa0b13fb5e2121d93801bc" translate="yes" xml:space="preserve">
          <source>To add an inner vector length axis to a tensor of scalars.</source>
          <target state="translated">スカラーのテンソルに内側のベクトル長軸を追加する。</target>
        </trans-unit>
        <trans-unit id="bd6eda6c08067795995f955381394f94ccb8826e" translate="yes" xml:space="preserve">
          <source>To aggregate gradients yourself, call &lt;code&gt;apply_gradients&lt;/code&gt; with &lt;code&gt;experimental_aggregate_gradients&lt;/code&gt; set to False. This is useful if you need to process aggregated gradients.</source>
          <target state="translated">グラデーションを自分で集計するには、 &lt;code&gt;experimental_aggregate_gradients&lt;/code&gt; をFalseに設定して &lt;code&gt;apply_gradients&lt;/code&gt; を呼び出します。これは、集約されたグラデーションを処理する必要がある場合に役立ちます。</target>
        </trans-unit>
        <trans-unit id="010eecd6ae7f583a0121a3a0180c941339655bd9" translate="yes" xml:space="preserve">
          <source>To apply a functional operation to the nonzero elements of a SparseTensor one of the following methods is recommended. First, if the function is expressible as TensorFlow ops, use</source>
          <target state="translated">SparseTensor の非ゼロ要素に関数演算を適用するには、以下のいずれかの方法が推奨されます。まず、関数がTensorFlow演算として表現可能な場合は</target>
        </trans-unit>
        <trans-unit id="3eb084feee66304e2da16fe914a839b30b34c9ff" translate="yes" xml:space="preserve">
          <source>To associate a &lt;code&gt;StatsAggregator&lt;/code&gt; with a &lt;a href=&quot;../../../../data/dataset&quot;&gt;&lt;code&gt;tf.data.Dataset&lt;/code&gt;&lt;/a&gt; object, use the following pattern:</source>
          <target state="translated">関連付けるに &lt;code&gt;StatsAggregator&lt;/code&gt; をして&lt;a href=&quot;../../../../data/dataset&quot;&gt; &lt;code&gt;tf.data.Dataset&lt;/code&gt; の&lt;/a&gt;オブジェクト、次のパターンを使用します。</target>
        </trans-unit>
        <trans-unit id="c154cd080332e723a840721f93b48724110f7c06" translate="yes" xml:space="preserve">
          <source>To associate a &lt;code&gt;StatsAggregator&lt;/code&gt; with a &lt;a href=&quot;../dataset&quot;&gt;&lt;code&gt;tf.data.Dataset&lt;/code&gt;&lt;/a&gt; object, use the following pattern:</source>
          <target state="translated">関連付けるに &lt;code&gt;StatsAggregator&lt;/code&gt; をして&lt;a href=&quot;../dataset&quot;&gt; &lt;code&gt;tf.data.Dataset&lt;/code&gt; の&lt;/a&gt;オブジェクト、次のパターンを使用します。</target>
        </trans-unit>
        <trans-unit id="936085b5545471dc42df6c7c7d391847c9751475" translate="yes" xml:space="preserve">
          <source>To avoid copies, if the consumer of the returned value is on the same device as the variable, this actually returns the live value of the variable, not a copy. Updates to the variable are seen by the consumer. If the consumer is on a different device it will get a copy of the variable.</source>
          <target state="translated">コピーを避けるために、返された値の消費者が変数と同じデバイスにいる場合、これは実際にはコピーではなく変数のライブ値を返します。変数への更新はコンシューマによって見られます。消費者が別のデバイスにいる場合は、変数のコピーを取得します。</target>
        </trans-unit>
        <trans-unit id="7c1421196dd351f3e8d18229f5901c13e59818be" translate="yes" xml:space="preserve">
          <source>To avoid this operation one can looping over the first &lt;code&gt;ndims&lt;/code&gt; of the variable and using &lt;code&gt;scatter_update&lt;/code&gt; on the subtensors that result of slicing the first dimension. This is a valid option for &lt;code&gt;ndims = 1&lt;/code&gt;, but less efficient than this implementation.</source>
          <target state="translated">この操作を回避するために、変数の最初の &lt;code&gt;ndims&lt;/code&gt; をループし、最初の次元をスライスした結果のサブテンソルでscatter_updateを使用 &lt;code&gt;scatter_update&lt;/code&gt; ます。これは &lt;code&gt;ndims = 1&lt;/code&gt; 有効なオプションですが、この実装ほど効率的ではありません。</target>
        </trans-unit>
        <trans-unit id="cfcb9f867b92956487a659195717febb57a22acc" translate="yes" xml:space="preserve">
          <source>To avoid this operation there would be 2 alternatives:</source>
          <target state="translated">この操作を回避するには、2つの選択肢があります。</target>
        </trans-unit>
        <trans-unit id="d93bb75610f7b39567f5b306f3397077993ff8e1" translate="yes" xml:space="preserve">
          <source>To avoid this operation there would be 2 alternatives: 1) Reshaping the variable by merging the first &lt;code&gt;ndims&lt;/code&gt; dimensions. However, this is not possible because &lt;a href=&quot;../../reshape&quot;&gt;&lt;code&gt;tf.reshape&lt;/code&gt;&lt;/a&gt; returns a Tensor, which we cannot use &lt;a href=&quot;scatter_update&quot;&gt;&lt;code&gt;tf.compat.v1.scatter_update&lt;/code&gt;&lt;/a&gt; on. 2) Looping over the first &lt;code&gt;ndims&lt;/code&gt; of the variable and using &lt;a href=&quot;scatter_update&quot;&gt;&lt;code&gt;tf.compat.v1.scatter_update&lt;/code&gt;&lt;/a&gt; on the subtensors that result of slicing the first dimension. This is a valid option for &lt;code&gt;ndims = 1&lt;/code&gt;, but less efficient than this implementation.</source>
          <target state="translated">この操作を回避するには、次の2つの方法があります。1）最初の &lt;code&gt;ndims&lt;/code&gt; 次元をマージして変数を変形します。ただし、これは不可能です。これは、&lt;a href=&quot;../../reshape&quot;&gt; &lt;code&gt;tf.reshape&lt;/code&gt; &lt;/a&gt;がTensorを返すため、tf.compat.v1.scatter_updateを使用できないため&lt;a href=&quot;scatter_update&quot;&gt; &lt;code&gt;tf.compat.v1.scatter_update&lt;/code&gt; &lt;/a&gt;。2）第1の過ループ &lt;code&gt;ndims&lt;/code&gt; 変数のと使用&lt;a href=&quot;scatter_update&quot;&gt; &lt;code&gt;tf.compat.v1.scatter_update&lt;/code&gt; を&lt;/a&gt; subtensors上の第一次元のスライスの結果。これは &lt;code&gt;ndims = 1&lt;/code&gt; 有効なオプションですが、この実装ほど効率的ではありません。</target>
        </trans-unit>
        <trans-unit id="c9183a300f45fff79988522f16235dc4e2de646c" translate="yes" xml:space="preserve">
          <source>To be implemented by subclasses:</source>
          <target state="translated">サブクラスで実装する。</target>
        </trans-unit>
        <trans-unit id="52f2d1556ade9e7f9e4af5a180af2690b66cec6f" translate="yes" xml:space="preserve">
          <source>To be used together with &lt;code&gt;initializer = tf.variance_scaling_initializer(factor=1.0, mode='FAN_IN')&lt;/code&gt;. For correct dropout, use &lt;code&gt;tf.contrib.nn.alpha_dropout&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;initializer = tf.variance_scaling_initializer(factor=1.0, mode='FAN_IN')&lt;/code&gt; と一緒に使用します。ドロップアウトを正しくするには、 &lt;code&gt;tf.contrib.nn.alpha_dropout&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="ea58afe1c10fb928517e860a0db2a381e664fd3c" translate="yes" xml:space="preserve">
          <source>To be used together with the &lt;a href=&quot;../initializers/lecunnormal&quot;&gt;&lt;code&gt;tf.keras.initializers.LecunNormal&lt;/code&gt;&lt;/a&gt; initializer.</source>
          <target state="translated">&lt;a href=&quot;../initializers/lecunnormal&quot;&gt; &lt;code&gt;tf.keras.initializers.LecunNormal&lt;/code&gt; &lt;/a&gt;初期化子と一緒に使用します。</target>
        </trans-unit>
        <trans-unit id="067aa09e87c256fc4280bb7886d1747104dcfb5d" translate="yes" xml:space="preserve">
          <source>To be used together with the dropout variant &lt;a href=&quot;../layers/alphadropout&quot;&gt;&lt;code&gt;tf.keras.layers.AlphaDropout&lt;/code&gt;&lt;/a&gt; (not regular dropout).</source>
          <target state="translated">ドロップアウトバリアント&lt;a href=&quot;../layers/alphadropout&quot;&gt; &lt;code&gt;tf.keras.layers.AlphaDropout&lt;/code&gt; &lt;/a&gt;（通常のドロップアウトではありません）と一緒に使用します。</target>
        </trans-unit>
        <trans-unit id="53dd8873954bfa79dfd0bea43d6ef54fe742261a" translate="yes" xml:space="preserve">
          <source>To build a SavedModel, the first meta graph must be saved with variables. Subsequent meta graphs will simply be saved with their graph definitions. If assets need to be saved and written or copied to disk, they can be provided when the meta graph def is added. If multiple meta graph defs are associated an asset of the same name, only the first version is retained.</source>
          <target state="translated">SavedModel を構築するには、最初のメタグラフを変数と共に保存する必要があります。それ以降のメタグラフは単にグラフ定義と共に保存されます。アセットを保存してディスクに書き込んだりコピーしたりする必要がある場合は、メタグラフ def を追加する際に提供することができます。同じ名前のアセットに複数のメタグラフdefが関連付けられている場合、最初のバージョンのみが保持されます。</target>
        </trans-unit>
        <trans-unit id="44fe360fd9bf0e087ab467407a9221a32654e234" translate="yes" xml:space="preserve">
          <source>To construct a TPUStrategy object, you need to run the initialization code as below:</source>
          <target state="translated">TPUStrategyオブジェクトを構築するには、以下のような初期化コードを実行する必要があります。</target>
        </trans-unit>
        <trans-unit id="83c7623c3022948b14096264ce7d526cb9408c74" translate="yes" xml:space="preserve">
          <source>To consume the statistics, associate a &lt;code&gt;StatsAggregator&lt;/code&gt; with the output dataset.</source>
          <target state="translated">統計を使用するには、 &lt;code&gt;StatsAggregator&lt;/code&gt; を出力データセットに関連付けます。</target>
        </trans-unit>
        <trans-unit id="d2287264f43a3ef6c22b5d232bbf5118319287d4" translate="yes" xml:space="preserve">
          <source>To create a &lt;a href=&quot;../compat/v1/session&quot;&gt;&lt;code&gt;tf.compat.v1.Session&lt;/code&gt;&lt;/a&gt; that connects to this server, use the following snippet:</source>
          <target state="translated">このサーバーに接続する&lt;a href=&quot;../compat/v1/session&quot;&gt; &lt;code&gt;tf.compat.v1.Session&lt;/code&gt; &lt;/a&gt;を作成するには、次のスニペットを使用します。</target>
        </trans-unit>
        <trans-unit id="d6382ce12824513eb2d0429e1935eb788cf98fff" translate="yes" xml:space="preserve">
          <source>To create a cluster with two jobs and five tasks, you specify the mapping from job names to lists of network addresses (typically hostname-port pairs).</source>
          <target state="translated">2つのジョブと5つのタスクを持つクラスタを作成するには、ジョブ名からネットワークアドレスのリスト(通常はホスト名とポートのペア)へのマッピングを指定します。</target>
        </trans-unit>
        <trans-unit id="162a52ef0e892f8de2d469fbf8a8ede583aeb2c2" translate="yes" xml:space="preserve">
          <source>To create a dataset of all files matching a pattern, use &lt;a href=&quot;dataset#list_files&quot;&gt;&lt;code&gt;tf.data.Dataset.list_files&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">パターンに一致するすべてのファイルのデータセットを作成するには、&lt;a href=&quot;dataset#list_files&quot;&gt; &lt;code&gt;tf.data.Dataset.list_files&lt;/code&gt; を&lt;/a&gt;使用します。</target>
        </trans-unit>
        <trans-unit id="d3f4ab00aa69fb40cd693922a5c483368cf34082" translate="yes" xml:space="preserve">
          <source>To customize the estimator &lt;code&gt;eval_metric_ops&lt;/code&gt; names, you can pass in the &lt;code&gt;metric_names_map&lt;/code&gt; dictionary mapping the keras model output metric names to the custom names as follows:</source>
          <target state="translated">推定器の &lt;code&gt;eval_metric_ops&lt;/code&gt; 名をカスタマイズするには、次のように、kerasモデルの出力メトリック名をカスタム名にマッピングする &lt;code&gt;metric_names_map&lt;/code&gt; ディクショナリを渡すことができます。</target>
        </trans-unit>
        <trans-unit id="baed8fb95bde1dbbdafd79f549daf02185ceb494" translate="yes" xml:space="preserve">
          <source>To enable a public method, subclasses should implement the leading-underscore version of the method. The argument signature should be identical except for the omission of &lt;code&gt;name=&quot;...&quot;&lt;/code&gt;. For example, to enable &lt;code&gt;matmul(x, adjoint=False, name=&quot;matmul&quot;)&lt;/code&gt; a subclass should implement &lt;code&gt;_matmul(x, adjoint=False)&lt;/code&gt;.</source>
          <target state="translated">パブリックメソッドを有効にするには、サブクラスでメソッドの先行アンダースコアバージョンを実装する必要があります。引数の署名は、 &lt;code&gt;name=&quot;...&quot;&lt;/code&gt; が省略されていることを除いて、同じである必要があります。たとえば、 &lt;code&gt;matmul(x, adjoint=False, name=&quot;matmul&quot;)&lt;/code&gt; を有効にするには、サブクラスで &lt;code&gt;_matmul(x, adjoint=False)&lt;/code&gt; を実装する必要があります。</target>
        </trans-unit>
        <trans-unit id="a64f441e5dd84fd06f79adb0f1f3a053a7155dea" translate="yes" xml:space="preserve">
          <source>To enable and control broadcasting, use an ellipsis. For example, to perform batch matrix multiplication with NumPy-style broadcasting across the batch dimensions, use:</source>
          <target state="translated">ブロードキャストを有効にして制御するには、省略記号を使用します。例えば、バッチ次元にわたってNumPyスタイルのブロードキャストを使用してバッチ行列の乗算を実行するには、次のようにします。</target>
        </trans-unit>
        <trans-unit id="afa60615bea13e940acd80b65497cda8c8de7ef9" translate="yes" xml:space="preserve">
          <source>To enable statefulness:</source>
          <target state="translated">ステートフルネスを有効にする。</target>
        </trans-unit>
        <trans-unit id="01b6fd9e2269c63a7f1c5eddbf780087a139a252" translate="yes" xml:space="preserve">
          <source>To enable statefulness: - Specify &lt;code&gt;stateful=True&lt;/code&gt; in the layer constructor. - Specify a fixed batch size for your model, by passing If sequential model: &lt;code&gt;batch_input_shape=(...)&lt;/code&gt; to the first layer in your model. Else for functional model with 1 or more Input layers: &lt;code&gt;batch_shape=(...)&lt;/code&gt; to all the first layers in your model. This is the expected shape of your inputs &lt;em&gt;including the batch size&lt;/em&gt;. It should be a tuple of integers, e.g. &lt;code&gt;(32, 10, 100)&lt;/code&gt;. - Specify &lt;code&gt;shuffle=False&lt;/code&gt; when calling fit().</source>
          <target state="translated">ステートフル性を有効にするには：- レイヤーコンストラクターで &lt;code&gt;stateful=True&lt;/code&gt; を指定します。 -モデルの最初のレイヤーにIfシーケンシャルモデル： &lt;code&gt;batch_input_shape=(...)&lt;/code&gt; を渡して、モデルの固定バッチサイズを指定します。それ以外の場合、1つ以上の入力レイヤーを持つ機能モデルの場合：モデルのすべての最初のレイヤーに &lt;code&gt;batch_shape=(...)&lt;/code&gt; これは、&lt;em&gt;バッチサイズを含む、&lt;/em&gt;入力の予想される形状です。整数のタプルである必要があります（例： &lt;code&gt;(32, 10, 100)&lt;/code&gt; 32、10、100 ））。-fit（）を呼び出すときに &lt;code&gt;shuffle=False&lt;/code&gt; を指定します。</target>
        </trans-unit>
        <trans-unit id="d5e380bc52096caf61cf4a0e2ca23ca08f41f03b" translate="yes" xml:space="preserve">
          <source>To enable this Soft-NMS mode, set the &lt;code&gt;soft_nms_sigma&lt;/code&gt; parameter to be larger than 0. When &lt;code&gt;soft_nms_sigma&lt;/code&gt; equals 0, the behavior of &lt;a href=&quot;non_max_suppression_padded&quot;&gt;&lt;code&gt;tf.image.non_max_suppression_padded&lt;/code&gt;&lt;/a&gt; is identical to that of &lt;a href=&quot;non_max_suppression&quot;&gt;&lt;code&gt;tf.image.non_max_suppression&lt;/code&gt;&lt;/a&gt; (except for the extra output) both in function and in running time.</source>
          <target state="translated">このソフトNMSモードを有効にするために、設定 &lt;code&gt;soft_nms_sigma&lt;/code&gt; の0より大きいされるパラメータ &lt;code&gt;soft_nms_sigma&lt;/code&gt; が0に等しいが、の挙動&lt;a href=&quot;non_max_suppression_padded&quot;&gt; &lt;code&gt;tf.image.non_max_suppression_padded&lt;/code&gt; が&lt;/a&gt;のものと同一である&lt;a href=&quot;non_max_suppression&quot;&gt; &lt;code&gt;tf.image.non_max_suppression&lt;/code&gt; &lt;/a&gt;両方に（余分な出力を除く）を機能と実行時に。</target>
        </trans-unit>
        <trans-unit id="63aaf92714daf46639926647a3d0a69e133b8f2a" translate="yes" xml:space="preserve">
          <source>To enable this Soft-NMS mode, set the &lt;code&gt;soft_nms_sigma&lt;/code&gt; parameter to be larger than 0. When &lt;code&gt;soft_nms_sigma&lt;/code&gt; equals 0, the behavior of &lt;code&gt;tf.image.non_max_suppression_v2&lt;/code&gt; is identical to that of &lt;a href=&quot;non_max_suppression&quot;&gt;&lt;code&gt;tf.image.non_max_suppression&lt;/code&gt;&lt;/a&gt; (except for the extra output) both in function and in running time.</source>
          <target state="translated">このソフトNMSモードを有効にするために、設定 &lt;code&gt;soft_nms_sigma&lt;/code&gt; の 0より大きいされるパラメータ &lt;code&gt;soft_nms_sigma&lt;/code&gt; が 0に等しいが、の挙動 &lt;code&gt;tf.image.non_max_suppression_v2&lt;/code&gt; はと同一である&lt;a href=&quot;non_max_suppression&quot;&gt; &lt;code&gt;tf.image.non_max_suppression&lt;/code&gt; &lt;/a&gt;（余分な出力を除く）の両方での機能と実行時間。</target>
        </trans-unit>
        <trans-unit id="30dc95cd6fb2fe82cb6bde586b190076a23204d3" translate="yes" xml:space="preserve">
          <source>To ensure forward compatibility of generated graphs (see &lt;code&gt;forward_compatible&lt;/code&gt;) with older binaries, new features can be gated with:</source>
          <target state="translated">生成されたグラフ（ &lt;code&gt;forward_compatible&lt;/code&gt; を参照）の古いバイナリとの上位互換性を確保するために、新機能を次のようにゲートできます。</target>
        </trans-unit>
        <trans-unit id="2a6dfd40e1c087316d123358f0bfd9c6696a8b43" translate="yes" xml:space="preserve">
          <source>To ensure that loading is complete and no more assignments will take place, use the &lt;code&gt;assert_consumed()&lt;/code&gt; method of the status object returned by &lt;code&gt;restore()&lt;/code&gt;:</source>
          <target state="translated">その読み込みが完了していることを確認するには、それ以上の割り当ては使用し、行われません &lt;code&gt;assert_consumed()&lt;/code&gt; によって返されるステータスオブジェクトのメソッド &lt;code&gt;restore()&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="6fdc8715d19df576a528e05d54600b3b8b7e951d" translate="yes" xml:space="preserve">
          <source>To ensure that loading is complete and no more assignments will take place, use the &lt;code&gt;assert_consumed()&lt;/code&gt; method of the status object returned by &lt;code&gt;restore&lt;/code&gt;:</source>
          <target state="translated">そのロードを確実にするために使用し、完了し、それ以上の割り当ては行われません &lt;code&gt;assert_consumed()&lt;/code&gt; によって返されたステータスオブジェクトのメソッド &lt;code&gt;restore&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="7f9135f3ba27360a5d60098a844664f0e165caf9" translate="yes" xml:space="preserve">
          <source>To extend, inherit from this class; from the subclass &lt;strong&gt;init&lt;/strong&gt;, call</source>
          <target state="translated">拡張するには、このクラスから継承します。サブクラス&lt;strong&gt;init&lt;/strong&gt;から呼び出し</target>
        </trans-unit>
        <trans-unit id="a5d8cbeafaa3eeb0c6165bfa56b4aafe15d6a9db" translate="yes" xml:space="preserve">
          <source>To generate different sequences across sessions, set neither graph-level nor op-level seeds:</source>
          <target state="translated">セッション間で異なるシーケンスを生成するには、グラフレベルのシードもオペレベルのシードも設定しません。</target>
        </trans-unit>
        <trans-unit id="8b8fda9f12ffa5af323a889062c3aa890309e2cb" translate="yes" xml:space="preserve">
          <source>To generate the same repeatable sequence for an op across sessions, set the seed for the op:</source>
          <target state="translated">セッション間で同じ繰り返し可能なシーケンスを生成するには、オペのシードを設定します。</target>
        </trans-unit>
        <trans-unit id="ff3af5efb2174b5bcd82487648e50b8ae5b6afb0" translate="yes" xml:space="preserve">
          <source>To get a more intuitive and visual look at what this operation does, you can run tensorflow/examples/wav_to_spectrogram to read in an audio file and save out the resulting spectrogram as a PNG image.</source>
          <target state="translated">この操作が何をするのかをより直感的に視覚的に見るには、tensorflow/examples/wav_to_spectrogram を実行してオーディオファイルを読み込んで、結果として得られたスペクトログラムを PNG 画像として保存します。</target>
        </trans-unit>
        <trans-unit id="ec9fe6e91399876e841634556ab27d6bee162948" translate="yes" xml:space="preserve">
          <source>To get a protocol buffer summary of the currently aggregated statistics, use the &lt;code&gt;StatsAggregator.get_summary()&lt;/code&gt; tensor. The easiest way to do this is to add the returned tensor to the &lt;code&gt;tf.GraphKeys.SUMMARIES&lt;/code&gt; collection, so that the summaries will be included with any existing summaries.</source>
          <target state="translated">現在集計されている統計のプロトコルバッファーの概要を取得するには、 &lt;code&gt;StatsAggregator.get_summary()&lt;/code&gt; テンソルを使用します。これを行う最も簡単な方法は、返されたテンソルを &lt;code&gt;tf.GraphKeys.SUMMARIES&lt;/code&gt; コレクションに追加して、サマリーが既存のサマリーに含まれるようにすることです。</target>
        </trans-unit>
        <trans-unit id="eecdfb3013e20388a17f33fbb93597b30d4ef349" translate="yes" xml:space="preserve">
          <source>To get the current default session, use &lt;a href=&quot;get_default_session&quot;&gt;&lt;code&gt;tf.compat.v1.get_default_session&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">現在のデフォルトセッションを取得するには、&lt;a href=&quot;get_default_session&quot;&gt; &lt;code&gt;tf.compat.v1.get_default_session&lt;/code&gt; を&lt;/a&gt;使用します。</target>
        </trans-unit>
        <trans-unit id="273ca78fffe894af5651288f4a1f4c051d209749" translate="yes" xml:space="preserve">
          <source>To illustrate the user-visible effects, consider these examples:</source>
          <target state="translated">ユーザーから見える効果を説明するために、以下の例を考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="ce5890e8d9ded5f833a93abef51a8a4c147da863" translate="yes" xml:space="preserve">
          <source>To instead reorder the data to rearrange the dimensions of a tensor, see &lt;a href=&quot;transpose&quot;&gt;&lt;code&gt;tf.transpose&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">代わりにデータを並べ替えてテンソルの次元を再配置するには、&lt;a href=&quot;transpose&quot;&gt; &lt;code&gt;tf.transpose&lt;/code&gt; を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="58521b85b5941fed07e375b8c580b661cb67962d" translate="yes" xml:space="preserve">
          <source>To load a network from a JSON save file, use &lt;a href=&quot;../models/model_from_json&quot;&gt;&lt;code&gt;keras.models.model_from_json(json_string, custom_objects={})&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">JSON保存ファイルからネットワークをロードするには、&lt;a href=&quot;../models/model_from_json&quot;&gt; &lt;code&gt;keras.models.model_from_json(json_string, custom_objects={})&lt;/code&gt; &lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="fc1f35de200c65966b97907804a085417fa2674d" translate="yes" xml:space="preserve">
          <source>To load a network from a JSON save file, use &lt;a href=&quot;models/model_from_json&quot;&gt;&lt;code&gt;keras.models.model_from_json(json_string, custom_objects={})&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">JSON保存ファイルからネットワークをロードするには、&lt;a href=&quot;models/model_from_json&quot;&gt; &lt;code&gt;keras.models.model_from_json(json_string, custom_objects={})&lt;/code&gt; &lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="171ed2725b41e726794d8676fc06308b4d649fcf" translate="yes" xml:space="preserve">
          <source>To load a network from a yaml save file, use &lt;a href=&quot;../models/model_from_yaml&quot;&gt;&lt;code&gt;keras.models.model_from_yaml(yaml_string, custom_objects={})&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">yaml保存ファイルからネットワークを読み込むには、&lt;a href=&quot;../models/model_from_yaml&quot;&gt; &lt;code&gt;keras.models.model_from_yaml(yaml_string, custom_objects={})&lt;/code&gt; &lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="32acfa401b4c952f2dcfef233deb7f737a491a64" translate="yes" xml:space="preserve">
          <source>To load a network from a yaml save file, use &lt;a href=&quot;models/model_from_yaml&quot;&gt;&lt;code&gt;keras.models.model_from_yaml(yaml_string, custom_objects={})&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">yaml保存ファイルからネットワークを読み込むには、&lt;a href=&quot;models/model_from_yaml&quot;&gt; &lt;code&gt;keras.models.model_from_yaml(yaml_string, custom_objects={})&lt;/code&gt; &lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="84dbf2d04bfcc507efa1aac8fcfb0ed50455e091" translate="yes" xml:space="preserve">
          <source>To make the random sequences generated by all ops be repeatable across sessions, set a graph-level seed:</source>
          <target state="translated">すべての操作で生成されたランダムなシーケンスをセッション間で繰り返し使用できるようにするには、グラフレベルのシードを設定します。</target>
        </trans-unit>
        <trans-unit id="8bca5a7e3515ab70d1734fcf9290f94f57a539f3" translate="yes" xml:space="preserve">
          <source>To mimic the behavior of &lt;code&gt;np.flatten&lt;/code&gt; (which flattens all dimensions), use &lt;code&gt;rt.merge_dims(0, -1). To mimic the behavior of&lt;/code&gt;tf.layers.Flatten&lt;code&gt;(which flattens all dimensions except the outermost batch dimension), use&lt;/code&gt;rt.merge_dims(1, -1)`.</source>
          <target state="translated">&lt;code&gt;np.flatten&lt;/code&gt; （すべての次元を平坦化する）の動作を模倣するには、 &lt;code&gt;rt.merge_dims(0, -1). To mimic the behavior of&lt;/code&gt; tf.layers.Flatten &lt;code&gt;(which flattens all dimensions except the outermost batch dimension), use&lt;/code&gt; する）の動作を模倣するには、 rt.merge_dims（1、-1） `を使用します。</target>
        </trans-unit>
        <trans-unit id="f9a3e8831e7d974549f1a0383e7928bbabcfacd7" translate="yes" xml:space="preserve">
          <source>To obtain an individual graph, use the &lt;code&gt;get_concrete_function&lt;/code&gt; method of the callable created by &lt;a href=&quot;function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt;. It can be called with the same arguments as &lt;code&gt;func&lt;/code&gt; and returns a special &lt;a href=&quot;graph&quot;&gt;&lt;code&gt;tf.Graph&lt;/code&gt;&lt;/a&gt; object:</source>
          <target state="translated">個々のグラフを取得するには、 &lt;code&gt;get_concrete_function&lt;/code&gt; によって作成された呼び出し可能オブジェクトのget_concrete_functionメソッドを使用し&lt;a href=&quot;function&quot;&gt; &lt;code&gt;tf.function&lt;/code&gt; &lt;/a&gt;。 &lt;code&gt;func&lt;/code&gt; と同じ引数で呼び出すことができ、特別な&lt;a href=&quot;graph&quot;&gt; &lt;code&gt;tf.Graph&lt;/code&gt; &lt;/a&gt;オブジェクトを返します。</target>
        </trans-unit>
        <trans-unit id="9e83f95895428f42e71becadca9982d2894dba04" translate="yes" xml:space="preserve">
          <source>To pass sample weights when training or evaluating the Estimator, the first item returned by the input function should be a dictionary with keys &lt;code&gt;features&lt;/code&gt; and &lt;code&gt;sample_weights&lt;/code&gt;. Example below:</source>
          <target state="translated">Estimatorをトレーニングまたは評価するときにサンプルの重みを渡すには、入力関数によって返される最初の項目は、キー &lt;code&gt;features&lt;/code&gt; と &lt;code&gt;sample_weights&lt;/code&gt; を含む辞書である必要があります。以下の例：</target>
        </trans-unit>
        <trans-unit id="a0110a07b243d67a47edf557bd54d79fd2de9674" translate="yes" xml:space="preserve">
          <source>To perform the clipping, the values &lt;code&gt;t_list[i]&lt;/code&gt; are set to:</source>
          <target state="translated">クリッピングを実行するには、値 &lt;code&gt;t_list[i]&lt;/code&gt; を次のように設定します。</target>
        </trans-unit>
        <trans-unit id="5e552f3cce7d0e03051d89f4e0255d1c49f37d1b" translate="yes" xml:space="preserve">
          <source>To prevent accidental sharing of variables, we raise an exception when getting an existing variable in a non-reusing scope.</source>
          <target state="translated">誤って変数を共有してしまうことを防ぐために、再利用しないスコープで既存の変数を取得する際に例外を発生させています。</target>
        </trans-unit>
        <trans-unit id="b90b39244fd5711de404a1ed79326b6635b08950" translate="yes" xml:space="preserve">
          <source>To process lines from files, use &lt;a href=&quot;textlinedataset&quot;&gt;&lt;code&gt;tf.data.TextLineDataset&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">ファイルの行を処理するには、&lt;a href=&quot;textlinedataset&quot;&gt; &lt;code&gt;tf.data.TextLineDataset&lt;/code&gt; を&lt;/a&gt;使用します。</target>
        </trans-unit>
        <trans-unit id="aa139b98ea790b72d4805462346af0f7c690db65" translate="yes" xml:space="preserve">
          <source>To process records written in the &lt;code&gt;TFRecord&lt;/code&gt; format, use &lt;code&gt;TFRecordDataset&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;TFRecord&lt;/code&gt; 形式で記述されたレコードを処理するには、TFRecordDatasetを使用し &lt;code&gt;TFRecordDataset&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="862cc9660449fcff05a0a9d8dd83a651e63fd705" translate="yes" xml:space="preserve">
          <source>To provide an API that is close to Python's file I/O objects, and</source>
          <target state="translated">PythonのファイルI/Oオブジェクトに近いAPIを提供することと</target>
        </trans-unit>
        <trans-unit id="e93ce7e6602bc5d8a646cce42b0e2f27a7ee545d" translate="yes" xml:space="preserve">
          <source>To provide an implementation based on TensorFlow's C++ FileSystem API.</source>
          <target state="translated">TensorFlowのC++FileSystem APIに基づく実装を提供する。</target>
        </trans-unit>
        <trans-unit id="b683767243ad0f37ed1467c8125bf95f601a1fc4" translate="yes" xml:space="preserve">
          <source>To read back the elements, use &lt;code&gt;TFRecordDataset&lt;/code&gt;.</source>
          <target state="translated">要素を読み戻すには、 &lt;code&gt;TFRecordDataset&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="ff235c20472c16fd213bae4a4af01054d920d420" translate="yes" xml:space="preserve">
          <source>To reconstruct an original waveform, a complementary window function should be used with &lt;code&gt;inverse_stft&lt;/code&gt;. Such a window function can be constructed with &lt;a href=&quot;inverse_stft_window_fn&quot;&gt;&lt;code&gt;tf.signal.inverse_stft_window_fn&lt;/code&gt;&lt;/a&gt;. Example:</source>
          <target state="translated">元の波形を再構築するには、 &lt;code&gt;inverse_stft&lt;/code&gt; で補完的なウィンドウ関数を使用する必要があります。このようなウィンドウ関数は、&lt;a href=&quot;inverse_stft_window_fn&quot;&gt; &lt;code&gt;tf.signal.inverse_stft_window_fn&lt;/code&gt; &lt;/a&gt;で構築できます。例：</target>
        </trans-unit>
        <trans-unit id="a1cda1853dc2b4c5ea41c6c734bd8df45e09a74c" translate="yes" xml:space="preserve">
          <source>To reconstruct an original waveform, the same window function should be used with &lt;code&gt;mdct&lt;/code&gt; and &lt;code&gt;inverse_mdct&lt;/code&gt;.</source>
          <target state="translated">元の波形を再構築するには、同じウィンドウ関数を &lt;code&gt;mdct&lt;/code&gt; と &lt;code&gt;inverse_mdct&lt;/code&gt; で使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="ca5c9dd44204672cbbbbaf3d7ffdd096d2e60573" translate="yes" xml:space="preserve">
          <source>To record statistics, use one of the custom transformation functions defined in this module when defining your &lt;a href=&quot;../../../../data/dataset&quot;&gt;&lt;code&gt;tf.data.Dataset&lt;/code&gt;&lt;/a&gt;. All statistics will be aggregated by the &lt;code&gt;StatsAggregator&lt;/code&gt; that is associated with a particular iterator (see below). For example, to record the latency of producing each element by iterating over a dataset:</source>
          <target state="translated">統計を記録するには、&lt;a href=&quot;../../../../data/dataset&quot;&gt; &lt;code&gt;tf.data.Dataset&lt;/code&gt; を&lt;/a&gt;定義するときに、このモジュールで定義されているカスタム変換関数の1つを使用します。すべての統計は、特定のイテレーターに関連付けられている &lt;code&gt;StatsAggregator&lt;/code&gt; によって集約されます（以下を参照）。たとえば、データセットを反復して各要素を生成するレイテンシを記録するには、次のようにします。</target>
        </trans-unit>
        <trans-unit id="84004f640543424d2c71289d24eec0f0b8df9f20" translate="yes" xml:space="preserve">
          <source>To record statistics, use one of the custom transformation functions defined in this module when defining your &lt;a href=&quot;../dataset&quot;&gt;&lt;code&gt;tf.data.Dataset&lt;/code&gt;&lt;/a&gt;. All statistics will be aggregated by the &lt;code&gt;StatsAggregator&lt;/code&gt; that is associated with a particular iterator (see below). For example, to record the latency of producing each element by iterating over a dataset:</source>
          <target state="translated">統計を記録するには、&lt;a href=&quot;../dataset&quot;&gt; &lt;code&gt;tf.data.Dataset&lt;/code&gt; を&lt;/a&gt;定義するときに、このモジュールで定義されているカスタム変換関数の1つを使用します。すべての統計は、特定のイテレーターに関連付けられている &lt;code&gt;StatsAggregator&lt;/code&gt; によって集約されます（以下を参照）。たとえば、データセットを反復して各要素を生成するレイテンシを記録するには、次のようにします。</target>
        </trans-unit>
        <trans-unit id="6601eea42af302d30ea25dfb68ead4d332e25000" translate="yes" xml:space="preserve">
          <source>To rescale an input in the &lt;code&gt;[0, 255]&lt;/code&gt; range to be in the &lt;code&gt;[-1, 1]&lt;/code&gt; range, you would pass &lt;code&gt;scale=1./127.5, offset=-1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;[0, 255]&lt;/code&gt; 0、255 ]の範囲の入力を &lt;code&gt;[-1, 1]&lt;/code&gt; ]の範囲に再スケーリングするには、 &lt;code&gt;scale=1./127.5, offset=-1&lt;/code&gt; を渡します。</target>
        </trans-unit>
        <trans-unit id="878d90bc13f047ae3b3be5ee736a5ab7a5fd6624" translate="yes" xml:space="preserve">
          <source>To rescale an input in the &lt;code&gt;[0, 255]&lt;/code&gt; range to be in the &lt;code&gt;[0, 1]&lt;/code&gt; range, you would pass &lt;code&gt;scale=1./255&lt;/code&gt;.</source>
          <target state="translated">入力を再スケーリングする &lt;code&gt;[0, 255]&lt;/code&gt; であることが範囲 &lt;code&gt;[0, 1]&lt;/code&gt; の範囲には、通過する &lt;code&gt;scale=1./255&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9bf5571681c9436431c1ed224b52ea46ea226e1b" translate="yes" xml:space="preserve">
          <source>To reset the states of your model, call &lt;code&gt;.reset_states()&lt;/code&gt; on either a specific layer, or on your entire model.</source>
          <target state="translated">モデルの状態をリセットするには、特定のレイヤーまたはモデル全体で &lt;code&gt;.reset_states()&lt;/code&gt; を呼び出します。</target>
        </trans-unit>
        <trans-unit id="5f2fb526cb8dbaa2bd872bcdf1bffcdc847f4f4f" translate="yes" xml:space="preserve">
          <source>To restore variables, you have to know the name of the shadow variables. That name and the original variable can then be passed to a &lt;code&gt;Saver()&lt;/code&gt; object to restore the variable from the moving average value with: &lt;code&gt;saver = tf.compat.v1.train.Saver({ema.average_name(var): var})&lt;/code&gt;</source>
          <target state="translated">変数を復元するには、シャドウ変数の名前を知っている必要があります。次に、その名前と元の変数を &lt;code&gt;Saver()&lt;/code&gt; オブジェクトに渡して、移動平均値から変数を復元できます： &lt;code&gt;saver = tf.compat.v1.train.Saver({ema.average_name(var): var})&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="61b9174bc024e647c5c9bf1631b4141790c76fd9" translate="yes" xml:space="preserve">
          <source>To run TF2 programs on TPUs, you can either use &lt;code&gt;.compile&lt;/code&gt; and &lt;code&gt;.fit&lt;/code&gt; APIs in &lt;a href=&quot;../../keras&quot;&gt;&lt;code&gt;tf.keras&lt;/code&gt;&lt;/a&gt; with TPUStrategy, or write your own customized training loop by calling &lt;code&gt;strategy.experimental_run_v2&lt;/code&gt; directly. Note that TPUStrategy doesn't support pure eager execution, so please make sure the function passed into &lt;code&gt;strategy.experimental_run_v2&lt;/code&gt; is a &lt;a href=&quot;../../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;strategy.experimental_run_v2&lt;/code&gt; us called inside a &lt;a href=&quot;../../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt; if running in eager mode.</source>
          <target state="translated">TPU上でTF2プログラムを実行するには、 &lt;code&gt;.compile&lt;/code&gt; および &lt;code&gt;.fit&lt;/code&gt; APIを&lt;a href=&quot;../../keras&quot;&gt; &lt;code&gt;tf.keras&lt;/code&gt; &lt;/a&gt;で使用するか、 &lt;code&gt;strategy.experimental_run_v2&lt;/code&gt; を直接呼び出して独自のカスタマイズされたトレーニングループを記述します。TPUStrategyは純粋な熱心な実行をサポートしているので確認してくださいに渡された関数にしてくださいしないことに注意してください &lt;code&gt;strategy.experimental_run_v2&lt;/code&gt; がある&lt;a href=&quot;../../function&quot;&gt; &lt;code&gt;tf.function&lt;/code&gt; &lt;/a&gt;か &lt;code&gt;strategy.experimental_run_v2&lt;/code&gt; 私たちは内部で呼び出さ&lt;a href=&quot;../../function&quot;&gt; &lt;code&gt;tf.function&lt;/code&gt; &lt;/a&gt;熱心モードで実行している場合。</target>
        </trans-unit>
        <trans-unit id="75d6af2437dac9afdbd259194ca306ea0df7ba35" translate="yes" xml:space="preserve">
          <source>To run TF2 programs on TPUs, you can either use &lt;code&gt;.compile&lt;/code&gt; and &lt;code&gt;.fit&lt;/code&gt; APIs in &lt;a href=&quot;../../keras&quot;&gt;&lt;code&gt;tf.keras&lt;/code&gt;&lt;/a&gt; with TPUStrategy, or write your own customized training loop by calling &lt;code&gt;strategy.run&lt;/code&gt; directly. Note that TPUStrategy doesn't support pure eager execution, so please make sure the function passed into &lt;code&gt;strategy.run&lt;/code&gt; is a &lt;a href=&quot;../../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;strategy.run&lt;/code&gt; is called inside a &lt;a href=&quot;../../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt; if eager behavior is enabled.</source>
          <target state="translated">TPUは上TF2プログラムを実行するには、使用のいずれかのことができ &lt;code&gt;.compile&lt;/code&gt; と &lt;code&gt;.fit&lt;/code&gt; でAPIを&lt;a href=&quot;../../keras&quot;&gt; &lt;code&gt;tf.keras&lt;/code&gt; &lt;/a&gt; TPUStrategyで、または呼び出すことによって、独自にカスタマイズしたトレーニングループを記述 &lt;code&gt;strategy.run&lt;/code&gt; を直接。TPUStrategyは純粋な熱心な実行をサポートし、そうしてくださいしないことを注意してくださいに渡された関数 &lt;code&gt;strategy.run&lt;/code&gt; はある&lt;a href=&quot;../../function&quot;&gt; &lt;code&gt;tf.function&lt;/code&gt; &lt;/a&gt;または &lt;code&gt;strategy.run&lt;/code&gt; が内部で呼び出され&lt;a href=&quot;../../function&quot;&gt; &lt;code&gt;tf.function&lt;/code&gt; &lt;/a&gt;熱心な動作が有効になっている場合。</target>
        </trans-unit>
        <trans-unit id="1d76e97ea1150910b642e3424cedffc8e064a46d" translate="yes" xml:space="preserve">
          <source>To run TF2 programs on TPUs, you can either use &lt;code&gt;.compile&lt;/code&gt; and &lt;code&gt;.fit&lt;/code&gt; APIs in &lt;a href=&quot;../keras&quot;&gt;&lt;code&gt;tf.keras&lt;/code&gt;&lt;/a&gt; with TPUStrategy, or write your own customized training loop by calling &lt;code&gt;strategy.run&lt;/code&gt; directly. Note that TPUStrategy doesn't support pure eager execution, so please make sure the function passed into &lt;code&gt;strategy.run&lt;/code&gt; is a &lt;a href=&quot;../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;strategy.run&lt;/code&gt; is called inside a &lt;a href=&quot;../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt; if eager behavior is enabled. See more details in https://www.tensorflow.org/guide/tpu.</source>
          <target state="translated">TPUは上TF2プログラムを実行するには、使用のいずれかのことができ &lt;code&gt;.compile&lt;/code&gt; と &lt;code&gt;.fit&lt;/code&gt; でAPIを&lt;a href=&quot;../keras&quot;&gt; &lt;code&gt;tf.keras&lt;/code&gt; &lt;/a&gt; TPUStrategyで、または呼び出すことによって、独自にカスタマイズしたトレーニングループを記述 &lt;code&gt;strategy.run&lt;/code&gt; を直接。TPUStrategyは純粋な熱心な実行をサポートし、そうしてくださいしないことを注意してくださいに渡された関数 &lt;code&gt;strategy.run&lt;/code&gt; はある&lt;a href=&quot;../function&quot;&gt; &lt;code&gt;tf.function&lt;/code&gt; &lt;/a&gt;または &lt;code&gt;strategy.run&lt;/code&gt; が内部で呼び出され&lt;a href=&quot;../function&quot;&gt; &lt;code&gt;tf.function&lt;/code&gt; &lt;/a&gt;熱心な動作が有効になっている場合。詳細については、https：//www.tensorflow.org/guide/tpuをご覧ください。</target>
        </trans-unit>
        <trans-unit id="e990fa899ccbe4b80cb8729867536ff2b0542458" translate="yes" xml:space="preserve">
          <source>To save and restore.</source>
          <target state="translated">保存して復元すること。</target>
        </trans-unit>
        <trans-unit id="b35673692b203b1580cc459164c684b7c71fe1e4" translate="yes" xml:space="preserve">
          <source>To shard a &lt;code&gt;dataset&lt;/code&gt; across multiple TFRecord files:</source>
          <target state="translated">シャードには、 &lt;code&gt;dataset&lt;/code&gt; 複数TFRecordファイル間：</target>
        </trans-unit>
        <trans-unit id="fc6bb2051a5897d4a8d4dac929c8a069356b9e0c" translate="yes" xml:space="preserve">
          <source>To simplify the thread implementation, the Coordinator provides a context handler &lt;code&gt;stop_on_exception()&lt;/code&gt; that automatically requests a stop if an exception is raised. Using the context handler the thread code above can be written as:</source>
          <target state="translated">スレッドの実装を簡素化するために、コーディネーターは、例外が発生した場合に自動的に停止を要求するコンテキストハンドラー &lt;code&gt;stop_on_exception()&lt;/code&gt; を提供します。コンテキストハンドラーを使用すると、上記のスレッドコードは次のように記述できます。</target>
        </trans-unit>
        <trans-unit id="a72b5fda5da9fdf55b3bf54113912820e04f4679" translate="yes" xml:space="preserve">
          <source>To stop the trace and export the collected information, use &lt;a href=&quot;trace_export&quot;&gt;&lt;code&gt;tf.summary.trace_export&lt;/code&gt;&lt;/a&gt;. To stop the trace without exporting, use &lt;a href=&quot;trace_off&quot;&gt;&lt;code&gt;tf.summary.trace_off&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">トレースを停止して収集された情報をエクスポートするには、&lt;a href=&quot;trace_export&quot;&gt; &lt;code&gt;tf.summary.trace_export&lt;/code&gt; を&lt;/a&gt;使用します。エクスポートせずにトレースを停止するには、&lt;a href=&quot;trace_off&quot;&gt; &lt;code&gt;tf.summary.trace_off&lt;/code&gt; を&lt;/a&gt;使用します。</target>
        </trans-unit>
        <trans-unit id="25b078e238adc2f2bf2f225cb3a76dafd2b5b18d" translate="yes" xml:space="preserve">
          <source>To take the transpose of the matrices in dimension-0 (such as when you are transposing matrices where 0 is the batch dimesnion), you would set &lt;code&gt;perm=[0,2,1]&lt;/code&gt;.</source>
          <target state="translated">次元0の行列の転置を行うには（0がバッチ次元である行列を転置する場合など）、 &lt;code&gt;perm=[0,2,1]&lt;/code&gt; を設定します。</target>
        </trans-unit>
        <trans-unit id="78edbe912a6ec7dfbde2fa6ca3dbd293be354b5e" translate="yes" xml:space="preserve">
          <source>To train with replicas you deploy the same program in a &lt;code&gt;Cluster&lt;/code&gt;. One of the tasks must be identified as the &lt;em&gt;chief&lt;/em&gt;: the task that handles initialization, checkpoints, summaries, and recovery. The other tasks depend on the &lt;em&gt;chief&lt;/em&gt; for these services.</source>
          <target state="translated">レプリカでトレーニングするには、同じプログラムを &lt;code&gt;Cluster&lt;/code&gt; デプロイします。タスクの1つは、初期化、チェックポイント、要約、およびリカバリーを処理するタスクである&lt;em&gt;チーフ&lt;/em&gt;として識別される必要があります。その他のタスクは、これらのサービスの&lt;em&gt;責任者に&lt;/em&gt;依存します。</target>
        </trans-unit>
        <trans-unit id="0a01c3edc32585755d57328d40fa48f8fdb3ab82" translate="yes" xml:space="preserve">
          <source>To treat a sparse input as dense, provide &lt;code&gt;allow_missing=True&lt;/code&gt;; otherwise, the parse functions will fail on any examples missing this feature.</source>
          <target state="translated">疎な入力を密に扱うには、 &lt;code&gt;allow_missing=True&lt;/code&gt; を指定します。そうしないと、この機能がない例では解析関数が失敗します。</target>
        </trans-unit>
        <trans-unit id="f70a87293b647de36d39cf376105ebfad1b65755" translate="yes" xml:space="preserve">
          <source>To treat sparse input as dense, provide a &lt;code&gt;default_value&lt;/code&gt;; otherwise, the parse functions will fail on any examples missing this feature.</source>
          <target state="translated">疎な入力を密に扱うには、 &lt;code&gt;default_value&lt;/code&gt; を指定します。そうしないと、この機能がない例では解析関数が失敗します。</target>
        </trans-unit>
        <trans-unit id="2cf2713de328f732331e0697fff7bd058371175a" translate="yes" xml:space="preserve">
          <source>To use &lt;code&gt;MirroredStrategy&lt;/code&gt; with multiple workers, please refer to &lt;code&gt;tf.distribute.MultiWorkerMirroredStrategy&lt;/code&gt;.</source>
          <target state="translated">複数のワーカーで &lt;code&gt;MirroredStrategy&lt;/code&gt; を使用するには、 &lt;code&gt;tf.distribute.MultiWorkerMirroredStrategy&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="12770f5e5f15720c161e4a87129f9d9bb0774bc6" translate="yes" xml:space="preserve">
          <source>To use SyncReplicasOptimizer with an &lt;code&gt;Estimator&lt;/code&gt;, you need to send sync_replicas_hook while calling the fit.</source>
          <target state="translated">&lt;code&gt;Estimator&lt;/code&gt; でSyncReplicasOptimizerを使用するには、近似を呼び出すときにsync_replicas_hookを送信する必要があります。</target>
        </trans-unit>
        <trans-unit id="783180a85bf045e00f72afe9cf4aeba0310e67f8" translate="yes" xml:space="preserve">
          <source>To use a listener, implement a class and pass the listener to a &lt;code&gt;CheckpointSaverHook&lt;/code&gt;, as in this example:</source>
          <target state="translated">リスナーを使用するには、次の例のように、クラスを実装してリスナーを &lt;code&gt;CheckpointSaverHook&lt;/code&gt; に渡します。</target>
        </trans-unit>
        <trans-unit id="dc7556a3e1ddbbfb55342d1204bfb7cd99d3d15a" translate="yes" xml:space="preserve">
          <source>To use another kernel, just replace the layer creation line with:</source>
          <target state="translated">別のカーネルを使用するには、レイヤー作成行を置き換えるだけです。</target>
        </trans-unit>
        <trans-unit id="82a8f0d7938dca39dd9baa444dbabf12a6beff73" translate="yes" xml:space="preserve">
          <source>To use crossed column in DNN model, you need to add it in an embedding column as in this example:</source>
          <target state="translated">DNNモデルでCrossed Columnを使用するには、この例のように埋め込みカラムに追加する必要があります。</target>
        </trans-unit>
        <trans-unit id="df232f0149a3304cb55f19e9533d29d033c88a07" translate="yes" xml:space="preserve">
          <source>To use it with Keras &lt;code&gt;compile&lt;/code&gt;/&lt;code&gt;fit&lt;/code&gt;, &lt;a href=&quot;https://www.tensorflow.org/guide/distributed_training#using_tfdistributestrategy_with_keras&quot;&gt;please read&lt;/a&gt;.</source>
          <target state="translated">Keras &lt;code&gt;compile&lt;/code&gt; / &lt;code&gt;fit&lt;/code&gt; で使用するには、&lt;a href=&quot;https://www.tensorflow.org/guide/distributed_training#using_tfdistributestrategy_with_keras&quot;&gt;読ん&lt;/a&gt;でください。</target>
        </trans-unit>
        <trans-unit id="52761ad57b4e88f15825661793f52089d3153688" translate="yes" xml:space="preserve">
          <source>To use mixed precision in a Keras model, the &lt;code&gt;'mixed_float16'&lt;/code&gt; or &lt;code&gt;'mixed_bfloat16'&lt;/code&gt; policy can be used. &lt;a href=&quot;set_policy&quot;&gt;&lt;code&gt;tf.keras.mixed_precision.experimental.set_policy&lt;/code&gt;&lt;/a&gt; can be used to set the default policy for layers if no policy is passed to them. For example:</source>
          <target state="translated">&lt;code&gt;'mixed_float16'&lt;/code&gt; モデルで混合精度を使用するには、'mixed_float16'または &lt;code&gt;'mixed_bfloat16'&lt;/code&gt; ポリシーを使用できます。&lt;a href=&quot;set_policy&quot;&gt; &lt;code&gt;tf.keras.mixed_precision.experimental.set_policy&lt;/code&gt; &lt;/a&gt;を使用すると、レイヤーにポリシーが渡されない場合に、レイヤーのデフォルトポリシーを設定できます。例えば：</target>
        </trans-unit>
        <trans-unit id="e3bc90b596c6a06641f646fd21855a01a15f891a" translate="yes" xml:space="preserve">
          <source>To use partial execution, a user first calls &lt;code&gt;partial_run_setup()&lt;/code&gt; and then a sequence of &lt;code&gt;partial_run()&lt;/code&gt;. &lt;code&gt;partial_run_setup&lt;/code&gt; specifies the list of feeds and fetches that will be used in the subsequent &lt;code&gt;partial_run&lt;/code&gt; calls.</source>
          <target state="translated">部分実行を使用するには、ユーザーは最初に &lt;code&gt;partial_run_setup()&lt;/code&gt; を呼び出してから、一連の &lt;code&gt;partial_run()&lt;/code&gt; を呼び出します。 &lt;code&gt;partial_run_setup&lt;/code&gt; は、後続の &lt;code&gt;partial_run&lt;/code&gt; 呼び出しで使用されるフィードとフェッチのリストを指定します。</target>
        </trans-unit>
        <trans-unit id="0486110c8c71e38a21a240cd6d1c94b9eb3a8e49" translate="yes" xml:space="preserve">
          <source>To use the pprof file:</source>
          <target state="translated">pprofファイルを使用するには</target>
        </trans-unit>
        <trans-unit id="77972f247631f66b18016dae59b6ae8450d1266a" translate="yes" xml:space="preserve">
          <source>To use the replacement for variables which does not have these issues:</source>
          <target state="translated">これらの問題を持たない変数の置換を使用するため。</target>
        </trans-unit>
        <trans-unit id="49e82f46abbf85f6d932a9d996d53b01fa3132b2" translate="yes" xml:space="preserve">
          <source>To use this API on TPU you should use a custom training loop. Below is an example of a training and evaluation step:</source>
          <target state="translated">TPUでこのAPIを使用するには、カスタムトレーニングループを使用する必要があります。以下にトレーニングと評価のステップの例を示します。</target>
        </trans-unit>
        <trans-unit id="d9fed22a474957718b6e8cceaa345a94b692ff2f" translate="yes" xml:space="preserve">
          <source>To use, enqueue filenames in a Queue. The output of Read will be a filename (key) and the contents of that file (value).</source>
          <target state="translated">使用するには、ファイル名をキューにエンキューします。Readの出力は、ファイル名(キー)とそのファイルの内容(値)になります。</target>
        </trans-unit>
        <trans-unit id="22500ae27d7e8f143eaf335c0b5e17ab00f9b916" translate="yes" xml:space="preserve">
          <source>To use, enqueue filenames in a Queue. The output of ReaderRead will be a filename (key) and the contents of that file (value).</source>
          <target state="translated">使用するには、ファイル名をキューにエンキューします。ReaderReadの出力は、ファイル名(キー)とそのファイルの内容(値)になります。</target>
        </trans-unit>
        <trans-unit id="936bb6e71e849ce05ab2a85d8c98f04120f3012d" translate="yes" xml:space="preserve">
          <source>To use, enqueue strings in a Queue. Read will take the front work string and output (work, work).</source>
          <target state="translated">使用するには、文字列をQueueでエンキューします。Readは前の作業文字列を取り、出力(work,作業)します。</target>
        </trans-unit>
        <trans-unit id="c154b7f61f883ef570a45770d3ff51fd323c7da3" translate="yes" xml:space="preserve">
          <source>To use, enqueue strings in a Queue. ReaderRead will take the front work string and output (work, work).</source>
          <target state="translated">使用するには、文字列をQueueでエンキューします。ReaderReadは前の仕事の文字列を取り、出力(仕事、仕事)をします。</target>
        </trans-unit>
        <trans-unit id="3b5c6be676ffa47f64b992a379fa3a687addb427" translate="yes" xml:space="preserve">
          <source>To warm-start an &lt;code&gt;Estimator&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;Estimator&lt;/code&gt; をウォームスタートするには：</target>
        </trans-unit>
        <trans-unit id="4e303367b1554b64249c563b8cdde01d47543e39" translate="yes" xml:space="preserve">
          <source>ToBool</source>
          <target state="translated">ToBool</target>
        </trans-unit>
        <trans-unit id="487247adcb71f2786b8b26a837b3a8f982eb5eb2" translate="yes" xml:space="preserve">
          <source>Toeplitz and Circulant Matrices - A Review: &lt;a href=&quot;https://www.nowpublishers.com/article/Details/CIT-006&quot;&gt;Gray, 2006&lt;/a&gt; (&lt;a href=&quot;https://ee.stanford.edu/%7Egray/toeplitz.pdf&quot;&gt;pdf&lt;/a&gt;)</source>
          <target state="translated">テプリッツ行列と巡回行列-レビュー：&lt;a href=&quot;https://www.nowpublishers.com/article/Details/CIT-006&quot;&gt;灰色、2006年&lt;/a&gt;（&lt;a href=&quot;https://ee.stanford.edu/%7Egray/toeplitz.pdf&quot;&gt;pdf&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="33d27663923e948257deb0ac3f48e158f539a021" translate="yes" xml:space="preserve">
          <source>Toeplitz means that &lt;code&gt;A&lt;/code&gt; has constant diagonals. Hence, &lt;code&gt;A&lt;/code&gt; can be generated with two vectors. One represents the first column of the matrix, and the other represents the first row.</source>
          <target state="translated">Toeplitzは、 &lt;code&gt;A&lt;/code&gt; の対角成分が一定であることを意味します。したがって、 &lt;code&gt;A&lt;/code&gt; は2つのベクトルで生成できます。 1つは行列の最初の列を表し、もう1つは最初の行を表します。</target>
        </trans-unit>
        <trans-unit id="0b92ef92f904efdaf4c897b9d82c8d8bc711a6dd" translate="yes" xml:space="preserve">
          <source>Top K categorical accuracy value.</source>
          <target state="translated">トップKのカテゴリ精度値。</target>
        </trans-unit>
        <trans-unit id="00a0204649835b513c94e7dcd17a04a18748c48f" translate="yes" xml:space="preserve">
          <source>TopK</source>
          <target state="translated">TopK</target>
        </trans-unit>
        <trans-unit id="9be91f59904e4556becc788662db35f00e8e37f9" translate="yes" xml:space="preserve">
          <source>TopKV2</source>
          <target state="translated">TopKV2</target>
        </trans-unit>
        <trans-unit id="ecc5f00336dd7a221505890680888796ae7ad79b" translate="yes" xml:space="preserve">
          <source>Total length of printed lines (e.g. set this to adapt the display to different terminal window sizes).</source>
          <target state="translated">印刷される行の長さの合計(例えば、異なる端末のウィンドウサイズに合わせて表示を適応させるためにこれを設定します)。</target>
        </trans-unit>
        <trans-unit id="18b8da40b59609823f34b2eae31c92eb13b8a1df" translate="yes" xml:space="preserve">
          <source>Total number of steps (batches of samples) before declaring the prediction round finished. Ignored with the default value of &lt;code&gt;None&lt;/code&gt;. If x is a &lt;a href=&quot;../../data&quot;&gt;&lt;code&gt;tf.data&lt;/code&gt;&lt;/a&gt; dataset and &lt;code&gt;steps&lt;/code&gt; is None, &lt;code&gt;predict&lt;/code&gt; will run until the input dataset is exhausted.</source>
          <target state="translated">予測ラウンドが終了したと宣言するまでの合計ステップ数（サンプルのバッチ）。デフォルト値の &lt;code&gt;None&lt;/code&gt; では無視されます。xがある場合&lt;a href=&quot;../../data&quot;&gt; &lt;code&gt;tf.data&lt;/code&gt; &lt;/a&gt;データセットと &lt;code&gt;steps&lt;/code&gt; Noneです、 &lt;code&gt;predict&lt;/code&gt; 入力データセットがなくなるまで実行されます。</target>
        </trans-unit>
        <trans-unit id="d64736c6b92cc8a7d61eecd538f81edd562b347c" translate="yes" xml:space="preserve">
          <source>Total number of steps (batches of samples) before declaring the prediction round finished. Ignored with the default value of &lt;code&gt;None&lt;/code&gt;. If x is a &lt;a href=&quot;../data&quot;&gt;&lt;code&gt;tf.data&lt;/code&gt;&lt;/a&gt; dataset and &lt;code&gt;steps&lt;/code&gt; is None, &lt;code&gt;predict&lt;/code&gt; will run until the input dataset is exhausted.</source>
          <target state="translated">予測ラウンドが終了したと宣言するまでの合計ステップ数（サンプルのバッチ）。デフォルト値の &lt;code&gt;None&lt;/code&gt; では無視されます。xがある場合&lt;a href=&quot;../data&quot;&gt; &lt;code&gt;tf.data&lt;/code&gt; &lt;/a&gt;データセットと &lt;code&gt;steps&lt;/code&gt; Noneです、 &lt;code&gt;predict&lt;/code&gt; 入力データセットがなくなるまで実行されます。</target>
        </trans-unit>
        <trans-unit id="f9b71747c87f2120b712f35eff6cd2daf9f890ef" translate="yes" xml:space="preserve">
          <source>Total number of steps expected, None if unknown.</source>
          <target state="translated">予想される総ステップ数、不明な場合はなし。</target>
        </trans-unit>
        <trans-unit id="2b273e7fcad30a2510d0545ec0ed37f53fcc2226" translate="yes" xml:space="preserve">
          <source>Total number of tasks/workers/replicas, could be different from replicas_to_aggregate. If total_num_replicas &amp;gt; replicas_to_aggregate: it is backup_replicas + replicas_to_aggregate. If total_num_replicas &amp;lt; replicas_to_aggregate: Replicas compute multiple batches per update to variables.</source>
          <target state="translated">タスク/ワーカー/レプリカの総数は、replicas_to_aggregateとは異なる場合があります。total_num_replicas&amp;gt; Replicas_to_aggregateの場合：backup_replicas + replicas_to_aggregateです。total_num_replicas &amp;lt;replicas_to_aggregateの場合：レプリカは、変数の更新ごとに複数のバッチを計算します。</target>
        </trans-unit>
        <trans-unit id="3c766217ff2603fec7b0d19fd0e734ed0a36b0a6" translate="yes" xml:space="preserve">
          <source>Trace events are created only when the profiler is enabled. More information on how to use the profiler can be found at &lt;a href=&quot;https://tensorflow.org/guide/profiler&quot;&gt;https://tensorflow.org/guide/profiler&lt;/a&gt;</source>
          <target state="translated">トレースイベントは、プロファイラーが有効になっている場合にのみ作成されます。プロファイラーの使用方法の詳細については、&lt;a href=&quot;https://tensorflow.org/guide/profiler&quot;&gt;https：//tensorflow.org/guide/profilerをご覧ください。&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="121fe412af2d5e916662ca3ec0794ef40b1e2f67" translate="yes" xml:space="preserve">
          <source>Trace of the linear operator, equal to sum of &lt;code&gt;self.diag_part()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;self.diag_part()&lt;/code&gt; の合計に等しい線形演算子のトレース。</target>
        </trans-unit>
        <trans-unit id="865739f4547ef1507e787549027075c5e994644c" translate="yes" xml:space="preserve">
          <source>Trace the function</source>
          <target state="translated">機能をトレースする</target>
        </trans-unit>
        <trans-unit id="36823bd4f0f4f117aef52940f9d3cfb4969f8d54" translate="yes" xml:space="preserve">
          <source>Trace the function, see the &lt;a href=&quot;https://www.tensorflow.org/guide/concrete_function&quot;&gt;Concrete Functions Guide&lt;/a&gt; for details.</source>
          <target state="translated">関数をトレースします。詳細については、「&lt;a href=&quot;https://www.tensorflow.org/guide/concrete_function&quot;&gt;具体的な関数ガイド」&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="a3cd08d7e53167c39ff4df8ac6fd7573ac51ea11" translate="yes" xml:space="preserve">
          <source>Traces argument information at compilation time.</source>
          <target state="translated">コンパイル時に引数情報をトレースします。</target>
        </trans-unit>
        <trans-unit id="0eed61bd40a0f60d630ca02fa135c76ba2b343a8" translate="yes" xml:space="preserve">
          <source>Tracing may fail if a shape missmatch can be detected:</source>
          <target state="translated">形状の不一致が検出された場合、トレースに失敗することがあります。</target>
        </trans-unit>
        <trans-unit id="235a91222dd28e8e16c0e133dc2cba6c6d12742f" translate="yes" xml:space="preserve">
          <source>Train a linear model to classify instances into one of multiple possible classes. When number of possible classes is 2, this is binary classification.</source>
          <target state="translated">インスタンスを複数の可能なクラスのいずれかに分類するために線形モデルを訓練する。可能なクラスの数が2の場合、これは2進分類です。</target>
        </trans-unit>
        <trans-unit id="ee3c9790cb66e90ecfd717511a371fde17bac07c" translate="yes" xml:space="preserve">
          <source>Train a linear regression model to predict label value given observation of feature values.</source>
          <target state="translated">特徴量の観測が与えられたラベル値を予測するために線形回帰モデルを訓練します。</target>
        </trans-unit>
        <trans-unit id="3efa73c7139b833a96e690294f1f5dee0c8dafcf" translate="yes" xml:space="preserve">
          <source>Train and evaluate the &lt;code&gt;estimator&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;estimator&lt;/code&gt; して評価します。</target>
        </trans-unit>
        <trans-unit id="beb3053fd8366acd014d9b2f3ece6098b4b72e55" translate="yes" xml:space="preserve">
          <source>Train and evaluate with Keras</source>
          <target state="translated">ケラスでのトレーニングと評価</target>
        </trans-unit>
        <trans-unit id="cc6f15e9d8d0df93c841a4bfbdce1ebcc8b8e338" translate="yes" xml:space="preserve">
          <source>Trainable variables (created by &lt;a href=&quot;variable&quot;&gt;&lt;code&gt;tf.Variable&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;compat/v1/get_variable&quot;&gt;&lt;code&gt;tf.compat.v1.get_variable&lt;/code&gt;&lt;/a&gt;, where &lt;code&gt;trainable=True&lt;/code&gt; is default in both cases) are automatically watched. Tensors can be manually watched by invoking the &lt;code&gt;watch&lt;/code&gt; method on this context manager.</source>
          <target state="translated">（によって作成されたトレーニング可能な変数&lt;a href=&quot;variable&quot;&gt; &lt;code&gt;tf.Variable&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;compat/v1/get_variable&quot;&gt; &lt;code&gt;tf.compat.v1.get_variable&lt;/code&gt; &lt;/a&gt;、 &lt;code&gt;trainable=True&lt;/code&gt; いずれの場合も、デフォルトでは）自動的に見守っています。テンソルは、このコンテキストマネージャーで &lt;code&gt;watch&lt;/code&gt; メソッドを呼び出すことにより、手動で監視できます。</target>
        </trans-unit>
        <trans-unit id="d85aa0db75043b2fc7e6d076a658d6108e846757" translate="yes" xml:space="preserve">
          <source>Training checkpoints</source>
          <target state="translated">トレーニングチェックポイント</target>
        </trans-unit>
        <trans-unit id="10de55a426007543588aad0c26e9034f2ddc3a47" translate="yes" xml:space="preserve">
          <source>Training graph visualization</source>
          <target state="translated">トレーニンググラフの可視化</target>
        </trans-unit>
        <trans-unit id="7db0d855207cb66583c78145b39525c5633639da" translate="yes" xml:space="preserve">
          <source>Training helper that restores from checkpoint and creates session.</source>
          <target state="translated">チェックポイントから復元してセッションを作成するトレーニングヘルパー。</target>
        </trans-unit>
        <trans-unit id="fb6f2aff4ed7bb3a59f319dbd5466e071cc53fba" translate="yes" xml:space="preserve">
          <source>Training loss &lt;code&gt;Tensor&lt;/code&gt;. Must be either scalar, or with shape &lt;code&gt;[1]&lt;/code&gt;.</source>
          <target state="translated">トレーニング損失 &lt;code&gt;Tensor&lt;/code&gt; 。スカラー、または形状 &lt;code&gt;[1]&lt;/code&gt; のいずれかである必要があります。</target>
        </trans-unit>
        <trans-unit id="7079a2991739ec717b2df9e546127d4ec5f23f66" translate="yes" xml:space="preserve">
          <source>Training step to trigger on.</source>
          <target state="translated">トリガーオンのトレーニングステップ。</target>
        </trans-unit>
        <trans-unit id="bf6759c44ad41b3091516c81e1bc49fed1c443ea" translate="yes" xml:space="preserve">
          <source>Trains a model given training data &lt;code&gt;input_fn&lt;/code&gt;.</source>
          <target state="translated">トレーニングデータ &lt;code&gt;input_fn&lt;/code&gt; を指定してモデルをトレーニングします。</target>
        </trans-unit>
        <trans-unit id="3b7a7a43991418e3ac5adb5f5a2111146e234e48" translate="yes" xml:space="preserve">
          <source>Trains a recurrent neural network model to classify instances into one of multiple classes.</source>
          <target state="translated">インスタンスを複数のクラスのいずれかに分類するためのリカレント・ニューラル・ネットワーク・モデルを学習します。</target>
        </trans-unit>
        <trans-unit id="03d8eb1e5694e7e09ad702ee89cbe5988334450c" translate="yes" xml:space="preserve">
          <source>Trains the model for a fixed number of epochs (iterations on a dataset).</source>
          <target state="translated">固定のエポック数(データセット上での反復)でモデルを学習します.</target>
        </trans-unit>
        <trans-unit id="e5238d35744e76f113cfe81d17fbfa29f295ac05" translate="yes" xml:space="preserve">
          <source>Transcode the input text from a source encoding to a destination encoding.</source>
          <target state="translated">入力テキストをソースエンコーディングからデスティネーションエンコーディングにトランスコードします。</target>
        </trans-unit>
        <trans-unit id="983dff86700d17b79a819dfaab7edfc9d23e3e22" translate="yes" xml:space="preserve">
          <source>Transfer learning with TensorFlow Hub</source>
          <target state="translated">TensorFlow Hubを使ったトランスファー学習</target>
        </trans-unit>
        <trans-unit id="db752c46f6cefcfd15e6ab5a7acbda3b3ec8bdb7" translate="yes" xml:space="preserve">
          <source>Transfer learning with a pretrained ConvNet</source>
          <target state="translated">事前に訓練されたConvNetを使った転送学習</target>
        </trans-unit>
        <trans-unit id="d3f4cdda163a694c3d7aafb554148d5d45b68f92" translate="yes" xml:space="preserve">
          <source>Transform [batch] matrix &lt;code&gt;x&lt;/code&gt; with left multiplication: &lt;code&gt;x --&amp;gt; Ax&lt;/code&gt;.</source>
          <target state="translated">[バッチ]行列 &lt;code&gt;x&lt;/code&gt; を左乗算で変換します： &lt;code&gt;x --&amp;gt; Ax&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="42db4158efb02ff54237870e3243b8f49a10cb88" translate="yes" xml:space="preserve">
          <source>Transform [batch] vector &lt;code&gt;x&lt;/code&gt; with left multiplication: &lt;code&gt;x --&amp;gt; Ax&lt;/code&gt;.</source>
          <target state="translated">[バッチ]ベクトル &lt;code&gt;x&lt;/code&gt; を左乗算で変換します： &lt;code&gt;x --&amp;gt; Ax&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d685ad7c59aeb1945ef867b52857539b62c1b81c" translate="yes" xml:space="preserve">
          <source>Transformations</source>
          <target state="translated">Transformations</target>
        </trans-unit>
        <trans-unit id="74bb10df9a38f2595c0a343bb271e614fdcbbc79" translate="yes" xml:space="preserve">
          <source>Transformations:</source>
          <target state="translated">Transformations:</target>
        </trans-unit>
        <trans-unit id="a65cfd47338728767e1d8fe389f325154f22e3d2" translate="yes" xml:space="preserve">
          <source>Transformer model for language understanding</source>
          <target state="translated">言語理解のための変圧器モデル</target>
        </trans-unit>
        <trans-unit id="c6c688b7b4f9c9a55098909d8e4bbea04f915bb0" translate="yes" xml:space="preserve">
          <source>Transforms &lt;code&gt;elems&lt;/code&gt; by applying &lt;code&gt;fn&lt;/code&gt; to each element unstacked on axis 0. (deprecated arguments)</source>
          <target state="translated">変換 &lt;code&gt;elems&lt;/code&gt; を適用することによって &lt;code&gt;fn&lt;/code&gt; 軸0（非推奨の引数）にアンスタックの各要素に対して</target>
        </trans-unit>
        <trans-unit id="33d02a85618ebba62b643cdb3a4e3f69d88e4866" translate="yes" xml:space="preserve">
          <source>Transforms &lt;code&gt;input_dataset&lt;/code&gt; containing &lt;code&gt;Example&lt;/code&gt; protos as vectors of DT_STRING into a dataset of &lt;code&gt;Tensor&lt;/code&gt; or &lt;code&gt;SparseTensor&lt;/code&gt; objects representing the parsed features.</source>
          <target state="translated">変換 &lt;code&gt;input_dataset&lt;/code&gt; 含有する &lt;code&gt;Example&lt;/code&gt; のデータセットにDT_STRINGのベクトルとしてPROTOSを &lt;code&gt;Tensor&lt;/code&gt; または &lt;code&gt;SparseTensor&lt;/code&gt; は、解析された特徴を表すオブジェクト。</target>
        </trans-unit>
        <trans-unit id="ae192d97c8bb43adae60e73f077c7a262798214c" translate="yes" xml:space="preserve">
          <source>Transforms a Tensor into a serialized TensorProto proto.</source>
          <target state="translated">Tensorをシリアル化されたTensorProto protoに変換します。</target>
        </trans-unit>
        <trans-unit id="4999b7a71f3c11d96be3e3808c9e8fc9eb261a51" translate="yes" xml:space="preserve">
          <source>Transforms a scalar brain.SequenceExample proto (as strings) into typed tensors.</source>
          <target state="translated">スカラーの brain.SequenceExample プロト(文字列として)を型付きテンソルに変換します。</target>
        </trans-unit>
        <trans-unit id="3fe37f8377ecffffde4f3405645d41e0b3b001bd" translate="yes" xml:space="preserve">
          <source>Transforms a serialized tensorflow.TensorProto proto into a Tensor.</source>
          <target state="translated">シリアライズされたtensorflow.TensorProtoプロトをTensorに変換します。</target>
        </trans-unit>
        <trans-unit id="f6ffa885d4348734b93da08e4df5eb979eae50df" translate="yes" xml:space="preserve">
          <source>Transforms a spectrogram into a form that's useful for speech recognition.</source>
          <target state="translated">スペクトログラムを音声認識に便利な形式に変換します。</target>
        </trans-unit>
        <trans-unit id="bd2f17793a2563570a330d4671f70e89b2937951" translate="yes" xml:space="preserve">
          <source>Transforms a tf.Example proto (as a string) into typed tensors.</source>
          <target state="translated">(文字列としての)tf.Example protoを型付きテンソルに変換します。</target>
        </trans-unit>
        <trans-unit id="0b8677520a5e74e9b4b4788602fe7bc1e6fe1360" translate="yes" xml:space="preserve">
          <source>Transforms a vector of brain.Example protos (as strings) into typed tensors.</source>
          <target state="translated">脳のベクトルを変換します.例:(文字列としての)プロトスを型付きテンソルに変換します.</target>
        </trans-unit>
        <trans-unit id="be5a4de021d7eadbe941c3409ada3c7b1dabaea1" translate="yes" xml:space="preserve">
          <source>Transforms a vector of brain.SequenceExample protos (as strings) into typed tensors.</source>
          <target state="translated">brain.SequenceExampleのprotos(文字列)のベクトルを型付きテンソルに変換します。</target>
        </trans-unit>
        <trans-unit id="eb363dfb8e50cc87a12a26568447baf08e0619fb" translate="yes" xml:space="preserve">
          <source>Transforms a vector of tf.Example protos (as strings) into typed tensors.</source>
          <target state="translated">tf.Exampleのprotos(文字列)のベクトルを型付きテンソルに変換します.</target>
        </trans-unit>
        <trans-unit id="db88575dec31c88470bf932dd1fed9370a7d6c45" translate="yes" xml:space="preserve">
          <source>Transforms a vector of tf.io.SequenceExample protos (as strings) into</source>
          <target state="translated">(文字列としての)tf.io.SequenceExampleのprotosのベクトルを</target>
        </trans-unit>
        <trans-unit id="655ffb734eb7a488c9c872982dd743f0f56654c3" translate="yes" xml:space="preserve">
          <source>Transforms each input point to its distances to all cluster centers.</source>
          <target state="translated">各入力点をすべてのクラスタ中心までの距離に変換します。</target>
        </trans-unit>
        <trans-unit id="fcd8235ad6fe846d496fe3b5ab9ef987b5075ab1" translate="yes" xml:space="preserve">
          <source>Transforms each sequence in &lt;code&gt;sequences&lt;/code&gt; to a list of texts(strings).</source>
          <target state="translated">各シーケンス変換 &lt;code&gt;sequences&lt;/code&gt; テキスト（文字列）のリストに。</target>
        </trans-unit>
        <trans-unit id="e5d4ddf915c1a321118b7e1927e1abe917834a51" translate="yes" xml:space="preserve">
          <source>Transforms each sequence into a list of text.</source>
          <target state="translated">各シーケンスをテキストのリストに変換します。</target>
        </trans-unit>
        <trans-unit id="15870f729495d9cc692bfd46436e8e2286a88257" translate="yes" xml:space="preserve">
          <source>Transforms each text in &lt;code&gt;texts&lt;/code&gt; to a sequence of integers.</source>
          <target state="translated">内の各テキスト変換し &lt;code&gt;texts&lt;/code&gt; 整数のシーケンスに。</target>
        </trans-unit>
        <trans-unit id="86add4b4e27d9c231884be5bf0ca73d7ca67d517" translate="yes" xml:space="preserve">
          <source>Transforms each text in texts to a sequence of integers.</source>
          <target state="translated">テキスト内の各テキストを整数列に変換します。</target>
        </trans-unit>
        <trans-unit id="71016bf2a8086e5adaa42aba0ed39ec30d8c82a3" translate="yes" xml:space="preserve">
          <source>Transparently swap the tensors produced in forward inference but needed for back prop from GPU to CPU. This allows training RNNs which would typically not fit on a single GPU, with very minimal (or no) performance penalty.</source>
          <target state="translated">前方推論で生成されたテンソルを、GPUからCPUへの後方支援に必要なテンソルに入れ替えます。これにより、通常は単一のGPUには収まらないようなRNNを、性能上のペナルティを非常に少なく(あるいは全くなく)して学習することができます。</target>
        </trans-unit>
        <trans-unit id="fa257429d8539a08df2ef78919507d4169cac2c8" translate="yes" xml:space="preserve">
          <source>Transpose</source>
          <target state="translated">Transpose</target>
        </trans-unit>
        <trans-unit id="c6f3940520a66558ccbf4deb29b8ad759ce2893f" translate="yes" xml:space="preserve">
          <source>Transpose image(s) by swapping the height and width dimension.</source>
          <target state="translated">高さと幅の寸法を入れ替えて画像を入れ替えます。</target>
        </trans-unit>
        <trans-unit id="aaef5878a51828ef045b24256f979251b2fa2f09" translate="yes" xml:space="preserve">
          <source>Transposed 2D convolution layer (sometimes called 2D Deconvolution).</source>
          <target state="translated">トランスポーズされた2次元畳み込み層(2次元デコンボリューションと呼ばれることもある)。</target>
        </trans-unit>
        <trans-unit id="20b55b4579cc2c500b14b1401912fc234412af61" translate="yes" xml:space="preserve">
          <source>Transposed 3D convolution layer (sometimes called 3D Deconvolution).</source>
          <target state="translated">転置3次元畳み込み層(3次元デコンボリューションと呼ばれることもある)。</target>
        </trans-unit>
        <trans-unit id="8af454b225f62d0dcbcdc7d510f5d2a829dab734" translate="yes" xml:space="preserve">
          <source>Transposed convolution layer (sometimes called Deconvolution).</source>
          <target state="translated">トランスポーズされた畳み込み層(デコンボリューションと呼ばれることもある)。</target>
        </trans-unit>
        <trans-unit id="c1808bb1215e7e8c12e0e53a29ab899fd06887f1" translate="yes" xml:space="preserve">
          <source>Transposes &lt;code&gt;a&lt;/code&gt;, where &lt;code&gt;a&lt;/code&gt; is a Tensor.</source>
          <target state="translated">を転置 &lt;code&gt;a&lt;/code&gt; ます。ここで &lt;code&gt;a&lt;/code&gt; はテンソルです。</target>
        </trans-unit>
        <trans-unit id="4559d9f372084e43321f8c8b67aa21b4b3be2db7" translate="yes" xml:space="preserve">
          <source>Transposes &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">を転置 &lt;code&gt;a&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="5f6a95a7cfa0d75e4317493ed12e7c428f7e9164" translate="yes" xml:space="preserve">
          <source>Transposes a &lt;code&gt;SparseTensor&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;SparseTensor&lt;/code&gt; を転置します</target>
        </trans-unit>
        <trans-unit id="2262bf9a92872de90cc8f31b3040779445c53825" translate="yes" xml:space="preserve">
          <source>Transposes a tensor and returns it.</source>
          <target state="translated">テンソルを転置して返します。</target>
        </trans-unit>
        <trans-unit id="52d7d3690c76e45b3f4ac6d7704301666eae2d1f" translate="yes" xml:space="preserve">
          <source>Transposes last two dimensions of tensor &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">テンソル &lt;code&gt;a&lt;/code&gt; の最後の2次元を転置します。</target>
        </trans-unit>
        <trans-unit id="9979dd1e79bbad4d151836984b737dcb27347af2" translate="yes" xml:space="preserve">
          <source>Transposes the inner (matrix) dimensions of a CSRSparseMatrix.</source>
          <target state="translated">CSRSparseMatrixの内部(行列)次元を転置します.</target>
        </trans-unit>
        <trans-unit id="3011a7a9922254d6bc94cbf852ba13e1faec6347" translate="yes" xml:space="preserve">
          <source>Transposes the inner (matrix) dimensions of a SparseMatrix and optionally conjugates its values.</source>
          <target state="translated">SparseMatrix の内部(行列)次元を転置し,オプションでその値を共役化します.</target>
        </trans-unit>
        <trans-unit id="ad508b5e8ca6e24e73ed31c06d7f5a032986b9fa" translate="yes" xml:space="preserve">
          <source>Transposes the last two dimensions of and conjugates tensor &lt;code&gt;matrix&lt;/code&gt;.</source>
          <target state="translated">の最後の2次元を転置し、テンソル &lt;code&gt;matrix&lt;/code&gt; を共役します。</target>
        </trans-unit>
        <trans-unit id="50adcae727c1540c5f8c2710b6a31d5f9d861f46" translate="yes" xml:space="preserve">
          <source>TridiagonalMatMul</source>
          <target state="translated">TridiagonalMatMul</target>
        </trans-unit>
        <trans-unit id="90d5236e355acbf1f60d52716bcd6f0402f00405" translate="yes" xml:space="preserve">
          <source>TridiagonalSolve</source>
          <target state="translated">TridiagonalSolve</target>
        </trans-unit>
        <trans-unit id="06d45be632bf282d211af84cbad96e7a33a03b23" translate="yes" xml:space="preserve">
          <source>Trouser</source>
          <target state="translated">Trouser</target>
        </trans-unit>
        <trans-unit id="afd4d25dce087075230a2ce40818eed7a8b7c821" translate="yes" xml:space="preserve">
          <source>True and exponential_avg_factor != 1.0: Mean must be a &lt;code&gt;Tensor&lt;/code&gt; of the same shape as scale containing the exponential running mean.</source>
          <target state="translated">Trueおよびexponential_avg_factor！= 1.0：平均は、指数移動平均を含むスケールと同じ形状の &lt;code&gt;Tensor&lt;/code&gt; である必要があります。</target>
        </trans-unit>
        <trans-unit id="b0904ca48cae02b60d23262abfe2ce903cfefb1e" translate="yes" xml:space="preserve">
          <source>True and exponential_avg_factor == 1.0: Mean must be None. is_training</source>
          <target state="translated">真であり、exponential_avg_factor ==1.0であること。平均値は None でなければなりません。</target>
        </trans-unit>
        <trans-unit id="3c2872020c8add34a2cf2fcba50775a603f0d0e2" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;v&lt;/code&gt; was created inside the scope, False if not.</source>
          <target state="translated">スコープ内に &lt;code&gt;v&lt;/code&gt; が作成された場合はTrue、作成されなかった場合はFalse。</target>
        </trans-unit>
        <trans-unit id="ea6d3038da7212df43580d700019b440b6df39f7" translate="yes" xml:space="preserve">
          <source>True if a GPU device of the requested kind is available.</source>
          <target state="translated">要求された種類のGPUデバイスが利用可能な場合は真。</target>
        </trans-unit>
        <trans-unit id="0182552244a71267208d89b4ec5f7f593b52459d" translate="yes" xml:space="preserve">
          <source>True if a Tensor of the &lt;code&gt;other&lt;/code&gt;&lt;code&gt;DType&lt;/code&gt; will be implicitly converted to this &lt;code&gt;DType&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;other&lt;/code&gt; &lt;code&gt;DType&lt;/code&gt; の Tensor が暗黙的にこの &lt;code&gt;DType&lt;/code&gt; に変換される場合はTrue 。</target>
        </trans-unit>
        <trans-unit id="d65dfa1082053356f76fa7e32f60ffc009e106a5" translate="yes" xml:space="preserve">
          <source>True if a stop was requested.</source>
          <target state="translated">停止が要求された場合は真。</target>
        </trans-unit>
        <trans-unit id="fba54694bed7e972eba04ddb43445b6835518a56" translate="yes" xml:space="preserve">
          <source>True if inside a &lt;code&gt;with strategy.scope():&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;with strategy.scope():&lt;/code&gt; 内部にある場合はtrueです。</target>
        </trans-unit>
        <trans-unit id="0d356c240016a0c32cb15a7f51543e8af63f4aad" translate="yes" xml:space="preserve">
          <source>True if spec_or_tensor is compatible with self.</source>
          <target state="translated">spec_or_tensorがselfと互換性があれば真。</target>
        </trans-unit>
        <trans-unit id="f031713f493f44a87f541097d9a6c4633a7c4174" translate="yes" xml:space="preserve">
          <source>True if the Coordinator is told stop, False if the timeout expired.</source>
          <target state="translated">コーディネータが停止を指示された場合はTrue、タイムアウトが切れた場合はFalseとなります。</target>
        </trans-unit>
        <trans-unit id="40e3b3363df1be71fab94fcf563145f01a88073c" translate="yes" xml:space="preserve">
          <source>True if the caller can expect that serialized TensorFlow graphs produced can be consumed by programs that are compiled with the TensorFlow library source code after (year, month, day).</source>
          <target state="translated">呼び出し元が、生成されたシリアル化されたTensorFlowグラフが、(年、月、日)の後にTensorFlowライブラリのソースコードでコンパイルされたプログラムによって消費されることを期待できる場合には真です。</target>
        </trans-unit>
        <trans-unit id="5bee156ad7270160152bb6dbabfb7781157fb705" translate="yes" xml:space="preserve">
          <source>True if the constructor is being called by one of the factory methods. If false, an exception will be raised.</source>
          <target state="translated">コンストラクタがファクトリーメソッドのいずれかによって呼び出されている場合は真。false の場合は例外が発生します。</target>
        </trans-unit>
        <trans-unit id="4faef914883a1a10aa15778c49f35fb98be8732e" translate="yes" xml:space="preserve">
          <source>True if the coordinator was told to stop, False otherwise.</source>
          <target state="translated">コーディネーターに止めろと言われた場合は真、そうでない場合は偽。</target>
        </trans-unit>
        <trans-unit id="41bb9eed11faf580e5cf2243f1284401f224c42a" translate="yes" xml:space="preserve">
          <source>True if the difference between the current time and the time of the last trigger exceeds &lt;code&gt;every_secs&lt;/code&gt;, or if the difference between the current step and the last triggered step exceeds &lt;code&gt;every_steps&lt;/code&gt;. False otherwise.</source>
          <target state="translated">現在の時刻と最後のトリガーの時刻との差が &lt;code&gt;every_secs&lt;/code&gt; を超える場合、または現在のステップと最後にトリガーされたステップとの差がevery_stepsを超える場合は &lt;code&gt;every_steps&lt;/code&gt; 。それ以外の場合はfalse。</target>
        </trans-unit>
        <trans-unit id="bfc13f68b704941e80142d04a3ed7c6629e6c664" translate="yes" xml:space="preserve">
          <source>True if the export directory contains SavedModel files, False otherwise.</source>
          <target state="translated">エクスポート ディレクトリに SavedModel ファイルが含まれている場合は True、そうでない場合は False となります。</target>
        </trans-unit>
        <trans-unit id="6a900b62e1edba1c0e27907e12139238da6afb94" translate="yes" xml:space="preserve">
          <source>True if the given node must run on CPU, otherwise False.</source>
          <target state="translated">与えられたノードがCPU上で実行されなければならない場合はTrue、そうでない場合はFalseです。</target>
        </trans-unit>
        <trans-unit id="e5ad15e25e43eb5bd9cd393c44c117efba29c6f6" translate="yes" xml:space="preserve">
          <source>True if the path exists, whether it's a file or a directory. False if the path does not exist and there are no filesystem errors.</source>
          <target state="translated">ファイルでもディレクトリでもパスが存在する場合は真。パスが存在せず、ファイルシステムエラーがない場合は False。</target>
        </trans-unit>
        <trans-unit id="2817ab94bf3761a7902a64b969f4ce8bf858694f" translate="yes" xml:space="preserve">
          <source>True if the quantization is signed or unsigned.</source>
          <target state="translated">量子化が符号付きまたは符号なしの場合は真。</target>
        </trans-unit>
        <trans-unit id="12521f184e32516a21dbe08fda414904f64f4716" translate="yes" xml:space="preserve">
          <source>True if the queue is closed and false if the queue is open.</source>
          <target state="translated">キューが閉じている場合は真、開いている場合は偽。</target>
        </trans-unit>
        <trans-unit id="8a6738c31462b3c1cdd66322c6255be278594bf2" translate="yes" xml:space="preserve">
          <source>True if the reader implementation can serialize its state.</source>
          <target state="translated">リーダの実装がその状態をシリアライズできる場合は真。</target>
        </trans-unit>
        <trans-unit id="b3d692e2a1a03f9a580cbe6af7887c076366f28a" translate="yes" xml:space="preserve">
          <source>True if the sequence is a not a string and is a collections.abc.Sequence or a dict.</source>
          <target state="translated">シーケンスが文字列ではなく、collections.abc.Sequenceまたはdictであれば真。</target>
        </trans-unit>
        <trans-unit id="e846d2ffe93240497692f8c335b561f9a3b5ca4b" translate="yes" xml:space="preserve">
          <source>True if this Dimension and &lt;code&gt;other&lt;/code&gt; are compatible.</source>
          <target state="translated">このDimensionと &lt;code&gt;other&lt;/code&gt; が互換性がある場合はTrue 。</target>
        </trans-unit>
        <trans-unit id="1af9f77f297353d13cc2052ce5add84a77143e29" translate="yes" xml:space="preserve">
          <source>True if this graph has been finalized.</source>
          <target state="translated">このグラフが確定していれば真。</target>
        </trans-unit>
        <trans-unit id="13ac567ddd78dbff91bfa15ccdc8c27002125b9d" translate="yes" xml:space="preserve">
          <source>True iff &lt;code&gt;self&lt;/code&gt; is compatible with &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">True iff &lt;code&gt;self&lt;/code&gt; は &lt;code&gt;other&lt;/code&gt; と互換性があります。</target>
        </trans-unit>
        <trans-unit id="3ea2041726102a7cb24768511dc474dfc2d2086e" translate="yes" xml:space="preserve">
          <source>True iff at most one predicate is allowed to evaluate to &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">最大で1つの述語が &lt;code&gt;True&lt;/code&gt; と評価できる場合はTrue。</target>
        </trans-unit>
        <trans-unit id="84ec63366604b21f0a1cd748c6c806b8cc035002" translate="yes" xml:space="preserve">
          <source>True on success, or false if no summary was emitted because no default summary writer was available.</source>
          <target state="translated">成功した場合はTrue、デフォルトのサマリーライターが利用できなかったためにサマリーが出力されなかった場合はFalseとなります。</target>
        </trans-unit>
        <trans-unit id="fc591d62fe392ab5c3a30eaf5e21967f39695530" translate="yes" xml:space="preserve">
          <source>True on success, or false if no summary was written because no default summary writer was available.</source>
          <target state="translated">成功した場合はTrue、デフォルトのサマリーライターが利用できなかったためにサマリーが書かれなかった場合はFalseとなります。</target>
        </trans-unit>
        <trans-unit id="c5ce5b285e7cceb24195ca6aafbc51395c9eec5d" translate="yes" xml:space="preserve">
          <source>True tries extracting the file as an Archive, like tar or zip.</source>
          <target state="translated">True は、ファイルを tar や zip のようなアーカイブとして抽出しようとします。</target>
        </trans-unit>
        <trans-unit id="64eb5b8ece15c07598a0a8b6e044d88bd144975f" translate="yes" xml:space="preserve">
          <source>True, False or None. None restores the default behavior.</source>
          <target state="translated">True、False、または None のいずれかを指定します。None はデフォルトの動作を復元します。</target>
        </trans-unit>
        <trans-unit id="f16aacc072df96e8b74050ff74d241c633ad1f94" translate="yes" xml:space="preserve">
          <source>True, if the path is a directory; False otherwise</source>
          <target state="translated">パスがディレクトリの場合はTrue、そうでない場合はFalse。</target>
        </trans-unit>
        <trans-unit id="b14f591e5a76ce927e3d51f5d369ecadec7b9175" translate="yes" xml:space="preserve">
          <source>True, if variables should be casted.</source>
          <target state="translated">変数がキャストされるべきかどうかを判定します。</target>
        </trans-unit>
        <trans-unit id="0398d49e6ea66afbb212b36d04e2616800d64ac3" translate="yes" xml:space="preserve">
          <source>True: executes each operation synchronously.</source>
          <target state="translated">True:各操作を同期的に実行します。</target>
        </trans-unit>
        <trans-unit id="4a2f0a78e05a23faa43333403bbc8e7bb4a127d9" translate="yes" xml:space="preserve">
          <source>TruncateDiv</source>
          <target state="translated">TruncateDiv</target>
        </trans-unit>
        <trans-unit id="88d5fe1e339e14bfa5e83a1a1041f877f78fa654" translate="yes" xml:space="preserve">
          <source>TruncateMod</source>
          <target state="translated">TruncateMod</target>
        </trans-unit>
        <trans-unit id="5b6f413272cd888b5af448b50b30ef69c71b431f" translate="yes" xml:space="preserve">
          <source>TruncatedNormal</source>
          <target state="translated">TruncatedNormal</target>
        </trans-unit>
        <trans-unit id="4d9fd66a7778c40e3dba2083356a599b52f25d88" translate="yes" xml:space="preserve">
          <source>Truncation designates that negative numbers will round fractional quantities toward zero. I.e. -7 / 5 = -1. This matches C semantics but it is different than Python semantics. See &lt;code&gt;FloorDiv&lt;/code&gt; for a division function that matches Python Semantics.</source>
          <target state="translated">切り捨ては、負の数が小数の数量をゼロに丸めることを指定します。つまり、-7 / 5 = -1です。これはCのセマンティクスと一致しますが、Pythonのセマンティクスとは異なります。Pythonセマンティクスに一致する除算関数については、 &lt;code&gt;FloorDiv&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="aa758b468b210aad3c052427b42a0c7ac48798f6" translate="yes" xml:space="preserve">
          <source>Tuple in the format used in &lt;a href=&quot;../model#fit&quot;&gt;&lt;code&gt;Model.fit&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../model#fit&quot;&gt; &lt;code&gt;Model.fit&lt;/code&gt; で&lt;/a&gt;使用される形式のタプル。</target>
        </trans-unit>
        <trans-unit id="3c85382570b1156fafff522dc38424cdd757186e" translate="yes" xml:space="preserve">
          <source>Tuple of 2 integers, how many zeros to add at the start and end of dim 1.</source>
          <target state="translated">2つの整数のタプル、dim 1の最初と最後に何個のゼロを加えるか。</target>
        </trans-unit>
        <trans-unit id="d878205ddde8c656cd0c2ec819ef9a66c6db3326" translate="yes" xml:space="preserve">
          <source>Tuple of 2 integers.</source>
          <target state="translated">2つの整数のタプル。</target>
        </trans-unit>
        <trans-unit id="9e902bb2fc5cab147bc391e40439b73d1a642c42" translate="yes" xml:space="preserve">
          <source>Tuple of 2 tuples, padding pattern.</source>
          <target state="translated">2つのタプルのタプル、パディングパターン。</target>
        </trans-unit>
        <trans-unit id="3e0b6b48776191185766960be076280c767a6bcd" translate="yes" xml:space="preserve">
          <source>Tuple of 3 integers, factors by which to downscale (dim1, dim2, dim3). &lt;code&gt;(2, 2, 2)&lt;/code&gt; will halve the size of the 3D input in each dimension.</source>
          <target state="translated">3つの整数のタプル、ダウンスケールする要因（dim1、dim2、dim3）。 &lt;code&gt;(2, 2, 2)&lt;/code&gt; 2、2、2 ）は、各次元の3D入力のサイズを半分にします。</target>
        </trans-unit>
        <trans-unit id="a2a3aa7cb19c709e2aeca6ab2c5fbdce9372f47c" translate="yes" xml:space="preserve">
          <source>Tuple of 3 tuples, padding pattern.</source>
          <target state="translated">3つのタプルのタプル、パディングパターン。</target>
        </trans-unit>
        <trans-unit id="3b36302f1d8a1cd0c40fa6d16b6fe2aaaa964f68" translate="yes" xml:space="preserve">
          <source>Tuple of Numpy arrays: &lt;code&gt;(x_train, y_train), (x_test, y_test)&lt;/code&gt;.</source>
          <target state="translated">Numpy配列のタプル： &lt;code&gt;(x_train, y_train), (x_test, y_test)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e5fcb3189bbbad2089b9134f58fe7fca941f8a70" translate="yes" xml:space="preserve">
          <source>Tuple of integers &lt;code&gt;(height, width)&lt;/code&gt;, defaults to &lt;code&gt;(256, 256)&lt;/code&gt;. The dimensions to which all images found will be resized.</source>
          <target state="translated">整数のタプル &lt;code&gt;(height, width)&lt;/code&gt; 、デフォルトは &lt;code&gt;(256, 256)&lt;/code&gt; です。見つかったすべての画像のサイズが変更されます。</target>
        </trans-unit>
        <trans-unit id="80e3a7c1e14386c2b20631926430b4d65ddfff1f" translate="yes" xml:space="preserve">
          <source>Tuple of integers representing (min, max) range values for all arrays without a specified range. Intended for experimenting with quantization via &quot;dummy quantization&quot;. (default None)</source>
          <target state="translated">範囲が指定されていないすべての配列の範囲値(min,max)を表す整数のタプル。ダミー量子化で量子化の実験をすることを想定しています。(デフォルトはなし)</target>
        </trans-unit>
        <trans-unit id="7e26526855fdb022129c7cbbd982fef1427fddb1" translate="yes" xml:space="preserve">
          <source>Tuple of integers, shape of returned Keras variable.</source>
          <target state="translated">整数のタプル、返されるKeras変数の形状。</target>
        </trans-unit>
        <trans-unit id="b8ec74a912c043af498fdebd5ada0cb4d060e6f5" translate="yes" xml:space="preserve">
          <source>Tuple of integers. Permutation pattern does not include the samples dimension. Indexing starts at 1. For instance, &lt;code&gt;(2, 1)&lt;/code&gt; permutes the first and second dimensions of the input.</source>
          <target state="translated">整数のタプル。順列パターンには、サンプルの次元は含まれていません。インデックス付けは1から始まります。たとえば、 &lt;code&gt;(2, 1)&lt;/code&gt; 2、1 ）は、入力の1番目と2番目の次元を並べ替えます。</target>
        </trans-unit>
        <trans-unit id="4d1f41be26f53eaa6f970fca60630a6f21855e44" translate="yes" xml:space="preserve">
          <source>Tuple of strings representing input tensor names and list of integers representing input shapes (e.g., [(&quot;foo&quot; : [1, 16, 16, 3])]). Use only when graph cannot be loaded into TensorFlow and when &lt;code&gt;input_tensors&lt;/code&gt; and &lt;code&gt;output_tensors&lt;/code&gt; are None. (default None)</source>
          <target state="translated">入力テンソル名を表す文字列のタプルと入力形状を表す整数のリスト（例：[（ &quot;foo&quot;：[1、16、16、3]）]）。グラフをTensorFlowにロードできない場合、および &lt;code&gt;input_tensors&lt;/code&gt; と &lt;code&gt;output_tensors&lt;/code&gt; がNoneの場合にのみ使用します。（デフォルトはなし）</target>
        </trans-unit>
        <trans-unit id="4cbc0064b79f9aa3d7ea238c4e18ad22b86f3acb" translate="yes" xml:space="preserve">
          <source>Tuple or list of integers with target dimensions, or single integer. The sizes of &lt;code&gt;x.shape[axes[0]]&lt;/code&gt; and &lt;code&gt;y.shape[axes[1]]&lt;/code&gt; should be equal.</source>
          <target state="translated">ターゲット次元を持つ整数のタプルまたはリスト、または単一の整数。 &lt;code&gt;x.shape[axes[0]]&lt;/code&gt; と &lt;code&gt;y.shape[axes[1]]&lt;/code&gt; のサイズは等しくなければなりません。</target>
        </trans-unit>
        <trans-unit id="082793c3bba9dd17881797f57bdfd7fbb926fad6" translate="yes" xml:space="preserve">
          <source>Tuple or list of integers, shape of returned Keras variable</source>
          <target state="translated">タプルまたは整数のリスト、返されるKeras変数の形状</target>
        </trans-unit>
        <trans-unit id="4531a58c8012cfb70552795a6d42bd391095a246" translate="yes" xml:space="preserve">
          <source>Tuple or list of two floats. Range for picking a brightness shift value from.</source>
          <target state="translated">タプルまたは2つのフロートのリスト。明るさのシフト値を指定する範囲を指定します。</target>
        </trans-unit>
        <trans-unit id="fcd91650680c7044999f313873fe057ab50db675" translate="yes" xml:space="preserve">
          <source>Tuple or list with positional arguments for &lt;code&gt;fn&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;fn&lt;/code&gt; の位置引数を持つタプルまたはリスト。</target>
        </trans-unit>
        <trans-unit id="b33b3b3fb1f8b255b7161c80b27363774e8f88ed" translate="yes" xml:space="preserve">
          <source>Tuple or list. Additional positional arguments to pass to &lt;code&gt;fn()&lt;/code&gt;.</source>
          <target state="translated">タプルまたはリスト。 &lt;code&gt;fn()&lt;/code&gt; に渡す追加の位置引数。</target>
        </trans-unit>
        <trans-unit id="2613ea839d069df0d5c8d9c5f47854631d09fc20" translate="yes" xml:space="preserve">
          <source>Tuple used by LSTM Cells for &lt;code&gt;state_size&lt;/code&gt;, &lt;code&gt;zero_state&lt;/code&gt;, and output state.</source>
          <target state="translated">LSTMセルが &lt;code&gt;state_size&lt;/code&gt; 、 &lt;code&gt;zero_state&lt;/code&gt; 、および出力状態に使用するタプル。</target>
        </trans-unit>
        <trans-unit id="5b48f912499203c94d01ac7a5a26aea7a05b21fa" translate="yes" xml:space="preserve">
          <source>Turn a nD tensor into a 2D tensor with same 0th dimension.</source>
          <target state="translated">nDテンソルを同じ0次元の2次元テンソルにする。</target>
        </trans-unit>
        <trans-unit id="84c0c370c16aa336bb6f7381c737e4c2aba96f9e" translate="yes" xml:space="preserve">
          <source>Turns positive integers (indexes) into dense vectors of fixed size.</source>
          <target state="translated">正の整数(インデックス)を固定サイズの密なベクトルに変換します。</target>
        </trans-unit>
        <trans-unit id="2c47d5c1924debfd2ddf97975d083f8b91fc55b1" translate="yes" xml:space="preserve">
          <source>Turns the serialized form of a Keras object back into an actual object.</source>
          <target state="translated">Kerasオブジェクトのシリアライズされたフォームを実際のオブジェクトに戻します。</target>
        </trans-unit>
        <trans-unit id="0312b13c624e55c7e9bb5fdcfe0c38b37f8b9c61" translate="yes" xml:space="preserve">
          <source>Tutorials and examples can be found in: &lt;a href=&quot;https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/profiler/g3doc/python_api.md&quot;&gt;https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/profiler/g3doc/python_api.md&lt;/a&gt;</source>
          <target state="translated">チュートリアルと例は、&lt;a href=&quot;https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/profiler/g3doc/python_api.md&quot;&gt;https&lt;/a&gt;：//github.com/tensorflow/tensorflow/blob/master/tensorflow/core/profiler/g3doc/python_api.mdにあります。</target>
        </trans-unit>
        <trans-unit id="e1970692bb6c07bd87f9682c04edd6a7dc8b64ed" translate="yes" xml:space="preserve">
          <source>Tutorials and examples can be found in: https://github.com/tensorflow/tensorflow/tree/master/tensorflow/core/profiler/README.md</source>
          <target state="translated">チュートリアルと例は https://github.com/tensorflow/tensorflow/tree/master/tensorflow/core/profiler/README.md にあります。</target>
        </trans-unit>
        <trans-unit id="5392c950bdde4be7e5f5b8fdc6a1ca5f21e905cf" translate="yes" xml:space="preserve">
          <source>Twitter</source>
          <target state="translated">Twitter</target>
        </trans-unit>
        <trans-unit id="698a7f116a9d0145fa7461b0cd8612ceab6c65c3" translate="yes" xml:space="preserve">
          <source>Two 2-d numpy arrays representing the theoretical and numerical Jacobian for dy/dx. Each has &quot;x_size&quot; rows and &quot;y_size&quot; columns where &quot;x_size&quot; is the number of elements in x and &quot;y_size&quot; is the number of elements in y. If x is a list, returns a list of two numpy arrays.</source>
          <target state="translated">dy/dxの理論的および数値的なヤコビアンを表す2つの2次元numpy配列。それぞれ &quot;x_size &quot;行と &quot;y_size &quot;列を持ち、&quot;x_size &quot;はxの要素数、&quot;y_size &quot;はyの要素数である。</target>
        </trans-unit>
        <trans-unit id="ba15ec3492dd4bf582b4e766b61d26647d5ffcdc" translate="yes" xml:space="preserve">
          <source>Two &lt;a href=&quot;../../tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt; objects of type &lt;code&gt;bool&lt;/code&gt; of the same shape. In this case, the result will be the element-wise logical AND of the two input tensors.</source>
          <target state="translated">同じ形状の &lt;code&gt;bool&lt;/code&gt; 型の2つの&lt;a href=&quot;../../tensor&quot;&gt; &lt;code&gt;tf.Tensor&lt;/code&gt; &lt;/a&gt;オブジェクト。この場合、結果は2つの入力テンソルの要素ごとの論理ANDになります。</target>
        </trans-unit>
        <trans-unit id="e2f8646d6f565d2ad7fc58a15043d6c2087ee7b6" translate="yes" xml:space="preserve">
          <source>Two &lt;a href=&quot;../../tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt; objects of type &lt;code&gt;bool&lt;/code&gt; of the same shape. In this case, the result will be the element-wise logical XOR of the two input tensors.</source>
          <target state="translated">同じ形状の &lt;code&gt;bool&lt;/code&gt; 型の2つの&lt;a href=&quot;../../tensor&quot;&gt; &lt;code&gt;tf.Tensor&lt;/code&gt; &lt;/a&gt;オブジェクト。この場合、結果は2つの入力テンソルの要素ごとの論理XORになります。</target>
        </trans-unit>
        <trans-unit id="0e476c2f4924caa7e379cac892bc43188804bebb" translate="yes" xml:space="preserve">
          <source>Two &lt;a href=&quot;../tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt; objects of type &lt;code&gt;bool&lt;/code&gt; of the same shape. In this case, the result will be the element-wise logical AND of the two input tensors.</source>
          <target state="translated">同じ形状の &lt;code&gt;bool&lt;/code&gt; 型の2つの&lt;a href=&quot;../tensor&quot;&gt; &lt;code&gt;tf.Tensor&lt;/code&gt; &lt;/a&gt;オブジェクト。この場合、結果は2つの入力テンソルの要素ごとの論理ANDになります。</target>
        </trans-unit>
        <trans-unit id="34ab6873a8334c48d1673369412e608cd7417e10" translate="yes" xml:space="preserve">
          <source>Two &lt;a href=&quot;../tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt; objects of type &lt;code&gt;bool&lt;/code&gt; of the same shape. In this case, the result will be the element-wise logical XOR of the two input tensors.</source>
          <target state="translated">同じ形状の &lt;code&gt;bool&lt;/code&gt; 型の2つの&lt;a href=&quot;../tensor&quot;&gt; &lt;code&gt;tf.Tensor&lt;/code&gt; &lt;/a&gt;オブジェクト。この場合、結果は2つの入力テンソルの要素ごとの論理XORになります。</target>
        </trans-unit>
        <trans-unit id="31988105748d2b29509a18eb03ac4bcf2e98951c" translate="yes" xml:space="preserve">
          <source>Two &lt;a href=&quot;tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt; objects of type &lt;code&gt;bool&lt;/code&gt; of the same shape. In this case, the result will be the element-wise logical AND of the two input tensors.</source>
          <target state="translated">同じ形状の &lt;code&gt;bool&lt;/code&gt; 型の2つの&lt;a href=&quot;tensor&quot;&gt; &lt;code&gt;tf.Tensor&lt;/code&gt; &lt;/a&gt;オブジェクト。この場合、結果は2つの入力テンソルの要素ごとの論理ANDになります。</target>
        </trans-unit>
        <trans-unit id="322bef22d5ff10923c851f4887f9752d9171cff1" translate="yes" xml:space="preserve">
          <source>Two &lt;a href=&quot;tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt; objects of type &lt;code&gt;bool&lt;/code&gt; of the same shape. In this case, the result will be the element-wise logical XOR of the two input tensors.</source>
          <target state="translated">同じ形状の &lt;code&gt;bool&lt;/code&gt; 型の2つの&lt;a href=&quot;tensor&quot;&gt; &lt;code&gt;tf.Tensor&lt;/code&gt; &lt;/a&gt;オブジェクト。この場合、結果は2つの入力テンソルの要素ごとの論理XORになります。</target>
        </trans-unit>
        <trans-unit id="e61ae5fa9a8a338e450ea4521d3c90e37b3fce55" translate="yes" xml:space="preserve">
          <source>Two &lt;code&gt;Tensor&lt;/code&gt; objects: &lt;code&gt;mean&lt;/code&gt; and &lt;code&gt;variance&lt;/code&gt;.</source>
          <target state="translated">2つの &lt;code&gt;Tensor&lt;/code&gt; オブジェクト： &lt;code&gt;mean&lt;/code&gt; と &lt;code&gt;variance&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="18f9e0ca8006912df25de0a98edea35700ad81f2" translate="yes" xml:space="preserve">
          <source>Two accumulation steps are required: 1) the accumulation of gradients squared, 2) the accumulation of updates squared.</source>
          <target state="translated">蓄積には2つのステップが必要です。1)勾配の二乗の蓄積、2)更新の二乗の蓄積です。</target>
        </trans-unit>
        <trans-unit id="a1d8ed408945a366f45477724e8c9686614ca2d7" translate="yes" xml:space="preserve">
          <source>Two different templates are guaranteed to be unique, unless you reenter the same variable scope as the initial definition of a template and redefine it. An examples of this exception:</source>
          <target state="translated">テンプレートの初期定義と同じ変数スコープを再入力して再定義しない限り、2つの異なるテンプレートは一意であることが保証されます。この例外の例。</target>
        </trans-unit>
        <trans-unit id="641506872a34040c078fdb14eeef6b25c62c6fc9" translate="yes" xml:space="preserve">
          <source>Two generators are independent of each other in the sense that the random-number streams they generate don't have statistically detectable correlations. The new generators are also independent of the old one. The old generator's state will be changed (like other random-number generating methods), so two calls of &lt;code&gt;split&lt;/code&gt; will return different new generators.</source>
          <target state="translated">2つのジェネレーターは、それらが生成する乱数ストリームに統計的に検出可能な相関関係がないという意味で、互いに独立しています。新しい発電機はまた古い発電機から独立しています。古いジェネレーターの状態は（他の乱数生成メソッドと同様に）変更されるため、 &lt;code&gt;split&lt;/code&gt; を2回呼び出すと、異なる新しいジェネレーターが返されます。</target>
        </trans-unit>
        <trans-unit id="609ab801a6e4c68686c97569df58fbb61201051d" translate="yes" xml:space="preserve">
          <source>Two known Dimensions are compatible if they have the same value. An unknown Dimension is compatible with all other Dimensions.</source>
          <target state="translated">2 つの既知の寸法は、同じ値を持つ場合に互換性があります。未知の寸法は、他のすべての寸法と互換性があります。</target>
        </trans-unit>
        <trans-unit id="6133911db30a0e3197c09499734a8919b0cbd3bf" translate="yes" xml:space="preserve">
          <source>Two or more words may be assigned to the same index, due to possible collisions by the hashing function. The &lt;a href=&quot;https://en.wikipedia.org/wiki/Birthday_problem#Probability_table&quot;&gt;probability&lt;/a&gt; of a collision is in relation to the dimension of the hashing space and the number of distinct objects.</source>
          <target state="translated">ハッシュ関数による衝突の可能性があるため、2つ以上の単語が同じインデックスに割り当てられる場合があります。衝突の&lt;a href=&quot;https://en.wikipedia.org/wiki/Birthday_problem#Probability_table&quot;&gt;確率&lt;/a&gt;は、ハッシュ空間の次元と個別のオブジェクトの数に関連しています。</target>
        </trans-unit>
        <trans-unit id="aa46f48d3d26a8be473e57169e56d3f2b7f57692" translate="yes" xml:space="preserve">
          <source>Two possibly-partially-defined shapes are compatible if there exists a fully-defined shape that both shapes can represent. Thus, compatibility allows the shape inference code to reason about partially-defined shapes. For example:</source>
          <target state="translated">部分的に定義されている可能性のある 2 つの形状は、両方の形状が表現できる完全定義の形状が存在する場合に互換性があります。このように、互換性により、形状推論コードは部分的に定義された形状について推論することができます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="b556440bce1c841c1d10f79b38663d9dfe8ce6f6" translate="yes" xml:space="preserve">
          <source>Two single elements of type &lt;code&gt;bool&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;bool&lt;/code&gt; 型の2つの単一要素</target>
        </trans-unit>
        <trans-unit id="8b0a6ae6ca7d62abe9867da93517fe68a65fffe7" translate="yes" xml:space="preserve">
          <source>Two static instances exist in the distributions library, signifying one of two possible properties for samples from a distribution:</source>
          <target state="translated">ディストリビューション・ライブラリには2つの静的インスタンスが存在し、ディストリビューションからのサンプルの2つの可能なプロパティのうちの1つを示しています。</target>
        </trans-unit>
        <trans-unit id="304880baecfd0af0b3d1da16c178a413930af3d7" translate="yes" xml:space="preserve">
          <source>Two tensors are considered compatible if they have the same dtype and their shapes are compatible (see &lt;a href=&quot;tensorshape#is_compatible_with&quot;&gt;&lt;code&gt;tf.TensorShape.is_compatible_with&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">2つのテンソルは、dtypeが同じで形状が互換性がある場合に互換性があると見なされます（&lt;a href=&quot;tensorshape#is_compatible_with&quot;&gt; &lt;code&gt;tf.TensorShape.is_compatible_with&lt;/code&gt; を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="6c808e735cf1d9acc205c12bc34a1db874936c96" translate="yes" xml:space="preserve">
          <source>Two tensors: &lt;code&gt;weighted_mean&lt;/code&gt; and &lt;code&gt;weighted_variance&lt;/code&gt;.</source>
          <target state="translated">2つのテンソル： &lt;code&gt;weighted_mean&lt;/code&gt; と &lt;code&gt;weighted_variance&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="197f1a152813e8754c3ab4ada0aee8e8eb0ab0e1" translate="yes" xml:space="preserve">
          <source>Type collections</source>
          <target state="translated">コレクションの種類</target>
        </trans-unit>
        <trans-unit id="70190875a976d04b6dbbdb76a76b8abab15ed20d" translate="yes" xml:space="preserve">
          <source>Type of reduction to apply to loss.</source>
          <target state="translated">損失に適用する減額の種類</target>
        </trans-unit>
        <trans-unit id="580ea2f11b5081d9834cac3a14574bfc02323a10" translate="yes" xml:space="preserve">
          <source>Type of the new or existing variable (defaults to &lt;code&gt;DT_FLOAT&lt;/code&gt;).</source>
          <target state="translated">新規または既存の変数のタイプ（デフォルトは &lt;code&gt;DT_FLOAT&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="eda6e626972cf9e8cb577094d8e71478f4d87dc1" translate="yes" xml:space="preserve">
          <source>Type of the variables. Ignored if &lt;code&gt;initializer&lt;/code&gt; is a &lt;code&gt;Tensor&lt;/code&gt;.</source>
          <target state="translated">変数のタイプ。 &lt;code&gt;initializer&lt;/code&gt; が &lt;code&gt;Tensor&lt;/code&gt; の場合は無視されます。</target>
        </trans-unit>
        <trans-unit id="8cb8d838a08c5043e95b8affed6f234ffe7a8fca" translate="yes" xml:space="preserve">
          <source>Type of weights, such as &lt;a href=&quot;../../tf#float32&quot;&gt;&lt;code&gt;tf.float32&lt;/code&gt;&lt;/a&gt;. Only float and integer weights are supported.</source>
          <target state="translated">&lt;a href=&quot;../../tf#float32&quot;&gt; &lt;code&gt;tf.float32&lt;/code&gt; &lt;/a&gt;などの重みのタイプ。floatとintegerの重みのみがサポートされています。</target>
        </trans-unit>
        <trans-unit id="89bccb1027fad55abb521d6f7f2c0ac6a074c8f5" translate="yes" xml:space="preserve">
          <source>Type specification for &lt;a href=&quot;dataset&quot;&gt;&lt;code&gt;tf.data.Dataset&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;dataset&quot;&gt; &lt;code&gt;tf.data.Dataset&lt;/code&gt; の&lt;/a&gt;型指定。</target>
        </trans-unit>
        <trans-unit id="712d9ffcd0e88abdb9eab9798af5f280ec9181bd" translate="yes" xml:space="preserve">
          <source>Type specification for &lt;a href=&quot;experimental/optional&quot;&gt;&lt;code&gt;tf.experimental.Optional&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;experimental/optional&quot;&gt; &lt;code&gt;tf.experimental.Optional&lt;/code&gt; の&lt;/a&gt;型指定。</target>
        </trans-unit>
        <trans-unit id="546c3b422414d2acfe0b7b6df33ddda2e98f189c" translate="yes" xml:space="preserve">
          <source>Type specification for &lt;a href=&quot;iterator&quot;&gt;&lt;code&gt;tf.data.Iterator&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;iterator&quot;&gt; &lt;code&gt;tf.data.Iterator&lt;/code&gt; の&lt;/a&gt;型指定。</target>
        </trans-unit>
        <trans-unit id="7ffc6a6652502645af83819deceaf071d1bee7ae" translate="yes" xml:space="preserve">
          <source>Type specification for a &lt;a href=&quot;indexedslices&quot;&gt;&lt;code&gt;tf.IndexedSlices&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;indexedslices&quot;&gt; &lt;code&gt;tf.IndexedSlices&lt;/code&gt; の&lt;/a&gt;型指定。</target>
        </trans-unit>
        <trans-unit id="db38e64c6790f1fa6a4046e1608589e1baafdb4f" translate="yes" xml:space="preserve">
          <source>Type specification for a &lt;a href=&quot;raggedtensor&quot;&gt;&lt;code&gt;tf.RaggedTensor&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;raggedtensor&quot;&gt; &lt;code&gt;tf.RaggedTensor&lt;/code&gt; の&lt;/a&gt;型指定。</target>
        </trans-unit>
        <trans-unit id="506637460ca723fc98125655b0c45f16d689f183" translate="yes" xml:space="preserve">
          <source>Type specification for a &lt;a href=&quot;sparse/sparsetensor&quot;&gt;&lt;code&gt;tf.SparseTensor&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;sparse/sparsetensor&quot;&gt; &lt;code&gt;tf.SparseTensor&lt;/code&gt; の&lt;/a&gt;型指定。</target>
        </trans-unit>
        <trans-unit id="f8dc08024793f24e03dca43c23eba2de392c0936" translate="yes" xml:space="preserve">
          <source>Type specification for a &lt;a href=&quot;sparse/sparsetensor&quot;&gt;&lt;code&gt;tf.sparse.SparseTensor&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;sparse/sparsetensor&quot;&gt; &lt;code&gt;tf.sparse.SparseTensor&lt;/code&gt; の&lt;/a&gt;型指定。</target>
        </trans-unit>
        <trans-unit id="097420656a3bb835a98ade8d3c1d8d6e161e4abc" translate="yes" xml:space="preserve">
          <source>Type specification for a &lt;a href=&quot;tensorarray&quot;&gt;&lt;code&gt;tf.TensorArray&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;tensorarray&quot;&gt; &lt;code&gt;tf.TensorArray&lt;/code&gt; の&lt;/a&gt;型指定。</target>
        </trans-unit>
        <trans-unit id="0fa80254c7cf732908a6ef92e8bcb16a8cbc3031" translate="yes" xml:space="preserve">
          <source>TypeError if &lt;code&gt;cluster&lt;/code&gt; is not a dictionary or &lt;code&gt;ClusterDef&lt;/code&gt; protocol buffer, or if &lt;code&gt;ps_strategy&lt;/code&gt; is provided but not a callable.</source>
          <target state="translated">&lt;code&gt;cluster&lt;/code&gt; が辞書または &lt;code&gt;ClusterDef&lt;/code&gt; プロトコルバッファーではない場合、または &lt;code&gt;ps_strategy&lt;/code&gt; が提供されているが呼び出し可能でない場合はTypeError 。</target>
        </trans-unit>
        <trans-unit id="7a7a3cb39cba799635ae97a5b59c3c35fb2a8e05" translate="yes" xml:space="preserve">
          <source>TypeError.</source>
          <target state="translated">TypeError.</target>
        </trans-unit>
        <trans-unit id="5bdcc3d1ee1c7b80e26206fa1de63397c5a2add9" translate="yes" xml:space="preserve">
          <source>TypeError: If the slice indices aren't int, slice, ellipsis, tf.newaxis or int32/int64 tensors.</source>
          <target state="translated">TypeError。スライスインデックスが int、slice、ellipsis、tf.newaxis、または int32/int64 テンソルでない場合。</target>
        </trans-unit>
        <trans-unit id="0d6c4c2eeadfc7d013e2b2fb8940e520aa96954c" translate="yes" xml:space="preserve">
          <source>Types I, II, III and IV are supported. Type I is implemented using a length &lt;code&gt;2N&lt;/code&gt; padded &lt;a href=&quot;rfft&quot;&gt;&lt;code&gt;tf.signal.rfft&lt;/code&gt;&lt;/a&gt;. Type II is implemented using a length &lt;code&gt;2N&lt;/code&gt; padded &lt;a href=&quot;rfft&quot;&gt;&lt;code&gt;tf.signal.rfft&lt;/code&gt;&lt;/a&gt;, as described here: &lt;a href=&quot;https://dsp.stackexchange.com/a/10606&quot;&gt;Type 2 DCT using 2N FFT padded (Makhoul)&lt;/a&gt;. Type III is a fairly straightforward inverse of Type II (i.e. using a length &lt;code&gt;2N&lt;/code&gt; padded &lt;a href=&quot;irfft&quot;&gt;&lt;code&gt;tf.signal.irfft&lt;/code&gt;&lt;/a&gt;). Type IV is calculated through 2N length DCT2 of padded signal and picking the odd indices.</source>
          <target state="translated">タイプI、II、III、およびIVがサポートされています。タイプIは、長さ &lt;code&gt;2N&lt;/code&gt; のパッド付き&lt;a href=&quot;rfft&quot;&gt; &lt;code&gt;tf.signal.rfft&lt;/code&gt; &lt;/a&gt;を使用して実装されます。タイプIIは、ここで説明するように、長さ &lt;code&gt;2N&lt;/code&gt; のパッド付き&lt;a href=&quot;rfft&quot;&gt; &lt;code&gt;tf.signal.rfft&lt;/code&gt; &lt;/a&gt;を使用して実装されます。2NFFTパッド付きの&lt;a href=&quot;https://dsp.stackexchange.com/a/10606&quot;&gt;タイプ2 DCT（Makhoul）&lt;/a&gt;。タイプIIIは、タイプIIのかなり単純な逆です（つまり、長さ &lt;code&gt;2N&lt;/code&gt; のパディングされた&lt;a href=&quot;irfft&quot;&gt; &lt;code&gt;tf.signal.irfft&lt;/code&gt; &lt;/a&gt;を使用します）。タイプIVは、パディングされた信号の2N長のDCT2と、奇数のインデックスを選択することによって計算されます。</target>
        </trans-unit>
        <trans-unit id="c9e719623f3a5418b899a4ace2cf4d169670e417" translate="yes" xml:space="preserve">
          <source>Types of loss reduction.</source>
          <target state="translated">損切りの種類。</target>
        </trans-unit>
        <trans-unit id="aa3c047f418cf4b489027ae070f266970331772f" translate="yes" xml:space="preserve">
          <source>Typical usage example:</source>
          <target state="translated">代表的な使用例。</target>
        </trans-unit>
        <trans-unit id="f86aad613fa5c3ee99a3b5451654d3e3136022f7" translate="yes" xml:space="preserve">
          <source>Typical usage for the &lt;code&gt;SavedModelBuilder&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;SavedModelBuilder&lt;/code&gt; の一般的な使用法：</target>
        </trans-unit>
        <trans-unit id="1dc96cc06e4c88360c7be195760a73e5c44fb2f7" translate="yes" xml:space="preserve">
          <source>Typical usage of this strategy could be testing your code with the tf.distribute.Strategy API before switching to other strategies which actually distribute to multiple devices/machines.</source>
          <target state="translated">このストラテジーの典型的な使用法は、複数のデバイス/マシンに実際に配布する他のストラテジーに切り替える前に、tf.distribute.Strategy APIを使ってコードをテストすることです。</target>
        </trans-unit>
        <trans-unit id="9f433de3a09f2cf5cd13a827c57725457d725e39" translate="yes" xml:space="preserve">
          <source>Typical usage:</source>
          <target state="translated">典型的な使い方。</target>
        </trans-unit>
        <trans-unit id="86f2b70049641c1127233f5a7f23b12cf7d72298" translate="yes" xml:space="preserve">
          <source>Typical usages of the &lt;code&gt;MethodNameUpdater&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;MethodNameUpdater&lt;/code&gt; の一般的な使用法</target>
        </trans-unit>
        <trans-unit id="0271771c7069a116c3373c269a63be4c6aca6198" translate="yes" xml:space="preserve">
          <source>Typical users will use one of the more specialized DEFINE_xxx functions, such as DEFINE_string or DEFINE_integer. But developers who need to create Flag objects themselves should use this function to register their flags.</source>
          <target state="translated">一般的なユーザは、DEFINE_stringやDEFINE_integerなど、より専門的なDEFINE_xxx関数のいずれかを使用します。しかし、フラグオブジェクトを自分で作成する必要がある開発者は、この関数を使用してフラグを登録する必要があります。</target>
        </trans-unit>
        <trans-unit id="2637b9cc80067f35b6391fac2edcbf9be59d7ab4" translate="yes" xml:space="preserve">
          <source>Typically only used in a cross-replica context:</source>
          <target state="translated">通常、クロスレプリカのコンテキストでのみ使用されます。</target>
        </trans-unit>
        <trans-unit id="770e50ed1c5b312d1ae6d0b8292c12f6aec34dd4" translate="yes" xml:space="preserve">
          <source>Typically this function is used to convert from TensorFlow GraphDef to TFLite. Conversion can be customized by providing arguments that are forwarded to &lt;code&gt;build_toco_convert_protos&lt;/code&gt; (see documentation for details). This function has been deprecated. Please use &lt;a href=&quot;../../../lite/tfliteconverter&quot;&gt;&lt;code&gt;lite.TFLiteConverter&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">通常、この関数はTensorFlow GraphDefからTFLiteへの変換に使用されます。 &lt;code&gt;build_toco_convert_protos&lt;/code&gt; に転送される引数を提供することにより、変換をカスタマイズできます（詳細については、ドキュメントを参照してください）。この関数は廃止されました。代わりに&lt;a href=&quot;../../../lite/tfliteconverter&quot;&gt; &lt;code&gt;lite.TFLiteConverter&lt;/code&gt; &lt;/a&gt;を使用してください。</target>
        </trans-unit>
        <trans-unit id="3fe4dd1700ccac29f3d0ae3fa02b865b65b1c45f" translate="yes" xml:space="preserve">
          <source>Typically this function is used to convert from TensorFlow GraphDef to TFLite. Conversion can be customized by providing arguments that are forwarded to &lt;code&gt;build_toco_convert_protos&lt;/code&gt; (see documentation for details). This function has been deprecated. Please use &lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/lite/TFLiteConverter&quot;&gt;&lt;code&gt;lite.TFLiteConverter&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">通常、この関数はTensorFlowGraphDefからTFLiteに変換するために使用されます。 &lt;code&gt;build_toco_convert_protos&lt;/code&gt; に転送される引数を提供することにより、変換をカスタマイズできます（詳細についてはドキュメントを参照してください）。この関数は非推奨になりました。代わりに&lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/lite/TFLiteConverter&quot;&gt; &lt;code&gt;lite.TFLiteConverter&lt;/code&gt; &lt;/a&gt;を使用してください。</target>
        </trans-unit>
        <trans-unit id="9f937cb551b8e8625cac21b8a54df64070d57507" translate="yes" xml:space="preserve">
          <source>Typically, constructing a file writer creates a new event file in &lt;code&gt;logdir&lt;/code&gt;. This event file will contain &lt;code&gt;Event&lt;/code&gt; protocol buffers constructed when you call one of the following functions: &lt;code&gt;add_summary()&lt;/code&gt;, &lt;code&gt;add_session_log()&lt;/code&gt;, &lt;code&gt;add_event()&lt;/code&gt;, or &lt;code&gt;add_graph()&lt;/code&gt;.</source>
          <target state="translated">通常、ファイルライターを作成すると、 &lt;code&gt;logdir&lt;/code&gt; に新しいイベントファイルが作成されます。このイベントファイルには、 &lt;code&gt;add_summary()&lt;/code&gt; 、 &lt;code&gt;add_session_log()&lt;/code&gt; 、 &lt;code&gt;add_event()&lt;/code&gt; 、または &lt;code&gt;add_graph()&lt;/code&gt; のいずれかの関数を呼び出したときに作成される &lt;code&gt;Event&lt;/code&gt; プロトコルバッファーが含まれます。</target>
        </trans-unit>
        <trans-unit id="aff7b1a518fb0d16f85d64959ece4d247dd8cf1c" translate="yes" xml:space="preserve">
          <source>Typically, different numerical approximations can be used for the log survival function, which are more accurate than &lt;code&gt;1 - cdf(x)&lt;/code&gt; when &lt;code&gt;x &amp;gt;&amp;gt; 1&lt;/code&gt;.</source>
          <target state="translated">通常、対数生存時間関数には異なる数値近似を使用できます。これは、 &lt;code&gt;x &amp;gt;&amp;gt; 1&lt;/code&gt; 場合、 &lt;code&gt;1 - cdf(x)&lt;/code&gt; よりも正確です。</target>
        </trans-unit>
        <trans-unit id="dc11d475cf6eeccc4ccad2799b660daf47f6e97d" translate="yes" xml:space="preserve">
          <source>Typically, this is used for contiguous ranges of integer indexes, but it doesn't have to be. This might be inefficient, however, if many of IDs are unused. Consider &lt;code&gt;categorical_column_with_hash_bucket&lt;/code&gt; in that case.</source>
          <target state="translated">通常、これは整数インデックスの連続した範囲に使用されますが、そうである必要はありません。ただし、IDの多くが使用されていない場合、これは非効率的です。その場合は、 &lt;code&gt;categorical_column_with_hash_bucket&lt;/code&gt; を検討してください。</target>
        </trans-unit>
        <trans-unit id="642d93bf7af9445a97651535e05ec594d4e074d2" translate="yes" xml:space="preserve">
          <source>Typically, this method directly controls &lt;a href=&quot;../../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../distribute/strategy&quot;&gt;&lt;code&gt;tf.distribute.Strategy&lt;/code&gt;&lt;/a&gt; settings, and delegates the actual evaluation logic to &lt;a href=&quot;../model#predict_step&quot;&gt;&lt;code&gt;Model.predict_step&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">通常、このメソッドは&lt;a href=&quot;../../function&quot;&gt; &lt;code&gt;tf.function&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;../../distribute/strategy&quot;&gt; &lt;code&gt;tf.distribute.Strategy&lt;/code&gt; &lt;/a&gt;設定を直接制御し、実際の評価ロジックを&lt;a href=&quot;../model#predict_step&quot;&gt; &lt;code&gt;Model.predict_step&lt;/code&gt; に委任し&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="e09b882e09baa741494589bf82363a386761e573" translate="yes" xml:space="preserve">
          <source>Typically, this method directly controls &lt;a href=&quot;../../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../distribute/strategy&quot;&gt;&lt;code&gt;tf.distribute.Strategy&lt;/code&gt;&lt;/a&gt; settings, and delegates the actual evaluation logic to &lt;a href=&quot;../model#test_step&quot;&gt;&lt;code&gt;Model.test_step&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">通常、このメソッドは&lt;a href=&quot;../../function&quot;&gt; &lt;code&gt;tf.function&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;../../distribute/strategy&quot;&gt; &lt;code&gt;tf.distribute.Strategy&lt;/code&gt; &lt;/a&gt;設定を直接制御し、実際の評価ロジックを&lt;a href=&quot;../model#test_step&quot;&gt; &lt;code&gt;Model.test_step&lt;/code&gt; に委任し&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="b89bd069f03bea0bc8a7420d63726498425c37ea" translate="yes" xml:space="preserve">
          <source>Typically, this method directly controls &lt;a href=&quot;../../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../distribute/strategy&quot;&gt;&lt;code&gt;tf.distribute.Strategy&lt;/code&gt;&lt;/a&gt; settings, and delegates the actual training logic to &lt;a href=&quot;../model#train_step&quot;&gt;&lt;code&gt;Model.train_step&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">通常、このメソッドは&lt;a href=&quot;../../function&quot;&gt; &lt;code&gt;tf.function&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;../../distribute/strategy&quot;&gt; &lt;code&gt;tf.distribute.Strategy&lt;/code&gt; &lt;/a&gt;設定を直接制御し、実際のトレーニングロジックを&lt;a href=&quot;../model#train_step&quot;&gt; &lt;code&gt;Model.train_step&lt;/code&gt; に委任し&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="6a9ed424e025572fe99563e115ac58ef9f0eecef" translate="yes" xml:space="preserve">
          <source>Typically, this method directly controls &lt;a href=&quot;../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../distribute/strategy&quot;&gt;&lt;code&gt;tf.distribute.Strategy&lt;/code&gt;&lt;/a&gt; settings, and delegates the actual evaluation logic to &lt;a href=&quot;model#predict_step&quot;&gt;&lt;code&gt;Model.predict_step&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">通常、このメソッドは&lt;a href=&quot;../function&quot;&gt; &lt;code&gt;tf.function&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;../distribute/strategy&quot;&gt; &lt;code&gt;tf.distribute.Strategy&lt;/code&gt; &lt;/a&gt;設定を直接制御し、実際の評価ロジックを&lt;a href=&quot;model#predict_step&quot;&gt; &lt;code&gt;Model.predict_step&lt;/code&gt; に委任し&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="88e682fbb9f04bb6f808d62f5cfd3cba250f9355" translate="yes" xml:space="preserve">
          <source>Typically, this method directly controls &lt;a href=&quot;../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../distribute/strategy&quot;&gt;&lt;code&gt;tf.distribute.Strategy&lt;/code&gt;&lt;/a&gt; settings, and delegates the actual evaluation logic to &lt;a href=&quot;model#test_step&quot;&gt;&lt;code&gt;Model.test_step&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">通常、このメソッドは&lt;a href=&quot;../function&quot;&gt; &lt;code&gt;tf.function&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;../distribute/strategy&quot;&gt; &lt;code&gt;tf.distribute.Strategy&lt;/code&gt; &lt;/a&gt;設定を直接制御し、実際の評価ロジックを&lt;a href=&quot;model#test_step&quot;&gt; &lt;code&gt;Model.test_step&lt;/code&gt; に委任し&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="39425f208b695839de1ae797673c90196ac3923f" translate="yes" xml:space="preserve">
          <source>Typically, this method directly controls &lt;a href=&quot;../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../distribute/strategy&quot;&gt;&lt;code&gt;tf.distribute.Strategy&lt;/code&gt;&lt;/a&gt; settings, and delegates the actual training logic to &lt;a href=&quot;model#train_step&quot;&gt;&lt;code&gt;Model.train_step&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">通常、このメソッドは&lt;a href=&quot;../function&quot;&gt; &lt;code&gt;tf.function&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;../distribute/strategy&quot;&gt; &lt;code&gt;tf.distribute.Strategy&lt;/code&gt; &lt;/a&gt;設定を直接制御し、実際のトレーニングロジックを&lt;a href=&quot;model#train_step&quot;&gt; &lt;code&gt;Model.train_step&lt;/code&gt; に委任し&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="4872edff50fbbe6a9f917cabaf4b95b3b51cfbf5" translate="yes" xml:space="preserve">
          <source>UUID of function that this tracks arguments for.</source>
          <target state="translated">引数を追跡する関数の UUID。</target>
        </trans-unit>
        <trans-unit id="028563b1e54555afd3216dd205c2179bff62edca" translate="yes" xml:space="preserve">
          <source>Unbatch</source>
          <target state="translated">Unbatch</target>
        </trans-unit>
        <trans-unit id="18de537cd188f9aa6703c0bcca0bdd3aa030d834" translate="yes" xml:space="preserve">
          <source>UnbatchDataset</source>
          <target state="translated">UnbatchDataset</target>
        </trans-unit>
        <trans-unit id="282c6a33f97fdaf72f77ce51ca56ef49ffc77747" translate="yes" xml:space="preserve">
          <source>UnbatchGrad</source>
          <target state="translated">UnbatchGrad</target>
        </trans-unit>
        <trans-unit id="0ed10c799418646f55b928fd78fe57ac0388bf1c" translate="yes" xml:space="preserve">
          <source>UncompressElement</source>
          <target state="translated">UncompressElement</target>
        </trans-unit>
        <trans-unit id="4b7dbe0386bf95cabb32b5ed231c8f56aae99b96" translate="yes" xml:space="preserve">
          <source>Uncompresses a compressed dataset element.</source>
          <target state="translated">圧縮されたデータセット要素を解凍します。</target>
        </trans-unit>
        <trans-unit id="315f69cd0de49a2c6013b3acdede0a3586eb743f" translate="yes" xml:space="preserve">
          <source>Under &lt;code&gt;TPUStrategy&lt;/code&gt;, we allow access to the method &lt;code&gt;enqueue&lt;/code&gt;, &lt;code&gt;dequeue&lt;/code&gt; and &lt;code&gt;apply_gradients&lt;/code&gt;. We will show examples below of how to use these to train and evaluate your model. Under CPU, we only access to the &lt;code&gt;embedding_tables&lt;/code&gt; property which allow access to the embedding tables so that you can use them to run model evaluation/prediction on CPU.</source>
          <target state="translated">下に &lt;code&gt;TPUStrategy&lt;/code&gt; 、我々は、メソッドへのアクセスを許可 &lt;code&gt;enqueue&lt;/code&gt; 、 &lt;code&gt;dequeue&lt;/code&gt; および &lt;code&gt;apply_gradients&lt;/code&gt; を。これらを使用してモデルをトレーニングおよび評価する方法の例を以下に示します。CPUでは、埋め込みテーブルへのアクセスを許可する &lt;code&gt;embedding_tables&lt;/code&gt; プロパティにのみアクセスするため、それらを使用してCPUでモデルの評価/予測を実行できます。</target>
        </trans-unit>
        <trans-unit id="e3e018efacc4788ac4991e79f9e0eac32efd113e" translate="yes" xml:space="preserve">
          <source>Under a scope &lt;code&gt;with custom_object_scope(objects_dict)&lt;/code&gt;, Keras methods such as &lt;a href=&quot;../models/load_model&quot;&gt;&lt;code&gt;tf.keras.models.load_model&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../models/model_from_config&quot;&gt;&lt;code&gt;tf.keras.models.model_from_config&lt;/code&gt;&lt;/a&gt; will be able to deserialize any custom object referenced by a saved config (e.g. a custom layer or metric).</source>
          <target state="translated">&lt;code&gt;with custom_object_scope(objects_dict)&lt;/code&gt; スコープでは、&lt;a href=&quot;../models/load_model&quot;&gt; &lt;code&gt;tf.keras.models.load_model&lt;/code&gt; &lt;/a&gt;や&lt;a href=&quot;../models/model_from_config&quot;&gt; &lt;code&gt;tf.keras.models.model_from_config&lt;/code&gt; &lt;/a&gt;などのKerasメソッドは、保存された構成（カスタムレイヤーやメトリックなど）によって参照されるカスタムオブジェクトを逆シリアル化できます。</target>
        </trans-unit>
        <trans-unit id="505df01a0bd35a5e05151b2e08abe84fb66596dc" translate="yes" xml:space="preserve">
          <source>Understanding and Improving Convolutional Neural Networks via Concatenated Rectified Linear Units: &lt;a href=&quot;http://proceedings.mlr.press/v48/shang16&quot;&gt;Shang et al., 2016&lt;/a&gt; (&lt;a href=&quot;http://proceedings.mlr.press/v48/shang16.pdf&quot;&gt;pdf&lt;/a&gt;)</source>
          <target state="translated">連結された正規化線形ユニットを介した畳み込みニューラルネットワークの理解と改善：&lt;a href=&quot;http://proceedings.mlr.press/v48/shang16&quot;&gt;Shang et al。、2016&lt;/a&gt;（&lt;a href=&quot;http://proceedings.mlr.press/v48/shang16.pdf&quot;&gt;pdf&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="1f2505b6c39bb7db973660c096d38f1739c74197" translate="yes" xml:space="preserve">
          <source>Undoes all SmartSet() &amp;amp; Set() calls, restoring original definitions.</source>
          <target state="translated">すべてのSmartSet（）およびSet（）呼び出しを元に戻し、元の定義を復元します。</target>
        </trans-unit>
        <trans-unit id="1956e966c40ea031fb68e7fe6e402465c17b477c" translate="yes" xml:space="preserve">
          <source>Unicode encoding that should be used to encode each codepoint sequence. Can be &lt;code&gt;&quot;UTF-8&quot;&lt;/code&gt;, &lt;code&gt;&quot;UTF-16-BE&quot;&lt;/code&gt;, or &lt;code&gt;&quot;UTF-32-BE&quot;&lt;/code&gt;.</source>
          <target state="translated">各コードポイントシーケンスをエンコードするために使用する必要があるUnicodeエンコーディング。することができ &lt;code&gt;&quot;UTF-8&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;UTF-16-BE&quot;&lt;/code&gt; 、または &lt;code&gt;&quot;UTF-32-BE&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="90ac7bb3b01b32e952ee295aa92163d24d25615d" translate="yes" xml:space="preserve">
          <source>Unicode strings</source>
          <target state="translated">ユニコード文字列</target>
        </trans-unit>
        <trans-unit id="5e0684d6d7d272631c8bbe44f41cfa3f5076b1d4" translate="yes" xml:space="preserve">
          <source>UnicodeDecode</source>
          <target state="translated">UnicodeDecode</target>
        </trans-unit>
        <trans-unit id="d7d59980b4ae5cf39a350faf2c470f5fc69d74d8" translate="yes" xml:space="preserve">
          <source>UnicodeDecodeWithOffsets</source>
          <target state="translated">UnicodeDecodeWithOffsets</target>
        </trans-unit>
        <trans-unit id="05ae41cc8fec2efee56c1fd3fc455b9ee887c661" translate="yes" xml:space="preserve">
          <source>UnicodeEncode</source>
          <target state="translated">UnicodeEncode</target>
        </trans-unit>
        <trans-unit id="d48a266454de5c99b64f1535df01a2aa732eb493" translate="yes" xml:space="preserve">
          <source>UnicodeScript</source>
          <target state="translated">UnicodeScript</target>
        </trans-unit>
        <trans-unit id="c03f6044710be2f868218b1b8ef3d1a0cb70d8e9" translate="yes" xml:space="preserve">
          <source>UnicodeTranscode</source>
          <target state="translated">UnicodeTranscode</target>
        </trans-unit>
        <trans-unit id="976c215ff49db1df66b6e17319495979c35769ef" translate="yes" xml:space="preserve">
          <source>Uniform Inner Dimensions</source>
          <target state="translated">均一な内部寸法</target>
        </trans-unit>
        <trans-unit id="8560175804cd279f78f66d9a95299a6ca618dbfc" translate="yes" xml:space="preserve">
          <source>Uniform Outer Dimensions</source>
          <target state="translated">均一な外形寸法</target>
        </trans-unit>
        <trans-unit id="877e52ac4e7248f2800c12c1d91696ac0ce4e843" translate="yes" xml:space="preserve">
          <source>Uniform and ragged outer dimensions may be interleaved, meaning that a tensor with any combination of ragged and uniform dimensions may be created. For example, a RaggedTensor &lt;code&gt;t4&lt;/code&gt; with shape &lt;code&gt;[3, None, 4, 8, None, 2]&lt;/code&gt; could be constructed as follows:</source>
          <target state="translated">均一で不規則な外形寸法を交互に配置できます。つまり、不規則な寸法と均一な寸法の任意の組み合わせのテンソルを作成できます。たとえば、形状が &lt;code&gt;[3, None, 4, 8, None, 2]&lt;/code&gt; 4、8 、なし、2]の RaggedTensor &lt;code&gt;t4&lt;/code&gt; は、次のように構成できます。</target>
        </trans-unit>
        <trans-unit id="9c91421a9e87411dcbfdcaf48e2c1f3430455339" translate="yes" xml:space="preserve">
          <source>Uniform dimensions are encoded using multidimensional numpy &lt;code&gt;array&lt;/code&gt;s. In the following example, the value returned by &lt;a href=&quot;raggedtensor#numpy&quot;&gt;&lt;code&gt;RaggedTensor.numpy()&lt;/code&gt;&lt;/a&gt; contains a single numpy &lt;code&gt;array&lt;/code&gt; object, with &lt;code&gt;rank=2&lt;/code&gt; and &lt;code&gt;dtype=int64&lt;/code&gt;:</source>
          <target state="translated">均一な次元は、多次元のnumpy &lt;code&gt;array&lt;/code&gt; を使用してエンコードされます。次の例では、&lt;a href=&quot;raggedtensor#numpy&quot;&gt; &lt;code&gt;RaggedTensor.numpy()&lt;/code&gt; &lt;/a&gt;によって返される値には、 &lt;code&gt;rank=2&lt;/code&gt; および &lt;code&gt;dtype=int64&lt;/code&gt; の単一のnumpy &lt;code&gt;array&lt;/code&gt; オブジェクトが含まれています。</target>
        </trans-unit>
        <trans-unit id="f358f22f84035b210a806ebde2b7ba64470c6103" translate="yes" xml:space="preserve">
          <source>Uniform distribution on an integer type's entire range.</source>
          <target state="translated">整数型の全範囲での一様分布。</target>
        </trans-unit>
        <trans-unit id="5a636a3f76b9605e2629209f45efcb9cace24843" translate="yes" xml:space="preserve">
          <source>Uniform distribution with &lt;code&gt;low&lt;/code&gt; and &lt;code&gt;high&lt;/code&gt; parameters.</source>
          <target state="translated">&lt;code&gt;low&lt;/code&gt; パラメータと &lt;code&gt;high&lt;/code&gt; パラメータの均一な分布。</target>
        </trans-unit>
        <trans-unit id="2408554486ca40a7df4bc74cb3619a293981c6a8" translate="yes" xml:space="preserve">
          <source>UniformCandidateSampler</source>
          <target state="translated">UniformCandidateSampler</target>
        </trans-unit>
        <trans-unit id="82b9b64659267074d1c1ba85abf6981423a4e4d2" translate="yes" xml:space="preserve">
          <source>UniformRowLength(length,)</source>
          <target state="translated">UniformRowLength(length,)</target>
        </trans-unit>
        <trans-unit id="338a58853d5b589d79285d729f26c7d598bf74eb" translate="yes" xml:space="preserve">
          <source>Union[Iterable[Enum], Iterable[Text], Enum, Text, None], the default value of the flag; see &lt;code&gt;DEFINE_multi&lt;/code&gt;; only differences are documented here. If the value is a single Enum, it is treated as a single-item list of that Enum value. If it is an iterable, text values within the iterable will be converted to the equivalent Enum objects.</source>
          <target state="translated">Union [Iterable [Enum]、Iterable [Text]、Enum、Text、None]、フラグのデフォルト値。 &lt;code&gt;DEFINE_multi&lt;/code&gt; を参照してください。ここでは違いのみが文書化されています。値が単一の列挙型の場合、その列挙型値の単一項目リストとして扱われます。iterableの場合、iterable内のテキスト値は同等のEnumオブジェクトに変換されます。</target>
        </trans-unit>
        <trans-unit id="04886f2c2934fa1074408cc7cc12b5f99af25706" translate="yes" xml:space="preserve">
          <source>Union[Iterable[T], Text, None], the default value of the flag. If the value is text, it will be parsed as if it was provided from the command line. If the value is a non-string iterable, it will be iterated over to create a shallow copy of the values. If it is None, it is left as-is.</source>
          <target state="translated">Union[Iterable[T],Text,None]、フラグのデフォルト値。値がテキストの場合、それがコマンドラインから提供されたものであるかのように解析されます。値が文字列ではない反復可能な値の場合は、値の浅いコピーを作成するために反復処理されます。Noneの場合は、そのままにしておきます。</target>
        </trans-unit>
        <trans-unit id="737c59cf13411337a19af29f48783402b8ed06de" translate="yes" xml:space="preserve">
          <source>Union[Iterable[Text], Text, None], the default value of the flag; see &lt;code&gt;DEFINE_multi&lt;/code&gt;.</source>
          <target state="translated">Union [Iterable [Text]、Text、None]、フラグのデフォルト値。 &lt;code&gt;DEFINE_multi&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="6428fc2f5260465f511164c37261c5570e275cd5" translate="yes" xml:space="preserve">
          <source>Union[Iterable[float], Text, None], the default value of the flag; see &lt;code&gt;DEFINE_multi&lt;/code&gt;.</source>
          <target state="translated">Union [Iterable [float]、Text、None]、フラグのデフォルト値。 &lt;code&gt;DEFINE_multi&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="c19e99ab715ea5a714cc70c9ca1419999c89628b" translate="yes" xml:space="preserve">
          <source>Union[Iterable[int], Text, None], the default value of the flag; see &lt;code&gt;DEFINE_multi&lt;/code&gt;.</source>
          <target state="translated">Union [Iterable [int]、Text、None]、フラグのデフォルト値。 &lt;code&gt;DEFINE_multi&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="87c6f410754d2f5d42cbccc33576be0d5edc865c" translate="yes" xml:space="preserve">
          <source>Unique</source>
          <target state="translated">Unique</target>
        </trans-unit>
        <trans-unit id="0dd84a267eb06050e1d51577f84d2e5f9d140c27" translate="yes" xml:space="preserve">
          <source>Unique integer ID.</source>
          <target state="translated">一意な整数のID。</target>
        </trans-unit>
        <trans-unit id="b898bebda42c40e1bfed797240e3b6330402424d" translate="yes" xml:space="preserve">
          <source>UniqueDataset</source>
          <target state="translated">UniqueDataset</target>
        </trans-unit>
        <trans-unit id="936d3125f6165a80c34df14b2afdc4601cd8b763" translate="yes" xml:space="preserve">
          <source>UniqueV2</source>
          <target state="translated">UniqueV2</target>
        </trans-unit>
        <trans-unit id="6d7fb951e6346ddabc82f570397d0fd46ed74844" translate="yes" xml:space="preserve">
          <source>UniqueWithCounts</source>
          <target state="translated">UniqueWithCounts</target>
        </trans-unit>
        <trans-unit id="1c7a5d24b663759b635f7eb14541a1e553019f23" translate="yes" xml:space="preserve">
          <source>UniqueWithCountsV2</source>
          <target state="translated">UniqueWithCountsV2</target>
        </trans-unit>
        <trans-unit id="3716d64264f900396f1af7fc16d7b86fdf992a50" translate="yes" xml:space="preserve">
          <source>Unknown error.</source>
          <target state="translated">不明なエラーです。</target>
        </trans-unit>
        <trans-unit id="36714cf4410eee18e8f50df2ffea0a7fa2ac86eb" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;../../../../data/dataset#batch&quot;&gt;&lt;code&gt;tf.data.Dataset.batch&lt;/code&gt;&lt;/a&gt;, the input elements to be batched may have different shapes, and this transformation will pad each component to the respective shape in &lt;code&gt;padded_shapes&lt;/code&gt;. The &lt;code&gt;padded_shapes&lt;/code&gt; argument determines the resulting shape for each dimension of each component in an output element:</source>
          <target state="translated">&lt;a href=&quot;../../../../data/dataset#batch&quot;&gt; &lt;code&gt;tf.data.Dataset.batch&lt;/code&gt; &lt;/a&gt;とは異なり、バッチ処理される入力要素の形状は異なる場合があり、この変換により、各コンポーネントが &lt;code&gt;padded_shapes&lt;/code&gt; のそれぞれの形状にパディングされます。 &lt;code&gt;padded_shapes&lt;/code&gt; の引数は、出力要素における各構成要素の各次元のために得られた形状を決定します。</target>
        </trans-unit>
        <trans-unit id="9ecf9df1b9c446def763a4926348afbeccb07217" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;../../../../data/dataset#batch&quot;&gt;&lt;code&gt;tf.data.Dataset.batch&lt;/code&gt;&lt;/a&gt;, the input elements to be batched may have different shapes, and this transformation will pad each component to the respective shape in &lt;code&gt;padding_shapes&lt;/code&gt;. The &lt;code&gt;padding_shapes&lt;/code&gt; argument determines the resulting shape for each dimension of each component in an output element:</source>
          <target state="translated">&lt;a href=&quot;../../../../data/dataset#batch&quot;&gt; &lt;code&gt;tf.data.Dataset.batch&lt;/code&gt; &lt;/a&gt;とは異なり、バッチ処理される入力要素の形状は異なる場合があり、この変換では、各コンポーネントがpadding_shapesのそれぞれの形状に &lt;code&gt;padding_shapes&lt;/code&gt; ます。 &lt;code&gt;padding_shapes&lt;/code&gt; の引数は、出力要素における各構成要素の各次元のために得られた形状を決定します。</target>
        </trans-unit>
        <trans-unit id="576d359833afce4c0260f4d74f22330fd90213de" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;../../../data/dataset#batch&quot;&gt;&lt;code&gt;tf.data.Dataset.batch&lt;/code&gt;&lt;/a&gt;, the input elements to be batched may have different shapes, and this transformation will pad each component to the respective shape in &lt;code&gt;padded_shapes&lt;/code&gt;. The &lt;code&gt;padded_shapes&lt;/code&gt; argument determines the resulting shape for each dimension of each component in an output element:</source>
          <target state="translated">&lt;a href=&quot;../../../data/dataset#batch&quot;&gt; &lt;code&gt;tf.data.Dataset.batch&lt;/code&gt; &lt;/a&gt;とは異なり、バッチ処理される入力要素の形状は異なる場合があり、この変換により、各コンポーネントが &lt;code&gt;padded_shapes&lt;/code&gt; のそれぞれの形状にパディングされます。 &lt;code&gt;padded_shapes&lt;/code&gt; の引数は、出力要素における各構成要素の各次元のために得られた形状を決定します。</target>
        </trans-unit>
        <trans-unit id="cb9a4a5a4e9492ece2558573a0acc8a789ddc313" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;../../../data/dataset#batch&quot;&gt;&lt;code&gt;tf.data.Dataset.batch&lt;/code&gt;&lt;/a&gt;, the input elements to be batched may have different shapes, and this transformation will pad each component to the respective shape in &lt;code&gt;padding_shapes&lt;/code&gt;. The &lt;code&gt;padding_shapes&lt;/code&gt; argument determines the resulting shape for each dimension of each component in an output element:</source>
          <target state="translated">&lt;a href=&quot;../../../data/dataset#batch&quot;&gt; &lt;code&gt;tf.data.Dataset.batch&lt;/code&gt; &lt;/a&gt;とは異なり、バッチ処理される入力要素の形状は異なる場合があり、この変換では、各コンポーネントがpadding_shapesのそれぞれの形状に &lt;code&gt;padding_shapes&lt;/code&gt; ます。 &lt;code&gt;padding_shapes&lt;/code&gt; の引数は、出力要素における各構成要素の各次元のために得られた形状を決定します。</target>
        </trans-unit>
        <trans-unit id="e4abe35be36c6363497bfcbdede20ee0472e70d3" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;../../../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;to_graph&lt;/code&gt; is a low-level transpiler that converts Python code to TensorFlow graph code. It does not implement any caching, variable management or create any actual ops, and is best used where greater control over the generated TensorFlow graph is desired. Another difference from &lt;a href=&quot;../../../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt; is that &lt;code&gt;to_graph&lt;/code&gt; will not wrap the graph into a TensorFlow function or a Python callable. Internally, &lt;a href=&quot;../../../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt; uses &lt;code&gt;to_graph&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../../function&quot;&gt; &lt;code&gt;tf.function&lt;/code&gt; &lt;/a&gt;とは異なり、 &lt;code&gt;to_graph&lt;/code&gt; はPythonコードをTensorFlowグラフコードに変換する低レベルのトランスパイラーです。キャッシングや変数管理を実装したり、実際の演算を作成したりすることはなく、生成されたTensorFlowグラフをより詳細に制御したい場合に最適です。&lt;a href=&quot;../../../function&quot;&gt; &lt;code&gt;tf.function&lt;/code&gt; &lt;/a&gt;と &lt;code&gt;to_graph&lt;/code&gt; う1つの違いは、to_graphがグラフをTensorFlow関数またはPython呼び出し可能オブジェクトにラップしないことです。内部的には、&lt;a href=&quot;../../../function&quot;&gt; &lt;code&gt;tf.function&lt;/code&gt; &lt;/a&gt;はto_graphを使用し &lt;code&gt;to_graph&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c289f8aae64df7cd4ff7fdb8457061e6c012cdc6" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;../../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;wrap_function&lt;/code&gt; will only trace the Python function once. As with placeholders in TF 1.x, shapes and dtypes must be provided to &lt;code&gt;wrap_function&lt;/code&gt;'s &lt;code&gt;signature&lt;/code&gt; argument.</source>
          <target state="translated">&lt;a href=&quot;../../function&quot;&gt; &lt;code&gt;tf.function&lt;/code&gt; &lt;/a&gt;とは異なり、 &lt;code&gt;wrap_function&lt;/code&gt; はPython関数を1回だけトレースします。TF 1.xのプレースホルダーと同様に、 &lt;code&gt;wrap_function&lt;/code&gt; の &lt;code&gt;signature&lt;/code&gt; 引数には形状とdtypeを指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="704bf993fd1f302cbdbbea9b08e8e2b996cf4dcb" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;../dataset#batch&quot;&gt;&lt;code&gt;tf.data.Dataset.batch&lt;/code&gt;&lt;/a&gt;, the input elements to be batched may have different shapes, and each batch will be encoded as a &lt;a href=&quot;../../raggedtensor&quot;&gt;&lt;code&gt;tf.RaggedTensor&lt;/code&gt;&lt;/a&gt;. Example:</source>
          <target state="translated">&lt;a href=&quot;../dataset#batch&quot;&gt; &lt;code&gt;tf.data.Dataset.batch&lt;/code&gt; &lt;/a&gt;とは異なり、バッチ処理される入力要素の形状は異なる場合があり、各バッチは&lt;a href=&quot;../../raggedtensor&quot;&gt; &lt;code&gt;tf.RaggedTensor&lt;/code&gt; &lt;/a&gt;としてエンコードされます。例：</target>
        </trans-unit>
        <trans-unit id="ab3fab341c82646fe8f085450f444bec807918c5" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;../dataset#batch&quot;&gt;&lt;code&gt;tf.data.Dataset.batch&lt;/code&gt;&lt;/a&gt;, the input elements to be batched may have different shapes, and this transformation will pad each component to the respective shape in &lt;code&gt;padded_shapes&lt;/code&gt;. The &lt;code&gt;padded_shapes&lt;/code&gt; argument determines the resulting shape for each dimension of each component in an output element:</source>
          <target state="translated">&lt;a href=&quot;../dataset#batch&quot;&gt; &lt;code&gt;tf.data.Dataset.batch&lt;/code&gt; &lt;/a&gt;とは異なり、バッチ処理される入力要素の形状は異なる場合があり、この変換により、各コンポーネントが &lt;code&gt;padded_shapes&lt;/code&gt; のそれぞれの形状にパディングされます。 &lt;code&gt;padded_shapes&lt;/code&gt; の引数は、出力要素における各構成要素の各次元のために得られた形状を決定します。</target>
        </trans-unit>
        <trans-unit id="1ebb4bc2458197f2fb3172235869b74c91d350b2" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;../dataset#batch&quot;&gt;&lt;code&gt;tf.data.Dataset.batch&lt;/code&gt;&lt;/a&gt;, the input elements to be batched may have different shapes, and this transformation will pad each component to the respective shape in &lt;code&gt;padding_shapes&lt;/code&gt;. The &lt;code&gt;padding_shapes&lt;/code&gt; argument determines the resulting shape for each dimension of each component in an output element:</source>
          <target state="translated">&lt;a href=&quot;../dataset#batch&quot;&gt; &lt;code&gt;tf.data.Dataset.batch&lt;/code&gt; &lt;/a&gt;とは異なり、バッチ処理される入力要素の形状は異なる場合があり、この変換では、各コンポーネントがpadding_shapesのそれぞれの形状に &lt;code&gt;padding_shapes&lt;/code&gt; ます。 &lt;code&gt;padding_shapes&lt;/code&gt; の引数は、出力要素における各構成要素の各次元のために得られた形状を決定します。</target>
        </trans-unit>
        <trans-unit id="0d34e57a1aa18be3c8484d7069cc1c8ad2db64a5" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;../dataset#batch&quot;&gt;&lt;code&gt;tf.data.Dataset.batch&lt;/code&gt;&lt;/a&gt;, the input elements to be batched may have different shapes:</source>
          <target state="translated">&lt;a href=&quot;../dataset#batch&quot;&gt; &lt;code&gt;tf.data.Dataset.batch&lt;/code&gt; &lt;/a&gt;とは異なり、バッチ処理される入力要素の形状は異なる場合があります。</target>
        </trans-unit>
        <trans-unit id="69eb42951cde2b887407e0d83e6a95dc1668220b" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;to_graph&lt;/code&gt; is a low-level transpiler that converts Python code to TensorFlow graph code. It does not implement any caching, variable management or create any actual ops, and is best used where greater control over the generated TensorFlow graph is desired. Another difference from &lt;a href=&quot;../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt; is that &lt;code&gt;to_graph&lt;/code&gt; will not wrap the graph into a TensorFlow function or a Python callable. Internally, &lt;a href=&quot;../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt; uses &lt;code&gt;to_graph&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;../function&quot;&gt; &lt;code&gt;tf.function&lt;/code&gt; &lt;/a&gt;とは異なり、 &lt;code&gt;to_graph&lt;/code&gt; はPythonコードをTensorFlowグラフコードに変換する低レベルのトランスパイラーです。キャッシングや変数管理を実装したり、実際の演算を作成したりすることはなく、生成されたTensorFlowグラフをより詳細に制御したい場合に最適です。&lt;a href=&quot;../function&quot;&gt; &lt;code&gt;tf.function&lt;/code&gt; &lt;/a&gt;と &lt;code&gt;to_graph&lt;/code&gt; う1つの違いは、to_graphがグラフをTensorFlow関数またはPython呼び出し可能オブジェクトにラップしないことです。内部的には、&lt;a href=&quot;../function&quot;&gt; &lt;code&gt;tf.function&lt;/code&gt; &lt;/a&gt;はto_graphを使用し &lt;code&gt;to_graph&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="de7b7f502adc89ee96e98e3c06014fa1c272dc91" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;dataset#batch&quot;&gt;&lt;code&gt;tf.data.Dataset.batch&lt;/code&gt;&lt;/a&gt;, the input elements to be batched may have different shapes, and this transformation will pad each component to the respective shape in &lt;code&gt;padded_shapes&lt;/code&gt;. The &lt;code&gt;padded_shapes&lt;/code&gt; argument determines the resulting shape for each dimension of each component in an output element:</source>
          <target state="translated">&lt;a href=&quot;dataset#batch&quot;&gt; &lt;code&gt;tf.data.Dataset.batch&lt;/code&gt; &lt;/a&gt;とは異なり、バッチ処理される入力要素の形状は異なる場合があり、この変換により、各コンポーネントが &lt;code&gt;padded_shapes&lt;/code&gt; のそれぞれの形状にパディングされます。 &lt;code&gt;padded_shapes&lt;/code&gt; の引数は、出力要素における各構成要素の各次元のために得られた形状を決定します。</target>
        </trans-unit>
        <trans-unit id="dcde43ba32f97c1ff2549287396cb94e24747c3e" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;dataset#batch&quot;&gt;&lt;code&gt;tf.data.Dataset.batch&lt;/code&gt;&lt;/a&gt;, the input elements to be batched may have different shapes, and this transformation will pad each component to the respective shape in &lt;code&gt;padding_shapes&lt;/code&gt;. The &lt;code&gt;padding_shapes&lt;/code&gt; argument determines the resulting shape for each dimension of each component in an output element:</source>
          <target state="translated">&lt;a href=&quot;dataset#batch&quot;&gt; &lt;code&gt;tf.data.Dataset.batch&lt;/code&gt; &lt;/a&gt;とは異なり、バッチ処理される入力要素の形状は異なる場合があり、この変換では、各コンポーネントがpadding_shapesのそれぞれの形状に &lt;code&gt;padding_shapes&lt;/code&gt; ます。 &lt;code&gt;padding_shapes&lt;/code&gt; の引数は、出力要素における各構成要素の各次元のために得られた形状を決定します。</target>
        </trans-unit>
        <trans-unit id="e86a43f4e75dabc2059ed1937b3c30cb8a924b23" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;SoftmaxCrossEntropyWithLogits&lt;/code&gt;, this operation does not accept a matrix of label probabilities, but rather a single label per row of features. This label is considered to have probability 1.0 for the given row.</source>
          <target state="translated">&lt;code&gt;SoftmaxCrossEntropyWithLogits&lt;/code&gt; とは異なり、この操作はラベル確率の行列を受け入れませんが、フィーチャの行ごとに1つのラベルを受け入れます。このラベルは、指定された行の確率が1.0であると見なされます。</target>
        </trans-unit>
        <trans-unit id="c42cd1138a7b09e8aab4b48a275bce9fecd055c5" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;mean_squared_error&lt;/code&gt;, which is a measure of the differences between corresponding elements of &lt;code&gt;predictions&lt;/code&gt; and &lt;code&gt;labels&lt;/code&gt;, &lt;code&gt;mean_pairwise_squared_error&lt;/code&gt; is a measure of the differences between pairs of corresponding elements of &lt;code&gt;predictions&lt;/code&gt; and &lt;code&gt;labels&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;predictions&lt;/code&gt; と &lt;code&gt;labels&lt;/code&gt; 対応する要素間の差異の尺度である &lt;code&gt;mean_squared_error&lt;/code&gt; とは異なり、 &lt;code&gt;mean_pairwise_squared_error&lt;/code&gt; は、 &lt;code&gt;predictions&lt;/code&gt; と &lt;code&gt;labels&lt;/code&gt; 対応する要素のペア間の差異の尺度です。</target>
        </trans-unit>
        <trans-unit id="54b3e19f1658856fdd01905f7b1d827a5e2c7da2" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;stack&lt;/code&gt;, &lt;code&gt;parallel_stack&lt;/code&gt; does NOT support backpropagation.</source>
          <target state="translated">&lt;code&gt;stack&lt;/code&gt; とは異なり、 &lt;code&gt;parallel_stack&lt;/code&gt; は逆伝播をサポートしていません。</target>
        </trans-unit>
        <trans-unit id="3d3e8c9f8d19935be11b8a97738c865b48f3a40a" translate="yes" xml:space="preserve">
          <source>Unlike FractionalMaxPoolGrad, we don't need to find arg_max for FractionalAvgPoolGrad, we just need to evenly back-propagate each element of out_backprop to those indices that form the same pooling cell. Therefore, we just need to know the shape of original input tensor, instead of the whole tensor.</source>
          <target state="translated">FractionalMaxPoolGradとは異なり、FractionalAvgPoolGradではarg_maxを見つける必要はなく、out_backpropの各要素を同じプーリングセルを形成するインデックスに均等にバックプロパゲーションする必要があります。したがって、テンソル全体ではなく、元の入力テンソルの形状を知る必要があります。</target>
        </trans-unit>
        <trans-unit id="591f5490b4f3510f244c0007610068c1ceac25d0" translate="yes" xml:space="preserve">
          <source>Unlike MapDataset, the &lt;code&gt;f&lt;/code&gt; in FlatMapDataset is expected to return a Dataset variant, and FlatMapDataset will flatten successive results into a single Dataset.</source>
          <target state="translated">MapDatasetとは異なり、FlatMapDatasetの &lt;code&gt;f&lt;/code&gt; はデータセットバリアントを返すことが期待されており、FlatMapDatasetは連続する結果を単一のデータセットにフラット化します。</target>
        </trans-unit>
        <trans-unit id="c453e83691ce84ff295e7a2c1ef516446c3ab8d7" translate="yes" xml:space="preserve">
          <source>Unlike MapDataset, the &lt;code&gt;f&lt;/code&gt; in InterleaveDataset is expected to return a Dataset variant, and InterleaveDataset will flatten successive results into a single Dataset. Unlike FlatMapDataset, InterleaveDataset will interleave sequences of up to &lt;code&gt;block_length&lt;/code&gt; consecutive elements from &lt;code&gt;cycle_length&lt;/code&gt; input elements.</source>
          <target state="translated">MapDatasetとは異なり、InterleaveDatasetの &lt;code&gt;f&lt;/code&gt; はデータセットバリアントを返すことが期待されており、InterleaveDatasetは連続する結果を単一のデータセットにフラット化します。FlatMapDatasetとは異なり、InterleaveDatasetは、 &lt;code&gt;cycle_length&lt;/code&gt; 入力要素から最大 &lt;code&gt;block_length&lt;/code&gt; の連続する要素のシーケンスをインターリーブします。</target>
        </trans-unit>
        <trans-unit id="9c4c90486ba0091b8ea290c9a282ca7b97ffe78f" translate="yes" xml:space="preserve">
          <source>Unlike a &quot;MapDataset&quot;, which applies &lt;code&gt;f&lt;/code&gt; sequentially, this dataset invokes up to &lt;code&gt;batch_size * num_parallel_batches&lt;/code&gt; copies of &lt;code&gt;f&lt;/code&gt; in parallel.</source>
          <target state="translated">適用される「MapDataset」とは異なり &lt;code&gt;f&lt;/code&gt; を順次、このデータセットは、最大呼び出し &lt;code&gt;batch_size * num_parallel_batches&lt;/code&gt; のコピー &lt;code&gt;f&lt;/code&gt; 並行して。</target>
        </trans-unit>
        <trans-unit id="88b9771a4d40bd229bd2768494cd1206b15de019" translate="yes" xml:space="preserve">
          <source>Unlike a &quot;MapDataset&quot;, which applies &lt;code&gt;f&lt;/code&gt; sequentially, this dataset invokes up to &lt;code&gt;num_parallel_calls&lt;/code&gt; copies of &lt;code&gt;f&lt;/code&gt; in parallel.</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; を順番に適用する「MapDataset」とは異なり、このデータセットは最大 &lt;code&gt;num_parallel_calls&lt;/code&gt; の &lt;code&gt;f&lt;/code&gt; のコピーを並列に呼び出します。</target>
        </trans-unit>
        <trans-unit id="13fc8fd7e6240efedf349e3dbe4446fea97e3c13" translate="yes" xml:space="preserve">
          <source>Unlike a TensorShape object, a TensorSpec object contains both shape and dtype information for a tensor. This method allows layers to provide output dtype information if it is different from the input dtype. For any layer that doesn't implement this function, the framework will fall back to use &lt;code&gt;compute_output_shape&lt;/code&gt;, and will assume that the output dtype matches the input dtype.</source>
          <target state="translated">TensorShapeオブジェクトとは異なり、TensorSpecオブジェクトには、テンソルの形状とdtypeの両方の情報が含まれています。このメソッドにより、入力dtypeと異なる場合、レイヤーは出力dtype情報を提供できます。この関数を実装していないレイヤーの場合、フレームワークは &lt;code&gt;compute_output_shape&lt;/code&gt; を使用するようにフォールバックし、出力dtypeが入力dtypeと一致すると想定します。</target>
        </trans-unit>
        <trans-unit id="43b00e58be5bd1f34d6a3d43cebfb8995414356d" translate="yes" xml:space="preserve">
          <source>Unlike assertRaisesRegex, this method takes a literal string, not a regular expression.</source>
          <target state="translated">assertRaisesRegex とは異なり、このメソッドは正規表現ではなくリテラル文字列を受け取ります。</target>
        </trans-unit>
        <trans-unit id="b677c0df05da91282dc6309d244c4aedc109a5da" translate="yes" xml:space="preserve">
          <source>Unlike the Copy Op, this op has HostMemory constraint on its input or output.</source>
          <target state="translated">コピーオペとは異なり、このオペは入力または出力にHostMemory制約を持っています。</target>
        </trans-unit>
        <trans-unit id="d5f7d3fe36850e7fa5811bed8af5b2d92d808d37" translate="yes" xml:space="preserve">
          <source>Unlike the CopyHost Op, this op does not have HostMemory constraint on its input or output.</source>
          <target state="translated">CopyHostオペとは異なり、このオペは入力や出力にHostMemory制約を持ちません。</target>
        </trans-unit>
        <trans-unit id="780bb9592c9dfb9fae30e2efc18623daa3e2cff4" translate="yes" xml:space="preserve">
          <source>Unlike the older op &lt;a href=&quot;compat/v1/squeeze&quot;&gt;&lt;code&gt;tf.compat.v1.squeeze&lt;/code&gt;&lt;/a&gt;, this op does not accept a deprecated &lt;code&gt;squeeze_dims&lt;/code&gt; argument.</source>
          <target state="translated">以前のop &lt;a href=&quot;compat/v1/squeeze&quot;&gt; &lt;code&gt;tf.compat.v1.squeeze&lt;/code&gt; &lt;/a&gt;とは異なり、このopは非推奨の &lt;code&gt;squeeze_dims&lt;/code&gt; 引数を受け入れません。</target>
        </trans-unit>
        <trans-unit id="33c0f5ca96c96a12269cd4ff95c4f773357fb44e" translate="yes" xml:space="preserve">
          <source>Unlike the original &lt;code&gt;accumulate_n&lt;/code&gt;, &lt;code&gt;accumulate_n_v2&lt;/code&gt; is differentiable.</source>
          <target state="translated">元の &lt;code&gt;accumulate_n&lt;/code&gt; とは異なり、 &lt;code&gt;accumulate_n_v2&lt;/code&gt; は微分可能です。</target>
        </trans-unit>
        <trans-unit id="9828410fab6a8798616092f30a5aa2ae3611617b" translate="yes" xml:space="preserve">
          <source>Unordered dictionaries are not supported in eager mode when &lt;code&gt;exclusive=False&lt;/code&gt;. Use a list of tuples instead.</source>
          <target state="translated">順序付けされていない辞書は、 &lt;code&gt;exclusive=False&lt;/code&gt; の場合、eagerモードではサポートされません。代わりにタプルのリストを使用してください。</target>
        </trans-unit>
        <trans-unit id="e2231a91d542441b9a855a9095ab4fe46e316699" translate="yes" xml:space="preserve">
          <source>Unpack</source>
          <target state="translated">Unpack</target>
        </trans-unit>
        <trans-unit id="0657883ef20cc657b888740e46664440ff735ff1" translate="yes" xml:space="preserve">
          <source>Unpacking behavior for iterator-like inputs: A common pattern is to pass a tf.data.Dataset, generator, or tf.keras.utils.Sequence to the &lt;code&gt;x&lt;/code&gt; argument of fit, which will in fact yield not only features (x) but optionally targets (y) and sample weights. Keras requires that the output of such iterator-likes be unambiguous. The iterator should return a tuple of length 1, 2, or 3, where the optional second and third elements will be used for y and sample_weight respectively. Any other type provided will be wrapped in a length one tuple, effectively treating everything as 'x'. When yielding dicts, they should still adhere to the top-level tuple structure. e.g. &lt;code&gt;({&quot;x0&quot;: x0, &quot;x1&quot;: x1}, y)&lt;/code&gt;. Keras will not attempt to separate features, targets, and weights from the keys of a single dict. A notable unsupported data type is the namedtuple. The reason is that it behaves like both an ordered datatype (tuple) and a mapping datatype (dict). So given a namedtuple of the form: &lt;code&gt;namedtuple(&quot;example_tuple&quot;, [&quot;y&quot;, &quot;x&quot;])&lt;/code&gt; it is ambiguous whether to reverse the order of the elements when interpreting the value. Even worse is a tuple of the form: &lt;code&gt;namedtuple(&quot;other_tuple&quot;, [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;])&lt;/code&gt; where it is unclear if the tuple was intended to be unpacked into x, y, and sample_weight or passed through as a single element to &lt;code&gt;x&lt;/code&gt;. As a result the data processing code will simply raise a ValueError if it encounters a namedtuple. (Along with instructions to remedy the issue.)</source>
          <target state="translated">イテレータのような入力のアンパック動作：一般的なパターンは、tf.data.Dataset、generator、またはtf.keras.utils.Sequenceをfit の &lt;code&gt;x&lt;/code&gt; 引数に渡すことです。これにより、実際には機能（x）だけでなく、オプションでターゲット（y）とサンプルの重み。 Kerasは、そのようなイテレータのようなものの出力が明確であることを要求します。イテレータは長さ1、2、または3のタプルを返す必要があります。オプションの2番目と3番目の要素は、yとsample_weightにそれぞれ使用されます。提供される他のタイプは、長さ1のタプルでラップされ、事実上すべてを「x」として扱います。辞書を生成するとき、それらは依然としてトップレベルのタプル構造に準拠する必要があります。例 &lt;code&gt;({&quot;x0&quot;: x0, &quot;x1&quot;: x1}, y)&lt;/code&gt; 。 Kerasは、機能、ターゲット、および重みを単一のディクテーションのキーから分離しようとはしません。サポートされていない注目すべきデータ型はnamedtupleです。その理由は、順序付けされたデータ型（タプル）とマッピングデータ型（dict）の両方のように動作するためです。したがって、namedtuple &lt;code&gt;namedtuple(&quot;example_tuple&quot;, [&quot;y&quot;, &quot;x&quot;])&lt;/code&gt; という形式のnamedtupleを指定すると、値を解釈するときに要素の順序を逆にするかどうかが不明確になります。さらに悪いのは、次の形式のタプルです &lt;code&gt;namedtuple(&quot;other_tuple&quot;, [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;])&lt;/code&gt; タプルがx、y、sample_weightにアンパックされたのか、渡されたのかがわからない場合への単一の要素として &lt;code&gt;x&lt;/code&gt; まで。その結果、データ処理コードは、namedtupleを検出した場合にValueErrorを発生させます。（問題を解決するための指示とともに）。</target>
        </trans-unit>
        <trans-unit id="a70d7a46a185b9dd6d1158e08b8b8c0950e01eaa" translate="yes" xml:space="preserve">
          <source>Unpacks &lt;code&gt;num&lt;/code&gt; tensors from &lt;code&gt;value&lt;/code&gt; by chipping it along the &lt;code&gt;axis&lt;/code&gt; dimension. For example, given a tensor of shape &lt;code&gt;(A, B, C, D)&lt;/code&gt;;</source>
          <target state="translated">アンパック &lt;code&gt;num&lt;/code&gt; からテンソル &lt;code&gt;value&lt;/code&gt; に沿ってチッピングによって &lt;code&gt;axis&lt;/code&gt; 寸法。たとえば、形状 &lt;code&gt;(A, B, C, D)&lt;/code&gt; テンソルが与えられます。</target>
        </trans-unit>
        <trans-unit id="243ed91dcd10a0424df6d36deb350e6391df8548" translate="yes" xml:space="preserve">
          <source>Unpacks &lt;code&gt;num&lt;/code&gt; tensors from &lt;code&gt;value&lt;/code&gt; by chipping it along the &lt;code&gt;axis&lt;/code&gt; dimension. If &lt;code&gt;num&lt;/code&gt; is not specified (the default), it is inferred from &lt;code&gt;value&lt;/code&gt;'s shape. If &lt;code&gt;value.shape[axis]&lt;/code&gt; is not known, &lt;code&gt;ValueError&lt;/code&gt; is raised.</source>
          <target state="translated">アンパック &lt;code&gt;num&lt;/code&gt; からテンソル &lt;code&gt;value&lt;/code&gt; に沿ってチッピングによって &lt;code&gt;axis&lt;/code&gt; 寸法。 &lt;code&gt;num&lt;/code&gt; が指定されていない場合（デフォルト）、 &lt;code&gt;value&lt;/code&gt; の形状から推測されます。場合 &lt;code&gt;value.shape[axis]&lt;/code&gt; 知られていない、 &lt;code&gt;ValueError&lt;/code&gt; 発生します。</target>
        </trans-unit>
        <trans-unit id="eb445a131ff25a35a36ff7e142e017c24f785cd1" translate="yes" xml:space="preserve">
          <source>Unpacks a given dimension of a rank-&lt;code&gt;R&lt;/code&gt; tensor into &lt;code&gt;num&lt;/code&gt; rank-&lt;code&gt;(R-1)&lt;/code&gt; tensors.</source>
          <target state="translated">ランク &lt;code&gt;R&lt;/code&gt; テンソルの指定された次元を &lt;code&gt;num&lt;/code&gt; ランク &lt;code&gt;(R-1)&lt;/code&gt; テンソルに展開します。</target>
        </trans-unit>
        <trans-unit id="48918b5563a8ceafb76129f6bc60ab73e49603cf" translate="yes" xml:space="preserve">
          <source>Unpacks the given dimension of a rank-&lt;code&gt;R&lt;/code&gt; tensor into rank-&lt;code&gt;(R-1)&lt;/code&gt; tensors.</source>
          <target state="translated">ランク &lt;code&gt;R&lt;/code&gt; テンソルの指定された次元をランク &lt;code&gt;(R-1)&lt;/code&gt; テンソルにアンパックします。</target>
        </trans-unit>
        <trans-unit id="d65a83d865bb52fdcfa278aa190e57e05dce3f63" translate="yes" xml:space="preserve">
          <source>Unpacks user-provided data tuple.</source>
          <target state="translated">ユーザーが提供するデータタプルを解凍します。</target>
        </trans-unit>
        <trans-unit id="05dc9402d9793ff470926b16aca6821cb0999026" translate="yes" xml:space="preserve">
          <source>Unparses all flags to the point before any FLAGS(argv) was called.</source>
          <target state="translated">FLAGS(argv)が呼び出される前の時点までのすべてのフラグをアンパースします。</target>
        </trans-unit>
        <trans-unit id="2c8018d2ec1edd743fc94f4ac501f4979aa67070" translate="yes" xml:space="preserve">
          <source>UnravelIndex</source>
          <target state="translated">UnravelIndex</target>
        </trans-unit>
        <trans-unit id="5abd8671c3b3e7c85742a7fbdf4fc8baadcb9032" translate="yes" xml:space="preserve">
          <source>UnrecognizedFlagError: if the referenced flag doesn't exist. DuplicateFlagError: if the alias name has been used by some existing flag.</source>
          <target state="translated">UnrecognizedFlagError:参照されているフラグが存在しない場合。DuplicateFlagError:エイリアス名が既存のフラグで使用されている場合。</target>
        </trans-unit>
        <trans-unit id="d01190ad612aa7505976a06d2cc1e8836b163992" translate="yes" xml:space="preserve">
          <source>Unscaled log probabilities of shape &lt;code&gt;[d_0, d_1, ..., d_{r-1}, num_classes]&lt;/code&gt; and dtype &lt;code&gt;float16&lt;/code&gt;, &lt;code&gt;float32&lt;/code&gt; or &lt;code&gt;float64&lt;/code&gt;.</source>
          <target state="translated">形状 &lt;code&gt;[d_0, d_1, ..., d_{r-1}, num_classes]&lt;/code&gt; およびdtype &lt;code&gt;float16&lt;/code&gt; 、 &lt;code&gt;float32&lt;/code&gt; 、または &lt;code&gt;float64&lt;/code&gt; のスケーリングされていない対数確率。</target>
        </trans-unit>
        <trans-unit id="6b9238f8e545d4a2d2b6a4160c436067e5463ca7" translate="yes" xml:space="preserve">
          <source>Unscaled log probabilities of shape &lt;code&gt;[d_0, d_1, ..., d_{r-1}, num_classes]&lt;/code&gt; and dtype &lt;code&gt;float16&lt;/code&gt;, &lt;code&gt;float32&lt;/code&gt;, or &lt;code&gt;float64&lt;/code&gt;.</source>
          <target state="translated">形状 &lt;code&gt;[d_0, d_1, ..., d_{r-1}, num_classes]&lt;/code&gt; およびdtype &lt;code&gt;float16&lt;/code&gt; 、 &lt;code&gt;float32&lt;/code&gt; 、または &lt;code&gt;float64&lt;/code&gt; のスケーリングされていない対数確率。</target>
        </trans-unit>
        <trans-unit id="6fd64ffd66a09162278b73ad3a2e108855905b4f" translate="yes" xml:space="preserve">
          <source>Unscaled log probabilities.</source>
          <target state="translated">尺度化されていない対数確率。</target>
        </trans-unit>
        <trans-unit id="9e5da72ba27bb718f2dac7fc946f26f49a76ad43" translate="yes" xml:space="preserve">
          <source>Unscales the gradients by the loss scale.</source>
          <target state="translated">勾配をロススケールでアンスケールします。</target>
        </trans-unit>
        <trans-unit id="9329b6002fc399b1c6e7eb106d68b0ce50955b52" translate="yes" xml:space="preserve">
          <source>UnsortedSegmentJoin</source>
          <target state="translated">UnsortedSegmentJoin</target>
        </trans-unit>
        <trans-unit id="0982334ce0fca73c3a5e3ea913a7e0313a459f82" translate="yes" xml:space="preserve">
          <source>UnsortedSegmentMax</source>
          <target state="translated">UnsortedSegmentMax</target>
        </trans-unit>
        <trans-unit id="366fa15ecb43d76a152b506219741a7b3f5f0bcd" translate="yes" xml:space="preserve">
          <source>UnsortedSegmentMin</source>
          <target state="translated">UnsortedSegmentMin</target>
        </trans-unit>
        <trans-unit id="6ef6286b2679e6c430cc36837f66e9730b079a8c" translate="yes" xml:space="preserve">
          <source>UnsortedSegmentProd</source>
          <target state="translated">UnsortedSegmentProd</target>
        </trans-unit>
        <trans-unit id="88334ca532d2e8466fab68a79d76f33ec76acf9a" translate="yes" xml:space="preserve">
          <source>UnsortedSegmentSum</source>
          <target state="translated">UnsortedSegmentSum</target>
        </trans-unit>
        <trans-unit id="c32922004f1cab6d2b368005f373dc639dc0003a" translate="yes" xml:space="preserve">
          <source>Unspecified run-time error.</source>
          <target state="translated">指定されていないランタイムエラーです。</target>
        </trans-unit>
        <trans-unit id="b986cea6fdf9453b34548d5133226ff149db996f" translate="yes" xml:space="preserve">
          <source>Unstack the values of a &lt;code&gt;Tensor&lt;/code&gt; in the TensorArray.</source>
          <target state="translated">TensorArray内の &lt;code&gt;Tensor&lt;/code&gt; の値をアンスタックします。</target>
        </trans-unit>
        <trans-unit id="7298d7ed988425fb6199864e49341c509f32d027" translate="yes" xml:space="preserve">
          <source>Unstage</source>
          <target state="translated">Unstage</target>
        </trans-unit>
        <trans-unit id="c5093a3d1578793a3f4e74f50d7ce016ac60ef3d" translate="yes" xml:space="preserve">
          <source>Untested. Very likely will not learn to output repeated classes.</source>
          <target state="translated">テストされていない。非常に可能性が高く、繰り返しのクラスを出力することを学ぶことはできません。</target>
        </trans-unit>
        <trans-unit id="5a0115166e5bef4246c231811f6b2ed301118eb7" translate="yes" xml:space="preserve">
          <source>Until the release of TF 2.0, we need the legacy behavior of &lt;code&gt;TensorShape&lt;/code&gt; to coexist with the new behavior. This utility is a bridge between the two.</source>
          <target state="translated">TF 2.0のリリースまでは、 &lt;code&gt;TensorShape&lt;/code&gt; のレガシー動作が新しい動作と共存する必要があります。このユーティリティは、2つの間のブリッジです。</target>
        </trans-unit>
        <trans-unit id="f13be7738e1389f72c0f88aa84d17719f746bf4a" translate="yes" xml:space="preserve">
          <source>Unused.</source>
          <target state="translated">Unused.</target>
        </trans-unit>
        <trans-unit id="673367f4f1a26218e41caccf074dc2728214600f" translate="yes" xml:space="preserve">
          <source>UnwrapDatasetVariant</source>
          <target state="translated">UnwrapDatasetVariant</target>
        </trans-unit>
        <trans-unit id="45306172633156360fe411da89aad86bcba27d77" translate="yes" xml:space="preserve">
          <source>Unwrapping and merging: Consider calling a function &lt;code&gt;fn&lt;/code&gt; on multiple replicas, like &lt;code&gt;experimental_run_v2(fn, args=[w])&lt;/code&gt; with an argument &lt;code&gt;w&lt;/code&gt; that is a wrapped value. This means &lt;code&gt;w&lt;/code&gt; will have a map taking replica id &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;w0&lt;/code&gt;, replica id &lt;code&gt;11&lt;/code&gt; to &lt;code&gt;w1&lt;/code&gt;, etc. &lt;code&gt;experimental_run_v2()&lt;/code&gt; unwraps &lt;code&gt;w&lt;/code&gt; before calling &lt;code&gt;fn&lt;/code&gt;, so it calls &lt;code&gt;fn(w0)&lt;/code&gt; on &lt;code&gt;d0&lt;/code&gt;, &lt;code&gt;fn(w1)&lt;/code&gt; on &lt;code&gt;d1&lt;/code&gt;, etc. It then merges the return values from &lt;code&gt;fn()&lt;/code&gt;, which can possibly result in wrapped values. For example, let's say &lt;code&gt;fn()&lt;/code&gt; returns a tuple with three components: &lt;code&gt;(x, a, v0)&lt;/code&gt; from replica 0, &lt;code&gt;(x, b, v1)&lt;/code&gt; on replica 1, etc. If the first component is the same object &lt;code&gt;x&lt;/code&gt; from every replica, then the first component of the merged result will also be &lt;code&gt;x&lt;/code&gt;. If the second component is different (&lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, ...) from each replica, then the merged value will have a wrapped map from replica device to the different values. If the third component is the members of a mirrored variable (&lt;code&gt;v&lt;/code&gt; maps &lt;code&gt;d0&lt;/code&gt; to &lt;code&gt;v0&lt;/code&gt;, &lt;code&gt;d1&lt;/code&gt; to &lt;a href=&quot;../../v1&quot;&gt;&lt;code&gt;v1&lt;/code&gt;&lt;/a&gt;, etc.), then the merged result will be that mirrored variable (&lt;code&gt;v&lt;/code&gt;).</source>
          <target state="translated">アンラップとマージ：ラップされた値である引数 &lt;code&gt;w&lt;/code&gt; を使用して、 &lt;code&gt;experimental_run_v2(fn, args=[w])&lt;/code&gt; ように、複数のレプリカで関数 &lt;code&gt;fn&lt;/code&gt; を呼び出すことを検討してください。この手段 &lt;code&gt;w&lt;/code&gt; はレプリカID服用マップがあります &lt;code&gt;0&lt;/code&gt; に &lt;code&gt;w0&lt;/code&gt; 、レプリカID &lt;code&gt;11&lt;/code&gt; に &lt;code&gt;w1&lt;/code&gt; など &lt;code&gt;experimental_run_v2()&lt;/code&gt; アンラップ &lt;code&gt;w&lt;/code&gt; を呼び出す前に &lt;code&gt;fn&lt;/code&gt; それが呼び出すので、 &lt;code&gt;fn(w0)&lt;/code&gt; 上 &lt;code&gt;d0&lt;/code&gt; 、 &lt;code&gt;fn(w1)&lt;/code&gt; の &lt;code&gt;d1&lt;/code&gt; 、など次に、 &lt;code&gt;fn()&lt;/code&gt; からの戻り値をマージします、値がラップされる可能性があります。たとえば、 &lt;code&gt;fn()&lt;/code&gt; としましょう三の成分とのタプルを返す： &lt;code&gt;(x, a, v0)&lt;/code&gt; レプリカ0から &lt;code&gt;(x, b, v1)&lt;/code&gt; 第一成分が同じオブジェクトである場合等レプリカ1上の &lt;code&gt;x&lt;/code&gt; すべてからレプリカの場合、マージされた結果の最初のコンポーネントも &lt;code&gt;x&lt;/code&gt; になります。 2番目のコンポーネントが各レプリカと異なる（ &lt;code&gt;a&lt;/code&gt; 、 &lt;code&gt;b&lt;/code&gt; 、...）場合、マージされた値には、レプリカデバイスから別の値へのマップがラップされます。 3番目のコンポーネントがミラー変数のメンバーである場合（ &lt;code&gt;v&lt;/code&gt; は &lt;code&gt;d0&lt;/code&gt; を &lt;code&gt;v0&lt;/code&gt; に、 &lt;code&gt;d1&lt;/code&gt; を&lt;a href=&quot;../../v1&quot;&gt; &lt;code&gt;v1&lt;/code&gt; に&lt;/a&gt;マップしますなど）、マージされた結果は、ミラーリングされた変数（ &lt;code&gt;v&lt;/code&gt; ）になります。</target>
        </trans-unit>
        <trans-unit id="452d19a44e1939a79c6b1e46110b7518ec2e32f4" translate="yes" xml:space="preserve">
          <source>Unwrapping and merging: Consider calling a function &lt;code&gt;fn&lt;/code&gt; on multiple replicas, like &lt;code&gt;experimental_run_v2(fn, args=[w])&lt;/code&gt; with an argument &lt;code&gt;w&lt;/code&gt; that is a wrapped value. This means &lt;code&gt;w&lt;/code&gt; will have a map taking replica id &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;w0&lt;/code&gt;, replica id &lt;code&gt;11&lt;/code&gt; to &lt;code&gt;w1&lt;/code&gt;, etc. &lt;code&gt;experimental_run_v2()&lt;/code&gt; unwraps &lt;code&gt;w&lt;/code&gt; before calling &lt;code&gt;fn&lt;/code&gt;, so it calls &lt;code&gt;fn(w0)&lt;/code&gt; on &lt;code&gt;d0&lt;/code&gt;, &lt;code&gt;fn(w1)&lt;/code&gt; on &lt;code&gt;d1&lt;/code&gt;, etc. It then merges the return values from &lt;code&gt;fn()&lt;/code&gt;, which can possibly result in wrapped values. For example, let's say &lt;code&gt;fn()&lt;/code&gt; returns a tuple with three components: &lt;code&gt;(x, a, v0)&lt;/code&gt; from replica 0, &lt;code&gt;(x, b, v1)&lt;/code&gt; on replica 1, etc. If the first component is the same object &lt;code&gt;x&lt;/code&gt; from every replica, then the first component of the merged result will also be &lt;code&gt;x&lt;/code&gt;. If the second component is different (&lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, ...) from each replica, then the merged value will have a wrapped map from replica device to the different values. If the third component is the members of a mirrored variable (&lt;code&gt;v&lt;/code&gt; maps &lt;code&gt;d0&lt;/code&gt; to &lt;code&gt;v0&lt;/code&gt;, &lt;code&gt;d1&lt;/code&gt; to &lt;a href=&quot;../compat/v1&quot;&gt;&lt;code&gt;v1&lt;/code&gt;&lt;/a&gt;, etc.), then the merged result will be that mirrored variable (&lt;code&gt;v&lt;/code&gt;).</source>
          <target state="translated">アンラップとマージ：ラップされた値である引数 &lt;code&gt;w&lt;/code&gt; を使用して、 &lt;code&gt;experimental_run_v2(fn, args=[w])&lt;/code&gt; ように、複数のレプリカで関数 &lt;code&gt;fn&lt;/code&gt; を呼び出すことを検討してください。この手段 &lt;code&gt;w&lt;/code&gt; はレプリカID服用マップがあります &lt;code&gt;0&lt;/code&gt; に &lt;code&gt;w0&lt;/code&gt; 、レプリカID &lt;code&gt;11&lt;/code&gt; に &lt;code&gt;w1&lt;/code&gt; など &lt;code&gt;experimental_run_v2()&lt;/code&gt; アンラップ &lt;code&gt;w&lt;/code&gt; を呼び出す前に &lt;code&gt;fn&lt;/code&gt; それが呼び出すので、 &lt;code&gt;fn(w0)&lt;/code&gt; 上 &lt;code&gt;d0&lt;/code&gt; 、 &lt;code&gt;fn(w1)&lt;/code&gt; の &lt;code&gt;d1&lt;/code&gt; 、など次に、 &lt;code&gt;fn()&lt;/code&gt; からの戻り値をマージします、ラップされた値になる可能性があります。例えば、レッツ言うの &lt;code&gt;fn()&lt;/code&gt; 三の成分とのタプルを返す： &lt;code&gt;(x, a, v0)&lt;/code&gt; レプリカ0から &lt;code&gt;(x, b, v1)&lt;/code&gt; 第一成分が同じオブジェクトである場合等レプリカ1上の &lt;code&gt;x&lt;/code&gt; すべてからレプリカの場合、マージされた結果の最初のコンポーネントも &lt;code&gt;x&lt;/code&gt; になります。 2番目のコンポーネントが各レプリカと異なる（ &lt;code&gt;a&lt;/code&gt; 、 &lt;code&gt;b&lt;/code&gt; 、...）場合、マージされた値には、レプリカデバイスから別の値へのマップがラップされます。 3番目のコンポーネントがミラー変数のメンバーである場合（ &lt;code&gt;v&lt;/code&gt; は &lt;code&gt;d0&lt;/code&gt; を &lt;code&gt;v0&lt;/code&gt; に、 &lt;code&gt;d1&lt;/code&gt; を&lt;a href=&quot;../compat/v1&quot;&gt; &lt;code&gt;v1&lt;/code&gt; に&lt;/a&gt;マップしますなど）、マージされた結果は、ミラーリングされた変数（ &lt;code&gt;v&lt;/code&gt; ）になります。</target>
        </trans-unit>
        <trans-unit id="447e8380a0660bcbaf0b5a0132d4263bb7475a27" translate="yes" xml:space="preserve">
          <source>Unwraps an object into a list of TFDecorators and a final target.</source>
          <target state="translated">オブジェクトをTFDecoratorsのリストと最終ターゲットにアンラップします。</target>
        </trans-unit>
        <trans-unit id="f84ad806586080c9477df4b9148217324f31d72e" translate="yes" xml:space="preserve">
          <source>Up-to-date gradients (i.e., time step at which gradient was computed is equal to the accumulator's time step) are added to the accumulator.</source>
          <target state="translated">最新のグラデーション(すなわち、グラデーションが計算されたタイムステップがアキュムレータのタイムステップと等しい)がアキュムレータに追加されます。</target>
        </trans-unit>
        <trans-unit id="82d0fcae0670e010a42fb65be9daf931bbfd317f" translate="yes" xml:space="preserve">
          <source>Update '*var' according to the AdaMax algorithm.</source>
          <target state="translated">AdaMaxアルゴリズムに従って'*var'を更新します。</target>
        </trans-unit>
        <trans-unit id="e38d308cee1cac8d9c2edb27c5ab629ef7fac7d9" translate="yes" xml:space="preserve">
          <source>Update '*var' according to the Adam algorithm.</source>
          <target state="translated">アダムアルゴリズムに従って'*var'を更新します。</target>
        </trans-unit>
        <trans-unit id="1b43e05874006f2166053362d39efb24c1da40cb" translate="yes" xml:space="preserve">
          <source>Update '*var' according to the AddSign update.</source>
          <target state="translated">AddSignの更新に合わせて'*var'を更新します。</target>
        </trans-unit>
        <trans-unit id="52d1d116ee95e78e3bbfd1ce841dc358b8929317" translate="yes" xml:space="preserve">
          <source>Update '*var' according to the Ftrl-proximal scheme.</source>
          <target state="translated">Ftrl-proximal スキームに従って '*var' を更新します。</target>
        </trans-unit>
        <trans-unit id="471071d3477d079bfcbcf7383ae1d699f1fecd50" translate="yes" xml:space="preserve">
          <source>Update '*var' according to the RMSProp algorithm.</source>
          <target state="translated">RMSPropアルゴリズムに従って'*var'を更新します。</target>
        </trans-unit>
        <trans-unit id="ff81ee48686edeb07f152d5d3567bb2505faedfb" translate="yes" xml:space="preserve">
          <source>Update '*var' according to the adadelta scheme.</source>
          <target state="translated">adadelta スキームに合わせて '*var' を更新します。</target>
        </trans-unit>
        <trans-unit id="5d5ebbbd0b1837c20103e258d32dcbcdda20ba7d" translate="yes" xml:space="preserve">
          <source>Update '*var' according to the adagrad scheme.</source>
          <target state="translated">adagradスキームに合わせて'*var'を更新します。</target>
        </trans-unit>
        <trans-unit id="868d113999a0543f3fad5d44d43245c1668a6d37" translate="yes" xml:space="preserve">
          <source>Update '*var' according to the centered RMSProp algorithm.</source>
          <target state="translated">中央揃えの RMSProp アルゴリズムに従って '*var' を更新します。</target>
        </trans-unit>
        <trans-unit id="e800b9c7484bc8710e98c151f2fff6a2fd5d03ac" translate="yes" xml:space="preserve">
          <source>Update '*var' according to the momentum scheme.</source>
          <target state="translated">勢いのあるスキームに合わせて'*var'を更新します。</target>
        </trans-unit>
        <trans-unit id="9d77d08a52fed9d23da57628bfa85afe8cc236bc" translate="yes" xml:space="preserve">
          <source>Update '*var' according to the proximal adagrad scheme.</source>
          <target state="translated">近位アダグラードスキームに合わせて'*var'を更新します。</target>
        </trans-unit>
        <trans-unit id="787674ac15a7f58c7a9bd7dc691b153215067ce5" translate="yes" xml:space="preserve">
          <source>Update '*var' as FOBOS algorithm with fixed learning rate.</source>
          <target state="translated">var'を固定学習率のFOBOSアルゴリズムとして更新する。</target>
        </trans-unit>
        <trans-unit id="abf5d76205f9777481707bb7900ee4d7f09321a8" translate="yes" xml:space="preserve">
          <source>Update '*var' by subtracting 'alpha' * 'delta' from it.</source>
          <target state="translated">varから'alpha'*'delta'を引いて'*var'を更新します。</target>
        </trans-unit>
        <trans-unit id="9efdd46b9ea48522d76a8280bde64699fbd0f6a5" translate="yes" xml:space="preserve">
          <source>Update '&lt;em&gt;var' and '&lt;/em&gt;accum' according to FOBOS with Adagrad learning rate.</source>
          <target state="translated">Adagrad学習率でFOBOSに従って「&lt;em&gt;var」と「&lt;/em&gt; accum」を更新します。</target>
        </trans-unit>
        <trans-unit id="fe20dc33f34485fdead6adf9d07e849e8a936d69" translate="yes" xml:space="preserve">
          <source>Update 'ref' by adding 'value' to it.</source>
          <target state="translated">refに'value'を追加して'ref'を更新します。</target>
        </trans-unit>
        <trans-unit id="c9257701af71d4f765da34dcd01e8df105b8aa44" translate="yes" xml:space="preserve">
          <source>Update 'ref' by assigning 'value' to it.</source>
          <target state="translated">refに'value'を代入して、'ref'を更新します。</target>
        </trans-unit>
        <trans-unit id="29365e08f06cd2686f25f0d377b66ff5415b759c" translate="yes" xml:space="preserve">
          <source>Update 'ref' by subtracting 'value' from it.</source>
          <target state="translated">ref'から'value'を引いて'ref'を更新します。</target>
        </trans-unit>
        <trans-unit id="6fe8e246cbfb66ec49e8326c839db8c07c5c7366" translate="yes" xml:space="preserve">
          <source>Update (</source>
          <target state="translated">更新(</target>
        </trans-unit>
        <trans-unit id="6509bc67c069e61a7a1a3a68aa4391deff81b6d2" translate="yes" xml:space="preserve">
          <source>Update &lt;code&gt;ref&lt;/code&gt; by adding &lt;code&gt;value&lt;/code&gt; to it.</source>
          <target state="translated">&lt;code&gt;ref&lt;/code&gt; に &lt;code&gt;value&lt;/code&gt; を追加して、refを更新します。</target>
        </trans-unit>
        <trans-unit id="05a75e8ad72ec7a17916b0418183b2ae49757686" translate="yes" xml:space="preserve">
          <source>Update &lt;code&gt;ref&lt;/code&gt; by assigning &lt;code&gt;value&lt;/code&gt; to it.</source>
          <target state="translated">&lt;code&gt;ref&lt;/code&gt; に &lt;code&gt;value&lt;/code&gt; を割り当てて、refを更新します。</target>
        </trans-unit>
        <trans-unit id="0da9a4ecf7a09eb5b3d6a68070c44c71f746dcb9" translate="yes" xml:space="preserve">
          <source>Update &lt;code&gt;ref&lt;/code&gt; by subtracting &lt;code&gt;value&lt;/code&gt; from it.</source>
          <target state="translated">&lt;code&gt;ref&lt;/code&gt; から &lt;code&gt;value&lt;/code&gt; を引くことにより、refを更新します。</target>
        </trans-unit>
        <trans-unit id="04cf114f82db9c03d560972fce4e303ff3f2a1fd" translate="yes" xml:space="preserve">
          <source>Update entries in '&lt;em&gt;var' and '&lt;/em&gt;accum' according to the proximal adagrad scheme.</source>
          <target state="translated">近位アダグラードスキームに従って、「&lt;em&gt;var」および「&lt;/em&gt; accum」のエントリを更新します。</target>
        </trans-unit>
        <trans-unit id="8d6d9dee5acd7031de9e9744560f0e2f29a28a2c" translate="yes" xml:space="preserve">
          <source>Update op.</source>
          <target state="translated">アップデートしてください。</target>
        </trans-unit>
        <trans-unit id="447e87cca9a900913e2b362703c44b530d8ad36e" translate="yes" xml:space="preserve">
          <source>Update relevant entries in '*var' according to the Ftrl-proximal scheme.</source>
          <target state="translated">Ftrl-proximal スキームに従って'*var'内の関連するエントリを更新します。</target>
        </trans-unit>
        <trans-unit id="97803936ee3881b955dd554c9048e1fb8c7cee65" translate="yes" xml:space="preserve">
          <source>Update relevant entries in '&lt;em&gt;var' and '&lt;/em&gt;accum' according to the adagrad scheme.</source>
          <target state="translated">adagradスキームに従って、「&lt;em&gt;var」および「&lt;/em&gt; accum」の関連エントリを更新します。</target>
        </trans-unit>
        <trans-unit id="d6438974b08aca642d6bcdb677ce1d3cc168f6c3" translate="yes" xml:space="preserve">
          <source>Update relevant entries in '&lt;em&gt;var' and '&lt;/em&gt;accum' according to the momentum scheme.</source>
          <target state="translated">運動量スキームに従って、「&lt;em&gt;var」および「&lt;/em&gt; accum」の関連エントリを更新します。</target>
        </trans-unit>
        <trans-unit id="3f3b6f8527ee9f9f2b48e9baa56537bfbb1fe75d" translate="yes" xml:space="preserve">
          <source>Update rule for parameter &lt;code&gt;w&lt;/code&gt; with gradient &lt;code&gt;g&lt;/code&gt; when &lt;code&gt;momentum&lt;/code&gt; is 0:</source>
          <target state="translated">&lt;code&gt;momentum&lt;/code&gt; が0の場合、勾配 &lt;code&gt;g&lt;/code&gt; でパラメーター &lt;code&gt;w&lt;/code&gt; のルールを更新します。</target>
        </trans-unit>
        <trans-unit id="63b0c5665a5cecb00d89f2c99aeee6da821e96bf" translate="yes" xml:space="preserve">
          <source>Update rule when &lt;code&gt;momentum&lt;/code&gt; is larger than 0:</source>
          <target state="translated">&lt;code&gt;momentum&lt;/code&gt; が0より大きい場合のルールの更新：</target>
        </trans-unit>
        <trans-unit id="d3f52bac13b63cbb6e97bf073a84b716bbe078b6" translate="yes" xml:space="preserve">
          <source>Update step:</source>
          <target state="translated">ステップを更新します。</target>
        </trans-unit>
        <trans-unit id="a77038db17ca8f9cacdb34920018f09eddc93c47" translate="yes" xml:space="preserve">
          <source>Update the last triggered time and step number.</source>
          <target state="translated">最後に発動した時間とステップ番号を更新します。</target>
        </trans-unit>
        <trans-unit id="d386d7ccaa88b6dedf1b5040c55b451c526442d6" translate="yes" xml:space="preserve">
          <source>Update the value of &lt;code&gt;x&lt;/code&gt; by adding &lt;code&gt;increment&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;increment&lt;/code&gt; を追加して、 &lt;code&gt;x&lt;/code&gt; の値を更新します。</target>
        </trans-unit>
        <trans-unit id="bbd7754fb14c25638e64d5d064bb72937445b6c4" translate="yes" xml:space="preserve">
          <source>Update the value of &lt;code&gt;x&lt;/code&gt; by subtracting &lt;code&gt;decrement&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; の値を、 &lt;code&gt;decrement&lt;/code&gt; を引いて更新します。</target>
        </trans-unit>
        <trans-unit id="bdd024c3635252f3a95af60168a7a02c85468f31" translate="yes" xml:space="preserve">
          <source>Updated base class for optimizers.</source>
          <target state="translated">オプティマイザの基底クラスを更新しました。</target>
        </trans-unit>
        <trans-unit id="f63d62e4ed45a361aebb6397e1fccc02f07b3ec2" translate="yes" xml:space="preserve">
          <source>Updates eval metrics. See &lt;code&gt;base_head.Head&lt;/code&gt; for details.</source>
          <target state="translated">評価指標を更新します。詳細については、 &lt;code&gt;base_head.Head&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="25882cbb9d1b53825b652d00bf42872915dbaa9e" translate="yes" xml:space="preserve">
          <source>Updates internal vocabulary based on a list of sequences.</source>
          <target state="translated">シーケンスのリストに基づいて内部語彙を更新します。</target>
        </trans-unit>
        <trans-unit id="852460ee15870b6e90ad0684cbc07e2e2a1a46d1" translate="yes" xml:space="preserve">
          <source>Updates internal vocabulary based on a list of texts.</source>
          <target state="translated">テキストのリストに基づいて内部語彙を更新します。</target>
        </trans-unit>
        <trans-unit id="bf38595a5f74f710192dab7d4c5a5b9f35f64f69" translate="yes" xml:space="preserve">
          <source>Updates loss scale based on if gradients are finite in current step.</source>
          <target state="translated">現在のステップで勾配が有限であるかどうかに基づいて損失スケールを更新します。</target>
        </trans-unit>
        <trans-unit id="3ff6b49a83b568897a31a71591847bcb981cfe8c" translate="yes" xml:space="preserve">
          <source>Updates metric objects and returns a &lt;code&gt;dict&lt;/code&gt; of the updated metrics.</source>
          <target state="translated">メトリックオブジェクトを更新し、更新されたメトリックの &lt;code&gt;dict&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="c1444a8720b007d3bc3efc14cd0416a718bdfe20" translate="yes" xml:space="preserve">
          <source>Updates specified rows 'i' with values 'v'.</source>
          <target state="translated">指定された行 'i' を値 'v' で更新します。</target>
        </trans-unit>
        <trans-unit id="da9e8385ef1cee6fd5a3ef89050fbd2471b13c5e" translate="yes" xml:space="preserve">
          <source>Updates the accumulator with a new value for global_step.</source>
          <target state="translated">global_step の新しい値でアキュムレータを更新します。</target>
        </trans-unit>
        <trans-unit id="04014643289292114c04f072ec1d42a7ffcf535f" translate="yes" xml:space="preserve">
          <source>Updates the content of the 'checkpoint' file. (deprecated)</source>
          <target state="translated">checkpoint' ファイルの内容を更新します。(廃止予定)</target>
        </trans-unit>
        <trans-unit id="e27ee7c5bc27400dd7ff516cc28fe06e87e352bf" translate="yes" xml:space="preserve">
          <source>Updates the method name(s) of the SavedModel stored in the given path.</source>
          <target state="translated">指定されたパスに保存されている SavedModel のメソッド名を更新します。</target>
        </trans-unit>
        <trans-unit id="114215d83f25c29dd880192b62cf9c4d735d8aca" translate="yes" xml:space="preserve">
          <source>Updates the progress bar.</source>
          <target state="translated">プログレスバーを更新します。</target>
        </trans-unit>
        <trans-unit id="f3aa5183ae2c5fffe19c95fc5154e5548921fe2d" translate="yes" xml:space="preserve">
          <source>Updates the shape of a tensor and checks at runtime that the shape holds.</source>
          <target state="translated">テンソルの形状を更新し、実行時に形状が保持されているかどうかをチェックします。</target>
        </trans-unit>
        <trans-unit id="d45fc3ae1d9fcc9b117583faaa29b9c68525b6d1" translate="yes" xml:space="preserve">
          <source>Updates the shape of this tensor.</source>
          <target state="translated">このテンソルの形状を更新します。</target>
        </trans-unit>
        <trans-unit id="f590327e9570d8c3a01e570e103d03bfc643e1c5" translate="yes" xml:space="preserve">
          <source>Updates the table to associates keys with values.</source>
          <target state="translated">テーブルを更新し、キーと値の関連付けを行います。</target>
        </trans-unit>
        <trans-unit id="cfb5af8bff1bdbad2b00e834b01497c1e3817b80" translate="yes" xml:space="preserve">
          <source>Updates the tree ensemble by adding a layer to the last tree being grown</source>
          <target state="translated">最後に成長した木にレイヤーを追加して、木のアンサンブルを更新します。</target>
        </trans-unit>
        <trans-unit id="e6834941215f45b3c876acacc8e8c580f1e32c40" translate="yes" xml:space="preserve">
          <source>Updates the tree ensemble by either adding a layer to the last tree being grown</source>
          <target state="translated">最後に成長した木にレイヤーを追加することで、木のアンサンブルを更新します。</target>
        </trans-unit>
        <trans-unit id="dd283fb80513334be997d84fc1ce654a3740f2f1" translate="yes" xml:space="preserve">
          <source>Updates the value of the loss scale.</source>
          <target state="translated">損失スケールの値を更新します。</target>
        </trans-unit>
        <trans-unit id="56d5a06c3dd0023752b72f3ca770e1ae3effe80d" translate="yes" xml:space="preserve">
          <source>Updates this variable with the max of &lt;a href=&quot;../../indexedslices&quot;&gt;&lt;code&gt;tf.IndexedSlices&lt;/code&gt;&lt;/a&gt; and itself.</source>
          <target state="translated">この変数を&lt;a href=&quot;../../indexedslices&quot;&gt; &lt;code&gt;tf.IndexedSlices&lt;/code&gt; &lt;/a&gt;とそれ自体の最大値で更新します。</target>
        </trans-unit>
        <trans-unit id="0b0e1aa88bedb98a31d52dc0db2aabdbdc628dd2" translate="yes" xml:space="preserve">
          <source>Updates this variable with the max of &lt;a href=&quot;indexedslices&quot;&gt;&lt;code&gt;tf.IndexedSlices&lt;/code&gt;&lt;/a&gt; and itself.</source>
          <target state="translated">この変数を&lt;a href=&quot;indexedslices&quot;&gt; &lt;code&gt;tf.IndexedSlices&lt;/code&gt; &lt;/a&gt;とそれ自体の最大値で更新します。</target>
        </trans-unit>
        <trans-unit id="729d65b580f1272ed91207fc8a10aa3312f5c72c" translate="yes" xml:space="preserve">
          <source>Updates this variable with the min of &lt;a href=&quot;../../indexedslices&quot;&gt;&lt;code&gt;tf.IndexedSlices&lt;/code&gt;&lt;/a&gt; and itself.</source>
          <target state="translated">この変数を&lt;a href=&quot;../../indexedslices&quot;&gt; &lt;code&gt;tf.IndexedSlices&lt;/code&gt; &lt;/a&gt;自体の最小値で更新します。</target>
        </trans-unit>
        <trans-unit id="ee9c6cf89fa6d5d3bc7214b300a7628504d2e372" translate="yes" xml:space="preserve">
          <source>Updates this variable with the min of &lt;a href=&quot;indexedslices&quot;&gt;&lt;code&gt;tf.IndexedSlices&lt;/code&gt;&lt;/a&gt; and itself.</source>
          <target state="translated">この変数を最小値で更新します &lt;a href=&quot;indexedslices&quot;&gt; &lt;code&gt;tf.IndexedSlices&lt;/code&gt; &lt;/a&gt;自体の。</target>
        </trans-unit>
        <trans-unit id="b62b62db1c38cdd8d87bd06d704758f1b3977490" translate="yes" xml:space="preserve">
          <source>Updating and clearing custom objects using &lt;code&gt;custom_object_scope&lt;/code&gt; is preferred, but &lt;code&gt;get_custom_objects&lt;/code&gt; can be used to directly access &lt;code&gt;_GLOBAL_CUSTOM_OBJECTS&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;custom_object_scope&lt;/code&gt; を使用したカスタムオブジェクトの更新とクリアが、 &lt;code&gt;get_custom_objects&lt;/code&gt; を使用して &lt;code&gt;_GLOBAL_CUSTOM_OBJECTS&lt;/code&gt; に直接アクセスできます。</target>
        </trans-unit>
        <trans-unit id="cd72d1503f9d3fb82ce4c9572b6d9a18a62eb0ba" translate="yes" xml:space="preserve">
          <source>Updating and clearing custom objects using &lt;code&gt;custom_object_scope&lt;/code&gt; is preferred, but &lt;code&gt;get_custom_objects&lt;/code&gt; can be used to directly access the current collection of custom objects.</source>
          <target state="translated">&lt;code&gt;custom_object_scope&lt;/code&gt; を使用してカスタムオブジェクトを更新およびクリアすることをお勧めしますが、 &lt;code&gt;get_custom_objects&lt;/code&gt; を使用して、カスタムオブジェクトの現在のコレクションに直接アクセスできます。</target>
        </trans-unit>
        <trans-unit id="281cba0fb3149b6c3774ed01f37649638874e882" translate="yes" xml:space="preserve">
          <source>Upon a load, the subset of variables and assets supplied as part of the specific meta graph def, will be restored into the supplied session. The values of the variables though will correspond to the saved values from the first meta graph added to the SavedModel using &lt;code&gt;add_meta_graph_and_variables(...)&lt;/code&gt; in &lt;code&gt;builder.py&lt;/code&gt;.</source>
          <target state="translated">ロード時に、特定のメタグラフ定義の一部として提供された変数とアセットのサブセットが、提供されたセッションに復元されます。変数の値が使用SavedModelに最初に追加されたメタグラフから保存された値に対応するであろうけれども &lt;code&gt;add_meta_graph_and_variables(...)&lt;/code&gt; で &lt;code&gt;builder.py&lt;/code&gt; を。</target>
        </trans-unit>
        <trans-unit id="363a67d86f68374ba8c4a4cfbabbae29d79775ae" translate="yes" xml:space="preserve">
          <source>Upon removal from the active set, a checkpoint will be preserved if it has been at least &lt;code&gt;keep_checkpoint_every_n_hours&lt;/code&gt; since the last preserved checkpoint. The default setting of &lt;code&gt;None&lt;/code&gt; does not preserve any checkpoints in this way.</source>
          <target state="translated">アクティブセットから削除されると、最後に保存されたチェックポイントから少なくとも &lt;code&gt;keep_checkpoint_every_n_hours&lt;/code&gt; が経過している場合、チェックポイントは保存されます。デフォルト設定の &lt;code&gt;None&lt;/code&gt; は、この方法でチェックポイントを保持しません。</target>
        </trans-unit>
        <trans-unit id="3ceee3a3a486ed4178c6d9fbac07e5800c6e5b47" translate="yes" xml:space="preserve">
          <source>Upper bound on the number of partitions. Defaults to 1.</source>
          <target state="translated">パーティションの数の上限。デフォルトは1です。</target>
        </trans-unit>
        <trans-unit id="5e44dc51c175ff5c0db1e82d8dfe21d3d95479e8" translate="yes" xml:space="preserve">
          <source>Upper boundary of the output interval.</source>
          <target state="translated">出力間隔の上限。</target>
        </trans-unit>
        <trans-unit id="19aecdfa7cdf02c6ca74a44e34017ebb74fcec55" translate="yes" xml:space="preserve">
          <source>UpperBound</source>
          <target state="translated">UpperBound</target>
        </trans-unit>
        <trans-unit id="c31d78903813b3bcaeecbae756ddce1af8f35bae" translate="yes" xml:space="preserve">
          <source>Upsampling layer for 1D inputs.</source>
          <target state="translated">1D入力のアップサンプリング層。</target>
        </trans-unit>
        <trans-unit id="7b0d1a97658971e96b3f9be123da52362174eefa" translate="yes" xml:space="preserve">
          <source>Upsampling layer for 2D inputs.</source>
          <target state="translated">2D入力用のアップサンプリングレイヤ。</target>
        </trans-unit>
        <trans-unit id="d8e99e181057faa2a85bca621f7cd639c1901c16" translate="yes" xml:space="preserve">
          <source>Upsampling layer for 3D inputs.</source>
          <target state="translated">3D入力用のアップサンプリングレイヤ。</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Usage</target>
        </trans-unit>
        <trans-unit id="9629fc5be7eebf84f66a1a4fe14d7eee29fbc498" translate="yes" xml:space="preserve">
          <source>Usage Example:</source>
          <target state="translated">使用例。</target>
        </trans-unit>
        <trans-unit id="c697e1f98f6b38e0ebf986cdde5209243dc5a1fb" translate="yes" xml:space="preserve">
          <source>Usage example with &lt;a href=&quot;../mobilenet&quot;&gt;&lt;code&gt;applications.MobileNet&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;../mobilenet&quot;&gt; &lt;code&gt;applications.MobileNet&lt;/code&gt; での&lt;/a&gt;使用例：</target>
        </trans-unit>
        <trans-unit id="7878482cb2d732b2ccb44cbc91378bf291581491" translate="yes" xml:space="preserve">
          <source>Usage example with &lt;a href=&quot;../strategy&quot;&gt;&lt;code&gt;tf.distribute.Strategy&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;../strategy&quot;&gt; &lt;code&gt;tf.distribute.Strategy&lt;/code&gt; を&lt;/a&gt;使用した使用例：</target>
        </trans-unit>
        <trans-unit id="b925d1a88d8e7cc54989fe4e8d7270088645c5c3" translate="yes" xml:space="preserve">
          <source>Usage example with tf.distribute.Strategy:</source>
          <target state="translated">tf.distribute.Strategyでの使用例。</target>
        </trans-unit>
        <trans-unit id="fec43ce445f974147bd0eb223a50147e7fb7202d" translate="yes" xml:space="preserve">
          <source>Usage example:</source>
          <target state="translated">使用例。</target>
        </trans-unit>
        <trans-unit id="77817d0a0c43f5e8811381e684f28870ad0caaef" translate="yes" xml:space="preserve">
          <source>Usage in a &lt;a href=&quot;function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;function&quot;&gt; &lt;code&gt;tf.function&lt;/code&gt; での&lt;/a&gt;使用：</target>
        </trans-unit>
        <trans-unit id="801e743874a5f137b8515158c4ad1c682d3d5c9a" translate="yes" xml:space="preserve">
          <source>Usage in a functional model:</source>
          <target state="translated">機能モデルでの使用法。</target>
        </trans-unit>
        <trans-unit id="f55d9b06976fb1e7cdaee8fa9d5e54cd7e87ed03" translate="yes" xml:space="preserve">
          <source>Usage in custom training loops</source>
          <target state="translated">カスタムトレーニングループでの使用法</target>
        </trans-unit>
        <trans-unit id="f7229b161af4f523b13ed9ebb0ca67db64df129d" translate="yes" xml:space="preserve">
          <source>Usage with &lt;code&gt;compile()&lt;/code&gt; API:</source>
          <target state="translated">&lt;code&gt;compile()&lt;/code&gt; APIでの使用法：</target>
        </trans-unit>
        <trans-unit id="e990e47405f0ff9e5047d2be7faad8352983c3d7" translate="yes" xml:space="preserve">
          <source>Usage with a canned estimator:</source>
          <target state="translated">缶詰の見積書を使った使い方</target>
        </trans-unit>
        <trans-unit id="b7f68eccfb39ab6d5044b1fe94d8202e173daf81" translate="yes" xml:space="preserve">
          <source>Usage with distribution strategy and custom training loop:</source>
          <target state="translated">ディストリビューション戦略やカスタムトレーニングループとの併用</target>
        </trans-unit>
        <trans-unit id="e394973fc15ca8e6a0ab7b5e15b6537c110fcd61" translate="yes" xml:space="preserve">
          <source>Usage with tf.keras API:</source>
          <target state="translated">tf.keras APIでの使用法。</target>
        </trans-unit>
        <trans-unit id="b672bfd407587ac4347c7d14f539f0167c943965" translate="yes" xml:space="preserve">
          <source>Usage with the &lt;a href=&quot;../../keras&quot;&gt;&lt;code&gt;tf.keras&lt;/code&gt;&lt;/a&gt; API:</source>
          <target state="translated">使用法&lt;a href=&quot;../../keras&quot;&gt; &lt;code&gt;tf.keras&lt;/code&gt; の&lt;/a&gt; API：</target>
        </trans-unit>
        <trans-unit id="96ba7c58b31b72cda1421876078e636d93a95906" translate="yes" xml:space="preserve">
          <source>Usage with the &lt;code&gt;compile()&lt;/code&gt; API:</source>
          <target state="translated">&lt;code&gt;compile()&lt;/code&gt; APIでの使用法：</target>
        </trans-unit>
        <trans-unit id="c3a64fc9df2f2b5aa9b2b0f2f696a9fa962d415a" translate="yes" xml:space="preserve">
          <source>Usage with the &lt;code&gt;compile&lt;/code&gt; API:</source>
          <target state="translated">使用方法 &lt;code&gt;compile&lt;/code&gt; API：</target>
        </trans-unit>
        <trans-unit id="861a0e430ffac5e4ae6e11b7a947f2c32d388cf4" translate="yes" xml:space="preserve">
          <source>Usage:</source>
          <target state="translated">Usage:</target>
        </trans-unit>
        <trans-unit id="030e432f7e4bb780778d21710d19d27e9dde09e7" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;../keras/models/load_model&quot;&gt;&lt;code&gt;tf.keras.models.load_model&lt;/code&gt;&lt;/a&gt; to restore the Keras model.</source>
          <target state="translated">使用する &lt;a href=&quot;../keras/models/load_model&quot;&gt; &lt;code&gt;tf.keras.models.load_model&lt;/code&gt; &lt;/a&gt;を Kerasモデルを復元します。</target>
        </trans-unit>
        <trans-unit id="d4c2fa90899bd40eef81dcc968f1e443a9a43ef7" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;global_variables&quot;&gt;&lt;code&gt;tf.compat.v1.global_variables&lt;/code&gt;&lt;/a&gt; instead. (deprecated)</source>
          <target state="translated">使用する &lt;a href=&quot;global_variables&quot;&gt; &lt;code&gt;tf.compat.v1.global_variables&lt;/code&gt; &lt;/a&gt;代わりに tf.compat.v1.global_variablesを。（非推奨）</target>
        </trans-unit>
        <trans-unit id="3209823decab9f9b116ef0a97be20eccaaae6362" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;strategy#experimental_distribute_dataset&quot;&gt;&lt;code&gt;tf.distribute.Strategy.experimental_distribute_dataset&lt;/code&gt;&lt;/a&gt; to convert a &lt;a href=&quot;../data/dataset&quot;&gt;&lt;code&gt;tf.data.Dataset&lt;/code&gt;&lt;/a&gt; to something that produces &quot;per-replica&quot; values. If you want to manually specify how the dataset should be partitioned across replicas, use &lt;a href=&quot;strategy#experimental_distribute_datasets_from_function&quot;&gt;&lt;code&gt;tf.distribute.Strategy.experimental_distribute_datasets_from_function&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">使用&lt;a href=&quot;strategy#experimental_distribute_dataset&quot;&gt; &lt;code&gt;tf.distribute.Strategy.experimental_distribute_dataset&lt;/code&gt; &lt;/a&gt;変換する&lt;a href=&quot;../data/dataset&quot;&gt; &lt;code&gt;tf.data.Dataset&lt;/code&gt; を&lt;/a&gt;「毎のレプリカ」値を生成するものに。レプリカ間でデータセットを分割する方法を手動で指定する場合は、次を使用します。&lt;a href=&quot;strategy#experimental_distribute_datasets_from_function&quot;&gt; &lt;code&gt;tf.distribute.Strategy.experimental_distribute_datasets_from_function&lt;/code&gt; &lt;/a&gt;代わりに tf.distribute.Strategy.experimental_distribute_datasets_from_functionをください。</target>
        </trans-unit>
        <trans-unit id="8ee5b2fdcd82632d020da9ff566a06840585c6ea" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;strategy#experimental_run_v2&quot;&gt;&lt;code&gt;tf.distribute.Strategy.experimental_run_v2&lt;/code&gt;&lt;/a&gt; to run a function once per replica, taking values that may be &quot;per-replica&quot; (e.g. from a distributed dataset) and returning &quot;per-replica&quot; values. This function is executed in &quot;replica context&quot;, which means each operation is performed separately on each replica.</source>
          <target state="translated">使用する &lt;a href=&quot;strategy#experimental_run_v2&quot;&gt; &lt;code&gt;tf.distribute.Strategy.experimental_run_v2&lt;/code&gt; &lt;/a&gt;をして、レプリカごとに1回関数を実行し、「レプリカごと」の値を（たとえば、分散データセットから）取り、「レプリカごと」の値を返します。この機能は「レプリカコンテキスト」で実行されます。つまり、各操作は各レプリカで個別に実行されます。</target>
        </trans-unit>
        <trans-unit id="d62a49dd6dc46f4c7a9acf5f4db7938f8cbc782e" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;strategy#run&quot;&gt;&lt;code&gt;tf.distribute.Strategy.run&lt;/code&gt;&lt;/a&gt; to run a function once per replica, taking values that may be &quot;per-replica&quot; (e.g. from a &lt;a href=&quot;distributeddataset&quot;&gt;&lt;code&gt;tf.distribute.DistributedDataset&lt;/code&gt;&lt;/a&gt; object) and returning &quot;per-replica&quot; values. This function is executed in &quot;replica context&quot;, which means each operation is performed separately on each replica.</source>
          <target state="translated">&lt;a href=&quot;strategy#run&quot;&gt; &lt;code&gt;tf.distribute.Strategy.run&lt;/code&gt; &lt;/a&gt;を使用して、レプリカごとに1回関数を実行し、「レプリカごと」の値を取得して（たとえば、&lt;a href=&quot;distributeddataset&quot;&gt; &lt;code&gt;tf.distribute.DistributedDataset&lt;/code&gt; &lt;/a&gt;オブジェクトから）、「レプリカごと」の値を返します。この機能は「レプリカコンテキスト」で実行されます。つまり、各操作は各レプリカで個別に実行されます。</target>
        </trans-unit>
        <trans-unit id="b44531c2feeada9ccb9c2de903665876111434ff" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;__floordiv__&lt;/code&gt; via &lt;code&gt;x // y&lt;/code&gt; instead.</source>
          <target state="translated">を介して &lt;code&gt;__floordiv__&lt;/code&gt; を使用 &lt;code&gt;x // y&lt;/code&gt; 代わりに、x // y。</target>
        </trans-unit>
        <trans-unit id="2767ed64c3817a4622daa8e917be1f662fce734c" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;as_numpy_iterator&lt;/code&gt; to inspect the content of your dataset. To see element shapes and types, print dataset elements directly instead of using &lt;code&gt;as_numpy_iterator&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;as_numpy_iterator&lt;/code&gt; を使用して、データセットのコンテンツを検査します。要素の形状とタイプを確認するには、使用せずにデータセット要素を直接印刷します &lt;code&gt;as_numpy_iterator&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="e94740ffc34912a09c1d4271d0d2a19f29965942" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;distribution&lt;/code&gt; to create a linear combination of &lt;code&gt;value&lt;/code&gt; with shape &lt;code&gt;[batch_size, Tq, dim]&lt;/code&gt;: &lt;code&gt;return tf.matmul(distribution, value)&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;distribution&lt;/code&gt; の線形結合作成する &lt;code&gt;value&lt;/code&gt; 形状で &lt;code&gt;[batch_size, Tq, dim]&lt;/code&gt; ： &lt;code&gt;return tf.matmul(distribution, value)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5eb34124b3d3c72e61b1960b8b0273621cb17166" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;distribution&lt;/code&gt; to create a linear combination of &lt;code&gt;value&lt;/code&gt; with shape &lt;code&gt;batch_size, Tq, dim]&lt;/code&gt;: &lt;code&gt;return tf.matmul(distribution, value)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;distribution&lt;/code&gt; を使用して、形状と &lt;code&gt;value&lt;/code&gt; 線形結合を作成します &lt;code&gt;return tf.matmul(distribution, value)&lt;/code&gt; &lt;code&gt;batch_size, Tq, dim]&lt;/code&gt; ：tf.matmul（distribution、value）を返します。</target>
        </trans-unit>
        <trans-unit id="44e30be08758ea8ade80932cd95cdb8d64bb47a8" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;flat_map&lt;/code&gt; if you want to make sure that the order of your dataset stays the same. For example, to flatten a dataset of batches into a dataset of their elements:</source>
          <target state="translated">データセットの順序が &lt;code&gt;flat_map&lt;/code&gt; ないようにする場合は、flat_mapを使用します。たとえば、バッチのデータセットを要素のデータセットにフラット化するには：</target>
        </trans-unit>
        <trans-unit id="7a992c4c721de761461c5374c7bd3a4aff948363" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;get_slot_names()&lt;/code&gt; to get the list of slot names created by the &lt;code&gt;Optimizer&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Optimizer&lt;/code&gt; によって作成されたスロット名のリストを取得するには、 &lt;code&gt;get_slot_names()&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="91f7ee28a1020db4d8680f6cfcc039630f6cf6c7" translate="yes" xml:space="preserve">
          <source>Use Keras-style variable management.</source>
          <target state="translated">Kerasスタイルの変数管理を使用します。</target>
        </trans-unit>
        <trans-unit id="440e973c7f91d2791a9db2a23271859d554779a3" translate="yes" xml:space="preserve">
          <source>Use QuantizeAndDequantizeV2 instead.</source>
          <target state="translated">代わりに QuantizeAndDequantizeV2 を使用してください。</target>
        </trans-unit>
        <trans-unit id="c72ad8c259b53b87feb4b811bfb9903790a506c0" translate="yes" xml:space="preserve">
          <source>Use RandomPoissonV2 instead.</source>
          <target state="translated">代わりにRandomPoissonV2を使用してください。</target>
        </trans-unit>
        <trans-unit id="2150f7b0818a8c9614aab9559af6a58afcb70753" translate="yes" xml:space="preserve">
          <source>Use VariableV2 instead.</source>
          <target state="translated">代わりに VariableV2 を使用してください。</target>
        </trans-unit>
        <trans-unit id="9643c07a64899011c5e66444b786696c2c1f292c" translate="yes" xml:space="preserve">
          <source>Use a GPU</source>
          <target state="translated">GPUを使用する</target>
        </trans-unit>
        <trans-unit id="0ef12200042309c3ec0320c88bb43b5872439b7c" translate="yes" xml:space="preserve">
          <source>Use a TPU</source>
          <target state="translated">TPU を使用して下さい</target>
        </trans-unit>
        <trans-unit id="55e615040b350f7d0e69b2efeab665769ae7dff0" translate="yes" xml:space="preserve">
          <source>Use cached_session instead. (deprecated)</source>
          <target state="translated">代わりに cached_session を使用してください。(廃止予定)</target>
        </trans-unit>
        <trans-unit id="a45a7fcfd0c3a826284614faab211360451f5baa" translate="yes" xml:space="preserve">
          <source>Use control flow v2.</source>
          <target state="translated">制御フローv2を使用します。</target>
        </trans-unit>
        <trans-unit id="370035f7e921eeac90f213974c56e368a0053937" translate="yes" xml:space="preserve">
          <source>Use for a single program</source>
          <target state="translated">単一のプログラムに使用する</target>
        </trans-unit>
        <trans-unit id="f43fa9092b2f91bd555938c5ea3e365d94b5e8be" translate="yes" xml:space="preserve">
          <source>Use for multiple replicas</source>
          <target state="translated">複数のレプリカに使用</target>
        </trans-unit>
        <trans-unit id="475c1ea44e2680d527418552a01d0d387b8889b0" translate="yes" xml:space="preserve">
          <source>Use is_tensor to differentiate types that can ingested by TensorFlow ops without any conversion (e.g., &lt;a href=&quot;tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;sparse/sparsetensor&quot;&gt;&lt;code&gt;tf.SparseTensor&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;raggedtensor&quot;&gt;&lt;code&gt;tf.RaggedTensor&lt;/code&gt;&lt;/a&gt;) from types that need to be converted into tensors before they are ingested (e.g., numpy &lt;code&gt;ndarray&lt;/code&gt; and Python scalars).</source>
          <target state="translated">is_tensorを使用して、変換せずにTensorFlow opsによって取り込むことができるタイプ（&lt;a href=&quot;tensor&quot;&gt; &lt;code&gt;tf.Tensor&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;sparse/sparsetensor&quot;&gt; &lt;code&gt;tf.SparseTensor&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;raggedtensor&quot;&gt; &lt;code&gt;tf.RaggedTensor&lt;/code&gt; など&lt;/a&gt;）と、取り込む前にテンソルに変換する必要があるタイプ（numpy &lt;code&gt;ndarray&lt;/code&gt; やPythonなど）を区別します。スカラー）。</target>
        </trans-unit>
        <trans-unit id="1492e12db8287cba745968988a12ad01c3a722bf" translate="yes" xml:space="preserve">
          <source>Use lazy Adam instead of Adam. Lazy Adam trains faster.</source>
          <target state="translated">アダムの代わりに怠け者のアダムを使いましょう。怠け者のアダムの方がトレーニングが早い。</target>
        </trans-unit>
        <trans-unit id="8bb5bf2a72112cde73c306a36e21803143fe65db" translate="yes" xml:space="preserve">
          <source>Use lazy Adam instead of Adam. Lazy Adam trains faster. Please see &lt;code&gt;optimization_parameters.proto&lt;/code&gt; for details.</source>
          <target state="translated">アダムの代わりに怠惰なアダムを使用してください。怠惰なアダムはより速く訓練します。詳細については、 &lt;code&gt;optimization_parameters.proto&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="8399a93fbe608ceae7467ffa9f4443f49ecb43c5" translate="yes" xml:space="preserve">
          <source>Use regexes=[''] for a regex that will always pass.</source>
          <target state="translated">常に通過する正規表現にはregexes=['']を使用します。</target>
        </trans-unit>
        <trans-unit id="89fcdf03d75c5035154abf603c2a5d6a8e7923ee" translate="yes" xml:space="preserve">
          <source>Use scores to calculate a distribution with shape &lt;code&gt;[batch_size, Tq, Tv]&lt;/code&gt;: &lt;code&gt;distribution = tf.nn.softmax(scores)&lt;/code&gt;.</source>
          <target state="translated">スコアを使用して、形状が &lt;code&gt;[batch_size, Tq, Tv]&lt;/code&gt; 分布を計算します： &lt;code&gt;distribution = tf.nn.softmax(scores)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="434fa6ee48f96c719d58baf9d88af78b48a7c5de" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;use_gpu&lt;/code&gt; and &lt;code&gt;force_gpu&lt;/code&gt; options to control where ops are run. If &lt;code&gt;force_gpu&lt;/code&gt; is True, all ops are pinned to &lt;code&gt;/device:GPU:0&lt;/code&gt;. Otherwise, if &lt;code&gt;use_gpu&lt;/code&gt; is True, TensorFlow tries to run as many ops on the GPU as possible. If both &lt;code&gt;force_gpu and&lt;/code&gt;use_gpu` are False, all ops are pinned to the CPU.</source>
          <target state="translated">&lt;code&gt;use_gpu&lt;/code&gt; および &lt;code&gt;force_gpu&lt;/code&gt; オプションを使用して、操作の実行場所を制御します。 &lt;code&gt;force_gpu&lt;/code&gt; がTrueの場合、すべての操作が &lt;code&gt;/device:GPU:0&lt;/code&gt; に固定されます。それ以外の場合、 &lt;code&gt;use_gpu&lt;/code&gt; がTrueの場合、TensorFlowはGPUで可能な限り多くの演算を実行しようとします。両方の場合 &lt;code&gt;force_gpu and&lt;/code&gt; use_gpu`のがFalseの場合、すべての操作がCPUに固定されます。</target>
        </trans-unit>
        <trans-unit id="af3eb58bfa11b2e816bf06bf154e9dd3eaba2e36" translate="yes" xml:space="preserve">
          <source>Use the adjoint of A in the matrix multiply. If A is complex, this is transpose(conj(A)). Otherwise it's transpose(A).</source>
          <target state="translated">行列の乗算でAのアドジョイントを使います。A が複素数の場合、これは転置(conj(A))です。それ以外の場合は転置(A)です。</target>
        </trans-unit>
        <trans-unit id="b81ee9831f55618dc71b894972452125c1c0e087" translate="yes" xml:space="preserve">
          <source>Use the adjoint of B in the matrix multiply. If B is complex, this is transpose(conj(B)). Otherwise it's transpose(B).</source>
          <target state="translated">行列の乗算でBのアドジョイントを使います。B が複素数の場合、これは転置(conj(B))です。そうでなければ転置(B)です。</target>
        </trans-unit>
        <trans-unit id="dd23d3f693402848b5c571179d734fa24d293240" translate="yes" xml:space="preserve">
          <source>Use the flag on the command line multiple times to place multiple enum values into the list.</source>
          <target state="translated">コマンドラインのフラグを複数回使用して、複数のenum値をリストに配置します。</target>
        </trans-unit>
        <trans-unit id="d2ec95228b5df088b9e12de695d7a5b48f073d13" translate="yes" xml:space="preserve">
          <source>Use the flag on the command line multiple times to place multiple enum values into the list. The 'default' may be a single string (which will be converted into a single-element list) or a list of strings.</source>
          <target state="translated">コマンドラインのフラグを複数回使用して、複数のenum値をリストに配置します。デフォルト」は単一の文字列 (単一要素のリストに変換されます)または文字列のリストです。</target>
        </trans-unit>
        <trans-unit id="7cd854f1deb653ced29c38efa8b46ec0bd203ec8" translate="yes" xml:space="preserve">
          <source>Use the flag on the command line multiple times to place multiple float values into the list. The 'default' may be a single float (which will be converted into a single-element list) or a list of floats.</source>
          <target state="translated">コマンドラインのフラグを複数回使用して、複数のフロート値をリストに配置します。デフォルト」は、単一の float (単一要素のリストに変換されます)または float のリストになります。</target>
        </trans-unit>
        <trans-unit id="0ba777030d82e3febc7f170821e4862f2ace63cd" translate="yes" xml:space="preserve">
          <source>Use the flag on the command line multiple times to place multiple integer values into the list. The 'default' may be a single integer (which will be converted into a single-element list) or a list of integers.</source>
          <target state="translated">複数の整数値をリストに入れるには、コマンドラインのフラグを複数回使用します。デフォルト」は単一の整数 (単一要素のリストに変換されます)か整数のリストになります。</target>
        </trans-unit>
        <trans-unit id="b36c5e7734d6891179ff0616c0be42883b3178af" translate="yes" xml:space="preserve">
          <source>Use the flag on the command line multiple times to place multiple string values into the list. The 'default' may be a single string (which will be converted into a single-element list) or a list of strings.</source>
          <target state="translated">複数の文字列値をリストに入れるには、コマンドラインのフラグを複数回使用します。デフォルト」は単一の文字列 (単一要素のリストに変換されます)または文字列のリストです。</target>
        </trans-unit>
        <trans-unit id="d3dd2345ae786232011837f1b50ba242eb1986f2" translate="yes" xml:space="preserve">
          <source>Use this cross-entropy loss when there are only two label classes (assumed to be 0 and 1). For each example, there should be a single floating-point value per prediction.</source>
          <target state="translated">ラベルクラスが2つしかない場合(0と1と仮定)、このクロスエントロピー損失を使用します。各例では、予測ごとに1つの浮動小数点値があるはずです。</target>
        </trans-unit>
        <trans-unit id="cea461fc9af427f5cd3544343b029f1c2bab9d0b" translate="yes" xml:space="preserve">
          <source>Use this crossentropy loss function when there are two or more label classes. We expect labels to be provided as integers. If you want to provide labels using &lt;code&gt;one-hot&lt;/code&gt; representation, please use &lt;code&gt;CategoricalCrossentropy&lt;/code&gt; loss. There should be &lt;code&gt;# classes&lt;/code&gt; floating point values per feature for &lt;code&gt;y_pred&lt;/code&gt; and a single floating point value per feature for &lt;code&gt;y_true&lt;/code&gt;.</source>
          <target state="translated">2つ以上のラベルクラスがある場合は、このクロスエントロピー損失関数を使用します。ラベルは整数として提供されることを期待しています。 &lt;code&gt;one-hot&lt;/code&gt; 表現を使用してラベルを提供する場合は、 &lt;code&gt;CategoricalCrossentropy&lt;/code&gt; 損失を使用してください。あるはず &lt;code&gt;# classes&lt;/code&gt; のための機能ごとに浮動小数点値を &lt;code&gt;y_pred&lt;/code&gt; とのための機能ごとに単一の浮動小数点値 &lt;code&gt;y_true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="78d33f54d7ac855026c26bfd507ca58a0c209d64" translate="yes" xml:space="preserve">
          <source>Use this crossentropy loss function when there are two or more label classes. We expect labels to be provided in a &lt;code&gt;one_hot&lt;/code&gt; representation. If you want to provide labels as integers, please use &lt;code&gt;SparseCategoricalCrossentropy&lt;/code&gt; loss. There should be &lt;code&gt;# classes&lt;/code&gt; floating point values per feature.</source>
          <target state="translated">2つ以上のラベルクラスがある場合は、このクロスエントロピー損失関数を使用します。ラベルは &lt;code&gt;one_hot&lt;/code&gt; 表現で提供されることを期待しています。ラベルを整数として提供する場合は、 &lt;code&gt;SparseCategoricalCrossentropy&lt;/code&gt; 損失を使用してください。機能ごとに &lt;code&gt;# classes&lt;/code&gt; 浮動小数点値が必要です。</target>
        </trans-unit>
        <trans-unit id="5c6c9c3f9fd66d91bb804a873975c909932a10ca" translate="yes" xml:space="preserve">
          <source>Use this crossentropy metric when there are two or more label classes. We expect labels to be provided as integers. If you want to provide labels using &lt;code&gt;one-hot&lt;/code&gt; representation, please use &lt;code&gt;CategoricalCrossentropy&lt;/code&gt; metric. There should be &lt;code&gt;# classes&lt;/code&gt; floating point values per feature for &lt;code&gt;y_pred&lt;/code&gt; and a single floating point value per feature for &lt;code&gt;y_true&lt;/code&gt;.</source>
          <target state="translated">2つ以上のラベルクラスがある場合、このクロスエントロピーメトリックを使用します。ラベルは整数として提供されることを期待しています。 &lt;code&gt;one-hot&lt;/code&gt; 表現を使用してラベルを提供する場合は、 &lt;code&gt;CategoricalCrossentropy&lt;/code&gt; メトリックを使用してください。あるはず &lt;code&gt;# classes&lt;/code&gt; のための機能ごとに浮動小数点値を &lt;code&gt;y_pred&lt;/code&gt; とのための機能ごとに単一の浮動小数点値 &lt;code&gt;y_true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2d8dc9e6eb45eed6afcf79258afbec19d798dabb" translate="yes" xml:space="preserve">
          <source>Use this function in place of &lt;a href=&quot;../../../../feature_column/embedding_column&quot;&gt;&lt;code&gt;tf.compat.v1.feature_column.embedding_column&lt;/code&gt;&lt;/a&gt; when you want to use the TPU to accelerate your embedding lookups via TPU embeddings.</source>
          <target state="translated">この関数を&lt;a href=&quot;../../../../feature_column/embedding_column&quot;&gt; &lt;code&gt;tf.compat.v1.feature_column.embedding_column&lt;/code&gt; の&lt;/a&gt;代わりに使用しますTPUを使用してTPU埋め込みによる埋め込みルックアップを高速化する場合を使用します。</target>
        </trans-unit>
        <trans-unit id="3cc5d4e2629c110ebe8857052924d43b36a33d1a" translate="yes" xml:space="preserve">
          <source>Use this function in place of tf.compat.v1.feature_column.shared_embedding_columns` when you want to use the TPU to accelerate your embedding lookups via TPU embeddings.</source>
          <target state="translated">TPUを使用してTPUエンベッディングによるエンベッディングルックアップを高速化したい場合に、この関数をtf.compat.v1.feature_column.shared_embedding_columns`の代わりに使用します。</target>
        </trans-unit>
        <trans-unit id="e33c1dd0300e16f424a91617a667c9261bc9be4c" translate="yes" xml:space="preserve">
          <source>Use this function to prevent regularization of variables.</source>
          <target state="translated">変数の正規化を防ぐためにこの関数を使用します。</target>
        </trans-unit>
        <trans-unit id="9622b2273be64542684f76f86eb661f385ac65c8" translate="yes" xml:space="preserve">
          <source>Use this function to wrap any op, maintaining its behavior in the forward pass, but replacing the original op in the backward graph with an identity. For example:</source>
          <target state="translated">この関数を使って任意のopをラップし,前方パスでの動作を維持しつつ,後方グラフの元のopをIDに置き換えます.例えば以下のようになります。</target>
        </trans-unit>
        <trans-unit id="fe53876e652ed0ef4c2e62692c0a8476320563f1" translate="yes" xml:space="preserve">
          <source>Use this interface if you need to provide a custom loss/head. For example, the following will be equivalent to using BoostedTreesRegressor</source>
          <target state="translated">カスタムロス/ヘッドを提供する必要がある場合は、このインターフェイスを使用します。例えば、以下はBoostedTreesRegressorを使用するのと同等のものになります。</target>
        </trans-unit>
        <trans-unit id="1fc9a09a598f08be35c9b3e469cc86fb8ef5c5c8" translate="yes" xml:space="preserve">
          <source>Use this method with the &lt;code&gt;with&lt;/code&gt; keyword to specify that ops created within the scope of a block should be added to this graph. In this case, once the scope of the &lt;code&gt;with&lt;/code&gt; is exited, the previous default graph is set again as default. There is a stack, so it's ok to have multiple nested levels of &lt;code&gt;as_default&lt;/code&gt; calls.</source>
          <target state="translated">このメソッドを &lt;code&gt;with&lt;/code&gt; キーワードと共に使用して、ブロックのスコープ内で作成されたopsをこのグラフに追加する必要があることを指定します。この場合、 &lt;code&gt;with&lt;/code&gt; のスコープが終了すると、以前のデフォルトのグラフがデフォルトとして再び設定されます。スタックがあるので、複数のネストされたレベルの &lt;code&gt;as_default&lt;/code&gt; 呼び出しがあっても問題ありません。</target>
        </trans-unit>
        <trans-unit id="1cb0006ae0bc4a4d2c6cc55d9288fc8e40392087" translate="yes" xml:space="preserve">
          <source>Use this transformation to produce a dataset that contains one instance of each unique element in the input. For example:</source>
          <target state="translated">この変換を使用して,入力内の一意な要素の各インスタンスを含むデータセットを生成します.例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="c1ae07580001407b54ea6c15a5ff62a49d8bc47c" translate="yes" xml:space="preserve">
          <source>Use this transformation to produce a dataset that contains the same elements as the input, but silently drops any elements that caused an error. For example:</source>
          <target state="translated">この変換を利用して,入力と同じ要素を含むが,エラーの原因となった要素を静かに削除するデータセットを作成します.例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="0ecb994c8af6ea20690f2149dd63292f77fb37b5" translate="yes" xml:space="preserve">
          <source>Use this when each of your sparse inputs has both an ID and a value. For example, if you're representing text documents as a collection of word frequencies, you can provide 2 parallel sparse input features ('terms' and 'frequencies' below).</source>
          <target state="translated">これは、それぞれの疎な入力が ID と値の両方を持つ場合に使用します。例えば、テキスト文書を単語の度数の集合として表現する場合、2つの並列スパース入力特徴('term' と 'frequencies' 以下)を提供することができます。</target>
        </trans-unit>
        <trans-unit id="579c3daf1696275881a685fed877b2bca49537c7" translate="yes" xml:space="preserve">
          <source>Use this when the caller knows that this FlagValues has been parsed as if a &lt;strong&gt;call&lt;/strong&gt;() invocation has happened. This is only a public method for use by things like appcommands which do additional command like parsing.</source>
          <target state="translated">呼び出し側がこのFlagValuesが解析されたことを&lt;strong&gt;呼び出し&lt;/strong&gt;（）呼び出しが行われたかの&lt;strong&gt;ように&lt;/strong&gt;知っている場合に使用します。これは、解析などの追加コマンドを実行するappcommandsなどで使用するためのパブリックメソッドにすぎません。</target>
        </trans-unit>
        <trans-unit id="f2352dd0c45545d0dddd83edf7a87ae1c7d6a2a5" translate="yes" xml:space="preserve">
          <source>Use this when your inputs are in string or integer format, and you have a vocabulary file that maps each value to an integer ID. By default, out-of-vocabulary values are ignored. Use either (but not both) of &lt;code&gt;num_oov_buckets&lt;/code&gt; and &lt;code&gt;default_value&lt;/code&gt; to specify how to include out-of-vocabulary values.</source>
          <target state="translated">入力が文字列または整数形式であり、各値を整数IDにマップする語彙ファイルがある場合に、これを使用します。デフォルトでは、語彙外の値は無視されます。 &lt;code&gt;num_oov_buckets&lt;/code&gt; と &lt;code&gt;default_value&lt;/code&gt; のどちらか（両方ではない）を使用して、語彙外の値を含める方法を指定します。</target>
        </trans-unit>
        <trans-unit id="ebfbbc24af8cd5c1b3325ddc7e9b9110d158077e" translate="yes" xml:space="preserve">
          <source>Use this when your inputs are in string or integer format, and you have an in-memory vocabulary mapping each value to an integer ID. By default, out-of-vocabulary values are ignored. Use either (but not both) of &lt;code&gt;num_oov_buckets&lt;/code&gt; and &lt;code&gt;default_value&lt;/code&gt; to specify how to include out-of-vocabulary values.</source>
          <target state="translated">入力が文字列または整数形式で、各値を整数IDにマッピングするメモリ内ボキャブラリがある場合に、これを使用します。デフォルトでは、語彙外の値は無視されます。 &lt;code&gt;num_oov_buckets&lt;/code&gt; と &lt;code&gt;default_value&lt;/code&gt; のどちらか（両方ではない）を使用して、語彙外の値を含める方法を指定します。</target>
        </trans-unit>
        <trans-unit id="5c2d5c81b6b22ab6aebbd8420d0922e66fb231ec" translate="yes" xml:space="preserve">
          <source>Use this when your inputs are integers in the range &lt;code&gt;[0, num_buckets)&lt;/code&gt;, and you want to use the input value itself as the categorical ID. Values outside this range will result in &lt;code&gt;default_value&lt;/code&gt; if specified, otherwise it will fail.</source>
          <target state="translated">これは、入力が &lt;code&gt;[0, num_buckets)&lt;/code&gt; 範囲の整数であり、入力値自体をカテゴリIDとして使用する場合に使用します。この範囲外の値は、指定されている場合は &lt;code&gt;default_value&lt;/code&gt; となり、そうでない場合は失敗します。</target>
        </trans-unit>
        <trans-unit id="be55e7e6d26bbf4b36ff797d2545265b0a6866e3" translate="yes" xml:space="preserve">
          <source>Use this when your inputs are sparse and of the same type (e.g. watched and impression video IDs that share the same vocabulary), and you want to convert them to a dense representation (e.g., to feed to a DNN).</source>
          <target state="translated">入力がスパースで同じタイプのもの(例えば、同じ語彙を共有する視聴動画とインプレッション動画のIDなど)で、それらを密な表現に変換したい場合に使用します(例:DNNへのフィード)。</target>
        </trans-unit>
        <trans-unit id="ce58da03135c2b5ad93ed7aa78fffe6ae161dd6d" translate="yes" xml:space="preserve">
          <source>Use this when your inputs are sparse, but you want to convert them to a dense representation (e.g., to feed to a DNN).</source>
          <target state="translated">入力が疎であるが、密な表現に変換したい場合に使用します(例:DNNへのフィード)。</target>
        </trans-unit>
        <trans-unit id="c980245437253028d09a527c56663fc1386fb381" translate="yes" xml:space="preserve">
          <source>Use this when your sparse features are in string or integer format, and you want to distribute your inputs into a finite number of buckets by hashing. output_id = Hash(input_feature_string) % bucket_size for string type input. For int type input, the value is converted to its string representation first and then hashed by the same formula.</source>
          <target state="translated">疎な特徴量が文字列または整数形式であり、入力をハッシュ化して有限のバケットに分散させたい場合に使用します。 output_id=Hash(input_feature_string)% 文字列型の入力の場合は、バケットサイズを指定します。int型の入力の場合、値は最初に文字列表現に変換され、同じ式でハッシュ化されます。</target>
        </trans-unit>
        <trans-unit id="610337110a51eaf727f0158c31e03e81c30df87c" translate="yes" xml:space="preserve">
          <source>Use with &lt;a href=&quot;../../distribute/strategy&quot;&gt;&lt;code&gt;tf.distribute.Strategy&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../../distribute/strategy&quot;&gt; &lt;code&gt;tf.distribute.Strategy&lt;/code&gt; &lt;/a&gt;と一緒に使用</target>
        </trans-unit>
        <trans-unit id="a0594027b100d87bb5949b9d94aec04e20184fe6" translate="yes" xml:space="preserve">
          <source>Use with &lt;a href=&quot;../../distribute/strategy&quot;&gt;&lt;code&gt;tf.distribute.Strategy&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../distribute/strategy&quot;&gt; &lt;code&gt;tf.distribute.Strategy&lt;/code&gt; で&lt;/a&gt;使用します。</target>
        </trans-unit>
        <trans-unit id="7b2a8e4ff6f36d2ae408104e160d5b3b9371d34a" translate="yes" xml:space="preserve">
          <source>Use with the &lt;code&gt;with&lt;/code&gt; keyword to specify that all operations constructed within the context should have control dependencies on &lt;code&gt;control_inputs&lt;/code&gt;. For example:</source>
          <target state="translated">&lt;code&gt;with&lt;/code&gt; キーワードと共に使用して、コンテキスト内で構築されたすべての操作が &lt;code&gt;control_inputs&lt;/code&gt; に対する制御依存関係を持つ必要があることを指定します。例えば：</target>
        </trans-unit>
        <trans-unit id="69dd6dc7e65c4b9fe7cd1454b69ad4047ff65a5d" translate="yes" xml:space="preserve">
          <source>Use with the &lt;code&gt;with&lt;/code&gt; keyword to specify that calls to &lt;a href=&quot;../../operation#run&quot;&gt;&lt;code&gt;tf.Operation.run&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../tensor#eval&quot;&gt;&lt;code&gt;tf.Tensor.eval&lt;/code&gt;&lt;/a&gt; should be executed in this session.</source>
          <target state="translated">&lt;code&gt;with&lt;/code&gt; キーワードとともに使用して、このセッションで&lt;a href=&quot;../../operation#run&quot;&gt; &lt;code&gt;tf.Operation.run&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;../../tensor#eval&quot;&gt; &lt;code&gt;tf.Tensor.eval&lt;/code&gt; の&lt;/a&gt;呼び出しを実行するように指定します。</target>
        </trans-unit>
        <trans-unit id="fefa29789a427f39795cb49ac3d13889fa028342" translate="yes" xml:space="preserve">
          <source>Used as the &lt;code&gt;_options&lt;/code&gt; argument to the &lt;code&gt;tf.Checkpoint&lt;/code&gt; constructor to adjust how variables are saved.</source>
          <target state="translated">&lt;code&gt;tf.Checkpoint&lt;/code&gt; コンストラクターの &lt;code&gt;_options&lt;/code&gt; 引数として使用され、変数の保存方法を調整します。</target>
        </trans-unit>
        <trans-unit id="687844afc928e1515653eca2dc67313bcb251adb" translate="yes" xml:space="preserve">
          <source>Used for Tensor.&lt;strong&gt;div&lt;/strong&gt;.</source>
          <target state="translated">Tensorに使用されます。&lt;strong&gt;div&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="acb129729f63585d898dc89a0859fbaa068d1542" translate="yes" xml:space="preserve">
          <source>Used for backwards compatibility.</source>
          <target state="translated">下位互換性のために使用します。</target>
        </trans-unit>
        <trans-unit id="2ed98ab98b4d3bc08d8823f62d5fecc305aaf972" translate="yes" xml:space="preserve">
          <source>Used for generating the &lt;code&gt;sampling_table&lt;/code&gt; argument for &lt;code&gt;skipgrams&lt;/code&gt;. &lt;code&gt;sampling_table[i]&lt;/code&gt; is the probability of sampling the word i-th most common word in a dataset (more common words should be sampled less frequently, for balance).</source>
          <target state="translated">&lt;code&gt;skipgrams&lt;/code&gt; の &lt;code&gt;sampling_table&lt;/code&gt; テーブル引数の生成に使用されます。 &lt;code&gt;sampling_table[i]&lt;/code&gt; は、データセット内のi番目に最も一般的な単語をサンプリングする確率です（より一般的な単語は、バランスをとるために、それほど頻繁にサンプリングする必要はありません）。</target>
        </trans-unit>
        <trans-unit id="838a9c1b2b1ad8d0483e3efe3752a2cfa857bf97" translate="yes" xml:space="preserve">
          <source>Used in &lt;code&gt;fit_generator&lt;/code&gt;, &lt;code&gt;evaluate_generator&lt;/code&gt;, &lt;code&gt;predict_generator&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;fit_generator&lt;/code&gt; 、 &lt;code&gt;evaluate_generator&lt;/code&gt; 、 &lt;code&gt;predict_generator&lt;/code&gt; で使用されます。</target>
        </trans-unit>
        <trans-unit id="e032a2a6a3c13d10bf51a9e9b4ceb6f1b08ec11d" translate="yes" xml:space="preserve">
          <source>Used in a functional model:</source>
          <target state="translated">機能モデルで使用します。</target>
        </trans-unit>
        <trans-unit id="ce35a302d37a4e5f24d1589056ce4a8ade1153e6" translate="yes" xml:space="preserve">
          <source>Used in the guide:</source>
          <target state="translated">ガイドで使用しています。</target>
        </trans-unit>
        <trans-unit id="5d57c19f05b013abb121e6d7231e8fb33b04353e" translate="yes" xml:space="preserve">
          <source>Used in the tutorials:</source>
          <target state="translated">チュートリアルで使用しています。</target>
        </trans-unit>
        <trans-unit id="666e19bae41db98d774366b280a7568a18c7a7d0" translate="yes" xml:space="preserve">
          <source>Used to create a connection to a TPU master in order to retrieve the system metadata.</source>
          <target state="translated">システムメタデータを取得するために TPU マスターへの接続を作成するために使用します。</target>
        </trans-unit>
        <trans-unit id="0d5b31850f6cd998b34c1f803e97f421ab5e927c" translate="yes" xml:space="preserve">
          <source>Used to implement efficient stacked RNNs.</source>
          <target state="translated">効率的なスタック型RNNの実装に使用します。</target>
        </trans-unit>
        <trans-unit id="1dc2e0b551da6f4f100efb7639cb33de1b18f9c4" translate="yes" xml:space="preserve">
          <source>Used to number checkpoints.</source>
          <target state="translated">チェックポイントの番号付けに使用します。</target>
        </trans-unit>
        <trans-unit id="f25ae0ac1af6f48ad552af7fd633f8cca6feb1bf" translate="yes" xml:space="preserve">
          <source>Used to prevent positional parameters. Internal, do not use.</source>
          <target state="translated">位置パラメーターを防ぐために使用します。内部的には、使用しないでください。</target>
        </trans-unit>
        <trans-unit id="10ff5000f97f7693594d9bc2e58cecc4845e5222" translate="yes" xml:space="preserve">
          <source>Useful e.g. connecting RNNs and convnets.</source>
          <target state="translated">RNN と convnets の接続などに便利です。</target>
        </trans-unit>
        <trans-unit id="33e1b276d404a935dc5326f961aab709a74eaaa4" translate="yes" xml:space="preserve">
          <source>Useful for e.g. connecting RNNs and convnets together.</source>
          <target state="translated">例えば、RNN と convnets を一緒に接続するのに便利です。</target>
        </trans-unit>
        <trans-unit id="2c162068f6d2673c0d1e37e670b21e118d35909f" translate="yes" xml:space="preserve">
          <source>Useful special cases:</source>
          <target state="translated">役に立つ特殊なケース</target>
        </trans-unit>
        <trans-unit id="288dbdb9bfd68b877505e5e2d999c8a104f5d6ad" translate="yes" xml:space="preserve">
          <source>Useful to avoid clutter from old models / layers.</source>
          <target state="translated">古いモデル/レイヤーの乱雑さを避けるのに便利です。</target>
        </trans-unit>
        <trans-unit id="ab56083300b8a34ad1a803f46ebcd7c664f460f2" translate="yes" xml:space="preserve">
          <source>User can call this function to disable 2.x behavior during complex migrations.</source>
          <target state="translated">ユーザーはこの関数を呼び出して、複雑な移行中に2.xの動作を無効にすることができます。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
