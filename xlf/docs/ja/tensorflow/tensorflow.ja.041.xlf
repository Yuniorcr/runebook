<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="tensorflow">
    <body>
      <group id="tensorflow">
        <trans-unit id="07d5b7b8864997727d8fb01740ad8b9e08b14f5f" translate="yes" xml:space="preserve">
          <source>The paper demonstrates the performance of MobileNets using &lt;code&gt;alpha&lt;/code&gt; values of 1.0 (also called 100 % MobileNet), 0.75, 0.5 and 0.25. For each of these &lt;code&gt;alpha&lt;/code&gt; values, weights for 4 different input image sizes are provided (224, 192, 160, 128).</source>
          <target state="translated">このホワイトペーパーでは、 &lt;code&gt;alpha&lt;/code&gt; 値1.0（100％MobileNetとも呼ばれます）、0.75、0.5、および0.25を使用したMobileNetのパフォーマンスを示しています。これらの &lt;code&gt;alpha&lt;/code&gt; 値のそれぞれについて、4つの異なる入力画像サイズ（224、192、160、128）の重みが提供されます。</target>
        </trans-unit>
        <trans-unit id="d91e185b3ec2b95e4e28b058fb7de6ed54c4f63d" translate="yes" xml:space="preserve">
          <source>The parameters &lt;code&gt;concentration&lt;/code&gt; and &lt;code&gt;rate&lt;/code&gt; must be shaped in a way that supports broadcasting (e.g. &lt;code&gt;concentration + rate&lt;/code&gt; is a valid operation).</source>
          <target state="translated">パラメータ &lt;code&gt;concentration&lt;/code&gt; と &lt;code&gt;rate&lt;/code&gt; は、ブロードキャストをサポートする方法で形成する必要があります（たとえば、 &lt;code&gt;concentration + rate&lt;/code&gt; は有効な操作です）。</target>
        </trans-unit>
        <trans-unit id="c4bf0f9162b85380657aa85a48762d0989942eac" translate="yes" xml:space="preserve">
          <source>The parameters &lt;code&gt;df&lt;/code&gt;, &lt;code&gt;loc&lt;/code&gt;, and &lt;code&gt;scale&lt;/code&gt; must be shaped in a way that supports broadcasting (e.g. &lt;code&gt;df + loc + scale&lt;/code&gt; is a valid operation).</source>
          <target state="translated">パラメータ &lt;code&gt;df&lt;/code&gt; 、 &lt;code&gt;loc&lt;/code&gt; 、および &lt;code&gt;scale&lt;/code&gt; は、ブロードキャストをサポートする方法で形成する必要があります（たとえば、 &lt;code&gt;df + loc + scale&lt;/code&gt; は有効な操作です）。</target>
        </trans-unit>
        <trans-unit id="f624db393a0283cdff3712a3c4bd723d749a30a5" translate="yes" xml:space="preserve">
          <source>The parameters &lt;code&gt;loc&lt;/code&gt; and &lt;code&gt;scale&lt;/code&gt; must be shaped in a way that supports broadcasting (e.g. &lt;code&gt;loc + scale&lt;/code&gt; is a valid operation).</source>
          <target state="translated">パラメータ &lt;code&gt;loc&lt;/code&gt; と &lt;code&gt;scale&lt;/code&gt; は、ブロードキャストをサポートする方法で形成する必要があります（たとえば、 &lt;code&gt;loc + scale&lt;/code&gt; は有効な操作です）。</target>
        </trans-unit>
        <trans-unit id="a2bb7ef60bf0239928d550799fd1318ab8a8e22c" translate="yes" xml:space="preserve">
          <source>The parameters &lt;code&gt;loc&lt;/code&gt; and &lt;code&gt;scale&lt;/code&gt; must be shaped in a way that supports broadcasting (e.g., &lt;code&gt;loc / scale&lt;/code&gt; is a valid operation).</source>
          <target state="translated">パラメータ &lt;code&gt;loc&lt;/code&gt; および &lt;code&gt;scale&lt;/code&gt; は、ブロードキャストをサポートする方法で形成する必要があります（たとえば、 &lt;code&gt;loc / scale&lt;/code&gt; は有効な操作です）。</target>
        </trans-unit>
        <trans-unit id="caea2d657314fc74a3b4c82a6b1a8e2927d4e265" translate="yes" xml:space="preserve">
          <source>The parameters &lt;code&gt;low&lt;/code&gt; and &lt;code&gt;high&lt;/code&gt; must be shaped in a way that supports broadcasting (e.g., &lt;code&gt;high - low&lt;/code&gt; is a valid operation).</source>
          <target state="translated">パラメータ &lt;code&gt;low&lt;/code&gt; および &lt;code&gt;high&lt;/code&gt; は、ブロードキャストをサポートする方法で形成する必要があります（たとえば、 &lt;code&gt;high - low&lt;/code&gt; は有効な操作です）。</target>
        </trans-unit>
        <trans-unit id="2da0524f5e34c476f58d52fd7e4bbaca30e3840a" translate="yes" xml:space="preserve">
          <source>The parameters apply to and only to the immediately enclosing loop. It only has effect if the loop is staged as a TF while_loop; otherwise the parameters have no effect.</source>
          <target state="translated">パラメータは、ループの直後にあるループにのみ適用されます。これはループがTFのwhile_loopとしてステージングされている場合にのみ効果があり、それ以外の場合は何の効果もありません。</target>
        </trans-unit>
        <trans-unit id="f861e09ace62d9cf6a436ce61f90b0514dff3612" translate="yes" xml:space="preserve">
          <source>The parameters can be intuited via their relationship to mean and stddev,</source>
          <target state="translated">パラメータは、平均値とstddevとの関係から直感的に理解することができます。</target>
        </trans-unit>
        <trans-unit id="78832ff2cd51fc67f3284e123b0a8c7a1096d66b" translate="yes" xml:space="preserve">
          <source>The parent could be a module when the child is a function at module scope. Or the parent could be a class when a class' method is being replaced. The named child is set to new_child, while the prior definition is saved away for later, when UnsetAll() is called.</source>
          <target state="translated">モジュールスコープで子が関数である場合、親はモジュールになる可能性があります。また、クラスのメソッドが置き換えられている場合は、親がクラスになる可能性があります。指定された子は new_child に設定され、以前の定義は後から UnsetAll()が呼ばれたときのために保存されます。</target>
        </trans-unit>
        <trans-unit id="cc13d476090ccb6ba884188ddcc28a81f62b0726" translate="yes" xml:space="preserve">
          <source>The parse() method checks to make sure that the string argument is a legal value and convert it to a native type. If the value cannot be converted, it should throw a 'ValueError' exception with a human readable explanation of why the value is illegal.</source>
          <target state="translated">parse()メソッドは、文字列の引数が正当な値であることを確認し、ネイティブ型に変換します。値を変換できなかった場合は 'ValueError' 例外をスローし、なぜその値が不正な値なのかを人間が読めるように説明しなければなりません。</target>
        </trans-unit>
        <trans-unit id="cf0794be97523b0be42896e118da1be5a61ff4da" translate="yes" xml:space="preserve">
          <source>The parsed value in native type.</source>
          <target state="translated">ネイティブ型で解析された値。</target>
        </trans-unit>
        <trans-unit id="8cff8c184992ecf7d79d6a190fc8e2ad81b8dd10" translate="yes" xml:space="preserve">
          <source>The partitioned embedding in &lt;code&gt;embedding_weights&lt;/code&gt; must all be the same shape except for the first dimension. The first dimension is allowed to vary as the vocabulary size is not necessarily a multiple of &lt;code&gt;P&lt;/code&gt;. &lt;code&gt;embedding_weights&lt;/code&gt; may be a &lt;code&gt;PartitionedVariable&lt;/code&gt; as returned by using &lt;a href=&quot;../compat/v1/get_variable&quot;&gt;&lt;code&gt;tf.compat.v1.get_variable()&lt;/code&gt;&lt;/a&gt; with a partitioner.</source>
          <target state="translated">embedding_weightsの分割された &lt;code&gt;embedding_weights&lt;/code&gt; は、最初の次元を除いてすべて同じ形状でなければなりません。語彙サイズは必ずしも &lt;code&gt;P&lt;/code&gt; の倍数ではないため、最初の次元は変化することが許可されています。 &lt;code&gt;embedding_weights&lt;/code&gt; は、 &lt;code&gt;PartitionedVariable&lt;/code&gt; &lt;a href=&quot;../compat/v1/get_variable&quot;&gt; &lt;code&gt;tf.compat.v1.get_variable()&lt;/code&gt; &lt;/a&gt;を使用して返されるPartitionedVariableの場合があります。</target>
        </trans-unit>
        <trans-unit id="8e157288a667a186f035deba918682c801fa1abf" translate="yes" xml:space="preserve">
          <source>The partitioned embedding in &lt;code&gt;embedding_weights&lt;/code&gt; must all be the same shape except for the first dimension. The first dimension is allowed to vary as the vocabulary size is not necessarily a multiple of &lt;code&gt;P&lt;/code&gt;. &lt;code&gt;embedding_weights&lt;/code&gt; may be a &lt;code&gt;PartitionedVariable&lt;/code&gt; as returned by using &lt;a href=&quot;../get_variable&quot;&gt;&lt;code&gt;tf.compat.v1.get_variable()&lt;/code&gt;&lt;/a&gt; with a partitioner.</source>
          <target state="translated">embedding_weightsの分割された &lt;code&gt;embedding_weights&lt;/code&gt; は、最初の次元を除いてすべて同じ形状でなければなりません。語彙サイズは必ずしも &lt;code&gt;P&lt;/code&gt; の倍数ではないため、最初の次元は変化することが許可されています。 &lt;code&gt;embedding_weights&lt;/code&gt; は、 &lt;code&gt;PartitionedVariable&lt;/code&gt; &lt;a href=&quot;../get_variable&quot;&gt; &lt;code&gt;tf.compat.v1.get_variable()&lt;/code&gt; &lt;/a&gt;を使用して返されるPartitionedVariableの場合があります。</target>
        </trans-unit>
        <trans-unit id="1549f14314cb2911099be0c08464c7d5489a22a6" translate="yes" xml:space="preserve">
          <source>The partitioned embedding in &lt;code&gt;embedding_weights&lt;/code&gt; must all be the same shape except for the first dimension. The first dimension is allowed to vary as the vocabulary size is not necessarily a multiple of num of shards.</source>
          <target state="translated">embedding_weightsのパーティション化された &lt;code&gt;embedding_weights&lt;/code&gt; は、最初の次元を除いてすべて同じ形状である必要があります。語彙のサイズは必ずしもシャードの数の倍数ではないため、最初の次元は変更できます。</target>
        </trans-unit>
        <trans-unit id="b3b7bcbb761db59d963bb51839f46a4b29f4af4e" translate="yes" xml:space="preserve">
          <source>The path is relative to tensorflow/</source>
          <target state="translated">パスは、tensorflow/の相対パスです。</target>
        </trans-unit>
        <trans-unit id="f48baa97e568a9b9e3b5f52a6ab7e866fecd8550" translate="yes" xml:space="preserve">
          <source>The path of the output proto file.</source>
          <target state="translated">出力プロトファイルのパス。</target>
        </trans-unit>
        <trans-unit id="ee14c49610bbef1394c243e137f1c0c32f1960be" translate="yes" xml:space="preserve">
          <source>The path to a directory in which to write checkpoints. A special file named &quot;checkpoint&quot; is also written to this directory (in a human-readable text format) which contains the state of the &lt;code&gt;CheckpointManager&lt;/code&gt;.</source>
          <target state="translated">チェックポイントを書き込むディレクトリへのパス。「checkpoint」という名前の特別なファイルも、 &lt;code&gt;CheckpointManager&lt;/code&gt; の状態を含むこのディレクトリに（人間が読める形式のテキスト形式で）書き込まれます。</target>
        </trans-unit>
        <trans-unit id="b3d2248f6c5ba1b79f5657059376b70c88f9d6c1" translate="yes" xml:space="preserve">
          <source>The path to an event file created by a &lt;code&gt;SummaryWriter&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;SummaryWriter&lt;/code&gt; によって作成されたイベントファイルへのパス。</target>
        </trans-unit>
        <trans-unit id="9a7713229c9d7bf490b65513fab0d07d2cad4f51" translate="yes" xml:space="preserve">
          <source>The path to the TFRecords file.</source>
          <target state="translated">TFRecords ファイルへのパスです。</target>
        </trans-unit>
        <trans-unit id="84c5edf8f8528c6dcc19dfeb36d929c09dc91f28" translate="yes" xml:space="preserve">
          <source>The path to the checkpoint as returned by &lt;code&gt;write&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;write&lt;/code&gt; によって返されるチェックポイントへのパス。</target>
        </trans-unit>
        <trans-unit id="b8030756c5c759c44f9f3cb2091477d30b127210" translate="yes" xml:space="preserve">
          <source>The path to the checkpoint, as returned by &lt;code&gt;save&lt;/code&gt; or &lt;a href=&quot;../../../train/latest_checkpoint&quot;&gt;&lt;code&gt;tf.train.latest_checkpoint&lt;/code&gt;&lt;/a&gt;. If None (as when there is no latest checkpoint for &lt;a href=&quot;../../../train/latest_checkpoint&quot;&gt;&lt;code&gt;tf.train.latest_checkpoint&lt;/code&gt;&lt;/a&gt; to return), returns an object which may run initializers for objects in the dependency graph. If the checkpoint was written by the name-based &lt;a href=&quot;saver&quot;&gt;&lt;code&gt;tf.compat.v1.train.Saver&lt;/code&gt;&lt;/a&gt;, names are used to match variables.</source>
          <target state="translated">&lt;code&gt;save&lt;/code&gt; または&lt;a href=&quot;../../../train/latest_checkpoint&quot;&gt; &lt;code&gt;tf.train.latest_checkpoint&lt;/code&gt; &lt;/a&gt;によって返されるチェックポイントへのパス。Noneの場合（返す&lt;a href=&quot;../../../train/latest_checkpoint&quot;&gt; &lt;code&gt;tf.train.latest_checkpoint&lt;/code&gt; &lt;/a&gt;の最新のチェックポイントがない場合など）、依存関係グラフ内のオブジェクトの初期化子を実行する可能性のあるオブジェクトを返します。チェックポイントが名前ベースの&lt;a href=&quot;saver&quot;&gt; &lt;code&gt;tf.compat.v1.train.Saver&lt;/code&gt; &lt;/a&gt;によって作成された場合、名前は変数の照合に使用されます。</target>
        </trans-unit>
        <trans-unit id="7d9bb46d11e0a3efc649638be0d00aa480e84e55" translate="yes" xml:space="preserve">
          <source>The path to the checkpoint, as returned by &lt;code&gt;save&lt;/code&gt; or &lt;a href=&quot;latest_checkpoint&quot;&gt;&lt;code&gt;tf.train.latest_checkpoint&lt;/code&gt;&lt;/a&gt;. If the checkpoint was written by the name-based &lt;a href=&quot;../compat/v1/train/saver&quot;&gt;&lt;code&gt;tf.compat.v1.train.Saver&lt;/code&gt;&lt;/a&gt;, names are used to match variables.</source>
          <target state="translated">&lt;code&gt;save&lt;/code&gt; または&lt;a href=&quot;latest_checkpoint&quot;&gt; &lt;code&gt;tf.train.latest_checkpoint&lt;/code&gt; &lt;/a&gt;によって返されるチェックポイントへのパス。チェックポイントが名前ベースの&lt;a href=&quot;../compat/v1/train/saver&quot;&gt; &lt;code&gt;tf.compat.v1.train.Saver&lt;/code&gt; &lt;/a&gt;によって作成された場合、名前は変数の照合に使用されます。</target>
        </trans-unit>
        <trans-unit id="d3c8f8b6fd3cf107eb955208c8e6315d0e1a6163" translate="yes" xml:space="preserve">
          <source>The path to the exported directory as a bytes object.</source>
          <target state="translated">エクスポートされたディレクトリへのパスをバイトオブジェクトとして指定します。</target>
        </trans-unit>
        <trans-unit id="2c6d384388d19ed3fa790b1769ea860a0e6be8d0" translate="yes" xml:space="preserve">
          <source>The path to the new checkpoint. It is also recorded in the &lt;code&gt;checkpoints&lt;/code&gt; and &lt;code&gt;latest_checkpoint&lt;/code&gt; properties.</source>
          <target state="translated">新しいチェックポイントへのパス。また、 &lt;code&gt;checkpoints&lt;/code&gt; および &lt;code&gt;latest_checkpoint&lt;/code&gt; プロパティにも記録されます。</target>
        </trans-unit>
        <trans-unit id="995443700e473d68dc872f5c69aa35e966bca809" translate="yes" xml:space="preserve">
          <source>The path to the new checkpoint. It is also recorded in the &lt;code&gt;checkpoints&lt;/code&gt; and &lt;code&gt;latest_checkpoint&lt;/code&gt; properties. &lt;code&gt;None&lt;/code&gt; if no checkpoint is saved.</source>
          <target state="translated">新しいチェックポイントへのパス。また、 &lt;code&gt;checkpoints&lt;/code&gt; と &lt;code&gt;latest_checkpoint&lt;/code&gt; プロパティにも記録されます。チェックポイントが保存されていない場合は &lt;code&gt;None&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0ee0e0b9b831848f3b4065f81ba73b2d7593c0f8" translate="yes" xml:space="preserve">
          <source>The path to the specified file present in the data attribute of py_test or py_binary.</source>
          <target state="translated">py_testまたはpy_binaryのdata属性で指定されたファイルへのパス。</target>
        </trans-unit>
        <trans-unit id="c28b39685fa19f5fe1fe963ce50d396e16dbe87f" translate="yes" xml:space="preserve">
          <source>The path to the specified file present in the data attribute of py_test or py_binary. Falls back to returning the same as get_data_files_path if it fails to detect a bazel runfiles directory.</source>
          <target state="translated">py_testまたはpy_binaryのdata属性にある指定されたファイルへのパスです。bazel runfilesディレクトリの検出に失敗した場合は、get_data_files_pathと同じパスを返すようにフォールバックします。</target>
        </trans-unit>
        <trans-unit id="87756ef48ceb2a46a88324fa1e20a23d5ed02a12" translate="yes" xml:space="preserve">
          <source>The path to which the SavedModel protocol buffer was written.</source>
          <target state="translated">SavedModel プロトコルバッファが書き込まれたパス。</target>
        </trans-unit>
        <trans-unit id="8be5bab78d1909543ad9986a84ecdbc0832b8254" translate="yes" xml:space="preserve">
          <source>The path to which the SavedModel will be stored.</source>
          <target state="translated">SavedModelが保存されるパス。</target>
        </trans-unit>
        <trans-unit id="0dab2a06ad633869bd90e943c4184ac0e2fe54a0" translate="yes" xml:space="preserve">
          <source>The pattern follows the re2 syntax (&lt;a href=&quot;https://github.com/google/re2/wiki/Syntax&quot;&gt;https://github.com/google/re2/wiki/Syntax&lt;/a&gt;)</source>
          <target state="translated">パターンはre2構文に従います（&lt;a href=&quot;https://github.com/google/re2/wiki/Syntax&quot;&gt;https://github.com/google/re2/wiki/Syntax&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="c7281e72ad08903abeb2bd587c7c0dfd0d8772e6" translate="yes" xml:space="preserve">
          <source>The pattern follows the re2 syntax (https://github.com/google/re2/wiki/Syntax)</source>
          <target state="translated">パターンは re2 の構文 (https://github.com/google/re2/wiki/Syntax)に従います。</target>
        </trans-unit>
        <trans-unit id="6073374fbdf4fdacc0b93351a02133e64c1915d8" translate="yes" xml:space="preserve">
          <source>The patterns are defined as strings. Supported patterns are defined here. Note that the pattern can be a Python iteratable of string patterns.</source>
          <target state="translated">パターンは文字列として定義されています。サポートされているパターンはここで定義されています。パターンは文字列パターンのPythonの反復可能なものであることに注意してください。</target>
        </trans-unit>
        <trans-unit id="5c52ca33f774b534fe80a4db87092be76893e002" translate="yes" xml:space="preserve">
          <source>The peephole implementation is based on:</source>
          <target state="translated">覗き穴の実装に基づいています。</target>
        </trans-unit>
        <trans-unit id="baf8710cc0a85723dd8aa2526d303f0863e63136" translate="yes" xml:space="preserve">
          <source>The performance of &lt;code&gt;LinearOperatorAdjoint&lt;/code&gt; depends on the underlying operators performance.</source>
          <target state="translated">&lt;code&gt;LinearOperatorAdjoint&lt;/code&gt; のパフォーマンスは、基になる演算子のパフォーマンスに依存します。</target>
        </trans-unit>
        <trans-unit id="80d488d70fd1fbe1594d7c6c118ae3795bd1145d" translate="yes" xml:space="preserve">
          <source>The performance of &lt;code&gt;LinearOperatorBlockDiag&lt;/code&gt; on any operation is equal to the sum of the individual operators' operations.</source>
          <target state="translated">任意の操作での &lt;code&gt;LinearOperatorBlockDiag&lt;/code&gt; のパフォーマンスは、個々のオペレーターの操作の合計と同じです。</target>
        </trans-unit>
        <trans-unit id="9b2ab24a37ac3d66ce6ff090c15ce4c8f5b1d480" translate="yes" xml:space="preserve">
          <source>The performance of &lt;code&gt;LinearOperatorComposition&lt;/code&gt; on any operation is equal to the sum of the individual operators' operations.</source>
          <target state="translated">任意の操作での &lt;code&gt;LinearOperatorComposition&lt;/code&gt; のパフォーマンスは、個々のオペレーターの操作の合計と同じです。</target>
        </trans-unit>
        <trans-unit id="f94bad31467a9ea9f4b4d537674d8e77b0cf1a22" translate="yes" xml:space="preserve">
          <source>The performance of &lt;code&gt;LinearOperatorInversion&lt;/code&gt; depends on the underlying operators performance: &lt;code&gt;solve&lt;/code&gt; and &lt;code&gt;matmul&lt;/code&gt; are swapped, and determinant is inverted.</source>
          <target state="translated">パフォーマンス &lt;code&gt;LinearOperatorInversion&lt;/code&gt; は、基盤となる事業者のパフォーマンスに依存します。 &lt;code&gt;solve&lt;/code&gt; と &lt;code&gt;matmul&lt;/code&gt; 交換され、そして行列が反転しています。</target>
        </trans-unit>
        <trans-unit id="bc0efd32d22cd6d37162492744eb9c09073101ec" translate="yes" xml:space="preserve">
          <source>The performance of &lt;code&gt;LinearOperatorKronecker&lt;/code&gt; on any operation is equal to the sum of the individual operators' operations.</source>
          <target state="translated">任意の操作における &lt;code&gt;LinearOperatorKronecker&lt;/code&gt; のパフォーマンスは、個々のオペレーターの操作の合計と同じです。</target>
        </trans-unit>
        <trans-unit id="3adcc83502b5bf35b4db3b88505bc6feb67f24c9" translate="yes" xml:space="preserve">
          <source>The polygamma function is defined as:</source>
          <target state="translated">ポリガンマ関数は次のように定義されています。</target>
        </trans-unit>
        <trans-unit id="58805a4c695a0c84e281d698b93c5605de911e7d" translate="yes" xml:space="preserve">
          <source>The port the TensorFlow server is listening on.</source>
          <target state="translated">TensorFlowサーバーがリッスンしているポート。</target>
        </trans-unit>
        <trans-unit id="278a092ca102f6f63192c91f543df0b76f86bf53" translate="yes" xml:space="preserve">
          <source>The position where padding or truncation happens is determined by the arguments &lt;code&gt;padding&lt;/code&gt; and &lt;code&gt;truncating&lt;/code&gt;, respectively. Pre-padding or removing values from the beginning of the sequence is the default.</source>
          <target state="translated">パディングまたは切り捨てが発生する位置は、引数の &lt;code&gt;padding&lt;/code&gt; と &lt;code&gt;truncating&lt;/code&gt; によってそれぞれ決定されます。シーケンスの先頭から値を事前にパディングまたは削除することがデフォルトです。</target>
        </trans-unit>
        <trans-unit id="9d524ae593bfca1cec825db026e283842ef95ed3" translate="yes" xml:space="preserve">
          <source>The possible number of labels the classification task can have. If this value is not provided, it will be calculated using both predictions and labels array.</source>
          <target state="translated">分類タスクが持つことができるラベルの数。この値が指定されていない場合は、予測値とラベル配列の両方を使用して計算されます。</target>
        </trans-unit>
        <trans-unit id="8efb3a74fd166658f111b04a0c0279818ee74864" translate="yes" xml:space="preserve">
          <source>The possible number of labels the prediction task can have. This value must be provided, since a confusion matrix of dimension = [num_classes, num_classes] will be allocated.</source>
          <target state="translated">予測タスクが持つことのできるラベルの数。dimension=[num_classes,num_classes]の混同行列が割り当てられるので,この値を指定しなければなりません.</target>
        </trans-unit>
        <trans-unit id="3e0a01897541e4cc7358dd44c0abef35501aae05" translate="yes" xml:space="preserve">
          <source>The possible number of labels the prediction task can have. This value must be provided, since two variables with shape = [num_classes] will be allocated.</source>
          <target state="translated">予測タスクが持つことができるラベルの数。shape=[num_classes]の2つの変数が割り当てられるので、この値を指定しなければなりません。</target>
        </trans-unit>
        <trans-unit id="692359d83812b544d928c04fadf8b5c3c2df67a0" translate="yes" xml:space="preserve">
          <source>The possible values are: &lt;code&gt;GATE_NONE&lt;/code&gt;, &lt;code&gt;GATE_OP&lt;/code&gt;, and &lt;code&gt;GATE_GRAPH&lt;/code&gt;.</source>
          <target state="translated">可能な値は次のとおりです &lt;code&gt;GATE_NONE&lt;/code&gt; 、 &lt;code&gt;GATE_OP&lt;/code&gt; 、および &lt;code&gt;GATE_GRAPH&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d5d3e18deacf1c7ef93bee6d5b865603caff1a2a" translate="yes" xml:space="preserve">
          <source>The potentially support list contains a list of ops that are partially or fully supported, which is derived by simply scanning op names to check whether they can be handled without real conversion and specific parameters.</source>
          <target state="translated">潜在的にサポートされているリストには、部分的または完全にサポートされている操作のリストが含まれており、実際の変換や特定のパラメータなしで処理できるかどうかをチェックするために、単に操作名をスキャンすることによって導出されます。</target>
        </trans-unit>
        <trans-unit id="7c853ad9a21d66e7bd6fdc646ae396c38787f2e0" translate="yes" xml:space="preserve">
          <source>The predicted outputs, a tensor of size &lt;code&gt;[batch_size, d0, .. dN]&lt;/code&gt; where N+1 is the total number of dimensions in &lt;code&gt;predictions&lt;/code&gt;.</source>
          <target state="translated">予測された出力、サイズ &lt;code&gt;[batch_size, d0, .. dN]&lt;/code&gt; テンソル。ここで、N +1は &lt;code&gt;predictions&lt;/code&gt; の次元の総数です。</target>
        </trans-unit>
        <trans-unit id="f104bcdd7d5f421504142d2c94d5f8c62a0e743f" translate="yes" xml:space="preserve">
          <source>The predicted outputs.</source>
          <target state="translated">予測された出力。</target>
        </trans-unit>
        <trans-unit id="a70f131e2a7ce29596591e28a1cfededaebaff6a" translate="yes" xml:space="preserve">
          <source>The predicted values, a &lt;code&gt;Tensor&lt;/code&gt; of any shape.</source>
          <target state="translated">予測値、任意の形状の &lt;code&gt;Tensor&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6728a30c6037094fe5c0a9ed3f50b7de76aa2e0d" translate="yes" xml:space="preserve">
          <source>The predicted values, a &lt;code&gt;Tensor&lt;/code&gt; of arbitrary dimensions. Will be cast to &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="translated">予測値、任意の次元の &lt;code&gt;Tensor&lt;/code&gt; 。 &lt;code&gt;bool&lt;/code&gt; にキャストされます。</target>
        </trans-unit>
        <trans-unit id="71f7a8826bad533ae16d312cbce730009c206751" translate="yes" xml:space="preserve">
          <source>The predicted values.</source>
          <target state="translated">予測値です。</target>
        </trans-unit>
        <trans-unit id="c4778ceab3533971f6aa86d7a9cab9cffa7b4ebb" translate="yes" xml:space="preserve">
          <source>The predicted values. Each element must be in the range &lt;code&gt;[0, 1]&lt;/code&gt;.</source>
          <target state="translated">予測値。各要素は &lt;code&gt;[0, 1]&lt;/code&gt; 範囲内にある必要があります。</target>
        </trans-unit>
        <trans-unit id="86f018a513047301d5f31c33cb992832bb0aa35d" translate="yes" xml:space="preserve">
          <source>The predicted values. shape = &lt;code&gt;[batch_size, d0, .. dN]&lt;/code&gt;</source>
          <target state="translated">予測値。形状= &lt;code&gt;[batch_size, d0, .. dN]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e9916875b88168e8e1d45339b98305ac670cab32" translate="yes" xml:space="preserve">
          <source>The predicted values. shape = &lt;code&gt;[batch_size, d0, .. dN]&lt;/code&gt;.</source>
          <target state="translated">予測値。形状= &lt;code&gt;[batch_size, d0, .. dN]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="350857c387e91589b30efc773f0aa8bb73f1dd8b" translate="yes" xml:space="preserve">
          <source>The prediction values.</source>
          <target state="translated">予測値です。</target>
        </trans-unit>
        <trans-unit id="22221eb5e9024f9d30d6d77902385bdae34280a3" translate="yes" xml:space="preserve">
          <source>The prefix of a V1 or V2 checkpoint. Typically the result of &lt;code&gt;Saver.save()&lt;/code&gt; or that of &lt;a href=&quot;../../../train/latest_checkpoint&quot;&gt;&lt;code&gt;tf.train.latest_checkpoint()&lt;/code&gt;&lt;/a&gt;, regardless of sharded/non-sharded or V1/V2.</source>
          <target state="translated">V1またはV2チェックポイントのプレフィックス。典型的結果 &lt;code&gt;Saver.save()&lt;/code&gt; またはの&lt;a href=&quot;../../../train/latest_checkpoint&quot;&gt; &lt;code&gt;tf.train.latest_checkpoint()&lt;/code&gt; &lt;/a&gt;にかかわらず、かけらの、/非かけら又はV1 / V2。</target>
        </trans-unit>
        <trans-unit id="aaf184bbd1e736ec9f0efcfa8ff77fd74b286f9f" translate="yes" xml:space="preserve">
          <source>The prefix of the most recent checkpoint in &lt;code&gt;directory&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;directory&lt;/code&gt; 内の最新のチェックポイントの接頭辞。</target>
        </trans-unit>
        <trans-unit id="0e79e9868436b7bc9300626a15307ccf5673bf8d" translate="yes" xml:space="preserve">
          <source>The prefix to use on all names created within the name scope.</source>
          <target state="translated">ネームスコープ内で作成されたすべての名前に使用する接頭辞。</target>
        </trans-unit>
        <trans-unit id="43a7df5de41d0edab56a0d1dc85f3a8f7b95e198" translate="yes" xml:space="preserve">
          <source>The primary case where you need extra work to support mixed precision or float64 is when you create a new tensor, such as with &lt;a href=&quot;../../../ones&quot;&gt;&lt;code&gt;tf.ones&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../../constant&quot;&gt;&lt;code&gt;tf.constant&lt;/code&gt;&lt;/a&gt;. In such cases, you must create the tensor of the correct dtype. For example, suppose you modify the &lt;code&gt;MyDense&lt;/code&gt; layer to add a random number to the output using &lt;a href=&quot;../../../random/normal&quot;&gt;&lt;code&gt;tf.random.normal&lt;/code&gt;&lt;/a&gt;. You must pass the input dtype to &lt;a href=&quot;../../../random/normal&quot;&gt;&lt;code&gt;tf.random.normal&lt;/code&gt;&lt;/a&gt; to ensure the dtypes match.</source>
          <target state="translated">倍精度またはfloat64をサポートするために追加の作業が必要になる主なケースは、&lt;a href=&quot;../../../ones&quot;&gt; &lt;code&gt;tf.ones&lt;/code&gt; &lt;/a&gt;や&lt;a href=&quot;../../../constant&quot;&gt; &lt;code&gt;tf.constant&lt;/code&gt; &lt;/a&gt;などを使用して新しいテンソルを作成する場合です。このような場合、正しいdtypeのテンソルを作成する必要があります。たとえば、あなたが変更と仮定 &lt;code&gt;MyDense&lt;/code&gt; の使用して出力に乱数を追加する層を&lt;a href=&quot;../../../random/normal&quot;&gt; &lt;code&gt;tf.random.normal&lt;/code&gt; を&lt;/a&gt;。dtypeが&lt;a href=&quot;../../../random/normal&quot;&gt; &lt;code&gt;tf.random.normal&lt;/code&gt; &lt;/a&gt;するようにするには、入力dtypeをtf.random.normalに渡す必要があります。</target>
        </trans-unit>
        <trans-unit id="70445e39cb7672ad4a6b06501270c1f13979a70f" translate="yes" xml:space="preserve">
          <source>The primary use case for this API is to put tensors in a set/dictionary. We can't put tensors in a set/dictionary as &lt;code&gt;tensor.__hash__()&lt;/code&gt; is no longer available starting Tensorflow 2.0.</source>
          <target state="translated">このAPIの主な使用例は、テンソルをセット/辞書に配置することです。Tensorflow 2.0以降、 &lt;code&gt;tensor.__hash__()&lt;/code&gt; は使用できなくなったため、テンソルをセット/辞書に入れることはできません。</target>
        </trans-unit>
        <trans-unit id="b0c5bb1e4f98a69939280a641cea06563cef1412" translate="yes" xml:space="preserve">
          <source>The primary use case for this API is to put variables in a set/dictionary. We can't put variables in a set/dictionary as &lt;code&gt;variable.__hash__()&lt;/code&gt; is no longer available starting Tensorflow 2.0.</source>
          <target state="translated">このAPIの主な使用例は、変数をセット/辞書に入れることです。変数を変数としてセット/辞書に入れることはできません &lt;code&gt;variable.__hash__()&lt;/code&gt; はTensorflow2.0以降使用できなくなりました。</target>
        </trans-unit>
        <trans-unit id="0cdbe0557abf05d8c31ba3846734c76d96d3bcc3" translate="yes" xml:space="preserve">
          <source>The primary usecase for this API is to put tensors in a set/dictionary. We can't put tensors in a set/dictionary as &lt;code&gt;tensor.__hash__()&lt;/code&gt; is no longer available starting Tensorflow 2.0.</source>
          <target state="translated">このAPIの主なユースケースは、テンソルをセット/辞書に配置することです。 &lt;code&gt;tensor.__hash__()&lt;/code&gt; はTensorflow 2.0以降では利用できないため、セット/辞書にテンソルを配置することはできません。</target>
        </trans-unit>
        <trans-unit id="14c5ca1e155e62f217839df947a76604aa7befe7" translate="yes" xml:space="preserve">
          <source>The primary usecase for this API is to put variables in a set/dictionary. We can't put variables in a set/dictionary as &lt;code&gt;variable.__hash__()&lt;/code&gt; is no longer available starting Tensorflow 2.0.</source>
          <target state="translated">このAPIの主な使用例は、変数をセット/辞書に配置することです。変数を変数としてセット/辞書に配置することはできません。Tensorflow2.0以降、 &lt;code&gt;variable.__hash__()&lt;/code&gt; は使用できなくなりました。</target>
        </trans-unit>
        <trans-unit id="bfffea38233a7f94cfc568cf11eefdfb38392417" translate="yes" xml:space="preserve">
          <source>The probability density function (pdf) is,</source>
          <target state="translated">確率密度関数(pdf)です。</target>
        </trans-unit>
        <trans-unit id="d639692ffbb24f5fe23fd0cf8f29f9ea56836d74" translate="yes" xml:space="preserve">
          <source>The probability density function (pdf) of this distribution is,</source>
          <target state="translated">この分布の確率密度関数(pdf)は</target>
        </trans-unit>
        <trans-unit id="c2092fccabcd3a2abdef73412d545365899001b8" translate="yes" xml:space="preserve">
          <source>The probability mass function (pmf) is,</source>
          <target state="translated">確率質量関数(pmf)です。</target>
        </trans-unit>
        <trans-unit id="331d712cc96a7cb254a89657cf4ba910cc781864" translate="yes" xml:space="preserve">
          <source>The processing of each sample contains the following steps:</source>
          <target state="translated">各サンプルの処理には、以下のステップが含まれています。</target>
        </trans-unit>
        <trans-unit id="b1597763a35d57db9c807276fa76fead0e6bf3d7" translate="yes" xml:space="preserve">
          <source>The processing of each sample contains the following steps: 1) standardize each sample (usually lowercasing + punctuation stripping) 2) split each sample into substrings (usually words) 3) recombine substrings into tokens (usually ngrams) 4) index tokens (associate a unique int value with each token) 5) transform each sample using this index, either into a vector of ints or a dense float vector.</source>
          <target state="translated">各サンプルの処理は以下のステップを含む。1)各サンプルを標準化する(通常は小文字化+句読点除去)2)各サンプルを部分文字列(通常は単語)に分割する 3)部分文字列をトークン(通常はngram)に再結合する 4)トークンをインデックス化する(各トークンに一意のint値を関連付ける)5)このインデックスを用いて,各サンプルをintのベクトルか密なfloatベクトルに変換する。</target>
        </trans-unit>
        <trans-unit id="bc3e043e3089ab9c2cc2954b166a1bf6364579df" translate="yes" xml:space="preserve">
          <source>The profiler server will exit when the process finishes. The service is defined in tensorflow/core/profiler/profiler_service.proto.</source>
          <target state="translated">プロファイラサーバーは、プロセスが終了すると終了します。サービスは tensorflow/core/profiler/profiler_service.proto で定義されています。</target>
        </trans-unit>
        <trans-unit id="e67a4435185658688f7c2b52360cda7ea81a0d75" translate="yes" xml:space="preserve">
          <source>The profiler session will be stopped and profile results can be saved.</source>
          <target state="translated">プロファイラセッションを停止し、プロファイル結果を保存することができます。</target>
        </trans-unit>
        <trans-unit id="ddcf3e7dfeb12410a9d6122f19a6f9f6186a333b" translate="yes" xml:space="preserve">
          <source>The protocol TensorFlow used to communicate between nodes. Defaults to 'grpc'.</source>
          <target state="translated">ノード間の通信に使用するプロトコル TensorFlow。デフォルトは 'grpc' です。</target>
        </trans-unit>
        <trans-unit id="5e9c7a33590d968d1c4d2adb1f14e30ca9d6e013" translate="yes" xml:space="preserve">
          <source>The provided generator can be finite in which case the class will throw a &lt;code&gt;StopIteration&lt;/code&gt; exception.</source>
          <target state="translated">提供されるジェネレーターは有限にすることができ、その場合、クラスは &lt;code&gt;StopIteration&lt;/code&gt; 例外をスローします。</target>
        </trans-unit>
        <trans-unit id="8129f9559f62303b98c598e584d99bb1465d425d" translate="yes" xml:space="preserve">
          <source>The provided value can be a python boolean, a scalar boolean Tensor, or or a callable providing such a value; if a callable is passed it will be invoked on-demand to determine whether summary writing will occur.</source>
          <target state="translated">提供される値は、pythonのブール値、スカラーのブール値Tensor、またはそのような値を提供するcallableになります;callableが渡された場合は、要約書き込みが発生するかどうかを判断するためにオンデマンドで呼び出されます。</target>
        </trans-unit>
        <trans-unit id="d84a7589708b247ba11ef0a6241d0276fd1c0415" translate="yes" xml:space="preserve">
          <source>The pseudo-inverse of a matrix &lt;code&gt;A&lt;/code&gt;, is defined as: 'the matrix that 'solves' [the least-squares problem] &lt;code&gt;A @ x = b&lt;/code&gt;,' i.e., if &lt;code&gt;x_hat&lt;/code&gt; is a solution, then &lt;code&gt;A_pinv&lt;/code&gt; is the matrix such that &lt;code&gt;x_hat = A_pinv @ b&lt;/code&gt;. It can be shown that if &lt;code&gt;U @ Sigma @ V.T = A&lt;/code&gt; is the singular value decomposition of &lt;code&gt;A&lt;/code&gt;, then &lt;code&gt;A_pinv = V @ inv(Sigma) U^T&lt;/code&gt;. [(Strang, 1980)][1]</source>
          <target state="translated">行列の擬似逆行列 &lt;code&gt;A&lt;/code&gt; は、次のように定義される。「マトリックスをその『解く』 [最小二乗問題] &lt;code&gt;A @ x = b&lt;/code&gt; 、」場合、すなわち、 &lt;code&gt;x_hat&lt;/code&gt; は溶液で、次いで &lt;code&gt;A_pinv&lt;/code&gt; がある行列よう &lt;code&gt;x_hat = A_pinv @ b&lt;/code&gt; 。 &lt;code&gt;U @ Sigma @ V.T = A&lt;/code&gt; がAの特異値分解で &lt;code&gt;A&lt;/code&gt; 場合、 &lt;code&gt;A_pinv = V @ inv(Sigma) U^T&lt;/code&gt; ことを示すことができます。 [（Strang、1980）] [1]</target>
        </trans-unit>
        <trans-unit id="9b22641be848196f7d9c02ba6fc3610602324007" translate="yes" xml:space="preserve">
          <source>The purpose of this function is to allow users of existing layers to slowly transition to Keras layers API without breaking existing functionality.</source>
          <target state="translated">この機能の目的は、既存のレイヤーのユーザーが既存の機能を壊すことなく、ゆっくりとKerasレイヤーAPIに移行できるようにすることです。</target>
        </trans-unit>
        <trans-unit id="d088d5e5d63d8b56ec540e3afc689671a1995e6f" translate="yes" xml:space="preserve">
          <source>The purpose of this scope is to allow users of existing layers to slowly transition to a Keras layers API without breaking existing functionality.</source>
          <target state="translated">このスコープの目的は、既存のレイヤーのユーザーが既存の機能を壊すことなく、ゆっくりと Keras レイヤー API に移行できるようにすることです。</target>
        </trans-unit>
        <trans-unit id="7c5cb70c5a3b792465bd5ce774c8ea2af3bb85e3" translate="yes" xml:space="preserve">
          <source>The python function &lt;code&gt;fn&lt;/code&gt; will be called once with symbolic arguments specified in the &lt;code&gt;signature&lt;/code&gt;, traced, and turned into a graph function. Any variables created by &lt;code&gt;fn&lt;/code&gt; will be owned by the object returned by &lt;code&gt;wrap_function&lt;/code&gt;. The resulting graph function can be called with tensors which match the signature.</source>
          <target state="translated">Python関数 &lt;code&gt;fn&lt;/code&gt; は、 &lt;code&gt;signature&lt;/code&gt; で指定されたシンボリック引数を使用して一度呼び出され、トレースされて、グラフ関数に変換されます。 &lt;code&gt;fn&lt;/code&gt; によって作成された変数は、 &lt;code&gt;wrap_function&lt;/code&gt; によって返されたオブジェクトによって所有されます。結果のグラフ関数は、署名に一致するテンソルで呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="d03bcbea9ec248eeaa20713d75d526a9879de1ff" translate="yes" xml:space="preserve">
          <source>The quantity to be monitored needs to be available in &lt;code&gt;logs&lt;/code&gt; dict. To make it so, pass the loss or metrics at &lt;code&gt;model.compile()&lt;/code&gt;.</source>
          <target state="translated">数量はで利用できるようにする必要性を監視する &lt;code&gt;logs&lt;/code&gt; 辞書。そのためには、 &lt;code&gt;model.compile()&lt;/code&gt; で損失またはメトリックを渡します。</target>
        </trans-unit>
        <trans-unit id="4d8a7f5ae13c0deb4cd4a8012ab18a5fdec064e5" translate="yes" xml:space="preserve">
          <source>The queue reference, i.e. the output of the queue op.</source>
          <target state="translated">キュー参照、すなわちキュー op の出力。</target>
        </trans-unit>
        <trans-unit id="aaadc5a70ca763680cae28ccccd312176ae7929f" translate="yes" xml:space="preserve">
          <source>The ragged rank for the &lt;code&gt;RaggedTensor&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;RaggedTensor&lt;/code&gt; の不規則なランク</target>
        </trans-unit>
        <trans-unit id="cf2591fdff5d530b2526efe01b41c14d72949b69" translate="yes" xml:space="preserve">
          <source>The random integers are slightly biased unless &lt;code&gt;maxval - minval&lt;/code&gt; is an exact power of two. The bias is small for values of &lt;code&gt;maxval - minval&lt;/code&gt; significantly smaller than the range of the output (either &lt;code&gt;2^32&lt;/code&gt; or &lt;code&gt;2^64&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;maxval - minval&lt;/code&gt; が正確に2の累乗でない限り、ランダムな整数はわずかにバイアスされます。 &lt;code&gt;maxval - minval&lt;/code&gt; 値が出力の範囲（ &lt;code&gt;2^32&lt;/code&gt; または &lt;code&gt;2^64&lt;/code&gt; ）よりも大幅に小さい場合、バイアスは小さくなります。</target>
        </trans-unit>
        <trans-unit id="b20ff491ff5822812275688511b761f22476aa65" translate="yes" xml:space="preserve">
          <source>The range of pixel values for the output image might be slightly different from the range for the input image because of limited numerical precision. To guarantee an output range, for example &lt;code&gt;[0.0, 1.0]&lt;/code&gt;, apply &lt;a href=&quot;../../../clip_by_value&quot;&gt;&lt;code&gt;tf.clip_by_value&lt;/code&gt;&lt;/a&gt; to the output.</source>
          <target state="translated">数値の精度に制限があるため、出力画像のピクセル値の範囲は、入力画像の範囲とわずかに異なる場合があります。 &lt;code&gt;[0.0, 1.0]&lt;/code&gt; &lt;a href=&quot;../../../clip_by_value&quot;&gt; &lt;code&gt;tf.clip_by_value&lt;/code&gt; &lt;/a&gt; ]などの出力範囲を保証するには、tf.clip_by_valueを出力に適用します。</target>
        </trans-unit>
        <trans-unit id="e8fedfebee027b536f10130b6d675ab2045757c3" translate="yes" xml:space="preserve">
          <source>The range of pixel values for the output image might be slightly different from the range for the input image because of limited numerical precision. To guarantee an output range, for example &lt;code&gt;[0.0, 1.0]&lt;/code&gt;, apply &lt;a href=&quot;../clip_by_value&quot;&gt;&lt;code&gt;tf.clip_by_value&lt;/code&gt;&lt;/a&gt; to the output.</source>
          <target state="translated">数値の精度が限られているため、出力画像のピクセル値の範囲が入力画像の範囲とわずかに異なる場合があります。 &lt;code&gt;[0.0, 1.0]&lt;/code&gt; &lt;a href=&quot;../clip_by_value&quot;&gt; &lt;code&gt;tf.clip_by_value&lt;/code&gt; &lt;/a&gt; ]などの出力範囲を保証するには、tf.clip_by_valueを出力に適用します。</target>
        </trans-unit>
        <trans-unit id="6294e1714e1b2b241bb1943b70eb74fc15a98222" translate="yes" xml:space="preserve">
          <source>The reason we get 'A2' instead 'A1' on the second call of &lt;a href=&quot;uniform&quot;&gt;&lt;code&gt;tf.random.uniform&lt;/code&gt;&lt;/a&gt; above is because the same &lt;a href=&quot;uniform&quot;&gt;&lt;code&gt;tf.random.uniform&lt;/code&gt;&lt;/a&gt; kernel (i.e. internal representation) is used by TensorFlow for all calls of it with the same arguments, and the kernel maintains an internal counter which is incremented every time it is executed, generating different results.</source>
          <target state="translated">上記の&lt;a href=&quot;uniform&quot;&gt; &lt;code&gt;tf.random.uniform&lt;/code&gt; &lt;/a&gt;の2回目の呼び出しで「A1」の代わりに「A2」を取得する理由は、同じ&lt;a href=&quot;uniform&quot;&gt; &lt;code&gt;tf.random.uniform&lt;/code&gt; &lt;/a&gt;カーネル（つまり内部表現）が、同じ引数を持つすべての呼び出しに対してTensorFlowによって使用されるためです。 、カーネルは、実行されるたびにインクリメントされる内部カウンターを維持し、異なる結果を生成します。</target>
        </trans-unit>
        <trans-unit id="afabff9ee6287914682ddea57965fb5330ae1825" translate="yes" xml:space="preserve">
          <source>The reason we get 'A2' instead 'A1' on the second call of &lt;a href=&quot;uniform&quot;&gt;&lt;code&gt;tf.random.uniform&lt;/code&gt;&lt;/a&gt; above is because the same &lt;a href=&quot;uniform&quot;&gt;&lt;code&gt;tf.random.uniform&lt;/code&gt;&lt;/a&gt; kernel (i.e. internel representation) is used by TensorFlow for all calls of it with the same arguments, and the kernel maintains an internal counter which is incremented every time it is executed, generating different results.</source>
          <target state="translated">上記の&lt;a href=&quot;uniform&quot;&gt; &lt;code&gt;tf.random.uniform&lt;/code&gt; &lt;/a&gt;の2回目の呼び出しで「A1」の代わりに「A2」を取得する理由は、同じ&lt;a href=&quot;uniform&quot;&gt; &lt;code&gt;tf.random.uniform&lt;/code&gt; &lt;/a&gt;カーネル（つまり、インターネル表現）が、同じ引数を持つそのすべての呼び出しに対してTensorFlowによって使用されるためです。 、およびカーネルは、実行されるたびに増分される内部カウンターを維持し、異なる結果を生成します。</target>
        </trans-unit>
        <trans-unit id="466c31e39da78ea430b94cdcadf9fd7405e0f0cf" translate="yes" xml:space="preserve">
          <source>The reason we get 'A2' instead 'A1' on the second call of &lt;a href=&quot;uniform&quot;&gt;&lt;code&gt;tf.random.uniform&lt;/code&gt;&lt;/a&gt; above is because the secand call uses a different operation seed.</source>
          <target state="translated">上記の&lt;a href=&quot;uniform&quot;&gt; &lt;code&gt;tf.random.uniform&lt;/code&gt; &lt;/a&gt;の2回目の呼び出しで「A1」の代わりに「A2」を取得する理由は、secand呼び出しが異なる演算シードを使用するためです。</target>
        </trans-unit>
        <trans-unit id="784df8a2c4aec00572bf8c70feb9ae2a52a2afdd" translate="yes" xml:space="preserve">
          <source>The reason we get 'A2' instead 'A1' on the second call of &lt;a href=&quot;uniform&quot;&gt;&lt;code&gt;tf.random.uniform&lt;/code&gt;&lt;/a&gt; above is because the second call uses a different operation seed.</source>
          <target state="translated">上記の&lt;a href=&quot;uniform&quot;&gt; &lt;code&gt;tf.random.uniform&lt;/code&gt; &lt;/a&gt;の2番目の呼び出しで「A1」の代わりに「A2」を取得する理由は、2番目の呼び出しが異なる操作シードを使用するためです。</target>
        </trans-unit>
        <trans-unit id="1280cfc6968446075563e60ad83288d637db87ba" translate="yes" xml:space="preserve">
          <source>The reconstruct one or more matrices from their LU decomposition(s).</source>
          <target state="translated">1つ以上の行列をLU分解から再構成します。</target>
        </trans-unit>
        <trans-unit id="39397157700bab61929a7d8ce8314e15144efa4b" translate="yes" xml:space="preserve">
          <source>The reduced SparseTensor.</source>
          <target state="translated">縮小されたSparseTensor。</target>
        </trans-unit>
        <trans-unit id="162a81b2ee639009df98d0138880fb964fcbc8fc" translate="yes" xml:space="preserve">
          <source>The reduced Tensor or the reduced SparseTensor if &lt;code&gt;output_is_sparse&lt;/code&gt; is True.</source>
          <target state="translated">&lt;code&gt;output_is_sparse&lt;/code&gt; がTrueの場合、削減されたTensorまたは削減されたSparseTensor 。</target>
        </trans-unit>
        <trans-unit id="1e34999a75a17ec65b85f93cb20fe03874e9d9e8" translate="yes" xml:space="preserve">
          <source>The reduced Tensor.</source>
          <target state="translated">縮小されたテンソル。</target>
        </trans-unit>
        <trans-unit id="fa52820210f038254236a33cd72deaaa4f2921cc" translate="yes" xml:space="preserve">
          <source>The reduced tensor (number of nonzero values).</source>
          <target state="translated">縮小されたテンソル(ゼロ以外の値の数)。</target>
        </trans-unit>
        <trans-unit id="5089f15002ac696c728750d278b7a2bb4b8292fd" translate="yes" xml:space="preserve">
          <source>The reduced tensor, of the same dtype as the input_tensor.</source>
          <target state="translated">input_tensorと同じdtypeの縮小テンソル。</target>
        </trans-unit>
        <trans-unit id="db036397ce15010ca38b7140e4ed7771da72f4bd" translate="yes" xml:space="preserve">
          <source>The reduced tensor, of the same dtype as the input_tensor. Note, for &lt;code&gt;complex64&lt;/code&gt; or &lt;code&gt;complex128&lt;/code&gt; input, the returned &lt;code&gt;Tensor&lt;/code&gt; will be of type &lt;code&gt;float32&lt;/code&gt; or &lt;code&gt;float64&lt;/code&gt;, respectively.</source>
          <target state="translated">input_tensorと同じdtypeの縮小テンソル。 &lt;code&gt;complex64&lt;/code&gt; または &lt;code&gt;complex128&lt;/code&gt; 入力の場合、返される &lt;code&gt;Tensor&lt;/code&gt; のタイプはそれぞれ &lt;code&gt;float32&lt;/code&gt; または &lt;code&gt;float64&lt;/code&gt; であることに注意してください。</target>
        </trans-unit>
        <trans-unit id="377005a84a788fcaae09139342bfe31ee6c3e407" translate="yes" xml:space="preserve">
          <source>The reduced tensor.</source>
          <target state="translated">縮小されたテンソル。</target>
        </trans-unit>
        <trans-unit id="4ca20066ecafb2f76458db7f5aae15b94f4599bf" translate="yes" xml:space="preserve">
          <source>The reduction to apply to the shard losses.</source>
          <target state="translated">シャードロスに適用される軽減。</target>
        </trans-unit>
        <trans-unit id="32126f130f539d8b348c3776e0d288e0eb3023ae" translate="yes" xml:space="preserve">
          <source>The reference to the TensorArray.</source>
          <target state="translated">TensorArrayへの参照です。</target>
        </trans-unit>
        <trans-unit id="bec5f1d035188c5f615977438d1fd8d80cd736d2" translate="yes" xml:space="preserve">
          <source>The regular expressions we want to match against str. See &quot;Notes&quot; above for detailed notes on how this is interpreted.</source>
          <target state="translated">strに対してマッチさせたい正規表現。これがどのように解釈されるかについては、上記の &quot;注意事項&quot; を参照してください。</target>
        </trans-unit>
        <trans-unit id="626421317b8daa7c4481578d7b1400cbc817027c" translate="yes" xml:space="preserve">
          <source>The regularized incomplete beta integral is defined as:</source>
          <target state="translated">正則化された不完全ベータ積分は次のように定義される。</target>
        </trans-unit>
        <trans-unit id="6b4ae5690943cd94c52d8b3b53e424b70c0a6f84" translate="yes" xml:space="preserve">
          <source>The remapping tensors can be generated using the GenerateVocabRemapping op.</source>
          <target state="translated">リマップテンソルはGenerateVocabRemapping op.を使って生成できます。</target>
        </trans-unit>
        <trans-unit id="6f76fd4e0a09c22f0b1432236fcf10360b759293" translate="yes" xml:space="preserve">
          <source>The remappings are 1-D tensors with the following properties:</source>
          <target state="translated">リマッピングは以下の性質を持つ1次元テンソルです。</target>
        </trans-unit>
        <trans-unit id="4eb549ec0edb51386556b04bcb293e63f29c79c8" translate="yes" xml:space="preserve">
          <source>The replacement character codepoint to be used in place of any invalid input when &lt;code&gt;errors='replace'&lt;/code&gt;. Any valid unicode codepoint may be used. The default value is the default unicode replacement character which is 0xFFFD (U+65533).</source>
          <target state="translated">&lt;code&gt;errors='replace'&lt;/code&gt; の場合に、無効な入力の代わりに使用される置換文字コードポイント。任意の有効なUnicodeコードポイントを使用できます。デフォルト値は、0xFFFD（U + 65533）であるデフォルトのUnicode置換文字です。</target>
        </trans-unit>
        <trans-unit id="dc58567cf18ed1da38d660adbff7112eaf4a0c43" translate="yes" xml:space="preserve">
          <source>The replacement codepoint to be used in place of invalid substrings in &lt;code&gt;input&lt;/code&gt; when &lt;code&gt;errors='replace'&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;errors='replace'&lt;/code&gt; の場合、 &lt;code&gt;input&lt;/code&gt; の無効な部分文字列の代わりに使用される置換コードポイント。</target>
        </trans-unit>
        <trans-unit id="5861bd77b8284cbd383ce9fa80004e5915d9c8c5" translate="yes" xml:space="preserve">
          <source>The replacement codepoint to be used in place of invalid substrings in &lt;code&gt;input&lt;/code&gt; when &lt;code&gt;errors='replace'&lt;/code&gt;; and in place of C0 control characters in &lt;code&gt;input&lt;/code&gt; when &lt;code&gt;replace_control_characters=True&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;errors='replace'&lt;/code&gt; ;の場合、 &lt;code&gt;input&lt;/code&gt; の無効な部分文字列の代わりに使用される置換コードポイント。そして、 &lt;code&gt;replace_control_characters=True&lt;/code&gt; の場合、 &lt;code&gt;input&lt;/code&gt; C0制御文字の代わりに。</target>
        </trans-unit>
        <trans-unit id="08f7982eae76c3d1b8d5c546c5c6087586c14c26" translate="yes" xml:space="preserve">
          <source>The request does not have valid authentication credentials.</source>
          <target state="translated">要求には有効な認証資格情報がありません。</target>
        </trans-unit>
        <trans-unit id="11fac311a887cb1b94b956ea27985cb8f91c9eab" translate="yes" xml:space="preserve">
          <source>The requirements to use the cuDNN implementation are:</source>
          <target state="translated">cuDNNの実装を使用するための要件は、以下の通りです。</target>
        </trans-unit>
        <trans-unit id="b7f944aa478f301b9d7d37d3ac6e02aa0ab614e1" translate="yes" xml:space="preserve">
          <source>The rescaling is applied both during training and inference.</source>
          <target state="translated">再スケーリングは、学習中と推論中の両方に適用されます。</target>
        </trans-unit>
        <trans-unit id="e10dd1c4bdea08780ec12768ba2f0c0cc6e6418e" translate="yes" xml:space="preserve">
          <source>The resizing Ops accept input images as tensors of several types. They always output resized images as float32 tensors.</source>
          <target state="translated">リサイズ操作は、入力画像をいくつかのタイプのテンソルとして受け入れます。彼らは常にリサイズされた画像を float32 テンソルとして出力します。</target>
        </trans-unit>
        <trans-unit id="5f32138dd7f669a33bea7319cf66264923452d20" translate="yes" xml:space="preserve">
          <source>The restored checkpoint path if the lastest checkpoint is found and restored. Otherwise None.</source>
          <target state="translated">直近のチェックポイントが検出され、リストアされた場合、リストアされたチェックポイント・パス。それ以外の場合は None。</target>
        </trans-unit>
        <trans-unit id="d06ff612c69fb3df1f3d794bb785e13f8da40620" translate="yes" xml:space="preserve">
          <source>The result is a 4-D tensor of shape &lt;code&gt;[batch_size, glimpse_height, glimpse_width, channels]&lt;/code&gt;. The channels and batch dimensions are the same as that of the input tensor. The height and width of the output windows are specified in the &lt;code&gt;size&lt;/code&gt; parameter.</source>
          <target state="translated">結果は、形状 &lt;code&gt;[batch_size, glimpse_height, glimpse_width, channels]&lt;/code&gt; 4次元テンソルです。チャネルとバッチの次元は、入力テンソルの次元と同じです。出力ウィンドウの高さと幅は、 &lt;code&gt;size&lt;/code&gt; パラメータで指定されます。</target>
        </trans-unit>
        <trans-unit id="af8e15d374bd08a8ea2bebed96d25f27af99cc58" translate="yes" xml:space="preserve">
          <source>The result is a 4D tensor which is indexed by batch, row, and column. &lt;code&gt;output[i, x, y]&lt;/code&gt; contains a flattened patch of size &lt;code&gt;sizes[1], sizes[2]&lt;/code&gt; which is taken from the input starting at &lt;code&gt;images[i, x*strides[1], y*strides[2]]&lt;/code&gt;.</source>
          <target state="translated">結果は、バッチ、行、および列によってインデックスが付けられた4Dテンソルです。 &lt;code&gt;output[i, x, y]&lt;/code&gt; は、 &lt;code&gt;images[i, x*strides[1], y*strides[2]]&lt;/code&gt; から始まる入力から取得されたサイズ &lt;code&gt;sizes[1], sizes[2]&lt;/code&gt; 平坦化されたパッチが含まれています。</target>
        </trans-unit>
        <trans-unit id="3408db8eec06fef64e88ca8c2438893f2827e593" translate="yes" xml:space="preserve">
          <source>The result is a [..., M+1, M] matrix with [..., 0,:] containing the eigenvalues, and subsequent [...,1:, :] containing the eigenvectors. The eigenvalues are sorted in non-decreasing order.</source>
          <target state="translated">結果は,固有値を含む[...,0,:]と固有ベクトルを含む[...,1:,:]を持つ[...,M+1,M]行列となります.固有値は減らない順にソートされます.</target>
        </trans-unit>
        <trans-unit id="91e981525729cfb7323f601fab3d959548453e14" translate="yes" xml:space="preserve">
          <source>The result is not a global index to the entire &lt;code&gt;Tensor&lt;/code&gt;, but rather just the index in the last dimension.</source>
          <target state="translated">結果は、 &lt;code&gt;Tensor&lt;/code&gt; 全体のグローバルインデックスではなく、最後の次元のインデックスだけです。</target>
        </trans-unit>
        <trans-unit id="cc0fc847805d05865dd1fc80479599ef10e030da" translate="yes" xml:space="preserve">
          <source>The result of calling parse_example on these examples will produce a dictionary with entries for &quot;ids&quot; and &quot;values&quot;. Passing those two objects to this function along with vocab_size=6, will produce a &lt;code&gt;SparseTensor&lt;/code&gt; that sparsely represents all three instances. Namely, the &lt;code&gt;indices&lt;/code&gt; property will contain the coordinates of the non-zero entries in the feature matrix (the first dimension is the row number in the matrix, i.e., the index within the batch, and the second dimension is the column number, i.e., the feature id); &lt;code&gt;values&lt;/code&gt; will contain the actual values. &lt;code&gt;shape&lt;/code&gt; will be the shape of the original matrix, i.e., (3, 6). For our example above, the output will be equal to:</source>
          <target state="translated">これらの例でparse_exampleを呼び出した結果は、「ids」と「values」のエントリを持つディクショナリを生成します。これら2つのオブジェクトをvocab_size = 6とともにこの関数に &lt;code&gt;SparseTensor&lt;/code&gt; と、3つのインスタンスすべてをまばらに表すSparseTensorが生成されます。つまり、 &lt;code&gt;indices&lt;/code&gt; プロパティには、機能マトリックスのゼロ以外のエントリの座標が含まれます（最初の次元はマトリックスの行番号、つまりバッチ内のインデックスで、2番目の次元は列番号です）。機能ID）; &lt;code&gt;values&lt;/code&gt; には実際の値が含まれます。 &lt;code&gt;shape&lt;/code&gt; は元のマトリックスの形状、つまり（3、6）になります。上記の例では、出力は次のようになります。</target>
        </trans-unit>
        <trans-unit id="c532f85716ab7d9d5ac1221540a16a00cf14d0f8" translate="yes" xml:space="preserve">
          <source>The result of one inference step, typically the output of calling the &lt;code&gt;Model&lt;/code&gt; on data.</source>
          <target state="translated">1つの推論ステップの結果、通常はデータに対して &lt;code&gt;Model&lt;/code&gt; を呼び出すことの出力。</target>
        </trans-unit>
        <trans-unit id="b712de5339fc3e663594598e87ccb0f331d98d0d" translate="yes" xml:space="preserve">
          <source>The result of the elementwise &lt;code&gt;!=&lt;/code&gt; operation, or &lt;code&gt;True&lt;/code&gt; if the arguments are not broadcast-compatible.</source>
          <target state="translated">要素ごとの &lt;code&gt;!=&lt;/code&gt; 演算の結果、または引数がブロードキャスト互換でない場合は &lt;code&gt;True&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="65bf62ac9a12a3ed583f3696b9ec4dfdd36908c0" translate="yes" xml:space="preserve">
          <source>The result of the elementwise &lt;code&gt;+&lt;/code&gt; operation.</source>
          <target state="translated">要素ごとの &lt;code&gt;+&lt;/code&gt; 演算の結果。</target>
        </trans-unit>
        <trans-unit id="4a0379f511e04f35dbfdf4e95a15f796515177e5" translate="yes" xml:space="preserve">
          <source>The result of the elementwise &lt;code&gt;==&lt;/code&gt; operation, or &lt;code&gt;False&lt;/code&gt; if the arguments are not broadcast-compatible.</source>
          <target state="translated">elementwise &lt;code&gt;==&lt;/code&gt; 操作の結果、または引数がブロードキャスト互換でない場合は &lt;code&gt;False&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a7181bf7e73106c9b2b97d9fffba14ef65fbf1f8" translate="yes" xml:space="preserve">
          <source>The result of this op should be passed through a &lt;code&gt;sparse_to_dense&lt;/code&gt; operation, then added to the logits of the sampled classes. This removes the contradictory effect of accidentally sampling the true target classes as noise classes for the same example.</source>
          <target state="translated">この操作の結果は、 &lt;code&gt;sparse_to_dense&lt;/code&gt; オペレーションを介して渡され、サンプリングされたクラスのロジットに追加されます。これにより、同じ例の真のターゲットクラスをノイズクラスとして誤ってサンプリングするという矛盾した影響が取り除かれます。</target>
        </trans-unit>
        <trans-unit id="95bce95270c24fcef8ff10f45294119d2cbaf8aa" translate="yes" xml:space="preserve">
          <source>The result will be biased towards the initial value of the variable.</source>
          <target state="translated">結果は変数の初期値に偏ります。</target>
        </trans-unit>
        <trans-unit id="01298564c21aafdba5ad8531a719b0b62528e9fe" translate="yes" xml:space="preserve">
          <source>The result will have those bits set, that are different in &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;. The computation is performed on the underlying representations of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">結果には、 &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; が異なるビットが設定されます。計算は、 &lt;code&gt;x&lt;/code&gt; および &lt;code&gt;y&lt;/code&gt; の基礎となる表現に対して実行されます。</target>
        </trans-unit>
        <trans-unit id="685b62e5962fffb0313c314fe8766a83e91dc7ce" translate="yes" xml:space="preserve">
          <source>The result will have those bits set, that are set in &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt; or both. The computation is performed on the underlying representations of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">結果には、 &lt;code&gt;x&lt;/code&gt; 、 &lt;code&gt;y&lt;/code&gt; 、またはその両方で設定されたビットが設定されます。計算は、 &lt;code&gt;x&lt;/code&gt; および &lt;code&gt;y&lt;/code&gt; の基礎となる表現に対して実行されます。</target>
        </trans-unit>
        <trans-unit id="b74f37adc87a210e3154c60f498551da0c0a3084" translate="yes" xml:space="preserve">
          <source>The result will have those bits set, that are set in both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;. The computation is performed on the underlying representations of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">結果には、 &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; の両方に設定されているビットが設定されます。計算は、 &lt;code&gt;x&lt;/code&gt; および &lt;code&gt;y&lt;/code&gt; の基礎となる表現に対して実行されます。</target>
        </trans-unit>
        <trans-unit id="a454b218545175a81109283a1b62827f2751cc1d" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Tensor&lt;/code&gt; of parsing a single &lt;code&gt;SequenceExample&lt;/code&gt; or &lt;code&gt;Example&lt;/code&gt; has a static &lt;code&gt;shape&lt;/code&gt; of &lt;code&gt;[None] + shape&lt;/code&gt; and the specified &lt;code&gt;dtype&lt;/code&gt;. The resulting &lt;code&gt;Tensor&lt;/code&gt; of parsing a &lt;code&gt;batch_size&lt;/code&gt; many &lt;code&gt;Example&lt;/code&gt;s has a static &lt;code&gt;shape&lt;/code&gt; of &lt;code&gt;[batch_size, None] + shape&lt;/code&gt; and the specified &lt;code&gt;dtype&lt;/code&gt;. The entries in the &lt;code&gt;batch&lt;/code&gt; from different &lt;code&gt;Examples&lt;/code&gt; will be padded with &lt;code&gt;default_value&lt;/code&gt; to the maximum length present in the &lt;code&gt;batch&lt;/code&gt;.</source>
          <target state="translated">得られた &lt;code&gt;Tensor&lt;/code&gt; 単一解析の &lt;code&gt;SequenceExample&lt;/code&gt; をまたは &lt;code&gt;Example&lt;/code&gt; 静的有する &lt;code&gt;shape&lt;/code&gt; の &lt;code&gt;[None] + shape&lt;/code&gt; と指定 &lt;code&gt;dtype&lt;/code&gt; 。得られた &lt;code&gt;Tensor&lt;/code&gt; 解析の &lt;code&gt;batch_size&lt;/code&gt; 多くの &lt;code&gt;Example&lt;/code&gt; Sは静的有する &lt;code&gt;shape&lt;/code&gt; の &lt;code&gt;[batch_size, None] + shape&lt;/code&gt; と指定 &lt;code&gt;dtype&lt;/code&gt; 。エントリ &lt;code&gt;batch&lt;/code&gt; 別の &lt;code&gt;Examples&lt;/code&gt; でパディングする &lt;code&gt;default_value&lt;/code&gt; の最大長に存在する &lt;code&gt;batch&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3a538e992c4e715c1f91b7c40110e2510e29c989" translate="yes" xml:space="preserve">
          <source>The resulting SavedModel is then servable with an input named &quot;x&quot;, its value having any shape and dtype float32.</source>
          <target state="translated">結果として得られる SavedModel は &quot;x&quot; という名前の入力を持つサーブ可能なものとなり、その値は任意の形状を持ち、dtype は float32 となります。</target>
        </trans-unit>
        <trans-unit id="b71ce2b54de94b7e8ecf2e651366ba952c5ce3a3" translate="yes" xml:space="preserve">
          <source>The resulting dataset is similar to the &lt;code&gt;InterleaveDataset&lt;/code&gt;, except that the dataset will fetch records from the interleaved datasets in parallel.</source>
          <target state="translated">結果のデータセットは &lt;code&gt;InterleaveDataset&lt;/code&gt; に似ていますが、データセットがインターリーブされたデータセットからレコードを並列にフェッチする点が異なります。</target>
        </trans-unit>
        <trans-unit id="5d8659c50ab2dced91f800b38d49965e49b25d1c" translate="yes" xml:space="preserve">
          <source>The resulting dataset is similar to the &lt;code&gt;InterleaveDataset&lt;/code&gt;, with the exception that if retrieving the next value from a dataset would cause the requester to block, it will skip that input dataset. This dataset is especially useful when loading data from a variable-latency datastores (e.g. HDFS, GCS), as it allows the training step to proceed so long as some data is available.</source>
          <target state="translated">結果のデータセットは &lt;code&gt;InterleaveDataset&lt;/code&gt; に似ていますが、データセットから次の値を取得するとリクエスターがブロックされる場合、その入力データセットがスキップされる点が異なります。このデータセットは、可変レイテンシのデータストア（HDFS、GCSなど）からデータを読み込むときに特に役立ちます。これにより、一部のデータが利用可能である限り、トレーニング手順を続行できます。</target>
        </trans-unit>
        <trans-unit id="fd835a476d97294a9a531a06c729ae1427276dc8" translate="yes" xml:space="preserve">
          <source>The resulting function is assumed stateful and will never be optimized.</source>
          <target state="translated">結果として得られる関数はステートフルであると仮定され、最適化されることはありません。</target>
        </trans-unit>
        <trans-unit id="1f53b61193a80c029c5a448efed06c1a8f6588c5" translate="yes" xml:space="preserve">
          <source>The resulting output shape when using the &quot;same&quot; padding option is: &lt;code&gt;output_shape = input_shape / strides&lt;/code&gt;</source>
          <target state="translated">「同じ」パディングオプションを使用した場合の結果の出力形状は次の &lt;code&gt;output_shape = input_shape / strides&lt;/code&gt; です。output_shape= input_shape / strides</target>
        </trans-unit>
        <trans-unit id="9ef25e64d2e423f7de1f3a02ba7a25085c38c8a1" translate="yes" xml:space="preserve">
          <source>The resulting tensor is populated with values of type &lt;code&gt;dtype&lt;/code&gt;, as specified by arguments &lt;code&gt;value&lt;/code&gt; and (optionally) &lt;code&gt;shape&lt;/code&gt; (see examples below).</source>
          <target state="translated">結果のテンソルには、引数の &lt;code&gt;value&lt;/code&gt; と（オプションで） &lt;code&gt;shape&lt;/code&gt; 指定された &lt;code&gt;dtype&lt;/code&gt; 型の値が入力されます（以下の例を参照）。</target>
        </trans-unit>
        <trans-unit id="0b674f3072695f2111704701dbc3947bfb383f3f" translate="yes" xml:space="preserve">
          <source>The resulting tensor is populated with values of type &lt;code&gt;dtype&lt;/code&gt;, as specified by arguments &lt;code&gt;value&lt;/code&gt; following the desired &lt;code&gt;shape&lt;/code&gt; of the new tensor (see examples below).</source>
          <target state="translated">結果のテンソルには、新しいテンソルの目的の &lt;code&gt;shape&lt;/code&gt; に続く引数の &lt;code&gt;value&lt;/code&gt; 指定された、タイプ &lt;code&gt;dtype&lt;/code&gt; の値が入力されます（以下の例を参照）。</target>
        </trans-unit>
        <trans-unit id="ef74e8f16df07a307babda0cfa120db0e980020d" translate="yes" xml:space="preserve">
          <source>The resulting tensor would look like this:</source>
          <target state="translated">結果として得られるテンソルは次のようになります。</target>
        </trans-unit>
        <trans-unit id="381b1e6543678db4ed459c1cba156ecc8ca01172" translate="yes" xml:space="preserve">
          <source>The resulting update to ref would look like this:</source>
          <target state="translated">refへの更新の結果は次のようになります。</target>
        </trans-unit>
        <trans-unit id="cbbd169c06c5469910e771887e06b5ed0c01b738" translate="yes" xml:space="preserve">
          <source>The resulting update to v would look like this:</source>
          <target state="translated">その結果、vへの更新は次のようになります。</target>
        </trans-unit>
        <trans-unit id="993bb51caef566927c6f2034eead7ae47fdb56d0" translate="yes" xml:space="preserve">
          <source>The resulting value &lt;code&gt;output&lt;/code&gt; would look like this:</source>
          <target state="translated">結果の値の &lt;code&gt;output&lt;/code&gt; は次のようになります。</target>
        </trans-unit>
        <trans-unit id="5cc6293ac412a772df6f0e78ca55482c98eb64a2" translate="yes" xml:space="preserve">
          <source>The results of the lookup are concatenated into a dense tensor. The returned tensor has shape &lt;code&gt;shape(ids) + shape(params)[1:]&lt;/code&gt;.</source>
          <target state="translated">ルックアップの結果は、密なテンソルに連結されます。返されるテンソルの形状は &lt;code&gt;shape(ids) + shape(params)[1:]&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="2f1f40e1bca978cc7aa38e548317ee19cb7dfd8c" translate="yes" xml:space="preserve">
          <source>The return value has the same type as &lt;code&gt;images&lt;/code&gt; if &lt;code&gt;method&lt;/code&gt; is &lt;a href=&quot;../../../image/resizemethod#NEAREST_NEIGHBOR&quot;&gt;&lt;code&gt;ResizeMethod.NEAREST_NEIGHBOR&lt;/code&gt;&lt;/a&gt;. It will also have the same type as &lt;code&gt;images&lt;/code&gt; if the size of &lt;code&gt;images&lt;/code&gt; can be statically determined to be the same as &lt;code&gt;size&lt;/code&gt;, because &lt;code&gt;images&lt;/code&gt; is returned in this case. Otherwise, the return value has type &lt;code&gt;float32&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;method&lt;/code&gt; が&lt;a href=&quot;../../../image/resizemethod#NEAREST_NEIGHBOR&quot;&gt; &lt;code&gt;ResizeMethod.NEAREST_NEIGHBOR&lt;/code&gt; の&lt;/a&gt;場合、戻り値は &lt;code&gt;images&lt;/code&gt; と同じ型になります。それはまた、同様のタイプがあります &lt;code&gt;images&lt;/code&gt; のサイズ場合 &lt;code&gt;images&lt;/code&gt; 静的と同じであると判断することができる &lt;code&gt;size&lt;/code&gt; ので、 &lt;code&gt;images&lt;/code&gt; この場合に返されます。それ以外の場合、戻り値の型は &lt;code&gt;float32&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="d56a51802c9fd20b938ff0224e17cc92fbe0a0fd" translate="yes" xml:space="preserve">
          <source>The return value has the same type as &lt;code&gt;images&lt;/code&gt; if &lt;code&gt;method&lt;/code&gt; is &lt;a href=&quot;../../../image/resizemethod#NEAREST_NEIGHBOR&quot;&gt;&lt;code&gt;tf.image.ResizeMethod.NEAREST_NEIGHBOR&lt;/code&gt;&lt;/a&gt;. It will also have the same type as &lt;code&gt;images&lt;/code&gt; if the size of &lt;code&gt;images&lt;/code&gt; can be statically determined to be the same as &lt;code&gt;size&lt;/code&gt;, because &lt;code&gt;images&lt;/code&gt; is returned in this case. Otherwise, the return value has type &lt;code&gt;float32&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;method&lt;/code&gt; が&lt;a href=&quot;../../../image/resizemethod#NEAREST_NEIGHBOR&quot;&gt; &lt;code&gt;tf.image.ResizeMethod.NEAREST_NEIGHBOR&lt;/code&gt; の&lt;/a&gt;場合、戻り値は &lt;code&gt;images&lt;/code&gt; と同じタイプになります。それはまた、同様のタイプがあります &lt;code&gt;images&lt;/code&gt; のサイズ場合 &lt;code&gt;images&lt;/code&gt; 静的と同じであると判断することができる &lt;code&gt;size&lt;/code&gt; ので、 &lt;code&gt;images&lt;/code&gt; この場合に返されます。それ以外の場合、戻り値の型は &lt;code&gt;float32&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="90335752084dfbdd6479bc3425e07c2c184fac03" translate="yes" xml:space="preserve">
          <source>The return value has the same type as &lt;code&gt;images&lt;/code&gt; if &lt;code&gt;method&lt;/code&gt; is &lt;a href=&quot;resizemethod#NEAREST_NEIGHBOR&quot;&gt;&lt;code&gt;ResizeMethod.NEAREST_NEIGHBOR&lt;/code&gt;&lt;/a&gt;. Otherwise, the return value has type &lt;code&gt;float32&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;method&lt;/code&gt; が&lt;a href=&quot;resizemethod#NEAREST_NEIGHBOR&quot;&gt; &lt;code&gt;ResizeMethod.NEAREST_NEIGHBOR&lt;/code&gt; の&lt;/a&gt;場合、戻り値は &lt;code&gt;images&lt;/code&gt; と同じ型になります。それ以外の場合、戻り値の型は &lt;code&gt;float32&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="8d380f2c5d4525994512f90f349c7eb51132c6e2" translate="yes" xml:space="preserve">
          <source>The return value has type &lt;code&gt;float32&lt;/code&gt;, unless the &lt;code&gt;method&lt;/code&gt; is &lt;a href=&quot;resizemethod#NEAREST_NEIGHBOR&quot;&gt;&lt;code&gt;ResizeMethod.NEAREST_NEIGHBOR&lt;/code&gt;&lt;/a&gt;, then the return dtype is the dtype of &lt;code&gt;images&lt;/code&gt;:</source>
          <target state="translated">戻り値は、型有し &lt;code&gt;float32&lt;/code&gt; しない限り、 &lt;code&gt;method&lt;/code&gt; ある&lt;a href=&quot;resizemethod#NEAREST_NEIGHBOR&quot;&gt; &lt;code&gt;ResizeMethod.NEAREST_NEIGHBOR&lt;/code&gt; &lt;/a&gt;、戻りDTYPEはDTYPEのある &lt;code&gt;images&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6db6bf11d3c25e837bbcedc93fcb0930b2a99ab3" translate="yes" xml:space="preserve">
          <source>The return value is not the same Tensor as the original, but contains the same values. This operation is fast when used on the same device.</source>
          <target state="translated">戻り値は元のTensorと同じではなく、同じ値が含まれています。この操作は、同じデバイスで使用すると高速です。</target>
        </trans-unit>
        <trans-unit id="3e3b67eed807726677126c856d0a6214fa8f8e4a" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;merge_fn&lt;/code&gt;, except for &lt;code&gt;PerReplica&lt;/code&gt; values which are unpacked.</source>
          <target state="translated">&lt;code&gt;PerReplica&lt;/code&gt; れていないPerReplica値を除いて、 &lt;code&gt;merge_fn&lt;/code&gt; の戻り値。</target>
        </trans-unit>
        <trans-unit id="b729f575891182a1cf2b646557e584015983e0cf" translate="yes" xml:space="preserve">
          <source>The return values from &lt;code&gt;Session.run()&lt;/code&gt; corresponding to the fetches attribute returned in the RunArgs. Note that this has the same shape as the RunArgs fetches. For example: fetches = global_step_tensor =&amp;gt; results = nparray(int) fetches = [train_op, summary_op, global_step_tensor] =&amp;gt; results = [None, nparray(string), nparray(int)] fetches = {'step': global_step_tensor, 'summ': summary_op} =&amp;gt; results = {'step': nparray(int), 'summ': nparray(string)}</source>
          <target state="translated">RunArgsで返されるfetches属性に対応する &lt;code&gt;Session.run()&lt;/code&gt; からの戻り値。これは、RunArgsがフェッチするのと同じ形状であることに注意してください。例：fetchs = global_step_tensor =&amp;gt; results = nparray（int）fetchs = [train_op、summary_op、global_step_tensor] =&amp;gt; results = [None、nparray（string）、nparray（int）] fetchs = {'step'：global_step_tensor、 ' summ '：summary_op} =&amp;gt;結果= {' step '：nparray（int）、' summ '：nparray（string）}</target>
        </trans-unit>
        <trans-unit id="1e968254f01cab6234b67bba030e47e2fb4dbf82" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;../../../../distribute/distributeddataset&quot;&gt;&lt;code&gt;tf.distribute.DistributedDataset&lt;/code&gt;&lt;/a&gt; can be iterated over similar to how regular datasets can. NOTE: The user cannot add any more transformations to a &lt;a href=&quot;../../../../distribute/distributeddataset&quot;&gt;&lt;code&gt;tf.distribute.DistributedDataset&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">返される&lt;a href=&quot;../../../../distribute/distributeddataset&quot;&gt; &lt;code&gt;tf.distribute.DistributedDataset&lt;/code&gt; &lt;/a&gt;は、通常のデータセットと同様に繰り返すことができます。注：ユーザーは、&lt;a href=&quot;../../../../distribute/distributeddataset&quot;&gt; &lt;code&gt;tf.distribute.DistributedDataset&lt;/code&gt; に&lt;/a&gt;これ以上変換を追加することはできません。</target>
        </trans-unit>
        <trans-unit id="e54bb88894be8aec22542ba047bf035708660a8b" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;../../../distribute/distributeddataset&quot;&gt;&lt;code&gt;tf.distribute.DistributedDataset&lt;/code&gt;&lt;/a&gt; can be iterated over similar to how regular datasets can. NOTE: The user cannot add any more transformations to a &lt;a href=&quot;../../../distribute/distributeddataset&quot;&gt;&lt;code&gt;tf.distribute.DistributedDataset&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">返される&lt;a href=&quot;../../../distribute/distributeddataset&quot;&gt; &lt;code&gt;tf.distribute.DistributedDataset&lt;/code&gt; &lt;/a&gt;は、通常のデータセットと同様に繰り返すことができます。注：ユーザーは、&lt;a href=&quot;../../../distribute/distributeddataset&quot;&gt; &lt;code&gt;tf.distribute.DistributedDataset&lt;/code&gt; に&lt;/a&gt;これ以上変換を追加することはできません。</target>
        </trans-unit>
        <trans-unit id="1bc73b952597eebba1bc9614e25b86603811dd74" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;../distributeddataset&quot;&gt;&lt;code&gt;tf.distribute.DistributedDataset&lt;/code&gt;&lt;/a&gt; can be iterated over similar to how regular datasets can. NOTE: The user cannot add any more transformations to a &lt;a href=&quot;../distributeddataset&quot;&gt;&lt;code&gt;tf.distribute.DistributedDataset&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">返される&lt;a href=&quot;../distributeddataset&quot;&gt; &lt;code&gt;tf.distribute.DistributedDataset&lt;/code&gt; &lt;/a&gt;は、通常のデータセットと同様に繰り返すことができます。注：ユーザーは、&lt;a href=&quot;../distributeddataset&quot;&gt; &lt;code&gt;tf.distribute.DistributedDataset&lt;/code&gt; に&lt;/a&gt;これ以上変換を追加することはできません。</target>
        </trans-unit>
        <trans-unit id="77573df9f9325728fade9f377ed047dae4204229" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;distributeddataset&quot;&gt;&lt;code&gt;tf.distribute.DistributedDataset&lt;/code&gt;&lt;/a&gt; can be iterated over similar to how regular datasets can. NOTE: The user cannot add any more transformations to a &lt;a href=&quot;distributeddataset&quot;&gt;&lt;code&gt;tf.distribute.DistributedDataset&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">返される&lt;a href=&quot;distributeddataset&quot;&gt; &lt;code&gt;tf.distribute.DistributedDataset&lt;/code&gt; &lt;/a&gt;は、通常のデータセットと同様に繰り返すことができます。注：ユーザーは、&lt;a href=&quot;distributeddataset&quot;&gt; &lt;code&gt;tf.distribute.DistributedDataset&lt;/code&gt; に&lt;/a&gt;これ以上変換を追加することはできません。</target>
        </trans-unit>
        <trans-unit id="1dea02fa1b7f8947a51fb716ddcefda916820715" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;tensorshape&quot;&gt;&lt;code&gt;tf.TensorShape&lt;/code&gt;&lt;/a&gt; is determined at &lt;em&gt;build&lt;/em&gt; time, without executing the underlying kernel. It is not a &lt;a href=&quot;tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt;. If you need a shape &lt;em&gt;tensor&lt;/em&gt;, either convert the &lt;a href=&quot;tensorshape&quot;&gt;&lt;code&gt;tf.TensorShape&lt;/code&gt;&lt;/a&gt; to a &lt;a href=&quot;constant&quot;&gt;&lt;code&gt;tf.constant&lt;/code&gt;&lt;/a&gt;, or use the &lt;a href=&quot;shape&quot;&gt;&lt;code&gt;tf.shape(tensor)&lt;/code&gt;&lt;/a&gt; function, which returns the tensor's shape at &lt;em&gt;execution&lt;/em&gt; time.</source>
          <target state="translated">返される&lt;a href=&quot;tensorshape&quot;&gt; &lt;code&gt;tf.TensorShape&lt;/code&gt; &lt;/a&gt;は、基盤となるカーネルを実行せずに、&lt;em&gt;ビルド&lt;/em&gt;時に決定されます。&lt;a href=&quot;tensor&quot;&gt; &lt;code&gt;tf.Tensor&lt;/code&gt; で&lt;/a&gt;はありません。あなたは形状が必要な場合&lt;em&gt;テンソルを&lt;/em&gt;、いずれかの変換&lt;a href=&quot;tensorshape&quot;&gt; &lt;code&gt;tf.TensorShape&lt;/code&gt; を&lt;/a&gt;する&lt;a href=&quot;constant&quot;&gt; &lt;code&gt;tf.constant&lt;/code&gt; &lt;/a&gt;、または使用&lt;a href=&quot;shape&quot;&gt; &lt;code&gt;tf.shape(tensor)&lt;/code&gt; &lt;/a&gt;でテンソルの形状を返す関数、&lt;em&gt;実行&lt;/em&gt;時間を。</target>
        </trans-unit>
        <trans-unit id="111bba19cc7fb0062ed6fe66a53428292ab2ad62" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;RaggedTensor&lt;/code&gt; corresponds with the python list defined by:</source>
          <target state="translated">返される &lt;code&gt;RaggedTensor&lt;/code&gt; は、次で定義されるpythonリストに対応します。</target>
        </trans-unit>
        <trans-unit id="ecbcae5eb984661e7de2445f57c60c5e40e3d894" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;Session&lt;/code&gt; will be the innermost session on which a &lt;code&gt;Session&lt;/code&gt; or &lt;code&gt;Session.as_default()&lt;/code&gt; context has been entered.</source>
          <target state="translated">返された &lt;code&gt;Session&lt;/code&gt; は、 &lt;code&gt;Session&lt;/code&gt; または &lt;code&gt;Session.as_default()&lt;/code&gt; コンテキストが入力された最も内側のセッションになります。</target>
        </trans-unit>
        <trans-unit id="95a65357f0f57659490bed4f233c4a4d8fc08588" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;Tensor&lt;/code&gt; will be close to an exact solution if &lt;code&gt;A&lt;/code&gt; is well conditioned. Otherwise closeness will vary. See class docstring for details.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; が十分条件付けされている場合、返される &lt;code&gt;Tensor&lt;/code&gt; は正確な解に近くなります。それ以外の場合、近さは異なります。詳細については、クラスdocstringを参照してください。</target>
        </trans-unit>
        <trans-unit id="210a2253a38d62adf49c231834e4374a228751a1" translate="yes" xml:space="preserve">
          <source>The returned callable will have the same return type as &lt;code&gt;tf.Session.run(fetches, ...)&lt;/code&gt;. For example, if &lt;code&gt;fetches&lt;/code&gt; is a &lt;a href=&quot;../../tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt;, the callable will return a numpy ndarray; if &lt;code&gt;fetches&lt;/code&gt; is a &lt;a href=&quot;../../operation&quot;&gt;&lt;code&gt;tf.Operation&lt;/code&gt;&lt;/a&gt;, it will return &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">返された呼び出し可能オブジェクトは、 &lt;code&gt;tf.Session.run(fetches, ...)&lt;/code&gt; と同じ戻り型を持ちます。たとえば、 &lt;code&gt;fetches&lt;/code&gt; が&lt;a href=&quot;../../tensor&quot;&gt; &lt;code&gt;tf.Tensor&lt;/code&gt; の&lt;/a&gt;場合、呼び出し可能オブジェクトはnumpy ndarrayを返します。 &lt;code&gt;fetches&lt;/code&gt; が&lt;a href=&quot;../../operation&quot;&gt; &lt;code&gt;tf.Operation&lt;/code&gt; の&lt;/a&gt;場合、 &lt;code&gt;None&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="bfdda7d94aac832546a913098111bedb3a5af104" translate="yes" xml:space="preserve">
          <source>The returned callable will take &lt;code&gt;len(feed_list)&lt;/code&gt; arguments whose types must be compatible feed values for the respective elements of &lt;code&gt;feed_list&lt;/code&gt;. For example, if element &lt;code&gt;i&lt;/code&gt; of &lt;code&gt;feed_list&lt;/code&gt; is a &lt;a href=&quot;../../tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt;, the &lt;code&gt;i&lt;/code&gt;th argument to the returned callable must be a numpy ndarray (or something convertible to an ndarray) with matching element type and shape. See &lt;code&gt;tf.Session.run&lt;/code&gt; for details of the allowable feed key and value types.</source>
          <target state="translated">返される呼び出し可能オブジェクトは &lt;code&gt;len(feed_list)&lt;/code&gt; 引数を取り、その型は &lt;code&gt;feed_list&lt;/code&gt; のそれぞれの要素の互換性のあるフィード値でなければなりません。素子たとえば、 &lt;code&gt;i&lt;/code&gt; の &lt;code&gt;feed_list&lt;/code&gt; がある&lt;a href=&quot;../../tensor&quot;&gt; &lt;code&gt;tf.Tensor&lt;/code&gt; &lt;/a&gt;、 &lt;code&gt;i&lt;/code&gt; 返さ呼び出し可能に番目の引数は、整合素子の種類及び形状のnumpyのndarray（又はndarrayに変換可能なもの）でなければなりません。参照 &lt;code&gt;tf.Session.run&lt;/code&gt; を許容フィードキーと値の種類の詳細については。</target>
        </trans-unit>
        <trans-unit id="5ae9baaba07ae2a863bb456cb56b210b15bfeca4" translate="yes" xml:space="preserve">
          <source>The returned dataset is a wrapped strategy dataset which creates a multidevice iterator under the hood. It prefetches the input data to the specified devices on the worker. The returned distributed dataset can be iterated over similar to how regular datasets can.</source>
          <target state="translated">返されるデータセットは、ラップされたストラテジーのデータセットで、フードの下にマルチデバイスイテレータを作成します。これは、ワーカー上の指定されたデバイスに入力データをプリフェッチします。返された分散データセットは、通常のデータセットと同様に反復処理を行うことができます。</target>
        </trans-unit>
        <trans-unit id="b16f128652226cd5df44d3210c5abe8996d2a7b8" translate="yes" xml:space="preserve">
          <source>The returned dict may have the following keys:</source>
          <target state="translated">返されたdictは以下のキーを持つことができます。</target>
        </trans-unit>
        <trans-unit id="6f7e2363fe125c1a5cdb798835abe8de5ac8aef0" translate="yes" xml:space="preserve">
          <source>The returned dictionary can be used as arg 'features' in &lt;a href=&quot;../../../io/parse_example&quot;&gt;&lt;code&gt;tf.io.parse_example&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">返されたディクショナリは、&lt;a href=&quot;../../../io/parse_example&quot;&gt; &lt;code&gt;tf.io.parse_example&lt;/code&gt; の&lt;/a&gt; arg 'features'として使用できます。</target>
        </trans-unit>
        <trans-unit id="27148d9610fe5857a584045bc355cd08d4ce68b2" translate="yes" xml:space="preserve">
          <source>The returned dictionary can be used as arg 'features' in &lt;a href=&quot;../io/parse_example&quot;&gt;&lt;code&gt;tf.io.parse_example&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">返されたディクショナリは、&lt;a href=&quot;../io/parse_example&quot;&gt; &lt;code&gt;tf.io.parse_example&lt;/code&gt; の&lt;/a&gt; arg 'features'として使用できます。</target>
        </trans-unit>
        <trans-unit id="e41cdf1dd9ec5b48c6c1a627e04bc9cd0f5646ec" translate="yes" xml:space="preserve">
          <source>The returned distributed dataset can be iterated over similar to how regular datasets can. NOTE: Currently, the user cannot add any more transformations to a distributed dataset.</source>
          <target state="translated">返された分散データセットは,通常のデータセットと同様に反復処理することができます.注意:現在のところ,ユーザは分散データセットにこれ以上の変換を追加することはできません.</target>
        </trans-unit>
        <trans-unit id="8e5c9b1714c669dc39fd802e652891ab6982a58a" translate="yes" xml:space="preserve">
          <source>The returned graph will be the innermost graph on which a &lt;a href=&quot;../../graph#as_default&quot;&gt;&lt;code&gt;Graph.as_default()&lt;/code&gt;&lt;/a&gt; context has been entered, or a global default graph if none has been explicitly created.</source>
          <target state="translated">返されるグラフは、&lt;a href=&quot;../../graph#as_default&quot;&gt; &lt;code&gt;Graph.as_default()&lt;/code&gt; &lt;/a&gt;コンテキストが入力された最も内側のグラフ、または明示的に作成されていない場合はグローバルなデフォルトグラフになります。</target>
        </trans-unit>
        <trans-unit id="a3ca6a76bf18bc7eb9e290fd0f8d92384b3fc63a" translate="yes" xml:space="preserve">
          <source>The returned graph will be the innermost graph on which a &lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/Graph#as_default&quot;&gt;&lt;code&gt;Graph.as_default()&lt;/code&gt;&lt;/a&gt; context has been entered, or a global default graph if none has been explicitly created.</source>
          <target state="translated">返されるグラフは、&lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/Graph#as_default&quot;&gt; &lt;code&gt;Graph.as_default()&lt;/code&gt; &lt;/a&gt;コンテキストが入力された最も内側のグラフ、または明示的に作成されていない場合はグローバルデフォルトグラフになります。</target>
        </trans-unit>
        <trans-unit id="4983b6188d9b3a5503f72bc1978affb47cac7b6d" translate="yes" xml:space="preserve">
          <source>The returned iterator implements the Python Iterator protocol.</source>
          <target state="translated">返されるイテレータは、Python の Iterator プロトコルを実装しています。</target>
        </trans-unit>
        <trans-unit id="6b38dad137146b9ef38ba7c509e2c0442b75c1f0" translate="yes" xml:space="preserve">
          <source>The returned iterator implements the Python iterator protocol and therefore can only be used in eager mode.</source>
          <target state="translated">返されるイテレータはPythonのイテレータプロトコルを実装しているため、イーガーモードでのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="7e0593141fa29e4d333dddf121d2181c125317c5" translate="yes" xml:space="preserve">
          <source>The returned iterator is not bound to a particular dataset, and it has no &lt;code&gt;initializer&lt;/code&gt;. To initialize the iterator, run the operation returned by &lt;code&gt;Iterator.make_initializer(dataset)&lt;/code&gt;.</source>
          <target state="translated">返されるイテレータは特定のデータセットにバインドされておらず、 &lt;code&gt;initializer&lt;/code&gt; もありません。イテレータを初期化するには、 &lt;code&gt;Iterator.make_initializer(dataset)&lt;/code&gt; によって返されたオペレーションを実行します。</target>
        </trans-unit>
        <trans-unit id="35c004b6fa1c65f47bcd7047f0f10a1978a605f3" translate="yes" xml:space="preserve">
          <source>The returned operation is a dequeue operation and will throw &lt;a href=&quot;../../../errors/outofrangeerror&quot;&gt;&lt;code&gt;tf.errors.OutOfRangeError&lt;/code&gt;&lt;/a&gt; if the input queue is exhausted. If this operation is feeding another input queue, its queue runner will catch this exception, however, if this operation is used in your main thread you are responsible for catching this yourself.</source>
          <target state="translated">返された操作はデキュー操作であり、入力キューを使い果たすと&lt;a href=&quot;../../../errors/outofrangeerror&quot;&gt; &lt;code&gt;tf.errors.OutOfRangeError&lt;/code&gt; &lt;/a&gt;をスローします。この操作が別の入力キューにデータを供給している場合、そのキューランナーがこの例外をキャッチしますが、この操作がメインスレッドで使用されている場合は、自分でキャッチする必要があります。</target>
        </trans-unit>
        <trans-unit id="388161f4aeaed3801662f433bd19fe4a8d446b0a" translate="yes" xml:space="preserve">
          <source>The returned permutation may be used to permute the rows and columns of the given sparse matrix. This typically results in permuted sparse matrix's sparse Cholesky (or other decompositions) in having fewer zero fill-in compared to decomposition of the original matrix.</source>
          <target state="translated">返された順列は,与えられた疎行列の行と列をパーミュートするために使用されてもよい。これは典型的には,元の行列の分解と比較して,パーミュートされた疎な行列の疎なコレスキー(または他の分解)のゼロフィルインが少ない結果となります.</target>
        </trans-unit>
        <trans-unit id="34611a4904c47d805a50142b42fe43a0ecae787f" translate="yes" xml:space="preserve">
          <source>The returned sparse matrix has the same dense shape as the input sparse matrix. For each component &lt;code&gt;A&lt;/code&gt; of the input sparse matrix, the corresponding output sparse matrix represents &lt;code&gt;L&lt;/code&gt;, the lower triangular Cholesky factor satisfying the following identity:</source>
          <target state="translated">返されるスパース行列は、入力スパース行列と同じ密な形状をしています。入力スパース行列の各コンポーネント &lt;code&gt;A&lt;/code&gt; について、対応する出力スパース行列は &lt;code&gt;L&lt;/code&gt; を表します。これは、次の単位元を満たす下三角コレスキー因子です。</target>
        </trans-unit>
        <trans-unit id="283d98979ab1e70cde916469a5e89b9e786cbb6c" translate="yes" xml:space="preserve">
          <source>The returned status object has the following methods:</source>
          <target state="translated">返されたステータス・オブジェクトには、以下のメソッドがあります。</target>
        </trans-unit>
        <trans-unit id="b692f2b05a18e92aff1d5bc6f670c1b3f429e602" translate="yes" xml:space="preserve">
          <source>The returned string will be in the form protocol://address, e.g. &quot;grpc://localhost:5050&quot;.</source>
          <target state="translated">返される文字列は protocol://address の形式で、例えば &quot;grpc://localhost:5050&quot; のようになります。</target>
        </trans-unit>
        <trans-unit id="c118b1fddbb7639875cad9b7ab197644effe14a5" translate="yes" xml:space="preserve">
          <source>The returned tensor uses the memory shared by dlpack capsules from other framework.</source>
          <target state="translated">返されたテンソルは、他のフレームワークのdlpackカプセルで共有されているメモリを使用します。</target>
        </trans-unit>
        <trans-unit id="76a9be24217f14af8b4e90ac374a00f3e69a4114" translate="yes" xml:space="preserve">
          <source>The returned tensor will contain a serialized &lt;a href=&quot;../../summary&quot;&gt;&lt;code&gt;tf.compat.v1.summary.Summary&lt;/code&gt;&lt;/a&gt; protocol buffer, which can be used with the standard TensorBoard logging facilities.</source>
          <target state="translated">返されるテンソルには、シリアル化された&lt;a href=&quot;../../summary&quot;&gt; &lt;code&gt;tf.compat.v1.summary.Summary&lt;/code&gt; &lt;/a&gt;プロトコルバッファーが含まれます。これは、標準のTensorBoardロギング機能で使用できます。</target>
        </trans-unit>
        <trans-unit id="c2eac31d16e8529bfab56c61e3821bc8b01c5d91" translate="yes" xml:space="preserve">
          <source>The returned tensor's dimension &lt;code&gt;i&lt;/code&gt; will correspond to the input dimension &lt;code&gt;perm[i]&lt;/code&gt;. If &lt;code&gt;perm&lt;/code&gt; is not given, it is set to (n-1...0), where n is the rank of the input tensor. Hence by default, this operation performs a regular matrix transpose on 2-D input Tensors.</source>
          <target state="translated">返されるテンソルの次元 &lt;code&gt;i&lt;/code&gt; は、入力次元 &lt;code&gt;perm[i]&lt;/code&gt; 対応します。 &lt;code&gt;perm&lt;/code&gt; が指定されていない場合は、（n-1 ... 0）に設定されます。ここで、nは入力テンソルのランクです。したがって、デフォルトでは、この操作は2次元入力テンソルで通常の行列転置を実行します。</target>
        </trans-unit>
        <trans-unit id="82d1c361e6f8f0d84bf0a1bcea9214b49e8cf3d3" translate="yes" xml:space="preserve">
          <source>The returned tensor's dimension i will correspond to the input dimension &lt;code&gt;perm[i]&lt;/code&gt;. If &lt;code&gt;perm&lt;/code&gt; is not given, it is set to (n-1...0), where n is the rank of the input tensor. Hence by default, this operation performs a regular matrix transpose on 2-D input Tensors.</source>
          <target state="translated">返されるテンソルの次元iは、入力次元 &lt;code&gt;perm[i]&lt;/code&gt; 対応します。 &lt;code&gt;perm&lt;/code&gt; が指定されない場合、（n-1 ... 0）に設定されます。ここで、nは入力テンソルのランクです。したがって、デフォルトでは、この操作は2次元入力テンソルに対して通常の行列転置を実行します。</target>
        </trans-unit>
        <trans-unit id="d9c115cc2d00147127224aefb2bd6a8e1bbe0c5c" translate="yes" xml:space="preserve">
          <source>The returned tensor's dimension i will correspond to the input dimension &lt;code&gt;perm[i]&lt;/code&gt;. If &lt;code&gt;perm&lt;/code&gt; is not given, it is set to (n-1...0), where n is the rank of the input tensor. Hence by default, this operation performs a regular matrix transpose on 2-D input Tensors. If conjugate is True and &lt;code&gt;a.dtype&lt;/code&gt; is either &lt;code&gt;complex64&lt;/code&gt; or &lt;code&gt;complex128&lt;/code&gt; then the values of &lt;code&gt;a&lt;/code&gt; are conjugated and transposed.</source>
          <target state="translated">返されるテンソルの次元iは、入力次元 &lt;code&gt;perm[i]&lt;/code&gt; 対応します。 &lt;code&gt;perm&lt;/code&gt; が指定されない場合、（n-1 ... 0）に設定されます。ここで、nは入力テンソルのランクです。したがって、デフォルトでは、この操作は2次元入力テンソルに対して通常の行列転置を実行します。共役がTrueで、 &lt;code&gt;a.dtype&lt;/code&gt; が &lt;code&gt;complex64&lt;/code&gt; または &lt;code&gt;complex128&lt;/code&gt; のいずれかである場合、 &lt;code&gt;a&lt;/code&gt; の値は共役されて転置されます。</target>
        </trans-unit>
        <trans-unit id="838e6e70eeb12ce61fde540b38b4044a46a8f134" translate="yes" xml:space="preserve">
          <source>The returned tensors are &lt;a href=&quot;../tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt;s if &lt;code&gt;input&lt;/code&gt; is a scalar, or &lt;a href=&quot;../raggedtensor&quot;&gt;&lt;code&gt;tf.RaggedTensor&lt;/code&gt;&lt;/a&gt;s otherwise.</source>
          <target state="translated">返されるテンソルは、 &lt;code&gt;input&lt;/code&gt; がスカラーの場合は&lt;a href=&quot;../tensor&quot;&gt; &lt;code&gt;tf.Tensor&lt;/code&gt; &lt;/a&gt; s、それ以外の場合は&lt;a href=&quot;../raggedtensor&quot;&gt; &lt;code&gt;tf.RaggedTensor&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="710644f5cd50999519cd748e88ddf36f02a2b455" translate="yes" xml:space="preserve">
          <source>The right-hand side of the &lt;code&gt;!=&lt;/code&gt; operator.</source>
          <target state="translated">&lt;code&gt;!=&lt;/code&gt; 演算子の右側。</target>
        </trans-unit>
        <trans-unit id="e668edbb07540997101fa0f49a39faa5f38caec8" translate="yes" xml:space="preserve">
          <source>The right-hand side of the &lt;code&gt;+&lt;/code&gt; operator.</source>
          <target state="translated">&lt;code&gt;+&lt;/code&gt; 演算子の右側。</target>
        </trans-unit>
        <trans-unit id="ff72258325f43cdf735f357c785333acbdbfc89a" translate="yes" xml:space="preserve">
          <source>The right-hand side of the &lt;code&gt;==&lt;/code&gt; operator.</source>
          <target state="translated">&lt;code&gt;==&lt;/code&gt; 演算子の右側。</target>
        </trans-unit>
        <trans-unit id="ca75c2c84ca7c94aaa9f8f708d895cba56b5cf74" translate="yes" xml:space="preserve">
          <source>The row partition tensors are in the order of the dimensions. At present, the types can be:</source>
          <target state="translated">行分割テンソルは次元の順になっています。現時点では、型は可能です。</target>
        </trans-unit>
        <trans-unit id="85216d0bd898c6d1680f5aac974d5348d1d96c2f" translate="yes" xml:space="preserve">
          <source>The row-split indices for this ragged tensor's &lt;code&gt;values&lt;/code&gt;.</source>
          <target state="translated">この不規則なテンソルの &lt;code&gt;values&lt;/code&gt; の行分割インデックス。</target>
        </trans-unit>
        <trans-unit id="5854e78835764512ec754b4ac011bb9b48f7d380" translate="yes" xml:space="preserve">
          <source>The row_splits for all ragged dimensions in this ragged tensor value.</source>
          <target state="translated">このぼろぼろテンソル値のすべてのぼろぼろ次元のrow_splits。</target>
        </trans-unit>
        <trans-unit id="5158c81c5ea5bb74de68daed2eacbf5dc32d4ad8" translate="yes" xml:space="preserve">
          <source>The runtime is then free to make optimizations based on this.</source>
          <target state="translated">ランタイムはこれに基づいて自由に最適化を行うことができます。</target>
        </trans-unit>
        <trans-unit id="ca5cdf682a9605ca998129dd4a854da399041aba" translate="yes" xml:space="preserve">
          <source>The same array (Numpy array if &lt;code&gt;x&lt;/code&gt; was a Numpy array, or TensorFlow tensor if &lt;code&gt;x&lt;/code&gt; was a tensor), cast to its new type.</source>
          <target state="translated">同じ配列（ &lt;code&gt;x&lt;/code&gt; がNumpy配列の場合はNumpy配列、 &lt;code&gt;x&lt;/code&gt; がテンソルの場合はTensorFlow テンソル）を新しい型にキャストします。</target>
        </trans-unit>
        <trans-unit id="e4b3e7c37b806fc9d4b600343aa28d9179c53706" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;../../raggedtensor#__div__&quot;&gt;&lt;code&gt;tf.compat.v1.div(x,y)&lt;/code&gt;&lt;/a&gt; for integers, but uses &lt;code&gt;tf.floor(tf.compat.v1.div(x,y))&lt;/code&gt; for floating point arguments so that the result is always an integer (though possibly an integer represented as floating point). This op is generated by &lt;code&gt;x // y&lt;/code&gt; floor division in Python 3 and in Python 2.7 with &lt;code&gt;from __future__ import division&lt;/code&gt;.</source>
          <target state="translated">整数の場合は&lt;a href=&quot;../../raggedtensor#__div__&quot;&gt; &lt;code&gt;tf.compat.v1.div(x,y)&lt;/code&gt; &lt;/a&gt;と同じですが、浮動小数点引数の場合は &lt;code&gt;tf.floor(tf.compat.v1.div(x,y))&lt;/code&gt; を使用するため、結果は常に整数（おそらく浮動小数点として表される整数です）。この &lt;code&gt;from __future__ import division&lt;/code&gt; は、Python 3およびPython 2.7で、from __future__ import Divisionを使用して、 &lt;code&gt;x // y&lt;/code&gt; フロア除算によって生成されます。</target>
        </trans-unit>
        <trans-unit id="07525f9495ce7a62b86179e9f6083e34f20d8d8b" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;../raggedtensor#__div__&quot;&gt;&lt;code&gt;tf.compat.v1.div(x,y)&lt;/code&gt;&lt;/a&gt; for integers, but uses &lt;code&gt;tf.floor(tf.compat.v1.div(x,y))&lt;/code&gt; for floating point arguments so that the result is always an integer (though possibly an integer represented as floating point). This op is generated by &lt;code&gt;x // y&lt;/code&gt; floor division in Python 3 and in Python 2.7 with &lt;code&gt;from __future__ import division&lt;/code&gt;.</source>
          <target state="translated">整数の場合は&lt;a href=&quot;../raggedtensor#__div__&quot;&gt; &lt;code&gt;tf.compat.v1.div(x,y)&lt;/code&gt; &lt;/a&gt;と同じですが、浮動小数点引数の場合は &lt;code&gt;tf.floor(tf.compat.v1.div(x,y))&lt;/code&gt; を使用するため、結果は常に整数（おそらく浮動小数点として表される整数です）。この &lt;code&gt;from __future__ import division&lt;/code&gt; は、Python 3およびPython 2.7で、from __future__ import Divisionを使用して、 &lt;code&gt;x // y&lt;/code&gt; フロア除算によって生成されます。</target>
        </trans-unit>
        <trans-unit id="3240798db52d492b4a5e0a4f1101b0ce22e5dea6" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;raggedtensor#__div__&quot;&gt;&lt;code&gt;tf.compat.v1.div(x,y)&lt;/code&gt;&lt;/a&gt; for integers, but uses &lt;code&gt;tf.floor(tf.compat.v1.div(x,y))&lt;/code&gt; for floating point arguments so that the result is always an integer (though possibly an integer represented as floating point). This op is generated by &lt;code&gt;x // y&lt;/code&gt; floor division in Python 3 and in Python 2.7 with &lt;code&gt;from __future__ import division&lt;/code&gt;.</source>
          <target state="translated">整数の場合は&lt;a href=&quot;raggedtensor#__div__&quot;&gt; &lt;code&gt;tf.compat.v1.div(x,y)&lt;/code&gt; &lt;/a&gt;と同じですが、浮動小数点引数の場合は &lt;code&gt;tf.floor(tf.compat.v1.div(x,y))&lt;/code&gt; を使用するため、結果は常に整数（おそらく浮動小数点として表される整数です）。この &lt;code&gt;from __future__ import division&lt;/code&gt; は、Python 3およびPython 2.7で、from __future__ import Divisionを使用して、 &lt;code&gt;x // y&lt;/code&gt; フロア除算によって生成されます。</target>
        </trans-unit>
        <trans-unit id="d6016fab50d93b1e77917677d258e0e003f237e6" translate="yes" xml:space="preserve">
          <source>The same tensor &lt;code&gt;x&lt;/code&gt;, unchanged.</source>
          <target state="translated">同じテンソル &lt;code&gt;x&lt;/code&gt; 、変更なし。</target>
        </trans-unit>
        <trans-unit id="e28b3d74027804ad355c817f8c256af8b2d25a2a" translate="yes" xml:space="preserve">
          <source>The samples are differentiable w.r.t. alpha and beta. The derivatives are computed using the approach described in (Figurnov et al., 2018).</source>
          <target state="translated">サンプルは、アルファとベータで微分可能である。導関数は、(Figurnov et al.,2018)に記載されたアプローチを用いて計算される。</target>
        </trans-unit>
        <trans-unit id="2c3935638fc889928b31f22a28b40af71a593afd" translate="yes" xml:space="preserve">
          <source>The samples are differentiable w.r.t. alpha and beta. The derivatives are computed using the approach described in the paper</source>
          <target state="translated">サンプルはアルファとベータで微分可能です。微分は論文</target>
        </trans-unit>
        <trans-unit id="92952659dac1bf101ab8c26a5fd0e7570c899948" translate="yes" xml:space="preserve">
          <source>The sampling probabilities are generated according to the sampling distribution used in word2vec:</source>
          <target state="translated">サンプリング確率は、word2vecで使用されているサンプリング分布に従って生成されます。</target>
        </trans-unit>
        <trans-unit id="7e70c09e21b733e9d2a808af0f600268962663fb" translate="yes" xml:space="preserve">
          <source>The save counter variable.</source>
          <target state="translated">セーブカウンタの変数です。</target>
        </trans-unit>
        <trans-unit id="ab43a8a642f72175fe828def8c8d03e9a692fe7b" translate="yes" xml:space="preserve">
          <source>The saved checkpoint includes variables created by this object and any trackable objects it depends on at the time &lt;a href=&quot;../../../train/checkpoint#save&quot;&gt;&lt;code&gt;Checkpoint.save()&lt;/code&gt;&lt;/a&gt; is called.</source>
          <target state="translated">保存されたチェックポイントには、このオブジェクトによって作成された変数と、&lt;a href=&quot;../../../train/checkpoint#save&quot;&gt; &lt;code&gt;Checkpoint.save()&lt;/code&gt; &lt;/a&gt;が呼び出されたときに依存する追跡可能なオブジェクトが含まれます。</target>
        </trans-unit>
        <trans-unit id="21ba0881308b74c027819f31603cfc6647b52c80" translate="yes" xml:space="preserve">
          <source>The saved checkpoint includes variables created by this object and any trackable objects it depends on at the time &lt;a href=&quot;checkpoint#save&quot;&gt;&lt;code&gt;Checkpoint.save()&lt;/code&gt;&lt;/a&gt; is called.</source>
          <target state="translated">保存されたチェックポイントには、このオブジェクトによって作成された変数と、&lt;a href=&quot;checkpoint#save&quot;&gt; &lt;code&gt;Checkpoint.save()&lt;/code&gt; &lt;/a&gt;が呼び出されたときに依存する追跡可能なオブジェクトが含まれます。</target>
        </trans-unit>
        <trans-unit id="38adbe2f58aa8b45a85ccd9d545a08f193885a40" translate="yes" xml:space="preserve">
          <source>The saved checkpoint includes variables created by this object and any trackable objects it depends on at the time &lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/train/Checkpoint#save&quot;&gt;&lt;code&gt;Checkpoint.save()&lt;/code&gt;&lt;/a&gt; is called.</source>
          <target state="translated">保存されたチェックポイントには、このオブジェクトと、&lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/train/Checkpoint#save&quot;&gt; &lt;code&gt;Checkpoint.save()&lt;/code&gt; &lt;/a&gt;が呼び出されたときに依存する追跡可能なオブジェクトによって作成された変数が含まれます。</target>
        </trans-unit>
        <trans-unit id="d6290af5f5d901c235fa2702c12d35d14bd8fbb8" translate="yes" xml:space="preserve">
          <source>The saved dataset is saved in multiple file &quot;shards&quot;. By default, the dataset output is divided to shards in a round-robin fashion but custom sharding can be specified via the &lt;code&gt;shard_func&lt;/code&gt; function. For example, you can save the dataset to using a single shard as follows:</source>
          <target state="translated">保存されたデータセットは、複数のファイル「シャード」に保存されます。デフォルトでは、データセット出力はラウンドロビン方式でシャードに分割されますが、カスタムシャーディングは &lt;code&gt;shard_func&lt;/code&gt; 関数を介して指定できます。たとえば、次のように、単一のシャードを使用してデータセットを保存できます。</target>
        </trans-unit>
        <trans-unit id="32eabd05b895cc5cbd843e5d58a26478d871b570" translate="yes" xml:space="preserve">
          <source>The saved model contains:</source>
          <target state="translated">保存されたモデルには、以下が含まれています。</target>
        </trans-unit>
        <trans-unit id="d3b7070f1ecc16e817793f6b5d01b2b53b58703e" translate="yes" xml:space="preserve">
          <source>The saved model contains: - the model's configuration (topology) - the model's weights - the model's optimizer's state (if any)</source>
          <target state="translated">保存されたモデルには以下が含まれます。-モデルの構成(トポロジー)-モデルの重み-モデルのオプティマイザの状態(ある場合)。</target>
        </trans-unit>
        <trans-unit id="eeb866c0e9b8a790b2b06bb4bf72fe83fcf3b7fd" translate="yes" xml:space="preserve">
          <source>The savefile includes:</source>
          <target state="translated">savefileには、以下のものが含まれています。</target>
        </trans-unit>
        <trans-unit id="2be8f8b013a0bea1b78a799bc083aef46d344f06" translate="yes" xml:space="preserve">
          <source>The scalar &lt;code&gt;default_value&lt;/code&gt; is the value output for keys not present in the table. It must also be of the same type as the table values.</source>
          <target state="translated">スカラー &lt;code&gt;default_value&lt;/code&gt; は、テーブルに存在しないキーの出力値です。また、テーブル値と同じタイプである必要があります。</target>
        </trans-unit>
        <trans-unit id="ff3fd5f27f08bbd84c446309ecdaecd1825d0b40" translate="yes" xml:space="preserve">
          <source>The scalar PSNR between a and b. The returned tensor has type &lt;a href=&quot;../../tf#float32&quot;&gt;&lt;code&gt;tf.float32&lt;/code&gt;&lt;/a&gt; and shape [batch_size, 1].</source>
          <target state="translated">aとbの間のスカラーPSNR。返されるテンソルのタイプは&lt;a href=&quot;../../tf#float32&quot;&gt; &lt;code&gt;tf.float32&lt;/code&gt; で&lt;/a&gt;、形状は[batch_size、1]です。</target>
        </trans-unit>
        <trans-unit id="dd78e4034ea5bbefe47a5585f3fa965bc5acaa8e" translate="yes" xml:space="preserve">
          <source>The scaled exponential unit activation: &lt;code&gt;scale * elu(x, alpha)&lt;/code&gt;.</source>
          <target state="translated">スケーリングされた指数ユニットのアクティブ化： &lt;code&gt;scale * elu(x, alpha)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d7cdf9b27ca1dd2bbd540e30d82d6f1126674d88" translate="yes" xml:space="preserve">
          <source>The scaling_factor is determined from &lt;code&gt;min_range&lt;/code&gt;, &lt;code&gt;max_range&lt;/code&gt;, and &lt;code&gt;narrow_range&lt;/code&gt; in a way that is compatible with &lt;code&gt;QuantizeAndDequantize{V2|V3}&lt;/code&gt; and &lt;code&gt;QuantizeV2&lt;/code&gt;, using the following algorithm:</source>
          <target state="translated">scaling_factorは、次のアルゴリズムを使用して、 &lt;code&gt;QuantizeAndDequantize{V2|V3}&lt;/code&gt; および &lt;code&gt;QuantizeV2&lt;/code&gt; と互換性のある方法で &lt;code&gt;min_range&lt;/code&gt; 、 &lt;code&gt;max_range&lt;/code&gt; 、および &lt;code&gt;narrow_range&lt;/code&gt; から決定されます。</target>
        </trans-unit>
        <trans-unit id="d82c0e384909c0dd188de5ead9b2872459677ae8" translate="yes" xml:space="preserve">
          <source>The schedule a 1-arg callable that produces a decayed learning rate when passed the current optimizer step. This can be useful for changing the learning rate value across different invocations of optimizer functions.</source>
          <target state="translated">現在のオプティマイザステップを通過したときに減衰した学習率を生成する1-argの呼び出し可能なスケジュールです。これは、オプティマイザ関数の異なる呼び出しの間で学習率の値を変更するのに便利です。</target>
        </trans-unit>
        <trans-unit id="c2ad88fa788374ec95b4583696db082a634b18eb" translate="yes" xml:space="preserve">
          <source>The schedule a 1-arg callable that produces a decayed learning rate when passed the current optimizer step. This can be useful for changing the learning rate value across different invocations of optimizer functions. It is computed as:</source>
          <target state="translated">現在のオプティマイザステップを通過したときに減衰した学習率を生成する1-argの呼び出し可能なスケジュールです。これはオプティマイザ関数の異なる呼び出しで学習率の値を変更するのに便利です。として計算されます。</target>
        </trans-unit>
        <trans-unit id="71d2993ed1ad7b32ffe04dab2486da899c3f2739" translate="yes" xml:space="preserve">
          <source>The schedule is a 1-arg callable that produces a decayed learning rate when passed the current optimizer step. This can be useful for changing the learning rate value across different invocations of optimizer functions. It is computed as:</source>
          <target state="translated">スケジュールは1-argの呼び出し可能なもので、現在のオプティマイザステップを通過したときに減衰した学習率を生成します。これはオプティマイザ関数の異なる呼び出しで学習率の値を変更するのに便利です。として計算されます。</target>
        </trans-unit>
        <trans-unit id="70da9d42a4b299e69bb575bc1c369e715f3022f0" translate="yes" xml:space="preserve">
          <source>The scope for the operations performed in computing the loss.</source>
          <target state="translated">損失を計算する際に行う操作の範囲。</target>
        </trans-unit>
        <trans-unit id="2bf5542bf013cf2cd0c7e2cee3c5c6cd6c529ad0" translate="yes" xml:space="preserve">
          <source>The scope name.</source>
          <target state="translated">スコープ名です。</target>
        </trans-unit>
        <trans-unit id="50f230356c528b135a5e5c8be0185503e716f9b3" translate="yes" xml:space="preserve">
          <source>The second call of &lt;code&gt;foo&lt;/code&gt; returns '(A2, A2)' instead of '(A1, A1)' because &lt;a href=&quot;uniform&quot;&gt;&lt;code&gt;tf.random.uniform&lt;/code&gt;&lt;/a&gt; maintains an internal counter. If you want &lt;code&gt;foo&lt;/code&gt; to return '(A1, A1)' every time, use the stateless random ops such as &lt;a href=&quot;stateless_uniform&quot;&gt;&lt;code&gt;tf.random.stateless_uniform&lt;/code&gt;&lt;/a&gt;. Also see &lt;a href=&quot;experimental/generator&quot;&gt;&lt;code&gt;tf.random.experimental.Generator&lt;/code&gt;&lt;/a&gt; for a new set of stateful random ops that use external variables to manage their states.</source>
          <target state="translated">&lt;code&gt;foo&lt;/code&gt; の2番目の呼び出しでは、&lt;a href=&quot;uniform&quot;&gt; &lt;code&gt;tf.random.uniform&lt;/code&gt; &lt;/a&gt;が内部カウンターを維持するため、「（A1、A1）」の代わりに「（A2、A2）」が返されます。 &lt;code&gt;foo&lt;/code&gt; が毎回 '（A1、A1）'を返すようにしたい場合は、&lt;a href=&quot;stateless_uniform&quot;&gt; &lt;code&gt;tf.random.stateless_uniform&lt;/code&gt; &lt;/a&gt;などのステートレスなランダム演算を使用します。また、外部変数を使用して状態を管理する新しいステートフルランダム&lt;a href=&quot;experimental/generator&quot;&gt; &lt;code&gt;tf.random.experimental.Generator&lt;/code&gt; &lt;/a&gt;セットについては、tf.random.experimental.Generatorを参照してください。</target>
        </trans-unit>
        <trans-unit id="99c1ec05a48b05e1a2d2c74a95c41738070d1d52" translate="yes" xml:space="preserve">
          <source>The second call of &lt;code&gt;foo&lt;/code&gt; returns '(A2, A2)' instead of '(A1, A1)' because &lt;a href=&quot;uniform&quot;&gt;&lt;code&gt;tf.random.uniform&lt;/code&gt;&lt;/a&gt; maintains an internal counter. If you want &lt;code&gt;foo&lt;/code&gt; to return '(A1, A1)' every time, use the stateless random ops such as &lt;a href=&quot;stateless_uniform&quot;&gt;&lt;code&gt;tf.random.stateless_uniform&lt;/code&gt;&lt;/a&gt;. Also see &lt;a href=&quot;generator&quot;&gt;&lt;code&gt;tf.random.experimental.Generator&lt;/code&gt;&lt;/a&gt; for a new set of stateful random ops that use external variables to manage their states.</source>
          <target state="translated">&lt;a href=&quot;uniform&quot;&gt; &lt;code&gt;tf.random.uniform&lt;/code&gt; &lt;/a&gt;は内部カウンターを維持するため、 &lt;code&gt;foo&lt;/code&gt; の2番目の呼び出しは「（A1、A1）」ではなく「（A2、A2）」を返します。 &lt;code&gt;foo&lt;/code&gt; が毎回 '（A1、A1）'を返すようにしたい場合は、&lt;a href=&quot;stateless_uniform&quot;&gt; &lt;code&gt;tf.random.stateless_uniform&lt;/code&gt; &lt;/a&gt;などのステートレスランダム演算を使用します。また、外部変数を使用して状態を管理するステートフルランダムオペレーションの新しいセットについては、&lt;a href=&quot;generator&quot;&gt; &lt;code&gt;tf.random.experimental.Generator&lt;/code&gt; &lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="08568c721bd015f102f6c3ec1b535d6153171292" translate="yes" xml:space="preserve">
          <source>The second dict contains the feature_list key/values.</source>
          <target state="translated">2 番目のディクトには feature_list のキー/値が含まれています。</target>
        </trans-unit>
        <trans-unit id="55c0e48b341890b90c7222213ebdf6711ed127c5" translate="yes" xml:space="preserve">
          <source>The second distribution.</source>
          <target state="translated">第二の分布です。</target>
        </trans-unit>
        <trans-unit id="73916e07f6ea34c81abd799027349571045df1c6" translate="yes" xml:space="preserve">
          <source>The second innermost dimension of &lt;code&gt;diagonal&lt;/code&gt; has double meaning. When &lt;code&gt;k&lt;/code&gt; is scalar or &lt;code&gt;k[0] == k[1]&lt;/code&gt;, &lt;code&gt;M&lt;/code&gt; is part of the batch size [I, J, ..., M], and the output tensor is:</source>
          <target state="translated">&lt;code&gt;diagonal&lt;/code&gt; の2番目の最も内側の次元には2つの意味があります。場合 &lt;code&gt;k&lt;/code&gt; はスカラーまたはある &lt;code&gt;k[0] == k[1]&lt;/code&gt; 、 &lt;code&gt;M&lt;/code&gt; は、バッチサイズ[I、J、...、M]の一部であり、出力テンソルです。</target>
        </trans-unit>
        <trans-unit id="897c8f258e58c08596b32bdbc51f703aa19e32cb" translate="yes" xml:space="preserve">
          <source>The second list to compare.</source>
          <target state="translated">2番目に比較するリスト。</target>
        </trans-unit>
        <trans-unit id="07d2101b8340d508be1c61741652a76d9deb3b07" translate="yes" xml:space="preserve">
          <source>The second operand; &lt;code&gt;SparseTensor&lt;/code&gt; or &lt;code&gt;Tensor&lt;/code&gt;. At least one operand must be sparse.</source>
          <target state="translated">2番目のオペランド。 &lt;code&gt;SparseTensor&lt;/code&gt; または &lt;code&gt;Tensor&lt;/code&gt; 。少なくとも1つのオペランドはスパースでなければなりません。</target>
        </trans-unit>
        <trans-unit id="eb28a5566b72083d75d5c15273e66594bb2b10e4" translate="yes" xml:space="preserve">
          <source>The second sequence to compare.</source>
          <target state="translated">比較するための2つ目のシーケンス。</target>
        </trans-unit>
        <trans-unit id="f44476a07dabc329393369e874eaf7a10133de21" translate="yes" xml:space="preserve">
          <source>The second set to compare.</source>
          <target state="translated">比べてみると2セット目。</target>
        </trans-unit>
        <trans-unit id="f193b83c375843f2a04bc17c95ee85c91007fcdb" translate="yes" xml:space="preserve">
          <source>The second structure to compare.</source>
          <target state="translated">比較するための第二の構造。</target>
        </trans-unit>
        <trans-unit id="d1bef3c10ad61ff65c7724ce0d24e0698479866c" translate="yes" xml:space="preserve">
          <source>The second tuple to compare.</source>
          <target state="translated">比較する2つ目のタプル。</target>
        </trans-unit>
        <trans-unit id="b310dae88696133dc7ed85369e494d665ee6beaf" translate="yes" xml:space="preserve">
          <source>The second variant is compatible with CuDNNGRU (GPU-only) and allows inference on CPU. Thus it has separate biases for &lt;code&gt;kernel&lt;/code&gt; and &lt;code&gt;recurrent_kernel&lt;/code&gt;. To use this variant, set &lt;code&gt;'reset_after'=True&lt;/code&gt; and &lt;code&gt;recurrent_activation='sigmoid'&lt;/code&gt;.</source>
          <target state="translated">2番目のバリアントはCuDNNGRU（GPUのみ）と互換性があり、CPUでの推論を可能にします。したがって、 &lt;code&gt;kernel&lt;/code&gt; と &lt;code&gt;recurrent_kernel&lt;/code&gt; には別々のバイアスがあります。このバリアントを使用するには、 &lt;code&gt;'reset_after'=True&lt;/code&gt; および &lt;code&gt;recurrent_activation='sigmoid'&lt;/code&gt; を設定します。</target>
        </trans-unit>
        <trans-unit id="44fd41a3b2fd550cb5e331da22b4349e8495f086" translate="yes" xml:space="preserve">
          <source>The second variant is compatible with CuDNNGRU (GPU-only) and allows inference on CPU. Thus it has separate biases for &lt;code&gt;kernel&lt;/code&gt; and &lt;code&gt;recurrent_kernel&lt;/code&gt;. Use &lt;code&gt;'reset_after'=True&lt;/code&gt; and &lt;code&gt;recurrent_activation='sigmoid'&lt;/code&gt;.</source>
          <target state="translated">2番目のバリアントはCuDNNGRU（GPUのみ）と互換性があり、CPUでの推論を可能にします。したがって、 &lt;code&gt;kernel&lt;/code&gt; と &lt;code&gt;recurrent_kernel&lt;/code&gt; には別々のバイアスがあります。使用 &lt;code&gt;'reset_after'=True&lt;/code&gt; と &lt;code&gt;recurrent_activation='sigmoid'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5ef054429664e25cebbffadf1c7499db194568c6" translate="yes" xml:space="preserve">
          <source>The second way is through a callable function that does not accept any arguments.</source>
          <target state="translated">2つ目の方法は、引数を受け付けない呼び出し可能な関数を使う方法です。</target>
        </trans-unit>
        <trans-unit id="9b1ff7b195e25bb1e934a1faddac3cb31e9dda14" translate="yes" xml:space="preserve">
          <source>The selected tensor.</source>
          <target state="translated">選択されたテンソル。</target>
        </trans-unit>
        <trans-unit id="6d81fff9b6102438ec592417def3c2112c0846b7" translate="yes" xml:space="preserve">
          <source>The semantics of the input tensor depends on tensor_debug_mode. In typical usage, the input tensor comes directly from the user computation only when graph_debug_mode is FULL_TENSOR (see protobuf/debug_event.proto for a list of all the possible values of graph_debug_mode). For the other debug modes, the input tensor should be produced by an additional op or subgraph that computes summary information about one or more tensors.</source>
          <target state="translated">入力テンソルのセマンティクスはtensor_debug_modeに依存します。典型的な使用法では、入力テンソルは graph_debug_mode が FULL_TENSOR の場合にのみ、ユーザの計算から直接得られます (graph_debug_mode の全可能な値のリストについては protobuf/debug_event.proto を参照してください)。他のデバッグモードでは、入力テンソルは、1つ以上のテンソルについての要約情報を計算する追加のopまたはサブグラフによって生成されなければなりません。</target>
        </trans-unit>
        <trans-unit id="1450544c35748cfa003192a74e09ceb10f67e4f7" translate="yes" xml:space="preserve">
          <source>The separator string used between ngram elements. Must be a string constant, not a Tensor.</source>
          <target state="translated">ngram要素間で使用される区切り文字列。Tensorではなく文字列定数でなければなりません。</target>
        </trans-unit>
        <trans-unit id="c84f4757d0db527182bb06d2afdc87b1042d6fea" translate="yes" xml:space="preserve">
          <source>The sequence in which to look for prefix.</source>
          <target state="translated">接頭辞を探す順番。</target>
        </trans-unit>
        <trans-unit id="14448741add9013596276b373f9b2b4fe8b71b2b" translate="yes" xml:space="preserve">
          <source>The sequence of &lt;code&gt;Tensor&lt;/code&gt; objects representing the data inputs of this op.</source>
          <target state="translated">この &lt;code&gt;Tensor&lt;/code&gt; のデータ入力を表すTensorオブジェクトのシーケンス。</target>
        </trans-unit>
        <trans-unit id="ad56b1734b2aec94010201da62b3c74ae59652ee" translate="yes" xml:space="preserve">
          <source>The sequence that we are testing.</source>
          <target state="translated">テストしているシーケンスです。</target>
        </trans-unit>
        <trans-unit id="9c721fd10cd508d808b1312a2194dc7e4890a7fc" translate="yes" xml:space="preserve">
          <source>The serialized &lt;code&gt;GraphDef&lt;/code&gt; can be imported into another &lt;code&gt;Graph&lt;/code&gt; (using &lt;a href=&quot;graph_util/import_graph_def&quot;&gt;&lt;code&gt;tf.import_graph_def&lt;/code&gt;&lt;/a&gt;) or used with the &lt;a href=&quot;https://www.tensorflow.org/api_docs/api_docs/cc/index&quot;&gt;C++ Session API&lt;/a&gt;.</source>
          <target state="translated">シリアル化された &lt;code&gt;GraphDef&lt;/code&gt; は、（&lt;a href=&quot;graph_util/import_graph_def&quot;&gt; &lt;code&gt;tf.import_graph_def&lt;/code&gt; を&lt;/a&gt;使用して）別の &lt;code&gt;Graph&lt;/code&gt; インポートするか、&lt;a href=&quot;https://www.tensorflow.org/api_docs/api_docs/cc/index&quot;&gt;C ++セッションAPIで使用できます&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="73859165e320015abdcf466de88e9720ebb22082" translate="yes" xml:space="preserve">
          <source>The serialized &lt;code&gt;GraphDef&lt;/code&gt; can be imported into another &lt;code&gt;Graph&lt;/code&gt; (using &lt;a href=&quot;graph_util/import_graph_def&quot;&gt;&lt;code&gt;tf.import_graph_def&lt;/code&gt;&lt;/a&gt;) or used with the &lt;a href=&quot;https://www.tensorflow.org/versions/r2.3/api_docs/api_docs/cc/index&quot;&gt;C++ Session API&lt;/a&gt;.</source>
          <target state="translated">シリアル化された &lt;code&gt;GraphDef&lt;/code&gt; は、（&lt;a href=&quot;graph_util/import_graph_def&quot;&gt; &lt;code&gt;tf.import_graph_def&lt;/code&gt; を&lt;/a&gt;使用して）別の &lt;code&gt;Graph&lt;/code&gt; インポートするか、&lt;a href=&quot;https://www.tensorflow.org/versions/r2.3/api_docs/api_docs/cc/index&quot;&gt;C ++セッションAPIで使用できます&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="766157bb0379c94a2b06eab4d5860dfc7335b141" translate="yes" xml:space="preserve">
          <source>The session to evaluate variables in. Ignored when executing eagerly. If not provided when graph building, the default session is used.</source>
          <target state="translated">変数を評価するセッション。熱心に実行している場合は無視されます。グラフ作成時に指定しない場合は、デフォルトのセッションが使用されます。</target>
        </trans-unit>
        <trans-unit id="4a72456f672e80ba24848fd6a912b31242ea6b05" translate="yes" xml:space="preserve">
          <source>The session to use to evaluate this variable. If none, the default session is used.</source>
          <target state="translated">この変数を評価するために使用するセッション。何もない場合は、デフォルトのセッションが使用されます。</target>
        </trans-unit>
        <trans-unit id="ec73351af802bdf6746d29fb3d40b6d4c532bba4" translate="yes" xml:space="preserve">
          <source>The set of absent/default values may be specified using a vector of lengths or a padding value (but not both). If &lt;code&gt;lengths&lt;/code&gt; is specified, then the output tensor will satisfy &lt;code&gt;output[row] = tensor[row][:lengths[row]]&lt;/code&gt;. If 'lengths' is a list of lists or tuple of lists, those lists will be used as nested row lengths. If &lt;code&gt;padding&lt;/code&gt; is specified, then any row &lt;em&gt;suffix&lt;/em&gt; consisting entirely of &lt;code&gt;padding&lt;/code&gt; will be excluded from the returned &lt;code&gt;RaggedTensor&lt;/code&gt;. If neither &lt;code&gt;lengths&lt;/code&gt; nor &lt;code&gt;padding&lt;/code&gt; is specified, then the returned &lt;code&gt;RaggedTensor&lt;/code&gt; will have no absent/default values.</source>
          <target state="translated">不在/デフォルト値のセットは、長さのベクトルまたはパディング値（両方ではない）を使用して指定できます。 &lt;code&gt;lengths&lt;/code&gt; が指定されている場合、出力テンソルは &lt;code&gt;output[row] = tensor[row][:lengths[row]]&lt;/code&gt; を満たします。 「lengths」がリストのリストまたはリストのタプルである場合、それらのリストはネストされた行の長さとして使用されます。 &lt;code&gt;padding&lt;/code&gt; が指定されている場合、完全に &lt;code&gt;padding&lt;/code&gt; 構成される行の&lt;em&gt;サフィックス&lt;/em&gt;は、返される &lt;code&gt;RaggedTensor&lt;/code&gt; から除外されます。 &lt;code&gt;lengths&lt;/code&gt; も &lt;code&gt;padding&lt;/code&gt; も指定されていない場合、返される &lt;code&gt;RaggedTensor&lt;/code&gt; には不在/デフォルト値はありません。</target>
        </trans-unit>
        <trans-unit id="0c1258f12879c9bd1b917a210f7db35cdd522088" translate="yes" xml:space="preserve">
          <source>The set of ops to be run as part of the main op upon the load operation.</source>
          <target state="translated">ロード操作時に主オペの一部として実行されるオペのセット。</target>
        </trans-unit>
        <trans-unit id="b8a942e9ca1e31cdbe28c47ba81e62ec5b4daae6" translate="yes" xml:space="preserve">
          <source>The set of variable names to convert (by default, all variables are converted).</source>
          <target state="translated">変換する変数名のセット(デフォルトでは、すべての変数が変換されます)。</target>
        </trans-unit>
        <trans-unit id="708ef0da29666e679f2d004edd19c8b18d49eb0b" translate="yes" xml:space="preserve">
          <source>The set of variable names to omit converting to constants.</source>
          <target state="translated">定数への変換を省略する変数名のセット。</target>
        </trans-unit>
        <trans-unit id="4fc94cf8836a9ff2b4e0118d0144216371d4137e" translate="yes" xml:space="preserve">
          <source>The shape and dtype of any intermediate or output tensors in the computation of &lt;code&gt;fn&lt;/code&gt; should not depend on the input to &lt;code&gt;fn&lt;/code&gt;.</source>
          <target state="translated">計算における任意の中間または出力テンソルの形状とDTYPE &lt;code&gt;fn&lt;/code&gt; への入力に依存してはならない &lt;code&gt;fn&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="915b2e710b3b023da7cd3921f1c34459542c194c" translate="yes" xml:space="preserve">
          <source>The shape for individual flat values in the &lt;code&gt;RaggedTensor&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;RaggedTensor&lt;/code&gt; の個々のフラット値の形状。</target>
        </trans-unit>
        <trans-unit id="b1218538acb5cc473fe08e57d6e893aaca21938d" translate="yes" xml:space="preserve">
          <source>The shape format of the &lt;code&gt;inputs&lt;/code&gt; Tensors. If True, these &lt;code&gt;Tensors&lt;/code&gt; must be shaped &lt;code&gt;[max_time, batch_size, num_classes]&lt;/code&gt;. If False, these &lt;code&gt;Tensors&lt;/code&gt; must be shaped &lt;code&gt;[batch_size, max_time, num_classes]&lt;/code&gt;. Using &lt;code&gt;time_major = True&lt;/code&gt; (default) is a bit more efficient because it avoids transposes at the beginning of the ctc_loss calculation. However, most TensorFlow data is batch-major, so by this function also accepts inputs in batch-major form.</source>
          <target state="translated">&lt;code&gt;inputs&lt;/code&gt; テンソルの形状形式。 Trueの場合、これらの &lt;code&gt;Tensors&lt;/code&gt; は &lt;code&gt;[max_time, batch_size, num_classes]&lt;/code&gt; 形状にする必要があります。 Falseの場合、これらの &lt;code&gt;Tensors&lt;/code&gt; は &lt;code&gt;[batch_size, max_time, num_classes]&lt;/code&gt; 形状にする必要があります。 &lt;code&gt;time_major = True&lt;/code&gt; （デフォルト）を使用すると、ctc_loss計算の開始時に転置が回避されるため、少し効率的です。ただし、ほとんどのTensorFlowデータはバッチメジャーであるため、この関数はバッチメジャー形式の入力も受け入れます。</target>
        </trans-unit>
        <trans-unit id="cd03f61b772d8cecf2105a6fa68f431df30d2490" translate="yes" xml:space="preserve">
          <source>The shape format of the &lt;code&gt;inputs&lt;/code&gt; and &lt;code&gt;outputs&lt;/code&gt; Tensors. If true, these &lt;code&gt;Tensors&lt;/code&gt; must be shaped &lt;code&gt;[max_time, batch_size, depth]&lt;/code&gt;. If false, these &lt;code&gt;Tensors&lt;/code&gt; must be shaped &lt;code&gt;[batch_size, max_time, depth]&lt;/code&gt;. Using &lt;code&gt;time_major = True&lt;/code&gt; is a bit more efficient because it avoids transposes at the beginning and end of the RNN calculation. However, most TensorFlow data is batch-major, so by default this function accepts input and emits output in batch-major form.</source>
          <target state="translated">&lt;code&gt;inputs&lt;/code&gt; テンソルと &lt;code&gt;outputs&lt;/code&gt; テンソルの形状形式。 trueの場合、これらの &lt;code&gt;Tensors&lt;/code&gt; は &lt;code&gt;[max_time, batch_size, depth]&lt;/code&gt; 形状にする必要があります。 falseの場合、これらの &lt;code&gt;Tensors&lt;/code&gt; は &lt;code&gt;[batch_size, max_time, depth]&lt;/code&gt; 形状にする必要があります。 &lt;code&gt;time_major = True&lt;/code&gt; を使用すると、RNN計算の開始時と終了時の転置が回避されるため、少し効率的です。ただし、ほとんどのTensorFlowデータはバッチメジャーであるため、デフォルトでは、この関数は入力を受け入れ、バッチメジャー形式で出力を出力します。</target>
        </trans-unit>
        <trans-unit id="e4fa5d6d5a2b3f7febe8c6a21da6334423de8f46" translate="yes" xml:space="preserve">
          <source>The shape format of the &lt;code&gt;inputs&lt;/code&gt; and &lt;code&gt;outputs&lt;/code&gt; tensors. If True, the inputs and outputs will be in shape &lt;code&gt;(timesteps, batch, ...)&lt;/code&gt;, whereas in the False case, it will be &lt;code&gt;(batch, timesteps, ...)&lt;/code&gt;. Using &lt;code&gt;time_major = True&lt;/code&gt; is a bit more efficient because it avoids transposes at the beginning and end of the RNN calculation. However, most TensorFlow data is batch-major, so by default this function accepts input and emits output in batch-major form.</source>
          <target state="translated">&lt;code&gt;inputs&lt;/code&gt; テンソルと &lt;code&gt;outputs&lt;/code&gt; テンソルの形状形式。 Trueの場合、入力と出力の形状は &lt;code&gt;(timesteps, batch, ...)&lt;/code&gt; になりますが、Falseの場合、 &lt;code&gt;(batch, timesteps, ...)&lt;/code&gt; ます。 &lt;code&gt;time_major = True&lt;/code&gt; を使用すると、RNN計算の開始時と終了時の転置が回避されるため、少し効率的です。ただし、ほとんどのTensorFlowデータはバッチメジャーであるため、デフォルトでは、この関数は入力を受け入れ、バッチメジャー形式で出力を出力します。</target>
        </trans-unit>
        <trans-unit id="1ca9d07b430e38f671c59fb716e05624f9098d82" translate="yes" xml:space="preserve">
          <source>The shape format of the &lt;code&gt;inputs&lt;/code&gt; and &lt;code&gt;outputs&lt;/code&gt; tensors. If True, the inputs and outputs will be in shape &lt;code&gt;[timesteps, batch, feature]&lt;/code&gt;, whereas in the False case, it will be &lt;code&gt;[batch, timesteps, feature]&lt;/code&gt;. Using &lt;code&gt;time_major = True&lt;/code&gt; is a bit more efficient because it avoids transposes at the beginning and end of the RNN calculation. However, most TensorFlow data is batch-major, so by default this function accepts input and emits output in batch-major form.</source>
          <target state="translated">&lt;code&gt;inputs&lt;/code&gt; テンソルと &lt;code&gt;outputs&lt;/code&gt; テンソルの形状形式。Trueの場合、入力と出力は &lt;code&gt;[timesteps, batch, feature]&lt;/code&gt; 形になりますが、Falseの場合、 &lt;code&gt;[batch, timesteps, feature]&lt;/code&gt; ます。 &lt;code&gt;time_major = True&lt;/code&gt; を使用すると、RNN計算の開始時と終了時の転置が回避されるため、少し効率的です。ただし、ほとんどのTensorFlowデータはバッチメジャーであるため、デフォルトでは、この関数は入力を受け入れ、バッチメジャー形式で出力を出力します。</target>
        </trans-unit>
        <trans-unit id="9705c68d850f3729f14c8b0e86c4e7a7c9b8a9c5" translate="yes" xml:space="preserve">
          <source>The shape inference functions propagate shapes to the extent possible:</source>
          <target state="translated">形状推論機能は、可能な範囲で形状を伝播させる。</target>
        </trans-unit>
        <trans-unit id="b9cb3dea60cfc74ebbae7817c2108c229a9e9930" translate="yes" xml:space="preserve">
          <source>The shape invariants for the loop variables.</source>
          <target state="translated">ループ変数の形状不変量。</target>
        </trans-unit>
        <trans-unit id="081af2a7657fa36a381b1785e67936a8d191debb" translate="yes" xml:space="preserve">
          <source>The shape is computed using shape inference functions that are registered for each &lt;a href=&quot;operation&quot;&gt;&lt;code&gt;tf.Operation&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">形状は、各&lt;a href=&quot;operation&quot;&gt; &lt;code&gt;tf.Operation&lt;/code&gt; に&lt;/a&gt;登録されている形状推論関数を使用して計算されます。</target>
        </trans-unit>
        <trans-unit id="7bc1bd93e711b8be01e066d838cfcf34409f0c38" translate="yes" xml:space="preserve">
          <source>The shape is computed using shape inference functions that are registered in the Op for each &lt;code&gt;Operation&lt;/code&gt;. See &lt;a href=&quot;tensorshape&quot;&gt;&lt;code&gt;tf.TensorShape&lt;/code&gt;&lt;/a&gt; for more details of what a shape represents.</source>
          <target state="translated">形状は、各 &lt;code&gt;Operation&lt;/code&gt; 登録されている形状推論関数を使用して計算されます。形状が表すものの詳細については、&lt;a href=&quot;tensorshape&quot;&gt; &lt;code&gt;tf.TensorShape&lt;/code&gt; &lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="5319f783b1231c02b92342d27602eef300f0a629" translate="yes" xml:space="preserve">
          <source>The shape of arguments to &lt;code&gt;__init__&lt;/code&gt;, &lt;code&gt;cdf&lt;/code&gt;, &lt;code&gt;log_cdf&lt;/code&gt;, &lt;code&gt;prob&lt;/code&gt;, and &lt;code&gt;log_prob&lt;/code&gt; reflect this broadcasting, as does the return value of &lt;code&gt;sample&lt;/code&gt; and &lt;code&gt;sample_n&lt;/code&gt;.</source>
          <target state="translated">引数の形状 &lt;code&gt;__init__&lt;/code&gt; 、 &lt;code&gt;cdf&lt;/code&gt; 、 &lt;code&gt;log_cdf&lt;/code&gt; 、 &lt;code&gt;prob&lt;/code&gt; 、および &lt;code&gt;log_prob&lt;/code&gt; はの戻り値同じように、この放送を反映し &lt;code&gt;sample&lt;/code&gt; と &lt;code&gt;sample_n&lt;/code&gt; が。</target>
        </trans-unit>
        <trans-unit id="c9539ceccae379560bc28e4de427220124dc1b7f" translate="yes" xml:space="preserve">
          <source>The shape of each element in the &lt;code&gt;TensorArray&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;TensorArray&lt;/code&gt; の各要素の形状。</target>
        </trans-unit>
        <trans-unit id="019adcd66453633d864b6a68c6e8a1ef2fb39d18" translate="yes" xml:space="preserve">
          <source>The shape of the &lt;code&gt;indices&lt;/code&gt; component, which indicates how many slices are in the &lt;code&gt;IndexedSlices&lt;/code&gt;.</source>
          <target state="translated">形状 &lt;code&gt;indices&lt;/code&gt; であるか多くのスライスを示し成分、 &lt;code&gt;IndexedSlices&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2a83199f6a8139b3838bc185a252e39d72f892d5" translate="yes" xml:space="preserve">
          <source>The shape of the RaggedTensor, or &lt;code&gt;None&lt;/code&gt; to allow any shape. If a shape is specified, then all ragged dimensions must have size &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">RaggedTensorの形状、または任意の形状を許可する場合は &lt;code&gt;None&lt;/code&gt; 。形状を指定する場合、すべての不規則な寸法のサイズは &lt;code&gt;None&lt;/code&gt; である必要があります。</target>
        </trans-unit>
        <trans-unit id="aed84e9082260c1530ba06836ab583c0743099df" translate="yes" xml:space="preserve">
          <source>The shape of the elements of the given list, as a tensor.</source>
          <target state="translated">与えられたリストの要素の形状をテンソルとして表します。</target>
        </trans-unit>
        <trans-unit id="7ae769cd7a979ed862a9572cd30406fef8fee2dc" translate="yes" xml:space="preserve">
          <source>The shape of the input data per sequence id. E.g. if &lt;code&gt;shape=(2,)&lt;/code&gt;, each example must contain &lt;code&gt;2 * sequence_length&lt;/code&gt; values.</source>
          <target state="translated">シーケンスIDごとの入力データの形状。たとえば、 &lt;code&gt;shape=(2,)&lt;/code&gt; 場合、各例には &lt;code&gt;2 * sequence_length&lt;/code&gt; 値が含まれている必要があります。</target>
        </trans-unit>
        <trans-unit id="3720998b3d73539e8c9661d288914e2cdaa82ba7" translate="yes" xml:space="preserve">
          <source>The shape of the output tensor is:</source>
          <target state="translated">出力テンソルの形状は</target>
        </trans-unit>
        <trans-unit id="b54a3296d32e764f7303629c8f4e133de6a9a7b0" translate="yes" xml:space="preserve">
          <source>The shape of the output will be:</source>
          <target state="translated">出力の形になります。</target>
        </trans-unit>
        <trans-unit id="ac04b940314214f5e17141730326fbc95d00e6e3" translate="yes" xml:space="preserve">
          <source>The shape of the resulting dense tensor. In particular, &lt;code&gt;result.shape[i]&lt;/code&gt; is &lt;code&gt;shape[i]&lt;/code&gt; (if &lt;code&gt;shape[i]&lt;/code&gt; is not None), or &lt;code&gt;self.bounding_shape(i)&lt;/code&gt; (otherwise).&lt;code&gt;shape.rank&lt;/code&gt; must be &lt;code&gt;None&lt;/code&gt; or equal to &lt;code&gt;self.rank&lt;/code&gt;.</source>
          <target state="translated">結果として得られる密なテンソルの形状。特に、 &lt;code&gt;result.shape[i]&lt;/code&gt; は &lt;code&gt;shape[i]&lt;/code&gt; （ &lt;code&gt;shape[i]&lt;/code&gt; がNoneでない場合）、または &lt;code&gt;self.bounding_shape(i)&lt;/code&gt; （それ以外の場合）です。 &lt;code&gt;shape.rank&lt;/code&gt; は &lt;code&gt;None&lt;/code&gt; または &lt;code&gt;self.rank&lt;/code&gt; と等しくなければなりません。</target>
        </trans-unit>
        <trans-unit id="2c9a810e455caa2b0b6f686bf9c200a962c54ef3" translate="yes" xml:space="preserve">
          <source>The shape of the state is algorithm-specific.</source>
          <target state="translated">状態の形状はアルゴリズム固有のものです。</target>
        </trans-unit>
        <trans-unit id="3389c6b2701837ccb66fc16af6826d909f63b514" translate="yes" xml:space="preserve">
          <source>The shape of the tensor to be fed (optional). If the shape is not specified, you can feed a sparse tensor of any shape.</source>
          <target state="translated">供給するテンソルの形状(オプション)。shapeが指定されていない場合は、任意の形状の疎なテンソルを供給することができます。</target>
        </trans-unit>
        <trans-unit id="376d2cc370b5ba232fdf37d951603c116bb04786" translate="yes" xml:space="preserve">
          <source>The shape of the tensor to be fed (optional). If the shape is not specified, you can feed a tensor of any shape.</source>
          <target state="translated">供給するテンソルの形状(オプション)。形状が指定されていない場合は、任意の形状のテンソルを供給することができます。</target>
        </trans-unit>
        <trans-unit id="b04d4e03100c6f081b5e785ea772cca017db1933" translate="yes" xml:space="preserve">
          <source>The shapes of the two operands must match: broadcasting is not supported.</source>
          <target state="translated">2つのオペランドの形状が一致していなければなりません。</target>
        </trans-unit>
        <trans-unit id="348113de328d02812f9ca2ed7f6d52b929c19ce9" translate="yes" xml:space="preserve">
          <source>The simplest form of RNN network generated is:</source>
          <target state="translated">生成されたRNNネットワークの最も単純な形態は、以下の通りである。</target>
        </trans-unit>
        <trans-unit id="ff2f171ddc511ae06abeb2ff57b6d8a5b4678a63" translate="yes" xml:space="preserve">
          <source>The simplest form of scatter is to insert individual elements in a tensor by index. For example, say we want to insert 4 scattered elements in a rank-1 tensor with 8 elements.</source>
          <target state="translated">散布の最も単純な形は、テンソルの中にインデックスで個々の要素を挿入することです。例えば、8つの要素を持つランク1のテンソルに4つの散布要素を挿入したいとします。</target>
        </trans-unit>
        <trans-unit id="f366cdfba69e2fc90954206f2645c89f45fbcd17" translate="yes" xml:space="preserve">
          <source>The simplest form of tensor_scatter_add is to add individual elements to a tensor by index. For example, say we want to add 4 elements in a rank-1 tensor with 8 elements.</source>
          <target state="translated">tensor_scatter_addの最も単純な形式は、テンソルにインデックスで個々の要素を追加することです。例えば、8つの要素を持つランク1のテンソルに4つの要素を追加したいとします。</target>
        </trans-unit>
        <trans-unit id="3af9f04f82cbb797b19d70da5fb65e10e6f6ef91" translate="yes" xml:space="preserve">
          <source>The simplest form of tensor_scatter_sub is to subtract individual elements from a tensor by index. For example, say we want to insert 4 scattered elements in a rank-1 tensor with 8 elements.</source>
          <target state="translated">tensor_scatter_subの最も単純な形式は、テンソルから個々の要素をインデックスで減算することです。例えば、8つの要素を持つランク1のテンソルに4つの散乱要素を挿入したいとします。</target>
        </trans-unit>
        <trans-unit id="802d517fc471afa54d770d15cdbc678a89e0c7a9" translate="yes" xml:space="preserve">
          <source>The simplest version of &lt;code&gt;map_fn&lt;/code&gt; repeatedly applies the callable &lt;code&gt;fn&lt;/code&gt; to a sequence of elements from first to last. The elements are made of the tensors unpacked from &lt;code&gt;elems&lt;/code&gt;. &lt;code&gt;dtype&lt;/code&gt; is the data type of the return value of &lt;code&gt;fn&lt;/code&gt;. Users must provide &lt;code&gt;dtype&lt;/code&gt; if it is different from the data type of &lt;code&gt;elems&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;map_fn&lt;/code&gt; の最も単純なバージョンは、呼び出し可能な &lt;code&gt;fn&lt;/code&gt; を最初から最後まで一連の要素に繰り返し適用します。要素は、要素から &lt;code&gt;elems&lt;/code&gt; たテンソルで構成されています。 &lt;code&gt;dtype&lt;/code&gt; は、 &lt;code&gt;fn&lt;/code&gt; の戻り値のデータ型です。ユーザーが提供しなければならない &lt;code&gt;dtype&lt;/code&gt; 、それはのデータ型と異なる場合 &lt;code&gt;elems&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d7f6d20e0852a13ae739990f6fedc34688b995c0" translate="yes" xml:space="preserve">
          <source>The simplest version of &lt;code&gt;scan&lt;/code&gt; repeatedly applies the callable &lt;code&gt;fn&lt;/code&gt; to a sequence of elements from first to last. The elements are made of the tensors unpacked from &lt;code&gt;elems&lt;/code&gt; on dimension 0. The callable fn takes two tensors as arguments. The first argument is the accumulated value computed from the preceding invocation of fn, and the second is the value at the current position of &lt;code&gt;elems&lt;/code&gt;. If &lt;code&gt;initializer&lt;/code&gt; is None, &lt;code&gt;elems&lt;/code&gt; must contain at least one element, and its first element is used as the initializer.</source>
          <target state="translated">&lt;code&gt;scan&lt;/code&gt; の最も単純なバージョンは、呼び出し可能な &lt;code&gt;fn&lt;/code&gt; を最初から最後まで一連の要素に繰り返し適用します。要素がテンソルで作られていますからアンパック &lt;code&gt;elems&lt;/code&gt; 次元に0呼び出し可能なFNは、引数として2つのテンソルをとります。最初の引数は、前のfnの呼び出しから計算された累積値であり、2番目の引数は、 &lt;code&gt;elems&lt;/code&gt; の現在の位置での値です。 &lt;code&gt;initializer&lt;/code&gt; がNoneの場合、 &lt;code&gt;elems&lt;/code&gt; には少なくとも1つの要素が含まれている必要があり、その最初の要素が初期化子として使用されます。</target>
        </trans-unit>
        <trans-unit id="7a38981091aad7a606ea4d4d2a567d64ac905976" translate="yes" xml:space="preserve">
          <source>The simplest way to create a dataset is to create it from a python &lt;code&gt;list&lt;/code&gt;:</source>
          <target state="translated">データセットを作成する最も簡単な方法は、Python &lt;code&gt;list&lt;/code&gt; から作成することです。</target>
        </trans-unit>
        <trans-unit id="8c730f2755df0951b225a0138c6c5b2d885cf90a" translate="yes" xml:space="preserve">
          <source>The size of &lt;code&gt;tensor_names&lt;/code&gt; must match the number of tensors in &lt;code&gt;data&lt;/code&gt;. &lt;code&gt;data[i]&lt;/code&gt; is written to &lt;code&gt;filename&lt;/code&gt; with name &lt;code&gt;tensor_names[i]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;tensor_names&lt;/code&gt; のサイズは、 &lt;code&gt;data&lt;/code&gt; 内のテンソルの数と一致する必要があります。 &lt;code&gt;data[i]&lt;/code&gt; は、 &lt;code&gt;tensor_names[i]&lt;/code&gt; という名前の &lt;code&gt;filename&lt;/code&gt; 書き込まれます。</target>
        </trans-unit>
        <trans-unit id="ab51731901ff080d9eff54a48d6859d0f1323c1a" translate="yes" xml:space="preserve">
          <source>The size of the resulting dataset will match the size of the smallest input dataset, and no error will be raised if input datasets have different sizes.</source>
          <target state="translated">結果として得られるデータセットのサイズは,最小の入力データセットのサイズと一致し,入力データセットのサイズが異なっていてもエラーは発生しません.</target>
        </trans-unit>
        <trans-unit id="017e6c560666c8b8adcda856df4242248fd294ae" translate="yes" xml:space="preserve">
          <source>The sizes of the pooling regions are generated randomly but are fairly uniform. For example, let's look at the height dimension, and the constraints on the list of rows that will be pool boundaries.</source>
          <target state="translated">プール領域のサイズはランダムに生成されますが、かなり均一です。例えば、高さ寸法と、プールの境界となる行のリストに対する制約を見てみましょう。</target>
        </trans-unit>
        <trans-unit id="3c43eb48e9249082c6dab3dc37ecd5648014a1b5" translate="yes" xml:space="preserve">
          <source>The snapshot API allows users to transparently persist the output of their preprocessing pipeline to disk, and materialize the pre-processed data on a different training run.</source>
          <target state="translated">スナップショットAPIにより、ユーザーは前処理パイプラインの出力を透過的にディスクに永続化し、別のトレーニングランで前処理されたデータを実体化することができます。</target>
        </trans-unit>
        <trans-unit id="50a231b5d401442573df3e17bbb0c7335e8e5d44" translate="yes" xml:space="preserve">
          <source>The softmax of each vector x is calculated by &lt;code&gt;exp(x)/tf.reduce_sum(exp(x))&lt;/code&gt;. The input values in are the log-odds of the resulting probability.</source>
          <target state="translated">各ベクトルxの &lt;code&gt;exp(x)/tf.reduce_sum(exp(x))&lt;/code&gt; は、exp（x）/tf.reduce_sum（exp（x））によって計算されます。の入力値は、結果の確率の対数オッズです。</target>
        </trans-unit>
        <trans-unit id="887fc2159220b03235a84826c28912f3876b1988" translate="yes" xml:space="preserve">
          <source>The softmax of each vector x is computed as &lt;code&gt;exp(x) / tf.reduce_sum(exp(x))&lt;/code&gt;.</source>
          <target state="translated">各ベクトルxの &lt;code&gt;exp(x) / tf.reduce_sum(exp(x))&lt;/code&gt; は、exp（x）/ tf.reduce_sum（exp（x））として計算されます。</target>
        </trans-unit>
        <trans-unit id="b6d8793457c083f0d11acb319bb58de8dcf61657" translate="yes" xml:space="preserve">
          <source>The softplus activation: &lt;code&gt;log(exp(x) + 1)&lt;/code&gt;.</source>
          <target state="translated">ソフトプラスのアクティブ化： &lt;code&gt;log(exp(x) + 1)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a35f61726860bd793a42b2269f7f12bfff5f5061" translate="yes" xml:space="preserve">
          <source>The softplus activation: &lt;code&gt;x / (abs(x) + 1)&lt;/code&gt;.</source>
          <target state="translated">softplusアクティベーション： &lt;code&gt;x / (abs(x) + 1)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6cdf43d3dd10a8cc3aa784daa0a9e1312644b77d" translate="yes" xml:space="preserve">
          <source>The softsign activation: &lt;code&gt;x / (abs(x) + 1)&lt;/code&gt;.</source>
          <target state="translated">ソフトサインのアクティブ化： &lt;code&gt;x / (abs(x) + 1)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6542d7e39f0c310801daa6538837ad6138ffae82" translate="yes" xml:space="preserve">
          <source>The solution is to ensure any access to the underlying resource &lt;code&gt;v&lt;/code&gt; is only processed through a critical section:</source>
          <target state="translated">解決策は、基になるリソースへのアクセス &lt;code&gt;v&lt;/code&gt; がクリティカルセクションでのみ処理されるようにすることです。</target>
        </trans-unit>
        <trans-unit id="48c0d2fec393318121a3ea291f2dd8dccd7b38fa" translate="yes" xml:space="preserve">
          <source>The solution is to identify which gradient call this particular TensorArray gradient is being called in. This is performed by identifying a unique string (e.g. &quot;gradients&quot;, &quot;gradients_1&quot;, ...) from the input gradient Tensor's name. This string is used as a suffix when creating the TensorArray gradient object here (the attribute &lt;code&gt;source&lt;/code&gt;).</source>
          <target state="translated">解決策は、この特定のTensorArrayグラデーションが呼び出されているグラデーション呼び出しを識別することです。これは、入力グラデーションTensorの名前から一意の文字列（「gradients」、「gradients_1」など）を識別することによって実行されます。この文字列は、ここでTensorArrayグラデーションオブジェクト（属性 &lt;code&gt;source&lt;/code&gt; ）を作成するときに接尾辞として使用されます。</target>
        </trans-unit>
        <trans-unit id="8a9c87c3bbd16608d71f6244bf102c899fcfe323" translate="yes" xml:space="preserve">
          <source>The solution is to wrap the model construction and execution in a keras-style scope:</source>
          <target state="translated">この解決策は、モデルの構築と実行をkerasスタイルのスコープでラップすることです。</target>
        </trans-unit>
        <trans-unit id="e590f462584ca8d9fda3b6ea3ab70cb8db99fef3" translate="yes" xml:space="preserve">
          <source>The source of the non-determinism will be platform- and time-dependent.</source>
          <target state="translated">非決定論の発生源はプラットフォームと時間に依存するだろう。</target>
        </trans-unit>
        <trans-unit id="7b94d68698f376ae68caf545ac2ad9ff65451535" translate="yes" xml:space="preserve">
          <source>The sparse implementation of this algorithm (used when the gradient is an IndexedSlices object, typically because of &lt;a href=&quot;../../../gather&quot;&gt;&lt;code&gt;tf.gather&lt;/code&gt;&lt;/a&gt; or an embedding lookup in the forward pass) does apply momentum to variable slices even if they were not used in the forward pass (meaning they have a gradient equal to zero). Momentum decay (beta1) is also applied to the entire momentum accumulator. This means that the sparse behavior is equivalent to the dense behavior (in contrast to some momentum implementations which ignore momentum unless a variable slice was actually used).</source>
          <target state="translated">このアルゴリズムのスパース実装（グラデーションがIndexedSlicesオブジェクトである場合、通常は&lt;a href=&quot;../../../gather&quot;&gt; &lt;code&gt;tf.gather&lt;/code&gt; &lt;/a&gt;またはフォワードパスでの埋め込みルックアップのために使用されます）は、フォワードパスで使用されなかった（つまり、勾配がゼロに等しい）。運動量減衰（beta1）は、運動量アキュムレータ全体にも適用されます。これは、スパース動作がデンス動作と同等であることを意味します（変数スライスが実際に使用されない限り、運動量を無視するいくつかの運動量実装とは対照的です）。</target>
        </trans-unit>
        <trans-unit id="2c28505e1992f5a2d21a399d52aaf1d49a6228f7" translate="yes" xml:space="preserve">
          <source>The sparse implementation of this algorithm (used when the gradient is an IndexedSlices object, typically because of &lt;a href=&quot;../../gather&quot;&gt;&lt;code&gt;tf.gather&lt;/code&gt;&lt;/a&gt; or an embedding lookup in the forward pass) does apply momentum to variable slices even if they were not used in the forward pass (meaning they have a gradient equal to zero). Momentum decay (beta1) is also applied to the entire momentum accumulator. This means that the sparse behavior is equivalent to the dense behavior (in contrast to some momentum implementations which ignore momentum unless a variable slice was actually used).</source>
          <target state="translated">このアルゴリズムのスパース実装（グラデーションがIndexedSlicesオブジェクトである場合、通常は&lt;a href=&quot;../../gather&quot;&gt; &lt;code&gt;tf.gather&lt;/code&gt; &lt;/a&gt;またはフォワードパスでの埋め込みルックアップのために使用されます）は、フォワードパスで使用されなかった（つまり、勾配がゼロに等しい）。運動量減衰（beta1）は、運動量アキュムレータ全体にも適用されます。これは、スパース動作がデンス動作と同等であることを意味します（変数スライスが実際に使用されない限り、運動量を無視するいくつかの運動量実装とは対照的です）。</target>
        </trans-unit>
        <trans-unit id="e5bdcabcaa194b28393438e39e1590c0f77ff2c8" translate="yes" xml:space="preserve">
          <source>The sparse matrix product may have numeric (non-structural) zeros.</source>
          <target state="translated">疎な行列積は,数値的な(非構造的な)ゼロを有していてもよい.</target>
        </trans-unit>
        <trans-unit id="dedfba1684c4375e13d104a45eb8d51735e2b834" translate="yes" xml:space="preserve">
          <source>The sparse tensor to convert. Must have rank 2.</source>
          <target state="translated">変換するスパーステンソル。ランク2でなければなりません.</target>
        </trans-unit>
        <trans-unit id="b54e597f7fe46cc2667d4b65cc738c9c9db301ba" translate="yes" xml:space="preserve">
          <source>The specified output type of the operation (&lt;code&gt;int32&lt;/code&gt; or &lt;code&gt;int64&lt;/code&gt;). Defaults to &lt;a href=&quot;../tf#int32&quot;&gt;&lt;code&gt;tf.int32&lt;/code&gt;&lt;/a&gt;(optional).</source>
          <target state="translated">指定された操作の出力タイプ（ &lt;code&gt;int32&lt;/code&gt; または &lt;code&gt;int64&lt;/code&gt; ）。デフォルトは&lt;a href=&quot;../tf#int32&quot;&gt; &lt;code&gt;tf.int32&lt;/code&gt; &lt;/a&gt;（オプション）です。</target>
        </trans-unit>
        <trans-unit id="8b88004b19728b58b00753256fbdb980b735e8d2" translate="yes" xml:space="preserve">
          <source>The split indices for the ragged tensor value.</source>
          <target state="translated">ゴロゴロしたテンソル値の分割インデックス。</target>
        </trans-unit>
        <trans-unit id="f49d81f2a44d35cf534ae7fd8c45debcfaf469ae" translate="yes" xml:space="preserve">
          <source>The split information is the best threshold (bucket id), gains and left/right node contributions per node for each feature.</source>
          <target state="translated">分割情報は、特徴量ごとに最適な閾値(バケットID)、ゲイン、ノードごとの左右ノード貢献度です。</target>
        </trans-unit>
        <trans-unit id="25fdcf5ad4499cdb6d4201c3ecb0186f730f52b9" translate="yes" xml:space="preserve">
          <source>The standard &lt;code&gt;segment_*&lt;/code&gt; functions assert that the segment indices are sorted. If you have unsorted indices use the equivalent &lt;code&gt;unsorted_segment_&lt;/code&gt; function. These functions take an additional argument &lt;code&gt;num_segments&lt;/code&gt; so that the output tensor can be efficiently allocated.</source>
          <target state="translated">標準の &lt;code&gt;segment_*&lt;/code&gt; 関数は、セグメントインデックスがソートされていることを表明します。ソートされていないインデックスがある場合は、同等の &lt;code&gt;unsorted_segment_&lt;/code&gt; 関数を使用してください。これらの関数は、出力テンソルを効率的に割り当てることができるように、追加の引数 &lt;code&gt;num_segments&lt;/code&gt; を取ります。</target>
        </trans-unit>
        <trans-unit id="b29667fc1f908940634484906fb6441d097a55ad" translate="yes" xml:space="preserve">
          <source>The standard &lt;code&gt;segment_*&lt;/code&gt; functions assert that the segment indices are sorted. If you have unsorted indices use the equivalent &lt;code&gt;unsorted_segment_&lt;/code&gt; function. Thses functions take an additional argument &lt;code&gt;num_segments&lt;/code&gt; so that the output tensor can be efficiently allocated.</source>
          <target state="translated">標準の &lt;code&gt;segment_*&lt;/code&gt; 関数は、セグメントインデックスがソートされていることをアサートします。ソートされていないインデックスがある場合は、同等の &lt;code&gt;unsorted_segment_&lt;/code&gt; 関数を使用します。これらの関数は、出力テンソルを効率的に割り当てることができるように、追加の引数 &lt;code&gt;num_segments&lt;/code&gt; を取ります。</target>
        </trans-unit>
        <trans-unit id="6cf74e13a5dc987612c9d705626f37de29ad545f" translate="yes" xml:space="preserve">
          <source>The standard library uses various well-known names to collect and retrieve values associated with a graph. For example, the &lt;code&gt;tf.Optimizer&lt;/code&gt; subclasses default to optimizing the variables collected under &lt;code&gt;tf.GraphKeys.TRAINABLE_VARIABLES&lt;/code&gt; if none is specified, but it is also possible to pass an explicit list of variables.</source>
          <target state="translated">標準ライブラリは、さまざまな既知の名前を使用して、グラフに関連付けられた値を収集および取得します。たとえば、 &lt;code&gt;tf.Optimizer&lt;/code&gt; サブクラスは、何も指定されていない場合、デフォルトで &lt;code&gt;tf.GraphKeys.TRAINABLE_VARIABLES&lt;/code&gt; で収集された変数を最適化しますが、変数の明示的なリストを渡すこともできます。</target>
        </trans-unit>
        <trans-unit id="ce8c36f190ecab29f1604c69bb1fdd2396d6f9bd" translate="yes" xml:space="preserve">
          <source>The standard pattern for updating variables is to:</source>
          <target state="translated">変数を更新するのが定番のパターンです。</target>
        </trans-unit>
        <trans-unit id="1df550e9ac2ff1efc86381fe4007d40151e6c36c" translate="yes" xml:space="preserve">
          <source>The started thread is added to the list of threads managed by the supervisor so it does not need to be passed to the &lt;code&gt;stop()&lt;/code&gt; method.</source>
          <target state="translated">開始されたスレッドは、監視プログラムによって管理されるスレッドのリストに追加されるため、 &lt;code&gt;stop()&lt;/code&gt; メソッドに渡す必要はありません。</target>
        </trans-unit>
        <trans-unit id="22b0c0a61720b2b49f3bdb46b68ab2ffe3bd7116" translate="yes" xml:space="preserve">
          <source>The started thread.</source>
          <target state="translated">始まったスレッド。</target>
        </trans-unit>
        <trans-unit id="04fb16ca663bd50a2194064568a76d4c96b84f17" translate="yes" xml:space="preserve">
          <source>The starting value for accumulators. Only zero or positive values are allowed.</source>
          <target state="translated">アキュムレータの開始値。ゼロまたは正の値のみが許可されます。</target>
        </trans-unit>
        <trans-unit id="c25d85454a9ea543e59596d91af95b242b42d7a4" translate="yes" xml:space="preserve">
          <source>The state of the RNG after &lt;code&gt;rng_skip(n)&lt;/code&gt; will be the same as that after &lt;code&gt;stateful_uniform([n])&lt;/code&gt; (or any other distribution). The actual increment added to the counter is an unspecified implementation detail.</source>
          <target state="translated">&lt;code&gt;rng_skip(n)&lt;/code&gt; 後のRNGの状態は、 &lt;code&gt;stateful_uniform([n])&lt;/code&gt; （またはその他の分布）後の状態と同じになります。カウンターに追加される実際の増分は、不特定の実装の詳細です。</target>
        </trans-unit>
        <trans-unit id="dd546c154f1294509a35cef6daf7e05272419f55" translate="yes" xml:space="preserve">
          <source>The state of the optimizer, allowing to resume training exactly where you left off.</source>
          <target state="translated">オプティマイザの状態は、あなたが去った場所でトレーニングを再開することを可能にします。</target>
        </trans-unit>
        <trans-unit id="712f8a6f55bf7c5b4fd684dab030efe40f46ccee" translate="yes" xml:space="preserve">
          <source>The statically known shape of this ragged tensor.</source>
          <target state="translated">このぼろぼろテンソルの統計的に知られた形状。</target>
        </trans-unit>
        <trans-unit id="05eef5966a4733b45681c7bb2c1cfa7fcd7e3ded" translate="yes" xml:space="preserve">
          <source>The statistics options associated with the dataset. See &lt;a href=&quot;experimental/statsoptions&quot;&gt;&lt;code&gt;tf.data.experimental.StatsOptions&lt;/code&gt;&lt;/a&gt; for more details.</source>
          <target state="translated">データセットに関連付けられている統計オプション。詳細については、&lt;a href=&quot;experimental/statsoptions&quot;&gt; &lt;code&gt;tf.data.experimental.StatsOptions&lt;/code&gt; &lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="a8c6e46a80c3223660eded889659ea2c4138b476" translate="yes" xml:space="preserve">
          <source>The step set by &lt;a href=&quot;set_step&quot;&gt;&lt;code&gt;tf.summary.experimental.set_step()&lt;/code&gt;&lt;/a&gt; if one has been set, otherwise None.</source>
          <target state="translated">ステップが設定されている場合は&lt;a href=&quot;set_step&quot;&gt; &lt;code&gt;tf.summary.experimental.set_step()&lt;/code&gt; &lt;/a&gt;によって設定され、それ以外の場合はなし。</target>
        </trans-unit>
        <trans-unit id="5dff7b910b7ad17251b2c5a9c0f91aaacc64e975" translate="yes" xml:space="preserve">
          <source>The str() operator of a 'FlagValues' object provides help for all of the registered 'Flag' objects.</source>
          <target state="translated">FlagValues'オブジェクトのstr()演算子は、登録されているすべての'Flag'オブジェクトのヘルプを提供します。</target>
        </trans-unit>
        <trans-unit id="13be6068510e1bba9bcaba7458adf0809e711454" translate="yes" xml:space="preserve">
          <source>The strategy may choose to put the variable on multiple devices, like mirrored variables, but unlike mirrored variables we don't synchronize the updates to them to make sure they have the same value. Instead, the synchronization is performed when reading in cross-replica context. In a replica context, reads and writes are performed on the local copy (we allow reads so you can write code like &lt;code&gt;v = 0.9*v + 0.1*update&lt;/code&gt;). We don't allow operations like &lt;code&gt;v.assign_add&lt;/code&gt; in a cross-replica context for sync on read variables; right now we don't have a use case for such updates and depending on the aggregation mode such updates may not be sensible.</source>
          <target state="translated">戦略は、ミラーリングされた変数のように、変数を複数のデバイスに配置することを選択できますが、ミラーリングされた変数とは異なり、更新をそれらに同期させて、それらが同じ値になることを確認しません。代わりに、レプリカ間で読み取るときに同期が実行されます。レプリカのコンテキストでは、読み取りと書き込みはローカルコピーで実行されます（読み取りを許可するため、 &lt;code&gt;v = 0.9*v + 0.1*update&lt;/code&gt; ようなコードを記述できます）。読み取り変数の同期のために、クロスレプリカコンテキストで &lt;code&gt;v.assign_add&lt;/code&gt; のような操作を行うことはできません。現在、このような更新の使用例はありません。集計モードによっては、このような更新が適切でない場合があります。</target>
        </trans-unit>
        <trans-unit id="d3fd5c3cf46ac06d0260b1f659bcc1a0b81cadee" translate="yes" xml:space="preserve">
          <source>The stream whose writes should be captured. This stream must have a file descriptor, support writing via using that file descriptor, and must have a &lt;code&gt;.flush()&lt;/code&gt; method.</source>
          <target state="translated">書き込みをキャプチャする必要があるストリーム。このストリームにはファイル記述子が必要であり、そのファイル記述子を使用した書き込みをサポートし、 &lt;code&gt;.flush()&lt;/code&gt; メソッドが必要です。</target>
        </trans-unit>
        <trans-unit id="644f3a81fca55d1677b34a373591148f236e0ab3" translate="yes" xml:space="preserve">
          <source>The string &quot;tensorflow&quot;.</source>
          <target state="translated">文字列「テンソルフロー」。</target>
        </trans-unit>
        <trans-unit id="cc503fc832fae0582037d46d99a283b2143a5687" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;-&lt;/code&gt; meaning that the slice covers all indices of this dimension</source>
          <target state="translated">文字列 &lt;code&gt;-&lt;/code&gt; スライスがこの次元のすべてのインデックスをカバーすることを意味します</target>
        </trans-unit>
        <trans-unit id="8540ba2c73157ed83e7a8b8d1ba5f66009b9e41f" translate="yes" xml:space="preserve">
          <source>The string name of a job in this cluster.</source>
          <target state="translated">このクラスタ内のジョブの文字列名。</target>
        </trans-unit>
        <trans-unit id="56132600b50269345758de3a44957eaf5ba36a10" translate="yes" xml:space="preserve">
          <source>The string name of the device to which this op has been assigned, or an empty string if it has not been assigned to a device.</source>
          <target state="translated">このオプが割り当てられたデバイスの文字列名、またはデバイスに割り当てられていない場合は空文字列。</target>
        </trans-unit>
        <trans-unit id="8992e1dfe2880c9a4de6beb1ac8e0230422a7a79" translate="yes" xml:space="preserve">
          <source>The string name of the underlying Queue.</source>
          <target state="translated">下位のキューの文字列名。</target>
        </trans-unit>
        <trans-unit id="a96aa4c9d9595a33bb0f9789d55b573d138edebb" translate="yes" xml:space="preserve">
          <source>The string name of this tensor.</source>
          <target state="translated">このテンソルの文字列名。</target>
        </trans-unit>
        <trans-unit id="c67de356b037fd5e8be6d855afae37205aa00794" translate="yes" xml:space="preserve">
          <source>The string path to the exported directory or &lt;code&gt;None&lt;/code&gt; if export is skipped.</source>
          <target state="translated">エクスポートされたディレクトリへの文字列パス。エクスポートがスキップされた場合は &lt;code&gt;None&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e5efe1c4c830550f08c9bea1e979d7c9a7668a12" translate="yes" xml:space="preserve">
          <source>The string path to the exported directory.</source>
          <target state="translated">エクスポートされたディレクトリへの文字列パス。</target>
        </trans-unit>
        <trans-unit id="e6d17d88d9f96bec8835a8d4d00d7ee284382edf" translate="yes" xml:space="preserve">
          <source>The string representation of a persistent tensor handle.</source>
          <target state="translated">永続的なテンソルハンドルの文字列表現。</target>
        </trans-unit>
        <trans-unit id="a8d628e9b8c8f44ad4c03facb818cd42847e7780" translate="yes" xml:space="preserve">
          <source>The string to use to separate the inputs. Defaults to &quot; &quot;.</source>
          <target state="translated">入力を分離するために使用する文字列。デフォルトは&quot; &quot;です。</target>
        </trans-unit>
        <trans-unit id="b4d0576ccdc2458c02c95d244e31139154833425" translate="yes" xml:space="preserve">
          <source>The string type of an operation. This corresponds to the &lt;code&gt;OpDef.name&lt;/code&gt; field for the proto that defines the operation.</source>
          <target state="translated">操作の文字列タイプ。これは、操作を定義するプロトの &lt;code&gt;OpDef.name&lt;/code&gt; フィールドに対応します。</target>
        </trans-unit>
        <trans-unit id="a17bd3da8a69a3dada0980459ac9d927bbc1c342" translate="yes" xml:space="preserve">
          <source>The string we try to match with the items in regexes.</source>
          <target state="translated">正規表現の項目と一致させようとする文字列。</target>
        </trans-unit>
        <trans-unit id="bb20559dca432fe77c06ffe1211357d7726b77ab" translate="yes" xml:space="preserve">
          <source>The structure of the components of this optional.</source>
          <target state="translated">このオプションの構成要素の構造。</target>
        </trans-unit>
        <trans-unit id="636182e5686aa0b143279a1925716c9803dd42dc" translate="yes" xml:space="preserve">
          <source>The stubbing is using the builtin getattr and setattr. So, the &lt;strong&gt;get&lt;/strong&gt; and &lt;strong&gt;set&lt;/strong&gt; will be called when stubbing ( probably be to manipulate obj.&lt;strong&gt;dict&lt;/strong&gt; instead of getattr() and setattr()).</source>
          <target state="translated">スタブは、組み込みのgetattrとsetattrを使用しています。だから、&lt;strong&gt;GET&lt;/strong&gt;や&lt;strong&gt;セットは&lt;/strong&gt;スタブ（たぶん。OBJ操作することが可能と呼び出される&lt;strong&gt;辞書&lt;/strong&gt;代わりにGETATTRのを（）とSETATTR（））。</target>
        </trans-unit>
        <trans-unit id="10e607f82b834bedf8082612b2f31785cf1834ed" translate="yes" xml:space="preserve">
          <source>The stubbing is using the builtin getattr and setattr. So, the &lt;strong&gt;get&lt;/strong&gt; and &lt;strong&gt;set&lt;/strong&gt; will be called when stubbing (TODO: A better idea would probably be to manipulate obj.&lt;strong&gt;dict&lt;/strong&gt; instead of getattr() and setattr()).</source>
          <target state="translated">スタブは組み込みのgetattrとsetattrを使用しています。だから、&lt;strong&gt;GET&lt;/strong&gt;と&lt;strong&gt;セットが&lt;/strong&gt;スタブときに呼び出されます（。TODO：良いアイデアはおそらくOBJを操作することであろう&lt;strong&gt;dictの&lt;/strong&gt;代わりにGETATTRのを（）とSETATTR（））。</target>
        </trans-unit>
        <trans-unit id="e3a83e1ccdb64a4c6aff88c02b12dcc686b2bf3b" translate="yes" xml:space="preserve">
          <source>The suffix for the variable that keeps the gradient squared accumulator. If not present, defaults to name.</source>
          <target state="translated">勾配二乗アキュムレータを保持する変数のサフィックス。省略した場合、デフォルトはnameです。</target>
        </trans-unit>
        <trans-unit id="628f884b08eaa26944d28d228cad39f4b6e377f6" translate="yes" xml:space="preserve">
          <source>The suffix for the variable that keeps the linear gradient accumulator. If not present, defaults to name + &quot;&lt;em&gt;1&quot;. &lt;/em&gt;</source>
          <target state="translated">線形グラデーションアキュムレータを保持する変数の接尾辞。存在しない場合、デフォルトで名前+ &quot; &lt;em&gt;1&quot;になります。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0b87677b2e7091b18f84e0a5a53ce47bf2fbc17a" translate="yes" xml:space="preserve">
          <source>The sum of the squared distance from each point in the first batch of inputs to its nearest cluster center.</source>
          <target state="translated">入力の最初のバッチの各点から最も近いクラスタ中心までの距離の二乗和。</target>
        </trans-unit>
        <trans-unit id="b87e105d01203888c35de69e0d8cabac2d7238b3" translate="yes" xml:space="preserve">
          <source>The summary has up to &lt;code&gt;max_images&lt;/code&gt; summary values containing images. The images are built from &lt;code&gt;tensor&lt;/code&gt; which must be 4-D with shape &lt;code&gt;[batch_size, height, width, channels]&lt;/code&gt; and where &lt;code&gt;channels&lt;/code&gt; can be:</source>
          <target state="translated">サマリーには、画像を含む最大 &lt;code&gt;max_images&lt;/code&gt; サマリー値があります。画像は &lt;code&gt;tensor&lt;/code&gt; から作成されます。テンソルは形状 &lt;code&gt;[batch_size, height, width, channels]&lt;/code&gt; 4Dである必要があり、 &lt;code&gt;channels&lt;/code&gt; は次のようになります。</target>
        </trans-unit>
        <trans-unit id="f3f45fd11021d0fbbacbdd0bd0b9e463916250a5" translate="yes" xml:space="preserve">
          <source>The summary has up to &lt;code&gt;max_outputs&lt;/code&gt; summary values containing audio. The audio is built from &lt;code&gt;tensor&lt;/code&gt; which must be 3-D with shape &lt;code&gt;[batch_size, frames, channels]&lt;/code&gt; or 2-D with shape &lt;code&gt;[batch_size, frames]&lt;/code&gt;. The values are assumed to be in the range of &lt;code&gt;[-1.0, 1.0]&lt;/code&gt; with a sample rate of &lt;code&gt;sample_rate&lt;/code&gt;.</source>
          <target state="translated">サマリーには、オーディオを含む最大 &lt;code&gt;max_outputs&lt;/code&gt; サマリー値があります。オーディオは、形状 &lt;code&gt;[batch_size, frames, channels]&lt;/code&gt; 3Dまたは形状 &lt;code&gt;[batch_size, frames]&lt;/code&gt; 2Dでなければならない &lt;code&gt;tensor&lt;/code&gt; から構築されます。値は &lt;code&gt;[-1.0, 1.0]&lt;/code&gt; 範囲で、サンプルレートは &lt;code&gt;sample_rate&lt;/code&gt; であると想定されています。</target>
        </trans-unit>
        <trans-unit id="4c8749a05b6c387d61ef6d60497d42b829e20f04" translate="yes" xml:space="preserve">
          <source>The summary has up to &lt;code&gt;max_outputs&lt;/code&gt; summary values containing images. The images are built from &lt;code&gt;tensor&lt;/code&gt; which must be 4-D with shape &lt;code&gt;[batch_size, height, width, channels]&lt;/code&gt; and where &lt;code&gt;channels&lt;/code&gt; can be:</source>
          <target state="translated">サマリーには、画像を含む最大 &lt;code&gt;max_outputs&lt;/code&gt; サマリー値があります。画像は &lt;code&gt;tensor&lt;/code&gt; から作成されます。テンソルは形状 &lt;code&gt;[batch_size, height, width, channels]&lt;/code&gt; 4Dである必要があり、 &lt;code&gt;channels&lt;/code&gt; は次のようになります。</target>
        </trans-unit>
        <trans-unit id="45ad74c802e798c2d2739d6fd3d4c8a9a95f1067" translate="yes" xml:space="preserve">
          <source>The summary stats contains gradients and hessians accumulated for each node, bucket and dimension id.</source>
          <target state="translated">サマリー統計には、各ノード、バケット、およびディメンジョン ID について蓄積された勾配とヘシアンが含まれています。</target>
        </trans-unit>
        <trans-unit id="3b4c4f21208a76ec80b0674286557919ec4d96bb" translate="yes" xml:space="preserve">
          <source>The summary stats contains gradients and hessians accumulated for each node, feature dimension id and bucket.</source>
          <target state="translated">サマリー統計情報には、各ノード、特徴次元ID、バケットごとに蓄積された勾配とヘシアンが含まれています。</target>
        </trans-unit>
        <trans-unit id="cdad9771b45b958101ba790c70a250dceed1de82" translate="yes" xml:space="preserve">
          <source>The summary stats contains gradients and hessians accumulated into the corresponding node and bucket for each example.</source>
          <target state="translated">サマリー統計情報には、各例に対応するノードとバケットに蓄積された勾配とヘシアンが含まれています。</target>
        </trans-unit>
        <trans-unit id="fa003ab56e1eb5342f9795fdbfba586bfe2f1900" translate="yes" xml:space="preserve">
          <source>The supervisor is notified of any exception raised by one of the services. After an exception is raised, &lt;code&gt;should_stop()&lt;/code&gt; returns &lt;code&gt;True&lt;/code&gt;. In that case the training loop should also stop. This is why the training loop has to check for &lt;code&gt;sv.should_stop()&lt;/code&gt;.</source>
          <target state="translated">スーパーバイザには、サービスの1つによって発生した例外が通知されます。例外が発生した後、 &lt;code&gt;should_stop()&lt;/code&gt; は &lt;code&gt;True&lt;/code&gt; を返します。その場合、トレーニングループも停止する必要があります。これが、トレーニングループが &lt;code&gt;sv.should_stop()&lt;/code&gt; をチェックする必要がある理由です。</target>
        </trans-unit>
        <trans-unit id="50528fab5ce38e9d3b4fc6e5612ddf34e494bebf" translate="yes" xml:space="preserve">
          <source>The swish activation applied to &lt;code&gt;x&lt;/code&gt; (see reference paper for details).</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; に適用されるスウィッシュアクティベーション（詳細については、リファレンスペーパーを参照してください）。</target>
        </trans-unit>
        <trans-unit id="c298d20320b239b254c85a68c7638e9b3d6999d9" translate="yes" xml:space="preserve">
          <source>The table initializer to use. See &lt;code&gt;HashTable&lt;/code&gt; kernel for supported key and value types.</source>
          <target state="translated">使用するテーブル初期化子。サポートされているキーと値のタイプについては、 &lt;code&gt;HashTable&lt;/code&gt; カーネルを参照してください。</target>
        </trans-unit>
        <trans-unit id="b372ddff28f44f63c6e232f1c30d44e36e67c586" translate="yes" xml:space="preserve">
          <source>The table key dtype.</source>
          <target state="translated">テーブルキーのdtypeです。</target>
        </trans-unit>
        <trans-unit id="92555821a111ce6704d66c3accb512005dcb54c2" translate="yes" xml:space="preserve">
          <source>The table to be initialized.</source>
          <target state="translated">初期化するテーブル。</target>
        </trans-unit>
        <trans-unit id="284ce4f13ba5d1db3bbec94a52d693d3d2283853" translate="yes" xml:space="preserve">
          <source>The table to initialize.</source>
          <target state="translated">初期化するテーブル。</target>
        </trans-unit>
        <trans-unit id="45ea7c0740084e6be8859e3f6c6a5a25999322a4" translate="yes" xml:space="preserve">
          <source>The table value dtype.</source>
          <target state="translated">テーブル値のdtypeです。</target>
        </trans-unit>
        <trans-unit id="8e9701fdc91c90f3e0a50b0354216b715e7e2b61" translate="yes" xml:space="preserve">
          <source>The tag name for this metadata.</source>
          <target state="translated">このメタデータのタグ名。</target>
        </trans-unit>
        <trans-unit id="2e6370789b18c4cef6f8f91690bde182484827c1" translate="yes" xml:space="preserve">
          <source>The target value of comparison.</source>
          <target state="translated">比較対象の目標値。</target>
        </trans-unit>
        <trans-unit id="f6bc45ea60aa5301cecc35d1fbbe5b21036c5bda" translate="yes" xml:space="preserve">
          <source>The task index for this particular VM, within the GCE instance group. In particular, every single instance should be assigned a unique ordinal index within an instance group manually so that they can be distinguished from each other.</source>
          <target state="translated">GCE インスタンス グループ内のこの特定の VM のタスク インデックス。特に、すべての単一のインスタンスには、インスタンスグループ内で一意の順序インデックスを手動で割り当てて、互いに区別できるようにする必要があります。</target>
        </trans-unit>
        <trans-unit id="39fc3d1afa951ce1fc0c6acdffe30bf9d05aaa6f" translate="yes" xml:space="preserve">
          <source>The task of an Enqueuer is to use parallelism to speed up preprocessing. This is done with processes or threads.</source>
          <target state="translated">エンキュイアのタスクは、並列性を利用して前処理を高速化することです。これはプロセスやスレッドを使って行われます。</target>
        </trans-unit>
        <trans-unit id="8d203e324545cf312d1311ac6ed39dbe8533902e" translate="yes" xml:space="preserve">
          <source>The temporary directory.</source>
          <target state="translated">テンポラリディレクトリ。</target>
        </trans-unit>
        <trans-unit id="89760396be504814d1d16fffe685b4c4ed9d185b" translate="yes" xml:space="preserve">
          <source>The tensor &lt;code&gt;keys&lt;/code&gt; must be of the same type as the keys of the table. The tensor &lt;code&gt;values&lt;/code&gt; must be of the type of the table values.</source>
          <target state="translated">テンソル &lt;code&gt;keys&lt;/code&gt; は、テーブルのキーと同じタイプである必要があります。テンソル &lt;code&gt;values&lt;/code&gt; は、テーブル値のタイプである必要があります。</target>
        </trans-unit>
        <trans-unit id="ba629a56d84ff4136c8aeadbf5a5b5c5e14b4183" translate="yes" xml:space="preserve">
          <source>The tensor &lt;code&gt;keys&lt;/code&gt; must of the same type as the keys of the table. Keys not already in the table are silently ignored.</source>
          <target state="translated">テンソル &lt;code&gt;keys&lt;/code&gt; は、テーブルのキーと同じタイプである必要があります。テーブルにまだ存在しないキーは、黙って無視されます。</target>
        </trans-unit>
        <trans-unit id="784e799f8d450863febee3c764bd275192b18bd8" translate="yes" xml:space="preserve">
          <source>The tensor &lt;code&gt;keys&lt;/code&gt; must of the same type as the keys of the table. The output &lt;code&gt;values&lt;/code&gt; is of the type of the table values.</source>
          <target state="translated">テンソル &lt;code&gt;keys&lt;/code&gt; は、テーブルのキーと同じタイプである必要があります。出力 &lt;code&gt;values&lt;/code&gt; は、テーブル値のタイプです。</target>
        </trans-unit>
        <trans-unit id="ba8d97a1a9f6a392dad767f9f5f935fc3b942c5f" translate="yes" xml:space="preserve">
          <source>The tensor at index &lt;code&gt;index&lt;/code&gt;.</source>
          <target state="translated">インデックス &lt;code&gt;index&lt;/code&gt; のテンソル。</target>
        </trans-unit>
        <trans-unit id="2316496cec696b46dadd19db7c5fa7648eaa2e07" translate="yes" xml:space="preserve">
          <source>The tensor for the keys.</source>
          <target state="translated">キーのテンソルです。</target>
        </trans-unit>
        <trans-unit id="0acc2ca709af133edb5533c7cf72d36eab353cfc" translate="yes" xml:space="preserve">
          <source>The tensor for the values.</source>
          <target state="translated">値のテンソルです。</target>
        </trans-unit>
        <trans-unit id="1b8bac0316b66126d9a5f3d03ead635dc9c4e503" translate="yes" xml:space="preserve">
          <source>The tensor is shuffled along dimension 0, such that each &lt;code&gt;value[j]&lt;/code&gt; is mapped to one and only one &lt;code&gt;output[i]&lt;/code&gt;. For example, a mapping that might occur for a 3x2 tensor is:</source>
          <target state="translated">テンソルは次元0に沿ってシャッフルされ、各 &lt;code&gt;value[j]&lt;/code&gt; は1つだけの &lt;code&gt;output[i]&lt;/code&gt; マッピングされます。たとえば、3x2テンソルで発生する可能性があるマッピングは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="b2ebac51ffaed872fc6c58ab59a37320ff00d8b4" translate="yes" xml:space="preserve">
          <source>The tensor over which to pool. Must have rank 3.</source>
          <target state="translated">プールするテンソル。ランク3でなければなりません。</target>
        </trans-unit>
        <trans-unit id="67d66a49c4d56f6740c34ad1abd2330c2a53d237" translate="yes" xml:space="preserve">
          <source>The tensor over which to pool. Must have rank 4.</source>
          <target state="translated">プールするテンソル。ランク4でなければなりません。</target>
        </trans-unit>
        <trans-unit id="8d6751ac1718f3abff2c47f31b4ce194ddbe60a5" translate="yes" xml:space="preserve">
          <source>The tensor over which to pool. Must have rank 5.</source>
          <target state="translated">プールするテンソル。ランク5でなければなりません。</target>
        </trans-unit>
        <trans-unit id="6ba96488585c7e70161cf56eacc0bc675e7c2bf5" translate="yes" xml:space="preserve">
          <source>The tensor returned by this operation is immutable.</source>
          <target state="translated">この操作で返されるテンソルは不変です。</target>
        </trans-unit>
        <trans-unit id="374a08aed4e22028f8c4f1a7a5332f381742c546" translate="yes" xml:space="preserve">
          <source>The tensor to reduce. Should be of numeric type, &lt;code&gt;bool&lt;/code&gt;, or &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">減らすテンソル。数値型、 &lt;code&gt;bool&lt;/code&gt; 、または &lt;code&gt;string&lt;/code&gt; 必要があります。</target>
        </trans-unit>
        <trans-unit id="af6cdbb07f5f2007c7664b9fc800d495933f2079" translate="yes" xml:space="preserve">
          <source>The tensor to reduce. Should have numeric type.</source>
          <target state="translated">縮小するテンソル。数値型でなければなりません。</target>
        </trans-unit>
        <trans-unit id="f76ee355f90903f0cc3c888c4e5cbb97172bd55d" translate="yes" xml:space="preserve">
          <source>The tensor to reduce. Should have real numeric type.</source>
          <target state="translated">縮小するテンソル。実数型でなければなりません。</target>
        </trans-unit>
        <trans-unit id="c8f9620fdd17bd0ae7e2e11319433d1d510e064f" translate="yes" xml:space="preserve">
          <source>The tensor to reduce. Should have real or complex type.</source>
          <target state="translated">縮小するテンソル。実数型または複素数型でなければなりません。</target>
        </trans-unit>
        <trans-unit id="60a48c532dffc217f038e38531b427ddb3f91bda" translate="yes" xml:space="preserve">
          <source>The tensor to start from.</source>
          <target state="translated">テンソルからスタートします。</target>
        </trans-unit>
        <trans-unit id="bc7b892140fc1cca57f3b6847beb68b7faa703c7" translate="yes" xml:space="preserve">
          <source>The tensor type for the result: one of &lt;code&gt;&quot;RaggedTensor&quot;&lt;/code&gt; or &lt;code&gt;&quot;SparseTensor&quot;&lt;/code&gt;.</source>
          <target state="translated">結果のテンソルタイプ： &lt;code&gt;&quot;RaggedTensor&quot;&lt;/code&gt; または &lt;code&gt;&quot;SparseTensor&quot;&lt;/code&gt; いずれか。</target>
        </trans-unit>
        <trans-unit id="f1c73ec4612fec81093c6dca3603df5977d11e17" translate="yes" xml:space="preserve">
          <source>The tensor_shape to resize the input to.</source>
          <target state="translated">入力のサイズを変更するtensor_shape。</target>
        </trans-unit>
        <trans-unit id="79aa982763ef4786022042e868a3556033a0c5ec" translate="yes" xml:space="preserve">
          <source>The tensors at corresponding positions in the three input lists (sample_indices, embedding_indices and aggregation_weights) must have the same shape, i.e. rank 1 with dim_size() equal to the total number of lookups into the table described by the corresponding feature.</source>
          <target state="translated">3つの入力リスト(sample_indices,embedding_indices,aggregation_weights)の対応する位置にあるテンソルは,同じ形状,すなわち,対応する特徴によって記述されたテーブルへのルックアップの総数に等しいdim_size()を持つランク1でなければなりません.</target>
        </trans-unit>
        <trans-unit id="9f41fba569c688c2ad85251ea878f2cfba46898a" translate="yes" xml:space="preserve">
          <source>The tensors at corresponding positions in the three input lists must have the same shape, i.e. rank 1 with dim_size() equal to the total number of lookups into the table described by the corresponding table_id.</source>
          <target state="translated">3 つの入力リストの対応する位置にあるテンソルは、同じ形をしていなければなりません。つまり、対応する table_id で記述されたテーブルへのルックアップの合計数に等しい dim_size()を持つ rank 1 でなければなりません。</target>
        </trans-unit>
        <trans-unit id="a5925b962b25493edc9ea9353afe8ff0989d3ebc" translate="yes" xml:space="preserve">
          <source>The tensors at corresponding positions in two of the input lists, embedding_indices and aggregation_weights, must have the same shape, i.e. rank 1 with dim_size() equal to the total number of lookups into the table described by the corresponding feature.</source>
          <target state="translated">embedding_indices と aggregation_weights の 2 つの入力リストの対応する位置にあるテンソルは,同じ形状,すなわち,対応する特徴によって記述されたテーブルへのルックアップの総数に等しい dim_size()を持つ rank 1 でなければなりません.</target>
        </trans-unit>
        <trans-unit id="263280cf1684ff5fb9dc90aff492167c49c357e8" translate="yes" xml:space="preserve">
          <source>The tensors in the &lt;code&gt;TensorArray&lt;/code&gt; selected by &lt;code&gt;indices&lt;/code&gt;, packed into one tensor.</source>
          <target state="translated">1つのテンソルにパックされた、 &lt;code&gt;indices&lt;/code&gt; によって選択された &lt;code&gt;TensorArray&lt;/code&gt; のテンソル。</target>
        </trans-unit>
        <trans-unit id="14d5f93ad26c02d132da873b0983deda8cc5ede0" translate="yes" xml:space="preserve">
          <source>The tensors returned by the callable identified by &lt;code&gt;branch_index&lt;/code&gt;, or those returned by &lt;code&gt;default&lt;/code&gt; if no key matches and &lt;code&gt;default&lt;/code&gt; was provided, or those returned by the max-keyed &lt;code&gt;branch_fn&lt;/code&gt; if no &lt;code&gt;default&lt;/code&gt; is provided.</source>
          <target state="translated">&lt;code&gt;branch_index&lt;/code&gt; によって識別される呼び出し可能オブジェクトによって返されるテンソル、または一致するキーがなく &lt;code&gt;default&lt;/code&gt; 場合はデフォルトで返されるテンソル、または &lt;code&gt;default&lt;/code&gt; が指定されていない &lt;code&gt;default&lt;/code&gt; はmax-keyed &lt;code&gt;branch_fn&lt;/code&gt; によって返されるテンソル。</target>
        </trans-unit>
        <trans-unit id="0ea9d9d23c406f164fd2c56245bf91a63b2aa423" translate="yes" xml:space="preserve">
          <source>The tensors returned by the first pair whose predicate evaluated to True, or those returned by &lt;code&gt;default&lt;/code&gt; if none does.</source>
          <target state="translated">述語がTrueと評価された最初のペアによって返されるテンソル、または何も評価しない場合に &lt;code&gt;default&lt;/code&gt; 返されるテンソル。</target>
        </trans-unit>
        <trans-unit id="62c909c71b66d6f5bfc11fa3e5279c6761971045" translate="yes" xml:space="preserve">
          <source>The tensors returned from &lt;code&gt;fn()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;fn()&lt;/code&gt; から返されたテンソル。</target>
        </trans-unit>
        <trans-unit id="3ac69b5b20154b08a328b1d97feb7527a2ebab36" translate="yes" xml:space="preserve">
          <source>The tensors to print out if the condition is False. Defaults to error message and first few entries of &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">条件がFalseの場合に出力するテンソル。デフォルトはエラーメッセージと &lt;code&gt;x&lt;/code&gt; 、 &lt;code&gt;y&lt;/code&gt; の最初のいくつかのエントリです。</target>
        </trans-unit>
        <trans-unit id="de476c8a1f81cdd546d80c349f6129aaf3737e55" translate="yes" xml:space="preserve">
          <source>The tensors to print out if the condition is False. Defaults to error message and first few entries of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">条件がFalseの場合に出力するテンソル。デフォルトはエラーメッセージと &lt;code&gt;x&lt;/code&gt; の最初のいくつかのエントリです。</target>
        </trans-unit>
        <trans-unit id="d755f0b97c63b7eff4b6dbe33de5d6acf734d32c" translate="yes" xml:space="preserve">
          <source>The tensors to print out if the condition is False. Defaults to error message and first few entries of the violating tensor.</source>
          <target state="translated">条件がFalseの場合に出力するテンソル。デフォルトはエラーメッセージと違反テンソルの最初の数エントリです。</target>
        </trans-unit>
        <trans-unit id="41e71fc634a3e1532ea4fdaf908aef7f0776c5d2" translate="yes" xml:space="preserve">
          <source>The tensors to print out if the condition is False. Defaults to error message and the shape of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">条件がFalseの場合に出力するテンソル。デフォルトはエラーメッセージと &lt;code&gt;x&lt;/code&gt; の形状です。</target>
        </trans-unit>
        <trans-unit id="a3c87ea478ca9312b37363d8086e97ef6cac7d50" translate="yes" xml:space="preserve">
          <source>The tensors to print out when condition is false.</source>
          <target state="translated">条件が偽の場合に出力するテンソル。</target>
        </trans-unit>
        <trans-unit id="2f38446647c9bdb5f6c17c4098bf60d7f38504af" translate="yes" xml:space="preserve">
          <source>The tensors will be printed to the log, with &lt;code&gt;INFO&lt;/code&gt; severity. If you are not seeing the logs, you might want to add the following line after your imports:</source>
          <target state="translated">テンソルは、 &lt;code&gt;INFO&lt;/code&gt; の重大度とともにログに出力されます。ログが表示されない場合は、インポート後に次の行を追加することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="6922a3a9fd52a35b3e308cba8bec364b7d504e80" translate="yes" xml:space="preserve">
          <source>The tf.Graph in which tensors are looked up. If None, the current default graph is used.</source>
          <target state="translated">テンソルが検索される tf.Graph。Noneの場合は、現在のデフォルトのグラフが使用されます。</target>
        </trans-unit>
        <trans-unit id="11bfdd9c3d39d4a32c1a375c3ce8bfd375bd0b18" translate="yes" xml:space="preserve">
          <source>The tf.tpu.Topology object for the topology of the TPU cluster.</source>
          <target state="translated">TPUクラスタのトポロジ用のtf.tpu.Topologyオブジェクト。</target>
        </trans-unit>
        <trans-unit id="befdc8701902b7376e60ef81bed3d724c3bb2879" translate="yes" xml:space="preserve">
          <source>The the elements of the output vector are in range (0, 1) and sum to 1.</source>
          <target state="translated">出力ベクトルの要素は範囲(0,1)であり、和は1になります。</target>
        </trans-unit>
        <trans-unit id="e8a1b74b382d4bec7d008b052874fc8efea06387" translate="yes" xml:space="preserve">
          <source>The threading options associated with the dataset. See &lt;a href=&quot;experimental/threadingoptions&quot;&gt;&lt;code&gt;tf.data.experimental.ThreadingOptions&lt;/code&gt;&lt;/a&gt; for more details.</source>
          <target state="translated">データセットに関連付けられているスレッドオプション。詳細については、&lt;a href=&quot;experimental/threadingoptions&quot;&gt; &lt;code&gt;tf.data.experimental.ThreadingOptions&lt;/code&gt; &lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="ed8f460f2dbd5613ea876b9d93397d3969bdc742" translate="yes" xml:space="preserve">
          <source>The thresholds used for evaluating AUC.</source>
          <target state="translated">AUCの評価に使用する閾値。</target>
        </trans-unit>
        <trans-unit id="4d718a76c8894d5837a42ef966440d43045adca5" translate="yes" xml:space="preserve">
          <source>The token representing an out-of-vocabulary value. Defaults to &quot;[UNK]&quot;.</source>
          <target state="translated">語彙外の値を表すトークン。デフォルトは&quot;[UNK]&quot;です。</target>
        </trans-unit>
        <trans-unit id="d3e4fd90c9e18807d72bafd4f4716080dd6bc34f" translate="yes" xml:space="preserve">
          <source>The total number of dimensions in a &lt;code&gt;RaggedTensor&lt;/code&gt; is called its &lt;em&gt;rank&lt;/em&gt;, and the number of ragged dimensions in a &lt;code&gt;RaggedTensor&lt;/code&gt; is called its &lt;em&gt;ragged-rank&lt;/em&gt;. A &lt;code&gt;RaggedTensor&lt;/code&gt;'s ragged-rank is fixed at graph creation time: it can't depend on the runtime values of &lt;code&gt;Tensor&lt;/code&gt;s, and can't vary dynamically for different session runs.</source>
          <target state="translated">次元の総数 &lt;code&gt;RaggedTensor&lt;/code&gt; は、その呼ばれ&lt;em&gt;、ランク&lt;/em&gt;、及びで不揃いの次元の数 &lt;code&gt;RaggedTensor&lt;/code&gt; は、その呼ばれる&lt;em&gt;不規則なランク&lt;/em&gt;。A &lt;code&gt;RaggedTensor&lt;/code&gt; のぼろランクは、グラフの作成時に固定されている：それはの実行時の値に依存することはできません &lt;code&gt;Tensor&lt;/code&gt; S、および別のセッションの実行のために動的に変化することはできません。</target>
        </trans-unit>
        <trans-unit id="7366f216b0f07a06f98c4cfb72b6efd8edad2b69" translate="yes" xml:space="preserve">
          <source>The total variation is the sum of the absolute differences for neighboring pixel-values in the input images. This measures how much noise is in the images.</source>
          <target state="translated">変動の合計は、入力画像の隣接する画素値の差の絶対値の合計である。これは、画像にどれだけのノイズがあるかを測定します。</target>
        </trans-unit>
        <trans-unit id="4cd5555b6721cf29a977af9cf8bb6114222ca75d" translate="yes" xml:space="preserve">
          <source>The total variation of &lt;code&gt;images&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;images&lt;/code&gt; の総バリエーション。</target>
        </trans-unit>
        <trans-unit id="b1be006e04763947d6204304381da8047ab403c6" translate="yes" xml:space="preserve">
          <source>The trace of input tensor.</source>
          <target state="translated">入力テンソルのトレース。</target>
        </trans-unit>
        <trans-unit id="e883a1ea41a9a9c563ecd15d66e0cea02e0fd475" translate="yes" xml:space="preserve">
          <source>The transformation calls &lt;code&gt;reduce_func&lt;/code&gt; successively on every element of the input dataset until the dataset is exhausted, aggregating information in its internal state. The &lt;code&gt;initial_state&lt;/code&gt; argument is used for the initial state and the final state is returned as the result.</source>
          <target state="translated">変換では、データセットがすべて使用されるまで、入力データセットのすべての要素に対して &lt;code&gt;reduce_func&lt;/code&gt; を連続的に呼び出し、内部状態の情報を集計します。 &lt;code&gt;initial_state&lt;/code&gt; 引数は、初期状態のために使用され、最終的な状態が結果として返されます。</target>
        </trans-unit>
        <trans-unit id="a76374d8db32ee668d78ea0cbd0b4fb2bd9d2baf" translate="yes" xml:space="preserve">
          <source>The transpose of &lt;code&gt;atrous_conv2d&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;atrous_conv2d&lt;/code&gt; の転置。</target>
        </trans-unit>
        <trans-unit id="24fae844f58c6b39229d2519fcdd2125a204111b" translate="yes" xml:space="preserve">
          <source>The transpose of &lt;code&gt;conv1d&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;conv1d&lt;/code&gt; の転置。</target>
        </trans-unit>
        <trans-unit id="e5584a45278a21e44f011bf21c57aa5501a09482" translate="yes" xml:space="preserve">
          <source>The transpose of &lt;code&gt;conv2d&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;conv2d&lt;/code&gt; の転置。</target>
        </trans-unit>
        <trans-unit id="88458abd7b78099fd74249ee9fe81104261b47e7" translate="yes" xml:space="preserve">
          <source>The transpose of &lt;code&gt;conv3d&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;conv3d&lt;/code&gt; の転置。</target>
        </trans-unit>
        <trans-unit id="4974672a5f0bdf2f1f4a3ac2ea5cc95568047305" translate="yes" xml:space="preserve">
          <source>The transpose of &lt;code&gt;convolution&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;convolution&lt;/code&gt; の転置。</target>
        </trans-unit>
        <trans-unit id="1519a20ef4fe586180643d48497a05b2e0fad92f" translate="yes" xml:space="preserve">
          <source>The tuple of concatenated tensors that was dequeued.</source>
          <target state="translated">デキューされた連結テンソルのタプル。</target>
        </trans-unit>
        <trans-unit id="947a12be95ae913828fb29965c58acb416f681d0" translate="yes" xml:space="preserve">
          <source>The tuple of tensors that was dequeued.</source>
          <target state="translated">デキューされたテンソルのタプル。</target>
        </trans-unit>
        <trans-unit id="3ac8da8c53a0fe7729ca96dc99672e3deaee4160" translate="yes" xml:space="preserve">
          <source>The tutorials cover how to use &lt;a href=&quot;../../distribute/strategy&quot;&gt;&lt;code&gt;tf.distribute.Strategy&lt;/code&gt;&lt;/a&gt; to do distributed training with native Keras APIs, custom training loops, and Esitmator APIs. They also cover how to save/load model when using &lt;a href=&quot;../../distribute/strategy&quot;&gt;&lt;code&gt;tf.distribute.Strategy&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">チュートリアルでは、&lt;a href=&quot;../../distribute/strategy&quot;&gt; &lt;code&gt;tf.distribute.Strategy&lt;/code&gt; &lt;/a&gt;を使用して、ネイティブのKeras API、カスタムトレーニングループ、およびEsitmatorAPIを使用して分散トレーニングを行う方法について説明します。また、&lt;a href=&quot;../../distribute/strategy&quot;&gt; &lt;code&gt;tf.distribute.Strategy&lt;/code&gt; &lt;/a&gt;を使用するときにモデルを保存/ロードする方法についても説明します。</target>
        </trans-unit>
        <trans-unit id="81263e37d187db94dad3d1abafbff5fd315364f1" translate="yes" xml:space="preserve">
          <source>The tutorials cover how to use &lt;a href=&quot;distribute/strategy&quot;&gt;&lt;code&gt;tf.distribute.Strategy&lt;/code&gt;&lt;/a&gt; to do distributed training with native Keras APIs, custom training loops, and Esitmator APIs. They also cover how to save/load model when using &lt;a href=&quot;distribute/strategy&quot;&gt;&lt;code&gt;tf.distribute.Strategy&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">チュートリアルでは、&lt;a href=&quot;distribute/strategy&quot;&gt; &lt;code&gt;tf.distribute.Strategy&lt;/code&gt; &lt;/a&gt;を使用して、ネイティブのKeras API、カスタムトレーニングループ、およびEsitmatorAPIを使用して分散トレーニングを行う方法について説明します。また、&lt;a href=&quot;distribute/strategy&quot;&gt; &lt;code&gt;tf.distribute.Strategy&lt;/code&gt; &lt;/a&gt;を使用するときにモデルを保存/ロードする方法についても説明します。</target>
        </trans-unit>
        <trans-unit id="fcce8e7308a1f27fd06f367ce630638c93d290a0" translate="yes" xml:space="preserve">
          <source>The two arguments should be data trees consisting of trees of dicts and lists. They will be deeply compared by walking into the contents of dicts and lists; other items will be compared using the == operator. If the two structures differ in content, the failure message will indicate the location within the structures where the first difference is found. This may be helpful when comparing large structures.</source>
          <target state="translated">2つの引数は、ディクトとリストの木からなるデータツリーでなければなりません。これらは、ディクトとリストの内容の中に入っていくことで深く比較され、他の項目は==演算子を使って比較されます。2つの構造体の内容が異なる場合、失敗メッセージは構造体の中で最初の違いが見つかった場所を示します。これは,大きな構造体を比較するときに役立つかもしれません.</target>
        </trans-unit>
        <trans-unit id="c63ea59f28eeb3c5ef7f12904295f5acd2abba7d" translate="yes" xml:space="preserve">
          <source>The two optional lists, &lt;code&gt;shapes&lt;/code&gt; and &lt;code&gt;names&lt;/code&gt;, must be of the same length as &lt;code&gt;dtypes&lt;/code&gt; if provided. The values at a given index &lt;code&gt;i&lt;/code&gt; indicate the shape and name to use for the corresponding queue component in &lt;code&gt;dtypes&lt;/code&gt;.</source>
          <target state="translated">2つのオプションリスト、 &lt;code&gt;shapes&lt;/code&gt; 及び &lt;code&gt;names&lt;/code&gt; 、同じ長さのものでなければならない &lt;code&gt;dtypes&lt;/code&gt; 設けられている場合。特定のインデックス &lt;code&gt;i&lt;/code&gt; の値は、 &lt;code&gt;dtypes&lt;/code&gt; の対応するキューコンポーネントに使用する形状と名前を示します。</target>
        </trans-unit>
        <trans-unit id="2509253fc683a9173057f5630f71d4971cacd9bd" translate="yes" xml:space="preserve">
          <source>The type of &lt;code&gt;values&lt;/code&gt; elements in the tensor to be fed.</source>
          <target state="translated">供給されるテンソルの &lt;code&gt;values&lt;/code&gt; 要素のタイプ。</target>
        </trans-unit>
        <trans-unit id="7c1114eda45ad0aa9835c881c7ed41948119a5f6" translate="yes" xml:space="preserve">
          <source>The type of alpha, beta, and the output: &lt;code&gt;float16&lt;/code&gt;, &lt;code&gt;float32&lt;/code&gt;, or &lt;code&gt;float64&lt;/code&gt;.</source>
          <target state="translated">アルファ、ベータのタイプ、および出力： &lt;code&gt;float16&lt;/code&gt; 、 &lt;code&gt;float32&lt;/code&gt; 、または &lt;code&gt;float64&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fcb9c58891241a3653f7ed23f1f4e9ce6c454d7f" translate="yes" xml:space="preserve">
          <source>The type of an element in the resulting &lt;code&gt;Tensor&lt;/code&gt;</source>
          <target state="translated">結果の &lt;code&gt;Tensor&lt;/code&gt; 要素のタイプ</target>
        </trans-unit>
        <trans-unit id="8cccbb2c85e31880b8682b2d0adfb113b78b64da" translate="yes" xml:space="preserve">
          <source>The type of compression for the record.</source>
          <target state="translated">レコードの圧縮の種類。</target>
        </trans-unit>
        <trans-unit id="1b4dd7863bb3d0a86631168ad97e3c5ad4e8e603" translate="yes" xml:space="preserve">
          <source>The type of element in the resulting &lt;code&gt;Tensor&lt;/code&gt;.</source>
          <target state="translated">結果の &lt;code&gt;Tensor&lt;/code&gt; の要素のタイプ。</target>
        </trans-unit>
        <trans-unit id="94422215aeace7edcb47320386970071b5179d19" translate="yes" xml:space="preserve">
          <source>The type of elements for the returned &lt;code&gt;RaggedTensor&lt;/code&gt;. If not specified, then a default is chosen based on the scalar values in &lt;code&gt;pylist&lt;/code&gt;.</source>
          <target state="translated">返される &lt;code&gt;RaggedTensor&lt;/code&gt; の要素のタイプ。指定しない場合、 &lt;code&gt;pylist&lt;/code&gt; のスカラー値に基づいてデフォルトが選択されます。</target>
        </trans-unit>
        <trans-unit id="7a013615eda1f8f0ede1ff237cff4a624ad2cf8a" translate="yes" xml:space="preserve">
          <source>The type of elements in the tensor to be fed.</source>
          <target state="translated">テンソルに含まれる要素の種類を入力します。</target>
        </trans-unit>
        <trans-unit id="ffc1d3e87a785b70bd5fa0c191f6b8f9a2dab411" translate="yes" xml:space="preserve">
          <source>The type of encoding for the file. Defaults to none.</source>
          <target state="translated">ファイルのエンコーディングの種類。デフォルトはnoneです。</target>
        </trans-unit>
        <trans-unit id="f00002f765021b74ae3866db29b33e5675d9c97a" translate="yes" xml:space="preserve">
          <source>The type of features. Only string and integer types are supported.</source>
          <target state="translated">機能の型です。文字列型と整数型のみサポートされています。</target>
        </trans-unit>
        <trans-unit id="405fc0a59f40a1f68ad3da9d2cbead3200ca93bb" translate="yes" xml:space="preserve">
          <source>The type of features. Only string and integer types are supported. If &lt;code&gt;None&lt;/code&gt;, it will be inferred from &lt;code&gt;vocabulary_list&lt;/code&gt;.</source>
          <target state="translated">機能のタイプ。文字列型と整数型のみがサポートされています。 &lt;code&gt;None&lt;/code&gt; の場合、 &lt;code&gt;vocabulary_list&lt;/code&gt; から推測されます。</target>
        </trans-unit>
        <trans-unit id="0e39ef94a4f11a83b4f0f2df2ede7e0ef31ede65" translate="yes" xml:space="preserve">
          <source>The type of loss reduction used in the head.</source>
          <target state="translated">頭部に使用するロスカットの種類です。</target>
        </trans-unit>
        <trans-unit id="9e1c8635c975f4590fc90901ef34444f7e5713cc" translate="yes" xml:space="preserve">
          <source>The type of sharding that auto-shard should attempt. If this is set to FILE, then we will attempt to shard by files (each worker will get a set of files to process). If we cannot find a set of files to shard for at least one file per worker, we will error out. When this option is selected, make sure that you have enough files so that each worker gets at least one file. There will be a runtime error thrown if there are insufficient files. If this is set to DATA, then we will shard by elements produced by the dataset, and each worker will process the whole dataset and discard the portion that is not for itself. If this is set to OFF, then we will not autoshard, and each worker will receive a copy of the full dataset. This option is set to AUTO by default, AUTO will attempt to first shard by FILE, and fall back to sharding by DATA if we cannot find a set of files to shard.</source>
          <target state="translated">自動シャードを試みるシャーディングのタイプ。これが FILE に設定されている場合、ファイル単位でシャーディングを試みます (各ワーカーは処理するファイルのセットを取得します)。ワーカーごとに少なくとも 1 つのファイルをシャーディングするファイルセットが見つからない場合は、エラーとなります。このオプションが選択されている場合、各ワーカーが少なくとも1つのファイルを取得するように十分なファイルがあることを確認してください。不足したファイルがあるとランタイムエラーがスローされます。これがDATAに設定されている場合、データセットから生成された要素でシャードし、各ワーカーはデータセット全体を処理し、自分のためではない部分は破棄します。これがOFFに設定されている場合、自動シャードは行われず、各ワーカーはデータセット全体のコピーを受け取ることになります。このオプションはデフォルトでAUTOに設定されており、AUTOは最初にFILEでシャーディングを試み、シャーディングするファイルのセットが見つからない場合はDATAでシャーディングするようにフォールバックします。</target>
        </trans-unit>
        <trans-unit id="1076c8ce1d97d2aae1dd52bec1be1eb1d7da0726" translate="yes" xml:space="preserve">
          <source>The type of the elements of the resulting tensor.</source>
          <target state="translated">結果のテンソルの要素の型。</target>
        </trans-unit>
        <trans-unit id="4e8bb7b7574042b37e7c6afeec47ae6a75f4b513" translate="yes" xml:space="preserve">
          <source>The type of the elements of the resulting tensor. If not specified, then a value is chosen based on the other args.</source>
          <target state="translated">結果として得られるテンソルの要素の型。指定されていない場合は、他の引数に基づいて値が選択されます。</target>
        </trans-unit>
        <trans-unit id="aed6e689e6786fb190bf4135aa5cf05a31f4f0b3" translate="yes" xml:space="preserve">
          <source>The type of the event samples (default: int32).</source>
          <target state="translated">イベントサンプルの種類(デフォルト:int32)。</target>
        </trans-unit>
        <trans-unit id="5a0617255d963a3d9373238c1968c00abc24574b" translate="yes" xml:space="preserve">
          <source>The type of the event samples. &lt;code&gt;None&lt;/code&gt; implies no type-enforcement.</source>
          <target state="translated">イベントサンプルのタイプ。 &lt;code&gt;None&lt;/code&gt; は、タイプエンフォースメントがないことを意味します。</target>
        </trans-unit>
        <trans-unit id="0e6ae3861b6b33f7202d6cb04f51d8a43f2ebb83" translate="yes" xml:space="preserve">
          <source>The type of the event samples. Default: &lt;code&gt;int32&lt;/code&gt;.</source>
          <target state="translated">イベントサンプルのタイプ。デフォルト： &lt;code&gt;int32&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e5ac8c9ef31246fab5b3b784f6fdb5ffec2b2eba" translate="yes" xml:space="preserve">
          <source>The type of the op (e.g. &lt;code&gt;&quot;MatMul&quot;&lt;/code&gt;).</source>
          <target state="translated">opのタイプ（例： &lt;code&gt;&quot;MatMul&quot;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="067097eae217bc20b817dae41bcd6adaa941c2bf" translate="yes" xml:space="preserve">
          <source>The type of the op that generated the tensor with bad numerics.</source>
          <target state="translated">悪い数値のテンソルを生成したopの種類。</target>
        </trans-unit>
        <trans-unit id="08a9b8c589712a808dd41511f2b9583296c78486" translate="yes" xml:space="preserve">
          <source>The type of the output tensor.</source>
          <target state="translated">出力テンソルの種類。</target>
        </trans-unit>
        <trans-unit id="6ac7350774189c9f4f0f6d153487ae1c0df2dfef" translate="yes" xml:space="preserve">
          <source>The type of the output.</source>
          <target state="translated">出力の種類です。</target>
        </trans-unit>
        <trans-unit id="da83b3257815d9c8a52c8c2fe774ab08e0d4a548" translate="yes" xml:space="preserve">
          <source>The type of the output. Default: tf.int32</source>
          <target state="translated">出力の型。デフォルト:tf.int32</target>
        </trans-unit>
        <trans-unit id="aa045fdeece95a6373419965f4b455817b39af60" translate="yes" xml:space="preserve">
          <source>The type of the output: &lt;code&gt;float16&lt;/code&gt;, &lt;code&gt;float32&lt;/code&gt;, &lt;code&gt;float64&lt;/code&gt;, &lt;code&gt;int32&lt;/code&gt; or &lt;code&gt;int64&lt;/code&gt;.</source>
          <target state="translated">出力のタイプ： &lt;code&gt;float16&lt;/code&gt; 、 &lt;code&gt;float32&lt;/code&gt; 、 &lt;code&gt;float64&lt;/code&gt; 、 &lt;code&gt;int32&lt;/code&gt; または &lt;code&gt;int64&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f27b43df09bda0cc0e4bd074ae7a03dba23972ee" translate="yes" xml:space="preserve">
          <source>The type of the output: &lt;code&gt;float16&lt;/code&gt;, &lt;code&gt;float32&lt;/code&gt;, &lt;code&gt;float64&lt;/code&gt;, &lt;code&gt;int32&lt;/code&gt;, or &lt;code&gt;int64&lt;/code&gt;.</source>
          <target state="translated">出力のタイプ： &lt;code&gt;float16&lt;/code&gt; 、 &lt;code&gt;float32&lt;/code&gt; 、 &lt;code&gt;float64&lt;/code&gt; 、 &lt;code&gt;int32&lt;/code&gt; 、または &lt;code&gt;int64&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f8cc4d05affc30251cb4e72ec85d99c502c39e2b" translate="yes" xml:space="preserve">
          <source>The type of the output: &lt;code&gt;float16&lt;/code&gt;, &lt;code&gt;float32&lt;/code&gt;, &lt;code&gt;float64&lt;/code&gt;, &lt;code&gt;int32&lt;/code&gt;, or &lt;code&gt;int64&lt;/code&gt;. For unbounded uniform ints (&lt;code&gt;minval&lt;/code&gt;, &lt;code&gt;maxval&lt;/code&gt; both &lt;code&gt;None&lt;/code&gt;), &lt;code&gt;uint32&lt;/code&gt; and &lt;code&gt;uint64&lt;/code&gt; may be used.</source>
          <target state="translated">出力のタイプ： &lt;code&gt;float16&lt;/code&gt; 、 &lt;code&gt;float32&lt;/code&gt; 、 &lt;code&gt;float64&lt;/code&gt; 、 &lt;code&gt;int32&lt;/code&gt; 、または &lt;code&gt;int64&lt;/code&gt; 。無限均一int型（ため &lt;code&gt;minval&lt;/code&gt; 、 &lt;code&gt;maxval&lt;/code&gt; 両方 &lt;code&gt;None&lt;/code&gt; ）、 &lt;code&gt;uint32&lt;/code&gt; と &lt;code&gt;uint64&lt;/code&gt; 使用することができます。</target>
        </trans-unit>
        <trans-unit id="5b2e4f649b30bc99091c2da410cb8448c8ba873a" translate="yes" xml:space="preserve">
          <source>The type of the this &lt;code&gt;LinearOperator&lt;/code&gt;. Arguments to &lt;code&gt;matmul&lt;/code&gt; and &lt;code&gt;solve&lt;/code&gt; will have to be this type.</source>
          <target state="translated">この &lt;code&gt;LinearOperator&lt;/code&gt; のタイプ。 &lt;code&gt;matmul&lt;/code&gt; と &lt;code&gt;solve&lt;/code&gt; の引数は、このタイプである必要があります。</target>
        </trans-unit>
        <trans-unit id="74e0737155eb6c648136eb7aa61f1f5f53eaee2c" translate="yes" xml:space="preserve">
          <source>The type of the variable. Defaults to &lt;code&gt;self.dtype&lt;/code&gt; or &lt;code&gt;float32&lt;/code&gt;.</source>
          <target state="translated">変数のタイプ。デフォルトは &lt;code&gt;self.dtype&lt;/code&gt; または &lt;code&gt;float32&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="89eb9b54cfc1eb5edbdf1804af86410f57c03f40" translate="yes" xml:space="preserve">
          <source>The type of values.</source>
          <target state="translated">価値観の種類です。</target>
        </trans-unit>
        <trans-unit id="cc791524ffdf48de9024b17fb2e81e72b1743abc" translate="yes" xml:space="preserve">
          <source>The type specification of an element of &lt;a href=&quot;distributediterator&quot;&gt;&lt;code&gt;tf.distribute.DistributedIterator&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;distributediterator&quot;&gt; &lt;code&gt;tf.distribute.DistributedIterator&lt;/code&gt; の&lt;/a&gt;要素の型指定。</target>
        </trans-unit>
        <trans-unit id="586865cdc2362857bdac73e4d9d4aafd45add2e6" translate="yes" xml:space="preserve">
          <source>The type specification of an element of this &lt;a href=&quot;distributeddataset&quot;&gt;&lt;code&gt;tf.distribute.DistributedDataset&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この&lt;a href=&quot;distributeddataset&quot;&gt; &lt;code&gt;tf.distribute.DistributedDataset&lt;/code&gt; の&lt;/a&gt;要素の型指定。</target>
        </trans-unit>
        <trans-unit id="9f4d546108b4584207f8473dd28294356ddeede5" translate="yes" xml:space="preserve">
          <source>The type specification of an element of this dataset.</source>
          <target state="translated">このデータセットの要素の型指定。</target>
        </trans-unit>
        <trans-unit id="31f5cdd5cadead57bcfc00f19cdc637b778a8dfa" translate="yes" xml:space="preserve">
          <source>The type specification of an element of this iterator.</source>
          <target state="translated">このイテレータの要素の型指定。</target>
        </trans-unit>
        <trans-unit id="31e1b2499af19cb707e87dbc9b32089b65e02169" translate="yes" xml:space="preserve">
          <source>The type specification of an element of this optional.</source>
          <target state="translated">このオプションの要素の型指定。</target>
        </trans-unit>
        <trans-unit id="bce40406c73aa0072207096be99446cc37cd3334" translate="yes" xml:space="preserve">
          <source>The types of the tensors in &lt;code&gt;values&lt;/code&gt; must match the schema for the fields specified in &lt;code&gt;field_names&lt;/code&gt;. All the tensors in &lt;code&gt;values&lt;/code&gt; must have a common shape prefix, &lt;em&gt;batch_shape&lt;/em&gt;.</source>
          <target state="translated">&lt;code&gt;values&lt;/code&gt; のテンソルのタイプは、 &lt;code&gt;field_names&lt;/code&gt; で指定されたフィールドのスキーマと一致する必要があります。 &lt;code&gt;values&lt;/code&gt; すべてのテンソルには、共通の形状接頭辞&lt;em&gt;batch_shapeが必要&lt;/em&gt;です。</target>
        </trans-unit>
        <trans-unit id="e5381b2e579e07c748270f78ee35dd566e3eb442" translate="yes" xml:space="preserve">
          <source>The typical scenario for &lt;code&gt;ExponentialMovingAverage&lt;/code&gt; is to compute moving averages of variables during training, and restore the variables from the computed moving averages during evaluations.</source>
          <target state="translated">&lt;code&gt;ExponentialMovingAverage&lt;/code&gt; の一般的なシナリオは、トレーニング中に変数の移動平均を計算し、評価中に計算された移動平均から変数を復元することです。</target>
        </trans-unit>
        <trans-unit id="3da77fbceb0e840441ce8c39192555e97fa2928b" translate="yes" xml:space="preserve">
          <source>The underlying accumulator reference.</source>
          <target state="translated">基礎となるアキュムレータ参照。</target>
        </trans-unit>
        <trans-unit id="c25ef637b6290d9c594d8a4f22f2ec949aa1bd01" translate="yes" xml:space="preserve">
          <source>The underlying queue reference.</source>
          <target state="translated">その下にあるキューの参照。</target>
        </trans-unit>
        <trans-unit id="e903c075a80c182337230b41e8fc05a166057ed0" translate="yes" xml:space="preserve">
          <source>The unique &lt;code&gt;frame_name&lt;/code&gt; is used by the &lt;code&gt;Executor&lt;/code&gt; to identify frames. If &lt;code&gt;is_constant&lt;/code&gt; is true, &lt;code&gt;output&lt;/code&gt; is a constant in the child frame; otherwise it may be changed in the child frame. At most &lt;code&gt;parallel_iterations&lt;/code&gt; iterations are run in parallel in the child frame.</source>
          <target state="translated">一意の &lt;code&gt;frame_name&lt;/code&gt; は、フレームを識別するために &lt;code&gt;Executor&lt;/code&gt; キュータによって使用されます。場合 &lt;code&gt;is_constant&lt;/code&gt; がtrueの場合、 &lt;code&gt;output&lt;/code&gt; 子フレーム内で一定です。そうしないと、子フレームで変更される可能性があります。最大で &lt;code&gt;parallel_iterations&lt;/code&gt; の反復は、子フレームで並列に実行されます。</target>
        </trans-unit>
        <trans-unit id="2570833b8fed9aa7ee0f6db077c7e434ab3d563b" translate="yes" xml:space="preserve">
          <source>The unpacked tuple, with &lt;code&gt;None&lt;/code&gt;s for &lt;code&gt;y&lt;/code&gt; and &lt;code&gt;sample_weight&lt;/code&gt; if they are not provided.</source>
          <target state="translated">アンパックタプル、 &lt;code&gt;None&lt;/code&gt; に対するS &lt;code&gt;y&lt;/code&gt; と &lt;code&gt;sample_weight&lt;/code&gt; それらが提供されない場合。</target>
        </trans-unit>
        <trans-unit id="d25a2d45745d4308947942d9bddb3fe51f90e219" translate="yes" xml:space="preserve">
          <source>The update rule for &lt;code&gt;variable&lt;/code&gt; with gradient &lt;code&gt;g&lt;/code&gt; uses an optimization described at the end of section 2 of the paper:</source>
          <target state="translated">勾配 &lt;code&gt;g&lt;/code&gt; を持つ &lt;code&gt;variable&lt;/code&gt; の更新規則は、論文のセクション2の最後に記載されている最適化を使用します。</target>
        </trans-unit>
        <trans-unit id="dcaa87717690c893cddcbb06c2774de0d640ef88" translate="yes" xml:space="preserve">
          <source>The update rule for &lt;code&gt;variable&lt;/code&gt; with gradient &lt;code&gt;g&lt;/code&gt; uses an optimization described at the end of section 7.1 of the paper:</source>
          <target state="translated">勾配 &lt;code&gt;g&lt;/code&gt; を持つ &lt;code&gt;variable&lt;/code&gt; の更新規則は、本書のセクション7.1の終わりに説明されている最適化を使用します。</target>
        </trans-unit>
        <trans-unit id="0efd76819f39cf3bcb5dd14bc65d8c8c72cef23d" translate="yes" xml:space="preserve">
          <source>The update rule for parameter &lt;code&gt;w&lt;/code&gt; with gradient &lt;code&gt;g&lt;/code&gt; is described at the end of section 7.1 of the paper:</source>
          <target state="translated">勾配 &lt;code&gt;g&lt;/code&gt; のパラメーター &lt;code&gt;w&lt;/code&gt; の更新規則は、このペーパーのセクション7.1の最後に説明されています。</target>
        </trans-unit>
        <trans-unit id="1a9901f8d5a239b98ad1f04b6bbdac6a25b5dbe0" translate="yes" xml:space="preserve">
          <source>The updated config has something needed to run a strategy, e.g. configuration to run collective ops, or device filters to improve distributed training performance.</source>
          <target state="translated">更新された設定には、戦略を実行するために必要なものが含まれています。例えば、集団行動を実行するための設定や、分散トレーニングのパフォーマンスを向上させるためのデバイスフィルタなどです。</target>
        </trans-unit>
        <trans-unit id="60dd7fe2afadb5341f05d411ef207c2859229807" translate="yes" xml:space="preserve">
          <source>The updated copy of the &lt;code&gt;config_proto&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;config_proto&lt;/code&gt; の更新されたコピー。</target>
        </trans-unit>
        <trans-unit id="7d9e39fd60700bb347ed0039e54d9af3ef5a5100" translate="yes" xml:space="preserve">
          <source>The updated decorator. If decorator_func is not a tf_decorator, new_target is returned.</source>
          <target state="translated">更新されたデコレータ。decorator_funcがtf_decoratorでない場合、new_targetが返される。</target>
        </trans-unit>
        <trans-unit id="fa6ecd5172af3b96400529c50d0c7eb9f4adaa33" translate="yes" xml:space="preserve">
          <source>The updated variable.</source>
          <target state="translated">更新された変数です。</target>
        </trans-unit>
        <trans-unit id="bb0ce841932dc29d8f332a4acc96a1313d2133b7" translate="yes" xml:space="preserve">
          <source>The updated variable. If &lt;code&gt;read_value&lt;/code&gt; is false, instead returns None in Eager mode and the assign op in graph mode.</source>
          <target state="translated">更新された変数。 &lt;code&gt;read_value&lt;/code&gt; がfalseの場合、代わりにEagerモードではNoneを返し、グラフモードではassignopを返します。</target>
        </trans-unit>
        <trans-unit id="5d8daec55baf3c813ce2f2fc4a5eab596ea78fbf" translate="yes" xml:space="preserve">
          <source>The upper regularized incomplete Gamma function is defined as:</source>
          <target state="translated">上位正則化された不完全ガンマ関数は次のように定義されます。</target>
        </trans-unit>
        <trans-unit id="a16fb2ccec6d9e76f7b18eacf6123674146710e7" translate="yes" xml:space="preserve">
          <source>The user could also use &lt;code&gt;make_input_fn_iterator&lt;/code&gt; if they want to customize which input is fed to which replica/worker etc.</source>
          <target state="translated">ユーザーは、どの入力がどのレプリカ/ワーカーに供給されるかなどをカスタマイズしたい場合は、 &lt;code&gt;make_input_fn_iterator&lt;/code&gt; を使用することもできます。</target>
        </trans-unit>
        <trans-unit id="ab789081815c49957f21bd695c2a3924b82c20ff" translate="yes" xml:space="preserve">
          <source>The user is given the option of raising an exception or returning &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">ユーザーには、例外を発生させるか、 &lt;code&gt;NaN&lt;/code&gt; を返すオプションが与えられます。</target>
        </trans-unit>
        <trans-unit id="2d78e502adf2b1729b9f368b8135c69dbb97bac0" translate="yes" xml:space="preserve">
          <source>The usual cross-entropy cost is defined as:</source>
          <target state="translated">通常のクロスエントロピーコストは次のように定義されます。</target>
        </trans-unit>
        <trans-unit id="55894b0693429bc52d5ca851ab5e7e50a45cb526" translate="yes" xml:space="preserve">
          <source>The valid keyword arguments in kwds are:</source>
          <target state="translated">kwdsで有効なキーワード引数は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="2e9dcb12c3ec9343c2b4d76ebee61442f18c708d" translate="yes" xml:space="preserve">
          <source>The value &lt;code&gt;delta&lt;/code&gt; is added to all components of the tensor &lt;code&gt;image&lt;/code&gt;. &lt;code&gt;image&lt;/code&gt; is converted to &lt;code&gt;float&lt;/code&gt; and scaled appropriately if it is in fixed-point representation, and &lt;code&gt;delta&lt;/code&gt; is converted to the same data type. For regular images, &lt;code&gt;delta&lt;/code&gt; should be in the range &lt;code&gt;[0,1)&lt;/code&gt;, as it is added to the image in floating point representation, where pixel values are in the &lt;code&gt;[0,1)&lt;/code&gt; range.</source>
          <target state="translated">&lt;code&gt;delta&lt;/code&gt; 値はテンソル &lt;code&gt;image&lt;/code&gt; すべての成分に追加されます。 &lt;code&gt;image&lt;/code&gt; が &lt;code&gt;float&lt;/code&gt; 変換され、固定小数点表現の場合は適切にスケーリングされ、 &lt;code&gt;delta&lt;/code&gt; は同じデータ型に変換されます。通常の画像の場合、ピクセル値が &lt;code&gt;[0,1)&lt;/code&gt; の範囲にある浮動小数点表現で画像に追加されるため、 &lt;code&gt;delta&lt;/code&gt; は &lt;code&gt;[0,1)&lt;/code&gt; の範囲にある必要があります。</target>
        </trans-unit>
        <trans-unit id="a0cc40289aaf5ca63368c701a28edf746620f686" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;self.value &amp;gt; other.value&lt;/code&gt; if both are known, otherwise None.</source>
          <target state="translated">両方がわかっている場合は、 &lt;code&gt;self.value &amp;gt; other.value&lt;/code&gt; の値、それ以外の場合はなし。</target>
        </trans-unit>
        <trans-unit id="28eee150e3c68dabbd6edcffc1df83846a31e392" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;self.value &amp;gt;= other.value&lt;/code&gt; if both are known, otherwise None.</source>
          <target state="translated">&lt;code&gt;self.value &amp;gt;= other.value&lt;/code&gt; の値は、両方が既知の場合はそれ以外、それ以外の場合はなし。</target>
        </trans-unit>
        <trans-unit id="1ac388cf68a7917e640172de08cfda57213cf191" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;self.value &amp;lt; other.value&lt;/code&gt; if both are known, otherwise None.</source>
          <target state="translated">両方が既知の場合は、 &lt;code&gt;self.value &amp;lt; other.value&lt;/code&gt; の値、それ以外の場合はNone。</target>
        </trans-unit>
        <trans-unit id="b01cea77304d81c49aa6bfe991a86b9994cc913b" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;self.value &amp;lt;= other.value&lt;/code&gt; if both are known, otherwise None.</source>
          <target state="translated">両方が既知の場合は、 &lt;code&gt;self.value &amp;lt;= other.value&lt;/code&gt; の値、それ以外の場合はNone。</target>
        </trans-unit>
        <trans-unit id="97a93b3e6e5220aba9e50c43c510d2bbbc1a87e0" translate="yes" xml:space="preserve">
          <source>The value of such a flag is a list that contains the individual values from all the appearances of that flag on the command-line.</source>
          <target state="translated">このようなフラグの値は、コマンドライン上でそのフラグがすべて出現したときの個々の値を含むリストです。</target>
        </trans-unit>
        <trans-unit id="a54451b41292d69deaf5cd8ce0771065680d134d" translate="yes" xml:space="preserve">
          <source>The value of the attr, as a Python object.</source>
          <target state="translated">Pythonオブジェクトとしてのattrの値。</target>
        </trans-unit>
        <trans-unit id="6e7716dffe6353c157e4a2c3f2e655d155be6b4b" translate="yes" xml:space="preserve">
          <source>The value of the flag is always a list, even if the option was only supplied once, and even if the default value is a single value</source>
          <target state="translated">フラグの値は、たとえオプションが一度しか与えられなかったとしても、またデフォルト値が単一の値であったとしても、常にリストになります。</target>
        </trans-unit>
        <trans-unit id="f28d312af2bea03bbf52afb2a569177bf8ca705a" translate="yes" xml:space="preserve">
          <source>The value of the flag, empty if the flag is not defined.</source>
          <target state="translated">フラグの値。フラグが定義されていない場合は空。</target>
        </trans-unit>
        <trans-unit id="bf8b3cb3b48dec54fd1680c59ba7cefb3dfc3602" translate="yes" xml:space="preserve">
          <source>The value of the variable after the update.</source>
          <target state="translated">更新後の変数の値。</target>
        </trans-unit>
        <trans-unit id="d29c684e1056225784225bef1dc61fddd3c411d6" translate="yes" xml:space="preserve">
          <source>The value of this dimension, or None if it is unknown.</source>
          <target state="translated">このディメンジョンの値、または不明な場合は None。</target>
        </trans-unit>
        <trans-unit id="dc40d49743dfe15cf0fa34edb80ecfa5afa70d65" translate="yes" xml:space="preserve">
          <source>The value or values returned by &lt;code&gt;map_func&lt;/code&gt; determine the structure of each element in the returned dataset.</source>
          <target state="translated">&lt;code&gt;map_func&lt;/code&gt; によって返される値は、返されるデータセットの各要素の構造を決定します。</target>
        </trans-unit>
        <trans-unit id="277f6e101a6f4f13a9cc5f1fee440972491084f4" translate="yes" xml:space="preserve">
          <source>The value representing an out-of-vocabulary value. Defaults to -1.</source>
          <target state="translated">語彙外の値を表す値。デフォルトは -1 です。</target>
        </trans-unit>
        <trans-unit id="27a9bdb78e692ccca6e6eeacfe9cf8259c37e6d7" translate="yes" xml:space="preserve">
          <source>The value returned by &lt;code&gt;run()&lt;/code&gt; has the same shape as the &lt;code&gt;fetches&lt;/code&gt; argument, where the leaves are replaced by the corresponding values returned by TensorFlow.</source>
          <target state="translated">&lt;code&gt;run()&lt;/code&gt; によって返される値は、 &lt;code&gt;fetches&lt;/code&gt; 引数と同じ形をしており、葉はTensorFlowによって返される対応する値に置き換えられます。</target>
        </trans-unit>
        <trans-unit id="6455c45d9b49b1bb8f4ec9b5dff00531b9342ec2" translate="yes" xml:space="preserve">
          <source>The value returned by the &lt;code&gt;activity_regularizer&lt;/code&gt; is divided by the input batch size so that the relative weighting between the weight regularizers and the activity regularizers does not change with the batch size.</source>
          <target state="translated">&lt;code&gt;activity_regularizer&lt;/code&gt; によって返される値は、入力バッチサイズで除算されるため、ウェイトレギュラライザとアクティビティレギュラライザ間の相対的な重み付けは、バッチサイズによって変化しません。</target>
        </trans-unit>
        <trans-unit id="e67ea60a1d86085a3a91a8df093188ea7d78231f" translate="yes" xml:space="preserve">
          <source>The value returned by this operation is guaranteed to be influenced by all the writes on which this operation depends directly or indirectly, and to not be influenced by any of the writes which depend directly or indirectly on this operation.</source>
          <target state="translated">この操作によって返される値は、この操作が直接または間接的に依存するすべての書き込みに影響を受け、この操作に直接または間接的に依存する書き込みに影響を受けないことが保証されています。</target>
        </trans-unit>
        <trans-unit id="ca8a88dac26c441fe66426635dcf33f3ecddba85" translate="yes" xml:space="preserve">
          <source>The value to add to the collection.</source>
          <target state="translated">コレクションに追加する値。</target>
        </trans-unit>
        <trans-unit id="67488a526901c9a4f2769ad17a3b244c04775dbb" translate="yes" xml:space="preserve">
          <source>The value to add to the collections.</source>
          <target state="translated">コレクションに加える価値。</target>
        </trans-unit>
        <trans-unit id="0467f1eec9e713645aba39b382503cafa6ae6856" translate="yes" xml:space="preserve">
          <source>The value to fill for empty rows, with the same type as &lt;code&gt;sp_input.&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;sp_input.&lt;/code&gt; と同じタイプで、空の行を埋めるための値。</target>
        </trans-unit>
        <trans-unit id="6c9729e11273c726456e8e0c3c8e270a5166729e" translate="yes" xml:space="preserve">
          <source>The value to fill the area outside the specified diagonal band with. Default is 0.</source>
          <target state="translated">指定した対角線帯の外側の領域を塗りつぶす値。デフォルトは0です。</target>
        </trans-unit>
        <trans-unit id="53f548425b8c43bbee75c542b6da5327e5f5f507" translate="yes" xml:space="preserve">
          <source>The value to use if a key is missing in the table.</source>
          <target state="translated">テーブル内にキーがない場合に使用する値。</target>
        </trans-unit>
        <trans-unit id="46cf38cbb0627d0763f0f1b40f1bcbf960cd2dde" translate="yes" xml:space="preserve">
          <source>The values generated are similar to values from a &lt;a href=&quot;randomnormal&quot;&gt;&lt;code&gt;tf.keras.initializers.RandomNormal&lt;/code&gt;&lt;/a&gt; initializer except that values more than two standard deviations from the mean are discarded and re-drawn.</source>
          <target state="translated">生成される値は、&lt;a href=&quot;randomnormal&quot;&gt; &lt;code&gt;tf.keras.initializers.RandomNormal&lt;/code&gt; &lt;/a&gt;初期化子の値と似ていますが、平均からの標準偏差が2を超える値が破棄され、再描画される点が異なります。</target>
        </trans-unit>
        <trans-unit id="c61a71eb4077cf30110803e381657708b49ae932" translate="yes" xml:space="preserve">
          <source>The values must include 0. There can be no duplicate values or negative values.</source>
          <target state="translated">値には 0 を含めなければなりません。重複した値や負の値を含むことはできません。</target>
        </trans-unit>
        <trans-unit id="1050986413ba8aa09be08e1ada6c99bfa286c827" translate="yes" xml:space="preserve">
          <source>The values not defined in &lt;code&gt;sp_input&lt;/code&gt; don't participate in the reduce max, as opposed to be implicitly assumed 0 -- hence it can return negative values for sparse &lt;code&gt;axis&lt;/code&gt;. But, in case there are no values in &lt;code&gt;axis&lt;/code&gt;, it will reduce to 0. See second example below.</source>
          <target state="translated">&lt;code&gt;sp_input&lt;/code&gt; で定義されていない値は、暗黙的に0と見なされるのではなく、reduce maxに参加しません。そのため、疎 &lt;code&gt;axis&lt;/code&gt; 負の値を返す可能性があります。ただし、 &lt;code&gt;axis&lt;/code&gt; に値がない場合、値は0に減少します。以下の2番目の例を参照してください。</target>
        </trans-unit>
        <trans-unit id="15f0cbbec41c8cec7a1600faa3fd0ba6c8267aeb" translate="yes" xml:space="preserve">
          <source>The values not defined in &lt;code&gt;sp_input&lt;/code&gt; don't participate in the reduce max, as opposed to be implicitly assumed 0 -- hence it can return negative values for sparse &lt;code&gt;reduction_axes&lt;/code&gt;. But, in case there are no values in &lt;code&gt;reduction_axes&lt;/code&gt;, it will reduce to 0. See second example below.</source>
          <target state="translated">&lt;code&gt;sp_input&lt;/code&gt; で定義されていない値は、暗黙的に0と見なされるのではなく、reduce maxに参加しません。したがって、スパースの &lt;code&gt;reduction_axes&lt;/code&gt; に対して負の値を返す可能性があります。ただし、 &lt;code&gt;reduction_axes&lt;/code&gt; に値がない場合は、0に減少します。以下の2番目の例を参照してください。</target>
        </trans-unit>
        <trans-unit id="01b28056c2bd0c58a2e89c42fd350d1a9e497580" translate="yes" xml:space="preserve">
          <source>The values of &lt;code&gt;alpha&lt;/code&gt; and &lt;code&gt;scale&lt;/code&gt; are chosen so that the mean and variance of the inputs are preserved between two consecutive layers as long as the weights are initialized correctly (see &lt;a href=&quot;../initializers/lecun_normal&quot;&gt;&lt;code&gt;lecun_normal&lt;/code&gt; initialization&lt;/a&gt;) and the number of inputs is &quot;large enough&quot; (see references for more information).</source>
          <target state="translated">&lt;code&gt;alpha&lt;/code&gt; と &lt;code&gt;scale&lt;/code&gt; の値は、重みが正しく初期化され（&lt;a href=&quot;../initializers/lecun_normal&quot;&gt; &lt;code&gt;lecun_normal&lt;/code&gt; 初期化を&lt;/a&gt;参照）、入力数が「十分に大きい」（参照の詳しくは）。</target>
        </trans-unit>
        <trans-unit id="64ea94b6b8cce4972e532c22a39ade0ab1c04bbd" translate="yes" xml:space="preserve">
          <source>The values of &lt;code&gt;alpha&lt;/code&gt; and &lt;code&gt;scale&lt;/code&gt; are chosen so that the mean and variance of the inputs are preserved between two consecutive layers as long as the weights are initialized correctly (see &lt;a href=&quot;../initializers/lecunnormal&quot;&gt;&lt;code&gt;tf.keras.initializers.LecunNormal&lt;/code&gt;&lt;/a&gt; initializer) and the number of input units is &quot;large enough&quot; (see reference paper for more information).</source>
          <target state="translated">&lt;code&gt;alpha&lt;/code&gt; と &lt;code&gt;scale&lt;/code&gt; の値は、重みが正しく初期化され（&lt;a href=&quot;../initializers/lecunnormal&quot;&gt; &lt;code&gt;tf.keras.initializers.LecunNormal&lt;/code&gt; &lt;/a&gt;イニシャライザーを参照）、入力ユニットの数が &quot;である限り、入力の平均と分散が2つの連続するレイヤー間で保持されるように選択されます。十分な大きさ」（詳細については、リファレンスペーパーを参照してください）。</target>
        </trans-unit>
        <trans-unit id="f733a02fe3b03768ab1ca9ec4da3805a1ad4b791" translate="yes" xml:space="preserve">
          <source>The values of &lt;code&gt;value&lt;/code&gt; are assigned to the positions in the tensor &lt;code&gt;input&lt;/code&gt; that are selected by the slice parameters. The slice parameters &lt;code&gt;begin&lt;/code&gt;&lt;code&gt;end&lt;/code&gt;&lt;code&gt;strides&lt;/code&gt; etc. work exactly as in &lt;code&gt;StridedSlice&lt;/code&gt;.</source>
          <target state="translated">値の &lt;code&gt;value&lt;/code&gt; は、スライスパラメータによって選択されたテンソル &lt;code&gt;input&lt;/code&gt; 位置に割り当てられます。スライスパラメータ &lt;code&gt;begin&lt;/code&gt; &lt;code&gt;end&lt;/code&gt; &lt;code&gt;strides&lt;/code&gt; などを開始し、 &lt;code&gt;StridedSlice&lt;/code&gt; とまったく同じように機能します。</target>
        </trans-unit>
        <trans-unit id="f39cb348464cd40ba244caddc3b9020cc754ba4b" translate="yes" xml:space="preserve">
          <source>The values of &lt;code&gt;value&lt;/code&gt; are assigned to the positions in the variable &lt;code&gt;ref&lt;/code&gt; that are selected by the slice parameters. The slice parameters &lt;code&gt;begin,&lt;/code&gt;end&lt;code&gt;,&lt;/code&gt;strides&lt;code&gt;, etc. work exactly as in&lt;/code&gt;StridedSlice`.</source>
          <target state="translated">valueの &lt;code&gt;value&lt;/code&gt; は、スライスパラメータによって選択された変数 &lt;code&gt;ref&lt;/code&gt; 内の位置に割り当てられます。スライスパラメータの &lt;code&gt;begin,&lt;/code&gt; 終了 &lt;code&gt;,&lt;/code&gt; ストライド &lt;code&gt;, etc. work exactly as in&lt;/code&gt; StridedSlice`とまったく同じように機能します。</target>
        </trans-unit>
        <trans-unit id="1f2d5c98a3c37925f071ae528d2a1426fcf8d79c" translate="yes" xml:space="preserve">
          <source>The values of &lt;code&gt;value&lt;/code&gt; are assigned to the positions in the variable &lt;code&gt;ref&lt;/code&gt; that are selected by the slice parameters. The slice parameters &lt;code&gt;begin&lt;/code&gt;, &lt;code&gt;end&lt;/code&gt;, &lt;code&gt;strides&lt;/code&gt;, etc. work exactly as in &lt;code&gt;StridedSlice&lt;/code&gt;.</source>
          <target state="translated">valueの &lt;code&gt;value&lt;/code&gt; は、スライスパラメータによって選択された変数 &lt;code&gt;ref&lt;/code&gt; 内の位置に割り当てられます。スライスパラメータの &lt;code&gt;begin&lt;/code&gt; 、 &lt;code&gt;end&lt;/code&gt; 、 &lt;code&gt;strides&lt;/code&gt; などは、 &lt;code&gt;StridedSlice&lt;/code&gt; とまったく同じように機能します。</target>
        </trans-unit>
        <trans-unit id="823a169cfff816da0e0ed79e7aa0fca33f12184b" translate="yes" xml:space="preserve">
          <source>The values to be used in the operation.</source>
          <target state="translated">操作に使用する値です。</target>
        </trans-unit>
        <trans-unit id="340b53ddcc61e1600456fa6a942b3a9db9dcd7f4" translate="yes" xml:space="preserve">
          <source>The variable &lt;code&gt;x&lt;/code&gt; updated.</source>
          <target state="translated">変数 &lt;code&gt;x&lt;/code&gt; が更新されました。</target>
        </trans-unit>
        <trans-unit id="9b98520ded5c59855ccbb91e15451f218e4fed8a" translate="yes" xml:space="preserve">
          <source>The variable corresponding to &lt;code&gt;input_&lt;/code&gt; or None</source>
          <target state="translated">&lt;code&gt;input_&lt;/code&gt; またはNoneに対応する変数</target>
        </trans-unit>
        <trans-unit id="b58067393f30493e389388e4808eed6d24490c13" translate="yes" xml:space="preserve">
          <source>The variable dtype of this policy, or None if the variable dtype should be inferred from the inputs.</source>
          <target state="translated">このポリシーの変数dtype、または変数dtypeが入力から推測される場合はNone。</target>
        </trans-unit>
        <trans-unit id="bb822034c75bacc81fb53dec6e4b25c54f49ac48" translate="yes" xml:space="preserve">
          <source>The variable dtype of this policy.</source>
          <target state="translated">このポリシーの変数 dtype。</target>
        </trans-unit>
        <trans-unit id="cf801794eaaba6ef2f8f7f433ed37a63d7d2327d" translate="yes" xml:space="preserve">
          <source>The variance for Student's T equals</source>
          <target state="translated">Student's Tの分散は等しく</target>
        </trans-unit>
        <trans-unit id="d641778ea2685b7b78fd228569c0026aa6abdc9c" translate="yes" xml:space="preserve">
          <source>The vocabulary file name.</source>
          <target state="translated">語彙ファイル名。</target>
        </trans-unit>
        <trans-unit id="cde4cff8a5ecda6c3308cd587b5940a27adec93c" translate="yes" xml:space="preserve">
          <source>The vocabulary file should be in CSV-like format, with the last field being the weight associated with the word.</source>
          <target state="translated">語彙ファイルはCSVのような形式で、最後のフィールドはその単語に関連付けられた重みである必要があります。</target>
        </trans-unit>
        <trans-unit id="1063f666d548cfe042252b2f4239aa647a4b8506" translate="yes" xml:space="preserve">
          <source>The weights of a layer represent the state of the layer. This function returns both trainable and non-trainable weight values associated with this layer as a list of Numpy arrays, which can in turn be used to load state into similarly parameterized layers.</source>
          <target state="translated">レイヤーの重みは,そのレイヤーの状態を表します.この関数は,このレイヤに関連付けられた学習可能な重みと学習不可能な重みの両方をNumpy配列のリストとして返します.</target>
        </trans-unit>
        <trans-unit id="bf4e9211223da35fb0cefc91c559dd39cd92d9f5" translate="yes" xml:space="preserve">
          <source>The weights of a layer represent the state of the layer. This function sets the weight values from numpy arrays. The weight values should be passed in the order they are created by the layer. Note that the layer's weights must be instantiated before calling this function by calling the layer.</source>
          <target state="translated">レイヤーの重みは、レイヤーの状態を表します。この関数は numpy 配列から重みの値を設定します。ウェイト値は、レイヤーが作成した順に渡す必要があります。レイヤーを呼び出してこの関数を呼び出す前に、レイヤーの重みをインスタンス化しておく必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="9c9c5e7f6fe29d5feb4e712a5efa9aacc5795ce1" translate="yes" xml:space="preserve">
          <source>The weights of an optimizer are its state (ie, variables). This function returns the weight values associated with this optimizer as a list of Numpy arrays. The first value is always the iterations count of the optimizer, followed by the optimizer's state variables in the order they were created. The returned list can in turn be used to load state into similarly parameterized optimizers.</source>
          <target state="translated">オプティマイザの重みは、そのオプティマイザの状態(つまり変数)です。この関数は、このオプティマイザに関連付けられた重みの値をNumpy配列のリストとして返します。最初の値は常にオプティマイザの反復回数で、その後にオプティマイザの状態変数が作成された順に続きます。返されたリストは、同様にパラメータ化されたオプティマイザに状態をロードするために使用することができます。</target>
        </trans-unit>
        <trans-unit id="1dbc3d68ba3835fc93e47564b7ed4f1325c6e8cd" translate="yes" xml:space="preserve">
          <source>The weights of an optimizer are its state (ie, variables). This function takes the weight values associated with this optimizer as a list of Numpy arrays. The first value is always the iterations count of the optimizer, followed by the optimizer's state variables in the order they are created. The passed values are used to set the new state of the optimizer.</source>
          <target state="translated">オプティマイザの重みは、そのオプティマイザの状態(つまり変数)です。この関数は、このオプティマイザに関連付けられた重みの値をNumpy配列のリストとして受け取ります。最初の値は常にオプティマイザの反復回数で、その後にオプティマイザの状態変数が作成された順に続きます。渡された値は、オプティマイザの新しい状態を設定するために使用されます。</target>
        </trans-unit>
        <trans-unit id="15e91da427b6cf2b2fbc5ac9447fe8b24dd8aa82" translate="yes" xml:space="preserve">
          <source>The width the output tensor is &lt;code&gt;input_depth * block_size&lt;/code&gt;, whereas the height is &lt;code&gt;input_height * block_size&lt;/code&gt;.</source>
          <target state="translated">出力テンソルの幅は &lt;code&gt;input_depth * block_size&lt;/code&gt; ですが、高さは &lt;code&gt;input_height * block_size&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="4a165b5ce96be1f52d9f7edf6d8a65c227dd997f" translate="yes" xml:space="preserve">
          <source>The width(s) of the ngrams to create. If this is a list or tuple, the op will return ngrams of all specified arities in list order. Values must be non-Tensor integers greater than 0.</source>
          <target state="translated">作成するngramの幅を指定します。これがリストまたはタプルである場合、opは指定されたすべての配列のngramsをリスト順に返します。値は0以上の非テンソル整数でなければなりません。</target>
        </trans-unit>
        <trans-unit id="78fda38eef982ddecbfd2142c00746b57a76815b" translate="yes" xml:space="preserve">
          <source>The word index dictionary.</source>
          <target state="translated">単語の索引辞書。</target>
        </trans-unit>
        <trans-unit id="524d27d9a78ab988dfdffc5a8ddf699fa93cbe93" translate="yes" xml:space="preserve">
          <source>The word index dictionary. Keys are word strings, values are their index.</source>
          <target state="translated">単語インデックス辞書。キーは単語の文字列、値はそのインデックスです。</target>
        </trans-unit>
        <trans-unit id="273384d93f6363b2a2a4c34767e0268890f5d5af" translate="yes" xml:space="preserve">
          <source>The wrapped input tensor.</source>
          <target state="translated">ラップされた入力テンソル。</target>
        </trans-unit>
        <trans-unit id="e4a82e3bb086ae7e63715facddf72f40e0765006" translate="yes" xml:space="preserve">
          <source>The wrapped output tensor.</source>
          <target state="translated">ラップされた出力テンソル。</target>
        </trans-unit>
        <trans-unit id="52457270e7a01e13ee00378b3108ea8fc12315e0" translate="yes" xml:space="preserve">
          <source>The wrapped value.</source>
          <target state="translated">ラップされた値。</target>
        </trans-unit>
        <trans-unit id="bb274ffefe3874a86b65898ba52aa9be06563172" translate="yes" xml:space="preserve">
          <source>The wrapper function.</source>
          <target state="translated">ラッパー機能です。</target>
        </trans-unit>
        <trans-unit id="0c29d607aec40364caa8044d1b086cb311bf2d17" translate="yes" xml:space="preserve">
          <source>Theano-like behavior example</source>
          <target state="translated">テアノのような行動例</target>
        </trans-unit>
        <trans-unit id="c3d562c283b894723caae359b0851a3c4fb15dc1" translate="yes" xml:space="preserve">
          <source>Then calling &lt;code&gt;image_dataset_from_directory(main_directory, labels='inferred')&lt;/code&gt; will return a &lt;a href=&quot;../../data/dataset&quot;&gt;&lt;code&gt;tf.data.Dataset&lt;/code&gt;&lt;/a&gt; that yields batches of images from the subdirectories &lt;code&gt;class_a&lt;/code&gt; and &lt;code&gt;class_b&lt;/code&gt;, together with labels 0 and 1 (0 corresponding to &lt;code&gt;class_a&lt;/code&gt; and 1 corresponding to &lt;code&gt;class_b&lt;/code&gt;).</source>
          <target state="translated">次に、 &lt;code&gt;image_dataset_from_directory(main_directory, labels='inferred')&lt;/code&gt; を &lt;code&gt;class_a&lt;/code&gt; と、サブディレクトリclass_aおよび &lt;code&gt;class_b&lt;/code&gt; から、ラベル0および1（0は &lt;code&gt;class_a&lt;/code&gt; に対応し、1は &lt;code&gt;class_b&lt;/code&gt; に対応）とともに画像のバッチを生成する&lt;a href=&quot;../../data/dataset&quot;&gt; &lt;code&gt;tf.data.Dataset&lt;/code&gt; &lt;/a&gt;が返されます。</target>
        </trans-unit>
        <trans-unit id="f5fae7664a9f8954314f95eaa134030803e80ccc" translate="yes" xml:space="preserve">
          <source>Then calling &lt;code&gt;text_dataset_from_directory(main_directory, labels='inferred')&lt;/code&gt; will return a &lt;a href=&quot;../../data/dataset&quot;&gt;&lt;code&gt;tf.data.Dataset&lt;/code&gt;&lt;/a&gt; that yields batches of texts from the subdirectories &lt;code&gt;class_a&lt;/code&gt; and &lt;code&gt;class_b&lt;/code&gt;, together with labels 0 and 1 (0 corresponding to &lt;code&gt;class_a&lt;/code&gt; and 1 corresponding to &lt;code&gt;class_b&lt;/code&gt;).</source>
          <target state="translated">次に、 &lt;code&gt;text_dataset_from_directory(main_directory, labels='inferred')&lt;/code&gt; を &lt;code&gt;class_a&lt;/code&gt; と、サブディレクトリclass_aおよび &lt;code&gt;class_b&lt;/code&gt; から、ラベル0および1（0は &lt;code&gt;class_a&lt;/code&gt; に対応し、1は &lt;code&gt;class_b&lt;/code&gt; に対応）とともにテキストのバッチを生成する&lt;a href=&quot;../../data/dataset&quot;&gt; &lt;code&gt;tf.data.Dataset&lt;/code&gt; &lt;/a&gt;が返されます。</target>
        </trans-unit>
        <trans-unit id="fb44a39f5e3304ba1e47cd9001107c1190200e02" translate="yes" xml:space="preserve">
          <source>Then output is &lt;code&gt;[2 x 2 x 3]&lt;/code&gt;:</source>
          <target state="translated">その場合、出力は &lt;code&gt;[2 x 2 x 3]&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="70803c29e37a6cdd022ef83164306a19f47318ca" translate="yes" xml:space="preserve">
          <source>Then output is &lt;code&gt;[3 x 4]&lt;/code&gt;:</source>
          <target state="translated">その場合、出力は &lt;code&gt;[3 x 4]&lt;/code&gt; です：</target>
        </trans-unit>
        <trans-unit id="609a89b6f4ea61b7d43929c28cac3cb16c1a8704" translate="yes" xml:space="preserve">
          <source>Then output is &lt;code&gt;[4 x 3]&lt;/code&gt;:</source>
          <target state="translated">その場合、出力は &lt;code&gt;[4 x 3]&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="b6380335743da8e76766d68f136c813dfdf80835" translate="yes" xml:space="preserve">
          <source>Then the final line will print out:</source>
          <target state="translated">そうすると、最後の一行が印刷されます。</target>
        </trans-unit>
        <trans-unit id="d073abde2a1df4b5c62a21448d955ee1c50a80df" translate="yes" xml:space="preserve">
          <source>Then the output is a dictionary:</source>
          <target state="translated">そうすると、出力は辞書になります。</target>
        </trans-unit>
        <trans-unit id="4c6244085178ac4f66fb4367c44b652758bf26c2" translate="yes" xml:space="preserve">
          <source>Then you can run a &lt;a href=&quot;../math/add&quot;&gt;&lt;code&gt;tf.add&lt;/code&gt;&lt;/a&gt; operation only on logical device 0.</source>
          <target state="translated">次に、論理デバイス0でのみ&lt;a href=&quot;../math/add&quot;&gt; &lt;code&gt;tf.add&lt;/code&gt; &lt;/a&gt;操作を実行できます。</target>
        </trans-unit>
        <trans-unit id="f77a2ae4d69da67530e4f97b9e84f16f29f79cdf" translate="yes" xml:space="preserve">
          <source>Then,</source>
          <target state="translated">Then,</target>
        </trans-unit>
        <trans-unit id="18c6dda9e31a83fdb5a90169c27005c658e8056f" translate="yes" xml:space="preserve">
          <source>Then, row_pooling_sequence should satisfy:</source>
          <target state="translated">とすると、row_pooling_sequenceは満たす必要があります。</target>
        </trans-unit>
        <trans-unit id="3debd4416d24691c45dc01b19b3489468194d8c2" translate="yes" xml:space="preserve">
          <source>There are a number of questions to ask in the decision process, including:</source>
          <target state="translated">などなど、意思決定の際にはいくつかの質問があります。</target>
        </trans-unit>
        <trans-unit id="6f58afb7ffb8a1e95bc14a4cccd59e26c144fddb" translate="yes" xml:space="preserve">
          <source>There are a number of requirements on what needs to happen inside the scope. However, in places where we have information about which strategy is in use, we often enter the scope for the user, so they don't have to do it explicitly (i.e. calling those either inside or outside the scope is OK).</source>
          <target state="translated">スコープ内で何をする必要があるかについては、いくつかの要件があります。しかし、どのストラテジーが使用されているかの情報がある場所では、ユーザーが明示的にスコープを入力する必要はありません(つまり、スコープの内側でも外側でも呼び出しはOKです)。</target>
        </trans-unit>
        <trans-unit id="f0dc8d396849561a849ade939c069a913c651243" translate="yes" xml:space="preserve">
          <source>There are different ways to quantize. This version uses only scaling, so 0.0 maps to 0.</source>
          <target state="translated">量子化にはさまざまな方法があります。このバージョンではスケーリングのみを使用しているので、0.0 は 0 にマップされます。</target>
        </trans-unit>
        <trans-unit id="372d16d9e0a1868251f75c59e5f513839dddd179" translate="yes" xml:space="preserve">
          <source>There are many different ways to implement atrous convolution (see the refs above). The implementation here reduces</source>
          <target state="translated">atrous 畳み込みを実装するには、さまざまな方法があります(上記参照)。ここでの実装では</target>
        </trans-unit>
        <trans-unit id="4b4c86e082be3a02799da3aa4833e74149042874" translate="yes" xml:space="preserve">
          <source>There are nodes like Identity and CheckNumerics that are only useful during training, and can be removed in graphs that will be used for nothing but inference. Here we identify and remove them, returning an equivalent graph. To be specific, CheckNumerics nodes are always removed, and Identity nodes that aren't involved in control edges are spliced out so that their input and outputs are directly connected.</source>
          <target state="translated">IdentityやCheckNumericsのようなノードがありますが、これらは学習中にのみ有用であり、推論以外には何にも使用されないグラフでは削除することができます。ここでは、それらを識別して削除し、等価なグラフを返します。具体的には、CheckNumericsのノードは常に削除され、制御辺に関与しないIdentityのノードは、入力と出力が直接接続されるようにスプライスアウトされる。</target>
        </trans-unit>
        <trans-unit id="a4fe5597954ba439b4679d614be0e1e5164b606b" translate="yes" xml:space="preserve">
          <source>There are several delicate issues when running multiple threads that way: closing the queues in sequence as the input is exhausted, correctly catching and reporting exceptions, etc.</source>
          <target state="translated">この方法で複数のスレッドを実行する場合には、いくつかのデリケートな問題があります:入力が尽きると順番にキューを閉じること、例外を正しくキャッチして報告すること、などです。</target>
        </trans-unit>
        <trans-unit id="20bc80fe9d0b075a12bc0575d2ba4a5d5fe1269d" translate="yes" xml:space="preserve">
          <source>There are several ways to run the conversion:</source>
          <target state="translated">変換を実行するにはいくつかの方法があります。</target>
        </trans-unit>
        <trans-unit id="9a0c34e11b24dd273612b5e842b9ca3db6c2dc5f" translate="yes" xml:space="preserve">
          <source>There are three important concepts associated with TensorFlow Distributions shapes:</source>
          <target state="translated">TensorFlowの分布形状に関連する3つの重要な概念があります。</target>
        </trans-unit>
        <trans-unit id="d89ee0299ae366416b4bb7507b2e32a19b6a4278" translate="yes" xml:space="preserve">
          <source>There are two APIs to create a &lt;a href=&quot;distributeddataset&quot;&gt;&lt;code&gt;tf.distribute.DistributedDataset&lt;/code&gt;&lt;/a&gt; object: &lt;a href=&quot;strategy#experimental_distribute_dataset&quot;&gt;&lt;code&gt;tf.distribute.Strategy.experimental_distribute_dataset(dataset)&lt;/code&gt;&lt;/a&gt;and &lt;a href=&quot;strategy#experimental_distribute_datasets_from_function&quot;&gt;&lt;code&gt;tf.distribute.Strategy.experimental_distribute_datasets_from_function(dataset_fn)&lt;/code&gt;&lt;/a&gt;. &lt;em&gt;When to use which?&lt;/em&gt; When you have a &lt;a href=&quot;../data/dataset&quot;&gt;&lt;code&gt;tf.data.Dataset&lt;/code&gt;&lt;/a&gt; instance, and the regular batch splitting (i.e. re-batch the input &lt;a href=&quot;../data/dataset&quot;&gt;&lt;code&gt;tf.data.Dataset&lt;/code&gt;&lt;/a&gt; instance with a new batch size that is equal to the global batch size divided by the number of replicas in sync) and autosharding (i.e. the &lt;a href=&quot;../data/experimental/autoshardpolicy&quot;&gt;&lt;code&gt;tf.data.experimental.AutoShardPolicy&lt;/code&gt;&lt;/a&gt; options) work for you, use the former API. Otherwise, if you are &lt;em&gt;not&lt;/em&gt; using a canonical &lt;a href=&quot;../data/dataset&quot;&gt;&lt;code&gt;tf.data.Dataset&lt;/code&gt;&lt;/a&gt; instance, or you would like to customize the batch splitting or sharding, you can wrap these logic in a &lt;code&gt;dataset_fn&lt;/code&gt; and use the latter API. Both API handles prefetch to device for the user. For more details and examples, follow the links to the APIs.</source>
          <target state="translated">&lt;a href=&quot;distributeddataset&quot;&gt; &lt;code&gt;tf.distribute.DistributedDataset&lt;/code&gt; &lt;/a&gt;オブジェクトを作成するための2つのAPIがあります：&lt;a href=&quot;strategy#experimental_distribute_dataset&quot;&gt; &lt;code&gt;tf.distribute.Strategy.experimental_distribute_dataset(dataset)&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;strategy#experimental_distribute_datasets_from_function&quot;&gt; &lt;code&gt;tf.distribute.Strategy.experimental_distribute_datasets_from_function(dataset_fn)&lt;/code&gt; &lt;/a&gt;。&lt;em&gt;いつどちらを使うの？&lt;/em&gt;あなたは持っている場合は&lt;a href=&quot;../data/dataset&quot;&gt; &lt;code&gt;tf.data.Dataset&lt;/code&gt; の&lt;/a&gt;インスタンスを、そして定期的なバッチ分割（すなわち再バッチインプット&lt;a href=&quot;../data/dataset&quot;&gt; &lt;code&gt;tf.data.Dataset&lt;/code&gt; の&lt;/a&gt;同期レプリカの数で割った世界的なバッチサイズに等しい新しいバッチサイズを持つインスタンス）および自動&lt;a href=&quot;../data/experimental/autoshardpolicy&quot;&gt; &lt;code&gt;tf.data.experimental.AutoShardPolicy&lt;/code&gt; &lt;/a&gt;（つまり、tf.data.experimental.AutoShardPolicyオプション）が機能します。以前のAPIを使用してください。それ以外の場合、正規を使用して&lt;em&gt;いない&lt;/em&gt;場合&lt;a href=&quot;../data/dataset&quot;&gt; &lt;code&gt;tf.data.Dataset&lt;/code&gt; &lt;/a&gt;インスタンス、またはバッチ分割またはシャーディングをカスタマイズする場合は、これらのロジックを &lt;code&gt;dataset_fn&lt;/code&gt; でラップし、後者のAPIを使用できます。どちらのAPIも、ユーザーのデバイスへのプリフェッチを処理します。詳細と例については、APIへのリンクをたどってください。</target>
        </trans-unit>
        <trans-unit id="6b8f13eb2103d67ac4feee46d41de0d462019931" translate="yes" xml:space="preserve">
          <source>There are two main usages of a &lt;code&gt;DistributedDataset&lt;/code&gt; object:</source>
          <target state="translated">&lt;code&gt;DistributedDataset&lt;/code&gt; オブジェクトの主な使用法は2つあります。</target>
        </trans-unit>
        <trans-unit id="3536015a851856ea989836d31de530e9b064da8c" translate="yes" xml:space="preserve">
          <source>There are two means to control the logging verbosity:</source>
          <target state="translated">ロギングの冗長性を制御する手段は2つあります。</target>
        </trans-unit>
        <trans-unit id="93dc11cfab5744c0fd203945e6587a775aa790bd" translate="yes" xml:space="preserve">
          <source>There are two modes under which the &lt;code&gt;TPUEmbedding&lt;/code&gt; class can used. This depends on if the class was created under a &lt;code&gt;TPUStrategy&lt;/code&gt; scope or not.</source>
          <target state="translated">&lt;code&gt;TPUEmbedding&lt;/code&gt; クラスを使用できるモードは2つあります。これは、クラスが &lt;code&gt;TPUStrategy&lt;/code&gt; スコープで作成されたかどうかによって異なります。</target>
        </trans-unit>
        <trans-unit id="cfe77a90ab442852a7e0e410775f1f4aa154097a" translate="yes" xml:space="preserve">
          <source>There are two possible return values, &quot;google&quot; (when TensorFlow is running in a Google-internal environment) or an empty string (when TensorFlow is running elsewhere).</source>
          <target state="translated">戻り値には、&quot;google&quot;(TensorFlowがGoogle内部の環境で実行されている場合)と空文字列(TensorFlowが他の場所で実行されている場合)の2つの可能性があります。</target>
        </trans-unit>
        <trans-unit id="c121ae8dd46f0cedd4d9939e53220e70d1795c85" translate="yes" xml:space="preserve">
          <source>There are two questions to ask in the decision process: Do you need gradients computed as sparse too? Is your sparse data represented as two &lt;code&gt;SparseTensor&lt;/code&gt;s: ids and values? There is more explanation about data format below. If you answer any of these questions as yes, consider using &lt;a href=&quot;../nn/embedding_lookup_sparse&quot;&gt;&lt;code&gt;tf.nn.embedding_lookup_sparse&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">決定プロセスで尋ねる2つの質問があります。スパースとして計算される勾配も必要ですか？スパースデータは、IDと値の2つの &lt;code&gt;SparseTensor&lt;/code&gt; として表されていますか？データ形式については、以下で詳しく説明します。これらの質問のいずれかに「はい」と答えた場合は、&lt;a href=&quot;../nn/embedding_lookup_sparse&quot;&gt; &lt;code&gt;tf.nn.embedding_lookup_sparse&lt;/code&gt; の&lt;/a&gt;使用を検討してください。</target>
        </trans-unit>
        <trans-unit id="0878716bd35f31f600ff16927cc66d2e1bdcca8d" translate="yes" xml:space="preserve">
          <source>There are two variants of the GRU implementation. The default one is based on &lt;a href=&quot;https://arxiv.org/abs/1406.1078v3&quot;&gt;v3&lt;/a&gt; and has reset gate applied to hidden state before matrix multiplication. The other one is based on &lt;a href=&quot;https://arxiv.org/abs/1406.1078v1&quot;&gt;original&lt;/a&gt; and has the order reversed.</source>
          <target state="translated">GRU実装には2つのバリアントがあります。デフォルトは&lt;a href=&quot;https://arxiv.org/abs/1406.1078v3&quot;&gt;v3に&lt;/a&gt;基づいており、行列乗算の前に非表示状態にリセットゲートが適用されています。もう1つは&lt;a href=&quot;https://arxiv.org/abs/1406.1078v1&quot;&gt;オリジナルに&lt;/a&gt;基づいており、順序が逆になっています。</target>
        </trans-unit>
        <trans-unit id="f3d0da97f844d09b6bac8339000119f443c41934" translate="yes" xml:space="preserve">
          <source>There are two variants. The default one is based on 1406.1078v3 and has reset gate applied to hidden state before matrix multiplication. The other one is based on original 1406.1078v1 and has the order reversed.</source>
          <target state="translated">2 つのバリエーションがあります。デフォルトのものは 1406.1078v3 に基づいており、行列の乗算の前に隠れた状態にリセットゲートが適用されます。もう一つはオリジナルの 1406.1078v1 に基づいており、順序が逆になっています。</target>
        </trans-unit>
        <trans-unit id="f1e5ef8034bae35c3455bef5218f7a32bbdb1aa7" translate="yes" xml:space="preserve">
          <source>There are two versions of the API: 1 or 2.</source>
          <target state="translated">APIには1と2の2種類のバージョンがあります。</target>
        </trans-unit>
        <trans-unit id="19c11322b50f362088a37650ccaf3b2e479b115a" translate="yes" xml:space="preserve">
          <source>There are two versions of the API: ExportSavedModelApiVersion.V1 and V2.</source>
          <target state="translated">APIには2つのバージョンがあります。ExportSavedModelApiVersion.V1とV2です。</target>
        </trans-unit>
        <trans-unit id="c409af06e5c37c31d5d6e63ae53409968bb739b2" translate="yes" xml:space="preserve">
          <source>There are two ways to create decorators that TensorFlow can introspect into. This is important for documentation generation purposes, so that function signatures aren't obscured by the (*args, **kwds) signature that decorators often provide.</source>
          <target state="translated">TensorFlowがイントロスペクトできるデコレータを作成するには、2つの方法があります。これは、関数のシグネチャがデコレータがよく提供する(*args,**kwds)シグネチャによって不明瞭にならないように、ドキュメントを生成する目的で重要です。</target>
        </trans-unit>
        <trans-unit id="49196c8dfb0588201d8b9733a14917623170a741" translate="yes" xml:space="preserve">
          <source>There are two ways to instantiate a &lt;code&gt;Model&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;Model&lt;/code&gt; をインスタンス化するには2つの方法があります。</target>
        </trans-unit>
        <trans-unit id="a3e498654dcff830e5be467e55fbbbbc20e2910f" translate="yes" xml:space="preserve">
          <source>There are two ways to use the moving averages for evaluations:</source>
          <target state="translated">移動平均線を評価に使う方法は2つあります。</target>
        </trans-unit>
        <trans-unit id="14b50269ad70f1441184d03f5b9e983ae0e09462" translate="yes" xml:space="preserve">
          <source>There is a special node with &lt;code&gt;task_type&lt;/code&gt; as &lt;code&gt;evaluator&lt;/code&gt;, which is not part of the (training) &lt;code&gt;cluster_spec&lt;/code&gt;. It handles the distributed evaluation job.</source>
          <target state="translated">特別なノードがある &lt;code&gt;task_type&lt;/code&gt; として &lt;code&gt;evaluator&lt;/code&gt; （トレーニング）の一部ではない、 &lt;code&gt;cluster_spec&lt;/code&gt; は。分散評価ジョブを処理します。</target>
        </trans-unit>
        <trans-unit id="ff5a342ad76b4f6dbc02bde4742c1939d0847ee4" translate="yes" xml:space="preserve">
          <source>There is also a global generator:</source>
          <target state="translated">グローバルジェネレーターもあります。</target>
        </trans-unit>
        <trans-unit id="c0a273890eb3544a6c0002e05e862f10bbfd245d" translate="yes" xml:space="preserve">
          <source>There is an equivalent description in terms of the [batch] spectrum &lt;code&gt;H&lt;/code&gt; and Fourier transforms. Here we consider &lt;code&gt;A.shape = [N, N]&lt;/code&gt; and ignore batch dimensions.</source>
          <target state="translated">[バッチ]スペクトル &lt;code&gt;H&lt;/code&gt; およびフーリエ変換に関して同等の説明があります。ここでは、 &lt;code&gt;A.shape = [N, N]&lt;/code&gt; を考慮し、バッチディメンションを無視します。</target>
        </trans-unit>
        <trans-unit id="34b53209d83711d378deaa8b481a2f90355eb0e3" translate="yes" xml:space="preserve">
          <source>There is an equivalent description in terms of the [batch] spectrum &lt;code&gt;H&lt;/code&gt; and Fourier transforms. Here we consider &lt;code&gt;A.shape = [N, N]&lt;/code&gt; and ignore batch dimensions. Define the discrete Fourier transform (DFT) and its inverse by</source>
          <target state="translated">[バッチ]スペクトル &lt;code&gt;H&lt;/code&gt; およびフーリエ変換に関して同等の説明があります。ここでは、 &lt;code&gt;A.shape = [N, N]&lt;/code&gt; を考慮し、バッチディメンションを無視します。離散フーリエ変換（DFT）とその逆を次のように定義します。</target>
        </trans-unit>
        <trans-unit id="70db84bf8987013d7aeb820bf2eec70af7a073ca" translate="yes" xml:space="preserve">
          <source>There is no need to delete the directory after the test.</source>
          <target state="translated">テスト後にディレクトリを削除する必要はありません。</target>
        </trans-unit>
        <trans-unit id="897a9d5198f512dcaeb305f37bd31486ee120960" translate="yes" xml:space="preserve">
          <source>There is no transformation in the &lt;a href=&quot;../data&quot;&gt;&lt;code&gt;tf.data&lt;/code&gt;&lt;/a&gt; Python API for creating this dataset. Instead, it is created as a result of the &lt;code&gt;filter_with_random_uniform_fusion&lt;/code&gt; static optimization. Whether this optimization is performed is determined by the &lt;code&gt;experimental_optimization.filter_with_random_uniform_fusion&lt;/code&gt; option of &lt;a href=&quot;../data/options&quot;&gt;&lt;code&gt;tf.data.Options&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">このデータセットを作成するための&lt;a href=&quot;../data&quot;&gt; &lt;code&gt;tf.data&lt;/code&gt; PythonAPIに&lt;/a&gt;は変換はありません。代わりに、 &lt;code&gt;filter_with_random_uniform_fusion&lt;/code&gt; 静的最適化の結果として作成されます。この最適化が実行されるかどうかは、&lt;a href=&quot;../data/options&quot;&gt; &lt;code&gt;tf.data.Options&lt;/code&gt; の&lt;/a&gt; &lt;code&gt;experimental_optimization.filter_with_random_uniform_fusion&lt;/code&gt; オプションによって決定されます。</target>
        </trans-unit>
        <trans-unit id="b246461630b3c81ed498d37ca7dc4b93263133aa" translate="yes" xml:space="preserve">
          <source>There is often a need to lift variable initialization ops out of control-flow scopes, function-building graphs, and gradient tapes. Entering an &lt;code&gt;init_scope&lt;/code&gt; is a mechanism for satisfying these desiderata. In particular, entering an &lt;code&gt;init_scope&lt;/code&gt; has three effects:</source>
          <target state="translated">変数初期化操作を制御フロースコープ、関数作成グラフ、および勾配テープから外す必要があることがよくあります。 &lt;code&gt;init_scope&lt;/code&gt; に入るのは、これらの願望を満たすためのメカニズムです。特に、 &lt;code&gt;init_scope&lt;/code&gt; を入力すると、3つの影響があります。</target>
        </trans-unit>
        <trans-unit id="9600bed3adf3351d3b6785f43a000c7d51f5ddee" translate="yes" xml:space="preserve">
          <source>There is one exception: if the final (i.e., innermost) element(s) of &lt;code&gt;partitions&lt;/code&gt; are &lt;code&gt;UniformRowLength&lt;/code&gt;s, then the values are simply reshaped (as a higher-dimensional &lt;a href=&quot;../tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt;), rather than being wrapped in a &lt;a href=&quot;../raggedtensor&quot;&gt;&lt;code&gt;tf.RaggedTensor&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">一つの例外がある：最終的な（すなわち、最も内側の）要素（複数可）場合は &lt;code&gt;partitions&lt;/code&gt; ある &lt;code&gt;UniformRowLength&lt;/code&gt; S、これらの値は単純に（より高い次元のように整形さ&lt;a href=&quot;../tensor&quot;&gt; &lt;code&gt;tf.Tensor&lt;/code&gt; &lt;/a&gt;むしろに包まれているよりも、）&lt;a href=&quot;../raggedtensor&quot;&gt; &lt;code&gt;tf.RaggedTensor&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b0e762e9fe47e7a8aaa65fed7f11b0b738414c89" translate="yes" xml:space="preserve">
          <source>There should be no data dependency between the different semantic invocations of &lt;code&gt;fn&lt;/code&gt;, i.e. it should be safe to map the elements of the inputs in any order.</source>
          <target state="translated">&lt;code&gt;fn&lt;/code&gt; の異なるセマンティック呼び出しの間にデータ依存関係があってはなりません。つまり、入力の要素を任意の順序でマップしても安全である必要があります。</target>
        </trans-unit>
        <trans-unit id="69f7128e30301479f7dbfc0ac8f483f3d6d00a4d" translate="yes" xml:space="preserve">
          <source>Therefore we introduce some decoupling using a queue. The queue contains the work units and the Reader dequeues from the queue when it is asked to produce a record (via Read()) but it has finished the last work unit.</source>
          <target state="translated">そこで、キューを用いたデカップリングを導入します。キューには作業単位が格納されており、リーダはレコードの生成を要求されたとき (Read()を介して)最後の作業単位を終了したときに、キューからキューイングを解除します。</target>
        </trans-unit>
        <trans-unit id="86cd25893d67c9049a975fb7c203728b1fcc6c8b" translate="yes" xml:space="preserve">
          <source>These are arguments passed to the optimizer subclass constructor (the &lt;code&gt;__init__&lt;/code&gt; method), and then passed to &lt;code&gt;self._set_hyper()&lt;/code&gt;. They can be either regular Python values (like 1.0), tensors, or callables. If they are callable, the callable will be called during &lt;code&gt;apply_gradients()&lt;/code&gt; to get the value for the hyper parameter.</source>
          <target state="translated">これらは、オプティマイザーサブクラスコンストラクター（ &lt;code&gt;__init__&lt;/code&gt; メソッド）に渡され、次に &lt;code&gt;self._set_hyper()&lt;/code&gt; に渡される引数です。通常のPython値（1.0など）、テンソル、または呼び出し可能変数のいずれかです。それらが呼び出し可能であれば、 &lt;code&gt;apply_gradients()&lt;/code&gt; 間に呼び出され、ハイパーパラメーターの値を取得します。</target>
        </trans-unit>
        <trans-unit id="d1eefae8eebd09f04dd361373c7c577f0cf1144d" translate="yes" xml:space="preserve">
          <source>These conversion options are experimental. They are subject to change without notice and offer no guarantees.</source>
          <target state="translated">これらの変換オプションは実験的なものです。これらは予告なく変更されることがあり、保証するものではありません。</target>
        </trans-unit>
        <trans-unit id="c291964ed47da0b87e8a53387f07ca95b28e890c" translate="yes" xml:space="preserve">
          <source>These indices specify where the values for each row begin in &lt;code&gt;self.values&lt;/code&gt;. &lt;code&gt;rt.row_starts()&lt;/code&gt; is equal to &lt;code&gt;rt.row_splits[:-1]&lt;/code&gt;.</source>
          <target state="translated">これらのインデックスは、各行の値が &lt;code&gt;self.values&lt;/code&gt; で始まる場所を指定します。 &lt;code&gt;rt.row_starts()&lt;/code&gt; は &lt;code&gt;rt.row_splits[:-1]&lt;/code&gt; と同じです。</target>
        </trans-unit>
        <trans-unit id="99b0058dc30c77b214aebabddab907af2da4a216" translate="yes" xml:space="preserve">
          <source>These indices specify where the values for each row end in &lt;code&gt;self.values&lt;/code&gt;. &lt;code&gt;rt.row_limits(self)&lt;/code&gt; is equal to &lt;code&gt;rt.row_splits[:-1]&lt;/code&gt;.</source>
          <target state="translated">これらのインデックスは、各行の値が &lt;code&gt;self.values&lt;/code&gt; で終わる場所を指定します。 &lt;code&gt;rt.row_limits(self)&lt;/code&gt; は &lt;code&gt;rt.row_splits[:-1]&lt;/code&gt; と同じです。</target>
        </trans-unit>
        <trans-unit id="23fdcaa94183d818b1595f88d3e5484cc7528a37" translate="yes" xml:space="preserve">
          <source>These layers expose 3 keyword arguments:</source>
          <target state="translated">これらのレイヤーは、3つのキーワード引数を公開しています。</target>
        </trans-unit>
        <trans-unit id="76c2c66d43654cd0b29da8b2ca646058c82ed16b" translate="yes" xml:space="preserve">
          <source>These might be stored sparsely in the following Example protos by storing only the feature ids (column number if the vectors are treated as a matrix) of the non-zero elements and the corresponding values:</source>
          <target state="translated">これらは,以下の例題では,ゼロではない要素の特徴ID(ベクトルを行列として扱う場合は列番号)とそれに対応する値のみを格納することで,まばらに格納されているかもしれません.</target>
        </trans-unit>
        <trans-unit id="e47f03b2a63c4e509a81c6c7d3f37f7d1be1a857" translate="yes" xml:space="preserve">
          <source>These sufficient statistics are computed using the one pass algorithm on an input that's optionally shifted. See: &lt;a href=&quot;https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance#Computing_shifted_data&quot;&gt;https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance#Computing_shifted_data&lt;/a&gt;</source>
          <target state="translated">これらの十分統計量は、オプションでシフトされた入力に対してワンパスアルゴリズムを使用して計算されます。参照：&lt;a href=&quot;https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance#Computing_shifted_data&quot;&gt;https&lt;/a&gt;：//en.wikipedia.org/wiki/Algorithms_for_calculating_variance#Computing_shifted_data</target>
        </trans-unit>
        <trans-unit id="df0616278e0670c1f8a838c05616c2906a5ad628" translate="yes" xml:space="preserve">
          <source>These sufficient statistics are computed using the one pass algorithm on an input that's optionally shifted. See: https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance#Computing_shifted_data</source>
          <target state="translated">これらの十分な統計量は、オプションでシフトされた入力に対してワンパスアルゴリズムを用いて計算されます。参照:https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance#Computing_shifted_data</target>
        </trans-unit>
        <trans-unit id="5c983cdacd0a0593413a5e4ab438ec1b6414a3f5" translate="yes" xml:space="preserve">
          <source>These typically correspond to model heads.</source>
          <target state="translated">これらは通常、モデルヘッドに対応しています。</target>
        </trans-unit>
        <trans-unit id="a2e13849b656ad081d144e8fb21e76af2be31973" translate="yes" xml:space="preserve">
          <source>These values are similar to values from a &lt;code&gt;random_normal_initializer&lt;/code&gt; except that values more than two standard deviations from the mean are discarded and re-drawn. This is the recommended initializer for neural network weights and filters.</source>
          <target state="translated">これらの値は、 &lt;code&gt;random_normal_initializer&lt;/code&gt; からの値に似ていますが、平均からの標準偏差が2つを超える値は破棄され、再描画されます。これは、ニューラルネットワークの重みとフィルターに推奨される初期化子です。</target>
        </trans-unit>
        <trans-unit id="6f69d15ae681fb68548cb2f0cf5da97b8f2f416c" translate="yes" xml:space="preserve">
          <source>They are not resettable. Once a one-shot iterator reaches the end of its underlying dataset, subsequent &quot;IteratorGetNext&quot; operations on that iterator will always produce an &lt;code&gt;OutOfRange&lt;/code&gt; error.</source>
          <target state="translated">それらはリセット可能ではありません。ワンショットイテレータが基になるデータセットの最後に到達すると、そのイテレータに対する後続の「IteratorGetNext」操作は常に &lt;code&gt;OutOfRange&lt;/code&gt; エラーを生成します。</target>
        </trans-unit>
        <trans-unit id="82a7de6a736dfa8a46716669d941754c78b26714" translate="yes" xml:space="preserve">
          <source>They do not support parameterization: all logic for creating the underlying dataset must be bundled in the &lt;code&gt;dataset_factory&lt;/code&gt; function.</source>
          <target state="translated">これらはパラメーター化をサポートしていません。基になるデータセットを作成するためのすべてのロジックは、 &lt;code&gt;dataset_factory&lt;/code&gt; 関数にバンドルされている必要があります。</target>
        </trans-unit>
        <trans-unit id="035fa9e40dd64ae60fe7c5634de4cc5ea73a82db" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;LinearOperator&lt;/code&gt; is initialized to have shape &lt;code&gt;[B1,...,Bb, N, N]&lt;/code&gt; by providing &lt;code&gt;spectrum&lt;/code&gt;, a &lt;code&gt;[B1,...,Bb, N0, N1, N2]&lt;/code&gt;&lt;code&gt;Tensor&lt;/code&gt; with &lt;code&gt;N0*N1*N2 = N&lt;/code&gt;.</source>
          <target state="translated">この &lt;code&gt;LinearOperator&lt;/code&gt; は &lt;code&gt;[B1,...,Bb, N, N]&lt;/code&gt; &lt;code&gt;spectrum&lt;/code&gt; 、 &lt;code&gt;[B1,...,Bb, N0, N1, N2]&lt;/code&gt; &lt;code&gt;Tensor&lt;/code&gt; を &lt;code&gt;N0*N1*N2 = N&lt;/code&gt; 提供することにより、形状[B1、...、Bb、N、N]を持つように初期化されます。</target>
        </trans-unit>
        <trans-unit id="7dc76893f409505eb4af8e3ca9d9b50f0907d32c" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;LinearOperator&lt;/code&gt; is initialized to have shape &lt;code&gt;[B1,...,Bb, N, N]&lt;/code&gt; by providing &lt;code&gt;spectrum&lt;/code&gt;, a &lt;code&gt;[B1,...,Bb, N0, N1]&lt;/code&gt;&lt;code&gt;Tensor&lt;/code&gt; with &lt;code&gt;N0*N1 = N&lt;/code&gt;.</source>
          <target state="translated">この &lt;code&gt;LinearOperator&lt;/code&gt; は &lt;code&gt;[B1,...,Bb, N, N]&lt;/code&gt; &lt;code&gt;spectrum&lt;/code&gt; 、 &lt;code&gt;[B1,...,Bb, N0, N1]&lt;/code&gt; &lt;code&gt;Tensor&lt;/code&gt; を &lt;code&gt;N0*N1 = N&lt;/code&gt; 提供することにより、形状[B1、...、Bb、N、N]を持つように初期化されます。</target>
        </trans-unit>
        <trans-unit id="45faa2260146699c38e2dafd91d1b8425180a30a" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;LinearOperator&lt;/code&gt; is initialized to have shape &lt;code&gt;[B1,...,Bb, N, N]&lt;/code&gt; by providing &lt;code&gt;spectrum&lt;/code&gt;, a &lt;code&gt;[B1,...,Bb, N]&lt;/code&gt;&lt;code&gt;Tensor&lt;/code&gt;.</source>
          <target state="translated">この &lt;code&gt;LinearOperator&lt;/code&gt; は &lt;code&gt;[B1,...,Bb, N, N]&lt;/code&gt; &lt;code&gt;spectrum&lt;/code&gt; 、 &lt;code&gt;[B1,...,Bb, N]&lt;/code&gt; &lt;code&gt;Tensor&lt;/code&gt; を提供することにより、形状[B1、...、Bb、N、N]を持つように初期化されます。</target>
        </trans-unit>
        <trans-unit id="14d38c8190663bcf5aee0e569e1c9fa815f97d9a" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;LinearOperator&lt;/code&gt; is initialized with boolean flags of the form &lt;code&gt;is_X&lt;/code&gt;, for &lt;code&gt;X = non_singular, self_adjoint, positive_definite, square&lt;/code&gt;. These have the following meaning</source>
          <target state="translated">この &lt;code&gt;LinearOperator&lt;/code&gt; は、フォームのブールフラグで初期化され &lt;code&gt;is_X&lt;/code&gt; のために、 &lt;code&gt;X = non_singular, self_adjoint, positive_definite, square&lt;/code&gt; 。これらの意味は次のとおりです</target>
        </trans-unit>
        <trans-unit id="59e2aeacdf121218eb0206f7223d277271e20ff4" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;LinearOperator&lt;/code&gt; is initialized with boolean flags of the form &lt;code&gt;is_X&lt;/code&gt;, for &lt;code&gt;X = non_singular, self_adjoint, positive_definite, square&lt;/code&gt;. These have the following meaning:</source>
          <target state="translated">この &lt;code&gt;LinearOperator&lt;/code&gt; は、フォームのブールフラグで初期化され &lt;code&gt;is_X&lt;/code&gt; のために、 &lt;code&gt;X = non_singular, self_adjoint, positive_definite, square&lt;/code&gt; 。これらの意味は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="c893a77a5cadc49b62c18f0fba68970cb1dcbaf6" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;LinearOperator&lt;/code&gt; is initialized with boolean flags of the form &lt;code&gt;is_X&lt;/code&gt;, for &lt;code&gt;X = non_singular&lt;/code&gt;, &lt;code&gt;self_adjoint&lt;/code&gt;, &lt;code&gt;positive_definite&lt;/code&gt;, &lt;code&gt;diag_update_positive&lt;/code&gt; and &lt;code&gt;square&lt;/code&gt;. These have the following meaning:</source>
          <target state="translated">この &lt;code&gt;LinearOperator&lt;/code&gt; は、フォームのブールフラグで初期化される &lt;code&gt;is_X&lt;/code&gt; ため、 &lt;code&gt;X = non_singular&lt;/code&gt; 、 &lt;code&gt;self_adjoint&lt;/code&gt; 、 &lt;code&gt;positive_definite&lt;/code&gt; 、 &lt;code&gt;diag_update_positive&lt;/code&gt; および &lt;code&gt;square&lt;/code&gt; 。これらの意味は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="1af767d14077ff11d4e7fc9b014e22bbf1d448de" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;Model&lt;/code&gt; has a dependency named &quot;input_transform&quot; on its &lt;code&gt;Dense&lt;/code&gt; layer, which in turn depends on its variables. As a result, saving an instance of &lt;code&gt;Regress&lt;/code&gt; using &lt;a href=&quot;../../../train/checkpoint&quot;&gt;&lt;code&gt;tf.train.Checkpoint&lt;/code&gt;&lt;/a&gt; will also save all the variables created by the &lt;code&gt;Dense&lt;/code&gt; layer.</source>
          <target state="translated">この &lt;code&gt;Model&lt;/code&gt; は、 &lt;code&gt;Dense&lt;/code&gt; レイヤーに「input_transform」という名前の依存関係があり、これは変数に依存しています。その結果、&lt;a href=&quot;../../../train/checkpoint&quot;&gt; &lt;code&gt;tf.train.Checkpoint&lt;/code&gt; &lt;/a&gt;を使用して &lt;code&gt;Regress&lt;/code&gt; のインスタンスを保存すると、 &lt;code&gt;Dense&lt;/code&gt; レイヤーによって作成されたすべての変数も保存されます。</target>
        </trans-unit>
        <trans-unit id="6bb0cfce4d3ef61c634cae7fd40aef46d6d26e65" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;Model&lt;/code&gt; has a dependency named &quot;input_transform&quot; on its &lt;code&gt;Dense&lt;/code&gt; layer, which in turn depends on its variables. As a result, saving an instance of &lt;code&gt;Regress&lt;/code&gt; using &lt;a href=&quot;checkpoint&quot;&gt;&lt;code&gt;tf.train.Checkpoint&lt;/code&gt;&lt;/a&gt; will also save all the variables created by the &lt;code&gt;Dense&lt;/code&gt; layer.</source>
          <target state="translated">この &lt;code&gt;Model&lt;/code&gt; は、 &lt;code&gt;Dense&lt;/code&gt; レイヤーに「input_transform」という名前の依存関係があり、これは変数に依存しています。その結果、&lt;a href=&quot;checkpoint&quot;&gt; &lt;code&gt;tf.train.Checkpoint&lt;/code&gt; &lt;/a&gt;を使用して &lt;code&gt;Regress&lt;/code&gt; のインスタンスを保存すると、 &lt;code&gt;Dense&lt;/code&gt; レイヤーによって作成されたすべての変数も保存されます。</target>
        </trans-unit>
        <trans-unit id="b5871012b5796b5a485fbd2ea90e6e96dc8a6361" translate="yes" xml:space="preserve">
          <source>This API allows querying the physical hardware resources prior to runtime initialization. Thus, giving an opportunity to call any additional configuration APIs. This is in contrast to &lt;a href=&quot;list_logical_devices&quot;&gt;&lt;code&gt;tf.config.list_logical_devices&lt;/code&gt;&lt;/a&gt;, which triggers runtime initialization in order to list the configured devices.</source>
          <target state="translated">このAPIを使用すると、ランタイムの初期化の前に物理ハードウェアリソースをクエリできます。したがって、追加の構成APIを呼び出す機会を提供します。これは、構成済みデバイスをリストするためにランタイム初期化をトリガーする&lt;a href=&quot;list_logical_devices&quot;&gt; &lt;code&gt;tf.config.list_logical_devices&lt;/code&gt; &lt;/a&gt;とは対照的です。</target>
        </trans-unit>
        <trans-unit id="74aac56e82063765baca7f72b6ef73462943063c" translate="yes" xml:space="preserve">
          <source>This API enables repeated preprocessing steps to be consolidated, and allows re-use of already processed data, trading off disk storage and network bandwidth for freeing up more valuable CPU resources and accelerator compute time.</source>
          <target state="translated">このAPIを使用することで、前処理を繰り返すステップを統合することができ、すでに処理済みのデータを再利用することができ、ディスクストレージとネットワーク帯域幅を削減して、より貴重なCPUリソースとアクセラレータの計算時間を解放します。</target>
        </trans-unit>
        <trans-unit id="762aea1a89e9b0e55d82633b7d3d567f5d2f187d" translate="yes" xml:space="preserve">
          <source>This API takes in a &lt;a href=&quot;../physicaldevice&quot;&gt;&lt;code&gt;tf.config.PhysicalDevice&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;../list_physical_devices&quot;&gt;&lt;code&gt;tf.config.list_physical_devices&lt;/code&gt;&lt;/a&gt;. It returns a dict with string keys containing various details about the device. Each key is only supported by a subset of devices, so you should not assume the returned dict will have any particular key.</source>
          <target state="translated">このAPIは、&lt;a href=&quot;../physicaldevice&quot;&gt; &lt;code&gt;tf.config.PhysicalDevice&lt;/code&gt; &lt;/a&gt;によって返される&lt;a href=&quot;../list_physical_devices&quot;&gt; &lt;code&gt;tf.config.list_physical_devices&lt;/code&gt; &lt;/a&gt;ます。デバイスに関するさまざまな詳細を含む文字列キーを含むdictを返します。各キーはデバイスのサブセットでのみサポートされているため、返されたdictに特定のキーがあると想定しないでください。</target>
        </trans-unit>
        <trans-unit id="22207bc9bfb65faecbe8df80de09b7c7ff71edfd" translate="yes" xml:space="preserve">
          <source>This API will connect to remote TPU cluster and initialize the TPU hardwares. Example usage:</source>
          <target state="translated">このAPIはリモートTPUクラスタに接続し、TPUのハードウェアを初期化します。使用例。</target>
        </trans-unit>
        <trans-unit id="fb9102764cadc1d75fc4b0e80481d3d9ed63d68c" translate="yes" xml:space="preserve">
          <source>This Estimator implements the following variants of the K-means algorithm:</source>
          <target state="translated">このEstimatorは、K-meansアルゴリズムの以下のバリエーションを実装しています。</target>
        </trans-unit>
        <trans-unit id="80c1b7fb2eecacd5d699b9ee230de5704ca37c8d" translate="yes" xml:space="preserve">
          <source>This Multinomial distribution is parameterized by &lt;code&gt;probs&lt;/code&gt;, a (batch of) length-&lt;code&gt;K&lt;/code&gt;&lt;code&gt;prob&lt;/code&gt; (probability) vectors (&lt;code&gt;K &amp;gt; 1&lt;/code&gt;) such that &lt;code&gt;tf.reduce_sum(probs, -1) = 1&lt;/code&gt;, and a &lt;code&gt;total_count&lt;/code&gt; number of trials, i.e., the number of trials per draw from the Multinomial. It is defined over a (batch of) length-&lt;code&gt;K&lt;/code&gt; vector &lt;code&gt;counts&lt;/code&gt; such that &lt;code&gt;tf.reduce_sum(counts, -1) = total_count&lt;/code&gt;. The Multinomial is identically the Binomial distribution when &lt;code&gt;K = 2&lt;/code&gt;.</source>
          <target state="translated">この多項分布によってパラメータ化され &lt;code&gt;probs&lt;/code&gt; 、長さ- （バッチ） &lt;code&gt;K&lt;/code&gt; の &lt;code&gt;prob&lt;/code&gt; （確率）ベクター（ &lt;code&gt;K &amp;gt; 1&lt;/code&gt; ）ように &lt;code&gt;tf.reduce_sum(probs, -1) = 1&lt;/code&gt; 、および &lt;code&gt;total_count&lt;/code&gt; 試行回数、すなわち、多項式からのドローごとの試行回数。これは、 &lt;code&gt;tf.reduce_sum(counts, -1) = total_count&lt;/code&gt; ような、長さ &lt;code&gt;K&lt;/code&gt; のベクトル &lt;code&gt;counts&lt;/code&gt; （のバッチ）で定義されます。 &lt;code&gt;K = 2&lt;/code&gt; 場合、多項式は二項分布と同じです。</target>
        </trans-unit>
        <trans-unit id="61586b843c2a7242a7ce5f726a415d728d094add" translate="yes" xml:space="preserve">
          <source>This Op also supports repeated indices in the output subscript, which is not supported by &lt;code&gt;numpy.einsum&lt;/code&gt;.</source>
          <target state="translated">このOpは、 &lt;code&gt;numpy.einsum&lt;/code&gt; ではサポートされていない出力添え字の繰り返しインデックスもサポートします。</target>
        </trans-unit>
        <trans-unit id="d0c42e63acc7dcc7eea605a766b11674d1c53e82" translate="yes" xml:space="preserve">
          <source>This Op checks that &lt;code&gt;x[i] != y[i]&lt;/code&gt; holds for every pair of (possibly broadcast) elements of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;. If both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are empty, this is trivially satisfied.</source>
          <target state="translated">このOpは、 &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; の（ブロードキャストされる可能性のある）要素のすべてのペア &lt;code&gt;x[i] != y[i]&lt;/code&gt; が成り立つことを確認します。 &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; の両方が空の場合、これは簡単に満たされます。</target>
        </trans-unit>
        <trans-unit id="74ec1aa4f8491ea53037a0fc532d4741eb9218bd" translate="yes" xml:space="preserve">
          <source>This Op checks that &lt;code&gt;x[i] &amp;gt; 0&lt;/code&gt; holds for every element of &lt;code&gt;x&lt;/code&gt;. If &lt;code&gt;x&lt;/code&gt; is empty, this is trivially satisfied.</source>
          <target state="translated">このオペレーションをチェックすることを &lt;code&gt;x[i] &amp;gt; 0&lt;/code&gt; のすべての要素にも当てはまる &lt;code&gt;x&lt;/code&gt; 。 &lt;code&gt;x&lt;/code&gt; が空の場合、これは簡単に満たされます。</target>
        </trans-unit>
        <trans-unit id="64284c5803db04a210d1a9048bfe82459a849a9d" translate="yes" xml:space="preserve">
          <source>This Op checks that &lt;code&gt;x[i] &amp;gt; y[i]&lt;/code&gt; holds for every pair of (possibly broadcast) elements of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;. If both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are empty, this is trivially satisfied.</source>
          <target state="translated">このOpは、 &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; の（ブロードキャストされる可能性のある）要素のすべてのペアについて &lt;code&gt;x[i] &amp;gt; y[i]&lt;/code&gt; が成り立つことを確認します。 &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; の両方が空の場合、これは簡単に満たされます。</target>
        </trans-unit>
        <trans-unit id="382c384f5bde2874efffdf9480af145ba234b875" translate="yes" xml:space="preserve">
          <source>This Op checks that &lt;code&gt;x[i] &amp;gt;= 0&lt;/code&gt; holds for every element of &lt;code&gt;x&lt;/code&gt;. If &lt;code&gt;x&lt;/code&gt; is empty, this is trivially satisfied.</source>
          <target state="translated">このオペレーションをチェックすることを &lt;code&gt;x[i] &amp;gt;= 0&lt;/code&gt; のすべての要素にも当てはまる &lt;code&gt;x&lt;/code&gt; 。 &lt;code&gt;x&lt;/code&gt; が空の場合、これは簡単に満たされます。</target>
        </trans-unit>
        <trans-unit id="501dbba0dad9772b46dd6dbe6d32dfc34b3073e4" translate="yes" xml:space="preserve">
          <source>This Op checks that &lt;code&gt;x[i] &amp;gt;= y[i]&lt;/code&gt; holds for every pair of (possibly broadcast) elements of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;. If both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are empty, this is trivially satisfied.</source>
          <target state="translated">このOpは、 &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; の（ブロードキャストされる可能性のある）要素のすべてのペア &lt;code&gt;x[i] &amp;gt;= y[i]&lt;/code&gt; が保持されることを確認します。 &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; の両方が空の場合、これは簡単に満たされます。</target>
        </trans-unit>
        <trans-unit id="86a98c771b136d5122e127f8b045988c2c9039d5" translate="yes" xml:space="preserve">
          <source>This Op checks that &lt;code&gt;x[i] &amp;lt; 0&lt;/code&gt; holds for every element of &lt;code&gt;x&lt;/code&gt;. If &lt;code&gt;x&lt;/code&gt; is empty, this is trivially satisfied.</source>
          <target state="translated">このオペレーションをチェックすることを &lt;code&gt;x[i] &amp;lt; 0&lt;/code&gt; のすべての要素にも当てはまる &lt;code&gt;x&lt;/code&gt; 。 &lt;code&gt;x&lt;/code&gt; が空の場合、これは簡単に満たされます。</target>
        </trans-unit>
        <trans-unit id="a26f9f0c29e64714922c2bda7e956bffe84f5c0c" translate="yes" xml:space="preserve">
          <source>This Op checks that &lt;code&gt;x[i] &amp;lt; y[i]&lt;/code&gt; holds for every pair of (possibly broadcast) elements of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;. If both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are empty, this is trivially satisfied.</source>
          <target state="translated">このOpは、 &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; の（ブロードキャストされる可能性のある）要素のすべてのペアについて、 &lt;code&gt;x[i] &amp;lt; y[i]&lt;/code&gt; が成り立つことを確認します。 &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; の両方が空の場合、これは簡単に満たされます。</target>
        </trans-unit>
        <trans-unit id="c63795d0aad1b74648e6a4624d3ec74f6c7d4a1e" translate="yes" xml:space="preserve">
          <source>This Op checks that &lt;code&gt;x[i] &amp;lt;= 0&lt;/code&gt; holds for every element of &lt;code&gt;x&lt;/code&gt;. If &lt;code&gt;x&lt;/code&gt; is empty, this is trivially satisfied.</source>
          <target state="translated">このオペアンプチェックはそれが &lt;code&gt;x[i] &amp;lt;= 0&lt;/code&gt; のすべての要素にも当てはまる &lt;code&gt;x&lt;/code&gt; 。 &lt;code&gt;x&lt;/code&gt; が空の場合、これは簡単に満たされます。</target>
        </trans-unit>
        <trans-unit id="52d38297a91871d25885ecc0eb75b01217f176df" translate="yes" xml:space="preserve">
          <source>This Op checks that &lt;code&gt;x[i] &amp;lt;= y[i]&lt;/code&gt; holds for every pair of (possibly broadcast) elements of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;. If both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are empty, this is trivially satisfied.</source>
          <target state="translated">このOpは、 &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; の（ブロードキャストされる可能性のある）要素のすべてのペアについて、 &lt;code&gt;x[i] &amp;lt;= y[i]&lt;/code&gt; が成り立つことを確認します。 &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; の両方が空の場合、これは簡単に満たされます。</target>
        </trans-unit>
        <trans-unit id="a274dbd07debbab7fc4511fde87c45ce7dd5f11a" translate="yes" xml:space="preserve">
          <source>This Op checks that &lt;code&gt;x[i] - y[i] &amp;lt; atol + rtol * tf.abs(y[i])&lt;/code&gt; holds for every pair of (possibly broadcast) elements of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;. If both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are empty, this is trivially satisfied.</source>
          <target state="translated">このOpは、 &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; の（おそらくブロードキャストされる）要素のすべてのペアについて、 &lt;code&gt;x[i] - y[i] &amp;lt; atol + rtol * tf.abs(y[i])&lt;/code&gt; が保持されることを確認します。 &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; の両方が空の場合、これは簡単に満たされます。</target>
        </trans-unit>
        <trans-unit id="afe67f7444ede4a73d34ba9ae37a78f686f755dd" translate="yes" xml:space="preserve">
          <source>This Op checks that &lt;code&gt;x[i] == y[i]&lt;/code&gt; holds for every pair of (possibly broadcast) elements of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;. If both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are empty, this is trivially satisfied.</source>
          <target state="translated">このOpは、 &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; の（ブロードキャストされる可能性のある）要素のすべてのペア &lt;code&gt;x[i] == y[i]&lt;/code&gt; が成り立つことを確認します。 &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; の両方が空の場合、これは簡単に満たされます。</target>
        </trans-unit>
        <trans-unit id="47fcdf77a806254f145cef6045f72f7418b87096" translate="yes" xml:space="preserve">
          <source>This Op checks that a collection of tensors shape relationships satisfies given constraints.</source>
          <target state="translated">この操作は、テンソルの形状関係の集合が与えられた制約を満たすかどうかをチェックします。</target>
        </trans-unit>
        <trans-unit id="70d8b32973294baa04c2b6c2343f69d0d35b251b" translate="yes" xml:space="preserve">
          <source>This Op checks that the rank of &lt;code&gt;x&lt;/code&gt; is equal to &lt;code&gt;rank&lt;/code&gt;.</source>
          <target state="translated">このオペアンプチェックのランクこと &lt;code&gt;x&lt;/code&gt; に等しい &lt;code&gt;rank&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="45bf526016d2ed135926c16509b05dd90dd8b920" translate="yes" xml:space="preserve">
          <source>This Op checks that the rank of &lt;code&gt;x&lt;/code&gt; is greater or equal to &lt;code&gt;rank&lt;/code&gt;.</source>
          <target state="translated">ランク、このオペアンプチェック &lt;code&gt;x&lt;/code&gt; が大きいかと等しい &lt;code&gt;rank&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ef8abcb7ef7c82e56e48acf10aee7a915b661e8e" translate="yes" xml:space="preserve">
          <source>This Op checks that the rank of &lt;code&gt;x&lt;/code&gt; is in &lt;code&gt;ranks&lt;/code&gt;.</source>
          <target state="translated">このOpは、 &lt;code&gt;x&lt;/code&gt; のランクがrankにあることを確認し &lt;code&gt;ranks&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9bbbc71838cec9daa4b798c766e634988ae8eda0" translate="yes" xml:space="preserve">
          <source>This Op does not require &lt;code&gt;a_indices&lt;/code&gt; be sorted in standard lexicographic order.</source>
          <target state="translated">この &lt;code&gt;a_indices&lt;/code&gt; では、a_indicesを標準の辞書式順序でソートする必要はありません。</target>
        </trans-unit>
        <trans-unit id="995662dbb5ee7bd63655bfa102038ae50bbbb546" translate="yes" xml:space="preserve">
          <source>This Op does not support implicit form. (i.e. equations without &lt;code&gt;-&amp;gt;&lt;/code&gt;).</source>
          <target state="translated">このOpは暗黙的な形式をサポートしていません。（つまり、 &lt;code&gt;-&amp;gt;&lt;/code&gt; のない方程式）。</target>
        </trans-unit>
        <trans-unit id="b037dc8de7a8b2184874f7694988339f20126019" translate="yes" xml:space="preserve">
          <source>This Op eases the porting of code that uses embedding_lookup_sparse(), although some Python preprocessing of the SparseTensor arguments to embedding_lookup_sparse() is required to produce the arguments to this Op, since only a single EnqueueTPUEmbeddingSparseBatch Op is allowed per training step.</source>
          <target state="translated">この操作は embedding_lookup_sparse()を使用するコードの移植を容易にしますが、この操作の引数を生成するためには embedding_lookup_sparse()への SparseTensor 引数の Python の前処理が必要になります。</target>
        </trans-unit>
        <trans-unit id="b3230f00e0154436022761e6b1f967d770055298" translate="yes" xml:space="preserve">
          <source>This Op first attempts to find the V2 index file pointed to by &quot;prefix&quot;, and if found proceed to read it as a V2 checkpoint;</source>
          <target state="translated">この操作では、まず &quot;prefix &quot;が指すV2インデックスファイルを見つけようとし、見つかった場合にはV2チェックポイントとして読み込んでいきます。</target>
        </trans-unit>
        <trans-unit id="1ed5e982672256e8ea90d7bd0d72e83dbb1172c0" translate="yes" xml:space="preserve">
          <source>This Op only supports unary and binary forms of &lt;code&gt;numpy.einsum&lt;/code&gt;.</source>
          <target state="translated">このOpは、 &lt;code&gt;numpy.einsum&lt;/code&gt; の単項形式とバイナリ形式のみをサポートします。</target>
        </trans-unit>
        <trans-unit id="793a60433b6712b8062346cc2fb3747282971aed" translate="yes" xml:space="preserve">
          <source>This Op picks a random location in &lt;code&gt;image&lt;/code&gt; and crops a &lt;code&gt;height&lt;/code&gt; by &lt;code&gt;width&lt;/code&gt; rectangle from that location. The random location is picked so the cropped area will fit inside the original image.</source>
          <target state="translated">このオペアンプはランダム場所を選び &lt;code&gt;image&lt;/code&gt; 作物 &lt;code&gt;height&lt;/code&gt; によって &lt;code&gt;width&lt;/code&gt; その位置から矩形を。トリミングされた領域が元の画像内に収まるように、ランダムな場所が選択されます。</target>
        </trans-unit>
        <trans-unit id="214a679e138acba179edb8672f1201325c1e87b6" translate="yes" xml:space="preserve">
          <source>This Op produces a set of TPU cores (for warm-up) or a single TPU core (for regular inference) to execute the TPU program on. The output is consumed by TPUPartitionedCall.</source>
          <target state="translated">この操作は、TPU プログラムを実行するための TPU コアのセット(ウォームアップ用)または単一の TPU コア(通常の推論用)を生成します。出力は TPUPartitionedCall によって消費される。</target>
        </trans-unit>
        <trans-unit id="1956a13a2a0626040a0d05adca12d21c39b428f4" translate="yes" xml:space="preserve">
          <source>This Op takes a SparseTensor and is the sparse counterpart to &lt;a href=&quot;../../math/reduce_max&quot;&gt;&lt;code&gt;tf.reduce_max()&lt;/code&gt;&lt;/a&gt;. In contrast to SparseReduceSum, this Op returns a SparseTensor.</source>
          <target state="translated">このOpはSparseTensorを取り、&lt;a href=&quot;../../math/reduce_max&quot;&gt; &lt;code&gt;tf.reduce_max()&lt;/code&gt; の&lt;/a&gt;疎な対応物です。SparseReduceSumとは対照的に、このOpはSparseTensorを返します。</target>
        </trans-unit>
        <trans-unit id="21543202b1cccf9199ac85ba0b6367bb37a43438" translate="yes" xml:space="preserve">
          <source>This Op takes a SparseTensor and is the sparse counterpart to &lt;a href=&quot;../../math/reduce_max&quot;&gt;&lt;code&gt;tf.reduce_max()&lt;/code&gt;&lt;/a&gt;. In particular, this Op also returns a dense &lt;code&gt;Tensor&lt;/code&gt; instead of a sparse one.</source>
          <target state="translated">このOpはSparseTensorを取り、&lt;a href=&quot;../../math/reduce_max&quot;&gt; &lt;code&gt;tf.reduce_max()&lt;/code&gt; の&lt;/a&gt;疎な対応物です。特に、このOp はまばらな &lt;code&gt;Tensor&lt;/code&gt; ではなく、密なTensorも返します。</target>
        </trans-unit>
        <trans-unit id="a92cf7c266fad63ba2ede16d013a7954c0a3ed23" translate="yes" xml:space="preserve">
          <source>This Op takes a SparseTensor and is the sparse counterpart to &lt;a href=&quot;../../math/reduce_sum&quot;&gt;&lt;code&gt;tf.reduce_sum()&lt;/code&gt;&lt;/a&gt;. In contrast to SparseReduceSum, this Op returns a SparseTensor.</source>
          <target state="translated">このOpはSparseTensorを取り、&lt;a href=&quot;../../math/reduce_sum&quot;&gt; &lt;code&gt;tf.reduce_sum()&lt;/code&gt; の&lt;/a&gt;疎な対応物です。SparseReduceSumとは対照的に、このOpはSparseTensorを返します。</target>
        </trans-unit>
        <trans-unit id="eff3316c87e58a0e09844e295d654acad826f230" translate="yes" xml:space="preserve">
          <source>This Op takes a SparseTensor and is the sparse counterpart to &lt;a href=&quot;../../math/reduce_sum&quot;&gt;&lt;code&gt;tf.reduce_sum()&lt;/code&gt;&lt;/a&gt;. In particular, this Op also returns a dense &lt;code&gt;Tensor&lt;/code&gt; instead of a sparse one.</source>
          <target state="translated">このOpはSparseTensorを取り、&lt;a href=&quot;../../math/reduce_sum&quot;&gt; &lt;code&gt;tf.reduce_sum()&lt;/code&gt; の&lt;/a&gt;疎な対応物です。特に、このOp はまばらな &lt;code&gt;Tensor&lt;/code&gt; ではなく、密なTensorも返します。</target>
        </trans-unit>
        <trans-unit id="02bfe7eb6e17547c27337071dde6515aea09a633" translate="yes" xml:space="preserve">
          <source>This Op takes a SparseTensor and is the sparse counterpart to &lt;a href=&quot;../math/reduce_max&quot;&gt;&lt;code&gt;tf.reduce_max()&lt;/code&gt;&lt;/a&gt;. In contrast to SparseReduceMax, this Op returns a SparseTensor.</source>
          <target state="translated">このOpはSparseTensorを取り、&lt;a href=&quot;../math/reduce_max&quot;&gt; &lt;code&gt;tf.reduce_max()&lt;/code&gt; に&lt;/a&gt;対応するスパースです。SparseReduceMaxとは対照的に、このOpはSparseTensorを返します。</target>
        </trans-unit>
        <trans-unit id="7321159b3f380865d8a3ddbbd1ea9288e20a93c6" translate="yes" xml:space="preserve">
          <source>This Op takes a SparseTensor and is the sparse counterpart to &lt;a href=&quot;../math/reduce_max&quot;&gt;&lt;code&gt;tf.reduce_max()&lt;/code&gt;&lt;/a&gt;. In particular, this Op also returns a dense &lt;code&gt;Tensor&lt;/code&gt; if &lt;code&gt;output_is_sparse&lt;/code&gt; is &lt;code&gt;False&lt;/code&gt;, or a &lt;code&gt;SparseTensor&lt;/code&gt; if &lt;code&gt;output_is_sparse&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">このOpはSparseTensorを取り、&lt;a href=&quot;../math/reduce_max&quot;&gt; &lt;code&gt;tf.reduce_max()&lt;/code&gt; の&lt;/a&gt;疎な対応物です。特に、このオペアンプも密返し &lt;code&gt;Tensor&lt;/code&gt; 場合 &lt;code&gt;output_is_sparse&lt;/code&gt; がある &lt;code&gt;False&lt;/code&gt; 、または &lt;code&gt;SparseTensor&lt;/code&gt; 場合 &lt;code&gt;output_is_sparse&lt;/code&gt; がある &lt;code&gt;True&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b1103b246b6e1caad53d997c04c64c3898e6d3b5" translate="yes" xml:space="preserve">
          <source>This Op takes a SparseTensor and is the sparse counterpart to &lt;a href=&quot;../math/reduce_max&quot;&gt;&lt;code&gt;tf.reduce_max()&lt;/code&gt;&lt;/a&gt;. In particular, this Op also returns a dense &lt;code&gt;Tensor&lt;/code&gt; instead of a sparse one.</source>
          <target state="translated">このOpはSparseTensorを取り、&lt;a href=&quot;../math/reduce_max&quot;&gt; &lt;code&gt;tf.reduce_max()&lt;/code&gt; に&lt;/a&gt;対応するスパースです。特に、このOpは、疎な &lt;code&gt;Tensor&lt;/code&gt; なく、密なテンソルも返します。</target>
        </trans-unit>
        <trans-unit id="a81865bba66b7cb3ccd5c843f29a627466d44c58" translate="yes" xml:space="preserve">
          <source>This Op takes a SparseTensor and is the sparse counterpart to &lt;a href=&quot;../math/reduce_sum&quot;&gt;&lt;code&gt;tf.reduce_sum()&lt;/code&gt;&lt;/a&gt;. In contrast to SparseReduceSum, this Op returns a SparseTensor.</source>
          <target state="translated">このOpはSparseTensorを取り、&lt;a href=&quot;../math/reduce_sum&quot;&gt; &lt;code&gt;tf.reduce_sum()&lt;/code&gt; に&lt;/a&gt;対応するスパースです。SparseReduceSumとは対照的に、このOpはSparseTensorを返します。</target>
        </trans-unit>
        <trans-unit id="a574e60c745da5b56aeabab5fc189ca97095b4e6" translate="yes" xml:space="preserve">
          <source>This Op takes a SparseTensor and is the sparse counterpart to &lt;a href=&quot;../math/reduce_sum&quot;&gt;&lt;code&gt;tf.reduce_sum()&lt;/code&gt;&lt;/a&gt;. In particular, this Op also returns a dense &lt;code&gt;Tensor&lt;/code&gt; if &lt;code&gt;output_is_sparse&lt;/code&gt; is &lt;code&gt;False&lt;/code&gt;, or a &lt;code&gt;SparseTensor&lt;/code&gt; if &lt;code&gt;output_is_sparse&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">このOpはSparseTensorを取り、&lt;a href=&quot;../math/reduce_sum&quot;&gt; &lt;code&gt;tf.reduce_sum()&lt;/code&gt; の&lt;/a&gt;疎な対応物です。特に、このオペアンプも密返し &lt;code&gt;Tensor&lt;/code&gt; 場合 &lt;code&gt;output_is_sparse&lt;/code&gt; がある &lt;code&gt;False&lt;/code&gt; 、または &lt;code&gt;SparseTensor&lt;/code&gt; 場合 &lt;code&gt;output_is_sparse&lt;/code&gt; がある &lt;code&gt;True&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0611fe28cd2ae42a84cd683414a5531be62247ed" translate="yes" xml:space="preserve">
          <source>This Op takes a SparseTensor and is the sparse counterpart to &lt;a href=&quot;../math/reduce_sum&quot;&gt;&lt;code&gt;tf.reduce_sum()&lt;/code&gt;&lt;/a&gt;. In particular, this Op also returns a dense &lt;code&gt;Tensor&lt;/code&gt; instead of a sparse one.</source>
          <target state="translated">このOpはSparseTensorを取り、&lt;a href=&quot;../math/reduce_sum&quot;&gt; &lt;code&gt;tf.reduce_sum()&lt;/code&gt; に&lt;/a&gt;対応するスパースです。特に、このOpは、疎な &lt;code&gt;Tensor&lt;/code&gt; なく、密なテンソルも返します。</target>
        </trans-unit>
        <trans-unit id="9513360fe89de6564516b0de822250d992516167" translate="yes" xml:space="preserve">
          <source>This adjusts the dynamic range of the gradient evaluation by scaling up the &lt;code&gt;loss&lt;/code&gt; value. The gradient values are then scaled back down by the recipricol of the loss scale. This is useful in reduced precision training where small gradient values would otherwise underflow the representable range.</source>
          <target state="translated">これは、 &lt;code&gt;loss&lt;/code&gt; 値を拡大することにより、勾配評価のダイナミックレンジを調整します。次に、勾配値は損失スケールのレシプリコールによって縮小されます。これは、小さな勾配値が表現可能な範囲をアンダーフローするような精度の低いトレーニングで役立ちます。</target>
        </trans-unit>
        <trans-unit id="f5e97086794cce37b1d5d739075a4835500e01f8" translate="yes" xml:space="preserve">
          <source>This adjusts the dynamic range of the gradient evaluation by scaling up the &lt;code&gt;loss&lt;/code&gt; value. The gradient values are then scaled back down by the reciprocal of the loss scale. This is useful in reduced precision training where small gradient values would otherwise underflow the representable range.</source>
          <target state="translated">これは、 &lt;code&gt;loss&lt;/code&gt; 値をスケールアップすることにより、勾配評価のダイナミックレンジを調整します。次に、勾配値は、損失スケールの逆数によってスケールダウンされます。これは、小さな勾配値が表現可能な範囲をアンダーフローする精度の低いトレーニングで役立ちます。</target>
        </trans-unit>
        <trans-unit id="33c2fc8a5963a345edc285e854dc6f61f0166cef" translate="yes" xml:space="preserve">
          <source>This allows 'names' which should be a list of names.</source>
          <target state="translated">これにより、名前のリストであるべき'names'が可能になります。</target>
        </trans-unit>
        <trans-unit id="4742c30308cfd6082fa96c4df5f33b7fbb5afa83" translate="yes" xml:space="preserve">
          <source>This allows communication and coordination when there are multiple calls to the step_fn triggered by a call to &lt;code&gt;strategy.experimental_run_v2(step_fn, ...)&lt;/code&gt;.</source>
          <target state="translated">これにより、 &lt;code&gt;strategy.experimental_run_v2(step_fn, ...)&lt;/code&gt; 呼び出しによってトリガーされたstep_fnへの複数の呼び出しがある場合の通信と調整が可能になります。</target>
        </trans-unit>
        <trans-unit id="54e8d42d088337b5915c0ad3a362c2e5bfd670e4" translate="yes" xml:space="preserve">
          <source>This allows communication and coordination when there are multiple calls to the step_fn triggered by a call to &lt;code&gt;strategy.run(step_fn, ...)&lt;/code&gt;.</source>
          <target state="translated">これにより、 &lt;code&gt;strategy.run(step_fn, ...)&lt;/code&gt; 呼び出しによってトリガーされたstep_fnへの複数の呼び出しがある場合に、通信と調整が可能になります。</target>
        </trans-unit>
        <trans-unit id="6406854276bccf2ce7a8330ff5c67c7e93bc6f24" translate="yes" xml:space="preserve">
          <source>This allows creating a sub-tensor from part of the current contents of a variable. See &lt;a href=&quot;../../tensor#__getitem__&quot;&gt;&lt;code&gt;tf.Tensor.&lt;strong&gt;getitem&lt;/strong&gt;&lt;/code&gt;&lt;/a&gt; for detailed examples of slicing.</source>
          <target state="translated">これにより、変数の現在の内容の一部からサブテンソルを作成できます。&lt;a href=&quot;../../tensor#__getitem__&quot;&gt; &lt;code&gt;tf.Tensor.&lt;strong&gt;getitem&lt;/strong&gt;&lt;/code&gt; &lt;/a&gt;参照してください。&lt;strong&gt;GetItem関数&lt;/strong&gt;スライスの詳細な例については。</target>
        </trans-unit>
        <trans-unit id="3f9bd14a03a5b9808d578e330775308ae0518e1f" translate="yes" xml:space="preserve">
          <source>This allows creating a sub-tensor from part of the current contents of a variable. See &lt;a href=&quot;tensor#__getitem__&quot;&gt;&lt;code&gt;tf.Tensor.&lt;strong&gt;getitem&lt;/strong&gt;&lt;/code&gt;&lt;/a&gt; for detailed examples of slicing.</source>
          <target state="translated">これにより、変数の現在の内容の一部からサブテンソルを作成できます。&lt;a href=&quot;tensor#__getitem__&quot;&gt; &lt;code&gt;tf.Tensor.&lt;strong&gt;getitem&lt;/strong&gt;&lt;/code&gt; &lt;/a&gt;参照してください。&lt;strong&gt;GetItem関数&lt;/strong&gt;スライスの詳細な例については。</target>
        </trans-unit>
        <trans-unit id="4a0031976f29ed8ed5b38f0545ffe09ca05a84a3" translate="yes" xml:space="preserve">
          <source>This allows reading and writing to this tensors w/o copies. This more closely mirrors the C++ Interpreter class interface's tensor() member, hence the name. Be careful to not hold these output references through calls to &lt;code&gt;allocate_tensors()&lt;/code&gt; and &lt;code&gt;invoke()&lt;/code&gt;. This function cannot be used to read intermediate results.</source>
          <target state="translated">これにより、コピーなしでこのテンソルを読み書きできます。これは、C ++インタープリタークラスインターフェースのtensor（）メンバーをより厳密に反映しているため、この名前が付けられています。 &lt;code&gt;allocate_tensors()&lt;/code&gt; および &lt;code&gt;invoke()&lt;/code&gt; の呼び出しを通じてこれらの出力参照を保持しないように注意してください。この関数を使用して中間結果を読み取ることはできません。</target>
        </trans-unit>
        <trans-unit id="aab58add7bb75e6c4119bf13ecc09894979d960d" translate="yes" xml:space="preserve">
          <source>This allows you to save the entirety of the state of a model in a single file.</source>
          <target state="translated">これにより、モデルの状態全体を1つのファイルに保存することができます。</target>
        </trans-unit>
        <trans-unit id="083c822ae2751294f6b801ab1aec618144643d76" translate="yes" xml:space="preserve">
          <source>This also supports either output striding via the optional &lt;code&gt;strides&lt;/code&gt; parameter or atrous convolution (also known as convolution with holes or dilated convolution, based on the French word &quot;trous&quot; meaning holes in English) via the optional &lt;code&gt;dilation_rate&lt;/code&gt; parameter. Currently, however, output striding is not supported for atrous convolutions.</source>
          <target state="translated">また、これはどちらかの出力オプションを経由して跨ぐサポート &lt;code&gt;strides&lt;/code&gt; オプションを経由してパラメータまたはatrousコンボリューション（英語の穴を意味するフランス語の単語に基づいても、穴や拡張型畳み込みとの畳み込みとして知られ、「TROUS」）を &lt;code&gt;dilation_rate&lt;/code&gt; のパラメータ。ただし、現在のところ、アストロ畳み込みでは出力ストライドはサポートされていません。</target>
        </trans-unit>
        <trans-unit id="0282c5f56f860d1be334e321248ec8429b6f156d" translate="yes" xml:space="preserve">
          <source>This also supports either output striding via the optional &lt;code&gt;strides&lt;/code&gt; parameter or atrous convolution (also known as convolution with holes or dilated convolution, based on the French word &quot;trous&quot; meaning holes in English) via the optional &lt;code&gt;dilations&lt;/code&gt; parameter. Currently, however, output striding is not supported for atrous convolutions.</source>
          <target state="translated">また、これはどちらかの出力オプションを経由して跨ぐサポート &lt;code&gt;strides&lt;/code&gt; オプションを経由してパラメータまたはatrousコンボリューション（英語の穴を意味するフランス語の単語に基づいても、穴や拡張型畳み込みとの畳み込みとして知られ、「TROUS」）の &lt;code&gt;dilations&lt;/code&gt; パラメータ。ただし、現在のところ、アストロ畳み込みでは出力ストライドはサポートされていません。</target>
        </trans-unit>
        <trans-unit id="40ecf12ea54cbb9c03cee235c92870bdadc05d0e" translate="yes" xml:space="preserve">
          <source>This assumes the input dictionary contains a &lt;code&gt;SparseTensor&lt;/code&gt; for key 'terms', and a &lt;code&gt;SparseTensor&lt;/code&gt; for key 'frequencies'. These 2 tensors must have the same indices and dense shape.</source>
          <target state="translated">これは、入力ディクショナリにキー「用語」の &lt;code&gt;SparseTensor&lt;/code&gt; とキー「頻度」の &lt;code&gt;SparseTensor&lt;/code&gt; が含まれていることを前提としています。これらの2つのテンソルは、同じインデックスと密な形状でなければなりません。</target>
        </trans-unit>
        <trans-unit id="ec5e01502dedce9b5506d5284b5d16bed3dce6f8" translate="yes" xml:space="preserve">
          <source>This avoids adding &lt;code&gt;numpy_input&lt;/code&gt; as a large constant in the graph, and copies the data to the machine or machines that will be processing the input.</source>
          <target state="translated">これにより、 &lt;code&gt;numpy_input&lt;/code&gt; をグラフ内の大きな定数として追加することを回避し、入力を処理する1つまたは複数のマシンにデータをコピーします。</target>
        </trans-unit>
        <trans-unit id="542cdf0657b556d7d4f13254bf996896da1af7f2" translate="yes" xml:space="preserve">
          <source>This behaves similarly to &lt;a href=&quot;../../name_scope&quot;&gt;&lt;code&gt;tf.name_scope&lt;/code&gt;&lt;/a&gt;, except that it returns a generated summary tag in addition to the scope name. The tag is structurally similar to the scope name - derived from the user-provided name, prefixed with enclosing name scopes if any - but we relax the constraint that it be uniquified, as well as the character set limitation (so the user-provided name can contain characters not legal for scope names; in the scope name these are removed).</source>
          <target state="translated">これは&lt;a href=&quot;../../name_scope&quot;&gt; &lt;code&gt;tf.name_scope&lt;/code&gt; &lt;/a&gt;と同じように動作しますが、スコープ名に加えて生成されたサマリータグを返します。タグは構造的にスコープ名に似ています-ユーザーが指定した名前から派生し、存在する場合は囲んでいる名前スコープが前に付けられます-一意化されるという制約と文字セットの制限（ユーザーが指定する名前）スコープ名に無効な文字を含めることができます。スコープ名では削除されます）。</target>
        </trans-unit>
        <trans-unit id="5d690c9d397a6da08fd08939e695a0fb6ea89e4b" translate="yes" xml:space="preserve">
          <source>This behavior gives control to callers on what to do if checkpoints do not come fast enough or stop being generated. For example, if callers have a way to detect that the training has stopped and know that no new checkpoints will be generated, they can provide a &lt;code&gt;timeout_fn&lt;/code&gt; that returns &lt;code&gt;True&lt;/code&gt; when the training has stopped. If they know that the training is still going on they return &lt;code&gt;False&lt;/code&gt; instead.</source>
          <target state="translated">この動作により、チェックポイントが十分に速くならない場合、または生成が停止した場合の対処法を呼び出し元に制御できます。たとえば、呼び出し元がトレーニングが停止したことを検出し、新しいチェックポイントが生成されないことを知っている場合、トレーニングが停止したときに &lt;code&gt;True&lt;/code&gt; を返す &lt;code&gt;timeout_fn&lt;/code&gt; を提供できます。トレーニングがまだ続いていることがわかっている場合は、代わりに &lt;code&gt;False&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="5d87911d57456c793352550a56288318dbdc2112" translate="yes" xml:space="preserve">
          <source>This behavior has been introduced in TensorFlow 2.0, in order to enable &lt;code&gt;layer.trainable = False&lt;/code&gt; to produce the most commonly expected behavior in the convnet fine-tuning use case.</source>
          <target state="translated">この動作はTlayerFlow 2.0で導入され、layer.trainable &lt;code&gt;layer.trainable = False&lt;/code&gt; を有効にして、convnet微調整のユースケースで最も一般的に期待される動作を生成します。</target>
        </trans-unit>
        <trans-unit id="566da943133ad9f7ff89e0ae58ccee97f0942cd9" translate="yes" xml:space="preserve">
          <source>This behavior only occurs as of TensorFlow 2.0. In 1.*, setting &lt;code&gt;layer.trainable = False&lt;/code&gt; would freeze the layer but would not switch it to inference mode.</source>
          <target state="translated">この動作はTensorFlow 2.0以降でのみ発生します。1. *では、 &lt;code&gt;layer.trainable = False&lt;/code&gt; を設定すると、レイヤーがフリーズしますが、推論モードに切り替わりません。</target>
        </trans-unit>
        <trans-unit id="947e43a536a4f632b306b7d5c3e4805a08d13eec" translate="yes" xml:space="preserve">
          <source>This blocks the calling thread until the thread whose join() method is called terminates -- either normally or through an unhandled exception or until the optional timeout occurs.</source>
          <target state="translated">これは、join()メソッドが呼び出されたスレッドが終了するまで、通常の処理を行うか、処理されない例外を経由するか、オプションのタイムアウトが発生するまで、呼び出し元のスレッドをブロックします。</target>
        </trans-unit>
        <trans-unit id="f576e406288a87f269b5d6306d3d486ac32d4798" translate="yes" xml:space="preserve">
          <source>This boolean flag determines whether variables should be initialized as they are instantiated (default), or if the user should handle the initialization (e.g. via &lt;a href=&quot;../../compat/v1/initialize_all_variables&quot;&gt;&lt;code&gt;tf.compat.v1.initialize_all_variables()&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">このブールフラグは、変数がインスタンス化されるときに初期化する必要があるか（デフォルト）、またはユーザーが初期化を処理する必要があるか（たとえば、&lt;a href=&quot;../../compat/v1/initialize_all_variables&quot;&gt; &lt;code&gt;tf.compat.v1.initialize_all_variables()&lt;/code&gt; を&lt;/a&gt;介して）を決定します。</target>
        </trans-unit>
        <trans-unit id="4711e34ac0b0f311f0826db62648fbfab1ecfcb6" translate="yes" xml:space="preserve">
          <source>This boolean is True when this is an export in the end of training. It is False for the intermediate exports during the training. When passing &lt;code&gt;Exporter&lt;/code&gt; to &lt;a href=&quot;train_and_evaluate&quot;&gt;&lt;code&gt;tf.estimator.train_and_evaluate&lt;/code&gt;&lt;/a&gt;&lt;code&gt;is_the_final_export&lt;/code&gt; is always False if &lt;a href=&quot;trainspec#max_steps&quot;&gt;&lt;code&gt;TrainSpec.max_steps&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">これがトレーニングの最後のエクスポートである場合、このブール値はTrueです。トレーニング中の中間輸出については誤りです。渡すときは &lt;code&gt;Exporter&lt;/code&gt; する&lt;a href=&quot;train_and_evaluate&quot;&gt; &lt;code&gt;tf.estimator.train_and_evaluate&lt;/code&gt; &lt;/a&gt; &lt;code&gt;is_the_final_export&lt;/code&gt; 場合は常にFalseで&lt;a href=&quot;trainspec#max_steps&quot;&gt; &lt;code&gt;TrainSpec.max_steps&lt;/code&gt; は&lt;/a&gt;ありません &lt;code&gt;None&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0d320c46f5814a56c1f3f60058177b848b6fe981" translate="yes" xml:space="preserve">
          <source>This call blocks until a set of threads have terminated. The set of thread is the union of the threads passed in the &lt;code&gt;threads&lt;/code&gt; argument and the list of threads that registered with the coordinator by calling &lt;a href=&quot;coordinator#register_thread&quot;&gt;&lt;code&gt;Coordinator.register_thread()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この呼び出しは、一連のスレッドが終了するまでブロックされます。スレッドのセットは、 &lt;code&gt;threads&lt;/code&gt; 引数で渡されたスレッドと、&lt;a href=&quot;coordinator#register_thread&quot;&gt; &lt;code&gt;Coordinator.register_thread()&lt;/code&gt; を&lt;/a&gt;呼び出してコーディネーターに登録されたスレッドのリストの和集合です。</target>
        </trans-unit>
        <trans-unit id="51c54c7d5726811d44822079b16e485771669c24" translate="yes" xml:space="preserve">
          <source>This call is ignored when eager execution is enabled (in that case, variable updates are run on the fly and thus do not need to be tracked for later execution).</source>
          <target state="translated">この呼び出しは、イーガー実行が有効な場合には無視されます(その場合、変数の更新はその場で実行されるので、後の実行のために追跡する必要はありません)。</target>
        </trans-unit>
        <trans-unit id="062df39159f4972c7eb0c0bbc3c621a80385af7d" translate="yes" xml:space="preserve">
          <source>This callback is automatically applied to every Keras model.</source>
          <target state="translated">このコールバックは、すべてのKerasモデルに自動的に適用されます。</target>
        </trans-unit>
        <trans-unit id="4a2209138c3b99588918296a296e9d5cba348ee9" translate="yes" xml:space="preserve">
          <source>This callback is automatically applied to every Keras model. The &lt;code&gt;History&lt;/code&gt; object gets returned by the &lt;code&gt;fit&lt;/code&gt; method of models.</source>
          <target state="translated">このコールバックは、すべてのKerasモデルに自動的に適用されます。 &lt;code&gt;History&lt;/code&gt; オブジェクトは、によって返される &lt;code&gt;fit&lt;/code&gt; モデルの方法。</target>
        </trans-unit>
        <trans-unit id="9a8fccab0666eafd61c1fb78dee506da35fb92ce" translate="yes" xml:space="preserve">
          <source>This callback is constructed with anonymous functions that will be called at the appropriate time. Note that the callbacks expects positional arguments, as:</source>
          <target state="translated">このコールバックは、適切なタイミングで呼び出される匿名関数で構成されています。コールバックは、以下のように位置引数を期待していることに注意してください。</target>
        </trans-unit>
        <trans-unit id="d5a28ff485e6238d1ad10ebb9f92b4945e5fbef4" translate="yes" xml:space="preserve">
          <source>This callback is not compatible with disabling eager execution.</source>
          <target state="translated">このコールバックは、イーガー実行を無効にすることには対応していません。</target>
        </trans-unit>
        <trans-unit id="d2fd53cd69211c630c172b830b110ef6741f78e7" translate="yes" xml:space="preserve">
          <source>This callback logs events for TensorBoard, including:</source>
          <target state="translated">このコールバックはTensorBoardのイベントを記録します。</target>
        </trans-unit>
        <trans-unit id="6cbedc26a564f8697fb303c927049b43625f8671" translate="yes" xml:space="preserve">
          <source>This can also be used in a &lt;a href=&quot;tableconfig&quot;&gt;&lt;code&gt;tf.tpu.experimental.embedding.TableConfig&lt;/code&gt;&lt;/a&gt; as the optimizer parameter to set a table specific optimizer. This will override the optimizer and parameters for global embedding optimizer defined above:</source>
          <target state="translated">これは、テーブル固有のオプティマイザーを設定するためのオプティマイザーパラメーターとして&lt;a href=&quot;tableconfig&quot;&gt; &lt;code&gt;tf.tpu.experimental.embedding.TableConfig&lt;/code&gt; &lt;/a&gt;で使用することもできます。これにより、上記で定義したグローバル埋め込みオプティマイザーのオプティマイザーとパラメーターがオーバーライドされます。</target>
        </trans-unit>
        <trans-unit id="6c4d9ff06bd1c217d75cb9a57ebc28626f964add" translate="yes" xml:space="preserve">
          <source>This can always be checked statically, so this method returns nothing.</source>
          <target state="translated">これは常に静的にチェックすることができるので、このメソッドは何も返しません。</target>
        </trans-unit>
        <trans-unit id="6f195f030f5d6a3952c927a303c10a3d51f131c5" translate="yes" xml:space="preserve">
          <source>This can be faster than multiple individual &lt;code&gt;reduce&lt;/code&gt;s because we can fuse several tensors into one or multiple packs before reduction.</source>
          <target state="translated">これは、還元の前に複数のテンソルを1つまたは複数のパックに融合できるため、複数の個別の &lt;code&gt;reduce&lt;/code&gt; よりも高速です。</target>
        </trans-unit>
        <trans-unit id="ef728ae4ad68ee3a6531133cdd224d4406968fce" translate="yes" xml:space="preserve">
          <source>This can be passed to methods like &lt;code&gt;tf.distribute.get_replica_context().all_reduce()&lt;/code&gt; to optimize collective operation performance. Note that these are only hints, which may or may not change the actual behavior. Some options only apply to certain strategy and are ignored by others.</source>
          <target state="translated">これを &lt;code&gt;tf.distribute.get_replica_context().all_reduce()&lt;/code&gt; などのメソッドに渡して、集合的な操作のパフォーマンスを最適化できます。これらは単なるヒントであり、実際の動作を変更する場合と変更しない場合があることに注意してください。一部のオプションは特定の戦略にのみ適用され、他の戦略では無視されます。</target>
        </trans-unit>
        <trans-unit id="f4c1e8ee1a694edb65fdf5329eae65afdec683d9" translate="yes" xml:space="preserve">
          <source>This can be used as a &quot;join&quot; mechanism for parallel computations: all the argument tensors can be computed in parallel, but the values of any tensor returned by &lt;code&gt;tuple&lt;/code&gt; are only available after all the parallel computations are done.</source>
          <target state="translated">これは、並列計算の「結合」メカニズムとして使用できます。すべての引数テンソルを並列で計算できますが、 &lt;code&gt;tuple&lt;/code&gt; によって返されるテンソルの値は、すべての並列計算が実行された後でのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="66b08400383b183cc1cba0b591ec90b5fe85d73d" translate="yes" xml:space="preserve">
          <source>This can be used as a loss-function during optimization so as to suppress noise in images. If you have a batch of images, then you should calculate the scalar loss-value as the sum: &lt;code&gt;loss = tf.reduce_sum(tf.image.total_variation(images))&lt;/code&gt;</source>
          <target state="translated">これは、画像のノイズを抑制するために、最適化中に損失関数として使用できます。画像のバッチがある場合は、スカラー損失値を合計として計算する必要があります &lt;code&gt;loss = tf.reduce_sum(tf.image.total_variation(images))&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f9d5c2eebbfc8025f5c8da3b80769337a79a6187" translate="yes" xml:space="preserve">
          <source>This can be used to hold some strategy specific configs.</source>
          <target state="translated">これは、いくつかのストラテジー固有の設定を保持するために使用することができます。</target>
        </trans-unit>
        <trans-unit id="ff61da80eb1038583fadf6e588b06357b27a55d8" translate="yes" xml:space="preserve">
          <source>This can be useful for debugging or profiling. For example, let's say you implemented a simple iterative sqrt function, and you want to collect the intermediate values and plot the convergence. Appending the values to a list in &lt;code&gt;@tf.function&lt;/code&gt; normally wouldn't work since it will just record the Tensors being traced, not the values. Instead, you can do the following.</source>
          <target state="translated">これは、デバッグやプロファイリングに役立ちます。たとえば、単純な反復sqrt関数を実装し、中間値を収集して収束をプロットするとします。 &lt;code&gt;@tf.function&lt;/code&gt; リストに値を追加しても、値ではなくトレースされるテンソルが記録されるだけなので、通常は機能しません。代わりに、以下を実行できます。</target>
        </trans-unit>
        <trans-unit id="5bc85a9ecd105989dec28b806afbbe4faa69f248" translate="yes" xml:space="preserve">
          <source>This can be useful if you want to log debug a training algorithm, report stats about the slots, etc.</source>
          <target state="translated">これは、トレーニングアルゴリズムのデバッグをログに記録したり、スロットに関する統計情報をレポートしたりしたい場合に便利です。</target>
        </trans-unit>
        <trans-unit id="de803dd8ed0f3487c59166443a170b97850a2c8d" translate="yes" xml:space="preserve">
          <source>This class allows to vectorize a text corpus, by turning each text into either a sequence of integers (each integer being the index of a token in a dictionary) or into a vector where the coefficient for each token could be binary, based on word count, based on tf-idf...</source>
          <target state="translated">このクラスは,テキストコーパスをベクトル化し,各テキストを整数(各整数は辞書のトークンのインデックス)のシーケンスに変換するか,各トークンの係数が2進数,単語数,tf-idf...に基づいたベクトルに変換することができます.</target>
        </trans-unit>
        <trans-unit id="c35c7cb7e9df11039724d697524b210395fe269e" translate="yes" xml:space="preserve">
          <source>This class assumes each worker is running the same code independently, but parameter servers are running a standard server. This means that while each worker will synchronously compute a single gradient update across all GPUs, updates between workers proceed asynchronously. Operations that occur only on the first replica (such as incrementing the global step), will occur on the first replica &lt;em&gt;of every worker&lt;/em&gt;.</source>
          <target state="translated">このクラスは、各ワーカーが同じコードを個別に実行していることを前提としていますが、パラメーターサーバーは標準サーバーを実行しています。これは、各ワーカーがすべてのGPUにわたる単一の勾配更新を同期的に計算する一方で、ワーカー間の更新は非同期で進行することを意味します。最初のレプリカでのみ発生する操作（グローバルステップの増分など）は、&lt;em&gt;すべてのworkerの&lt;/em&gt;最初のレプリカ&lt;em&gt;で&lt;/em&gt;発生します。</target>
        </trans-unit>
        <trans-unit id="1ea4dadc6d5580b6a9567a54f238c77dab3d0a06" translate="yes" xml:space="preserve">
          <source>This class caches file writers, one per directory.</source>
          <target state="translated">このクラスは、ディレクトリごとに1つのファイルライターをキャッシュします。</target>
        </trans-unit>
        <trans-unit id="b8684cfbd26f7ff4ba54e9a816ce8e5ac6de8988" translate="yes" xml:space="preserve">
          <source>This class can be used to support training large embeddings on TPU. When creating an instance of this class, you must specify the complete set of tables and features you expect to lookup in those tables. See the documentation of &lt;a href=&quot;tableconfig&quot;&gt;&lt;code&gt;tf.tpu.experimental.embedding.TableConfig&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;featureconfig&quot;&gt;&lt;code&gt;tf.tpu.experimental.embedding.FeatureConfig&lt;/code&gt;&lt;/a&gt; for more details on the complete set of options. We will cover the basic usage here.</source>
          <target state="translated">このクラスは、TPUでの大規模な埋め込みのトレーニングをサポートするために使用できます。このクラスのインスタンスを作成するときは、それらのテーブルでルックアップする予定のテーブルと機能の完全なセットを指定する必要があります。オプションの完全なセットの詳細については、&lt;a href=&quot;tableconfig&quot;&gt; &lt;code&gt;tf.tpu.experimental.embedding.TableConfig&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;featureconfig&quot;&gt; &lt;code&gt;tf.tpu.experimental.embedding.FeatureConfig&lt;/code&gt; の&lt;/a&gt;ドキュメントを参照してください。ここでは、基本的な使用法について説明します。</target>
        </trans-unit>
        <trans-unit id="e9243b860278b8d7215f95a8eb101fc7a883ab5b" translate="yes" xml:space="preserve">
          <source>This class can create placeholders for tf.Tensors, tf.SparseTensors, and tf.RaggedTensors by choosing 'sparse=True' or 'ragged=True'.</source>
          <target state="translated">このクラスは、'sparse=True' または 'ragged=True' を選択することで、tf.Tensors,tf.SparseTensors,tf.RaggedTensors のプレースホルダを作成することができます。</target>
        </trans-unit>
        <trans-unit id="805ec9c49684c57a889497d64617b10bca6259a1" translate="yes" xml:space="preserve">
          <source>This class can create placeholders for tf.Tensors, tf.SparseTensors, and tf.RaggedTensors by choosing 'sparse=True' or 'ragged=True'. Note that 'sparse' and 'ragged' can't be configured to True at same time. Usage:</source>
          <target state="translated">このクラスは、'sparse=True' または 'ragged=True' を選択することで、 tf.Tensors,tf.SparseTensors,tf.RaggedTensors のプレースホルダを作成することができます。なお、'sparse' と 'ragged' は同時に True に設定することはできません。使用法。</target>
        </trans-unit>
        <trans-unit id="b93eb86d4b8b199ed8de190972226d76d3ddbda5" translate="yes" xml:space="preserve">
          <source>This class defines the API to add Ops to train a model. You never use this class directly, but instead instantiate one of its subclasses such as &lt;a href=&quot;sgd&quot;&gt;&lt;code&gt;tf.keras.optimizers.SGD&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;adam&quot;&gt;&lt;code&gt;tf.keras.optimizers.Adam&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">このクラスは、Opsを追加してモデルをトレーニングするためのAPIを定義します。このクラスを直接使用することはありませんが、代わりに&lt;a href=&quot;sgd&quot;&gt; &lt;code&gt;tf.keras.optimizers.SGD&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;adam&quot;&gt; &lt;code&gt;tf.keras.optimizers.Adam&lt;/code&gt; &lt;/a&gt;などのサブクラスの1つをインスタンス化します。</target>
        </trans-unit>
        <trans-unit id="1921ba1f544676f9bbcb9030a711c397087751d1" translate="yes" xml:space="preserve">
          <source>This class defines the API to add Ops to train a model. You never use this class directly, but instead instantiate one of its subclasses such as &lt;code&gt;GradientDescentOptimizer&lt;/code&gt;, &lt;code&gt;AdagradOptimizer&lt;/code&gt;, or &lt;code&gt;MomentumOptimizer&lt;/code&gt;.</source>
          <target state="translated">このクラスは、Opsを追加してモデルをトレーニングするためのAPIを定義します。このクラスを直接使用することはありませんが、代わりに &lt;code&gt;GradientDescentOptimizer&lt;/code&gt; 、 &lt;code&gt;AdagradOptimizer&lt;/code&gt; 、または &lt;code&gt;MomentumOptimizer&lt;/code&gt; などのサブクラスのいずれかをインスタンス化します。</target>
        </trans-unit>
        <trans-unit id="f1b4934ebc6e87e946a8327b096ccaba6f902fbb" translate="yes" xml:space="preserve">
          <source>This class defines the key and value used for tf.lookup.TextFileInitializer.</source>
          <target state="translated">このクラスは、tf.lookup.TextFileInitializerで使用されるキーと値を定義します。</target>
        </trans-unit>
        <trans-unit id="bbef232ee84dd43e03ff0bb31e2fff3d62ddb086" translate="yes" xml:space="preserve">
          <source>This class exports the serving graph and checkpoints at the end.</source>
          <target state="translated">このクラスは、サーブグラフと最後のチェックポイントをエクスポートします。</target>
        </trans-unit>
        <trans-unit id="2398f265a0682e91ce8fc30c31cc00a32b85cf94" translate="yes" xml:space="preserve">
          <source>This class exports the serving graph and checkpoints of the best models.</source>
          <target state="translated">このクラスは、ベストモデルのサーブグラフとチェックポイントをエクスポートします。</target>
        </trans-unit>
        <trans-unit id="f378b5fe5691dc39f9cd3d236136a8685104c4fd" translate="yes" xml:space="preserve">
          <source>This class has been deprecated. Please use &lt;a href=&quot;../../../lite/tfliteconverter&quot;&gt;&lt;code&gt;lite.TFLiteConverter&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">このクラスは廃止されました。代わりに&lt;a href=&quot;../../../lite/tfliteconverter&quot;&gt; &lt;code&gt;lite.TFLiteConverter&lt;/code&gt; &lt;/a&gt;を使用してください。</target>
        </trans-unit>
        <trans-unit id="56db13aef8a0368de7cd44eab17a2a6ce7b0dc42" translate="yes" xml:space="preserve">
          <source>This class has been deprecated. Please use &lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/lite/TFLiteConverter&quot;&gt;&lt;code&gt;lite.TFLiteConverter&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">このクラスは非推奨になりました。代わりに&lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/lite/TFLiteConverter&quot;&gt; &lt;code&gt;lite.TFLiteConverter&lt;/code&gt; &lt;/a&gt;を使用してください。</target>
        </trans-unit>
        <trans-unit id="8616741a1ce86b957920807cdf7bdf7cd9ce000e" translate="yes" xml:space="preserve">
          <source>This class has two primary purposes:</source>
          <target state="translated">このクラスには主に2つの目的があります。</target>
        </trans-unit>
        <trans-unit id="42f7db2b92ba92041bfe671280afd36a3919a9f0" translate="yes" xml:space="preserve">
          <source>This class holds the configuration data for a single embedding feature. The main use is to assign features to &lt;a href=&quot;tableconfig&quot;&gt;&lt;code&gt;tf.tpu.experimental.embedding.TableConfig&lt;/code&gt;&lt;/a&gt;s via the table parameter:</source>
          <target state="translated">このクラスは、単一の埋め込み機能の構成データを保持します。主な用途は、テーブルパラメータを介して&lt;a href=&quot;tableconfig&quot;&gt; &lt;code&gt;tf.tpu.experimental.embedding.TableConfig&lt;/code&gt; &lt;/a&gt;に機能を割り当てることです。</target>
        </trans-unit>
        <trans-unit id="3a9133b931fbc77d042cdefc7dee2428d484b0ed" translate="yes" xml:space="preserve">
          <source>This class holds the configuration data for a single embedding table. It is used as the &lt;code&gt;table&lt;/code&gt; parameter of a &lt;a href=&quot;featureconfig&quot;&gt;&lt;code&gt;tf.tpu.experimental.embedding.FeatureConfig&lt;/code&gt;&lt;/a&gt;. Multiple &lt;a href=&quot;featureconfig&quot;&gt;&lt;code&gt;tf.tpu.experimental.embedding.FeatureConfig&lt;/code&gt;&lt;/a&gt; objects can use the same &lt;a href=&quot;tableconfig&quot;&gt;&lt;code&gt;tf.tpu.experimental.embedding.TableConfig&lt;/code&gt;&lt;/a&gt; object. In this case a shared table will be created for those feature lookups.</source>
          <target state="translated">このクラスは、単一の埋め込みテーブルの構成データを保持します。これは、&lt;a href=&quot;featureconfig&quot;&gt; &lt;code&gt;tf.tpu.experimental.embedding.FeatureConfig&lt;/code&gt; の&lt;/a&gt; &lt;code&gt;table&lt;/code&gt; パラメータとして使用されます。複数の&lt;a href=&quot;featureconfig&quot;&gt; &lt;code&gt;tf.tpu.experimental.embedding.FeatureConfig&lt;/code&gt; &lt;/a&gt;オブジェクトは、同じ&lt;a href=&quot;tableconfig&quot;&gt; &lt;code&gt;tf.tpu.experimental.embedding.TableConfig&lt;/code&gt; &lt;/a&gt;オブジェクトを使用できます。この場合、これらの機能ルックアップ用に共有テーブルが作成されます。</target>
        </trans-unit>
        <trans-unit id="e41eb7b59b50f02eb388655630751957c627b643" translate="yes" xml:space="preserve">
          <source>This class implements &lt;code&gt;__enter__&lt;/code&gt; and &lt;code&gt;__exit__&lt;/code&gt;, and can be used in &lt;code&gt;with&lt;/code&gt; blocks like a normal file.</source>
          <target state="translated">このクラスの実装は &lt;code&gt;__enter__&lt;/code&gt; と &lt;code&gt;__exit__&lt;/code&gt; 、とに使用することができ &lt;code&gt;with&lt;/code&gt; 、通常のファイルのようにブロックします。</target>
        </trans-unit>
        <trans-unit id="8e6a775ae22bedf95251724d923983db37089b28" translate="yes" xml:space="preserve">
          <source>This class implements &lt;code&gt;__enter__&lt;/code&gt; and &lt;code&gt;__exit__&lt;/code&gt;, and can be used in &lt;code&gt;with&lt;/code&gt; blocks like a normal file. (See the usage example above.)</source>
          <target state="translated">このクラスの実装は &lt;code&gt;__enter__&lt;/code&gt; と &lt;code&gt;__exit__&lt;/code&gt; 、とに使用することができ &lt;code&gt;with&lt;/code&gt; 、通常のファイルのようにブロックします。（上記の使用例を参照してください。）</target>
        </trans-unit>
        <trans-unit id="61d78e6233b72d451051551f631a8d253b9c0d10" translate="yes" xml:space="preserve">
          <source>This class implements a simple mechanism to coordinate the termination of a set of threads.</source>
          <target state="translated">このクラスは、スレッドのセットの終了を調整するためのシンプルなメカニズムを実装しています。</target>
        </trans-unit>
        <trans-unit id="2c453470b9fb7d2dd4c8372805a2c5b45dcafe1a" translate="yes" xml:space="preserve">
          <source>This class in stateful and thread-compatible.</source>
          <target state="translated">このクラスはステートフルでスレッド互換です。</target>
        </trans-unit>
        <trans-unit id="b6c71f2399c238428100228254e29a64f6c45e19" translate="yes" xml:space="preserve">
          <source>This class is a simple wrapper for a pair of &lt;code&gt;Tensor&lt;/code&gt; objects:</source>
          <target state="translated">このクラスは、 &lt;code&gt;Tensor&lt;/code&gt; オブジェクトのペアの単純なラッパーです。</target>
        </trans-unit>
        <trans-unit id="aaddfb846b1d90d727149969bb3d79f9de0c7466" translate="yes" xml:space="preserve">
          <source>This class is a small wrapper that takes care of session creation and checkpoint recovery. It also provides functions that to facilitate coordination among multiple training threads or processes.</source>
          <target state="translated">このクラスは、セッションの作成やチェックポイントの回復を行う小さなラッパーです。また、複数のトレーニングスレッドやプロセス間の調整を容易にする機能も提供します。</target>
        </trans-unit>
        <trans-unit id="17463f3d93317c6b5e6f0cc508b2a6f39e7358ea" translate="yes" xml:space="preserve">
          <source>This class is deprecated. For synchrononous training, please use &lt;a href=&quot;https://github.com/tensorflow/tensorflow/tree/master/tensorflow/contrib/distribute&quot;&gt;Distribution Strategies&lt;/a&gt;.</source>
          <target state="translated">このクラスは非推奨です。同期トレーニングについては、&lt;a href=&quot;https://github.com/tensorflow/tensorflow/tree/master/tensorflow/contrib/distribute&quot;&gt;配布戦略&lt;/a&gt;を使用してください。</target>
        </trans-unit>
        <trans-unit id="000d9e8de17ad9ab35fd8858d3f373310d7cf1c7" translate="yes" xml:space="preserve">
          <source>This class is deprecated. For synchronous training, please use &lt;a href=&quot;https://github.com/tensorflow/tensorflow/tree/master/tensorflow/contrib/distribute&quot;&gt;Distribution Strategies&lt;/a&gt;.</source>
          <target state="translated">このクラスは非推奨です。同期トレーニングの場合は、&lt;a href=&quot;https://github.com/tensorflow/tensorflow/tree/master/tensorflow/contrib/distribute&quot;&gt;配布戦略&lt;/a&gt;を使用してください。</target>
        </trans-unit>
        <trans-unit id="4616d8f2e476585f5e22705937707332b5baeb5b" translate="yes" xml:space="preserve">
          <source>This class is deprecated. Please use &lt;a href=&quot;monitoredtrainingsession&quot;&gt;&lt;code&gt;tf.compat.v1.train.MonitoredTrainingSession&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">このクラスは非推奨です。代わりに&lt;a href=&quot;monitoredtrainingsession&quot;&gt; &lt;code&gt;tf.compat.v1.train.MonitoredTrainingSession&lt;/code&gt; &lt;/a&gt;を使用してください。</target>
        </trans-unit>
        <trans-unit id="42d3bc86be52a8736e6d7aa317815110401307ef" translate="yes" xml:space="preserve">
          <source>This class is heavily overloaded:</source>
          <target state="translated">このクラスは過負荷が大きいです。</target>
        </trans-unit>
        <trans-unit id="22170de053f3420fc08a96260e613e3fa8486018" translate="yes" xml:space="preserve">
          <source>This class is meant to be used with dynamic iteration primitives such as &lt;code&gt;while_loop&lt;/code&gt; and &lt;code&gt;map_fn&lt;/code&gt;. It supports gradient back-propagation via special &quot;flow&quot; control flow dependencies.</source>
          <target state="translated">このクラスは、 &lt;code&gt;while_loop&lt;/code&gt; や &lt;code&gt;map_fn&lt;/code&gt; などの動的反復プリミティブで使用するためのものです。特別な「フロー」制御フローの依存関係を介して、勾配の逆伝播をサポートします。</target>
        </trans-unit>
        <trans-unit id="3c5c516c190cd8f8be6eb152047649a9bf6735af" translate="yes" xml:space="preserve">
          <source>This class is not thread-safe.</source>
          <target state="translated">このクラスはスレッドセーフではありません。</target>
        </trans-unit>
        <trans-unit id="121c6274230c0f7d1b806b54f9d580ba8e2d228a" translate="yes" xml:space="preserve">
          <source>This class merges the output of multiple &lt;code&gt;Head&lt;/code&gt; objects. Specifically:</source>
          <target state="translated">このクラスは、複数の &lt;code&gt;Head&lt;/code&gt; オブジェクトの出力をマージします。具体的には：</target>
        </trans-unit>
        <trans-unit id="7cd980fdc04e7da43f8abb3e3be6ffdf25b7685d" translate="yes" xml:space="preserve">
          <source>This class performs a model export everytime the new model is better than any existing model.</source>
          <target state="translated">このクラスは、新しいモデルが既存のモデルよりも優れている場合には、その都度モデルのエクスポートを行います。</target>
        </trans-unit>
        <trans-unit id="391aed511e9154256ca236f23d6877cb0f9d37db" translate="yes" xml:space="preserve">
          <source>This class performs a single export at the end of training.</source>
          <target state="translated">このクラスは、トレーニングの最後に単一のエクスポートを実行します。</target>
        </trans-unit>
        <trans-unit id="b83c252083ca3edbed9d1168a0ed9755da22c25f" translate="yes" xml:space="preserve">
          <source>This class performs a union given two or more existing ClusterResolvers. It merges the underlying ClusterResolvers, and returns one unified ClusterSpec when cluster_spec is called. The details of the merge function is documented in the cluster_spec function.</source>
          <target state="translated">このクラスは、2つ以上の既存のClusterResolversを与えられた場合に結合を行います。基底にあるClusterResolversをマージし、cluster_specが呼ばれたときに一つの統一されたClusterSpecを返します。マージ関数の詳細は cluster_spec 関数で説明されています。</target>
        </trans-unit>
        <trans-unit id="631d6a58bb184da4fc166c1a1dbaf36a0e45d9c8" translate="yes" xml:space="preserve">
          <source>This class performs the softmax operation for you, so inputs should be e.g. linear projections of outputs by an LSTM.</source>
          <target state="translated">このクラスはソフトマックス演算を実行しますので、入力はLSTMによる出力の線形投影などになります。</target>
        </trans-unit>
        <trans-unit id="d2810b13f641fd9987b2ce8b38f939b3369079e3" translate="yes" xml:space="preserve">
          <source>This class processes one step within the whole time sequence input, whereas &lt;code&gt;tf.keras.layer.GRU&lt;/code&gt; processes the whole sequence.</source>
          <target state="translated">このクラスは、時間シーケンス入力全体の1つのステップを処理しますが、 &lt;code&gt;tf.keras.layer.GRU&lt;/code&gt; はシーケンス全体を処理します。</target>
        </trans-unit>
        <trans-unit id="9a1d5a35670a2cc4cfac2401e85535a1c8acffb8" translate="yes" xml:space="preserve">
          <source>This class processes one step within the whole time sequence input, whereas &lt;code&gt;tf.keras.layer.LSTM&lt;/code&gt; processes the whole sequence.</source>
          <target state="translated">このクラスは、時間シーケンス入力全体の1つのステップを処理しますが、 &lt;code&gt;tf.keras.layer.LSTM&lt;/code&gt; はシーケンス全体を処理します。</target>
        </trans-unit>
        <trans-unit id="85aecc3ec7757c0f4286579ce3ab5119031dd197" translate="yes" xml:space="preserve">
          <source>This class processes one step within the whole time sequence input, whereas &lt;code&gt;tf.keras.layer.SimpleRNN&lt;/code&gt; processes the whole sequence.</source>
          <target state="translated">このクラスは、時間シーケンス入力全体の1つのステップを処理しますが、 &lt;code&gt;tf.keras.layer.SimpleRNN&lt;/code&gt; はシーケンス全体を処理します。</target>
        </trans-unit>
        <trans-unit id="c2cd1ab18438d633073fa2c3300d94950ce386b5" translate="yes" xml:space="preserve">
          <source>This class regularly exports the serving graph and checkpoints.</source>
          <target state="translated">このクラスは、サーブグラフとチェックポイントを定期的にエクスポートします。</target>
        </trans-unit>
        <trans-unit id="44829f1dbd5fa6ec4b7c405e96fb0cb7473fedd5" translate="yes" xml:space="preserve">
          <source>This class specifies the configurations for an &lt;code&gt;Estimator&lt;/code&gt; run.</source>
          <target state="translated">このクラスは、 &lt;code&gt;Estimator&lt;/code&gt; 実行の構成を指定します。</target>
        </trans-unit>
        <trans-unit id="349b70f1528f5d483fc48af054599841c5669982" translate="yes" xml:space="preserve">
          <source>This class takes in a sequence of data-points gathered at equal intervals, along with time series parameters such as stride, length of history, etc., to produce batches for training/validation.</source>
          <target state="translated">このクラスでは、等間隔で収集された一連のデータポイントを、歩幅や履歴の長さなどの時系列パラメータとともに取り込み、トレーニング/検証用のバッチを作成します。</target>
        </trans-unit>
        <trans-unit id="2020d8f19309c20263f69977f3eb5adfc93381e1" translate="yes" xml:space="preserve">
          <source>This class uses a &lt;a href=&quot;../variable&quot;&gt;&lt;code&gt;tf.Variable&lt;/code&gt;&lt;/a&gt; to manage its internal state. Every time random numbers are generated, the state of the generator will change. For example:</source>
          <target state="translated">このクラスは、&lt;a href=&quot;../variable&quot;&gt; &lt;code&gt;tf.Variable&lt;/code&gt; &lt;/a&gt;を使用して内部状態を管理します。乱数が生成されるたびに、ジェネレーターの状態が変化します。例えば：</target>
        </trans-unit>
        <trans-unit id="45bad515b0c24287a7857bc49730849b980995da" translate="yes" xml:space="preserve">
          <source>This classifier ignores feature values and will learn to predict the average value of each label. For single-label problems, this will predict the probability distribution of the classes as seen in the labels. For multi-label problems, this will predict the fraction of examples that are positive for each class.</source>
          <target state="translated">この分類器は,特徴量を無視して,各ラベルの平均値を予測することを学習する.単一ラベル問題では,ラベルで見たクラスの確率分布を予測します.マルチラベル問題では,各クラスの正の例の割合を予測します.</target>
        </trans-unit>
        <trans-unit id="1203741987f9f009e5e86b580142b5f23085017c" translate="yes" xml:space="preserve">
          <source>This computes the internal data stats related to the data-dependent transformations, based on an array of sample data.</source>
          <target state="translated">これは、サンプルデータの配列に基づいて、データに依存する変換に関連する内部データの統計量を計算します。</target>
        </trans-unit>
        <trans-unit id="38619017d4eec4e645fa2f91a523c788477cd3cb" translate="yes" xml:space="preserve">
          <source>This condition holds if for every pair of (possibly broadcast) elements &lt;code&gt;x[i]&lt;/code&gt;, &lt;code&gt;y[i]&lt;/code&gt;, we have</source>
          <target state="translated">この条件は、（ブロードキャストされる可能性のある）要素のすべてのペア &lt;code&gt;x[i]&lt;/code&gt; 、 &lt;code&gt;y[i]&lt;/code&gt; に対して、</target>
        </trans-unit>
        <trans-unit id="462aa0ba39503de33a78d3a4ed1c72d0eb71fa77" translate="yes" xml:space="preserve">
          <source>This condition holds if for every pair of (possibly broadcast) elements &lt;code&gt;x[i]&lt;/code&gt;, &lt;code&gt;y[i]&lt;/code&gt;, we have &lt;code&gt;x[i] != y[i]&lt;/code&gt;. If both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are empty, this is trivially satisfied.</source>
          <target state="translated">この条件は、（ブロードキャストされる可能性のある）要素のすべてのペア &lt;code&gt;x[i]&lt;/code&gt; 、 &lt;code&gt;y[i]&lt;/code&gt; に対して、 &lt;code&gt;x[i] != y[i]&lt;/code&gt; がある場合に当てはまります。 &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; の両方が空の場合、これは簡単に満たされます。</target>
        </trans-unit>
        <trans-unit id="e25b6ae62c3ffc2ef4953d25e9698856f0a3b77a" translate="yes" xml:space="preserve">
          <source>This condition holds if for every pair of (possibly broadcast) elements &lt;code&gt;x[i]&lt;/code&gt;, &lt;code&gt;y[i]&lt;/code&gt;, we have &lt;code&gt;x[i] &amp;gt; y[i]&lt;/code&gt;. If both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are empty, this is trivially satisfied.</source>
          <target state="translated">（ブロードキャストされる可能性のある）要素のすべてのペア &lt;code&gt;x[i]&lt;/code&gt; 、 &lt;code&gt;y[i]&lt;/code&gt; に対して、 &lt;code&gt;x[i] &amp;gt; y[i]&lt;/code&gt; が存在する場合、この条件が成立します。 &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; の両方が空の場合、これは簡単に満たされます。</target>
        </trans-unit>
        <trans-unit id="ad801aabcdd92fbf94ec233e05dfeadd68d460b3" translate="yes" xml:space="preserve">
          <source>This condition holds if for every pair of (possibly broadcast) elements &lt;code&gt;x[i]&lt;/code&gt;, &lt;code&gt;y[i]&lt;/code&gt;, we have &lt;code&gt;x[i] &amp;gt;= y[i]&lt;/code&gt;. If both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are empty, this is trivially satisfied.</source>
          <target state="translated">この条件は、（ブロードキャストされる可能性のある）要素のすべてのペア &lt;code&gt;x[i]&lt;/code&gt; 、 &lt;code&gt;y[i]&lt;/code&gt; について、 &lt;code&gt;x[i] &amp;gt;= y[i]&lt;/code&gt; がある場合に成立します。 &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; の両方が空の場合、これは簡単に満たされます。</target>
        </trans-unit>
        <trans-unit id="512ed74cbec98906ad1a4d1866d9484e4d2ad504" translate="yes" xml:space="preserve">
          <source>This condition holds if for every pair of (possibly broadcast) elements &lt;code&gt;x[i]&lt;/code&gt;, &lt;code&gt;y[i]&lt;/code&gt;, we have &lt;code&gt;x[i] &amp;lt; y[i]&lt;/code&gt;. If both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are empty, this is trivially satisfied.</source>
          <target state="translated">この条件は、（ブロードキャストされる可能性がある）要素のすべてのペア &lt;code&gt;x[i]&lt;/code&gt; 、 &lt;code&gt;y[i]&lt;/code&gt; に対して、 &lt;code&gt;x[i] &amp;lt; y[i]&lt;/code&gt; 場合に成り立ちます。 &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; の両方が空の場合、これは簡単に満たされます。</target>
        </trans-unit>
        <trans-unit id="81434868d39629bbc35c170df36a994a92015b46" translate="yes" xml:space="preserve">
          <source>This condition holds if for every pair of (possibly broadcast) elements &lt;code&gt;x[i]&lt;/code&gt;, &lt;code&gt;y[i]&lt;/code&gt;, we have &lt;code&gt;x[i] &amp;lt;= y[i]&lt;/code&gt;. If both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are empty, this is trivially satisfied.</source>
          <target state="translated">（ブロードキャストされる可能性のある）要素のすべてのペア &lt;code&gt;x[i]&lt;/code&gt; 、 &lt;code&gt;y[i]&lt;/code&gt; について、 &lt;code&gt;x[i] &amp;lt;= y[i]&lt;/code&gt; が存在する場合、この条件が成立します。 &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; の両方が空の場合、これは簡単に満たされます。</target>
        </trans-unit>
        <trans-unit id="93ee9d4d5438fdc7dae43626edce4fb33cefa73b" translate="yes" xml:space="preserve">
          <source>This condition holds if for every pair of (possibly broadcast) elements &lt;code&gt;x[i]&lt;/code&gt;, &lt;code&gt;y[i]&lt;/code&gt;, we have &lt;code&gt;x[i] == y[i]&lt;/code&gt;. If both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are empty, this is trivially satisfied.</source>
          <target state="translated">（おそらくブロードキャストされる）要素のすべてのペア &lt;code&gt;x[i]&lt;/code&gt; 、 &lt;code&gt;y[i]&lt;/code&gt; に対して、 &lt;code&gt;x[i] == y[i]&lt;/code&gt; がある場合、この条件が成立します。 &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; の両方が空の場合、これは簡単に満たされます。</target>
        </trans-unit>
        <trans-unit id="1107421e32062956898c5a66e60e49bd95c7ed45" translate="yes" xml:space="preserve">
          <source>This constraint can be applied to any &lt;code&gt;Conv2D&lt;/code&gt; layer version, including &lt;code&gt;Conv2DTranspose&lt;/code&gt; and &lt;code&gt;SeparableConv2D&lt;/code&gt;, and with either &lt;code&gt;&quot;channels_last&quot;&lt;/code&gt; or &lt;code&gt;&quot;channels_first&quot;&lt;/code&gt; data format. The method assumes the weight tensor is of shape &lt;code&gt;(rows, cols, input_depth, output_depth)&lt;/code&gt;.</source>
          <target state="translated">この制約は、いずれにも適用することができる &lt;code&gt;Conv2D&lt;/code&gt; を含む層バージョン、 &lt;code&gt;Conv2DTranspose&lt;/code&gt; と &lt;code&gt;SeparableConv2D&lt;/code&gt; 、及びいずれかと &lt;code&gt;&quot;channels_last&quot;&lt;/code&gt; 又は &lt;code&gt;&quot;channels_first&quot;&lt;/code&gt; データフォーマット。このメソッドは、重みテンソルの形状 &lt;code&gt;(rows, cols, input_depth, output_depth)&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="e5e140df8d55549c17df75f17763f4c88b908cd9" translate="yes" xml:space="preserve">
          <source>This constructor creates both a &lt;code&gt;variable&lt;/code&gt; Op and an &lt;code&gt;assign&lt;/code&gt; Op to set the variable to its initial value.</source>
          <target state="translated">このコンストラクターは、 &lt;code&gt;variable&lt;/code&gt; Opと &lt;code&gt;assign&lt;/code&gt; Opの両方を作成して、変数をその初期値に設定します。</target>
        </trans-unit>
        <trans-unit id="0853b5f1d96849514913dcea4715e205fe7e9be9" translate="yes" xml:space="preserve">
          <source>This constructor is private -- please use one of the following ops to build &lt;code&gt;RaggedTensor&lt;/code&gt;s:</source>
          <target state="translated">このコンストラクターはプライベートです &lt;code&gt;RaggedTensor&lt;/code&gt; を構築するには、次のいずれかのオペレーションを使用してください：</target>
        </trans-unit>
        <trans-unit id="fa9706d28ea0bf76646310aace552e8f79dee4fd" translate="yes" xml:space="preserve">
          <source>This constructor only applies if the algorithm is a counter-based algorithm. See method &lt;code&gt;key&lt;/code&gt; for the meaning of &quot;key&quot; and &quot;counter&quot;.</source>
          <target state="translated">このコンストラクターは、アルゴリズムがカウンターベースのアルゴリズムである場合にのみ適用されます。「キー」と「カウンター」の意味については、メソッド &lt;code&gt;key&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="abd1f92b92080f9534139ad50b5578924ec063f6" translate="yes" xml:space="preserve">
          <source>This contains most of the synchronization implementation and also wraps the apply_gradients() from the real optimizer.</source>
          <target state="translated">これには同期化の実装のほとんどが含まれており、実際のオプティマイザからの apply_gradients()もラップされています。</target>
        </trans-unit>
        <trans-unit id="dac62a0f0dbdc3c6a9231598871c80876ac21c3b" translate="yes" xml:space="preserve">
          <source>This context handler simplifies the exception handling. Use it as follows:</source>
          <target state="translated">このコンテキストハンドラは例外処理を簡素化します。以下のように使用します。</target>
        </trans-unit>
        <trans-unit id="92e2326270a118c9b1678bb4952443a859f4c559" translate="yes" xml:space="preserve">
          <source>This context manager can be used to override the gradient function that will be used for ops within the scope of the context.</source>
          <target state="translated">このコンテキストマネージャーを使用して、コンテキストの範囲内の操作に使用されるグラデーション関数をオーバーライドすることができます。</target>
        </trans-unit>
        <trans-unit id="790e879037e30f5e5546c1be4c06bf6476dca2dd" translate="yes" xml:space="preserve">
          <source>This context manager captures all writes to a given stream inside of a &lt;code&gt;CapturedWrites&lt;/code&gt; object. When this context manager is created, it yields the &lt;code&gt;CapturedWrites&lt;/code&gt; object. The captured contents can be accessed by calling &lt;code&gt;.contents()&lt;/code&gt; on the &lt;code&gt;CapturedWrites&lt;/code&gt;.</source>
          <target state="translated">このコンテキストマネージャは、 &lt;code&gt;CapturedWrites&lt;/code&gt; オブジェクト内の特定のストリームへのすべての書き込みをキャプチャします。このコンテキストマネージャが作成されると、 &lt;code&gt;CapturedWrites&lt;/code&gt; オブジェクトが生成されます。キャプチャされたコンテンツには、 &lt;code&gt;CapturedWrites&lt;/code&gt; で &lt;code&gt;.contents()&lt;/code&gt; を呼び出すことでアクセスできます。</target>
        </trans-unit>
        <trans-unit id="41c375fab79db6dca2a3052fe26a3bb1f0a48127" translate="yes" xml:space="preserve">
          <source>This context manager creates and automatically recovers a session. It optionally starts the standard services that handle checkpoints and summaries. It monitors exceptions raised from the &lt;code&gt;with&lt;/code&gt; block or from the services and stops the supervisor as needed.</source>
          <target state="translated">このコンテキストマネージャは、セッションを作成して自動的に回復します。オプションで、チェックポイントとサマリーを処理する標準サービスを開始します。これは、 &lt;code&gt;with&lt;/code&gt; ブロックまたはサービスから発生した例外を監視し、必要に応じてスーパーバイザを停止します。</target>
        </trans-unit>
        <trans-unit id="1dfc6367da2112861ba5a19ab74136e2bfa59bd7" translate="yes" xml:space="preserve">
          <source>This context manager pushes a name scope, which will make the name of all operations added within it have a prefix.</source>
          <target state="translated">このコンテキストマネージャは名前スコープをプッシュし、その中に追加されたすべての操作の名前に接頭辞を付けます。</target>
        </trans-unit>
        <trans-unit id="cadf2e29564a69f6d9e78e18436e128fc8603a09" translate="yes" xml:space="preserve">
          <source>This context manager validates that the (optional) &lt;code&gt;values&lt;/code&gt; are from the same graph, ensures that graph is the default graph, and pushes a name scope and a variable scope.</source>
          <target state="translated">このコンテキストマネージャは、（オプションの） &lt;code&gt;values&lt;/code&gt; が同じグラフからのものであることを検証し、グラフがデフォルトのグラフであることを確認し、名前スコープと変数スコープをプッシュします。</target>
        </trans-unit>
        <trans-unit id="9fe8f8972b4d68b13082f0d96ff8de4b430acf3b" translate="yes" xml:space="preserve">
          <source>This context manager validates that the given &lt;code&gt;values&lt;/code&gt; are from the same graph, makes that graph the default graph, and pushes a name scope in that graph (see &lt;a href=&quot;../../../../graph#name_scope&quot;&gt;&lt;code&gt;tf.Graph.name_scope&lt;/code&gt;&lt;/a&gt; for more details on that).</source>
          <target state="translated">このコンテキストマネージャーは、指定された &lt;code&gt;values&lt;/code&gt; が同じグラフからのものであることを検証し、そのグラフをデフォルトのグラフにし、そのグラフに名前スコープをプッシュします（詳細については、&lt;a href=&quot;../../../../graph#name_scope&quot;&gt; &lt;code&gt;tf.Graph.name_scope&lt;/code&gt; &lt;/a&gt;を参照してください）。</target>
        </trans-unit>
        <trans-unit id="8bc9405ecd91e0aa7f29a32f0b001ccc17dfce1e" translate="yes" xml:space="preserve">
          <source>This convenience method requires a session where the graph containing this variable has been launched. If no session is passed, the default session is used. See &lt;a href=&quot;compat/v1/session&quot;&gt;&lt;code&gt;tf.compat.v1.Session&lt;/code&gt;&lt;/a&gt; for more information on launching a graph and on sessions.</source>
          <target state="translated">この便利なメソッドには、この変数を含むグラフが起動されているセッションが必要です。セッションが渡されない場合、デフォルトのセッションが使用されます。グラフの起動とセッションの詳細については、&lt;a href=&quot;compat/v1/session&quot;&gt; &lt;code&gt;tf.compat.v1.Session&lt;/code&gt; &lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="69597b8afaecf26bf780e17dbe96db99a176f9db" translate="yes" xml:space="preserve">
          <source>This convenience method requires a session where the graph containing this variable has been launched. If no session is passed, the default session is used. See &lt;a href=&quot;session&quot;&gt;&lt;code&gt;tf.compat.v1.Session&lt;/code&gt;&lt;/a&gt; for more information on launching a graph and on sessions.</source>
          <target state="translated">この便利なメソッドには、この変数を含むグラフが起動されているセッションが必要です。セッションが渡されない場合、デフォルトのセッションが使用されます。グラフの起動とセッションの詳細については、&lt;a href=&quot;session&quot;&gt; &lt;code&gt;tf.compat.v1.Session&lt;/code&gt; &lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="049bd1098346a19ff3fab486ff6a7b47c3fd7819" translate="yes" xml:space="preserve">
          <source>This creates a &lt;code&gt;LinearOperator&lt;/code&gt; of the form &lt;code&gt;A = L + U D V^H&lt;/code&gt;, with &lt;code&gt;L&lt;/code&gt; a &lt;code&gt;LinearOperator&lt;/code&gt;, &lt;code&gt;U, V&lt;/code&gt; both [batch] matrices, and &lt;code&gt;D&lt;/code&gt; a [batch] diagonal matrix.</source>
          <target state="translated">これは、作成 &lt;code&gt;LinearOperator&lt;/code&gt; 形態の &lt;code&gt;A = L + U D V^H&lt;/code&gt; 用いて、 &lt;code&gt;L&lt;/code&gt; &lt;code&gt;LinearOperator&lt;/code&gt; 、 &lt;code&gt;U, V&lt;/code&gt; の両方[バッチ]行列、および &lt;code&gt;D&lt;/code&gt; [バッチ]対角行列。</target>
        </trans-unit>
        <trans-unit id="20e733fb47526c81e38b7224224a075d45127bb0" translate="yes" xml:space="preserve">
          <source>This creates a named directory on disk that is isolated to this test, and will be properly cleaned up by the test. This avoids several pitfalls of creating temporary directories for test purposes, as well as makes it easier to setup directories and verify their contents.</source>
          <target state="translated">これにより、ディスク上にこのテスト用に隔離された名前付きディレクトリが作成され、テストによって適切にクリーンアップされます。これにより、テスト目的で一時的なディレクトリを作成する際のいくつかの落とし穴を回避し、ディレクトリの設定や内容の検証が容易になります。</target>
        </trans-unit>
        <trans-unit id="63a4f566bb13c25047e12750280d68497191b0d8" translate="yes" xml:space="preserve">
          <source>This creates a named directory on disk that is isolated to this test, and will be properly cleaned up by the test. This avoids several pitfalls of creating temporary directories for test purposes, as well as makes it easier to setup directories and verify their contents. For example:</source>
          <target state="translated">これにより、ディスク上にこのテスト用に隔離された名前付きディレクトリが作成され、テストによって適切にクリーンアップされます。これにより、テスト目的で一時的なディレクトリを作成することによるいくつかの落とし穴を回避し、ディレクトリのセットアップやその内容の検証が容易になります。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="75714df8d9550841d3043fbd62dad500169275e6" translate="yes" xml:space="preserve">
          <source>This creates a named file on disk that is isolated to this test, and will be properly cleaned up by the test. This avoids several pitfalls of creating temporary files for test purposes, as well as makes it easier to setup files, their data, read them back, and inspect them when a test fails.</source>
          <target state="translated">これにより、ディスク上に名前付きファイルが作成されます。これにより、テスト目的のために一時ファイルを作成することによるいくつかの落とし穴を回避することができます。</target>
        </trans-unit>
        <trans-unit id="2f4f8ffa306c5f0499e24ea63e1e0e690360c7a3" translate="yes" xml:space="preserve">
          <source>This creates a named file on disk that is isolated to this test, and will be properly cleaned up by the test. This avoids several pitfalls of creating temporary files for test purposes, as well as makes it easier to setup files, their data, read them back, and inspect them when a test fails. For example:</source>
          <target state="translated">これにより、ディスク上に名前付きファイルが作成されます。これにより、テスト目的のために一時ファイルを作成することによるいくつかの落とし穴を回避できます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="42646afd71d42ede988399add1a74a5f6b4c93c2" translate="yes" xml:space="preserve">
          <source>This creates a tuple of tensors with the same values as the &lt;code&gt;tensors&lt;/code&gt; argument, except that the value of each tensor is only returned after the values of all tensors have been computed.</source>
          <target state="translated">これにより、すべてのテンソルの値が計算された後にのみ各テンソルの値が返されることを除いて、 &lt;code&gt;tensors&lt;/code&gt; 引数と同じ値を持つテンソルのタプルが作成されます。</target>
        </trans-unit>
        <trans-unit id="89651a110f241aba282c0d3c4d5816a82b95a5ce" translate="yes" xml:space="preserve">
          <source>This dataset attempts to determine whether a valid snapshot exists at the &lt;code&gt;snapshot_path&lt;/code&gt;, and reads from the snapshot in lieu of using &lt;code&gt;input_dataset&lt;/code&gt;. If not, it will run the preprocessing pipeline as usual, and write out a snapshot of the data processed for future use.</source>
          <target state="translated">このデータセットは、 &lt;code&gt;snapshot_path&lt;/code&gt; に有効なスナップショットが存在するかどうかを判別しようとし、 &lt;code&gt;input_dataset&lt;/code&gt; を使用する代わりにスナップショットから読み取ります。そうでない場合は、通常どおり前処理パイプラインを実行し、将来の使用のために処理されたデータのスナップショットを書き出します。</target>
        </trans-unit>
        <trans-unit id="f9dc1c4d1a56233dc4a8e886da12f3f0a495623a" translate="yes" xml:space="preserve">
          <source>This dataset fills a buffer with &lt;code&gt;buffer_size&lt;/code&gt; elements, then randomly samples elements from this buffer, replacing the selected elements with new elements. For perfect shuffling, a buffer size greater than or equal to the full size of the dataset is required.</source>
          <target state="translated">このデータセットは、バッファーを &lt;code&gt;buffer_size&lt;/code&gt; 要素で満たし、次にこのバッファーから要素をランダムにサンプリングして、選択した要素を新しい要素で置き換えます。完全なシャッフルには、データセットのフルサイズ以上のバッファーサイズが必要です。</target>
        </trans-unit>
        <trans-unit id="28c299276126ace248fef26b3267fca38b82ca7a" translate="yes" xml:space="preserve">
          <source>This dataset has been superseded by &lt;code&gt;ParallelInterleaveDatasetV2&lt;/code&gt;. New code should use &lt;code&gt;ParallelInterleaveDatasetV2&lt;/code&gt;.</source>
          <target state="translated">このデータセットは、 &lt;code&gt;ParallelInterleaveDatasetV2&lt;/code&gt; に置き換えられました。新しいコードは &lt;code&gt;ParallelInterleaveDatasetV2&lt;/code&gt; を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="97fff19a84ee410a08999fab8be4d199f9066fdc" translate="yes" xml:space="preserve">
          <source>This dataset operator is very useful when running distributed training, as it allows each worker to read a unique subset.</source>
          <target state="translated">このデータセット演算子は、各ワーカーが一意のサブセットを読み取ることができるので、分散訓練を実行する際に非常に便利です。</target>
        </trans-unit>
        <trans-unit id="0601b18d7846c9e12aa36064d4b2b93f04fe9903" translate="yes" xml:space="preserve">
          <source>This dataset will throw a NotFound error if we cannot shard the dataset automatically.</source>
          <target state="translated">このデータセットは、データセットを自動的にシャードできない場合、NotFoundエラーをスローします。</target>
        </trans-unit>
        <trans-unit id="38966f21ae4fd315566bc2e9e41902f2d11ad1fd" translate="yes" xml:space="preserve">
          <source>This decorator allows fine grained control over the gradients of a sequence for operations. This may be useful for multiple reasons, including providing a more efficient or numerically stable gradient for a sequence of operations.</source>
          <target state="translated">このデコレータは、操作のためのシーケンスの勾配を細かく制御することを可能にする。これは、一連の操作に対して、より効率的なグラデーションや数値的に安定したグラデーションを提供することなど、複数の理由で有用です。</target>
        </trans-unit>
        <trans-unit id="507c4c48f689d10862643a9c65b8ad1497b61251" translate="yes" xml:space="preserve">
          <source>This decorator injects the decorated class or function into the Keras custom object dictionary, so that it can be serialized and deserialized without needing an entry in the user-provided custom object dict. It also injects a function that Keras will call to get the object's serializable string key.</source>
          <target state="translated">このデコレータは、デコレーションされたクラスや関数をKerasのカスタムオブジェクト辞書に注入し、ユーザが提供するカスタムオブジェクトディクショナリのエントリを必要とせずにシリアライズやデシリアライズができるようにします。また、Keras がオブジェクトのシリアライズ可能な文字列キーを取得するために呼び出す関数を注入します。</target>
        </trans-unit>
        <trans-unit id="99ba7a22516d6648f4353818a77d3239c06fe661" translate="yes" xml:space="preserve">
          <source>This decorator is only used when defining a new op type. For an op with &lt;code&gt;m&lt;/code&gt; inputs and &lt;code&gt;n&lt;/code&gt; outputs, the gradient function is a function that takes the original &lt;code&gt;Operation&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt;&lt;code&gt;Tensor&lt;/code&gt; objects (representing the gradients with respect to each output of the op), and returns &lt;code&gt;m&lt;/code&gt;&lt;code&gt;Tensor&lt;/code&gt; objects (representing the partial gradients with respect to each input of the op).</source>
          <target state="translated">このデコレータは、新しいopタイプを定義するときにのみ使用されます。 &lt;code&gt;m&lt;/code&gt; 個の入力と &lt;code&gt;n&lt;/code&gt; 個の出力を持つopの場合、勾配関数は、元の &lt;code&gt;Operation&lt;/code&gt; オブジェクトと &lt;code&gt;n&lt;/code&gt; 個の &lt;code&gt;Tensor&lt;/code&gt; オブジェクト（opの各出力に関する勾配を表す）を取り、 &lt;code&gt;m&lt;/code&gt; 個の &lt;code&gt;Tensor&lt;/code&gt; オブジェクト（部分的な勾配を表す）を返す関数ですopの各入力に関して）。</target>
        </trans-unit>
        <trans-unit id="f69390eec43b9170084ec67f23f7df44213faadc" translate="yes" xml:space="preserve">
          <source>This defines the skeleton for all implementations of ClusterResolvers. ClusterResolvers are a way for TensorFlow to communicate with various cluster management systems (e.g. GCE, AWS, etc...) and gives TensorFlow necessary information to set up distributed training.</source>
          <target state="translated">これは、ClusterResolversのすべての実装のスケルトンを定義します。ClusterResolversはTensorFlowが様々なクラスタ管理システム(GCE、AWSなど)と通信するための手段であり、TensorFlowに分散訓練をセットアップするために必要な情報を与えます。</target>
        </trans-unit>
        <trans-unit id="31c4ff795b26f67c26110ef2a390028f451d7769" translate="yes" xml:space="preserve">
          <source>This defines the skeleton for all implementations of ClusterResolvers. ClusterResolvers are a way for TensorFlow to communicate with various cluster management systems (e.g. GCE, AWS, etc...).</source>
          <target state="translated">これは、ClusterResolversのすべての実装のスケルトンを定義します。ClusterResolversはTensorFlowが様々なクラスタ管理システム(GCE、AWSなど)と通信するための方法です。</target>
        </trans-unit>
        <trans-unit id="0df31e40439c17db3321616e25b535cdb0316252" translate="yes" xml:space="preserve">
          <source>This definition of cell differs from the definition used in the literature. In the literature, 'cell' refers to an object with a single scalar output. This definition refers to a horizontal array of such units.</source>
          <target state="translated">このセルの定義は、文献で使用されている定義とは異なる。文献では、「セル」は単一のスカラー出力を持つオブジェクトを指す。この定義では、このような単位の水平配列を指す。</target>
        </trans-unit>
        <trans-unit id="0725a72c209eb53df1440f5a39a25dbf2ab21a14" translate="yes" xml:space="preserve">
          <source>This distribution has parameters: degree of freedom &lt;code&gt;df&lt;/code&gt;, location &lt;code&gt;loc&lt;/code&gt;, and &lt;code&gt;scale&lt;/code&gt;.</source>
          <target state="translated">この分布には、自由度 &lt;code&gt;df&lt;/code&gt; 、位置 &lt;code&gt;loc&lt;/code&gt; 、 &lt;code&gt;scale&lt;/code&gt; パラメーターがあります。</target>
        </trans-unit>
        <trans-unit id="11a222f9738197dadd6eb7c453e22ae24d0f3567" translate="yes" xml:space="preserve">
          <source>This does not close the session.</source>
          <target state="translated">これはセッションを閉じません。</target>
        </trans-unit>
        <trans-unit id="e3bddf2a09aebf2b7d2bb27cde671e8328a7dc27" translate="yes" xml:space="preserve">
          <source>This does not undo the effects of loss scaling. Any optimizers wrapped with a LossScaleOptimizer will continue to do loss scaling, although this loss scaling will no longer be useful if the optimizer is used in new Sessions, as the graph rewrite no longer converts the graph to use float16.</source>
          <target state="translated">これは、ロススケーリングの効果を元に戻すものではありません。LossScaleOptimizer でラップされたオプティマイザは、ロススケーリングを継続しますが、グラフの書き換えでグラフが float16 を使用するように変換されなくなるため、オプティマイザが新しいセッションで使用されている場合は、このロススケーリングはもはや有用ではありません。</target>
        </trans-unit>
        <trans-unit id="02c54112c729e547b6e3e03e55cab5ced9766b9c" translate="yes" xml:space="preserve">
          <source>This does not undo the effects of loss scaling. Any optimizers wrapped with a LossScaleOptimizer will continue to do loss scaling, although this loss scaling will no longer be useful, as the graph rewrite no longer converts tf.functions to use float16.</source>
          <target state="translated">これはロススケーリングの効果を元に戻すものではありません。LossScaleOptimizerでラップされたオプティマイザはロス・スケーリングを継続しますが、グラフの書き換えでtf.functionsがfloat16を使用するように変換されなくなったため、このロス・スケーリングはもはや有用ではありません。</target>
        </trans-unit>
        <trans-unit id="3bfa5300d7e625917e03fb074107ed12abbdcbbe" translate="yes" xml:space="preserve">
          <source>This eliminates the overhead of &lt;code&gt;k-1&lt;/code&gt; calls to &lt;code&gt;space_to_batch_nd&lt;/code&gt; and &lt;code&gt;batch_to_space_nd&lt;/code&gt;.</source>
          <target state="translated">これにより、 &lt;code&gt;space_to_batch_nd&lt;/code&gt; および &lt;code&gt;batch_to_space_nd&lt;/code&gt; への &lt;code&gt;k-1&lt;/code&gt; 呼び出しのオーバーヘッドが排除されます。</target>
        </trans-unit>
        <trans-unit id="4c1542adb4efbb08745cf8660782eb015be7e9a8" translate="yes" xml:space="preserve">
          <source>This enables the new behavior.</source>
          <target state="translated">これにより、新しい動作が可能になります。</target>
        </trans-unit>
        <trans-unit id="e158c4e53eb8ef556e4d562ffa77e16f6fc696bb" translate="yes" xml:space="preserve">
          <source>This enables the user to close and release the resource in the middle of a step/run.</source>
          <target state="translated">これにより、ステップ/ランの途中でリソースをクローズして解放することができます。</target>
        </trans-unit>
        <trans-unit id="b70309885ebd2feded30214b2bff057bfcef522b" translate="yes" xml:space="preserve">
          <source>This enables variables to be read as bfloat16 type when using get_variable.</source>
          <target state="translated">これにより、get_variableを使用する際に変数をbfloat16型で読み込むことができるようになります。</target>
        </trans-unit>
        <trans-unit id="9b4ec5604b14a4a73674990062864327b53e189b" translate="yes" xml:space="preserve">
          <source>This enumeration represents optional conversion options.</source>
          <target state="translated">この列挙は、オプションの変換オプションを表します。</target>
        </trans-unit>
        <trans-unit id="26d8315a3de6d7adfdf3bbd23a3ef83e0e870212" translate="yes" xml:space="preserve">
          <source>This estimator ignores feature values and will learn to predict the average value of each label. E.g. for single-label classification problems, this will predict the probability distribution of the classes as seen in the labels. For multi-label classification problems, it will predict the ratio of examples that contain each class.</source>
          <target state="translated">この推定器は特徴量を無視して、各ラベルの平均値を予測することを学習します。例えば、1つのラベルの分類問題では、ラベルから見たクラスの確率分布を予測します。マルチラベル分類問題では、各クラスを含む例の比率を予測します。</target>
        </trans-unit>
        <trans-unit id="c0a3c93652b7acdf673bb2d9770fb27696ed0299" translate="yes" xml:space="preserve">
          <source>This example creates a lookup layer and generates the vocabulary by analyzing the dataset.</source>
          <target state="translated">この例では、ルックアップ層を作成し、データセットを解析して語彙を生成します。</target>
        </trans-unit>
        <trans-unit id="a9de20f542fbd733883e56dc873754dfb758c273" translate="yes" xml:space="preserve">
          <source>This example creates a lookup layer with a pre-existing vocabulary.</source>
          <target state="translated">この例では、既存の語彙でルックアップレイヤーを作成します。</target>
        </trans-unit>
        <trans-unit id="c0b0f0177841bd64344b603ca5701c7a1c4bfeec" translate="yes" xml:space="preserve">
          <source>This example demonstrates how to map indices to strings using this layer. (You can also use adapt() with inverse=True, but for simplicity we'll pass the vocab in this example.)</source>
          <target state="translated">この例では、このレイヤーを使ってインデックスを文字列にマッピングする方法を示しています。(inverse=True を指定して adapt()を使用することもできますが、簡単のためにこの例ではボキャブを渡しています)。</target>
        </trans-unit>
        <trans-unit id="3a755e66edb0249a30f62c3fbfa9da1107d08395" translate="yes" xml:space="preserve">
          <source>This example demonstrates how to map indices to values using this layer. (You can also use adapt() with inverse=True, but for simplicity we'll pass the vocab in this example.)</source>
          <target state="translated">この例では、このレイヤーを使ってインデックスを値にマッピングする方法を示しています。(inverse=True を指定して adapt()を使用することもできますが、簡単のためにこの例ではボキャブラリーを渡します)</target>
        </trans-unit>
        <trans-unit id="494bbe4febd153531076a3e5cddcbab4e936bc24" translate="yes" xml:space="preserve">
          <source>This example demonstrates how to use a lookup layer with multiple OOV tokens. When a layer is created with more than one OOV token, any OOV values are hashed into the number of OOV buckets, distributing OOV values in a deterministic fashion across the set.</source>
          <target state="translated">この例は、複数の OOV トークンを持つルックアップ・レイヤーの使用方法を示しています。複数のOOVトークンを持つレイヤが作成されると、任意のOOV値がOOVバケットの数だけハッシュ化され、OOV値がセット全体に決定論的に分配されます。</target>
        </trans-unit>
        <trans-unit id="69a4365d2fc53f53ca98893f19670abd4d1d2032" translate="yes" xml:space="preserve">
          <source>This example demonstrates how to use the vocabulary of a standard lookup layer to create an inverse lookup layer.</source>
          <target state="translated">この例では、標準ルックアップレイヤーの語彙を使って逆ルックアップレイヤーを作成する方法を示しています。</target>
        </trans-unit>
        <trans-unit id="a68786f5a17b7958b628ee0e8691b24f56ab38dc" translate="yes" xml:space="preserve">
          <source>This example gives binary output instead of counting the occurrence.</source>
          <target state="translated">この例では、発生をカウントする代わりにバイナリ出力を行います。</target>
        </trans-unit>
        <trans-unit id="3f03708fe58a6d112475001cb64ef56af4e257ac" translate="yes" xml:space="preserve">
          <source>This example instantiates a TextVectorization layer that lowercases text, splits on whitespace, strips punctuation, and outputs integer vocab indices.</source>
          <target state="translated">この例では、テキストを小文字にし、空白で分割し、句読点を削除し、整数のボキャブラリーインデックスを出力する TextVectorization レイヤをインスタンス化します。</target>
        </trans-unit>
        <trans-unit id="ee52f3666629477330cedb91ea1ff2368d33cc78" translate="yes" xml:space="preserve">
          <source>This example shows how to instantiate a layer that applies the same dense operation to every element in a sequence, but uses the ellipsis notation instead of specifying the batch and sequence dimensions.</source>
          <target state="translated">この例では、シーケンス内のすべての要素に同じ密な操作を適用するレイヤーをインスタンス化する方法を示していますが、バッチ寸法とシーケンス寸法を指定する代わりにエリプシス記法を使用しています。</target>
        </trans-unit>
        <trans-unit id="0d7af74c46a4fae38ce9ff64ebe601e504aada00" translate="yes" xml:space="preserve">
          <source>This example shows how to instantiate a layer that applies the same dense operation to every element in a sequence. Here, the 'output_shape' has two values (since there are two non-batch dimensions in the output); the first dimension in the output_shape is &lt;code&gt;None&lt;/code&gt;, because the sequence dimension &lt;code&gt;b&lt;/code&gt; has an unknown shape.</source>
          <target state="translated">この例は、シーケンス内のすべての要素に同じ密な操作を適用するレイヤーをインスタンス化する方法を示しています。ここで、「output_shape」には2つの値があります（出力には2つの非バッチ次元があるため）。シーケンス次元 &lt;code&gt;b&lt;/code&gt; の形状が不明であるため、output_shapeの最初の次元は &lt;code&gt;None&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="a7e9f20f12802c04c896151951f7fd5800246d6c" translate="yes" xml:space="preserve">
          <source>This example shows how to instantiate a standard Keras dense layer using einsum operations. This example is equivalent to &lt;a href=&quot;../dense&quot;&gt;&lt;code&gt;tf.keras.layers.Dense(64, use_bias=True)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この例は、einsum操作を使用して標準のKeras高密度レイヤーをインスタンス化する方法を示しています。この例は、&lt;a href=&quot;../dense&quot;&gt; &lt;code&gt;tf.keras.layers.Dense(64, use_bias=True)&lt;/code&gt; &lt;/a&gt;と同等です。</target>
        </trans-unit>
        <trans-unit id="bf32128894beae4e1d5986c66f68269f1ae0857f" translate="yes" xml:space="preserve">
          <source>This example takes a 2 dimensional input and returns a &lt;code&gt;Tensor&lt;/code&gt; with bincounting on each sample.</source>
          <target state="translated">この例では、2次元の入力を受け取り、各サンプルのビンカウントを使用して &lt;code&gt;Tensor&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="8f9c3d77008f03aede1949e1e8b86cf490084ce8" translate="yes" xml:space="preserve">
          <source>This example takes an input (which could be a Tensor, RaggedTensor, or SparseTensor) and returns a SparseTensor where (i,j) is 1 if the value j appears in batch i at least once and is 0 otherwise. Note that, even though some values (like 20 in batch 1 and 11 in batch 2) appear more than once, the 'values' tensor is all 1s.</source>
          <target state="translated">この例では、入力(テンソル、ラグドテンソル、スパーステンソルのいずれか)を受け取り、(i,j)が1で、(i,j)がバッチiに1回以上出現した場合は1、そうでない場合は0となるスパーステンソルを返します。一部の値(バッチ1では20、バッチ2では11)が複数回出現していても、'values'テンソルはすべて1であることに注意してください。</target>
        </trans-unit>
        <trans-unit id="d3981b34919fca04a3be3649adee342abfe3505a" translate="yes" xml:space="preserve">
          <source>This example takes an input (which could be a Tensor, RaggedTensor, or SparseTensor) and returns a SparseTensor where the value of (i,j) is the number of times value j appears in batch i.</source>
          <target state="translated">この例では、入力(テンソル、ラグドテンソル、スパーステンソルのいずれか)を取り、(i,j)の値がバッチiに値jが出現した回数であるスパーステンソルを返します。</target>
        </trans-unit>
        <trans-unit id="8dd04c77a84f7fb7b79c65a0782e87dc8901b29b" translate="yes" xml:space="preserve">
          <source>This example takes an input (which could be a Tensor, RaggedTensor, or SparseTensor) and returns a SparseTensor where the value of (i,j) is the number of times value j appears in batch i. However, all values of j above 'maxlength' are ignored. The dense_shape of the output sparse tensor is set to 'minlength'. Note that, while the input is identical to the example above, the value '10001' in batch item 2 is dropped, and the dense shape is [2, 500] instead of [2,10002] or [2, 102].</source>
          <target state="translated">この例では、入力(Tensor、RaggedTensor、SparseTensorのいずれか)を取り、(i,j)の値がバッチiでの値jの出現回数であるSparseTensorを返します。出力されるスパーステンソルのdense_shapeは'minlength'に設定されます。入力は上の例と同じであるが、バッチ項目2の値'10001'は削除され、密な形状は[2,10002]や[2,102]ではなく[2,500]になることに注意してください。</target>
        </trans-unit>
        <trans-unit id="9ad6c7816616b3241d748e89b2cfcff037903efa" translate="yes" xml:space="preserve">
          <source>This example takes two inputs - a values tensor and a weights tensor. These tensors must be identically shaped, and have the same row splits or indices in the case of RaggedTensors or SparseTensors. When performing a weighted count, the op will output a SparseTensor where the value of (i, j) is the sum of the values in the weight tensor's batch i in the locations where the values tensor has the value j. In this case, the output dtype is the same as the dtype of the weights tensor.</source>
          <target state="translated">この例では、値テンソルと重みテンソルの2つの入力を取ります。これらのテンソルは,同じ形をしていなければならず,RaggedTensorsやSparseTensorsの場合は,同じ行分割またはインデックスを持ちます.重み付きカウントを実行する場合、opは、(i,j)の値が、値テンソルが値jを持つ場所の重みテンソルのバッチiの値の合計であるスパーステンソルを出力します。</target>
        </trans-unit>
        <trans-unit id="3b8a0001b21c834c94ffc58110b29147780ed1bc" translate="yes" xml:space="preserve">
          <source>This exception is most commonly raised when running an operation that reads a &lt;a href=&quot;../variable&quot;&gt;&lt;code&gt;tf.Variable&lt;/code&gt;&lt;/a&gt; before it has been initialized.</source>
          <target state="translated">この例外は、初期化される前に&lt;a href=&quot;../variable&quot;&gt; &lt;code&gt;tf.Variable&lt;/code&gt; &lt;/a&gt;を読み取る操作を実行するときに最も一般的に発生します。</target>
        </trans-unit>
        <trans-unit id="5c5a8c57c6d5ff0bef6c24b2e2bd3f673907515f" translate="yes" xml:space="preserve">
          <source>This exception is not currently used.</source>
          <target state="translated">この例外は現在使用されていません。</target>
        </trans-unit>
        <trans-unit id="f99d6b607eb42d98eb52dda612321114e3e91d9d" translate="yes" xml:space="preserve">
          <source>This exception is raised in &quot;end-of-file&quot; conditions, such as when a &lt;code&gt;tf.QueueBase.dequeue&lt;/code&gt; operation is blocked on an empty queue, and a &lt;code&gt;tf.QueueBase.close&lt;/code&gt; operation executes.</source>
          <target state="translated">この例外は、 &lt;code&gt;tf.QueueBase.dequeue&lt;/code&gt; 操作が空のキューでブロックされ、 &lt;code&gt;tf.QueueBase.close&lt;/code&gt; 操作が実行される場合など、「ファイルの終わり」条件で発生します。</target>
        </trans-unit>
        <trans-unit id="78d71c0636a2aa1fd087c8298d2d2e031276f9b2" translate="yes" xml:space="preserve">
          <source>This exception is raised when some invariant expected by the runtime has been broken. Catching this exception is not recommended.</source>
          <target state="translated">この例外は、ランタイムが期待する不変量が壊れた場合に発生します。この例外をキャッチすることは推奨されません。</target>
        </trans-unit>
        <trans-unit id="7057b737e9dfe1ba0218e510ec51533edf1eab95" translate="yes" xml:space="preserve">
          <source>This exists primarily to support the definition of type-specific summary ops like scalar() and image(), and is not intended for direct use unless defining a new type-specific summary op.</source>
          <target state="translated">これは主に scalar()や image()のような型固有のサマリー演算の定義をサポートするために存在し、新しい型固有のサマリー演算を定義しない限り、直接使用することは意図されていません。</target>
        </trans-unit>
        <trans-unit id="42562f80c79b3f19581dfb21136c32f3ec5adea4" translate="yes" xml:space="preserve">
          <source>This facilitates a cleaner api around global state. Instead of</source>
          <target state="translated">これにより、グローバルな状態の周りのよりクリーンな api が容易になります。の代わりに</target>
        </trans-unit>
        <trans-unit id="b7cea24b85385b2c626baad7c000ac087d0ac17d" translate="yes" xml:space="preserve">
          <source>This file includes functions and constants from core (model_utils) and export.py</source>
          <target state="translated">このファイルには、core (model_utils)と export.py の関数と定数が含まれています。</target>
        </trans-unit>
        <trans-unit id="1ed5997b223ee14f22d4d6301133fe48a3becd70" translate="yes" xml:space="preserve">
          <source>This flag will have a value of None, True or False. None is possible if default=None and the user does not specify the flag on the command line.</source>
          <target state="translated">このフラグの値は None、True または False です。Noneは、default=Noneでユーザがコマンドラインでフラグを指定していない場合に可能です。</target>
        </trans-unit>
        <trans-unit id="edc3e42fb098d2f82cf52f313f0a2bbc39d59acf" translate="yes" xml:space="preserve">
          <source>This foldl operator repeatedly applies the callable &lt;code&gt;fn&lt;/code&gt; to a sequence of elements from first to last. The elements are made of the tensors unpacked from &lt;code&gt;elems&lt;/code&gt; on dimension 0. The callable fn takes two tensors as arguments. The first argument is the accumulated value computed from the preceding invocation of fn, and the second is the value at the current position of &lt;code&gt;elems&lt;/code&gt;. If &lt;code&gt;initializer&lt;/code&gt; is None, &lt;code&gt;elems&lt;/code&gt; must contain at least one element, and its first element is used as the initializer.</source>
          <target state="translated">このfoldl演算子は、呼び出し可能な &lt;code&gt;fn&lt;/code&gt; を最初から最後まで一連の要素に繰り返し適用します。要素がテンソルで作られていますからアンパック &lt;code&gt;elems&lt;/code&gt; 次元に0呼び出し可能なFNは、引数として2つのテンソルをとります。最初の引数は、前のfnの呼び出しから計算された累積値で、2番目の引数は、現在の &lt;code&gt;elems&lt;/code&gt; の位置の値です。 &lt;code&gt;initializer&lt;/code&gt; がNoneの場合、 &lt;code&gt;elems&lt;/code&gt; には少なくとも1つの要素が含まれている必要があり、その最初の要素が初期化子として使用されます。</target>
        </trans-unit>
        <trans-unit id="5c9efc4e60690682d054976cd526187b0ec74f90" translate="yes" xml:space="preserve">
          <source>This foldr operator repeatedly applies the callable &lt;code&gt;fn&lt;/code&gt; to a sequence of elements from last to first. The elements are made of the tensors unpacked from &lt;code&gt;elems&lt;/code&gt;. The callable fn takes two tensors as arguments. The first argument is the accumulated value computed from the preceding invocation of fn, and the second is the value at the current position of &lt;code&gt;elems&lt;/code&gt;. If &lt;code&gt;initializer&lt;/code&gt; is None, &lt;code&gt;elems&lt;/code&gt; must contain at least one element, and its first element is used as the initializer.</source>
          <target state="translated">このfoldr演算子は、呼び出し可能な &lt;code&gt;fn&lt;/code&gt; を最後から最初の要素のシーケンスに繰り返し適用します。要素は、要素から &lt;code&gt;elems&lt;/code&gt; たテンソルでできています。呼び出し可能なfnは2つのテンソルを引数として取ります。最初の引数は、前のfnの呼び出しから計算された累積値で、2番目の引数は、現在の &lt;code&gt;elems&lt;/code&gt; の位置の値です。 &lt;code&gt;initializer&lt;/code&gt; がNoneの場合、 &lt;code&gt;elems&lt;/code&gt; には少なくとも1つの要素が含まれている必要があり、その最初の要素が初期化子として使用されます。</target>
        </trans-unit>
        <trans-unit id="e47bc5be6551c40b285b99814572b5e2b249a8b5" translate="yes" xml:space="preserve">
          <source>This function adds operations to the current session. To compute the error using a particular device, such as a GPU, use the standard methods for setting a device (e.g. using with sess.graph.device() or setting a device function in the session constructor).</source>
          <target state="translated">この関数は現在のセッションに操作を追加します。GPUなどの特定のデバイスを使用してエラーを計算するには、デバイスを設定する標準的な方法を使用します(例:sess.graph.device()を使用したり、セッションのコンストラクタでdevice関数を設定したりします)。</target>
        </trans-unit>
        <trans-unit id="b1c988623a891fbccad5b0fbb3db51dcb83f9a90" translate="yes" xml:space="preserve">
          <source>This function adds the following to the current &lt;code&gt;Graph&lt;/code&gt;:</source>
          <target state="translated">この関数は、現在の &lt;code&gt;Graph&lt;/code&gt; 以下を追加します。</target>
        </trans-unit>
        <trans-unit id="7391056d9f36003196c437fbb04f6186eed40dde" translate="yes" xml:space="preserve">
          <source>This function allows expressing computations in a TensorFlow graph as Python functions. In particular, it wraps a Python function &lt;code&gt;func&lt;/code&gt; in a once-differentiable TensorFlow operation that executes it with eager execution enabled. As a consequence, &lt;a href=&quot;py_function&quot;&gt;&lt;code&gt;tf.py_function&lt;/code&gt;&lt;/a&gt; makes it possible to express control flow using Python constructs (&lt;code&gt;if&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt;, etc.), instead of TensorFlow control flow constructs (&lt;a href=&quot;cond&quot;&gt;&lt;code&gt;tf.cond&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;while_loop&quot;&gt;&lt;code&gt;tf.while_loop&lt;/code&gt;&lt;/a&gt;). For example, you might use &lt;a href=&quot;py_function&quot;&gt;&lt;code&gt;tf.py_function&lt;/code&gt;&lt;/a&gt; to implement the log huber function:</source>
          <target state="translated">この関数を使用すると、TensorFlowグラフの計算をPython関数として表現できます。特に、Python関数 &lt;code&gt;func&lt;/code&gt; を、かつて微分可能なTensorFlow演算にラップして、積極的実行を有効にして実行します。その結果、&lt;a href=&quot;py_function&quot;&gt; &lt;code&gt;tf.py_function&lt;/code&gt; &lt;/a&gt;を使用すると、TensorFlow制御フロー構造体（&lt;a href=&quot;cond&quot;&gt; &lt;code&gt;tf.cond&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;while_loop&quot;&gt; &lt;code&gt;tf.while_loop&lt;/code&gt; &lt;/a&gt;）ではなく、Python構造体（ &lt;code&gt;if&lt;/code&gt; 、 &lt;code&gt;while&lt;/code&gt; 、 &lt;code&gt;for&lt;/code&gt; など）を使用して制御フローを表現できます。たとえば、&lt;a href=&quot;py_function&quot;&gt; &lt;code&gt;tf.py_function&lt;/code&gt; &lt;/a&gt;を使用してログハブ機能を実装できます。</target>
        </trans-unit>
        <trans-unit id="fa49b9c5fb3cc27a08b15ff4c8fbc286bffc2bb3" translate="yes" xml:space="preserve">
          <source>This function allows replacing a function wrapped by &lt;code&gt;decorator_func&lt;/code&gt;, assuming the decorator that wraps the function is written as described below.</source>
          <target state="translated">この関数は、によってラップ関数交換可能 &lt;code&gt;decorator_func&lt;/code&gt; を以下に説明するように機能をラップするデコレータが書き込まれると仮定すると、。</target>
        </trans-unit>
        <trans-unit id="f1af1fe4443bcb9edf1df9ce5ca5cc1b073069a3" translate="yes" xml:space="preserve">
          <source>This function also returns a &lt;code&gt;should_apply_gradients&lt;/code&gt; bool. If False, gradients should not be applied to the variables that step, as nonfinite gradients were found, and the loss scale has been be updated to reduce the chance of finding nonfinite gradients in the next step. Some loss scale classes will always return True, as they cannot adjust themselves in response to nonfinite gradients.</source>
          <target state="translated">この関数は、 &lt;code&gt;should_apply_gradients&lt;/code&gt; bool も返します。Falseの場合、非有限の勾配が検出されたため、勾配をステップする変数に適用しないでください。次のステップで非有限の勾配を検出する可能性を減らすために損失スケールが更新されました。一部の損失スケールクラスは、非有限勾配に応じて自身を調整できないため、常にTrueを返します。</target>
        </trans-unit>
        <trans-unit id="a970dd1ee86d1ed9e7a0f4a5fcb3e14f9903fdf2" translate="yes" xml:space="preserve">
          <source>This function assumes that &lt;code&gt;img1&lt;/code&gt; and &lt;code&gt;img2&lt;/code&gt; are image batches, i.e. the last three dimensions are [height, width, channels].</source>
          <target state="translated">この関数は、 &lt;code&gt;img1&lt;/code&gt; と &lt;code&gt;img2&lt;/code&gt; がイメージバッチであること、つまり最後の3つの次元が[高さ、幅、チャネル]であることを前提としています。</target>
        </trans-unit>
        <trans-unit id="05e4418b517bd473a485966680131f4c4c444d83" translate="yes" xml:space="preserve">
          <source>This function attempts to partially evaluate the given tensor, and returns its value as a numpy ndarray if this succeeds.</source>
          <target state="translated">この関数は,与えられたテンソルを部分的に評価し,成功した場合はその値を numpy ndarray として返します.</target>
        </trans-unit>
        <trans-unit id="cf86c424c057435bb07a468ed262a1bc87e5ff48" translate="yes" xml:space="preserve">
          <source>This function can be called at the beginning of the program (before &lt;code&gt;Tensors&lt;/code&gt;, &lt;code&gt;Graphs&lt;/code&gt; or other structures have been created, and before devices have been initialized. It switches all global behaviors that are different between TensorFlow 1.x and 2.x to behave as intended for 1.x.</source>
          <target state="translated">この関数は、プログラムの最初（ &lt;code&gt;Tensors&lt;/code&gt; 、 &lt;code&gt;Graphs&lt;/code&gt; などの構造が作成される前、およびデバイスが初期化される前に）で呼び出すことができます。これは、TensorFlow 1.xと2.xの間で異なるすべてのグローバル動作を切り替えて、次のように動作します1.xを対象としています。</target>
        </trans-unit>
        <trans-unit id="10057d11c28687d408d56022580e8ea6fe2a793b" translate="yes" xml:space="preserve">
          <source>This function can be called at the beginning of the program (before &lt;code&gt;Tensors&lt;/code&gt;, &lt;code&gt;Graphs&lt;/code&gt; or other structures have been created, and before devices have been initialized. It switches all global behaviors that are different between TensorFlow 1.x and 2.x to behave as intended for 2.x.</source>
          <target state="translated">この関数は、プログラムの最初（ &lt;code&gt;Tensors&lt;/code&gt; 、 &lt;code&gt;Graphs&lt;/code&gt; などの構造が作成される前、およびデバイスが初期化される前に）で呼び出すことができます。これは、TensorFlow 1.xと2.xの間で異なるすべてのグローバル動作を切り替えて、次のように動作します2.xを対象としています。</target>
        </trans-unit>
        <trans-unit id="b42e569daa67e0a1534f20b78d521ba43e71fa0e" translate="yes" xml:space="preserve">
          <source>This function can be used to calculate a suitable paddings argument for use with space_to_batch_nd and batch_to_space_nd.</source>
          <target state="translated">この関数は、 space_to_batch_nd および batch_to_space_nd で使用するための適切なパディング引数を計算するために使用することができます。</target>
        </trans-unit>
        <trans-unit id="c744362e6d55098ce01656aff7353b51e78a3f8e" translate="yes" xml:space="preserve">
          <source>This function can be useful when composing a new operation in Python (such as &lt;code&gt;my_func&lt;/code&gt; in the example above). All standard Python op constructors apply this function to each of their Tensor-valued inputs, which allows those ops to accept numpy arrays, Python lists, and scalars in addition to &lt;code&gt;Tensor&lt;/code&gt; objects.</source>
          <target state="translated">この関数は、Pythonで新しい操作を作成するときに役立ちます（上記の例の &lt;code&gt;my_func&lt;/code&gt; など）。すべての標準Python opコンストラクターは、この関数をTensor値の入力のそれぞれに適用します。これにより、これらのopsは、 &lt;code&gt;Tensor&lt;/code&gt; オブジェクトに加えて、numpy配列、Pythonリスト、スカラーを受け入れることができます。</target>
        </trans-unit>
        <trans-unit id="217d0b2441a5002feaf4d45bd68846f61852099e" translate="yes" xml:space="preserve">
          <source>This function can compute several different vector norms (the 1-norm, the Euclidean or 2-norm, the inf-norm, and in general the p-norm for p &amp;gt; 0) and matrix norms (Frobenius, 1-norm, 2-norm and inf-norm).</source>
          <target state="translated">この関数は、いくつかの異なるベクトルノルム（1ノルム、ユークリッドまたは2ノルム、infノルム、および一般にp&amp;gt; 0のpノルム）と行列ノルム（Frobenius、1-ノルム、2- normおよびinf-norm）。</target>
        </trans-unit>
        <trans-unit id="3ea434ce2125739c9300b55f884e2363f68836bb" translate="yes" xml:space="preserve">
          <source>This function can only be called before any Graphs, Ops, or Tensors have been created. It can be used at the beginning of the program for complex migration projects from TensorFlow 1.x to 2.x.</source>
          <target state="translated">この関数は、グラフ、オペレーション、テンソルが作成される前にのみ呼び出すことができます。この関数は、TensorFlow 1.xから2.xへの複雑な移行プロジェクトにプログラムの最初に使用できます。</target>
        </trans-unit>
        <trans-unit id="588718f27309c0577e10569b211613b30b1126d6" translate="yes" xml:space="preserve">
          <source>This function casts the input to &lt;code&gt;dtype&lt;/code&gt; without applying any scaling. If there is a danger that values would over or underflow in the cast, this op applies the appropriate clamping before the cast.</source>
          <target state="translated">この関数は、スケーリングを適用せずに入力を &lt;code&gt;dtype&lt;/code&gt; にキャストします。キャストで値がオーバーフローまたはアンダーフローする危険がある場合、この操作はキャストの前に適切なクランプを適用します。</target>
        </trans-unit>
        <trans-unit id="09decee67bf539dd150a70f2c58935c601acb068" translate="yes" xml:space="preserve">
          <source>This function computes the exponential of every element in the input tensor. i.e. &lt;code&gt;exp(x)&lt;/code&gt; or &lt;code&gt;e^(x)&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; is the input tensor. &lt;code&gt;e&lt;/code&gt; denotes Euler's number and is approximately equal to 2.718281. Output is positive for any real input.</source>
          <target state="translated">この関数は、入力テンソルのすべての要素の指数を計算します。つまり、 &lt;code&gt;exp(x)&lt;/code&gt; または &lt;code&gt;e^(x)&lt;/code&gt; 。ここで、 &lt;code&gt;x&lt;/code&gt; は入力テンソルです。 &lt;code&gt;e&lt;/code&gt; はオイラー数を表し、約2.718281です。実際の入力に対して出力は正です。</target>
        </trans-unit>
        <trans-unit id="5fcc9bd16353155f925829234fcc96a9dbe0c86d" translate="yes" xml:space="preserve">
          <source>This function computes the exponential of the input tensor element-wise. i.e. &lt;a href=&quot;exp&quot;&gt;&lt;code&gt;math.exp(x)&lt;/code&gt;&lt;/a&gt; or \(e^x\), where &lt;code&gt;x&lt;/code&gt; is the input tensor. \(e\) denotes Euler's number and is approximately equal to 2.718281. Output is positive for any real input.</source>
          <target state="translated">この関数は、入力テンソルの指数を要素ごとに計算します。つまり、&lt;a href=&quot;exp&quot;&gt; &lt;code&gt;math.exp(x)&lt;/code&gt; &lt;/a&gt;または\（e ^ x \）です。ここで、 &lt;code&gt;x&lt;/code&gt; は入力テンソルです。\（e \）はオイラーの数を示し、2.718281にほぼ等しくなります。出力は、実際の入力に対して正です。</target>
        </trans-unit>
        <trans-unit id="7c0a191a50e5e9af59c01d8569f306fc43d930b1" translate="yes" xml:space="preserve">
          <source>This function computes the matrix logarithm using the Schur-Parlett algorithm. Details of the algorithm can be found in Section 11.6.2 of: Nicholas J. Higham, Functions of Matrices: Theory and Computation, SIAM 2008. ISBN 978-0-898716-46-7.</source>
          <target state="translated">この関数は,Schur-Parlett アルゴリズムを用いて行列の対数を計算します.このアルゴリズムの詳細は、以下のセクション11.6.2に記載されています。Nicholas J.Higham,Functions of Matrices.理論と計算,SIAM 2008.ISBN 978-0-898716-46-7.</target>
        </trans-unit>
        <trans-unit id="be1f544dd8e61bda50e9ba11ee30c7fa32e6f8ea" translate="yes" xml:space="preserve">
          <source>This function converts Python objects of various types to &lt;code&gt;Tensor&lt;/code&gt; objects. It accepts &lt;code&gt;Tensor&lt;/code&gt; objects, numpy arrays, Python lists, and Python scalars. For example:</source>
          <target state="translated">この関数は、さまざまなタイプのPythonオブジェクトを &lt;code&gt;Tensor&lt;/code&gt; オブジェクトに変換します。 &lt;code&gt;Tensor&lt;/code&gt; オブジェクト、numpy配列、Pythonリスト、Pythonスカラーを受け入れます。例えば：</target>
        </trans-unit>
        <trans-unit id="e487da37eb7d13adb8d956491efcafe1ed6b6abd" translate="yes" xml:space="preserve">
          <source>This function creates a new Generator object (and the Variable object within), which does not work well with tf.function because (1) tf.function puts restrictions on Variable creation thus reset_global_generator can't be freely used inside tf.function; (2) redirecting a global variable to a new object is problematic with tf.function because the old object may be captured by a 'tf.function'ed function and still be used by it. A 'tf.function'ed function only keeps weak references to variables, so deleting a variable and then calling that function again may raise an error, as demonstrated by random_test.py/RandomTest.testResetGlobalGeneratorBadWithDefun .</source>
          <target state="translated">(1)tf.function は変数の作成に制限をかけているため、tf.function の中では reset_global_generator を自由に使うことができません。tf.function'ed 関数は変数への弱い参照を保持しているだけなので、変数を削除してから再度その関数を呼び出すとエラーが発生する可能性があります(random_test.py/RandomTest.testResetResetGolableGeneratorBadWithDefun .</target>
        </trans-unit>
        <trans-unit id="7bd8be377fdf00edb4e98ffd4a0d17d3f66c21a2" translate="yes" xml:space="preserve">
          <source>This function divides &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, forcing Python 2 semantics. That is, if &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are both integers then the result will be an integer. This is in contrast to Python 3, where division with &lt;code&gt;/&lt;/code&gt; is always a float while division with &lt;code&gt;//&lt;/code&gt; is always an integer.</source>
          <target state="translated">この関数は &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; を分割し、Python 2のセマンティクスを強制します。つまり、 &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; が両方とも整数の場合、結果は整数になります。これは、との除算のPython 3とは対照的である &lt;code&gt;/&lt;/code&gt; が有する除算しながら常にフロートである &lt;code&gt;//&lt;/code&gt; は常に整数です。</target>
        </trans-unit>
        <trans-unit id="d24aa00a66ce40fc5a2092349ae7643f400f331a" translate="yes" xml:space="preserve">
          <source>This function enables you to use a &lt;a href=&quot;../dataset&quot;&gt;&lt;code&gt;tf.data.Dataset&lt;/code&gt;&lt;/a&gt; in a stateless &quot;tensor-in tensor-out&quot; expression, without creating a &lt;a href=&quot;../../compat/v1/data/iterator&quot;&gt;&lt;code&gt;tf.compat.v1.data.Iterator&lt;/code&gt;&lt;/a&gt;. This can be useful when your preprocessing transformations are expressed as a &lt;code&gt;Dataset&lt;/code&gt;, and you want to use the transformation at serving time. For example:</source>
          <target state="translated">この機能は、あなたが使用することができます&lt;a href=&quot;../dataset&quot;&gt; &lt;code&gt;tf.data.Dataset&lt;/code&gt; を&lt;/a&gt;作成せず、ステートレス「テンソルインテンソルアウト」という表現で&lt;a href=&quot;../../compat/v1/data/iterator&quot;&gt; &lt;code&gt;tf.compat.v1.data.Iterator&lt;/code&gt; を&lt;/a&gt;。これは、前処理変換が &lt;code&gt;Dataset&lt;/code&gt; として表現されており、提供時に変換を使用する場合に役立ちます。例えば：</target>
        </trans-unit>
        <trans-unit id="dcd4ee76305c19cb19df5a4e6d70410c1e1185ec" translate="yes" xml:space="preserve">
          <source>This function enables you to use a &lt;a href=&quot;../dataset&quot;&gt;&lt;code&gt;tf.data.Dataset&lt;/code&gt;&lt;/a&gt; in a stateless &quot;tensor-in tensor-out&quot; expression, without creating an iterator. This can be useful when your preprocessing transformations are expressed as a &lt;code&gt;Dataset&lt;/code&gt;, and you want to use the transformation at serving time.</source>
          <target state="translated">この関数を使用すると、イテレータを作成せずに、ステートレスの「テンソルインテンソルアウト」式で&lt;a href=&quot;../dataset&quot;&gt; &lt;code&gt;tf.data.Dataset&lt;/code&gt; &lt;/a&gt;を使用できます。これは、前処理変換が &lt;code&gt;Dataset&lt;/code&gt; として表現されており、サービング時に変換を使用する場合に役立ちます。</target>
        </trans-unit>
        <trans-unit id="43245fcf24b3e5f89c388ed18c02c0b4b9e1fd8d" translate="yes" xml:space="preserve">
          <source>This function enqueues a structure of features to be looked up in the embedding tables. We expect that the batch size of each of the tensors in features matches the per core batch size. This will automatically happen if your input dataset is batched to the global batch size and you use &lt;a href=&quot;../../../distribute/tpustrategy&quot;&gt;&lt;code&gt;tf.distribute.TPUStrategy&lt;/code&gt;&lt;/a&gt;'s &lt;code&gt;experimental_distribute_dataset&lt;/code&gt; or if you use &lt;code&gt;experimental_distribute_datasets_from_function&lt;/code&gt; and batch to the per core batch size computed by the context passed to your input function.</source>
          <target state="translated">この関数は、埋め込みテーブルで検索される機能の構造をキューに入れます。機能内の各テンソルのバッチサイズは、コアごとのバッチサイズと一致すると予想されます。これは、入力データセットがグローバルバッチサイズにバッチ処理され、&lt;a href=&quot;../../../distribute/tpustrategy&quot;&gt; &lt;code&gt;tf.distribute.TPUStrategy&lt;/code&gt; &lt;/a&gt;の &lt;code&gt;experimental_distribute_dataset&lt;/code&gt; を使用する場合、または &lt;code&gt;experimental_distribute_datasets_from_function&lt;/code&gt; を使用して、入力関数に渡されるコンテキストによって計算されたコアごとのバッチサイズにバッチ処理する場合に自動的に発生します。</target>
        </trans-unit>
        <trans-unit id="af17991dd15e2b7fa7774cc8e8187690043ab3dd" translate="yes" xml:space="preserve">
          <source>This function exists only for backwards compatibility purposes; new code should use &lt;code&gt;__floordiv__&lt;/code&gt; via the syntax &lt;code&gt;x // y&lt;/code&gt;. Using &lt;code&gt;x // y&lt;/code&gt; communicates clearly that the result rounds down, and is forward compatible to Python 3.</source>
          <target state="translated">この関数は、下位互換性の目的でのみ存在します。新しいコードは、構文 &lt;code&gt;x // y&lt;/code&gt; 介して &lt;code&gt;__floordiv__&lt;/code&gt; を使用する必要があります。 &lt;code&gt;x // y&lt;/code&gt; を使用すると、結果が切り捨てられ、Python 3との上位互換性があることが明確に伝えられます。</target>
        </trans-unit>
        <trans-unit id="1a2f6439e571c218e4f990c2f6f9f31b011962aa" translate="yes" xml:space="preserve">
          <source>This function exists only to have a better error message. Instead of: &lt;code&gt;TypeError: unsupported operand type(s) for /: 'Dimension' and 'int'&lt;/code&gt;, this function will explicitly call for usage of &lt;code&gt;//&lt;/code&gt; instead.</source>
          <target state="translated">この関数は、より適切なエラーメッセージを表示するためにのみ存在します。 &lt;code&gt;TypeError: unsupported operand type(s) for /: 'Dimension' and 'int'&lt;/code&gt; 代わりに、この関数は代わりに &lt;code&gt;//&lt;/code&gt; の使用を明示的に呼び出します。</target>
        </trans-unit>
        <trans-unit id="6bf09410a9b47558afad7eb9fc6a9929885c6dd9" translate="yes" xml:space="preserve">
          <source>This function exists only to have a better error message. Instead of: &lt;code&gt;TypeError: unsupported operand type(s) for /: 'int' and 'Dimension'&lt;/code&gt;, this function will explicitly call for usage of &lt;code&gt;//&lt;/code&gt; instead.</source>
          <target state="translated">この関数は、より適切なエラーメッセージを表示するためにのみ存在します。 &lt;code&gt;TypeError: unsupported operand type(s) for /: 'int' and 'Dimension'&lt;/code&gt; 代わりに、この関数は代わりに &lt;code&gt;//&lt;/code&gt; の使用を明示的に呼び出します。</target>
        </trans-unit>
        <trans-unit id="7046a2ab2d223422699f2f1db88f8efbcff064ed" translate="yes" xml:space="preserve">
          <source>This function exports the graph, saver, and collection objects into &lt;code&gt;MetaGraphDef&lt;/code&gt; protocol buffer with the intention of it being imported at a later time or location to restart training, run inference, or be a subgraph.</source>
          <target state="translated">この関数は、グラフ、セーバー、およびコレクションオブジェクトを &lt;code&gt;MetaGraphDef&lt;/code&gt; プロトコルバッファーにエクスポートし、後でインポートすることで、トレーニングを再開したり、推論を実行したり、サブグラフにすることを意図しています。</target>
        </trans-unit>
        <trans-unit id="7a855742752eb51788b391963ce908a091cbe366" translate="yes" xml:space="preserve">
          <source>This function follows the &lt;a href=&quot;http://htk.eng.cam.ac.uk/&quot;&gt;Hidden Markov Model Toolkit (HTK)&lt;/a&gt; convention, defining the mel scale in terms of a frequency in hertz according to the following formula:</source>
          <target state="translated">この関数は、&lt;a href=&quot;http://htk.eng.cam.ac.uk/&quot;&gt;隠れマルコフモデルツールキット（HTK）の&lt;/a&gt;規則に従い、次の式に従ってヘルツ単位の周波数でメル尺度を定義します。</target>
        </trans-unit>
        <trans-unit id="6a27fb60b44269b202e3c908e7cb802642c2ac28" translate="yes" xml:space="preserve">
          <source>This function forces Python 3 division operator semantics where all integer arguments are cast to floating types first. This op is generated by normal &lt;code&gt;x / y&lt;/code&gt; division in Python 3 and in Python 2.7 with &lt;code&gt;from __future__ import division&lt;/code&gt;. If you want integer division that rounds down, use &lt;code&gt;x // y&lt;/code&gt; or &lt;code&gt;tf.math.floordiv&lt;/code&gt;.</source>
          <target state="translated">この関数は、すべての整数引数が最初に浮動小数点型にキャストされるPython 3除算演算子セマンティクスを強制します。この &lt;code&gt;from __future__ import division&lt;/code&gt; は、Python 3およびPython 2.7の通常の &lt;code&gt;x / y&lt;/code&gt; 除算により、__ future__インポート除算により生成されます。 &lt;code&gt;tf.math.floordiv&lt;/code&gt; 整数除算が必要な場合は、 &lt;code&gt;x // y&lt;/code&gt; またはtf.math.floordivを使用します。</target>
        </trans-unit>
        <trans-unit id="4d4720bce15c58196c687612f77168d6737d499a" translate="yes" xml:space="preserve">
          <source>This function generalizes the &lt;a href=&quot;non_max_suppression&quot;&gt;&lt;code&gt;tf.image.non_max_suppression&lt;/code&gt;&lt;/a&gt; op by also supporting a Soft-NMS (with Gaussian weighting) mode (c.f. Bodla et al, https://arxiv.org/abs/1704.04503) where boxes reduce the score of other overlapping boxes instead of directly causing them to be pruned. Consequently, in contrast to &lt;a href=&quot;non_max_suppression&quot;&gt;&lt;code&gt;tf.image.non_max_suppression&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;non_max_suppression_padded&quot;&gt;&lt;code&gt;tf.image.non_max_suppression_padded&lt;/code&gt;&lt;/a&gt; returns the new scores of each input box in the second output, &lt;code&gt;selected_scores&lt;/code&gt;.</source>
          <target state="translated">この関数は、&lt;a href=&quot;non_max_suppression&quot;&gt; &lt;code&gt;tf.image.non_max_suppression&lt;/code&gt; &lt;/a&gt;が他の重複するボックスのスコアを減らすSoft-NMS（ガウス重み付け付き）モード（Bodla et al、https：//arxiv.org/abs/1704.04503を参照）もサポートすることにより、tf.image.non_max_suppressionopを一般化します。それらを直接剪定させる代わりに。したがって、&lt;a href=&quot;non_max_suppression&quot;&gt; &lt;code&gt;tf.image.non_max_suppression&lt;/code&gt; &lt;/a&gt;とは対照的に、&lt;a href=&quot;non_max_suppression_padded&quot;&gt; &lt;code&gt;tf.image.non_max_suppression_padded&lt;/code&gt; &lt;/a&gt;は、2番目の出力である &lt;code&gt;selected_scores&lt;/code&gt; の各入力ボックスの新しいスコアを返します。</target>
        </trans-unit>
        <trans-unit id="b139bf71180b25aa620a27f39c22f066fe31fcf7" translate="yes" xml:space="preserve">
          <source>This function generalizes the &lt;a href=&quot;non_max_suppression&quot;&gt;&lt;code&gt;tf.image.non_max_suppression&lt;/code&gt;&lt;/a&gt; op by also supporting a Soft-NMS (with Gaussian weighting) mode (c.f. Bodla et al, https://arxiv.org/abs/1704.04503) where boxes reduce the score of other overlapping boxes instead of directly causing them to be pruned. Consequently, in contrast to &lt;a href=&quot;non_max_suppression&quot;&gt;&lt;code&gt;tf.image.non_max_suppression&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;tf.image.non_max_suppression_v2&lt;/code&gt; returns the new scores of each input box in the second output, &lt;code&gt;selected_scores&lt;/code&gt;.</source>
          <target state="translated">この関数は、&lt;a href=&quot;non_max_suppression&quot;&gt; &lt;code&gt;tf.image.non_max_suppression&lt;/code&gt; &lt;/a&gt; opを一般化し、ボックスが他の重複するボックスのスコアを減らすSoft-NMS（ガウス重み付き）モード（Bodla et al、https：//arxiv.org/abs/1704.04503を参照）もサポートします。それらを直接剪定するのではなく、したがって、&lt;a href=&quot;non_max_suppression&quot;&gt; &lt;code&gt;tf.image.non_max_suppression&lt;/code&gt; &lt;/a&gt;とは対照的に、 &lt;code&gt;tf.image.non_max_suppression_v2&lt;/code&gt; は、2番目の出力 &lt;code&gt;selected_scores&lt;/code&gt; の各入力ボックスの新しいスコアを返します。</target>
        </trans-unit>
        <trans-unit id="1f78cfdbddd70d6ebd322125da902964ca2c0221" translate="yes" xml:space="preserve">
          <source>This function generates a weighted sum based on output dimension &lt;code&gt;units&lt;/code&gt;. Weighted sum refers to logits in classification problems. It refers to the prediction itself for linear regression problems.</source>
          <target state="translated">この関数は、出力次元 &lt;code&gt;units&lt;/code&gt; 基づいて加重和を生成します。加重和は、分類問題のロジットを指します。線形回帰問題の予測自体を指します。</target>
        </trans-unit>
        <trans-unit id="b7164aa4227947230adf26e333ecf50d207f9d4e" translate="yes" xml:space="preserve">
          <source>This function ignores flags whose value is None. Each flag assignment is separated by a newline.</source>
          <target state="translated">この関数は、値が None のフラグを無視します。各フラグの割り当ては改行で区切られています。</target>
        </trans-unit>
        <trans-unit id="0c81aeff7442b1d7f71d30de1b5da89dfe187de7" translate="yes" xml:space="preserve">
          <source>This function in addition also allows assignment to a sliced range. This is similar to &lt;code&gt;__setitem__&lt;/code&gt; functionality in Python. However, the syntax is different so that the user can capture the assignment operation for grouping or passing to &lt;code&gt;sess.run()&lt;/code&gt;. For example,</source>
          <target state="translated">さらに、この関数は、スライスされた範囲への割り当ても可能にします。これはPythonの &lt;code&gt;__setitem__&lt;/code&gt; 機能に似ています。ただし、構文が異なるため、ユーザーは &lt;code&gt;sess.run()&lt;/code&gt; にグループ化または渡すための割り当て操作をキャプチャできます。例えば、</target>
        </trans-unit>
        <trans-unit id="f477dc6f411c004d0b07e1741886385a8bad1741" translate="yes" xml:space="preserve">
          <source>This function is a more primitive version of &lt;code&gt;dynamic_rnn&lt;/code&gt; that provides more direct access to the inputs each iteration. It also provides more control over when to start and finish reading the sequence, and what to emit for the output.</source>
          <target state="translated">この関数は &lt;code&gt;dynamic_rnn&lt;/code&gt; のより基本的なバージョンであり、反復ごとに入力へのより直接的なアクセスを提供します。また、シーケンスの読み取りを開始および終了するタイミングと、出力のために何を出力するかをより詳細に制御できます。</target>
        </trans-unit>
        <trans-unit id="b35cb926e7e56c5e0bb4984bfdd19c6c71696446" translate="yes" xml:space="preserve">
          <source>This function is a simpler wrapper around the more general &lt;a href=&quot;convolution&quot;&gt;&lt;code&gt;tf.nn.convolution&lt;/code&gt;&lt;/a&gt;, and exists only for backwards compatibility. You can use &lt;a href=&quot;convolution&quot;&gt;&lt;code&gt;tf.nn.convolution&lt;/code&gt;&lt;/a&gt; to perform 1-D, 2-D, or 3-D atrous convolution.</source>
          <target state="translated">この関数は、より一般的な&lt;a href=&quot;convolution&quot;&gt; &lt;code&gt;tf.nn.convolution&lt;/code&gt; の&lt;/a&gt;単純なラッパーであり、下位互換性のためにのみ存在します。&lt;a href=&quot;convolution&quot;&gt; &lt;code&gt;tf.nn.convolution&lt;/code&gt; &lt;/a&gt;を使用して、1次元、2次元、または3次元のアストロ畳み込みを実行できます。</target>
        </trans-unit>
        <trans-unit id="1fde94a598e8772eaea3cc47dd741a3aa23b5c85" translate="yes" xml:space="preserve">
          <source>This function is analogous to &lt;a href=&quot;https://docs.scipy.org/doc/numpy/reference/generated/numpy.linalg.pinv.html&quot;&gt;&lt;code&gt;numpy.linalg.pinv&lt;/code&gt;&lt;/a&gt;. It differs only in default value of &lt;code&gt;rcond&lt;/code&gt;. In &lt;code&gt;numpy.linalg.pinv&lt;/code&gt;, the default &lt;code&gt;rcond&lt;/code&gt; is &lt;code&gt;1e-15&lt;/code&gt;. Here the default is &lt;code&gt;10. * max(num_rows, num_cols) * np.finfo(dtype).eps&lt;/code&gt;.</source>
          <target state="translated">この関数は&lt;a href=&quot;https://docs.scipy.org/doc/numpy/reference/generated/numpy.linalg.pinv.html&quot;&gt; &lt;code&gt;numpy.linalg.pinv&lt;/code&gt; に&lt;/a&gt;似ています。 &lt;code&gt;rcond&lt;/code&gt; のデフォルト値のみが異なります。で &lt;code&gt;numpy.linalg.pinv&lt;/code&gt; 、デフォルトの &lt;code&gt;rcond&lt;/code&gt; ある &lt;code&gt;1e-15&lt;/code&gt; 。ここでのデフォルトは &lt;code&gt;10. * max(num_rows, num_cols) * np.finfo(dtype).eps&lt;/code&gt; です。* max（num_rows、num_cols）* np.finfo（dtype）.eps。</target>
        </trans-unit>
        <trans-unit id="c82b17de9fe920f72f7a5369e74c77b8a5f75d81" translate="yes" xml:space="preserve">
          <source>This function is based on the standard SSIM implementation from: Wang, Z., Bovik, A. C., Sheikh, H. R., &amp;amp; Simoncelli, E. P. (2004). Image quality assessment: from error visibility to structural similarity. IEEE transactions on image processing.</source>
          <target state="translated">この関数は、Wang、Z.、Bovik、AC、Sheikh、HR、＆Simoncelli、EP（2004）の標準SSIM実装に基づいています。画質評価：エラーの可視性から構造の類似性まで。画像処理に関するIEEEトランザクション。</target>
        </trans-unit>
        <trans-unit id="3f78f322021258197ee0401af332233d4fb6c937" translate="yes" xml:space="preserve">
          <source>This function is cached the first time &lt;a href=&quot;../model#evaluate&quot;&gt;&lt;code&gt;Model.evaluate&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../model#test_on_batch&quot;&gt;&lt;code&gt;Model.test_on_batch&lt;/code&gt;&lt;/a&gt; is called. The cache is cleared whenever &lt;a href=&quot;../model#compile&quot;&gt;&lt;code&gt;Model.compile&lt;/code&gt;&lt;/a&gt; is called.</source>
          <target state="translated">この関数は、&lt;a href=&quot;../model#evaluate&quot;&gt; &lt;code&gt;Model.evaluate&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;../model#test_on_batch&quot;&gt; &lt;code&gt;Model.test_on_batch&lt;/code&gt; &lt;/a&gt;が最初に呼び出されたときにキャッシュされます。&lt;a href=&quot;../model#compile&quot;&gt; &lt;code&gt;Model.compile&lt;/code&gt; &lt;/a&gt;が呼び出されるたびに、キャッシュはクリアされます。</target>
        </trans-unit>
        <trans-unit id="03d4062526248415274d1920f151d5925ea1d106" translate="yes" xml:space="preserve">
          <source>This function is cached the first time &lt;a href=&quot;../model#fit&quot;&gt;&lt;code&gt;Model.fit&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../model#train_on_batch&quot;&gt;&lt;code&gt;Model.train_on_batch&lt;/code&gt;&lt;/a&gt; is called. The cache is cleared whenever &lt;a href=&quot;../model#compile&quot;&gt;&lt;code&gt;Model.compile&lt;/code&gt;&lt;/a&gt; is called.</source>
          <target state="translated">この関数は、&lt;a href=&quot;../model#fit&quot;&gt; &lt;code&gt;Model.fit&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;../model#train_on_batch&quot;&gt; &lt;code&gt;Model.train_on_batch&lt;/code&gt; &lt;/a&gt;が最初に呼び出されたときにキャッシュされます。&lt;a href=&quot;../model#compile&quot;&gt; &lt;code&gt;Model.compile&lt;/code&gt; &lt;/a&gt;が呼び出されるたびに、キャッシュはクリアされます。</target>
        </trans-unit>
        <trans-unit id="a73ed236f67dee6103073403c6d29f26833958d9" translate="yes" xml:space="preserve">
          <source>This function is cached the first time &lt;a href=&quot;../model#predict&quot;&gt;&lt;code&gt;Model.predict&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../model#predict_on_batch&quot;&gt;&lt;code&gt;Model.predict_on_batch&lt;/code&gt;&lt;/a&gt; is called. The cache is cleared whenever &lt;a href=&quot;../model#compile&quot;&gt;&lt;code&gt;Model.compile&lt;/code&gt;&lt;/a&gt; is called.</source>
          <target state="translated">この関数は、&lt;a href=&quot;../model#predict&quot;&gt; &lt;code&gt;Model.predict&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;../model#predict_on_batch&quot;&gt; &lt;code&gt;Model.predict_on_batch&lt;/code&gt; &lt;/a&gt;が最初に呼び出されたときにキャッシュされます。&lt;a href=&quot;../model#compile&quot;&gt; &lt;code&gt;Model.compile&lt;/code&gt; &lt;/a&gt;が呼び出されるたびに、キャッシュはクリアされます。</target>
        </trans-unit>
        <trans-unit id="9c02b98872d235ad42d3656b50ce22017eda7ff2" translate="yes" xml:space="preserve">
          <source>This function is cached the first time &lt;a href=&quot;model#evaluate&quot;&gt;&lt;code&gt;Model.evaluate&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;model#test_on_batch&quot;&gt;&lt;code&gt;Model.test_on_batch&lt;/code&gt;&lt;/a&gt; is called. The cache is cleared whenever &lt;a href=&quot;model#compile&quot;&gt;&lt;code&gt;Model.compile&lt;/code&gt;&lt;/a&gt; is called.</source>
          <target state="translated">この関数は、&lt;a href=&quot;model#evaluate&quot;&gt; &lt;code&gt;Model.evaluate&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;model#test_on_batch&quot;&gt; &lt;code&gt;Model.test_on_batch&lt;/code&gt; &lt;/a&gt;が最初に呼び出されたときにキャッシュされます。&lt;a href=&quot;model#compile&quot;&gt; &lt;code&gt;Model.compile&lt;/code&gt; &lt;/a&gt;が呼び出されるたびに、キャッシュはクリアされます。</target>
        </trans-unit>
        <trans-unit id="9d1d8a8ff69ef7a941ba68b453aec429bfe458e1" translate="yes" xml:space="preserve">
          <source>This function is cached the first time &lt;a href=&quot;model#fit&quot;&gt;&lt;code&gt;Model.fit&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;model#train_on_batch&quot;&gt;&lt;code&gt;Model.train_on_batch&lt;/code&gt;&lt;/a&gt; is called. The cache is cleared whenever &lt;a href=&quot;model#compile&quot;&gt;&lt;code&gt;Model.compile&lt;/code&gt;&lt;/a&gt; is called.</source>
          <target state="translated">この関数は、&lt;a href=&quot;model#fit&quot;&gt; &lt;code&gt;Model.fit&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;model#train_on_batch&quot;&gt; &lt;code&gt;Model.train_on_batch&lt;/code&gt; &lt;/a&gt;が最初に呼び出されたときにキャッシュされます。&lt;a href=&quot;model#compile&quot;&gt; &lt;code&gt;Model.compile&lt;/code&gt; &lt;/a&gt;が呼び出されるたびに、キャッシュはクリアされます。</target>
        </trans-unit>
        <trans-unit id="5d0db761a3ad75448d327cc87f61eb8b0729f377" translate="yes" xml:space="preserve">
          <source>This function is cached the first time &lt;a href=&quot;model#predict&quot;&gt;&lt;code&gt;Model.predict&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;model#predict_on_batch&quot;&gt;&lt;code&gt;Model.predict_on_batch&lt;/code&gt;&lt;/a&gt; is called. The cache is cleared whenever &lt;a href=&quot;model#compile&quot;&gt;&lt;code&gt;Model.compile&lt;/code&gt;&lt;/a&gt; is called.</source>
          <target state="translated">この関数は、&lt;a href=&quot;model#predict&quot;&gt; &lt;code&gt;Model.predict&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;model#predict_on_batch&quot;&gt; &lt;code&gt;Model.predict_on_batch&lt;/code&gt; &lt;/a&gt;が最初に呼び出されたときにキャッシュされます。&lt;a href=&quot;model#compile&quot;&gt; &lt;code&gt;Model.compile&lt;/code&gt; &lt;/a&gt;が呼び出されるたびに、キャッシュはクリアされます。</target>
        </trans-unit>
        <trans-unit id="ecacc04269db8f28f91780c2b346f24c2d101704" translate="yes" xml:space="preserve">
          <source>This function is called between epochs/steps, when a metric is evaluated during training.</source>
          <target state="translated">この関数は,訓練中にメトリックが評価される場合に,エポック/ステップ間で呼び出されます.</target>
        </trans-unit>
        <trans-unit id="a75cbe1aa934dcb50e2537aae264b28dbab09250" translate="yes" xml:space="preserve">
          <source>This function is called by FLAGS(argv). It scans the input list for a flag that looks like: --flagfile=</source>
          <target state="translated">この関数はFLAGS(argv)によって呼び出されます。入力リストをスキャンして、次のようなフラグを探します。--flagfile=</target>
        </trans-unit>
        <trans-unit id="e57b5dff2b7e230f6a359d3b07cb810778cc3047" translate="yes" xml:space="preserve">
          <source>This function is called in the main TensorFlow &lt;code&gt;__init__.py&lt;/code&gt; file, user should not need to call it, except during complex migrations.</source>
          <target state="translated">この関数はメインのTensorFlow &lt;code&gt;__init__.py&lt;/code&gt; ファイルで呼び出されます。複雑な移行中を除いて、ユーザーが呼び出す必要はありません。</target>
        </trans-unit>
        <trans-unit id="0831cfa041ba84a9c1bb953a8575728ee9dbe8bf" translate="yes" xml:space="preserve">
          <source>This function is faster and numerically stabler than &lt;code&gt;bessel_i0(x)&lt;/code&gt;.</source>
          <target state="translated">この関数は、 &lt;code&gt;bessel_i0(x)&lt;/code&gt; より高速で数値的に安定しています。</target>
        </trans-unit>
        <trans-unit id="1f2e499db54e57708a372078c16af5df37036099" translate="yes" xml:space="preserve">
          <source>This function is faster and numerically stabler than &lt;code&gt;bessel_i1(x)&lt;/code&gt;.</source>
          <target state="translated">この関数は、 &lt;code&gt;bessel_i1(x)&lt;/code&gt; より高速で、数値的に安定しています。</target>
        </trans-unit>
        <trans-unit id="d7e374cf0f52d98689ddb22ec7b9e2a428cd4956" translate="yes" xml:space="preserve">
          <source>This function is implemented using a queue. A &lt;code&gt;QueueRunner&lt;/code&gt; for the queue is added to the current &lt;code&gt;Graph&lt;/code&gt;'s &lt;code&gt;QUEUE_RUNNER&lt;/code&gt; collection.</source>
          <target state="translated">この関数は、キューを使用して実装されます。 &lt;code&gt;QueueRunner&lt;/code&gt; キューのは、電流に加算される &lt;code&gt;Graph&lt;/code&gt; の &lt;code&gt;QUEUE_RUNNER&lt;/code&gt; のコレクション。</target>
        </trans-unit>
        <trans-unit id="4c4c3026638168daaa4ab1a3c114680f01d9d246" translate="yes" xml:space="preserve">
          <source>This function is more numerically stable than log(sum(exp(input))). It avoids overflows caused by taking the exp of large inputs and underflows caused by taking the log of small inputs.</source>
          <target state="translated">この関数は log(sum(exp(input))よりも数値的に安定しています。)大きな入力のexpを取ることによるオーバーフローや小さな入力のlogを取ることによるアンダーフローを回避します。</target>
        </trans-unit>
        <trans-unit id="80c0f02cfab4a0ee1574d2a1145f5fca28f12b11" translate="yes" xml:space="preserve">
          <source>This function is only available with the TensorFlow backend for the time being.</source>
          <target state="translated">この機能は当分の間、TensorFlowバックエンドでのみ利用可能です。</target>
        </trans-unit>
        <trans-unit id="11a7ac7f028baf06c483242a158777b17ee8b353" translate="yes" xml:space="preserve">
          <source>This function is only used when defining a new op type. It may be used for ops such as &lt;a href=&quot;size&quot;&gt;&lt;code&gt;tf.size()&lt;/code&gt;&lt;/a&gt; that are not differentiable. For example:</source>
          <target state="translated">この関数は、新しいopタイプを定義する場合にのみ使用されます。区別できない&lt;a href=&quot;size&quot;&gt; &lt;code&gt;tf.size()&lt;/code&gt; &lt;/a&gt;などの操作に使用できます。例えば：</target>
        </trans-unit>
        <trans-unit id="61969c39a3dfe9d632e8e43316d05aa062590efa" translate="yes" xml:space="preserve">
          <source>This function is part of the Keras serialization and deserialization framework. It maps objects to the string names associated with those objects for serialization/deserialization.</source>
          <target state="translated">この関数はKerasのシリアライゼーションおよびデシリアライゼーションフレームワークの一部です。この関数は、シリアライゼーション/デシリアライゼーションのために、オブジェクトをそのオブジェクトに関連付けられた文字列名にマッピングします。</target>
        </trans-unit>
        <trans-unit id="7aa4be9a74ac3f90821c5e3ef2a47e10c4dfdcb8" translate="yes" xml:space="preserve">
          <source>This function is part of the Keras serialization and deserialization framework. It maps strings to the objects associated with them for serialization/deserialization.</source>
          <target state="translated">この関数はKerasのシリアライゼーションおよびデシリアライゼーションフレームワークの一部です。シリアライズ/デシリアライズのために、文字列をそれに関連付けられたオブジェクトにマッピングします。</target>
        </trans-unit>
        <trans-unit id="577a32736f43471cd2cd1266738343fb80596d48" translate="yes" xml:space="preserve">
          <source>This function is the canonical way to get/validate an object of one of the allowed types from an external argument reference in the Session API.</source>
          <target state="translated">この関数は、Session API の外部引数参照から、許可されている型の一つのオブジェクトを取得/検証する標準的な方法です。</target>
        </trans-unit>
        <trans-unit id="130785c66d51b0bf917ff1a83e8cb5fd0234052e" translate="yes" xml:space="preserve">
          <source>This function is to generate &lt;a href=&quot;../distributedvalues&quot;&gt;&lt;code&gt;tf.distribute.DistributedValues&lt;/code&gt;&lt;/a&gt; to pass into &lt;code&gt;run&lt;/code&gt;, &lt;code&gt;reduce&lt;/code&gt;, or other methods that take distributed values when not using datasets.</source>
          <target state="translated">この関数は、&lt;a href=&quot;../distributedvalues&quot;&gt; &lt;code&gt;tf.distribute.DistributedValues&lt;/code&gt; &lt;/a&gt;を生成し &lt;code&gt;run&lt;/code&gt; 、データセットを使用しないときに分散値を取得するrun、 &lt;code&gt;reduce&lt;/code&gt; 、またはその他のメソッドに渡します。</target>
        </trans-unit>
        <trans-unit id="84ff67d2523742ed898675e46a84da4adae4f6b1" translate="yes" xml:space="preserve">
          <source>This function is to generate &lt;a href=&quot;distributedvalues&quot;&gt;&lt;code&gt;tf.distribute.DistributedValues&lt;/code&gt;&lt;/a&gt; to pass into &lt;code&gt;run&lt;/code&gt;, &lt;code&gt;reduce&lt;/code&gt;, or other methods that take distributed values when not using datasets.</source>
          <target state="translated">この関数は、&lt;a href=&quot;distributedvalues&quot;&gt; &lt;code&gt;tf.distribute.DistributedValues&lt;/code&gt; &lt;/a&gt;を生成し &lt;code&gt;run&lt;/code&gt; 、データセットを使用しないときに分散値を取得するrun、 &lt;code&gt;reduce&lt;/code&gt; 、またはその他のメソッドに渡します。</target>
        </trans-unit>
        <trans-unit id="691cc7f8251e205cf948be38afb6e034f26a2e72" translate="yes" xml:space="preserve">
          <source>This function is used to perform parallel lookups on the list of tensors in &lt;code&gt;params&lt;/code&gt;. It is a generalization of &lt;a href=&quot;../../../gather&quot;&gt;&lt;code&gt;tf.gather&lt;/code&gt;&lt;/a&gt;, where &lt;code&gt;params&lt;/code&gt; is interpreted as a partitioning of a large embedding tensor. &lt;code&gt;params&lt;/code&gt; may be a &lt;code&gt;PartitionedVariable&lt;/code&gt; as returned by using &lt;a href=&quot;../get_variable&quot;&gt;&lt;code&gt;tf.compat.v1.get_variable()&lt;/code&gt;&lt;/a&gt; with a partitioner.</source>
          <target state="translated">この関数は、 &lt;code&gt;params&lt;/code&gt; のテンソルのリストで並列ルックアップを実行するために使用されます。これは&lt;a href=&quot;../../../gather&quot;&gt; &lt;code&gt;tf.gather&lt;/code&gt; を&lt;/a&gt;一般化したもので、 &lt;code&gt;params&lt;/code&gt; は大きな埋め込みテンソルの分割として解釈されます。 &lt;code&gt;params&lt;/code&gt; は、 &lt;code&gt;PartitionedVariable&lt;/code&gt; &lt;a href=&quot;../get_variable&quot;&gt; &lt;code&gt;tf.compat.v1.get_variable()&lt;/code&gt; &lt;/a&gt;を使用して返されるPartitionedVariableの場合があります。</target>
        </trans-unit>
        <trans-unit id="4938f0a72e046cd0e52c1383bdb6cd4186015a22" translate="yes" xml:space="preserve">
          <source>This function is used to perform parallel lookups on the list of tensors in &lt;code&gt;params&lt;/code&gt;. It is a generalization of &lt;a href=&quot;../gather&quot;&gt;&lt;code&gt;tf.gather&lt;/code&gt;&lt;/a&gt;, where &lt;code&gt;params&lt;/code&gt; is interpreted as a partitioning of a large embedding tensor.</source>
          <target state="translated">この関数は、 &lt;code&gt;params&lt;/code&gt; のテンソルのリストで並列ルックアップを実行するために使用されます。これは&lt;a href=&quot;../gather&quot;&gt; &lt;code&gt;tf.gather&lt;/code&gt; の&lt;/a&gt;一般化であり、 &lt;code&gt;params&lt;/code&gt; は大きな埋め込みテンソルの分割として解釈されます。</target>
        </trans-unit>
        <trans-unit id="237e26d699d02ce05b0e4079a36fba68db8a8789" translate="yes" xml:space="preserve">
          <source>This function is used to perform parallel lookups on the list of tensors in &lt;code&gt;params&lt;/code&gt;. It is a generalization of &lt;a href=&quot;../gather&quot;&gt;&lt;code&gt;tf.gather&lt;/code&gt;&lt;/a&gt;, where &lt;code&gt;params&lt;/code&gt; is interpreted as a partitioning of a large embedding tensor. &lt;code&gt;params&lt;/code&gt; may be a &lt;code&gt;PartitionedVariable&lt;/code&gt; as returned by using &lt;a href=&quot;../compat/v1/get_variable&quot;&gt;&lt;code&gt;tf.compat.v1.get_variable()&lt;/code&gt;&lt;/a&gt; with a partitioner.</source>
          <target state="translated">この関数は、 &lt;code&gt;params&lt;/code&gt; のテンソルのリストで並列ルックアップを実行するために使用されます。これは&lt;a href=&quot;../gather&quot;&gt; &lt;code&gt;tf.gather&lt;/code&gt; を&lt;/a&gt;一般化したもので、 &lt;code&gt;params&lt;/code&gt; は大きな埋め込みテンソルの分割として解釈されます。 &lt;code&gt;params&lt;/code&gt; は、 &lt;code&gt;PartitionedVariable&lt;/code&gt; &lt;a href=&quot;../compat/v1/get_variable&quot;&gt; &lt;code&gt;tf.compat.v1.get_variable()&lt;/code&gt; &lt;/a&gt;を使用して返されるPartitionedVariableの場合があります。</target>
        </trans-unit>
        <trans-unit id="f577da20d8fc0c2379f7e51688987afe782aa9c2" translate="yes" xml:space="preserve">
          <source>This function is useful for unit testing. A unit test can test using the mixed precision graph rewrite, then disable it so future unit tests continue using float32.</source>
          <target state="translated">この関数はユニットテストに便利です。ユニットテストでは、混合精度グラフの書き換えを使用してテストを行い、それを無効にすることで、将来のユニットテストでは float32 を使用してテストを継続することができます。</target>
        </trans-unit>
        <trans-unit id="d61d06f477fe487d45a847bca66c249257c10fe4" translate="yes" xml:space="preserve">
          <source>This function is useful for unit testing. A unit tests can test using the mixed precision graph rewrite, then disable it so future unit tests continue using float32. If this is done, unit tests should not share a single session, as &lt;code&gt;enable_mixed_precision_graph_rewrite&lt;/code&gt; and &lt;code&gt;disable_mixed_precision_graph_rewrite&lt;/code&gt; have no effect on existing sessions.</source>
          <target state="translated">この関数は単体テストに役立ちます。単体テストでは、混合精度グラフの書き換えを使用してテストし、それを無効にして、今後の単体テストでfloat32を引き続き使用できます。これが行われる場合、 &lt;code&gt;enable_mixed_precision_graph_rewrite&lt;/code&gt; と &lt;code&gt;disable_mixed_precision_graph_rewrite&lt;/code&gt; は既存のセッションに影響を与えないため、単体テストは単一のセッションを共有しないでください。</target>
        </trans-unit>
        <trans-unit id="929b9d5a5eeca32709da98b98c1fa20f11f6684a" translate="yes" xml:space="preserve">
          <source>This function may be used in the &lt;code&gt;options&lt;/code&gt; argument in functions that load a SavedModel (&lt;a href=&quot;load&quot;&gt;&lt;code&gt;tf.saved_model.load&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../keras/models/load_model&quot;&gt;&lt;code&gt;tf.keras.models.load_model&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">この関数は、SavedModel（&lt;a href=&quot;load&quot;&gt; &lt;code&gt;tf.saved_model.load&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../keras/models/load_model&quot;&gt; &lt;code&gt;tf.keras.models.load_model&lt;/code&gt; &lt;/a&gt;）をロードする関数の &lt;code&gt;options&lt;/code&gt; 引数で使用できます。</target>
        </trans-unit>
        <trans-unit id="d4e537bea1c76cb2cbcdaeafa3c9baedcb0e335e" translate="yes" xml:space="preserve">
          <source>This function may be used in the &lt;code&gt;options&lt;/code&gt; argument in functions that save a SavedModel (&lt;a href=&quot;save&quot;&gt;&lt;code&gt;tf.saved_model.save&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../keras/models/save_model&quot;&gt;&lt;code&gt;tf.keras.models.save_model&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">この関数は、SavedModel（&lt;a href=&quot;save&quot;&gt; &lt;code&gt;tf.saved_model.save&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../keras/models/save_model&quot;&gt; &lt;code&gt;tf.keras.models.save_model&lt;/code&gt; &lt;/a&gt;）を保存する関数の &lt;code&gt;options&lt;/code&gt; 引数で使用できます。</target>
        </trans-unit>
        <trans-unit id="23d4449e48af4e4a9efae86d49cf037eac266df3" translate="yes" xml:space="preserve">
          <source>This function only gets the device policy for the current thread. Any subsequently started thread will again use the default policy.</source>
          <target state="translated">この関数は、現在のスレッドのデバイスポリシーのみを取得します。その後に開始されたスレッドは、デフォルトのポリシーを再び使用します。</target>
        </trans-unit>
        <trans-unit id="69c8cb582945069c7d9496b069e6902700fc7e3d" translate="yes" xml:space="preserve">
          <source>This function only sets the device policy for the current thread. Any subsequently started thread will again use the default policy.</source>
          <target state="translated">この関数は、現在のスレッドのデバイスポリシーのみを設定します。その後に起動されたスレッドは、デフォルトのポリシーを再び使用します。</target>
        </trans-unit>
        <trans-unit id="128baaf391e006514e7e2e442ed3dbb64e14a3c9" translate="yes" xml:space="preserve">
          <source>This function performs the equivalent of</source>
          <target state="translated">この関数は</target>
        </trans-unit>
        <trans-unit id="fac08ba1f46139129a2f42247910a712f1085f49" translate="yes" xml:space="preserve">
          <source>This function prefixes the name with the current variable scope and performs reuse checks. See the &lt;a href=&quot;https://tensorflow.org/guide/variables&quot;&gt;Variable Scope How To&lt;/a&gt; for an extensive description of how reusing works. Here is a basic example:</source>
          <target state="translated">この関数は、名前の前に現在の変数スコープを付け、再利用チェックを実行します。再利用の&lt;a href=&quot;https://tensorflow.org/guide/variables&quot;&gt;しくみの&lt;/a&gt;詳細については、変数スコープのハウツーを参照してください。基本的な例を次に示します。</target>
        </trans-unit>
        <trans-unit id="85bc4aa7e8b39b071c3a83bcd2bcb628b96948b5" translate="yes" xml:space="preserve">
          <source>This function produces signatures intended for use with the TensorFlow Serving Classify API (tensorflow_serving/apis/prediction_service.proto), and so constrains the input and output types to those allowed by TensorFlow Serving.</source>
          <target state="translated">この関数は、TensorFlow Serving Classify API (tensorflow_serving/apis/prediction_service.proto)での使用を意図したシグネチャを生成するため、入出力タイプをTensorFlow Servingで許可されたものに制限します。</target>
        </trans-unit>
        <trans-unit id="795898cb16fc0e553ecaa87cbe16e8417edef412" translate="yes" xml:space="preserve">
          <source>This function produces signatures intended for use with the TensorFlow Serving Predict API (tensorflow_serving/apis/prediction_service.proto). This API imposes no constraints on the input and output types.</source>
          <target state="translated">この関数は、TensorFlow Serving Predict API(tensorflow_serving/apis/prediction_service.proto)での使用を意図したシグネチャを生成します。このAPIでは、入力型と出力型に制約はありません。</target>
        </trans-unit>
        <trans-unit id="0bd91f24173f9c6c06caccaa86fb2987286936b9" translate="yes" xml:space="preserve">
          <source>This function produces signatures intended for use with the TensorFlow Serving Regress API (tensorflow_serving/apis/prediction_service.proto), and so constrains the input and output types to those allowed by TensorFlow Serving.</source>
          <target state="translated">この関数は、TensorFlow Serving Regress API(tensorflow_serving/apis/prediction_service.proto)での使用を意図したシグネチャを生成するため、入出力タイプをTensorFlow Servingで許可されたものに制限します。</target>
        </trans-unit>
        <trans-unit id="da2207550b053f2e41ed03fce80a539629a65e2e" translate="yes" xml:space="preserve">
          <source>This function provides a way to import a serialized TensorFlow &lt;a href=&quot;https://www.tensorflow.org/code/tensorflow/core/framework/graph.proto&quot;&gt;&lt;code&gt;GraphDef&lt;/code&gt;&lt;/a&gt; protocol buffer, and extract individual objects in the &lt;code&gt;GraphDef&lt;/code&gt; as &lt;a href=&quot;../tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../operation&quot;&gt;&lt;code&gt;tf.Operation&lt;/code&gt;&lt;/a&gt; objects. Once extracted, these objects are placed into the current default &lt;code&gt;Graph&lt;/code&gt;. See &lt;a href=&quot;../graph#as_graph_def&quot;&gt;&lt;code&gt;tf.Graph.as_graph_def&lt;/code&gt;&lt;/a&gt; for a way to create a &lt;code&gt;GraphDef&lt;/code&gt; proto.</source>
          <target state="translated">この関数は、シリアル化されたTensorFlow &lt;a href=&quot;https://www.tensorflow.org/code/tensorflow/core/framework/graph.proto&quot;&gt; &lt;code&gt;GraphDef&lt;/code&gt; &lt;/a&gt;プロトコルバッファーをインポートし、 &lt;code&gt;GraphDef&lt;/code&gt; 内の個々のオブジェクトを&lt;a href=&quot;../tensor&quot;&gt; &lt;code&gt;tf.Tensor&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;../operation&quot;&gt; &lt;code&gt;tf.Operation&lt;/code&gt; &lt;/a&gt;オブジェクトとして抽出する方法を提供します。抽出されると、これらのオブジェクトは現在のデフォルトの &lt;code&gt;Graph&lt;/code&gt; 配置されます。 &lt;code&gt;GraphDef&lt;/code&gt; プロトを作成する方法については、&lt;a href=&quot;../graph#as_graph_def&quot;&gt; &lt;code&gt;tf.Graph.as_graph_def&lt;/code&gt; &lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="59bf9d9f9818c530570cd3baaed9172f0b655e0a" translate="yes" xml:space="preserve">
          <source>This function raises &lt;code&gt;ValueError&lt;/code&gt; unless it can be certain that the given &lt;code&gt;tensor&lt;/code&gt; is a scalar. &lt;code&gt;ValueError&lt;/code&gt; is also raised if the shape of &lt;code&gt;tensor&lt;/code&gt; is unknown.</source>
          <target state="translated">この関数は、指定された &lt;code&gt;tensor&lt;/code&gt; がスカラーであることが確実でない限り、 &lt;code&gt;ValueError&lt;/code&gt; を発生させます。 &lt;code&gt;tensor&lt;/code&gt; の形状が不明な場合も &lt;code&gt;ValueError&lt;/code&gt; が発生します。</target>
        </trans-unit>
        <trans-unit id="22fe780c67f001ded49fb5e4133cb0847481dd48" translate="yes" xml:space="preserve">
          <source>This function receives as input a string of text and returns a list of encoded integers each corresponding to a word (or token) in the given input string.</source>
          <target state="translated">この関数は,テキストの文字列を入力として受け取り,与えられた入力文字列に含まれる単語(またはトークン)に対応するエンコードされた整数のリストを返します.</target>
        </trans-unit>
        <trans-unit id="3009d910bdcd32cff99d1458043403e12c1c254c" translate="yes" xml:space="preserve">
          <source>This function reinstantiates model state by:</source>
          <target state="translated">この関数は、モデルの状態を再インスタンス化します。</target>
        </trans-unit>
        <trans-unit id="a733b4ff78c36cb4d261221c5118416ce8061d8e" translate="yes" xml:space="preserve">
          <source>This function reinstantiates model state by: 1) loading model topology from json (this will eventually come from metagraph). 2) loading model weights from checkpoint.</source>
          <target state="translated">この関数は、以下の方法でモデルの状態を再構築します。1)jsonからモデルのトポロジーを読み込む (これは最終的にはmetagraphから取得します)。2)チェックポイントからモデルの重みを読み込む。</target>
        </trans-unit>
        <trans-unit id="ff0b45b19346e757b8eb62e1bc7385c9d06f1d69" translate="yes" xml:space="preserve">
          <source>This function returns a tensor whose elements are defined by &lt;code&gt;equation&lt;/code&gt;, which is written in a shorthand form inspired by the Einstein summation convention. As an example, consider multiplying two matrices A and B to form a matrix C. The elements of C are given by:</source>
          <target state="translated">この関数は、Einstein総和規約に触発された省略形で記述された &lt;code&gt;equation&lt;/code&gt; で要素が定義されているテンソルを返します。例として、2つの行列AとBを乗算して行列Cを形成することを検討してください。Cの要素は次のように与えられます。</target>
        </trans-unit>
        <trans-unit id="0b7b7a286f6486a214583e48df98d413e08472ce" translate="yes" xml:space="preserve">
          <source>This function should &lt;em&gt;not&lt;/em&gt; be used for operations that have a well-defined gradient that is not yet implemented.</source>
          <target state="translated">この関数は、まだ実装されていない明確に定義された勾配を持つ操作には使用し&lt;em&gt;ない&lt;/em&gt;でください。</target>
        </trans-unit>
        <trans-unit id="1b640a4c1fd849556e2182a5a501c968b01e5603" translate="yes" xml:space="preserve">
          <source>This function should contain the mathemetical logic for one step of evaluation. This typically includes the forward pass, loss calculation, and metrics updates.</source>
          <target state="translated">この関数には、評価の 1 つのステップのための数学的ロジックが含まれている必要があります。これには通常、フォワードパス、損失計算、メトリクスの更新が含まれます。</target>
        </trans-unit>
        <trans-unit id="48eea658706b62c655231b07e7ecfd12850950f0" translate="yes" xml:space="preserve">
          <source>This function should only be called during TRAIN mode.</source>
          <target state="translated">この関数はTRAINモードの時にのみ呼び出されるべきです。</target>
        </trans-unit>
        <trans-unit id="92add72d0f856bfc3fd4e7bcbf6ab90dc2a5a26d" translate="yes" xml:space="preserve">
          <source>This function specifies the device to be used for ops created/executed in a particular context. Nested contexts will inherit and also create/execute their ops on the specified device. If a specific device is not required, consider not using this function so that a device can be automatically assigned. In general the use of this function is optional. &lt;code&gt;device_name&lt;/code&gt; can be fully specified, as in &quot;/job:worker/task:1/device:cpu:0&quot;, or partially specified, containing only a subset of the &quot;/&quot;-separated fields. Any fields which are specified will override device annotations from outer scopes.</source>
          <target state="translated">この関数は、特定のコンテキストで作成/実行されるopsに使用されるデバイスを指定します。ネストされたコンテキストは、指定されたデバイスでopsを継承し、作成/実行します。特定のデバイスが必要ない場合は、デバイスを自動的に割り当てることができるように、この機能を使用しないことを検討してください。通常、この関数の使用はオプションです。 &lt;code&gt;device_name&lt;/code&gt; は、「/ job：worker / task：1 / device：cpu：0」のように完全に指定することも、「/」で区切られたフィールドのサブセットのみを含む部分的に指定することもできます。指定されたフィールドは、外部スコープからのデバイス注釈をオーバーライドします。</target>
        </trans-unit>
        <trans-unit id="c538dca8aca927a7d8bbd1b0bb2e590f6c5ad3a5" translate="yes" xml:space="preserve">
          <source>This function supports a subset of tf.gather, see tf.gather for details on usage.</source>
          <target state="translated">この関数は tf.gather のサブセットをサポートしています。</target>
        </trans-unit>
        <trans-unit id="e857d76db9c7bac209f1715cec1437cf523540d8" translate="yes" xml:space="preserve">
          <source>This function swaps half-spaces for all axes listed (defaults to all). Note that &lt;code&gt;y[0]&lt;/code&gt; is the Nyquist component only if &lt;code&gt;len(x)&lt;/code&gt; is even.</source>
          <target state="translated">この関数は、リストされているすべての軸の半空間を交換します（デフォルトはすべて）。 &lt;code&gt;len(x)&lt;/code&gt; が偶数の場合にのみ、 &lt;code&gt;y[0]&lt;/code&gt; がナイキストコンポーネントであることに注意してください。</target>
        </trans-unit>
        <trans-unit id="700dee7b88966a0547c5ef0b6e43b47147bea1dd" translate="yes" xml:space="preserve">
          <source>This function takes a &lt;code&gt;MetaGraphDef&lt;/code&gt; protocol buffer as input. If the argument is a file containing a &lt;code&gt;MetaGraphDef&lt;/code&gt; protocol buffer , it constructs a protocol buffer from the file content. The function then adds all the nodes from the &lt;code&gt;graph_def&lt;/code&gt; field to the current graph, recreates all the collections, and returns a saver constructed from the &lt;code&gt;saver_def&lt;/code&gt; field.</source>
          <target state="translated">この関数は、 &lt;code&gt;MetaGraphDef&lt;/code&gt; プロトコルバッファーを入力として受け取ります。引数が &lt;code&gt;MetaGraphDef&lt;/code&gt; プロトコルバッファを含むファイルの場合、ファイルの内容からプロトコルバッファを構築します。関数は、その後のすべてのノード追加 &lt;code&gt;graph_def&lt;/code&gt; 、現在のグラフにフィールドをすべてのコレクションを再作成し、そしてから構成セーバー返し &lt;code&gt;saver_def&lt;/code&gt; フィールド。</target>
        </trans-unit>
        <trans-unit id="fd08a12501f4bce4f0a38bb7f61e556860ac6186" translate="yes" xml:space="preserve">
          <source>This function takes in a sequence of data-points gathered at equal intervals, along with time series parameters such as length of the sequences/windows, spacing between two sequence/windows, etc., to produce batches of timeseries inputs and targets.</source>
          <target state="translated">この関数は,等間隔に収集されたデータ点のシーケンスと,シーケンス/ウィンドウの長さ,2つのシーケンス/ウィンドウ間の間隔などの時系列パラメータを取り込み,時系列入力とターゲットのバッチを生成します.</target>
        </trans-unit>
        <trans-unit id="f6d25a51ea520664ee90a7477aef16d45f240f73" translate="yes" xml:space="preserve">
          <source>This function transforms a list (of length &lt;code&gt;num_samples&lt;/code&gt;) of sequences (lists of integers) into a 2D Numpy array of shape &lt;code&gt;(num_samples, num_timesteps)&lt;/code&gt;. &lt;code&gt;num_timesteps&lt;/code&gt; is either the &lt;code&gt;maxlen&lt;/code&gt; argument if provided, or the length of the longest sequence in the list.</source>
          <target state="translated">この関数は、シーケンス（整数のリスト）のリスト（長さ &lt;code&gt;num_samples&lt;/code&gt; ）を形状の2D Numpy配列 &lt;code&gt;(num_samples, num_timesteps)&lt;/code&gt; ます。 &lt;code&gt;num_timesteps&lt;/code&gt; は、指定されている場合は &lt;code&gt;maxlen&lt;/code&gt; 引数、またはリスト内で最も長いシーケンスの長さのいずれかです。</target>
        </trans-unit>
        <trans-unit id="94fc01032dc6978adba1e0b4d64fc3f4b8d2c710" translate="yes" xml:space="preserve">
          <source>This function transforms a list of &lt;code&gt;num_samples&lt;/code&gt; sequences (lists of integers) into a 2D Numpy array of shape &lt;code&gt;(num_samples, num_timesteps)&lt;/code&gt;. &lt;code&gt;num_timesteps&lt;/code&gt; is either the &lt;code&gt;maxlen&lt;/code&gt; argument if provided, or the length of the longest sequence otherwise.</source>
          <target state="translated">この関数は、 &lt;code&gt;num_samples&lt;/code&gt; シーケンスのリスト（整数のリスト）を形状の2D Numpy配列 &lt;code&gt;(num_samples, num_timesteps)&lt;/code&gt; ます。 &lt;code&gt;num_timesteps&lt;/code&gt; は、指定されている場合は &lt;code&gt;maxlen&lt;/code&gt; 引数、そうでない場合は最も長いシーケンスの長さです。</target>
        </trans-unit>
        <trans-unit id="c60464500521000032d7d0dd44fb1270d9c6691c" translate="yes" xml:space="preserve">
          <source>This function transforms a sequence of word indexes (list of integers) into tuples of words of the form:</source>
          <target state="translated">この関数は,一連の単語インデックス(整数のリスト)をタプル形式の単語に変換します.</target>
        </trans-unit>
        <trans-unit id="109cf8b58e8d5422a5502fb692567a43d8008aa5" translate="yes" xml:space="preserve">
          <source>This function transforms a string of text into a list of words while ignoring &lt;code&gt;filters&lt;/code&gt; which include punctuations by default.</source>
          <target state="translated">この関数は、デフォルトで句読点を含む &lt;code&gt;filters&lt;/code&gt; を無視して、テキストの文字列を単語のリストに変換します。</target>
        </trans-unit>
        <trans-unit id="0cf6cff1a07ce3f9dd6dd3457b8400fd6ba9faf8" translate="yes" xml:space="preserve">
          <source>This function uses substring matching, i.e. the matching succeeds if &lt;em&gt;any&lt;/em&gt; substring of the error message matches &lt;em&gt;any&lt;/em&gt; regex in the list. This is more convenient for the user than full-string matching.</source>
          <target state="translated">この関数は部分文字列マッチングを使用します。つまり、エラーメッセージの&lt;em&gt;いずれかの&lt;/em&gt;部分文字列がリスト内の&lt;em&gt;いずれかの&lt;/em&gt;正規表現と一致する場合、マッチングは成功します。これは、文字列の完全一致よりもユーザーにとって便利です。</target>
        </trans-unit>
        <trans-unit id="6ea3c37a0724be70d72aba9456ec479ad3e1efd0" translate="yes" xml:space="preserve">
          <source>This function validates that &lt;code&gt;obj&lt;/code&gt; represents an element of this graph, and gives an informative error message if it is not.</source>
          <target state="translated">この関数は、 &lt;code&gt;obj&lt;/code&gt; がこのグラフの要素を表していることを検証し、そうでない場合は有益なエラーメッセージを表示します。</target>
        </trans-unit>
        <trans-unit id="5535ae7e49ad8d44ba9e9cbd32412f5d3383ba9d" translate="yes" xml:space="preserve">
          <source>This function will check the outermost context for the program and see if it is in eager mode. It is useful comparing to &lt;a href=&quot;../../executing_eagerly&quot;&gt;&lt;code&gt;tf.executing_eagerly()&lt;/code&gt;&lt;/a&gt;, which checks the current context and will return &lt;code&gt;False&lt;/code&gt; within a &lt;a href=&quot;../../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt; body. It can be used to build library that behave differently in eager runtime and v1 session runtime (deprecated).</source>
          <target state="translated">この関数は、プログラムの最も外側のコンテキストをチェックし、それがイーガーモードにあるかどうかを確認します。現在のコンテキストをチェックし、&lt;a href=&quot;../../function&quot;&gt; &lt;code&gt;tf.function&lt;/code&gt; &lt;/a&gt;本体内で &lt;code&gt;False&lt;/code&gt; を返す&lt;a href=&quot;../../executing_eagerly&quot;&gt; &lt;code&gt;tf.executing_eagerly()&lt;/code&gt; &lt;/a&gt;と比較すると便利です。これは、イーガーランタイムとv1セッションランタイム（非推奨）で異なる動作をするライブラリを構築するために使用できます。</target>
        </trans-unit>
        <trans-unit id="1b809c8513edcf65ff2e661e67bc392f776c9e7e" translate="yes" xml:space="preserve">
          <source>This function will create the global generator the first time it is called, and the generator will be placed at the default device at that time, so one needs to be careful when this function is first called. Using a generator placed on a less-ideal device will incur performance regression.</source>
          <target state="translated">この関数は、最初に呼び出されたときにグローバル・ジェネレーターを作成し、その時点でデフォルト・デバイスに配置されるので、この関数を最初に呼び出すときには注意が必要です。あまり理想的でないデバイスに配置されたジェネレータを使用すると、パフォーマンスが低下します。</target>
        </trans-unit>
        <trans-unit id="89bde45a9d6e8e699bac43f2a09b2f06fe6c3d12" translate="yes" xml:space="preserve">
          <source>This function will modify the tensors passed in as it adds more operations and hence changing the consumers of the operations of the input tensors.</source>
          <target state="translated">この関数は,入力されたテンソルに演算を追加し,その結果,入力テンソルの演算の消費者を変更するので,渡されたテンソルを変更します.</target>
        </trans-unit>
        <trans-unit id="e4e12e3274ef470af1606308b5afb5383f0e4373" translate="yes" xml:space="preserve">
          <source>This function works on either a single image (&lt;code&gt;image&lt;/code&gt; is a 3-D Tensor), or a batch of images (&lt;code&gt;image&lt;/code&gt; is a 4-D Tensor).</source>
          <target state="translated">この関数は、単一の画像（ &lt;code&gt;image&lt;/code&gt; は3Dテンソル）または画像のバッチ（ &lt;code&gt;image&lt;/code&gt; は4Dテンソル）で機能します。</target>
        </trans-unit>
        <trans-unit id="3bc4d91f81e39f3ea54e11412256f8f82c2a442a" translate="yes" xml:space="preserve">
          <source>This function wraps tensor placeholders in a supervised_receiver_fn with the expectation that the features and labels appear precisely as the model_fn expects them. Features and labels can therefore be dicts of tensors, or raw tensors.</source>
          <target state="translated">この関数は,特徴とラベルが model_fn が期待する通りに正確に現れることを期待して,supervised_receiver_fn でテンソルプレースホルダをラップします.そのため,特徴とラベルは,テンソルのディクショナリ,または生のテンソルにすることができます.</target>
        </trans-unit>
        <trans-unit id="390f51be88bc027febcd4f2fc680ab5ff0ecb909" translate="yes" xml:space="preserve">
          <source>This functionality can be used to remap both row vocabularies (typically, features) and column vocabularies (typically, classes) from TensorFlow checkpoints. Note that the partitioning logic relies on contiguous vocabularies corresponding to div-partitioned variables. Moreover, the underlying remapping uses an IndexTable (as opposed to an inexact CuckooTable), so client code should use the corresponding index_table_from_file() as the FeatureColumn framework does (as opposed to tf.feature_to_id(), which uses a CuckooTable).</source>
          <target state="translated">この機能は、TensorFlowチェックポイントから行のボキャブラリー(通常はフィーチャ)と列のボキャブラリー(通常はクラス)の両方をリマップするために使用することができます。パーティショニング・ロジックは、div分割された変数に対応する連続したボキャブラリーに依存していることに注意してください。さらに、基礎となるリマッピングは IndexTable を使用します(不正確な CuckooTable ではなく)ので、クライアントコードは FeatureColumn フレームワークが行うように、対応する index_table_from_file()を使用すべきです(CuckooTable を使用する tf.feature_to_id()とは対照的です)。</target>
        </trans-unit>
        <trans-unit id="061aef760e659c96c1579128f6e2913f90a85e0a" translate="yes" xml:space="preserve">
          <source>This has the effect of transforming sliding window operations into the corresponding &quot;atrous&quot; operation in which the input is sampled at the specified &lt;code&gt;dilation_rate&lt;/code&gt;.</source>
          <target state="translated">これには、スライディングウィンドウ操作を、入力が指定された &lt;code&gt;dilation_rate&lt;/code&gt; でサンプリングされる対応する「アトラス」操作に変換するという効果があります。</target>
        </trans-unit>
        <trans-unit id="10c41b6251ef0bcbec27e5d4c8ebb2292ccebcaa" translate="yes" xml:space="preserve">
          <source>This helper method provides a higher-level alternative to using &lt;code&gt;tf.contrib.summary.summary_writer_initializer_op&lt;/code&gt; and &lt;code&gt;tf.contrib.summary.graph&lt;/code&gt;.</source>
          <target state="translated">このヘルパーメソッドは、 &lt;code&gt;tf.contrib.summary.summary_writer_initializer_op&lt;/code&gt; および &lt;code&gt;tf.contrib.summary.graph&lt;/code&gt; を使用するより高レベルの代替手段を提供します。</target>
        </trans-unit>
        <trans-unit id="671c9eb768ee498e26815ceb625e7ee7c309f7e7" translate="yes" xml:space="preserve">
          <source>This hook delays execution until global step reaches to &lt;code&gt;wait_until_step&lt;/code&gt;. It is used to gradually start workers in distributed settings. One example usage would be setting &lt;code&gt;wait_until_step=int(K*log(task_id+1))&lt;/code&gt; assuming that task_id=0 is the chief.</source>
          <target state="translated">このフックは、グローバルステップが &lt;code&gt;wait_until_step&lt;/code&gt; に達するまで実行を遅らせます。分散設定でワーカーを徐々に開始するために使用されます。使用例の1つは、task_id = 0が主であると想定して、wait_until_step = &lt;code&gt;wait_until_step=int(K*log(task_id+1))&lt;/code&gt; を設定することです。</target>
        </trans-unit>
        <trans-unit id="1a0fa0f63117915fa2c817fa42b4c67a4f5c8b33" translate="yes" xml:space="preserve">
          <source>This hook requests stop after either a number of steps have been executed or a last step has been reached. Only one of the two options can be specified.</source>
          <target state="translated">このフックは、いくつかのステップが実行された後、または最後のステップに達した後に停止を要求します。2つのオプションのうちの1つだけを指定することができます。</target>
        </trans-unit>
        <trans-unit id="29326e19d0dc3f4c325692b2b9f948f424da0e4f" translate="yes" xml:space="preserve">
          <source>This hook saves the state of the iterators in the &lt;code&gt;Graph&lt;/code&gt; so that when training is resumed the input pipeline continues from where it left off. This could potentially avoid overfitting in certain pipelines where the number of training steps per eval are small compared to the dataset size or if the training pipeline is pre-empted.</source>
          <target state="translated">このフックは、イテレータの状態を &lt;code&gt;Graph&lt;/code&gt; 保存するので、トレーニングが再開されたときに、入力パイプラインが中断したところから継続します。これにより、evalあたりのトレーニングステップの数がデータセットのサイズと比較して小さい場合や、トレーニングパイプラインがプリエンプトされた場合に、特定のパイプラインで過剰適合を回避できる可能性があります。</target>
        </trans-unit>
        <trans-unit id="362202ba29e8d6beed9c2059ae03ede13f3cd76f" translate="yes" xml:space="preserve">
          <source>This hook should be used if the input pipeline state needs to be saved separate from the model checkpoint. Doing so may be useful for a few reasons:</source>
          <target state="translated">このフックは、入力パイプラインの状態をモデルチェックポイントとは別に保存する必要がある場合に使用します。このようにすると、いくつかの理由で便利な場合があります。</target>
        </trans-unit>
        <trans-unit id="b6ae1f6a6bb162ce4153046b8500ec1c1479c758" translate="yes" xml:space="preserve">
          <source>This identifies the replica that is part of a sync group. Currently we assume that all sync groups contain the same number of replicas. The value of the replica id can range from 0 to &lt;code&gt;num_replica_in_sync&lt;/code&gt; - 1.</source>
          <target state="translated">これは、同期グループの一部であるレプリカを識別します。現在、すべての同期グループに同じ数のレプリカが含まれていると想定しています。レプリカIDの値の範囲は &lt;code&gt;num_replica_in_sync&lt;/code&gt; -1です。</target>
        </trans-unit>
        <trans-unit id="1b29036c26df39b1ea3c52cbf28f86f795fcf9f0" translate="yes" xml:space="preserve">
          <source>This implementation is based off of the Cephes math library.</source>
          <target state="translated">この実装はCephesの数学ライブラリをベースにしています。</target>
        </trans-unit>
        <trans-unit id="3f20df5d52794499c7d70f58fc604ea383aee58e" translate="yes" xml:space="preserve">
          <source>This implementation is to be used in conjunction of BlockLSTMV2.</source>
          <target state="translated">この実装は、BlockLSTMV2と組み合わせて使用します。</target>
        </trans-unit>
        <trans-unit id="e4e20691c6271c3052db6329ff09bab3c3926f92" translate="yes" xml:space="preserve">
          <source>This implementation is to be used in conjunction of LSTMBlock.</source>
          <target state="translated">この実装は、LSTMBlockと組み合わせて使用します。</target>
        </trans-unit>
        <trans-unit id="2023d65f880c26efdc064ba734473728a5acce91" translate="yes" xml:space="preserve">
          <source>This implementation is to be used in conjunction of LSTMBlockCell.</source>
          <target state="translated">この実装は、LSTMBlockCellと組み合わせて使用します。</target>
        </trans-unit>
        <trans-unit id="ecd5efd797cabcd540fdce983afef271dcb8292a" translate="yes" xml:space="preserve">
          <source>This implementation of RMSprop uses plain momentum, not Nesterov momentum.</source>
          <target state="translated">このRMSpropの実装では、Nesterov運動量ではなく、プレーン運動量を使用しています。</target>
        </trans-unit>
        <trans-unit id="32650114feea17cac9bd97ba7f3acc193158dc56" translate="yes" xml:space="preserve">
          <source>This implementation uses 1 weight matrix and 1 bias vector, and there's an optional peephole connection.</source>
          <target state="translated">この実装では、1つの重み行列と1つのバイアスベクトルを使用し、オプションの覗き穴接続があります。</target>
        </trans-unit>
        <trans-unit id="69398f914b35c5353b93476810576462db6eec45" translate="yes" xml:space="preserve">
          <source>This implements the anisotropic 2-D version of the formula described here:</source>
          <target state="translated">これは、ここで説明した式の異方性2次元版を実装しています。</target>
        </trans-unit>
        <trans-unit id="cd31200075bd4a5cc039e35e154eab86539a7999" translate="yes" xml:space="preserve">
          <source>This improves training speed. Please see &lt;code&gt;optimization_parameters.proto&lt;/code&gt; for details.</source>
          <target state="translated">これにより、トレーニング速度が向上します。詳細については、 &lt;code&gt;optimization_parameters.proto&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="eaa40933c0c7c31f3c54363539d17de16903a6ff" translate="yes" xml:space="preserve">
          <source>This includes ops from TF 2.0 tf.summary and TF 1.x tf.contrib.summary (except for &lt;code&gt;tf.contrib.summary.graph&lt;/code&gt; and &lt;code&gt;tf.contrib.summary.import_event&lt;/code&gt;), but does &lt;em&gt;not&lt;/em&gt; include TF 1.x tf.summary ops.</source>
          <target state="translated">これには、TF 2.0 tf.summaryおよびTF 1.x tf.contrib.summary（ &lt;code&gt;tf.contrib.summary.graph&lt;/code&gt; および &lt;code&gt;tf.contrib.summary.import_event&lt;/code&gt; を除く）の操作が含まれますが、TF 1.x tf.summaryは含まれませ&lt;em&gt;ん&lt;/em&gt; ops。</target>
        </trans-unit>
        <trans-unit id="2cbffbf5b87e7d08406cd7f76d2f7936c22b5d07" translate="yes" xml:space="preserve">
          <source>This includes the operations to synchronize replicas: aggregate gradients, apply to variables, increment global step, insert tokens to token queue.</source>
          <target state="translated">これには、レプリカを同期させるための操作が含まれています:グラデーションの集約、変数への適用、グローバルステップのインクリメント、トークンキューへのトークンの挿入。</target>
        </trans-unit>
        <trans-unit id="dc77baa2dba67576cde30b92064b3afa6abe84f1" translate="yes" xml:space="preserve">
          <source>This induces quasi-linear speedup on up to 8 GPUs.</source>
          <target state="translated">これにより、最大8個のGPUで擬似的な高速化を実現しています。</target>
        </trans-unit>
        <trans-unit id="9e91bcd2748922b865fbdb3c28f16a3f92c87b0e" translate="yes" xml:space="preserve">
          <source>This initializer assigns one entry in the table for each line in the file.</source>
          <target state="translated">このイニシャライザは、ファイル内の各行に対してテーブル内の1つのエントリを割り当てます。</target>
        </trans-unit>
        <trans-unit id="93a30392533a2023857f78a57a8100de69db56b7" translate="yes" xml:space="preserve">
          <source>This initializes a new Kubernetes ClusterResolver. The ClusterResolver will attempt to talk to the Kubernetes master to retrieve all the instances of pods matching a label selector.</source>
          <target state="translated">これは新しいKubernetes ClusterResolverを初期化します。ClusterResolverは、ラベルセレクタにマッチするポッドのインスタンスをすべて取得するためにKubernetesマスターに話しかけることを試みます。</target>
        </trans-unit>
        <trans-unit id="ded15c2fc6dc030fcd9627bdc75c00460c2cb65d" translate="yes" xml:space="preserve">
          <source>This is (mostly) a special case of &lt;a href=&quot;../math/add&quot;&gt;&lt;code&gt;tf.add&lt;/code&gt;&lt;/a&gt; where &lt;code&gt;bias&lt;/code&gt; is restricted to 1-D. Broadcasting is supported, so &lt;code&gt;value&lt;/code&gt; may have any number of dimensions. Unlike &lt;a href=&quot;../math/add&quot;&gt;&lt;code&gt;tf.add&lt;/code&gt;&lt;/a&gt;, the type of &lt;code&gt;bias&lt;/code&gt; is allowed to differ from &lt;code&gt;value&lt;/code&gt; in the case where both types are quantized.</source>
          <target state="translated">これは、（主に）の特別な場合である&lt;a href=&quot;../math/add&quot;&gt; &lt;code&gt;tf.add&lt;/code&gt; &lt;/a&gt; &lt;code&gt;bias&lt;/code&gt; 1-Dに制限されます。ブロードキャストがサポートされているため、 &lt;code&gt;value&lt;/code&gt; は任意の数の次元を含めることができます。&lt;a href=&quot;../math/add&quot;&gt; &lt;code&gt;tf.add&lt;/code&gt; &lt;/a&gt;とは異なり、 &lt;code&gt;bias&lt;/code&gt; タイプは、両方のタイプが量子化される場合の &lt;code&gt;value&lt;/code&gt; とは異なることが許可されます。</target>
        </trans-unit>
        <trans-unit id="9f67d123191520f4a8994999dc8cd88f7fe320b7" translate="yes" xml:space="preserve">
          <source>This is EXPERIMENTAL and subject to change.</source>
          <target state="translated">これは経験的なものであり、変更される場合があります。</target>
        </trans-unit>
        <trans-unit id="02f8d625292f24a8f6fa6d8a843ae5c003159e97" translate="yes" xml:space="preserve">
          <source>This is a class method that describes what key/value arguments are required to instantiate the given &lt;code&gt;Distribution&lt;/code&gt; so that a particular shape is returned for that instance's call to &lt;code&gt;sample()&lt;/code&gt;.</source>
          <target state="translated">これは、特定のShapeがそのインスタンスの &lt;code&gt;sample()&lt;/code&gt; の呼び出しで返されるように、特定の &lt;code&gt;Distribution&lt;/code&gt; をインスタンス化するために必要なキー/値引数を記述するクラスメソッドです。</target>
        </trans-unit>
        <trans-unit id="012a7836bd88d1e3c2c595506564d4812be83ba5" translate="yes" xml:space="preserve">
          <source>This is a class method that describes what key/value arguments are required to instantiate the given &lt;code&gt;Distribution&lt;/code&gt; so that a particular shape is returned for that instance's call to &lt;code&gt;sample()&lt;/code&gt;. Assumes that the sample's shape is known statically.</source>
          <target state="translated">これは、特定のShapeがそのインスタンスの &lt;code&gt;sample()&lt;/code&gt; の呼び出しで返されるように、特定の &lt;code&gt;Distribution&lt;/code&gt; をインスタンス化するために必要なキー/値引数を記述するクラスメソッドです。サンプルの形状が静的にわかっていると仮定します。</target>
        </trans-unit>
        <trans-unit id="fead40a760af2fb3753f3e33415c41be437e055a" translate="yes" xml:space="preserve">
          <source>This is a companion method to &lt;code&gt;add_queue_runner()&lt;/code&gt;. It just starts threads for all queue runners collected in the graph. It returns the list of all threads.</source>
          <target state="translated">これは、 &lt;code&gt;add_queue_runner()&lt;/code&gt; のコンパニオンメソッドです。グラフで収集されたすべてのキューランナーのスレッドを開始するだけです。すべてのスレッドのリストを返します。</target>
        </trans-unit>
        <trans-unit id="9590afd024cc456ab84ee4d2f95cabc25b5ebe3a" translate="yes" xml:space="preserve">
          <source>This is a context class that is passed to the &lt;code&gt;value_fn&lt;/code&gt; in &lt;code&gt;strategy.experimental_distribute_values_from_function&lt;/code&gt; and contains information about the compute replicas. The &lt;code&gt;num_replicas_in_sync&lt;/code&gt; and &lt;code&gt;replica_id&lt;/code&gt; can be used to customize the value on each replica.</source>
          <target state="translated">これは、 &lt;code&gt;strategy.experimental_distribute_values_from_function&lt;/code&gt; の &lt;code&gt;value_fn&lt;/code&gt; に渡されるコンテキストクラスであり、コンピューティングレプリカに関する情報が含まれています。 &lt;code&gt;num_replicas_in_sync&lt;/code&gt; と &lt;code&gt;replica_id&lt;/code&gt; は各レプリカに値をカスタマイズするために使用することができます。</target>
        </trans-unit>
        <trans-unit id="309ae6e7b107ea04158b03fa5671cc2764a5cdf7" translate="yes" xml:space="preserve">
          <source>This is a context class that is passed to the user's input function and contains information about the compute replicas and input pipelines. The number of compute replicas (in sync training) helps compute the local batch size from the desired global batch size for each replica. The input pipeline information can be used to return a different subset of the input in each replica (for e.g. shard the input pipeline, use a different input source etc).</source>
          <target state="translated">これは,ユーザの入力関数に渡されるコンテキストクラスで,コンピュートレプリカと入力パイプラインに関する情報を含みます.計算レプリカの数(同期学習時)は,各レプリカのグローバルなバッチサイズからローカルなバッチサイズを計算するのに役立ちます.入力パイプラインの情報は,各レプリカの入力の異なるサブセットを返すために利用することができます(例えば,入力パイプラインをシャードする,異なる入力ソースを使用するなど).</target>
        </trans-unit>
        <trans-unit id="1659a3286a3bedb8cf721b60523b4bfde4d51caf" translate="yes" xml:space="preserve">
          <source>This is a convenience method that converts RGB images to float representation, adjusts their brightness, and then converts them back to the original data type. If several adjustments are chained, it is advisable to minimize the number of redundant conversions.</source>
          <target state="translated">RGB画像をfloat表現に変換し、明るさを調整した後、元のデータ型に戻す変換を行う便利な方法です。複数の調整が連鎖している場合は、冗長な変換を最小限にすることが望ましい。</target>
        </trans-unit>
        <trans-unit id="7bcc711030b8e6b303b05fbb2eadad7a51295960" translate="yes" xml:space="preserve">
          <source>This is a convenience method that converts RGB images to float representation, adjusts their contrast, and then converts them back to the original data type. If several adjustments are chained, it is advisable to minimize the number of redundant conversions.</source>
          <target state="translated">RGB画像をfloat表現に変換し、コントラストを調整した後、元のデータ型に戻す変換を行う便利な方法です。複数の調整が連鎖している場合は、冗長な変換を最小限にすることが望ましい。</target>
        </trans-unit>
        <trans-unit id="689582a22623e8b58ba6e0ed65682c48dc03d8f0" translate="yes" xml:space="preserve">
          <source>This is a convenience method that converts RGB images to float representation, converts them to HSV, add an offset to the saturation channel, converts back to RGB and then back to the original data type. If several adjustments are chained it is advisable to minimize the number of redundant conversions.</source>
          <target state="translated">これは、RGB画像をfloat表現に変換し、HSVに変換し、彩度チャンネルにオフセットを加え、RGBに変換してから元のデータ型に戻すという便利な方法です。複数の調整が連鎖している場合は、冗長な変換の数を最小限にすることが望ましい。</target>
        </trans-unit>
        <trans-unit id="154fc7928cd01964ea2a05b16a1fbc2cadc62c3b" translate="yes" xml:space="preserve">
          <source>This is a convenience method that converts RGB images to float representation, converts them to HSV, adds an offset to the saturation channel, converts back to RGB and then back to the original data type. If several adjustments are chained it is advisable to minimize the number of redundant conversions.</source>
          <target state="translated">これは、RGB画像をfloat表現に変換し、HSVに変換し、彩度チャンネルにオフセットを加え、RGBに変換してから元のデータ型に戻すという便利な方法です。複数の調整が連鎖している場合は、冗長な変換の数を最小限にすることが望ましいです。</target>
        </trans-unit>
        <trans-unit id="157983bd7b4bf865fccf95ec9e2bc8ddd381392d" translate="yes" xml:space="preserve">
          <source>This is a convenience method that converts an RGB image to float representation, converts it to HSV, add an offset to the hue channel, converts back to RGB and then back to the original data type. If several adjustments are chained it is advisable to minimize the number of redundant conversions.</source>
          <target state="translated">これは、RGB画像をfloat表現に変換してHSVに変換し、色相チャンネルにオフセットを加え、RGBに変換してから元のデータ型に戻すという便利な方法です。複数の調整が連鎖している場合は、冗長な変換の数を最小限にすることが望ましいです。</target>
        </trans-unit>
        <trans-unit id="bc1addde10acbe587836014417c1c886ecf1e9cf" translate="yes" xml:space="preserve">
          <source>This is a convenience method that converts an RGB image to float representation, converts it to HSV, adds an offset to the hue channel, converts back to RGB and then back to the original data type. If several adjustments are chained it is advisable to minimize the number of redundant conversions.</source>
          <target state="translated">これは、RGB画像をfloat表現に変換し、HSVに変換し、色相チャンネルにオフセットを加え、RGBに変換してから元のデータ型に戻すという便利な方法です。複数の調整が連鎖している場合は、冗長な変換の数を最小限にすることが望ましいです。</target>
        </trans-unit>
        <trans-unit id="8b85cb6fb2b17c1cfe1f8becbb4b4eeadf576adb" translate="yes" xml:space="preserve">
          <source>This is a convenience method that converts an image to uint8 representation, encodes it to jpeg with &lt;code&gt;jpeg_quality&lt;/code&gt;, decodes it, and then converts back to the original data type.</source>
          <target state="translated">これは、画像をuint8表現に変換し、 &lt;code&gt;jpeg_quality&lt;/code&gt; を使用してjpegにエンコードし、デコードしてから、元のデータ型に戻す便利なメソッドです。</target>
        </trans-unit>
        <trans-unit id="040dbe98920d5a5c1090b8783413f490c3abe113" translate="yes" xml:space="preserve">
          <source>This is a convenience utility for packing data into the tuple formats that &lt;a href=&quot;../model#fit&quot;&gt;&lt;code&gt;Model.fit&lt;/code&gt;&lt;/a&gt; uses.</source>
          <target state="translated">これは、&lt;a href=&quot;../model#fit&quot;&gt; &lt;code&gt;Model.fit&lt;/code&gt; が&lt;/a&gt;使用するタプル形式にデータをパックするための便利なユーティリティです。</target>
        </trans-unit>
        <trans-unit id="177a96552c22761995fc2a02f86657fdf66dd73d" translate="yes" xml:space="preserve">
          <source>This is a convenience utility to be used when overriding &lt;a href=&quot;../model#train_step&quot;&gt;&lt;code&gt;Model.train_step&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../model#test_step&quot;&gt;&lt;code&gt;Model.test_step&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;../model#predict_step&quot;&gt;&lt;code&gt;Model.predict_step&lt;/code&gt;&lt;/a&gt;. This utility makes it easy to support data of the form &lt;code&gt;(x,)&lt;/code&gt;, &lt;code&gt;(x, y)&lt;/code&gt;, or &lt;code&gt;(x, y, sample_weight)&lt;/code&gt;.</source>
          <target state="translated">これは、&lt;a href=&quot;../model#train_step&quot;&gt; &lt;code&gt;Model.train_step&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../model#test_step&quot;&gt; &lt;code&gt;Model.test_step&lt;/code&gt; &lt;/a&gt;、または&lt;a href=&quot;../model#predict_step&quot;&gt; &lt;code&gt;Model.predict_step&lt;/code&gt; を&lt;/a&gt;オーバーライドするときに使用する便利なユーティリティです。このユーティリティを使用すると、 &lt;code&gt;(x,)&lt;/code&gt; 、 &lt;code&gt;(x, y)&lt;/code&gt; 、または &lt;code&gt;(x, y, sample_weight)&lt;/code&gt; の形式のデータを簡単にサポートできます。</target>
        </trans-unit>
        <trans-unit id="c0b259f9b8e5db6abf1f7ca2cc64744a095dde1b" translate="yes" xml:space="preserve">
          <source>This is a dataset of 11,228 newswires from Reuters, labeled over 46 topics.</source>
          <target state="translated">これはロイターのニュースワイヤー11,228本のデータセットで、46のトピックに分類されています。</target>
        </trans-unit>
        <trans-unit id="768eb884c8ee5b48b0c147f90ce4407a6a9884da" translate="yes" xml:space="preserve">
          <source>This is a dataset of 25,000 movies reviews from IMDB, labeled by sentiment (positive/negative). Reviews have been preprocessed, and each review is encoded as a list of word indexes (integers). For convenience, words are indexed by overall frequency in the dataset, so that for instance the integer &quot;3&quot; encodes the 3rd most frequent word in the data. This allows for quick filtering operations such as: &quot;only consider the top 10,000 most common words, but eliminate the top 20 most common words&quot;.</source>
          <target state="translated">これは、IMDBの映画レビュー25,000件のデータセットで、センチメント(ポジティブ/ネガティブ)でラベル付けされています。レビューは前処理され、各レビューは単語のインデックス(整数)のリストとしてエンコードされています。便宜上、単語はデータセット内の全体的な頻度でインデックス化されており、例えば、整数 &quot;3 &quot;はデータ内で3番目に頻度の高い単語をコード化しています。これにより、次のようなフィルタリング操作を素早く行うことができます。&quot;例えば、「最もよく使われる単語の上位10,000個だけを考慮するが、最もよく使われる単語の上位20個は除外する」というようなフィルタリング操作が可能である。</target>
        </trans-unit>
        <trans-unit id="e86bf0041eb6fb31b4e9ede482e55b7d43a98c80" translate="yes" xml:space="preserve">
          <source>This is a dataset of 50,000 32x32 color training images and 10,000 test images, labeled over 10 categories. See more info at the &lt;a href=&quot;https://www.cs.toronto.edu/%7Ekriz/cifar.html&quot;&gt;CIFAR homepage&lt;/a&gt;.</source>
          <target state="translated">これは、10のカテゴリでラベル付けされた50,000の32x32カラートレーニング画像と10,000のテスト画像のデータセットです。詳細については、&lt;a href=&quot;https://www.cs.toronto.edu/%7Ekriz/cifar.html&quot;&gt;CIFARホームページを&lt;/a&gt;ご覧ください。</target>
        </trans-unit>
        <trans-unit id="435f80948690367d77e0f3784d30df76f7f3d98a" translate="yes" xml:space="preserve">
          <source>This is a dataset of 50,000 32x32 color training images and 10,000 test images, labeled over 100 fine-grained classes that are grouped into 20 coarse-grained classes. See more info at the &lt;a href=&quot;https://www.cs.toronto.edu/%7Ekriz/cifar.html&quot;&gt;CIFAR homepage&lt;/a&gt;.</source>
          <target state="translated">これは、50,000個の32x32カラートレーニング画像と10,000個のテスト画像のデータセットであり、20個の粗いクラスにグループ化された100個を超える細かいクラスにラベルが付けられています。詳細については、&lt;a href=&quot;https://www.cs.toronto.edu/%7Ekriz/cifar.html&quot;&gt;CIFARホームページを&lt;/a&gt;ご覧ください。</target>
        </trans-unit>
        <trans-unit id="33a8fb4dd54ee096f6f9e8b6100e0ded183914c6" translate="yes" xml:space="preserve">
          <source>This is a dataset of 60,000 28x28 grayscale images of 10 fashion categories, along with a test set of 10,000 images. This dataset can be used as a drop-in replacement for MNIST. The class labels are:</source>
          <target state="translated">これは10のファッションカテゴリの28x28階調画像60,000枚とテスト画像10,000枚を収録したデータセットです。このデータセットはMNISTの代替品として使うことができます。クラスラベルは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="e30665bff921b2720a3a63831af563bf188d5b46" translate="yes" xml:space="preserve">
          <source>This is a dataset of 60,000 28x28 grayscale images of the 10 digits, along with a test set of 10,000 images. More info can be found at the &lt;a href=&quot;http://yann.lecun.com/exdb/mnist/&quot;&gt;MNIST homepage&lt;/a&gt;.</source>
          <target state="translated">これは、10桁の60,000個の28x28グレースケール画像と10,000個の画像のテストセットのデータセットです。詳細については、&lt;a href=&quot;http://yann.lecun.com/exdb/mnist/&quot;&gt;MNISTホームページをご覧ください&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="710ac221d7447de49c2c2452f75596e4bb685c1c" translate="yes" xml:space="preserve">
          <source>This is a dataset taken from the StatLib library which is maintained at Carnegie Mellon University.</source>
          <target state="translated">これはカーネギーメロン大学で管理されているStatLibライブラリから取得したデータセットです。</target>
        </trans-unit>
        <trans-unit id="ab28ad9476b59e4ae1d47c731d1e80592c84261d" translate="yes" xml:space="preserve">
          <source>This is a deprecated version of &lt;code&gt;fractional_avg_pool&lt;/code&gt;.</source>
          <target state="translated">これは、 &lt;code&gt;fractional_avg_pool&lt;/code&gt; の非推奨バージョンです。</target>
        </trans-unit>
        <trans-unit id="89fac60f109fd0365fd768e5b0c1efda980aac29" translate="yes" xml:space="preserve">
          <source>This is a deprecated version of &lt;code&gt;fractional_max_pool&lt;/code&gt;.</source>
          <target state="translated">これは非推奨バージョンの &lt;code&gt;fractional_max_pool&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="ec0b5065eeff136feb43dbfad07e272612b79d8c" translate="yes" xml:space="preserve">
          <source>This is a deprecated version of BiasAdd and will be soon removed.</source>
          <target state="translated">これはBiasAddの非推奨バージョンで、すぐに削除されます。</target>
        </trans-unit>
        <trans-unit id="066f7ab7935722a8bd3e79702ee438f7b2aad916" translate="yes" xml:space="preserve">
          <source>This is a difference between DatasetV1 and DatasetV2. DatasetV1 does not take anything in its constructor whereas in the DatasetV2, we expect subclasses to create a variant_tensor and pass it in to the super() call.</source>
          <target state="translated">これがDatasetV1とDatasetV2の違いです。DatasetV1はコンストラクタで何も取りませんが、DatasetV2では、サブクラスが variant_tensorを作成して、それをsuper()呼び出しに渡すことを期待しています。</target>
        </trans-unit>
        <trans-unit id="e7c85e6a460e7ff32a9089528b0d0f38042adaa0" translate="yes" xml:space="preserve">
          <source>This is a faster way to train a softmax classifier over a huge number of classes.</source>
          <target state="translated">これは、膨大な数のクラスにわたってソフトマックス分類器を訓練するための高速な方法です。</target>
        </trans-unit>
        <trans-unit id="d7e11ee2edab133ca8b8374faafd78e7821ed539" translate="yes" xml:space="preserve">
          <source>This is a legacy behaviour of TensorFlow and is highly discouraged.</source>
          <target state="translated">これはTensorFlowのレガシーな動作であり、非常にお勧めできません。</target>
        </trans-unit>
        <trans-unit id="a3be19c517fb6a6f6742dcaed9be8bb79e5a6a4d" translate="yes" xml:space="preserve">
          <source>This is a legacy version of the more general BatchToSpaceND.</source>
          <target state="translated">これは、より一般的なBatchToSpaceNDのレガシーバージョンです。</target>
        </trans-unit>
        <trans-unit id="c2584be3bd38ee90f3ac17e87b40fd5fb1908bdb" translate="yes" xml:space="preserve">
          <source>This is a legacy version of the more general SpaceToBatchND.</source>
          <target state="translated">これは、より一般的なSpaceToBatchNDのレガシーバージョンです。</target>
        </trans-unit>
        <trans-unit id="c0ae3cb7ef651d4c8fb957d4b4823d4c0713533f" translate="yes" xml:space="preserve">
          <source>This is a low-level interface for creating an &lt;code&gt;Operation&lt;/code&gt;. Most programs will not call this method directly, and instead use the Python op constructors, such as &lt;a href=&quot;constant&quot;&gt;&lt;code&gt;tf.constant()&lt;/code&gt;&lt;/a&gt;, which add ops to the default graph.</source>
          <target state="translated">これは、 &lt;code&gt;Operation&lt;/code&gt; を作成するための低レベルのインターフェースです。ほとんどのプログラムはこのメソッドを直接呼び出さず、代わりにデフォルトのグラフにopsを追加する&lt;a href=&quot;constant&quot;&gt; &lt;code&gt;tf.constant()&lt;/code&gt; &lt;/a&gt;などのPython opコンストラクターを使用します。</target>
        </trans-unit>
        <trans-unit id="1cd850dc655362d680df73debd3d92a42edd1883" translate="yes" xml:space="preserve">
          <source>This is a method that implementers of subclasses of &lt;code&gt;Layer&lt;/code&gt; or &lt;code&gt;Model&lt;/code&gt; can override if they need a state-creation step in-between layer instantiation and layer call.</source>
          <target state="translated">これは、 &lt;code&gt;Layer&lt;/code&gt; または &lt;code&gt;Model&lt;/code&gt; サブクラスの実装者が、レイヤーのインスタンス化とレイヤーの呼び出しの間に状態作成ステップを必要とする場合にオーバーライドできるメソッドです。</target>
        </trans-unit>
        <trans-unit id="62c4042c7b665a4296b8d1a943304048eb64aec7" translate="yes" xml:space="preserve">
          <source>This is a nonzero integer. See the get_ident() function. Thread identifiers may be recycled when a thread exits and another thread is created. The identifier is available even after the thread has exited.</source>
          <target state="translated">これは0ではない整数です。get_ident()関数を参照ください。スレッドの識別子は、スレッドが終了して別のスレッドが作成されたときにリサイクルされることがあります。識別子は、スレッドが終了した後でも利用可能です。</target>
        </trans-unit>
        <trans-unit id="31eb573dcb4f05e127842ce7a2c523b4f9fd2e61" translate="yes" xml:space="preserve">
          <source>This is a reduction created for Nvidia DGX-1 which assumes GPUs connects like that on DGX-1 machine. If you have different GPU inter-connections, it is likely that it would be slower than &lt;a href=&quot;reductiontoonedevice&quot;&gt;&lt;code&gt;tf.distribute.ReductionToOneDevice&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">これは、Nvidia DGX-1用に作成された削減であり、GPUがDGX-1マシンと同様に接続することを前提としています。異なるGPU相互接続がある場合は、&lt;a href=&quot;reductiontoonedevice&quot;&gt; &lt;code&gt;tf.distribute.ReductionToOneDevice&lt;/code&gt; &lt;/a&gt;よりも遅くなる可能性があります。</target>
        </trans-unit>
        <trans-unit id="85f7e8c05b61af3e5451f6e510d0b0985383c1d8" translate="yes" xml:space="preserve">
          <source>This is a special case of &lt;a href=&quot;../math/add&quot;&gt;&lt;code&gt;tf.add&lt;/code&gt;&lt;/a&gt; where &lt;code&gt;bias&lt;/code&gt; is restricted to be 1-D. Broadcasting is supported, so &lt;code&gt;value&lt;/code&gt; may have any number of dimensions.</source>
          <target state="translated">これは、特殊なケースである&lt;a href=&quot;../math/add&quot;&gt; &lt;code&gt;tf.add&lt;/code&gt; &lt;/a&gt; &lt;code&gt;bias&lt;/code&gt; 1-Dに制限されます。ブロードキャストがサポートされているため、 &lt;code&gt;value&lt;/code&gt; は任意の数の次元があります。</target>
        </trans-unit>
        <trans-unit id="cbdbb1332709a943bc7d0db1d68caf76c3a99f69" translate="yes" xml:space="preserve">
          <source>This is a stateless version of &lt;a href=&quot;../../../random/categorical&quot;&gt;&lt;code&gt;tf.random.categorical&lt;/code&gt;&lt;/a&gt;: if run twice with the same seeds and shapes, it will produce the same pseudorandom numbers. The output is consistent across multiple runs on the same hardware (and between CPU and GPU), but may change between versions of TensorFlow or on non-CPU/GPU hardware.</source>
          <target state="translated">これは、&lt;a href=&quot;../../../random/categorical&quot;&gt; &lt;code&gt;tf.random.categorical&lt;/code&gt; の&lt;/a&gt;ステートレスバージョンです。同じシードと形状で2回実行すると、同じ疑似乱数が生成されます。出力は、同じハードウェア（およびCPUとGPU間）での複数の実行にわたって一貫していますが、TensorFlowのバージョン間または非CPU / GPUハードウェアで変更される場合があります。</target>
        </trans-unit>
        <trans-unit id="81cb44c6cca42a31a07fbae208fd1a7a56619cfa" translate="yes" xml:space="preserve">
          <source>This is a stateless version of &lt;a href=&quot;../../../random/categorical&quot;&gt;&lt;code&gt;tf.random.categorical&lt;/code&gt;&lt;/a&gt;: if run twice with the same seeds, it will produce the same pseudorandom numbers. The output is consistent across multiple runs on the same hardware (and between CPU and GPU), but may change between versions of TensorFlow or on non-CPU/GPU hardware.</source>
          <target state="translated">これは&lt;a href=&quot;../../../random/categorical&quot;&gt; &lt;code&gt;tf.random.categorical&lt;/code&gt; の&lt;/a&gt;ステートレスバージョンです。同じシードで2回実行すると、同じ疑似乱数が生成されます。出力は、同じハードウェアでの複数の実行にわたって（およびCPUとGPUの間で）一貫していますが、TensorFlowのバージョン間または非CPU / GPUハードウェアで異なる場合があります。</target>
        </trans-unit>
        <trans-unit id="de68a47b12e07130e567ec24bb61927f4f535092" translate="yes" xml:space="preserve">
          <source>This is a stateless version of &lt;a href=&quot;gamma&quot;&gt;&lt;code&gt;tf.random.gamma&lt;/code&gt;&lt;/a&gt;: if run twice with the same seeds and shapes, it will produce the same pseudorandom numbers. The output is consistent across multiple runs on the same hardware (and between CPU and GPU), but may change between versions of TensorFlow or on non-CPU/GPU hardware.</source>
          <target state="translated">これは&lt;a href=&quot;gamma&quot;&gt; &lt;code&gt;tf.random.gamma&lt;/code&gt; の&lt;/a&gt;ステートレスバージョンです。同じシードと形状で2回実行すると、同じ疑似乱数が生成されます。出力は、同じハードウェア（およびCPUとGPU間）での複数の実行にわたって一貫していますが、TensorFlowのバージョン間または非CPU / GPUハードウェアで変更される場合があります。</target>
        </trans-unit>
        <trans-unit id="d527e38ee04e494f8d4e9909ef23824c02f218d2" translate="yes" xml:space="preserve">
          <source>This is a stateless version of &lt;a href=&quot;generator#binomial&quot;&gt;&lt;code&gt;tf.random.Generator.binomial&lt;/code&gt;&lt;/a&gt;: if run twice with the same seeds and shapes, it will produce the same pseudorandom numbers. The output is consistent across multiple runs on the same hardware (and between CPU and GPU), but may change between versions of TensorFlow or on non-CPU/GPU hardware.</source>
          <target state="translated">これは、&lt;a href=&quot;generator#binomial&quot;&gt; &lt;code&gt;tf.random.Generator.binomial&lt;/code&gt; の&lt;/a&gt;ステートレスバージョンです。同じシードと形状で2回実行すると、同じ疑似乱数が生成されます。出力は、同じハードウェア（およびCPUとGPU間）での複数の実行にわたって一貫していますが、TensorFlowのバージョン間または非CPU / GPUハードウェアで変更される場合があります。</target>
        </trans-unit>
        <trans-unit id="1f9d7559f26ce2def191894981d83e7101b4893f" translate="yes" xml:space="preserve">
          <source>This is a stateless version of &lt;a href=&quot;normal&quot;&gt;&lt;code&gt;tf.random.normal&lt;/code&gt;&lt;/a&gt;: if run twice with the same seeds and shapes, it will produce the same pseudorandom numbers. The output is consistent across multiple runs on the same hardware (and between CPU and GPU), but may change between versions of TensorFlow or on non-CPU/GPU hardware.</source>
          <target state="translated">これは、&lt;a href=&quot;normal&quot;&gt; &lt;code&gt;tf.random.normal&lt;/code&gt; の&lt;/a&gt;ステートレスバージョンです。同じシードと形状で2回実行すると、同じ疑似乱数が生成されます。出力は、同じハードウェア（およびCPUとGPU間）での複数の実行にわたって一貫していますが、TensorFlowのバージョン間または非CPU / GPUハードウェアで変更される場合があります。</target>
        </trans-unit>
        <trans-unit id="812a072511f22cc831859b50e28ff4fe62133693" translate="yes" xml:space="preserve">
          <source>This is a stateless version of &lt;a href=&quot;normal&quot;&gt;&lt;code&gt;tf.random.normal&lt;/code&gt;&lt;/a&gt;: if run twice with the same seeds, it will produce the same pseudorandom numbers. The output is consistent across multiple runs on the same hardware (and between CPU and GPU), but may change between versions of TensorFlow or on non-CPU/GPU hardware.</source>
          <target state="translated">これは&lt;a href=&quot;normal&quot;&gt; &lt;code&gt;tf.random.normal&lt;/code&gt; の&lt;/a&gt;ステートレスバージョンです。同じシードで2回実行すると、同じ疑似乱数が生成されます。出力は、同じハードウェアでの複数の実行にわたって（およびCPUとGPUの間で）一貫していますが、TensorFlowのバージョン間または非CPU / GPUハードウェアで異なる場合があります。</target>
        </trans-unit>
        <trans-unit id="eb02c3777bd174779389bb97e4e8d5e8436a288c" translate="yes" xml:space="preserve">
          <source>This is a stateless version of &lt;a href=&quot;poisson&quot;&gt;&lt;code&gt;tf.random.poisson&lt;/code&gt;&lt;/a&gt;: if run twice with the same seeds and shapes, it will produce the same pseudorandom numbers. The output is consistent across multiple runs on the same hardware, but may change between versions of TensorFlow or on non-CPU/GPU hardware.</source>
          <target state="translated">これは、&lt;a href=&quot;poisson&quot;&gt; &lt;code&gt;tf.random.poisson&lt;/code&gt; の&lt;/a&gt;ステートレスバージョンです。同じシードと形状で2回実行すると、同じ疑似乱数が生成されます。出力は、同じハードウェアでの複数の実行にわたって一貫していますが、TensorFlowのバージョン間または非CPU / GPUハードウェアで変更される場合があります。</target>
        </trans-unit>
        <trans-unit id="4ca51d036bc29518d8577d5bfc5e3dc7a0421db6" translate="yes" xml:space="preserve">
          <source>This is a stateless version of &lt;a href=&quot;truncated_normal&quot;&gt;&lt;code&gt;tf.random.truncated_normal&lt;/code&gt;&lt;/a&gt;: if run twice with the same seeds and shapes, it will produce the same pseudorandom numbers. The output is consistent across multiple runs on the same hardware (and between CPU and GPU), but may change between versions of TensorFlow or on non-CPU/GPU hardware.</source>
          <target state="translated">これは、&lt;a href=&quot;truncated_normal&quot;&gt; &lt;code&gt;tf.random.truncated_normal&lt;/code&gt; の&lt;/a&gt;ステートレスバージョンです。同じシードと形状で2回実行すると、同じ疑似乱数が生成されます。出力は、同じハードウェア（およびCPUとGPU間）での複数の実行にわたって一貫していますが、TensorFlowのバージョン間または非CPU / GPUハードウェアで変更される場合があります。</target>
        </trans-unit>
        <trans-unit id="dd6096e0d7eff9f42170cc05a1fe61ba85be91f4" translate="yes" xml:space="preserve">
          <source>This is a stateless version of &lt;a href=&quot;truncated_normal&quot;&gt;&lt;code&gt;tf.random.truncated_normal&lt;/code&gt;&lt;/a&gt;: if run twice with the same seeds, it will produce the same pseudorandom numbers. The output is consistent across multiple runs on the same hardware (and between CPU and GPU), but may change between versions of TensorFlow or on non-CPU/GPU hardware.</source>
          <target state="translated">これは&lt;a href=&quot;truncated_normal&quot;&gt; &lt;code&gt;tf.random.truncated_normal&lt;/code&gt; の&lt;/a&gt;ステートレスバージョンです。同じシードで2回実行すると、同じ疑似乱数が生成されます。出力は、同じハードウェアでの複数の実行にわたって（およびCPUとGPUの間で）一貫していますが、TensorFlowのバージョン間または非CPU / GPUハードウェアで異なる場合があります。</target>
        </trans-unit>
        <trans-unit id="ac72baa117d9b4a5bdf610d359eb9848fb6723ce" translate="yes" xml:space="preserve">
          <source>This is a stateless version of &lt;a href=&quot;uniform&quot;&gt;&lt;code&gt;tf.random.uniform&lt;/code&gt;&lt;/a&gt;: if run twice with the same seeds and shapes, it will produce the same pseudorandom numbers. The output is consistent across multiple runs on the same hardware (and between CPU and GPU), but may change between versions of TensorFlow or on non-CPU/GPU hardware.</source>
          <target state="translated">これは、&lt;a href=&quot;uniform&quot;&gt; &lt;code&gt;tf.random.uniform&lt;/code&gt; の&lt;/a&gt;ステートレスバージョンです。同じシードと形状で2回実行すると、同じ疑似乱数が生成されます。出力は、同じハードウェア（およびCPUとGPU間）での複数の実行にわたって一貫していますが、TensorFlowのバージョン間または非CPU / GPUハードウェアで変更される場合があります。</target>
        </trans-unit>
        <trans-unit id="7b120804ac2994699c2b37663ac0990fd63dfd70" translate="yes" xml:space="preserve">
          <source>This is a stateless version of &lt;a href=&quot;uniform&quot;&gt;&lt;code&gt;tf.random.uniform&lt;/code&gt;&lt;/a&gt;: if run twice with the same seeds, it will produce the same pseudorandom numbers. The output is consistent across multiple runs on the same hardware (and between CPU and GPU), but may change between versions of TensorFlow or on non-CPU/GPU hardware.</source>
          <target state="translated">これは&lt;a href=&quot;uniform&quot;&gt; &lt;code&gt;tf.random.uniform&lt;/code&gt; の&lt;/a&gt;ステートレスバージョンです。同じシードで2回実行すると、同じ疑似乱数が生成されます。出力は、同じハードウェアでの複数の実行にわたって（およびCPUとGPUの間で）一貫していますが、TensorFlowのバージョン間または非CPU / GPUハードウェアで異なる場合があります。</target>
        </trans-unit>
        <trans-unit id="93abfee5707aabda372725092df92726179f4164" translate="yes" xml:space="preserve">
          <source>This is a stateless version of &lt;code&gt;tf.categorical&lt;/code&gt;: if run twice with the same seeds and shapes, it will produce the same pseudorandom numbers. The output is consistent across multiple runs on the same hardware (and between CPU and GPU), but may change between versions of TensorFlow or on non-CPU/GPU hardware.</source>
          <target state="translated">これは &lt;code&gt;tf.categorical&lt;/code&gt; のステートレスバージョンです。同じシードと形状で2回実行すると、同じ疑似乱数が生成されます。出力は、同じハードウェア（およびCPUとGPU間）での複数の実行にわたって一貫していますが、TensorFlowのバージョン間または非CPU / GPUハードウェアで変更される場合があります。</target>
        </trans-unit>
        <trans-unit id="ada11b1aaca11d67319d958bd7d1da13f15ebb7f" translate="yes" xml:space="preserve">
          <source>This is a stateless version of &lt;code&gt;tf.categorical&lt;/code&gt;: if run twice with the same seeds, it will produce the same pseudorandom numbers. The output is consistent across multiple runs on the same hardware (and between CPU and GPU), but may change between versions of TensorFlow or on non-CPU/GPU hardware.</source>
          <target state="translated">これは &lt;code&gt;tf.categorical&lt;/code&gt; のステートレスバージョンです。同じシードで2回実行すると、同じ疑似乱数が生成されます。出力は、同じハードウェアでの複数の実行にわたって（およびCPUとGPUの間で）一貫していますが、TensorFlowのバージョン間または非CPU / GPUハードウェアで異なる場合があります。</target>
        </trans-unit>
        <trans-unit id="9603abb8f073d177d05702e0bc2ac4de5a04a74c" translate="yes" xml:space="preserve">
          <source>This is a wrapper to the &lt;code&gt;hashing_trick&lt;/code&gt; function using &lt;code&gt;hash&lt;/code&gt; as the hashing function; unicity of word to index mapping non-guaranteed.</source>
          <target state="translated">これはラッパーです &lt;code&gt;hashing_trick&lt;/code&gt; の使用機能 &lt;code&gt;hash&lt;/code&gt; ハッシュ関数として、単語からインデックスへのマッピングの単一性は保証されていません。</target>
        </trans-unit>
        <trans-unit id="5b00a32a0d99275c6a4a177506328b41e8a5cbe9" translate="yes" xml:space="preserve">
          <source>This is almost identical to QuantizeAndDequantizeV2, except that num_bits is a tensor, so its value can change during training.</source>
          <target state="translated">これはQuantizeAndDequantizeV2とほぼ同じですが、num_bitsがテンソルなので、学習中に値が変わる可能性があることを除いては、QuantizeAndDequantizeV2とほぼ同じです。</target>
        </trans-unit>
        <trans-unit id="ac7a813777192ceaa721f12e2b167eefa5ce19d7" translate="yes" xml:space="preserve">
          <source>This is always checked statically, so this method returns nothing.</source>
          <target state="translated">これは常に静的にチェックされるので、このメソッドは何も返しません。</target>
        </trans-unit>
        <trans-unit id="edf37ccd5d1846dec567da6f67dc930901f7907c" translate="yes" xml:space="preserve">
          <source>This is an abstract base class, so you cannot instantiate it directly. Instead, use one of its concrete subclasses:</source>
          <target state="translated">これは抽象基底クラスなので、直接インスタンス化することはできません。代わりに、その具体的なサブクラスのいずれかを使用します。</target>
        </trans-unit>
        <trans-unit id="acb8330008d86d94ea39351a6992d0b396765e55" translate="yes" xml:space="preserve">
          <source>This is an abstract class which allows extensions to TensorFlow's object-based checkpointing (see &lt;a href=&quot;../checkpoint&quot;&gt;&lt;code&gt;tf.train.Checkpoint&lt;/code&gt;&lt;/a&gt;). For example a wrapper for NumPy arrays:</source>
          <target state="translated">これは、TensorFlowのオブジェクトベースのチェックポイントの拡張を可能にする抽象クラスです（&lt;a href=&quot;../checkpoint&quot;&gt; &lt;code&gt;tf.train.Checkpoint&lt;/code&gt; を&lt;/a&gt;参照）。たとえば、NumPy配列のラッパー：</target>
        </trans-unit>
        <trans-unit id="f0c3e68e0358a0f76609938022081ba5ccf573dd" translate="yes" xml:space="preserve">
          <source>This is an experimental op for internal use only and it is possible to use this op in unsafe ways. DO NOT USE unless you fully understand the risks.</source>
          <target state="translated">これは内部での使用のみを目的とした実験的な操作であり、安全でない方法で使用する可能性があります。リスクを完全に理解しない限り、使用しないでください。</target>
        </trans-unit>
        <trans-unit id="8bbaa33b6f8b11a0355ba861cdf03d3e08622a92" translate="yes" xml:space="preserve">
          <source>This is an identity op (behaves like &lt;a href=&quot;../../identity&quot;&gt;&lt;code&gt;tf.identity&lt;/code&gt;&lt;/a&gt;) with the side effect of printing &lt;code&gt;data&lt;/code&gt; when evaluating.</source>
          <target state="translated">これは、評価時に &lt;code&gt;data&lt;/code&gt; を印刷するという副作用のあるアイデンティティ&lt;a href=&quot;../../identity&quot;&gt; &lt;code&gt;tf.identity&lt;/code&gt; &lt;/a&gt;（tf.identityのように動作します）です。</target>
        </trans-unit>
        <trans-unit id="5c9b3651662523b2ca2e5016d6f25cb9aff58541" translate="yes" xml:space="preserve">
          <source>This is an implementation of ClusterResolver for Slurm clusters. This allows the specification of jobs and task counts, number of tasks per node, number of GPUs on each node and number of GPUs for each task. It retrieves system attributes by Slurm environment variables, resolves allocated computing node names, constructs a cluster and returns a ClusterResolver object which can be used for distributed TensorFlow.</source>
          <target state="translated">Slurmクラスタ用のClusterResolverの実装です。これにより、ジョブとタスク数、ノードごとのタスク数、各ノードのGPU数、タスクごとのGPU数を指定することができます。Slurm環境変数によるシステム属性の取得、割り当てられた計算ノード名の解決、クラスタの構築、分散TensorFlowに利用できるClusterResolverオブジェクトの返却を行います。</target>
        </trans-unit>
        <trans-unit id="04be17d14e8556e45ddfd971016c00de8c4f5796" translate="yes" xml:space="preserve">
          <source>This is an implementation of cluster resolvers for Kubernetes. When given the the Kubernetes namespace and label selector for pods, we will retrieve the pod IP addresses of all running pods matching the selector, and return a ClusterSpec based on that information.</source>
          <target state="translated">これはKubernetes用のクラスタリゾルバの実装です。Kubernetes の名前空間とポッドのラベルセレクタが与えられると、セレクタにマッチするすべての実行中のポッドの IP アドレスを取得し、その情報に基づいて ClusterSpec を返します。</target>
        </trans-unit>
        <trans-unit id="fbfdd6a723bd3e94666f26590d4249971ef2fb48" translate="yes" xml:space="preserve">
          <source>This is an implementation of cluster resolvers for Slurm clusters. This allows the specification of jobs and task counts, number of tasks per node, number of GPUs on each node and number of GPUs for each task. It retrieves system attributes by Slurm environment variables, resolves allocated computing node names, constructs a cluster and returns a ClusterResolver object which can be use for distributed TensorFlow.</source>
          <target state="translated">Slurmクラスタ用のクラスタリゾルバの実装です。これにより、ジョブ数やタスク数、ノードごとのタスク数、各ノードのGPU数、タスクごとのGPU数を指定することができます。Slurm環境変数によるシステム属性の取得、割り当てられた計算ノード名の解決、クラスタの構築、分散TensorFlowで利用可能なClusterResolverオブジェクトの返却を行います。</target>
        </trans-unit>
        <trans-unit id="6c7332a1bfb936db2e58085e5162712580a9aab8" translate="yes" xml:space="preserve">
          <source>This is an implementation of cluster resolvers for the Google Cloud TPU service.</source>
          <target state="translated">Google Cloud TPUサービス用のクラスタリゾルバの実装です。</target>
        </trans-unit>
        <trans-unit id="71688349367e3a46bf633affe83f7f67a539cf79" translate="yes" xml:space="preserve">
          <source>This is an implementation of cluster resolvers for the Google Cloud TPU service. As Cloud TPUs are in alpha, you will need to specify a API definition file for this to consume, in addition to a list of Cloud TPUs in your Google Cloud Platform project.</source>
          <target state="translated">Google Cloud TPU サービスのクラスタリゾルバの実装です。Cloud TPU はアルファ版なので、Google Cloud Platform プロジェクト内の Cloud TPU のリストに加えて、これを消費するための API 定義ファイルを指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="ad683e8f469fc31a1a6f2ec923965536267cfedf" translate="yes" xml:space="preserve">
          <source>This is an implementation of cluster resolvers for the Google Compute Engine instance group platform. By specifying a project, zone, and instance group, this will retrieve the IP address of all the instances within the instance group and return a ClusterResolver object suitable for use for distributed TensorFlow.</source>
          <target state="translated">Google Compute Engineのインスタンスグループプラットフォーム用のクラスタリゾルバの実装です。プロジェクト、ゾーン、インスタンスグループを指定することで、インスタンスグループ内のすべてのインスタンスのIPアドレスを取得し、分散TensorFlowでの使用に適したClusterResolverオブジェクトを返します。</target>
        </trans-unit>
        <trans-unit id="a371677e8e3150f82fcdcb41fbdf4b2aece50db2" translate="yes" xml:space="preserve">
          <source>This is an implementation of cluster resolvers when using TF_CONFIG to set information about the cluster. The cluster spec returned will be initialized from the TF_CONFIG environment variable.</source>
          <target state="translated">TF_CONFIGを使用してクラスタの情報を設定する場合のクラスタリゾルバの実装です。返されたクラスタ仕様は、環境変数 TF_CONFIG から初期化されます。</target>
        </trans-unit>
        <trans-unit id="f2e4a40b99bc22ad76a6b8d488160787266d96b7" translate="yes" xml:space="preserve">
          <source>This is because evaluating the gradient graph does not require evaluating the constant(1) op created in the forward pass.</source>
          <target state="translated">勾配グラフの評価は、フォワードパスで作成された定数(1)opを評価する必要がないからです。</target>
        </trans-unit>
        <trans-unit id="b402b2ea93d17cfe8814c2e2dd9513661013af48" translate="yes" xml:space="preserve">
          <source>This is called to signal the hooks that a new session has been created. This has two essential differences with the situation in which &lt;code&gt;begin&lt;/code&gt; is called:</source>
          <target state="translated">これは、新しいセッションが作成されたことをフックに通知するために呼び出されます。これには、 &lt;code&gt;begin&lt;/code&gt; が呼び出される状況と2つの本質的な違いがあります。</target>
        </trans-unit>
        <trans-unit id="e53a92d847e73238072fa6528b3217c26234a931" translate="yes" xml:space="preserve">
          <source>This is completely equivalent to the slightly longer code:</source>
          <target state="translated">これは、少し長めのコードと完全に等価です。</target>
        </trans-unit>
        <trans-unit id="bb94386b1c4a4c290298db5397c611953054ddc2" translate="yes" xml:space="preserve">
          <source>This is convenient in interactive shells and &lt;a href=&quot;http://ipython.org&quot;&gt;IPython notebooks&lt;/a&gt;, as it avoids having to pass an explicit &lt;code&gt;Session&lt;/code&gt; object to run ops.</source>
          <target state="translated">これは、操作を実行するために明示的な &lt;code&gt;Session&lt;/code&gt; オブジェクトを渡す必要がないため、インタラクティブシェルや&lt;a href=&quot;http://ipython.org&quot;&gt;IPythonノートブック&lt;/a&gt;で便利です。</target>
        </trans-unit>
        <trans-unit id="9c4ed05585b78549393533536c5eaedd31668459" translate="yes" xml:space="preserve">
          <source>This is different from &lt;code&gt;get_collection()&lt;/code&gt; which always returns a copy of the collection list if it exists and never creates an empty collection.</source>
          <target state="translated">これは、存在する場合は常にコレクションリストのコピーを返し、空のコレクションを作成しない &lt;code&gt;get_collection()&lt;/code&gt; とは異なります。</target>
        </trans-unit>
        <trans-unit id="6e7866f4c4c548ff00d81ad9995e04b7c1f8a6da" translate="yes" xml:space="preserve">
          <source>This is different from &lt;code&gt;get_collection_ref()&lt;/code&gt; which always returns the actual collection list if it exists in that it returns a new list each time it is called.</source>
          <target state="translated">これは、呼び出されるたびに新しいリストを返すという点で、実際のコレクションリストが存在する場合は常にそれを返す &lt;code&gt;get_collection_ref()&lt;/code&gt; とは異なります。</target>
        </trans-unit>
        <trans-unit id="c1f83f54b0650a6fa73b0409ff1516763b5fe7d4" translate="yes" xml:space="preserve">
          <source>This is equivalent to applying LSTMBlockCell in a loop, like so:</source>
          <target state="translated">これは、このようにLSTMBlockCellをループで適用することに相当します。</target>
        </trans-unit>
        <trans-unit id="731ffc6237ea1b1cd740ef79a9e5ef7a26a2d7c5" translate="yes" xml:space="preserve">
          <source>This is essentially a shortcut for &lt;code&gt;assign(self, value)&lt;/code&gt;.</source>
          <target state="translated">これは基本的に、 &lt;code&gt;assign(self, value)&lt;/code&gt; ショートカットです。</target>
        </trans-unit>
        <trans-unit id="0bbe53c86ac89d70d42d35929c4d3967934b3af3" translate="yes" xml:space="preserve">
          <source>This is essentially a shortcut for &lt;code&gt;assign_add(self, delta)&lt;/code&gt;.</source>
          <target state="translated">これは基本的に、 &lt;code&gt;assign_add(self, delta)&lt;/code&gt; ショートカットです。</target>
        </trans-unit>
        <trans-unit id="13da478f41797a8113b6021c13a3264c6404bfc3" translate="yes" xml:space="preserve">
          <source>This is essentially a shortcut for &lt;code&gt;assign_sub(self, delta)&lt;/code&gt;.</source>
          <target state="translated">これは基本的に、 &lt;code&gt;assign_sub(self, delta)&lt;/code&gt; ショートカットです。</target>
        </trans-unit>
        <trans-unit id="e2b79a6063d963599f65675c034b474bb3cf4380" translate="yes" xml:space="preserve">
          <source>This is essentially a shortcut for &lt;code&gt;count_up_to(self, limit)&lt;/code&gt;.</source>
          <target state="translated">これは本質的に &lt;code&gt;count_up_to(self, limit)&lt;/code&gt; ショートカットです。</target>
        </trans-unit>
        <trans-unit id="1f513c169143d5db244b63790e45478adc90df06" translate="yes" xml:space="preserve">
          <source>This is expected to return a constant value that will not be changed throughout its life cycle.</source>
          <target state="translated">これは、ライフサイクルを通して変更されない一定の値を返すことが期待されています。</target>
        </trans-unit>
        <trans-unit id="cf3c566ed68759dd2e1f8f0b989dfbaaf3ac89b7" translate="yes" xml:space="preserve">
          <source>This is for example useful if you want to save to a local directory, such as &quot;/tmp&quot; when running in a distributed setting. In that case pass a device for the host where the &quot;/tmp&quot; directory is accessible.</source>
          <target state="translated">これは例えば、分散設定で実行しているときに&quot;/tmp &quot;のようなローカルディレクトリに保存したい場合に便利です。その場合、&quot;/tmp&quot; ディレクトリにアクセスできるホストのデバイスを渡します。</target>
        </trans-unit>
        <trans-unit id="cbd5047389c2714c42e18e715b6900b97495f191" translate="yes" xml:space="preserve">
          <source>This is for use with models that expect a single &lt;code&gt;Tensor&lt;/code&gt; or &lt;code&gt;SparseTensor&lt;/code&gt; as an input feature, as opposed to a dict of features.</source>
          <target state="translated">これは、特徴の &lt;code&gt;SparseTensor&lt;/code&gt; 、単一の &lt;code&gt;Tensor&lt;/code&gt; またはSparseTensorを入力特徴として期待するモデルで使用するためのものです。</target>
        </trans-unit>
        <trans-unit id="76d3e8dd92950ccc6782125edfc083318d1af070" translate="yes" xml:space="preserve">
          <source>This is implemented as a generalized linear model, see &lt;a href=&quot;https://en.wikipedia.org/wiki/Generalized_linear_model&quot;&gt;https://en.wikipedia.org/wiki/Generalized_linear_model&lt;/a&gt;</source>
          <target state="translated">これは一般化線形モデルとして実装されています&lt;a href=&quot;https://en.wikipedia.org/wiki/Generalized_linear_model&quot;&gt;。https：//en.wikipedia.org/wiki/Generalized_linear_modelを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="4f78d4311c49702fc3e064ee729929a77dc6e0a0" translate="yes" xml:space="preserve">
          <source>This is implemented as a generalized linear model, see https://en.wikipedia.org/wiki/Generalized_linear_model.</source>
          <target state="translated">これは一般化線形モデルとして実装されており、https://en.wikipedia.org/wiki/Generalized_linear_model を参照してください。</target>
        </trans-unit>
        <trans-unit id="7a79baaefeeabffec27522a961ac347462293274" translate="yes" xml:space="preserve">
          <source>This is important for the RNN layer to invoke this in it call() method so that the cached mask is cleared before calling the cell.call(). The mask should be cached across the timestep within the same batch, but shouldn't be cached between batches. Otherwise it will introduce unreasonable bias against certain index of data within the batch.</source>
          <target state="translated">これは RNN レイヤーがこれを call()メソッドで呼び出すことが重要で、cell.call()を呼び出す前にキャッシュされたマスクがクリアされるようにします。マスクは同じバッチ内のタイムステップ全体に渡ってキャッシュされるべきですが、バッチ間でキャッシュされるべきではありません。そうしないと、バッチ内のデータの特定のインデックスに対して不合理なバイアスがかかってしまいます。</target>
        </trans-unit>
        <trans-unit id="b5e2c7b524f309c97d9b307ab3f360df187084ea" translate="yes" xml:space="preserve">
          <source>This is intended to be used on signals (or images). Produces a PSNR value for each image in batch.</source>
          <target state="translated">信号(または画像)に使用することを目的としています。バッチ内の各画像のPSNR値を生成します。</target>
        </trans-unit>
        <trans-unit id="5c8364ff06f44a0d2f95291cd9a883d7572dfead" translate="yes" xml:space="preserve">
          <source>This is just a shortcut for &lt;code&gt;variables_initializer(global_variables())&lt;/code&gt;</source>
          <target state="translated">これは、 &lt;code&gt;variables_initializer(global_variables())&lt;/code&gt; の単なるショートカットです。</target>
        </trans-unit>
        <trans-unit id="df7f814ad895f2447cfabb704fb289f9c5058c9f" translate="yes" xml:space="preserve">
          <source>This is just a shortcut for &lt;code&gt;variables_initializer(local_variables())&lt;/code&gt;</source>
          <target state="translated">これは、 &lt;code&gt;variables_initializer(local_variables())&lt;/code&gt; の単なるショートカットです。</target>
        </trans-unit>
        <trans-unit id="1f3a1e67435c460ebf6c9461373717a014d4077f" translate="yes" xml:space="preserve">
          <source>This is like &lt;code&gt;Restore&lt;/code&gt; except that restored tensor can be listed as filling only a slice of a larger tensor. &lt;code&gt;shape_and_slice&lt;/code&gt; specifies the shape of the larger tensor and the slice that the restored tensor covers.</source>
          <target state="translated">これは &lt;code&gt;Restore&lt;/code&gt; 似ていますが、復元されたテンソルは、より大きなテンソルのスライスのみを埋めるようにリストできる点が異なります。 &lt;code&gt;shape_and_slice&lt;/code&gt; は、復元されたテンソルがカバーする大きいテンソルとスライスの形状を指定します。</target>
        </trans-unit>
        <trans-unit id="9a946a8e53161857f667092e8b20dfd7b65825b0" translate="yes" xml:space="preserve">
          <source>This is like &lt;code&gt;Save&lt;/code&gt; except that tensors can be listed in the saved file as being a slice of a larger tensor. &lt;code&gt;shapes_and_slices&lt;/code&gt; specifies the shape of the larger tensor and the slice that this tensor covers. &lt;code&gt;shapes_and_slices&lt;/code&gt; must have as many elements as &lt;code&gt;tensor_names&lt;/code&gt;.</source>
          <target state="translated">これは、テンソルがより大きなテンソルのスライスとして保存されたファイルにリストされることを除いて、 &lt;code&gt;Save&lt;/code&gt; 似ています。 &lt;code&gt;shapes_and_slices&lt;/code&gt; は、大きいテンソルの形状と、このテンソルがカバーするスライスを指定します。 &lt;code&gt;shapes_and_slices&lt;/code&gt; は、tensor_namesと同じ数の要素が &lt;code&gt;tensor_names&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="3f6a76852476cdaa13e9bdd3f2afe687e9e8f273" translate="yes" xml:space="preserve">
          <source>This is like &lt;code&gt;sigmoid_cross_entropy_with_logits()&lt;/code&gt; except that &lt;code&gt;pos_weight&lt;/code&gt;, allows one to trade off recall and precision by up- or down-weighting the cost of a positive error relative to a negative error.</source>
          <target state="translated">これは似ている &lt;code&gt;sigmoid_cross_entropy_with_logits()&lt;/code&gt; ことを除いて &lt;code&gt;pos_weight&lt;/code&gt; 、一方が上方または負の誤差に正の誤差の相対的なダウン重み付けコストにより再現率と精度のトレードオフを可能にします。</target>
        </trans-unit>
        <trans-unit id="45f8d315bd404d0acf0d22377d0fcd8dbfde7b6a" translate="yes" xml:space="preserve">
          <source>This is mathematically equivalent to the classic formula below, but the use of an &lt;code&gt;assign_sub&lt;/code&gt; op (the &lt;code&gt;&quot;-=&quot;&lt;/code&gt; in the formula) allows concurrent lockless updates to the variables:</source>
          <target state="translated">これは数学的には以下の従来の数式と同等ですが、 &lt;code&gt;assign_sub&lt;/code&gt; 演算（数式の &lt;code&gt;&quot;-=&quot;&lt;/code&gt; ）を使用すると、変数をロックなしで同時に更新できます。</target>
        </trans-unit>
        <trans-unit id="a748c5d3b3b745591c3f3c629fe6702e2487d204" translate="yes" xml:space="preserve">
          <source>This is matrix product, not element-wise product.</source>
          <target state="translated">これは行列積であって、要素別積ではない。</target>
        </trans-unit>
        <trans-unit id="e3ce6465dd501a9c64e67f9787b8dbacdd54e8b7" translate="yes" xml:space="preserve">
          <source>This is matrix-vector product, not element-wise product.</source>
          <target state="translated">これは行列ベクトル積であり、要素毎の積ではありません。</target>
        </trans-unit>
        <trans-unit id="8c5b780da30371ec04532fe08dfb27ab4f7f20a6" translate="yes" xml:space="preserve">
          <source>This is more efficient than using separate &lt;a href=&quot;../reverse&quot;&gt;&lt;code&gt;tf.reverse&lt;/code&gt;&lt;/a&gt; ops.</source>
          <target state="translated">これは、個別の&lt;a href=&quot;../reverse&quot;&gt; &lt;code&gt;tf.reverse&lt;/code&gt; &lt;/a&gt; ops を使用するよりも効率的です。</target>
        </trans-unit>
        <trans-unit id="eabc0e8c9ba11bd382b9ff6e31e4cc504e020ab9" translate="yes" xml:space="preserve">
          <source>This is more efficient than using separate &lt;a href=&quot;../reverse&quot;&gt;&lt;code&gt;tf.reverse&lt;/code&gt;&lt;/a&gt; ops. The &lt;code&gt;reverse&lt;/code&gt; and &lt;code&gt;exclusive&lt;/code&gt; kwargs can also be combined:</source>
          <target state="translated">これは、個別の&lt;a href=&quot;../reverse&quot;&gt; &lt;code&gt;tf.reverse&lt;/code&gt; &lt;/a&gt; ops を使用するよりも効率的です。 &lt;code&gt;reverse&lt;/code&gt; と &lt;code&gt;exclusive&lt;/code&gt; kwargsからも組み合わせることができます。</target>
        </trans-unit>
        <trans-unit id="80ea1c276768e8dc61eb8fd686066ffd896d6dd9" translate="yes" xml:space="preserve">
          <source>This is not a graph construction method, it does not add ops to the graph.</source>
          <target state="translated">これはグラフの構築方法ではなく、グラフにOPSを追加するものではありません。</target>
        </trans-unit>
        <trans-unit id="afbcb9b1912c3cf36d0b4a3b3d79a1accb7231d9" translate="yes" xml:space="preserve">
          <source>This is particularly useful for creating a critical section when used in conjunction with &lt;code&gt;MutexLockIdentity&lt;/code&gt;:</source>
          <target state="translated">これは、 &lt;code&gt;MutexLockIdentity&lt;/code&gt; と組み合わせて使用​​する場合にクリティカルセクションを作成する場合に特に便利です。</target>
        </trans-unit>
        <trans-unit id="be0ccfef7a257148d1bd487cc01dfdee2f9dcbb7" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;code&gt;embedding_column&lt;/code&gt;, except that it produces a list of embedding columns that share the same embedding weights.</source>
          <target state="translated">これは &lt;code&gt;embedding_column&lt;/code&gt; に似ていますが、同じ埋め込みの重みを共有する埋め込み列のリストが生成される点が異なります。</target>
        </trans-unit>
        <trans-unit id="16ef5940d98e86cc048c2b1d955cc28ebe55e81d" translate="yes" xml:space="preserve">
          <source>This is supposed to be executed in the beginning of the chief/sync thread so that even if the total_num_replicas is less than replicas_to_aggregate, the model can still proceed as the replicas can compute multiple steps per variable update. Make sure: &lt;code&gt;num_tokens &amp;gt;= replicas_to_aggregate - total_num_replicas&lt;/code&gt;.</source>
          <target state="translated">これは、チーフ/同期スレッドの最初に実行されることになっているため、total_num_replicasがreplicas_to_aggregateよりも小さい場合でも、レプリカが変数の更新ごとに複数のステップを計算できるため、モデルを続行できます。確認： &lt;code&gt;num_tokens &amp;gt;= replicas_to_aggregate - total_num_replicas&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b0eb2e902e8ddf903b8c32989be7bc5b84650328" translate="yes" xml:space="preserve">
          <source>This is the Python 2.x counterpart to &lt;code&gt;__bool__()&lt;/code&gt; above.</source>
          <target state="translated">これは上記の &lt;code&gt;__bool__()&lt;/code&gt; 対応するPython 2.x です。</target>
        </trans-unit>
        <trans-unit id="a177ea545dfd38bd683f27da57349ab86dcbee74" translate="yes" xml:space="preserve">
          <source>This is the V1 version of this layer that uses variable_scope's or partitioner to create variables which works well with PartitionedVariables. Variable scopes are deprecated in V2, so the V2 version uses name_scopes instead. But currently that lacks support for partitioned variables. Use this if you need partitioned variables. Use the partitioner argument if you have a Keras model and uses &lt;a href=&quot;../estimator/model_to_estimator&quot;&gt;&lt;code&gt;tf.compat.v1.keras.estimator.model_to_estimator&lt;/code&gt;&lt;/a&gt; for training.</source>
          <target state="translated">これは、variable_scopeまたはpartitionerを使用してPartitionedVariablesで適切に機能する変数を作成するこのレイヤーのV1バージョンです。変数スコープはV2で非推奨になるため、V2バージョンでは代わりにname_scopesを使用します。しかし現在、それはパーティション化された変数のサポートを欠いています。パーティション変数が必要な場合は、これを使用します。&lt;a href=&quot;../estimator/model_to_estimator&quot;&gt; &lt;code&gt;tf.compat.v1.keras.estimator.model_to_estimator&lt;/code&gt; &lt;/a&gt;モデルがあり、トレーニングにtf.compat.v1.keras.estimator.model_to_estimatorを使用する場合は、partitioner引数を使用します。</target>
        </trans-unit>
        <trans-unit id="8d8b6a8f2029ea1fc60a937a0c43797bc06e4fc9" translate="yes" xml:space="preserve">
          <source>This is the V1 version of this layer that uses variable_scope's to create variables which works well with PartitionedVariables. Variable scopes are deprecated in V2, so the V2 version uses name_scopes instead. But currently that lacks support for partitioned variables. Use this if you need partitioned variables.</source>
          <target state="translated">これはこのレイヤーの V1 版で、変数の作成に variable_scope を使用し、PartitionedVariables とうまく機能するようにしたものです。変数スコープはV2では非推奨とされているので、V2版では代わりにname_scopeを使用しています。しかし、現在のところ、これはパーティショニング変数のサポートに欠けています。パーティショニングされた変数が必要な場合はこれを使ってください。</target>
        </trans-unit>
        <trans-unit id="f355bc341013b9a7925572a2dcb6ac68143ef849" translate="yes" xml:space="preserve">
          <source>This is the V2 version of this layer that uses name_scopes to create variables instead of variable_scopes. But this approach currently lacks support for partitioned variables. In that case, use the V1 version instead.</source>
          <target state="translated">これはこのレイヤーのV2版で、変数の作成に variable_scopesの代わりにname_scopesを使用しています。しかし、このアプローチは現在のところ変数の分割をサポートしていません。その場合は、代わりに V1 版を使用してください。</target>
        </trans-unit>
        <trans-unit id="45048f38a2e249e88fc3cdaca3ce8480b40e2329" translate="yes" xml:space="preserve">
          <source>This is the angle ( \theta \in [-\pi, \pi] ) such that [ x = r \cos(\theta) ] and [ y = r \sin(\theta) ] where (r = \sqrt(x^2 + y^2) ).</source>
          <target state="translated">この角度は、(「\theta \in [-\pi,\pi])のように、(x=r \cos(\theta)]and(y=r \sin(\theta)])、(r=sqrt(x^2+y^2))、(r=√(x^2+y^2))となります。</target>
        </trans-unit>
        <trans-unit id="d2e50218603262fb1a544e117d169f38db78b601" translate="yes" xml:space="preserve">
          <source>This is the base class for implementing RNN cells with custom behavior.</source>
          <target state="translated">カスタムビヘイビアを持つRNNセルを実装するためのベースクラスです。</target>
        </trans-unit>
        <trans-unit id="9e013372239f70ba2378635884ba4bb573e7d626" translate="yes" xml:space="preserve">
          <source>This is the class from which all layers inherit.</source>
          <target state="translated">これはすべてのレイヤーが継承するクラスです。</target>
        </trans-unit>
        <trans-unit id="ff34740f3f60fdf70d3491fdb28647e761a272fb" translate="yes" xml:space="preserve">
          <source>This is the correct way to perform gradient clipping (Pascanu et al., 2012).</source>
          <target state="translated">これは、グラデーションクリッピングを行うための正しい方法です(Pascanuら、2012年)。</target>
        </trans-unit>
        <trans-unit id="8fa4ff7f2578477f255b6f02a47ae45758b90edc" translate="yes" xml:space="preserve">
          <source>This is the correct way to perform gradient clipping (for example, see &lt;a href=&quot;http://arxiv.org/abs/1211.5063&quot;&gt;Pascanu et al., 2012&lt;/a&gt; (&lt;a href=&quot;http://arxiv.org/pdf/1211.5063.pdf&quot;&gt;pdf&lt;/a&gt;)).</source>
          <target state="translated">これは、勾配クリッピングを実行する正しい方法です（たとえば、&lt;a href=&quot;http://arxiv.org/abs/1211.5063&quot;&gt;Pascanu et al。、2012&lt;/a&gt;（&lt;a href=&quot;http://arxiv.org/pdf/1211.5063.pdf&quot;&gt;pdf&lt;/a&gt;）を参照してください）。</target>
        </trans-unit>
        <trans-unit id="76694ede23dda167a78335c0c1bd3e85284fad75" translate="yes" xml:space="preserve">
          <source>This is the crossentropy metric class to be used when there are multiple label classes (2 or more). Here we assume that labels are given as a &lt;code&gt;one_hot&lt;/code&gt; representation. eg., When labels values are [2, 0, 1], &lt;code&gt;y_true&lt;/code&gt; = [[0, 0, 1], [1, 0, 0], [0, 1, 0]].</source>
          <target state="translated">これは、複数のラベルクラス（2つ以上）がある場合に使用されるクロスエントロピーメトリッククラスです。ここでは、ラベルが &lt;code&gt;one_hot&lt;/code&gt; 表現として指定されていると想定しています。たとえば、ラベル値が[ &lt;code&gt;y_true&lt;/code&gt; ]の場合、y_true = [[ 0、0、1 ]、[ 1、0、0 ]、[ 0、1、0 ]]です。</target>
        </trans-unit>
        <trans-unit id="d187cef3999e110bfd14733d1bc7141db46b4d0d" translate="yes" xml:space="preserve">
          <source>This is the crossentropy metric class to be used when there are only two label classes (0 and 1).</source>
          <target state="translated">これは,2つのラベルクラス(0と1)しかない場合に使用されるクロスエントロピーメトリッククラスです.</target>
        </trans-unit>
        <trans-unit id="fb90fff0e52ece653003dbcf512572b6437c5795" translate="yes" xml:space="preserve">
          <source>This is the dtype layers will create their variables in, unless a layer explicitly chooses a different dtype. If this is different than &lt;a href=&quot;policy#compute_dtype&quot;&gt;&lt;code&gt;Policy.compute_dtype&lt;/code&gt;&lt;/a&gt;, Layers will cast variables to the compute dtype to avoid type errors.</source>
          <target state="translated">これは、層が別のdtypeを明示的に選択しない限り、dtype層が変数を作成します。これが&lt;a href=&quot;policy#compute_dtype&quot;&gt; &lt;code&gt;Policy.compute_dtype&lt;/code&gt; &lt;/a&gt;と異なる場合、レイヤーは変数を計算dtypeにキャストして、タイプエラーを回避します。</target>
        </trans-unit>
        <trans-unit id="08b035fd1ef991c0ac17661834339a93b3d11556" translate="yes" xml:space="preserve">
          <source>This is the dtype layers will do their computations in.</source>
          <target state="translated">これは dtype レイヤーが計算を行う場所です。</target>
        </trans-unit>
        <trans-unit id="5e888c610bf02b0ac69c58288afbe898eebab389" translate="yes" xml:space="preserve">
          <source>This is the first part of &lt;code&gt;minimize()&lt;/code&gt;. It returns a list of (gradient, variable) pairs where &quot;gradient&quot; is the gradient for &quot;variable&quot;. Note that &quot;gradient&quot; can be a &lt;code&gt;Tensor&lt;/code&gt;, an &lt;code&gt;IndexedSlices&lt;/code&gt;, or &lt;code&gt;None&lt;/code&gt; if there is no gradient for the given variable.</source>
          <target state="translated">これは、 &lt;code&gt;minimize()&lt;/code&gt; の最初の部分です。（gradient）は（variable）の勾配である（gradient、variable）のペアのリストを返します。「gradient」は &lt;code&gt;Tensor&lt;/code&gt; 、 &lt;code&gt;IndexedSlices&lt;/code&gt; 、または指定された変数に勾配がない場合は &lt;code&gt;None&lt;/code&gt; になる可能性があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="d316c810415832d0f55adcb10b604f9c47cbd2e8" translate="yes" xml:space="preserve">
          <source>This is the number of train steps running in TPU system before returning to CPU host for each &lt;code&gt;Session.run&lt;/code&gt;. This means global step is increased &lt;code&gt;iterations_per_loop&lt;/code&gt; times in one &lt;code&gt;Session.run&lt;/code&gt;. It is recommended to be set as number of global steps for next checkpoint. Note that in evaluation don't use this value, instead we run total eval &lt;code&gt;steps&lt;/code&gt; on TPU for a single &lt;code&gt;Session.run&lt;/code&gt;. [Experimental]: &lt;code&gt;iterations_per_loop&lt;/code&gt; can be specified as a time interval. To specify N seconds in one &lt;code&gt;Session.run&lt;/code&gt;, one can specify it as &lt;code&gt;Ns&lt;/code&gt; and substitute the N with the N with the number of desired seconds. Alternatively, the unit of time can also be specified in minutes or hours, e.g. &lt;code&gt;3600s&lt;/code&gt; or &lt;code&gt;60m&lt;/code&gt; or &lt;code&gt;1h&lt;/code&gt;.</source>
          <target state="translated">これは、各 &lt;code&gt;Session.run&lt;/code&gt; のCPUホストに戻る前にTPUシステムで実行されているトレインステップの数です。これは、グローバルステップが1つの &lt;code&gt;Session.run&lt;/code&gt; で &lt;code&gt;iterations_per_loop&lt;/code&gt; 時間増加することを意味します。次のチェックポイントのグローバルステップ数として設定することをお勧めします。評価ではこの値を使用しないでください。代わりに、単一の &lt;code&gt;Session.run&lt;/code&gt; に対してTPUで合計評価 &lt;code&gt;steps&lt;/code&gt; します。 [実験的]： &lt;code&gt;iterations_per_loop&lt;/code&gt; は時間間隔として指定できます。 1つの &lt;code&gt;Session.run&lt;/code&gt; でN秒を指定するには、 &lt;code&gt;Ns&lt;/code&gt; として指定できます。Nを希望の秒数のNに置き換えます。または、時間の単位を分または時間で指定することもできます（例： &lt;code&gt;3600s&lt;/code&gt; または &lt;code&gt;60m&lt;/code&gt; または &lt;code&gt;1h&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a40023f76ab90114029e1bcc91749b2e4391f638" translate="yes" xml:space="preserve">
          <source>This is the opposite of &lt;code&gt;pack&lt;/code&gt;.</source>
          <target state="translated">これは &lt;code&gt;pack&lt;/code&gt; の反対です。</target>
        </trans-unit>
        <trans-unit id="c3ea6e7a75310a4a77e1b1f56fba56b3219204d9" translate="yes" xml:space="preserve">
          <source>This is the opposite of &lt;code&gt;unpack&lt;/code&gt;.</source>
          <target state="translated">これは &lt;code&gt;unpack&lt;/code&gt; の反対です。</target>
        </trans-unit>
        <trans-unit id="b03c235347a9cd23cdcbcc99319938e9531d2ad0" translate="yes" xml:space="preserve">
          <source>This is the opposite of stack.</source>
          <target state="translated">これはスタックの逆です。</target>
        </trans-unit>
        <trans-unit id="2e4bca768b327e659a826ca7018b5b658cdefd12" translate="yes" xml:space="preserve">
          <source>This is the opposite of unstack. The numpy equivalent is</source>
          <target state="translated">これはunstackの逆です。numpyに相当するのは</target>
        </trans-unit>
        <trans-unit id="40e4198c7947cb171a27f0f2b96b5e41f088c377" translate="yes" xml:space="preserve">
          <source>This is the opposite of unstack. The numpy equivalent is &lt;code&gt;np.stack&lt;/code&gt;</source>
          <target state="translated">これはunstackの逆です。相当するnumpyは &lt;code&gt;np.stack&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="97cb38281f3bf589012ea6423fb54fdf27897538" translate="yes" xml:space="preserve">
          <source>This is the recommended way to check if a checkpoint exists, since it takes into account the naming difference between V1 and V2 formats.</source>
          <target state="translated">V1形式とV2形式のネーミングの違いを考慮しているので、チェックポイントが存在するかどうかを確認するのにおすすめの方法です。</target>
        </trans-unit>
        <trans-unit id="1ffa5c6451bfed59ad42e7f927c856cf80634c8e" translate="yes" xml:space="preserve">
          <source>This is the recommended way to get the mtimes, since it takes into account the naming difference between V1 and V2 formats.</source>
          <target state="translated">mtimesの取得方法は、V1とV2の形式のネーミングの違いを考慮しているので、これがおすすめです。</target>
        </trans-unit>
        <trans-unit id="e10b2d35c35f3fc21ee9a235cd260123a0e63325" translate="yes" xml:space="preserve">
          <source>This is the same as the number of Read executions that have succeeded.</source>
          <target state="translated">これは、成功したReadの実行回数と同じです。</target>
        </trans-unit>
        <trans-unit id="85a191debc0e75e9aae4867ba1a3abb350e8cdbd" translate="yes" xml:space="preserve">
          <source>This is the same as the number of ReaderRead executions that have succeeded.</source>
          <target state="translated">これは、成功したReaderReadの実行回数と同じです。</target>
        </trans-unit>
        <trans-unit id="f339ca988bca6265b32a0422f47f6bd298db3ffc" translate="yes" xml:space="preserve">
          <source>This is the second part of &lt;code&gt;minimize()&lt;/code&gt;. It returns an &lt;code&gt;Operation&lt;/code&gt; that applies gradients.</source>
          <target state="translated">これは、 &lt;code&gt;minimize()&lt;/code&gt; の 2番目の部分です。グラデーションを適用する &lt;code&gt;Operation&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="929a719e4fd77bb16e29532f382d40f922f3c1e7" translate="yes" xml:space="preserve">
          <source>This is the second part of &lt;code&gt;minimize()&lt;/code&gt;. It returns an &lt;code&gt;Operation&lt;/code&gt; that conditionally applies gradients if all gradient values are finite. Otherwise no update is performed (nor is &lt;code&gt;global_step&lt;/code&gt; incremented).</source>
          <target state="translated">これは、 &lt;code&gt;minimize()&lt;/code&gt; の 2番目の部分です。すべての勾配値が有限である場合、条件付きで勾配を適用する &lt;code&gt;Operation&lt;/code&gt; を返します。それ以外の場合、更新は実行されません（ &lt;code&gt;global_step&lt;/code&gt; は増分されません）。</target>
        </trans-unit>
        <trans-unit id="e8ee3ea42d612b02e009f45c4fa84d1cc896a5de" translate="yes" xml:space="preserve">
          <source>This is true if the variable dtype is not the same as the compute dtype.</source>
          <target state="translated">これは、変数dtypeがcomputeのdtypeと同じでない場合に真となります。</target>
        </trans-unit>
        <trans-unit id="91423d96c0eed87b88e95950664bbf721548ff0b" translate="yes" xml:space="preserve">
          <source>This is typically used by gradient computations for a broadcasting operation.</source>
          <target state="translated">これは、一般的に放送操作のための勾配計算で使用されます。</target>
        </trans-unit>
        <trans-unit id="a06d1207d293755800555755a98a415474a76700" translate="yes" xml:space="preserve">
          <source>This is typically used by gradient computations for a concat operation.</source>
          <target state="translated">これは通常、コンカット演算のための勾配計算で使用されます。</target>
        </trans-unit>
        <trans-unit id="599e1941b7c0f4f9a0022f3bce79b85ba3adcf41" translate="yes" xml:space="preserve">
          <source>This is typically used to create the weights of &lt;code&gt;Layer&lt;/code&gt; subclasses.</source>
          <target state="translated">これは通常、 &lt;code&gt;Layer&lt;/code&gt; サブクラスの重みを作成するために使用されます。</target>
        </trans-unit>
        <trans-unit id="c448d69e13a9acb17ee778d9369e5a1d63cab697" translate="yes" xml:space="preserve">
          <source>This is used for converting legacy Theano-saved model files.</source>
          <target state="translated">これは、レガシーのTheanoで保存されたモデルファイルを変換するために使用されます。</target>
        </trans-unit>
        <trans-unit id="05a2eba266c663d9424df49b8db51e4cc8c2df9e" translate="yes" xml:space="preserve">
          <source>This is used only for TfLite, it provides hints and it also makes the variables in the desired for the tflite ops (transposed and seaparated).</source>
          <target state="translated">これはTfLiteのためだけに使用され、ヒントを提供し、また、tfliteのOPSのための希望の変数(移調とシーパレート)を作成します。</target>
        </trans-unit>
        <trans-unit id="48e3efb832cfd45bd13919fdfde1ca19835cc159" translate="yes" xml:space="preserve">
          <source>This is used only for TfLite, it provides hints and it also makes the variables in the desired for the tflite ops (transposed and separated).</source>
          <target state="translated">これはTfLiteのためだけに使用され、ヒントを提供し、また、tfliteのOPSのために希望する変数の中の変数を作成します(転置と分離)。</target>
        </trans-unit>
        <trans-unit id="ad15eb7677663d9a7242cb23213706bc03ee0734" translate="yes" xml:space="preserve">
          <source>This is used only for TfLite, it provides hints and it also makes the variables in the desired for the tflite ops.</source>
          <target state="translated">これはTfLiteでのみ使用され、ヒントを提供し、tfliteの操作に必要な変数を作成します。</target>
        </trans-unit>
        <trans-unit id="aa63c8ad524a0fffe274fd0f59f47f9f37029b1b" translate="yes" xml:space="preserve">
          <source>This is used to convert from a TensorFlow GraphDef, SavedModel or tf.keras model into either a TFLite FlatBuffer or graph visualization.</source>
          <target state="translated">これは、TensorFlow GraphDef、SavedModel、または tf.keras モデルを TFLite FlatBuffer またはグラフ表示に変換するために使用されます。</target>
        </trans-unit>
        <trans-unit id="42aa887e1a89f1c6a2cebd74bb895f76b927be77" translate="yes" xml:space="preserve">
          <source>This is used to decide whether loss should be scaled in optimizer (used only for estimator + v1 optimizer use case).</source>
          <target state="translated">これは、オプティマイザで損失をスケーリングするかどうかを決定するために使用されます(エスティメー タ+v1 オプティマイザのユースケースでのみ使用されます)。</target>
        </trans-unit>
        <trans-unit id="b17cf82d54ada528ca921a0efa90b52815fa4b91" translate="yes" xml:space="preserve">
          <source>This is used to prepare for toco conversion of complex intrinsic usages. Note: only one of session or graph_def should be used, not both.</source>
          <target state="translated">これは、複雑な固有用途のtoco変換の準備のために使用されます。注意:sessionかgraph_defのどちらか一方のみを使用し、両方を使用してはいけません。</target>
        </trans-unit>
        <trans-unit id="c7bb1bcc7e14a92bfe2b3cdc7e1ae060a3c52e44" translate="yes" xml:space="preserve">
          <source>This is useful any time you want to compute a value with TensorFlow but need to pretend that the value was a constant. Some examples include:</source>
          <target state="translated">これは、TensorFlowで値を計算したいが、その値が定数であるかのように振る舞う必要がある場合に便利です。いくつかの例があります。</target>
        </trans-unit>
        <trans-unit id="615f9e8a59ff4f1c3fc7f3ec9b1dd3650508efec" translate="yes" xml:space="preserve">
          <source>This is useful as a placeholder in code that expects a context manager.</source>
          <target state="translated">これは、コンテキストマネージャを期待するコードのプレースホルダとして便利です。</target>
        </trans-unit>
        <trans-unit id="150d8f70445d33c34b068178e2af6c26bf08bf36" translate="yes" xml:space="preserve">
          <source>This is useful for debugging and providing early errors. For example, when tracing a &lt;a href=&quot;function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt;, no ops are being executed, shapes may be unknown (See the &lt;a href=&quot;https://www.tensorflow.org/guide/concrete_function&quot;&gt;Concrete Functions Guide&lt;/a&gt; for details).</source>
          <target state="translated">これは、デバッグと初期エラーの提供に役立ちます。たとえば、&lt;a href=&quot;function&quot;&gt; &lt;code&gt;tf.function&lt;/code&gt; を&lt;/a&gt;トレースする場合、opsは実行されておらず、形状が不明である可能性があります（詳細については、&lt;a href=&quot;https://www.tensorflow.org/guide/concrete_function&quot;&gt;具体的な関数ガイド&lt;/a&gt;を参照してください）。</target>
        </trans-unit>
        <trans-unit id="b9563699660ae889442bbf807a27eb9beba27100" translate="yes" xml:space="preserve">
          <source>This is useful for separating training updates and state updates, e.g. when we need to update a layer's internal state during prediction.</source>
          <target state="translated">これは、予測中にレイヤーの内部状態を更新する必要がある場合など、トレーニングの更新と状態の更新を分離するのに便利です。</target>
        </trans-unit>
        <trans-unit id="946e89dc12a7c9a5e1ede20576867301b896367c" translate="yes" xml:space="preserve">
          <source>This is useful for sequence tasks in which the elements have variable length. Grouping together elements that have similar lengths reduces the total fraction of padding in a batch which increases training step efficiency.</source>
          <target state="translated">これは、要素の長さが可変であるシーケンスタスクに便利です。長さが似ている要素をグループ化することで、バッチ内のパディングの合計割合を減らすことができ、学習ステップの効率を高めることができます。</target>
        </trans-unit>
        <trans-unit id="750a87642623af70551e01a6394d91315e9bfbb7" translate="yes" xml:space="preserve">
          <source>This is useful if you don't want to exit the context manager for the tape, or can't because the desired reset point is inside a control flow construct:</source>
          <target state="translated">これは、テープのコンテキスト・マネージャを終了したくない場合や、希望するリセット・ポイントがコントロール・フロー構造体の中にあるために終了できない場合に便利です。</target>
        </trans-unit>
        <trans-unit id="1c4209d707783ab42b6537361cd0e771e2838f9d" translate="yes" xml:space="preserve">
          <source>This is useful in summaries to measure and report sparsity. For example,</source>
          <target state="translated">これは、スパース度を測定して報告するためのサマリーに便利です。例えば</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
