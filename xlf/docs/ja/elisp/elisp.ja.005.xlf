<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="elisp">
    <body>
      <group id="elisp">
        <trans-unit id="3a21eefa10a38bebd685a041bc883db13a690f78" translate="yes" xml:space="preserve">
          <source>A sparse keymap used by buttons.</source>
          <target state="translated">ボタンで使用される疎なキーマップ。</target>
        </trans-unit>
        <trans-unit id="7a6d924c29a314704225148c6f1e8e4dd9598ef6" translate="yes" xml:space="preserve">
          <source>A sparse keymap used for responses in &lt;code&gt;query-replace&lt;/code&gt; and related commands; also for &lt;code&gt;y-or-n-p&lt;/code&gt; and &lt;code&gt;map-y-or-n-p&lt;/code&gt;. The functions that use this map do not support prefix keys; they look up one event at a time. &lt;code&gt;multi-query-replace-map&lt;/code&gt; extends &lt;code&gt;query-replace-map&lt;/code&gt; for multi-buffer replacements. See &lt;a href=&quot;search-and-replace#Search-and-Replace&quot;&gt;query-replace-map&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;query-replace&lt;/code&gt; および関連コマンドの応答に使用されるスパースキーマップ。他にも &lt;code&gt;y-or-n-p&lt;/code&gt; 及び &lt;code&gt;map-y-or-n-p&lt;/code&gt; 。このマップを使用する関数は、プレフィックスキーをサポートしていません。一度に1つのイベントを検索します。 &lt;code&gt;multi-query-replace-map&lt;/code&gt; は、マルチバッファ置換のためにquery-replace-mapを拡張し &lt;code&gt;query-replace-map&lt;/code&gt; 。&lt;a href=&quot;search-and-replace#Search-and-Replace&quot;&gt;query-replace-mapを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="2273ae4dbb377e2aa911010dd8b2da0b64c40b7c" translate="yes" xml:space="preserve">
          <source>A sparse keymap used for the</source>
          <target state="translated">に使用される疎なキーマップです。</target>
        </trans-unit>
        <trans-unit id="7144fe372d5198217578856f61ea2cf40f8209ff" translate="yes" xml:space="preserve">
          <source>A sparse keymap used to map certain keys under graphical frames. The function &lt;code&gt;x-setup-function-keys&lt;/code&gt; uses this.</source>
          <target state="translated">グラフィカルフレームの下に特定のキーをマップするために使用されるスパースキーマップ。関数 &lt;code&gt;x-setup-function-keys&lt;/code&gt; はこれを使用します。</target>
        </trans-unit>
        <trans-unit id="88e891a88be3fe4e62330f9bb2210843e83520a9" translate="yes" xml:space="preserve">
          <source>A sparse keymap used while processing</source>
          <target state="translated">処理中に使用されるスパースキーマップ</target>
        </trans-unit>
        <trans-unit id="765649c4f2ad56ec8ad2f598cca04c9ff7b7da2a" translate="yes" xml:space="preserve">
          <source>A sparse keymap useful for buffers containing buffers. You may want to use this as a parent keymap. See &lt;a href=&quot;buttons#Buttons&quot;&gt;Buttons&lt;/a&gt;.</source>
          <target state="translated">バッファを含むバッファに役立つスパースキーマップ。これを親キーマップとして使用することをお勧めします。&lt;a href=&quot;buttons#Buttons&quot;&gt;ボタンを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="5f4ac56519c11e0fe0577b1cad8ce3bbe4207fc9" translate="yes" xml:space="preserve">
          <source>A special feature allows you to specify expressions to evaluate if and when a file is loaded (see &lt;a href=&quot;hooks-for-loading#Hooks-for-Loading&quot;&gt;Hooks for Loading&lt;/a&gt;). That feature is not exactly a hook, but does a similar job.</source>
          <target state="translated">特別な機能を使用すると、ファイルがロードされるかどうか、およびいつロードされるかを評価する式を指定できます（&lt;a href=&quot;hooks-for-loading#Hooks-for-Loading&quot;&gt;ロード用のフックを&lt;/a&gt;参照）。その機能は正確にはフックではありませんが、同様の仕事をします。</target>
        </trans-unit>
        <trans-unit id="5be02abf64fa9f6d03c8545ca5b0ef5253cf8321" translate="yes" xml:space="preserve">
          <source>A special kind of key binding can be used to &lt;em&gt;remap&lt;/em&gt; one command to another, without having to refer to the key sequence(s) bound to the original command. To use this feature, make a key binding for a key sequence that starts with the dummy event &lt;code&gt;remap&lt;/code&gt;, followed by the command name you want to remap; for the binding, specify the new definition (usually a command name, but possibly any other valid definition for a key binding).</source>
          <target state="translated">特別な種類のキーバインディングを使用すると、元のコマンドにバインドされたキーシーケンスを参照しなくても、あるコマンドを別のコマンドに&lt;em&gt;再マップ&lt;/em&gt;できます。この機能を使用するには、ダミーイベントの &lt;code&gt;remap&lt;/code&gt; で始まり、その後に再マップするコマンド名が続くキーシーケンスのキーバインディングを作成します。バインディングには、新しい定義を指定します（通常はコマンド名ですが、キーバインディングの他の有効な定義の場合もあります）。</target>
        </trans-unit>
        <trans-unit id="b3b13190b49396edf46334298af39e2a2e3045a9" translate="yes" xml:space="preserve">
          <source>A specially constructed list.</source>
          <target state="translated">特別に構築されたリスト。</target>
        </trans-unit>
        <trans-unit id="cdeb8b40b772b9f3c7e2c98e3c8b8dec4698471b" translate="yes" xml:space="preserve">
          <source>A specification can have a &lt;em&gt;width&lt;/em&gt;, which is a decimal number that appears after any field number and flags. If the printed representation of the object contains fewer characters than this width, &lt;code&gt;format&lt;/code&gt; extends it with padding. Any padding introduced by the width normally consists of spaces inserted on the left:</source>
          <target state="translated">仕様には&lt;em&gt;幅を含める&lt;/em&gt;ことができます。これは、フィールド番号とフラグの後に表示される10進数です。オブジェクトの印刷された表現に含まれる文字がこの幅より少ない場合、 &lt;code&gt;format&lt;/code&gt; はパディングでオブジェクトを拡張します。幅によって導入されるパディングは通常、左側に挿入されたスペースで構成されます。</target>
        </trans-unit>
        <trans-unit id="fffe787c50a5092035410b47c5d5ac737f027fa9" translate="yes" xml:space="preserve">
          <source>A specification list may contain sublists, which match arguments that are themselves lists, or it may contain vectors used for grouping. Sublists and groups thus subdivide the specification list into a hierarchy of levels. Specification keywords apply only to the remainder of the sublist or group they are contained in.</source>
          <target state="translated">仕様リストは、それ自体がリストである引数にマッチするサブリストを含んでいてもよいし、グループ化に使われるベクターを含んでいてもよい。このように、サブリストとグループは、仕様リストをレベルの階層に細分化します。仕様キーワードは、それらが含まれるサブリストやグループの残りの部分にのみ適用されます。</target>
        </trans-unit>
        <trans-unit id="9468aabf9aff18dfe4927c4df0cf6ef94a873fcf" translate="yes" xml:space="preserve">
          <source>A string as a mode line construct appears verbatim except for &lt;em&gt;&lt;code&gt;%&lt;/code&gt;-constructs&lt;/em&gt; in it. These stand for substitution of other data; see &lt;a href=&quot;_0025_002dconstructs#g_t_0025_002dConstructs&quot;&gt;%-Constructs&lt;/a&gt;.</source>
          <target state="translated">モードライン構成としての文字列は、&lt;em&gt; &lt;code&gt;%&lt;/code&gt; -&lt;/em&gt;構成を除いて逐語的に表示されます。これらは他のデータの置換を表します。&lt;a href=&quot;_0025_002dconstructs#g_t_0025_002dConstructs&quot;&gt;％-構成を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="2532fec68eb63f66911855847dedf967f8f81556" translate="yes" xml:space="preserve">
          <source>A string as input will be used directly. It may be modified by the function (unlike most other Emacs Lisp functions) to reduce the chance of exposing sensitive data after the function does its work.</source>
          <target state="translated">入力としての文字列が直接使用されます。他のほとんどの Emacs Lisp 関数とは異なり、関数が処理を行った後に機密データを公開する可能性を減らすために、関数によって文字列を変更することができます。</target>
        </trans-unit>
        <trans-unit id="a8bebc2f246c21ea650e3cb3ac8fe99ed1f62459" translate="yes" xml:space="preserve">
          <source>A string can hold properties for the characters it contains, in addition to the characters themselves. This enables programs that copy text between strings and buffers to copy the text&amp;rsquo;s properties with no special effort. See &lt;a href=&quot;text-properties#Text-Properties&quot;&gt;Text Properties&lt;/a&gt;, for an explanation of what text properties mean. Strings with text properties use a special read and print syntax:</source>
          <target state="translated">文字列は、文字自体に加えて、文字列に含まれる文字のプロパティを保持できます。これにより、文字列とバッファの間でテキストをコピーするプログラムは、特別な労力なしでテキストのプロパティをコピーできます。テキストプロパティの意味の説明については、&lt;a href=&quot;text-properties#Text-Properties&quot;&gt;テキストプロパティを&lt;/a&gt;参照してください。テキストプロパティを持つ文字列は、特別な読み取りおよび印刷構文を使用します。</target>
        </trans-unit>
        <trans-unit id="dfef331cf99173b597cb3a4f9ebbdb7c1f294c0a" translate="yes" xml:space="preserve">
          <source>A string containing the same byte sequence as an XBM file would contain. You must not specify &lt;code&gt;:height&lt;/code&gt; and &lt;code&gt;:width&lt;/code&gt; in this case, because omitting them is what indicates the data has the format of an XBM file. The file contents specify the height and width of the image.</source>
          <target state="translated">XBMファイルと同じバイトシーケンスを含む文字列に含まれます。この場合、 &lt;code&gt;:height&lt;/code&gt; と &lt;code&gt;:width&lt;/code&gt; を指定しないでください。これらを省略すると、データがXBMファイルの形式になっていることがわかります。ファイルの内容は、画像の高さと幅を指定します。</target>
        </trans-unit>
        <trans-unit id="b80138eb0e7d2ee11a5334072539786172a5e2bd" translate="yes" xml:space="preserve">
          <source>A string displayed by the Emacs tooltip help system; by default, &lt;code&gt;&quot;mouse-2, RET: Push this button&quot;&lt;/code&gt;. Alternatively, a function that returns, or a form that evaluates to, a string to be displayed or &lt;code&gt;nil&lt;/code&gt;. For details see &lt;a href=&quot;special-properties#Text-help_002decho&quot;&gt;Text help-echo&lt;/a&gt;.</source>
          <target state="translated">Emacsツールチップヘルプシステムによって表示される文字列。デフォルトでは、 &lt;code&gt;&quot;mouse-2, RET: Push this button&quot;&lt;/code&gt; 。または、表示する文字列または &lt;code&gt;nil&lt;/code&gt; を返す関数または評価するフォーム。詳細については、&lt;a href=&quot;special-properties#Text-help_002decho&quot;&gt;テキストヘルプエコーを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="7e28e179ae46e636da2eca587a2ddde99c5d0cd9" translate="yes" xml:space="preserve">
          <source>A string in Emacs Lisp is an array that contains an ordered sequence of characters. Strings are used as names of symbols, buffers, and files; to send messages to users; to hold text being copied between buffers; and for many other purposes. Because strings are so important, Emacs Lisp has many functions expressly for manipulating them. Emacs Lisp programs use strings more often than individual characters.</source>
          <target state="translated">Emacs Lisp における文字列とは、文字列を順番に並べた配列のことです。文字列は、シンボル、バッファ、ファイルの名前、ユーザへのメッセージの送信、バッファ間でコピーされたテキストの保持、その他多くの目的で使用されます。文字列は非常に重要であるため、Emacs Lisp には、文字列を操作するための多くの関数が用意されています。Emacs Lisp プログラムでは、個々の文字よりも文字列を使用することが多いです。</target>
        </trans-unit>
        <trans-unit id="97d89176884a6777ab0a93f14e9b3cf203593d01" translate="yes" xml:space="preserve">
          <source>A string is a fixed sequence of characters. It is a type of sequence called a &lt;em&gt;array&lt;/em&gt;, meaning that its length is fixed and cannot be altered once it is created (see &lt;a href=&quot;sequences-arrays-vectors#Sequences-Arrays-Vectors&quot;&gt;Sequences Arrays Vectors&lt;/a&gt;). Unlike in C, Emacs Lisp strings are &lt;em&gt;not&lt;/em&gt; terminated by a distinguished character code.</source>
          <target state="translated">文字列は、文字の固定シーケンスです。これは、シーケンスの種類が呼び出された&lt;em&gt;配列を&lt;/em&gt;、その長さが固定されていることを意味し、それが作成されると（参照変更することができない&lt;a href=&quot;sequences-arrays-vectors#Sequences-Arrays-Vectors&quot;&gt;シーケンス配列ベクトルを&lt;/a&gt;）。Cとは異なり、EmacsLisp文字列は区別された文字コードで終了し&lt;em&gt;ません&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="fe9aa772c2d97bd3d2707cc2379051eb1e145422" translate="yes" xml:space="preserve">
          <source>A string is an array of characters and a vector is an array of arbitrary objects. A bool-vector can hold only &lt;code&gt;t&lt;/code&gt; or &lt;code&gt;nil&lt;/code&gt;. These kinds of array may have any length up to the largest fixnum, subject to system architecture limits and available memory. Char-tables are sparse arrays indexed by any valid character code; they can hold arbitrary objects.</source>
          <target state="translated">文字列は文字の配列であり、ベクトルは任意のオブジェクトの配列です。bool-vectorは、 &lt;code&gt;t&lt;/code&gt; または &lt;code&gt;nil&lt;/code&gt; のみを保持できます。これらの種類のアレイは、システムアーキテクチャの制限と使用可能なメモリに応じて、最大のfixnumまでの任意の長さを持つことができます。Char-tablesは、有効な文字コードでインデックス付けされたスパース配列です。それらは任意のオブジェクトを保持できます。</target>
        </trans-unit>
        <trans-unit id="2441898090949c6885e0d3b806fb9b48c4944a10" translate="yes" xml:space="preserve">
          <source>A string is text saved in the register.</source>
          <target state="translated">文字列はレジスタに保存されたテキストです。</target>
        </trans-unit>
        <trans-unit id="49f6b3f288e48e7a1e61f7ccbc7a20aa90fb1620" translate="yes" xml:space="preserve">
          <source>A string or a bool-vector containing the bits of the image (plus perhaps some extra bits at the end that will not be used). It should contain at least &lt;code&gt;&lt;var&gt;stride&lt;/var&gt;&amp;nbsp;*&amp;nbsp;&lt;var&gt;height&lt;/var&gt;&lt;/code&gt; bits, where &lt;var&gt;stride&lt;/var&gt; is the smallest multiple of 8 greater than or equal to the width of the image. In this case, you should specify &lt;code&gt;:height&lt;/code&gt;, &lt;code&gt;:width&lt;/code&gt; and &lt;code&gt;:stride&lt;/code&gt;, both to indicate that the string contains just the bits rather than a whole XBM file, and to specify the size of the image.</source>
          <target state="translated">画像のビットを含む文字列またはブールベクトル（さらに、最後に使用されない余分なビットがいくつかあります）。少なくとも &lt;code&gt;&lt;var&gt;stride&lt;/var&gt;&amp;nbsp;*&amp;nbsp;&lt;var&gt;height&lt;/var&gt;&lt;/code&gt; ビットが含まれている必要があります。 &lt;var&gt;stride&lt;/var&gt; は、画像の幅以上の8の最小公倍数です。この場合、 &lt;code&gt;:height&lt;/code&gt; 、 &lt;code&gt;:width&lt;/code&gt; 、および &lt;code&gt;:stride&lt;/code&gt; を指定して、文字列にXBMファイル全体ではなくビットのみが含まれていることを示し、画像のサイズを指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="036a59e22e9f954ee65be3ccd2c0ddd139f906a5" translate="yes" xml:space="preserve">
          <source>A string or vector as &lt;var&gt;command&lt;/var&gt; is executed with &lt;code&gt;execute-kbd-macro&lt;/code&gt;. A function is passed to &lt;code&gt;call-interactively&lt;/code&gt; (see above), along with the &lt;var&gt;record-flag&lt;/var&gt; and &lt;var&gt;keys&lt;/var&gt; arguments.</source>
          <target state="translated">&lt;var&gt;command&lt;/var&gt; としての文字列またはベクトルは、 &lt;code&gt;execute-kbd-macro&lt;/code&gt; で実行されます。関数は、 &lt;var&gt;record-flag&lt;/var&gt; および &lt;var&gt;keys&lt;/var&gt; 引数とともに、 &lt;code&gt;call-interactively&lt;/code&gt; （上記を参照）に渡されます。</target>
        </trans-unit>
        <trans-unit id="fb505d9a7d4b3f1a25ce86b9d3dae98375c606b2" translate="yes" xml:space="preserve">
          <source>A string starting with two or more dashes specifies a separator line; see &lt;a href=&quot;menu-separators#Menu-Separators&quot;&gt;Menu Separators&lt;/a&gt;.</source>
          <target state="translated">2つ以上のダッシュで始まる文字列は、区切り線を指定します。&lt;a href=&quot;menu-separators#Menu-Separators&quot;&gt;メニューセパレータを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="45afeec22e5b1392a38afb3af0c622aa891ec190" translate="yes" xml:space="preserve">
          <source>A string that gives the repository branch from which Emacs was built. In the most cases this is &lt;code&gt;&quot;master&quot;&lt;/code&gt;. If Emacs was built outside revision control, the value is &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">Emacsが構築されたリポジトリブランチを与える文字列。ほとんどの場合、これは &lt;code&gt;&quot;master&quot;&lt;/code&gt; です。Emacsがリビジョン管理の外部で構築された場合、値は &lt;code&gt;nil&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="a176c29cb00e1ce1efdc8fd4de377dd60ec1aa7c" translate="yes" xml:space="preserve">
          <source>A string that gives the repository revision from which Emacs was built. If Emacs was built outside revision control, the value is &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">Emacsが構築されたリポジトリリビジョンを与える文字列。Emacsがリビジョン管理の外部で構築された場合、値は &lt;code&gt;nil&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="32c2c310a05a2e4299069228d4059ebe12c87d4e" translate="yes" xml:space="preserve">
          <source>A string that is the name of the process&amp;rsquo;s controlling terminal. On Unix and GNU systems, this is normally the file name of the corresponding terminal device, such as</source>
          <target state="translated">プロセスの制御端末の名前である文字列。UnixおよびGNUシステムでは、これは通常、対応する端末デバイスのファイル名です。</target>
        </trans-unit>
        <trans-unit id="a07b76952ae2e1b9491a1beda81ccc1a2fb843d7" translate="yes" xml:space="preserve">
          <source>A structure describing where the cursor is in this window.</source>
          <target state="translated">このウィンドウ内のカーソルの位置を記述する構造体。</target>
        </trans-unit>
        <trans-unit id="20ca76b446ea261daca0ab9858048669216bed62" translate="yes" xml:space="preserve">
          <source>A structure describing where the cursor of this window physically is.</source>
          <target state="translated">このウィンドウのカーソルが物理的にどこにあるかを記述する構造体。</target>
        </trans-unit>
        <trans-unit id="283fbe00ae8cce4ea280dfbb7b15b846c6c4c692" translate="yes" xml:space="preserve">
          <source>A sublist specification may be a dotted list and the corresponding list argument may then be a dotted list. Alternatively, the last &lt;small&gt;CDR&lt;/small&gt; of a dotted list specification may be another sublist specification (via a grouping or an indirect specification, e.g., &lt;code&gt;(spec .  [(more
specs&amp;hellip;)])&lt;/code&gt;) whose elements match the non-dotted list arguments. This is useful in recursive specifications such as in the backquote example. Also see the description of a &lt;code&gt;nil&lt;/code&gt; specification above for terminating such recursion.</source>
          <target state="translated">サブリスト指定は点線のリストであり、対応するリスト引数は点線のリストである可能性があります。あるいは、点線リスト仕様の最後の&lt;small&gt;CDR&lt;/small&gt;は、要素が非点線リスト引数と一致する別のサブリスト仕様（グループ化または間接仕様、たとえば &lt;code&gt;(spec . [(more specs&amp;hellip;)])&lt;/code&gt; ）である場合があります。これは、バッククォートの例などの再帰的な仕様で役立ちます。このような再帰を終了するには、上記の &lt;code&gt;nil&lt;/code&gt; 仕様の説明も参照してください。</target>
        </trans-unit>
        <trans-unit id="e6bd63f0d6eed94cca2c1d7fa955eac6382d7a76" translate="yes" xml:space="preserve">
          <source>A subprocess of Emacs may be &lt;em&gt;synchronous&lt;/em&gt; or &lt;em&gt;asynchronous&lt;/em&gt;, depending on how it is created. When you create a synchronous subprocess, the Lisp program waits for the subprocess to terminate before continuing execution. When you create an asynchronous subprocess, it can run in parallel with the Lisp program. This kind of subprocess is represented within Emacs by a Lisp object which is also called a &amp;ldquo;process&amp;rdquo;. Lisp programs can use this object to communicate with the subprocess or to control it. For example, you can send signals, obtain status information, receive output from the process, or send input to it.</source>
          <target state="translated">Emacsのサブプロセスは、作成方法に応じて、&lt;em&gt;同期&lt;/em&gt;または&lt;em&gt;非同期の&lt;/em&gt;場合があります。同期サブプロセスを作成すると、Lispプログラムはサブプロセスが終了するのを待ってから実行を続行します。非同期サブプロセスを作成すると、Lispプログラムと並行して実行できます。この種のサブプロセスは、Emacs内で「プロセス」とも呼ばれるLispオブジェクトによって表されます。 Lispプログラムは、このオブジェクトを使用してサブプロセスと通信したり、サブプロセスを制御したりできます。たとえば、シグナルの送信、ステータス情報の取得、プロセスからの出力の受信、またはプロセスへの入力の送信を行うことができます。</target>
        </trans-unit>
        <trans-unit id="087de830e58dec95d6c61960121c78d539705185" translate="yes" xml:space="preserve">
          <source>A subprocess of Emacs running on the underlying OS.</source>
          <target state="translated">基盤となるOS上で動作するEmacsのサブプロセス。</target>
        </trans-unit>
        <trans-unit id="35507e345942623bfb6aa6be63bdded05b6c5918" translate="yes" xml:space="preserve">
          <source>A suitable kind of &lt;code&gt;file-error&lt;/code&gt; error is signaled if the file does not exist, or is not deletable. (On GNU and other POSIX-like systems, a file is deletable if its directory is writable.)</source>
          <target state="translated">ファイルが存在しない場合、または削除できない場合は、適切な種類の &lt;code&gt;file-error&lt;/code&gt; エラーが通知されます。（GNUおよびその他のPOSIXのようなシステムでは、ディレクトリが書き込み可能である場合、ファイルは削除可能です。）</target>
        </trans-unit>
        <trans-unit id="58e5791b58ed962f6049e196b317aabc08f3c119" translate="yes" xml:space="preserve">
          <source>A symbol as a mode line construct stands for its value. The value of &lt;var&gt;symbol&lt;/var&gt; is used as a mode line construct, in place of &lt;var&gt;symbol&lt;/var&gt;. However, the symbols &lt;code&gt;t&lt;/code&gt; and &lt;code&gt;nil&lt;/code&gt; are ignored, as is any symbol whose value is void.</source>
          <target state="translated">モードラインコンストラクトとしてのシンボルは、その値を表します。値 &lt;var&gt;symbol&lt;/var&gt; の代わりに、モードライン構築物として使用される &lt;var&gt;symbol&lt;/var&gt; 。ただし、値が無効であるシンボルと同様に、シンボル &lt;code&gt;t&lt;/code&gt; および &lt;code&gt;nil&lt;/code&gt; は無視されます。</target>
        </trans-unit>
        <trans-unit id="136dfe6f1f6290980b0a544df03bc8031bada37f" translate="yes" xml:space="preserve">
          <source>A symbol as input stream is equivalent to the symbol&amp;rsquo;s function definition (if any).</source>
          <target state="translated">入力ストリームとしてのシンボルは、シンボルの関数定義（存在する場合）と同等です。</target>
        </trans-unit>
        <trans-unit id="11075144c8ce3c1e072d1e5adaac43cdc6ed22f8" translate="yes" xml:space="preserve">
          <source>A symbol as output stream is equivalent to the symbol&amp;rsquo;s function definition (if any).</source>
          <target state="translated">出力ストリームとしてのシンボルは、シンボルの関数定義（存在する場合）と同等です。</target>
        </trans-unit>
        <trans-unit id="bce876b9cd2acba081d2ad07d0fc80b3afe79b3c" translate="yes" xml:space="preserve">
          <source>A symbol can serve as a variable, as a function name, or to hold a property list. Or it may serve only to be distinct from all other Lisp objects, so that its presence in a data structure may be recognized reliably. In a given context, usually only one of these uses is intended. But you can use one symbol in all of these ways, independently.</source>
          <target state="translated">シンボルは、変数として、関数名として、あるいはプロパティリストを保持するために使用することができます。あるいは、他のすべてのLispオブジェクトとは区別され、データ構造の中での存在を確実に認識できるようにするためだけに使われることもあります。与えられたコンテキストでは、通常、これらの用途のうちの1つだけが意図されています。しかし、1つのシンボルをこれらすべての方法で独立して使用することができます。</target>
        </trans-unit>
        <trans-unit id="1b40c765dfb974c4520f948565e6ea3abebbf26c" translate="yes" xml:space="preserve">
          <source>A symbol can serve as the name of a function.</source>
          <target state="translated">シンボルは、関数の名前として使用することができます。</target>
        </trans-unit>
        <trans-unit id="2522095758f15f287bcb68febcef4a1aef3c93ca" translate="yes" xml:space="preserve">
          <source>A symbol can serve as the name of a function. This happens when the symbol&amp;rsquo;s &lt;em&gt;function cell&lt;/em&gt; (see &lt;a href=&quot;symbol-components#Symbol-Components&quot;&gt;Symbol Components&lt;/a&gt;) contains a function object (e.g., a lambda expression). Then the symbol itself becomes a valid, callable function, equivalent to the function object in its function cell.</source>
          <target state="translated">シンボルは、関数の名前として使用できます。これは、シンボルの&lt;em&gt;関数セル&lt;/em&gt;（&lt;a href=&quot;symbol-components#Symbol-Components&quot;&gt;シンボルコンポーネントを&lt;/a&gt;参照）に関数オブジェクト（ラムダ式など）が含まれている場合に発生します。次に、シンボル自体が、関数セル内の関数オブジェクトと同等の、有効で呼び出し可能な関数になります。</target>
        </trans-unit>
        <trans-unit id="dc66ecbc9c4221d50048e15206869a3b042473a6" translate="yes" xml:space="preserve">
          <source>A symbol is a function to compute the height. It is called with the current height as argument, and should return the new height to use.</source>
          <target state="translated">シンボルは高さを計算する関数です。現在の高さを引数にして呼び出され、使用する新しい高さを返します。</target>
        </trans-unit>
        <trans-unit id="1735c25eacfa5dbfa81d50d3791a7b3948064021" translate="yes" xml:space="preserve">
          <source>A symbol may possess any number of &lt;em&gt;symbol properties&lt;/em&gt;, which can be used to record miscellaneous information about the symbol. For example, when a symbol has a &lt;code&gt;risky-local-variable&lt;/code&gt; property with a non-&lt;code&gt;nil&lt;/code&gt; value, that means the variable which the symbol names is a risky file-local variable (see &lt;a href=&quot;file-local-variables#File-Local-Variables&quot;&gt;File Local Variables&lt;/a&gt;).</source>
          <target state="translated">シンボルは、シンボルに関するその他の情報を記録するために使用できる、任意の数の&lt;em&gt;シンボルプロパティ&lt;/em&gt;を持つことができます。たとえば、シンボルに &lt;code&gt;nil&lt;/code&gt; 以外の値を持つ &lt;code&gt;risky-local-variable&lt;/code&gt; プロパティがある場合、それはシンボル名が危険なファイルローカル変数であることを意味します（&lt;a href=&quot;file-local-variables#File-Local-Variables&quot;&gt;ファイルローカル変数を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="4af456786cdb930cf51a2fe8cb251937c0f92f76" translate="yes" xml:space="preserve">
          <source>A symbol name can contain any characters whatever. Most symbol names are written with letters, digits, and the punctuation characters &amp;lsquo;</source>
          <target state="translated">シンボル名には、任意の文字を含めることができます。ほとんどの記号名は、文字、数字、句読文字で書かれています。</target>
        </trans-unit>
        <trans-unit id="c152fe70962941670ef3592324bbdb47115752ec" translate="yes" xml:space="preserve">
          <source>A symbol whose name starts with a colon (&amp;lsquo;</source>
          <target state="translated">名前がコロン（ '）で始まる記号</target>
        </trans-unit>
        <trans-unit id="3728c8c2eb3343e2a05d9141c3b791e811332750" translate="yes" xml:space="preserve">
          <source>A symbol. In other words, &lt;code&gt;(setf x y)&lt;/code&gt; is exactly equivalent to &lt;code&gt;(setq x y)&lt;/code&gt;, and &lt;code&gt;setq&lt;/code&gt; itself is strictly speaking redundant given that &lt;code&gt;setf&lt;/code&gt; exists. Most programmers will continue to prefer &lt;code&gt;setq&lt;/code&gt; for setting simple variables, though, for stylistic and historical reasons. The macro &lt;code&gt;(setf x y)&lt;/code&gt; actually expands to &lt;code&gt;(setq x y)&lt;/code&gt;, so there is no performance penalty for using it in compiled code.</source>
          <target state="translated">シンボル。言い換えると、 &lt;code&gt;(setf x y)&lt;/code&gt; は &lt;code&gt;(setq x y)&lt;/code&gt; xy）とまったく同じであり、 &lt;code&gt;setf&lt;/code&gt; が存在する場合、 &lt;code&gt;setq&lt;/code&gt; 自体は厳密に言えば冗長です。ただし、文体的および歴史的な理由から、ほとんどのプログラマーは単純な変数の設定に &lt;code&gt;setq&lt;/code&gt; を引き続き好むでしょう。マクロ &lt;code&gt;(setf x y)&lt;/code&gt; 実際には &lt;code&gt;(setq x y)&lt;/code&gt; xy）に展開されるため、コンパイルされたコードで使用してもパフォーマンスが低下することはありません。</target>
        </trans-unit>
        <trans-unit id="1954d27d0637fd3ddd907ebc88c0499752335e55" translate="yes" xml:space="preserve">
          <source>A syntax table can &lt;em&gt;inherit&lt;/em&gt; from another syntax table, which is called its &lt;em&gt;parent syntax table&lt;/em&gt;. A syntax table can leave the syntax class of some characters unspecified, by giving them the &amp;ldquo;inherit&amp;rdquo; syntax class; such a character then acquires the syntax class specified by the parent syntax table (see &lt;a href=&quot;syntax-class-table#Syntax-Class-Table&quot;&gt;Syntax Class Table&lt;/a&gt;). Emacs defines a &lt;em&gt;standard syntax table&lt;/em&gt;, which is the default parent syntax table, and is also the syntax table used by Fundamental mode.</source>
          <target state="translated">構文テーブルは、&lt;em&gt;親構文テーブル&lt;/em&gt;と呼ばれる別の構文テーブルから&lt;em&gt;継承&lt;/em&gt;でき&lt;em&gt;ます&lt;/em&gt;。構文テーブルでは、「継承」構文クラスを指定することにより、一部の文字の構文クラスを指定しないままにすることができます。このような文字は、親構文テーブルで指定された構文クラスを取得します（&lt;a href=&quot;syntax-class-table#Syntax-Class-Table&quot;&gt;構文クラステーブルを&lt;/a&gt;参照）。Emacsは、デフォルトの親構文テーブルであり、基本モードで使用される構文テーブルでもある&lt;em&gt;標準構文テーブルを&lt;/em&gt;定義します。</target>
        </trans-unit>
        <trans-unit id="b659b2d3d03e0d7773e900b73de02d70d5ddcd88" translate="yes" xml:space="preserve">
          <source>A syntax table is a data structure which can be used to look up the &lt;em&gt;syntax class&lt;/em&gt; and other syntactic properties of each character. Syntax tables are used by Lisp programs for scanning and moving across text.</source>
          <target state="translated">構文テーブルは、各文字の&lt;em&gt;構文クラス&lt;/em&gt;およびその他の構文プロパティを検索するために使用できるデータ構造です。構文テーブルは、テキストをスキャンして移動するためにLispプログラムによって使用されます。</target>
        </trans-unit>
        <trans-unit id="611cab9bf171d524f8bb167ff2d975371afdf4c3" translate="yes" xml:space="preserve">
          <source>A terminal device displays frames.</source>
          <target state="translated">端末装置はフレームを表示する。</target>
        </trans-unit>
        <trans-unit id="154579a3c3d7f8dbf4dedff1e12b0784abbfebd3" translate="yes" xml:space="preserve">
          <source>A themable named sound from the freedesktop.org sound naming specification from &amp;lsquo;</source>
          <target state="translated">'からのfreedesktop.orgサウンド命名仕様からのそれらの名前付きサウンド</target>
        </trans-unit>
        <trans-unit id="26c5fb26d2d40b902e4464e332d9e274ac27ae65" translate="yes" xml:space="preserve">
          <source>A thread of Emacs Lisp execution.</source>
          <target state="translated">Emacs Lisp実行のスレッド。</target>
        </trans-unit>
        <trans-unit id="57dfda42a48a44a57cc294b3f4f34e2af8232910" translate="yes" xml:space="preserve">
          <source>A token can be an &lt;code&gt;opener&lt;/code&gt; (something similar to an open-paren), a &lt;code&gt;closer&lt;/code&gt; (like a close-paren), or &lt;code&gt;neither&lt;/code&gt; of the two (e.g., an infix operator, or an inner token like &lt;code&gt;&quot;else&quot;&lt;/code&gt;).</source>
          <target state="translated">トークンは、 &lt;code&gt;opener&lt;/code&gt; （open-parenに似たもの）、 &lt;code&gt;closer&lt;/code&gt; （close-parenのような）、または2つの &lt;code&gt;neither&lt;/code&gt; でもない（たとえば、中置演算子、または &lt;code&gt;&quot;else&quot;&lt;/code&gt; のような内部トークン）ことができます。</target>
        </trans-unit>
        <trans-unit id="0d764cf0b69eb00f7e2c9718e179e351b46213d5" translate="yes" xml:space="preserve">
          <source>A tool bar is a row of images.</source>
          <target state="translated">ツールバーは画像が並んでいます。</target>
        </trans-unit>
        <trans-unit id="b6e511e3067670e626e12e33340269d446fde317" translate="yes" xml:space="preserve">
          <source>A translation table has two extra slots. The first is either &lt;code&gt;nil&lt;/code&gt; or a translation table that performs the reverse translation; the second is the maximum number of characters to look up for translating sequences of characters (see the description of &lt;code&gt;make-translation-table-from-alist&lt;/code&gt; below).</source>
          <target state="translated">変換テーブルには、2つの追加スロットがあります。1つ目は、 &lt;code&gt;nil&lt;/code&gt; または逆変換を実行する変換テーブルです。2番目は、文字のシーケンスを翻訳するために検索する文字の最大数です（以下の &lt;code&gt;make-translation-table-from-alist&lt;/code&gt; の説明を参照してください）。</target>
        </trans-unit>
        <trans-unit id="fdc3d3499bd5bb07db44fa25b08d5a6a535373e6" translate="yes" xml:space="preserve">
          <source>A true mirror-image of &lt;code&gt;re-search-forward&lt;/code&gt; would require a special feature for matching regular expressions from end to beginning. It&amp;rsquo;s not worth the trouble of implementing that.</source>
          <target state="translated">&lt;code&gt;re-search-forward&lt;/code&gt; の真の鏡像には、正規表現を最後から最初まで照合するための特別な機能が必要です。それを実装するのに苦労する価値はありません。</target>
        </trans-unit>
        <trans-unit id="d8e822f12fc2d0ada4fa0abd7fbe433aba2b4039" translate="yes" xml:space="preserve">
          <source>A type predicate function takes one argument; it returns &lt;code&gt;t&lt;/code&gt; if the argument belongs to the appropriate type, and &lt;code&gt;nil&lt;/code&gt; otherwise. Following a general Lisp convention for predicate functions, most type predicates&amp;rsquo; names end with &amp;lsquo;</source>
          <target state="translated">型述語関数は1つの引数を取ります。引数が適切な型に属している場合は &lt;code&gt;t&lt;/code&gt; を返し、そうでない場合は &lt;code&gt;nil&lt;/code&gt; を返します。述語関数の一般的なLisp規則に従って、ほとんどの型述語の名前は「」で終わります。</target>
        </trans-unit>
        <trans-unit id="0d50bc7f95aabd11c78a01358b272f4c298b3579" translate="yes" xml:space="preserve">
          <source>A type used for automatically loading seldom-used functions.</source>
          <target state="translated">滅多に使わない関数を自動的に読み込むためのタイプ。</target>
        </trans-unit>
        <trans-unit id="b25d98417944fbcf3fe27fffb07995fdd6887711" translate="yes" xml:space="preserve">
          <source>A typical value might look like this:</source>
          <target state="translated">典型的な値は次のようになるかもしれません。</target>
        </trans-unit>
        <trans-unit id="7068fb3333ff355206cad1f5c8ac4e885a7b5eaa" translate="yes" xml:space="preserve">
          <source>A unique number assigned to this window when it was created.</source>
          <target state="translated">このウィンドウが作成されたときに割り当てられた一意の番号。</target>
        </trans-unit>
        <trans-unit id="1f49c36b6b4f969d94158af5c04fa459e6fb756b" translate="yes" xml:space="preserve">
          <source>A user interface for building JSONRPC applications</source>
          <target state="translated">JSONRPCアプリケーションを構築するためのユーザーインターフェース</target>
        </trans-unit>
        <trans-unit id="da28673ff5250624bbd9c79fdce5b46476250e40" translate="yes" xml:space="preserve">
          <source>A value of &lt;code&gt;nil&lt;/code&gt; is equivalent to .5, since its effect is to center point. This variable automatically becomes buffer-local when set in any fashion.</source>
          <target state="translated">&lt;code&gt;nil&lt;/code&gt; の値は、その効果が中心点にあるため、.5に相当します。この変数は、何らかの方法で設定すると、自動的にバッファーローカルになります。</target>
        </trans-unit>
        <trans-unit id="761af930570eba02ee4263e0c4625df53668e35d" translate="yes" xml:space="preserve">
          <source>A value of &lt;code&gt;nil&lt;/code&gt; says to ignore the lock and let this user edit the file anyway.</source>
          <target state="translated">&lt;code&gt;nil&lt;/code&gt; の値は、ロックを無視し、このユーザーがファイルを編集できるようにすることを示します。</target>
        </trans-unit>
        <trans-unit id="2614ea86270afac8b5acd08878d712db67414cd0" translate="yes" xml:space="preserve">
          <source>A value of &lt;code&gt;t&lt;/code&gt; says to grab the lock on the file. Then this user may edit the file and &lt;var&gt;other-user&lt;/var&gt; loses the lock.</source>
          <target state="translated">&lt;code&gt;t&lt;/code&gt; の値は、ファイルのロックを取得することを示します。次に、このユーザーはファイルを編集でき、 &lt;var&gt;other-user&lt;/var&gt; はロックを失います。</target>
        </trans-unit>
        <trans-unit id="0f7035c80e73faf961d120dfe6ba3e3b9a60ff4c" translate="yes" xml:space="preserve">
          <source>A value of the form &lt;code&gt;(&lt;var&gt;num&lt;/var&gt; . &lt;var&gt;expr&lt;/var&gt;)&lt;/code&gt; stands for the product of the values of &lt;var&gt;num&lt;/var&gt; and &lt;var&gt;expr&lt;/var&gt;. For example, &lt;code&gt;(2 . in)&lt;/code&gt; specifies a width of 2 inches, while &lt;code&gt;(0.5 .
&lt;var&gt;image&lt;/var&gt;)&lt;/code&gt; specifies half the width (or height) of the specified &lt;var&gt;image&lt;/var&gt; (which should be given by its image spec).</source>
          <target state="translated">フォームの値 &lt;code&gt;(&lt;var&gt;num&lt;/var&gt; . &lt;var&gt;expr&lt;/var&gt;)&lt;/code&gt; の値の積を意味 &lt;var&gt;num&lt;/var&gt; と &lt;var&gt;expr&lt;/var&gt; 。たとえば、 &lt;code&gt;(2 . in)&lt;/code&gt; .in）は2インチの幅を指定し、 &lt;code&gt;(0.5 . &lt;var&gt;image&lt;/var&gt;)&lt;/code&gt; 指定された 画像の幅（または高さ）の半分を指定し &lt;var&gt;image&lt;/var&gt; （画像仕様で指定する必要があります）。</target>
        </trans-unit>
        <trans-unit id="7d6f07646985192c4276dea56a0bd52c3ee59a86" translate="yes" xml:space="preserve">
          <source>A variable can be let-bound (see &lt;a href=&quot;local-variables#Local-Variables&quot;&gt;Local Variables&lt;/a&gt;) to a value. This makes its global value shadowed by the binding; &lt;code&gt;default-value&lt;/code&gt; will then return the value from that binding, not the global value, and &lt;code&gt;set-default&lt;/code&gt; will be prevented from setting the global value (it will change the let-bound value instead). The following two functions allow to reference the global value even if it&amp;rsquo;s shadowed by a let-binding.</source>
          <target state="translated">変数は、値に&lt;a href=&quot;local-variables#Local-Variables&quot;&gt;自由に&lt;/a&gt;バインドできます（ローカル変数を参照）。これにより、そのグローバル値がバインディングによってシャドウされます。 &lt;code&gt;default-value&lt;/code&gt; は、グローバル値ではなく、そのバインディングから値を返し、 &lt;code&gt;set-default&lt;/code&gt; はグローバル値を設定できなくなります（代わりにlet-bound値が変更されます）。次の2つの関数を使用すると、let-bindingによってシャドウされている場合でも、グローバル値を参照できます。</target>
        </trans-unit>
        <trans-unit id="42469365ae54b87406fe0c4580eafab3e15cd7f7" translate="yes" xml:space="preserve">
          <source>A variable can have buffer-local bindings in some buffers but not in other buffers. The default binding is shared by all the buffers that don&amp;rsquo;t have their own bindings for the variable. (This includes all newly-created buffers.) If you set the variable in a buffer that does not have a buffer-local binding for it, this sets the default binding, so the new value is visible in all the buffers that see the default binding.</source>
          <target state="translated">変数は、一部のバッファーではバッファーローカルバインディングを持つことができますが、他のバッファーでは持つことができません。デフォルトのバインディングは、変数に対する独自のバインディングを持たないすべてのバッファーで共有されます。（これには、新しく作成されたすべてのバッファーが含まれます。）バッファーローカルバインディングがないバッファーに変数を設定すると、デフォルトのバインディングが設定されるため、デフォルトを表示するすべてのバッファーに新しい値が表示されます。バインディング。</target>
        </trans-unit>
        <trans-unit id="7229e30ed01c65b1f554b2be31bb3ad0ddba289e" translate="yes" xml:space="preserve">
          <source>A variable can have more than one local binding at a time (e.g., if there are nested &lt;code&gt;let&lt;/code&gt; forms that bind the variable). The &lt;em&gt;current binding&lt;/em&gt; is the local binding that is actually in effect. It determines the value returned by evaluating the variable symbol, and it is the binding acted on by &lt;code&gt;setq&lt;/code&gt;.</source>
          <target state="translated">変数は、一度に複数のローカルバインディングを持つことができます（たとえば、変数をバインドするネスト &lt;code&gt;let&lt;/code&gt; れたletフォームがある場合）。&lt;em&gt;結合電流が&lt;/em&gt;有効に実際にあるものバインディングローカルです。これは、変数シンボルを評価することによって返される値を決定し、 &lt;code&gt;setq&lt;/code&gt; によって作用されるバインディングです。</target>
        </trans-unit>
        <trans-unit id="a1ac65fb2f3cee8bab9b33ddf4b381098337ecd1" translate="yes" xml:space="preserve">
          <source>A variable declared to be a user option (i.e., satisfying the predicate &lt;code&gt;custom-variable-p&lt;/code&gt;). This reads the variable using &lt;code&gt;read-variable&lt;/code&gt;. See &lt;a href=&quot;high_002dlevel-completion#Definition-of-read_002dvariable&quot;&gt;Definition of read-variable&lt;/a&gt;. Existing, Completion, Prompt.</source>
          <target state="translated">ユーザーオプションとして宣言された変数（つまり、述語 &lt;code&gt;custom-variable-p&lt;/code&gt; を満たす）。これは、 &lt;code&gt;read-variable&lt;/code&gt; を使用して変数を読み取ります。&lt;a href=&quot;high_002dlevel-completion#Definition-of-read_002dvariable&quot;&gt;読み取り変数の定義を&lt;/a&gt;参照してください。既存、完了、プロンプト。</target>
        </trans-unit>
        <trans-unit id="714788a2d69016197f589516788c6c86a085d831" translate="yes" xml:space="preserve">
          <source>A variable definition serves three purposes. First, it informs people who read the code that the symbol is &lt;em&gt;intended&lt;/em&gt; to be used a certain way (as a variable). Second, it informs the Lisp system of this, optionally supplying an initial value and a documentation string. Third, it provides information to programming tools such as &lt;code&gt;etags&lt;/code&gt;, allowing them to find where the variable was defined.</source>
          <target state="translated">変数定義には3つの目的があります。まず、コードを読んだ人に、シンボルが特定の方法で（変数として）使用される&lt;em&gt;こと&lt;/em&gt;を&lt;em&gt;意図&lt;/em&gt;していることを通知します。次に、Lispシステムにこれを通知し、オプションで初期値とドキュメント文字列を提供します。第三に、 &lt;code&gt;etags&lt;/code&gt; などのプログラミングツールに情報を提供し、変数が定義された場所を見つけることができるようにします。</target>
        </trans-unit>
        <trans-unit id="6d8469682cf6ae5ee24fbb06b606a67a9bdca6f1" translate="yes" xml:space="preserve">
          <source>A vector of elements groups the elements into a single &lt;em&gt;group specification&lt;/em&gt;. Its meaning has nothing to do with vectors.</source>
          <target state="translated">要素のベクトルは、要素を単一の&lt;em&gt;グループ仕様にグループ化します&lt;/em&gt;。その意味はベクトルとは何の関係もありません。</target>
        </trans-unit>
        <trans-unit id="907ba2db0b69ea3ac390ffc8957c9f20ac952af1" translate="yes" xml:space="preserve">
          <source>A vector of glyphs for indicating the presence of invisible lines (the default is &amp;lsquo;</source>
          <target state="translated">目に見えない線の存在を示すためのグリフのベクトル（デフォルトは '</target>
        </trans-unit>
        <trans-unit id="5b9d67749d8a12ed598e9d50f8a2fa40ed3d9434" translate="yes" xml:space="preserve">
          <source>A vector of strings or bool-vectors, each specifying one line of the image. Do specify &lt;code&gt;:height&lt;/code&gt; and &lt;code&gt;:width&lt;/code&gt;.</source>
          <target state="translated">文字列またはブールベクトルのベクトル。それぞれが画像の1行を指定します。 &lt;code&gt;:height&lt;/code&gt; と &lt;code&gt;:width&lt;/code&gt; を指定してください。</target>
        </trans-unit>
        <trans-unit id="bfd393f14b47e46b8b1b11b3ee71f7e6e4effd32" translate="yes" xml:space="preserve">
          <source>A vector, like a string or a number, is considered a constant for evaluation: the result of evaluating it is the same vector. This does not evaluate or even examine the elements of the vector. See &lt;a href=&quot;self_002devaluating-forms#Self_002dEvaluating-Forms&quot;&gt;Self-Evaluating Forms&lt;/a&gt;. Vectors written with square brackets should not be modified via &lt;code&gt;aset&lt;/code&gt; or other destructive operations. See &lt;a href=&quot;mutability#Mutability&quot;&gt;Mutability&lt;/a&gt;.</source>
          <target state="translated">文字列や数値などのベクトルは、評価の定数と見なされます。評価の結果は同じベクトルです。これは、ベクトルの要素を評価したり、調べたりすることはありません。&lt;a href=&quot;self_002devaluating-forms#Self_002dEvaluating-Forms&quot;&gt;自己評価フォームを&lt;/a&gt;参照してください。角括弧で記述されたベクトルは、 &lt;code&gt;aset&lt;/code&gt; またはその他の破壊的な操作によって変更しないでください。&lt;a href=&quot;mutability#Mutability&quot;&gt;可変性を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="cea3cbc11949c249de3312f294eef9cb9f938425" translate="yes" xml:space="preserve">
          <source>A version number, in a form that the function &lt;code&gt;version-to-list&lt;/code&gt; understands (e.g., &amp;lsquo;</source>
          <target state="translated">関数 &lt;code&gt;version-to-list&lt;/code&gt; が理解できる形式のバージョン番号（例： '</target>
        </trans-unit>
        <trans-unit id="d6f9261a2dce5769b4273b16b8e7e92056f25007" translate="yes" xml:space="preserve">
          <source>A very simple parsing technique.</source>
          <target state="translated">非常にシンプルな構文解析のテクニックです。</target>
        </trans-unit>
        <trans-unit id="a21b6bc0e953a05c7047f6926acdf8cdb6092af2" translate="yes" xml:space="preserve">
          <source>A visible child frame always appears on top of its parent frame thus obscuring parts of it, except on NS builds where it may be positioned beneath the parent. This is comparable to the window-system window of a top-level frame which also always appears on top of its parent window&amp;mdash;the desktop&amp;rsquo;s root window. When a parent frame is iconified or made invisible (see &lt;a href=&quot;visibility-of-frames#Visibility-of-Frames&quot;&gt;Visibility of Frames&lt;/a&gt;), its child frames are made invisible. When a parent frame is deiconified or made visible, its child frames are made visible.</source>
          <target state="translated">表示されている子フレームは常に親フレームの上に表示されるため、親の下に配置される可能性のあるNSビルドを除いて、その一部が不明瞭になります。これは、常に親ウィンドウ（デスクトップのルートウィンドウ）の上に表示されるトップレベルフレームのウィンドウシステムウィンドウに相当します。親フレームがアイコン化または非表示にされると（&lt;a href=&quot;visibility-of-frames#Visibility-of-Frames&quot;&gt;フレームの可視性を&lt;/a&gt;参照）、その子フレームは非表示になります。親フレームが非アイコン化または表示されると、その子フレームが表示されます。</target>
        </trans-unit>
        <trans-unit id="3f15d83470f651a16357e3fbbafed38889367d47" translate="yes" xml:space="preserve">
          <source>A visible frame occupies a rectangular area on its terminal&amp;rsquo;s display. This area may contain a number of nested rectangles, each serving a different purpose. The drawing below sketches the layout of a frame on a graphical terminal:</source>
          <target state="translated">表示されているフレームは、端末のディスプレイの長方形の領域を占めています。この領域には、それぞれが異なる目的を果たす、いくつかのネストされた長方形が含まれる場合があります。以下の図は、グラフィカル端末でのフレームのレイアウトを示しています。</target>
        </trans-unit>
        <trans-unit id="9dc2f20dda99554f7dead3ef07cf05023791995d" translate="yes" xml:space="preserve">
          <source>A watch can become invalid if the file or directory it watches is deleted, or if the watcher thread exits abnormally for any other reason. Removing the watch by calling &lt;code&gt;file-notify-rm-watch&lt;/code&gt; also makes it invalid.</source>
          <target state="translated">ウォッチするファイルまたはディレクトリが削除された場合、またはウォッチャースレッドがその他の理由で異常終了した場合、ウォッチは無効になる可能性があります。 &lt;code&gt;file-notify-rm-watch&lt;/code&gt; を呼び出して時計を削除すると、時計も無効になります。</target>
        </trans-unit>
        <trans-unit id="efb12abaf84e2ff0588000ce76b06f219405368d" translate="yes" xml:space="preserve">
          <source>A web server providing access to a package archive must support the following queries:</source>
          <target state="translated">パッケージアーカイブへのアクセスを提供する Web サーバは、以下のクエリをサポートしている必要があります。</target>
        </trans-unit>
        <trans-unit id="96a8665d6abd124bc5fe28303880a92b178554c2" translate="yes" xml:space="preserve">
          <source>A well-designed macro definition takes steps to avoid this problem by producing an expansion that evaluates the argument expressions exactly once unless repeated evaluation is part of the intended purpose of the macro. Here is a correct expansion for the &lt;code&gt;for&lt;/code&gt; macro:</source>
          <target state="translated">適切に設計されたマクロ定義は、繰り返しの評価がマクロの意図された目的の一部でない限り、引数式を1回だけ評価する展開を生成することにより、この問題を回避するための手順を実行します。 &lt;code&gt;for&lt;/code&gt; マクロの正しい展開は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="b1827635d79dea77c5cd2894c432de677a45e87a" translate="yes" xml:space="preserve">
          <source>A window can get resized explicitly by using one of the functions from the preceding section or implicitly, for example, when resizing an adjacent window, when splitting or deleting a window (see &lt;a href=&quot;splitting-windows#Splitting-Windows&quot;&gt;Splitting Windows&lt;/a&gt;, see &lt;a href=&quot;deleting-windows#Deleting-Windows&quot;&gt;Deleting Windows&lt;/a&gt;) or when resizing the window&amp;rsquo;s frame (see &lt;a href=&quot;frame-size#Frame-Size&quot;&gt;Frame Size&lt;/a&gt;).</source>
          <target state="translated">ウィンドウは、前のセクションの関数の1つを使用して明示的に、または暗黙的に、たとえば、隣接するウィンドウのサイズ変更時、ウィンドウの分割または削除時（ウィンドウの&lt;a href=&quot;splitting-windows#Splitting-Windows&quot;&gt;分割&lt;/a&gt;、ウィンドウの&lt;a href=&quot;deleting-windows#Deleting-Windows&quot;&gt;削除を&lt;/a&gt;参照）、またはウィンドウのフレームのサイズ変更時（ウィンドウのサイズ変更を参照）にサイズ変更できます。&lt;a href=&quot;frame-size#Frame-Size&quot;&gt;フレームサイズを&lt;/a&gt;参照してください）。</target>
        </trans-unit>
        <trans-unit id="da0f4aabb2b28d1adb4d16bd804393865c93bf0e" translate="yes" xml:space="preserve">
          <source>A window can have a &lt;em&gt;header line&lt;/em&gt; at the top, just as it can have a mode line at the bottom. The header line feature works just like the mode line feature, except that it&amp;rsquo;s controlled by &lt;code&gt;header-line-format&lt;/code&gt;:</source>
          <target state="translated">ウィンドウの下部にモード行があるのと同じように、ウィンドウの上部に&lt;em&gt;ヘッダー行&lt;/em&gt;を&lt;em&gt;含める&lt;/em&gt;ことができます。ヘッダー行機能は、 &lt;code&gt;header-line-format&lt;/code&gt; によって制御されることを除いて、モード行機能と同じように機能します。</target>
        </trans-unit>
        <trans-unit id="7eb040f86ff87638d96bfd4ec298244d1a1c95a8" translate="yes" xml:space="preserve">
          <source>A window is resized if and only if it has been specially created for the buffer. In particular, windows that have shown another buffer before are not resized. By default, this mode uses &lt;code&gt;fit-window-to-buffer&lt;/code&gt; (see &lt;a href=&quot;resizing-windows#Resizing-Windows&quot;&gt;Resizing Windows&lt;/a&gt;) for resizing. You can specify a different function by customizing the options &lt;code&gt;temp-buffer-max-height&lt;/code&gt; and &lt;code&gt;temp-buffer-max-width&lt;/code&gt; below.</source>
          <target state="translated">ウィンドウは、バッファ用に特別に作成されている場合にのみサイズ変更されます。特に、以前に別のバッファを表示したことがあるウィンドウはサイズ変更されません。デフォルトでは、このモードの使用は、 &lt;code&gt;fit-window-to-buffer&lt;/code&gt; （参照&lt;a href=&quot;resizing-windows#Resizing-Windows&quot;&gt;ウィンドウのサイズ変更を&lt;/a&gt;リサイズするために）。以下のオプション &lt;code&gt;temp-buffer-max-height&lt;/code&gt; および &lt;code&gt;temp-buffer-max-width&lt;/code&gt; をカスタマイズすることにより、別の関数を指定できます。</target>
        </trans-unit>
        <trans-unit id="5b181ae523d21d580fe4dc9490e28d52beda4e36" translate="yes" xml:space="preserve">
          <source>A window showing a temporary buffer can be fitted to the size of that buffer using the following mode:</source>
          <target state="translated">テンポラリバッファを表示するウィンドウは、以下のモードを使用して、そのバッファのサイズに合わせてフィットさせることができます。</target>
        </trans-unit>
        <trans-unit id="10b80aceee959c8dcb16c72ed1a2553043421e82" translate="yes" xml:space="preserve">
          <source>A window that is just one line tall never displays a header line. A window that is two lines tall cannot display both a mode line and a header line at once; if it has a mode line, then it does not display a header line.</source>
          <target state="translated">1 行だけのウィンドウにはヘッダ行は表示されない。2 行の高さのウィンドウは、モード行とヘッダ行の両方を同時に表示することはできません。</target>
        </trans-unit>
        <trans-unit id="6004ea783485bff5b8ff0a2c4b58ed331fceaf67" translate="yes" xml:space="preserve">
          <source>A window that showed &lt;var&gt;buffer&lt;/var&gt; before, provided it is not the selected window.</source>
          <target state="translated">示されたウィンドウ &lt;var&gt;buffer&lt;/var&gt; 前には、それが選択されたウィンドウではないが提供されます。</target>
        </trans-unit>
        <trans-unit id="24fac820e9dc3bcfec792e9cbea05e313a184dd9" translate="yes" xml:space="preserve">
          <source>A working buffer for decoding.</source>
          <target state="translated">デコードのための作業用バッファ。</target>
        </trans-unit>
        <trans-unit id="a0c46d9d748b73163c147c1ce7040c6c5f099f4e" translate="yes" xml:space="preserve">
          <source>A working buffer for encoding.</source>
          <target state="translated">エンコードのための作業用バッファ。</target>
        </trans-unit>
        <trans-unit id="616b07ea95b58bd9c829efac045d8e3b914aeaa6" translate="yes" xml:space="preserve">
          <source>A wrap prefix may also be specified for regions of text, using the &lt;code&gt;wrap-prefix&lt;/code&gt; text or overlay property. This takes precedence over the &lt;code&gt;wrap-prefix&lt;/code&gt; variable. See &lt;a href=&quot;special-properties#Special-Properties&quot;&gt;Special Properties&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;wrap-prefix&lt;/code&gt; textまたはoverlayプロパティを使用して、テキストの領域にwrapprefixを指定することもできます。これは、 &lt;code&gt;wrap-prefix&lt;/code&gt; 変数よりも優先されます。&lt;a href=&quot;special-properties#Special-Properties&quot;&gt;特別なプロパティを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="3b61659ac0aca26e539585c1b71cc13614c39334" translate="yes" xml:space="preserve">
          <source>A wrap-prefix may also be specified for an entire buffer using the &lt;code&gt;wrap-prefix&lt;/code&gt; buffer-local variable (however, a &lt;code&gt;wrap-prefix&lt;/code&gt; text-property takes precedence over the value of the &lt;code&gt;wrap-prefix&lt;/code&gt; variable). See &lt;a href=&quot;truncation#Truncation&quot;&gt;Truncation&lt;/a&gt;.</source>
          <target state="translated">wrap-prefixは、 &lt;code&gt;wrap-prefix&lt;/code&gt; buffer-local変数を使用してバッファー全体に指定することもできます（ただし、 &lt;code&gt;wrap-prefix&lt;/code&gt; text-propertyは &lt;code&gt;wrap-prefix&lt;/code&gt; 変数の値よりも優先されます）。&lt;a href=&quot;truncation#Truncation&quot;&gt;切り捨てを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="1a6a3baa60990f601b340b07ecccc1672c3cca03" translate="yes" xml:space="preserve">
          <source>A-</source>
          <target state="translated">A-</target>
        </trans-unit>
        <trans-unit id="a85e90f9835e6411e691ebde65582614cea81732" translate="yes" xml:space="preserve">
          <source>ALT</source>
          <target state="translated">ALT</target>
        </trans-unit>
        <trans-unit id="80d305c58f97edfae92a3627f5a66d9bef4d8d46" translate="yes" xml:space="preserve">
          <source>AM</source>
          <target state="translated">AM</target>
        </trans-unit>
        <trans-unit id="d93d10ff0fbef1b4aa0ddc24e10e907746d3c85a" translate="yes" xml:space="preserve">
          <source>API</source>
          <target state="translated">API</target>
        </trans-unit>
        <trans-unit id="94090230b1f8c256f7ac5dc5a70bd3b20ee4ff15" translate="yes" xml:space="preserve">
          <source>ASCII</source>
          <target state="translated">ASCII</target>
        </trans-unit>
        <trans-unit id="031fd11ba8734ab304116a023b5216306b246bee" translate="yes" xml:space="preserve">
          <source>AT</source>
          <target state="translated">AT</target>
        </trans-unit>
        <trans-unit id="99122025a15b80d993018f40997751b62445924e" translate="yes" xml:space="preserve">
          <source>AT&amp;amp;T Unix System V.</source>
          <target state="translated">AT＆TUnixSystemV。</target>
        </trans-unit>
        <trans-unit id="54f90b5155803aae21271b2ad64b0075c858dfb3" translate="yes" xml:space="preserve">
          <source>Abbrev Properties</source>
          <target state="translated">Abbrevプロパティ</target>
        </trans-unit>
        <trans-unit id="f784445cdd616480acdfafb0159b1dd57c47999c" translate="yes" xml:space="preserve">
          <source>Abbrev Table Properties</source>
          <target state="translated">略)テーブルのプロパティ</target>
        </trans-unit>
        <trans-unit id="2a8b96a9acfbae4f72a46878195e3d362ca12a6d" translate="yes" xml:space="preserve">
          <source>Abbrev Tables</source>
          <target state="translated">略表</target>
        </trans-unit>
        <trans-unit id="a762e02aeaccf777576ff3c307e562d8de1c9496" translate="yes" xml:space="preserve">
          <source>Abbrev tables used by various major modes.</source>
          <target state="translated">主要な各種モードで使用される略表。</target>
        </trans-unit>
        <trans-unit id="49470700c92eb0723c4ce23a16459e8c3cadae63" translate="yes" xml:space="preserve">
          <source>Abbrevs</source>
          <target state="translated">Abbrevs</target>
        </trans-unit>
        <trans-unit id="0305dceae89338799d1bdcabaff23a024687a7d6" translate="yes" xml:space="preserve">
          <source>Abbrevs and Abbrev Expansion</source>
          <target state="translated">アブレブとアブレブ展開</target>
        </trans-unit>
        <trans-unit id="b4aa8f55f18e483e3d99ff9bebe3bd5c52648359" translate="yes" xml:space="preserve">
          <source>Abbrevs are usually expanded by certain interactive commands, including &lt;code&gt;self-insert-command&lt;/code&gt;. This section describes the subroutines used in writing such commands, as well as the variables they use for communication.</source>
          <target state="translated">略語は通常、 &lt;code&gt;self-insert-command&lt;/code&gt; を含む特定の対話型コマンドによって展開されます。このセクションでは、このようなコマンドの作成に使用されるサブルーチンと、それらが通信に使用する変数について説明します。</target>
        </trans-unit>
        <trans-unit id="1631d5afa2a3227c2b1fff62aedf669a7aee3c55" translate="yes" xml:space="preserve">
          <source>Abbrevs have properties, some of which influence the way they work. You can provide them as arguments to &lt;code&gt;define-abbrev&lt;/code&gt;, and manipulate them with the following functions:</source>
          <target state="translated">略語にはプロパティがあり、その一部は動作方法に影響を与えます。それらを &lt;code&gt;define-abbrev&lt;/code&gt; の引数として指定し、次の関数で操作できます。</target>
        </trans-unit>
        <trans-unit id="fd64ebde815890af94b19555b946c61d882f6e1a" translate="yes" xml:space="preserve">
          <source>Abort one level back to the previous command level (&lt;code&gt;abort-recursive-edit&lt;/code&gt;).</source>
          <target state="translated">1つのレベルを中止して前のコマンドレベルに戻します（ &lt;code&gt;abort-recursive-edit&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="649f859d67e712421f56a26ae61a458542dd60ea" translate="yes" xml:space="preserve">
          <source>Absolute and Relative File Names</source>
          <target state="translated">絶対ファイル名と相対ファイル名</target>
        </trans-unit>
        <trans-unit id="059d44280b6e5c431c206b204f4f62d2e05d3635" translate="yes" xml:space="preserve">
          <source>Absolute times may be specified using a string with a limited variety of formats, and are taken to be times &lt;em&gt;today&lt;/em&gt;, even if already in the past. The recognized forms are &amp;lsquo;</source>
          <target state="translated">絶対時間は、限られた種類の形式の文字列を使用して指定でき、すでに過去であっても、&lt;em&gt;今日の&lt;/em&gt;時間と見なされます。認識される形式は '</target>
        </trans-unit>
        <trans-unit id="c2929c3c521daab9f85d0df0bc4e1eb3e6ff7ace" translate="yes" xml:space="preserve">
          <source>Abstract Display</source>
          <target state="translated">抽象的な表示</target>
        </trans-unit>
        <trans-unit id="0dd14bcbc9ae50a4fc5b86a822cc2f2f4d8cca03" translate="yes" xml:space="preserve">
          <source>Abstract Display Example</source>
          <target state="translated">抽象的な表示例</target>
        </trans-unit>
        <trans-unit id="8ca47e66401ef945d4b28414ef0d5576741f3686" translate="yes" xml:space="preserve">
          <source>Abstract Display Functions</source>
          <target state="translated">抽象的な表示機能</target>
        </trans-unit>
        <trans-unit id="69257aa08447c746dd43fabf319f01b5bf36c541" translate="yes" xml:space="preserve">
          <source>Accepting Output from Processes</source>
          <target state="translated">プロセスからの出力を受け入れる</target>
        </trans-unit>
        <trans-unit id="b3e3bbc9103b04d543a6204da8e18664e43f77be" translate="yes" xml:space="preserve">
          <source>Access control</source>
          <target state="translated">アクセス制御</target>
        </trans-unit>
        <trans-unit id="c95b17f402b7316d8ba7de52ef60427ce9506d18" translate="yes" xml:space="preserve">
          <source>Access to Documentation Strings</source>
          <target state="translated">ドキュメントの文字列へのアクセス</target>
        </trans-unit>
        <trans-unit id="ad4938a0faaa972c17f8af4c4d5fdcca75e5ab35" translate="yes" xml:space="preserve">
          <source>Access to Frame Parameters</source>
          <target state="translated">フレームパラメータへのアクセス</target>
        </trans-unit>
        <trans-unit id="51a874cb0f96d3ea9f2ce946b1290deba1b58fd0" translate="yes" xml:space="preserve">
          <source>Access, manipulate and search the</source>
          <target state="translated">アクセス、操作、検索</target>
        </trans-unit>
        <trans-unit id="21dbc590326eedf17d212f7c64c83e8331fddf48" translate="yes" xml:space="preserve">
          <source>Accessing Elements of Lists</source>
          <target state="translated">リストの要素へのアクセス</target>
        </trans-unit>
        <trans-unit id="b4efd1b0aae332f4b617e49e2f68b08f45ba40e4" translate="yes" xml:space="preserve">
          <source>Accessing Function Cell Contents</source>
          <target state="translated">アクセス機能セルの内容</target>
        </trans-unit>
        <trans-unit id="2ae0d4aab84373932fbdccdc1dd027efe8eb99b1" translate="yes" xml:space="preserve">
          <source>Accessing Mouse Events</source>
          <target state="translated">マウスイベントへのアクセス</target>
        </trans-unit>
        <trans-unit id="7b70ffbc5424e39bca6adad4e4d11285e1ac347b" translate="yes" xml:space="preserve">
          <source>Accessing Other Processes</source>
          <target state="translated">他のプロセスへのアクセス</target>
        </trans-unit>
        <trans-unit id="8339c289bb6c2a3facc1658bda0b35c1d194fecf" translate="yes" xml:space="preserve">
          <source>Accessing Scroll Bar Events</source>
          <target state="translated">スクロールバーのイベントへのアクセス</target>
        </trans-unit>
        <trans-unit id="8eb474e9f84ed1c8d415f59983dd55f6ddf51322" translate="yes" xml:space="preserve">
          <source>Accessing Symbol Properties</source>
          <target state="translated">シンボルのプロパティへのアクセス</target>
        </trans-unit>
        <trans-unit id="dd21e1a656d1c33e1a0961edb1425706c4dca0fb" translate="yes" xml:space="preserve">
          <source>Accessing Variable Values</source>
          <target state="translated">変数値へのアクセス</target>
        </trans-unit>
        <trans-unit id="8572c608682fbb32c330cfe123c0c1e48efb3125" translate="yes" xml:space="preserve">
          <source>Accessing a window&amp;rsquo;s size.</source>
          <target state="translated">ウィンドウのサイズにアクセスする。</target>
        </trans-unit>
        <trans-unit id="f8f65e4cb3dd5208adf445a32728a6ff8fca1a80" translate="yes" xml:space="preserve">
          <source>Accessing and changing buffer names.</source>
          <target state="translated">バッファ名へのアクセスと変更</target>
        </trans-unit>
        <trans-unit id="3129221bf25c4d4b56aa75c86a37cdcc52d7977f" translate="yes" xml:space="preserve">
          <source>Accessing and recording terminal input.</source>
          <target state="translated">端子入力にアクセスして記録します。</target>
        </trans-unit>
        <trans-unit id="8631d7461d61b93f0e7f285fa1d91660e92fcc8e" translate="yes" xml:space="preserve">
          <source>Accessing files.</source>
          <target state="translated">ファイルへのアクセス。</target>
        </trans-unit>
        <trans-unit id="6ab94f81e36e6a4e03c0557995d9d781180dfde7" translate="yes" xml:space="preserve">
          <source>Accessing or setting the function definition of a symbol.</source>
          <target state="translated">シンボルの関数定義にアクセスしたり、設定したりします。</target>
        </trans-unit>
        <trans-unit id="febe729637e545444f7ff407ae1d3c58bfa2095e" translate="yes" xml:space="preserve">
          <source>Accessing other processes running on your system.</source>
          <target state="translated">システム上で実行されている他のプロセスへのアクセス</target>
        </trans-unit>
        <trans-unit id="317d74ecc1929588bf8f86c73cd8f7de6158a955" translate="yes" xml:space="preserve">
          <source>Accessing property lists stored elsewhere.</source>
          <target state="translated">他の場所に保存されているプロパティリストへのアクセス。</target>
        </trans-unit>
        <trans-unit id="4de3522fad93f3eb20523cf511d421cb8eef7ca4" translate="yes" xml:space="preserve">
          <source>Accessing run-status and other attributes.</source>
          <target state="translated">ランステータスやその他の属性へのアクセス</target>
        </trans-unit>
        <trans-unit id="e4d2ebfdc40bb29558e41e11ad7b405042d411f3" translate="yes" xml:space="preserve">
          <source>Accessing single items of match data, such as where a particular subexpression started.</source>
          <target state="translated">特定のサブ式がどこから始まったかなど、マッチデータの単一項目にアクセスします。</target>
        </trans-unit>
        <trans-unit id="e47d1cd990a7768c115296fc95220fcfe9f44b0e" translate="yes" xml:space="preserve">
          <source>Accessing symbol properties.</source>
          <target state="translated">シンボルのプロパティにアクセスします。</target>
        </trans-unit>
        <trans-unit id="97a8946bf0993a5ece0972055df9d2232582c889" translate="yes" xml:space="preserve">
          <source>Accessing the Entire Match Data</source>
          <target state="translated">マッチデータ全体へのアクセス</target>
        </trans-unit>
        <trans-unit id="0098eec4c4a85cc7153b9941ac7e084d9e2e8113" translate="yes" xml:space="preserve">
          <source>Accessing the entire match data at once, as a list.</source>
          <target state="translated">一致したデータ全体にリストとして一度にアクセスすることができます。</target>
        </trans-unit>
        <trans-unit id="6d51c3b889a7d39ffb0cd69aa7cdd6137813bf7a" translate="yes" xml:space="preserve">
          <source>Accessor functions are provided to access the elements in this list. The accessors are mentioned along with the descriptions of the elements below.</source>
          <target state="translated">このリストの要素にアクセスするためのアクセサ関数が提供されています。アクセサは、以下の要素の説明とともに記載されています。</target>
        </trans-unit>
        <trans-unit id="a16eff51e0f2460918136851c80aba409432bd14" translate="yes" xml:space="preserve">
          <source>Accordingly, the native height of a frame may include the height of the tool bar but not that of the menu bar (Lucid, Motif, MS-Windows) or those of the menu bar and the tool bar (non-toolkit and text terminal frames).</source>
          <target state="translated">したがって、フレームのネイティブな高さは、ツールバーの高さを含むが、メニューバーの高さは含まない(Lucid、Motif、MS-Windows)、またはメニューバーとツールバーの高さは含まない(非ツールキットフレームとテキスト端末フレーム)。</target>
        </trans-unit>
        <trans-unit id="5d9540ff93a75d47409d6a0aa37491da117ecdf8" translate="yes" xml:space="preserve">
          <source>Acknowledgments</source>
          <target state="translated">Acknowledgments</target>
        </trans-unit>
        <trans-unit id="8be718ab6c21edb41bfaec3e8d4ff0416d658fc0" translate="yes" xml:space="preserve">
          <source>Action Alists for Buffer Display</source>
          <target state="translated">バッファ表示用のアクションリスト</target>
        </trans-unit>
        <trans-unit id="ce9f32ee0623ab47f4c96611c146ef4fcb105048" translate="yes" xml:space="preserve">
          <source>Action Functions for Buffer Display</source>
          <target state="translated">バッファ表示のアクション機能</target>
        </trans-unit>
        <trans-unit id="bea1043802a5a73ba6a935cc95001c4084c8eed4" translate="yes" xml:space="preserve">
          <source>Active Display Table</source>
          <target state="translated">アクティブディスプレイテーブル</target>
        </trans-unit>
        <trans-unit id="1b42bb970933421bd7fe384eb941f0b135fc8d12" translate="yes" xml:space="preserve">
          <source>Active Keymaps</source>
          <target state="translated">アクティブキーマップ</target>
        </trans-unit>
        <trans-unit id="8bae209835d078ba1a2b628e6a1e2a530501a3e6" translate="yes" xml:space="preserve">
          <source>Adapting code using the old defadvice</source>
          <target state="translated">旧defadviceを使用してコードを適応させる</target>
        </trans-unit>
        <trans-unit id="fb2cba4aab141960fa84cebe7cdaa1f7b5ca40f1" translate="yes" xml:space="preserve">
          <source>Adapting code using the old defadvice.</source>
          <target state="translated">旧来の欠点を利用したコードの適応。</target>
        </trans-unit>
        <trans-unit id="d3aca0f70608cde924c0c717aa6f76cc5b6dd2c8" translate="yes" xml:space="preserve">
          <source>Adaptive Fill Mode</source>
          <target state="translated">アダプティブフィルモード</target>
        </trans-unit>
        <trans-unit id="ad3177b884766938f06c1f5cfe5f60876bbecbb6" translate="yes" xml:space="preserve">
          <source>Adaptive Fill mode chooses a fill prefix from context.</source>
          <target state="translated">適応塗りつぶしモードでは、 塗りつぶしの接頭辞をコンテキストから選択します。</target>
        </trans-unit>
        <trans-unit id="45867255fd797585e4916e018bbccee9a35d212f" translate="yes" xml:space="preserve">
          <source>Adaptive Fill mode is enabled when this variable is non-&lt;code&gt;nil&lt;/code&gt;. It is &lt;code&gt;t&lt;/code&gt; by default.</source>
          <target state="translated">この変数が &lt;code&gt;nil&lt;/code&gt; 以外の場合、アダプティブフィルモードが有効になります。デフォルトでは &lt;code&gt;t&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="41fe7af53eab5acab9f4d23fedd7b9d027e07088" translate="yes" xml:space="preserve">
          <source>Adaptive Fill mode matches this regular expression against the text starting after the left margin whitespace (if any) on a line; the characters it matches are that line&amp;rsquo;s candidate for the fill prefix.</source>
          <target state="translated">アダプティブフィルモードは、この正規表現を、行の左マージンの空白（存在する場合）の後に始まるテキストと照合します。一致する文字は、その行の塗りつぶしプレフィックスの候補です。</target>
        </trans-unit>
        <trans-unit id="1298942391d0f9524543f2b581a0f4733a3cd521" translate="yes" xml:space="preserve">
          <source>Add &lt;var&gt;child&lt;/var&gt; to &lt;var&gt;node&lt;/var&gt;&amp;rsquo;s child list before the &lt;var&gt;before&lt;/var&gt; node. If &lt;var&gt;before&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, make &lt;var&gt;child&lt;/var&gt; the first child.</source>
          <target state="translated">追加 &lt;var&gt;child&lt;/var&gt; への &lt;var&gt;node&lt;/var&gt; 前の子リストを &lt;var&gt;before&lt;/var&gt; ノード。 &lt;var&gt;before&lt;/var&gt; が &lt;code&gt;nil&lt;/code&gt; の場合、 &lt;var&gt;child&lt;/var&gt; 最初の子にします。</target>
        </trans-unit>
        <trans-unit id="86a8c842c5f2e03db4ed77dc6cfb42a4e1d59a0e" translate="yes" xml:space="preserve">
          <source>Add a clipping path to &lt;var&gt;svg&lt;/var&gt;. If applied to a shape via the &lt;var&gt;:clip-path&lt;/var&gt; property, parts of that shape which lie outside of the clipping path are not drawn.</source>
          <target state="translated">&lt;var&gt;svg&lt;/var&gt; にクリッピングパスを追加します。 &lt;var&gt;:clip-path&lt;/var&gt; プロパティを介してシェイプに適用した場合、クリッピングパスの外側にあるシェイプの部分は描画されません。</target>
        </trans-unit>
        <trans-unit id="ca2976f450cc856aed523c528c25b64c84e61f8c" translate="yes" xml:space="preserve">
          <source>Add a function to &lt;code&gt;font-lock-extend-region-functions&lt;/code&gt; that does the &lt;em&gt;identification&lt;/em&gt; and extends the scan so that the scanned text never starts or ends in the middle of a multiline construct.</source>
          <target state="translated">&lt;code&gt;font-lock-extend-region-functions&lt;/code&gt; に関数を追加して、&lt;em&gt;識別を&lt;/em&gt;行い、スキャンを拡張して、スキャンされたテキストが複数行の構成の途中で開始または終了しないようにします。</target>
        </trans-unit>
        <trans-unit id="2437c12b4ee8245aff3c6e915602340a5cb79372" translate="yes" xml:space="preserve">
          <source>Add a polygon to &lt;var&gt;svg&lt;/var&gt; where &lt;var&gt;points&lt;/var&gt; is a list of X/Y pairs that describe the outer circumference of the polygon.</source>
          <target state="translated">ポリゴンを &lt;var&gt;svg&lt;/var&gt; に追加します。ここで、 &lt;var&gt;points&lt;/var&gt; は、ポリゴンの外周を表すX / Yペアのリストです。</target>
        </trans-unit>
        <trans-unit id="d0cd8a519df07a3ed1321bd58a41305e60e7eb92" translate="yes" xml:space="preserve">
          <source>Add a watch for filesystem events pertaining to &lt;var&gt;file&lt;/var&gt;. This arranges for filesystem events pertaining to &lt;var&gt;file&lt;/var&gt; to be reported to Emacs.</source>
          <target state="translated">ファイルに関連する &lt;var&gt;file&lt;/var&gt; システムイベントの監視を追加します。これにより、ファイルに関連する &lt;var&gt;file&lt;/var&gt; システムイベントがEmacsに報告されるようになります。</target>
        </trans-unit>
        <trans-unit id="e14f3bd4b7856be2d474146674d049259534d312" translate="yes" xml:space="preserve">
          <source>Add an element to &lt;code&gt;minor-mode-alist&lt;/code&gt; for each minor mode (see &lt;a href=&quot;mode-line-variables#Definition-of-minor_002dmode_002dalist&quot;&gt;Definition of minor-mode-alist&lt;/a&gt;), if you want to indicate the minor mode in the mode line. This element should be a list of the following form:</source>
          <target state="translated">モード行でマイナーモードを指定する場合は、マイナーモードごとにマイナーモード &lt;code&gt;minor-mode-alist&lt;/code&gt; 要素を追加します（マイナーモードアリストの&lt;a href=&quot;mode-line-variables#Definition-of-minor_002dmode_002dalist&quot;&gt;定義を&lt;/a&gt;参照）。この要素は、次の形式のリストである必要があります。</target>
        </trans-unit>
        <trans-unit id="7cff03d7e41619c195637edc380375b892f0845c" translate="yes" xml:space="preserve">
          <source>Add an embedded (raster) image to &lt;var&gt;svg&lt;/var&gt;. If &lt;var&gt;datap&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, &lt;var&gt;image&lt;/var&gt; should be a file name; otherwise it should be a string containing the image data as raw bytes. &lt;var&gt;image-type&lt;/var&gt; should be a</source>
          <target state="translated">埋め込まれた（ラスター）画像を &lt;var&gt;svg&lt;/var&gt; に追加します。 &lt;var&gt;datap&lt;/var&gt; が &lt;code&gt;nil&lt;/code&gt; の場合、 &lt;var&gt;image&lt;/var&gt; はファイル名である必要があります。それ以外の場合は、画像データを生のバイトとして含む文字列である必要があります。 &lt;var&gt;image-type&lt;/var&gt; は</target>
        </trans-unit>
        <trans-unit id="a711fa29586567ced283637a07f291daf9eccd20" translate="yes" xml:space="preserve">
          <source>Add line breaks and indentation to the top-level Lisp form at point to make it more readable.</source>
          <target state="translated">ポイントのトップレベルのLispフォームに改行とインデントを追加して、より読みやすくする。</target>
        </trans-unit>
        <trans-unit id="4d943f97d99246a36fad53c87be01c95f3a766cf" translate="yes" xml:space="preserve">
          <source>Add the advice &lt;var&gt;function&lt;/var&gt; to the named function &lt;var&gt;symbol&lt;/var&gt;. &lt;var&gt;where&lt;/var&gt; and &lt;var&gt;props&lt;/var&gt; have the same meaning as for &lt;code&gt;add-function&lt;/code&gt; (see &lt;a href=&quot;core-advising-primitives#Core-Advising-Primitives&quot;&gt;Core Advising Primitives&lt;/a&gt;).</source>
          <target state="translated">名前付き関数 &lt;var&gt;symbol&lt;/var&gt; アドバイス &lt;var&gt;function&lt;/var&gt; を追加します。 &lt;var&gt;where&lt;/var&gt; と &lt;var&gt;props&lt;/var&gt; は、 &lt;code&gt;add-function&lt;/code&gt; の場合と同じ意味を持ちます（&lt;a href=&quot;core-advising-primitives#Core-Advising-Primitives&quot;&gt;Core Advising Primitivesを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="83a774fd7318f04762e68de4e2b137225620ce7f" translate="yes" xml:space="preserve">
          <source>Add the custom node &lt;var&gt;tag&lt;/var&gt; to &lt;var&gt;svg&lt;/var&gt;.</source>
          <target state="translated">カスタムノード &lt;var&gt;tag&lt;/var&gt; を &lt;var&gt;svg&lt;/var&gt; に追加します。</target>
        </trans-unit>
        <trans-unit id="3861b616706cb862303f0503ef614aace33c9de7" translate="yes" xml:space="preserve">
          <source>Add the outline of a shape to &lt;var&gt;svg&lt;/var&gt; according to &lt;var&gt;commands&lt;/var&gt;, see &lt;a href=&quot;#SVG-Path-Commands&quot;&gt;SVG Path Commands&lt;/a&gt;.</source>
          <target state="translated">&lt;var&gt;commands&lt;/var&gt; に従って、形状のアウトラインを &lt;var&gt;svg&lt;/var&gt; に追加します&lt;a href=&quot;#SVG-Path-Commands&quot;&gt;。SVGパスコマンドを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="9913c193acde9c02d5ae3b24bc390ab6d78afa81" translate="yes" xml:space="preserve">
          <source>Add the specified &lt;var&gt;text&lt;/var&gt; to &lt;var&gt;svg&lt;/var&gt;.</source>
          <target state="translated">指定した &lt;var&gt;text&lt;/var&gt; を &lt;var&gt;svg&lt;/var&gt; に追加します。</target>
        </trans-unit>
        <trans-unit id="8aacc8a54a520b2ac614e1a90f78fb2eedfee11f" translate="yes" xml:space="preserve">
          <source>Add to &lt;var&gt;svg&lt;/var&gt; a circle whose center is at &lt;var&gt;x&lt;/var&gt;/&lt;var&gt;y&lt;/var&gt; and whose radius is &lt;var&gt;radius&lt;/var&gt;.</source>
          <target state="translated">中心が &lt;var&gt;x&lt;/var&gt; / &lt;var&gt;y&lt;/var&gt; にあり、半径が &lt;var&gt;radius&lt;/var&gt; である円を &lt;var&gt;svg&lt;/var&gt; に追加します。</target>
        </trans-unit>
        <trans-unit id="4fe52fae4d07b75457a9542137a4b9b5c60d0aef" translate="yes" xml:space="preserve">
          <source>Add to &lt;var&gt;svg&lt;/var&gt; a line that starts at &lt;var&gt;x1&lt;/var&gt;/&lt;var&gt;y1&lt;/var&gt; and extends to &lt;var&gt;x2&lt;/var&gt;/&lt;var&gt;y2&lt;/var&gt;.</source>
          <target state="translated">&lt;var&gt;x1&lt;/var&gt; / &lt;var&gt;y1&lt;/var&gt; で始まり、 &lt;var&gt;x2&lt;/var&gt; / &lt;var&gt;y2&lt;/var&gt; まで伸びる線を &lt;var&gt;svg&lt;/var&gt; に追加します。</target>
        </trans-unit>
        <trans-unit id="6a286d1f3e95235d9468003833dcabc092caa2e1" translate="yes" xml:space="preserve">
          <source>Add to &lt;var&gt;svg&lt;/var&gt; a multiple-segment line (a.k.a. &amp;ldquo;polyline&amp;rdquo;) that goes through &lt;var&gt;points&lt;/var&gt;, which is a list of X/Y position pairs.</source>
          <target state="translated">X / Y位置ペアのリストである &lt;var&gt;points&lt;/var&gt; を通過する複数セグメントの線（別名「ポリライン」）を &lt;var&gt;svg&lt;/var&gt; に追加します。</target>
        </trans-unit>
        <trans-unit id="565a0d4084aef376e27a550cb97be439640f51cd" translate="yes" xml:space="preserve">
          <source>Add to &lt;var&gt;svg&lt;/var&gt; a rectangle whose upper left corner is at position &lt;var&gt;x&lt;/var&gt;/&lt;var&gt;y&lt;/var&gt; and whose size is &lt;var&gt;width&lt;/var&gt;/&lt;var&gt;height&lt;/var&gt;.</source>
          <target state="translated">左上隅が位置 &lt;var&gt;x&lt;/var&gt; / &lt;var&gt;y&lt;/var&gt; にあり、サイズが &lt;var&gt;width&lt;/var&gt; / &lt;var&gt;height&lt;/var&gt; ある長方形を &lt;var&gt;svg&lt;/var&gt; に追加します。</target>
        </trans-unit>
        <trans-unit id="f117e38663daed515f31d78095890b69b59541be" translate="yes" xml:space="preserve">
          <source>Add to &lt;var&gt;svg&lt;/var&gt; an ellipse whose center is at &lt;var&gt;x&lt;/var&gt;/&lt;var&gt;y&lt;/var&gt;, and whose horizontal radius is &lt;var&gt;x-radius&lt;/var&gt; and the vertical radius is &lt;var&gt;y-radius&lt;/var&gt;.</source>
          <target state="translated">中心が &lt;var&gt;x&lt;/var&gt; / &lt;var&gt;y&lt;/var&gt; にあり、水平半径が &lt;var&gt;x-radius&lt;/var&gt; 、垂直半径が &lt;var&gt;y-radius&lt;/var&gt; 半径の楕円を &lt;var&gt;svg&lt;/var&gt; に追加します。</target>
        </trans-unit>
        <trans-unit id="a72995a8fcd466eb526d56641ee9c271fda926c9" translate="yes" xml:space="preserve">
          <source>Adding additional information about a function.</source>
          <target state="translated">機能に関する追加情報を追加します。</target>
        </trans-unit>
        <trans-unit id="8d9d382c9e9984ab00e1fba4ef0f8c1158adf2d5" translate="yes" xml:space="preserve">
          <source>Adding buttons to Emacs buffers.</source>
          <target state="translated">Emacsのバッファにボタンを追加する</target>
        </trans-unit>
        <trans-unit id="53b2f670a3f5ad65cee3f0da686a14d79f042bed" translate="yes" xml:space="preserve">
          <source>Adding clickable buttons to Emacs buffers.</source>
          <target state="translated">Emacs バッファにクリッカブルボタンを追加する。</target>
        </trans-unit>
        <trans-unit id="4679096d507cd2c89ee536f4f3c0706150098e70" translate="yes" xml:space="preserve">
          <source>Adding new text to a buffer.</source>
          <target state="translated">バッファに新しいテキストを追加します。</target>
        </trans-unit>
        <trans-unit id="95751041c5c1654a609b5b64e61a15f9bddb79a0" translate="yes" xml:space="preserve">
          <source>Adding to the definition of a function.</source>
          <target state="translated">関数の定義に追加すること。</target>
        </trans-unit>
        <trans-unit id="58b99f3d38ede1597b9ac02693be3ab80822e821" translate="yes" xml:space="preserve">
          <source>Adding, subtracting, comparing times, etc.</source>
          <target state="translated">足し算、引き算、回数の比較など</target>
        </trans-unit>
        <trans-unit id="500196012d89f448a3af179ba361faa20093707c" translate="yes" xml:space="preserve">
          <source>Additional Options for Displaying Buffers</source>
          <target state="translated">バッファを表示するための追加オプション</target>
        </trans-unit>
        <trans-unit id="58c09d8cc944ca4e37be6c32b0108073f18357b2" translate="yes" xml:space="preserve">
          <source>Additional alist entries may be defined in the future.</source>
          <target state="translated">将来的には、追加の alist エントリが定義される可能性があります。</target>
        </trans-unit>
        <trans-unit id="a22e777afc57137b40767d7ea63841431e6d681d" translate="yes" xml:space="preserve">
          <source>Additional customization facilities.</source>
          <target state="translated">カスタマイズ機能を追加しました。</target>
        </trans-unit>
        <trans-unit id="d931ed9a4962a5016c462de8f0c48ae86a47f189" translate="yes" xml:space="preserve">
          <source>Additional flags each character can have.</source>
          <target state="translated">各キャラクタが持つことができる追加のフラグ。</target>
        </trans-unit>
        <trans-unit id="94e8d86d4f239006083ee80460e98ca2f47369d1" translate="yes" xml:space="preserve">
          <source>Additional image properties supported for the &lt;code&gt;xbm&lt;/code&gt; image type are:</source>
          <target state="translated">&lt;code&gt;xbm&lt;/code&gt; イメージタイプでサポートされる追加のイメージプロパティは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="6431dff5a05dff6ce51567fbc49ea8750d45e21d" translate="yes" xml:space="preserve">
          <source>Additional keypad duplicates of keys ordinarily found elsewhere. Emacs normally translates these into the like-named non-keypad keys.</source>
          <target state="translated">通常他の場所にあるキーのキーパッド複製。Emacs は通常、これらをキーパッド以外のキーに変換します。</target>
        </trans-unit>
        <trans-unit id="6338a470de402714fad49d59e574ee2a004eb402" translate="yes" xml:space="preserve">
          <source>Additional relevant functions for net connections.</source>
          <target state="translated">ネット接続に関連する機能を追加しました。</target>
        </trans-unit>
        <trans-unit id="3c7e388f967fe300edc4c7b897df6b058218b157" translate="yes" xml:space="preserve">
          <source>Additional space to leave below each text line, in pixels (a positive integer). See &lt;a href=&quot;line-height#Line-Height&quot;&gt;Line Height&lt;/a&gt;, for more information.</source>
          <target state="translated">各テキスト行の下にピクセル単位（正の整数）で残す追加のスペース。詳細については、&lt;a href=&quot;line-height#Line-Height&quot;&gt;線の高さを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="b1fd54e2342c288944104eeefd68ecbc3f125806" translate="yes" xml:space="preserve">
          <source>Additional typographic style information for the font, such as &amp;lsquo;</source>
          <target state="translated">'などのフォントの追加の活版印刷スタイル情報</target>
        </trans-unit>
        <trans-unit id="ee273060f190cc74f93860343b827ad47759d5a0" translate="yes" xml:space="preserve">
          <source>Additionally, C code can modify the value of variables directly, bypassing the watchpoint mechanism.</source>
          <target state="translated">さらに、C言語のコードは、ウォッチポイント機構をバイパスして、変数の値を直接変更することができます。</target>
        </trans-unit>
        <trans-unit id="a8a4e955fb763f3e97efcc9f314ccd7894853f87" translate="yes" xml:space="preserve">
          <source>Additionally, arrange to display &lt;var&gt;doc&lt;/var&gt; along with the docstring of &lt;code&gt;pcase&lt;/code&gt;. By convention, &lt;var&gt;doc&lt;/var&gt; should use &lt;code&gt;EXPVAL&lt;/code&gt; to stand for the result of evaluating &lt;var&gt;expression&lt;/var&gt; (first arg to &lt;code&gt;pcase&lt;/code&gt;).</source>
          <target state="translated">さらに、 &lt;code&gt;pcase&lt;/code&gt; のdocstringと一緒に &lt;var&gt;doc&lt;/var&gt; を表示するように調整します。慣例により、 &lt;var&gt;doc&lt;/var&gt; は &lt;code&gt;EXPVAL&lt;/code&gt; を使用して、 &lt;var&gt;expression&lt;/var&gt; の評価結果を表す必要があります（最初のargから &lt;code&gt;pcase&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="21af65202f21fc2dc93653ae03092063c5b61dff" translate="yes" xml:space="preserve">
          <source>Additionally, conflicts can occur:</source>
          <target state="translated">さらに、コンフリクトが発生することもあります。</target>
        </trans-unit>
        <trans-unit id="e75498292efb2e16310b12aff15b14972a22b009" translate="yes" xml:space="preserve">
          <source>Additionally, the &lt;var&gt;collection&lt;/var&gt; should generally not be pre-filtered based on the current text between &lt;var&gt;start&lt;/var&gt; and &lt;var&gt;end&lt;/var&gt;, because that is the responsibility of the caller of &lt;code&gt;completion-at-point-functions&lt;/code&gt; to do that according to the completion styles it decides to use.</source>
          <target state="translated">さらに、 &lt;var&gt;collection&lt;/var&gt; は通常、 &lt;var&gt;start&lt;/var&gt; と &lt;var&gt;end&lt;/var&gt; 間の現在のテキストに基づいて事前にフィルタリングされるべきではありません。これは、使用することを決定した完了スタイルに従ってそれを行うのは、完了 &lt;code&gt;completion-at-point-functions&lt;/code&gt; の呼び出し元の責任であるためです。</target>
        </trans-unit>
        <trans-unit id="82ec8503880130af95fe77d33f6e32d8d45be1c7" translate="yes" xml:space="preserve">
          <source>Adjustable Tab Stops</source>
          <target state="translated">調節可能なタブストップ</target>
        </trans-unit>
        <trans-unit id="cce71d8b4de0fbe7b1d1416d923c41d53c78a09c" translate="yes" xml:space="preserve">
          <source>Adjustable, typewriter-like tab stops.</source>
          <target state="translated">調節可能なタイプライターのようなタブストップ。</target>
        </trans-unit>
        <trans-unit id="3b315ad397f4b4a0ed97547b767a1277549aaf87" translate="yes" xml:space="preserve">
          <source>Adjusting Point After Commands</source>
          <target state="translated">コマンド後のポイント調整</target>
        </trans-unit>
        <trans-unit id="9a61906e01d69a6bb351e657b21352956d8d32ce" translate="yes" xml:space="preserve">
          <source>Adjustment of point after a command.</source>
          <target state="translated">コマンド後のポイント調整</target>
        </trans-unit>
        <trans-unit id="e59f2f2723f7c1f609f3550bb2671a6cb90986fe" translate="yes" xml:space="preserve">
          <source>Advice and coding conventions for Emacs Lisp.</source>
          <target state="translated">Emacs Lispのためのアドバイスとコーディング規約。</target>
        </trans-unit>
        <trans-unit id="40d1b99315ff674405912fd3cc10e5b67c67dd32" translate="yes" xml:space="preserve">
          <source>Advising Emacs Lisp Functions</source>
          <target state="translated">EmacsのLisp関数のアドバイス</target>
        </trans-unit>
        <trans-unit id="7d52de2eb6adab7304f81575e610e6fdaba9cc2d" translate="yes" xml:space="preserve">
          <source>Advising Named Functions</source>
          <target state="translated">アドバイスの命名機能</target>
        </trans-unit>
        <trans-unit id="ab277db91341f63fab17a1c61d2a97a801877f92" translate="yes" xml:space="preserve">
          <source>Advising named functions.</source>
          <target state="translated">名前のついた機能をアドバイスする。</target>
        </trans-unit>
        <trans-unit id="79ba5e1b3f99abfd54ef8d839ba12bd2ac4d79cb" translate="yes" xml:space="preserve">
          <source>After</source>
          <target state="translated">After</target>
        </trans-unit>
        <trans-unit id="2001d34da0f06a489ff0edce787794897f4aeb55" translate="yes" xml:space="preserve">
          <source>After &lt;code&gt;set-text-properties&lt;/code&gt; returns, all the characters in the specified range have identical properties.</source>
          <target state="translated">後に &lt;code&gt;set-text-properties&lt;/code&gt; 戻り、指定した範囲内のすべての文字は、同一の特性を有しています。</target>
        </trans-unit>
        <trans-unit id="26622072ea6b71fa07e70b43c76041b80e7e5a30" translate="yes" xml:space="preserve">
          <source>After Emacs changes a file, there are two reasons the changes might not survive later failures of power or media, both having to do with efficiency. First, the operating system might alias written data with data already stored elsewhere on secondary storage until one file or the other is later modified; this will lose both files if the only copy on secondary storage is lost due to media failure. Second, the operating system might not write data to secondary storage immediately, which will lose the data if power is lost.</source>
          <target state="translated">Emacs がファイルを変更した後、後に電源やメディアが故障しても変更が生き残れない可能性がありますが、これにはどちらも効率性に関係する 2 つの理由があります。第一に、一方のファイルまたは他方のファイルが後で変更されるまで、オペレーティング・システムは書き込まれたデータをセカンダリ・ストレージの別の場所にすでに保存されているデータとエイリアス化する可能性があります。第二に、オペレーティングシステムがすぐにセカンダリストレージにデータを書き込まない場合があり、これは電源が失われた場合にデータを失うことになります。</target>
        </trans-unit>
        <trans-unit id="9f89518425e409284cb01cc7c3c6a1775a6a510d" translate="yes" xml:space="preserve">
          <source>After Emacs reads your init file, it initializes &lt;code&gt;auto-save-list-file-name&lt;/code&gt; (if you have not already set it non-&lt;code&gt;nil&lt;/code&gt;) based on this prefix, adding the host name and process ID. If you set this to &lt;code&gt;nil&lt;/code&gt; in your init file, then Emacs does not initialize &lt;code&gt;auto-save-list-file-name&lt;/code&gt;.</source>
          <target state="translated">Emacsはinitファイルを読み取った後、このプレフィックスに基づいて &lt;code&gt;auto-save-list-file-name&lt;/code&gt; を初期化し（まだ &lt;code&gt;nil&lt;/code&gt; 以外に設定していない場合）、ホスト名とプロセスIDを追加します。initファイルでこれを &lt;code&gt;nil&lt;/code&gt; に設定すると、Emacsは &lt;code&gt;auto-save-list-file-name&lt;/code&gt; を初期化しません。</target>
        </trans-unit>
        <trans-unit id="c6d6ee5d7d9a1dbc90deb665a4ae3ffff4b1c578" translate="yes" xml:space="preserve">
          <source>After Font Lock evaluates &lt;var&gt;pre-form&lt;/var&gt;, it does not search for &lt;var&gt;anchored-matcher&lt;/var&gt; beyond the end of the line. However, if &lt;var&gt;pre-form&lt;/var&gt; returns a buffer position that is greater than the position of point after &lt;var&gt;pre-form&lt;/var&gt; is evaluated, then the position returned by &lt;var&gt;pre-form&lt;/var&gt; is used as the limit of the search instead. It is generally a bad idea to return a position greater than the end of the line; in other words, the &lt;var&gt;anchored-matcher&lt;/var&gt; search should not span lines.</source>
          <target state="translated">Font Lockは &lt;var&gt;pre-form&lt;/var&gt; リフォームを評価した後、行末を超えて &lt;var&gt;anchored-matcher&lt;/var&gt; を検索しません。ただし、 &lt;var&gt;pre-form&lt;/var&gt; 後の点の位置より大きいバッファ位置返す &lt;var&gt;pre-form&lt;/var&gt; 評価され、その後によって返される位置 &lt;var&gt;pre-form&lt;/var&gt; 代わりに、検索の限界として使用されます。一般に、行の終わりよりも大きい位置を返すことはお勧めできません。言い換えると、 &lt;var&gt;anchored-matcher&lt;/var&gt; 検索は行にまたがってはなりません。</target>
        </trans-unit>
        <trans-unit id="0d5f3b64280f526c25116915081cc07a4ccb40b7" translate="yes" xml:space="preserve">
          <source>After a &lt;em&gt;synchronous process&lt;/em&gt; is created, Emacs waits for the process to terminate before continuing. Starting Dired on GNU or Unix&lt;a href=&quot;#FOOT21&quot; name=&quot;DOCF21&quot;&gt;&lt;sup&gt;21&lt;/sup&gt;&lt;/a&gt; is an example of this: it runs &lt;code&gt;ls&lt;/code&gt; in a synchronous process, then modifies the output slightly. Because the process is synchronous, the entire directory listing arrives in the buffer before Emacs tries to do anything with it.</source>
          <target state="translated">&lt;em&gt;同期プロセス&lt;/em&gt;が作成された後、Emacsはプロセスが終了するのを待ってから続行します。GNUまたはUnix上でのdiredを開始&lt;a href=&quot;#FOOT21&quot; name=&quot;DOCF21&quot;&gt;&lt;sup&gt;21は&lt;/sup&gt;&lt;/a&gt;この例である：それは実行 &lt;code&gt;ls&lt;/code&gt; 同期処理では、わずかに出力を変更します。プロセスは同期的であるため、Emacsが何かをしようとする前に、ディレクトリリスト全体がバッファに到着します。</target>
        </trans-unit>
        <trans-unit id="79d05caca5759ed0ecaf87a1fc890988221544d6" translate="yes" xml:space="preserve">
          <source>After adding this advice, if you call &lt;code&gt;my-double&lt;/code&gt; with &amp;lsquo;</source>
          <target state="translated">このアドバイスを追加した後 &lt;code&gt;my-double&lt;/code&gt; を 'で呼び出すと</target>
        </trans-unit>
        <trans-unit id="b482ecda0086b5db531f75dfdba2467dc5429ef2" translate="yes" xml:space="preserve">
          <source>After an inline function is defined, its inline expansion can be performed later on in the same file, just like macros.</source>
          <target state="translated">インライン関数を定義した後、マクロと同様に、後から同じファイル内でインライン展開を行うことができます。</target>
        </trans-unit>
        <trans-unit id="1711c03422a1600eb8ad808ec0bc8cf24123cdd2" translate="yes" xml:space="preserve">
          <source>After defining &lt;var&gt;name&lt;/var&gt; in this way, you can use it as the &lt;var&gt;test&lt;/var&gt; argument in &lt;code&gt;make-hash-table&lt;/code&gt;. When you do that, the hash table will use &lt;var&gt;test-fn&lt;/var&gt; to compare key values, and &lt;var&gt;hash-fn&lt;/var&gt; to compute a hash code from a key value.</source>
          <target state="translated">この方法で &lt;var&gt;name&lt;/var&gt; を定義した後、それを &lt;code&gt;make-hash-table&lt;/code&gt; の &lt;var&gt;test&lt;/var&gt; 引数として使用できます。これを行うと、ハッシュテーブルは &lt;var&gt;test-fn&lt;/var&gt; を使用してキー値を比較し、 &lt;var&gt;hash-fn&lt;/var&gt; を使用してキー値からハッシュコードを計算します。</target>
        </trans-unit>
        <trans-unit id="cb84be952166d7a786e0f5810ef1b95aefca141b" translate="yes" xml:space="preserve">
          <source>After executing the body of the handler, the &lt;code&gt;condition-case&lt;/code&gt; returns normally, using the value of the last form in the handler body as the overall value.</source>
          <target state="translated">ハンドラーの本体を実行した後、 &lt;code&gt;condition-case&lt;/code&gt; は通常どおり戻り、ハンドラー本体の最後のフォームの値を全体の値として使用します。</target>
        </trans-unit>
        <trans-unit id="4dcf95c5a0c487e8209e489fa588abd672d9e8b8" translate="yes" xml:space="preserve">
          <source>After execution of the handler body, execution returns from the &lt;code&gt;condition-case&lt;/code&gt; form. Because the protected form is exited completely before execution of the handler, the handler cannot resume execution at the point of the error, nor can it examine variable bindings that were made within the protected form. All it can do is clean up and proceed.</source>
          <target state="translated">ハンドラー本体の実行後、実行は &lt;code&gt;condition-case&lt;/code&gt; 形式から戻ります。保護されたフォームはハンドラーの実行前に完全に終了するため、ハンドラーはエラーの時点で実行を再開することも、保護されたフォーム内で作成された変数バインディングを調べることもできません。できることは、クリーンアップして続行することだけです。</target>
        </trans-unit>
        <trans-unit id="f9f96cc122b695225532f65f8c1dc5af1dd81ad0" translate="yes" xml:space="preserve">
          <source>After installation, the installed package is &lt;em&gt;loaded&lt;/em&gt;: Emacs adds the package&amp;rsquo;s content directory to &lt;code&gt;load-path&lt;/code&gt;, and evaluates the autoload definitions in</source>
          <target state="translated">インストール後、インストールされたパッケージが&lt;em&gt;ロード&lt;/em&gt;されます：Emacsはパッケージのコンテンツディレクトリを &lt;code&gt;load-path&lt;/code&gt; に追加し、の自動ロード定義を評価します</target>
        </trans-unit>
        <trans-unit id="7d8f54422101c3e253d2eea8938b01fa0aa88a65" translate="yes" xml:space="preserve">
          <source>After moving point, you may wish to jump back to the stop point. You can do that with</source>
          <target state="translated">ポイント移動後、停止ポイントにジャンプして戻ってくるのもいいかもしれません。これを行うには</target>
        </trans-unit>
        <trans-unit id="70f30068f24e099728f9220f33c66de8c45b3661" translate="yes" xml:space="preserve">
          <source>After selecting</source>
          <target state="translated">選択した後</target>
        </trans-unit>
        <trans-unit id="6b47650b2f0eeaae057157d2f6dba970bba4bcc2" translate="yes" xml:space="preserve">
          <source>After substitution, if a &amp;lsquo;</source>
          <target state="translated">置換後、 '</target>
        </trans-unit>
        <trans-unit id="11efe5f0fdddc5460cc69a92a923925429424bb2" translate="yes" xml:space="preserve">
          <source>After switching windows or buffers, and in some other cases, if the window start is in the middle of a line, Emacs adjusts the window start to the start of a line. This prevents certain operations from leaving the window start at a meaningless point within a line. This feature may interfere with testing some Lisp code by executing it using the commands of Lisp mode, because they trigger this readjustment. To test such code, put it into a command and bind the command to a key.</source>
          <target state="translated">ウィンドウやバッファを切り替えた後など、ウィンドウの開始位置が行の途中にある場合、Emacs はウィンドウの開始位置を行の開始位置に調整します。これにより、特定の操作でウィンドウの開始位置が行内の無意味な位置になってしまうことを防ぐことができます。この機能は、一部のLispコードをLispモードのコマンドを使って実行してテストする際に、この再調整をトリガーにしてしまうため、テストに支障をきたす可能性があります。そのようなコードをテストするには、それをコマンドに入れて、コマンドをキーにバインドしてください。</target>
        </trans-unit>
        <trans-unit id="495827ab1d768e91f37fdef6604e6f5836895698" translate="yes" xml:space="preserve">
          <source>After that, &lt;var&gt;body&lt;/var&gt; is executed, and the connection-local variables are unwound. Example:</source>
          <target state="translated">その後、 &lt;var&gt;body&lt;/var&gt; が実行され、接続ローカル変数が巻き戻されます。例：</target>
        </trans-unit>
        <trans-unit id="6ba43c834d967b77f336f5c21c19c92d28a6987a" translate="yes" xml:space="preserve">
          <source>After the &amp;lsquo;</source>
          <target state="translated">後に '</target>
        </trans-unit>
        <trans-unit id="d9009ae4cb68e38ac581c27d4e2acc4e2c297d9b" translate="yes" xml:space="preserve">
          <source>After the call to the &lt;code&gt;DEFUN&lt;/code&gt; macro, you must write the argument list for the C function, including the types for the arguments. If the primitive accepts a fixed maximum number of Lisp arguments, there must be one C argument for each Lisp argument, and each argument must be of type &lt;code&gt;Lisp_Object&lt;/code&gt;. (Various macros and functions for creating values of type &lt;code&gt;Lisp_Object&lt;/code&gt; are declared in the file</source>
          <target state="translated">&lt;code&gt;DEFUN&lt;/code&gt; マクロを呼び出した後、引数の型を含め、C関数の引数リストを作成する必要があります。プリミティブが固定最大数のLisp引数を受け入れる場合、Lisp引数ごとに1つのC引数が必要であり、各引数は &lt;code&gt;Lisp_Object&lt;/code&gt; 型である必要があります。（ &lt;code&gt;Lisp_Object&lt;/code&gt; 型の値を作成するためのさまざまなマクロと関数がファイルで宣言されています</target>
        </trans-unit>
        <trans-unit id="33d79aff6f896ac6094c3c7ab2c4138388d48ec5" translate="yes" xml:space="preserve">
          <source>After the command loop has translated a key sequence into a command, it invokes that command using the function &lt;code&gt;command-execute&lt;/code&gt;. If the command is a function, &lt;code&gt;command-execute&lt;/code&gt; calls &lt;code&gt;call-interactively&lt;/code&gt;, which reads the arguments and calls the command. You can also call these functions yourself.</source>
          <target state="translated">コマンドループがキーシーケンスをコマンドに変換した後、関数 &lt;code&gt;command-execute&lt;/code&gt; を使用してそのコマンドを呼び出します。コマンドが関数の場合、 &lt;code&gt;command-execute&lt;/code&gt; は &lt;code&gt;call-interactively&lt;/code&gt; を呼び出します。これにより、引数が読み取られ、コマンドが呼び出されます。これらの関数を自分で呼び出すこともできます。</target>
        </trans-unit>
        <trans-unit id="eb00eb8abe509aa0e806964b17e030d795a6dcae" translate="yes" xml:space="preserve">
          <source>After the file has been loaded, the symbol should have a new function definition that is not an autoload object. The new definition is then called as if it had been there to begin with. From the user&amp;rsquo;s point of view, the function call works as expected, using the function definition in the loaded file.</source>
          <target state="translated">ファイルがロードされた後、シンボルには、自動ロードオブジェクトではない新しい関数定義が含まれている必要があります。新しい定義は、そもそもそこにあったかのように呼び出されます。ユーザーの観点からは、関数呼び出しは、ロードされたファイルの関数定義を使用して、期待どおりに機能します。</target>
        </trans-unit>
        <trans-unit id="5e64aa108dd56236b255a2bfaa30873fae10d663" translate="yes" xml:space="preserve">
          <source>After the lines are joined, the function &lt;code&gt;fixup-whitespace&lt;/code&gt; is responsible for deciding whether to leave a space at the junction.</source>
          <target state="translated">線が結合された後、関数 &lt;code&gt;fixup-whitespace&lt;/code&gt; は、接合部にスペースを残すかどうかを決定する責任があります。</target>
        </trans-unit>
        <trans-unit id="8028d1d381d5b478f2dffeace51ce5901d720198" translate="yes" xml:space="preserve">
          <source>After the terminal is initialized, this is set to the terminal-specific initialization function.</source>
          <target state="translated">端末を初期化した後、端末固有の初期化機能に設定します。</target>
        </trans-unit>
        <trans-unit id="c2df18475dff27329715d9ae9944a0845bdbbdd4" translate="yes" xml:space="preserve">
          <source>After these mandatory arguments follow the keyword arguments. The most important is &lt;code&gt;:type&lt;/code&gt;, which describes the data type we want to match with this widget. Here a &lt;code&gt;binary-tree-of-string&lt;/code&gt; is described as being either a string, or a cons-cell whose car and cdr are themselves both &lt;code&gt;binary-tree-of-string&lt;/code&gt;. Note the reference to the widget type we are currently in the process of defining. The &lt;code&gt;:tag&lt;/code&gt; attribute is a string to name the widget in the user interface, and the &lt;code&gt;:offset&lt;/code&gt; argument is there to ensure that child nodes are indented four spaces relative to the parent node, making the tree structure apparent in the customization buffer.</source>
          <target state="translated">これらの必須引数の後に、キーワード引数が続きます。最も重要なのは &lt;code&gt;:type&lt;/code&gt; です。これは、このウィジェットと照合するデータ型を記述します。ここでは、 &lt;code&gt;binary-tree-of-string&lt;/code&gt; は、文字列、またはcarとcdr自体が両方とも &lt;code&gt;binary-tree-of-string&lt;/code&gt; であるcons-cellとして記述されています。現在定義中のウィジェットタイプへの参照に注意してください。 &lt;code&gt;:tag&lt;/code&gt; 属性は、ユーザーインターフェイスのウィジェットに名前を付けるための文字列で、 &lt;code&gt;:offset&lt;/code&gt; 引数は、子ノードがカスタマイズバッファで見かけツリー構造を作り、親ノードに対する4つのスペースでインデントされていることを確認することがあります。</target>
        </trans-unit>
        <trans-unit id="fdf9c94744bf9492e6805756a0c97707a0c90bae" translate="yes" xml:space="preserve">
          <source>After writing your C code for a module function, you should make a Lisp function object from it using the &lt;code&gt;make_function&lt;/code&gt; function, whose pointer is provided in the environment (recall that the pointer to the environment is returned by &lt;code&gt;get_environment&lt;/code&gt;). This is normally done in the module initialization function (see &lt;a href=&quot;module-initialization#module-initialization-function&quot;&gt;module initialization function&lt;/a&gt;), after verifying the</source>
          <target state="translated">モジュール関数のCコードを記述した後、 &lt;code&gt;make_function&lt;/code&gt; 関数を使用してLisp関数オブジェクトを作成する必要があります。make_function関数のポインターは環境で提供されます（環境へのポインターは &lt;code&gt;get_environment&lt;/code&gt; によって返されることを思い出してください）。これは通常、モジュール初期化関数（&lt;a href=&quot;module-initialization#module-initialization-function&quot;&gt;モジュール初期化関数を&lt;/a&gt;参照）で、</target>
        </trans-unit>
        <trans-unit id="01273641f1108e9334b3ff2f2de5aac2328b0349" translate="yes" xml:space="preserve">
          <source>After you activate the change group, any changes you make in that buffer become part of it. Once you have made all the desired changes in the buffer, you must &lt;em&gt;finish&lt;/em&gt; the change group. There are two ways to do this: you can either accept (and finalize) all the changes, or cancel them all.</source>
          <target state="translated">変更グループをアクティブ化すると、そのバッファーで行った変更はすべてそのバッファーの一部になります。バッファに必要な変更をすべて加えたら、変更グループを&lt;em&gt;終了&lt;/em&gt;する必要があります。これを行うには2つの方法があります。すべての変更を受け入れる（そして確定する）か、すべてをキャンセルすることができます。</target>
        </trans-unit>
        <trans-unit id="156a361715177a7a195a547edfc720451b956bc1" translate="yes" xml:space="preserve">
          <source>After you create an archive, remember that it is not accessible in the Package Menu interface unless it is in &lt;code&gt;package-archives&lt;/code&gt;.</source>
          <target state="translated">アーカイブを作成した後は、 &lt;code&gt;package-archives&lt;/code&gt; にない限り、パッケージメニューインターフェイスからアクセスできないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="e6177c7642a19bf3ac0b659b32ac63c9a38ada82" translate="yes" xml:space="preserve">
          <source>After you think you have fixed the problem, use</source>
          <target state="translated">問題が解決したと思ったら</target>
        </trans-unit>
        <trans-unit id="26afb7a30b02ada3701025dcae553b3342d65c03" translate="yes" xml:space="preserve">
          <source>Alias Menu Items</source>
          <target state="translated">エイリアスメニューの項目</target>
        </trans-unit>
        <trans-unit id="4ecfd05f5c4a9c12f77ec0ab644b70282ba9ee84" translate="yes" xml:space="preserve">
          <source>Alist with elements</source>
          <target state="translated">要素を持つAlist</target>
        </trans-unit>
        <trans-unit id="4a7098b2dd254466abcb5233fdc2c39c1c9bc767" translate="yes" xml:space="preserve">
          <source>Alists for fine-tuning buffer display.</source>
          <target state="translated">バッファ表示を微調整するためのリスト。</target>
        </trans-unit>
        <trans-unit id="6a72085653e4c5be8c7640c868ef787cbcf063d1" translate="yes" xml:space="preserve">
          <source>All</source>
          <target state="translated">All</target>
        </trans-unit>
        <trans-unit id="a745dcd86b59cafb3c0ca3bc7c385a6602657fcf" translate="yes" xml:space="preserve">
          <source>All &lt;var&gt;exp&lt;/var&gt;s are evaluated first, after which they are matched against their respective &lt;var&gt;pattern&lt;/var&gt;, introducing new variable bindings that can then be used inside &lt;var&gt;body&lt;/var&gt;. The variable bindings are produced by destructuring binding of elements of &lt;var&gt;pattern&lt;/var&gt; to the values of the corresponding elements of the evaluated &lt;var&gt;exp&lt;/var&gt;.</source>
          <target state="translated">すべての &lt;var&gt;exp&lt;/var&gt; が最初に評価され、その後、それぞれの &lt;var&gt;pattern&lt;/var&gt; と照合され、 &lt;var&gt;body&lt;/var&gt; 内で使用できる新しい変数バインディングが導入されます。変数バインディングは、 &lt;var&gt;pattern&lt;/var&gt; 要素の、評価された &lt;var&gt;exp&lt;/var&gt; の対応する要素の値へのバインディングを分解することによって生成されます。</target>
        </trans-unit>
        <trans-unit id="aa4b6e4b0a07d4d70f84e83caad6fff48d32fad3" translate="yes" xml:space="preserve">
          <source>All Emacs Lisp arrays are one-dimensional. (Most other programming languages support multidimensional arrays, but they are not essential; you can get the same effect with nested one-dimensional arrays.) Each type of array has its own read syntax; see the following sections for details.</source>
          <target state="translated">Emacs Lisp の配列はすべて一次元です。(他のほとんどのプログラミング言語では多次元配列をサポートしていますが、必須ではありません。)配列の種類にはそれぞれ独自の読み込み構文があります。</target>
        </trans-unit>
        <trans-unit id="78dab1ef3770dfe21362526370a14bdcd828cdca" translate="yes" xml:space="preserve">
          <source>All arguments are instrumented for evaluation.</source>
          <target state="translated">すべての引数は評価のためにインストルメントされています。</target>
        </trans-unit>
        <trans-unit id="b6a1d847b868b0a62fa982b38796821b2fb0c23f" translate="yes" xml:space="preserve">
          <source>All arguments are numbers. Floating-point arguments can be tricky, because floating-point arithmetic is inexact. For instance, depending on the machine, it may quite well happen that &lt;code&gt;(number-sequence 0.4 0.6 0.2)&lt;/code&gt; returns the one element list &lt;code&gt;(0.4)&lt;/code&gt;, whereas &lt;code&gt;(number-sequence 0.4 0.8 0.2)&lt;/code&gt; returns a list with three elements. The &lt;var&gt;n&lt;/var&gt;th element of the list is computed by the exact formula &lt;code&gt;(+ &lt;var&gt;from&lt;/var&gt; (* &lt;var&gt;n&lt;/var&gt; &lt;var&gt;separation&lt;/var&gt;))&lt;/code&gt;. Thus, if one wants to make sure that &lt;var&gt;to&lt;/var&gt; is included in the list, one can pass an expression of this exact type for &lt;var&gt;to&lt;/var&gt;. Alternatively, one can replace &lt;var&gt;to&lt;/var&gt; with a slightly larger value (or a slightly more negative value if &lt;var&gt;separation&lt;/var&gt; is negative).</source>
          <target state="translated">すべての引数は数字です。浮動小数点演算は不正確であるため、浮動小数点引数は注意が必要な場合があります。たとえば、マシンによっては、 &lt;code&gt;(number-sequence 0.4 0.6 0.2)&lt;/code&gt; が1つの要素のリスト &lt;code&gt;(0.4)&lt;/code&gt; を返すのに対し、 &lt;code&gt;(number-sequence 0.4 0.8 0.2)&lt;/code&gt; が3つの要素のリストを返す場合があります。リストの &lt;var&gt;n&lt;/var&gt; 番目の要素は、正確な式 &lt;code&gt;(+ &lt;var&gt;from&lt;/var&gt; (* &lt;var&gt;n&lt;/var&gt; &lt;var&gt;separation&lt;/var&gt;))&lt;/code&gt; によって計算されます。したがって、 &lt;var&gt;to&lt;/var&gt; がリストに含まれていることを確認したい場合は、この正確なタイプの式を &lt;var&gt;to&lt;/var&gt; 渡すことができます。あるいは、交換することができます &lt;var&gt;to&lt;/var&gt; わずかに大きい値（または &lt;var&gt;separation&lt;/var&gt; が負の場合はわずかに負の値）。</target>
        </trans-unit>
        <trans-unit id="2208c34161ce80d7a782807d1e4cec6e6a7dd001" translate="yes" xml:space="preserve">
          <source>All breakpoints in a definition are forgotten each time you reinstrument it. If you wish to make a breakpoint that won&amp;rsquo;t be forgotten, you can write a &lt;em&gt;source breakpoint&lt;/em&gt;, which is simply a call to the function &lt;code&gt;edebug&lt;/code&gt; in your source code. You can, of course, make such a call conditional. For example, in the &lt;code&gt;fac&lt;/code&gt; function, you can insert the first line as shown below, to stop when the argument reaches zero:</source>
          <target state="translated">定義内のすべてのブレークポイントは、再インストルメントするたびに忘れられます。忘れられないブレークポイントを作成したい場合は、&lt;em&gt;ソースブレークポイントを&lt;/em&gt;記述でき&lt;em&gt;ます&lt;/em&gt;。これは、ソースコードで関数 &lt;code&gt;edebug&lt;/code&gt; を呼び出すだけです。もちろん、そのような呼び出しを条件付きで行うことができます。たとえば、 &lt;code&gt;fac&lt;/code&gt; 関数では、次のように最初の行を挿入して、引数がゼロに達したときに停止することができます。</target>
        </trans-unit>
        <trans-unit id="9bb2b7fe1708d34d491b12dd030e589c31b4ac12" translate="yes" xml:space="preserve">
          <source>All built-in functions do check the types of their actual arguments when appropriate, and signal a &lt;code&gt;wrong-type-argument&lt;/code&gt; error if an argument is of the wrong type. For example, here is what happens if you pass an argument to &lt;code&gt;+&lt;/code&gt; that it cannot handle:</source>
          <target state="translated">すべての組み込み関数は、必要に応じて実際の引数の型をチェックし、引数の &lt;code&gt;wrong-type-argument&lt;/code&gt; が間違っている場合は、間違った型の引数エラーを通知します。たとえば、処理できない引数を &lt;code&gt;+&lt;/code&gt; に渡すと、次のようになります。</target>
        </trans-unit>
        <trans-unit id="0a8b2cb5ecd2f67ffd2840d4654471062074ad24" translate="yes" xml:space="preserve">
          <source>All buttons have a non-&lt;code&gt;nil&lt;/code&gt;&lt;code&gt;button&lt;/code&gt; property, which may be useful in finding regions of text that comprise buttons (which is what the standard button functions do).</source>
          <target state="translated">すべてのボタンには &lt;code&gt;nil&lt;/code&gt; 以外の &lt;code&gt;button&lt;/code&gt; プロパティがあり、ボタンを構成するテキストの領域を見つけるのに役立ちます（これは標準のボタン関数が行うことです）。</target>
        </trans-unit>
        <trans-unit id="0de9e1669bff9ffa03c0a6b06c8fc7f25b299da9" translate="yes" xml:space="preserve">
          <source>All command loops, including recursive ones, set up all-purpose error handlers so that an error in a command run from the command loop will not exit the loop.</source>
          <target state="translated">再帰的なものを含むすべてのコマンドループは、コマンドループから実行されたコマンドのエラーがループを終了しないように、万能エラーハンドラを設定します。</target>
        </trans-unit>
        <trans-unit id="2bf532e176c9ef15e8a341ec22d44645c0ae9a2a" translate="yes" xml:space="preserve">
          <source>All connection-local variables, which are specified by &lt;code&gt;default-directory&lt;/code&gt;, are applied.</source>
          <target state="translated">&lt;code&gt;default-directory&lt;/code&gt; で指定されているすべての接続ローカル変数が適用されます。</target>
        </trans-unit>
        <trans-unit id="e7f6062bb49c083289ef91ea0670a9dad56b4214" translate="yes" xml:space="preserve">
          <source>All customization types are implemented as widgets; see &lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/widget/index.html#Top&quot;&gt;Introduction&lt;/a&gt; in</source>
          <target state="translated">すべてのカスタマイズタイプはウィジェットとして実装されます。の&lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/widget/index.html#Top&quot;&gt;概要&lt;/a&gt;を参照してください</target>
        </trans-unit>
        <trans-unit id="dca342b020ceabede3de91c0d8473d75e1b019c2" translate="yes" xml:space="preserve">
          <source>All following elements in the specification list are optional; as soon as one does not match, Edebug stops matching at this level.</source>
          <target state="translated">仕様リストの以下の要素はすべてオプションであり、1つでも一致しないとすぐに Edebug はこのレベルでのマッチングを停止します。</target>
        </trans-unit>
        <trans-unit id="2c01d7a4983336c611392d0fc00fd2b83de2bc6d" translate="yes" xml:space="preserve">
          <source>All following elements in the specification list are repeated zero or more times. In the last repetition, however, it is not a problem if the expression runs out before matching all of the elements of the specification list.</source>
          <target state="translated">仕様リストに続くすべての要素を0回以上繰り返します。ただし、最後の繰り返しでは、仕様リストのすべての要素と一致する前に式が切れてしまっても問題ありません。</target>
        </trans-unit>
        <trans-unit id="25b37db993c79b5143fd020bfa5984f4943de615" translate="yes" xml:space="preserve">
          <source>All four kinds of array share these characteristics:</source>
          <target state="translated">4種類のアレイはすべてこのような特徴を持っています。</target>
        </trans-unit>
        <trans-unit id="b65738468b638316e78cf6dcd55faa5077ce8a18" translate="yes" xml:space="preserve">
          <source>All functions defined in this library are free of side-effects; i.e., they do not modify any sequence (list, vector, or string) that you pass as an argument. Unless otherwise stated, the result is a sequence of the same type as the input. For those functions that take a predicate, this should be a function of one argument.</source>
          <target state="translated">このライブラリで定義されている関数はすべて副作用がありません。つまり,引数として渡されたシーケンス(リスト,ベクトル,文字列)を変更することはありません。特に指定がない限り,結果は入力と同じ型のシーケンスとなります.述語を取る関数の場合、これは1つの引数の関数でなければなりません。</target>
        </trans-unit>
        <trans-unit id="c71e30856d625975a83aead946dd7f4e5c8c274a" translate="yes" xml:space="preserve">
          <source>All functions that create markers without accepting an argument that specifies the insertion type, create them with insertion type &lt;code&gt;nil&lt;/code&gt; (see &lt;a href=&quot;creating-markers#Creating-Markers&quot;&gt;Creating Markers&lt;/a&gt;). Also, the mark has, by default, insertion type &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">挿入タイプを指定する引数を受け入れずにマーカーを作成するすべての関数は、挿入タイプ &lt;code&gt;nil&lt;/code&gt; で&lt;a href=&quot;creating-markers#Creating-Markers&quot;&gt;マーカー&lt;/a&gt;を作成します（マーカーの作成を参照）。また、マークのデフォルトの挿入タイプは &lt;code&gt;nil&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="7e5df34fc50a10cee1104c398dc0d288148f5677" translate="yes" xml:space="preserve">
          <source>All numbers can be compared with &lt;code&gt;eql&lt;/code&gt; or &lt;code&gt;=&lt;/code&gt;; fixnums can also be compared with &lt;code&gt;eq&lt;/code&gt;. To test whether an integer is a fixnum or a bignum, you can compare it to &lt;code&gt;most-negative-fixnum&lt;/code&gt; and &lt;code&gt;most-positive-fixnum&lt;/code&gt;, or you can use the convenience predicates &lt;code&gt;fixnump&lt;/code&gt; and &lt;code&gt;bignump&lt;/code&gt; on any object.</source>
          <target state="translated">すべての数値は、 &lt;code&gt;eql&lt;/code&gt; または &lt;code&gt;=&lt;/code&gt; と比較できます。fixnumsは &lt;code&gt;eq&lt;/code&gt; と比較することもできます。整数がfixnumまたはbignumであるかどうかをテストするには、整数を &lt;code&gt;most-negative-fixnum&lt;/code&gt; および &lt;code&gt;most-positive-fixnum&lt;/code&gt; &lt;code&gt;fixnump&lt;/code&gt; と &lt;code&gt;bignump&lt;/code&gt; するか、任意のオブジェクトで便利な述語fixnumpおよびbignumpを使用できます。</target>
        </trans-unit>
        <trans-unit id="c2c85ce8bd7457b271669cf5c05e295e1385ce6f" translate="yes" xml:space="preserve">
          <source>All of the &lt;var&gt;value-form&lt;/var&gt;s in &lt;var&gt;bindings&lt;/var&gt; are evaluated in the order they appear and &lt;em&gt;before&lt;/em&gt; binding any of the symbols to them. Here is an example of this: &lt;code&gt;z&lt;/code&gt; is bound to the old value of &lt;code&gt;y&lt;/code&gt;, which is 2, not the new value of &lt;code&gt;y&lt;/code&gt;, which is 1.</source>
          <target state="translated">&lt;var&gt;bindings&lt;/var&gt; 内のすべての &lt;var&gt;value-form&lt;/var&gt; は、表示される順序で、シンボルをバインドする&lt;em&gt;前に&lt;/em&gt;評価されます。ここで、この例は： &lt;code&gt;z&lt;/code&gt; 古い値にバインドされ &lt;code&gt;y&lt;/code&gt; 2、のない新しい値であり、 &lt;code&gt;y&lt;/code&gt; 1です。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cb57c7da298437e1c1c392f0acf73eba41691d75" translate="yes" xml:space="preserve">
          <source>All of the deletion functions operate on the current buffer.</source>
          <target state="translated">すべての削除機能は、現在のバッファに対して動作します。</target>
        </trans-unit>
        <trans-unit id="af4a5a5cd065f9f5dbe42b33024e60fb527b8391" translate="yes" xml:space="preserve">
          <source>All of the functions described below are actually &lt;em&gt;function pointers&lt;/em&gt; provided via the pointer to the environment which every module function accepts. Therefore, module code should call these functions through the environment pointer, like this:</source>
          <target state="translated">以下で説明するすべての関数は、実際には、すべてのモジュール関数が受け入れる環境へのポインターを介して提供される&lt;em&gt;関数ポインター&lt;/em&gt;です。したがって、モジュールコードは、次のように、環境ポインタを介してこれらの関数を呼び出す必要があります。</target>
        </trans-unit>
        <trans-unit id="2486aadd4696b33394cf13a628e5e81f8336dc69" translate="yes" xml:space="preserve">
          <source>All of these keywords, except &lt;code&gt;:tag&lt;/code&gt;, can be used more than once in a given item. Each use of the keyword has an independent effect. The keyword &lt;code&gt;:tag&lt;/code&gt; is an exception because any given item can only display one name.</source>
          <target state="translated">&lt;code&gt;:tag&lt;/code&gt; を除くこれらのキーワードはすべて、特定のアイテムで複数回使用できます。キーワードを使用するたびに、独立した効果があります。特定のアイテムには1つの名前しか表示できないため、キーワード &lt;code&gt;:tag&lt;/code&gt; は例外です。</target>
        </trans-unit>
        <trans-unit id="7c58a8aa90e29eb8cc586744cbf0bae2b76d1c9b" translate="yes" xml:space="preserve">
          <source>All the Emacs primitives for file access and file name transformation check the given file name against &lt;code&gt;file-name-handler-alist&lt;/code&gt;. If the file name matches &lt;var&gt;regexp&lt;/var&gt;, the primitives handle that file by calling &lt;var&gt;handler&lt;/var&gt;.</source>
          <target state="translated">ファイルアクセスとファイル名変換のためのすべてのEmacsプリミティブは、指定されたファイル名を &lt;code&gt;file-name-handler-alist&lt;/code&gt; と照合します。ファイル名が &lt;var&gt;regexp&lt;/var&gt; と一致する場合、プリミティブは &lt;var&gt;handler&lt;/var&gt; を呼び出すことによってそのファイルを処理します。</target>
        </trans-unit>
        <trans-unit id="9a0d1e07e928a09c5cfab793d66c3b83e32a68e0" translate="yes" xml:space="preserve">
          <source>All the buffer properties that are related to the buffer text are swapped as well: the positions of point and mark, all the markers, the overlays, the text properties, the undo list, the value of the &lt;code&gt;enable-multibyte-characters&lt;/code&gt; flag (see &lt;a href=&quot;text-representations#Text-Representations&quot;&gt;enable-multibyte-characters&lt;/a&gt;), etc.</source>
          <target state="translated">バッファテキストに関連するすべてのバッファプロパティも交換されます：ポイントとマークの位置、すべてのマーカー、オーバーレイ、テキストプロパティ、元に戻すリスト、 &lt;code&gt;enable-multibyte-characters&lt;/code&gt; フラグの値（を参照）&lt;a href=&quot;text-representations#Text-Representations&quot;&gt;enable-multibyte-characters&lt;/a&gt;）など。</target>
        </trans-unit>
        <trans-unit id="41d1c4b0b8ba4df658a7d43aad707edd6505e753" translate="yes" xml:space="preserve">
          <source>All the directories in the file system form a tree starting at the root directory. A file name can specify all the directory names starting from the root of the tree; then it is called an &lt;em&gt;absolute&lt;/em&gt; file name. Or it can specify the position of the file in the tree relative to a default directory; then it is called a &lt;em&gt;relative&lt;/em&gt; file name. On GNU and other POSIX-like systems, after any leading &amp;lsquo;</source>
          <target state="translated">ファイルシステム内のすべてのディレクトリは、ルートディレクトリから始まるツリーを形成します。ファイル名は、ツリーのルートから始まるすべてのディレクトリ名を指定できます。それからそれは&lt;em&gt;絶対&lt;/em&gt;ファイル名と呼ばれます。または、デフォルトディレクトリを基準にしたツリー内のファイルの位置を指定することもできます。その後、&lt;em&gt;相対&lt;/em&gt;ファイル名と呼ばれます。GNUおよびその他のPOSIXのようなシステムでは、先行する '</target>
        </trans-unit>
        <trans-unit id="6d03c2077a45424604dd5945928dd7d581573444" translate="yes" xml:space="preserve">
          <source>All the flags except &amp;lsquo;</source>
          <target state="translated">'を除くすべてのフラグ</target>
        </trans-unit>
        <trans-unit id="1fa32ceee23a50f9250c28b0af70936b4c7fea6b" translate="yes" xml:space="preserve">
          <source>All the following functions take an optional list of keyword parameters that alter the various attributes from their default values. Valid attributes include:</source>
          <target state="translated">以下の関数はすべて、さまざまな属性をデフォルト値から変更するキーワードパラメータのオプションのリストを取ります。有効な属性は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="fd4e3414635a6335aabdd75003f817dd7df606f1" translate="yes" xml:space="preserve">
          <source>All the operations that transfer text in and out of Emacs have the ability to use a coding system to encode or decode the text. You can also explicitly encode and decode text using the functions in this section.</source>
          <target state="translated">Emacs の内外でテキストを転送するすべての操作は、コーディングシステムを使用してテキストをエンコードまたは デコードする機能を持っています。このセクションの関数を使用して、明示的にテキストをエンコードしたりデコードしたりすることもできます。</target>
        </trans-unit>
        <trans-unit id="3d0ec5a014b164fea677713adc2d6869587a38a2" translate="yes" xml:space="preserve">
          <source>All the remaining elements (if any) are collectively called &lt;var&gt;other-vars&lt;/var&gt;. Each of these elements should have the form &lt;code&gt;(&lt;var&gt;variable&lt;/var&gt; . &lt;var&gt;value&lt;/var&gt;)&lt;/code&gt;&amp;mdash;which means, make &lt;var&gt;variable&lt;/var&gt; buffer-local and then set it to &lt;var&gt;value&lt;/var&gt;. You can use these &lt;var&gt;other-vars&lt;/var&gt; to set other variables that affect fontification, aside from those you can control with the first five elements. See &lt;a href=&quot;other-font-lock-variables#Other-Font-Lock-Variables&quot;&gt;Other Font Lock Variables&lt;/a&gt;.</source>
          <target state="translated">残りのすべての要素（存在する場合）は、まとめて &lt;var&gt;other-vars&lt;/var&gt; と呼ばれます。これらの各要素の形式は &lt;code&gt;(&lt;var&gt;variable&lt;/var&gt; . &lt;var&gt;value&lt;/var&gt;)&lt;/code&gt; 必要があります。つまり、 &lt;var&gt;variable&lt;/var&gt; バッファローカルにしてから、 &lt;var&gt;value&lt;/var&gt; 設定します。これらの &lt;var&gt;other-vars&lt;/var&gt; を使用して、最初の5つの要素で制御できる変数以外に、フォント化に影響を与える他の変数を設定できます。&lt;a href=&quot;other-font-lock-variables#Other-Font-Lock-Variables&quot;&gt;その他のフォントロック変数を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="eef34056c9664b484982e4f51615ce7ab9a41812" translate="yes" xml:space="preserve">
          <source>All the specification characters allow an optional &lt;em&gt;precision&lt;/em&gt; after the field number, flags and width, if present. The precision is a decimal-point &amp;lsquo;</source>
          <target state="translated">すべての指定文字は、フィールド番号、フラグ、および幅（存在する場合）の後にオプションの&lt;em&gt;精度を&lt;/em&gt;許可します。精度は小数点です '</target>
        </trans-unit>
        <trans-unit id="ca4ef7026f0627fed1dbae0beb181539bc4f6f15" translate="yes" xml:space="preserve">
          <source>All the usual rules for documentation strings in Lisp code (see &lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/elisp/Documentation-Tips.html#Documentation-Tips&quot;&gt;Documentation Tips&lt;/a&gt;) apply to C code documentation strings too.</source>
          <target state="translated">Lispコードのドキュメント文字列に関する通常のルール（&lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/elisp/Documentation-Tips.html#Documentation-Tips&quot;&gt;ドキュメントのヒントを&lt;/a&gt;参照）はすべて、Cコードのドキュメント文字列にも適用されます。</target>
        </trans-unit>
        <trans-unit id="58d526aa213005ab745d03bed480a0d5feb42ba3" translate="yes" xml:space="preserve">
          <source>All three of the subprocess-creating functions allow to specify command-line arguments for the process to run. For &lt;code&gt;call-process&lt;/code&gt; and &lt;code&gt;call-process-region&lt;/code&gt;, these come in the form of a &lt;code&gt;&amp;amp;rest&lt;/code&gt; argument, &lt;var&gt;args&lt;/var&gt;. For &lt;code&gt;make-process&lt;/code&gt;, both the program to run and its command-line arguments are specified as a list of strings. The command-line arguments must all be strings, and they are supplied to the program as separate argument strings. Wildcard characters and other shell constructs have no special meanings in these strings, since the strings are passed directly to the specified program.</source>
          <target state="translated">3つのサブプロセス作成関数はすべて、実行するプロセスのコマンドライン引数を指定できます。以下のため &lt;code&gt;call-process&lt;/code&gt; および &lt;code&gt;call-process-region&lt;/code&gt; 、これらはの形で来る &lt;code&gt;&amp;amp;rest&lt;/code&gt; の引数、 &lt;var&gt;args&lt;/var&gt; 。以下のために &lt;code&gt;make-process&lt;/code&gt; 、プログラムの両方を実行すると、そのコマンドライン引数は、文字列のリストとして指定されています。コマンドライン引数はすべて文字列である必要があり、個別の引数文字列としてプログラムに提供されます。文字列は指定されたプログラムに直接渡されるため、ワイルドカード文字やその他のシェル構造は、これらの文字列では特別な意味を持ちません。</target>
        </trans-unit>
        <trans-unit id="0dd2c1f56aad50efd70754bd7b0f1448e6dee489" translate="yes" xml:space="preserve">
          <source>All you need to do is add a &lt;code&gt;declare-function&lt;/code&gt; statement before the first use of the function in question:</source>
          <target state="translated">問題の関数を最初に使用する前に、 &lt;code&gt;declare-function&lt;/code&gt; ステートメントを追加するだけです。</target>
        </trans-unit>
        <trans-unit id="83a5fc8fd0c6232ad2485feb2941be6df4658ce5" translate="yes" xml:space="preserve">
          <source>Allow &lt;var&gt;command&lt;/var&gt; (a symbol) to be executed without special confirmation from now on, and alter the user&amp;rsquo;s init file (see &lt;a href=&quot;init-file#Init-File&quot;&gt;Init File&lt;/a&gt;) so that this will apply to future sessions.</source>
          <target state="translated">許可する &lt;var&gt;command&lt;/var&gt; （参照（シンボル）今から、特別な確認なしに実行されるように、ユーザーの初期化ファイルを変更する&lt;a href=&quot;init-file#Init-File&quot;&gt;初期化ファイルを&lt;/a&gt;、これは将来のセッションに適用されるように）。</target>
        </trans-unit>
        <trans-unit id="fbe56df0c14a0941bf2865207a4eec4975a429b2" translate="yes" xml:space="preserve">
          <source>Almost all the messages displayed in the echo area are also recorded in the</source>
          <target state="translated">また、エコーエリアに表示されるほぼ全てのメッセージは</target>
        </trans-unit>
        <trans-unit id="0a6cdeb0d1c09e0504231be0c620803ea8ce80be" translate="yes" xml:space="preserve">
          <source>Along with the mandatory &lt;code&gt;:request-dispatcher&lt;/code&gt; and &lt;code&gt;:notification-dispatcher&lt;/code&gt; initargs, users of the &lt;code&gt;jsonrpc-process-connection&lt;/code&gt; class should pass the following initargs as keyword-value pairs to &lt;code&gt;make-instance&lt;/code&gt;:</source>
          <target state="translated">必須の &lt;code&gt;:request-dispatcher&lt;/code&gt; および &lt;code&gt;:notification-dispatcher&lt;/code&gt; initargsに加えて、 &lt;code&gt;jsonrpc-process-connection&lt;/code&gt; クラスのユーザーは、次のinitargsをキーワードと値のペアとして &lt;code&gt;make-instance&lt;/code&gt; に渡す必要があります。</target>
        </trans-unit>
        <trans-unit id="986ce8469a3d5002d455b0f41722b9928e133cc8" translate="yes" xml:space="preserve">
          <source>Alphabetical sorting means that two sort keys are compared by comparing the first characters of each, the second characters of each, and so on. If a mismatch is found, it means that the sort keys are unequal; the sort key whose character is less at the point of first mismatch is the lesser sort key. The individual characters are compared according to their numerical character codes in the Emacs character set.</source>
          <target state="translated">アルファベット順ソートとは、2 つのソートキーを、それぞれの最初の文字、2 番目の文字を比較することで比較することを意味します。不一致が見つかった場合は、ソートキーが不平等であることを意味します。個々の文字は、Emacs の文字セットの数値文字コードに従って比較されます。</target>
        </trans-unit>
        <trans-unit id="3397c8f08539eaf212b8a514976581cd47575863" translate="yes" xml:space="preserve">
          <source>Also by convention, the &lt;small&gt;CDR&lt;/small&gt; of the last cons cell in a list is &lt;code&gt;nil&lt;/code&gt;. We call such a &lt;code&gt;nil&lt;/code&gt;-terminated structure a &lt;em&gt;proper list&lt;/em&gt;&lt;a href=&quot;#FOOT3&quot; name=&quot;DOCF3&quot;&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt;. In Emacs Lisp, the symbol &lt;code&gt;nil&lt;/code&gt; is both a symbol and a list with no elements. For convenience, the symbol &lt;code&gt;nil&lt;/code&gt; is considered to have &lt;code&gt;nil&lt;/code&gt; as its &lt;small&gt;CDR&lt;/small&gt; (and also as its &lt;small&gt;CAR&lt;/small&gt;).</source>
          <target state="translated">また、慣例により、リストの最後のconsセルの&lt;small&gt;CDR&lt;/small&gt;は &lt;code&gt;nil&lt;/code&gt; です。このような &lt;code&gt;nil&lt;/code&gt; で終了する構造を&lt;em&gt;適切なリスト&lt;/em&gt;&lt;a href=&quot;#FOOT3&quot; name=&quot;DOCF3&quot;&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt;と呼びます。Emacs Lispでは、シンボル &lt;code&gt;nil&lt;/code&gt; はシンボルであり、要素のないリストでもあります。便宜上、記号 &lt;code&gt;nil&lt;/code&gt; は、その&lt;small&gt;CDR&lt;/small&gt;（およびその&lt;small&gt;CAR&lt;/small&gt;）として &lt;code&gt;nil&lt;/code&gt; を持っていると見なされます。&lt;small&gt;&lt;/small&gt;&lt;small&gt;&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="fff39e0b11dcde645d91107c5004ab17b6696524" translate="yes" xml:space="preserve">
          <source>Also note that this variable is not meant to be a generic facility for accessing external libraries; only those already known by Emacs can be loaded through it.</source>
          <target state="translated">また、この変数は外部ライブラリにアクセスするための汎用的な機能ではないことにも注意してください。</target>
        </trans-unit>
        <trans-unit id="b0218093aabf50731b0dfd5f6bc99d6da5f04d9a" translate="yes" xml:space="preserve">
          <source>Also see &lt;code&gt;edebug-tracing&lt;/code&gt;, in &lt;a href=&quot;trace-buffer#Trace-Buffer&quot;&gt;Trace Buffer&lt;/a&gt;.</source>
          <target state="translated">参照してください &lt;code&gt;edebug-tracing&lt;/code&gt; では、&lt;a href=&quot;trace-buffer#Trace-Buffer&quot;&gt;トレース・バッファ&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4d0d7b652d689c605bbb8e508dce118b76e3835d" translate="yes" xml:space="preserve">
          <source>Also see the following function.</source>
          <target state="translated">また、以下の機能も参照してください。</target>
        </trans-unit>
        <trans-unit id="f91d8e06c0823bced203ecdc95d5ffb09f2dca97" translate="yes" xml:space="preserve">
          <source>Also see the functions &lt;code&gt;bolp&lt;/code&gt; and &lt;code&gt;eolp&lt;/code&gt; in &lt;a href=&quot;near-point#Near-Point&quot;&gt;Near Point&lt;/a&gt;. These functions do not move point, but test whether it is already at the beginning or end of a line.</source>
          <target state="translated">また、機能の参照 &lt;code&gt;bolp&lt;/code&gt; と &lt;code&gt;eolp&lt;/code&gt; で&lt;a href=&quot;near-point#Near-Point&quot;&gt;近くのポイントを&lt;/a&gt;。これらの関数はポイントを移動しませんが、それがすでに行の先頭または末尾にあるかどうかをテストします。</target>
        </trans-unit>
        <trans-unit id="1c151f9dd941153aa652ba089e31237c83748274" translate="yes" xml:space="preserve">
          <source>Also, if &lt;code&gt;ignore-window-parameters&lt;/code&gt; is &lt;code&gt;nil&lt;/code&gt;, this function does not delete any window whose &lt;code&gt;no-delete-other-windows&lt;/code&gt; parameter is non-&lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">また、 &lt;code&gt;ignore-window-parameters&lt;/code&gt; が &lt;code&gt;nil&lt;/code&gt; の場合、この関数は、 &lt;code&gt;no-delete-other-windows&lt;/code&gt; パラメーターがnon - &lt;code&gt;nil&lt;/code&gt; であるウィンドウを削除しません。</target>
        </trans-unit>
        <trans-unit id="7732936fed3ff7cd50aeba214305d9cb5cc02021" translate="yes" xml:space="preserve">
          <source>Also, inline functions do not behave well with respect to debugging, tracing, and advising (see &lt;a href=&quot;advising-functions#Advising-Functions&quot;&gt;Advising Functions&lt;/a&gt;). Since ease of debugging and the flexibility of redefining functions are important features of Emacs, you should not make a function inline, even if it&amp;rsquo;s small, unless its speed is really crucial, and you&amp;rsquo;ve timed the code to verify that using &lt;code&gt;defun&lt;/code&gt; actually has performance problems.</source>
          <target state="translated">また、インライン関数は、デバッグ、トレース、およびアドバイスに関して適切に動作しません（&lt;a href=&quot;advising-functions#Advising-Functions&quot;&gt;アドバイス関数を&lt;/a&gt;参照）。デバッグの容易さと関数の再定義の柔軟性はEmacsの重要な機能であるため、関数の速度が非常に重要であり、 &lt;code&gt;defun&lt;/code&gt; の使用が実際にパフォーマンスの問題。</target>
        </trans-unit>
        <trans-unit id="3a284929ebe4ecbc4627599844c16f8ee2075a18" translate="yes" xml:space="preserve">
          <source>Also, this variable is bound to non-&lt;code&gt;nil&lt;/code&gt; while running those same hook variables, so that by default modifying the buffer from a modification hook does not cause other modification hooks to be run. If you do want modification hooks to be run in a particular piece of code that is itself run from a modification hook, then rebind locally &lt;code&gt;inhibit-modification-hooks&lt;/code&gt; to &lt;code&gt;nil&lt;/code&gt;. However, doing this may cause recursive calls to the modification hooks, so be sure to prepare for that (for example, by binding some variable which tells your hook to do nothing).</source>
          <target state="translated">また、この変数は、同じフック変数の実行中に非 &lt;code&gt;nil&lt;/code&gt; にバインドされるため、デフォルトでは、変更フックからバッファーを変更しても、他の変更フックは実行されません。それ自体が変更フックから実行される特定のコードで変更フックを実行する場合は、ローカルで &lt;code&gt;inhibit-modification-hooks&lt;/code&gt; を &lt;code&gt;nil&lt;/code&gt; に再バインドします。ただし、これを行うと、変更フックへの再帰呼び出しが発生する可能性があるため、必ずその準備をしてください（たとえば、フックに何もしないように指示する変数をバインドすることによって）。</target>
        </trans-unit>
        <trans-unit id="e30eff925100b7c3e119ed678e39009e962455b0" translate="yes" xml:space="preserve">
          <source>Alt</source>
          <target state="translated">Alt</target>
        </trans-unit>
        <trans-unit id="a5a07d26b576b4c962f39501eaa335d2542ec41a" translate="yes" xml:space="preserve">
          <source>Alt-Hyper-Meta-x</source>
          <target state="translated">Alt-Hyper-Meta-x</target>
        </trans-unit>
        <trans-unit id="ce59e9b5171b68822f40796bb3f0c52339cf67a2" translate="yes" xml:space="preserve">
          <source>Alt-TAB</source>
          <target state="translated">Alt-TAB</target>
        </trans-unit>
        <trans-unit id="3569cde666bf1d56550417379b59c63f9186f81c" translate="yes" xml:space="preserve">
          <source>Altering List Elements with setcar</source>
          <target state="translated">setcar でリスト要素を変更する</target>
        </trans-unit>
        <trans-unit id="c23b06af6029fc510471e91f93630d6b95133fec" translate="yes" xml:space="preserve">
          <source>Altering the CDR of a List</source>
          <target state="translated">リストのCDRを変更する</target>
        </trans-unit>
        <trans-unit id="32b911a69c85aa2eed0e0429593ee1d599f1648f" translate="yes" xml:space="preserve">
          <source>Altering the contents of an existing string.</source>
          <target state="translated">既存の文字列の内容を変更します。</target>
        </trans-unit>
        <trans-unit id="03e916d44308e382702efa38414c976b82eebcbb" translate="yes" xml:space="preserve">
          <source>Alternative foreground color, a string. This is like &lt;code&gt;:foreground&lt;/code&gt; but the color is only used as a foreground when the background color is near to the foreground that would have been used. This is useful for example when marking text (i.e., the region face). If the text has a foreground that is visible with the region face, that foreground is used. If the foreground is near the region face background, &lt;code&gt;:distant-foreground&lt;/code&gt; is used instead so the text is readable.</source>
          <target state="translated">代替の前景色、文字列。これは &lt;code&gt;:foreground&lt;/code&gt; に似ていますが、背景色が使用される前景に近い場合にのみ、色が前景として使用されます。これは、たとえばテキスト（つまり、領域の面）をマークするときに役立ちます。テキストに領域面で表示される前景がある場合、その前景が使用されます。前景が領域面の背景の近くにある場合は、代わりに &lt;code&gt;:distant-foreground&lt;/code&gt; が使用されるため、テキストが読みやすくなります。</target>
        </trans-unit>
        <trans-unit id="b201fde3a76a13fb565d2139c2505d62747c3f3d" translate="yes" xml:space="preserve">
          <source>Alternatively, &lt;var&gt;menu&lt;/var&gt; can have the following form:</source>
          <target state="translated">または、 &lt;var&gt;menu&lt;/var&gt; 形式は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="612d416a8c5c9032e5eee36eda3e173bd67f6d8e" translate="yes" xml:space="preserve">
          <source>Alternatively, a menu item can be a list with the same format as &lt;var&gt;menu&lt;/var&gt;. This is a submenu.</source>
          <target state="translated">または、メニュー項目を &lt;var&gt;menu&lt;/var&gt; と同じ形式のリストにすることもできます。これはサブメニューです。</target>
        </trans-unit>
        <trans-unit id="0f3215559a2b65437e72958763c4ad5ae7956797" translate="yes" xml:space="preserve">
          <source>Alternatively, a menu item can be a string. Then that string appears in the menu as unselectable text. A string consisting of dashes is displayed as a separator (see &lt;a href=&quot;menu-separators#Menu-Separators&quot;&gt;Menu Separators&lt;/a&gt;).</source>
          <target state="translated">または、メニュー項目を文字列にすることもできます。次に、その文字列が選択できないテキストとしてメニューに表示されます。ダッシュで構成される文字列は、区切り文字として表示され&lt;a href=&quot;menu-separators#Menu-Separators&quot;&gt;ます&lt;/a&gt;（メニュー区切り記号を参照）。</target>
        </trans-unit>
        <trans-unit id="f86166f09a2fa545f30584a0fa07bc98a8228018" translate="yes" xml:space="preserve">
          <source>Alternatively, a menu item may have the form:</source>
          <target state="translated">あるいは、メニュー項目はフォームを持っていてもよい。</target>
        </trans-unit>
        <trans-unit id="2a475682f68cc8d5942ac33225fa6641ddb131e3" translate="yes" xml:space="preserve">
          <source>Alternatively, an &lt;code&gt;interactive&lt;/code&gt; form may be specified in a function symbol&amp;rsquo;s &lt;code&gt;interactive-form&lt;/code&gt; property. A non-&lt;code&gt;nil&lt;/code&gt; value for this property takes precedence over any &lt;code&gt;interactive&lt;/code&gt; form in the function body itself. This feature is seldom used.</source>
          <target state="translated">または、関数シンボルの &lt;code&gt;interactive-form&lt;/code&gt; プロパティで &lt;code&gt;interactive&lt;/code&gt; フォームを指定することもできます。非 &lt;code&gt;nil&lt;/code&gt; このプロパティの値は、任意のよりも優先さ &lt;code&gt;interactive&lt;/code&gt; 機能本体自体のフォーム。この機能はめったに使用されません。</target>
        </trans-unit>
        <trans-unit id="70290e19eb34b55b8e6acff0975f8bd70f0b8116" translate="yes" xml:space="preserve">
          <source>Alternatively, the problems sketched above can be avoided by always resizing all windows in the same combination whenever one of its windows is split or deleted. This also permits splitting windows that would be otherwise too small for such an operation.</source>
          <target state="translated">あるいは、上でスケッチしたような問題は、ウィンドウの一つが分割されたり削除されたりするときには、常に同じ組み合わせですべてのウィンドウのサイズを変更することで回避することができます。これにより、そうでなければ小さすぎるウィンドウを分割することも可能になります。</target>
        </trans-unit>
        <trans-unit id="b26670ac06db641e3e84463f0ad2daa068f83654" translate="yes" xml:space="preserve">
          <source>Alternatively, the value can specify the bitmap directly, with a list of the form &lt;code&gt;(&lt;var&gt;width&lt;/var&gt; &lt;var&gt;height&lt;/var&gt; &lt;var&gt;data&lt;/var&gt;)&lt;/code&gt;. Here, &lt;var&gt;width&lt;/var&gt; and &lt;var&gt;height&lt;/var&gt; specify the size in pixels, and &lt;var&gt;data&lt;/var&gt; is a string containing the raw bits of the bitmap, row by row. Each row occupies &lt;em&gt;(&lt;var&gt;width&lt;/var&gt; + 7) / 8&lt;/em&gt; consecutive bytes in the string (which should be a unibyte string for best results). This means that each row always occupies at least one whole byte.</source>
          <target state="translated">または、値は、フォームのリスト &lt;code&gt;(&lt;var&gt;width&lt;/var&gt; &lt;var&gt;height&lt;/var&gt; &lt;var&gt;data&lt;/var&gt;)&lt;/code&gt; てビットマップを直接指定することもできます。ここで、 &lt;var&gt;width&lt;/var&gt; と &lt;var&gt;height&lt;/var&gt; さはピクセル単位でサイズを指定し、 &lt;var&gt;data&lt;/var&gt; はビットマップの生のビットを行ごとに含む文字列です。各行は、文字列内で&lt;em&gt;（ &lt;var&gt;width&lt;/var&gt; + 7）/ 8&lt;/em&gt;連続バイトを占めます（最良の結果を得るには、これは1バイトの文字列である必要があります）。これは、各行が常に少なくとも1バイト全体を占めることを意味します。</target>
        </trans-unit>
        <trans-unit id="3fffa4436d30acad881ee763e3e490d5b00c5e0b" translate="yes" xml:space="preserve">
          <source>Alternatively, we can use the &lt;code&gt;with-current-buffer&lt;/code&gt; macro:</source>
          <target state="translated">または、 &lt;code&gt;with-current-buffer&lt;/code&gt; マクロを使用することもできます。</target>
        </trans-unit>
        <trans-unit id="b512dedf489786abd4f584013029d9c643312107" translate="yes" xml:space="preserve">
          <source>Alternatively, you can define a function by providing the code which will inline it as a compiler macro. The following macros make this possible.</source>
          <target state="translated">あるいは、コンパイラマクロとして関数をインライン化するコードを提供することで関数を定義することもできます。以下のマクロを使用すると、これが可能になります。</target>
        </trans-unit>
        <trans-unit id="a6177cf1ed61859e6ad146c7a2e9af66ea184b0c" translate="yes" xml:space="preserve">
          <source>Alternatively, you can set &lt;var&gt;min-value&lt;/var&gt; and &lt;var&gt;max-value&lt;/var&gt; to &lt;code&gt;nil&lt;/code&gt;. In that case, the progress reporter does not report process percentages; it instead displays a &amp;ldquo;spinner&amp;rdquo; that rotates a notch each time you update the progress reporter.</source>
          <target state="translated">または、 &lt;var&gt;min-value&lt;/var&gt; と &lt;var&gt;max-value&lt;/var&gt; を &lt;code&gt;nil&lt;/code&gt; に設定することもできます。その場合、進捗レポーターはプロセスのパーセンテージを報告しません。代わりに、進行状況レポーターを更新するたびにノッチを回転させる「スピナー」が表示されます。</target>
        </trans-unit>
        <trans-unit id="92226f9d87069cd2db7b3d326f09e83f23a82036" translate="yes" xml:space="preserve">
          <source>Alternatively, you could use the &lt;code&gt;:stderr&lt;/code&gt; parameter with a non-&lt;code&gt;nil&lt;/code&gt; value in a call to &lt;code&gt;make-process&lt;/code&gt; (see &lt;a href=&quot;asynchronous-processes#Asynchronous-Processes&quot;&gt;make-process&lt;/a&gt;) to make the destination of the error output separate from the standard output; in that case, Emacs will use pipes for communicating with the subprocess.</source>
          <target state="translated">または、 &lt;code&gt;make-process&lt;/code&gt; の呼び出しで &lt;code&gt;:stderr&lt;/code&gt; パラメーターを &lt;code&gt;nil&lt;/code&gt; 以外の値とともに使用して（&lt;a href=&quot;asynchronous-processes#Asynchronous-Processes&quot;&gt;make-processを&lt;/a&gt;参照）、エラー出力の宛先を標準出力とは別にすることもできます。その場合、Emacsはサブプロセスとの通信にパイプを使用します。</target>
        </trans-unit>
        <trans-unit id="67171d73924b845a3534e0ecdf7ce358ebf03943" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;(time-convert nil nil)&lt;/code&gt; is equivalent to &lt;code&gt;(current-time)&lt;/code&gt;, the latter may be a bit faster.</source>
          <target state="translated">なお、 &lt;code&gt;(time-convert nil nil)&lt;/code&gt; と等価である &lt;code&gt;(current-time)&lt;/code&gt; 、後者は少し速くすることができます。</target>
        </trans-unit>
        <trans-unit id="ada9e95e67f8cc5ff4fdc84a7549ab0fbfa66304" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;redisplay&lt;/code&gt; tries immediately to redisplay, it does not change how Emacs decides which parts of its frame(s) to redisplay. By contrast, the following function adds certain windows to the pending redisplay work (as if their contents had completely changed), but does not immediately try to perform redisplay.</source>
          <target state="translated">が &lt;code&gt;redisplay&lt;/code&gt; 再表示し、すぐにしようと、それはEmacsがそのフレーム（S）の一部を再表示するかを決定方法を変更しません。対照的に、次の関数は、保留中の再表示作業に特定のウィンドウを追加しますが（内容が完全に変更されたかのように）、すぐに再表示を実行しようとはしません。</target>
        </trans-unit>
        <trans-unit id="1b09322d9e876baf3954f8eeffbc89a79699d7f4" translate="yes" xml:space="preserve">
          <source>Although Emacs normally respects access permissions of the underlying operating system, in some cases it handles accesses specially. For example, file names can have handlers that treat the files specially, with their own access checking. See &lt;a href=&quot;magic-file-names#Magic-File-Names&quot;&gt;Magic File Names&lt;/a&gt;. Also, a buffer can be read-only even if the corresponding file is writable, and vice versa, which can result in messages such as &amp;lsquo;</source>
          <target state="translated">Emacsは通常、基盤となるオペレーティングシステムのアクセス許可を尊重しますが、場合によっては特別にアクセスを処理します。たとえば、ファイル名には、独自のアクセスチェックを使用してファイルを特別に処理するハンドラーを含めることができます。&lt;a href=&quot;magic-file-names#Magic-File-Names&quot;&gt;マジックファイル名を&lt;/a&gt;参照してください。また、対応するファイルが書き込み可能であっても、バッファは読み取り専用である可能性があり、その逆も可能であり、その結果、「</target>
        </trans-unit>
        <trans-unit id="41aec9e3c0639b5cbc769510aa631eca22825357" translate="yes" xml:space="preserve">
          <source>Although a &amp;lsquo;</source>
          <target state="translated">'</target>
        </trans-unit>
        <trans-unit id="0f3c6c13e12239c0128c12d87359384cf4720010" translate="yes" xml:space="preserve">
          <source>Although a character alternative can include duplicates, it is better style to avoid them. For example, &amp;lsquo;</source>
          <target state="translated">キャラクターの代替には重複を含めることができますが、重複を避ける方が良いスタイルです。例えば、 '</target>
        </trans-unit>
        <trans-unit id="003ff1a62df2fa3817a8fd6c5d1dd5fe04cc547c" translate="yes" xml:space="preserve">
          <source>Although a range can denote just one, two, or three characters, it is simpler to list the characters. For example, &amp;lsquo;</source>
          <target state="translated">範囲は1文字、2文字、または3文字だけを表すことができますが、文字をリストする方が簡単です。例えば、 '</target>
        </trans-unit>
        <trans-unit id="743be7d85c6dff8ab2c12b47e5caa1355172e2a0" translate="yes" xml:space="preserve">
          <source>Although a range&amp;rsquo;s bound can be almost any character, it is better style to stay within natural sequences of ASCII letters and digits because most people have not memorized character code tables. For example, &amp;lsquo;</source>
          <target state="translated">範囲の境界はほとんどすべての文字にすることができますが、ほとんどの人は文字コードテーブルを記憶していないため、ASCII文字と数字の自然なシーケンス内にとどまる方が良いスタイルです。例えば、 '</target>
        </trans-unit>
        <trans-unit id="a6f6b98c4f64609315a55f827d800190bc2958cc" translate="yes" xml:space="preserve">
          <source>Although both sorts of failures can largely be avoided by a suitably configured file system, such systems are typically more expensive or less efficient. In more-typical systems, to survive media failure you can copy the file to a different device, and to survive a power failure you can use the &lt;code&gt;write-region&lt;/code&gt; function with the &lt;code&gt;write-region-inhibit-fsync&lt;/code&gt; variable set to &lt;code&gt;nil&lt;/code&gt;. See &lt;a href=&quot;writing-to-files#Writing-to-Files&quot;&gt;Writing to Files&lt;/a&gt;.</source>
          <target state="translated">どちらの種類の障害も、適切に構成されたファイルシステムによって大部分は回避できますが、そのようなシステムは通常、より高価であるか、効率が低くなります。より一般的なシステムでは、メディア障害に耐えるためにファイルを別のデバイスにコピーでき、電源障害に耐えるために、 &lt;code&gt;write-region&lt;/code&gt; &lt;code&gt;write-region-inhibit-fsync&lt;/code&gt; 変数を &lt;code&gt;nil&lt;/code&gt; に設定してwrite-region関数を使用できます。&lt;a href=&quot;writing-to-files#Writing-to-Files&quot;&gt;ファイルへの書き込みを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="9d6a6f038f930d539ab3543bcd22fa56a80436b0" translate="yes" xml:space="preserve">
          <source>Although completion is usually done in the minibuffer, the completion facility can also be used on the text in ordinary Emacs buffers. In many major modes, in-buffer completion is performed by the</source>
          <target state="translated">補完は通常ミニバッファ内で行われますが、補完機能は通常のEmacsバッファ内のテキストにも使用できます。多くの主要なモードでは、バッファ内補完は</target>
        </trans-unit>
        <trans-unit id="67fae8b88cdfb0b03098409367fbfcfd4933ca60" translate="yes" xml:space="preserve">
          <source>Although functions are usually defined with &lt;code&gt;defun&lt;/code&gt; and given names at the same time, it is sometimes convenient to use an explicit lambda expression&amp;mdash;an &lt;em&gt;anonymous function&lt;/em&gt;. Anonymous functions are valid wherever function names are. They are often assigned as variable values, or as arguments to functions; for instance, you might pass one as the &lt;var&gt;function&lt;/var&gt; argument to &lt;code&gt;mapcar&lt;/code&gt;, which applies that function to each element of a list (see &lt;a href=&quot;mapping-functions#Mapping-Functions&quot;&gt;Mapping Functions&lt;/a&gt;). See &lt;a href=&quot;accessing-documentation#describe_002dsymbols-example&quot;&gt;describe-symbols example&lt;/a&gt;, for a realistic example of this.</source>
          <target state="translated">関数は通常、 &lt;code&gt;defun&lt;/code&gt; と名前を同時に使用して定義されますが、明示的なラムダ式（&lt;em&gt;無名関数）&lt;/em&gt;を使用すると便利な場合があり&lt;em&gt;ます&lt;/em&gt;。匿名関数は、関数名がどこにあっても有効です。多くの場合、変数値として、または関数への引数として割り当てられます。たとえば、 &lt;var&gt;function&lt;/var&gt; 引数として1つを &lt;code&gt;mapcar&lt;/code&gt; に渡すと、リストの各要素にその関数が適用されます（「&lt;a href=&quot;mapping-functions#Mapping-Functions&quot;&gt;関数のマッピング」を&lt;/a&gt;参照）。この現実的な例については、&lt;a href=&quot;accessing-documentation#describe_002dsymbols-example&quot;&gt;describe-symbolsの例を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="1be7de9f1b9c2d003e43c343730f7fd8d2bd62d3" translate="yes" xml:space="preserve">
          <source>Although numbers never change and all markers are mutable, some types have members some of which are mutable and others not. These types include conses, vectors, and strings. For example, although &lt;code&gt;&quot;cons&quot;&lt;/code&gt; and &lt;code&gt;(symbol-name 'cons)&lt;/code&gt; both yield strings that should not be changed, &lt;code&gt;(copy-sequence &quot;cons&quot;)&lt;/code&gt; and &lt;code&gt;(make-string 3 ?a)&lt;/code&gt; both yield mutable strings that can be changed via later calls to &lt;code&gt;aset&lt;/code&gt;.</source>
          <target state="translated">数値は変更されず、すべてのマーカーは変更可能ですが、一部のタイプにはメンバーがあり、一部は変更可能で、その他は変更可能ではありません。これらのタイプには、conses、vector、およびstringsが含まれます。たとえば、 &lt;code&gt;&quot;cons&quot;&lt;/code&gt; と &lt;code&gt;(symbol-name 'cons)&lt;/code&gt; どちらも変更してはならない文字列を生成しますが、 &lt;code&gt;(copy-sequence &quot;cons&quot;)&lt;/code&gt; と &lt;code&gt;(make-string 3 ?a)&lt;/code&gt; どちらも、次の方法で変更できる可変文字列を生成します。後で &lt;code&gt;aset&lt;/code&gt; を呼び出します。</target>
        </trans-unit>
        <trans-unit id="cd89d9ee767436b48e243e1fec03f6f21ceca0df" translate="yes" xml:space="preserve">
          <source>Although packing and unpacking operations change the organization of data (in memory), they preserve the data&amp;rsquo;s &lt;em&gt;total length&lt;/em&gt;, which is the sum of all the fields&amp;rsquo; lengths, in bytes. This value is not generally inherent in either the specification or alist alone; instead, both pieces of information contribute to its calculation. Likewise, the length of a string or array being unpacked may be longer than the data&amp;rsquo;s total length as described by the specification.</source>
          <target state="translated">パックおよびアンパック操作は（メモリ内の）データの編成を変更しますが、すべてのフィールドの長さの&lt;em&gt;合計で&lt;/em&gt;あるデータの&lt;em&gt;全長&lt;/em&gt;をバイト単位で保持します。この値は、通常、仕様またはリストだけに固有のものではありません。代わりに、両方の情報がその計算に貢献します。同様に、解凍される文字列または配列の長さは、仕様で説明されているように、データの全長よりも長くなる場合があります。</target>
        </trans-unit>
        <trans-unit id="d96567dd4450662d62d221615f9401c0781977ac" translate="yes" xml:space="preserve">
          <source>Although the expressions &lt;code&gt;(list '+ 1 2)&lt;/code&gt; and &lt;code&gt;'(+ 1 2)&lt;/code&gt; both yield lists equal to &lt;code&gt;(+ 1 2)&lt;/code&gt;, the former yields a freshly-minted mutable list whereas the latter yields a list built from conses that might be shared and should not be modified. See &lt;a href=&quot;self_002devaluating-forms#Self_002dEvaluating-Forms&quot;&gt;Self-Evaluating Forms&lt;/a&gt;.</source>
          <target state="translated">式が、 &lt;code&gt;(list '+ 1 2)&lt;/code&gt; 及び &lt;code&gt;'(+ 1 2)&lt;/code&gt; リストが等しい両方の収率 &lt;code&gt;(+ 1 2)&lt;/code&gt; 、前者収率後者の収率で共有されるかもしれないコンスから構築されたリストに対し、新たに鋳造可変リスト変更しないでください。&lt;a href=&quot;self_002devaluating-forms#Self_002dEvaluating-Forms&quot;&gt;自己評価フォームを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="22404d7c1088551650eedf30d445b02f32c8b26a" translate="yes" xml:space="preserve">
          <source>Although the list &lt;code&gt;(0.5)&lt;/code&gt; was mutable when it was created, it should not have been changed via &lt;code&gt;setcar&lt;/code&gt; because it given to &lt;code&gt;eval&lt;/code&gt;. The reverse does not occur: an object that should not be changed never becomes mutable afterwards.</source>
          <target state="translated">リスト &lt;code&gt;(0.5)&lt;/code&gt; は作成時に変更可能でしたが、 &lt;code&gt;eval&lt;/code&gt; に与えられたため、 &lt;code&gt;setcar&lt;/code&gt; を介して変更するべきではありませんでした。逆は発生しません。変更してはならないオブジェクトは、後で変更可能になることはありません。</target>
        </trans-unit>
        <trans-unit id="391c1ca03938de65f008bec7937cdacbb0a5f7c8" translate="yes" xml:space="preserve">
          <source>Although the portable dumper code can run on many platforms, the dump files that it produces are not portable&amp;mdash;they can be loaded only by the Emacs executable that dumped them.</source>
          <target state="translated">ポータブルダンパーコードは多くのプラットフォームで実行できますが、それが生成するダンプファイルはポータブルではありません。それらをダンプしたEmacs実行可能ファイルによってのみロードできます。</target>
        </trans-unit>
        <trans-unit id="6fa602a74e291da2cfde0e718a9868c53eb69aef" translate="yes" xml:space="preserve">
          <source>Although top-level calls to &lt;code&gt;require&lt;/code&gt; are evaluated during byte compilation, &lt;code&gt;provide&lt;/code&gt; calls are not. Therefore, you can ensure that a file of definitions is loaded before it is byte-compiled by including a &lt;code&gt;provide&lt;/code&gt; followed by a &lt;code&gt;require&lt;/code&gt; for the same feature, as in the following example.</source>
          <target state="translated">&lt;code&gt;require&lt;/code&gt; のトップレベルの呼び出しはバイトのコンパイル中に評価されますが、 &lt;code&gt;provide&lt;/code&gt; の呼び出しは評価されません。したがって、次の例のように、同じ機能の &lt;code&gt;require&lt;/code&gt; 続いて &lt;code&gt;provide&lt;/code&gt; を含めることにより、バイトコンパイルされる前に定義のファイルがロードされるようにすることができます。</target>
        </trans-unit>
        <trans-unit id="0d330d60bab6b0316e891e9303762414649958a9" translate="yes" xml:space="preserve">
          <source>Although traditionally Lisp timestamps were integer pairs, their form has evolved and programs ordinarily should not depend on the current default form. If your program needs a particular timestamp form, you can use the &lt;code&gt;time-convert&lt;/code&gt; function to convert it to the needed form. See &lt;a href=&quot;time-conversion#Time-Conversion&quot;&gt;Time Conversion&lt;/a&gt;.</source>
          <target state="translated">従来、Lispタイムスタンプは整数のペアでしたが、その形式は進化しており、プログラムは通常、現在のデフォルトの形式に依存するべきではありません。プログラムに特定のタイムスタンプ形式が必要な場合は、 &lt;code&gt;time-convert&lt;/code&gt; 関数を使用してそれを必要な形式に変換できます。&lt;a href=&quot;time-conversion#Time-Conversion&quot;&gt;時間変換を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="03d337a2cc5120b55c2c85cdc5a80ad1a0f608d6" translate="yes" xml:space="preserve">
          <source>Always use the &lt;code&gt;:set&lt;/code&gt; function to initialize the variable. If the variable is already non-void, reset it by calling the &lt;code&gt;:set&lt;/code&gt; function using the current value (returned by the &lt;code&gt;:get&lt;/code&gt; method). This is the default &lt;code&gt;:initialize&lt;/code&gt; function.</source>
          <target state="translated">変数を初期化するには、常に &lt;code&gt;:set&lt;/code&gt; 関数を使用してください。変数がすでにvoidでない場合は、現在の値（ &lt;code&gt;:get&lt;/code&gt; メソッドによって返される）を使用して &lt;code&gt;:set&lt;/code&gt; 関数を呼び出して変数をリセットします。これはデフォルトの &lt;code&gt;:initialize&lt;/code&gt; 関数です。</target>
        </trans-unit>
        <trans-unit id="3d4ac6bb796b287295b9fa9b0f33f9196a9c4247" translate="yes" xml:space="preserve">
          <source>Amongst other things, this function sets up the &lt;code&gt;comment-start&lt;/code&gt; variable to handle Lisp comments:</source>
          <target state="translated">特に、この関数は、Lispコメントを処理するために &lt;code&gt;comment-start&lt;/code&gt; 変数を設定します。</target>
        </trans-unit>
        <trans-unit id="55327aa4b2861fca2f67242dee6031a0481c6441" translate="yes" xml:space="preserve">
          <source>An (efficient) array of characters.</source>
          <target state="translated">文字の(効率的な)配列。</target>
        </trans-unit>
        <trans-unit id="b24fa2adc3461b8097e9865ddc5d05a962a6075d" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;end-of-file&lt;/code&gt; error is signaled if reading encounters an unterminated list, vector, or string.</source>
          <target state="translated">読み取りで &lt;code&gt;end-of-file&lt;/code&gt; ないリスト、ベクトル、または文字列が検出されると、ファイルの終わりエラーが通知されます。</target>
        </trans-unit>
        <trans-unit id="4fa8eeb2346c8a9639fa3ee155f83ec1952beb3e" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;action alist&lt;/em&gt; is an association list mapping predefined symbols recognized by action functions to values these functions are supposed to interpret accordingly. In each call, &lt;code&gt;display-buffer&lt;/code&gt; constructs a new, possibly empty action alist and passes that entire list on to any action function it calls.</source>
          <target state="translated">&lt;em&gt;アクション連想リストは、&lt;/em&gt;これらの機能は、それに応じて解釈するようになっている値に作用機能によって認識アソシエーションリストマッピング定義済みシンボルです。各呼び出しで、 &lt;code&gt;display-buffer&lt;/code&gt; は新しい、場合によっては空のアクションリストを作成し、そのリスト全体を呼び出したアクション関数に渡します。</target>
        </trans-unit>
        <trans-unit id="6fbb202e704ca6497d62596b4b24317b48567731" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;action function&lt;/em&gt; is a function &lt;code&gt;display-buffer&lt;/code&gt; calls for choosing a window to display a buffer. Action functions take two arguments: &lt;var&gt;buffer&lt;/var&gt;, the buffer to display, and &lt;var&gt;alist&lt;/var&gt;, an action alist (see &lt;a href=&quot;buffer-display-action-alists#Buffer-Display-Action-Alists&quot;&gt;Buffer Display Action Alists&lt;/a&gt;). They are supposed to return a window displaying &lt;var&gt;buffer&lt;/var&gt; if they succeed and &lt;code&gt;nil&lt;/code&gt; if they fail.</source>
          <target state="translated">&lt;em&gt;アクション機能は、&lt;/em&gt;機能である &lt;code&gt;display-buffer&lt;/code&gt; バッファを表示するウィンドウを選択するためのコール。：アクション関数は、次の2つの引数を取る &lt;var&gt;buffer&lt;/var&gt; 、ディスプレイへのバッファ、および &lt;var&gt;alist&lt;/var&gt; 、アクション連想リスト（参照&lt;a href=&quot;buffer-display-action-alists#Buffer-Display-Action-Alists&quot;&gt;バッファの表示アクション連想リストを&lt;/a&gt;）。成功した場合は &lt;var&gt;buffer&lt;/var&gt; 表示するウィンドウを返し、失敗した場合は &lt;code&gt;nil&lt;/code&gt; を返すことになっています。</target>
        </trans-unit>
        <trans-unit id="42d3eec2eded4ad1f09d03ecadb028b0fe97c946" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;array&lt;/em&gt; is a fixed-length object with a slot for each of its elements. All the elements are accessible in constant time. The four types of arrays are strings, vectors, char-tables and bool-vectors.</source>
          <target state="translated">&lt;em&gt;アレイは、&lt;/em&gt;その要素のそれぞれに対するスロットを有する固定長のオブジェクトです。すべての要素に一定時間でアクセスできます。配列の4つのタイプは、文字列、ベクトル、char-tables、およびbool-vectorsです。</target>
        </trans-unit>
        <trans-unit id="a4bee20b16add7aae2f3af434413439ac2fc3a32" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;array&lt;/em&gt; is composed of an arbitrary number of slots for holding or referring to other Lisp objects, arranged in a contiguous block of memory. Accessing any element of an array takes approximately the same amount of time. In contrast, accessing an element of a list requires time proportional to the position of the element in the list. (Elements at the end of a list take longer to access than elements at the beginning of a list.)</source>
          <target state="translated">&lt;em&gt;アレイは&lt;/em&gt;、保持又はメモリの連続ブロックに配置された他のLispオブジェクトを参照するためのスロットの任意の数で構成されています。配列の任意の要素にアクセスするには、ほぼ同じ時間がかかります。対照的に、リストの要素にアクセスするには、リスト内の要素の位置に比例した時間が必要です。（リストの最後にある要素は、リストの最初にある要素よりもアクセスに時間がかかります。）</target>
        </trans-unit>
        <trans-unit id="553ed232664b5e6ef74691641b0767d1d08a7cfd" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;array&lt;/em&gt; object has slots that hold a number of other Lisp objects, called the elements of the array. Any element of an array may be accessed in constant time. In contrast, the time to access an element of a list is proportional to the position of that element in the list.</source>
          <target state="translated">&lt;em&gt;配列&lt;/em&gt;オブジェクトは、他のLispオブジェクトの数を保持するスロットを有し、配列の要素と呼ばれます。配列の任意の要素に一定時間でアクセスできます。対照的に、リストの要素にアクセスする時間は、リスト内のその要素の位置に比例します。</target>
        </trans-unit>
        <trans-unit id="51d6c8f716e9b88b14b6fb96e89f9851f7407153" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;association list&lt;/em&gt; or &lt;em&gt;alist&lt;/em&gt; is a specially-constructed list whose elements are cons cells. In each element, the &lt;small&gt;CAR&lt;/small&gt; is considered a &lt;em&gt;key&lt;/em&gt;, and the &lt;small&gt;CDR&lt;/small&gt; is considered an &lt;em&gt;associated value&lt;/em&gt;. (In some cases, the associated value is stored in the &lt;small&gt;CAR&lt;/small&gt; of the &lt;small&gt;CDR&lt;/small&gt;.) Association lists are often used as stacks, since it is easy to add or remove associations at the front of the list.</source>
          <target state="translated">&lt;em&gt;関連リスト&lt;/em&gt;または&lt;em&gt;連想リストは、&lt;/em&gt;その要素がコンス・セルで特別に構築リストです。各要素で、&lt;small&gt;CAR&lt;/small&gt;は&lt;em&gt;キー&lt;/em&gt;と見なされ、&lt;small&gt;CDR&lt;/small&gt;は&lt;em&gt;関連する値&lt;/em&gt;と見なされ&lt;em&gt;ます&lt;/em&gt;。 （場合によっては、関連付けられた値が&lt;small&gt;CDR&lt;/small&gt;の&lt;small&gt;CAR&lt;/small&gt;に格納されます。）関連付けリストは、リストの先頭で関連付けを簡単に追加または削除できるため、スタックとして使用されることがよくあります。&lt;small&gt;&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="1abfa47a133f69e41aaa18f7e94f5e435978d98b" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;association list&lt;/em&gt;, or &lt;em&gt;alist&lt;/em&gt; for short, records a mapping from keys to values. It is a list of cons cells called &lt;em&gt;associations&lt;/em&gt;: the &lt;small&gt;CAR&lt;/small&gt; of each cons cell is the &lt;em&gt;key&lt;/em&gt;, and the &lt;small&gt;CDR&lt;/small&gt; is the &lt;em&gt;associated value&lt;/em&gt;.&lt;a href=&quot;#FOOT5&quot; name=&quot;DOCF5&quot;&gt;&lt;sup&gt;5&lt;/sup&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;em&gt;連想リスト&lt;/em&gt;、または&lt;em&gt;連想リスト&lt;/em&gt;短いためには、キーから値へのマッピングを記録します。これは呼ばれるコンスセルのリストである&lt;em&gt;団体&lt;/em&gt;：&lt;small&gt;CAR&lt;/small&gt;各コンスセルのが&lt;em&gt;キー&lt;/em&gt;、そして&lt;small&gt;CDRは&lt;/small&gt;ある&lt;em&gt;関連付けられた値&lt;/em&gt;。&lt;a href=&quot;#FOOT5&quot; name=&quot;DOCF5&quot;&gt;&lt;sup&gt;5&lt;/sup&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b5d765e12413afb561974dbf3e3027981ca84c13" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;autoload object&lt;/em&gt; is a list whose first element is the symbol &lt;code&gt;autoload&lt;/code&gt;. It is stored as the function definition of a symbol, where it serves as a placeholder for the real definition. The autoload object says that the real definition is found in a file of Lisp code that should be loaded when necessary. It contains the name of the file, plus some other information about the real definition.</source>
          <target state="translated">&lt;em&gt;自動ロードオブジェクトは、&lt;/em&gt;その最初の要素のシンボルであるリストである &lt;code&gt;autoload&lt;/code&gt; 。これは、シンボルの関数定義として格納され、実際の定義のプレースホルダーとして機能します。autoloadオブジェクトは、実際の定義が必要なときにロードされるべきLispコードのファイルにあることを示しています。これには、ファイルの名前に加えて、実際の定義に関するその他の情報が含まれています。</target>
        </trans-unit>
        <trans-unit id="24cadccfe6209dab134eadc89a088981a88134fc" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;ewoc&lt;/em&gt; is a structure that organizes information required to construct buffer text that represents certain Lisp data. The buffer text of the ewoc has three parts, in order: first, fixed &lt;em&gt;header&lt;/em&gt; text; next, textual descriptions of a series of data elements (Lisp objects that you specify); and last, fixed &lt;em&gt;footer&lt;/em&gt; text. Specifically, an ewoc contains information on:</source>
          <target state="translated">&lt;em&gt;ewocは&lt;/em&gt;、特定のLispデータを表すコンストラクトバッファテキストに必要な情報を編成する構造です。ewocのバッファテキストは、次の3つの部分で構成されています。最初に、固定&lt;em&gt;ヘッダー&lt;/em&gt;テキスト。次に、一連のデータ要素（指定したLispオブジェクト）のテキストによる説明。最後に、固定&lt;em&gt;フッター&lt;/em&gt;テキスト。具体的には、ewocには次の情報が含まれています。</target>
        </trans-unit>
        <trans-unit id="45ade8aa3c0307591d943018dc5e837198a89448" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;image descriptor&lt;/em&gt; is a list which specifies the underlying data for an image, and how to display it. It is typically used as the value of a &lt;code&gt;display&lt;/code&gt; overlay or text property (see &lt;a href=&quot;other-display-specs#Other-Display-Specs&quot;&gt;Other Display Specs&lt;/a&gt;); but See &lt;a href=&quot;showing-images#Showing-Images&quot;&gt;Showing Images&lt;/a&gt;, for convenient helper functions to insert images into buffers.</source>
          <target state="translated">&lt;em&gt;画像記述子は、&lt;/em&gt;画像の基礎となるデータを指定するリストであり、それを表示する方法。これは通常、 &lt;code&gt;display&lt;/code&gt; オーバーレイまたはテキストプロパティの値として使用されます（&lt;a href=&quot;other-display-specs#Other-Display-Specs&quot;&gt;その他の表示仕様を&lt;/a&gt;参照）。ただし、画像をバッファに挿入するための便利なヘルパー関数については、「&lt;a href=&quot;showing-images#Showing-Images&quot;&gt;画像の表示&lt;/a&gt;」を参照してください。</target>
        </trans-unit>
        <trans-unit id="8ee4088b1e46a6b8823f17c1848dbfa1804acba9" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;indirect buffer&lt;/em&gt; shares the text of some other buffer, which is called the &lt;em&gt;base buffer&lt;/em&gt; of the indirect buffer. In some ways it is the analogue, for buffers, of a symbolic link among files. The base buffer may not itself be an indirect buffer.</source>
          <target state="translated">&lt;em&gt;間接バッファの&lt;/em&gt;共有と呼ばれているいくつかの他のバッファのテキスト&lt;em&gt;ベースのバッファ&lt;/em&gt;間接バッファの。いくつかの点で、それはファイル間のシンボリックリンクの類似物です。ベースバッファ自体が間接バッファであってはなりません。</target>
        </trans-unit>
        <trans-unit id="5d4ce81396c742a0b613f8351db2ccbce4a6b846" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;inline function&lt;/em&gt; is a function that works just like an ordinary function, except for one thing: when you byte-compile a call to the function (see &lt;a href=&quot;byte-compilation#Byte-Compilation&quot;&gt;Byte Compilation&lt;/a&gt;), the function&amp;rsquo;s definition is expanded into the caller.</source>
          <target state="translated">&lt;em&gt;インライン関数は、&lt;/em&gt;一つのことを除いて、普通の関数のように動作機能である：あなたはときに、関数の呼び出しを（参照バイトコンパイル&lt;a href=&quot;byte-compilation#Byte-Compilation&quot;&gt;バイトコンパイル&lt;/a&gt;）、関数の定義は、呼び出し元に展開されます。</target>
        </trans-unit>
        <trans-unit id="9f6630c098c66be4689d2cdd9cd8bef1da6dd18e" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;overlay&lt;/em&gt; specifies properties that apply to a part of a buffer. Each overlay applies to a specified range of the buffer, and contains a property list (a list whose elements are alternating property names and values). Overlay properties are used to present parts of the buffer temporarily in a different display style. Overlays have no read syntax, and print in hash notation, giving the buffer name and range of positions.</source>
          <target state="translated">&lt;em&gt;オーバーレイは&lt;/em&gt;、バッファの一部に適用されるプロパティを指定します。各オーバーレイは、バッファの指定された範囲に適用され、プロパティリスト（要素がプロパティ名と値を交互に持つリスト）を含みます。オーバーレイプロパティは、バッファの一部を別の表示スタイルで一時的に表示するために使用されます。オーバーレイには読み取り構文がなく、ハッシュ表記で出力され、バッファー名と位置の範囲が示されます。</target>
        </trans-unit>
        <trans-unit id="07799df1b9d386af6360d33cd65d6f9fe665cd6d" translate="yes" xml:space="preserve">
          <source>An &lt;var&gt;rhs&lt;/var&gt; cannot be an empty list (an empty list is never needed, since SMIE allows all non-terminals to match the empty string anyway).</source>
          <target state="translated">&lt;var&gt;rhs&lt;/var&gt; 空のリストにできません（SMIEは、すべての非端末はとにかく空の文字列を一致させることができますので、空のリストは、必要とされることはありません）。</target>
        </trans-unit>
        <trans-unit id="ad5b32c399f18af984f9755a3f1132417efccd31" translate="yes" xml:space="preserve">
          <source>An &lt;var&gt;rhs&lt;/var&gt; cannot have 2 consecutive non-terminals: each pair of non-terminals needs to be separated by a terminal (aka token). This is a fundamental limitation of operator precedence grammars.</source>
          <target state="translated">&lt;var&gt;rhs&lt;/var&gt; は、2つの連続する非終端記号を持つことはできません。非終端記号の各ペアは、終端記号（別名トークン）で区切る必要があります。これは、演算子優先順位文法の基本的な制限です。</target>
        </trans-unit>
        <trans-unit id="7922709da81f687d8271ff998b16af874b1814ac" translate="yes" xml:space="preserve">
          <source>An Emacs &lt;em&gt;character set&lt;/em&gt;, or &lt;em&gt;charset&lt;/em&gt;, is a set of characters in which each character is assigned a numeric code point. (The Unicode Standard calls this a &lt;em&gt;coded character set&lt;/em&gt;.) Each Emacs charset has a name which is a symbol. A single character can belong to any number of different character sets, but it will generally have a different code point in each charset. Examples of character sets include &lt;code&gt;ascii&lt;/code&gt;, &lt;code&gt;iso-8859-1&lt;/code&gt;, &lt;code&gt;greek-iso8859-7&lt;/code&gt;, and &lt;code&gt;windows-1255&lt;/code&gt;. The code point assigned to a character in a charset is usually different from its code point used in Emacs buffers and strings.</source>
          <target state="translated">Emacsの&lt;em&gt;文字セット&lt;/em&gt;（&lt;em&gt;charset&lt;/em&gt;）は、各文字に数値コードポイントが割り当てられた文字のセットです。 （Unicode標準では、これを&lt;em&gt;コード化文字セット&lt;/em&gt;と呼んでいます。）各Emacs文字セットには、記号である名前があります。 1つの文字は、任意の数の異なる文字セットに属することができますが、通常、各文字セットには異なるコードポイントがあります。文字セットの例には、 &lt;code&gt;ascii&lt;/code&gt; 、 &lt;code&gt;iso-8859-1&lt;/code&gt; 、 &lt;code&gt;greek-iso8859-7&lt;/code&gt; 、および &lt;code&gt;windows-1255&lt;/code&gt; が含まれます。文字セット内の文字に割り当てられたコードポイントは、通常、Emacsのバッファや文字列で使用されているコードポイントとは異なります。</target>
        </trans-unit>
        <trans-unit id="b460981854f34e1d2df2695ccac2e570ff87d223" translate="yes" xml:space="preserve">
          <source>An Emacs installation may have a &lt;em&gt;default init file&lt;/em&gt;, which is a Lisp library named</source>
          <target state="translated">Emacsのインストールには、&lt;em&gt;デフォルトのinitファイル&lt;/em&gt;がある場合があり&lt;em&gt;ます&lt;/em&gt;。これはLispライブラリという名前です。</target>
        </trans-unit>
        <trans-unit id="e2785779758cffeebac8e8b91c79bc832a2d5aa1" translate="yes" xml:space="preserve">
          <source>An abbrev table is represented as an obarray. See &lt;a href=&quot;creating-symbols#Creating-Symbols&quot;&gt;Creating Symbols&lt;/a&gt;, for information about obarrays. Each abbreviation is represented by a symbol in the obarray. The symbol&amp;rsquo;s name is the abbreviation; its value is the expansion; its function definition is the hook function for performing the expansion (see &lt;a href=&quot;defining-abbrevs#Defining-Abbrevs&quot;&gt;Defining Abbrevs&lt;/a&gt;); and its property list cell contains various additional properties, including the use count and the number of times the abbreviation has been expanded (see &lt;a href=&quot;abbrev-properties#Abbrev-Properties&quot;&gt;Abbrev Properties&lt;/a&gt;).</source>
          <target state="translated">略語テーブルは、obarrayとして表されます。obarrayの詳細については、「&lt;a href=&quot;creating-symbols#Creating-Symbols&quot;&gt;シンボルの作成」を&lt;/a&gt;参照してください。各略語は、obarray内の記号で表されます。記号の名前は略語です。その値は拡張です。その関数定義は、展開を実行するためのフック関数です（&lt;a href=&quot;defining-abbrevs#Defining-Abbrevs&quot;&gt;略語の定義を参照&lt;/a&gt;）。また、そのプロパティリストセルには、使用回数や&lt;a href=&quot;abbrev-properties#Abbrev-Properties&quot;&gt;略語&lt;/a&gt;が展開された回数など、さまざまな追加のプロパティが含まれています（略語のプロパティを参照）。</target>
        </trans-unit>
        <trans-unit id="e708d184dee6ca64093dbe415ec262b16c5b9ff2" translate="yes" xml:space="preserve">
          <source>An abbreviation or &lt;em&gt;abbrev&lt;/em&gt; is a string of characters that may be expanded to a longer string. The user can insert the abbrev string and find it replaced automatically with the expansion of the abbrev. This saves typing.</source>
          <target state="translated">略語または&lt;em&gt;略語&lt;/em&gt;は、より長い文字列に展開できる文字列です。ユーザーは略語文字列を挿入すると、略語の展開に自動的に置き換えられることがわかります。これにより、入力が節約されます。</target>
        </trans-unit>
        <trans-unit id="8be78449d783fd1e94ea043c27376e317eb4caa7" translate="yes" xml:space="preserve">
          <source>An abnormal hook run by &lt;code&gt;delete-terminal&lt;/code&gt;. Each function receives one argument, the &lt;var&gt;terminal&lt;/var&gt; argument passed to &lt;code&gt;delete-terminal&lt;/code&gt;. Due to technical details, the functions may be called either just before the terminal is deleted, or just afterwards.</source>
          <target state="translated">&lt;code&gt;delete-terminal&lt;/code&gt; によって実行される異常なフック。各関数は1つの引数を受け取り、 &lt;var&gt;terminal&lt;/var&gt; 引数は &lt;code&gt;delete-terminal&lt;/code&gt; に渡されます。技術的な詳細により、関数は端末が削除される直前または直後に呼び出される場合があります。</target>
        </trans-unit>
        <trans-unit id="6b8b396e23526cbc99aafc9321a68ad76aeb57a7" translate="yes" xml:space="preserve">
          <source>An abnormal hook run by &lt;code&gt;make-frame&lt;/code&gt; after it created the frame. Each function in &lt;code&gt;after-make-frame-functions&lt;/code&gt; receives one argument, the frame just created.</source>
          <target state="translated">&lt;code&gt;make-frame&lt;/code&gt; を作成した後、make-frameによって実行される異常なフック。 &lt;code&gt;after-make-frame-functions&lt;/code&gt; の各関数は、作成されたばかりのフレームという1つの引数を受け取ります。</target>
        </trans-unit>
        <trans-unit id="d8587f99198f36ccc0868cfa884bdb9eebf7fda4" translate="yes" xml:space="preserve">
          <source>An abnormal hook run by prefix commands (such as</source>
          <target state="translated">プレフィックスコマンドによって実行される異常なフック(例えば</target>
        </trans-unit>
        <trans-unit id="a76206aa6573ab5f6706b29d3c45607d86b5bf4d" translate="yes" xml:space="preserve">
          <source>An action function accepts two arguments: the buffer to display and an action alist. It attempts to display the buffer in some window, picking or creating a window according to its own criteria. If successful, it returns the window; otherwise, it returns &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">アクション関数は、表示するバッファーとアクションリストの2つの引数を受け入れます。バッファをあるウィンドウに表示しようとし、独自の基準に従ってウィンドウを選択または作成します。成功すると、ウィンドウが返されます。それ以外の場合は、 &lt;code&gt;nil&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="b8f8b239306495b67e6a33c553a3311a22ea8108" translate="yes" xml:space="preserve">
          <source>An action function for displaying buffers in side windows.</source>
          <target state="translated">サイドウィンドウにバッファを表示するアクション機能。</target>
        </trans-unit>
        <trans-unit id="8d4ccdf032d06b3ff88d7877263294cc83765270" translate="yes" xml:space="preserve">
          <source>An alist of the minor modes of this buffer.</source>
          <target state="translated">このバッファのマイナーモードの一覧。</target>
        </trans-unit>
        <trans-unit id="9d0b7856c0ae1bba2fe0095e327228fef5e6cbeb" translate="yes" xml:space="preserve">
          <source>An alternative to keeping around C data structures that need to be passed to module functions later is to create &lt;em&gt;user pointer&lt;/em&gt; objects. A user pointer, or &lt;code&gt;user-ptr&lt;/code&gt;, object is a Lisp object that encapsulates a C pointer and can have an associated finalizer function, which is called when the object is garbage-collected (see &lt;a href=&quot;garbage-collection#Garbage-Collection&quot;&gt;Garbage Collection&lt;/a&gt;). The module</source>
          <target state="translated">後でモジュール関数に渡す必要があるCデータ構造を保持する代わりに、&lt;em&gt;ユーザーポインタ&lt;/em&gt;オブジェクトを作成することも&lt;em&gt;でき&lt;/em&gt;ます。ユーザーポインターまたは &lt;code&gt;user-ptr&lt;/code&gt; オブジェクトは、Cポインターをカプセル化するLispオブジェクトであり、オブジェクトが&lt;a href=&quot;garbage-collection#Garbage-Collection&quot;&gt;ガベージコレクション&lt;/a&gt;されるときに呼び出されるファイナライザー関数を関連付けることができます（ガベージコレクションを参照）。モジュール</target>
        </trans-unit>
        <trans-unit id="76745f9f38a9adc0e71accf01a6af367ec394a13" translate="yes" xml:space="preserve">
          <source>An alternative, structured regexp notation.</source>
          <target state="translated">代替的な構造化正規表現表記法。</target>
        </trans-unit>
        <trans-unit id="49d23cb0a4197518f11c87451f54d2c79b88ddd3" translate="yes" xml:space="preserve">
          <source>An anonymous face: a property list of the form &lt;code&gt;(&lt;var&gt;keyword&lt;/var&gt;
&lt;var&gt;value&lt;/var&gt; &amp;hellip;)&lt;/code&gt;, where each &lt;var&gt;keyword&lt;/var&gt; is a face attribute name and &lt;var&gt;value&lt;/var&gt; is a value for that attribute.</source>
          <target state="translated">匿名の顔：フォーム &lt;code&gt;(&lt;var&gt;keyword&lt;/var&gt; &lt;var&gt;value&lt;/var&gt; &amp;hellip;)&lt;/code&gt; プロパティリスト。各 &lt;var&gt;keyword&lt;/var&gt; は顔の属性名であり、 &lt;var&gt;value&lt;/var&gt; はその属性の値です。</target>
        </trans-unit>
        <trans-unit id="0cb1807f666d0b9ab5deb699a6ca67714dc0387b" translate="yes" xml:space="preserve">
          <source>An application can bind this variable to a non-&lt;code&gt;nil&lt;/code&gt; value around calls to these functions. If it does so, the application is fully responsible for correctly assigning the parameters of all involved windows when exiting that function.</source>
          <target state="translated">アプリケーションは、これらの関数の呼び出しの前後で、この変数を &lt;code&gt;nil&lt;/code&gt; 以外の値にバインドできます。その場合、アプリケーションは、その関数を終了するときに、関連するすべてのウィンドウのパラメーターを正しく割り当てる責任があります。</target>
        </trans-unit>
        <trans-unit id="17ba397de5d1c307ab7dde751562e065ea00e3df" translate="yes" xml:space="preserve">
          <source>An arrow in the left fringe indicates the line where the function is executing. Point initially shows where within the line the function is executing, but this ceases to be true if you move point yourself.</source>
          <target state="translated">左のフリンジの矢印は、関数が実行されている行を示しています。Pointは、最初は関数が実行されている行のどこにあるかを示していますが、自分でPointを移動させた場合には、この表示はなくなります。</target>
        </trans-unit>
        <trans-unit id="ac945ca03e1203355b8e2eb7095f27f8bf8a33d9" translate="yes" xml:space="preserve">
          <source>An asynchronous process is controlled either via a &lt;em&gt;pty&lt;/em&gt; (pseudo-terminal) or a &lt;em&gt;pipe&lt;/em&gt;. The choice of pty or pipe is made when creating the process, by default based on the value of the variable &lt;code&gt;process-connection-type&lt;/code&gt; (see below). If available, ptys are usually preferable for processes visible to the user, as in Shell mode, because they allow for job control (</source>
          <target state="translated">非同期プロセスは、&lt;em&gt;pty&lt;/em&gt;（疑似端末）または&lt;em&gt;パイプの&lt;/em&gt;いずれかを介して制御されます。ptyまたはpipeの選択は、プロセスの作成時に行われます。デフォルトでは、変数 &lt;code&gt;process-connection-type&lt;/code&gt; の値に基づいています（以下を参照）。利用可能な場合、ptyは通常、シェルモードのように、ユーザーに表示されるプロセスに適しています。これは、ジョブ制御が可能であるためです（</target>
        </trans-unit>
        <trans-unit id="fed2f1ab264295d6199c8837444baee7f96bfb5c" translate="yes" xml:space="preserve">
          <source>An autoload object is usually created with the function &lt;code&gt;autoload&lt;/code&gt;, which stores the object in the function cell of a symbol. See &lt;a href=&quot;autoload#Autoload&quot;&gt;Autoload&lt;/a&gt;, for more details.</source>
          <target state="translated">autoloadオブジェクトは通常、関数 &lt;code&gt;autoload&lt;/code&gt; を使用して作成されます。この関数は、オブジェクトをシンボルの関数セルに格納します。詳細については、&lt;a href=&quot;autoload#Autoload&quot;&gt;自動ロードを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="224896b7315afde30421b984952b3f7096f2d130" translate="yes" xml:space="preserve">
          <source>An autoloaded keymap loads automatically during key lookup when a prefix key&amp;rsquo;s binding is the symbol &lt;var&gt;function&lt;/var&gt;. Autoloading does not occur for other kinds of access to the keymap. In particular, it does not happen when a Lisp program gets the keymap from the value of a variable and calls &lt;code&gt;define-key&lt;/code&gt;; not even if the variable name is the same symbol &lt;var&gt;function&lt;/var&gt;.</source>
          <target state="translated">プレフィックスキーのバインディングがシンボル &lt;var&gt;function&lt;/var&gt; 場合、自動ロードされたキーマップはキールックアップ中に自動的にロードされます。キーマップへの他の種類のアクセスでは、自動ロードは発生しません。特に、Lispプログラムが変数の値からキーマップを取得し、 &lt;code&gt;define-key&lt;/code&gt; を呼び出す場合は発生しません。変数名が同じシンボル &lt;var&gt;function&lt;/var&gt; ても違います。</target>
        </trans-unit>
        <trans-unit id="b47c8f66af20cead9b4237e06f3de8a32193907c" translate="yes" xml:space="preserve">
          <source>An element can also look like this:</source>
          <target state="translated">要素は、次のような形にすることもできます。</target>
        </trans-unit>
        <trans-unit id="d07aa0262359efa83d0dc291cc7ca1c53bb48bad" translate="yes" xml:space="preserve">
          <source>An empty element in the value of the environment variable, whether trailing (as in the above example), leading, or embedded, is replaced by the default value of &lt;code&gt;load-path&lt;/code&gt; as determined by the standard initialization procedure. If there are no such empty elements, then &lt;code&gt;EMACSLOADPATH&lt;/code&gt; specifies the entire &lt;code&gt;load-path&lt;/code&gt;. You must include either an empty element, or the explicit path to the directory containing the standard Lisp files, else Emacs will not function. (Another way to modify &lt;code&gt;load-path&lt;/code&gt; is to use the</source>
          <target state="translated">環境変数の値の空の要素は、末尾（上記の例のように）、先頭、または埋め込みのいずれであっても、標準の初期化手順で決定された &lt;code&gt;load-path&lt;/code&gt; のデフォルト値に置き換えられます。そのような空の要素がない場合、 &lt;code&gt;EMACSLOADPATH&lt;/code&gt; は &lt;code&gt;load-path&lt;/code&gt; 全体を指定します。空の要素、または標準のLispファイルを含むディレクトリへの明示的なパスのいずれかを含める必要があります。そうしないと、Emacsは機能しません。（ &lt;code&gt;load-path&lt;/code&gt; を変更する別の方法は、</target>
        </trans-unit>
        <trans-unit id="4ebff7dd30b4758ff88bcc9a085f45ded794db52" translate="yes" xml:space="preserve">
          <source>An empty sequence contributes nothing to the value returned by &lt;code&gt;append&lt;/code&gt;. As a consequence of this, a final &lt;code&gt;nil&lt;/code&gt; argument forces a copy of the previous argument:</source>
          <target state="translated">空のシーケンスは、 &lt;code&gt;append&lt;/code&gt; によって返される値には何の影響も与えません。この結果、最後の &lt;code&gt;nil&lt;/code&gt; 引数は、前の引数のコピーを強制します。</target>
        </trans-unit>
        <trans-unit id="a86a8ba20f9c2d16da923dc8e59ec1f1d98d5dee" translate="yes" xml:space="preserve">
          <source>An equivalent expression for &lt;code&gt;(add-to-list '&lt;var&gt;var&lt;/var&gt;
&lt;var&gt;value&lt;/var&gt;)&lt;/code&gt; is this:</source>
          <target state="translated">&lt;code&gt;(add-to-list '&lt;var&gt;var&lt;/var&gt; &lt;var&gt;value&lt;/var&gt;)&lt;/code&gt; の同等の式は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="d3b3af3cc140e3e00a2eb7021cf621de45339c06" translate="yes" xml:space="preserve">
          <source>An error in &lt;var&gt;body&lt;/var&gt; does not undo the load, but does prevent execution of the rest of &lt;var&gt;body&lt;/var&gt;.</source>
          <target state="translated">&lt;var&gt;body&lt;/var&gt; のエラーはロードを元に戻しませんが、 &lt;var&gt;body&lt;/var&gt; の残りの部分の実行を妨げます。</target>
        </trans-unit>
        <trans-unit id="780991d8624f2cb2ad931ebb1b65ed8116e288c9" translate="yes" xml:space="preserve">
          <source>An error is signaled if &lt;var&gt;command&lt;/var&gt; is not a function or if it cannot be called interactively (i.e., is not a command). Note that keyboard macros (strings and vectors) are not accepted, even though they are considered commands, because they are not functions. If &lt;var&gt;command&lt;/var&gt; is a symbol, then &lt;code&gt;call-interactively&lt;/code&gt; uses its function definition.</source>
          <target state="translated">&lt;var&gt;command&lt;/var&gt; が関数ではない場合、または対話的に呼び出すことができない場合（つまり、コマンドではない場合）、エラーが通知されます。キーボードマクロ（文字列とベクトル）は、関数ではないため、コマンドと見なされても受け入れられないことに注意してください。場合は &lt;var&gt;command&lt;/var&gt; シンボルであり、その後、 &lt;code&gt;call-interactively&lt;/code&gt; その関数定義を使用しています。</target>
        </trans-unit>
        <trans-unit id="61727b4effcd7b8d96ef35b8becbc54d386ea1fd" translate="yes" xml:space="preserve">
          <source>An error is signaled if &lt;var&gt;directory&lt;/var&gt; is not the name of a directory that can be read.</source>
          <target state="translated">&lt;var&gt;directory&lt;/var&gt; が読み取り可能なディレクトリの名前でない場合、エラーが通知されます。</target>
        </trans-unit>
        <trans-unit id="a857332d53570982c6dc820fa3fd199f30c64bac" translate="yes" xml:space="preserve">
          <source>An error is signaled if &lt;var&gt;frame&lt;/var&gt; has no side windows and no saved state is found for it.</source>
          <target state="translated">&lt;var&gt;frame&lt;/var&gt; にサイドウィンドウがなく、保存された状態が見つからない場合、エラーが通知されます。</target>
        </trans-unit>
        <trans-unit id="4c7868057424e94cc2ec18aa245abf34334cd76a" translate="yes" xml:space="preserve">
          <source>An error is signaled if &lt;var&gt;marker&lt;/var&gt; is neither a marker nor an integer.</source>
          <target state="translated">&lt;var&gt;marker&lt;/var&gt; がマーカーでも整数でもない場合、エラーが通知されます。</target>
        </trans-unit>
        <trans-unit id="ce502c5c14b3dd5ab57c7b1bc0667e1dce7ae3f1" translate="yes" xml:space="preserve">
          <source>An error is signaled if &lt;var&gt;name&lt;/var&gt; is not a string.</source>
          <target state="translated">&lt;var&gt;name&lt;/var&gt; が文字列でない場合、エラーが通知されます。</target>
        </trans-unit>
        <trans-unit id="d180f585f076cc17698606f42a90ec93eb4bf554" translate="yes" xml:space="preserve">
          <source>An error is signaled if you cannot write or create &lt;var&gt;filename&lt;/var&gt;.</source>
          <target state="translated">&lt;var&gt;filename&lt;/var&gt; 記述または作成できない場合は、エラーが通知されます。</target>
        </trans-unit>
        <trans-unit id="4b96760d80ee8b7d0f895bcbd78c4d4e13017398" translate="yes" xml:space="preserve">
          <source>An error is signaled unless both &lt;var&gt;start&lt;/var&gt; and &lt;var&gt;end&lt;/var&gt; are integers or markers that indicate positions in the current buffer. (It is unimportant which number is larger.)</source>
          <target state="translated">&lt;var&gt;start&lt;/var&gt; と &lt;var&gt;end&lt;/var&gt; 両方が現在のバッファ内の位置を示す整数またはマーカーでない限り、エラーが通知されます。（どちらの数字が大きいかは重要ではありません。）</target>
        </trans-unit>
        <trans-unit id="c51f55b2646e08b61f713ce7217e4887d1b95bfb" translate="yes" xml:space="preserve">
          <source>An error that has no explicit handler may call the Lisp debugger. The debugger is enabled if the variable &lt;code&gt;debug-on-error&lt;/code&gt; (see &lt;a href=&quot;error-debugging#Error-Debugging&quot;&gt;Error Debugging&lt;/a&gt;) is non-&lt;code&gt;nil&lt;/code&gt;. Unlike error handlers, the debugger runs in the environment of the error, so that you can examine values of variables precisely as they were at the time of the error.</source>
          <target state="translated">明示的なハンドラーがないエラーは、Lispデバッガーを呼び出す可能性があります。変数 &lt;code&gt;debug-on-error&lt;/code&gt; （「&lt;a href=&quot;error-debugging#Error-Debugging&quot;&gt;エラーのデバッグ&lt;/a&gt;」を参照）が &lt;code&gt;nil&lt;/code&gt; 以外の場合、デバッガーは有効になります。エラーハンドラーとは異なり、デバッガーはエラーの環境で実行されるため、変数の値をエラー時とまったく同じように調べることができます。</target>
        </trans-unit>
        <trans-unit id="826bd3cc8d084ab396a2d00d5bdbe16d54e818a5" translate="yes" xml:space="preserve">
          <source>An ewoc maintains its text in the buffer that is current when you create it, so switch to the intended buffer before calling &lt;code&gt;ewoc-create&lt;/code&gt;.</source>
          <target state="translated">ewocは、作成時に最新のバッファーにテキストを保持するため、 &lt;code&gt;ewoc-create&lt;/code&gt; を呼び出す前に目的のバッファーに切り替えてください。</target>
        </trans-unit>
        <trans-unit id="fc38d0c598a08a05ef1cbe7256ecba3cfbdd4bb4" translate="yes" xml:space="preserve">
          <source>An example of a major mode derived from Special mode is Buffer Menu mode, which is used by the</source>
          <target state="translated">スペシャルモードから派生した主要なモードの例としては、バッファメニューモードがあります。</target>
        </trans-unit>
        <trans-unit id="7d6bea7b0ca20a81d8dc92f7b4dfca2a43542cbd" translate="yes" xml:space="preserve">
          <source>An example of a major mode derived from Text mode is HTML mode. See &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/HTML-Mode.html#HTML-Mode&quot;&gt;SGML and HTML Modes&lt;/a&gt; in</source>
          <target state="translated">テキストモードから派生したメジャーモードの例は、HTMLモードです。参照&lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/HTML-Mode.html#HTML-Mode&quot;&gt;SGMLとHTMLモード&lt;/a&gt;で</target>
        </trans-unit>
        <trans-unit id="ade7f0bd288bb8a7ac97abf2b4ebdf07442ec432" translate="yes" xml:space="preserve">
          <source>An example of a special form is the definition of &lt;code&gt;or&lt;/code&gt;, from</source>
          <target state="translated">特別な形式の例は、からの &lt;code&gt;or&lt;/code&gt; の定義です。</target>
        </trans-unit>
        <trans-unit id="ef33cd83c0ed34c69762159ed48693bced9fc15f" translate="yes" xml:space="preserve">
          <source>An example of a type descriptor is any instance of &lt;code&gt;cl-structure-class&lt;/code&gt;.</source>
          <target state="translated">タイプ記述子の例は、 &lt;code&gt;cl-structure-class&lt;/code&gt; の任意のインスタンスです。</target>
        </trans-unit>
        <trans-unit id="24242de3c100a999285b6229c3f4ecef7f0ccd1f" translate="yes" xml:space="preserve">
          <source>An example of speedup from byte compilation.</source>
          <target state="translated">バイトコンパイルからの高速化の例。</target>
        </trans-unit>
        <trans-unit id="db343fa7b3e5ada913fce5ea3283f949a1870619" translate="yes" xml:space="preserve">
          <source>An example of the use of &lt;code&gt;defconst&lt;/code&gt; is Emacs&amp;rsquo;s definition of &lt;code&gt;float-pi&lt;/code&gt;&amp;mdash;the mathematical constant &lt;em&gt;pi&lt;/em&gt;, which ought not to be changed by anyone (attempts by the Indiana State Legislature notwithstanding). As the second form illustrates, however, &lt;code&gt;defconst&lt;/code&gt; is only advisory.</source>
          <target state="translated">&lt;code&gt;defconst&lt;/code&gt; の使用例は、Emacsによる &lt;code&gt;float-pi&lt;/code&gt; の定義です。これは数学定数&lt;em&gt;pi&lt;/em&gt;であり、誰も変更してはなりません（インディアナ州議会による試みにもかかわらず）。ただし、2番目の形式が示すように、 &lt;code&gt;defconst&lt;/code&gt; は単なる助言です。</target>
        </trans-unit>
        <trans-unit id="33511a390c0a0778aeb50d2d3d11dc55b02fecef" translate="yes" xml:space="preserve">
          <source>An exclusive lock for thread synchronization.</source>
          <target state="translated">スレッド同期用の排他的なロック。</target>
        </trans-unit>
        <trans-unit id="33cdd5563375ee0f1deecf7207e816fded24f27d" translate="yes" xml:space="preserve">
          <source>An extended-format menu item is a more flexible and also cleaner alternative to the simple format. You define an event type with a binding that&amp;rsquo;s a list starting with the symbol &lt;code&gt;menu-item&lt;/code&gt;. For a non-selectable string, the binding looks like this:</source>
          <target state="translated">拡張形式のメニュー項目は、単純な形式よりも柔軟でクリーンな代替手段です。シンボル &lt;code&gt;menu-item&lt;/code&gt; で始まるリストであるバインディングを使用してイベントタイプを定義します。選択できない文字列の場合、バインディングは次のようになります。</target>
        </trans-unit>
        <trans-unit id="dd1c3b20fbc2c4f6fdbfa727cc037df93e3d480a" translate="yes" xml:space="preserve">
          <source>An extra vertical space, with no actual line.</source>
          <target state="translated">実際のラインがない縦長の余分なスペース。</target>
        </trans-unit>
        <trans-unit id="7d946c1cee5e1ba6a2795eaa7494b0742a37aa80" translate="yes" xml:space="preserve">
          <source>An image map is an alist where each element has the format &lt;code&gt;(&lt;var&gt;area&lt;/var&gt; &lt;var&gt;id&lt;/var&gt; &lt;var&gt;plist&lt;/var&gt;)&lt;/code&gt;. An &lt;var&gt;area&lt;/var&gt; is specified as either a rectangle, a circle, or a polygon.</source>
          <target state="translated">イメージマップは、各要素の形式が &lt;code&gt;(&lt;var&gt;area&lt;/var&gt; &lt;var&gt;id&lt;/var&gt; &lt;var&gt;plist&lt;/var&gt;)&lt;/code&gt; のリストです。 &lt;var&gt;area&lt;/var&gt; 長方形、円形、または多角形のいずれかとして指定されています。</target>
        </trans-unit>
        <trans-unit id="13e8bfffc43f95cb01c82af877179e85c97c1ef2" translate="yes" xml:space="preserve">
          <source>An important function of each major mode is to customize the</source>
          <target state="translated">各主要モードの重要な機能は、カスタマイズのための</target>
        </trans-unit>
        <trans-unit id="3b4e015d01f5bbc54743f05646c0292a69c90141" translate="yes" xml:space="preserve">
          <source>An indication of the depth of recursive editing levels (not counting minibuffer levels): one &amp;lsquo;</source>
          <target state="translated">再帰的な編集レベルの深さの表示（ミニバッファーレベルはカウントされません）：1 '</target>
        </trans-unit>
        <trans-unit id="93f69cd72673e3fad1210d3ff536f5eac200198d" translate="yes" xml:space="preserve">
          <source>An indirect buffer cannot visit a file, but its base buffer can. If you try to save the indirect buffer, that actually saves the base buffer.</source>
          <target state="translated">間接バッファはファイルにアクセスできませんが、ベースバッファはアクセスできます。間接バッファを保存しようとすると、実際にはベースバッファが保存されます。</target>
        </trans-unit>
        <trans-unit id="f4f16819d5893d8be64117345439137741280e45" translate="yes" xml:space="preserve">
          <source>An indirect buffer shares text with some other buffer.</source>
          <target state="translated">間接バッファは、他のバッファとテキストを共有します。</target>
        </trans-unit>
        <trans-unit id="dd71440c52babfc9828665c875dc912c73851196" translate="yes" xml:space="preserve">
          <source>An input character event consists of a &lt;em&gt;basic code&lt;/em&gt; between 0 and 524287, plus any or all of these &lt;em&gt;modifier bits&lt;/em&gt;:</source>
          <target state="translated">入力文字イベントは、0〜524287の&lt;em&gt;基本コード&lt;/em&gt;と、これらの&lt;em&gt;修飾子ビットの&lt;/em&gt;いずれかまたはすべてで構成され&lt;em&gt;ます&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="b3693e265751b6a87adf1612d2ffab4f6ae73018" translate="yes" xml:space="preserve">
          <source>An integer indicating the Universal Time offset in seconds, i.e., the number of seconds east of Greenwich.</source>
          <target state="translated">協定世界時のオフセットを秒単位で示す整数、つまりグリニッジの東の秒数。</target>
        </trans-unit>
        <trans-unit id="1b85b9238ec8e0326b1ff24adce97a9f1339ccd1" translate="yes" xml:space="preserve">
          <source>An integer number specifies the desired total height of the chosen window in lines.</source>
          <target state="translated">整数値は、選択したウィンドウの高さの合計を行単位で指定します。</target>
        </trans-unit>
        <trans-unit id="ae5275ccb64692a25834f62374d3e39ff8168087" translate="yes" xml:space="preserve">
          <source>An integer specifies the desired total width of the chosen window in columns.</source>
          <target state="translated">整数値は、選択したウィンドウの全幅を列単位で指定します。</target>
        </trans-unit>
        <trans-unit id="c25162540c717d611e1426ca74b4483ad68c8fe4" translate="yes" xml:space="preserve">
          <source>An integer that increments each time Emacs is built in the same directory (without cleaning). This is only of relevance when developing Emacs.</source>
          <target state="translated">同じディレクトリにEmacsがビルドされるたびにインクリメントされる整数(クリーニングなし)。これは Emacs を開発する場合にのみ意味があります。</target>
        </trans-unit>
        <trans-unit id="a372e2277d8f20cbea84272110bbfb45b40e134a" translate="yes" xml:space="preserve">
          <source>An integer that represents the minimum number of colors the terminal should support. This matches a terminal if its &lt;code&gt;display-color-cells&lt;/code&gt; value is at least the specified integer.</source>
          <target state="translated">端末がサポートする必要のある色の最小数を表す整数。 &lt;code&gt;display-color-cells&lt;/code&gt; 値が少なくとも指定された整数である場合、これは端末と一致します。</target>
        </trans-unit>
        <trans-unit id="666998409bcbf2ebf0bfb7f00ef2a1f48383fd05" translate="yes" xml:space="preserve">
          <source>An integer, the operating system&amp;rsquo;s process</source>
          <target state="translated">整数、オペレーティングシステムのプロセス</target>
        </trans-unit>
        <trans-unit id="85068ddc5e4eeb621888a2f24d4968195abea28e" translate="yes" xml:space="preserve">
          <source>An integer, which stands for itself.</source>
          <target state="translated">それ自身を表す整数。</target>
        </trans-unit>
        <trans-unit id="483624c83a349249c67af72f64c85e27874fdcce" translate="yes" xml:space="preserve">
          <source>An integer. Although this is the simplest form, it cannot represent subsecond timestamps.</source>
          <target state="translated">整数。これは最も単純な形式ですが、サブセコンドのタイムスタンプを表すことはできません。</target>
        </trans-unit>
        <trans-unit id="210e35e78b0bac1a6f24a3e4af59acfd7b9cae5d" translate="yes" xml:space="preserve">
          <source>An interned symbol whose name is read in the minibuffer. Terminate the input with either</source>
          <target state="translated">ミニバッファに名前が読み込まれる内部シンボル。入力を終了するには</target>
        </trans-unit>
        <trans-unit id="d5c7d47ecad208491b6f75958ec8b743a987742f" translate="yes" xml:space="preserve">
          <source>An irrelevant argument. This code always supplies &lt;code&gt;nil&lt;/code&gt; as the argument&amp;rsquo;s value. No I/O.</source>
          <target state="translated">無関係な議論。このコードは、引数の値として常に &lt;code&gt;nil&lt;/code&gt; を提供します。I / Oなし。</target>
        </trans-unit>
        <trans-unit id="27856a404b93377dd2ce26256cf827f21924ee05" translate="yes" xml:space="preserve">
          <source>An object which can be invoked via the &lt;code&gt;command-execute&lt;/code&gt; primitive, usually due to the user typing in a key sequence &lt;em&gt;bound&lt;/em&gt; to that command. See &lt;a href=&quot;interactive-call#Interactive-Call&quot;&gt;Interactive Call&lt;/a&gt;. A command is usually a function; if the function is written in Lisp, it is made into a command by an &lt;code&gt;interactive&lt;/code&gt; form in the function definition (see &lt;a href=&quot;defining-commands#Defining-Commands&quot;&gt;Defining Commands&lt;/a&gt;). Commands that are functions can also be called from Lisp expressions, just like other functions.</source>
          <target state="translated">通常、ユーザーがそのコマンドに&lt;em&gt;バインド&lt;/em&gt;されたキーシーケンスを入力したために、 &lt;code&gt;command-execute&lt;/code&gt; プリミティブを介して呼び出すことができるオブジェクト。&lt;a href=&quot;interactive-call#Interactive-Call&quot;&gt;インタラクティブコールを&lt;/a&gt;参照してください。コマンドは通常、関数です。関数がLispで書かれている場合、関数定義の &lt;code&gt;interactive&lt;/code&gt; フォームによってコマンドになります（&lt;a href=&quot;defining-commands#Defining-Commands&quot;&gt;コマンドの&lt;/a&gt;定義を参照）。関数であるコマンドは、他の関数と同様に、Lisp式から呼び出すこともできます。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="187267476807f080e4cb1366bd55dc6c3a734b11" translate="yes" xml:space="preserve">
          <source>An old piece of advice such as:</source>
          <target state="translated">といった古いアドバイス。</target>
        </trans-unit>
        <trans-unit id="a4f4924d6a637db199a3dbbcbcca04ca29c457ed" translate="yes" xml:space="preserve">
          <source>An ordinary, unencrypted connection.</source>
          <target state="translated">通常の暗号化されていない接続です。</target>
        </trans-unit>
        <trans-unit id="8f179ba3c57cb5057b94b469bdc747796dcb263d" translate="yes" xml:space="preserve">
          <source>An output stream specifies what to do with the characters produced by printing. Most print functions accept an output stream as an optional argument. Here are the possible types of output stream:</source>
          <target state="translated">出力ストリームは、印刷によって生成された文字をどうするかを指定します。ほとんどの印刷関数は、オプションの引数として出力ストリームを受け入れます。以下に、出力ストリームの可能なタイプを示します。</target>
        </trans-unit>
        <trans-unit id="4a4e0e2275538ba1b3ea01efe71801a7f7f08073" translate="yes" xml:space="preserve">
          <source>An overlay uses markers to record its beginning and end; thus, editing the text of the buffer adjusts the beginning and end of each overlay so that it stays with the text. When you create the overlay, you can specify whether text inserted at the beginning should be inside the overlay or outside, and likewise for the end of the overlay.</source>
          <target state="translated">オーバーレイはマーカーを使用して開始と終了を記録しますので、バッファのテキストを編集すると、各オーバーレイの開始と終了がテキストと一緒に残るように調整されます。オーバーレイを作成する際に、最初に挿入されたテキストをオーバーレイの内側にするか外側にするかを指定することができます。</target>
        </trans-unit>
        <trans-unit id="b25d5a56d0ee9ca005469f384e566fa726e58945" translate="yes" xml:space="preserve">
          <source>An overlay whose &lt;var&gt;start&lt;/var&gt; and &lt;var&gt;end&lt;/var&gt; specify the same buffer position is known as &lt;em&gt;empty&lt;/em&gt;. A non-empty overlay can become empty if the text between its &lt;var&gt;start&lt;/var&gt; and &lt;var&gt;end&lt;/var&gt; is deleted. When that happens, the overlay is by default not deleted, but you can cause it to be deleted by giving it the &amp;lsquo;</source>
          <target state="translated">&lt;var&gt;start&lt;/var&gt; と &lt;var&gt;end&lt;/var&gt; が同じバッファ位置を指定するオーバーレイは、&lt;em&gt;空&lt;/em&gt;と呼ばれ&lt;em&gt;ます&lt;/em&gt;。空でないオーバーレイは、 &lt;var&gt;start&lt;/var&gt; と &lt;var&gt;end&lt;/var&gt; 間のテキストが削除されると空になる可能性があります。その場合、オーバーレイはデフォルトでは削除されませんが、 'を指定することで削除することができます。</target>
        </trans-unit>
        <trans-unit id="51ba330dcf0b0a0baa7674c3887cbac685290344" translate="yes" xml:space="preserve">
          <source>An overview of all the special sequences.</source>
          <target state="translated">すべての特殊なシーケンスの概要。</target>
        </trans-unit>
        <trans-unit id="045422a0880a1615b24f5a3a512245b1c27b53c3" translate="yes" xml:space="preserve">
          <source>An unspecified value, present for backward compatibility.</source>
          <target state="translated">不特定多数の値で、下位互換性のために存在します。</target>
        </trans-unit>
        <trans-unit id="55764c2c6ec8109ce06467af931be863e9f31e08" translate="yes" xml:space="preserve">
          <source>And here is the code to set up the keymap for Lisp mode:</source>
          <target state="translated">そして、ここにLispモードのキーマップを設定するコードがあります。</target>
        </trans-unit>
        <trans-unit id="b6e7a99ffdd1e497ee1a0b6591309c08b6de6ce9" translate="yes" xml:space="preserve">
          <source>Animation operates by means of a timer. Note that Emacs imposes a minimum frame delay of 0.01 (&lt;code&gt;image-minimum-frame-delay&lt;/code&gt;) seconds. If the image itself does not specify a delay, Emacs uses &lt;code&gt;image-default-frame-delay&lt;/code&gt;.</source>
          <target state="translated">アニメーションはタイマーによって動作します。Emacsは0.01（ &lt;code&gt;image-minimum-frame-delay&lt;/code&gt; ）秒の最小フレーム遅延を課していることに注意してください。画像自体が遅延を指定していない場合、Emacsは &lt;code&gt;image-default-frame-delay&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="6f497993755de46018a5ff1778be3f6bc999629d" translate="yes" xml:space="preserve">
          <source>Anonymous Functions</source>
          <target state="translated">匿名機能</target>
        </trans-unit>
        <trans-unit id="d155a6db1755fd84bc4701702679a300873b3893" translate="yes" xml:space="preserve">
          <source>Another annoyance (more an inconvenience than a limitation) is that when a series of &lt;var&gt;condition&lt;/var&gt; predicates implement equality tests, there is a lot of repeated code. (&lt;code&gt;cl-case&lt;/code&gt; solves this inconvenience.)</source>
          <target state="translated">もう1つの厄介な点（制限よりも不便）は、一連の &lt;var&gt;condition&lt;/var&gt; 述語が等価性テストを実装するときに、コードが繰り返されることです。（ &lt;code&gt;cl-case&lt;/code&gt; はこの不便を解決します。）</target>
        </trans-unit>
        <trans-unit id="5303f5dba20cc28da9809fdf0b019eb440c2beee" translate="yes" xml:space="preserve">
          <source>Another command,</source>
          <target state="translated">もう一つのコマンド。</target>
        </trans-unit>
        <trans-unit id="46429506bccc14a1fccf369e49c5519916a0ddea" translate="yes" xml:space="preserve">
          <source>Another difference from &lt;code&gt;rx-let&lt;/code&gt; is that the &lt;var&gt;bindings&lt;/var&gt; are dynamically scoped, and thus also available in functions called from &lt;var&gt;body&lt;/var&gt;. However, they are not visible inside functions defined in &lt;var&gt;body&lt;/var&gt;.</source>
          <target state="translated">&lt;code&gt;rx-let&lt;/code&gt; とのもう1つの違いは、 &lt;var&gt;bindings&lt;/var&gt; が動的にスコープされるため、 &lt;var&gt;body&lt;/var&gt; から呼び出される関数でも使用できることです。ただし、 &lt;var&gt;body&lt;/var&gt; で定義された関数内には表示されません。</target>
        </trans-unit>
        <trans-unit id="60eaf91aef5f334ebb5d4be6e2c8a0357829b694" translate="yes" xml:space="preserve">
          <source>Another disadvantage is that making a large function inline can increase the size of compiled code both in files and in memory. Since the speed advantage of inline functions is greatest for small functions, you generally should not make large functions inline.</source>
          <target state="translated">もう一つの欠点は、大きな関数をインラインで作成すると、ファイルとメモリの両方でコンパイルされたコードのサイズが大きくなってしまうことです。インライン関数の速度面での利点は小さな関数の方が大きいので、一般的には大きな関数をインラインにするべきではありません。</target>
        </trans-unit>
        <trans-unit id="6f719d65bc588f6114e05a3ba91ae2e2b8b0fa12" translate="yes" xml:space="preserve">
          <source>Another effect of calling this function is to cause unconditional redisplay of the mode line for the current buffer. In fact, the function &lt;code&gt;force-mode-line-update&lt;/code&gt; works by doing this:</source>
          <target state="translated">この関数を呼び出すことのもう1つの効果は、現在のバッファーのモード行を無条件に再表示することです。実際、 &lt;code&gt;force-mode-line-update&lt;/code&gt; 関数は、次のようにして機能します。</target>
        </trans-unit>
        <trans-unit id="fe8d47ec903dba59decabf21d52ed6b989d5e361" translate="yes" xml:space="preserve">
          <source>Another element is &lt;code&gt;(selinux-context . &lt;var&gt;context&lt;/var&gt;)&lt;/code&gt;, where &lt;var&gt;context&lt;/var&gt; is the SELinux context, in the same form returned by &lt;code&gt;file-selinux-context&lt;/code&gt;.</source>
          <target state="translated">別の要素である &lt;code&gt;(selinux-context . &lt;var&gt;context&lt;/var&gt;)&lt;/code&gt; 、 &lt;var&gt;context&lt;/var&gt; によって返される同じ形式で、SELinuxのコンテキストで &lt;code&gt;file-selinux-context&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d4a41e64a0f4d5fb203b7d54e395a3a3c7314af2" translate="yes" xml:space="preserve">
          <source>Another file for site-customization is</source>
          <target state="translated">サイトカスタマイズのための別のファイルは</target>
        </trans-unit>
        <trans-unit id="dc46fb6acabbfa966b8518e0f2262bc229a7fdf8" translate="yes" xml:space="preserve">
          <source>Another important concept is the notion of &lt;em&gt;parent&lt;/em&gt;: The &lt;em&gt;parent&lt;/em&gt; of a token, is the head token of the nearest enclosing syntactic construct. For example, the parent of an &lt;code&gt;else&lt;/code&gt; is the &lt;code&gt;if&lt;/code&gt; to which it belongs, and the parent of an &lt;code&gt;if&lt;/code&gt;, in turn, is the lead token of the surrounding construct. The command &lt;code&gt;backward-sexp&lt;/code&gt; jumps from a token to its parent, but there are some caveats: for &lt;em&gt;openers&lt;/em&gt; (tokens which start a construct, like &lt;code&gt;if&lt;/code&gt;), you need to start with point before the token, while for others you need to start with point after the token. &lt;code&gt;backward-sexp&lt;/code&gt; stops with point before the parent token if that is the &lt;em&gt;opener&lt;/em&gt; of the token of interest, and otherwise it stops with point after the parent token.</source>
          <target state="translated">もう1つの重要な概念は、&lt;em&gt;親&lt;/em&gt;の概念です。トークンの&lt;em&gt;親&lt;/em&gt;は、最も近い囲んでいる構文構造のヘッドトークンです。例えば、親の &lt;code&gt;else&lt;/code&gt; されて &lt;code&gt;if&lt;/code&gt; 、それが属する、との親 &lt;code&gt;if&lt;/code&gt; 、今度は、周囲の構造物の鉛トークンです。コマンド &lt;code&gt;backward-sexp&lt;/code&gt; はトークンからその親にジャンプしますが、いくつかの注意点があります。&lt;em&gt;オープナー&lt;/em&gt;（ &lt;code&gt;if&lt;/code&gt; のように構成を開始するトークン）の場合は、トークンの前のポイントから開始する必要がありますが、他の場合は、で開始する必要があります。トークンの後のポイント。 &lt;code&gt;backward-sexp&lt;/code&gt; は、親トークンの前のポイントで停止します。&lt;em&gt;対象&lt;/em&gt;のトークンの&lt;em&gt;オープナー。&lt;/em&gt;それ以外の場合は、親トークンの後のポイントで停止します。</target>
        </trans-unit>
        <trans-unit id="b9deb7098c7fabbe640d3f39576b579bcc48e2d3" translate="yes" xml:space="preserve">
          <source>Another problem can happen if the macro definition itself evaluates any of the macro argument expressions, such as by calling &lt;code&gt;eval&lt;/code&gt; (see &lt;a href=&quot;eval#Eval&quot;&gt;Eval&lt;/a&gt;). If the argument is supposed to refer to the user&amp;rsquo;s variables, you may have trouble if the user happens to use a variable with the same name as one of the macro arguments. Inside the macro body, the macro argument binding is the most local binding of this variable, so any references inside the form being evaluated do refer to it. Here is an example:</source>
          <target state="translated">&lt;code&gt;eval&lt;/code&gt; を呼び出すなどして、マクロ定義自体がマクロ引数式のいずれかを評価する場合、別の問題が発生する可能性があります（&lt;a href=&quot;eval#Eval&quot;&gt;Evalを&lt;/a&gt;参照）。引数がユーザーの変数を参照することになっている場合、ユーザーがマクロ引数の1つと同じ名前の変数を使用すると、問題が発生する可能性があります。マクロ本体内では、マクロ引数バインディングがこの変数の最もローカルなバインディングであるため、評価されるフォーム内の参照はすべてそれを参照します。次に例を示します。</target>
        </trans-unit>
        <trans-unit id="0557ba812636c13b28f9c028bebedfc50e7d0d42" translate="yes" xml:space="preserve">
          <source>Another problem with calling &lt;code&gt;eval&lt;/code&gt; in a macro definition is that it probably won&amp;rsquo;t do what you intend in a compiled program. The byte compiler runs macro definitions while compiling the program, when the program&amp;rsquo;s own computations (which you might have wished to access with &lt;code&gt;eval&lt;/code&gt;) don&amp;rsquo;t occur and its local variable bindings don&amp;rsquo;t exist.</source>
          <target state="translated">マクロ定義で &lt;code&gt;eval&lt;/code&gt; を呼び出す際の別の問題は、コンパイルされたプログラムで意図したとおりに実行されない可能性があることです。バイトコンパイラは、プログラムのコンパイル中にマクロ定義を実行します。これは、プログラム自体の計算（ &lt;code&gt;eval&lt;/code&gt; を使用してアクセスしたい場合があります）が発生せず、そのローカル変数バインディングが存在しない場合です。</target>
        </trans-unit>
        <trans-unit id="2808e270cef0e3cc098d7ecd467a657ae4eca448" translate="yes" xml:space="preserve">
          <source>Another prominent use of property lists is for storing symbol properties. Every symbol possesses a list of properties, used to record miscellaneous information about the symbol; these properties are stored in the form of a property list. See &lt;a href=&quot;symbol-properties#Symbol-Properties&quot;&gt;Symbol Properties&lt;/a&gt;.</source>
          <target state="translated">プロパティリストのもう1つの顕著な用途は、シンボルプロパティを保存することです。すべてのシンボルには、シンボルに関するその他の情報を記録するために使用されるプロパティのリストがあります。これらのプロパティは、プロパティリストの形式で保存されます。&lt;a href=&quot;symbol-properties#Symbol-Properties&quot;&gt;シンボルのプロパティを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="a7cde5f29771c6fd0640e059c163a4125f612e60" translate="yes" xml:space="preserve">
          <source>Another use for &lt;code&gt;image-flush&lt;/code&gt; is for memory conservation. If your Lisp program creates a large number of temporary images over a period much shorter than &lt;code&gt;image-cache-eviction-delay&lt;/code&gt; (see below), you can opt to flush unused images yourself, instead of waiting for Emacs to do it automatically.</source>
          <target state="translated">&lt;code&gt;image-flush&lt;/code&gt; もう1つの用途は、メモリの節約です。Lispプログラムが &lt;code&gt;image-cache-eviction-delay&lt;/code&gt; （以下を参照）よりもはるかに短い期間に多数の一時イメージを作成する場合、Emacsが自動的に行うのを待つ代わりに、未使用のイメージを自分でフラッシュすることを選択できます。</target>
        </trans-unit>
        <trans-unit id="641eb2680ee1c66beb56d48bd54946b6ae9853e6" translate="yes" xml:space="preserve">
          <source>Another way of classifying character syntax.</source>
          <target state="translated">文字構文を分類する別の方法。</target>
        </trans-unit>
        <trans-unit id="4bd2ea34cde1c693974149a710eecd977a89a21d" translate="yes" xml:space="preserve">
          <source>Another way to customize Imenu for a major mode is to set the variables &lt;code&gt;imenu-prev-index-position-function&lt;/code&gt; and &lt;code&gt;imenu-extract-index-name-function&lt;/code&gt;:</source>
          <target state="translated">メジャーモード用にImenuをカスタマイズする別の方法は、変数 &lt;code&gt;imenu-prev-index-position-function&lt;/code&gt; および &lt;code&gt;imenu-extract-index-name-function&lt;/code&gt; を設定することです。</target>
        </trans-unit>
        <trans-unit id="6a0538015d82239738c87e340807fdb7d0f6e3a0" translate="yes" xml:space="preserve">
          <source>Answer this question &amp;ldquo;no&amp;rdquo;, and give up on the entire series of questions for the current buffer. Continue to the next buffer in the sequence.</source>
          <target state="translated">この質問に「いいえ」と答え、現在のバッファに関する一連の質問全体をあきらめます。シーケンス内の次のバッファに進みます。</target>
        </trans-unit>
        <trans-unit id="274994b09ea810169b43f8a646ebc9ffc6bce18b" translate="yes" xml:space="preserve">
          <source>Answer this question &amp;ldquo;no&amp;rdquo;, and give up on the entire series of questions, assuming that the answers will be &amp;ldquo;no&amp;rdquo;.</source>
          <target state="translated">この質問に「いいえ」と答え、答えが「いいえ」になると仮定して、一連の質問全体をあきらめます。</target>
        </trans-unit>
        <trans-unit id="d8496e3b1f926969c35562be91206a0af61ee16e" translate="yes" xml:space="preserve">
          <source>Answer this question &amp;ldquo;yes&amp;rdquo;, and give up on the entire series of questions, assuming that subsequent answers will be &amp;ldquo;no&amp;rdquo;.</source>
          <target state="translated">この質問に「はい」と答え、その後の答えが「いいえ」になると仮定して、一連の質問全体をあきらめます。</target>
        </trans-unit>
        <trans-unit id="f56b5305911f928e39581a218bfd705b0028549b" translate="yes" xml:space="preserve">
          <source>Answer this question &amp;ldquo;yes&amp;rdquo;, but show the results&amp;mdash;don&amp;rsquo;t advance yet to the next question.</source>
          <target state="translated">この質問に「はい」と答えますが、結果を示します。まだ次の質問に進まないでください。</target>
        </trans-unit>
        <trans-unit id="c32d375e1b285db59346c4795a32d1241b4b196d" translate="yes" xml:space="preserve">
          <source>Answer this question and all subsequent questions in the series with &amp;ldquo;yes&amp;rdquo;, without further user interaction, for all remaining buffers.</source>
          <target state="translated">この質問とシリーズの後続のすべての質問に、残りのすべてのバッファーについて、ユーザーの操作なしで「はい」と答えます。</target>
        </trans-unit>
        <trans-unit id="cf8d75f96842754b6fdf5c2cb0d9b07cc288c581" translate="yes" xml:space="preserve">
          <source>Answer this question and all subsequent questions in the series with &amp;ldquo;yes&amp;rdquo;, without further user interaction.</source>
          <target state="translated">この質問とシリーズの後続のすべての質問には、ユーザーの操作なしで「はい」と答えてください。</target>
        </trans-unit>
        <trans-unit id="58980dd0f49cd2faac7cab10b446ea677250ef35" translate="yes" xml:space="preserve">
          <source>Antinews</source>
          <target state="translated">Antinews</target>
        </trans-unit>
        <trans-unit id="1fa1accc626834eb5e37df54ce5a411a8faa2f5a" translate="yes" xml:space="preserve">
          <source>Any Lisp program output that would normally go to the echo area, either using &lt;code&gt;message&lt;/code&gt;, or using &lt;code&gt;prin1&lt;/code&gt;, etc., with &lt;code&gt;t&lt;/code&gt; as the stream, goes instead to Emacs&amp;rsquo;s standard descriptors when in batch mode: &lt;code&gt;message&lt;/code&gt; writes to the standard error descriptor, while &lt;code&gt;prin1&lt;/code&gt; and other print functions write to the standard output. Similarly, input that would normally come from the minibuffer is read from the standard input descriptor. Thus, Emacs behaves much like a noninteractive application program. (The echo area output that Emacs itself normally generates, such as command echoing, is suppressed entirely.)</source>
          <target state="translated">通常、エコーエリアに行くと、任意のLispのプログラム出力、いずれかを使用して &lt;code&gt;message&lt;/code&gt; 、または使用して &lt;code&gt;prin1&lt;/code&gt; をして、など、 &lt;code&gt;t&lt;/code&gt; ストリームとして、時にバッチモードでEmacsの標準記述子に代わりに行く： &lt;code&gt;message&lt;/code&gt; を標準エラー記述子への書き込み、一方、 &lt;code&gt;prin1&lt;/code&gt; およびその他の印刷関数は標準出力に書き込みます。同様に、通常はミニバッファからの入力は、標準入力記述子から読み取られます。したがって、Emacsは非対話型アプリケーションプログラムのように動作します。 （コマンドエコーなど、Emacs自体が通常生成するエコーエリア出力は完全に抑制されます。）</target>
        </trans-unit>
        <trans-unit id="050f2a1f992936a9f3bd70f97c3df722975a4ffc" translate="yes" xml:space="preserve">
          <source>Any buffer which does not specify values for these variables uses the values specified by the &lt;code&gt;left-fringe&lt;/code&gt; and &lt;code&gt;right-fringe&lt;/code&gt; frame parameters (see &lt;a href=&quot;layout-parameters#Layout-Parameters&quot;&gt;Layout Parameters&lt;/a&gt;).</source>
          <target state="translated">これらの変数の値を指定しないバッファーは、 &lt;code&gt;left-fringe&lt;/code&gt; および &lt;code&gt;right-fringe&lt;/code&gt; フレームパラメーターで指定された値を使用します（&lt;a href=&quot;layout-parameters#Layout-Parameters&quot;&gt;レイアウトパラメーターを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="fd492b9bb3754cde03d33417c72155f2cdb192d7" translate="yes" xml:space="preserve">
          <source>Any conditional construct can be expressed with &lt;code&gt;cond&lt;/code&gt; or with &lt;code&gt;if&lt;/code&gt;. Therefore, the choice between them is a matter of style. For example:</source>
          <target state="translated">任意の条件付き構文は、 &lt;code&gt;cond&lt;/code&gt; または &lt;code&gt;if&lt;/code&gt; で表すことができます。したがって、それらの間の選択はスタイルの問題です。例えば：</target>
        </trans-unit>
        <trans-unit id="6a06364a7a0a952bf465c39928bf99f3f61b0422" translate="yes" xml:space="preserve">
          <source>Any connection profile of &lt;var&gt;profiles&lt;/var&gt; must have been already defined by &lt;code&gt;connection-local-set-profile-variables&lt;/code&gt;.</source>
          <target state="translated">いずれかの接続プロファイル &lt;var&gt;profiles&lt;/var&gt; すでにによって定義されている必要があります &lt;code&gt;connection-local-set-profile-variables&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a92544790b0c628c4a67c0d9ad0654a8710429c7" translate="yes" xml:space="preserve">
          <source>Any function or macro defined as Lisp code may be set to break on entry, regardless of whether it is interpreted code or compiled code. If the function is a command, it will enter the debugger when called from Lisp and when called interactively (after the reading of the arguments). You can also set debug-on-entry for primitive functions (i.e., those written in C) this way, but it only takes effect when the primitive is called from Lisp code. Debug-on-entry is not allowed for special forms.</source>
          <target state="translated">Lisp コードとして定義されている関数やマクロは、それが解釈コードであるかコンパイルされたコードであるかに関わらず、入力時にブレークするように設定することができます。関数がコマンドの場合、Lisp から呼び出されたときと、対話的に呼び出されたとき (引数を読み込んだ後)にデバッガに入ります。プリミティブ関数 (つまり C 言語で書かれた関数)のデバッグ・オン・エントリをこの方法で設定することもできますが、プリミティブが Lisp コードから呼び出されたときにのみ有効になります。デバッグ・オン・エントリは特殊な形式の場合には許可されません。</target>
        </trans-unit>
        <trans-unit id="8638b648157581df0efb6302834ee2f03492764d" translate="yes" xml:space="preserve">
          <source>Any integer glyph code greater than or equal to the length of the glyph table is displayed literally.</source>
          <target state="translated">グリフテーブルの長さ以上の整数のグリフコードはすべて文字通り表示されます。</target>
        </trans-unit>
        <trans-unit id="4c6a27c6563d69b7aca82f351f60298b13184203" translate="yes" xml:space="preserve">
          <source>Any kind of Lisp code is valid inside &lt;var&gt;body&lt;/var&gt;, but &lt;code&gt;iter-yield&lt;/code&gt; and &lt;code&gt;iter-yield-from&lt;/code&gt; cannot appear inside &lt;code&gt;unwind-protect&lt;/code&gt; forms.</source>
          <target state="translated">どんな種類のLispコードも &lt;var&gt;body&lt;/var&gt; 中で有効ですが、 &lt;code&gt;iter-yield&lt;/code&gt; と &lt;code&gt;iter-yield-from&lt;/code&gt; は &lt;code&gt;unwind-protect&lt;/code&gt; フォームの中には現れません。</target>
        </trans-unit>
        <trans-unit id="a4fc7cbf2349da81499a5258b7f6c62e471e0a86" translate="yes" xml:space="preserve">
          <source>Any of the above window elements (except &lt;code&gt;text&lt;/code&gt;) can also be used with &lt;code&gt;:align-to&lt;/code&gt; to specify that the position is relative to the left edge of the given area. Once the base offset for a relative position has been set (by the first occurrence of one of these symbols), further occurrences of these symbols are interpreted as the width of the specified area. For example, to align to the center of the left-margin, use</source>
          <target state="translated">上記のウィンドウ要素（ &lt;code&gt;text&lt;/code&gt; を除く）のいずれかを &lt;code&gt;:align-to&lt;/code&gt; とともに使用して、指定された領域の左端を基準にして位置を指定することもできます。相対位置のベースオフセットが設定されると（これらのシンボルの1つが最初に出現することにより）、これらのシンボルがさらに出現すると、指定された領域の幅として解釈されます。たとえば、左マージンの中央に揃えるには、</target>
        </trans-unit>
        <trans-unit id="947bbfa4cfb925a66b42d553b356034e0c632a8d" translate="yes" xml:space="preserve">
          <source>Any of these arguments can be given to identify the process that is to be configured. If none of these arguments is given, the current buffer&amp;rsquo;s process is used.</source>
          <target state="translated">これらの引数のいずれかを指定して、構成するプロセスを識別することができます。これらの引数のいずれも指定されていない場合は、現在のバッファーのプロセスが使用されます。</target>
        </trans-unit>
        <trans-unit id="d761e83aca259b6c169b8f0ba443733debb02169" translate="yes" xml:space="preserve">
          <source>Any other character following &amp;lsquo;</source>
          <target state="translated">'に続くその他の文字</target>
        </trans-unit>
        <trans-unit id="8b9b2ed191d1fda99979a3c9c2769788ca05c905" translate="yes" xml:space="preserve">
          <source>Any other format character results in an &amp;lsquo;</source>
          <target state="translated">その他のフォーマット文字は 'になります</target>
        </trans-unit>
        <trans-unit id="da32c3cdd65afe4fd7df1698891716e553030ff9" translate="yes" xml:space="preserve">
          <source>Any other keyword arguments are passed directly to the &lt;code&gt;defcustom&lt;/code&gt; generated for the variable &lt;var&gt;mode&lt;/var&gt;.</source>
          <target state="translated">その他のキーワード引数は、変数 &lt;var&gt;mode&lt;/var&gt; 用に生成された &lt;code&gt;defcustom&lt;/code&gt; に直接渡されます。</target>
        </trans-unit>
        <trans-unit id="a9dd7d9e5f6c66323cdba5127ceece8bda299da3" translate="yes" xml:space="preserve">
          <source>Any other kind of property value is a height spec, which translates into a number&amp;mdash;the specified line height. There are several ways to write a height spec; here&amp;rsquo;s how each of them translates into a number:</source>
          <target state="translated">その他の種類のプロパティ値は高さの仕様であり、これは数値、つまり指定された行の高さに変換されます。高さ仕様を作成する方法はいくつかあります。それぞれが数値に変換される方法は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="80c9ec34ade8e4048b77d042cf2894fc4d219cf7" translate="yes" xml:space="preserve">
          <source>Any other list is a &lt;em&gt;sublist specification&lt;/em&gt; and the argument must be a list whose elements match the specification &lt;var&gt;elements&lt;/var&gt;.</source>
          <target state="translated">その他のリストは&lt;em&gt;サブリスト仕様で&lt;/em&gt;あり、引数は、要素が仕様 &lt;var&gt;elements&lt;/var&gt; 一致するリストである必要があります。</target>
        </trans-unit>
        <trans-unit id="efc5f087f8ebb1db404013a2d9b97f161e290782" translate="yes" xml:space="preserve">
          <source>Any other non-&lt;code&gt;nil&lt;/code&gt; value means to resize minibuffer-only frames by calling &lt;code&gt;fit-frame-to-buffer&lt;/code&gt; (see &lt;a href=&quot;resizing-windows#Resizing-Windows&quot;&gt;Resizing Windows&lt;/a&gt;).</source>
          <target state="translated">その他の &lt;code&gt;nil&lt;/code&gt; 以外の値は、 &lt;code&gt;fit-frame-to-buffer&lt;/code&gt; を呼び出してミニバッファーのみのフレームのサイズを変更することを意味します（&lt;a href=&quot;resizing-windows#Resizing-Windows&quot;&gt;Windowsのサイズ変更を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="de1dca44c2e30439c9ac0151a01ef3eee3bfac38" translate="yes" xml:space="preserve">
          <source>Any other non-&lt;code&gt;nil&lt;/code&gt; value means to select a window instantaneously as soon as the mouse pointer enters it.</source>
          <target state="translated">その他の &lt;code&gt;nil&lt;/code&gt; 以外の値は、マウスポインタがウィンドウに入るとすぐにウィンドウを選択することを意味します。</target>
        </trans-unit>
        <trans-unit id="e871933984652498dd2af321ce39af05be929b56" translate="yes" xml:space="preserve">
          <source>Any other symbol in a specification list may be a predicate or an indirect specification.</source>
          <target state="translated">仕様リストの他のシンボルは、述語または間接仕様である場合があります。</target>
        </trans-unit>
        <trans-unit id="dbbabe65f60d7295c7911e33efd55bcf43789dbf" translate="yes" xml:space="preserve">
          <source>Any other value for &lt;var&gt;order&lt;/var&gt; removes the numeric order of &lt;var&gt;element&lt;/var&gt; if it already has one; otherwise, it is equivalent to &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">&lt;var&gt;order&lt;/var&gt; の他の値は、 &lt;var&gt;element&lt;/var&gt; の番号順がすでにある場合は削除します。それ以外の場合は、 &lt;code&gt;nil&lt;/code&gt; と同等です。</target>
        </trans-unit>
        <trans-unit id="8680b4e68cce538925a1e5ee144f0189a305515f" translate="yes" xml:space="preserve">
          <source>Any other value means consider windows on the selected frame.</source>
          <target state="translated">それ以外の値は、選択されたフレームの窓を考慮することを意味します。</target>
        </trans-unit>
        <trans-unit id="15b4bce70cfe3f06b7b1a2f9ed3099030510e5dc" translate="yes" xml:space="preserve">
          <source>Any other value means to try iconifying the child frame. Since such an attempt may not be honored by all window managers and can even lead to making the child frame unresponsive to user actions, the default is to iconify the top level frame instead.</source>
          <target state="translated">それ以外の値を指定すると、子フレームのアイコン化を試みます。このような試みは、すべてのウィンドウマネージャに受け入れられるわけではなく、子フレームがユーザーのアクションに反応しなくなる可能性があるため、デフォルトではトップレベルのフレームをアイコン化することになっています。</target>
        </trans-unit>
        <trans-unit id="ebda99dde61c93e02da1a43ffb05fdba89a8d98e" translate="yes" xml:space="preserve">
          <source>Any other value of &lt;var&gt;require-match&lt;/var&gt; behaves like &lt;code&gt;t&lt;/code&gt;, except that the exit commands won&amp;rsquo;t exit if it performs completion.</source>
          <target state="translated">&lt;var&gt;require-match&lt;/var&gt; の他の値は、終了コマンドが完了を実行しても終了しないことを除いて、 &lt;code&gt;t&lt;/code&gt; のように動作します。</target>
        </trans-unit>
        <trans-unit id="86b521e158439e11f2ef9516804d10581a8219f2" translate="yes" xml:space="preserve">
          <source>Any parameters not mentioned in &lt;var&gt;parameters&lt;/var&gt; default to the values in the alist &lt;code&gt;default-frame-alist&lt;/code&gt; (see &lt;a href=&quot;initial-parameters#Initial-Parameters&quot;&gt;Initial Parameters&lt;/a&gt;); parameters not specified there default from the X resources or its equivalent on your operating system (see &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/X-Resources.html#X-Resources&quot;&gt;X Resources&lt;/a&gt; in</source>
          <target state="translated">記載されていない任意のパラメータ &lt;var&gt;parameters&lt;/var&gt; 連想リスト内の値にデフォルト &lt;code&gt;default-frame-alist&lt;/code&gt; （参照&lt;a href=&quot;initial-parameters#Initial-Parameters&quot;&gt;初期パラメータを&lt;/a&gt;）。パラメータはXのリソースまたはオペレーティングシステム上でそれに相当するから、そこにデフォルト値を指定していない（参照&lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/X-Resources.html#X-Resources&quot;&gt;Xリソース&lt;/a&gt;での</target>
        </trans-unit>
        <trans-unit id="9860f00e606061647e41c129f0e0903be5e003a1" translate="yes" xml:space="preserve">
          <source>Any processes that have this buffer as the &lt;code&gt;process-buffer&lt;/code&gt; are sent the &lt;code&gt;SIGHUP&lt;/code&gt; (hangup) signal, which normally causes them to terminate. See &lt;a href=&quot;signals-to-processes#Signals-to-Processes&quot;&gt;Signals to Processes&lt;/a&gt;.</source>
          <target state="translated">このバッファーを &lt;code&gt;process-buffer&lt;/code&gt; バッファーとして持つプロセスには、 &lt;code&gt;SIGHUP&lt;/code&gt; （ハングアップ）シグナルが送信されます。これにより、通常はプロセスが終了します。&lt;a href=&quot;signals-to-processes#Signals-to-Processes&quot;&gt;プロセスへのシグナルを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="545802d960c72afb533f784369e021b83a96956f" translate="yes" xml:space="preserve">
          <source>Any redisplay triggering the run of window change functions may be aborted. If the abort occurs before window change functions have run to their completion, they will be run again with the previous values, that is, as if redisplay had not been performed. If aborted later, they will be run with the new values, that is, as if redisplay had been actually performed.</source>
          <target state="translated">ウィンドウ変更関数の実行をトリガーとする再表示は、すべて中止されることがあります。ウィンドウ変更関数の実行が完了する前にアボートが発生した場合、それらは以前の値で、つまり、再表示が実行されなかったかのように、再び実行されます。後にアボートされた場合は、新しい値で実行され、つまり、再表示が実際に行われたかのように実行されます。</target>
        </trans-unit>
        <trans-unit id="7024b793b36bc3e3bb195637c26938af29b056cc" translate="yes" xml:space="preserve">
          <source>Any two distinct Lisp objects are different as keys.</source>
          <target state="translated">2つの異なるLispオブジェクトはキーとして異なります。</target>
        </trans-unit>
        <trans-unit id="2402827e518f1d5fcdc03543bf7c6c4f8b5d7ef6" translate="yes" xml:space="preserve">
          <source>Any two regular expressions &lt;var&gt;a&lt;/var&gt; and &lt;var&gt;b&lt;/var&gt; can be concatenated. The result is a regular expression that matches a string if &lt;var&gt;a&lt;/var&gt; matches some amount of the beginning of that string and &lt;var&gt;b&lt;/var&gt; matches the rest of the string.</source>
          <target state="translated">任意の2つの正規表現 &lt;var&gt;a&lt;/var&gt; と &lt;var&gt;b&lt;/var&gt; を連結できます。結果は、 &lt;var&gt;b&lt;/var&gt; がその文字列の先頭のある量に一致し、bが文字列の残りの部分に一致する場合に &lt;var&gt;a&lt;/var&gt; その文字列に一致する正規表現です。</target>
        </trans-unit>
        <trans-unit id="45ffc4ae2f26e287178694c6132c38fe72023bb0" translate="yes" xml:space="preserve">
          <source>Any unhandled errors while loading a file terminate loading. If the load was done for the sake of &lt;code&gt;autoload&lt;/code&gt;, any function definitions made during the loading are undone.</source>
          <target state="translated">ファイルのロード中に未処理のエラーが発生すると、ロードが終了します。 &lt;code&gt;autoload&lt;/code&gt; ためにロードが行われた場合、ロード中に行われた関数定義はすべて取り消されます。</target>
        </trans-unit>
        <trans-unit id="1ceb1e23a710f2ab6b34678613c9db79937409cd" translate="yes" xml:space="preserve">
          <source>Any variable whose name has a non-&lt;code&gt;nil&lt;/code&gt;&lt;code&gt;risky-local-variable&lt;/code&gt; property is considered risky. When you define a user option using &lt;code&gt;defcustom&lt;/code&gt;, you can set its &lt;code&gt;risky-local-variable&lt;/code&gt; property by adding the arguments &lt;code&gt;:risky &lt;var&gt;value&lt;/var&gt;&lt;/code&gt; to &lt;code&gt;defcustom&lt;/code&gt; (see &lt;a href=&quot;variable-definitions#Variable-Definitions&quot;&gt;Variable Definitions&lt;/a&gt;). In addition, any variable whose name ends in any of &amp;lsquo;</source>
          <target state="translated">名前に &lt;code&gt;nil&lt;/code&gt; 以外の &lt;code&gt;risky-local-variable&lt;/code&gt; プロパティがある変数は、リスクがあると見なされます。 &lt;code&gt;defcustom&lt;/code&gt; を使用してユーザーオプションを定義する場合、引数 &lt;code&gt;:risky &lt;var&gt;value&lt;/var&gt;&lt;/code&gt; &lt;var&gt;value&lt;/var&gt; を &lt;code&gt;defcustom&lt;/code&gt; に追加することでその &lt;code&gt;risky-local-variable&lt;/code&gt; プロパティを設定できます（&lt;a href=&quot;variable-definitions#Variable-Definitions&quot;&gt;変数の定義を&lt;/a&gt;参照）。さらに、名前が 'のいずれかで終わる変数</target>
        </trans-unit>
        <trans-unit id="2146f7db0997563acb7fa242e2c3506c43699f4a" translate="yes" xml:space="preserve">
          <source>Anything else means to consider windows on &lt;var&gt;window&lt;/var&gt;&amp;rsquo;s frame, and no others.</source>
          <target state="translated">それ以外は、 &lt;var&gt;window&lt;/var&gt; のフレーム上のウィンドウを考慮することを意味し、他のウィンドウは考慮しません。</target>
        </trans-unit>
        <trans-unit id="ed179d7c24b9f78db2acddd1c26cf5d5e3a10309" translate="yes" xml:space="preserve">
          <source>Apart from Fundamental mode, there are three major modes that other major modes commonly derive from: Text mode, Prog mode, and Special mode. While Text mode is useful in its own right (e.g., for editing files ending in</source>
          <target state="translated">ファンダメンタルモードの他に、他の主要なモードが共通して派生する3つの主要なモードがあります:テキストモード、プログモード、スペシャルモードです。テキストモードはそれ自体が便利なモードですが(例えば</target>
        </trans-unit>
        <trans-unit id="d92f266ff96117cb3b55d3ff2938ee734d58418c" translate="yes" xml:space="preserve">
          <source>Apart from the above usual keymaps, Emacs provides special ways for programs to make other keymaps active. Firstly, the variable &lt;code&gt;overriding-local-map&lt;/code&gt; specifies a keymap that replaces the usual active keymaps, except for the global keymap. Secondly, the terminal-local variable &lt;code&gt;overriding-terminal-local-map&lt;/code&gt; specifies a keymap that takes precedence over &lt;em&gt;all&lt;/em&gt; other keymaps (including &lt;code&gt;overriding-local-map&lt;/code&gt;); this is normally used for modal/transient keybindings (the function &lt;code&gt;set-transient-map&lt;/code&gt; provides a convenient interface for this). See &lt;a href=&quot;controlling-active-maps#Controlling-Active-Maps&quot;&gt;Controlling Active Maps&lt;/a&gt;, for details.</source>
          <target state="translated">上記の通常のキーマップとは別に、Emacsはプログラムが他のキーマップをアクティブにするための特別な方法を提供します。まず、変数overriding &lt;code&gt;overriding-local-map&lt;/code&gt; は、グローバルキーマップを除いて、通常のアクティブなキーマップを置き換えるキーマップを指定します。次に、terminal-local変数overriding &lt;code&gt;overriding-terminal-local-map&lt;/code&gt; は、他の&lt;em&gt;すべて&lt;/em&gt;のキーマップ（overriding &lt;code&gt;overriding-local-map&lt;/code&gt; を含む）よりも優先されるキーマップを指定します。これは通常、モーダル/トランジェントキーバインディングに使用されます（関数 &lt;code&gt;set-transient-map&lt;/code&gt; は、このための便利なインターフェイスを提供します）。詳細については、&lt;a href=&quot;controlling-active-maps#Controlling-Active-Maps&quot;&gt;アクティブマップの制御&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="a68119502a0311abd68d0719c5b77a5911c9e84f" translate="yes" xml:space="preserve">
          <source>Apart from the functions documented in this section, you can print Lisp objects to the echo area by specifying &lt;code&gt;t&lt;/code&gt; as the output stream. See &lt;a href=&quot;output-streams#Output-Streams&quot;&gt;Output Streams&lt;/a&gt;.</source>
          <target state="translated">このセクションで説明されている関数とは別に、出力ストリームとして &lt;code&gt;t&lt;/code&gt; を指定することにより、Lispオブジェクトをエコー領域に出力できます。&lt;a href=&quot;output-streams#Output-Streams&quot;&gt;出力ストリームを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="1cd2802aef7e489fd6909738c550b3b9f5ec028d" translate="yes" xml:space="preserve">
          <source>Apart from the values given below, each face attribute can have the value &lt;code&gt;unspecified&lt;/code&gt;. This special value means that the face doesn&amp;rsquo;t specify that attribute directly. An &lt;code&gt;unspecified&lt;/code&gt; attribute tells Emacs to refer instead to a parent face (see the description &lt;code&gt;:inherit&lt;/code&gt; attribute below); or, failing that, to an underlying face (see &lt;a href=&quot;displaying-faces#Displaying-Faces&quot;&gt;Displaying Faces&lt;/a&gt;). The &lt;code&gt;default&lt;/code&gt; face must specify all attributes.</source>
          <target state="translated">以下に示す値とは別に、各face属性の値は &lt;code&gt;unspecified&lt;/code&gt; ていません。この特別な値は、顔がその属性を直接指定しないことを意味します。 &lt;code&gt;unspecified&lt;/code&gt; 属性は、親の顔（説明を参照する代わりに参照するようにEmacsに指示 &lt;code&gt;:inherit&lt;/code&gt; 以下の属性）。または、それが失敗した場合は、下にある面に移動します（面の&lt;a href=&quot;displaying-faces#Displaying-Faces&quot;&gt;表示を&lt;/a&gt;参照）。 &lt;code&gt;default&lt;/code&gt; 顔は、すべての属性を指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="f240948e5698f084e306e2f0433d5215c7e9dc03" translate="yes" xml:space="preserve">
          <source>Append &lt;var&gt;child&lt;/var&gt; as the last child of &lt;var&gt;node&lt;/var&gt;.</source>
          <target state="translated">&lt;var&gt;node&lt;/var&gt; の最後の &lt;var&gt;child&lt;/var&gt; として子を追加します。</target>
        </trans-unit>
        <trans-unit id="73973cfd168d40bb8277e2f6044ecdb605409c4e" translate="yes" xml:space="preserve">
          <source>Appendices</source>
          <target state="translated">Appendices</target>
        </trans-unit>
        <trans-unit id="6453a2437bbdcb5f8fffb150dbc05d248106b629" translate="yes" xml:space="preserve">
          <source>Applications should put a function on this hook only if they want to react to changes that happened on (or have been signaled for) two or more frames since last redisplay. In every other case, putting the function on &lt;code&gt;window-state-change-functions&lt;/code&gt; should be preferred.</source>
          <target state="translated">アプリケーションは、最後の再表示以降に2つ以上のフレームで発生した（または通知された）変更に対応する場合にのみ、このフックに関数を配置する必要があります。それ以外の場合はすべて、関数を &lt;code&gt;window-state-change-functions&lt;/code&gt; に配置することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="26de2593285b5ae9fccf013cfbb25224e0f5a299" translate="yes" xml:space="preserve">
          <source>Applying Customizations</source>
          <target state="translated">カスタマイズの適用</target>
        </trans-unit>
        <trans-unit id="36aa9251a3a7a8564f2137c662428024f6ade2c8" translate="yes" xml:space="preserve">
          <source>Applying a function to each element of a list, etc.</source>
          <target state="translated">リストの各要素に関数を適用するなど</target>
        </trans-unit>
        <trans-unit id="8d1feffaedb79bbeb47768ea8d15131f798d1c88" translate="yes" xml:space="preserve">
          <source>Arbitrary text, read in the minibuffer and returned as a string (see &lt;a href=&quot;text-from-minibuffer#Text-from-Minibuffer&quot;&gt;Text from Minibuffer&lt;/a&gt;). Terminate the input with either</source>
          <target state="translated">ミニ&lt;a href=&quot;text-from-minibuffer#Text-from-Minibuffer&quot;&gt;バッファーで読み取ら&lt;/a&gt;れ、文字列として返される任意のテキスト（ミニバッファーからのテキストを参照）。いずれかで入力を終了します</target>
        </trans-unit>
        <trans-unit id="7d9f86d28b0c0c91c1eb18ed796eb1ba12533f22" translate="yes" xml:space="preserve">
          <source>Arbitrary text, read in the minibuffer using the current buffer&amp;rsquo;s input method, and returned as a string (see &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Input-Methods.html#Input-Methods&quot;&gt;Input Methods&lt;/a&gt; in</source>
          <target state="translated">任意のテキスト。現在のバッファの入力メソッドを使用してミニバッファに読み込まれ、文字列として返されます（の&lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Input-Methods.html#Input-Methods&quot;&gt;入力メソッド&lt;/a&gt;を参照）。</target>
        </trans-unit>
        <trans-unit id="bd4951fd6a7c3feab0f23a3cd32635bc99258318" translate="yes" xml:space="preserve">
          <source>Args out of range</source>
          <target state="translated">射程外のアルグ</target>
        </trans-unit>
        <trans-unit id="0c474d136d838c73efef53606031eb17d140e04e" translate="yes" xml:space="preserve">
          <source>Arguments to &lt;code&gt;literal&lt;/code&gt; and &lt;code&gt;regexp&lt;/code&gt; forms in &lt;var&gt;rx-expr&lt;/var&gt; must be string literals.</source>
          <target state="translated">&lt;var&gt;rx-expr&lt;/var&gt; の &lt;code&gt;literal&lt;/code&gt; および &lt;code&gt;regexp&lt;/code&gt; 形式への引数は文字列リテラルである必要があります。</target>
        </trans-unit>
        <trans-unit id="067d717a61de8fed36456114a24a52f9975bc09e" translate="yes" xml:space="preserve">
          <source>Arithmetic Operations</source>
          <target state="translated">算術演算</target>
        </trans-unit>
        <trans-unit id="e9ba134322b748a6c1b2b91140e83920bb3352f8" translate="yes" xml:space="preserve">
          <source>Arithmetic error</source>
          <target state="translated">算術エラー</target>
        </trans-unit>
        <trans-unit id="11d55c8ac9f9031983e49487cf4e01cc836699f5" translate="yes" xml:space="preserve">
          <source>Arithmetic overflow error</source>
          <target state="translated">算術オーバーフローエラー</target>
        </trans-unit>
        <trans-unit id="d11aaaa37e2311485d3875fbb3013fe0f23d4b0b" translate="yes" xml:space="preserve">
          <source>Around advice such as:</source>
          <target state="translated">などのアドバイス周り。</target>
        </trans-unit>
        <trans-unit id="41fcc6cba3496dc0275b2af2eceda84dfb41da3d" translate="yes" xml:space="preserve">
          <source>Arrange to scan these files when producing the</source>
          <target state="translated">を作成する際に、これらのファイルをスキャンするように手配します。</target>
        </trans-unit>
        <trans-unit id="5a208284047f94a448814865ab5ceb940cbbaf32" translate="yes" xml:space="preserve">
          <source>Arranging to run a cleanup form if an error happens.</source>
          <target state="translated">エラーが発生した場合にクリーンアップフォームを実行するようにアレンジ。</target>
        </trans-unit>
        <trans-unit id="238a5476b2b099dbf0d0f2fd0cf448d18972ec8a" translate="yes" xml:space="preserve">
          <source>Array Type</source>
          <target state="translated">配列型</target>
        </trans-unit>
        <trans-unit id="73e54889ed8e57216f0ca1581847b9782331ae4c" translate="yes" xml:space="preserve">
          <source>Array, a fixed-size set of Lisp objects which may be accessed by an index.</source>
          <target state="translated">配列、固定サイズのLispオブジェクトの集合で、インデックスによってアクセスすることができます。</target>
        </trans-unit>
        <trans-unit id="b90cc9bfd23567a2ff5ba1f00e7c63ca6da8755e" translate="yes" xml:space="preserve">
          <source>Arrays</source>
          <target state="translated">Arrays</target>
        </trans-unit>
        <trans-unit id="081ca36507218ed52666e78775654403a5cbd1aa" translate="yes" xml:space="preserve">
          <source>Arrays are fixed-length sequences. They are further subdivided into strings, vectors, char-tables and bool-vectors. Vectors can hold elements of any type, whereas string elements must be characters, and bool-vector elements must be &lt;code&gt;t&lt;/code&gt; or &lt;code&gt;nil&lt;/code&gt;. Char-tables are like vectors except that they are indexed by any valid character code. The characters in a string can have text properties like characters in a buffer (see &lt;a href=&quot;text-properties#Text-Properties&quot;&gt;Text Properties&lt;/a&gt;), but vectors do not support text properties, even when their elements happen to be characters.</source>
          <target state="translated">配列は固定長のシーケンスです。それらはさらに文字列、ベクトル、char-tablesおよびbool-vectorsに細分されます。ベクトルは任意のタイプの要素を保持できますが、文字列要素は文字である必要があり、bool-vector要素は &lt;code&gt;t&lt;/code&gt; または &lt;code&gt;nil&lt;/code&gt; である必要があります。文字テーブルは、有効な文字コードでインデックスが付けられることを除けば、ベクトルに似ています。文字列内の文字は、バッファ内の文字のようなテキストプロパティを持つことができますが（&lt;a href=&quot;text-properties#Text-Properties&quot;&gt;テキストプロパティを&lt;/a&gt;参照）、ベクトルは、要素が文字である場合でも、テキストプロパティをサポートしていません。</target>
        </trans-unit>
        <trans-unit id="ce9ceca356ae903e8b84ce8876d693efd3ec5212" translate="yes" xml:space="preserve">
          <source>Arrays include strings and vectors.</source>
          <target state="translated">配列には文字列とベクターがあります。</target>
        </trans-unit>
        <trans-unit id="2a256f62beeee99618180946ede4c7802661b91b" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;lsh&lt;/code&gt; behaves like &lt;code&gt;ash&lt;/code&gt; except when &lt;var&gt;integer1&lt;/var&gt; and &lt;var&gt;count1&lt;/var&gt; are both negative, the following examples focus on these exceptional cases. These examples assume 30-bit fixnums.</source>
          <target state="translated">&lt;code&gt;lsh&lt;/code&gt; のように振る舞う &lt;code&gt;ash&lt;/code&gt; 場合を除き、 &lt;var&gt;integer1&lt;/var&gt; と &lt;var&gt;count1&lt;/var&gt; 両方とも否定され、以下の例は、これらの例外的なケースに焦点を当てます。これらの例は、30ビットのfixnumを想定しています。</target>
        </trans-unit>
        <trans-unit id="85514a867e7a20560268b28853e86e5aa494f0b6" translate="yes" xml:space="preserve">
          <source>As a &amp;lsquo;</source>
          <target state="translated">として '</target>
        </trans-unit>
        <trans-unit id="06830ace04b31c9ec49e44f925889f374b949f5a" translate="yes" xml:space="preserve">
          <source>As a final step, before returning the chosen coding system, &lt;code&gt;select-safe-coding-system&lt;/code&gt; checks whether that coding system is consistent with what would be selected if the contents of the region were read from a file. (If not, this could lead to data corruption in a file subsequently re-visited and edited.) Normally, &lt;code&gt;select-safe-coding-system&lt;/code&gt; uses &lt;code&gt;buffer-file-name&lt;/code&gt; as the file for this purpose, but if &lt;var&gt;file&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, it uses that file instead (this can be relevant for &lt;code&gt;write-region&lt;/code&gt; and similar functions). If it detects an apparent inconsistency, &lt;code&gt;select-safe-coding-system&lt;/code&gt; queries the user before selecting the coding system.</source>
          <target state="translated">最後のステップとして、選択したコーディングシステムを返す前に、 &lt;code&gt;select-safe-coding-system&lt;/code&gt; は、そのコーディングシステムが、領域の内容がファイルから読み取られた場合に選択されるものと一致しているかどうかを確認します。 （そうでない場合、これは後で再訪問および編集されたファイルのデータ破損につながる可能性があります。）通常、 &lt;code&gt;select-safe-coding-system&lt;/code&gt; はこの目的でファイルとして &lt;code&gt;buffer-file-name&lt;/code&gt; を使用しますが、 &lt;var&gt;file&lt;/var&gt; が &lt;code&gt;nil&lt;/code&gt; 以外の場合、代わりにそのファイルを使用します（これは &lt;code&gt;write-region&lt;/code&gt; および同様の機能に関連する可能性があります）。明らかな不整合を検出した場合、 &lt;code&gt;select-safe-coding-system&lt;/code&gt; は、コーディングシステムを選択する前にユーザーにクエリを実行します。</target>
        </trans-unit>
        <trans-unit id="8347ee4e8693c87255357e7f5883850b386cce75" translate="yes" xml:space="preserve">
          <source>As a general recommendation, try to avoid using &lt;code&gt;looking-back&lt;/code&gt; wherever possible, since it is slow. For this reason, there are no plans to add a &lt;code&gt;looking-back-p&lt;/code&gt; function.</source>
          <target state="translated">一般的な推奨事項として、 &lt;code&gt;looking-back&lt;/code&gt; は遅いため、可能な限り使用しないようにしてください。このため、 &lt;code&gt;looking-back-p&lt;/code&gt; 関数を追加する予定はありません。</target>
        </trans-unit>
        <trans-unit id="082ed7d43ef6ed77537415a322f89e49796457df" translate="yes" xml:space="preserve">
          <source>As a historical accident, &lt;var&gt;position&lt;/var&gt; was implemented inconsistently in different functions. In &lt;code&gt;completing-read&lt;/code&gt;, &lt;var&gt;position&lt;/var&gt;&amp;rsquo;s value is interpreted as origin-zero; that is, a value of 0 means the beginning of the string, 1 means after the first character, etc. In &lt;code&gt;read-minibuffer&lt;/code&gt;, and the other non-completion minibuffer input functions that support this argument, 1 means the beginning of the string, 2 means after the first character, etc.</source>
          <target state="translated">歴史的な事故として、 &lt;var&gt;position&lt;/var&gt; はさまざまな機能で一貫して実装されていませんでした。で &lt;code&gt;completing-read&lt;/code&gt; 、 &lt;var&gt;position&lt;/var&gt; の値は、原点ゼロとして解釈されます。つまり、値0は文字列の先頭を意味し、1は最初の文字の後などを意味し &lt;code&gt;read-minibuffer&lt;/code&gt; 、およびこの引数をサポートするその他の非完了ミニバッファ入力関数では、1は文字列の先頭を意味します。 2は最初の文字の後などを意味します。</target>
        </trans-unit>
        <trans-unit id="4294650896b83fd9e5d4be93d12e4c592d4f0ccc" translate="yes" xml:space="preserve">
          <source>As a practical matter, if you are writing text for other people to read, you should set &lt;code&gt;fill-column&lt;/code&gt; to no more than 70. Otherwise the line will be too long for people to read comfortably, and this can make the text seem clumsy.</source>
          <target state="translated">実際問題として、他の人が読めるようにテキストを書いている場合は、 &lt;code&gt;fill-column&lt;/code&gt; を70以下に設定する必要があります。そうしないと、行が長すぎて他の人が快適に読めなくなり、テキストが不器用に見える可能性があります。</target>
        </trans-unit>
        <trans-unit id="bb4aaf8789bdd2420621e991adcf2190aa28b7df" translate="yes" xml:space="preserve">
          <source>As a result, it is currently not possible to represent the character</source>
          <target state="translated">その結果、現在のところ、キャラクターの</target>
        </trans-unit>
        <trans-unit id="b5eb1265a3a71f4ed8bb8ff9aa6033bf57cae934" translate="yes" xml:space="preserve">
          <source>As a rule, the inner frame is subdivided into the frame&amp;rsquo;s root window (see &lt;a href=&quot;windows-and-frames#Windows-and-Frames&quot;&gt;Windows and Frames&lt;/a&gt;) and the frame&amp;rsquo;s minibuffer window (see &lt;a href=&quot;minibuffer-windows#Minibuffer-Windows&quot;&gt;Minibuffer Windows&lt;/a&gt;). There are two notable exceptions to this rule: A &lt;em&gt;minibuffer-less frame&lt;/em&gt; contains a root window only and does not contain a minibuffer window. A &lt;em&gt;minibuffer-only frame&lt;/em&gt; contains only a minibuffer window which also serves as that frame&amp;rsquo;s root window. See &lt;a href=&quot;initial-parameters#Initial-Parameters&quot;&gt;Initial Parameters&lt;/a&gt; for how to create such frame configurations.</source>
          <target state="translated">原則として、内部フレームはフレームのルートウィンドウ（ウィンドウ&lt;a href=&quot;windows-and-frames#Windows-and-Frames&quot;&gt;とフレームを&lt;/a&gt;参照）とフレームのミニバッファウィンドウ（ミニバッファウィンドウを参照）に&lt;a href=&quot;minibuffer-windows#Minibuffer-Windows&quot;&gt;分割されます&lt;/a&gt;。このルールには、2つの注目すべき例外があります。&lt;em&gt;ミニバッファのないフレーム&lt;/em&gt;にはルートウィンドウのみが含まれ、ミニバッファウィンドウは含まれません。&lt;em&gt;ミニバッファ専用フレームは&lt;/em&gt;また、そのフレームのルートウィンドウとして機能するだけミニバッファ・ウィンドウを含んでいます。このようなフレーム構成を作成する方法については、&lt;a href=&quot;initial-parameters#Initial-Parameters&quot;&gt;初期パラメーター&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="7658703b932157d4e051dbdce1277e8475ac36f2" translate="yes" xml:space="preserve">
          <source>As a side effect, backups are necessarily made by copying. See &lt;a href=&quot;rename-or-copy#Rename-or-Copy&quot;&gt;Rename or Copy&lt;/a&gt;. Yet, at the same time, saving a precious file always breaks all hard links between the file you save and other file names.</source>
          <target state="translated">副作用として、バックアップは必然的にコピーによって行われます。&lt;a href=&quot;rename-or-copy#Rename-or-Copy&quot;&gt;名前の変更またはコピーを&lt;/a&gt;参照してください。ただし、同時に、貴重なファイルを保存すると、保存したファイルと他のファイル名の間のすべてのハードリンクが常に切断されます。</target>
        </trans-unit>
        <trans-unit id="c897a9ef1100434cc7715e3fbb47fdb7454824de" translate="yes" xml:space="preserve">
          <source>As a simple example, we can concatenate the regular expressions &amp;lsquo;</source>
          <target state="translated">簡単な例として、正規表現を連結できます。</target>
        </trans-unit>
        <trans-unit id="bc0e4551b2a377b6cea04f402200bc2b67248275" translate="yes" xml:space="preserve">
          <source>As a special case, &lt;code&gt;next&lt;/code&gt; of a frame&amp;rsquo;s root window points to the frame&amp;rsquo;s minibuffer window, provided this is not a minibuffer-only or minibuffer-less frame. On such frames &lt;code&gt;prev&lt;/code&gt; of the minibuffer window points to that frame&amp;rsquo;s root window. In any other case, the root window&amp;rsquo;s &lt;code&gt;next&lt;/code&gt; and the minibuffer window&amp;rsquo;s (if present) &lt;code&gt;prev&lt;/code&gt; fields are &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">特別な場合として、フレームのルートウィンドウの &lt;code&gt;next&lt;/code&gt; は、フレームのミニバッファウィンドウを指します。ただし、これがミニバッファのみまたはミニバッファなしのフレームでない場合に限ります。そのようなフレームでは、ミニバッファウィンドウの &lt;code&gt;prev&lt;/code&gt; はそのフレームのルートウィンドウを指します。それ以外の場合、ルートウィンドウの &lt;code&gt;next&lt;/code&gt; フィールドとミニバッファウィンドウの（存在する場合） &lt;code&gt;prev&lt;/code&gt; フィールドは &lt;code&gt;nil&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="640b1e7193c0828a7e9c0e26231c2f3a2ad3a5f4" translate="yes" xml:space="preserve">
          <source>As a special case, a function may return with a different buffer current. Emacs takes this to mean that the current buffer contains altered text to be output. It therefore changes the &lt;var&gt;start&lt;/var&gt; and &lt;var&gt;end&lt;/var&gt; arguments of the &lt;code&gt;write-region&lt;/code&gt; call, giving them the values of &lt;code&gt;point-min&lt;/code&gt; and &lt;code&gt;point-max&lt;/code&gt; in the new buffer, respectively. It also discards all previous annotations, because they should have been dealt with by this function.</source>
          <target state="translated">特別な場合として、関数は異なるバッファ電流で戻る場合があります。Emacsはこれを、現在のバッファーに出力される変更されたテキストが含まれていることを意味すると解釈します。したがって、 &lt;code&gt;write-region&lt;/code&gt; 呼び出しの &lt;var&gt;start&lt;/var&gt; 引数と &lt;var&gt;end&lt;/var&gt; 引数を変更し、新しいバッファーの &lt;code&gt;point-min&lt;/code&gt; と &lt;code&gt;point-max&lt;/code&gt; の値をそれぞれ与えます。また、以前の注釈はすべてこの関数で処理されるはずだったため、破棄されます。</target>
        </trans-unit>
        <trans-unit id="538f59aab9497ba8d48e55c2e55b2635fbda077a" translate="yes" xml:space="preserve">
          <source>As a special case, if &lt;var&gt;cons-cell&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, this function returns &lt;code&gt;nil&lt;/code&gt;. Therefore, any list is a valid argument. An error is signaled if the argument is not a cons cell or &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">特別な場合として、 &lt;var&gt;cons-cell&lt;/var&gt; が &lt;code&gt;nil&lt;/code&gt; の場合、この関数は &lt;code&gt;nil&lt;/code&gt; を返します。したがって、どのリストも有効な引数です。引数がconsセルまたは &lt;code&gt;nil&lt;/code&gt; でない場合、エラーが通知されます。</target>
        </trans-unit>
        <trans-unit id="9e59f0605f808bdde6a150c85073aac9e660ad27" translate="yes" xml:space="preserve">
          <source>As a special case, if &lt;var&gt;cons-cell&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, this function returns &lt;code&gt;nil&lt;/code&gt;; therefore, any list is a valid argument. An error is signaled if the argument is not a cons cell or &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">特別な場合として、 &lt;var&gt;cons-cell&lt;/var&gt; が &lt;code&gt;nil&lt;/code&gt; の場合、この関数は &lt;code&gt;nil&lt;/code&gt; を返します。したがって、どのリストも有効な引数です。引数がconsセルまたは &lt;code&gt;nil&lt;/code&gt; でない場合、エラーが通知されます。</target>
        </trans-unit>
        <trans-unit id="ca7cece4ddf32f2b45c2031fd9e867d6b7889049" translate="yes" xml:space="preserve">
          <source>As a special case, if &lt;var&gt;flag&lt;/var&gt; is &lt;code&gt;t&lt;/code&gt;, &lt;var&gt;window&lt;/var&gt; becomes &lt;em&gt;strongly&lt;/em&gt; dedicated to its buffer. &lt;code&gt;set-window-buffer&lt;/code&gt; signals an error when the window it acts upon is strongly dedicated to its buffer and does not already display the buffer it is asked to display. Other functions do not treat &lt;code&gt;t&lt;/code&gt; differently from any non-&lt;code&gt;nil&lt;/code&gt; value.</source>
          <target state="translated">場合特殊なケースとして、 &lt;var&gt;flag&lt;/var&gt; ある &lt;code&gt;t&lt;/code&gt; 、 &lt;var&gt;window&lt;/var&gt; なり&lt;em&gt;強く&lt;/em&gt;、そのバッファに専用。 &lt;code&gt;set-window-buffer&lt;/code&gt; は、作用するウィンドウがそのバッファー専用であり、表示を要求されたバッファーをまだ表示していない場合にエラーを通知します。他の関数は、 &lt;code&gt;t&lt;/code&gt; を &lt;code&gt;nil&lt;/code&gt; 以外の値と同じように扱います。</target>
        </trans-unit>
        <trans-unit id="4aced0063585f5b279a49199acec884cc3288ce9" translate="yes" xml:space="preserve">
          <source>As a special exception, the error symbol &lt;code&gt;quit&lt;/code&gt; does not have the condition &lt;code&gt;error&lt;/code&gt;, because quitting is not considered an error.</source>
          <target state="translated">特別な例外として、 &lt;code&gt;quit&lt;/code&gt; は &lt;code&gt;error&lt;/code&gt; とは見なされないため、エラーシンボルquitには条件エラーはありません。</target>
        </trans-unit>
        <trans-unit id="07d6ca82a5135dea4c0b8a8393dd8ef483c67bf7" translate="yes" xml:space="preserve">
          <source>As a technical detail, when &lt;var&gt;switches&lt;/var&gt; contains the long &amp;lsquo;</source>
          <target state="translated">技術的な詳細として、 &lt;var&gt;switches&lt;/var&gt; に長い 'が含まれている場合</target>
        </trans-unit>
        <trans-unit id="8f4f9b3b2bfdbcd1a575981570d572a49858acde" translate="yes" xml:space="preserve">
          <source>As a trivial example, here&amp;rsquo;s how to add advice that&amp;rsquo;ll modify the return value of a function every time it&amp;rsquo;s called:</source>
          <target state="translated">簡単な例として、関数が呼び出されるたびに関数の戻り値を変更するアドバイスを追加する方法を次に示します。</target>
        </trans-unit>
        <trans-unit id="b1f3d0120b8c51d503e5e5327b8ce35d598fd0fd" translate="yes" xml:space="preserve">
          <source>As always, there must be no possibility of intervening searches between the call to a search function and the call to &lt;code&gt;match-data&lt;/code&gt; that is intended to access the match data for that search.</source>
          <target state="translated">いつものように、するために検索機能の呼び出しと呼び出しの間で検索を介在の可能性があってはならない &lt;code&gt;match-data&lt;/code&gt; その検索に一致するデータにアクセスすることを目的としています。</target>
        </trans-unit>
        <trans-unit id="1472e06e8a8fc0331e8821e03360d8c11b163707" translate="yes" xml:space="preserve">
          <source>As an alternative to the string-based syntax, Emacs provides the structured &lt;code&gt;rx&lt;/code&gt; notation based on Lisp S-expressions. This notation is usually easier to read, write and maintain than regexp strings, and can be indented and commented freely. It requires a conversion into string form since that is what regexp functions expect, but that conversion typically takes place during byte-compilation rather than when the Lisp code using the regexp is run.</source>
          <target state="translated">文字列ベースの構文の代わりに、Emacsは &lt;code&gt;rx&lt;/code&gt; 式に基づく構造化されたrx表記を提供します。この表記は通常、正規表現文字列よりも読み取り、書き込み、および保守が簡単であり、自由にインデントおよびコメント化できます。正規表現関数が期待するので文字列形式への変換が必要ですが、その変換は通常、正規表現を使用するLispコードが実行されるときではなく、バイトコンパイル中に行われます。</target>
        </trans-unit>
        <trans-unit id="95b6d5f91746264f4dd9c82e53bfbbe800efcb96" translate="yes" xml:space="preserve">
          <source>As an example of &lt;code&gt;sort-subr&lt;/code&gt;, here is the complete function definition for &lt;code&gt;sort-lines&lt;/code&gt;:</source>
          <target state="translated">例として &lt;code&gt;sort-subr&lt;/code&gt; 、ここのための完全な関数定義で &lt;code&gt;sort-lines&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="39d7c3afd50025e1aeeb3300312260fc1e12eaba" translate="yes" xml:space="preserve">
          <source>As an example, here is a sequence of &lt;code&gt;split-window&lt;/code&gt; calls that yields the window configuration discussed in &lt;a href=&quot;windows-and-frames#Windows-and-Frames&quot;&gt;Windows and Frames&lt;/a&gt;. This example demonstrates splitting a live window as well as splitting an internal window. We begin with a frame containing a single window (a live root window), which we denote by &lt;var&gt;W4&lt;/var&gt;. Calling &lt;code&gt;(split-window W4)&lt;/code&gt; yields this window configuration:</source>
          <target state="translated">例として、&lt;a href=&quot;windows-and-frames#Windows-and-Frames&quot;&gt;Windowsとフレームで&lt;/a&gt;説明されているウィンドウ構成を生成する一連の &lt;code&gt;split-window&lt;/code&gt; 呼び出しを次に示します。この例は、ライブウィンドウの分割と内部ウィンドウの分割を示しています。まず、単一のウィンドウ（ライブルートウィンドウ）を含むフレームから始めます。これを &lt;var&gt;W4&lt;/var&gt; で示します。 &lt;code&gt;(split-window W4)&lt;/code&gt; を呼び出すと、次のウィンドウ構成が生成されます。</target>
        </trans-unit>
        <trans-unit id="3000460ba524b76305a7ac5b84a2be2cc384cf2b" translate="yes" xml:space="preserve">
          <source>As an example, here&amp;rsquo;s a simplified (and inefficient) version of the primitive function &lt;code&gt;next-single-char-property-change&lt;/code&gt; (see &lt;a href=&quot;property-search#Property-Search&quot;&gt;Property Search&lt;/a&gt;). It searches forward from position &lt;var&gt;pos&lt;/var&gt; for the next position where the value of a given property &lt;code&gt;prop&lt;/code&gt;, as obtained from either overlays or text properties, changes.</source>
          <target state="translated">例として、プリミティブ関数 &lt;code&gt;next-single-char-property-change&lt;/code&gt; の簡略化された（非効率的な）バージョンを次に示します（&lt;a href=&quot;property-search#Property-Search&quot;&gt;プロパティ検索を&lt;/a&gt;参照）。オーバーレイまたはテキストプロパティのいずれかから取得された特定のプロパティ &lt;code&gt;prop&lt;/code&gt; の値が変更される次の位置を、位置 &lt;var&gt;pos&lt;/var&gt; から前方に検索します。</target>
        </trans-unit>
        <trans-unit id="ac2005a3b3b773dfac881bf44c6dc9ffab49bfce" translate="yes" xml:space="preserve">
          <source>As an exception to the rule that a symbol&amp;rsquo;s name serves as its printed representation, &amp;lsquo;</source>
          <target state="translated">シンボルの名前がその印刷された表現として機能するという規則の例外として、 '</target>
        </trans-unit>
        <trans-unit id="2daa82fa454d2ab6dd7bfac54a9eefb51ae6ff85" translate="yes" xml:space="preserve">
          <source>As an exception, if you evaluate a &lt;code&gt;defface&lt;/code&gt; form with</source>
          <target state="translated">例外として、 &lt;code&gt;defface&lt;/code&gt; フォームを次のように評価する場合</target>
        </trans-unit>
        <trans-unit id="1a2d268c77084e31235d0ca81e4bd6ebfe990b03" translate="yes" xml:space="preserve">
          <source>As an exception, this function reads a file name using a graphical file dialog instead of the minibuffer, if all of the following are true:</source>
          <target state="translated">例外として、この関数は、以下のすべてが真の場合、ミニバッファの代わりにグラフィカルファイルダイアログを使用してファイル名を読み込みます。</target>
        </trans-unit>
        <trans-unit id="7f170945bb4b449cfc683c1ed37876c06db96463" translate="yes" xml:space="preserve">
          <source>As an obsolescent calling convention, this function can be given six or more arguments. The first six arguments &lt;var&gt;second&lt;/var&gt;, &lt;var&gt;minute&lt;/var&gt;, &lt;var&gt;hour&lt;/var&gt;, &lt;var&gt;day&lt;/var&gt;, &lt;var&gt;month&lt;/var&gt;, and &lt;var&gt;year&lt;/var&gt; specify most of the components of a decoded time. If there are more than six arguments the &lt;em&gt;last&lt;/em&gt; argument is used as &lt;var&gt;zone&lt;/var&gt; and any other extra arguments are ignored, so that &lt;code&gt;(apply
#'encode-time (decode-time ...))&lt;/code&gt; works. In this obsolescent convention, &lt;var&gt;zone&lt;/var&gt; defaults to the current time zone rule (see &lt;a href=&quot;time-zone-rules#Time-Zone-Rules&quot;&gt;Time Zone Rules&lt;/a&gt;), and &lt;var&gt;dst&lt;/var&gt; is treated as if it was -1.</source>
          <target state="translated">廃止された呼び出し規約として、この関数には6つ以上の引数を指定できます。最初の6つの引数 &lt;var&gt;second&lt;/var&gt; 、 &lt;var&gt;minute&lt;/var&gt; 、 &lt;var&gt;hour&lt;/var&gt; 、 &lt;var&gt;day&lt;/var&gt; 、 &lt;var&gt;month&lt;/var&gt; 、および &lt;var&gt;year&lt;/var&gt; は、デコードされた時間のほとんどのコンポーネントを指定します。 6つを超える引数がある場合、&lt;em&gt;最後の&lt;/em&gt;引数が &lt;var&gt;zone&lt;/var&gt; として使用され、その他の追加の引数は無視されるため、 &lt;code&gt;(apply #'encode-time (decode-time ...))&lt;/code&gt; 機能します。この廃止された規則では、 &lt;var&gt;zone&lt;/var&gt; デフォルトで現在のタイムゾーンルールになり（&lt;a href=&quot;time-zone-rules#Time-Zone-Rules&quot;&gt;タイムゾーンルールを&lt;/a&gt;参照）、 &lt;var&gt;dst&lt;/var&gt; は-1であるかのように扱われます。</target>
        </trans-unit>
        <trans-unit id="2491282a6d1f8281ac0fcd08cc3d8281fc7d632e" translate="yes" xml:space="preserve">
          <source>As editing continues, undo lists get longer and longer. To prevent them from using up all available memory space, garbage collection trims them back to size limits you can set. (For this purpose, the size of an undo list measures the cons cells that make up the list, plus the strings of deleted text.) Three variables control the range of acceptable sizes: &lt;code&gt;undo-limit&lt;/code&gt;, &lt;code&gt;undo-strong-limit&lt;/code&gt; and &lt;code&gt;undo-outer-limit&lt;/code&gt;. In these variables, size is counted as the number of bytes occupied, which includes both saved text and other data.</source>
          <target state="translated">編集を続けると、元に戻すリストはどんどん長くなります。それらが使用可能なすべてのメモリスペースを使い果たすのを防ぐために、ガベージコレクションはそれらを設定可能なサイズ制限にトリミングします。 （この目的のために、元に戻すリストのサイズは、リストを構成するconsセルと、削除されたテキストの文字列を測定します。）3つの変数、 &lt;code&gt;undo-limit&lt;/code&gt; 、 &lt;code&gt;undo-strong-limit&lt;/code&gt; 、 &lt;code&gt;undo-outer-limit&lt;/code&gt; が許容サイズの範囲を制御します。アウターリミット。これらの変数では、サイズは占有されているバイト数としてカウントされます。これには、保存されたテキストとその他のデータの両方が含まれます。</target>
        </trans-unit>
        <trans-unit id="39fc3a710f302293efc2b0bded9197ae640e963b" translate="yes" xml:space="preserve">
          <source>As explained in &lt;a href=&quot;variable-scoping#Variable-Scoping&quot;&gt;Variable Scoping&lt;/a&gt;, Emacs can optionally enable lexical binding of variables. When lexical binding is enabled, any named function that you create (e.g., with &lt;code&gt;defun&lt;/code&gt;), as well as any anonymous function that you create using the &lt;code&gt;lambda&lt;/code&gt; macro or the &lt;code&gt;function&lt;/code&gt; special form or the &lt;code&gt;#'&lt;/code&gt; syntax (see &lt;a href=&quot;anonymous-functions#Anonymous-Functions&quot;&gt;Anonymous Functions&lt;/a&gt;), is automatically converted into a &lt;em&gt;closure&lt;/em&gt;.</source>
          <target state="translated">&lt;a href=&quot;variable-scoping#Variable-Scoping&quot;&gt;変数スコープ&lt;/a&gt;で説明されているように、Emacsはオプションで変数の字句バインディングを有効にすることができます。レキシカルバインディングが有効になっている場合、作成する名前付き関数（たとえば、 &lt;code&gt;defun&lt;/code&gt; を使用）、および &lt;code&gt;lambda&lt;/code&gt; マクロまたは &lt;code&gt;function&lt;/code&gt; 特殊形式または &lt;code&gt;#'&lt;/code&gt; 構文（&lt;a href=&quot;anonymous-functions#Anonymous-Functions&quot;&gt;匿名関数を&lt;/a&gt;参照）を使用して作成する無名関数は自動的に作成されます。&lt;em&gt;クロージャに&lt;/em&gt;変換されます。</target>
        </trans-unit>
        <trans-unit id="72d71c3cc374384e0af0a0724fbb040625e0c496" translate="yes" xml:space="preserve">
          <source>As far as &lt;code&gt;define-key&lt;/code&gt; is concerned, &lt;var&gt;item-string&lt;/var&gt; and &lt;var&gt;help-string&lt;/var&gt; are part of the event&amp;rsquo;s binding. However, &lt;code&gt;lookup-key&lt;/code&gt; returns just &lt;var&gt;real-binding&lt;/var&gt;, and only &lt;var&gt;real-binding&lt;/var&gt; is used for executing the key.</source>
          <target state="translated">これまでのように &lt;code&gt;define-key&lt;/code&gt; 懸念され、 &lt;var&gt;item-string&lt;/var&gt; と &lt;var&gt;help-string&lt;/var&gt; イベントの結合の一部です。ただし、 &lt;code&gt;lookup-key&lt;/code&gt; は &lt;var&gt;real-binding&lt;/var&gt; のみを返し、キーの実行には &lt;var&gt;real-binding&lt;/var&gt; のみが使用されます。</target>
        </trans-unit>
        <trans-unit id="04371b35f248ca488e9627aecf5dda4a949a350a" translate="yes" xml:space="preserve">
          <source>As far as possible, new major modes should be derived, either directly or indirectly, from one of these three modes. One reason is that this allows users to customize a single mode hook (e.g., &lt;code&gt;prog-mode-hook&lt;/code&gt;) for an entire family of relevant modes (e.g., all programming language modes).</source>
          <target state="translated">可能な限り、これら3つのモードのいずれかから、直接的または間接的に新しいメジャーモードを派生させる必要があります。1つの理由は、これにより、ユーザーが関連するモードのファミリー全体（たとえば、すべてのプログラミング言語モード）に対して単一のモードフック（たとえば、 &lt;code&gt;prog-mode-hook&lt;/code&gt; ）をカスタマイズできることです。</target>
        </trans-unit>
        <trans-unit id="ff3ef6be607829903e8a6baac8628d90d56c089f" translate="yes" xml:space="preserve">
          <source>As far as the Lisp reader is concerned, &amp;lsquo;</source>
          <target state="translated">Lispリーダーに関する限り、 '</target>
        </trans-unit>
        <trans-unit id="c87e482a1ccf8205de796dac23a5ade838dbdd25" translate="yes" xml:space="preserve">
          <source>As for &lt;code&gt;nil&lt;/code&gt;, but if</source>
          <target state="translated">&lt;code&gt;nil&lt;/code&gt; と同じですが、</target>
        </trans-unit>
        <trans-unit id="e20b47eb8e540da13af46101ac4dc2b6a5827bfb" translate="yes" xml:space="preserve">
          <source>As for &lt;code&gt;x-popup-menu&lt;/code&gt;, an element of the list may be just a string instead of a cons cell &lt;code&gt;(&lt;var&gt;string&lt;/var&gt; . &lt;var&gt;value&lt;/var&gt;)&lt;/code&gt;. That makes a box that cannot be selected.</source>
          <target state="translated">用として &lt;code&gt;x-popup-menu&lt;/code&gt; 、リストの要素は、単なる文字列の代わりに、コンス・セルであってもよい &lt;code&gt;(&lt;var&gt;string&lt;/var&gt; . &lt;var&gt;value&lt;/var&gt;)&lt;/code&gt; 。そのため、選択できないボックスが作成されます。</target>
        </trans-unit>
        <trans-unit id="18f02bf364dcfbbb51fe785b93d6502cf175baf7" translate="yes" xml:space="preserve">
          <source>As in the previous example (see &lt;a href=&quot;#pcase_002dexample_002d1&quot;&gt;Example 1&lt;/a&gt;), &lt;code&gt;and&lt;/code&gt; begins with a &lt;code&gt;pred&lt;/code&gt; sub-pattern to ensure the following sub-patterns work with an object of the correct type (string, in this case). If &lt;code&gt;(stringp&amp;nbsp;&lt;var&gt;expval&lt;/var&gt;)&lt;/code&gt; returns &lt;code&gt;nil&lt;/code&gt;, &lt;code&gt;pred&lt;/code&gt; fails, and thus &lt;code&gt;and&lt;/code&gt; fails, too.</source>
          <target state="translated">前の例（&lt;a href=&quot;#pcase_002dexample_002d1&quot;&gt;例1を&lt;/a&gt;参照） &lt;code&gt;and&lt;/code&gt; 同様に、 &lt;code&gt;pred&lt;/code&gt; サブパターンで始まり、次のサブパターンが正しいタイプのオブジェクト（この場合は文字列）で機能することを確認します。 &lt;code&gt;(stringp&amp;nbsp;&lt;var&gt;expval&lt;/var&gt;)&lt;/code&gt; が &lt;code&gt;nil&lt;/code&gt; を返す場合、 &lt;code&gt;pred&lt;/code&gt; は失敗するため &lt;code&gt;and&lt;/code&gt; 失敗します。</target>
        </trans-unit>
        <trans-unit id="aca399bc248b6540182b97cdc8a6ceed399a0db7" translate="yes" xml:space="preserve">
          <source>As is the case with &lt;code&gt;format&lt;/code&gt;, a format specification can include a width, which is a decimal number that appears after any flags. If a substitution contains fewer characters than its specified width, it is padded on the left:</source>
          <target state="translated">&lt;code&gt;format&lt;/code&gt; の場合と同様に、format仕様には、フラグの後に表示される10進数であるwidthを含めることができます。置換に含まれる文字が指定された幅より少ない場合は、左側に埋め込まれます。</target>
        </trans-unit>
        <trans-unit id="9007d393cbc677946e3b508fd46f178b4ffc51b8" translate="yes" xml:space="preserve">
          <source>As long as the selected window displays the current buffer, the window&amp;rsquo;s point and the buffer&amp;rsquo;s point always move together; they remain equal.</source>
          <target state="translated">選択したウィンドウに現在のバッファが表示されている限り、ウィンドウのポイントとバッファのポイントは常に一緒に移動します。それらは等しいままです。</target>
        </trans-unit>
        <trans-unit id="a4599968f503223a9b7899912e9301addb3f9878" translate="yes" xml:space="preserve">
          <source>As long as the value of &lt;code&gt;meta-prefix-char&lt;/code&gt; remains 27, key lookup translates</source>
          <target state="translated">&lt;code&gt;meta-prefix-char&lt;/code&gt; の値が27のままである限り、キールックアップは変換されます</target>
        </trans-unit>
        <trans-unit id="2403f847930ce8798404ebfea8bddc7017e3a7dd" translate="yes" xml:space="preserve">
          <source>As previously noted in this manual, a Lisp program is represented primarily by Lisp objects, and only secondarily as text. The textual form of a Lisp program is given by the read syntax of the Lisp objects that constitute the program. Hence, the textual form of a variable in a Lisp program is written using the read syntax for the symbol representing the variable.</source>
          <target state="translated">このマニュアルで述べたように、Lispプログラムは主にLispオブジェクトによって表現され、二次的にはテキストとして表現されます。Lispプログラムのテキスト形式は、プログラムを構成するLispオブジェクトの読み取り構文によって与えられます。したがって、Lispプログラム内の変数のテキスト形式は、その変数を表す記号の読み取り構文を使って書かれます。</target>
        </trans-unit>
        <trans-unit id="6c8a180c05fd7458e0ef38127404fa2fa9ac26b5" translate="yes" xml:space="preserve">
          <source>As previously noted, Emacs Lisp allows the same symbol to be defined both as a variable (e.g., with &lt;code&gt;defvar&lt;/code&gt;) and as a function or macro (e.g., with &lt;code&gt;defun&lt;/code&gt;). Such definitions do not conflict.</source>
          <target state="translated">先に述べたように、Emacs Lispには（と、例えば、同じシンボルが変数との両方を定義することを可能にする &lt;code&gt;defvar&lt;/code&gt; の（と、EG）及び関数またはマクロとして &lt;code&gt;defun&lt;/code&gt; ）。そのような定義は矛盾しません。</target>
        </trans-unit>
        <trans-unit id="2a0ddcf1c50ca193923f438a27950fa2767aba7b" translate="yes" xml:space="preserve">
          <source>As the examples in this section illustrate, &lt;code&gt;format-spec&lt;/code&gt; is often used for selectively formatting an assortment of different pieces of information. This is useful in programs that provide user-customizable format strings, as the user can choose to format with a regular syntax and in any desired order only a subset of the information that the program makes available.</source>
          <target state="translated">このセクションの例が示すように、 &lt;code&gt;format-spec&lt;/code&gt; は、さまざまな情報を選択的にフォーマットするためによく使用されます。これは、ユーザーが通常の構文で、プログラムが提供する情報のサブセットのみを任意の順序でフォーマットすることを選択できるため、ユーザーがカスタマイズ可能なフォーマット文字列を提供するプログラムで役立ちます。</target>
        </trans-unit>
        <trans-unit id="fcae404ca40596bab0f46fcb1d1aebb078adf297" translate="yes" xml:space="preserve">
          <source>As the heap size increases, the time to perform a garbage collection increases. Thus, it can be desirable to do them less frequently in proportion.</source>
          <target state="translated">ヒープサイズが大きくなると、ガベージコレクションを実行する時間が長くなる。したがって、それらを行う頻度は比例して少なくすることが望ましい場合がある。</target>
        </trans-unit>
        <trans-unit id="7e3df73939184a50a6120a14310b27d84575c14c" translate="yes" xml:space="preserve">
          <source>As the name implies, this function does not display any messages.</source>
          <target state="translated">その名の通り、この関数はメッセージを表示しません。</target>
        </trans-unit>
        <trans-unit id="e31d6bc3247e331efa29ece4c6b4b7ecd35823cc" translate="yes" xml:space="preserve">
          <source>As these examples show, you can use a form with a lambda expression as its &lt;small&gt;CAR&lt;/small&gt; to make local variables and give them values. In the old days of Lisp, this technique was the only way to bind and initialize local variables. But nowadays, it is clearer to use the special form &lt;code&gt;let&lt;/code&gt; for this purpose (see &lt;a href=&quot;local-variables#Local-Variables&quot;&gt;Local Variables&lt;/a&gt;). Lambda expressions are mainly used as anonymous functions for passing as arguments to other functions (see &lt;a href=&quot;anonymous-functions#Anonymous-Functions&quot;&gt;Anonymous Functions&lt;/a&gt;), or stored as symbol function definitions to produce named functions (see &lt;a href=&quot;function-names#Function-Names&quot;&gt;Function Names&lt;/a&gt;).</source>
          <target state="translated">これらの例が示すように、ラムダ式を&lt;small&gt;CAR&lt;/small&gt;として持つフォームを使用して、ローカル変数を作成し、それらに値を与えることができます。 Lispの昔は、この手法がローカル変数をバインドして初期化する唯一の方法でした。しかし、最近では、この目的のために特別な形式 &lt;code&gt;let&lt;/code&gt; を使用する方が明確です（&lt;a href=&quot;local-variables#Local-Variables&quot;&gt;ローカル変数を&lt;/a&gt;参照）。ラムダ式は、主に他の関数の引数として渡すために匿名関数として使用されている（参照&lt;a href=&quot;anonymous-functions#Anonymous-Functions&quot;&gt;無名関数を&lt;/a&gt;（参照）、または名前の関数を生成するためにシンボルの関数定義として保存&lt;a href=&quot;function-names#Function-Names&quot;&gt;関数名を&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="37412dfde91c59b85070a1fa6f6188f685c97c7f" translate="yes" xml:space="preserve">
          <source>As you use this manual, we ask that you send corrections as soon as you find them. If you think of a simple, real life example for a function or group of functions, please make an effort to write it up and send it in. Please reference any comments to the node name and function or variable name, as appropriate. Also state the number of the edition you are criticizing.</source>
          <target state="translated">本書をお使いになりながら、修正点を見つけたらすぐにお送りください。関数や関数群の簡単な実例を思いついたら、それを書いて送る努力をしてください。コメントはノード名と関数名や変数名を適宜参照してください。また、批判している版の番号も明記してください。</target>
        </trans-unit>
        <trans-unit id="875666f6d9c3564876142613c6760e04a0da95b2" translate="yes" xml:space="preserve">
          <source>Aside from elements that specify bindings for keys, a keymap can also have a string as an element. This is called the &lt;em&gt;overall prompt string&lt;/em&gt; and makes it possible to use the keymap as a menu. See &lt;a href=&quot;defining-menus#Defining-Menus&quot;&gt;Defining Menus&lt;/a&gt;.</source>
          <target state="translated">キーのバインディングを指定する要素とは別に、キーマップは要素として文字列を持つこともできます。これは&lt;em&gt;全体的なプロンプト文字列&lt;/em&gt;と呼ばれ、キーマップをメニューとして使用できるようにします。&lt;a href=&quot;defining-menus#Defining-Menus&quot;&gt;メニューの定義を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="1d3719187ae715d19fbc05c49ed805a355d60c95" translate="yes" xml:space="preserve">
          <source>Aside from some technical details, the body of the &lt;code&gt;find-file&lt;/code&gt; function is basically equivalent to:</source>
          <target state="translated">いくつかの技術的な詳細を除けば、 &lt;code&gt;find-file&lt;/code&gt; 関数の本体は基本的に次のものと同等です。</target>
        </trans-unit>
        <trans-unit id="e8854395183315465f485147e2c0e5d0dad0bf04" translate="yes" xml:space="preserve">
          <source>Aside from the four basic conditional forms, Emacs Lisp also has a pattern-matching conditional form, the &lt;code&gt;pcase&lt;/code&gt; macro, a hybrid of &lt;code&gt;cond&lt;/code&gt; and &lt;code&gt;cl-case&lt;/code&gt; (see &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/cl/Conditionals.html#Conditionals&quot;&gt;Conditionals&lt;/a&gt; in</source>
          <target state="translated">4つの基本的な条件付きフォームの他に、Emacs Lispには、パターンマッチング条件付きフォーム、 &lt;code&gt;pcase&lt;/code&gt; マクロ、 &lt;code&gt;cond&lt;/code&gt; と &lt;code&gt;cl-case&lt;/code&gt; caseのハイブリッドもあります（の&lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/cl/Conditionals.html#Conditionals&quot;&gt;条件付き&lt;/a&gt;を参照）。</target>
        </trans-unit>
        <trans-unit id="d784be167f97d7b6e1444587a023ff8462f0adde" translate="yes" xml:space="preserve">
          <source>Aside from the mathematical incorrectness of asserting that 9 is a double-digit integer, there is another problem with &lt;code&gt;MAYBE&lt;/code&gt;. The body form references &lt;code&gt;n&lt;/code&gt; once more, yet we do not see the updated value&amp;mdash;10&amp;mdash;at all. What happened to it?</source>
          <target state="translated">9が2桁の整数であると主張するという数学的な誤りは別として、 &lt;code&gt;MAYBE&lt;/code&gt; には別の問題があります。ボディフォームはもう一度 &lt;code&gt;n&lt;/code&gt; を参照しますが、更新された値（10）はまったく表示されません。それがどうなったのか？</target>
        </trans-unit>
        <trans-unit id="3562777bc6a3edbbbfe49bb7c58769707930308b" translate="yes" xml:space="preserve">
          <source>Ask</source>
          <target state="translated">Ask</target>
        </trans-unit>
        <trans-unit id="5cc8d5b1e25410343b6c6d03e6144240950ba693" translate="yes" xml:space="preserve">
          <source>Ask user a multiple choice question. &lt;var&gt;prompt&lt;/var&gt; should be a string that will be displayed as the prompt.</source>
          <target state="translated">ユーザーに多肢選択式の質問をします。 &lt;var&gt;prompt&lt;/var&gt; は、プロンプトとして表示される文字列である必要があります。</target>
        </trans-unit>
        <trans-unit id="a575156671adcef0e66c96ca9986973728b1a5e6" translate="yes" xml:space="preserve">
          <source>Asking Multiple-Choice Questions</source>
          <target state="translated">多肢選択式の質問</target>
        </trans-unit>
        <trans-unit id="f48d4ab0834bb43d119ea91a0df80bf7d9b32ab7" translate="yes" xml:space="preserve">
          <source>Asking a question with a simple answer.</source>
          <target state="translated">簡単な答えで質問をすること。</target>
        </trans-unit>
        <trans-unit id="fe7e00f4a1fa3a5c1a99ddf9345528ef0e23e5df" translate="yes" xml:space="preserve">
          <source>Asking complex questions.</source>
          <target state="translated">複雑な質問をすること。</target>
        </trans-unit>
        <trans-unit id="27b0c683fbfb99510b0eaaaf16a761a3b451a6a0" translate="yes" xml:space="preserve">
          <source>Asking the user to choose a coding system.</source>
          <target state="translated">コーディングシステムを選択してもらう。</target>
        </trans-unit>
        <trans-unit id="e753d0e9020f53ad0de8df59f25fdea5680ef2fc" translate="yes" xml:space="preserve">
          <source>Asking the user to specify a character.</source>
          <target state="translated">ユーザーに文字の指定を求める</target>
        </trans-unit>
        <trans-unit id="79f255d18c150763000984a919eb61a8c62cb802" translate="yes" xml:space="preserve">
          <source>Asking where the mouse is, or moving it.</source>
          <target state="translated">マウスの位置を聞いたり、動かしたり。</target>
        </trans-unit>
        <trans-unit id="9a8aef5df06c4a0630dba0718222fbda7f2ae98b" translate="yes" xml:space="preserve">
          <source>Assertion failed</source>
          <target state="translated">アサーション失敗</target>
        </trans-unit>
        <trans-unit id="906762c6281b489fa4d8cc099d0c4e13c1902efd" translate="yes" xml:space="preserve">
          <source>Assigning Lisp property lists to text characters.</source>
          <target state="translated">テキスト文字にLispプロパティリストを割り当てる。</target>
        </trans-unit>
        <trans-unit id="8f9fb7e8c09158fb874cf09f8dbca8383f6a050c" translate="yes" xml:space="preserve">
          <source>Associate &lt;var&gt;stderr&lt;/var&gt; with the standard error of the process. A non-&lt;code&gt;nil&lt;/code&gt; value should be either a buffer or a pipe process created with &lt;code&gt;make-pipe-process&lt;/code&gt;, described below. If &lt;var&gt;stderr&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, standard error is mixed with standard output, and both are sent to &lt;var&gt;buffer&lt;/var&gt; or &lt;var&gt;filter&lt;/var&gt;.</source>
          <target state="translated">准 &lt;var&gt;stderr&lt;/var&gt; プロセスの標準誤差と。非 &lt;code&gt;nil&lt;/code&gt; 値は、バッファまたはで作成されたパイプのプロセスのいずれかでなければならない &lt;code&gt;make-pipe-process&lt;/code&gt; 後述します。 &lt;var&gt;stderr&lt;/var&gt; が &lt;code&gt;nil&lt;/code&gt; の場合、標準エラーは標準出力と混合され、両方が &lt;var&gt;buffer&lt;/var&gt; または &lt;var&gt;filter&lt;/var&gt; 送信されます。</target>
        </trans-unit>
        <trans-unit id="e3024403263d4d843f0e51777623d2a49c1231db" translate="yes" xml:space="preserve">
          <source>Associating additional information with windows.</source>
          <target state="translated">追加情報をウィンドウに関連付ける</target>
        </trans-unit>
        <trans-unit id="e463ae7c0c475efc422013c7bb62639251e2604f" translate="yes" xml:space="preserve">
          <source>Association List Type</source>
          <target state="translated">アソシエーションリストタイプ</target>
        </trans-unit>
        <trans-unit id="c1eecc79e49a6ca7a499806fc8e58814d3aeda58" translate="yes" xml:space="preserve">
          <source>Association Lists</source>
          <target state="translated">アソシエーションリスト</target>
        </trans-unit>
        <trans-unit id="a0f646334656079aafb8f68fbbd7ae734d08ae78" translate="yes" xml:space="preserve">
          <source>Association lists (see &lt;a href=&quot;association-lists#Association-Lists&quot;&gt;Association Lists&lt;/a&gt;) are very similar to property lists. In contrast to association lists, the order of the pairs in the property list is not significant, since the property names must be distinct.</source>
          <target state="translated">連想リスト（参照&lt;a href=&quot;association-lists#Association-Lists&quot;&gt;連想リストは&lt;/a&gt;）プロパティリストと非常によく似ています。アソシエーションリストとは対照的に、プロパティ名は区別する必要があるため、プロパティリスト内のペアの順序は重要ではありません。</target>
        </trans-unit>
        <trans-unit id="14ba3cbc75793dbade1b890546d72c62627ca897" translate="yes" xml:space="preserve">
          <source>Association lists are often used to record information that you might otherwise keep on a stack, since new associations may be added easily to the front of the list. When searching an association list for an association with a given key, the first one found is returned, if there is more than one.</source>
          <target state="translated">アソシエーション・リストは、スタックに保存していた情報を記録するためによく使用されます。与えられたキーを持つアソシエーションをアソシエーション・リストで検索すると、複数のアソシエーションがある場合は、最初に見つかったものが返されます。</target>
        </trans-unit>
        <trans-unit id="c3f9b4c0afa65ab472f88a447b5b643be2caa8ed" translate="yes" xml:space="preserve">
          <source>Asynchronous subprocesses receive input when it is sent to them by Emacs, which is done with the functions in this section. You must specify the process to send input to, and the input data to send. If the subprocess runs a program, the data appears on the standard input of that program; for connections, the data is sent to the connected device or program.</source>
          <target state="translated">非同期サブプロセスは、Emacsから入力が送られてきたときに入力を受け取ります。入力を送信するプロセスと、送信する入力データを指定する必要があります。サブプロセスがプログラムを実行している場合、データはそのプログラムの標準入力に表示されます。</target>
        </trans-unit>
        <trans-unit id="a5bb8623a169e7bd4940e5f36d437427d3e09d1b" translate="yes" xml:space="preserve">
          <source>At any time, one frame in Emacs is the &lt;em&gt;selected frame&lt;/em&gt;. The selected window always resides on the selected frame.</source>
          <target state="translated">いつでも、Emacsの1つのフレームが&lt;em&gt;選択されたフレーム&lt;/em&gt;です。選択したウィンドウは常に選択したフレーム上にあります。</target>
        </trans-unit>
        <trans-unit id="4c816364377c69602fd91de24b490b44a6fcd129" translate="yes" xml:space="preserve">
          <source>At any time, several primary keymaps are &lt;em&gt;active&lt;/em&gt;&amp;mdash;that is, in use for finding key bindings. These are the &lt;em&gt;global map&lt;/em&gt;, which is shared by all buffers; the &lt;em&gt;local keymap&lt;/em&gt;, which is usually associated with a specific major mode; and zero or more &lt;em&gt;minor mode keymaps&lt;/em&gt;, which belong to currently enabled minor modes. (Not all minor modes have keymaps.) The local keymap bindings shadow (i.e., take precedence over) the corresponding global bindings. The minor mode keymaps shadow both local and global keymaps. See &lt;a href=&quot;active-keymaps#Active-Keymaps&quot;&gt;Active Keymaps&lt;/a&gt;, for details.</source>
          <target state="translated">いつでも、いくつかのプライマリキーマップが&lt;em&gt;アクティブになってい&lt;/em&gt;ます。つまり、キーバインディングの検索に使用されています。これらは、すべてのバッファで共有される&lt;em&gt;グローバルマップ&lt;/em&gt;です。&lt;em&gt;ローカルキーマップ&lt;/em&gt;は通常、特定のメジャーモードに関連付けられています、。現在有効になっているマイナーモードに属する0個以上の&lt;em&gt;マイナーモードキーマップ&lt;/em&gt;。 （すべてのマイナーモードにキーマップがあるわけではありません。）ローカルキーマップバインディングは、対応するグローバルバインディングをシャドウします（つまり、優先します）。マイナーモードのキーマップは、ローカルキーマップとグローバルキーマップの両方をシャドウします。詳細については、&lt;a href=&quot;active-keymaps#Active-Keymaps&quot;&gt;アクティブキーマップ&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="8d93bb5f9a38a88b4da1e36b6fa1f9cb4bfd6596" translate="yes" xml:space="preserve">
          <source>At each stage, if a face has a valid &lt;code&gt;:inherit&lt;/code&gt; attribute, Emacs treats any attribute with an &lt;code&gt;unspecified&lt;/code&gt; value as having the corresponding value drawn from the parent face(s). see &lt;a href=&quot;face-attributes#Face-Attributes&quot;&gt;Face Attributes&lt;/a&gt;. Note that the parent face(s) may also leave the attribute unspecified; in that case, the attribute remains unspecified at the next level of face merging.</source>
          <target state="translated">各段階で、面に有効な &lt;code&gt;:inherit&lt;/code&gt; 属性がある場合、Emacsは、値が &lt;code&gt;unspecified&lt;/code&gt; れていない属性を、親の面から引き出された対応する値を持つものとして扱います。&lt;a href=&quot;face-attributes#Face-Attributes&quot;&gt;顔の属性を&lt;/a&gt;参照してください。親の顔も属性を指定しないままにする場合があることに注意してください。その場合、属性は面のマージの次のレベルで指定されないままになります。</target>
        </trans-unit>
        <trans-unit id="621cbe593d12331614294e33d27df98bfb14d296" translate="yes" xml:space="preserve">
          <source>At some point in the future the base C dialect will no doubt change to C11.</source>
          <target state="translated">将来的には、ベースとなるC言語の方言がC11に変わることは間違いないでしょう。</target>
        </trans-unit>
        <trans-unit id="2d46551267fccda2366ce110501bc5c0ac875511" translate="yes" xml:space="preserve">
          <source>At the beginning or end of a line, the appropriate amount of space is none. Before a character with close parenthesis syntax, or after a character with open parenthesis or expression-prefix syntax, no space is also appropriate. Otherwise, one space is appropriate. See &lt;a href=&quot;syntax-class-table#Syntax-Class-Table&quot;&gt;Syntax Class Table&lt;/a&gt;.</source>
          <target state="translated">行の最初または最後では、適切なスペースの量はありません。閉じ括弧構文の文字の前、または開き括弧または式接頭辞構文の文字の後にも、スペースは適切ではありません。それ以外の場合は、1つのスペースが適切です。&lt;a href=&quot;syntax-class-table#Syntax-Class-Table&quot;&gt;構文クラス表を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="007e79f90925179d568d16a8deaddb8c8e8caa2f" translate="yes" xml:space="preserve">
          <source>At the center of the window is the &lt;em&gt;text area&lt;/em&gt;, or &lt;em&gt;body&lt;/em&gt;, where the buffer text is displayed. The text area can be surrounded by a series of optional areas. On the left and right, from innermost to outermost, these are the left and right fringes, denoted by LF and RF (see &lt;a href=&quot;fringes#Fringes&quot;&gt;Fringes&lt;/a&gt;); the left and right margins, denoted by LM and RM in the schematic (see &lt;a href=&quot;display-margins#Display-Margins&quot;&gt;Display Margins&lt;/a&gt;); the left or right vertical scroll bar, only one of which is present at any time, denoted by LS and RS (see &lt;a href=&quot;scroll-bars#Scroll-Bars&quot;&gt;Scroll Bars&lt;/a&gt;); and the right divider, denoted by RD (see &lt;a href=&quot;window-dividers#Window-Dividers&quot;&gt;Window Dividers&lt;/a&gt;). At the top of the window is the header line (see &lt;a href=&quot;header-lines#Header-Lines&quot;&gt;Header Lines&lt;/a&gt;). At the bottom of the window are the horizontal scroll bar (see &lt;a href=&quot;scroll-bars#Scroll-Bars&quot;&gt;Scroll Bars&lt;/a&gt;); the mode line (see &lt;a href=&quot;mode-line-format#Mode-Line-Format&quot;&gt;Mode Line Format&lt;/a&gt;); and the bottom divider (see &lt;a href=&quot;window-dividers#Window-Dividers&quot;&gt;Window Dividers&lt;/a&gt;).</source>
          <target state="translated">ウィンドウの中心にある&lt;em&gt;テキスト領域&lt;/em&gt;、又は&lt;em&gt;身体&lt;/em&gt;バッファテキストが表示され、。テキスト領域は、一連のオプション領域で囲むことができます。左右の最も内側から最も外側まで、これらは左右のフリンジであり、LFとRFで示されます（&lt;a href=&quot;fringes#Fringes&quot;&gt;フリンジを&lt;/a&gt;参照）。回路図でLMとRMで示されている左右のマージン（&lt;a href=&quot;display-margins#Display-Margins&quot;&gt;マージンの表示を&lt;/a&gt;参照）。左または右の垂直スクロールバー。LSとRSで示される、常に1つだけが存在します（&lt;a href=&quot;scroll-bars#Scroll-Bars&quot;&gt;スクロールバーを&lt;/a&gt;参照）。右の仕切りはRDで示されます（&lt;a href=&quot;window-dividers#Window-Dividers&quot;&gt;ウィンドウ仕切りを&lt;/a&gt;参照）。ウィンドウの上部にはヘッダー行があります（&lt;a href=&quot;header-lines#Header-Lines&quot;&gt;ヘッダー行を&lt;/a&gt;参照））。ウィンドウの下部に水平スクロールバーが（参照されている&lt;a href=&quot;scroll-bars#Scroll-Bars&quot;&gt;スクロールバーを&lt;/a&gt;）。モードライン（&lt;a href=&quot;mode-line-format#Mode-Line-Format&quot;&gt;モードラインフォーマットを&lt;/a&gt;参照）。および下部の仕切り（&lt;a href=&quot;window-dividers#Window-Dividers&quot;&gt;ウィンドウの&lt;/a&gt;仕切りを参照）。</target>
        </trans-unit>
        <trans-unit id="fce2ab087a5fd08a2230eb11f4e344519f5c8db6" translate="yes" xml:space="preserve">
          <source>At the level of C code, quitting cannot happen just anywhere; only at the special places that check &lt;code&gt;quit-flag&lt;/code&gt;. The reason for this is that quitting at other places might leave an inconsistency in Emacs&amp;rsquo;s internal state. Because quitting is delayed until a safe place, quitting cannot make Emacs crash.</source>
          <target state="translated">Cコードのレベルでは、終了はどこでも発生することはありません。 &lt;code&gt;quit-flag&lt;/code&gt; をチェックする特別な場所でのみ。これは、他の場所で終了すると、Emacsの内部状態に不整合が残る可能性があるためです。終了は安全な場所まで延期されるため、終了してもEmacsがクラッシュすることはありません。</target>
        </trans-unit>
        <trans-unit id="d255c59db332c87b9a24623a21d91ebeac724f41" translate="yes" xml:space="preserve">
          <source>At this moment typing</source>
          <target state="translated">この時点でタイピング</target>
        </trans-unit>
        <trans-unit id="ede1fb5d661ab864aba9032ff56e1ac325b126c0" translate="yes" xml:space="preserve">
          <source>Atomic Change Groups</source>
          <target state="translated">原子変化群</target>
        </trans-unit>
        <trans-unit id="aab81d84cf8514fae3d044627f17a742d2c5166b" translate="yes" xml:space="preserve">
          <source>Atomic Windows</source>
          <target state="translated">アトミックウィンドウズ</target>
        </trans-unit>
        <trans-unit id="ccb118068fddf7824a58d856e2c3e7b40ebb74f7" translate="yes" xml:space="preserve">
          <source>Atomic windows are implemented with the help of the reserved &lt;code&gt;window-atom&lt;/code&gt; window parameter (see &lt;a href=&quot;window-parameters#Window-Parameters&quot;&gt;Window Parameters&lt;/a&gt;) and an internal window (see &lt;a href=&quot;basic-windows#Basic-Windows&quot;&gt;Basic Windows&lt;/a&gt;) called the root window of the atomic window. All windows that are part of the same atomic window have this root window as their common ancestor and are assigned a non-&lt;code&gt;nil&lt;/code&gt;&lt;code&gt;window-atom&lt;/code&gt; parameter.</source>
          <target state="translated">アトミックウィンドウは、予約の助けを借りて実現されている &lt;code&gt;window-atom&lt;/code&gt; ウィンドウパラメータ（参照&lt;a href=&quot;window-parameters#Window-Parameters&quot;&gt;ウィンドウのパラメータを&lt;/a&gt;（参照）と内部窓&lt;a href=&quot;basic-windows#Basic-Windows&quot;&gt;Windowsの基本を&lt;/a&gt;、原子ウィンドウのルートウィンドウと呼ばれます）。同じアトミックウィンドウの一部であるすべてのウィンドウには、共通の祖先としてこのルートウィンドウがあり、 &lt;code&gt;nil&lt;/code&gt; 以外の &lt;code&gt;window-atom&lt;/code&gt; パラメーターが割り当てられています。</target>
        </trans-unit>
        <trans-unit id="a163ce0a704c17ae2c4e7f0c3f6ff0be652a3729" translate="yes" xml:space="preserve">
          <source>Atomic windows are rectangular compositions of at least two live windows. They have the following distinctive characteristics:</source>
          <target state="translated">アトミックウィンドウは、少なくとも2つのライブウィンドウからなる長方形の組成物である。それらは、次のような特徴的な特徴を持っている。</target>
        </trans-unit>
        <trans-unit id="84b84a11114f20365d178505da52d54f0c432b05" translate="yes" xml:space="preserve">
          <source>Atomic windows are useful to construct and preserve window layouts that are meaningful only when all involved buffers are shown simultaneously in a specific manner, such as when showing differences between file revisions, or the same text in different languages or markups. They can also be used to permanently display information pertinent to a specific window in bars on that window&amp;rsquo;s sides.</source>
          <target state="translated">アトミックウィンドウは、ファイルリビジョン間の違いや、異なる言語やマークアップで同じテキストを表示する場合など、関連するすべてのバッファが特定の方法で同時に表示される場合にのみ意味のあるウィンドウレイアウトを構築および保持するのに役立ちます。また、特定のウィンドウに関連する情報を、そのウィンドウの側面にあるバーに永続的に表示するために使用することもできます。</target>
        </trans-unit>
        <trans-unit id="7ac3939a8902c4e5ec26fa6e697cca7abee0c334" translate="yes" xml:space="preserve">
          <source>Atomic windows automatically cease to exist when one of their constituents gets deleted. To dissolve an atomic window manually, reset the &lt;code&gt;window-atom&lt;/code&gt; parameter of its constituents&amp;mdash;the root of the atomic window and all its descendants.</source>
          <target state="translated">アトミックウィンドウは、その構成要素の1つが削除されると、自動的に存在しなくなります。アトミックウィンドウを手動でディゾルブするには、その構成要素（アトミックウィンドウのルートとそのすべての子孫）の &lt;code&gt;window-atom&lt;/code&gt; パラメーターをリセットします。</target>
        </trans-unit>
        <trans-unit id="b9ac22b82065cc69d28fef7fb37ebf9456c2f8c5" translate="yes" xml:space="preserve">
          <source>Attempt to set a constant symbol</source>
          <target state="translated">定数記号の設定を試みる</target>
        </trans-unit>
        <trans-unit id="040459de5fdc40f82378844a0d54d538e77e475c" translate="yes" xml:space="preserve">
          <source>Attempts to match &lt;var&gt;pattern1&lt;/var&gt;&amp;hellip;, in order, until one of them fails to match. In that case, &lt;code&gt;and&lt;/code&gt; likewise fails to match, and the rest of the sub-patterns are not tested. If all sub-patterns match, &lt;code&gt;and&lt;/code&gt; matches.</source>
          <target state="translated">いずれかが一致しなくなるまで、 &lt;var&gt;pattern1&lt;/var&gt; &amp;hellip;を順番に一致させようとします。その場合には、 &lt;code&gt;and&lt;/code&gt; 同様に一致させるために失敗し、サブパターンの残りの部分は、テストされていません。すべてのサブパターンが一致する場合、 &lt;code&gt;and&lt;/code&gt; 一致します。</target>
        </trans-unit>
        <trans-unit id="d62c51b00eb3d0f88c19008784cb02b23b4ba495" translate="yes" xml:space="preserve">
          <source>Attempts to match &lt;var&gt;pattern1&lt;/var&gt;, &lt;var&gt;pattern2&lt;/var&gt;, &amp;hellip;, in order, until one of them succeeds. In that case, &lt;code&gt;or&lt;/code&gt; likewise matches, and the rest of the sub-patterns are not tested. (Note that there must be at least two sub-patterns. Simply &lt;code&gt;(or&amp;nbsp;&lt;var&gt;pattern1&lt;/var&gt;)&lt;/code&gt; signals error.)</source>
          <target state="translated">いずれかが成功するまで、 &lt;var&gt;pattern1&lt;/var&gt; 、 &lt;var&gt;pattern2&lt;/var&gt; 、&amp;hellip;を順番に一致させようとします。その場合、 &lt;code&gt;or&lt;/code&gt; 同様に一致し、残りのサブパターンはテストされません。（少なくとも2つのサブパターンが必要であることに注意してください。単に &lt;code&gt;(or&amp;nbsp;&lt;var&gt;pattern1&lt;/var&gt;)&lt;/code&gt; エラーを示します。）</target>
        </trans-unit>
        <trans-unit id="5b2467f53cc44078cb438b0c2750bc2ec1578c8a" translate="yes" xml:space="preserve">
          <source>Attract focus to the window chosen</source>
          <target state="translated">選択したウィンドウにフォーカスを集める</target>
        </trans-unit>
        <trans-unit id="19a9640f6e74bf975fe0db395e61ad03d3ece1c7" translate="yes" xml:space="preserve">
          <source>Audible signal to the user.</source>
          <target state="translated">ユーザーへの可聴信号。</target>
        </trans-unit>
        <trans-unit id="ee1acfa55eb1476c86c5c4a68f256a67b25289ab" translate="yes" xml:space="preserve">
          <source>Authentication</source>
          <target state="translated">Authentication</target>
        </trans-unit>
        <trans-unit id="2667d909be440bdf6583125971872bea1221d4db" translate="yes" xml:space="preserve">
          <source>Auto Fill mode also enables the functions that change the margins and justification style to refill portions of the text. See &lt;a href=&quot;margins#Margins&quot;&gt;Margins&lt;/a&gt;.</source>
          <target state="translated">自動入力モードでは、余白と位置揃えのスタイルを変更してテキストの一部を再入力する機能も有効になります。&lt;a href=&quot;margins#Margins&quot;&gt;マージンを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="555de047487d343cd666ab6a903a79ef6c09e487" translate="yes" xml:space="preserve">
          <source>Auto Fill mode is a minor mode that fills lines automatically as text is inserted. See &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Auto-Fill.html#Auto-Fill&quot;&gt;Auto Fill&lt;/a&gt; in</source>
          <target state="translated">自動塗りつぶしモードは、テキストが挿入されると自動的に行を塗りつぶすマイナーモードです。参照&lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Auto-Fill.html#Auto-Fill&quot;&gt;自動記入&lt;/a&gt;で</target>
        </trans-unit>
        <trans-unit id="850ade7a51d735a464313dc8f30adc7d11e8a00d" translate="yes" xml:space="preserve">
          <source>Auto Filling</source>
          <target state="translated">自動充填</target>
        </trans-unit>
        <trans-unit id="0b4ed412ef994ca0c43e1b7bd22d818d428bb6c5" translate="yes" xml:space="preserve">
          <source>Auto-Saving</source>
          <target state="translated">Auto-Saving</target>
        </trans-unit>
        <trans-unit id="845b01108562c3d927a2af1812a0c1bf88795555" translate="yes" xml:space="preserve">
          <source>Auto-saving...</source>
          <target state="translated">Auto-saving...</target>
        </trans-unit>
        <trans-unit id="c2e779e790c1d4dc28d4326306803dbf362b481e" translate="yes" xml:space="preserve">
          <source>Autoload</source>
          <target state="translated">Autoload</target>
        </trans-unit>
        <trans-unit id="06d7988cf794172658af0153fd1a2481ba35d7d2" translate="yes" xml:space="preserve">
          <source>Autoload Type</source>
          <target state="translated">オートロードタイプ</target>
        </trans-unit>
        <trans-unit id="85e513dae1246e61ba8640eb87ad292a21840742" translate="yes" xml:space="preserve">
          <source>Autoload by Prefix</source>
          <target state="translated">プレフィックスによるオートロード</target>
        </trans-unit>
        <trans-unit id="a316cd16d04dc567c3b4909645684cb65b1f615f" translate="yes" xml:space="preserve">
          <source>Autoload by Prefix.</source>
          <target state="translated">プレフィックスによるオートロード。</target>
        </trans-unit>
        <trans-unit id="3fa81ba949fafdad4688aed6d9380f82976ca9d7" translate="yes" xml:space="preserve">
          <source>Autoloading</source>
          <target state="translated">Autoloading</target>
        </trans-unit>
        <trans-unit id="eb9cb47e9f34f586b55a9d914f6b2f6403badd01" translate="yes" xml:space="preserve">
          <source>Automatic Face Assignment</source>
          <target state="translated">顔の自動割り付け</target>
        </trans-unit>
        <trans-unit id="ae90bbb56c1aa1c308fb3a413aa144f52a6ccd37" translate="yes" xml:space="preserve">
          <source>Automatic Indentation of code</source>
          <target state="translated">コードの自動インデント</target>
        </trans-unit>
        <trans-unit id="a8cc32cc81dbf9afed120141fd3975ae43627630" translate="yes" xml:space="preserve">
          <source>Automatic updating of frame titles.</source>
          <target state="translated">フレームタイトルの自動更新</target>
        </trans-unit>
        <trans-unit id="a5bc07194f48e4d3351e56450cd28e631e2382b0" translate="yes" xml:space="preserve">
          <source>Automatically re-evaluate a list of expressions and display their results each time Edebug updates the display.</source>
          <target state="translated">式のリストを自動的に再評価し、Edebugが表示を更新するたびにその結果を表示します。</target>
        </trans-unit>
        <trans-unit id="1cd844466867bdaf6e1db628300b6112623f0e83" translate="yes" xml:space="preserve">
          <source>Automatically selecting windows with the mouse.</source>
          <target state="translated">マウスで自動的にウィンドウを選択します。</target>
        </trans-unit>
        <trans-unit id="c89d8ac98afcea167130340f5b561c866ca98fd5" translate="yes" xml:space="preserve">
          <source>Autotyping</source>
          <target state="translated">Autotyping</target>
        </trans-unit>
        <trans-unit id="361af9ca637df41d1dd709df4b2eb262901b3fd8" translate="yes" xml:space="preserve">
          <source>Avoid &lt;code&gt;ssize_t&lt;/code&gt; except when communicating to low-level APIs that have &lt;code&gt;ssize_t&lt;/code&gt;-related limitations. Although it&amp;rsquo;s equivalent to &lt;code&gt;ptrdiff_t&lt;/code&gt; on typical platforms, &lt;code&gt;ssize_t&lt;/code&gt; is occasionally narrower, so using it for size-related calculations could overflow. Also, &lt;code&gt;ptrdiff_t&lt;/code&gt; is more ubiquitous and better-standardized, has standard &lt;code&gt;printf&lt;/code&gt; formats, and is the basis for Emacs&amp;rsquo;s internal size-overflow checking. When using &lt;code&gt;ssize_t&lt;/code&gt;, please note that POSIX requires support only for values in the range -1 .. &lt;code&gt;SSIZE_MAX&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ssize_t&lt;/code&gt; 関連の制限がある低レベルAPIと通信する場合を除いて、 &lt;code&gt;ssize_t&lt;/code&gt; は避けてください。それはと同等ですが &lt;code&gt;ptrdiff_t&lt;/code&gt; の典型的なプラットフォーム上で、 &lt;code&gt;ssize_t&lt;/code&gt; のはサイズ関連の計算のためにそれを使用してオーバーフローすることができるように、時折狭くなっています。また、 &lt;code&gt;ptrdiff_t&lt;/code&gt; はよりユビキタスで標準化されており、標準の &lt;code&gt;printf&lt;/code&gt; 形式を備えており、Emacsの内部サイズオーバーフローチェックの基礎となっています。 &lt;code&gt;ssize_t&lt;/code&gt; を使用する場合、POSIXは-1 &lt;code&gt;SSIZE_MAX&lt;/code&gt; 範囲の値のみをサポートする必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="4db5c02b78c97409e22545eb6907ca4a351e1990" translate="yes" xml:space="preserve">
          <source>Avoid arbitrary limits. For example, avoid &lt;code&gt;int len = strlen
(s);&lt;/code&gt; unless the length of &lt;code&gt;s&lt;/code&gt; is required for other reasons to fit in &lt;code&gt;int&lt;/code&gt; range.</source>
          <target state="translated">任意の制限を避けてください。たとえば、 &lt;code&gt;int len = strlen (s);&lt;/code&gt; は避けてください。他の理由で &lt;code&gt;int&lt;/code&gt; の範囲に収まるように &lt;code&gt;s&lt;/code&gt; の長さが必要な場合を除きます。</target>
        </trans-unit>
        <trans-unit id="0d6e79e0cc19181112cfd0c36a5750ae8c092fc5" translate="yes" xml:space="preserve">
          <source>Avoid depending on how many times expansion is done.</source>
          <target state="translated">拡張の回数に依存するのは避けましょう。</target>
        </trans-unit>
        <trans-unit id="2e549352e5b71cd7798ed53124f97e4a4c19088d" translate="yes" xml:space="preserve">
          <source>Avoiding evaluation (to put constants in the program).</source>
          <target state="translated">評価を避ける(プログラムに定数を入れる)。</target>
        </trans-unit>
        <trans-unit id="98c63cc59f3d9c3c7c9d29e55ddfee0b39d55b90" translate="yes" xml:space="preserve">
          <source>Avoiding problems with dynamic binding.</source>
          <target state="translated">動的バインディングの問題を回避する。</target>
        </trans-unit>
        <trans-unit id="ae4f281df5a5d0ff3cad6371f76d5c29b6d953ec" translate="yes" xml:space="preserve">
          <source>B</source>
          <target state="translated">B</target>
        </trans-unit>
        <trans-unit id="16374ac2b9a2eb53d18fcede0cdf14c4d6e18ba5" translate="yes" xml:space="preserve">
          <source>BS</source>
          <target state="translated">BS</target>
        </trans-unit>
        <trans-unit id="b52b36b7269fbfc58ec24bb724691951a3decbe8" translate="yes" xml:space="preserve">
          <source>Back</source>
          <target state="translated">Back</target>
        </trans-unit>
        <trans-unit id="17c0e560f6eadc671493346fc0a13caf302e9875" translate="yes" xml:space="preserve">
          <source>Background color, a string. The value can be a system-defined color name, or a hexadecimal color specification. See &lt;a href=&quot;color-names#Color-Names&quot;&gt;Color Names&lt;/a&gt;.</source>
          <target state="translated">背景色、文字列。値は、システム定義の色名、または16進数の色指定にすることができます。&lt;a href=&quot;color-names#Color-Names&quot;&gt;色名を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="cc48ef84cf0ee761d58df4dcb6d99bd10746fd9a" translate="yes" xml:space="preserve">
          <source>Backquote</source>
          <target state="translated">Backquote</target>
        </trans-unit>
        <trans-unit id="1c6ba351e6ca20e8a37172efc2c86d4aab598c50" translate="yes" xml:space="preserve">
          <source>Backquote-Style Patterns</source>
          <target state="translated">バッククォート-スタイルのパターン</target>
        </trans-unit>
        <trans-unit id="c0ecdab9574e4ebcb9dc4d8aec5335a6fb1dc637" translate="yes" xml:space="preserve">
          <source>Backquote-style patterns are a powerful set of &lt;code&gt;pcase&lt;/code&gt; pattern extensions (created using &lt;code&gt;pcase-defmacro&lt;/code&gt;) that make it easy to match &lt;var&gt;expval&lt;/var&gt; against specifications of its &lt;em&gt;structure&lt;/em&gt;.</source>
          <target state="translated">バッククォートスタイルのパターンは、（ &lt;code&gt;pcase-defmacro&lt;/code&gt; を使用して作成された） &lt;code&gt;pcase&lt;/code&gt; パターン拡張の強力なセットであり、expvalをその&lt;em&gt;構造の&lt;/em&gt;仕様と簡単に照合 &lt;var&gt;expval&lt;/var&gt; ます。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a017b7b51d9d23728fcdbbcaa591b2596fe0b09a" translate="yes" xml:space="preserve">
          <source>Backslash Constructs in Regular Expressions</source>
          <target state="translated">正規表現のバックスラッシュ構文</target>
        </trans-unit>
        <trans-unit id="807e6daac187d064954fd59f10abb8e716892ec1" translate="yes" xml:space="preserve">
          <source>Backslash-sequences in regular expressions.</source>
          <target state="translated">正規表現のバックスラッシュシーケンス。</target>
        </trans-unit>
        <trans-unit id="9bfb245aa5d9e794b82e574165fbbc700e3e2a72" translate="yes" xml:space="preserve">
          <source>Backtraces</source>
          <target state="translated">Backtraces</target>
        </trans-unit>
        <trans-unit id="c3e2b2ecbdd4245dd6be8d66bf5a99a7880e1508" translate="yes" xml:space="preserve">
          <source>Backtracking in Specifications</source>
          <target state="translated">仕様書のバックトラック</target>
        </trans-unit>
        <trans-unit id="efef7b78f24a9457b9578006ead1a23980b022a2" translate="yes" xml:space="preserve">
          <source>Backtracking is also disabled after successfully matching a quoted symbol or string specification, since this usually indicates a recognized construct. But if you have a set of alternative constructs that all begin with the same symbol, you can usually work around this constraint by factoring the symbol out of the alternatives, e.g., &lt;code&gt;[&quot;foo&quot; &amp;amp;or [first case] [second case] ...]&lt;/code&gt;.</source>
          <target state="translated">引用符で囲まれた記号または文字列の指定が正常に一致した後も、バックトラッキングは無効になります。これは通常、認識された構成を示しているためです。ただし、すべて同じ記号で始まる代替構造のセットがある場合は、通常、代替から記号を因数分解することでこの制約を回避できます。たとえば、 &lt;code&gt;[&quot;foo&quot; &amp;amp;or [first case] [second case] ...]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1b80345f727522e6032bad01fc94ae4ee43720c6" translate="yes" xml:space="preserve">
          <source>Backtracking is disabled while matching any of the form specifications (that is, &lt;code&gt;form&lt;/code&gt;, &lt;code&gt;body&lt;/code&gt;, &lt;code&gt;def-form&lt;/code&gt;, and &lt;code&gt;def-body&lt;/code&gt;). These specifications will match any form so any error must be in the form itself rather than at a higher level.</source>
          <target state="translated">フォームの仕様（つまり、 &lt;code&gt;form&lt;/code&gt; 、 &lt;code&gt;body&lt;/code&gt; 、 &lt;code&gt;def-form&lt;/code&gt; 、および &lt;code&gt;def-body&lt;/code&gt; ）のいずれかに一致している間は、バックトラッキングが無効になります。これらの仕様はどのフォームにも一致するため、エラーは上位レベルではなくフォーム自体にある必要があります。</target>
        </trans-unit>
        <trans-unit id="a4fc1af88bf3a7f32329f6577445d6679643e427" translate="yes" xml:space="preserve">
          <source>Backup Files</source>
          <target state="translated">バックアップファイル</target>
        </trans-unit>
        <trans-unit id="40a0ef48a621ee3ca348b1e08eee5e6ff78084ac" translate="yes" xml:space="preserve">
          <source>Backup by Renaming or by Copying?</source>
          <target state="translated">名前を変更してバックアップするか、コピーしてバックアップするか?</target>
        </trans-unit>
        <trans-unit id="3e24bb9e6bf592cfc87438fc7775b2a394418349" translate="yes" xml:space="preserve">
          <source>Backup files and auto-save files are two methods by which Emacs tries to protect the user from the consequences of crashes or of the user&amp;rsquo;s own errors. Auto-saving preserves the text from earlier in the current editing session; backup files preserve file contents prior to the current session.</source>
          <target state="translated">バックアップファイルと自動保存ファイルは、Emacsがクラッシュやユーザー自身のエラーの結果からユーザーを保護しようとする2つの方法です。自動保存は、現在の編集セッションの初期のテキストを保持します。バックアップファイルは、現在のセッションの前にファイルの内容を保持します。</target>
        </trans-unit>
        <trans-unit id="2b47ba4274b19191cdf1a5d7d53d13dd0235dd70" translate="yes" xml:space="preserve">
          <source>Backups and Auto-Saving</source>
          <target state="translated">バックアップと自動保存</target>
        </trans-unit>
        <trans-unit id="0cea14da6f943b9330cb8b19aa3f92fa39fb6f16" translate="yes" xml:space="preserve">
          <source>Backups are usually made by renaming the visited file to a new name. Optionally, you can specify that backup files should be made by copying the visited file. This choice makes a difference for files with multiple names; it also can affect whether the edited file remains owned by the original owner or becomes owned by the user editing it.</source>
          <target state="translated">バックアップは通常、訪問したファイルを新しい名前に変更することで作成されます。オプションで、訪問したファイルをコピーしてバックアップファイルを作成するように指定することもできます。この選択は、複数の名前を持つファイルに違いをもたらします。また、編集されたファイルが元の所有者に所有されたままであるか、編集したユーザーが所有するようになるかにも影響します。</target>
        </trans-unit>
        <trans-unit id="980a00caa2a5856cb63bd39c2e2070bc841c28b4" translate="yes" xml:space="preserve">
          <source>Backups of files with names matching &lt;var&gt;regexp&lt;/var&gt; will be made in &lt;var&gt;directory&lt;/var&gt;. &lt;var&gt;directory&lt;/var&gt; may be relative or absolute. If it is absolute, so that all matching files are backed up into the same directory, the file names in this directory will be the full name of the file backed up with all directory separators changed to &amp;lsquo;</source>
          <target state="translated">&lt;var&gt;regexp&lt;/var&gt; と一致する名前のファイルのバックアップは、 &lt;var&gt;directory&lt;/var&gt; に作成されます。 &lt;var&gt;directory&lt;/var&gt; は相対的または絶対的です。絶対的な場合、一致するすべてのファイルが同じディレクトリにバックアップされるため、このディレクトリ内のファイル名は、すべてのディレクトリ区切り文字が 'に変更されたバックアップファイルのフルネームになります</target>
        </trans-unit>
        <trans-unit id="fd4a1f65749d89056abcaeac3722a7b7a8fe75a1" translate="yes" xml:space="preserve">
          <source>Backward Compatibility</source>
          <target state="translated">下位互換性</target>
        </trans-unit>
        <trans-unit id="e514a03485d2668ef95953c312b10de6213c5a6b" translate="yes" xml:space="preserve">
          <source>Base 64 Encoding</source>
          <target state="translated">ベース64エンコーディング</target>
        </trans-unit>
        <trans-unit id="2da9b468199d7990437f4078993fd373ed775585" translate="yes" xml:space="preserve">
          <source>Base 64 code is used in email to encode a sequence of 8-bit bytes as a longer sequence of</source>
          <target state="translated">ベース64コードは、8ビットバイトのシーケンスをより長いシーケンスとしてエンコードするために電子メールで使用されます。</target>
        </trans-unit>
        <trans-unit id="4c671100c5a64e216a5296532f998860991bfe71" translate="yes" xml:space="preserve">
          <source>Based on the provided grammar, SMIE will be able to provide automatic indentation without any extra effort. But in practice, this default indentation style will probably not be good enough. You will want to tweak it in many different cases.</source>
          <target state="translated">提供された文法に基づいて、SMIEは余分な努力なしに自動インデントを提供することができるでしょう。しかし、実際には、このデフォルトのインデントスタイルではおそらく十分ではないでしょう。いろいろなケースで微調整したくなるでしょう。</target>
        </trans-unit>
        <trans-unit id="ed7c8b81e81eeb80d5baed6aff985328d2115ad0" translate="yes" xml:space="preserve">
          <source>Basic Char Syntax</source>
          <target state="translated">基本的な文字構文</target>
        </trans-unit>
        <trans-unit id="ca917eb6ff98062e696cf80a8ae061ef35888178" translate="yes" xml:space="preserve">
          <source>Basic Completion Functions</source>
          <target state="translated">基本的な完成機能</target>
        </trans-unit>
        <trans-unit id="50e2e3f56e746aee43ca80ef4e5fffdf4609c4f8" translate="yes" xml:space="preserve">
          <source>Basic Concepts of Coding Systems</source>
          <target state="translated">符号化システムの基本概念</target>
        </trans-unit>
        <trans-unit id="ad89db73741185f622afaecb510f561259b3dde6" translate="yes" xml:space="preserve">
          <source>Basic Concepts of Emacs Windows</source>
          <target state="translated">Emacs Windowsの基本概念</target>
        </trans-unit>
        <trans-unit id="00f4714f957a02625aba98347f399df3258beab7" translate="yes" xml:space="preserve">
          <source>Basic Faces</source>
          <target state="translated">基本的な顔</target>
        </trans-unit>
        <trans-unit id="ff9602efc9e32b4e2b30281afa47a5ad0c076c75" translate="yes" xml:space="preserve">
          <source>Basic Major Modes</source>
          <target state="translated">基本的な主要なモード</target>
        </trans-unit>
        <trans-unit id="7f5daf3307f72897980331dcafb0dc7eac1c3f87" translate="yes" xml:space="preserve">
          <source>Basic Parameters</source>
          <target state="translated">基本的なパラメータ</target>
        </trans-unit>
        <trans-unit id="57d59d1f9034406d74ff83e18c697246b75a0ddb" translate="yes" xml:space="preserve">
          <source>Basic Thread Functions</source>
          <target state="translated">基本的なスレッド機能</target>
        </trans-unit>
        <trans-unit id="566fc95e858fa38a59a695bd7cab6cae3b6d8fa3" translate="yes" xml:space="preserve">
          <source>Basic concepts of keymaps.</source>
          <target state="translated">キーマップの基本的な考え方</target>
        </trans-unit>
        <trans-unit id="a25b5cf184191bab8faa27ed59d923cece314ddb" translate="yes" xml:space="preserve">
          <source>Basic concepts of syntax tables.</source>
          <target state="translated">構文表の基本的な概念。</target>
        </trans-unit>
        <trans-unit id="8b4ea8050a775a0f3ea3c2ccd48f52d29c5611ab" translate="yes" xml:space="preserve">
          <source>Basic concepts.</source>
          <target state="translated">基本的な概念。</target>
        </trans-unit>
        <trans-unit id="0f70f9424495752a5144291186246e76da91be5b" translate="yes" xml:space="preserve">
          <source>Basic ideas of mode line control.</source>
          <target state="translated">モードライン制御の基本的な考え方</target>
        </trans-unit>
        <trans-unit id="1d42c96aca54ef9a010f6e17d0638352d113a90e" translate="yes" xml:space="preserve">
          <source>Basic information about minibuffers.</source>
          <target state="translated">ミニバッファーの基本情報</target>
        </trans-unit>
        <trans-unit id="3d3ef0f3067180013beb55c1d6dc1d28f43802f5" translate="yes" xml:space="preserve">
          <source>Basic information on using windows.</source>
          <target state="translated">windowsを使う上での基本的な情報。</target>
        </trans-unit>
        <trans-unit id="1b6019974338c229459a64e3a602d1c23dece46e" translate="yes" xml:space="preserve">
          <source>Basic layout of frames.</source>
          <target state="translated">フレームの基本的なレイアウト。</target>
        </trans-unit>
        <trans-unit id="2a42ee27cdcf6bfedbc7c589958206e56696aee1" translate="yes" xml:space="preserve">
          <source>Basic properties of strings and characters.</source>
          <target state="translated">文字列と文字の基本的な性質</target>
        </trans-unit>
        <trans-unit id="3c23a95b197dbd7c57081385c609a0440865eff0" translate="yes" xml:space="preserve">
          <source>Basic thread functions.</source>
          <target state="translated">スレッドの基本的な機能。</target>
        </trans-unit>
        <trans-unit id="8b6d8cb0fe44b1ea97c8dffd9944957e48ec1ad8" translate="yes" xml:space="preserve">
          <source>Batch Mode</source>
          <target state="translated">バッチモード</target>
        </trans-unit>
        <trans-unit id="9b540e8dec8ec13cb761e2f53dc0c1414e9d9fbf" translate="yes" xml:space="preserve">
          <source>Be careful not to redefine existing functions unintentionally. &lt;code&gt;defun&lt;/code&gt; redefines even primitive functions such as &lt;code&gt;car&lt;/code&gt; without any hesitation or notification. Emacs does not prevent you from doing this, because redefining a function is sometimes done deliberately, and there is no way to distinguish deliberate redefinition from unintentional redefinition.</source>
          <target state="translated">意図せずに既存の関数を再定義しないように注意してください。 &lt;code&gt;defun&lt;/code&gt; は、 &lt;code&gt;car&lt;/code&gt; などの原始的な機能でさえ、ためらったり通知したりすることなく再定義します。関数の再定義は意図的に行われることがあり、意図的な再定義と意図しない再定義を区別する方法がないため、Emacsはこれを妨げることはありません。</target>
        </trans-unit>
        <trans-unit id="13b72a62f4358262651a47272a3079ef92b405df" translate="yes" xml:space="preserve">
          <source>Be careful when composing these regular expressions; a poorly written pattern can dramatically slow things down! The function &lt;code&gt;regexp-opt&lt;/code&gt; (see &lt;a href=&quot;regexp-functions#Regexp-Functions&quot;&gt;Regexp Functions&lt;/a&gt;) is useful for calculating optimal regular expressions to match several keywords.</source>
          <target state="translated">これらの正規表現を作成するときは注意してください。うまく書かれていないパターンは物事を劇的に遅くする可能性があります！関数 &lt;code&gt;regexp-opt&lt;/code&gt; （&lt;a href=&quot;regexp-functions#Regexp-Functions&quot;&gt;Regexp関数を&lt;/a&gt;参照）は、複数のキーワードに一致する最適な正規表現を計算するのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="27bc044b4c8d3ad73080a8adb64df2e5a46f2bb1" translate="yes" xml:space="preserve">
          <source>Be careful when using non-</source>
          <target state="translated">非使用の場合は注意が必要です。</target>
        </trans-unit>
        <trans-unit id="e685f45a3679a7ec991ede319ba164f9a2bcda4c" translate="yes" xml:space="preserve">
          <source>Be careful when writing macro calls in files that you intend to byte-compile. Since macro calls are expanded when they are compiled, the macros need to be loaded into Emacs or the byte compiler will not do the right thing. The usual way to handle this is with &lt;code&gt;require&lt;/code&gt; forms which specify the files containing the needed macro definitions (see &lt;a href=&quot;named-features#Named-Features&quot;&gt;Named Features&lt;/a&gt;). Normally, the byte compiler does not evaluate the code that it is compiling, but it handles &lt;code&gt;require&lt;/code&gt; forms specially, by loading the specified libraries. To avoid loading the macro definition files when someone &lt;em&gt;runs&lt;/em&gt; the compiled program, write &lt;code&gt;eval-when-compile&lt;/code&gt; around the &lt;code&gt;require&lt;/code&gt; calls (see &lt;a href=&quot;eval-during-compile#Eval-During-Compile&quot;&gt;Eval During Compile&lt;/a&gt;). For more details, See &lt;a href=&quot;compiling-macros#Compiling-Macros&quot;&gt;Compiling Macros&lt;/a&gt;.</source>
          <target state="translated">Be careful when writing macro calls in files that you intend to byte-compile. Since macro calls are expanded when they are compiled, the macros need to be loaded into Emacs or the byte compiler will not do the right thing. The usual way to handle this is with &lt;code&gt;require&lt;/code&gt; forms which specify the files containing the needed macro definitions (see &lt;a href=&quot;named-features#Named-Features&quot;&gt;Named Features&lt;/a&gt;). Normally, the byte compiler does not evaluate the code that it is compiling, but it handles &lt;code&gt;require&lt;/code&gt; forms specially, by loading the specified libraries. To avoid loading the macro definition files when someone &lt;em&gt;runs&lt;/em&gt; the compiled program, write &lt;code&gt;eval-when-compile&lt;/code&gt; around the &lt;code&gt;require&lt;/code&gt; calls (see &lt;a href=&quot;eval-during-compile#Eval-During-Compile&quot;&gt;Eval During Compile&lt;/a&gt;). For more details, See &lt;a href=&quot;compiling-macros#Compiling-Macros&quot;&gt;Compiling Macros&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="c6856b62c3a77e855fac355ce1578434726e9581" translate="yes" xml:space="preserve">
          <source>Be careful with file names that end in spaces. On some filesystems (notably, MS-Windows), trailing whitespace characters in file names are silently and automatically ignored.</source>
          <target state="translated">スペースで終わるファイル名には注意してください。一部のファイルシステム (特に MS-Windows)では、ファイル名の末尾の空白文字は静かに自動的に無視されます。</target>
        </trans-unit>
        <trans-unit id="7baa8406b5920aeefae8bb15fe88275a07b0c0a0" translate="yes" xml:space="preserve">
          <source>Be sure to verify that the file name is relative before doing that. If you use an absolute file name, the results could be syntactically invalid or refer to the wrong file.</source>
          <target state="translated">その前に、ファイル名が相対的なものであることを確認してください。絶対ファイル名を使用した場合、結果は構文的に無効であったり、間違ったファイルを参照している可能性があります。</target>
        </trans-unit>
        <trans-unit id="98789dc3354690dfbeaecf0f3ce9c8a96fe9026d" translate="yes" xml:space="preserve">
          <source>Because &amp;lsquo;</source>
          <target state="translated">Because &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="e6dbac2a93ea4cf3cf393a42d12efb8fd86797f8" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;kill-emacs&lt;/code&gt; can be called in situations where user interaction is impossible (e.g., when the terminal is disconnected), functions on this hook should not attempt to interact with the user. If you want to interact with the user when Emacs is shutting down, use &lt;code&gt;kill-emacs-query-functions&lt;/code&gt;, described below.</source>
          <target state="translated">Because &lt;code&gt;kill-emacs&lt;/code&gt; can be called in situations where user interaction is impossible (e.g., when the terminal is disconnected), functions on this hook should not attempt to interact with the user. If you want to interact with the user when Emacs is shutting down, use &lt;code&gt;kill-emacs-query-functions&lt;/code&gt; , described below.</target>
        </trans-unit>
        <trans-unit id="0b34653ccb844a855bf2a53664633d4afdefaf2b" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;quote&lt;/code&gt; is used so often in programs, Lisp provides a convenient read syntax for it. An apostrophe character (&amp;lsquo;</source>
          <target state="translated">Because &lt;code&gt;quote&lt;/code&gt; is used so often in programs, Lisp provides a convenient read syntax for it. An apostrophe character (&amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="b2bc1f0e771e6eb95b71dcedaea02b03d8a8a123" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;save-excursion&lt;/code&gt; only saves point for the buffer that was current at the start of the excursion, any changes made to point in other buffers, during the excursion, will remain in effect afterward. This frequently leads to unintended consequences, so the byte compiler warns if you call &lt;code&gt;set-buffer&lt;/code&gt; during an excursion:</source>
          <target state="translated">Because &lt;code&gt;save-excursion&lt;/code&gt; only saves point for the buffer that was current at the start of the excursion, any changes made to point in other buffers, during the excursion, will remain in effect afterward. This frequently leads to unintended consequences, so the byte compiler warns if you call &lt;code&gt;set-buffer&lt;/code&gt; during an excursion:</target>
        </trans-unit>
        <trans-unit id="1d3ee6e492f4a143386c60288985612cf7687a32" translate="yes" xml:space="preserve">
          <source>Because cons cells are so central to Lisp, we also have a word for an object which is not a cons cell. These objects are called &lt;em&gt;atoms&lt;/em&gt;.</source>
          <target state="translated">Because cons cells are so central to Lisp, we also have a word for an object which is not a cons cell. These objects are called &lt;em&gt;atoms&lt;/em&gt;.</target>
        </trans-unit>
        <trans-unit id="8e02576b56371153350d8d25bb27cbfbf989dce0" translate="yes" xml:space="preserve">
          <source>Because each symbol has separate value and function cells, variables names and function names do not conflict. For example, the symbol &lt;code&gt;buffer-file-name&lt;/code&gt; has a value (the name of the file being visited in the current buffer) as well as a function definition (a primitive function that returns the name of the file):</source>
          <target state="translated">Because each symbol has separate value and function cells, variables names and function names do not conflict. For example, the symbol &lt;code&gt;buffer-file-name&lt;/code&gt; has a value (the name of the file being visited in the current buffer) as well as a function definition (a primitive function that returns the name of the file):</target>
        </trans-unit>
        <trans-unit id="d2ece29760102e60138459a857930034eb578422" translate="yes" xml:space="preserve">
          <source>Because it is common to perform arithmetic operations on a marker position, most of these operations (including &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;-&lt;/code&gt;) accept markers as arguments. In such cases, the marker stands for its current position.</source>
          <target state="translated">Because it is common to perform arithmetic operations on a marker position, most of these operations (including &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;-&lt;/code&gt; ) accept markers as arguments. In such cases, the marker stands for its current position.</target>
        </trans-unit>
        <trans-unit id="29cedf8199b58b0444621f3b1384580f106a0af6" translate="yes" xml:space="preserve">
          <source>Because it takes some time to load the standard Lisp files, the</source>
          <target state="translated">標準のLispファイルを読み込むのに時間がかかるので</target>
        </trans-unit>
        <trans-unit id="42fc09422aef4da2bc16d41efb01630156afbdf1" translate="yes" xml:space="preserve">
          <source>Because most cons cells are used as part of lists, we refer to any structure made out of cons cells as a &lt;em&gt;list structure&lt;/em&gt;.</source>
          <target state="translated">Because most cons cells are used as part of lists, we refer to any structure made out of cons cells as a &lt;em&gt;list structure&lt;/em&gt;.</target>
        </trans-unit>
        <trans-unit id="aecbe3fd5b632bec5904e4eeb626bf628ddaa189" translate="yes" xml:space="preserve">
          <source>Because non terminals cannot appear consecutively in the BNF grammar, it is difficult to correctly handle tokens that act as terminators, so the above grammar treats &lt;code&gt;&quot;;&quot;&lt;/code&gt; as a statement &lt;em&gt;separator&lt;/em&gt; instead, which SMIE can handle very well.</source>
          <target state="translated">Because non terminals cannot appear consecutively in the BNF grammar, it is difficult to correctly handle tokens that act as terminators, so the above grammar treats &lt;code&gt;&quot;;&quot;&lt;/code&gt; as a statement &lt;em&gt;separator&lt;/em&gt; instead, which SMIE can handle very well.</target>
        </trans-unit>
        <trans-unit id="5527da9c81f706f4f494272f6a72b5e6c955dbcd" translate="yes" xml:space="preserve">
          <source>Because of the special nature of lazily bound variables, it is an error to set them (e.g. with &lt;code&gt;setq&lt;/code&gt;).</source>
          <target state="translated">Because of the special nature of lazily bound variables, it is an error to set them (e.g. with &lt;code&gt;setq&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="4cc7eee6b3274dd2df5b26429c74414bad10f743" translate="yes" xml:space="preserve">
          <source>Because of the way lists are implemented on top of cons cells, you can treat &lt;code&gt;list-alist&lt;/code&gt; in the example above as a cons cell alist, where the value type is a list with a single element containing the real value.</source>
          <target state="translated">Because of the way lists are implemented on top of cons cells, you can treat &lt;code&gt;list-alist&lt;/code&gt; in the example above as a cons cell alist, where the value type is a list with a single element containing the real value.</target>
        </trans-unit>
        <trans-unit id="d4920f7b17cfb9be5d144cd02f205a26abedb351" translate="yes" xml:space="preserve">
          <source>Because regular expression matching works only going forward, this is implemented by searching backwards from point for a match that ends at point. That can be quite slow if it has to search a long distance. You can bound the time required by specifying a non-&lt;code&gt;nil&lt;/code&gt; value for &lt;var&gt;limit&lt;/var&gt;, which says not to search before &lt;var&gt;limit&lt;/var&gt;. In this case, the match that is found must begin at or after &lt;var&gt;limit&lt;/var&gt;. Here&amp;rsquo;s an example:</source>
          <target state="translated">Because regular expression matching works only going forward, this is implemented by searching backwards from point for a match that ends at point. That can be quite slow if it has to search a long distance. You can bound the time required by specifying a non- &lt;code&gt;nil&lt;/code&gt; value for &lt;var&gt;limit&lt;/var&gt; , which says not to search before &lt;var&gt;limit&lt;/var&gt; . In this case, the match that is found must begin at or after &lt;var&gt;limit&lt;/var&gt; . Here&amp;rsquo;s an example:</target>
        </trans-unit>
        <trans-unit id="891978e65a108dec966a02f2c109e3c7ab27e318" translate="yes" xml:space="preserve">
          <source>Because the byte-compiled code is evaluated by the byte-code interpreter, instead of being executed directly by the machine&amp;rsquo;s hardware (as true compiled code is), byte-code is completely transportable from machine to machine without recompilation. It is not, however, as fast as true compiled code.</source>
          <target state="translated">Because the byte-compiled code is evaluated by the byte-code interpreter, instead of being executed directly by the machine&amp;rsquo;s hardware (as true compiled code is), byte-code is completely transportable from machine to machine without recompilation. It is not, however, as fast as true compiled code.</target>
        </trans-unit>
        <trans-unit id="9807276681c6c1286c20092e4291987485eca98a" translate="yes" xml:space="preserve">
          <source>Because the match data normally describe the most recent search only, you must be careful not to do another search inadvertently between the search you wish to refer back to and the use of the match data. If you can&amp;rsquo;t avoid another intervening search, you must save and restore the match data around it, to prevent it from being overwritten.</source>
          <target state="translated">Because the match data normally describe the most recent search only, you must be careful not to do another search inadvertently between the search you wish to refer back to and the use of the match data. If you can&amp;rsquo;t avoid another intervening search, you must save and restore the match data around it, to prevent it from being overwritten.</target>
        </trans-unit>
        <trans-unit id="2a9a557d3ce6491f8ae2018c1e6773fb2de8d6d8" translate="yes" xml:space="preserve">
          <source>Because the result of the evaluation is non-&lt;code&gt;nil&lt;/code&gt;, &lt;code&gt;guard&lt;/code&gt; matches, &lt;code&gt;and&lt;/code&gt; matches, and control passes to that clause&amp;rsquo;s body forms.</source>
          <target state="translated">Because the result of the evaluation is non- &lt;code&gt;nil&lt;/code&gt; , &lt;code&gt;guard&lt;/code&gt; matches, &lt;code&gt;and&lt;/code&gt; matches, and control passes to that clause&amp;rsquo;s body forms.</target>
        </trans-unit>
        <trans-unit id="1db90825a22716e728468e821da490caab60e2bd" translate="yes" xml:space="preserve">
          <source>Because the symbols used for abbrevs are not interned in the usual obarray, they will never appear as the result of reading a Lisp expression; in fact, normally they are never used except by the code that handles abbrevs. Therefore, it is safe to use them in a nonstandard way.</source>
          <target state="translated">略語に使われるシンボルは通常のobarrayには組み込まれていないので、Lisp式を読んだ結果として現れることはありません;実際、通常は略語を扱うコード以外では使われることはありません。したがって、非標準的な方法で使用しても問題ありません。</target>
        </trans-unit>
        <trans-unit id="4c851d66714e2bb452c04ba43899f653d596ccbc" translate="yes" xml:space="preserve">
          <source>Because the width of a given string depends on the flags that control the appearance of certain characters, &lt;code&gt;vertical-motion&lt;/code&gt; behaves differently, for a given piece of text, depending on the buffer it is in, and even on the selected window (because the width, the truncation flag, and display table may vary between windows). See &lt;a href=&quot;usual-display#Usual-Display&quot;&gt;Usual Display&lt;/a&gt;.</source>
          <target state="translated">Because the width of a given string depends on the flags that control the appearance of certain characters, &lt;code&gt;vertical-motion&lt;/code&gt; behaves differently, for a given piece of text, depending on the buffer it is in, and even on the selected window (because the width, the truncation flag, and display table may vary between windows). See &lt;a href=&quot;usual-display#Usual-Display&quot;&gt;Usual Display&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="ed8353d04454f502b14b0705a480aaefdecdb99f" translate="yes" xml:space="preserve">
          <source>Because threads were a relatively late addition to Emacs Lisp, and due to the way dynamic binding was sometimes used in conjunction with &lt;code&gt;accept-process-output&lt;/code&gt;, by default a process is locked to the thread that created it. When a process is locked to a thread, output from the process can only be accepted by that thread.</source>
          <target state="translated">Because threads were a relatively late addition to Emacs Lisp, and due to the way dynamic binding was sometimes used in conjunction with &lt;code&gt;accept-process-output&lt;/code&gt; , by default a process is locked to the thread that created it. When a process is locked to a thread, output from the process can only be accepted by that thread.</target>
        </trans-unit>
        <trans-unit id="edefffca965b0362f640503f05f0a22864aaf0c5" translate="yes" xml:space="preserve">
          <source>Because we read from side to side in the inner loop, and from top to bottom in the outer loop, the effect of horizontal scrolling is not like that of textual or vertical scrolling. Textual scrolling involves selection of a portion of text to display, and vertical scrolling moves the window contents contiguously; but horizontal scrolling causes part of &lt;em&gt;each line&lt;/em&gt; to go off screen.</source>
          <target state="translated">Because we read from side to side in the inner loop, and from top to bottom in the outer loop, the effect of horizontal scrolling is not like that of textual or vertical scrolling. Textual scrolling involves selection of a portion of text to display, and vertical scrolling moves the window contents contiguously; but horizontal scrolling causes part of &lt;em&gt;each line&lt;/em&gt; to go off screen.</target>
        </trans-unit>
        <trans-unit id="ca1ce0d49ba0f409cab2f1c7bbd925fafa44fcfe" translate="yes" xml:space="preserve">
          <source>Beeping</source>
          <target state="translated">Beeping</target>
        </trans-unit>
        <trans-unit id="17f7918b2f07183d74812fc33ccac59180f7ee50" translate="yes" xml:space="preserve">
          <source>Before Emacs can draw a character on a graphical display, it must select a &lt;em&gt;font&lt;/em&gt; for that character&lt;a href=&quot;#FOOT23&quot; name=&quot;DOCF23&quot;&gt;&lt;sup&gt;23&lt;/sup&gt;&lt;/a&gt;. See &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Fonts.html#Fonts&quot;&gt;Fonts&lt;/a&gt; in</source>
          <target state="translated">Before Emacs can draw a character on a graphical display, it must select a &lt;em&gt;font&lt;/em&gt; for that character&lt;a href=&quot;#FOOT23&quot; name=&quot;DOCF23&quot;&gt;&lt;sup&gt;23&lt;/sup&gt;&lt;/a&gt;. See &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Fonts.html#Fonts&quot;&gt;Fonts&lt;/a&gt; in</target>
        </trans-unit>
        <trans-unit id="13e5148e87ac77ce622c012484f91f5a2b40ed38" translate="yes" xml:space="preserve">
          <source>Before actually playing the sound, &lt;code&gt;play-sound&lt;/code&gt; calls the functions in the list &lt;code&gt;play-sound-functions&lt;/code&gt;. Each function is called with one argument, &lt;var&gt;sound&lt;/var&gt;.</source>
          <target state="translated">Before actually playing the sound, &lt;code&gt;play-sound&lt;/code&gt; calls the functions in the list &lt;code&gt;play-sound-functions&lt;/code&gt; . Each function is called with one argument, &lt;var&gt;sound&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="acfa912275db6abf7aab479d6b8b835a2b7d945e" translate="yes" xml:space="preserve">
          <source>Before any attempt to send the request, the application-specific conditions are checked. Since the &lt;code&gt;jsonrpc&lt;/code&gt; library can&amp;rsquo;t know what these conditions are, the program can use the &lt;code&gt;jsonrpc-connection-ready-p&lt;/code&gt; generic function (see &lt;a href=&quot;generic-functions#Generic-Functions&quot;&gt;Generic Functions&lt;/a&gt;) to specify them. The default method for this function returns &lt;code&gt;t&lt;/code&gt;, but you can add overriding methods that return &lt;code&gt;nil&lt;/code&gt; in some situations, based on the arguments passed to it, which are the &lt;code&gt;jsonrpc-connection&lt;/code&gt; object (see &lt;a href=&quot;jsonrpc-overview#JSONRPC-Overview&quot;&gt;JSONRPC Overview&lt;/a&gt;) and whichever value you passed as the &lt;code&gt;:deferred&lt;/code&gt; keyword argument.</source>
          <target state="translated">Before any attempt to send the request, the application-specific conditions are checked. Since the &lt;code&gt;jsonrpc&lt;/code&gt; library can&amp;rsquo;t know what these conditions are, the program can use the &lt;code&gt;jsonrpc-connection-ready-p&lt;/code&gt; generic function (see &lt;a href=&quot;generic-functions#Generic-Functions&quot;&gt;Generic Functions&lt;/a&gt;) to specify them. The default method for this function returns &lt;code&gt;t&lt;/code&gt; , but you can add overriding methods that return &lt;code&gt;nil&lt;/code&gt; in some situations, based on the arguments passed to it, which are the &lt;code&gt;jsonrpc-connection&lt;/code&gt; object (see &lt;a href=&quot;jsonrpc-overview#JSONRPC-Overview&quot;&gt;JSONRPC Overview&lt;/a&gt;) and whichever value you passed as the &lt;code&gt;:deferred&lt;/code&gt; keyword argument.</target>
        </trans-unit>
        <trans-unit id="dcb73aafe29a27771bb410a3cc2ea9ba475e91b4" translate="yes" xml:space="preserve">
          <source>Before confirming unsaved changes, &lt;code&gt;kill-buffer&lt;/code&gt; calls the functions in the list &lt;code&gt;kill-buffer-query-functions&lt;/code&gt;, in order of appearance, with no arguments. The buffer being killed is the current buffer when they are called. The idea of this feature is that these functions will ask for confirmation from the user. If any of them returns &lt;code&gt;nil&lt;/code&gt;, &lt;code&gt;kill-buffer&lt;/code&gt; spares the buffer&amp;rsquo;s life.</source>
          <target state="translated">Before confirming unsaved changes, &lt;code&gt;kill-buffer&lt;/code&gt; calls the functions in the list &lt;code&gt;kill-buffer-query-functions&lt;/code&gt; , in order of appearance, with no arguments. The buffer being killed is the current buffer when they are called. The idea of this feature is that these functions will ask for confirmation from the user. If any of them returns &lt;code&gt;nil&lt;/code&gt; , &lt;code&gt;kill-buffer&lt;/code&gt; spares the buffer&amp;rsquo;s life.</target>
        </trans-unit>
        <trans-unit id="b2c6df81ff9d3d92d5524e2fbe564a5cd653b1ec" translate="yes" xml:space="preserve">
          <source>Before creating the frame, this function ensures that Emacs is set up to display graphics. For instance, if Emacs has not processed X resources (e.g., if it was started on a text terminal), it does so at this time. In all other respects, this function behaves like &lt;code&gt;make-frame&lt;/code&gt; (see &lt;a href=&quot;creating-frames#Creating-Frames&quot;&gt;Creating Frames&lt;/a&gt;).</source>
          <target state="translated">Before creating the frame, this function ensures that Emacs is set up to display graphics. For instance, if Emacs has not processed X resources (e.g., if it was started on a text terminal), it does so at this time. In all other respects, this function behaves like &lt;code&gt;make-frame&lt;/code&gt; (see &lt;a href=&quot;creating-frames#Creating-Frames&quot;&gt;Creating Frames&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="838498ac25b34bcaba38e8d1736cb5d1213cbd8a" translate="yes" xml:space="preserve">
          <source>Before restoring the previous definitions, &lt;code&gt;unload-feature&lt;/code&gt; runs &lt;code&gt;remove-hook&lt;/code&gt; to remove functions in the library from certain hooks. These hooks include variables whose names end in &amp;lsquo;</source>
          <target state="translated">Before restoring the previous definitions, &lt;code&gt;unload-feature&lt;/code&gt; runs &lt;code&gt;remove-hook&lt;/code&gt; to remove functions in the library from certain hooks. These hooks include variables whose names end in &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="1f9591d8d77ddb1cb74b81db22ada52f623b6efb" translate="yes" xml:space="preserve">
          <source>Before suspending, &lt;code&gt;suspend-emacs&lt;/code&gt; runs the normal hook &lt;code&gt;suspend-hook&lt;/code&gt;. After the user resumes Emacs, &lt;code&gt;suspend-emacs&lt;/code&gt; runs the normal hook &lt;code&gt;suspend-resume-hook&lt;/code&gt;. See &lt;a href=&quot;hooks#Hooks&quot;&gt;Hooks&lt;/a&gt;.</source>
          <target state="translated">Before suspending, &lt;code&gt;suspend-emacs&lt;/code&gt; runs the normal hook &lt;code&gt;suspend-hook&lt;/code&gt; . After the user resumes Emacs, &lt;code&gt;suspend-emacs&lt;/code&gt; runs the normal hook &lt;code&gt;suspend-resume-hook&lt;/code&gt; . See &lt;a href=&quot;hooks#Hooks&quot;&gt;Hooks&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="88b944d20a7b391474416844b970d522dd303815" translate="yes" xml:space="preserve">
          <source>Before the display margins can display anything, you must give them a nonzero width. The usual way to do that is to set these variables:</source>
          <target state="translated">表示余白に何かを表示させる前に、0ではない幅を与えなければなりません。通常の方法は、これらの変数を設定することです。</target>
        </trans-unit>
        <trans-unit id="b44b66b4a5c9db407d2757ab95949e425a1d30d3" translate="yes" xml:space="preserve">
          <source>Before the double-click or double-drag event, Emacs generates a &lt;em&gt;double-down&lt;/em&gt; event when the user presses the button down for the second time. Its event type contains &amp;lsquo;</source>
          <target state="translated">Before the double-click or double-drag event, Emacs generates a &lt;em&gt;double-down&lt;/em&gt; event when the user presses the button down for the second time. Its event type contains &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="27eeeabd3ce039e5d19034d398eafd77b5b99419" translate="yes" xml:space="preserve">
          <source>Before you do this, make sure the defun has enough close parentheses. Otherwise,</source>
          <target state="translated">これを行う前に、defunに十分に近い括弧が付いていることを確認してください。そうでなければ</target>
        </trans-unit>
        <trans-unit id="cb9703a6b294ccc0880d4c1dfd4f9f3daf981cdb" translate="yes" xml:space="preserve">
          <source>Begin your module by including the header file</source>
          <target state="translated">ヘッダーファイルを含めてモジュールを開始します。</target>
        </trans-unit>
        <trans-unit id="b4042d6d0e34481a13a0bd70105a92db402dff7f" translate="yes" xml:space="preserve">
          <source>Beginning of buffer</source>
          <target state="translated">バッファの開始</target>
        </trans-unit>
        <trans-unit id="7967dbe1bdfdc4fa11437c00eb1b6a94e7b1839d" translate="yes" xml:space="preserve">
          <source>Being quick and simple, &lt;code&gt;unsafep&lt;/code&gt; does a very light analysis and rejects many Lisp expressions that are actually safe. There are no known cases where &lt;code&gt;unsafep&lt;/code&gt; returns &lt;code&gt;nil&lt;/code&gt; for an unsafe expression. However, a safe Lisp expression can return a string with a &lt;code&gt;display&lt;/code&gt; property, containing an associated Lisp expression to be executed after the string is inserted into a buffer. This associated expression can be a virus. In order to be safe, you must delete properties from all strings calculated by user code before inserting them into buffers.</source>
          <target state="translated">Being quick and simple, &lt;code&gt;unsafep&lt;/code&gt; does a very light analysis and rejects many Lisp expressions that are actually safe. There are no known cases where &lt;code&gt;unsafep&lt;/code&gt; returns &lt;code&gt;nil&lt;/code&gt; for an unsafe expression. However, a safe Lisp expression can return a string with a &lt;code&gt;display&lt;/code&gt; property, containing an associated Lisp expression to be executed after the string is inserted into a buffer. This associated expression can be a virus. In order to be safe, you must delete properties from all strings calculated by user code before inserting them into buffers.</target>
        </trans-unit>
        <trans-unit id="cd79998f02d02ee1f54b550965880ade28c0e5ae" translate="yes" xml:space="preserve">
          <source>Below is a table explaining each element. Note that last &lt;code&gt;heap&lt;/code&gt; entry is optional and present only if an underlying &lt;code&gt;malloc&lt;/code&gt; implementation provides &lt;code&gt;mallinfo&lt;/code&gt; function.</source>
          <target state="translated">Below is a table explaining each element. Note that last &lt;code&gt;heap&lt;/code&gt; entry is optional and present only if an underlying &lt;code&gt;malloc&lt;/code&gt; implementation provides &lt;code&gt;mallinfo&lt;/code&gt; function.</target>
        </trans-unit>
        <trans-unit id="b3840ae760c97e9024f5cab124e17dbea9c19d2c" translate="yes" xml:space="preserve">
          <source>Below is a table of the classes you can use in a character alternative, and what they mean. Note that the &amp;lsquo;</source>
          <target state="translated">Below is a table of the classes you can use in a character alternative, and what they mean. Note that the &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="01bae04f3ae2801c065a4011c8954162185dde4a" translate="yes" xml:space="preserve">
          <source>Below there is a description of a few subtypes of &lt;code&gt;Lisp_Vectorlike&lt;/code&gt;. Buffer object represents the text to display and edit. Window is the part of display structure which shows the buffer or is used as a container to recursively place other windows on the same frame. (Do not confuse Emacs Lisp window object with the window as an entity managed by the user interface system like X; in Emacs terminology, the latter is called frame.) Finally, process object is used to manage the subprocesses.</source>
          <target state="translated">Below there is a description of a few subtypes of &lt;code&gt;Lisp_Vectorlike&lt;/code&gt; . Buffer object represents the text to display and edit. Window is the part of display structure which shows the buffer or is used as a container to recursively place other windows on the same frame. (Do not confuse Emacs Lisp window object with the window as an entity managed by the user interface system like X; in Emacs terminology, the latter is called frame.) Finally, process object is used to manage the subprocesses.</target>
        </trans-unit>
        <trans-unit id="5c8be3db4820388729d86b1200b856644093f20c" translate="yes" xml:space="preserve">
          <source>Below we will give a number of guidelines to redeem the frustration mentioned above and thus to avoid literally losing buffers in-between the windows of a frame.</source>
          <target state="translated">以下、私たちは、上記のフラストレーションを償還するためのガイドラインの数を与えると、このように文字通りフレームの窓の間にバッファを失うことを避けるために。</target>
        </trans-unit>
        <trans-unit id="0353802f217c5a533a465f68ec4f0d8faa7c50cf" translate="yes" xml:space="preserve">
          <source>Below, we show first the regexp as a string in Lisp syntax (to distinguish spaces from tab characters), and then the result of evaluating it. The string constant begins and ends with a double-quote. &amp;lsquo;</source>
          <target state="translated">Below, we show first the regexp as a string in Lisp syntax (to distinguish spaces from tab characters), and then the result of evaluating it. The string constant begins and ends with a double-quote. &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="3cca15ebda8dce9819d62b75dc10ad2c1696871b" translate="yes" xml:space="preserve">
          <source>Berkeley BSD and its variants.</source>
          <target state="translated">バークレー BSD とその変種。</target>
        </trans-unit>
        <trans-unit id="01ea07f92a42549b5de550cce8a6d1e85ce49161" translate="yes" xml:space="preserve">
          <source>Beware: this property operates at a very low level, and affects a lot of code in unexpected ways. So use it with extreme caution. A common misuse is to put an intangible property on invisible text, which is actually unnecessary since the command loop will move point outside of the invisible text at the end of each command anyway. See &lt;a href=&quot;adjusting-point#Adjusting-Point&quot;&gt;Adjusting Point&lt;/a&gt;. For these reasons, this property is obsolete; use the &lt;code&gt;cursor-intangible&lt;/code&gt; property instead.</source>
          <target state="translated">Beware: this property operates at a very low level, and affects a lot of code in unexpected ways. So use it with extreme caution. A common misuse is to put an intangible property on invisible text, which is actually unnecessary since the command loop will move point outside of the invisible text at the end of each command anyway. See &lt;a href=&quot;adjusting-point#Adjusting-Point&quot;&gt;Adjusting Point&lt;/a&gt;. For these reasons, this property is obsolete; use the &lt;code&gt;cursor-intangible&lt;/code&gt; property instead.</target>
        </trans-unit>
        <trans-unit id="f7f5f613a250e0e11c1b4577276a09871c48b610" translate="yes" xml:space="preserve">
          <source>Beyond the basic vector, a lot of objects like markers, overlays and buffers are managed as if they were vectors. The corresponding C data structures include the &lt;code&gt;union vectorlike_header&lt;/code&gt; field whose &lt;code&gt;size&lt;/code&gt; member contains the subtype enumerated by &lt;code&gt;enum pvec_type&lt;/code&gt; and an information about how many &lt;code&gt;Lisp_Object&lt;/code&gt; fields this structure contains and what the size of the rest data is. This information is needed to calculate the memory footprint of an object, and used by the vector allocation code while iterating over the vector blocks.</source>
          <target state="translated">Beyond the basic vector, a lot of objects like markers, overlays and buffers are managed as if they were vectors. The corresponding C data structures include the &lt;code&gt;union vectorlike_header&lt;/code&gt; field whose &lt;code&gt;size&lt;/code&gt; member contains the subtype enumerated by &lt;code&gt;enum pvec_type&lt;/code&gt; and an information about how many &lt;code&gt;Lisp_Object&lt;/code&gt; fields this structure contains and what the size of the rest data is. This information is needed to calculate the memory footprint of an object, and used by the vector allocation code while iterating over the vector blocks.</target>
        </trans-unit>
        <trans-unit id="f2b8d702e0ae298ec5dfa21f68f107c0b717e304" translate="yes" xml:space="preserve">
          <source>Bidirectional Display</source>
          <target state="translated">双方向表示</target>
        </trans-unit>
        <trans-unit id="0f761761aa75d96b2cf2c46b89a33d4202f1f95c" translate="yes" xml:space="preserve">
          <source>Bidirectional reordering can have surprising and unpleasant effects when two strings with bidirectional content are juxtaposed in a buffer, or otherwise programmatically concatenated into a string of text. A typical problematic case is when a buffer consists of sequences of text fields separated by whitespace or punctuation characters, like Buffer Menu mode or Rmail Summary Mode. Because the punctuation characters used as separators have &lt;em&gt;weak directionality&lt;/em&gt;, they take on the directionality of surrounding text. As result, a numeric field that follows a field with bidirectional content can be displayed &lt;em&gt;to the left&lt;/em&gt; of the preceding field, messing up the expected layout. There are several ways to avoid this problem:</source>
          <target state="translated">Bidirectional reordering can have surprising and unpleasant effects when two strings with bidirectional content are juxtaposed in a buffer, or otherwise programmatically concatenated into a string of text. A typical problematic case is when a buffer consists of sequences of text fields separated by whitespace or punctuation characters, like Buffer Menu mode or Rmail Summary Mode. Because the punctuation characters used as separators have &lt;em&gt;weak directionality&lt;/em&gt;, they take on the directionality of surrounding text. As result, a numeric field that follows a field with bidirectional content can be displayed &lt;em&gt;to the left&lt;/em&gt; of the preceding field, messing up the expected layout. There are several ways to avoid this problem:</target>
        </trans-unit>
        <trans-unit id="7618266932012d1bb7d78a709b3b8de0c7e01623" translate="yes" xml:space="preserve">
          <source>Bignums can have arbitrary precision. Operations that overflow a fixnum will return a bignum instead.</source>
          <target state="translated">ビグナムは任意の精度を持つことができます。fixnum をオーバーフローさせた操作は、代わりに bignum を返します。</target>
        </trans-unit>
        <trans-unit id="fb38340a365bddb7a78416de50a44b6a7efdea98" translate="yes" xml:space="preserve">
          <source>Bind the symbol &lt;var&gt;ref&lt;/var&gt; to a submatch that matches &lt;var&gt;rx-expr&lt;/var&gt;&lt;small&gt;...&lt;/small&gt;. &lt;var&gt;ref&lt;/var&gt; is bound in &lt;var&gt;body-forms&lt;/var&gt; to the string of the submatch or nil, but can also be used in &lt;code&gt;backref&lt;/code&gt;.</source>
          <target state="translated">Bind the symbol &lt;var&gt;ref&lt;/var&gt; to a submatch that matches &lt;var&gt;rx-expr&lt;/var&gt; &lt;small&gt;...&lt;/small&gt;. &lt;var&gt;ref&lt;/var&gt; is bound in &lt;var&gt;body-forms&lt;/var&gt; to the string of the submatch or nil, but can also be used in &lt;code&gt;backref&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4379c6bcd5778b843b030784559be7b79a5580f0" translate="yes" xml:space="preserve">
          <source>Binding &lt;code&gt;coding-system-for-write&lt;/code&gt; to a non-&lt;code&gt;nil&lt;/code&gt; value prevents output primitives from calling the function specified by &lt;code&gt;select-safe-coding-system-function&lt;/code&gt; (see &lt;a href=&quot;user_002dchosen-coding-systems#User_002dChosen-Coding-Systems&quot;&gt;User-Chosen Coding Systems&lt;/a&gt;). This is because</source>
          <target state="translated">Binding &lt;code&gt;coding-system-for-write&lt;/code&gt; to a non- &lt;code&gt;nil&lt;/code&gt; value prevents output primitives from calling the function specified by &lt;code&gt;select-safe-coding-system-function&lt;/code&gt; (see &lt;a href=&quot;user_002dchosen-coding-systems#User_002dChosen-Coding-Systems&quot;&gt;User-Chosen Coding Systems&lt;/a&gt;). This is because</target>
        </trans-unit>
        <trans-unit id="fd1754f82b6bd628f04b3f5c068badfc9846c322" translate="yes" xml:space="preserve">
          <source>Binding module functions to Lisp symbols</source>
          <target state="translated">モジュール関数をLispシンボルにバインド</target>
        </trans-unit>
        <trans-unit id="5d759eb09f19bf06ed84ff18e43aee3a19e46979" translate="yes" xml:space="preserve">
          <source>Bitwise Operations on Integers</source>
          <target state="translated">整数のビット演算</target>
        </trans-unit>
        <trans-unit id="93fd851ff63a4d886e2fa5d2be01e88deb486b52" translate="yes" xml:space="preserve">
          <source>Blinking Parentheses</source>
          <target state="translated">括弧の点滅</target>
        </trans-unit>
        <trans-unit id="6ac648d45e59dfdc6715fe0e3cbd86c82820c6b6" translate="yes" xml:space="preserve">
          <source>Block until &lt;var&gt;thread&lt;/var&gt; exits, or until the current thread is signaled. It returns the result of the &lt;var&gt;thread&lt;/var&gt; function. If &lt;var&gt;thread&lt;/var&gt; has already exited, this returns immediately.</source>
          <target state="translated">Block until &lt;var&gt;thread&lt;/var&gt; exits, or until the current thread is signaled. It returns the result of the &lt;var&gt;thread&lt;/var&gt; function. If &lt;var&gt;thread&lt;/var&gt; has already exited, this returns immediately.</target>
        </trans-unit>
        <trans-unit id="c6929c141afbaefdc4afd63ac4b5596956cfa67c" translate="yes" xml:space="preserve">
          <source>Bool-Vector Type</source>
          <target state="translated">ブールベクトル型</target>
        </trans-unit>
        <trans-unit id="882f4e1ca02e65db176c079c22995b90c25fc39c" translate="yes" xml:space="preserve">
          <source>Bool-vectors</source>
          <target state="translated">Bool-vectors</target>
        </trans-unit>
        <trans-unit id="c0a12baab63ceb798d7bac34fa38c4622e4b0373" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;kill-ring&lt;/code&gt; and &lt;code&gt;kill-ring-yank-pointer&lt;/code&gt; are Lisp variables whose values are normally lists. The word &amp;ldquo;pointer&amp;rdquo; in the name of the &lt;code&gt;kill-ring-yank-pointer&lt;/code&gt; indicates that the variable&amp;rsquo;s purpose is to identify one element of the list for use by the next yank command.</source>
          <target state="translated">Both &lt;code&gt;kill-ring&lt;/code&gt; and &lt;code&gt;kill-ring-yank-pointer&lt;/code&gt; are Lisp variables whose values are normally lists. The word &amp;ldquo;pointer&amp;rdquo; in the name of the &lt;code&gt;kill-ring-yank-pointer&lt;/code&gt; indicates that the variable&amp;rsquo;s purpose is to identify one element of the list for use by the next yank command.</target>
        </trans-unit>
        <trans-unit id="2fdc0bac385ea879dbde52d2dd508f2b5a448d88" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;read-from-minibuffer&lt;/code&gt; and &lt;code&gt;completing-read&lt;/code&gt; add new elements to the history list automatically, and provide commands to allow the user to reuse items on the list. The only thing your program needs to do to use a history list is to initialize it and to pass its name to the input functions when you wish. But it is safe to modify the list by hand when the minibuffer input functions are not using it.</source>
          <target state="translated">Both &lt;code&gt;read-from-minibuffer&lt;/code&gt; and &lt;code&gt;completing-read&lt;/code&gt; add new elements to the history list automatically, and provide commands to allow the user to reuse items on the list. The only thing your program needs to do to use a history list is to initialize it and to pass its name to the input functions when you wish. But it is safe to modify the list by hand when the minibuffer input functions are not using it.</target>
        </trans-unit>
        <trans-unit id="fc66435a82b20252191500c38ab3e5707fac603e" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;yes-or-no-p&lt;/code&gt; and &lt;code&gt;y-or-n-p&lt;/code&gt; use the minibuffer.</source>
          <target state="translated">Both &lt;code&gt;yes-or-no-p&lt;/code&gt; and &lt;code&gt;y-or-n-p&lt;/code&gt; use the minibuffer.</target>
        </trans-unit>
        <trans-unit id="dfd6cff3dbda1d13ebd279438e41124efaba93e7" translate="yes" xml:space="preserve">
          <source>Both &lt;var&gt;error-symbol&lt;/var&gt; and &lt;var&gt;data&lt;/var&gt; are available to any error handlers that handle the error: &lt;code&gt;condition-case&lt;/code&gt; binds a local variable to a list of the form &lt;code&gt;(&lt;var&gt;error-symbol&lt;/var&gt; .
&lt;var&gt;data&lt;/var&gt;)&lt;/code&gt; (see &lt;a href=&quot;handling-errors#Handling-Errors&quot;&gt;Handling Errors&lt;/a&gt;).</source>
          <target state="translated">Both &lt;var&gt;error-symbol&lt;/var&gt; and &lt;var&gt;data&lt;/var&gt; are available to any error handlers that handle the error: &lt;code&gt;condition-case&lt;/code&gt; binds a local variable to a list of the form &lt;code&gt;(&lt;var&gt;error-symbol&lt;/var&gt; . &lt;var&gt;data&lt;/var&gt;)&lt;/code&gt; (see &lt;a href=&quot;handling-errors#Handling-Errors&quot;&gt;Handling Errors&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="62da8c794cc6a7eb9ffe501a46f505c4219f98f2" translate="yes" xml:space="preserve">
          <source>Both forms of this definition (with backquote and without) suffer from the defect that &lt;var&gt;final&lt;/var&gt; is evaluated on every iteration. If &lt;var&gt;final&lt;/var&gt; is a constant, this is not a problem. If it is a more complex form, say &lt;code&gt;(long-complex-calculation x)&lt;/code&gt;, this can slow down the execution significantly. If &lt;var&gt;final&lt;/var&gt; has side effects, executing it more than once is probably incorrect.</source>
          <target state="translated">Both forms of this definition (with backquote and without) suffer from the defect that &lt;var&gt;final&lt;/var&gt; is evaluated on every iteration. If &lt;var&gt;final&lt;/var&gt; is a constant, this is not a problem. If it is a more complex form, say &lt;code&gt;(long-complex-calculation x)&lt;/code&gt; , this can slow down the execution significantly. If &lt;var&gt;final&lt;/var&gt; has side effects, executing it more than once is probably incorrect.</target>
        </trans-unit>
        <trans-unit id="4b35a12cfb8382543b92627bbee4b04423faea8d" translate="yes" xml:space="preserve">
          <source>Both lists and arrays are classified as sequences.</source>
          <target state="translated">リストも配列もシーケンスに分類されます。</target>
        </trans-unit>
        <trans-unit id="d2f3804efa9fdf3073f4d412bb85880a0a67b5c0" translate="yes" xml:space="preserve">
          <source>Both the values and the keys in an alist may be any Lisp objects. For example, in the following alist, the symbol &lt;code&gt;a&lt;/code&gt; is associated with the number &lt;code&gt;1&lt;/code&gt;, and the string &lt;code&gt;&quot;b&quot;&lt;/code&gt; is associated with the &lt;em&gt;list&lt;/em&gt;&lt;code&gt;(2 3)&lt;/code&gt;, which is the &lt;small&gt;CDR&lt;/small&gt; of the alist element:</source>
          <target state="translated">Both the values and the keys in an alist may be any Lisp objects. For example, in the following alist, the symbol &lt;code&gt;a&lt;/code&gt; is associated with the number &lt;code&gt;1&lt;/code&gt; , and the string &lt;code&gt;&quot;b&quot;&lt;/code&gt; is associated with the &lt;em&gt;list&lt;/em&gt; &lt;code&gt;(2 3)&lt;/code&gt; , which is the &lt;small&gt;CDR&lt;/small&gt; of the alist element:</target>
        </trans-unit>
        <trans-unit id="cce7f2f2f0dc525117a70d581d9c335212145e5b" translate="yes" xml:space="preserve">
          <source>Bottom</source>
          <target state="translated">Bottom</target>
        </trans-unit>
        <trans-unit id="e61ada95a3801a523f8d48042eaed868415934b4" translate="yes" xml:space="preserve">
          <source>Breaking on an event.</source>
          <target state="translated">イベントでブレイク。</target>
        </trans-unit>
        <trans-unit id="25a85b6e8b7cc5b5a89123c777d9b420bfa8cc33" translate="yes" xml:space="preserve">
          <source>Breakpoints at stop points.</source>
          <target state="translated">ストップポイントでのブレイクポイント。</target>
        </trans-unit>
        <trans-unit id="50f88da05c8e174324af021a4ee24bc168eb0c3d" translate="yes" xml:space="preserve">
          <source>Breaks</source>
          <target state="translated">Breaks</target>
        </trans-unit>
        <trans-unit id="ee60d60ea805fbda38f6f538481a92d3787df0b9" translate="yes" xml:space="preserve">
          <source>Brief description</source>
          <target state="translated">簡単な説明</target>
        </trans-unit>
        <trans-unit id="3fb0fc86dfa0b9d7362bd38d269b717749f04cef" translate="yes" xml:space="preserve">
          <source>Buffer Basics</source>
          <target state="translated">バッファの基本</target>
        </trans-unit>
        <trans-unit id="c027215488849466cacd3006649b1340a2edd0fc" translate="yes" xml:space="preserve">
          <source>Buffer File Name</source>
          <target state="translated">バッファファイル名</target>
        </trans-unit>
        <trans-unit id="a4af6911c145bae353cfba5cde3bbb16bdca445e" translate="yes" xml:space="preserve">
          <source>Buffer Internals</source>
          <target state="translated">バッファ内部</target>
        </trans-unit>
        <trans-unit id="5032b3933a4bf66e8948fdd3b1195bf2ec955ec7" translate="yes" xml:space="preserve">
          <source>Buffer Modification</source>
          <target state="translated">バッファの変更</target>
        </trans-unit>
        <trans-unit id="a1220d5a5dc0d3413a288b7d866d2b909c573bb8" translate="yes" xml:space="preserve">
          <source>Buffer Modification Time</source>
          <target state="translated">バッファ修正時間</target>
        </trans-unit>
        <trans-unit id="44e02f9bcee199b59cbd729f000935b0a07991dd" translate="yes" xml:space="preserve">
          <source>Buffer Names</source>
          <target state="translated">バッファ名</target>
        </trans-unit>
        <trans-unit id="ccf9f9fdff4870f16ae30767ca4be6fe76523e15" translate="yes" xml:space="preserve">
          <source>Buffer Parameters</source>
          <target state="translated">バッファパラメータ</target>
        </trans-unit>
        <trans-unit id="e93f01132bbaec25c49799efddeb64957f02afd2" translate="yes" xml:space="preserve">
          <source>Buffer Text Notation</source>
          <target state="translated">バッファテキスト表記法</target>
        </trans-unit>
        <trans-unit id="f1294c425911ac20d751cb9d1c51979e6e34f62e" translate="yes" xml:space="preserve">
          <source>Buffer Type</source>
          <target state="translated">バッファタイプ</target>
        </trans-unit>
        <trans-unit id="abcd68a1e18c1b87353060b6dc458244da82927b" translate="yes" xml:space="preserve">
          <source>Buffer is read-only</source>
          <target state="translated">バッファは読み取り専用</target>
        </trans-unit>
        <trans-unit id="344030f3634d1baa3762609d3692b8f3c1316b48" translate="yes" xml:space="preserve">
          <source>Buffer positions and motion functions.</source>
          <target state="translated">バッファの位置とモーション機能</target>
        </trans-unit>
        <trans-unit id="6246ccf7dd19ff26d69c92fb853ac66fb5ae4f89" translate="yes" xml:space="preserve">
          <source>Buffer positions are measured in character units. This function returns the byte-position corresponding to buffer position &lt;var&gt;position&lt;/var&gt; in the current buffer. This is 1 at the start of the buffer, and counts upward in bytes. If &lt;var&gt;position&lt;/var&gt; is out of range, the value is &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">Buffer positions are measured in character units. This function returns the byte-position corresponding to buffer position &lt;var&gt;position&lt;/var&gt; in the current buffer. This is 1 at the start of the buffer, and counts upward in bytes. If &lt;var&gt;position&lt;/var&gt; is out of range, the value is &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="35ca209a656833f1530433e2982a81634d31ea0e" translate="yes" xml:space="preserve">
          <source>Buffer positions indicating which text is on-screen in a window.</source>
          <target state="translated">ウィンドウ内のどのテキストが画面上にあるかを示すバッファ位置。</target>
        </trans-unit>
        <trans-unit id="8a53998ea65d2c55189b85c0ba6f6abc07875258" translate="yes" xml:space="preserve">
          <source>Buffer-Local Variables</source>
          <target state="translated">バッファローカル変数</target>
        </trans-unit>
        <trans-unit id="e1f999c3ef7294166b2203dddf8a38a2a12863ad" translate="yes" xml:space="preserve">
          <source>Buffer-specific information that is directly accessible is stored in &lt;em&gt;buffer-local&lt;/em&gt; variable bindings, which are variable values that are effective only in a particular buffer. This feature allows each buffer to override the values of certain variables. Most major modes override variables such as &lt;code&gt;fill-column&lt;/code&gt; or &lt;code&gt;comment-column&lt;/code&gt; in this way. For more information about buffer-local variables and functions related to them, see &lt;a href=&quot;buffer_002dlocal-variables#Buffer_002dLocal-Variables&quot;&gt;Buffer-Local Variables&lt;/a&gt;.</source>
          <target state="translated">Buffer-specific information that is directly accessible is stored in &lt;em&gt;buffer-local&lt;/em&gt; variable bindings, which are variable values that are effective only in a particular buffer. This feature allows each buffer to override the values of certain variables. Most major modes override variables such as &lt;code&gt;fill-column&lt;/code&gt; or &lt;code&gt;comment-column&lt;/code&gt; in this way. For more information about buffer-local variables and functions related to them, see &lt;a href=&quot;buffer_002dlocal-variables#Buffer_002dLocal-Variables&quot;&gt;Buffer-Local Variables&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="ea28d2b0e2e067c2d49b361f79f8dd13430b1c1f" translate="yes" xml:space="preserve">
          <source>Buffer-wide commands and bindings for buttons.</source>
          <target state="translated">バッファワイドコマンドとボタンのバインディング</target>
        </trans-unit>
        <trans-unit id="4cbcd2f7b704b607643b54842a2d38a1465e1a06" translate="yes" xml:space="preserve">
          <source>Buffers</source>
          <target state="translated">Buffers</target>
        </trans-unit>
        <trans-unit id="c34ea999c856831b2f1f1b93ec2c55bca01f7339" translate="yes" xml:space="preserve">
          <source>Buffers and Windows</source>
          <target state="translated">バッファとWindows</target>
        </trans-unit>
        <trans-unit id="89fab4e05ae4baad776ec1df498d67259c031ce8" translate="yes" xml:space="preserve">
          <source>Buffers are displayed in windows.</source>
          <target state="translated">バッファはウィンドウに表示されます。</target>
        </trans-unit>
        <trans-unit id="813e70bd28e3a98cb6625b026a7542aa93fd1a0a" translate="yes" xml:space="preserve">
          <source>Buffers exist until explicitly killed.</source>
          <target state="translated">バッファは明示的に殺されるまで存在します。</target>
        </trans-unit>
        <trans-unit id="5807d4a79a20e298c7a061e07bafbf257b7f1329" translate="yes" xml:space="preserve">
          <source>Buffers have no read syntax. They print in hash notation, showing the buffer name.</source>
          <target state="translated">バッファには読み込み構文はありません。バッファはハッシュ表記で表示され、バッファ名が表示されます。</target>
        </trans-unit>
        <trans-unit id="c849b71243437a37c01b415363a9e00d3f75220f" translate="yes" xml:space="preserve">
          <source>Buffers in Emacs editing are objects that have distinct names and hold text that can be edited. Buffers appear to Lisp programs as a special data type. You can think of the contents of a buffer as a string that you can extend; insertions and deletions may occur in any part of the buffer. See &lt;a href=&quot;text#Text&quot;&gt;Text&lt;/a&gt;.</source>
          <target state="translated">Buffers in Emacs editing are objects that have distinct names and hold text that can be edited. Buffers appear to Lisp programs as a special data type. You can think of the contents of a buffer as a string that you can extend; insertions and deletions may occur in any part of the buffer. See &lt;a href=&quot;text#Text&quot;&gt;Text&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="5d9c37d98ed9d04e80b306fce37d88ced34649fb" translate="yes" xml:space="preserve">
          <source>Buffers that are ephemeral and generally uninteresting to the user have names starting with a space, so that the &lt;code&gt;list-buffers&lt;/code&gt; and &lt;code&gt;buffer-menu&lt;/code&gt; commands don&amp;rsquo;t mention them (but if such a buffer visits a file, it &lt;strong&gt;is&lt;/strong&gt; mentioned). A name starting with space also initially disables recording undo information; see &lt;a href=&quot;undo#Undo&quot;&gt;Undo&lt;/a&gt;.</source>
          <target state="translated">Buffers that are ephemeral and generally uninteresting to the user have names starting with a space, so that the &lt;code&gt;list-buffers&lt;/code&gt; and &lt;code&gt;buffer-menu&lt;/code&gt; commands don&amp;rsquo;t mention them (but if such a buffer visits a file, it &lt;strong&gt;is&lt;/strong&gt; mentioned). A name starting with space also initially disables recording undo information; see &lt;a href=&quot;undo#Undo&quot;&gt;Undo&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="330d744f9b4b4abc2c70c54c6b6b286c98dced2b" translate="yes" xml:space="preserve">
          <source>Build a new evaluation list from the contents of the buffer (&lt;code&gt;edebug-update-eval-list&lt;/code&gt;).</source>
          <target state="translated">Build a new evaluation list from the contents of the buffer ( &lt;code&gt;edebug-update-eval-list&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="317d4e3a3a04e5eea5fc26c035b1ef9dd209902c" translate="yes" xml:space="preserve">
          <source>Build new types from other types or data.</source>
          <target state="translated">他の型やデータから新しい型を構築します。</target>
        </trans-unit>
        <trans-unit id="b1f5f048510e296c0efaf69fd58cab73cd422bd8" translate="yes" xml:space="preserve">
          <source>Building Cons Cells and Lists</source>
          <target state="translated">ビルコンセルとリスト</target>
        </trans-unit>
        <trans-unit id="bdc049a5ba45c2fd12b217cecac69626d97e5db0" translate="yes" xml:space="preserve">
          <source>Building Emacs</source>
          <target state="translated">Emacsの構築</target>
        </trans-unit>
        <trans-unit id="f53b042cb4d6b635c59397892faa831033884cbc" translate="yes" xml:space="preserve">
          <source>Building Emacs requires GNU Make version 3.81 or later.</source>
          <target state="translated">EmacsをビルドするにはGNU Makeバージョン3.81以降が必要です。</target>
        </trans-unit>
        <trans-unit id="79b6b1f02a69a8e5241277580817571424a17daa" translate="yes" xml:space="preserve">
          <source>Building and dumping Emacs; internal data structures.</source>
          <target state="translated">Emacs の構築とダンプ、内部データ構造。</target>
        </trans-unit>
        <trans-unit id="34812aaa741da1103c385a52808aa91b80e9594f" translate="yes" xml:space="preserve">
          <source>Built-in &lt;code&gt;rx&lt;/code&gt; forms, like &lt;code&gt;digit&lt;/code&gt; and &lt;code&gt;group&lt;/code&gt;, cannot be redefined.</source>
          <target state="translated">Built-in &lt;code&gt;rx&lt;/code&gt; forms, like &lt;code&gt;digit&lt;/code&gt; and &lt;code&gt;group&lt;/code&gt; , cannot be redefined.</target>
        </trans-unit>
        <trans-unit id="f1c7bd5dfbc70feff63bb4c975105aed8228177c" translate="yes" xml:space="preserve">
          <source>Builtin Commands</source>
          <target state="translated">組み込みコマンド</target>
        </trans-unit>
        <trans-unit id="eb37717154ce80760d9e952968529a057b6b75e2" translate="yes" xml:space="preserve">
          <source>Builtin Constants</source>
          <target state="translated">組み込み定数</target>
        </trans-unit>
        <trans-unit id="ce64a3485e5540eb2d738ffca93bc4a6a99dac9d" translate="yes" xml:space="preserve">
          <source>Builtin Functions</source>
          <target state="translated">ビルトイン機能</target>
        </trans-unit>
        <trans-unit id="a9cc087245dc67aa0bcbea3954c8f85e35fb9e6d" translate="yes" xml:space="preserve">
          <source>Builtin Macros</source>
          <target state="translated">ビルトインマクロ</target>
        </trans-unit>
        <trans-unit id="c87bbec5d329be7d9ab3d4f7f28179b67b985893" translate="yes" xml:space="preserve">
          <source>Builtin Special Forms</source>
          <target state="translated">ビルトインされた特殊フォーム</target>
        </trans-unit>
        <trans-unit id="ce27ad322fdf4fa3514cbeb626501e0ed27f14ae" translate="yes" xml:space="preserve">
          <source>Builtin User Options</source>
          <target state="translated">ビルトインユーザーオプション</target>
        </trans-unit>
        <trans-unit id="843ed68047eb8a91c66fd38a5ea1a9307d042738" translate="yes" xml:space="preserve">
          <source>Builtin Variables</source>
          <target state="translated">ビルトイン変数</target>
        </trans-unit>
        <trans-unit id="5067c37a304c3bbf7192b5da6e72fcd4d8ed1b67" translate="yes" xml:space="preserve">
          <source>But if you type a control combination not in</source>
          <target state="translated">にないコントロールの組み合わせを入力すると</target>
        </trans-unit>
        <trans-unit id="5a9ec335ac0058bc8871067e4469ec28043b246e" translate="yes" xml:space="preserve">
          <source>But this will create conflicts for &lt;code&gt;&quot;ELSE&quot;&lt;/code&gt;: on the one hand, the IF rule implies (among many other things) that &lt;code&gt;&quot;ELSE&quot; = &quot;END&quot;&lt;/code&gt;; but on the other hand, since &lt;code&gt;&quot;ELSE&quot;&lt;/code&gt; appears within &lt;code&gt;cases&lt;/code&gt;, which appears left of &lt;code&gt;&quot;END&quot;&lt;/code&gt;, we also have &lt;code&gt;&quot;ELSE&quot; &amp;gt; &quot;END&quot;&lt;/code&gt;. We can solve the conflict either by using:</source>
          <target state="translated">But this will create conflicts for &lt;code&gt;&quot;ELSE&quot;&lt;/code&gt; : on the one hand, the IF rule implies (among many other things) that &lt;code&gt;&quot;ELSE&quot; = &quot;END&quot;&lt;/code&gt; ; but on the other hand, since &lt;code&gt;&quot;ELSE&quot;&lt;/code&gt; appears within &lt;code&gt;cases&lt;/code&gt; , which appears left of &lt;code&gt;&quot;END&quot;&lt;/code&gt; , we also have &lt;code&gt;&quot;ELSE&quot; &amp;gt; &quot;END&quot;&lt;/code&gt; . We can solve the conflict either by using:</target>
        </trans-unit>
        <trans-unit id="2a081c2786dbf00aa6d8f9b177ec4a1ad92a73fe" translate="yes" xml:space="preserve">
          <source>But this would add multiple elements if the library is reloaded. To avoid the problem, use &lt;code&gt;add-to-list&lt;/code&gt; (see &lt;a href=&quot;list-variables#List-Variables&quot;&gt;List Variables&lt;/a&gt;):</source>
          <target state="translated">But this would add multiple elements if the library is reloaded. To avoid the problem, use &lt;code&gt;add-to-list&lt;/code&gt; (see &lt;a href=&quot;list-variables#List-Variables&quot;&gt;List Variables&lt;/a&gt;):</target>
        </trans-unit>
        <trans-unit id="07ec1dfa598ebfb12e7443602444d7a051d224dd" translate="yes" xml:space="preserve">
          <source>But we recommend &lt;code&gt;copy-sequence&lt;/code&gt; for this purpose (see &lt;a href=&quot;sequence-functions#Sequence-Functions&quot;&gt;Sequence Functions&lt;/a&gt;).</source>
          <target state="translated">ただし、この目的には &lt;code&gt;copy-sequence&lt;/code&gt; をお勧めします（&lt;a href=&quot;sequence-functions#Sequence-Functions&quot;&gt;シーケンス関数を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="c0bd785491e817f0f44e14205af6a59e1a447d90" translate="yes" xml:space="preserve">
          <source>But you should use &lt;code&gt;advice-add&lt;/code&gt; and &lt;code&gt;advice-remove&lt;/code&gt; for that instead. This separate set of functions to manipulate pieces of advice applied to named functions, offers the following extra features compared to &lt;code&gt;add-function&lt;/code&gt;: they know how to deal with macros and autoloaded functions, they let &lt;code&gt;describe-function&lt;/code&gt; preserve the original docstring as well as document the added advice, and they let you add and remove advice before a function is even defined.</source>
          <target state="translated">ただし、代わりに、 &lt;code&gt;advice-remove&lt;/code&gt; &lt;code&gt;advice-add&lt;/code&gt; およびadvice-removeを使用する必要があります。名前付き関数に適用されるアドバイスを操作するこの別個の関数セットは、 &lt;code&gt;add-function&lt;/code&gt; と比較して、次の追加機能を提供します。マクロと自動ロードされた関数の処理方法を知っており、 &lt;code&gt;describe-function&lt;/code&gt; に元のdocstringとドキュメントを保持させます。追加されたアドバイス。関数が定義される前にアドバイスを追加および削除できます。</target>
        </trans-unit>
        <trans-unit id="7d8a0e63cd1a06ea0e2679c87030f5570105b2a4" translate="yes" xml:space="preserve">
          <source>Button Buffer Commands</source>
          <target state="translated">ボタンバッファコマンド</target>
        </trans-unit>
        <trans-unit id="d055960c135678f62a49f9b6f7a5d94add754440" translate="yes" xml:space="preserve">
          <source>Button Properties</source>
          <target state="translated">ボタンのプロパティ</target>
        </trans-unit>
        <trans-unit id="41fa24540db10de11f239ddb922c6363c465adf0" translate="yes" xml:space="preserve">
          <source>Button Types</source>
          <target state="translated">ボタンの種類</target>
        </trans-unit>
        <trans-unit id="1e308eff60f72b546296987374ea4612fa02db86" translate="yes" xml:space="preserve">
          <source>Button properties with special meanings.</source>
          <target state="translated">特別な意味を持つボタンのプロパティ。</target>
        </trans-unit>
        <trans-unit id="e8bf727af91015f6f823f13b436c2880666b454a" translate="yes" xml:space="preserve">
          <source>Button-Down Events</source>
          <target state="translated">ボタンダウンイベント</target>
        </trans-unit>
        <trans-unit id="503d46db37b0db45db898aabed77244252918ca2" translate="yes" xml:space="preserve">
          <source>Buttons</source>
          <target state="translated">Buttons</target>
        </trans-unit>
        <trans-unit id="4c379f628ac77bed975fa656ab1146980f7bff07" translate="yes" xml:space="preserve">
          <source>Buttons are associated with a region of text, using an overlay or text properties to hold button-specific information, all of which are initialized from the button&amp;rsquo;s type (which defaults to the built-in button type &lt;code&gt;button&lt;/code&gt;). Like all Emacs text, the appearance of the button is governed by the &lt;code&gt;face&lt;/code&gt; property; by default (via the &lt;code&gt;face&lt;/code&gt; property inherited from the &lt;code&gt;button&lt;/code&gt; button-type) this is a simple underline, like a typical web-page link.</source>
          <target state="translated">ボタンはテキストの領域に関連付けられ、オーバーレイまたはテキストプロパティを使用してボタン固有の情報を保持します。これらの情報はすべて、ボタンのタイプ（デフォルトでは組み込みのボタンタイプ &lt;code&gt;button&lt;/code&gt; ）から初期化されます。すべてのEmacsテキストと同様に、ボタンの外観は &lt;code&gt;face&lt;/code&gt; プロパティによって制御されます。デフォルトでは（ &lt;code&gt;button&lt;/code&gt; ボタンタイプから継承された &lt;code&gt;face&lt;/code&gt; プロパティを介して）、これは一般的なWebページのリンクのような単純な下線です。</target>
        </trans-unit>
        <trans-unit id="91c7c66c2c1453401e19d50861895a10fdbd7d8e" translate="yes" xml:space="preserve">
          <source>By &lt;em&gt;separator&lt;/em&gt;, we mean here a token whose sole purpose is to separate various elements within some enclosing syntactic construct, and which does not have any semantic significance in itself (i.e., it would typically not exist as a node in an abstract syntax tree).</source>
          <target state="translated">することにより&lt;em&gt;、セパレータ&lt;/em&gt;、我々はここでその唯一の目的一部囲む構文構造内の様々な要素を分離することであり、それ自体があらゆる意味的な重要性を持っていない（すなわち、それは一般的に抽象構文木のノードとして存在しません）のトークンを意味します。</target>
        </trans-unit>
        <trans-unit id="1286985575cca5c62cde4a1b9229a630c85b3182" translate="yes" xml:space="preserve">
          <source>By contrast, a Lisp program can do insertion with inheritance or without, depending on the choice of insertion primitive. The ordinary text insertion functions, such as &lt;code&gt;insert&lt;/code&gt;, do not inherit any properties. They insert text with precisely the properties of the string being inserted, and no others. This is correct for programs that copy text from one context to another&amp;mdash;for example, into or out of the kill ring. To insert with inheritance, use the special primitives described in this section. Self-inserting characters inherit properties because they work using these primitives.</source>
          <target state="translated">対照的に、Lispプログラムは、挿入プリミティブの選択に応じて、継承の有無にかかわらず挿入を行うことができます。 &lt;code&gt;insert&lt;/code&gt; などの通常のテキスト挿入関数は、プロパティを継承しません。挿入されている文字列のプロパティを正確に含むテキストを挿入し、他のプロパティは挿入しません。これは、あるコンテキストから別のコンテキストにテキストをコピーするプログラム（たとえば、キルリングの内外）に適しています。継承を使用して挿入するには、このセクションで説明する特別なプリミティブを使用します。自己挿入文字は、これらのプリミティブを使用して機能するため、プロパティを継承します。</target>
        </trans-unit>
        <trans-unit id="78d9ed9ffae62086921d390616b3fa2296925abd" translate="yes" xml:space="preserve">
          <source>By contrast, for an array of keyboard input characters (such as a key sequence), a vector may be necessary, because many keyboard input characters are outside the range that will fit in a string. See &lt;a href=&quot;key-sequence-input#Key-Sequence-Input&quot;&gt;Key Sequence Input&lt;/a&gt;.</source>
          <target state="translated">対照的に、キーボード入力文字の配列（キーシーケンスなど）の場合、多くのキーボード入力文字が文字列に収まる範囲外にあるため、ベクトルが必要になる場合があります。&lt;a href=&quot;key-sequence-input#Key-Sequence-Input&quot;&gt;キーシーケンス入力を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="12144324278ff8b90e0a364f623b2e54380c481c" translate="yes" xml:space="preserve">
          <source>By contrast, in programs that manipulate function definitions for other purposes, it is better to use &lt;code&gt;fset&lt;/code&gt;, which does not keep such records. See &lt;a href=&quot;function-cells#Function-Cells&quot;&gt;Function Cells&lt;/a&gt;.</source>
          <target state="translated">対照的に、他の目的で関数定義を操作するプログラムでは、そのようなレコードを保持しない &lt;code&gt;fset&lt;/code&gt; を使用することをお勧めします。&lt;a href=&quot;function-cells#Function-Cells&quot;&gt;関数セルを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="e28b30f108e8c96578a3e1fc9b8f49f98c5c829d" translate="yes" xml:space="preserve">
          <source>By contrast, object-oriented programs use &lt;em&gt;polymorphic functions&lt;/em&gt;: a set of specialized functions having the same name, each one of which was written for a certain specific set of argument types. Which of the functions is actually called is decided at run time based on the types of the actual arguments.</source>
          <target state="translated">対照的に、オブジェクト指向プログラムは&lt;em&gt;ポリモーフィック関数を&lt;/em&gt;使用し&lt;em&gt;ます&lt;/em&gt;。つまり、同じ名前を持つ特殊な関数のセットであり、それぞれが特定の引数タイプのセット用に作成されています。どの関数が実際に呼び出されるかは、実際の引数のタイプに基づいて実行時に決定されます。</target>
        </trans-unit>
        <trans-unit id="955d83a02806ccf2dfd155108f9d134b64fbc8d8" translate="yes" xml:space="preserve">
          <source>By contrast, the following example calls a function without any symbol function indirection, because the first element is an anonymous Lisp function, not a symbol.</source>
          <target state="translated">対照的に、次の例では、最初の要素がシンボルではなく匿名の Lisp 関数であるため、シンボル関数のインダイレクションなしで関数を呼び出しています。</target>
        </trans-unit>
        <trans-unit id="90d9b7ac9f08bada9648d4c6e90292b9adc5f05d" translate="yes" xml:space="preserve">
          <source>By contrast, using only error symbols without condition names would seriously decrease the power of &lt;code&gt;condition-case&lt;/code&gt;. Condition names make it possible to categorize errors at various levels of generality when you write an error handler. Using error symbols alone would eliminate all but the narrowest level of classification.</source>
          <target state="translated">対照的に、条件名のないエラーシンボルのみを使用すると、 &lt;code&gt;condition-case&lt;/code&gt; の能力が大幅に低下します。条件名を使用すると、エラーハンドラーを作成するときに、さまざまなレベルの一般性でエラーを分類できます。エラーシンボルのみを使用すると、最も狭いレベルの分類を除くすべてが排除されます。</target>
        </trans-unit>
        <trans-unit id="c262827c2a008bc82000c720bb603706e79b1b54" translate="yes" xml:space="preserve">
          <source>By convention, any argument whose name contains the name of a type (e.g., &lt;var&gt;integer&lt;/var&gt;, &lt;var&gt;integer1&lt;/var&gt; or &lt;var&gt;buffer&lt;/var&gt;) is expected to be of that type. A plural of a type (such as &lt;var&gt;buffers&lt;/var&gt;) often means a list of objects of that type. An argument named &lt;var&gt;object&lt;/var&gt; may be of any type. (For a list of Emacs object types, see &lt;a href=&quot;lisp-data-types#Lisp-Data-Types&quot;&gt;Lisp Data Types&lt;/a&gt;.) An argument with any other sort of name (e.g., &lt;var&gt;new-file&lt;/var&gt;) is specific to the function; if the function has a documentation string, the type of the argument should be described there (see &lt;a href=&quot;documentation#Documentation&quot;&gt;Documentation&lt;/a&gt;).</source>
          <target state="translated">慣例により、名前に型の名前（たとえば、 &lt;var&gt;integer&lt;/var&gt; 、 &lt;var&gt;integer1&lt;/var&gt; 、または &lt;var&gt;buffer&lt;/var&gt; ）が含まれる引数は、その型であると想定されます。型の複数形（ &lt;var&gt;buffers&lt;/var&gt; など）は、多くの場合、その型のオブジェクトのリストを意味します。 &lt;var&gt;object&lt;/var&gt; という名前の引数は、どのタイプでもかまいません。（Emacsオブジェクトタイプのリストについては、&lt;a href=&quot;lisp-data-types#Lisp-Data-Types&quot;&gt;Lispデータタイプを&lt;/a&gt;参照してください。）他の種類の名前（たとえば、 &lt;var&gt;new-file&lt;/var&gt; ）を持つ引数は、関数に固有です。関数にドキュメント文字列がある場合は、引数のタイプをそこに記述する必要があります（&lt;a href=&quot;documentation#Documentation&quot;&gt;ドキュメントを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="29edadc76625945d3e9732385f723229ac2c6358" translate="yes" xml:space="preserve">
          <source>By convention, if a function&amp;rsquo;s symbol consists of two names separated by &amp;lsquo;</source>
          <target state="translated">慣例により、関数のシンボルが 'で区切られた2つの名前で構成されている場合</target>
        </trans-unit>
        <trans-unit id="81288ed35b7f8aec4f961beebc97c447985deae4" translate="yes" xml:space="preserve">
          <source>By convention, the entries &lt;code&gt;window-height&lt;/code&gt;, &lt;code&gt;window-width&lt;/code&gt; and &lt;code&gt;preserve-size&lt;/code&gt; are applied after the chosen window&amp;rsquo;s buffer has been set up and if and only if that window never showed another buffer before. More precisely, the latter means that the window must have been either created by the current &lt;code&gt;display-buffer&lt;/code&gt; call or the window was created earlier by &lt;code&gt;display-buffer&lt;/code&gt; to show the buffer and never was used to show another buffer until it was reused by the current invocation of &lt;code&gt;display-buffer&lt;/code&gt;.</source>
          <target state="translated">慣例により、エントリ &lt;code&gt;window-height&lt;/code&gt; 、 &lt;code&gt;window-width&lt;/code&gt; 、 &lt;code&gt;preserve-size&lt;/code&gt; は、選択したウィンドウのバッファが設定された後、そのウィンドウが以前に別のバッファを表示したことがない場合にのみ適用されます。より正確には、後者は、ウィンドウが現在の &lt;code&gt;display-buffer&lt;/code&gt; 呼び出しによって作成されたか、ウィンドウを &lt;code&gt;display-buffer&lt;/code&gt; ためにdisplay-bufferによって以前に作成され、現在の人によって再利用されるまで別のバッファーを表示するために使用されなかったことを意味します &lt;code&gt;display-buffer&lt;/code&gt; の呼び出し。</target>
        </trans-unit>
        <trans-unit id="961315a74279b10aa81793f8f190e6ad9e46b005" translate="yes" xml:space="preserve">
          <source>By convention, the height of the chosen window is adjusted only if the window is part of a vertical combination (see &lt;a href=&quot;windows-and-frames#Windows-and-Frames&quot;&gt;Windows and Frames&lt;/a&gt;) to avoid changing the height of other, unrelated windows. Also, this entry should be processed only under certain conditions which are specified right below this list.</source>
          <target state="translated">慣例により、選択したウィンドウの高さは、ウィンドウが垂直方向の組み合わせの一部である場合にのみ調整され（ウィンドウ&lt;a href=&quot;windows-and-frames#Windows-and-Frames&quot;&gt;とフレームを&lt;/a&gt;参照）、他の無関係なウィンドウの高さを変更しないようにします。また、このエントリは、このリストのすぐ下に指定されている特定の条件下でのみ処理する必要があります。</target>
        </trans-unit>
        <trans-unit id="46e87bdc0265fdf29ddfc65a07831e51565c646d" translate="yes" xml:space="preserve">
          <source>By convention, the pixels of the display at the values returned for &lt;var&gt;left&lt;/var&gt; and &lt;var&gt;top&lt;/var&gt; are considered to be inside (part of) &lt;var&gt;frame&lt;/var&gt;. Hence, if &lt;var&gt;left&lt;/var&gt; and &lt;var&gt;top&lt;/var&gt; are both zero, the pixel at the display&amp;rsquo;s origin is part of &lt;var&gt;frame&lt;/var&gt;. The pixels at &lt;var&gt;bottom&lt;/var&gt; and &lt;var&gt;right&lt;/var&gt;, on the other hand, are considered to lie immediately outside &lt;var&gt;frame&lt;/var&gt;. This means that if you have, for example, two side-by-side frames positioned such that the right outer edge of the frame on the left equals the left outer edge of the frame on the right, the pixels at that edge show a part of the frame on the right.</source>
          <target state="translated">慣例により、 &lt;var&gt;left&lt;/var&gt; と &lt;var&gt;top&lt;/var&gt; 返される値のディスプレイのピクセルは、 &lt;var&gt;frame&lt;/var&gt; 内側（の一部）と見なされます。したがって、 &lt;var&gt;left&lt;/var&gt; と &lt;var&gt;top&lt;/var&gt; が両方ともゼロの場合、ディスプレイの原点のピクセルは &lt;var&gt;frame&lt;/var&gt; 一部です。画素の &lt;var&gt;bottom&lt;/var&gt; 及び &lt;var&gt;right&lt;/var&gt; 、一方で、すぐ外にあると考えられている &lt;var&gt;frame&lt;/var&gt; 。つまり、たとえば、左側のフレームの右外縁が右のフレームの左外縁と等しくなるように2つのフレームを並べて配置した場合、その端のピクセルは一部を示します。右側のフレームの。</target>
        </trans-unit>
        <trans-unit id="6a4bd0ccbb65351d0542d9701b9e76e9ff39eb97" translate="yes" xml:space="preserve">
          <source>By convention, the width of the chosen window is adjusted only if the window is part of a horizontal combination (see &lt;a href=&quot;windows-and-frames#Windows-and-Frames&quot;&gt;Windows and Frames&lt;/a&gt;) to avoid changing the width of other, unrelated windows. Also, this entry should be processed under only certain conditions which are specified right below this list.</source>
          <target state="translated">慣例により、選択したウィンドウの幅は、ウィンドウが水平方向の組み合わせの一部である場合にのみ調整され（ウィンドウ&lt;a href=&quot;windows-and-frames#Windows-and-Frames&quot;&gt;とフレームを&lt;/a&gt;参照）、他の無関係なウィンドウの幅が変更されないようにします。また、このエントリは、このリストのすぐ下に指定されている特定の条件下でのみ処理する必要があります。</target>
        </trans-unit>
        <trans-unit id="f1f59fea98d20db1b1e18d570c20cefba2dd601a" translate="yes" xml:space="preserve">
          <source>By convention, vertical offsets increase &amp;ldquo;downwards&amp;rdquo;. This means that the height of a frame is obtained by subtracting the offset of its top edge from that of its bottom edge. Horizontal offsets increase &amp;ldquo;rightwards&amp;rdquo;, as expected, so a frame&amp;rsquo;s width is calculated by subtracting the offset of its left edge from that of its right edge.</source>
          <target state="translated">慣例により、垂直オフセットは「下向き」に増加します。これは、フレームの高さは、下端のオフセットから上端のオフセットを差し引くことによって得られることを意味します。水平オフセットは予想どおり「右方向」に増加するため、フレームの幅は、右端のオフセットから左端のオフセットを差し引くことによって計算されます。</target>
        </trans-unit>
        <trans-unit id="5bc4ab559bcd3485770406aa3206099c2c318a03" translate="yes" xml:space="preserve">
          <source>By convention, when defining variables of a &amp;ldquo;native&amp;rdquo; type (&lt;code&gt;int&lt;/code&gt; and &lt;code&gt;bool&lt;/code&gt;), the name of the C variable is the name of the Lisp variable with &lt;code&gt;-&lt;/code&gt; replaced by &lt;code&gt;_&lt;/code&gt;. When the variable has type &lt;code&gt;Lisp_Object&lt;/code&gt;, the convention is to also prefix the C variable name with &lt;code&gt;V&lt;/code&gt;. i.e.</source>
          <target state="translated">慣例により、「ネイティブ」タイプ（ &lt;code&gt;int&lt;/code&gt; および &lt;code&gt;bool&lt;/code&gt; ）の変数を定義する場合、C変数の名前はLisp変数の名前であり、 &lt;code&gt;-&lt;/code&gt; は &lt;code&gt;_&lt;/code&gt; に置き換えられます。変数のタイプが &lt;code&gt;Lisp_Object&lt;/code&gt; の場合、慣例では、C変数名の前に &lt;code&gt;V&lt;/code&gt; を付けます。すなわち</target>
        </trans-unit>
        <trans-unit id="0b42bb254be6d5ac55cc35f34239ee11afcaf79a" translate="yes" xml:space="preserve">
          <source>By convention, you should put the &lt;code&gt;interactive&lt;/code&gt; form in the function body, as the first top-level form. If there is an &lt;code&gt;interactive&lt;/code&gt; form in both the &lt;code&gt;interactive-form&lt;/code&gt; symbol property and the function body, the former takes precedence. The &lt;code&gt;interactive-form&lt;/code&gt; symbol property can be used to add an interactive form to an existing function, or change how its arguments are processed interactively, without redefining the function.</source>
          <target state="translated">慣例により、最初のトップレベルフォームとして、 &lt;code&gt;interactive&lt;/code&gt; フォームを関数本体に配置する必要があります。 &lt;code&gt;interactive-form&lt;/code&gt; シンボルプロパティと関数本体の両方に &lt;code&gt;interactive&lt;/code&gt; フォームがある場合は、前者が優先されます。 &lt;code&gt;interactive-form&lt;/code&gt; シンボルプロパティは、関数を再定義することなく、既存の機能にインタラクティブフォームを追加したり、その引数が対話的に処理する方法を変更するために使用することができます。</target>
        </trans-unit>
        <trans-unit id="bd6cd1964a58199f17af10ed0710e7304dbef795" translate="yes" xml:space="preserve">
          <source>By default &lt;code&gt;switch-to-prev-buffer&lt;/code&gt; and &lt;code&gt;switch-to-next-buffer&lt;/code&gt; can switch to a buffer that is already shown in another window. The following option can be used to override this behavior.</source>
          <target state="translated">デフォルトでは、 &lt;code&gt;switch-to-prev-buffer&lt;/code&gt; および &lt;code&gt;switch-to-next-buffer&lt;/code&gt; は、別のウィンドウにすでに表示されているバッファーに切り替えることができます。次のオプションを使用して、この動作をオーバーライドできます。</target>
        </trans-unit>
        <trans-unit id="c2e5b9fa592a3409a2011f26d6c0a6701c7e5da1" translate="yes" xml:space="preserve">
          <source>By default both IPv4 and IPv6 lookups are attempted. The optional argument &lt;var&gt;family&lt;/var&gt; controls this behavior, specifying the symbol &lt;code&gt;ipv4&lt;/code&gt; or &lt;code&gt;ipv6&lt;/code&gt; restricts lookups to IPv4 and IPv6 respectively.</source>
          <target state="translated">デフォルトでは、IPv4とIPv6の両方のルックアップが試行されます。オプションの引数 &lt;var&gt;family&lt;/var&gt; はこの動作を制御し、シンボル &lt;code&gt;ipv4&lt;/code&gt; または &lt;code&gt;ipv6&lt;/code&gt; を指定すると、ルックアップがそれぞれIPv4およびIPv6に制限されます。</target>
        </trans-unit>
        <trans-unit id="af6f338f5f9982890241460392dfd56c79820ad8" translate="yes" xml:space="preserve">
          <source>By default the dumped</source>
          <target state="translated">デフォルトでは、ダンプされた</target>
        </trans-unit>
        <trans-unit id="ec8b6ebd7649499745ebeafd06ed0b949a38dabd" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;eval-region&lt;/code&gt; does not produce any output. However, if &lt;var&gt;stream&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, any output produced by output functions (see &lt;a href=&quot;output-functions#Output-Functions&quot;&gt;Output Functions&lt;/a&gt;), as well as the values that result from evaluating the expressions in the region are printed using &lt;var&gt;stream&lt;/var&gt;. See &lt;a href=&quot;output-streams#Output-Streams&quot;&gt;Output Streams&lt;/a&gt;.</source>
          <target state="translated">デフォルトでは、 &lt;code&gt;eval-region&lt;/code&gt; は出力を生成しません。しかし、 &lt;var&gt;stream&lt;/var&gt; 非ある &lt;code&gt;nil&lt;/code&gt; 、任意の出力は、出力関数（参照によって生成&lt;a href=&quot;output-functions#Output-Functions&quot;&gt;出力関数の&lt;/a&gt;領域に式を評価した結果を用いて印刷されていること）、ならびに値の &lt;var&gt;stream&lt;/var&gt; 。&lt;a href=&quot;output-streams#Output-Streams&quot;&gt;出力ストリームを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="a53473f0b03225bb59517eff6e8b663daa1b7774" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;switch-to-buffer&lt;/code&gt; tries to preserve &lt;code&gt;window-point&lt;/code&gt;. This behavior can be tuned using the following option.</source>
          <target state="translated">デフォルトでは、 &lt;code&gt;switch-to-buffer&lt;/code&gt; は &lt;code&gt;window-point&lt;/code&gt; を保持しようとします。この動作は、次のオプションを使用して調整できます。</target>
        </trans-unit>
        <trans-unit id="ee1412f6a4896bbf8989a04623bf820b553fdea4" translate="yes" xml:space="preserve">
          <source>By default, &lt;var&gt;keywords&lt;/var&gt; are added at the beginning of &lt;code&gt;font-lock-keywords&lt;/code&gt;. If the optional argument &lt;var&gt;how&lt;/var&gt; is &lt;code&gt;set&lt;/code&gt;, they are used to replace the value of &lt;code&gt;font-lock-keywords&lt;/code&gt;. If &lt;var&gt;how&lt;/var&gt; is any other non-&lt;code&gt;nil&lt;/code&gt; value, they are added at the end of &lt;code&gt;font-lock-keywords&lt;/code&gt;.</source>
          <target state="translated">デフォルトでは、 &lt;var&gt;keywords&lt;/var&gt; は &lt;code&gt;font-lock-keywords&lt;/code&gt; の先頭に追加されます。オプションの引数 &lt;var&gt;how&lt;/var&gt; が &lt;code&gt;set&lt;/code&gt; ている場合、それらは &lt;code&gt;font-lock-keywords&lt;/code&gt; の値を置き換えるために使用されます。他の &lt;code&gt;nil&lt;/code&gt; 以外の値がどの &lt;var&gt;how&lt;/var&gt; いる場合は、 &lt;code&gt;font-lock-keywords&lt;/code&gt; の最後に追加されます。</target>
        </trans-unit>
        <trans-unit id="10521942e8c52f15b21a03de5615c1566c427141" translate="yes" xml:space="preserve">
          <source>By default, Emacs determines the base direction of each paragraph by looking at the text at its beginning. The precise method of determining the base direction is specified by the</source>
          <target state="translated">デフォルトでは、Emacs は、各段落の先頭のテキストを見て、各段落の基底方向を決定します。基底方向を決定する正確な方法は</target>
        </trans-unit>
        <trans-unit id="d9bc871638c9fc2d81d98a2b4d5d096f7d797fd7" translate="yes" xml:space="preserve">
          <source>By default, Emacs makes a single backup file for each file edited. You can alternatively request numbered backups; then each new backup file gets a new name. You can delete old numbered backups when you don&amp;rsquo;t want them any more, or Emacs can delete them automatically.</source>
          <target state="translated">デフォルトでは、Emacsは編集されたファイルごとに1つのバックアップファイルを作成します。または、番号付きのバックアップをリクエストすることもできます。次に、新しいバックアップファイルごとに新しい名前が付けられます。古い番号のバックアップが不要になったときに削除することも、Emacsが自動的に削除することもできます。</target>
        </trans-unit>
        <trans-unit id="eb5fb3e174ce7ebaa56506756450880c9f6707f5" translate="yes" xml:space="preserve">
          <source>By default, Emacs starts in multibyte mode: it stores the contents of buffers and strings using an internal encoding that represents non-</source>
          <target state="translated">デフォルトでは、Emacs はマルチバイトモードで起動します。</target>
        </trans-unit>
        <trans-unit id="2439b1b4fb24aa8804e6e4ef3da82558ce16fc14" translate="yes" xml:space="preserve">
          <source>By default, Emacs tries to keep the number of lines and columns of a frame&amp;rsquo;s text area unaltered when, for example, toggling its menu or tool bar, changing its default font or setting the width of any of its scroll bars. This means that in such case Emacs must ask the window manager to resize the frame&amp;rsquo;s window in order to accommodate the size change.</source>
          <target state="translated">デフォルトでは、Emacsは、メニューやツールバーを切り替えたり、デフォルトのフォントを変更したり、スクロールバーの幅を設定したりするときに、フレームのテキスト領域の行数と列数を変更しないようにします。これは、そのような場合、Emacsはサイズ変更に対応するためにウィンドウマネージャーにフレームのウィンドウのサイズを変更するように依頼する必要があることを意味します。</target>
        </trans-unit>
        <trans-unit id="c3302471f75eaf89ac88db46d17c6df0b07bc2a8" translate="yes" xml:space="preserve">
          <source>By default, a text property is rear-sticky but not front-sticky; thus, the default is to inherit all the properties of the preceding character, and nothing from the following character.</source>
          <target state="translated">デフォルトでは、テキストのプロパティは後方に粘着しますが、前方に粘着しないようになっています。</target>
        </trans-unit>
        <trans-unit id="b6bdb814df1ff8f4484bd14e8665079dde59b196" translate="yes" xml:space="preserve">
          <source>By default, all subdirectories are descended into. If &lt;var&gt;predicate&lt;/var&gt; is &lt;code&gt;t&lt;/code&gt;, errors when trying to descend into a subdirectory (for instance, if it&amp;rsquo;s not readable by this user) are ignored. If it&amp;rsquo;s neither &lt;code&gt;nil&lt;/code&gt; nor &lt;code&gt;t&lt;/code&gt;, it should be a function that takes one parameter (the subdirectory name) and should return non-&lt;code&gt;nil&lt;/code&gt; if the directory is to be descended into.</source>
          <target state="translated">デフォルトでは、すべてのサブディレクトリが子孫になります。 &lt;var&gt;predicate&lt;/var&gt; が &lt;code&gt;t&lt;/code&gt; の場合、サブディレクトリに降下しようとしたときのエラー（たとえば、このユーザーが読み取れない場合）は無視されます。 &lt;code&gt;nil&lt;/code&gt; でも &lt;code&gt;t&lt;/code&gt; でもない場合は、1つのパラメーター（サブディレクトリ名）を受け取る関数である必要があり、ディレクトリの子孫になる場合は &lt;code&gt;nil&lt;/code&gt; 以外を返す必要があります。</target>
        </trans-unit>
        <trans-unit id="34620b2db91cbe790eb8b807c0d8c806964cdff3" translate="yes" xml:space="preserve">
          <source>By default, format specifications correspond to successive values from &lt;var&gt;objects&lt;/var&gt;. Thus, the first format specification in &lt;var&gt;string&lt;/var&gt; uses the first such value, the second format specification uses the second such value, and so on. Any extra format specifications (those for which there are no corresponding values) cause an error. Any extra values to be formatted are ignored.</source>
          <target state="translated">デフォルトでは、フォーマット仕様は &lt;var&gt;objects&lt;/var&gt; からの連続する値に対応します。したがって、 &lt;var&gt;string&lt;/var&gt; 最初のフォーマット指定は最初のそのような値を使用し、2番目のフォーマット指定は2番目のそのような値を使用します。追加のフォーマット仕様（対応する値がないもの）があると、エラーが発生します。フォーマットする余分な値は無視されます。</target>
        </trans-unit>
        <trans-unit id="cfab6cab0b08bc4c2da07991fa913322ec8175a9" translate="yes" xml:space="preserve">
          <source>By default, frame parameters are saved and restored by the desktop library functions (see &lt;a href=&quot;desktop-save-mode#Desktop-Save-Mode&quot;&gt;Desktop Save Mode&lt;/a&gt;) when the variable &lt;code&gt;desktop-restore-frames&lt;/code&gt; is non-&lt;code&gt;nil&lt;/code&gt;. It&amp;rsquo;s the responsibility of applications that their parameters are included in &lt;code&gt;frameset-persistent-filter-alist&lt;/code&gt; to avoid that they get meaningless or even harmful values in restored sessions.</source>
          <target state="translated">デフォルトでは、変数 &lt;code&gt;desktop-restore-frames&lt;/code&gt; が &lt;code&gt;nil&lt;/code&gt; 以外の場合、フレームパラメータはデスクトップライブラリ関数（&lt;a href=&quot;desktop-save-mode#Desktop-Save-Mode&quot;&gt;デスクトップ保存モードを&lt;/a&gt;参照）によって保存および復元されます。復元されたセッションで意味のない値や有害な値を取得しないように、パラメーターを &lt;code&gt;frameset-persistent-filter-alist&lt;/code&gt; に含めるのはアプリケーションの責任です。</target>
        </trans-unit>
        <trans-unit id="4ff08fda735af5f6543bdd7e51226e1a37b99336" translate="yes" xml:space="preserve">
          <source>By default, if the latest auto-save file is more recent than the visited file, and the argument &lt;var&gt;ignore-auto&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, &lt;code&gt;revert-buffer&lt;/code&gt; asks the user whether to use that auto-save instead. When you invoke this command interactively, &lt;var&gt;ignore-auto&lt;/var&gt; is &lt;code&gt;t&lt;/code&gt; if there is no numeric prefix argument; thus, the interactive default is not to check the auto-save file.</source>
          <target state="translated">デフォルトでは、最新の自動保存ファイルがアクセスしたファイルよりも &lt;code&gt;nil&lt;/code&gt; 、引数 &lt;var&gt;ignore-auto&lt;/var&gt; がnilの場合、 &lt;code&gt;revert-buffer&lt;/code&gt; は代わりにその自動保存を使用するかどうかをユーザーに尋ねます。このコマンドを対話的に呼び出す場合、数値のプレフィックス引数がない場合、 &lt;var&gt;ignore-auto&lt;/var&gt; は &lt;code&gt;t&lt;/code&gt; です。したがって、インタラクティブなデフォルトでは、自動保存ファイルはチェックされません。</target>
        </trans-unit>
        <trans-unit id="2816188a5a0e8a3ed928cd480d7464b05373951a" translate="yes" xml:space="preserve">
          <source>By default, it also defines a variable named &lt;var&gt;mode&lt;/var&gt;, which is set to &lt;code&gt;t&lt;/code&gt; or &lt;code&gt;nil&lt;/code&gt; by enabling or disabling the mode. The variable is initialized to &lt;var&gt;init-value&lt;/var&gt;. Except in unusual circumstances (see below), this value must be &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">デフォルトでは、 &lt;var&gt;mode&lt;/var&gt; という名前の変数も定義されています。この変数は、モードを有効または無効にすることで &lt;code&gt;t&lt;/code&gt; または &lt;code&gt;nil&lt;/code&gt; に設定されます。変数は &lt;var&gt;init-value&lt;/var&gt; に初期化されます。異常な状況（以下を参照）を除いて、この値は &lt;code&gt;nil&lt;/code&gt; でなければなりません。</target>
        </trans-unit>
        <trans-unit id="1adc609228685b29696e0ff7e75061c83ffb5bde" translate="yes" xml:space="preserve">
          <source>By default, output is put in a buffer.</source>
          <target state="translated">デフォルトでは、出力はバッファに格納されます。</target>
        </trans-unit>
        <trans-unit id="410cbb685716930dfd39abc9cbf65a643f166d48" translate="yes" xml:space="preserve">
          <source>By default, process output is inserted in the associated buffer. (You can change this by defining a custom filter function, see &lt;a href=&quot;filter-functions#Filter-Functions&quot;&gt;Filter Functions&lt;/a&gt;.) The position to insert the output is determined by the &lt;code&gt;process-mark&lt;/code&gt;, which is then updated to point to the end of the text just inserted. Usually, but not always, the &lt;code&gt;process-mark&lt;/code&gt; is at the end of the buffer.</source>
          <target state="translated">デフォルトでは、プロセス出力は関連するバッファに挿入されます。（あなたが見る、カスタムフィルタ関数を定義することによって、これを変更することができます&lt;a href=&quot;filter-functions#Filter-Functions&quot;&gt;フィルタ関数を&lt;/a&gt;。）により決定された出力挿入する位置 &lt;code&gt;process-mark&lt;/code&gt; そしてちょうど挿入したテキストの末尾を指すように更新され、。常にではありませんが、通常、 &lt;code&gt;process-mark&lt;/code&gt; はバッファの最後にあります。</target>
        </trans-unit>
        <trans-unit id="f08b23f065e4db8b7e347aa8e9d5f1dfa79f259d" translate="yes" xml:space="preserve">
          <source>By default, searches in Emacs ignore the case of the text they are searching through; if you specify searching for &amp;lsquo;</source>
          <target state="translated">デフォルトでは、Emacsでの検索では、検索しているテキストの大文字と小文字は区別されません。'の検索を指定した場合</target>
        </trans-unit>
        <trans-unit id="1fd764f8ebd1a38813dea49832550f50112ed16b" translate="yes" xml:space="preserve">
          <source>By default, side windows cannot be split via &lt;code&gt;split-window&lt;/code&gt; (see &lt;a href=&quot;splitting-windows#Splitting-Windows&quot;&gt;Splitting Windows&lt;/a&gt;). Also, a side window is not reused or split by any buffer display action (see &lt;a href=&quot;buffer-display-action-functions#Buffer-Display-Action-Functions&quot;&gt;Buffer Display Action Functions&lt;/a&gt;) unless it is explicitly specified as target of that action. Note also that &lt;code&gt;delete-other-windows&lt;/code&gt; cannot make a side window the only window on its frame (see &lt;a href=&quot;deleting-windows#Deleting-Windows&quot;&gt;Deleting Windows&lt;/a&gt;).</source>
          <target state="translated">デフォルトでは、サイドウィンドウは、ビア分割することはできません &lt;code&gt;split-window&lt;/code&gt; （参照&lt;a href=&quot;splitting-windows#Splitting-Windows&quot;&gt;ウィンドウの分割&lt;/a&gt;）。また、サイドウィンドウは、そのアクションのターゲットとして明示的に指定されていない限り、バッファ表示アクション（&lt;a href=&quot;buffer-display-action-functions#Buffer-Display-Action-Functions&quot;&gt;バッファ表示アクション関数を&lt;/a&gt;参照）によって再利用または分割されません。 &lt;code&gt;delete-other-windows&lt;/code&gt; は、サイドウィンドウをそのフレーム上の唯一のウィンドウにすることはできないことにも注意してください（ウィンドウの&lt;a href=&quot;deleting-windows#Deleting-Windows&quot;&gt;削除を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="337f680b05ae479de5bb330579bb081a7cad8c38" translate="yes" xml:space="preserve">
          <source>By default, the error output from the process, if any, is also passed to the filter function, unless the destination for the standard error stream of the process was separated from the standard output when the process was created. Emacs will only call the filter function during certain function calls. See &lt;a href=&quot;output-from-processes#Output-from-Processes&quot;&gt;Output from Processes&lt;/a&gt;. Note that if any of those functions are called by the filter, the filter may be called recursively.</source>
          <target state="translated">デフォルトでは、プロセスの標準エラーストリームの宛先がプロセスの作成時に標準出力から分離されていない限り、プロセスからのエラー出力もフィルター関数に渡されます。 Emacsは特定の関数呼び出し中にのみフィルター関数を呼び出します。&lt;a href=&quot;output-from-processes#Output-from-Processes&quot;&gt;プロセスからの出力を&lt;/a&gt;参照してください。これらの関数のいずれかがフィルターによって呼び出された場合、フィルターは再帰的に呼び出される可能性があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="06b7d4e5494854a61c5e08ae9fc06e3dd1a74a05" translate="yes" xml:space="preserve">
          <source>By default, the functions that save and restore window configurations or the states of windows (see &lt;a href=&quot;window-configurations#Window-Configurations&quot;&gt;Window Configurations&lt;/a&gt;) do not care about window parameters. This means that when you change the value of a parameter within the body of a &lt;code&gt;save-window-excursion&lt;/code&gt;, the previous value is not restored when that macro exits. It also means that when you restore via &lt;code&gt;window-state-put&lt;/code&gt; a window state saved earlier by &lt;code&gt;window-state-get&lt;/code&gt;, all cloned windows have their parameters reset to &lt;code&gt;nil&lt;/code&gt;. The following variable allows you to override the standard behavior:</source>
          <target state="translated">デフォルトでは、ウィンドウ構成またはウィンドウの状態を保存および復元する関数（「&lt;a href=&quot;window-configurations#Window-Configurations&quot;&gt;ウィンドウ構成&lt;/a&gt;」を参照）は、ウィンドウパラメーターを考慮しません。これは、 &lt;code&gt;save-window-excursion&lt;/code&gt; の本体内でパラメーターの値を変更した場合、そのマクロが終了しても以前の値は復元されないことを意味します。また、 &lt;code&gt;window-state-put&lt;/code&gt; を介して、 &lt;code&gt;window-state-get&lt;/code&gt; によって以前に保存されたウィンドウ状態を復元すると、複製されたすべてのウィンドウのパラメーターが &lt;code&gt;nil&lt;/code&gt; にリセットされることも意味します。次の変数を使用すると、標準の動作をオーバーライドできます。</target>
        </trans-unit>
        <trans-unit id="42d60f64d2f3044aeab0d538900375a76783a13e" translate="yes" xml:space="preserve">
          <source>By default, the global map binds &lt;code&gt;[tool-bar]&lt;/code&gt; as follows:</source>
          <target state="translated">デフォルトでは、グローバルマップは &lt;code&gt;[tool-bar]&lt;/code&gt; を次のようにバインドします。</target>
        </trans-unit>
        <trans-unit id="7273860db2763e093bd47c6c91c3aff5ba16714f" translate="yes" xml:space="preserve">
          <source>By default, the local bindings that Emacs creates are &lt;em&gt;dynamic bindings&lt;/em&gt;. Such a binding has &lt;em&gt;dynamic scope&lt;/em&gt;, meaning that any part of the program can potentially access the variable binding. It also has &lt;em&gt;dynamic extent&lt;/em&gt;, meaning that the binding lasts only while the binding construct (such as the body of a &lt;code&gt;let&lt;/code&gt; form) is being executed.</source>
          <target state="translated">デフォルトでは、Emacsが作成するローカルバインディングは&lt;em&gt;動的バインディング&lt;/em&gt;です。このようなバインディングには&lt;em&gt;動的スコープがあります&lt;/em&gt;。つまり、プログラムのどの部分でも変数バインディングにアクセスできる可能性があります。また、&lt;em&gt;動的エクステント&lt;/em&gt;があります。つまり、バインディングは、バインディング構造（ &lt;code&gt;let&lt;/code&gt; フォームの本体など）が実行されている間だけ持続します。</target>
        </trans-unit>
        <trans-unit id="fd1815fd5a5c0fb02829db09a71557be08961cdb" translate="yes" xml:space="preserve">
          <source>By default, the local variable bindings made by Emacs are dynamic bindings. When a variable is dynamically bound, its current binding at any point in the execution of the Lisp program is simply the most recently-created dynamic local binding for that symbol, or the global binding if there is no such local binding.</source>
          <target state="translated">デフォルトでは、Emacs が作成するローカル変数のバインディングは動的バインディングです。変数が動的にバインドされている場合、Lispプログラムの実行中のどの時点でも、そのシンボルの現在のバインディングは、そのシンボルのために最近作成された動的ローカルバインディングになります。</target>
        </trans-unit>
        <trans-unit id="47f31a9758da1b80f09abc18f1231cee612e7b61" translate="yes" xml:space="preserve">
          <source>By default, the range of codepoints passed to &lt;var&gt;function&lt;/var&gt; includes all the characters in &lt;var&gt;charset&lt;/var&gt;, but optional arguments &lt;var&gt;from-code&lt;/var&gt; and &lt;var&gt;to-code&lt;/var&gt; limit that to the range of characters between these two codepoints of &lt;var&gt;charset&lt;/var&gt;. If either of them is &lt;code&gt;nil&lt;/code&gt;, it defaults to the first or last codepoint of &lt;var&gt;charset&lt;/var&gt;, respectively.</source>
          <target state="translated">デフォルトでは、 &lt;var&gt;function&lt;/var&gt; に渡されるコードポイントの範囲には、 &lt;var&gt;charset&lt;/var&gt; 内のすべての文字が含まれますが、オプションの引数 &lt;var&gt;from-code&lt;/var&gt; および &lt;var&gt;to-code&lt;/var&gt; は、 &lt;var&gt;charset&lt;/var&gt; のこれら2つのコードポイント間の文字範囲に制限します。それらのいずれかが &lt;code&gt;nil&lt;/code&gt; の場合、デフォルトでそれぞれ &lt;var&gt;charset&lt;/var&gt; の最初または最後のコードポイントになります。</target>
        </trans-unit>
        <trans-unit id="3d1494bcaafdc3c540ef160a9f8e6f65dd4261e3" translate="yes" xml:space="preserve">
          <source>By default, the space taken up by &lt;var&gt;window&lt;/var&gt; is given to one of its adjacent sibling windows, if any. However, if the variable &lt;code&gt;window-combination-resize&lt;/code&gt; is non-&lt;code&gt;nil&lt;/code&gt;, the space is proportionally distributed among any remaining windows in the same window combination. See &lt;a href=&quot;recombining-windows#Recombining-Windows&quot;&gt;Recombining Windows&lt;/a&gt;.</source>
          <target state="translated">デフォルトでは、 &lt;var&gt;window&lt;/var&gt; が占めるスペースは、隣接する兄弟ウィンドウの1つに割り当てられます（存在する場合）。ただし、変数 &lt;code&gt;window-combination-resize&lt;/code&gt; が &lt;code&gt;nil&lt;/code&gt; 以外の場合、スペースは同じウィンドウの組み合わせ内の残りのウィンドウに比例して分散されます。&lt;a href=&quot;recombining-windows#Recombining-Windows&quot;&gt;Windowsの再結合を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="f1defe0245424aab283006a635faaa0b360d0c56" translate="yes" xml:space="preserve">
          <source>By default, the value is a function that asks the user whether to proceed.</source>
          <target state="translated">デフォルトでは、値はユーザーに進むかどうかを尋ねる関数です。</target>
        </trans-unit>
        <trans-unit id="6d7d2b01d1d4f6143cd45dbac4779e0cc9e9e7c9" translate="yes" xml:space="preserve">
          <source>By default, the values are integers that are 100 times the system load averages, but if &lt;var&gt;use-float&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, then they are returned as floating-point numbers without multiplying by 100.</source>
          <target state="translated">デフォルトでは、値はシステム負荷平均の100倍の整数ですが、 &lt;var&gt;use-float&lt;/var&gt; が &lt;code&gt;nil&lt;/code&gt; 以外の場合、100を掛けずに浮動小数点数として返されます。</target>
        </trans-unit>
        <trans-unit id="e561fba1f476b09361515566e3c64701551c6912" translate="yes" xml:space="preserve">
          <source>By default, this alist contains one entry with the key &lt;code&gt;edebug&lt;/code&gt; and a list of three functions, which are the default implementations of the functions inserted in instrumented code: &lt;code&gt;edebug-enter&lt;/code&gt;, &lt;code&gt;edebug-before&lt;/code&gt; and &lt;code&gt;edebug-after&lt;/code&gt;. To change Edebug&amp;rsquo;s behavior globally, modify the default entry.</source>
          <target state="translated">デフォルトでは、このリストには、キー &lt;code&gt;edebug&lt;/code&gt; を含む1つのエントリと、インストルメント化されたコードに挿入された関数のデフォルトの実装である3つの関数のリストが含まれています： &lt;code&gt;edebug-enter&lt;/code&gt; 、 &lt;code&gt;edebug-before&lt;/code&gt; 、 &lt;code&gt;edebug-after&lt;/code&gt; 。Edebugの動作をグローバルに変更するには、デフォルトのエントリを変更します。</target>
        </trans-unit>
        <trans-unit id="a30c2c9f6f69702d4744ebbd4fe0caff5ca90a07" translate="yes" xml:space="preserve">
          <source>By default, this function also moves &lt;var&gt;window&lt;/var&gt;&amp;rsquo;s buffer to the front of the buffer list (see &lt;a href=&quot;buffer-list#Buffer-List&quot;&gt;Buffer List&lt;/a&gt;) and makes &lt;var&gt;window&lt;/var&gt; the most recently selected window. If the optional argument &lt;var&gt;norecord&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, these additional actions are omitted.</source>
          <target state="translated">デフォルトでは、この機能はまた、移動 &lt;var&gt;window&lt;/var&gt; バッファリストの先頭へのバッファを（参照&lt;a href=&quot;buffer-list#Buffer-List&quot;&gt;バッファリスト&lt;/a&gt;）となります &lt;var&gt;window&lt;/var&gt; 最近選択ウィンドウ。オプションの引数 &lt;var&gt;norecord&lt;/var&gt; が &lt;code&gt;nil&lt;/code&gt; 以外の場合、これらの追加のアクションは省略されます。</target>
        </trans-unit>
        <trans-unit id="314e04d83201875669bd5820e278b79ec5e410e1" translate="yes" xml:space="preserve">
          <source>By default, this function resets &lt;var&gt;window&lt;/var&gt;&amp;rsquo;s position, display margins, fringe widths, and scroll bar settings, based on the local variables in the specified buffer. However, if the optional argument &lt;var&gt;keep-margins&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, it leaves &lt;var&gt;window&lt;/var&gt;&amp;rsquo;s display margins, fringes and scroll bar settings alone.</source>
          <target state="translated">デフォルトでは、この関数は、指定されたバッファ内のローカル変数に基づいて、 &lt;var&gt;window&lt;/var&gt; の位置、表示マージン、フリンジ幅、およびスクロールバーの設定をリセットします。ただし、オプションの引数 &lt;var&gt;keep-margins&lt;/var&gt; が &lt;code&gt;nil&lt;/code&gt; 以外の場合、 &lt;var&gt;window&lt;/var&gt; の表示マージン、フリンジ、およびスクロールバーの設定はそのままになります。</target>
        </trans-unit>
        <trans-unit id="c8d7822491c87018aaf653bdc89135199d35d678" translate="yes" xml:space="preserve">
          <source>By default, this variable is always set to &lt;code&gt;t&lt;/code&gt;, meaning that a call of &lt;code&gt;process-file&lt;/code&gt; could potentially change any file on a remote host. When set to &lt;code&gt;nil&lt;/code&gt;, a file name handler could optimize its behavior with respect to remote file attribute caching.</source>
          <target state="translated">デフォルトでは、この変数は常に &lt;code&gt;t&lt;/code&gt; に設定されています。これは、 &lt;code&gt;process-file&lt;/code&gt; を呼び出すと、リモートホスト上のファイルが変更される可能性があることを意味します。 &lt;code&gt;nil&lt;/code&gt; に設定すると、ファイル名ハンドラーはリモートファイル属性のキャッシュに関する動作を最適化できます。</target>
        </trans-unit>
        <trans-unit id="fe49d9f104dc3f50cf901776febad4cfc3162c78" translate="yes" xml:space="preserve">
          <source>By default, this variable&amp;rsquo;s value is &lt;code&gt;read&lt;/code&gt;. See &lt;a href=&quot;input-functions#Input-Functions&quot;&gt;Input Functions&lt;/a&gt;.</source>
          <target state="translated">デフォルトでは、この変数の値が &lt;code&gt;read&lt;/code&gt; 。&lt;a href=&quot;input-functions#Input-Functions&quot;&gt;入力関数を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="c2688defb0c98a25897334d05cea4581b8ab7493" translate="yes" xml:space="preserve">
          <source>By design, action functions are free in their interpretation of action alist entries. In fact, some entries like &lt;code&gt;allow-no-window&lt;/code&gt; or &lt;code&gt;previous-window&lt;/code&gt; have a meaning only for one or a few action functions, and are ignored by the rest. Other entries, like &lt;code&gt;inhibit-same-window&lt;/code&gt; or &lt;code&gt;window-parameters&lt;/code&gt;, are supposed to be respected by most action functions, including those provided by application programs and external packages.</source>
          <target state="translated">設計上、アクション関数はアクションリストエントリの解釈において自由です。実際、 &lt;code&gt;allow-no-window&lt;/code&gt; や &lt;code&gt;previous-window&lt;/code&gt; などの一部のエントリは、1つまたはいくつかのアクション関数に対してのみ意味があり、残りの関数では無視されます。 &lt;code&gt;inhibit-same-window&lt;/code&gt; や &lt;code&gt;window-parameters&lt;/code&gt; などの他のエントリは、アプリケーションプログラムや外部パッケージによって提供されるものを含め、ほとんどのアクション関数によって尊重されることになっています。</target>
        </trans-unit>
        <trans-unit id="5df52f7953c9e1e23b06b07d93d36bf7c4082b84" translate="yes" xml:space="preserve">
          <source>By design, operations to make or modify child frames are implemented with the help of frame parameters (see &lt;a href=&quot;frame-parameters#Frame-Parameters&quot;&gt;Frame Parameters&lt;/a&gt;) without any specialized functions or customizable variables. Note that child frames are meaningful on graphical terminals only.</source>
          <target state="translated">設計上、子フレームを作成または変更する操作は、特別な関数やカスタマイズ可能な変数を使用せずに、フレームパラメーター（&lt;a href=&quot;frame-parameters#Frame-Parameters&quot;&gt;フレームパラメーターを&lt;/a&gt;参照）を使用して実装されます。子フレームは、グラフィカル端末でのみ意味があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="bc5e006af20582138d39d0ef5f207bc52db0c4b3" translate="yes" xml:space="preserve">
          <source>By editing the buffer in place. In this case, &lt;var&gt;to-fn&lt;/var&gt; should return the end-position of the range of text, as modified.</source>
          <target state="translated">バッファを所定の位置で編集する。この場合、 &lt;var&gt;to-fn&lt;/var&gt; は、変更されたテキスト範囲の終了位置を返す必要があります。</target>
        </trans-unit>
        <trans-unit id="63b5c76c72ae22fa7a5d14c68660da304cacecaf" translate="yes" xml:space="preserve">
          <source>By returning a list of annotations. This is a list of elements of the form &lt;code&gt;(&lt;var&gt;position&lt;/var&gt; . &lt;var&gt;string&lt;/var&gt;)&lt;/code&gt;, where &lt;var&gt;position&lt;/var&gt; is an integer specifying the relative position in the text to be written, and &lt;var&gt;string&lt;/var&gt; is the annotation to add there. The list must be sorted in order of position when &lt;var&gt;to-fn&lt;/var&gt; returns it.</source>
          <target state="translated">注釈のリストを返す。これは、 &lt;code&gt;(&lt;var&gt;position&lt;/var&gt; . &lt;var&gt;string&lt;/var&gt;)&lt;/code&gt; 形式の要素のリストです。ここで、 &lt;var&gt;position&lt;/var&gt; は、書き込まれるテキスト内の相対位置を指定する整数であり、 &lt;var&gt;string&lt;/var&gt; はそこに追加する注釈です。 &lt;var&gt;to-fn&lt;/var&gt; がリストを返す場合、リストは位置順にソートする必要があります。</target>
        </trans-unit>
        <trans-unit id="b9df056fb7a4026d67a3485fe6622bd0ac5e4705" translate="yes" xml:space="preserve">
          <source>By setting the &lt;var&gt;action&lt;/var&gt; argument, an application effectively overrules any customization of &lt;code&gt;display-buffer-base-action&lt;/code&gt;. Our user can now either accept the choice of the application, or redouble by customizing the option &lt;code&gt;display-buffer-alist&lt;/code&gt; as follows:</source>
          <target state="translated">&lt;var&gt;action&lt;/var&gt; 引数を設定することにより、アプリケーションは &lt;code&gt;display-buffer-base-action&lt;/code&gt; のカスタマイズを事実上無効にします。これで、ユーザーはアプリケーションの選択を受け入れるか、オプション &lt;code&gt;display-buffer-alist&lt;/code&gt; を次のようにカスタマイズして倍増することができます。</target>
        </trans-unit>
        <trans-unit id="3d82e754d3481447db663d32552753c526295b30" translate="yes" xml:space="preserve">
          <source>Byte Compilation</source>
          <target state="translated">バイトコンパイル</target>
        </trans-unit>
        <trans-unit id="38293ea2f575b674a58092e2860f65e375cf569f" translate="yes" xml:space="preserve">
          <source>Byte compilation functions.</source>
          <target state="translated">バイトコンパイル機能。</target>
        </trans-unit>
        <trans-unit id="05bc2b18f50e1c59ce5be83b3a043fed7d8464a5" translate="yes" xml:space="preserve">
          <source>Byte compiler warnings can be controlled more precisely by setting the variable &lt;code&gt;byte-compile-warnings&lt;/code&gt;. See its documentation string for details.</source>
          <target state="translated">バイトコンパイラの警告は、変数 &lt;code&gt;byte-compile-warnings&lt;/code&gt; を設定することでより正確に制御できます。詳細については、ドキュメント文字列を参照してください。</target>
        </trans-unit>
        <trans-unit id="30c3dfd8676a2b612dc32e5e0e6e366336cdb1d2" translate="yes" xml:space="preserve">
          <source>Byte-Code Function Objects</source>
          <target state="translated">バイトコード関数オブジェクト</target>
        </trans-unit>
        <trans-unit id="11dfd8a56350515cd4673e500974d1d76f92ac16" translate="yes" xml:space="preserve">
          <source>Byte-Code Function Type</source>
          <target state="translated">バイトコード関数型</target>
        </trans-unit>
        <trans-unit id="59fecc0a37710dd91bf58606dfa13b25c3069f87" translate="yes" xml:space="preserve">
          <source>Byte-Compilation Functions</source>
          <target state="translated">バイトコンパイル機能</target>
        </trans-unit>
        <trans-unit id="1a37ba1d3be3c3de01e4d5d496b8285b080495ba" translate="yes" xml:space="preserve">
          <source>Byte-compiled functions have a special data type: they are &lt;em&gt;byte-code function objects&lt;/em&gt;. Whenever such an object appears as a function to be called, Emacs uses the byte-code interpreter to execute the byte-code.</source>
          <target state="translated">バイトコンパイルされた関数には特別なデータ型があり&lt;em&gt;ます&lt;/em&gt;。それらは&lt;em&gt;バイトコード関数オブジェクトです&lt;/em&gt;。そのようなオブジェクトが呼び出される関数として現れるときはいつでも、Emacsはバイトコードインタープリターを使用してバイトコードを実行します。</target>
        </trans-unit>
        <trans-unit id="3bb9f8596b1e76a28bc9081c521014596231e12a" translate="yes" xml:space="preserve">
          <source>Byte-compiling a file also executes any &lt;code&gt;require&lt;/code&gt; calls at top-level in the file, so you can ensure that necessary macro definitions are available during compilation by requiring the files that define them (see &lt;a href=&quot;named-features#Named-Features&quot;&gt;Named Features&lt;/a&gt;). To avoid loading the macro definition files when someone &lt;em&gt;runs&lt;/em&gt; the compiled program, write &lt;code&gt;eval-when-compile&lt;/code&gt; around the &lt;code&gt;require&lt;/code&gt; calls (see &lt;a href=&quot;eval-during-compile#Eval-During-Compile&quot;&gt;Eval During Compile&lt;/a&gt;).</source>
          <target state="translated">ファイルをバイトコンパイルすると、ファイルのトップレベルで &lt;code&gt;require&lt;/code&gt; 呼び出しも実行されるため、必要なマクロ定義を定義するファイルを要求することで、コンパイル中に必要なマクロ定義を使用できるようにすることができます（&lt;a href=&quot;named-features#Named-Features&quot;&gt;名前付き機能を&lt;/a&gt;参照）。誰か&lt;em&gt;が&lt;/em&gt;コンパイル済みプログラムを&lt;em&gt;実行&lt;/em&gt;するときにマクロ定義ファイルがロードされないように &lt;code&gt;eval-when-compile&lt;/code&gt; は、 &lt;code&gt;require&lt;/code&gt; 呼び出しの周りにeval-when-compileを記述します（&lt;a href=&quot;eval-during-compile#Eval-During-Compile&quot;&gt;コンパイル中の評価を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="cc41f45aabe0cfaf8f1fb19aff9d4d9cd35def84" translate="yes" xml:space="preserve">
          <source>Byte-compiling a file often produces warnings about functions that the compiler doesn&amp;rsquo;t know about (see &lt;a href=&quot;compiler-errors#Compiler-Errors&quot;&gt;Compiler Errors&lt;/a&gt;). Sometimes this indicates a real problem, but usually the functions in question are defined in other files which would be loaded if that code is run. For example, byte-compiling</source>
          <target state="translated">ファイルをバイトコンパイルすると、コンパイラが認識していない関数に関する警告が生成されることがよくあります（&lt;a href=&quot;compiler-errors#Compiler-Errors&quot;&gt;コンパイラエラーを&lt;/a&gt;参照）。これは実際の問題を示している場合もありますが、通常、問題の関数は、そのコードが実行された場合にロードされる他のファイルで定義されています。たとえば、バイトコンパイル</target>
        </trans-unit>
        <trans-unit id="32096c2e0eff33d844ee6d675407ace18289357d" translate="yes" xml:space="preserve">
          <source>C</source>
          <target state="translated">C</target>
        </trans-unit>
        <trans-unit id="440395ca055b9f07fbed0d7cf4596c35fc237caa" translate="yes" xml:space="preserve">
          <source>C Dialect</source>
          <target state="translated">C方言</target>
        </trans-unit>
        <trans-unit id="161c19c41476b0282b81eeb78bdaec44cc5f26eb" translate="yes" xml:space="preserve">
          <source>C Integer Types</source>
          <target state="translated">C 整数型</target>
        </trans-unit>
        <trans-unit id="f1dfdb58024fd801bb8d8d91b16183f255579149" translate="yes" xml:space="preserve">
          <source>C-</source>
          <target state="translated">C-</target>
        </trans-unit>
        <trans-unit id="e98b70997278aacbb8d37c462eeefc3cbd3956d9" translate="yes" xml:space="preserve">
          <source>C-=</source>
          <target state="translated">C-=</target>
        </trans-unit>
        <trans-unit id="f91ccd340101fead85b132fc626cf86c66e71760" translate="yes" xml:space="preserve">
          <source>C-@</source>
          <target state="translated">C-@</target>
        </trans-unit>
        <trans-unit id="5a32717cd694e62b994ffe84487a025e94d4ba8d" translate="yes" xml:space="preserve">
          <source>C-A</source>
          <target state="translated">C-A</target>
        </trans-unit>
        <trans-unit id="a0720f926a1edd4fcb28152926e89547a933d93b" translate="yes" xml:space="preserve">
          <source>C-DEL</source>
          <target state="translated">C-DEL</target>
        </trans-unit>
        <trans-unit id="e8de50b9ffc20496735696fad0e0b83e070a5838" translate="yes" xml:space="preserve">
          <source>C-M-S-v</source>
          <target state="translated">C-M-S-v</target>
        </trans-unit>
        <trans-unit id="a587267328d8d782313379e66ff7b0b685da74e3" translate="yes" xml:space="preserve">
          <source>C-M-a</source>
          <target state="translated">C-M-a</target>
        </trans-unit>
        <trans-unit id="523363599c87501263758c3178a881d56b0ca0f3" translate="yes" xml:space="preserve">
          <source>C-M-b</source>
          <target state="translated">C-M-b</target>
        </trans-unit>
        <trans-unit id="9ab2ef69a1c8dee51e5c638f3f4dfb634fbe96a6" translate="yes" xml:space="preserve">
          <source>C-M-c</source>
          <target state="translated">C-M-c</target>
        </trans-unit>
        <trans-unit id="a2b4c4a3c492ba7d8900be9b332ed927f932ea89" translate="yes" xml:space="preserve">
          <source>C-M-e</source>
          <target state="translated">C-M-e</target>
        </trans-unit>
        <trans-unit id="1415d2b0c002711c0b18baff2ffb42f215277da7" translate="yes" xml:space="preserve">
          <source>C-M-f</source>
          <target state="translated">C-M-f</target>
        </trans-unit>
        <trans-unit id="e1283736390e7ca8f0e8dae4d7c15501e7285305" translate="yes" xml:space="preserve">
          <source>C-M-i</source>
          <target state="translated">C-M-i</target>
        </trans-unit>
        <trans-unit id="5554d733d6164f6f3c0310969979f52f4373a6f3" translate="yes" xml:space="preserve">
          <source>C-M-q</source>
          <target state="translated">C-M-q</target>
        </trans-unit>
        <trans-unit id="e48088e6addb18372a14ed6b8da1a6b58ad7c957" translate="yes" xml:space="preserve">
          <source>C-M-v</source>
          <target state="translated">C-M-v</target>
        </trans-unit>
        <trans-unit id="e3d2747af9266236b31cfe9dbcc1d21c148863e4" translate="yes" xml:space="preserve">
          <source>C-M-x</source>
          <target state="translated">C-M-x</target>
        </trans-unit>
        <trans-unit id="d149ce62d1e517cc3bc28b8250bb976be43efcc0" translate="yes" xml:space="preserve">
          <source>C-\</source>
          <target state="translated">C-\</target>
        </trans-unit>
        <trans-unit id="015b01935f205cea280aafb1b1c1757c49bc1bf4" translate="yes" xml:space="preserve">
          <source>C-]</source>
          <target state="translated">C-]</target>
        </trans-unit>
        <trans-unit id="5ec9d3dadc7abaeb1f5f16db2365b2aeb6a2f74b" translate="yes" xml:space="preserve">
          <source>C-_</source>
          <target state="translated">C-_</target>
        </trans-unit>
        <trans-unit id="3bff8fb1aa290267671b1c50e3b32db24f00b295" translate="yes" xml:space="preserve">
          <source>C-a</source>
          <target state="translated">C-a</target>
        </trans-unit>
        <trans-unit id="c204a76fc3c1123c96b13dd7ec922d02d4b00e91" translate="yes" xml:space="preserve">
          <source>C-b</source>
          <target state="translated">C-b</target>
        </trans-unit>
        <trans-unit id="b3b7965656c0921692a30673d7781acd51c4eed9" translate="yes" xml:space="preserve">
          <source>C-c</source>
          <target state="translated">C-c</target>
        </trans-unit>
        <trans-unit id="2922399c2d547241985d2d9050d0f4a253f10c73" translate="yes" xml:space="preserve">
          <source>C-c 3</source>
          <target state="translated">C-c 3</target>
        </trans-unit>
        <trans-unit id="8c846cf1bd5b4fe56864ee3f4c9665e8b3b8fcc4" translate="yes" xml:space="preserve">
          <source>C-c &lt;var&gt;letter&lt;/var&gt;</source>
          <target state="translated">CC &lt;var&gt;letter&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="63d94b505b28b164240bf9389a0b04f654a4efe7" translate="yes" xml:space="preserve">
          <source>C-c C-d</source>
          <target state="translated">C-c C-d</target>
        </trans-unit>
        <trans-unit id="d0bed7baa3038554c15ed1dd0d2b6090b9910013" translate="yes" xml:space="preserve">
          <source>C-c C-u</source>
          <target state="translated">C-c C-u</target>
        </trans-unit>
        <trans-unit id="f74c88ff9d7e7d40f5d62f507900f4cb7519ee90" translate="yes" xml:space="preserve">
          <source>C-c C-w</source>
          <target state="translated">C-c C-w</target>
        </trans-unit>
        <trans-unit id="e396508e7aa9423085342ba159b546882b435194" translate="yes" xml:space="preserve">
          <source>C-c C-z</source>
          <target state="translated">C-c C-z</target>
        </trans-unit>
        <trans-unit id="98c56570dd5671b7a19fbc0ebf8785f9ff91eddc" translate="yes" xml:space="preserve">
          <source>C-c ESC</source>
          <target state="translated">C-c ESC</target>
        </trans-unit>
        <trans-unit id="f9d21da244350a9db0114ec30af406d5bef1cb45" translate="yes" xml:space="preserve">
          <source>C-c ESC O P</source>
          <target state="translated">C-c ESC O P</target>
        </trans-unit>
        <trans-unit id="57e4e54e9967cd42daed8a76a5aa899b154b7b12" translate="yes" xml:space="preserve">
          <source>C-c PF1</source>
          <target state="translated">C-c PF1</target>
        </trans-unit>
        <trans-unit id="d2e5a2b66c696b957548f71ee728ee1ae137f0c0" translate="yes" xml:space="preserve">
          <source>C-c h</source>
          <target state="translated">C-c h</target>
        </trans-unit>
        <trans-unit id="a7ef1e89e28b60bd53a0a5ab746fbcd131fdf224" translate="yes" xml:space="preserve">
          <source>C-e</source>
          <target state="translated">C-e</target>
        </trans-unit>
        <trans-unit id="dd71d43937255c2ba419c077fa824865f8267186" translate="yes" xml:space="preserve">
          <source>C-f</source>
          <target state="translated">C-f</target>
        </trans-unit>
        <trans-unit id="a4b41cc50f9ee3592ac03dec905ea87299f64719" translate="yes" xml:space="preserve">
          <source>C-f C-n</source>
          <target state="translated">C-f C-n</target>
        </trans-unit>
        <trans-unit id="a6d13ed5d2d00101157246b7ae1e91a19d7d7406" translate="yes" xml:space="preserve">
          <source>C-g</source>
          <target state="translated">C-g</target>
        </trans-unit>
        <trans-unit id="a8d14a9f4bc55d9a8a84935ad37682321efb17a6" translate="yes" xml:space="preserve">
          <source>C-h</source>
          <target state="translated">C-h</target>
        </trans-unit>
        <trans-unit id="131f9a03ecbf035173b42486265daa4c059aa594" translate="yes" xml:space="preserve">
          <source>C-h C-h</source>
          <target state="translated">C-h C-h</target>
        </trans-unit>
        <trans-unit id="8fc1636b1726f0f848e9110d7df8ad94624fe8a2" translate="yes" xml:space="preserve">
          <source>C-h P</source>
          <target state="translated">C-h P</target>
        </trans-unit>
        <trans-unit id="d24cf6f79d3eca79589b614119c65a877786e8e3" translate="yes" xml:space="preserve">
          <source>C-h a</source>
          <target state="translated">C-h a</target>
        </trans-unit>
        <trans-unit id="c947b2d5d96ff5df49e3e32802fd4fbc37367b9c" translate="yes" xml:space="preserve">
          <source>C-h b</source>
          <target state="translated">C-h b</target>
        </trans-unit>
        <trans-unit id="2f32ced337101528820a543fba4ae73fd0b8a020" translate="yes" xml:space="preserve">
          <source>C-h c</source>
          <target state="translated">C-h c</target>
        </trans-unit>
        <trans-unit id="b6509cacdcc73abddf104ea8e33a97a3ac5575fa" translate="yes" xml:space="preserve">
          <source>C-h f</source>
          <target state="translated">C-h f</target>
        </trans-unit>
        <trans-unit id="044ffa482f401d4a34b0ce3d2fc0aa8a6c6451c5" translate="yes" xml:space="preserve">
          <source>C-h m</source>
          <target state="translated">C-h m</target>
        </trans-unit>
        <trans-unit id="94df7f22a37722547e0a4acb987c3e85a4c7583c" translate="yes" xml:space="preserve">
          <source>C-h v</source>
          <target state="translated">C-h v</target>
        </trans-unit>
        <trans-unit id="223627ab9c74b5ae56858c226557c9e9be301085" translate="yes" xml:space="preserve">
          <source>C-i</source>
          <target state="translated">C-i</target>
        </trans-unit>
        <trans-unit id="4d83990cce829d69d972a1ed2a1e206afb6b5b37" translate="yes" xml:space="preserve">
          <source>C-j</source>
          <target state="translated">C-j</target>
        </trans-unit>
        <trans-unit id="d5eeac2f32301e2b964f421e02a44c5afa000881" translate="yes" xml:space="preserve">
          <source>C-k</source>
          <target state="translated">C-k</target>
        </trans-unit>
        <trans-unit id="2fef5b5a274737535a312ecc5d6b8de717c1cb77" translate="yes" xml:space="preserve">
          <source>C-l</source>
          <target state="translated">C-l</target>
        </trans-unit>
        <trans-unit id="aa3408adf600065cf33c17971e8cdd9f76e5d785" translate="yes" xml:space="preserve">
          <source>C-n</source>
          <target state="translated">C-n</target>
        </trans-unit>
        <trans-unit id="332268c029d8126391ff9151361238bdf44870d8" translate="yes" xml:space="preserve">
          <source>C-p</source>
          <target state="translated">C-p</target>
        </trans-unit>
        <trans-unit id="023f8e3d8a24aa022603e7bc5546978051323321" translate="yes" xml:space="preserve">
          <source>C-p 6</source>
          <target state="translated">C-p 6</target>
        </trans-unit>
        <trans-unit id="7e58e0990d0a53938ca001b4ad01a74ad57ecbdf" translate="yes" xml:space="preserve">
          <source>C-p C-f</source>
          <target state="translated">C-p C-f</target>
        </trans-unit>
        <trans-unit id="1666955c646a9bb3fabdb2404112bd45b66ccb34" translate="yes" xml:space="preserve">
          <source>C-q</source>
          <target state="translated">C-q</target>
        </trans-unit>
        <trans-unit id="74b18abb702cb69395f60707416dd8e1f9e92a32" translate="yes" xml:space="preserve">
          <source>C-r</source>
          <target state="translated">C-r</target>
        </trans-unit>
        <trans-unit id="78540d990eb5e51e46b3d550d8999b517398872e" translate="yes" xml:space="preserve">
          <source>C-s</source>
          <target state="translated">C-s</target>
        </trans-unit>
        <trans-unit id="ac7de9aff7d0daffb3ae53140a783f411f89c587" translate="yes" xml:space="preserve">
          <source>C-u</source>
          <target state="translated">C-u</target>
        </trans-unit>
        <trans-unit id="d22f544f91c38776df9e98de756eed3debe16cdc" translate="yes" xml:space="preserve">
          <source>C-u -</source>
          <target state="translated">シーユー</target>
        </trans-unit>
        <trans-unit id="10f8bc5307f68632db725ed0931d63de1460ddfa" translate="yes" xml:space="preserve">
          <source>C-u -1 C-M-u</source>
          <target state="translated">C-u -1 C-M-u</target>
        </trans-unit>
        <trans-unit id="5f418fb7321d2ab8c56f997e5658b00a3040a2d1" translate="yes" xml:space="preserve">
          <source>C-u 0 C-j</source>
          <target state="translated">C-u 0 C-j</target>
        </trans-unit>
        <trans-unit id="da79c04f91b004dd27140e6acdba5d94bb656395" translate="yes" xml:space="preserve">
          <source>C-u 0 C-x C-e</source>
          <target state="translated">C-u 0 C-x C-e</target>
        </trans-unit>
        <trans-unit id="9abc686ab642db3617ba866712386a2c3367c984" translate="yes" xml:space="preserve">
          <source>C-u 1 2 3-</source>
          <target state="translated">C-u 1 2 3</target>
        </trans-unit>
        <trans-unit id="078553441ff260418cd0fae179ba0b421b563072" translate="yes" xml:space="preserve">
          <source>C-u 4</source>
          <target state="translated">C-u 4</target>
        </trans-unit>
        <trans-unit id="b45852e2bb35925480811fa34c28817e312757e2" translate="yes" xml:space="preserve">
          <source>C-u C-M-u</source>
          <target state="translated">C-u C-M-u</target>
        </trans-unit>
        <trans-unit id="320929c2d1df45760946518161a90d14f7c50bd7" translate="yes" xml:space="preserve">
          <source>C-u C-M-x</source>
          <target state="translated">丙午丙午丙午丙午</target>
        </trans-unit>
        <trans-unit id="c64b6c2b2de84365236fe039ef1643ad9097b181" translate="yes" xml:space="preserve">
          <source>C-u C-f</source>
          <target state="translated">C-u C-f</target>
        </trans-unit>
        <trans-unit id="144ed887662b97ccd7d5e4df38590e6b0c9188ee" translate="yes" xml:space="preserve">
          <source>C-u RET</source>
          <target state="translated">C-u RET</target>
        </trans-unit>
        <trans-unit id="c228f37d7ea330bf7c0d73a894ac443b387f3c40" translate="yes" xml:space="preserve">
          <source>C-u-</source>
          <target state="translated">C-u-</target>
        </trans-unit>
        <trans-unit id="0a23d9de112f4305bbf7d308788b4615cc11e2a2" translate="yes" xml:space="preserve">
          <source>C-v</source>
          <target state="translated">C-v</target>
        </trans-unit>
        <trans-unit id="298ef629795cfb23ea736c739c02035ede13e0c6" translate="yes" xml:space="preserve">
          <source>C-x</source>
          <target state="translated">C-x</target>
        </trans-unit>
        <trans-unit id="4347a3678ac074d5ec07c3503e15ff18b018adc3" translate="yes" xml:space="preserve">
          <source>C-x 0</source>
          <target state="translated">C-x 0</target>
        </trans-unit>
        <trans-unit id="10124bcc79d4680d2849a4ecb1654c7898083a7b" translate="yes" xml:space="preserve">
          <source>C-x 1</source>
          <target state="translated">C-x 1</target>
        </trans-unit>
        <trans-unit id="4d47f604c607b6bcf678aa67ec1bf75bf4ba7c33" translate="yes" xml:space="preserve">
          <source>C-x 2</source>
          <target state="translated">C-x 2</target>
        </trans-unit>
        <trans-unit id="556f397c3864e7f8b2430507a0e9a218c58fd56b" translate="yes" xml:space="preserve">
          <source>C-x 3</source>
          <target state="translated">C-x 3</target>
        </trans-unit>
        <trans-unit id="abc0d3ddf5ac08765cf41363b262bc421ad3ed38" translate="yes" xml:space="preserve">
          <source>C-x 4</source>
          <target state="translated">C-x 4</target>
        </trans-unit>
        <trans-unit id="63307f15d6b42550d550cea24aeaa5bda8c024a5" translate="yes" xml:space="preserve">
          <source>C-x 4 C-f</source>
          <target state="translated">C-x 4 C-f</target>
        </trans-unit>
        <trans-unit id="d7e8408a7a87b24eb8ce1e9cd577a71f1abc5c24" translate="yes" xml:space="preserve">
          <source>C-x 4 C-o</source>
          <target state="translated">C-x 4 C-o</target>
        </trans-unit>
        <trans-unit id="d4b75cbe5b9f13c775f58fb5aadb4fd2fca9c73f" translate="yes" xml:space="preserve">
          <source>C-x 5</source>
          <target state="translated">C-x 5</target>
        </trans-unit>
        <trans-unit id="74dc274a8f353a10c8762b6eeb01cd5d80e205ba" translate="yes" xml:space="preserve">
          <source>C-x 6</source>
          <target state="translated">C-x 6</target>
        </trans-unit>
        <trans-unit id="b0c7a6e9bf270123c8284d4924a852cb0abe30d2" translate="yes" xml:space="preserve">
          <source>C-x @</source>
          <target state="translated">C-x @</target>
        </trans-unit>
        <trans-unit id="9ac0e333a25e06893ccf8044371d24b9f4683984" translate="yes" xml:space="preserve">
          <source>C-x C-\</source>
          <target state="translated">C-x C-</target>
        </trans-unit>
        <trans-unit id="fdd391c7388aca6906f3e720a86ca5447e7d9c38" translate="yes" xml:space="preserve">
          <source>C-x C-a C-m</source>
          <target state="translated">C-x C-a C-m</target>
        </trans-unit>
        <trans-unit id="38858c4b382736f825616a2e73e26265ca9bb63a" translate="yes" xml:space="preserve">
          <source>C-x C-c</source>
          <target state="translated">C-x C-c</target>
        </trans-unit>
        <trans-unit id="2e574ba4b6c51b8c22a26b1eabc3a75c78d4ea7e" translate="yes" xml:space="preserve">
          <source>C-x C-e</source>
          <target state="translated">C-x C-e</target>
        </trans-unit>
        <trans-unit id="94093db9cb5d3fcd6ac5d93df4e2811d80860744" translate="yes" xml:space="preserve">
          <source>C-x C-f</source>
          <target state="translated">C-x C-f</target>
        </trans-unit>
        <trans-unit id="5aa04c1406d2bc59f9f02c65f0475fb37d41d69f" translate="yes" xml:space="preserve">
          <source>C-x C-g</source>
          <target state="translated">C-x C-g</target>
        </trans-unit>
        <trans-unit id="42560a5db134ba65783348e3bb0520d740376d48" translate="yes" xml:space="preserve">
          <source>C-x C-k</source>
          <target state="translated">C-x C-k</target>
        </trans-unit>
        <trans-unit id="92e72c608b382e9a997922e89877037677057e63" translate="yes" xml:space="preserve">
          <source>C-x C-k RET</source>
          <target state="translated">C-x C-k RET</target>
        </trans-unit>
        <trans-unit id="1c401be2ef044065bde20ae40271bd4ce7c9dbaa" translate="yes" xml:space="preserve">
          <source>C-x C-q</source>
          <target state="translated">C-x C-q</target>
        </trans-unit>
        <trans-unit id="a35119fcea09407a970dc0c67d75cdf4c7493695" translate="yes" xml:space="preserve">
          <source>C-x C-v</source>
          <target state="translated">C-x C-v</target>
        </trans-unit>
        <trans-unit id="380c2576bb1153c21b82305ecfd8e9cf75bb83cb" translate="yes" xml:space="preserve">
          <source>C-x C-w</source>
          <target state="translated">C-x C-w</target>
        </trans-unit>
        <trans-unit id="ad8e8247f1608bee89a7e56cab4034588ceeed4a" translate="yes" xml:space="preserve">
          <source>C-x ESC</source>
          <target state="translated">シーエックスシー</target>
        </trans-unit>
        <trans-unit id="08a670503878dc334b05f1ec67cd80daa09a543f" translate="yes" xml:space="preserve">
          <source>C-x RET</source>
          <target state="translated">C-x RET</target>
        </trans-unit>
        <trans-unit id="33f00fe6ae825deab6e618f2518c895513248309" translate="yes" xml:space="preserve">
          <source>C-x RET c</source>
          <target state="translated">C-x RET c</target>
        </trans-unit>
        <trans-unit id="79182736a3f6f4a9b73be73dd66c6a963d18e6ef" translate="yes" xml:space="preserve">
          <source>C-x X =</source>
          <target state="translated">C-x X =</target>
        </trans-unit>
        <trans-unit id="06fec4fbfa2b40b5ba7dcd2878f2262be7a89cc4" translate="yes" xml:space="preserve">
          <source>C-x X W</source>
          <target state="translated">C-x X W</target>
        </trans-unit>
        <trans-unit id="b2d82441407b634931a0202fcd846528c8356104" translate="yes" xml:space="preserve">
          <source>C-x X X</source>
          <target state="translated">C-x X X</target>
        </trans-unit>
        <trans-unit id="0eabb8db03adc6a93c843bc7c3b4405a882bfbbf" translate="yes" xml:space="preserve">
          <source>C-x X w</source>
          <target state="translated">C-x X w</target>
        </trans-unit>
        <trans-unit id="a433c8910fd90328a865425f7cba86d9473bd9b8" translate="yes" xml:space="preserve">
          <source>C-x a</source>
          <target state="translated">シーエックス</target>
        </trans-unit>
        <trans-unit id="d678c9278cafdf31c68ce0a63d4dfdb3f69b7e79" translate="yes" xml:space="preserve">
          <source>C-x a i</source>
          <target state="translated">C-x a i</target>
        </trans-unit>
        <trans-unit id="2aaaca2013569838cb0a146bd12e35301c230558" translate="yes" xml:space="preserve">
          <source>C-x b</source>
          <target state="translated">シーエックスビー</target>
        </trans-unit>
        <trans-unit id="81a4dfc7002c34a5db314fd55a88c71ce9f8561c" translate="yes" xml:space="preserve">
          <source>C-x l</source>
          <target state="translated">シーエックスエル</target>
        </trans-unit>
        <trans-unit id="b228794009dfb59282b23e84edcb2dc535059148" translate="yes" xml:space="preserve">
          <source>C-x left</source>
          <target state="translated">シーエックス左</target>
        </trans-unit>
        <trans-unit id="0b13a73400d0c3c495b50621ca5fbf45fa714316" translate="yes" xml:space="preserve">
          <source>C-x m</source>
          <target state="translated">シーエックスエム</target>
        </trans-unit>
        <trans-unit id="e78aa0259487687b23094dfc0b1d246956ee5054" translate="yes" xml:space="preserve">
          <source>C-x n</source>
          <target state="translated">シーエックスエヌ</target>
        </trans-unit>
        <trans-unit id="37419a3d9d60f9f4a3c3ceeae49cb867b0552dd5" translate="yes" xml:space="preserve">
          <source>C-x o</source>
          <target state="translated">シーエックスオー</target>
        </trans-unit>
        <trans-unit id="06bba06d9146ec872930935a408ff9e6db7b540e" translate="yes" xml:space="preserve">
          <source>C-x q</source>
          <target state="translated">C-x q</target>
        </trans-unit>
        <trans-unit id="6e1b8f11e4e004ffcd85260453eb416fadd8becd" translate="yes" xml:space="preserve">
          <source>C-x r</source>
          <target state="translated">シーエックスアール</target>
        </trans-unit>
        <trans-unit id="c03a751f3df1d75c00ca555cdecb7ea0f12e35b3" translate="yes" xml:space="preserve">
          <source>C-x t</source>
          <target state="translated">C-x t</target>
        </trans-unit>
        <trans-unit id="16f34907c9a94600e9a207daf61c838d0b36dc8a" translate="yes" xml:space="preserve">
          <source>C-x v</source>
          <target state="translated">シーエックスブイ</target>
        </trans-unit>
        <trans-unit id="f286461016d3e4db77e8a575a1f55b2d71886961" translate="yes" xml:space="preserve">
          <source>C-y</source>
          <target state="translated">C-y</target>
        </trans-unit>
        <trans-unit id="acbbb692ba3dcc7f0dd54066ac8990ff1950dc9c" translate="yes" xml:space="preserve">
          <source>C-z</source>
          <target state="translated">C-z</target>
        </trans-unit>
        <trans-unit id="ee5254754a61a705597a6d10837027cbbdd49eb6" translate="yes" xml:space="preserve">
          <source>CLOS</source>
          <target state="translated">CLOS</target>
        </trans-unit>
        <trans-unit id="8a9cbc4396b103e6b251b294230c1bb9eed38e2f" translate="yes" xml:space="preserve">
          <source>COM1</source>
          <target state="translated">COM1</target>
        </trans-unit>
        <trans-unit id="23f35962de37902073c854bc889f0133b87d83ae" translate="yes" xml:space="preserve">
          <source>COM9</source>
          <target state="translated">COM9</target>
        </trans-unit>
        <trans-unit id="cbb44b8d4066ca53d103823d7579880a884c46f2" translate="yes" xml:space="preserve">
          <source>CTL</source>
          <target state="translated">CTL</target>
        </trans-unit>
        <trans-unit id="b38bed0f0e9601a07358ec72777da31f91720f2a" translate="yes" xml:space="preserve">
          <source>CTRL</source>
          <target state="translated">CTRL</target>
        </trans-unit>
        <trans-unit id="5e1dd8155002a7d7db24335015acaddd25a44f09" translate="yes" xml:space="preserve">
          <source>CVS</source>
          <target state="translated">CVS</target>
        </trans-unit>
        <trans-unit id="36e5803b7728bb1569947feca18d17ebe22e40b0" translate="yes" xml:space="preserve">
          <source>Calendrical conversion functions always use the Gregorian calendar, even for dates before the Gregorian calendar was introduced. Year numbers count the number of years since the year 1 BC, and do not skip zero as traditional Gregorian years do; for example, the year number -37 represents the Gregorian year 38 BC.</source>
          <target state="translated">カレンドリカル変換関数は、グレゴリオ暦が導入される前の日付であっても、常にグレゴリオ暦を使用します。年号は紀元前1年からの年数を数え、伝統的なグレゴリオ暦のようにゼロをスキップしません;例えば、年号-37はグレゴリオ暦紀元前38年を表します。</target>
        </trans-unit>
        <trans-unit id="de42e995f53f7e732b05aa461dce2010e145fa00" translate="yes" xml:space="preserve">
          <source>Call &lt;var&gt;button&lt;/var&gt;&amp;rsquo;s &lt;code&gt;action&lt;/code&gt; property (i.e., invoke the function that is the value of that property, passing it the single argument &lt;var&gt;button&lt;/var&gt;). If &lt;var&gt;use-mouse-action&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, try to invoke the button&amp;rsquo;s &lt;code&gt;mouse-action&lt;/code&gt; property instead of &lt;code&gt;action&lt;/code&gt;; if the button has no &lt;code&gt;mouse-action&lt;/code&gt; property, use &lt;code&gt;action&lt;/code&gt; as normal. If the &lt;code&gt;button-data&lt;/code&gt; property is present in &lt;var&gt;button&lt;/var&gt;, use that as the argument for the &lt;code&gt;action&lt;/code&gt; function instead of &lt;var&gt;button&lt;/var&gt;.</source>
          <target state="translated">通話 &lt;var&gt;button&lt;/var&gt; の &lt;code&gt;action&lt;/code&gt; （その単一の引数を渡し、そのプロパティの値である機能のinvokeすなわち、プロパティ &lt;var&gt;button&lt;/var&gt; ）。場合は &lt;var&gt;use-mouse-action&lt;/var&gt; 非で &lt;code&gt;nil&lt;/code&gt; で、ボタンの起動しようとする &lt;code&gt;mouse-action&lt;/code&gt; の代わりにプロパティを &lt;code&gt;action&lt;/code&gt; 。ボタンに &lt;code&gt;mouse-action&lt;/code&gt; プロパティがない場合は、通常どおり &lt;code&gt;action&lt;/code&gt; を使用します。 &lt;code&gt;button-data&lt;/code&gt; プロパティが &lt;var&gt;button&lt;/var&gt; に存在する場合は、buttonの代わりにそれを &lt;code&gt;action&lt;/code&gt; 関数の引数として使用し &lt;var&gt;button&lt;/var&gt; 。</target>
        </trans-unit>
        <trans-unit id="f7e81e62a0bc26dffa21e5943c5b76d235ec9103" translate="yes" xml:space="preserve">
          <source>Call &lt;var&gt;function&lt;/var&gt; after the old function and only if the old function returned &lt;code&gt;nil&lt;/code&gt;. More specifically, the composition of the two functions behaves like:</source>
          <target state="translated">古い &lt;var&gt;function&lt;/var&gt; 後で、古い関数が &lt;code&gt;nil&lt;/code&gt; を返した場合にのみ関数を呼び出します。より具体的には、2つの関数の構成は次のように動作します。</target>
        </trans-unit>
        <trans-unit id="15f89cad7964a4c4ff36312550efc21a307afff6" translate="yes" xml:space="preserve">
          <source>Call &lt;var&gt;function&lt;/var&gt; after the old function and only if the old function returned non-&lt;code&gt;nil&lt;/code&gt;. Both functions receive the same arguments, and the return value of the composition is the return value of &lt;var&gt;function&lt;/var&gt;. More specifically, the composition of the two functions behaves like:</source>
          <target state="translated">古い &lt;var&gt;function&lt;/var&gt; 後で、古い関数が &lt;code&gt;nil&lt;/code&gt; 以外を返した場合にのみ関数を呼び出します。両方の関数は同じ引数を受け取り、コンポジションの戻り値は &lt;var&gt;function&lt;/var&gt; 戻り値です。より具体的には、2つの関数の構成は次のように動作します。</target>
        </trans-unit>
        <trans-unit id="11b9ee6402d0942f809e7bacb34c109edce11c8a" translate="yes" xml:space="preserve">
          <source>Call &lt;var&gt;function&lt;/var&gt; after the old function. Both functions receive the same arguments, and the return value of the composition is the return value of the old function. More specifically, the composition of the two functions behaves like:</source>
          <target state="translated">古い &lt;var&gt;function&lt;/var&gt; 後に関数を呼び出します。両方の関数は同じ引数を受け取り、コンポジションの戻り値は古い関数の戻り値です。より具体的には、2つの関数の構成は次のように動作します。</target>
        </trans-unit>
        <trans-unit id="dd45f95fef4e571698af292b7cdd92bffd8265e2" translate="yes" xml:space="preserve">
          <source>Call &lt;var&gt;function&lt;/var&gt; before the old function and don&amp;rsquo;t call the old function if &lt;var&gt;function&lt;/var&gt; returns &lt;code&gt;nil&lt;/code&gt;. Both functions receive the same arguments, and the return value of the composition is the return value of the old function. More specifically, the composition of the two functions behaves like:</source>
          <target state="translated">通話 &lt;var&gt;function&lt;/var&gt; ならば、古い関数の前とすると、古い関数を呼び出していない &lt;var&gt;function&lt;/var&gt; 戻り &lt;code&gt;nil&lt;/code&gt; 。両方の関数は同じ引数を受け取り、コンポジションの戻り値は古い関数の戻り値です。より具体的には、2つの関数の構成は次のように動作します。</target>
        </trans-unit>
        <trans-unit id="e177089f3e47a75e445f46873115fbe430078933" translate="yes" xml:space="preserve">
          <source>Call &lt;var&gt;function&lt;/var&gt; before the old function and only call the old function if &lt;var&gt;function&lt;/var&gt; returns &lt;code&gt;nil&lt;/code&gt;. More specifically, the composition of the two functions behaves like:</source>
          <target state="translated">通話 &lt;var&gt;function&lt;/var&gt; 、古い機能の前にしている場合にのみ、古い関数を呼び出す &lt;var&gt;function&lt;/var&gt; を返すの &lt;code&gt;nil&lt;/code&gt; 。より具体的には、2つの関数の構成は次のように動作します。</target>
        </trans-unit>
        <trans-unit id="5a61495f3b296416244dbb85cc0933049276d9d5" translate="yes" xml:space="preserve">
          <source>Call &lt;var&gt;function&lt;/var&gt; before the old function. Both functions receive the same arguments, and the return value of the composition is the return value of the old function. More specifically, the composition of the two functions behaves like:</source>
          <target state="translated">古い &lt;var&gt;function&lt;/var&gt; 前に関数を呼び出します。両方の関数は同じ引数を受け取り、コンポジションの戻り値は古い関数の戻り値です。より具体的には、2つの関数の構成は次のように動作します。</target>
        </trans-unit>
        <trans-unit id="f4cc04f8d665904345400ebc070afe6901974fc2" translate="yes" xml:space="preserve">
          <source>Call &lt;var&gt;function&lt;/var&gt; first and use the result (which should be a list) as the new arguments to pass to the old function. More specifically, the composition of the two functions behaves like:</source>
          <target state="translated">最初に &lt;var&gt;function&lt;/var&gt; 呼び出し、その結果（リストである必要があります）を新しい引数として使用して、古い関数に渡します。より具体的には、2つの関数の構成は次のように動作します。</target>
        </trans-unit>
        <trans-unit id="e77c6828a07ec693781d6efe3e57ff1a5a36a8c0" translate="yes" xml:space="preserve">
          <source>Call &lt;var&gt;function&lt;/var&gt; for characters in &lt;var&gt;charset&lt;/var&gt;. &lt;var&gt;function&lt;/var&gt; is called with two arguments. The first one is a cons cell &lt;code&gt;(&lt;var&gt;from&lt;/var&gt; .  &lt;var&gt;to&lt;/var&gt;)&lt;/code&gt;, where &lt;var&gt;from&lt;/var&gt; and &lt;var&gt;to&lt;/var&gt; indicate a range of characters contained in charset. The second argument passed to &lt;var&gt;function&lt;/var&gt; is &lt;var&gt;arg&lt;/var&gt;.</source>
          <target state="translated">&lt;var&gt;charset&lt;/var&gt; 内の文字の &lt;var&gt;function&lt;/var&gt; を呼び出します。 &lt;var&gt;function&lt;/var&gt; は2つの引数で呼び出されます。最初のものは、コンス・セルである &lt;code&gt;(&lt;var&gt;from&lt;/var&gt; . &lt;var&gt;to&lt;/var&gt;)&lt;/code&gt; &lt;var&gt;from&lt;/var&gt; 。 &lt;var&gt;to&lt;/var&gt; ）、 &lt;var&gt;from&lt;/var&gt; と &lt;var&gt;to&lt;/var&gt; 文字セットに含まれる文字の範囲を示しています。 &lt;var&gt;function&lt;/var&gt; 渡される2番目の引数は &lt;var&gt;arg&lt;/var&gt; です。</target>
        </trans-unit>
        <trans-unit id="fae0114c2201a949abeef4209c12323f1f0e324b" translate="yes" xml:space="preserve">
          <source>Call &lt;var&gt;function&lt;/var&gt; for every piece of advice that was added to the named function &lt;var&gt;symbol&lt;/var&gt;. &lt;var&gt;function&lt;/var&gt; is called with two arguments: the advice function and its properties.</source>
          <target state="translated">名前付き関数 &lt;var&gt;symbol&lt;/var&gt; に追加されたすべてのアドバイスに対して &lt;var&gt;function&lt;/var&gt; を呼び出します。 &lt;var&gt;function&lt;/var&gt; は、アドバイス関数とそのプロパティの2つの引数で呼び出されます。</target>
        </trans-unit>
        <trans-unit id="567ee80f88e9b6fcfc133e840199c180bb8db2d1" translate="yes" xml:space="preserve">
          <source>Call &lt;var&gt;function&lt;/var&gt; instead of the old function, but provide the old function as an extra argument to &lt;var&gt;function&lt;/var&gt;. This is the most flexible composition. For example, it lets you call the old function with different arguments, or many times, or within a let-binding, or you can sometimes delegate the work to the old function and sometimes override it completely. More specifically, the composition of the two functions behaves like:</source>
          <target state="translated">古い &lt;var&gt;function&lt;/var&gt; 代わりに関数を呼び出しますが、関数への追加の引数として古い関数を提供し &lt;var&gt;function&lt;/var&gt; 。これは最も柔軟な構成です。たとえば、古い関数を異なる引数で、何度も、またはlet-binding内で呼び出すことができます。また、作業を古い関数に委任して、完全にオーバーライドすることもできます。より具体的には、2つの関数の構成は次のように動作します。</target>
        </trans-unit>
        <trans-unit id="d1a7d71503696cf38410fc1322aa1095b06486f0" translate="yes" xml:space="preserve">
          <source>Call the anonymous function with one argument, &lt;var&gt;expval&lt;/var&gt; (see &lt;a href=&quot;lambda-expressions#Lambda-Expressions&quot;&gt;Lambda Expressions&lt;/a&gt;).</source>
          <target state="translated">&lt;var&gt;expval&lt;/var&gt; という1つの引数を使用して無名関数を呼び出します（&lt;a href=&quot;lambda-expressions#Lambda-Expressions&quot;&gt;Lambda式を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="7476fa450c9cf57b9d41330c2668e502b573753f" translate="yes" xml:space="preserve">
          <source>Call the function (the first element of the function call) with &lt;var&gt;n&lt;/var&gt; arguments (the other elements) and an additional &lt;var&gt;n&lt;/var&gt;+1-th argument that is &lt;var&gt;expval&lt;/var&gt;.</source>
          <target state="translated">&lt;var&gt;n&lt;/var&gt; 個の引数（他の要素）と、 &lt;var&gt;expval&lt;/var&gt; である追加の &lt;var&gt;n&lt;/var&gt; +1番目の引数を使用して関数（関数呼び出しの最初の要素）を呼び出します。</target>
        </trans-unit>
        <trans-unit id="cce8159a07f7ca94dd3aede2fb066a149472cac4" translate="yes" xml:space="preserve">
          <source>Call the function &lt;var&gt;f&lt;/var&gt; for every piece of advice that was added to &lt;var&gt;function-def&lt;/var&gt;. &lt;var&gt;f&lt;/var&gt; is called with two arguments: the advice function and its properties.</source>
          <target state="translated">&lt;var&gt;function-def&lt;/var&gt; に追加されたアドバイスごとに、関数 &lt;var&gt;f&lt;/var&gt; を呼び出します。 &lt;var&gt;f&lt;/var&gt; は、アドバイス関数とそのプロパティの2つの引数で呼び出されます。</target>
        </trans-unit>
        <trans-unit id="f7bee42ac2cfe40e42c5b3d7a4488a39eab8279c" translate="yes" xml:space="preserve">
          <source>Call the named function with one argument, &lt;var&gt;expval&lt;/var&gt;.</source>
          <target state="translated">1つの引数 &lt;var&gt;expval&lt;/var&gt; を使用して名前付き関数を呼び出します。</target>
        </trans-unit>
        <trans-unit id="c5bef85c072afa5ae3f80c86a71f855f8cba1aac" translate="yes" xml:space="preserve">
          <source>Call the old function first and pass the result to &lt;var&gt;function&lt;/var&gt;. More specifically, the composition of the two functions behaves like:</source>
          <target state="translated">最初に古い関数を呼び出し、その結果を &lt;var&gt;function&lt;/var&gt; 渡します。より具体的には、2つの関数の構成は次のように動作します。</target>
        </trans-unit>
        <trans-unit id="6afd776be5db841a6dc68b637bb932e7dfca56a9" translate="yes" xml:space="preserve">
          <source>Call this command after using &lt;code&gt;smie-config-guess&lt;/code&gt;, to save your settings for future sessions.</source>
          <target state="translated">&lt;code&gt;smie-config-guess&lt;/code&gt; を使用した後にこのコマンドを呼び出して、将来のセッションのために設定を保存します。</target>
        </trans-unit>
        <trans-unit id="8506342e0260dd8016e03d646af20a2c9018a199" translate="yes" xml:space="preserve">
          <source>Call this function instead of using a literal value (usually, zero) of the column number for indenting top-level program constructs. The function&amp;rsquo;s value is the column number to use for top-level constructs. When no superior mode is in effect, this function returns zero.</source>
          <target state="translated">トップレベルのプログラム構造をインデントするために列番号のリテラル値（通常はゼロ）を使用する代わりに、この関数を呼び出します。関数の値は、最上位の構成に使用する列番号です。上位モードが有効になっていない場合、この関数はゼロを返します。</target>
        </trans-unit>
        <trans-unit id="98d6a6a2c4f2e6e0e83bdfbcc0730217802507ab" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;concat&lt;/code&gt; converts the list to a string so you can see its contents more clearly.</source>
          <target state="translated">&lt;code&gt;concat&lt;/code&gt; を呼び出すと、リストが文字列に変換されるため、内容をより明確に確認できます。</target>
        </trans-unit>
        <trans-unit id="aa38eb2554dbe5c7a33e4b709e55fe4dded0e886" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;smie-setup&lt;/code&gt; is also sufficient to make</source>
          <target state="translated">&lt;code&gt;smie-setup&lt;/code&gt; を呼び出すだけでも十分です。</target>
        </trans-unit>
        <trans-unit id="511ba4c0240efeaabfee01e6c6a8c90f51297283" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;substitute-in-file-name&lt;/code&gt; on output produced by &lt;code&gt;substitute-in-file-name&lt;/code&gt; tends to give incorrect results. For instance, use of &amp;lsquo;</source>
          <target state="translated">呼び出し &lt;code&gt;substitute-in-file-name&lt;/code&gt; によって生成される出力の &lt;code&gt;substitute-in-file-name&lt;/code&gt; 誤った結果を与える傾向があります。たとえば、 'の使用</target>
        </trans-unit>
        <trans-unit id="9ac3d844132b984a3eb47bf8dcb79e4bbd848878" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;window-preserve-size&lt;/code&gt; (see &lt;a href=&quot;preserving-window-sizes#Preserving-Window-Sizes&quot;&gt;Preserving Window Sizes&lt;/a&gt;) will try to keep the size of the argument window unchanged when popping up a new window. You have to make sure that another window in the same combination can be shrunk instead, though.</source>
          <target state="translated">&lt;code&gt;window-preserve-size&lt;/code&gt; を呼び出すと（「&lt;a href=&quot;preserving-window-sizes#Preserving-Window-Sizes&quot;&gt;ウィンドウサイズの&lt;/a&gt;保持」を参照）、新しいウィンドウをポップアップするときに引数ウィンドウのサイズを変更しないようにします。ただし、同じ組み合わせの別のウィンドウを代わりに縮小できることを確認する必要があります。</target>
        </trans-unit>
        <trans-unit id="2f2b1f5f71d89e54c8503e6cf93a04999cc1b58a" translate="yes" xml:space="preserve">
          <source>Calling Functions</source>
          <target state="translated">呼び出し機能</target>
        </trans-unit>
        <trans-unit id="504886a8ce3a7ab2de140289b5cdac7f6b388ff2" translate="yes" xml:space="preserve">
          <source>Calling a command, so that it will read arguments.</source>
          <target state="translated">コマンドを呼び出すことで、引数を読み込むようにします。</target>
        </trans-unit>
        <trans-unit id="a961505da75e77209eaa6b59e8f61a3dffb36635" translate="yes" xml:space="preserve">
          <source>Calling the major mode command twice in direct succession should not fail and should do the same thing as calling the command only once. In other words, the major mode command should be idempotent.</source>
          <target state="translated">メジャーモードコマンドを2回連続して呼び出しても失敗してはならず、1回だけ呼び出したのと同じことをしなければなりません。言い換えれば、メジャーモードコマンドは、偶数でなければなりません。</target>
        </trans-unit>
        <trans-unit id="1e6c66b20a23a26c0a918b56cec3c86770820c22" translate="yes" xml:space="preserve">
          <source>Calling this function explicitly is useful for splitting the effects of a command into more than one unit. For example, &lt;code&gt;query-replace&lt;/code&gt; calls &lt;code&gt;undo-boundary&lt;/code&gt; after each replacement, so that the user can undo individual replacements one by one.</source>
          <target state="translated">この関数を明示的に呼び出すと、コマンドの効果を複数のユニットに分割するのに役立ちます。たとえば、 &lt;code&gt;query-replace&lt;/code&gt; は、各置換の後に &lt;code&gt;undo-boundary&lt;/code&gt; を呼び出すため、ユーザーは個々の置換を1つずつ元に戻すことができます。</target>
        </trans-unit>
        <trans-unit id="8a5bda3d28236066116676706c47de1d0f0328a6" translate="yes" xml:space="preserve">
          <source>Calling this function is sufficient to make commands such as &lt;code&gt;forward-sexp&lt;/code&gt;, &lt;code&gt;backward-sexp&lt;/code&gt;, and &lt;code&gt;transpose-sexps&lt;/code&gt; be able to properly handle structural elements other than just the paired parentheses already handled by syntax tables. For example, if the provided grammar is precise enough, &lt;code&gt;transpose-sexps&lt;/code&gt; can correctly transpose the two arguments of a &lt;code&gt;+&lt;/code&gt; operator, taking into account the precedence rules of the language.</source>
          <target state="translated">この関数を呼び出すだけで、 &lt;code&gt;forward-sexp&lt;/code&gt; 、 &lt;code&gt;backward-sexp&lt;/code&gt; 、 &lt;code&gt;transpose-sexps&lt;/code&gt; などのコマンドで、構文テーブルで既に処理されているペアの括弧以外の構造要素を適切に処理できるようになります。たとえば、提供された文法が十分に正確である場合、 &lt;code&gt;transpose-sexps&lt;/code&gt; は、言語の優先順位規則を考慮して、 &lt;code&gt;+&lt;/code&gt; 演算子の2つの引数を正しく転置できます。</target>
        </trans-unit>
        <trans-unit id="e5b34fd5a2e36cd4eafb9c4fcecc3d11f251e2e3" translate="yes" xml:space="preserve">
          <source>Cannot determine image type</source>
          <target state="translated">画像の種類を判断できない</target>
        </trans-unit>
        <trans-unit id="c1186dd76154d57de923217a8dd3d16441be124a" translate="yes" xml:space="preserve">
          <source>Cannot open load file &lt;var&gt;filename&lt;/var&gt;</source>
          <target state="translated">ロードファイルのファイル &lt;var&gt;filename&lt;/var&gt; 開くことができません</target>
        </trans-unit>
        <trans-unit id="311dff8ce71dc0b4b0666e7280ad010d93e7918a" translate="yes" xml:space="preserve">
          <source>Capture groups</source>
          <target state="translated">キャプチャグループ</target>
        </trans-unit>
        <trans-unit id="5fe52af8b2d198c370691f5d3a5caec003b55dcc" translate="yes" xml:space="preserve">
          <source>Case Changes</source>
          <target state="translated">ケースチェンジ</target>
        </trans-unit>
        <trans-unit id="ff5641735ee7c07e5eed18f7107abe940e61dcc3" translate="yes" xml:space="preserve">
          <source>Case Conversion in Lisp</source>
          <target state="translated">Lispでの大文字小文字の変換</target>
        </trans-unit>
        <trans-unit id="ee05e5edf5d51051d5e8ea58e5fb1140b748c002" translate="yes" xml:space="preserve">
          <source>Case conversion functions.</source>
          <target state="translated">ケース変換機能を搭載しています。</target>
        </trans-unit>
        <trans-unit id="4fc7e1d52f22796c47c268de900d6e7082017f5a" translate="yes" xml:space="preserve">
          <source>Case conversion of parts of the buffer.</source>
          <target state="translated">バッファーの部品のケース変換</target>
        </trans-unit>
        <trans-unit id="60f886006f4b5be396aef39220ae04232401704b" translate="yes" xml:space="preserve">
          <source>Case tables (see &lt;a href=&quot;case-tables#Case-Tables&quot;&gt;Case Tables&lt;/a&gt;).</source>
          <target state="translated">ケーステーブル（参照&lt;a href=&quot;case-tables#Case-Tables&quot;&gt;ケーステーブル&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="760a611d6b77c0b6b7da5b461fa97629808e415a" translate="yes" xml:space="preserve">
          <source>Case-independent or case-significant searching.</source>
          <target state="translated">ケースに依存しない検索、またはケースに依存しない検索。</target>
        </trans-unit>
        <trans-unit id="6ccb60071be8f00760a3824d9f7d0fad57de789f" translate="yes" xml:space="preserve">
          <source>Categories</source>
          <target state="translated">Categories</target>
        </trans-unit>
        <trans-unit id="c62bb44b2dbb1eab36c5fe60b6989181f7595720" translate="yes" xml:space="preserve">
          <source>Category character</source>
          <target state="translated">カテゴリーキャラクター</target>
        </trans-unit>
        <trans-unit id="ed3dc45ada47ab5b03a62a82e4fe63e2c08a4aa5" translate="yes" xml:space="preserve">
          <source>Category name</source>
          <target state="translated">カテゴリ名</target>
        </trans-unit>
        <trans-unit id="21ee11841e5216e7932316a3ba9dbe3bf176d378" translate="yes" xml:space="preserve">
          <source>Causes the server to suppress playing any sounds, if it has that ability.</source>
          <target state="translated">サーバーがその機能を持っている場合、サウンドを再生しないようにします。</target>
        </trans-unit>
        <trans-unit id="bcaa33a7ae44bd5042c37a9cdbea7f843b1cf7c8" translate="yes" xml:space="preserve">
          <source>Caveats</source>
          <target state="translated">Caveats</target>
        </trans-unit>
        <trans-unit id="983a41bf08948cb10ca36f96d754fedb2fa51108" translate="yes" xml:space="preserve">
          <source>Caveats for &lt;var&gt;symbol&lt;/var&gt; in Sequencing Patterns</source>
          <target state="translated">シーケンスパターンの &lt;var&gt;symbol&lt;/var&gt; に関する警告</target>
        </trans-unit>
        <trans-unit id="10c846191e34dad7942410f081d90ef9a60dccb4" translate="yes" xml:space="preserve">
          <source>Certain &lt;em&gt;special events&lt;/em&gt; are handled at a very low level&amp;mdash;as soon as they are read. The &lt;code&gt;read-event&lt;/code&gt; function processes these events itself, and never returns them. Instead, it keeps waiting for the first event that is not special and returns that one.</source>
          <target state="translated">特定の&lt;em&gt;特別なイベント&lt;/em&gt;は、読み取られるとすぐに、非常に低いレベルで処理されます。 &lt;code&gt;read-event&lt;/code&gt; 機能は、これらのイベント自体を処理し、それらを返すことはありません。代わりに、特別ではない最初のイベントを待ち続け、そのイベントを返します。</target>
        </trans-unit>
        <trans-unit id="2668c38616b8f82385530ab10556316664076de7" translate="yes" xml:space="preserve">
          <source>Certain abbrevs, called &lt;em&gt;system abbrevs&lt;/em&gt;, are defined by a major mode instead of the user. A system abbrev is identified by its non-&lt;code&gt;nil&lt;/code&gt;&lt;code&gt;:system&lt;/code&gt; property (see &lt;a href=&quot;abbrev-properties#Abbrev-Properties&quot;&gt;Abbrev Properties&lt;/a&gt;). When abbrevs are saved to an abbrev file, system abbrevs are omitted. See &lt;a href=&quot;abbrev-files#Abbrev-Files&quot;&gt;Abbrev Files&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;システム略語&lt;/em&gt;と呼ばれる特定の略語は、ユーザーではなくメジャーモードによって定義されます。システムの略語は、そのnon- &lt;code&gt;nil&lt;/code&gt; &lt;code&gt;:system&lt;/code&gt; プロパティによって識別されます（&lt;a href=&quot;abbrev-properties#Abbrev-Properties&quot;&gt;略語のプロパティを&lt;/a&gt;参照）。略語を略語ファイルに保存する場合、システムの略語は省略されます。&lt;a href=&quot;abbrev-files#Abbrev-Files&quot;&gt;略語ファイルを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="bb70bbca935cc9ba0d3270144cb857746601caf3" translate="yes" xml:space="preserve">
          <source>Certain format specifications require values of particular types. If you supply a value that doesn&amp;rsquo;t fit the requirements, an error is signaled.</source>
          <target state="translated">特定のフォーマット仕様では、特定のタイプの値が必要です。要件に適合しない値を指定すると、エラーが通知されます。</target>
        </trans-unit>
        <trans-unit id="17f9520304f622d054d6e6a095bc91eb04688136" translate="yes" xml:space="preserve">
          <source>Certain function-like objects, called &lt;em&gt;special forms&lt;/em&gt; and &lt;em&gt;macros&lt;/em&gt;, also accept arguments to carry out computations. However, as explained below, these are not considered functions in Emacs Lisp.</source>
          <target state="translated">&lt;em&gt;特殊なフォーム&lt;/em&gt;や&lt;em&gt;マクロ&lt;/em&gt;と呼ばれる特定の関数のようなオブジェクトも、引数を受け入れて計算を実行します。ただし、以下で説明するように、これらはEmacsLispの関数とは見なされません。</target>
        </trans-unit>
        <trans-unit id="a3317a453486426103c83a8405cdf6293656cb02" translate="yes" xml:space="preserve">
          <source>Certain functions such as &lt;code&gt;read-key-sequence&lt;/code&gt; or &lt;code&gt;read-quoted-char&lt;/code&gt; prevent quitting entirely even though they wait for input. Instead of quitting,</source>
          <target state="translated">&lt;code&gt;read-key-sequence&lt;/code&gt; や &lt;code&gt;read-quoted-char&lt;/code&gt; などの特定の関数は、入力を待っていても完全に終了することを防ぎます。やめる代わりに、</target>
        </trans-unit>
        <trans-unit id="9781a84dc281e4b3ac7e8fb884e18e00f10c91d8" translate="yes" xml:space="preserve">
          <source>Certain other values of &lt;var&gt;separator-type&lt;/var&gt; specify a different style of separator. Here is a table of them:</source>
          <target state="translated">&lt;var&gt;separator-type&lt;/var&gt; 他の特定の値は、異なるスタイルのセパレータを指定します。それらの表は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="b28516fbcb8e500a178b2a631de8639fdef46b0f" translate="yes" xml:space="preserve">
          <source>Certain text properties are meaningful in the mode line. The &lt;code&gt;face&lt;/code&gt; property affects the appearance of text; the &lt;code&gt;help-echo&lt;/code&gt; property associates help strings with the text, and &lt;code&gt;keymap&lt;/code&gt; can make the text mouse-sensitive.</source>
          <target state="translated">特定のテキストプロパティは、モード行で意味があります。 &lt;code&gt;face&lt;/code&gt; プロパティは、テキストの外観に影響を与えます。 &lt;code&gt;help-echo&lt;/code&gt; プロパティを関連付けヘルプテキストを含む文字列、および &lt;code&gt;keymap&lt;/code&gt; テキストをマウスに敏感にすることができます。</target>
        </trans-unit>
        <trans-unit id="78b3210742dadf1e3c0eabba8c8ed5204a166dda" translate="yes" xml:space="preserve">
          <source>Change Hooks</source>
          <target state="translated">フックの変更</target>
        </trans-unit>
        <trans-unit id="b474b780b926dcbfa75d96cb86ad31c3233c390b" translate="yes" xml:space="preserve">
          <source>Change the font-related attributes of &lt;var&gt;face&lt;/var&gt; to those of &lt;var&gt;font&lt;/var&gt; (a string or a font object). See &lt;a href=&quot;face-attributes#face_002dfont_002dattribute&quot;&gt;face-font-attribute&lt;/a&gt;, for the supported formats of the &lt;var&gt;font&lt;/var&gt; argument. This function sets the attribute &lt;code&gt;:font&lt;/code&gt; of the face, and indirectly also the &lt;code&gt;:family&lt;/code&gt;, &lt;code&gt;:foundry&lt;/code&gt;, &lt;code&gt;:width&lt;/code&gt;, &lt;code&gt;:height&lt;/code&gt;, &lt;code&gt;:weight&lt;/code&gt;, and &lt;code&gt;:slant&lt;/code&gt; attributes, as defined by the font. If &lt;var&gt;frame&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, only change the attributes on the specified frame.</source>
          <target state="translated">フォント関連の属性変更 &lt;var&gt;face&lt;/var&gt; のものに &lt;var&gt;font&lt;/var&gt; （文字列フォントオブジェクト）。 &lt;var&gt;font&lt;/var&gt; 引数のサポートされている形式については、&lt;a href=&quot;face-attributes#face_002dfont_002dattribute&quot;&gt;face-font-attributeを&lt;/a&gt;参照してください。この関数は、 &lt;code&gt;:font&lt;/code&gt; で定義されているように、顔の属性：fontを設定し、間接的に &lt;code&gt;:family&lt;/code&gt; 、 &lt;code&gt;:foundry&lt;/code&gt; 、 &lt;code&gt;:width&lt;/code&gt; 、 &lt;code&gt;:height&lt;/code&gt; 、 &lt;code&gt;:weight&lt;/code&gt; 、および &lt;code&gt;:slant&lt;/code&gt; 属性も設定します。 &lt;var&gt;frame&lt;/var&gt; が &lt;code&gt;nil&lt;/code&gt; 以外の場合は、指定されたフレームの属性のみを変更します。</target>
        </trans-unit>
        <trans-unit id="100a984c74cd76a27c5abd1250aa8a0325533085" translate="yes" xml:space="preserve">
          <source>Changes in process sentinels take effect immediately&amp;mdash;if the sentinel is slated to be run but has not been called yet, and you specify a new sentinel, the eventual call to the sentinel will use the new one.</source>
          <target state="translated">プロセスセンチネルの変更はすぐに有効になります。センチネルが実行される予定であるがまだ呼び出されていない場合、新しいセンチネルを指定すると、センチネルへの最終的な呼び出しで新しいセンチネルが使用されます。</target>
        </trans-unit>
        <trans-unit id="156524b67d9176e9980be07f37b022c85504061b" translate="yes" xml:space="preserve">
          <source>Changing File Names and Attributes</source>
          <target state="translated">ファイル名と属性の変更</target>
        </trans-unit>
        <trans-unit id="51016b235a030223e05c662ad0783ea8a9b72574" translate="yes" xml:space="preserve">
          <source>Changing Key Bindings</source>
          <target state="translated">キーバインドの変更</target>
        </trans-unit>
        <trans-unit id="7594cb533c4a496e3f17056c9667959d56338aee" translate="yes" xml:space="preserve">
          <source>Changing Text Properties</source>
          <target state="translated">テキストのプロパティを変更する</target>
        </trans-unit>
        <trans-unit id="de45395bd6cb72dc2da08ba6aae7cf507d1e0f7f" translate="yes" xml:space="preserve">
          <source>Changing any of the &lt;code&gt;scroll-bar-width&lt;/code&gt;, &lt;code&gt;scroll-bar-height&lt;/code&gt;, &lt;code&gt;vertical-scroll-bars&lt;/code&gt;, &lt;code&gt;horizontal-scroll-bars&lt;/code&gt;, &lt;code&gt;left-fringe&lt;/code&gt; and &lt;code&gt;right-fringe&lt;/code&gt; frame parameters is handled as if the frame contained just one live window. This means, for example, that removing vertical scroll bars on a frame containing several side by side windows will shrink the outer frame width by the width of one scroll bar provided this option is &lt;code&gt;nil&lt;/code&gt; and keep it unchanged if this option is &lt;code&gt;t&lt;/code&gt; or a list containing &lt;code&gt;vertical-scroll-bars&lt;/code&gt;.</source>
          <target state="translated">いずれかを変更する &lt;code&gt;scroll-bar-width&lt;/code&gt; 、 &lt;code&gt;scroll-bar-height&lt;/code&gt; 、 &lt;code&gt;vertical-scroll-bars&lt;/code&gt; 、 &lt;code&gt;horizontal-scroll-bars&lt;/code&gt; 、 &lt;code&gt;left-fringe&lt;/code&gt; と &lt;code&gt;right-fringe&lt;/code&gt; フレームは一つだけのライブウィンドウが含まれているかのようフレームのパラメータが処理されます。これは、たとえば、複数のウィンドウが並んでいるフレームで垂直スクロールバーを削除すると、このオプションが &lt;code&gt;nil&lt;/code&gt; の場合、外側のフレーム幅が1つのスクロールバーの幅だけ縮小され、このオプションが &lt;code&gt;t&lt;/code&gt; またはリストの場合は変更されないことを意味します。 &lt;code&gt;vertical-scroll-bars&lt;/code&gt; を含む。</target>
        </trans-unit>
        <trans-unit id="fd7f426a8c11556d236e6fe7c9beb52aa001a64a" translate="yes" xml:space="preserve">
          <source>Changing point.</source>
          <target state="translated">ポイントを変更します。</target>
        </trans-unit>
        <trans-unit id="35bbf3ed9b965bfacb89f9f800e62d4fe12c4c01" translate="yes" xml:space="preserve">
          <source>Changing the &lt;small&gt;CAR&lt;/small&gt; of a cons cell is done with &lt;code&gt;setcar&lt;/code&gt;. When used on a list, &lt;code&gt;setcar&lt;/code&gt; replaces one element of a list with a different element.</source>
          <target state="translated">consセルの&lt;small&gt;CAR&lt;/small&gt;の変更は、 &lt;code&gt;setcar&lt;/code&gt; を使用して行われます。リストで使用すると、 &lt;code&gt;setcar&lt;/code&gt; はリストの1つの要素を別の要素に置き換えます。</target>
        </trans-unit>
        <trans-unit id="562e2b4207b6c404cf6c751160157bd49ac95781" translate="yes" xml:space="preserve">
          <source>Changing the sizes of windows.</source>
          <target state="translated">窓のサイズを変更する</target>
        </trans-unit>
        <trans-unit id="6a1f8e8787fc1acb606cc50f5b6e9d8f7bdd458d" translate="yes" xml:space="preserve">
          <source>Changing this variable does not force an update of the mode line.</source>
          <target state="translated">この変数を変更しても、モードラインの更新は強制されません。</target>
        </trans-unit>
        <trans-unit id="f0c739408abd052ee5d44db4e8e0adc91f0b680a" translate="yes" xml:space="preserve">
          <source>Char-Table Type</source>
          <target state="translated">文字テーブル型</target>
        </trans-unit>
        <trans-unit id="ce090131f8a640a66d14740f37efd79c98da2f52" translate="yes" xml:space="preserve">
          <source>Char-Tables</source>
          <target state="translated">Char-Tables</target>
        </trans-unit>
        <trans-unit id="89a0d26064c88761be4481b9b52065531e5e024c" translate="yes" xml:space="preserve">
          <source>Character Classes</source>
          <target state="translated">文字クラス</target>
        </trans-unit>
        <trans-unit id="8cd166d7b5c972d19c78d965c26afe0d852a6bbc" translate="yes" xml:space="preserve">
          <source>Character Codes</source>
          <target state="translated">文字コード</target>
        </trans-unit>
        <trans-unit id="198408dd9120e5714424c5f00fa2e02c78a9427b" translate="yes" xml:space="preserve">
          <source>Character Display</source>
          <target state="translated">文字表示</target>
        </trans-unit>
        <trans-unit id="b1c5fa0155ae3ab9ad380fa3cfc349d0a0ec23e9" translate="yes" xml:space="preserve">
          <source>Character Properties</source>
          <target state="translated">キャラクターのプロパティ</target>
        </trans-unit>
        <trans-unit id="0e7c11d7a7200a36005057b0e953e12aae6033f0" translate="yes" xml:space="preserve">
          <source>Character Sets</source>
          <target state="translated">キャラクターセット</target>
        </trans-unit>
        <trans-unit id="275450cc1e4926b0829cc65cd3f2b3d835f4e048" translate="yes" xml:space="preserve">
          <source>Character Type</source>
          <target state="translated">文字タイプ</target>
        </trans-unit>
        <trans-unit id="ea8d87953a98f75b2aa021b7b8cb876f766bf6b9" translate="yes" xml:space="preserve">
          <source>Character attributes that define their behavior and handling.</source>
          <target state="translated">その動作や取り扱いを定義するキャラクター属性。</target>
        </trans-unit>
        <trans-unit id="5978dbfeccf01151025eeaa59ed56b27e00fec9f" translate="yes" xml:space="preserve">
          <source>Character category tables (see &lt;a href=&quot;categories#Categories&quot;&gt;Categories&lt;/a&gt;).</source>
          <target state="translated">文字カテゴリテーブル（&lt;a href=&quot;categories#Categories&quot;&gt;カテゴリを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="9755699503a79e3114d0435a6c41d83696a2d623" translate="yes" xml:space="preserve">
          <source>Character classes used in regular expressions.</source>
          <target state="translated">正規表現で使用される文字クラス。</target>
        </trans-unit>
        <trans-unit id="1d5a2032f34ffea795feb6720457cf5de1c95dbd" translate="yes" xml:space="preserve">
          <source>Character quotes: &amp;lsquo;</source>
          <target state="translated">文字の引用符： '</target>
        </trans-unit>
        <trans-unit id="d4eeaab110722d926fe33c40dc614e75f6d0aef8" translate="yes" xml:space="preserve">
          <source>Characteristics of arrays in Emacs Lisp.</source>
          <target state="translated">Emacs Lispにおける配列の特徴。</target>
        </trans-unit>
        <trans-unit id="7295605dcc69f48d0631634d8294614f5cae238b" translate="yes" xml:space="preserve">
          <source>Characters for which there is no suitable font, or which cannot be encoded by the terminal&amp;rsquo;s coding system.</source>
          <target state="translated">適切なフォントがない文字、または端末のコーディングシステムでエンコードできない文字。</target>
        </trans-unit>
        <trans-unit id="f395a989f7613a08007721455bd0e01ef846f3c5" translate="yes" xml:space="preserve">
          <source>Characters in strings and buffers are currently limited to the range of 0 to 4194303&amp;mdash;twenty two bits (see &lt;a href=&quot;character-codes#Character-Codes&quot;&gt;Character Codes&lt;/a&gt;). Codes 0 through 127 are</source>
          <target state="translated">文字列およびバッファ内の文字は、現在0〜4194303の範囲（22ビット）に制限されています（&lt;a href=&quot;character-codes#Character-Codes&quot;&gt;文字コードを&lt;/a&gt;参照）。コード0から127は</target>
        </trans-unit>
        <trans-unit id="2f2d8febd021625a726bddcf901f92bcf114c32e" translate="yes" xml:space="preserve">
          <source>Characters in this class count as part of words if &lt;code&gt;words-include-escapes&lt;/code&gt; is non-&lt;code&gt;nil&lt;/code&gt;. See &lt;a href=&quot;word-motion#Word-Motion&quot;&gt;Word Motion&lt;/a&gt;.</source>
          <target state="translated">このクラスの文字は、 &lt;code&gt;words-include-escapes&lt;/code&gt; が &lt;code&gt;nil&lt;/code&gt; 以外の場合、単語の一部としてカウントされます。参照してください&lt;a href=&quot;word-motion#Word-Motion&quot;&gt;Wordのモーションを&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2a10df5b911a93e079b9555a76636c96ac49a9a5" translate="yes" xml:space="preserve">
          <source>Characters of Unicode General Category [Cf], such as U+200E &lt;small&gt;LEFT-TO-RIGHT MARK&lt;/small&gt;, but excluding characters that have graphic images, such as U+00AD &lt;small&gt;SOFT HYPHEN&lt;/small&gt;.</source>
          <target state="translated">このようU + 200EなどのUnicodeの一般カテゴリの文字[CF]、&lt;small&gt;LEFT-TO-RIGHT MARK&lt;/small&gt;が、そのようなU + 00ADなどのグラフィック画像を、持っている文字を除く&lt;small&gt;SOFT HYPHENを&lt;/small&gt;。</target>
        </trans-unit>
        <trans-unit id="d64597528b4665933dfaeebfdafad56f74f0e55b" translate="yes" xml:space="preserve">
          <source>Characters that have the property &lt;code&gt;inhibit-read-only&lt;/code&gt; can be edited even in read-only buffers. See &lt;a href=&quot;read-only-buffers#Read-Only-Buffers&quot;&gt;Read Only Buffers&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;inhibit-read-only&lt;/code&gt; プロパティを持つ文字は、読み取り専用のバッファーでも編集できます。&lt;a href=&quot;read-only-buffers#Read-Only-Buffers&quot;&gt;読み取り専用バッファを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="e63d767e9c8b2c1671e34752b2089312848063bf" translate="yes" xml:space="preserve">
          <source>Characters that separate symbols and words from each other. Typically, whitespace characters have no other syntactic significance, and multiple whitespace characters are syntactically equivalent to a single one. Space, tab, and formfeed are classified as whitespace in almost all major modes.</source>
          <target state="translated">記号や単語を互いに分離する文字。一般的に、空白文字は他の構文上の意味を持たず、複数の空白文字は1つの空白文字と構文的に等価である。スペース、タブ、およびフォームフィードは、ほとんどすべての主要なモードでホワイトスペースとして分類される。</target>
        </trans-unit>
        <trans-unit id="fa30e64c5637f1d5a32a9a352ecb5ba52a350acf" translate="yes" xml:space="preserve">
          <source>Characters that start an escape sequence, such as is used in string and character constants. The character &amp;lsquo;</source>
          <target state="translated">文字列定数や文字定数で使用されるような、エスケープシーケンスを開始する文字。キャラクター '</target>
        </trans-unit>
        <trans-unit id="c81c548b4c8ec05d54666a049f54eb670318ccea" translate="yes" xml:space="preserve">
          <source>Characters that start or end a special kind of comment. &lt;em&gt;Any&lt;/em&gt; generic comment delimiter matches &lt;em&gt;any&lt;/em&gt; generic comment delimiter, but they cannot match a comment starter or comment ender; generic comment delimiters can only match each other.</source>
          <target state="translated">特別な種類のコメントを開始または終了する文字。&lt;em&gt;任意の&lt;/em&gt;汎用コメント区切り文字は一致する&lt;em&gt;任意の&lt;/em&gt;汎用コメント区切り文字を、彼らはコメントスターターやコメントエンダーと一致することはできません。一般的なコメント区切り文字は、互いにのみ一致できます。</target>
        </trans-unit>
        <trans-unit id="ac7296c49b8b1a6c9dc8eb94911bbbba5328c176" translate="yes" xml:space="preserve">
          <source>Characters that start or end a string. This class differs from the string quote class in that &lt;em&gt;any&lt;/em&gt; generic string delimiter can match any other generic string delimiter; but they do not match ordinary string quote characters.</source>
          <target state="translated">文字列を開始または終了する文字。このクラスは、&lt;em&gt;任意の&lt;/em&gt;汎用文字列区切り文字が他の任意の汎用文字列区切り文字と一致できるという点で、文字列引用クラスとは異なります。ただし、通常の文字列引用符とは一致しません。</target>
        </trans-unit>
        <trans-unit id="878c9eb0cca3656e2070d507e9c66472d4b16d58" translate="yes" xml:space="preserve">
          <source>Characters used as punctuation in a human language, or used in a programming language to separate symbols from one another. Some programming language modes, such as Emacs Lisp mode, have no characters in this class since the few characters that are not symbol or word constituents all have other uses. Other programming language modes, such as C mode, use punctuation syntax for operators.</source>
          <target state="translated">人間の言語で句読点として使用される文字、またはプログラミング言語で記号を互いに分離するために使用される文字。Emacs Lisp モードのようないくつかのプログラミング言語モードでは、記号や単語の構成要素ではないいくつかの文字はすべて他の用途を持っているため、このクラスには文字がありません。C モードのような他のプログラミング言語モードでは、演算子に句読点構文を使用します。</target>
        </trans-unit>
        <trans-unit id="06f7786b4e99ee5ceb3cb305cfc63a98ff812c14" translate="yes" xml:space="preserve">
          <source>Characters used for syntactic operators that are considered as part of an expression if they appear next to one. In Lisp modes, these characters include the apostrophe, &amp;lsquo;</source>
          <target state="translated">式の隣にある場合に式の一部と見なされる構文演算子に使用される文字。Lispモードでは、これらの文字にはアポストロフィが含まれます。</target>
        </trans-unit>
        <trans-unit id="b0de87a3961de259dc33f8a42911d09393a940b8" translate="yes" xml:space="preserve">
          <source>Characters used in dissimilar pairs to surround sentences or expressions. Such a grouping is begun with an open parenthesis character and terminated with a close. Each open parenthesis character matches a particular close parenthesis character, and vice versa. Normally, Emacs indicates momentarily the matching open parenthesis when you insert a close parenthesis. See &lt;a href=&quot;blinking#Blinking&quot;&gt;Blinking&lt;/a&gt;.</source>
          <target state="translated">文や表現を囲むために異なるペアで使用される文字。このようなグループ化は、開き括弧文字で始まり、閉じで終了します。各開き括弧文字は特定の閉じ括弧文字と一致し、その逆も同様です。通常、Emacsは、閉じ括弧を挿入すると、一致する開き括弧を瞬間的に示します。&lt;a href=&quot;blinking#Blinking&quot;&gt;点滅を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="4150dd70fbcba800bf39a3d8687d1d7aeb5b8bb0" translate="yes" xml:space="preserve">
          <source>Characters used in various languages to delimit comments. Human text has no comment characters. In Lisp, the semicolon (&amp;lsquo;</source>
          <target state="translated">コメントを区切るためにさまざまな言語で使用される文字。人間のテキストにはコメント文字はありません。Lispでは、セミコロン（ '</target>
        </trans-unit>
        <trans-unit id="48fc8012fa06ff8528f92e294cf2c321f8c94197" translate="yes" xml:space="preserve">
          <source>Characters used to delimit string constants. The same string quote character appears at the beginning and the end of a string. Such quoted strings do not nest.</source>
          <target state="translated">文字列定数を区切るために使用される文字。文字列の先頭と末尾には、同じ文字列引用符が出現します。このような引用符で囲まれた文字列は入れ子になりません。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
