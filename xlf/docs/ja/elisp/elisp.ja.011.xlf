<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="elisp">
    <body>
      <group id="elisp">
        <trans-unit id="6ac036b8d1c1ea2354a0438f84ad30f9852d9133" translate="yes" xml:space="preserve">
          <source>If this variable&amp;rsquo;s value is non-&lt;code&gt;nil&lt;/code&gt;, it is a symbol which is used as a text property name. A non-&lt;code&gt;nil&lt;/code&gt; value for that text property means the other text properties for this character have already been computed.</source>
          <target state="translated">If this variable&amp;rsquo;s value is non- &lt;code&gt;nil&lt;/code&gt; , it is a symbol which is used as a text property name. A non- &lt;code&gt;nil&lt;/code&gt; value for that text property means the other text properties for this character have already been computed.</target>
        </trans-unit>
        <trans-unit id="8e2bb8ec07b4bc794a3673b2e73ca58eb14b1ba1" translate="yes" xml:space="preserve">
          <source>If two objects &lt;var&gt;obj1&lt;/var&gt; and &lt;var&gt;obj2&lt;/var&gt; are &lt;code&gt;eq&lt;/code&gt;, then &lt;code&gt;(sxhash-eq &lt;var&gt;obj1&lt;/var&gt;)&lt;/code&gt; and &lt;code&gt;(sxhash-eq &lt;var&gt;obj2&lt;/var&gt;)&lt;/code&gt; are the same integer.</source>
          <target state="translated">If two objects &lt;var&gt;obj1&lt;/var&gt; and &lt;var&gt;obj2&lt;/var&gt; are &lt;code&gt;eq&lt;/code&gt; , then &lt;code&gt;(sxhash-eq &lt;var&gt;obj1&lt;/var&gt;)&lt;/code&gt; and &lt;code&gt;(sxhash-eq &lt;var&gt;obj2&lt;/var&gt;)&lt;/code&gt; are the same integer.</target>
        </trans-unit>
        <trans-unit id="44ade2ddab356cb60d73286f7dd807880759d4c2" translate="yes" xml:space="preserve">
          <source>If two objects &lt;var&gt;obj1&lt;/var&gt; and &lt;var&gt;obj2&lt;/var&gt; are &lt;code&gt;eql&lt;/code&gt;, then &lt;code&gt;(sxhash-eql &lt;var&gt;obj1&lt;/var&gt;)&lt;/code&gt; and &lt;code&gt;(sxhash-eql &lt;var&gt;obj2&lt;/var&gt;)&lt;/code&gt; are the same integer.</source>
          <target state="translated">If two objects &lt;var&gt;obj1&lt;/var&gt; and &lt;var&gt;obj2&lt;/var&gt; are &lt;code&gt;eql&lt;/code&gt; , then &lt;code&gt;(sxhash-eql &lt;var&gt;obj1&lt;/var&gt;)&lt;/code&gt; and &lt;code&gt;(sxhash-eql &lt;var&gt;obj2&lt;/var&gt;)&lt;/code&gt; are the same integer.</target>
        </trans-unit>
        <trans-unit id="faa2ecf2925aadfa7df8d5d6017d1a43d6a4fbf6" translate="yes" xml:space="preserve">
          <source>If two objects &lt;var&gt;obj1&lt;/var&gt; and &lt;var&gt;obj2&lt;/var&gt; are &lt;code&gt;equal&lt;/code&gt;, then &lt;code&gt;(sxhash-equal &lt;var&gt;obj1&lt;/var&gt;)&lt;/code&gt; and &lt;code&gt;(sxhash-equal &lt;var&gt;obj2&lt;/var&gt;)&lt;/code&gt; are the same integer.</source>
          <target state="translated">If two objects &lt;var&gt;obj1&lt;/var&gt; and &lt;var&gt;obj2&lt;/var&gt; are &lt;code&gt;equal&lt;/code&gt; , then &lt;code&gt;(sxhash-equal &lt;var&gt;obj1&lt;/var&gt;)&lt;/code&gt; and &lt;code&gt;(sxhash-equal &lt;var&gt;obj2&lt;/var&gt;)&lt;/code&gt; are the same integer.</target>
        </trans-unit>
        <trans-unit id="c4a957c6ab4394732423e757c73b91fce71b8325" translate="yes" xml:space="preserve">
          <source>If user input represents an octal number, this function returns that number. If it is a complete symbolic specification of mode bits, as in &lt;code&gt;&quot;u=rwx&quot;&lt;/code&gt;, the function converts it to the equivalent numeric value using &lt;code&gt;file-modes-symbolic-to-number&lt;/code&gt; and returns the result. If the specification is relative, as in &lt;code&gt;&quot;o+g&quot;&lt;/code&gt;, then the permissions on which the specification is based are taken from the mode bits of &lt;var&gt;base-file&lt;/var&gt;. If &lt;var&gt;base-file&lt;/var&gt; is omitted or &lt;code&gt;nil&lt;/code&gt;, the function uses &lt;code&gt;0&lt;/code&gt; as the base mode bits. The complete and relative specifications can be combined, as in &lt;code&gt;&quot;u+r,g+rx,o+r,g-w&quot;&lt;/code&gt;. See &lt;a href=&quot;http://www.gnu.org/software/coreutils/manual/html_node/File-permissions.html#File-permissions&quot;&gt;File permissions&lt;/a&gt; in</source>
          <target state="translated">If user input represents an octal number, this function returns that number. If it is a complete symbolic specification of mode bits, as in &lt;code&gt;&quot;u=rwx&quot;&lt;/code&gt; , the function converts it to the equivalent numeric value using &lt;code&gt;file-modes-symbolic-to-number&lt;/code&gt; and returns the result. If the specification is relative, as in &lt;code&gt;&quot;o+g&quot;&lt;/code&gt; , then the permissions on which the specification is based are taken from the mode bits of &lt;var&gt;base-file&lt;/var&gt; . If &lt;var&gt;base-file&lt;/var&gt; is omitted or &lt;code&gt;nil&lt;/code&gt; , the function uses &lt;code&gt;0&lt;/code&gt; as the base mode bits. The complete and relative specifications can be combined, as in &lt;code&gt;&quot;u+r,g+rx,o+r,g-w&quot;&lt;/code&gt; . See &lt;a href=&quot;http://www.gnu.org/software/coreutils/manual/html_node/File-permissions.html#File-permissions&quot;&gt;File permissions&lt;/a&gt; in</target>
        </trans-unit>
        <trans-unit id="ab20dbc7190aa4c17064de5aae79eae25a6f3ca2" translate="yes" xml:space="preserve">
          <source>If we know that the &lt;code&gt;&quot;else&quot;&lt;/code&gt; is always aligned with its &lt;code&gt;&quot;if&quot;&lt;/code&gt; and is always at the beginning of a line, we can use a more efficient rule:</source>
          <target state="translated">If we know that the &lt;code&gt;&quot;else&quot;&lt;/code&gt; is always aligned with its &lt;code&gt;&quot;if&quot;&lt;/code&gt; and is always at the beginning of a line, we can use a more efficient rule:</target>
        </trans-unit>
        <trans-unit id="b94e278e89af3d9639830ebb8509d74bc9218c33" translate="yes" xml:space="preserve">
          <source>If you add a new primitive to a file that already has Lisp primitives defined in it, find the function (near the end of the file) named &lt;code&gt;syms_of_&lt;var&gt;something&lt;/var&gt;&lt;/code&gt;, and add the call to &lt;code&gt;defsubr&lt;/code&gt; there. If the file doesn&amp;rsquo;t have this function, or if you create a new file, add to it a &lt;code&gt;syms_of_&lt;var&gt;filename&lt;/var&gt;&lt;/code&gt; (e.g., &lt;code&gt;syms_of_myfile&lt;/code&gt;). Then find the spot in</source>
          <target state="translated">If you add a new primitive to a file that already has Lisp primitives defined in it, find the function (near the end of the file) named &lt;code&gt;syms_of_&lt;var&gt;something&lt;/var&gt;&lt;/code&gt; , and add the call to &lt;code&gt;defsubr&lt;/code&gt; there. If the file doesn&amp;rsquo;t have this function, or if you create a new file, add to it a &lt;code&gt;syms_of_&lt;var&gt;filename&lt;/var&gt;&lt;/code&gt; (e.g., &lt;code&gt;syms_of_myfile&lt;/code&gt; ). Then find the spot in</target>
        </trans-unit>
        <trans-unit id="8e51eed80e79b2bcea4605ee7ff46c46550e45f1" translate="yes" xml:space="preserve">
          <source>If you alter the compiled file (such as by compiling a new version), then trying to load any function not already loaded will usually yield nonsense results.</source>
          <target state="translated">コンパイルされたファイルを変更した場合 (新しいバージョンをコンパイルするなど)、まだロードされていない関数をロードしようとすると、通常は意味のない結果が得られます。</target>
        </trans-unit>
        <trans-unit id="0eb0fd19eca276d41267eb825a3b2aa624892e92" translate="yes" xml:space="preserve">
          <source>If you are careful not to exceed the ring size, you can use the ring as a first-in-first-out queue. For example:</source>
          <target state="translated">リングサイズを超えないように注意すれば、先入れ先出しのキューとして使用することができます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="fc8d2ca20908496286a727bd09248d8bc43a541e" translate="yes" xml:space="preserve">
          <source>If you are running across a network, and different parts of the network work at different baud rates, the value returned by Emacs may be different from the value used by your local terminal. Some network protocols communicate the local terminal speed to the remote machine, so that Emacs and other programs can get the proper value, but others do not. If Emacs has the wrong value, it makes decisions that are less than optimal. To fix the problem, set &lt;code&gt;baud-rate&lt;/code&gt;.</source>
          <target state="translated">If you are running across a network, and different parts of the network work at different baud rates, the value returned by Emacs may be different from the value used by your local terminal. Some network protocols communicate the local terminal speed to the remote machine, so that Emacs and other programs can get the proper value, but others do not. If Emacs has the wrong value, it makes decisions that are less than optimal. To fix the problem, set &lt;code&gt;baud-rate&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0072664fa49d446301646082567e540da686bac7" translate="yes" xml:space="preserve">
          <source>If you are sure that a warning message about a missing function or variable is unjustified, there are several ways to suppress it:</source>
          <target state="translated">欠落している関数や変数に関する警告メッセージが不当であることが確実な場合、それを抑制する方法がいくつかあります。</target>
        </trans-unit>
        <trans-unit id="f22a0f306b8db09319cdd2bfdcd0eed8dd5fd3d7" translate="yes" xml:space="preserve">
          <source>If you are using a macro to do something an ordinary function could do, just for the sake of speed, consider using an inline function instead. See &lt;a href=&quot;inline-functions#Inline-Functions&quot;&gt;Inline Functions&lt;/a&gt;.</source>
          <target state="translated">If you are using a macro to do something an ordinary function could do, just for the sake of speed, consider using an inline function instead. See &lt;a href=&quot;inline-functions#Inline-Functions&quot;&gt;Inline Functions&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="d39bc44a789b7cd31c5d8a478076105fab4e1cea" translate="yes" xml:space="preserve">
          <source>If you are using a mode whose indentation is provided by SMIE, you can customize the indentation to suit your preferences. You can do this on a per-mode basis (using the option &lt;code&gt;smie-config&lt;/code&gt;), or a per-file basis (using the function &lt;code&gt;smie-config-local&lt;/code&gt; in a file-local variable specification).</source>
          <target state="translated">If you are using a mode whose indentation is provided by SMIE, you can customize the indentation to suit your preferences. You can do this on a per-mode basis (using the option &lt;code&gt;smie-config&lt;/code&gt; ), or a per-file basis (using the function &lt;code&gt;smie-config-local&lt;/code&gt; in a file-local variable specification).</target>
        </trans-unit>
        <trans-unit id="af4a68bcde30998a536e42773304bc15d422df91" translate="yes" xml:space="preserve">
          <source>If you are writing code for release, for others to use, try to avoid including advice in it. If the function you want to advise has no hook to do the job, please talk with the Emacs developers about adding a suitable hook. Especially, Emacs&amp;rsquo;s own source files should not put advice on functions in Emacs. (There are currently a few exceptions to this convention, but we aim to correct them.) It is generally cleaner to create a new hook in &lt;code&gt;foo&lt;/code&gt;, and make &lt;code&gt;bar&lt;/code&gt; use the hook, than to have &lt;code&gt;bar&lt;/code&gt; put advice in &lt;code&gt;foo&lt;/code&gt;.</source>
          <target state="translated">If you are writing code for release, for others to use, try to avoid including advice in it. If the function you want to advise has no hook to do the job, please talk with the Emacs developers about adding a suitable hook. Especially, Emacs&amp;rsquo;s own source files should not put advice on functions in Emacs. (There are currently a few exceptions to this convention, but we aim to correct them.) It is generally cleaner to create a new hook in &lt;code&gt;foo&lt;/code&gt; , and make &lt;code&gt;bar&lt;/code&gt; use the hook, than to have &lt;code&gt;bar&lt;/code&gt; put advice in &lt;code&gt;foo&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bda02007617357daadbad5daa64711e089b1fa98" translate="yes" xml:space="preserve">
          <source>If you call &lt;code&gt;set-face-attribute&lt;/code&gt; and pass a font spec, font entity, or font name string as the value of the &lt;code&gt;:font&lt;/code&gt; attribute, Emacs opens the best matching font that is available for display. It then stores the corresponding font object as the actual value of the &lt;code&gt;:font&lt;/code&gt; attribute for that face.</source>
          <target state="translated">If you call &lt;code&gt;set-face-attribute&lt;/code&gt; and pass a font spec, font entity, or font name string as the value of the &lt;code&gt;:font&lt;/code&gt; attribute, Emacs opens the best matching font that is available for display. It then stores the corresponding font object as the actual value of the &lt;code&gt;:font&lt;/code&gt; attribute for that face.</target>
        </trans-unit>
        <trans-unit id="69c55f2e5f8ed1abaffbeb201babe6c0b3098a84" translate="yes" xml:space="preserve">
          <source>If you call &lt;code&gt;sort-regexp-fields&lt;/code&gt; interactively, it prompts for &lt;var&gt;record-regexp&lt;/var&gt; and &lt;var&gt;key-regexp&lt;/var&gt; in the minibuffer.</source>
          <target state="translated">If you call &lt;code&gt;sort-regexp-fields&lt;/code&gt; interactively, it prompts for &lt;var&gt;record-regexp&lt;/var&gt; and &lt;var&gt;key-regexp&lt;/var&gt; in the minibuffer.</target>
        </trans-unit>
        <trans-unit id="19b20fbcaed19267c0ae5233685511404c8fe13b" translate="yes" xml:space="preserve">
          <source>If you can read &lt;var&gt;filename&lt;/var&gt; this function returns &lt;code&gt;nil&lt;/code&gt;; otherwise it signals an error using &lt;var&gt;string&lt;/var&gt; as the error message text.</source>
          <target state="translated">If you can read &lt;var&gt;filename&lt;/var&gt; this function returns &lt;code&gt;nil&lt;/code&gt; ; otherwise it signals an error using &lt;var&gt;string&lt;/var&gt; as the error message text.</target>
        </trans-unit>
        <trans-unit id="ec646b6002abc5e60335d6f3ab6e9548f2ac3d2c" translate="yes" xml:space="preserve">
          <source>If you change &lt;code&gt;debug-on-error&lt;/code&gt; or &lt;code&gt;debug-on-quit&lt;/code&gt; while Edebug is active, these changes will be forgotten when Edebug becomes inactive. Furthermore, during Edebug&amp;rsquo;s recursive edit, these variables are bound to the values they had outside of Edebug.</source>
          <target state="translated">If you change &lt;code&gt;debug-on-error&lt;/code&gt; or &lt;code&gt;debug-on-quit&lt;/code&gt; while Edebug is active, these changes will be forgotten when Edebug becomes inactive. Furthermore, during Edebug&amp;rsquo;s recursive edit, these variables are bound to the values they had outside of Edebug.</target>
        </trans-unit>
        <trans-unit id="82e1d7f6837d7e1fd79a005ee98861790c6bed8a" translate="yes" xml:space="preserve">
          <source>If you change &lt;code&gt;debug-on-signal&lt;/code&gt; to a non-&lt;code&gt;nil&lt;/code&gt; value, the debugger gets the first chance at every error, regardless of the presence of &lt;code&gt;condition-case&lt;/code&gt;. (To invoke the debugger, the error must still fulfill the criteria specified by &lt;code&gt;debug-on-error&lt;/code&gt; and &lt;code&gt;debug-ignored-errors&lt;/code&gt;.)</source>
          <target state="translated">If you change &lt;code&gt;debug-on-signal&lt;/code&gt; to a non- &lt;code&gt;nil&lt;/code&gt; value, the debugger gets the first chance at every error, regardless of the presence of &lt;code&gt;condition-case&lt;/code&gt; . (To invoke the debugger, the error must still fulfill the criteria specified by &lt;code&gt;debug-on-error&lt;/code&gt; and &lt;code&gt;debug-ignored-errors&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="a032c6d2c26bc9a17573480803a0fc6e92740213" translate="yes" xml:space="preserve">
          <source>If you change the bindings in &lt;var&gt;parent-keymap&lt;/var&gt; using &lt;code&gt;define-key&lt;/code&gt; or other key-binding functions, these changed bindings are visible in the inheriting keymap, unless shadowed by the bindings made by &lt;var&gt;elements&lt;/var&gt;. The converse is not true: if you use &lt;code&gt;define-key&lt;/code&gt; to change bindings in the inheriting keymap, these changes are recorded in &lt;var&gt;elements&lt;/var&gt;, but have no effect on &lt;var&gt;parent-keymap&lt;/var&gt;.</source>
          <target state="translated">If you change the bindings in &lt;var&gt;parent-keymap&lt;/var&gt; using &lt;code&gt;define-key&lt;/code&gt; or other key-binding functions, these changed bindings are visible in the inheriting keymap, unless shadowed by the bindings made by &lt;var&gt;elements&lt;/var&gt; . The converse is not true: if you use &lt;code&gt;define-key&lt;/code&gt; to change bindings in the inheriting keymap, these changes are recorded in &lt;var&gt;elements&lt;/var&gt; , but have no effect on &lt;var&gt;parent-keymap&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="9cb1eba86e3ba5c0e1663be951356c7fd19739f3" translate="yes" xml:space="preserve">
          <source>If you change the values of &lt;code&gt;edebug-on-error&lt;/code&gt; or &lt;code&gt;edebug-on-quit&lt;/code&gt; while Edebug is active, their values won&amp;rsquo;t be used until the &lt;em&gt;next&lt;/em&gt; time Edebug is invoked via a new command.</source>
          <target state="translated">If you change the values of &lt;code&gt;edebug-on-error&lt;/code&gt; or &lt;code&gt;edebug-on-quit&lt;/code&gt; while Edebug is active, their values won&amp;rsquo;t be used until the &lt;em&gt;next&lt;/em&gt; time Edebug is invoked via a new command.</target>
        </trans-unit>
        <trans-unit id="b5ecdaab829d09620b381ec99a472542b3bed464" translate="yes" xml:space="preserve">
          <source>If you click a button three or more times and then press it again, the events for the presses beyond the third are all triple events. Emacs does not have separate event types for quadruple, quintuple, etc. events. However, you can look at the event list to find out precisely how many times the button was pressed.</source>
          <target state="translated">ボタンを3回以上クリックしてからもう一度押すと、3回目以降の押した分のイベントはすべてトリプルイベントになります。Emacsには、四重、五重などのイベントの個別のイベントタイプはありません。しかし、イベントリストを見れば、ボタンが何回押されたかを正確に知ることができます。</target>
        </trans-unit>
        <trans-unit id="97f76d136a54a91f5ce09fa28d033744e2b18618" translate="yes" xml:space="preserve">
          <source>If you click a button twice and then press it again, all in quick succession, Emacs generates a &lt;em&gt;triple-down&lt;/em&gt; event, followed by either a &lt;em&gt;triple-click&lt;/em&gt; or a &lt;em&gt;triple-drag&lt;/em&gt;. The event types of these events contain &amp;lsquo;</source>
          <target state="translated">If you click a button twice and then press it again, all in quick succession, Emacs generates a &lt;em&gt;triple-down&lt;/em&gt; event, followed by either a &lt;em&gt;triple-click&lt;/em&gt; or a &lt;em&gt;triple-drag&lt;/em&gt;. The event types of these events contain &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="babf73f5ef063cd1ca16de5c46e1c4b38d2d236a" translate="yes" xml:space="preserve">
          <source>If you click a button, then press it down again and start moving the mouse with the button held down, then you get a &lt;em&gt;double-drag&lt;/em&gt; event when you ultimately release the button. Its event type contains &amp;lsquo;</source>
          <target state="translated">If you click a button, then press it down again and start moving the mouse with the button held down, then you get a &lt;em&gt;double-drag&lt;/em&gt; event when you ultimately release the button. Its event type contains &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="c5fb3a0c87cdbd7c9d430fccee88612b713587b6" translate="yes" xml:space="preserve">
          <source>If you compile the above code, the anonymous function is also compiled. This would not happen if, say, you had constructed the anonymous function by quoting it as a list:</source>
          <target state="translated">上記のコードをコンパイルすると、匿名関数もコンパイルされます。これは、例えば匿名関数をリストとして引用して構築した場合には起こらないでしょう。</target>
        </trans-unit>
        <trans-unit id="3585ff0dc0e69eb3875d3c21881701fbf12049b6" translate="yes" xml:space="preserve">
          <source>If you define a function which is side-effect free or pure, give it a non-&lt;code&gt;nil&lt;/code&gt;&lt;code&gt;side-effect-free&lt;/code&gt; or &lt;code&gt;pure&lt;/code&gt; property, respectively (see &lt;a href=&quot;standard-properties#Standard-Properties&quot;&gt;Standard Properties&lt;/a&gt;).</source>
          <target state="translated">If you define a function which is side-effect free or pure, give it a non- &lt;code&gt;nil&lt;/code&gt; &lt;code&gt;side-effect-free&lt;/code&gt; or &lt;code&gt;pure&lt;/code&gt; property, respectively (see &lt;a href=&quot;standard-properties#Standard-Properties&quot;&gt;Standard Properties&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="9d356c50a344f26b7b7e0c2e2a88f2a9d47c5035" translate="yes" xml:space="preserve">
          <source>If you delete or move the compiled file after loading it, Emacs can no longer load the remaining function definitions not already loaded.</source>
          <target state="translated">コンパイルしたファイルをロードした後に削除したり移動したりすると、まだロードされていない残りの関数定義をEmacsがロードできなくなります。</target>
        </trans-unit>
        <trans-unit id="832ed8c18f70d41abab32f7213d1a98c3b93e0e3" translate="yes" xml:space="preserve">
          <source>If you did the last search in a buffer, you should omit the &lt;var&gt;string&lt;/var&gt; argument or specify &lt;code&gt;nil&lt;/code&gt; for it, and make sure that the current buffer is the one in which you performed the last search. Then this function edits the buffer, replacing the matched text with &lt;var&gt;replacement&lt;/var&gt;. It leaves point at the end of the replacement text.</source>
          <target state="translated">If you did the last search in a buffer, you should omit the &lt;var&gt;string&lt;/var&gt; argument or specify &lt;code&gt;nil&lt;/code&gt; for it, and make sure that the current buffer is the one in which you performed the last search. Then this function edits the buffer, replacing the matched text with &lt;var&gt;replacement&lt;/var&gt; . It leaves point at the end of the replacement text.</target>
        </trans-unit>
        <trans-unit id="5752e1504ebf2064bf0d5937ac79557053162460" translate="yes" xml:space="preserve">
          <source>If you directly define a file-scope C variable of type &lt;code&gt;Lisp_Object&lt;/code&gt;, you must protect it from garbage-collection by calling &lt;code&gt;staticpro&lt;/code&gt; in &lt;code&gt;syms_of_&lt;var&gt;filename&lt;/var&gt;&lt;/code&gt;, like this:</source>
          <target state="translated">If you directly define a file-scope C variable of type &lt;code&gt;Lisp_Object&lt;/code&gt; , you must protect it from garbage-collection by calling &lt;code&gt;staticpro&lt;/code&gt; in &lt;code&gt;syms_of_&lt;var&gt;filename&lt;/var&gt;&lt;/code&gt; , like this:</target>
        </trans-unit>
        <trans-unit id="a799552f0c440dd51dc850366b3de6e02e55511d" translate="yes" xml:space="preserve">
          <source>If you divide an integer by the integer 0, Emacs signals an &lt;code&gt;arith-error&lt;/code&gt; error (see &lt;a href=&quot;errors#Errors&quot;&gt;Errors&lt;/a&gt;). Floating-point division of a nonzero number by zero yields either positive or negative infinity (see &lt;a href=&quot;float-basics#Float-Basics&quot;&gt;Float Basics&lt;/a&gt;).</source>
          <target state="translated">If you divide an integer by the integer 0, Emacs signals an &lt;code&gt;arith-error&lt;/code&gt; error (see &lt;a href=&quot;errors#Errors&quot;&gt;Errors&lt;/a&gt;). Floating-point division of a nonzero number by zero yields either positive or negative infinity (see &lt;a href=&quot;float-basics#Float-Basics&quot;&gt;Float Basics&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="c48948f392e624e52dbc1aa826b6d5945fcc5647" translate="yes" xml:space="preserve">
          <source>If you do alter &lt;code&gt;mode-line-format&lt;/code&gt; itself, the new value should use the same variables that appear in the default value (see &lt;a href=&quot;mode-line-variables#Mode-Line-Variables&quot;&gt;Mode Line Variables&lt;/a&gt;), rather than duplicating their contents or displaying the information in another fashion. This way, customizations made by the user or by Lisp programs (such as &lt;code&gt;display-time&lt;/code&gt; and major modes) via changes to those variables remain effective.</source>
          <target state="translated">If you do alter &lt;code&gt;mode-line-format&lt;/code&gt; itself, the new value should use the same variables that appear in the default value (see &lt;a href=&quot;mode-line-variables#Mode-Line-Variables&quot;&gt;Mode Line Variables&lt;/a&gt;), rather than duplicating their contents or displaying the information in another fashion. This way, customizations made by the user or by Lisp programs (such as &lt;code&gt;display-time&lt;/code&gt; and major modes) via changes to those variables remain effective.</target>
        </trans-unit>
        <trans-unit id="919e7db85c8f5ee11bd70bb4cc9d84095b916140" translate="yes" xml:space="preserve">
          <source>If you do not specify a window&amp;rsquo;s scroll bar settings via &lt;code&gt;set-window-scroll-bars&lt;/code&gt;, the buffer-local variables &lt;code&gt;vertical-scroll-bar&lt;/code&gt;, &lt;code&gt;horizontal-scroll-bar&lt;/code&gt;, &lt;code&gt;scroll-bar-width&lt;/code&gt; and &lt;code&gt;scroll-bar-height&lt;/code&gt; in the buffer being displayed control the window&amp;rsquo;s scroll bars. The function &lt;code&gt;set-window-buffer&lt;/code&gt; examines these variables. If you change them in a buffer that is already visible in a window, you can make the window take note of the new values by calling &lt;code&gt;set-window-buffer&lt;/code&gt; specifying the same buffer that is already displayed.</source>
          <target state="translated">If you do not specify a window&amp;rsquo;s scroll bar settings via &lt;code&gt;set-window-scroll-bars&lt;/code&gt; , the buffer-local variables &lt;code&gt;vertical-scroll-bar&lt;/code&gt; , &lt;code&gt;horizontal-scroll-bar&lt;/code&gt; , &lt;code&gt;scroll-bar-width&lt;/code&gt; and &lt;code&gt;scroll-bar-height&lt;/code&gt; in the buffer being displayed control the window&amp;rsquo;s scroll bars. The function &lt;code&gt;set-window-buffer&lt;/code&gt; examines these variables. If you change them in a buffer that is already visible in a window, you can make the window take note of the new values by calling &lt;code&gt;set-window-buffer&lt;/code&gt; specifying the same buffer that is already displayed.</target>
        </trans-unit>
        <trans-unit id="7d5478635f2aa0a1b8f06759d112fc9a81bb9ae9" translate="yes" xml:space="preserve">
          <source>If you do not want a Lisp file to be compiled, ever, put a file-local variable binding for &lt;code&gt;no-byte-compile&lt;/code&gt; into it, like this:</source>
          <target state="translated">If you do not want a Lisp file to be compiled, ever, put a file-local variable binding for &lt;code&gt;no-byte-compile&lt;/code&gt; into it, like this:</target>
        </trans-unit>
        <trans-unit id="bd9289930e0af37b6580f5f7e82b4908b4ac925e" translate="yes" xml:space="preserve">
          <source>If you do not want a particular command to be recognized as the previous command in the case where it got an error, you must code that command to prevent this. One way is to set &lt;code&gt;this-command&lt;/code&gt; to &lt;code&gt;t&lt;/code&gt; at the beginning of the command, and set &lt;code&gt;this-command&lt;/code&gt; back to its proper value at the end, like this:</source>
          <target state="translated">If you do not want a particular command to be recognized as the previous command in the case where it got an error, you must code that command to prevent this. One way is to set &lt;code&gt;this-command&lt;/code&gt; to &lt;code&gt;t&lt;/code&gt; at the beginning of the command, and set &lt;code&gt;this-command&lt;/code&gt; back to its proper value at the end, like this:</target>
        </trans-unit>
        <trans-unit id="5611162597f8b6ec87950a669e8a5984dfaa42e0" translate="yes" xml:space="preserve">
          <source>If you do not want this feature, set the variable &lt;code&gt;case-fold-search&lt;/code&gt; to &lt;code&gt;nil&lt;/code&gt;. Then all letters must match exactly, including case. This is a buffer-local variable; altering the variable affects only the current buffer. (See &lt;a href=&quot;intro-to-buffer_002dlocal#Intro-to-Buffer_002dLocal&quot;&gt;Intro to Buffer-Local&lt;/a&gt;.) Alternatively, you may change the default value. In Lisp code, you will more typically use &lt;code&gt;let&lt;/code&gt; to bind &lt;code&gt;case-fold-search&lt;/code&gt; to the desired value.</source>
          <target state="translated">If you do not want this feature, set the variable &lt;code&gt;case-fold-search&lt;/code&gt; to &lt;code&gt;nil&lt;/code&gt; . Then all letters must match exactly, including case. This is a buffer-local variable; altering the variable affects only the current buffer. (See &lt;a href=&quot;intro-to-buffer_002dlocal#Intro-to-Buffer_002dLocal&quot;&gt;Intro to Buffer-Local&lt;/a&gt;.) Alternatively, you may change the default value. In Lisp code, you will more typically use &lt;code&gt;let&lt;/code&gt; to bind &lt;code&gt;case-fold-search&lt;/code&gt; to the desired value.</target>
        </trans-unit>
        <trans-unit id="f866fd286c45411a67dbb50a84fea3f20ae8d82b" translate="yes" xml:space="preserve">
          <source>If you do set the same variable again, the new value replaces the old one:</source>
          <target state="translated">同じ変数を再度設定した場合、新しい値が古い値に置き換わります。</target>
        </trans-unit>
        <trans-unit id="3402ff5b14ba5a8ea18eb9cb2a7a34434be535f3" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t know exactly where in the source code you want to put the debug statement, but you want to display a backtrace when a certain message is displayed, you can set &lt;code&gt;debug-on-message&lt;/code&gt; to a regular expression matching the desired message.</source>
          <target state="translated">If you don&amp;rsquo;t know exactly where in the source code you want to put the debug statement, but you want to display a backtrace when a certain message is displayed, you can set &lt;code&gt;debug-on-message&lt;/code&gt; to a regular expression matching the desired message.</target>
        </trans-unit>
        <trans-unit id="1411d7398cdf316f7a761acc6232531b6f93aa6f" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t see a problem at that point, the next thing to do is to type</source>
          <target state="translated">If you don&amp;rsquo;t see a problem at that point, the next thing to do is to type</target>
        </trans-unit>
        <trans-unit id="c777867a4fcf3b6790ba4a3f6676ab8e8eb5e7ea" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t specify &lt;var&gt;help&lt;/var&gt;, the default is &lt;code&gt;(&quot;object&quot;
&quot;objects&quot; &quot;act on&quot;)&lt;/code&gt;.</source>
          <target state="translated">If you don&amp;rsquo;t specify &lt;var&gt;help&lt;/var&gt; , the default is &lt;code&gt;(&quot;object&quot; &quot;objects&quot; &quot;act on&quot;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="73fcecbc1356991b98581a800856e4e2763a1b17" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t specify &lt;var&gt;history&lt;/var&gt;, then the default history list &lt;code&gt;minibuffer-history&lt;/code&gt; is used. For other standard history lists, see below. You can also create your own history list variable; just initialize it to &lt;code&gt;nil&lt;/code&gt; before the first use. If the variable is buffer local, then each buffer will have its own input history list.</source>
          <target state="translated">If you don&amp;rsquo;t specify &lt;var&gt;history&lt;/var&gt; , then the default history list &lt;code&gt;minibuffer-history&lt;/code&gt; is used. For other standard history lists, see below. You can also create your own history list variable; just initialize it to &lt;code&gt;nil&lt;/code&gt; before the first use. If the variable is buffer local, then each buffer will have its own input history list.</target>
        </trans-unit>
        <trans-unit id="3b45979ffc14a7465f0296ae53f5338e35b87473" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t specify the &lt;code&gt;line-height&lt;/code&gt; property, the line&amp;rsquo;s height consists of the contents&amp;rsquo; height plus the line spacing. There are several ways to specify the line spacing for different parts of Emacs text.</source>
          <target state="translated">If you don&amp;rsquo;t specify the &lt;code&gt;line-height&lt;/code&gt; property, the line&amp;rsquo;s height consists of the contents&amp;rsquo; height plus the line spacing. There are several ways to specify the line spacing for different parts of Emacs text.</target>
        </trans-unit>
        <trans-unit id="b6743c06f00234ad9062a2a3a2ea7fc17e673ef8" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t specify this keyword at all, the default is to determine the coding systems from the data.</source>
          <target state="translated">If you don&amp;rsquo;t specify this keyword at all, the default is to determine the coding systems from the data.</target>
        </trans-unit>
        <trans-unit id="04bef473929ac543401da8285cfb9a7eb0c1717c" translate="yes" xml:space="preserve">
          <source>If you get a warning that</source>
          <target state="translated">という警告が出たら</target>
        </trans-unit>
        <trans-unit id="e767fb6147ef9fb326b46a3482c4c2ceedb2b93a" translate="yes" xml:space="preserve">
          <source>If you have a constant that needs some calculation to produce, &lt;code&gt;eval-when-compile&lt;/code&gt; can do that at compile-time. For example,</source>
          <target state="translated">If you have a constant that needs some calculation to produce, &lt;code&gt;eval-when-compile&lt;/code&gt; can do that at compile-time. For example,</target>
        </trans-unit>
        <trans-unit id="3f37032d6c165b2681c4b1c8b2c526ae79d7f709" translate="yes" xml:space="preserve">
          <source>If you have a frame that displays only one window, you can fit that frame to its buffer using the command &lt;code&gt;fit-frame-to-buffer&lt;/code&gt;.</source>
          <target state="translated">If you have a frame that displays only one window, you can fit that frame to its buffer using the command &lt;code&gt;fit-frame-to-buffer&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="33faad871265de71a9510766889514f64259bfd3" translate="yes" xml:space="preserve">
          <source>If you have made extensive changes to a file and then change your mind about them, you can get rid of them by reading in the previous version of the file with the &lt;code&gt;revert-buffer&lt;/code&gt; command. See &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Reverting.html#Reverting&quot;&gt;Reverting a Buffer&lt;/a&gt; in</source>
          <target state="translated">If you have made extensive changes to a file and then change your mind about them, you can get rid of them by reading in the previous version of the file with the &lt;code&gt;revert-buffer&lt;/code&gt; command. See &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Reverting.html#Reverting&quot;&gt;Reverting a Buffer&lt;/a&gt; in</target>
        </trans-unit>
        <trans-unit id="3114430b909452db4a0ad15c4686bf655a82d1b5" translate="yes" xml:space="preserve">
          <source>If you have never given a symbol any function definition, we say that that symbol&amp;rsquo;s function cell is &lt;em&gt;void&lt;/em&gt;. In other words, the function cell does not have any Lisp object in it. If you try to call the symbol as a function, Emacs signals a &lt;code&gt;void-function&lt;/code&gt; error.</source>
          <target state="translated">If you have never given a symbol any function definition, we say that that symbol&amp;rsquo;s function cell is &lt;em&gt;void&lt;/em&gt;. In other words, the function cell does not have any Lisp object in it. If you try to call the symbol as a function, Emacs signals a &lt;code&gt;void-function&lt;/code&gt; error.</target>
        </trans-unit>
        <trans-unit id="1adb1c551e5096149203b778dae4aca140133316" translate="yes" xml:space="preserve">
          <source>If you have passed a non-&lt;code&gt;nil&lt;/code&gt;&lt;var&gt;stderr&lt;/var&gt; to &lt;code&gt;make-process&lt;/code&gt;, it will have a standard error process. See &lt;a href=&quot;asynchronous-processes#Asynchronous-Processes&quot;&gt;Asynchronous Processes&lt;/a&gt;. In that case, waiting for process output from the main process doesn&amp;rsquo;t wait for output from the standard error process. To make sure you have received both all of standard output and all of standard error from a process, use the following code:</source>
          <target state="translated">If you have passed a non- &lt;code&gt;nil&lt;/code&gt; &lt;var&gt;stderr&lt;/var&gt; to &lt;code&gt;make-process&lt;/code&gt; , it will have a standard error process. See &lt;a href=&quot;asynchronous-processes#Asynchronous-Processes&quot;&gt;Asynchronous Processes&lt;/a&gt;. In that case, waiting for process output from the main process doesn&amp;rsquo;t wait for output from the standard error process. To make sure you have received both all of standard output and all of standard error from a process, use the following code:</target>
        </trans-unit>
        <trans-unit id="ef54783b26bd82dc91fad381aa3579ce041cbe4e" translate="yes" xml:space="preserve">
          <source>If you instrument the &lt;code&gt;test&lt;/code&gt; macro and step through it, then by default the result of the &lt;code&gt;symbol-function&lt;/code&gt; call has numerous &lt;code&gt;edebug-after&lt;/code&gt; and &lt;code&gt;edebug-before&lt;/code&gt; forms, which can make it difficult to see the actual result. If &lt;code&gt;edebug-unwrap-results&lt;/code&gt; is non-&lt;code&gt;nil&lt;/code&gt;, Edebug tries to remove these forms from the result.</source>
          <target state="translated">If you instrument the &lt;code&gt;test&lt;/code&gt; macro and step through it, then by default the result of the &lt;code&gt;symbol-function&lt;/code&gt; call has numerous &lt;code&gt;edebug-after&lt;/code&gt; and &lt;code&gt;edebug-before&lt;/code&gt; forms, which can make it difficult to see the actual result. If &lt;code&gt;edebug-unwrap-results&lt;/code&gt; is non- &lt;code&gt;nil&lt;/code&gt; , Edebug tries to remove these forms from the result.</target>
        </trans-unit>
        <trans-unit id="33abc94ec53362e4d866e3e4d48d4aa529da00b3" translate="yes" xml:space="preserve">
          <source>If you instrument the definition of &lt;code&gt;fac&lt;/code&gt; (shown below) and then execute &lt;code&gt;(fac 3)&lt;/code&gt;, here is what you would normally see. Point is at the open-parenthesis before &lt;code&gt;if&lt;/code&gt;.</source>
          <target state="translated">If you instrument the definition of &lt;code&gt;fac&lt;/code&gt; (shown below) and then execute &lt;code&gt;(fac 3)&lt;/code&gt; , here is what you would normally see. Point is at the open-parenthesis before &lt;code&gt;if&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="30df8677ae4d4b292044bc3da5da7b6491d7a906" translate="yes" xml:space="preserve">
          <source>If you invoke Emacs with command-line options that specify frame appearance, those options take effect by adding elements to either &lt;code&gt;initial-frame-alist&lt;/code&gt; or &lt;code&gt;default-frame-alist&lt;/code&gt;. Options which affect just the initial frame, such as &amp;lsquo;</source>
          <target state="translated">If you invoke Emacs with command-line options that specify frame appearance, those options take effect by adding elements to either &lt;code&gt;initial-frame-alist&lt;/code&gt; or &lt;code&gt;default-frame-alist&lt;/code&gt; . Options which affect just the initial frame, such as &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="4f8ed670902a9aad525f057b6320f5c8058a1c22" translate="yes" xml:space="preserve">
          <source>If you just want to automatically auto-revert every &lt;code&gt;auto-revert-interval&lt;/code&gt; seconds (like the Buffer Menu), use:</source>
          <target state="translated">If you just want to automatically auto-revert every &lt;code&gt;auto-revert-interval&lt;/code&gt; seconds (like the Buffer Menu), use:</target>
        </trans-unit>
        <trans-unit id="71a2adf65a17fe610efe228b45e1cb903d7bc113" translate="yes" xml:space="preserve">
          <source>If you kill a buffer that is current or displayed in a window, Emacs automatically selects or displays some other buffer instead. This means that killing a buffer can change the current buffer. Therefore, when you kill a buffer, you should also take the precautions associated with changing the current buffer (unless you happen to know that the buffer being killed isn&amp;rsquo;t current). See &lt;a href=&quot;current-buffer#Current-Buffer&quot;&gt;Current Buffer&lt;/a&gt;.</source>
          <target state="translated">If you kill a buffer that is current or displayed in a window, Emacs automatically selects or displays some other buffer instead. This means that killing a buffer can change the current buffer. Therefore, when you kill a buffer, you should also take the precautions associated with changing the current buffer (unless you happen to know that the buffer being killed isn&amp;rsquo;t current). See &lt;a href=&quot;current-buffer#Current-Buffer&quot;&gt;Current Buffer&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="2706b518d3512c99807786ca5940e248dfba9276" translate="yes" xml:space="preserve">
          <source>If you kill a buffer that is the base buffer of one or more indirect buffers (see &lt;a href=&quot;indirect-buffers#Indirect-Buffers&quot;&gt;Indirect Buffers&lt;/a&gt;), the indirect buffers are automatically killed as well.</source>
          <target state="translated">If you kill a buffer that is the base buffer of one or more indirect buffers (see &lt;a href=&quot;indirect-buffers#Indirect-Buffers&quot;&gt;Indirect Buffers&lt;/a&gt;), the indirect buffers are automatically killed as well.</target>
        </trans-unit>
        <trans-unit id="939512f98de951d77e46c1fff3ddbca96952464a" translate="yes" xml:space="preserve">
          <source>If you kill the buffer-local binding of a variable that automatically becomes buffer-local when set, this makes the default value visible in the current buffer. However, if you set the variable again, that will once again create a buffer-local binding for it.</source>
          <target state="translated">設定時に自動的にバッファローカルになる変数のバッファローカルバインディングを無効にすると、デフォルト値が現在のバッファに表示されるようになります。しかし、変数を再度設定すると、再びバッファローカルバインディングが作成されます。</target>
        </trans-unit>
        <trans-unit id="0bd6b02038337f2a12bac9ed44de58bac548a3a1" translate="yes" xml:space="preserve">
          <source>If you make local bindings (with &lt;code&gt;let&lt;/code&gt; or function arguments) for a variable that may also have buffer-local bindings, make sure that the same buffer is current at the beginning and at the end of the local binding&amp;rsquo;s scope. Otherwise you might bind it in one buffer and unbind it in another!</source>
          <target state="translated">If you make local bindings (with &lt;code&gt;let&lt;/code&gt; or function arguments) for a variable that may also have buffer-local bindings, make sure that the same buffer is current at the beginning and at the end of the local binding&amp;rsquo;s scope. Otherwise you might bind it in one buffer and unbind it in another!</target>
        </trans-unit>
        <trans-unit id="0b3744efd19539e84c69f0918b4efca1435c71f7" translate="yes" xml:space="preserve">
          <source>If you may need to follow symbolic links preceding &amp;lsquo;</source>
          <target state="translated">If you may need to follow symbolic links preceding &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="b461f9a1f06af80679d7c10a422deb5335205d1b" translate="yes" xml:space="preserve">
          <source>If you modify any of these two variables, you should normally modify both, to make sure they describe paragraphs consistently. For example, to have each new line start a new paragraph for bidi-reordering purposes, set both variables to &lt;code&gt;&quot;^&quot;&lt;/code&gt;.</source>
          <target state="translated">If you modify any of these two variables, you should normally modify both, to make sure they describe paragraphs consistently. For example, to have each new line start a new paragraph for bidi-reordering purposes, set both variables to &lt;code&gt;&quot;^&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fbb55a4c1fcd6f3dc2ebf9fd160259311b33e11d" translate="yes" xml:space="preserve">
          <source>If you need a function to read a character using the minibuffer, use &lt;code&gt;read-char-from-minibuffer&lt;/code&gt; (see &lt;a href=&quot;multiple-queries#Multiple-Queries&quot;&gt;Multiple Queries&lt;/a&gt;).</source>
          <target state="translated">If you need a function to read a character using the minibuffer, use &lt;code&gt;read-char-from-minibuffer&lt;/code&gt; (see &lt;a href=&quot;multiple-queries#Multiple-Queries&quot;&gt;Multiple Queries&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="2229e5dcc64890b68f42258b57c852775ec25771" translate="yes" xml:space="preserve">
          <source>If you need full backtracking capability to handle multiple uses of &amp;lsquo;</source>
          <target state="translated">If you need full backtracking capability to handle multiple uses of &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="7165f313d61fb790c146d795e82a0805252bf947" translate="yes" xml:space="preserve">
          <source>If you need something more sophisticated, such as to make changes in various buffers constitute one atomic group, you must directly call lower-level functions that &lt;code&gt;atomic-change-group&lt;/code&gt; uses.</source>
          <target state="translated">If you need something more sophisticated, such as to make changes in various buffers constitute one atomic group, you must directly call lower-level functions that &lt;code&gt;atomic-change-group&lt;/code&gt; uses.</target>
        </trans-unit>
        <trans-unit id="11ad821a0f4118843537a5c201be2e1b6fea9371" translate="yes" xml:space="preserve">
          <source>If you need to ask the user a question that might have more than just 2 answers, use &lt;code&gt;read-answer&lt;/code&gt;.</source>
          <target state="translated">If you need to ask the user a question that might have more than just 2 answers, use &lt;code&gt;read-answer&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bb6836f3fc908033ed970b99b5923dc6160e9d7e" translate="yes" xml:space="preserve">
          <source>If you need to compute the width of a string on display, you should use &lt;code&gt;string-width&lt;/code&gt; (see &lt;a href=&quot;size-of-displayed-text#Size-of-Displayed-Text&quot;&gt;Size of Displayed Text&lt;/a&gt;), not &lt;code&gt;length&lt;/code&gt;, since &lt;code&gt;length&lt;/code&gt; only counts the number of characters, but does not account for the display width of each character.</source>
          <target state="translated">If you need to compute the width of a string on display, you should use &lt;code&gt;string-width&lt;/code&gt; (see &lt;a href=&quot;size-of-displayed-text#Size-of-Displayed-Text&quot;&gt;Size of Displayed Text&lt;/a&gt;), not &lt;code&gt;length&lt;/code&gt; , since &lt;code&gt;length&lt;/code&gt; only counts the number of characters, but does not account for the display width of each character.</target>
        </trans-unit>
        <trans-unit id="70e7694409075c9777e7eff046635c9af505c810" translate="yes" xml:space="preserve">
          <source>If you need to deal with time values that are not representable by &lt;code&gt;struct timespec&lt;/code&gt;, or if you want higher precision, call the Lisp function &lt;code&gt;encode-time&lt;/code&gt; and work with its return value. See &lt;a href=&quot;time-conversion#Time-Conversion&quot;&gt;Time Conversion&lt;/a&gt;.</source>
          <target state="translated">If you need to deal with time values that are not representable by &lt;code&gt;struct timespec&lt;/code&gt; , or if you want higher precision, call the Lisp function &lt;code&gt;encode-time&lt;/code&gt; and work with its return value. See &lt;a href=&quot;time-conversion#Time-Conversion&quot;&gt;Time Conversion&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="b8b147bdeb91ba4529c7e7a0d87287ac0e0835ba" translate="yes" xml:space="preserve">
          <source>If you need to display in a single buffer several very different types of text, consider using an alternative facility described in &lt;a href=&quot;swapping-text#Swapping-Text&quot;&gt;Swapping Text&lt;/a&gt;.</source>
          <target state="translated">If you need to display in a single buffer several very different types of text, consider using an alternative facility described in &lt;a href=&quot;swapping-text#Swapping-Text&quot;&gt;Swapping Text&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="eeed25719a7b61a09bb3ff7fc01192b5bf607932" translate="yes" xml:space="preserve">
          <source>If you need to make sure the resulting string, when copied to a different location, will not change its visual appearance due to reordering of bidirectional text, use the &lt;code&gt;buffer-substring-with-bidi-context&lt;/code&gt; function (see &lt;a href=&quot;bidirectional-display#Bidirectional-Display&quot;&gt;buffer-substring-with-bidi-context&lt;/a&gt;).</source>
          <target state="translated">If you need to make sure the resulting string, when copied to a different location, will not change its visual appearance due to reordering of bidirectional text, use the &lt;code&gt;buffer-substring-with-bidi-context&lt;/code&gt; function (see &lt;a href=&quot;bidirectional-display#Bidirectional-Display&quot;&gt;buffer-substring-with-bidi-context&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="f6b2d2f05788f0a22eaa0bceb4193d2292e14cac" translate="yes" xml:space="preserve">
          <source>If you need to split a string into a list of individual command-line arguments suitable for &lt;code&gt;call-process&lt;/code&gt; or &lt;code&gt;start-process&lt;/code&gt;, see &lt;a href=&quot;shell-arguments#Shell-Arguments&quot;&gt;split-string-and-unquote&lt;/a&gt;.</source>
          <target state="translated">If you need to split a string into a list of individual command-line arguments suitable for &lt;code&gt;call-process&lt;/code&gt; or &lt;code&gt;start-process&lt;/code&gt; , see &lt;a href=&quot;shell-arguments#Shell-Arguments&quot;&gt;split-string-and-unquote&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="af860e5b717926ca034b7f46b6b08bfccf91b51e" translate="yes" xml:space="preserve">
          <source>If you need to use &lt;code&gt;funcall&lt;/code&gt; to call a command and make it behave as if invoked interactively, use &lt;code&gt;funcall-interactively&lt;/code&gt; (see &lt;a href=&quot;interactive-call#Interactive-Call&quot;&gt;Interactive Call&lt;/a&gt;).</source>
          <target state="translated">If you need to use &lt;code&gt;funcall&lt;/code&gt; to call a command and make it behave as if invoked interactively, use &lt;code&gt;funcall-interactively&lt;/code&gt; (see &lt;a href=&quot;interactive-call#Interactive-Call&quot;&gt;Interactive Call&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="d21db95cbdcf54c25ebb2a8e577371ca4dde72ec" translate="yes" xml:space="preserve">
          <source>If you need to use binary I/O in batch mode, e.g., use the functions described in this section to write out arbitrary binary data or avoid conversion of newlines on non-POSIX hosts, see &lt;a href=&quot;input-functions#Input-Functions&quot;&gt;set-binary-mode&lt;/a&gt;.</source>
          <target state="translated">If you need to use binary I/O in batch mode, e.g., use the functions described in this section to write out arbitrary binary data or avoid conversion of newlines on non-POSIX hosts, see &lt;a href=&quot;input-functions#Input-Functions&quot;&gt;set-binary-mode&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="b65293e7558904871088857519e372b129e02eab" translate="yes" xml:space="preserve">
          <source>If you only need to save and restore the identity of the current buffer, use &lt;code&gt;save-current-buffer&lt;/code&gt; or &lt;code&gt;with-current-buffer&lt;/code&gt; instead (see &lt;a href=&quot;current-buffer#Current-Buffer&quot;&gt;Current Buffer&lt;/a&gt;). If you need to save or restore window configurations, see the forms described in &lt;a href=&quot;window-configurations#Window-Configurations&quot;&gt;Window Configurations&lt;/a&gt; and in &lt;a href=&quot;frame-configurations#Frame-Configurations&quot;&gt;Frame Configurations&lt;/a&gt;.</source>
          <target state="translated">If you only need to save and restore the identity of the current buffer, use &lt;code&gt;save-current-buffer&lt;/code&gt; or &lt;code&gt;with-current-buffer&lt;/code&gt; instead (see &lt;a href=&quot;current-buffer#Current-Buffer&quot;&gt;Current Buffer&lt;/a&gt;). If you need to save or restore window configurations, see the forms described in &lt;a href=&quot;window-configurations#Window-Configurations&quot;&gt;Window Configurations&lt;/a&gt; and in &lt;a href=&quot;frame-configurations#Frame-Configurations&quot;&gt;Frame Configurations&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="9083fbc2d21158149a1bc8ac3c7f2844e3ff216f" translate="yes" xml:space="preserve">
          <source>If you performed the last search on a string, pass the same string as &lt;var&gt;string&lt;/var&gt;. Then this function returns a new string, in which the matched text is replaced by &lt;var&gt;replacement&lt;/var&gt;.</source>
          <target state="translated">If you performed the last search on a string, pass the same string as &lt;var&gt;string&lt;/var&gt; . Then this function returns a new string, in which the matched text is replaced by &lt;var&gt;replacement&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="fbd25781d637473670d3becc584d66487e91046b" translate="yes" xml:space="preserve">
          <source>If you plan to use &lt;code&gt;read&lt;/code&gt; later on the formatted string to retrieve a copy of the formatted value, use a specification that lets &lt;code&gt;read&lt;/code&gt; reconstruct the value. To format numbers in this reversible way you can use &amp;lsquo;</source>
          <target state="translated">If you plan to use &lt;code&gt;read&lt;/code&gt; later on the formatted string to retrieve a copy of the formatted value, use a specification that lets &lt;code&gt;read&lt;/code&gt; reconstruct the value. To format numbers in this reversible way you can use &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="6a33cd11cdd6f251eb76fe12ca6c4e85092aa642" translate="yes" xml:space="preserve">
          <source>If you press the same mouse button more than once in quick succession without moving the mouse, Emacs generates special &lt;em&gt;repeat&lt;/em&gt; mouse events for the second and subsequent presses.</source>
          <target state="translated">If you press the same mouse button more than once in quick succession without moving the mouse, Emacs generates special &lt;em&gt;repeat&lt;/em&gt; mouse events for the second and subsequent presses.</target>
        </trans-unit>
        <trans-unit id="6e651e37e48dc0de984abd21d2f50cbabd101a42" translate="yes" xml:space="preserve">
          <source>If you provide a string instead of a symbol as &lt;var&gt;symbol&lt;/var&gt;, it stands for a symbol name. Then &lt;code&gt;unintern&lt;/code&gt; deletes the symbol (if any) in the obarray which has that name. If there is no such symbol, &lt;code&gt;unintern&lt;/code&gt; does nothing.</source>
          <target state="translated">If you provide a string instead of a symbol as &lt;var&gt;symbol&lt;/var&gt; , it stands for a symbol name. Then &lt;code&gt;unintern&lt;/code&gt; deletes the symbol (if any) in the obarray which has that name. If there is no such symbol, &lt;code&gt;unintern&lt;/code&gt; does nothing.</target>
        </trans-unit>
        <trans-unit id="97d5739d107f56aa611048ed083389faa16f7c11" translate="yes" xml:space="preserve">
          <source>If you put a &lt;code&gt;defcustom&lt;/code&gt; in a pre-loaded Emacs Lisp file (see &lt;a href=&quot;building-emacs#Building-Emacs&quot;&gt;Building Emacs&lt;/a&gt;), the standard value installed at dump time might be incorrect, e.g., because another variable that it depends on has not been assigned the right value yet. In that case, use &lt;code&gt;custom-reevaluate-setting&lt;/code&gt;, described below, to re-evaluate the standard value after Emacs starts up.</source>
          <target state="translated">If you put a &lt;code&gt;defcustom&lt;/code&gt; in a pre-loaded Emacs Lisp file (see &lt;a href=&quot;building-emacs#Building-Emacs&quot;&gt;Building Emacs&lt;/a&gt;), the standard value installed at dump time might be incorrect, e.g., because another variable that it depends on has not been assigned the right value yet. In that case, use &lt;code&gt;custom-reevaluate-setting&lt;/code&gt; , described below, to re-evaluate the standard value after Emacs starts up.</target>
        </trans-unit>
        <trans-unit id="6c382b520db08e679ebb946a10d148108b4e2829" translate="yes" xml:space="preserve">
          <source>If you put a &lt;code&gt;yank-handler&lt;/code&gt; text property on all or part of a string, that alters how &lt;code&gt;insert-for-yank&lt;/code&gt; inserts the string. If different parts of the string have different &lt;code&gt;yank-handler&lt;/code&gt; values (comparison being done with &lt;code&gt;eq&lt;/code&gt;), each substring is handled separately. The property value must be a list of one to four elements, with the following format (where elements after the first may be omitted):</source>
          <target state="translated">If you put a &lt;code&gt;yank-handler&lt;/code&gt; text property on all or part of a string, that alters how &lt;code&gt;insert-for-yank&lt;/code&gt; inserts the string. If different parts of the string have different &lt;code&gt;yank-handler&lt;/code&gt; values (comparison being done with &lt;code&gt;eq&lt;/code&gt; ), each substring is handled separately. The property value must be a list of one to four elements, with the following format (where elements after the first may be omitted):</target>
        </trans-unit>
        <trans-unit id="20d9b4533ab2bc9736806c58622cd4bf44e87f4c" translate="yes" xml:space="preserve">
          <source>If you redump Emacs by calling &lt;code&gt;dump-emacs&lt;/code&gt; (see &lt;a href=&quot;building-emacs#Building-Emacs&quot;&gt;Building Emacs&lt;/a&gt;), you may wish to set this variable to &lt;code&gt;nil&lt;/code&gt; first in order to cause the new dumped Emacs to process its new command-line arguments.</source>
          <target state="translated">If you redump Emacs by calling &lt;code&gt;dump-emacs&lt;/code&gt; (see &lt;a href=&quot;building-emacs#Building-Emacs&quot;&gt;Building Emacs&lt;/a&gt;), you may wish to set this variable to &lt;code&gt;nil&lt;/code&gt; first in order to cause the new dumped Emacs to process its new command-line arguments.</target>
        </trans-unit>
        <trans-unit id="085a188ee0ae3f10744759afa9f5b7baf461b132" translate="yes" xml:space="preserve">
          <source>If you run &lt;code&gt;normal-mode&lt;/code&gt; interactively, the argument &lt;var&gt;find-file&lt;/var&gt; is normally &lt;code&gt;nil&lt;/code&gt;. In this case, &lt;code&gt;normal-mode&lt;/code&gt; unconditionally processes any file local variables.</source>
          <target state="translated">If you run &lt;code&gt;normal-mode&lt;/code&gt; interactively, the argument &lt;var&gt;find-file&lt;/var&gt; is normally &lt;code&gt;nil&lt;/code&gt; . In this case, &lt;code&gt;normal-mode&lt;/code&gt; unconditionally processes any file local variables.</target>
        </trans-unit>
        <trans-unit id="69bd4b2952384a0a33ef5b0366f425ff27273401" translate="yes" xml:space="preserve">
          <source>If you run Emacs from the directory where it was built&amp;mdash;that is, an executable that has not been formally installed&amp;mdash;Emacs instead initializes &lt;code&gt;load-path&lt;/code&gt; using the</source>
          <target state="translated">If you run Emacs from the directory where it was built&amp;mdash;that is, an executable that has not been formally installed&amp;mdash;Emacs instead initializes &lt;code&gt;load-path&lt;/code&gt; using the</target>
        </trans-unit>
        <trans-unit id="33df89859e8bd5153172b40f655f9725c87eaa23" translate="yes" xml:space="preserve">
          <source>If you set &lt;code&gt;debug-on-event&lt;/code&gt; to a special event (see &lt;a href=&quot;special-events#Special-Events&quot;&gt;Special Events&lt;/a&gt;), Emacs will try to enter the debugger as soon as it receives this event, bypassing &lt;code&gt;special-event-map&lt;/code&gt;. At present, the only supported values correspond to the signals &lt;code&gt;SIGUSR1&lt;/code&gt; and &lt;code&gt;SIGUSR2&lt;/code&gt; (this is the default). This can be helpful when &lt;code&gt;inhibit-quit&lt;/code&gt; is set and Emacs is not otherwise responding.</source>
          <target state="translated">If you set &lt;code&gt;debug-on-event&lt;/code&gt; to a special event (see &lt;a href=&quot;special-events#Special-Events&quot;&gt;Special Events&lt;/a&gt;), Emacs will try to enter the debugger as soon as it receives this event, bypassing &lt;code&gt;special-event-map&lt;/code&gt; . At present, the only supported values correspond to the signals &lt;code&gt;SIGUSR1&lt;/code&gt; and &lt;code&gt;SIGUSR2&lt;/code&gt; (this is the default). This can be helpful when &lt;code&gt;inhibit-quit&lt;/code&gt; is set and Emacs is not otherwise responding.</target>
        </trans-unit>
        <trans-unit id="9c694c02ac2532f5fe2abe237714159362002a21" translate="yes" xml:space="preserve">
          <source>If you set &lt;code&gt;debug-on-message&lt;/code&gt; to a regular expression, Emacs will enter the debugger if it displays a matching message in the echo area. For example, this can be useful when trying to find the cause of a particular message.</source>
          <target state="translated">If you set &lt;code&gt;debug-on-message&lt;/code&gt; to a regular expression, Emacs will enter the debugger if it displays a matching message in the echo area. For example, this can be useful when trying to find the cause of a particular message.</target>
        </trans-unit>
        <trans-unit id="690f685efae0cb9f9d5902d7605b6ee4e66d6dce" translate="yes" xml:space="preserve">
          <source>If you set this hook locally in a buffer, it is assumed to be associated with the file or the way the contents of the buffer were obtained. Thus the variable is marked as a permanent local, so that changing the major mode does not alter a buffer-local value. On the other hand, calling &lt;code&gt;set-visited-file-name&lt;/code&gt; will reset it. If this is not what you want, you might like to use &lt;code&gt;write-contents-functions&lt;/code&gt; instead.</source>
          <target state="translated">If you set this hook locally in a buffer, it is assumed to be associated with the file or the way the contents of the buffer were obtained. Thus the variable is marked as a permanent local, so that changing the major mode does not alter a buffer-local value. On the other hand, calling &lt;code&gt;set-visited-file-name&lt;/code&gt; will reset it. If this is not what you want, you might like to use &lt;code&gt;write-contents-functions&lt;/code&gt; instead.</target>
        </trans-unit>
        <trans-unit id="cfc7987161a9303dafc2b33573d2e5f10008802a" translate="yes" xml:space="preserve">
          <source>If you set this variable to &lt;code&gt;nil&lt;/code&gt; in a buffer, that buffer does not have a mode line. (A window that is just one line tall also does not display a mode line.)</source>
          <target state="translated">If you set this variable to &lt;code&gt;nil&lt;/code&gt; in a buffer, that buffer does not have a mode line. (A window that is just one line tall also does not display a mode line.)</target>
        </trans-unit>
        <trans-unit id="9d66da1552d51dd81ff05a3b900a0329bf52436f" translate="yes" xml:space="preserve">
          <source>If you set this variable to a non-&lt;code&gt;nil&lt;/code&gt; value, the feature of moving point out of these sequences is completely turned off.</source>
          <target state="translated">If you set this variable to a non- &lt;code&gt;nil&lt;/code&gt; value, the feature of moving point out of these sequences is completely turned off.</target>
        </trans-unit>
        <trans-unit id="ca8a3595d33e58a00ada25426e1b2f96b61be780" translate="yes" xml:space="preserve">
          <source>If you specify &lt;var&gt;initial&lt;/var&gt;, that is an initial file name to insert in the buffer (after &lt;var&gt;directory&lt;/var&gt;, if that is inserted). In this case, point goes at the beginning of &lt;var&gt;initial&lt;/var&gt;. The default for &lt;var&gt;initial&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;&amp;mdash;don&amp;rsquo;t insert any file name. To see what &lt;var&gt;initial&lt;/var&gt; does, try the command</source>
          <target state="translated">If you specify &lt;var&gt;initial&lt;/var&gt; , that is an initial file name to insert in the buffer (after &lt;var&gt;directory&lt;/var&gt; , if that is inserted). In this case, point goes at the beginning of &lt;var&gt;initial&lt;/var&gt; . The default for &lt;var&gt;initial&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt; &amp;mdash;don&amp;rsquo;t insert any file name. To see what &lt;var&gt;initial&lt;/var&gt; does, try the command</target>
        </trans-unit>
        <trans-unit id="5c87b5e9500f1aecb01a1e2b9e8cf60f70697916" translate="yes" xml:space="preserve">
          <source>If you specify &lt;var&gt;prompt&lt;/var&gt;, that becomes the overall prompt string for the keymap. You should specify this only for menu keymaps (see &lt;a href=&quot;defining-menus#Defining-Menus&quot;&gt;Defining Menus&lt;/a&gt;). A keymap with an overall prompt string will always present a mouse menu or a keyboard menu if it is active for looking up the next input event. Don&amp;rsquo;t specify an overall prompt string for the main map of a major or minor mode, because that would cause the command loop to present a keyboard menu every time.</source>
          <target state="translated">If you specify &lt;var&gt;prompt&lt;/var&gt; , that becomes the overall prompt string for the keymap. You should specify this only for menu keymaps (see &lt;a href=&quot;defining-menus#Defining-Menus&quot;&gt;Defining Menus&lt;/a&gt;). A keymap with an overall prompt string will always present a mouse menu or a keyboard menu if it is active for looking up the next input event. Don&amp;rsquo;t specify an overall prompt string for the main map of a major or minor mode, because that would cause the command loop to present a keyboard menu every time.</target>
        </trans-unit>
        <trans-unit id="5edea50f7657db34bc2bc85d01daa7f7adc96609" translate="yes" xml:space="preserve">
          <source>If you specify &lt;var&gt;uid&lt;/var&gt; (a number), the result is the user name that corresponds to &lt;var&gt;uid&lt;/var&gt;, or &lt;code&gt;nil&lt;/code&gt; if there is no such user.</source>
          <target state="translated">If you specify &lt;var&gt;uid&lt;/var&gt; (a number), the result is the user name that corresponds to &lt;var&gt;uid&lt;/var&gt; , or &lt;code&gt;nil&lt;/code&gt; if there is no such user.</target>
        </trans-unit>
        <trans-unit id="f97e6393b96bab93a2f54c0164447ab04caf4a1b" translate="yes" xml:space="preserve">
          <source>If you specify a buffer, &lt;var&gt;buffer&lt;/var&gt;, then the value is the size of &lt;var&gt;buffer&lt;/var&gt;.</source>
          <target state="translated">If you specify a buffer, &lt;var&gt;buffer&lt;/var&gt; , then the value is the size of &lt;var&gt;buffer&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="f505374ea489ecb94c5a8340e207775e38c3e1b5" translate="yes" xml:space="preserve">
          <source>If you specify a number for &lt;var&gt;limit&lt;/var&gt;, then after chasing through that many links, the function just returns what it has even if that is still a symbolic link.</source>
          <target state="translated">If you specify a number for &lt;var&gt;limit&lt;/var&gt; , then after chasing through that many links, the function just returns what it has even if that is still a symbolic link.</target>
        </trans-unit>
        <trans-unit id="375bd3746fef25d0232e18d73f21e041e0753b43" translate="yes" xml:space="preserve">
          <source>If you specify an XBM image using data within Emacs instead of an external file, use the following three properties:</source>
          <target state="translated">外部ファイルではなくEmacs内のデータを使用してXBMイメージを指定する場合は、以下の3つのプロパティを使用します。</target>
        </trans-unit>
        <trans-unit id="fde2a383a2451f6ddbde3c6482877a98961e5cf2" translate="yes" xml:space="preserve">
          <source>If you specify the frame name explicitly when you create the frame, the name is also used (instead of the name of the Emacs executable) when looking up X resources for the frame.</source>
          <target state="translated">フレームを作成する際にフレーム名を明示的に指定した場合、フレームのXリソースを検索する際にも(Emacsの実行ファイル名ではなく)その名前が使用されます。</target>
        </trans-unit>
        <trans-unit id="f6ca207d06cc2c68a4c2828df92b77209025123f" translate="yes" xml:space="preserve">
          <source>If you specify the same slot on the same side for two or more different buffers, the buffer displayed last is shown in the corresponding window. Hence, slots can be used for sharing the same side window between buffers.</source>
          <target state="translated">2つ以上の異なるバッファに対して同じ側に同じスロットを指定すると、最後に表示されたバッファが対応するウィンドウに表示されます。したがって、スロットはバッファ間で同じサイドウィンドウを共有するために使用することができます。</target>
        </trans-unit>
        <trans-unit id="05d28610a19e0f56bd2c76d43cd9274215e3fa7d" translate="yes" xml:space="preserve">
          <source>If you specify this keyword, the variable&amp;rsquo;s documentation string should describe how to do the same job in hand-written Lisp code.</source>
          <target state="translated">If you specify this keyword, the variable&amp;rsquo;s documentation string should describe how to do the same job in hand-written Lisp code.</target>
        </trans-unit>
        <trans-unit id="716618ddbeabe19866aadf7f17b67b04057ebcef" translate="yes" xml:space="preserve">
          <source>If you store a completion alist in a variable, you should mark the variable as risky by giving it a non-&lt;code&gt;nil&lt;/code&gt;&lt;code&gt;risky-local-variable&lt;/code&gt; property. See &lt;a href=&quot;file-local-variables#File-Local-Variables&quot;&gt;File Local Variables&lt;/a&gt;.</source>
          <target state="translated">If you store a completion alist in a variable, you should mark the variable as risky by giving it a non- &lt;code&gt;nil&lt;/code&gt; &lt;code&gt;risky-local-variable&lt;/code&gt; property. See &lt;a href=&quot;file-local-variables#File-Local-Variables&quot;&gt;File Local Variables&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="40a77c6103e436345187dd30831cc5254ef479b8" translate="yes" xml:space="preserve">
          <source>If you try this, you will notice that repeated attempts to display</source>
          <target state="translated">これを試してみると、何度も</target>
        </trans-unit>
        <trans-unit id="6a67eecb62315ce39f790ce6ffad7fa4e38d4eb8" translate="yes" xml:space="preserve">
          <source>If you use &lt;code&gt;buffer-swap-text&lt;/code&gt; on a file-visiting buffer, you should set up a hook to save the buffer&amp;rsquo;s original text rather than what it was swapped with. &lt;code&gt;write-region-annotate-functions&lt;/code&gt; works for this purpose. You should probably set &lt;code&gt;buffer-saved-size&lt;/code&gt; to -2 in the buffer, so that changes in the text it is swapped with will not interfere with auto-saving.</source>
          <target state="translated">If you use &lt;code&gt;buffer-swap-text&lt;/code&gt; on a file-visiting buffer, you should set up a hook to save the buffer&amp;rsquo;s original text rather than what it was swapped with. &lt;code&gt;write-region-annotate-functions&lt;/code&gt; works for this purpose. You should probably set &lt;code&gt;buffer-saved-size&lt;/code&gt; to -2 in the buffer, so that changes in the text it is swapped with will not interfere with auto-saving.</target>
        </trans-unit>
        <trans-unit id="d6907391755fb47bb50b18a1d24adc63588140ea" translate="yes" xml:space="preserve">
          <source>If you use &lt;code&gt;regexp-opt&lt;/code&gt; to produce the regular expression &lt;var&gt;matcher&lt;/var&gt;, you can use &lt;code&gt;regexp-opt-depth&lt;/code&gt; (see &lt;a href=&quot;regexp-functions#Regexp-Functions&quot;&gt;Regexp Functions&lt;/a&gt;) to calculate the value for &lt;var&gt;subexp&lt;/var&gt;.</source>
          <target state="translated">If you use &lt;code&gt;regexp-opt&lt;/code&gt; to produce the regular expression &lt;var&gt;matcher&lt;/var&gt; , you can use &lt;code&gt;regexp-opt-depth&lt;/code&gt; (see &lt;a href=&quot;regexp-functions#Regexp-Functions&quot;&gt;Regexp Functions&lt;/a&gt;) to calculate the value for &lt;var&gt;subexp&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="fd48732c105c46f30a8758370472e5d61da524f5" translate="yes" xml:space="preserve">
          <source>If you use a minibuffer-only frame, you might want that frame to raise when you enter the minibuffer. If so, set the variable &lt;code&gt;minibuffer-auto-raise&lt;/code&gt; to &lt;code&gt;t&lt;/code&gt;. See &lt;a href=&quot;raising-and-lowering#Raising-and-Lowering&quot;&gt;Raising and Lowering&lt;/a&gt;.</source>
          <target state="translated">If you use a minibuffer-only frame, you might want that frame to raise when you enter the minibuffer. If so, set the variable &lt;code&gt;minibuffer-auto-raise&lt;/code&gt; to &lt;code&gt;t&lt;/code&gt; . See &lt;a href=&quot;raising-and-lowering#Raising-and-Lowering&quot;&gt;Raising and Lowering&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="fa0c1227e66ae4b44f79049d6018702a84803396" translate="yes" xml:space="preserve">
          <source>If you use any Unicode-style escape sequence &amp;lsquo;</source>
          <target state="translated">If you use any Unicode-style escape sequence &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="0b2b537fa713937b15520eb5e6b8621ddcd5294c" translate="yes" xml:space="preserve">
          <source>If you use the &lt;code&gt;define-derived-mode&lt;/code&gt; macro, it will take care of many of these conventions automatically. See &lt;a href=&quot;derived-modes#Derived-Modes&quot;&gt;Derived Modes&lt;/a&gt;. Note also that Fundamental mode is an exception to many of these conventions, because it represents the default state of Emacs.</source>
          <target state="translated">&lt;code&gt;define-derived-mode&lt;/code&gt; マクロを使用すると、これらの規則の多くが自動的に処理されます。&lt;a href=&quot;derived-modes#Derived-Modes&quot;&gt;派生モードを&lt;/a&gt;参照してください。基本モードはEmacsのデフォルト状態を表すため、これらの規則の多くの例外であることに注意してください。</target>
        </trans-unit>
        <trans-unit id="ebbd02981d2d6e160b2592d755148aa81cf87d75" translate="yes" xml:space="preserve">
          <source>If you use this command in a different window displaying the same buffer, that window will be used instead to display the current definition in the future.</source>
          <target state="translated">同じバッファを表示している別のウィンドウでこのコマンドを使用した場合、将来的にはそのウィンドウが現在の定義を表示するために代わりに使用されます。</target>
        </trans-unit>
        <trans-unit id="afdbef8990f56e48b4ad3c9668d8bcdb3999729f" translate="yes" xml:space="preserve">
          <source>If you use this for a type that appears as an alternative inside of &lt;code&gt;choice&lt;/code&gt;; it specifies the default value to use, at first, if and when the user selects this alternative with the menu in the customization buffer.</source>
          <target state="translated">あなたは、の代替内部のように見えるタイプのためにこれを使用する場合 &lt;code&gt;choice&lt;/code&gt; 。これは、ユーザーがカスタマイズバッファーのメニューでこの選択肢を選択した場合に、最初に使用するデフォルト値を指定します。</target>
        </trans-unit>
        <trans-unit id="629ad44964d5895c3d594065b4e7da091b6bb932" translate="yes" xml:space="preserve">
          <source>If you use this keyword more than once, you can put a single item into more than one group. Displaying any of those groups will show this item. Please don&amp;rsquo;t overdo this, since the result would be annoying.</source>
          <target state="translated">このキーワードを複数回使用する場合は、1つのアイテムを複数のグループに入れることができます。これらのグループのいずれかを表示すると、このアイテムが表示されます。結果が煩わしいので、これをやり過ぎないでください。</target>
        </trans-unit>
        <trans-unit id="49e3ca07657354c28816ff97da5c7582b8256ace" translate="yes" xml:space="preserve">
          <source>If you want a menu bar submenu to have contents that vary, you should still use a menu keymap to implement it. To make the contents vary, add a hook function to &lt;code&gt;menu-bar-update-hook&lt;/code&gt; to update the contents of the menu keymap as necessary.</source>
          <target state="translated">メニューバーのサブメニューの内容を変更したい場合でも、メニューキーマップを使用して実装する必要があります。内容を変更するには、 &lt;code&gt;menu-bar-update-hook&lt;/code&gt; にフック関数を追加して、必要に応じてメニューキーマップの内容を更新します。</target>
        </trans-unit>
        <trans-unit id="3be39a84378c1d3ff63b94f456da0a9da8540136" translate="yes" xml:space="preserve">
          <source>If you want code to be executed when a &lt;em&gt;particular&lt;/em&gt; library is loaded, use the macro &lt;code&gt;with-eval-after-load&lt;/code&gt;:</source>
          <target state="translated">&lt;em&gt;特定の&lt;/em&gt;ライブラリがロードされたときにコードを実行する場合は、次のマクロ &lt;code&gt;with-eval-after-load&lt;/code&gt; 使用します-eval-after-load：</target>
        </trans-unit>
        <trans-unit id="c9e263b344abbe33fc08169dcaf2cad9b660996f" translate="yes" xml:space="preserve">
          <source>If you want to be able to debug errors that are caught by a &lt;code&gt;condition-case&lt;/code&gt;, set the variable &lt;code&gt;debug-on-signal&lt;/code&gt; to a non-&lt;code&gt;nil&lt;/code&gt; value. You can also specify that a particular handler should let the debugger run first, by writing &lt;code&gt;debug&lt;/code&gt; among the conditions, like this:</source>
          <target state="translated">&lt;code&gt;condition-case&lt;/code&gt; によってキャッチされたエラーをデバッグできるようにする場合は、変数 &lt;code&gt;debug-on-signal&lt;/code&gt; を &lt;code&gt;nil&lt;/code&gt; 以外の値に設定します。次のように、条件の中で &lt;code&gt;debug&lt;/code&gt; を記述することにより、特定のハンドラーがデバッガーを最初に実行するように指定することもできます。</target>
        </trans-unit>
        <trans-unit id="59bdec6558d0121a21861b3648de710d60579fcc" translate="yes" xml:space="preserve">
          <source>If you want to be able to distinguish all possible values computed by &lt;var&gt;body&lt;/var&gt; from both kinds of abort conditions, write the code like this:</source>
          <target state="translated">&lt;var&gt;body&lt;/var&gt; によって計算されたすべての可能な値を両方の種類の中止条件から区別できるようにする場合は、次のようなコードを記述します。</target>
        </trans-unit>
        <trans-unit id="c7c6338ea698e54cbd61c931fd1eb115534a9075" translate="yes" xml:space="preserve">
          <source>If you want to change the way Emacs handles drop of different types or add a new type, customize &lt;code&gt;x-dnd-types-alist&lt;/code&gt;. This requires detailed knowledge of what types other applications use for drag and drop.</source>
          <target state="translated">Emacsが異なるタイプのドロップを処理する方法を変更したり、新しいタイプを追加したりする場合は、 &lt;code&gt;x-dnd-types-alist&lt;/code&gt; をカスタマイズします。これには、他のアプリケーションがドラッグアンドドロップに使用するタイプに関する詳細な知識が必要です。</target>
        </trans-unit>
        <trans-unit id="9962c78c83f1c13605cf8ba722facf4943be5aa3" translate="yes" xml:space="preserve">
          <source>If you want to define &lt;code&gt;safe-local-variable&lt;/code&gt; properties for variables defined in C source code, add the names and the properties of those variables to the list in the &amp;ldquo;Safe local variables&amp;rdquo; section of</source>
          <target state="translated">Cソースコードで定義された &lt;code&gt;safe-local-variable&lt;/code&gt; プロパティを定義する場合は、それらの変数の名前とプロパティをの「Safelocalvariables」セクションのリストに追加します。</target>
        </trans-unit>
        <trans-unit id="a63fb633f610fcf7b569e1e58f5a8bedb9ec6204" translate="yes" xml:space="preserve">
          <source>If you want to delete elements that are &lt;code&gt;equal&lt;/code&gt; to a given value, use &lt;code&gt;delete&lt;/code&gt; (see below).</source>
          <target state="translated">あなたがある要素を削除したい場合は &lt;code&gt;equal&lt;/code&gt; 与えられた値にし、使用して &lt;code&gt;delete&lt;/code&gt; （下記参照）。</target>
        </trans-unit>
        <trans-unit id="a770c467b911a60af82d90717d058d45481ec026" translate="yes" xml:space="preserve">
          <source>If you want to find all matches for a regexp in part of the buffer, and replace them, the best way is to write an explicit loop using &lt;code&gt;re-search-forward&lt;/code&gt; and &lt;code&gt;replace-match&lt;/code&gt;, like this:</source>
          <target state="translated">バッファの一部で正規表現に一致するものをすべて見つけて置換する場合は、次のように &lt;code&gt;re-search-forward&lt;/code&gt; と &lt;code&gt;replace-match&lt;/code&gt; を使用して明示的なループを作成するのが最善の方法です。</target>
        </trans-unit>
        <trans-unit id="e07043ea04e2ff5e4af20b9e5042e3dbc7fb1ab7" translate="yes" xml:space="preserve">
          <source>If you want to increment the variable, you must use &lt;code&gt;setq&lt;/code&gt;, like this:</source>
          <target state="translated">変数をインクリメントする場合は、次のように &lt;code&gt;setq&lt;/code&gt; を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="c38bee5b246e44204c9311862ab52b37815b5e96" translate="yes" xml:space="preserve">
          <source>If you want to make a Lisp variable that is defined in C behave like one declared with &lt;code&gt;defcustom&lt;/code&gt;, add an appropriate entry to</source>
          <target state="translated">Cで定義されているLisp変数を &lt;code&gt;defcustom&lt;/code&gt; で宣言されたもののように動作させる場合は、に適切なエントリを追加します。</target>
        </trans-unit>
        <trans-unit id="c89381f0269c1ad13f9db33500586f3038ca5d1c" translate="yes" xml:space="preserve">
          <source>If you want to make the new mode the default for files with certain recognizable names, add an element to &lt;code&gt;auto-mode-alist&lt;/code&gt; to select the mode for those file names (see &lt;a href=&quot;auto-major-mode#Auto-Major-Mode&quot;&gt;Auto Major Mode&lt;/a&gt;). If you define the mode command to autoload, you should add this element in the same file that calls &lt;code&gt;autoload&lt;/code&gt;. If you use an autoload cookie for the mode command, you can also use an autoload cookie for the form that adds the element (see &lt;a href=&quot;autoload#autoload-cookie&quot;&gt;autoload cookie&lt;/a&gt;). If you do not autoload the mode command, it is sufficient to add the element in the file that contains the mode definition.</source>
          <target state="translated">新しいモードを特定の認識可能な名前のファイルのデフォルトにしたい場合は、 &lt;code&gt;auto-mode-alist&lt;/code&gt; に要素を追加して、それらのファイル名のモードを選択します（&lt;a href=&quot;auto-major-mode#Auto-Major-Mode&quot;&gt;自動メジャーモードを&lt;/a&gt;参照）。あなたが自動ロードにモードコマンドを定義する場合は、呼び出しを同じファイルにこの要素を追加する必要が &lt;code&gt;autoload&lt;/code&gt; 。 modeコマンドにautoloadcookieを使用する場合は、要素を追加するフォームにautoload cookieを使用することもできます（&lt;a href=&quot;autoload#autoload-cookie&quot;&gt;autoload cookieを&lt;/a&gt;参照）。 modeコマンドを自動ロードしない場合は、モード定義を含むファイルに要素を追加するだけで十分です。</target>
        </trans-unit>
        <trans-unit id="b6bd9286bc367e97ce4540abf13e066ac7ad9d72" translate="yes" xml:space="preserve">
          <source>If you want to pass a file name to another process so that another program can read the file, use the function &lt;code&gt;file-local-copy&lt;/code&gt;; see &lt;a href=&quot;magic-file-names#Magic-File-Names&quot;&gt;Magic File Names&lt;/a&gt;.</source>
          <target state="translated">別のプログラムがファイルを読み取れるようにファイル名を別のプロセスに渡したい場合は、関数 &lt;code&gt;file-local-copy&lt;/code&gt; ;を使用します。&lt;a href=&quot;magic-file-names#Magic-File-Names&quot;&gt;マジックファイル名を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="252c3f2a6736d1faced75b5183751f3b39035b6e" translate="yes" xml:space="preserve">
          <source>If you want to preload function or variable definitions, there are three ways you can do this and make their documentation strings accessible when you subsequently run Emacs:</source>
          <target state="translated">関数や変数の定義をプリロードするには、次の 3 つの方法があります。</target>
        </trans-unit>
        <trans-unit id="2cee666fd30a296699a4e8f28dd2fdfe14c7228f" translate="yes" xml:space="preserve">
          <source>If you want to specify group members through &lt;var&gt;members&lt;/var&gt;, each element should have the form &lt;code&gt;(&lt;var&gt;name&lt;/var&gt; &lt;var&gt;widget&lt;/var&gt;)&lt;/code&gt;. Here &lt;var&gt;name&lt;/var&gt; is a symbol, and &lt;var&gt;widget&lt;/var&gt; is a widget type for editing that symbol. Useful widgets are &lt;code&gt;custom-variable&lt;/code&gt; for a variable, &lt;code&gt;custom-face&lt;/code&gt; for a face, and &lt;code&gt;custom-group&lt;/code&gt; for a group.</source>
          <target state="translated">あなたはを通じてグループメンバーを指定したい場合は &lt;var&gt;members&lt;/var&gt; 、各要素は、フォームが必要です &lt;code&gt;(&lt;var&gt;name&lt;/var&gt; &lt;var&gt;widget&lt;/var&gt;)&lt;/code&gt; 。ここで、 &lt;var&gt;name&lt;/var&gt; はシンボルであり、 &lt;var&gt;widget&lt;/var&gt; はそのシンボルを編集するためのウィジェットタイプです。便利なウィジェットは、 &lt;code&gt;custom-variable&lt;/code&gt; 、変数の &lt;code&gt;custom-face&lt;/code&gt; 、顔用、および &lt;code&gt;custom-group&lt;/code&gt; グループのために。</target>
        </trans-unit>
        <trans-unit id="8e10bdc9c026c4aa399e4b42ba23f64d06212059" translate="yes" xml:space="preserve">
          <source>If you want to take action as soon as a button is pressed, you need to handle &lt;em&gt;button-down&lt;/em&gt; events.&lt;a href=&quot;#FOOT13&quot; name=&quot;DOCF13&quot;&gt;&lt;sup&gt;13&lt;/sup&gt;&lt;/a&gt; These occur as soon as a button is pressed. They are represented by lists that look exactly like click events (see &lt;a href=&quot;click-events#Click-Events&quot;&gt;Click Events&lt;/a&gt;), except that the &lt;var&gt;event-type&lt;/var&gt; symbol name contains the prefix &amp;lsquo;</source>
          <target state="translated">ボタンが押されたらすぐにアクションを実行したい場合は、ボタン&lt;em&gt;ダウン&lt;/em&gt;イベントを処理する必要があります。&lt;a href=&quot;#FOOT13&quot; name=&quot;DOCF13&quot;&gt;&lt;sup&gt;13&lt;/sup&gt;&lt;/a&gt;これらはボタンが押されるとすぐに発生します。これらは、 &lt;var&gt;event-type&lt;/var&gt; シンボル名に接頭辞 'が含まれていることを除いて、&lt;a href=&quot;click-events#Click-Events&quot;&gt;クリックイベントと&lt;/a&gt;まったく同じように見えるリストで表されます（クリックイベントを参照）。</target>
        </trans-unit>
        <trans-unit id="1a0489351d0c73d72b0fca1ef67e3467436c6466" translate="yes" xml:space="preserve">
          <source>If you want to use a directory file name in making such a combination, you must first convert it to a directory name using &lt;code&gt;file-name-as-directory&lt;/code&gt;:</source>
          <target state="translated">このような組み合わせでディレクトリファイル名を使用する場合は、最初に &lt;code&gt;file-name-as-directory&lt;/code&gt; を使用してディレクトリファイル名に変換する必要があります。</target>
        </trans-unit>
        <trans-unit id="27743c56b5d0dd9981b65d5ea4209829501380cb" translate="yes" xml:space="preserve">
          <source>If you want to use this function in an Emacs that was already dumped, you must run Emacs with the &amp;lsquo;</source>
          <target state="translated">すでにダンプされているEmacsでこの関数を使用する場合は、「」を指定してEmacsを実行する必要があります。</target>
        </trans-unit>
        <trans-unit id="9bff8e6a47b35cd45f5d8552d3e143fb633c4b1c" translate="yes" xml:space="preserve">
          <source>If you want to write a command along the lines of &lt;code&gt;query-replace&lt;/code&gt;, you can use &lt;code&gt;perform-replace&lt;/code&gt; to do the work.</source>
          <target state="translated">&lt;code&gt;query-replace&lt;/code&gt; の行に沿ってコマンドを記述したい場合は、 &lt;code&gt;perform-replace&lt;/code&gt; を使用して作業を行うことができます。</target>
        </trans-unit>
        <trans-unit id="353f48c9646e1a608529d6b8bd599dd5f82d0944" translate="yes" xml:space="preserve">
          <source>If you want to write a temporary file which is likely to be small, you should compute the directory like this:</source>
          <target state="translated">小さくなりそうなテンポラリファイルを書きたい場合は、このようにディレクトリを計算します。</target>
        </trans-unit>
        <trans-unit id="1def4c97f647247a5c5ff48230af3b2e0d31bcc6" translate="yes" xml:space="preserve">
          <source>If you want your program to handle different types differently, you must do explicit type checking. The most common way to check the type of an object is to call a &lt;em&gt;type predicate&lt;/em&gt; function. Emacs has a type predicate for each type, as well as some predicates for combinations of types.</source>
          <target state="translated">プログラムで異なる型を異なる方法で処理する場合は、明示的な型チェックを行う必要があります。オブジェクトの型をチェックする最も一般的な方法は、&lt;em&gt;型述語&lt;/em&gt;関数を呼び出すことです。Emacsには、各タイプのタイプ述語と、タイプの組み合わせのいくつかの述語があります。</target>
        </trans-unit>
        <trans-unit id="7f232d7dc078880a275acb49812461edd0ce860d" translate="yes" xml:space="preserve">
          <source>If you wanted to attach the same replace menu to a mouse click, you can do it this way:</source>
          <target state="translated">マウスクリックに同じ置換メニューを付けたかった場合は、このようにします。</target>
        </trans-unit>
        <trans-unit id="28b8c0ff1e6b7f40141852b8f78ad49d083249f7" translate="yes" xml:space="preserve">
          <source>If you wish to add text properties to a buffer or remove them without marking the buffer as modified, you can wrap the calls above in the &lt;code&gt;with-silent-modifications&lt;/code&gt; macro. See &lt;a href=&quot;buffer-modification#Buffer-Modification&quot;&gt;Buffer Modification&lt;/a&gt;.</source>
          <target state="translated">テキストプロパティをバッファに追加したり、バッファを変更済みとしてマークせずに削除したりする場合は、上記の呼び出しを &lt;code&gt;with-silent-modifications&lt;/code&gt; マクロでラップできます。&lt;a href=&quot;buffer-modification#Buffer-Modification&quot;&gt;バッファの変更を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="9314fb2dc1ec806dadc29d80680d276f22ec3691" translate="yes" xml:space="preserve">
          <source>If you wish to verify the conformance of a module to the Emacs dynamic module</source>
          <target state="translated">モジュールの Emacs 動的モジュールへの適合性を検証したい場合は、以下のようにします。</target>
        </trans-unit>
        <trans-unit id="ca331c2a227354c196a20ee4c8b853bb299d3e61" translate="yes" xml:space="preserve">
          <source>If you wish, you can replace the &lt;code&gt;ask-user-about-lock&lt;/code&gt; function with your own version that makes the decision in another way.</source>
          <target state="translated">必要に応じて、 &lt;code&gt;ask-user-about-lock&lt;/code&gt; 関数を、別の方法で決定を行う独自のバージョンに置き換えることができます。</target>
        </trans-unit>
        <trans-unit id="4d662283da0f2958a60954e2e27370bba9903a41" translate="yes" xml:space="preserve">
          <source>If you would like to see Edebug&amp;rsquo;s functions in the backtrace, use</source>
          <target state="translated">Edebugの関数をバックトレースで確認したい場合は、</target>
        </trans-unit>
        <trans-unit id="0e7b1af4801797b08feab3ca25fd99f927f534a2" translate="yes" xml:space="preserve">
          <source>If you write a function definition with an unusual macro that is not one of the known and recognized function definition methods, use of an ordinary magic autoload comment would copy the whole definition into &lt;code&gt;loaddefs.el&lt;/code&gt;. That is not desirable. You can put the desired &lt;code&gt;autoload&lt;/code&gt; call into &lt;code&gt;loaddefs.el&lt;/code&gt; instead by writing this:</source>
          <target state="translated">既知の認識されている関数定義メソッドの1つではない異常なマクロを使用して関数定義を作成する場合、通常のマジックオートロードコメントを使用すると、定義全体が &lt;code&gt;loaddefs.el&lt;/code&gt; にコピーされます。それは望ましくありません。代わりに、 &lt;code&gt;loaddefs.el&lt;/code&gt; ように記述して、目的の &lt;code&gt;autoload&lt;/code&gt; 呼び出しをloaddefs.elに入れることができます。</target>
        </trans-unit>
        <trans-unit id="d233d041f222a6f0703355568126be43236fb134" translate="yes" xml:space="preserve">
          <source>If you write your own function to be put on the &lt;code&gt;tooltip-functions&lt;/code&gt; list, you may need to know the buffer of the mouse event that triggered the tooltip display. The following function provides that information.</source>
          <target state="translated">&lt;code&gt;tooltip-functions&lt;/code&gt; リストに追加する独自の関数を作成する場合は、ツールチップ表示をトリガーしたマウスイベントのバッファーを知る必要がある場合があります。次の関数はその情報を提供します。</target>
        </trans-unit>
        <trans-unit id="5f651282e9deb511f780af54aec3d7ab9890404b" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re setting up an asynchronous TLS connection, you have to also provide the &lt;code&gt;:tls-parameters&lt;/code&gt; parameter (see below).</source>
          <target state="translated">非同期TLS接続を設定する場合は、 &lt;code&gt;:tls-parameters&lt;/code&gt; パラメーターも指定する必要があります（以下を参照）。</target>
        </trans-unit>
        <trans-unit id="d70f5aea9c1d350e01a6eceee76a9e7dbb533230" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using another package, but only need macros from it (the byte compiler will expand those), then &lt;code&gt;eval-when-compile&lt;/code&gt; can be used to load it for compiling, but not executing. For example,</source>
          <target state="translated">別のパッケージを使用しているが、そのパッケージのマクロのみが必要な場合（バイトコンパイラはそれらを展開します）、 &lt;code&gt;eval-when-compile&lt;/code&gt; を使用してコンパイル用にロードできますが、実行はできません。例えば、</target>
        </trans-unit>
        <trans-unit id="2d45e994d3ba3dcb17fc10bf4fc110fdce2e5f3f" translate="yes" xml:space="preserve">
          <source>If your Emacs Lisp program needs to assign some faces to text, it is often a good idea to use certain existing faces or inherit from them, rather than defining entirely new faces. This way, if other users have customized the basic faces to give Emacs a certain look, your program will fit in without additional customization.</source>
          <target state="translated">Emacs Lisp プログラムがテキストにいくつかの面を割り当てる必要がある場合、まったく新しい面を定義するのではなく、特定の既存の面を使用したり、既存の面を継承したりするのがよいでしょう。このようにすれば、他のユーザが基本的な面をカスタマイズして Emacs の外観を変えたとしても、あなたのプログラムは追加のカスタマイズをすることなく適合します。</target>
        </trans-unit>
        <trans-unit id="5c8bded4be6d6694860d7eb8600eff32119af59a" translate="yes" xml:space="preserve">
          <source>If your Emacs build has ImageMagick support, you can use the ImageMagick library to load many image formats (see &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/File-Conveniences.html#File-Conveniences&quot;&gt;File Conveniences&lt;/a&gt; in</source>
          <target state="translated">EmacsビルドでImageMagickがサポートされている場合は、ImageMagickライブラリを使用して多くの画像形式を読み込むことができます（の&lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/File-Conveniences.html#File-Conveniences&quot;&gt;ファイルの利便性&lt;/a&gt;を参照）</target>
        </trans-unit>
        <trans-unit id="79aae3290a46dbcf7b36398be7497460dba8720d" translate="yes" xml:space="preserve">
          <source>If your Lisp program needs to make layout decisions, you will find the following function useful:</source>
          <target state="translated">Lispプログラムでレイアウトを決定する必要がある場合は、以下の関数が便利です。</target>
        </trans-unit>
        <trans-unit id="5fc6e331da7d896db05ebf47e4b7c4b10ed997b9" translate="yes" xml:space="preserve">
          <source>If your function happens to read input, a character you type intending to interrupt execution may be read by the function instead. You can avoid such unintended results by paying attention to when your program wants input.</source>
          <target state="translated">関数が入力を読み込んでしまうと、実行を中断するつもりで入力した文字が代わりに関数に読み込まれてしまうことがあります。このような意図しない結果を避けるには、プログラムが入力を欲しがっているときに注意を払う必要があります。</target>
        </trans-unit>
        <trans-unit id="1ba170033e789539342f30492cc68db1c80633aa" translate="yes" xml:space="preserve">
          <source>If your mode fontifies text explicitly by adding &lt;code&gt;font-lock-face&lt;/code&gt; properties, it can specify &lt;code&gt;(nil t)&lt;/code&gt; for &lt;code&gt;font-lock-defaults&lt;/code&gt; to turn off all automatic fontification. However, this is not required; it is possible to fontify some things using &lt;code&gt;font-lock-face&lt;/code&gt; properties and set up automatic fontification for other parts of the text.</source>
          <target state="translated">モードが &lt;code&gt;font-lock-face&lt;/code&gt; プロパティを追加してテキストを明示的にフォント化する場合、 &lt;code&gt;font-lock-defaults&lt;/code&gt; に &lt;code&gt;(nil t)&lt;/code&gt; を指定して、すべての自動フォント化をオフにすることができます。ただし、これは必須ではありません。 &lt;code&gt;font-lock-face&lt;/code&gt; プロパティを使用していくつかのものをフォント化し、テキストの他の部分の自動フォント化を設定することができます。</target>
        </trans-unit>
        <trans-unit id="6c52d9cb365da1adebc29d4657b8bbaede4dc551" translate="yes" xml:space="preserve">
          <source>If your module includes potentially long-running code, it is a good idea to check from time to time in that code whether the user wants to quit, e.g., by typing</source>
          <target state="translated">モジュールに長時間実行される可能性のあるコードが含まれている場合、ユーザが終了したいかどうかをそのコードの中で時々チェックすることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="89267be88e244d3cd9cb4a0ac81d5a54135d6b2b" translate="yes" xml:space="preserve">
          <source>If your monitor displays colors too light, you should specify a &lt;code&gt;screen-gamma&lt;/code&gt; value smaller than 2.2. This requests correction that makes colors darker. A screen gamma value of 1.5 may give good results for LCD color displays.</source>
          <target state="translated">モニターの色が明るすぎる場合は、2.2未満の &lt;code&gt;screen-gamma&lt;/code&gt; 値を指定する必要があります。これは、色を暗くする修正を要求します。1.5の画面ガンマ値は、LCDカラーディスプレイに良い結果をもたらす可能性があります。</target>
        </trans-unit>
        <trans-unit id="dd935a1aca6ebbfdcc9a67b41e3b53df100359c7" translate="yes" xml:space="preserve">
          <source>If your package uses a fixed file name, how to handle various operating systems simply.</source>
          <target state="translated">パッケージが固定ファイル名を使用している場合、様々なOSを簡単に扱う方法。</target>
        </trans-unit>
        <trans-unit id="1193689cd9a0ac4f92f059d1dc0a2088ab488de5" translate="yes" xml:space="preserve">
          <source>If your program is working correctly, but not fast enough, and you want to make it run more quickly or efficiently, the first thing to do is &lt;em&gt;profile&lt;/em&gt; your code so that you know where it spends most of the execution time. If you find that one particular function is responsible for a significant portion of the execution time, you can start looking for ways to optimize that piece.</source>
          <target state="translated">あなたのプログラムがなく、十分に速く、正しく機能している、とあなたはそれがより迅速または効率的に実行したい場合は、まず最初に行うには、&lt;em&gt;プロファイル&lt;/em&gt;は、実行時間の大半を費やしている場所がわかるようにコードを。ある特定の関数が実行時間のかなりの部分を占めていることがわかった場合は、その部分を最適化する方法を探し始めることができます。</target>
        </trans-unit>
        <trans-unit id="b1e042424d49662dae08a1bf6462ad5f5721c1d9" translate="yes" xml:space="preserve">
          <source>If your system does not support a locale environment, this function behaves like &lt;code&gt;string-equal&lt;/code&gt;.</source>
          <target state="translated">システムがロケール環境をサポートしていない場合、この関数は &lt;code&gt;string-equal&lt;/code&gt; のように動作します。</target>
        </trans-unit>
        <trans-unit id="3b2ec9e1ced6426f29862d927943724a180f4f37" translate="yes" xml:space="preserve">
          <source>If your system does not support a locale environment, this function behaves like &lt;code&gt;string-lessp&lt;/code&gt;.</source>
          <target state="translated">システムがロケール環境をサポートしていない場合、この関数は &lt;code&gt;string-lessp&lt;/code&gt; のように動作します。</target>
        </trans-unit>
        <trans-unit id="a2a7f8c74638fa05ec98f6bc846b8e0afbd1dcfa" translate="yes" xml:space="preserve">
          <source>If, as a consequence of this variable&amp;rsquo;s setting, &lt;code&gt;split-window&lt;/code&gt; makes a new parent window, it also calls &lt;code&gt;set-window-combination-limit&lt;/code&gt; (see below) on the newly-created internal window. This affects how the window tree is rearranged when the child windows are deleted (see below).</source>
          <target state="translated">この変数の設定の結果として、 &lt;code&gt;split-window&lt;/code&gt; が新しい親ウィンドウを作成する場合、新しく作成された内部ウィンドウで &lt;code&gt;set-window-combination-limit&lt;/code&gt; （以下を参照）も呼び出します。これは、子ウィンドウが削除されたときにウィンドウツリーがどのように再配置されるかに影響します（以下を参照）。</target>
        </trans-unit>
        <trans-unit id="451b00a18210e489817e33a2f75ab13a9719ab44" translate="yes" xml:space="preserve">
          <source>If, for instance, you have a function with the following signature:</source>
          <target state="translated">例えば、以下のようなシグネチャを持つ関数があるとします。</target>
        </trans-unit>
        <trans-unit id="2abf7c3ec223f2095009c55b2f242e5df196b064" translate="yes" xml:space="preserve">
          <source>If, in the configuration shown at the beginning of this section, the combination limit of &lt;var&gt;W4&lt;/var&gt; (the parent window of &lt;var&gt;W6&lt;/var&gt; and &lt;var&gt;W7&lt;/var&gt;) is &lt;code&gt;t&lt;/code&gt;, deleting &lt;var&gt;W5&lt;/var&gt; will not implicitly delete &lt;var&gt;W4&lt;/var&gt; too.</source>
          <target state="translated">このセクションの冒頭に示した構成で、 &lt;var&gt;W4&lt;/var&gt; （ &lt;var&gt;W6&lt;/var&gt; と &lt;var&gt;W7&lt;/var&gt; の親ウィンドウ）の組み合わせ制限が &lt;code&gt;t&lt;/code&gt; である場合、 &lt;var&gt;W5&lt;/var&gt; を削除しても &lt;var&gt;W4&lt;/var&gt; も暗黙的に削除されません。</target>
        </trans-unit>
        <trans-unit id="78ffec08f0afea5009a9e4f31e999a7aef7bb8b2" translate="yes" xml:space="preserve">
          <source>Illustrates regular expression syntax.</source>
          <target state="translated">正規表現の構文を説明します。</target>
        </trans-unit>
        <trans-unit id="6d6a2e3a1d75ffca319bbe002e550450309d7c59" translate="yes" xml:space="preserve">
          <source>Image Cache</source>
          <target state="translated">画像キャッシュ</target>
        </trans-unit>
        <trans-unit id="48b5c8b5116be341240880cddc06c139bf112214" translate="yes" xml:space="preserve">
          <source>Image Descriptors</source>
          <target state="translated">画像記述子</target>
        </trans-unit>
        <trans-unit id="c8f6654a5156a1080fb81d03686a08b3810bb836" translate="yes" xml:space="preserve">
          <source>Image Formats</source>
          <target state="translated">イメージフォーマット</target>
        </trans-unit>
        <trans-unit id="aeaae8093342d2fd0a43876f35175087f3fc1c56" translate="yes" xml:space="preserve">
          <source>Image rotation is supported by &lt;var&gt;frame&lt;/var&gt; if the rotation angle is an integral multiple of 90 degrees.</source>
          <target state="translated">回転角が90度の整数倍の場合、画像の回転は &lt;var&gt;frame&lt;/var&gt; によってサポートされます。</target>
        </trans-unit>
        <trans-unit id="22a44b07be718b7665f80244ca7dfeffb2cef34a" translate="yes" xml:space="preserve">
          <source>Image scaling is supported by &lt;var&gt;frame&lt;/var&gt; via the &lt;code&gt;:scale&lt;/code&gt;, &lt;code&gt;:width&lt;/code&gt;, &lt;code&gt;:height&lt;/code&gt;, &lt;code&gt;:max-width&lt;/code&gt;, and &lt;code&gt;:max-height&lt;/code&gt; properties.</source>
          <target state="translated">画像のスケーリングは、 &lt;code&gt;:scale&lt;/code&gt; 、 &lt;code&gt;:width&lt;/code&gt; 、 &lt;code&gt;:height&lt;/code&gt; 、 &lt;code&gt;:max-width&lt;/code&gt; 、および &lt;code&gt;:max-height&lt;/code&gt; プロパティを介して &lt;var&gt;frame&lt;/var&gt; でサポートされます。</target>
        </trans-unit>
        <trans-unit id="1d1d6e296cb1c073ca88d9a58e07068eb51b05b3" translate="yes" xml:space="preserve">
          <source>Image support on some platforms uses this facility. Here&amp;rsquo;s an example of setting this variable for supporting images on MS-Windows:</source>
          <target state="translated">一部のプラットフォームでのイメージサポートは、この機能を使用します。MS-Windowsで画像をサポートするためにこの変数を設定する例を次に示します。</target>
        </trans-unit>
        <trans-unit id="ba6aa59bf89de0d7431e45a8f58836f3a0d84eff" translate="yes" xml:space="preserve">
          <source>Image type &lt;code&gt;gif&lt;/code&gt;. Supports the &lt;code&gt;:index&lt;/code&gt; property. See &lt;a href=&quot;multi_002dframe-images#Multi_002dFrame-Images&quot;&gt;Multi-Frame Images&lt;/a&gt;.</source>
          <target state="translated">画像タイプ &lt;code&gt;gif&lt;/code&gt; 。 &lt;code&gt;:index&lt;/code&gt; プロパティをサポートします。&lt;a href=&quot;multi_002dframe-images#Multi_002dFrame-Images&quot;&gt;マルチフレーム画像を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="e6b807cfc6c4926cd04ef1e64755f11a7ed890ee" translate="yes" xml:space="preserve">
          <source>Image type &lt;code&gt;jpeg&lt;/code&gt;.</source>
          <target state="translated">画像タイプ &lt;code&gt;jpeg&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bff299fe7917d8e01d672a807ac7ad596bd1fa0a" translate="yes" xml:space="preserve">
          <source>Image type &lt;code&gt;png&lt;/code&gt;.</source>
          <target state="translated">画像タイプ &lt;code&gt;png&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6d259c4b3f9f796b005c99eb224c7f8328e811db" translate="yes" xml:space="preserve">
          <source>Image type &lt;code&gt;tiff&lt;/code&gt;. Supports the &lt;code&gt;:index&lt;/code&gt; property. See &lt;a href=&quot;multi_002dframe-images#Multi_002dFrame-Images&quot;&gt;Multi-Frame Images&lt;/a&gt;.</source>
          <target state="translated">画像タイプ &lt;code&gt;tiff&lt;/code&gt; 。 &lt;code&gt;:index&lt;/code&gt; プロパティをサポートします。&lt;a href=&quot;multi_002dframe-images#Multi_002dFrame-Images&quot;&gt;マルチフレーム画像を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="f82696e58684223314f34c1e138cf5a09eed1ec1" translate="yes" xml:space="preserve">
          <source>ImageMagick Images</source>
          <target state="translated">イメージマジックの画像</target>
        </trans-unit>
        <trans-unit id="09e871c98fef3b901a775def173e4126aaf73b42" translate="yes" xml:space="preserve">
          <source>Images</source>
          <target state="translated">Images</target>
        </trans-unit>
        <trans-unit id="b10522704faf5fb14671202d20d0113707920769" translate="yes" xml:space="preserve">
          <source>Images are automatically scaled when created based on the &lt;code&gt;image-scaling-factor&lt;/code&gt; variable. The value is either a floating point number (where numbers higher than 1 means to increase the size and lower means to shrink the size), or the symbol &lt;code&gt;auto&lt;/code&gt;, which will compute a scaling factor based on the font pixel size.</source>
          <target state="translated">&lt;code&gt;image-scaling-factor&lt;/code&gt; 変数に基づいて作成されると、画像は自動的にスケーリングされます。値は、浮動小数点数（1より大きい数値はサイズを大きくし、小さい数値はサイズを小さくすることを意味します）、またはフォントのピクセルサイズに基づいて倍率を計算する記号 &lt;code&gt;auto&lt;/code&gt; のいずれかです。</target>
        </trans-unit>
        <trans-unit id="bffbf50340be5bd8849e7bdae58afca1242ae52f" translate="yes" xml:space="preserve">
          <source>Images inserted with the insertion functions above also get a local keymap installed in the text properties (or overlays) that span the displayed image. This keymap defines the following commands:</source>
          <target state="translated">上記の挿入機能で挿入された画像は、表示された画像にまたがるテキストプロパティ(またはオーバーレイ)にインストールされたローカルキーマップも取得します。このキーマップは以下のコマンドを定義しています。</target>
        </trans-unit>
        <trans-unit id="2577d1937dba79f175ee8cc8dd563700f7a20a83" translate="yes" xml:space="preserve">
          <source>Images loaded with ImageMagick support the following additional image descriptor properties:</source>
          <target state="translated">ImageMagick で読み込まれた画像は、以下の追加の画像記述子プロパティをサポートしています。</target>
        </trans-unit>
        <trans-unit id="ae0df5967aaeb367560d887978e6697e8445e507" translate="yes" xml:space="preserve">
          <source>Images, margins, text size, etc.</source>
          <target state="translated">画像、余白、文字の大きさなど</target>
        </trans-unit>
        <trans-unit id="582d79238d4c996206b1d9fcda2bd858616fc5e0" translate="yes" xml:space="preserve">
          <source>Imenu</source>
          <target state="translated">Imenu</target>
        </trans-unit>
        <trans-unit id="9b3ebff6f4733ad352d5af8ef98a92252e56d9f9" translate="yes" xml:space="preserve">
          <source>Implementing a link involves three separate steps: (1) indicating clickability when the mouse moves over the link; (2) making</source>
          <target state="translated">リンクの実装には3つのステップがあります。(1)マウスがリンクの上を移動したときにクリック可能性を示すこと、(2)リンクの上に</target>
        </trans-unit>
        <trans-unit id="ba709de5d7a6443728b0e7d903b67e7e463a3df8" translate="yes" xml:space="preserve">
          <source>Implied Frame Resizing</source>
          <target state="translated">暗黙のフレームリサイズ</target>
        </trans-unit>
        <trans-unit id="6be920774eab706a9a6e9e109fe21af9fbbf76a5" translate="yes" xml:space="preserve">
          <source>Implied resizing of frames and how to prevent it.</source>
          <target state="translated">フレームの暗黙のリサイズとそれを防ぐ方法</target>
        </trans-unit>
        <trans-unit id="aef36502d67b0520654deb764dd055a7e905cfdd" translate="yes" xml:space="preserve">
          <source>In</source>
          <target state="translated">In</target>
        </trans-unit>
        <trans-unit id="8fe04c542be958393c3da42ee6384a7d0cac600e" translate="yes" xml:space="preserve">
          <source>In Adaptive Fill mode, this command calls &lt;code&gt;fill-context-prefix&lt;/code&gt; to choose a fill prefix by default. See &lt;a href=&quot;adaptive-fill#Adaptive-Fill&quot;&gt;Adaptive Fill&lt;/a&gt;.</source>
          <target state="translated">アダプティブフィルモードでは、このコマンドは &lt;code&gt;fill-context-prefix&lt;/code&gt; を呼び出して、デフォルトでフィルプレフィックスを選択します。&lt;a href=&quot;adaptive-fill#Adaptive-Fill&quot;&gt;アダプティブフィルを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="45a0c5d90449be73929ea5cf30f6e7c34dd2845f" translate="yes" xml:space="preserve">
          <source>In C the corresponding code uses &lt;code&gt;Fmake_variable_buffer_local&lt;/code&gt; in combination with &lt;code&gt;DEFSYM&lt;/code&gt;, i.e.</source>
          <target state="translated">Cに対応するコードが使用 &lt;code&gt;Fmake_variable_buffer_local&lt;/code&gt; をと組み合わせて &lt;code&gt;DEFSYM&lt;/code&gt; 、すなわち</target>
        </trans-unit>
        <trans-unit id="e18ad52ed484e26dd1d95b7bed4a6e310f733e51" translate="yes" xml:space="preserve">
          <source>In C, the tagged pointer is an object of type &lt;code&gt;Lisp_Object&lt;/code&gt;. Any initialized variable of such a type always holds the value of one of the following basic data types: integer, symbol, string, cons cell, float, or vectorlike object. Each of these data types has the corresponding tag value. All tags are enumerated by &lt;code&gt;enum Lisp_Type&lt;/code&gt; and placed into a 3-bit bitfield of the &lt;code&gt;Lisp_Object&lt;/code&gt;. The rest of the bits is the value itself. Integers are immediate, i.e., directly represented by those &lt;em&gt;value bits&lt;/em&gt;, and all other objects are represented by the C pointers to a corresponding object allocated from the heap. Width of the &lt;code&gt;Lisp_Object&lt;/code&gt; is platform- and configuration-dependent: usually it&amp;rsquo;s equal to the width of an underlying platform pointer (i.e., 32-bit on a 32-bit machine and 64-bit on a 64-bit one), but also there is a special configuration where &lt;code&gt;Lisp_Object&lt;/code&gt; is 64-bit but all pointers are 32-bit. The latter trick was designed to overcome the limited range of values for Lisp integers on a 32-bit system by using 64-bit &lt;code&gt;long long&lt;/code&gt; type for &lt;code&gt;Lisp_Object&lt;/code&gt;.</source>
          <target state="translated">Cでは、タグ付きポインタは &lt;code&gt;Lisp_Object&lt;/code&gt; 型のオブジェクトです。このようなタイプの初期化された変数は、常に次の基本データタイプのいずれかの値を保持します：整数、シンボル、文字列、consセル、float、またはvectorlikeオブジェクト。これらの各データ型には、対応するタグ値があります。すべてのタグは、によって列挙さ &lt;code&gt;enum Lisp_Type&lt;/code&gt; との3ビットのビットフィールドに入れ &lt;code&gt;Lisp_Object&lt;/code&gt; 。残りのビットは値そのものです。整数は即時です。つまり、これらの&lt;em&gt;値ビット&lt;/em&gt;によって直接表され、他のすべてのオブジェクトは、ヒープから割り当てられた対応するオブジェクトへのCポインタによって表されます。 &lt;code&gt;Lisp_Object&lt;/code&gt; の幅プラットフォームと構成に依存します。通常、基になるプラットフォームポインターの幅と同じです（つまり、32ビットマシンでは32ビット、64ビットマシンでは64ビット）が、特別な構成もあります。ここで、 &lt;code&gt;Lisp_Object&lt;/code&gt; は64ビットですが、すべてのポインターは32ビットです。後者のトリックは、 &lt;code&gt;Lisp_Object&lt;/code&gt; に64ビットの &lt;code&gt;long long&lt;/code&gt; 型を使用することにより、32ビットシステム上のLisp整数の限られた範囲の値を克服するように設計されました。</target>
        </trans-unit>
        <trans-unit id="74391ea991c057a25805bcc7f35913579f56dca9" translate="yes" xml:space="preserve">
          <source>In Emacs Lisp, &lt;code&gt;nil&lt;/code&gt; and &lt;code&gt;t&lt;/code&gt; are special symbols that always evaluate to themselves. This is so that you do not need to quote them to use them as constants in a program. An attempt to change their values results in a &lt;code&gt;setting-constant&lt;/code&gt; error. See &lt;a href=&quot;constant-variables#Constant-Variables&quot;&gt;Constant Variables&lt;/a&gt;.</source>
          <target state="translated">Emacs Lispでは、 &lt;code&gt;nil&lt;/code&gt; と &lt;code&gt;t&lt;/code&gt; は常に自分自身に評価される特別な記号です。これは、プログラムで定数として使用するために引用符で囲む必要がないようにするためです。それらの値を変更しようとすると、 &lt;code&gt;setting-constant&lt;/code&gt; エラーが発生します。&lt;a href=&quot;constant-variables#Constant-Variables&quot;&gt;定数変数を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="7ad4e15232bab0e5d73751f02a46989f735b0d79" translate="yes" xml:space="preserve">
          <source>In Emacs Lisp, an obarray is actually a vector. Each element of the vector is a bucket; its value is either an interned symbol whose name hashes to that bucket, or 0 if the bucket is empty. Each interned symbol has an internal link (invisible to the user) to the next symbol in the bucket. Because these links are invisible, there is no way to find all the symbols in an obarray except using &lt;code&gt;mapatoms&lt;/code&gt; (below). The order of symbols in a bucket is not significant.</source>
          <target state="translated">Emacs Lispでは、obarrayは実際にはベクトルです。ベクトルの各要素はバケットです。その値は、名前がそのバケットにハッシュされているインターンシンボル、またはバケットが空の場合は0のいずれかです。インターンされた各シンボルには、バケット内の次のシンボルへの内部リンク（ユーザーには表示されません）があります。これらのリンクは表示されないため、 &lt;code&gt;mapatoms&lt;/code&gt; （下記）を使用する以外に、obarray内のすべてのシンボルを見つける方法はありません。バケット内のシンボルの順序は重要ではありません。</target>
        </trans-unit>
        <trans-unit id="167a75f8cc60d70b238473b34e2d15e825f2b4a7" translate="yes" xml:space="preserve">
          <source>In Emacs Lisp, certain symbols normally evaluate to themselves. These include &lt;code&gt;nil&lt;/code&gt; and &lt;code&gt;t&lt;/code&gt;, as well as any symbol whose name starts with &amp;lsquo;</source>
          <target state="translated">Emacs Lispでは、特定のシンボルは通常それ自体に評価されます。これらには、 &lt;code&gt;nil&lt;/code&gt; と &lt;code&gt;t&lt;/code&gt; 、および名前が 'で始まる任意の記号が含まれます。</target>
        </trans-unit>
        <trans-unit id="d3d82148ca2384cc8ee1ed3664e9a838b9558bde" translate="yes" xml:space="preserve">
          <source>In Emacs Lisp, fonts are represented using three different Lisp object types: &lt;em&gt;font objects&lt;/em&gt;, &lt;em&gt;font specs&lt;/em&gt;, and &lt;em&gt;font entities&lt;/em&gt;.</source>
          <target state="translated">Emacs Lispでは、フォントは3つの異なるLispオブジェクトタイプ（&lt;em&gt;フォントオブジェクト&lt;/em&gt;、&lt;em&gt;フォント仕様&lt;/em&gt;、&lt;em&gt;フォントエンティティ）&lt;/em&gt;を使用して表されます。</target>
        </trans-unit>
        <trans-unit id="ce0c7667a4c5fb417ea75b3519174ba5e3b8596c" translate="yes" xml:space="preserve">
          <source>In Emacs Lisp, if two fixnums are numerically equal, they are the same Lisp object. That is, &lt;code&gt;eq&lt;/code&gt; is equivalent to &lt;code&gt;=&lt;/code&gt; on fixnums. It is sometimes convenient to use &lt;code&gt;eq&lt;/code&gt; for comparing an unknown value with a fixnum, because &lt;code&gt;eq&lt;/code&gt; does not report an error if the unknown value is not a number&amp;mdash;it accepts arguments of any type. By contrast, &lt;code&gt;=&lt;/code&gt; signals an error if the arguments are not numbers or markers. However, it is better programming practice to use &lt;code&gt;=&lt;/code&gt; if you can, even for comparing integers.</source>
          <target state="translated">Emacs Lispでは、2つのfixnumが数値的に等しい場合、それらは同じLispオブジェクトです。つまり、 &lt;code&gt;eq&lt;/code&gt; はfixnumsの &lt;code&gt;=&lt;/code&gt; と同等です。不明な値が数値でない場合、 &lt;code&gt;eq&lt;/code&gt; はエラーを報告せず、任意のタイプの引数を受け入れるため、不明な値をfixnumと比較するために &lt;code&gt;eq&lt;/code&gt; を使用すると便利な場合があります。対照的に、引数が数値またはマーカーでない場合、 &lt;code&gt;=&lt;/code&gt; はエラーを示します。ただし、可能であれば、整数を比較する場合でも、 &lt;code&gt;=&lt;/code&gt; を使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="056b909cc3695df5e93a61166399585cdef0425e" translate="yes" xml:space="preserve">
          <source>In Emacs Lisp, it is &lt;em&gt;not&lt;/em&gt; an error if an element of an association list is not a cons cell. The alist search functions simply ignore such elements. Many other versions of Lisp signal errors in such cases.</source>
          <target state="translated">Emacs Lispの、それは&lt;em&gt;ない&lt;/em&gt;連想リストの要素がコンス・セルでない場合、エラー。alist検索関数は、そのような要素を単に無視します。このような場合、他の多くのバージョンのLisp信号エラーが発生します。</target>
        </trans-unit>
        <trans-unit id="0ba583440567b18d5b81ae15d30046dcd5919135" translate="yes" xml:space="preserve">
          <source>In Emacs Lisp, such a list is a valid expression which evaluates to a function object.</source>
          <target state="translated">Emacs Lispでは、このようなリストは関数オブジェクトに評価される有効な式です。</target>
        </trans-unit>
        <trans-unit id="79e9cb90d8f1ed44a5daae3726bf1118952bd6eb" translate="yes" xml:space="preserve">
          <source>In Emacs Lisp, text characters are represented by integers. Any integer between zero and the value of &lt;code&gt;(max-char)&lt;/code&gt;, inclusive, is considered to be valid as a character. See &lt;a href=&quot;character-codes#Character-Codes&quot;&gt;Character Codes&lt;/a&gt;.</source>
          <target state="translated">Emacs Lispでは、テキスト文字は整数で表されます。ゼロから &lt;code&gt;(max-char)&lt;/code&gt; の値までの整数は、文字として有効であると見なされます。&lt;a href=&quot;character-codes#Character-Codes&quot;&gt;文字コードを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="dc557095ff4ddb838d7231fc59eb5902f756d5f5" translate="yes" xml:space="preserve">
          <source>In Emacs Lisp, the symbol &lt;code&gt;nil&lt;/code&gt; has three separate meanings: it is a symbol with the name &amp;lsquo;</source>
          <target state="translated">Emacs Lispでは、記号 &lt;code&gt;nil&lt;/code&gt; には3つの異なる意味があります。それは 'という名前の記号です。</target>
        </trans-unit>
        <trans-unit id="4bdd0ad62ddb48a82f579e9d7b8435a64c33dc3b" translate="yes" xml:space="preserve">
          <source>In Emacs&amp;rsquo;s current implementation, each graphical terminal possesses an image cache, which is shared by all the frames on that terminal (see &lt;a href=&quot;multiple-terminals#Multiple-Terminals&quot;&gt;Multiple Terminals&lt;/a&gt;). Thus, refreshing an image in one frame also refreshes it in all other frames on the same terminal.</source>
          <target state="translated">Emacsの現在の実装では、各グラフィカル端末は画像キャッシュを所有しており、その端末上のすべてのフレームで共有されます（&lt;a href=&quot;multiple-terminals#Multiple-Terminals&quot;&gt;複数の端末を&lt;/a&gt;参照）。したがって、1つのフレームで画像を更新すると、同じ端末上の他のすべてのフレームでも画像が更新されます。</target>
        </trans-unit>
        <trans-unit id="2cfd6914c188d4937ed552a12d7ad4fd0e04dbfb" translate="yes" xml:space="preserve">
          <source>In Emacs, each property has a name, which is a symbol, and a set of possible values, whose types depend on the property; if a character does not have a certain property, the value is &lt;code&gt;nil&lt;/code&gt;. As a general rule, the names of character properties in Emacs are produced from the corresponding Unicode properties by downcasing them and replacing each &amp;lsquo;</source>
          <target state="translated">Emacsでは、各プロパティにはシンボルである名前と可能な値のセットがあり、そのタイプはプロパティによって異なります。文字に特定のプロパティがない場合、値は &lt;code&gt;nil&lt;/code&gt; です。原則として、Emacsの文字プロパティの名前は、対応するUnicodeプロパティから、それらをダウンケースし、それぞれを置き換えることによって生成されます。</target>
        </trans-unit>
        <trans-unit id="30d7d9e3884c83ac05ed06549fc0bda540ce471f" translate="yes" xml:space="preserve">
          <source>In Emacs, processing user input takes priority over redisplay. If you call these functions when input is available, they don&amp;rsquo;t redisplay immediately, but the requested redisplay does happen eventually&amp;mdash;after all the input has been processed.</source>
          <target state="translated">Emacsでは、ユーザー入力の処理が再表示よりも優先されます。入力が利用可能なときにこれらの関数を呼び出すと、すぐには再表示されませんが、すべての入力が処理された後、要求された再表示は最終的に行われます。</target>
        </trans-unit>
        <trans-unit id="495b0af8742c1362f3b43e3c05d5f67cbd311b61" translate="yes" xml:space="preserve">
          <source>In GNU Emacs, you can search for the next match for a regular expression (see &lt;a href=&quot;syntax-of-regexps#Syntax-of-Regexps&quot;&gt;Syntax of Regexps&lt;/a&gt;) either incrementally or not. For incremental search commands, see &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Regexp-Search.html#Regexp-Search&quot;&gt;Regular Expression Search&lt;/a&gt; in</source>
          <target state="translated">GNU Emacsでは、正規表現の次の一致を検索することができます（&lt;a href=&quot;syntax-of-regexps#Syntax-of-Regexps&quot;&gt;Regexpsの構文を参照&lt;/a&gt;）。インクリメンタルサーチコマンドについては、の&lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Regexp-Search.html#Regexp-Search&quot;&gt;正規表現検索&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="bb6bf702e875e738b66a4d81962fcc97a8fc8a9b" translate="yes" xml:space="preserve">
          <source>In Lisp symbols sometimes need to be quoted, to achieve the same effect in C you again use the corresponding constant symbol &lt;code&gt;Qmy_lisp_variable&lt;/code&gt;. For example, when creating a buffer-local variable (see &lt;a href=&quot;buffer_002dlocal-variables#Buffer_002dLocal-Variables&quot;&gt;Buffer-Local Variables&lt;/a&gt;) in Lisp you would write:</source>
          <target state="translated">Lispシンボルでは、引用符で &lt;code&gt;Qmy_lisp_variable&lt;/code&gt; 必要がある場合があります。Cで同じ効果を得るには、対応する定数シンボルQmy_lisp_variableを再度使用します。たとえば、Lispで&lt;a href=&quot;buffer_002dlocal-variables#Buffer_002dLocal-Variables&quot;&gt;バッファ&lt;/a&gt;ローカル変数（バッファローカル変数を参照）を作成する場合、次のように記述します。</target>
        </trans-unit>
        <trans-unit id="1a54f569b2a1104466db435e6a994296e8a10203" translate="yes" xml:space="preserve">
          <source>In POSIX, locales control which language to use in language-related features. These Emacs variables control how Emacs interacts with these features.</source>
          <target state="translated">POSIX では、ロケールは言語関連の機能でどの言語を使用するかを制御します。これらの Emacs 変数は、Emacs がこれらの機能とどのように相互作用するかを制御します。</target>
        </trans-unit>
        <trans-unit id="cb60a2c08b3d7d91de1154d61b87b4cbb7d768d9" translate="yes" xml:space="preserve">
          <source>In a Lisp program, if you want to look at the contents of a file but not alter it, the fastest way is to use &lt;code&gt;insert-file-contents&lt;/code&gt; in a temporary buffer. Visiting the file is not necessary and takes longer. See &lt;a href=&quot;reading-from-files#Reading-from-Files&quot;&gt;Reading from Files&lt;/a&gt;.</source>
          <target state="translated">Lispプログラムでは、ファイルの内容を確認したいが変更したくない場合、最も速い方法は一時バッファーで &lt;code&gt;insert-file-contents&lt;/code&gt; を使用することです。ファイルにアクセスする必要はなく、時間がかかります。&lt;a href=&quot;reading-from-files#Reading-from-Files&quot;&gt;ファイルからの読み取りを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="1edf8916db656c7d77716fc20e2c864d77eff0a1" translate="yes" xml:space="preserve">
          <source>In a backtrace you can specify a stack frame by moving point to a line describing that frame. The frame whose line point is on is considered the &lt;em&gt;current frame&lt;/em&gt;.</source>
          <target state="translated">バックトレースでは、そのフレームを説明する線にポイントを移動することで、スタックフレームを指定できます。ラインポイントがオンになっている&lt;em&gt;フレーム&lt;/em&gt;は、&lt;em&gt;現在のフレーム&lt;/em&gt;と見なされます。</target>
        </trans-unit>
        <trans-unit id="d321617bc2957edda9f7299aaed744d6b62dfa9f" translate="yes" xml:space="preserve">
          <source>In a buffer, the buffer-local value of the variable &lt;code&gt;enable-multibyte-characters&lt;/code&gt; specifies the representation used. The representation for a string is determined and recorded in the string when the string is constructed.</source>
          <target state="translated">バッファーでは、変数 &lt;code&gt;enable-multibyte-characters&lt;/code&gt; のbuffer-local値は、使用される表現を指定します。文字列の表現は、文字列が作成されるときに決定され、文字列に記録されます。</target>
        </trans-unit>
        <trans-unit id="d5b3c2f60eb9de03c344c19458f75ded0f988032" translate="yes" xml:space="preserve">
          <source>In a computer, an integer is represented as a binary number, a sequence of &lt;em&gt;bits&lt;/em&gt; (digits which are either zero or one). Conceptually the bit sequence is infinite on the left, with the most-significant bits being all zeros or all ones. A bitwise operation acts on the individual bits of such a sequence. For example, &lt;em&gt;shifting&lt;/em&gt; moves the whole sequence left or right one or more places, reproducing the same pattern moved over.</source>
          <target state="translated">コンピューターでは、整数は2進数、&lt;em&gt;ビットの&lt;/em&gt;シーケンス（0または1のいずれかである数字）として表されます。概念的には、ビットシーケンスは左側で無限であり、最も重要なビットはすべて0またはすべて1です。ビット単位の演算は、そのようなシーケンスの個々のビットに作用します。たとえば、&lt;em&gt;シフト&lt;/em&gt;すると、シーケンス全体が1つ以上の場所で左または右に移動し、移動した同じパターンが再現されます。</target>
        </trans-unit>
        <trans-unit id="fb58dc1bd5b5a462384b2bd580dc601ea418376c" translate="yes" xml:space="preserve">
          <source>In a connection, the address in internal format of the remote peer.</source>
          <target state="translated">接続では、リモートピアの内部フォーマットのアドレス。</target>
        </trans-unit>
        <trans-unit id="937afbfd1c954fb42bb11db790d91eaf0406154d" translate="yes" xml:space="preserve">
          <source>In a customization of &lt;code&gt;display-buffer-alist&lt;/code&gt; it would be used as follows:</source>
          <target state="translated">&lt;code&gt;display-buffer-alist&lt;/code&gt; のカスタマイズでは、次のように使用されます。</target>
        </trans-unit>
        <trans-unit id="02df984c3529f76c9a4015001b01d209da05e6aa" translate="yes" xml:space="preserve">
          <source>In a function definition (a &lt;code&gt;lambda&lt;/code&gt; or &lt;code&gt;defun&lt;/code&gt; form), the documentation string is specified after the argument list, and is normally stored directly in the function object. See &lt;a href=&quot;function-documentation#Function-Documentation&quot;&gt;Function Documentation&lt;/a&gt;. You can also put function documentation in the &lt;code&gt;function-documentation&lt;/code&gt; property of a function name (see &lt;a href=&quot;accessing-documentation#Accessing-Documentation&quot;&gt;Accessing Documentation&lt;/a&gt;).</source>
          <target state="translated">関数定義（ &lt;code&gt;lambda&lt;/code&gt; 形式または &lt;code&gt;defun&lt;/code&gt; 形式）では、ドキュメント文字列は引数リストの後に指定され、通常は関数オブジェクトに直接格納されます。&lt;a href=&quot;function-documentation#Function-Documentation&quot;&gt;関数のドキュメントを&lt;/a&gt;参照してください。関数名の &lt;code&gt;function-documentation&lt;/code&gt; プロパティに関数ドキュメントを配置することもできます（&lt;a href=&quot;accessing-documentation#Accessing-Documentation&quot;&gt;ドキュメントへのアクセスを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="9eea6a2ed4dafd38340b45092920794b871b7be2" translate="yes" xml:space="preserve">
          <source>In a function description, the name of the function being described appears first. It is followed on the same line by a list of argument names. These names are also used in the body of the description, to stand for the values of the arguments.</source>
          <target state="translated">関数の説明では、説明されている関数の名前が最初に現れます。その後、同じ行に引数名のリストが続きます。これらの名前は、引数の値を表すために記述の本文でも使用されます。</target>
        </trans-unit>
        <trans-unit id="f265fc98d3924e1abaf704d23613cfbac37962c6" translate="yes" xml:space="preserve">
          <source>In a general sense, a function is a rule for carrying out a computation given input values called &lt;em&gt;arguments&lt;/em&gt;. The result of the computation is called the &lt;em&gt;value&lt;/em&gt; or &lt;em&gt;return value&lt;/em&gt; of the function. The computation can also have side effects, such as lasting changes in the values of variables or the contents of data structures (see &lt;a href=&quot;intro-eval#Definition-of-side-effect&quot;&gt;Definition of side effect&lt;/a&gt;). A &lt;em&gt;pure function&lt;/em&gt; is a function which, in addition to having no side effects, always returns the same value for the same combination of arguments, regardless of external factors such as machine type or system state.</source>
          <target state="translated">一般的な意味で、関数は&lt;em&gt;引数&lt;/em&gt;と呼ばれる入力値を指定して計算を実行するためのルールです。計算の結果は、関数の&lt;em&gt;値&lt;/em&gt;または&lt;em&gt;戻り値&lt;/em&gt;と呼ばれます。計算には、変数の値やデータ構造の内容の永続的な変更などの副作用もあります（副作用の&lt;a href=&quot;intro-eval#Definition-of-side-effect&quot;&gt;定義を&lt;/a&gt;参照）。&lt;em&gt;純粋関数は&lt;/em&gt;副作用を持たないことに加えて、常に関係なく、そのような機種やシステム状態などの外部要因の、引数の同じ組み合わせに対して同じ値を返す関数です。</target>
        </trans-unit>
        <trans-unit id="96c3f228f301c5161e3eb0673e109763dc8f02e1" translate="yes" xml:space="preserve">
          <source>In a major mode for editing some kind of structured text, such as a programming language, indentation of text according to structure is probably useful. So the mode should set &lt;code&gt;indent-line-function&lt;/code&gt; to a suitable function, and probably customize other variables for indentation. See &lt;a href=&quot;auto_002dindentation#Auto_002dIndentation&quot;&gt;Auto-Indentation&lt;/a&gt;.</source>
          <target state="translated">プログラミング言語など、ある種の構造化テキストを編集するためのメジャーモードでは、構造に応じたテキストのインデントがおそらく役立ちます。したがって、モードは &lt;code&gt;indent-line-function&lt;/code&gt; を適切な関数に設定し、おそらく他の変数をインデント用にカスタマイズする必要があります。&lt;a href=&quot;auto_002dindentation#Auto_002dIndentation&quot;&gt;自動インデントを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="1010cadba3e3eb9ca7bca39cbf0064b7fa6a1d87" translate="yes" xml:space="preserve">
          <source>In a package that can be preloaded, it is sometimes necessary (or useful) to delay certain evaluations until Emacs subsequently starts up. The vast majority of such cases relate to the values of customizable variables. For example, &lt;code&gt;tutorial-directory&lt;/code&gt; is a variable defined in</source>
          <target state="translated">プリロード可能なパッケージでは、Emacsがその後起動するまで、特定の評価を遅らせる必要がある（または役立つ）場合があります。このような場合の大部分は、カスタマイズ可能な変数の値に関連しています。たとえば、 &lt;code&gt;tutorial-directory&lt;/code&gt; はで定義された変数です。</target>
        </trans-unit>
        <trans-unit id="0c9ab0563187085f470a4162ca64c920ef8f3780" translate="yes" xml:space="preserve">
          <source>In a server, if you specified &lt;code&gt;t&lt;/code&gt; for &lt;var&gt;service&lt;/var&gt;, this value is the actual port number.</source>
          <target state="translated">サーバーでは、 &lt;var&gt;service&lt;/var&gt; に &lt;code&gt;t&lt;/code&gt; を指定した場合、この値は実際のポート番号です。</target>
        </trans-unit>
        <trans-unit id="38330f228367727c246a23aacc922e71762f491b" translate="yes" xml:space="preserve">
          <source>In a string, the 2**7 bit attached to an</source>
          <target state="translated">文字列では、2**7ビットが</target>
        </trans-unit>
        <trans-unit id="cb764f5b1cd69acb27303028c22d0c8d6831d1ea" translate="yes" xml:space="preserve">
          <source>In a variable definition (a &lt;code&gt;defvar&lt;/code&gt; form), the documentation string is specified after the initial value. See &lt;a href=&quot;defining-variables#Defining-Variables&quot;&gt;Defining Variables&lt;/a&gt;. The string is stored in the variable&amp;rsquo;s &lt;code&gt;variable-documentation&lt;/code&gt; property.</source>
          <target state="translated">変数定義（ &lt;code&gt;defvar&lt;/code&gt; 形式）では、ドキュメント文字列は初期値の後に指定されます。&lt;a href=&quot;defining-variables#Defining-Variables&quot;&gt;変数の定義を&lt;/a&gt;参照してください。文字列は、変数の &lt;code&gt;variable-documentation&lt;/code&gt; プロパティに格納されます。</target>
        </trans-unit>
        <trans-unit id="529ec901908473f00f0f48571f9c0e29f851ad5f" translate="yes" xml:space="preserve">
          <source>In addition an optional &lt;var&gt;coding-system&lt;/var&gt; can be specified if needed.</source>
          <target state="translated">さらに、必要に応じてオプションの &lt;var&gt;coding-system&lt;/var&gt; を指定できます。</target>
        </trans-unit>
        <trans-unit id="525f83380ee1265a6947c7040c2a3e7d21c25884" translate="yes" xml:space="preserve">
          <source>In addition to accessing and manipulating processes that are subprocesses of the current Emacs session, Emacs Lisp programs can also access other processes running on the same machine. We call these &lt;em&gt;system processes&lt;/em&gt;, to distinguish them from Emacs subprocesses.</source>
          <target state="translated">現在のEmacsセッションのサブプロセスであるプロセスへのアクセスと操作に加えて、EmacsLispプログラムは同じマシンで実行されている他のプロセスにもアクセスできます。これらをEmacsサブプロセスと区別するために、これらの&lt;em&gt;システムプロセス&lt;/em&gt;と呼びます。</target>
        </trans-unit>
        <trans-unit id="7bdb7f13163d532b7e614f0668a6458aa5f29adb" translate="yes" xml:space="preserve">
          <source>In addition to its parents, the error symbol has a &lt;var&gt;message&lt;/var&gt; which is a string to be printed when that error is signaled but not handled. If that message is not valid, the error message &amp;lsquo;</source>
          <target state="translated">その親に加えて、エラーシンボルには、そのエラーが通知されたが処理されなかったときに出力される文字列である &lt;var&gt;message&lt;/var&gt; があります。そのメッセージが無効な場合、エラーメッセージ '</target>
        </trans-unit>
        <trans-unit id="c353f4ffe1e4f69045cda4cc05340d97bd69840b" translate="yes" xml:space="preserve">
          <source>In addition to operating on files themselves, Emacs Lisp programs often need to operate on file names; i.e., to take them apart and to use part of a name to construct related file names. This section describes how to manipulate file names.</source>
          <target state="translated">Emacs Lisp プログラムは、ファイル自体を操作するだけでなく、ファイル名を操作する必要があることが多 くあります。つまり、ファイルを分解したり、名前の一部を使って関連するファイル名を構築したりする必要があります。このセクションでは、ファイル名を操作する方法について説明します。</target>
        </trans-unit>
        <trans-unit id="387b3f59848f82250f4a8ce567df30121ef1d27b" translate="yes" xml:space="preserve">
          <source>In addition to processes that run programs, Lisp programs can open connections of several types to devices or processes running on the same machine or on other machines. The supported connection types are: TCP and UDP network connections, serial port connections, and pipe connections. Each such connection is also represented by a process object.</source>
          <target state="translated">プログラムを実行するプロセスに加えて、Lisp プログラムは、同じマシンや他のマシン上で実行されているデバイスやプロセスに対して、いくつかのタイプの接続を開くことができます。サポートされている接続タイプは以下の通りです。TCP および UDP ネットワーク接続、シリアルポート接続、パイプ接続です。このような接続は、それぞれプロセスオブジェクトで表現されます。</target>
        </trans-unit>
        <trans-unit id="3c5b86e3b4354c4c1fa9c08ccbf5b49528a15320" translate="yes" xml:space="preserve">
          <source>In addition to specifying a single codepoint, &lt;var&gt;character&lt;/var&gt; may be a cons &lt;code&gt;(&lt;var&gt;from&lt;/var&gt; . &lt;var&gt;to&lt;/var&gt;)&lt;/code&gt;, where &lt;var&gt;from&lt;/var&gt; and &lt;var&gt;to&lt;/var&gt; are character codepoints. In that case, use &lt;var&gt;font-spec&lt;/var&gt; for all the characters in the range &lt;var&gt;from&lt;/var&gt; and &lt;var&gt;to&lt;/var&gt; (inclusive).</source>
          <target state="translated">単一のコードポイントを指定することに加えて、 &lt;var&gt;character&lt;/var&gt; 短所であってもよい &lt;code&gt;(&lt;var&gt;from&lt;/var&gt; . &lt;var&gt;to&lt;/var&gt;)&lt;/code&gt; 、 &lt;var&gt;from&lt;/var&gt; と &lt;var&gt;to&lt;/var&gt; 文字コードポイントです。その場合、使用 &lt;var&gt;font-spec&lt;/var&gt; 範囲内のすべての文字に対して &lt;var&gt;from&lt;/var&gt; と &lt;var&gt;to&lt;/var&gt; （を含みます）。</target>
        </trans-unit>
        <trans-unit id="41d3cfcccd9ef5616b8769d3619cf8d518b74e63" translate="yes" xml:space="preserve">
          <source>In addition to subprocesses of the current Emacs session, you can also access other processes running on your machine. See &lt;a href=&quot;system-processes#System-Processes&quot;&gt;System Processes&lt;/a&gt;.</source>
          <target state="translated">現在のEmacsセッションのサブプロセスに加えて、マシンで実行されている他のプロセスにアクセスすることもできます。&lt;a href=&quot;system-processes#System-Processes&quot;&gt;システムプロセスを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="a7064fdb6b5bca7cd74df3a9cfd9570247d7d390" translate="yes" xml:space="preserve">
          <source>In addition to the above, 24 additional compositions of &lt;code&gt;car&lt;/code&gt; and &lt;code&gt;cdr&lt;/code&gt; are defined as &lt;code&gt;c&lt;var&gt;xxx&lt;/var&gt;r&lt;/code&gt; and &lt;code&gt;c&lt;var&gt;xxxx&lt;/var&gt;r&lt;/code&gt;, where each &lt;code&gt;&lt;var&gt;x&lt;/var&gt;&lt;/code&gt; is either &lt;code&gt;a&lt;/code&gt; or &lt;code&gt;d&lt;/code&gt;. &lt;code&gt;cadr&lt;/code&gt;, &lt;code&gt;caddr&lt;/code&gt;, and &lt;code&gt;cadddr&lt;/code&gt; pick out the second, third or fourth elements of a list, respectively.</source>
          <target state="translated">上記の、24件の追加の組成物に加えて、 &lt;code&gt;car&lt;/code&gt; と &lt;code&gt;cdr&lt;/code&gt; として定義されている &lt;code&gt;c&lt;var&gt;xxx&lt;/var&gt;r&lt;/code&gt; 及び &lt;code&gt;c&lt;var&gt;xxxx&lt;/var&gt;r&lt;/code&gt; それぞれ、 &lt;code&gt;&lt;var&gt;x&lt;/var&gt;&lt;/code&gt; いずれかであるか、 &lt;code&gt;d&lt;/code&gt; 。 &lt;code&gt;cadr&lt;/code&gt; 、 &lt;code&gt;caddr&lt;/code&gt; 、および &lt;code&gt;cadddr&lt;/code&gt; は、それぞれリストの2番目、3番目、または4番目の要素を選択します。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5ea747ccb6525f229be3767e03769ebe3fd13bdb" translate="yes" xml:space="preserve">
          <source>In addition to the classes, entries for characters in a syntax table can specify flags. There are eight possible flags, represented by the characters &amp;lsquo;</source>
          <target state="translated">クラスに加えて、構文テーブルの文字のエントリでフラグを指定できます。文字で表される8つの可能なフラグがあります '</target>
        </trans-unit>
        <trans-unit id="fa8b8b78067e8a2d0074c7fc569ed6a4aef4b677" translate="yes" xml:space="preserve">
          <source>In addition to the common keywords (see &lt;a href=&quot;common-keywords#Common-Keywords&quot;&gt;Common Keywords&lt;/a&gt;), you can also use this keyword in &lt;code&gt;defgroup&lt;/code&gt;:</source>
          <target state="translated">共通のキーワード（参照に加えて、&lt;a href=&quot;common-keywords#Common-Keywords&quot;&gt;共通のキーワードを&lt;/a&gt;）、あなたはまた、このキーワードを使用することができます &lt;code&gt;defgroup&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="29283b097ca518b11209ca1cc5e62af08088092e" translate="yes" xml:space="preserve">
          <source>In addition to the fundamental buffer list just described, Emacs maintains a local buffer list for each frame, in which the buffers that have been displayed (or had their windows selected) in that frame come first. (This order is recorded in the frame&amp;rsquo;s &lt;code&gt;buffer-list&lt;/code&gt; frame parameter; see &lt;a href=&quot;buffer-parameters#Buffer-Parameters&quot;&gt;Buffer Parameters&lt;/a&gt;.) Buffers never displayed in that frame come afterward, ordered according to the fundamental buffer list.</source>
          <target state="translated">今説明した基本的なバッファリストに加えて、Emacsは各フレームのローカルバッファリストを維持します。このリストでは、そのフレームで表示された（またはウィンドウが選択された）バッファが最初に表示されます。（この順序は、フレームの &lt;code&gt;buffer-list&lt;/code&gt; フレームパラメーターに記録されます。&lt;a href=&quot;buffer-parameters#Buffer-Parameters&quot;&gt;バッファーパラメーターを&lt;/a&gt;参照してください。）そのフレームに表示されないバッファーは、基本バッファーリストに従って順序付けられて後で表示されます。</target>
        </trans-unit>
        <trans-unit id="70589b40fe71188d55af613ff5caa55411dd7c27" translate="yes" xml:space="preserve">
          <source>In addition to the keywords listed in &lt;a href=&quot;common-keywords#Common-Keywords&quot;&gt;Common Keywords&lt;/a&gt;, this macro accepts the following keywords:</source>
          <target state="translated">&lt;a href=&quot;common-keywords#Common-Keywords&quot;&gt;一般的なキーワード&lt;/a&gt;にリストされているキーワードに加えて、このマクロは次のキーワードを受け入れます。</target>
        </trans-unit>
        <trans-unit id="14751632f3fa92d651d6de24660d939a484e328f" translate="yes" xml:space="preserve">
          <source>In addition to the mark, each buffer has a &lt;em&gt;mark ring&lt;/em&gt; which is a list of markers containing previous values of the mark. When editing commands change the mark, they should normally save the old value of the mark on the mark ring. The variable &lt;code&gt;mark-ring-max&lt;/code&gt; specifies the maximum number of entries in the mark ring; once the list becomes this long, adding a new element deletes the last element.</source>
          <target state="translated">マークに加えて、各バッファには、&lt;em&gt;マークの&lt;/em&gt;以前の値を含むマーカーのリストである&lt;em&gt;マークリングが&lt;/em&gt;あります。コマンドを編集してマークを変更する場合、通常はマークの古い値をマークリングに保存する必要があります。変数 &lt;code&gt;mark-ring-max&lt;/code&gt; は、マークリングのエントリの最大数を指定します。リストがこれほど長くなると、新しい要素を追加すると最後の要素が削除されます。</target>
        </trans-unit>
        <trans-unit id="c174d1d04f5ead445f6e0ecd4196859599f8b7e5" translate="yes" xml:space="preserve">
          <source>In addition to the specific escape sequences for special important control characters, Emacs provides several types of escape syntax that you can use to specify non-</source>
          <target state="translated">特別に重要な制御文字のための特定のエスケープシーケンスに加えて、Emacs にはいくつかのタイプのエスケープ構文が用意されています。</target>
        </trans-unit>
        <trans-unit id="806eb0827f5ad53c91dfa2917aa1276e03487d08" translate="yes" xml:space="preserve">
          <source>In addition to the stack, byte-code functions can use, bind, and set ordinary Lisp variables, by transferring values between variables and the stack.</source>
          <target state="translated">スタックに加えて、バイトコード関数は、変数とスタックの間で値を転送することで、通常のLisp変数を使用したり、バインドしたり、設定したりすることができます。</target>
        </trans-unit>
        <trans-unit id="e8fb33822f9f0ddadebc4c17ae82c36a969b63dc" translate="yes" xml:space="preserve">
          <source>In addition to the usual &lt;code&gt;rx&lt;/code&gt; syntax, &lt;var&gt;rx-expr&lt;/var&gt;&amp;hellip; can contain the following constructs:</source>
          <target state="translated">通常の &lt;code&gt;rx&lt;/code&gt; 構文に加えて、 &lt;var&gt;rx-expr&lt;/var&gt; &amp;hellip;には次の構成を含めることができます。</target>
        </trans-unit>
        <trans-unit id="861619441bdc3073f9cfaef71fbacdcaa751184b" translate="yes" xml:space="preserve">
          <source>In addition, Emacs defines the following common mathematical constants:</source>
          <target state="translated">また、Emacsでは、以下のような共通の数学定数が定義されています。</target>
        </trans-unit>
        <trans-unit id="a618d5cb4304df670c9f4fb6aed2d8570eaa1d4d" translate="yes" xml:space="preserve">
          <source>In addition, a module can verify the compatibility of the module</source>
          <target state="translated">さらに、モジュールは、モジュールの互換性を検証することができる</target>
        </trans-unit>
        <trans-unit id="6138054406fb00c76442b8e0e427c64e19964717" translate="yes" xml:space="preserve">
          <source>In addition, certain &lt;em&gt;magic&lt;/em&gt; file names are handled specially. For example, when a remote file name is specified, Emacs accesses the file over the network via an appropriate protocol. See &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Remote-Files.html#Remote-Files&quot;&gt;Remote Files&lt;/a&gt; in</source>
          <target state="translated">さらに、特定の&lt;em&gt;マジック&lt;/em&gt;ファイル名は特別に処理されます。たとえば、リモートファイル名が指定されている場合、Emacsは適切なプロトコルを介してネットワーク経由でファイルにアクセスします。の&lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Remote-Files.html#Remote-Files&quot;&gt;リモートファイル&lt;/a&gt;を参照してください</target>
        </trans-unit>
        <trans-unit id="e8a5c4503f8397d7e06f3cb0730d58989841f459" translate="yes" xml:space="preserve">
          <source>In addition, each window maintains a list of &lt;em&gt;next buffers&lt;/em&gt;, which is a list of buffers re-shown by &lt;code&gt;switch-to-prev-buffer&lt;/code&gt; (see below). This list is mainly used by &lt;code&gt;switch-to-prev-buffer&lt;/code&gt; and &lt;code&gt;switch-to-next-buffer&lt;/code&gt; for choosing buffers to switch to.</source>
          <target state="translated">さらに、各ウィンドウには&lt;em&gt;次のバッファの&lt;/em&gt;リストが保持され&lt;em&gt;ます&lt;/em&gt;。これは、 &lt;code&gt;switch-to-prev-buffer&lt;/code&gt; によって再表示されるバッファのリストです（以下を参照）。このリストは主に、 &lt;code&gt;switch-to-prev-buffer&lt;/code&gt; &lt;code&gt;switch-to-next-buffer&lt;/code&gt; を選択するために、switch-to-prev-bufferおよびswitch-to-next-bufferによって使用されます。</target>
        </trans-unit>
        <trans-unit id="40fe5e071e4d8814ba46d10ce4d3d2ba5eb89d1b" translate="yes" xml:space="preserve">
          <source>In addition, it doesn&amp;rsquo;t alter a line if &lt;var&gt;nochange-regexp&lt;/var&gt; matches at the beginning of the line (if &lt;var&gt;nochange-regexp&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;).</source>
          <target state="translated">さらに、行の先頭で &lt;var&gt;nochange-regexp&lt;/var&gt; が一致する場合（ &lt;var&gt;nochange-regexp&lt;/var&gt; が &lt;code&gt;nil&lt;/code&gt; 以外の場合）、行は変更されません。</target>
        </trans-unit>
        <trans-unit id="634b56dedb74cfcfcc2b4c23398c78b873b18883" translate="yes" xml:space="preserve">
          <source>In addition, modes for buffers of tabulated data can inherit from Tabulated List mode, which is in turn derived from Special mode. See &lt;a href=&quot;tabulated-list-mode#Tabulated-List-Mode&quot;&gt;Tabulated List Mode&lt;/a&gt;.</source>
          <target state="translated">さらに、表形式データのバッファーのモードは、表形式リストモードから継承できます。表形式リストモードは、特殊モードから派生します。&lt;a href=&quot;tabulated-list-mode#Tabulated-List-Mode&quot;&gt;表形式リストモードを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="8458f97247e5805c182989af41d45c53eb115262" translate="yes" xml:space="preserve">
          <source>In addition, several major mode conventions (see &lt;a href=&quot;major-mode-conventions#Major-Mode-Conventions&quot;&gt;Major Mode Conventions&lt;/a&gt;) apply to minor modes as well: those regarding the names of global symbols, the use of a hook at the end of the initialization function, and the use of keymaps and other tables.</source>
          <target state="translated">また、いくつかの主要なモードの慣習が（参照&lt;a href=&quot;major-mode-conventions#Major-Mode-Conventions&quot;&gt;メジャーモードの規則を&lt;/a&gt;）うまくとしてマイナーモードに適用されます。グローバルシンボルの名前に関するものであり、初期化関数の最後でフックを使用すると、キーマップや他のテーブルを使用します。</target>
        </trans-unit>
        <trans-unit id="4e10e520f9a6c6683a99c59aceede71aae7f0066" translate="yes" xml:space="preserve">
          <source>In addition, the keyword argument &lt;code&gt;:supertype&lt;/code&gt; may be used to specify a button-type from which &lt;var&gt;name&lt;/var&gt; inherits its default property values. Note that this inheritance happens only when &lt;var&gt;name&lt;/var&gt; is defined; subsequent changes to a supertype are not reflected in its subtypes.</source>
          <target state="translated">さらに、キーワード引数 &lt;code&gt;:supertype&lt;/code&gt; を使用して、 &lt;var&gt;name&lt;/var&gt; がデフォルトのプロパティ値を継承するボタンタイプを指定できます。この継承は、 &lt;var&gt;name&lt;/var&gt; が定義されている場合にのみ発生することに注意してください。その後のスーパータイプへの変更は、そのサブタイプには反映されません。</target>
        </trans-unit>
        <trans-unit id="85ff8817dbd0f29156e32c5107069061c8afdaa3" translate="yes" xml:space="preserve">
          <source>In addition, this function by default also tells the display engine to update the display of &lt;var&gt;window&lt;/var&gt; when its frame gets redisplayed the next time. If &lt;var&gt;norecord&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, such updates are usually not performed. If, however, &lt;var&gt;norecord&lt;/var&gt; equals the special symbol &lt;code&gt;mark-for-redisplay&lt;/code&gt;, the additional actions mentioned above are omitted but &lt;var&gt;window&lt;/var&gt; will be nevertheless updated.</source>
          <target state="translated">さらに、この関数はデフォルトで、フレームが次回再表示されたときに &lt;var&gt;window&lt;/var&gt; の表示を更新するようにディスプレイエンジンに指示します。 &lt;var&gt;norecord&lt;/var&gt; が &lt;code&gt;nil&lt;/code&gt; 以外の場合、そのような更新は通常実行されません。ただし、 &lt;var&gt;norecord&lt;/var&gt; が特別な記号 &lt;code&gt;mark-for-redisplay&lt;/code&gt; redisplayと等しい場合、上記の追加のアクションは省略され &lt;var&gt;window&lt;/var&gt; が、それでもウィンドウは更新されます。</target>
        </trans-unit>
        <trans-unit id="5bf884b3fb47f2ce4634851fb114d20b6bd6d338" translate="yes" xml:space="preserve">
          <source>In addition, to be acceptable, a completion must also match all the regular expressions in &lt;code&gt;completion-regexp-list&lt;/code&gt;. (Unless &lt;var&gt;collection&lt;/var&gt; is a function, in which case that function has to handle &lt;code&gt;completion-regexp-list&lt;/code&gt; itself.)</source>
          <target state="translated">さらに、受け入れ可能であるためには、補完は、 &lt;code&gt;completion-regexp-list&lt;/code&gt; 内のすべての正規表現とも一致する必要があります。（ &lt;var&gt;collection&lt;/var&gt; が関数である場合を &lt;code&gt;completion-regexp-list&lt;/code&gt; 、その場合、その関数はcompletion-regexp-list自体を処理する必要があります。）</target>
        </trans-unit>
        <trans-unit id="7cc2fc189c0b1e344fb740a24d867c950e0a2e21" translate="yes" xml:space="preserve">
          <source>In addition, when several consecutive fields are wildcards, Emacs collapses them into a single wildcard. This is to prevent use of auto-scaled fonts. Fonts made by scaling larger fonts are not usable for editing, and scaling a smaller font is not useful because it is better to use the smaller font in its own size, which Emacs does.</source>
          <target state="translated">また、複数の連続したフィールドがワイルドカードになっている場合、Emacsではそれらを1つのワイルドカードに折りたたむようにしています。これは、自動スケーリングされたフォントの使用を防ぐためです。大きなフォントをスケーリングして作られたフォントは編集には使えませんし、小さいフォントをスケーリングしても、小さいフォントはそれなりのサイズで使った方が良いので、Emacsがやっているようなスケーリングは役に立たないのです。</target>
        </trans-unit>
        <trans-unit id="dcc0b00855e4755365a0cf1f09ff7bdbd4bc0266" translate="yes" xml:space="preserve">
          <source>In addition, you can mark a particular calling convention for a function as obsolete:</source>
          <target state="translated">さらに、関数の特定の呼び出し規約を廃止されたものとしてマークすることもできます。</target>
        </trans-unit>
        <trans-unit id="abd2410956fae4848b0fe5a8e212d2a9cb21e007" translate="yes" xml:space="preserve">
          <source>In addition, you can specify how to override other aspects of &lt;var&gt;parent&lt;/var&gt; with &lt;var&gt;body&lt;/var&gt;. The command &lt;var&gt;variant&lt;/var&gt; evaluates the forms in &lt;var&gt;body&lt;/var&gt; after setting up all its usual overrides, just before running the mode hooks.</source>
          <target state="translated">さらに、 &lt;var&gt;parent&lt;/var&gt; 他の側面を &lt;var&gt;body&lt;/var&gt; でオーバーライドする方法を指定できます。コマンド &lt;var&gt;variant&lt;/var&gt; は、通常のオーバーライドをすべて設定した後、モードフックを実行する直前に、 &lt;var&gt;body&lt;/var&gt; のフォームを評価します。</target>
        </trans-unit>
        <trans-unit id="02d36c3daefb75afe381d792395f9b544a5ec4c1" translate="yes" xml:space="preserve">
          <source>In addition, you can use &lt;code&gt;jit-lock-register&lt;/code&gt; to register a Font Lock fontification function, which will be called whenever parts of a buffer are (re)fontified because a window was scrolled or its size changed. See &lt;a href=&quot;other-font-lock-variables#Other-Font-Lock-Variables&quot;&gt;Other Font Lock Variables&lt;/a&gt;.</source>
          <target state="translated">さらに、 &lt;code&gt;jit-lock-register&lt;/code&gt; を使用して、フォントロックフォント化関数を登録できます。この関数は、ウィンドウがスクロールされた、またはウィンドウのサイズが変更されたためにバッファの一部が（再）フォント化されるたびに呼び出されます。&lt;a href=&quot;other-font-lock-variables#Other-Font-Lock-Variables&quot;&gt;その他のフォントロック変数を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="5705334ff8d1c82c84ad44b35b05007f2fa086a6" translate="yes" xml:space="preserve">
          <source>In addition, you should use the &lt;code&gt;:image&lt;/code&gt; property; this is how you specify the image to display in the tool bar:</source>
          <target state="translated">さらに、 &lt;code&gt;:image&lt;/code&gt; プロパティを使用する必要があります。これは、ツールバーに表示する画像を指定する方法です。</target>
        </trans-unit>
        <trans-unit id="ef0d186686b9c18697ab294b6e70ae5ec8c76b45" translate="yes" xml:space="preserve">
          <source>In all cases, the functions specify the program to be run. An error is signaled if the file is not found or cannot be executed. If the file name is relative, the variable &lt;code&gt;exec-path&lt;/code&gt; contains a list of directories to search. Emacs initializes &lt;code&gt;exec-path&lt;/code&gt; when it starts up, based on the value of the environment variable &lt;code&gt;PATH&lt;/code&gt;. The standard file name constructs, &amp;lsquo;</source>
          <target state="translated">いずれの場合も、関数は実行するプログラムを指定します。ファイルが見つからないか実行できない場合は、エラーが通知されます。ファイル名が相対的な場合、変数 &lt;code&gt;exec-path&lt;/code&gt; には、検索するディレクトリのリストが含まれます。Emacsは、環境変数 &lt;code&gt;PATH&lt;/code&gt; の値に基づいて、起動時に &lt;code&gt;exec-path&lt;/code&gt; を初期化します。標準のファイル名は、 '</target>
        </trans-unit>
        <trans-unit id="b115e6222ce380955a9d138aca170aa8e2fc234f" translate="yes" xml:space="preserve">
          <source>In all of these functions, if &lt;var&gt;pos&lt;/var&gt; is omitted or &lt;code&gt;nil&lt;/code&gt;, the value of point is used by default. If narrowing is in effect, then &lt;var&gt;pos&lt;/var&gt; should fall within the accessible portion. See &lt;a href=&quot;narrowing#Narrowing&quot;&gt;Narrowing&lt;/a&gt;.</source>
          <target state="translated">これらすべての関数で、 &lt;var&gt;pos&lt;/var&gt; が省略されているか、 &lt;code&gt;nil&lt;/code&gt; の場合、デフォルトでpointの値が使用されます。ナローイングが有効な場合、 &lt;var&gt;pos&lt;/var&gt; はアクセス可能な部分に含まれる必要があります。&lt;a href=&quot;narrowing#Narrowing&quot;&gt;ナローイングを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="cf682436e64696838034960370c404ea0fb339cf" translate="yes" xml:space="preserve">
          <source>In all other cases (i.e., if a backup was made by copying or if no backup was made), this function returns &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">他のすべての場合（つまり、コピーによってバックアップが作成された場合、またはバックアップが作成されなかった場合）、この関数は &lt;code&gt;nil&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="70cd7827f4bb42c08e11727b0f1fc468af4e5623" translate="yes" xml:space="preserve">
          <source>In all other respects, the indirect buffer and its base buffer are completely separate. They have different names, independent values of point, independent narrowing, independent markers and overlays (though inserting or deleting text in either buffer relocates the markers and overlays for both), independent major modes, and independent buffer-local variable bindings.</source>
          <target state="translated">それ以外の点では、間接バッファとベースバッファは完全に分離されています。これらは異なる名前、独立したポイント値、独立した絞り込み、独立したマーカーとオーバーレイ(どちらかのバッファにテキストを挿入したり削除したりすると、両方のマーカーとオーバーレイが再配置されますが)、独立したメジャーモード、独立したバッファローカル変数バインディングを持っています。</target>
        </trans-unit>
        <trans-unit id="e9323836e208f0f82945b28702f7866a57f8574f" translate="yes" xml:space="preserve">
          <source>In an empty obarray, every element is 0, so you can create an obarray with &lt;code&gt;(make-vector &lt;var&gt;length&lt;/var&gt; 0)&lt;/code&gt;. &lt;strong&gt;This is the only valid way to create an obarray.&lt;/strong&gt; Prime numbers as lengths tend to result in good hashing; lengths one less than a power of two are also good.</source>
          <target state="translated">空のobarrayでは、すべての要素が0であるため、 &lt;code&gt;(make-vector &lt;var&gt;length&lt;/var&gt; 0)&lt;/code&gt; を使用してobarrayを作成できます。&lt;strong&gt;これは、obarrayを作成するための唯一の有効な方法です。&lt;/strong&gt;長さとしての素数は、適切なハッシュをもたらす傾向があります。2の累乗より1小さい長さも良いです。</target>
        </trans-unit>
        <trans-unit id="c76083d7ada2b44cfdf97bab16a99c1032df0a60" translate="yes" xml:space="preserve">
          <source>In an indirect buffer, this points to the base buffer. In an ordinary buffer, it is null.</source>
          <target state="translated">間接バッファでは、これはベースバッファを指します。通常のバッファでは null です。</target>
        </trans-unit>
        <trans-unit id="be6a5b6e0ca7ae36339c26b567db393e85f17f36" translate="yes" xml:space="preserve">
          <source>In an interactive call, &lt;var&gt;buffer-or-name&lt;/var&gt; is the current buffer. You cannot specify any other buffer.</source>
          <target state="translated">対話型呼び出しでは、 &lt;var&gt;buffer-or-name&lt;/var&gt; が現在のバッファーです。他のバッファは指定できません。</target>
        </trans-unit>
        <trans-unit id="c4012945ab51c1de7ae7e0feebb4d0048885f32d" translate="yes" xml:space="preserve">
          <source>In an interactive call, &lt;var&gt;count&lt;/var&gt; is the numeric prefix argument, and &lt;var&gt;killp&lt;/var&gt; is the unprocessed prefix argument. Therefore, if a prefix argument is supplied, the text is saved in the kill ring. If no prefix argument is supplied, then one character is deleted, but not saved in the kill ring.</source>
          <target state="translated">対話型呼び出しでは、 &lt;var&gt;count&lt;/var&gt; は数値のプレフィックス引数であり、 &lt;var&gt;killp&lt;/var&gt; は未処理のプレフィックス引数です。したがって、プレフィックス引数が指定されている場合、テキストはキルリングに保存されます。プレフィックス引数が指定されていない場合、1文字が削除されますが、キルリングには保存されません。</target>
        </trans-unit>
        <trans-unit id="704c56b79c4ed2cb4dfd912f6f7d4ba1689e5220" translate="yes" xml:space="preserve">
          <source>In an interactive call, &lt;var&gt;count&lt;/var&gt; is the numeric prefix argument.</source>
          <target state="translated">対話型呼び出しでは、 &lt;var&gt;count&lt;/var&gt; は数値のプレフィックス引数です。</target>
        </trans-unit>
        <trans-unit id="9c353c383e13b0c1f20602b8bc3d920d9ce5a372" translate="yes" xml:space="preserve">
          <source>In an interactive call, &lt;var&gt;join-following-p&lt;/var&gt; is the prefix argument, and &lt;var&gt;beg&lt;/var&gt; and &lt;var&gt;end&lt;/var&gt; are, respectively, the start and end of the region if it is active, else &lt;code&gt;nil&lt;/code&gt;. The function returns &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">対話型呼び出しでは、 &lt;var&gt;join-following-p&lt;/var&gt; がプレフィックス引数であり、 &lt;var&gt;beg&lt;/var&gt; と &lt;var&gt;end&lt;/var&gt; は、アクティブな場合はそれぞれ領域の開始と終了、それ以外の場合は &lt;code&gt;nil&lt;/code&gt; です。関数は &lt;code&gt;nil&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="dd9c47e572e1c96e3e5511e4f902232b871741f5" translate="yes" xml:space="preserve">
          <source>In an interactive call, &lt;var&gt;move-count&lt;/var&gt; is set to the numeric prefix argument.</source>
          <target state="translated">対話型呼び出しでは、 &lt;var&gt;move-count&lt;/var&gt; は数値プレフィックス引数に設定されます。</target>
        </trans-unit>
        <trans-unit id="877a7452b2cb77873327a9d65a9bc81a3bc68b87" translate="yes" xml:space="preserve">
          <source>In an interactive call, &lt;var&gt;n&lt;/var&gt; is the numeric prefix argument, if provided; otherwise &lt;var&gt;n&lt;/var&gt; defaults to &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">対話型呼び出しでは、 &lt;var&gt;n&lt;/var&gt; は、提供されている場合、数値プレフィックス引数です。それ以外の場合、 &lt;var&gt;n&lt;/var&gt; はデフォルトで &lt;code&gt;nil&lt;/code&gt; になります。</target>
        </trans-unit>
        <trans-unit id="d388d1baf8cc5dc2fc6fa147be58325965385ef6" translate="yes" xml:space="preserve">
          <source>In an interactive call, &lt;var&gt;start&lt;/var&gt; and &lt;var&gt;end&lt;/var&gt; are point and the mark, and &lt;var&gt;region&lt;/var&gt; is always non-&lt;code&gt;nil&lt;/code&gt;, so the command always kills the text in the current region.</source>
          <target state="translated">対話型呼び出しでは、 &lt;var&gt;start&lt;/var&gt; と &lt;var&gt;end&lt;/var&gt; はポイントとマークであり、 &lt;var&gt;region&lt;/var&gt; は常に非 &lt;code&gt;nil&lt;/code&gt; であるため、コマンドは常に現在の領域のテキストを強制終了します。</target>
        </trans-unit>
        <trans-unit id="a6cb6ba8c7fe3535c2d651a8267a7942776259f0" translate="yes" xml:space="preserve">
          <source>In an interactive call, &lt;var&gt;start&lt;/var&gt; and &lt;var&gt;end&lt;/var&gt; are point and the mark, and &lt;var&gt;region&lt;/var&gt; is always non-&lt;code&gt;nil&lt;/code&gt;, so the command always saves the text in the current region.</source>
          <target state="translated">対話型呼び出しでは、 &lt;var&gt;start&lt;/var&gt; と &lt;var&gt;end&lt;/var&gt; はポイントとマークであり、 &lt;var&gt;region&lt;/var&gt; は常に非 &lt;code&gt;nil&lt;/code&gt; であるため、コマンドは常にテキストを現在のリージョンに保存します。</target>
        </trans-unit>
        <trans-unit id="726b5ea42fc92cd6827c86a199c5d5ff92d13493" translate="yes" xml:space="preserve">
          <source>In an interactive call, &lt;var&gt;start&lt;/var&gt; and &lt;var&gt;end&lt;/var&gt; are set to the bounds of the current region (point and the mark, with the smallest first).</source>
          <target state="translated">インタラクティブコールでは、 &lt;var&gt;start&lt;/var&gt; と &lt;var&gt;end&lt;/var&gt; は現在の領域の境界に設定されます（ポイントとマーク、最小のものが最初になります）。</target>
        </trans-unit>
        <trans-unit id="909035f0fed973896fe39afc8da0584d4b089bed" translate="yes" xml:space="preserve">
          <source>In an interactive call, BUFFER-OR-NAME is the current buffer. You cannot specify any other buffer. This function returns &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">対話型呼び出しでは、BUFFER-OR-NAMEが現在のバッファーです。他のバッファは指定できません。この関数は &lt;code&gt;nil&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="b6eeae93f2da1e1eebbead60ee6180c03e34ee17" translate="yes" xml:space="preserve">
          <source>In any alternative for which &lt;code&gt;nil&lt;/code&gt; is not a valid value, other than a &lt;code&gt;const&lt;/code&gt;, you should specify a valid default for that alternative using the &lt;code&gt;:value&lt;/code&gt; keyword. See &lt;a href=&quot;type-keywords#Type-Keywords&quot;&gt;Type Keywords&lt;/a&gt;.</source>
          <target state="translated">そのため任意の代替では &lt;code&gt;nil&lt;/code&gt; の以外の有効な値ではない &lt;code&gt;const&lt;/code&gt; 、あなたが使用してその代替のための有効なデフォルト指定する必要があります &lt;code&gt;:value&lt;/code&gt; キーワードを。&lt;a href=&quot;type-keywords#Type-Keywords&quot;&gt;タイプキーワードを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="c3f1ff89d869dfc333b47133aae85f8c337add69" translate="yes" xml:space="preserve">
          <source>In any construct except &amp;lsquo;</source>
          <target state="translated">'以外の構成</target>
        </trans-unit>
        <trans-unit id="23f12bc9401d6ef353dd5c55264d43d354d02967" translate="yes" xml:space="preserve">
          <source>In backtraces, the tails of long lists and the ends of long strings, vectors or structures, as well as objects which are deeply nested, will be printed as underlined &amp;ldquo;...&amp;rdquo;. You can click with the mouse on a &amp;ldquo;...&amp;rdquo;, or type</source>
          <target state="translated">バックトレースでは、長いリストの末尾と長い文字列、ベクトル、または構造の終わり、および深くネストされたオブジェクトは、下線付きの「...」として出力されます。「...」をマウスでクリックするか、「...」と入力します。</target>
        </trans-unit>
        <trans-unit id="c4a2e0b355083bd4e6d42b1e97e7d50e0326670d" translate="yes" xml:space="preserve">
          <source>In batch mode (see &lt;a href=&quot;batch-mode#Batch-Mode&quot;&gt;Batch Mode&lt;/a&gt;), &lt;code&gt;sit-for&lt;/code&gt; cannot be interrupted, even by input from the standard input descriptor. It is thus equivalent to &lt;code&gt;sleep-for&lt;/code&gt;, which is described below.</source>
          <target state="translated">バッチモード（参照では&lt;a href=&quot;batch-mode#Batch-Mode&quot;&gt;バッチモード&lt;/a&gt;）、 &lt;code&gt;sit-for&lt;/code&gt; は中断することはできません、でも、標準入力記述子からの入力によって。したがって、これは以下で説明する &lt;code&gt;sleep-for&lt;/code&gt; と同等です。</target>
        </trans-unit>
        <trans-unit id="9752b056c39ff21442a1ef5d86a1fc2649afb383" translate="yes" xml:space="preserve">
          <source>In batch mode, the message is printed to the standard error stream, followed by a newline.</source>
          <target state="translated">バッチ・モードでは、メッセージは標準エラー・ストリームに印刷され、その後に改行が続きます。</target>
        </trans-unit>
        <trans-unit id="8f907e0c0c1a2381a3d4d498c2ada7dd4f978099" translate="yes" xml:space="preserve">
          <source>In between &lt;code&gt;deftheme&lt;/code&gt; and &lt;code&gt;provide-theme&lt;/code&gt; are Lisp forms specifying the theme settings: usually a call to &lt;code&gt;custom-theme-set-variables&lt;/code&gt; and/or a call to &lt;code&gt;custom-theme-set-faces&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;deftheme&lt;/code&gt; と &lt;code&gt;provide-theme&lt;/code&gt; の間には、テーマ設定を指定するLispフォームがあります。通常は &lt;code&gt;custom-theme-set-variables&lt;/code&gt; の呼び出し、および/または &lt;code&gt;custom-theme-set-faces&lt;/code&gt; の呼び出しです。</target>
        </trans-unit>
        <trans-unit id="3186dd1c1a48267fc6d25c2e34e690dda868c78a" translate="yes" xml:space="preserve">
          <source>In binary, the decimal integer 5 looks like this:</source>
          <target state="translated">2進数では、10進数の整数5はこのようになります。</target>
        </trans-unit>
        <trans-unit id="d7ecff436b6d92bbc3770178067cf6d70a3b3360" translate="yes" xml:space="preserve">
          <source>In bitfields, prefer &lt;code&gt;unsigned int&lt;/code&gt; or &lt;code&gt;signed int&lt;/code&gt; to &lt;code&gt;int&lt;/code&gt;, as &lt;code&gt;int&lt;/code&gt; is less portable: it might be signed, and might not be. Single-bit bit fields should be &lt;code&gt;unsigned int&lt;/code&gt; or &lt;code&gt;bool_bf&lt;/code&gt; so that their values are 0 or 1.</source>
          <target state="translated">ビットフィールドでは、好む &lt;code&gt;unsigned int&lt;/code&gt; 型または &lt;code&gt;signed int&lt;/code&gt; に &lt;code&gt;int&lt;/code&gt; 型として、 &lt;code&gt;int&lt;/code&gt; はそれが署名されるかもしれない、とではないかもしれません：以下、ポータブルです。シングルビットビットフィールドは、値が0または1になるように、 &lt;code&gt;unsigned int&lt;/code&gt; または &lt;code&gt;bool_bf&lt;/code&gt; である必要があります。</target>
        </trans-unit>
        <trans-unit id="675393a13b41d56ffdbbbad71f7b6ec5ff7928e6" translate="yes" xml:space="preserve">
          <source>In case a process status changes need to be passed to several sentinels, you can use &lt;code&gt;add-function&lt;/code&gt; to combine an existing sentinel with a new one. See &lt;a href=&quot;advising-functions#Advising-Functions&quot;&gt;Advising Functions&lt;/a&gt;.</source>
          <target state="translated">プロセスステータスの変更を複数のセンチネルに渡す必要がある場合は、 &lt;code&gt;add-function&lt;/code&gt; を使用して、既存のセンチネルを新しいセンチネルと組み合わせることができます。&lt;a href=&quot;advising-functions#Advising-Functions&quot;&gt;アドバイス機能を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="0977f1472f3a5da1475ae4011d1503a4798e4640" translate="yes" xml:space="preserve">
          <source>In case the process&amp;rsquo;s output needs to be passed to several filters, you can use &lt;code&gt;add-function&lt;/code&gt; to combine an existing filter with a new one. See &lt;a href=&quot;advising-functions#Advising-Functions&quot;&gt;Advising Functions&lt;/a&gt;.</source>
          <target state="translated">プロセスの出力を複数のフィルターに渡す必要がある場合は、 &lt;code&gt;add-function&lt;/code&gt; を使用して、既存のフィルターを新しいフィルターと組み合わせることができます。&lt;a href=&quot;advising-functions#Advising-Functions&quot;&gt;アドバイス機能を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="415e1a1cd6e77875c4b4a2bc134b390be6d8c82b" translate="yes" xml:space="preserve">
          <source>In complicated programs, simple termination may not be what you want. For example, the program may have made temporary changes in data structures, or created temporary buffers that should be deleted before the program is finished. In such cases, you would use &lt;code&gt;unwind-protect&lt;/code&gt; to establish &lt;em&gt;cleanup expressions&lt;/em&gt; to be evaluated in case of error. (See &lt;a href=&quot;cleanups#Cleanups&quot;&gt;Cleanups&lt;/a&gt;.) Occasionally, you may wish the program to continue execution despite an error in a subroutine. In these cases, you would use &lt;code&gt;condition-case&lt;/code&gt; to establish &lt;em&gt;error handlers&lt;/em&gt; to recover control in case of error.</source>
          <target state="translated">複雑なプログラムでは、単純な終了はあなたが望むものではないかもしれません。たとえば、プログラムがデータ構造に一時的な変更を加えたり、プログラムが終了する前に削除する必要のある一時バッファを作成したりした可能性があります。このような場合、 &lt;code&gt;unwind-protect&lt;/code&gt; を使用して、エラーの場合に評価される&lt;em&gt;クリーンアップ式&lt;/em&gt;を確立します。 （&lt;a href=&quot;cleanups#Cleanups&quot;&gt;クリーンアップを&lt;/a&gt;参照してください。）場合によっては、サブルーチンでエラーが発生してもプログラムの実行を継続したいことがあります。このような場合、 &lt;code&gt;condition-case&lt;/code&gt; を使用して&lt;em&gt;エラーハンドラー&lt;/em&gt;を確立し、&lt;em&gt;エラー&lt;/em&gt;が発生した場合に制御を回復します。</target>
        </trans-unit>
        <trans-unit id="60f0d105f0d0cf77e2c002371b610ecf30fd644e" translate="yes" xml:space="preserve">
          <source>In contexts where a truth value is expected, any non-&lt;code&gt;nil&lt;/code&gt; value is considered to be &lt;var&gt;true&lt;/var&gt;. However, &lt;code&gt;t&lt;/code&gt; is the preferred way to represent the truth value &lt;var&gt;true&lt;/var&gt;. When you need to choose a value that represents &lt;var&gt;true&lt;/var&gt;, and there is no other basis for choosing, use &lt;code&gt;t&lt;/code&gt;. The symbol &lt;code&gt;t&lt;/code&gt; always has the value &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">真理値が期待されるコンテキストでは、 &lt;code&gt;nil&lt;/code&gt; 以外の値はすべて &lt;var&gt;true&lt;/var&gt; と見なされます。ただし、 &lt;code&gt;t&lt;/code&gt; は真理値 &lt;var&gt;true&lt;/var&gt; を表すための好ましい方法です。 &lt;var&gt;true&lt;/var&gt; を表す値を選択する必要があり、選択するための他の根拠がない場合は、 &lt;code&gt;t&lt;/code&gt; を使用します。記号 &lt;code&gt;t&lt;/code&gt; の値は常に &lt;code&gt;t&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="8eba9b310f9d565eff25ab947d11a5a1f613377b" translate="yes" xml:space="preserve">
          <source>In contrast to the round-trip specification described in the previous subsection (see &lt;a href=&quot;format-conversion-round_002dtrip#Format-Conversion-Round_002dTrip&quot;&gt;Format Conversion Round-Trip&lt;/a&gt;), you can use the variables &lt;code&gt;after-insert-file-functions&lt;/code&gt; and &lt;code&gt;write-region-annotate-functions&lt;/code&gt; to separately control the respective reading and writing conversions.</source>
          <target state="translated">前のサブセクションで説明したラウンドトリップ仕様（&lt;a href=&quot;format-conversion-round_002dtrip#Format-Conversion-Round_002dTrip&quot;&gt;フォーマット変換ラウンドトリップを&lt;/a&gt;参照）とは対照的に、変数 &lt;code&gt;after-insert-file-functions&lt;/code&gt; および &lt;code&gt;write-region-annotate-functions&lt;/code&gt; を使用して、それぞれの読み取りと書き込みを個別に制御できます。コンバージョン。</target>
        </trans-unit>
        <trans-unit id="0a3bf2d74aea58d6ea8bffb1137530a1210d0d12" translate="yes" xml:space="preserve">
          <source>In contrast, when reading, the annotations intermixed with the text are handled immediately. &lt;code&gt;insert-file-contents&lt;/code&gt; sets point to the beginning of some text to be converted, then calls the conversion functions with the length of that text. These functions should always return with point at the beginning of the inserted text. This approach makes sense for reading because annotations removed by the first converter can&amp;rsquo;t be mistakenly processed by a later converter. Each conversion function should scan for the annotations it recognizes, remove the annotation, modify the buffer text (to set a text property, for example), and return the updated length of the text, as it stands after those changes. The value returned by one function becomes the argument to the next function.</source>
          <target state="translated">対照的に、読むとき、テキストと混合された注釈はすぐに処理されます。 &lt;code&gt;insert-file-contents&lt;/code&gt; セットは、変換されるテキストの先頭を指し、そのテキストの長さで変換関数を呼び出します。これらの関数は、挿入されたテキストの先頭に常にポイントを付けて戻る必要があります。最初のコンバーターによって削除された注釈が後のコンバーターによって誤って処理されることはないため、このアプローチは読むのに意味があります。各変換関数は、認識した注釈をスキャンし、注釈を削除し、バッファテキストを変更し（たとえば、テキストプロパティを設定するため）、変更後のテキストの更新された長さを返す必要があります。 1つの関数によって返される値は、次の関数への引数になります。</target>
        </trans-unit>
        <trans-unit id="45f849363c53b5551262a12f44a838fe59d9dfff" translate="yes" xml:space="preserve">
          <source>In conventional string syntax, it would be written</source>
          <target state="translated">従来の文字列構文では</target>
        </trans-unit>
        <trans-unit id="6763f8895253c23b2bfde0810fbb36d480f05759" translate="yes" xml:space="preserve">
          <source>In database terminology, an &lt;em&gt;atomic&lt;/em&gt; change is an indivisible change&amp;mdash;it can succeed entirely or it can fail entirely, but it cannot partly succeed. A Lisp program can make a series of changes to one or several buffers as an &lt;em&gt;atomic change group&lt;/em&gt;, meaning that either the entire series of changes will be installed in their buffers or, in case of an error, none of them will be.</source>
          <target state="translated">データベースの用語では、&lt;em&gt;アトミックな&lt;/em&gt;変更は不可分な変更です。完全に成功することも、完全に失敗することもありますが、部分的に成功することはできません。Lispプログラムは、&lt;em&gt;アトミック変更グループ&lt;/em&gt;として1つまたは複数のバッファーに一連の変更を加えることができます。つまり、一連の変更全体がバッファーにインストールされるか、エラーが発生した場合はいずれもインストールされません。</target>
        </trans-unit>
        <trans-unit id="24fde5297de2cdf3f7cddc429425532a566bab63" translate="yes" xml:space="preserve">
          <source>In detail, &lt;code&gt;fill-context-prefix&lt;/code&gt; does this:</source>
          <target state="translated">詳細には、 &lt;code&gt;fill-context-prefix&lt;/code&gt; はこれを行います。</target>
        </trans-unit>
        <trans-unit id="6c73b882a6269a46b3da224791afd0c995e3640a" translate="yes" xml:space="preserve">
          <source>In each frame, at any time, exactly one Emacs window is designated as &lt;em&gt;selected within the frame&lt;/em&gt;. For the selected frame, that window is called the &lt;em&gt;selected window&lt;/em&gt;&amp;mdash;the one in which most editing takes place, and in which the cursor for selected windows appears (see &lt;a href=&quot;cursor-parameters#Cursor-Parameters&quot;&gt;Cursor Parameters&lt;/a&gt;). Keyboard input that inserts or deletes text is also normally directed to this window. The selected window&amp;rsquo;s buffer is usually also the current buffer, except when &lt;code&gt;set-buffer&lt;/code&gt; has been used (see &lt;a href=&quot;current-buffer#Current-Buffer&quot;&gt;Current Buffer&lt;/a&gt;). As for non-selected frames, the window selected within the frame becomes the selected window if the frame is ever selected. See &lt;a href=&quot;selecting-windows#Selecting-Windows&quot;&gt;Selecting Windows&lt;/a&gt;.</source>
          <target state="translated">各フレームでは、いつでも&lt;em&gt;、フレーム内で選択&lt;/em&gt;されたEmacsウィンドウが1つだけ指定さ&lt;em&gt;れます&lt;/em&gt;。選択されたフレームの場合、そのウィンドウは&lt;em&gt;選択されたウィンドウ&lt;/em&gt;と呼ば&lt;em&gt;れます。&lt;/em&gt;これは、ほとんどの編集が行われ、選択されたウィンドウのカーソルが表示されるウィンドウです（&lt;a href=&quot;cursor-parameters#Cursor-Parameters&quot;&gt;カーソルパラメータを&lt;/a&gt;参照）。テキストを挿入または削除するキーボード入力も、通常、このウィンドウに送られます。選択したウィンドウのバッファは、 &lt;code&gt;set-buffer&lt;/code&gt; が使用されている場合を除いて、通常は現在のバッファでもあります（&lt;a href=&quot;current-buffer#Current-Buffer&quot;&gt;現在のバッファを&lt;/a&gt;参照）。選択されていないフレームについては、フレームが選択されている場合、フレーム内で選択されたウィンドウが選択されたウィンドウになります。&lt;a href=&quot;selecting-windows#Selecting-Windows&quot;&gt;Windowsの選択を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="ad35cfb21fd35d93c29df7f5ad4a4bed0b1b3107" translate="yes" xml:space="preserve">
          <source>In either case, evaluating the new form a second time should reuse the window already showing</source>
          <target state="translated">いずれの場合も、新しいフォームを2回目に評価すると、すでに表示されているウィンドウを再利用する必要があります。</target>
        </trans-unit>
        <trans-unit id="ee27d0c4d0b49c83179819de6b9ff1ee23a49d86" translate="yes" xml:space="preserve">
          <source>In either case, if the buffer appended to happens to be displayed in some window, the next redisplay will show how its text has changed. If it is not displayed in any window, you will not see the change immediately on the screen. The command causes the buffer to become current temporarily, but does not cause it to be displayed.</source>
          <target state="translated">いずれの場合も、追加されたバッファがたまたまどこかのウィンドウに表示されていた場合は、次の再表示でそのテキストがどのように変更されたかが表示されます。どのウィンドウにも表示されていない場合は、画面上にすぐに変更が表示されることはありません。このコマンドはバッファを一時的にカレント状態にしますが、表示はされません。</target>
        </trans-unit>
        <trans-unit id="ef78bac5868bf004212c473e8f88981c10bea61b" translate="yes" xml:space="preserve">
          <source>In either case, the mouse pointer must enter the text area of a window in order to trigger its selection. Dragging the scroll bar slider or the mode line of a window conceptually should not cause its auto-selection.</source>
          <target state="translated">いずれの場合も、マウスポインタがウィンドウのテキストエリアに入る必要があります。スクロールバーのスライダーやウィンドウのモードラインをドラッグしても、概念的には自動選択が発生しないはずです。</target>
        </trans-unit>
        <trans-unit id="bb020b581d31901fa99b6df9f62296593685946f" translate="yes" xml:space="preserve">
          <source>In execution, this is equivalent to &lt;code&gt;(progn &lt;var&gt;body&lt;/var&gt;...)&lt;/code&gt;, but the compiler does not issue warnings for anything that occurs inside &lt;var&gt;body&lt;/var&gt;.</source>
          <target state="translated">実行時には、これは &lt;code&gt;(progn &lt;var&gt;body&lt;/var&gt;...)&lt;/code&gt; と同等ですが、コンパイラーは &lt;var&gt;body&lt;/var&gt; 内で発生したものに対して警告を発行しません。</target>
        </trans-unit>
        <trans-unit id="b9f9f3178064d3634e45314cc92aa2cf96eef93d" translate="yes" xml:space="preserve">
          <source>In execution, this is equivalent to &lt;code&gt;(progn &lt;var&gt;body&lt;/var&gt;...)&lt;/code&gt;, but the compiler does not issue warnings for the specified conditions in &lt;var&gt;body&lt;/var&gt;. &lt;var&gt;warnings&lt;/var&gt; is an associative list of warning symbols and function/variable symbols they apply to. For instance, if you wish to call an obsolete function called &lt;code&gt;foo&lt;/code&gt;, but want to suppress the compilation warning, say:</source>
          <target state="translated">実行時には、これは &lt;code&gt;(progn &lt;var&gt;body&lt;/var&gt;...)&lt;/code&gt; と同等ですが、コンパイラーは &lt;var&gt;body&lt;/var&gt; で指定された条件に対して警告を発行しません。 &lt;var&gt;warnings&lt;/var&gt; は、警告記号とそれらが適用される関数/変数記号の関連リストです。たとえば、 &lt;code&gt;foo&lt;/code&gt; という廃止された関数を呼び出したいが、コンパイルの警告を抑制したい場合は、次のように言います。</target>
        </trans-unit>
        <trans-unit id="e7a73c00dd55be6828ec1b5b1eeb3d24e621b2d1" translate="yes" xml:space="preserve">
          <source>In fact, &lt;code&gt;shell-mode&lt;/code&gt; is used only in a function that executes &lt;code&gt;(require 'shell)&lt;/code&gt; before calling &lt;code&gt;shell-mode&lt;/code&gt;, so &lt;code&gt;shell-mode&lt;/code&gt; will be defined properly at run-time. When you know that such a warning does not indicate a real problem, it is good to suppress the warning. That makes new warnings which might mean real problems more visible. You do that with &lt;code&gt;declare-function&lt;/code&gt;.</source>
          <target state="translated">実際には、 &lt;code&gt;shell-mode&lt;/code&gt; 実行するだけの機能で使用されている &lt;code&gt;(require 'shell)&lt;/code&gt; を呼び出す前に、 &lt;code&gt;shell-mode&lt;/code&gt; 、その &lt;code&gt;shell-mode&lt;/code&gt; 実行時に適切に定義されます。このような警告が実際の問題を示していないことがわかっている場合は、警告を抑制することをお勧めします。これにより、実際の問題をより明確にする可能性のある新しい警告が作成されます。これは &lt;code&gt;declare-function&lt;/code&gt; で行います。</target>
        </trans-unit>
        <trans-unit id="702499afeb8537fae4516a820a217b87dce96b8a" translate="yes" xml:space="preserve">
          <source>In general, a coding system doesn&amp;rsquo;t guarantee roundtrip identity: decoding a byte sequence using a coding system, then encoding the resulting text in the same coding system, can produce a different byte sequence. But some coding systems do guarantee that the byte sequence will be the same as what you originally decoded. Here are a few examples:</source>
          <target state="translated">一般に、コーディングシステムはラウンドトリップIDを保証しません。コーディングシステムを使用してバイトシーケンスをデコードし、結果のテキストを同じコーディングシステムでエンコードすると、異なるバイトシーケンスが生成される可能性があります。ただし、一部のコーディングシステムでは、バイトシーケンスが最初にデコードしたものと同じになることが保証されています。次にいくつかの例を示します。</target>
        </trans-unit>
        <trans-unit id="ed8140bd46b47c404332052d91ca4300f382ef67" translate="yes" xml:space="preserve">
          <source>In general, a customization type is a list whose first element is a symbol, one of the customization type names defined in the following sections. After this symbol come a number of arguments, depending on the symbol. Between the type symbol and its arguments, you can optionally write keyword-value pairs (see &lt;a href=&quot;type-keywords#Type-Keywords&quot;&gt;Type Keywords&lt;/a&gt;).</source>
          <target state="translated">一般に、カスタマイズタイプは、最初の要素がシンボルであるリストであり、次のセクションで定義されているカスタマイズタイプ名の1つです。この記号の後には、記号に応じていくつかの引数があります。タイプシンボルとその引数の間に、オプションでキーワードと値のペアを書き込むことができます（&lt;a href=&quot;type-keywords#Type-Keywords&quot;&gt;タイプキーワードを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="1b2ad17401a7d60fe385624a77f3d12df552ad7a" translate="yes" xml:space="preserve">
          <source>In general, any version of Emacs can run byte-compiled code produced by recent earlier versions of Emacs, but the reverse is not true.</source>
          <target state="translated">一般的に、どのバージョンのEmacsでも、最近の以前のバージョンのEmacsで生成されたバイトコンパイルされたコードを実行することができますが、逆は真ではありません。</target>
        </trans-unit>
        <trans-unit id="483c66ee5a6826168e53ee4c3c9f71f1f0eb14bb" translate="yes" xml:space="preserve">
          <source>In general, it is not a good idea to position a frame relative to the right or bottom edge of its display. Positioning the initial or a new frame is either not accurate (because the size of the outer frame is not yet fully known before the frame has been made visible) or will cause additional flicker (if the frame has to be repositioned after becoming visible).</source>
          <target state="translated">一般的に、フレームをその表示の右端または下端に相対的に配置することは良い考えではありません。初期フレームまたは新しいフレームを配置することは、(フレームが可視化される前に、外側フレームのサイズがまだ完全に知られていないため)正確ではないか、または(可視化された後にフレームを再配置しなければならない場合)追加のフリッカーを引き起こすことになります。</target>
        </trans-unit>
        <trans-unit id="034a86c69916fca88f1f01a8bd4d6e2f2b480dfb" translate="yes" xml:space="preserve">
          <source>In general, the execution modes earlier in the above list run the program more slowly or stop sooner than the modes later in the list.</source>
          <target state="translated">一般的に、上記リストの中で早い方の実行モードは、リストの中で遅い方の実行モードよりもプログラムをゆっくりと実行したり、すぐに停止したりします。</target>
        </trans-unit>
        <trans-unit id="62c782f036549cb7ac5bcdfa7098ab39e8230d14" translate="yes" xml:space="preserve">
          <source>In general, you should never use &lt;code&gt;select-frame&lt;/code&gt; in a way that could switch to a different terminal without switching back when you&amp;rsquo;re done.</source>
          <target state="translated">一般に、終了時に元に戻さずに別の端末に切り替えることができるような方法で &lt;code&gt;select-frame&lt;/code&gt; を使用しないでください。</target>
        </trans-unit>
        <trans-unit id="000defc205f6d714529fe32278af5b38a4bfd5bc" translate="yes" xml:space="preserve">
          <source>In hexadecimal and octal escape sequences, the escaped character code may contain a variable number of digits, so the first subsequent character which is not a valid hexadecimal or octal digit terminates the escape sequence. If the next character in a string could be interpreted as a hexadecimal or octal digit, write &amp;lsquo;</source>
          <target state="translated">16進数および8進数のエスケープシーケンスでは、エスケープされた文字コードに可変桁数が含まれる場合があるため、有効な16進数または8進数ではない最初の後続文字がエスケープシーケンスを終了します。文字列の次の文字が16進数または8進数として解釈される可能性がある場合は、「」と記述します。</target>
        </trans-unit>
        <trans-unit id="0836c04769a43db17a7b5ef05b200c3203b6be46" translate="yes" xml:space="preserve">
          <source>In human languages, and in C code, the parenthesis pairs are &amp;lsquo;</source>
          <target state="translated">人間の言語およびCコードでは、括弧のペアは 'です。</target>
        </trans-unit>
        <trans-unit id="c6f32a0eb2283df62480c957c724fa4fc47bd02c" translate="yes" xml:space="preserve">
          <source>In its most simplistic form, a frame accommodates always one single window that can be used for displaying a buffer. As a consequence, it is always the latest call of &lt;code&gt;display-buffer&lt;/code&gt; that will have succeeded in placing its buffer there.</source>
          <target state="translated">最も単純な形式では、フレームは、バッファの表示に使用できる単一のウィンドウを常に収容します。結果として、バッファをそこに配置することに成功したのは、常に &lt;code&gt;display-buffer&lt;/code&gt; の最新の呼び出しです。</target>
        </trans-unit>
        <trans-unit id="517dd96030f3f996fb1f45cc621a39517562983b" translate="yes" xml:space="preserve">
          <source>In many</source>
          <target state="translated">多くの場合</target>
        </trans-unit>
        <trans-unit id="8dcd7ed16971de04e98f26c126a4533e71094f7f" translate="yes" xml:space="preserve">
          <source>In many cases, you can avoid the need to track the mouse by using the &lt;code&gt;mouse-face&lt;/code&gt; text property (see &lt;a href=&quot;special-properties#Special-Properties&quot;&gt;Special Properties&lt;/a&gt;). That works at a much lower level and runs more smoothly than Lisp-level mouse tracking.</source>
          <target state="translated">多くの場合、 &lt;code&gt;mouse-face&lt;/code&gt; textプロパティを使用してマウスを追跡する必要を回避できます（&lt;a href=&quot;special-properties#Special-Properties&quot;&gt;特別なプロパティを&lt;/a&gt;参照）。これははるかに低いレベルで機能し、Lispレベルのマウストラッキングよりもスムーズに実行されます。</target>
        </trans-unit>
        <trans-unit id="49101488ffc937e3b7893c385b89b2d974310c1a" translate="yes" xml:space="preserve">
          <source>In most Emacs Lisp programs, the fact that non-</source>
          <target state="translated">ほとんどのEmacs Lispプログラムでは、非</target>
        </trans-unit>
        <trans-unit id="3d37db503d5ae63228a732b670e52af7077b5d2f" translate="yes" xml:space="preserve">
          <source>In most cases, &lt;var&gt;repeat&lt;/var&gt; has no effect on when &lt;em&gt;first&lt;/em&gt; call takes place&amp;mdash;&lt;var&gt;time&lt;/var&gt; alone specifies that. There is one exception: if &lt;var&gt;time&lt;/var&gt; is &lt;code&gt;t&lt;/code&gt;, then the timer runs whenever the time is a multiple of &lt;var&gt;repeat&lt;/var&gt; seconds after the epoch. This is useful for functions like &lt;code&gt;display-time&lt;/code&gt;.</source>
          <target state="translated">ほとんどの場合、 &lt;var&gt;repeat&lt;/var&gt; は&lt;em&gt;最初の&lt;/em&gt;呼び出しが行われる &lt;var&gt;time&lt;/var&gt; は影響しません。時間だけで指定されます。例外が1つあります。 &lt;var&gt;time&lt;/var&gt; が &lt;code&gt;t&lt;/code&gt; の場合、タイマーは、時刻がエポック後の &lt;var&gt;repeat&lt;/var&gt; 秒の倍数になるたびに実行されます。これは、 &lt;code&gt;display-time&lt;/code&gt; などの関数に役立ちます。</target>
        </trans-unit>
        <trans-unit id="2168d3ba9383968f4154392a9504604af5704a81" translate="yes" xml:space="preserve">
          <source>In most cases, an object&amp;rsquo;s printed representation is also a read syntax for the object. However, some types have no read syntax, since it does not make sense to enter objects of these types as constants in a Lisp program. These objects are printed in &lt;em&gt;hash notation&lt;/em&gt;, which consists of the characters &amp;lsquo;</source>
          <target state="translated">ほとんどの場合、オブジェクトの印刷表現は、オブジェクトの読み取り構文でもあります。ただし、Lispプログラムに定数としてこれらのタイプのオブジェクトを入力することは意味がないため、一部のタイプには読み取り構文がありません。これらのオブジェクトは、文字で構成される&lt;em&gt;ハッシュ表記&lt;/em&gt;で出力されます。</target>
        </trans-unit>
        <trans-unit id="c750c78aabaa316f26f23fc17657b3720fc57df7" translate="yes" xml:space="preserve">
          <source>In most cases, this is the same as &lt;code&gt;data-directory&lt;/code&gt;. They may be different when you run Emacs from the directory where you built it, without actually installing it. See &lt;a href=&quot;help-functions#Definition-of-data_002ddirectory&quot;&gt;Definition of data-directory&lt;/a&gt;.</source>
          <target state="translated">ほとんどの場合、これは &lt;code&gt;data-directory&lt;/code&gt; と同じです。実際にインストールせずに、ビルドしたディレクトリからEmacsを実行すると、それらが異なる場合があります。&lt;a href=&quot;help-functions#Definition-of-data_002ddirectory&quot;&gt;データディレクトリの定義を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="7f11478c160dcd0584465efccbf9e4064e017f8a" translate="yes" xml:space="preserve">
          <source>In most cases, you should not call minibuffer input functions in the middle of a Lisp function. Instead, do all minibuffer input as part of reading the arguments for a command, in the &lt;code&gt;interactive&lt;/code&gt; specification. See &lt;a href=&quot;defining-commands#Defining-Commands&quot;&gt;Defining Commands&lt;/a&gt;.</source>
          <target state="translated">ほとんどの場合、Lisp関数の途中でミニバッファー入力関数を呼び出さないでください。代わりに、 &lt;code&gt;interactive&lt;/code&gt; 仕様で、コマンドの引数の読み取りの一部としてすべてのミニバッファー入力を実行します。&lt;a href=&quot;defining-commands#Defining-Commands&quot;&gt;コマンドの定義を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="b4c2bc2c76de37d53e0710c100619151cccb7b2e" translate="yes" xml:space="preserve">
          <source>In most cases, you should not call these functions in the middle of a Lisp function. When possible, do all minibuffer input as part of reading the arguments for a command, in the &lt;code&gt;interactive&lt;/code&gt; specification. See &lt;a href=&quot;defining-commands#Defining-Commands&quot;&gt;Defining Commands&lt;/a&gt;.</source>
          <target state="translated">ほとんどの場合、Lisp関数の途中でこれらの関数を呼び出さないでください。可能であれば、 &lt;code&gt;interactive&lt;/code&gt; 仕様で、コマンドの引数の読み取りの一部としてすべてのミニバッファー入力を実行します。&lt;a href=&quot;defining-commands#Defining-Commands&quot;&gt;コマンドの定義を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="2d28787cdfc551ad73cc6007bcd96f89f863e52c" translate="yes" xml:space="preserve">
          <source>In most cases, you should not need to call &lt;code&gt;package-activate-all&lt;/code&gt;, as this is done automatically during startup. Simply make sure to put any code that should run before &lt;code&gt;package-activate-all&lt;/code&gt; in the early init file, and any code that should run after it in the primary init file (see &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Init-File.html#Init-File&quot;&gt;Init File&lt;/a&gt; in</source>
          <target state="translated">ほとんどの場合、 &lt;code&gt;package-activate-all&lt;/code&gt; を呼び出す必要はありません。これは、起動時に自動的に行われるためです。単に前に実行する必要があります任意のコードを入れてください &lt;code&gt;package-activate-all&lt;/code&gt; 早期初期化ファイルには、プライマリinitファイル内で後に実行する必要があります任意のコードが（参照&lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Init-File.html#Init-File&quot;&gt;初期化ファイル&lt;/a&gt;に</target>
        </trans-unit>
        <trans-unit id="574e81c2ebf0fb53e6b7a82f512213500a53d2b7" translate="yes" xml:space="preserve">
          <source>In most clean Lisp code, this difference won&amp;rsquo;t matter. It can matter only if you perform side-effects on the objects constructed by the macro definition. Thus, to avoid trouble, &lt;strong&gt;avoid side effects on objects constructed by macro definitions&lt;/strong&gt;. Here is an example of how such side effects can get you into trouble:</source>
          <target state="translated">ほとんどのクリーンなLispコードでは、この違いは重要ではありません。マクロ定義によって構築されたオブジェクトに副作用を実行する場合にのみ問題になります。したがって、トラブルを&lt;strong&gt;回避するために、マクロ定義によって構築されたオブジェクトへの副作用を回避してください&lt;/strong&gt;。このような副作用がどのようにあなたをトラブルに巻き込むことができるかの例はここにあります：</target>
        </trans-unit>
        <trans-unit id="0b16687a5ada91a83610070c6aab00214708b230" translate="yes" xml:space="preserve">
          <source>In most computer languages, every function has a name. But in Lisp, a function in the strictest sense has no name: it is an object which can &lt;em&gt;optionally&lt;/em&gt; be associated with a symbol (e.g., &lt;code&gt;car&lt;/code&gt;) that serves as the function name. See &lt;a href=&quot;function-names#Function-Names&quot;&gt;Function Names&lt;/a&gt;. When a function has been given a name, we usually also refer to that symbol as a &amp;ldquo;function&amp;rdquo; (e.g., we refer to &amp;ldquo;the function &lt;code&gt;car&lt;/code&gt;&amp;rdquo;). In this manual, the distinction between a function name and the function object itself is usually unimportant, but we will take note wherever it is relevant.</source>
          <target state="translated">ほとんどのコンピューター言語では、すべての関数に名前があります。しかし、Lispでは、最も厳密な意味での関数には名前がありません。それは、関数名として機能するシンボル（たとえば、 &lt;code&gt;car&lt;/code&gt; ）に&lt;em&gt;オプション&lt;/em&gt;で関連付けることができるオブジェクト&lt;em&gt;です&lt;/em&gt;。&lt;a href=&quot;function-names#Function-Names&quot;&gt;関数名を&lt;/a&gt;参照してください。関数に名前が付けられている場合、通常、その記号を「関数」とも呼びます（たとえば、「関数 &lt;code&gt;car&lt;/code&gt; 」と呼びます）。このマニュアルでは、関数名と関数オブジェクト自体の区別は通常重要ではありませんが、関連する場合は常に注意します。</target>
        </trans-unit>
        <trans-unit id="0783cd0cb68b0d9a782edd9f6662166db1491334" translate="yes" xml:space="preserve">
          <source>In most languages, the programmer must declare the data type of each variable, and the type is known by the compiler but not represented in the data. Such type declarations do not exist in Emacs Lisp. A Lisp variable can have any type of value, and it remembers whatever value you store in it, type and all. (Actually, a small number of Emacs Lisp variables can only take on values of a certain type. See &lt;a href=&quot;variables-with-restricted-values#Variables-with-Restricted-Values&quot;&gt;Variables with Restricted Values&lt;/a&gt;.)</source>
          <target state="translated">ほとんどの言語では、プログラマーは各変数のデータ型を宣言する必要があり、その型はコンパイラーによって認識されますが、データでは表されません。このような型宣言はEmacsLispには存在しません。 Lisp変数は任意のタイプの値を持つことができ、それに格納する値、タイプ、およびすべてを記憶します。 （実際には、少数のEmacs Lisp変数は特定のタイプの値しかとることができません。&lt;a href=&quot;variables-with-restricted-values#Variables-with-Restricted-Values&quot;&gt;制限された値を持つ変数を&lt;/a&gt;参照してください。）</target>
        </trans-unit>
        <trans-unit id="48532c1621002093d77ee956f1e52d70bc16b5b2" translate="yes" xml:space="preserve">
          <source>In most of the places where strings are used, we conceptualize the string as containing text characters&amp;mdash;the same kind of characters found in buffers or files. Occasionally Lisp programs use strings that conceptually contain keyboard characters; for example, they may be key sequences or keyboard macro definitions. However, storing keyboard characters in a string is a complex matter, for reasons of historical compatibility, and it is not always possible.</source>
          <target state="translated">文字列が使用されるほとんどの場所では、文字列をテキスト文字を含むものとして概念化しています。これは、バッファやファイルにあるのと同じ種類の文字です。時折、Lispプログラムは概念的にキーボード文字を含む文字列を使用します。たとえば、キーシーケンスやキーボードマクロ定義などです。ただし、キーボード文字を文字列に格納することは、歴史的な互換性のために複雑な問題であり、常に可能であるとは限りません。</target>
        </trans-unit>
        <trans-unit id="5f4144091cc9aca1cd2f8e02b0fccbdf93c70e06" translate="yes" xml:space="preserve">
          <source>In most programming languages, it is impossible to have a function without a name. In Lisp, a function has no intrinsic name. A lambda expression can be called as a function even though it has no name; to emphasize this, we also call it an &lt;em&gt;anonymous function&lt;/em&gt; (see &lt;a href=&quot;anonymous-functions#Anonymous-Functions&quot;&gt;Anonymous Functions&lt;/a&gt;). A named function in Lisp is just a symbol with a valid function in its function cell (see &lt;a href=&quot;defining-functions#Defining-Functions&quot;&gt;Defining Functions&lt;/a&gt;).</source>
          <target state="translated">ほとんどのプログラミング言語では、名前のない関数を持つことは不可能です。Lispでは、関数に固有の名前はありません。ラムダ式は、名前がなくても関数として呼び出すことができます。これを強調するために、我々はまた、それを呼び出す&lt;em&gt;匿名関数&lt;/em&gt;（参照&lt;a href=&quot;anonymous-functions#Anonymous-Functions&quot;&gt;無名関数を&lt;/a&gt;）。Lispの名前付き関数は、関数セルに有効な関数がある単なるシンボルです（関数の&lt;a href=&quot;defining-functions#Defining-Functions&quot;&gt;定義を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="717022d1f6adfca4a3a7968227e86d9f8fd9f6f0" translate="yes" xml:space="preserve">
          <source>In most ways, a minibuffer is a normal Emacs buffer. Most operations &lt;em&gt;within&lt;/em&gt; a buffer, such as editing commands, work normally in a minibuffer. However, many operations for managing buffers do not apply to minibuffers. The name of a minibuffer always has the form &amp;lsquo;</source>
          <target state="translated">ほとんどの場合、ミニバッファーは通常のEmacsバッファーです。コマンドの編集など、バッファ&lt;em&gt;内の&lt;/em&gt;ほとんどの操作&lt;em&gt;は&lt;/em&gt;、通常、ミニバッファで機能します。ただし、バッファを管理するための多くの操作は、ミニバッファには適用されません。ミニバッファの名前は常に 'の形式になります</target>
        </trans-unit>
        <trans-unit id="2561cd793393aff7d27fa03dc11a09e0ffcec475" translate="yes" xml:space="preserve">
          <source>In one special case, &lt;var&gt;pos-or-area&lt;/var&gt; is a list containing a symbol (one of the symbols listed above) instead of just the symbol. This happens after the imaginary prefix keys for the event are registered by Emacs. See &lt;a href=&quot;key-sequence-input#Key-Sequence-Input&quot;&gt;Key Sequence Input&lt;/a&gt;.</source>
          <target state="translated">1つの特殊なケースでは、 &lt;var&gt;pos-or-area&lt;/var&gt; は、シンボルだけでなく、シンボル（上記のシンボルの1つ）を含むリストです。これは、イベントの架空のプレフィックスキーがEmacsによって登録された後に発生します。&lt;a href=&quot;key-sequence-input#Key-Sequence-Input&quot;&gt;キーシーケンス入力を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="40058b1b79d94d51db03317b307ab30a9e089207" translate="yes" xml:space="preserve">
          <source>In order for a symbol to be an error symbol, it must be defined with &lt;code&gt;define-error&lt;/code&gt; which takes a parent condition (defaults to &lt;code&gt;error&lt;/code&gt;). This parent defines the conditions that this kind of error belongs to. The transitive set of parents always includes the error symbol itself, and the symbol &lt;code&gt;error&lt;/code&gt;. Because quitting is not considered an error, the set of parents of &lt;code&gt;quit&lt;/code&gt; is just &lt;code&gt;(quit)&lt;/code&gt;.</source>
          <target state="translated">シンボルがエラーシンボルであるためには、親条件をとる &lt;code&gt;define-error&lt;/code&gt; で定義する必要があります（デフォルトは &lt;code&gt;error&lt;/code&gt; ）。この親は、この種のエラーが属する条件を定義します。親の推移的なセットには、常にエラーシンボル自体とシンボル &lt;code&gt;error&lt;/code&gt; が含まれます。終了はエラーとはみなされないため、両親の一連の &lt;code&gt;quit&lt;/code&gt; 単にある &lt;code&gt;(quit)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="42862e17fb0b9045574c0488aeeff987c7b035ab" translate="yes" xml:space="preserve">
          <source>In order for compilation of macro calls to work, the macros must already be defined in Lisp when the calls to them are compiled. The compiler has a special feature to help you do this: if a file being compiled contains a &lt;code&gt;defmacro&lt;/code&gt; form, the macro is defined temporarily for the rest of the compilation of that file.</source>
          <target state="translated">マクロ呼び出しのコンパイルが機能するためには、マクロへの呼び出しがコンパイルされるときに、マクロがLispですでに定義されている必要があります。コンパイラには、これを行うのに役立つ特別な機能があります。コンパイル中のファイルに &lt;code&gt;defmacro&lt;/code&gt; 形式が含まれている場合、そのファイルの残りのコンパイルのためにマクロが一時的に定義されます。</target>
        </trans-unit>
        <trans-unit id="007cc651440219a61408c3deac9dfe41920a80bf" translate="yes" xml:space="preserve">
          <source>In order to extract the local part of the file&amp;rsquo;s name of a temporary file, use &lt;code&gt;file-local-name&lt;/code&gt; (see &lt;a href=&quot;magic-file-names#Magic-File-Names&quot;&gt;Magic File Names&lt;/a&gt;).</source>
          <target state="translated">一時ファイルのファイル名のローカル部分を抽出するには、 &lt;code&gt;file-local-name&lt;/code&gt; を使用します（&lt;a href=&quot;magic-file-names#Magic-File-Names&quot;&gt;Magic File Namesを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="02b3ec04225a3187705865de19dd49a2f10d82cd" translate="yes" xml:space="preserve">
          <source>In order to find out which window or frame was selected the last time window change functions were run, the following functions can be used:</source>
          <target state="translated">前回のウィンドウ変更関数の実行時に、どのウィンドウやフレームが選択されていたかを調べるには、以下の関数を使用します。</target>
        </trans-unit>
        <trans-unit id="4aa759b30fc1bac4367e22f29f78fa95acabc797" translate="yes" xml:space="preserve">
          <source>In order to give a child frame a draggable header or mode line, the window parameters &lt;code&gt;mode-line-format&lt;/code&gt; and &lt;code&gt;header-line-format&lt;/code&gt; are handy (see &lt;a href=&quot;window-parameters#Window-Parameters&quot;&gt;Window Parameters&lt;/a&gt;). These allow to remove an unwanted mode line (when &lt;code&gt;drag-with-header-line&lt;/code&gt; is chosen) and to remove mouse-sensitive areas which might interfere with frame dragging.</source>
          <target state="translated">子フレームにドラッグ可能なヘッダーまたはモードラインを与えるために、ウィンドウパラメーター &lt;code&gt;mode-line-format&lt;/code&gt; および &lt;code&gt;header-line-format&lt;/code&gt; が便利です（&lt;a href=&quot;window-parameters#Window-Parameters&quot;&gt;ウィンドウパラメーターを&lt;/a&gt;参照）。これらにより、不要なモードラインを削除し（ &lt;code&gt;drag-with-header-line&lt;/code&gt; が選択されている場合）、フレームのドラッグを妨げる可能性のあるマウスの影響を受けやすい領域を削除できます。</target>
        </trans-unit>
        <trans-unit id="3a1da75035de559e954ff07f12d67704d95cfb68" translate="yes" xml:space="preserve">
          <source>In order to prevent the hook functions from being called more than once for the same part of the buffer, you can use the variable &lt;code&gt;buffer-access-fontified-property&lt;/code&gt;.</source>
          <target state="translated">フック関数がバッファーの同じ部分に対して複数回呼び出されるのを防ぐために、変数 &lt;code&gt;buffer-access-fontified-property&lt;/code&gt; を使用できます。</target>
        </trans-unit>
        <trans-unit id="ce8866ba225f4a0e162725c09d5505ceaec41ba9" translate="yes" xml:space="preserve">
          <source>In order to see how this new, modified form works, delete any frame showing</source>
          <target state="translated">この新しい修正されたフォームがどのように動作するかを確認するには、以下のようなフレームを削除してください。</target>
        </trans-unit>
        <trans-unit id="25d21175a564e227d0d2be93a38559526ba4e991" translate="yes" xml:space="preserve">
          <source>In order to use Edebug to debug Lisp code, you must first &lt;em&gt;instrument&lt;/em&gt; the code. Instrumenting code inserts additional code into it, to invoke Edebug at the proper places.</source>
          <target state="translated">Edebugを使用してLispコードをデバッグするには、最初にコードを&lt;em&gt;インストルメント化&lt;/em&gt;する必要があります。インストルメンテーションコードは、適切な場所でEdebugを呼び出すために、追加のコードを挿入します。</target>
        </trans-unit>
        <trans-unit id="fe0db91a5b392657a0aca17c10f50da256d748a3" translate="yes" xml:space="preserve">
          <source>In ordinary usage, the difference between simple packages and multi-file packages is relatively unimportant; the Package Menu interface makes no distinction between them. However, the procedure for creating them differs, as explained in the following sections.</source>
          <target state="translated">通常の使い方では、単純なパッケージとマルチファイルパッケージの違いは比較的重要ではありません。しかし、以下のセクションで説明するように、それらを作成するための手順は異なります。</target>
        </trans-unit>
        <trans-unit id="4049b50b43320603134b658569956160c5b33eec" translate="yes" xml:space="preserve">
          <source>In other languages, an expression is text; it has no other form. In Lisp, an expression is primarily a Lisp object and only secondarily the text that is the object&amp;rsquo;s read syntax. Often there is no need to emphasize this distinction, but you must keep it in the back of your mind, or you will occasionally be very confused.</source>
          <target state="translated">他の言語では、式はテキストです。他の形はありません。Lispでは、式は主にLispオブジェクトであり、二次的にはオブジェクトの読み取り構文であるテキストです。多くの場合、この区別を強調する必要はありませんが、心の奥に置いておく必要があります。そうしないと、非常に混乱することがあります。</target>
        </trans-unit>
        <trans-unit id="b28e79f39397b0edb42bffc1a990b7fa7d5f45bc" translate="yes" xml:space="preserve">
          <source>In other words, after the end of a group, the matcher remembers the beginning and end of the text matched by that group. Later on in the regular expression you can use &amp;lsquo;</source>
          <target state="translated">言い換えると、グループの終了後、マッチャーはそのグループによって一致したテキストの開始と終了を記憶します。後で正規表現で使用できます '</target>
        </trans-unit>
        <trans-unit id="73dca98bad9f727764c940e829d2b4567f5194c0" translate="yes" xml:space="preserve">
          <source>In other words, the string character with the &lt;code&gt;cursor&lt;/code&gt; property of any non-&lt;code&gt;nil&lt;/code&gt; value is the character where to display the cursor. The value of the property says for which buffer positions to display the cursor there. If the value is an integer &lt;var&gt;n&lt;/var&gt;, the cursor is displayed there when point is anywhere between the beginning of the overlay or &lt;code&gt;display&lt;/code&gt; property and &lt;var&gt;n&lt;/var&gt; positions after that. If the value is anything else and non-&lt;code&gt;nil&lt;/code&gt;, the cursor is displayed there only when point is at the beginning of the &lt;code&gt;display&lt;/code&gt; property or at &lt;code&gt;overlay-start&lt;/code&gt;.</source>
          <target state="translated">つまり、 &lt;code&gt;nil&lt;/code&gt; 以外の値の &lt;code&gt;cursor&lt;/code&gt; プロパティを持つ文字列文字は、カーソルを表示する文字です。プロパティの値は、カーソルをそこに表示するバッファ位置を示します。値が整数 &lt;var&gt;n&lt;/var&gt; の場合、ポイントがオーバーレイまたは &lt;code&gt;display&lt;/code&gt; プロパティの先頭とその後の &lt;var&gt;n&lt;/var&gt; 位置の間のどこかにあると、カーソルがそこに表示されます。値がそれ以外で &lt;code&gt;nil&lt;/code&gt; 以外の場合、カーソルは、ポイントが &lt;code&gt;display&lt;/code&gt; プロパティの先頭または &lt;code&gt;overlay-start&lt;/code&gt; にある場合にのみ表示されます。</target>
        </trans-unit>
        <trans-unit id="342b05b7073d64e941e7a9180ce0ab73ce5d1977" translate="yes" xml:space="preserve">
          <source>In particular, &lt;code&gt;delete-windows-on&lt;/code&gt; (see &lt;a href=&quot;deleting-windows#Deleting-Windows&quot;&gt;Deleting Windows&lt;/a&gt;) handles case (2) by deleting the associated frame and case (3) by showing another buffer in that frame&amp;rsquo;s only window. The function &lt;code&gt;replace-buffer-in-windows&lt;/code&gt; (see &lt;a href=&quot;buffers-and-windows#Buffers-and-Windows&quot;&gt;Buffers and Windows&lt;/a&gt;) which is called when a buffer gets killed, deletes the window in case (1) and behaves like &lt;code&gt;delete-windows-on&lt;/code&gt; otherwise.</source>
          <target state="translated">特に、 &lt;code&gt;delete-windows-on&lt;/code&gt; （「ウィンドウの&lt;a href=&quot;deleting-windows#Deleting-Windows&quot;&gt;削除」を&lt;/a&gt;参照）は、関連するフレームを削除することでケース（2）を処理し、そのフレームの唯一のウィンドウに別のバッファーを表示することでケース（3）を処理します。関数 &lt;code&gt;replace-buffer-in-windows&lt;/code&gt; （「&lt;a href=&quot;buffers-and-windows#Buffers-and-Windows&quot;&gt;BuffersとWindows&lt;/a&gt;」を参照）は、バッファーが強制終了されたときに呼び出され、（1）の場合はウィンドウを削除し、それ以外の場合は &lt;code&gt;delete-windows-on&lt;/code&gt; のように動作します。</target>
        </trans-unit>
        <trans-unit id="ae990d311270dc72ee6facabe1f2c786eb8e3f14" translate="yes" xml:space="preserve">
          <source>In particular, mutating the returned value may inadvertently change another string, alter a constant string in the program, or even raise an error. To obtain a string that you can safely mutate, use &lt;code&gt;copy-sequence&lt;/code&gt; on the result.</source>
          <target state="translated">特に、戻り値を変更すると、誤って別の文字列が変更されたり、プログラム内の定数文字列が変更されたり、エラーが発生したりする可能性があります。安全に変更できる文字列を取得するには、結果に &lt;code&gt;copy-sequence&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="d8c72f894595d295da4116cddb04e4987b994ba0" translate="yes" xml:space="preserve">
          <source>In particular, under X (but not when building with GTK+), the frame&amp;rsquo;s outer border can be used. On MS-Windows, specifying a non-zero outer border width will show a one-pixel wide external border. Under all window-systems, the internal border can be used. In either case, it&amp;rsquo;s advisable to disable a child frame&amp;rsquo;s window manager decorations with the &lt;code&gt;undecorated&lt;/code&gt; frame parameter (see &lt;a href=&quot;management-parameters#Management-Parameters&quot;&gt;Management Parameters&lt;/a&gt;).</source>
          <target state="translated">特に、Xの下（GTK +でビルドする場合は除く）では、フレームの外側の境界線を使用できます。 MS-Windowsでは、ゼロ以外の外側の境界線の幅を指定すると、1ピクセル幅の外側の境界線が表示されます。すべてのウィンドウシステムで、内部境界線を使用できます。いずれの場合も、装飾されて &lt;code&gt;undecorated&lt;/code&gt; フレームパラメータを使用して子フレームのウィンドウマネージャの装飾を無効にすることをお勧めします（&lt;a href=&quot;management-parameters#Management-Parameters&quot;&gt;管理パラメータを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="785c848b7a9c76188153b98dc766e9eee3d7f299" translate="yes" xml:space="preserve">
          <source>In practice not all of the areas shown in the drawing will or may be present. The meaning of these areas is described below.</source>
          <target state="translated">実際には、図面に示された領域の全てが存在するとは限らないし、存在してもよい。これらの領域の意味を以下に説明する。</target>
        </trans-unit>
        <trans-unit id="1a24ae50708083315e6e5d71edf56c47415c18d3" translate="yes" xml:space="preserve">
          <source>In practice this means that &lt;code&gt;display-buffer&lt;/code&gt; builds a list of all action functions specified by these display actions. The first element of this list is the first action function specified by &lt;code&gt;display-buffer-overriding-action&lt;/code&gt;, if any. Its last element is &lt;code&gt;display-buffer-pop-up-frame&lt;/code&gt;&amp;mdash;the last action function specified by &lt;code&gt;display-buffer-fallback-action&lt;/code&gt;. Duplicates are not removed from this list&amp;mdash;hence one and the same action function may be called multiple times during one call of &lt;code&gt;display-buffer&lt;/code&gt;.</source>
          <target state="translated">実際には、これは、 &lt;code&gt;display-buffer&lt;/code&gt; がこれらの表示アクションによって指定されたすべてのアクション関数のリストを作成することを意味します。このリストの最初の要素は、 &lt;code&gt;display-buffer-overriding-action&lt;/code&gt; （存在する場合）によって指定された最初のアクション関数です。その最後の要素は、 &lt;code&gt;display-buffer-pop-up-frame&lt;/code&gt; &amp;mdash;display &lt;code&gt;display-buffer-fallback-action&lt;/code&gt; 指定された最後のアクション関数です。重複はこのリストから削除されません。したがって、 &lt;code&gt;display-buffer&lt;/code&gt; の1回の呼び出し中に、1つの同じアクション関数が複数回呼び出される可能性があります。</target>
        </trans-unit>
        <trans-unit id="069dde31ed88efd7662427ed0d83c24aecd85cef" translate="yes" xml:space="preserve">
          <source>In practice, most &amp;lsquo;</source>
          <target state="translated">実際には、ほとんどの '</target>
        </trans-unit>
        <trans-unit id="dff22f2148342d55185406b93857c7cd707282f3" translate="yes" xml:space="preserve">
          <source>In practice, nearly all functions have names, and are referred to by their names. You can create a named Lisp function by defining a lambda expression and putting it in a function cell (see &lt;a href=&quot;function-cells#Function-Cells&quot;&gt;Function Cells&lt;/a&gt;). However, it is more common to use the &lt;code&gt;defun&lt;/code&gt; special form, described in the next section. See &lt;a href=&quot;defining-functions#Defining-Functions&quot;&gt;Defining Functions&lt;/a&gt;.</source>
          <target state="translated">実際には、ほとんどすべての関数に名前があり、それらの名前で参照されます。あなたは（参照ラムダ式を定義し、機能セルにそれを置くことによって名付けられたLisp関数を作成することができます&lt;a href=&quot;function-cells#Function-Cells&quot;&gt;機能セルを&lt;/a&gt;）。ただし、次のセクションで説明する &lt;code&gt;defun&lt;/code&gt; 特殊フォームを使用するのがより一般的です。&lt;a href=&quot;defining-functions#Defining-Functions&quot;&gt;関数の定義を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="e2ec4dd56177cba6f1cdca6d305d727013f82bc9" translate="yes" xml:space="preserve">
          <source>In practice, you can usually use the text property search functions in place of explicit interval boundaries. You can think of them as finding the boundaries of intervals, assuming that intervals are always coalesced whenever possible. See &lt;a href=&quot;property-search#Property-Search&quot;&gt;Property Search&lt;/a&gt;.</source>
          <target state="translated">実際には、通常、明示的な間隔境界の代わりにテキストプロパティ検索関数を使用できます。可能な場合は常に間隔が合体すると仮定すると、間隔の境界を見つけることと考えることができます。&lt;a href=&quot;property-search#Property-Search&quot;&gt;プロパティ検索を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="595414a18f0f6814ac8aec499699ba0cadf3010e" translate="yes" xml:space="preserve">
          <source>In principle, if you want an array of text characters, you could use either a string or a vector. In practice, we always choose strings for such applications, for four reasons:</source>
          <target state="translated">原則として、テキスト文字の配列が必要な場合は、文字列かベクトルのどちらかを使用することができます。実際には、このようなアプリケーションでは、次の4つの理由から常に文字列を選択します。</target>
        </trans-unit>
        <trans-unit id="952a69bffe57014633d87ea51d91051b5c23b497" translate="yes" xml:space="preserve">
          <source>In principle, you can assign a variable value to any symbol with &lt;code&gt;setq&lt;/code&gt;, whether or not it has first been defined as a variable. However, you ought to write a variable definition for each global variable that you want to use; otherwise, your Lisp program may not act correctly if it is evaluated with lexical scoping enabled (see &lt;a href=&quot;variable-scoping#Variable-Scoping&quot;&gt;Variable Scoping&lt;/a&gt;).</source>
          <target state="translated">原則として、最初に変数として定義されているかどうかに関係なく、 &lt;code&gt;setq&lt;/code&gt; を使用して任意のシンボルに変数値を割り当てることができます。ただし、使用するグローバル変数ごとに変数定義を作成する必要があります。そうしないと、字句スコープを有効にして評価した場合、Lispプログラムが正しく動作しない可能性があります（&lt;a href=&quot;variable-scoping#Variable-Scoping&quot;&gt;変数スコープを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="59a81a18a5d27bbbef59498c3ff3190989d0d540" translate="yes" xml:space="preserve">
          <source>In short, a keymap entry may be a keymap, a command, a keyboard macro, a symbol that leads to one of them, or &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">つまり、キーマップエントリは、キーマップ、コマンド、キーボードマクロ、それらの1つにつながる記号、または &lt;code&gt;nil&lt;/code&gt; の場合があります。</target>
        </trans-unit>
        <trans-unit id="64a6416d90974dbdcf9b5cf8181346f0fcaef6ea" translate="yes" xml:space="preserve">
          <source>In simple cases, all you need to specify is the mapping to lower-case; the three related tables will be calculated automatically from that one.</source>
          <target state="translated">単純な場合は、小文字へのマッピングを指定するだけで、関連する3つのテーブルはその1つから自動的に計算されます。</target>
        </trans-unit>
        <trans-unit id="ca3f716cf86956eff115da7250837a9a9ae0da62" translate="yes" xml:space="preserve">
          <source>In some cases, a leading &amp;lsquo;</source>
          <target state="translated">場合によっては、先頭の '</target>
        </trans-unit>
        <trans-unit id="51c6be916769f1ca362110d817b3845ee05a7c40" translate="yes" xml:space="preserve">
          <source>In some cases, it is important to control the relative ordering of functions on the hook. The optional argument &lt;var&gt;depth&lt;/var&gt; lets you indicate where the function should be inserted in the list: it should then be a number between -100 and 100 where the higher the value, the closer to the end of the list the function should go. The &lt;var&gt;depth&lt;/var&gt; defaults to 0 and for backward compatibility when &lt;var&gt;depth&lt;/var&gt; is a non-nil symbol it is interpreted as a depth of 90. Furthermore, when &lt;var&gt;depth&lt;/var&gt; is strictly greater than 0 the function is added &lt;em&gt;after&lt;/em&gt; rather than before functions of the same depth. One should never use a depth of 100 (or -100), because one can never be sure that no other function will ever need to come before (or after) us.</source>
          <target state="translated">場合によっては、フック上の関数の相対的な順序を制御することが重要です。オプションの引数の &lt;var&gt;depth&lt;/var&gt; 使用すると、関数をリストのどこに挿入するかを指定できます。値が大きいほど、関数がリストの最後に近づくように、-100から100までの数値にする必要があります。 &lt;var&gt;depth&lt;/var&gt; が0および下位互換性のためのデフォルトは、 &lt;var&gt;depth&lt;/var&gt; 非ゼロシンボルである、場合は、さらに90の深さとして解釈される &lt;var&gt;depth&lt;/var&gt; 0よりも厳密に大きい機能が追加され&lt;em&gt;た後&lt;/em&gt;ではなく、同じ深さの関数の前に。 100（または-100）の深さを使用しないでください。他の関数が私たちの前（または後）に来る必要がないことを確信できないからです。</target>
        </trans-unit>
        <trans-unit id="65dfdc7d279aaa17d921d1528c2b2fe56c2c0a4d" translate="yes" xml:space="preserve">
          <source>In some cases, text lines are truncated on the screen rather than continued onto additional screen lines. In these cases, &lt;code&gt;vertical-motion&lt;/code&gt; moves point much like &lt;code&gt;forward-line&lt;/code&gt;. See &lt;a href=&quot;truncation#Truncation&quot;&gt;Truncation&lt;/a&gt;.</source>
          <target state="translated">場合によっては、テキスト行は、追加の画面行に続くのではなく、画面上で切り捨てられます。これらの場合、 &lt;code&gt;vertical-motion&lt;/code&gt; は &lt;code&gt;forward-line&lt;/code&gt; ようにポイントします。&lt;a href=&quot;truncation#Truncation&quot;&gt;切り捨てを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="4582e0d4f2cc8e2368ad7a2f683a1a7484ac075b" translate="yes" xml:space="preserve">
          <source>In some cases, the option is followed in the command line by an argument. In these cases, the &lt;var&gt;handler-function&lt;/var&gt; can find all the remaining command-line arguments in the variable &lt;code&gt;command-line-args-left&lt;/code&gt; (see below). (The entire list of command-line arguments is in &lt;code&gt;command-line-args&lt;/code&gt;.)</source>
          <target state="translated">場合によっては、コマンドラインでオプションの後に引数が続きます。このような場合、 &lt;var&gt;handler-function&lt;/var&gt; は、変数 &lt;code&gt;command-line-args-left&lt;/code&gt; で残りのすべてのコマンドライン引数を見つけることができます（以下を参照）。（コマンドライン引数の全リストは &lt;code&gt;command-line-args&lt;/code&gt; にあります。）</target>
        </trans-unit>
        <trans-unit id="878c8864da92eab3f1063c3c626126be65624841" translate="yes" xml:space="preserve">
          <source>In some configurations, Emacs cannot display a real dialog box; so instead it displays the same items in a pop-up menu in the center of the frame.</source>
          <target state="translated">いくつかの設定では、Emacs は実際のダイアログボックスを表示できないため、フレームの中央にポップアップメニューで同じ項目を表示します。</target>
        </trans-unit>
        <trans-unit id="4e6989e3c48ebc292a0fb0be926a8320dfd01322" translate="yes" xml:space="preserve">
          <source>In some functions (such as &lt;code&gt;read-quoted-char&lt;/code&gt;),</source>
          <target state="translated">一部の関数（ &lt;code&gt;read-quoted-char&lt;/code&gt; など）では、</target>
        </trans-unit>
        <trans-unit id="623f15e33a88f6fded6d8865aae03ac806476d9f" translate="yes" xml:space="preserve">
          <source>In some ways, the Button package duplicates the functionality in the Widget package. See &lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/widget/index.html#Top&quot;&gt;Introduction&lt;/a&gt; in</source>
          <target state="translated">いくつかの点で、ButtonパッケージはWidgetパッケージの機能を複製します。の&lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/widget/index.html#Top&quot;&gt;概要&lt;/a&gt;を参照してください</target>
        </trans-unit>
        <trans-unit id="56e23b6ebee018ae84e4594f62dc43eca78b4394" translate="yes" xml:space="preserve">
          <source>In strings and buffers, the only control characters allowed are those that exist in</source>
          <target state="translated">文字列やバッファで許可される制御文字は</target>
        </trans-unit>
        <trans-unit id="0183eea7f0857fe25abe600463b2305c9ae8752b" translate="yes" xml:space="preserve">
          <source>In subsequent sections, we will describe the details of what evaluation means for each kind of form.</source>
          <target state="translated">以降では、評価がどのような意味を持つのかを、各種類の形態ごとに詳細に説明していく。</target>
        </trans-unit>
        <trans-unit id="a57836ad148b9af16d39bd5e1f715466141037f4" translate="yes" xml:space="preserve">
          <source>In that case, the anonymous function is kept as a lambda expression in the compiled code. The byte-compiler cannot assume this list is a function, even though it looks like one, since it does not know that &lt;code&gt;change-property&lt;/code&gt; intends to use it as a function.</source>
          <target state="translated">その場合、無名関数はコンパイルされたコードでラムダ式として保持されます。バイトコンパイラは、 &lt;code&gt;change-property&lt;/code&gt; がこのリストを関数として使用することを意図していることを知らないため、このリストが関数のように見えても、関数であると見なすことはできません。</target>
        </trans-unit>
        <trans-unit id="b6abefb0ebc02351d5d08f8505d9c39811bfa807" translate="yes" xml:space="preserve">
          <source>In the</source>
          <target state="translated">の中では</target>
        </trans-unit>
        <trans-unit id="cc52d935c1f29304f640ff4f787b205caeb68ac4" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;rx&lt;/code&gt; notation (see &lt;a href=&quot;rx-notation#Rx-Notation&quot;&gt;Rx Notation&lt;/a&gt;), the regexp could be written</source>
          <target state="translated">&lt;code&gt;rx&lt;/code&gt; 表記（参照&lt;a href=&quot;rx-notation#Rx-Notation&quot;&gt;Rxの表記を&lt;/a&gt;、正規表現を書くことができます）</target>
        </trans-unit>
        <trans-unit id="edf58eb540efa82d8a13378501011be853119a74" translate="yes" xml:space="preserve">
          <source>In the above example, the index for &amp;lsquo;</source>
          <target state="translated">上記の例では、 'のインデックス</target>
        </trans-unit>
        <trans-unit id="e3f6d7d410589a0987a82033d6841e21fcb99c48" translate="yes" xml:space="preserve">
          <source>In the above pseudo-code, if a key sequence starts with a mouse event (see &lt;a href=&quot;mouse-events#Mouse-Events&quot;&gt;Mouse Events&lt;/a&gt;), that event&amp;rsquo;s position is used instead of point, and the event&amp;rsquo;s buffer is used instead of the current buffer. In particular, this affects how the &lt;code&gt;keymap&lt;/code&gt; and &lt;code&gt;local-map&lt;/code&gt; properties are looked up. If a mouse event occurs on a string embedded with a &lt;code&gt;display&lt;/code&gt;, &lt;code&gt;before-string&lt;/code&gt;, or &lt;code&gt;after-string&lt;/code&gt; property (see &lt;a href=&quot;special-properties#Special-Properties&quot;&gt;Special Properties&lt;/a&gt;), and the string has a non-&lt;code&gt;nil&lt;/code&gt;&lt;code&gt;keymap&lt;/code&gt; or &lt;code&gt;local-map&lt;/code&gt; property, that overrides the corresponding property in the underlying buffer text (i.e., the property specified by the underlying text is ignored).</source>
          <target state="translated">上記の擬似コードでは、キーシーケンスがマウスイベントで始まる場合（&lt;a href=&quot;mouse-events#Mouse-Events&quot;&gt;マウスイベントを&lt;/a&gt;参照）、ポイントの代わりにそのイベントの位置が使用され、現在のバッファの代わりにイベントのバッファが使用されます。特に、これは &lt;code&gt;keymap&lt;/code&gt; と &lt;code&gt;local-map&lt;/code&gt; プロパティの検索方法に影響します。 &lt;code&gt;display&lt;/code&gt; 、 &lt;code&gt;before-string&lt;/code&gt; 、または &lt;code&gt;after-string&lt;/code&gt; プロパティ（&lt;a href=&quot;special-properties#Special-Properties&quot;&gt;特別なプロパティを&lt;/a&gt;参照）が埋め込まれた文字列でマウスイベントが発生し、その文字列に &lt;code&gt;nil&lt;/code&gt; 以外の &lt;code&gt;keymap&lt;/code&gt; または &lt;code&gt;local-map&lt;/code&gt; マップがある場合 プロパティ。基になるバッファテキスト内の対応するプロパティを上書きします（つまり、基になるテキストで指定されたプロパティは無視されます）。</target>
        </trans-unit>
        <trans-unit id="27631bf78c7ae4e923152b090765e541b19e5a80" translate="yes" xml:space="preserve">
          <source>In the case of lexical bindings (see &lt;a href=&quot;variable-scoping#Variable-Scoping&quot;&gt;Variable Scoping&lt;/a&gt;), a closure is an object like any other in Emacs Lisp, and bindings in a closure are shared by any threads invoking the closure.</source>
          <target state="translated">字句バインディングの場合（&lt;a href=&quot;variable-scoping#Variable-Scoping&quot;&gt;Variable Scopingを&lt;/a&gt;参照）、クロージャはEmacs Lispの他のオブジェクトと同様のオブジェクトであり、クロージャ内のバインディングは、クロージャを呼び出すスレッドによって共有されます。</target>
        </trans-unit>
        <trans-unit id="59e0cecfabf4546ad2f48ca811a7e72617ebf6dd" translate="yes" xml:space="preserve">
          <source>In the customization buffer, each element is displayed and edited separately, according to the type specified for it.</source>
          <target state="translated">カスタマイズバッファでは、指定されたタイプに応じて、各要素が個別に表示・編集されます。</target>
        </trans-unit>
        <trans-unit id="b31bdf79753cfe29ec8e26d6c3395cd18ae6e0a8" translate="yes" xml:space="preserve">
          <source>In the customization buffer, the &lt;small&gt;CAR&lt;/small&gt; and &lt;small&gt;CDR&lt;/small&gt; are displayed and edited separately, each according to their specified type.</source>
          <target state="translated">カスタマイズバッファでは、&lt;small&gt;CAR&lt;/small&gt;と&lt;small&gt;CDR&lt;/small&gt;が個別に表示および編集され、それぞれが指定されたタイプに応じて表示されます。</target>
        </trans-unit>
        <trans-unit id="794a81a94829a19492d4fef3897a2f66fd03bedc" translate="yes" xml:space="preserve">
          <source>In the customization buffer, the user selects an alternative using a menu, and can then edit the value in the usual way for that alternative.</source>
          <target state="translated">カスタマイズバッファでは、ユーザーはメニューを使用して代替案を選択し、その代替案に対して通常の方法で値を編集することができます。</target>
        </trans-unit>
        <trans-unit id="77d73a55a4ef46351e5ba12b487904babc3187bd" translate="yes" xml:space="preserve">
          <source>In the documentation string of an autoloaded command (see &lt;a href=&quot;autoload#Autoload&quot;&gt;Autoload&lt;/a&gt;), these key-substitution sequences have an additional special effect: they cause</source>
          <target state="translated">自動ロードされたコマンドのドキュメント文字列（&lt;a href=&quot;autoload#Autoload&quot;&gt;Autoloadを&lt;/a&gt;参照）では、これらのキー置換シーケンスには追加の特殊効果があります。</target>
        </trans-unit>
        <trans-unit id="a60a213b91a605f64eb22b1f3ba89d0650b4a400" translate="yes" xml:space="preserve">
          <source>In the early days of Lisp, &lt;code&gt;progn&lt;/code&gt; was the only way to execute two or more forms in succession and use the value of the last of them. But programmers found they often needed to use a &lt;code&gt;progn&lt;/code&gt; in the body of a function, where (at that time) only one form was allowed. So the body of a function was made into an implicit &lt;code&gt;progn&lt;/code&gt;: several forms are allowed just as in the body of an actual &lt;code&gt;progn&lt;/code&gt;. Many other control structures likewise contain an implicit &lt;code&gt;progn&lt;/code&gt;. As a result, &lt;code&gt;progn&lt;/code&gt; is not used as much as it was many years ago. It is needed now most often inside an &lt;code&gt;unwind-protect&lt;/code&gt;, &lt;code&gt;and&lt;/code&gt;, &lt;code&gt;or&lt;/code&gt;, or in the &lt;var&gt;then&lt;/var&gt;-part of an &lt;code&gt;if&lt;/code&gt;.</source>
          <target state="translated">Lispの初期には、 &lt;code&gt;progn&lt;/code&gt; は、2つ以上のフォームを連続して実行し、最後のフォームの値を使用する唯一の方法でした。しかし、プログラマーは、関数の本体で &lt;code&gt;progn&lt;/code&gt; を使用する必要があることがよくあり、（当時は）1つの形式しか許可されていませんでした。そのため、関数の本体は暗黙の &lt;code&gt;progn&lt;/code&gt; になりました。実際の &lt;code&gt;progn&lt;/code&gt; の本体と同じように、いくつかの形式が許可されます。他の多くの制御構造も同様に暗黙の &lt;code&gt;progn&lt;/code&gt; 含んでいます。その結果、 &lt;code&gt;progn&lt;/code&gt; は何年も前ほど使用されていません。これは、内部で今、最も頻繁に必要とされている &lt;code&gt;unwind-protect&lt;/code&gt; は、 &lt;code&gt;and&lt;/code&gt; 、 &lt;code&gt;or&lt;/code&gt; 、またはで &lt;var&gt;then&lt;/var&gt; -part &lt;code&gt;if&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7158787e9fd5c853d586cfa0e51a5ed11d6bcd94" translate="yes" xml:space="preserve">
          <source>In the example below,</source>
          <target state="translated">下の例では</target>
        </trans-unit>
        <trans-unit id="6ae41878d5c3d4986d366e49c3e9a986cae7e077" translate="yes" xml:space="preserve">
          <source>In the example below, &lt;code&gt;fixup-whitespace&lt;/code&gt; is called the first time with point before the word &amp;lsquo;</source>
          <target state="translated">以下の例では、 &lt;code&gt;fixup-whitespace&lt;/code&gt; は、単語 'の前にポイントを付けて最初に呼び出されます。</target>
        </trans-unit>
        <trans-unit id="1159bcac76d9d797434640f0fdc5e48f8f16f786" translate="yes" xml:space="preserve">
          <source>In the example below, point is located on the line starting &amp;lsquo;</source>
          <target state="translated">以下の例では、ポイントは 'で始まる線上にあります。</target>
        </trans-unit>
        <trans-unit id="41e79dffa91b26c5c432c03364763e538453a3a0" translate="yes" xml:space="preserve">
          <source>In the example below, the Lisp program reads the character</source>
          <target state="translated">以下の例では、Lispプログラムは文字</target>
        </trans-unit>
        <trans-unit id="6c6b370e3f7d29753468f7d7c39505a6457cb137" translate="yes" xml:space="preserve">
          <source>In the example below, the first process is started and runs (rather, sleeps) for 100 seconds (the output buffer &amp;lsquo;</source>
          <target state="translated">以下の例では、最初のプロセスが開始され、100秒間実行（スリープ）されます（出力バッファー '</target>
        </trans-unit>
        <trans-unit id="2cbe7de5e5f4171a8b0909e3ea37d9411601b61f" translate="yes" xml:space="preserve">
          <source>In the example below, the returned alist indicates that the key</source>
          <target state="translated">以下の例では、返された alist は、キー</target>
        </trans-unit>
        <trans-unit id="21f639f7916c0989e45d99b6f8d95bb479e2a7dc" translate="yes" xml:space="preserve">
          <source>In the examples below, imagine that you&amp;rsquo;re in a buffer that looks like this:</source>
          <target state="translated">以下の例では、次のようなバッファにいると想像してください。</target>
        </trans-unit>
        <trans-unit id="45cdf70211c7a85bbbe2f457d2d568784938c5c8" translate="yes" xml:space="preserve">
          <source>In the examples below, the buffer &amp;lsquo;</source>
          <target state="translated">以下の例では、バッファ '</target>
        </trans-unit>
        <trans-unit id="50c103b8760cb1abed49a28229f31f25093e7fe2" translate="yes" xml:space="preserve">
          <source>In the examples below, we show the &lt;em&gt;display appearance&lt;/em&gt; of the buffer &lt;code&gt;foo&lt;/code&gt;, which changes with the value of &lt;code&gt;selective-display&lt;/code&gt;. The &lt;em&gt;contents&lt;/em&gt; of the buffer do not change.</source>
          <target state="translated">以下の例では、 &lt;code&gt;selective-display&lt;/code&gt; の値によって変化するバッファ &lt;code&gt;foo&lt;/code&gt; の&lt;em&gt;表示外観&lt;/em&gt;を示しています。バッファの&lt;em&gt;内容&lt;/em&gt;は変更されません。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8d8e5189aaefce12f30329357296c95e61a38bdb" translate="yes" xml:space="preserve">
          <source>In the first example below, the user types the character</source>
          <target state="translated">以下の最初の例では、ユーザは文字</target>
        </trans-unit>
        <trans-unit id="1bcb5b6f5d8b3ef6f45f427e9e77f07309f79243" translate="yes" xml:space="preserve">
          <source>In the first of the following examples, the string &amp;lsquo;</source>
          <target state="translated">次の例の最初の例では、文字列 '</target>
        </trans-unit>
        <trans-unit id="8d216f0c7f12baf6cd4ed80a6b27ab324e470109" translate="yes" xml:space="preserve">
          <source>In the first part of the following example, we list two files,</source>
          <target state="translated">以下の例の最初の部分では、2つのファイルをリストアップします。</target>
        </trans-unit>
        <trans-unit id="acff65f1c9d9496c4b122331f3a702dc9fa85418" translate="yes" xml:space="preserve">
          <source>In the following documentation, &lt;var&gt;spec&lt;/var&gt; refers to a data layout specification, &lt;code&gt;bindat-raw&lt;/code&gt; to a byte array, and &lt;var&gt;struct&lt;/var&gt; to an alist representing unpacked field data.</source>
          <target state="translated">次のドキュメントでは、 &lt;var&gt;spec&lt;/var&gt; はデータレイアウト仕様、 &lt;code&gt;bindat-raw&lt;/code&gt; はバイト配列、 &lt;var&gt;struct&lt;/var&gt; はアンパックされたフィールドデータを表すリストを指します。</target>
        </trans-unit>
        <trans-unit id="0f00c733671a04000a05bf717e25acf161719f5a" translate="yes" xml:space="preserve">
          <source>In the following example,</source>
          <target state="translated">以下の例では</target>
        </trans-unit>
        <trans-unit id="e2316694a9af81a8f03d3bab0408009a0c338429" translate="yes" xml:space="preserve">
          <source>In the following example, Emacs displays the prompt &amp;lsquo;</source>
          <target state="translated">次の例では、Emacsはプロンプトを表示します '</target>
        </trans-unit>
        <trans-unit id="4a721fdb8420736a6ae7cc10bb2e34400e9c7e6d" translate="yes" xml:space="preserve">
          <source>In the following example, a Lisp expression calls &lt;code&gt;backtrace&lt;/code&gt; explicitly. This prints the backtrace to the stream &lt;code&gt;standard-output&lt;/code&gt;, which, in this case, is the buffer &amp;lsquo;</source>
          <target state="translated">次の例では、Lisp式が &lt;code&gt;backtrace&lt;/code&gt; 明示的に呼び出します。これにより、バックトレースがストリームの &lt;code&gt;standard-output&lt;/code&gt; れます。この場合は、バッファです。</target>
        </trans-unit>
        <trans-unit id="95ec3b70ec2b6de3a44a863ec7979700ca8528bc" translate="yes" xml:space="preserve">
          <source>In the following example, assume that the file</source>
          <target state="translated">以下の例では、ファイル</target>
        </trans-unit>
        <trans-unit id="d4d9cd6735838e19fca58cfa4e5f227b1e63a68a" translate="yes" xml:space="preserve">
          <source>In the following example, assume that the first character in the buffer is &amp;lsquo;</source>
          <target state="translated">次の例では、バッファの最初の文字が 'であると想定しています。</target>
        </trans-unit>
        <trans-unit id="cbbae18ed437d3d1b7cd3f29fa619c133fefd3c5" translate="yes" xml:space="preserve">
          <source>In the following example, numerous symbols begin with the characters &amp;lsquo;</source>
          <target state="translated">次の例では、多数の記号が文字 'で始まります。</target>
        </trans-unit>
        <trans-unit id="1d8315041ff8cb6c06515b158189a3073ed152cc" translate="yes" xml:space="preserve">
          <source>In the following example, point is at the beginning of the second line:</source>
          <target state="translated">以下の例では、ポイントは2行目の先頭にあります。</target>
        </trans-unit>
        <trans-unit id="42ecbf1ba17019105911ffebbbf6edf40624a688" translate="yes" xml:space="preserve">
          <source>In the following example, point is initially at the beginning of the line. Then &lt;code&gt;(search-forward &quot;fox&quot;)&lt;/code&gt; moves point after the last letter of &amp;lsquo;</source>
          <target state="translated">次の例では、ポイントは最初は行の先頭にあります。次に、 &lt;code&gt;(search-forward &quot;fox&quot;)&lt;/code&gt; は 'の最後の文字の後にポイントを移動します</target>
        </trans-unit>
        <trans-unit id="4e4648a8ef8c97faf71ce36a2f1da992a66ce66a" translate="yes" xml:space="preserve">
          <source>In the following example, point is initially before the &amp;lsquo;</source>
          <target state="translated">次の例では、ポイントは最初は 'の前にあります</target>
        </trans-unit>
        <trans-unit id="998eebc83fc288fc771f6a8b8a1d104df394fe25" translate="yes" xml:space="preserve">
          <source>In the following example, point is initially located directly before the &amp;lsquo;</source>
          <target state="translated">次の例では、ポイントは最初は 'の直前にあります。</target>
        </trans-unit>
        <trans-unit id="222a580e4261f699fc64318a04a2725d2450a74c" translate="yes" xml:space="preserve">
          <source>In the following example, suppose that</source>
          <target state="translated">以下の例では、次のように仮定します。</target>
        </trans-unit>
        <trans-unit id="c4a412b551b194333428c49302d54e094323961e" translate="yes" xml:space="preserve">
          <source>In the following example, suppose that the current default directory has five files whose names begin with &amp;lsquo;</source>
          <target state="translated">次の例では、現在のデフォルトディレクトリに名前が 'で始まる5つのファイルがあるとします。</target>
        </trans-unit>
        <trans-unit id="5723aa0ef8724a536d5900f5c59be1d86438116d" translate="yes" xml:space="preserve">
          <source>In the following example, the &lt;code&gt;(list 4)&lt;/code&gt; that &lt;code&gt;delq&lt;/code&gt; attempts to match and the &lt;code&gt;(4)&lt;/code&gt; in the &lt;code&gt;sample-list&lt;/code&gt; are &lt;code&gt;equal&lt;/code&gt; but not &lt;code&gt;eq&lt;/code&gt;:</source>
          <target state="translated">次の例では、 &lt;code&gt;(list 4)&lt;/code&gt; こと &lt;code&gt;delq&lt;/code&gt; 試みが一致すると &lt;code&gt;(4)&lt;/code&gt; における &lt;code&gt;sample-list&lt;/code&gt; ある &lt;code&gt;equal&lt;/code&gt; なく、 &lt;code&gt;eq&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="49c3d7898ccead7f82ec14a83d5c284abbacaed2" translate="yes" xml:space="preserve">
          <source>In the following example, the function &lt;code&gt;simple-rec&lt;/code&gt; first advances point one word, then enters a recursive edit, printing out a message in the echo area. The user can then do any editing desired, and then type</source>
          <target state="translated">次の例では、関数 &lt;code&gt;simple-rec&lt;/code&gt; は最初にポイントを1ワード進め、次に再帰編集を入力して、エコー領域にメッセージを出力します。その後、ユーザーは必要な編集を行ってから、次のように入力できます。</target>
        </trans-unit>
        <trans-unit id="bdd55f89db54776fce5243ffc69b1e9e59acdf44" translate="yes" xml:space="preserve">
          <source>In the following example, the user enters &amp;lsquo;</source>
          <target state="translated">次の例では、ユーザーは「」と入力します。</target>
        </trans-unit>
        <trans-unit id="7407d41abc6236fc89ae0cd2ce1bcece190e1422" translate="yes" xml:space="preserve">
          <source>In the following example, the user may type a number of characters right after starting the evaluation of the form. After the &lt;code&gt;sleep-for&lt;/code&gt; finishes sleeping, &lt;code&gt;discard-input&lt;/code&gt; discards any characters typed during the sleep.</source>
          <target state="translated">次の例では、ユーザーはフォームの評価を開始した直後にいくつかの文字を入力できます。 &lt;code&gt;sleep-for&lt;/code&gt; がスリープを終了した後、 &lt;code&gt;discard-input&lt;/code&gt; は、スリープ中に入力されたすべての文字を破棄します。</target>
        </trans-unit>
        <trans-unit id="f7696bfce1413c1620baa40974e9b096f97b1062" translate="yes" xml:space="preserve">
          <source>In the following example, the user types in the octal number 177 (which is 127 in decimal).</source>
          <target state="translated">次の例では、ユーザは 8 進数 177 (10 進数では 127)を入力します。</target>
        </trans-unit>
        <trans-unit id="90031aaefbae5ba18088f25e005afdff8b8be5df" translate="yes" xml:space="preserve">
          <source>In the following example, we define a &lt;code&gt;change-property&lt;/code&gt; function that takes a function as its third argument, followed by a &lt;code&gt;double-property&lt;/code&gt; function that makes use of &lt;code&gt;change-property&lt;/code&gt; by passing it an anonymous function:</source>
          <target state="translated">次の例では、関数を3番目の引数として受け取る &lt;code&gt;change-property&lt;/code&gt; 関数を定義し、その後に無名関数を渡すことで &lt;code&gt;change-property&lt;/code&gt; を利用する &lt;code&gt;double-property&lt;/code&gt; 関数を定義します。</target>
        </trans-unit>
        <trans-unit id="9a1fd088e9ae4b7e83b043fac095f41e72df8bbd" translate="yes" xml:space="preserve">
          <source>In the following example, we make</source>
          <target state="translated">以下の例では</target>
        </trans-unit>
        <trans-unit id="f9648cfc2ef9e1392db8901e3933f175d8a84fca" translate="yes" xml:space="preserve">
          <source>In the following example, we offer the user an expression with initial text that is already a valid form:</source>
          <target state="translated">次の例では、すでに有効なフォームである初期テキストを持つ式をユーザーに提供しています。</target>
        </trans-unit>
        <trans-unit id="2e3e4218ff460b22a5180b17ddb295a8da5eceae" translate="yes" xml:space="preserve">
          <source>In the following example, we set the value of a symbol with &lt;code&gt;setq&lt;/code&gt;. Then we evaluate the symbol, and get back the value that &lt;code&gt;setq&lt;/code&gt; stored.</source>
          <target state="translated">次の例では、 &lt;code&gt;setq&lt;/code&gt; を使用してシンボルの値を設定します。次に、シンボルを評価し、 &lt;code&gt;setq&lt;/code&gt; が格納した値を取得します。</target>
        </trans-unit>
        <trans-unit id="f311afb8bd19dedc75d6adda2a147ef509e3a73e" translate="yes" xml:space="preserve">
          <source>In the following example, we use &lt;code&gt;call-process-region&lt;/code&gt; to run the &lt;code&gt;cat&lt;/code&gt; utility, with standard input being the first five characters in buffer &amp;lsquo;</source>
          <target state="translated">次の例では、 &lt;code&gt;call-process-region&lt;/code&gt; を使用して &lt;code&gt;cat&lt;/code&gt; ユーティリティを実行し、標準入力はバッファの最初の5文字です。</target>
        </trans-unit>
        <trans-unit id="2ed30191890b49ad905f6c690d281609333d59e9" translate="yes" xml:space="preserve">
          <source>In the following examples, we call &lt;code&gt;delete-horizontal-space&lt;/code&gt; four times, once on each line, with point between the second and third characters on the line each time.</source>
          <target state="translated">次の例では、 &lt;code&gt;delete-horizontal-space&lt;/code&gt; 4回、各行に1回呼び出し、そのたびに行の2番目と3番目の文字の間にポイントを置きます。</target>
        </trans-unit>
        <trans-unit id="d73b2eb7e108f2274f2167b405818a1a4e5e8de9" translate="yes" xml:space="preserve">
          <source>In the following four functions, &amp;ldquo;beginning&amp;rdquo; or &amp;ldquo;end&amp;rdquo; of buffer refers to the beginning or end of the accessible portion.</source>
          <target state="translated">以下の4つの機能において、バッファの「開始」または「終了」は、アクセス可能な部分の開始または終了を指します。</target>
        </trans-unit>
        <trans-unit id="b77941da969f1ea78534b72b05e1f2ecd1399269" translate="yes" xml:space="preserve">
          <source>In the functions below, &lt;var&gt;stream&lt;/var&gt; stands for an input stream (see the previous section). If &lt;var&gt;stream&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt; or omitted, it defaults to the value of &lt;code&gt;standard-input&lt;/code&gt;.</source>
          <target state="translated">以下の関数では、 &lt;var&gt;stream&lt;/var&gt; は入力ストリームを表します（前のセクションを参照）。場合 &lt;var&gt;stream&lt;/var&gt; ある &lt;code&gt;nil&lt;/code&gt; の値がデフォルト、または省略 &lt;code&gt;standard-input&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e02f70d33a63dec1a218a9f9fe21d0936515a768" translate="yes" xml:space="preserve">
          <source>In the functions below, &lt;var&gt;stream&lt;/var&gt; stands for an output stream. (See the previous section for a description of output streams. Also See &lt;a href=&quot;output-streams#external_002ddebugging_002doutput&quot;&gt;external-debugging-output&lt;/a&gt;, a useful stream value for debugging.) If &lt;var&gt;stream&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt; or omitted, it defaults to the value of &lt;code&gt;standard-output&lt;/code&gt;.</source>
          <target state="translated">以下の関数で、 &lt;var&gt;stream&lt;/var&gt; は出力ストリームを表します。（出力ストリームの説明については、前のセクションを参照してください。&lt;a href=&quot;output-streams#external_002ddebugging_002doutput&quot;&gt;デバッグに&lt;/a&gt;役立つストリーム値であるexternal-debugging-outputも参照してください。） &lt;var&gt;stream&lt;/var&gt; が &lt;code&gt;nil&lt;/code&gt; または省略されている場合、デフォルトで &lt;code&gt;standard-output&lt;/code&gt; の値になります。</target>
        </trans-unit>
        <trans-unit id="842ff05e729e0c493fb0e3ce6cf4160def60f98a" translate="yes" xml:space="preserve">
          <source>In the functions that have an argument &lt;var&gt;newname&lt;/var&gt;, if a file by the name of &lt;var&gt;newname&lt;/var&gt; already exists, the actions taken depend on the value of the argument &lt;var&gt;ok-if-already-exists&lt;/var&gt;:</source>
          <target state="translated">引数 &lt;var&gt;newname&lt;/var&gt; を持つ関数で、 &lt;var&gt;newname&lt;/var&gt; という名前のファイルがすでに存在する場合、実行されるアクションは引数 &lt;var&gt;ok-if-already-exists&lt;/var&gt; の値によって異なります。</target>
        </trans-unit>
        <trans-unit id="b9986edbcc327565facd71c28fb47353a1513f05" translate="yes" xml:space="preserve">
          <source>In the functions that have an argument &lt;var&gt;newname&lt;/var&gt;, if this argument is a directory name it is treated as if the nondirectory part of the source name were appended. Typically, a directory name is one that ends in &amp;lsquo;</source>
          <target state="translated">引数 &lt;var&gt;newname&lt;/var&gt; を持つ関数では、この引数がディレクトリ名の場合、ソース名の非ディレクトリ部分が追加されたかのように扱われます。通常、ディレクトリ名は 'で終わるものです。</target>
        </trans-unit>
        <trans-unit id="3ff38bdd102a36bf5dad69f0bd3a4c48bcbb2f33" translate="yes" xml:space="preserve">
          <source>In the minibuffer,</source>
          <target state="translated">ミニバッファの中で</target>
        </trans-unit>
        <trans-unit id="95d42950506f5e85d9c00b2291550dcad572692d" translate="yes" xml:space="preserve">
          <source>In the new syntax table, all characters are initially given the &amp;ldquo;inherit&amp;rdquo; (&amp;lsquo;</source>
          <target state="translated">新しい構文テーブルでは、すべての文字に最初に「継承」（ '</target>
        </trans-unit>
        <trans-unit id="654197206043d5aa17cba42455172c4d80bf915c" translate="yes" xml:space="preserve">
          <source>In the output, tab and newline appear as themselves.</source>
          <target state="translated">出力では、タブと改行がそれ自体で表示されます。</target>
        </trans-unit>
        <trans-unit id="f0a865aff1bbfb0c542ac415212a86fda6d690da" translate="yes" xml:space="preserve">
          <source>In the parse tree, each HTML node is represented by a list in which the first element is a symbol representing the node name, the second element is an alist of node attributes, and the remaining elements are the subnodes.</source>
          <target state="translated">構文解析ツリーでは、各 HTML ノードはリストで表され、最初の要素はノード名を表す記号、2 番目の要素はノード属性のリスト、残りの要素はサブノードです。</target>
        </trans-unit>
        <trans-unit id="a6aa826dba60e33cee2ff73324e1dfc071fd99de" translate="yes" xml:space="preserve">
          <source>In the previous section, the definition of &lt;code&gt;for&lt;/code&gt; was fixed as follows to make the expansion evaluate the macro arguments the proper number of times:</source>
          <target state="translated">前のセクションでは、 &lt;code&gt;for&lt;/code&gt; の定義を次のように修正して、展開でマクロ引数を適切な回数評価できるようにしました。</target>
        </trans-unit>
        <trans-unit id="d94acc49f6466170529c5b4de675f17843e1d018" translate="yes" xml:space="preserve">
          <source>In the previous sections we have described how to construct elaborate type specifications for &lt;code&gt;defcustom&lt;/code&gt;. In some cases you may want to give such a type specification a name. The obvious case is when you are using the same type for many user options: rather than repeat the specification for each option, you can give the type specification a name, and use that name each &lt;code&gt;defcustom&lt;/code&gt;. The other case is when a user option&amp;rsquo;s value is a recursive data structure. To make it possible for a datatype to refer to itself, it needs to have a name.</source>
          <target state="translated">前のセクションでは、 &lt;code&gt;defcustom&lt;/code&gt; の複雑な型仕様を構築する方法について説明しました。場合によっては、そのような型仕様に名前を付けたいことがあります。明らかなケースは、多くのユーザーオプションに同じタイプを使用している場合です。オプションごとに指定を繰り返すのではなく、タイプ指定に名前を付け、その名前を各 &lt;code&gt;defcustom&lt;/code&gt; に使用できます。もう1つのケースは、ユーザーオプションの値が再帰的なデータ構造である場合です。データ型がそれ自体を参照できるようにするには、名前が必要です。</target>
        </trans-unit>
        <trans-unit id="e1fe76b2ce299aa2f258889220086dc41caa10db" translate="yes" xml:space="preserve">
          <source>In the previous subsection we have described in detail how individual action functions interpret the action alist entries they care about. Here we give a reference list of all known action alist entries according to their symbols, together with their values and action functions (see &lt;a href=&quot;buffer-display-action-functions#Buffer-Display-Action-Functions&quot;&gt;Buffer Display Action Functions&lt;/a&gt;) that recognize them. Throughout this list, the terms &amp;ldquo;buffer&amp;rdquo; will refer to the buffer &lt;code&gt;display-buffer&lt;/code&gt; is supposed to display, and &amp;ldquo;value&amp;rdquo; refers to the entry&amp;rsquo;s value.</source>
          <target state="translated">前のサブセクションでは、個々のアクション関数が関心のあるアクションリストエントリをどのように解釈するかについて詳しく説明しました。ここでは、すべての既知のアクションリストエントリの参照リストを、それらのシンボルと、それらを認識する値およびアクション関数（&lt;a href=&quot;buffer-display-action-functions#Buffer-Display-Action-Functions&quot;&gt;バッファ表示アクション関数を&lt;/a&gt;参照）とともに示します。このリスト全体で、「バッファ」という用語は、表示されるはずのバッファの &lt;code&gt;display-buffer&lt;/code&gt; 指し、「値」はエントリの値を指します。</target>
        </trans-unit>
        <trans-unit id="70305cb871bf1fadf003b84d92f8f772b2e037ea" translate="yes" xml:space="preserve">
          <source>In the return value, &lt;var&gt;function&lt;/var&gt; is whatever was supplied as the &lt;small&gt;CAR&lt;/small&gt; of the evaluated list, or a &lt;code&gt;lambda&lt;/code&gt; expression in the case of a macro call. If the function has a &lt;code&gt;&amp;amp;rest&lt;/code&gt; argument, that is represented as the tail of the list &lt;var&gt;arg-values&lt;/var&gt;.</source>
          <target state="translated">戻り値では、 &lt;var&gt;function&lt;/var&gt; は評価されたリストの&lt;small&gt;CAR&lt;/small&gt;として提供されたもの、またはマクロ呼び出しの場合は &lt;code&gt;lambda&lt;/code&gt; 式です。関数に &lt;code&gt;&amp;amp;rest&lt;/code&gt; 引数がある場合、それはリスト &lt;var&gt;arg-values&lt;/var&gt; の末尾として表されます。</target>
        </trans-unit>
        <trans-unit id="a43342cb008eceb0301dec01749bcef5885ffad6" translate="yes" xml:space="preserve">
          <source>In the second expression, the local binding of &lt;code&gt;print-escape-newlines&lt;/code&gt; is in effect during the call to &lt;code&gt;prin1&lt;/code&gt;, but not during the printing of the result.</source>
          <target state="translated">2番目の式では、 &lt;code&gt;print-escape-newlines&lt;/code&gt; &lt;code&gt;prin1&lt;/code&gt; のローカルバインディングは、prin1の呼び出し中に有効になりますが、結果の印刷中には有効になりません。</target>
        </trans-unit>
        <trans-unit id="780bba30b6e90faed0e2ade0fdd2f1da2fdca85f" translate="yes" xml:space="preserve">
          <source>In the second variant, the choice of lines to hide is made automatically based on indentation. This variant is designed to be a user-level feature.</source>
          <target state="translated">2つ目のバリアントでは、非表示にする行の選択はインデントに基づいて自動的に行われます。このバリアントは、ユーザーレベルの機能として設計されています。</target>
        </trans-unit>
        <trans-unit id="bffc354f8e26188db7e818c849dff5db0c9e8f32" translate="yes" xml:space="preserve">
          <source>In the simplest case, &lt;var&gt;listname&lt;/var&gt; is an unquoted symbol naming a list; in that case, this macro is equivalent to &lt;code&gt;(prog1&amp;nbsp;(car&amp;nbsp;listname)&amp;nbsp;(setq&amp;nbsp;listname&amp;nbsp;(cdr&amp;nbsp;listname)))&lt;/code&gt;.</source>
          <target state="translated">最も単純なケースでは、 &lt;var&gt;listname&lt;/var&gt; は、リストに名前を付ける引用符で囲まれていない記号です。その場合、このマクロは &lt;code&gt;(prog1&amp;nbsp;(car&amp;nbsp;listname)&amp;nbsp;(setq&amp;nbsp;listname&amp;nbsp;(cdr&amp;nbsp;listname)))&lt;/code&gt; と同等です。</target>
        </trans-unit>
        <trans-unit id="6677923bd341b8f53bd4e45ad643c994637a35f0" translate="yes" xml:space="preserve">
          <source>In the simplest case, &lt;var&gt;separator-type&lt;/var&gt; consists of only dashes. That specifies the default kind of separator. (For compatibility, &lt;code&gt;&quot;&quot;&lt;/code&gt; and &lt;code&gt;-&lt;/code&gt; also count as separators.)</source>
          <target state="translated">最も単純なケースでは、 &lt;var&gt;separator-type&lt;/var&gt; はダッシュのみで構成されます。これは、デフォルトの種類のセパレーターを指定します。（互換性のために、 &lt;code&gt;&quot;&quot;&lt;/code&gt; と &lt;code&gt;-&lt;/code&gt; も区切り文字としてカウントされます。）</target>
        </trans-unit>
        <trans-unit id="4ac8ea59e19025468a89992b0f2dbc087cbc7d49" translate="yes" xml:space="preserve">
          <source>In the simplest case, any non-&lt;code&gt;nil&lt;/code&gt;&lt;code&gt;invisible&lt;/code&gt; property makes a character invisible. This is the default case&amp;mdash;if you don&amp;rsquo;t alter the default value of &lt;code&gt;buffer-invisibility-spec&lt;/code&gt;, this is how the &lt;code&gt;invisible&lt;/code&gt; property works. You should normally use &lt;code&gt;t&lt;/code&gt; as the value of the &lt;code&gt;invisible&lt;/code&gt; property if you don&amp;rsquo;t plan to set &lt;code&gt;buffer-invisibility-spec&lt;/code&gt; yourself.</source>
          <target state="translated">最も単純なケースでは、任意の非 &lt;code&gt;nil&lt;/code&gt; の &lt;code&gt;invisible&lt;/code&gt; プロパティは、文字が見えなくなります。これがデフォルトのケースです &lt;code&gt;buffer-invisibility-spec&lt;/code&gt; デフォルト値を変更しない場合、これが &lt;code&gt;invisible&lt;/code&gt; プロパティの動作方法です。 &lt;code&gt;buffer-invisibility-spec&lt;/code&gt; を自分で設定する予定がない場合は、通常、 &lt;code&gt;invisible&lt;/code&gt; プロパティの値として &lt;code&gt;t&lt;/code&gt; を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="b654a675313cc501deccb72dafb7cf632e0a67de" translate="yes" xml:space="preserve">
          <source>In the string representation, alphanumeric characters ordinarily stand for themselves; for example, &lt;code&gt;&quot;a&quot;&lt;/code&gt; represents</source>
          <target state="translated">文字列表現では、通常、英数字はそれ自体を表します。たとえば、 &lt;code&gt;&quot;a&quot;&lt;/code&gt; は</target>
        </trans-unit>
        <trans-unit id="68ea687212db99586a26415019a5a3e01bea5f4c" translate="yes" xml:space="preserve">
          <source>In the terminology of operating systems, a &lt;em&gt;process&lt;/em&gt; is a space in which a program can execute. Emacs runs in a process. Emacs Lisp programs can invoke other programs in processes of their own. These are called &lt;em&gt;subprocesses&lt;/em&gt; or &lt;em&gt;child processes&lt;/em&gt; of the Emacs process, which is their &lt;em&gt;parent process&lt;/em&gt;.</source>
          <target state="translated">オペレーティングシステムの用語では、&lt;em&gt;プロセス&lt;/em&gt;はプログラムが実行できるスペースです。Emacsはプロセスで実行されます。Emacs Lispプログラムは、独自のプロセスで他のプログラムを呼び出すことができます。これらは呼ばれている&lt;em&gt;サブプロセス&lt;/em&gt;や&lt;em&gt;子プロセス&lt;/em&gt;自分でEmacsプロセスの&lt;em&gt;親プロセス&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="20d433bd64cf194bf3401eb20026d1e5a072b7d8" translate="yes" xml:space="preserve">
          <source>In the unlikely event that you need a more general functionality than &lt;code&gt;custom-initialize-delay&lt;/code&gt; provides, you can use &lt;code&gt;before-init-hook&lt;/code&gt; (see &lt;a href=&quot;startup-summary#Startup-Summary&quot;&gt;Startup Summary&lt;/a&gt;).</source>
          <target state="translated">万が一、 &lt;code&gt;custom-initialize-delay&lt;/code&gt; が提供するよりも一般的な機能が必要な場合は、 &lt;code&gt;before-init-hook&lt;/code&gt; を使用できます（&lt;a href=&quot;startup-summary#Startup-Summary&quot;&gt;スタートアップの概要を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="653d17f655aa9bc207c0340a07989c300bfc7174" translate="yes" xml:space="preserve">
          <source>In the vector representation, each element of the vector represents an input event, in its Lisp form. See &lt;a href=&quot;input-events#Input-Events&quot;&gt;Input Events&lt;/a&gt;. For example, the vector &lt;code&gt;[?\C-x ?l]&lt;/code&gt; represents the key sequence</source>
          <target state="translated">ベクトル表現では、ベクトルの各要素はLisp形式で入力イベントを表します。&lt;a href=&quot;input-events#Input-Events&quot;&gt;入力イベントを&lt;/a&gt;参照してください。たとえば、ベクトル &lt;code&gt;[?\C-x ?l]&lt;/code&gt; はキーシーケンスを表します</target>
        </trans-unit>
        <trans-unit id="37545e5ede88b47c3c895f58d985de6aa2297176" translate="yes" xml:space="preserve">
          <source>In their most simple form of use, side windows allow to display specific buffers always in the same area of a frame. Hence they can be regarded as a generalization of the concept provided by &lt;code&gt;display-buffer-at-bottom&lt;/code&gt; (see &lt;a href=&quot;buffer-display-action-functions#Buffer-Display-Action-Functions&quot;&gt;Buffer Display Action Functions&lt;/a&gt;) to the remaining sides of a frame. With suitable customizations, however, side windows can be also used to provide frame layouts similar to those found in so-called integrated development environments (IDEs).</source>
          <target state="translated">最も単純な使用形態では、サイドウィンドウを使用すると、特定のバッファを常にフレームの同じ領域に表示できます。したがって、これらは、 &lt;code&gt;display-buffer-at-bottom&lt;/code&gt; （&lt;a href=&quot;buffer-display-action-functions#Buffer-Display-Action-Functions&quot;&gt;バッファ表示アクション関数を&lt;/a&gt;参照）によってフレームの残りの側に提供される概念の一般化と見なすことができます。ただし、適切にカスタマイズすれば、サイドウィンドウを使用して、いわゆる統合開発環境（IDE）で見られるものと同様のフレームレイアウトを提供することもできます。</target>
        </trans-unit>
        <trans-unit id="4da8e1cd8146f3a0b7e768a0095492966a0a3fcb" translate="yes" xml:space="preserve">
          <source>In theory, a theme file can also contain other Lisp forms, which would be evaluated when loading the theme, but that is bad form. To protect against loading themes containing malicious code, Emacs displays the source file and asks for confirmation from the user before loading any non-built-in theme for the first time. As such, themes are not ordinarily byte-compiled, and source files always take precedence when Emacs is looking for a theme to load.</source>
          <target state="translated">理論的には、テーマファイルには他の Lisp フォームも含まれている可能性があり、それはテーマを読み込むときに評価されますが、それは悪いフォームです。悪意のあるコードを含むテーマをロードしないようにするために、Emacsでは、内蔵されていないテーマを初めてロードする前に、ソースファイルを表示してユーザーに確認を求めます。このように、テーマは通常バイトコンパイルされておらず、Emacs が読み込むテーマを探す際には常にソースファイルが優先されます。</target>
        </trans-unit>
        <trans-unit id="bdc0c811869c12153b361b16802c27840ea05add" translate="yes" xml:space="preserve">
          <source>In these functions, the &lt;var&gt;process&lt;/var&gt; argument can be a process or the name of a process, or a buffer or buffer name (which stands for a process via &lt;code&gt;get-buffer-process&lt;/code&gt;). &lt;code&gt;nil&lt;/code&gt; means the current buffer&amp;rsquo;s process.</source>
          <target state="translated">これらの関数では、 &lt;var&gt;process&lt;/var&gt; 引数は、プロセスまたはプロセスの名前、あるいはバッファーまたはバッファー名（ &lt;code&gt;get-buffer-process&lt;/code&gt; を介したプロセスを表す）にすることができます。 &lt;code&gt;nil&lt;/code&gt; は、現在のバッファのプロセスを意味します。</target>
        </trans-unit>
        <trans-unit id="7889cf29aeb64d8679d013ba57b97d89a395974a" translate="yes" xml:space="preserve">
          <source>In this case &lt;code&gt;with-temp-buffer-window&lt;/code&gt; always makes a new parent window when it splits an existing window (see &lt;a href=&quot;temporary-displays#Temporary-Displays&quot;&gt;Temporary Displays&lt;/a&gt;). Otherwise, window splitting behaves as for &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">この場合 &lt;code&gt;with-temp-buffer-window&lt;/code&gt; は、既存のウィンドウを分割するときに常に新しい親ウィンドウを作成します（&lt;a href=&quot;temporary-displays#Temporary-Displays&quot;&gt;一時表示を&lt;/a&gt;参照）。それ以外の場合、ウィンドウ分割は &lt;code&gt;nil&lt;/code&gt; と同様に動作します。</target>
        </trans-unit>
        <trans-unit id="4aad296f13c9498890681b6eab23e4731825c14d" translate="yes" xml:space="preserve">
          <source>In this case &lt;code&gt;with-temp-buffer-window&lt;/code&gt; makes a new parent window when it splits a window and &lt;code&gt;temp-buffer-resize-mode&lt;/code&gt; is enabled (see &lt;a href=&quot;temporary-displays#Temporary-Displays&quot;&gt;Temporary Displays&lt;/a&gt;). Otherwise, window splitting behaves as for &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">この場合 &lt;code&gt;with-temp-buffer-window&lt;/code&gt; は、ウィンドウを分割し、 &lt;code&gt;temp-buffer-resize-mode&lt;/code&gt; が有効になっているときに新しい親ウィンドウを作成します（&lt;a href=&quot;temporary-displays#Temporary-Displays&quot;&gt;一時表示を&lt;/a&gt;参照）。それ以外の場合、ウィンドウ分割は &lt;code&gt;nil&lt;/code&gt; と同様に動作します。</target>
        </trans-unit>
        <trans-unit id="f92ba4ac4b99574f776831ff1c5804087ad33c57" translate="yes" xml:space="preserve">
          <source>In this case the &lt;code&gt;inhibit-same-window&lt;/code&gt; alist entry will successfully invalidate the &lt;code&gt;display-buffer-same-window&lt;/code&gt; specification from &lt;code&gt;display-buffer-overriding-action&lt;/code&gt; and &lt;code&gt;display-buffer&lt;/code&gt; will show</source>
          <target state="translated">この場合、 &lt;code&gt;inhibit-same-window&lt;/code&gt; 連想リストエントリが正常に無効にする &lt;code&gt;display-buffer-same-window&lt;/code&gt; から指定 &lt;code&gt;display-buffer-overriding-action&lt;/code&gt; 及び &lt;code&gt;display-buffer&lt;/code&gt; 表示します</target>
        </trans-unit>
        <trans-unit id="04b2213a63614ac8251b3c7bc455f4e8850855b5" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;&quot;prolog&quot;&lt;/code&gt; is the name of the file to load, 169681 refers to the documentation string in the</source>
          <target state="translated">この場合、 &lt;code&gt;&quot;prolog&quot;&lt;/code&gt; はロードするファイルの名前であり、169681はのドキュメント文字列を参照します</target>
        </trans-unit>
        <trans-unit id="8e648e458f3c001b5d685c0aaee6c84fe234be3f" translate="yes" xml:space="preserve">
          <source>In this case, the &lt;small&gt;CDR&lt;/small&gt; of the association &lt;code&gt;(lily white)&lt;/code&gt; is not the symbol &lt;code&gt;white&lt;/code&gt;, but rather the list &lt;code&gt;(white)&lt;/code&gt;. This becomes clearer if the association is written in dotted pair notation:</source>
          <target state="translated">この場合、関連付けの&lt;small&gt;CDR &lt;/small&gt; &lt;code&gt;(lily white)&lt;/code&gt; はシンボル &lt;code&gt;white&lt;/code&gt; ではなく、リスト &lt;code&gt;(white)&lt;/code&gt; です。これは、関連付けが点線のペア表記で記述されている場合に明確になります。</target>
        </trans-unit>
        <trans-unit id="5c978b1007a3cfab25727c041633a410661259c5" translate="yes" xml:space="preserve">
          <source>In this case, the process is not truly synchronous, since it can run in parallel with Emacs; but you can think of it as synchronous in that Emacs is essentially finished with the subprocess as soon as this function returns.</source>
          <target state="translated">この場合、Emacs と並行して実行することができるので、プロセスは真の意味で同期的ではありません。</target>
        </trans-unit>
        <trans-unit id="3fc1a62b1e8add3600030a618eb06b7554d262e1" translate="yes" xml:space="preserve">
          <source>In this diagram, each box represents a slot that can hold or refer to any Lisp object. Each pair of boxes represents a cons cell. Each arrow represents a reference to a Lisp object, either an atom or another cons cell.</source>
          <target state="translated">この図では、各ボックスは、任意の Lisp オブジェクトを保持または参照できるスロットを表しています。各ボックスのペアは cons セルを表しています。矢印はLispオブジェクトへの参照を表しています。</target>
        </trans-unit>
        <trans-unit id="5189ea2c15eedb2e76964428691f1c5cd904bd9e" translate="yes" xml:space="preserve">
          <source>In this example, point is between the &amp;lsquo;</source>
          <target state="translated">この例では、ポイントは 'の間にあります</target>
        </trans-unit>
        <trans-unit id="f7926c062dd5a0ff5ef38fa8e29790f6b8333d0b" translate="yes" xml:space="preserve">
          <source>In this example, point is initially at the beginning of the buffer; the search leaves it between the &amp;lsquo;</source>
          <target state="translated">この例では、ポイントは最初はバッファーの先頭にあります。検索はそれを 'の間に残します</target>
        </trans-unit>
        <trans-unit id="8a9cce26338257a7f7f918d357295fda94e21a00" translate="yes" xml:space="preserve">
          <source>In this example, point is initially located at the beginning of the second line:</source>
          <target state="translated">この例では、ポイントは2行目の先頭に位置しています。</target>
        </trans-unit>
        <trans-unit id="9c8ac6b39fdaea7c1429c01fa50b5a383964f56c" translate="yes" xml:space="preserve">
          <source>In this example, point is located directly before the &amp;lsquo;</source>
          <target state="translated">この例では、ポイントは 'の直前にあります。</target>
        </trans-unit>
        <trans-unit id="3576b093aaf2ac699eaa7e91d03edb88bd5e4be3" translate="yes" xml:space="preserve">
          <source>In this example, the first box, which holds the &lt;small&gt;CAR&lt;/small&gt; of the first cons cell, refers to or holds &lt;code&gt;rose&lt;/code&gt; (a symbol). The second box, holding the &lt;small&gt;CDR&lt;/small&gt; of the first cons cell, refers to the next pair of boxes, the second cons cell. The &lt;small&gt;CAR&lt;/small&gt; of the second cons cell is &lt;code&gt;violet&lt;/code&gt;, and its &lt;small&gt;CDR&lt;/small&gt; is the third cons cell. The &lt;small&gt;CDR&lt;/small&gt; of the third (and last) cons cell is &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">この例では、最初のconsセルの&lt;small&gt;CAR&lt;/small&gt;を保持する最初のボックスは、 &lt;code&gt;rose&lt;/code&gt; （シンボル）を参照または保持します。最初のconsセルの&lt;small&gt;CDR&lt;/small&gt;を保持する2番目のボックスは、次のボックスのペアである2番目のconsセルを参照します。2番目のconsセルの&lt;small&gt;CAR&lt;/small&gt;は &lt;code&gt;violet&lt;/code&gt; であり、その&lt;small&gt;CDR&lt;/small&gt;は3番目のconsセルです。3番目（および最後）のconsセルの&lt;small&gt;CDR&lt;/small&gt;は &lt;code&gt;nil&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="73de656109b1553b872ecb7b04fd7edf5fcf976d" translate="yes" xml:space="preserve">
          <source>In this example, the form is executed with buffer &amp;lsquo;</source>
          <target state="translated">この例では、フォームはバッファ 'を使用して実行されます</target>
        </trans-unit>
        <trans-unit id="4b9029e7a66aa0c9f8ca4c799ed66e0cfbb79118" translate="yes" xml:space="preserve">
          <source>In this example, the index for &amp;lsquo;</source>
          <target state="translated">この例では、 'のインデックス</target>
        </trans-unit>
        <trans-unit id="764b384a226e6ab33f5227fab6776af37eb99b70" translate="yes" xml:space="preserve">
          <source>In this example, the interpreted code required 10 seconds to run, whereas the byte-compiled code required less than 4 seconds. These results are representative, but actual results may vary.</source>
          <target state="translated">この例では、インタープリタコードの実行に10秒を要したのに対し、バイトコンパイルされたコードでは4秒未満でした。これらの結果は代表的なものですが、実際の結果は異なる場合があります。</target>
        </trans-unit>
        <trans-unit id="6c60d69a652292ccff830c67c8d2351ad5e5e0b6" translate="yes" xml:space="preserve">
          <source>In this example, the value says that</source>
          <target state="translated">この例では、値は</target>
        </trans-unit>
        <trans-unit id="bf4b9ec25e056b797f6607ca8b59766a3a808319" translate="yes" xml:space="preserve">
          <source>In this kind of element, &lt;var&gt;anchored-highlighter&lt;/var&gt; specifies how to highlight text that follows a match found by &lt;var&gt;matcher&lt;/var&gt;. So a match found by &lt;var&gt;matcher&lt;/var&gt; acts as the anchor for further searches specified by &lt;var&gt;anchored-highlighter&lt;/var&gt;. &lt;var&gt;anchored-highlighter&lt;/var&gt; is a list of the following form:</source>
          <target state="translated">この種の要素では、 &lt;var&gt;anchored-highlighter&lt;/var&gt; は、 &lt;var&gt;matcher&lt;/var&gt; によって検出された一致に続くテキストを強調表示する方法を指定します。したがって、 &lt;var&gt;matcher&lt;/var&gt; によって検出された一致は、anchored &lt;var&gt;anchored-highlighter&lt;/var&gt; によって指定されたさらなる検索のアンカーとして機能します。 &lt;var&gt;anchored-highlighter&lt;/var&gt; は、次の形式のリストです。</target>
        </trans-unit>
        <trans-unit id="8f400ef8e587e9e01e8f55ffe8f0804f11bd1102" translate="yes" xml:space="preserve">
          <source>In this kind of element, &lt;var&gt;facespec&lt;/var&gt; is an expression whose value specifies the face to use for highlighting. In the simplest case, &lt;var&gt;facespec&lt;/var&gt; is a Lisp variable (a symbol) whose value is a face name.</source>
          <target state="translated">この種の要素では、 &lt;var&gt;facespec&lt;/var&gt; は、その値が強調表示に使用する面を指定する式です。最も単純なケースでは、 &lt;var&gt;facespec&lt;/var&gt; は値が面名であるLisp変数（シンボル）です。</target>
        </trans-unit>
        <trans-unit id="d0f3cf4781874539fca8b12ffa575360a97062a3" translate="yes" xml:space="preserve">
          <source>In this kind of element, &lt;var&gt;matcher&lt;/var&gt; is either a regular expression or a function, as described above. The &lt;small&gt;CDR&lt;/small&gt;, &lt;var&gt;subexp&lt;/var&gt;, specifies which subexpression of &lt;var&gt;matcher&lt;/var&gt; should be highlighted (instead of the entire text that &lt;var&gt;matcher&lt;/var&gt; matched).</source>
          <target state="translated">この種の要素では、 &lt;var&gt;matcher&lt;/var&gt; は前述のように正規表現または関数のいずれかです。&lt;small&gt;CDR&lt;/small&gt;、 &lt;var&gt;subexp&lt;/var&gt; の部分式、指定 &lt;var&gt;matcher&lt;/var&gt; （全体ではなく、テキストの強調表示されます &lt;var&gt;matcher&lt;/var&gt; 一致しました）。</target>
        </trans-unit>
        <trans-unit id="d4c92f44f29e6a508a88862991fc4849cfa01b75" translate="yes" xml:space="preserve">
          <source>In this kind of element, &lt;var&gt;subexp-highlighter&lt;/var&gt; is a list which specifies how to highlight matches found by &lt;var&gt;matcher&lt;/var&gt;. It has the form:</source>
          <target state="translated">この種の要素では、 &lt;var&gt;subexp-highlighter&lt;/var&gt; は、 &lt;var&gt;matcher&lt;/var&gt; によって検出された一致を強調表示する方法を指定するリストです。それは形をしています：</target>
        </trans-unit>
        <trans-unit id="65868b57f4589aab73c360fb6e9e308010443437" translate="yes" xml:space="preserve">
          <source>In this manual, we write &lt;code&gt;()&lt;/code&gt; when we wish to emphasize that it means the empty list, and we write &lt;code&gt;nil&lt;/code&gt; when we wish to emphasize that it means the truth value &lt;var&gt;false&lt;/var&gt;. That is a good convention to use in Lisp programs also.</source>
          <target state="translated">このマニュアルでは、空のリストを意味することを強調したい場合は &lt;code&gt;()&lt;/code&gt; を記述し、真理値 &lt;var&gt;false&lt;/var&gt; を意味することを強調したい場合は &lt;code&gt;nil&lt;/code&gt; を記述します。これは、Lispプログラムでも使用するのに適した規則です。</target>
        </trans-unit>
        <trans-unit id="af20502ec39925ff9d9d9c1f4f7cbd4800bb2ffe" translate="yes" xml:space="preserve">
          <source>In this next example, point is between the &amp;lsquo;</source>
          <target state="translated">この次の例では、ポイントは 'の間にあります</target>
        </trans-unit>
        <trans-unit id="5b3dc1e84019e82e89cd0988c8c5c64866bf8ed9" translate="yes" xml:space="preserve">
          <source>In this scenario, &lt;code&gt;jsonrpc-connection&lt;/code&gt; is subclassed to implement a different underlying transport strategy (for details on how to subclass, see &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/eieio/Inheritance.html#Inheritance&quot;&gt;(eieio)Inheritance&lt;/a&gt;.). Users of the application-building interface can then instantiate objects of this concrete class (using the &lt;code&gt;make-instance&lt;/code&gt; function) and connect to JSONRPC endpoints using that strategy.</source>
          <target state="translated">このシナリオでは、 &lt;code&gt;jsonrpc-connection&lt;/code&gt; がサブクラス化されて、異なる基盤となるトランスポート戦略が実装されます&lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/eieio/Inheritance.html#Inheritance&quot;&gt;（&lt;/a&gt;サブクラス化の方法の詳細については、（eieio）Inheritanceを参照してください）。アプリケーション構築インターフェースのユーザーは、（ &lt;code&gt;make-instance&lt;/code&gt; 関数を使用して）この具象クラスのオブジェクトをインスタンス化し、その戦略を使用してJSONRPCエンドポイントに接続できます。</target>
        </trans-unit>
        <trans-unit id="b9e4e7371206d35dcfc5989991b4a959d04ae518" translate="yes" xml:space="preserve">
          <source>In this scenario, the JSONRPC application selects a concrete subclass of &lt;code&gt;jsonrpc-connection&lt;/code&gt;, and proceeds to create objects of that subclass using &lt;code&gt;make-instance&lt;/code&gt;. To initiate a contact to the remote endpoint, the JSONRPC application passes this object to the functions &lt;code&gt;jsonrpc-notify&lt;/code&gt;, &lt;code&gt;jsonrpc-request&lt;/code&gt;, and/or &lt;code&gt;jsonrpc-async-request&lt;/code&gt;. For handling remotely initiated contacts, which generally come in asynchronously, the instantiation should include &lt;code&gt;:request-dispatcher&lt;/code&gt; and &lt;code&gt;:notification-dispatcher&lt;/code&gt; initargs, which are both functions of 3 arguments: the connection object; a symbol naming the JSONRPC method invoked remotely; and a JSONRPC &lt;code&gt;params&lt;/code&gt; object.</source>
          <target state="translated">このシナリオでは、JSONRPCアプリケーションは &lt;code&gt;jsonrpc-connection&lt;/code&gt; の具象サブクラスを選択し、 &lt;code&gt;make-instance&lt;/code&gt; を使用してそのサブクラスのオブジェクトの作成に進みます。リモートエンドポイントへの接続を開始するために、JSONRPCアプリケーションはこのオブジェクトを関数 &lt;code&gt;jsonrpc-notify&lt;/code&gt; 、 &lt;code&gt;jsonrpc-request&lt;/code&gt; 、および/または &lt;code&gt;jsonrpc-async-request&lt;/code&gt; に渡します。通常は非同期で受信 &lt;code&gt;:request-dispatcher&lt;/code&gt; れるリモートで開始された連絡先を処理するには、インスタンス化に：request-dispatcherと &lt;code&gt;:notification-dispatcher&lt;/code&gt; initargsを含める必要があります。これらは両方とも3つの引数の関数です。リモートで呼び出されるJSONRPCメソッドに名前を付けるシンボル。そして、JSONRPC &lt;code&gt;params&lt;/code&gt; オブジェクト。</target>
        </trans-unit>
        <trans-unit id="1af82129d6d32c9e06217b885c8dd8bf6f60a0e9" translate="yes" xml:space="preserve">
          <source>In this section we describe functions for creating, accessing and altering syntax tables.</source>
          <target state="translated">このセクションでは、構文テーブルの作成、アクセス、および変更のための関数について説明します。</target>
        </trans-unit>
        <trans-unit id="7456e6359dd2969245d309399580bcce1506a625" translate="yes" xml:space="preserve">
          <source>In this section we list some of the more general keymaps. Many of these exist when Emacs is first started, but some are loaded only when the respective feature is accessed.</source>
          <target state="translated">このセクションでは、より一般的なキーマップをいくつか挙げます。これらの多くは Emacs の最初の起動時に存在しますが、中にはそれぞれの機能にアクセスしたときにのみロードされるものもあります。</target>
        </trans-unit>
        <trans-unit id="75c4faa5a87500b689faf740289921e94ba4648d" translate="yes" xml:space="preserve">
          <source>In this section, we describe how to create an &lt;em&gt;asynchronous process&lt;/em&gt;. After an asynchronous process is created, it runs in parallel with Emacs, and Emacs can communicate with it using the functions described in the following sections (see &lt;a href=&quot;input-to-processes#Input-to-Processes&quot;&gt;Input to Processes&lt;/a&gt;, and see &lt;a href=&quot;output-from-processes#Output-from-Processes&quot;&gt;Output from Processes&lt;/a&gt;). Note that process communication is only partially asynchronous: Emacs sends and receives data to and from a process only when those functions are called.</source>
          <target state="translated">このセクションでは、&lt;em&gt;非同期プロセス&lt;/em&gt;を作成する方法について説明します。非同期プロセスが作成されると、Emacsと並行して実行され、Emacsは次のセクションで説明する関数を使用し&lt;a href=&quot;input-to-processes#Input-to-Processes&quot;&gt;てプロセス&lt;/a&gt;と通信できます（「プロセスへの入力」および「&lt;a href=&quot;output-from-processes#Output-from-Processes&quot;&gt;プロセスからの出力&lt;/a&gt;」を参照）。プロセス通信は部分的に非同期であることに注意してください。Emacsは、これらの関数が呼び出された場合にのみ、プロセスとの間でデータを送受信します。</target>
        </trans-unit>
        <trans-unit id="c9b298dd66b005623af56bf6c6bc09c1e5f67332" translate="yes" xml:space="preserve">
          <source>In this section, we describe the functions that accept all types of arrays.</source>
          <target state="translated">ここでは、すべての型の配列を受け付ける関数について説明します。</target>
        </trans-unit>
        <trans-unit id="abf73e32c756c256563a8daa580c451693687fe9" translate="yes" xml:space="preserve">
          <source>In this section, we document the &lt;code&gt;run-hooks&lt;/code&gt; function, which is used to run a normal hook. We also document the functions for running various kinds of abnormal hooks.</source>
          <target state="translated">このセクションでは、通常のフックを実行するために使用される &lt;code&gt;run-hooks&lt;/code&gt; 関数について説明します。また、さまざまな異常フックを実行するための関数についても説明します。</target>
        </trans-unit>
        <trans-unit id="cc308cdcd27e50a8464c2fb8c2b137680f8aa92d" translate="yes" xml:space="preserve">
          <source>In this special form, the arguments &lt;var&gt;from&lt;/var&gt; and &lt;var&gt;to&lt;/var&gt; are optional, but must both be present or both absent. If they are present, &lt;var&gt;inc&lt;/var&gt; may optionally be specified as well. These arguments are grouped with the argument &lt;var&gt;var&lt;/var&gt; into a list, to distinguish them from &lt;var&gt;body&lt;/var&gt;, which includes all remaining elements of the form.</source>
          <target state="translated">この特別な形式では、 &lt;var&gt;from&lt;/var&gt; と &lt;var&gt;to&lt;/var&gt; の引数はオプションですが、両方が存在するか、両方が存在しない必要があります。それらが存在する場合は、オプションで &lt;var&gt;inc&lt;/var&gt; も指定できます。これらの引数は、フォームの残りのすべての要素を含む &lt;var&gt;body&lt;/var&gt; と区別するために、引数 &lt;var&gt;var&lt;/var&gt; とともにリストにグループ化されます。</target>
        </trans-unit>
        <trans-unit id="9191121a266e1613654b74c183e9b81e80959c1f" translate="yes" xml:space="preserve">
          <source>In this subsection, &lt;var&gt;ewoc&lt;/var&gt; and &lt;var&gt;node&lt;/var&gt; stand for the structures described above (see &lt;a href=&quot;abstract-display#Abstract-Display&quot;&gt;Abstract Display&lt;/a&gt;), while &lt;var&gt;data&lt;/var&gt; stands for an arbitrary Lisp object used as a data element.</source>
          <target state="translated">このサブセクションでは、 &lt;var&gt;ewoc&lt;/var&gt; と &lt;var&gt;node&lt;/var&gt; は上記の構造を表し（&lt;a href=&quot;abstract-display#Abstract-Display&quot;&gt;Abstract Displayを&lt;/a&gt;参照）、 &lt;var&gt;data&lt;/var&gt; はデータ要素として使用される任意のLispオブジェクトを表します。</target>
        </trans-unit>
        <trans-unit id="b7695c1c385c781384681e043cf75498c33095e8" translate="yes" xml:space="preserve">
          <source>In typical use of text properties, most of the time several or many consecutive characters have the same value for a property. Rather than writing your programs to examine characters one by one, it is much faster to process chunks of text that have the same property value.</source>
          <target state="translated">テキストのプロパティの典型的な使用法では、ほとんどの場合、プロパティの値が同じである文字が複数、または多数連続していることが多いです。プログラムを書いて一文字ずつ調べるよりも、同じプロパティ値を持つテキストの塊を処理する方がはるかに高速です。</target>
        </trans-unit>
        <trans-unit id="398759523f553da3a04d5632b9ae89f03ca6ebe6" translate="yes" xml:space="preserve">
          <source>In unusual circumstances, there can be more than one buffer visiting the same file name. In such cases, this function returns the first such buffer in the buffer list.</source>
          <target state="translated">異常な状況下では、同じファイル名に複数のバッファが存在することがあります。そのような場合、この関数はバッファリストの最初のバッファを返します。</target>
        </trans-unit>
        <trans-unit id="6bc522c712bd045ae610c3ffdfe588e290263853" translate="yes" xml:space="preserve">
          <source>In window systems, such as X, data can be transferred between different applications by means of &lt;em&gt;selections&lt;/em&gt;. X defines an arbitrary number of &lt;em&gt;selection types&lt;/em&gt;, each of which can store its own data; however, only three are commonly used: the &lt;em&gt;clipboard&lt;/em&gt;, &lt;em&gt;primary selection&lt;/em&gt;, and &lt;em&gt;secondary selection&lt;/em&gt;. Other window systems support only the clipboard. See &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Cut-and-Paste.html#Cut-and-Paste&quot;&gt;Cut and Paste&lt;/a&gt; in</source>
          <target state="translated">Xなどのウィンドウシステムでは、&lt;em&gt;選択&lt;/em&gt;によってデータを異なるアプリケーション間で転送できます。Xは、任意の数の&lt;em&gt;選択タイプを&lt;/em&gt;定義し、それぞれが独自のデータを格納できます。ただし、一般的に使用されるのは、&lt;em&gt;クリップボード&lt;/em&gt;、&lt;em&gt;一次選択&lt;/em&gt;、および&lt;em&gt;二次選択の&lt;/em&gt;3つだけです。他のウィンドウシステムはクリップボードのみをサポートします。&lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Cut-and-Paste.html#Cut-and-Paste&quot;&gt;カットアンドペースト&lt;/a&gt;を参照してください</target>
        </trans-unit>
        <trans-unit id="1f4f96711902573479785d359bea6010a237cdfb" translate="yes" xml:space="preserve">
          <source>In writing the key sequence to rebind, it is good to use the special escape sequences for control and meta characters (see &lt;a href=&quot;string-type#String-Type&quot;&gt;String Type&lt;/a&gt;). The syntax &amp;lsquo;</source>
          <target state="translated">再バインドするキーシーケンスを作成する際には、制御文字とメタ文字に特別なエスケープシーケンスを使用することをお勧めします（&lt;a href=&quot;string-type#String-Type&quot;&gt;文字列タイプを&lt;/a&gt;参照）。構文 '</target>
        </trans-unit>
        <trans-unit id="5c699af66d7cc4077f86d1419c1e341294245528" translate="yes" xml:space="preserve">
          <source>Include an external link after the documentation string for this item. This is a sentence containing a button that references some other documentation.</source>
          <target state="translated">この項目のドキュメント文字列の後に外部リンクを含めます。これは、他のドキュメントを参照するボタンを含む文です。</target>
        </trans-unit>
        <trans-unit id="76775cb67de1d16719f132aea62e321213b81dcb" translate="yes" xml:space="preserve">
          <source>Includes examples and caveats.</source>
          <target state="translated">例題と注意点を紹介。</target>
        </trans-unit>
        <trans-unit id="abb42b558c56ceb21cca2f6daadd7a31514411ab" translate="yes" xml:space="preserve">
          <source>Increase the image size (&lt;code&gt;image-increase-size&lt;/code&gt;). A prefix value of &amp;lsquo;</source>
          <target state="translated">画像サイズを大きくします（ &lt;code&gt;image-increase-size&lt;/code&gt; ）。'のプレフィックス値</target>
        </trans-unit>
        <trans-unit id="9229257425378cb0ebb48e0365ae97d30b8cbd09" translate="yes" xml:space="preserve">
          <source>Incremental search can make invisible overlays visible temporarily and/or permanently when a match includes invisible text. To enable this, the overlay should have a non-&lt;code&gt;nil&lt;/code&gt;&lt;code&gt;isearch-open-invisible&lt;/code&gt; property. The property value should be a function to be called with the overlay as an argument. This function should make the overlay visible permanently; it is used when the match overlaps the overlay on exit from the search.</source>
          <target state="translated">インクリメンタルサーチでは、一致に非表示のテキストが含まれている場合、非表示のオーバーレイを一時的および/または永続的に表示できます。これを有効にするには、オーバーレイに &lt;code&gt;nil&lt;/code&gt; &lt;code&gt;isearch-open-invisible&lt;/code&gt; プロパティが必要です。プロパティ値は、オーバーレイを引数として呼び出す関数である必要があります。この関数は、オーバーレイを永続的に表示する必要があります。これは、検索の終了時に一致がオーバーレイと重なる場合に使用されます。</target>
        </trans-unit>
        <trans-unit id="e6d579c6cc398fe7db545dd582fc67de8b2d582c" translate="yes" xml:space="preserve">
          <source>Indent all the lines in a region.</source>
          <target state="translated">リージョン内のすべての行をインデントします。</target>
        </trans-unit>
        <trans-unit id="42c518bd88aefe4faecc452be3932f9e029498cb" translate="yes" xml:space="preserve">
          <source>Indent calls to this function or macro according to &lt;var&gt;indent-spec&lt;/var&gt;. This is typically used for macros, though it works for functions too. See &lt;a href=&quot;indenting-macros#Indenting-Macros&quot;&gt;Indenting Macros&lt;/a&gt;.</source>
          <target state="translated">&lt;var&gt;indent-spec&lt;/var&gt; に従って、この関数またはマクロへの呼び出しをインデントします。これは通常、マクロに使用されますが、関数にも機能します。&lt;a href=&quot;indenting-macros#Indenting-Macros&quot;&gt;マクロのインデントを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="27176cfb7708a018b06cd9d8ea7336b632a76f0d" translate="yes" xml:space="preserve">
          <source>Indent current token as a &lt;em&gt;separator&lt;/em&gt;.</source>
          <target state="translated">現在のトークンを&lt;em&gt;区切り文字&lt;/em&gt;としてインデントします。</target>
        </trans-unit>
        <trans-unit id="66b7ce43ce4a7ca89f6dad39cb0198725d35356c" translate="yes" xml:space="preserve">
          <source>Indent the current line based on previous lines.</source>
          <target state="translated">前の行を基準に現在の行をインデントします。</target>
        </trans-unit>
        <trans-unit id="c9ec7fcf0ce1c005cbdd2ae9ab39e1773e6bf368" translate="yes" xml:space="preserve">
          <source>Indentation</source>
          <target state="translated">Indentation</target>
        </trans-unit>
        <trans-unit id="511f4889f97fada7d908032cc1464f2aa35c8004" translate="yes" xml:space="preserve">
          <source>Indentation Controlled by Major Mode</source>
          <target state="translated">メジャーモードによるインデント制御</target>
        </trans-unit>
        <trans-unit id="fdac28e1c2199ac39cc5e09f4dd786cd625bd4a4" translate="yes" xml:space="preserve">
          <source>Indentation Primitives</source>
          <target state="translated">インデントプリミティブ</target>
        </trans-unit>
        <trans-unit id="5b82b1b833300c0e6e5e24537ad294a6d135f9fa" translate="yes" xml:space="preserve">
          <source>Indentation Relative to Previous Lines</source>
          <target state="translated">前の行を基準としたインデント</target>
        </trans-unit>
        <trans-unit id="2af2ccd8b84225bf2c735da91f1184265c730f6a" translate="yes" xml:space="preserve">
          <source>Indentation-Based Motion Commands</source>
          <target state="translated">インデントに基づくモーションコマンド</target>
        </trans-unit>
        <trans-unit id="1bb77083feeb12d0ebb47ef46a39b5078cd5cb2d" translate="yes" xml:space="preserve">
          <source>Indenting Macros</source>
          <target state="translated">マクロのインデント</target>
        </trans-unit>
        <trans-unit id="30f00ddc559ee66f1e7768bbbc4d7eee4d538190" translate="yes" xml:space="preserve">
          <source>Indenting an Entire Region</source>
          <target state="translated">領域全体をインデントする</target>
        </trans-unit>
        <trans-unit id="c2df9b932637fe9d32a0f16da1c11873398f873d" translate="yes" xml:space="preserve">
          <source>Index</source>
          <target state="translated">Index</target>
        </trans-unit>
        <trans-unit id="8f868c1e82b2154aed66be4aaa7e76b45121fbff" translate="yes" xml:space="preserve">
          <source>Index including concepts, functions, variables, and other terms.</source>
          <target state="translated">概念、関数、変数、その他の用語を含む索引。</target>
        </trans-unit>
        <trans-unit id="d52c4a56e9e6d6db73917b478317c4b1d432ad1f" translate="yes" xml:space="preserve">
          <source>Indicates that the specification is for a defining form. Edebug&amp;rsquo;s definition of a defining form is a form containing one or more code forms which are saved and executed later, after the execution of the defining form.</source>
          <target state="translated">仕様が定義フォーム用であることを示します。Edebugの定義フォームの定義は、定義フォームの実行後に保存および実行される1つ以上のコードフォームを含むフォームです。</target>
        </trans-unit>
        <trans-unit id="1112b756bb004fe882859143d87adf31c2f5d050" translate="yes" xml:space="preserve">
          <source>Indirect Buffers</source>
          <target state="translated">間接バッファ</target>
        </trans-unit>
        <trans-unit id="938b66bd8c62095908b57d694e88050ca1007edd" translate="yes" xml:space="preserve">
          <source>Individual characters are used occasionally in programs, but it is more common to work with &lt;em&gt;strings&lt;/em&gt;, which are sequences composed of characters. See &lt;a href=&quot;string-type#String-Type&quot;&gt;String Type&lt;/a&gt;.</source>
          <target state="translated">プログラムでは個々の文字が使用されることがありますが、&lt;em&gt;文字&lt;/em&gt;で構成されるシーケンスである&lt;em&gt;文字列&lt;/em&gt;を使用するのが一般的です。&lt;a href=&quot;string-type#String-Type&quot;&gt;文字列型を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="4b631f69842530d659306c8f06dbad594a6b1807" translate="yes" xml:space="preserve">
          <source>Info</source>
          <target state="translated">Info</target>
        </trans-unit>
        <trans-unit id="ad474c9deee501ca52324eb72953350dc14402c1" translate="yes" xml:space="preserve">
          <source>Info about total size of Lisp objects made so far.</source>
          <target state="translated">これまでに作成されたLispオブジェクトの総サイズについての情報です。</target>
        </trans-unit>
        <trans-unit id="e73d741db9df809634f2d60fc44dc32e7f4bc7e7" translate="yes" xml:space="preserve">
          <source>Info for users downgrading to Emacs 26.</source>
          <target state="translated">Emacs 26 にダウングレードするユーザーのための情報。</target>
        </trans-unit>
        <trans-unit id="0eb5ed506e4923c28d7f4a8aa69efe99b3ad75d1" translate="yes" xml:space="preserve">
          <source>Information</source>
          <target state="translated">Information</target>
        </trans-unit>
        <trans-unit id="8247fbb975f100a6b13b56c054fa3613a36b297b" translate="yes" xml:space="preserve">
          <source>Information about Files</source>
          <target state="translated">ファイルに関する情報</target>
        </trans-unit>
        <trans-unit id="df29a9e6a31bec3e8b780a960759047a5bd6a25f" translate="yes" xml:space="preserve">
          <source>Information from Markers</source>
          <target state="translated">マーカーからの情報</target>
        </trans-unit>
        <trans-unit id="3ef56c865ee91dd66ebad0347cc1f0de75602bc3" translate="yes" xml:space="preserve">
          <source>Information from the Command Loop</source>
          <target state="translated">コマンドループからの情報</target>
        </trans-unit>
        <trans-unit id="18c79d206ba3bf95c4d3ca95be49d37877182f30" translate="yes" xml:space="preserve">
          <source>Informing user about progress of a long operation.</source>
          <target state="translated">長時間の操作の進行状況をユーザーに通知する。</target>
        </trans-unit>
        <trans-unit id="d8a1fba394d47f17007b00e6ef12b9c86a3c6414" translate="yes" xml:space="preserve">
          <source>Inherit standard syntax: &amp;lsquo;</source>
          <target state="translated">標準構文を継承します： '</target>
        </trans-unit>
        <trans-unit id="15e80c1c18978164d737579b198c39c73404e4e1" translate="yes" xml:space="preserve">
          <source>Inheritance and Keymaps</source>
          <target state="translated">継承とキーマップ</target>
        </trans-unit>
        <trans-unit id="fb691787cc7690e0df61a80ff9e0643eb7d0d6da" translate="yes" xml:space="preserve">
          <source>Initial Frame Parameters</source>
          <target state="translated">初期フレームパラメータ</target>
        </trans-unit>
        <trans-unit id="89a2bccb3e4d6523cbe25ad5db3ff715866a115e" translate="yes" xml:space="preserve">
          <source>Initial Input</source>
          <target state="translated">初期入力</target>
        </trans-unit>
        <trans-unit id="eb607b40a369ea5599a4b2f0220d4f687f78016b" translate="yes" xml:space="preserve">
          <source>Initialize the log function of a server process to &lt;var&gt;log&lt;/var&gt;. The log function is called each time the server accepts a network connection from a client. The arguments passed to the log function are &lt;var&gt;server&lt;/var&gt;, &lt;var&gt;connection&lt;/var&gt;, and &lt;var&gt;message&lt;/var&gt;; where &lt;var&gt;server&lt;/var&gt; is the server process, &lt;var&gt;connection&lt;/var&gt; is the new process for the connection, and &lt;var&gt;message&lt;/var&gt; is a string describing what has happened.</source>
          <target state="translated">サーバープロセスのログ機能を初期化してログに記録し &lt;var&gt;log&lt;/var&gt; 。ログ関数は、サーバーがクライアントからのネットワーク接続を受け入れるたびに呼び出されます。log関数に渡される引数は、 &lt;var&gt;server&lt;/var&gt; 、 &lt;var&gt;connection&lt;/var&gt; 、および &lt;var&gt;message&lt;/var&gt; です。ここで、 &lt;var&gt;server&lt;/var&gt; はサーバープロセス、 &lt;var&gt;connection&lt;/var&gt; は接続の新しいプロセス、 &lt;var&gt;message&lt;/var&gt; は何が起こったかを説明する文字列です。</target>
        </trans-unit>
        <trans-unit id="f894ea5a16cfcad8d7176dad8de92207ba46e301" translate="yes" xml:space="preserve">
          <source>Initialize the process filter to &lt;var&gt;filter&lt;/var&gt;.</source>
          <target state="translated">プロセスフィルターを初期化してフィルターし &lt;var&gt;filter&lt;/var&gt; 。</target>
        </trans-unit>
        <trans-unit id="4bdcb3b64e7635d1c8dde72370f13421e348ea64" translate="yes" xml:space="preserve">
          <source>Initialize the process filter to &lt;var&gt;filter&lt;/var&gt;. If not specified, a default filter will be provided, which can be changed later. See &lt;a href=&quot;filter-functions#Filter-Functions&quot;&gt;Filter Functions&lt;/a&gt;.</source>
          <target state="translated">プロセスフィルターを初期化してフィルターし &lt;var&gt;filter&lt;/var&gt; 。指定しない場合、デフォルトのフィルターが提供されますが、後で変更できます。&lt;a href=&quot;filter-functions#Filter-Functions&quot;&gt;フィルタ機能を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="88aa27fccdee463394440c83004deae351722113" translate="yes" xml:space="preserve">
          <source>Initialize the process filter to &lt;var&gt;filter&lt;/var&gt;. If not specified, a default filter will be provided, which can be overridden later. See &lt;a href=&quot;filter-functions#Filter-Functions&quot;&gt;Filter Functions&lt;/a&gt;.</source>
          <target state="translated">プロセスフィルターを初期化してフィルターし &lt;var&gt;filter&lt;/var&gt; 。指定しない場合、デフォルトのフィルターが提供されますが、後でオーバーライドできます。&lt;a href=&quot;filter-functions#Filter-Functions&quot;&gt;フィルタ機能を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="978fecd8f603fe8d25457aa9a55a2791886af74d" translate="yes" xml:space="preserve">
          <source>Initialize the process plist to &lt;var&gt;plist&lt;/var&gt;.</source>
          <target state="translated">プロセスplistを &lt;var&gt;plist&lt;/var&gt; に初期化します。</target>
        </trans-unit>
        <trans-unit id="c97165454b295da9973e4e05e4127a6851e7f5bd" translate="yes" xml:space="preserve">
          <source>Initialize the process query flag to &lt;var&gt;query-flag&lt;/var&gt;. See &lt;a href=&quot;query-before-exit#Query-Before-Exit&quot;&gt;Query Before Exit&lt;/a&gt;.</source>
          <target state="translated">プロセスクエリフラグを &lt;var&gt;query-flag&lt;/var&gt; に初期化します。&lt;a href=&quot;query-before-exit#Query-Before-Exit&quot;&gt;終了前のクエリを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="1296ca254782c4485a383df44dbf7f61ee7b4bc5" translate="yes" xml:space="preserve">
          <source>Initialize the process query flag to &lt;var&gt;query-flag&lt;/var&gt;. See &lt;a href=&quot;query-before-exit#Query-Before-Exit&quot;&gt;Query Before Exit&lt;/a&gt;. The flags defaults to &lt;code&gt;nil&lt;/code&gt; if unspecified.</source>
          <target state="translated">プロセスクエリフラグを &lt;var&gt;query-flag&lt;/var&gt; に初期化します。&lt;a href=&quot;query-before-exit#Query-Before-Exit&quot;&gt;終了前のクエリを&lt;/a&gt;参照してください。指定されていない場合、フラグのデフォルトは &lt;code&gt;nil&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="7423f99e44e5c0fe954c4b5fbab30632bfd77607" translate="yes" xml:space="preserve">
          <source>Initialize the process sentinel to &lt;var&gt;sentinel&lt;/var&gt;.</source>
          <target state="translated">プロセスsentinelを &lt;var&gt;sentinel&lt;/var&gt; に初期化します。</target>
        </trans-unit>
        <trans-unit id="9db86c8bfdd16aec885a8fb101a51297ca90199b" translate="yes" xml:space="preserve">
          <source>Initialize the process sentinel to &lt;var&gt;sentinel&lt;/var&gt;. If not specified, a default sentinel will be used, which can be changed later. See &lt;a href=&quot;sentinels#Sentinels&quot;&gt;Sentinels&lt;/a&gt;.</source>
          <target state="translated">プロセスsentinelを &lt;var&gt;sentinel&lt;/var&gt; に初期化します。指定しない場合、デフォルトのセンチネルが使用されますが、後で変更できます。&lt;a href=&quot;sentinels#Sentinels&quot;&gt;センチネルを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="438b44ac9a269df0c942362a3b40baff51fec529" translate="yes" xml:space="preserve">
          <source>Initialize the process sentinel to &lt;var&gt;sentinel&lt;/var&gt;. If not specified, a default sentinel will be used, which can be overridden later. See &lt;a href=&quot;sentinels#Sentinels&quot;&gt;Sentinels&lt;/a&gt;.</source>
          <target state="translated">プロセスsentinelを &lt;var&gt;sentinel&lt;/var&gt; に初期化します。指定しない場合、デフォルトの番兵が使用されますが、後で上書きできます。&lt;a href=&quot;sentinels#Sentinels&quot;&gt;センチネルを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="cc3466ae2da1d30465b2916d783d7d5e733df96c" translate="yes" xml:space="preserve">
          <source>Initialize the type of device used to communicate with the subprocess. Possible values are &lt;code&gt;pty&lt;/code&gt; to use a pty, &lt;code&gt;pipe&lt;/code&gt; to use a pipe, or &lt;code&gt;nil&lt;/code&gt; to use the default derived from the value of the &lt;code&gt;process-connection-type&lt;/code&gt; variable. This parameter and the value of &lt;code&gt;process-connection-type&lt;/code&gt; are ignored if a non-&lt;code&gt;nil&lt;/code&gt; value is specified for the &lt;code&gt;:stderr&lt;/code&gt; parameter; in that case, the type will always be &lt;code&gt;pipe&lt;/code&gt;. On systems where ptys are not available (MS-Windows), this parameter is likewise ignored, and pipes are used unconditionally.</source>
          <target state="translated">サブプロセスとの通信に使用されるデバイスのタイプを初期化します。可能な値は、 &lt;code&gt;pty&lt;/code&gt; を使用する場合はpty、 &lt;code&gt;pipe&lt;/code&gt; を使用する場合はpipe、または &lt;code&gt;process-connection-type&lt;/code&gt; 変数の値から派生したデフォルトを使用する場合は &lt;code&gt;nil&lt;/code&gt; です。 &lt;code&gt;:stderr&lt;/code&gt; パラメーターに &lt;code&gt;nil&lt;/code&gt; 以外の値が指定されている場合、このパラメーターと &lt;code&gt;process-connection-type&lt;/code&gt; の値は無視されます。その場合、タイプは常に &lt;code&gt;pipe&lt;/code&gt; ます。 ptyが使用できないシステム（MS-Windows）では、このパラメーターも同様に無視され、パイプは無条件に使用されます。</target>
        </trans-unit>
        <trans-unit id="75ba3477c577bc61f2782c6fbd5d3918d3d93888" translate="yes" xml:space="preserve">
          <source>Inline (&lt;code&gt;defsubst&lt;/code&gt;) functions are less troublesome; if you compile a call to such a function before its definition is known, the call will still work right, it will just run slower.</source>
          <target state="translated">インライン（ &lt;code&gt;defsubst&lt;/code&gt; ）関数はそれほど面倒ではありません。その定義がわかる前にそのような関数の呼び出しをコンパイルした場合でも、呼び出しは正しく機能し、実行速度が遅くなります。</target>
        </trans-unit>
        <trans-unit id="b60019f47df04ae92897fa912c6748a6013313fa" translate="yes" xml:space="preserve">
          <source>Inline Functions</source>
          <target state="translated">インライン関数</target>
        </trans-unit>
        <trans-unit id="023bd002a35d8328e1b84deea2b2fbe846651660" translate="yes" xml:space="preserve">
          <source>Inner Frame</source>
          <target state="translated">インナーフレーム</target>
        </trans-unit>
        <trans-unit id="1ff7c24cdc862e41c4384103afd571ff8024a31c" translate="yes" xml:space="preserve">
          <source>Input Events</source>
          <target state="translated">入力イベント</target>
        </trans-unit>
        <trans-unit id="68e31416a1a24dd5f2a79386c7cd5ebc7d038f16" translate="yes" xml:space="preserve">
          <source>Input Focus</source>
          <target state="translated">入力フォーカス</target>
        </trans-unit>
        <trans-unit id="88198074ced9d4479d4b7e9aafe153884a14b789" translate="yes" xml:space="preserve">
          <source>Input Functions</source>
          <target state="translated">入力機能</target>
        </trans-unit>
        <trans-unit id="c968ad8768affe487c292b6adc7616df4a013a6b" translate="yes" xml:space="preserve">
          <source>Input Methods</source>
          <target state="translated">入力方法</target>
        </trans-unit>
        <trans-unit id="a821e6c8419f780e8743b7bf306490cddd9913c4" translate="yes" xml:space="preserve">
          <source>Input Modes</source>
          <target state="translated">入力モード</target>
        </trans-unit>
        <trans-unit id="eed11d0bb1de0f449227ff92bf6d2ad650126f01" translate="yes" xml:space="preserve">
          <source>Input Streams</source>
          <target state="translated">入力ストリーム</target>
        </trans-unit>
        <trans-unit id="3b3948df9e555ca646262a35e33cb7cf68613dc1" translate="yes" xml:space="preserve">
          <source>Input methods allow users to enter various non-ASCII characters without special keyboards.</source>
          <target state="translated">入力手段は、特殊なキーボードを使用せずに、様々な非ASCII文字を入力することができる。</target>
        </trans-unit>
        <trans-unit id="bf60d2635214ca206c57f12fa87775f6b4f038df" translate="yes" xml:space="preserve">
          <source>Insert the output in a buffer with that name, before point.</source>
          <target state="translated">pointの前に、その名前のバッファに出力を挿入します。</target>
        </trans-unit>
        <trans-unit id="3aa29461af0f56c0dd73083f79d4a003b7af3788" translate="yes" xml:space="preserve">
          <source>Insert the output in that buffer, before point. This includes both the standard output stream and the standard error stream of the process.</source>
          <target state="translated">そのバッファに、ポイントの前に出力を挿入します。これには、プロセスの標準出力ストリームと標準エラーストリームの両方が含まれます。</target>
        </trans-unit>
        <trans-unit id="1c64a3bbdde10f3ebb444ccc0c14466f3d048a31" translate="yes" xml:space="preserve">
          <source>Insert the output in the current buffer, before point.</source>
          <target state="translated">現在のバッファにポイントの前に出力を挿入します。</target>
        </trans-unit>
        <trans-unit id="0d849e555da7ae1ee48fec0567933a06f27173ff" translate="yes" xml:space="preserve">
          <source>Insert the strings &lt;var&gt;strings&lt;/var&gt;, just like the function &lt;code&gt;insert-before-markers&lt;/code&gt;, but inherit any sticky properties from the adjoining text.</source>
          <target state="translated">関数 &lt;code&gt;insert-before-markers&lt;/code&gt; と同じように、文字 &lt;var&gt;strings&lt;/var&gt; 挿入しますが、隣接するテキストからスティッキープロパティを継承します。</target>
        </trans-unit>
        <trans-unit id="90ef3b52113b2290b776d5edcbf7341e258eb075" translate="yes" xml:space="preserve">
          <source>Insert the strings &lt;var&gt;strings&lt;/var&gt;, just like the function &lt;code&gt;insert&lt;/code&gt;, but inherit any sticky properties from the adjoining text.</source>
          <target state="translated">関数 &lt;code&gt;insert&lt;/code&gt; と同じように文字 &lt;var&gt;strings&lt;/var&gt; 挿入しますが、隣接するテキストからスティッキープロパティを継承します。</target>
        </trans-unit>
        <trans-unit id="d4b10e59d8cd180c5c4c38922e8312024dcd937c" translate="yes" xml:space="preserve">
          <source>Inserting Text</source>
          <target state="translated">テキストの挿入</target>
        </trans-unit>
        <trans-unit id="f62a121c8905d9b70d56a62824bb530abbb240fe" translate="yes" xml:space="preserve">
          <source>Insertion and deletion in a buffer must check all the markers and relocate them if necessary. This slows processing in a buffer with a large number of markers. For this reason, it is a good idea to make a marker point nowhere if you are sure you don&amp;rsquo;t need it any more. Markers that can no longer be accessed are eventually removed (see &lt;a href=&quot;garbage-collection#Garbage-Collection&quot;&gt;Garbage Collection&lt;/a&gt;).</source>
          <target state="translated">バッファへの挿入と削除では、すべてのマーカーを確認し、必要に応じてそれらを再配置する必要があります。これにより、マーカーの数が多いバッファーでの処理が遅くなります。このため、マーカーが不要になったことが確実な場合は、マーカーポイントをどこにも配置しないことをお勧めします。アクセスできなくなったマーカーは、最終的に削除されます（&lt;a href=&quot;garbage-collection#Garbage-Collection&quot;&gt;ガベージコレクションを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="17ee0ff6e39b0d949eba112fc3626357b3a22a32" translate="yes" xml:space="preserve">
          <source>Insertion functions signal an error if the current buffer is read-only (see &lt;a href=&quot;read-only-buffers#Read-Only-Buffers&quot;&gt;Read Only Buffers&lt;/a&gt;) or if they insert within read-only text (see &lt;a href=&quot;special-properties#Special-Properties&quot;&gt;Special Properties&lt;/a&gt;).</source>
          <target state="translated">挿入関数は、現在のバッファーが読み取り専用の場合（&lt;a href=&quot;read-only-buffers#Read-Only-Buffers&quot;&gt;読み取り専用バッファーを&lt;/a&gt;参照）、または読み取り専用テキスト内に挿入する場合（&lt;a href=&quot;special-properties#Special-Properties&quot;&gt;特殊プロパティを&lt;/a&gt;参照）にエラーを通知します。</target>
        </trans-unit>
        <trans-unit id="5434f633b863c5453f6112150b15fbd13f9dde5c" translate="yes" xml:space="preserve">
          <source>Insertion moves markers located at positions after the insertion point, so that they stay with the surrounding text (see &lt;a href=&quot;markers#Markers&quot;&gt;Markers&lt;/a&gt;). When a marker points at the place of insertion, insertion may or may not relocate the marker, depending on the marker&amp;rsquo;s insertion type (see &lt;a href=&quot;marker-insertion-types#Marker-Insertion-Types&quot;&gt;Marker Insertion Types&lt;/a&gt;). Certain special functions such as &lt;code&gt;insert-before-markers&lt;/code&gt; relocate all such markers to point after the inserted text, regardless of the markers&amp;rsquo; insertion type.</source>
          <target state="translated">挿入により、挿入ポイントの後の位置にあるマーカーが移動し、周囲のテキストと一緒に表示されます（&lt;a href=&quot;markers#Markers&quot;&gt;マーカーを&lt;/a&gt;参照）。マーカーが挿入場所を指している場合、マーカーの挿入タイプに応じて、挿入によってマーカーが再配置される場合と再配置されない場合があります（&lt;a href=&quot;marker-insertion-types#Marker-Insertion-Types&quot;&gt;マーカー挿入タイプを&lt;/a&gt;参照）。 &lt;code&gt;insert-before-markers&lt;/code&gt; などの特定の特別な機能は、マーカーの挿入タイプに関係なく、挿入されたテキストの後を指すようにそのようなすべてのマーカーを再配置します。</target>
        </trans-unit>
        <trans-unit id="bd95261b13119729b7f21abc1b22f07a4f3b895c" translate="yes" xml:space="preserve">
          <source>Insertion next to a read-only character is an error if inserting ordinary text there would inherit the &lt;code&gt;read-only&lt;/code&gt; property due to stickiness. Thus, you can control permission to insert next to read-only text by controlling the stickiness. See &lt;a href=&quot;sticky-properties#Sticky-Properties&quot;&gt;Sticky Properties&lt;/a&gt;.</source>
          <target state="translated">通常のテキストを挿入すると、粘着性のために &lt;code&gt;read-only&lt;/code&gt; プロパティが継承される場合、読み取り専用文字の横に挿入するとエラーになります。したがって、粘着性を制御することにより、読み取り専用テキストの横に挿入する権限を制御できます。&lt;a href=&quot;sticky-properties#Sticky-Properties&quot;&gt;スティッキープロパティを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="0021bd63930267acc7e983ae1c2b95215f4a5f19" translate="yes" xml:space="preserve">
          <source>Insertion of text at the border between intervals also raises questions that have no satisfactory answer.</source>
          <target state="translated">間隔の境目にテキストを挿入することも、納得のいく回答が得られない問題を提起しています。</target>
        </trans-unit>
        <trans-unit id="a632b0d51711f298bce3fb60664237d20718b891" translate="yes" xml:space="preserve">
          <source>Inside a &lt;code&gt;repeat&lt;/code&gt; block, these contain the maximum number of repetitions (as specified by the &lt;var&gt;count&lt;/var&gt; parameter), and the current repetition number (counting from 0). Setting &lt;code&gt;count&lt;/code&gt; to zero will terminate the inner-most repeat block after the current repetition has completed.</source>
          <target state="translated">&lt;code&gt;repeat&lt;/code&gt; ブロック内には、最大繰り返し数（ &lt;var&gt;count&lt;/var&gt; パラメーターで指定）と現在の繰り返し数（0から数えて）が含まれます。 &lt;code&gt;count&lt;/code&gt; をゼロに設定すると、現在の繰り返しが完了した後、最も内側の繰り返しブロックが終了します。</target>
        </trans-unit>
        <trans-unit id="bbecdb627416247ff6d11ce653cbc5c864a55b32" translate="yes" xml:space="preserve">
          <source>Install &lt;var&gt;filter&lt;/var&gt; as the process filter.</source>
          <target state="translated">インストール &lt;var&gt;filter&lt;/var&gt; 加工フィルタとして。</target>
        </trans-unit>
        <trans-unit id="44e7cf106d78a4e14ed20efc7a4b48dce495ecdb" translate="yes" xml:space="preserve">
          <source>Install &lt;var&gt;plist&lt;/var&gt; as the initial plist of the process.</source>
          <target state="translated">プロセスの最初の &lt;var&gt;plist&lt;/var&gt; としてplistをインストールします。</target>
        </trans-unit>
        <trans-unit id="f8052583c9ddb4adcb58b5e1d5c25c1b544fa693" translate="yes" xml:space="preserve">
          <source>Install &lt;var&gt;sentinel&lt;/var&gt; as the process sentinel.</source>
          <target state="translated">プロセス &lt;var&gt;sentinel&lt;/var&gt; としてセンチネルをインストールします。</target>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">Installation</target>
        </trans-unit>
        <trans-unit id="16d39f83c12d88464b887e1ce49fd00973ec280c" translate="yes" xml:space="preserve">
          <source>Installing a package, either via the command &lt;code&gt;package-install-file&lt;/code&gt;, or via the Package Menu, creates a subdirectory of &lt;code&gt;package-user-dir&lt;/code&gt; named</source>
          <target state="translated">コマンド &lt;code&gt;package-install-file&lt;/code&gt; またはPackageMenuを使用してパッケージをインストールすると、 &lt;code&gt;package-user-dir&lt;/code&gt; という名前のサブディレクトリが作成されます。</target>
        </trans-unit>
        <trans-unit id="44bbd8cdd2a2c9792cd51329260082dfa8dcec4d" translate="yes" xml:space="preserve">
          <source>Installing several buffer changes atomically.</source>
          <target state="translated">複数のバッファの変更をアトミックにインストールします。</target>
        </trans-unit>
        <trans-unit id="0b8fb4bde942015c31c40daedf4c7212f24d5f6e" translate="yes" xml:space="preserve">
          <source>Instead of a string, &lt;var&gt;rep&lt;/var&gt; can be a function. In that case, &lt;code&gt;replace-regexp-in-string&lt;/code&gt; calls &lt;var&gt;rep&lt;/var&gt; for each match, passing the text of the match as its sole argument. It collects the value &lt;var&gt;rep&lt;/var&gt; returns and passes that to &lt;code&gt;replace-match&lt;/code&gt; as the replacement string. The match data at this point are the result of matching &lt;var&gt;regexp&lt;/var&gt; against a substring of &lt;var&gt;string&lt;/var&gt;.</source>
          <target state="translated">文字列の代わりに、 &lt;var&gt;rep&lt;/var&gt; を関数にすることができます。その場合、 &lt;code&gt;replace-regexp-in-string&lt;/code&gt; は、一致ごとに &lt;var&gt;rep&lt;/var&gt; を呼び出し、一致のテキストを唯一の引数として渡します。 &lt;var&gt;rep&lt;/var&gt; が返す値を収集し、それを &lt;code&gt;replace-match&lt;/code&gt; に置換文字列として渡します。この時点で一致データが一致の結果である &lt;var&gt;regexp&lt;/var&gt; のストリングに対する &lt;var&gt;string&lt;/var&gt; 。</target>
        </trans-unit>
        <trans-unit id="3f1753669c714a1d7e578072aa4ed5c9dba79dc2" translate="yes" xml:space="preserve">
          <source>Instead of adding a buffer name or a regular expression to one of these options use a &lt;code&gt;display-buffer-alist&lt;/code&gt; entry for that buffer specifying the action function &lt;code&gt;display-buffer-same-window&lt;/code&gt;.</source>
          <target state="translated">これらのオプションの1つにバッファー名または正規表現を追加する代わりに、アクション関数 &lt;code&gt;display-buffer-same-window&lt;/code&gt; を指定するそのバッファーの &lt;code&gt;display-buffer-alist&lt;/code&gt; エントリーを使用します。</target>
        </trans-unit>
        <trans-unit id="b0a6282c7355fde001d90d645305cae7bf3bf7cc" translate="yes" xml:space="preserve">
          <source>Instead of binding the mouse command in a major mode keymap, you can bind it within the link text, using the &lt;code&gt;keymap&lt;/code&gt; text property (see &lt;a href=&quot;special-properties#Special-Properties&quot;&gt;Special Properties&lt;/a&gt;). For instance:</source>
          <target state="translated">メジャーモードのキーマップでマウスコマンドをバインドする代わりに、 &lt;code&gt;keymap&lt;/code&gt; テキストプロパティを使用してリンクテキスト内でバインドできます（&lt;a href=&quot;special-properties#Special-Properties&quot;&gt;特別なプロパティを&lt;/a&gt;参照）。例えば：</target>
        </trans-unit>
        <trans-unit id="2670142fd5a30e583bc4b4555d7ebad06b38986e" translate="yes" xml:space="preserve">
          <source>Instead of computing text properties for all the text in the buffer, you can arrange to compute the text properties for parts of the text when and if something depends on them.</source>
          <target state="translated">バッファ内のすべてのテキストに対してテキストプロパティを計算するのではなく、何かがそのテキストに依存している場合には、そのテキストの一部に対してテキストプロパティを計算するようにアレンジすることができます。</target>
        </trans-unit>
        <trans-unit id="e0c382c2cc436ecc3057d41eae8562719a5d21f3" translate="yes" xml:space="preserve">
          <source>Instead of customizing this variable to &lt;code&gt;t&lt;/code&gt;, customize &lt;code&gt;display-buffer-base-action&lt;/code&gt;, for example, as follows:</source>
          <target state="translated">この変数を &lt;code&gt;t&lt;/code&gt; にカスタマイズする代わりに、たとえば、次のように &lt;code&gt;display-buffer-base-action&lt;/code&gt; をカスタマイズします。</target>
        </trans-unit>
        <trans-unit id="f48c49102d6b6fcfa99d56a07826d258451b4f42" translate="yes" xml:space="preserve">
          <source>Instead of the &amp;lsquo;</source>
          <target state="translated">'の代わりに</target>
        </trans-unit>
        <trans-unit id="27778412a3ebd3d11dbf8545f85798fd64a1f13a" translate="yes" xml:space="preserve">
          <source>Instead of using &lt;code&gt;region-beginning&lt;/code&gt; and &lt;code&gt;region-end&lt;/code&gt;, a command designed to operate on a region should normally use &lt;code&gt;interactive&lt;/code&gt; with the &amp;lsquo;</source>
          <target state="translated">代わりに使用しての &lt;code&gt;region-beginning&lt;/code&gt; と &lt;code&gt;region-end&lt;/code&gt; 通常使用する必要があり、地域で動作するように設計コマンドを &lt;code&gt;interactive&lt;/code&gt; 'は</target>
        </trans-unit>
        <trans-unit id="aaf2819d27bf1d28940bd55fb19452da2f766bc0" translate="yes" xml:space="preserve">
          <source>Instead of using this variable, it is cleaner to use another, newer feature: to pass the function as the &lt;var&gt;read-function&lt;/var&gt; argument to &lt;code&gt;eval-region&lt;/code&gt;. See &lt;a href=&quot;eval#Definition-of-eval_002dregion&quot;&gt;Eval&lt;/a&gt;.</source>
          <target state="translated">この変数を使用する代わりに、別の新しい機能を使用する方がクリーンです。つまり、関数を &lt;var&gt;read-function&lt;/var&gt; 引数として &lt;code&gt;eval-region&lt;/code&gt; に渡します。&lt;a href=&quot;eval#Definition-of-eval_002dregion&quot;&gt;Evalを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="0d2c7cb2dbf87e9087cb37f404447063050738e9" translate="yes" xml:space="preserve">
          <source>Instead of writing a character literally into a multibyte string, you can write it as its character code using an escape sequence. See &lt;a href=&quot;general-escape-syntax#General-Escape-Syntax&quot;&gt;General Escape Syntax&lt;/a&gt;, for details about escape sequences.</source>
          <target state="translated">文字を文字通りマルチバイト文字列に書き込む代わりに、エスケープシーケンスを使用して文字コードとして書き込むことができます。エスケープシーケンスの詳細については、「&lt;a href=&quot;general-escape-syntax#General-Escape-Syntax&quot;&gt;一般的なエスケープ構文&lt;/a&gt;」を参照してください。</target>
        </trans-unit>
        <trans-unit id="8e0e5c167c46a9a94a4405deed528806c20888f6" translate="yes" xml:space="preserve">
          <source>Instrumenting Macro Calls</source>
          <target state="translated">マクロコールのインストゥルメンテーション</target>
        </trans-unit>
        <trans-unit id="01d3a83d4f8979d33eb587942de6ed97b7aa1bf4" translate="yes" xml:space="preserve">
          <source>Instrumenting for Edebug</source>
          <target state="translated">Edebugのためのインストゥルメント</target>
        </trans-unit>
        <trans-unit id="08303d355edd3eb94e9dada9e860f7f9d4221540" translate="yes" xml:space="preserve">
          <source>Integer Basics</source>
          <target state="translated">整数の基礎</target>
        </trans-unit>
        <trans-unit id="5944fda631d99e7fe1c28748c40fccba38502e8a" translate="yes" xml:space="preserve">
          <source>Integer Type</source>
          <target state="translated">整数型</target>
        </trans-unit>
        <trans-unit id="0392f509cf780dcebf79ba10d500e70f3c35a232" translate="yes" xml:space="preserve">
          <source>Integers in Emacs Lisp are not limited to the machine word size. Under the hood, though, there are two kinds of integers: smaller ones, called &lt;em&gt;fixnums&lt;/em&gt;, and larger ones, called &lt;em&gt;bignums&lt;/em&gt;. Although Emacs Lisp code ordinarily should not depend on whether an integer is a fixnum or a bignum, older Emacs versions support only fixnums, some functions in Emacs still accept only fixnums, and older Emacs Lisp code may have trouble when given bignums. For example, while older Emacs Lisp code could safely compare integers for numeric equality with &lt;code&gt;eq&lt;/code&gt;, the presence of bignums means that equality predicates like &lt;code&gt;eql&lt;/code&gt; and &lt;code&gt;=&lt;/code&gt; should now be used to compare integers.</source>
          <target state="translated">Emacs Lispの整数は、マシンのワードサイズに制限されていません。ただし、&lt;em&gt;内部的&lt;/em&gt;には2種類の整数があります&lt;em&gt;。fixnum&lt;/em&gt;と呼ばれる小さい整数と&lt;em&gt;bignum&lt;/em&gt;と呼ばれる大きい&lt;em&gt;整数&lt;/em&gt;です。 Emacs Lispコードは通常、整数がfixnumであるかbignumであるかに依存するべきではありませんが、古いEmacsバージョンはfixnumのみをサポートし、Emacsの一部の関数は依然としてfixnumのみを受け入れ、古いEmacsLispコードはbignumを指定すると問題が発生する可能性があります。たとえば、古いEmacs Lispコードは整数を &lt;code&gt;eq&lt;/code&gt; と安全に比較できますが、bignumが存在するということは、 &lt;code&gt;eql&lt;/code&gt; や &lt;code&gt;=&lt;/code&gt; などの等価述語を使用して整数を比較する必要があることを意味します。</target>
        </trans-unit>
        <trans-unit id="cdaff6a8856112e0bedf086bd56487ab63649d1a" translate="yes" xml:space="preserve">
          <source>Inter-thread events.</source>
          <target state="translated">スレッド間のイベント。</target>
        </trans-unit>
        <trans-unit id="6c3d2212a9f9c32cfe9d9e6085463de2a793ed69" translate="yes" xml:space="preserve">
          <source>Interacting with the POSIX locale.</source>
          <target state="translated">POSIX ロケールとの相互作用。</target>
        </trans-unit>
        <trans-unit id="a8f3404ff9a3b9a61cebb71bc3145a7e8268e559" translate="yes" xml:space="preserve">
          <source>Interaction with normal keymaps</source>
          <target state="translated">通常のキーマップとの相互作用</target>
        </trans-unit>
        <trans-unit id="3a4d181036b390bfd4c90ee0f787d10de7dd1557" translate="yes" xml:space="preserve">
          <source>Interactive Call</source>
          <target state="translated">インタラクティブコール</target>
        </trans-unit>
        <trans-unit id="8c112c62a1db80a1fd6eb4c52dbbd37b94063133" translate="yes" xml:space="preserve">
          <source>Interactive interfaces for redefining keys.</source>
          <target state="translated">キーを再定義するためのインタラクティブなインターフェイス。</target>
        </trans-unit>
        <trans-unit id="bb426c56195b2ae94b49e74ad823d065b0153c08" translate="yes" xml:space="preserve">
          <source>Interactively, &lt;code&gt;byte-recompile-directory&lt;/code&gt; prompts for &lt;var&gt;directory&lt;/var&gt; and &lt;var&gt;flag&lt;/var&gt; is the prefix argument.</source>
          <target state="translated">インタラクティブに、 &lt;code&gt;byte-recompile-directory&lt;/code&gt; は &lt;var&gt;directory&lt;/var&gt; と &lt;var&gt;flag&lt;/var&gt; プロンプトをプレフィックス引数として使用します。</target>
        </trans-unit>
        <trans-unit id="89db943b3ea009e2eeb342d7b413658ef1beb7e7" translate="yes" xml:space="preserve">
          <source>Interactively, &lt;var&gt;mode&lt;/var&gt; is read from the minibuffer using &lt;code&gt;read-file-modes&lt;/code&gt; (see below), which lets the user type in either an integer or a string representing the permissions symbolically.</source>
          <target state="translated">インタラクティブに、 &lt;var&gt;mode&lt;/var&gt; はread &lt;code&gt;read-file-modes&lt;/code&gt; （以下を参照）を使用してミニバッファーから読み取られます。これにより、ユーザーはアクセス許可を象徴的に表す整数または文字列を入力できます。</target>
        </trans-unit>
        <trans-unit id="1ac1b597f72189ba2ae56769e0cdd444c02533a2" translate="yes" xml:space="preserve">
          <source>Interactively, or when &lt;var&gt;display&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, the return value is also displayed in the echo area.</source>
          <target state="translated">インタラクティブに、または &lt;var&gt;display&lt;/var&gt; が &lt;code&gt;nil&lt;/code&gt; 以外の場合、戻り値もエコー領域に表示されます。</target>
        </trans-unit>
        <trans-unit id="b6a1797fff7a6f70ada887bad92631a8a9bf2bb1" translate="yes" xml:space="preserve">
          <source>Interfacing to an archive web server</source>
          <target state="translated">アーカイブウェブサーバとのインターフェース</target>
        </trans-unit>
        <trans-unit id="6fd6296201ee71e0d25d2f3b29fb410be639536c" translate="yes" xml:space="preserve">
          <source>Interfacing to an archive web server.</source>
          <target state="translated">アーカイブウェブサーバとのインターフェイス。</target>
        </trans-unit>
        <trans-unit id="b88993e0e807666740f1e6e7487891d4221c3508" translate="yes" xml:space="preserve">
          <source>Internal Border</source>
          <target state="translated">内部ボーダー</target>
        </trans-unit>
        <trans-unit id="1f6f7ba7cb7b347a96d1107fab7991d51090ae38" translate="yes" xml:space="preserve">
          <source>Internal mechanisms of image display.</source>
          <target state="translated">画像表示の内部機構。</target>
        </trans-unit>
        <trans-unit id="aae2d2f7d4d44e63ffbe3d64c1331e1f4a7499c4" translate="yes" xml:space="preserve">
          <source>Internal size of a buffer, i.e., &lt;code&gt;sizeof (struct buffer)&lt;/code&gt;. (Do not confuse with the value returned by &lt;code&gt;buffer-size&lt;/code&gt; function.)</source>
          <target state="translated">バッファの内部サイズ、つまり &lt;code&gt;sizeof (struct buffer)&lt;/code&gt; 。（ &lt;code&gt;buffer-size&lt;/code&gt; 関数によって返される値と混同しないでください。）</target>
        </trans-unit>
        <trans-unit id="5a032235c1121bf9c1e0179ca7ff43c3f2ac2220" translate="yes" xml:space="preserve">
          <source>Internal size of a cons cell, i.e., &lt;code&gt;sizeof (struct Lisp_Cons)&lt;/code&gt;.</source>
          <target state="translated">consセルの内部サイズ、つまり &lt;code&gt;sizeof (struct Lisp_Cons)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b01e7eab827250f987c16a7e503e6a91dd12d67d" translate="yes" xml:space="preserve">
          <source>Internal size of a float object, i.e., &lt;code&gt;sizeof (struct Lisp_Float)&lt;/code&gt;. (Do not confuse it with the native platform &lt;code&gt;float&lt;/code&gt; or &lt;code&gt;double&lt;/code&gt;.)</source>
          <target state="translated">floatオブジェクトの内部サイズ、つまり &lt;code&gt;sizeof (struct Lisp_Float)&lt;/code&gt; 。（ネイティブプラットフォームの &lt;code&gt;float&lt;/code&gt; または &lt;code&gt;double&lt;/code&gt; と混同しないでください。）</target>
        </trans-unit>
        <trans-unit id="1837980aa62b1a62e48654b616a2e12c11db3594" translate="yes" xml:space="preserve">
          <source>Internal size of a string header, i.e., &lt;code&gt;sizeof (struct Lisp_String)&lt;/code&gt;.</source>
          <target state="translated">文字列ヘッダーの内部サイズ、つまり &lt;code&gt;sizeof (struct Lisp_String)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="674373e621338f8918b9cf85fce5944b7e0a8d86" translate="yes" xml:space="preserve">
          <source>Internal size of a symbol, i.e., &lt;code&gt;sizeof (struct Lisp_Symbol)&lt;/code&gt;.</source>
          <target state="translated">シンボルの内部サイズ、つまり &lt;code&gt;sizeof (struct Lisp_Symbol)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b4e2cb2dd48ef88f7cd7e24e4c124a254fe9f746" translate="yes" xml:space="preserve">
          <source>Internal size of a vector slot, always equal to &lt;code&gt;sizeof (Lisp_Object)&lt;/code&gt;.</source>
          <target state="translated">ベクトルスロットの内部サイズ。常に &lt;code&gt;sizeof (Lisp_Object)&lt;/code&gt; と同じです。</target>
        </trans-unit>
        <trans-unit id="0ee27812d3f05af328dcd6e592fdf426cab58207" translate="yes" xml:space="preserve">
          <source>Internal size of an interval object, i.e., &lt;code&gt;sizeof (struct interval)&lt;/code&gt;.</source>
          <target state="translated">間隔オブジェクトの内部サイズ、つまり &lt;code&gt;sizeof (struct interval)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="96c24069c6a8e1694d80a391c18f10c673381b44" translate="yes" xml:space="preserve">
          <source>Internally, &lt;code&gt;defalias&lt;/code&gt; normally uses &lt;code&gt;fset&lt;/code&gt; to set the definition. If &lt;var&gt;name&lt;/var&gt; has a &lt;code&gt;defalias-fset-function&lt;/code&gt; property, however, the associated value is used as a function to call in place of &lt;code&gt;fset&lt;/code&gt;.</source>
          <target state="translated">内部的には、 &lt;code&gt;defalias&lt;/code&gt; は通常 &lt;code&gt;fset&lt;/code&gt; を使用して定義を設定します。場合は &lt;var&gt;name&lt;/var&gt; あり &lt;code&gt;defalias-fset-function&lt;/code&gt; プロパティを、しかし、関連する値の代わりに呼び出すための関数として使用されている &lt;code&gt;fset&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="068796783fad3a87ca900b7c710e4916ea8b3bc6" translate="yes" xml:space="preserve">
          <source>Internally, &lt;code&gt;defcustom&lt;/code&gt; uses the symbol property &lt;code&gt;standard-value&lt;/code&gt; to record the expression for the standard value, &lt;code&gt;saved-value&lt;/code&gt; to record the value saved by the user with the customization buffer, and &lt;code&gt;customized-value&lt;/code&gt; to record the value set by the user with the customization buffer, but not saved. See &lt;a href=&quot;symbol-properties#Symbol-Properties&quot;&gt;Symbol Properties&lt;/a&gt;. In addition, there&amp;rsquo;s &lt;code&gt;themed-value&lt;/code&gt;, which is used to record the value set by a theme (see &lt;a href=&quot;custom-themes#Custom-Themes&quot;&gt;Custom Themes&lt;/a&gt;). These properties are lists, the car of which is an expression that evaluates to the value.</source>
          <target state="translated">内部的には、 &lt;code&gt;defcustom&lt;/code&gt; はシンボルプロパティ &lt;code&gt;standard-value&lt;/code&gt; を使用して標準値の式を記録し、 &lt;code&gt;saved-value&lt;/code&gt; はユーザーがカスタマイズバッファーで保存した &lt;code&gt;customized-value&lt;/code&gt; を記録し、customized-valueはユーザーがカスタマイズで設定した値を記録します。バッファですが、保存されません。&lt;a href=&quot;symbol-properties#Symbol-Properties&quot;&gt;シンボルのプロパティを&lt;/a&gt;参照してください。さらに、テーマによって設定された値を記録するために使用される &lt;code&gt;themed-value&lt;/code&gt; があります（&lt;a href=&quot;custom-themes#Custom-Themes&quot;&gt;カスタムテーマを&lt;/a&gt;参照）。これらのプロパティはリストであり、その車は値に評価される式です。</target>
        </trans-unit>
        <trans-unit id="d530007eafdd82a256c358d7298bdbec30d8cfb6" translate="yes" xml:space="preserve">
          <source>Internally, &lt;code&gt;make-serial-process&lt;/code&gt; calls &lt;code&gt;serial-process-configure&lt;/code&gt; for the initial configuration of the serial port.</source>
          <target state="translated">内部的には、 &lt;code&gt;make-serial-process&lt;/code&gt; は、シリアルポートの初期構成のために &lt;code&gt;serial-process-configure&lt;/code&gt; を呼び出します。</target>
        </trans-unit>
        <trans-unit id="793925a115b236f980464335670b39f399baa2cd" translate="yes" xml:space="preserve">
          <source>Internally, &lt;code&gt;word-search-forward&lt;/code&gt; and related functions use the function &lt;code&gt;word-search-regexp&lt;/code&gt; to convert &lt;var&gt;string&lt;/var&gt; to a regular expression that ignores punctuation.</source>
          <target state="translated">内部的には、 &lt;code&gt;word-search-forward&lt;/code&gt; および関連する関数は、関数 &lt;code&gt;word-search-regexp&lt;/code&gt; を使用して、 &lt;var&gt;string&lt;/var&gt; を句読点を無視する正規表現に変換します。</target>
        </trans-unit>
        <trans-unit id="975cc38153f45730f641194a328f88d442fb0adf" translate="yes" xml:space="preserve">
          <source>Internally, Emacs arranges windows in a tree; each group of siblings has a parent window whose area includes all the siblings. This field points to the window&amp;rsquo;s parent in that tree, as a Lisp object. For the root window of the tree and a minibuffer window this is always &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">内部的には、Emacsはウィンドウをツリーに配置します。兄弟の各グループには、すべての兄弟が含まれる領域の親ウィンドウがあります。このフィールドは、Lispオブジェクトとして、そのツリー内のウィンドウの親を指します。ツリーのルートウィンドウとミニバッファウィンドウの場合、これは常に &lt;code&gt;nil&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="c9a16f1135c9a066d602dd303b59514a13358f60" translate="yes" xml:space="preserve">
          <source>Internally, Emacs stores each face&amp;rsquo;s default spec in its &lt;code&gt;face-defface-spec&lt;/code&gt; symbol property (see &lt;a href=&quot;symbol-properties#Symbol-Properties&quot;&gt;Symbol Properties&lt;/a&gt;). The &lt;code&gt;saved-face&lt;/code&gt; property stores any face spec saved by the user using the customization buffer; the &lt;code&gt;customized-face&lt;/code&gt; property stores the face spec customized for the current session, but not saved; and the &lt;code&gt;theme-face&lt;/code&gt; property stores an alist associating the active customization settings and Custom themes with the face specs for that face. The face&amp;rsquo;s documentation string is stored in the &lt;code&gt;face-documentation&lt;/code&gt; property.</source>
          <target state="translated">内部的には、Emacsは各面のデフォルトスペックを &lt;code&gt;face-defface-spec&lt;/code&gt; シンボルプロパティに保存します（&lt;a href=&quot;symbol-properties#Symbol-Properties&quot;&gt;シンボルプロパティを&lt;/a&gt;参照）。 &lt;code&gt;saved-face&lt;/code&gt; 特性格納カスタマイズバッファを用いてユーザによって保存された任意の顔スペック。 &lt;code&gt;customized-face&lt;/code&gt; プロパティは、現在のセッションのためにカスタマイズされた顔の仕様を格納しますが、保存されません。また、 &lt;code&gt;theme-face&lt;/code&gt; プロパティには、アクティブなカスタマイズ設定とカスタムテーマをその顔の顔の仕様に関連付けるリストが格納されます。顔のドキュメント文字列は、 &lt;code&gt;face-documentation&lt;/code&gt; プロパティに保存されます。</target>
        </trans-unit>
        <trans-unit id="890345b36f6729af8e091b77ec37233f091c4268" translate="yes" xml:space="preserve">
          <source>Internally, a byte-code function object is much like a vector; its elements can be accessed using &lt;code&gt;aref&lt;/code&gt;. Its printed representation is like that for a vector, with an additional &amp;lsquo;</source>
          <target state="translated">内部的には、バイトコード関数オブジェクトはベクトルによく似ています。その要素には、 &lt;code&gt;aref&lt;/code&gt; を使用してアクセスできます。その印刷された表現は、ベクトルの表現に似ていますが、 'が追加されています</target>
        </trans-unit>
        <trans-unit id="c255d867bde58e3eaa0e52e4d12a66d31afbc458" translate="yes" xml:space="preserve">
          <source>Internally, a record object is much like a vector; its slots can be accessed using &lt;code&gt;aref&lt;/code&gt; and it can be copied using &lt;code&gt;copy-sequence&lt;/code&gt;. However, the first slot is used to hold its type as returned by &lt;code&gt;type-of&lt;/code&gt;. Also, in the current implementation records can have at most 4096 slots, whereas vectors can be much larger. Like arrays, records use zero-origin indexing: the first slot has index 0.</source>
          <target state="translated">内部的には、レコードオブジェクトはベクトルによく似ています。そのスロットには &lt;code&gt;aref&lt;/code&gt; を使用してアクセスでき、 &lt;code&gt;copy-sequence&lt;/code&gt; を使用してコピーできます。ただし、最初のスロットは、 &lt;code&gt;type-of&lt;/code&gt; によって返されるタイプを保持するために使用されます。また、現在の実装では、レコードは最大4096のスロットを持つことができますが、ベクトルははるかに大きくなる可能性があります。配列と同様に、レコードはゼロオリジンインデックスを使用します。最初のスロットのインデックスは0です。</target>
        </trans-unit>
        <trans-unit id="10ce65f3f55d9a82d5a4e5b0c5a3b5dfc8acdf3d" translate="yes" xml:space="preserve">
          <source>Internally, a syntax table is a char-table (see &lt;a href=&quot;char_002dtables#Char_002dTables&quot;&gt;Char-Tables&lt;/a&gt;). The element at index &lt;var&gt;c&lt;/var&gt; describes the character with code &lt;var&gt;c&lt;/var&gt;; its value is a cons cell which specifies the syntax of the character in question. See &lt;a href=&quot;syntax-table-internals#Syntax-Table-Internals&quot;&gt;Syntax Table Internals&lt;/a&gt;, for details. However, instead of using &lt;code&gt;aset&lt;/code&gt; and &lt;code&gt;aref&lt;/code&gt; to modify and inspect syntax table contents, you should usually use the higher-level functions &lt;code&gt;char-syntax&lt;/code&gt; and &lt;code&gt;modify-syntax-entry&lt;/code&gt;, which are described in &lt;a href=&quot;syntax-table-functions#Syntax-Table-Functions&quot;&gt;Syntax Table Functions&lt;/a&gt;.</source>
          <target state="translated">内部的には、構文テーブルはchar-tableです（&lt;a href=&quot;char_002dtables#Char_002dTables&quot;&gt;Char-Tablesを&lt;/a&gt;参照）。インデックス &lt;var&gt;c&lt;/var&gt; の要素は、コード &lt;var&gt;c&lt;/var&gt; で文字を記述します。その値は、問題の文字の構文を指定するconsセルです。詳細については、&lt;a href=&quot;syntax-table-internals#Syntax-Table-Internals&quot;&gt;構文テーブルの内部&lt;/a&gt;を参照してください。ただし、構文テーブルの内容を変更および検査するために &lt;code&gt;aset&lt;/code&gt; および &lt;code&gt;aref&lt;/code&gt; を使用する代わりに、通常、&lt;a href=&quot;syntax-table-functions#Syntax-Table-Functions&quot;&gt;構文テーブル関数で&lt;/a&gt;説明されている高レベルの関数 &lt;code&gt;char-syntax&lt;/code&gt; および &lt;code&gt;modify-syntax-entry&lt;/code&gt; を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="ab6dcb624548f874717d593593cde5ae43f61956" translate="yes" xml:space="preserve">
          <source>Internally, the dynamic loading of documentation strings is accomplished by writing compiled files with a special Lisp reader construct, &amp;lsquo;</source>
          <target state="translated">内部的には、ドキュメント文字列の動的ロードは、コンパイルされたファイルを特別なLispリーダー構造で書き込むことによって実現されます。</target>
        </trans-unit>
        <trans-unit id="6c7d074b02409a43b3c3691b8e3eff070049c70c" translate="yes" xml:space="preserve">
          <source>Internally, the set of parents is stored in the &lt;code&gt;error-conditions&lt;/code&gt; property of the error symbol and the message is stored in the &lt;code&gt;error-message&lt;/code&gt; property of the error symbol.</source>
          <target state="translated">内部的には、親のセットはエラーシンボルの &lt;code&gt;error-conditions&lt;/code&gt; プロパティに格納され、メッセージはエラーシンボルの &lt;code&gt;error-message&lt;/code&gt; プロパティに格納されます。</target>
        </trans-unit>
        <trans-unit id="5b6293020ceb499ae9005377abda5b9d10b853fe" translate="yes" xml:space="preserve">
          <source>Internally, this function creates an overlay, and gives it a &lt;code&gt;before-string&lt;/code&gt; property containing text that has a &lt;code&gt;display&lt;/code&gt; property whose value is the image. (Whew!)</source>
          <target state="translated">内部的には、この関数はオーバーレイを作成し、値がimageである &lt;code&gt;display&lt;/code&gt; プロパティを持つテキストを含む &lt;code&gt;before-string&lt;/code&gt; プロパティを提供します。（ふぅ！）</target>
        </trans-unit>
        <trans-unit id="ad027260c034e64a0aed9ec0c21434a870d67bde" translate="yes" xml:space="preserve">
          <source>Internally, this function inserts &lt;var&gt;string&lt;/var&gt; in the buffer, and gives it a &lt;code&gt;display&lt;/code&gt; property which specifies &lt;var&gt;image&lt;/var&gt;. See &lt;a href=&quot;display-property#Display-Property&quot;&gt;Display Property&lt;/a&gt;.</source>
          <target state="translated">内部的には、この関数は &lt;var&gt;string&lt;/var&gt; をバッファに挿入し、 &lt;var&gt;image&lt;/var&gt; を指定する &lt;code&gt;display&lt;/code&gt; プロパティをバッファに与えます。&lt;a href=&quot;display-property#Display-Property&quot;&gt;表示プロパティを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="d82805e46a43054034aa8dbdc3072940853963ca" translate="yes" xml:space="preserve">
          <source>Internals of Drag-and-Drop implementation.</source>
          <target state="translated">ドラッグアンドドロップ実装の内部。</target>
        </trans-unit>
        <trans-unit id="0878947a69e042d32e6c0e5b544cd467d1e941d1" translate="yes" xml:space="preserve">
          <source>Internals of the Debugger</source>
          <target state="translated">デバッガの内部</target>
        </trans-unit>
        <trans-unit id="f059416759860bf53ccffccb3662c0ac1c504a36" translate="yes" xml:space="preserve">
          <source>Internals of the Kill Ring</source>
          <target state="translated">キルリングの内部</target>
        </trans-unit>
        <trans-unit id="c8a6d283f50874c1f273c7066e8f6024a632ca2a" translate="yes" xml:space="preserve">
          <source>International characters in strings.</source>
          <target state="translated">文字列内の国際文字。</target>
        </trans-unit>
        <trans-unit id="2a55fdbcbc93e7871a3735ecdecb37fb80ceb461" translate="yes" xml:space="preserve">
          <source>Interning ensures that each obarray has just one symbol with any particular name. Other like-named symbols may exist, but not in the same obarray. Thus, the reader gets the same symbols for the same names, as long as you keep reading with the same obarray.</source>
          <target state="translated">インターナリングにより、各 obarray には特定の名前を持つシンボルが 1 つだけ存在することになります。同じ名前のシンボルが存在しても、同じオブレイには存在しないことがあります。このように、同じオブレイで読み続ける限り、同じ名前のシンボルを得ることができます。</target>
        </trans-unit>
        <trans-unit id="a82f77a8f55334d8bb59e260c5127cc00a4536b2" translate="yes" xml:space="preserve">
          <source>Interning usually happens automatically in the reader, but sometimes other programs need to do it. For example, after the</source>
          <target state="translated">インターナリングは通常、リーダーの中で自動的に行われますが、他のプログラムがそれを行う必要がある場合もあります。例えば</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="8ed8ee7e55170bcbcc50e6f4ddad4940be31b3b2" translate="yes" xml:space="preserve">
          <source>Introduction and concepts.</source>
          <target state="translated">導入と概念。</target>
        </trans-unit>
        <trans-unit id="f63dc883116ea7e854aa44d7f9ec4421e0ce2395" translate="yes" xml:space="preserve">
          <source>Introduction and conventions used.</source>
          <target state="translated">紹介文と使用されている慣用句。</target>
        </trans-unit>
        <trans-unit id="b8caf81bc82bf9149f7f4f8ca46a4d2df8d59d59" translate="yes" xml:space="preserve">
          <source>Introduction to Buffer-Local Variables</source>
          <target state="translated">バッファローカル変数の紹介</target>
        </trans-unit>
        <trans-unit id="ca959ab108e8c4b82e06c2cd8e7df1402c2fdca1" translate="yes" xml:space="preserve">
          <source>Introduction to Evaluation</source>
          <target state="translated">評価入門</target>
        </trans-unit>
        <trans-unit id="424b5352ecd6aed0c4787a5e67cf7822394d4180" translate="yes" xml:space="preserve">
          <source>Introduction to Minibuffers</source>
          <target state="translated">ミニバッファーの紹介</target>
        </trans-unit>
        <trans-unit id="08f3e034c9cceb45ce8ecb8f79ad7b810051e748" translate="yes" xml:space="preserve">
          <source>Introduction to Reading and Printing</source>
          <target state="translated">読書・印刷入門</target>
        </trans-unit>
        <trans-unit id="97ad18054b9569eed06f9ecf25bb01ba9f0544fc" translate="yes" xml:space="preserve">
          <source>Introduction to use of Edebug.</source>
          <target state="translated">Edebugの使い方を紹介します。</target>
        </trans-unit>
        <trans-unit id="fb00fd291ed8bdc1da78f75b2dfea4fe96a9552c" translate="yes" xml:space="preserve">
          <source>Invalid coding system</source>
          <target state="translated">無効なコーディングシステム</target>
        </trans-unit>
        <trans-unit id="f4da90dedff4144a88b3f5641db5e04aea389b0e" translate="yes" xml:space="preserve">
          <source>Invalid format operation</source>
          <target state="translated">無効なフォーマット操作</target>
        </trans-unit>
        <trans-unit id="05b9e32cfa1dec4a8735af4f154c5c0b16324e49" translate="yes" xml:space="preserve">
          <source>Invalid function</source>
          <target state="translated">無効な関数</target>
        </trans-unit>
        <trans-unit id="21f66391b38e2d6c5385ca6d73c08b6046139bff" translate="yes" xml:space="preserve">
          <source>Invalid read syntax</source>
          <target state="translated">無効な読み取り構文</target>
        </trans-unit>
        <trans-unit id="39af5982d90c7c046f2c0e30d3c43a0d69f7c511" translate="yes" xml:space="preserve">
          <source>Invalid read syntax: &quot;)&quot;</source>
          <target state="translated">無効な読み取り構文です。&quot;)&quot;</target>
        </trans-unit>
        <trans-unit id="1f526a95f220fa3e397793791a95103a25349fa5" translate="yes" xml:space="preserve">
          <source>Invalid regexp</source>
          <target state="translated">無効な正規表現</target>
        </trans-unit>
        <trans-unit id="c28782659524c74728d4791e47ac0768f2d2a2fa" translate="yes" xml:space="preserve">
          <source>Invisible Text</source>
          <target state="translated">不可視テキスト</target>
        </trans-unit>
        <trans-unit id="1ba45e6efe9b69076beb81f22754c2276b515f29" translate="yes" xml:space="preserve">
          <source>Invokes &lt;code&gt;pop-to-buffer&lt;/code&gt; to proceed.</source>
          <target state="translated">&lt;code&gt;pop-to-buffer&lt;/code&gt; を呼び出して続行します。</target>
        </trans-unit>
        <trans-unit id="2b6f179c44acf946ea87d5fd9a67e79980a7bf28" translate="yes" xml:space="preserve">
          <source>Invoking the Debugger</source>
          <target state="translated">デバッガの起動</target>
        </trans-unit>
        <trans-unit id="3b5c7ed80b795c31ca809c1980f8e9b7ef9b7cb4" translate="yes" xml:space="preserve">
          <source>Invoking the Input Method</source>
          <target state="translated">入力メソッドの呼び出し</target>
        </trans-unit>
        <trans-unit id="f95535be202c390af54850aaa2b9814ce9f60024" translate="yes" xml:space="preserve">
          <source>Invoking the minibuffer with completion.</source>
          <target state="translated">補完でミニバッファを呼び出します。</target>
        </trans-unit>
        <trans-unit id="d82cb1a6affac049d5e0a64e8bc2eabc7098b52a" translate="yes" xml:space="preserve">
          <source>Is a given file readable? Writable?</source>
          <target state="translated">与えられたファイルは読めるか? 書き込み可能か?</target>
        </trans-unit>
        <trans-unit id="cc345fde3dff917a2877747ac2b2a0a59a508cad" translate="yes" xml:space="preserve">
          <source>Is it a directory? A symbolic link?</source>
          <target state="translated">それはディレクトリですか?シンボリックリンク?</target>
        </trans-unit>
        <trans-unit id="ce731c05fc64ab5b57ee9d5ba394e0ea5eb6be0b" translate="yes" xml:space="preserve">
          <source>Is this object a list? Comparing two lists.</source>
          <target state="translated">このオブジェクトはリストですか?2つのリストを比較します。</target>
        </trans-unit>
        <trans-unit id="faf1e5134b7192f681808c3c7a3dcf14d24adcce" translate="yes" xml:space="preserve">
          <source>It adds subdirectories to &lt;code&gt;load-path&lt;/code&gt;, by running the file named</source>
          <target state="translated">名前の付いたファイルを実行することにより、 &lt;code&gt;load-path&lt;/code&gt; サブディレクトリを追加します</target>
        </trans-unit>
        <trans-unit id="26ebe0ae609401a2ad28c4f3ef880f902fb57804" translate="yes" xml:space="preserve">
          <source>It also affects decisions about whether to scroll part of the screen or repaint on text terminals. See &lt;a href=&quot;forcing-redisplay#Forcing-Redisplay&quot;&gt;Forcing Redisplay&lt;/a&gt;, for the corresponding functionality on graphical terminals.</source>
          <target state="translated">また、画面の一部をスクロールするか、テキスト端末で再描画するかについての決定にも影響します。グラフィカル端末の対応する機能については、&lt;a href=&quot;forcing-redisplay#Forcing-Redisplay&quot;&gt;強制的な再表示を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="a4141f73f90581e1ab9aa132384bbf4e5ae08ded" translate="yes" xml:space="preserve">
          <source>It also applies to any asynchronous subprocess or network stream, but in a different way: the value of &lt;code&gt;coding-system-for-read&lt;/code&gt; when you start the subprocess or open the network stream specifies the input decoding method for that subprocess or network stream. It remains in use for that subprocess or network stream unless and until overridden.</source>
          <target state="translated">これは、非同期サブプロセスまたはネットワークストリームにも適用されますが、方法が異なります。サブプロセスを開始するとき、またはネットワークストリームを開くときの、 &lt;code&gt;coding-system-for-read&lt;/code&gt; の値は、そのサブプロセスまたはネットワークストリームの入力デコード方法を指定します。オーバーライドされない限り、そのサブプロセスまたはネットワークストリームで使用され続けます。</target>
        </trans-unit>
        <trans-unit id="aace0e7e04bb1701d0b33950723bc535b0281f25" translate="yes" xml:space="preserve">
          <source>It also displays the symbols in a buffer named</source>
          <target state="translated">という名前のバッファにシンボルを表示します。</target>
        </trans-unit>
        <trans-unit id="10f4c6d92e33b4069ea7366cc5044b10b6555757" translate="yes" xml:space="preserve">
          <source>It always returns &lt;code&gt;t&lt;/code&gt; for buffers that are not visiting a file, even if &lt;code&gt;visited-file-modtime&lt;/code&gt; returns a non-zero value. For instance, it always returns &lt;code&gt;t&lt;/code&gt; for dired buffers. It returns &lt;code&gt;t&lt;/code&gt; for buffers that are visiting a file that does not exist and never existed, but &lt;code&gt;nil&lt;/code&gt; for file-visiting buffers whose file has been deleted.</source>
          <target state="translated">&lt;code&gt;visited-file-modtime&lt;/code&gt; がゼロ以外の値を返した場合でも、ファイルにアクセスしていないバッファーに対しては常に &lt;code&gt;t&lt;/code&gt; を返します。たとえば、diredバッファの場合は常に &lt;code&gt;t&lt;/code&gt; を返します。存在せず、存在したことのないファイルにアクセスしているバッファの場合は &lt;code&gt;t&lt;/code&gt; を返しますが、ファイルが削除されたファイルにアクセスしているバッファの場合は &lt;code&gt;nil&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="36679f079089d8681a01f756abfb5ab13128d005" translate="yes" xml:space="preserve">
          <source>It always sets the file modes of the copied files to match the corresponding original file.</source>
          <target state="translated">コピーされたファイルのファイルモードを常に対応する元のファイルと一致するように設定します。</target>
        </trans-unit>
        <trans-unit id="68c121eadb6645154879627e1f8f4d91b9159e0d" translate="yes" xml:space="preserve">
          <source>It blocks out all process output (since Emacs accepts process output only while waiting).</source>
          <target state="translated">すべてのプロセス出力をブロックします(Emacsは待機中のみプロセス出力を受け付けるので)。</target>
        </trans-unit>
        <trans-unit id="db1622f7113638a1b6cf00fc1d147d1151f5939d" translate="yes" xml:space="preserve">
          <source>It blocks out any idle timers that ought to run during that time.</source>
          <target state="translated">その間に実行されるべきアイドルタイマーをブロックします。</target>
        </trans-unit>
        <trans-unit id="500a99712580a0fd93b02db9ad0f50b8dfd5061d" translate="yes" xml:space="preserve">
          <source>It calls &lt;code&gt;frame-notice-user-settings&lt;/code&gt;, which modifies the parameters of the selected frame according to whatever the init files specify.</source>
          <target state="translated">&lt;code&gt;frame-notice-user-settings&lt;/code&gt; を呼び出します。これは、initファイルで指定されている内容に従って、選択したフレームのパラメーターを変更します。</target>
        </trans-unit>
        <trans-unit id="08316562225e169cff224da3eaa939766d93f6e4" translate="yes" xml:space="preserve">
          <source>It calls the function &lt;code&gt;package-activate-all&lt;/code&gt; to activate any optional Emacs Lisp package that has been installed. See &lt;a href=&quot;packaging-basics#Packaging-Basics&quot;&gt;Packaging Basics&lt;/a&gt;. However, Emacs doesn&amp;rsquo;t activate the packages when &lt;code&gt;package-enable-at-startup&lt;/code&gt; is &lt;code&gt;nil&lt;/code&gt; or when it&amp;rsquo;s started with one of the options &amp;lsquo;</source>
          <target state="translated">関数 &lt;code&gt;package-activate-all&lt;/code&gt; を呼び出して、インストールされているオプションのEmacsLispパッケージをアクティブにします。&lt;a href=&quot;packaging-basics#Packaging-Basics&quot;&gt;パッケージングの基本を&lt;/a&gt;参照してください。ただし、 &lt;code&gt;package-enable-at-startup&lt;/code&gt; が &lt;code&gt;nil&lt;/code&gt; の場合、またはオプションの1つで開始された場合、Emacsはパッケージをアクティブ化しません。</target>
        </trans-unit>
        <trans-unit id="0136b0ca24d16b01a291e47bd7153f4f2fba2a73" translate="yes" xml:space="preserve">
          <source>It creates the submenu &lt;var&gt;menu-title&lt;/var&gt; specified by &lt;var&gt;sub-alist&lt;/var&gt;.</source>
          <target state="translated">&lt;var&gt;sub-alist&lt;/var&gt; で指定されたサブメニュー &lt;var&gt;menu-title&lt;/var&gt; を作成します。</target>
        </trans-unit>
        <trans-unit id="69c1303d35db5ea0aad7fd95fc917c9a224ef2f1" translate="yes" xml:space="preserve">
          <source>It displays the &lt;em&gt;startup screen&lt;/em&gt;, which is a special buffer that contains information about copyleft and basic Emacs usage. This is not done if &lt;code&gt;inhibit-startup-screen&lt;/code&gt; or &lt;code&gt;initial-buffer-choice&lt;/code&gt; are non-&lt;code&gt;nil&lt;/code&gt;, or if the &amp;lsquo;</source>
          <target state="translated">&lt;em&gt;起動画面が&lt;/em&gt;表示され&lt;em&gt;ます&lt;/em&gt;。これは、コピーレフトと基本的なEmacsの使用法に関する情報を含む特別なバッファーです。これは、 &lt;code&gt;inhibit-startup-screen&lt;/code&gt; または &lt;code&gt;initial-buffer-choice&lt;/code&gt; が &lt;code&gt;nil&lt;/code&gt; 以外の場合、または '</target>
        </trans-unit>
        <trans-unit id="26297586b2674d5e45392b02c3a4a0a6b4471608" translate="yes" xml:space="preserve">
          <source>It displays the initial echo area message, unless you have suppressed that with &lt;code&gt;inhibit-startup-echo-area-message&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;inhibit-startup-echo-area-message&lt;/code&gt; 抑制していない限り、最初のエコーエリアメッセージが表示されます。</target>
        </trans-unit>
        <trans-unit id="deb0e9c99bf58c06b6f38c7c256f96f0b734089a" translate="yes" xml:space="preserve">
          <source>It does not matter to the caller of a function whether the function is primitive. However, this does matter if you try to redefine a primitive with a function written in Lisp. The reason is that the primitive function may be called directly from C code. Calls to the redefined function from Lisp will use the new definition, but calls from C code may still use the built-in definition. Therefore, &lt;strong&gt;we discourage redefinition of primitive functions&lt;/strong&gt;.</source>
          <target state="translated">関数がプリミティブであるかどうかは、関数の呼び出し元にとって重要ではありません。ただし、Lispで記述された関数を使用してプリミティブを再定義しようとする場合、これは重要です。その理由は、プリミティブ関数がCコードから直接呼び出される可能性があるためです。Lispからの再定義された関数の呼び出しは新しい定義を使用しますが、Cコードからの呼び出しは引き続き組み込みの定義を使用する場合があります。したがって、&lt;strong&gt;プリミティブ関数の再定義はお勧めしません&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="dc2cfa8003c37f1bb7b6976cb93df4aaf5e867c7" translate="yes" xml:space="preserve">
          <source>It does some basic parsing of the command-line arguments.</source>
          <target state="translated">コマンドライン引数の基本的な解析を行います。</target>
        </trans-unit>
        <trans-unit id="780d4f9cb3c97b4270953a6df1b1b787aacbefcb" translate="yes" xml:space="preserve">
          <source>It first deletes any child frame of &lt;var&gt;frame&lt;/var&gt; (see &lt;a href=&quot;child-frames#Child-Frames&quot;&gt;Child Frames&lt;/a&gt;) and any frame whose &lt;code&gt;delete-before&lt;/code&gt; frame parameter (see &lt;a href=&quot;frame-interaction-parameters#Frame-Interaction-Parameters&quot;&gt;Frame Interaction Parameters&lt;/a&gt;) specifies &lt;var&gt;frame&lt;/var&gt;. All such deletions are performed recursively; so this step makes sure that no other frames with &lt;var&gt;frame&lt;/var&gt; as their ancestor will exist. Then, unless &lt;var&gt;frame&lt;/var&gt; specifies a tooltip, this function runs the hook &lt;code&gt;delete-frame-functions&lt;/code&gt; (each function getting one argument, &lt;var&gt;frame&lt;/var&gt;) before actually killing the frame. After actually killing the frame and removing the frame from the frame list, &lt;code&gt;delete-frame&lt;/code&gt; runs &lt;code&gt;after-delete-frame-functions&lt;/code&gt;.</source>
          <target state="translated">これは、最初の子フレームを削除 &lt;var&gt;frame&lt;/var&gt; （参照&lt;a href=&quot;child-frames#Child-Frames&quot;&gt;子フレームを&lt;/a&gt;）し、その任意のフレーム &lt;code&gt;delete-before&lt;/code&gt; フレームパラメータ（参照&lt;a href=&quot;frame-interaction-parameters#Frame-Interaction-Parameters&quot;&gt;フレーム相互作用パラメータを&lt;/a&gt;）指定し &lt;var&gt;frame&lt;/var&gt; 。このような削除はすべて再帰的に実行されます。したがって、この手順では、 &lt;var&gt;frame&lt;/var&gt; を祖先とする他のフレームが存在しないことを確認します。次に、 &lt;var&gt;frame&lt;/var&gt; がツールチップを指定しない限り、この関数は実際にフレームを強制終了する前にフック &lt;code&gt;delete-frame-functions&lt;/code&gt; （各関数は1つの引数 &lt;var&gt;frame&lt;/var&gt; を取得します）を実行します。実際にフレームを強制終了し、フレームリストからフレームを削除した後、 &lt;code&gt;delete-frame&lt;/code&gt; が実行されます &lt;code&gt;after-delete-frame-functions&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="65b6824863bde18952e797a108d59972b5cd7ca4" translate="yes" xml:space="preserve">
          <source>It follows the cyclic ordering of windows. The optional arguments &lt;var&gt;minibuf&lt;/var&gt; and &lt;var&gt;all-frames&lt;/var&gt; specify the set of windows included; these have the same arguments as in &lt;code&gt;next-window&lt;/code&gt;. If &lt;var&gt;all-frames&lt;/var&gt; specifies a frame, the first window walked is the first window on that frame (the one returned by &lt;code&gt;frame-first-window&lt;/code&gt;), not necessarily the selected window.</source>
          <target state="translated">これは、ウィンドウの循環順序に従います。オプションの引数 &lt;var&gt;minibuf&lt;/var&gt; および &lt;var&gt;all-frames&lt;/var&gt; は、含まれるウィンドウのセットを指定します。これらには、 &lt;code&gt;next-window&lt;/code&gt; の場合と同じ引数があります。 &lt;var&gt;all-frames&lt;/var&gt; がフレームを指定している場合、最初にウォークされたウィンドウはそのフレームの最初のウィンドウ（ &lt;code&gt;frame-first-window&lt;/code&gt; によって返されるウィンドウ）であり、必ずしも選択されたウィンドウである必要はありません。</target>
        </trans-unit>
        <trans-unit id="d6d1323f650d9889c77490ede806efe0a1b71711" translate="yes" xml:space="preserve">
          <source>It initializes the initial frame&amp;rsquo;s faces, and sets up the menu bar and tool bar if needed. If graphical frames are supported, it sets up the tool bar even if the current frame is not a graphical one, since a graphical frame may be created later on.</source>
          <target state="translated">初期フレームの面を初期化し、必要に応じてメニューバーとツールバーを設定します。グラフィカルフレームがサポートされている場合、グラフィカルフレームは後で作成される可能性があるため、現在のフレームがグラフィカルフレームでなくてもツールバーが設定されます。</target>
        </trans-unit>
        <trans-unit id="4dd46431e678931fbcb6b6537b9da5f2a07769f6" translate="yes" xml:space="preserve">
          <source>It inserts frequency counts as comment lines after each line of code. You can undo all insertions with one &lt;code&gt;undo&lt;/code&gt; command. The counts appear under the &amp;lsquo;</source>
          <target state="translated">コードの各行の後に、頻度カウントをコメント行として挿入します。1つの &lt;code&gt;undo&lt;/code&gt; コマンドですべての挿入を元に戻すことができます。カウントは 'の下に表示されます</target>
        </trans-unit>
        <trans-unit id="3173cca5c8e25be905c421498d74ebe861b45fb4" translate="yes" xml:space="preserve">
          <source>It is a good idea for this function to run &lt;code&gt;temp-buffer-show-hook&lt;/code&gt; just as &lt;code&gt;with-output-to-temp-buffer&lt;/code&gt; normally would, inside of &lt;code&gt;save-selected-window&lt;/code&gt; and with the chosen window and buffer selected.</source>
          <target state="translated">この関数では、 &lt;code&gt;save-selected-window&lt;/code&gt; 内で、選択したウィンドウとバッファーを選択した状態で、 &lt;code&gt;with-output-to-temp-buffer&lt;/code&gt; が通常行うのと同じように &lt;code&gt;temp-buffer-show-hook&lt;/code&gt; を実行することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="12a15b18bad26a84d1b400ed140fae6294485d46" translate="yes" xml:space="preserve">
          <source>It is a good idea to provide documentation strings for all the functions in your program, even those that are called only from within your program. Documentation strings are like comments, except that they are easier to access.</source>
          <target state="translated">プログラム内のすべての関数について、プログラム内からのみ呼び出される関数であっても、ドキュメント文字列を提供することをお勧めします。ドキュメントの文字列はコメントのようなものですが、アクセスしやすいという点を除いては同じです。</target>
        </trans-unit>
        <trans-unit id="f01ee6ca8bab6f5d9577b6a2063514f28c09839e" translate="yes" xml:space="preserve">
          <source>It is also legitimate for a major mode to rebind a standard key sequence whose standard meaning is rarely useful in that mode. For instance, minibuffer modes rebind</source>
          <target state="translated">メジャーモードでは、標準的な意味がそのモードではほとんど役に立たない標準的なキー配列をリバインドすることも正当です。例えば、ミニバッファモードは</target>
        </trans-unit>
        <trans-unit id="2b57f5bccf3ef0816a9be0839152c423c58bb643" translate="yes" xml:space="preserve">
          <source>It is also possible to call &lt;code&gt;sit-for&lt;/code&gt; with three arguments, as &lt;code&gt;(sit-for &lt;var&gt;seconds&lt;/var&gt; &lt;var&gt;millisec&lt;/var&gt; &lt;var&gt;nodisp&lt;/var&gt;)&lt;/code&gt;, but that is considered obsolete.</source>
          <target state="translated">呼び出すことも可能である &lt;code&gt;sit-for&lt;/code&gt; 三つの引数を持つ、など &lt;code&gt;(sit-for &lt;var&gt;seconds&lt;/var&gt; &lt;var&gt;millisec&lt;/var&gt; &lt;var&gt;nodisp&lt;/var&gt;)&lt;/code&gt; が、それは時代遅れと見なされます。</target>
        </trans-unit>
        <trans-unit id="baad5ec4e1257ce583e2c8021e1913799f72c849" translate="yes" xml:space="preserve">
          <source>It is also possible to find out how many arguments an arbitrary function expects:</source>
          <target state="translated">また、任意の関数が期待する引数の数を調べることも可能です。</target>
        </trans-unit>
        <trans-unit id="a6c145fead22c2d038d5449b927625f21786cd2b" translate="yes" xml:space="preserve">
          <source>It is also possible to watch filesystems on remote machines, see &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Remote-Files.html#Remote-Files&quot;&gt;Remote Files&lt;/a&gt; in</source>
          <target state="translated">リモートマシンでファイルシステムを監視することもできます。の&lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Remote-Files.html#Remote-Files&quot;&gt;リモートファイル&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="3e621862bcf1c790b5d037616916bbe2c538d4f7" translate="yes" xml:space="preserve">
          <source>It is an error to call &lt;code&gt;condition-wait&lt;/code&gt; without holding the condition&amp;rsquo;s associated mutex.</source>
          <target state="translated">条件に関連付けられたミューテックスを保持せずに &lt;code&gt;condition-wait&lt;/code&gt; を呼び出すとエラーになります。</target>
        </trans-unit>
        <trans-unit id="a7b086934bad52d2aec76907ca52328c3844b39e" translate="yes" xml:space="preserve">
          <source>It is an error to make a constant or a read-only variable buffer-local. See &lt;a href=&quot;constant-variables#Constant-Variables&quot;&gt;Constant Variables&lt;/a&gt;.</source>
          <target state="translated">定数または読み取り専用変数をバッファローカルにするのはエラーです。&lt;a href=&quot;constant-variables#Constant-Variables&quot;&gt;定数変数を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="72843249d94cfc895b70ea2d9791255b690c126e" translate="yes" xml:space="preserve">
          <source>It is assumed that when a caller of &lt;code&gt;display-buffer&lt;/code&gt; specifies a non-&lt;code&gt;nil&lt;/code&gt;&lt;code&gt;allow-no-window&lt;/code&gt; entry, it is also able to handle a &lt;code&gt;nil&lt;/code&gt; return value.</source>
          <target state="translated">&lt;code&gt;display-buffer&lt;/code&gt; の呼び出し元が &lt;code&gt;nil&lt;/code&gt; 以外の &lt;code&gt;allow-no-window&lt;/code&gt; エントリを指定すると、 &lt;code&gt;nil&lt;/code&gt; の戻り値も処理できると想定されます。</target>
        </trans-unit>
        <trans-unit id="3f80f1cfd1cf04e4bc17393008731d354dfb2372" translate="yes" xml:space="preserve">
          <source>It is best to avoid mentioning specific bit numbers in your program. To test the modifier bits of a character, use the function &lt;code&gt;event-modifiers&lt;/code&gt; (see &lt;a href=&quot;classifying-events#Classifying-Events&quot;&gt;Classifying Events&lt;/a&gt;). When making key bindings, you can use the read syntax for characters with modifier bits (&amp;lsquo;</source>
          <target state="translated">プログラムで特定のビット番号について言及することは避けるのが最善です。文字の修飾子ビットをテストするには、関数 &lt;code&gt;event-modifiers&lt;/code&gt; を使用します（&lt;a href=&quot;classifying-events#Classifying-Events&quot;&gt;イベントの分類を&lt;/a&gt;参照）。キーバインディングを作成する場合、修飾子ビット（ '）を含む文字の読み取り構文を使用できます。</target>
        </trans-unit>
        <trans-unit id="0d52a1fb8bf86f61e2abf981d0b44f7de8aa8b26" translate="yes" xml:space="preserve">
          <source>It is common for Lisp functions to accept functions as arguments or find them in data structures (especially in hook variables and property lists) and call them using &lt;code&gt;funcall&lt;/code&gt; or &lt;code&gt;apply&lt;/code&gt;. Functions that accept function arguments are often called &lt;em&gt;functionals&lt;/em&gt;.</source>
          <target state="translated">Lisp関数は、関数を引数として受け入れるか、データ構造（特にフック変数とプロパティリスト）でそれらを &lt;code&gt;funcall&lt;/code&gt; 、funcallまたは &lt;code&gt;apply&lt;/code&gt; を使用してそれらを呼び出すのが一般的です。関数の引数を受け入れる関数は、しばしば&lt;em&gt;汎関数&lt;/em&gt;と呼ばれ&lt;em&gt;ます&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="3f754947b959e216056814f1e32b8d9283beb7a0" translate="yes" xml:space="preserve">
          <source>It is common to add code to one&amp;rsquo;s init file (see &lt;a href=&quot;init-file#Init-File&quot;&gt;Init File&lt;/a&gt;) to add one or more directories to &lt;code&gt;load-path&lt;/code&gt;. For example:</source>
          <target state="translated">自分のinitファイル（&lt;a href=&quot;init-file#Init-File&quot;&gt;Init Fileを&lt;/a&gt;参照）にコードを追加して、1つ以上のディレクトリを &lt;code&gt;load-path&lt;/code&gt; に追加するのが一般的です。例えば：</target>
        </trans-unit>
        <trans-unit id="b83625c7041cfe9ad97f496a0522d9523b3b8dc4" translate="yes" xml:space="preserve">
          <source>It is common to write numbers, characters, strings, and even vectors in Lisp code, taking advantage of the fact that they self-evaluate. However, it is quite unusual to do this for types that lack a read syntax, because there&amp;rsquo;s no way to write them textually. It is possible to construct Lisp expressions containing these types by means of a Lisp program. Here is an example:</source>
          <target state="translated">数値、文字、文字列、さらにはベクトルをLispコードで記述し、それらが自己評価するという事実を利用するのが一般的です。ただし、読み取り構文がない型に対してこれを行うのは非常に珍しいことです。これは、テキストで書き込む方法がないためです。 Lispプログラムを使用して、これらのタイプを含むLisp式を作成することができます。次に例を示します。</target>
        </trans-unit>
        <trans-unit id="6c4f2df1721f4ac95ab46d4cfe55ed881a7d9df2" translate="yes" xml:space="preserve">
          <source>It is equally easy to insert a new element by changing &lt;small&gt;CDR&lt;/small&gt;s:</source>
          <target state="translated">It is equally easy to insert a new element by changing &lt;small&gt;CDR&lt;/small&gt;s:</target>
        </trans-unit>
        <trans-unit id="66640a1037abec141a287214c7037d4b09466e4e" translate="yes" xml:space="preserve">
          <source>It is generally cleaner and more flexible to store a function in a data structure, and call it with &lt;code&gt;funcall&lt;/code&gt; or &lt;code&gt;apply&lt;/code&gt;, than to store an expression in the data structure and evaluate it. Using functions provides the ability to pass information to them as arguments.</source>
          <target state="translated">It is generally cleaner and more flexible to store a function in a data structure, and call it with &lt;code&gt;funcall&lt;/code&gt; or &lt;code&gt;apply&lt;/code&gt; , than to store an expression in the data structure and evaluate it. Using functions provides the ability to pass information to them as arguments.</target>
        </trans-unit>
        <trans-unit id="7224f1903528385d0d899a0e49ee687a6aa9d558" translate="yes" xml:space="preserve">
          <source>It is generally impossible to read the same sequence twice, since sequences are always created anew upon reading. If you read the read syntax for a sequence twice, you get two sequences with equal contents. There is one exception: the empty list &lt;code&gt;()&lt;/code&gt; always stands for the same object, &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">It is generally impossible to read the same sequence twice, since sequences are always created anew upon reading. If you read the read syntax for a sequence twice, you get two sequences with equal contents. There is one exception: the empty list &lt;code&gt;()&lt;/code&gt; always stands for the same object, &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e2e4677a7491341a5525f2d613fb39d09d0efa30" translate="yes" xml:space="preserve">
          <source>It is implemented using the watchpoint mechanism, so it inherits the same characteristics and limitations: all aliases of &lt;var&gt;variable&lt;/var&gt; will be watched together, only dynamic variables can be watched, and changes to the objects referenced by variables are not detected. For details, see &lt;a href=&quot;watching-variables#Watching-Variables&quot;&gt;Watching Variables&lt;/a&gt;.</source>
          <target state="translated">It is implemented using the watchpoint mechanism, so it inherits the same characteristics and limitations: all aliases of &lt;var&gt;variable&lt;/var&gt; will be watched together, only dynamic variables can be watched, and changes to the objects referenced by variables are not detected. For details, see &lt;a href=&quot;watching-variables#Watching-Variables&quot;&gt;Watching Variables&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="8bb7af09e2683dd1d43399c262cc53e7f80c18fb" translate="yes" xml:space="preserve">
          <source>It is important to assure that point does not continuously jump around as a consequence of auto-reverting. Of course, moving point might be inevitable if the buffer radically changes.</source>
          <target state="translated">自動反転の結果、ポイントが連続的に飛び回ることがないようにすることが重要です。もちろん、バッファが急激に変化した場合には、ポイントの移動は避けられないかもしれません。</target>
        </trans-unit>
        <trans-unit id="3eede72b9dece35e34101793a2f333f89d89a4f4" translate="yes" xml:space="preserve">
          <source>It is invoked via a mouse command.</source>
          <target state="translated">マウスコマンドで起動します。</target>
        </trans-unit>
        <trans-unit id="b5639d37fabd83f8e595d9ba42541031771e2456" translate="yes" xml:space="preserve">
          <source>It is legitimate for a major mode to rebind a standard key sequence if it provides a command that does the same job in a way better suited to the text this mode is used for. For example, a major mode for editing a programming language might redefine</source>
          <target state="translated">メジャーモードが標準キー配列を再バインドすることは、そのモードが使用されているテキストに適した方法で同じ仕事をするコマンドを提供している場合には、正当なことです。例えば、プログラミング言語を編集するためのメジャーモードは</target>
        </trans-unit>
        <trans-unit id="eae810ab4df9e8a364d85ae8c7b547bd3e8d8937" translate="yes" xml:space="preserve">
          <source>It is normal practice to change the bindings in the global keymap, but you should not assign this variable any value other than the keymap it starts out with.</source>
          <target state="translated">グローバルキーマップ内のバインディングを変更するのは通常のことですが、この変数には、最初に始まるキーマップ以外の値を代入してはいけません。</target>
        </trans-unit>
        <trans-unit id="c7f2848da15c9bd47e2aa08dc291366d9534c8a8" translate="yes" xml:space="preserve">
          <source>It is not advisable to put anything in</source>
          <target state="translated">に何かを入れるのはお勧めできません。</target>
        </trans-unit>
        <trans-unit id="2bbf03bc73d7ef3e252d6245e26ed80331379d73" translate="yes" xml:space="preserve">
          <source>It is not crucial to exclude from the alist the keysyms of other X servers; those do no harm, as long as they don&amp;rsquo;t conflict with the ones used by the X server actually in use.</source>
          <target state="translated">It is not crucial to exclude from the alist the keysyms of other X servers; those do no harm, as long as they don&amp;rsquo;t conflict with the ones used by the X server actually in use.</target>
        </trans-unit>
        <trans-unit id="6c9d03ef366e0475e733b12fb4ac0e9991b62830" translate="yes" xml:space="preserve">
          <source>It is not sufficient to determine whether a given window shows the currently active minibuffer by comparing it with the result of &lt;code&gt;(minibuffer-window)&lt;/code&gt;, because there can be more than one minibuffer window if there is more than one frame.</source>
          <target state="translated">It is not sufficient to determine whether a given window shows the currently active minibuffer by comparing it with the result of &lt;code&gt;(minibuffer-window)&lt;/code&gt; , because there can be more than one minibuffer window if there is more than one frame.</target>
        </trans-unit>
        <trans-unit id="0e93812a73d2bc561240927bd0add1fb2b57b9cb" translate="yes" xml:space="preserve">
          <source>It is often convenient to write a function that allows certain arguments to be omitted. For example, the function &lt;code&gt;substring&lt;/code&gt; accepts three arguments&amp;mdash;a string, the start index and the end index&amp;mdash;but the third argument defaults to the &lt;var&gt;length&lt;/var&gt; of the string if you omit it. It is also convenient for certain functions to accept an indefinite number of arguments, as the functions &lt;code&gt;list&lt;/code&gt; and &lt;code&gt;+&lt;/code&gt; do.</source>
          <target state="translated">It is often convenient to write a function that allows certain arguments to be omitted. For example, the function &lt;code&gt;substring&lt;/code&gt; accepts three arguments&amp;mdash;a string, the start index and the end index&amp;mdash;but the third argument defaults to the &lt;var&gt;length&lt;/var&gt; of the string if you omit it. It is also convenient for certain functions to accept an indefinite number of arguments, as the functions &lt;code&gt;list&lt;/code&gt; and &lt;code&gt;+&lt;/code&gt; do.</target>
        </trans-unit>
        <trans-unit id="4d267166b6e7f4643511ccbc7ed7e8692e1af1ee" translate="yes" xml:space="preserve">
          <source>It is often useful to move point temporarily within a localized portion of the program. This is called an &lt;em&gt;excursion&lt;/em&gt;, and it is done with the &lt;code&gt;save-excursion&lt;/code&gt; special form. This construct remembers the initial identity of the current buffer, and its value of point, and restores them after the excursion completes. It is the standard way to move point within one part of a program and avoid affecting the rest of the program, and is used thousands of times in the Lisp sources of Emacs.</source>
          <target state="translated">It is often useful to move point temporarily within a localized portion of the program. This is called an &lt;em&gt;excursion&lt;/em&gt;, and it is done with the &lt;code&gt;save-excursion&lt;/code&gt; special form. This construct remembers the initial identity of the current buffer, and its value of point, and restores them after the excursion completes. It is the standard way to move point within one part of a program and avoid affecting the rest of the program, and is used thousands of times in the Lisp sources of Emacs.</target>
        </trans-unit>
        <trans-unit id="4a9a518d3c351efa42f91492c1d3d264dda80369" translate="yes" xml:space="preserve">
          <source>It is ok for a mode to use &lt;code&gt;font-lock-face&lt;/code&gt; for some text and also use the normal Font Lock machinery. But if the mode does not use the normal Font Lock machinery, it should not set the variable &lt;code&gt;font-lock-defaults&lt;/code&gt;. In this case the &lt;code&gt;face&lt;/code&gt; property will not be overriden, so using the &lt;code&gt;face&lt;/code&gt; property could work too. However, using &lt;code&gt;font-lock-face&lt;/code&gt; is generally preferable as it allows the user to control the fontification by toggling &lt;code&gt;font-lock-mode&lt;/code&gt;, and lets the code work regardless of whether the mode uses Font Lock machinery or not.</source>
          <target state="translated">It is ok for a mode to use &lt;code&gt;font-lock-face&lt;/code&gt; for some text and also use the normal Font Lock machinery. But if the mode does not use the normal Font Lock machinery, it should not set the variable &lt;code&gt;font-lock-defaults&lt;/code&gt; . In this case the &lt;code&gt;face&lt;/code&gt; property will not be overriden, so using the &lt;code&gt;face&lt;/code&gt; property could work too. However, using &lt;code&gt;font-lock-face&lt;/code&gt; is generally preferable as it allows the user to control the fontification by toggling &lt;code&gt;font-lock-mode&lt;/code&gt; , and lets the code work regardless of whether the mode uses Font Lock machinery or not.</target>
        </trans-unit>
        <trans-unit id="c3d2ba074f26ffb62a211357cea324dbc4b2f4ea" translate="yes" xml:space="preserve">
          <source>It is possible to advise a primitive (see &lt;a href=&quot;what-is-a-function#What-Is-a-Function&quot;&gt;What Is a Function&lt;/a&gt;), but one should typically &lt;em&gt;not&lt;/em&gt; do so, for two reasons. Firstly, some primitives are used by the advice mechanism, and advising them could cause an infinite recursion. Secondly, many primitives are called directly from C, and such calls ignore advice; hence, one ends up in a confusing situation where some calls (occurring from Lisp code) obey the advice and other calls (from C code) do not.</source>
          <target state="translated">It is possible to advise a primitive (see &lt;a href=&quot;what-is-a-function#What-Is-a-Function&quot;&gt;What Is a Function&lt;/a&gt;), but one should typically &lt;em&gt;not&lt;/em&gt; do so, for two reasons. Firstly, some primitives are used by the advice mechanism, and advising them could cause an infinite recursion. Secondly, many primitives are called directly from C, and such calls ignore advice; hence, one ends up in a confusing situation where some calls (occurring from Lisp code) obey the advice and other calls (from C code) do not.</target>
        </trans-unit>
        <trans-unit id="158ec131ed80fbe1245b2dbcf3882b001d0a335c" translate="yes" xml:space="preserve">
          <source>It is possible to avoid implicit resizing of a specific window when there are one or more other resizable windows on the same frame. For this purpose, Emacs must be advised to &lt;em&gt;preserve&lt;/em&gt; the size of that window. There are two basic ways to do that.</source>
          <target state="translated">It is possible to avoid implicit resizing of a specific window when there are one or more other resizable windows on the same frame. For this purpose, Emacs must be advised to &lt;em&gt;preserve&lt;/em&gt; the size of that window. There are two basic ways to do that.</target>
        </trans-unit>
        <trans-unit id="5059d1ca2b3130d76d02552f9db1a53062d38b02" translate="yes" xml:space="preserve">
          <source>It is possible to read a special file (such as a FIFO or an I/O device) with &lt;code&gt;insert-file-contents&lt;/code&gt;, as long as &lt;var&gt;replace&lt;/var&gt; and &lt;var&gt;visit&lt;/var&gt; are &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">It is possible to read a special file (such as a FIFO or an I/O device) with &lt;code&gt;insert-file-contents&lt;/code&gt; , as long as &lt;var&gt;replace&lt;/var&gt; and &lt;var&gt;visit&lt;/var&gt; are &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="206fcc689764ad9025a7ae9e9481deb9e1a87744" translate="yes" xml:space="preserve">
          <source>It is possible to use &lt;code&gt;char-after&lt;/code&gt; to examine characters at various buffer positions without moving point to those positions. Only an actual change in the value of point runs these hook functions.</source>
          <target state="translated">It is possible to use &lt;code&gt;char-after&lt;/code&gt; to examine characters at various buffer positions without moving point to those positions. Only an actual change in the value of point runs these hook functions.</target>
        </trans-unit>
        <trans-unit id="ea9002dbd9b169e39f06dc37297bb765ac7c9c2f" translate="yes" xml:space="preserve">
          <source>It is possible to use an anonymous Lisp macro just like an anonymous function, but this is never done, because it does not make sense to pass an anonymous macro to functionals such as &lt;code&gt;mapcar&lt;/code&gt;. In practice, all Lisp macros have names, and they are almost always defined with the &lt;code&gt;defmacro&lt;/code&gt; macro.</source>
          <target state="translated">It is possible to use an anonymous Lisp macro just like an anonymous function, but this is never done, because it does not make sense to pass an anonymous macro to functionals such as &lt;code&gt;mapcar&lt;/code&gt; . In practice, all Lisp macros have names, and they are almost always defined with the &lt;code&gt;defmacro&lt;/code&gt; macro.</target>
        </trans-unit>
        <trans-unit id="91987bc01ce4e25960e8f7c77d19903b336be8fa" translate="yes" xml:space="preserve">
          <source>It is probably a good idea for the functions to do nothing if the character after &lt;var&gt;pos&lt;/var&gt; already has a non-&lt;code&gt;nil&lt;/code&gt;&lt;code&gt;fontified&lt;/code&gt; property, but this is not required. If one function overrides the assignments made by a previous one, the properties after the last function finishes are the ones that really matter.</source>
          <target state="translated">It is probably a good idea for the functions to do nothing if the character after &lt;var&gt;pos&lt;/var&gt; already has a non- &lt;code&gt;nil&lt;/code&gt; &lt;code&gt;fontified&lt;/code&gt; property, but this is not required. If one function overrides the assignments made by a previous one, the properties after the last function finishes are the ones that really matter.</target>
        </trans-unit>
        <trans-unit id="8c50e007c4847dde92fe8e165d1a24f7fbca3071" translate="yes" xml:space="preserve">
          <source>It is quite common to use some storage for a while, then release it by (for example) killing a buffer or deleting the last pointer to an object. Emacs provides a &lt;em&gt;garbage collector&lt;/em&gt; to reclaim this abandoned storage. The garbage collector operates by finding and marking all Lisp objects that are still accessible to Lisp programs. To begin with, it assumes all the symbols, their values and associated function definitions, and any data presently on the stack, are accessible. Any objects that can be reached indirectly through other accessible objects are also accessible.</source>
          <target state="translated">It is quite common to use some storage for a while, then release it by (for example) killing a buffer or deleting the last pointer to an object. Emacs provides a &lt;em&gt;garbage collector&lt;/em&gt; to reclaim this abandoned storage. The garbage collector operates by finding and marking all Lisp objects that are still accessible to Lisp programs. To begin with, it assumes all the symbols, their values and associated function definitions, and any data presently on the stack, are accessible. Any objects that can be reached indirectly through other accessible objects are also accessible.</target>
        </trans-unit>
        <trans-unit id="9f81f2fefce2410ae1512655349098e0d74c8ad5" translate="yes" xml:space="preserve">
          <source>It is risky to change this variable&amp;rsquo;s value without doing various other things. Normally it is better to use &lt;code&gt;set-visited-file-name&lt;/code&gt; (see below); some of the things done there, such as changing the buffer name, are not strictly necessary, but others are essential to avoid confusing Emacs.</source>
          <target state="translated">It is risky to change this variable&amp;rsquo;s value without doing various other things. Normally it is better to use &lt;code&gt;set-visited-file-name&lt;/code&gt; (see below); some of the things done there, such as changing the buffer name, are not strictly necessary, but others are essential to avoid confusing Emacs.</target>
        </trans-unit>
        <trans-unit id="81c490de37e7452de0a620a005a47606bd70b349" translate="yes" xml:space="preserve">
          <source>It is sometimes useful to make two variables synonyms, so that both variables always have the same value, and changing either one also changes the other. Whenever you change the name of a variable&amp;mdash;either because you realize its old name was not well chosen, or because its meaning has partly changed&amp;mdash;it can be useful to keep the old name as an &lt;em&gt;alias&lt;/em&gt; of the new one for compatibility. You can do this with &lt;code&gt;defvaralias&lt;/code&gt;.</source>
          <target state="translated">It is sometimes useful to make two variables synonyms, so that both variables always have the same value, and changing either one also changes the other. Whenever you change the name of a variable&amp;mdash;either because you realize its old name was not well chosen, or because its meaning has partly changed&amp;mdash;it can be useful to keep the old name as an &lt;em&gt;alias&lt;/em&gt; of the new one for compatibility. You can do this with &lt;code&gt;defvaralias&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a2a84b8c48d3b060fcc06470427ce26c8399bf6f" translate="yes" xml:space="preserve">
          <source>It is sometimes useful to take some action when a variable changes its value. The &lt;em&gt;variable watchpoint&lt;/em&gt; facility provides the means to do so. Some possible uses for this feature include keeping display in sync with variable settings, and invoking the debugger to track down unexpected changes to variables (see &lt;a href=&quot;variable-debugging#Variable-Debugging&quot;&gt;Variable Debugging&lt;/a&gt;).</source>
          <target state="translated">It is sometimes useful to take some action when a variable changes its value. The &lt;em&gt;variable watchpoint&lt;/em&gt; facility provides the means to do so. Some possible uses for this feature include keeping display in sync with variable settings, and invoking the debugger to track down unexpected changes to variables (see &lt;a href=&quot;variable-debugging#Variable-Debugging&quot;&gt;Variable Debugging&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="3f4f9ca54d322d9dfa0b17bef44fd7e71b5662a0" translate="yes" xml:space="preserve">
          <source>It is useful to specify the &lt;code&gt;:require&lt;/code&gt; keyword for an option that turns on a certain feature. This causes Emacs to load the feature, if it is not already loaded, whenever the option is set. See &lt;a href=&quot;common-keywords#Common-Keywords&quot;&gt;Common Keywords&lt;/a&gt;. Here is an example:</source>
          <target state="translated">It is useful to specify the &lt;code&gt;:require&lt;/code&gt; keyword for an option that turns on a certain feature. This causes Emacs to load the feature, if it is not already loaded, whenever the option is set. See &lt;a href=&quot;common-keywords#Common-Keywords&quot;&gt;Common Keywords&lt;/a&gt;. Here is an example:</target>
        </trans-unit>
        <trans-unit id="1084186213269f2884b66a5901a0fe109856708d" translate="yes" xml:space="preserve">
          <source>It is usually a bad idea for timer functions to alter buffer contents. When they do, they usually should call &lt;code&gt;undo-boundary&lt;/code&gt; both before and after changing the buffer, to separate the timer&amp;rsquo;s changes from user commands&amp;rsquo; changes and prevent a single undo entry from growing to be quite large.</source>
          <target state="translated">It is usually a bad idea for timer functions to alter buffer contents. When they do, they usually should call &lt;code&gt;undo-boundary&lt;/code&gt; both before and after changing the buffer, to separate the timer&amp;rsquo;s changes from user commands&amp;rsquo; changes and prevent a single undo entry from growing to be quite large.</target>
        </trans-unit>
        <trans-unit id="51bfeb221e33f8fd00e57f4226da961d1d317a23" translate="yes" xml:space="preserve">
          <source>It is usually a bad idea to have more than one process associated with the same buffer.</source>
          <target state="translated">通常、同じバッファに複数のプロセスが関連付けられているのは良くありません。</target>
        </trans-unit>
        <trans-unit id="341cb9738d8f2bcab2233c96dc993a86f9598f86" translate="yes" xml:space="preserve">
          <source>It is very common to read a Lisp form and then evaluate the form, but reading and evaluation are separate activities, and either can be performed alone. Reading per se does not evaluate anything; it converts the printed representation of a Lisp object to the object itself. It is up to the caller of &lt;code&gt;read&lt;/code&gt; to specify whether this object is a form to be evaluated, or serves some entirely different purpose. See &lt;a href=&quot;input-functions#Input-Functions&quot;&gt;Input Functions&lt;/a&gt;.</source>
          <target state="translated">It is very common to read a Lisp form and then evaluate the form, but reading and evaluation are separate activities, and either can be performed alone. Reading per se does not evaluate anything; it converts the printed representation of a Lisp object to the object itself. It is up to the caller of &lt;code&gt;read&lt;/code&gt; to specify whether this object is a form to be evaluated, or serves some entirely different purpose. See &lt;a href=&quot;input-functions#Input-Functions&quot;&gt;Input Functions&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="545d22f4c3da6e907a054b17ba6817a718596224" translate="yes" xml:space="preserve">
          <source>It is very unusual to change the global keymap.</source>
          <target state="translated">グローバルキーマップを変更するのは非常に珍しいです。</target>
        </trans-unit>
        <trans-unit id="96139028099a0bfa0975054c4ed4730a63010934" translate="yes" xml:space="preserve">
          <source>It loads any</source>
          <target state="translated">それは任意の</target>
        </trans-unit>
        <trans-unit id="ce4af309e8e71369b6c603cca0cfd8e3be09a193" translate="yes" xml:space="preserve">
          <source>It loads the library</source>
          <target state="translated">ライブラリをロードします。</target>
        </trans-unit>
        <trans-unit id="f58887fd3294e17aa3e3e1af45b67849abc46e36" translate="yes" xml:space="preserve">
          <source>It loads your abbrevs from the file specified by &lt;code&gt;abbrev-file-name&lt;/code&gt;, if that file exists and can be read (see &lt;a href=&quot;abbrev-files#Abbrev-Files&quot;&gt;abbrev-file-name&lt;/a&gt;). This is not done if the option &amp;lsquo;</source>
          <target state="translated">It loads your abbrevs from the file specified by &lt;code&gt;abbrev-file-name&lt;/code&gt; , if that file exists and can be read (see &lt;a href=&quot;abbrev-files#Abbrev-Files&quot;&gt;abbrev-file-name&lt;/a&gt;). This is not done if the option &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="dea39a1a58b57ed5c242a688a8b16e364190e632" translate="yes" xml:space="preserve">
          <source>It loads your early init file (see &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Early-Init-File.html#Early-Init-File&quot;&gt;Early Init File&lt;/a&gt; in</source>
          <target state="translated">It loads your early init file (see &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Early-Init-File.html#Early-Init-File&quot;&gt;Early Init File&lt;/a&gt; in</target>
        </trans-unit>
        <trans-unit id="a9b670a2bbddceb4c5ab7bd11a55ab2796be2d98" translate="yes" xml:space="preserve">
          <source>It loads your init file (see &lt;a href=&quot;init-file#Init-File&quot;&gt;Init File&lt;/a&gt;). This is not done if the options &amp;lsquo;</source>
          <target state="translated">It loads your init file (see &lt;a href=&quot;init-file#Init-File&quot;&gt;Init File&lt;/a&gt;). This is not done if the options &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="26dc9b8940f0ed8395f81364b4d2c60b19096a69" translate="yes" xml:space="preserve">
          <source>It makes a difference whether the user&amp;rsquo;s variable is named &lt;code&gt;a&lt;/code&gt; or &lt;code&gt;x&lt;/code&gt;, because &lt;code&gt;a&lt;/code&gt; conflicts with the macro argument variable &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">It makes a difference whether the user&amp;rsquo;s variable is named &lt;code&gt;a&lt;/code&gt; or &lt;code&gt;x&lt;/code&gt; , because &lt;code&gt;a&lt;/code&gt; conflicts with the macro argument variable &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3f588db542d569932c817bd6b5fdaa9a4f1bd05c" translate="yes" xml:space="preserve">
          <source>It may be a Lisp expression that is not a string; then it should be a form that is evaluated to get a list of arguments to pass to the command. Usually this form will call various functions to read input from the user, most often through the minibuffer (see &lt;a href=&quot;minibuffers#Minibuffers&quot;&gt;Minibuffers&lt;/a&gt;) or directly from the keyboard (see &lt;a href=&quot;reading-input#Reading-Input&quot;&gt;Reading Input&lt;/a&gt;).</source>
          <target state="translated">It may be a Lisp expression that is not a string; then it should be a form that is evaluated to get a list of arguments to pass to the command. Usually this form will call various functions to read input from the user, most often through the minibuffer (see &lt;a href=&quot;minibuffers#Minibuffers&quot;&gt;Minibuffers&lt;/a&gt;) or directly from the keyboard (see &lt;a href=&quot;reading-input#Reading-Input&quot;&gt;Reading Input&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="e657a7f0ef3da4440c9a172406d4c83cc7a6c0ec" translate="yes" xml:space="preserve">
          <source>It may be a string; its contents are a sequence of elements separated by newlines, one for each argument&lt;a href=&quot;#FOOT12&quot; name=&quot;DOCF12&quot;&gt;&lt;sup&gt;12&lt;/sup&gt;&lt;/a&gt;. Each element consists of a code character (see &lt;a href=&quot;interactive-codes#Interactive-Codes&quot;&gt;Interactive Codes&lt;/a&gt;) optionally followed by a prompt (which some code characters use and some ignore). Here is an example:</source>
          <target state="translated">It may be a string; its contents are a sequence of elements separated by newlines, one for each argument&lt;a href=&quot;#FOOT12&quot; name=&quot;DOCF12&quot;&gt;&lt;sup&gt;12&lt;/sup&gt;&lt;/a&gt;. Each element consists of a code character (see &lt;a href=&quot;interactive-codes#Interactive-Codes&quot;&gt;Interactive Codes&lt;/a&gt;) optionally followed by a prompt (which some code characters use and some ignore). Here is an example:</target>
        </trans-unit>
        <trans-unit id="270207470e73c1b4f20ceeca5a4e07a1e861134d" translate="yes" xml:space="preserve">
          <source>It may be easier to understand Edebug specifications by studying the examples provided here.</source>
          <target state="translated">ここで紹介した例を勉強しておくと、Edebugの仕様を理解しやすくなるかもしれません。</target>
        </trans-unit>
        <trans-unit id="29ae132e6f7b39d1f5c10685d3a9d808a04b0a94" translate="yes" xml:space="preserve">
          <source>It may be omitted or &lt;code&gt;nil&lt;/code&gt;; then the command is called with no arguments. This leads quickly to an error if the command requires one or more arguments.</source>
          <target state="translated">It may be omitted or &lt;code&gt;nil&lt;/code&gt; ; then the command is called with no arguments. This leads quickly to an error if the command requires one or more arguments.</target>
        </trans-unit>
        <trans-unit id="a7ae8f4f5163ffdad3ac600dbfe8890ee50679f5" translate="yes" xml:space="preserve">
          <source>It might be illustrative to look at the list of action functions &lt;code&gt;display-buffer&lt;/code&gt; would have tried to display</source>
          <target state="translated">It might be illustrative to look at the list of action functions &lt;code&gt;display-buffer&lt;/code&gt; would have tried to display</target>
        </trans-unit>
        <trans-unit id="f613bf2f4a5a85329f026a11071df7c6baaf0a91" translate="yes" xml:space="preserve">
          <source>It now exits if the option &lt;code&gt;--batch&lt;/code&gt; was specified.</source>
          <target state="translated">It now exits if the option &lt;code&gt;--batch&lt;/code&gt; was specified.</target>
        </trans-unit>
        <trans-unit id="b223a189ae751119c33b80a020770286ea64a0a6" translate="yes" xml:space="preserve">
          <source>It processes any command-line options that were not handled earlier.</source>
          <target state="translated">以前に処理されなかったコマンドラインオプションを処理します。</target>
        </trans-unit>
        <trans-unit id="f719eab01b127d2177bbaf5f862883e5485e8eae" translate="yes" xml:space="preserve">
          <source>It returns &lt;code&gt;nil&lt;/code&gt; if the frame is known not to be focused, &lt;code&gt;t&lt;/code&gt; if the frame is known to be focused, or &lt;code&gt;unknown&lt;/code&gt; if Emacs does not know the focus state of the frame. (You may see this last state in TTY frames running on terminals that do not support explicit focus notifications.)</source>
          <target state="translated">It returns &lt;code&gt;nil&lt;/code&gt; if the frame is known not to be focused, &lt;code&gt;t&lt;/code&gt; if the frame is known to be focused, or &lt;code&gt;unknown&lt;/code&gt; if Emacs does not know the focus state of the frame. (You may see this last state in TTY frames running on terminals that do not support explicit focus notifications.)</target>
        </trans-unit>
        <trans-unit id="f6127be12a81ec3143b75ff723db16b07ec57fc0" translate="yes" xml:space="preserve">
          <source>It returns a list &lt;code&gt;(&lt;var&gt;id&lt;/var&gt; &lt;var&gt;cols&lt;/var&gt;)&lt;/code&gt;, where &lt;var&gt;id&lt;/var&gt; is the ID of the deleted entry and &lt;var&gt;cols&lt;/var&gt; is a vector of its column descriptors. It moves point to the beginning of the current line. It returns &lt;code&gt;nil&lt;/code&gt; if there is no entry at point.</source>
          <target state="translated">It returns a list &lt;code&gt;(&lt;var&gt;id&lt;/var&gt; &lt;var&gt;cols&lt;/var&gt;)&lt;/code&gt; , where &lt;var&gt;id&lt;/var&gt; is the ID of the deleted entry and &lt;var&gt;cols&lt;/var&gt; is a vector of its column descriptors. It moves point to the beginning of the current line. It returns &lt;code&gt;nil&lt;/code&gt; if there is no entry at point.</target>
        </trans-unit>
        <trans-unit id="13687604dddd27521e079b6548d3c35983b18d78" translate="yes" xml:space="preserve">
          <source>It runs &lt;code&gt;emacs-startup-hook&lt;/code&gt;.</source>
          <target state="translated">It runs &lt;code&gt;emacs-startup-hook&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="57d130dea79514478748a7450914f1fdf423cfbf" translate="yes" xml:space="preserve">
          <source>It runs &lt;code&gt;window-setup-hook&lt;/code&gt;. The only difference between this hook and &lt;code&gt;emacs-startup-hook&lt;/code&gt; is that this one runs after the previously mentioned modifications to the frame parameters.</source>
          <target state="translated">It runs &lt;code&gt;window-setup-hook&lt;/code&gt; . The only difference between this hook and &lt;code&gt;emacs-startup-hook&lt;/code&gt; is that this one runs after the previously mentioned modifications to the frame parameters.</target>
        </trans-unit>
        <trans-unit id="b4284000b9f4273ed298f7b9c6acbae8ad8a70fd" translate="yes" xml:space="preserve">
          <source>It runs the normal hook &lt;code&gt;after-init-hook&lt;/code&gt;.</source>
          <target state="translated">It runs the normal hook &lt;code&gt;after-init-hook&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="65ed86a0349bcbc41775fe86552a371004ac385f" translate="yes" xml:space="preserve">
          <source>It runs the normal hook &lt;code&gt;before-init-hook&lt;/code&gt;.</source>
          <target state="translated">It runs the normal hook &lt;code&gt;before-init-hook&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a06c9ffa5dcf00d29d69c9797dd7e0da6832d589" translate="yes" xml:space="preserve">
          <source>It sets the language environment and the terminal coding system, if requested by environment variables such as &lt;code&gt;LANG&lt;/code&gt;.</source>
          <target state="translated">It sets the language environment and the terminal coding system, if requested by environment variables such as &lt;code&gt;LANG&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4923a2b121bc6bb59693b11c6a7750a08e3930eb" translate="yes" xml:space="preserve">
          <source>It sets the variable &lt;code&gt;after-init-time&lt;/code&gt; to the value of &lt;code&gt;current-time&lt;/code&gt;. This variable was set to &lt;code&gt;nil&lt;/code&gt; earlier; setting it to the current time signals that the initialization phase is over, and, together with &lt;code&gt;before-init-time&lt;/code&gt;, provides the measurement of how long it took.</source>
          <target state="translated">It sets the variable &lt;code&gt;after-init-time&lt;/code&gt; to the value of &lt;code&gt;current-time&lt;/code&gt; . This variable was set to &lt;code&gt;nil&lt;/code&gt; earlier; setting it to the current time signals that the initialization phase is over, and, together with &lt;code&gt;before-init-time&lt;/code&gt; , provides the measurement of how long it took.</target>
        </trans-unit>
        <trans-unit id="5daee93c148acf992b6fea81eb74da11887f6178" translate="yes" xml:space="preserve">
          <source>It sets the variable &lt;code&gt;before-init-time&lt;/code&gt; to the value of &lt;code&gt;current-time&lt;/code&gt; (see &lt;a href=&quot;time-of-day#Time-of-Day&quot;&gt;Time of Day&lt;/a&gt;). It also sets &lt;code&gt;after-init-time&lt;/code&gt; to &lt;code&gt;nil&lt;/code&gt;, which signals to Lisp programs that Emacs is being initialized.</source>
          <target state="translated">It sets the variable &lt;code&gt;before-init-time&lt;/code&gt; to the value of &lt;code&gt;current-time&lt;/code&gt; (see &lt;a href=&quot;time-of-day#Time-of-Day&quot;&gt;Time of Day&lt;/a&gt;). It also sets &lt;code&gt;after-init-time&lt;/code&gt; to &lt;code&gt;nil&lt;/code&gt; , which signals to Lisp programs that Emacs is being initialized.</target>
        </trans-unit>
        <trans-unit id="5e3e48641edd97a87cf2a4c0fb33b8851ec59b76" translate="yes" xml:space="preserve">
          <source>It should return either a number, which is the number of columns of indentation for that line, or a list whose car is such a number. The difference between returning a number and returning a list is that a number says that all following lines at the same nesting level should be indented just like this one; a list says that following lines might call for different indentations. This makes a difference when the indentation is being computed by</source>
          <target state="translated">これは、その行のインデントの列数である数値を返すか、その車がそのような数値であるリストを返すべきです。数値を返す場合とリストを返す場合の違いは、数値は同じネスティングレベルの後続の行はすべてこの行のようにインデントされるべきだということです。これは、インデントが</target>
        </trans-unit>
        <trans-unit id="99280a67fd3ac6e66ec565182a43a4b5d4ec95df" translate="yes" xml:space="preserve">
          <source>It specifies the numbers of pixels to be left free on the left, above, the right, and below a frame that shall be fit. The default specifies &lt;code&gt;nil&lt;/code&gt; for each which means to use no margins. The value specified here can be overridden for a specific frame by that frame&amp;rsquo;s &lt;code&gt;fit-frame-to-buffer-margins&lt;/code&gt; parameter, if present.</source>
          <target state="translated">It specifies the numbers of pixels to be left free on the left, above, the right, and below a frame that shall be fit. The default specifies &lt;code&gt;nil&lt;/code&gt; for each which means to use no margins. The value specified here can be overridden for a specific frame by that frame&amp;rsquo;s &lt;code&gt;fit-frame-to-buffer-margins&lt;/code&gt; parameter, if present.</target>
        </trans-unit>
        <trans-unit id="28ce94806e6158d5cc7c2d469c858c1b7c53e2dd" translate="yes" xml:space="preserve">
          <source>It takes a candidate for the fill prefix from the first line&amp;mdash;it tries first the function in &lt;code&gt;adaptive-fill-function&lt;/code&gt; (if any), then the regular expression &lt;code&gt;adaptive-fill-regexp&lt;/code&gt; (see below). The first non-&lt;code&gt;nil&lt;/code&gt; result of these, or the empty string if they&amp;rsquo;re both &lt;code&gt;nil&lt;/code&gt;, becomes the first line&amp;rsquo;s candidate.</source>
          <target state="translated">It takes a candidate for the fill prefix from the first line&amp;mdash;it tries first the function in &lt;code&gt;adaptive-fill-function&lt;/code&gt; (if any), then the regular expression &lt;code&gt;adaptive-fill-regexp&lt;/code&gt; (see below). The first non- &lt;code&gt;nil&lt;/code&gt; result of these, or the empty string if they&amp;rsquo;re both &lt;code&gt;nil&lt;/code&gt; , becomes the first line&amp;rsquo;s candidate.</target>
        </trans-unit>
        <trans-unit id="f89e2f8e456314ee623854cef9dd8ebd8d7735d3" translate="yes" xml:space="preserve">
          <source>It use &lt;code&gt;custom-reevaluate-setting&lt;/code&gt; to re-initialize the members of the list &lt;code&gt;custom-delayed-init-variables&lt;/code&gt;. These are any pre-loaded user options whose default value depends on the run-time, rather than build-time, context. See &lt;a href=&quot;building-emacs#Building-Emacs&quot;&gt;custom-initialize-delay&lt;/a&gt;.</source>
          <target state="translated">It use &lt;code&gt;custom-reevaluate-setting&lt;/code&gt; to re-initialize the members of the list &lt;code&gt;custom-delayed-init-variables&lt;/code&gt; . These are any pre-loaded user options whose default value depends on the run-time, rather than build-time, context. See &lt;a href=&quot;building-emacs#Building-Emacs&quot;&gt;custom-initialize-delay&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="44cd2108881f01dd8c596bbd91d07233b73cb9b2" translate="yes" xml:space="preserve">
          <source>It works to put a &lt;code&gt;lambda&lt;/code&gt;-expression function on a hook, but we recommend avoiding this because it can lead to confusion. If you add the same &lt;code&gt;lambda&lt;/code&gt;-expression a second time but write it slightly differently, you will get two equivalent but distinct functions on the hook. If you then remove one of them, the other will still be on it.</source>
          <target state="translated">It works to put a &lt;code&gt;lambda&lt;/code&gt; -expression function on a hook, but we recommend avoiding this because it can lead to confusion. If you add the same &lt;code&gt;lambda&lt;/code&gt; -expression a second time but write it slightly differently, you will get two equivalent but distinct functions on the hook. If you then remove one of them, the other will still be on it.</target>
        </trans-unit>
        <trans-unit id="80fdf17dcc7b4f396ac917a2a9e0157cd87886a5" translate="yes" xml:space="preserve">
          <source>It you wish to use &lt;code&gt;fset&lt;/code&gt; to make an alternate name for a function, consider using &lt;code&gt;defalias&lt;/code&gt; instead. See &lt;a href=&quot;defining-functions#Definition-of-defalias&quot;&gt;Definition of defalias&lt;/a&gt;.</source>
          <target state="translated">It you wish to use &lt;code&gt;fset&lt;/code&gt; to make an alternate name for a function, consider using &lt;code&gt;defalias&lt;/code&gt; instead. See &lt;a href=&quot;defining-functions#Definition-of-defalias&quot;&gt;Definition of defalias&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="12c3787085fed9c7ac2a19edc5f190b93b7fcd00" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s important to note that generator function bodies only execute inside calls to &lt;code&gt;iter-next&lt;/code&gt;. A call to a function defined with &lt;code&gt;iter-defun&lt;/code&gt; produces an iterator; you must drive this iterator with &lt;code&gt;iter-next&lt;/code&gt; for anything interesting to happen. Each call to a generator function produces a &lt;em&gt;different&lt;/em&gt; iterator, each with its own state.</source>
          <target state="translated">It&amp;rsquo;s important to note that generator function bodies only execute inside calls to &lt;code&gt;iter-next&lt;/code&gt; . A call to a function defined with &lt;code&gt;iter-defun&lt;/code&gt; produces an iterator; you must drive this iterator with &lt;code&gt;iter-next&lt;/code&gt; for anything interesting to happen. Each call to a generator function produces a &lt;em&gt;different&lt;/em&gt; iterator, each with its own state.</target>
        </trans-unit>
        <trans-unit id="729165fc7a05eb589cbb1af78d5106f307b47f0e" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s often best to use a button-down event to trigger the menu. Then the user can select a menu item by releasing the button.</source>
          <target state="translated">It&amp;rsquo;s often best to use a button-down event to trigger the menu. Then the user can select a menu item by releasing the button.</target>
        </trans-unit>
        <trans-unit id="0c08d58a77f22a792633779a50d013f737ce9483" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s possible to use &lt;code&gt;defmacro&lt;/code&gt; to define a macro to expand into the same code that an inline function would execute (see &lt;a href=&quot;macros#Macros&quot;&gt;Macros&lt;/a&gt;). But the macro would be limited to direct use in expressions&amp;mdash;a macro cannot be called with &lt;code&gt;apply&lt;/code&gt;, &lt;code&gt;mapcar&lt;/code&gt; and so on. Also, it takes some work to convert an ordinary function into a macro. To convert it into an inline function is easy; just replace &lt;code&gt;defun&lt;/code&gt; with &lt;code&gt;defsubst&lt;/code&gt;. Since each argument of an inline function is evaluated exactly once, you needn&amp;rsquo;t worry about how many times the body uses the arguments, as you do for macros.</source>
          <target state="translated">It&amp;rsquo;s possible to use &lt;code&gt;defmacro&lt;/code&gt; to define a macro to expand into the same code that an inline function would execute (see &lt;a href=&quot;macros#Macros&quot;&gt;Macros&lt;/a&gt;). But the macro would be limited to direct use in expressions&amp;mdash;a macro cannot be called with &lt;code&gt;apply&lt;/code&gt; , &lt;code&gt;mapcar&lt;/code&gt; and so on. Also, it takes some work to convert an ordinary function into a macro. To convert it into an inline function is easy; just replace &lt;code&gt;defun&lt;/code&gt; with &lt;code&gt;defsubst&lt;/code&gt; . Since each argument of an inline function is evaluated exactly once, you needn&amp;rsquo;t worry about how many times the body uses the arguments, as you do for macros.</target>
        </trans-unit>
        <trans-unit id="18905aab409cadb5b72681a650ec99001cb221e0" translate="yes" xml:space="preserve">
          <source>Iteration</source>
          <target state="translated">Iteration</target>
        </trans-unit>
        <trans-unit id="f4d74e5132bdad11a69b68ebde992bf491707cbc" translate="yes" xml:space="preserve">
          <source>Iteration means executing part of a program repetitively. For example, you might want to repeat some computation once for each element of a list, or once for each integer from 0 to &lt;var&gt;n&lt;/var&gt;. You can do this in Emacs Lisp with the special form &lt;code&gt;while&lt;/code&gt;:</source>
          <target state="translated">Iteration means executing part of a program repetitively. For example, you might want to repeat some computation once for each element of a list, or once for each integer from 0 to &lt;var&gt;n&lt;/var&gt; . You can do this in Emacs Lisp with the special form &lt;code&gt;while&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="2fb2f2a0c2e32e4191a12be240b63fedbe73b154" translate="yes" xml:space="preserve">
          <source>Its default value is a list of two functions:</source>
          <target state="translated">デフォルト値は2つの関数のリストです。</target>
        </trans-unit>
        <trans-unit id="49589a66a4ed1e537405d93b509f6624692ac859" translate="yes" xml:space="preserve">
          <source>Its limitations are two-fold:</source>
          <target state="translated">その限界は2つあります。</target>
        </trans-unit>
        <trans-unit id="007b93ab24ba9d1da7373772173fe2a52b7889ac" translate="yes" xml:space="preserve">
          <source>Its value is a cons cell whose &lt;small&gt;CAR&lt;/small&gt; is the property value, the same value &lt;code&gt;get-char-property&lt;/code&gt; would return with the same arguments. Its &lt;small&gt;CDR&lt;/small&gt; is the overlay in which the property was found, or &lt;code&gt;nil&lt;/code&gt;, if it was found as a text property or not found at all.</source>
          <target state="translated">Its value is a cons cell whose &lt;small&gt;CAR&lt;/small&gt; is the property value, the same value &lt;code&gt;get-char-property&lt;/code&gt; would return with the same arguments. Its &lt;small&gt;CDR&lt;/small&gt; is the overlay in which the property was found, or &lt;code&gt;nil&lt;/code&gt; , if it was found as a text property or not found at all.</target>
        </trans-unit>
        <trans-unit id="6b878b75e01a9b65a11b6b767fc6064f2ed8e1c3" translate="yes" xml:space="preserve">
          <source>Its value should be an alist of elements &lt;code&gt;(&lt;var&gt;group&lt;/var&gt;
. &lt;var&gt;method&lt;/var&gt;)&lt;/code&gt;, where &lt;var&gt;group&lt;/var&gt; is a symbol specifying a group of characters, and &lt;var&gt;method&lt;/var&gt; is a symbol specifying how to display them.</source>
          <target state="translated">Its value should be an alist of elements &lt;code&gt;(&lt;var&gt;group&lt;/var&gt; . &lt;var&gt;method&lt;/var&gt;)&lt;/code&gt; , where &lt;var&gt;group&lt;/var&gt; is a symbol specifying a group of characters, and &lt;var&gt;method&lt;/var&gt; is a symbol specifying how to display them.</target>
        </trans-unit>
        <trans-unit id="a45885aac538290762a4f7f3317abf411bb16059" translate="yes" xml:space="preserve">
          <source>JPEG</source>
          <target state="translated">JPEG</target>
        </trans-unit>
        <trans-unit id="031a4e76f0b39d0df073d934da5fc48da8d737e5" translate="yes" xml:space="preserve">
          <source>JSON</source>
          <target state="translated">JSON</target>
        </trans-unit>
        <trans-unit id="6f0b2b618684c092a8066c4d2b87cf92b25d0ab7" translate="yes" xml:space="preserve">
          <source>JSON Remote Procedure Call protocol</source>
          <target state="translated">JSONリモートプロシージャコールプロトコル</target>
        </trans-unit>
        <trans-unit id="5f40c53af62eb7b5ee0a65ed1e7c8f365f43b1f1" translate="yes" xml:space="preserve">
          <source>JSON has only one map type, the object. JSON objects are represented using Lisp hashtables, alists or plists. When an alist or plist contains several elements with the same key, Emacs uses only the first element for serialization, in accordance with the behavior of &lt;code&gt;assq&lt;/code&gt;.</source>
          <target state="translated">JSON has only one map type, the object. JSON objects are represented using Lisp hashtables, alists or plists. When an alist or plist contains several elements with the same key, Emacs uses only the first element for serialization, in accordance with the behavior of &lt;code&gt;assq&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4027009299142689327089033c66ce6d8204c015" translate="yes" xml:space="preserve">
          <source>JSON has only one sequence type, the array. JSON arrays are represented using Lisp vectors.</source>
          <target state="translated">JSONには配列という1つのシーケンス型しかありません。JSON の配列は Lisp ベクトルを使って表現されます。</target>
        </trans-unit>
        <trans-unit id="89330272dcad769514c364e424832f313f1167c0" translate="yes" xml:space="preserve">
          <source>JSON only has floating-point numbers. They can represent both Lisp integers and Lisp floating-point numbers.</source>
          <target state="translated">JSONには浮動小数点数しかありません。これらはLispの整数とLispの浮動小数点数の両方を表現することができます。</target>
        </trans-unit>
        <trans-unit id="18c0817b7de8ce2fe86bde8704950b2eeeb0640d" translate="yes" xml:space="preserve">
          <source>JSON strings are always Unicode strings encoded in UTF-8. Lisp strings can contain non-Unicode characters.</source>
          <target state="translated">JSON文字列は常にUTF-8でエンコードされたUnicode文字列です。Lisp文字列は非Unicode文字を含むことができます。</target>
        </trans-unit>
        <trans-unit id="604769fe0494c1a23dd3dbf7fcb493bb82074409" translate="yes" xml:space="preserve">
          <source>JSON uses three keywords: &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;null&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt;. &lt;code&gt;true&lt;/code&gt; is represented by the symbol &lt;code&gt;t&lt;/code&gt;. By default, the remaining two are represented, respectively, by the symbols &lt;code&gt;:null&lt;/code&gt; and &lt;code&gt;:false&lt;/code&gt;.</source>
          <target state="translated">JSON uses three keywords: &lt;code&gt;true&lt;/code&gt; , &lt;code&gt;null&lt;/code&gt; , &lt;code&gt;false&lt;/code&gt; . &lt;code&gt;true&lt;/code&gt; is represented by the symbol &lt;code&gt;t&lt;/code&gt; . By default, the remaining two are represented, respectively, by the symbols &lt;code&gt;:null&lt;/code&gt; and &lt;code&gt;:false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ffacdf205c7b613f126d350a3416adc2ea7f7d90" translate="yes" xml:space="preserve">
          <source>JSONRPC</source>
          <target state="translated">JSONRPC</target>
        </trans-unit>
        <trans-unit id="023904df01b91caca2efa0a6f39bbded6afa2411" translate="yes" xml:space="preserve">
          <source>JSONRPC JSON object format</source>
          <target state="translated">JSONRPC JSONオブジェクト形式</target>
        </trans-unit>
        <trans-unit id="8cb256262920f81ff7c10fc10bd2e49e81c8137a" translate="yes" xml:space="preserve">
          <source>JSONRPC JSON objects are exchanged as Lisp plists (see &lt;a href=&quot;property-lists#Property-Lists&quot;&gt;Property Lists&lt;/a&gt;): JSON-compatible plists are handed to the dispatcher functions and, likewise, JSON-compatible plists should be given to &lt;code&gt;jsonrpc-notify&lt;/code&gt;, &lt;code&gt;jsonrpc-request&lt;/code&gt;, and &lt;code&gt;jsonrpc-async-request&lt;/code&gt;.</source>
          <target state="translated">JSONRPC JSON objects are exchanged as Lisp plists (see &lt;a href=&quot;property-lists#Property-Lists&quot;&gt;Property Lists&lt;/a&gt;): JSON-compatible plists are handed to the dispatcher functions and, likewise, JSON-compatible plists should be given to &lt;code&gt;jsonrpc-notify&lt;/code&gt; , &lt;code&gt;jsonrpc-request&lt;/code&gt; , and &lt;code&gt;jsonrpc-async-request&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a9068fb4f18e456442cb8e3b2ddc33c5d4e5641e" translate="yes" xml:space="preserve">
          <source>JSONRPC communication</source>
          <target state="translated">JSONRPC通信</target>
        </trans-unit>
        <trans-unit id="bb9246b17bfdff9790f8c3e72422d7b7db8ccff0" translate="yes" xml:space="preserve">
          <source>Jumping</source>
          <target state="translated">Jumping</target>
        </trans-unit>
        <trans-unit id="a20aab26c7084f09b487ca4a8ecb0f67c7f41eca" translate="yes" xml:space="preserve">
          <source>Jumping out of a sequence.</source>
          <target state="translated">順番に飛び出していく。</target>
        </trans-unit>
        <trans-unit id="2d4e7474c74be192828a058c6fbfa5e4ed48ebd6" translate="yes" xml:space="preserve">
          <source>Just like &lt;code&gt;input-decode-map&lt;/code&gt;, but unlike &lt;code&gt;local-function-key-map&lt;/code&gt;, this keymap is applied regardless of whether the input key-sequence has a normal binding. Note however that actual key bindings can have an effect on &lt;code&gt;key-translation-map&lt;/code&gt;, even though they are overridden by it. Indeed, actual key bindings override &lt;code&gt;local-function-key-map&lt;/code&gt; and thus may alter the key sequence that &lt;code&gt;key-translation-map&lt;/code&gt; receives. Clearly, it is better to avoid this type of situation.</source>
          <target state="translated">Just like &lt;code&gt;input-decode-map&lt;/code&gt; , but unlike &lt;code&gt;local-function-key-map&lt;/code&gt; , this keymap is applied regardless of whether the input key-sequence has a normal binding. Note however that actual key bindings can have an effect on &lt;code&gt;key-translation-map&lt;/code&gt; , even though they are overridden by it. Indeed, actual key bindings override &lt;code&gt;local-function-key-map&lt;/code&gt; and thus may alter the key sequence that &lt;code&gt;key-translation-map&lt;/code&gt; receives. Clearly, it is better to avoid this type of situation.</target>
        </trans-unit>
        <trans-unit id="77d80675faa0379a05b630d16d127cfd2e69de8d" translate="yes" xml:space="preserve">
          <source>Just moving the mouse, not pushing a button.</source>
          <target state="translated">ボタンを押すのではなく、マウスを動かすだけ。</target>
        </trans-unit>
        <trans-unit id="17d7aa6336e0d7068a94ced38ef5d747f79474ef" translate="yes" xml:space="preserve">
          <source>Just what parameters a frame has depends on what display mechanism it uses. This section describes the parameters that have special meanings on some or all kinds of terminals. Of these, &lt;code&gt;name&lt;/code&gt;, &lt;code&gt;title&lt;/code&gt;, &lt;code&gt;height&lt;/code&gt;, &lt;code&gt;width&lt;/code&gt;, &lt;code&gt;buffer-list&lt;/code&gt; and &lt;code&gt;buffer-predicate&lt;/code&gt; provide meaningful information in terminal frames, and &lt;code&gt;tty-color-mode&lt;/code&gt; is meaningful only for frames on text terminals.</source>
          <target state="translated">Just what parameters a frame has depends on what display mechanism it uses. This section describes the parameters that have special meanings on some or all kinds of terminals. Of these, &lt;code&gt;name&lt;/code&gt; , &lt;code&gt;title&lt;/code&gt; , &lt;code&gt;height&lt;/code&gt; , &lt;code&gt;width&lt;/code&gt; , &lt;code&gt;buffer-list&lt;/code&gt; and &lt;code&gt;buffer-predicate&lt;/code&gt; provide meaningful information in terminal frames, and &lt;code&gt;tty-color-mode&lt;/code&gt; is meaningful only for frames on text terminals.</target>
        </trans-unit>
        <trans-unit id="a7ee38bb7be4fc44198cb2685d9601dcf2b9f569" translate="yes" xml:space="preserve">
          <source>K</source>
          <target state="translated">K</target>
        </trans-unit>
        <trans-unit id="b4003201894d55fb52e96919b5492ae84d3e20c6" translate="yes" xml:space="preserve">
          <source>Keep the standard output stream separate from the standard error stream; deal with the ordinary output as specified by &lt;var&gt;real-destination&lt;/var&gt;, and dispose of the error output according to &lt;var&gt;error-destination&lt;/var&gt;. If &lt;var&gt;error-destination&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, that means to discard the error output, &lt;code&gt;t&lt;/code&gt; means mix it with the ordinary output, and a string specifies a file name to redirect error output into.</source>
          <target state="translated">Keep the standard output stream separate from the standard error stream; deal with the ordinary output as specified by &lt;var&gt;real-destination&lt;/var&gt; , and dispose of the error output according to &lt;var&gt;error-destination&lt;/var&gt; . If &lt;var&gt;error-destination&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt; , that means to discard the error output, &lt;code&gt;t&lt;/code&gt; means mix it with the ordinary output, and a string specifies a file name to redirect error output into.</target>
        </trans-unit>
        <trans-unit id="2313f6a862f0a5a7b23c0ccfb3f009b7d62043d3" translate="yes" xml:space="preserve">
          <source>Keeping multiple backups for each source file.</source>
          <target state="translated">ソースファイルごとに複数のバックアップを保持します。</target>
        </trans-unit>
        <trans-unit id="8d474fa62c5cf5a6da4cbae82ab10a2815da666e" translate="yes" xml:space="preserve">
          <source>Key Lookup</source>
          <target state="translated">キールックアップ</target>
        </trans-unit>
        <trans-unit id="cb77a254d48a5f705e632277b08072b03c096a05" translate="yes" xml:space="preserve">
          <source>Key Sequence Input</source>
          <target state="translated">キーシーケンス入力</target>
        </trans-unit>
        <trans-unit id="7a7b2425d6daf70b349c0a7d7d7ea874344f67e9" translate="yes" xml:space="preserve">
          <source>Key Sequences</source>
          <target state="translated">キーシーケンス</target>
        </trans-unit>
        <trans-unit id="0b515ab1a9fb6a3fcee02f1f50e5a2f26e18e821" translate="yes" xml:space="preserve">
          <source>Key lookup uses just the event type of each event in the key sequence; the rest of the event is ignored. In fact, a key sequence used for key lookup may designate a mouse event with just its types (a symbol) instead of the entire event (a list). See &lt;a href=&quot;input-events#Input-Events&quot;&gt;Input Events&lt;/a&gt;. Such a key sequence is insufficient for &lt;code&gt;command-execute&lt;/code&gt; to run, but it is sufficient for looking up or rebinding a key.</source>
          <target state="translated">Key lookup uses just the event type of each event in the key sequence; the rest of the event is ignored. In fact, a key sequence used for key lookup may designate a mouse event with just its types (a symbol) instead of the entire event (a list). See &lt;a href=&quot;input-events#Input-Events&quot;&gt;Input Events&lt;/a&gt;. Such a key sequence is insufficient for &lt;code&gt;command-execute&lt;/code&gt; to run, but it is sufficient for looking up or rebinding a key.</target>
        </trans-unit>
        <trans-unit id="00ac667fea005ecd115f4ed149f2f13d0cf004c7" translate="yes" xml:space="preserve">
          <source>Key sequences as Lisp objects.</source>
          <target state="translated">Lispオブジェクトとしてのキーシーケンス。</target>
        </trans-unit>
        <trans-unit id="e6f5765563fe2bf147f6daa60b670109e680de3f" translate="yes" xml:space="preserve">
          <source>Key sequences containing function keys, mouse button events, system events, or non-</source>
          <target state="translated">ファンクションキー、マウスボタンイベント、システムイベント、または非</target>
        </trans-unit>
        <trans-unit id="3961da9502b1e99387aff089f5c83ca94c5c588d" translate="yes" xml:space="preserve">
          <source>Keyboard Events</source>
          <target state="translated">キーボードイベント</target>
        </trans-unit>
        <trans-unit id="cc4837611e356bedd08fd92c8bd27ef9a22790ca" translate="yes" xml:space="preserve">
          <source>Keyboard Macros</source>
          <target state="translated">キーボードマクロ</target>
        </trans-unit>
        <trans-unit id="8b6bd7b83a0711a97c1d29c9f645fc934a4cbc3d" translate="yes" xml:space="preserve">
          <source>Keyboard macros (strings and vectors) are commands also, even though they are not functions. See &lt;a href=&quot;keyboard-macros#Keyboard-Macros&quot;&gt;Keyboard Macros&lt;/a&gt;. We say that a symbol is a command if its function cell contains a command (see &lt;a href=&quot;symbol-components#Symbol-Components&quot;&gt;Symbol Components&lt;/a&gt;); such a &lt;em&gt;named command&lt;/em&gt; can be invoked with</source>
          <target state="translated">Keyboard macros (strings and vectors) are commands also, even though they are not functions. See &lt;a href=&quot;keyboard-macros#Keyboard-Macros&quot;&gt;Keyboard Macros&lt;/a&gt;. We say that a symbol is a command if its function cell contains a command (see &lt;a href=&quot;symbol-components#Symbol-Components&quot;&gt;Symbol Components&lt;/a&gt;); such a &lt;em&gt;named command&lt;/em&gt; can be invoked with</target>
        </trans-unit>
        <trans-unit id="57d8ce809f6aac6dc1bf827bb30233a06fa72cbe" translate="yes" xml:space="preserve">
          <source>Keyboard macros containing the commands in this section do not completely work: exiting from Edebug, to resume the program, loses track of the keyboard macro. This is not easy to fix. Also, defining or executing a keyboard macro outside of Edebug does not affect commands inside Edebug. This is usually an advantage. See also the &lt;code&gt;edebug-continue-kbd-macro&lt;/code&gt; option in &lt;a href=&quot;edebug-options#Edebug-Options&quot;&gt;Edebug Options&lt;/a&gt;.</source>
          <target state="translated">Keyboard macros containing the commands in this section do not completely work: exiting from Edebug, to resume the program, loses track of the keyboard macro. This is not easy to fix. Also, defining or executing a keyboard macro outside of Edebug does not affect commands inside Edebug. This is usually an advantage. See also the &lt;code&gt;edebug-continue-kbd-macro&lt;/code&gt; option in &lt;a href=&quot;edebug-options#Edebug-Options&quot;&gt;Edebug Options&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="e3894811d2bb2e8a0e70a43023f6e533fc04aa5f" translate="yes" xml:space="preserve">
          <source>Keymap Basics</source>
          <target state="translated">キーマップの基本</target>
        </trans-unit>
        <trans-unit id="7e1e2cf42b1a47ad6de7151c248a098ee3773208" translate="yes" xml:space="preserve">
          <source>Keymap Type</source>
          <target state="translated">キーマップの種類</target>
        </trans-unit>
        <trans-unit id="d76a6428ca9ac90ba70592739416e9b19c454e19" translate="yes" xml:space="preserve">
          <source>Keymaps</source>
          <target state="translated">Keymaps</target>
        </trans-unit>
        <trans-unit id="68c5dc6cf88794930ca2d061c030b64676e40cee" translate="yes" xml:space="preserve">
          <source>Keymaps and Minor Modes</source>
          <target state="translated">キーマップとマイナーモード</target>
        </trans-unit>
        <trans-unit id="3093db83b00c2f7e5b19934739a3fc63828ae6d8" translate="yes" xml:space="preserve">
          <source>Keymaps do not directly record bindings for the meta characters. Instead, meta characters are regarded for purposes of key lookup as sequences of two characters, the first of which is</source>
          <target state="translated">キーマップはメタ文字へのバインディングを直接記録しない。代わりに、メタ文字はキー検索の目的では、2つの文字のシーケンスとみなされます。</target>
        </trans-unit>
        <trans-unit id="3117df544bce8c92b99c739e69838cf2a9859a28" translate="yes" xml:space="preserve">
          <source>Keymaps for Translating Sequences of Events</source>
          <target state="translated">イベントのシーケンスを変換するためのキーマップ</target>
        </trans-unit>
        <trans-unit id="89b194f61c3768b6f1d5626d1fe4d243fd85ddb1" translate="yes" xml:space="preserve">
          <source>Keymaps for translating sequences of events.</source>
          <target state="translated">イベントのシーケンスを変換するためのキーマップ。</target>
        </trans-unit>
        <trans-unit id="fe40ad8ac52f1e3452189e07dae6c5efcaaf2ae3" translate="yes" xml:space="preserve">
          <source>Keypad PF keys.</source>
          <target state="translated">キーパッドのPFキー。</target>
        </trans-unit>
        <trans-unit id="7ff53782c834404cf3524a8597174b2cf0076736" translate="yes" xml:space="preserve">
          <source>Keypad arrow keys. Emacs normally translates these into the corresponding non-keypad keys &lt;code&gt;home&lt;/code&gt;, &lt;code&gt;left&lt;/code&gt;, &amp;hellip;</source>
          <target state="translated">Keypad arrow keys. Emacs normally translates these into the corresponding non-keypad keys &lt;code&gt;home&lt;/code&gt; , &lt;code&gt;left&lt;/code&gt; , &amp;hellip;</target>
        </trans-unit>
        <trans-unit id="b5eb0d39876e431709d140c2c21d82c8238a6c99" translate="yes" xml:space="preserve">
          <source>Keypad keys (to the right of the regular keyboard).</source>
          <target state="translated">キーパッドキー(通常のキーボードの右側)。</target>
        </trans-unit>
        <trans-unit id="eef968747a417ebd5b41ada36d96e9a593e3dde7" translate="yes" xml:space="preserve">
          <source>Keypad keys with digits.</source>
          <target state="translated">キーパッドのキーには数字が入っています。</target>
        </trans-unit>
        <trans-unit id="dd3107ada3563f5762a1c77c6d042feef96965e8" translate="yes" xml:space="preserve">
          <source>Keys which are numbers are the same if they are &lt;code&gt;equal&lt;/code&gt;, that is, if they are equal in value and either both are integers or both are floating point; otherwise, two distinct objects are never the same.</source>
          <target state="translated">Keys which are numbers are the same if they are &lt;code&gt;equal&lt;/code&gt; , that is, if they are equal in value and either both are integers or both are floating point; otherwise, two distinct objects are never the same.</target>
        </trans-unit>
        <trans-unit id="0a96287d882fd3ff1fe974dd3e8fb389c5f972f8" translate="yes" xml:space="preserve">
          <source>Keyword-argument pairs in a customization type.</source>
          <target state="translated">カスタマイズタイプのキーワード引数のペア。</target>
        </trans-unit>
        <trans-unit id="f530db58b3e5088dc7412c6d2298ba3f8456bdeb" translate="yes" xml:space="preserve">
          <source>Keywords</source>
          <target state="translated">Keywords</target>
        </trans-unit>
        <trans-unit id="99d76e74c509d75e4d702035d810e89f93c7d6d9" translate="yes" xml:space="preserve">
          <source>Kill Ring Concepts</source>
          <target state="translated">キルリングの概念</target>
        </trans-unit>
        <trans-unit id="0793494cd99ab42f2fd7a7de2f60c1b1f50d20a1" translate="yes" xml:space="preserve">
          <source>Killed text is saved for later yanking in the &lt;em&gt;kill ring&lt;/em&gt;. This is a list that holds a number of recent kills, not just the last text kill. We call this a &amp;ldquo;ring&amp;rdquo; because yanking treats it as having elements in a cyclic order. The list is kept in the variable &lt;code&gt;kill-ring&lt;/code&gt;, and can be operated on with the usual functions for lists; there are also specialized functions, described in this section, that treat it as a ring.</source>
          <target state="translated">殺されたテキストは、中、後にヤンクのために保存されて&lt;em&gt;キルリング&lt;/em&gt;。これは、最後のテキストキルだけでなく、最近のキルの数を保持するリストです。ヤンクはそれを循環順序の要素を持つものとして扱うため、これを「リング」と呼びます。リストは変数 &lt;code&gt;kill-ring&lt;/code&gt; に保持され、リストの通常の関数で操作できます。このセクションで説明する、リングとして扱う特殊な関数もあります。</target>
        </trans-unit>
        <trans-unit id="3af8708ad522d3a5f4a8a381debab1e57b5755ab" translate="yes" xml:space="preserve">
          <source>Killing Buffers</source>
          <target state="translated">キリングバッファ</target>
        </trans-unit>
        <trans-unit id="905a28f726d10a308adc3a62e9e389be2995327d" translate="yes" xml:space="preserve">
          <source>Killing Emacs</source>
          <target state="translated">Emacsを殺す</target>
        </trans-unit>
        <trans-unit id="e96de96c4cb696f64784e596daa37e7385985b37" translate="yes" xml:space="preserve">
          <source>Killing Emacs means ending the execution of the Emacs process. If you started Emacs from a terminal, the parent process normally resumes control. The low-level primitive for killing Emacs is &lt;code&gt;kill-emacs&lt;/code&gt;.</source>
          <target state="translated">Emacsを強制終了するということは、Emacsプロセスの実行を終了することを意味します。ターミナルからEmacsを起動した場合、通常、親プロセスは制御を再開します。Emacsを &lt;code&gt;kill-emacs&lt;/code&gt; ための低レベルのプリミティブはkill-emacsです。</target>
        </trans-unit>
        <trans-unit id="32c52ea2582689ab686f39c40e2513b971ea8ebe" translate="yes" xml:space="preserve">
          <source>Killing a buffer that is already dead has no effect.</source>
          <target state="translated">既に死んでいるバッファを殺しても効果はありません。</target>
        </trans-unit>
        <trans-unit id="6077b76b5702831c966267012f0fbf3e43b7d854" translate="yes" xml:space="preserve">
          <source>Killing an indirect buffer has no effect on its base buffer. Killing the base buffer effectively kills the indirect buffer in that it cannot ever again be the current buffer.</source>
          <target state="translated">間接バッファを殺してもベースバッファには何の影響もありません。ベースバッファを殺しても間接バッファは効果的に殺され、現在のバッファになることはできません。</target>
        </trans-unit>
        <trans-unit id="6e673387e3bdf070063073a3f9e5be789f453c2e" translate="yes" xml:space="preserve">
          <source>Killing the associated buffer of a process also kills the process. Emacs asks for confirmation first, if the process&amp;rsquo;s &lt;code&gt;process-query-on-exit-flag&lt;/code&gt; is non-&lt;code&gt;nil&lt;/code&gt; (see &lt;a href=&quot;query-before-exit#Query-Before-Exit&quot;&gt;Query Before Exit&lt;/a&gt;). This confirmation is done by the function &lt;code&gt;process-kill-buffer-query-function&lt;/code&gt;, which is run from &lt;code&gt;kill-buffer-query-functions&lt;/code&gt; (see &lt;a href=&quot;killing-buffers#Killing-Buffers&quot;&gt;Killing Buffers&lt;/a&gt;).</source>
          <target state="translated">プロセスの関連するバッファを強制終了すると、プロセスも強制終了されます。プロセスの &lt;code&gt;process-query-on-exit-flag&lt;/code&gt; が &lt;code&gt;nil&lt;/code&gt; でない場合、Emacsは最初に確認を求めます（&lt;a href=&quot;query-before-exit#Query-Before-Exit&quot;&gt;終了前のクエリを&lt;/a&gt;参照）。この確認は、 &lt;code&gt;process-kill-buffer-query-function&lt;/code&gt; から実行される関数process-kill-buffer-query-functionによって行われ &lt;code&gt;kill-buffer-query-functions&lt;/code&gt; （&lt;a href=&quot;killing-buffers#Killing-Buffers&quot;&gt;Killing Buffersを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="3bdff83a09d5676c78e5c2c430a0e721e8015f53" translate="yes" xml:space="preserve">
          <source>Killing the process&amp;rsquo;s buffer deletes the process, which kills the subprocess with a &lt;code&gt;SIGHUP&lt;/code&gt; signal (see &lt;a href=&quot;signals-to-processes#Signals-to-Processes&quot;&gt;Signals to Processes&lt;/a&gt;).</source>
          <target state="translated">プロセスのバッファを強制終了すると、プロセスが削除され、 &lt;code&gt;SIGHUP&lt;/code&gt; シグナルでサブプロセスが強制終了されます（「&lt;a href=&quot;signals-to-processes#Signals-to-Processes&quot;&gt;プロセスへのシグナル」を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="7f4b3ead218699344f23be9d2cfa8db0a8b21cce" translate="yes" xml:space="preserve">
          <source>Kinds of Forms</source>
          <target state="translated">フォームの種類</target>
        </trans-unit>
        <trans-unit id="64d2ffb3f2887641adb1066e515d59980846cd8f" translate="yes" xml:space="preserve">
          <source>Kludge to make preloaded Lisp functions shareable.</source>
          <target state="translated">KludgeでプリロードされたLisp関数を共有できるようにしました。</target>
        </trans-unit>
        <trans-unit id="9f99b3ffcb996071b995db44be3acebff40b85cd" translate="yes" xml:space="preserve">
          <source>Knowing the outer size of a frame is useful for fitting a frame into the working area of its display (see &lt;a href=&quot;multiple-terminals#Multiple-Terminals&quot;&gt;Multiple Terminals&lt;/a&gt;) or for placing two frames adjacent to each other on the screen. Usually, the outer size of a frame is available only after the frame has been mapped (made visible, see &lt;a href=&quot;visibility-of-frames#Visibility-of-Frames&quot;&gt;Visibility of Frames&lt;/a&gt;) at least once. For the initial frame or a frame that has not been created yet, the outer size can be only estimated or must be calculated from the window-system&amp;rsquo;s or window manager&amp;rsquo;s defaults. One workaround is to obtain the differences of the outer and native (see below) sizes of a mapped frame and use them for calculating the outer size of the new frame.</source>
          <target state="translated">フレームの外側のサイズを知ることは、フレームをそのディスプレイの作業領域に合わせる（&lt;a href=&quot;multiple-terminals#Multiple-Terminals&quot;&gt;複数の端末を&lt;/a&gt;参照）場合、または2つのフレームを画面上で互いに隣接して配置する場合に役立ちます。通常、フレームの外側のサイズは、フレームが少なくとも1回マップされた後（表示されます。&lt;a href=&quot;visibility-of-frames#Visibility-of-Frames&quot;&gt;フレームの可視性を&lt;/a&gt;参照）にのみ使用できます。初期フレームまたはまだ作成されていないフレームの場合、外側のサイズは推定のみ可能であるか、ウィンドウシステムまたはウィンドウマネージャーのデフォルトから計算する必要があります。回避策の1つは、マップされたフレームの外側のサイズとネイティブ（以下を参照）サイズの差を取得し、それらを使用して新しいフレームの外側のサイズを計算することです。</target>
        </trans-unit>
        <trans-unit id="cbd787f29ba8f2730cc87a999b5ba33499aa964b" translate="yes" xml:space="preserve">
          <source>Kochi Gothic</source>
          <target state="translated">高知ゴシック</target>
        </trans-unit>
        <trans-unit id="dbe210e5d6e8e316f7fec4291dc590c38590425d" translate="yes" xml:space="preserve">
          <source>LRM</source>
          <target state="translated">LRM</target>
        </trans-unit>
        <trans-unit id="93888d709ed769c070b132d596bc80ec625d98c7" translate="yes" xml:space="preserve">
          <source>LRO</source>
          <target state="translated">LRO</target>
        </trans-unit>
        <trans-unit id="0d6d942b0d775bd54e421837f661227031916cc3" translate="yes" xml:space="preserve">
          <source>Lambda Expressions</source>
          <target state="translated">ラムダ式</target>
        </trans-unit>
        <trans-unit id="08e9d75b80cfeb0adf69e90498297bc377db4e87" translate="yes" xml:space="preserve">
          <source>Lambda expressions are functions with no names.</source>
          <target state="translated">ラムダ式は名前のない関数です。</target>
        </trans-unit>
        <trans-unit id="91690fadbf640ee6fddae4125d1ea25d075b5bc6" translate="yes" xml:space="preserve">
          <source>Laplace edge-detection currently uses a matrix of</source>
          <target state="translated">ラプラスエッジ検出では,現在のところ</target>
        </trans-unit>
        <trans-unit id="c26bd272e8dcb1ad4f38240d83c90fe2b2da1de1" translate="yes" xml:space="preserve">
          <source>Lastly (in this series of &lt;code&gt;and&lt;/code&gt; sub-patterns), &lt;code&gt;app&lt;/code&gt; evaluates &lt;code&gt;(match-string&amp;nbsp;1&amp;nbsp;&lt;var&gt;expval&lt;/var&gt;)&lt;/code&gt; (line 6) to get a temporary value &lt;var&gt;tmp&lt;/var&gt; (i.e., the &amp;ldquo;NUMBER&amp;rdquo; substring) and tries to match &lt;var&gt;tmp&lt;/var&gt; against pattern &lt;code&gt;val&lt;/code&gt; (line 7). Since that is a &lt;var&gt;symbol&lt;/var&gt; pattern, it matches unconditionally and additionally binds &lt;code&gt;val&lt;/code&gt; to &lt;var&gt;tmp&lt;/var&gt;.</source>
          <target state="translated">最後（のこのシリーズの &lt;code&gt;and&lt;/code&gt; 、サブパターン） &lt;code&gt;app&lt;/code&gt; 評価する &lt;code&gt;(match-string&amp;nbsp;1&amp;nbsp;&lt;var&gt;expval&lt;/var&gt;)&lt;/code&gt; 一時的な値を取得する（ライン6） &lt;var&gt;tmp&lt;/var&gt; （サブストリングすなわち、「NUMBER」）と一致させようと &lt;var&gt;tmp&lt;/var&gt; のパターンに対して &lt;code&gt;val&lt;/code&gt; （ライン7）。これは &lt;var&gt;symbol&lt;/var&gt; パターンであるため、無条件に一致し、さらに &lt;code&gt;val&lt;/code&gt; を &lt;var&gt;tmp&lt;/var&gt; にバインドします。</target>
        </trans-unit>
        <trans-unit id="3c447261c5172f1f0b697d9d9c7e4f3be584769f" translate="yes" xml:space="preserve">
          <source>Layout Parameters</source>
          <target state="translated">レイアウトパラメータ</target>
        </trans-unit>
        <trans-unit id="dd7dcc546a0d472e7c791aa18106a1ac7f735332" translate="yes" xml:space="preserve">
          <source>Lazy Computation of Text Properties</source>
          <target state="translated">テキストプロパティの遅延計算</target>
        </trans-unit>
        <trans-unit id="51a6c8e8ab483e67fa01f4eb903d9c6360351fa8" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s assume you did not type</source>
          <target state="translated">入力しなかったとしましょう</target>
        </trans-unit>
        <trans-unit id="6c75a6f87f325302da0b7e4c39c4c865071152a7" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s consider a user who, as a rule, prefers to display buffers on another frame. Such a user might provide the following customization:</source>
          <target state="translated">原則として、別のフレームにバッファを表示することを好むユーザーを考えてみましょう。このようなユーザーは、次のカスタマイズを提供する場合があります。</target>
        </trans-unit>
        <trans-unit id="b0ffbdb0406b9b3b41b822f0911fd341803419cd" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s consider the situation where &lt;code&gt;obj&lt;/code&gt; is not a string, or it is a string but has the wrong form. In this case, one of the &lt;code&gt;pred&lt;/code&gt; (lines 3-5) fails to match, thus &lt;code&gt;and&lt;/code&gt; (line 2) fails to match, thus &lt;code&gt;or&lt;/code&gt; (line 1) proceeds to try sub-pattern &lt;code&gt;let&lt;/code&gt; (line 8).</source>
          <target state="translated">&lt;code&gt;obj&lt;/code&gt; が文字列ではない、または文字列であるが形式が間違っている状況を考えてみましょう。この場合、 &lt;code&gt;pred&lt;/code&gt; の1つ（3〜5行目）が一致しないため &lt;code&gt;and&lt;/code&gt; （2行目）が一致しないため、 &lt;code&gt;or&lt;/code&gt; （1行目）がサブパターン &lt;code&gt;let&lt;/code&gt; （8行目）の試行に進みます。</target>
        </trans-unit>
        <trans-unit id="f464f3d20ed12cd11f243e1c955b67ff512e7c56" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s start with a precise explanation of the arguments to the &lt;code&gt;DEFUN&lt;/code&gt; macro. Here is a template for them:</source>
          <target state="translated">&lt;code&gt;DEFUN&lt;/code&gt; マクロの引数の正確な説明から始めましょう。それらのテンプレートは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="41d77d8b522c0e48c0a6671a0d4abc1bf8cb3bb4" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s use the term &lt;em&gt;keymap entry&lt;/em&gt; to describe the value found by looking up an event type in a keymap. (This doesn&amp;rsquo;t include the item string and other extra elements in a keymap element for a menu item, because &lt;code&gt;lookup-key&lt;/code&gt; and other key lookup functions don&amp;rsquo;t include them in the returned value.) While any Lisp object may be stored in a keymap as a keymap entry, not all make sense for key lookup. Here is a table of the meaningful types of keymap entries:</source>
          <target state="translated">&lt;em&gt;キーマップエントリ&lt;/em&gt;という用語を使用して、キーマップでイベントタイプを検索して見つかった値を説明しましょう。 （ &lt;code&gt;lookup-key&lt;/code&gt; およびその他のキールックアップ関数は戻り値に含まれないため、これにはメニュー項目のキーマップ要素に項目文字列およびその他の追加要素は含まれません。）Lispオブジェクトはに格納される可能性があります。キーマップエントリとしてのキーマップ。すべてがキールックアップに意味があるわけではありません。キーマップエントリの意味のあるタイプの表を次に示します。</target>
        </trans-unit>
        <trans-unit id="8bbb0c0a5273b41486ac35de13cae2a081554aba" translate="yes" xml:space="preserve">
          <source>Letter-case of the strings is significant for the computed distance, but their text properties are ignored. If the optional argument &lt;var&gt;bytecompare&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, the function calculates the distance in terms of bytes instead of characters. The byte-wise comparison uses the internal Emacs representation of characters, so it will produce inaccurate results for multibyte strings that include raw bytes (see &lt;a href=&quot;text-representations#Text-Representations&quot;&gt;Text Representations&lt;/a&gt;); make the strings unibyte by encoding them (see &lt;a href=&quot;explicit-encoding#Explicit-Encoding&quot;&gt;Explicit Encoding&lt;/a&gt;) if you need accurate results with raw bytes.</source>
          <target state="translated">文字列の大文字と小文字は計算された距離にとって重要ですが、それらのテキストプロパティは無視されます。オプションの引数 &lt;var&gt;bytecompare&lt;/var&gt; が &lt;code&gt;nil&lt;/code&gt; 以外の場合、関数は文字ではなくバイト単位で距離を計算します。バイト単位の比較では、文字の内部Emacs表現が使用されるため、生のバイトを含むマルチバイト文字列に対して不正確な結果が生成されます（&lt;a href=&quot;text-representations#Text-Representations&quot;&gt;テキスト表現を&lt;/a&gt;参照）。生のバイトで正確な結果が必要な場合は、文字列をエンコードしてユニバイトにします（&lt;a href=&quot;explicit-encoding#Explicit-Encoding&quot;&gt;明示的なエンコードを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="24275f318d0094becb9bb3da3aed51320878e090" translate="yes" xml:space="preserve">
          <source>Level 1: highlight function declarations, file directives (such as include or import directives), strings and comments. The idea is speed, so only the most important and top-level components are fontified.</source>
          <target state="translated">レベル1:関数宣言、ファイル指示(インクルードやインポート指示など)、文字列、コメントを強調表示します。スピードを重視しているため、最も重要なトップレベルのコンポーネントのみがフォント化されます。</target>
        </trans-unit>
        <trans-unit id="2117c8f73cb61424d16255425c9131034d1c287e" translate="yes" xml:space="preserve">
          <source>Level 2: in addition to level 1, highlight all language keywords, including type names that act like keywords, as well as named constant values. The idea is that all keywords (either syntactic or semantic) should be fontified appropriately.</source>
          <target state="translated">レベル2:レベル1に加えて、キーワードのように振る舞う型名や名前付き定数値を含むすべての言語キーワードを強調表示します。これは、すべてのキーワード(構文的または意味的なもの)を適切にフォント化することです。</target>
        </trans-unit>
        <trans-unit id="660378d0e3ca367794af05e686894a24e39fd862" translate="yes" xml:space="preserve">
          <source>Level 3: in addition to level 2, highlight the symbols being defined in function and variable declarations, and all builtin function names, wherever they appear.</source>
          <target state="translated">レベル 3:レベル 2 に加えて、関数や変数の宣言で定義されているシンボル、およびすべての組み込み関数名が表示されている場所を強調表示します。</target>
        </trans-unit>
        <trans-unit id="87fb603e415154744259577d7102e0b2b0b1e8f1" translate="yes" xml:space="preserve">
          <source>Levels of Font Lock</source>
          <target state="translated">フォントロックのレベル</target>
        </trans-unit>
        <trans-unit id="845c80fcc7da2e284fb9f14c14e06bfedafb8705" translate="yes" xml:space="preserve">
          <source>Lexical Binding</source>
          <target state="translated">レキシカルバインディング</target>
        </trans-unit>
        <trans-unit id="03c426c0276e9e8faf0018b87a45220aece313e0" translate="yes" xml:space="preserve">
          <source>Lexical binding is also enabled in Lisp Interaction and IELM mode, used in the</source>
          <target state="translated">レキシカルバインディングは、Lisp Interaction と IELM モードでも有効になっています。</target>
        </trans-unit>
        <trans-unit id="8f85fbb6468aabdaf187bcf592914af6cc0d70ab" translate="yes" xml:space="preserve">
          <source>Lexical binding was introduced to Emacs, as an optional feature, in version 24.1. We expect its importance to increase with time. Lexical binding opens up many more opportunities for optimization, so programs using it are likely to run faster in future Emacs versions. Lexical binding is also more compatible with concurrency, which was added to Emacs in version 26.1.</source>
          <target state="translated">レキシカルバインディングはバージョン24.1でオプション機能としてEmacsに導入されました。その重要性は時間の経過とともに増していくと予想されます。Lexical バインディングは最適化のための多くの機会を提供してくれるので、将来の Emacs バージョンでは、Lexical バインディングを使用したプログラムがより高速に動作するようになるでしょう。Lexical binding は、バージョン 26.1 で Emacs に追加された concurrency との互換性も向上しています。</target>
        </trans-unit>
        <trans-unit id="88636ad7d4af3bb35c12874b15e249f93c783680" translate="yes" xml:space="preserve">
          <source>Lexical bindings have indefinite extent. Even after a binding construct has finished executing, its lexical environment can be &amp;ldquo;kept around&amp;rdquo; in Lisp objects called &lt;em&gt;closures&lt;/em&gt;. A closure is created when you define a named or anonymous function with lexical binding enabled. See &lt;a href=&quot;closures#Closures&quot;&gt;Closures&lt;/a&gt;, for details.</source>
          <target state="translated">字句バインディングの範囲は不定です。バインディングコンストラクトの実行が終了した後でも、その字句環境は&lt;em&gt;クロージャ&lt;/em&gt;と呼ばれるLispオブジェクトに「保持」できます。字句バインディングを有効にして名前付き関数または無名関数を定義すると、クロージャが作成されます。詳細については、&lt;a href=&quot;closures#Closures&quot;&gt;クロージャ&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="58d773a50406916324eae7c7bdd22604efe3ac76" translate="yes" xml:space="preserve">
          <source>Library Search</source>
          <target state="translated">図書館検索</target>
        </trans-unit>
        <trans-unit id="9b66d8e56a509c424a23ad7b016d16d59e2f1039" translate="yes" xml:space="preserve">
          <source>Licensed under the GNU GPL license.</source>
          <target state="translated">GNU GPLライセンスの下でライセンスされています。</target>
        </trans-unit>
        <trans-unit id="c7e02c95fe85052fcadf9745a5f1d0358088d936" translate="yes" xml:space="preserve">
          <source>Like</source>
          <target state="translated">Like</target>
        </trans-unit>
        <trans-unit id="1b251709afeae3912bdd27abd462e3a66e4fd821" translate="yes" xml:space="preserve">
          <source>Like &amp;lsquo;</source>
          <target state="translated">お気に入り '</target>
        </trans-unit>
        <trans-unit id="18854c1917f4c8ae7ba5b12ef46faa8c310417a3" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;base64-encode-string&lt;/code&gt;, but generates the URL variant of base 64, and doesn&amp;rsquo;t insert newline characters into the encoded text, so the result is just one long line.</source>
          <target state="translated">&lt;code&gt;base64-encode-string&lt;/code&gt; と同様ですが、base 64のURLバリアントを生成し、エンコードされたテキストに改行文字を挿入しないため、結果は1行だけになります。</target>
        </trans-unit>
        <trans-unit id="cf864cb9871ee5f0fed0c2f4c9ed40a911dc24fb" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;const&lt;/code&gt;, but used for values which are functions. This displays the documentation string as well as the function name. The documentation string is either the one you specify with &lt;code&gt;:doc&lt;/code&gt;, or &lt;var&gt;function&lt;/var&gt;&amp;rsquo;s own documentation string.</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; と同様ですが、関数である値に使用されます。これにより、ドキュメント文字列と関数名が表示されます。ドキュメント文字列は、 &lt;code&gt;:doc&lt;/code&gt; で指定したものか、 &lt;var&gt;function&lt;/var&gt; 独自のドキュメント文字列です。</target>
        </trans-unit>
        <trans-unit id="35528820d5e979720b5f6b9b2860031f57025852" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;const&lt;/code&gt;, but used for values which are variable names. This displays the documentation string as well as the variable name. The documentation string is either the one you specify with &lt;code&gt;:doc&lt;/code&gt;, or &lt;var&gt;variable&lt;/var&gt;&amp;rsquo;s own documentation string.</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; と同様ですが、変数名である値に使用されます。これにより、ドキュメント文字列と変数名が表示されます。ドキュメント文字列は、 &lt;code&gt;:doc&lt;/code&gt; で指定したものか、 &lt;var&gt;variable&lt;/var&gt; の独自のドキュメント文字列です。</target>
        </trans-unit>
        <trans-unit id="511f05b3538b8f4e5096f874143c83d71d91d631" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;custom-initialize-set&lt;/code&gt;, but use the function &lt;code&gt;set-default&lt;/code&gt; to set the variable, instead of the variable&amp;rsquo;s &lt;code&gt;:set&lt;/code&gt; function. This is the usual choice for a variable whose &lt;code&gt;:set&lt;/code&gt; function enables or disables a minor mode; with this choice, defining the variable will not call the minor mode function, but customizing the variable will do so.</source>
          <target state="translated">&lt;code&gt;custom-initialize-set&lt;/code&gt; と同様 &lt;code&gt;set-default&lt;/code&gt; が、変数の &lt;code&gt;:set&lt;/code&gt; 関数の代わりに、関数set-defaultを使用して変数を設定します。これは、 &lt;code&gt;:set&lt;/code&gt; 関数がマイナーモードを有効または無効にする変数の通常の選択です。この選択では、変数を定義してもマイナーモード関数は呼び出されませんが、変数をカスタマイズすると呼び出されます。</target>
        </trans-unit>
        <trans-unit id="204b186d3bb6599421d53e05eadb77e0ad88c08e" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;custom-manual&lt;/code&gt; except that the link appears in the customization buffer with the Info node name.</source>
          <target state="translated">リンクがInfoノード名でカスタマイズバッファに表示されることを除いて、 &lt;code&gt;custom-manual&lt;/code&gt; と同様です。</target>
        </trans-unit>
        <trans-unit id="ce9088de4b6dd7133bd35b95efda2d37cb731128" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;defmacro&lt;/code&gt;, a function inlined with &lt;code&gt;define-inline&lt;/code&gt; inherits the scoping rules, either dynamic or lexical, from the call site. See &lt;a href=&quot;variable-scoping#Variable-Scoping&quot;&gt;Variable Scoping&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;defmacro&lt;/code&gt; と同様に、 &lt;code&gt;define-inline&lt;/code&gt; でインライン化された関数は、動的または字句のいずれかのスコープ規則を呼び出しサイトから継承します。&lt;a href=&quot;variable-scoping#Variable-Scoping&quot;&gt;変数スコープを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="054b1abbf6ea76431660ba137b3df462a1771437" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;defvar&lt;/code&gt;, this macro marks &lt;code&gt;option&lt;/code&gt; as a special variable, meaning that it should always be dynamically bound. If &lt;var&gt;option&lt;/var&gt; is already lexically bound, that lexical binding remains in effect until the binding construct exits. See &lt;a href=&quot;variable-scoping#Variable-Scoping&quot;&gt;Variable Scoping&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;defvar&lt;/code&gt; と同様に、このマクロは &lt;code&gt;option&lt;/code&gt; を特別な変数としてマークします。つまり、常に動的にバインドする必要があります。 &lt;var&gt;option&lt;/var&gt; がすでに字句的にバインドされている場合、その字句バインディングは、バインディング構造が終了するまで有効です。&lt;a href=&quot;variable-scoping#Variable-Scoping&quot;&gt;変数スコープを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="f505d65b09cd1366a862e42a8e4a2919c0a4c57d" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;exit&lt;/code&gt;, but add the key that was pressed to &lt;code&gt;unread-command-events&lt;/code&gt; (see &lt;a href=&quot;event-input-misc#Event-Input-Misc&quot;&gt;Event Input Misc&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;exit&lt;/code&gt; と同様ですが、押されたキーを &lt;code&gt;unread-command-events&lt;/code&gt; に追加します（&lt;a href=&quot;event-input-misc#Event-Input-Misc&quot;&gt;Event Input Miscを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="ea9c4bf2fcaba7d1996da05f9b1b988c94d94fff" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;group&lt;/code&gt;, but explicitly assign the group number &lt;var&gt;n&lt;/var&gt;. &lt;var&gt;n&lt;/var&gt; must be positive. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">&lt;code&gt;group&lt;/code&gt; と同様ですが、グループ番号 &lt;var&gt;n&lt;/var&gt; を明示的に割り当てます。 &lt;var&gt;n&lt;/var&gt; は正でなければなりません。対応する文字列正規表現： '</target>
        </trans-unit>
        <trans-unit id="4add0eb468b070e1db0603abb32c078a15300385" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;list&lt;/code&gt; except that the value must be a vector instead of a list. The elements work the same as in &lt;code&gt;list&lt;/code&gt;.</source>
          <target state="translated">値がリストではなくベクトルでなければならないことを除いて、 &lt;code&gt;list&lt;/code&gt; と同様です。要素は &lt;code&gt;list&lt;/code&gt; と同じように機能します。</target>
        </trans-unit>
        <trans-unit id="1e9ef9ed8d9cfadaf1437987621cbd1046a68178" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;minflt&lt;/code&gt; and &lt;code&gt;majflt&lt;/code&gt;, but include the number of page faults for all the child processes of the given process.</source>
          <target state="translated">&lt;code&gt;minflt&lt;/code&gt; や &lt;code&gt;majflt&lt;/code&gt; と同様ですが、特定のプロセスのすべての子プロセスのページフォールトの数が含まれます。</target>
        </trans-unit>
        <trans-unit id="9dec2e247bfc6d918dc0518cecb0337e87b44e0a" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;next-frame&lt;/code&gt;, but cycles through all frames in the opposite direction.</source>
          <target state="translated">&lt;code&gt;next-frame&lt;/code&gt; と同様ですが、すべてのフレームを反対方向に循環します。</target>
        </trans-unit>
        <trans-unit id="1c35e817ce01d7a752f2915ea0e7c93f0517b8ce" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;plist-get&lt;/code&gt; except that it compares properties using &lt;code&gt;equal&lt;/code&gt; instead of &lt;code&gt;eq&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;eq&lt;/code&gt; の代わりに &lt;code&gt;equal&lt;/code&gt; を使用してプロパティを比較することを除いて、 &lt;code&gt;plist-get&lt;/code&gt; と同様です。</target>
        </trans-unit>
        <trans-unit id="b8a06b48a7b978de0c0d0d182fbd613f4474d842" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;plist-put&lt;/code&gt; except that it compares properties using &lt;code&gt;equal&lt;/code&gt; instead of &lt;code&gt;eq&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;eq&lt;/code&gt; の代わりに &lt;code&gt;equal&lt;/code&gt; を使用してプロパティを比較すること &lt;code&gt;plist-put&lt;/code&gt; 除いて、plist-putと同様です。</target>
        </trans-unit>
        <trans-unit id="5e02ab76a9a240ef8de0ab7231efecfe7c29c24c" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;remove-text-properties&lt;/code&gt; except that &lt;var&gt;list-of-properties&lt;/var&gt; is a list of property names only, not an alternating list of property names and values.</source>
          <target state="translated">&lt;code&gt;remove-text-properties&lt;/code&gt; と同様ですが、 &lt;var&gt;list-of-properties&lt;/var&gt; はプロパティ名のみのリストであり、プロパティ名と値の交互のリストではありません。</target>
        </trans-unit>
        <trans-unit id="84e3993015f242ac6ae5f8797efb186174cfc8b8" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;set-buffer-modified-p&lt;/code&gt;, but does not force redisplay of mode lines.</source>
          <target state="translated">&lt;code&gt;set-buffer-modified-p&lt;/code&gt; と同様ですが、モード行の再表示を強制しません。</target>
        </trans-unit>
        <trans-unit id="9a6e79e4e3bd95966166ddf0bb5d7b010896c5bf" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;signal&lt;/code&gt; (see &lt;a href=&quot;signaling-errors#Signaling-Errors&quot;&gt;Signaling Errors&lt;/a&gt;), but the signal is delivered in the thread &lt;var&gt;thread&lt;/var&gt;. If &lt;var&gt;thread&lt;/var&gt; is the current thread, then this just calls &lt;code&gt;signal&lt;/code&gt; immediately. Otherwise, &lt;var&gt;thread&lt;/var&gt; will receive the signal as soon as it becomes current. If &lt;var&gt;thread&lt;/var&gt; was blocked by a call to &lt;code&gt;mutex-lock&lt;/code&gt;, &lt;code&gt;condition-wait&lt;/code&gt;, or &lt;code&gt;thread-join&lt;/code&gt;; &lt;code&gt;thread-signal&lt;/code&gt; will unblock it.</source>
          <target state="translated">&lt;code&gt;signal&lt;/code&gt; と同様ですが（&lt;a href=&quot;signaling-errors#Signaling-Errors&quot;&gt;シグナルエラーを&lt;/a&gt;参照）、シグナルはスレッド &lt;var&gt;thread&lt;/var&gt; 配信されます。場合は &lt;var&gt;thread&lt;/var&gt; 現在のスレッドで、これだけのコールは &lt;code&gt;signal&lt;/code&gt; すぐ。それ以外の場合、 &lt;var&gt;thread&lt;/var&gt; は現在の信号になるとすぐに信号を受信します。 &lt;code&gt;mutex-lock&lt;/code&gt; 、 &lt;code&gt;condition-wait&lt;/code&gt; 、または &lt;code&gt;thread-join&lt;/code&gt; の呼び出しによって &lt;var&gt;thread&lt;/var&gt; がブロックされた場合。 &lt;code&gt;thread-signal&lt;/code&gt; はそれをブロック解除します。</target>
        </trans-unit>
        <trans-unit id="70f44fcb4db769ebd3aa02784e1dfae20cbb9cec" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;start-process&lt;/code&gt;, this function starts a new asynchronous subprocess running &lt;var&gt;program&lt;/var&gt; in it, and returns its process object.</source>
          <target state="translated">&lt;code&gt;start-process&lt;/code&gt; と同様に、この関数はその中で &lt;var&gt;program&lt;/var&gt; を実行している新しい非同期サブプロセスを開始し、そのプロセスオブジェクトを返します。</target>
        </trans-unit>
        <trans-unit id="1768be4d2bcedb1b2e7b51f71b8b22c88b6d6932" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;string&lt;/code&gt; except that the string must be a valid regular expression.</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt; が有効な正規表現でなければならないことを除いて、文字列と同様です。</target>
        </trans-unit>
        <trans-unit id="f979121e411bd20dfdc3630fc906f2e77d6bac00" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;switch-to-buffer&lt;/code&gt;, this function updates the buffer list unless &lt;var&gt;norecord&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;switch-to-buffer&lt;/code&gt; と同様に、この関数は &lt;var&gt;norecord&lt;/var&gt; が &lt;code&gt;nil&lt;/code&gt; 以外でない限り、バッファーリストを更新します。</target>
        </trans-unit>
        <trans-unit id="41318cc8f100d4675dfe14fffade93d0c7208044" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;tabulated-list-gui-sort-indicator-asc&lt;/code&gt;, but used for text-mode frames.</source>
          <target state="translated">&lt;code&gt;tabulated-list-gui-sort-indicator-asc&lt;/code&gt; に似ていますが、テキストモードフレームに使用されます。</target>
        </trans-unit>
        <trans-unit id="e26f9bf4e17c8b8a9b3a88b07dbaf00921a8ff2b" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;tabulated-list-gui-sort-indicator-asc&lt;/code&gt;, but used when the column is sorted in the descending order.</source>
          <target state="translated">同様 &lt;code&gt;tabulated-list-gui-sort-indicator-asc&lt;/code&gt; 列が降順にソートされている場合が、使用。</target>
        </trans-unit>
        <trans-unit id="ac75f39d714deb46e7cfbb9da2b8004c0b4dd120" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;tabulated-list-tty-sort-indicator-asc&lt;/code&gt;, but used when the column is sorted in the descending order.</source>
          <target state="translated">同様 &lt;code&gt;tabulated-list-tty-sort-indicator-asc&lt;/code&gt; 列が降順にソートされている場合が、使用。</target>
        </trans-unit>
        <trans-unit id="83baebd26ca9a920629b6b8881f71882e191e292" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;this-command-keys&lt;/code&gt;, except that it always returns the events in a vector, so you don&amp;rsquo;t need to deal with the complexities of storing input events in a string (see &lt;a href=&quot;strings-of-events#Strings-of-Events&quot;&gt;Strings of Events&lt;/a&gt;).</source>
          <target state="translated">同様に &lt;code&gt;this-command-keys&lt;/code&gt; 、あなたが（参照文字列の入力イベントを保存するの複雑さに対処する必要はありませんので、それは常にベクトルでイベントを返すことを除いて、&lt;a href=&quot;strings-of-events#Strings-of-Events&quot;&gt;イベントの文字列を&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="2a77e33ddaa024bcb7e1de6d16b70822ff2b74e0" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;utime&lt;/code&gt;, &lt;code&gt;stime&lt;/code&gt;, and &lt;code&gt;time&lt;/code&gt;, but include the times of all the child processes of the given process.</source>
          <target state="translated">同様 &lt;code&gt;utime&lt;/code&gt; 、 &lt;code&gt;stime&lt;/code&gt; 、および &lt;code&gt;time&lt;/code&gt; が、与えられたプロセスのすべての子プロセスの時間を含みます。</target>
        </trans-unit>
        <trans-unit id="264fb3dd5c5a9c6df032cdd8b67cc032c5141d77" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;vertical-motion&lt;/code&gt;, &lt;code&gt;count-screen-lines&lt;/code&gt; always uses the current buffer, regardless of which buffer is displayed in &lt;var&gt;window&lt;/var&gt;. This makes possible to use &lt;code&gt;count-screen-lines&lt;/code&gt; in any buffer, whether or not it is currently displayed in some window.</source>
          <target state="translated">&lt;code&gt;vertical-motion&lt;/code&gt; と同様に、 &lt;code&gt;count-screen-lines&lt;/code&gt; は、 &lt;var&gt;window&lt;/var&gt; 表示されているバッファーに関係なく、常に現在のバッファーを使用します。これにより、現在一部のウィンドウに表示されているかどうかに関係なく、任意のバッファーで &lt;code&gt;count-screen-lines&lt;/code&gt; を使用できます。</target>
        </trans-unit>
        <trans-unit id="1d2cce2deecdcf8cf23c34bb65bc484d84587588" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;y-or-n-p&lt;/code&gt;, except that if the user fails to answer within &lt;var&gt;seconds&lt;/var&gt; seconds, this function stops waiting and returns &lt;var&gt;default&lt;/var&gt;. It works by setting up a timer; see &lt;a href=&quot;timers#Timers&quot;&gt;Timers&lt;/a&gt;. The argument &lt;var&gt;seconds&lt;/var&gt; should be a number.</source>
          <target state="translated">&lt;code&gt;y-or-n-p&lt;/code&gt; と同様ですが、ユーザーが &lt;var&gt;seconds&lt;/var&gt; 秒以内に応答しなかった場合、この関数は待機を停止し、 &lt;var&gt;default&lt;/var&gt; を返します。タイマーを設定することで機能します。&lt;a href=&quot;timers#Timers&quot;&gt;タイマーを&lt;/a&gt;参照してください。引数 &lt;var&gt;seconds&lt;/var&gt; は数値である必要があります。</target>
        </trans-unit>
        <trans-unit id="42d3bb0dd219a8f3377a5d7dfc35b9c093371501" translate="yes" xml:space="preserve">
          <source>Like a buffer, a string can contain text properties for the characters in it, as well as the characters themselves. See &lt;a href=&quot;text-properties#Text-Properties&quot;&gt;Text Properties&lt;/a&gt;. All the Lisp primitives that copy text from strings to buffers or other strings also copy the properties of the characters being copied.</source>
          <target state="translated">バッファと同様に、文字列には、文字自体だけでなく、その中の文字のテキストプロパティを含めることができます。&lt;a href=&quot;text-properties#Text-Properties&quot;&gt;テキストのプロパティを&lt;/a&gt;参照してください。文字列からバッファまたは他の文字列にテキストをコピーするすべてのLispプリミティブは、コピーされる文字のプロパティもコピーします。</target>
        </trans-unit>
        <trans-unit id="a8a6416bd2f6413e3de422a7bab6e772fb8419cd" translate="yes" xml:space="preserve">
          <source>Like a mode line, but at the top.</source>
          <target state="translated">モードラインみたいな感じで、トップで。</target>
        </trans-unit>
        <trans-unit id="ea6efe0718530791d43dbe7d53bb5a14e1b67ed8" translate="yes" xml:space="preserve">
          <source>Like abbrevs, abbrev tables have properties, some of which influence the way they work. You can provide them as arguments to &lt;code&gt;define-abbrev-table&lt;/code&gt;, and manipulate them with the functions:</source>
          <target state="translated">略語と同様に、略語テーブルにはプロパティがあり、その一部は動作方法に影響を与えます。それらを &lt;code&gt;define-abbrev-table&lt;/code&gt; の引数として指定し、次の関数で操作できます。</target>
        </trans-unit>
        <trans-unit id="44ec097d5bc177ce9f85e7d020e50ae88d2f91c4" translate="yes" xml:space="preserve">
          <source>Like any application, Emacs can be run in a secure environment, where the operating system enforces rules about access and the like. With some care, Emacs-based applications can also be part of a security perimeter that checks such rules. Although the default settings for Emacs work well for a typical software development environment, they may require adjustment in environments containing untrusted users that may include attackers. Here is a compendium of security issues that may be helpful if you are developing such applications. It is by no means complete; it is intended to give you an idea of the security issues involved, rather than to be a security checklist.</source>
          <target state="translated">他のアプリケーションと同様に、Emacs は安全な環境で実行することができます。多少の注意を払えば、Emacs ベースのアプリケーションは、そのようなルールをチェックするセキュリ ティ境界線の一部になることもできます。Emacs のデフォルト設定は、一般的なソフトウェア開発環境では十分に機能しますが、攻撃者を含む信頼されていないユー ザーを含む環境では、調整が必要になる場合があります。ここでは、このようなアプリケーションを開発している場合に役立つと思われるセキュリ ティ問題の概要を紹介します。これは完全なものではありません。これは、セキュリティチェックリストではなく、関連するセキュリ ティ問題のアイデアを提供することを目的としています。</target>
        </trans-unit>
        <trans-unit id="64697998797f77574ca5b12fc923c577aecf3e58" translate="yes" xml:space="preserve">
          <source>Like any marker, this marker can be set to point at any buffer you like. If you make it point at any buffer other than the one of which it is the mark, it will yield perfectly consistent, but rather odd, results. We recommend that you not do it!</source>
          <target state="translated">他のマーカーと同様に、このマーカーも任意のバッファを指すように設定することができます。このマーカーがマークされているバッファ以外のバッファを指すように設定すると、完全に一貫した結果が得られますが、むしろ奇妙な結果になります。このようなことはしないことをお勧めします。</target>
        </trans-unit>
        <trans-unit id="1e30ff33c9d97dd95ea9111da199e049a900cc43" translate="yes" xml:space="preserve">
          <source>Like other arrays, vectors use zero-origin indexing: the first element has index 0.</source>
          <target state="translated">他の配列と同様に、ベクトルはゼロオリジンインデックスを使用します。</target>
        </trans-unit>
        <trans-unit id="bd4fbae429af14d7410a0be5944198b140179fb1" translate="yes" xml:space="preserve">
          <source>Like other buffers, a minibuffer uses a local keymap (see &lt;a href=&quot;keymaps#Keymaps&quot;&gt;Keymaps&lt;/a&gt;) to specify special key bindings. The function that invokes the minibuffer also sets up its local map according to the job to be done. See &lt;a href=&quot;text-from-minibuffer#Text-from-Minibuffer&quot;&gt;Text from Minibuffer&lt;/a&gt;, for the non-completion minibuffer local maps. See &lt;a href=&quot;completion-commands#Completion-Commands&quot;&gt;Completion Commands&lt;/a&gt;, for the minibuffer local maps for completion.</source>
          <target state="translated">他のバッファと同様に、ミニバッファは（参照ローカルキーマップを使用して&lt;a href=&quot;keymaps#Keymaps&quot;&gt;キーマップを&lt;/a&gt;特別なキーバインディングを指定します）。ミニバッファを呼び出す関数は、実行するジョブに応じてローカルマップも設定します。未完了のミニバッファローカルマップについては、ミニバッファ&lt;a href=&quot;text-from-minibuffer#Text-from-Minibuffer&quot;&gt;からのテキストを&lt;/a&gt;参照してください。&lt;a href=&quot;completion-commands#Completion-Commands&quot;&gt;完了&lt;/a&gt;用のミニバッファローカルマップについては、完了コマンドを参照してください。</target>
        </trans-unit>
        <trans-unit id="b2ee97c7efba6f620110611b5db71717d51e8ddb" translate="yes" xml:space="preserve">
          <source>Like other positions, point designates a place between two characters (or before the first character, or after the last character), rather than a particular character. Usually terminals display the cursor over the character that immediately follows point; point is actually before the character on which the cursor sits.</source>
          <target state="translated">他の位置と同様に、ポイントは特定の文字ではなく、2つの文字の間の位置(または最初の文字の前、または最後の文字の後)を指定する。通常、端末は point の直後の文字の上にカーソルを表示しますが、point は実際にはカーソルのある文字の前にあります。</target>
        </trans-unit>
        <trans-unit id="8da9a43aec4137b9ff967ca13c1bd7372e6ad639" translate="yes" xml:space="preserve">
          <source>Like the &lt;code&gt;and&lt;/code&gt; construct, &lt;code&gt;or&lt;/code&gt; can be written in terms of &lt;code&gt;cond&lt;/code&gt;. For example:</source>
          <target state="translated">同様 &lt;code&gt;and&lt;/code&gt; 構築物 &lt;code&gt;or&lt;/code&gt; の用語で記述することができ &lt;code&gt;cond&lt;/code&gt; 。例えば：</target>
        </trans-unit>
        <trans-unit id="a93ae83163cf6a8ddec90d055956fb5025562919" translate="yes" xml:space="preserve">
          <source>Like the menu bar, the tool bar (see &lt;a href=&quot;tool-bar#Tool-Bar&quot;&gt;Tool Bar&lt;/a&gt;) can be either internal (drawn by Emacs itself) or external (drawn by a toolkit). The GTK+ and NS builds have the tool bar drawn by the toolkit. The remaining builds use internal tool bars. With GTK+ the tool bar can be located on either side of the frame, immediately outside the internal border, see below. Tool bars are usually not shown for child frames (see &lt;a href=&quot;child-frames#Child-Frames&quot;&gt;Child Frames&lt;/a&gt;). Display of the tool bar can be suppressed by setting the &lt;code&gt;tool-bar-lines&lt;/code&gt; parameter (see &lt;a href=&quot;layout-parameters#Layout-Parameters&quot;&gt;Layout Parameters&lt;/a&gt;) to zero.</source>
          <target state="translated">メニューバーと同様に、ツール・バーは、（参照&lt;a href=&quot;tool-bar#Tool-Bar&quot;&gt;ツールバーを&lt;/a&gt;）内部（Emacs自身によって描かれた）または（ツールキットによって描かれた）外部のいずれかになります。 GTK +およびNSビルドには、ツールキットによって描画されるツールバーがあります。残りのビルドは内部ツールバーを使用します。 GTK +を使用すると、ツールバーはフレームの両側、内側の境界のすぐ外側に配置できます。以下を参照してください。ツールバーは、通常、子フレーム（参照のために示されていない&lt;a href=&quot;child-frames#Child-Frames&quot;&gt;子フレームを&lt;/a&gt;）。ツールバーの表示は、tool &lt;code&gt;tool-bar-lines&lt;/code&gt; パラメーター（「&lt;a href=&quot;layout-parameters#Layout-Parameters&quot;&gt;レイアウトパラメーター&lt;/a&gt;」を参照）をゼロに設定することで抑制できます。</target>
        </trans-unit>
        <trans-unit id="fda771ab560862777893dc0b295d979a9763ad74" translate="yes" xml:space="preserve">
          <source>Like the menu bar, the tool bar can display separators (see &lt;a href=&quot;menu-separators#Menu-Separators&quot;&gt;Menu Separators&lt;/a&gt;). Tool bar separators are vertical rather than horizontal, though, and only a single style is supported. They are represented in the tool bar keymap by &lt;code&gt;(menu-item &quot;--&quot;)&lt;/code&gt; entries; properties like &lt;code&gt;:visible&lt;/code&gt; are not supported for tool bar separators. Separators are rendered natively in GTK+ and Nextstep tool bars; in the other cases, they are rendered using an image of a vertical line.</source>
          <target state="translated">メニューバーと同様に、ツールバーにはセパレーターを表示できます（&lt;a href=&quot;menu-separators#Menu-Separators&quot;&gt;メニューセパレーターを&lt;/a&gt;参照）。ただし、ツールバーの区切り文字は水平ではなく垂直であり、サポートされるスタイルは1つだけです。それらは、ツールバーのキーマップで &lt;code&gt;(menu-item &quot;--&quot;)&lt;/code&gt; エントリによって表されます。 &lt;code&gt;:visible&lt;/code&gt; のようなプロパティは、ツールバーの区切り文字ではサポートされていません。セパレーターはGTK +およびNextstepツールバーでネイティブにレンダリングされます。それ以外の場合は、垂直線の画像を使用してレンダリングされます。</target>
        </trans-unit>
        <trans-unit id="9df33e5d8f7b38be89f4b568592a838f25636c81" translate="yes" xml:space="preserve">
          <source>Like the standard &lt;code&gt;backref&lt;/code&gt; construct, but &lt;var&gt;ref&lt;/var&gt; can here also be a name introduced by a previous &lt;code&gt;(let &lt;var&gt;ref&lt;/var&gt; &amp;hellip;)&lt;/code&gt; construct.</source>
          <target state="translated">標準の &lt;code&gt;backref&lt;/code&gt; コンストラクトと同様ですが、 &lt;var&gt;ref&lt;/var&gt; は、以前の &lt;code&gt;(let &lt;var&gt;ref&lt;/var&gt; &amp;hellip;)&lt;/code&gt; コンストラクトによって導入された名前にすることもできます。</target>
        </trans-unit>
        <trans-unit id="6121daf0fb6ccba2fa0baef96baeb4b4791c43e3" translate="yes" xml:space="preserve">
          <source>Likewise, &lt;code&gt;save-excursion&lt;/code&gt; does not restore window-buffer correspondences altered by functions such as &lt;code&gt;switch-to-buffer&lt;/code&gt;.</source>
          <target state="translated">同様に、 &lt;code&gt;save-excursion&lt;/code&gt; は、 &lt;code&gt;switch-to-buffer&lt;/code&gt; などの関数によって変更されたウィンドウとバッファーの対応を復元しません。</target>
        </trans-unit>
        <trans-unit id="86ef385a59e33cf483e8dded5ef79cc70f792473" translate="yes" xml:space="preserve">
          <source>Likewise, for handling the three types of remote contacts (requests, notifications, and responses to local requests), the transport implementation must arrange for the function &lt;code&gt;jsonrpc-connection-receive&lt;/code&gt; to be called after noticing a new JSONRPC message on the wire (whatever that &quot;wire&quot; may be).</source>
          <target state="translated">同様に、3種類のリモートコンタクト（リクエスト、通知、ローカルリクエストへの応答）を処理するために、トランスポート実装は、ネットワーク上の新しいJSONRPCメッセージに気付いた後に関数 &lt;code&gt;jsonrpc-connection-receive&lt;/code&gt; が呼び出されるように調整する必要があります（ 「ワイヤー」は）かもしれません。</target>
        </trans-unit>
        <trans-unit id="0f76d8acf641d878dd8f95ce0cf81e2a38f35161" translate="yes" xml:space="preserve">
          <source>Likewise, for scrolling up. The value, &lt;var&gt;f&lt;/var&gt;, specifies how far point should be placed from the bottom of the window; thus, as with &lt;code&gt;scroll-down-aggressively&lt;/code&gt;, a larger value scrolls more aggressively.</source>
          <target state="translated">同様に、上にスクロールします。値 &lt;var&gt;f&lt;/var&gt; は、ウィンドウの下部からポイントを配置する距離を指定します。したがって、 &lt;code&gt;scroll-down-aggressively&lt;/code&gt; 同様に、値が大きいほどアグレッシブにスクロールします。</target>
        </trans-unit>
        <trans-unit id="9173a7576ab9406f8159ed0ad696d18cf5a5de55" translate="yes" xml:space="preserve">
          <source>Likewise, to move to the end of the buffer, use:</source>
          <target state="translated">同様に、バッファの最後に移動するには、次のようにします。</target>
        </trans-unit>
        <trans-unit id="607bc37fe36f1db5f0eedea396370eb624c4e6e9" translate="yes" xml:space="preserve">
          <source>Likewise, you can suppress the warning for a specific use of a variable &lt;var&gt;variable&lt;/var&gt; by conditionalizing it on a &lt;code&gt;boundp&lt;/code&gt; test:</source>
          <target state="translated">同様に、 &lt;code&gt;boundp&lt;/code&gt; テストで条件付けすることにより、変数 &lt;var&gt;variable&lt;/var&gt; 特定の使用に対する警告を抑制することができます。</target>
        </trans-unit>
        <trans-unit id="6c62e4ab3dbe05f042adec9ffbc82e4cfec79087" translate="yes" xml:space="preserve">
          <source>Likewise, you can tell the compiler that a variable is defined using &lt;code&gt;defvar&lt;/code&gt; with no initial value. (Note that this marks the variable as special, i.e. dynamically bound, but only within the current lexical scope, or file if at top-level.) See &lt;a href=&quot;defining-variables#Defining-Variables&quot;&gt;Defining Variables&lt;/a&gt;.</source>
          <target state="translated">同様に、変数が初期値なしで &lt;code&gt;defvar&lt;/code&gt; を使用して定義されていることをコンパイラーに伝えることができます。（これにより、変数が特別なものとしてマークされます。つまり、動的にバインドされますが、現在の字句スコープ内、またはトップレベルの場合はファイル内にのみマークされます。）&lt;a href=&quot;defining-variables#Defining-Variables&quot;&gt;変数の定義を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="a7c04c64ed3f2a9374590c76c50d3b7f1b18e3da" translate="yes" xml:space="preserve">
          <source>Limitations</source>
          <target state="translated">Limitations</target>
        </trans-unit>
        <trans-unit id="4b7070c9a5c61e5ad4b904c57e944895659357fd" translate="yes" xml:space="preserve">
          <source>Line 1 &amp;ldquo;factors out&amp;rdquo; the &lt;var&gt;expval&lt;/var&gt; binding with &lt;code&gt;and&lt;/code&gt; and &lt;var&gt;symbol&lt;/var&gt; (in this case, &lt;code&gt;num&lt;/code&gt;). On line 2, &lt;code&gt;or&lt;/code&gt; begins in the same way as before, but instead of binding different symbols, uses &lt;code&gt;let&lt;/code&gt; twice (lines 3-4) to bind the same symbol &lt;code&gt;spin&lt;/code&gt; in both sub-patterns. The value of &lt;code&gt;spin&lt;/code&gt; distinguishes the sub-patterns. The body form references both symbols (line 5).</source>
          <target state="translated">1行目は、 &lt;code&gt;and&lt;/code&gt; および &lt;var&gt;symbol&lt;/var&gt; （この場合は &lt;code&gt;num&lt;/code&gt; ）を使用した &lt;var&gt;expval&lt;/var&gt; バインディングを「因数分解」します。2行目、 &lt;code&gt;or&lt;/code&gt; 以前と同じ方法で開始しますが、異なるシンボルをバインドする代わりに、 &lt;code&gt;let&lt;/code&gt; を2回（3〜4行目）使用して、両方のサブパターンで同じシンボル &lt;code&gt;spin&lt;/code&gt; をバインドします。 &lt;code&gt;spin&lt;/code&gt; の値はサブパターンを区別します。本文フォームは両方の記号を参照します（5行目）。</target>
        </trans-unit>
        <trans-unit id="ac3292c1d1364f8eb7cb1cb73de1b6c6819f007a" translate="yes" xml:space="preserve">
          <source>Line Height</source>
          <target state="translated">ライン高さ</target>
        </trans-unit>
        <trans-unit id="d19fdad54534f671523b6ba91167c0a2af1211e8" translate="yes" xml:space="preserve">
          <source>Link to a file; &lt;var&gt;file&lt;/var&gt; is a string which specifies the name of the file to visit with &lt;code&gt;find-file&lt;/code&gt; when the user invokes this link.</source>
          <target state="translated">ファイルへのリンク。 &lt;var&gt;file&lt;/var&gt; は、ユーザーがこのリンクを呼び出したときに &lt;code&gt;find-file&lt;/code&gt; でアクセスするファイルの名前を指定する文字列です。</target>
        </trans-unit>
        <trans-unit id="22480f8e64b100d948600dc541fbe87fd12cf0ad" translate="yes" xml:space="preserve">
          <source>Link to a web page; &lt;var&gt;url&lt;/var&gt; is a string which specifies the</source>
          <target state="translated">Webページへのリンク。 &lt;var&gt;url&lt;/var&gt; は、を指定する文字列です。</target>
        </trans-unit>
        <trans-unit id="6196a47a6fade23ecdb0cf7553070cfc1f4b67e9" translate="yes" xml:space="preserve">
          <source>Link to an Emacs Lisp library file; &lt;var&gt;library&lt;/var&gt; is a string which specifies the library name.</source>
          <target state="translated">EmacsLispライブラリファイルへのリンク。 &lt;var&gt;library&lt;/var&gt; は、ライブラリ名を指定する文字列です。</target>
        </trans-unit>
        <trans-unit id="bf66ba2266e555d89a7551e84cff8291754f5ac7" translate="yes" xml:space="preserve">
          <source>Link to an Info node; &lt;var&gt;info-node&lt;/var&gt; is a string which specifies the node name, as in &lt;code&gt;&quot;(emacs)Top&quot;&lt;/code&gt;. The link appears as &amp;lsquo;</source>
          <target state="translated">情報ノードへのリンク。 &lt;var&gt;info-node&lt;/var&gt; は、 &lt;code&gt;&quot;(emacs)Top&quot;&lt;/code&gt; ようにノード名を指定する文字列です。リンクは 'として表示されます</target>
        </trans-unit>
        <trans-unit id="0d9e752b2010ff1455dafc24361a10db156301e1" translate="yes" xml:space="preserve">
          <source>Link to another customization group. Invoking it creates a new customization buffer for &lt;var&gt;group&lt;/var&gt;.</source>
          <target state="translated">別のカスタマイズグループにリンクします。これを呼び出すと、 &lt;var&gt;group&lt;/var&gt; 新しいカスタマイズバッファが作成されます。</target>
        </trans-unit>
        <trans-unit id="8c73b95e12ba7b48400412835847598d2b4297a9" translate="yes" xml:space="preserve">
          <source>Link to the commentary section of a library; &lt;var&gt;library&lt;/var&gt; is a string which specifies the library name. See &lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/elisp/Library-Headers.html#Library-Headers&quot;&gt;Library Headers&lt;/a&gt;.</source>
          <target state="translated">ライブラリの解説セクションへのリンク。 &lt;var&gt;library&lt;/var&gt; は、ライブラリ名を指定する文字列です。&lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/elisp/Library-Headers.html#Library-Headers&quot;&gt;ライブラリヘッダーを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="0af47038ac7d2a137e5fb0843704c0a217bb19fe" translate="yes" xml:space="preserve">
          <source>Link to the documentation of a function; &lt;var&gt;function&lt;/var&gt; is a string which specifies the name of the function to describe with &lt;code&gt;describe-function&lt;/code&gt; when the user invokes this link.</source>
          <target state="translated">関数のドキュメントへのリンク。 &lt;var&gt;function&lt;/var&gt; は、ユーザーがこのリンクを呼び出したときに、 &lt;code&gt;describe-function&lt;/code&gt; で記述する関数の名前を指定する文字列です。</target>
        </trans-unit>
        <trans-unit id="6004ab0c17b773b21124a13a049a164c20095e5e" translate="yes" xml:space="preserve">
          <source>Link to the documentation of a variable; &lt;var&gt;variable&lt;/var&gt; is a string which specifies the name of the variable to describe with &lt;code&gt;describe-variable&lt;/code&gt; when the user invokes this link.</source>
          <target state="translated">変数のドキュメントへのリンク。 &lt;var&gt;variable&lt;/var&gt; は、ユーザーがこのリンクを呼び出したときに、 &lt;code&gt;describe-variable&lt;/code&gt; で記述する変数の名前を指定する文字列です。</target>
        </trans-unit>
        <trans-unit id="11b92badcf27d4b637951157332f5903e3a51659" translate="yes" xml:space="preserve">
          <source>Links to the preceding and following nodes in the chain.</source>
          <target state="translated">チェーンの前後のノードへのリンク。</target>
        </trans-unit>
        <trans-unit id="a7518b7d8d9c8b8ab73ff878b6f9268c622af85d" translate="yes" xml:space="preserve">
          <source>Lisp (LISt Processing language) was first developed in the late 1950s at the Massachusetts Institute of Technology for research in artificial intelligence. The great power of the Lisp language makes it ideal for other purposes as well, such as writing editing commands.</source>
          <target state="translated">Lisp(LISt処理言語)は、1950年代後半にマサチューセッツ工科大学で人工知能の研究のために最初に開発されました。Lisp言語の偉大なパワーにより、編集コマンドを書くなど、他の目的にも最適です。</target>
        </trans-unit>
        <trans-unit id="093033f3ad1baf1e960c639480ab203cf9eefb80" translate="yes" xml:space="preserve">
          <source>Lisp Data Types</source>
          <target state="translated">Lisp のデータ型</target>
        </trans-unit>
        <trans-unit id="070300a2d38e695ab5e6b29fde3619a0ca2a902e" translate="yes" xml:space="preserve">
          <source>Lisp History</source>
          <target state="translated">Lispの歴史</target>
        </trans-unit>
        <trans-unit id="a95ae648eeb012f8070dcb15c34e598757cc1931" translate="yes" xml:space="preserve">
          <source>Lisp Macro Evaluation</source>
          <target state="translated">Lisp マクロ評価</target>
        </trans-unit>
        <trans-unit id="0e410e687183103929a8880a76ed05ea40533c7d" translate="yes" xml:space="preserve">
          <source>Lisp code should use this function instead of &lt;code&gt;buffer-substring&lt;/code&gt;, &lt;code&gt;buffer-substring-no-properties&lt;/code&gt;, or &lt;code&gt;delete-and-extract-region&lt;/code&gt; when copying into user-accessible data structures such as the kill-ring, X clipboard, and registers. Major and minor modes can modify &lt;code&gt;filter-buffer-substring-function&lt;/code&gt; to alter such text as it is copied out of the buffer.</source>
          <target state="translated">Lispコードは、kill-ring、Xクリップボード、レジスタなどのユーザーがアクセスできるデータ構造にコピーするときに、 &lt;code&gt;buffer-substring&lt;/code&gt; 、 &lt;code&gt;buffer-substring-no-properties&lt;/code&gt; 、または &lt;code&gt;delete-and-extract-region&lt;/code&gt; の代わりにこの関数を使用する必要があります。メジャーモードとマイナーモードでは、 &lt;code&gt;filter-buffer-substring-function&lt;/code&gt; を変更して、バッファーからコピーされるテキストを変更できます。</target>
        </trans-unit>
        <trans-unit id="8fc5a9e95ef7885a0b7599ee4ecbaf851f92a696" translate="yes" xml:space="preserve">
          <source>Lisp expression:</source>
          <target state="translated">Lisp表現。</target>
        </trans-unit>
        <trans-unit id="9a49e6726f59e36c724f79f5510e315b850a89a9" translate="yes" xml:space="preserve">
          <source>Lisp expressions for defining functions.</source>
          <target state="translated">関数を定義するためのLisp式。</target>
        </trans-unit>
        <trans-unit id="04c1aa53f54116c8c2b6559a2f7db15e028716fc" translate="yes" xml:space="preserve">
          <source>Lisp functions are executable code, just like functions in other programming languages. In Lisp, unlike most languages, functions are also Lisp objects. A non-compiled function in Lisp is a lambda expression: that is, a list whose first element is the symbol &lt;code&gt;lambda&lt;/code&gt; (see &lt;a href=&quot;lambda-expressions#Lambda-Expressions&quot;&gt;Lambda Expressions&lt;/a&gt;).</source>
          <target state="translated">Lisp関数は、他のプログラミング言語の関数と同じように、実行可能コードです。Lispでは、ほとんどの言語とは異なり、関数もLispオブジェクトです。Lispでコンパイルされていない関数はラムダ式です。つまり、最初の要素がシンボル &lt;code&gt;lambda&lt;/code&gt; であるリストです（&lt;a href=&quot;lambda-expressions#Lambda-Expressions&quot;&gt;ラムダ式を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="48b47c25285835ef4229cdb4249b0b97f8b61318" translate="yes" xml:space="preserve">
          <source>Lisp functions vs. primitives; terminology.</source>
          <target state="translated">Lisp関数とプリミティブ、用語。</target>
        </trans-unit>
        <trans-unit id="b7f5a1d65c1925ee62d77c064437066c7e060879" translate="yes" xml:space="preserve">
          <source>Lisp is unlike many other languages in that its objects are &lt;em&gt;self-typing&lt;/em&gt;: the primitive type of each object is implicit in the object itself. For example, if an object is a vector, nothing can treat it as a number; Lisp knows it is a vector, not a number.</source>
          <target state="translated">Lispは、そのオブジェクトが&lt;em&gt;自己型付け&lt;/em&gt;であるという点で他の多くの言語とは異なり&lt;em&gt;ます&lt;/em&gt;。各オブジェクトのプリミティブ型は、オブジェクト自体に暗黙的に含まれています。たとえば、オブジェクトがベクトルの場合、それを数値として扱うことはできません。Lispは、それが数値ではなくベクトルであることを知っています。</target>
        </trans-unit>
        <trans-unit id="c1a44c55700efa37938155d19ec6cee2495bb14b" translate="yes" xml:space="preserve">
          <source>Lisp macro objects are usually defined with the built-in &lt;code&gt;defmacro&lt;/code&gt; macro, but any list that begins with &lt;code&gt;macro&lt;/code&gt; is a macro as far as Emacs is concerned. See &lt;a href=&quot;macros#Macros&quot;&gt;Macros&lt;/a&gt;, for an explanation of how to write a macro.</source>
          <target state="translated">Lispのマクロオブジェクトは、通常、ビルトインで定義されている &lt;code&gt;defmacro&lt;/code&gt; マクロが、で始まる任意のリスト &lt;code&gt;macro&lt;/code&gt; Emacsを懸念している限りマクロです。&lt;a href=&quot;macros#Macros&quot;&gt;マクロの&lt;/a&gt;記述方法の説明については、マクロを参照してください。</target>
        </trans-unit>
        <trans-unit id="d9a34bc15715c9484c3c6d58e0cfbe37f7e5fc6d" translate="yes" xml:space="preserve">
          <source>Lisp objects can refer to themselves. Printing a self-referential object in the normal way would require an infinite amount of text, and the attempt could cause infinite recursion. Emacs detects such recursion and prints &amp;lsquo;</source>
          <target state="translated">Lispオブジェクトはそれ自体を参照できます。通常の方法で自己参照オブジェクトを印刷するには、無限の量のテキストが必要になり、その試みによって無限の再帰が発生する可能性があります。Emacsはそのような再帰を検出して出力します '</target>
        </trans-unit>
        <trans-unit id="38cb61435a14d84b4e828f9b902cd652a45bb04e" translate="yes" xml:space="preserve">
          <source>Lisp packages that load files of customizations, or any other sort of user profile, should obey this variable in deciding where to find it. They should load the profile of the user name found in this variable. If &lt;code&gt;init-file-user&lt;/code&gt; is &lt;code&gt;nil&lt;/code&gt;, meaning that the &amp;lsquo;</source>
          <target state="translated">カスタマイズのファイルまたは他の種類のユーザープロファイルをロードするLispパッケージは、それを見つける場所を決定する際にこの変数に従う必要があります。この変数で見つかったユーザー名のプロファイルをロードする必要があります。場合 &lt;code&gt;init-file-user&lt;/code&gt; ある &lt;code&gt;nil&lt;/code&gt; 'という意味</target>
        </trans-unit>
        <trans-unit id="d96f39c620264ffeb78deb4cecb038146b82aebf" translate="yes" xml:space="preserve">
          <source>Lisp primitives are Lisp functions implemented in C. The details of interfacing the C function so that Lisp can call it are handled by a few C macros. The only way to really understand how to write new C code is to read the source, but we can explain some things here.</source>
          <target state="translated">Lispプリミティブとは、C言語で実装されたLisp関数のことです。C言語の関数をLispが呼び出せるようにインターフェイスする詳細は、いくつかのC言語のマクロで処理されます。新しいC言語のコードの書き方を本当に理解するには、ソースを読むしかありませんが、ここではいくつかのことを説明します。</target>
        </trans-unit>
        <trans-unit id="a7c856d0fff164a7f1d6af49754ec372f5744350" translate="yes" xml:space="preserve">
          <source>Lisp programs can also directly display a bitmap in the left or right fringe, by using a &lt;code&gt;display&lt;/code&gt; property for one of the characters appearing in the line (see &lt;a href=&quot;other-display-specs#Other-Display-Specs&quot;&gt;Other Display Specs&lt;/a&gt;). Such a display specification has the form</source>
          <target state="translated">Lispプログラムは、行に &lt;code&gt;display&lt;/code&gt; される文字の1つにdisplayプロパティを使用することにより、左または右のフリンジにビットマップを直接表示することもできます（&lt;a href=&quot;other-display-specs#Other-Display-Specs&quot;&gt;その他の表示仕様を&lt;/a&gt;参照）。このような表示仕様は、</target>
        </trans-unit>
        <trans-unit id="70a68430b5ee6f5c63e455e63af6968f951de310" translate="yes" xml:space="preserve">
          <source>Lisp programs can listen for connections by creating network servers. A network server is also represented by a kind of process object, but unlike a network connection, the network server never transfers data itself. When it receives a connection request, it creates a new network connection to represent the connection just made. (The network connection inherits certain information, including the process plist, from the server.) The network server then goes back to listening for more connection requests.</source>
          <target state="translated">Lispプログラムは、ネットワークサーバを作成することで、接続をリッスンすることができます。ネットワークサーバはプロセスオブジェクトの一種でもありますが、ネットワーク接続とは異なり、ネットワークサーバはそれ自体でデータを転送することはありません。ネットワークサーバは接続要求を受け取ると、新しいネットワーク接続を作成して、その接続を表現します(このネットワーク接続は、ネットワーク接続を含む特定の情報を継承します)。(ネットワーク接続は、プロセスのplistを含む特定の情報をサーバから継承します)。ネットワーク・サーバは、その後、さらなる接続要求のためのリッスンに戻ります。</target>
        </trans-unit>
        <trans-unit id="eb25bc2c53938daa0a10ceee8670460ef857ca05" translate="yes" xml:space="preserve">
          <source>Lisp programs can set &lt;code&gt;transient-mark-mode&lt;/code&gt; to non-&lt;code&gt;nil&lt;/code&gt;, non-&lt;code&gt;t&lt;/code&gt; values to enable Transient Mark mode temporarily. If the value is &lt;code&gt;lambda&lt;/code&gt;, Transient Mark mode is automatically turned off after any action, such as buffer modification, that would normally deactivate the mark. If the value is &lt;code&gt;(only&amp;nbsp;.&amp;nbsp;&lt;var&gt;oldval&lt;/var&gt;)&lt;/code&gt;, then &lt;code&gt;transient-mark-mode&lt;/code&gt; is set to the value &lt;var&gt;oldval&lt;/var&gt; after any subsequent command that moves point and is not shift-translated (see &lt;a href=&quot;key-sequence-input#Key-Sequence-Input&quot;&gt;shift-translation&lt;/a&gt;), or after any other action that would normally deactivate the mark.</source>
          <target state="translated">Lispプログラムは &lt;code&gt;transient-mark-mode&lt;/code&gt; をnon - &lt;code&gt;nil&lt;/code&gt; 、non - &lt;code&gt;t&lt;/code&gt; 値に設定して、TransientMarkモードを一時的に有効にすることができます。値が &lt;code&gt;lambda&lt;/code&gt; 場合、通常はマークを非アクティブ化するバッファの変更などのアクションの後に、トランジェントマークモードが自動的にオフになります。値が &lt;code&gt;(only&amp;nbsp;.&amp;nbsp;&lt;var&gt;oldval&lt;/var&gt;)&lt;/code&gt; 場合、 &lt;code&gt;transient-mark-mode&lt;/code&gt; は、ポイントを移動してシフト変換されない後続のコマンド（&lt;a href=&quot;key-sequence-input#Key-Sequence-Input&quot;&gt;shift-translationを&lt;/a&gt;参照）の後、または通常のアクションの後、値 &lt;var&gt;oldval&lt;/var&gt; に設定されます。マークを無効にします。</target>
        </trans-unit>
        <trans-unit id="3aa64bd9d4a4db969c3909de23bb8e7a8d6e781d" translate="yes" xml:space="preserve">
          <source>Lisp programs can switch frames temporarily by calling the function &lt;code&gt;select-frame&lt;/code&gt;. This does not alter the window system&amp;rsquo;s concept of focus; rather, it escapes from the window manager&amp;rsquo;s control until that control is somehow reasserted.</source>
          <target state="translated">Lispプログラムは、関数 &lt;code&gt;select-frame&lt;/code&gt; を呼び出すことにより、フレームを一時的に切り替えることができます。これは、ウィンドウシステムのフォーカスの概念を変更しません。むしろ、ウィンドウマネージャーのコントロールから、そのコントロールが何らかの形で再度アサートされるまでエスケープします。</target>
        </trans-unit>
        <trans-unit id="e6266b236aa3407b98b48107324e801de224e6ad" translate="yes" xml:space="preserve">
          <source>Lisp programs must be prepared that user customizations may cause buffers to get displayed in an unexpected way. They should never assume in their subsequent behavior, that the buffer has been shown precisely the way they asked for in the &lt;var&gt;action&lt;/var&gt; argument of &lt;code&gt;display-buffer&lt;/code&gt;.</source>
          <target state="translated">Lispプログラムは、ユーザーのカスタマイズによってバッファーが予期しない方法で表示される可能性があるように準備する必要があります。その後の動作で、バッファが &lt;code&gt;display-buffer&lt;/code&gt; の &lt;var&gt;action&lt;/var&gt; 引数で要求されたとおりに正確に表示されていると想定してはなりません。</target>
        </trans-unit>
        <trans-unit id="6612695190dbf10d24bd3737b61d06d8dee5099f" translate="yes" xml:space="preserve">
          <source>Lisp programs should &lt;em&gt;not&lt;/em&gt; rely on hash codes being preserved between Emacs sessions, as the implementation of the hash functions uses some details of the object storage that can change between sessions and between different architectures.</source>
          <target state="translated">ハッシュ関数の実装はセッション間および異なるアーキテクチャ間で変更される可能性のあるオブジェクトストレージの詳細を使用するため、LispプログラムはEmacsセッション間で保持されているハッシュコードに依存すべきではあり&lt;em&gt;ません&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="430b9fa1fd5ba568a813aa706678d439215cf675" translate="yes" xml:space="preserve">
          <source>Lisp programs sometimes need to run a shell and give it a command that contains file names that were specified by the user. These programs ought to be able to support any valid file name. But the shell gives special treatment to certain characters, and if these characters occur in the file name, they will confuse the shell. To handle these characters, use the function &lt;code&gt;shell-quote-argument&lt;/code&gt;:</source>
          <target state="translated">Lispプログラムは、シェルを実行して、ユーザーが指定したファイル名を含むコマンドをシェルに与える必要がある場合があります。これらのプログラムは、任意の有効なファイル名をサポートできる必要があります。ただし、シェルは特定の文字に特別な処理を行い、これらの文字がファイル名に含まれていると、シェルが混乱します。これらの文字を処理するには、関数 &lt;code&gt;shell-quote-argument&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="cfca57d0cb6702725bd47fe954b2d8aad7ece85e" translate="yes" xml:space="preserve">
          <source>Lisp representation for character display fonts.</source>
          <target state="translated">文字表示フォントのLisp表現。</target>
        </trans-unit>
        <trans-unit id="b7904939c664c0654e4069d00a64b5fe14da5051" translate="yes" xml:space="preserve">
          <source>List contains a loop</source>
          <target state="translated">リストにはループが含まれています。</target>
        </trans-unit>
        <trans-unit id="3e55737f21b8d4e744eb6aa465bb3fe3e505747a" translate="yes" xml:space="preserve">
          <source>List of frame parameters for window systems.</source>
          <target state="translated">ウィンドウシステムのフレームパラメータの一覧です。</target>
        </trans-unit>
        <trans-unit id="c1aa03bb883bbb60cce2d139f90d3fdb47174dc3" translate="yes" xml:space="preserve">
          <source>List of frames that this physical monitor dominates (see below).</source>
          <target state="translated">この物理モニタが支配するフレームのリスト(下記参照)。</target>
        </trans-unit>
        <trans-unit id="5255158e8775a2ebbae84ae901ff359ddfa1d8dd" translate="yes" xml:space="preserve">
          <source>List of set bits in &lt;var&gt;len&lt;/var&gt; bytes. The bytes are taken in big endian order and the bits are numbered starting with &lt;code&gt;8 *
&lt;var&gt;len&lt;/var&gt; - 1&lt;/code&gt; and ending with zero. For example: &lt;code&gt;bits
2&lt;/code&gt; unpacks &lt;code&gt;#x28&lt;/code&gt;&lt;code&gt;#x1c&lt;/code&gt; to &lt;code&gt;(2 3 4 11 13)&lt;/code&gt; and &lt;code&gt;#x1c&lt;/code&gt;&lt;code&gt;#x28&lt;/code&gt; to &lt;code&gt;(3 5 10 11 12)&lt;/code&gt;.</source>
          <target state="translated">&lt;var&gt;len&lt;/var&gt; バイト単位のセットビットのリスト。バイトはビッグエンディアンの順序で取得され、ビットには &lt;code&gt;8 * &lt;var&gt;len&lt;/var&gt; - 1&lt;/code&gt; で始まり、ゼロで終わる番号が付けられます。例えば： &lt;code&gt;bits 2&lt;/code&gt; アンパック &lt;code&gt;#x28&lt;/code&gt; &lt;code&gt;#x1c&lt;/code&gt; に &lt;code&gt;(2 3 4 11 13)&lt;/code&gt; 及び &lt;code&gt;#x1c&lt;/code&gt; &lt;code&gt;#x28&lt;/code&gt; に &lt;code&gt;(3 5 10 11 12)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b9849ac255593e53a8f74892aeb3c6148e2227ef" translate="yes" xml:space="preserve">
          <source>List of some standard error symbols.</source>
          <target state="translated">いくつかの標準的なエラーシンボルのリストです。</target>
        </trans-unit>
        <trans-unit id="dd46ad2b3ec4905179728f23e75392d7cd255398" translate="yes" xml:space="preserve">
          <source>List of some standard hook variables.</source>
          <target state="translated">いくつかの標準的なフック変数のリスト。</target>
        </trans-unit>
        <trans-unit id="684686c9485926fd7bb605cb2b4b6557c3c1c8f3" translate="yes" xml:space="preserve">
          <source>List of some standard keymaps.</source>
          <target state="translated">いくつかの標準的なキーマップの一覧です。</target>
        </trans-unit>
        <trans-unit id="57c9502a7d7d48fd4a86b45fefb2b163491c3ae1" translate="yes" xml:space="preserve">
          <source>Lists</source>
          <target state="translated">Lists</target>
        </trans-unit>
        <trans-unit id="20dd55e92ceb2d7f29cba2ee3c74cacc30b7d09c" translate="yes" xml:space="preserve">
          <source>Lists and Cons Cells</source>
          <target state="translated">リストとコンサセル</target>
        </trans-unit>
        <trans-unit id="95e6ae4511e2076e5ec8acc94916a3a73b48a317" translate="yes" xml:space="preserve">
          <source>Lists are the most commonly-used sequences. A list can hold elements of any type, and its length can be easily changed by adding or removing elements. See the next subsection for more about lists.</source>
          <target state="translated">リストは最も一般的に使用されるシーケンスです。リストは任意の型の要素を持つことができ、その長さは要素を追加したり削除したりすることで簡単に変えることができます。リストについては次のサブセクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="0deb648df977bd4b3bf1acb18dcca54edca072ea" translate="yes" xml:space="preserve">
          <source>Lists in Lisp are not a primitive data type; they are built up from &lt;em&gt;cons cells&lt;/em&gt; (see &lt;a href=&quot;cons-cell-type#Cons-Cell-Type&quot;&gt;Cons Cell Type&lt;/a&gt;). A cons cell is a data object that represents an ordered pair. That is, it has two slots, and each slot &lt;em&gt;holds&lt;/em&gt;, or &lt;em&gt;refers to&lt;/em&gt;, some Lisp object. One slot is known as the &lt;small&gt;CAR&lt;/small&gt;, and the other is known as the &lt;small&gt;CDR&lt;/small&gt;. (These names are traditional; see &lt;a href=&quot;cons-cell-type#Cons-Cell-Type&quot;&gt;Cons Cell Type&lt;/a&gt;.) &lt;small&gt;CDR&lt;/small&gt; is pronounced &amp;ldquo;could-er&amp;rdquo;.</source>
          <target state="translated">Lispのリストはプリミティブデータ型ではありません。彼らはから構築される&lt;em&gt;コンス・セル&lt;/em&gt;（参照&lt;a href=&quot;cons-cell-type#Cons-Cell-Type&quot;&gt;コンスセルタイプ&lt;/a&gt;）。 consセルは、順序対を表すデータオブジェクトです。つまり、2つのスロットがあり、各スロット&lt;em&gt;は&lt;/em&gt;Lispオブジェクト&lt;em&gt;を&lt;/em&gt;&lt;em&gt;保持&lt;/em&gt;または&lt;em&gt;参照し&lt;/em&gt;ます。 1つのスロットは&lt;small&gt;CAR&lt;/small&gt;と呼ばれ、もう1つのスロットは&lt;small&gt;CDR&lt;/small&gt;と呼ばれます。 （これらの名前は伝統的なものです。&lt;a href=&quot;cons-cell-type#Cons-Cell-Type&quot;&gt;短所セルタイプを&lt;/a&gt;参照してください。）&lt;small&gt;CDR&lt;/small&gt;は「could-er」と発音されます。</target>
        </trans-unit>
        <trans-unit id="9099e49f5a4614e80a7fbc32b3b32e0c649d2edd" translate="yes" xml:space="preserve">
          <source>Lists, cons cells, and related functions.</source>
          <target state="translated">リスト、コンセル、関連機能。</target>
        </trans-unit>
        <trans-unit id="9e7aaaa88e5ccb737ed89b621f362caa5d1c2f65" translate="yes" xml:space="preserve">
          <source>Lists, strings and the other array types also share important similarities. For example, all have a length &lt;var&gt;l&lt;/var&gt;, and all have elements which can be indexed from zero to &lt;var&gt;l&lt;/var&gt; minus one. Several functions, called sequence functions, accept any kind of sequence. For example, the function &lt;code&gt;length&lt;/code&gt; reports the length of any kind of sequence. See &lt;a href=&quot;sequences-arrays-vectors#Sequences-Arrays-Vectors&quot;&gt;Sequences Arrays Vectors&lt;/a&gt;.</source>
          <target state="translated">リスト、文字列、その他の配列タイプも重要な類似点を共有しています。たとえば、すべての長さは &lt;var&gt;l&lt;/var&gt; であり、すべてに0から &lt;var&gt;l&lt;/var&gt; から1を引いた値までインデックスを付けることができる要素があります。シーケンス関数と呼ばれるいくつかの関数は、あらゆる種類のシーケンスを受け入れます。たとえば、関数の &lt;code&gt;length&lt;/code&gt; は、あらゆる種類のシーケンスの長さを報告します。&lt;a href=&quot;sequences-arrays-vectors#Sequences-Arrays-Vectors&quot;&gt;シーケンス配列ベクトルを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="c9ce88cec200da5730917cabea833810578d4d60" translate="yes" xml:space="preserve">
          <source>Lists, strings and vectors are called sequences. Certain functions act on any kind of sequence. The description of vectors is here as well.</source>
          <target state="translated">リスト,文字列,ベクトルをシーケンスと呼びます.ある種の関数は,どのような種類のシーケンスに対しても動作します.ベクトルの説明はこちらにもあります。</target>
        </trans-unit>
        <trans-unit id="44705636b815ace7e561a7446a758c35f2dedad2" translate="yes" xml:space="preserve">
          <source>Literal text</source>
          <target state="translated">リテラルテキスト</target>
        </trans-unit>
        <trans-unit id="7561f82ae5b90f8428d596aba3af87144f94e678" translate="yes" xml:space="preserve">
          <source>Literal unprintable characters in strings.</source>
          <target state="translated">文字列の中のリテラルで印刷不可能な文字。</target>
        </trans-unit>
        <trans-unit id="c7ba7dcf662374aafe652b03d75cb8f6024519d9" translate="yes" xml:space="preserve">
          <source>Literals</source>
          <target state="translated">Literals</target>
        </trans-unit>
        <trans-unit id="bc6cc4663c2f684119734fdc2abb9c21336632c5" translate="yes" xml:space="preserve">
          <source>Living With a Weak Parser</source>
          <target state="translated">弱いパーサーとの生活</target>
        </trans-unit>
        <trans-unit id="7a611ffe36f69e8659eea0f180752be7e04730b8" translate="yes" xml:space="preserve">
          <source>Load Suffixes</source>
          <target state="translated">接尾辞の読み込み</target>
        </trans-unit>
        <trans-unit id="f9ad7c8d6bf23f4bd156133162b128490e0c6198" translate="yes" xml:space="preserve">
          <source>Load file &lt;var&gt;file&lt;/var&gt; (a string) before displaying this customization item (see &lt;a href=&quot;loading#Loading&quot;&gt;Loading&lt;/a&gt;). Loading is done with &lt;code&gt;load&lt;/code&gt;, and only if the file is not already loaded.</source>
          <target state="translated">このカスタマイズ項目を表示する前に、ファイル &lt;var&gt;file&lt;/var&gt; （文字列）を&lt;a href=&quot;loading#Loading&quot;&gt;ロードし&lt;/a&gt;ます（ロードを参照）。ロードは、ファイルがまだロードされていない場合にのみ、 &lt;code&gt;load&lt;/code&gt; を使用して実行されます。</target>
        </trans-unit>
        <trans-unit id="1bd4cd17a8147cc5cd6d3f97fd6644f944793104" translate="yes" xml:space="preserve">
          <source>Load the files with</source>
          <target state="translated">でファイルをロードします。</target>
        </trans-unit>
        <trans-unit id="883657b0663d05cb81a7f624698cafeec52f6b73" translate="yes" xml:space="preserve">
          <source>Loadable modules in Emacs are enabled by using the</source>
          <target state="translated">Emacsでロード可能なモジュールは</target>
        </trans-unit>
        <trans-unit id="8f26c6520d61588a9757bc182157c4497628e871" translate="yes" xml:space="preserve">
          <source>Loading</source>
          <target state="translated">Loading</target>
        </trans-unit>
        <trans-unit id="0f84e4833a47ae5b5d6c641ba5839ef1259c6482" translate="yes" xml:space="preserve">
          <source>Loading Non-ASCII Characters</source>
          <target state="translated">非ASCII文字の読み込み</target>
        </trans-unit>
        <trans-unit id="a881ef8a5e395de040b2cde053e1fa0f6d614659" translate="yes" xml:space="preserve">
          <source>Loading a file of Lisp code means bringing its contents into the Lisp environment in the form of Lisp objects. Emacs finds and opens the file, reads the text, evaluates each form, and then closes the file. Such a file is also called a &lt;em&gt;Lisp library&lt;/em&gt;.</source>
          <target state="translated">Lispコードのファイルをロードするということは、その内容をLispオブジェクトの形でLisp環境に持ち込むことを意味します。Emacsはファイルを見つけて開き、テキストを読み取り、各フォームを評価してからファイルを閉じます。このようなファイルは、&lt;em&gt;Lispライブラリ&lt;/em&gt;とも呼ばれ&lt;em&gt;ます&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="904a9f782b30e1a58668b2173bc0b744a768d9fa" translate="yes" xml:space="preserve">
          <source>Loading a library if it isn&amp;rsquo;t already loaded.</source>
          <target state="translated">ライブラリがまだロードされていない場合は、ライブラリをロードします。</target>
        </trans-unit>
        <trans-unit id="963c158ee7d6cc3ddeaacac290e282697c29cc98" translate="yes" xml:space="preserve">
          <source>Loading foo...</source>
          <target state="translated">ローディング中のfoo...</target>
        </trans-unit>
        <trans-unit id="90227054d0c4071b95dc470817610b24dd4cae6b" translate="yes" xml:space="preserve">
          <source>Loading foo...done</source>
          <target state="translated">foo...done の読み込み</target>
        </trans-unit>
        <trans-unit id="ff5148d6cff2251fbb44fa24ac71e87831f6949a" translate="yes" xml:space="preserve">
          <source>Local Variables</source>
          <target state="translated">局所変数</target>
        </trans-unit>
        <trans-unit id="1c80e104177d7b78185bb1b8711d3cbd2a0da9a4" translate="yes" xml:space="preserve">
          <source>Local Variables in Macro Expansions</source>
          <target state="translated">マクロ展開の局所変数</target>
        </trans-unit>
        <trans-unit id="81e25eae5238b0d1e80b489db0e70db5d36fa19f" translate="yes" xml:space="preserve">
          <source>Local variable bindings in the expansion require special care.</source>
          <target state="translated">拡張でのローカル変数バインディングには特別な注意が必要です。</target>
        </trans-unit>
        <trans-unit id="779b54ae3ad4227df0c4817bd5cf967d7971b9a8" translate="yes" xml:space="preserve">
          <source>Local variables common for remote connections.</source>
          <target state="translated">リモート接続で共通のローカル変数。</target>
        </trans-unit>
        <trans-unit id="7f188a87ee03e71d60616a4c96885d1c0b74f9c8" translate="yes" xml:space="preserve">
          <source>Local variables common to all files in a directory.</source>
          <target state="translated">ディレクトリ内のすべてのファイルに共通のローカル変数。</target>
        </trans-unit>
        <trans-unit id="a222060e32289bf6910ac4a07a10733be500bd99" translate="yes" xml:space="preserve">
          <source>Locales</source>
          <target state="translated">Locales</target>
        </trans-unit>
        <trans-unit id="c40c47188d80c7c01d1f14ab9115e42654014c62" translate="yes" xml:space="preserve">
          <source>Locating Files in Standard Places</source>
          <target state="translated">標準的な場所にファイルを配置する</target>
        </trans-unit>
        <trans-unit id="ca96bd07c69909b5097860baf11cb9da67a0b932" translate="yes" xml:space="preserve">
          <source>Locking and unlocking files, to prevent simultaneous editing by two people.</source>
          <target state="translated">ファイルのロックとロック解除を行い、2人同時編集を防ぐ。</target>
        </trans-unit>
        <trans-unit id="19b48b850743ec74aaf2ba7f74397470f9322fb8" translate="yes" xml:space="preserve">
          <source>Logging Messages in *Messages*</source>
          <target state="translated">メッセージ*でメッセージをログに記録する</target>
        </trans-unit>
        <trans-unit id="f992fcdf326b78d500b906f947284b63f7afb915" translate="yes" xml:space="preserve">
          <source>Logical and, or, not, shifting.</source>
          <target state="translated">論理的に、あるいは、そうではなくて、ずらしていく。</target>
        </trans-unit>
        <trans-unit id="5d5f34745d0c565923c156fa463ee88aafc88956" translate="yes" xml:space="preserve">
          <source>Long description</source>
          <target state="translated">長い説明</target>
        </trans-unit>
        <trans-unit id="1601ce5c57967aca4f1582458112c97ae2082434" translate="yes" xml:space="preserve">
          <source>Looking Up Fonts</source>
          <target state="translated">フォントを探す</target>
        </trans-unit>
        <trans-unit id="d63629c4a0bb6a63de031bf229ac03c609809d09" translate="yes" xml:space="preserve">
          <source>Looking Up and Expanding Abbreviations</source>
          <target state="translated">略語の調べ方と展開</target>
        </trans-unit>
        <trans-unit id="bc0e6625c124c4eb5bd0fcd56ac755373c3fb4f2" translate="yes" xml:space="preserve">
          <source>Looking at the properties of one character.</source>
          <target state="translated">一文字の特性を見て</target>
        </trans-unit>
        <trans-unit id="178121740f45b5d6e7facf9d96018d909c21354f" translate="yes" xml:space="preserve">
          <source>Looking through all keymaps, for printing help.</source>
          <target state="translated">すべてのキーマップに目を通すと、印刷の助けになる。</target>
        </trans-unit>
        <trans-unit id="851bbb5519ca80dce271e99e2231072e5a4a3479" translate="yes" xml:space="preserve">
          <source>Looking up the names of available fonts and information about them.</source>
          <target state="translated">利用可能なフォントの名前や情報を調べることができます。</target>
        </trans-unit>
        <trans-unit id="68ff0bd1cbaecfae7d37b0d97386effbf3fba27d" translate="yes" xml:space="preserve">
          <source>Lookup in a hash table is extremely fast for large tables&amp;mdash;in fact, the time required is essentially &lt;em&gt;independent&lt;/em&gt; of how many elements are stored in the table. For smaller tables (a few tens of elements) alists may still be faster because hash tables have a more-or-less constant overhead.</source>
          <target state="translated">ハッシュテーブルでのルックアップは、大きなテーブルでは非常に高速です。実際、必要な時間は、テーブルに格納されている要素の数とは本質的に&lt;em&gt;無関係&lt;/em&gt;です。小さいテーブル（数十の要素）の場合、ハッシュテーブルには多かれ少なかれ一定のオーバーヘッドがあるため、アリストはさらに高速になる可能性があります。</target>
        </trans-unit>
        <trans-unit id="f5253ec82559052e87ceaff557957647ac4e6a68" translate="yes" xml:space="preserve">
          <source>Low-Level Font Representation</source>
          <target state="translated">低レベルのフォント表現</target>
        </trans-unit>
        <trans-unit id="323f212d3828fcc314985cd1386476951f05a2ee" translate="yes" xml:space="preserve">
          <source>Low-Level Kill Ring</source>
          <target state="translated">低レベルキルリング</target>
        </trans-unit>
        <trans-unit id="cd3b0d6e2fa4c08068b3e57e488ba7e247c660c5" translate="yes" xml:space="preserve">
          <source>Low-Level Network Access</source>
          <target state="translated">低レベルネットワークアクセス</target>
        </trans-unit>
        <trans-unit id="cbddb05b874ab89fa507c4d8957fdf31bf1114b7" translate="yes" xml:space="preserve">
          <source>Low-Level Parsing</source>
          <target state="translated">低レベル解析</target>
        </trans-unit>
        <trans-unit id="4259b3253a806353d7c8d6ae41622a4465d4b63c" translate="yes" xml:space="preserve">
          <source>Low-level functions for completing strings.</source>
          <target state="translated">文字列を完成させるための低レベルの関数。</target>
        </trans-unit>
        <trans-unit id="e3fc395679fd313e5a3b121bd0f61b1e24d51f49" translate="yes" xml:space="preserve">
          <source>Lower-level but more general function to create connections and servers.</source>
          <target state="translated">下位レベルだが、接続やサーバーを作成するための一般的な機能。</target>
        </trans-unit>
        <trans-unit id="412965d373e39e0acf2e9d34874530d49b3e8f45" translate="yes" xml:space="preserve">
          <source>Lower-level subroutines that they use.</source>
          <target state="translated">彼らが使用する下位レベルのサブルーチン。</target>
        </trans-unit>
        <trans-unit id="c63ae6dd4fc9f9dda66970e827d13f7c73fe841c" translate="yes" xml:space="preserve">
          <source>M</source>
          <target state="translated">M</target>
        </trans-unit>
        <trans-unit id="1380c1040fe5f22f86cfa0fff612c7bb977dc760" translate="yes" xml:space="preserve">
          <source>M-</source>
          <target state="translated">M-</target>
        </trans-unit>
        <trans-unit id="37a5c39dff07a52dd3087c214ce1f8d1b29f0a8c" translate="yes" xml:space="preserve">
          <source>M-&amp;lt;</source>
          <target state="translated">M-&amp;lt;</target>
        </trans-unit>
        <trans-unit id="f56099d279d3bbbe13433ab2b41f59ecda17c1b5" translate="yes" xml:space="preserve">
          <source>M--</source>
          <target state="translated">M--</target>
        </trans-unit>
        <trans-unit id="3c8556ad1d538e0b24776b2eb4aadd97384f92be" translate="yes" xml:space="preserve">
          <source>M-.</source>
          <target state="translated">M-.</target>
        </trans-unit>
        <trans-unit id="195ce7fc591804e0719a61c0fa3a7301aae4a144" translate="yes" xml:space="preserve">
          <source>M-:</source>
          <target state="translated">M-:</target>
        </trans-unit>
        <trans-unit id="d63f0fe93faad24b66a76a47ccdc11cdad6f0669" translate="yes" xml:space="preserve">
          <source>M-: &lt;var&gt;exp&lt;/var&gt;RET</source>
          <target state="translated">M-： &lt;var&gt;exp&lt;/var&gt; RET</target>
        </trans-unit>
        <trans-unit id="306f4c5a0e32d8e206ce9f2acecfdbbd30b93ebd" translate="yes" xml:space="preserve">
          <source>M-A</source>
          <target state="translated">M-A</target>
        </trans-unit>
        <trans-unit id="6951aed8ad5e7255f081050661207da69a62bceb" translate="yes" xml:space="preserve">
          <source>M-F1</source>
          <target state="translated">M-F1</target>
        </trans-unit>
        <trans-unit id="d5deac9a11e75cdf2221fc4ccab2ecbdf3ce7f5e" translate="yes" xml:space="preserve">
          <source>M-O</source>
          <target state="translated">M-O</target>
        </trans-unit>
        <trans-unit id="582c231510f999e4090021d4c4d24dd9d1083ddc" translate="yes" xml:space="preserve">
          <source>M-TAB</source>
          <target state="translated">M-TAB</target>
        </trans-unit>
        <trans-unit id="6e83342732a657a8dfe6c872ef3fa40bd7ab6c1d" translate="yes" xml:space="preserve">
          <source>M-[</source>
          <target state="translated">M-[</target>
        </trans-unit>
        <trans-unit id="c32ec53effd66388f8d3ebba5bbdc052dda00483" translate="yes" xml:space="preserve">
          <source>M-a</source>
          <target state="translated">M-a</target>
        </trans-unit>
        <trans-unit id="dfec75d824ab931885b10c2deb8b602ddf385540" translate="yes" xml:space="preserve">
          <source>M-b</source>
          <target state="translated">M-b</target>
        </trans-unit>
        <trans-unit id="92eda3bf541ac9f8576ded598bec375af4abc3bd" translate="yes" xml:space="preserve">
          <source>M-end</source>
          <target state="translated">M-end</target>
        </trans-unit>
        <trans-unit id="980a6233a9b06694b777bb282affe943e0afc2da" translate="yes" xml:space="preserve">
          <source>M-g</source>
          <target state="translated">M-g</target>
        </trans-unit>
        <trans-unit id="52706036e0d1667ecb93c7d036d3d039cba1682a" translate="yes" xml:space="preserve">
          <source>M-n</source>
          <target state="translated">M-n</target>
        </trans-unit>
        <trans-unit id="c7cf6ebaeff525a4a38321125032420c3882f5a3" translate="yes" xml:space="preserve">
          <source>M-o</source>
          <target state="translated">M-o</target>
        </trans-unit>
        <trans-unit id="15f62577eedb593ecdad3ec32390144de3a4748e" translate="yes" xml:space="preserve">
          <source>M-o M-o</source>
          <target state="translated">モ・モ・モ・モ</target>
        </trans-unit>
        <trans-unit id="ded2b381f768b0426ee02fc11e7b1ea526d86382" translate="yes" xml:space="preserve">
          <source>M-p</source>
          <target state="translated">M-p</target>
        </trans-unit>
        <trans-unit id="0f8046567a7777233033e7c62fcbaaf077eb077a" translate="yes" xml:space="preserve">
          <source>M-r</source>
          <target state="translated">M-r</target>
        </trans-unit>
        <trans-unit id="0006025ee1ee308621c9836f080cfbad730b00dd" translate="yes" xml:space="preserve">
          <source>M-s</source>
          <target state="translated">M-s</target>
        </trans-unit>
        <trans-unit id="e2dbd97a24cfd42feafe4155928e5e36e05f30f3" translate="yes" xml:space="preserve">
          <source>M-v</source>
          <target state="translated">M-v</target>
        </trans-unit>
        <trans-unit id="5516e58102890d870825312fe7edb083af235de4" translate="yes" xml:space="preserve">
          <source>M-x</source>
          <target state="translated">M-x</target>
        </trans-unit>
        <trans-unit id="e96ee2840300f270b45095c2f0ec40521a00cde5" translate="yes" xml:space="preserve">
          <source>M-x &lt;var&gt;command&lt;/var&gt;</source>
          <target state="translated">Mx &lt;var&gt;command&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="30b1c3d10bd4ea36dfe161af71f9b59cff94dfbf" translate="yes" xml:space="preserve">
          <source>M-x &lt;var&gt;command&lt;/var&gt;RET</source>
          <target state="translated">Mx &lt;var&gt;command&lt;/var&gt; RET</target>
        </trans-unit>
        <trans-unit id="c8f918be9ef0d86eff9e8b262b173a76afb5d823" translate="yes" xml:space="preserve">
          <source>M-x apropos RET x-pointer RET</source>
          <target state="translated">M-x apropos RET x-pointer RET</target>
        </trans-unit>
        <trans-unit id="19d036c0bdece7df51bbb22b25a57a912bb781fc" translate="yes" xml:space="preserve">
          <source>M-x customize</source>
          <target state="translated">M-x カスタマイズ</target>
        </trans-unit>
        <trans-unit id="350cf2e68d92268174ae9d7178734cce54adaa8c" translate="yes" xml:space="preserve">
          <source>M-x describe-categories RET</source>
          <target state="translated">M-x describe-categories RET</target>
        </trans-unit>
        <trans-unit id="28a7266291890a298f219fa24bf612c876e68a3a" translate="yes" xml:space="preserve">
          <source>M-x dired-default-directory-on-left</source>
          <target state="translated">M-x dired-default-directory-on-left</target>
        </trans-unit>
        <trans-unit id="d0dbe2e240aeb6f1a78c981c88c230cc06b9fce7" translate="yes" xml:space="preserve">
          <source>M-x edebug-all-defs</source>
          <target state="translated">M-x edebug-all-defs</target>
        </trans-unit>
        <trans-unit id="c71a2298fbf3e6b350d972a5f6758ef0c7f37945" translate="yes" xml:space="preserve">
          <source>M-x edebug-all-forms</source>
          <target state="translated">M-x edebug-all-forms</target>
        </trans-unit>
        <trans-unit id="66031655733aef9ceba93288111a34d690630332" translate="yes" xml:space="preserve">
          <source>M-x edebug-backtrace-hide-instrumentation</source>
          <target state="translated">M-x edebug-backtrace-hide-instrumentation</target>
        </trans-unit>
        <trans-unit id="f849db42cc80a644b891cceb796496aea5a33446" translate="yes" xml:space="preserve">
          <source>M-x edebug-backtrace-show-instrumentation</source>
          <target state="translated">M-x edebug-backtrace-show-instrumentation</target>
        </trans-unit>
        <trans-unit id="0e0239d280915da82047b3562e0edc1ef7e13f61" translate="yes" xml:space="preserve">
          <source>M-x edebug-eval-top-level-form</source>
          <target state="translated">M-x edebug-eval-top-level-form</target>
        </trans-unit>
        <trans-unit id="95fa4b4069fcd95b6d5ac0204ea4c9cff0ee6f75" translate="yes" xml:space="preserve">
          <source>M-x edit-tab-stops</source>
          <target state="translated">M-x編集タブ停止</target>
        </trans-unit>
        <trans-unit id="924625b2d7b939bdd69c369a8e0e7552d4621132" translate="yes" xml:space="preserve">
          <source>M-x list-colors-display</source>
          <target state="translated">M-x リストカラー表示</target>
        </trans-unit>
        <trans-unit id="2d76ea9e63fcbb859b33f48edd7feb794a1730b1" translate="yes" xml:space="preserve">
          <source>M-x list-processes</source>
          <target state="translated">M-x リストプロセス</target>
        </trans-unit>
        <trans-unit id="84edc9f7052f2c9a7f036d7890685dfe8db762ec" translate="yes" xml:space="preserve">
          <source>M-x load-library RET package-x RET</source>
          <target state="translated">M-x load-library RET パッケージ-x RET</target>
        </trans-unit>
        <trans-unit id="b609619759aa9b92d26776cb6f14ab4bcfcc31de" translate="yes" xml:space="preserve">
          <source>M-x profiler-&amp;hellip;</source>
          <target state="translated">Mxプロファイラー-&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="0773bdccb110b28fb0a67898b66d8dd11444e9cc" translate="yes" xml:space="preserve">
          <source>M-x profiler-report</source>
          <target state="translated">M-x プロファイラレポート</target>
        </trans-unit>
        <trans-unit id="4f21aa5941ccf75086060a4caa6ef135d1f402a8" translate="yes" xml:space="preserve">
          <source>M-x profiler-start</source>
          <target state="translated">M-x プロファイラスタート</target>
        </trans-unit>
        <trans-unit id="7f9fd75200c3ba11f87c5df3770346f3beaa6c06" translate="yes" xml:space="preserve">
          <source>M-x profiler-stop</source>
          <target state="translated">エムエックスプロファイラストップ</target>
        </trans-unit>
        <trans-unit id="e1f1559513ee5a73bed6212288039c357856e5b7" translate="yes" xml:space="preserve">
          <source>M-x python-mode</source>
          <target state="translated">M-x python-mode</target>
        </trans-unit>
        <trans-unit id="9a178593a35bbea7f02403c42d651edd7a1bdd3d" translate="yes" xml:space="preserve">
          <source>M-x re-builder</source>
          <target state="translated">エムエックスリビルダー</target>
        </trans-unit>
        <trans-unit id="02844767c038cdd2dda139c1d2eab250404388db" translate="yes" xml:space="preserve">
          <source>M-x report-emacs-bug</source>
          <target state="translated">M-x レポート-emacs-バグ</target>
        </trans-unit>
        <trans-unit id="4a8d44402484cf1af704bb5188c0b2f67fd9deae" translate="yes" xml:space="preserve">
          <source>M-x serial-term</source>
          <target state="translated">エムエックスシリアルターム</target>
        </trans-unit>
        <trans-unit id="d262f66141e61698a64505a1167b86f852cd6537" translate="yes" xml:space="preserve">
          <source>M-x set-visited-file-name</source>
          <target state="translated">M-x set-visited-file-name</target>
        </trans-unit>
        <trans-unit id="ddd4cde942039a43aa69d7aaf7874a8689013014" translate="yes" xml:space="preserve">
          <source>M-x shell</source>
          <target state="translated">エムエックスシェル</target>
        </trans-unit>
        <trans-unit id="aeb29959992cb9268370a1bd309d2ce9f465185c" translate="yes" xml:space="preserve">
          <source>M-x testcover-mark-all</source>
          <target state="translated">エムエックステストカバーマークオール</target>
        </trans-unit>
        <trans-unit id="e8f70ba057d5e0dc5100fc76829c8002a8f06257" translate="yes" xml:space="preserve">
          <source>M-x testcover-next-mark</source>
          <target state="translated">M-xテストカバー次のマーク</target>
        </trans-unit>
        <trans-unit id="91f5f461f2c3a31e68b3789ab862a2b579739b85" translate="yes" xml:space="preserve">
          <source>M-x testcover-start RET&lt;var&gt;file&lt;/var&gt;RET</source>
          <target state="translated">Mxtestcover-RET &lt;var&gt;file&lt;/var&gt; RETを開始します</target>
        </trans-unit>
        <trans-unit id="0cb1249115b25aa2690a25b8910733c67b4a92a4" translate="yes" xml:space="preserve">
          <source>M-x untabify</source>
          <target state="translated">エムエックスアンタビファイ</target>
        </trans-unit>
        <trans-unit id="8938bda20b679e9984362cfe3b0025e2957609de" translate="yes" xml:space="preserve">
          <source>M-x update-directory-autoloads</source>
          <target state="translated">M-x update-directory-autoloads</target>
        </trans-unit>
        <trans-unit id="17a3a65ded9cf97168d2d48abac758964baf3233" translate="yes" xml:space="preserve">
          <source>M-x update-file-autoloads</source>
          <target state="translated">M-x update-file-autoloads</target>
        </trans-unit>
        <trans-unit id="157b9065ca9092b93a2cd86b2065b6f97cb3c423" translate="yes" xml:space="preserve">
          <source>M-x widget-browse RET binary-tree-of-string RET</source>
          <target state="translated">M-x ウィジェットブラウズ RET バイナリツリーオブストリング RET</target>
        </trans-unit>
        <trans-unit id="3aa424326e8c65a4310c522189aff3bdb49730f9" translate="yes" xml:space="preserve">
          <source>M-xelp-instrument-listRET nil RET</source>
          <target state="translated">M-xelp-instrument-listRET nil RET</target>
        </trans-unit>
        <trans-unit id="d61a0439c16b301031a2c72fbbf40aec0781473a" translate="yes" xml:space="preserve">
          <source>M-xelp-results</source>
          <target state="translated">M-xelp-results</target>
        </trans-unit>
        <trans-unit id="4cb98f7867f1180986c1b84ef1785ff0b2c4dc15" translate="yes" xml:space="preserve">
          <source>M-xlist-buffers</source>
          <target state="translated">M-xlist-buffers</target>
        </trans-unit>
        <trans-unit id="05b684cd2cc4407a760fc4776a9afa8ac8eaddb7" translate="yes" xml:space="preserve">
          <source>M-xlist-tags</source>
          <target state="translated">M-xlist-tags</target>
        </trans-unit>
        <trans-unit id="7555a33395fef6db20d121fb58c3221aa124e48c" translate="yes" xml:space="preserve">
          <source>M-y</source>
          <target state="translated">M-y</target>
        </trans-unit>
        <trans-unit id="db42242da8c9daf4dc32a3e8f6a8c77ab461abee" translate="yes" xml:space="preserve">
          <source>MENU-BAR</source>
          <target state="translated">MENU-BAR</target>
        </trans-unit>
        <trans-unit id="40bb78ac4a8f75b73057a2a259dcfa335c88dad4" translate="yes" xml:space="preserve">
          <source>META</source>
          <target state="translated">META</target>
        </trans-unit>
        <trans-unit id="2d4aa5a5271bf55bf5139dda546f0f30ba06a6bd" translate="yes" xml:space="preserve">
          <source>MIME</source>
          <target state="translated">MIME</target>
        </trans-unit>
        <trans-unit id="240ac4da20e27f25d9defe42a63eca4461adbce9" translate="yes" xml:space="preserve">
          <source>MS-DOS and MS-Windows systems usually lack the standard Unix program &lt;code&gt;ls&lt;/code&gt;, so this function emulates the standard Unix program &lt;code&gt;ls&lt;/code&gt; with Lisp code.</source>
          <target state="translated">MS-DOSおよびMS-Windowsシステムには通常標準のUnixプログラム &lt;code&gt;ls&lt;/code&gt; がないため、この関数は標準のUnixプログラム &lt;code&gt;ls&lt;/code&gt; をLispコードでエミュレートします。</target>
        </trans-unit>
        <trans-unit id="a6a56e5df064567806bfd2d02ec60d53d177da70" translate="yes" xml:space="preserve">
          <source>MS-DOS doesn&amp;rsquo;t support asynchronous subprocesses, so this option doesn&amp;rsquo;t work there.</source>
          <target state="translated">MS-DOSは非同期サブプロセスをサポートしていないため、このオプションはそこでは機能しません。</target>
        </trans-unit>
        <trans-unit id="660bf78961f4ec6bd8bd8b37a3b0b2769db2b14a" translate="yes" xml:space="preserve">
          <source>Macro</source>
          <target state="translated">Macro</target>
        </trans-unit>
        <trans-unit id="0d2da2eb949e2df3a96a434a98613935cdfa18a4" translate="yes" xml:space="preserve">
          <source>Macro Type</source>
          <target state="translated">マクロタイプ</target>
        </trans-unit>
        <trans-unit id="3764e4ae50932da915ec9a84fd2ba1b1c33188ce" translate="yes" xml:space="preserve">
          <source>Macro calls (see &lt;a href=&quot;macros#Macros&quot;&gt;Macros&lt;/a&gt;).</source>
          <target state="translated">マクロ呼び出し（&lt;a href=&quot;macros#Macros&quot;&gt;マクロを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="730c77b761075cf87c04f675fec25c96f12254c7" translate="yes" xml:space="preserve">
          <source>Macro expansion can have counterintuitive consequences. This section describes some important consequences that can lead to trouble, and rules to follow to avoid trouble.</source>
          <target state="translated">マクロの拡大は、意外な結果を招くことがあります。ここでは、トラブルにつながるいくつかの重要な結果と、トラブルを回避するためのルールについて説明します。</target>
        </trans-unit>
        <trans-unit id="7c8148b5f3e72ae81e30a87c1414a699978cee33" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;1value&lt;/strong&gt;&lt;em&gt;form&lt;/em&gt;</source>
          <target state="translated">マクロ：1&lt;strong&gt;値&lt;/strong&gt;&lt;em&gt;形式&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f625904d011437c920c24217d1112932e75fdede" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;EMACS_LIMB_MAX&lt;/strong&gt;</source>
          <target state="translated">マクロ：&lt;strong&gt;EMACS_LIMB_MAX&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f63e91ed8761158e2824094f3c035978e33f0b75" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;add-function&lt;/strong&gt;&lt;em&gt;where place function &amp;amp;optional props&lt;/em&gt;</source>
          <target state="translated">マクロ：&lt;em&gt;関数とオプションの小道具を配置する関数を&lt;/em&gt;&lt;strong&gt;追加&lt;/strong&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5429d225c6285d485886a63d9a654b44fd9af85a" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;cl-defgeneric&lt;/strong&gt;&lt;em&gt;name arguments [documentation] [options-and-methods&amp;hellip;] &amp;amp;rest body&lt;/em&gt;</source>
          <target state="translated">マクロ：&lt;strong&gt;cl-defgeneric&lt;/strong&gt;&lt;em&gt;名引数[ドキュメント] [オプションとメソッド&amp;hellip;]＆rest body&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ba5cedae4a4b306427387f90edd4dbd185e02578" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;cl-defmethod&lt;/strong&gt;&lt;em&gt;name [qualifier] arguments [&amp;amp;context (expr spec)&amp;hellip;] &amp;amp;rest [docstring] body&lt;/em&gt;</source>
          <target state="translated">マクロ：&lt;strong&gt;cl-defmethod&lt;/strong&gt;&lt;em&gt;名[修飾子]引数[＆context（expr spec）&amp;hellip;]＆rest [docstring] body&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1ff2b909c891d19da7650f8ccd70d4ff20d5f0ef" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;combine-after-change-calls&lt;/strong&gt;&lt;em&gt;body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">マクロ：&lt;strong&gt;変更後の結合-&lt;/strong&gt;&lt;em&gt;本体の&lt;/em&gt;&lt;strong&gt;呼び出し&lt;/strong&gt;&lt;em&gt;&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6ee51599c974e6734d6444e666498d94c6309037" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;combine-change-calls&lt;/strong&gt;&lt;em&gt;beg end body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">マクロ：&lt;strong&gt;combine-change-calls &lt;/strong&gt;&lt;em&gt;beg endbody&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3aee740831df3fe36c5e3627bd95688debd9b10c" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;condition-case-unless-debug&lt;/strong&gt;&lt;em&gt;var protected-form handlers&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">マクロ：&lt;strong&gt;condition-case-unless-debug &lt;/strong&gt;&lt;em&gt;varprotected-formhandlers&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="be46ac442c6b283fe5303544430db1733ede80cf" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;declare-function&lt;/strong&gt;&lt;em&gt;function file &amp;amp;optional arglist fileonly&lt;/em&gt;</source>
          <target state="translated">マクロ：&lt;strong&gt;宣言関数&lt;/strong&gt;&lt;em&gt;関数ファイルとオプションのarglistファイルのみ&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="62a5106ba44b52792efba46fd9abcd6f50d2a690" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;declare&lt;/strong&gt;&lt;em&gt;specs&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">マクロ：&lt;em&gt;仕様を&lt;/em&gt;&lt;strong&gt;宣言する&lt;/strong&gt;&lt;em&gt;&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="aad917e7e24305c69cc7b616287145940c7bc611" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;def-edebug-spec&lt;/strong&gt;&lt;em&gt;macro specification&lt;/em&gt;</source>
          <target state="translated">マクロ：&lt;strong&gt;def-edebug-spec&lt;/strong&gt;&lt;em&gt;マクロ仕様&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e8850ae7654fdd0f9e7e3643b836d299119c8eb3" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;defcustom&lt;/strong&gt;&lt;em&gt;option standard doc [keyword value]&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">マクロ：&lt;strong&gt;defcustom&lt;/strong&gt;&lt;em&gt;オプション標準ドキュメント[キーワード値]&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5434cd21483dbb5ef69be871541753221bd178a5" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;defface&lt;/strong&gt;&lt;em&gt;face spec doc [keyword value]&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">マクロ：&lt;strong&gt;defface &lt;/strong&gt;&lt;em&gt;face spec doc [キーワード値]&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="14c7fabc7b52a8375cc5c9e142c3ac122d2ea4bc" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;defgroup&lt;/strong&gt;&lt;em&gt;group members doc [keyword value]&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">マクロ：&lt;strong&gt;defgroup&lt;/strong&gt;&lt;em&gt;グループメンバーdoc [キーワード値]&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="28b55593ba483070425de7736987bf774bd2c491" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;defimage&lt;/strong&gt;&lt;em&gt;symbol specs &amp;amp;optional doc&lt;/em&gt;</source>
          <target state="translated">マクロ：&lt;strong&gt;defimage&lt;/strong&gt;&lt;em&gt;シンボル仕様とオプションのドキュメント&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fea6bef8b59da7c79bbd75395190d7484736ecf9" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;define-advice&lt;/strong&gt;&lt;em&gt;symbol (where lambda-list &amp;amp;optional name depth) &amp;amp;rest body&lt;/em&gt;</source>
          <target state="translated">マクロ：&lt;strong&gt;define-advice &lt;/strong&gt;&lt;em&gt;symbol（ラムダリスト＆オプションの名前の深さ）＆rest body&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="70852342716d3e0bca8b4f3d79c1ec5991f6b9cc" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;define-alternatives&lt;/strong&gt;&lt;em&gt;command &amp;amp;rest customizations&lt;/em&gt;</source>
          <target state="translated">マクロ：&lt;strong&gt;define-alternatives&lt;/strong&gt;&lt;em&gt;コマンドと残りのカスタマイズ&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="af424b3d2ee378903109c9532c12c3d915726f60" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;define-derived-mode&lt;/strong&gt;&lt;em&gt;variant parent name docstring keyword-args&amp;hellip; body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">マクロ：&lt;em&gt;define-&lt;/em&gt;&lt;strong&gt;派生モード&lt;/strong&gt;&lt;em&gt;バリアント親名docstringkeyword-args&amp;hellip;body&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d039443b2fcf2ccb94276b2881ba59ab7c4bef6e" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;define-generic-mode&lt;/strong&gt;&lt;em&gt;mode comment-list keyword-list font-lock-list auto-mode-list function-list &amp;amp;optional docstring&lt;/em&gt;</source>
          <target state="translated">マクロ：&lt;strong&gt;define-generic-mode&lt;/strong&gt;&lt;em&gt;モードcomment-listキーワード-list font-lock-list auto-mode-list function-list＆optional docstring&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3be7a42eb17b3b478f941dfaad3f2a091b3d9de0" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;define-globalized-minor-mode&lt;/strong&gt;&lt;em&gt;global-mode mode turn-on keyword-args&amp;hellip; body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">マクロ：&lt;strong&gt;define-globalized-minor-mode &lt;/strong&gt;&lt;em&gt;global-mode mode turn-onkeyword-args&amp;hellip;body&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c3698aa5f5a4cf22d04e63dba4fd63eeab2b198c" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;define-inline&lt;/strong&gt;&lt;em&gt;name args [doc] [declare] body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">マクロ：&lt;strong&gt;define-inline &lt;/strong&gt;&lt;em&gt;name args [doc] [declare] body&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1872fe945d43990f77596fefa545da1cad14ecf2" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;define-minor-mode&lt;/strong&gt;&lt;em&gt;mode doc [init-value [lighter [keymap]]] keyword-args&amp;hellip; body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">マクロ：&lt;strong&gt;define-minor-mode &lt;/strong&gt;&lt;em&gt;mode doc [init-value [lighter [keymap]]] keyword-args&amp;hellip;body&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e428f2f8e85f45dc22b5c0ef48e7d972c7378dba" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;define-obsolete-face-alias&lt;/strong&gt;&lt;em&gt;obsolete-face current-face when&lt;/em&gt;</source>
          <target state="translated">マクロ：&lt;strong&gt;define-obsolete-face-alias &lt;/strong&gt;&lt;em&gt;obsolete-face current-face when&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="803af6ea30a01f534dc197a816a8b6feeabe7985" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;define-obsolete-function-alias&lt;/strong&gt;&lt;em&gt;obsolete-name current-name when &amp;amp;optional doc&lt;/em&gt;</source>
          <target state="translated">マクロ：&lt;strong&gt;define-obsolete-function-alias &lt;/strong&gt;&lt;em&gt;obsolete-name current-name when＆optional doc&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c1c5b6a54e8e1d18babd8fbf3277042db07db8a8" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;define-obsolete-variable-alias&lt;/strong&gt;&lt;em&gt;obsolete-name current-name &amp;amp;optional when docstring&lt;/em&gt;</source>
          <target state="translated">マクロ：&lt;strong&gt;define-obsolete-variable-alias &lt;/strong&gt;&lt;em&gt;obsolete-name current-name＆optional when docstring&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="10f5376be352b9daee65a34b48f0eb2a91bc607c" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;defmacro&lt;/strong&gt;&lt;em&gt;name args [doc] [declare] body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">マクロ：&lt;strong&gt;defmacro &lt;/strong&gt;&lt;em&gt;name args [doc] [declare] body&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="78c0fc24e6b16b98abe1b0908482cec19956ca6f" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;defsubst&lt;/strong&gt;&lt;em&gt;name args [doc] [declare] [interactive] body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">マクロ：&lt;strong&gt;defsubst &lt;/strong&gt;&lt;em&gt;name args [doc] [declare] [interactive] body&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1683d10fb7854b9d19dee990d4fa2a5c7aa5855c" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;deftheme&lt;/strong&gt;&lt;em&gt;theme &amp;amp;optional doc&lt;/em&gt;</source>
          <target state="translated">マクロ：&lt;strong&gt;deftheme&lt;/strong&gt;&lt;em&gt;テーマとオプションのドキュメント&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8f549c138328cc6f82aa82edd990d79c318eb798" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;defun&lt;/strong&gt;&lt;em&gt;name args [doc] [declare] [interactive] body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">マクロ：&lt;strong&gt;defun &lt;/strong&gt;&lt;em&gt;name args [doc] [declare] [interactive] body&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="10c945e44b82a451a5291eaa330f70caa9d10af2" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;defvar-local&lt;/strong&gt;&lt;em&gt;variable value &amp;amp;optional docstring&lt;/em&gt;</source>
          <target state="translated">マクロ：&lt;strong&gt;defvar-ローカル&lt;/strong&gt;&lt;em&gt;変数値とオプションのdocstring&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cc1f8d335ca6f3d1108310f49f1d7c79312c2310" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;delay-mode-hooks&lt;/strong&gt;&lt;em&gt;body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">マクロ：&lt;strong&gt;delay-mode-hooksbody &lt;/strong&gt;&lt;em&gt;&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="236c5615e3d9ad7c6a4ecbd45a98af3f3547666f" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;dolist-with-progress-reporter&lt;/strong&gt;&lt;em&gt;(var count [result]) reporter-or-message body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">マクロ：&lt;strong&gt;dolist-with-progress-reporter &lt;/strong&gt;&lt;em&gt;（var count [result]）reporter-or-messagebody&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="af38a7273fecb69f9c319a26123467a4b36e125d" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;dolist&lt;/strong&gt;&lt;em&gt;(var list [result]) body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">マクロ：&lt;strong&gt;dolist &lt;/strong&gt;&lt;em&gt;（var list [result]）body&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f09315db5afa839072a62fbc1535685142261f35" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;dotimes-with-progress-reporter&lt;/strong&gt;&lt;em&gt;(var count [result]) reporter-or-message body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">マクロ：&lt;strong&gt;dotimes-with-progress-reporter &lt;/strong&gt;&lt;em&gt;（var count [result]）reporter-or- &lt;/em&gt;&lt;strong&gt;messagebody &lt;/strong&gt;&lt;em&gt;&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7f92ffa9680e321f5b7958eb9df3da33cc00a96e" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;dotimes&lt;/strong&gt;&lt;em&gt;(var count [result]) body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">マクロ：&lt;strong&gt;dotimes &lt;/strong&gt;&lt;em&gt;（var count [result]）body&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="27132dd2125d6a24d297f0e928ce24fd5c66c2a4" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;easy-menu-define&lt;/strong&gt;&lt;em&gt;symbol maps doc menu&lt;/em&gt;</source>
          <target state="translated">マクロ：&lt;strong&gt;easy- &lt;/strong&gt;&lt;em&gt;menu-シンボルマップの&lt;/em&gt;&lt;strong&gt;定義&lt;/strong&gt;&lt;em&gt;ドキュメントメニュー&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4202975359e6a5a35e94aebc824c1980bfa133ab" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;edebug-tracing&lt;/strong&gt;&lt;em&gt;string body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">マクロ：&lt;strong&gt;edebug-&lt;/strong&gt;&lt;em&gt;文字列本体の&lt;/em&gt;&lt;strong&gt;トレース&lt;/strong&gt;&lt;em&gt;&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
