<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="elisp">
    <body>
      <group id="elisp">
        <trans-unit id="97209372ca87135e65cd9c81713566e0e5ffbbed" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;file-name-quote&lt;/strong&gt;&lt;em&gt;name&lt;/em&gt;</source>
          <target state="translated">マクロ：&lt;strong&gt;ファイル名-引用&lt;/strong&gt;&lt;em&gt;名&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d492c007d3e41ed8529a79c7de06f64a383b0bb4" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;file-name-quoted-p&lt;/strong&gt;&lt;em&gt;name&lt;/em&gt;</source>
          <target state="translated">マクロ：&lt;strong&gt;file-name-quoted-p &lt;/strong&gt;&lt;em&gt;name&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="84eef64536eebdfb99700969216aebc1568b1a93" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;file-name-unquote&lt;/strong&gt;&lt;em&gt;name&lt;/em&gt;</source>
          <target state="translated">マクロ：&lt;strong&gt;ファイル名-引用符で囲まれていない&lt;/strong&gt;&lt;em&gt;名前&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="726f23b904d3162d0b6b2ce258aedc6f34085b01" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;gv-define-expander&lt;/strong&gt;&lt;em&gt;name handler&lt;/em&gt;</source>
          <target state="translated">マクロ：&lt;strong&gt;gv-define-expander&lt;/strong&gt;&lt;em&gt;名前ハンドラー&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3e8e8e6f9fb8ae64c4b81b0efb77b3aec46b1848" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;gv-define-setter&lt;/strong&gt;&lt;em&gt;name arglist &amp;amp;rest body&lt;/em&gt;</source>
          <target state="translated">マクロ：&lt;strong&gt;gv-define-setter &lt;/strong&gt;&lt;em&gt;name arglist＆rest body&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1ba4267fb86a2133c14e3991e850bf82e933e6cf" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;gv-define-simple-setter&lt;/strong&gt;&lt;em&gt;name setter &amp;amp;optional fix-return&lt;/em&gt;</source>
          <target state="translated">マクロ：&lt;strong&gt;gv-define-simple-setter &lt;/strong&gt;&lt;em&gt;name setter＆optional fix-return&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fe36114bc819fefed7ef2aa455dfe1201e1f3794" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;gv-letplace&lt;/strong&gt;&lt;em&gt;(getter setter) place &amp;amp;rest body&lt;/em&gt;</source>
          <target state="translated">マクロ：&lt;strong&gt;gv-letplace &lt;/strong&gt;&lt;em&gt;（getter setter）place＆rest body&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4d988bb7298849df77bbbf913cc1608cf1c65a48" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;ignore-error&lt;/strong&gt;&lt;em&gt;condition body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">マクロ：&lt;strong&gt;無視-エラー&lt;/strong&gt;&lt;em&gt;条件本体&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c0a70bba890a42f68ebbfdbefb8d53b65ab046ba" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;ignore-errors&lt;/strong&gt;&lt;em&gt;body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">マクロ：&lt;strong&gt;無視-エラー&lt;/strong&gt;&lt;em&gt;本体&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8d8cf7a6718df181f54afa400b67ca2ca8fa1da3" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;inline-const-p&lt;/strong&gt;&lt;em&gt;expression&lt;/em&gt;</source>
          <target state="translated">マクロ：&lt;strong&gt;inline-const-p&lt;/strong&gt;&lt;em&gt;式&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a2f83ce40aaee4b4c13e471e1088895be676b70e" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;inline-const-val&lt;/strong&gt;&lt;em&gt;expression&lt;/em&gt;</source>
          <target state="translated">マクロ：&lt;strong&gt;inline-const-val&lt;/strong&gt;&lt;em&gt;式&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="53a8c04b7bc095c6f92dc2e1ef62aceb2230f983" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;inline-error&lt;/strong&gt;&lt;em&gt;format &amp;amp;rest args&lt;/em&gt;</source>
          <target state="translated">マクロ：&lt;strong&gt;インラインエラー&lt;/strong&gt;&lt;em&gt;形式と残りの引数&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="18c258c00d0a0eefa18864e32e22a05027f102ed" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;inline-letevals&lt;/strong&gt;&lt;em&gt;(bindings&amp;hellip;) body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">マクロ：&lt;strong&gt;インライン-letevals &lt;/strong&gt;&lt;em&gt;（バインディング&amp;hellip;）本体&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7ea22905659127e33e1bae1fa9ee88c436a06ea8" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;inline-quote&lt;/strong&gt;&lt;em&gt;expression&lt;/em&gt;</source>
          <target state="translated">マクロ：&lt;strong&gt;インライン引用&lt;/strong&gt;&lt;em&gt;式&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="591cc65dde8d823c972143bbff5028af79cbb9db" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;iter-defun&lt;/strong&gt;&lt;em&gt;name args [doc] [declare] [interactive] body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">マクロ：&lt;strong&gt;iter-defun &lt;/strong&gt;&lt;em&gt;name args [doc] [declare] [interactive] body&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5dec5c51dc2ec952f84f4bbfed169751066042a1" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;iter-do&lt;/strong&gt;&lt;em&gt;(var iterator) body &amp;hellip;&lt;/em&gt;</source>
          <target state="translated">マクロ：&lt;strong&gt;iter-do &lt;/strong&gt;&lt;em&gt;（var iterator）body&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6af415e6cbf9f96bba0dce565e09bab755f1b4a1" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;iter-lambda&lt;/strong&gt;&lt;em&gt;args [doc] [interactive] body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">マクロ：&lt;strong&gt;iter-lambda &lt;/strong&gt;&lt;em&gt;args [doc] [interactive] body&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d034239c1317860ddb076eb18efff19e3bf9b86f" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;iter-yield-from&lt;/strong&gt;&lt;em&gt;iterator&lt;/em&gt;</source>
          <target state="translated">マクロ：&lt;strong&gt;iter-yield-&lt;/strong&gt;&lt;em&gt;イテレータ&lt;/em&gt;&lt;strong&gt;から&lt;/strong&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8295211938d4a3f738add01d06599196ba528680" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;iter-yield&lt;/strong&gt;&lt;em&gt;value&lt;/em&gt;</source>
          <target state="translated">マクロ：&lt;strong&gt;iter-yield &lt;/strong&gt;&lt;em&gt;value&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fb4abdbc2718878523fc62e401ee9bbb454e720e" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;lambda&lt;/strong&gt;&lt;em&gt;args [doc] [interactive] body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">マクロ：&lt;strong&gt;lambda &lt;/strong&gt;&lt;em&gt;args [doc] [interactive] body&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="97e12fdbcb9c7d29cfa4fb4a4d5bebd3b572b4be" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;lazy-completion-table&lt;/strong&gt;&lt;em&gt;var fun&lt;/em&gt;</source>
          <target state="translated">マクロ：&lt;strong&gt;lazy-completion-table &lt;/strong&gt;&lt;em&gt;var fun&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a13b390be25a1fbc366c265b47e90db671786c62" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;let-alist&lt;/strong&gt;&lt;em&gt;alist body&lt;/em&gt;</source>
          <target state="translated">マクロ：&lt;strong&gt;let-alist &lt;/strong&gt;&lt;em&gt;alist body&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0ff539998c76c30f04c81c659cfe2406d40230c9" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;make-help-screen&lt;/strong&gt;&lt;em&gt;fname help-line help-text help-map&lt;/em&gt;</source>
          <target state="translated">マクロ：&lt;strong&gt;make-help-screen &lt;/strong&gt;&lt;em&gt;fname help-line help-text help-map&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bcb098a03ed9e790b3a8274d37d20c47f9829b78" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;minibuffer-with-setup-hook&lt;/strong&gt;&lt;em&gt;function &amp;amp;rest body&lt;/em&gt;</source>
          <target state="translated">マクロ：&lt;strong&gt;minibuffer-with-setup-hook&lt;/strong&gt;&lt;em&gt;関数とレスト本体&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8438b00f04bfd18b4b0ae35e53a7cc991b2b59c9" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;noreturn&lt;/strong&gt;&lt;em&gt;form&lt;/em&gt;</source>
          <target state="translated">マクロ：&lt;strong&gt;ノーリターン&lt;/strong&gt;&lt;em&gt;フォーム&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cec782422ca74e562fbd1f338919db0b374e18fc" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;pcase-defmacro&lt;/strong&gt;&lt;em&gt;name args [doc] &amp;amp;rest body&lt;/em&gt;</source>
          <target state="translated">マクロ：&lt;strong&gt;pcase-defmacro &lt;/strong&gt;&lt;em&gt;name args [doc]＆rest body&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cbac1c3a887c3fb24e6cc7cf54c7c2199087fe99" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;pcase-dolist&lt;/strong&gt;&lt;em&gt;(pattern list) body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">マクロ：&lt;strong&gt;pcase-dolist &lt;/strong&gt;&lt;em&gt;（パターンリスト）本体&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0c05dbc3c6db6b261f36f043c6e80c8f33eda5de" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;pcase-let*&lt;/strong&gt;&lt;em&gt;bindings body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">マクロ：&lt;strong&gt;pcase-let *&lt;/strong&gt;&lt;em&gt;バインディング本体&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bb51fe5b0cf3705a47723c876b1e4bcd04dc577a" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;pcase-let&lt;/strong&gt;&lt;em&gt;bindings body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">マクロ：&lt;strong&gt;pcase-let&lt;/strong&gt;&lt;em&gt;バインディング本体&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ca87b97e541c841df38930296559cb00658e2768" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;pcase&lt;/strong&gt;&lt;em&gt;expression &amp;amp;rest clauses&lt;/em&gt;</source>
          <target state="translated">マクロ：&lt;strong&gt;pcase&lt;/strong&gt;&lt;em&gt;式とrest句&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="983e88ae1faa1be0650589312d5418fdde60f1bc" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;pop&lt;/strong&gt;&lt;em&gt;listname&lt;/em&gt;</source>
          <target state="translated">マクロ：&lt;strong&gt;ポップ&lt;/strong&gt;&lt;em&gt;リスト名&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8e0e2b6a982aeda0e4decaf96d35ea59a59bd598" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;provide-theme&lt;/strong&gt;&lt;em&gt;theme&lt;/em&gt;</source>
          <target state="translated">マクロ：&lt;strong&gt;テーマの&lt;/strong&gt;&lt;em&gt;テーマを&lt;/em&gt;&lt;strong&gt;提供する&lt;/strong&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1dc602f484a77596e515278730a111ba18108235" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;push&lt;/strong&gt;&lt;em&gt;element listname&lt;/em&gt;</source>
          <target state="translated">マクロ：&lt;strong&gt;プッシュ&lt;/strong&gt;&lt;em&gt;要素リスト名&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f156a8123bbcf74aa52f2b693a342c402f146879" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;remove-function&lt;/strong&gt;&lt;em&gt;place function&lt;/em&gt;</source>
          <target state="translated">マクロ：&lt;strong&gt;削除機能&lt;/strong&gt;&lt;em&gt;配置機能&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="dade05721b4bb5b2388ba9e36428808b0bd35b85" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;rx-define&lt;/strong&gt;&lt;em&gt;name [arglist] rx-form&lt;/em&gt;</source>
          <target state="translated">マクロ：&lt;strong&gt;rx-定義&lt;/strong&gt;&lt;em&gt;名[arglist] rx-form&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="96bddb173e4fc87b0212f01a02bc2ff46662fd79" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;rx-let-eval&lt;/strong&gt;&lt;em&gt;bindings body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">マクロ：&lt;strong&gt;rx-let-eval&lt;/strong&gt;&lt;em&gt;バインディング本体&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0f690b0183cee377b178ae7b310b55bed43dc046" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;rx-let&lt;/strong&gt;&lt;em&gt;(bindings&amp;hellip;) body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">マクロ：&lt;strong&gt;rx-let &lt;/strong&gt;&lt;em&gt;（バインディング&amp;hellip;）本体&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6b7d03766c09f7e22083ae5f1e5632dbe96a4075" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;rx&lt;/strong&gt;&lt;em&gt;rx-expr&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">マクロ：&lt;strong&gt;rxrx &lt;/strong&gt;&lt;em&gt;-expr&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7e38445717db19d10c7b2ff0da1e3c8e5606a741" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;save-mark-and-excursion&lt;/strong&gt;&lt;em&gt;body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">マクロ：&lt;strong&gt;保存マークとエクスカーションの&lt;/strong&gt;&lt;em&gt;本文&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d9f08975e9fff445dfb403167bb2325ccb174e76" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;save-match-data&lt;/strong&gt;&lt;em&gt;body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">マクロ：&lt;strong&gt;save-match-data&lt;/strong&gt;&lt;em&gt;本文&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="92793bf9d32a9540658805cb43a3ae0efa7f3128" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;save-selected-window&lt;/strong&gt;&lt;em&gt;forms&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">マクロ：&lt;strong&gt;save-selected-window&lt;/strong&gt;&lt;em&gt;フォーム&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e56a36e57644762b26c7a8043ad96444679ee21f" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;save-window-excursion&lt;/strong&gt;&lt;em&gt;forms&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">マクロ：&lt;strong&gt;save-window-excursion&lt;/strong&gt;&lt;em&gt;フォーム&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="12a277b9203d5ab428dff62199f053203e4f9360" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;seq-doseq&lt;/strong&gt;&lt;em&gt;(var sequence) body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">マクロ：&lt;strong&gt;seq-doseq &lt;/strong&gt;&lt;em&gt;（var sequence）body&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b835674eb567909d999b1d3adb5b36f56b21eb76" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;seq-let&lt;/strong&gt;&lt;em&gt;var-sequence val-sequence body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">マクロ：&lt;strong&gt;seq-let &lt;/strong&gt;&lt;em&gt;var-sequenceval-sequencebody&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e1c8aece33f7cb04f9bb4e8e78e941ba25f10c8a" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;setf&lt;/strong&gt;&lt;em&gt;[place form]&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">マクロ：&lt;strong&gt;setf &lt;/strong&gt;&lt;em&gt;[プレースフォーム]&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9ae20fe71c0e147bb6bc4871d96f5e92f5c5660a" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;setq-local&lt;/strong&gt;&lt;em&gt;&amp;amp;rest pairs&lt;/em&gt;</source>
          <target state="translated">マクロ：&lt;strong&gt;setq-ローカル&lt;/strong&gt;&lt;em&gt;とレストのペア&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7fc00650723cfa16788a6eb8c490f8e2cbe554c7" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;thunk-delay&lt;/strong&gt;&lt;em&gt;forms&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">マクロ：&lt;strong&gt;サンク遅延&lt;/strong&gt;&lt;em&gt;フォーム&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f74169099eddfe8865dcdf5990bc129a1fdc6673" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;thunk-let*&lt;/strong&gt;&lt;em&gt;(bindings&amp;hellip;) forms&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">マクロ：&lt;strong&gt;thunk-let * &lt;/strong&gt;&lt;em&gt;（バインディング&amp;hellip;）フォーム&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2a1e217877c5526cceda285dd42d4924b08e82f6" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;thunk-let&lt;/strong&gt;&lt;em&gt;(bindings&amp;hellip;) forms&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">マクロ：&lt;strong&gt;サンクレット&lt;/strong&gt;&lt;em&gt;（バインディング&amp;hellip;）フォーム&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="766201ee854ac160680cf24ccec173e582e1a7ed" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;track-mouse&lt;/strong&gt;&lt;em&gt;body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">マクロ：&lt;strong&gt;トラックマウス&lt;/strong&gt;&lt;em&gt;本体&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="feb84a0ba8e8559be9ca8af3789ff323f8333f22" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;unless&lt;/strong&gt;&lt;em&gt;condition forms&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">マクロ：&lt;em&gt;条件が形成され&lt;/em&gt;&lt;strong&gt;ない限り&lt;/strong&gt;&lt;em&gt;&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d5aff66224e617a69f0607a954cf4ce95d91c0fc" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;when&lt;/strong&gt;&lt;em&gt;condition then-forms&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">マクロ：&lt;strong&gt;とき&lt;/strong&gt;&lt;em&gt;の条件は、その後、フォーム...&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f205733ce1922f5715da64c2f9555232afd3f01c" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;while-no-input&lt;/strong&gt;&lt;em&gt;body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">マクロ：&lt;strong&gt;while-no-inputbody &lt;/strong&gt;&lt;em&gt;&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f712914bd7ea1c83173b9e57d39ac648cc864f03" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;with-case-table&lt;/strong&gt;&lt;em&gt;table body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">マクロ：&lt;strong&gt;with-case-table&lt;/strong&gt;&lt;em&gt;テーブル本体&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="756ee1443c1beb536eabc9fa307af9516c8aef78" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;with-coding-priority&lt;/strong&gt;&lt;em&gt;coding-systems &amp;amp;rest body&lt;/em&gt;</source>
          <target state="translated">マクロ：&lt;strong&gt;with-coding-prioritycoding &lt;/strong&gt;&lt;em&gt;-systems＆rest body&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b0626d3bcff6d0f9b11bce251e24405f3aef3212" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;with-connection-local-variables&lt;/strong&gt;&lt;em&gt;&amp;amp;rest body&lt;/em&gt;</source>
          <target state="translated">マクロ：&lt;strong&gt;with-connection-local-variables &lt;/strong&gt;&lt;em&gt;＆rest body&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e90a90d3854565590ceddc4b00fa70821a122a93" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;with-current-buffer-window&lt;/strong&gt;&lt;em&gt;buffer-or-name action quit-function &amp;amp;rest body&lt;/em&gt;</source>
          <target state="translated">マクロ：&lt;strong&gt;with-current-buffer-window &lt;/strong&gt;&lt;em&gt;buffer-or-name action quit-function＆rest body&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6e67efe0226ce402a3b6577c2572b74269dde5f8" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;with-current-buffer&lt;/strong&gt;&lt;em&gt;buffer-or-name body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">マクロ：&lt;strong&gt;with-current- &lt;/strong&gt;&lt;em&gt;bufferbuffer-or-namebody&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a213d0fd2a350c51fd6e821ffbef2c3c4e957b3f" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;with-demoted-errors&lt;/strong&gt;&lt;em&gt;format body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">マクロ：&lt;strong&gt;with-demoted-errors&lt;/strong&gt;&lt;em&gt;フォーマット本体&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="92216dc544bae7ab562994e1580bab8f27e5c500" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;with-displayed-buffer-window&lt;/strong&gt;&lt;em&gt;buffer-or-name action quit-function &amp;amp;rest body&lt;/em&gt;</source>
          <target state="translated">マクロ：&lt;strong&gt;with-displayed-buffer-window &lt;/strong&gt;&lt;em&gt;buffer-or-name action quit-function＆rest body&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="02e7d013fbb53c92f365f47d71935d53a79d3a44" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;with-eval-after-load&lt;/strong&gt;&lt;em&gt;library body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">マクロ：&lt;strong&gt;with-eval-after-load&lt;/strong&gt;&lt;em&gt;ライブラリ本体&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3ef9c7bbb2f8fd032cb894c0974bac62ca556b08" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;with-file-modes&lt;/strong&gt;&lt;em&gt;mode body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">マクロ：&lt;strong&gt;with-file-modes&lt;/strong&gt;&lt;em&gt;モード本体&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2e1ad0b0fa15e75e81fefccc043649d47a0ec7e8" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;with-help-window&lt;/strong&gt;&lt;em&gt;buffer-or-name body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">マクロ：&lt;strong&gt;with-help- &lt;/strong&gt;&lt;em&gt;windowbuffer-or-namebody&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fe85851374c7d77e353d19f39d6c72494baf5727" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;with-local-quit&lt;/strong&gt;&lt;em&gt;body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">マクロ：&lt;strong&gt;with-local-quitbody &lt;/strong&gt;&lt;em&gt;&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bf3fce278bf45ed1fb14e057cc0160271c67cbe1" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;with-mutex&lt;/strong&gt;&lt;em&gt;mutex body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">マクロ：&lt;strong&gt;with-mutex&lt;/strong&gt;&lt;em&gt;ミューテックス本体&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b5ce9ef0c5615794d7bdaada637134dc5ef72f95" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;with-output-to-string&lt;/strong&gt;&lt;em&gt;body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">マクロ：&lt;strong&gt;with-output-to-stringbody &lt;/strong&gt;&lt;em&gt;&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="145e9acb2514daffd471084b4b74175db21ac6c3" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;with-output-to-temp-buffer&lt;/strong&gt;&lt;em&gt;buffer-name body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">マクロ：&lt;strong&gt;with-output-to-temp-buffer &lt;/strong&gt;&lt;em&gt;buffer- &lt;/em&gt;&lt;strong&gt;namebody &lt;/strong&gt;&lt;em&gt;&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="014aa5fdf2960526d77b8827eae2e874906c5c72" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;with-selected-window&lt;/strong&gt;&lt;em&gt;window forms&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">マクロ：&lt;strong&gt;with-selected-window&lt;/strong&gt;&lt;em&gt;ウィンドウフォーム&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a68f1966ed297f73ea9922e372523354a6209aeb" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;with-silent-modifications&lt;/strong&gt;&lt;em&gt;body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">マクロ：&lt;strong&gt;with-silent-modificationsbody &lt;/strong&gt;&lt;em&gt;&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1b76c740d791472ee05bb84bd685f4830fbd0565" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;with-syntax-table&lt;/strong&gt;&lt;em&gt;table body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">マクロ：&lt;strong&gt;with-syntax-table&lt;/strong&gt;&lt;em&gt;テーブル本体&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7179c68d1d61234db5bb28f842f04ab503193f52" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;with-temp-buffer-window&lt;/strong&gt;&lt;em&gt;buffer-or-name action quit-function body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">マクロ：&lt;strong&gt;with-temp-buffer-windowbuffer- &lt;/strong&gt;&lt;em&gt;or-nameアクションquit-functionbody&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cb335e848f2b8117c60546cedb994f0aab8f2d72" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;with-temp-buffer&lt;/strong&gt;&lt;em&gt;body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">マクロ：&lt;strong&gt;with-temp-bufferbody &lt;/strong&gt;&lt;em&gt;&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="68e9e5f62833f7dad75fa42c04a754f63c197fe2" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;with-temp-file&lt;/strong&gt;&lt;em&gt;file body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">マクロ：&lt;strong&gt;with-temp-file&lt;/strong&gt;&lt;em&gt;ファイル本体&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6e02315ac7e8b3f0ae1f5ca75a9f6f493bcaeceb" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;with-temp-message&lt;/strong&gt;&lt;em&gt;message &amp;amp;rest body&lt;/em&gt;</source>
          <target state="translated">マクロ：&lt;strong&gt;with-temp-message&lt;/strong&gt;&lt;em&gt;メッセージ＆rest body&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="87f26c950e83c00d565896bc264176d651cbc638" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;with-timeout&lt;/strong&gt;&lt;em&gt;(seconds timeout-forms&amp;hellip;) body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">マクロ：&lt;strong&gt;with-timeout &lt;/strong&gt;&lt;em&gt;（seconds timeout-forms&amp;hellip;）body&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="899bd694d29ace1be956ab35177075021977560b" translate="yes" xml:space="preserve">
          <source>Macros</source>
          <target state="translated">Macros</target>
        </trans-unit>
        <trans-unit id="b7ffee61760e61c23c93306e84f4ed865540a241" translate="yes" xml:space="preserve">
          <source>Macros and Byte Compilation</source>
          <target state="translated">マクロとバイトコンパイル</target>
        </trans-unit>
        <trans-unit id="e9174412561f9b06e7358a460619f423a936460d" translate="yes" xml:space="preserve">
          <source>Macros are a way to extend the Lisp language.</source>
          <target state="translated">マクロはLisp言語を拡張する方法です。</target>
        </trans-unit>
        <trans-unit id="df1edfc722b17bf0432a6a39f4d123de99bb02e1" translate="yes" xml:space="preserve">
          <source>Macros can do this because they operate on the unevaluated expressions for the arguments, not on the argument values as functions do. They can therefore construct an expansion containing these argument expressions or parts of them.</source>
          <target state="translated">マクロは、関数のように引数の値ではなく、引数の評価されていない式を操作するため、このようなことができます。そのため、これらの引数式またはその一部を含む拡張子を構築することができます。</target>
        </trans-unit>
        <trans-unit id="86ad4286948aac2e22fb320469457597f40e25e9" translate="yes" xml:space="preserve">
          <source>Macros like &lt;code&gt;save-window-excursion&lt;/code&gt;, &lt;code&gt;with-selected-window&lt;/code&gt; or &lt;code&gt;with-current-buffer&lt;/code&gt; can be used when running window change functions.</source>
          <target state="translated">ウィンドウ変更関数を実行するときは、 &lt;code&gt;save-window-excursion&lt;/code&gt; 、 &lt;code&gt;with-selected-window&lt;/code&gt; 、 &lt;code&gt;with-current-buffer&lt;/code&gt; などのマクロを使用できます。</target>
        </trans-unit>
        <trans-unit id="8609149c2452193a39482806645c173c455fdb7e" translate="yes" xml:space="preserve">
          <source>Macros often need to construct large list structures from a mixture of constants and nonconstant parts. To make this easier, use the &amp;lsquo;</source>
          <target state="translated">マクロは、定数と非定数部分の混合から大きなリスト構造を構築する必要があることがよくあります。これを簡単にするには、 'を使用します</target>
        </trans-unit>
        <trans-unit id="e02a2089bfc650b4d78c5778356a47b4f6c929d4" translate="yes" xml:space="preserve">
          <source>Maintaining Undo Lists</source>
          <target state="translated">Undoリストの管理</target>
        </trans-unit>
        <trans-unit id="b4800c1dbe2e7fe97716c9f437b2d989b0114297" translate="yes" xml:space="preserve">
          <source>Maintaining a public package archive entails a degree of responsibility. When Emacs users install packages from your archive, those packages can cause Emacs to run arbitrary code with the permissions of the installing user. (This is true for Emacs code in general, not just for packages.) So you should ensure that your archive is well-maintained and keep the hosting system secure.</source>
          <target state="translated">パブリックパッケージアーカイブを管理するには、ある程度の責任が伴います。Emacs ユーザがアーカイブからパッケージをインストールすると、そのパッケージがインストールしたユーザの権限で Emacs が任意のコードを実行する原因になることがあります (これはパッケージに限らず、Emacs コード全般に言えることです)。(これはパッケージに限らず、Emacs のコード全般に言えることです。)ですから、アーカイブは十分にメンテナンスされていることを確認し、ホスティングシステムを安全に保つ必要があります。</target>
        </trans-unit>
        <trans-unit id="c19746ba61877a021e38d926e000d62be983a896" translate="yes" xml:space="preserve">
          <source>Maintaining package archives.</source>
          <target state="translated">パッケージアーカイブの管理</target>
        </trans-unit>
        <trans-unit id="606cf8196868e5f549fd1168472b48701f267c5f" translate="yes" xml:space="preserve">
          <source>Major Mode Conventions</source>
          <target state="translated">主なモード規定</target>
        </trans-unit>
        <trans-unit id="bb282fd14bccfc29a60ab093b4041c44964f43f9" translate="yes" xml:space="preserve">
          <source>Major Mode Examples</source>
          <target state="translated">主なモード例</target>
        </trans-unit>
        <trans-unit id="a8b5ad1cdceba549e2a4b89898c34005d52785df" translate="yes" xml:space="preserve">
          <source>Major Modes</source>
          <target state="translated">主要なモード</target>
        </trans-unit>
        <trans-unit id="cd5fed78b53dc008bcaa949f077e4002fa314735" translate="yes" xml:space="preserve">
          <source>Major and Minor Modes</source>
          <target state="translated">メジャーモードとマイナーモード</target>
        </trans-unit>
        <trans-unit id="e37f2a35397994a75b440b8e162b38fe39bb718b" translate="yes" xml:space="preserve">
          <source>Major modes for editing text should not define</source>
          <target state="translated">テキストを編集するための主要なモードは</target>
        </trans-unit>
        <trans-unit id="4fa4f3d22c7a7ae10c0e45ce33e8b5151b9a09b1" translate="yes" xml:space="preserve">
          <source>Major modes should not alter options that are primarily a matter of user preference, such as whether Auto-Fill mode is enabled. Leave this to each user to decide. However, a major mode should customize other variables so that Auto-Fill mode will work usefully &lt;em&gt;if&lt;/em&gt; the user decides to use it.</source>
          <target state="translated">メジャーモードでは、自動入力モードが有効になっているかどうかなど、主にユーザーの好みの問題であるオプションを変更しないでください。これは各ユーザーに任せて決定してください。ただし、メジャーモードでは、ユーザーが使用することを決定した&lt;em&gt;場合に&lt;/em&gt;自動入力モードが便利に機能するように、他の変数をカスタマイズする必要があります。</target>
        </trans-unit>
        <trans-unit id="d5246cd7371de3f7eda0f9bf9b7e1bf7a313c280" translate="yes" xml:space="preserve">
          <source>Major modes should run their mode hook using this function. It is similar to &lt;code&gt;run-hooks&lt;/code&gt; (see &lt;a href=&quot;hooks#Hooks&quot;&gt;Hooks&lt;/a&gt;), but it also runs &lt;code&gt;change-major-mode-after-body-hook&lt;/code&gt;, &lt;code&gt;hack-local-variables&lt;/code&gt; (when the buffer is visiting a file) (see &lt;a href=&quot;file-local-variables#File-Local-Variables&quot;&gt;File Local Variables&lt;/a&gt;), and &lt;code&gt;after-change-major-mode-hook&lt;/code&gt;. The last thing it does is to evaluate any &lt;code&gt;:after-hook&lt;/code&gt; forms declared by parent modes (see &lt;a href=&quot;derived-modes#Derived-Modes&quot;&gt;Derived Modes&lt;/a&gt;).</source>
          <target state="translated">メジャーモードは、この関数を使用してモードフックを実行する必要があります。に似て &lt;code&gt;run-hooks&lt;/code&gt; （参照&lt;a href=&quot;hooks#Hooks&quot;&gt;フック&lt;/a&gt;）が、それはまた走る &lt;code&gt;change-major-mode-after-body-hook&lt;/code&gt; 、 &lt;code&gt;hack-local-variables&lt;/code&gt; （バッファがファイルを訪問したとき）（参照&lt;a href=&quot;file-local-variables#File-Local-Variables&quot;&gt;ファイルローカル変数を&lt;/a&gt;）、および &lt;code&gt;after-change-major-mode-hook&lt;/code&gt; 。最後に行うことは、親モードによって宣言された &lt;code&gt;:after-hook&lt;/code&gt; フォームを評価することです（&lt;a href=&quot;derived-modes#Derived-Modes&quot;&gt;派生モードを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="2923364acdd14ce08c91c050cf84d8d42591bb6e" translate="yes" xml:space="preserve">
          <source>Major modes specialize Emacs for editing or interacting with particular kinds of text. Each buffer has exactly one major mode at a time. Every major mode is associated with a &lt;em&gt;major mode command&lt;/em&gt;, whose name should end in &amp;lsquo;</source>
          <target state="translated">メジャーモードは、特定の種類のテキストを編集または操作するためのEmacsに特化しています。各バッファには、一度に1つのメジャーモードがあります。すべてのメジャーモードは&lt;em&gt;メジャーモードコマンドに&lt;/em&gt;関連付けられており、その名前は 'で終わる必要があり&lt;em&gt;ます&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="38d00cb263c96ca2a52e27564fd94babb43bab35" translate="yes" xml:space="preserve">
          <source>Make a finalizer that will run &lt;var&gt;function&lt;/var&gt;. &lt;var&gt;function&lt;/var&gt; will be called after garbage collection when the returned finalizer object becomes unreachable. If the finalizer object is reachable only through references from finalizer objects, it does not count as reachable for the purpose of deciding whether to run &lt;var&gt;function&lt;/var&gt;. &lt;var&gt;function&lt;/var&gt; will be run once per finalizer object.</source>
          <target state="translated">&lt;var&gt;function&lt;/var&gt; を実行するファイナライザーを作成します。返されたファイナライザオブジェクトが到達不能になると、ガベージコレクション後に &lt;var&gt;function&lt;/var&gt; が呼び出されます。ファイナライザーオブジェクトがファイナライザーオブジェクトからの参照を介してのみ到達可能である場合、 &lt;var&gt;function&lt;/var&gt; を実行するかどうかを決定する目的で到達可能としてカウントされません。 &lt;var&gt;function&lt;/var&gt; は、ファイナライザーオブジェクトごとに1回実行されます。</target>
        </trans-unit>
        <trans-unit id="7d05b1ed3c0802c954e67c3ed43ecc3f76f2dcb8" translate="yes" xml:space="preserve">
          <source>Make a new condition variable associated with &lt;var&gt;mutex&lt;/var&gt;. If &lt;var&gt;name&lt;/var&gt; is specified, it is a name given to the condition variable. It must be a string. The name is for debugging purposes only; it has no meaning to Emacs.</source>
          <target state="translated">&lt;var&gt;mutex&lt;/var&gt; 関連付けられた新しい条件変数を作成します。 &lt;var&gt;name&lt;/var&gt; が指定されている場合、それは条件変数に付けられた名前です。文字列である必要があります。この名前はデバッグのみを目的としています。Emacsには意味がありません。</target>
        </trans-unit>
        <trans-unit id="1c29998a0cfecf6c2e9ce2a81215d8045a8a6c92" translate="yes" xml:space="preserve">
          <source>Make numbered backups if the visited file already has numbered backups; otherwise, do not. This is the default.</source>
          <target state="translated">訪問したファイルに既に番号付きバックアップがある場合は番号付きバックアップを作成し、そうでない場合は作成しません。これがデフォルトです。</target>
        </trans-unit>
        <trans-unit id="2da90c1787d3c7d351f1c46baa7a638097f08e65" translate="yes" xml:space="preserve">
          <source>Make numbered backups.</source>
          <target state="translated">番号付きのバックアップを作成します。</target>
        </trans-unit>
        <trans-unit id="711b2ff4a299052a936b40c6f84cbfef1eba50db" translate="yes" xml:space="preserve">
          <source>Make sure &lt;code&gt;jit-lock-contextually&lt;/code&gt; is set and rely on it doing its job. This will only rehighlight the part of the construct that follows the actual change, and will do it after a short delay. This only works if the highlighting of the various parts of your multiline construct never depends on text in subsequent lines. Since &lt;code&gt;jit-lock-contextually&lt;/code&gt; is activated by default, this can be an attractive solution.</source>
          <target state="translated">確認してください &lt;code&gt;jit-lock-contextually&lt;/code&gt; を設定し、その仕事をして、それに依存しています。これは、実際の変更に続く構成の部分のみを再強調し、少し遅れてそれを行います。これは、複数行構成のさまざまな部分の強調表示が後続の行のテキストに依存しない場合にのみ機能します。以来 &lt;code&gt;jit-lock-contextually&lt;/code&gt; デフォルトで有効にされ、これは魅力的な解決策になることができます。</target>
        </trans-unit>
        <trans-unit id="b6a7dff46b149b27821f54fd9ae7b59aa7b81e46" translate="yes" xml:space="preserve">
          <source>Make the &lt;code&gt;rx&lt;/code&gt; definitions in &lt;var&gt;bindings&lt;/var&gt; available locally for &lt;code&gt;rx&lt;/code&gt; macro invocations in &lt;var&gt;body&lt;/var&gt;, which is then evaluated.</source>
          <target state="translated">&lt;var&gt;bindings&lt;/var&gt; 内の &lt;code&gt;rx&lt;/code&gt; 定義を、 &lt;var&gt;body&lt;/var&gt; 内の &lt;code&gt;rx&lt;/code&gt; マクロ呼び出しでローカルに使用できるようにします。これは次に評価されます。</target>
        </trans-unit>
        <trans-unit id="7cbe1d5e07a300b4e199aa52e31ab4c25575ef27" translate="yes" xml:space="preserve">
          <source>Making Backup Files</source>
          <target state="translated">バックアップファイルの作成</target>
        </trans-unit>
        <trans-unit id="d519807d2832f393ececd53cc3b5b0781e852aed" translate="yes" xml:space="preserve">
          <source>Making Buttons</source>
          <target state="translated">ボタンの作り方</target>
        </trans-unit>
        <trans-unit id="6bc49c91daf67a006b0afd80b17ad707dc94b52d" translate="yes" xml:space="preserve">
          <source>Making Certain File Names &amp;ldquo;Magic&amp;rdquo;</source>
          <target state="translated">特定のファイル名を「魔法」にする</target>
        </trans-unit>
        <trans-unit id="c34b468d532d0ce0f0dafb7d482d36723b3412cd" translate="yes" xml:space="preserve">
          <source>Making Certain File Names “Magic”</source>
          <target state="translated">特定のファイル名を「魔法」にする</target>
        </trans-unit>
        <trans-unit id="c51c6eff7a755274f117eedefbb312175db7a807" translate="yes" xml:space="preserve">
          <source>Making a command distinguish interactive calls.</source>
          <target state="translated">対話的な呼び出しをコマンドで区別させる</target>
        </trans-unit>
        <trans-unit id="7318dd947ef8c106ed8ecd66b4999fa87252517d" translate="yes" xml:space="preserve">
          <source>Making a frame the child of another.</source>
          <target state="translated">フレームを他の人の子にすること。</target>
        </trans-unit>
        <trans-unit id="a4f8e97640cd04a362c1fe6f0e955802fe3826fe" translate="yes" xml:space="preserve">
          <source>Making a frame visible usually makes all its child frames (and their descendants) visible as well (see &lt;a href=&quot;child-frames#Child-Frames&quot;&gt;Child Frames&lt;/a&gt;).</source>
          <target state="translated">フレームを表示すると、通常、そのすべての子フレーム（およびその子孫）も表示されます（&lt;a href=&quot;child-frames#Child-Frames&quot;&gt;子フレームを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="681222f25961ab30aded517088045711c219585c" translate="yes" xml:space="preserve">
          <source>Making a function inline often makes its function calls run faster. But it also has disadvantages. For one thing, it reduces flexibility; if you change the definition of the function, calls already inlined still use the old definition until you recompile them.</source>
          <target state="translated">関数をインラインにすると、関数の呼び出しが速くなることがよくあります。しかし、これには欠点もあります。関数の定義を変更した場合、すでにインライン化されている呼び出しは再コンパイルするまで古い定義を使用します。</target>
        </trans-unit>
        <trans-unit id="f2089d7853bf8479df80e0abc427bb46a0ae24ca" translate="yes" xml:space="preserve">
          <source>Making a simple menu.</source>
          <target state="translated">シンプルなメニュー作り。</target>
        </trans-unit>
        <trans-unit id="8439e43257d843b9c56d5b30e329b96824cfd5a0" translate="yes" xml:space="preserve">
          <source>Making a trace buffer is not the same thing as using trace execution mode (see &lt;a href=&quot;edebug-execution-modes#Edebug-Execution-Modes&quot;&gt;Edebug Execution Modes&lt;/a&gt;).</source>
          <target state="translated">トレースバッファの作成は、トレース実行モードの使用と同じではありません（&lt;a href=&quot;edebug-execution-modes#Edebug-Execution-Modes&quot;&gt;Edebug実行モードを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="e9a2a5554b24dffde38c378df6b1ed44b56af090" translate="yes" xml:space="preserve">
          <source>Making a variable buffer-local within a &lt;code&gt;let&lt;/code&gt;-binding for that variable does not work reliably, unless the buffer in which you do this is not current either on entry to or exit from the &lt;code&gt;let&lt;/code&gt;. This is because &lt;code&gt;let&lt;/code&gt; does not distinguish between different kinds of bindings; it knows only which variable the binding was made for.</source>
          <target state="translated">その変数の &lt;code&gt;let&lt;/code&gt; - binding内で変数をbuffer-localにすることは、これを行うバッファーが &lt;code&gt;let&lt;/code&gt; への入り口またはletからの出口のいずれかで最新でない場合を除いて、確実に機能しません。これは、 &lt;code&gt;let&lt;/code&gt; が異なる種類のバインディングを区別しないためです。バインディングが作成された変数のみを認識します。</target>
        </trans-unit>
        <trans-unit id="1a77df4e83035e98ff42ae3948f6a82cd13e6bb3" translate="yes" xml:space="preserve">
          <source>Making and Deleting Numbered Backup Files</source>
          <target state="translated">番号付きバックアップファイルの作成と削除</target>
        </trans-unit>
        <trans-unit id="502cd69036f8965c9870fb3f5a0ea43cc7a0e64d" translate="yes" xml:space="preserve">
          <source>Making elements that match multiline constructs work properly has two aspects: correct &lt;em&gt;identification&lt;/em&gt; and correct &lt;em&gt;rehighlighting&lt;/em&gt;. The first means that Font Lock finds all multiline constructs. The second means that Font Lock will correctly rehighlight all the relevant text when a multiline construct is changed&amp;mdash;for example, if some of the text that was previously part of a multiline construct ceases to be part of it. The two aspects are closely related, and often getting one of them to work will appear to make the other also work. However, for reliable results you must attend explicitly to both aspects.</source>
          <target state="translated">複数行の構成に一致する要素を適切に機能させるには、正しい&lt;em&gt;識別&lt;/em&gt;と正しい&lt;em&gt;再強調という&lt;/em&gt;2つの側面があります。 1つ目は、FontLockがすべての複数行構成を検索することを意味します。 2つ目は、複数行の構成が変更された場合、たとえば、以前は複数行の構成の一部であったテキストの一部がその一部でなくなった場合に、フォントロックが関連するすべてのテキストを正しく再強調表示することを意味します。 2つの側面は密接に関連しており、多くの場合、一方を機能させると、もう一方も機能するように見えます。ただし、信頼できる結果を得るには、両方の側面に明示的に注意する必要があります。</target>
        </trans-unit>
        <trans-unit id="098d22cd28360badafbde33dc08e76c95b4320aa" translate="yes" xml:space="preserve">
          <source>Making empty markers or markers at certain places.</source>
          <target state="translated">特定の場所に空のマーカーや目印を作ること。</target>
        </trans-unit>
        <trans-unit id="525dbea9386c59969f103c79f75f5f87fc2f3fcd" translate="yes" xml:space="preserve">
          <source>Making keymaps active is not the only way to use them. Keymaps are also used in other ways, such as for translating events within &lt;code&gt;read-key-sequence&lt;/code&gt;. See &lt;a href=&quot;translation-keymaps#Translation-Keymaps&quot;&gt;Translation Keymaps&lt;/a&gt;.</source>
          <target state="translated">キーマップをアクティブにすることは、キーマップを使用する唯一の方法ではありません。 &lt;code&gt;read-key-sequence&lt;/code&gt; マップは、read-key-sequence内のイベントの変換など、他の方法でも使用されます。&lt;a href=&quot;translation-keymaps#Translation-Keymaps&quot;&gt;翻訳キーマップを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="541485b8dffefaa5c41c8732b845592eb77e4506" translate="yes" xml:space="preserve">
          <source>Making multiple system-level windows.</source>
          <target state="translated">複数のシステムレベルのウィンドウを作成します。</target>
        </trans-unit>
        <trans-unit id="7aea42fe562cd12b8ebe2dbf3e921b54d524ae69" translate="yes" xml:space="preserve">
          <source>Making printable descriptions of non-printing characters and key sequences.</source>
          <target state="translated">印刷しない文字やキー配列の説明文を印刷可能なものにする。</target>
        </trans-unit>
        <trans-unit id="a8c2048498ddf380173f943840a29bb5648daa3a" translate="yes" xml:space="preserve">
          <source>Making variables and faces customizable.</source>
          <target state="translated">変数や面をカスタマイズできるようにする</target>
        </trans-unit>
        <trans-unit id="f955f72d31d474b19bd9671e9ef2cb781d7e8a14" translate="yes" xml:space="preserve">
          <source>Making windows atomic (see &lt;a href=&quot;atomic-windows#Atomic-Windows&quot;&gt;Atomic Windows&lt;/a&gt;) avoids breaking an existing window composition when popping up a new window. The new window will pop up outside the composition instead.</source>
          <target state="translated">ウィンドウをアトミックにする（&lt;a href=&quot;atomic-windows#Atomic-Windows&quot;&gt;アトミック&lt;/a&gt;ウィンドウを参照）と、新しいウィンドウをポップアップするときに既存のウィンドウ構成が壊れるのを防ぐことができます。代わりに、新しいウィンドウがコンポジションの外にポップアップ表示されます。</target>
        </trans-unit>
        <trans-unit id="e6360d86a643276430e992495fad2c7dbbc295a9" translate="yes" xml:space="preserve">
          <source>Managing Overlays</source>
          <target state="translated">オーバーレイの管理</target>
        </trans-unit>
        <trans-unit id="debda63f7ddcebd0c0dfe38a3022559f7abc90ec" translate="yes" xml:space="preserve">
          <source>Managing a Fixed-Size Ring of Objects</source>
          <target state="translated">固定サイズのリング状のオブジェクトの管理</target>
        </trans-unit>
        <trans-unit id="fdce057e8f54be9a848c2533b0fadb72cdfd78bc" translate="yes" xml:space="preserve">
          <source>Managing a fixed-size ring of objects.</source>
          <target state="translated">固定サイズのリング状のオブジェクトを管理します。</target>
        </trans-unit>
        <trans-unit id="75bd65a788f8528d79762b0605df956da0550547" translate="yes" xml:space="preserve">
          <source>Manipulating Buttons</source>
          <target state="translated">ボタンの操作</target>
        </trans-unit>
        <trans-unit id="e43177bf40b32f1208c84ad9ee839111b074ef8c" translate="yes" xml:space="preserve">
          <source>Manipulating windows and displaying buffers.</source>
          <target state="translated">ウィンドウの操作とバッファの表示</target>
        </trans-unit>
        <trans-unit id="4e836fdc2572ab23d5dc8c36bd613ac6b0f82d63" translate="yes" xml:space="preserve">
          <source>Manual</source>
          <target state="translated">Manual</target>
        </trans-unit>
        <trans-unit id="7492182c02f487bb6ba19f1d0693155fc4bbcfd0" translate="yes" xml:space="preserve">
          <source>Many 32-bit operating systems are limited to system times containing 32 bits of information in their seconds component; these systems typically handle only the times from 1901-12-13 20:45:52 through 2038-01-19 03:14:07 Universal Time. However, 64-bit and some 32-bit operating systems have larger seconds components, and can represent times far in the past or future.</source>
          <target state="translated">多くの32ビットOSは、秒成分に32ビットの情報を含むシステム時刻に制限されています。これらのシステムは、通常、1901-12-13 20:45:52から2038-01-19 03:14:07までの世界標準時の時刻のみを扱います。しかし、64 ビットと一部の 32 ビットのオペレーティングシステムでは、より大きな秒数成分を持ち、過去や未来の時間を表すことができます。</target>
        </trans-unit>
        <trans-unit id="79e5ea61e3cd212d27c82f4613eb12341df1f45d" translate="yes" xml:space="preserve">
          <source>Many alists use lists with two elements, instead of cons cells. For example,</source>
          <target state="translated">多くのリストでは、consセルの代わりに2つの要素を持つリストを使用しています。例えば</target>
        </trans-unit>
        <trans-unit id="cb227181787da48817c942e26d864e081c59be50" translate="yes" xml:space="preserve">
          <source>Many efforts in the design of &lt;code&gt;display-buffer&lt;/code&gt; have been given to maintain compatibility with code that uses older options like &lt;code&gt;pop-up-windows&lt;/code&gt;, &lt;code&gt;pop-up-frames&lt;/code&gt;, &lt;code&gt;pop-up-frame-alist&lt;/code&gt;, &lt;code&gt;same-window-buffer-names&lt;/code&gt; and &lt;code&gt;same-window-regexps&lt;/code&gt;. Lisp Programs and users should refrain from using these options. Above we already warned against customizing &lt;code&gt;pop-up-frame-alist&lt;/code&gt;. Here we describe how to convert the remaining options to use display actions instead.</source>
          <target state="translated">設計に多くの努力 &lt;code&gt;display-buffer&lt;/code&gt; などの用途古いオプションというコードとの互換性を維持するために与えられている &lt;code&gt;pop-up-windows&lt;/code&gt; 、 &lt;code&gt;pop-up-frames&lt;/code&gt; 、 &lt;code&gt;pop-up-frame-alist&lt;/code&gt; 、 &lt;code&gt;same-window-buffer-names&lt;/code&gt; し、 &lt;code&gt;same-window-regexps&lt;/code&gt; 。 Lispプログラムとユーザーはこれらのオプションの使用を控えるべきです。上記では、 &lt;code&gt;pop-up-frame-alist&lt;/code&gt; のカスタマイズに対してすでに警告しています。ここでは、残りのオプションを変換して、代わりに表示アクションを使用する方法について説明します。</target>
        </trans-unit>
        <trans-unit id="4b9ab87576a609558bdd9e7bef4e47ebe7d12419" translate="yes" xml:space="preserve">
          <source>Many filter functions sometimes (or always) insert the output in the process&amp;rsquo;s buffer, mimicking the actions of the default filter. Such filter functions need to make sure that they save the current buffer, select the correct buffer (if different) before inserting output, and then restore the original buffer. They should also check whether the buffer is still alive, update the process marker, and in some cases update the value of point. Here is how to do these things:</source>
          <target state="translated">多くのフィルター関数は、デフォルトのフィルターのアクションを模倣して、プロセスのバッファーに出力を挿入する場合があります（または常に）。このようなフィルター関数は、出力を挿入する前に、現在のバッファーを確実に保存し、正しいバッファー（異なる場合）を選択してから、元のバッファーを復元する必要があります。また、バッファがまだ生きているかどうかを確認し、プロセスマーカーを更新し、場合によってはポイントの値を更新する必要があります。これらの方法は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="bd93bafe41da62c5221706aaaa782fac79369062" translate="yes" xml:space="preserve">
          <source>Many functions are provided to look at the characters around point. Several simple functions are described here. See also &lt;code&gt;looking-at&lt;/code&gt; in &lt;a href=&quot;regexp-search#Regexp-Search&quot;&gt;Regexp Search&lt;/a&gt;.</source>
          <target state="translated">ポイント周辺の文字を見るための機能が多数用意されています。ここでは、いくつかの簡単な関数について説明します。参照してください &lt;code&gt;looking-at&lt;/code&gt; で&lt;a href=&quot;regexp-search#Regexp-Search&quot;&gt;正規表現を検索します&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="99061e430b89d1f2aeaea52a5d8f4cb245b9c411" translate="yes" xml:space="preserve">
          <source>Many functions build lists, as lists reside at the very heart of Lisp. &lt;code&gt;cons&lt;/code&gt; is the fundamental list-building function; however, it is interesting to note that &lt;code&gt;list&lt;/code&gt; is used more times in the source code for Emacs than &lt;code&gt;cons&lt;/code&gt;.</source>
          <target state="translated">リストはLispの中心にあるため、多くの関数がリストを作成します。 &lt;code&gt;cons&lt;/code&gt; は基本的なリスト作成機能です。ただし、Emacsのソースコードでは &lt;code&gt;cons&lt;/code&gt; よりも &lt;code&gt;list&lt;/code&gt; が頻繁に使用されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="b118195a9372d8b227bd6e9ed5773cbb28b54e10" translate="yes" xml:space="preserve">
          <source>Many functions like &lt;code&gt;current-time&lt;/code&gt; and &lt;code&gt;file-attributes&lt;/code&gt; return &lt;em&gt;Lisp timestamp&lt;/em&gt; values that count seconds, and that can represent absolute time by counting seconds since the &lt;em&gt;epoch&lt;/em&gt; of 1970-01-01 00:00:00 UTC.</source>
          <target state="translated">&lt;code&gt;current-time&lt;/code&gt; や &lt;code&gt;file-attributes&lt;/code&gt; のような多くの関数は、秒をカウントする&lt;em&gt;Lispタイムスタンプ&lt;/em&gt;値を返します。これは、1970-01-01 00：00：00UTCの&lt;em&gt;エポック&lt;/em&gt;からの秒をカウントすることで絶対時間を表すことができます。</target>
        </trans-unit>
        <trans-unit id="802952a287eebffddbd929e1038f8cdef315746b" translate="yes" xml:space="preserve">
          <source>Many functions that interact with process objects, (for instance, &lt;code&gt;process-datagram-address&lt;/code&gt;) rely on them at least having a socket before they can return a useful value. These functions will block until the socket has achieved the desired status. The recommended way of interacting with asynchronous sockets is to place a sentinel on the process, and not try to interact with it before it has changed status to &amp;lsquo;</source>
          <target state="translated">プロセスオブジェクトと相互作用する多くの関数（たとえば、 &lt;code&gt;process-datagram-address&lt;/code&gt; ）は、有用な値を返す前に、少なくともソケットを持っていることに依存しています。これらの機能は、ソケットが目的のステータスに達するまでブロックされます。非同期ソケットと対話するための推奨される方法は、プロセスにセンチネルを配置し、ステータスが 'に変わる前にプロセスと対話しようとしないことです。</target>
        </trans-unit>
        <trans-unit id="34060d8cea305615df58234c0c74340b92bdbb96" translate="yes" xml:space="preserve">
          <source>Many of the examples in this manual print text when they are evaluated. If you execute example code in a Lisp Interaction buffer (such as the buffer</source>
          <target state="translated">このマニュアルの例題の多くは、評価されるとテキストが表示されます。Lisp インタラクションバッファ(バッファ</target>
        </trans-unit>
        <trans-unit id="2cb6eeef569da5d2926960dd49593235b8a4de19" translate="yes" xml:space="preserve">
          <source>Many of the file functions take one or more arguments that are file names. A file name is a string. Most of these functions expand file name arguments using the function &lt;code&gt;expand-file-name&lt;/code&gt;, so that</source>
          <target state="translated">ファイル関数の多くは、ファイル名である1つ以上の引数を取ります。ファイル名は文字列です。これらの関数のほとんどは、関数 &lt;code&gt;expand-file-name&lt;/code&gt; を使用してファイル名引数を展開するため、</target>
        </trans-unit>
        <trans-unit id="856002faf420bf01c022be5d9fd84713d7c5ea95" translate="yes" xml:space="preserve">
          <source>Many of the functions described in this chapter accept markers for arguments in place of numbers. (See &lt;a href=&quot;markers#Markers&quot;&gt;Markers&lt;/a&gt;.) Since the actual arguments to such functions may be either numbers or markers, we often give these arguments the name &lt;var&gt;number-or-marker&lt;/var&gt;. When the argument value is a marker, its position value is used and its buffer is ignored.</source>
          <target state="translated">この章で説明する関数の多くは、数値の代わりに引数のマーカーを受け入れます。（&lt;a href=&quot;markers#Markers&quot;&gt;マーカーを&lt;/a&gt;参照してください。）このような関数の実際の引数は数値またはマーカーのいずれかである可能性があるため、これらの引数に数値またはマーカーという名前を付けることがよくあり &lt;var&gt;number-or-marker&lt;/var&gt; 。引数値がマーカーの場合、その位置値が使用され、そのバッファーは無視されます。</target>
        </trans-unit>
        <trans-unit id="ede60666649bf60156d4a427812b20ad852466a6" translate="yes" xml:space="preserve">
          <source>Many of the specialized editing and I/O facilities of Emacs accept only strings. For example, you cannot insert a vector of characters into a buffer the way you can insert a string. See &lt;a href=&quot;strings-and-characters#Strings-and-Characters&quot;&gt;Strings and Characters&lt;/a&gt;.</source>
          <target state="translated">Emacsの特殊な編集およびI / O機能の多くは、文字列のみを受け入れます。たとえば、文字列を挿入する方法で文字のベクトルをバッファに挿入することはできません。&lt;a href=&quot;strings-and-characters#Strings-and-Characters&quot;&gt;文字列と文字を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="3629e89080e09e327cdd6dfb7f47d74e11faec96" translate="yes" xml:space="preserve">
          <source>Many of the standard Emacs functions manipulate or test the characters in the current buffer; a whole chapter in this manual is devoted to describing these functions (see &lt;a href=&quot;text#Text&quot;&gt;Text&lt;/a&gt;).</source>
          <target state="translated">標準のEmacs関数の多くは、現在のバッファー内の文字を操作またはテストします。このマニュアルの全章は、これらの機能の説明に専念しています（&lt;a href=&quot;text#Text&quot;&gt;テキストを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="d945fb20602aed4abd69b2e84e025e54ece264be" translate="yes" xml:space="preserve">
          <source>Many of the valid output streams are also valid as input streams. The difference between input and output streams is therefore more a matter of how you use a Lisp object, than of different types of object.</source>
          <target state="translated">有効な出力ストリームの多くは入力ストリームとしても有効です。したがって、入力ストリームと出力ストリームの違いは、オブジェクトの種類の違いというよりも、Lispオブジェクトの使い方の問題になります。</target>
        </trans-unit>
        <trans-unit id="f337e3c741b2e5363e4452e88afb97f9e466bc3f" translate="yes" xml:space="preserve">
          <source>Many overlay properties have special meanings; here is a table of them:</source>
          <target state="translated">多くのオーバーレイプロパティには特別な意味があります。</target>
        </trans-unit>
        <trans-unit id="28669a5c2141fd75140a0f1efc7ec3dc89659c90" translate="yes" xml:space="preserve">
          <source>Many text-related functions operate on a region of text defined by two buffer positions passed in arguments named &lt;var&gt;start&lt;/var&gt; and &lt;var&gt;end&lt;/var&gt;. These arguments should be either markers (see &lt;a href=&quot;markers#Markers&quot;&gt;Markers&lt;/a&gt;) or numeric character positions (see &lt;a href=&quot;positions#Positions&quot;&gt;Positions&lt;/a&gt;). The order of these arguments does not matter; it is all right for &lt;var&gt;start&lt;/var&gt; to be the end of the region and &lt;var&gt;end&lt;/var&gt; the beginning. For example, &lt;code&gt;(delete-region 1
10)&lt;/code&gt; and &lt;code&gt;(delete-region 10 1)&lt;/code&gt; are equivalent. An &lt;code&gt;args-out-of-range&lt;/code&gt; error is signaled if either &lt;var&gt;start&lt;/var&gt; or &lt;var&gt;end&lt;/var&gt; is outside the accessible portion of the buffer. In an interactive call, point and the mark are used for these arguments.</source>
          <target state="translated">多くのテキスト関連関数は、 &lt;var&gt;start&lt;/var&gt; および &lt;var&gt;end&lt;/var&gt; という名前の引数で渡される2つのバッファー位置によって定義されるテキストの領域で動作します。これらの引数は、マーカー（参照のいずれかでなければなりません&lt;a href=&quot;markers#Markers&quot;&gt;マーカーを&lt;/a&gt;（参照）、または数値文字位置&lt;a href=&quot;positions#Positions&quot;&gt;体位&lt;/a&gt;）。これらの引数の順序は重要ではありません。 &lt;var&gt;start&lt;/var&gt; が地域の &lt;var&gt;end&lt;/var&gt; 、始まりであることが大丈夫です。たとえば、 &lt;code&gt;(delete-region 1 10)&lt;/code&gt; と &lt;code&gt;(delete-region 10 1)&lt;/code&gt; は同等です。 &lt;var&gt;start&lt;/var&gt; または &lt;var&gt;end&lt;/var&gt; いずれか &lt;code&gt;args-out-of-range&lt;/code&gt; の引数エラーが通知されますバッファのアクセス可能な部分の外側にあります。対話型の呼び出しでは、ポイントとマークがこれらの引数に使用されます。</target>
        </trans-unit>
        <trans-unit id="6ed3e3bf0cc6abbeb7fc11924e0595f7cbb9b258" translate="yes" xml:space="preserve">
          <source>Many window-systems are not able to change the opacity (see &lt;a href=&quot;font-and-color-parameters#Font-and-Color-Parameters&quot;&gt;Font and Color Parameters&lt;/a&gt;) of child frames.</source>
          <target state="translated">多くのウィンドウシステムは、子フレームの不透明度（&lt;a href=&quot;font-and-color-parameters#Font-and-Color-Parameters&quot;&gt;フォントと色のパラメータを&lt;/a&gt;参照）を変更できません。</target>
        </trans-unit>
        <trans-unit id="213b455d1f0caf22fcf0e2374a037400baed7c91" translate="yes" xml:space="preserve">
          <source>Mapping Functions</source>
          <target state="translated">マッピング機能</target>
        </trans-unit>
        <trans-unit id="7b7987be97e32819225bc7a4606b16bf612de0b6" translate="yes" xml:space="preserve">
          <source>Mapping for such special cases are taken from &lt;code&gt;special-uppercase&lt;/code&gt;, &lt;code&gt;special-lowercase&lt;/code&gt; and &lt;code&gt;special-titlecase&lt;/code&gt; See &lt;a href=&quot;character-properties#Character-Properties&quot;&gt;Character Properties&lt;/a&gt;.</source>
          <target state="translated">このような特殊なケースのマッピングは、 &lt;code&gt;special-lowercase&lt;/code&gt; &lt;code&gt;special-uppercase&lt;/code&gt; 、特殊小文字、および &lt;code&gt;special-titlecase&lt;/code&gt; から取得され&lt;a href=&quot;character-properties#Character-Properties&quot;&gt;ます&lt;/a&gt;。文字のプロパティを参照してください。</target>
        </trans-unit>
        <trans-unit id="f093ddf02abeed7e13d39bb01f441baf4324273f" translate="yes" xml:space="preserve">
          <source>Margins for Filling</source>
          <target state="translated">充填のためのマージン</target>
        </trans-unit>
        <trans-unit id="e693e76b5d2e33add6fdff9ff18a57f6b466043e" translate="yes" xml:space="preserve">
          <source>Mark set</source>
          <target state="translated">マークセット</target>
        </trans-unit>
        <trans-unit id="40c9d9aab143333b8799668f89011a977e366648" translate="yes" xml:space="preserve">
          <source>Mark the function or macro as obsolete, similar to a call to &lt;code&gt;make-obsolete&lt;/code&gt; (see &lt;a href=&quot;obsolete-functions#Obsolete-Functions&quot;&gt;Obsolete Functions&lt;/a&gt;). &lt;var&gt;current-name&lt;/var&gt; should be a symbol (in which case the warning message says to use that instead), a string (specifying the warning message), or &lt;code&gt;nil&lt;/code&gt; (in which case the warning message gives no extra details). &lt;var&gt;when&lt;/var&gt; should be a string indicating when the function or macro was first made obsolete.</source>
          <target state="translated">&lt;code&gt;make-obsolete&lt;/code&gt; の呼び出しと同様に、関数またはマクロを廃止としてマークします（&lt;a href=&quot;obsolete-functions#Obsolete-Functions&quot;&gt;廃止された関数を&lt;/a&gt;参照）。 &lt;var&gt;current-name&lt;/var&gt; は、記号（この場合、警告メッセージは代わりにそれを使用するように指示します）、文字列（警告メッセージを指定）、または &lt;code&gt;nil&lt;/code&gt; （この場合、警告メッセージは追加の詳細を提供しません）である必要があります。 &lt;var&gt;when&lt;/var&gt; は、関数またはマクロが最初に廃止された時期を示す文字列である必要があります。</target>
        </trans-unit>
        <trans-unit id="75ec2d229775005fdc921c3a210ff1b8c8b13b6e" translate="yes" xml:space="preserve">
          <source>Marker Insertion Types</source>
          <target state="translated">マーカ挿入タイプ</target>
        </trans-unit>
        <trans-unit id="20a369b8d549cf56bd368b32f6f9b7f7febde165" translate="yes" xml:space="preserve">
          <source>Marker Type</source>
          <target state="translated">マーカタイプ</target>
        </trans-unit>
        <trans-unit id="c64fa883b0b011047af44d0deea4165129c087b1" translate="yes" xml:space="preserve">
          <source>Markers</source>
          <target state="translated">Markers</target>
        </trans-unit>
        <trans-unit id="3a15c9c37c23f1de054f9f2fb2d0661fb9245c11" translate="yes" xml:space="preserve">
          <source>Markers have no read syntax. They print in hash notation, giving the current character position and the name of the buffer.</source>
          <target state="translated">マーカーには読み込み構文はありません。マーカーはハッシュ表記で表示され、現在の文字の位置とバッファの名前が表示されます。</target>
        </trans-unit>
        <trans-unit id="90ec4189b2e9a955fa94b8f4c8d3ea5a03189fdd" translate="yes" xml:space="preserve">
          <source>Markers pointing into any sort records are left with no useful position after &lt;code&gt;sort-subr&lt;/code&gt; returns.</source>
          <target state="translated">&lt;code&gt;sort-subr&lt;/code&gt; が戻った後、ソートレコードを指すマーカーは有用な位置がなくなります。</target>
        </trans-unit>
        <trans-unit id="c6e97fbd0e2de79918f6c8ca8bf38d32ac3071bf" translate="yes" xml:space="preserve">
          <source>Markers represent positions and update automatically when the text is changed.</source>
          <target state="translated">マーカーは位置を表し、テキストが変更されると自動的に更新されます。</target>
        </trans-unit>
        <trans-unit id="c3ffcb290c16e09210daad56e90773ef95a42fa0" translate="yes" xml:space="preserve">
          <source>Marking multiline chunks with a text property.</source>
          <target state="translated">複数行のチャンクをテキストプロパティでマークします。</target>
        </trans-unit>
        <trans-unit id="adb842e548d37ba30e15d8d71ecca123602b790c" translate="yes" xml:space="preserve">
          <source>Marks the selected window as non-dedicated and proceeds.</source>
          <target state="translated">選択したウィンドウを非専用ウィンドウとしてマークして続行します。</target>
        </trans-unit>
        <trans-unit id="63136e6c72133709fdd14fe590280a9e7adfb5ae" translate="yes" xml:space="preserve">
          <source>Match &lt;var&gt;rx&lt;/var&gt;, with &lt;code&gt;zero-or-more&lt;/code&gt;, &lt;code&gt;0+&lt;/code&gt;, &lt;code&gt;one-or-more&lt;/code&gt;, &lt;code&gt;1+&lt;/code&gt;, &lt;code&gt;zero-or-one&lt;/code&gt;, &lt;code&gt;opt&lt;/code&gt; and &lt;code&gt;optional&lt;/code&gt; using greedy matching. This is the default.</source>
          <target state="translated">一致が &lt;var&gt;rx&lt;/var&gt; と、 &lt;code&gt;zero-or-more&lt;/code&gt; 、 &lt;code&gt;0+&lt;/code&gt; 、 &lt;code&gt;one-or-more&lt;/code&gt; 、 &lt;code&gt;1+&lt;/code&gt; 、 &lt;code&gt;zero-or-one&lt;/code&gt; 、 &lt;code&gt;opt&lt;/code&gt; および &lt;code&gt;optional&lt;/code&gt; 貪欲マッチングを使用します。これがデフォルトです。</target>
        </trans-unit>
        <trans-unit id="2e1d4ec9e304a391aeeff942a7e3f04f60b8de56" translate="yes" xml:space="preserve">
          <source>Match &lt;var&gt;rx&lt;/var&gt;, with &lt;code&gt;zero-or-more&lt;/code&gt;, &lt;code&gt;0+&lt;/code&gt;, &lt;code&gt;one-or-more&lt;/code&gt;, &lt;code&gt;1+&lt;/code&gt;, &lt;code&gt;zero-or-one&lt;/code&gt;, &lt;code&gt;opt&lt;/code&gt; and &lt;code&gt;optional&lt;/code&gt; using non-greedy matching.</source>
          <target state="translated">一致が &lt;var&gt;rx&lt;/var&gt; と、 &lt;code&gt;zero-or-more&lt;/code&gt; 、 &lt;code&gt;0+&lt;/code&gt; 、 &lt;code&gt;one-or-more&lt;/code&gt; 、 &lt;code&gt;1+&lt;/code&gt; 、 &lt;code&gt;zero-or-one&lt;/code&gt; 、 &lt;code&gt;opt&lt;/code&gt; および &lt;code&gt;optional&lt;/code&gt; による非貪欲マッチング。</target>
        </trans-unit>
        <trans-unit id="71abe0286e229c1d876f4a021f7e016ea6b1fc99" translate="yes" xml:space="preserve">
          <source>Match a character from a named character class:</source>
          <target state="translated">名前付き文字クラスの文字にマッチします。</target>
        </trans-unit>
        <trans-unit id="ad6d6fc231dbd73dfc165b65f61e36d58bad1af7" translate="yes" xml:space="preserve">
          <source>Match a character in category &lt;var&gt;category&lt;/var&gt;, which is either one of the names below or its category character.</source>
          <target state="translated">以下の名前のいずれかまたはそのカテゴリ文字であるカテゴリ &lt;var&gt;category&lt;/var&gt; 文字と一致します。</target>
        </trans-unit>
        <trans-unit id="de8031dd3712abe87445e83aadf5d0e6910dc120" translate="yes" xml:space="preserve">
          <source>Match a character included in all of the &lt;var&gt;charset&lt;/var&gt;s. Each &lt;var&gt;charset&lt;/var&gt; can be a character, a single-character string, an &lt;code&gt;any&lt;/code&gt; form without character classes, or an &lt;code&gt;intersection&lt;/code&gt;, &lt;code&gt;or&lt;/code&gt; or &lt;code&gt;not&lt;/code&gt; form whose arguments are also &lt;var&gt;charset&lt;/var&gt;s.</source>
          <target state="translated">すべての &lt;var&gt;charset&lt;/var&gt; 含まれる文字に一致します。各 &lt;var&gt;charset&lt;/var&gt; 、文字、単一文字の文字列とすることができる &lt;code&gt;any&lt;/code&gt; 文字クラスのないフォーム、または &lt;code&gt;intersection&lt;/code&gt; 、 &lt;code&gt;or&lt;/code&gt; か &lt;code&gt;not&lt;/code&gt; その引数でもある形 &lt;var&gt;charset&lt;/var&gt; 秒。</target>
        </trans-unit>
        <trans-unit id="1d6ce8155afacb2f041062878ec1c97fa63888c6" translate="yes" xml:space="preserve">
          <source>Match a character not included in &lt;var&gt;charspec&lt;/var&gt;. &lt;var&gt;charspec&lt;/var&gt; can be a character, a single-character string, an &lt;code&gt;any&lt;/code&gt;, &lt;code&gt;not&lt;/code&gt;, &lt;code&gt;or&lt;/code&gt;, &lt;code&gt;intersection&lt;/code&gt;, &lt;code&gt;syntax&lt;/code&gt; or &lt;code&gt;category&lt;/code&gt; form, or a character class. If &lt;var&gt;charspec&lt;/var&gt; is an &lt;code&gt;or&lt;/code&gt; form, its arguments have the same restrictions as those of &lt;code&gt;intersection&lt;/code&gt;; see below. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">&lt;var&gt;charspec&lt;/var&gt; に含まれていない文字に一致します。 &lt;var&gt;charspec&lt;/var&gt; は、文字、単一文字の文字列とすることができる &lt;code&gt;any&lt;/code&gt; 、 &lt;code&gt;not&lt;/code&gt; 、 &lt;code&gt;or&lt;/code&gt; 、 &lt;code&gt;intersection&lt;/code&gt; 、 &lt;code&gt;syntax&lt;/code&gt; または &lt;code&gt;category&lt;/code&gt; フォーム、または文字クラス。場合 &lt;var&gt;charspec&lt;/var&gt; がある &lt;code&gt;or&lt;/code&gt; の形、その引数は、のと同じ制限があり &lt;code&gt;intersection&lt;/code&gt; 。下記参照。対応する文字列正規表現： '</target>
        </trans-unit>
        <trans-unit id="20528df965fcdab88638f3141ed3bb0a4816a094" translate="yes" xml:space="preserve">
          <source>Match a character with syntax &lt;var&gt;syntax&lt;/var&gt;, being one of the following names:</source>
          <target state="translated">次のいずれかの名前の文字を構文 &lt;var&gt;syntax&lt;/var&gt; と一致させます。</target>
        </trans-unit>
        <trans-unit id="d97d65b8ec18624513dc0b5597c7a311786d6e2f" translate="yes" xml:space="preserve">
          <source>Match a single character from one of the &lt;var&gt;set&lt;/var&gt;s. Each &lt;var&gt;set&lt;/var&gt; is a character, a string representing the set of its characters, a range or a character class (see below). A range is either a hyphen-separated string like &lt;code&gt;&quot;A-Z&quot;&lt;/code&gt;, or a cons of characters like &lt;code&gt;(?A . ?Z)&lt;/code&gt;.</source>
          <target state="translated">&lt;var&gt;set&lt;/var&gt; の1つから1文字を一致させます。各 &lt;var&gt;set&lt;/var&gt; は、文字、その文字のセットを表す文字列、範囲、または文字クラスです（以下を参照）。範囲は、 &lt;code&gt;&quot;A-Z&quot;&lt;/code&gt; ようなハイフンで区切られた文字列、または &lt;code&gt;(?A . ?Z)&lt;/code&gt; ような文字の短所のいずれかです。</target>
        </trans-unit>
        <trans-unit id="2dd2fbec99fc2ab616903412ba0cff721c4c9e90" translate="yes" xml:space="preserve">
          <source>Match alphabetic characters and digits. More precisely, match characters whose Unicode &amp;lsquo;</source>
          <target state="translated">アルファベットと数字を一致させます。より正確には、Unicode 'の文字を一致させます</target>
        </trans-unit>
        <trans-unit id="82708ce98f9d023741d282ec7721747edbd6f773" translate="yes" xml:space="preserve">
          <source>Match alphabetic characters. More precisely, match characters whose Unicode &amp;lsquo;</source>
          <target state="translated">アルファベット文字と一致します。より正確には、Unicode 'の文字を一致させます</target>
        </trans-unit>
        <trans-unit id="8bb62c1f38a88090666bab18fcce11f7a820ad8a" translate="yes" xml:space="preserve">
          <source>Match any</source>
          <target state="translated">任意のものにマッチします。</target>
        </trans-unit>
        <trans-unit id="c6bedd2c326b64596143cbeea5bbc65702a26806" translate="yes" xml:space="preserve">
          <source>Match any character except a newline. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">改行以外の任意の文字に一致します。対応する文字列正規表現： '</target>
        </trans-unit>
        <trans-unit id="cc22989554162915a08cc2b0ae06291b07457a73" translate="yes" xml:space="preserve">
          <source>Match any character except whitespace,</source>
          <target state="translated">空白以外の任意の文字にマッチします。</target>
        </trans-unit>
        <trans-unit id="7e7f303c256818204aa47a2cf16fd245fafcb2e6" translate="yes" xml:space="preserve">
          <source>Match any character that has whitespace syntax (see &lt;a href=&quot;syntax-class-table#Syntax-Class-Table&quot;&gt;Syntax Class Table&lt;/a&gt;).</source>
          <target state="translated">空白構文を持つ任意の文字に一致します（&lt;a href=&quot;syntax-class-table#Syntax-Class-Table&quot;&gt;構文クラス表を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="20fbfb2c118e7dfaf594921c0c9ef8d863759b77" translate="yes" xml:space="preserve">
          <source>Match any character that has word syntax (see &lt;a href=&quot;syntax-class-table#Syntax-Class-Table&quot;&gt;Syntax Class Table&lt;/a&gt;).</source>
          <target state="translated">単語構文を持つ任意の文字に一致します（&lt;a href=&quot;syntax-class-table#Syntax-Class-Table&quot;&gt;構文クラス表を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="68242dc98a557b85cf91e4b3c6ac38743362dde2" translate="yes" xml:space="preserve">
          <source>Match any character whose code is in the range 0&amp;ndash;31.</source>
          <target state="translated">コードが0〜31の範囲にある任意の文字に一致します。</target>
        </trans-unit>
        <trans-unit id="a9facac9ba78f72ef2c064b0654d33707cf5d808" translate="yes" xml:space="preserve">
          <source>Match any character. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">任意の文字に一致します。対応する文字列正規表現： '</target>
        </trans-unit>
        <trans-unit id="d134eaf7cc09f30a884da1beb70b95fea1c42f48" translate="yes" xml:space="preserve">
          <source>Match any non-</source>
          <target state="translated">任意の非表示を一致させる</target>
        </trans-unit>
        <trans-unit id="ef8bad91a3175348513872b6c54736f0c4acdee3" translate="yes" xml:space="preserve">
          <source>Match any punctuation character. (At present, for multibyte characters, anything that has non-word syntax.)</source>
          <target state="translated">任意の句読点文字にマッチします。(現時点では、マルチバイト文字の場合は、単語以外の構文を持つものは何でも)</target>
        </trans-unit>
        <trans-unit id="b234e5cee3141027589e4ab45ac9e2ef3aef0df9" translate="yes" xml:space="preserve">
          <source>Match anything lower-case, as determined by the current case table. If &lt;code&gt;case-fold-search&lt;/code&gt; is non-nil, this also matches any upper-case letter.</source>
          <target state="translated">現在の大文字小文字の表で決定されているように、小文字に一致します。場合 &lt;code&gt;case-fold-search&lt;/code&gt; 非nilで、これはまた、任意の大文字と一致します。</target>
        </trans-unit>
        <trans-unit id="b2217b7ab7ecff3396b14564129755a0ed8ebb52" translate="yes" xml:space="preserve">
          <source>Match anything upper-case, as determined by the current case table. If &lt;code&gt;case-fold-search&lt;/code&gt; is non-nil, this also matches any lower-case letter.</source>
          <target state="translated">現在の大文字小文字の表によって決定されるように、大文字のすべてに一致します。場合 &lt;code&gt;case-fold-search&lt;/code&gt; 非nilで、これはまた、任意の小文字に一致します。</target>
        </trans-unit>
        <trans-unit id="407d34a704815e72fde4647d011a88e9c5656f33" translate="yes" xml:space="preserve">
          <source>Match anywhere but at the beginning or end of a word. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">単語の最初または最後以外の場所に一致します。対応する文字列正規表現： '</target>
        </trans-unit>
        <trans-unit id="a152ee853f24a37ea457df3b8d2fdc8d7fc9b34c" translate="yes" xml:space="preserve">
          <source>Match at point. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">ポイントで一致します。対応する文字列正規表現： '</target>
        </trans-unit>
        <trans-unit id="f259a5bdb641748dc6291dbf1194b2479f6cc58c" translate="yes" xml:space="preserve">
          <source>Match at the beginning of a line. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">行頭で一致します。対応する文字列正規表現： '</target>
        </trans-unit>
        <trans-unit id="381a3b6056cd0802e4c2d50199de3b52bc4cc745" translate="yes" xml:space="preserve">
          <source>Match at the beginning of a symbol. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">記号の先頭で一致します。対応する文字列正規表現： '</target>
        </trans-unit>
        <trans-unit id="06202c9463fb84fe0562bd42d6d713a2880e374b" translate="yes" xml:space="preserve">
          <source>Match at the beginning of a word. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">単語の先頭で一致します。対応する文字列正規表現： '</target>
        </trans-unit>
        <trans-unit id="96950b0283f2ce0a0d3b906dc2439e842ea803e8" translate="yes" xml:space="preserve">
          <source>Match at the beginning or end of a word. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">単語の最初または最後に一致します。対応する文字列正規表現： '</target>
        </trans-unit>
        <trans-unit id="44efaac71dd0cf46b4e63e407bdb35817ac76578" translate="yes" xml:space="preserve">
          <source>Match at the end of a line. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">行の終わりで一致します。対応する文字列正規表現： '</target>
        </trans-unit>
        <trans-unit id="290249cf5c2235f1cd6f27816d45a80df534d2c5" translate="yes" xml:space="preserve">
          <source>Match at the end of a symbol. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">記号の末尾で一致します。対応する文字列正規表現： '</target>
        </trans-unit>
        <trans-unit id="e8ba6be4fdd0b132f04646bba49b7c6fc783a283" translate="yes" xml:space="preserve">
          <source>Match at the end of a word. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">単語の終わりに一致します。対応する文字列正規表現： '</target>
        </trans-unit>
        <trans-unit id="c43211f21a3160a9d519576413e4b08b88f31ae7" translate="yes" xml:space="preserve">
          <source>Match at the end of the string or buffer being matched against. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">照合対象の文字列またはバッファの最後で照合します。対応する文字列正規表現： '</target>
        </trans-unit>
        <trans-unit id="8efde31ba8632a39a1c15dd9f32b844f802c7c3d" translate="yes" xml:space="preserve">
          <source>Match at the start of the string or buffer being matched against. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">照合対象の文字列またはバッファの先頭で照合します。対応する文字列正規表現： '</target>
        </trans-unit>
        <trans-unit id="b731924293870a882dd28691dfcda9844f7ce67b" translate="yes" xml:space="preserve">
          <source>Match exactly one of the &lt;var&gt;rx&lt;/var&gt;s. If all arguments are strings, characters, or &lt;code&gt;or&lt;/code&gt; forms so constrained, the longest possible match will always be used. Otherwise, either the longest match or the first (in left-to-right order) will be used. Without arguments, the expression will not match anything at all. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">&lt;var&gt;rx&lt;/var&gt; の1つと正確に一致します。すべての引数が文字列、文字、またはある場合 &lt;code&gt;or&lt;/code&gt; 制約のでフォームは、可能な限り長いマッチが常に使用されます。それ以外の場合は、最長の一致または最初の一致（左から右の順序）のいずれかが使用されます。引数がないと、式は何にも一致しません。対応する文字列正規表現： '</target>
        </trans-unit>
        <trans-unit id="7248472c4540b5bb98fb3d7078116ee5540becd2" translate="yes" xml:space="preserve">
          <source>Match horizontal whitespace. More precisely, match characters whose Unicode &amp;lsquo;</source>
          <target state="translated">水平方向の空白に一致します。より正確には、Unicode '</target>
        </trans-unit>
        <trans-unit id="39ffee8a3eb0d7a19803afa6abf19912b7bfc01e" translate="yes" xml:space="preserve">
          <source>Match the &lt;var&gt;rx&lt;/var&gt;s &lt;var&gt;n&lt;/var&gt; or more times. Greedy. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">一致 &lt;var&gt;rx&lt;/var&gt; S &lt;var&gt;n&lt;/var&gt; 回以上。貪欲。対応する文字列正規表現： '</target>
        </trans-unit>
        <trans-unit id="88b7d7bd4b35ad1b528a3b8246e2f6305909616e" translate="yes" xml:space="preserve">
          <source>Match the &lt;var&gt;rx&lt;/var&gt;s at least &lt;var&gt;n&lt;/var&gt; but no more than &lt;var&gt;m&lt;/var&gt; times. Greedy. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">一致 &lt;var&gt;rx&lt;/var&gt; の少なくとも &lt;var&gt;n&lt;/var&gt; 個が、せいぜい &lt;var&gt;m&lt;/var&gt; 時間を。貪欲。対応する文字列正規表現： '</target>
        </trans-unit>
        <trans-unit id="de1b336fa7f4a968c25a0903b00419f673937ea9" translate="yes" xml:space="preserve">
          <source>Match the &lt;var&gt;rx&lt;/var&gt;s exactly &lt;var&gt;n&lt;/var&gt; times. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">&lt;var&gt;rx&lt;/var&gt; を正確に &lt;var&gt;n&lt;/var&gt; 回一致させます。対応する文字列正規表現： '</target>
        </trans-unit>
        <trans-unit id="54969cf7c5583dafecdf62c967082837d0ecd45e" translate="yes" xml:space="preserve">
          <source>Match the &lt;var&gt;rx&lt;/var&gt;s in sequence. Without arguments, the expression matches the empty string. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">&lt;var&gt;rx&lt;/var&gt; を順番に一致させます。引数がない場合、式は空の文字列と一致します。対応する文字列正規表現： '</target>
        </trans-unit>
        <trans-unit id="812a5d6c5321c4869a91d7591bbf90a4ff04128c" translate="yes" xml:space="preserve">
          <source>Match the &lt;var&gt;rx&lt;/var&gt;s once or an empty string. Greedy by default. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">&lt;var&gt;rx&lt;/var&gt; を1回一致させるか、空の文字列に一致させます。デフォルトでは貪欲です。対応する文字列正規表現： '</target>
        </trans-unit>
        <trans-unit id="9d0e81755a90f55e663c35482e9b674dfc7de4d6" translate="yes" xml:space="preserve">
          <source>Match the &lt;var&gt;rx&lt;/var&gt;s once or an empty string. Greedy. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">&lt;var&gt;rx&lt;/var&gt; を1回一致させるか、空の文字列に一致させます。貪欲。対応する文字列正規表現： '</target>
        </trans-unit>
        <trans-unit id="fd8b263c55e5ec0df49c18d0e47fbf0a1224d33d" translate="yes" xml:space="preserve">
          <source>Match the &lt;var&gt;rx&lt;/var&gt;s one or more times. Greedy by default. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">&lt;var&gt;rx&lt;/var&gt; を1回以上一致させます。デフォルトでは貪欲です。対応する文字列正規表現： '</target>
        </trans-unit>
        <trans-unit id="2490a514c7217f45471d9b7c69875762fbd73841" translate="yes" xml:space="preserve">
          <source>Match the &lt;var&gt;rx&lt;/var&gt;s one or more times. Greedy. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">&lt;var&gt;rx&lt;/var&gt; を1回以上一致させます。貪欲。対応する文字列正規表現： '</target>
        </trans-unit>
        <trans-unit id="5f0c30af008a7a0ac54edf6206107e136e38294e" translate="yes" xml:space="preserve">
          <source>Match the &lt;var&gt;rx&lt;/var&gt;s one or more times. Non-greedy. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">&lt;var&gt;rx&lt;/var&gt; を1回以上一致させます。貪欲ではありません。対応する文字列正規表現： '</target>
        </trans-unit>
        <trans-unit id="83cd886da13deacda47e2fa48ca143a7370599e2" translate="yes" xml:space="preserve">
          <source>Match the &lt;var&gt;rx&lt;/var&gt;s or an empty string. Non-greedy. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">&lt;var&gt;rx&lt;/var&gt; または空の文字列に一致します。貪欲ではありません。対応する文字列正規表現： '</target>
        </trans-unit>
        <trans-unit id="3ab134fd7cf12648498ed41926f7c6ef78bd3c0f" translate="yes" xml:space="preserve">
          <source>Match the &lt;var&gt;rx&lt;/var&gt;s zero or more times. Greedy by default. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">&lt;var&gt;rx&lt;/var&gt; を0回以上一致させます。デフォルトでは貪欲です。対応する文字列正規表現： '</target>
        </trans-unit>
        <trans-unit id="d5a7ac9731ccc96d5cf2d592aa59dafb6c31bd41" translate="yes" xml:space="preserve">
          <source>Match the &lt;var&gt;rx&lt;/var&gt;s zero or more times. Greedy. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">&lt;var&gt;rx&lt;/var&gt; を0回以上一致させます。貪欲。対応する文字列正規表現： '</target>
        </trans-unit>
        <trans-unit id="f105243e42ef3ab66e32f5d3b154f392aaed42cc" translate="yes" xml:space="preserve">
          <source>Match the &lt;var&gt;rx&lt;/var&gt;s zero or more times. Non-greedy. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">&lt;var&gt;rx&lt;/var&gt; を0回以上一致させます。貪欲ではありません。対応する文字列正規表現： '</target>
        </trans-unit>
        <trans-unit id="5fe3267ec0ff2cb20b90f39f1574039c8a4d6b35" translate="yes" xml:space="preserve">
          <source>Match the &lt;var&gt;rx&lt;/var&gt;s, making the matched text and position accessible in the match data. The first group in a regexp is numbered 1; subsequent groups will be numbered one higher than the previous group. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">一致 &lt;var&gt;rx&lt;/var&gt; マッチデータでマッチしたテキストと位置がアクセスできる、秒。正規表現の最初のグループには1の番号が付けられています。後続のグループには、前のグループより1つ大きい番号が付けられます。対応する文字列正規表現： '</target>
        </trans-unit>
        <trans-unit id="d7ef5aa9b8bbb06530907d3195d5d192d80e7284" translate="yes" xml:space="preserve">
          <source>Match the character &amp;lsquo;</source>
          <target state="translated">文字に一致する '</target>
        </trans-unit>
        <trans-unit id="40ed76ce7b1c68d6b3c8c8bd4b855cfc96f6c033" translate="yes" xml:space="preserve">
          <source>Match the digits &amp;lsquo;</source>
          <target state="translated">数字を一致させる '</target>
        </trans-unit>
        <trans-unit id="365ffcf90847f5dfedeacb92fb74bfd5ac33dc8a" translate="yes" xml:space="preserve">
          <source>Match the hexadecimal digits &amp;lsquo;</source>
          <target state="translated">16進数に一致する '</target>
        </trans-unit>
        <trans-unit id="4a6978bcd14cd4f93782a8738d7349ba0d760be5" translate="yes" xml:space="preserve">
          <source>Match the literal string that is the result from evaluating the Lisp expression &lt;var&gt;expr&lt;/var&gt;. The evaluation takes place at call time, in the current lexical environment.</source>
          <target state="translated">Lisp式 &lt;var&gt;expr&lt;/var&gt; を評価した結果であるリテラル文字列と一致します。評価は、現在の字句環境で、呼び出し時に行われます。</target>
        </trans-unit>
        <trans-unit id="1b502a84ddadc23f3da402b6793e0b908501bce7" translate="yes" xml:space="preserve">
          <source>Match the rx form that is the result from evaluating the Lisp expression &lt;var&gt;expr&lt;/var&gt;. The evaluation takes place at macro-expansion time for &lt;code&gt;rx&lt;/code&gt;, at call time for &lt;code&gt;rx-to-string&lt;/code&gt;, in the current global environment.</source>
          <target state="translated">Lisp式 &lt;var&gt;expr&lt;/var&gt; を評価した結果であるrx形式に一致します。評価は、現在のグローバル環境で、 &lt;code&gt;rx&lt;/code&gt; のマクロ展開時、 &lt;code&gt;rx-to-string&lt;/code&gt; の呼び出し時に行われます。</target>
        </trans-unit>
        <trans-unit id="3205c51d28824b4cbb8711f257894d8bb4c2f6f1" translate="yes" xml:space="preserve">
          <source>Match the string &amp;lsquo;</source>
          <target state="translated">文字列に一致する '</target>
        </trans-unit>
        <trans-unit id="7b75719d500955e334549481f6c7ea7b50a1ad73" translate="yes" xml:space="preserve">
          <source>Match the string regexp that is the result from evaluating the Lisp expression &lt;var&gt;expr&lt;/var&gt;. The evaluation takes place at call time, in the current lexical environment.</source>
          <target state="translated">Lisp式 &lt;var&gt;expr&lt;/var&gt; を評価した結果である文字列regexpと一致します。評価は、現在の字句環境で、呼び出し時に行われます。</target>
        </trans-unit>
        <trans-unit id="ae757acb76ba91417eef2b42ffb76c4521c4b810" translate="yes" xml:space="preserve">
          <source>Match the text previously matched by group number &lt;var&gt;n&lt;/var&gt;. &lt;var&gt;n&lt;/var&gt; must be in the range 1&amp;ndash;9. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">以前にグループ番号 &lt;var&gt;n&lt;/var&gt; で一致したテキストと一致します。 &lt;var&gt;n&lt;/var&gt; は1〜9の範囲でなければなりません。対応する文字列正規表現： '</target>
        </trans-unit>
        <trans-unit id="a9d49dbe39ad1efa260b09b12e904b32531ad43c" translate="yes" xml:space="preserve">
          <source>Match whitespace or a character matched by &lt;code&gt;graph&lt;/code&gt;.</source>
          <target state="translated">空白または &lt;code&gt;graph&lt;/code&gt; と一致する文字に一致します。</target>
        </trans-unit>
        <trans-unit id="54273900d77a58b496b801254cfc591edb749bf9" translate="yes" xml:space="preserve">
          <source>Matches any &lt;var&gt;expval&lt;/var&gt;, and additionally let-binds &lt;var&gt;symbol&lt;/var&gt; to &lt;var&gt;expval&lt;/var&gt;, such that this binding is available to &lt;var&gt;body-forms&lt;/var&gt; (see &lt;a href=&quot;dynamic-binding#Dynamic-Binding&quot;&gt;Dynamic Binding&lt;/a&gt;).</source>
          <target state="translated">任意の &lt;var&gt;expval&lt;/var&gt; に一致し、さらにlet- &lt;var&gt;expval&lt;/var&gt; &lt;var&gt;symbol&lt;/var&gt; をexpvalに一致させて、このバインディングを &lt;var&gt;body-forms&lt;/var&gt; 使用できるようにします（&lt;a href=&quot;dynamic-binding#Dynamic-Binding&quot;&gt;動的バインディングを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="132befd5d9407a174f4ad033d6cea023a4b37857" translate="yes" xml:space="preserve">
          <source>Matches any &lt;var&gt;expval&lt;/var&gt;. This is also known as &lt;em&gt;don&amp;rsquo;t care&lt;/em&gt; or &lt;em&gt;wildcard&lt;/em&gt;.</source>
          <target state="translated">任意の &lt;var&gt;expval&lt;/var&gt; に一致します。これは、&lt;em&gt;ドントケア&lt;/em&gt;または&lt;em&gt;ワイルドカード&lt;/em&gt;とも呼ばれ&lt;em&gt;ます&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="282c53348f7fcd0ad68d33bb9c7f6cccc54a4565" translate="yes" xml:space="preserve">
          <source>Matches if &lt;var&gt;boolean-expression&lt;/var&gt; evaluates to non-&lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">&lt;var&gt;boolean-expression&lt;/var&gt; がnon- &lt;code&gt;nil&lt;/code&gt; と評価された場合に一致します。</target>
        </trans-unit>
        <trans-unit id="257d039f7b35b3e0442ca76380b5ef90a0d77303" translate="yes" xml:space="preserve">
          <source>Matches if &lt;var&gt;expval&lt;/var&gt; equals &lt;var&gt;val&lt;/var&gt;. The comparison is done as if by &lt;code&gt;equal&lt;/code&gt; (see &lt;a href=&quot;equality-predicates#Equality-Predicates&quot;&gt;Equality Predicates&lt;/a&gt;).</source>
          <target state="translated">&lt;var&gt;expval&lt;/var&gt; が &lt;var&gt;val&lt;/var&gt; と等しい場合に一致します。比較は、 &lt;code&gt;equal&lt;/code&gt; かのように行われます（&lt;a href=&quot;equality-predicates#Equality-Predicates&quot;&gt;Equality Predicatesを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="0b1481ca7fe064087aacfb37775ecc46665629cf" translate="yes" xml:space="preserve">
          <source>Matches if &lt;var&gt;expval&lt;/var&gt; equals the literal object. This is a special case of &lt;code&gt;'&lt;var&gt;val&lt;/var&gt;&lt;/code&gt;, above, possible because literal objects of these types are self-quoting.</source>
          <target state="translated">&lt;var&gt;expval&lt;/var&gt; がリテラルオブジェクトと等しい場合に一致します。これらのタイプのリテラルオブジェクトは自己引用であるため、これは上記の &lt;code&gt;'&lt;var&gt;val&lt;/var&gt;&lt;/code&gt; 特殊なケースです。</target>
        </trans-unit>
        <trans-unit id="978883ed6eed2d6a28b654dbedeb42b8609b3fad" translate="yes" xml:space="preserve">
          <source>Matches if &lt;var&gt;expval&lt;/var&gt; is a cons cell whose &lt;code&gt;car&lt;/code&gt; matches &lt;var&gt;qpat1&lt;/var&gt; and whose &lt;code&gt;cdr&lt;/code&gt; matches &lt;var&gt;qpat2&lt;/var&gt;. This readily generalizes to lists as in &lt;code&gt;(&lt;var&gt;qpat1&lt;/var&gt;&amp;nbsp;&lt;var&gt;qpat2&lt;/var&gt;&amp;nbsp;&amp;hellip;)&lt;/code&gt;.</source>
          <target state="translated">一致した場合 &lt;var&gt;expval&lt;/var&gt; はコンスセルである &lt;code&gt;car&lt;/code&gt; と一致し &lt;var&gt;qpat1&lt;/var&gt; と &lt;code&gt;cdr&lt;/code&gt; が一致し &lt;var&gt;qpat2&lt;/var&gt; を。これは、 &lt;code&gt;(&lt;var&gt;qpat1&lt;/var&gt;&amp;nbsp;&lt;var&gt;qpat2&lt;/var&gt;&amp;nbsp;&amp;hellip;)&lt;/code&gt; ようにリストに簡単に一般化されます。</target>
        </trans-unit>
        <trans-unit id="8d421ecc7a203998190360c012b97d967bb56647" translate="yes" xml:space="preserve">
          <source>Matches if &lt;var&gt;expval&lt;/var&gt; is a vector of length &lt;var&gt;m&lt;/var&gt; whose &lt;code&gt;0&lt;/code&gt;..&lt;code&gt;(&lt;var&gt;m&lt;/var&gt;-1)&lt;/code&gt;th elements match &lt;var&gt;qpat1&lt;/var&gt;, &lt;var&gt;qpat2&lt;/var&gt; &amp;hellip; &lt;var&gt;qpatm&lt;/var&gt;, respectively.</source>
          <target state="translated">&lt;var&gt;expval&lt;/var&gt; が長さ &lt;var&gt;m&lt;/var&gt; のベクトルであり、その &lt;code&gt;0&lt;/code&gt; .. &lt;code&gt;(&lt;var&gt;m&lt;/var&gt;-1)&lt;/code&gt; 番目の要素がそれぞれ &lt;var&gt;qpat1&lt;/var&gt; 、 &lt;var&gt;qpat2&lt;/var&gt; &amp;hellip; &lt;var&gt;qpatm&lt;/var&gt; と一致する場合に一致します。</target>
        </trans-unit>
        <trans-unit id="7ae908cffb91a06454159f03a0002153cc9d96fb" translate="yes" xml:space="preserve">
          <source>Matches if &lt;var&gt;function&lt;/var&gt; called on &lt;var&gt;expval&lt;/var&gt; returns a value that matches &lt;var&gt;pattern&lt;/var&gt;. &lt;var&gt;function&lt;/var&gt; can take one of the forms described for &lt;code&gt;pred&lt;/code&gt;, above. Unlike &lt;code&gt;pred&lt;/code&gt;, however, &lt;code&gt;app&lt;/code&gt; tests the result against &lt;var&gt;pattern&lt;/var&gt;, rather than against a boolean truth value.</source>
          <target state="translated">一致した場合 &lt;var&gt;function&lt;/var&gt; で呼び出さ &lt;var&gt;expval&lt;/var&gt; 戻り値と一致する &lt;var&gt;pattern&lt;/var&gt; 。 &lt;var&gt;function&lt;/var&gt; は、上記の &lt;code&gt;pred&lt;/code&gt; について説明した形式のいずれかを取ることができます。ただし、 &lt;code&gt;pred&lt;/code&gt; とは異なり、 &lt;code&gt;app&lt;/code&gt; はブール値の真理値ではなく、 &lt;var&gt;pattern&lt;/var&gt; に対して結果をテストします。</target>
        </trans-unit>
        <trans-unit id="739f57f309dcf068954c6199fcd5d3b33f050610" translate="yes" xml:space="preserve">
          <source>Matches if the corresponding element of &lt;var&gt;expval&lt;/var&gt; is &lt;code&gt;equal&lt;/code&gt; to the specified literal object.</source>
          <target state="translated">&lt;var&gt;expval&lt;/var&gt; の対応する要素が、指定されたリテラルオブジェクトと &lt;code&gt;equal&lt;/code&gt; します。</target>
        </trans-unit>
        <trans-unit id="674ff3b825d9ae7d265a12ff2ae08223fcb7d64f" translate="yes" xml:space="preserve">
          <source>Matches if the corresponding element of &lt;var&gt;expval&lt;/var&gt; matches &lt;var&gt;pattern&lt;/var&gt;. Note that &lt;var&gt;pattern&lt;/var&gt; is any kind that &lt;code&gt;pcase&lt;/code&gt; supports. (In the example above, &lt;code&gt;second-elem&lt;/code&gt; is a &lt;var&gt;symbol&lt;/var&gt; core pattern; it therefore matches anything, and let-binds &lt;code&gt;second-elem&lt;/code&gt;.)</source>
          <target state="translated">&lt;var&gt;expval&lt;/var&gt; の対応する要素がpatternに一致する場合に一致し &lt;var&gt;pattern&lt;/var&gt; 。 &lt;var&gt;pattern&lt;/var&gt; は &lt;code&gt;pcase&lt;/code&gt; がサポートするあらゆる種類であることに注意してください。（上記の例では、 &lt;code&gt;second-elem&lt;/code&gt; は &lt;var&gt;symbol&lt;/var&gt; コアパターンであるため、すべてに一致し、 &lt;code&gt;second-elem&lt;/code&gt; をlet -bindします。）</target>
        </trans-unit>
        <trans-unit id="1308a03f9d82916c80a7d812b1deda28157315b6" translate="yes" xml:space="preserve">
          <source>Matches if the predicate &lt;var&gt;function&lt;/var&gt; returns non-&lt;code&gt;nil&lt;/code&gt; when called on &lt;var&gt;expval&lt;/var&gt;. the predicate &lt;var&gt;function&lt;/var&gt; can have one of the following forms:</source>
          <target state="translated">&lt;var&gt;expval&lt;/var&gt; で呼び出されたときに、述語 &lt;var&gt;function&lt;/var&gt; が非 &lt;code&gt;nil&lt;/code&gt; を返す場合に一致します。述語 &lt;var&gt;function&lt;/var&gt; は、次のいずれかの形式になります。</target>
        </trans-unit>
        <trans-unit id="6d30d930e31b7cc8d8611f9ee7e28b703c1f1f15" translate="yes" xml:space="preserve">
          <source>Matches strings against the regexp &lt;var&gt;rx-expr&lt;/var&gt;&amp;hellip;, using the &lt;code&gt;rx&lt;/code&gt; regexp notation (see &lt;a href=&quot;rx-notation#Rx-Notation&quot;&gt;Rx Notation&lt;/a&gt;), as if by &lt;code&gt;string-match&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;string-match&lt;/code&gt; のように、 &lt;code&gt;rx&lt;/code&gt; regexp表記法（&lt;a href=&quot;rx-notation#Rx-Notation&quot;&gt;Rx表記法を&lt;/a&gt;参照）を使用して、文字列を &lt;var&gt;rx-expr&lt;/var&gt; &amp;hellip;と照合します。</target>
        </trans-unit>
        <trans-unit id="4c220368bb4219d0ac89ca454946be8bddd2829b" translate="yes" xml:space="preserve">
          <source>Matching single characters</source>
          <target state="translated">単一文字のマッチング</target>
        </trans-unit>
        <trans-unit id="0c2d501ea6626d380ec030a4b996efde369c2ab2" translate="yes" xml:space="preserve">
          <source>Measuring the resources that your code uses.</source>
          <target state="translated">コードが使用するリソースを測定します。</target>
        </trans-unit>
        <trans-unit id="03a68b7d8b854f2e082850074e2a8ddc1224e602" translate="yes" xml:space="preserve">
          <source>Memory Usage</source>
          <target state="translated">メモリ使用量</target>
        </trans-unit>
        <trans-unit id="3b9c0cfb66cbc7f431d2be01c6c671bec7a34644" translate="yes" xml:space="preserve">
          <source>Menu Bar</source>
          <target state="translated">メニューバー</target>
        </trans-unit>
        <trans-unit id="16caad169ee406031f21f23e1b6301b797fa0084" translate="yes" xml:space="preserve">
          <source>Menu Example</source>
          <target state="translated">メニュー例</target>
        </trans-unit>
        <trans-unit id="b12062efe3af477059c284119d8434d41ae242a3" translate="yes" xml:space="preserve">
          <source>Menu Keymaps</source>
          <target state="translated">メニューキーマップ</target>
        </trans-unit>
        <trans-unit id="6fb0b0290e8b0a35d56be9fedd24c4318262e46c" translate="yes" xml:space="preserve">
          <source>Menu Separators</source>
          <target state="translated">メニューセパレータ</target>
        </trans-unit>
        <trans-unit id="15c6cdd8a7fcc3254e0110b90d40dcb9521b5c10" translate="yes" xml:space="preserve">
          <source>Menus and the Keyboard</source>
          <target state="translated">メニューとキーボード</target>
        </trans-unit>
        <trans-unit id="7ed3131770bb3cf28e7cdf82c3c9fbd8d687f5e1" translate="yes" xml:space="preserve">
          <source>Menus and the Mouse</source>
          <target state="translated">メニューとマウス</target>
        </trans-unit>
        <trans-unit id="c18bb98ae36a93e8052f0d6c9f161d8d49feaa19" translate="yes" xml:space="preserve">
          <source>Messages like &amp;lsquo;</source>
          <target state="translated">'のようなメッセージ</target>
        </trans-unit>
        <trans-unit id="8d546a6dea9ff90d517b51c25b35319931ae4e04" translate="yes" xml:space="preserve">
          <source>Meta</source>
          <target state="translated">Meta</target>
        </trans-unit>
        <trans-unit id="7d26ac8fefd98dd2e2239d0d83cfc7025404ed00" translate="yes" xml:space="preserve">
          <source>Meta-Character Syntax</source>
          <target state="translated">メタ文字構文</target>
        </trans-unit>
        <trans-unit id="25523a0222c9047ee4b9673f05cad4ee5f070cad" translate="yes" xml:space="preserve">
          <source>Method definitions can make use of a new argument-list keyword, &lt;code&gt;&amp;amp;context&lt;/code&gt;, which introduces extra specializers that test the environment at the time the method is run. This keyword should appear after the list of required arguments, but before any &lt;code&gt;&amp;amp;rest&lt;/code&gt; or &lt;code&gt;&amp;amp;optional&lt;/code&gt; keywords. The &lt;code&gt;&amp;amp;context&lt;/code&gt; specializers look much like regular argument specializers&amp;mdash;(&lt;var&gt;expr&lt;/var&gt;&lt;var&gt;spec&lt;/var&gt;)&amp;mdash;except that &lt;var&gt;expr&lt;/var&gt; is an expression to be evaluated in the current context, and the &lt;var&gt;spec&lt;/var&gt; is a value to compare against. For example, &lt;code&gt;&amp;amp;context (overwrite-mode (eql t))&lt;/code&gt; will make the method applicable only when &lt;code&gt;overwrite-mode&lt;/code&gt; is turned on. The &lt;code&gt;&amp;amp;context&lt;/code&gt; keyword can be followed by any number of context specializers. Because the context specializers are not part of the generic function&amp;rsquo;s argument signature, they may be omitted in methods that don&amp;rsquo;t require them.</source>
          <target state="translated">メソッド定義では、新しい引数リストキーワード &lt;code&gt;&amp;amp;context&lt;/code&gt; を使用できます。これにより、メソッドの実行時に環境をテストする追加のスペシャライザーが導入されます。このキーワードは、必須引数のリストの後、 &lt;code&gt;&amp;amp;rest&lt;/code&gt; または &lt;code&gt;&amp;amp;optional&lt;/code&gt; キーワードの前に表示する必要があります。 &lt;code&gt;&amp;amp;context&lt;/code&gt; specializersは非常に似て、通常の引数specializers-（ &lt;var&gt;expr&lt;/var&gt; の &lt;var&gt;spec&lt;/var&gt; ）-exceptこと &lt;var&gt;expr&lt;/var&gt; は、現在のコンテキストで評価される式であり、 &lt;var&gt;spec&lt;/var&gt; 比較対象の値です。たとえば、 &lt;code&gt;&amp;amp;context (overwrite-mode (eql t))&lt;/code&gt; は、 &lt;code&gt;overwrite-mode&lt;/code&gt; がオンになっている場合にのみメソッドを適用可能にします。ザ・ &lt;code&gt;&amp;amp;context&lt;/code&gt; キーワードの後に​​は、任意の数のコンテキストスペシャライザーを続けることができます。コンテキストスペシャライザーは汎用関数の引数シグネチャの一部ではないため、コンテキストスペシャライザーを必要としないメソッドでは省略できます。</target>
        </trans-unit>
        <trans-unit id="3814dd76362cfffd02ba4b1937ed1c2c87e7844e" translate="yes" xml:space="preserve">
          <source>Microsoft Windows NT, 9X and later. The value of &lt;code&gt;system-type&lt;/code&gt; is always &lt;code&gt;windows-nt&lt;/code&gt;, e.g., even on Windows 10.</source>
          <target state="translated">Microsoft Windows NT、9X以降。 &lt;code&gt;system-type&lt;/code&gt; の値は、たとえばWindows 10でも、常に &lt;code&gt;windows-nt&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="2767e46afcc3ac1795e792eb132101e2b44c1778" translate="yes" xml:space="preserve">
          <source>Microsoft&amp;rsquo;s DOS. Emacs compiled with DJGPP for MS-DOS binds &lt;code&gt;system-type&lt;/code&gt; to &lt;code&gt;ms-dos&lt;/code&gt; even when you run it on MS-Windows.</source>
          <target state="translated">MicrosoftのDOS。MS-DOS用のDJGPPでコンパイルされたEmacsは、MS-Windowsで実行した場合でも、 &lt;code&gt;system-type&lt;/code&gt; を &lt;code&gt;ms-dos&lt;/code&gt; にバインドします。</target>
        </trans-unit>
        <trans-unit id="f9c9c8db7156a7448700d445deeeb649c319eb70" translate="yes" xml:space="preserve">
          <source>Minibuffer Commands</source>
          <target state="translated">ミニバッファコマンド</target>
        </trans-unit>
        <trans-unit id="b66e5aaaf448e820ada310fc0fc7cfcb0f0786b0" translate="yes" xml:space="preserve">
          <source>Minibuffer Commands that Do Completion</source>
          <target state="translated">補完を行うミニバッファコマンド</target>
        </trans-unit>
        <trans-unit id="6a3f154cb3d12adeba658562da192d175d080908" translate="yes" xml:space="preserve">
          <source>Minibuffer Contents</source>
          <target state="translated">ミニバッファの内容</target>
        </trans-unit>
        <trans-unit id="c9ecc01b5e1b40232e2354f19e5d6b7647cfab66" translate="yes" xml:space="preserve">
          <source>Minibuffer History</source>
          <target state="translated">ミニバッファの歴史</target>
        </trans-unit>
        <trans-unit id="5711d65bace0facc4ca32fe822109910ac6088d3" translate="yes" xml:space="preserve">
          <source>Minibuffer Miscellany</source>
          <target state="translated">ミニバッファその他</target>
        </trans-unit>
        <trans-unit id="7af96936c990ed708387e7161673b6638521b972" translate="yes" xml:space="preserve">
          <source>Minibuffer Windows</source>
          <target state="translated">ミニバッファウィンドウズ</target>
        </trans-unit>
        <trans-unit id="d3a911d1b2be32f6461ffe02d45b48c543df77a1" translate="yes" xml:space="preserve">
          <source>Minibuffer commands that do completion.</source>
          <target state="translated">補完を行うミニバッファコマンド。</target>
        </trans-unit>
        <trans-unit id="d54ac200a7fb55100cb14bfbd0ecda71c040d192" translate="yes" xml:space="preserve">
          <source>Minibuffer input is a special kind of recursive editing. It has a few special wrinkles, such as enabling display of the minibuffer and the minibuffer window, but fewer than you might suppose. Certain keys behave differently in the minibuffer, but that is only because of the minibuffer&amp;rsquo;s local map; if you switch windows, you get the usual Emacs commands.</source>
          <target state="translated">ミニバッファ入力は、特別な種類の再帰編集です。ミニバッファやミニバッファウィンドウの表示を有効にするなど、いくつかの特別なシワがありますが、想像以上に少ないです。特定のキーはミニバッファ内で異なる動作をしますが、それはミニバッファのローカルマップのためだけです。ウィンドウを切り替えると、通常のEmacsコマンドが表示されます。</target>
        </trans-unit>
        <trans-unit id="367762892b20350b19f7bd8cd60d6489ac911db6" translate="yes" xml:space="preserve">
          <source>Minibuffers</source>
          <target state="translated">Minibuffers</target>
        </trans-unit>
        <trans-unit id="edccf3bc0f1044797feeb7318644812ec8808a04" translate="yes" xml:space="preserve">
          <source>Minibuffers and Frames</source>
          <target state="translated">ミニバッファとフレーム</target>
        </trans-unit>
        <trans-unit id="a6078aaad32f5816f061d4e9117bdbc1d7ee3400" translate="yes" xml:space="preserve">
          <source>Minimum value of &lt;code&gt;hscroll&lt;/code&gt;, set by the user via &lt;code&gt;set-window-hscroll&lt;/code&gt; (see &lt;a href=&quot;horizontal-scrolling#Horizontal-Scrolling&quot;&gt;Horizontal Scrolling&lt;/a&gt;). When only the current line is hscrolled, this describes the horizontal scrolling of lines other than the current one.</source>
          <target state="translated">ユーザーが &lt;code&gt;set-window-hscroll&lt;/code&gt; を介して設定した &lt;code&gt;hscroll&lt;/code&gt; の最小値（&lt;a href=&quot;horizontal-scrolling#Horizontal-Scrolling&quot;&gt;水平スクロールを&lt;/a&gt;参照）。現在の行のみがhscrollされている場合、これは現在の行以外の行の水平スクロールを表します。</target>
        </trans-unit>
        <trans-unit id="64f24a9a0dc69d512190fb4f05f76bebd963ffc9" translate="yes" xml:space="preserve">
          <source>Minor Modes</source>
          <target state="translated">マイナーモード</target>
        </trans-unit>
        <trans-unit id="63be5c97e7240142a22356e2f1777fc2c8d3904a" translate="yes" xml:space="preserve">
          <source>Minor modes may bind commands to key sequences consisting of</source>
          <target state="translated">マイナーモードでは、コマンドを以下のようなキーシーケンスにバインドすることができます。</target>
        </trans-unit>
        <trans-unit id="8df431838fe5f9e1d63617cd34c66e591a88b4ec" translate="yes" xml:space="preserve">
          <source>Misc Network Facilities</source>
          <target state="translated">その他ネットワーク設備</target>
        </trans-unit>
        <trans-unit id="8e515a2e618367c7a4a06c28d8c1be931f8c03d1" translate="yes" xml:space="preserve">
          <source>Miscellaneous Convenience Functions for Modules</source>
          <target state="translated">モジュールの各種便利機能</target>
        </trans-unit>
        <trans-unit id="7a052e4f76928458969464505a52746d5a78fea2" translate="yes" xml:space="preserve">
          <source>Miscellaneous Edebug Commands</source>
          <target state="translated">その他の Edebug コマンド</target>
        </trans-unit>
        <trans-unit id="a47827783224a9ce5dd490948eb1ebddc3b4d684" translate="yes" xml:space="preserve">
          <source>Miscellaneous Event Input Features</source>
          <target state="translated">その他のイベント入力機能</target>
        </trans-unit>
        <trans-unit id="b29522452ab33d2ad0ba96dda015a6308c7b2c75" translate="yes" xml:space="preserve">
          <source>Miscellaneous System Events</source>
          <target state="translated">その他のシステムイベント</target>
        </trans-unit>
        <trans-unit id="03e893e20e6aedf9fdd003184f4239c14fa31543" translate="yes" xml:space="preserve">
          <source>Miscellaneous commands.</source>
          <target state="translated">その他のコマンド。</target>
        </trans-unit>
        <trans-unit id="513913e8f1b8df71a57aef2147717f04b5a5ff53" translate="yes" xml:space="preserve">
          <source>Miscellaneous.</source>
          <target state="translated">Miscellaneous.</target>
        </trans-unit>
        <trans-unit id="b841515cb79574557871d33c6c685c8b786e812e" translate="yes" xml:space="preserve">
          <source>Mode Hooks</source>
          <target state="translated">モードフック</target>
        </trans-unit>
        <trans-unit id="1660228964a84777507d5db30661351095dda9bc" translate="yes" xml:space="preserve">
          <source>Mode Line Basics</source>
          <target state="translated">モードラインの基本</target>
        </trans-unit>
        <trans-unit id="92a5ca248b99dee1b2ae58ed98e940b4cbfc322d" translate="yes" xml:space="preserve">
          <source>Mode Line Format</source>
          <target state="translated">ファッションライン形式</target>
        </trans-unit>
        <trans-unit id="1a4b9da8f1b1256a549fb046003a7eb28cd18a68" translate="yes" xml:space="preserve">
          <source>Mode line construct for miscellaneous information. By default, this shows the information specified by &lt;code&gt;global-mode-string&lt;/code&gt;.</source>
          <target state="translated">その他の情報のためのモードライン構成。デフォルトでは、これは &lt;code&gt;global-mode-string&lt;/code&gt; で指定された情報を表示します。</target>
        </trans-unit>
        <trans-unit id="79f5b225cffab11e22dc40b6f05abef1d33d1561" translate="yes" xml:space="preserve">
          <source>Modes</source>
          <target state="translated">Modes</target>
        </trans-unit>
        <trans-unit id="72b2168254baad89e5c1ab9acb3b6040544bd8fb" translate="yes" xml:space="preserve">
          <source>Modes derived from Tabulated List mode should call this after setting the above variables (in particular, only after setting &lt;code&gt;tabulated-list-format&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;tabulated-list-format&lt;/code&gt; リストモードから派生したモードでは、上記の変数を設定した後（特に、表形式リスト形式を設定した後でのみ）、これを呼び出す必要があります。</target>
        </trans-unit>
        <trans-unit id="f37280f5c8b796776063d76ead3db5950069843b" translate="yes" xml:space="preserve">
          <source>Modes for program source code should set this to &lt;code&gt;left-to-right&lt;/code&gt;. Prog mode does this by default, so modes derived from Prog mode do not need to set this explicitly (see &lt;a href=&quot;basic-major-modes#Basic-Major-Modes&quot;&gt;Basic Major Modes&lt;/a&gt;).</source>
          <target state="translated">プログラムのソースコードのモードでは、これを &lt;code&gt;left-to-right&lt;/code&gt; 設定する必要があります。Progモードはデフォルトでこれを行うため、Progモードから派生したモードではこれを明示的に設定する必要はありません（&lt;a href=&quot;basic-major-modes#Basic-Major-Modes&quot;&gt;基本メジャーモードを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="b5803becd9e65746e44a5fb6727af1b147951979" translate="yes" xml:space="preserve">
          <source>Modes such as Dired and Rmail make buffers read-only when altering the contents with the usual editing commands would probably be a mistake.</source>
          <target state="translated">DiredやRmailのようなモードでは、通常の編集コマンドで内容を変更する際にバッファを読み取り専用にしてしまうのは、おそらく間違いだと思います。</target>
        </trans-unit>
        <trans-unit id="3e0d60bdae51618466cc5411408a226c74100aa3" translate="yes" xml:space="preserve">
          <source>Modes such as Dired mode, in which the text being edited does not consist of a file&amp;rsquo;s contents but can be regenerated in some other fashion, can give this variable a buffer-local value that is a special function to regenerate the contents.</source>
          <target state="translated">編集中のテキストがファイルの内容で構成されていないが、他の方法で再生成できるDiredモードなどのモードでは、この変数に、内容を再生成するための特別な関数であるバッファーローカル値を与えることができます。</target>
        </trans-unit>
        <trans-unit id="2a24cfeea8738c2ef8dbe6b0b8299a0d52050626" translate="yes" xml:space="preserve">
          <source>Modes that other modes are often derived from.</source>
          <target state="translated">他のモードが派生することが多いモード。</target>
        </trans-unit>
        <trans-unit id="9b381b9e6c64fcffa354dbacacd2ce3c1b8c0754" translate="yes" xml:space="preserve">
          <source>Modifying Existing List Structure</source>
          <target state="translated">既存のリスト構造の変更</target>
        </trans-unit>
        <trans-unit id="c3379a41bf4759b0d4c70d3387480936a6059e23" translate="yes" xml:space="preserve">
          <source>Modifying List Variables</source>
          <target state="translated">リスト変数の変更</target>
        </trans-unit>
        <trans-unit id="df42359d215a53db6ed9a7c4b8cbe68fd027284d" translate="yes" xml:space="preserve">
          <source>Modifying Menus</source>
          <target state="translated">メニューの変更</target>
        </trans-unit>
        <trans-unit id="06b27e179bc67d2eb79dac2d1e6d2015650bd5ca" translate="yes" xml:space="preserve">
          <source>Modifying Strings</source>
          <target state="translated">文字列の修正</target>
        </trans-unit>
        <trans-unit id="8e9379a55961a6ef4c12aeb1fda47c055107980d" translate="yes" xml:space="preserve">
          <source>Modifying and Translating Input Events</source>
          <target state="translated">入力イベントの修正と変換</target>
        </trans-unit>
        <trans-unit id="0c57ccfc431bc2516e5717214f07522071c88c48" translate="yes" xml:space="preserve">
          <source>Modifying lists stored in variables.</source>
          <target state="translated">変数に格納されているリストを変更します。</target>
        </trans-unit>
        <trans-unit id="0a7be6ae1c4a45d3076b49b4bc3c1a4ee48cb902" translate="yes" xml:space="preserve">
          <source>Modifying text is not allowed in a read-only buffer.</source>
          <target state="translated">読み取り専用バッファでは、テキストの変更は許可されていません。</target>
        </trans-unit>
        <trans-unit id="23f3dc3212ed2957d48473bfbcff7fdc730bbb06" translate="yes" xml:space="preserve">
          <source>Module Initialization Code</source>
          <target state="translated">モジュール初期化コード</target>
        </trans-unit>
        <trans-unit id="71d4613afbc49b703267c29c22712c23464539a5" translate="yes" xml:space="preserve">
          <source>Module functions including the &lt;code&gt;emacs_module_init&lt;/code&gt; function (see &lt;a href=&quot;module-initialization#module-initialization-function&quot;&gt;module initialization function&lt;/a&gt;) may only interact with Emacs by calling environment functions from some live &lt;code&gt;emacs_env&lt;/code&gt; pointer while being called directly or indirectly from Emacs. In other words, if a module function wants to call Lisp functions or Emacs primitives, convert &lt;code&gt;emacs_value&lt;/code&gt; objects to and from C datatypes (see &lt;a href=&quot;module-values#Module-Values&quot;&gt;Module Values&lt;/a&gt;), or interact with Emacs in any other way, some call from Emacs to &lt;code&gt;emacs_module_init&lt;/code&gt; or to a module function must be in the call stack. Module function may not interact with Emacs while garbage collection is running; see &lt;a href=&quot;garbage-collection#Garbage-Collection&quot;&gt;Garbage Collection&lt;/a&gt;. They may only interact with Emacs from Lisp interpreter threads (including the main thread) created by Emacs; see &lt;a href=&quot;threads#Threads&quot;&gt;Threads&lt;/a&gt;. The</source>
          <target state="translated">&lt;code&gt;emacs_module_init&lt;/code&gt; 関数（&lt;a href=&quot;module-initialization#module-initialization-function&quot;&gt;モジュール初期化関数を&lt;/a&gt;参照）を含むモジュール関数は、Emacsから直接または間接的に呼び出されているときに、ライブ &lt;code&gt;emacs_env&lt;/code&gt; ポインターから環境関数を呼び出すことによってのみEmacsと対話できます。言い換えれば、モジュール関数がLisp関数またはEmacsプリミティブを呼び出したり、 &lt;code&gt;emacs_value&lt;/code&gt; オブジェクトをCデータタイプとの間で変換したり（&lt;a href=&quot;module-values#Module-Values&quot;&gt;モジュール値を&lt;/a&gt;参照）、または他の方法でEmacsと &lt;code&gt;emacs_module_init&lt;/code&gt; たりする場合、Emacsからemacs_module_initまたはモジュールへの呼び出しがあります。関数はコールスタックになければなりません。ガベージコレクションの実行中は、モジュール関数がEmacsと相互作用しない場合があります。&lt;a href=&quot;garbage-collection#Garbage-Collection&quot;&gt;ガベージコレクションを&lt;/a&gt;参照してください。それらは、Emacsによって作成されたLispインタプリタスレッド（メインスレッドを含む）からのEmacsとのみ対話できます。&lt;a href=&quot;threads#Threads&quot;&gt;スレッドを&lt;/a&gt;参照してください。ザ・</target>
        </trans-unit>
        <trans-unit id="aa62ecac906e7dae2c8e2d7e79864dfd62f36887" translate="yes" xml:space="preserve">
          <source>Module functions use the type &lt;code&gt;emacs_value&lt;/code&gt; to communicate Lisp objects between Emacs and the module (see &lt;a href=&quot;module-values#Module-Values&quot;&gt;Module Values&lt;/a&gt;). The</source>
          <target state="translated">モジュール関数は、タイプ &lt;code&gt;emacs_value&lt;/code&gt; を使用して、Emacsとモジュールの間でLispオブジェクトを通信します（&lt;a href=&quot;module-values#Module-Values&quot;&gt;モジュール値を&lt;/a&gt;参照）。ザ・</target>
        </trans-unit>
        <trans-unit id="53078183c7061fe0cd9edd96cc36e5ce37d0a31b" translate="yes" xml:space="preserve">
          <source>Modules can create &lt;code&gt;user-ptr&lt;/code&gt; Lisp objects that embed pointers to C struct&amp;rsquo;s defined by the module. This is useful for keeping around complex data structures created by a module, to be passed back to the module&amp;rsquo;s functions. User-ptr objects can also have associated &lt;em&gt;finalizers&lt;/em&gt; &amp;ndash; functions to be run when the object is GC&amp;rsquo;ed; this is useful for freeing any resources allocated for the underlying data structure, such as memory, open file descriptors, etc. See &lt;a href=&quot;module-values#Module-Values&quot;&gt;Module Values&lt;/a&gt;.</source>
          <target state="translated">モジュールは、モジュールによって定義されたC構造体へのポインタを埋め込む &lt;code&gt;user-ptr&lt;/code&gt; Lispオブジェクトを作成できます。これは、モジュールによって作成された複雑なデータ構造を保持して、モジュールの関数に戻すのに役立ちます。 User-ptrオブジェクトには、&lt;em&gt;ファイナライザー&lt;/em&gt;を関連付けることもできます。これは、オブジェクトがGCされたときに実行される関数です。これは、メモリ、開いているファイル記述子など、基礎となるデータ構造に割り当てられているリソースを解放するのに役立ち&lt;a href=&quot;module-values#Module-Values&quot;&gt;ます&lt;/a&gt;。モジュール値を参照してください。</target>
        </trans-unit>
        <trans-unit id="cdaf1615e9fcf09128f766c4a11eb97589359016" translate="yes" xml:space="preserve">
          <source>Modules provide additional Lisp primitives.</source>
          <target state="translated">モジュールは追加のLispプリミティブを提供します。</target>
        </trans-unit>
        <trans-unit id="6ec2f205aeddb216abff070de47e318b831ed982" translate="yes" xml:space="preserve">
          <source>More commonly, a face is referred to via a &lt;em&gt;face name&lt;/em&gt;: a Lisp symbol associated with a set of face attributes&lt;a href=&quot;#FOOT22&quot; name=&quot;DOCF22&quot;&gt;&lt;sup&gt;22&lt;/sup&gt;&lt;/a&gt;. Named faces are defined using the &lt;code&gt;defface&lt;/code&gt; macro (see &lt;a href=&quot;defining-faces#Defining-Faces&quot;&gt;Defining Faces&lt;/a&gt;). Emacs comes with several standard named faces (see &lt;a href=&quot;basic-faces#Basic-Faces&quot;&gt;Basic Faces&lt;/a&gt;).</source>
          <target state="translated">より一般的には、顔は、&lt;em&gt;顔の名前&lt;/em&gt;、つまり顔の属性のセットに関連付けられたLispシンボルを介して参照されます&lt;a href=&quot;#FOOT22&quot; name=&quot;DOCF22&quot;&gt;&lt;sup&gt;22&lt;/sup&gt;&lt;/a&gt;。顔を使用して定義された名前の &lt;code&gt;defface&lt;/code&gt; のマクロ（参照&lt;a href=&quot;defining-faces#Defining-Faces&quot;&gt;定義顔&lt;/a&gt;）。Emacsにはいくつかの標準的な名前付き面が付属しています（&lt;a href=&quot;basic-faces#Basic-Faces&quot;&gt;基本面を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="b94de5ef15a44f90d2da93f96e38f761c889651d" translate="yes" xml:space="preserve">
          <source>More complex menu item definitions.</source>
          <target state="translated">より複雑なメニュー項目の定義</target>
        </trans-unit>
        <trans-unit id="754bbd6d917505e0487bb8bfca83939b74396492" translate="yes" xml:space="preserve">
          <source>More generally,</source>
          <target state="translated">もっと一般的には。</target>
        </trans-unit>
        <trans-unit id="d436056747a2fab716975cd61c740bc6fb24a4a3" translate="yes" xml:space="preserve">
          <source>More generally, &lt;code&gt;listname&lt;/code&gt; can be a generalized variable. In that case, this macro does the equivalent of &lt;code&gt;(setf&amp;nbsp;&lt;var&gt;listname&lt;/var&gt;&amp;nbsp;(cons&amp;nbsp;&lt;var&gt;element&lt;/var&gt;&amp;nbsp;&lt;var&gt;listname&lt;/var&gt;))&lt;/code&gt;. See &lt;a href=&quot;generalized-variables#Generalized-Variables&quot;&gt;Generalized Variables&lt;/a&gt;.</source>
          <target state="translated">より一般的には、 &lt;code&gt;listname&lt;/code&gt; は一般化された変数にすることができます。その場合、このマクロは &lt;code&gt;(setf&amp;nbsp;&lt;var&gt;listname&lt;/var&gt;&amp;nbsp;(cons&amp;nbsp;&lt;var&gt;element&lt;/var&gt;&amp;nbsp;&lt;var&gt;listname&lt;/var&gt;))&lt;/code&gt; と同等の動作をします。&lt;a href=&quot;generalized-variables#Generalized-Variables&quot;&gt;一般化変数を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="55172490781de7bea7e9de094ce64599830a7212" translate="yes" xml:space="preserve">
          <source>More generally, &lt;var&gt;listname&lt;/var&gt; can be a generalized variable. In that case, this macro saves into &lt;var&gt;listname&lt;/var&gt; using &lt;code&gt;setf&lt;/code&gt;. See &lt;a href=&quot;generalized-variables#Generalized-Variables&quot;&gt;Generalized Variables&lt;/a&gt;.</source>
          <target state="translated">より一般的には、 &lt;var&gt;listname&lt;/var&gt; は一般化された変数にすることができます。その場合、このマクロは &lt;code&gt;setf&lt;/code&gt; を使用して &lt;var&gt;listname&lt;/var&gt; に保存されます。&lt;a href=&quot;generalized-variables#Generalized-Variables&quot;&gt;一般化変数を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="d7ab2fa4e143762f1cbf98c94412199e5e759c95" translate="yes" xml:space="preserve">
          <source>More generally, &lt;var&gt;mode-line-string&lt;/var&gt; can be any mode line construct. It appears in the mode line when the value of &lt;var&gt;minor-mode-variable&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, and not otherwise. These strings should begin with spaces so that they don&amp;rsquo;t run together. Conventionally, the &lt;var&gt;minor-mode-variable&lt;/var&gt; for a specific mode is set to a non-&lt;code&gt;nil&lt;/code&gt; value when that minor mode is activated.</source>
          <target state="translated">より一般的には、 &lt;var&gt;mode-line-string&lt;/var&gt; は任意のモードライン構成にすることができます。 &lt;var&gt;minor-mode-variable&lt;/var&gt; の値が &lt;code&gt;nil&lt;/code&gt; 以外の場合はモード行に表示され、それ以外の場合は表示されません。これらの文字列は、一緒に実行されないようにスペースで始める必要があります。従来、特定のモードの &lt;var&gt;minor-mode-variable&lt;/var&gt; は、そのマイナーモードがアクティブ化されたときに非 &lt;code&gt;nil&lt;/code&gt; 値に設定されていました。</target>
        </trans-unit>
        <trans-unit id="759e70a01a264315afd54c72c902aa5e03d4acbc" translate="yes" xml:space="preserve">
          <source>More generally, the final argument to &lt;code&gt;append&lt;/code&gt; may be any Lisp object. The final argument is not copied or converted; it becomes the &lt;small&gt;CDR&lt;/small&gt; of the last cons cell in the new list. If the final argument is itself a list, then its elements become in effect elements of the result list. If the final element is not a list, the result is a dotted list since its final &lt;small&gt;CDR&lt;/small&gt; is not &lt;code&gt;nil&lt;/code&gt; as required in a proper list (see &lt;a href=&quot;cons-cells#Cons-Cells&quot;&gt;Cons Cells&lt;/a&gt;).</source>
          <target state="translated">より一般的には、 &lt;code&gt;append&lt;/code&gt; する最後の引数は任意のLispオブジェクトです。最後の引数はコピーも変換もされません。これは、新しいリストの最後のconsセルの&lt;small&gt;CDR&lt;/small&gt;になります。最後の引数自体がリストである場合、その要素は結果リストの実質的な要素になります。最後の要素がリストでない場合、適切なリストで必要とされる最終的な&lt;small&gt;CDR&lt;/small&gt;が &lt;code&gt;nil&lt;/code&gt; でないため、結果は点線のリストになります（&lt;a href=&quot;cons-cells#Cons-Cells&quot;&gt;Cons Cellsを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="5c06fdd4f23cd4daee8d294f03b24245dc305ec4" translate="yes" xml:space="preserve">
          <source>More generally, you can use the variable &lt;code&gt;buffer-invisibility-spec&lt;/code&gt; to control which values of the &lt;code&gt;invisible&lt;/code&gt; property make text invisible. This permits you to classify the text into different subsets in advance, by giving them different &lt;code&gt;invisible&lt;/code&gt; values, and subsequently make various subsets visible or invisible by changing the value of &lt;code&gt;buffer-invisibility-spec&lt;/code&gt;.</source>
          <target state="translated">より一般的には、変数 &lt;code&gt;buffer-invisibility-spec&lt;/code&gt; を使用して、 &lt;code&gt;invisible&lt;/code&gt; プロパティのどの値がテキストを非表示にするかを制御できます。これは、あなたがそれらに異なる与えることによって、事前に異なるサブセットにテキストを分類することを可能にする &lt;code&gt;invisible&lt;/code&gt; 価値を、その後の値が変更することにより、種々のサブセットを表示または非表示にする &lt;code&gt;buffer-invisibility-spec&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="60a18e357538be44773938629786b367e89b0ffd" translate="yes" xml:space="preserve">
          <source>More individual control is possible by using a cons cell: In that case the frame&amp;rsquo;s width ratio is preserved if the &lt;small&gt;CAR&lt;/small&gt; of the cell is either &lt;code&gt;t&lt;/code&gt; or &lt;code&gt;width-only&lt;/code&gt;. The height ratio is preserved if the &lt;small&gt;CAR&lt;/small&gt; of the cell is either &lt;code&gt;t&lt;/code&gt; or &lt;code&gt;height-only&lt;/code&gt;. The left position ratio is preserved if the &lt;small&gt;CDR&lt;/small&gt; of the cell is either &lt;code&gt;t&lt;/code&gt; or &lt;code&gt;left-only&lt;/code&gt;. The top position ratio is preserved if the &lt;small&gt;CDR&lt;/small&gt; of the cell is either &lt;code&gt;t&lt;/code&gt; or &lt;code&gt;top-only&lt;/code&gt;.</source>
          <target state="translated">consセルを使用すると、より個別の制御が可能になります。その場合、セルの&lt;small&gt;CAR&lt;/small&gt;が &lt;code&gt;t&lt;/code&gt; または &lt;code&gt;width-only&lt;/code&gt; 場合、フレームの幅の比率は保持されます。セルの&lt;small&gt;CAR&lt;/small&gt;が &lt;code&gt;t&lt;/code&gt; または &lt;code&gt;height-only&lt;/code&gt; 場合、高さの比率は保持されます。セルの&lt;small&gt;CDR&lt;/small&gt;が &lt;code&gt;t&lt;/code&gt; または &lt;code&gt;left-only&lt;/code&gt; 場合、左位置比は保持されます。セルの&lt;small&gt;CDR&lt;/small&gt;が &lt;code&gt;t&lt;/code&gt; または &lt;code&gt;top-only&lt;/code&gt; の場合、上部の位置の比率は保持されます。</target>
        </trans-unit>
        <trans-unit id="2d35b8a3c91aa8470e9a099d606cc2c1c7acaba3" translate="yes" xml:space="preserve">
          <source>More precisely, we should now have a Lisp function (a lambda expression), a byte-code function, a primitive function, a Lisp macro, a special form, or an autoload object. Each of these types is a case described in one of the following sections. If the object is not one of these types, Emacs signals an &lt;code&gt;invalid-function&lt;/code&gt; error.</source>
          <target state="translated">より正確には、Lisp関数（ラムダ式）、バイトコード関数、プリミティブ関数、Lispマクロ、特殊な形式、または自動ロードオブジェクトが必要です。これらの各タイプは、次のセクションのいずれかで説明されているケースです。オブジェクトがこれらのタイプのいずれでもない場合、Emacsは &lt;code&gt;invalid-function&lt;/code&gt; エラーを通知します。</target>
        </trans-unit>
        <trans-unit id="5d1907fa94271e60953cb92c6af32f80577dca2a" translate="yes" xml:space="preserve">
          <source>Most Emacs Lisp file-manipulation functions get errors when used on files that are directories. For example, you cannot delete a directory with &lt;code&gt;delete-file&lt;/code&gt;. These special functions exist to create and delete directories.</source>
          <target state="translated">ほとんどのEmacsLispファイル操作関数は、ディレクトリであるファイルで使用するとエラーが発生します。たとえば、 &lt;code&gt;delete-file&lt;/code&gt; を使用してディレクトリを削除することはできません。これらの特別な機能は、ディレクトリを作成および削除するために存在します。</target>
        </trans-unit>
        <trans-unit id="09eed349899d3e99c3026461a2438ccf55662d6f" translate="yes" xml:space="preserve">
          <source>Most Emacs commands can use a &lt;em&gt;prefix argument&lt;/em&gt;, a number specified before the command itself. (Don&amp;rsquo;t confuse prefix arguments with prefix keys.) The prefix argument is at all times represented by a value, which may be &lt;code&gt;nil&lt;/code&gt;, meaning there is currently no prefix argument. Each command may use the prefix argument or ignore it.</source>
          <target state="translated">ほとんどのEmacsコマンドは、コマンド自体の前に指定された番号である&lt;em&gt;プレフィックス引数&lt;/em&gt;を使用できます。（プレフィックス引数とプレフィックスキーを混同しないでください。）プレフィックス引数は常に値で表されます。値は &lt;code&gt;nil&lt;/code&gt; の場合があります。つまり、現在プレフィックス引数はありません。各コマンドは、プレフィックス引数を使用することも、無視することもできます。</target>
        </trans-unit>
        <trans-unit id="964d2f546749ab746319cf9bf92a58945c9983a6" translate="yes" xml:space="preserve">
          <source>Most Lisp code should not use this macro; &lt;code&gt;save-selected-window&lt;/code&gt; is typically sufficient. In particular, this macro cannot reliably prevent the code in &lt;var&gt;forms&lt;/var&gt; from opening new windows, because new windows might be opened in other frames (see &lt;a href=&quot;choosing-window#Choosing-Window&quot;&gt;Choosing Window&lt;/a&gt;), and &lt;code&gt;save-window-excursion&lt;/code&gt; only saves and restores the window configuration on the current frame.</source>
          <target state="translated">ほとんどのLispコードはこのマクロを使用すべきではありません。通常、 &lt;code&gt;save-selected-window&lt;/code&gt; で十分です。特に、このマクロは、 &lt;var&gt;forms&lt;/var&gt; 内のコードが新しいウィンドウを開くのを確実に防ぐことはできません。新しいウィンドウが他のフレームで開かれる可能性があり（&lt;a href=&quot;choosing-window#Choosing-Window&quot;&gt;ウィンドウの選択を&lt;/a&gt;参照）、 &lt;code&gt;save-window-excursion&lt;/code&gt; は、現在のフレームのウィンドウ構成のみを保存および復元します。</target>
        </trans-unit>
        <trans-unit id="fe2ae73f5ba28b3bd7e0ab7c9daa9a827c4bf56e" translate="yes" xml:space="preserve">
          <source>Most applications should not use recursive editing, except as part of using the minibuffer. Usually it is more convenient for the user if you change the major mode of the current buffer temporarily to a special major mode, which should have a command to go back to the previous mode. (The</source>
          <target state="translated">ほとんどのアプリケーションでは、ミニバッファの使用の一部としての使用を除いて、再帰的な編集を使用すべきではありません。通常、現在のバッファのメジャーモードを一時的に特別なメジャーモードに変更した方がユーザにとっては便利であり、前のモードに戻るためのコマンドを持っているはずです。(その</target>
        </trans-unit>
        <trans-unit id="1eaf100a3aafa712a449e3207bf7cabe96c9c0ab" translate="yes" xml:space="preserve">
          <source>Most buffers have an &lt;em&gt;undo list&lt;/em&gt;, which records all changes made to the buffer&amp;rsquo;s text so that they can be undone. (The buffers that don&amp;rsquo;t have one are usually special-purpose buffers for which Emacs assumes that undoing is not useful. In particular, any buffer whose name begins with a space has its undo recording off by default; see &lt;a href=&quot;buffer-names#Buffer-Names&quot;&gt;Buffer Names&lt;/a&gt;.) All the primitives that modify the text in the buffer automatically add elements to the front of the undo list, which is in the variable &lt;code&gt;buffer-undo-list&lt;/code&gt;.</source>
          <target state="translated">ほとんどのバッファには&lt;em&gt;元に戻すリスト&lt;/em&gt;があり、&lt;em&gt;元に戻す&lt;/em&gt;ことができるように、バッファのテキストに加えられたすべての変更が記録されます。 （これがないバッファーは通常、Emacsが元に戻すことは役に立たないと見なす専用のバッファーです。特に、名前がスペースで始まるバッファーは、デフォルトで元に戻す記録がオフになります。&lt;a href=&quot;buffer-names#Buffer-Names&quot;&gt;バッファー名を&lt;/a&gt;参照してください。）すべてバッファ内のテキストを変更するプリミティブは、変数 &lt;code&gt;buffer-undo-list&lt;/code&gt; にある元に戻すリストの先頭に要素を自動的に追加します。</target>
        </trans-unit>
        <trans-unit id="b6dcfcc1ab586c7c06232994a3f579a591ce8d2a" translate="yes" xml:space="preserve">
          <source>Most control constructs affect only the flow of control within the construct itself. The function &lt;code&gt;throw&lt;/code&gt; is the exception to this rule of normal program execution: it performs a nonlocal exit on request. (There are other exceptions, but they are for error handling only.) &lt;code&gt;throw&lt;/code&gt; is used inside a &lt;code&gt;catch&lt;/code&gt;, and jumps back to that &lt;code&gt;catch&lt;/code&gt;. For example:</source>
          <target state="translated">ほとんどの制御構造は、構造自体内の制御の流れにのみ影響します。関数 &lt;code&gt;throw&lt;/code&gt; は、通常のプログラム実行のこのルールの例外です。要求に応じて非ローカル終了を実行します。（他にも例外はありますが、彼らは唯一のエラー処理のためのものです。） &lt;code&gt;throw&lt;/code&gt; 内部で使用されている &lt;code&gt;catch&lt;/code&gt; し、それに戻ってジャンプ &lt;code&gt;catch&lt;/code&gt; 。例えば：</target>
        </trans-unit>
        <trans-unit id="72373bc3f93b6102b1ff980fc9edb816c70fbcbd" translate="yes" xml:space="preserve">
          <source>Most errors are signaled automatically within Lisp primitives which you call for other purposes, such as if you try to take the &lt;small&gt;CAR&lt;/small&gt; of an integer or move forward a character at the end of the buffer. You can also signal errors explicitly with the functions &lt;code&gt;error&lt;/code&gt; and &lt;code&gt;signal&lt;/code&gt;.</source>
          <target state="translated">ほとんどのエラーは、整数の&lt;small&gt;CAR&lt;/small&gt;を取得しようとしたり、バッファの最後で文字を進めようとしたりする場合など、他の目的で呼び出すLispプリミティブ内で自動的に通知されます。関数 &lt;code&gt;error&lt;/code&gt; と &lt;code&gt;signal&lt;/code&gt; を使用して、エラーを明示的に通知することもできます。</target>
        </trans-unit>
        <trans-unit id="266fa78b8886478b8a397f099e61b861826a3118" translate="yes" xml:space="preserve">
          <source>Most keyboards also have &lt;em&gt;function keys&lt;/em&gt;&amp;mdash;keys that have names or symbols that are not characters. Function keys are represented in Emacs Lisp as symbols; the symbol&amp;rsquo;s name is the function key&amp;rsquo;s label, in lower case. For example, pressing a key labeled</source>
          <target state="translated">ほとんどのキーボードには、&lt;em&gt;ファンクションキー&lt;/em&gt;（文字ではない名前または記号を持つ&lt;em&gt;キー）&lt;/em&gt;もあり&lt;em&gt;ます&lt;/em&gt;。ファンクションキーはEmacsLispでは記号として表されます。記号の名前は、小文字のファンクションキーのラベルです。たとえば、ラベルの付いたキーを押す</target>
        </trans-unit>
        <trans-unit id="9f00659321a54a5b7e744a95bacbe846e1ba78fa" translate="yes" xml:space="preserve">
          <source>Most minor modes implement features that are independent of the major mode, and can thus be used with most major modes. For example, Auto Fill mode works with any major mode that permits text insertion. A few minor modes, however, are specific to a particular major mode. For example, Diff Auto Refine mode is a minor mode that is intended to be used only with Diff mode.</source>
          <target state="translated">ほとんどのマイナーモードはメジャーモードとは独立した機能を実装しているので、ほとんどのメジャーモードで使用できます。例えば、自動塗りつぶしモードは、テキストの挿入を許可するすべてのメジャーモードで動作します。しかし、いくつかのマイナーモードは特定のメジャーモードに特化しています。例えば、Diff オートリファインモードはマイナーなモードで、Diff モードでのみ使用することを意図しています。</target>
        </trans-unit>
        <trans-unit id="c397a5c428cdfab905c1bb14033fe204e686e090" translate="yes" xml:space="preserve">
          <source>Most needs are satisfied by these two ways that backtracking is automatically disabled, but occasionally it is useful to explicitly disable backtracking by using the &lt;code&gt;gate&lt;/code&gt; specification. This is useful when you know that no higher alternatives could apply. See the example of the &lt;code&gt;let&lt;/code&gt; specification.</source>
          <target state="translated">ほとんどのニーズは、バックトラッキングが自動的に無効になるこれらの2つの方法で満たされますが、 &lt;code&gt;gate&lt;/code&gt; 仕様を使用してバックトラッキングを明示的に無効にすると便利な場合があります。これは、より高い代替案が適用できないことがわかっている場合に役立ちます。 &lt;code&gt;let&lt;/code&gt; 仕様の例を参照してください。</target>
        </trans-unit>
        <trans-unit id="cc4ca8d6208ffb0d4a36e05a18b9c69498324dc6" translate="yes" xml:space="preserve">
          <source>Most of the Lisp functions for reading text take an &lt;em&gt;input stream&lt;/em&gt; as an argument. The input stream specifies where or how to get the characters of the text to be read. Here are the possible types of input stream:</source>
          <target state="translated">テキストを読み取るためのほとんどのLisp関数は、引数として&lt;em&gt;入力ストリーム&lt;/em&gt;を取ります。入力ストリームは、テキストの文字を読み取る場所または方法を指定します。入力ストリームの可能なタイプは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="f7fb5ab8ace2fa15e51d35ce50aee4d936080390" translate="yes" xml:space="preserve">
          <source>Most of the commands in this section return values that are not meaningful. All the functions that do filling take note of the current left margin, current right margin, and current justification style (see &lt;a href=&quot;margins#Margins&quot;&gt;Margins&lt;/a&gt;). If the current justification style is &lt;code&gt;none&lt;/code&gt;, the filling functions don&amp;rsquo;t actually do anything.</source>
          <target state="translated">このセクションのほとんどのコマンドは、意味のない値を返します。塗りつぶしを行うすべての関数は、現在の左マージン、現在の右マージン、および現在の位置揃えスタイルに注意します（&lt;a href=&quot;margins#Margins&quot;&gt;マージンを&lt;/a&gt;参照）。現在の位置合わせスタイルが &lt;code&gt;none&lt;/code&gt; の場合、塗りつぶし関数は実際には何もしません。</target>
        </trans-unit>
        <trans-unit id="cbad2a18a2d91f80015c7e2ea18ca8a1aab103fa" translate="yes" xml:space="preserve">
          <source>Most of the functions below take a name and sometimes an obarray as arguments. A &lt;code&gt;wrong-type-argument&lt;/code&gt; error is signaled if the name is not a string, or if the obarray is not a vector.</source>
          <target state="translated">以下の関数のほとんどは、名前と、場合によってはobarrayを引数として取ります。 &lt;code&gt;wrong-type-argument&lt;/code&gt; 名前が文字列でない場合、またはオブジェクト配列がベクトルでない場合はエラーが通知されます。</target>
        </trans-unit>
        <trans-unit id="68726f32511ba6a9522b1792a27d11825f7b4a12" translate="yes" xml:space="preserve">
          <source>Most of the functions described below became available in Emacs 25, the first Emacs release that supported dynamic modules. For the few functions that became available in later Emacs releases, we mention the first Emacs version that supported them.</source>
          <target state="translated">以下に説明する機能のほとんどは、ダイナミックモジュールをサポートした最初の Emacs リリースである Emacs 25 で利用できるようになりました。後のEmacsリリースで利用できるようになったいくつかの関数については、それらをサポートした最初のEmacsバージョンに言及しています。</target>
        </trans-unit>
        <trans-unit id="b3d67ad5f3eb4dfd9ab8ef87986f724f3ad34348" translate="yes" xml:space="preserve">
          <source>Most of the hooks in Emacs are &lt;em&gt;normal hooks&lt;/em&gt;. These variables contain lists of functions to be called with no arguments. By convention, whenever the hook name ends in &amp;lsquo;</source>
          <target state="translated">Emacsのフックのほとんどは&lt;em&gt;通常のフック&lt;/em&gt;です。これらの変数には、引数なしで呼び出される関数のリストが含まれています。慣例により、フック名が 'で終わる場合は常に</target>
        </trans-unit>
        <trans-unit id="fbcca09d8ca07315a2c9111b156bdf457cc5150a" translate="yes" xml:space="preserve">
          <source>Most of the kill commands are primarily for interactive use, and are not described here. What we do describe are the functions provided for use in writing such commands. You can use these functions to write commands for killing text. When you need to delete text for internal purposes within a Lisp function, you should normally use deletion functions, so as not to disturb the kill ring contents. See &lt;a href=&quot;deletion#Deletion&quot;&gt;Deletion&lt;/a&gt;.</source>
          <target state="translated">ほとんどのkillコマンドは主にインタラクティブな使用を目的としているため、ここでは説明しません。ここで説明するのは、そのようなコマンドの作成に使用するために提供されている関数です。これらの関数を使用して、テキストを強制終了するコマンドを作成できます。Lisp関数内の内部目的でテキストを削除する必要がある場合は、通常、キルリングの内容を乱さないように削除関数を使用する必要があります。&lt;a href=&quot;deletion#Deletion&quot;&gt;削除を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="cc3c2124fc3bae720b8252b979a43c48fb44d9b9" translate="yes" xml:space="preserve">
          <source>Most of the time, functions are called when their names are written in Lisp expressions in Lisp programs. However, you can construct or obtain a function object at run time and then call it with the primitive functions &lt;code&gt;funcall&lt;/code&gt; and &lt;code&gt;apply&lt;/code&gt;. See &lt;a href=&quot;calling-functions#Calling-Functions&quot;&gt;Calling Functions&lt;/a&gt;.</source>
          <target state="translated">ほとんどの場合、関数は、その名前がLispプログラムのLisp式で記述されているときに呼び出されます。ただし、実行時に関数オブジェクトを作成または取得してから、プリミティブ関数 &lt;code&gt;funcall&lt;/code&gt; および &lt;code&gt;apply&lt;/code&gt; を使用して呼び出すことができます。&lt;a href=&quot;calling-functions#Calling-Functions&quot;&gt;関数の呼び出しを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="ad2a15ba084ba8bc4aa18e87ac5aa225a45b1c5d" translate="yes" xml:space="preserve">
          <source>Most of the time, it&amp;rsquo;s not useful to distinguish the two. So normally &lt;code&gt;local-function-key-map&lt;/code&gt; (see &lt;a href=&quot;translation-keymaps#Translation-Keymaps&quot;&gt;Translation Keymaps&lt;/a&gt;) is set up to map &lt;code&gt;tab&lt;/code&gt; into 9. Thus, a key binding for character code 9 (the character</source>
          <target state="translated">ほとんどの場合、2つを区別することは役に立ちません。したがって、通常、 &lt;code&gt;local-function-key-map&lt;/code&gt; （&lt;a href=&quot;translation-keymaps#Translation-Keymaps&quot;&gt;翻訳&lt;/a&gt;キーマップを参照）は、 &lt;code&gt;tab&lt;/code&gt; を9にマップするように設定されます。したがって、文字コード9（文字</target>
        </trans-unit>
        <trans-unit id="abe6f1d63c7f88d045c5b31ba7795c4ed74c53bd" translate="yes" xml:space="preserve">
          <source>Most of these error symbols are defined in C (mainly</source>
          <target state="translated">これらのエラーシンボルのほとんどはC言語で定義されています(主に</target>
        </trans-unit>
        <trans-unit id="49da26863e7f22566b2cf4a25068c25f6cd2d052" translate="yes" xml:space="preserve">
          <source>Most of these variables have names ending with &amp;lsquo;</source>
          <target state="translated">これらの変数のほとんどは、 'で終わる名前を持っています</target>
        </trans-unit>
        <trans-unit id="9c4e0cce8a81ef3708db9a9d44182e2b8fe94a9d" translate="yes" xml:space="preserve">
          <source>Most often, forms are evaluated automatically, by virtue of their occurrence in a program being run. On rare occasions, you may need to write code that evaluates a form that is computed at run time, such as after reading a form from text being edited or getting one from a property list. On these occasions, use the &lt;code&gt;eval&lt;/code&gt; function. Often &lt;code&gt;eval&lt;/code&gt; is not needed and something else should be used instead. For example, to get the value of a variable, while &lt;code&gt;eval&lt;/code&gt; works, &lt;code&gt;symbol-value&lt;/code&gt; is preferable; or rather than store expressions in a property list that then need to go through &lt;code&gt;eval&lt;/code&gt;, it is better to store functions instead that are then passed to &lt;code&gt;funcall&lt;/code&gt;.</source>
          <target state="translated">ほとんどの場合、フォームは、実行中のプログラムで発生するため、自動的に評価されます。まれに、編集中のテキストからフォームを読み取ったり、プロパティリストからフォームを取得したりした後など、実行時に計算されるフォームを評価するコードを作成する必要がある場合があります。このような場合は、 &lt;code&gt;eval&lt;/code&gt; 関数を使用してください。多くの場合、 &lt;code&gt;eval&lt;/code&gt; は不要であり、代わりに他のものを使用する必要があります。たとえば、変数の値を取得するには、 &lt;code&gt;eval&lt;/code&gt; が機能している間、 &lt;code&gt;symbol-value&lt;/code&gt; が望ましいです。または、 &lt;code&gt;eval&lt;/code&gt; を実行する必要があるプロパティリストに式を格納するのではなく、関数を格納してから &lt;code&gt;funcall&lt;/code&gt; に渡す方が適切です。</target>
        </trans-unit>
        <trans-unit id="aa3d06d22c97d444806afc27e617f43b0ad086a7" translate="yes" xml:space="preserve">
          <source>Most often, the &lt;var&gt;types&lt;/var&gt; in a &lt;code&gt;set&lt;/code&gt; are &lt;code&gt;const&lt;/code&gt; types, as shown here:</source>
          <target state="translated">ほとんどの場合、 &lt;var&gt;types&lt;/var&gt; で &lt;code&gt;set&lt;/code&gt; ある &lt;code&gt;const&lt;/code&gt; ここに示すように、タイプ：</target>
        </trans-unit>
        <trans-unit id="2104b44b9ba0cc9d20b66b199ac691005bd0bed2" translate="yes" xml:space="preserve">
          <source>Most uses of &lt;code&gt;eval-and-compile&lt;/code&gt; are fairly sophisticated.</source>
          <target state="translated">&lt;code&gt;eval-and-compile&lt;/code&gt; のほとんどの使用法はかなり洗練されています。</target>
        </trans-unit>
        <trans-unit id="81869f1759c2b1872ff235184d70faf9f4fd2d64" translate="yes" xml:space="preserve">
          <source>Most window systems use a desktop metaphor. Part of this metaphor is the idea that system-level windows (representing, e.g., Emacs frames) are stacked in a notional third dimension perpendicular to the screen surface. The order induced by stacking is total and usually referred to as stacking (or Z-) order. Where the areas of two windows overlap, the one higher up in that order will (partially) cover the one underneath.</source>
          <target state="translated">ほとんどのウィンドウシステムでは、デスクトップのメタファーを使用しています。このメタファーの一部は、システムレベルのウィンドウ(例えば、Emacs フレームを表す)が、スクリーンの表面に垂直な概念的な三次元でスタックされているという考え方です。スタッキングによって引き起こされる順序は合計であり、通常はスタッキング(またはZ-)順序と呼ばれています。2 つのウィンドウの領域が重なっている場合、その順番で上の方が下の方を(部分的に)カバーします。</target>
        </trans-unit>
        <trans-unit id="0a9fbf9f714ce6a3a5ea4ced3ed7f3d62099211d" translate="yes" xml:space="preserve">
          <source>Most window-systems clip a child frame at the native edges (see &lt;a href=&quot;frame-geometry#Frame-Geometry&quot;&gt;Frame Geometry&lt;/a&gt;) of its parent frame&amp;mdash;everything outside these edges is usually invisible. A child frame&amp;rsquo;s &lt;code&gt;left&lt;/code&gt; and &lt;code&gt;top&lt;/code&gt; parameters specify a position relative to the top-left corner of its parent&amp;rsquo;s native frame. When the parent frame is resized, this position remains conceptually unaltered.</source>
          <target state="translated">ほとんどのウィンドウシステムは、親フレームのネイティブエッジ（&lt;a href=&quot;frame-geometry#Frame-Geometry&quot;&gt;フレームジオメトリを&lt;/a&gt;参照）で子フレームをクリップします。これらのエッジの外側は通常、すべて見えません。子フレームの &lt;code&gt;left&lt;/code&gt; パラメータと &lt;code&gt;top&lt;/code&gt; パラメータは、親のネイティブフレームの左上隅を基準にした位置を指定します。親フレームのサイズが変更されても、この位置は概念的に変更されません。</target>
        </trans-unit>
        <trans-unit id="852329adec48160b733c7ed9efcc2bd1ea539df5" translate="yes" xml:space="preserve">
          <source>Mostly, however, this function is called automatically at an appropriate time.</source>
          <target state="translated">しかし、ほとんどの場合、この関数は適切なタイミングで自動的に呼び出されます。</target>
        </trans-unit>
        <trans-unit id="e040db2b7f1361a938099464de9858040e353ddb" translate="yes" xml:space="preserve">
          <source>Motion</source>
          <target state="translated">Motion</target>
        </trans-unit>
        <trans-unit id="4c333f9eac917041de2dbe5d4e12612fb84fb008" translate="yes" xml:space="preserve">
          <source>Motion Commands Based on Parsing</source>
          <target state="translated">パーシングに基づくモーションコマンド</target>
        </trans-unit>
        <trans-unit id="e8a12b0b4cf9966d415d89a1d69b08c8352f976f" translate="yes" xml:space="preserve">
          <source>Motion Events</source>
          <target state="translated">モーションイベント</target>
        </trans-unit>
        <trans-unit id="91315d6877510cf4da5e405826b3221c94135c3e" translate="yes" xml:space="preserve">
          <source>Motion and Syntax</source>
          <target state="translated">モーションと構文</target>
        </trans-unit>
        <trans-unit id="e092df3cd889f7ec86f740980f392f5d6e8af02e" translate="yes" xml:space="preserve">
          <source>Motion by Characters</source>
          <target state="translated">キャラクターによる動き</target>
        </trans-unit>
        <trans-unit id="d2ce7e2f90144ab22f36527dc8781160c756549d" translate="yes" xml:space="preserve">
          <source>Motion by Screen Lines</source>
          <target state="translated">スクリーンラインによる動き</target>
        </trans-unit>
        <trans-unit id="4dce4bd28a86b1ce27d0bd612a7561462c7cc60b" translate="yes" xml:space="preserve">
          <source>Motion by Text Lines</source>
          <target state="translated">テキストラインによる動き</target>
        </trans-unit>
        <trans-unit id="2d29ecb574b2bce083871d9d9c13f5b680f74abd" translate="yes" xml:space="preserve">
          <source>Motion by Words</source>
          <target state="translated">言葉による動き</target>
        </trans-unit>
        <trans-unit id="633150abc226c78ac7b073c2e31944ab3ddd0ae8" translate="yes" xml:space="preserve">
          <source>Motion functions change the value of point, either relative to the current value of point, relative to the beginning or end of the buffer, or relative to the edges of the selected window. See &lt;a href=&quot;point#Point&quot;&gt;Point&lt;/a&gt;.</source>
          <target state="translated">モーション関数は、ポイントの現在の値、バッファの開始または終了、または選択したウィンドウのエッジのいずれかを基準にして、ポイントの値を変更します。&lt;a href=&quot;point#Point&quot;&gt;ポイントを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="013a79eacf73d8474d69b249a7fcb74f3bc7d072" translate="yes" xml:space="preserve">
          <source>Motion functions that work by parsing.</source>
          <target state="translated">パースすることで動作するモーション機能。</target>
        </trans-unit>
        <trans-unit id="37802ebb8eb19a12e9b66522e9d801b5abfc80a9" translate="yes" xml:space="preserve">
          <source>Motion to an End of the Buffer</source>
          <target state="translated">バッファ終了の動き</target>
        </trans-unit>
        <trans-unit id="48637a9a84940dbd837461865518bd9300ca2cf2" translate="yes" xml:space="preserve">
          <source>Mouse Dragging Parameters</source>
          <target state="translated">マウスドラッグのパラメータ</target>
        </trans-unit>
        <trans-unit id="b239ecd4f1b125963a812db57dc3cec60573502b" translate="yes" xml:space="preserve">
          <source>Mouse Events</source>
          <target state="translated">マウスイベント</target>
        </trans-unit>
        <trans-unit id="99a6a713af3081ea16c4b4ba861aeaea079ffefd" translate="yes" xml:space="preserve">
          <source>Mouse Position</source>
          <target state="translated">マウスの位置</target>
        </trans-unit>
        <trans-unit id="c15f4049211f898d49c97d76dd71469c52292f33" translate="yes" xml:space="preserve">
          <source>Mouse Tracking</source>
          <target state="translated">マウストラッキング</target>
        </trans-unit>
        <trans-unit id="4a803cb0d07554c2f9f3761b9162a772b63c4e18" translate="yes" xml:space="preserve">
          <source>Mouse Window Auto-selection</source>
          <target state="translated">マウスウィンドウの自動選択</target>
        </trans-unit>
        <trans-unit id="f47c56f8e3df66caa71e2d0ce49ed9adb3c1a9bd" translate="yes" xml:space="preserve">
          <source>Mouse auto-selection can be used to emulate a focus follows mouse policy for child frames (see &lt;a href=&quot;child-frames#Child-Frames&quot;&gt;Child Frames&lt;/a&gt;) which usually are not tracked by the window manager. This requires to set the value of &lt;code&gt;focus-follows-mouse&lt;/code&gt; (see &lt;a href=&quot;input-focus#Input-Focus&quot;&gt;Input Focus&lt;/a&gt;) to a non-&lt;code&gt;nil&lt;/code&gt; value. If the value of &lt;code&gt;focus-follows-mouse&lt;/code&gt; is &lt;code&gt;auto-raise&lt;/code&gt;, entering a child frame with the mouse will raise it automatically above all other child frames of that frame&amp;rsquo;s parent frame.</source>
          <target state="translated">マウスの自動選択は、フォーカスをエミュレートするために使用することができる子フレーム（参照用マウスポリシー以下&lt;a href=&quot;child-frames#Child-Frames&quot;&gt;子フレームを&lt;/a&gt;通常ウィンドウマネージャによって追跡されていません）。これには、 &lt;code&gt;focus-follows-mouse&lt;/code&gt; （&lt;a href=&quot;input-focus#Input-Focus&quot;&gt;入力フォーカスを&lt;/a&gt;参照）の値を &lt;code&gt;nil&lt;/code&gt; 以外の値に設定する必要があります。 &lt;code&gt;focus-follows-mouse&lt;/code&gt; の値が &lt;code&gt;auto-raise&lt;/code&gt; 場合、マウスで子フレームを入力すると、そのフレームの親フレームの他のすべての子フレームよりも自動的にレイズされます。</target>
        </trans-unit>
        <trans-unit id="2df64335cf98c72ba6ba9a9e8bb30c7f288e379f" translate="yes" xml:space="preserve">
          <source>Mouse auto-selection selects the minibuffer window only if it is active, and never deselects the active minibuffer window.</source>
          <target state="translated">マウスの自動選択は、ミニバッファウィンドウがアクティブな場合にのみ選択し、アクティブなミニバッファウィンドウの選択を解除することはありません。</target>
        </trans-unit>
        <trans-unit id="e56ccfe134223b80437e24ef8272e7c77b397941" translate="yes" xml:space="preserve">
          <source>Move back to the previous place that a question was asked about.</source>
          <target state="translated">質問のあった前の場所に移動します。</target>
        </trans-unit>
        <trans-unit id="fcfc1a5d81c2fd67d3d58302e0edda1d94a48c17" translate="yes" xml:space="preserve">
          <source>Move point back to the current stop point in the source code buffer (&lt;code&gt;edebug-where&lt;/code&gt;).</source>
          <target state="translated">ポイントをソースコードバッファ内の現在の停止ポイントに戻します（ &lt;code&gt;edebug-where&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="e8011edd1eeb2660ed2ab6bdc47c4b387b009944" translate="yes" xml:space="preserve">
          <source>Move point to &lt;var&gt;limit&lt;/var&gt; (or the end of the accessible portion of the buffer) and return &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">ポイントを &lt;var&gt;limit&lt;/var&gt; （またはバッファのアクセス可能な部分の終わり）に移動し、 &lt;code&gt;nil&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="97b7fff41223832602e81589fc86fce13dac6227" translate="yes" xml:space="preserve">
          <source>Move point to the next breakpoint in the current definition (&lt;code&gt;edebug-next-breakpoint&lt;/code&gt;).</source>
          <target state="translated">ポイントを現在の定義の次のブレークポイントに移動します（ &lt;code&gt;edebug-next-breakpoint&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="ef08217195a398b9b9595051fd75d3bbcfe68238" translate="yes" xml:space="preserve">
          <source>Move the pen to the first point in &lt;var&gt;points&lt;/var&gt;. Additional points are connected with lines. &lt;var&gt;points&lt;/var&gt; is a list of X/Y coordinate pairs. Subsequent &lt;code&gt;moveto&lt;/code&gt; commands represent the start of a new &lt;em&gt;subpath&lt;/em&gt;.</source>
          <target state="translated">最初の点にペンを移動 &lt;var&gt;points&lt;/var&gt; 。追加のポイントは線で接続されます。 &lt;var&gt;points&lt;/var&gt; は、X / Y座標ペアのリストです。後続の &lt;code&gt;moveto&lt;/code&gt; コマンドは、新しい&lt;em&gt;サブパスの&lt;/em&gt;開始を表します。</target>
        </trans-unit>
        <trans-unit id="f66eccc892556cafb6abe680c2768bcdf1cc6f5c" translate="yes" xml:space="preserve">
          <source>Move to first non-blank character.</source>
          <target state="translated">ブランクのない最初の文字に移動します。</target>
        </trans-unit>
        <trans-unit id="77f061b9a5f55737090245a4c987a501fd31859d" translate="yes" xml:space="preserve">
          <source>Move to the &lt;var&gt;n&lt;/var&gt;th next button, or &lt;var&gt;n&lt;/var&gt;th previous button if &lt;var&gt;n&lt;/var&gt; is negative. If &lt;var&gt;n&lt;/var&gt; is zero, move to the start of any button at point. If &lt;var&gt;wrap&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, moving past either end of the buffer continues from the other end. If &lt;var&gt;display-message&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, the button&amp;rsquo;s help-echo string is displayed. Any button with a non-&lt;code&gt;nil&lt;/code&gt;&lt;code&gt;skip&lt;/code&gt; property is skipped over. Returns the button found, and signals an error if no buttons can be found. If &lt;var&gt;no-error&lt;/var&gt; in non-&lt;code&gt;nil&lt;/code&gt;, return nil instead of signaling the error.</source>
          <target state="translated">&lt;var&gt;n&lt;/var&gt; 番目の次のボタン、または &lt;var&gt;n&lt;/var&gt; が負の場合は &lt;var&gt;n&lt;/var&gt; 番目の前のボタンに移動します。 &lt;var&gt;n&lt;/var&gt; がゼロの場合、任意のボタンの先頭に移動します。 &lt;var&gt;wrap&lt;/var&gt; が &lt;code&gt;nil&lt;/code&gt; 以外の場合、バッファのいずれかの端を通過する移動は、もう一方の端から続行されます。場合は &lt;var&gt;display-message&lt;/var&gt; 非で &lt;code&gt;nil&lt;/code&gt; に、ボタンのヘルプエコー文字列が表示されます。 &lt;code&gt;nil&lt;/code&gt; 以外の &lt;code&gt;skip&lt;/code&gt; プロパティを持つボタンはすべてスキップされます。見つかったボタンを返し、ボタンが見つからない場合はエラーを通知します。 &lt;code&gt;nil&lt;/code&gt; 以外で &lt;var&gt;no-error&lt;/var&gt; しない場合は、エラーを通知する代わりにnilを返します。</target>
        </trans-unit>
        <trans-unit id="43a8000e954824d989286ea299c734a6c7cfc47e" translate="yes" xml:space="preserve">
          <source>Move to the &lt;var&gt;n&lt;/var&gt;th previous button, or &lt;var&gt;n&lt;/var&gt;th next button if &lt;var&gt;n&lt;/var&gt; is negative. If &lt;var&gt;n&lt;/var&gt; is zero, move to the start of any button at point. If &lt;var&gt;wrap&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, moving past either end of the buffer continues from the other end. If &lt;var&gt;display-message&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, the button&amp;rsquo;s help-echo string is displayed. Any button with a non-&lt;code&gt;nil&lt;/code&gt;&lt;code&gt;skip&lt;/code&gt; property is skipped over. Returns the button found, and signals an error if no buttons can be found. If &lt;var&gt;no-error&lt;/var&gt; in non-&lt;code&gt;nil&lt;/code&gt;, return nil instead of signaling the error.</source>
          <target state="translated">&lt;var&gt;n&lt;/var&gt; 番目の前のボタンに移動するか、 &lt;var&gt;n&lt;/var&gt; が負の場合は &lt;var&gt;n&lt;/var&gt; 番目の次のボタンに移動します。 &lt;var&gt;n&lt;/var&gt; がゼロの場合、任意のボタンの先頭に移動します。 &lt;var&gt;wrap&lt;/var&gt; が &lt;code&gt;nil&lt;/code&gt; 以外の場合、バッファのいずれかの端を通過する移動は、もう一方の端から続行されます。場合は &lt;var&gt;display-message&lt;/var&gt; 非で &lt;code&gt;nil&lt;/code&gt; に、ボタンのヘルプエコー文字列が表示されます。 &lt;code&gt;nil&lt;/code&gt; 以外の &lt;code&gt;skip&lt;/code&gt; プロパティを持つボタンはすべてスキップされます。見つかったボタンを返し、ボタンが見つからない場合はエラーを通知します。 &lt;code&gt;nil&lt;/code&gt; 以外で &lt;var&gt;no-error&lt;/var&gt; しない場合は、エラーを通知する代わりにnilを返します。</target>
        </trans-unit>
        <trans-unit id="82c00742d33b45dc4a64242477e55b1102b66060" translate="yes" xml:space="preserve">
          <source>Move to the beginning of the frame, or to the beginning of the previous frame.</source>
          <target state="translated">枠の先頭、または前の枠の先頭に移動します。</target>
        </trans-unit>
        <trans-unit id="f893b5353d62ff9e12c35b7fb0f50fcaa8318d21" translate="yes" xml:space="preserve">
          <source>Move to the beginning of the next frame.</source>
          <target state="translated">次のフレームの先頭に移動します。</target>
        </trans-unit>
        <trans-unit id="f297af264dbf0d0932fcc470cbe1fecf16841cb6" translate="yes" xml:space="preserve">
          <source>Moving Marker Positions</source>
          <target state="translated">移動マーカーの位置</target>
        </trans-unit>
        <trans-unit id="0bd65246c05a2e512da13871350157d560493acf" translate="yes" xml:space="preserve">
          <source>Moving around the existing windows.</source>
          <target state="translated">既存の窓の周りを移動。</target>
        </trans-unit>
        <trans-unit id="2450710a86f0e38a5a79572127c7c737f5ad650e" translate="yes" xml:space="preserve">
          <source>Moving by parsing lists and sexps.</source>
          <target state="translated">リストやSexpsを解析して移動します。</target>
        </trans-unit>
        <trans-unit id="bcf6a5cad29fb42b7bcbea23a358b3e4f0f14190" translate="yes" xml:space="preserve">
          <source>Moving in terms of characters.</source>
          <target state="translated">文字で動くこと。</target>
        </trans-unit>
        <trans-unit id="5a0a7594babae65e9fe76da6d52f721490d43cae" translate="yes" xml:space="preserve">
          <source>Moving in terms of lines as displayed.</source>
          <target state="translated">表示されたままのラインでの移動。</target>
        </trans-unit>
        <trans-unit id="13133c035ed058b88d7defb0074a4f22a2f70555" translate="yes" xml:space="preserve">
          <source>Moving in terms of lines of text.</source>
          <target state="translated">文章の行数で移動すること。</target>
        </trans-unit>
        <trans-unit id="26b889272e175455d666cb66239aca23e15df9b4" translate="yes" xml:space="preserve">
          <source>Moving in terms of words.</source>
          <target state="translated">言葉で動くこと。</target>
        </trans-unit>
        <trans-unit id="53e7a90c8dae3998834ecec2913e2cd430599962" translate="yes" xml:space="preserve">
          <source>Moving over Balanced Expressions</source>
          <target state="translated">バランスの取れた式を移動する</target>
        </trans-unit>
        <trans-unit id="8693a264fbf00aa36cb635bdd23ca472a4fefbca" translate="yes" xml:space="preserve">
          <source>Moving over characters with certain syntaxes.</source>
          <target state="translated">特定の構文で文字を移動します。</target>
        </trans-unit>
        <trans-unit id="042aaa586f3cf81580cc5e1f174b18fabcc9a6c1" translate="yes" xml:space="preserve">
          <source>Moving text up and down through the window.</source>
          <target state="translated">ウィンドウ内でテキストを上下に移動します。</target>
        </trans-unit>
        <trans-unit id="e0d03b42d9316b69bb4bfb00e411362bd9b92f0d" translate="yes" xml:space="preserve">
          <source>Moving the contents sideways on the window.</source>
          <target state="translated">ウィンドウ上で内容を横に移動します。</target>
        </trans-unit>
        <trans-unit id="16062acc29ac83c08f815d725d13ca53166d371d" translate="yes" xml:space="preserve">
          <source>Moving the contents up and down on the window.</source>
          <target state="translated">ウィンドウの上で内容を上下に移動させます。</target>
        </trans-unit>
        <trans-unit id="7d1c895a6a69bb551cb3ab05a9436825b15affd7" translate="yes" xml:space="preserve">
          <source>Moving the marker to a new buffer or position.</source>
          <target state="translated">マーカーを新しいバッファまたは位置に移動します。</target>
        </trans-unit>
        <trans-unit id="ef6300d4905ba5885914045db1c0057a8e7f4297" translate="yes" xml:space="preserve">
          <source>Moving the mouse before releasing the button.</source>
          <target state="translated">ボタンを離す前にマウスを動かす</target>
        </trans-unit>
        <trans-unit id="96d5ebfd5d41e3ac266699afa4c07f17d42dc6a2" translate="yes" xml:space="preserve">
          <source>Moving the mouse between frames.</source>
          <target state="translated">フレーム間でのマウスの移動。</target>
        </trans-unit>
        <trans-unit id="1a17774ff24591b3f0339a2975566bc3052acf2a" translate="yes" xml:space="preserve">
          <source>Moving to the beginning or end of the buffer.</source>
          <target state="translated">バッファの先頭または末尾に移動します。</target>
        </trans-unit>
        <trans-unit id="6bc8df29048775edb3b67797f960add5fb20f24e" translate="yes" xml:space="preserve">
          <source>Multi-Frame Images</source>
          <target state="translated">マルチフレーム画像</target>
        </trans-unit>
        <trans-unit id="075c17f7c3e017a54cdac2a44040577e98923617" translate="yes" xml:space="preserve">
          <source>Multi-file Packages</source>
          <target state="translated">マルチファイルパッケージ</target>
        </trans-unit>
        <trans-unit id="5dd969976c5aa3ebe5d20441de8bf258343ebb9c" translate="yes" xml:space="preserve">
          <source>Multiline Font Lock Constructs</source>
          <target state="translated">マルチラインフォントロックの構築</target>
        </trans-unit>
        <trans-unit id="850c8a0b5e9ff569211d95d52d7ed685c25d8241" translate="yes" xml:space="preserve">
          <source>Multiple Terminals</source>
          <target state="translated">複数の端子</target>
        </trans-unit>
        <trans-unit id="0b79f8e4890c8608e67c29a1e344d765772f2753" translate="yes" xml:space="preserve">
          <source>Mutability</source>
          <target state="translated">Mutability</target>
        </trans-unit>
        <trans-unit id="ad5e52be06b8d534aed54257f0dbf7aa8ff2ec03" translate="yes" xml:space="preserve">
          <source>Mutex Type</source>
          <target state="translated">ミューテックスタイプ</target>
        </trans-unit>
        <trans-unit id="dd060da851122b430bf0f99b458f73ce7b008e14" translate="yes" xml:space="preserve">
          <source>Mutex objects have no read syntax. They print in hash notation, giving the name of the mutex (if it has been given a name) or its address in core:</source>
          <target state="translated">Mutex オブジェクトには読み込み構文はありません。これらのオブジェクトはハッシュ表記で表示され、ミューテックスの名前(名前が与えられている場合)またはコアのアドレスを指定します。</target>
        </trans-unit>
        <trans-unit id="82f2c9599c5c14be2ce92b9de958cb57db81b38f" translate="yes" xml:space="preserve">
          <source>Mutexes</source>
          <target state="translated">Mutexes</target>
        </trans-unit>
        <trans-unit id="5255835bbfa8722501d3084e2ba916530d5a554c" translate="yes" xml:space="preserve">
          <source>Mutexes allow exclusive access to data.</source>
          <target state="translated">ミューテックスは、データへの排他的なアクセスを可能にします。</target>
        </trans-unit>
        <trans-unit id="b51a60734da64be0e618bacbea2865a8a7dcd669" translate="yes" xml:space="preserve">
          <source>N</source>
          <target state="translated">N</target>
        </trans-unit>
        <trans-unit id="ad4ff2f947bcd2ef0dc89fd3a7ca83591ba37e18" translate="yes" xml:space="preserve">
          <source>NS builds consider the tool bar to be a decoration, and therefore hide it on an undecorated frame.</source>
          <target state="translated">NS ビルドでは、ツールバーを装飾とみなしているため、装飾されていないフレームに隠すようになっています。</target>
        </trans-unit>
        <trans-unit id="e97a54619a408647abe8729216664f6e3b8d47e9" translate="yes" xml:space="preserve">
          <source>NS builds do not clip child frames at the parent frame&amp;rsquo;s edges, allowing them to be positioned so they do not obscure the parent frame while still being visible themselves.</source>
          <target state="translated">NSビルドは、親フレームのエッジで子フレームをクリップしないため、子フレームを配置して、それ自体が表示されているときに親フレームを覆い隠さないようにすることができます。</target>
        </trans-unit>
        <trans-unit id="eef19c54306daa69eda49c0272623bdb5e2b341f" translate="yes" xml:space="preserve">
          <source>NULL</source>
          <target state="translated">NULL</target>
        </trans-unit>
        <trans-unit id="93ba4abc16637fa77fe2aca725d91f288b90cfbb" translate="yes" xml:space="preserve">
          <source>NaCl</source>
          <target state="translated">NaCl</target>
        </trans-unit>
        <trans-unit id="f7fd9c68f804acda665d2ab082217bb1583318f2" translate="yes" xml:space="preserve">
          <source>NaN</source>
          <target state="translated">NaN</target>
        </trans-unit>
        <trans-unit id="709a23220f2c3d64d1e1d6d18c4d5280f8d82fca" translate="yes" xml:space="preserve">
          <source>Name</source>
          <target state="translated">Name</target>
        </trans-unit>
        <trans-unit id="33b8ab26e443037c1b6a008d5daac383b918372d" translate="yes" xml:space="preserve">
          <source>Name of the physical monitor as &lt;var&gt;string&lt;/var&gt;.</source>
          <target state="translated">&lt;var&gt;string&lt;/var&gt; としての物理モニターの名前。</target>
        </trans-unit>
        <trans-unit id="33fc3e5c2e89aacc9b50f1169d442c12bb23fe2c" translate="yes" xml:space="preserve">
          <source>Naming Backup Files</source>
          <target state="translated">バックアップファイルの名前付け</target>
        </trans-unit>
        <trans-unit id="e93d31d911fab1a3e2aba574d0e113197a0b7e55" translate="yes" xml:space="preserve">
          <source>Naming a Function</source>
          <target state="translated">関数の命名</target>
        </trans-unit>
        <trans-unit id="697edbe4acd10b9466b672837ee81bd016c23b79" translate="yes" xml:space="preserve">
          <source>Narrow</source>
          <target state="translated">Narrow</target>
        </trans-unit>
        <trans-unit id="8ecb67c30433187282f082e25e52e62490e245cc" translate="yes" xml:space="preserve">
          <source>Narrowing</source>
          <target state="translated">Narrowing</target>
        </trans-unit>
        <trans-unit id="ba453f44e68e8506ff49aa121453956a2b98d6dd" translate="yes" xml:space="preserve">
          <source>Narrowing is specified with two buffer positions, which become the beginning and end of the accessible portion. For most editing commands and primitives, these positions replace the values of the beginning and end of the buffer. While narrowing is in effect, no text outside the accessible portion is displayed, and point cannot move outside the accessible portion. Note that narrowing does not alter actual buffer positions (see &lt;a href=&quot;point#Point&quot;&gt;Point&lt;/a&gt;); it only determines which positions are considered the accessible portion of the buffer. Most functions refuse to operate on text that is outside the accessible portion.</source>
          <target state="translated">ナローイングは、アクセス可能な部分の開始と終了になる2つのバッファー位置で指定されます。ほとんどの編集コマンドおよびプリミティブでは、これらの位置がバッファーの開始値と終了値を置き換えます。ナローイングが有効になっている間、アクセス可能な部分の外側のテキストは表示されず、ポイントはアクセス可能な部分の外側に移動できません。ナローイングは実際のバッファー位置を変更しないことに注意してください（&lt;a href=&quot;point#Point&quot;&gt;ポイントを&lt;/a&gt;参照）。バッファのアクセス可能な部分と見なされる位置を決定するだけです。ほとんどの関数は、アクセス可能な部分の外側にあるテキストの操作を拒否します。</target>
        </trans-unit>
        <trans-unit id="7bdf9620ee53a876bad1749f32c91f0860d2de5f" translate="yes" xml:space="preserve">
          <source>Native Frame</source>
          <target state="translated">ネイティブフレーム</target>
        </trans-unit>
        <trans-unit id="bd2f2298f83f47b01df37aff3486ab3d7c655bdf" translate="yes" xml:space="preserve">
          <source>Naturally, Emacs will never signal &lt;code&gt;new-error&lt;/code&gt; on its own; only an explicit call to &lt;code&gt;signal&lt;/code&gt; (see &lt;a href=&quot;signaling-errors#Definition-of-signal&quot;&gt;Definition of signal&lt;/a&gt;) in your code can do this:</source>
          <target state="translated">当然、Emacsはそれ自体で &lt;code&gt;new-error&lt;/code&gt; することはありません。唯一の明示的な呼び出し &lt;code&gt;signal&lt;/code&gt; （参照&lt;a href=&quot;signaling-errors#Definition-of-signal&quot;&gt;信号の定義を&lt;/a&gt;）あなたのコードでこれを行うことができます。</target>
        </trans-unit>
        <trans-unit id="3d596b97b9719e1805fb3852fa7a7684551f102c" translate="yes" xml:space="preserve">
          <source>Negative parameter values position the right edge of the outer frame by &lt;var&gt;-x&lt;/var&gt; pixels left from the right edge of the screen (or the parent frame&amp;rsquo;s native rectangle) and the bottom edge by &lt;var&gt;-y&lt;/var&gt; pixels up from the bottom edge of the screen (or the parent frame&amp;rsquo;s native rectangle).</source>
          <target state="translated">負パラメータ値の位置によって、外枠の右端 &lt;var&gt;-x&lt;/var&gt; による画面の右端（または親フレームのネイティブ長方形）から左画素及び下端 &lt;var&gt;-y&lt;/var&gt; 画面の下端からのピクセルアップ（または親フレームのネイティブ長方形）。</target>
        </trans-unit>
        <trans-unit id="5806a4fdd1b51a9d2dde88f7b0063ac5bf8c2a79" translate="yes" xml:space="preserve">
          <source>Negative values never indicate an offset from the right or bottom edge of &lt;var&gt;frame&lt;/var&gt;&amp;rsquo;s display or parent frame. Rather, they mean that &lt;var&gt;frame&lt;/var&gt;&amp;rsquo;s outer position is on the left and/or above the origin of its display or the native position of its parent frame. This usually means that &lt;var&gt;frame&lt;/var&gt; is only partially visible (or completely invisible). However, on systems where the display&amp;rsquo;s origin does not coincide with its top-left corner, the frame may be visible on a secondary monitor.</source>
          <target state="translated">負の値は、 &lt;var&gt;frame&lt;/var&gt; のディスプレイまたは親フレームの右端または下端からのオフセットを示すことはありません。むしろ、 &lt;var&gt;frame&lt;/var&gt; の外側の位置が、ディスプレイの原点または親フレームのネイティブ位置の左側および/または上にあることを意味します。これは通常、 &lt;var&gt;frame&lt;/var&gt; が部分的にしか見えない（または完全に見えない）ことを意味します。ただし、ディスプレイの原点が左上隅と一致しないシステムでは、フレームがセカンダリモニターに表示される場合があります。</target>
        </trans-unit>
        <trans-unit id="50f671274ba560467341410034be03976b38330e" translate="yes" xml:space="preserve">
          <source>Nested association lists is supported:</source>
          <target state="translated">入れ子になったアソシエーションリストをサポートしています。</target>
        </trans-unit>
        <trans-unit id="c347c211993fddc45bd180abc87a138a590651c8" translate="yes" xml:space="preserve">
          <source>Nested use of several change groups for the same buffer works as you would expect. Non-nested use of change groups for the same buffer will get Emacs confused, so don&amp;rsquo;t let it happen; the first change group you start for any given buffer should be the last one finished.</source>
          <target state="translated">同じバッファに対して複数の変更グループをネストして使用すると、期待どおりに機能します。同じバッファに変更グループをネストせずに使用すると、Emacsが混乱するため、発生させないでください。特定のバッファに対して最初に開始する変更グループは、最後に終了する必要があります。</target>
        </trans-unit>
        <trans-unit id="d179e139906d2dd2f78172ff8723394a1290a6a3" translate="yes" xml:space="preserve">
          <source>Nesting &lt;code&gt;let-alist&lt;/code&gt; inside each other is allowed, but the code in the inner &lt;code&gt;let-alist&lt;/code&gt; can&amp;rsquo;t access the variables bound by the outer &lt;code&gt;let-alist&lt;/code&gt;.</source>
          <target state="translated">ネスト &lt;code&gt;let-alist&lt;/code&gt; 互いに内部が許可されていますが、内部のコード &lt;code&gt;let-alist&lt;/code&gt; 外側に拘束される変数にアクセスすることはできません &lt;code&gt;let-alist&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f4512de22f11934fdb81d9289bb39ac4b395feae" translate="yes" xml:space="preserve">
          <source>Network Connections</source>
          <target state="translated">ネットワーク接続</target>
        </trans-unit>
        <trans-unit id="1a2ceca984e39b172fda21e503d83194676acb77" translate="yes" xml:space="preserve">
          <source>Network Options</source>
          <target state="translated">ネットワークオプション</target>
        </trans-unit>
        <trans-unit id="92a0a91f7ea484b5d2e0caa0572673102ce764e4" translate="yes" xml:space="preserve">
          <source>Network Servers</source>
          <target state="translated">ネットワークサーバー</target>
        </trans-unit>
        <trans-unit id="5e5da2cd3c810a62709e4258b89df7da017dd9e1" translate="yes" xml:space="preserve">
          <source>Network access</source>
          <target state="translated">ネットワークアクセス</target>
        </trans-unit>
        <trans-unit id="4db16d13f459789c5e4f3a0b0eb58ac0b72836a4" translate="yes" xml:space="preserve">
          <source>Network connections and servers are created by calling &lt;code&gt;make-network-process&lt;/code&gt; with an argument list consisting of keyword/argument pairs, for example &lt;code&gt;:server t&lt;/code&gt; to create a server process, or &lt;code&gt;:type 'datagram&lt;/code&gt; to create a datagram connection. See &lt;a href=&quot;low_002dlevel-network#Low_002dLevel-Network&quot;&gt;Low-Level Network&lt;/a&gt;, for details. You can also use the &lt;code&gt;open-network-stream&lt;/code&gt; function described below.</source>
          <target state="translated">ネットワーク接続とサーバーは、キーワードと引数のペアで構成される引数リストを使用して &lt;code&gt;make-network-process&lt;/code&gt; を呼び出すことで作成されます。たとえば、 &lt;code&gt;:server t&lt;/code&gt; を使用してサーバープロセスを作成したり、 &lt;code&gt;:type 'datagram&lt;/code&gt; を使用してデータグラム接続を作成したりします。詳細については、&lt;a href=&quot;low_002dlevel-network#Low_002dLevel-Network&quot;&gt;低レベルネットワーク&lt;/a&gt;を参照してください。以下に説明する &lt;code&gt;open-network-stream&lt;/code&gt; 関数を使用することもできます。</target>
        </trans-unit>
        <trans-unit id="03c2b7b3aa6dd8790276a40fdff32df5fbd4ba6e" translate="yes" xml:space="preserve">
          <source>Network servers let Emacs accept net connections.</source>
          <target state="translated">ネットワークサーバはEmacsがネット接続を受け付けるようにしています。</target>
        </trans-unit>
        <trans-unit id="f7f37df5443218422ad6ebd50122d98556ecefca" translate="yes" xml:space="preserve">
          <source>Never add an autoload &lt;em&gt;comment&lt;/em&gt; to silence a compiler warning in another file. In the file that produces the warning, use &lt;code&gt;(defvar foo)&lt;/code&gt; to silence an undefined variable warning, and &lt;code&gt;declare-function&lt;/code&gt; (see &lt;a href=&quot;declaring-functions#Declaring-Functions&quot;&gt;Declaring Functions&lt;/a&gt;) to silence an undefined function warning; or require the relevant library; or use an explicit autoload &lt;em&gt;statement&lt;/em&gt;.</source>
          <target state="translated">コンパイラの警告を別のファイルで消音するために、自動ロード&lt;em&gt;コメント&lt;/em&gt;を追加しないでください。警告を生成するファイルで、 &lt;code&gt;(defvar foo)&lt;/code&gt; を使用して未定義の変数の警告を消音し、 &lt;code&gt;declare-function&lt;/code&gt; （関数の&lt;a href=&quot;declaring-functions#Declaring-Functions&quot;&gt;宣言を&lt;/a&gt;参照）を使用して未定義の関数の警告を消音します。または関連するライブラリが必要です。または、明示的なautoload&lt;em&gt;ステートメントを&lt;/em&gt;使用します。</target>
        </trans-unit>
        <trans-unit id="9c2964759b06a2623b93cf7c65f17e2ef21aa268" translate="yes" xml:space="preserve">
          <source>Next in precedence are keymaps specified by enabled minor modes. These keymaps, if any, are specified by the variables &lt;code&gt;emulation-mode-map-alists&lt;/code&gt;, &lt;code&gt;minor-mode-overriding-map-alist&lt;/code&gt;, and &lt;code&gt;minor-mode-map-alist&lt;/code&gt;. See &lt;a href=&quot;controlling-active-maps#Controlling-Active-Maps&quot;&gt;Controlling Active Maps&lt;/a&gt;.</source>
          <target state="translated">次に優先されるのは、有効なマイナーモードで指定されたキーマップです。これらのキーマップは、存在する場合、変数 &lt;code&gt;emulation-mode-map-alists&lt;/code&gt; 、 &lt;code&gt;minor-mode-overriding-map-alist&lt;/code&gt; overriding -map-alist、および &lt;code&gt;minor-mode-map-alist&lt;/code&gt; によって指定されます。&lt;a href=&quot;controlling-active-maps#Controlling-Active-Maps&quot;&gt;アクティブマップの制御を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="cf11fa80110f5add1f6e8df89357b576825e8423" translate="yes" xml:space="preserve">
          <source>Next in precedence is the buffer&amp;rsquo;s &lt;em&gt;local keymap&lt;/em&gt;, containing key bindings specific to the buffer. The minibuffer also has a local keymap (see &lt;a href=&quot;intro-to-minibuffers#Intro-to-Minibuffers&quot;&gt;Intro to Minibuffers&lt;/a&gt;). If there is a &lt;code&gt;local-map&lt;/code&gt; text or overlay property at point, that specifies the local keymap to use, in place of the buffer&amp;rsquo;s default local keymap.</source>
          <target state="translated">次に優先されるのは、バッファに固有のキーバインディングを含むバッファの&lt;em&gt;ローカルキーマップ&lt;/em&gt;です。ミニバッファにはローカルキーマップもあります（ミニバッファの&lt;a href=&quot;intro-to-minibuffers#Intro-to-Minibuffers&quot;&gt;概要を&lt;/a&gt;参照）。ポイントに &lt;code&gt;local-map&lt;/code&gt; テキストまたはオーバーレイプロパティがある場合、バッファのデフォルトのローカルキーマップの代わりに、使用するローカルキーマップを指定します。</target>
        </trans-unit>
        <trans-unit id="ea6e9f5900f2c58fe85d30179802bd1c82319521" translate="yes" xml:space="preserve">
          <source>Next to every menu bar item, Emacs displays a key binding that runs the same command (if such a key binding exists). This serves as a convenient hint for users who do not know the key binding. If a command has multiple bindings, Emacs normally displays the first one it finds. You can specify one particular key binding by assigning an &lt;code&gt;:advertised-binding&lt;/code&gt; symbol property to the command. See &lt;a href=&quot;keys-in-documentation#Keys-in-Documentation&quot;&gt;Keys in Documentation&lt;/a&gt;.</source>
          <target state="translated">すべてのメニューバー項目の横に、Emacsは同じコマンドを実行するキーバインディングを表示します（そのようなキーバインディングが存在する場合）。これは、キーバインディングを知らないユーザーにとって便利なヒントとして役立ちます。コマンドに複数のバインディングがある場合、Emacsは通常最初に見つけたものを表示します。コマンドに &lt;code&gt;:advertised-binding&lt;/code&gt; symbolプロパティを割り当てることにより、1つの特定のキーバインディングを指定できます。&lt;a href=&quot;keys-in-documentation#Keys-in-Documentation&quot;&gt;ドキュメントのキーを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="27f58e46bfcfa765f0350cd6b6821ef674d81fef" translate="yes" xml:space="preserve">
          <source>Next we define the menu items:</source>
          <target state="translated">次にメニュー項目を定義します。</target>
        </trans-unit>
        <trans-unit id="71ae8da1cccbc9f22418d39bfa80cb8b8749d267" translate="yes" xml:space="preserve">
          <source>Next, Emacs adds any extra load directories that you specify using the</source>
          <target state="translated">次に、Emacs は</target>
        </trans-unit>
        <trans-unit id="d62380513230c1ed3241e1f5ee2099ae36407b91" translate="yes" xml:space="preserve">
          <source>Next, we call &lt;code&gt;(split-window W3 nil 'left)&lt;/code&gt;, passing the internal window &lt;var&gt;W3&lt;/var&gt; as the argument. The result:</source>
          <target state="translated">次に、 &lt;code&gt;(split-window W3 nil 'left)&lt;/code&gt; を呼び出し、内部ウィンドウ &lt;var&gt;W3&lt;/var&gt; を引数として渡します。結果：</target>
        </trans-unit>
        <trans-unit id="b961cdbb90d8271bcd99e03aa14df9f662fda815" translate="yes" xml:space="preserve">
          <source>Next, write an initialization function for the module.</source>
          <target state="translated">次に、モジュールの初期化関数を書きます。</target>
        </trans-unit>
        <trans-unit id="e71dbb9278b56b980f41278b5bdbd5ad829743eb" translate="yes" xml:space="preserve">
          <source>Next: stop at the next stop point encountered after an expression (&lt;code&gt;edebug-next-mode&lt;/code&gt;). Also see &lt;code&gt;edebug-forward-sexp&lt;/code&gt; in &lt;a href=&quot;jumping#Jumping&quot;&gt;Jumping&lt;/a&gt;.</source>
          <target state="translated">次へ：式の後に検出された次の停止ポイントで停止します（ &lt;code&gt;edebug-next-mode&lt;/code&gt; ）。参照してください &lt;code&gt;edebug-forward-sexp&lt;/code&gt; で&lt;a href=&quot;jumping#Jumping&quot;&gt;ジャンプを&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1e86fd1a5ff5402fe649662053b5f46f96ea16c3" translate="yes" xml:space="preserve">
          <source>No argument is matched but backtracking through the gate is disabled while matching the remainder of the specifications at this level. This is primarily used to generate more specific syntax error messages. See &lt;a href=&quot;backtracking#Backtracking&quot;&gt;Backtracking&lt;/a&gt;, for more details. Also see the &lt;code&gt;let&lt;/code&gt; example.</source>
          <target state="translated">引数は一致しませんが、このレベルの残りの仕様と一致している間、ゲートを介したバックトラックは無効になります。これは主に、より具体的な構文エラーメッセージを生成するために使用されます。詳細については、&lt;a href=&quot;backtracking#Backtracking&quot;&gt;バックトラッキングを&lt;/a&gt;参照してください。 &lt;code&gt;let&lt;/code&gt; の例も参照してください。</target>
        </trans-unit>
        <trans-unit id="5cadafbd2e7190a2f1d2b8eedb1454e2868f07a2" translate="yes" xml:space="preserve">
          <source>No catch for tag</source>
          <target state="translated">タグのキャッチはありません。</target>
        </trans-unit>
        <trans-unit id="bbeb07f8bf2d7e3c732cf8947945435e8e59adfe" translate="yes" xml:space="preserve">
          <source>No obarray contains all symbols; in fact, some symbols are not in any obarray. They are called &lt;em&gt;uninterned symbols&lt;/em&gt;. An uninterned symbol has the same four cells as other symbols; however, the only way to gain access to it is by finding it in some other object or as the value of a variable.</source>
          <target state="translated">すべてのシンボルを含むobarrayはありません。実際、一部のシンボルはどのオブアレイにも含まれていません。それらは非&lt;em&gt;インターンシンボル&lt;/em&gt;と呼ばれ&lt;em&gt;ます&lt;/em&gt;。インターンされていないシンボルには、他のシンボルと同じ4つのセルがあります。ただし、それにアクセスする唯一の方法は、他のオブジェクトで、または変数の値としてそれを見つけることです。</target>
        </trans-unit>
        <trans-unit id="8838111d4610c90296b30fc380a23778ca2a7a0e" translate="yes" xml:space="preserve">
          <source>No text is inserted.</source>
          <target state="translated">テキストは挿入されていません。</target>
        </trans-unit>
        <trans-unit id="de830dc532a97e327dc9112b349772dda4316853" translate="yes" xml:space="preserve">
          <source>Non-</source>
          <target state="translated">Non-</target>
        </trans-unit>
        <trans-unit id="dd3e47873c08c1cbf08bc18047d3d358e469fc94" translate="yes" xml:space="preserve">
          <source>Non-&lt;code&gt;nil&lt;/code&gt; if IPv6 is supported.</source>
          <target state="translated">非 &lt;code&gt;nil&lt;/code&gt; のIPv6の場合は、サポートされています。</target>
        </trans-unit>
        <trans-unit id="c137cc4db2df7f4be1c8cd466be3bbfbab527f39" translate="yes" xml:space="preserve">
          <source>Non-&lt;code&gt;nil&lt;/code&gt; if datagrams are supported.</source>
          <target state="translated">非 &lt;code&gt;nil&lt;/code&gt; のデータグラムがサポートされている場合。</target>
        </trans-unit>
        <trans-unit id="85ba9cd318b20fd143c7eef7c3f80b8dac2a20df" translate="yes" xml:space="preserve">
          <source>Non-&lt;code&gt;nil&lt;/code&gt; if inside a string. More precisely, this is the character that will terminate the string, or &lt;code&gt;t&lt;/code&gt; if a generic string delimiter character should terminate it.</source>
          <target state="translated">非 &lt;code&gt;nil&lt;/code&gt; の文字列内の場合。より正確には、これは文字列を終了する文字です。一般的な文字列区切り文字で終了する必要がある場合は &lt;code&gt;t&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="9c329207815f864cfe40c306c4b2308f01044b65" translate="yes" xml:space="preserve">
          <source>Non-&lt;code&gt;nil&lt;/code&gt; if local (a.k.a. &amp;ldquo;UNIX domain&amp;rdquo;) sockets are supported.</source>
          <target state="translated">非 &lt;code&gt;nil&lt;/code&gt; のローカル（別名「UNIXドメイン」）のソケットがサポートされている場合。</target>
        </trans-unit>
        <trans-unit id="5b4d81358027d2cd5d76892ec114515c0d94000f" translate="yes" xml:space="preserve">
          <source>Non-&lt;code&gt;nil&lt;/code&gt; if non-blocking connect is supported.</source>
          <target state="translated">非ブロッキング接続がサポートされている場合は非 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6a0195fbc2801af663ba0ec5723eebf901180bde" translate="yes" xml:space="preserve">
          <source>Non-&lt;code&gt;nil&lt;/code&gt; if the system can select the port for a server.</source>
          <target state="translated">非 &lt;code&gt;nil&lt;/code&gt; のシステムは、サーバーのポートを選択することができます。</target>
        </trans-unit>
        <trans-unit id="298a4e63bde074768d01508f47e1e3a7d52b639a" translate="yes" xml:space="preserve">
          <source>Non-&lt;code&gt;nil&lt;/code&gt; if this window is dedicated to its buffer.</source>
          <target state="translated">非 &lt;code&gt;nil&lt;/code&gt; のこのウィンドウは、そのバッファに捧げられています。</target>
        </trans-unit>
        <trans-unit id="2d45527490c53e7bb3fcf4095792dbed717b907d" translate="yes" xml:space="preserve">
          <source>Non-&lt;code&gt;nil&lt;/code&gt; means current value of &lt;code&gt;start&lt;/code&gt; was the beginning of a line when it was chosen.</source>
          <target state="translated">non- &lt;code&gt;nil&lt;/code&gt; は、 &lt;code&gt;start&lt;/code&gt; の現在の値が選択されたときの行の始まりであることを意味します。</target>
        </trans-unit>
        <trans-unit id="97e7e8cff888f916fc069faab013939aece0c530" translate="yes" xml:space="preserve">
          <source>Non-&lt;code&gt;nil&lt;/code&gt; means that regular expression matching for the sake of &lt;code&gt;font-lock-keywords&lt;/code&gt; should be case-insensitive.</source>
          <target state="translated">non- &lt;code&gt;nil&lt;/code&gt; は、 &lt;code&gt;font-lock-keywords&lt;/code&gt; のための正規表現マッチングで大文字と小文字を区別しないことを意味します。</target>
        </trans-unit>
        <trans-unit id="17f14e42cfe6c0c5fa4278037593c1cf2a9f7e46" translate="yes" xml:space="preserve">
          <source>Non-&lt;code&gt;nil&lt;/code&gt;&lt;var&gt;region-noncontiguous-p&lt;/var&gt; means that the region between &lt;var&gt;start&lt;/var&gt; and &lt;var&gt;end&lt;/var&gt; is composed of noncontiguous pieces. The most common example of this is a rectangular region, where the pieces are separated by newline characters.</source>
          <target state="translated">non &lt;var&gt;region-noncontiguous-p&lt;/var&gt; &lt;code&gt;nil&lt;/code&gt; region-noncontiguous-pは、 &lt;var&gt;start&lt;/var&gt; と &lt;var&gt;end&lt;/var&gt; 間の領域が非連続部分で構成されていることを意味します。この最も一般的な例は、部分が改行文字で区切られている長方形の領域です。</target>
        </trans-unit>
        <trans-unit id="5d29f2d794a4e41245bc116e7d56afd0854763f8" translate="yes" xml:space="preserve">
          <source>Non-ASCII Characters</source>
          <target state="translated">非ASCII文字</target>
        </trans-unit>
        <trans-unit id="9a1964e6f1fd92781e6b1f5855e1a8b90a085deb" translate="yes" xml:space="preserve">
          <source>Non-ASCII Characters in Strings</source>
          <target state="translated">文字列中の非ASCII文字</target>
        </trans-unit>
        <trans-unit id="ee03ca40fe0fddf419289b00e54d3e235f27f181" translate="yes" xml:space="preserve">
          <source>Non-ASCII text in buffers and strings.</source>
          <target state="translated">バッファや文字列内の非ASCIIテキスト。</target>
        </trans-unit>
        <trans-unit id="6371bd35cb6aae61f199a61590cfd0399446eef8" translate="yes" xml:space="preserve">
          <source>Non-ASCII text written to the standard output or error descriptors is by default encoded using &lt;code&gt;locale-coding-system&lt;/code&gt; (see &lt;a href=&quot;locales#Locales&quot;&gt;Locales&lt;/a&gt;) if it is non-&lt;code&gt;nil&lt;/code&gt;; this can be overridden by binding &lt;code&gt;coding-system-for-write&lt;/code&gt; to a coding system of you choice (see &lt;a href=&quot;explicit-encoding#Explicit-Encoding&quot;&gt;Explicit Encoding&lt;/a&gt;).</source>
          <target state="translated">標準出力またはエラー記述子に書き込まれる非ASCIIテキストは、 &lt;code&gt;nil&lt;/code&gt; 以外の場合、デフォルトで &lt;code&gt;locale-coding-system&lt;/code&gt; （&lt;a href=&quot;locales#Locales&quot;&gt;ロケールを&lt;/a&gt;参照）を使用してエンコードされます。これは、 &lt;code&gt;coding-system-for-write&lt;/code&gt; を選択したコーディングシステムにバインドすることでオーバーライドできます（&lt;a href=&quot;explicit-encoding#Explicit-Encoding&quot;&gt;明示的なエンコーディングを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="8f9dde119327e925337a2b9bade0b26729d73142" translate="yes" xml:space="preserve">
          <source>Non-constant variables whose value can &lt;em&gt;not&lt;/em&gt; be an arbitrary Lisp object.</source>
          <target state="translated">値を任意のLispオブジェクトにすることができ&lt;em&gt;ない&lt;/em&gt;非定数変数。</target>
        </trans-unit>
        <trans-unit id="ba5ac4c4b4eca5c161d4957f66dd2e8e98dbac8b" translate="yes" xml:space="preserve">
          <source>Non-printing control flag. When it is used, other specifiers must be given in the order of decreasing size, i.e., years before days, hours before minutes, etc. Nothing will be produced in the result string to the left of &amp;lsquo;</source>
          <target state="translated">非印刷制御フラグ。使用する場合、他の指定子はサイズの小さい順に指定する必要があります。つまり、数年前、数時間前などです。 'の左側の結果文字列には何も生成されません。</target>
        </trans-unit>
        <trans-unit id="0978c4a08e7aa3c2e4530a665830e83fac749d6d" translate="yes" xml:space="preserve">
          <source>Non-zero if communication with the subprocess uses a pty; zero if it uses a pipe.</source>
          <target state="translated">サブプロセスとの通信でptyを使用する場合は0以外、パイプを使用する場合は0。</target>
        </trans-unit>
        <trans-unit id="5f22d5c13ab24217b6cce33d3adbd30e573e6278" translate="yes" xml:space="preserve">
          <source>Non-zero if this window is a &lt;em&gt;pseudo window&lt;/em&gt;. A pseudo window is either a window used to display the menu bar or the tool bar (when Emacs uses toolkits that don&amp;rsquo;t display their own menu bar and tool bar) or the tab bar or a window showing a tooltip on a tooltip frame. Pseudo windows are in general not accessible from Lisp code.</source>
          <target state="translated">このウィンドウが&lt;em&gt;疑似ウィンドウの&lt;/em&gt;場合はゼロ以外。疑似ウィンドウは、メニューバーまたはツールバーを表示するために使用されるウィンドウ（Emacsが独自のメニューバーとツールバーを表示しないツールキットを使用する場合）、またはタブバーまたはツールチップフレームにツールチップを表示するウィンドウです。疑似ウィンドウは一般にLispコードからアクセスできません。</target>
        </trans-unit>
        <trans-unit id="54314d871cb31d9ea8c00c7bd36602724ec562af" translate="yes" xml:space="preserve">
          <source>Non-zero if this window is a minibuffer window, a window showing the minibuffer or the echo area.</source>
          <target state="translated">このウィンドウがミニバッファウィンドウ、ミニバッファまたはエコー領域を表示するウィンドウである場合は、0 以外の値を指定します。</target>
        </trans-unit>
        <trans-unit id="0ba1c3d1e346952de45a35d971ea7bad1bf252e0" translate="yes" xml:space="preserve">
          <source>Non-zero means the cursor in this window is logically off. This is used for blinking the cursor.</source>
          <target state="translated">0以外の値は、このウィンドウのカーソルが論理的にオフになっていることを意味します。これはカーソルを点滅させるために使用されます。</target>
        </trans-unit>
        <trans-unit id="16075a3db57978fdbecdd0a45ee972e34d651059" translate="yes" xml:space="preserve">
          <source>Non-zero means this window&amp;rsquo;s mode line needs to be updated.</source>
          <target state="translated">ゼロ以外は、このウィンドウのモード行を更新する必要があることを意味します。</target>
        </trans-unit>
        <trans-unit id="71fab370af08ad66d6e2717a8c670408d7a79d19" translate="yes" xml:space="preserve">
          <source>None of the above functions suppress quitting.</source>
          <target state="translated">上記のいずれの機能も辞めることを抑制するものではありません。</target>
        </trans-unit>
        <trans-unit id="9bfc03cabd4be3ad4520d8a6d451463b5aa1986e" translate="yes" xml:space="preserve">
          <source>None of the arguments is instrumented.</source>
          <target state="translated">引数はいずれもインストルメントされていません。</target>
        </trans-unit>
        <trans-unit id="2df251e672be89a4e3f1f02e5d89d7600b0e8d4d" translate="yes" xml:space="preserve">
          <source>None of these three functions will make a frame smaller than needed to display all of its windows together with their scroll bars, fringes, margins, dividers, mode and header lines. This contrasts with requests by the window manager triggered, for example, by dragging the external border of a frame with the mouse. Such requests are always honored by clipping, if necessary, portions that cannot be displayed at the right, bottom corner of the frame. The parameters &lt;code&gt;min-width&lt;/code&gt; and &lt;code&gt;min-height&lt;/code&gt; (see &lt;a href=&quot;size-parameters#Size-Parameters&quot;&gt;Size Parameters&lt;/a&gt;) can be used to obtain a similar behavior when changing the frame size from within Emacs.</source>
          <target state="translated">これらの3つの関数はいずれも、スクロールバー、フリンジ、マージン、仕切り、モード、およびヘッダー行とともにすべてのウィンドウを表示するために必要なフレームよりも小さくすることはありません。これは、たとえば、フレームの外側の境界線をマウスでドラッグすることによってトリガーされるウィンドウマネージャーによる要求とは対照的です。このような要求は、必要に応じて、フレームの右下隅に表示できない部分をクリッピングすることによって常に受け入れられます。パラメータ &lt;code&gt;min-width&lt;/code&gt; と &lt;code&gt;min-height&lt;/code&gt; （&lt;a href=&quot;size-parameters#Size-Parameters&quot;&gt;サイズパラメータを&lt;/a&gt;参照）を使用して、Emacs内からフレームサイズを変更するときに同様の動作を取得できます。</target>
        </trans-unit>
        <trans-unit id="a13391618a7eb550b931b1ca7f5e7dea3f609549" translate="yes" xml:space="preserve">
          <source>Nonlocal Exits</source>
          <target state="translated">非ローカル出口</target>
        </trans-unit>
        <trans-unit id="04cfa77523068f9d99f2dadfb2d56696bd61d7b4" translate="yes" xml:space="preserve">
          <source>Nonlocal Exits in Modules</source>
          <target state="translated">モジュールの非局所的な出口</target>
        </trans-unit>
        <trans-unit id="989a5aecc184b93ecbd769ecbad5acdea9c400aa" translate="yes" xml:space="preserve">
          <source>Nonlocal exits for the program&amp;rsquo;s own purposes.</source>
          <target state="translated">プログラム自体の目的のための非ローカル出口。</target>
        </trans-unit>
        <trans-unit id="9fd8001fd6d82a32c9adc0fec8386196b8416cea" translate="yes" xml:space="preserve">
          <source>Nonprinting Characters in Strings</source>
          <target state="translated">文字列の非印刷文字</target>
        </trans-unit>
        <trans-unit id="f8770b24b50ea318a926e10ce75d22b10fca1574" translate="yes" xml:space="preserve">
          <source>Normally all the elements are markers or &lt;code&gt;nil&lt;/code&gt;, but if &lt;var&gt;integers&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, that means to use integers instead of markers. (In that case, the buffer itself is appended as an additional element at the end of the list, to facilitate complete restoration of the match data.) If the last match was done on a string with &lt;code&gt;string-match&lt;/code&gt;, then integers are always used, since markers can&amp;rsquo;t point into a string.</source>
          <target state="translated">通常、すべての要素はマーカーまたは &lt;code&gt;nil&lt;/code&gt; ですが、 &lt;var&gt;integers&lt;/var&gt; が &lt;code&gt;nil&lt;/code&gt; 以外の場合は、マーカーの代わりに整数を使用することを意味します。（その場合、一致データの完全な復元を容易にするために、バッファー自体がリストの最後に追加要素として追加されます。）最後の一致が &lt;code&gt;string-match&lt;/code&gt; の文字列で行われた場合、整数が常に使用されます。 、マーカーは文字列を指すことができないため。</target>
        </trans-unit>
        <trans-unit id="192d978732b9939fab239d8824137b1ba2ec3243" translate="yes" xml:space="preserve">
          <source>Normally any upper case event is converted to lower case if the original event is undefined and the lower case equivalent is defined. The argument &lt;var&gt;dont-downcase-last&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, means do not convert the last event to lower case. This is appropriate for reading a key sequence to be defined.</source>
          <target state="translated">通常、元のイベントが定義されておらず、同等の小文字が定義されている場合、大文字のイベントはすべて小文字に変換されます。引数 &lt;var&gt;dont-downcase-last&lt;/var&gt; は、 &lt;code&gt;nil&lt;/code&gt; 以外の場合、最後のイベントを小文字に変換しないことを意味します。これは、定義するキーシーケンスを読み取るのに適しています。</target>
        </trans-unit>
        <trans-unit id="dad78cd65a27cbbd2fd73355d58cb98bdd207435" translate="yes" xml:space="preserve">
          <source>Normally completion operates on the whole string, so for all normal collections, this will always return &lt;code&gt;(0 . (length
&lt;var&gt;suffix&lt;/var&gt;))&lt;/code&gt;. But more complex completion such as completion on files is done one field at a time. For example, completion of &lt;code&gt;&quot;/usr/sh&quot;&lt;/code&gt; will include &lt;code&gt;&quot;/usr/share/&quot;&lt;/code&gt; but not &lt;code&gt;&quot;/usr/share/doc&quot;&lt;/code&gt; even if &lt;code&gt;&quot;/usr/share/doc&quot;&lt;/code&gt; exists. Also &lt;code&gt;all-completions&lt;/code&gt; on &lt;code&gt;&quot;/usr/sh&quot;&lt;/code&gt; will not include &lt;code&gt;&quot;/usr/share/&quot;&lt;/code&gt; but only &lt;code&gt;&quot;share/&quot;&lt;/code&gt;. So if &lt;var&gt;string&lt;/var&gt; is &lt;code&gt;&quot;/usr/sh&quot;&lt;/code&gt; and &lt;var&gt;suffix&lt;/var&gt; is &lt;code&gt;&quot;e/doc&quot;&lt;/code&gt;, &lt;code&gt;completion-boundaries&lt;/code&gt; will return &lt;code&gt;(5 . 1)&lt;/code&gt; which tells us that the &lt;var&gt;collection&lt;/var&gt; will only return completion information that pertains to the area after &lt;code&gt;&quot;/usr/&quot;&lt;/code&gt; and before &lt;code&gt;&quot;/doc&quot;&lt;/code&gt;.</source>
          <target state="translated">通常、完了は文字列全体で機能するため、すべての通常のコレクションでは、これは常に &lt;code&gt;(0 . (length &lt;var&gt;suffix&lt;/var&gt;))&lt;/code&gt; 返します。ただし、ファイルの完了などのより複雑な完了は、一度に1つのフィールドで実行されます。例えば、完了 &lt;code&gt;&quot;/usr/sh&quot;&lt;/code&gt; 含まれる &lt;code&gt;&quot;/usr/share/&quot;&lt;/code&gt; ではなく &lt;code&gt;&quot;/usr/share/doc&quot;&lt;/code&gt; ても &lt;code&gt;&quot;/usr/share/doc&quot;&lt;/code&gt; 存在します。また、 &lt;code&gt;all-completions&lt;/code&gt; の &lt;code&gt;&quot;/usr/sh&quot;&lt;/code&gt; は含まれません &lt;code&gt;&quot;/usr/share/&quot;&lt;/code&gt; だけ &lt;code&gt;&quot;share/&quot;&lt;/code&gt; 。したがって、 &lt;var&gt;string&lt;/var&gt; が &lt;code&gt;&quot;/usr/sh&quot;&lt;/code&gt; そして、 &lt;var&gt;suffix&lt;/var&gt; ある &lt;code&gt;&quot;e/doc&quot;&lt;/code&gt; 、 &lt;code&gt;completion-boundaries&lt;/code&gt; は &lt;code&gt;(5 . 1)&lt;/code&gt; を返します。これは、 &lt;var&gt;collection&lt;/var&gt; が &lt;code&gt;&quot;/usr/&quot;&lt;/code&gt; 後および &lt;code&gt;&quot;/doc&quot;&lt;/code&gt; 前の領域に関連する完了情報のみを返すことを示しています。</target>
        </trans-unit>
        <trans-unit id="eef86229b8453b39f2aa268e50526cd24df0ce4f" translate="yes" xml:space="preserve">
          <source>Normally the frame parameter &lt;code&gt;vertical-scroll-bars&lt;/code&gt; controls whether the windows in the frame have vertical scroll bars, and whether they are on the left or right. The frame parameter &lt;code&gt;scroll-bar-width&lt;/code&gt; specifies how wide they are (&lt;code&gt;nil&lt;/code&gt; meaning the default).</source>
          <target state="translated">通常、フレームパラメータ &lt;code&gt;vertical-scroll-bars&lt;/code&gt; は、フレーム内のウィンドウに垂直スクロールバーがあるかどうか、およびそれらが左側にあるか右側にあるかを制御します。フレームパラメータ &lt;code&gt;scroll-bar-width&lt;/code&gt; は、それらの幅を指定します（ &lt;code&gt;nil&lt;/code&gt; はデフォルトを意味します）。</target>
        </trans-unit>
        <trans-unit id="b67289438b7d78753fd70ed6a9106b4a91cda89b" translate="yes" xml:space="preserve">
          <source>Normally the menu bar shows global items followed by items defined by the local maps.</source>
          <target state="translated">通常、メニューバーにはグローバル項目の後にローカルマップで定義された項目が表示されます。</target>
        </trans-unit>
        <trans-unit id="b4ce40396bab6737ba31fe0b078bdd852088010f" translate="yes" xml:space="preserve">
          <source>Normally the strings in this menu are determined automatically from the choices; however, you can specify different strings for the menu by including the &lt;code&gt;:tag&lt;/code&gt; keyword in the alternatives. For example, if an integer stands for a number of spaces, while a string is text to use verbatim, you might write the customization type this way,</source>
          <target state="translated">通常、このメニューの文字列は選択肢から自動的に決定されます。ただし、選択肢に &lt;code&gt;:tag&lt;/code&gt; キーワードを含めることで、メニューに異なる文字列を指定できます。たとえば、整数がスペースの数を表し、文字列が逐語的に使用するテキストである場合、カスタマイズタイプを次のように記述できます。</target>
        </trans-unit>
        <trans-unit id="62b64002f4f8b319511bb978309afeb856e1036e" translate="yes" xml:space="preserve">
          <source>Normally this function returns a list of coding systems that could handle decoding the text that was scanned. They are listed in order of decreasing priority. But if &lt;var&gt;highest&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, then the return value is just one coding system, the one that is highest in priority.</source>
          <target state="translated">通常、この関数は、スキャンされたテキストのデコードを処理できるコーディングシステムのリストを返します。それらは優先度の高い順にリストされています。ただし、 &lt;var&gt;highest&lt;/var&gt; が &lt;code&gt;nil&lt;/code&gt; 以外の場合、戻り値は1つのコーディングシステムであり、優先度が最も高いものです。</target>
        </trans-unit>
        <trans-unit id="ab4019dfe8ddc7d2f4af3e844b877df3f30a8685" translate="yes" xml:space="preserve">
          <source>Normally you add events to the front of this list, so that the events most recently unread will be reread first.</source>
          <target state="translated">通常はこのリストの先頭にイベントを追加するので、直近の未読イベントが先に再読されます。</target>
        </trans-unit>
        <trans-unit id="9b2e214efb7720744217eac6eff20d8f98ffd008" translate="yes" xml:space="preserve">
          <source>Normally you do not need to set the stipple attribute, because it is used automatically to handle certain shades of gray.</source>
          <target state="translated">通常はstipple属性を設定する必要はありませんが、これは特定のグレーの濃淡を処理するために自動的に使用されるからです。</target>
        </trans-unit>
        <trans-unit id="c998bbdbb3cbe3ac5764a0951dbc909e2665a30b" translate="yes" xml:space="preserve">
          <source>Normally you don&amp;rsquo;t specify the name explicitly, and Emacs computes the frame name automatically based on a template stored in the variable &lt;code&gt;frame-title-format&lt;/code&gt;. Emacs recomputes the name each time the frame is redisplayed.</source>
          <target state="translated">通常、名前を明示的に指定することはなく、Emacsは変数 &lt;code&gt;frame-title-format&lt;/code&gt; に格納されているテンプレートに基づいてフレーム名を自動的に計算します。Emacsは、フレームが再表示されるたびに名前を再計算します。</target>
        </trans-unit>
        <trans-unit id="802f45620f0b9ed768e00202f167ac521857caf7" translate="yes" xml:space="preserve">
          <source>Normally you should not change the value of this variable.</source>
          <target state="translated">通常はこの変数の値を変更してはいけません。</target>
        </trans-unit>
        <trans-unit id="7a23d4c059b6f9f25f5adc759fee5b9b134865c2" translate="yes" xml:space="preserve">
          <source>Normally, &lt;code&gt;add-to-history&lt;/code&gt; removes duplicate members from the history list if &lt;code&gt;history-delete-duplicates&lt;/code&gt; is non-&lt;code&gt;nil&lt;/code&gt;. However, if &lt;var&gt;keep-all&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, that says not to remove duplicates, and to add &lt;var&gt;newelt&lt;/var&gt; to the list even if it is empty.</source>
          <target state="translated">通常、 &lt;code&gt;add-to-history&lt;/code&gt; は、 &lt;code&gt;history-delete-duplicates&lt;/code&gt; が &lt;code&gt;nil&lt;/code&gt; 以外の場合、履歴リストから重複メンバーを削除します。ただし、 &lt;var&gt;keep-all&lt;/var&gt; が &lt;code&gt;nil&lt;/code&gt; 以外の場合は、重複を削除せず、空であってもリストに &lt;var&gt;newelt&lt;/var&gt; を追加することを意味します。</target>
        </trans-unit>
        <trans-unit id="84a125fd6e14f51bb1790a0c3b9796a123e66347" translate="yes" xml:space="preserve">
          <source>Normally, &lt;code&gt;define-abbrev&lt;/code&gt; sets the variable &lt;code&gt;abbrevs-changed&lt;/code&gt; to &lt;code&gt;t&lt;/code&gt;, if it actually changes the abbrev. This is so that some commands will offer to save the abbrevs. It does not do this for a system abbrev, since those aren&amp;rsquo;t saved anyway.</source>
          <target state="translated">通常、 &lt;code&gt;define-abbrev&lt;/code&gt; は、実際に &lt;code&gt;abbrevs-changed&lt;/code&gt; する場合、変数abbrevs-changedを &lt;code&gt;t&lt;/code&gt; に設定します。これは、一部のコマンドが略語を保存することを提案するためです。とにかく保存されないため、システムの略語に対してはこれを行いません。</target>
        </trans-unit>
        <trans-unit id="970594f1826445de648390764f7d9d23076e7277" translate="yes" xml:space="preserve">
          <source>Normally, &lt;code&gt;emacs_value&lt;/code&gt; objects have a rather short lifetime: it ends when the &lt;code&gt;emacs_env&lt;/code&gt; pointer used for their creation goes out of scope. Occasionally, you may need to create &lt;em&gt;global references&lt;/em&gt;: &lt;code&gt;emacs_value&lt;/code&gt; objects that live as long as you wish. Use the following two functions to manage such objects.</source>
          <target state="translated">通常、 &lt;code&gt;emacs_value&lt;/code&gt; オブジェクトの有効期間はかなり短く、作成に使用された &lt;code&gt;emacs_env&lt;/code&gt; ポインターがスコープ外になると終了します。場合によっては、&lt;em&gt;グローバル参照&lt;/em&gt;を作成する必要があり&lt;em&gt;ます&lt;/em&gt;：必要&lt;em&gt;な&lt;/em&gt; &lt;code&gt;emacs_value&lt;/code&gt; するemacs_valueオブジェクト。このようなオブジェクトを管理するには、次の2つの関数を使用します。</target>
        </trans-unit>
        <trans-unit id="39b787a71e5fbae9edb48d71ec234482e20b431b" translate="yes" xml:space="preserve">
          <source>Normally, &lt;code&gt;map-y-or-n-p&lt;/code&gt; binds &lt;code&gt;cursor-in-echo-area&lt;/code&gt; while prompting. But if &lt;var&gt;no-cursor-in-echo-area&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, it does not do that.</source>
          <target state="translated">通常、 &lt;code&gt;map-y-or-n-p&lt;/code&gt; は、プロンプト中に &lt;code&gt;cursor-in-echo-area&lt;/code&gt; をバインドします。ただし、 &lt;var&gt;no-cursor-in-echo-area&lt;/var&gt; が &lt;code&gt;nil&lt;/code&gt; でない場合は、それは行われません。</target>
        </trans-unit>
        <trans-unit id="b1b62f370a1c1a6e7086ac926443ce71d3d50fde" translate="yes" xml:space="preserve">
          <source>Normally, &lt;code&gt;md5&lt;/code&gt; signals an error if the text can&amp;rsquo;t be encoded using the specified or chosen coding system. However, if &lt;var&gt;noerror&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, it silently uses &lt;code&gt;raw-text&lt;/code&gt; coding instead.</source>
          <target state="translated">通常、指定または選択したコーディングシステムを使用してテキストをエンコードできない場合、 &lt;code&gt;md5&lt;/code&gt; はエラーを通知します。ただし、 &lt;var&gt;noerror&lt;/var&gt; が &lt;code&gt;nil&lt;/code&gt; 以外の場合は、代わりに &lt;code&gt;raw-text&lt;/code&gt; コーディングをサイレントに使用します。</target>
        </trans-unit>
        <trans-unit id="4c4fc931c5f12a4d2220d2a0743fc463a725a420" translate="yes" xml:space="preserve">
          <source>Normally, &lt;code&gt;revert-buffer&lt;/code&gt; asks for confirmation before it changes the buffer; but if the argument &lt;var&gt;noconfirm&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, &lt;code&gt;revert-buffer&lt;/code&gt; does not ask for confirmation.</source>
          <target state="translated">通常、 &lt;code&gt;revert-buffer&lt;/code&gt; は、バッファーを変更する前に確認を求めます。ただし、引数 &lt;var&gt;noconfirm&lt;/var&gt; が &lt;code&gt;nil&lt;/code&gt; 以外の場合、 &lt;code&gt;revert-buffer&lt;/code&gt; は確認を要求しません。</target>
        </trans-unit>
        <trans-unit id="c7a8f6a1665078c7e303220251e8e70e9878aff0" translate="yes" xml:space="preserve">
          <source>Normally, &lt;code&gt;transpose-regions&lt;/code&gt; relocates markers with the transposed text; a marker previously positioned within one of the two transposed portions moves along with that portion, thus remaining between the same two characters in their new position. However, if &lt;var&gt;leave-markers&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, &lt;code&gt;transpose-regions&lt;/code&gt; does not do this&amp;mdash;it leaves all markers unrelocated.</source>
          <target state="translated">通常、 &lt;code&gt;transpose-regions&lt;/code&gt; は、転置されたテキストとともにマーカーを再配置します。2つの転置部分の1つ内に以前に配置されたマーカーは、その部分とともに移動するため、同じ2つの文字の間に新しい位置に留まります。ただし、 &lt;var&gt;leave-markers&lt;/var&gt; が &lt;code&gt;nil&lt;/code&gt; 以外の場合、 &lt;code&gt;transpose-regions&lt;/code&gt; はこれを行いません。つまり、すべてのマーカーが再配置されないままになります。</target>
        </trans-unit>
        <trans-unit id="c224a495efc6cae4ffaacc3200216d71860a3648" translate="yes" xml:space="preserve">
          <source>Normally, &lt;code&gt;write-region&lt;/code&gt; displays the message &amp;lsquo;</source>
          <target state="translated">通常、 &lt;code&gt;write-region&lt;/code&gt; はメッセージを表示します '</target>
        </trans-unit>
        <trans-unit id="a463efccfae5102145810b771db2db6ac9df4444" translate="yes" xml:space="preserve">
          <source>Normally, &lt;var&gt;keymap&lt;/var&gt; is used just once, to look up the very next key. If the optional argument &lt;var&gt;keep-pred&lt;/var&gt; is &lt;code&gt;t&lt;/code&gt;, the map stays active as long as the user types keys defined in &lt;var&gt;keymap&lt;/var&gt;; when the user types a key that is not in &lt;var&gt;keymap&lt;/var&gt;, the transient keymap is deactivated and normal key lookup continues for that key.</source>
          <target state="translated">通常、 &lt;var&gt;keymap&lt;/var&gt; は、次のキーを検索するために1回だけ使用されます。オプションの引数 &lt;var&gt;keep-pred&lt;/var&gt; が &lt;code&gt;t&lt;/code&gt; の場合、ユーザーが &lt;var&gt;keymap&lt;/var&gt; で定義されたキーを入力している限り、マップはアクティブなままです。ユーザーが &lt;var&gt;keymap&lt;/var&gt; にないキーを入力すると、一時キーマップが非アクティブ化され、そのキーの通常のキー検索が続行されます。</target>
        </trans-unit>
        <trans-unit id="f65ffe59e12caca0f23c215b2caa4e497fa21c12" translate="yes" xml:space="preserve">
          <source>Normally, Emacs uses the face specs of each face to automatically calculate its attributes on each frame (see &lt;a href=&quot;defining-faces#Defining-Faces&quot;&gt;Defining Faces&lt;/a&gt;). The function &lt;code&gt;set-face-attribute&lt;/code&gt; can override this calculation by directly assigning attributes to a face, either on a specific frame or for all frames. This function is mostly intended for internal usage.</source>
          <target state="translated">通常、Emacsは各面の面仕様を使用して、各フレームの属性を自動的に計算します（&lt;a href=&quot;defining-faces#Defining-Faces&quot;&gt;面の定義を&lt;/a&gt;参照）。関数 &lt;code&gt;set-face-attribute&lt;/code&gt; は、特定のフレームまたはすべてのフレームのいずれかで、属性を面に直接割り当てることにより、この計算をオーバーライドできます。この関数は主に内部使用を目的としています。</target>
        </trans-unit>
        <trans-unit id="56d71e2eece71984f9cf83046339cf5cde803b82" translate="yes" xml:space="preserve">
          <source>Normally, a face is declared just once, using &lt;code&gt;defface&lt;/code&gt;, and any further changes to its appearance are applied using the Customize framework (e.g., via the Customize user interface or via the &lt;code&gt;custom-set-faces&lt;/code&gt; function; see &lt;a href=&quot;applying-customizations#Applying-Customizations&quot;&gt;Applying Customizations&lt;/a&gt;), or by face remapping (see &lt;a href=&quot;face-remapping#Face-Remapping&quot;&gt;Face Remapping&lt;/a&gt;). In the rare event that you need to change a face spec directly from Lisp, you can use the &lt;code&gt;face-spec-set&lt;/code&gt; function.</source>
          <target state="translated">通常、顔は &lt;code&gt;defface&lt;/code&gt; を使用して一度だけ宣言され、その外観へのそれ以上の変更は、Customizeフレームワークを使用して（たとえば、Customizeユーザーインターフェイスまたは &lt;code&gt;custom-set-faces&lt;/code&gt; 関数を介して。&lt;a href=&quot;applying-customizations#Applying-Customizations&quot;&gt;カスタマイズの適用を&lt;/a&gt;参照）、またはによって適用されます。顔の再マッピング（参照&lt;a href=&quot;face-remapping#Face-Remapping&quot;&gt;フェイス再マッピングを&lt;/a&gt;）。まれに、Lispから直接顔のスペックを変更する必要がある場合は、 &lt;code&gt;face-spec-set&lt;/code&gt; 関数を使用できます。</target>
        </trans-unit>
        <trans-unit id="ef564d0438f8b582059c4f06fa6f5901a7eb5fe3" translate="yes" xml:space="preserve">
          <source>Normally, a newline is automatically inserted after the header, the footer and every node&amp;rsquo;s textual description. If &lt;var&gt;nosep&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, no newline is inserted. This may be useful for displaying an entire ewoc on a single line, for example, or for making nodes invisible by arranging for &lt;var&gt;pretty-printer&lt;/var&gt; to do nothing for those nodes.</source>
          <target state="translated">通常、改行は、ヘッダー、フッター、およびすべてのノードのテキストによる説明の後に自動的に挿入されます。 &lt;var&gt;nosep&lt;/var&gt; が &lt;code&gt;nil&lt;/code&gt; 以外の場合、改行は挿入されません。これは、たとえば、ewoc全体を1行に表示する場合や、 &lt;var&gt;pretty-printer&lt;/var&gt; がそれらのノードに対して何もしないように調整することによってノードを非表示にする場合に役立ちます。</target>
        </trans-unit>
        <trans-unit id="78ecfe635d86fae4e7dabe6c5a40c28ac6789c76" translate="yes" xml:space="preserve">
          <source>Normally, a red highlight indicates the form was never completely evaluated; a brown highlight means it always evaluated to the same value (meaning there has been little testing of what is done with the result). However, the red highlight is skipped for forms that can&amp;rsquo;t possibly complete their evaluation, such as &lt;code&gt;error&lt;/code&gt;. The brown highlight is skipped for forms that are expected to always evaluate to the same value, such as &lt;code&gt;(setq x 14)&lt;/code&gt;.</source>
          <target state="translated">通常、赤いハイライトは、フォームが完全に評価されていないことを示します。茶色のハイライトは、常に同じ値に評価されることを意味します（結果で何が行われるかについてのテストがほとんど行われていないことを意味します）。ただし、 &lt;code&gt;error&lt;/code&gt; など、評価を完了できない可能性のあるフォームでは、赤いハイライトはスキップされます。 &lt;code&gt;(setq x 14)&lt;/code&gt; のように、常に同じ値に評価されると予想されるフォームでは、茶色のハイライトはスキップされます。</target>
        </trans-unit>
        <trans-unit id="b7854440eb6b90acf05dcac089bc58cb02d3786d" translate="yes" xml:space="preserve">
          <source>Normally, commands specify which representation to use for the prefix argument, either numeric or raw, in the &lt;code&gt;interactive&lt;/code&gt; specification. (See &lt;a href=&quot;using-interactive#Using-Interactive&quot;&gt;Using Interactive&lt;/a&gt;.) Alternatively, functions may look at the value of the prefix argument directly in the variable &lt;code&gt;current-prefix-arg&lt;/code&gt;, but this is less clean.</source>
          <target state="translated">通常、コマンドは、 &lt;code&gt;interactive&lt;/code&gt; 仕様でプレフィックス引数に使用する表現（数値またはraw）を指定します。（&lt;a href=&quot;using-interactive#Using-Interactive&quot;&gt;インタラクティブの使用を&lt;/a&gt;参照してください。）あるいは、関数は変数 &lt;code&gt;current-prefix-arg&lt;/code&gt; でプレフィックス引数の値を直接調べることもできますが、これはあまりクリーンではありません。</target>
        </trans-unit>
        <trans-unit id="0922fd40705d46e517e311d0b4534c4d4aea3a25" translate="yes" xml:space="preserve">
          <source>Normally, deleting a large amount of text from a buffer inhibits further auto-saving of that buffer because it has shrunk. However, &lt;code&gt;erase-buffer&lt;/code&gt; does not do this, the idea being that the future text is not really related to the former text, and its size should not be compared with that of the former text.</source>
          <target state="translated">通常、バッファから大量のテキストを削除すると、バッファが縮小したため、そのバッファをさらに自動保存できなくなります。ただし、 &lt;code&gt;erase-buffer&lt;/code&gt; はこれを行いません。将来のテキストは実際には前のテキストとは関係がなく、そのサイズを前のテキストのサイズと比較するべきではないという考えです。</target>
        </trans-unit>
        <trans-unit id="2b35691422f5a8a262ba1ccbae353a8209b947f0" translate="yes" xml:space="preserve">
          <source>Normally, displaying a long message resizes the echo area to display the entire message. But if the variable &lt;code&gt;message-truncate-lines&lt;/code&gt; is non-&lt;code&gt;nil&lt;/code&gt;, the echo area does not resize, and the message is truncated to fit it.</source>
          <target state="translated">通常、長いメッセージを表示すると、エコー領域のサイズが変更されてメッセージ全体が表示されます。ただし、変数 &lt;code&gt;message-truncate-lines&lt;/code&gt; が &lt;code&gt;nil&lt;/code&gt; 以外の場合、エコー領域のサイズは変更されず、メッセージはそれに合わせて切り捨てられます。</target>
        </trans-unit>
        <trans-unit id="f23d4ac50b4b0692f85e2c612a9dbf51f5ee0c69" translate="yes" xml:space="preserve">
          <source>Normally, each entry in a &lt;code&gt;list&lt;/code&gt; or &lt;code&gt;vector&lt;/code&gt; type specification describes a single element type. But when an entry contains &lt;code&gt;:inline t&lt;/code&gt;, the value it matches is merged directly into the containing sequence. For example, if the entry matches a list with three elements, those become three elements of the overall sequence. This is analogous to &amp;lsquo;</source>
          <target state="translated">通常、 &lt;code&gt;list&lt;/code&gt; または &lt;code&gt;vector&lt;/code&gt; タイプ仕様の各エントリは、単一の要素タイプを記述します。ただし、エントリに &lt;code&gt;:inline t&lt;/code&gt; が含まれている場合、一致する値は含まれているシーケンスに直接マージされます。たとえば、エントリが3つの要素を持つリストと一致する場合、それらはシーケンス全体の3つの要素になります。これは 'に類似しています</target>
        </trans-unit>
        <trans-unit id="467a0b75a915def14074129749af0e39f8c66a1c" translate="yes" xml:space="preserve">
          <source>Normally, each frame has its own minibuffer window at the bottom, which is used whenever that frame is selected. You can get that window with the function &lt;code&gt;minibuffer-window&lt;/code&gt; (see &lt;a href=&quot;minibuffer-windows#Minibuffer-Windows&quot;&gt;Minibuffer Windows&lt;/a&gt;).</source>
          <target state="translated">通常、各フレームの下部には独自のミニバッファウィンドウがあり、そのフレームが選択されるたびに使用されます。このウィンドウは、関数 &lt;code&gt;minibuffer-window&lt;/code&gt; windowを使用して取得できます（&lt;a href=&quot;minibuffer-windows#Minibuffer-Windows&quot;&gt;Minibuffer Windowsを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="f47235bc295fc9ef73d437c414c49bbdf12a693c" translate="yes" xml:space="preserve">
          <source>Normally, elements of &lt;code&gt;font-lock-keywords&lt;/code&gt; should not match across multiple lines; that doesn&amp;rsquo;t work reliably, because Font Lock usually scans just part of the buffer, and it can miss a multi-line construct that crosses the line boundary where the scan starts. (The scan normally starts at the beginning of a line.)</source>
          <target state="translated">通常、 &lt;code&gt;font-lock-keywords&lt;/code&gt; の要素は複数行で一致するべきではありません。Font Lockは通常、バッファの一部のみをスキャンし、スキャンが開始される行の境界を越える複数行の構成を見逃す可能性があるため、これは確実に機能しません。（通常、スキャンは行の先頭から開始されます。）</target>
        </trans-unit>
        <trans-unit id="d12bd9c60258b05b553df099e61b1e0db5cc0eb0" translate="yes" xml:space="preserve">
          <source>Normally, errors caught by &lt;code&gt;condition-case&lt;/code&gt; never invoke the debugger. The &lt;code&gt;condition-case&lt;/code&gt; gets a chance to handle the error before the debugger gets a chance.</source>
          <target state="translated">通常、 &lt;code&gt;condition-case&lt;/code&gt; によってキャッチされたエラーは、デバッガーを呼び出すことはありません。 &lt;code&gt;condition-case&lt;/code&gt; デバッガがチャンスを得る前に、エラーを処理する機会を得ます。</target>
        </trans-unit>
        <trans-unit id="54a2bd94783a47980369965cd627bee242490611" translate="yes" xml:space="preserve">
          <source>Normally, if &lt;var&gt;character&lt;/var&gt; is an</source>
          <target state="translated">通常、 &lt;var&gt;character&lt;/var&gt; が</target>
        </trans-unit>
        <trans-unit id="d50713f555db79e954a816742203790399e0673d" translate="yes" xml:space="preserve">
          <source>Normally, if &lt;var&gt;element&lt;/var&gt; is added, it is added to the front of &lt;var&gt;symbol&lt;/var&gt;, but if the optional argument &lt;var&gt;append&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, it is added at the end.</source>
          <target state="translated">通常、 &lt;var&gt;element&lt;/var&gt; が追加されると、 &lt;var&gt;symbol&lt;/var&gt; の前に追加され &lt;var&gt;append&lt;/var&gt; が、オプションの引数appendが &lt;code&gt;nil&lt;/code&gt; 以外の場合は、最後に追加されます。</target>
        </trans-unit>
        <trans-unit id="d6187789e5ea59be13e6c842c07c9deb29b1d4bb" translate="yes" xml:space="preserve">
          <source>Normally, it is not necessary to manipulate fonts directly. In case you need to do so, this section explains how.</source>
          <target state="translated">通常、フォントを直接操作する必要はありません。必要な場合に備えて、ここではその方法を説明します。</target>
        </trans-unit>
        <trans-unit id="becd1bd4e621ec277e1f58244c23bb4b5b4c4b17" translate="yes" xml:space="preserve">
          <source>Normally, it modifies a category set by adding &lt;var&gt;category&lt;/var&gt; to it. But if &lt;var&gt;reset&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, then it deletes &lt;var&gt;category&lt;/var&gt; instead.</source>
          <target state="translated">通常、カテゴリセットに &lt;var&gt;category&lt;/var&gt; を追加して変更します。ただし、 &lt;var&gt;reset&lt;/var&gt; が &lt;code&gt;nil&lt;/code&gt; 以外の場合は、代わりに &lt;var&gt;category&lt;/var&gt; が削除されます。</target>
        </trans-unit>
        <trans-unit id="33a09b1e73b35c5e6e469be538e26ad9f62399d8" translate="yes" xml:space="preserve">
          <source>Normally, prefer &lt;code&gt;intptr_t&lt;/code&gt; for internal representations of pointers, or for integers bounded only by the number of objects that can exist at any given time or by the total number of bytes that can be allocated. However, prefer &lt;code&gt;uintptr_t&lt;/code&gt; to represent pointer arithmetic that could cross page boundaries. For example, on a machine with a 32-bit address space an array could cross the 0x7fffffff/0x80000000 boundary, which would cause an integer overflow when adding 1 to &lt;code&gt;(intptr_t) 0x7fffffff&lt;/code&gt;.</source>
          <target state="translated">通常、ポインタの内部表現、または任意の時点で存在できるオブジェクトの数または割り当て可能なバイトの総数によってのみ制限される整数には、 &lt;code&gt;intptr_t&lt;/code&gt; を優先します。ただし、ページの境界を越える可能性のあるポインタ演算を表すには、 &lt;code&gt;uintptr_t&lt;/code&gt; を使用することをお勧めします。たとえば、32ビットのアドレス空間を持つマシンでは、配列が0x7fffffff / 0x80000000の境界を越える可能性があり、 &lt;code&gt;(intptr_t) 0x7fffffff&lt;/code&gt; 1を加算すると整数オーバーフローが発生します。</target>
        </trans-unit>
        <trans-unit id="1e6c689be8312b59b07bf40709097a3c5731537c" translate="yes" xml:space="preserve">
          <source>Normally, repetition forms are greedy, in that they attempt to match as many times as possible. Some forms are non-greedy; they try to match as few times as possible (see &lt;a href=&quot;regexp-special#Non_002dgreedy-repetition&quot;&gt;Non-greedy repetition&lt;/a&gt;).</source>
          <target state="translated">通常、繰り返し形式は、可能な限り何度も一致させようとするという点で貪欲です。一部の形式は貪欲ではありません。それらは可能な限り一致しようとしません（&lt;a href=&quot;regexp-special#Non_002dgreedy-repetition&quot;&gt;貪欲でない繰り返しを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="8afe6491950d0be63d8da54adfd8c5f2338d800f" translate="yes" xml:space="preserve">
          <source>Normally, the</source>
          <target state="translated">通常であれば</target>
        </trans-unit>
        <trans-unit id="30802bf54b72f5663b6407f90667f9e51d089434" translate="yes" xml:space="preserve">
          <source>Normally, the argument expressions are not evaluated as part of computing the macro expansion, but instead appear as part of the expansion, so they are computed when the expansion is evaluated.</source>
          <target state="translated">通常、引数式はマクロ展開の計算の一部として評価されるのではなく、展開の一部として現れるので、展開が評価されたときに計算されます。</target>
        </trans-unit>
        <trans-unit id="629b571150fb4d121b8cb2e6cf7f1cf6cc68f709" translate="yes" xml:space="preserve">
          <source>Normally, the buffer displayed in the selected window is the current buffer, but this is not always so: a Lisp program can temporarily designate any buffer as current in order to operate on its contents, without changing what is displayed on the screen. The most basic function for designating a current buffer is &lt;code&gt;set-buffer&lt;/code&gt;.</source>
          <target state="translated">通常、選択したウィンドウに表示されるバッファは現在のバッファですが、常にそうであるとは限りません。Lispプログラムは、画面に表示される内容を変更せずに、その内容を操作するために一時的に任意のバッファを現在のバッファとして指定できます。現在のバッファを指定するための最も基本的な関数は &lt;code&gt;set-buffer&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="1ef79e40f4fe75ea19a532d8a9828e867c6dc545" translate="yes" xml:space="preserve">
          <source>Normally, the cursor is displayed at the beginning or the end of any overlay and text property strings present at the current buffer position. You can place the cursor on any desired character of these strings by giving that character a non-&lt;code&gt;nil&lt;/code&gt;&lt;code&gt;cursor&lt;/code&gt; text property. In addition, if the value of the &lt;code&gt;cursor&lt;/code&gt; property is an integer, it specifies the number of buffer&amp;rsquo;s character positions, starting with the position where the overlay or the &lt;code&gt;display&lt;/code&gt; property begins, for which the cursor should be displayed on that character. Specifically, if the value of the &lt;code&gt;cursor&lt;/code&gt; property of a character is the number &lt;var&gt;n&lt;/var&gt;, the cursor will be displayed on this character for any buffer position in the range &lt;code&gt;[&lt;var&gt;ovpos&lt;/var&gt;..&lt;var&gt;ovpos&lt;/var&gt;+&lt;var&gt;n&lt;/var&gt;)&lt;/code&gt;, where &lt;var&gt;ovpos&lt;/var&gt; is the overlay&amp;rsquo;s starting position given by &lt;code&gt;overlay-start&lt;/code&gt; (see &lt;a href=&quot;managing-overlays#Managing-Overlays&quot;&gt;Managing Overlays&lt;/a&gt;), or the position where the &lt;code&gt;display&lt;/code&gt; text property begins in the buffer.</source>
          <target state="translated">通常、カーソルは、現在のバッファ位置に存在するオーバーレイおよびテキストプロパティ文字列の最初または最後に表示されます。これらの文字列の任意の文字に非 &lt;code&gt;nil&lt;/code&gt; &lt;code&gt;cursor&lt;/code&gt; テキストプロパティを指定することにより、カーソルをこれらの文字列の任意の文字に置くことができます。さらに、 &lt;code&gt;cursor&lt;/code&gt; プロパティの値が整数の場合、オーバーレイまたは &lt;code&gt;display&lt;/code&gt; プロパティが開始する位置から開始して、その文字にカーソルを表示するバッファの文字位置の数を指定します。具体的には、文字の &lt;code&gt;cursor&lt;/code&gt; プロパティの値が数値 &lt;var&gt;n&lt;/var&gt; の場合、 &lt;code&gt;[&lt;var&gt;ovpos&lt;/var&gt;..&lt;var&gt;ovpos&lt;/var&gt;+&lt;var&gt;n&lt;/var&gt;)&lt;/code&gt; 範囲内の任意のバッファ位置でこの文字にカーソルが表示されます。 &lt;var&gt;ovpos&lt;/var&gt; .. &lt;var&gt;ovpos&lt;/var&gt; + &lt;var&gt;n&lt;/var&gt; ）、ここで &lt;var&gt;ovpos&lt;/var&gt; は、overlay &lt;code&gt;overlay-start&lt;/code&gt; （&lt;a href=&quot;managing-overlays#Managing-Overlays&quot;&gt;オーバーレイの管理を&lt;/a&gt;参照）によって指定されたオーバーレイの開始位置、または &lt;code&gt;display&lt;/code&gt; テキストプロパティがバッファー内で開始する位置です。</target>
        </trans-unit>
        <trans-unit id="6e260092c506bb0904c31069887686f085d03db5" translate="yes" xml:space="preserve">
          <source>Normally, the keymap &lt;code&gt;query-replace-map&lt;/code&gt; defines the possible user responses for queries. The argument &lt;var&gt;map&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, specifies a keymap to use instead of &lt;code&gt;query-replace-map&lt;/code&gt;.</source>
          <target state="translated">通常、keymap &lt;code&gt;query-replace-map&lt;/code&gt; は、クエリに対して可能なユーザー応答を定義します。引数 &lt;var&gt;map&lt;/var&gt; は、 &lt;code&gt;nil&lt;/code&gt; 以外の場合、 &lt;code&gt;query-replace-map&lt;/code&gt; の代わりに使用するキーマップを指定します。</target>
        </trans-unit>
        <trans-unit id="c9bc529dca0e2a9cf79b4d035ef919efc70874fc" translate="yes" xml:space="preserve">
          <source>Normally, the specified buffer is put at the front of the buffer list&amp;mdash;both the global buffer list and the selected frame&amp;rsquo;s buffer list (see &lt;a href=&quot;buffer-list#Buffer-List&quot;&gt;Buffer List&lt;/a&gt;). However, this is not done if the optional argument &lt;var&gt;norecord&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">通常は、指定されたバッファは、（参照バッファリストの両方グローバルバッファリストと、選択したフレームのバッファリストの先頭に置かれる&lt;a href=&quot;buffer-list#Buffer-List&quot;&gt;バッファリスト&lt;/a&gt;）。ただし、オプションの引数 &lt;var&gt;norecord&lt;/var&gt; が &lt;code&gt;nil&lt;/code&gt; 以外の場合、これは実行されません。</target>
        </trans-unit>
        <trans-unit id="7936ac8e02ea68233dc9ba1fd5cca740f87f5020" translate="yes" xml:space="preserve">
          <source>Normally, the variables &lt;code&gt;window-min-height&lt;/code&gt; and &lt;code&gt;window-min-width&lt;/code&gt; specify the smallest allowable window size (see &lt;a href=&quot;window-sizes#Window-Sizes&quot;&gt;Window Sizes&lt;/a&gt;). However, if the optional argument &lt;var&gt;ignore&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, this function ignores &lt;code&gt;window-min-height&lt;/code&gt; and &lt;code&gt;window-min-width&lt;/code&gt;, as well as &lt;code&gt;window-size-fixed&lt;/code&gt;. Instead, it considers the minimum-height window to be one consisting of a header and a mode line, a horizontal scrollbar and a bottom divider (if any), plus a text area one line tall; and a minimum-width window as one consisting of fringes, margins, a scroll bar and a right divider (if any), plus a text area two columns wide.</source>
          <target state="translated">通常、変数 &lt;code&gt;window-min-height&lt;/code&gt; および &lt;code&gt;window-min-width&lt;/code&gt; は、許容される最小のウィンドウサイズを指定します（&lt;a href=&quot;window-sizes#Window-Sizes&quot;&gt;ウィンドウサイズを&lt;/a&gt;参照）。ただし、オプションの引数 &lt;var&gt;ignore&lt;/var&gt; が &lt;code&gt;nil&lt;/code&gt; 以外の場合、この関数は &lt;code&gt;window-min-height&lt;/code&gt; と &lt;code&gt;window-min-width&lt;/code&gt; 、および &lt;code&gt;window-size-fixed&lt;/code&gt; を無視します。代わりに、最小の高さのウィンドウは、ヘッダーとモードライン、水平スクロールバーと下部の仕切り（存在する場合）、および1行の高さのテキスト領域で構成されるウィンドウと見なされます。フリンジ、マージン、スクロールバー、右仕切り（存在する場合）、および2列幅のテキスト領域で構成される最小幅のウィンドウ。</target>
        </trans-unit>
        <trans-unit id="c5713371bb37a8cdef55c3106ef4460970d0eab6" translate="yes" xml:space="preserve">
          <source>Normally, this command puts point before the inserted text, and the mark after it. However, if the optional second argument &lt;var&gt;beforep&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, it puts the mark before and point after.</source>
          <target state="translated">通常、このコマンドは挿入されたテキストの前にポイントを置き、その後にマークを置きます。ただし、オプションの2番目の引数 &lt;var&gt;beforep&lt;/var&gt; が &lt;code&gt;nil&lt;/code&gt; 以外の場合は、前にマークを付け、後にポイントを付けます。</target>
        </trans-unit>
        <trans-unit id="3d42087a0d42cd57b27861aa1a1b4a750c8b489d" translate="yes" xml:space="preserve">
          <source>Normally, this command reinitializes the buffer&amp;rsquo;s major and minor modes using &lt;code&gt;normal-mode&lt;/code&gt;. But if &lt;var&gt;preserve-modes&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, the modes remain unchanged.</source>
          <target state="translated">通常、このコマンドは、 &lt;code&gt;normal-mode&lt;/code&gt; を使用してバッファのメジャーモードとマイナーモードを再初期化します。ただし、 &lt;var&gt;preserve-modes&lt;/var&gt; が &lt;code&gt;nil&lt;/code&gt; 以外の場合、モードは変更されません。</target>
        </trans-unit>
        <trans-unit id="aa1a4bffdaf1e62a462694623e95b20201dc51ec" translate="yes" xml:space="preserve">
          <source>Normally, this function asks the user for confirmation if there already is a buffer visiting &lt;var&gt;filename&lt;/var&gt;. If &lt;var&gt;no-query&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, that prevents asking this question. If there already is a buffer visiting &lt;var&gt;filename&lt;/var&gt;, and the user confirms or &lt;var&gt;no-query&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, this function makes the new buffer name unique by appending a number inside of &amp;lsquo;</source>
          <target state="translated">通常、この関数は、 &lt;var&gt;filename&lt;/var&gt; アクセスするバッファがすでに存在するかどうかをユーザーに確認するように求めます。場合は &lt;var&gt;no-query&lt;/var&gt; 非ではありません &lt;code&gt;nil&lt;/code&gt; で、その防止には、この質問を。 &lt;var&gt;filename&lt;/var&gt; にアクセスするバッファがすでに存在し、ユーザーが確認するか &lt;var&gt;no-query&lt;/var&gt; が &lt;code&gt;nil&lt;/code&gt; 以外の場合、この関数は '内に数字を追加することで新しいバッファ名を一意にします</target>
        </trans-unit>
        <trans-unit id="64fcbebdb92f9124f1312a1ae2441a038070f262" translate="yes" xml:space="preserve">
          <source>Normally, this function inserts newline characters into the encoded text, to avoid overlong lines. However, if the optional argument &lt;var&gt;no-line-break&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, these newlines are not added, so the output is just one long line.</source>
          <target state="translated">通常、この関数は、長すぎる行を避けるために、エンコードされたテキストに改行文字を挿入します。ただし、オプションの引数 &lt;var&gt;no-line-break&lt;/var&gt; が &lt;code&gt;nil&lt;/code&gt; 以外の場合、これらの改行は追加されないため、出力は1つの長い行になります。</target>
        </trans-unit>
        <trans-unit id="f43ac9933802532b28a287e5f45c7854bcc33b0b" translate="yes" xml:space="preserve">
          <source>Normally, this function inserts newline characters into the encoded text, to avoid overlong lines. However, if the optional argument &lt;var&gt;no-line-break&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, these newlines are not added, so the result string is just one long line.</source>
          <target state="translated">通常、この関数は、長すぎる行を避けるために、エンコードされたテキストに改行文字を挿入します。ただし、オプションの引数 &lt;var&gt;no-line-break&lt;/var&gt; が &lt;code&gt;nil&lt;/code&gt; 以外の場合、これらの改行は追加されないため、結果の文字列は1つの長い行になります。</target>
        </trans-unit>
        <trans-unit id="d37dcdec76f9e6b7d0121007f21ec47b7057c83e" translate="yes" xml:space="preserve">
          <source>Normally, this function signals an error if you attempt to delete the sole active terminal, but if &lt;var&gt;force&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, you are allowed to do so. Emacs automatically calls this function when the last frame on a terminal is deleted (see &lt;a href=&quot;deleting-frames#Deleting-Frames&quot;&gt;Deleting Frames&lt;/a&gt;).</source>
          <target state="translated">通常、この関数は、唯一のアクティブな端末を削除しようとするとエラーを通知しますが、 &lt;var&gt;force&lt;/var&gt; が &lt;code&gt;nil&lt;/code&gt; 以外の場合は、削除できます。Emacsは、端末の最後のフレームが削除されると、この関数を自動的に呼び出します（&lt;a href=&quot;deleting-frames#Deleting-Frames&quot;&gt;フレームの削除を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="6dd336d19d532b36fa2861068df8621fa7546f25" translate="yes" xml:space="preserve">
          <source>Normally, well-designed Lisp programs should not use &lt;code&gt;with-eval-after-load&lt;/code&gt;. If you need to examine and set the variables defined in another library (those meant for outside use), you can do it immediately&amp;mdash;there is no need to wait until the library is loaded. If you need to call functions defined by that library, you should load the library, preferably with &lt;code&gt;require&lt;/code&gt; (see &lt;a href=&quot;named-features#Named-Features&quot;&gt;Named Features&lt;/a&gt;).</source>
          <target state="translated">通常、適切に設計されたLispプログラムは &lt;code&gt;with-eval-after-load&lt;/code&gt; を使用すべきではありません。別のライブラリで定義されている変数（外部で使用するためのもの）を調べて設定する必要がある場合は、すぐに実行できます。ライブラリがロードされるまで待つ必要はありません。そのライブラリによって定義された関数を呼び出す必要がある場合は、できれば &lt;code&gt;require&lt;/code&gt; を使用してライブラリをロードする必要があります（&lt;a href=&quot;named-features#Named-Features&quot;&gt;名前付き機能を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="32213d153ad203f84c268998070d9c91fd7446c2" translate="yes" xml:space="preserve">
          <source>Normally, when &lt;var&gt;tree&lt;/var&gt; is anything other than a cons cell, &lt;code&gt;copy-tree&lt;/code&gt; simply returns &lt;var&gt;tree&lt;/var&gt;. However, if &lt;var&gt;vecp&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, it copies vectors too (and operates recursively on their elements).</source>
          <target state="translated">Normally, when &lt;var&gt;tree&lt;/var&gt; is anything other than a cons cell, &lt;code&gt;copy-tree&lt;/code&gt; simply returns &lt;var&gt;tree&lt;/var&gt; . However, if &lt;var&gt;vecp&lt;/var&gt; is non- &lt;code&gt;nil&lt;/code&gt; , it copies vectors too (and operates recursively on their elements).</target>
        </trans-unit>
        <trans-unit id="a3c03c3e2f02de6a73dd67dd8665632ac3ecb4d6" translate="yes" xml:space="preserve">
          <source>Normally, you specify the Edebug execution mode by typing a command to continue the program in a certain mode. Here is a table of these commands; all except for</source>
          <target state="translated">通常は、コマンドを入力してEdebugの実行モードを指定し、特定のモードでプログラムを続行します。以下にこれらのコマンドの表を示します。</target>
        </trans-unit>
        <trans-unit id="28a2d6a083bc6ad019b2a98e4e29d81c91548221" translate="yes" xml:space="preserve">
          <source>Not all convenient formats are strings. If &lt;var&gt;time&lt;/var&gt; is a number (integer or floating point), that specifies a relative time measured in seconds. The result of &lt;code&gt;encode-time&lt;/code&gt; can also be used to specify an absolute value for &lt;var&gt;time&lt;/var&gt;.</source>
          <target state="translated">Not all convenient formats are strings. If &lt;var&gt;time&lt;/var&gt; is a number (integer or floating point), that specifies a relative time measured in seconds. The result of &lt;code&gt;encode-time&lt;/code&gt; can also be used to specify an absolute value for &lt;var&gt;time&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="cb74d9cca41ce9c386501e0756ab5861fff45519" translate="yes" xml:space="preserve">
          <source>Not all grammars are accepted:</source>
          <target state="translated">全ての文法が通用するわけではありません。</target>
        </trans-unit>
        <trans-unit id="99f0e2cc9f83cb30e3ae050f9b9f847c4120fdb6" translate="yes" xml:space="preserve">
          <source>Not every string is a valid regular expression. For example, a string that ends inside a character alternative without a terminating &amp;lsquo;</source>
          <target state="translated">Not every string is a valid regular expression. For example, a string that ends inside a character alternative without a terminating &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="43ff9e862a86dab0a657fc6384f26e1419f49f75" translate="yes" xml:space="preserve">
          <source>Not used by core Emacs features.</source>
          <target state="translated">Emacs のコア機能では使用されません。</target>
        </trans-unit>
        <trans-unit id="c7c5413b8718cba59a931876fd41b752eae55f77" translate="yes" xml:space="preserve">
          <source>Notation for describing functions, variables, etc.</source>
          <target state="translated">関数や変数などを記述する際の表記法</target>
        </trans-unit>
        <trans-unit id="4c3b785fe5302404be7fd8ebefe6a435a4164b8b" translate="yes" xml:space="preserve">
          <source>Note also that &lt;code&gt;expand-file-name&lt;/code&gt; does not follow symbolic links at any level. This results in a difference between the way &lt;code&gt;file-truename&lt;/code&gt; and &lt;code&gt;expand-file-name&lt;/code&gt; treat &amp;lsquo;</source>
          <target state="translated">Note also that &lt;code&gt;expand-file-name&lt;/code&gt; does not follow symbolic links at any level. This results in a difference between the way &lt;code&gt;file-truename&lt;/code&gt; and &lt;code&gt;expand-file-name&lt;/code&gt; treat &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="e8c1e3068af42529c71ce3761f404a8c7cb2b54f" translate="yes" xml:space="preserve">
          <source>Note also that the native position of a frame usually remains unaltered on its display when removing or adding the window manager decorations by changing the frame&amp;rsquo;s &lt;code&gt;override-redirect&lt;/code&gt; or &lt;code&gt;undecorated&lt;/code&gt; parameter (see &lt;a href=&quot;management-parameters#Management-Parameters&quot;&gt;Management Parameters&lt;/a&gt;).</source>
          <target state="translated">Note also that the native position of a frame usually remains unaltered on its display when removing or adding the window manager decorations by changing the frame&amp;rsquo;s &lt;code&gt;override-redirect&lt;/code&gt; or &lt;code&gt;undecorated&lt;/code&gt; parameter (see &lt;a href=&quot;management-parameters#Management-Parameters&quot;&gt;Management Parameters&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="e06a1498bcc4e46f5b08f1b485bfe2d29db14c40" translate="yes" xml:space="preserve">
          <source>Note also that this translation is done before the characters are supplied to input methods (see &lt;a href=&quot;input-methods#Input-Methods&quot;&gt;Input Methods&lt;/a&gt;). Use &lt;code&gt;translation-table-for-input&lt;/code&gt; (see &lt;a href=&quot;translation-of-characters#Translation-of-Characters&quot;&gt;Translation of Characters&lt;/a&gt;), if you want to translate characters after input methods operate.</source>
          <target state="translated">Note also that this translation is done before the characters are supplied to input methods (see &lt;a href=&quot;input-methods#Input-Methods&quot;&gt;Input Methods&lt;/a&gt;). Use &lt;code&gt;translation-table-for-input&lt;/code&gt; (see &lt;a href=&quot;translation-of-characters#Translation-of-Characters&quot;&gt;Translation of Characters&lt;/a&gt;), if you want to translate characters after input methods operate.</target>
        </trans-unit>
        <trans-unit id="f37c9faec19e5f322f365ce34f1cd5f26d62fd9b" translate="yes" xml:space="preserve">
          <source>Note also that under certain circumstances &lt;code&gt;switch-to-prev-buffer&lt;/code&gt; and &lt;code&gt;switch-to-next-buffer&lt;/code&gt; may ignore this option, for example, when there is only one buffer left these functions can switch to.</source>
          <target state="translated">Note also that under certain circumstances &lt;code&gt;switch-to-prev-buffer&lt;/code&gt; and &lt;code&gt;switch-to-next-buffer&lt;/code&gt; may ignore this option, for example, when there is only one buffer left these functions can switch to.</target>
        </trans-unit>
        <trans-unit id="e43f096d72c1fa7eda8bb11cbb26469630c96a62" translate="yes" xml:space="preserve">
          <source>Note also that window managers usually do not ask for resizing a frame when they change the number of lines occupied by an external menu or tool bar. Typically, such &amp;ldquo;wrappings&amp;rdquo; occur when a user shrinks a frame horizontally, making it impossible to display all elements of its menu or tool bar. They may also result from a change of the major mode altering the number of items of a menu or tool bar. Any such wrappings may implicitly alter the number of lines of a frame&amp;rsquo;s text area and are unaffected by the setting of this option.</source>
          <target state="translated">Note also that window managers usually do not ask for resizing a frame when they change the number of lines occupied by an external menu or tool bar. Typically, such &amp;ldquo;wrappings&amp;rdquo; occur when a user shrinks a frame horizontally, making it impossible to display all elements of its menu or tool bar. They may also result from a change of the major mode altering the number of items of a menu or tool bar. Any such wrappings may implicitly alter the number of lines of a frame&amp;rsquo;s text area and are unaffected by the setting of this option.</target>
        </trans-unit>
        <trans-unit id="c02c5b53625103bbcd1e981469317bde4d2eff01" translate="yes" xml:space="preserve">
          <source>Note also the function &lt;code&gt;window-largest-empty-rectangle&lt;/code&gt; (see &lt;a href=&quot;coordinates-and-windows#Coordinates-and-Windows&quot;&gt;Coordinates and Windows&lt;/a&gt;) which can be used to inscribe a child frame in the largest empty area of an existing window. This can be useful to avoid that a child frame obscures any text shown in that window.</source>
          <target state="translated">Note also the function &lt;code&gt;window-largest-empty-rectangle&lt;/code&gt; (see &lt;a href=&quot;coordinates-and-windows#Coordinates-and-Windows&quot;&gt;Coordinates and Windows&lt;/a&gt;) which can be used to inscribe a child frame in the largest empty area of an existing window. This can be useful to avoid that a child frame obscures any text shown in that window.</target>
        </trans-unit>
        <trans-unit id="ac296846d6e88621711014648ad3889107526b49" translate="yes" xml:space="preserve">
          <source>Note also, that positions specified relative to the right/bottom edge of a display, workarea or parent frame as well as floating-point offsets are stored internally as integer offsets relative to the left/top edge of the display, workarea or parent frame edge. They are also returned as such by functions like &lt;code&gt;frame-parameters&lt;/code&gt; and restored as such by the desktop saving routines.</source>
          <target state="translated">Note also, that positions specified relative to the right/bottom edge of a display, workarea or parent frame as well as floating-point offsets are stored internally as integer offsets relative to the left/top edge of the display, workarea or parent frame edge. They are also returned as such by functions like &lt;code&gt;frame-parameters&lt;/code&gt; and restored as such by the desktop saving routines.</target>
        </trans-unit>
        <trans-unit id="4ee808f9b4d3b62c6e1c4ae8210950ef2323557e" translate="yes" xml:space="preserve">
          <source>Note also, that the combined action alist may contain duplicate entries and entries for the same key with different values. As a rule, action functions always use the first association of a key they find. Hence, the association an action function uses is not necessarily the association provided by the display action that specified that action function,</source>
          <target state="translated">結合されたアクションのリストには、重複したエントリや、異なる値を持つ同じキーのためのエントリが含まれている可能性があることにも注意してください。ルールとして、アクション関数は常に見つけたキーの最初の関連付けを使用します。したがって、アクション関数が使用するアソシエーションは、必ずしもそのアクション関数を指定した表示アクションによって提供されるアソシエーションではありません。</target>
        </trans-unit>
        <trans-unit id="e5cf53f2f379d0df5750245ed5d07f62c700d148" translate="yes" xml:space="preserve">
          <source>Note how both &lt;code&gt;and&lt;/code&gt; and &lt;code&gt;let&lt;/code&gt; sub-patterns finish in the same way: by trying (always successfully) to match against the &lt;var&gt;symbol&lt;/var&gt; pattern &lt;code&gt;val&lt;/code&gt;, in the process binding &lt;code&gt;val&lt;/code&gt;. Thus, &lt;code&gt;or&lt;/code&gt; always matches and control always passes to the body form (line 9). Because that is the last body form in a successfully matched &lt;code&gt;pcase&lt;/code&gt; clause, it is the value of &lt;code&gt;pcase&lt;/code&gt; and likewise the return value of &lt;code&gt;grok/pcase&lt;/code&gt; (see &lt;a href=&quot;what-is-a-function#What-Is-a-Function&quot;&gt;What Is a Function&lt;/a&gt;).</source>
          <target state="translated">Note how both &lt;code&gt;and&lt;/code&gt; and &lt;code&gt;let&lt;/code&gt; sub-patterns finish in the same way: by trying (always successfully) to match against the &lt;var&gt;symbol&lt;/var&gt; pattern &lt;code&gt;val&lt;/code&gt; , in the process binding &lt;code&gt;val&lt;/code&gt; . Thus, &lt;code&gt;or&lt;/code&gt; always matches and control always passes to the body form (line 9). Because that is the last body form in a successfully matched &lt;code&gt;pcase&lt;/code&gt; clause, it is the value of &lt;code&gt;pcase&lt;/code&gt; and likewise the return value of &lt;code&gt;grok/pcase&lt;/code&gt; (see &lt;a href=&quot;what-is-a-function#What-Is-a-Function&quot;&gt;What Is a Function&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="da5b870679158a8dc429765e73588de68e861a6b" translate="yes" xml:space="preserve">
          <source>Note that &amp;lsquo;</source>
          <target state="translated">ご了承ください '</target>
        </trans-unit>
        <trans-unit id="5a8aa4751bb1c982814a77bf1d580dce6aad70e9" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;(car foo)&lt;/code&gt; is not executed if &lt;code&gt;(consp foo)&lt;/code&gt; returns &lt;code&gt;nil&lt;/code&gt;, thus avoiding an error.</source>
          <target state="translated">Note that &lt;code&gt;(car foo)&lt;/code&gt; is not executed if &lt;code&gt;(consp foo)&lt;/code&gt; returns &lt;code&gt;nil&lt;/code&gt; , thus avoiding an error.</target>
        </trans-unit>
        <trans-unit id="82cc38abe8d3c167aceee216d425c0ab550d1382" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;(delq 'c sample-list)&lt;/code&gt; modifies &lt;code&gt;sample-list&lt;/code&gt; to splice out the third element, but &lt;code&gt;(delq 'a sample-list)&lt;/code&gt; does not splice anything&amp;mdash;it just returns a shorter list. Don&amp;rsquo;t assume that a variable which formerly held the argument &lt;var&gt;list&lt;/var&gt; now has fewer elements, or that it still holds the original list! Instead, save the result of &lt;code&gt;delq&lt;/code&gt; and use that. Most often we store the result back into the variable that held the original list:</source>
          <target state="translated">Note that &lt;code&gt;(delq 'c sample-list)&lt;/code&gt; modifies &lt;code&gt;sample-list&lt;/code&gt; to splice out the third element, but &lt;code&gt;(delq 'a sample-list)&lt;/code&gt; does not splice anything&amp;mdash;it just returns a shorter list. Don&amp;rsquo;t assume that a variable which formerly held the argument &lt;var&gt;list&lt;/var&gt; now has fewer elements, or that it still holds the original list! Instead, save the result of &lt;code&gt;delq&lt;/code&gt; and use that. Most often we store the result back into the variable that held the original list:</target>
        </trans-unit>
        <trans-unit id="88ce8d10722b09594fee9067ec46be961db1010b" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;ad-activate&lt;/code&gt; had a global effect: it activated all pieces of advice enabled for that specified function. If you wanted to only activate or deactivate a particular piece, you needed to &lt;em&gt;enable&lt;/em&gt; or &lt;em&gt;disable&lt;/em&gt; it with &lt;code&gt;ad-enable-advice&lt;/code&gt; and &lt;code&gt;ad-disable-advice&lt;/code&gt;. The new mechanism does away with this distinction.</source>
          <target state="translated">Note that &lt;code&gt;ad-activate&lt;/code&gt; had a global effect: it activated all pieces of advice enabled for that specified function. If you wanted to only activate or deactivate a particular piece, you needed to &lt;em&gt;enable&lt;/em&gt; or &lt;em&gt;disable&lt;/em&gt; it with &lt;code&gt;ad-enable-advice&lt;/code&gt; and &lt;code&gt;ad-disable-advice&lt;/code&gt; . The new mechanism does away with this distinction.</target>
        </trans-unit>
        <trans-unit id="a8b9b0264afaff2247ccc31f5609c567f52bbb12" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;display-buffer-reuse-window&lt;/code&gt; appears redundant in the customization of &lt;code&gt;display-buffer-base-action&lt;/code&gt; because it is already part of &lt;code&gt;display-buffer-fallback-action&lt;/code&gt; and should be tried there anyway. However, that would fail because due to the precedence of &lt;code&gt;display-buffer-base-action&lt;/code&gt; over &lt;code&gt;display-buffer-fallback-action&lt;/code&gt;, at that time &lt;code&gt;display-buffer-pop-up-frame&lt;/code&gt; would have already won the race. In fact, this:</source>
          <target state="translated">Note that &lt;code&gt;display-buffer-reuse-window&lt;/code&gt; appears redundant in the customization of &lt;code&gt;display-buffer-base-action&lt;/code&gt; because it is already part of &lt;code&gt;display-buffer-fallback-action&lt;/code&gt; and should be tried there anyway. However, that would fail because due to the precedence of &lt;code&gt;display-buffer-base-action&lt;/code&gt; over &lt;code&gt;display-buffer-fallback-action&lt;/code&gt; , at that time &lt;code&gt;display-buffer-pop-up-frame&lt;/code&gt; would have already won the race. In fact, this:</target>
        </trans-unit>
        <trans-unit id="420700b2d9abe3e5aa5c3ba405713ee29ec392d5" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;eval-expression-debug-on-error&lt;/code&gt; overrides this variable in some cases; see below.</source>
          <target state="translated">Note that &lt;code&gt;eval-expression-debug-on-error&lt;/code&gt; overrides this variable in some cases; see below.</target>
        </trans-unit>
        <trans-unit id="bcbdaf4d50a8c86ab39d55059a3ac469c00b587e" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;expand-file-name&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; expand environment variables; only &lt;code&gt;substitute-in-file-name&lt;/code&gt; does that:</source>
          <target state="translated">Note that &lt;code&gt;expand-file-name&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; expand environment variables; only &lt;code&gt;substitute-in-file-name&lt;/code&gt; does that:</target>
        </trans-unit>
        <trans-unit id="ab80ac2f4a9d468cbc4712bf3ee278edec445477" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;let&lt;/code&gt; bindings are treated specially by the Emacs Lisp implementation. There is no way to duplicate this unwinding and rewinding behavior other than by using &lt;code&gt;let&lt;/code&gt;. For example, a manual implementation of &lt;code&gt;let&lt;/code&gt; written using &lt;code&gt;unwind-protect&lt;/code&gt; cannot arrange for variable values to be thread-specific.</source>
          <target state="translated">Note that &lt;code&gt;let&lt;/code&gt; bindings are treated specially by the Emacs Lisp implementation. There is no way to duplicate this unwinding and rewinding behavior other than by using &lt;code&gt;let&lt;/code&gt; . For example, a manual implementation of &lt;code&gt;let&lt;/code&gt; written using &lt;code&gt;unwind-protect&lt;/code&gt; cannot arrange for variable values to be thread-specific.</target>
        </trans-unit>
        <trans-unit id="89f00f3fb6940c8e5695af8eb8543d457737771c" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;macroexpand&lt;/code&gt; does not look at the subexpressions of &lt;var&gt;form&lt;/var&gt; (although some macro definitions may do so). Even if they are macro calls themselves, &lt;code&gt;macroexpand&lt;/code&gt; does not expand them.</source>
          <target state="translated">Note that &lt;code&gt;macroexpand&lt;/code&gt; does not look at the subexpressions of &lt;var&gt;form&lt;/var&gt; (although some macro definitions may do so). Even if they are macro calls themselves, &lt;code&gt;macroexpand&lt;/code&gt; does not expand them.</target>
        </trans-unit>
        <trans-unit id="d670e88e4393319b698452d1022060ef368672e8" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;nil&lt;/code&gt;, being both a valid alist and a valid plist, represents &lt;code&gt;{}&lt;/code&gt;, the empty JSON object; not &lt;code&gt;null&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt;, or an empty array, all of which are different JSON values.</source>
          <target state="translated">Note that &lt;code&gt;nil&lt;/code&gt; , being both a valid alist and a valid plist, represents &lt;code&gt;{}&lt;/code&gt; , the empty JSON object; not &lt;code&gt;null&lt;/code&gt; , &lt;code&gt;false&lt;/code&gt; , or an empty array, all of which are different JSON values.</target>
        </trans-unit>
        <trans-unit id="9fa6019796c4614fd1ce6adb41579f6d542fd75e" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;set-window-hscroll&lt;/code&gt; may appear not to work if you test it by evaluating a call with</source>
          <target state="translated">Note that &lt;code&gt;set-window-hscroll&lt;/code&gt; may appear not to work if you test it by evaluating a call with</target>
        </trans-unit>
        <trans-unit id="2ea6c975bcb32bc398a9332341b86368aab4d1e0" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;sort-columns&lt;/code&gt; rejects text that contains tabs, because tabs could be split across the specified columns. Use</source>
          <target state="translated">Note that &lt;code&gt;sort-columns&lt;/code&gt; rejects text that contains tabs, because tabs could be split across the specified columns. Use</target>
        </trans-unit>
        <trans-unit id="e14386726913a3c2fd59bf734e821066eca6e0b8" translate="yes" xml:space="preserve">
          <source>Note that &lt;var&gt;condition&lt;/var&gt; will only be evaluated when redisplay examines the text where this display spec is located, so this feature is best suited for conditions that are relatively stable, i.e. yield, for each particular buffer position, the same results on every evaluation. If the results change for the same text location, e.g., if the result depends on the position of point, then the conditional specification might not do what you want, because redisplay examines only those parts of buffer text where it has reasons to assume that something changed since the last display cycle.</source>
          <target state="translated">Note that &lt;var&gt;condition&lt;/var&gt; will only be evaluated when redisplay examines the text where this display spec is located, so this feature is best suited for conditions that are relatively stable, i.e. yield, for each particular buffer position, the same results on every evaluation. If the results change for the same text location, e.g., if the result depends on the position of point, then the conditional specification might not do what you want, because redisplay examines only those parts of buffer text where it has reasons to assume that something changed since the last display cycle.</target>
        </trans-unit>
        <trans-unit id="11c86dc7160f3159d0caf4f8ca652e035830aeb9" translate="yes" xml:space="preserve">
          <source>Note that &lt;var&gt;row&lt;/var&gt; is counted from the top of the text area. If the window given by &lt;var&gt;position&lt;/var&gt; possesses a header line (see &lt;a href=&quot;header-lines#Header-Lines&quot;&gt;Header Lines&lt;/a&gt;) or a tab line, they are &lt;em&gt;not&lt;/em&gt; included in the &lt;var&gt;row&lt;/var&gt; count.</source>
          <target state="translated">Note that &lt;var&gt;row&lt;/var&gt; is counted from the top of the text area. If the window given by &lt;var&gt;position&lt;/var&gt; possesses a header line (see &lt;a href=&quot;header-lines#Header-Lines&quot;&gt;Header Lines&lt;/a&gt;) or a tab line, they are &lt;em&gt;not&lt;/em&gt; included in the &lt;var&gt;row&lt;/var&gt; count.</target>
        </trans-unit>
        <trans-unit id="36140c7862902330c0ed8b4c4f62d98557115715" translate="yes" xml:space="preserve">
          <source>Note that C code cannot call functions by name unless they are defined in C. The way to call a function written in Lisp is to use &lt;code&gt;Ffuncall&lt;/code&gt;, which embodies the Lisp function &lt;code&gt;funcall&lt;/code&gt;. Since the Lisp function &lt;code&gt;funcall&lt;/code&gt; accepts an unlimited number of arguments, in C it takes two: the number of Lisp-level arguments, and a one-dimensional array containing their values. The first Lisp-level argument is the Lisp function to call, and the rest are the arguments to pass to it.</source>
          <target state="translated">Note that C code cannot call functions by name unless they are defined in C. The way to call a function written in Lisp is to use &lt;code&gt;Ffuncall&lt;/code&gt; , which embodies the Lisp function &lt;code&gt;funcall&lt;/code&gt; . Since the Lisp function &lt;code&gt;funcall&lt;/code&gt; accepts an unlimited number of arguments, in C it takes two: the number of Lisp-level arguments, and a one-dimensional array containing their values. The first Lisp-level argument is the Lisp function to call, and the rest are the arguments to pass to it.</target>
        </trans-unit>
        <trans-unit id="e556b978b826723508b3c9b15f0f641cf8aad16e" translate="yes" xml:space="preserve">
          <source>Note that Emacs automatically saves and restores the match data while executing filter functions. See &lt;a href=&quot;match-data#Match-Data&quot;&gt;Match Data&lt;/a&gt;.</source>
          <target state="translated">Note that Emacs automatically saves and restores the match data while executing filter functions. See &lt;a href=&quot;match-data#Match-Data&quot;&gt;Match Data&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="849766f54cbb0ac387cb87a85961815edd45103c" translate="yes" xml:space="preserve">
          <source>Note that Emacs automatically saves and restores the match data while executing sentinels. See &lt;a href=&quot;match-data#Match-Data&quot;&gt;Match Data&lt;/a&gt;.</source>
          <target state="translated">Note that Emacs automatically saves and restores the match data while executing sentinels. See &lt;a href=&quot;match-data#Match-Data&quot;&gt;Match Data&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="fd5df05fa87dff11a9d0af24fb74e840bb6e9f14" translate="yes" xml:space="preserve">
          <source>Note that Emacs sometimes uses non-numeric priority values for some of its internal overlays, so do not try to do arithmetic on the priority of an overlay (unless it is one that you created). In particular, the overlay used for showing the region uses a priority value of the form &lt;code&gt;(&lt;var&gt;primary&lt;/var&gt;&amp;nbsp;.&amp;nbsp;&lt;var&gt;secondary&lt;/var&gt;)&lt;/code&gt;, where the &lt;var&gt;primary&lt;/var&gt; value is used as described above, and &lt;var&gt;secondary&lt;/var&gt; is the fallback value used when &lt;var&gt;primary&lt;/var&gt; and the nesting considerations fail to resolve the precedence between overlays. However, you are advised not to design Lisp programs based on this implementation detail; if you need to put overlays in priority order, use the &lt;var&gt;sorted&lt;/var&gt; argument of &lt;code&gt;overlays-at&lt;/code&gt;. See &lt;a href=&quot;finding-overlays#Finding-Overlays&quot;&gt;Finding Overlays&lt;/a&gt;.</source>
          <target state="translated">Note that Emacs sometimes uses non-numeric priority values for some of its internal overlays, so do not try to do arithmetic on the priority of an overlay (unless it is one that you created). In particular, the overlay used for showing the region uses a priority value of the form &lt;code&gt;(&lt;var&gt;primary&lt;/var&gt;&amp;nbsp;.&amp;nbsp;&lt;var&gt;secondary&lt;/var&gt;)&lt;/code&gt; , where the &lt;var&gt;primary&lt;/var&gt; value is used as described above, and &lt;var&gt;secondary&lt;/var&gt; is the fallback value used when &lt;var&gt;primary&lt;/var&gt; and the nesting considerations fail to resolve the precedence between overlays. However, you are advised not to design Lisp programs based on this implementation detail; if you need to put overlays in priority order, use the &lt;var&gt;sorted&lt;/var&gt; argument of &lt;code&gt;overlays-at&lt;/code&gt; . See &lt;a href=&quot;finding-overlays#Finding-Overlays&quot;&gt;Finding Overlays&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="1d3be1a87b3711b91ae65cc80a7d5b435901ca0c" translate="yes" xml:space="preserve">
          <source>Note that Emacs tries to expand macros when loading an uncompiled Lisp file. This is not always possible, but if it is, it speeds up subsequent execution. See &lt;a href=&quot;how-programs-do-loading#How-Programs-Do-Loading&quot;&gt;How Programs Do Loading&lt;/a&gt;.</source>
          <target state="translated">Note that Emacs tries to expand macros when loading an uncompiled Lisp file. This is not always possible, but if it is, it speeds up subsequent execution. See &lt;a href=&quot;how-programs-do-loading#How-Programs-Do-Loading&quot;&gt;How Programs Do Loading&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="0b3adfb09c7f22559fa8fff3314fa3e947a0a9c9" translate="yes" xml:space="preserve">
          <source>Note that a frame cannot be deleted as long as its minibuffer serves as surrogate minibuffer for another frame (see &lt;a href=&quot;minibuffers-and-frames#Minibuffers-and-Frames&quot;&gt;Minibuffers and Frames&lt;/a&gt;). Normally, you cannot delete a frame if all other frames are invisible, but if &lt;var&gt;force&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, then you are allowed to do so.</source>
          <target state="translated">Note that a frame cannot be deleted as long as its minibuffer serves as surrogate minibuffer for another frame (see &lt;a href=&quot;minibuffers-and-frames#Minibuffers-and-Frames&quot;&gt;Minibuffers and Frames&lt;/a&gt;). Normally, you cannot delete a frame if all other frames are invisible, but if &lt;var&gt;force&lt;/var&gt; is non- &lt;code&gt;nil&lt;/code&gt; , then you are allowed to do so.</target>
        </trans-unit>
        <trans-unit id="6c88bb0b96b0659e2468d8c7144a4535dc553f33" translate="yes" xml:space="preserve">
          <source>Note that a sublist specification written as &lt;code&gt;(specs .  nil)&lt;/code&gt; is equivalent to &lt;code&gt;(specs)&lt;/code&gt;, and &lt;code&gt;(specs .
(sublist-elements&amp;hellip;))&lt;/code&gt; is equivalent to &lt;code&gt;(specs
sublist-elements&amp;hellip;)&lt;/code&gt;.</source>
          <target state="translated">Note that a sublist specification written as &lt;code&gt;(specs . nil)&lt;/code&gt; is equivalent to &lt;code&gt;(specs)&lt;/code&gt; , and &lt;code&gt;(specs . (sublist-elements&amp;hellip;))&lt;/code&gt; is equivalent to &lt;code&gt;(specs sublist-elements&amp;hellip;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b700a940d8e3ee969e5d08838da33d645a36c49b" translate="yes" xml:space="preserve">
          <source>Note that a symbol used as a function name may also be used as a variable; these two uses of a symbol are independent and do not conflict. (This is not the case in some dialects of Lisp, like Scheme.)</source>
          <target state="translated">関数名として使われている記号は変数として使われることもあります。(SchemeのようなLispの方言ではこの限りではありません)。</target>
        </trans-unit>
        <trans-unit id="0e7d278c76ca3c97b7fc7f52a288a7ed8d2b5fc0" translate="yes" xml:space="preserve">
          <source>Note that all functions described below will respect the adherence of frames (and all other window-system windows) to their respective z-group (see &lt;a href=&quot;position-parameters#Position-Parameters&quot;&gt;Position Parameters&lt;/a&gt;). For example, you usually cannot lower a frame below that of the desktop window and you cannot raise a frame whose &lt;code&gt;z-group&lt;/code&gt; parameter is &lt;code&gt;nil&lt;/code&gt; above the window-system&amp;rsquo;s taskbar or tooltip window.</source>
          <target state="translated">Note that all functions described below will respect the adherence of frames (and all other window-system windows) to their respective z-group (see &lt;a href=&quot;position-parameters#Position-Parameters&quot;&gt;Position Parameters&lt;/a&gt;). For example, you usually cannot lower a frame below that of the desktop window and you cannot raise a frame whose &lt;code&gt;z-group&lt;/code&gt; parameter is &lt;code&gt;nil&lt;/code&gt; above the window-system&amp;rsquo;s taskbar or tooltip window.</target>
        </trans-unit>
        <trans-unit id="1eca8603245bea5b809eedfce8382a27e1e6ac6e" translate="yes" xml:space="preserve">
          <source>Note that among the internal functions listed here, &lt;code&gt;display-buffer--maybe-same-window&lt;/code&gt; is effectively ignored while &lt;code&gt;display-buffer--maybe-pop-up-frame-or-window&lt;/code&gt; actually runs &lt;code&gt;display-buffer-pop-up-window&lt;/code&gt;.</source>
          <target state="translated">Note that among the internal functions listed here, &lt;code&gt;display-buffer--maybe-same-window&lt;/code&gt; is effectively ignored while &lt;code&gt;display-buffer--maybe-pop-up-frame-or-window&lt;/code&gt; actually runs &lt;code&gt;display-buffer-pop-up-window&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7d006d7d82c4cf8967401facb8495eb53ce2b548" translate="yes" xml:space="preserve">
          <source>Note that any functions added to these hooks by your initial file are usually not run for the initial frame, since Emacs reads the initial file only after creating that frame. However, if the initial frame is specified to use a separate minibuffer frame (see &lt;a href=&quot;minibuffers-and-frames#Minibuffers-and-Frames&quot;&gt;Minibuffers and Frames&lt;/a&gt;), the functions will be run for both, the minibuffer-less and the minibuffer frame.</source>
          <target state="translated">Note that any functions added to these hooks by your initial file are usually not run for the initial frame, since Emacs reads the initial file only after creating that frame. However, if the initial frame is specified to use a separate minibuffer frame (see &lt;a href=&quot;minibuffers-and-frames#Minibuffers-and-Frames&quot;&gt;Minibuffers and Frames&lt;/a&gt;), the functions will be run for both, the minibuffer-less and the minibuffer frame.</target>
        </trans-unit>
        <trans-unit id="6b08f2421a6c05a0ee00e59222f1df594f4fd0e9" translate="yes" xml:space="preserve">
          <source>Note that any non-&lt;code&gt;nil&lt;/code&gt; symbol might be used as an event or an event type; &lt;code&gt;eventp&lt;/code&gt; cannot distinguish whether a symbol is intended by Lisp code to be used as an event.</source>
          <target state="translated">Note that any non- &lt;code&gt;nil&lt;/code&gt; symbol might be used as an event or an event type; &lt;code&gt;eventp&lt;/code&gt; cannot distinguish whether a symbol is intended by Lisp code to be used as an event.</target>
        </trans-unit>
        <trans-unit id="d1591e27e69961a04460b2fe1820737613f07080" translate="yes" xml:space="preserve">
          <source>Note that case conversion is not a one-to-one mapping of codepoints and length of the result may differ from length of the argument. Furthermore, because passing a character forces return type to be a character, functions are unable to perform proper substitution and result may differ compared to treating a one-character string. For example:</source>
          <target state="translated">大文字小文字の変換はコードポイントの一対一の対応付けではなく、結果の長さが引数の長さと異なる場合があることに注意してください。さらに、文字を渡すとreturn型が強制的に文字になるため、関数は適切な置換を行うことができず、1文字の文字列を扱う場合と結果が異なる場合があります。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="ce70eb5a1727174c7a315b786b751a0ce2e6823e" translate="yes" xml:space="preserve">
          <source>Note that display tables affect how the mode line is displayed, so if you want to force redisplay of the mode line using a new display table, call &lt;code&gt;force-mode-line-update&lt;/code&gt; (see &lt;a href=&quot;mode-line-format#Mode-Line-Format&quot;&gt;Mode Line Format&lt;/a&gt;).</source>
          <target state="translated">Note that display tables affect how the mode line is displayed, so if you want to force redisplay of the mode line using a new display table, call &lt;code&gt;force-mode-line-update&lt;/code&gt; (see &lt;a href=&quot;mode-line-format#Mode-Line-Format&quot;&gt;Mode Line Format&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="3e027fd5d05afab1bae33a36130ab5cf384d7efa" translate="yes" xml:space="preserve">
          <source>Note that elements of &lt;code&gt;minor-mode-map-alist&lt;/code&gt; do not have the same structure as elements of &lt;code&gt;minor-mode-alist&lt;/code&gt;. The map must be the &lt;small&gt;CDR&lt;/small&gt; of the element; a list with the map as the second element will not do. The &lt;small&gt;CDR&lt;/small&gt; can be either a keymap (a list) or a symbol whose function definition is a keymap.</source>
          <target state="translated">Note that elements of &lt;code&gt;minor-mode-map-alist&lt;/code&gt; do not have the same structure as elements of &lt;code&gt;minor-mode-alist&lt;/code&gt; . The map must be the &lt;small&gt;CDR&lt;/small&gt; of the element; a list with the map as the second element will not do. The &lt;small&gt;CDR&lt;/small&gt; can be either a keymap (a list) or a symbol whose function definition is a keymap.</target>
        </trans-unit>
        <trans-unit id="5c6f5e6a17b21c98d8da299e04e71ec5bc5fccaa" translate="yes" xml:space="preserve">
          <source>Note that for &lt;code&gt;nthcdr&lt;/code&gt;, the list argument of the function must itself be a valid &lt;var&gt;place&lt;/var&gt; form. For example, &lt;code&gt;(setf (nthcdr
0 foo) 7)&lt;/code&gt; will set &lt;code&gt;foo&lt;/code&gt; itself to 7.</source>
          <target state="translated">Note that for &lt;code&gt;nthcdr&lt;/code&gt; , the list argument of the function must itself be a valid &lt;var&gt;place&lt;/var&gt; form. For example, &lt;code&gt;(setf (nthcdr 0 foo) 7)&lt;/code&gt; will set &lt;code&gt;foo&lt;/code&gt; itself to 7.</target>
        </trans-unit>
        <trans-unit id="b7031d4a6bb1fd17ff90dc3b21b4c28dae0691db" translate="yes" xml:space="preserve">
          <source>Note that hyphen (&lt;code&gt;-&lt;/code&gt;) is special in strings in this construct, since it acts as a range separator. To include a hyphen, add it as a separate character or single-character string. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">Note that hyphen ( &lt;code&gt;-&lt;/code&gt; ) is special in strings in this construct, since it acts as a range separator. To include a hyphen, add it as a separate character or single-character string. Corresponding string regexp: &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="71a252b7e10406a1efe10d060f22023cc1adeb54" translate="yes" xml:space="preserve">
          <source>Note that if Emacs already has a buffer visiting the same file non-literally, it will not visit the same file literally, but instead just switch to the existing buffer. If you want to be sure of accessing a file&amp;rsquo;s contents literally, you should create a temporary buffer and then read the file contents into it using &lt;code&gt;insert-file-contents-literally&lt;/code&gt; (see &lt;a href=&quot;reading-from-files#Reading-from-Files&quot;&gt;Reading from Files&lt;/a&gt;).</source>
          <target state="translated">Note that if Emacs already has a buffer visiting the same file non-literally, it will not visit the same file literally, but instead just switch to the existing buffer. If you want to be sure of accessing a file&amp;rsquo;s contents literally, you should create a temporary buffer and then read the file contents into it using &lt;code&gt;insert-file-contents-literally&lt;/code&gt; (see &lt;a href=&quot;reading-from-files#Reading-from-Files&quot;&gt;Reading from Files&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="7aabecd82de173080e0d6a40e3c8b6bd5b301744" translate="yes" xml:space="preserve">
          <source>Note that if the string to be displayed in the margin doesn&amp;rsquo;t specify a face, its face is determined using the same rules and priorities as it is for strings displayed in the text area (see &lt;a href=&quot;displaying-faces#Displaying-Faces&quot;&gt;Displaying Faces&lt;/a&gt;). If this results in undesirable &amp;ldquo;leaking&amp;rdquo; of faces into the margin, make sure the string has an explicit face specified for it.</source>
          <target state="translated">Note that if the string to be displayed in the margin doesn&amp;rsquo;t specify a face, its face is determined using the same rules and priorities as it is for strings displayed in the text area (see &lt;a href=&quot;displaying-faces#Displaying-Faces&quot;&gt;Displaying Faces&lt;/a&gt;). If this results in undesirable &amp;ldquo;leaking&amp;rdquo; of faces into the margin, make sure the string has an explicit face specified for it.</target>
        </trans-unit>
        <trans-unit id="d4e506505176e0289fea2ef20ed99c25d90708a5" translate="yes" xml:space="preserve">
          <source>Note that if the text also has a &lt;code&gt;height&lt;/code&gt; display specification, which was specified before (i.e. to the left of) &lt;code&gt;raise&lt;/code&gt;, the latter will affect the amount of raising or lowering in pixels, because that is based on the height of the text being raised. Therefore, if you want to display a sub- or superscript that is smaller than the normal text height, consider specifying &lt;code&gt;raise&lt;/code&gt; before &lt;code&gt;height&lt;/code&gt;.</source>
          <target state="translated">Note that if the text also has a &lt;code&gt;height&lt;/code&gt; display specification, which was specified before (i.e. to the left of) &lt;code&gt;raise&lt;/code&gt; , the latter will affect the amount of raising or lowering in pixels, because that is based on the height of the text being raised. Therefore, if you want to display a sub- or superscript that is smaller than the normal text height, consider specifying &lt;code&gt;raise&lt;/code&gt; before &lt;code&gt;height&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4f83321e2dc6362ff6bb142d1319ba7d1841f375" translate="yes" xml:space="preserve">
          <source>Note that image types &lt;code&gt;pbm&lt;/code&gt; and &lt;code&gt;xbm&lt;/code&gt; do not need entries in this variable because they do not depend on external libraries and are always available in Emacs.</source>
          <target state="translated">Note that image types &lt;code&gt;pbm&lt;/code&gt; and &lt;code&gt;xbm&lt;/code&gt; do not need entries in this variable because they do not depend on external libraries and are always available in Emacs.</target>
        </trans-unit>
        <trans-unit id="2b90bd2256efbea7d91a8f1731d6cbc9dc04839d" translate="yes" xml:space="preserve">
          <source>Note that in contrast to &lt;code&gt;or&lt;/code&gt;, both arguments are always evaluated.</source>
          <target state="translated">Note that in contrast to &lt;code&gt;or&lt;/code&gt; , both arguments are always evaluated.</target>
        </trans-unit>
        <trans-unit id="f1d398c647559c7e5536cae0d92bd8598b1b5529" translate="yes" xml:space="preserve">
          <source>Note that in the third example, the function returned</source>
          <target state="translated">3 番目の例では、関数は</target>
        </trans-unit>
        <trans-unit id="f10b1133c79e4544a6c4fd2a1bf8f43bddfa17d8" translate="yes" xml:space="preserve">
          <source>Note that keymaps and keyboard macros (strings and vectors) are not valid functions, so a symbol with a keymap, string, or vector as its function definition is invalid as a function. It is, however, valid as a key binding. If the definition is a keyboard macro, then the symbol is also valid as an argument to &lt;code&gt;command-execute&lt;/code&gt; (see &lt;a href=&quot;interactive-call#Interactive-Call&quot;&gt;Interactive Call&lt;/a&gt;).</source>
          <target state="translated">Note that keymaps and keyboard macros (strings and vectors) are not valid functions, so a symbol with a keymap, string, or vector as its function definition is invalid as a function. It is, however, valid as a key binding. If the definition is a keyboard macro, then the symbol is also valid as an argument to &lt;code&gt;command-execute&lt;/code&gt; (see &lt;a href=&quot;interactive-call#Interactive-Call&quot;&gt;Interactive Call&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="f7ca497421798c821a09facd3f3452f27743e204" translate="yes" xml:space="preserve">
          <source>Note that negative values do not permit to align the right or bottom edge of &lt;var&gt;frame&lt;/var&gt; exactly at the right or bottom edge of its display or parent frame. Neither do they allow to specify a position that does not lie within the edges of the display or parent frame. The frame parameters &lt;code&gt;left&lt;/code&gt; and &lt;code&gt;top&lt;/code&gt; (see &lt;a href=&quot;position-parameters#Position-Parameters&quot;&gt;Position Parameters&lt;/a&gt;) allow to do that, but may still fail to provide good results for the initial or a new frame.</source>
          <target state="translated">Note that negative values do not permit to align the right or bottom edge of &lt;var&gt;frame&lt;/var&gt; exactly at the right or bottom edge of its display or parent frame. Neither do they allow to specify a position that does not lie within the edges of the display or parent frame. The frame parameters &lt;code&gt;left&lt;/code&gt; and &lt;code&gt;top&lt;/code&gt; (see &lt;a href=&quot;position-parameters#Position-Parameters&quot;&gt;Position Parameters&lt;/a&gt;) allow to do that, but may still fail to provide good results for the initial or a new frame.</target>
        </trans-unit>
        <trans-unit id="6bb86bc06ff9fe96cf961221500aba7002f6114c" translate="yes" xml:space="preserve">
          <source>Note that on multi-monitor displays (see &lt;a href=&quot;multiple-terminals#Multiple-Terminals&quot;&gt;Multiple Terminals&lt;/a&gt;), the window manager might position the frame differently than specified by the positional parameters in &lt;var&gt;parameters&lt;/var&gt; (see &lt;a href=&quot;position-parameters#Position-Parameters&quot;&gt;Position Parameters&lt;/a&gt;). For example, some window managers have a policy of displaying the frame on the monitor that contains the largest part of the window (a.k.a. the &lt;em&gt;dominating&lt;/em&gt; monitor).</source>
          <target state="translated">Note that on multi-monitor displays (see &lt;a href=&quot;multiple-terminals#Multiple-Terminals&quot;&gt;Multiple Terminals&lt;/a&gt;), the window manager might position the frame differently than specified by the positional parameters in &lt;var&gt;parameters&lt;/var&gt; (see &lt;a href=&quot;position-parameters#Position-Parameters&quot;&gt;Position Parameters&lt;/a&gt;). For example, some window managers have a policy of displaying the frame on the monitor that contains the largest part of the window (a.k.a. the &lt;em&gt;dominating&lt;/em&gt; monitor).</target>
        </trans-unit>
        <trans-unit id="451dabba0c45d6a9da92c12dfcbef25151b92f65" translate="yes" xml:space="preserve">
          <source>Note that once you have defined a face (usually with &lt;code&gt;defface&lt;/code&gt;), you cannot later undefine this face safely, except by restarting Emacs.</source>
          <target state="translated">Note that once you have defined a face (usually with &lt;code&gt;defface&lt;/code&gt; ), you cannot later undefine this face safely, except by restarting Emacs.</target>
        </trans-unit>
        <trans-unit id="8be3a3df08c2c43245d05ddcd5d07fbab7b209b4" translate="yes" xml:space="preserve">
          <source>Note that property lists are similar to association lists in several respects. A property list behaves like an association list in which each key can occur only once. See &lt;a href=&quot;property-lists#Property-Lists&quot;&gt;Property Lists&lt;/a&gt;, for a comparison of property lists and association lists.</source>
          <target state="translated">Note that property lists are similar to association lists in several respects. A property list behaves like an association list in which each key can occur only once. See &lt;a href=&quot;property-lists#Property-Lists&quot;&gt;Property Lists&lt;/a&gt;, for a comparison of property lists and association lists.</target>
        </trans-unit>
        <trans-unit id="cf01d48b51913f0cf00ab32bac6c884aa95173f2" translate="yes" xml:space="preserve">
          <source>Note that providing such an entry alone does not necessarily make the window as tall as specified by its value. To actually resize an existing window or make a new window as tall as specified by that value, a &lt;code&gt;window-height&lt;/code&gt; entry specifying that value should be provided as well. Such a &lt;code&gt;window-height&lt;/code&gt; entry can, however, specify a completely different value or ask the window height to be fit to that of its buffer in which case the &lt;code&gt;window-min-height&lt;/code&gt; entry provides the guaranteed minimum height of the window used.</source>
          <target state="translated">Note that providing such an entry alone does not necessarily make the window as tall as specified by its value. To actually resize an existing window or make a new window as tall as specified by that value, a &lt;code&gt;window-height&lt;/code&gt; entry specifying that value should be provided as well. Such a &lt;code&gt;window-height&lt;/code&gt; entry can, however, specify a completely different value or ask the window height to be fit to that of its buffer in which case the &lt;code&gt;window-min-height&lt;/code&gt; entry provides the guaranteed minimum height of the window used.</target>
        </trans-unit>
        <trans-unit id="a8d1c86e0cb1777d5c4381401ecb75f9d100b2f8" translate="yes" xml:space="preserve">
          <source>Note that references to &lt;code&gt;foo&lt;/code&gt; in &lt;var&gt;body&lt;/var&gt; access the buffer-local binding of buffer &amp;lsquo;</source>
          <target state="translated">Note that references to &lt;code&gt;foo&lt;/code&gt; in &lt;var&gt;body&lt;/var&gt; access the buffer-local binding of buffer &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="944ce22b3c1e0e4361ff98e0b47922f894f4954d" translate="yes" xml:space="preserve">
          <source>Note that remapping only takes place through active keymaps; for example, putting a remapping in a prefix keymap like &lt;code&gt;ctl-x-map&lt;/code&gt; typically has no effect, as such keymaps are not themselves active. In addition, remapping only works through a single level; in the following example,</source>
          <target state="translated">Note that remapping only takes place through active keymaps; for example, putting a remapping in a prefix keymap like &lt;code&gt;ctl-x-map&lt;/code&gt; typically has no effect, as such keymaps are not themselves active. In addition, remapping only works through a single level; in the following example,</target>
        </trans-unit>
        <trans-unit id="aa44f3362212f49d475dc95b39b81576e77893a3" translate="yes" xml:space="preserve">
          <source>Note that setting this variable to a non-&lt;code&gt;nil&lt;/code&gt; value does not change the fact that auto-saving is different from saving the buffer; e.g., the hooks described in &lt;a href=&quot;saving-buffers#Saving-Buffers&quot;&gt;Saving Buffers&lt;/a&gt; are &lt;em&gt;not&lt;/em&gt; run when a buffer is auto-saved.</source>
          <target state="translated">Note that setting this variable to a non- &lt;code&gt;nil&lt;/code&gt; value does not change the fact that auto-saving is different from saving the buffer; e.g., the hooks described in &lt;a href=&quot;saving-buffers#Saving-Buffers&quot;&gt;Saving Buffers&lt;/a&gt; are &lt;em&gt;not&lt;/em&gt; run when a buffer is auto-saved.</target>
        </trans-unit>
        <trans-unit id="ce4d07d18464ef749e1edb147a33de09d0f7af7e" translate="yes" xml:space="preserve">
          <source>Note that several rings in Emacs, like the kill ring and the mark ring, are actually implemented as simple lists, &lt;em&gt;not&lt;/em&gt; using the &lt;code&gt;ring&lt;/code&gt; package; thus the following functions won&amp;rsquo;t work on them.</source>
          <target state="translated">Note that several rings in Emacs, like the kill ring and the mark ring, are actually implemented as simple lists, &lt;em&gt;not&lt;/em&gt; using the &lt;code&gt;ring&lt;/code&gt; package; thus the following functions won&amp;rsquo;t work on them.</target>
        </trans-unit>
        <trans-unit id="ada2f27c9ba203cc421e71266f32365f19ed4b0f" translate="yes" xml:space="preserve">
          <source>Note that since &lt;code&gt;switch-to-prev-buffer&lt;/code&gt; is called by &lt;code&gt;bury-buffer&lt;/code&gt;, &lt;code&gt;replace-buffer-in-windows&lt;/code&gt; and &lt;code&gt;quit-restore-window&lt;/code&gt; as well, customizing this option may also affect the behavior of Emacs when a window is quit or a buffer gets buried or killed.</source>
          <target state="translated">Note that since &lt;code&gt;switch-to-prev-buffer&lt;/code&gt; is called by &lt;code&gt;bury-buffer&lt;/code&gt; , &lt;code&gt;replace-buffer-in-windows&lt;/code&gt; and &lt;code&gt;quit-restore-window&lt;/code&gt; as well, customizing this option may also affect the behavior of Emacs when a window is quit or a buffer gets buried or killed.</target>
        </trans-unit>
        <trans-unit id="df75894a436d2ac6f25b076d7908978b97f93102" translate="yes" xml:space="preserve">
          <source>Note that since this is a function, it can only return non-&lt;code&gt;nil&lt;/code&gt; for variables which are permanently special, but not for those that are only special in the current lexical scope.</source>
          <target state="translated">Note that since this is a function, it can only return non- &lt;code&gt;nil&lt;/code&gt; for variables which are permanently special, but not for those that are only special in the current lexical scope.</target>
        </trans-unit>
        <trans-unit id="2fac15f40439742424e3aa18f0429ca4f01e2aaf" translate="yes" xml:space="preserve">
          <source>Note that sometimes selecting a window is not enough to show it, or make its frame the top-most frame on display: you may also need to raise the frame or make sure input focus is directed to that frame. See &lt;a href=&quot;input-focus#Input-Focus&quot;&gt;Input Focus&lt;/a&gt;.</source>
          <target state="translated">Note that sometimes selecting a window is not enough to show it, or make its frame the top-most frame on display: you may also need to raise the frame or make sure input focus is directed to that frame. See &lt;a href=&quot;input-focus#Input-Focus&quot;&gt;Input Focus&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="1028e973fd6d45e7d7652a7eded330cbb5470222" translate="yes" xml:space="preserve">
          <source>Note that space properties are treated as paragraph separators for the purposes of reordering bidirectional text for display. See &lt;a href=&quot;bidirectional-display#Bidirectional-Display&quot;&gt;Bidirectional Display&lt;/a&gt;, for the details.</source>
          <target state="translated">Note that space properties are treated as paragraph separators for the purposes of reordering bidirectional text for display. See &lt;a href=&quot;bidirectional-display#Bidirectional-Display&quot;&gt;Bidirectional Display&lt;/a&gt;, for the details.</target>
        </trans-unit>
        <trans-unit id="7cb5ad3eb4a2271a938c9aa7f77ae8d741838eaf" translate="yes" xml:space="preserve">
          <source>Note that specifying a value, even &lt;code&gt;nil&lt;/code&gt;, marks the variable as special permanently. Whereas if &lt;var&gt;value&lt;/var&gt; is omitted then the variable is only marked special locally (i.e. within the current lexical scope, or file if at the top-level). This can be useful for suppressing byte compilation warnings, see &lt;a href=&quot;compiler-errors#Compiler-Errors&quot;&gt;Compiler Errors&lt;/a&gt;.</source>
          <target state="translated">Note that specifying a value, even &lt;code&gt;nil&lt;/code&gt; , marks the variable as special permanently. Whereas if &lt;var&gt;value&lt;/var&gt; is omitted then the variable is only marked special locally (i.e. within the current lexical scope, or file if at the top-level). This can be useful for suppressing byte compilation warnings, see &lt;a href=&quot;compiler-errors#Compiler-Errors&quot;&gt;Compiler Errors&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="d0bceaee80bf44f350b2b336e7bdc4aca04effe6" translate="yes" xml:space="preserve">
          <source>Note that storing a new binding for</source>
          <target state="translated">の新しいバインディングを保存することに注意してください。</target>
        </trans-unit>
        <trans-unit id="ca0f3720c830567e36124202fdc192dd9c282156" translate="yes" xml:space="preserve">
          <source>Note that storing new values into the &lt;small&gt;CDR&lt;/small&gt;s of cons cells in this list does &lt;em&gt;not&lt;/em&gt; change the buffer-local values of the variables.</source>
          <target state="translated">Note that storing new values into the &lt;small&gt;CDR&lt;/small&gt;s of cons cells in this list does &lt;em&gt;not&lt;/em&gt; change the buffer-local values of the variables.</target>
        </trans-unit>
        <trans-unit id="bcb5445ab75b38c5ccd760396b2859fa80f84f86" translate="yes" xml:space="preserve">
          <source>Note that text in paragraphs whose base direction is right-to-left (see &lt;a href=&quot;bidirectional-display#Bidirectional-Display&quot;&gt;Bidirectional Display&lt;/a&gt;) moves in the opposite direction: e.g., it moves to the right when &lt;code&gt;scroll-left&lt;/code&gt; is invoked with a positive value of &lt;var&gt;count&lt;/var&gt;.</source>
          <target state="translated">Note that text in paragraphs whose base direction is right-to-left (see &lt;a href=&quot;bidirectional-display#Bidirectional-Display&quot;&gt;Bidirectional Display&lt;/a&gt;) moves in the opposite direction: e.g., it moves to the right when &lt;code&gt;scroll-left&lt;/code&gt; is invoked with a positive value of &lt;var&gt;count&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="643a90b7cc572aa8f24a2a4aeec18309319e74d7" translate="yes" xml:space="preserve">
          <source>Note that the</source>
          <target state="translated">に注意してください。</target>
        </trans-unit>
        <trans-unit id="e36a773ef709e536a82e2d886a7cd51f572df233" translate="yes" xml:space="preserve">
          <source>Note that the &amp;lsquo;</source>
          <target state="translated">'</target>
        </trans-unit>
        <trans-unit id="a6469f422f7ec9a279d6ed4b82f424847330e523" translate="yes" xml:space="preserve">
          <source>Note that the argument &lt;code&gt;(assq 'handler list)&lt;/code&gt; appears in the expansion.</source>
          <target state="translated">Note that the argument &lt;code&gt;(assq 'handler list)&lt;/code&gt; appears in the expansion.</target>
        </trans-unit>
        <trans-unit id="4368eeb627f6bc57851f8ed6589cb35a499c91b1" translate="yes" xml:space="preserve">
          <source>Note that the arguments can be the results of other function calls, as in this example:</source>
          <target state="translated">この例のように、引数は他の関数呼び出しの結果である可能性があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="60b6c61854c649097ce19157cbb7f0ddb8c5eefa" translate="yes" xml:space="preserve">
          <source>Note that the docstrings mention &lt;var&gt;args&lt;/var&gt; (in this case, only one: &lt;code&gt;n&lt;/code&gt;) in the usual way, and also mention &lt;code&gt;EXPVAL&lt;/code&gt; by convention. The first rewrite (i.e., &lt;var&gt;body&lt;/var&gt; for &lt;code&gt;less-than&lt;/code&gt;) uses one core pattern: &lt;code&gt;pred&lt;/code&gt;. The second uses two core patterns: &lt;code&gt;and&lt;/code&gt; and &lt;code&gt;pred&lt;/code&gt;, as well as the newly-defined pattern &lt;code&gt;less-than&lt;/code&gt;. Both use a single backquote construct (see &lt;a href=&quot;backquote#Backquote&quot;&gt;Backquote&lt;/a&gt;).</source>
          <target state="translated">Note that the docstrings mention &lt;var&gt;args&lt;/var&gt; (in this case, only one: &lt;code&gt;n&lt;/code&gt; ) in the usual way, and also mention &lt;code&gt;EXPVAL&lt;/code&gt; by convention. The first rewrite (i.e., &lt;var&gt;body&lt;/var&gt; for &lt;code&gt;less-than&lt;/code&gt; ) uses one core pattern: &lt;code&gt;pred&lt;/code&gt; . The second uses two core patterns: &lt;code&gt;and&lt;/code&gt; and &lt;code&gt;pred&lt;/code&gt; , as well as the newly-defined pattern &lt;code&gt;less-than&lt;/code&gt; . Both use a single backquote construct (see &lt;a href=&quot;backquote#Backquote&quot;&gt;Backquote&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="c2edb0886e867e4ca5989b4ab0140428caf42280" translate="yes" xml:space="preserve">
          <source>Note that the documentation strings for Emacs are not the same thing as the Emacs manual. Manuals have their own source files, written in the Texinfo language; documentation strings are specified in the definitions of the functions and variables they apply to. A collection of documentation strings is not sufficient as a manual because a good manual is not organized in that fashion; it is organized in terms of topics of discussion.</source>
          <target state="translated">Emacsのドキュメント文字列は、Emacsのマニュアルと同じものではないことに注意してください。マニュアルには、Texinfo言語で書かれた独自のソースファイルがあります。優れたマニュアルは、そのように整理されているのではなく、議論のトピックで整理されているので、ドキュメント文字列の集まりだけではマニュアルとしては十分ではありません。</target>
        </trans-unit>
        <trans-unit id="fca742cf8fd5cf459a0d4b4751312094297df69c" translate="yes" xml:space="preserve">
          <source>Note that the effect of restacking will only hold as long as neither of the involved frames is iconified or made invisible. You can use the &lt;code&gt;z-group&lt;/code&gt; (see &lt;a href=&quot;position-parameters#Position-Parameters&quot;&gt;Position Parameters&lt;/a&gt;) frame parameter to add a frame to a group of frames permanently shown above or below other frames. As long as a frame belongs to one of these groups, restacking it will only affect its relative stacking position within that group. The effect of restacking frames belonging to different z-groups is undefined. You can list frames in their current stacking order with the function &lt;code&gt;frame-list-z-order&lt;/code&gt; (see &lt;a href=&quot;finding-all-frames#Finding-All-Frames&quot;&gt;Finding All Frames&lt;/a&gt;).</source>
          <target state="translated">Note that the effect of restacking will only hold as long as neither of the involved frames is iconified or made invisible. You can use the &lt;code&gt;z-group&lt;/code&gt; (see &lt;a href=&quot;position-parameters#Position-Parameters&quot;&gt;Position Parameters&lt;/a&gt;) frame parameter to add a frame to a group of frames permanently shown above or below other frames. As long as a frame belongs to one of these groups, restacking it will only affect its relative stacking position within that group. The effect of restacking frames belonging to different z-groups is undefined. You can list frames in their current stacking order with the function &lt;code&gt;frame-list-z-order&lt;/code&gt; (see &lt;a href=&quot;finding-all-frames#Finding-All-Frames&quot;&gt;Finding All Frames&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="2582678e0a51538e9f647014c2a05c8ea4765da3" translate="yes" xml:space="preserve">
          <source>Note that the first &lt;var&gt;form&lt;/var&gt; is evaluated, then the first &lt;var&gt;symbol&lt;/var&gt; is set, then the second &lt;var&gt;form&lt;/var&gt; is evaluated, then the second &lt;var&gt;symbol&lt;/var&gt; is set, and so on:</source>
          <target state="translated">Note that the first &lt;var&gt;form&lt;/var&gt; is evaluated, then the first &lt;var&gt;symbol&lt;/var&gt; is set, then the second &lt;var&gt;form&lt;/var&gt; is evaluated, then the second &lt;var&gt;symbol&lt;/var&gt; is set, and so on:</target>
        </trans-unit>
        <trans-unit id="9173ba72010925230c9678e4a9c448ec671403eb" translate="yes" xml:space="preserve">
          <source>Note that the first read skips a space. Reading skips any amount of whitespace preceding the significant text.</source>
          <target state="translated">最初の読み取りでは空白をスキップすることに注意してください。読み上げでは、重要なテキストの前にある空白はすべてスキップされます。</target>
        </trans-unit>
        <trans-unit id="5b4a82bbf9da4eb3b066c08dd5991f582e95b2ff" translate="yes" xml:space="preserve">
          <source>Note that the function specified by this option is called only if the specified frame contains just one live window and there is at least one other frame on the same terminal.</source>
          <target state="translated">このオプションで指定された関数は、指定されたフレームにライブウィンドウが1つだけ含まれていて、同じ端末上に他のフレームが少なくとも1つある場合にのみ呼び出されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="43a4f6baecfda8409de3b10f1d269557bab73567" translate="yes" xml:space="preserve">
          <source>Note that the handling of &lt;code&gt;command-switch-alist&lt;/code&gt; doesn&amp;rsquo;t treat equals signs in &lt;var&gt;option&lt;/var&gt; specially. That is, if there&amp;rsquo;s an option like &lt;code&gt;--name=value&lt;/code&gt; on the command line, then only a &lt;code&gt;command-switch-alist&lt;/code&gt; member whose &lt;code&gt;car&lt;/code&gt; is literally &lt;code&gt;--name=value&lt;/code&gt; will match this option. If you want to parse such options, you need to use &lt;code&gt;command-line-functions&lt;/code&gt; instead (see below).</source>
          <target state="translated">Note that the handling of &lt;code&gt;command-switch-alist&lt;/code&gt; doesn&amp;rsquo;t treat equals signs in &lt;var&gt;option&lt;/var&gt; specially. That is, if there&amp;rsquo;s an option like &lt;code&gt;--name=value&lt;/code&gt; on the command line, then only a &lt;code&gt;command-switch-alist&lt;/code&gt; member whose &lt;code&gt;car&lt;/code&gt; is literally &lt;code&gt;--name=value&lt;/code&gt; will match this option. If you want to parse such options, you need to use &lt;code&gt;command-line-functions&lt;/code&gt; instead (see below).</target>
        </trans-unit>
        <trans-unit id="10d410d8d2209e47d081d1091cbeb510cad74888" translate="yes" xml:space="preserve">
          <source>Note that the meaning of &lt;code&gt;nil&lt;/code&gt; differs slightly from that of the &lt;var&gt;all-frames&lt;/var&gt; argument to &lt;code&gt;next-window&lt;/code&gt; (see &lt;a href=&quot;cyclic-window-ordering#Cyclic-Window-Ordering&quot;&gt;Cyclic Window Ordering&lt;/a&gt;).</source>
          <target state="translated">Note that the meaning of &lt;code&gt;nil&lt;/code&gt; differs slightly from that of the &lt;var&gt;all-frames&lt;/var&gt; argument to &lt;code&gt;next-window&lt;/code&gt; (see &lt;a href=&quot;cyclic-window-ordering#Cyclic-Window-Ordering&quot;&gt;Cyclic Window Ordering&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="46305bb5f2b4deb49120db52fdc405524ee1ca0b" translate="yes" xml:space="preserve">
          <source>Note that the minibuffer window used by a frame need not be part of that frame&amp;mdash;a frame that has no minibuffer of its own necessarily uses some other frame&amp;rsquo;s minibuffer window. The minibuffer window of a minibuffer-less frame can be changed by setting that frame&amp;rsquo;s &lt;code&gt;minibuffer&lt;/code&gt; frame parameter (see &lt;a href=&quot;buffer-parameters#Buffer-Parameters&quot;&gt;Buffer Parameters&lt;/a&gt;).</source>
          <target state="translated">Note that the minibuffer window used by a frame need not be part of that frame&amp;mdash;a frame that has no minibuffer of its own necessarily uses some other frame&amp;rsquo;s minibuffer window. The minibuffer window of a minibuffer-less frame can be changed by setting that frame&amp;rsquo;s &lt;code&gt;minibuffer&lt;/code&gt; frame parameter (see &lt;a href=&quot;buffer-parameters#Buffer-Parameters&quot;&gt;Buffer Parameters&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="29787cca83afbad5cb5731b6b829bddd7a5a6e3f" translate="yes" xml:space="preserve">
          <source>Note that the open and close parentheses remain in the list. The Lisp reader encountered the open parenthesis, decided that it ended the input, and unread it. Another attempt to read from the stream at this point would read &amp;lsquo;</source>
          <target state="translated">Note that the open and close parentheses remain in the list. The Lisp reader encountered the open parenthesis, decided that it ended the input, and unread it. Another attempt to read from the stream at this point would read &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="59f13de0f3c2b965927d50d1e0831d83e4c0b4e3" translate="yes" xml:space="preserve">
          <source>Note that the option &lt;code&gt;fit-window-to-buffer-horizontally&lt;/code&gt; must have a non-&lt;code&gt;nil&lt;/code&gt; value in order to allow horizontal adjustment of windows. Entries are also added that ask for preserving the height of side windows at the top and bottom of the frame and the width of side windows at the left or right of the frame. To assure that side windows retain their respective sizes when maximizing the frame, the variable &lt;code&gt;window-resize-pixelwise&lt;/code&gt; is set to a non-&lt;code&gt;nil&lt;/code&gt; value. See &lt;a href=&quot;resizing-windows#Resizing-Windows&quot;&gt;Resizing Windows&lt;/a&gt;.</source>
          <target state="translated">Note that the option &lt;code&gt;fit-window-to-buffer-horizontally&lt;/code&gt; must have a non- &lt;code&gt;nil&lt;/code&gt; value in order to allow horizontal adjustment of windows. Entries are also added that ask for preserving the height of side windows at the top and bottom of the frame and the width of side windows at the left or right of the frame. To assure that side windows retain their respective sizes when maximizing the frame, the variable &lt;code&gt;window-resize-pixelwise&lt;/code&gt; is set to a non- &lt;code&gt;nil&lt;/code&gt; value. See &lt;a href=&quot;resizing-windows#Resizing-Windows&quot;&gt;Resizing Windows&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="9a70f1cf74ad105152fa3a136ffd4bd441d193a1" translate="yes" xml:space="preserve">
          <source>Note that the second argument is always the list of &lt;em&gt;all&lt;/em&gt; action alist entries specified by the sources named above. Hence, the first element of that list is the first action alist entry specified by &lt;code&gt;display-buffer-overriding-action&lt;/code&gt;, if any. Its last element is the last alist entry of &lt;code&gt;display-buffer-base-action&lt;/code&gt;, if any (the action alist of &lt;code&gt;display-buffer-fallback-action&lt;/code&gt; is empty).</source>
          <target state="translated">Note that the second argument is always the list of &lt;em&gt;all&lt;/em&gt; action alist entries specified by the sources named above. Hence, the first element of that list is the first action alist entry specified by &lt;code&gt;display-buffer-overriding-action&lt;/code&gt; , if any. Its last element is the last alist entry of &lt;code&gt;display-buffer-base-action&lt;/code&gt; , if any (the action alist of &lt;code&gt;display-buffer-fallback-action&lt;/code&gt; is empty).</target>
        </trans-unit>
        <trans-unit id="074011f5871b6c0968cba6e5251ad570a7913126" translate="yes" xml:space="preserve">
          <source>Note that the term &amp;ldquo;command&amp;rdquo;, in this context, refers to an interactively callable function (or function-like object), or a keyboard macro. It does not refer to the key sequence used to invoke a command (see &lt;a href=&quot;keymaps#Keymaps&quot;&gt;Keymaps&lt;/a&gt;).</source>
          <target state="translated">Note that the term &amp;ldquo;command&amp;rdquo;, in this context, refers to an interactively callable function (or function-like object), or a keyboard macro. It does not refer to the key sequence used to invoke a command (see &lt;a href=&quot;keymaps#Keymaps&quot;&gt;Keymaps&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="2b48ed316676b2a77757a76ff8c81c0c3beb1931" translate="yes" xml:space="preserve">
          <source>Note that the time returned by this function excludes the time Emacs was not using the processor, and if the Emacs process has several threads, the returned value is the sum of the processor times used up by all Emacs threads.</source>
          <target state="translated">この関数が返す時間には、Emacs がプロセッサを使用していない時間は含まれていないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="87ffd6d39e1afd8a7828b54719c1a46abb2defc0" translate="yes" xml:space="preserve">
          <source>Note that the user-level incremental search feature handles case distinctions differently. When the search string contains only lower case letters, the search ignores case, but when the search string contains one or more upper case letters, the search becomes case-sensitive. But this has nothing to do with the searching functions used in Lisp code. See &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Incremental-Search.html#Incremental-Search&quot;&gt;Incremental Search&lt;/a&gt; in</source>
          <target state="translated">Note that the user-level incremental search feature handles case distinctions differently. When the search string contains only lower case letters, the search ignores case, but when the search string contains one or more upper case letters, the search becomes case-sensitive. But this has nothing to do with the searching functions used in Lisp code. See &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Incremental-Search.html#Incremental-Search&quot;&gt;Incremental Search&lt;/a&gt; in</target>
        </trans-unit>
        <trans-unit id="f06cef1accb1f0afe0d8f8b378512094228d0996" translate="yes" xml:space="preserve">
          <source>Note that the value of the &lt;code&gt;window-atom&lt;/code&gt; parameter does not really matter as long as it is non-&lt;code&gt;nil&lt;/code&gt;. The values assigned by &lt;code&gt;display-buffer-in-atom-window&lt;/code&gt; just allow for easy retrieval of the original and the new window after that function has been applied. Note also that the &lt;code&gt;window-atom&lt;/code&gt; parameter is the only window parameter assigned by &lt;code&gt;display-buffer-in-atom-window&lt;/code&gt;. Further parameters have to be set by the application explicitly via a &lt;code&gt;window-parameters&lt;/code&gt; entry in &lt;var&gt;alist&lt;/var&gt;.</source>
          <target state="translated">Note that the value of the &lt;code&gt;window-atom&lt;/code&gt; parameter does not really matter as long as it is non- &lt;code&gt;nil&lt;/code&gt; . The values assigned by &lt;code&gt;display-buffer-in-atom-window&lt;/code&gt; just allow for easy retrieval of the original and the new window after that function has been applied. Note also that the &lt;code&gt;window-atom&lt;/code&gt; parameter is the only window parameter assigned by &lt;code&gt;display-buffer-in-atom-window&lt;/code&gt; . Further parameters have to be set by the application explicitly via a &lt;code&gt;window-parameters&lt;/code&gt; entry in &lt;var&gt;alist&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="3fb6d667bc03880b5ccfb18ddea5d35e1c03ca93" translate="yes" xml:space="preserve">
          <source>Note that the value of this variable is ignored when &lt;code&gt;make-process&lt;/code&gt; is called with a non-&lt;code&gt;nil&lt;/code&gt; value of the &lt;code&gt;:stderr&lt;/code&gt; parameter; in that case, Emacs will communicate with the process using pipes. It is also ignored if ptys are unavailable (MS-Windows).</source>
          <target state="translated">Note that the value of this variable is ignored when &lt;code&gt;make-process&lt;/code&gt; is called with a non- &lt;code&gt;nil&lt;/code&gt; value of the &lt;code&gt;:stderr&lt;/code&gt; parameter; in that case, Emacs will communicate with the process using pipes. It is also ignored if ptys are unavailable (MS-Windows).</target>
        </trans-unit>
        <trans-unit id="4a97b13e6f37fae9d240fea05dd6e0d29f53c80f" translate="yes" xml:space="preserve">
          <source>Note that the values of the above two variables take effect at display time, so let-binding them around code which produces echo-area messages will not work. If you want to prevent resizing of minibuffer windows when displaying long messages, bind the &lt;code&gt;message-truncate-lines&lt;/code&gt; variable instead (see &lt;a href=&quot;echo-area-customization#Echo-Area-Customization&quot;&gt;Echo Area Customization&lt;/a&gt;).</source>
          <target state="translated">Note that the values of the above two variables take effect at display time, so let-binding them around code which produces echo-area messages will not work. If you want to prevent resizing of minibuffer windows when displaying long messages, bind the &lt;code&gt;message-truncate-lines&lt;/code&gt; variable instead (see &lt;a href=&quot;echo-area-customization#Echo-Area-Customization&quot;&gt;Echo Area Customization&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="cc4faf74f63a3bd8358aed546107967e25cd284b" translate="yes" xml:space="preserve">
          <source>Note that there is no conflict between the variable named &lt;code&gt;list&lt;/code&gt; used in this example and the function named &lt;code&gt;list&lt;/code&gt; described below; any symbol can serve both purposes.</source>
          <target state="translated">Note that there is no conflict between the variable named &lt;code&gt;list&lt;/code&gt; used in this example and the function named &lt;code&gt;list&lt;/code&gt; described below; any symbol can serve both purposes.</target>
        </trans-unit>
        <trans-unit id="f915f57254052f46a7173c363fa3e8ad81bbb90f" translate="yes" xml:space="preserve">
          <source>Note that these are the actual outer edges of the window, including any header line, mode line, scroll bar, fringes, window divider and display margins. On a text terminal, if the window has a neighbor on its right, its right edge includes the separator line between the window and its neighbor.</source>
          <target state="translated">これらは、ヘッダライン、モードライン、スクロールバー、フリンジ、ウィンドウの仕切り、表示マージンを含む、ウィンドウの実際の外縁であることに注意してください。テキスト端末では、ウィンドウの右側に隣り合うウィンドウがある場合、その右端にはウィンドウと隣り合うウィンドウの間の区切り線が含まれます。</target>
        </trans-unit>
        <trans-unit id="3e29252ca0099b32f668a2f0acad91a2370dc400" translate="yes" xml:space="preserve">
          <source>Note that these meanings differ slightly from those of the &lt;var&gt;all-frames&lt;/var&gt; argument to &lt;code&gt;next-window&lt;/code&gt; (see &lt;a href=&quot;cyclic-window-ordering#Cyclic-Window-Ordering&quot;&gt;Cyclic Window Ordering&lt;/a&gt;). This function may be changed in a future version of Emacs to eliminate this discrepancy.</source>
          <target state="translated">Note that these meanings differ slightly from those of the &lt;var&gt;all-frames&lt;/var&gt; argument to &lt;code&gt;next-window&lt;/code&gt; (see &lt;a href=&quot;cyclic-window-ordering#Cyclic-Window-Ordering&quot;&gt;Cyclic Window Ordering&lt;/a&gt;). This function may be changed in a future version of Emacs to eliminate this discrepancy.</target>
        </trans-unit>
        <trans-unit id="aeecc111a3fa90e2f602220a93eb501df7032c35" translate="yes" xml:space="preserve">
          <source>Note that these two map variables do affect the execution of key sequences entered using the menu bar, even if they do not affect the menu bar display. So if a menu bar key sequence comes in, you should clear the variables before looking up and executing that key sequence. Modes that use the variables would typically do this anyway; normally they respond to events that they do not handle by &amp;ldquo;unreading&amp;rdquo; them and exiting.</source>
          <target state="translated">Note that these two map variables do affect the execution of key sequences entered using the menu bar, even if they do not affect the menu bar display. So if a menu bar key sequence comes in, you should clear the variables before looking up and executing that key sequence. Modes that use the variables would typically do this anyway; normally they respond to events that they do not handle by &amp;ldquo;unreading&amp;rdquo; them and exiting.</target>
        </trans-unit>
        <trans-unit id="e346e2d0ff56f6335dc3e655ea9c25b7e0e40014" translate="yes" xml:space="preserve">
          <source>Note that this argument does not have the same meaning as in other functions which scan all live windows (see &lt;a href=&quot;cyclic-window-ordering#Cyclic-Window-Ordering&quot;&gt;Cyclic Window Ordering&lt;/a&gt;). Specifically, the meanings of &lt;code&gt;t&lt;/code&gt; and &lt;code&gt;nil&lt;/code&gt; here are the opposite of what they are in those other functions.</source>
          <target state="translated">Note that this argument does not have the same meaning as in other functions which scan all live windows (see &lt;a href=&quot;cyclic-window-ordering#Cyclic-Window-Ordering&quot;&gt;Cyclic Window Ordering&lt;/a&gt;). Specifically, the meanings of &lt;code&gt;t&lt;/code&gt; and &lt;code&gt;nil&lt;/code&gt; here are the opposite of what they are in those other functions.</target>
        </trans-unit>
        <trans-unit id="894d286209e758f0c8e4e2de8dc595b49367a3dd" translate="yes" xml:space="preserve">
          <source>Note that this does not tell you whether the display you are using really supports that color. When using X, you can ask for any defined color on any kind of display, and you will get some result&amp;mdash;typically, the closest it can do. To determine whether a frame can really display a certain color, use &lt;code&gt;color-supported-p&lt;/code&gt; (see below).</source>
          <target state="translated">Note that this does not tell you whether the display you are using really supports that color. When using X, you can ask for any defined color on any kind of display, and you will get some result&amp;mdash;typically, the closest it can do. To determine whether a frame can really display a certain color, use &lt;code&gt;color-supported-p&lt;/code&gt; (see below).</target>
        </trans-unit>
        <trans-unit id="9c87143dafdf2015bda6be19171c454f6308b5a5" translate="yes" xml:space="preserve">
          <source>Note that this function disregards the minibuffer window (see &lt;a href=&quot;minibuffer-windows#Minibuffer-Windows&quot;&gt;Minibuffer Windows&lt;/a&gt;). Hence, with &lt;var&gt;side&lt;/var&gt; equal to &lt;code&gt;bottom&lt;/code&gt; it may return &lt;code&gt;t&lt;/code&gt; also when the minibuffer window appears right below &lt;var&gt;window&lt;/var&gt;.</source>
          <target state="translated">Note that this function disregards the minibuffer window (see &lt;a href=&quot;minibuffer-windows#Minibuffer-Windows&quot;&gt;Minibuffer Windows&lt;/a&gt;). Hence, with &lt;var&gt;side&lt;/var&gt; equal to &lt;code&gt;bottom&lt;/code&gt; it may return &lt;code&gt;t&lt;/code&gt; also when the minibuffer window appears right below &lt;var&gt;window&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="3c74267c9a9889a0868c5053a41c16d0ecce8ab6" translate="yes" xml:space="preserve">
          <source>Note that this function doesn&amp;rsquo;t account for the visual width of characters on display, like the number of visual columns taken by a tab character or an image. If you need the coordinates in canonical character units, use &lt;code&gt;posn-col-row&lt;/code&gt; instead.</source>
          <target state="translated">Note that this function doesn&amp;rsquo;t account for the visual width of characters on display, like the number of visual columns taken by a tab character or an image. If you need the coordinates in canonical character units, use &lt;code&gt;posn-col-row&lt;/code&gt; instead.</target>
        </trans-unit>
        <trans-unit id="998f1206a8bc180e46c0f799b8b5a670212afaad" translate="yes" xml:space="preserve">
          <source>Note that this function has an ambiguity if the found element is identical to &lt;var&gt;default&lt;/var&gt;, as in that case it cannot be known whether an element was found or not.</source>
          <target state="translated">Note that this function has an ambiguity if the found element is identical to &lt;var&gt;default&lt;/var&gt; , as in that case it cannot be known whether an element was found or not.</target>
        </trans-unit>
        <trans-unit id="6df96098672080fc58058b91a33fcbca6a21515b" translate="yes" xml:space="preserve">
          <source>Note that this function has to retrieve the dimensions of each line of &lt;var&gt;window&lt;/var&gt;&amp;rsquo;s glyph matrix via &lt;code&gt;window-lines-pixel-dimensions&lt;/code&gt; (see &lt;a href=&quot;size-of-displayed-text#Size-of-Displayed-Text&quot;&gt;Size of Displayed Text&lt;/a&gt;). Hence, this function may also return &lt;code&gt;nil&lt;/code&gt; when the current glyph matrix of &lt;var&gt;window&lt;/var&gt; is not up-to-date.</source>
          <target state="translated">Note that this function has to retrieve the dimensions of each line of &lt;var&gt;window&lt;/var&gt; &amp;rsquo;s glyph matrix via &lt;code&gt;window-lines-pixel-dimensions&lt;/code&gt; (see &lt;a href=&quot;size-of-displayed-text#Size-of-Displayed-Text&quot;&gt;Size of Displayed Text&lt;/a&gt;). Hence, this function may also return &lt;code&gt;nil&lt;/code&gt; when the current glyph matrix of &lt;var&gt;window&lt;/var&gt; is not up-to-date.</target>
        </trans-unit>
        <trans-unit id="c5054dbcacc1045ce838f26e3713bfdb492fb165" translate="yes" xml:space="preserve">
          <source>Note that this function might return inaccurate results in some situations, such as the following:</source>
          <target state="translated">この関数は、以下のような状況では不正確な結果を返す可能性があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="28e1bb3bf31dd9667c950f330d082131ff2cc74a" translate="yes" xml:space="preserve">
          <source>Note that this function only changes the buffer contents; it does not alter &lt;code&gt;tabulated-list-entries&lt;/code&gt;.</source>
          <target state="translated">この関数はバッファの内容のみを変更することに注意してください。 &lt;code&gt;tabulated-list-entries&lt;/code&gt; は変更されません。</target>
        </trans-unit>
        <trans-unit id="6f915802707d0be2b41295f510d267fae8df11a6" translate="yes" xml:space="preserve">
          <source>Note that this function returns only IPv4 information.</source>
          <target state="translated">なお、この関数はIPv4の情報のみを返します。</target>
        </trans-unit>
        <trans-unit id="20b5e54b67d99f5fc2e693cae10cc92ff59c28aa" translate="yes" xml:space="preserve">
          <source>Note that this incorporates the submenu keymap, which is the value of the variable &lt;code&gt;menu-bar-replace-menu&lt;/code&gt;, rather than the symbol &lt;code&gt;menu-bar-replace-menu&lt;/code&gt; itself. Using that symbol in the parent menu item would be meaningless because &lt;code&gt;menu-bar-replace-menu&lt;/code&gt; is not a command.</source>
          <target state="translated">これには、シンボル &lt;code&gt;menu-bar-replace-menu&lt;/code&gt; 自体ではなく、変数 &lt;code&gt;menu-bar-replace-menu&lt;/code&gt; の値であるサブメニューキーマップが組み込まれていることに注意してください。 &lt;code&gt;menu-bar-replace-menu&lt;/code&gt; はコマンドではないため、親メニュー項目でその記号を使用しても意味がありません。</target>
        </trans-unit>
        <trans-unit id="aa1d2cd987fde9747e5aba9be8d033f0786b741e" translate="yes" xml:space="preserve">
          <source>Note that this option does not distinguish &amp;ldquo;sloppy&amp;rdquo; focus (where the frame that previously had focus retains focus as long as the mouse pointer does not move into another window manager window) from &amp;ldquo;strict&amp;rdquo; focus (where a frame immediately loses focus when it&amp;rsquo;s left by the mouse pointer). Neither does it recognize whether your window manager supports delayed focusing or auto-raising where you can explicitly specify the time until a new frame gets focus or is auto-raised.</source>
          <target state="translated">このオプションでは、「ずさんな」フォーカス（以前にフォーカスがあったフレームが別のウィンドウマネージャーウィンドウに移動しない限りフォーカスを保持する）と「厳密な」フォーカス（フレームがフォーカスを失うとすぐにフォーカスが失われる）を区別しないことに注意してください。マウスポインタによって残されます）。また、ウィンドウマネージャーが遅延フォーカスまたは自動レイズをサポートしているかどうかも認識しません。この場合、新しいフレームがフォーカスを取得するか、自動レイズされるまでの時間を明示的に指定できます。</target>
        </trans-unit>
        <trans-unit id="a7ad66f5d269e6734f06cb2f3c0014bbfb55b77d" translate="yes" xml:space="preserve">
          <source>Note that this translation is the first thing that happens to a character after it is read from the terminal. Record-keeping features such as &lt;code&gt;recent-keys&lt;/code&gt; and dribble files record the characters after translation.</source>
          <target state="translated">この変換は、端末から読み取られた後、文字に最初に発生することであることに注意してください。 &lt;code&gt;recent-keys&lt;/code&gt; やドリブルファイルなどの記録管理機能は、翻訳後に文字を記録します。</target>
        </trans-unit>
        <trans-unit id="8b01ecccbe829efd57fc886cd453e999a2cf9884" translate="yes" xml:space="preserve">
          <source>Note that this variable applies only to events that really come from the keyboard, and has no effect on mouse events or any other events.</source>
          <target state="translated">この変数は、実際にキーボードから来るイベントにのみ適用され、マウスイベントやその他のイベントには影響しないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="879e8333c0e4e7f970d5416ebcdb0f1f832c6b93" translate="yes" xml:space="preserve">
          <source>Note that unlike &lt;code&gt;reverse&lt;/code&gt;, this function doesn&amp;rsquo;t work with strings. Although you can alter string data by using &lt;code&gt;aset&lt;/code&gt;, it is strongly encouraged to treat strings as immutable even when they are mutable. See &lt;a href=&quot;mutability#Mutability&quot;&gt;Mutability&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;reverse&lt;/code&gt; とは異なり、この関数は文字列では機能しないことに注意してください。 &lt;code&gt;aset&lt;/code&gt; を使用して文字列データを変更できますが、文字列が可変であっても、文字列を不変として扱うことを強くお勧めします。&lt;a href=&quot;mutability#Mutability&quot;&gt;可変性を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="95e0f840e124ea1d4b479e3c1de97bffda6d36fe" translate="yes" xml:space="preserve">
          <source>Note that unlike dynamic variables which are tied to the symbol object itself, the relationship between lexical variables and symbols is only present in the interpreter (or compiler). Therefore, functions which take a symbol argument (like &lt;code&gt;symbol-value&lt;/code&gt;, &lt;code&gt;boundp&lt;/code&gt;, and &lt;code&gt;set&lt;/code&gt;) can only retrieve or modify a variable&amp;rsquo;s dynamic binding (i.e., the contents of its symbol&amp;rsquo;s value cell).</source>
          <target state="translated">シンボルオブジェクト自体に関連付けられている動的変数とは異なり、字句変数とシンボルの関係は、インタープリター（またはコンパイラー）にのみ存在することに注意してください。したがって、シンボル引数をとる関数（ &lt;code&gt;symbol-value&lt;/code&gt; 、 &lt;code&gt;boundp&lt;/code&gt; 、 &lt;code&gt;set&lt;/code&gt; など）は、変数の動的バインディング（つまり、シンボルの値セルの内容）のみを取得または変更できます。</target>
        </trans-unit>
        <trans-unit id="b42ea23442a5852b3e3945f946840be547f84efc" translate="yes" xml:space="preserve">
          <source>Note that using &lt;code&gt;mode-line&lt;/code&gt;, &lt;code&gt;mode-line-inactive&lt;/code&gt;, or &lt;code&gt;header-line&lt;/code&gt; as &lt;var&gt;face&lt;/var&gt; will actually redisplay the mode line or the header line, respectively, using the current definitions of the corresponding face, in addition to returning the formatted string. (Other faces do not cause redisplay.)</source>
          <target state="translated">&lt;var&gt;face&lt;/var&gt; として &lt;code&gt;mode-line&lt;/code&gt; 、 &lt;code&gt;mode-line-inactive&lt;/code&gt; 、または &lt;code&gt;header-line&lt;/code&gt; を使用すると、フォーマットされた文字列を返すだけでなく、対応する面の現在の定義を使用して、実際にはそれぞれモード行またはヘッダー行が再表示されることに注意してください。（他の面は再表示されません。）</target>
        </trans-unit>
        <trans-unit id="da7485093f3e51570042141c7d27e976a6d49566" translate="yes" xml:space="preserve">
          <source>Note that versions of Windows before W2K support only &lt;code&gt;:icon&lt;/code&gt; and &lt;code&gt;:tip&lt;/code&gt;. The other parameters can be passed, but they will be ignored on those old systems.</source>
          <target state="translated">W2Kより前のバージョンのWindowsは、 &lt;code&gt;:icon&lt;/code&gt; と &lt;code&gt;:tip&lt;/code&gt; のみをサポートしていることに注意してください。他のパラメーターは渡すことができますが、それらの古いシステムでは無視されます。</target>
        </trans-unit>
        <trans-unit id="32213ce9630018bd32281e740807f4edfc3f4d49" translate="yes" xml:space="preserve">
          <source>Note that void is not the same as &lt;code&gt;nil&lt;/code&gt; or the symbol &lt;code&gt;void&lt;/code&gt;. The symbols &lt;code&gt;nil&lt;/code&gt; and &lt;code&gt;void&lt;/code&gt; are Lisp objects, and can be stored into a function cell just as any other object can be (and they can be valid functions if you define them in turn with &lt;code&gt;defun&lt;/code&gt;). A void function cell contains no object whatsoever.</source>
          <target state="translated">voidは &lt;code&gt;nil&lt;/code&gt; または記号 &lt;code&gt;void&lt;/code&gt; と同じではないことに注意してください。記号 &lt;code&gt;nil&lt;/code&gt; と &lt;code&gt;void&lt;/code&gt; はLispオブジェクトであり、他のオブジェクトと同じように関数セルに格納できます（また、 &lt;code&gt;defun&lt;/code&gt; で順番に定義すると、有効な関数になります）。void関数セルにはオブジェクトがまったく含まれていません。</target>
        </trans-unit>
        <trans-unit id="c55ed2cdfec3c287af375d8415ca35326ee5ad2a" translate="yes" xml:space="preserve">
          <source>Note that we didn&amp;rsquo;t care to specify a &lt;code&gt;reusable-frames&lt;/code&gt; action alist entry in our specification of &lt;code&gt;display-buffer-alist&lt;/code&gt;. &lt;code&gt;display-buffer&lt;/code&gt; always takes the first one it finds&amp;mdash;in our case the one specified by &lt;code&gt;display-buffer-base-action&lt;/code&gt;. If we wanted to use a different specification, for example, to exclude iconified frames showing</source>
          <target state="translated">&lt;code&gt;display-buffer-alist&lt;/code&gt; の仕様では、 &lt;code&gt;reusable-frames&lt;/code&gt; アクションのリストエントリを指定する必要がないことに注意してください。 &lt;code&gt;display-buffer&lt;/code&gt; は常に、最初に見つかったもの、この場合は &lt;code&gt;display-buffer-base-action&lt;/code&gt; で指定されたものを取得します。たとえば、別の仕様を使用して、表示されているアイコン化されたフレームを除外する場合</target>
        </trans-unit>
        <trans-unit id="695d219c90e242ce9ab38b41dd5442dca50f0c95" translate="yes" xml:space="preserve">
          <source>Note that we do not quote the &lt;code&gt;lambda&lt;/code&gt; form.</source>
          <target state="translated">&lt;code&gt;lambda&lt;/code&gt; 形式は引用しないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="27279efa933392e2845851f38f8ebb1579dfb1cb" translate="yes" xml:space="preserve">
          <source>Note that we never modify the data in each node, which is fixed when the ewoc is created to be either &lt;code&gt;nil&lt;/code&gt; or an index into the vector &lt;code&gt;colorcomp-data&lt;/code&gt;, the actual color components.</source>
          <target state="translated">各ノードのデータを変更しないことに注意してください。これは、ewocが &lt;code&gt;nil&lt;/code&gt; または実際の色成分であるベクトル &lt;code&gt;colorcomp-data&lt;/code&gt; へのインデックスとして作成されるときに修正されます。</target>
        </trans-unit>
        <trans-unit id="e11f9f08db090622f4787f9d406b1aa205d88060" translate="yes" xml:space="preserve">
          <source>Note that when a frame is not large enough to accommodate a change of any of the parameters listed above, Emacs may try to enlarge the frame even if this option is non-&lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">フレームが上記のパラメータのいずれかの変更に対応するのに十分な大きさでない場合、このオプションが &lt;code&gt;nil&lt;/code&gt; でない場合でも、Emacsはフレームを拡大しようとする場合があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="93e5de1e980991d9fdbf3fb24041ced46918aafe" translate="yes" xml:space="preserve">
          <source>Note that when a frame&amp;rsquo;s pixel size is not a multiple of its character size, at least one window may get resized pixelwise even if this option is &lt;code&gt;nil&lt;/code&gt;. The default value is &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">フレームのピクセルサイズがその文字サイズの倍数でない場合、このオプションが &lt;code&gt;nil&lt;/code&gt; であっても、少なくとも1つのウィンドウがピクセル単位でサイズ変更される可能性があることに注意してください。デフォルト値は &lt;code&gt;nil&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="0488512718b2693ed44b51fbae789514d6f0a966" translate="yes" xml:space="preserve">
          <source>Note that when evaluating under lexical binding the result is a closure object (see &lt;a href=&quot;closures#Closures&quot;&gt;Closures&lt;/a&gt;).</source>
          <target state="translated">字句バインディングの下で​​評価する場合、結果はクロージャオブジェクトであることに注意してください（&lt;a href=&quot;closures#Closures&quot;&gt;クロージャを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="2b2dcc95bd27b61f320e52671bde8d565c5541e0" translate="yes" xml:space="preserve">
          <source>Note that window change functions provide no information about which windows have been deleted since the last time they were run. If necessary, applications should remember any window showing a specific buffer in a local variable of that buffer and update it in a function run by the default values of any of the hooks that are run when a window buffer change was detected.</source>
          <target state="translated">ウィンドウ変更関数は、最後に実行されてからどのウィンドウが削除されたかについての情報を提供しないことに注意してください。必要であれば、アプリケーションは、特定のバッファを表示している任意のウィンドウをそのバッファのローカル変数に記憶し、ウィンドウバッファの変更が検出されたときに実行される任意のフックのデフォルト値によって実行される関数でそれを更新する必要があります。</target>
        </trans-unit>
        <trans-unit id="b1db01bbe0bf3270ff266bbfef6dae125e24f80a" translate="yes" xml:space="preserve">
          <source>Note that with multiple monitors, the origin of the display does not necessarily coincide with the top-left corner of the entire usable display area of the terminal. Hence the absolute position of a frame can be negative in such an environment even when that frame is completely visible.</source>
          <target state="translated">なお、マルチモニタの場合、表示の原点は必ずしも端末の使用可能な表示領域全体の左上隅と一致しない。そのため、このような環境では、フレームが完全に見えていても、フレームの絶対位置が負になることがある。</target>
        </trans-unit>
        <trans-unit id="c81d4cca0834a0ff81c0a8aba5344f507503f4ac" translate="yes" xml:space="preserve">
          <source>Note that you cannot specify a hash table whose initial contents include objects that have no read syntax, such as buffers and frames. Such objects may be added to the hash table after it is created.</source>
          <target state="translated">バッファやフレームなどの読み取り構文を持たないオブジェクトを初期コンテンツに含むハッシュテーブルを指定することはできないことに注意してください。このようなオブジェクトは、ハッシュテーブルが作成された後に追加される可能性があります。</target>
        </trans-unit>
        <trans-unit id="df97661ee2013a21758ac0f65cab67196b09b407" translate="yes" xml:space="preserve">
          <source>Note that you could implement an equivalent test by using &lt;code&gt;intern&lt;/code&gt; to get an &lt;code&gt;emacs_value&lt;/code&gt; representing &lt;code&gt;nil&lt;/code&gt;, then use &lt;code&gt;eq&lt;/code&gt;, described above, to test for equality. But using this function is more convenient.</source>
          <target state="translated">&lt;code&gt;intern&lt;/code&gt; を使用して &lt;code&gt;nil&lt;/code&gt; を表す &lt;code&gt;emacs_value&lt;/code&gt; を取得し、次に上記の &lt;code&gt;eq&lt;/code&gt; を使用して同等性をテストすることにより、同等のテストを実装できることに注意してください。ただし、この機能を使用する方が便利です。</target>
        </trans-unit>
        <trans-unit id="8085c903afbf6def946357e85a074fc45d960104" translate="yes" xml:space="preserve">
          <source>Note that you may reenter the same Edebug level several times if, for example, an instrumented function is called several times from one command.</source>
          <target state="translated">例えば、インストゥルメントされた関数が1つのコマンドから何度か呼び出された場合、同じEdebugレベルに何度か再入力することができることに注意してください。</target>
        </trans-unit>
        <trans-unit id="9728aac91e0d5d7d3233a093047d1e3cf2f7b5fb" translate="yes" xml:space="preserve">
          <source>Note that, unlike in message-based OO languages, such as C</source>
          <target state="translated">C言語のようなメッセージベースのOO言語とは異なります。</target>
        </trans-unit>
        <trans-unit id="906465653e9352a3acf19ee4e06fa8005cc8906b" translate="yes" xml:space="preserve">
          <source>Note the call to &lt;code&gt;maybe_quit&lt;/code&gt; inside the loop: this function checks whether the user pressed</source>
          <target state="translated">ループ内の &lt;code&gt;maybe_quit&lt;/code&gt; の呼び出しに注意してください。この関数は、ユーザーがを押したかどうかをチェックします。</target>
        </trans-unit>
        <trans-unit id="18449a6bba4a3bf6dccfca75e5c0114afa84bfeb" translate="yes" xml:space="preserve">
          <source>Note the symbols which the bindings are made for; these appear inside square brackets, in the key sequence being defined. In some cases, this symbol is the same as the command name; sometimes it is different. These symbols are treated as function keys, but they are not real function keys on the keyboard. They do not affect the functioning of the menu itself, but they are echoed in the echo area when the user selects from the menu, and they appear in the output of &lt;code&gt;where-is&lt;/code&gt; and &lt;code&gt;apropos&lt;/code&gt;.</source>
          <target state="translated">バインディングが作成されているシンボルに注意してください。これらは、定義されているキーシーケンスの角括弧内に表示されます。場合によっては、この記号はコマンド名と同じです。時々それは異なります。これらの記号はファンクションキーとして扱われますが、キーボードの実際のファンクションキーではありません。これらはメニュー自体の機能には影響しませんが、ユーザーがメニューから選択するとエコー領域にエコーされ、 &lt;code&gt;where-is&lt;/code&gt; および &lt;code&gt;apropos&lt;/code&gt; の出力に表示されます。</target>
        </trans-unit>
        <trans-unit id="090bff393075f6b58e2d0efa3893f085f97dd09d" translate="yes" xml:space="preserve">
          <source>Note: If the replacement is a string, it will be placed in a temporary buffer so that &lt;code&gt;replace-buffer-contents&lt;/code&gt; can operate on it. Therefore, if you already have the replacement in a buffer, it makes no sense to convert it to a string using &lt;code&gt;buffer-substring&lt;/code&gt; or similar.</source>
          <target state="translated">注：置換が文字列の場合、 &lt;code&gt;replace-buffer-contents&lt;/code&gt; が操作できるように、一時バッファーに配置されます。したがって、すでにバッファに置換がある場合は、 &lt;code&gt;buffer-substring&lt;/code&gt; などを使用して文字列に変換しても意味がありません。</target>
        </trans-unit>
        <trans-unit id="15b8243f03b0e985c78ff44d43c977a16ec664d5" translate="yes" xml:space="preserve">
          <source>Note: The interactive spec of &lt;var&gt;function&lt;/var&gt; will apply to the combined function and should hence obey the calling convention of the combined function rather than that of &lt;var&gt;function&lt;/var&gt;. In many cases, it makes no difference since they are identical, but it does matter for &lt;code&gt;:around&lt;/code&gt;, &lt;code&gt;:filter-args&lt;/code&gt;, and &lt;code&gt;:filter-return&lt;/code&gt;, where &lt;var&gt;function&lt;/var&gt; receives different arguments than the original function stored in &lt;var&gt;place&lt;/var&gt;.</source>
          <target state="translated">注： &lt;var&gt;function&lt;/var&gt; の対話型仕様は結合関数に適用されるため、関数の呼び出し規約ではなく、結合関数の呼び出し規約に従う必要があり &lt;var&gt;function&lt;/var&gt; 。多くの場合、それらは同一であるため違いはありませんが、 &lt;code&gt;:around&lt;/code&gt; 、 &lt;code&gt;:filter-args&lt;/code&gt; 、および &lt;code&gt;:filter-return&lt;/code&gt; の場合は重要です。この場合、 &lt;var&gt;function&lt;/var&gt; は、その &lt;var&gt;place&lt;/var&gt; 格納されている元の関数とは異なる引数を受け取ります。</target>
        </trans-unit>
        <trans-unit id="086829d75bac2c9e339b5bb59f87867c9bac04d0" translate="yes" xml:space="preserve">
          <source>Note: face remapping is non-recursive. If &lt;var&gt;remapping&lt;/var&gt; references the same face name &lt;var&gt;face&lt;/var&gt;, either directly or via the &lt;code&gt;:inherit&lt;/code&gt; attribute of some other face in &lt;var&gt;remapping&lt;/var&gt;, that reference uses the normal definition of &lt;var&gt;face&lt;/var&gt;. For instance, if the &lt;code&gt;mode-line&lt;/code&gt; face is remapped using this entry in &lt;code&gt;face-remapping-alist&lt;/code&gt;:</source>
          <target state="translated">注：顔の再マッピングは非再帰的です。もし &lt;var&gt;remapping&lt;/var&gt; の参照と同じ顔の名前の &lt;var&gt;face&lt;/var&gt; 直接または経由して、 &lt;code&gt;:inherit&lt;/code&gt; で他のいくつかの顔の属性 &lt;var&gt;remapping&lt;/var&gt; リファレンスは、通常の定義使用していること、 &lt;var&gt;face&lt;/var&gt; 。たとえば、 &lt;code&gt;face-remapping-alist&lt;/code&gt; のこのエントリを使用して &lt;code&gt;mode-line&lt;/code&gt; 顔が再マッピングされる場合：</target>
        </trans-unit>
        <trans-unit id="48c1f7cc7802f63e35b4a25aa793c719285304f9" translate="yes" xml:space="preserve">
          <source>Note: the properties &lt;code&gt;composition&lt;/code&gt;, &lt;code&gt;display&lt;/code&gt;, &lt;code&gt;invisible&lt;/code&gt; and &lt;code&gt;intangible&lt;/code&gt; can also cause point to move to an acceptable place, after each Emacs command. See &lt;a href=&quot;adjusting-point#Adjusting-Point&quot;&gt;Adjusting Point&lt;/a&gt;.</source>
          <target state="translated">注：プロパティ &lt;code&gt;composition&lt;/code&gt; 、 &lt;code&gt;display&lt;/code&gt; 、 &lt;code&gt;invisible&lt;/code&gt; 、 &lt;code&gt;intangible&lt;/code&gt; も、各Emacsコマンドの後で、ポイントを許容可能な場所に移動させる可能性があります。&lt;a href=&quot;adjusting-point#Adjusting-Point&quot;&gt;調整ポイントを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="e6cd208317b8407557bf5e9e8a5213d6396ae797" translate="yes" xml:space="preserve">
          <source>Notice how those lexers return the empty string when in front of parentheses. This is because SMIE automatically takes care of the parentheses defined in the syntax table. More specifically if the lexer returns &lt;code&gt;nil&lt;/code&gt; or an empty string, SMIE tries to handle the corresponding text as a sexp according to syntax tables.</source>
          <target state="translated">括弧の前にある場合、これらのレクサーが空の文字列を返す方法に注意してください。これは、SMIEが構文テーブルで定義された括弧を自動的に処理するためです。より具体的には、レクサーが &lt;code&gt;nil&lt;/code&gt; または空の文字列を返す場合、SMIEは、構文テーブルに従って、対応するテキストをsexpとして処理しようとします。</target>
        </trans-unit>
        <trans-unit id="1e7899e05f54c7cf4e3b193d5da99af8fc028b7c" translate="yes" xml:space="preserve">
          <source>Notice that all functions are allowed to overwrite the match data unless they&amp;rsquo;re explicitly documented not to do so. A consequence is that functions that are run implicitly in the background (see &lt;a href=&quot;timers#Timers&quot;&gt;Timers&lt;/a&gt;, and &lt;a href=&quot;idle-timers#Idle-Timers&quot;&gt;Idle Timers&lt;/a&gt;) should likely save and restore the match data explicitly.</source>
          <target state="translated">すべての関数は、明示的に文書化されていない限り、一致データを上書きできることに注意してください。その結果、バックグラウンドで暗黙的に実行される関数（&lt;a href=&quot;timers#Timers&quot;&gt;Timers&lt;/a&gt;および&lt;a href=&quot;idle-timers#Idle-Timers&quot;&gt;Idle Timersを&lt;/a&gt;参照）は、一致データを明示的に保存および復元する必要があります。</target>
        </trans-unit>
        <trans-unit id="7bf3df555a929d338861ed3b64bf8199a25afe42" translate="yes" xml:space="preserve">
          <source>Notification severity level, one of &lt;code&gt;info&lt;/code&gt;, &lt;code&gt;warning&lt;/code&gt;, or &lt;code&gt;error&lt;/code&gt;. If given, the value determines the icon displayed to the left of the notification title, but only if the &lt;code&gt;:title&lt;/code&gt; parameter (see below) is also specified and is a string.</source>
          <target state="translated">通知の重大度レベル、 &lt;code&gt;info&lt;/code&gt; 、 &lt;code&gt;warning&lt;/code&gt; 、または &lt;code&gt;error&lt;/code&gt; いずれか。指定した場合、値は通知タイトルの左側に表示されるアイコンを決定しますが、 &lt;code&gt;:title&lt;/code&gt; パラメーター（以下を参照）も指定され、文字列である場合に限ります。</target>
        </trans-unit>
        <trans-unit id="864d97d356a80a5cd27ad60eb5336174f9507562" translate="yes" xml:space="preserve">
          <source>Notifications on File Changes</source>
          <target state="translated">ファイルの変更に関する通知</target>
        </trans-unit>
        <trans-unit id="e3768fb5cf0372c526b5e173f1befdd62061f9c9" translate="yes" xml:space="preserve">
          <source>Notify &lt;var&gt;cond&lt;/var&gt;. The mutex with &lt;var&gt;cond&lt;/var&gt; must be held before calling this. Ordinarily a single waiting thread is woken by &lt;code&gt;condition-notify&lt;/code&gt;; but if &lt;var&gt;all&lt;/var&gt; is not &lt;code&gt;nil&lt;/code&gt;, then all threads waiting on &lt;var&gt;cond&lt;/var&gt; are notified.</source>
          <target state="translated">&lt;var&gt;cond&lt;/var&gt; に通知します。これを呼び出す前に、 &lt;var&gt;cond&lt;/var&gt; を使用したミューテックスを保持する必要があります。通常、単一の待機中のスレッドは、 &lt;code&gt;condition-notify&lt;/code&gt; によってウェイクアップされます。ただし、 &lt;var&gt;all&lt;/var&gt; が &lt;code&gt;nil&lt;/code&gt; でない場合は、 &lt;var&gt;cond&lt;/var&gt; を待機しているすべてのスレッドに通知されます。</target>
        </trans-unit>
        <trans-unit id="f36fcd20d98f1c2ef6f745daf470b6fc6dd07587" translate="yes" xml:space="preserve">
          <source>Novice Emacs Lisp programmers often try to use the mark for the wrong purposes. The mark saves a location for the user&amp;rsquo;s convenience. An editing command should not alter the mark unless altering the mark is part of the user-level functionality of the command. (And, in that case, this effect should be documented.) To remember a location for internal use in the Lisp program, store it in a Lisp variable. For example:</source>
          <target state="translated">初心者のEmacsLispプログラマーは、しばしば間違った目的でマークを使おうとします。マークは、ユーザーの便宜のために場所を保存します。マークの変更がコマンドのユーザーレベルの機能の一部でない限り、編集コマンドはマークを変更しないでください。（そして、その場合、この効果を文書化する必要があります。）Lispプログラムで内部使用する場所を記憶するには、それをLisp変数に格納します。例えば：</target>
        </trans-unit>
        <trans-unit id="93fe86956bd461c4f9006b03bcbecd888324bf7d" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s change the argument given to &lt;code&gt;catch2&lt;/code&gt;:</source>
          <target state="translated">それでは、 &lt;code&gt;catch2&lt;/code&gt; に与えられた引数を変更しましょう：</target>
        </trans-unit>
        <trans-unit id="7551c107ba5514ae35edf328fbdb7f4e01b52801" translate="yes" xml:space="preserve">
          <source>Now that &lt;code&gt;app&lt;/code&gt; has matched, all &lt;code&gt;and&lt;/code&gt; sub-patterns have matched, and so &lt;code&gt;and&lt;/code&gt; matches. Likewise, once &lt;code&gt;and&lt;/code&gt; has matched, &lt;code&gt;or&lt;/code&gt; matches and does not proceed to try sub-pattern &lt;code&gt;let&lt;/code&gt; (line 8).</source>
          <target state="translated">今という &lt;code&gt;app&lt;/code&gt; 一致した、すべて &lt;code&gt;and&lt;/code&gt; サブパターンが一致した、など &lt;code&gt;and&lt;/code&gt; 一致しました。同様に、一度 &lt;code&gt;and&lt;/code&gt; 一致した &lt;code&gt;or&lt;/code&gt; 一致してサブパターン &lt;code&gt;let&lt;/code&gt; の試行に進みません（8行目）。</target>
        </trans-unit>
        <trans-unit id="8bf81c47d3466cac8f8f1e05225e708ff47181f9" translate="yes" xml:space="preserve">
          <source>Now we can put the output in the proper order by reversing the list:</source>
          <target state="translated">あとはリストを逆にすることで、出力を適切な順番に並べることができるようになりました。</target>
        </trans-unit>
        <trans-unit id="5d2c4f3b6b617ec480f6e2553990ecdaa4eb658c" translate="yes" xml:space="preserve">
          <source>Now we create a hard link, by calling &lt;code&gt;add-name-to-file&lt;/code&gt;, then list the files again. This shows two names for one file,</source>
          <target state="translated">ここで、 &lt;code&gt;add-name-to-file&lt;/code&gt; を呼び出してハードリンクを作成し、ファイルを再度一覧表示します。これは、1つのファイルに2つの名前を示しています。</target>
        </trans-unit>
        <trans-unit id="07f78a209cc321ded7c29827738886e3593f46f8" translate="yes" xml:space="preserve">
          <source>Now we read using the stream thus constructed:</source>
          <target state="translated">ここでは、このようにして構築されたストリームを使用して読み込みを行います。</target>
        </trans-unit>
        <trans-unit id="429cf392dcfad2eb5b3fb43671b8d50dc62f2be6" translate="yes" xml:space="preserve">
          <source>Now we show a use of a marker as an output stream. Initially, the marker is in buffer &lt;code&gt;foo&lt;/code&gt;, between the &amp;lsquo;</source>
          <target state="translated">ここで、出力ストリームとしてのマーカーの使用法を示します。最初は、マーカーはバッファ &lt;code&gt;foo&lt;/code&gt; にあります。</target>
        </trans-unit>
        <trans-unit id="6fb2e1a0ad356df5d65425e68c286f81f8d8b450" translate="yes" xml:space="preserve">
          <source>Now you can go to the beginning of the defun and type</source>
          <target state="translated">これでdefunの最初の方に行って、次のように入力します。</target>
        </trans-unit>
        <trans-unit id="e23718dfb830dd77b88fcfc0d1b3bea6a5e6fca3" translate="yes" xml:space="preserve">
          <source>Now, when enlarging a window vertically, Emacs tries to obtain the corresponding space from its lower sibling, provided such a window exists. In our scenario, enlarging &lt;var&gt;W4&lt;/var&gt; will steal space from &lt;var&gt;W3&lt;/var&gt;.</source>
          <target state="translated">ここで、ウィンドウを垂直方向に拡大するとき、Emacsは、そのようなウィンドウが存在する場合、その下の兄弟から対応するスペースを取得しようとします。このシナリオでは、 &lt;var&gt;W4&lt;/var&gt; を拡大すると、 &lt;var&gt;W3&lt;/var&gt; からスペースが奪われます。</target>
        </trans-unit>
        <trans-unit id="9e06af5545a3e4354b7d4ee0852c0eed7a91cb67" translate="yes" xml:space="preserve">
          <source>Number of seconds to pause when a breakpoint is reached and the execution mode is trace or continue. See &lt;a href=&quot;edebug-execution-modes#Edebug-Execution-Modes&quot;&gt;Edebug Execution Modes&lt;/a&gt;.</source>
          <target state="translated">ブレークポイントに到達し、実行モードがトレースまたは続行したときに一時停止する秒数。&lt;a href=&quot;edebug-execution-modes#Edebug-Execution-Modes&quot;&gt;Edebug実行モードを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="322456515cb687e293b524d7ce7beddddcb9bc80" translate="yes" xml:space="preserve">
          <source>Number of spaces</source>
          <target state="translated">スペース数</target>
        </trans-unit>
        <trans-unit id="7e53821f70ae16079c4a6a64c52a91fae645bc5f" translate="yes" xml:space="preserve">
          <source>Numbers</source>
          <target state="translated">Numbers</target>
        </trans-unit>
        <trans-unit id="7e3c0a7716da4e48fa5db56b8609023d7442bc77" translate="yes" xml:space="preserve">
          <source>Numbers and arithmetic functions.</source>
          <target state="translated">数字と算術関数。</target>
        </trans-unit>
        <trans-unit id="f004d111f9eecf4e07d15edb9e80b8c6a0bb7fb8" translate="yes" xml:space="preserve">
          <source>Numbers controlling how to compose characters.</source>
          <target state="translated">文字の構成方法を制御する数字。</target>
        </trans-unit>
        <trans-unit id="4632fc07fc740627ec8979b8ae726d58ce6441a0" translate="yes" xml:space="preserve">
          <source>Numbers with fractional parts and with a large range.</source>
          <target state="translated">端数部分があり、範囲が広い数字。</target>
        </trans-unit>
        <trans-unit id="238f75d73961cd8ec3a93e41f8eca572c815790b" translate="yes" xml:space="preserve">
          <source>Numbers without fractional parts.</source>
          <target state="translated">端数部分のない数字。</target>
        </trans-unit>
        <trans-unit id="30a62380404b3b267a5c4e21b5e111455d09031e" translate="yes" xml:space="preserve">
          <source>Numeric</source>
          <target state="translated">Numeric</target>
        </trans-unit>
        <trans-unit id="f72c4497b8297399ea538316ed693eb0b0f69dbb" translate="yes" xml:space="preserve">
          <source>Numeric Conversions</source>
          <target state="translated">数値変換</target>
        </trans-unit>
        <trans-unit id="08a914cde05039694ef0194d9ee79ff9a79dde33" translate="yes" xml:space="preserve">
          <source>O</source>
          <target state="translated">O</target>
        </trans-unit>
        <trans-unit id="a7947cd1693d4f1df0716adaabddf52493ff1007" translate="yes" xml:space="preserve">
          <source>O P</source>
          <target state="translated">オーピー</target>
        </trans-unit>
        <trans-unit id="c363dc3457ef24cf6ba8971bbc948dded316392b" translate="yes" xml:space="preserve">
          <source>Obarrays are also a kind of hash table, but they are a different type of object and are used only for recording interned symbols (see &lt;a href=&quot;creating-symbols#Creating-Symbols&quot;&gt;Creating Symbols&lt;/a&gt;).</source>
          <target state="translated">Obarrayも一種のハッシュテーブルですが、それらは異なるタイプのオブジェクトであり、インターンされたシンボルを記録するためにのみ使用されます（シンボルの&lt;a href=&quot;creating-symbols#Creating-Symbols&quot;&gt;作成を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="6f56ee4a102e69c064a8440479a96623086d8758" translate="yes" xml:space="preserve">
          <source>Object Internals</source>
          <target state="translated">オブジェクト内部</target>
        </trans-unit>
        <trans-unit id="9101d7a347d0a3885fc114e1cef91162863e5343" translate="yes" xml:space="preserve">
          <source>Objects holding information about types.</source>
          <target state="translated">型に関する情報を保持するオブジェクト。</target>
        </trans-unit>
        <trans-unit id="d2b0ba186e391135f71f9fbac7110335d650cacf" translate="yes" xml:space="preserve">
          <source>Objects that have no read syntax are presented like this (see &lt;a href=&quot;printed-representation#Printed-Representation&quot;&gt;Printed Representation&lt;/a&gt;).</source>
          <target state="translated">読み取り構文を持たないオブジェクトは、次のように表示されます（&lt;a href=&quot;printed-representation#Printed-Representation&quot;&gt;印刷表現を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="d7717e27b11c625514b5d6b2df3dc3a2a3bbea53" translate="yes" xml:space="preserve">
          <source>Obtain rudimentary coverage testing and frequency counts.</source>
          <target state="translated">初歩的なカバレッジテストと周波数カウントを取得します。</target>
        </trans-unit>
        <trans-unit id="523942562b4a55d93a983d95b45b7177c8e4772d" translate="yes" xml:space="preserve">
          <source>Obtaining random integers, predictable or not.</source>
          <target state="translated">予測可能か否かを問わず、乱数整数を取得する。</target>
        </trans-unit>
        <trans-unit id="46a01ce0f03ec80a793aa30a264989482df496b0" translate="yes" xml:space="preserve">
          <source>Obviously, this does not actually modify &lt;code&gt;previous-line&lt;/code&gt;. For that the old advice needed:</source>
          <target state="translated">明らかに、これは実際には &lt;code&gt;previous-line&lt;/code&gt; 変更しません。そのために必要な古いアドバイス：</target>
        </trans-unit>
        <trans-unit id="264277b0376bfa4b86c520e9ec23072a05a7fe4d" translate="yes" xml:space="preserve">
          <source>Occasionally problems result from the fact that a macro call is expanded each time it is evaluated in an interpreted function, but is expanded only once (during compilation) for a compiled function. If the macro definition has side effects, they will work differently depending on how many times the macro is expanded.</source>
          <target state="translated">マクロ呼び出しが解釈された関数で評価されるたびに展開されるが、コンパイルされた関数では一度だけ(コンパイル中に)展開されるという事実から、時折問題が発生します。マクロの定義に副作用がある場合、マクロが展開される回数に応じて異なる動作をするようになります。</target>
        </trans-unit>
        <trans-unit id="bce973a751cd4a03300fce0010a6712f601f9f80" translate="yes" xml:space="preserve">
          <source>Occasionally you will want to test explicitly whether a library has already been loaded. If the library uses &lt;code&gt;provide&lt;/code&gt; to provide a named feature, you can use &lt;code&gt;featurep&lt;/code&gt; earlier in the file to test whether the &lt;code&gt;provide&lt;/code&gt; call has been executed before (see &lt;a href=&quot;named-features#Named-Features&quot;&gt;Named Features&lt;/a&gt;). Alternatively, you could use something like this:</source>
          <target state="translated">ライブラリがすでにロードされているかどうかを明示的にテストしたい場合があります。ライブラリが &lt;code&gt;provide&lt;/code&gt; を使用して名前付き機能を提供する場合は、ファイルの前半で &lt;code&gt;featurep&lt;/code&gt; を使用して、 &lt;code&gt;provide&lt;/code&gt; 呼び出しが以前に実行されたかどうかをテストできます（&lt;a href=&quot;named-features#Named-Features&quot;&gt;名前付き機能を&lt;/a&gt;参照）。または、次のようなものを使用することもできます。</target>
        </trans-unit>
        <trans-unit id="3bce6877b2fad79bb26a891e5eaabc5fa131f26b" translate="yes" xml:space="preserve">
          <source>Occasionally, Emacs needs to hold and manipulate encoded text or binary non-text data in its buffers or strings. For example, when Emacs visits a file, it first reads the file&amp;rsquo;s text verbatim into a buffer, and only then converts it to the internal representation. Before the conversion, the buffer holds encoded text.</source>
          <target state="translated">時折、Emacsはエンコードされたテキストまたはバイナリの非テキストデータをバッファまたは文字列に保持して操作する必要があります。たとえば、Emacsがファイルにアクセスすると、最初にファイルのテキストを逐語的にバッファに読み込み、次にそれを内部表現に変換します。変換前に、バッファはエンコードされたテキストを保持します。</target>
        </trans-unit>
        <trans-unit id="3dbe249e6f95e11f5e11808a2753212c83d62b34" translate="yes" xml:space="preserve">
          <source>Occasionally, such &lt;em&gt;implied frame resizing&lt;/em&gt; may be unwanted, for example, when a frame has been maximized or made full-screen (where it&amp;rsquo;s turned off by default). In general, users can disable implied resizing with the following option:</source>
          <target state="translated">場合によっては、フレームが最大化されているか、フルスクリーンになっている（デフォルトでオフになっている）場合など、このような&lt;em&gt;暗黙のフレームサイズ変更&lt;/em&gt;が不要な&lt;em&gt;場合&lt;/em&gt;があります。一般に、ユーザーは次のオプションを使用して暗黙のサイズ変更を無効にできます。</target>
        </trans-unit>
        <trans-unit id="0aff50bf865a5c17280fbf067141c1f7c36c3a36" translate="yes" xml:space="preserve">
          <source>Occasionally, you may want to reference a variable which is only determined at run time. In that case, you cannot specify the variable name in the text of the program. You can use the &lt;code&gt;symbol-value&lt;/code&gt; function to extract the value.</source>
          <target state="translated">場合によっては、実行時にのみ決定される変数を参照したいことがあります。その場合、プログラムのテキストで変数名を指定することはできません。あなたは使用することができ &lt;code&gt;symbol-value&lt;/code&gt; 値を抽出する機能を。</target>
        </trans-unit>
        <trans-unit id="22fc935449693a1e814188a46a216288f35c0512" translate="yes" xml:space="preserve">
          <source>Of course, if the actual value of the option fits this alternative, it will appear showing the actual value, not &lt;var&gt;default&lt;/var&gt;.</source>
          <target state="translated">もちろん、オプションの実際の値がこの選択肢に適合する場合は、 &lt;var&gt;default&lt;/var&gt; ではなく実際の値が表示されます。</target>
        </trans-unit>
        <trans-unit id="15696db648937c4ccbe88be9cf5f24c7996a1367" translate="yes" xml:space="preserve">
          <source>Of these usual keymaps, the highest-precedence one is specified by the &lt;code&gt;keymap&lt;/code&gt; text or overlay property at point, if any. (For a mouse input event, Emacs uses the event position instead of point; see &lt;a href=&quot;searching-keymaps#Searching-Keymaps&quot;&gt;Searching Keymaps&lt;/a&gt;.)</source>
          <target state="translated">これらの通常の &lt;code&gt;keymap&lt;/code&gt; うち、最も優先度の高いものは、キーマップテキストまたはポイントのオーバーレイプロパティ（存在する場合）によって指定されます。（マウス入力イベントの場合、Emacsはポイントではなくイベント位置を使用します。&lt;a href=&quot;searching-keymaps#Searching-Keymaps&quot;&gt;キーマップの検索を&lt;/a&gt;参照してください。）</target>
        </trans-unit>
        <trans-unit id="4dc8a5d2b3bac37c9f0883d213f98c63e2f5757f" translate="yes" xml:space="preserve">
          <source>Often &lt;code&gt;window-size-fixed&lt;/code&gt; is overly aggressive because it inhibits any attempt to explicitly resize or split an affected window as well. This may even happen after the window has been resized implicitly, for example, when deleting an adjacent window or resizing the window&amp;rsquo;s frame. The following function tries hard to never disallow resizing such a window explicitly:</source>
          <target state="translated">多くの場合、 &lt;code&gt;window-size-fixed&lt;/code&gt; は、影響を受けるウィンドウのサイズを明示的に変更したり分割したりする試みを禁止するため、過度に攻撃的です。これは、ウィンドウのサイズが暗黙的に変更された後、たとえば、隣接するウィンドウを削除したり、ウィンドウのフレームのサイズを変更したりした場合でも発生する可能性があります。次の関数は、このようなウィンドウのサイズ変更を明示的に禁止しないように努めています。</target>
        </trans-unit>
        <trans-unit id="eee3f476e8d88bba8df49970967c0f8d91d77b1e" translate="yes" xml:space="preserve">
          <source>Often we want to execute the last clause whenever none of the previous clauses was successful. To do this, we use &lt;code&gt;t&lt;/code&gt; as the &lt;var&gt;condition&lt;/var&gt; of the last clause, like this: &lt;code&gt;(t
&lt;var&gt;body-forms&lt;/var&gt;)&lt;/code&gt;. The form &lt;code&gt;t&lt;/code&gt; evaluates to &lt;code&gt;t&lt;/code&gt;, which is never &lt;code&gt;nil&lt;/code&gt;, so this clause never fails, provided the &lt;code&gt;cond&lt;/code&gt; gets to it at all. For example:</source>
          <target state="translated">前の句がどれも成功しなかったときはいつでも、最後の句を実行したいことがよくあります。これを行うには、次のように、最後の句の &lt;var&gt;condition&lt;/var&gt; として &lt;code&gt;t&lt;/code&gt; を使用します： &lt;code&gt;(t &lt;var&gt;body-forms&lt;/var&gt;)&lt;/code&gt; &lt;var&gt;body-forms&lt;/var&gt; ）。フォーム &lt;code&gt;t&lt;/code&gt; に評価を &lt;code&gt;t&lt;/code&gt; になることはありません、 &lt;code&gt;nil&lt;/code&gt; のこの句が失敗したことがないように提供、 &lt;code&gt;cond&lt;/code&gt; がすべてでそれを取得します。例えば：</target>
        </trans-unit>
        <trans-unit id="ab20aa539406f6dcc74005792b8dba230e5c4baa" translate="yes" xml:space="preserve">
          <source>Older implementations of &lt;code&gt;display-buffer&lt;/code&gt; frequently caused users and applications to fight over the settings of user options like &lt;code&gt;pop-up-frames&lt;/code&gt; and &lt;code&gt;pop-up-windows&lt;/code&gt; (see &lt;a href=&quot;choosing-window-options#Choosing-Window-Options&quot;&gt;Choosing Window Options&lt;/a&gt;). This was one major reason for redesigning &lt;code&gt;display-buffer&lt;/code&gt;&amp;mdash;to provide a clear framework specifying what users and applications should be allowed to do.</source>
          <target state="translated">&lt;code&gt;display-buffer&lt;/code&gt; の古い実装では、ユーザーとアプリケーションが &lt;code&gt;pop-up-frames&lt;/code&gt; や &lt;code&gt;pop-up-windows&lt;/code&gt; などのユーザーオプションの設定をめぐって争うことがよくありました（&lt;a href=&quot;choosing-window-options#Choosing-Window-Options&quot;&gt;ウィンドウオプションの選択を&lt;/a&gt;参照）。これが、 &lt;code&gt;display-buffer&lt;/code&gt; を再設計する主な理由の1つでした。これは、ユーザーとアプリケーションに実行を許可する必要があることを指定する明確なフレームワークを提供するためです。</target>
        </trans-unit>
        <trans-unit id="bde4db5a93db0c668793ff17fa3effb0028c7b23" translate="yes" xml:space="preserve">
          <source>Omitting the argument &lt;var&gt;end&lt;/var&gt; is equivalent to specifying &lt;code&gt;nil&lt;/code&gt;. It follows that &lt;code&gt;(substring &lt;var&gt;string&lt;/var&gt; 0)&lt;/code&gt; returns a copy of all of &lt;var&gt;string&lt;/var&gt;.</source>
          <target state="translated">引数 &lt;var&gt;end&lt;/var&gt; を省略することは、 &lt;code&gt;nil&lt;/code&gt; を指定することと同じです。したがって、 &lt;code&gt;(substring &lt;var&gt;string&lt;/var&gt; 0)&lt;/code&gt; はすべての &lt;var&gt;string&lt;/var&gt; コピーを返します。</target>
        </trans-unit>
        <trans-unit id="066afc902473c5cdc45a4d6cd87ac56bcadb3222" translate="yes" xml:space="preserve">
          <source>On GNU and Unix systems, each X display is a separate graphical terminal. When Emacs is started from within the X window system, it uses the X display specified by the &lt;code&gt;DISPLAY&lt;/code&gt; environment variable, or by the &amp;lsquo;</source>
          <target state="translated">GNUおよびUnixシステムでは、各Xディスプレイは個別のグラフィカル端末です。EmacsがXウィンドウシステム内から起動されると、 &lt;code&gt;DISPLAY&lt;/code&gt; 環境変数または 'で指定されたXディスプレイを使用します。</target>
        </trans-unit>
        <trans-unit id="091b227d1e7a53734313af3b399630351b76696a" translate="yes" xml:space="preserve">
          <source>On GNU and Unix systems, you can create additional frames on any available terminal, within a single Emacs session, regardless of whether Emacs was started on a text or graphical terminal. Emacs can display on both graphical and text terminals simultaneously. This comes in handy, for instance, when you connect to the same session from several remote locations. See &lt;a href=&quot;multiple-terminals#Multiple-Terminals&quot;&gt;Multiple Terminals&lt;/a&gt;.</source>
          <target state="translated">GNUおよびUnixシステムでは、Emacsがテキスト端末で開始されたかグラフィカル端末で開始されたかに関係なく、単一のEmacsセッション内で利用可能な任意の端末に追加のフレームを作成できます。Emacsはグラフィカル端末とテキスト端末の両方に同時に表示できます。これは、たとえば、複数のリモートロケーションから同じセッションに接続する場合に便利です。&lt;a href=&quot;multiple-terminals#Multiple-Terminals&quot;&gt;複数の端末を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="86008f191b802986f9373390d1207c585a06279d" translate="yes" xml:space="preserve">
          <source>On GNU and other POSIX-like systems, a string returned by this function always ends in a slash. On MS-DOS it can also end in a colon.</source>
          <target state="translated">GNUや他のPOSIXに似たシステムでは、この関数が返す文字列は常にスラッシュで終わります。MS-DOSではコロンで終わることもあります。</target>
        </trans-unit>
        <trans-unit id="3ec76dde782f694fa2ff646fa44724ed20f56abf" translate="yes" xml:space="preserve">
          <source>On GNU and other POSIX-like systems, this simply returns &lt;var&gt;filename&lt;/var&gt;. On other operating systems, it may enforce system-specific file name conventions; for example, on MS-DOS this function performs a variety of changes to enforce MS-DOS file name limitations, including converting any leading &amp;lsquo;</source>
          <target state="translated">GNUおよびその他のPOSIXのようなシステムでは、これは単に &lt;var&gt;filename&lt;/var&gt; 返します。他のオペレーティングシステムでは、システム固有のファイル名の規則が適用される場合があります。たとえば、MS-DOSでは、この関数はさまざまな変更を実行して、先頭の 'の変換など、MS-DOSファイル名の制限を適用します。</target>
        </trans-unit>
        <trans-unit id="d87da634547b00223204825e52b32ac75a53d3aa" translate="yes" xml:space="preserve">
          <source>On GNU platforms when operating on a local file, this function is atomic: if the filesystem is simultaneously being changed by some other process, this function returns the file&amp;rsquo;s attributes either before or after the change. Otherwise this function is not atomic, and might return &lt;code&gt;nil&lt;/code&gt; if it detects the race condition, or might return a hodgepodge of the previous and current file attributes.</source>
          <target state="translated">ローカルファイルを操作するGNUプラットフォームでは、この関数はアトミックです。ファイルシステムが他のプロセスによって同時に変更されている場合、この関数は変更前または変更後にファイルの属性を返します。それ以外の場合、この関数はアトミックではなく、競合状態を検出した場合に &lt;code&gt;nil&lt;/code&gt; を返すか、以前および現在のファイル属性の寄せ集めを返す可能性があります。</target>
        </trans-unit>
        <trans-unit id="b8d088ebe683822c85b3d4ba7ca6f051bd5326f5" translate="yes" xml:space="preserve">
          <source>On MS-DOS and MS-Windows, these functions (like the function that actually operate on files) accept MS-DOS or MS-Windows file-name syntax, where backslashes separate the components, as well as POSIX syntax; but they always return POSIX syntax. This enables Lisp programs to specify file names in POSIX syntax and work properly on all systems without change.&lt;a href=&quot;#FOOT15&quot; name=&quot;DOCF15&quot;&gt;&lt;sup&gt;15&lt;/sup&gt;&lt;/a&gt;</source>
          <target state="translated">MS-DOSおよびMS-Windowsでは、これらの関数（実際にファイルを操作する関数など）は、バックスラッシュでコンポーネントを区切るMS-DOSまたはMS-Windowsのファイル名構文とPOSIX構文を受け入れます。ただし、常にPOSIX構文を返します。これにより、LispプログラムはPOSIX構文でファイル名を指定し、変更することなくすべてのシステムで正しく動作することができます。&lt;a href=&quot;#FOOT15&quot; name=&quot;DOCF15&quot;&gt;&lt;sup&gt;15&lt;/sup&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2928e4c3bab1512e37407ed35b34ba158366a196" translate="yes" xml:space="preserve">
          <source>On MS-DOS filesystems without long names this variable is always ignored.</source>
          <target state="translated">長い名前のないMS-DOSファイルシステムでは、この変数は常に無視されます。</target>
        </trans-unit>
        <trans-unit id="e12a5b8ff044d26de039b2ea5eb8fbb324b2d8e4" translate="yes" xml:space="preserve">
          <source>On MS-DOS, Emacs sets the &lt;code&gt;TERM&lt;/code&gt; environment variable to &amp;lsquo;</source>
          <target state="translated">MS-DOSでは、Emacsは &lt;code&gt;TERM&lt;/code&gt; 環境変数を 'に設定します</target>
        </trans-unit>
        <trans-unit id="ec2bac6013926e2f9b7a2cc7618659e3f89fcfa1" translate="yes" xml:space="preserve">
          <source>On MS-Windows the &lt;var&gt;noactivate&lt;/var&gt; argument has no effect. However, if &lt;var&gt;frame&lt;/var&gt; is a child frame (see &lt;a href=&quot;child-frames#Child-Frames&quot;&gt;Child Frames&lt;/a&gt;), this function usually focuses &lt;var&gt;frame&lt;/var&gt; without raising it above other child frames.</source>
          <target state="translated">MS-Windowsでは、 &lt;var&gt;noactivate&lt;/var&gt; 引数は効果がありません。ただし、 &lt;var&gt;frame&lt;/var&gt; （参照子フレームである&lt;a href=&quot;child-frames#Child-Frames&quot;&gt;子フレームを&lt;/a&gt;）、この関数は通常、焦点を当てて &lt;var&gt;frame&lt;/var&gt; 他の子フレームの上にそれを上昇させることなく。</target>
        </trans-unit>
        <trans-unit id="ef4fecbe41a5626c5f763eccb62f475909804106" translate="yes" xml:space="preserve">
          <source>On Windows 2000 and later, Emacs by default uses Unicode APIs to pass file names to the OS, so the value of &lt;code&gt;file-name-coding-system&lt;/code&gt; is largely ignored. Lisp applications that need to encode or decode file names on the Lisp level should use &lt;code&gt;utf-8&lt;/code&gt; coding-system when &lt;code&gt;system-type&lt;/code&gt; is &lt;code&gt;windows-nt&lt;/code&gt;; the conversion of UTF-8 encoded file names to the encoding appropriate for communicating with the OS is performed internally by Emacs.</source>
          <target state="translated">Windows 2000以降では、EmacsはデフォルトでUnicode APIを使用してファイル名をOSに渡すため、 &lt;code&gt;file-name-coding-system&lt;/code&gt; の値はほとんど無視されます。Lispレベルでファイル名をエンコードまたはデコードする必要があるLispアプリケーションは、 &lt;code&gt;system-type&lt;/code&gt; が &lt;code&gt;windows-nt&lt;/code&gt; の場合、 &lt;code&gt;utf-8&lt;/code&gt; coding -systemを使用する必要があります。UTF-8でエンコードされたファイル名からOSとの通信に適したエンコードへの変換は、Emacsによって内部的に実行されます。</target>
        </trans-unit>
        <trans-unit id="3d9d3c2776e23b63f854890fc4c9449192d7124d" translate="yes" xml:space="preserve">
          <source>On a graphical display, tiny arrow images in the window fringes indicate truncated and continued lines (see &lt;a href=&quot;fringes#Fringes&quot;&gt;Fringes&lt;/a&gt;). On a text terminal, a &amp;lsquo;</source>
          <target state="translated">グラフィックディスプレイでは、ウィンドウのフリンジにある小さな矢印画像は、切り捨てられた連続した線を示します（&lt;a href=&quot;fringes#Fringes&quot;&gt;フリンジを&lt;/a&gt;参照）。テキスト端末では、 '</target>
        </trans-unit>
        <trans-unit id="80f59247bbce1d1c9f874202c878dbd846f48819" translate="yes" xml:space="preserve">
          <source>On a graphical terminal that supports extended</source>
          <target state="translated">拡張された</target>
        </trans-unit>
        <trans-unit id="71814826cf878c3c911d09d9a92001d4a2a4fb2c" translate="yes" xml:space="preserve">
          <source>On a graphical terminal the following two functions allow the absolute position of the mouse cursor to be retrieved and set.</source>
          <target state="translated">グラフィカルターミナルでは、以下の 2 つの関数により、マウスカーソルの絶対位置を取得して設定することができます。</target>
        </trans-unit>
        <trans-unit id="da4884a418379ce0d9a42cbe8229e4ebb6fbeeba" translate="yes" xml:space="preserve">
          <source>On a graphical terminal this form &amp;ldquo;warps&amp;rdquo; the mouse cursor to the upper left corner of the glyph at the selected window&amp;rsquo;s point. A position calculated this way can be also used to show a tooltip window there.</source>
          <target state="translated">グラフィカル端末では、このフォームは、選択したウィンドウのポイントでグリフの左上隅にマウスカーソルを「ワープ」します。この方法で計算された位置を使用して、ツールチップウィンドウを表示することもできます。</target>
        </trans-unit>
        <trans-unit id="c638ecc2a4ea2d5a12f6c70496e911bec175971e" translate="yes" xml:space="preserve">
          <source>On a graphical terminal we distinguish two types of frames: A normal &lt;em&gt;top-level frame&lt;/em&gt; is a frame whose window-system window is a child of the window-system&amp;rsquo;s root window for that terminal. A child frame is a frame whose window-system window is the child of the window-system window of another Emacs frame. See &lt;a href=&quot;child-frames#Child-Frames&quot;&gt;Child Frames&lt;/a&gt;.</source>
          <target state="translated">グラフィカル端末では、2つのタイプのフレームを区別します。通常の&lt;em&gt;トップレベルフレーム&lt;/em&gt;は、ウィンドウシステムウィンドウがその端末のウィンドウシステムのルートウィンドウの子であるフレームです。子フレームは、ウィンドウシステムウィンドウが別のEmacsフレームのウィンドウシステムウィンドウの子であるフレームです。&lt;a href=&quot;child-frames#Child-Frames&quot;&gt;子フレームを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="c566ed32a5007176cbb7b1c85495717dc12a7b9d" translate="yes" xml:space="preserve">
          <source>On a text terminal frame both values are zero.</source>
          <target state="translated">テキスト端末のフレームでは、両方の値がゼロになります。</target>
        </trans-unit>
        <trans-unit id="a9edfd72a3d801155297af0b22f3986badadf241" translate="yes" xml:space="preserve">
          <source>On a text terminal, all frames are considered visible for the purposes of this function, even though only one frame is displayed. See &lt;a href=&quot;raising-and-lowering#Raising-and-Lowering&quot;&gt;Raising and Lowering&lt;/a&gt;.</source>
          <target state="translated">テキスト端末では、1つのフレームしか表示されていなくても、この機能の目的上、すべてのフレームが表示されていると見なされます。&lt;a href=&quot;raising-and-lowering#Raising-and-Lowering&quot;&gt;上げ下げを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="5c4eb786d6a56a9b0991f45bcfa777150db81f17" translate="yes" xml:space="preserve">
          <source>On each frame, the frame parameter &lt;code&gt;tool-bar-lines&lt;/code&gt; controls how many lines&amp;rsquo; worth of height to reserve for the tool bar. A zero value suppresses the tool bar. If the value is nonzero, and &lt;code&gt;auto-resize-tool-bars&lt;/code&gt; is non-&lt;code&gt;nil&lt;/code&gt;, the tool bar expands and contracts automatically as needed to hold the specified contents. If the value is &lt;code&gt;grow-only&lt;/code&gt;, the tool bar expands automatically, but does not contract automatically.</source>
          <target state="translated">各フレームで、フレームパラメータ &lt;code&gt;tool-bar-lines&lt;/code&gt; は、ツールバー用に予約するラインの高さを制御します。ゼロ値はツールバーを抑制します。値がゼロ以外で、 &lt;code&gt;auto-resize-tool-bars&lt;/code&gt; が &lt;code&gt;nil&lt;/code&gt; 以外の場合、ツールバーは必要に応じて自動的に拡大および縮小し、指定された内容を保持します。値が &lt;code&gt;grow-only&lt;/code&gt; の場合、ツールバーは自動的に拡大しますが、自動的には縮小しません。</target>
        </trans-unit>
        <trans-unit id="a47451314dff3dd8ebd99643acb7f9a5e541559a" translate="yes" xml:space="preserve">
          <source>On graphical displays, Emacs draws &lt;em&gt;fringes&lt;/em&gt; next to each window: thin vertical strips down the sides which can display bitmaps indicating truncation, continuation, horizontal scrolling, and so on.</source>
          <target state="translated">グラフィカルディスプレイでは、Emacsは各ウィンドウの横に&lt;em&gt;フリンジを&lt;/em&gt;描画します。切り捨て、継続、水平スクロールなどを示すビットマップを表示できる薄い垂直ストリップが側面にあります。</target>
        </trans-unit>
        <trans-unit id="bc01dccb2a56362cf18d4aefcda75bb95fe48802" translate="yes" xml:space="preserve">
          <source>On graphical systems, the position of a normal top-level frame is specified as the absolute position of its outer frame (see &lt;a href=&quot;frame-geometry#Frame-Geometry&quot;&gt;Frame Geometry&lt;/a&gt;). The position of a child frame (see &lt;a href=&quot;child-frames#Child-Frames&quot;&gt;Child Frames&lt;/a&gt;) is specified via pixel offsets of its outer edges relative to the native position of its parent frame.</source>
          <target state="translated">グラフィカルシステムでは、通常のトップレベルフレームの位置は、その外側のフレームの絶対位置として指定されます（&lt;a href=&quot;frame-geometry#Frame-Geometry&quot;&gt;フレームジオメトリを&lt;/a&gt;参照）。子フレームの位置は、（参照&lt;a href=&quot;child-frames#Child-Frames&quot;&gt;子フレームの&lt;/a&gt;）親フレームのネイティブ位置に対してその外縁のピクセルオフセットを介して指定されています。</target>
        </trans-unit>
        <trans-unit id="ec338cdd1a9ff313906eec5d348a8022f6c825b7" translate="yes" xml:space="preserve">
          <source>On graphical terminals, you can specify the line spacing for all lines in a frame, using the &lt;code&gt;line-spacing&lt;/code&gt; frame parameter (see &lt;a href=&quot;layout-parameters#Layout-Parameters&quot;&gt;Layout Parameters&lt;/a&gt;). However, if the default value of &lt;code&gt;line-spacing&lt;/code&gt; is non-&lt;code&gt;nil&lt;/code&gt;, it overrides the frame&amp;rsquo;s &lt;code&gt;line-spacing&lt;/code&gt; parameter. An integer specifies the number of pixels put below lines. A floating-point number specifies the spacing relative to the frame&amp;rsquo;s default line height.</source>
          <target state="translated">グラフィカル端末では、 &lt;code&gt;line-spacing&lt;/code&gt; frameパラメータを使用して、フレーム内のすべての行の行間隔を指定できます（&lt;a href=&quot;layout-parameters#Layout-Parameters&quot;&gt;レイアウトパラメータを&lt;/a&gt;参照）。デフォルト値の場合は、 &lt;code&gt;line-spacing&lt;/code&gt; 非で &lt;code&gt;nil&lt;/code&gt; を、それがフレームの優先されます &lt;code&gt;line-spacing&lt;/code&gt; パラメータを。整数は、線の下に配置されるピクセル数を指定します。浮動小数点数は、フレームのデフォルトの行の高さに対する間隔を指定します。</target>
        </trans-unit>
        <trans-unit id="b46ca9680188aa91809e991a0175bded9c6cfada" translate="yes" xml:space="preserve">
          <source>On match, the clause&amp;rsquo;s body forms can reference the set of symbols the pattern let-binds. When &lt;var&gt;seqpat&lt;/var&gt; is &lt;code&gt;and&lt;/code&gt;, this set is the union of all the symbols each of its sub-patterns let-binds. This makes sense because, for &lt;code&gt;and&lt;/code&gt; to match, all the sub-patterns must match.</source>
          <target state="translated">一致すると、句の本体フォームは、パターンがバインドするシンボルのセットを参照できます。 &lt;var&gt;seqpat&lt;/var&gt; が &lt;code&gt;and&lt;/code&gt; の場合、このセットは、各サブパターンのlet- bindのすべてのシンボルの和集合です。以下のために、これは理にかなっている &lt;code&gt;and&lt;/code&gt; 一致し、すべてのサブパターンが一致している必要があります。</target>
        </trans-unit>
        <trans-unit id="c2fe00d1b0cab19cc3dbd01c42a2c9d3f1167cf5" translate="yes" xml:space="preserve">
          <source>On most systems, the directory part is everything up to and including the last slash (backslash is also allowed in input on MS-DOS or MS-Windows); the nondirectory part is the rest.</source>
          <target state="translated">ほとんどのシステムでは、ディレクトリ部分は最後のスラッシュを含むすべてのものです(MS-DOSやMS-Windowsではバックスラッシュも入力で許可されています)。</target>
        </trans-unit>
        <trans-unit id="d9f9275391241753a0fc3733e8b2d3b0ad7002b2" translate="yes" xml:space="preserve">
          <source>On most systems, this function works by running a directory listing program whose name is in the variable &lt;code&gt;insert-directory-program&lt;/code&gt;. If &lt;var&gt;wildcard&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, it also runs the shell specified by &lt;code&gt;shell-file-name&lt;/code&gt;, to expand the wildcards.</source>
          <target state="translated">ほとんどのシステムでは、この関数は、名前が変数 &lt;code&gt;insert-directory-program&lt;/code&gt; にあるディレクトリリストプログラムを実行することによって機能します。 &lt;var&gt;wildcard&lt;/var&gt; が &lt;code&gt;nil&lt;/code&gt; 以外の場合は、 &lt;code&gt;shell-file-name&lt;/code&gt; で指定されたシェルも実行して、ワイルドカードを展開します。</target>
        </trans-unit>
        <trans-unit id="6d4535f8da402c43490a2180be3f0732c9111726" translate="yes" xml:space="preserve">
          <source>On multi-monitor displays it is possible to use the command &lt;code&gt;make-frame-on-monitor&lt;/code&gt; to make frames on the specified monitor.</source>
          <target state="translated">マルチモニターディスプレイでは、コマンド &lt;code&gt;make-frame-on-monitor&lt;/code&gt; を使用して、指定したモニターでフレームを作成できます。</target>
        </trans-unit>
        <trans-unit id="424aff0ac8fca763b6c89e454a579a4f615d419e" translate="yes" xml:space="preserve">
          <source>On some multi-monitor setups, a single X display outputs to more than one physical monitor. You can use the functions &lt;code&gt;display-monitor-attributes-list&lt;/code&gt; and &lt;code&gt;frame-monitor-attributes&lt;/code&gt; to obtain information about such setups.</source>
          <target state="translated">一部のマルチモニター設定では、単一のXディスプレイが複数の物理モニターに出力されます。関数 &lt;code&gt;display-monitor-attributes-list&lt;/code&gt; および &lt;code&gt;frame-monitor-attributes&lt;/code&gt; を使用して、このような設定に関する情報を取得できます。</target>
        </trans-unit>
        <trans-unit id="25a3df6f65657e687d2e69c45bc13942a081601f" translate="yes" xml:space="preserve">
          <source>On some operating systems, an absolute file name begins with a device name. On such systems, &lt;var&gt;filename&lt;/var&gt; has no relative equivalent based on &lt;var&gt;directory&lt;/var&gt; if they start with two different device names. In this case, &lt;code&gt;file-relative-name&lt;/code&gt; returns &lt;var&gt;filename&lt;/var&gt; in absolute form.</source>
          <target state="translated">一部のオペレーティングシステムでは、絶対ファイル名はデバイス名で始まります。このようなシステムでは、 &lt;var&gt;filename&lt;/var&gt; が2つの異なるデバイス名で始まる場合、 &lt;var&gt;directory&lt;/var&gt; 基づく相対的な同等物はありません。この場合、 &lt;code&gt;file-relative-name&lt;/code&gt; は &lt;var&gt;filename&lt;/var&gt; を絶対形式で返します。</target>
        </trans-unit>
        <trans-unit id="213a628dbf886420d394fb191adc21bae49c70bf" translate="yes" xml:space="preserve">
          <source>On some operating systems, each file can be associated with arbitrary &lt;em&gt;extended file attributes&lt;/em&gt;. At present, Emacs supports querying and setting two specific sets of extended file attributes: Access Control Lists (ACLs) and SELinux contexts. These extended file attributes are used, on some systems, to impose more sophisticated file access controls than the basic Unix-style permissions discussed in the previous sections.</source>
          <target state="translated">一部のオペレーティングシステムでは、各ファイルを任意の&lt;em&gt;拡張ファイル属性に&lt;/em&gt;関連付けることが&lt;em&gt;できます&lt;/em&gt;。現在、Emacsは、アクセス制御リスト（ACL）とSELinuxコンテキストという2つの特定の拡張ファイル属性セットのクエリと設定をサポートしています。これらの拡張ファイル属性は、一部のシステムでは、前のセクションで説明した基本的なUnixスタイルのアクセス許可よりも高度なファイルアクセス制御を課すために使用されます。</target>
        </trans-unit>
        <trans-unit id="73e008db2f82ffdcf0d72c8e1923a9faeb539e93" translate="yes" xml:space="preserve">
          <source>On some operating systems, more complex sets of access permissions can be specified, via mechanisms such as Access Control Lists (ACLs). See &lt;a href=&quot;extended-attributes#Extended-Attributes&quot;&gt;Extended Attributes&lt;/a&gt;, for how to query and set those permissions.</source>
          <target state="translated">一部のオペレーティングシステムでは、アクセス制御リスト（ACL）などのメカニズムを介して、より複雑なアクセス許可のセットを指定できます。これらの権限を照会および設定する方法については、&lt;a href=&quot;extended-attributes#Extended-Attributes&quot;&gt;拡張属性を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="c32f84426cac9a32d45d101e0d8f5f9e2996aa5c" translate="yes" xml:space="preserve">
          <source>On some systems, when Emacs reads the output from a subprocess, the output data is read in very small blocks, potentially resulting in very poor performance. This behavior can be remedied to some extent by setting the variable &lt;code&gt;process-adaptive-read-buffering&lt;/code&gt; to a non-&lt;code&gt;nil&lt;/code&gt; value (the default), as it will automatically delay reading from such processes, thus allowing them to produce more output before Emacs tries to read it.</source>
          <target state="translated">一部のシステムでは、Emacsがサブプロセスから出力を読み取るときに、出力データが非常に小さなブロックで読み取られるため、パフォーマンスが非常に低下する可能性があります。この動作は、変数 &lt;code&gt;process-adaptive-read-buffering&lt;/code&gt; を &lt;code&gt;nil&lt;/code&gt; 以外の値（デフォルト）に設定することである程度改善できます。これは、このようなプロセスからの読み取りを自動的に遅らせ、Emacsが試行する前により多くの出力を生成できるようにするためです。それを読むために。</target>
        </trans-unit>
        <trans-unit id="819b49b75e3e8487d55fbdd732a2765e416d401d" translate="yes" xml:space="preserve">
          <source>On success, it returns a list of a binary string (the output) and the IV used.</source>
          <target state="translated">成功すると、バイナリ文字列のリスト(出力)と使用された IV を返します。</target>
        </trans-unit>
        <trans-unit id="5b8c9a445132c5cf6d56dccf077cd1f1c5b172c2" translate="yes" xml:space="preserve">
          <source>On text terminals, it is possible to &lt;em&gt;suspend Emacs&lt;/em&gt;, which means stopping Emacs temporarily and returning control to its superior process, which is usually the shell. This allows you to resume editing later in the same Emacs process, with the same buffers, the same kill ring, the same undo history, and so on. To resume Emacs, use the appropriate command in the parent shell&amp;mdash;most likely &lt;code&gt;fg&lt;/code&gt;.</source>
          <target state="translated">テキスト端末では、&lt;em&gt;Emacs&lt;/em&gt;を&lt;em&gt;一時停止する&lt;/em&gt;ことができます。つまり、Emacsを一時的に停止し、制御を上位のプロセス（通常はシェル）に戻します。これにより、同じEmacsプロセスの後半で、同じバッファー、同じキルリング、同じ元に戻す履歴などを使用して編集を再開できます。Emacsを再開するには、親シェルで適切なコマンド（おそらく &lt;code&gt;fg&lt;/code&gt; )を使用します。</target>
        </trans-unit>
        <trans-unit id="77e13395725f09ad2c8856d110ef6337fce6ac46" translate="yes" xml:space="preserve">
          <source>On text terminals, suspending and resuming Emacs normally also refreshes the screen. Some terminal emulators record separate contents for display-oriented programs such as Emacs and for ordinary sequential display. If you are using such a terminal, you might want to inhibit the redisplay on resumption.</source>
          <target state="translated">テキスト端末では,通常,Emacs を中断して再開すると画面も更新される.端末エミュレータの中には、Emacsのような表示重視のプログラム用と通常の逐次表示用に別々の内容を記録しているものがあります。そのような端末を使用している場合は、再開時の再表示を抑制した方が良いかもしれません。</target>
        </trans-unit>
        <trans-unit id="20d88ccd4c937138f50db938fd11563e2dd25a8e" translate="yes" xml:space="preserve">
          <source>On text terminals, the line spacing cannot be altered.</source>
          <target state="translated">テキスト端末では、行間の変更はできません。</target>
        </trans-unit>
        <trans-unit id="e069fc175afc43cf759588b838318611f81e51ce" translate="yes" xml:space="preserve">
          <source>On the other hand, &lt;code&gt;assq&lt;/code&gt; is not usually useful in alists where the keys may not be symbols:</source>
          <target state="translated">一方、 &lt;code&gt;assq&lt;/code&gt; は通常、キーがシンボルではない可能性のあるリストでは役に立ちません。</target>
        </trans-unit>
        <trans-unit id="2812f8f2bcfa7413b908d5f9a288205c2972743e" translate="yes" xml:space="preserve">
          <source>On the other hand, the order of &lt;em&gt;bindings&lt;/em&gt; is unspecified: in the following example, either 1 or 2 might be printed.</source>
          <target state="translated">一方、&lt;em&gt;バインディング&lt;/em&gt;の順序は指定されていません。次の例では、1または2のいずれかが出力される可能性があります。</target>
        </trans-unit>
        <trans-unit id="5f85ff0be4cebfcaf47b004ec226b3b02a71dc33" translate="yes" xml:space="preserve">
          <source>On the whole, Emacs follows the Unicode Standard in its implementation of character properties. In particular, Emacs supports the &lt;a href=&quot;https://www.unicode.org/reports/tr23/&quot;&gt;Unicode Character Property Model&lt;/a&gt;, and the Emacs character property database is derived from the Unicode Character Database (</source>
          <target state="translated">全体として、Emacsは文字プロパティの実装においてUnicode標準に従います。特に、Emacsは&lt;a href=&quot;https://www.unicode.org/reports/tr23/&quot;&gt;Unicode文字プロパティモデルを&lt;/a&gt;サポートしており、Emacs文字プロパティデータベースはUnicode文字データベースから派生しています（</target>
        </trans-unit>
        <trans-unit id="0df1af20ccce16453cf49d86077bec23de12dd86" translate="yes" xml:space="preserve">
          <source>On window systems that support it, Emacs tries by default to make the text size of a frame measured in pixels a multiple of the frame&amp;rsquo;s character size. This, however, usually means that a frame can be resized only in character size increments when dragging its external borders. It also may break attempts to truly maximize the frame or making it &amp;ldquo;fullheight&amp;rdquo; or &amp;ldquo;fullwidth&amp;rdquo; (see &lt;a href=&quot;size-parameters#Size-Parameters&quot;&gt;Size Parameters&lt;/a&gt;) leaving some empty space below and/or on the right of the frame. The following option may help in that case.</source>
          <target state="translated">それをサポートするウィンドウシステムでは、Emacsはデフォルトで、ピクセル単位で測定されたフレームのテキストサイズをフレームの文字サイズの倍数にしようとします。ただし、これは通常、フレームの外側の境界線をドラッグするときに、文字サイズの増分でのみフレームのサイズを変更できることを意味します。また、フレームを真に最大化する試みや、フレームを「全角」または「全角」にする試み（&lt;a href=&quot;size-parameters#Size-Parameters&quot;&gt;サイズパラメータを&lt;/a&gt;参照）を中断し、フレームの下や右側に空きスペースを残す場合があります。その場合、次のオプションが役立つ場合があります。</target>
        </trans-unit>
        <trans-unit id="841d1d478ab20c6c338cac784c3bcdb7e40083b9" translate="yes" xml:space="preserve">
          <source>On window systems, you can also enable auto-raising (on frame selection) or auto-lowering (on frame deselection) using frame parameters. See &lt;a href=&quot;management-parameters#Management-Parameters&quot;&gt;Management Parameters&lt;/a&gt;.</source>
          <target state="translated">ウィンドウシステムでは、フレームパラメータを使用して自動上昇（フレーム選択時）または自動下降（フレーム選択解除時）を有効にすることもできます。&lt;a href=&quot;management-parameters#Management-Parameters&quot;&gt;管理パラメータを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="77c8d598496ec2e71e45a895d0ca263179948375" translate="yes" xml:space="preserve">
          <source>On-demand loading of support libraries.</source>
          <target state="translated">サポートライブラリのオンデマンドロード</target>
        </trans-unit>
        <trans-unit id="ad07b4aac29586e1b0b7c1f1bda28884c7ab4bca" translate="yes" xml:space="preserve">
          <source>Once Emacs decides that a certain handler handles the error, it returns control to that handler. To do so, Emacs unbinds all variable bindings made by binding constructs that are being exited, and executes the cleanups of all &lt;code&gt;unwind-protect&lt;/code&gt; forms that are being exited. Once control arrives at the handler, the body of the handler executes normally.</source>
          <target state="translated">Emacsは、特定のハンドラーがエラーを処理すると判断すると、そのハンドラーに制御を戻します。そうするために、Emacsは、終了しているバインディングコンストラクトによって作成されたすべての変数バインディングをアンバインドし、終了しているすべての &lt;code&gt;unwind-protect&lt;/code&gt; フォームのクリーンアップを実行します。制御がハンドラーに到達すると、ハンドラーの本体は正常に実行されます。</target>
        </trans-unit>
        <trans-unit id="778c77b00697e4553fcdfbf4f104e11fe2eb93ee" translate="yes" xml:space="preserve">
          <source>Once a function is instrumented, any call to the function activates Edebug. Depending on which Edebug execution mode you have selected, activating Edebug may stop execution and let you step through the function, or it may update the display and continue execution while checking for debugging commands. The default execution mode is step, which stops execution. See &lt;a href=&quot;edebug-execution-modes#Edebug-Execution-Modes&quot;&gt;Edebug Execution Modes&lt;/a&gt;.</source>
          <target state="translated">関数がインストルメントされると、関数を呼び出すとEdebugがアクティブになります。選択したEdebug実行モードによっては、Edebugをアクティブにすると、実行が停止して機能をステップ実行できる場合や、デバッグコマンドを確認しながら表示を更新して実行を続行する場合があります。デフォルトの実行モードはstepで、実行を停止します。&lt;a href=&quot;edebug-execution-modes#Edebug-Execution-Modes&quot;&gt;Edebug実行モードを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="7e4ee3d26197fcab8232cca69fb16d0f05f95688" translate="yes" xml:space="preserve">
          <source>Once a series has begun, the value is a marker which points to the buffer position in the warnings buffer of the start of the series.</source>
          <target state="translated">系列が開始されると、その値は系列の開始時の警告バッファのバッファ位置を指すマーカーとなります。</target>
        </trans-unit>
        <trans-unit id="36b6d567cfa67a7659808b6d1ff19d545a0d2c63" translate="yes" xml:space="preserve">
          <source>Once set up, side windows also change the behavior of the commands &lt;code&gt;switch-to-prev-buffer&lt;/code&gt; and &lt;code&gt;switch-to-next-buffer&lt;/code&gt; (see &lt;a href=&quot;window-history#Window-History&quot;&gt;Window History&lt;/a&gt;). In particular, these commands will refrain from showing, in a side window, buffers that have not been displayed in that window before. They will also refrain from having a normal, non-side window show a buffer that has been already displayed in a side window. A notable exception to the latter rule occurs when an application, after displaying a buffer, resets that buffer&amp;rsquo;s local variables.</source>
          <target state="translated">セットアップが完了すると、サイドウィンドウはコマンド &lt;code&gt;switch-to-prev-buffer&lt;/code&gt; および &lt;code&gt;switch-to-next-buffer&lt;/code&gt; の動作も変更します（&lt;a href=&quot;window-history#Window-History&quot;&gt;ウィンドウ履歴を&lt;/a&gt;参照）。特に、これらのコマンドは、サイドウィンドウに、以前はそのウィンドウに表示されていなかったバッファを表示しません。また、通常の非サイドウィンドウに、サイドウィンドウにすでに表示されているバッファを表示することも控えます。後者のルールの注目すべき例外は、アプリケーションがバッファを表示した後、そのバッファのローカル変数をリセットしたときに発生します。</target>
        </trans-unit>
        <trans-unit id="46c1926d71b4e8e4b97adb3110fa61cac0093fb9" translate="yes" xml:space="preserve">
          <source>Once the buffer has a suitable &lt;code&gt;revert-buffer-function&lt;/code&gt; and &lt;code&gt;buffer-stale-function&lt;/code&gt;, several problems usually remain.</source>
          <target state="translated">バッファに適切な &lt;code&gt;revert-buffer-function&lt;/code&gt; と &lt;code&gt;buffer-stale-function&lt;/code&gt; が含まれると、通常、いくつかの問題が残ります。</target>
        </trans-unit>
        <trans-unit id="59381f9a9d9f927b9e2c3c74e1d9f85d8c8d831a" translate="yes" xml:space="preserve">
          <source>Once the mark exists in a buffer, it normally never ceases to exist. However, it may become &lt;em&gt;inactive&lt;/em&gt;, if Transient Mark mode is enabled. The buffer-local variable &lt;code&gt;mark-active&lt;/code&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, means that the mark is active. A command can call the function &lt;code&gt;deactivate-mark&lt;/code&gt; to deactivate the mark directly, or it can request deactivation of the mark upon return to the editor command loop by setting the variable &lt;code&gt;deactivate-mark&lt;/code&gt; to a non-&lt;code&gt;nil&lt;/code&gt; value.</source>
          <target state="translated">マークがバッファに存在すると、通常は存在しなくなることはありません。ただし、トランジェントマークモードが有効になっている場合は、&lt;em&gt;非アクティブ&lt;/em&gt;になる可能性があります。バッファローカル変数 &lt;code&gt;mark-active&lt;/code&gt; は、 &lt;code&gt;nil&lt;/code&gt; 以外の場合、マークがアクティブであることを意味します。コマンドは、関数 &lt;code&gt;deactivate-mark&lt;/code&gt; を呼び出してマークを直接非アクティブ化するか、変数 &lt;code&gt;deactivate-mark&lt;/code&gt; を &lt;code&gt;nil&lt;/code&gt; 以外の値に設定することにより、エディターコマンドループに戻ったときにマークの非アクティブ化を要求できます。</target>
        </trans-unit>
        <trans-unit id="197124b549991ea7d2db5253b6de18d693ff5eb3" translate="yes" xml:space="preserve">
          <source>Once the variable has a value, you can refer to it by using the symbol itself as an expression. Thus,</source>
          <target state="translated">変数が値を持つようになると、シンボル自体を式として使うことで、その値を参照することができます。このように</target>
        </trans-unit>
        <trans-unit id="fd18cae1d555d9632ceb9466f9b376521bcb7fd1" translate="yes" xml:space="preserve">
          <source>Once you scroll a window as far right as it can go, back to its normal position where the total leftward scrolling is zero, attempts to scroll any farther right have no effect.</source>
          <target state="translated">一度、ウィンドウを右方向にスクロールして、左方向へのスクロールの合計がゼロになる通常の位置に戻すと、それ以上右方向にスクロールしようとしても何の効果もありません。</target>
        </trans-unit>
        <trans-unit id="e2ef1484d788b8e71ea675fa55e9514ec4d62317" translate="yes" xml:space="preserve">
          <source>Once your module function detected that a nonlocal exit is pending, it can either return to Emacs (after performing the necessary local cleanup), or it can attempt to recover from the nonlocal exit. The following</source>
          <target state="translated">モジュール機能が非ローカル終了が保留中であることを検出すると、(必要なローカルクリーンアップを実行した後に)Emacsに戻るか、非ローカル終了からの回復を試みることができます。以下のように、モジュール関数が非ローカル終了を検出した場合は</target>
        </trans-unit>
        <trans-unit id="d1513ef69753da579d30dff357ebb3c01e465563" translate="yes" xml:space="preserve">
          <source>Once your module is written, compile it to produce a shared library, according to the conventions of the underlying platform. Then place the shared library in a directory mentioned in &lt;code&gt;load-path&lt;/code&gt; (see &lt;a href=&quot;library-search#Library-Search&quot;&gt;Library Search&lt;/a&gt;), where Emacs will find it.</source>
          <target state="translated">モジュールを作成したら、基盤となるプラットフォームの規則に従って、モジュールをコンパイルして共有ライブラリを作成します。次に、共有ライブラリを &lt;code&gt;load-path&lt;/code&gt; （&lt;a href=&quot;library-search#Library-Search&quot;&gt;ライブラリ検索を&lt;/a&gt;参照）に記載されているディレクトリに配置します。ここで、Emacsがそれを見つけます。</target>
        </trans-unit>
        <trans-unit id="f3c0b70cb22f00da9b2ba81dbf3bf978932a071a" translate="yes" xml:space="preserve">
          <source>One &amp;lsquo;</source>
          <target state="translated">1 '</target>
        </trans-unit>
        <trans-unit id="4adda958bb416b9b9ce93994e71859b6fceded90" translate="yes" xml:space="preserve">
          <source>One example of a case where this variable makes a difference is when the default font has no italic equivalent. With the default ordering, the &lt;code&gt;italic&lt;/code&gt; face will use a non-italic font that is similar to the default one. But if you put &lt;code&gt;:slant&lt;/code&gt; before &lt;code&gt;:height&lt;/code&gt;, the &lt;code&gt;italic&lt;/code&gt; face will use an italic font, even if its height is not quite right.</source>
          <target state="translated">この変数が違いを生むケースの一例は、デフォルトのフォントにイタリックに相当するものがない場合です。デフォルトの順序では、 &lt;code&gt;italic&lt;/code&gt; はデフォルトのフォントと同様の非イタリックフォントを使用します。ただし、 &lt;code&gt;:height&lt;/code&gt; の前に &lt;code&gt;:slant&lt;/code&gt; を付けると、高さが正しくない場合でも、 &lt;code&gt;italic&lt;/code&gt; 面は斜体のフォントを使用します。</target>
        </trans-unit>
        <trans-unit id="577e046c059fefb7e07e716cb84ee3c1d1a8d0ea" translate="yes" xml:space="preserve">
          <source>One object can have multiple textual representations. For example, &amp;lsquo;</source>
          <target state="translated">1つのオブジェクトに複数のテキスト表現を含めることができます。例えば、 '</target>
        </trans-unit>
        <trans-unit id="e131db88539c1a117d848bab11ab32a20ff4ae32" translate="yes" xml:space="preserve">
          <source>One of the effects of making a minor mode global is that the &lt;var&gt;mode&lt;/var&gt; variable becomes a customization variable. Toggling it through the Customize interface turns the mode on and off, and its value can be saved for future Emacs sessions (see &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Saving-Customizations.html#Saving-Customizations&quot;&gt;Saving Customizations&lt;/a&gt; in</source>
          <target state="translated">マイナーモードをグローバルにすることの効果の1つは、 &lt;var&gt;mode&lt;/var&gt; 変数がカスタマイズ変数になることです。カスタマイズインタフェースを介して、それを切り替えると、オンとオフモードになり、その値は、将来のEmacsセッション（参照のために保存することができます&lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Saving-Customizations.html#Saving-Customizations&quot;&gt;保存のカスタマイズの&lt;/a&gt;中で</target>
        </trans-unit>
        <trans-unit id="a45c275128e0b9c2732acf99d11b72a739cabbf7" translate="yes" xml:space="preserve">
          <source>One of the elements is &lt;code&gt;(acl . &lt;var&gt;acl&lt;/var&gt;)&lt;/code&gt;, where &lt;var&gt;acl&lt;/var&gt; has the same form returned by &lt;code&gt;file-acl&lt;/code&gt;.</source>
          <target state="translated">要素の一つである &lt;code&gt;(acl . &lt;var&gt;acl&lt;/var&gt;)&lt;/code&gt; 、 &lt;var&gt;acl&lt;/var&gt; によって返される同じ形式は &lt;code&gt;file-acl&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="33b9427a7425593acc13906a9fe5a0f436f2867b" translate="yes" xml:space="preserve">
          <source>One of the files in the content directory must be named</source>
          <target state="translated">コンテンツディレクトリ内のファイルの1つは</target>
        </trans-unit>
        <trans-unit id="889f4e481c60baff17ff497b3fc3a3ae3d75286d" translate="yes" xml:space="preserve">
          <source>One or more flag characters can appear immediately after the &amp;lsquo;</source>
          <target state="translated">'の直後に1つ以上のフラグ文字を表示できます</target>
        </trans-unit>
        <trans-unit id="b9aff7d2a1cda9fb1100f1f1c7d6d8ce23f3a07d" translate="yes" xml:space="preserve">
          <source>One possible consequence of this process is an infinite loop, in the event that a symbol&amp;rsquo;s function cell refers to the same symbol. Otherwise, we eventually obtain a non-symbol, which ought to be a function or other suitable object.</source>
          <target state="translated">このプロセスの考えられる結果の1つは、シンボルの関数セルが同じシンボルを参照している場合の無限ループです。そうでなければ、最終的には、関数または他の適切なオブジェクトであるはずの非シンボルを取得します。</target>
        </trans-unit>
        <trans-unit id="2efc7bf28038f291b21bb7d6c5b6e4024d66a9f9" translate="yes" xml:space="preserve">
          <source>One potential reason for such a failure to instrument is that some macro definitions are not yet known to Emacs. To work around this, load the file which defines the function you are about to instrument.</source>
          <target state="translated">このようなインストルメントに失敗する原因として、マクロの定義が Emacs にはまだ知られていないものがあることが考えられます。これを回避するには、インストルメントしようとしている関数を定義しているファイルをロードします。</target>
        </trans-unit>
        <trans-unit id="c73c9472ca68902783f9eff8fc7a9275e411bae6" translate="yes" xml:space="preserve">
          <source>One responsibility of &lt;var&gt;from-fn&lt;/var&gt; is to make sure that the beginning of the file no longer matches &lt;var&gt;regexp&lt;/var&gt;. Otherwise it is likely to get called again. Also, &lt;var&gt;from-fn&lt;/var&gt; must not involve buffers or files other than the one being decoded, otherwise the internal buffer used for formatting might be overwritten.</source>
          <target state="translated">&lt;var&gt;from-fn&lt;/var&gt; の1つの責任は、ファイルの先頭が &lt;var&gt;regexp&lt;/var&gt; 一致しないことを確認することです。そうしないと、再度呼び出される可能性があります。また、 &lt;var&gt;from-fn&lt;/var&gt; には、デコードされるもの以外のバッファまたはファイルを含めることはできません。含まない場合、フォーマットに使用される内部バッファが上書きされる可能性があります。</target>
        </trans-unit>
        <trans-unit id="a512c4c508943629411341265b0a1b3580ada561" translate="yes" xml:space="preserve">
          <source>One special kind of side effect can&amp;rsquo;t be avoided: constructing Lisp objects. Almost all macro expansions include constructed lists; that is the whole point of most macros. This is usually safe; there is just one case where you must be careful: when the object you construct is part of a quoted constant in the macro expansion.</source>
          <target state="translated">1つの特別な種類の副作用は避けられません：Lispオブジェクトの構築。ほとんどすべてのマクロ展開には、作成されたリストが含まれています。それがほとんどのマクロの要点です。これは通常安全です。注意が必要なケースは1つだけです。作成するオブジェクトが、マクロ展開で引用符で囲まれた定数の一部である場合です。</target>
        </trans-unit>
        <trans-unit id="c55a9d4e3055cc50dcbf39304bdeafccb27e6553" translate="yes" xml:space="preserve">
          <source>One unusual thing about this command is that the entire line containing position &lt;var&gt;beg&lt;/var&gt;, and the entire line containing position &lt;var&gt;end&lt;/var&gt;, are included in the region sorted.</source>
          <target state="translated">このコマンドの珍しい点の1つは、位置 &lt;var&gt;beg&lt;/var&gt; を含む行全体、および位置 &lt;var&gt;end&lt;/var&gt; を含む行全体がソートされた領域に含まれることです。</target>
        </trans-unit>
        <trans-unit id="a2d226d6e0986fd5ff1e62cb952a91648093c02f" translate="yes" xml:space="preserve">
          <source>One use for &lt;code&gt;image-flush&lt;/code&gt; is to tell Emacs about a change in an image file. If an image specification contains a &lt;code&gt;:file&lt;/code&gt; property, the image is cached based on the file&amp;rsquo;s contents when the image is first displayed. Even if the file subsequently changes, Emacs continues displaying the old version of the image. Calling &lt;code&gt;image-flush&lt;/code&gt; flushes the image from the cache, forcing Emacs to re-read the file the next time it needs to display that image.</source>
          <target state="translated">&lt;code&gt;image-flush&lt;/code&gt; の使用法の1つは、画像ファイルの変更についてEmacsに通知することです。画像仕様に &lt;code&gt;:file&lt;/code&gt; プロパティが含まれている場合、画像は、画像が最初に表示されたときのファイルの内容に基づいてキャッシュされます。その後ファイルが変更されても、Emacsは古いバージョンの画像を表示し続けます。 &lt;code&gt;image-flush&lt;/code&gt; を呼び出すと、キャッシュから画像がフラッシュされ、次にその画像を表示する必要があるときにEmacsにファイルの再読み取りが強制されます。</target>
        </trans-unit>
        <trans-unit id="6f05610b66d19812d3d46bdeffc2bf46fe230ffa" translate="yes" xml:space="preserve">
          <source>One use of &lt;code&gt;regexp-quote&lt;/code&gt; is to combine an exact string match with context described as a regular expression. For example, this searches for the string that is the value of &lt;var&gt;string&lt;/var&gt;, surrounded by whitespace:</source>
          <target state="translated">&lt;code&gt;regexp-quote&lt;/code&gt; の使用法の1つは、文字列の完全一致を正規表現として記述されたコンテキストと組み合わせることです。たとえば、これは空白で囲まれた文字 &lt;var&gt;string&lt;/var&gt; の値である文字列を検索します。</target>
        </trans-unit>
        <trans-unit id="6b443615f7088e219757f3ce2e0767b4fb5de64b" translate="yes" xml:space="preserve">
          <source>One use of focus redirection is for frames that don&amp;rsquo;t have minibuffers. These frames use minibuffers on other frames. Activating a minibuffer on another frame redirects focus to that frame. This puts the focus on the minibuffer&amp;rsquo;s frame, where it belongs, even though the mouse remains in the frame that activated the minibuffer.</source>
          <target state="translated">フォーカスリダイレクトの使用法の1つは、ミニバッファーを持たないフレームの場合です。これらのフレームは、他のフレームでミニバッファを使用します。別のフレームでミニバッファーをアクティブにすると、フォーカスがそのフレームにリダイレクトされます。これにより、ミニバッファをアクティブにしたフレームにマウスが残っていても、ミニバッファが属するフレームにフォーカスが移ります。</target>
        </trans-unit>
        <trans-unit id="55ca5f8a1f3a2f9f4a1e3fefe222967bb4301ed6" translate="yes" xml:space="preserve">
          <source>One use of minor mode keymaps is to modify the behavior of certain self-inserting characters so that they do something else as well as self-insert. (Another way to customize &lt;code&gt;self-insert-command&lt;/code&gt; is through &lt;code&gt;post-self-insert-hook&lt;/code&gt;, see &lt;a href=&quot;commands-for-insertion#Commands-for-Insertion&quot;&gt;Commands for Insertion&lt;/a&gt;. Apart from this, the facilities for customizing &lt;code&gt;self-insert-command&lt;/code&gt; are limited to special cases, designed for abbrevs and Auto Fill mode. Do not try substituting your own definition of &lt;code&gt;self-insert-command&lt;/code&gt; for the standard one. The editor command loop handles this function specially.)</source>
          <target state="translated">マイナーモードキーマップの使用法の1つは、特定の自己挿入文字の動作を変更して、自己挿入だけでなく他のことも実行するようにすることです。 （ &lt;code&gt;self-insert-command&lt;/code&gt; をカスタマイズする別の方法は &lt;code&gt;post-self-insert-hook&lt;/code&gt; を使用することです。&lt;a href=&quot;commands-for-insertion#Commands-for-Insertion&quot;&gt;挿入のコマンドを&lt;/a&gt;参照してください。これとは別に、 &lt;code&gt;self-insert-command&lt;/code&gt; をカスタマイズする機能は、略語と自動入力用に設計された特別な場合に限定されます。モード。標準の &lt;code&gt;self-insert-command&lt;/code&gt; 独自の定義を置き換えようとしないでください。エディターコマンドループは、この関数を特別に処理します。）</target>
        </trans-unit>
        <trans-unit id="964a845b7c3be261e46e6c16cfdd2b39ae693122" translate="yes" xml:space="preserve">
          <source>One use of this function is in preparation for defining a longer key that uses &lt;var&gt;key&lt;/var&gt; as a prefix&amp;mdash;which would not be allowed if &lt;var&gt;key&lt;/var&gt; has a non-prefix binding. For example:</source>
          <target state="translated">この関数の使用法の1つは、 &lt;var&gt;key&lt;/var&gt; をプレフィックスとして使用する長いキーを定義する準備です。これは、 &lt;var&gt;key&lt;/var&gt; にプレフィックス以外のバインディングがある場合は許可されません。例えば：</target>
        </trans-unit>
        <trans-unit id="992da344af8495da1bf5875640a42f02ebd76cdf" translate="yes" xml:space="preserve">
          <source>One use of this function is to define function keys on terminals that have downloadable function key definitions. For example, this is how (on certain terminals) to define function key 4 to move forward four characters (by transmitting the characters</source>
          <target state="translated">この機能の用途の一つは、ダウンロード可能なファンクションキー定義を持つ端末でファンクションキーを定義することである。例えば、以下のように(特定の端末で)ファンクションキー4を定義して、4つの文字を前進させることができます。</target>
        </trans-unit>
        <trans-unit id="023abc72efceee06dfb7ea03706101194c813d2e" translate="yes" xml:space="preserve">
          <source>One use of this variable is for telling &lt;code&gt;x-popup-menu&lt;/code&gt; where to pop up a menu. It is also used internally by &lt;code&gt;y-or-n-p&lt;/code&gt; (see &lt;a href=&quot;yes_002dor_002dno-queries#Yes_002dor_002dNo-Queries&quot;&gt;Yes-or-No Queries&lt;/a&gt;).</source>
          <target state="translated">この変数の使用法の1つは、 &lt;code&gt;x-popup-menu&lt;/code&gt; にメニューをポップアップする場所を指示することです。また、 &lt;code&gt;y-or-n-p&lt;/code&gt; によって内部的に使用されます（&lt;a href=&quot;yes_002dor_002dno-queries#Yes_002dor_002dNo-Queries&quot;&gt;Yes-or-Noクエリを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="bde8277d79875f5ea95a8ec30aa3980302baf104" translate="yes" xml:space="preserve">
          <source>One way or another, these mechanisms specify a Lisp value for the spacing of each line. The value is a height spec, and it translates into a Lisp value as described above. However, in this case the numeric height value specifies the line spacing, rather than the line height.</source>
          <target state="translated">一つの方法または別の方法で、これらのメカニズムは、各行の間隔のためのLisp値を指定します。この値は高さの指定であり、上述のようにLisp値に変換されます。しかし、この場合、高さの数値は行の高さではなく、行の間隔を指定します。</target>
        </trans-unit>
        <trans-unit id="f712e3c7ea934966609bea4ea08c88d53b0d34d7" translate="yes" xml:space="preserve">
          <source>One way to avoid pathological cases like this is to think of &lt;code&gt;empty-object&lt;/code&gt; as a funny kind of constant, not as a memory allocation construct. You wouldn&amp;rsquo;t use &lt;code&gt;setcar&lt;/code&gt; on a constant such as &lt;code&gt;'(nil)&lt;/code&gt;, so naturally you won&amp;rsquo;t use it on &lt;code&gt;(empty-object)&lt;/code&gt; either.</source>
          <target state="translated">このような病的なケースを回避する1つの方法は、 &lt;code&gt;empty-object&lt;/code&gt; を、メモリ割り当て構造としてではなく、面白​​い種類の定数として考えることです。 &lt;code&gt;'(nil)&lt;/code&gt; などの定数で &lt;code&gt;setcar&lt;/code&gt; を使用しないので、当然、 &lt;code&gt;(empty-object)&lt;/code&gt; でも使用しません。</target>
        </trans-unit>
        <trans-unit id="21005527907c627869027aeb58d2b47e207aa33d" translate="yes" xml:space="preserve">
          <source>One way to cope with circular structure is to set &lt;code&gt;print-length&lt;/code&gt; or &lt;code&gt;print-level&lt;/code&gt; to truncate the printing. Edebug does this for you; it binds &lt;code&gt;print-length&lt;/code&gt; and &lt;code&gt;print-level&lt;/code&gt; to the values of the variables &lt;code&gt;edebug-print-length&lt;/code&gt; and &lt;code&gt;edebug-print-level&lt;/code&gt; (so long as they have non-&lt;code&gt;nil&lt;/code&gt; values). See &lt;a href=&quot;output-variables#Output-Variables&quot;&gt;Output Variables&lt;/a&gt;.</source>
          <target state="translated">円形構造に対処する1つの方法は、 &lt;code&gt;print-length&lt;/code&gt; または &lt;code&gt;print-level&lt;/code&gt; を設定して印刷を切り捨てることです。Edebugがこれを行います。それが結合する &lt;code&gt;print-length&lt;/code&gt; と &lt;code&gt;print-level&lt;/code&gt; 変数の値に &lt;code&gt;edebug-print-length&lt;/code&gt; と &lt;code&gt;edebug-print-level&lt;/code&gt; （限り、それらが非有するように &lt;code&gt;nil&lt;/code&gt; 値）。&lt;a href=&quot;output-variables#Output-Variables&quot;&gt;出力変数を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="fb79df4c6bc7c681333d9bd2d1fe18512e30d371" translate="yes" xml:space="preserve">
          <source>One way to ensure reliable rehighlighting of multiline Font Lock constructs is to put on them the text property &lt;code&gt;font-lock-multiline&lt;/code&gt;. It should be present and non-&lt;code&gt;nil&lt;/code&gt; for text that is part of a multiline construct.</source>
          <target state="translated">複数行のフォントロック構造を確実に再強調表示する1つの方法は、テキストプロパティ &lt;code&gt;font-lock-multiline&lt;/code&gt; を配置することです。複数行の構成の一部であるテキストの場合は、存在し、 &lt;code&gt;nil&lt;/code&gt; 以外である必要があります。</target>
        </trans-unit>
        <trans-unit id="c715d20a7533e9f52b8676dee0de643ff507bb6b" translate="yes" xml:space="preserve">
          <source>One way to increase the security of your packages is to &lt;em&gt;sign&lt;/em&gt; them using a cryptographic key. If you have generated a private/public gpg key pair, you can use gpg to sign the package like this:</source>
          <target state="translated">パッケージのセキュリティを強化する1つの方法は、暗号化キーを使用してパッケージに&lt;em&gt;署名&lt;/em&gt;することです。秘密/公開gpgキーのペアを生成した場合は、gpgを使用して次のようにパッケージに署名できます。</target>
        </trans-unit>
        <trans-unit id="fbc2d56b429ee910d28dbf2fbd89ff2226fc991f" translate="yes" xml:space="preserve">
          <source>One way to represent a face is as a property list of attributes, like &lt;code&gt;(:foreground &quot;red&quot; :weight bold)&lt;/code&gt;. Such a list is called an &lt;em&gt;anonymous face&lt;/em&gt;. For example, you can assign an anonymous face as the value of the &lt;code&gt;face&lt;/code&gt; text property, and Emacs will display the underlying text with the specified attributes. See &lt;a href=&quot;special-properties#Special-Properties&quot;&gt;Special Properties&lt;/a&gt;.</source>
          <target state="translated">顔を表す1つの方法は、 &lt;code&gt;(:foreground &quot;red&quot; :weight bold)&lt;/code&gt; ような属性のプロパティリストとして使用することです。このようなリストは&lt;em&gt;匿名の顔&lt;/em&gt;と呼ばれます。たとえば、 &lt;code&gt;face&lt;/code&gt; textプロパティの値として匿名の顔を割り当てることができ、Emacsは指定された属性で基になるテキストを表示します。&lt;a href=&quot;special-properties#Special-Properties&quot;&gt;特別なプロパティを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="85f792f34f1609454c8ad7752317553e8a6aea26" translate="yes" xml:space="preserve">
          <source>One way to use &lt;code&gt;catch&lt;/code&gt; and &lt;code&gt;throw&lt;/code&gt; is to exit from a doubly nested loop. (In most languages, this would be done with a &lt;code&gt;goto&lt;/code&gt;.) Here we compute &lt;code&gt;(foo &lt;var&gt;i&lt;/var&gt; &lt;var&gt;j&lt;/var&gt;)&lt;/code&gt; for &lt;var&gt;i&lt;/var&gt; and &lt;var&gt;j&lt;/var&gt; varying from 0 to 9:</source>
          <target state="translated">&lt;code&gt;catch&lt;/code&gt; アンド &lt;code&gt;throw&lt;/code&gt; を使用する1つの方法は、二重にネストされたループを終了することです。（ほとんどの言語では、これは &lt;code&gt;goto&lt;/code&gt; で実行されます。）ここでは、0から9まで変化する &lt;var&gt;i&lt;/var&gt; と &lt;var&gt;j&lt;/var&gt; の &lt;code&gt;(foo &lt;var&gt;i&lt;/var&gt; &lt;var&gt;j&lt;/var&gt;)&lt;/code&gt; を計算します。</target>
        </trans-unit>
        <trans-unit id="48d778b2ad99cdef9eebb6a0fb329935a9f7da52" translate="yes" xml:space="preserve">
          <source>One-dimensional arrays of &lt;code&gt;t&lt;/code&gt; or &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;t&lt;/code&gt; または &lt;code&gt;nil&lt;/code&gt; の1次元配列。</target>
        </trans-unit>
        <trans-unit id="6073cf4225ea4cf9fd99b377fa082aad9eea6d61" translate="yes" xml:space="preserve">
          <source>One-dimensional arrays.</source>
          <target state="translated">一次元配列。</target>
        </trans-unit>
        <trans-unit id="be996260ce0e4df49d84c11ecb1d8434ceb9918f" translate="yes" xml:space="preserve">
          <source>One-dimensional sparse arrays indexed by characters.</source>
          <target state="translated">文字をインデックスとする1次元の疎な配列.</target>
        </trans-unit>
        <trans-unit id="ae88654faca91364a5a35b8017f9b11dd388a0bf" translate="yes" xml:space="preserve">
          <source>Only &lt;var&gt;body-form&lt;/var&gt; is protected by the &lt;code&gt;unwind-protect&lt;/code&gt;. If any of the &lt;var&gt;cleanup-forms&lt;/var&gt; themselves exits nonlocally (via a &lt;code&gt;throw&lt;/code&gt; or an error), &lt;code&gt;unwind-protect&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; guaranteed to evaluate the rest of them. If the failure of one of the &lt;var&gt;cleanup-forms&lt;/var&gt; has the potential to cause trouble, then protect it with another &lt;code&gt;unwind-protect&lt;/code&gt; around that form.</source>
          <target state="translated">&lt;code&gt;unwind-protect&lt;/code&gt; によって保護されるのは &lt;var&gt;body-form&lt;/var&gt; のみです。 &lt;var&gt;cleanup-forms&lt;/var&gt; 自体のいずれかが（ &lt;code&gt;throw&lt;/code&gt; またはエラーを介して）非ローカルに終了する場合、 &lt;code&gt;unwind-protect&lt;/code&gt; が残りのフォームを評価すること&lt;em&gt;は&lt;/em&gt;保証され&lt;em&gt;ませ&lt;/em&gt;ん。 &lt;var&gt;cleanup-forms&lt;/var&gt; の1つに障害が発生すると問題が発生する可能性がある場合は、そのフォームの周囲を別の &lt;code&gt;unwind-protect&lt;/code&gt; します。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5ddbb81d5905d23be7a9282a488499d00d5db21e" translate="yes" xml:space="preserve">
          <source>Only available on macOS, if non-&lt;code&gt;nil&lt;/code&gt;, set the titlebar and toolbar to be transparent. This effectively sets the background color of both to match the Emacs background color.</source>
          <target state="translated">macOSでのみ使用可能で、 &lt;code&gt;nil&lt;/code&gt; でない場合は、タイトルバーとツールバーを透明に設定します。これにより、両方の背景色がEmacsの背景色と一致するように効果的に設定されます。</target>
        </trans-unit>
        <trans-unit id="18179e6d777e1c5274c1d80de143a1698c76c5dd" translate="yes" xml:space="preserve">
          <source>Only available on macOS, if set to &lt;code&gt;dark&lt;/code&gt; draw this frame&amp;rsquo;s window-system window using the &amp;ldquo;vibrant dark&amp;rdquo; theme, otherwise use the system default. The &amp;ldquo;vibrant dark&amp;rdquo; theme can be used to set the toolbar and scrollbars to a dark appearance when using an Emacs theme with a dark background.</source>
          <target state="translated">macOSでのみ使用できます。 &lt;code&gt;dark&lt;/code&gt; 設定されている場合は、「鮮やかなダーク」テーマを使用してこのフレームのウィンドウシステムウィンドウを描画します。それ以外の場合は、システムのデフォルトを使用します。「鮮やかなダーク」テーマを使用すると、背景が暗いEmacsテーマを使用するときに、ツールバーとスクロールバーを暗い外観に設定できます。</target>
        </trans-unit>
        <trans-unit id="c4e0867e177c2c0fb6455a0e2fbcd920632c9814" translate="yes" xml:space="preserve">
          <source>Only if creating a new frame fails, &lt;code&gt;display-buffer&lt;/code&gt; will apply the actions supplied by &lt;code&gt;display-buffer-fallback-action&lt;/code&gt; which means to again try reusing a window, popping up a new window and so on. A trivial way to make frame creation fail is supplied by the following form:</source>
          <target state="translated">新しいフレームの作成が失敗した場合にのみ、 &lt;code&gt;display-buffer&lt;/code&gt; は &lt;code&gt;display-buffer-fallback-action&lt;/code&gt; によって提供されるアクションを適用します。これは、ウィンドウの再利用、新しいウィンドウのポップアップなどを再試行することを意味します。フレームの作成を失敗させる簡単な方法は、次のフォームで提供されます。</target>
        </trans-unit>
        <trans-unit id="586047e86826f6dbd9c9e2881cee476941126e1e" translate="yes" xml:space="preserve">
          <source>Only top-level values (arrays and objects) can be serialized to JSON. The subobjects within these top-level values can be of any type. Likewise, the parsing functions will only return vectors, hashtables, alists, and plists.</source>
          <target state="translated">トップレベルの値(配列とオブジェクト)だけがJSONにシリアライズできます。これらのトップレベルの値の中のサブオブジェクトは、どのようなタイプであっても構いません。同様に、解析関数はベクター、ハッシュテーブル、リスト、プリストのみを返します。</target>
        </trans-unit>
        <trans-unit id="d7386c857a6085eb01544217b3270be05da5ce62" translate="yes" xml:space="preserve">
          <source>Open parenthesis characters: &amp;lsquo;</source>
          <target state="translated">開き括弧文字： '</target>
        </trans-unit>
        <trans-unit id="7c1e62f5f482a805fbc3795b139cfba4a6ee67ba" translate="yes" xml:space="preserve">
          <source>Opening network connections.</source>
          <target state="translated">ネットワーク接続を開く。</target>
        </trans-unit>
        <trans-unit id="8a38f5abc74dccf57ac90365fb1a9bb0148242a3" translate="yes" xml:space="preserve">
          <source>Operating System Environment</source>
          <target state="translated">オペレーティングシステム環境</target>
        </trans-unit>
        <trans-unit id="47ccf7c0529a8c5659311c8f82bec6086b29bb6c" translate="yes" xml:space="preserve">
          <source>Operating System Interface</source>
          <target state="translated">オペレーティングシステムインタフェース</target>
        </trans-unit>
        <trans-unit id="686c6069aa66b3b4e21a44c27c9586de497a2f96" translate="yes" xml:space="preserve">
          <source>Operating on X11 Keysyms</source>
          <target state="translated">X11上での操作 Keysyms</target>
        </trans-unit>
        <trans-unit id="1f124ca397e717abcc79b77c1f05d2b73214fbd7" translate="yes" xml:space="preserve">
          <source>Operating on key symbols for X Windows.</source>
          <target state="translated">X Windows用のキーシンボルで動作します。</target>
        </trans-unit>
        <trans-unit id="f100a2b248d1a840348b4d7eb2abbcfa1fd0b916" translate="yes" xml:space="preserve">
          <source>Operating on the special minibuffer windows.</source>
          <target state="translated">特殊なミニバッファウィンドウでの操作。</target>
        </trans-unit>
        <trans-unit id="30642cc8933c44209f3f574d7f685d3dbe69cad1" translate="yes" xml:space="preserve">
          <source>Operator Precedence Grammars</source>
          <target state="translated">演算子先行文法</target>
        </trans-unit>
        <trans-unit id="9abbe311bb8d8a0022002079a7ed956ab53457b0" translate="yes" xml:space="preserve">
          <source>Operator precedence grammar is a very primitive technology for parsing compared to some of the more common techniques used in compilers. It has the following characteristics: its parsing power is very limited, and it is largely unable to detect syntax errors, but it has the advantage of being algorithmically efficient and able to parse forward just as well as backward. In practice that means that SMIE can use it for indentation based on backward parsing, that it can provide both &lt;code&gt;forward-sexp&lt;/code&gt; and &lt;code&gt;backward-sexp&lt;/code&gt; functionality, and that it will naturally work on syntactically incorrect code without any extra effort. The downside is that it also means that most programming languages cannot be parsed correctly using SMIE, at least not without resorting to some special tricks (see &lt;a href=&quot;smie-tricks#SMIE-Tricks&quot;&gt;SMIE Tricks&lt;/a&gt;).</source>
          <target state="translated">演算子優先順位文法は、コンパイラーで使用されるより一般的な手法のいくつかと比較して、構文解析のための非常に原始的な技術です。次の特徴があります。解析能力が非常に制限されており、構文エラーをほとんど検出できませんが、アルゴリズム的に効率的であり、前方および後方に解析できるという利点があります。実際には、SMIEはこれを後方解析に基づくインデントに使用でき、 &lt;code&gt;forward-sexp&lt;/code&gt; と &lt;code&gt;backward-sexp&lt;/code&gt; の両方の機能を提供でき、余分な労力をかけなくても構文的に正しくないコードで自然に機能します。欠点は、少なくともいくつかの特別なトリックに頼らなければ、ほとんどのプログラミング言語がSMIEを使用して正しく解析できないことも意味します（を参照）。&lt;a href=&quot;smie-tricks#SMIE-Tricks&quot;&gt;SMIEトリック&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="433ecb082f2de86ea14497d016e6339cef126f75" translate="yes" xml:space="preserve">
          <source>Option variables for customizing Edebug.</source>
          <target state="translated">Edebugをカスタマイズするためのオプション変数。</target>
        </trans-unit>
        <trans-unit id="41725bd17665c6ac89cc5165603ca309d1ea2d7c" translate="yes" xml:space="preserve">
          <source>Optional argument &lt;var&gt;family&lt;/var&gt; specified as symbol &lt;code&gt;ipv4&lt;/code&gt; or &lt;code&gt;ipv6&lt;/code&gt; restricts the returned information to IPv4 and IPv6 addresses respectively, independently of the value of &lt;var&gt;full&lt;/var&gt;. Specifying &lt;code&gt;ipv6&lt;/code&gt; when IPv6 support is not available will result in an error being signaled.</source>
          <target state="translated">シンボル &lt;code&gt;ipv4&lt;/code&gt; または &lt;code&gt;ipv6&lt;/code&gt; として指定されたオプションの引数 &lt;var&gt;family&lt;/var&gt; は、 &lt;var&gt;full&lt;/var&gt; の値に関係なく、返される情報をそれぞれIPv4アドレスとIPv6アドレスに制限します。IPv6サポートが利用できないときに &lt;code&gt;ipv6&lt;/code&gt; を指定すると、エラーが通知されます。</target>
        </trans-unit>
        <trans-unit id="b0205e865ebbb646fcce5e119e547b665d053edb" translate="yes" xml:space="preserve">
          <source>Optional argument &lt;var&gt;full&lt;/var&gt; non-&lt;code&gt;nil&lt;/code&gt; means to instead return a list of one or more elements of the form &lt;code&gt;(&lt;var&gt;ifname&lt;/var&gt;&amp;nbsp;&lt;var&gt;addr&lt;/var&gt;&amp;nbsp;&lt;var&gt;bcast&lt;/var&gt;&amp;nbsp;&lt;var&gt;netmask&lt;/var&gt;)&lt;/code&gt;. &lt;var&gt;ifname&lt;/var&gt; is a non-unique string naming the interface. &lt;var&gt;addr&lt;/var&gt;, &lt;var&gt;bcast&lt;/var&gt;, and &lt;var&gt;netmask&lt;/var&gt; are vectors of integers detailing the IP address, broadcast address, and network mask.</source>
          <target state="translated">オプションの引数 &lt;var&gt;full&lt;/var&gt; 非 &lt;code&gt;nil&lt;/code&gt; のの代わりに、フォームの1つの以上の要素のリストを返すための手段 &lt;code&gt;(&lt;var&gt;ifname&lt;/var&gt;&amp;nbsp;&lt;var&gt;addr&lt;/var&gt;&amp;nbsp;&lt;var&gt;bcast&lt;/var&gt;&amp;nbsp;&lt;var&gt;netmask&lt;/var&gt;)&lt;/code&gt; 。 &lt;var&gt;ifname&lt;/var&gt; は、インターフェイスに名前を付ける一意でない文字列です。 &lt;var&gt;addr&lt;/var&gt; 、 &lt;var&gt;bcast&lt;/var&gt; 、および &lt;var&gt;netmask&lt;/var&gt; は、IPアドレス、ブロードキャストアドレス、およびネットワークマスクの詳細を示す整数のベクトルです。</target>
        </trans-unit>
        <trans-unit id="3ce281c8a118cd3ed61dcec4880e6886db816d03" translate="yes" xml:space="preserve">
          <source>Optional argument &lt;var&gt;size&lt;/var&gt; non-&lt;code&gt;nil&lt;/code&gt; means to try swapping the sizes of &lt;var&gt;window-1&lt;/var&gt; and &lt;var&gt;window-2&lt;/var&gt; as well. A value of &lt;code&gt;height&lt;/code&gt; means to swap heights only, a value of &lt;code&gt;width&lt;/code&gt; means to swap widths only, while &lt;code&gt;t&lt;/code&gt; means to swap both widths and heights, if possible. Frames are not resized by this function.</source>
          <target state="translated">オプションの引数の &lt;var&gt;size&lt;/var&gt; 非 &lt;code&gt;nil&lt;/code&gt; のサイズ交換してみてくださいするための手段 &lt;var&gt;window-1&lt;/var&gt; および &lt;var&gt;window-2&lt;/var&gt; うまくとして。 &lt;code&gt;height&lt;/code&gt; の値は高さのみを交換することを意味し、 &lt;code&gt;width&lt;/code&gt; の値は幅のみを交換することを意味し、 &lt;code&gt;t&lt;/code&gt; は可能であれば幅と高さの両方を交換することを意味します。この関数では、フレームのサイズは変更されません。</target>
        </trans-unit>
        <trans-unit id="ce411d37922de190b756838011d8fc8421d7f336" translate="yes" xml:space="preserve">
          <source>Optional argument &lt;var&gt;suffix&lt;/var&gt; is a string to be displayed after &lt;var&gt;reporter&lt;/var&gt;&amp;rsquo;s main message and progress text. If &lt;var&gt;reporter&lt;/var&gt; is a non-numerical reporter, then &lt;var&gt;value&lt;/var&gt; should be &lt;code&gt;nil&lt;/code&gt;, or a string to use instead of &lt;var&gt;suffix&lt;/var&gt;.</source>
          <target state="translated">オプションの引数 &lt;var&gt;suffix&lt;/var&gt; は、 &lt;var&gt;reporter&lt;/var&gt; のメインメッセージと進行状況テキストの後に表示される文字列です。場合 &lt;var&gt;reporter&lt;/var&gt; 数値以外のレポーターである、そして &lt;var&gt;value&lt;/var&gt; あるべき &lt;code&gt;nil&lt;/code&gt; 、または文字列の代わりに使用する &lt;var&gt;suffix&lt;/var&gt; 。</target>
        </trans-unit>
        <trans-unit id="a305373f5ab4c8179b157e7348094ea4ce59f3c4" translate="yes" xml:space="preserve">
          <source>Optional argument &lt;var&gt;type&lt;/var&gt; specifies the type of the edges to return: &lt;code&gt;outer-edges&lt;/code&gt; means to return the outer edges of &lt;var&gt;frame&lt;/var&gt;, &lt;code&gt;native-edges&lt;/code&gt; (or &lt;code&gt;nil&lt;/code&gt;) means to return its native edges and &lt;code&gt;inner-edges&lt;/code&gt; means to return its inner edges.</source>
          <target state="translated">オプションの引数 &lt;var&gt;type&lt;/var&gt; は、返すエッジのタイプを指定します &lt;code&gt;outer-edges&lt;/code&gt; は &lt;var&gt;frame&lt;/var&gt; の外側のエッジを返すことを意味し、 &lt;code&gt;native-edges&lt;/code&gt; （または &lt;code&gt;nil&lt;/code&gt; ）はネイティブのエッジを返すことを意味し、 &lt;code&gt;inner-edges&lt;/code&gt; は内側のエッジを返すことを意味します。</target>
        </trans-unit>
        <trans-unit id="b389bdb03281d5aed10905c4bf13e4c443b15b78" translate="yes" xml:space="preserve">
          <source>Options for how input is processed.</source>
          <target state="translated">入力がどのように処理されるかのオプション。</target>
        </trans-unit>
        <trans-unit id="676740d3b53e425b59a5051ef0cf6614000f6153" translate="yes" xml:space="preserve">
          <source>Ordinarily the first argument is a list &lt;code&gt;(&lt;var&gt;second&lt;/var&gt; &lt;var&gt;minute&lt;/var&gt; &lt;var&gt;hour&lt;/var&gt; &lt;var&gt;day&lt;/var&gt; &lt;var&gt;month&lt;/var&gt;
&lt;var&gt;year&lt;/var&gt; &lt;var&gt;ignored&lt;/var&gt; &lt;var&gt;dst&lt;/var&gt; &lt;var&gt;zone&lt;/var&gt;)&lt;/code&gt; that specifies a decoded time in the style of &lt;code&gt;decode-time&lt;/code&gt;, so that &lt;code&gt;(encode-time (decode-time ...))&lt;/code&gt; works. For the meanings of these list members, see the table under &lt;code&gt;decode-time&lt;/code&gt;.</source>
          <target state="translated">通常は最初の引数はリストである &lt;code&gt;(&lt;var&gt;second&lt;/var&gt; &lt;var&gt;minute&lt;/var&gt; &lt;var&gt;hour&lt;/var&gt; &lt;var&gt;day&lt;/var&gt; &lt;var&gt;month&lt;/var&gt; &lt;var&gt;year&lt;/var&gt; &lt;var&gt;ignored&lt;/var&gt; &lt;var&gt;dst&lt;/var&gt; &lt;var&gt;zone&lt;/var&gt;)&lt;/code&gt; のスタイルでデコードされた時刻を指定し &lt;code&gt;decode-time&lt;/code&gt; ように、 &lt;code&gt;(encode-time (decode-time ...))&lt;/code&gt; 動作します。これらのリストメンバーの意味については、 &lt;code&gt;decode-time&lt;/code&gt; の下の表を参照してください。</target>
        </trans-unit>
        <trans-unit id="4c6d5310c1a644ae25978f7caf49bad39c82c0ef" translate="yes" xml:space="preserve">
          <source>Ordinarily, &lt;code&gt;fill-individual-paragraphs&lt;/code&gt; regards each change in indentation as starting a new paragraph. If &lt;code&gt;fill-individual-varying-indent&lt;/code&gt; is non-&lt;code&gt;nil&lt;/code&gt;, then only separator lines separate paragraphs. That mode can handle indented paragraphs with additional indentation on the first line.</source>
          <target state="translated">通常、 &lt;code&gt;fill-individual-paragraphs&lt;/code&gt; は、インデントの各変更を新しい段落の開始と見なします。場合 &lt;code&gt;fill-individual-varying-indent&lt;/code&gt; 非ある &lt;code&gt;nil&lt;/code&gt; 、その後だけ分離株は、段落を分けます。このモードでは、最初の行にインデントを追加して、インデントされた段落を処理できます。</target>
        </trans-unit>
        <trans-unit id="375f3605b67b9e5591350d037468627ffa4a6244" translate="yes" xml:space="preserve">
          <source>Ordinarily, &lt;code&gt;rename-buffer&lt;/code&gt; signals an error if &lt;var&gt;newname&lt;/var&gt; is already in use. However, if &lt;var&gt;unique&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, it modifies &lt;var&gt;newname&lt;/var&gt; to make a name that is not in use. Interactively, you can make &lt;var&gt;unique&lt;/var&gt; non-&lt;code&gt;nil&lt;/code&gt; with a numeric prefix argument. (This is how the command &lt;code&gt;rename-uniquely&lt;/code&gt; is implemented.)</source>
          <target state="translated">通常、 &lt;var&gt;newname&lt;/var&gt; がすでに使用されている場合、 &lt;code&gt;rename-buffer&lt;/code&gt; はエラーを通知します。ただし、 &lt;var&gt;unique&lt;/var&gt; が &lt;code&gt;nil&lt;/code&gt; 以外の場合は、 &lt;var&gt;newname&lt;/var&gt; を変更して、使用されていない名前にします。インタラクティブに、数値のプレフィックス引数を使用して &lt;var&gt;unique&lt;/var&gt; 非 &lt;code&gt;nil&lt;/code&gt; を作成できます。（これは、コマンド &lt;code&gt;rename-uniquely&lt;/code&gt; の実装方法です。）</target>
        </trans-unit>
        <trans-unit id="49604b10b3ce6fc4e228c33eaf4c9eabebbafb54" translate="yes" xml:space="preserve">
          <source>Ordinarily, &lt;code&gt;unload-feature&lt;/code&gt; refuses to unload a library on which other loaded libraries depend. (A library &lt;var&gt;a&lt;/var&gt; depends on library &lt;var&gt;b&lt;/var&gt; if &lt;var&gt;a&lt;/var&gt; contains a &lt;code&gt;require&lt;/code&gt; for &lt;var&gt;b&lt;/var&gt;.) If the optional argument &lt;var&gt;force&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, dependencies are ignored and you can unload any library.</source>
          <target state="translated">通常、 &lt;code&gt;unload-feature&lt;/code&gt; は、ロードされた他のライブラリが依存しているライブラリのアンロードを拒否します。 （ライブラリ &lt;var&gt;a&lt;/var&gt; ライブラリに依存 &lt;var&gt;b&lt;/var&gt; 場合は含ま &lt;code&gt;require&lt;/code&gt; するために &lt;var&gt;b&lt;/var&gt; 。）オプションの引数の場合は &lt;var&gt;force&lt;/var&gt; 非で &lt;code&gt;nil&lt;/code&gt; の依存関係は無視され、あなたが任意のライブラリをアンロードすることができます。 &lt;var&gt;a&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="1bfbb016c1886fa701a54a40747d69fbc68c3719" translate="yes" xml:space="preserve">
          <source>Ordinarily, functions that operate on text or move point do not care whether the text is invisible, they process invisible characters and visible characters alike. The user-level line motion commands, such as &lt;code&gt;next-line&lt;/code&gt;, &lt;code&gt;previous-line&lt;/code&gt;, ignore invisible newlines if &lt;code&gt;line-move-ignore-invisible&lt;/code&gt; is non-&lt;code&gt;nil&lt;/code&gt; (the default), i.e., behave like these invisible newlines didn&amp;rsquo;t exist in the buffer, but only because they are explicitly programmed to do so.</source>
          <target state="translated">通常、テキストまたは移動ポイントを操作する関数は、テキストが非表示であるかどうかを気にせず、非表示の文字と表示の文字を同様に処理します。 &lt;code&gt;next-line&lt;/code&gt; 、 &lt;code&gt;previous-line&lt;/code&gt; などのユーザーレベルのラインモーションコマンドは、 &lt;code&gt;line-move-ignore-invisible&lt;/code&gt; が &lt;code&gt;nil&lt;/code&gt; 以外（デフォルト）の場合、つまり、これらの非表示の改行が存在しなかったように動作する場合、非表示の改行を無視します。バッファ。ただし、明示的にプログラムされているためです。</target>
        </trans-unit>
        <trans-unit id="2931150327a52dd944296ebe55052fed18d6a2ee" translate="yes" xml:space="preserve">
          <source>Ordinarily, this function deletes all existing frames not listed in &lt;var&gt;configuration&lt;/var&gt;. But if &lt;var&gt;nodelete&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, the unwanted frames are iconified instead.</source>
          <target state="translated">通常、この関数は、 &lt;var&gt;configuration&lt;/var&gt; リストされていない既存のフレームをすべて削除します。ただし、 &lt;var&gt;nodelete&lt;/var&gt; が &lt;code&gt;nil&lt;/code&gt; 以外の場合は、代わりに不要なフレームがアイコン化されます。</target>
        </trans-unit>
        <trans-unit id="87302b912cb01c9639fa44884323306db9210741" translate="yes" xml:space="preserve">
          <source>Ordinary Lisp variables can be assigned any value that is a valid Lisp object. However, certain Lisp variables are not defined in Lisp, but in C. Most of these variables are defined in the C code using &lt;code&gt;DEFVAR_LISP&lt;/code&gt;. Like variables defined in Lisp, these can take on any value. However, some variables are defined using &lt;code&gt;DEFVAR_INT&lt;/code&gt; or &lt;code&gt;DEFVAR_BOOL&lt;/code&gt;. See &lt;a href=&quot;writing-emacs-primitives#Defining-Lisp-variables-in-C&quot;&gt;Writing Emacs Primitives&lt;/a&gt;, in particular the description of functions of the type &lt;code&gt;syms_of_&lt;var&gt;filename&lt;/var&gt;&lt;/code&gt;, for a brief discussion of the C implementation.</source>
          <target state="translated">通常のLisp変数には、有効なLispオブジェクトである任意の値を割り当てることができます。ただし、特定のLisp変数はLispではなくCで定義されています。これらの変数のほとんどは、 &lt;code&gt;DEFVAR_LISP&lt;/code&gt; を使用してCコードで定義されています。Lispで定義された変数と同様に、これらは任意の値を取ることができます。ただし、一部の変数は &lt;code&gt;DEFVAR_INT&lt;/code&gt; または &lt;code&gt;DEFVAR_BOOL&lt;/code&gt; を使用して定義されます。参照してください&lt;a href=&quot;writing-emacs-primitives#Defining-Lisp-variables-in-C&quot;&gt;書き込みEmacsのプリミティブを&lt;/a&gt;、特にタイプの機能の説明 &lt;code&gt;syms_of_&lt;var&gt;filename&lt;/var&gt;&lt;/code&gt; Cの実装の簡単な議論のために、。</target>
        </trans-unit>
        <trans-unit id="9aa2f051f923703f2af383ff67fd2ab1b21d7049" translate="yes" xml:space="preserve">
          <source>Ordinary characters &amp;ndash; keys with symbols on them.</source>
          <target state="translated">通常の文字&amp;ndash;記号が付いたキー。</target>
        </trans-unit>
        <trans-unit id="ea6b2ec77fa1c5f39197cbc7ea3990c82fb9841d" translate="yes" xml:space="preserve">
          <source>Ordinary evaluation of a macro call finishes by evaluating the expansion. However, the macro expansion is not necessarily evaluated right away, or at all, because other programs also expand macro calls, and they may or may not evaluate the expansions.</source>
          <target state="translated">マクロ呼び出しの通常の評価は、展開を評価することで終了します。しかし、他のプログラムもマクロ呼び出しの展開を行っており、その展開を評価する場合と評価しない場合があるため、マクロの展開がすぐに評価されるとは限らないし、全く評価されない場合もある。</target>
        </trans-unit>
        <trans-unit id="08b529b0be834d360e6ea5bc83de04138368fecc" translate="yes" xml:space="preserve">
          <source>Ordinary quitting gives no information about why the program was looping. To get more information, you can set the variable &lt;code&gt;debug-on-quit&lt;/code&gt; to non-&lt;code&gt;nil&lt;/code&gt;. Once you have the debugger running in the middle of the infinite loop, you can proceed from the debugger using the stepping commands. If you step through the entire loop, you may get enough information to solve the problem.</source>
          <target state="translated">通常の終了では、プログラムがループしていた理由に関する情報は得られません。詳細情報を取得するには、変数 &lt;code&gt;debug-on-quit&lt;/code&gt; を &lt;code&gt;nil&lt;/code&gt; - nilに設定します。デバッガーを無限ループの途中で実行すると、ステッピングコマンドを使用してデバッガーから続行できます。ループ全体をステップスルーすると、問題を解決するのに十分な情報が得られる場合があります。</target>
        </trans-unit>
        <trans-unit id="34d1e835211103e55315f8950b093575e40b4d28" translate="yes" xml:space="preserve">
          <source>Other Character Modifier Bits</source>
          <target state="translated">その他の文字修飾ビット</target>
        </trans-unit>
        <trans-unit id="33198adc02f29100fbe001bcd24af108bb8d17c8" translate="yes" xml:space="preserve">
          <source>Other Display Specifications</source>
          <target state="translated">その他の表示仕様</target>
        </trans-unit>
        <trans-unit id="e1b5fab73cfe1a3afaa115ab03f0edad57c69f7f" translate="yes" xml:space="preserve">
          <source>Other Features of Argument Lists</source>
          <target state="translated">引数リストのその他の特徴</target>
        </trans-unit>
        <trans-unit id="4e097fdc9bb03d4937b671db92b45a0f360cd315" translate="yes" xml:space="preserve">
          <source>Other Font Lock Variables</source>
          <target state="translated">その他のフォントロック変数</target>
        </trans-unit>
        <trans-unit id="46737ad394242fbdb99171fff4fda522659876cd" translate="yes" xml:space="preserve">
          <source>Other Hash Table Functions</source>
          <target state="translated">その他のハッシュテーブル関数</target>
        </trans-unit>
        <trans-unit id="56044b82f8d646d772974c14d2a91bcbcbcb3ce7" translate="yes" xml:space="preserve">
          <source>Other Image Types</source>
          <target state="translated">その他の画像タイプ</target>
        </trans-unit>
        <trans-unit id="edfdae8d79c7493898f253dfe960e84840b69477" translate="yes" xml:space="preserve">
          <source>Other Lisp objects are &lt;em&gt;mutable&lt;/em&gt;: it is safe to change their values via destructive operations involving side effects. For example, an existing marker can be changed by moving the marker to point to somewhere else.</source>
          <target state="translated">他のLispオブジェクトは&lt;em&gt;変更可能&lt;/em&gt;です：副作用を伴う破壊的な操作を介してそれらの値を変更するのは安全です。たとえば、既存のマーカーは、マーカーを移動して別の場所を指すようにすることで変更できます。</target>
        </trans-unit>
        <trans-unit id="041cab119371080f5c14fa74fa5fa41d2e6a8bf9" translate="yes" xml:space="preserve">
          <source>Other Topics Related to Functions</source>
          <target state="translated">関数のその他の関連トピック</target>
        </trans-unit>
        <trans-unit id="6eb08d88c80caa45384446348816e55ba7c955ae" translate="yes" xml:space="preserve">
          <source>Other aspects of tooltip display are controlled by several customizable settings; see &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Tooltips.html#Tooltips&quot;&gt;Tooltips&lt;/a&gt; in</source>
          <target state="translated">ツールチップ表示の他の側面は、いくつかのカスタマイズ可能な設定によって制御されます。の&lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Tooltips.html#Tooltips&quot;&gt;ツールチップ&lt;/a&gt;を参照してください</target>
        </trans-unit>
        <trans-unit id="6a64c877816cb35a6c766c7fbbe33ffb08e05d25" translate="yes" xml:space="preserve">
          <source>Other definition types:</source>
          <target state="translated">その他の定義タイプ。</target>
        </trans-unit>
        <trans-unit id="21ad92f8be5dc4e33dd7afb9682a8336e5b8df9f" translate="yes" xml:space="preserve">
          <source>Other events the system can generate.</source>
          <target state="translated">システムが生成できるその他のイベント</target>
        </trans-unit>
        <trans-unit id="d9542df9ae63b6d508bd2e2ee21aec4ef7962dc9" translate="yes" xml:space="preserve">
          <source>Other frequently used commands are</source>
          <target state="translated">その他、よく使われるコマンドは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="db54d46555d1f340a37db3a33c9204c8396d6479" translate="yes" xml:space="preserve">
          <source>Other functions to compare with this one include &lt;code&gt;make-vector&lt;/code&gt; (see &lt;a href=&quot;vectors#Vectors&quot;&gt;Vectors&lt;/a&gt;) and &lt;code&gt;make-list&lt;/code&gt; (see &lt;a href=&quot;building-lists#Building-Lists&quot;&gt;Building Lists&lt;/a&gt;).</source>
          <target state="translated">これと比較する他の関数には、 &lt;code&gt;make-vector&lt;/code&gt; （&lt;a href=&quot;vectors#Vectors&quot;&gt;Vectorsを&lt;/a&gt;参照）および &lt;code&gt;make-list&lt;/code&gt; （&lt;a href=&quot;building-lists#Building-Lists&quot;&gt;Building Listsを&lt;/a&gt;参照）が含まれます。</target>
        </trans-unit>
        <trans-unit id="408167f431dbe022874b25fe0cbeecaf0058b490" translate="yes" xml:space="preserve">
          <source>Other functions you can use to create buffers include &lt;code&gt;with-output-to-temp-buffer&lt;/code&gt; (see &lt;a href=&quot;temporary-displays#Temporary-Displays&quot;&gt;Temporary Displays&lt;/a&gt;) and &lt;code&gt;create-file-buffer&lt;/code&gt; (see &lt;a href=&quot;visiting-files#Visiting-Files&quot;&gt;Visiting Files&lt;/a&gt;). Starting a subprocess can also create a buffer (see &lt;a href=&quot;processes#Processes&quot;&gt;Processes&lt;/a&gt;).</source>
          <target state="translated">あなたがバッファを作成するために使用できるその他の機能は含まれ &lt;code&gt;with-output-to-temp-buffer&lt;/code&gt; （参照&lt;a href=&quot;temporary-displays#Temporary-Displays&quot;&gt;一時的な表示を&lt;/a&gt;）して &lt;code&gt;create-file-buffer&lt;/code&gt; （参照&lt;a href=&quot;visiting-files#Visiting-Files&quot;&gt;ファイルを訪問します&lt;/a&gt;）。サブプロセスを開始すると、バッファを作成することもできます（&lt;a href=&quot;processes#Processes&quot;&gt;プロセスを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="12da01fa29e6553cd0e8cb48e03d6be151f33875" translate="yes" xml:space="preserve">
          <source>Other keyboard character events cannot fit in a string. This includes keyboard events in the range of 128 to 255.</source>
          <target state="translated">その他のキーボード文字イベントは文字列に収まりません。これには、128~255の範囲のキーボードイベントが含まれます。</target>
        </trans-unit>
        <trans-unit id="4ac0b6dbdd8cbd1b63c08a470ab7011f7b3c910a" translate="yes" xml:space="preserve">
          <source>Other primitives to look inside of window configurations would make sense, but are not implemented because we did not need them. See the file</source>
          <target state="translated">ウィンドウ設定の内部を見るための他のプリミティブは理にかなっていると思いますが、必要がなかったので実装されていません。ファイル</target>
        </trans-unit>
        <trans-unit id="f2e96a7c2811cdfc73c1ef4d1bd1a2c29ec6dda7" translate="yes" xml:space="preserve">
          <source>Other programs can also use custom printing; see</source>
          <target state="translated">他のプログラムでもカスタム印刷を使用することができます。</target>
        </trans-unit>
        <trans-unit id="0656cfe9687d5b1c6eec51fbeb7667af045fb347" translate="yes" xml:space="preserve">
          <source>Other quoting constructs include &lt;code&gt;function&lt;/code&gt; (see &lt;a href=&quot;anonymous-functions#Anonymous-Functions&quot;&gt;Anonymous Functions&lt;/a&gt;), which causes an anonymous lambda expression written in Lisp to be compiled, and &amp;lsquo;</source>
          <target state="translated">他の引用構造には、Lispで記述された匿名ラムダ式をコンパイルする &lt;code&gt;function&lt;/code&gt; （&lt;a href=&quot;anonymous-functions#Anonymous-Functions&quot;&gt;無名関数を&lt;/a&gt;参照）、および 'が含まれます。</target>
        </trans-unit>
        <trans-unit id="d862e1f98dfca98bea09cf7215fbefad08c4cef4" translate="yes" xml:space="preserve">
          <source>Other times, after careful consideration you may conclude that those conflicts are not serious and simply resolve them via the &lt;var&gt;resolvers&lt;/var&gt; argument of &lt;code&gt;smie-bnf-&amp;gt;prec2&lt;/code&gt;. Usually this is because the grammar is simply ambiguous: the conflict does not affect the set of programs described by the grammar, but only the way those programs are parsed. This is typically the case for separators and associative infix operators, where you want to add a resolver like &lt;code&gt;'((assoc &quot;|&quot;))&lt;/code&gt;. Another case where this can happen is for the classic &lt;em&gt;dangling else&lt;/em&gt; problem, where you will use &lt;code&gt;'((assoc
&quot;else&quot; &quot;then&quot;))&lt;/code&gt;. It can also happen for cases where the conflict is real and cannot really be resolved, but it is unlikely to pose a problem in practice.</source>
          <target state="translated">また、慎重に検討した結果、これらの競合は深刻ではないと結論付け、 &lt;code&gt;smie-bnf-&amp;gt;prec2&lt;/code&gt; の &lt;var&gt;resolvers&lt;/var&gt; 引数を使用して解決する場合もあります。通常、これは文法が単純にあいまいであるためです。競合は、文法によって記述されたプログラムのセットには影響せず、それらのプログラムの解析方法にのみ影響します。これは通常、 &lt;code&gt;'((assoc &quot;|&quot;))&lt;/code&gt; のようなリゾルバーを追加するセパレーターと連想中置演算子の場合です。これが発生する可能性のある別のケースは、古典的な&lt;em&gt;ぶら下がりelse&lt;/em&gt;問題の場合で、 &lt;code&gt;'((assoc &quot;else&quot; &quot;then&quot;))&lt;/code&gt; 。競合が実際に発生し、実際に解決できない場合にも発生する可能性がありますが、実際には問題が発生する可能性はほとんどありません。</target>
        </trans-unit>
        <trans-unit id="4957b132ab51bc30771f521b4940cb71793014c9" translate="yes" xml:space="preserve">
          <source>Other useful tools for debugging input and output problems are the dribble file (see &lt;a href=&quot;terminal-input#Terminal-Input&quot;&gt;Terminal Input&lt;/a&gt;) and the &lt;code&gt;open-termscript&lt;/code&gt; function (see &lt;a href=&quot;terminal-output#Terminal-Output&quot;&gt;Terminal Output&lt;/a&gt;).</source>
          <target state="translated">入出力の問題をデバッグするための他の便利なツールは、ドリブルファイル（&lt;a href=&quot;terminal-input#Terminal-Input&quot;&gt;ターミナル入力を&lt;/a&gt;参照）と &lt;code&gt;open-termscript&lt;/code&gt; 関数（&lt;a href=&quot;terminal-output#Terminal-Output&quot;&gt;ターミナル出力を&lt;/a&gt;参照）です。</target>
        </trans-unit>
        <trans-unit id="a49240e9e249989689d2ce97e9d81c517eb880e2" translate="yes" xml:space="preserve">
          <source>Other value</source>
          <target state="translated">その他の値</target>
        </trans-unit>
        <trans-unit id="f3fdcd50495da9607d64876c8b19f3585d001e97" translate="yes" xml:space="preserve">
          <source>Otherwise the function &lt;code&gt;call-process&lt;/code&gt; does no redisplay, and the results become visible on the screen only when Emacs redisplays that buffer in the normal course of events.</source>
          <target state="translated">それ以外の場合、関数 &lt;code&gt;call-process&lt;/code&gt; は再表示されず、Emacsが通常のイベントの過程でそのバッファーを再表示した場合にのみ結果が画面に表示されます。</target>
        </trans-unit>
        <trans-unit id="e5cf2c68d7f5c24121fcd7006c95c362d16d9910" translate="yes" xml:space="preserve">
          <source>Otherwise the value should be an alist that specifies which fringe indicators to display and where. Each element of the alist should have the form &lt;code&gt;(&lt;var&gt;indicator&lt;/var&gt; . &lt;var&gt;position&lt;/var&gt;)&lt;/code&gt;. Here, &lt;var&gt;indicator&lt;/var&gt; is one of &lt;code&gt;top&lt;/code&gt;, &lt;code&gt;bottom&lt;/code&gt;, &lt;code&gt;up&lt;/code&gt;, &lt;code&gt;down&lt;/code&gt;, and &lt;code&gt;t&lt;/code&gt; (which covers all the icons not yet specified), while &lt;var&gt;position&lt;/var&gt; is one of &lt;code&gt;left&lt;/code&gt;, &lt;code&gt;right&lt;/code&gt; and &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">それ以外の場合、値は、表示するフリンジインジケーターと場所を指定するリストである必要があります。アリストの各要素は、形式 &lt;code&gt;(&lt;var&gt;indicator&lt;/var&gt; . &lt;var&gt;position&lt;/var&gt;)&lt;/code&gt; 必要があります。ここで、 &lt;var&gt;indicator&lt;/var&gt; の一つである &lt;code&gt;top&lt;/code&gt; 、 &lt;code&gt;bottom&lt;/code&gt; 、 &lt;code&gt;up&lt;/code&gt; 、 &lt;code&gt;down&lt;/code&gt; 、及び &lt;code&gt;t&lt;/code&gt; が、（まだ指定されていないすべてのアイコンをカバーする） &lt;var&gt;position&lt;/var&gt; の一つである &lt;code&gt;left&lt;/code&gt; 、 &lt;code&gt;right&lt;/code&gt; と &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6cd6099948cb8e952f2e06ed3844cf9915b36c22" translate="yes" xml:space="preserve">
          <source>Otherwise, if &lt;var&gt;window&lt;/var&gt; was previously used for displaying other buffers (see &lt;a href=&quot;window-history#Window-History&quot;&gt;Window History&lt;/a&gt;), the most recent buffer in that history will be displayed. In either case, if &lt;var&gt;window&lt;/var&gt; is not deleted, its &lt;code&gt;quit-restore&lt;/code&gt; parameter is reset to &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">それ以外の場合、 &lt;var&gt;window&lt;/var&gt; が以前に他のバッファを表示するために使用されていた場合（&lt;a href=&quot;window-history#Window-History&quot;&gt;ウィンドウ履歴を&lt;/a&gt;参照）、その履歴の最新のバッファが表示されます。いずれの場合も、 &lt;var&gt;window&lt;/var&gt; が削除されていない場合、その &lt;code&gt;quit-restore&lt;/code&gt; パラメーターは &lt;code&gt;nil&lt;/code&gt; にリセットされます。</target>
        </trans-unit>
        <trans-unit id="b22d99af3628f670cc53b3c236b49d8671be213f" translate="yes" xml:space="preserve">
          <source>Otherwise, if the indentation function in &lt;code&gt;indent-line-function&lt;/code&gt; is &lt;code&gt;indent-to-left-margin&lt;/code&gt; (a trivial command that inserts a tab character), or if the variable &lt;code&gt;tab-always-indent&lt;/code&gt; specifies that a tab character ought to be inserted (see below), then it inserts a tab character.</source>
          <target state="translated">それ以外の場合、 &lt;code&gt;indent-line-function&lt;/code&gt; の &lt;code&gt;indent-to-left-margin&lt;/code&gt; 関数がindent-to-left-margin（タブ文字を挿入する簡単なコマンド）である場合、または変数 &lt;code&gt;tab-always-indent&lt;/code&gt; がタブ文字を挿入する必要があることを指定している場合（以下を参照）、タブ文字を挿入します。</target>
        </trans-unit>
        <trans-unit id="4a70357a80ea185af667a6cf9db2f85e272ad161" translate="yes" xml:space="preserve">
          <source>Otherwise, it indents the current line; this is done by calling the function in &lt;code&gt;indent-line-function&lt;/code&gt;. If the line is already indented, and the value of &lt;code&gt;tab-always-indent&lt;/code&gt; is &lt;code&gt;complete&lt;/code&gt; (see below), it tries completing the text at point.</source>
          <target state="translated">それ以外の場合は、現在の行をインデントします。これは、 &lt;code&gt;indent-line-function&lt;/code&gt; の関数を呼び出すことによって行われます。行がすでにインデントされていて、 &lt;code&gt;tab-always-indent&lt;/code&gt; の値が &lt;code&gt;complete&lt;/code&gt; （以下を参照）、その時点でテキストを完成させようとします。</target>
        </trans-unit>
        <trans-unit id="f0728e46990b904a5fc71835f81206fdedceb327" translate="yes" xml:space="preserve">
          <source>Otherwise, the base location should be a directory name. In this case, Emacs retrieves packages from this archive via ordinary file access. Such local archives are mainly useful for testing.</source>
          <target state="translated">そうでなければ、ベースとなる場所はディレクトリ名でなければなりません。この場合、Emacs は通常のファイルアクセスでこのアーカイブからパッケージを取得します。このようなローカルアーカイブは主にテストに便利です。</target>
        </trans-unit>
        <trans-unit id="45a47ab7c8110b367a5eb7d10e05ec778824df4d" translate="yes" xml:space="preserve">
          <source>Otherwise, the file modes of &lt;var&gt;newname&lt;/var&gt; are left unchanged if it is an existing file, and set to those of &lt;var&gt;oldname&lt;/var&gt;, masked by the default file permissions (see &lt;code&gt;set-default-file-modes&lt;/code&gt; below), if &lt;var&gt;newname&lt;/var&gt; is to be newly created. The Access Control List or SELinux context are not copied over in either case.</source>
          <target state="translated">それ以外の場合、 &lt;var&gt;newname&lt;/var&gt; のファイルモードは、既存のファイルの場合は変更されず、 &lt;var&gt;newname&lt;/var&gt; を新しく作成する場合は、デフォルトのファイル権限でマスクされた &lt;var&gt;oldname&lt;/var&gt; の &lt;code&gt;set-default-file-modes&lt;/code&gt; ます（以下のset-default-file-modesを参照）。どちらの場合も、アクセス制御リストまたはSELinuxコンテキストはコピーされません。</target>
        </trans-unit>
        <trans-unit id="81d57dfe0afd7a0985d57a78533c79c5a914182c" translate="yes" xml:space="preserve">
          <source>Otherwise, the symbol should be a predicate. The predicate is called with the argument, and if the predicate returns &lt;code&gt;nil&lt;/code&gt;, the specification fails and the argument is not instrumented.</source>
          <target state="translated">それ以外の場合、シンボルは述語である必要があります。述語は引数とともに呼び出され、述語が &lt;code&gt;nil&lt;/code&gt; を返す場合、指定は失敗し、引数はインストルメントされません。</target>
        </trans-unit>
        <trans-unit id="763f06232ee2847cc0f578d2a2ffd866f636432a" translate="yes" xml:space="preserve">
          <source>Otherwise, the value must be a list of regular expressions. Then a scalable font is enabled for use if its name matches any regular expression in the list. For example,</source>
          <target state="translated">そうでなければ、値は正規表現のリストでなければなりません。そうすると、スケーラブルフォントの名前がリスト内の任意の正規表現と一致した場合に、スケーラブルフォントの使用が有効になります。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="c8f0909271c68b7b8449d51302ffcf15bff72083" translate="yes" xml:space="preserve">
          <source>Otherwise, the value should be a function which returns a list of the above form when called with no arguments.</source>
          <target state="translated">そうでない場合は、引数なしで呼び出されたときに上記の形式のリストを返す関数でなければなりません。</target>
        </trans-unit>
        <trans-unit id="14d051441dd1704941ec3ffbfe4f559120510bb1" translate="yes" xml:space="preserve">
          <source>Otherwise, this returns &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">それ以外の場合、これは &lt;code&gt;nil&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="575a546ff3b142ba0fac4a6250e6ac440f035d5e" translate="yes" xml:space="preserve">
          <source>Our simple sample function, &lt;code&gt;(lambda (a b c) (+ a b c))&lt;/code&gt;, specifies three argument variables, so it must be called with three arguments: if you try to call it with only two arguments or four arguments, you get a &lt;code&gt;wrong-number-of-arguments&lt;/code&gt; error (see &lt;a href=&quot;errors#Errors&quot;&gt;Errors&lt;/a&gt;).</source>
          <target state="translated">単純なサンプル関数 &lt;code&gt;(lambda (a b c) (+ a b c))&lt;/code&gt; 、3つの引数変数を指定するため、3つの引数で呼び出す必要があります。2つの引数または4つの引数だけで呼び出そうとすると、 &lt;code&gt;wrong-number-of-arguments&lt;/code&gt; 返されます。-of-argumentsエラー（&lt;a href=&quot;errors#Errors&quot;&gt;エラーを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="a9852d0d719ff08733d222f566af473ea8319ac5" translate="yes" xml:space="preserve">
          <source>Outer Border</source>
          <target state="translated">アウターボーダー</target>
        </trans-unit>
        <trans-unit id="d03df9879e63c94d1ef1ef625db82f7c6086fd99" translate="yes" xml:space="preserve">
          <source>Outer Frame</source>
          <target state="translated">アウターフレーム</target>
        </trans-unit>
        <trans-unit id="d25d9ab5e677c4a9d400b4025bd92a3b5bab6708" translate="yes" xml:space="preserve">
          <source>Outer borders are never shown on text terminal frames and on frames generated by GTK+ routines. On MS-Windows, the outer border is emulated with the help of a one pixel wide external border. Non-toolkit builds on X allow to change the color of the outer border by setting the &lt;code&gt;border-color&lt;/code&gt; frame parameter (see &lt;a href=&quot;layout-parameters#Layout-Parameters&quot;&gt;Layout Parameters&lt;/a&gt;).</source>
          <target state="translated">テキスト端末フレームおよびGTK +ルーチンによって生成されたフレームに外側の境界線が表示されることはありません。 MS-Windowsでは、外側の境界線は1ピクセル幅の外側の境界線を使用してエミュレートされます。 X上に構築されたツールキット以外では、 &lt;code&gt;border-color&lt;/code&gt; frameパラメーターを設定することで外側の境界線の色を変更できます（&lt;a href=&quot;layout-parameters#Layout-Parameters&quot;&gt;レイアウトパラメーターを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="b23b7fca5f6573328ef2d805a7e0260cd5710efd" translate="yes" xml:space="preserve">
          <source>Output Functions</source>
          <target state="translated">出力機能</target>
        </trans-unit>
        <trans-unit id="9a91268a8670899c3fa6018e379c6499b8b7af3e" translate="yes" xml:space="preserve">
          <source>Output Streams</source>
          <target state="translated">出力ストリーム</target>
        </trans-unit>
        <trans-unit id="c32e9bc6a6bca97190de9cf86b1d5bfe5eb2f34a" translate="yes" xml:space="preserve">
          <source>Output from a subprocess can arrive only while Emacs is waiting: when reading terminal input (see the function &lt;code&gt;waiting-for-user-input-p&lt;/code&gt;), in &lt;code&gt;sit-for&lt;/code&gt; and &lt;code&gt;sleep-for&lt;/code&gt; (see &lt;a href=&quot;waiting#Waiting&quot;&gt;Waiting&lt;/a&gt;), in &lt;code&gt;accept-process-output&lt;/code&gt; (see &lt;a href=&quot;accepting-output#Accepting-Output&quot;&gt;Accepting Output&lt;/a&gt;), and in functions which send data to processes (see &lt;a href=&quot;input-to-processes#Input-to-Processes&quot;&gt;Input to Processes&lt;/a&gt;). This minimizes the problem of timing errors that usually plague parallel programming. For example, you can safely create a process and only then specify its buffer or filter function; no output can arrive before you finish, if the code in between does not call any primitive that waits.</source>
          <target state="translated">サブプロセスからの出力は、Emacsが待機している間のみ到着できます：端末入力を読み取るとき（関数 &lt;code&gt;waiting-for-user-input-p&lt;/code&gt; を参照）、 &lt;code&gt;sit-for&lt;/code&gt; および &lt;code&gt;sleep-for&lt;/code&gt; （&lt;a href=&quot;waiting#Waiting&quot;&gt;Waitingを&lt;/a&gt;参照）、 &lt;code&gt;accept-process-output&lt;/code&gt; （&lt;a href=&quot;accepting-output#Accepting-Output&quot;&gt;出力の受け入れを&lt;/a&gt;参照）、およびプロセスにデータを送信する関数（&lt;a href=&quot;input-to-processes#Input-to-Processes&quot;&gt;プロセスへの入力を&lt;/a&gt;参照）。これにより、通常は並列プログラミングを悩ますタイミングエラーの問題が最小限に抑えられます。たとえば、プロセスを安全に作成してから、そのバッファまたはフィルタ関数を指定することができます。間にあるコードが待機するプリミティブを呼び出さない場合、終了する前に出力が到着することはありません。</target>
        </trans-unit>
        <trans-unit id="21c758cdd849bd8a6c5c89059360afc09cd26de1" translate="yes" xml:space="preserve">
          <source>Output from asynchronous subprocesses normally arrives only while Emacs is waiting for some sort of external event, such as elapsed time or terminal input. Occasionally it is useful in a Lisp program to explicitly permit output to arrive at a specific point, or even to wait until output arrives from a process.</source>
          <target state="translated">非同期サブプロセスからの出力は通常、Emacsが経過時間や端末入力などの外部イベントを待っている間にのみ到着します。Lisp プログラムでは、出力が特定のポイントに到達することを明示的に許可したり、プロセスからの出力が到達するまで待つことができる場合もあります。</target>
        </trans-unit>
        <trans-unit id="0b9ca3340cc6c5af5f85b890299ce5ced2b68445" translate="yes" xml:space="preserve">
          <source>Output of messages into the</source>
          <target state="translated">へのメッセージの出力</target>
        </trans-unit>
        <trans-unit id="8c784b59ac07f59605bca80bc6385a0c8abe5d2b" translate="yes" xml:space="preserve">
          <source>Output trace information on function calls and returns.</source>
          <target state="translated">関数の呼び出しと戻り値のトレース情報を出力します。</target>
        </trans-unit>
        <trans-unit id="e4053b393b6a34936a44a25f539116ecb913583a" translate="yes" xml:space="preserve">
          <source>Outside Emacs, characters can be represented in many different encodings, such as ISO-8859-1, GB-2312, Big-5, etc. Emacs converts between these external encodings and its internal representation, as appropriate, when it reads text into a buffer or a string, or when it writes text to a disk file or passes it to some other process.</source>
          <target state="translated">Emacs の外部では、文字は ISO-8859-1、GB-2312、Big-5 など、さまざまなエンコーディングで表現できます。Emacs は、テキストをバッファや文字列に読み込んだり、テキストをディスクファイルに書き込んだり、 他のプロセスに渡したりするときに、これらの外部エンコーディングと内部表現の間で適切に変換します。</target>
        </trans-unit>
        <trans-unit id="c0a2a08afab0fbd40ca04201e1206a333c99a403" translate="yes" xml:space="preserve">
          <source>Outside of Emacs, on systems with job control, the stop character (usually</source>
          <target state="translated">Emacs以外では、ジョブ制御のあるシステムでは、停止文字(通常は</target>
        </trans-unit>
        <trans-unit id="b22b6e787ba475871fd62e316803a0a0753ded2f" translate="yes" xml:space="preserve">
          <source>Over void parts of the window (parts that do not correspond to any of the buffer contents), the mouse pointer usually uses the &lt;code&gt;arrow&lt;/code&gt; style, but you can specify a different style (one of those above) by setting &lt;code&gt;void-text-area-pointer&lt;/code&gt;.</source>
          <target state="translated">ウィンドウのvoid部分（バッファの内容のいずれにも対応しない部分）では、マウスポインタは通常 &lt;code&gt;arrow&lt;/code&gt; スタイルを使用しますが、 &lt;code&gt;void-text-area-pointer&lt;/code&gt; 設定することで別のスタイル（上記のいずれか）を指定できます。ポインタ。</target>
        </trans-unit>
        <trans-unit id="0fea430e693a45386a3c9636b829f4fd78379194" translate="yes" xml:space="preserve">
          <source>Overall, the key-value pairs passed to &lt;var&gt;function&lt;/var&gt; describe all the values stored in &lt;var&gt;char-table&lt;/var&gt;.</source>
          <target state="translated">全体として、 &lt;var&gt;function&lt;/var&gt; 渡されるキーと値のペアは、 &lt;var&gt;char-table&lt;/var&gt; に格納されているすべての値を記述します。</target>
        </trans-unit>
        <trans-unit id="c67eb8bae9c49b877d15564d28cb90029ac13ef6" translate="yes" xml:space="preserve">
          <source>Overlay Properties</source>
          <target state="translated">オーバーレイのプロパティ</target>
        </trans-unit>
        <trans-unit id="7e2d14eedf83ae2cc686557be0c0dade27cbfcb8" translate="yes" xml:space="preserve">
          <source>Overlay Type</source>
          <target state="translated">オーバーレイタイプ</target>
        </trans-unit>
        <trans-unit id="4e8e813f097ac9fdf229d20b7105e0cc57cfc922" translate="yes" xml:space="preserve">
          <source>Overlay properties are like text properties in that the properties that alter how a character is displayed can come from either source. But in most respects they are different. See &lt;a href=&quot;text-properties#Text-Properties&quot;&gt;Text Properties&lt;/a&gt;, for comparison.</source>
          <target state="translated">オーバーレイプロパティは、文字の表示方法を変更するプロパティがどちらのソースからも取得できるという点で、テキストプロパティに似ています。しかし、ほとんどの点でそれらは異なります。比較については、&lt;a href=&quot;text-properties#Text-Properties&quot;&gt;テキストのプロパティを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="30f888d222b77006610001ff65a62036e76c8b9f" translate="yes" xml:space="preserve">
          <source>Overlays</source>
          <target state="translated">Overlays</target>
        </trans-unit>
        <trans-unit id="7436ded961ede3d7e72f8b002fd2f760f034b992" translate="yes" xml:space="preserve">
          <source>Overlays also support the &lt;code&gt;modification-hooks&lt;/code&gt; property, but the details are somewhat different (see &lt;a href=&quot;overlay-properties#Overlay-Properties&quot;&gt;Overlay Properties&lt;/a&gt;).</source>
          <target state="translated">オーバーレイは &lt;code&gt;modification-hooks&lt;/code&gt; プロパティもサポートしますが、詳細は多少異なり&lt;a href=&quot;overlay-properties#Overlay-Properties&quot;&gt;ます&lt;/a&gt;（オーバーレイプロパティを参照）。</target>
        </trans-unit>
        <trans-unit id="38346ff2dbbd0c10b491d604ab1d0f5bf067809c" translate="yes" xml:space="preserve">
          <source>Overriding syntax with text properties.</source>
          <target state="translated">テキストプロパティで構文をオーバーライドします。</target>
        </trans-unit>
        <trans-unit id="0efc2e6be4c23b9a513d7ce0dcff8ed80e8912e7" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="translated">Overview</target>
        </trans-unit>
        <trans-unit id="3b314bcbaf594e58e02b7f1ac94d0a07d164ad50" translate="yes" xml:space="preserve">
          <source>Overview of Markers</source>
          <target state="translated">マーカーの概要</target>
        </trans-unit>
        <trans-unit id="e5dff67285e4f2b89cea9a5461f21bbf12d615e1" translate="yes" xml:space="preserve">
          <source>Overview of customizing Font Lock.</source>
          <target state="translated">フォントロックのカスタマイズの概要。</target>
        </trans-unit>
        <trans-unit id="48001e2fa21457daa7eb4268da77364c19623e16" translate="yes" xml:space="preserve">
          <source>Overview of mouse events.</source>
          <target state="translated">マウスイベントの概要。</target>
        </trans-unit>
        <trans-unit id="f42cdff5bec245ffb3bc5a0b0105f795984699c8" translate="yes" xml:space="preserve">
          <source>Overview of streams, reading and printing.</source>
          <target state="translated">ストリーム、読み込み、印刷の概要。</target>
        </trans-unit>
        <trans-unit id="511993d3c99719e38a6779073019dacd7178ddb9" translate="yes" xml:space="preserve">
          <source>P</source>
          <target state="translated">P</target>
        </trans-unit>
        <trans-unit id="d613d88cb2d86f484f6f82d44ac1fc60722abe20" translate="yes" xml:space="preserve">
          <source>PDF</source>
          <target state="translated">PDF</target>
        </trans-unit>
        <trans-unit id="1d7fd5d567d57918b31b5a2025c0ead430339e0b" translate="yes" xml:space="preserve">
          <source>PF1</source>
          <target state="translated">PF1</target>
        </trans-unit>
        <trans-unit id="dde57e820d65c87a0777da46aba7cd35a0c8436a" translate="yes" xml:space="preserve">
          <source>PID</source>
          <target state="translated">PID</target>
        </trans-unit>
        <trans-unit id="0c95dc6163ff0d09e82f44e7c50db7ad6b089bf3" translate="yes" xml:space="preserve">
          <source>PM</source>
          <target state="translated">PM</target>
        </trans-unit>
        <trans-unit id="70fe60b7dfe0837f2c69677bfef128c134937b16" translate="yes" xml:space="preserve">
          <source>PNG</source>
          <target state="translated">PNG</target>
        </trans-unit>
        <trans-unit id="74235b074241ce94a5e09f007b23a0ca401ea696" translate="yes" xml:space="preserve">
          <source>POSIX Regular Expression Searching</source>
          <target state="translated">POSIX 正規表現検索</target>
        </trans-unit>
        <trans-unit id="871ee878f58ebcf07fad71fd2bcebbda6088639b" translate="yes" xml:space="preserve">
          <source>POSIX specifies several environment variables that can affect how Emacs behaves. Any environment variable whose name consists entirely of uppercase ASCII letters, digits, and the underscore may affect the internal behavior of Emacs. Emacs uses several such variables, e.g., &lt;code&gt;EMACSLOADPATH&lt;/code&gt;. See &lt;a href=&quot;library-search#Library-Search&quot;&gt;Library Search&lt;/a&gt;. On some platforms some environment variables (e.g., &lt;code&gt;PATH&lt;/code&gt;, &lt;code&gt;POSIXLY_CORRECT&lt;/code&gt;, &lt;code&gt;SHELL&lt;/code&gt;, &lt;code&gt;TMPDIR&lt;/code&gt;) need to have properly-configured values in order to get standard behavior for any utility Emacs might invoke. Even seemingly-benign variables like &lt;code&gt;TZ&lt;/code&gt; may have security implications. See &lt;a href=&quot;system-environment#System-Environment&quot;&gt;System Environment&lt;/a&gt;.</source>
          <target state="translated">POSIXは、Emacsの動作に影響を与える可能性のあるいくつかの環境変数を指定します。名前がすべて大文字のASCII文字、数字、およびアンダースコアで構成されている環境変数は、Emacsの内部動作に影響を与える可能性があります。 Emacsはそのような変数をいくつか使用します（例： &lt;code&gt;EMACSLOADPATH&lt;/code&gt; )。&lt;a href=&quot;library-search#Library-Search&quot;&gt;ライブラリ検索を&lt;/a&gt;参照してください。一部のプラットフォームでは、Emacsが呼び出す可能性のあるユーティリティの標準的な動作を取得するために、一部の環境変数（ &lt;code&gt;PATH&lt;/code&gt; 、 &lt;code&gt;POSIXLY_CORRECT&lt;/code&gt; 、 &lt;code&gt;SHELL&lt;/code&gt; 、 &lt;code&gt;TMPDIR&lt;/code&gt; など）に適切に構成された値が必要です。 &lt;code&gt;TZ&lt;/code&gt; のような一見良性の変数でさえ、セキュリティに影響を与える可能性があります。&lt;a href=&quot;system-environment#System-Environment&quot;&gt;システム環境を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="31021705d55f66068349f6ead54a6f4f1f1f4e1c" translate="yes" xml:space="preserve">
          <source>Package-Requires</source>
          <target state="translated">Package-Requires</target>
        </trans-unit>
        <trans-unit id="400112f99c45dae97ae81ee287e883c5967448d7" translate="yes" xml:space="preserve">
          <source>Package-Version</source>
          <target state="translated">Package-Version</target>
        </trans-unit>
        <trans-unit id="c26ef24c1e9c01425e91a34b0caa85ab70d66bf6" translate="yes" xml:space="preserve">
          <source>Packages distributed as part of Emacs that use the &lt;code&gt;:package-version&lt;/code&gt; keyword must also update the &lt;code&gt;customize-package-emacs-version-alist&lt;/code&gt; variable.</source>
          <target state="translated">&lt;code&gt;:package-version&lt;/code&gt; キーワードを使用するEmacsの一部として配布されるパッケージは、 &lt;code&gt;customize-package-emacs-version-alist&lt;/code&gt; 変数も更新する必要があります。</target>
        </trans-unit>
        <trans-unit id="3a39b68c35be609fae3db651a70893a29f102145" translate="yes" xml:space="preserve">
          <source>Packaging</source>
          <target state="translated">Packaging</target>
        </trans-unit>
        <trans-unit id="42f9009cd9572c10d5a27ab040ba2ba3d71640ce" translate="yes" xml:space="preserve">
          <source>Packaging Basics</source>
          <target state="translated">パッケージングの基本</target>
        </trans-unit>
        <trans-unit id="e0fb56429e1a2ef765c166a971fbafb2df17fb78" translate="yes" xml:space="preserve">
          <source>Packing and Unpacking Byte Arrays</source>
          <target state="translated">バイト配列のパッキングとアンパッキング</target>
        </trans-unit>
        <trans-unit id="7cba3e212dcc3d05c7ed8450a9553450544ee41d" translate="yes" xml:space="preserve">
          <source>PageDown</source>
          <target state="translated">PageDown</target>
        </trans-unit>
        <trans-unit id="2e2bbfe16d99367325be3ba50291408aefa81595" translate="yes" xml:space="preserve">
          <source>Paired delimiters: &amp;lsquo;</source>
          <target state="translated">ペアの区切り文字： '</target>
        </trans-unit>
        <trans-unit id="d4c7c2e3ad59ecdbc81f52c2333acc0ab45fc3f5" translate="yes" xml:space="preserve">
          <source>Pairs of characters are compared according to their character codes. Keep in mind that lower case letters have higher numeric values in the</source>
          <target state="translated">文字のペアは、文字コードによって比較されます。では、小文字の方が数値が高いことを覚えておいてください。</target>
        </trans-unit>
        <trans-unit id="2836a2cd0203ab3c4a413cfd2f0b910b3a2b2fef" translate="yes" xml:space="preserve">
          <source>Parameters common for all frames on terminal.</source>
          <target state="translated">端末上のすべてのフレームに共通のパラメータ。</target>
        </trans-unit>
        <trans-unit id="82045ada54eb55bca7be07c13568a28bcd4565bf" translate="yes" xml:space="preserve">
          <source>Parameters describing the X- and Y-offsets of a frame are always measured in pixels. For a normal, non-child frame they specify the frame&amp;rsquo;s outer position (see &lt;a href=&quot;frame-geometry#Frame-Geometry&quot;&gt;Frame Geometry&lt;/a&gt;) relative to its display&amp;rsquo;s origin. For a child frame (see &lt;a href=&quot;child-frames#Child-Frames&quot;&gt;Child Frames&lt;/a&gt;) they specify the frame&amp;rsquo;s outer position relative to the native position of the frame&amp;rsquo;s parent frame. (Note that none of these parameters is meaningful on TTY frames.)</source>
          <target state="translated">フレームのXオフセットとYオフセットを表すパラメータは、常にピクセル単位で測定されます。通常の子以外のフレームの場合、ディスプレイの原点を基準にしたフレームの外側の位置（&lt;a href=&quot;frame-geometry#Frame-Geometry&quot;&gt;フレームジオメトリを&lt;/a&gt;参照）を指定します。子フレームについて（参照&lt;a href=&quot;child-frames#Child-Frames&quot;&gt;子フレームを&lt;/a&gt;、彼らは、フレームの親フレームの本来の位置に枠の外側の位置を指定します）。（これらのパラメーターはいずれもTTYフレームでは意味がないことに注意してください。）</target>
        </trans-unit>
        <trans-unit id="6fe4da0442db9ec376fd1ebd0885e7871dd6c06a" translate="yes" xml:space="preserve">
          <source>Parameters for interacting with other frames.</source>
          <target state="translated">他のフレームと対話するためのパラメータ。</target>
        </trans-unit>
        <trans-unit id="187e29395efb81d6e368498d4c21b83faa4f6bac" translate="yes" xml:space="preserve">
          <source>Parameters for resizing and moving frames with the mouse.</source>
          <target state="translated">マウスでフレームをリサイズしたり移動したりするためのパラメータ。</target>
        </trans-unit>
        <trans-unit id="3304283cc7ef5bd20c4b8b92ab9f7d659a1d933a" translate="yes" xml:space="preserve">
          <source>Parameters that affect parsing.</source>
          <target state="translated">解析に影響を与えるパラメータ。</target>
        </trans-unit>
        <trans-unit id="662b563f3e8a80a489f1f7aa600b993494c4ca80" translate="yes" xml:space="preserve">
          <source>Parameters that are fundamental.</source>
          <target state="translated">基本となるパラメータ。</target>
        </trans-unit>
        <trans-unit id="71dcb10469ca71f255f80878d6bb08653414646f" translate="yes" xml:space="preserve">
          <source>Parameters to Control Parsing</source>
          <target state="translated">解析を制御するためのパラメータ</target>
        </trans-unit>
        <trans-unit id="3a77d88b486083a5b1a286e032cc2eaf602cab89" translate="yes" xml:space="preserve">
          <source>Parent mode for buffers containing tabulated data.</source>
          <target state="translated">集計データを含むバッファの親モード。</target>
        </trans-unit>
        <trans-unit id="00e169811424fee10d949efd728dc5985c0c3f1b" translate="yes" xml:space="preserve">
          <source>Parent type: &lt;code&gt;array&lt;/code&gt;.</source>
          <target state="translated">親タイプ： &lt;code&gt;array&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fc475e11afc91bfdb5091ef734af47c9e9ec4c73" translate="yes" xml:space="preserve">
          <source>Parent type: &lt;code&gt;list&lt;/code&gt;.</source>
          <target state="translated">親タイプ： &lt;code&gt;list&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f98d45fa291377ce2d003ec40640eeb0e4c79445" translate="yes" xml:space="preserve">
          <source>Parent type: &lt;code&gt;number&lt;/code&gt;.</source>
          <target state="translated">親タイプ： &lt;code&gt;number&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="defc0b42f93cf65435dd3de8a8247bacb70982ad" translate="yes" xml:space="preserve">
          <source>Parent type: &lt;code&gt;sequence&lt;/code&gt;.</source>
          <target state="translated">親タイプ： &lt;code&gt;sequence&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f1b04c0c36b344236da631ede7b83372f26428b9" translate="yes" xml:space="preserve">
          <source>Parent type: &lt;code&gt;symbol&lt;/code&gt;</source>
          <target state="translated">親タイプ： &lt;code&gt;symbol&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7a33d7f2f11c1fed9edd1a0648e4921a4b929017" translate="yes" xml:space="preserve">
          <source>Parent windows do not display buffers, and play little role in display except to shape their child windows. Emacs Lisp programs cannot directly manipulate parent windows; they operate on the windows at the leaves of the tree, which actually display buffers.</source>
          <target state="translated">親ウィンドウはバッファを表示せず、子ウィンドウの形を整える以外には、表示にほとんど役割を果たしません。Emacs Lisp プログラムは親ウィンドウを直接操作することはできません。</target>
        </trans-unit>
        <trans-unit id="a9a6581c08789385ed2a0f325a688a832347f188" translate="yes" xml:space="preserve">
          <source>Parser State</source>
          <target state="translated">パーサ状態</target>
        </trans-unit>
        <trans-unit id="4526a4b5852177789cf8e9bfecfe9da2131c54cb" translate="yes" xml:space="preserve">
          <source>Parsing Expressions</source>
          <target state="translated">式の解析</target>
        </trans-unit>
        <trans-unit id="e231765095ab882fb7fcf938cb7f6e8c8c4b17f6" translate="yes" xml:space="preserve">
          <source>Parsing HTML and XML</source>
          <target state="translated">HTML と XML の解析</target>
        </trans-unit>
        <trans-unit id="fe6bf59025bd0e2925b6d89834e3acc681649e86" translate="yes" xml:space="preserve">
          <source>Parsing HTML and XML.</source>
          <target state="translated">HTML と XML を解析します。</target>
        </trans-unit>
        <trans-unit id="08eb2ab878002b2ff0551a7f614ba8a4ce7a1b19" translate="yes" xml:space="preserve">
          <source>Parsing across a specified region.</source>
          <target state="translated">指定された領域にまたがってパースします。</target>
        </trans-unit>
        <trans-unit id="f40cea5e85407269571363df9bd9391ce3f4ad7b" translate="yes" xml:space="preserve">
          <source>Parsing and Formatting Times</source>
          <target state="translated">構文解析と書式設定の時間</target>
        </trans-unit>
        <trans-unit id="ac97cfccea0017cf98319b0ca0948a055efe585f" translate="yes" xml:space="preserve">
          <source>Parsing and generating JSON values</source>
          <target state="translated">JSON値のパースと生成</target>
        </trans-unit>
        <trans-unit id="d9c9a717935cc6b02f547040191d6f2545e876ed" translate="yes" xml:space="preserve">
          <source>Parsing and generating JSON values.</source>
          <target state="translated">JSON値をパースして生成します。</target>
        </trans-unit>
        <trans-unit id="5217da08a22ae64804bc400d2407ec040403c3c7" translate="yes" xml:space="preserve">
          <source>Parsing balanced expressions using the syntax table.</source>
          <target state="translated">構文表を使用してバランス式を解析します。</target>
        </trans-unit>
        <trans-unit id="cfd676e977daa56fd9d54f7c8b9c4143d00aec36" translate="yes" xml:space="preserve">
          <source>Parsing geometry specifications.</source>
          <target state="translated">ジオメトリの仕様を解析します。</target>
        </trans-unit>
        <trans-unit id="094f3d7cfff68518244aec1c04b390842b32aced" translate="yes" xml:space="preserve">
          <source>Particular properties with special meanings.</source>
          <target state="translated">特別な意味を持つ特殊な性質。</target>
        </trans-unit>
        <trans-unit id="7bdf4b7194fa08f8c2706fdc986660b700d98bb5" translate="yes" xml:space="preserve">
          <source>Parts of words in human languages. These are typically used in variable and command names in programs. All upper- and lower-case letters, and the digits, are typically word constituents.</source>
          <target state="translated">人間の言語における単語の一部。これらは通常、プログラムの変数名やコマンド名に使用されます。すべての大文字と小文字、および数字は、典型的には単語の構成要素である。</target>
        </trans-unit>
        <trans-unit id="3fe618d6f369040b19cdcd8393043d5b040f5577" translate="yes" xml:space="preserve">
          <source>Pattern-Matching Conditional</source>
          <target state="translated">パターンマッチング条件付き</target>
        </trans-unit>
        <trans-unit id="4849c1facbc8d17ea4d09ce55cc45604ad2f39f1" translate="yes" xml:space="preserve">
          <source>Pcase patterns not only express a condition on the form of the objects they can match, but they can also extract sub-fields of those objects. For example we can extract 2 elements from a list that is the value of the variable &lt;code&gt;my-list&lt;/code&gt; with the following code:</source>
          <target state="translated">Pcaseパターンは、一致できるオブジェクトの形式に関する条件を表すだけでなく、それらのオブジェクトのサブフィールドを抽出することもできます。たとえば、次のコードを使用して、変数 &lt;code&gt;my-list&lt;/code&gt; の値であるリストから2つの要素を抽出できます。</target>
        </trans-unit>
        <trans-unit id="f88d30015d65ab6f358329e5144fe34af976d4ca" translate="yes" xml:space="preserve">
          <source>People are sometimes tempted to create a variable whose value is a face name. In the vast majority of cases, this is not necessary; the usual procedure is to define a face with &lt;code&gt;defface&lt;/code&gt;, and then use its name directly.</source>
          <target state="translated">顔の名前を値とする変数を作成したくなることがあります。ほとんどの場合、これは必要ありません。通常の手順は、 &lt;code&gt;defface&lt;/code&gt; を使用して面を定義し、その名前を直接使用することです。</target>
        </trans-unit>
        <trans-unit id="16d67645704093cc2992f9742e395e378a4a7842" translate="yes" xml:space="preserve">
          <source>People do not write byte-code; that job is left to the byte compiler. But we provide a disassembler to satisfy a cat-like curiosity. The disassembler converts the byte-compiled code into human-readable form.</source>
          <target state="translated">バイトコードを書くのはバイトコンパイラに任されています。しかし、私たちは猫のような好奇心を満たすためにディスアセンブラを提供しています。このディスアセンブラは、バイトでコンパイルされたコードを人間が読める形に変換してくれます。</target>
        </trans-unit>
        <trans-unit id="d246b3473da94f1b94146151c91359171732e430" translate="yes" xml:space="preserve">
          <source>People often use &lt;code&gt;global-set-key&lt;/code&gt; in their init files (see &lt;a href=&quot;init-file#Init-File&quot;&gt;Init File&lt;/a&gt;) for simple customization. For example,</source>
          <target state="translated">人々は頻繁に使用する &lt;code&gt;global-set-key&lt;/code&gt; 自分のinitファイル（参照で&lt;a href=&quot;init-file#Init-File&quot;&gt;初期化ファイルを&lt;/a&gt;、簡単なカスタマイズのため）。例えば、</target>
        </trans-unit>
        <trans-unit id="26e74f2999a60551463cceee8a64dda32c66da77" translate="yes" xml:space="preserve">
          <source>Perform &lt;var&gt;action&lt;/var&gt; if the user clicks on a button.</source>
          <target state="translated">ユーザーがボタンをクリックした場合に &lt;var&gt;action&lt;/var&gt; 実行します。</target>
        </trans-unit>
        <trans-unit id="6aa0734a37f43c716d45db437864376f51cf5a6d" translate="yes" xml:space="preserve">
          <source>Perform a quit right away. Only &lt;code&gt;y-or-n-p&lt;/code&gt; and related functions use this answer.</source>
          <target state="translated">すぐに終了します。 &lt;code&gt;y-or-n-p&lt;/code&gt; および関連する関数のみがこの回答を使用します。</target>
        </trans-unit>
        <trans-unit id="69869cd815dc383536f8d4d158ed0475269499de" translate="yes" xml:space="preserve">
          <source>Perform destructuring binding of variables according to &lt;var&gt;bindings&lt;/var&gt;, and then evaluate &lt;var&gt;body&lt;/var&gt;.</source>
          <target state="translated">&lt;var&gt;bindings&lt;/var&gt; に従って変数のデストラクチャリングバインディングを実行してから、 &lt;var&gt;body&lt;/var&gt; を評価します。</target>
        </trans-unit>
        <trans-unit id="c54c145e4d62a63d0c1782ba7e752fadb7b82eec" translate="yes" xml:space="preserve">
          <source>Perform the action specified by a button at location &lt;var&gt;pos&lt;/var&gt;. &lt;var&gt;pos&lt;/var&gt; may be either a buffer position or a mouse-event. If &lt;var&gt;use-mouse-action&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, or &lt;var&gt;pos&lt;/var&gt; is a mouse-event (see &lt;a href=&quot;mouse-events#Mouse-Events&quot;&gt;Mouse Events&lt;/a&gt;), try to invoke the button&amp;rsquo;s &lt;code&gt;mouse-action&lt;/code&gt; property instead of &lt;code&gt;action&lt;/code&gt;; if the button has no &lt;code&gt;mouse-action&lt;/code&gt; property, use &lt;code&gt;action&lt;/code&gt; as normal. &lt;var&gt;pos&lt;/var&gt; defaults to point, except when &lt;code&gt;push-button&lt;/code&gt; is invoked interactively as the result of a mouse-event, in which case, the mouse event&amp;rsquo;s position is used. If there&amp;rsquo;s no button at &lt;var&gt;pos&lt;/var&gt;, do nothing and return &lt;code&gt;nil&lt;/code&gt;, otherwise return &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">位置 &lt;var&gt;pos&lt;/var&gt; のボタンで指定されたアクションを実行します。 &lt;var&gt;pos&lt;/var&gt; は、バッファ位置またはマウスイベントのいずれかです。場合は &lt;var&gt;use-mouse-action&lt;/var&gt; 非で &lt;code&gt;nil&lt;/code&gt; で、または &lt;var&gt;pos&lt;/var&gt; がマウスイベントである（参照&lt;a href=&quot;mouse-events#Mouse-Events&quot;&gt;マウスイベントを&lt;/a&gt;、ボタンの呼び出そう） &lt;code&gt;mouse-action&lt;/code&gt; の代わりにプロパティを &lt;code&gt;action&lt;/code&gt; 。ボタンに &lt;code&gt;mouse-action&lt;/code&gt; プロパティがない場合は、通常どおり &lt;code&gt;action&lt;/code&gt; を使用します。 &lt;var&gt;pos&lt;/var&gt; は、マウスイベントの結果として &lt;code&gt;push-button&lt;/code&gt; がインタラクティブに呼び出される場合を除いて、デフォルトでポイントになります。この場合、マウスイベントの位置が使用されます。で、何のボタンがない場合は &lt;var&gt;pos&lt;/var&gt; 、何もせずに &lt;code&gt;nil&lt;/code&gt; を返します。それ以外の場合は、 &lt;code&gt;t&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="4f225f76cbcb682ebabbd6df30985ed39beadca0" translate="yes" xml:space="preserve">
          <source>Perform the specified window scroll operation, then ask the same question again. Only &lt;code&gt;y-or-n-p&lt;/code&gt; and related functions use this answer.</source>
          <target state="translated">指定されたウィンドウスクロール操作を実行してから、同じ質問をもう一度行ってください。 &lt;code&gt;y-or-n-p&lt;/code&gt; および関連する関数のみがこの回答を使用します。</target>
        </trans-unit>
        <trans-unit id="67a71f8eb164bf8cbebbd57b3abbfb3d805ffe84" translate="yes" xml:space="preserve">
          <source>Performance of Byte-Compiled Code</source>
          <target state="translated">バイトコンパイルされたコードの性能</target>
        </trans-unit>
        <trans-unit id="6547e00c11db8db176592a59424033b3f90c9a4b" translate="yes" xml:space="preserve">
          <source>Piecemeal Specification</source>
          <target state="translated">ピース単位の仕様</target>
        </trans-unit>
        <trans-unit id="8a2c6ee815e7a7247ddacfd3b50b4d7a7829a89f" translate="yes" xml:space="preserve">
          <source>Pixel Specification for Spaces</source>
          <target state="translated">空間のピクセル仕様</target>
        </trans-unit>
        <trans-unit id="e342bbd9ca43541fd7f27aae1acd3394adc60779" translate="yes" xml:space="preserve">
          <source>Place a &lt;code&gt;font-lock-multiline&lt;/code&gt; property on the construct. This will rehighlight the whole construct if any part of it is changed. In some cases you can do this automatically by setting the &lt;code&gt;font-lock-multiline&lt;/code&gt; variable, which see.</source>
          <target state="translated">構成に &lt;code&gt;font-lock-multiline&lt;/code&gt; プロパティを配置します。これにより、構成の一部が変更された場合に、構成全体が再度強調表示されます。場合によっては、 &lt;code&gt;font-lock-multiline&lt;/code&gt; 変数を設定することでこれを自動的に行うことができます。</target>
        </trans-unit>
        <trans-unit id="c235c05182119ad368fe267076dee6d0dd6a6b9c" translate="yes" xml:space="preserve">
          <source>Place a &lt;code&gt;jit-lock-defer-multiline&lt;/code&gt; property on the construct. This works only if &lt;code&gt;jit-lock-contextually&lt;/code&gt; is used, and with the same delay before rehighlighting, but like &lt;code&gt;font-lock-multiline&lt;/code&gt;, it also handles the case where highlighting depends on subsequent lines.</source>
          <target state="translated">置き &lt;code&gt;jit-lock-defer-multiline&lt;/code&gt; 構造上の特性を。これは、 &lt;code&gt;jit-lock-contextually&lt;/code&gt; が使用されている場合にのみ機能し、再強調表示までの遅延は同じ &lt;code&gt;font-lock-multiline&lt;/code&gt; が、font-lock-multilineと同様に、強調表示が後続の行に依存する場合も処理します。</target>
        </trans-unit>
        <trans-unit id="0892bc999ffda43cddb1e182b36617e30f0fe235" translate="yes" xml:space="preserve">
          <source>Playing sounds on the computer&amp;rsquo;s speaker.</source>
          <target state="translated">コンピューターのスピーカーで音を鳴らす。</target>
        </trans-unit>
        <trans-unit id="061394dac9aea5d18455df9eaa1d0cd858c9f0b8" translate="yes" xml:space="preserve">
          <source>Please answer y or n.</source>
          <target state="translated">yまたはnと答えてください。</target>
        </trans-unit>
        <trans-unit id="6a490ec11b9140306205d30629596595e9b6e94f" translate="yes" xml:space="preserve">
          <source>Please answer yes or no.</source>
          <target state="translated">イエスかノーかお答えください。</target>
        </trans-unit>
        <trans-unit id="71ece59413670b96fc75ee700d7e27c649f7e924" translate="yes" xml:space="preserve">
          <source>Please send comments and corrections using</source>
          <target state="translated">コメントや訂正は、以下の方法でお送りください。</target>
        </trans-unit>
        <trans-unit id="f79a28423ed1ae0232efb54ad41227d0955084f3" translate="yes" xml:space="preserve">
          <source>Point</source>
          <target state="translated">Point</target>
        </trans-unit>
        <trans-unit id="f5cc952a1d9de36117c7758546bd79fa0d592285" translate="yes" xml:space="preserve">
          <source>Point (2) implies that a &lt;code&gt;:weight black&lt;/code&gt; attribute will be satisfied by any display that can display bold, as will &lt;code&gt;:foreground &quot;yellow&quot;&lt;/code&gt; as long as some yellowish color can be displayed, but &lt;code&gt;:slant italic&lt;/code&gt; will &lt;em&gt;not&lt;/em&gt; be satisfied by the tty display code&amp;rsquo;s automatic substitution of a dim face for italic.</source>
          <target state="translated">点（2）ことを意味 &lt;code&gt;:weight black&lt;/code&gt; れるように属性は、太字表示することができる任意のディスプレイによって満足される &lt;code&gt;:foreground &quot;yellow&quot;&lt;/code&gt; 長いいくつかの黄色がかった色のように表示することができるが、 &lt;code&gt;:slant italic&lt;/code&gt; あろう&lt;em&gt;ない&lt;/em&gt;TTYによって満たされます表示コードが自動的に薄暗い面を斜体に置き換えます。</target>
        </trans-unit>
        <trans-unit id="396cf0edbfa0128fdb159e61630df3d416f1062f" translate="yes" xml:space="preserve">
          <source>Point and the mark, as two numeric arguments, smallest first. This is the only code letter that specifies two successive arguments rather than one. This will signal an error if the mark is not set in the buffer which is current when the command is invoked. No I/O.</source>
          <target state="translated">ポイントとマークは、2つの数値引数として、小さい方から先に指定します。これは、1つではなく2つの連続した引数を指定する唯一のコードレターです。これは、コマンドが呼び出されたときに現在のバッファにマークがセットされていない場合にエラーを通知します。I/Oはありません。</target>
        </trans-unit>
        <trans-unit id="607e97203b9ceed3b508490569d375e75af49959" translate="yes" xml:space="preserve">
          <source>Pointer Shape</source>
          <target state="translated">ポインター形状</target>
        </trans-unit>
        <trans-unit id="952493c99caa2adef127c34f7eb386dd95d6f98f" translate="yes" xml:space="preserve">
          <source>Polymorphism, Emacs-style.</source>
          <target state="translated">Emacsスタイルのポリモーフィズム。</target>
        </trans-unit>
        <trans-unit id="ed7450dfdd1d277c3cabc1ce06c43cba4a362b92" translate="yes" xml:space="preserve">
          <source>Pop-Up Menus</source>
          <target state="translated">ポップアップメニュー</target>
        </trans-unit>
        <trans-unit id="5307f05e0199e2333e229d7e2d00200cc6d0db03" translate="yes" xml:space="preserve">
          <source>Popping up a new window will fail if there is not enough space on the selected frame. In an uncustomized Emacs it typically fails when there are already two windows on a frame. For example, if you now type</source>
          <target state="translated">選択したフレームに十分なスペースがない場合、新しいウィンドウのポップアップは失敗します。カスタマイズされていないEmacsでは、1つのフレームにすでに2つのウィンドウがある場合に失敗するのが一般的です。例えば、今</target>
        </trans-unit>
        <trans-unit id="a6a8cdd50e41aeb0ad1784d8f1195a61e89f7520" translate="yes" xml:space="preserve">
          <source>Position Parameters</source>
          <target state="translated">位置パラメータ</target>
        </trans-unit>
        <trans-unit id="fcd7e6b774c8f47ead8ead0ed8f33c8f9f736a14" translate="yes" xml:space="preserve">
          <source>Position of the top-left corner and size of the work area (usable space) in pixels as &amp;lsquo;</source>
          <target state="translated">左上隅の位置と作業領域（使用可能なスペース）のサイズ（ピクセル単位） '</target>
        </trans-unit>
        <trans-unit id="e7f9862a7c40fe020b33ccbf1989aac5bbb93333" translate="yes" xml:space="preserve">
          <source>Position of the top-left corner of the monitor&amp;rsquo;s screen and its size, in pixels, as &amp;lsquo;</source>
          <target state="translated">モニターの画面の左上隅の位置とそのサイズ（ピクセル単位）、 '</target>
        </trans-unit>
        <trans-unit id="cd4683fadf7005eca07e4d6267ddbb19ebcb91fa" translate="yes" xml:space="preserve">
          <source>Positions</source>
          <target state="translated">Positions</target>
        </trans-unit>
        <trans-unit id="da11d4c9a25e9c8a4126db50b558133457b0ac80" translate="yes" xml:space="preserve">
          <source>Positions are usually represented as integers starting from 1, but can also be represented as &lt;em&gt;markers&lt;/em&gt;&amp;mdash;special objects that relocate automatically when text is inserted or deleted so they stay with the surrounding characters. Functions that expect an argument to be a position (an integer), but accept a marker as a substitute, normally ignore which buffer the marker points into; they convert the marker to an integer, and use that integer, exactly as if you had passed the integer as the argument, even if the marker points to the wrong buffer. A marker that points nowhere cannot convert to an integer; using it instead of an integer causes an error. See &lt;a href=&quot;markers#Markers&quot;&gt;Markers&lt;/a&gt;.</source>
          <target state="translated">位置は通常、1から始まる整数として表されますが、&lt;em&gt;マーカー&lt;/em&gt;として表すこともできます。これは、テキストが挿入または削除されると自動的に再配置され、周囲の文字と一緒に残る特別なオブジェクトです。引数が位置（整数）であることを期待しているが、代わりにマーカーを受け入れる関数は、通常、マーカーが指すバッファーを無視します。マーカーが間違ったバッファーを指している場合でも、マーカーを整数に変換し、引数として整数を渡した場合とまったく同じように、その整数を使用します。どこも指さないマーカーは整数に変換できません。整数の代わりに使用すると、エラーが発生します。&lt;a href=&quot;markers#Markers&quot;&gt;マーカーを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="0d57c1560194ed5b9740be5062e662f21bf258a8" translate="yes" xml:space="preserve">
          <source>Precalculated Fontification</source>
          <target state="translated">事前に計算されたフォント化</target>
        </trans-unit>
        <trans-unit id="bb31a3184fc540673e8536291743e02cc7cb150c" translate="yes" xml:space="preserve">
          <source>Precautions about loading a file twice.</source>
          <target state="translated">ファイルを2回読み込む場合の注意事項</target>
        </trans-unit>
        <trans-unit id="566ae5a22bce2d820a88dbf4901446093188d136" translate="yes" xml:space="preserve">
          <source>Precedence conflicts can be resolved via &lt;var&gt;resolvers&lt;/var&gt;, which is a list of &lt;em&gt;precs&lt;/em&gt; tables (see &lt;code&gt;smie-precs-&amp;gt;prec2&lt;/code&gt;): for each precedence conflict, if those &lt;code&gt;precs&lt;/code&gt; tables specify a particular constraint, then the conflict is resolved by using this constraint instead, else a conflict is reported and one of the conflicting constraints is picked arbitrarily and the others are simply ignored.</source>
          <target state="translated">優先順位の競合は、&lt;em&gt;precs&lt;/em&gt;テーブルのリストである &lt;var&gt;resolvers&lt;/var&gt; を介して解決できます（ &lt;code&gt;smie-precs-&amp;gt;prec2&lt;/code&gt; を参照）。優先順位の競合ごとに、それらの &lt;code&gt;precs&lt;/code&gt; テーブルが特定の制約を指定している場合、代わりにこの制約を使用して競合を解決します。それ以外の場合は、競合が報告され、競合する制約の1つが任意に選択され、他の制約は単に無視されます。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="964094642c54dd1cde6edca379d013120bbe6cdf" translate="yes" xml:space="preserve">
          <source>Precedence of Action Functions</source>
          <target state="translated">動作機能の優先順位</target>
        </trans-unit>
        <trans-unit id="7f421f63196a5c9594ee21a2f12cf973d50a9e3c" translate="yes" xml:space="preserve">
          <source>Precisely what this function does depends on your operating system. The function is designed to work with the syntax of your system&amp;rsquo;s standard shell; if you use an unusual shell, you will need to redefine this function. See &lt;a href=&quot;security-considerations#Security-Considerations&quot;&gt;Security Considerations&lt;/a&gt;.</source>
          <target state="translated">この機能が何をするかは、オペレーティングシステムによって異なります。この関数は、システムの標準シェルの構文で機能するように設計されています。異常なシェルを使用する場合は、この関数を再定義する必要があります。&lt;a href=&quot;security-considerations#Security-Considerations&quot;&gt;セキュリティに関する考慮事項を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="b5f5818990ffb371882dce4537255efe1cd466f7" translate="yes" xml:space="preserve">
          <source>Predicates for Strings</source>
          <target state="translated">文字列の述語</target>
        </trans-unit>
        <trans-unit id="442ffe2a26e139b52c8f550f48e68a7ff0384a94" translate="yes" xml:space="preserve">
          <source>Predicates on Lists</source>
          <target state="translated">リストの述語</target>
        </trans-unit>
        <trans-unit id="d49b8773d143e9fa0eb02a21089beeae242b1962" translate="yes" xml:space="preserve">
          <source>Predicates on Markers</source>
          <target state="translated">マーカーの述語</target>
        </trans-unit>
        <trans-unit id="46f7b3c414e7e9b45a8f34a40c695f3aa31c75d5" translate="yes" xml:space="preserve">
          <source>Prefer &lt;code&gt;bool&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt; and &lt;code&gt;true&lt;/code&gt; for booleans. Using &lt;code&gt;bool&lt;/code&gt; can make programs easier to read and a bit faster than using &lt;code&gt;int&lt;/code&gt;. Although it is also OK to use &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;1&lt;/code&gt;, this older style is gradually being phased out. When using &lt;code&gt;bool&lt;/code&gt;, respect the limitations of the replacement implementation of &lt;code&gt;bool&lt;/code&gt;, as documented in the source file</source>
          <target state="translated">優先 &lt;code&gt;bool&lt;/code&gt; 、 &lt;code&gt;false&lt;/code&gt; と &lt;code&gt;true&lt;/code&gt; ブール値のため。 &lt;code&gt;bool&lt;/code&gt; を使用すると、 &lt;code&gt;int&lt;/code&gt; を使用するよりもプログラムが読みやすくなり、少し速くなります。それは使用することもOKですが &lt;code&gt;int&lt;/code&gt; 、 &lt;code&gt;0&lt;/code&gt; と &lt;code&gt;1&lt;/code&gt; を、この古いスタイルが徐々に段階的に廃止されています。 &lt;code&gt;bool&lt;/code&gt; を使用するときは、ソースファイルに記載されているように、 &lt;code&gt;bool&lt;/code&gt; の置換実装の制限を尊重してください。</target>
        </trans-unit>
        <trans-unit id="e90dac2bef91521c9b188ca145887974636ecc63" translate="yes" xml:space="preserve">
          <source>Prefer &lt;code&gt;int&lt;/code&gt; for Emacs character codes, in the range 0 .. 0x3FFFFF. More generally, prefer &lt;code&gt;int&lt;/code&gt; for integers known to be in &lt;code&gt;int&lt;/code&gt; range, e.g., screen column counts.</source>
          <target state="translated">好む &lt;code&gt;int&lt;/code&gt; 型の範囲0 .. 0x3FFFFFで、Emacsの文字コードのために。より一般的には、 &lt;code&gt;int&lt;/code&gt; の範囲内にあることがわかっている整数、たとえば画面の列数には &lt;code&gt;int&lt;/code&gt; を優先します。</target>
        </trans-unit>
        <trans-unit id="6abf985b52c94873bd501a840ff79256f37b786f" translate="yes" xml:space="preserve">
          <source>Prefer &lt;code&gt;intmax_t&lt;/code&gt; for representing values that might be any signed integer value. A &lt;code&gt;printf&lt;/code&gt;-family function can print such a value via a format like &lt;code&gt;&quot;%&quot;PRIdMAX&lt;/code&gt;.</source>
          <target state="translated">任意の符号付き整数値である可能性のある値を表すには、 &lt;code&gt;intmax_t&lt;/code&gt; を優先します。 &lt;code&gt;printf&lt;/code&gt; の-family関数のような形式を介してそのような値を印刷することができ &lt;code&gt;&quot;%&quot;PRIdMAX&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5aba5324ce8cab9dcb20a85c6046cc14468964db" translate="yes" xml:space="preserve">
          <source>Prefer &lt;code&gt;ptrdiff_t&lt;/code&gt; for sizes, i.e., for integers bounded by the maximum size of any individual C object or by the maximum number of elements in any C array. This is part of Emacs&amp;rsquo;s general preference for signed types. Using &lt;code&gt;ptrdiff_t&lt;/code&gt; limits objects to &lt;code&gt;PTRDIFF_MAX&lt;/code&gt; bytes, but larger objects would cause trouble anyway since they would break pointer subtraction, so this does not impose an arbitrary limit.</source>
          <target state="translated">サイズ、つまり、個々のCオブジェクトの最大サイズまたは任意のC配列の要素の最大数によって制限される整数の場合は、 &lt;code&gt;ptrdiff_t&lt;/code&gt; を優先します。これは、署名されたタイプに対するEmacsの一般的な好みの一部です。 &lt;code&gt;ptrdiff_t&lt;/code&gt; を使用すると、オブジェクトは &lt;code&gt;PTRDIFF_MAX&lt;/code&gt; バイトに制限されますが、オブジェクトが大きいと、ポインターの減算が中断されるため、とにかく問題が発生するため、任意の制限はありません。</target>
        </trans-unit>
        <trans-unit id="8e94bb20236e0858945d4668328a5de11ef32384" translate="yes" xml:space="preserve">
          <source>Prefer signed types to unsigned, as code gets confusing when signed and unsigned types are combined. Many other guidelines assume that types are signed; in the rarer cases where unsigned types are needed, similar advice may apply to the unsigned counterparts (e.g., &lt;code&gt;size_t&lt;/code&gt; instead of &lt;code&gt;ptrdiff_t&lt;/code&gt;, or &lt;code&gt;uintptr_t&lt;/code&gt; instead of &lt;code&gt;intptr_t&lt;/code&gt;).</source>
          <target state="translated">符号付きタイプと符号なしタイプを組み合わせるとコードが混乱するため、符号なしタイプよりも符号付きタイプを優先します。他の多くのガイドラインは、型が署名されていることを前提としています。符号なしの型が必要なまれなケースでは、同様のアドバイスが符号なしの対応物に適用される場合があります（たとえば、 &lt;code&gt;ptrdiff_t&lt;/code&gt; の代わりに &lt;code&gt;size_t&lt;/code&gt; 、または &lt;code&gt;uintptr_t&lt;/code&gt; 代わりに &lt;code&gt;intptr_t&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="eb7db6d9838695e18c3cfbbb520e7db0376d0493" translate="yes" xml:space="preserve">
          <source>Prefer the Emacs-defined type &lt;code&gt;EMACS_INT&lt;/code&gt; for representing values converted to or from Emacs Lisp fixnums, as fixnum arithmetic is based on &lt;code&gt;EMACS_INT&lt;/code&gt;.</source>
          <target state="translated">fixnum演算は &lt;code&gt;EMACS_INT&lt;/code&gt; に基づいているため、Emacs Lisp fixnumsとの間で変換された値を表すには、Emacs定義の型 &lt;code&gt;EMACS_INT&lt;/code&gt; を優先します。</target>
        </trans-unit>
        <trans-unit id="90eceb016c51a762f15c7287008c113f6f37296c" translate="yes" xml:space="preserve">
          <source>Prefix</source>
          <target state="translated">Prefix</target>
        </trans-unit>
        <trans-unit id="f2dde8bb9369c48db82506a473e93f7ed3d5942d" translate="yes" xml:space="preserve">
          <source>Prefix Command Arguments</source>
          <target state="translated">プレフィックスコマンド引数</target>
        </trans-unit>
        <trans-unit id="fc822d5fffcf943b9b68bade876c53fa39133517" translate="yes" xml:space="preserve">
          <source>Prefix Command: &lt;strong&gt;help-command&lt;/strong&gt;</source>
          <target state="translated">プレフィックスコマンド：&lt;strong&gt;help-command&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8127e5cff40d331d2889508db678ae3da7edce03" translate="yes" xml:space="preserve">
          <source>Prefix Keys</source>
          <target state="translated">プレフィックスキー</target>
        </trans-unit>
        <trans-unit id="817021ee105a177dc2b7d088adcd2a6072b0d3fc" translate="yes" xml:space="preserve">
          <source>Prefix key definitions can appear in any active keymap. The definitions of</source>
          <target state="translated">プレフィックスキーの定義は、どのアクティブなキーマップにも現れることができます。キーの定義は</target>
        </trans-unit>
        <trans-unit id="5836ac851edf7d470c1d5663cc48d0f741b10afb" translate="yes" xml:space="preserve">
          <source>Prefix keys are not supported; each key binding must be for a single-event key sequence. This is because the functions don&amp;rsquo;t use &lt;code&gt;read-key-sequence&lt;/code&gt; to get the input; instead, they read a single event and look it up &amp;ldquo;by hand&amp;rdquo;.</source>
          <target state="translated">プレフィックスキーはサポートされていません。各キーバインディングは、単一イベントのキーシーケンス用である必要があります。これは、関数が入力を取得するために &lt;code&gt;read-key-sequence&lt;/code&gt; を使用しないためです。代わりに、彼らは単一のイベントを読み、それを「手作業で」調べます。</target>
        </trans-unit>
        <trans-unit id="c4ae4b776a504ab9c3984d5b960e50114372390f" translate="yes" xml:space="preserve">
          <source>Preparing Lisp code for distribution</source>
          <target state="translated">配布用のLispコードの準備</target>
        </trans-unit>
        <trans-unit id="10350ff9d1e72d872a5f8f9d7298748467902f2b" translate="yes" xml:space="preserve">
          <source>Preparing Lisp code for distribution.</source>
          <target state="translated">配布用のLispコードを準備します。</target>
        </trans-unit>
        <trans-unit id="3fbbb867e77ea91146750aea189a6cf551e1e134" translate="yes" xml:space="preserve">
          <source>Preserving Window Sizes</source>
          <target state="translated">ウィンドウサイズの保存</target>
        </trans-unit>
        <trans-unit id="0c99adaa60348b0a7126fde1061a297dc36572d3" translate="yes" xml:space="preserve">
          <source>Preserving parts of the window layout.</source>
          <target state="translated">ウィンドウレイアウトの一部を保存します。</target>
        </trans-unit>
        <trans-unit id="6a0869815cba064e511a1c537e094bcd0e750151" translate="yes" xml:space="preserve">
          <source>Preserving the frame layout when splitting and deleting windows.</source>
          <target state="translated">ウィンドウの分割・削除時にフレームレイアウトを保持する</target>
        </trans-unit>
        <trans-unit id="9c0038945c8e114f3f1807b0a52d587b5b1bd28c" translate="yes" xml:space="preserve">
          <source>Preserving the size of windows.</source>
          <target state="translated">窓の大きさを保つ。</target>
        </trans-unit>
        <trans-unit id="ea683ad616063b7347bdddeee7203a82e1a3805b" translate="yes" xml:space="preserve">
          <source>Press</source>
          <target state="translated">Press</target>
        </trans-unit>
        <trans-unit id="077d78d93e37589dfda68a661edba7765c9a96eb" translate="yes" xml:space="preserve">
          <source>Pretty name of the major mode, e.g., &lt;code&gt;&quot;Lisp&quot;&lt;/code&gt;.</source>
          <target state="translated">メジャーモードのかなりの名前、例えば &lt;code&gt;&quot;Lisp&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="531715daf7ebc8ef98855e02895358381e85f316" translate="yes" xml:space="preserve">
          <source>Pretty-print &lt;var&gt;dom&lt;/var&gt; at point. If &lt;var&gt;remove-empty&lt;/var&gt;, don&amp;rsquo;t print textual nodes that just contain white-space.</source>
          <target state="translated">ポイントでプリティプリントの &lt;var&gt;dom&lt;/var&gt; 。 &lt;var&gt;remove-empty&lt;/var&gt; の場合、空白だけを含むテキストノードを印刷しないでください。</target>
        </trans-unit>
        <trans-unit id="e9e155626bd628166db4aa789fdecee502d51e80" translate="yes" xml:space="preserve">
          <source>Primitive Function Type</source>
          <target state="translated">原始関数型</target>
        </trans-unit>
        <trans-unit id="d4b920e2aa288558fd4452eaffcbabb2af4ae49b" translate="yes" xml:space="preserve">
          <source>Primitive functions have no read syntax and print in hash notation with the name of the subroutine.</source>
          <target state="translated">原始関数は読み込み構文を持たず、サブルーチン名をハッシュ表記で表示します。</target>
        </trans-unit>
        <trans-unit id="6a9fe8615a701b97218da662f3a8ac14d6a4e2e2" translate="yes" xml:space="preserve">
          <source>Primitives to manipulate advice.</source>
          <target state="translated">アドバイスを操作するためのプリミティブ</target>
        </trans-unit>
        <trans-unit id="6fe4360c793f86fad27a09cbb948550825d8306d" translate="yes" xml:space="preserve">
          <source>Primitives to manipulate advices</source>
          <target state="translated">アドバイスを操作するためのプリミティブ</target>
        </trans-unit>
        <trans-unit id="06e0d7c66571d0f6d87aa8043cbfa0b78303b0e0" translate="yes" xml:space="preserve">
          <source>Print name</source>
          <target state="translated">印刷名</target>
        </trans-unit>
        <trans-unit id="69544e79a072d0314baaf9607247e3926667f4b3" translate="yes" xml:space="preserve">
          <source>Printed Representation and Read Syntax</source>
          <target state="translated">印刷表現と読み取り構文</target>
        </trans-unit>
        <trans-unit id="8ccedf5a8ea780671c6a52974e6be904b03133b1" translate="yes" xml:space="preserve">
          <source>Printing Notation</source>
          <target state="translated">印刷表記法</target>
        </trans-unit>
        <trans-unit id="7312416c2b8010e4c72ab0d5fa97039ad88c9d67" translate="yes" xml:space="preserve">
          <source>Printing can produce text that cannot be read. For example, buffers, windows, frames, subprocesses and markers print as text that starts with &amp;lsquo;</source>
          <target state="translated">印刷すると、読めないテキストが生成される可能性があります。たとえば、バッファ、ウィンドウ、フレーム、サブプロセス、およびマーカーは、 'で始まるテキストとして印刷されます。</target>
        </trans-unit>
        <trans-unit id="a49547abb517cf476f465ac950cd09fc7cf42082" translate="yes" xml:space="preserve">
          <source>Printing in Edebug</source>
          <target state="translated">エデブグでの印刷</target>
        </trans-unit>
        <trans-unit id="1478d8b6646a5b6c28fcb2c26cdab0af796a34c6" translate="yes" xml:space="preserve">
          <source>Prior to executing the command, Emacs runs &lt;code&gt;undo-boundary&lt;/code&gt; to create an undo boundary. See &lt;a href=&quot;maintaining-undo#Maintaining-Undo&quot;&gt;Maintaining Undo&lt;/a&gt;.</source>
          <target state="translated">コマンドを実行する前に、Emacsは &lt;code&gt;undo-boundary&lt;/code&gt; を実行してUNDO境界を作成します。&lt;a href=&quot;maintaining-undo#Maintaining-Undo&quot;&gt;元に戻すの維持を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="c9730a0155bb21c8af306ff2d9e1e2ca1ea11f5a" translate="yes" xml:space="preserve">
          <source>Prior to installation, a multi-file package is stored in a package archive as a tar file. The tar file must be named</source>
          <target state="translated">インストールの前に、マルチファイルパッケージは tar ファイルとしてパッケージアーカイブに保存されます。tar ファイルは</target>
        </trans-unit>
        <trans-unit id="ce845e6b0aa275c28de44782dd6ee706a0038583" translate="yes" xml:space="preserve">
          <source>Proceed to the stop point near where point is (&lt;code&gt;edebug-goto-here&lt;/code&gt;).</source>
          <target state="translated">ポイントがある場所の近くの停止ポイントに進みます（ &lt;code&gt;edebug-goto-here&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="a7ddba4cc1f556ac8301507aef95c2eb40133e9b" translate="yes" xml:space="preserve">
          <source>Process &lt;var&gt;spec-name&lt;/var&gt; as a sub-specification. This describes a structure nested within another structure.</source>
          <target state="translated">&lt;var&gt;spec-name&lt;/var&gt; をサブ仕様として処理します。これは、別の構造内にネストされた構造を表します。</target>
        </trans-unit>
        <trans-unit id="b61ce7d62891ad9c77d8356faa4d21e99475b062" translate="yes" xml:space="preserve">
          <source>Process Buffers</source>
          <target state="translated">プロセスバッファ</target>
        </trans-unit>
        <trans-unit id="388a07565282836943b234cb56d32f5aaedadf4d" translate="yes" xml:space="preserve">
          <source>Process Filter Functions</source>
          <target state="translated">プロセスフィルタ機能</target>
        </trans-unit>
        <trans-unit id="82bbfe85a5064f53c30df0b409969f7286c3ee10" translate="yes" xml:space="preserve">
          <source>Process Information</source>
          <target state="translated">プロセス情報</target>
        </trans-unit>
        <trans-unit id="47289f1e56f217b7b80a0cc10d8010bd99f47a6f" translate="yes" xml:space="preserve">
          <source>Process Internals</source>
          <target state="translated">プロセス内部</target>
        </trans-unit>
        <trans-unit id="a3ecc75c0ef59a79b8629845db769dd698d63aee" translate="yes" xml:space="preserve">
          <source>Process Type</source>
          <target state="translated">プロセスタイプ</target>
        </trans-unit>
        <trans-unit id="eb5f5e6bcdf5acb4a18fe835289e7deaa3131609" translate="yes" xml:space="preserve">
          <source>Process objects have no read syntax. They print in hash notation, giving the name of the process:</source>
          <target state="translated">プロセスオブジェクトには読み込み構文はありません。プロセスの名前を指定してハッシュ表記で表示します。</target>
        </trans-unit>
        <trans-unit id="7b2a6ac8c2aedf47a7dc723aeee816d7cb51bcb1" translate="yes" xml:space="preserve">
          <source>Process the &lt;var&gt;field-specs&lt;/var&gt; recursively, in order, then repeat starting from the first one, processing all the specifications &lt;var&gt;count&lt;/var&gt; times overall. The &lt;var&gt;count&lt;/var&gt; is given using the same formats as a field length&amp;mdash;if an &lt;code&gt;eval&lt;/code&gt; form is used, it is evaluated just once. For correct operation, each specification in &lt;var&gt;field-specs&lt;/var&gt; must include a name.</source>
          <target state="translated">処理 &lt;var&gt;field-specs&lt;/var&gt; すべての仕様を処理し、最初の1から始まる繰り返し、その後、順番に、再帰的に &lt;var&gt;count&lt;/var&gt; 全体的な回。 &lt;var&gt;count&lt;/var&gt; 長さが-場合は、フィールドと同じフォーマットを使用して与えられている &lt;code&gt;eval&lt;/code&gt; 形式が使用され、それが一度だけ評価されます。正しく動作させるには、 &lt;var&gt;field-specs&lt;/var&gt; の各仕様に名前を含める必要があります。</target>
        </trans-unit>
        <trans-unit id="ce0e1a372c609efa3318c56c4f9bd77418472459" translate="yes" xml:space="preserve">
          <source>Process-based JSONRPC connections</source>
          <target state="translated">プロセスベースの JSONRPC 接続</target>
        </trans-unit>
        <trans-unit id="ed7308bb59f2876220e45299939d241199595df2" translate="yes" xml:space="preserve">
          <source>Processes</source>
          <target state="translated">Processes</target>
        </trans-unit>
        <trans-unit id="5f86fd596bc409e1c58d5c382f46bf1605423851" translate="yes" xml:space="preserve">
          <source>Processes and Threads</source>
          <target state="translated">プロセスとスレッド</target>
        </trans-unit>
        <trans-unit id="14f958f6abd050bdccac455398bea4f88719fe76" translate="yes" xml:space="preserve">
          <source>Processor Run time</source>
          <target state="translated">プロセッサ実行時間</target>
        </trans-unit>
        <trans-unit id="7ca6cefa03b4cc37b1ca7248c4b3124ef11af957" translate="yes" xml:space="preserve">
          <source>Produces a literal &amp;lsquo;</source>
          <target state="translated">リテラルを生成します '</target>
        </trans-unit>
        <trans-unit id="cea5295b78ec1b99a624dda73a7e6d10f18cdf3f" translate="yes" xml:space="preserve">
          <source>Profiling</source>
          <target state="translated">Profiling</target>
        </trans-unit>
        <trans-unit id="c154c3adc3938975f05131376f2e5436e405861f" translate="yes" xml:space="preserve">
          <source>Prog mode binds &lt;code&gt;parse-sexp-ignore-comments&lt;/code&gt; to &lt;code&gt;t&lt;/code&gt; (see &lt;a href=&quot;motion-via-parsing#Motion-via-Parsing&quot;&gt;Motion via Parsing&lt;/a&gt;) and &lt;code&gt;bidi-paragraph-direction&lt;/code&gt; to &lt;code&gt;left-to-right&lt;/code&gt; (see &lt;a href=&quot;bidirectional-display#Bidirectional-Display&quot;&gt;Bidirectional Display&lt;/a&gt;).</source>
          <target state="translated">Progモードは、 &lt;code&gt;parse-sexp-ignore-comments&lt;/code&gt; を &lt;code&gt;t&lt;/code&gt; にバインドし（&lt;a href=&quot;motion-via-parsing#Motion-via-Parsing&quot;&gt;Motion via Parsingを&lt;/a&gt;参照）、 &lt;code&gt;bidi-paragraph-direction&lt;/code&gt; を &lt;code&gt;left-to-right&lt;/code&gt; バインドします（&lt;a href=&quot;bidirectional-display#Bidirectional-Display&quot;&gt;双方向表示を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="668caef4152238abda5f1efa569224f231dac599" translate="yes" xml:space="preserve">
          <source>Prog mode is a basic major mode for buffers containing programming language source code. Most of the programming language major modes built into Emacs are derived from it.</source>
          <target state="translated">Progモードは、プログラミング言語のソースコードを格納したバッファの基本的なメジャーモードです。Emacs に組み込まれているプログラミング言語のメジャーモードのほとんどは、このモードから派生しています。</target>
        </trans-unit>
        <trans-unit id="4cea4cfeb3712ea10092eb76342518fae1684ff9" translate="yes" xml:space="preserve">
          <source>Programmed Completion</source>
          <target state="translated">プログラム完成</target>
        </trans-unit>
        <trans-unit id="73ceda4e78259dd722c11f42a884506b0642dcb8" translate="yes" xml:space="preserve">
          <source>Programming Types</source>
          <target state="translated">プログラミングの種類</target>
        </trans-unit>
        <trans-unit id="e4ad9d4a698f953901838f2b945f06a3bc720785" translate="yes" xml:space="preserve">
          <source>Programs can bind this variable to &lt;code&gt;t&lt;/code&gt; to say that the next warning should begin a series. When several warnings form a series, that means to leave point on the first warning of the series, rather than keep moving it for each warning so that it appears on the last one. The series ends when the local binding is unbound and &lt;code&gt;warning-series&lt;/code&gt; becomes &lt;code&gt;nil&lt;/code&gt; again.</source>
          <target state="translated">プログラムは、この変数を &lt;code&gt;t&lt;/code&gt; にバインドして、次の警告が一連の警告を開始する必要があることを通知できます。複数の警告がシリーズを形成する場合、それは、最後の警告に表示されるように警告ごとに移動し続けるのではなく、シリーズの最初の警告にポイントを残すことを意味します。ローカルバインディングがアンバインドされ、 &lt;code&gt;warning-series&lt;/code&gt; が再び &lt;code&gt;nil&lt;/code&gt; になると、シリーズは終了します。</target>
        </trans-unit>
        <trans-unit id="92cd77ba5036da4c83c813bc771dc65c0e2a2e16" translate="yes" xml:space="preserve">
          <source>Programs can customize how their warnings appear by binding the variables described in this section.</source>
          <target state="translated">プログラムは、このセクションで説明する変数をバインドすることで、警告の表示方法をカスタマイズすることができます。</target>
        </trans-unit>
        <trans-unit id="28306873004163f1c54815ba67d6f6a02d437add" translate="yes" xml:space="preserve">
          <source>Programs which need to further customize the delayed warnings mechanism can change the variable &lt;code&gt;delayed-warnings-hook&lt;/code&gt;:</source>
          <target state="translated">遅延警告メカニズムをさらにカスタマイズする必要があるプログラムは、変数 &lt;code&gt;delayed-warnings-hook&lt;/code&gt; を変更できます。</target>
        </trans-unit>
        <trans-unit id="2b0e9946d875afe68c7ebbc29fc31bfb38e35193" translate="yes" xml:space="preserve">
          <source>Prompts the user whether to allow switching.</source>
          <target state="translated">切り替えを許可するかどうかをユーザに促します。</target>
        </trans-unit>
        <trans-unit id="452b9037bada9b0c89432df65970439b3d0e924a" translate="yes" xml:space="preserve">
          <source>Properly speaking, strings cannot hold meta characters; but when a string is to be used as a key sequence, there is a special convention that provides a way to represent meta versions of</source>
          <target state="translated">適切に言えば、文字列はメタ文字を保持することはできませんが、文字列をキーシーケンスとして使用する場合、特別な規則があります。</target>
        </trans-unit>
        <trans-unit id="27be843b2a0060fe359278ced4660e8808d9feaf" translate="yes" xml:space="preserve">
          <source>Properties for representing formatting of text.</source>
          <target state="translated">テキストの書式を表すプロパティです。</target>
        </trans-unit>
        <trans-unit id="28fda1d29c479301b92b1d646a01dabebf2e9ec4" translate="yes" xml:space="preserve">
          <source>Properties in the Mode Line</source>
          <target state="translated">モードラインのプロパティ</target>
        </trans-unit>
        <trans-unit id="213490567ef858f9bf66730bcc80eb0c08256c1b" translate="yes" xml:space="preserve">
          <source>Properties with Special Meanings</source>
          <target state="translated">特別な意味を持つ物件</target>
        </trans-unit>
        <trans-unit id="1e89be5f8e0cde7710ce257bc0ca4618ccdceedb" translate="yes" xml:space="preserve">
          <source>Property Lists</source>
          <target state="translated">物件一覧</target>
        </trans-unit>
        <trans-unit id="612e4b2e166639467285e39b4ed1d8fd99f87210" translate="yes" xml:space="preserve">
          <source>Property Lists Outside Symbols</source>
          <target state="translated">物件一覧 外部シンボル</target>
        </trans-unit>
        <trans-unit id="71dffa635be8196fa84e899f671cf85d7edd9bfd" translate="yes" xml:space="preserve">
          <source>Property Lists and Association Lists</source>
          <target state="translated">物件リストと協会リスト</target>
        </trans-unit>
        <trans-unit id="ff82d5b6b42140b1216123af4c6a6d9b5f0855c2" translate="yes" xml:space="preserve">
          <source>Property list</source>
          <target state="translated">物件一覧</target>
        </trans-unit>
        <trans-unit id="46b689e66f80f0841016c7872d607ebdbd67532f" translate="yes" xml:space="preserve">
          <source>Property lists are better than association lists for attaching information to various Lisp function names or variables. If your program keeps all such information in one association list, it will typically need to search that entire list each time it checks for an association for a particular Lisp function name or variable, which could be slow. By contrast, if you keep the same information in the property lists of the function names or variables themselves, each search will scan only the length of one property list, which is usually short. This is why the documentation for a variable is recorded in a property named &lt;code&gt;variable-documentation&lt;/code&gt;. The byte compiler likewise uses properties to record those functions needing special treatment.</source>
          <target state="translated">プロパティリストは、さまざまなLisp関数名または変数に情報を添付するための関連付けリストよりも優れています。プログラムがそのようなすべての情報を1つの関連付けリストに保持している場合、通常、特定のLisp関数名または変数の関連付けをチェックするたびにそのリスト全体を検索する必要があります。これは時間がかかる可能性があります。対照的に、関数名または変数自体のプロパティリストに同じ情報を保持している場合、各検索では1つのプロパティリストの長さのみがスキャンされます。これは通常は短いものです。これが、 &lt;code&gt;variable-documentation&lt;/code&gt; という名前のプロパティに記録される理由です。バイトコンパイラも同様に、プロパティを使用して、特別な処理が必要な関数を記録します。</target>
        </trans-unit>
        <trans-unit id="b7b650cedbe6931fc274d356229231f9ce6992b0" translate="yes" xml:space="preserve">
          <source>Property lists are used in several contexts. For instance, the function &lt;code&gt;put-text-property&lt;/code&gt; takes an argument which is a property list, specifying text properties and associated values which are to be applied to text in a string or buffer. See &lt;a href=&quot;text-properties#Text-Properties&quot;&gt;Text Properties&lt;/a&gt;.</source>
          <target state="translated">プロパティリストは、いくつかのコンテキストで使用されます。たとえば、関数 &lt;code&gt;put-text-property&lt;/code&gt; は、プロパティリストである引数を取り、文字列またはバッファ内のテキストに適用されるテキストプロパティと関連する値を指定します。&lt;a href=&quot;text-properties#Text-Properties&quot;&gt;テキストのプロパティを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="26c9c2b245fd32a1d270268516bccb5c02599371" translate="yes" xml:space="preserve">
          <source>Provide a default value.</source>
          <target state="translated">デフォルト値を指定します。</target>
        </trans-unit>
        <trans-unit id="c25a562aa1564b018459df8c958d13043bf1493a" translate="yes" xml:space="preserve">
          <source>Provide completion.</source>
          <target state="translated">補完を提供する。</target>
        </trans-unit>
        <trans-unit id="69ca381250c3c3006fc14df7ced71bab7380a5f9" translate="yes" xml:space="preserve">
          <source>Providing a menu of definitions made in a buffer.</source>
          <target state="translated">バッファ内で作成された定義のメニューを提供する。</target>
        </trans-unit>
        <trans-unit id="7eb3824960aa38aac0253d4e86d70f62d6bf4d05" translate="yes" xml:space="preserve">
          <source>Providing code to be run when particular libraries are loaded.</source>
          <target state="translated">特定のライブラリがロードされたときに実行されるコードの提供</target>
        </trans-unit>
        <trans-unit id="645ce7ff3a9e362d4f39d88c21ee1a9e243a4dba" translate="yes" xml:space="preserve">
          <source>Providing point or the mark as an argument value is also common, but if you do this &lt;em&gt;and&lt;/em&gt; read input (whether using the minibuffer or not), be sure to get the integer values of point or the mark after reading. The current buffer may be receiving subprocess output; if subprocess output arrives while the command is waiting for input, it could relocate point and the mark.</source>
          <target state="translated">引数値としてポイントまたはマークを指定することも一般的ですが、これ&lt;em&gt;を&lt;/em&gt;実行して入力&lt;em&gt;を&lt;/em&gt;読み取る場合（ミニバッファーを使用するかどうかに関係なく）、読み取り後にポイントまたはマークの整数値を取得してください。現在のバッファはサブプロセス出力を受信して​​いる可能性があります。コマンドが入力を待機している間にサブプロセス出力が到着すると、ポイントとマークが再配置される可能性があります。</target>
        </trans-unit>
        <trans-unit id="b8f35d8fc2ec94eb3ae367995ce77a849bd095af" translate="yes" xml:space="preserve">
          <source>Pseudo-random numbers are generated from a &lt;em&gt;seed value&lt;/em&gt;. Starting from any given seed, the &lt;code&gt;random&lt;/code&gt; function always generates the same sequence of numbers. By default, Emacs initializes the random seed at startup, in such a way that the sequence of values of &lt;code&gt;random&lt;/code&gt; (with overwhelming likelihood) differs in each Emacs run.</source>
          <target state="translated">疑似乱数は&lt;em&gt;シード値&lt;/em&gt;から生成され&lt;em&gt;ます&lt;/em&gt;。任意のシードから開始して、 &lt;code&gt;random&lt;/code&gt; 関数は常に同じ数のシーケンスを生成します。デフォルトでは、Emacsはの値のシーケンスように起動時にランダムシード、初期化 &lt;code&gt;random&lt;/code&gt; 各Emacsの実行中（圧倒的な可能性を有する）が異なっています。</target>
        </trans-unit>
        <trans-unit id="2eb80e35d971a935837f24f84a6852b12c75cb7f" translate="yes" xml:space="preserve">
          <source>Punctuation characters: &amp;lsquo;</source>
          <target state="translated">句読文字： '</target>
        </trans-unit>
        <trans-unit id="4b4cb70ba2cfe639a8da865361774dfa2c376cc9" translate="yes" xml:space="preserve">
          <source>Pure Storage</source>
          <target state="translated">ピュアストレージ</target>
        </trans-unit>
        <trans-unit id="90aba799522d2d020ebb6ae6c41c3b9be6c0e7f6" translate="yes" xml:space="preserve">
          <source>Pure storage is allocated only while &lt;code&gt;temacs&lt;/code&gt; is loading the standard preloaded Lisp libraries. In the file</source>
          <target state="translated">ピュアストレージは、 &lt;code&gt;temacs&lt;/code&gt; が標準のプリロードされたLispライブラリをロードしている間だけ割り当てられます。ファイル内</target>
        </trans-unit>
        <trans-unit id="307d0e8cf258958b59c555f09777515eed5854cd" translate="yes" xml:space="preserve">
          <source>Pushing and releasing a mouse button.</source>
          <target state="translated">マウスのボタンを押したり離したりします。</target>
        </trans-unit>
        <trans-unit id="b5742a72c0db888525b18c87e0c62d02e0e4ea94" translate="yes" xml:space="preserve">
          <source>Put a string with a text property directly into the mode line data structure.</source>
          <target state="translated">モードラインのデータ構造体に直接、テキストプロパティを持つ文字列を入れます。</target>
        </trans-unit>
        <trans-unit id="0cd76f5f4d006c099b898a42926b589b7c1b8288" translate="yes" xml:space="preserve">
          <source>Put a text property on a mode line %-construct such as &amp;lsquo;</source>
          <target state="translated">モード行にテキストプロパティを配置します％-'などの構成</target>
        </trans-unit>
        <trans-unit id="4dc0318a27df4bbd3819a2ae0650102cbfcad405" translate="yes" xml:space="preserve">
          <source>Put this customization item in group &lt;var&gt;group&lt;/var&gt;. If this keyword is missing from a customization item, it&amp;rsquo;ll be placed in the same group that was last defined (in the current file).</source>
          <target state="translated">このカスタマイズ項目をグループ &lt;var&gt;group&lt;/var&gt; 入れます。このキーワードがカスタマイズ項目にない場合は、（現在のファイルで）最後に定義されたのと同じグループに配置されます。</target>
        </trans-unit>
        <trans-unit id="5d0aee0599747fe1cef238e007941d3d3ff80b55" translate="yes" xml:space="preserve">
          <source>Putting Keyboard Events in Strings</source>
          <target state="translated">キーボードイベントを文字列に入れる</target>
        </trans-unit>
        <trans-unit id="573506225dbcbd9461c05f97b5cbb6e9b7ea4b2e" translate="yes" xml:space="preserve">
          <source>Putting information into a mode line.</source>
          <target state="translated">モードラインに情報を入れる</target>
        </trans-unit>
        <trans-unit id="2e23fbce1e64b75a823c48bd07eb8cffd6a4db53" translate="yes" xml:space="preserve">
          <source>Putting so much code in the &lt;code&gt;defvar&lt;/code&gt; form has one disadvantage: it puts the documentation string far away from the line which names the variable. Here&amp;rsquo;s a safe way to avoid that:</source>
          <target state="translated">&lt;code&gt;defvar&lt;/code&gt; 形式に非常に多くのコードを配置すると、1つの欠点があります。それは、変数に名前を付ける行からドキュメント文字列を遠くに配置することです。これを回避する安全な方法は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="c3156e00d3c2588c639e0d3cf6821258b05761c7" translate="yes" xml:space="preserve">
          <source>Q</source>
          <target state="translated">Q</target>
        </trans-unit>
        <trans-unit id="464d9993abd4ae2c2c7c9e7b26a5f83fd64b3caa" translate="yes" xml:space="preserve">
          <source>Query (once) about all the variables.</source>
          <target state="translated">すべての変数について(一度だけ)クエリを実行します。</target>
        </trans-unit>
        <trans-unit id="cd271b4ec3efd977479f9516f661f6689767b2d4" translate="yes" xml:space="preserve">
          <source>Querying Before Exit</source>
          <target state="translated">終了前の問い合わせ</target>
        </trans-unit>
        <trans-unit id="002ff598115d84595ffeee6219cb5c03d3a1d4a6" translate="yes" xml:space="preserve">
          <source>Question</source>
          <target state="translated">Question</target>
        </trans-unit>
        <trans-unit id="1a2285d8881f226e13430515a9dd2b9fb6294200" translate="yes" xml:space="preserve">
          <source>Quit</source>
          <target state="translated">Quit</target>
        </trans-unit>
        <trans-unit id="d67020addf987d4f125096bc76d55fb8b1a84640" translate="yes" xml:space="preserve">
          <source>Quitting</source>
          <target state="translated">Quitting</target>
        </trans-unit>
        <trans-unit id="4db027af27fca0bea2af0a68a56488a1c5b9de06" translate="yes" xml:space="preserve">
          <source>Quitting Windows</source>
          <target state="translated">Windowsを終了する</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
