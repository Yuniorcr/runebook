<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="erlang">
    <body>
      <group id="erlang">
        <trans-unit id="6cbf1adc0d75868cfd46589662e75f0f79ed5cbb" translate="yes" xml:space="preserve">
          <source>The Bindings area, displaying all variables bindings. If you click a variable name, the value is displayed in the Evaluator area. Double-click a variable name to open a window where the variable value can be edited. Notice however that pid, port, reference, or fun values cannot be edited unless they can be represented in the running system.</source>
          <target state="translated">バインディング領域で、すべての変数のバインディングを表示します。変数名をクリックすると、評価者領域に値が表示されます。変数名をダブルクリックすると、変数値を編集できるウィンドウが開きます。ただし、pid,port,reference,fun の値は、実行中のシステムで表現できない限り編集できないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="4b6c3c38656309049129434a8a3888567bd5d33d" translate="yes" xml:space="preserve">
          <source>The Button area, with buttons for quick access to frequently used functions in the &lt;strong&gt;Process&lt;/strong&gt; menu.</source>
          <target state="translated">[ボタン]領域には、[ &lt;strong&gt;処理&lt;/strong&gt; ]メニューで頻繁に使用される機能にすばやくアクセスするためのボタンがあります。</target>
        </trans-unit>
        <trans-unit id="ada22f32dd020105bdc39ab625188b5d539d360a" translate="yes" xml:space="preserve">
          <source>The C driver is a module that is compiled and linked into a shared library. It uses a driver structure and includes the header file &lt;code&gt;erl_driver.h&lt;/code&gt;.</source>
          <target state="translated">Cドライバは、コンパイルされて共有ライブラリにリンクされるモジュールです。ドライバー構造を使用し、ヘッダーファイル &lt;code&gt;erl_driver.h&lt;/code&gt; をインクルードします。</target>
        </trans-unit>
        <trans-unit id="2a7c12f419c3e677f26c1d74131f78103f5ccbf9" translate="yes" xml:space="preserve">
          <source>The C node can act as a server or a client when setting up the Erlang-C communication. If it acts as a client, it connects to an Erlang node by calling &lt;code&gt;erl_connect()&lt;/code&gt;, which returns an open file descriptor at success:</source>
          <target state="translated">Cノードは、Erlang-C通信をセットアップするときにサーバーまたはクライアントとして機能できます。クライアントとして機能する場合は、 &lt;code&gt;erl_connect()&lt;/code&gt; を呼び出してErlangノードに接続し、成功するとオープンファイル記述子を返します。</target>
        </trans-unit>
        <trans-unit id="f778bcd020988cc52d7d8911bac363507b5bc1fe" translate="yes" xml:space="preserve">
          <source>The C node can receive a message from Erlang by calling &lt;code&gt;erl_receive msg()&lt;/code&gt;. This function reads data from the open file descriptor &lt;code&gt;fd&lt;/code&gt; into a buffer and puts the result in an &lt;code&gt;ErlMessage&lt;/code&gt; struct &lt;code&gt;emsg&lt;/code&gt;. &lt;code&gt;ErlMessage&lt;/code&gt; has a field &lt;code&gt;type&lt;/code&gt; defining what kind of data is received. In this case, the type of interest is &lt;code&gt;ERL_REG_SEND&lt;/code&gt; which indicates that Erlang sent a message to a registered process at the C node. The actual message, an &lt;code&gt;ETERM&lt;/code&gt;, is in the &lt;code&gt;msg&lt;/code&gt; field.</source>
          <target state="translated">Cノードは &lt;code&gt;erl_receive msg()&lt;/code&gt; を呼び出すことにより、Erlangからメッセージを受信できます。この関数は、開いているファイル記述子 &lt;code&gt;fd&lt;/code&gt; からデータをバッファーに読み取り、その結果を &lt;code&gt;ErlMessage&lt;/code&gt; struct &lt;code&gt;emsg&lt;/code&gt; に入れます。 &lt;code&gt;ErlMessage&lt;/code&gt; には、受信するデータの種類を定義するフィールド &lt;code&gt;type&lt;/code&gt; があります。この場合、関心のあるタイプは &lt;code&gt;ERL_REG_SEND&lt;/code&gt; で、ErlangがCノードの登録済みプロセスにメッセージを送信したことを示します。実際のメッセージ &lt;code&gt;ETERM&lt;/code&gt; は &lt;code&gt;msg&lt;/code&gt; フィールドにあります。</target>
        </trans-unit>
        <trans-unit id="44cfee0b8169b38821cf004612b6024fa4504a22" translate="yes" xml:space="preserve">
          <source>The CA certificates specified for the connection will be used to construct the certificate chain validating the CRLs.</source>
          <target state="translated">接続に指定された CA 証明書は、CRL を検証する証明書チェーンを構築するために使用されます。</target>
        </trans-unit>
        <trans-unit id="9b711437028a29fd162a39304f7e85e3b67e2c19" translate="yes" xml:space="preserve">
          <source>The CGI script response comprises a message header and a message body, separated by a blank line. The message header contains one or more header fields. The body can be empty.</source>
          <target state="translated">CGI スクリプトの応答は、空白行で区切られたメッセージヘッダーとメッセージボディで構成されています。メッセージヘッダーは1つ以上のヘッダーフィールドを含みます。ボディは空にすることができます。</target>
        </trans-unit>
        <trans-unit id="4c3c9d660d39101e158d800c72dc5b3c5f71e86f" translate="yes" xml:space="preserve">
          <source>The CNT column shows the total number of function calls that was found in the trace. In the ACC column is the total time of the trace from first timestamp to last. And in the OWN column is the sum of the execution time in functions found in the trace, not including called functions. In this case it is very close to the ACC time since the emulator had practically nothing else to do than to execute our test program.</source>
          <target state="translated">CNT 列には、トレースで見つかった関数呼び出しの総数が表示されます。ACC列には、最初のタイムスタンプから最後のタイムスタンプまでのトレースの合計時間が表示されます。そしてOWN列には、トレースで見つかった関数の実行時間の合計で、呼び出された関数は含まれていません。この場合、エミュレータはテストプログラムを実行する以外に何もすることがなかったので、ACCの時間に非常に近い値になります。</target>
        </trans-unit>
        <trans-unit id="0bca2724268527bcfe47363d53f453d381e52758" translate="yes" xml:space="preserve">
          <source>The CPU topology is used when binding schedulers to logical processors. If schedulers are already bound when the CPU topology is changed, the schedulers are sent a request to rebind according to the new CPU topology.</source>
          <target state="translated">CPUトポロジは、スケジューラを論理プロセッサにバインドする際に使用される。CPUトポロジが変更されたときに、すでにスケジューラがバインドされている場合は、新しいCPUトポロジに合わせてスケジューラをリバインドするためのリクエストを送信します。</target>
        </trans-unit>
        <trans-unit id="3e338f2c345acced3a85f3002b3cdda7b33768c1" translate="yes" xml:space="preserve">
          <source>The CPU utilization is defined as the sum of the percentage shares of the CPU cycles spent in all busy processor states (see &lt;code&gt;util/1&lt;/code&gt; below) in average on all CPUs.</source>
          <target state="translated">CPU使用率は、すべてのCPUで平均してすべてのビジープロセッサ状態（以下の &lt;code&gt;util/1&lt;/code&gt; を参照）で費やされたCPUサイクルの割合の合計として定義されます。</target>
        </trans-unit>
        <trans-unit id="aa86529ffc420dbda732a44a0aa8bd483c1ae653" translate="yes" xml:space="preserve">
          <source>The CRL entry extensions OID name atoms and their corresponding value types are as follows:</source>
          <target state="translated">CRL エントリ拡張 OID 名アトムとそれに対応する値タイプは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="270f1611da531780d2eaa5897949ee887332e027" translate="yes" xml:space="preserve">
          <source>The CRL extensions OID name atoms and their corresponding value types are as follows:</source>
          <target state="translated">CRL拡張OID名アトムとそれに対応する値タイプは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="d9b7329cef621756a648262a641008c28933737d" translate="yes" xml:space="preserve">
          <source>The CRLs will be fetched from a local or external cache. See &lt;code&gt;ssl_crl_cache_api(3)&lt;/code&gt;.</source>
          <target state="translated">CRLは、ローカルまたは外部キャッシュからフェッチされます。 &lt;code&gt;ssl_crl_cache_api(3)&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="f3d829d39e1e62045ec8647a09fccc7a51c77978" translate="yes" xml:space="preserve">
          <source>The CT hook functions can call any logging function in the &lt;code&gt;ct&lt;/code&gt; interface to print information to the log files, or to add comments in the suite overview page.</source>
          <target state="translated">CTフック関数は、 &lt;code&gt;ct&lt;/code&gt; インターフェースのロギング関数を呼び出して、ログファイルに情報を出力したり、スイートの概要ページにコメントを追加したりできます。</target>
        </trans-unit>
        <trans-unit id="3ec67be87ba83be4a6a36f46cae0a249d6c031c6" translate="yes" xml:space="preserve">
          <source>The Call Graph is  represented by Erlang terms (the sets are lists), which is suitable for many analyses. But for analyses that look at chains of calls, a list representation is much too slow. Instead the representation offered by the &lt;code id=&quot;representation&quot;&gt;digraph&lt;/code&gt; module is used. The translation of the list representation of the Call Graph - or a subgraph thereof - to the &lt;code&gt;digraph&lt;/code&gt; representation does not come for free, so the language used for expressing queries to be described below has a special operator for this task and a possibility to save the &lt;code&gt;digraph&lt;/code&gt; representation for subsequent analyses.</source>
          <target state="translated">コールグラフは、Erlang用語（セットはリスト）で表され、多くの分析に適しています。しかし、一連の呼び出しを分析する場合、リストの表現は遅すぎます。代わりに、 &lt;code id=&quot;representation&quot;&gt;digraph&lt;/code&gt; モジュールによって提供される表現が使用されます。コールグラフのリスト表現またはそのサブグラフの &lt;code&gt;digraph&lt;/code&gt; 表現への変換は無料ではないため、以下で説明するクエリの表現に使用される言語には、このタスクのための特別な演算子があり、後続の分析のための &lt;code&gt;digraph&lt;/code&gt; 表現。</target>
        </trans-unit>
        <trans-unit id="bce56cac593ab0a42cef53b33869a05dc52b528e" translate="yes" xml:space="preserve">
          <source>The Code area, displaying the code being executed. The code is indented and each line is prefixed with its line number. If the process execution is stopped, the current line is marked with &lt;code&gt;--&amp;gt;&lt;/code&gt;. An existing break point at a line is marked with a stop symbol. In the example shown in the illustration, the execution stopped at line 6, before the execution of &lt;code&gt;fac/1&lt;/code&gt;.</source>
          <target state="translated">実行されているコードを表示するコード領域。コードはインデントされており、各行の先頭には行番号が付いています。プロセスの実行が停止すると、現在の行は &lt;code&gt;--&amp;gt;&lt;/code&gt; マークされます。行の既存のブレークポイントには、停止記号が付いています。図の例では、実行は6行目で停止してから &lt;code&gt;fac/1&lt;/code&gt; が実行されています。</target>
        </trans-unit>
        <trans-unit id="3c4163ad4ae86ebef487e34acf3cb3b300872a11" translate="yes" xml:space="preserve">
          <source>The Common Message and Relay applications are the only applications that diameter itself has any specific knowledge of. The Common Message application is used for messages that diameter itself handles: CER/CEA, DWR/DWA and DPR/DPA. The Relay application is given special treatment with regard to encode/decode since the messages and AVPs it handles are not specifically defined.</source>
          <target state="translated">Common MessageとRelayアプリケーションは、dameter自身が特別な知識を持っている唯一のアプリケーションです。Common Messageアプリケーションは、dameter自身が扱うメッセージに使用されます。CER/CEA、DWR/DWA、DPR/DPAです。Relayアプリケーションは、それが扱うメッセージとAVPが特に定義されていないため、エンコード/デコードに関して特別な扱いを受けます。</target>
        </trans-unit>
        <trans-unit id="314dbe1e2d1cb12d891485b91d81bb94162ddaf9" translate="yes" xml:space="preserve">
          <source>The Compliance column notes &lt;strong&gt;C&lt;/strong&gt; (Compliant) if the required functionality is implemented, &lt;strong&gt;PC&lt;/strong&gt; (Partially Compliant) if there are limitations, &lt;strong&gt;NC&lt;/strong&gt; (Not Compliant) if functionality is not implemented, or a dash if text is informational or only places requirements that must be met by the user's implementation.</source>
          <target state="translated">コンプライアンスの列には、必要な機能が実装されている場合は&lt;strong&gt;C&lt;/strong&gt;（準拠）、制限がある場合は&lt;strong&gt;PC&lt;/strong&gt;（部分的に準拠）、機能が実装されていない場合は&lt;strong&gt;NC&lt;/strong&gt;（非準拠）、またはテキストが情報であるか必要な要件のみが記載されている場合はダッシュが表示されます。ユーザーの実装によって満たされました。</target>
        </trans-unit>
        <trans-unit id="cb5797134c742f2284426627bbcaee9db9ff4f9b" translate="yes" xml:space="preserve">
          <source>The ControlPid may be the identity of a process residing on another Erlang node. This is useful when you want to distribute a user over several Erlang nodes. In such a case one of the nodes has the physical connection. When a user residing on one of the other nodes needs to send a request (with megaco:call/3 or megaco:cast/3), the message will encoded on the originating Erlang node, and then be forwarded to the node with the physical connection. When the reply arrives, it will be forwarded back to the originator. The distributed connection may explicitly be deactivated by a local call to megaco:disconnect/2 or implicitly when the physical connection is deactivated (with megaco:disconnect/2, killing the controlling process, halting the other node, ...).</source>
          <target state="translated">ControlPidは別のErlangノードにいるプロセスのIDです。これは複数のErlangノードにユーザーを分散させたいときに便利です。このような場合、ノードの1つが物理的な接続を持っています。他のノードにいるユーザがリクエストを送る必要があるとき(megaco:call/3やmegaco:cast/3を使って)、メッセージは元のErlangノードでエンコードされ、物理的に接続しているノードに転送されます。リプライが到着すると、元のノードに転送されます。分散接続は明示的にmegaco:disconnect/2へのローカルコールで解除されるか、物理接続が解除されたときに暗黙的に解除されます(megaco:disconnect/2で制御プロセスを停止させたり、他のノードを停止させたり、...)。</target>
        </trans-unit>
        <trans-unit id="78df27997f59e3cf7a226f97555796fd4db3b167" translate="yes" xml:space="preserve">
          <source>The Crashdump Viewer is a WxWidgets based tool for browsing Erlang crashdumps.</source>
          <target state="translated">Crashdump ViewerはWxWidgetsベースのErlangのクラッシュダンプを閲覧するためのツールです。</target>
        </trans-unit>
        <trans-unit id="e25b4f2128c61d45f1244bb1e42a65e6c254444f" translate="yes" xml:space="preserve">
          <source>The Cs (Surrogate) property applies only to characters in the range U+D800 to U+DFFF. Such characters are invalid in Unicode strings and so cannot be tested by PCRE. Perl does not support the Cs property.</source>
          <target state="translated">Cs(サロゲート)プロパティは、U+D800からU+DFFFの範囲の文字にのみ適用されます。このような文字はUnicode文字列では無効なので、PCREではテストできません。Perl は Cs プロパティをサポートしていません。</target>
        </trans-unit>
        <trans-unit id="8d8b1e5940b411ae8301615a457804bfb0094984" translate="yes" xml:space="preserve">
          <source>The DER encoder omits the encoding for the same &lt;code&gt;BIT STRING&lt;/code&gt;:</source>
          <target state="translated">DERエンコーダーは、同じ &lt;code&gt;BIT STRING&lt;/code&gt; のエンコードを省略します。</target>
        </trans-unit>
        <trans-unit id="9e781b3302f49ad7b6f93f77b8bb63523e6ee75c" translate="yes" xml:space="preserve">
          <source>The DER-encoded Diffie-Hellman parameters. If specified, it overrides option &lt;code&gt;dhfile&lt;/code&gt;.</source>
          <target state="translated">DERエンコードされたDiffie-Hellmanパラメータ。指定すると、オプション &lt;code&gt;dhfile&lt;/code&gt; が上書きされます。</target>
        </trans-unit>
        <trans-unit id="b9e05b3ca4b742f1e879494bc5c683f33ec025ce" translate="yes" xml:space="preserve">
          <source>The DER-encoded trusted certificates. If this option is supplied it overrides option &lt;code&gt;cacertfile&lt;/code&gt;.</source>
          <target state="translated">DERエンコードされた信頼できる証明書。このオプションを指定すると、オプション &lt;code&gt;cacertfile&lt;/code&gt; が上書きされます。</target>
        </trans-unit>
        <trans-unit id="503452c36c49cb1fd0ea949662ea239d8f9105d2" translate="yes" xml:space="preserve">
          <source>The DER-encoded user's private key or a map refering to a crypto engine and its key reference that optionally can be password protected, seealso &lt;code&gt;crypto:engine_load/4&lt;/code&gt; and &lt;code&gt;Crypto's Users Guide&lt;/code&gt;. If this option is supplied, it overrides option &lt;code&gt;keyfile&lt;/code&gt;.</source>
          <target state="translated">DERでエンコードされたユーザーの秘密キーまたは暗号エンジンを参照するマップと、オプションでパスワードで保護できるキー参照。crypto &lt;code&gt;crypto:engine_load/4&lt;/code&gt; と &lt;code&gt;Crypto's Users Guide&lt;/code&gt; ご覧ください。このオプションを指定すると、オプション &lt;code&gt;keyfile&lt;/code&gt; が上書きされます。</target>
        </trans-unit>
        <trans-unit id="1412b8d79c31037e94ec8ee160cfa882f7bfb3fb" translate="yes" xml:space="preserve">
          <source>The DER-encoded users certificate. If this option is supplied, it overrides option &lt;code&gt;certfile&lt;/code&gt;.</source>
          <target state="translated">DERでエンコードされたユーザー証明書。このオプションを指定すると、オプション &lt;code&gt;certfile&lt;/code&gt; が上書きされます。</target>
        </trans-unit>
        <trans-unit id="25f2f74a7edc47541dafb29c006cde23cd47d9fe" translate="yes" xml:space="preserve">
          <source>The Diameter header of the message. Can be (and typically should be) &lt;code&gt;undefined&lt;/code&gt; for an outgoing message in a non-relay application, in which case diameter provides appropriate values.</source>
          <target state="translated">メッセージのDiameterヘッダー。非リレーアプリケーションの送信メッセージに対して &lt;code&gt;undefined&lt;/code&gt; にすることができます（通常は未定義にする必要があります）。この場合、diameterは適切な値を提供します。</target>
        </trans-unit>
        <trans-unit id="5efc1791e653c1599eb1a85a25bc63fbc5f68900" translate="yes" xml:space="preserve">
          <source>The EPMD closes the socket when it has sent the information.</source>
          <target state="translated">EPMDは、情報を送信した時点でソケットを閉じます。</target>
        </trans-unit>
        <trans-unit id="657accf9a74a7eb0b025905c51aa524bbb4f52c3" translate="yes" xml:space="preserve">
          <source>The ETS type of the dumped table (that is, &lt;code&gt;set&lt;/code&gt;, &lt;code&gt;bag&lt;/code&gt;, &lt;code&gt;duplicate_bag&lt;/code&gt;, or &lt;code&gt;ordered_set&lt;/code&gt;). This type is used when loading the table again.</source>
          <target state="translated">ダンプされたテーブルのETSタイプ（つまり、 &lt;code&gt;set&lt;/code&gt; 、 &lt;code&gt;bag&lt;/code&gt; 、 &lt;code&gt;duplicate_bag&lt;/code&gt; 、または &lt;code&gt;ordered_set&lt;/code&gt; ）。このタイプは、テーブルを再度ロードするときに使用されます。</target>
        </trans-unit>
        <trans-unit id="37bd9159078f20014405583883e1e7838b1f320f" translate="yes" xml:space="preserve">
          <source>The EUnit framework makes it extremely easy to write unit tests in Erlang. There are a few different ways of writing them, though, so we start with the simplest:</source>
          <target state="translated">EUnitフレームワークはErlangでユニットテストを書くのを非常に簡単にしてくれます。しかし、いくつかの異なる書き方があります。</target>
        </trans-unit>
        <trans-unit id="25e6615a6259b426a5c1aa433aefd48dfe9f0730" translate="yes" xml:space="preserve">
          <source>The Election Process</source>
          <target state="translated">選挙の流れ</target>
        </trans-unit>
        <trans-unit id="d7e47fd1c3278cd7de4abd1246ff9d0b6caf0c35" translate="yes" xml:space="preserve">
          <source>The Encoding can be changed for a file &quot;on the fly&quot; by using function &lt;code&gt;io:setopts/2&lt;/code&gt;. So a file can be analyzed in latin1 encoding for, for example, a BOM, positioned beyond the BOM and then be set for the right encoding before further reading. For functions identifying BOMs, see module &lt;code&gt;unicode(3)&lt;/code&gt;.</source>
          <target state="translated">関数 &lt;code&gt;io:setopts/2&lt;/code&gt; を使用して、「オンザフライ」でファイルのエンコーディングを変更できます。したがって、ファイルは、たとえばBOMのlatin1エンコーディングで分析し、BOMを超えて配置し、さらに読み取る前に正しいエンコーディングに設定できます。BOMを識別する関数については、モジュール &lt;code&gt;unicode(3)&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="a3ce07ca3d080f90844cafbb92cdb028293480a0" translate="yes" xml:space="preserve">
          <source>The Erlang &lt;strong&gt;error logger&lt;/strong&gt; is an event manager (see &lt;code&gt;OTP Design Principles&lt;/code&gt; and &lt;code&gt;gen_event(3)&lt;/code&gt;), registered as &lt;code&gt;error_logger&lt;/code&gt;.</source>
          <target state="translated">Erlang &lt;strong&gt;エラーロガー&lt;/strong&gt;は、 &lt;code&gt;error_logger&lt;/code&gt; として登録されたイベントマネージャー（ &lt;code&gt;OTP Design Principles&lt;/code&gt; と &lt;code&gt;gen_event(3)&lt;/code&gt; を参照）です。</target>
        </trans-unit>
        <trans-unit id="a6cec8bd2bf7434e290f227203641824a28b2253" translate="yes" xml:space="preserve">
          <source>The Erlang API allows using arbitrary curve parameters, but in FIPS mode only those allowed by the Security Policy shall be used.</source>
          <target state="translated">Erlang APIは任意の曲線パラメータを使うことができますが、FIPSモードではセキュリティポリシーで許可されたものだけが使われます。</target>
        </trans-unit>
        <trans-unit id="1e13d1897ff2db6a5ca229af1382794e443a1fe1" translate="yes" xml:space="preserve">
          <source>The Erlang API of the crypto application is identical regardless of building with or without FIPS support. However the nif code internally uses a different OpenSSL API.</source>
          <target state="translated">暗号アプリケーションのErlang APIはFIPSサポートの有無に関わらず同じです。しかし、nifのコードは内部的に異なるOpenSSL APIを使用しています。</target>
        </trans-unit>
        <trans-unit id="48490447d94b14d0abe2e04b21fbd8bf2b9b8cdb" translate="yes" xml:space="preserve">
          <source>The Erlang BIF &lt;code&gt;spawn&lt;/code&gt; is used to create a new process: &lt;code&gt;spawn(Module, Exported_Function, List of Arguments)&lt;/code&gt;. Consider the following module:</source>
          <target state="translated">Erlang BIF &lt;code&gt;spawn&lt;/code&gt; を使用して、新しいプロセスを作成します： &lt;code&gt;spawn(Module, Exported_Function, List of Arguments)&lt;/code&gt; 。次のモジュールについて考えてみます。</target>
        </trans-unit>
        <trans-unit id="bc260aee970be8377de4dc3244ea906f03e3f766" translate="yes" xml:space="preserve">
          <source>The Erlang BIFs.</source>
          <target state="translated">ErlangのBIF。</target>
        </trans-unit>
        <trans-unit id="99fe49d5ed45f059cc301355028f8dfef080429d" translate="yes" xml:space="preserve">
          <source>The Erlang Distribution protocol is not by itself secure and does not aim to be so. In order to get secure distribution the distributed nodes should be configured to use distribution over tls. See the &lt;code&gt;Using SSL for Erlang Distribution&lt;/code&gt; User's Guide for details on how to setup a secure distributed node.</source>
          <target state="translated">Erlang配布プロトコルは、それ自体は安全ではなく、そうであることを目指していません。安全な配布を行うには、tls経由の配布を使用するように分散ノードを構成する必要があります。参照してください &lt;code&gt;Using SSL for Erlang Distribution&lt;/code&gt; の設定方法への安全な分散ノードの詳細については、ユーザーズガイドを。</target>
        </trans-unit>
        <trans-unit id="a40f7e40db92a7107a9e3a5cac4b4ab65b30339c" translate="yes" xml:space="preserve">
          <source>The Erlang Emulator</source>
          <target state="translated">Erlangエミュレータ</target>
        </trans-unit>
        <trans-unit id="99377f0e14b45ce54e27b19f84ce7e618a01753c" translate="yes" xml:space="preserve">
          <source>The Erlang I/O-system has been designed (or at least used) in a way where you expect any I/O server to handle any string data. That is, however, no longer the case when working with Unicode characters. The Erlang programmer must now know the capabilities of the device where the data ends up. Also, ports in Erlang are byte-oriented, so an arbitrary string of (Unicode) characters cannot be sent to a port without first converting it to an encoding of choice.</source>
          <target state="translated">ErlangのI/OシステムはどんなI/Oサーバでも文字列データを扱えるように設計されています(少なくとも使われています)。しかし、Unicode文字を扱う場合はそうではありません。Erlangプログラマはデータの行き着く先のデバイスの能力を知っていなければなりません。また、Erlangのポートはバイト指向なので、任意の文字列(Unicode)をポートに送るには、最初に任意のエンコーディングに変換しなければなりません。</target>
        </trans-unit>
        <trans-unit id="81cc438ebd93249f6378dd48a6614f5a8c1d4ea2" translate="yes" xml:space="preserve">
          <source>The Erlang ODBC application consists of both &lt;code&gt;Erlang&lt;/code&gt; and &lt;code&gt;C&lt;/code&gt; code. The &lt;code&gt;C&lt;/code&gt; code is delivered as a precompiled executable for windows, solaris and linux (SLES10) in the commercial build. In the open source distribution it is built the same way as all other application using configure and make. You may want to provide the the path to your ODBC libraries using --with-odbc=PATH.</source>
          <target state="translated">Erlang ODBCアプリケーションは、 &lt;code&gt;Erlang&lt;/code&gt; と &lt;code&gt;C&lt;/code&gt; コードの両方で構成されています。 &lt;code&gt;C&lt;/code&gt; のコードは、市販のビルドの窓、SolarisおよびLinux（SLES10）のためのコンパイル済み実行ファイルとして配信されます。オープンソースディストリビューションでは、configureおよびmakeを使用する他のすべてのアプリケーションと同じ方法でビルドされます。--with-odbc = PATHを使用して、ODBCライブラリへのパスを提供することができます。</target>
        </trans-unit>
        <trans-unit id="8a4351bfa2f995c6bd330803859435f644586add" translate="yes" xml:space="preserve">
          <source>The Erlang ODBC application should run on all Unix dialects including Linux, Windows 2000, Windows XP and NT. But currently it is only tested for Solaris, Windows 2000, Windows XP and NT.</source>
          <target state="translated">Erlang ODBCアプリケーションはLinux、Windows 2000、Windows XP、NTを含むすべてのUnixの方言で動作するはずです。しかし、現在はSolaris、Windows 2000、Windows XP、NTでしかテストされていません。</target>
        </trans-unit>
        <trans-unit id="c54f824f83f969a528f4d85db8ff3bf2b47f63fe" translate="yes" xml:space="preserve">
          <source>The Erlang ODBC application should work for any relational database that has an ODBC driver. But currently it is only regularly tested for &lt;code&gt;sqlserver&lt;/code&gt; and &lt;code&gt;postgres&lt;/code&gt;.</source>
          <target state="translated">Erlang ODBCアプリケーションは、ODBCドライバーを持つすべてのリレーショナルデータベースで機能するはずです。しかし、現在は &lt;code&gt;sqlserver&lt;/code&gt; と &lt;code&gt;postgres&lt;/code&gt; に対してのみ定期的にテストされています。</target>
        </trans-unit>
        <trans-unit id="7d474f74418b8768698a57fb6613d328b379dec3" translate="yes" xml:space="preserve">
          <source>The Erlang ODBC interface is in principal database independent, e.i. an erlang program using the interface could be run without changes towards different databases. But as SQL is used it is alas possible to write database dependent programs. Even though SQL is an ANSI-standard meant to be database independent, different databases have proprietary extensions to SQL defining their own data types. If you keep to the ANSI data types you will minimize the problem. But unfortunately there is no guarantee that all databases actually treats the ANSI data types equivalently. For instance an installation of &lt;code&gt;Oracle Enterprise release 8.0.5.0.0 for unix&lt;/code&gt; will accept that you create a table column with the ANSI data type &lt;code&gt;integer&lt;/code&gt;, but when retrieving values from this column the driver reports that it is of type &lt;code&gt;SQL_DECIMAL(0, 38)&lt;/code&gt; and not &lt;code&gt;SQL_INTEGER&lt;/code&gt; as you may have expected.</source>
          <target state="translated">Erlang ODBCインターフェースは主にデータベースに依存していません。つまり、インターフェースを使用するerlangプログラムは、異なるデータベースに変更を加えることなく実行できます。しかし、SQLが使用されているため、データベースに依存するプログラムを作成することはできません。 SQLはデータベースに依存しないことを意図したANSI標準ですが、データベースごとに独自のデータ型を定義するSQLの独自の拡張機能があります。 ANSIデータ型を維持すると、問題を最小限に抑えることができます。しかし、残念ながら、すべてのデータベースが実際にANSIデータ型を同等に扱うという保証はありません。たとえば &lt;code&gt;Oracle Enterprise release 8.0.5.0.0 for unix&lt;/code&gt; インストールでは、ANSIデータ型 &lt;code&gt;integer&lt;/code&gt; テーブル列を作成することが受け入れられます。ただし、この列から値を取得するとき、ドライバーはそれが &lt;code&gt;SQL_DECIMAL(0, 38)&lt;/code&gt; タイプであり、 &lt;code&gt;SQL_INTEGER&lt;/code&gt; ではないことを予想どおり報告します。</target>
        </trans-unit>
        <trans-unit id="56a64c0ae629896e0d315a11fe6e47437de08daf" translate="yes" xml:space="preserve">
          <source>The Erlang Port Mapper Daemon &lt;strong&gt;epmd&lt;/strong&gt; is automatically started at every host where an Erlang node is started. It is responsible for mapping the symbolic node names to machine addresses. See the &lt;code&gt;epmd(1)&lt;/code&gt; manual page in ERTS.</source>
          <target state="translated">Erlangポートマッパーデーモン&lt;strong&gt;epmd&lt;/strong&gt;は、Erlangノードが開始されるすべてのホストで自動的に開始されます。シンボリックノード名をマシンアドレスにマッピングします。参照してください &lt;code&gt;epmd(1)&lt;/code&gt; ERTSでマニュアルページを。</target>
        </trans-unit>
        <trans-unit id="d980add9dd240554f189b1c3b37b65443fa21bb5" translate="yes" xml:space="preserve">
          <source>The Erlang Runtime System Application, ERTS, contains functionality necessary to run the Erlang system.</source>
          <target state="translated">Erlangランタイムシステムアプリケーション、ERTSにはErlangシステムを実行するために必要な機能が含まれています。</target>
        </trans-unit>
        <trans-unit id="ec553e20bbac1faf44d07e9ebb7fae6ca5046122" translate="yes" xml:space="preserve">
          <source>The Erlang SSL application implements the SSL/TLS/DTLS protocol for the currently supported versions, see the &lt;code&gt;&lt;a href=&quot;ssl&quot;&gt;ssl(3)&lt;/a&gt;&lt;/code&gt; manual page.</source>
          <target state="translated">Erlang SSLアプリケーションは、現在サポートされているバージョンのSSL / TLS / DTLSプロトコルを実装してい &lt;code&gt;&lt;a href=&quot;ssl&quot;&gt;ssl(3)&lt;/a&gt;&lt;/code&gt; マニュアルページを参照してください。</target>
        </trans-unit>
        <trans-unit id="0c184aeafc9a6a8c3c28dfd4fc9896eddb1e7172" translate="yes" xml:space="preserve">
          <source>The Erlang Token Scanner returns tokens with a subset of the following annotations, depending on the options:</source>
          <target state="translated">Erlang Token Scannerはオプションに応じて、以下のアノテーションのサブセットを持つトークンを返します。</target>
        </trans-unit>
        <trans-unit id="f44e036ac3f33332c9617d1ca93feead49accb2d" translate="yes" xml:space="preserve">
          <source>The Erlang VM uses a PCRE library where heap memory is used when regular expression match recursion occurs. This therefore limits the use of machine heap, not C stack.</source>
          <target state="translated">Erlang VMはPCREライブラリを使っていて、正規表現マッチの再帰が発生したときにヒープメモリが使われます。そのため、Cスタックではなくマシンヒープの使用を制限しています。</target>
        </trans-unit>
        <trans-unit id="8d4936bbce5dce7c69c00ed9e6d923ffdcef1207" translate="yes" xml:space="preserve">
          <source>The Erlang archives are &lt;code&gt;ZIP&lt;/code&gt; files with extension &lt;code&gt;.ez&lt;/code&gt;. Erlang archives can also be enclosed in &lt;code&gt;escript&lt;/code&gt; files whose file extension is arbitrary.</source>
          <target state="translated">Erlangアーカイブは、拡張子が &lt;code&gt;.ez&lt;/code&gt; の &lt;code&gt;ZIP&lt;/code&gt; ファイルです。Erlangアーカイブは、ファイル拡張子が任意の &lt;code&gt;escript&lt;/code&gt; ファイルに含めることもできます。</target>
        </trans-unit>
        <trans-unit id="75458bb55fedfe4d27d190b85b2453fc10e6e94f" translate="yes" xml:space="preserve">
          <source>The Erlang code in the &quot;Erlang code.&quot; section is written into the output file directly after the module declaration and predefined exports declaration so it is possible to add extra exports, define imports and other attributes which are then visible in the whole file.</source>
          <target state="translated">Erlang code.&quot;セクションのErlangコードはモジュール宣言と定義済みエクスポート宣言の直後に出力ファイルに書き込まれるので、追加のエクスポートを追加したり、インポートやその他の属性を定義したりすることができます。</target>
        </trans-unit>
        <trans-unit id="9bada6b35e4702ac9e1f602bd85f459a9e5c8d11" translate="yes" xml:space="preserve">
          <source>The Erlang code is slightly different, as we do not return the result synchronously from &lt;code&gt;port_control&lt;/code&gt;, instead we get it from &lt;code&gt;driver_output&lt;/code&gt; as data in the message queue. The function &lt;code&gt;return_port_data&lt;/code&gt; above receives data from the port. As the data is in binary format, we use &lt;code&gt;binary_to_term/1&lt;/code&gt; to convert it to an Erlang term. Notice that the driver is opened in binary mode (&lt;code&gt;open_port/2&lt;/code&gt; is called with option &lt;code&gt;[binary]&lt;/code&gt;). This means that data sent from the driver to the emulator is sent as binaries. Without option &lt;code&gt;binary&lt;/code&gt;, they would have been lists of integers.</source>
          <target state="translated">Erlangのコードは少し異なります。これは、結果を &lt;code&gt;port_control&lt;/code&gt; から同期的に返すのではなく、メッセージキューのデータとして &lt;code&gt;driver_output&lt;/code&gt; から取得するためです。上記の関数 &lt;code&gt;return_port_data&lt;/code&gt; は、ポートからデータを受信します。データはバイナリ形式なので、 &lt;code&gt;binary_to_term/1&lt;/code&gt; を使用してErlang用語に変換します。ドライバーがバイナリー・モードで開かれていることに注意してください（ &lt;code&gt;open_port/2&lt;/code&gt; は &lt;code&gt;[binary]&lt;/code&gt; オプションで呼び出されます）。つまり、ドライバーからエミュレーターに送信されるデータはバイナリーとして送信されます。オプション &lt;code&gt;binary&lt;/code&gt; がなければ、それらは整数のリストでした。</target>
        </trans-unit>
        <trans-unit id="57d172985612cd6cd41a2f597d2b75bb27821e07" translate="yes" xml:space="preserve">
          <source>The Erlang code linter.</source>
          <target state="translated">Erlangのコードリンター。</target>
        </trans-unit>
        <trans-unit id="a5138a7c32b5f91b090191893db4bd11097e1026" translate="yes" xml:space="preserve">
          <source>The Erlang code preprocessor includes functions that are used by the &lt;code&gt;compile&lt;/code&gt; module to preprocess macros and include files before the parsing takes place.</source>
          <target state="translated">Erlangコードプリプロセッサには、 &lt;code&gt;compile&lt;/code&gt; モジュールがマクロを前処理するために使用する関数と、解析が行われる前にファイルを含める関数が含まれています。</target>
        </trans-unit>
        <trans-unit id="5d403e45ee407cb0dd03528fe23bfb406bd2d6ae" translate="yes" xml:space="preserve">
          <source>The Erlang crash dump had a major facelift in Erlang/OTP R9C. The information in this section is therefore not directly applicable for older dumps. However, if you use &lt;code&gt;crashdump_viewer(3)&lt;/code&gt; on older dumps, the crash dumps are translated into a format similar to this.</source>
          <target state="translated">Erlangクラッシュダンプは、Erlang / OTP R9Cで大幅に改良されました。したがって、このセクションの情報は、古いダンプには直接適用できません。ただし、古いダンプで &lt;code&gt;crashdump_viewer(3)&lt;/code&gt; を使用すると、クラッシュダンプはこれに似た形式に変換されます。</target>
        </trans-unit>
        <trans-unit id="737305746ee3808d6e58fd2718a7d171052eb3a2" translate="yes" xml:space="preserve">
          <source>The Erlang crash dump is a readable text file, but it can be difficult to read. Using the Crashdump Viewer tool in the &lt;code&gt;Observer&lt;/code&gt; application simplifies the task. This is a wx-widget-based tool for browsing Erlang crash dumps.</source>
          <target state="translated">Erlangクラッシュダンプは読み取り可能なテキストファイルですが、読みにくい場合があります。 &lt;code&gt;Observer&lt;/code&gt; アプリケーションでCrashdump Viewerツールを使用すると、タスクが簡単になります。これは、Erlangクラッシュダンプを参照するためのwxウィジェットベースのツールです。</target>
        </trans-unit>
        <trans-unit id="3019fbc7ca6a8b1745aa1cb4e5822a66509aa10a" translate="yes" xml:space="preserve">
          <source>The Erlang crashdump contains a listing of each living Erlang process in the system. The following fields can exist for a process:</source>
          <target state="translated">Erlang crashdumpはシステム内で生きているErlangプロセスのリストを含んでいます。プロセスには以下のフィールドがあります。</target>
        </trans-unit>
        <trans-unit id="db00cf758cc1a463b96d0532ae1f4b69cef5510a" translate="yes" xml:space="preserve">
          <source>The Erlang distribution can in theory use almost any connection-based protocol as bearer. However, a module that implements the protocol-specific parts of the connection setup is needed. The default distribution module is &lt;code&gt;inet_tcp_dist&lt;/code&gt; in the Kernel application. When starting an Erlang node distributed, &lt;code&gt;net_kernel&lt;/code&gt; uses this module to set up listen ports and connections.</source>
          <target state="translated">Erlangディストリビューションでは、理論的には、ほとんどすべての接続ベースのプロトコルをベアラとして使用できます。ただし、接続設定のプロトコル固有の部分を実装するモジュールが必要です。カーネルアプリケーションでは、デフォルトの配布モジュールは &lt;code&gt;inet_tcp_dist&lt;/code&gt; です。分散Erlangノードを開始するとき、 &lt;code&gt;net_kernel&lt;/code&gt; はこのモジュールを使用してリスンポートと接続をセットアップします。</target>
        </trans-unit>
        <trans-unit id="5c65eb0e7a3b5fcbd2b82941f0e7502510e7adf8" translate="yes" xml:space="preserve">
          <source>The Erlang driver thread API can be used in conjunction with the POSIX thread API on UN-ices and with the Windows native thread API on Windows. The Erlang driver thread API has the advantage of being portable, but there can exist situations where you want to use functionality from the POSIX thread API or the Windows native thread API.</source>
          <target state="translated">ErlangドライバスレッドAPIはUN-icesのPOSIXスレッドAPIやWindowsのWindowsネイティブスレッドAPIと組み合わせて使うことができます。ErlangドライバスレッドAPIは移植性に優れていますが、POSIXスレッドAPIやWindowsネイティブスレッドAPIの機能を使いたい場合もあります。</target>
        </trans-unit>
        <trans-unit id="cd35f4981de74aaf8658339a6b773ed029b97baf" translate="yes" xml:space="preserve">
          <source>The Erlang driver thread API only returns error codes when it is reasonable to recover from an error condition. If it is not reasonable to recover from an error condition, the whole runtime system is terminated. For example, if a create mutex operation fails, an error code is returned, but if a lock operation on a mutex fails, the whole runtime system is terminated.</source>
          <target state="translated">ErlangドライバのスレッドAPIは、エラー状態から回復するのが妥当な場合にのみエラーコードを返します。エラー状態から回復するのが妥当でない場合、ランタイムシステム全体が終了します。例えば、ミューテックスの作成操作が失敗した場合はエラーコードが返されますが、ミューテックスのロック操作が失敗した場合はランタイムシステム全体が終了します。</target>
        </trans-unit>
        <trans-unit id="f886f4ca7d89492a5c1356ea054f392597b34344" translate="yes" xml:space="preserve">
          <source>The Erlang editing mode provides a command that knows about the Erlang comment structure and can be used to fill text paragraphs in comments. Ex:</source>
          <target state="translated">Erlang編集モードはErlangのコメント構造を知っているコマンドを提供し、コメントの段落を埋めるのに使うことができます。例</target>
        </trans-unit>
        <trans-unit id="6381e25503c0fb716dfd00aadaa0608beadd9a69" translate="yes" xml:space="preserve">
          <source>The Erlang emulator is found by examining the registry keys for the emulator version specified in the release data file. The new emulator must be properly installed before the upgrade for this to work.</source>
          <target state="translated">Erlangエミュレータはリリースデータファイルで指定されたエミュレータバージョンのレジストリキーを調べて見つけます。アップグレードする前に新しいエミュレータを正しくインストールしておく必要があります。</target>
        </trans-unit>
        <trans-unit id="6339e932f018732bcd165eb1f04f836a77855588" translate="yes" xml:space="preserve">
          <source>The Erlang emulator keeps track of a &lt;strong&gt;stack trace&lt;/strong&gt;, information about recent function calls. This information is used if an error occurs, for example:</source>
          <target state="translated">Erlangエミュレーターは、最近の関数呼び出しに関する情報である&lt;strong&gt;スタックトレースを追跡し&lt;/strong&gt;ます。この情報は、エラーが発生した場合に使用されます。次に例を示します。</target>
        </trans-unit>
        <trans-unit id="17cd3f882b4ce1af8737a7262e13ec5ab23b1f5e" translate="yes" xml:space="preserve">
          <source>The Erlang emulator.</source>
          <target state="translated">Erlangエミュレータです。</target>
        </trans-unit>
        <trans-unit id="5714cdd55594ddeb51b48625444a53558a829eec" translate="yes" xml:space="preserve">
          <source>The Erlang external term format is a representation of an Erlang term as a sequence of bytes, that is, a binary. Conversion between the two representations is done using the following BIFs:</source>
          <target state="translated">Erlang外部用語フォーマットはErlang用語をバイトのシーケンス、つまりバイナリで表現したものです。2つの表現間の変換は以下のBIFを使って行われます。</target>
        </trans-unit>
        <trans-unit id="152d4b6905d9f607d0072156b089899f65fd52eb" translate="yes" xml:space="preserve">
          <source>The Erlang implementation is &quot;clever&quot; and minimizes the number of times each message is tested against the patterns in each &lt;code&gt;receive&lt;/code&gt;.</source>
          <target state="translated">Erlangの実装は「賢い」ものであり、各メッセージが各 &lt;code&gt;receive&lt;/code&gt; のパターンに対してテストされる回数を最小限に抑えます。</target>
        </trans-unit>
        <trans-unit id="79a0b3cf2e8db83679b557ee8aff89fcae6b1c98" translate="yes" xml:space="preserve">
          <source>The Erlang interpreter can also be accessed through the interface module &lt;code&gt;&lt;a href=&quot;int&quot;&gt;int(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Erlangインタプリタには、インターフェイスモジュール &lt;code&gt;&lt;a href=&quot;int&quot;&gt;int(3)&lt;/a&gt;&lt;/code&gt; からもアクセスできます。</target>
        </trans-unit>
        <trans-unit id="d3ca39c39b895d99de154868388ab2c941551645" translate="yes" xml:space="preserve">
          <source>The Erlang interpreter provides mechanisms for breakpoints and stepwise execution of code. It is primarily intended to be used by Debugger, see the User's Guide and &lt;code&gt;&lt;a href=&quot;debugger&quot;&gt;debugger(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Erlangインタープリターは、ブレークポイントとコードの段階的実行のためのメカニズムを提供します。これは主にデバッガーで使用することを目的としてい &lt;code&gt;&lt;a href=&quot;debugger&quot;&gt;debugger(3)&lt;/a&gt;&lt;/code&gt; 。ユーザーズガイドとデバッガー（3）を参照してください。</target>
        </trans-unit>
        <trans-unit id="bfe42365ca090c07c2f31a18aa82078cc7413a46" translate="yes" xml:space="preserve">
          <source>The Erlang language is described in the &lt;a href=&quot;doc/reference_manual/users_guide&quot;&gt;Erlang Reference Manual&lt;/a&gt;. An Erlang tutorial can be found in &lt;a href=&quot;doc/getting_started/users_guide&quot;&gt; Getting Started With Erlang&lt;/a&gt;.</source>
          <target state="translated">Erlang言語については、&lt;a href=&quot;doc/reference_manual/users_guide&quot;&gt;Erlangリファレンスマニュアルで&lt;/a&gt;説明されています。Erlangチュートリアルは&lt;a href=&quot;doc/getting_started/users_guide&quot;&gt;Getting Started With Erlangにあり&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="5c86834683bf25d823843edf61397923bc0c7af5" translate="yes" xml:space="preserve">
          <source>The Erlang language specification puts no limits on the number of processes, length of atoms, and so on. However, for performance and memory saving reasons, there will always be limits in a practical implementation of the Erlang language and execution environment.</source>
          <target state="translated">Erlang言語の仕様ではプロセスの数や原子の長さなどに制限はありません。しかし、パフォーマンスとメモリ節約の理由から、Erlang言語と実行環境の実用的な実装には常に制限があります。</target>
        </trans-unit>
        <trans-unit id="5868365d112b2d753afe38d0282d35341218fb05" translate="yes" xml:space="preserve">
          <source>The Erlang literal syntax for strings uses the &quot;\&quot; (backslash) character as an escape code. You need to escape backslashes in literal strings, both in your code and in the shell, with an extra backslash, that is, &quot;\\&quot;.</source>
          <target state="translated">Erlangの文字列のリテラル構文では&quot;\&quot; (バックスラッシュ)をエスケープコードとして使います。コードの中でもシェルの中でも、リテラル文字列のバックスラッシュをエスケープする必要があります。</target>
        </trans-unit>
        <trans-unit id="7436c6776e46ff0b0c98637a1562d8d93f74d6d7" translate="yes" xml:space="preserve">
          <source>The Erlang meta interpreter.</source>
          <target state="translated">Erlangメタインタプリタ。</target>
        </trans-unit>
        <trans-unit id="6dd0afebea808766c4e5ba67702ba9bcda564088" translate="yes" xml:space="preserve">
          <source>The Erlang mode does, of course, provide this feature. The layout used is based on the common use of the language.</source>
          <target state="translated">Erlangモードはもちろんこの機能を提供します。使用されているレイアウトは言語の一般的な使い方に基づいています。</target>
        </trans-unit>
        <trans-unit id="e03b514fa1c315e1fd202d5ceb91d82531266ba5" translate="yes" xml:space="preserve">
          <source>The Erlang mode for the Emacs editor includes two &lt;code&gt;Common Test&lt;/code&gt; test suite templates, one with extensive information in the function headers, and one with minimal information. A test suite template provides a quick start for implementing a suite from scratch and gives a good overview of the available callback functions. The two templates follows:</source>
          <target state="translated">EmacsエディターのErlangモードには、2つの &lt;code&gt;Common Test&lt;/code&gt; テストスイートテンプレートが含まれています。1つは関数ヘッダーに広範な情報があり、もう1つは最小限の情報があります。テストスイートテンプレートは、スイートを最初から実装するためのクイックスタートを提供し、使用可能なコールバック関数の概要を提供します。2つのテンプレートは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="bd1e16dd7e3186a437be6f5c58e6b98f95a1b6f2" translate="yes" xml:space="preserve">
          <source>The Erlang module can look as follows:</source>
          <target state="translated">Erlangモジュールは以下のようになります。</target>
        </trans-unit>
        <trans-unit id="4e4823fe40646d231f25e1af4061079540646bbb" translate="yes" xml:space="preserve">
          <source>The Erlang nif library contains function for easily working with I/O vectors as used by the unix system call &lt;code&gt;writev&lt;/code&gt;. The I/O Queue is not thread safe, so some other synchronization mechanism has to be used.</source>
          <target state="translated">Erlang nifライブラリには、UNIXシステムコール &lt;code&gt;writev&lt;/code&gt; で使用されるI / Oベクトルを簡単に操作するための関数が含まれています。I / Oキューはスレッドセーフではないため、他の同期メカニズムを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="4fe4b7ddd1b6e3fddbfb0dc8eba68674fa92a0bc" translate="yes" xml:space="preserve">
          <source>The Erlang node is to be given the short name &lt;code&gt;e1&lt;/code&gt; and must be set to use the same magic cookie as the C node, &lt;code&gt;secretcookie&lt;/code&gt;:</source>
          <target state="translated">Erlangノードには短い名前 &lt;code&gt;e1&lt;/code&gt; が与えられ、Cノードと同じマジックcookie、 &lt;code&gt;secretcookie&lt;/code&gt; を使用するように設定する必要があります。</target>
        </trans-unit>
        <trans-unit id="b252e3e3ea1acfeb31712ba10c8bb1164cc7e6f7" translate="yes" xml:space="preserve">
          <source>The Erlang nodes have different cookies.</source>
          <target state="translated">Erlangノードは異なるクッキーを持っています。</target>
        </trans-unit>
        <trans-unit id="2dac1fcc04ff2d796878d2e221f0d3d0504eeff3" translate="yes" xml:space="preserve">
          <source>The Erlang parser.</source>
          <target state="translated">Erlangパーサー。</target>
        </trans-unit>
        <trans-unit id="e3e1a66870ceefa4057accb399287057807ab241" translate="yes" xml:space="preserve">
          <source>The Erlang part of the asynchronous driver consists of the sample file &lt;code&gt;pg_async.erl&lt;/code&gt;.</source>
          <target state="translated">非同期ドライバーのErlang部分は、サンプルファイル &lt;code&gt;pg_async.erl&lt;/code&gt; で構成されています。</target>
        </trans-unit>
        <trans-unit id="8a9c70ac47d5fb1df5bdc0c1579a6d354d215f36" translate="yes" xml:space="preserve">
          <source>The Erlang pretty printer.</source>
          <target state="translated">Erlangの可愛いプリンタ。</target>
        </trans-unit>
        <trans-unit id="8092d1a007430220494c776fea5b8d0105151629" translate="yes" xml:space="preserve">
          <source>The Erlang process creating a port is said to be the &lt;strong&gt;port owner&lt;/strong&gt;, or the &lt;strong&gt;connected process&lt;/strong&gt; of the port. All communication to and from the port must go through the port owner. If the port owner terminates, so does the port (and the external program, if it is written correctly).</source>
          <target state="translated">ポートを作成するErlangプロセスは、&lt;strong&gt;ポート所有者&lt;/strong&gt;、または&lt;strong&gt;ポート&lt;/strong&gt;の&lt;strong&gt;接続されたプロセス&lt;/strong&gt;と呼ばれます。ポートとの間のすべての通信は、ポート所有者を経由する必要があります。ポートの所有者が終了すると、ポート（および、正しく記述されている場合は外部プログラム）も終了します。</target>
        </trans-unit>
        <trans-unit id="27d54a521c2a5287aa3d01d2b57bd9e14da9ddb9" translate="yes" xml:space="preserve">
          <source>The Erlang representation for &quot;BMPString&quot; and &quot;UniversalString&quot; is either a list of ASCII values or a list of quadruples. The quadruple representation associates to the Unicode standard representation of characters. The ASCII characters are all represented by quadruples beginning with three zeros like {0,0,0,65} for character 'A'. When decoding a value for these strings, the result is a list of quadruples, or integers when the value is an ASCII character.</source>
          <target state="translated">Erlangの &quot;BMPString &quot;と &quot;UniversalString &quot;の表現はASCII値のリストか四重項のリストです。四重項表現はUnicodeの標準的な文字表現に関連しています。ASCII 文字はすべて、文字 'A' の {0,0,0,65}のように、3 つのゼロから始まる四重項で表現されます。これらの文字列の値をデコードすると、結果は四重プルのリストとなり、値が ASCII 文字の場合は整数となります。</target>
        </trans-unit>
        <trans-unit id="fd34b0812f3e91023a25d2d60c73c4062e69913a" translate="yes" xml:space="preserve">
          <source>The Erlang representation of an ASN.1 &lt;code&gt;INTEGER&lt;/code&gt; is an integer or an atom if a &lt;code&gt;Named Number List&lt;/code&gt; (see &lt;code&gt;T6&lt;/code&gt; in the previous list) is specified.</source>
          <target state="translated">&lt;code&gt;Named Number List&lt;/code&gt; （前のリストの &lt;code&gt;T6&lt;/code&gt; を参照）が指定されている場合、ASN.1 &lt;code&gt;INTEGER&lt;/code&gt; のErlang表現は整数またはアトムです。</target>
        </trans-unit>
        <trans-unit id="6762086b168330d83da3710e72be56df1e3f3f82" translate="yes" xml:space="preserve">
          <source>The Erlang runtime system can use the complete 32-bit (or 64-bit) address space, but the operating system often limits a single process to use less than that.</source>
          <target state="translated">Erlangのランタイムシステムは32ビット(または64ビット)のアドレス空間を完全に使うことができますが、オペレーティングシステムは1つのプロセスがそれ以下のアドレス空間を使うことを制限していることがよくあります。</target>
        </trans-unit>
        <trans-unit id="b825bf5f9dd97f4fdde610e1f993f6d1d34418b7" translate="yes" xml:space="preserve">
          <source>The Erlang runtime system requires that the contents of the script used to boot the system is a binary Erlang term. This function transforms the &lt;code&gt;File.script&lt;/code&gt; boot script to a binary term, which is stored in the &lt;code&gt;File.boot&lt;/code&gt; file.</source>
          <target state="translated">Erlangランタイムシステムでは、システムの起動に使用されるスクリプトの内容がバイナリErlang用語である必要があります。この関数は、 &lt;code&gt;File.script&lt;/code&gt; ブートスクリプトを、 &lt;code&gt;File.boot&lt;/code&gt; ファイルに格納されているバイナリ項に変換します。</target>
        </trans-unit>
        <trans-unit id="a1ce0572c42ceec3f568ad1851dad4770b2b84b7" translate="yes" xml:space="preserve">
          <source>The Erlang runtime system uses a generational garbage collection scheme, using an &quot;old heap&quot; for data that has survived at least one garbage collection. When there is no more room on the old heap, a fullsweep garbage collection is done.</source>
          <target state="translated">Erlangのランタイムシステムは世代別ガベージコレクション方式を使っており、少なくとも1回のガベージコレクションで生き残ったデータには「古いヒープ」を使います。古いヒープに空きがなくなると、フルスイープのガベージコレクションが行われます。</target>
        </trans-unit>
        <trans-unit id="b9d9f6b0df9097bbff53b037dc4f96145ca6dbd2" translate="yes" xml:space="preserve">
          <source>The Erlang runtime systems view of &lt;code&gt;&lt;a href=&quot;#POSIX_Time&quot;&gt;POSIX time&lt;/a&gt;&lt;/code&gt;. To retrieve it, call &lt;code&gt;&lt;a href=&quot;erlang#system_time-0&quot;&gt;erlang:system_time()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#POSIX_Time&quot;&gt;POSIX time&lt;/a&gt;&lt;/code&gt; のErlangランタイムシステムビュー。それを取得するには、 &lt;code&gt;&lt;a href=&quot;erlang#system_time-0&quot;&gt;erlang:system_time()&lt;/a&gt;&lt;/code&gt; を呼び出します。</target>
        </trans-unit>
        <trans-unit id="175c0bd0d93fcd68af4b41f5bd3ed0c1384dfa2e" translate="yes" xml:space="preserve">
          <source>The Erlang scanner in the &lt;code&gt;io&lt;/code&gt; module can be used as a starting point when writing a new scanner. Study &lt;code&gt;yeccscan.erl&lt;/code&gt; in order to see how a filter can be added on top of &lt;code&gt;io:scan_erl_form/3&lt;/code&gt; to provide a scanner for Yecc that tokenizes grammar files before parsing them with the Yecc parser. A more general approach to scanner implementation is to use a scanner generator. A scanner generator in Erlang called &lt;code&gt;leex&lt;/code&gt; is under development.</source>
          <target state="translated">&lt;code&gt;io&lt;/code&gt; モジュールのErlangスキャナーは、新しいスキャナーを作成する際の出発点として使用できます。研究 &lt;code&gt;yeccscan.erl&lt;/code&gt; フィルタがの上に追加することができる方法を確認するために &lt;code&gt;io:scan_erl_form/3&lt;/code&gt; Yeccパーサでそれらを解析する前に文法ファイルをトークン化Yeccためのスキャナを提供します。スキャナー実装へのより一般的なアプローチは、スキャナージェネレーターを使用することです。Erlangで &lt;code&gt;leex&lt;/code&gt; と呼ばれるスキャナージェネレーターが開発中です。</target>
        </trans-unit>
        <trans-unit id="37265f6197faced222d42e8a4148f58e5b966cea" translate="yes" xml:space="preserve">
          <source>The Erlang server interface is implemented by module &lt;code&gt;mod_esi&lt;/code&gt;.</source>
          <target state="translated">Erlangサーバーインターフェイスはモジュール &lt;code&gt;mod_esi&lt;/code&gt; によって実装されます。</target>
        </trans-unit>
        <trans-unit id="fa8c45ba50425e13e797fcc4854bc1fcf3424403" translate="yes" xml:space="preserve">
          <source>The Erlang shell available over SSH</source>
          <target state="translated">SSH経由で利用できるErlangシェル</target>
        </trans-unit>
        <trans-unit id="fa1d76065068bd2589fcd099c8a0c8156db2a1c8" translate="yes" xml:space="preserve">
          <source>The Erlang shell understands the command &lt;code&gt;c(Module)&lt;/code&gt; which both compiles and loads &lt;code&gt;Module&lt;/code&gt;.</source>
          <target state="translated">アーランシェルコマンド理解 &lt;code&gt;c(Module)&lt;/code&gt; の両方のコンパイルとロード &lt;code&gt;Module&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a5dceee96a25b9a8c7bf615c2130bf76584510ce" translate="yes" xml:space="preserve">
          <source>The Erlang shell.</source>
          <target state="translated">Erlangシェル。</target>
        </trans-unit>
        <trans-unit id="a51205151ea58d8438ebe29c7d0e6218f72ff948" translate="yes" xml:space="preserve">
          <source>The Erlang source code has support for the UTF-8 encoding and bytewise encoding. The default in Erlang/OTP R16B was bytewise (&lt;code&gt;latin1&lt;/code&gt;) encoding. It was changed to UTF-8 in Erlang/OTP 17.0. You can control the encoding by a comment like the following in the beginning of the file:</source>
          <target state="translated">Erlangソースコードは、UTF-8エンコーディングとバイト単位のエンコーディングをサポートしています。Erlang / OTP R16Bのデフォルトはバイト単位（ &lt;code&gt;latin1&lt;/code&gt; ）エンコーディングでした。Erlang / OTP 17.0でUTF-8に変更されました。ファイルの先頭にある次のようなコメントでエンコードを制御できます。</target>
        </trans-unit>
        <trans-unit id="469909cd3bb80b2a08960dcf0954a2e053c206c4" translate="yes" xml:space="preserve">
          <source>The Erlang source file &lt;code&gt;encoding&lt;/code&gt; is selected by a comment in one of the first two lines of the source file. The first string that matches the regular expression &lt;code&gt;coding\s*[:=]\s*([-a-zA-Z0-9])+&lt;/code&gt; selects the encoding. If the matching string is an invalid encoding, it is ignored. The valid encodings are &lt;code&gt;Latin-1&lt;/code&gt; and &lt;code&gt;UTF-8&lt;/code&gt;, where the case of the characters can be chosen freely.</source>
          <target state="translated">Erlangソースファイルの &lt;code&gt;encoding&lt;/code&gt; は、ソースファイルの最初の2行のいずれかのコメントによって選択されます。正規表現 &lt;code&gt;coding\s*[:=]\s*([-a-zA-Z0-9])+&lt;/code&gt; 一致する最初の文字列は、エンコーディングを選択します。一致する文字列が無効なエンコーディングである場合、それは無視されます。有効なエンコーディングは &lt;code&gt;Latin-1&lt;/code&gt; と &lt;code&gt;UTF-8&lt;/code&gt; で、文字の大文字と小文字は自由に選択できます。</target>
        </trans-unit>
        <trans-unit id="e7ddb53385af1f6753c8713a645cc1fc36907bac" translate="yes" xml:space="preserve">
          <source>The Erlang source file &lt;strong id=&quot;encoding&quot;&gt;encoding&lt;/strong&gt; is selected by a comment in one of the first two lines of the source file. The first string matching the regular expression &lt;code&gt;coding\s*[:=]\s*([-a-zA-Z0-9])+&lt;/code&gt; selects the encoding. If the matching string is not a valid encoding, it is ignored. The valid encodings are &lt;code&gt;Latin-1&lt;/code&gt; and &lt;code&gt;UTF-8&lt;/code&gt;, where the case of the characters can be chosen freely.</source>
          <target state="translated">Erlangソースファイルの&lt;strong id=&quot;encoding&quot;&gt;エンコーディング&lt;/strong&gt;は、ソースファイルの最初の2行のいずれかのコメントによって選択されます。正規表現 &lt;code&gt;coding\s*[:=]\s*([-a-zA-Z0-9])+&lt;/code&gt; 一致する最初の文字列は、エンコーディングを選択します。一致する文字列が有効なエンコーディングでない場合、無視されます。有効なエンコーディングは &lt;code&gt;Latin-1&lt;/code&gt; と &lt;code&gt;UTF-8&lt;/code&gt; で、文字の大文字と小文字は自由に選択できます。</target>
        </trans-unit>
        <trans-unit id="978c7190f27ebbf14f966c1feadf6f5410de9629" translate="yes" xml:space="preserve">
          <source>The Erlang system must be started.</source>
          <target state="translated">Erlangシステムを起動しなければなりません。</target>
        </trans-unit>
        <trans-unit id="c9941ae0e376a140dd219d96c5fea5aedb3770d4" translate="yes" xml:space="preserve">
          <source>The Erlang token scanner.</source>
          <target state="translated">Erlangのトークンスキャナ。</target>
        </trans-unit>
        <trans-unit id="a16c12a6b02ac800a11334f62d3a994378ac0165" translate="yes" xml:space="preserve">
          <source>The Erlang web server API data types are as follows:</source>
          <target state="translated">ErlangのWebサーバーAPIのデータ型は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="65d28c591e7208c326a531484ecbb2f3de4814d0" translate="yes" xml:space="preserve">
          <source>The Evaluator area, where you can evaluate functions within the context of the debugged process, if that process execution is stopped.</source>
          <target state="translated">評価者領域は、デバッグされたプロセスの実行が停止している場合に、デバッグされたプロセスのコンテキスト内で関数を評価することができます。</target>
        </trans-unit>
        <trans-unit id="b8f527b2c601f16975ba4c3206247d354cc52722" translate="yes" xml:space="preserve">
          <source>The FTP client always tries to use passive FTP mode and only resort to active FTP mode if this fails. This default behavior can be changed by start option &lt;code&gt;&lt;a href=&quot;#mode&quot;&gt;mode&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">FTPクライアントは常にパッシブFTPモードを使用しようとし、これが失敗した場合にのみアクティブFTPモードに頼ります。このデフォルトの動作は、起動オプション &lt;code&gt;&lt;a href=&quot;#mode&quot;&gt;mode&lt;/a&gt;&lt;/code&gt; 変更できます。</target>
        </trans-unit>
        <trans-unit id="46eb4343e573b38e361697e41777d053a18c2fba" translate="yes" xml:space="preserve">
          <source>The FTP client can be started and stopped dynamically in runtime by calling the &lt;code&gt;ftp&lt;/code&gt; application API &lt;code&gt;ftp:start_service(ServiceConfig)&lt;/code&gt; and &lt;code&gt;ftp:stop_service(Pid)&lt;/code&gt;.</source>
          <target state="translated">FTPクライアントは、 &lt;code&gt;ftp&lt;/code&gt; アプリケーションAPIの &lt;code&gt;ftp:start_service(ServiceConfig)&lt;/code&gt; および &lt;code&gt;ftp:stop_service(Pid)&lt;/code&gt; を呼び出すことにより、実行時に動的に開始および停止できます。</target>
        </trans-unit>
        <trans-unit id="0ff37cf016753285c00cfe38b14f6b9064cd0bb5" translate="yes" xml:space="preserve">
          <source>The Flex scanner is a Megaco scanner written as a linked in driver (in C). There are two ways to get this working:</source>
          <target state="translated">Flexスキャナは、リンクインドライバ(C言語)で書かれたMegacoスキャナです。これを動作させるには2つの方法があります。</target>
        </trans-unit>
        <trans-unit id="0817c2658a9f234929df429f0abce5aa05ce329d" translate="yes" xml:space="preserve">
          <source>The Fun can also be passed as an argument to the function &lt;code&gt;&lt;a href=&quot;mnesia#activity-4&quot;&gt;mnesia:activity/2,3,4&lt;/a&gt;&lt;/code&gt;, which enables use of customized activity access callback modules. It can either be obtained directly by stating the module name as argument, or implicitly by use of configuration parameter &lt;code&gt;access_module&lt;/code&gt;. A customized callback module can be used for several purposes, such as providing triggers, integrity constraints, runtime statistics, or virtual tables.</source>
          <target state="translated">Funは、関数 &lt;code&gt;&lt;a href=&quot;mnesia#activity-4&quot;&gt;mnesia:activity/2,3,4&lt;/a&gt;&lt;/code&gt; に引数として渡すこともできます。これにより、カスタマイズされたアクティビティアクセスコールバックモジュールを使用できるようになります。引数としてモジュール名を指定して直接取得するか、構成パラメーター &lt;code&gt;access_module&lt;/code&gt; を使用して暗黙的に取得できます。カスタマイズされたコールバックモジュールは、トリガー、整合性制約、ランタイム統計、仮想テーブルの提供など、いくつかの目的に使用できます。</target>
        </trans-unit>
        <trans-unit id="491576369b07d94c026adb9d94add3cd468dc1c6" translate="yes" xml:space="preserve">
          <source>The GUI main window is opened when Crashdump Viewer has loaded a crashdump. It contains a title bar, a menu bar, information tabs, and a status bar.</source>
          <target state="translated">Crashdump Viewerがクラッシュダンプをロードすると、GUIメイン・ウィンドウが開きます。メイン・ウィンドウには、タイトル・バー、メニュー・バー、情報タブ、ステータス・バーがあります。</target>
        </trans-unit>
        <trans-unit id="468c9cc0468cc5c92ee919e07070c915b671da34" translate="yes" xml:space="preserve">
          <source>The GetNext Operation operation should only be defined for tables since the agent can find the next instance of plain variables in the MIB and call the instrumentation with the &lt;code&gt;get&lt;/code&gt; operation.</source>
          <target state="translated">エージェントはMIBでプレーン変数の次のインスタンスを見つけ、 &lt;code&gt;get&lt;/code&gt; 操作でインスツルメンテーションを呼び出すことができるため、GetNext操作操作はテーブルに対してのみ定義する必要があります。</target>
        </trans-unit>
        <trans-unit id="ca4179f6bcde085d4b0d34f9240821a74141f758" translate="yes" xml:space="preserve">
          <source>The Gregorian calendar in this module is extended back to year 0. For a given date, the &lt;strong&gt;gregorian days&lt;/strong&gt; is the number of days up to and including the date specified. Similarly, the &lt;strong&gt;gregorian seconds&lt;/strong&gt; for a specified date and time is the number of seconds up to and including the specified date and time.</source>
          <target state="translated">このモジュールのグレゴリオ暦は0年まで拡張されます。特定の日付の場合、グレゴリオ暦の&lt;strong&gt;日数&lt;/strong&gt;は、指定された日付までの日数です。同様に、指定された日時の&lt;strong&gt;グレゴリオ秒&lt;/strong&gt;は、指定された日時までの秒数です。</target>
        </trans-unit>
        <trans-unit id="6a32364a7c7faf5d1cbacad811c6e3a642e6422e" translate="yes" xml:space="preserve">
          <source>The HTML overview log file is updated with test results.</source>
          <target state="translated">HTML概要ログファイルは、テスト結果とともに更新されます。</target>
        </trans-unit>
        <trans-unit id="aab4263cb8d1f32842025f35d2e34059d6bef33e" translate="yes" xml:space="preserve">
          <source>The HTML version of the test suite source code is not generated during the test run (and is consequently not available in the log file system).</source>
          <target state="translated">テストスイートのソースコードのHTMLバージョンは、テスト実行中には生成されません(結果的にログファイルシステムでは利用できません)。</target>
        </trans-unit>
        <trans-unit id="e41fc71ae08f56427cd0499723a4d95a81e54bc2" translate="yes" xml:space="preserve">
          <source>The HTTP client and server are HTTP 1.1 compliant as defined in &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc2616.txt&quot;&gt;RFC 2616&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">HTTPクライアントとサーバーは、 &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc2616.txt&quot;&gt;RFC 2616&lt;/a&gt;&lt;/code&gt; で定義されているように、HTTP 1.1に準拠しています。</target>
        </trans-unit>
        <trans-unit id="0a3e013cebd4679eacc44ce278db16ae997e7553" translate="yes" xml:space="preserve">
          <source>The HTTP client default profile is started when the &lt;code&gt;Inets&lt;/code&gt; application is started and is then available to all processes on that Erlang node. Other profiles can also be started at application startup, or profiles can be started and stopped dynamically in runtime. Each client profile spawns a new process to handle each request, unless a persistent connection can be used with or without pipelining. The client adds a &lt;code&gt;host&lt;/code&gt; header and an empty &lt;code&gt;te&lt;/code&gt; header if there are no such headers present in the request.</source>
          <target state="translated">HTTPクライアントのデフォルトプロファイルは、 &lt;code&gt;Inets&lt;/code&gt; アプリケーションの起動時に開始され、そのErlangノードのすべてのプロセスで使用できます。他のプロファイルもアプリケーションの起動時に開始できます。または、実行時にプロファイルを動的に開始および停止できます。パイプラインの有無にかかわらず永続的な接続を使用できる場合を除き、各クライアントプロファイルは、各リクエストを処理する新しいプロセスを生成します。クライアントは、追加 &lt;code&gt;host&lt;/code&gt; ヘッダーと空の &lt;code&gt;te&lt;/code&gt; 要求に存在しないようなヘッダが存在しない場合ヘッダを。</target>
        </trans-unit>
        <trans-unit id="7c7ba7538b9c9c0121b49c6ec91168734deba0dc" translate="yes" xml:space="preserve">
          <source>The HTTP server, also referred to as httpd, handles HTTP requests as described in &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc2616.txt&quot;&gt;RFC 2616&lt;/a&gt;&lt;/code&gt; with a few exceptions, such as gateway and proxy functionality. The server supports IPv6 as long as the underlying mechanisms also do so.</source>
          <target state="translated">HTTPサーバーは、httpdとも呼ばれ、ゲートウェイやプロキシ機能などのいくつかの例外を除いて、 &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc2616.txt&quot;&gt;RFC 2616&lt;/a&gt;&lt;/code&gt; で説明されているようにHTTP要求を処理します。基盤となるメカニズムもIPv6をサポートしている限り、サーバーはIPv6をサポートします。</target>
        </trans-unit>
        <trans-unit id="ed5f93e75e8af313b179c6713c54eb1bf37d9eef" translate="yes" xml:space="preserve">
          <source>The HTTP standard requires them to be case insensitive. Use this feature only if there is no other way to communicate with the server or for testing purpose. When this option is used, no headers are automatically added. All necessary headers must be provided by the user.</source>
          <target state="translated">HTTP 標準では、大文字と小文字を区別しないことが要求されています。この機能は、サーバと通信するための他の方法がない場合やテスト目的の場合にのみ使用してください。このオプションを使用すると、ヘッダは自動的に追加されません。必要なヘッダはすべてユーザが提供する必要があります。</target>
        </trans-unit>
        <trans-unit id="f2d85de81f5fcc8588a618440bb02e8ae50bca16" translate="yes" xml:space="preserve">
          <source>The HTTP status code returned to the client (&lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc1945.txt&quot;&gt;RFC 1945&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">クライアントに返されたHTTPステータスコード（ &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc1945.txt&quot;&gt;RFC 1945&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="1b82e39a63325ee5467a0018be1f905eeb2f7c52" translate="yes" xml:space="preserve">
          <source>The Hypertext Transfer Protocol. The packets are returned with the format according to &lt;code&gt;HttpPacket&lt;/code&gt; described earlier. A packet is either a request, a response, a header, or an end of header mark. Invalid lines are returned as &lt;code&gt;HttpError&lt;/code&gt;.</source>
          <target state="translated">ハイパーテキスト転送プロトコル。パケットは、前述の &lt;code&gt;HttpPacket&lt;/code&gt; に従った形式で返されます。パケットは、要求、応答、ヘッダー、またはヘッダー終了マークのいずれかです。無効な行は &lt;code&gt;HttpError&lt;/code&gt; として返されます。</target>
        </trans-unit>
        <trans-unit id="169734960811a4c34c5ce86c1d456ff7cf230d3e" translate="yes" xml:space="preserve">
          <source>The Hypertext Transfer Protocol. The packets are returned with the format according to &lt;code&gt;HttpPacket&lt;/code&gt; described in &lt;code&gt;erlang:decode_packet/3&lt;/code&gt; in ERTS. A socket in passive mode returns &lt;code&gt;{ok, HttpPacket}&lt;/code&gt; from &lt;code&gt;gen_tcp:recv&lt;/code&gt; while an active socket sends messages like &lt;code&gt;{http, Socket, HttpPacket}&lt;/code&gt;.</source>
          <target state="translated">ハイパーテキスト転送プロトコル。パケットは、 &lt;code&gt;HttpPacket&lt;/code&gt; &lt;code&gt;erlang:decode_packet/3&lt;/code&gt; に記述されているHttpPacketに従った形式で返されます。パッシブモードのソケットは &lt;code&gt;gen_tcp:recv&lt;/code&gt; から &lt;code&gt;{ok, HttpPacket}&lt;/code&gt; 返しますが、アクティブソケットは &lt;code&gt;{http, Socket, HttpPacket}&lt;/code&gt; などのメッセージを送信します。</target>
        </trans-unit>
        <trans-unit id="0fdd97c77238f0d4bc1a4b8495b731166db58155" translate="yes" xml:space="preserve">
          <source>The I/O device used when Erlang is started with the &quot;-oldshell&quot; or &quot;-noshell&quot; flags is by default set to &lt;code&gt;latin1&lt;/code&gt; encoding, meaning that any characters &amp;gt; codepoint 255 are escaped and that input is expected to be plain 8-bit ISO Latin-1. If the encoding is changed to Unicode, input and output from the standard file descriptors are in UTF-8 (regardless of operating system).</source>
          <target state="translated">Erlangが「-oldshell」または「-noshell」フラグで開始されたときに使用されるI / Oデバイスは、デフォルトで &lt;code&gt;latin1&lt;/code&gt; エンコーディングに設定されています。つまり、コードポイント255を超える文字はエスケープされ、入力はプレーンな8ビットであることが期待されますISO Latin-1。エンコーディングをUnicodeに変更すると、標準ファイル記述子からの入力と出力は、オペレーティングシステムに関係なくUTF-8になります。</target>
        </trans-unit>
        <trans-unit id="3a9ee44bfdadb9768492101f1c57f8171e2439fd" translate="yes" xml:space="preserve">
          <source>The I/O protocol in Erlang enables bi-directional communication between clients and servers.</source>
          <target state="translated">ErlangのI/Oプロトコルはクライアントとサーバ間の双方向通信を可能にします。</target>
        </trans-unit>
        <trans-unit id="da4b71eee53848cfe7e0ded6f806a23b361aa596" translate="yes" xml:space="preserve">
          <source>The I/O server can, for a list of requests, send any of the following valid results in the reply, depending on the requests in the list:</source>
          <target state="translated">I/Oサーバーは、リクエストのリストに対して、リスト内のリクエストに応じて、以下の有効な結果のいずれかを返信に送ることができます。</target>
        </trans-unit>
        <trans-unit id="7bf03aa38e2e7b2e9d865676ed62c6ed1b166de9" translate="yes" xml:space="preserve">
          <source>The I/O server is a process that handles the requests and performs the requested task on, for example, an I/O device.</source>
          <target state="translated">I/Oサーバは、要求を処理し、要求されたタスクを例えばI/Oデバイス上で実行するプロセスである。</target>
        </trans-unit>
        <trans-unit id="29324f42eeb70cb428190b9afb707250b51d08e0" translate="yes" xml:space="preserve">
          <source>The I/O server is to send one of the following as &lt;code&gt;Reply&lt;/code&gt;:</source>
          <target state="translated">I / Oサーバーは、次のいずれかを &lt;code&gt;Reply&lt;/code&gt; として送信します。</target>
        </trans-unit>
        <trans-unit id="cffff6188b7c071be58063158f15f52414545611" translate="yes" xml:space="preserve">
          <source>The I/O server is to send the &lt;code&gt;Reply&lt;/code&gt; as:</source>
          <target state="translated">I / Oサーバーは、 &lt;code&gt;Reply&lt;/code&gt; を次のように送信します。</target>
        </trans-unit>
        <trans-unit id="a68a34b093217c6e79f51f56360324a76a6607db" translate="yes" xml:space="preserve">
          <source>The I/O server replies to the client with an &lt;code&gt;io_reply&lt;/code&gt; tuple, where element &lt;code&gt;Reply&lt;/code&gt; is one of:</source>
          <target state="translated">I / Oサーバーはクライアントに &lt;code&gt;io_reply&lt;/code&gt; タプルで応答します。ここで、要素 &lt;code&gt;Reply&lt;/code&gt; は次のいずれかです。</target>
        </trans-unit>
        <trans-unit id="d6984e80e5ec40501eed04b79f0e90cd3e1a039b" translate="yes" xml:space="preserve">
          <source>The I/O server replies:</source>
          <target state="translated">I/Oサーバが応答します。</target>
        </trans-unit>
        <trans-unit id="615c499b56501d6b2d674044444c5cd252a3aa4d" translate="yes" xml:space="preserve">
          <source>The I/O vector used by the emulator and drivers is a list of binaries, with a &lt;code&gt;SysIOVec&lt;/code&gt; pointing to the buffers of the binaries. It is used in &lt;code&gt;driver_outputv&lt;/code&gt; and the &lt;code&gt;&lt;a href=&quot;driver_entry#outputv&quot;&gt;outputv&lt;/a&gt;&lt;/code&gt; driver callback. Also, the driver queue is an &lt;code&gt;ErlIOVec&lt;/code&gt;.</source>
          <target state="translated">エミュレーターとドライバーが使用するI / Oベクトルはバイナリーのリストであり、 &lt;code&gt;SysIOVec&lt;/code&gt; はバイナリーのバッファーを指します。これは、 &lt;code&gt;driver_outputv&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;driver_entry#outputv&quot;&gt;outputv&lt;/a&gt;&lt;/code&gt; ドライバーコールバックで使用されます。また、ドライバーキューは &lt;code&gt;ErlIOVec&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="11486f73702f77793d0c501dded54bd9d9a0b366" translate="yes" xml:space="preserve">
          <source>The ID of the handler (which is &lt;code&gt;false&lt;/code&gt; if it was registered without an ID).</source>
          <target state="translated">ハンドラーのID（IDなしで登録された場合は &lt;code&gt;false&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="5910e0f627e6ac1682f658faee394e4ef0132c80" translate="yes" xml:space="preserve">
          <source>The IDs contains normal fully qualified domain names like e.g &lt;code&gt;foo.example.com&lt;/code&gt;, but IP addresses are not recommended. The rfc describes why this is not recommended as well as security considerations about how to aquire the Reference IDs.</source>
          <target state="translated">IDには &lt;code&gt;foo.example.com&lt;/code&gt; などの通常の完全修飾ドメイン名が含まれますが、IPアドレスは推奨されません。rfcには、これが推奨されない理由と、参照IDを取得する方法に関するセキュリティ上の考慮事項が記載されています。</target>
        </trans-unit>
        <trans-unit id="b28f4dac9c4ee5d63c861a672e8fdeba64970c63" translate="yes" xml:space="preserve">
          <source>The IP addresses must be specified in the standard form (four decimal numbers separated by periods, for example, &lt;code&gt;&quot;150.236.20.74&quot;&lt;/code&gt;. Hosts names are not acceptable, but a broadcast address (preferably limited to the local network) is.</source>
          <target state="translated">IPアドレスは標準形式で指定する必要があります（ピリオドで区切られた4つの10進数、たとえば &lt;code&gt;&quot;150.236.20.74&quot;&lt;/code&gt; )。ホスト名は受け入れられませんが、ブロードキャストアドレス（ローカルネットワークに限定されることが望ましい）は受け入れられます。</target>
        </trans-unit>
        <trans-unit id="74be3487335549a3ba00af3a4220139041a986e4" translate="yes" xml:space="preserve">
          <source>The Inets services API.</source>
          <target state="translated">InetsサービスのAPIです。</target>
        </trans-unit>
        <trans-unit id="2bd655ea5793b54cfcef1365f007ad296dab65da" translate="yes" xml:space="preserve">
          <source>The Interpret Modules window is used for selecting which modules to interpret. Initially, the window displays the modules (&lt;code&gt;erl&lt;/code&gt; files) and subdirectories of the current working directory.</source>
          <target state="translated">「モジュールの解釈」ウィンドウは、解釈するモジュールを選択するために使用されます。最初に、ウィンドウには現在の作業ディレクトリのモジュール（ &lt;code&gt;erl&lt;/code&gt; ファイル）とサブディレクトリが表示されます。</target>
        </trans-unit>
        <trans-unit id="46568e5f2d41b68efc3d2efed445ca9d877dd874" translate="yes" xml:space="preserve">
          <source>The Kernel application has all the code necessary to run the Erlang runtime system: file servers, code servers, and so on.</source>
          <target state="translated">カーネルアプリケーションはErlangランタイムシステムを実行するのに必要なすべてのコードを持っています:ファイルサーバ、コードサーバなど。</target>
        </trans-unit>
        <trans-unit id="1d2901750e4e178866aa29af00b9514d934b8cb3" translate="yes" xml:space="preserve">
          <source>The Kernel application is the first application started. It is mandatory in the sense that the minimal system based on Erlang/OTP consists of Kernel and STDLIB. Kernel contains the following functional areas:</source>
          <target state="translated">Kernelアプリケーションは最初に起動するアプリケーションです。Erlang/OTPベースのミニマルシステムはKernelとSTDLIBで構成されているという意味で必須です。Kernelには以下の機能領域が含まれています。</target>
        </trans-unit>
        <trans-unit id="393233a88750cf4fe6f8a18919929901cb57f040" translate="yes" xml:space="preserve">
          <source>The Kernel configuration parameter &lt;code&gt;global_groups&lt;/code&gt; defines the global groups (see also &lt;code&gt;kernel(6)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;config&quot;&gt;config(4)&lt;/a&gt;&lt;/code&gt;):</source>
          <target state="translated">カーネル構成パラメーター &lt;code&gt;global_groups&lt;/code&gt; は、グローバルグループを定義し &lt;code&gt;kernel(6)&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;config&quot;&gt;config(4)&lt;/a&gt;&lt;/code&gt; も参照）。</target>
        </trans-unit>
        <trans-unit id="329d0e8d9e7fbac7a43bba657580181c6f878afc" translate="yes" xml:space="preserve">
          <source>The Kernel/STDLIB applications are damaged or the start script is damaged.</source>
          <target state="translated">Kernel/STDLIBアプリケーションが破損しているか、スタートスクリプトが破損しています。</target>
        </trans-unit>
        <trans-unit id="ce538f925bf84002c38fbd4dc502029a22341ac9" translate="yes" xml:space="preserve">
          <source>The Leex module should be considered experimental as it will be subject to changes in future releases.</source>
          <target state="translated">Leexモジュールは将来のリリースで変更される可能性があるため、実験的なものと考えてください。</target>
        </trans-unit>
        <trans-unit id="c848076de058785ede6b2e785124e2cf00899a54" translate="yes" xml:space="preserve">
          <source>The Linux Trace Toolkit: next generation is an open source system software package for correlated tracing of the Linux kernel, user applications and libraries.</source>
          <target state="translated">Linux Trace Toolkit:next generationは、Linuxカーネル、ユーザアプリケーション、ライブラリの相関トレースを行うためのオープンソースのシステムソフトウェアパッケージです。</target>
        </trans-unit>
        <trans-unit id="9b5f802a372a8d9f81e47da8ffe942e03e117399" translate="yes" xml:space="preserve">
          <source>The Logger backend forwards log events from the API, first through a set of &lt;strong&gt;primary filters&lt;/strong&gt;, then through a set of secondary filters attached to each log handler. The secondary filters are in the following named &lt;strong&gt;handler filters&lt;/strong&gt;.</source>
          <target state="translated">ロガーバックエンドは、APIからログイベントを転送します。最初に一連の&lt;strong&gt;プライマリフィルター&lt;/strong&gt;を介して、次に各ログハンドラーに接続されている一連のセカンダリフィルターを介して転送します。セカンダリフィルターは、次の名前付き&lt;strong&gt;ハンドラーフィルターにあり&lt;/strong&gt;ます。</target>
        </trans-unit>
        <trans-unit id="709c2b894a55cf0a9eb1d8fa9b54a57e464ba3b7" translate="yes" xml:space="preserve">
          <source>The M-bit on a component AVP of a Grouped AVP that does not set M is ignored: such AVPs are not regarded as erroneous at decode.</source>
          <target state="translated">M が設定されていないグループ化 AVP のコンポーネント AVP の M ビットは無視されます。</target>
        </trans-unit>
        <trans-unit id="6e65c3cb49c60d682bd3249d0c0dd54ec5a5739f" translate="yes" xml:space="preserve">
          <source>The MD5 Message-Digest Algorithm is &lt;strong&gt;not&lt;/strong&gt; considered safe for code-signing or software-integrity purposes.</source>
          <target state="translated">MD5メッセージダイジェストアルゴリズムは、コード署名やソフトウェア整合性の目的では安全と&lt;strong&gt;は&lt;/strong&gt;見なされ&lt;strong&gt;ません&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="f776c349863aa954c934ed6333465e82a978b325" translate="yes" xml:space="preserve">
          <source>The MFA alternative makes it possible for Megaco to start and supervise a scanner written by the user (see &lt;code&gt;supervisor:start_child&lt;/code&gt; for an explanation of the parameters).</source>
          <target state="translated">MFAの代替案を使用すると、Megacoはユーザーが作成したスキャナーを起動して監視できます（パラメーターの説明については、 &lt;code&gt;supervisor:start_child&lt;/code&gt; を参照してください）。</target>
        </trans-unit>
        <trans-unit id="1def19a97ae2b0656b00af132fb7f372cb973f9f" translate="yes" xml:space="preserve">
          <source>The MG may explicitly invoke megaco:connect/4 and use a provisioned MID of the MGC as the RemoteMid.</source>
          <target state="translated">MG は明示的に megaco:connect/4 を呼び出し、MGC のプロビジョニングされた MID を RemoteMid として使用することができます。</target>
        </trans-unit>
        <trans-unit id="d9b9106067cc9059d7c61d3ebb7b2686b953f307" translate="yes" xml:space="preserve">
          <source>The MG may explicitly invoke megaco:connect/4 with the atom 'preliminary_mid' as a temporary MID of the MGC, send an intial message, the Service Change Request, to the MGC and then wait for an initial message, the Service Change Reply. When the reply arrives, the Megaco application will pick the MID of the MGC from the message header and automatically upgrade the connection to be a &quot;normal&quot; connection. By using this method of establishing the connection, the callback function UserMod:handle_connect/2 to be invoked twice. First with a ConnHandle with the remote_mid-field set to preliminary_mid, and then when the connection upgrade is done with the remote_mid-field set to the actual MID of the MGC.</source>
          <target state="translated">MGC は、MGC の一時的な MID として、megaco:connect/4 を明示的に呼び出し、初期メッセージである Service Change Request を MGC に送信し、初期メッセージである Service Change Reply を待つことができます。返信が到着すると、MegacoアプリケーションはメッセージヘッダからMGCのMIDをピックアップし、自動的に「通常の」接続にアップグレードします。この方法で接続を確立することで、コールバック関数UserMod:handle_connect/2を2回呼び出すことができます。最初は、connHandle で remote_mid-field を preliminary_mid に設定し、次に接続のアップグレードが行われたときに remote_mid-field を MGC の実際の MID に設定します。</target>
        </trans-unit>
        <trans-unit id="aea17cec43c433cc7d5df78c11e5155adf50c978" translate="yes" xml:space="preserve">
          <source>The MIB compiler can be invoked from the OS command line by using the command &lt;code&gt;erlc&lt;/code&gt;. &lt;code&gt;erlc&lt;/code&gt; recognizes the extension &lt;code&gt;.mib&lt;/code&gt;, and invokes the SNMP MIB compiler for files with that extension. The options &lt;code&gt;db&lt;/code&gt;, &lt;code&gt;group_check&lt;/code&gt;, &lt;code&gt;deprecated&lt;/code&gt;, &lt;code&gt;description&lt;/code&gt;, &lt;code&gt;verbosity&lt;/code&gt;, &lt;code&gt;imports&lt;/code&gt; and &lt;code&gt;module_identity&lt;/code&gt; have to be specified to &lt;code&gt;erlc&lt;/code&gt; using the syntax &lt;code&gt;+term&lt;/code&gt;. See &lt;code&gt;erlc(1)&lt;/code&gt; for details.</source>
          <target state="translated">MIBコンパイラーは、コマンド &lt;code&gt;erlc&lt;/code&gt; を使用して、OSコマンド行から呼び出すことができます。 &lt;code&gt;erlc&lt;/code&gt; は拡張子.mibを認識し、その拡張子を &lt;code&gt;.mib&lt;/code&gt; ファイルのSNMP MIBコンパイラーを呼び出します。オプション &lt;code&gt;db&lt;/code&gt; 、 &lt;code&gt;group_check&lt;/code&gt; 、 &lt;code&gt;deprecated&lt;/code&gt; 、 &lt;code&gt;description&lt;/code&gt; 、 &lt;code&gt;verbosity&lt;/code&gt; 、 &lt;code&gt;imports&lt;/code&gt; および &lt;code&gt;module_identity&lt;/code&gt; は、構文 &lt;code&gt;+term&lt;/code&gt; を使用して &lt;code&gt;erlc&lt;/code&gt; に指定する必要があります。詳細については、 &lt;code&gt;erlc(1)&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="f4f52d6224012981f65b2f6681c14c8ab8b0bbf8" translate="yes" xml:space="preserve">
          <source>The MIB compiler is started with a call to &lt;code&gt;snmpc:compile(&amp;lt;mibname&amp;gt;).&lt;/code&gt; For example:</source>
          <target state="translated">MIBコンパイラは、 &lt;code&gt;snmpc:compile(&amp;lt;mibname&amp;gt;).&lt;/code&gt; 呼び出しで開始されます。例えば：</target>
        </trans-unit>
        <trans-unit id="edd06159b7a6aba946136da4c7e4c2496fb5f976" translate="yes" xml:space="preserve">
          <source>The MIB compiler understands both SMIv1 and SMIv2 MIBs. It uses the &lt;code&gt;MODULE-IDENTITY&lt;/code&gt; statement to determine if the MIB is version 1 or 2.</source>
          <target state="translated">MIBコンパイラは、SMIv1とSMIv2の両方のMIBを理解します。これは、使用しています &lt;code&gt;MODULE-IDENTITY&lt;/code&gt; の MIBは、バージョン1または2であるかどうかを判断するためのステートメントを。</target>
        </trans-unit>
        <trans-unit id="f45016e5e003d17ae323b899458860dc734f4ec3" translate="yes" xml:space="preserve">
          <source>The MIB compiler understands both SMIv1 and SMIv2 MIBs. It uses the MODULE-IDENTITY statement to determinate if the MIB is written in SMI version 1 or 2.</source>
          <target state="translated">MIB コンパイラは SMIv1 と SMIv2 の両方の MIB を理解します。それはMODULE-IDENTITY文を使用して、MIBがSMIバージョン1か2で書かれているかどうかを判断します。</target>
        </trans-unit>
        <trans-unit id="cd9d36a4d02e1cba5060187b622d24d58daaa77e" translate="yes" xml:space="preserve">
          <source>The MIB definition for the table looks as follows:</source>
          <target state="translated">テーブルのMIB定義は以下のようになります。</target>
        </trans-unit>
        <trans-unit id="3670a31f68beb5c49cf1fc0895f0360e583892d6" translate="yes" xml:space="preserve">
          <source>The MIB is specified in an adapted subset of the Abstract Syntax Notation One (ASN.1) language. This adapted subset is called the Structure of Management Information (SMI).</source>
          <target state="translated">MIB は、抽象構文表記法 1 (ASN.1)言語の適応サブセットで指定される。この適応されたサブセットは、管理情報の構造(SMI)と呼ばれる。</target>
        </trans-unit>
        <trans-unit id="ddf38993bb21f6943082354919313abcba92be9e" translate="yes" xml:space="preserve">
          <source>The MIB must be written as a text file in SMIv1 or SMIv2 using an ASN.1 notation before it will be compiled. This text file must have the same name as the MIB, but with the suffix &lt;code&gt;.mib&lt;/code&gt;. This is necessary for handling the &lt;code&gt;IMPORT&lt;/code&gt; statement.</source>
          <target state="translated">MIBは、コンパイルする前に、ASN.1表記を使用してSMIv1またはSMIv2でテキストファイルとして書き込む必要があります。このテキストファイルは、MIBと同じ名前である必要がありますが、サフィックス &lt;code&gt;.mib&lt;/code&gt; が付いています。これは、 &lt;code&gt;IMPORT&lt;/code&gt; ステートメントを処理するために必要です。</target>
        </trans-unit>
        <trans-unit id="28b5820bae2b823215328a884121f24cdebd6ac9" translate="yes" xml:space="preserve">
          <source>The MIB table shown in the previous section can be compiled as follows:</source>
          <target state="translated">前項で示したMIBテーブルは、以下のようにコンパイルすることができます。</target>
        </trans-unit>
        <trans-unit id="8ec9b6855efdcd50624fb2152240f9d6cfd37b82" translate="yes" xml:space="preserve">
          <source>The MIB used in this example is called EX1-MIB. It contains two objects, a variable with a name and a table with friends.</source>
          <target state="translated">この例で使用しているMIBはEX1-MIBと呼ばれています。これには、名前のついた変数と、友達のいるテーブルの2つのオブジェクトが含まれています。</target>
        </trans-unit>
        <trans-unit id="e2036f385fe7aec6b74107075c06d9fb946e725a" translate="yes" xml:space="preserve">
          <source>The Makefile rule generated by this option looks as follows:</source>
          <target state="translated">このオプションで生成されるMakefileルールは以下のようになります。</target>
        </trans-unit>
        <trans-unit id="b70e5f8f89b4686cb29a4a908b91ac8e282aa8a9" translate="yes" xml:space="preserve">
          <source>The Manager sends a request to the Agent.</source>
          <target state="translated">マネージャーはエージェントにリクエストを送信します。</target>
        </trans-unit>
        <trans-unit id="46da3a78459a2791fe81dd4c8585eaa2e4cc0ded" translate="yes" xml:space="preserve">
          <source>The Master Agent decodes the incoming UDP packet.</source>
          <target state="translated">マスターエージェントは、受信UDPパケットをデコードします。</target>
        </trans-unit>
        <trans-unit id="373ff796c178ffe0a9fc192a5614c9c2aa28127a" translate="yes" xml:space="preserve">
          <source>The Master Agent determines which items in the request that should be processed here and which items should be forwarded to its subagent.</source>
          <target state="translated">マスターエージェントは、ここで処理すべきリクエストのどの項目を、そのサブエージェントに転送すべきかを決定します。</target>
        </trans-unit>
        <trans-unit id="efae611f18882de954fb6f64727d8f6c45904beb" translate="yes" xml:space="preserve">
          <source>The Megaco client (user) starts the flex scanner (load the driver).</source>
          <target state="translated">メガコクライアント(ユーザー)がフレックススキャナを起動(ドライバをロード)します。</target>
        </trans-unit>
        <trans-unit id="74b78735e0be983743300743d7f123f781d14b1d" translate="yes" xml:space="preserve">
          <source>The Megaco mib is as of yet not standardized and our implementation is based on &lt;strong&gt;draft-ietf-megaco-mib-04.txt&lt;/strong&gt;. Almost all of the mib cannot easily be implemented by the megaco application. Instead these things should be implemented by a user (of the megaco application).</source>
          <target state="translated">Megaco mibは&lt;strong&gt;現時点&lt;/strong&gt;ではまだ標準化されておらず、私たちの実装は&lt;strong&gt;draft-ietf-megaco-mib-04.txtに基づいてい&lt;/strong&gt;ます。ほとんどすべてのmibは、megacoアプリケーションで簡単に実装することはできません。代わりに、これらはmegacoアプリケーションのユーザーが実装する必要があります。</target>
        </trans-unit>
        <trans-unit id="69ce7f3a78e528729b8eeea0590643ad39f48cc1" translate="yes" xml:space="preserve">
          <source>The Megaco/H.248 application contains implementations for the two protocols specified by the Megaco/H.248 standard; UDP, see &lt;code&gt;&lt;a href=&quot;megaco_udp&quot;&gt;megaco_udp&lt;/a&gt;&lt;/code&gt;, and TCP/TPKT, see &lt;code&gt;&lt;a href=&quot;megaco_tcp&quot;&gt;megaco_tcp&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Megaco / H.248アプリケーションには、Megaco / H.248標準で指定された2つのプロトコルの実装が含まれています。UDP、参照 &lt;code&gt;&lt;a href=&quot;megaco_udp&quot;&gt;megaco_udp&lt;/a&gt;&lt;/code&gt; を、およびTCP / TPKTは、参照 &lt;code&gt;&lt;a href=&quot;megaco_tcp&quot;&gt;megaco_tcp&lt;/a&gt;&lt;/code&gt; を。</target>
        </trans-unit>
        <trans-unit id="aad987e822802dc01bf9dc22e5bb8ea6068aa667" translate="yes" xml:space="preserve">
          <source>The Megaco/H.248 standard defines both a plain text encoding and a binary encoding (ASN.1 BER) and we have implemented encoders and decoders for both. We do in fact supply five different encoding/decoding modules.</source>
          <target state="translated">Megaco/H.248 規格では、プレーンテキストエンコーディングとバイナリエンコーディング(ASN.1 BER)の両方が定義されており、当社では両方のエンコーダーとデコーダーを実装しています。実際に5種類のエンコーディング/デコーディングモジュールを提供しています。</target>
        </trans-unit>
        <trans-unit id="aa06303bf449e60941f0fbd6f5db8a0257dfe140" translate="yes" xml:space="preserve">
          <source>The Megaco/H.248 standard defines both a plain text encoding and a binary encoding (ASN.1 BER) and we have implemented encoders and decoders for both. We do supply a bunch of different encoding/decoding modules and the user may in fact implement their own (like our erl_dist module). Using a non-standard encoding format has its obvious drawbacks, but may be useful in some configurations.</source>
          <target state="translated">Megaco/H.248 規格では、プレーンテキストエンコーディングとバイナリエンコーディング (ASN.1 BER)の両方が定義されており、我々は両方のエンコーディングとデコーダを実装しています。我々は多くの異なるエンコーディング/デコーディングモジュールを提供していますが、 実際にはユーザが独自に実装することもできます (erl_dist モジュールのように)。非標準のエンコーディングフォーマットを使うことには明らかな欠点がありますが、 いくつかの設定では有用かもしれません。</target>
        </trans-unit>
        <trans-unit id="1180df526f481dbe5f0436fa1406c56c4711af67" translate="yes" xml:space="preserve">
          <source>The Mnesia DBMS can be used for storing data of SNMP tables. This means that an SNMP table can be implemented as a Mnesia table, and that a Mnesia table can be made visible via SNMP. This mapping is largely automated.</source>
          <target state="translated">Mnesia DBMSは、SNMPテーブルのデータを格納するために使用することができます。つまり、SNMPテーブルをMnesiaテーブルとして実装し、SNMP経由でMnesiaテーブルを可視化することができます。このマッピングはほぼ自動化されています。</target>
        </trans-unit>
        <trans-unit id="a591b496e3da82473b635cc4b898494993b158a0" translate="yes" xml:space="preserve">
          <source>The Mnesia algorithm for table load can lead to a situation where a table cannot be loaded. This situation occurs when a node is started and Mnesia concludes, or suspects, that another copy of the table was active after this local copy became inactive because of a system crash.</source>
          <target state="translated">テーブルロードのためのMnesiaアルゴリズムは、テーブルをロードできない状況を引き起こす可能性があります。この状況は、ノードが起動され、システムクラッシュによりローカルコピーが非アクティブになった後、テーブルの別のコピーがアクティブになったとMnesiaが結論づけた場合、またはその疑いがある場合に発生します。</target>
        </trans-unit>
        <trans-unit id="5e84c0c6719410c924b39a7531b144a0635ce33f" translate="yes" xml:space="preserve">
          <source>The Mnesia application provides a heavy duty real-time distributed database.</source>
          <target state="translated">Mnesiaアプリケーションは、ヘビーデューティーなリアルタイム分散データベースを提供します。</target>
        </trans-unit>
        <trans-unit id="4e31cb2dccdf565dc1ca8c735031043aeea8bc8e" translate="yes" xml:space="preserve">
          <source>The Mnesia directory is to be set to &lt;code&gt;M&lt;/code&gt;.</source>
          <target state="translated">Mnesiaディレクトリーは &lt;code&gt;M&lt;/code&gt; に設定されます。</target>
        </trans-unit>
        <trans-unit id="87981337ff090edb8a09d20ade88cd56c81fc2fc" translate="yes" xml:space="preserve">
          <source>The Mnesia tables can be manipulated without using transactions. This has some serious disadvantages, but is considerably faster, as the transaction manager is not involved and no locks are set. A dirty operation does, however, guarantee a certain level of consistency, and the dirty operations cannot return garbled records. All dirty operations provide location transparency to the programmer, and a program does not have to be aware of the whereabouts of a certain table to function.</source>
          <target state="translated">Mnesiaのテーブルは、トランザクションを使用せずに操作することができます。これにはいくつかの深刻な欠点がありますが、トランザクションマネージャが関与しておらず、ロックも設定されていないため、かなり高速です。しかし、ダーティ操作は一定レベルの一貫性を保証し、ダーティ操作は文字化けしたレコードを返すことはできません。すべてのダーティ操作はプログラマに位置の透過性を提供し、プログラムは機能するために特定のテーブルの位置を意識する必要はありません。</target>
        </trans-unit>
        <trans-unit id="12555ca4fb4e5c73fcfb7a6b579630e086477989" translate="yes" xml:space="preserve">
          <source>The Module, Function and/or Arity parts of the tuple may be specified as the atom &lt;code&gt;'_'&lt;/code&gt; which is a &quot;wild-card&quot; matching all modules/functions/arities. Note, if the Module is specified as &lt;code&gt;'_'&lt;/code&gt;, the Function and Arity parts have to be specified as '_' too. The same holds for the Functions relation to the Arity.</source>
          <target state="translated">タプルのモジュール、関数、および/またはアリティの部分は、すべてのモジュール/関数/アリティに一致する「ワイルドカード」であるアトム &lt;code&gt;'_'&lt;/code&gt; として指定できます。モジュールが &lt;code&gt;'_'&lt;/code&gt; として指定されている場合、関数とアリティの部分も '_'として指定する必要があることに注意してください。アリティとの関数の関係についても同様です。</target>
        </trans-unit>
        <trans-unit id="f0af3d5917bbe134a6abcdbbf9104dc4ecd4c736" translate="yes" xml:space="preserve">
          <source>The Monitor window is the main window of Debugger and displays the following:</source>
          <target state="translated">モニタウィンドウはデバッガのメインウィンドウで、以下のように表示されます。</target>
        </trans-unit>
        <trans-unit id="70b4cea5e362ae717c1192bf6736623910297884" translate="yes" xml:space="preserve">
          <source>The NETCONF client is also compliant with RFC 5277 NETCONF Event Notifications, which defines a mechanism for an asynchronous message notification delivery service for the NETCONF protocol.</source>
          <target state="translated">NETCONF クライアントは、NETCONF プロトコルの非同期メッセージ通知配信サービスのメカニズムを定義する RFC 5277 NETCONF Event Notifications にも準拠しています。</target>
        </trans-unit>
        <trans-unit id="99b3461576af86b2830e124486fcb6fbe5704dd5" translate="yes" xml:space="preserve">
          <source>The NETCONF client is compliant with RFC 4741 NETCONF Configuration Protocol and RFC 4742 Using the NETCONF Configuration Protocol over Secure SHell (SSH).</source>
          <target state="translated">NETCONF クライアントは、RFC 4741 NETCONF Configuration Protocol および RFC 4742 Using NETCONF Configuration Protocol over Secure SHell (SSH)に準拠しています。</target>
        </trans-unit>
        <trans-unit id="ddf8604513f6b03eececb0b12edf6062d8892eb4" translate="yes" xml:space="preserve">
          <source>The NETCONF server uses &lt;code&gt;error_logger&lt;/code&gt; for logging of NETCONF traffic. A special purpose error handler is implemented in &lt;code&gt;ct_conn_log_h&lt;/code&gt;. To use this error handler, add the &lt;code&gt;cth_conn_log&lt;/code&gt; hook in the test suite, for example:</source>
          <target state="translated">NETCONFサーバーは、NETCONFトラフィックのロギングに &lt;code&gt;error_logger&lt;/code&gt; を使用します。 &lt;code&gt;ct_conn_log_h&lt;/code&gt; には、特別な目的のエラーハンドラが実装されています。このエラーハンドラーを使用するには、テストスイートに &lt;code&gt;cth_conn_log&lt;/code&gt; フックを追加します。次に例を示します。</target>
        </trans-unit>
        <trans-unit id="2d107278e1a70d51b4fdd7f40141f0fe34ee6756" translate="yes" xml:space="preserve">
          <source>The NIF library must be explicitly loaded by Erlang code in the same module.</source>
          <target state="translated">NIFライブラリは同じモジュールのErlangコードから明示的にロードされなければなりません。</target>
        </trans-unit>
        <trans-unit id="41a4ad2b0dc5ffd6f13eaa47aa861d15ed3c8d0c" translate="yes" xml:space="preserve">
          <source>The NIFs of the module are compiled and linked into a shared library. Each NIF is implemented as a normal C function. The macro &lt;code&gt;ERL_NIF_INIT&lt;/code&gt; together with an array of structures defines the names, arity, and function pointers of all the NIFs in the module. The header file &lt;code&gt;erl_nif.h&lt;/code&gt; must be included. As the library is a shared module, not a program, no main function is to be present.</source>
          <target state="translated">モジュールのNIFがコンパイルされ、共有ライブラリにリンクされます。各NIFは通常のC関数として実装されます。マクロ &lt;code&gt;ERL_NIF_INIT&lt;/code&gt; と構造体の配列は、モジュール内のすべてのNIFの名前、アリティ、および関数ポインターを定義します。ヘッダーファイル &lt;code&gt;erl_nif.h&lt;/code&gt; をインクルードする必要があります。ライブラリはプログラムではなく共有モジュールであるため、メイン関数は存在しません。</target>
        </trans-unit>
        <trans-unit id="fd402b6f90d216badbbd85762e2a8ddff6c71c0f" translate="yes" xml:space="preserve">
          <source>The Network Interface (Net if) process delivers SNMP PDUs to a master agent, and receives SNMP PDUs from the master agent. The most common behaviour of a Net if process is that is receives bytes from a network, decodes them into an SNMP PDU, which it sends to a master agent. When the master agent has processed the PDU, it sends a response PDU to the Net if process, which encodes the PDU into bytes and transmits the bytes onto the network.</source>
          <target state="translated">ネットワークインターフェース(Net if)プロセスは、SNMP PDUをマスターエージェントに配信し、マスターエージェントからSNMP PDUを受信します。Net if プロセスの最も一般的な動作は、ネットワークからバイトを受信し、それを SNMP PDU にデコードしてマスターエージェントに送信することです。マスターエージェントがPDUを処理すると、レスポンスPDUをNet ifプロセスに送信します。</target>
        </trans-unit>
        <trans-unit id="976e6c5625eb166a7240dd083a2239c03ac8b8ec" translate="yes" xml:space="preserve">
          <source>The Network Interface (Net if) process delivers SNMP PDUs to the manager server, and receives SNMP PDUs from the manager server. The most common behaviour of a Net if process is that is receives request PDU from the manager server, encodes the PDU into bytes and transmits the bytes onto the network to an agent. When the reply from the agent is received by the Net if process, which it decodes into an SNMP PDU, which it sends to the manager server.</source>
          <target state="translated">ネットワークインターフェース(Net if)プロセスは、SNMP PDUをマネージャサーバに配信し、マネージャサーバからSNMP PDUを受信します。Net ifプロセスの最も一般的な動作は、マネージャサーバから要求PDUを受信し、PDUをバイトにエンコードし、そのバイトをネットワーク上のエージェントに送信することです。エージェントからの応答を Net if プロセスが受信すると、その応答は SNMP PDU にデコードされ、マネージャサーバに送信されます。</target>
        </trans-unit>
        <trans-unit id="e3ad1933c4b353741e7d3dd411a4625d945e51b1" translate="yes" xml:space="preserve">
          <source>The OAM components, and some other OTP applications, define SNMP MIBs. These MIBs are written in SNMPv2 SMI syntax, as defined in RFC 1902. For convenience we also deliver the SNMPv1 SMI equivalent. All MIBs are designed to be v1/v2 compatible, that is, the v2 MIBs do not use any construct not available in v1.</source>
          <target state="translated">OAMコンポーネントと他のいくつかのOTPアプリケーションは、SNMP MIBを定義します。これらのMIBは、RFC 1902で定義されているように、SNMPv2 SMI構文で書かれています。利便性のために、SNMPv1 SMIと同等のものも提供しています。すべてのMIBはv1/v2互換であるように設計されており、v2 MIBではv1で利用できない構成を使用しません。</target>
        </trans-unit>
        <trans-unit id="dfa71a1f0f4b6ee0f7da7bee6b28148c4530dbc7" translate="yes" xml:space="preserve">
          <source>The OS failed to load the NIF library.</source>
          <target state="translated">OSがNIFライブラリのロードに失敗しました。</target>
        </trans-unit>
        <trans-unit id="6c43c2d0328ac7bd67f0bc31e296a2b1639ba6e7" translate="yes" xml:space="preserve">
          <source>The OTP mibs are stored in the &lt;code&gt;$OTP_ROOT/lib/otp_mibs/mibs/&lt;/code&gt; directory. They are defined in SNMPv2 SMI syntax. An SNMPv1 version of the mib is delivered in the &lt;code&gt;mibs/v1&lt;/code&gt; directory. The compiled MIB is located under &lt;code&gt;priv/mibs&lt;/code&gt;, and the generated &lt;code&gt;.hrl&lt;/code&gt; file under the &lt;code&gt;include&lt;/code&gt; directory. To compile a MIB that IMPORTS a MIB in the OTP_Mibs application, give the option &lt;code&gt;{il, [&quot;otp_mibs/priv/mibs&quot;]}&lt;/code&gt; to the MIB compiler.</source>
          <target state="translated">OTP &lt;code&gt;$OTP_ROOT/lib/otp_mibs/mibs/&lt;/code&gt; は$ OTP_ROOT / lib / otp_mibs / mibs /ディレクトリに保存されています。これらはSNMPv2 SMI構文で定義されています。 &lt;code&gt;mibs/v1&lt;/code&gt; のSNMPv1バージョンは、mibs / v1ディレクトリで提供されます。コンパイルされたMIBは &lt;code&gt;priv/mibs&lt;/code&gt; &lt;code&gt;.hrl&lt;/code&gt; 下にあり、生成された.hrlファイルは &lt;code&gt;include&lt;/code&gt; ディレクトリの下にあります。OTP_MibsアプリケーションでMIBをインポートするMIBをコンパイルするには、MIBコンパイラにオプション &lt;code&gt;{il, [&quot;otp_mibs/priv/mibs&quot;]}&lt;/code&gt; を指定します。</target>
        </trans-unit>
        <trans-unit id="ef0289a2a348b65c119233c8ade03f223f5c8802" translate="yes" xml:space="preserve">
          <source>The OTP release that the currently executing ERTS application is part of, as an integer. For details, see &lt;code&gt;erlang:system_info(otp_release)&lt;/code&gt;. This macro was introduced in OTP release 21.</source>
          <target state="translated">現在実行中のERTSアプリケーションが含まれているOTPリリース（整数）。詳細については、 &lt;code&gt;erlang:system_info(otp_release)&lt;/code&gt; を参照してください。このマクロはOTPリリース21で導入されました。</target>
        </trans-unit>
        <trans-unit id="16e1639b18798e91125ecf1f057060589779b23c" translate="yes" xml:space="preserve">
          <source>The OTP-MIB mib represents information about Erlang nodes such as node name, number of running processes, virtual machine version etc. If the MIB should be used in a system, it should be loaded into an SNMP agent by using the API function &lt;code&gt;otp_mib:load/1&lt;/code&gt;.</source>
          <target state="translated">OTP-MIB mibは、ノード名、実行中のプロセスの数、仮想マシンのバージョンなど、Erlangノードに関する情報を表します &lt;code&gt;otp_mib:load/1&lt;/code&gt; をシステムで使用する必要がある場合は、API関数otp_mibを使用してSNMPエージェントにロードする必要があります。 load / 1。</target>
        </trans-unit>
        <trans-unit id="1d079c6127c093fd0bf885dc8ec3e524eee2389b" translate="yes" xml:space="preserve">
          <source>The OTP-REG mib defines the unique OTP subtree of object identifiers under the Ericsson subtree. Under the OTP subtree several object identifiers are defined. This module is typically included by OTP applications defining their own mibs, or ASN.1 modules in general, that require unique object identifiers under the OTP subtree.</source>
          <target state="translated">OTP-REG mib は、Ericsson サブツリーの下にあるオブジェクト識別子の固有の OTP サブツリーを定義します。OTP サブツリーの下には、いくつかのオブジェクト識別子が定義されています。このモジュールは通常、独自の mib を定義する OTP アプリケーションや、一般的に ASN.1 モジュールに含まれ、OTP サブツリーの下で一意のオブジェクト識別子を必要とする場合に使用されます。</target>
        </trans-unit>
        <trans-unit id="7e4e2e6abc0df4b67e259520ad92410685d1db8d" translate="yes" xml:space="preserve">
          <source>The OTP-SNMPEA-MIB was used in earlier versions of the agent, before standard MIBs existed for access control, MIB views, and trap target specification. All objects in this MIB are now obsolete.</source>
          <target state="translated">OTP-SNMPEA-MIBは、アクセス制御、MIBビュー、およびトラップターゲット指定のための標準MIBが存在する前の、エージェントの以前のバージョンで使用されていました。このMIB内のすべてのオブジェクトは現在では廃止されています。</target>
        </trans-unit>
        <trans-unit id="dfdf456ec73d4195574c470386dbc5ef95b5e4be" translate="yes" xml:space="preserve">
          <source>The OTP-TC mib provides the textual convention datatype &lt;code&gt;OwnerString&lt;/code&gt;.</source>
          <target state="translated">OTP-TC mibは、テキスト表記のデータ型 &lt;code&gt;OwnerString&lt;/code&gt; を提供します。</target>
        </trans-unit>
        <trans-unit id="370c0fa4230350b45a2bed8b159298418299327c" translate="yes" xml:space="preserve">
          <source>The Observer application is a container including the following tools for tracing and investigation of distributed systems:</source>
          <target state="translated">Observerアプリケーションは、分散システムのトレースや調査のための以下のツールを含むコンテナです。</target>
        </trans-unit>
        <trans-unit id="e53532ab978b0a1e5f72db0836d60dcb2627de7d" translate="yes" xml:space="preserve">
          <source>The Observer application is available on the trace control node.</source>
          <target state="translated">Observer アプリケーションはトレース制御ノードで利用できます。</target>
        </trans-unit>
        <trans-unit id="acca74abfba6c1293f4de6924079a0d77446f3db" translate="yes" xml:space="preserve">
          <source>The Observer application might not always be available on the node to be traced (in the following called the &quot;traced node&quot;). However, Trace Tool Builder can still be run from another node (in the following called the &quot;trace control node&quot;) as long as the following is fulfilled:</source>
          <target state="translated">Observerアプリケーションは、トレースするノード(以下では「トレースされたノード」と呼ぶ)上で利用できるとは限りません。しかし、トレースツールビルダは、以下の条件を満たしていれば、別のノード(以下では「トレース制御ノード」と呼ぶ)からでも実行することができます。</target>
        </trans-unit>
        <trans-unit id="40509725b1b94ac04bace7fdcf93e38e06d1990b" translate="yes" xml:space="preserve">
          <source>The Operation and Maintenance (OAM) support in OTP consists of a generic model for management subsystems in OTP, and some components to be used in these subsystems. This section describes the model.</source>
          <target state="translated">OTPにおけるOAM(Operation and Maintenance)サポートは、OTPにおける管理サブシステムの汎用モデルと、これらのサブシステムで使用されるいくつかのコンポーネントから構成されています。ここでは、このモデルについて説明する。</target>
        </trans-unit>
        <trans-unit id="808ca5db0eed6b5828cf7aea959f1c6d4f421b35" translate="yes" xml:space="preserve">
          <source>The P flag has been deprecated by RFC 6733.</source>
          <target state="translated">PフラグはRFC 6733で非推奨とされています。</target>
        </trans-unit>
        <trans-unit id="521a731b4b96b784ec12d6942621ae176f880a6a" translate="yes" xml:space="preserve">
          <source>The PCRE library sets a limit on how many times the internal match function can be called. Defaults to 10,000,000 in the library compiled for Erlang. If &lt;code&gt;{error, match_limit}&lt;/code&gt; is returned, the execution of the regular expression has reached this limit. This is normally to be regarded as a &lt;code&gt;nomatch&lt;/code&gt;, which is the default return value when this occurs, but by specifying &lt;code&gt;report_errors&lt;/code&gt;, you are informed when the match fails because of too many internal calls.</source>
          <target state="translated">PCREライブラリは、内部照合関数を呼び出すことができる回数に制限を設定します。Erlang用にコンパイルされたライブラリのデフォルトは10,000,000です。場合 &lt;code&gt;{error, match_limit}&lt;/code&gt; 返され、正規表現の実行は、この制限に達しています。これは通常、 &lt;code&gt;nomatch&lt;/code&gt; と見なされます。これは、これが発生したときのデフォルトの戻り値ですが、 &lt;code&gt;report_errors&lt;/code&gt; を指定することにより、内部呼び出しが多すぎるために一致が失敗したときに通知されます。</target>
        </trans-unit>
        <trans-unit id="315aa4b073a3e51b4182d67ae5a99c3e8dd60122" translate="yes" xml:space="preserve">
          <source>The PCRE-specific options &lt;code&gt;dupnames&lt;/code&gt;, &lt;code&gt;ungreedy&lt;/code&gt;, and &lt;code&gt;extra&lt;/code&gt; can be changed in the same way as the Perl-compatible options by using the characters J, U, and X respectively.</source>
          <target state="translated">PCRE固有のオプション &lt;code&gt;dupnames&lt;/code&gt; 、 &lt;code&gt;ungreedy&lt;/code&gt; 、および &lt;code&gt;extra&lt;/code&gt; は、J、U、およびXの文字をそれぞれ使用して、Perl互換のオプションと同じ方法で変更できます。</target>
        </trans-unit>
        <trans-unit id="3b60700ebcda31fdb446fa71f372ef2af6d7bcce" translate="yes" xml:space="preserve">
          <source>The PLT is built using option &lt;code&gt;--build_plt&lt;/code&gt; to Dialyzer. The following command builds the recommended minimal PLT for Erlang/OTP:</source>
          <target state="translated">PLTは、Dialyzerのオプション &lt;code&gt;--build_plt&lt;/code&gt; を使用してビルドされます。次のコマンドは、Erlang / OTPに推奨される最小限のPLTを構築します。</target>
        </trans-unit>
        <trans-unit id="068bb5f6b3073467febaec97d8dca8e259a70b70" translate="yes" xml:space="preserve">
          <source>The PLT is extended to also include the files specified with &lt;code&gt;-c&lt;/code&gt; and &lt;code&gt;-r&lt;/code&gt;. Use &lt;code&gt;--plt&lt;/code&gt; to specify which PLT to start from, and &lt;code&gt;--output_plt&lt;/code&gt; to specify where to put the PLT. Notice that the analysis possibly can include files from the PLT if they depend on the new files. This option only works for BEAM files.</source>
          <target state="translated">PLTが拡張され、 &lt;code&gt;-c&lt;/code&gt; および &lt;code&gt;-r&lt;/code&gt; で指定されたファイルも含まれるようになりました。使用は &lt;code&gt;--plt&lt;/code&gt; から始める、とするためにどのPLT指定する &lt;code&gt;--output_plt&lt;/code&gt; どこPLTを入れて指定します。新しいファイルに依存している場合、分析にPLTのファイルが含まれる可能性があることに注意してください。このオプションは、BEAMファイルに対してのみ機能します。</target>
        </trans-unit>
        <trans-unit id="a5ac14853a9b086e8f452912a23bfe90221af508" translate="yes" xml:space="preserve">
          <source>The Perl documentation states that it is probably useful only when combined with (?{}) or (??{}). Those are Perl features that are not present in PCRE.</source>
          <target state="translated">Perlのドキュメントには、(?{})や(? これらはPCREにはないPerlの機能です。</target>
        </trans-unit>
        <trans-unit id="05f38ed5f44cf6a58fcb55ac9b9ba9cb03970efa" translate="yes" xml:space="preserve">
          <source>The ProtocolVersion version is the version actually encoded in the reply message.</source>
          <target state="translated">ProtocolVersionバージョンは、返信メッセージで実際にエンコードされたバージョンです。</target>
        </trans-unit>
        <trans-unit id="544a356532db2cd2759e24c6723c4194d33f11f5" translate="yes" xml:space="preserve">
          <source>The Public Key application deals with public-key related file formats, digital signatures, and &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc5280.txt&quot;&gt; X-509 certificates&lt;/a&gt;&lt;/code&gt;. It is a library application that provides encode/decode, sign/verify, encrypt/decrypt, and similar functionality. It does not read or write files, it expects or returns file contents or partial file contents as binaries.</source>
          <target state="translated">公開鍵アプリケーションは、公開鍵関連のファイル形式、デジタル署名、および &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc5280.txt&quot;&gt; X-509 certificates&lt;/a&gt;&lt;/code&gt; 扱います。これは、エンコード/デコード、署名/検証、暗号化/復号化などの機能を提供するライブラリアプリケーションです。ファイルの読み取りや書き込みは行わず、ファイルの内容または部分的なファイルの内容をバイナリとして予期または返します。</target>
        </trans-unit>
        <trans-unit id="7ebdf434e84c8ed49f35713ff4853c27de0d8e82" translate="yes" xml:space="preserve">
          <source>The Public Key decode- and encode-functions try to use the NIFs in the ASN.1 compilers runtime modules, if they can be found. Thus, to have the ASN1 application in the path of your system gives the best performance.</source>
          <target state="translated">公開鍵のデコードおよびエンコード関数は、ASN.1コンパイラのランタイムモジュールにあるNIFを使用しようとします。このように、ASN1アプリケーションをシステムのパスに置くことが、最高のパフォーマンスを提供します。</target>
        </trans-unit>
        <trans-unit id="efe14f45b872852caa29e8e8cc7c7d6e2482faaf" translate="yes" xml:space="preserve">
          <source>The RFC 3539 watchdog state machine has transitioned into (&lt;code&gt;up&lt;/code&gt;) or out of (&lt;code&gt;down&lt;/code&gt;) the OKAY state. If a &lt;code&gt;#diameter_packet{}&lt;/code&gt; is present in an &lt;code&gt;up&lt;/code&gt; event then there has been a capabilities exchange on a newly established transport connection and the record contains the received CER or CEA.</source>
          <target state="translated">RFC 3539ウォッチドッグステートマシンがOKAY状態に移行（ &lt;code&gt;up&lt;/code&gt; ）または終了（ &lt;code&gt;down&lt;/code&gt; ）しました。場合 &lt;code&gt;#diameter_packet{}&lt;/code&gt; 内に存在する &lt;code&gt;up&lt;/code&gt; イベント次いで能力があった新たに確立されたトランスポート接続上で交換し、レコードは、受信したCERまたはCEAを含有します。</target>
        </trans-unit>
        <trans-unit id="dc64b0c1b30970fb85a8fe63a3336e6b7a09937b" translate="yes" xml:space="preserve">
          <source>The RFC 3539 watchdog timer. An integer value is interpreted as the RFC's TwInit in milliseconds, a jitter of &amp;plusmn; 2 seconds being added at each rearming of the timer to compute the RFC's Tw. An MFA is expected to return the RFC's Tw directly, with jitter applied, allowing the jitter calculation to be performed by the callback.</source>
          <target state="translated">RFC 3539ウォッチドッグタイマー。整数値は、ミリ秒単位のRFCのTwInitとして解釈されます。RFCのTwを計算するために、タイマーを再設定するたびに&amp;plusmn;2秒のジッタが追加されます。 MFAはジッターが適用された状態でRFCのTwを直接返すことが期待されており、コールバックによってジッター計算を実行できます。</target>
        </trans-unit>
        <trans-unit id="fcc9e80a4124e3a42a057c7e5dbba54abf671c72" translate="yes" xml:space="preserve">
          <source>The RFC states that if a certificate defines Reference IDs in a &lt;code&gt;Subject Alternate Name&lt;/code&gt; field, the &lt;code&gt;Subject&lt;/code&gt; field MUST NOT be used for host name checking, even if it contains valid CN names. Therefore only &lt;code&gt;kb.example.org&lt;/code&gt; and &lt;code&gt;https://www.example.org&lt;/code&gt; matches. The match fails both for &lt;code&gt;example.com&lt;/code&gt; and &lt;code&gt;foo.example.com&lt;/code&gt; becuase they are in the &lt;code&gt;Subject&lt;/code&gt; field which is not checked because the &lt;code&gt;Subject Alternate Name&lt;/code&gt; field is present.</source>
          <target state="translated">RFCは、証明書が &lt;code&gt;Subject Alternate Name&lt;/code&gt; フィールドで参照IDを定義する場合、有効なCN名が含まれている場合でも、 &lt;code&gt;Subject&lt;/code&gt; フィールドをホスト名チェックに使用してはならないことを述べています。したがって、 &lt;code&gt;kb.example.org&lt;/code&gt; と &lt;code&gt;https://www.example.org&lt;/code&gt; のみが一致します。試合は両方のために失敗し &lt;code&gt;example.com&lt;/code&gt; と &lt;code&gt;foo.example.com&lt;/code&gt; becuase彼らがしている &lt;code&gt;Subject&lt;/code&gt; ので、チェックされていないフィールド &lt;code&gt;Subject Alternate Name&lt;/code&gt; フィールドが存在しています。</target>
        </trans-unit>
        <trans-unit id="8707a6b8a6bbf5e67f47a831acd5b638d6ca82c3" translate="yes" xml:space="preserve">
          <source>The Report Browser (RB) tool is used to browse and format error reports written by the error logger handler &lt;code&gt;log_mf_h&lt;/code&gt; in STDLIB.</source>
          <target state="translated">Report Browser（RB）ツールは、STDLIBのエラーロガーハンドラー &lt;code&gt;log_mf_h&lt;/code&gt; によって書き込まれたエラーレポートを参照およびフォーマットするために使用されます。</target>
        </trans-unit>
        <trans-unit id="e200f59605a43a83406a6a1c3aae57938231fe10" translate="yes" xml:space="preserve">
          <source>The Report Browser Tool</source>
          <target state="translated">レポートブラウザツール</target>
        </trans-unit>
        <trans-unit id="4692a2cbc9da1318b1c32468112fcf231936c7b1" translate="yes" xml:space="preserve">
          <source>The Runtime_Tools application is available on both the trace control node and the traced node.</source>
          <target state="translated">Runtime_Toolsアプリケーションは、トレース制御ノードとトレースされたノードの両方で利用できます。</target>
        </trans-unit>
        <trans-unit id="3e6f6adc881738e4e882b8995898a6ee34ae6866" translate="yes" xml:space="preserve">
          <source>The SASL application introduces three types of reports:</source>
          <target state="translated">SASLアプリケーションでは、3種類のレポートを紹介しています。</target>
        </trans-unit>
        <trans-unit id="a66565cf9194d0ac12d200f8341003bfd8ef9840" translate="yes" xml:space="preserve">
          <source>The SASL application provides support for:</source>
          <target state="translated">SASLアプリケーションはサポートを提供しています。</target>
        </trans-unit>
        <trans-unit id="d6eac0a2617b8363f4e9ff21a3e5cf89ae6de35c" translate="yes" xml:space="preserve">
          <source>The SASL error logging concept described in this section is deprecated since Erlang/OTP 21.0, when the new &lt;code&gt;logging API&lt;/code&gt; was introduced.</source>
          <target state="translated">このセクションで説明されているSASLエラーロギングの概念は、新しい &lt;code&gt;logging API&lt;/code&gt; が導入されたErlang / OTP 21.0以降では使用されていません。</target>
        </trans-unit>
        <trans-unit id="06f440d4cdd560b9a71ad7c9c8906b6fd30020a0" translate="yes" xml:space="preserve">
          <source>The SAX events that are sent to the user via the callback.</source>
          <target state="translated">コールバックを介してユーザーに送信される SAX イベント。</target>
        </trans-unit>
        <trans-unit id="6c62591fcbde98f13b883726ae2b16d26e6fd6e4" translate="yes" xml:space="preserve">
          <source>The SMP emulator (introduced in R11B) takes advantage of a multi-core or multi-CPU computer by running several Erlang scheduler threads (typically, the same as the number of cores). Each scheduler thread schedules Erlang processes in the same way as the Erlang scheduler in the non-SMP emulator.</source>
          <target state="translated">SMPエミュレータ(R11Bで導入)はマルチコアやマルチCPUのコンピュータを利用して、複数のErlangスケジューラースレッド(通常はコア数と同じ)を実行します。各スケジューラスレッドは非SMPエミュレータのErlangスケジューラと同じ方法でErlangプロセスをスケジュールします。</target>
        </trans-unit>
        <trans-unit id="886a9eb3b2cede92a51b83a792de6e157b89118c" translate="yes" xml:space="preserve">
          <source>The SNMP agent system consists of one Master Agent and optional Sub-agents.</source>
          <target state="translated">SNMPエージェントシステムは、1つのマスターエージェントとオプションのサブエージェントで構成されています。</target>
        </trans-unit>
        <trans-unit id="7abe087b7edee22ce1a0361250a19799bdfe6153" translate="yes" xml:space="preserve">
          <source>The SNMP agent system consists of one Master Agent and optional sub-agents. The Master Agent can be seen as a special kind of sub-agent. It implements the core agent functionality, UDP packet processing, type checking, access control, trap distribution, and so on. From a user perspective, it is used as an ordinary sub-agent.</source>
          <target state="translated">SNMPエージェントシステムは、1つのマスターエージェントとオプションのサブエージェントで構成されています。マスターエージェントは、特別な種類のサブエージェントと見ることができます。マスターエージェントは、エージェントのコア機能であるUDPパケット処理、タイプチェック、アクセス制御、トラップ配信などを実装しています。ユーザーから見れば、通常のサブエージェントとして使用されます。</target>
        </trans-unit>
        <trans-unit id="3265cc19f00c49d8349eff44b143ef435848cde4" translate="yes" xml:space="preserve">
          <source>The SNMP agent toolkit gets input from three different sources:</source>
          <target state="translated">SNMPエージェントツールキットは、3つの異なるソースからの入力を取得します。</target>
        </trans-unit>
        <trans-unit id="516cef785b21f525314dd4769fb5d4a3d8e52b36" translate="yes" xml:space="preserve">
          <source>The SNMP application consists of several entities, of which the agent is one. This function starts the agent entity of the application.</source>
          <target state="translated">SNMP アプリケーションは複数のエンティティで構成されており、そのうちの一つがエージェントです。本関数は、アプリケーションのエージェントエンティティを起動します。</target>
        </trans-unit>
        <trans-unit id="5a5e7e85ae81bf01406a4eba00ac814b17f5f063" translate="yes" xml:space="preserve">
          <source>The SNMP application consists of several entities, of which the manager is one. This function starts the manager entity of the application.</source>
          <target state="translated">SNMP アプリケーションは複数のエンティティで構成されており、そのうちの 1 つがマネージャです。この関数は、アプリケーションのマネージャエンティティを起動します。</target>
        </trans-unit>
        <trans-unit id="1c525a15cd833eca106834a5297df8dd9f3d8e99" translate="yes" xml:space="preserve">
          <source>The SNMP application should be used to start an SNMP agent. Then the API functions below can be used to load/unload the OTP-MIB into/from the agent. The instrumentation of the OTP-MIB uses Mnesia, hence Mnesia must be started prior to loading the OTP-MIB.</source>
          <target state="translated">SNMPエージェントを起動するには、SNMPアプリケーションを使用する必要があります。その後、以下のAPI関数を使用して、エージェントへのOTP-MIBのロード/アンロードを行います。OTP-MIBのインストルメンテーションはMnesiaを使用しているため、OTP-MIBをロードする前にMnesiaを起動する必要があります。</target>
        </trans-unit>
        <trans-unit id="efcaf71f311ac8ed0a4c853a395724aa7b68ecca" translate="yes" xml:space="preserve">
          <source>The SNMP built-in database</source>
          <target state="translated">SNMP組み込みデータベース</target>
        </trans-unit>
        <trans-unit id="1f9b4daeb0c18439d5ab9d3febb86ba8cf3f41bc" translate="yes" xml:space="preserve">
          <source>The SNMP development tool provides an environment for rapid agent/manager prototyping and construction. With the following information provided, this tool is used to set up a running multi-lingual SNMP agent/manager:</source>
          <target state="translated">SNMP開発ツールは、迅速なエージェント/マネージャのプロトタイピングと構築のための環境を提供します。以下の情報を提供し、このツールを使用して、実行中の多言語SNMPエージェント/マネージャを設定します。</target>
        </trans-unit>
        <trans-unit id="4042139e11f084c5315473eee5bae69ee58a652c" translate="yes" xml:space="preserve">
          <source>The SNMP development toolkit contains the following parts:</source>
          <target state="translated">SNMP開発ツールキットには、以下の部分が含まれています。</target>
        </trans-unit>
        <trans-unit id="c676c0d7043a8420fb555224be79bdf5a57f0b38" translate="yes" xml:space="preserve">
          <source>The SNMP development toolkit works with all three versions of Standard Internet Management Framework; SNMPv1, SNMPv2 and SNMPv3. They all share the same basic structure and components. And they follow the same architecture.</source>
          <target state="translated">SNMP開発ツールキットは、SNMPv1、SNMPv2、SNMPv3の3つのバージョンすべてで動作します。これらはすべて同じ基本構造とコンポーネントを共有しています。また、同じアーキテクチャに従っています。</target>
        </trans-unit>
        <trans-unit id="4c98874c0a92d51a9659461230a55d2c1a730338" translate="yes" xml:space="preserve">
          <source>The SNMP-COMMUNITY-MIB defines managed objects that is used for coexistence between SNMPv1 and SNMPv2c with SNMPv3. Specifically, it contains objects for mapping between community strings and version-independent SNMP message parameters. In addition, this MIB provides a mechanism for performing source address validation on incoming requests, and for selecting community strings based on target addresses for outgoing notifications.</source>
          <target state="translated">SNMP-COMMUNITY-MIBは、SNMPv1、SNMPv2cとSNMPv3を共存させるための管理オブジェクトを定義しています。具体的には、コミュニティ文字列とバージョンに依存しないSNMPメッセージパラメータをマッピングするためのオブジェクトが含まれています。また、本MIBは、受信要求に対して送信元アドレスの検証を行い、発信通知の対象アドレスに基づいてコミュニティ文字列を選択するための仕組みを提供します。</target>
        </trans-unit>
        <trans-unit id="8668c117c3657ad50b4bac1040aadc9d90558e41" translate="yes" xml:space="preserve">
          <source>The SNMP-FRAMEWORK-MIB and SNMP-MPD-MIB define additional read-only managed objects, which is used in the generic SNMP framework defined in RFC2271 and the generic message processing and dispatching module defined in RFC2272. They are generic in the sense that they are not tied to any specific SNMP version.</source>
          <target state="translated">SNMP-FRAMEWORK-MIBおよびSNMP-MPD-MIBは、RFC2271で定義されている汎用SNMPフレームワークおよびRFC2272で定義されている汎用メッセージ処理およびディスパッチモジュールで使用される、追加の読み取り専用管理オブジェクトを定義します。これらは、特定のSNMPバージョンに縛られないという意味で汎用的なものです。</target>
        </trans-unit>
        <trans-unit id="45b5b2d3e04821e69bc6b70c4958af997f02dac7" translate="yes" xml:space="preserve">
          <source>The SNMP-TARGET-MIB and SNMP-NOTIFICATION-MIB define managed objects for configuration of notification receivers. They are described in detail in RFC2273. Only a brief description is given here.</source>
          <target state="translated">SNMP-TARGET-MIBおよびSNMP-NOTIFICATION-MIBは、通知受信機の設定のための管理オブジェクトを定義する。これらはRFC2273で詳細に記述されています。ここでは簡単な説明のみを行う。</target>
        </trans-unit>
        <trans-unit id="9d8ba60d5c67646e6a39ec77ff47623898401ff5" translate="yes" xml:space="preserve">
          <source>The SNMP-USER-BASED-SM-MIB defines managed objects that is used for the User-Based Security Model.</source>
          <target state="translated">SNMP-USER-BASED-SM-MIBは、ユーザベースセキュリティモデルで使用される管理オブジェクトを定義します。</target>
        </trans-unit>
        <trans-unit id="06a4a7a167128e9dfbd7bbf5787fec903cb71f3c" translate="yes" xml:space="preserve">
          <source>The SNMP-VIEW-BASED-ACM-MIB defines managed objects to control access to the the managed objects for the managers. The View Based Access Control Module (VACM) can be used with any SNMP version. However, if it is used with SNMPv1 or SNMPv2c, the SNMP-COMMUNITY-MIB defines additional objects to map community strings to VACM parameters.</source>
          <target state="translated">SNMP-VIEW-BASED-ACMIBは、管理者が管理対象オブジェクトへのアクセスを制御するための管理対象オブジェクトを定義します。ビューベースアクセス制御モジュール(VACM)は、どのSNMPバージョンでも使用することができます。ただし、SNMPv1またはSNMPv2cで使用する場合、SNMP-COMMUNITY-MIBは、コミュニティ文字列をVACMパラメータにマッピングするための追加オブジェクトを定義します。</target>
        </trans-unit>
        <trans-unit id="cf1237e4f8f3b9ace0c3f4bf9ded6dcb4f4634bb" translate="yes" xml:space="preserve">
          <source>The SNMPv3 specifications take a modular approach to SNMP. All modules are separated from each other, and can be extended or replaced individually. Examples of modules are Message definition, Security and Access Control. The main features of SNMPv3 are:</source>
          <target state="translated">SNMPv3仕様は、SNMPにモジュラーアプローチを採用しています。すべてのモジュールは互いに分離されており、個別に拡張または置換することができます。モジュールの例としては、メッセージ定義、セキュリティ、アクセス制御があります。SNMPv3の主な機能は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="49091ee8eff63f8735f82d85f410f0e974abd772" translate="yes" xml:space="preserve">
          <source>The SSH Authentication Protocol is a general-purpose user authentication protocol run over the SSH Transport Layer Protocol. The &lt;code&gt;ssh&lt;/code&gt; application supports user authentication as follows:</source>
          <target state="translated">SSH認証プロトコルは、SSHトランスポート層プロトコル上で実行される汎用ユーザー認証プロトコルです。 &lt;code&gt;ssh&lt;/code&gt; 次のようにアプリケーションがユーザ認証をサポートしています。</target>
        </trans-unit>
        <trans-unit id="7b0b1cec477594d6b882874c149d3fa88e25a3ad" translate="yes" xml:space="preserve">
          <source>The SSH Connection Protocol provides application-support services over the transport pipe, for example, channel multiplexing, flow control, remote program execution, signal propagation, and connection forwarding. Functions for handling the SSH Connection Protocol can be found in the module &lt;code&gt;&lt;a href=&quot;ssh_connection&quot;&gt;ssh_connection&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;ssh&lt;/code&gt;.</source>
          <target state="translated">SSH接続プロトコルは、チャネルの多重化、フロー制御、リモートプログラムの実行、信号の伝播、接続の転送など、トランスポートパイプを介したアプリケーションサポートサービスを提供します。SSH接続プロトコルを処理するための関数は、 &lt;code&gt;ssh&lt;/code&gt; のモジュール &lt;code&gt;&lt;a href=&quot;ssh_connection&quot;&gt;ssh_connection&lt;/a&gt;&lt;/code&gt; にあります。</target>
        </trans-unit>
        <trans-unit id="509aa3afb50ca256dde1f08abd1d170febe86fc9" translate="yes" xml:space="preserve">
          <source>The SSH Transport Protocol is a secure, low-level transport. It provides strong encryption, cryptographic host authentication, and integrity protection. A minimum of Message Authentication Code (MAC) and encryption algorithms are supported. For details, see the &lt;code&gt;&lt;a href=&quot;ssh&quot;&gt;ssh(3)&lt;/a&gt;&lt;/code&gt; manual page in &lt;code&gt;ssh&lt;/code&gt;.</source>
          <target state="translated">SSHトランスポートプロトコルは、安全な低レベルのトランスポートです。強力な暗号化、暗号ホスト認証、および整合性保護を提供します。最小のメッセージ認証コード（MAC）と暗号化アルゴリズムがサポートされています。詳細については、 &lt;code&gt;&lt;a href=&quot;ssh&quot;&gt;ssh(3)&lt;/a&gt;&lt;/code&gt; でのマニュアルページ &lt;code&gt;ssh&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="24d33b22db4cc904f86f4d5db9025bf058eaf503" translate="yes" xml:space="preserve">
          <source>The SSL/TLS distribution options can be written into a file that is consulted when the node is started. This file name is then specified with the command line argument &lt;code&gt;-ssl_dist_optfile&lt;/code&gt;.</source>
          <target state="translated">SSL / TLS配布オプションは、ノードの起動時に参照されるファイルに書き込むことができます。このファイル名は、コマンドライン引数 &lt;code&gt;-ssl_dist_optfile&lt;/code&gt; で指定されます。</target>
        </trans-unit>
        <trans-unit id="555d2ccf08ac60c2e06799bc61b70df2c88b6a2f" translate="yes" xml:space="preserve">
          <source>The Solaris (SunOS 5.x) messages are retrieved from the syslog-daemon, &lt;code&gt;syslogd&lt;/code&gt;.</source>
          <target state="translated">Solaris（SunOS 5.x）メッセージは、syslog-daemon、 &lt;code&gt;syslogd&lt;/code&gt; から取得されます。</target>
        </trans-unit>
        <trans-unit id="23097a6cf28465a184806bf15474a12dff162d12" translate="yes" xml:space="preserve">
          <source>The Standard Erlang Libraries application, &lt;strong&gt;STDLIB&lt;/strong&gt;, is mandatory in the sense that the minimal system based on Erlang/OTP consists of &lt;strong&gt;STDLIB&lt;/strong&gt; and &lt;strong&gt;Kernel&lt;/strong&gt;.</source>
          <target state="translated">標準のErlangライブラリアプリケーションである&lt;strong&gt;STDLIBは&lt;/strong&gt;、Erlang / OTPに基づく最小限のシステムが&lt;strong&gt;STDLIB&lt;/strong&gt;と&lt;strong&gt;Kernelで&lt;/strong&gt;構成されるという意味で必須です。</target>
        </trans-unit>
        <trans-unit id="5c2a74e481bb59b29d7198edb8d96d6f22f60622" translate="yes" xml:space="preserve">
          <source>The System Under Test (SUT) can consist of one or more target nodes. &lt;code&gt;Common Test&lt;/code&gt; contains a generic test server that, together with other test utilities, is used to perform test case execution. The tests can be started from a GUI, from the OS shell, or from an Erlang shell. &lt;strong&gt;Test suites&lt;/strong&gt; are files (Erlang modules) that contain the &lt;strong&gt;test cases&lt;/strong&gt; (Erlang functions) to be executed. &lt;strong&gt;Support modules&lt;/strong&gt; provide functions that the test cases use to do the tests.</source>
          <target state="translated">テスト対象システム（SUT）は、1つ以上のターゲットノードで構成できます。 &lt;code&gt;Common Test&lt;/code&gt; には、他のテストユーティリティと共に、テストケースの実行に使用される汎用テストサーバーが含まれています。テストは、GUI、OSシェル、またはErlangシェルから開始できます。&lt;strong&gt;テストスイート&lt;/strong&gt;は、実行される&lt;strong&gt;テストケース&lt;/strong&gt;（Erlang関数）を含むファイル（Erlangモジュール）です。&lt;strong&gt;サポートモジュール&lt;/strong&gt;は、テストケースがテストを実行するために使用する機能を提供します。</target>
        </trans-unit>
        <trans-unit id="eb87875630edf563277392030eee430765ee9a3b" translate="yes" xml:space="preserve">
          <source>The TCP/IP &lt;code&gt;epmd&lt;/code&gt; daemon only keeps track of the &lt;code&gt;Name&lt;/code&gt; (first) part of an Erlang node name. The &lt;code&gt;Host&lt;/code&gt; part (whatever is after the &lt;code&gt;@&lt;/code&gt;) is implicit in the node name where the &lt;code&gt;epmd&lt;/code&gt; daemon was contacted, as is the IP address where the Erlang node can be reached. Consistent and correct TCP naming services are therefore required for an Erlang network to function correctly.</source>
          <target state="translated">TCP / IP &lt;code&gt;epmd&lt;/code&gt; デーモンは、Erlangノード名の &lt;code&gt;Name&lt;/code&gt; （最初）の部分のみを追跡します。 &lt;code&gt;Host&lt;/code&gt; 部分は、（後にあるものは何でも &lt;code&gt;@&lt;/code&gt; ）ノード名に内在する &lt;code&gt;epmd&lt;/code&gt; Erlangのノードに到達できるIPアドレスであるとしてデーモンが、接触させました。したがって、Erlangネットワークが正しく機能するには、一貫性のある正しいTCPネームサービスが必要です。</target>
        </trans-unit>
        <trans-unit id="058df102c079061352735c937be80bdb1a45818f" translate="yes" xml:space="preserve">
          <source>The TCP/IP distribution uses a handshake that expects a connection-based protocol, that is, the protocol does not include any authentication after the handshake procedure.</source>
          <target state="translated">TCP/IP ディストリビューションでは、接続ベースのプロトコルを期待したハンドシェイク、つまりハンドシェイク手順後の認証を含まないプロトコルを使用しています。</target>
        </trans-unit>
        <trans-unit id="6657b1618f0a92c332d5f9a74326d92f2550bf02" translate="yes" xml:space="preserve">
          <source>The TCP_NODELAY option for the telnet socket is disabled (set to &lt;code&gt;false&lt;/code&gt;) per default</source>
          <target state="translated">デフォルトでは、telnetソケットのTCP_NODELAYオプションは無効になっています（ &lt;code&gt;false&lt;/code&gt; に設定されています）。</target>
        </trans-unit>
        <trans-unit id="27af0d178d9d81560da76e1bb5028c47f5e6d47a" translate="yes" xml:space="preserve">
          <source>The TFTP port where the daemon listens. Defaults is the standardized number 69. On the server side, it can sometimes make sense to set it to 0, meaning that the daemon just picks a free port (which one is returned by function &lt;code&gt;info/1&lt;/code&gt;).</source>
          <target state="translated">デーモンが待機するTFTPポート。デフォルトは標準化された番号69です。サーバー側では、0に設定すると意味がある場合があります。これは、デーモンが空きポート（関数 &lt;code&gt;info/1&lt;/code&gt; によって返されるポート）のみを選択することを意味します。</target>
        </trans-unit>
        <trans-unit id="75ccd2ece5259566f90ebb1a8f2c68746b4c7b93" translate="yes" xml:space="preserve">
          <source>The TLS/DTLS handshake protocol and data transfer is run on top of the TLS/DTLS Record Protocol, which uses a keyed-hash Message Authenticity Code (MAC), or a Hash-based MAC (HMAC), to protect the message data integrity. From the TLS RFC: &quot;A Message Authentication Code is a one-way hash computed from a message and some secret data. It is difficult to forge without knowing the secret data. Its purpose is to detect if the message has been altered.&quot;</source>
          <target state="translated">TLS/DTLS ハンドシェイクプロトコルとデータ転送は、TLS/DTLS レコードプロトコルの上で実行され、メッセージデータの整合性を保護するために、鍵付きハッシュのメッセージ認証コード (MAC)またはハッシュベースの MAC (HMAC)を使用します。TLS RFC より:「メッセージ認証コードは、メッセージといくつかの秘密データから計算される一方通行のハッシュです。秘密データを知らずに偽造することは困難です。その目的は、メッセージが改ざんされたかどうかを検出することです。</target>
        </trans-unit>
        <trans-unit id="ecf685e6c13939907b870d82ee6d0c05ec6e094e" translate="yes" xml:space="preserve">
          <source>The Text Based Trace Facility</source>
          <target state="translated">テキストベースのトレース機能</target>
        </trans-unit>
        <trans-unit id="e8fd67f45550805b41375cc84bc114e897e3206a" translate="yes" xml:space="preserve">
          <source>The Trace Tool Builder, &lt;code&gt;ttb&lt;/code&gt;, is a base for building trace tools for distributed systems.</source>
          <target state="translated">トレースツールビルダー &lt;code&gt;ttb&lt;/code&gt; は、分散システム用のトレースツールを構築するためのベースです。</target>
        </trans-unit>
        <trans-unit id="64d22e790fe528bf704a212bc1e1c0da643a949f" translate="yes" xml:space="preserve">
          <source>The Trace area also displays Back Trace, a summary of the current function calls on the stack.</source>
          <target state="translated">また、トレースエリアには、スタック上の現在の関数呼び出しの概要であるバックトレースも表示されます。</target>
        </trans-unit>
        <trans-unit id="b692df8320088d88e275d851ad60786d4e949a1f" translate="yes" xml:space="preserve">
          <source>The Trace area, which displays a trace output for the process.</source>
          <target state="translated">プロセスのトレース出力を表示するトレースエリアです。</target>
        </trans-unit>
        <trans-unit id="1b50d3d2fc04c4411539dfbb6e62512f2efa0130" translate="yes" xml:space="preserve">
          <source>The Trivial File Transfer Protocol or TFTP is a very simple protocol used to transfer files.</source>
          <target state="translated">Trivial File Transfer Protocol または TFTP は、ファイルを転送するために使用される非常にシンプルなプロトコルです。</target>
        </trans-unit>
        <trans-unit id="bf89156ef59750c4bb77ca15635b355ebce24e10" translate="yes" xml:space="preserve">
          <source>The Types are:</source>
          <target state="translated">タイプは</target>
        </trans-unit>
        <trans-unit id="2ea556d1f13405f24d60defd343780b8d63e1882" translate="yes" xml:space="preserve">
          <source>The URL the client was on before requesting the URL (if it could not be determined, a minus sign is placed in this field).</source>
          <target state="translated">クライアントがURLを要求する前にログオンしていたURL(判断できない場合は、この欄にマイナス記号を入れます)。</target>
        </trans-unit>
        <trans-unit id="2cd23bacb56d43630d70d816af467c37a05ab674" translate="yes" xml:space="preserve">
          <source>The UTF-8 variants were introduced in Erlang/OTP R16 and the string returned by &lt;code&gt;ERL_ATOM_PTR(atom)&lt;/code&gt; was not &lt;code&gt;NULL&lt;/code&gt;-terminated on older releases.</source>
          <target state="translated">UTF-8バリアントはErlang / OTP R16で導入され、 &lt;code&gt;ERL_ATOM_PTR(atom)&lt;/code&gt; によって返される文字列は、古いリリースでは &lt;code&gt;NULL&lt;/code&gt; で終了していませんでした。</target>
        </trans-unit>
        <trans-unit id="615107616ab4a2ac637d22a3e97ccf0d1ff89d56" translate="yes" xml:space="preserve">
          <source>The Unicode characters need to be processed by the Erlang program, which is why library functions must be able to handle them. In some cases functionality has been added to already existing interfaces (as the &lt;code&gt;string&lt;/code&gt; module now can handle strings with any code points). In some cases new functionality or options have been added (as in the &lt;code&gt;io&lt;/code&gt; module, the file handling, the &lt;code&gt;unicode&lt;/code&gt; module, and the bit syntax). Today most modules in Kernel and STDLIB, as well as the VM are Unicode-aware.</source>
          <target state="translated">Unicode文字は、Erlangプログラムで処理する必要があるため、ライブラリ関数でUnicode文字を処理できる必要があります。場合によっては、既存のインターフェイスに機能が追加されています（ &lt;code&gt;string&lt;/code&gt; モジュールが任意のコードポイントの文字列を処理できるようになったため）。場合によっては、新しい機能またはオプションが追加されました（ &lt;code&gt;io&lt;/code&gt; モジュール、ファイル処理、 &lt;code&gt;unicode&lt;/code&gt; モジュール、ビット構文など）。現在、カーネルとSTDLIBのほとんどのモジュール、およびVMはUnicode対応です。</target>
        </trans-unit>
        <trans-unit id="d8a64b00a37fa70a62423e7afa68917e078e3bbf" translate="yes" xml:space="preserve">
          <source>The Unicode file naming support was introduced in Erlang/OTP R14B01. A VM operating in Unicode filename translation mode can work with files having names in any language or character set (as long as it is supported by the underlying operating system and file system). The Unicode character list is used to denote filenames or directory names. If the file system content is listed, you also get Unicode lists as return value. The support lies in the Kernel and STDLIB modules, which is why most applications (that do not explicitly require the filenames to be in the ISO Latin-1 range) benefit from the Unicode support without change.</source>
          <target state="translated">Unicodeファイル名のサポートはErlang/OTP R14B01で導入されました。Unicodeファイル名変換モードで動作しているVMは、どんな言語や文字セットでもファイル名を持つファイルを扱うことができます(基本となるオペレーティングシステムとファイルシステムでサポートされている限り)。Unicode 文字リストは、ファイル名またはディレクトリ名を示すために使用されます。ファイルシステムの内容がリストされている場合は、戻り値として Unicode リストも取得します。このサポートはカーネルと STDLIB モジュールにありますので、ほとんどのアプリケーションでは (ファイル名が ISO Latin-1 の範囲内にあることを明示的に要求しない)Unicode サポートを変更することなく恩恵を受けることができます。</target>
        </trans-unit>
        <trans-unit id="2e08532eda1cbb1ea06bfac649530b3d005afb89" translate="yes" xml:space="preserve">
          <source>The Unicode string is returned as a Unicode list, which is recognized as such, as the Erlang shell uses the Unicode encoding (and is started with all Unicode characters considered printable). The Unicode list is valid input to function &lt;code&gt;io:put_chars/2&lt;/code&gt;, so data can be output on any Unicode-capable device. If the device is a terminal, characters are output in format &lt;code&gt;\x{&lt;/code&gt;H...&lt;code&gt;}&lt;/code&gt; if encoding is &lt;code&gt;latin1&lt;/code&gt;. Otherwise in UTF-8 (for the non-interactive terminal: &quot;oldshell&quot; or &quot;noshell&quot;) or whatever is suitable to show the character properly (for an interactive terminal: the regular shell).</source>
          <target state="translated">Unicode文字列はUnicodeリストとして返されます。これは、ErlangシェルがUnicodeエンコーディングを使用するため、そのように認識されます（すべてのUnicode文字が印刷可能と見なされて開始されます）。 Unicodeリストは関数 &lt;code&gt;io:put_chars/2&lt;/code&gt; への有効な入力であるため、データは任意のUnicode対応デバイスで出力できます。デバイスが端末で、エンコーディングが &lt;code&gt;latin1&lt;/code&gt; の場合、文字は &lt;code&gt;\x{&lt;/code&gt; H ... &lt;code&gt;}&lt;/code&gt; の形式で出力されます。それ以外の場合はUTF-8（非インタラクティブ端末の場合： &quot;oldshell&quot;または &quot;noshell&quot;）または文字を適切に表示するのに適したもの（インタラクティブ端末の場合：通常のシェル）。</target>
        </trans-unit>
        <trans-unit id="917f1b5ccc007e44df82f5ad9e8e418e0762f6b0" translate="yes" xml:space="preserve">
          <source>The Unicode support is controlled by both command-line switches, some standard environment variables, and the OTP version you are using. Most options affect mainly how Unicode data is displayed, not the functionality of the APIs in the standard libraries. This means that Erlang programs usually do not need to concern themselves with these options, they are more for the development environment. An Erlang program can be written so that it works well regardless of the type of system or the Unicode options that are in effect.</source>
          <target state="translated">Unicode のサポートは、コマンドラインスイッチ、いくつかの標準環境変数、使用している OTP のバージョンの両方によって制御されます。ほとんどのオプションは主にUnicodeデータがどのように表示されるかに影響を与え、標準ライブラリのAPIの機能には影響を与えません。つまり、Erlangプログラムは通常これらのオプションを気にする必要はありません。Erlangプログラムはシステムの種類やUnicodeオプションに関係なくうまく動作するように書くことができます。</target>
        </trans-unit>
        <trans-unit id="9e4f13026f64ec5f7cdd6285c03d5258bacc1cd2" translate="yes" xml:space="preserve">
          <source>The Unicode translation modifier &lt;code&gt;t&lt;/code&gt; specifies how to treat characters outside the Latin-1 range of codepoints, in atoms, strings, and binaries. For example, printing an atom containing a character &amp;gt; 255:</source>
          <target state="translated">Unicode変換修飾子 &lt;code&gt;t&lt;/code&gt; は、Latin-1のコードポイントの範囲外にある文字を、アトム、文字列、バイナリで処理する方法を指定します。たとえば、255を超える文字を含むアトムを印刷します。</target>
        </trans-unit>
        <trans-unit id="e24a7d795c65b90caaa133aaf71048aad49fb98e" translate="yes" xml:space="preserve">
          <source>The Unicode translation modifier works as with &lt;code&gt;s&lt;/code&gt;:</source>
          <target state="translated">Unicode変換修飾子は &lt;code&gt;s&lt;/code&gt; と同様に機能します。</target>
        </trans-unit>
        <trans-unit id="b61b21ce88bdc4622a6b58534472bd97a7d6b6d9" translate="yes" xml:space="preserve">
          <source>The Unix &lt;code&gt;DISPLAY&lt;/code&gt; environment variable is to be set to the display of the master node.</source>
          <target state="translated">Unix &lt;code&gt;DISPLAY&lt;/code&gt; 環境変数は、マスターノードのディスプレイに設定されます。</target>
        </trans-unit>
        <trans-unit id="7580a1c9657bbaca0bea72d41a48c1a2c9f178ef" translate="yes" xml:space="preserve">
          <source>The VM performs tail call optimization, which does not add new entries to the stacktrace, and also limits stacktraces to a certain depth. Furthermore, compiler options, optimizations and future changes may add or remove stacktrace entries, causing any code that expects the stacktrace to be in a certain order or contain specific items to fail.</source>
          <target state="translated">VM はテールコール最適化を実行し、スタックトレースに新しいエントリを追加せず、スタックトレースを一定の深さに制限します。さらに、コンパイラのオプション、最適化、および将来の変更により、スタックトレースのエントリが追加されたり削除されたりする可能性があり、スタックトレースが特定の順序であることや特定の項目を含むことを期待するコードはすべて失敗します。</target>
        </trans-unit>
        <trans-unit id="36921b8c054120393af51df837412dde5ebe77c2" translate="yes" xml:space="preserve">
          <source>The VM with SMP support makes quite a heavy use of atomic memory operations. An implementation providing native atomic memory operations is therefore very important when building Erlang/OTP. By default the VM will refuse to build if native atomic memory operations are not available.</source>
          <target state="translated">SMPをサポートしているVMはアトミックメモリ操作を多用します。したがって、ネイティブのアトミックメモリ操作を提供する実装はErlang/OTPをビルドする際に非常に重要です。デフォルトでは、ネイティブのアトミックメモリ操作が利用できない場合、VMはビルドを拒否します。</target>
        </trans-unit>
        <trans-unit id="883c00fb93b6833f40d7fa937a519315da18d85d" translate="yes" xml:space="preserve">
          <source>The View Module window displays the contents of an interpreted module and makes it possible to set breakpoints.</source>
          <target state="translated">View Module ウィンドウは、解釈されたモジュールの内容を表示し、ブレークポイントを設定することができます。</target>
        </trans-unit>
        <trans-unit id="818a2a38b6d37966404b0037603dc28865b80d3d" translate="yes" xml:space="preserve">
          <source>The Windows messages are retrieved from the eventlog file.</source>
          <target state="translated">Windows メッセージは eventlog ファイルから取得されます。</target>
        </trans-unit>
        <trans-unit id="1ef81693a27626a4d31fec58f2301060476cd06b" translate="yes" xml:space="preserve">
          <source>The Windows system is rebooted whenever the emulator stops (a more simple form of watchdog). This can be useful for less critical systems, otherwise use the heart functionality to accomplish this.</source>
          <target state="translated">Windows システムは、エミュレータが停止するたびに再起動されます (ウォッチドッグのより簡単な形式です)。これは重要度の低いシステムに便利ですが、そうでない場合はハート機能を使用してください。</target>
        </trans-unit>
        <trans-unit id="66afd9d96a38a37c4f7f94ff1bd05dfee703afea" translate="yes" xml:space="preserve">
          <source>The XML version shown earlier can also be used, but it is to be explicitly specified that the &lt;code&gt;ct_config_xml&lt;/code&gt; callback module is to be used by &lt;code&gt;Common Test&lt;/code&gt;.</source>
          <target state="translated">前に示したXMLバージョンも使用できますが、 &lt;code&gt;ct_config_xml&lt;/code&gt; コールバックモジュールが &lt;code&gt;Common Test&lt;/code&gt; で使用されることを明示的に指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="252a4b864e9fb6b863b0c8c232185b5a96bbfa1c" translate="yes" xml:space="preserve">
          <source>The \A, \Z, and \z assertions differ from the traditional circumflex and dollar (described in the next section) in that they only ever match at the very start and end of the subject string, whatever options are set. Thus, they are independent of multiline mode. These three assertions are not affected by options &lt;code&gt;notbol&lt;/code&gt; or &lt;code&gt;noteol&lt;/code&gt;, which affect only the behavior of the circumflex and dollar metacharacters. However, if argument &lt;code&gt;startoffset&lt;/code&gt; of &lt;code&gt;&lt;a href=&quot;#run-3&quot;&gt;run/3&lt;/a&gt;&lt;/code&gt; is non-zero, indicating that matching is to start at a point other than the beginning of the subject, \A can never match. The difference between \Z and \z is that \Z matches before a newline at the end of the string and at the very end, while \z matches only at the end.</source>
          <target state="translated">\ A、\ Z、および\ zアサーションは、オプションが設定されていても、サブジェクト文字列の最初と最後でのみ一致するという点で、従来のサーカムフレックスおよびドル（次のセクションで説明）とは異なります。したがって、これらはマルチラインモードから独立しています。これらの3つのアサーションは、サーカムフレックスとドルのメタキャラクターの動作のみに影響を与えるオプション &lt;code&gt;notbol&lt;/code&gt; または &lt;code&gt;noteol&lt;/code&gt; の影響を受けません。ただし、 &lt;code&gt;&lt;a href=&quot;#run-3&quot;&gt;run/3&lt;/a&gt;&lt;/code&gt; の引数 &lt;code&gt;startoffset&lt;/code&gt; がゼロ以外であり、一致が件名の先頭以外の場所から始まることを示している場合、\ Aは決して一致できません。 \ Zと\ zの違いは、\ Zは文字列の最後と最後の改行の前で一致するのに対し、\ zは最後でのみ一致することです。</target>
        </trans-unit>
        <trans-unit id="943d4453f30bb5749d0c52004563365b21bda38a" translate="yes" xml:space="preserve">
          <source>The \C escape sequence</source>
          <target state="translated">The ¶ The C escape sequence</target>
        </trans-unit>
        <trans-unit id="4f34ba1108b5cb6716129944fbf4f4329a0a6235" translate="yes" xml:space="preserve">
          <source>The \C escape sequence is best avoided. However, one way of using it that avoids the problem of malformed UTF characters is to use a lookahead to check the length of the next character, as in the following pattern, which can be used with a UTF-8 string (ignore whitespace and line breaks):</source>
          <target state="translated">C エスケープシーケンスは避けた方がよいでしょう。しかし、不正な UTF 文字の問題を回避する方法の一つとして、次のパターンのように、ルックヘッドを使って次の文字の長さをチェックする方法があります。</target>
        </trans-unit>
        <trans-unit id="c3ea67e0b67cb019dc5aaa8e95c03b5cb7572754" translate="yes" xml:space="preserve">
          <source>The \G assertion is true only when the current matching position is at the start point of the match, as specified by argument &lt;code&gt;startoffset&lt;/code&gt; of &lt;code&gt;run/3&lt;/code&gt;. It differs from \A when the value of &lt;code&gt;startoffset&lt;/code&gt; is non-zero. By calling &lt;code&gt;run/3&lt;/code&gt; multiple times with appropriate arguments, you can mimic the Perl option &lt;code&gt;/g&lt;/code&gt;, and it is in this kind of implementation where \G can be useful.</source>
          <target state="translated">\ Gアサーションは、 &lt;code&gt;run/3&lt;/code&gt; の引数 &lt;code&gt;startoffset&lt;/code&gt; で指定されているように、現在の一致位置が一致の開始点にある場合にのみ真になります。 &lt;code&gt;startoffset&lt;/code&gt; の値がゼロ以外の場合、\ Aとは異なります。適切な引数を指定して &lt;code&gt;run/3&lt;/code&gt; を複数回呼び出すことにより、Perlオプション &lt;code&gt;/g&lt;/code&gt; を模倣できます。この種の実装では、\ Gが役立ちます。</target>
        </trans-unit>
        <trans-unit id="2f7f1b350c6833ef257bc14bd5940d6dff8095f3" translate="yes" xml:space="preserve">
          <source>The \Q...\E sequence is recognized both inside and outside character classes. An isolated \E that is not preceded by \Q is ignored. If \Q is not followed by \E later in the pattern, the literal interpretation continues to the end of the pattern (that is, \E is assumed at the end). If the isolated \Q is inside a character class, this causes an error, as the character class is not terminated.</source>
          <target state="translated">The \Q...\E sequence is recognized both inside and outside character class.A isolated \E that is not preceded by \Q is ignored.If \Q is not followed by \E later in the pattern,the literal interpretation continues to the end of the pattern (すなわち、最後に\E is assumed at the end)。孤立した\\Qが文字クラスの中にある場合は、文字クラスが終了しないため、エラーとなる。</target>
        </trans-unit>
        <trans-unit id="14658b1c2056da1457d1137feae50fbf03cef97b" translate="yes" xml:space="preserve">
          <source>The \R escape sequence</source>
          <target state="translated">The ¶ The R escape sequence</target>
        </trans-unit>
        <trans-unit id="4253fcd6879a11eec01b435167179d5e15f76711" translate="yes" xml:space="preserve">
          <source>The \X escape matches any number of Unicode characters that form an &quot;extended grapheme cluster&quot;, and treats the sequence as an atomic group (see below). Up to and including release 8.31, PCRE matched an earlier, simpler definition that was equivalent to &lt;code&gt;(?&amp;gt;\PM\pM*)&lt;/code&gt;. That is, it matched a character without the &quot;mark&quot; property, followed by zero or more characters with the &quot;mark&quot; property. Characters with the &quot;mark&quot; property are typically non-spacing accents that affect the preceding character.</source>
          <target state="translated">\ Xエスケープは、「拡張書記素クラスター」を形成する任意の数のUnicode文字と一致し、シーケンスをアトミックグループとして扱います（以下を参照）。リリース8.31までは、PCREは &lt;code&gt;(?&amp;gt;\PM\pM*)&lt;/code&gt; に相当する以前のより簡単な定義に一致していました。つまり、「mark」プロパティのない文字に一致し、その後に「mark」プロパティのあるゼロ個以上の文字が続きました。 「マーク」プロパティを持つ文字は、通常、前の文字に影響を与える非間隔アクセントです。</target>
        </trans-unit>
        <trans-unit id="fe0ff3b7597c9ca177e61f2b7394c84224900254" translate="yes" xml:space="preserve">
          <source>The \X escape sequence</source>
          <target state="translated">The X escape sequence</target>
        </trans-unit>
        <trans-unit id="1a667df5d1564a7cf0ddb2cbecc475bdb5eb483f" translate="yes" xml:space="preserve">
          <source>The \c facility was designed for use with ASCII characters, but with the extension to Unicode it is even less useful than it once was.</source>
          <target state="translated">c施設は、ASCII文字で使用するために設計されていましたが、Unicodeに拡張されたことで、かつてよりもさらに使い勝手が悪くなっています。</target>
        </trans-unit>
        <trans-unit id="269d02430fd6e138cda2800d0af71fa652dd1cf5" translate="yes" xml:space="preserve">
          <source>The ability to globally register names is a central concept in the programming of distributed Erlang systems. In this module, the equivalent of the &lt;code&gt;register/2&lt;/code&gt; and &lt;code&gt;whereis/1&lt;/code&gt; BIFs (for local name registration) are provided, but for a network of Erlang nodes. A registered name is an alias for a process identifier (pid). The global name server monitors globally registered pids. If a process terminates, the name is also globally unregistered.</source>
          <target state="translated">名前をグローバルに登録する機能は、分散Erlangシステムのプログラミングにおける中心的な概念です。このモジュールでは、 &lt;code&gt;register/2&lt;/code&gt; および &lt;code&gt;whereis/1&lt;/code&gt; BIF（ローカル名登録用）に相当するものが提供されていますが、Erlangノードのネットワーク用です。登録名は、プロセス識別子（pid）のエイリアスです。グローバルネームサーバーは、グローバルに登録されたPIDを監視します。プロセスが終了すると、名前もグローバルに登録解除されます。</target>
        </trans-unit>
        <trans-unit id="2cc8577a293410d9b2b2308f91ef8c7aeb7972a3" translate="yes" xml:space="preserve">
          <source>The ability to have nested transaction with identical semantics as top-level transaction makes it easier to write library functions that manipulate &lt;code&gt;Mnesia&lt;/code&gt; tables.</source>
          <target state="translated">最上位のトランザクションと同じセマンティクスでトランザクションをネストできるため、 &lt;code&gt;Mnesia&lt;/code&gt; テーブルを操作するライブラリ関数を簡単に作成できます。</target>
        </trans-unit>
        <trans-unit id="89a04008ab968f22c43827dcb1f3ef8218af459a" translate="yes" xml:space="preserve">
          <source>The ability to reconfigure the system without stopping or suspending it.</source>
          <target state="translated">停止・中断せずに再設定できること。</target>
        </trans-unit>
        <trans-unit id="129e9c30a42ceaac73e62bd0dcc82cdd40af7c03" translate="yes" xml:space="preserve">
          <source>The above commands give a bit more information than the exact answers, but adequate information when manually searching for answers to these questions.</source>
          <target state="translated">上記のコマンドでは、正確な答えよりも少し多くの情報が得られますが、これらの質問に対する答えを手動で検索する場合には十分な情報が得られます。</target>
        </trans-unit>
        <trans-unit id="45b0784fdfa3b2b86ccd9506530ebe25156cc75c" translate="yes" xml:space="preserve">
          <source>The above domains are used for logs originating from Erlang/OTP. D1 specifies that the log event comes from Erlang/OTP in general, and D2 indicates that the log event is a so called &lt;code&gt;&lt;a href=&quot;logger_chapter#sasl_reports&quot;&gt;SASL report&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">上記のドメインは、Erlang / OTPからのログに使用されます。D1はログイベントが一般的にErlang / OTPからのものであることを指定し、D2はログイベントがいわゆる &lt;code&gt;&lt;a href=&quot;logger_chapter#sasl_reports&quot;&gt;SASL report&lt;/a&gt;&lt;/code&gt; あることを示します。</target>
        </trans-unit>
        <trans-unit id="4ad528c9654cb6b91e6a15396b85e360c22694a9" translate="yes" xml:space="preserve">
          <source>The above function specification uses multiple occurrences of the same type variable. That provides more type information than the following function specification, where the type variables are missing:</source>
          <target state="translated">上記の関数仕様では、同じ型変数を複数回使用しています。これは、型変数が欠落している以下の関数仕様よりも多くの型情報を提供します。</target>
        </trans-unit>
        <trans-unit id="6b3999c12af345ea4567453a651d6ad765544220" translate="yes" xml:space="preserve">
          <source>The above line will create a &lt;code&gt;TAGS&lt;/code&gt; file covering all the Erlang source files in the current directory, and in the subdirectories below.</source>
          <target state="translated">上記の行は、現在のディレクトリと以下のサブディレクトリにあるすべてのErlangソースファイルをカバーする &lt;code&gt;TAGS&lt;/code&gt; ファイルを作成します。</target>
        </trans-unit>
        <trans-unit id="e341eaf056f6757aa8744bf39e8ccfa82e2460c2" translate="yes" xml:space="preserve">
          <source>The above problem can also be solved as follows:</source>
          <target state="translated">また、上記の問題は以下のように解くことができます。</target>
        </trans-unit>
        <trans-unit id="492aee09cf585dc36dd1c47f1f73ebd941b86f64" translate="yes" xml:space="preserve">
          <source>The above publications can be found at &lt;code&gt;&lt;a href=&quot;http://www.ietf.org&quot;&gt;IETF&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">上記の出版物は &lt;code&gt;&lt;a href=&quot;http://www.ietf.org&quot;&gt;IETF&lt;/a&gt;&lt;/code&gt; にあります。</target>
        </trans-unit>
        <trans-unit id="425de3e4a3c3f31918aace8062226e8cca18ed8a" translate="yes" xml:space="preserve">
          <source>The above return value and output after the call to &lt;code&gt;release_handler:install_release/1&lt;/code&gt; means that the &lt;code&gt;release_handler&lt;/code&gt; has restarted the node by using &lt;code&gt;heart&lt;/code&gt;. This is always done when the upgrade involves a change of the applications ERTS, Kernel, STDLIB, or SASL. For more information, see &lt;code&gt;&lt;a href=&quot;upgrade&quot;&gt;Upgrade when Erlang/OTP has Changed&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">上記の戻り値と &lt;code&gt;release_handler:install_release/1&lt;/code&gt; の呼び出し後の出力は、 &lt;code&gt;release_handler&lt;/code&gt; が &lt;code&gt;heart&lt;/code&gt; を使用してノードを再起動したことを意味します。これは、アップグレードにアプリケーションERTS、カーネル、STDLIB、またはSASLの変更が含まれる場合に常に行われます。詳細については、「 &lt;code&gt;&lt;a href=&quot;upgrade&quot;&gt;Upgrade when Erlang/OTP has Changed&lt;/a&gt;&lt;/code&gt; 」を参照してください。</target>
        </trans-unit>
        <trans-unit id="782b35684c4c327f6b3806c4707f7ff71cfb9ed8" translate="yes" xml:space="preserve">
          <source>The above slogan is one of the more common reasons for Erlang to terminate. For unknown reasons the Erlang Run-Time System failed to allocate memory to use. When this happens a crash dump is generated that contains information about the state of the system as it ran out of mmeory. Use the &lt;code&gt;crashdump_viewer&lt;/code&gt; to get a view of the memory is being used. Look for processes with large heaps or many messages, large ets tables, etc.</source>
          <target state="translated">上記のスローガンは、Erlangが終了する最も一般的な理由の1つです。不明な理由により、Erlangランタイムシステムは使用するメモリの割り当てに失敗しました。これが発生すると、システムがmmeoryを使い果たしたときのシステムの状態に関する情報を含むクラッシュダンプが生成されます。 &lt;code&gt;crashdump_viewer&lt;/code&gt; を使用して、使用されているメモリのビューを取得します。大きなヒープまたは多くのメッセージ、大きなetsテーブルなどを持つプロセスを探します。</target>
        </trans-unit>
        <trans-unit id="a934d4536371eb6354c38319c0a6fa99eadfdfc1" translate="yes" xml:space="preserve">
          <source>The absence of warnings does not mean that there are no remaining errors in the code.</source>
          <target state="translated">警告がないということは、コードにエラーが残っていないということではありません。</target>
        </trans-unit>
        <trans-unit id="52e22f3960de9276ce93c1885ad7150854270f91" translate="yes" xml:space="preserve">
          <source>The absolute path of directory &lt;code&gt;chat_server/ebin&lt;/code&gt; is here passed to the code server. This is essential because relative paths are stored by the code server as relative, and &lt;code&gt;Common Test&lt;/code&gt; changes the current working directory of ERTS during the test run.</source>
          <target state="translated">ここで、ディレクトリ &lt;code&gt;chat_server/ebin&lt;/code&gt; の絶対パスがコードサーバーに渡されます。相対パスはコードサーバーによって相対パスとして格納され、 &lt;code&gt;Common Test&lt;/code&gt; はテスト実行中にERTSの現在の作業ディレクトリを変更するため、これは不可欠です。</target>
        </trans-unit>
        <trans-unit id="5539aa6980c3b1d4dc664f3e80f8e7768512fe3a" translate="yes" xml:space="preserve">
          <source>The absolute point in time, the timer is set to expire on, must be in the interval &lt;code&gt;[&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;#system_info_start_time&quot;&gt;erlang:system_info(start_time)&lt;/a&gt;&lt;/code&gt;&lt;code&gt;,&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;#system_info_end_time&quot;&gt;erlang:system_info(end_time)&lt;/a&gt;&lt;/code&gt;&lt;code&gt;]&lt;/code&gt;. If a relative time is specified, the &lt;code&gt;Time&lt;/code&gt; value is not allowed to be negative.</source>
          <target state="translated">タイマーの有効期限が切れるように設定されている絶対的な時点。 &lt;code&gt;[&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;#system_info_start_time&quot;&gt;erlang:system_info(start_time)&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;#system_info_end_time&quot;&gt;erlang:system_info(end_time)&lt;/a&gt;&lt;/code&gt; （start_time） &lt;code&gt;,&lt;/code&gt; erlang：system_info（end_time） &lt;code&gt;]&lt;/code&gt; の範囲内である必要があります。相対時間を指定する場合、 &lt;code&gt;Time&lt;/code&gt; 値を負にすることはできません。</target>
        </trans-unit>
        <trans-unit id="e18029dc4fbc0a03d56e79bb7184953e3744a063" translate="yes" xml:space="preserve">
          <source>The abstract layer (defined in &lt;code&gt;&lt;a href=&quot;erl_syntax&quot;&gt;erl_syntax&lt;/a&gt;&lt;/code&gt;) is nicely structured and the node types are context-independent. The layer makes it possible to transparently attach source-code comments and user annotations to nodes of the tree. Using the abstract layer makes applications less sensitive to changes in the &lt;code&gt;erl_parse(3)&lt;/code&gt; data structures, only requiring the &lt;code&gt;erl_syntax&lt;/code&gt; module to be up-to-date.</source>
          <target state="translated">抽象レイヤー（ &lt;code&gt;&lt;a href=&quot;erl_syntax&quot;&gt;erl_syntax&lt;/a&gt;&lt;/code&gt; で定義）は適切に構造化されており、ノードタイプはコンテキストに依存しません。このレイヤーにより、ソースコードのコメントとユーザーの注釈をツリーのノードに透過的にアタッチできます。抽象層を使用すると、アプリケーションは &lt;code&gt;erl_parse(3)&lt;/code&gt; データ構造の変更に対する感度が低くなり、 &lt;code&gt;erl_syntax&lt;/code&gt; モジュールを最新にするだけで済みます。</target>
        </trans-unit>
        <trans-unit id="4ebbf813506aec9cb5b7febd24547c187a92185e" translate="yes" xml:space="preserve">
          <source>The accepted socket inherits the options set for &lt;code&gt;ListenSocket&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;#listen-2&quot;&gt;listen/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">受け入れられたソケットは、 &lt;code&gt;&lt;a href=&quot;#listen-2&quot;&gt;listen/2&lt;/a&gt;&lt;/code&gt; の &lt;code&gt;ListenSocket&lt;/code&gt; に設定されたオプションを継承します。</target>
        </trans-unit>
        <trans-unit id="f6c1f48a70d3a03fcd08b9ecaf840df566c82062" translate="yes" xml:space="preserve">
          <source>The ack_action() is either:</source>
          <target state="translated">ack_action()はどちらかです。</target>
        </trans-unit>
        <trans-unit id="4df5499b046a3caa5c00b3bf34cda3b59c95dee6" translate="yes" xml:space="preserve">
          <source>The ack_data() argument to this function is the Erlang term returned by handle_trans_request/3.</source>
          <target state="translated">この関数の ack_data()引数は handle_trans_request/3 が返す Erlang 項です。</target>
        </trans-unit>
        <trans-unit id="573fc48700bb83712fa26ae3db5f4a997f5bdf7a" translate="yes" xml:space="preserve">
          <source>The action to take when the Erlang emulator stops unexpectedly. Default is to ignore.</source>
          <target state="translated">Erlangエミュレータが予期せず停止したときのアクション。デフォルトは無視です。</target>
        </trans-unit>
        <trans-unit id="40fdcbc6206b95ef9655638b626a5128e3d5dc2c" translate="yes" xml:space="preserve">
          <source>The actual encoded messages have been collected in one directory per encoding type, containing one file per encoded message.</source>
          <target state="translated">実際のエンコードされたメッセージは、エンコードタイプごとに1つのディレクトリに集められ、エンコードされたメッセージごとに1つのファイルが含まれています。</target>
        </trans-unit>
        <trans-unit id="bbf119f15e4a3e4c9e43ba3da03845ee142277be" translate="yes" xml:space="preserve">
          <source>The actual message returned by the RPC server is a 2-tuple &lt;code&gt;{rex,Reply}&lt;/code&gt;. If you use &lt;code&gt;erl_rpc_from()&lt;/code&gt; in your code, this is the message you will need to parse. If you use &lt;code&gt;erl_rpc()&lt;/code&gt;, the tuple itself is parsed for you, and the message returned to your program is the Erlang term containing &lt;code&gt;Reply&lt;/code&gt; only. Replies to RPC requests are always &lt;code&gt;ERL_SEND&lt;/code&gt; messages.</source>
          <target state="translated">RPCサーバーから返される実際のメッセージは、2タプルの &lt;code&gt;{rex,Reply}&lt;/code&gt; です。コードで &lt;code&gt;erl_rpc_from()&lt;/code&gt; を使用する場合、これは解析する必要があるメッセージです。 &lt;code&gt;erl_rpc()&lt;/code&gt; を使用すると、タプル自体が解析され、プログラムに返されるメッセージは、 &lt;code&gt;Reply&lt;/code&gt; のみを含むErlang用語になります。RPC要求への &lt;code&gt;ERL_SEND&lt;/code&gt; は常にERL_SENDメッセージです。</target>
        </trans-unit>
        <trans-unit id="3f712073d78ceb80ba4691c57506456b575aeca2" translate="yes" xml:space="preserve">
          <source>The actual number of fragments</source>
          <target state="translated">実際のフラグメント数</target>
        </trans-unit>
        <trans-unit id="4322cef184ec5aecf9faa18423df4ee550bc1ca0" translate="yes" xml:space="preserve">
          <source>The actual supervision of execution times is in itself a CPU intensive activity. A message is written on the trace file for every function call that is made by the profiled code.</source>
          <target state="translated">実行時間の実際の監視は、それ自体がCPUを集中的に使用する活動です。プロファイリングされたコードによって行われる関数呼び出しごとに、トレースファイルにメッセージが書き込まれます。</target>
        </trans-unit>
        <trans-unit id="4d3571545f798bc55c8050de98e521a38384a9d2" translate="yes" xml:space="preserve">
          <source>The actual timer time.</source>
          <target state="translated">実際のタイマーの時間。</target>
        </trans-unit>
        <trans-unit id="27345ee3cabb8f446fd8fd55e223fda324b5bab0" translate="yes" xml:space="preserve">
          <source>The actual value is the quoted atom &lt;code&gt;'NULL'&lt;/code&gt;.</source>
          <target state="translated">実際の値は、引用符で囲まれたアトム &lt;code&gt;'NULL'&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="c72f4263f7e8c1e5785af3ae16a212b694d638c6" translate="yes" xml:space="preserve">
          <source>The address and port of the other end of the connection.</source>
          <target state="translated">接続の相手側のアドレスとポート。</target>
        </trans-unit>
        <trans-unit id="5ae3afdabf8d69b7f030903f34729a4d0a97bc17" translate="yes" xml:space="preserve">
          <source>The address must be the IP address and cannot be the hostname.</source>
          <target state="translated">アドレスはIPアドレスでなければならず、ホスト名にすることはできません。</target>
        </trans-unit>
        <trans-unit id="45c66a6604fd97ae44d5625424f5836d3c3179c8" translate="yes" xml:space="preserve">
          <source>The address of the fun's code when HiPE is enabled.</source>
          <target state="translated">HiPEが有効になっているときのファンのコードのアドレス。</target>
        </trans-unit>
        <trans-unit id="7ddf5f9487a859a28b6ed4d37dd3d9bebe9f2f6a" translate="yes" xml:space="preserve">
          <source>The address of the fun's code.</source>
          <target state="translated">ファンのコードのアドレス。</target>
        </trans-unit>
        <trans-unit id="7e8bf572fd0f0bc243c5923805f5fb20ef2fe37e" translate="yes" xml:space="preserve">
          <source>The address specified in &lt;code&gt;&lt;a href=&quot;#send-3&quot;&gt;send&lt;/a&gt;&lt;/code&gt; overwrites the primary peer address</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#send-3&quot;&gt;send&lt;/a&gt;&lt;/code&gt; で指定されたアドレスは、プライマリピアアドレスを上書きします</target>
        </trans-unit>
        <trans-unit id="ba449fc5f30a23d575fa4c4396e275fa504dce46" translate="yes" xml:space="preserve">
          <source>The adjustment of system time could have been made smother than using a time warp approach, but we think that would be a bad choice. As we can express and measure time that is not connected to calendar time by the use of Erlang monotonic time, it is better to expose the change in Erlang system time immediately. This as the Erlang applications executing on the system can react on the change in system time as soon as possible. This is also more or less exactly how most operating systems handle this (OS monotonic time and OS system time). By adjusting system time smoothly, we would just hide the fact that system time changed and make it harder for the Erlang applications to react to the change in a sensible way.</source>
          <target state="translated">システム時間の調整は、タイムワープのアプローチを使うよりももっとスムーズにできたかもしれませんが、それは悪い選択だと考えています。Erlangのモノトニックタイムを使うことでカレンダータイムとは関係のない時間を表現したり計測したりすることができるので、Erlangのシステムタイムの変化はすぐに公開した方が良いでしょう。システム上で実行しているErlangアプリケーションはシステム時間の変化にすぐに反応することができるからです。これはほとんどのオペレーティングシステムがどのように処理しているかというと(OSのモノトニックタイムとOSのシステムタイム)です。システム時間をスムーズに調整することで、システム時間が変化したことを隠してしまい、Erlangアプリケーションがその変化に反応するのを難しくしてしまいます。</target>
        </trans-unit>
        <trans-unit id="5f9472dc1436a5862ca0454404828318f9e56d1f" translate="yes" xml:space="preserve">
          <source>The advantage of using an extensible (agent/manager) toolkit is to remove details such as type-checking, access rights, Protocol Data Unit (PDU), encoding, decoding, and trap distribution from the programmer, who only has to write the instrumentation functions, which implement the MIBs. The &lt;code&gt;get-next&lt;/code&gt; function only has to be implemented for tables, and not for every variable in the global naming tree. This information can be deduced from the ASN.1 file.</source>
          <target state="translated">拡張可能な（エージェント/マネージャー）ツールキットを使用する利点は、タイプチェック、アクセス権、プロトコルデータユニット（PDU）、エンコード、デコード、トラップ配布などの詳細をプログラマーから削除することです。 MIBを実装する関数。 &lt;code&gt;get-next&lt;/code&gt; 機能は、テーブルのみのためではなく、グローバル・ネーミングツリー内のすべての変数のために実装する必要があります。この情報は、ASN.1ファイルから推定できます。</target>
        </trans-unit>
        <trans-unit id="9fe8e4ddaca688413966f57d082a8c9a7e076fe3" translate="yes" xml:space="preserve">
          <source>The advantages of separating the table coordinator from the SNMP tool are:</source>
          <target state="translated">テーブルコーディネータとSNMPツールを分離するメリットは</target>
        </trans-unit>
        <trans-unit id="1e3ed41d7fd39c63d6b7f432ea91d01107779b41" translate="yes" xml:space="preserve">
          <source>The affected tables are write-locked during the restoration. However, regardless of the lock conflicts caused by this, the applications can continue to do their work while the restoration is being performed. The restoration is performed as one single transaction.</source>
          <target state="translated">影響を受けたテーブルは、リストア中に書き込みロックされます。しかし、これによるロックの競合に関係なく、アプリケーションはリストアが実行されている間、作業を継続することができます。復元は 1 つの単一トランザクションとして実行されます。</target>
        </trans-unit>
        <trans-unit id="eeb577e64047dee54287b4297431d9c8f5676c03" translate="yes" xml:space="preserve">
          <source>The age is defined in milliseconds.</source>
          <target state="translated">年齢はミリ秒単位で定義されています。</target>
        </trans-unit>
        <trans-unit id="e7020aa85de45cdbfd0f6571b7cc03a6fded1bbd" translate="yes" xml:space="preserve">
          <source>The agent and manager uses (application) configuration parameters to find out where these directories are located. The parameters should be defined in an Erlang system configuration file. The following configuration parameters are defined for the SNMP application:</source>
          <target state="translated">エージェントとマネージャは(アプリケーションの)設定パラメータを使って、これらのディレクトリがどこにあるかを見つけます。パラメータはErlangシステム設定ファイルで定義されていなければなりません。以下の設定パラメータはSNMPアプリケーションに定義されています。</target>
        </trans-unit>
        <trans-unit id="532498afa1ab407c6e18b6c76c06f1a8f9021335" translate="yes" xml:space="preserve">
          <source>The agent can be configured to be multi-threaded, to process one incoming request at a time, or to have a request limit enabled (this can be used for load control or to limit the effect of DoS attacks). If it is multi-threaded, read requests (&lt;code&gt;get&lt;/code&gt;, &lt;code&gt;get-next&lt;/code&gt; and &lt;code&gt;get-bulk&lt;/code&gt;) and traps are processed in parallel with each other and &lt;code&gt;set&lt;/code&gt; requests. However, all &lt;code&gt;set&lt;/code&gt; requests are serialized, which means that if the agent is waiting for the application to complete a complicated write operation, it will not process any new write requests until this operation is finished. It processes read requests and sends traps, concurrently. The reason for not handle write requests in parallel is that a complex locking mechanism would be needed even in the simplest cases. Even with the scheme described above, the user must be careful not to violate that the &lt;code&gt;set&lt;/code&gt; requests are atoms. If this is hard to do, do not use the multi-threaded feature.</source>
          <target state="translated">エージェントは、マルチスレッド、一度に1つの着信要求を処理する、または要求制限を有効にするように構成できます（これは、負荷制御やDoS攻撃の影響を制限するために使用できます）。マルチスレッドの場合、読み取り要求（ &lt;code&gt;get&lt;/code&gt; 、 &lt;code&gt;get-next&lt;/code&gt; 、 &lt;code&gt;get-bulk&lt;/code&gt; ）とトラップは互いに並行して処理され、要求を &lt;code&gt;set&lt;/code&gt; ます。ただし、すべての &lt;code&gt;set&lt;/code&gt; つまり、エージェントがアプリケーションが複雑な書き込み操作を完了するのを待っている場合、この操作が完了するまで、新しい書き込み要求は処理されません。読み取り要求を処理し、トラップを同時に送信します。書き込みリクエストを並行して処理しない理由は、最も単純なケースでも複雑なロックメカニズムが必要になるためです。上記のスキームでも、ユーザーは、 &lt;code&gt;set&lt;/code&gt; リクエストがアトムであることを違反しないように注意する必要があります。これが難しい場合は、マルチスレッド機能を使用しないでください。</target>
        </trans-unit>
        <trans-unit id="1765275ae72c3c73846eb96f701861af075a2ade" translate="yes" xml:space="preserve">
          <source>The agent can both perform and respond to discovery.</source>
          <target state="translated">エージェントは、ディスカバリーを実行することも、ディスカバリーに応答することもできます。</target>
        </trans-unit>
        <trans-unit id="5fab26e9897ff23218adb34fca8afc8ac6df806b" translate="yes" xml:space="preserve">
          <source>The agent can spontaneously send a notification, for example, an alarm, to the manager.</source>
          <target state="translated">エージェントは、自発的に、例えばアラームなどの通知を管理者に送信することができます。</target>
        </trans-unit>
        <trans-unit id="88e6c01b1d22bf1009d4f112f5ef241f146f87bc" translate="yes" xml:space="preserve">
          <source>The agent does not check complex ranges specified for INTEGER objects. In these cases it just checks that the value lies within the minimum and maximum values specified. For example, if the range is specified as &lt;code&gt;1..10 | 12..20&lt;/code&gt; the agent would let 11 through, but not 0 or 21. The instrumentation functions must check the complex ranges itself.</source>
          <target state="translated">エージェントは、INTEGERオブジェクトに指定された複雑な範囲をチェックしません。これらの場合、値が指定された最小値と最大値の範囲内にあることを確認するだけです。たとえば、範囲が &lt;code&gt;1..10 | 12..20&lt;/code&gt; として指定されている場合、12..20エージェントは11を通過させますが、0または21は通過させません。計測機能は、複雑な範囲自体をチェックする必要があります。</target>
        </trans-unit>
        <trans-unit id="821394aba5a85ee9b738eccc0b641e5e87f98f1d" translate="yes" xml:space="preserve">
          <source>The agent information should be stored in a file called &lt;code&gt;agent.conf&lt;/code&gt;.</source>
          <target state="translated">エージェント情報は、 &lt;code&gt;agent.conf&lt;/code&gt; というファイルに保存する必要があります。</target>
        </trans-unit>
        <trans-unit id="7d5c2b0ecab378b92db71d78b459615c0be2b937" translate="yes" xml:space="preserve">
          <source>The agent is an entity that executes within a &lt;strong&gt;Network Element (NE)&lt;/strong&gt;. In OTP, the NE can be a distributed system, meaning that the distributed system is managed as one entity. Of course, the agent can be configured to be able to run on one of several nodes, making it a distributed OTP application.</source>
          <target state="translated">エージェントは、&lt;strong&gt;ネットワーク要素（NE）&lt;/strong&gt;内で実行されるエンティティです。OTPでは、NEを分散システムにすることができます。つまり、分散システムは1つのエンティティとして管理されます。もちろん、エージェントは、いくつかのノードの1つで実行できるように構成して、分散OTPアプリケーションにすることができます。</target>
        </trans-unit>
        <trans-unit id="b3d395baa2a805befd96447c7ba7e7fb38c483ae" translate="yes" xml:space="preserve">
          <source>The agent is configured with the configuration tool, using default suggestions for everything but the manager node.</source>
          <target state="translated">エージェントは、マネージャノード以外のすべてのものにデフォルトの提案を使用して、設定ツールを使用して設定されます。</target>
        </trans-unit>
        <trans-unit id="bafc8c1a76725000dfff5c337a6c7efd569cd586" translate="yes" xml:space="preserve">
          <source>The agent is highly fault tolerant. If the manager gets an unexpected response from the agent, it is possible that some instrumentation function has returned an erroneous value. The agent will not crash even if the instrumentation does. It should be noted that if an instrumentation function enters an infinite loop, the agent will also be blocked forever. The supervisor ,or the application, specifies how to restart the agent.</source>
          <target state="translated">エージェントは高い耐障害性を持っています。マネージャがエージェントから予期しない応答を取得する場合、いくつかの計装機能が誤った値を返した可能性があります。インスツルメンテーションが発生してもエージェントがクラッシュすることはありません。インスツルメンテーション関数が無限ループに入ると、エージェントも永遠にブロックされることに注意する必要があります。スーパーバイザまたはアプリケーションは、エージェントを再起動する方法を指定します。</target>
        </trans-unit>
        <trans-unit id="2c7ad18cc20a9d278d188273b0ceb93f154abb8c" translate="yes" xml:space="preserve">
          <source>The agent receives a request and maps it to calls to one or more instrumentation functions. These functions perform operations on the resources to implement the semantics associated with the MO.</source>
          <target state="translated">エージェントはリクエストを受け取り、それを1つ以上のインストルメンテーション関数への呼び出しにマッピングする。これらの関数は、MOに関連付けられたセマンティクスを実装するために、リソー スに対する操作を実行する。</target>
        </trans-unit>
        <trans-unit id="5394a28e8aa26b89d2b8f393dd3cca2d7c380d89" translate="yes" xml:space="preserve">
          <source>The agent responds to discovery autonomously, without interaction by the user.</source>
          <target state="translated">エージェントは、ユーザーによる相互作用なしに、自律的に発見に応答します。</target>
        </trans-unit>
        <trans-unit id="ebd412ca77c13dc418b2ee47def2c221adc4c0fa" translate="yes" xml:space="preserve">
          <source>The agent started is called &lt;code&gt;snmp_master_agent&lt;/code&gt;. Use &lt;code&gt;&lt;a href=&quot;#load_mibs-1&quot;&gt;ct_snmp:load_mibs/1&lt;/a&gt;&lt;/code&gt; to load MIBs into the agent.</source>
          <target state="translated">開始されたエージェントは &lt;code&gt;snmp_master_agent&lt;/code&gt; と呼ばれます。 &lt;code&gt;&lt;a href=&quot;#load_mibs-1&quot;&gt;ct_snmp:load_mibs/1&lt;/a&gt;&lt;/code&gt; を使用して、MIBをエージェントにロードします。</target>
        </trans-unit>
        <trans-unit id="35fefa07539d964d08302d135b6a045a731feaec" translate="yes" xml:space="preserve">
          <source>The agent stores the values in an internal volatile database, which is based on the standard module &lt;code&gt;ets&lt;/code&gt;. However, it is possible to let the MIB compiler generate functions which use an internal, persistent database, or the Mnesia DBMS. Refer to the Mnesia User Guide and the Reference Manual, section SNMP, module &lt;code&gt;snmp_generic&lt;/code&gt; for more information.</source>
          <target state="translated">エージェントは、標準モジュール &lt;code&gt;ets&lt;/code&gt; に基づく内部の揮発性データベースに値を保存します。ただし、MIBコンパイラーに、内部の永続データベースまたはMnesia DBMSを使用する関数を生成させることは可能です。詳細については、MnesiaユーザーガイドとリファレンスマニュアルのセクションSNMP、モジュール &lt;code&gt;snmp_generic&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="88cd9d752952f90596dc3746023ba01fb085191a" translate="yes" xml:space="preserve">
          <source>The agent will never generate the &lt;code&gt;wrongEncoding&lt;/code&gt; error. If a variable binding is erroneous encoded, the &lt;code&gt;asn1ParseError&lt;/code&gt; counter will be incremented.</source>
          <target state="translated">エージェントが &lt;code&gt;wrongEncoding&lt;/code&gt; エラーを生成することはありません。変数バインディングが誤ってエンコードされている場合、 &lt;code&gt;asn1ParseError&lt;/code&gt; カウンターが増分されます。</target>
        </trans-unit>
        <trans-unit id="31dc2849b5514caeb8ae4f58e7cc8579c0d02b0d" translate="yes" xml:space="preserve">
          <source>The alarm handler is part of the SASL application.</source>
          <target state="translated">アラーム・ハンドラはSASLアプリケーションの一部です。</target>
        </trans-unit>
        <trans-unit id="f225b02b835111c249a55da204c91a4c1ca4bd60" translate="yes" xml:space="preserve">
          <source>The alarm handler process is a &lt;code&gt;gen_event&lt;/code&gt; event manager process that receives alarms in the system. This process is not intended to be a complete alarm handler. It defines a place to which alarms can be sent. One simple event handler is installed in the alarm handler at startup, but users are encouraged to write and install their own handlers.</source>
          <target state="translated">アラームハンドラプロセスは、システムでアラームを受信する &lt;code&gt;gen_event&lt;/code&gt; イベントマネージャプロセスです。このプロセスは、完全なアラームハンドラを意図したものではありません。アラームを送信できる場所を定義します。起動時にアラームハンドラーに1つの単純なイベントハンドラーがインストールされますが、ユーザーは独自のハンドラーを作成してインストールすることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="9a1c34ac82f222f7bf20fdb60c9c70070554269a" translate="yes" xml:space="preserve">
          <source>The alarms are cleared automatically when the alarm cause is no longer valid.</source>
          <target state="translated">アラーム原因が有効でなくなると、アラームは自動的にクリアされます。</target>
        </trans-unit>
        <trans-unit id="986d3b30b24eb7709dfdc0693fd6abc2a7ec4e8c" translate="yes" xml:space="preserve">
          <source>The algorithm for updating &lt;code&gt;Serial&lt;/code&gt; can be described as follows:</source>
          <target state="translated">&lt;code&gt;Serial&lt;/code&gt; を更新するアルゴリズムは、次のように説明できます。</target>
        </trans-unit>
        <trans-unit id="4dd9a185b05bfc6c5aca5b3488aeb8d588a949ea" translate="yes" xml:space="preserve">
          <source>The algorithm for wich the fun should implement the special matching rules</source>
          <target state="translated">お楽しみのアルゴリズムは、特別なマッチングルールを実装する必要があります。</target>
        </trans-unit>
        <trans-unit id="7bb19b504df5c1a9303c7a6f511b1fc2dc8c9766" translate="yes" xml:space="preserve">
          <source>The algorithm in &lt;code&gt;ssh_hostkey_fingerprint/1&lt;/code&gt; is md5 to be compatible with older ssh-keygen commands. The string from the second variant is prepended by the algorithm name in uppercase as in newer ssh-keygen commands.</source>
          <target state="translated">&lt;code&gt;ssh_hostkey_fingerprint/1&lt;/code&gt; のアルゴリズムはmd5で、古いssh-keygenコマンドと互換性があります。2番目のバリアントからの文字列は、新しいssh-keygenコマンドの場合と同様に、アルゴリズム名が大文字で先頭に追加されます。</target>
        </trans-unit>
        <trans-unit id="b2f989a67b5ca0281a96030c126b7a3d77ef6b31" translate="yes" xml:space="preserve">
          <source>The algorithm is a modification of the version attributed to Richard A. O'Keefe in the standard Prolog library.</source>
          <target state="translated">このアルゴリズムは、標準PrologライブラリのRichard A.O'Keefeに帰属するバージョンを修正したものです。</target>
        </trans-unit>
        <trans-unit id="7f680b0d6e8d6f4e75e82db44978468dc45a6e99" translate="yes" xml:space="preserve">
          <source>The algorithm is the same as for send above.</source>
          <target state="translated">アルゴリズムは上記のsendと同じです。</target>
        </trans-unit>
        <trans-unit id="230091aa46aa0a9b37e9fd8c10519ddfe76dd814" translate="yes" xml:space="preserve">
          <source>The algorithm that is used to draw a graph with as few crossed links as possible is called force graph. A force graph consists of nodes and directed links between nodes. Each node is associated with a repulsive force that pushes nodes away from each other. This force can be adjusted with the left slider or with the mouse wheel. Each link is associated with an attractive force that pulls the nodes nearer to each other. This force can be adjusted with the right slider. If this force becomes too strong, the graph will be unstable. The third parameter that can be adjusted is the length of the links. It is adjusted with the middle slider.</source>
          <target state="translated">交差するリンクをできるだけ少なくしてグラフを描くアルゴリズムをフォースグラフという。フォースグラフは、ノードとノード間の有向リンクで構成される。各ノードには、ノードを互いに遠ざける反発力が関連付けられています。この力は左のスライダーやマウスホイールで調整できます。各リンクは、ノードを互いに近くに引き寄せる魅力的な力に関連付けられています。この力は、右のスライダで調整できます。この力が強すぎると、グラフが不安定になります。3番目のパラメータはリンクの長さです。これは真ん中のスライダーで調整します。</target>
        </trans-unit>
        <trans-unit id="e0be3089ed3cdab42290e47bafffab640f5507bb" translate="yes" xml:space="preserve">
          <source>The algorithms should be in the preferred order. Selected signature algorithm can restrict which hash functions that may be selected. Default support for {md5, rsa} removed in ssl-8.0</source>
          <target state="translated">アルゴリズムは好ましい順序であることが望ましい。選択された署名アルゴリズムは、選択される可能性のあるハッシュ関数を制限することができます。ssl-8.0では{md5,rsa}のデフォルトサポートが削除されました。</target>
        </trans-unit>
        <trans-unit id="51bb3389ce8effbbb1e7082b3ae1de9569a30494" translate="yes" xml:space="preserve">
          <source>The algorithms specified by this option will be the ones accepted by the server in a signature algorithm negotiation, introduced in TLS-1.2. The algorithms will also be offered to the client if a client certificate is requested. For more details see the &lt;code&gt;&lt;a href=&quot;#client_signature_algs&quot;&gt;corresponding client option&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">このオプションで指定されたアルゴリズムは、TLS-1.2で導入された署名アルゴリズムネゴシエーションでサーバーが受け入れるアルゴリズムになります。アルゴリズムは、クライアント証明書が要求された場合にもクライアントに提供されます。詳細については、 &lt;code&gt;&lt;a href=&quot;#client_signature_algs&quot;&gt;corresponding client option&lt;/a&gt;&lt;/code&gt; 参照してください。</target>
        </trans-unit>
        <trans-unit id="5b2fe8210e9b69a3cc07735de1a6330b93954baa" translate="yes" xml:space="preserve">
          <source>The algoritm for modifications works like this:</source>
          <target state="translated">修正のためのアルゴリズムは次のように動作します。</target>
        </trans-unit>
        <trans-unit id="10574335a609a1059aa012db0f86b9ea475e61d4" translate="yes" xml:space="preserve">
          <source>The allocator types that will be searched. Defaults to all &lt;code&gt;alloc_util&lt;/code&gt; allocators.</source>
          <target state="translated">検索されるアロケータのタイプ。デフォルトはすべての &lt;code&gt;alloc_util&lt;/code&gt; アロケーターです。</target>
        </trans-unit>
        <trans-unit id="f7ed9195c9091feda9cc03849f91a3d0e1313381" translate="yes" xml:space="preserve">
          <source>The allowed &lt;code&gt;AccessMode&lt;/code&gt; of a table can be defined to be &lt;code&gt;read_only&lt;/code&gt; or &lt;code&gt;read_write&lt;/code&gt;. It can be toggled with the function &lt;code&gt;&lt;a href=&quot;mnesia#change_table_access_mode-2&quot;&gt;mnesia:change_table_access_mode(Tab, AccessMode)&lt;/a&gt;&lt;/code&gt; in runtime. &lt;code&gt;read_only&lt;/code&gt; tables and &lt;code&gt;local_content&lt;/code&gt; tables are always loaded locally, as there is no need for copying the table from other nodes. Other tables are primarily loaded remotely from active replicas on other nodes if the table has been loaded there already, or if the running &lt;code&gt;Mnesia&lt;/code&gt; has decided to load the table there already.</source>
          <target state="translated">テーブルの許可される &lt;code&gt;AccessMode&lt;/code&gt; は、 &lt;code&gt;read_only&lt;/code&gt; または &lt;code&gt;read_write&lt;/code&gt; として定義できます。実行時に関数 &lt;code&gt;&lt;a href=&quot;mnesia#change_table_access_mode-2&quot;&gt;mnesia:change_table_access_mode(Tab, AccessMode)&lt;/a&gt;&lt;/code&gt; で切り替えることができます。他のノードからテーブルをコピーする必要がないため、 &lt;code&gt;read_only&lt;/code&gt; テーブルと &lt;code&gt;local_content&lt;/code&gt; テーブルは常にローカルにロードされます。他のテーブルは、テーブルがすでにそこにロードされている場合、または実行中の &lt;code&gt;Mnesia&lt;/code&gt; がテーブルをすでにそこにロードすることを決定している場合、主に他のノードのアクティブなレプリカからリモートでロードされます。</target>
        </trans-unit>
        <trans-unit id="c9cd2b75bdb0d580c661ccb5efbc7ebe47d4aa8f" translate="yes" xml:space="preserve">
          <source>The allowed range is 1..256. Defaults to 1 for &lt;code&gt;integer&lt;/code&gt;, &lt;code&gt;float&lt;/code&gt;, and &lt;code&gt;bitstring&lt;/code&gt;, and to 8 for &lt;code&gt;binary&lt;/code&gt;. No unit specifier must be given for the types &lt;code&gt;utf8&lt;/code&gt;, &lt;code&gt;utf16&lt;/code&gt;, and &lt;code&gt;utf32&lt;/code&gt;.</source>
          <target state="translated">許容範囲は1..256です。 &lt;code&gt;integer&lt;/code&gt; 、 &lt;code&gt;float&lt;/code&gt; 、および &lt;code&gt;bitstring&lt;/code&gt; のデフォルトは1で、 &lt;code&gt;binary&lt;/code&gt; のデフォルトは8です。タイプ &lt;code&gt;utf8&lt;/code&gt; 、 &lt;code&gt;utf16&lt;/code&gt; 、および &lt;code&gt;utf32&lt;/code&gt; に単位指定子を指定する必要はありません。</target>
        </trans-unit>
        <trans-unit id="ad89fe4bac55bef5e612143241645e3f39f837c7" translate="yes" xml:space="preserve">
          <source>The allowed values for &lt;code&gt;Operation&lt;/code&gt; are:</source>
          <target state="translated">&lt;code&gt;Operation&lt;/code&gt; に許可される値は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="91eabbe1745620d58dbabfc6b149c475cb3f775e" translate="yes" xml:space="preserve">
          <source>The amount of dirty CPU schedulers is limited by the amount of normal schedulers in order to limit the effect on processes executing on ordinary schedulers. If the amount of dirty CPU schedulers was allowed to be unlimited, dirty CPU bound jobs would potentially starve normal jobs.</source>
          <target state="translated">ダーティCPUスケジューラの量は、通常のスケジューラ上で実行されるプロセスへの影響を制限するために、通常のスケジューラの量で制限されています。ダーティなCPUスケジューラの量を無制限にすると、ダーティなCPUバインドジョブは通常のジョブを飢餓状態にする可能性があります。</target>
        </trans-unit>
        <trans-unit id="27a9761aa8b41fe03707985ac819ffa2294674b4" translate="yes" xml:space="preserve">
          <source>The amount of dirty IO schedulers is not limited by the amount of normal schedulers &lt;code&gt;&lt;a href=&quot;#+SDcpu&quot;&gt;like the amount of dirty CPU schedulers&lt;/a&gt;&lt;/code&gt;. This since only I/O bound work is expected to execute on dirty I/O schedulers. If the user should schedule CPU bound jobs on dirty I/O schedulers, these jobs might starve ordinary jobs executing on ordinary schedulers.</source>
          <target state="translated">ダーティIOスケジューラ &lt;code&gt;&lt;a href=&quot;#+SDcpu&quot;&gt;like the amount of dirty CPU schedulers&lt;/a&gt;&lt;/code&gt; 通常のスケジューラの量によって制限されません。これは、I / Oバウンド作業のみがダーティI / Oスケジューラで実行されることが予想されるためです。ユーザーがダーティI / OスケジューラでCPUバインドジョブをスケジュールする必要がある場合、これらのジョブは通常のスケジューラで実行されている通常のジョブを枯渇させる可能性があります。</target>
        </trans-unit>
        <trans-unit id="664e7e56a2225929620ef872c0ebcd0c6fb9c4c1" translate="yes" xml:space="preserve">
          <source>The amount of free memory available to the Erlang emulator for allocation.</source>
          <target state="translated">Erlangエミュレータに割り当てられる空きメモリの量です。</target>
        </trans-unit>
        <trans-unit id="856f5380158f6d7ba56eebb6ae41011bd9432d40" translate="yes" xml:space="preserve">
          <source>The amount of memory available to the whole operating system. This may well be equal to &lt;code&gt;total_memory&lt;/code&gt; but not necessarily.</source>
          <target state="translated">オペレーティングシステム全体で使用可能なメモリの量。これは、 &lt;code&gt;total_memory&lt;/code&gt; に等しい場合がありますが、必ずしもそうであるとは限りません。</target>
        </trans-unit>
        <trans-unit id="177a7f5e407b489cea8a1c26cd218274ba08f36c" translate="yes" xml:space="preserve">
          <source>The amount of memory the system has available for disk swap.</source>
          <target state="translated">システムがディスクスワップのために利用可能なメモリの量。</target>
        </trans-unit>
        <trans-unit id="7656a9402d240df34705d7b544f4dff29a5abe83" translate="yes" xml:space="preserve">
          <source>The amount of memory the system uses for cached files read from disk.</source>
          <target state="translated">システムがディスクから読み込んだキャッシュファイルに使用するメモリ量。</target>
        </trans-unit>
        <trans-unit id="eee7cda7742ee86ae7d191faad9371151f0ebd25" translate="yes" xml:space="preserve">
          <source>The amount of memory the system uses for temporary storing raw disk blocks.</source>
          <target state="translated">生のディスクブロックを一時的に保存するためにシステムが使用するメモリの量。</target>
        </trans-unit>
        <trans-unit id="1082b666267c1d0a05f9d3fc735ec44903b5cce2" translate="yes" xml:space="preserve">
          <source>The amount of time that passes between a signal is sent and the arrival of the signal at the destination is unspecified but positive. If the receiver has terminated, the signal does not arrive, but it can trigger another signal. For example, a link signal sent to a non-existing process triggers an exit signal, which is sent back to where the link signal originated from. When communicating over the distribution, signals can be lost if the distribution channel goes down.</source>
          <target state="translated">信号が送信されてから送信先に信号が到着するまでの経過時間は、不特定ではあるが正である。受信機が終了した場合、信号は到着しないが、別の信号をトリガすることができる。例えば、存在しないプロセスに送信されたリンク信号は、終了信号をトリガし、その終了信号は、リンク信号が発信された場所に戻って送信される。ディストリビューションを介して通信する場合、ディストリビューションチャネルがダウンすると信号が失われる可能性があります。</target>
        </trans-unit>
        <trans-unit id="4519c04c3df5357f9581cfbf162358aa5fec4d97" translate="yes" xml:space="preserve">
          <source>The amount of total amount of memory the system has available for disk swap.</source>
          <target state="translated">システムがディスクスワップのために利用可能なメモリの総量です。</target>
        </trans-unit>
        <trans-unit id="784b5a2e886a3960b27831ea309171f77ba1c2b8" translate="yes" xml:space="preserve">
          <source>The amount of unused memory on each heap. This information is usually useless.</source>
          <target state="translated">各ヒープ上の未使用メモリの量。この情報は通常は役に立たない。</target>
        </trans-unit>
        <trans-unit id="eaa8449008b96acfc6b47fd80ac7ade7e1100e51" translate="yes" xml:space="preserve">
          <source>The analysis result can either be for all modules, or for one module. In either case a call count limit can be given to filter out the functions with a call count below the limit. The all modules analysis does &lt;strong&gt;not&lt;/strong&gt; contain the module &lt;code&gt;cprof&lt;/code&gt; itself, it can only be analysed by specifying it as a single module to analyse.</source>
          <target state="translated">分析結果は、すべてのモジュールの場合も、1つのモジュールの場合もあります。どちらの場合も、呼び出しカウント制限を指定して、呼び出しカウントが制限を下回る関数を除外できます。すべてのモジュール分析にはモジュール &lt;code&gt;cprof&lt;/code&gt; 自体&lt;strong&gt;は&lt;/strong&gt;含まれていませ&lt;strong&gt;ん&lt;/strong&gt;。分析する単一のモジュールとして指定することによってのみ分析できます。</target>
        </trans-unit>
        <trans-unit id="665b53498dfc4b5081b2898303b46c4e6c1e3b19" translate="yes" xml:space="preserve">
          <source>The analysis starts from an empty PLT and creates a new one from the files specified with &lt;code&gt;-c&lt;/code&gt; and &lt;code&gt;-r&lt;/code&gt;. This option only works for BEAM files. To override the default PLT location, use &lt;code&gt;--plt&lt;/code&gt; or &lt;code&gt;--output_plt&lt;/code&gt;.</source>
          <target state="translated">分析は空のPLTから始まり、 &lt;code&gt;-c&lt;/code&gt; および &lt;code&gt;-r&lt;/code&gt; で指定されたファイルから新しいPLTを作成します。このオプションは、BEAMファイルに対してのみ機能します。デフォルトのPLTの場所を上書きするには、-- &lt;code&gt;--plt&lt;/code&gt; または &lt;code&gt;--output_plt&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="cdcf511f2d0831631f6fdd22a140605914418760" translate="yes" xml:space="preserve">
          <source>The answer to the request is encoded to a UDP Protocol Data Unit (PDU).</source>
          <target state="translated">リクエストに対する応答はUDPプロトコルデータユニット(PDU)にエンコードされます。</target>
        </trans-unit>
        <trans-unit id="2bf1e9025d3f661f3470ed7afc4906eb1f7fc756" translate="yes" xml:space="preserve">
          <source>The answers are found by evaluating the qualifiers from left to right, backtracking when some filter returns &lt;code&gt;false&lt;/code&gt;, or collecting the template when all filters return &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">答えは、修飾子を左から右に評価し、一部のフィルターが &lt;code&gt;false&lt;/code&gt; を返したときにバックトラックするか、すべてのフィルターが &lt;code&gt;true&lt;/code&gt; を返したときにテンプレートを収集することで見つかります。</target>
        </trans-unit>
        <trans-unit id="f318a6ba118898a63239c22ec72006a08d5ca687" translate="yes" xml:space="preserve">
          <source>The application can be specified by its name &lt;code&gt;Application&lt;/code&gt;. In this case, the application controller searches the code path for the application resource file &lt;code&gt;Application.app&lt;/code&gt; and loads the specification it contains.</source>
          <target state="translated">アプリケーションは &lt;code&gt;Application&lt;/code&gt; という名前で指定できます。この場合、アプリケーションコントローラーは、アプリケーションリソースファイル &lt;code&gt;Application.app&lt;/code&gt; のコードパスを検索し、そこに含まれている仕様を読み込みます。</target>
        </trans-unit>
        <trans-unit id="620c94d66204ee923841db86e6b7d75bbdd11ef8" translate="yes" xml:space="preserve">
          <source>The application concept applies both to program structure (processes) and directory structure (modules).</source>
          <target state="translated">アプリケーションの概念は、プログラム構造(プロセス)とディレクトリ構造(モジュール)の両方に適用されます。</target>
        </trans-unit>
        <trans-unit id="f58d25a7007e6f3798c0b59bdfac842192b77950" translate="yes" xml:space="preserve">
          <source>The application controller automatically loads any included applications when loading a primary application, but does not start them. Instead, the top supervisor of the included application must be started by a supervisor in the including application.</source>
          <target state="translated">アプリケーションコントローラは、プライマリアプリケーションをロードする際に、すべてのインクルードアプリケーションを自動的にロードしますが、それらを起動することはありません。代わりに、インクルードされたアプリケーションのトップスーパバイザは、インクルードされたアプリケーションのスーパバイザによって起動されなければなりません。</target>
        </trans-unit>
        <trans-unit id="98f6f34774d04811ed29ee462b6732dccb9d0043" translate="yes" xml:space="preserve">
          <source>The application controller checks the value of the application specification key &lt;code&gt;applications&lt;/code&gt;, to ensure that all applications needed to be started before this application are running. Otherwise, &lt;code&gt;{error,{not_started,App}}&lt;/code&gt; is returned, where &lt;code&gt;App&lt;/code&gt; is the name of the missing application.</source>
          <target state="translated">アプリケーションコントローラーは、アプリケーション仕様の主要な &lt;code&gt;applications&lt;/code&gt; の値をチェックして、このアプリケーションが実行される前にすべてのアプリケーションを起動する必要があることを確認します。それ以外の場合は、 &lt;code&gt;{error,{not_started,App}}&lt;/code&gt; が返されます。ここで、 &lt;code&gt;App&lt;/code&gt; は不足しているアプリケーションの名前です。</target>
        </trans-unit>
        <trans-unit id="f3a71b2d510c249b1ef4dc36fecf08094449baa7" translate="yes" xml:space="preserve">
          <source>The application controller creates an application master for the application</source>
          <target state="translated">アプリケーションコントローラは、アプリケーション用のアプリケーションマスタを作成します。</target>
        </trans-unit>
        <trans-unit id="83a95923e1f732ae145bb3e38ddb63679bc6a37a" translate="yes" xml:space="preserve">
          <source>The application controller then creates an &lt;strong&gt;application master&lt;/strong&gt; for the application. The application master becomes the group leader of all the processes in the application. I/O is forwarded to the previous group leader, though, this is just a way to identify processes that belong to the application. Used for example to find itself from any process, or, reciprocally, to kill them all when it terminates.</source>
          <target state="translated">次に、アプリケーションコントローラーは、&lt;strong&gt;アプリケーションのアプリケーションマスター&lt;/strong&gt;を作成します。アプリケーションマスターは、アプリケーション内のすべてのプロセスのグループリーダーになります。I / Oは前のグループリーダーに転送されますが、これはアプリケーションに属するプロセスを識別するための方法にすぎません。たとえば、任意のプロセスから自分自身を見つけるため、または相互に、プロセスが終了したときにそれらをすべて強制終了するために使用されます。</target>
        </trans-unit>
        <trans-unit id="cb0f6ae5fb0c8a7581cb9e8e067ef2f56d1995bb" translate="yes" xml:space="preserve">
          <source>The application dependencies can be checked using the Erlang shell. Application dependencies are verified among installed applications by &lt;code&gt;otp_patch_apply&lt;/code&gt;, but these are not necessarily those actually loaded. By calling &lt;code&gt;system_information:sanity_check()&lt;/code&gt; one can validate dependencies among applications actually loaded.</source>
          <target state="translated">アプリケーションの依存関係は、Erlangシェルを使用して確認できます。アプリケーションの依存関係は、インストールされているアプリケーション間で &lt;code&gt;otp_patch_apply&lt;/code&gt; によって検証されますが、これらは必ずしも実際にロードされるものではありません。 &lt;code&gt;system_information:sanity_check()&lt;/code&gt; を呼び出すことにより、実際にロードされたアプリケーション間の依存関係を検証できます。</target>
        </trans-unit>
        <trans-unit id="bb62df0e58b18cc0a3dd6823066bbe7bee60e95d" translate="yes" xml:space="preserve">
          <source>The application is started at the first operational node that is listed in the list of nodes in the &lt;code&gt;distributed&lt;/code&gt; configuration parameter. The application is started as usual. That is, an application master is created and calls the application callback function:</source>
          <target state="translated">アプリケーションは、 &lt;code&gt;distributed&lt;/code&gt; 構成パラメーターのノードのリストにリストされている最初の稼働ノードで開始されます。アプリケーションは通常どおり開始されます。つまり、アプリケーションマスターが作成され、アプリケーションコールバック関数を呼び出します。</target>
        </trans-unit>
        <trans-unit id="89049fedc72f84958aace187301d7f02b79550e8" translate="yes" xml:space="preserve">
          <source>The application is started by the application master calling:</source>
          <target state="translated">アプリケーションマスターの呼び出しでアプリケーションが起動します。</target>
        </trans-unit>
        <trans-unit id="bfedb4900bc06eb3b379ebe1429d3cb0e9392954" translate="yes" xml:space="preserve">
          <source>The application is started the normal way at the new node, that is, by the application master calling:</source>
          <target state="translated">アプリケーションは新しいノードで通常の方法で起動されます。</target>
        </trans-unit>
        <trans-unit id="10822e972b13555d1eff4f5137f6287954df0861" translate="yes" xml:space="preserve">
          <source>The application master calls &lt;code&gt;Module:start(normal, StartArgs)&lt;/code&gt; to start the top supervisor.</source>
          <target state="translated">アプリケーションマスターは &lt;code&gt;Module:start(normal, StartArgs)&lt;/code&gt; を呼び出して、最上位のスーパーバイザを起動します。</target>
        </trans-unit>
        <trans-unit id="e29776b842b696055e58002f88fb65232061b2ab" translate="yes" xml:space="preserve">
          <source>The application master starts the application by calling the application callback function &lt;code&gt;Module:start/2&lt;/code&gt; as defined by the application specification key &lt;code&gt;mod&lt;/code&gt;.</source>
          <target state="translated">アプリケーションマスターは、アプリケーション仕様キー &lt;code&gt;mod&lt;/code&gt; で定義されているように、アプリケーションコールバック関数 &lt;code&gt;Module:start/2&lt;/code&gt; を呼び出すことによってアプリケーションを起動します。</target>
        </trans-unit>
        <trans-unit id="8cabb4f62fd98a4ff2c6678b3ed5fdfd959999a1" translate="yes" xml:space="preserve">
          <source>The application master starts the application by calling the application callback function &lt;code&gt;start/2&lt;/code&gt; in the module, and with the start argument, defined by the &lt;code&gt;mod&lt;/code&gt; key in the &lt;code&gt;.app&lt;/code&gt; file.</source>
          <target state="translated">アプリケーションマスターは、モジュールのアプリケーションコールバック関数 &lt;code&gt;start/2&lt;/code&gt; を呼び出すことにより、アプリケーションを開始します。開始引数は、 &lt;code&gt;.app&lt;/code&gt; ファイルの &lt;code&gt;mod&lt;/code&gt; キーで定義されます。</target>
        </trans-unit>
        <trans-unit id="13734b250f5eb9d546b03086cf7b41b4dea34d6f" translate="yes" xml:space="preserve">
          <source>The application master stops the application by telling the top supervisor to shut down. The top supervisor tells all its child processes to shut down, and so on; the entire tree is terminated in reversed start order. The application master then calls the application callback function &lt;code&gt;stop/1&lt;/code&gt; in the module defined by the &lt;code&gt;mod&lt;/code&gt; key.</source>
          <target state="translated">アプリケーションマスターは、トップスーパーバイザにシャットダウンするように指示することにより、アプリケーションを停止します。最上位のスーパーバイザは、すべての子プロセスにシャットダウンするように指示します。ツリー全体が逆の開始順序で終了します。次に、アプリケーションマスターは、 &lt;code&gt;mod&lt;/code&gt; キーで定義されたモジュールのアプリケーションコールバック関数 &lt;code&gt;stop/1&lt;/code&gt; を呼び出します。</target>
        </trans-unit>
        <trans-unit id="b526c8807809b1d1a78677dccccf183dc7531782" translate="yes" xml:space="preserve">
          <source>The application master then calls &lt;code&gt;Module:start/2&lt;/code&gt; for the primary application, followed by calls to &lt;code&gt;Module:start_phase/3&lt;/code&gt; for each start phase (as defined for the primary application), both for the primary application and for each of its included applications, for which the start phase is defined.</source>
          <target state="translated">次に、アプリケーションマスターは、プライマリアプリケーションに対して &lt;code&gt;Module:start/2&lt;/code&gt; を呼び出し、その後、プライマリアプリケーションとそれに含まれる各アプリケーションの両方について、（プライマリアプリケーションに対して定義されている）開始フェーズごとに &lt;code&gt;Module:start_phase/3&lt;/code&gt; を呼び出します。開始フェーズが定義されています。</target>
        </trans-unit>
        <trans-unit id="a163c20a5a18b97757a743989413cf19c582f80f" translate="yes" xml:space="preserve">
          <source>The application requires Erlang/OTP release R10B or later.</source>
          <target state="translated">このアプリケーションにはErlang/OTPリリースR10B以降が必要です。</target>
        </trans-unit>
        <trans-unit id="47de7b9f1554880fd51a51ad6a1c134e4bb1c43b" translate="yes" xml:space="preserve">
          <source>The application requires Erlang/OTP release R13B02 or later.</source>
          <target state="translated">このアプリケーションにはErlang/OTPのリリースR13B02以降が必要です。</target>
        </trans-unit>
        <trans-unit id="04c072f323859be092a04c77c0d3a8f3932431a9" translate="yes" xml:space="preserve">
          <source>The application requires Erlang/OTP release R13BB or later. If you use the old &lt;code&gt;GS&lt;/code&gt; based GUI it does suffice with R7B.</source>
          <target state="translated">アプリケーションには、Erlang / OTPリリースR13BB以降が必要です。古い &lt;code&gt;GS&lt;/code&gt; ベースのGUI を使用している場合は、R7Bで十分です。</target>
        </trans-unit>
        <trans-unit id="705f938ebc82f5cfe9e917670d636ce442e4f982" translate="yes" xml:space="preserve">
          <source>The application resource file is to be called &lt;code&gt;Application.app&lt;/code&gt;, where &lt;code&gt;Application&lt;/code&gt; is the application name. The file is to be located in directory &lt;code&gt;ebin&lt;/code&gt; for the application.</source>
          <target state="translated">アプリケーションリソースファイルの名前は &lt;code&gt;Application.app&lt;/code&gt; で、 &lt;code&gt;Application&lt;/code&gt; はアプリケーション名です。ファイルは、アプリケーションのディレクトリ &lt;code&gt;ebin&lt;/code&gt; にあります。</target>
        </trans-unit>
        <trans-unit id="8095bda3db4836c710654adeb79de3919a1733c3" translate="yes" xml:space="preserve">
          <source>The application settings page is rather incomplete.</source>
          <target state="translated">アプリの設定ページがやや不完全です。</target>
        </trans-unit>
        <trans-unit id="a30b190dbffeb37d7579aa94007cbfaeb029e782" translate="yes" xml:space="preserve">
          <source>The application specification can also be specified directly as a tuple &lt;code&gt;AppSpec&lt;/code&gt;, having the format and contents as described in &lt;code&gt;&lt;a href=&quot;app&quot;&gt;app(4)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">アプリケーション仕様は、 &lt;code&gt;&lt;a href=&quot;app&quot;&gt;app(4)&lt;/a&gt;&lt;/code&gt; で説明されている形式と内容を持つタプル &lt;code&gt;AppSpec&lt;/code&gt; として直接指定することもできます。</target>
        </trans-unit>
        <trans-unit id="ae0f5edbfbc9e079896bc2aadb1ec402b1e46966" translate="yes" xml:space="preserve">
          <source>The application upgrade file is to be called &lt;code&gt;Application.appup&lt;/code&gt;, where &lt;code&gt;Application&lt;/code&gt; is the application name. The file is to be located in the &lt;code&gt;ebin&lt;/code&gt; directory for the application.</source>
          <target state="translated">アプリケーションのアップグレードファイルが呼び出される &lt;code&gt;Application.appup&lt;/code&gt; 、 &lt;code&gt;Application&lt;/code&gt; アプリケーション名です。ファイルは、アプリケーションの &lt;code&gt;ebin&lt;/code&gt; ディレクトリにあります。</target>
        </trans-unit>
        <trans-unit id="01be2b299856c125d638a3713ccfbcb4f60476f7" translate="yes" xml:space="preserve">
          <source>The application version of the SSL application.</source>
          <target state="translated">SSLアプリケーションのアプリケーション版です。</target>
        </trans-unit>
        <trans-unit id="73e6b27f7140dc43719697a589e7dc915f9cffa1" translate="yes" xml:space="preserve">
          <source>The application window is started by double clicking on an application name. The application window consists of four pages (tabs):</source>
          <target state="translated">アプリケーションウィンドウは、アプリケーション名をダブルクリックすることで起動します。アプリケーションウィンドウは4つのページ(タブ)で構成されています。</target>
        </trans-unit>
        <trans-unit id="c8077f9793de81202aa1676c65a0451a20a5cbbb" translate="yes" xml:space="preserve">
          <source>The application-neutral representation of an AVP. Primarily intended for use by relay applications that need to handle arbitrary Diameter applications. A service implementing a specific Diameter application (for which it configures a dictionary) can manipulate values of type &lt;code&gt;&lt;a href=&quot;#message&quot;&gt;message()&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">AVPのアプリケーション中立表現。主に、任意のDiameterアプリケーションを処理する必要があるリレーアプリケーションによる使用を目的としています。（ディクショナリを構成する）特定のDiameterアプリケーションを実装するサービスは、代わりにタイプ &lt;code&gt;&lt;a href=&quot;#message&quot;&gt;message()&lt;/a&gt;&lt;/code&gt; の値を操作できます。</target>
        </trans-unit>
        <trans-unit id="e81712f8fd17dfa5b0951414305dbd11e0bfbc67" translate="yes" xml:space="preserve">
          <source>The applications are sorted according to the dependencies between the applications. Where there are no dependencies, the order in the &lt;code&gt;.rel&lt;/code&gt; file is kept.</source>
          <target state="translated">アプリケーションは、アプリケーション間の依存関係に従ってソートされます。依存関係がない場合、 &lt;code&gt;.rel&lt;/code&gt; ファイル内の順序は保持されます。</target>
        </trans-unit>
        <trans-unit id="85353072338b2dbf168feea1aabc66961c7a142d" translate="yes" xml:space="preserve">
          <source>The archive must be closed with &lt;code&gt;&lt;a href=&quot;#zip_close-1&quot;&gt;zip_close/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">アーカイブは &lt;code&gt;&lt;a href=&quot;#zip_close-1&quot;&gt;zip_close/1&lt;/a&gt;&lt;/code&gt; で閉じる必要があります。</target>
        </trans-unit>
        <trans-unit id="cd634904a6b19656df55ba94518706b87469aeb9" translate="yes" xml:space="preserve">
          <source>The archive size is limited to 2 GB (32 bits).</source>
          <target state="translated">アーカイブサイズは2GB(32ビット)までとなります。</target>
        </trans-unit>
        <trans-unit id="cd12ca75aaea91ed2a310f36dcea8f4976e41af5" translate="yes" xml:space="preserve">
          <source>The argument &lt;code&gt;DefaultAgentConfig&lt;/code&gt; is used as default values when this user register agents.</source>
          <target state="translated">引数 &lt;code&gt;DefaultAgentConfig&lt;/code&gt; は、このユーザーがエージェントを登録するときにデフォルト値として使用されます。</target>
        </trans-unit>
        <trans-unit id="69004e83d19b67fea82f2e443fe9acacd301728c" translate="yes" xml:space="preserve">
          <source>The argument &lt;code&gt;Extra&lt;/code&gt; is just an opaque data structure passed to the user via the callback functions in the &lt;code&gt;&lt;a href=&quot;megaco_user&quot;&gt;user callback module&lt;/a&gt;&lt;/code&gt;. Note however that if &lt;code&gt;Extra&lt;/code&gt; has the value &lt;code&gt;extra_undefined&lt;/code&gt; the argument will be ignored (same as if &lt;code&gt;process_received_message/4&lt;/code&gt; had been called). See the documentation for the behaviour of the callback module, &lt;code&gt;&lt;a href=&quot;megaco_user&quot;&gt;megaco_user&lt;/a&gt;&lt;/code&gt;, for more info.</source>
          <target state="translated">引数 &lt;code&gt;Extra&lt;/code&gt; は、 &lt;code&gt;&lt;a href=&quot;megaco_user&quot;&gt;user callback module&lt;/a&gt;&lt;/code&gt; コールバック関数を介してユーザーに渡される不透明なデータ構造です。ただし、 &lt;code&gt;Extra&lt;/code&gt; の値が &lt;code&gt;extra_undefined&lt;/code&gt; の場合、引数は無視されます（ &lt;code&gt;process_received_message/4&lt;/code&gt; が呼び出された場合と同じ）。詳細については、コールバックモジュール &lt;code&gt;&lt;a href=&quot;megaco_user&quot;&gt;megaco_user&lt;/a&gt;&lt;/code&gt; の動作に関するドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="f459c21deb16ca0d8a2238ea1bb013af1aa40900" translate="yes" xml:space="preserve">
          <source>The argument &lt;code&gt;Listen&lt;/code&gt; is the handle originally passed from the &lt;code&gt;&lt;a href=&quot;#listen&quot;&gt;listen/1&lt;/a&gt;&lt;/code&gt; callback. The argument &lt;code&gt;Opts&lt;/code&gt; is a list of options to read for future connections.</source>
          <target state="translated">引数 &lt;code&gt;Listen&lt;/code&gt; は、最初に &lt;code&gt;&lt;a href=&quot;#listen&quot;&gt;listen/1&lt;/a&gt;&lt;/code&gt; コールバックから渡されたハンドルです。引数 &lt;code&gt;Opts&lt;/code&gt; は、将来の接続のために読み取るオプションのリストです。</target>
        </trans-unit>
        <trans-unit id="debf3f82b456b10623118b0f8614068c9ab5fae7" translate="yes" xml:space="preserve">
          <source>The argument &lt;code&gt;Listen&lt;/code&gt; is the handle originally passed from the &lt;code&gt;&lt;a href=&quot;#listen&quot;&gt;listen/1&lt;/a&gt;&lt;/code&gt; callback. The argument &lt;code&gt;Opts&lt;/code&gt; is a list of options to set on future connections.</source>
          <target state="translated">引数 &lt;code&gt;Listen&lt;/code&gt; は、最初に &lt;code&gt;&lt;a href=&quot;#listen&quot;&gt;listen/1&lt;/a&gt;&lt;/code&gt; コールバックから渡されたハンドルです。引数 &lt;code&gt;Opts&lt;/code&gt; は、将来の接続で設定するオプションのリストです。</target>
        </trans-unit>
        <trans-unit id="6f649282c95c4ff27efd3a1061e1c2bdcdf508eb" translate="yes" xml:space="preserve">
          <source>The argument &lt;code&gt;Opaque&lt;/code&gt; is forwarded to the backup module. It returns &lt;code&gt;{atomic, TabList}&lt;/code&gt; if successful, or the tuple &lt;code&gt;{aborted, Reason}&lt;/code&gt; if there is an error. &lt;code&gt;TabList&lt;/code&gt; is a list of the restored tables. Tables that are restored are write-locked during the restore operation. However, regardless of any lock conflict caused by this, applications can continue to do their work during the restore operation.</source>
          <target state="translated">引数 &lt;code&gt;Opaque&lt;/code&gt; はバックアップモジュールに転送されます。成功した場合は &lt;code&gt;{atomic, TabList}&lt;/code&gt; 返し、エラーがある場合はタプル &lt;code&gt;{aborted, Reason}&lt;/code&gt; 返します。 &lt;code&gt;TabList&lt;/code&gt; は、復元されたテーブルのリストです。復元されたテーブルは、復元操作中に書き込みロックされます。ただし、これによって引き起こされるロックの競合に関係なく、アプリケーションは復元操作中に引き続き作業を行うことができます。</target>
        </trans-unit>
        <trans-unit id="dfff5e2db73b8f539cd9908f48d194bda191ddfc" translate="yes" xml:space="preserve">
          <source>The argument can also be a list of modules or filenames, in which case the function tries to interpret each module as specified earlier. The function then always returns &lt;code&gt;ok&lt;/code&gt;, but prints some information to &lt;code&gt;stdout&lt;/code&gt; if a module cannot be interpreted.</source>
          <target state="translated">引数は、モジュールまたはファイル名のリストにすることもできます。その場合、関数は前に指定したように各モジュールを解釈しようとします。その後、関数は常に &lt;code&gt;ok&lt;/code&gt; を返しますが、モジュールを解釈できない場合は、いくつかの情報を &lt;code&gt;stdout&lt;/code&gt; に出力します。</target>
        </trans-unit>
        <trans-unit id="f72a488906a1bc4231e746b4ff7b4a8e45eb6fc3" translate="yes" xml:space="preserve">
          <source>The argument is a float that is written as &lt;code&gt;[-]d.ddde+-ddd&lt;/code&gt;, where the precision is the number of digits written. The default precision is 6 and it cannot be &amp;lt; 2.</source>
          <target state="translated">引数は &lt;code&gt;[-]d.ddde+-ddd&lt;/code&gt; として記述される浮動小数点数であり、精度は書き込まれる桁数です。デフォルトの精度は6であり、&amp;lt;2にすることはできません。</target>
        </trans-unit>
        <trans-unit id="93d3f166ed7f071a0cf8c5e27837f3a0c6681247" translate="yes" xml:space="preserve">
          <source>The argument is a float that is written as &lt;code&gt;[-]ddd.ddd&lt;/code&gt;, where the precision is the number of digits after the decimal point. The default precision is 6 and it cannot be &amp;lt; 1.</source>
          <target state="translated">引数は &lt;code&gt;[-]ddd.ddd&lt;/code&gt; として記述される浮動小数点数で、精度は小数点以下の桁数です。デフォルトの精度は6で、1未満にすることはできません。</target>
        </trans-unit>
        <trans-unit id="049df39b974433b181b76b3894315e239a3ad777" translate="yes" xml:space="preserve">
          <source>The argument is a float that is written as &lt;code&gt;f&lt;/code&gt;, if it is &amp;gt;= 0.1 and &amp;lt; 10000.0. Otherwise, it is written in the &lt;code&gt;e&lt;/code&gt; format. The precision is the number of significant digits. It defaults to 6 and is not to be &amp;lt; 2. If the absolute value of the float does not allow it to be written in the &lt;code&gt;f&lt;/code&gt; format with the desired number of significant digits, it is also written in the &lt;code&gt;e&lt;/code&gt; format.</source>
          <target state="translated">引数は、&amp;gt; = 0.1および&amp;lt;10000.0の場合、 &lt;code&gt;f&lt;/code&gt; として書き込まれる浮動小数点です。それ以外の場合は、 &lt;code&gt;e&lt;/code&gt; 形式で書き込まれます。精度は、有効桁数です。デフォルトは6であり、2未満ではありません。浮動小数点数の絶対値が、有効な有効桁数の &lt;code&gt;f&lt;/code&gt; 形式で書き込むことができない場合は、 &lt;code&gt;e&lt;/code&gt; 形式でも書き込まれます。</target>
        </trans-unit>
        <trans-unit id="fd2ce2991cd1ed1c5544565d4bc9f56a7a9da522" translate="yes" xml:space="preserve">
          <source>The argument is a number that is interpreted as an ASCII code. The precision is the number of times the character is printed and defaults to the field width, which in turn defaults to 1. Example:</source>
          <target state="translated">引数はASCIIコードとして解釈される数値です。精度は文字が印刷される回数で、デフォルトはフィールド幅で、デフォルトは1です。例。</target>
        </trans-unit>
        <trans-unit id="41417c1b36d7d073dd070139b59528225284b877" translate="yes" xml:space="preserve">
          <source>The argument to &lt;code&gt;init_per_suite&lt;/code&gt; is &lt;code&gt;Config&lt;/code&gt;, that is, the same key-value list of runtime configuration data that each test case takes as input argument. &lt;code&gt;init_per_suite&lt;/code&gt; can modify this parameter with information that the test cases need. The possibly modified &lt;code&gt;Config&lt;/code&gt; list is the return value of the function.</source>
          <target state="translated">&lt;code&gt;init_per_suite&lt;/code&gt; の引数は &lt;code&gt;Config&lt;/code&gt; です。つまり、各テストケースが入力引数として取るランタイム構成データの同じキーと値のリストです。 &lt;code&gt;init_per_suite&lt;/code&gt; は、テストケースに必要な情報を使用してこのパラメーターを変更できます。変更された可能性のある &lt;code&gt;Config&lt;/code&gt; リストは、関数の戻り値です。</target>
        </trans-unit>
        <trans-unit id="19116289e2a06f46f52b99e7a354d07e181d8263" translate="yes" xml:space="preserve">
          <source>The argument type change is from signed to unsigned. This can cause problems for, for example, loop termination conditions or error conditions if you only change the types all over the place.</source>
          <target state="translated">引数の型の変更は、符号付きから符号なしへの変更です。これにより、型だけをあちこちに変更すると、例えばループ終了条件やエラー条件などの問題が発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="518f1110847b76edf7686b0d43ca29a942986a62" translate="yes" xml:space="preserve">
          <source>The argument, &lt;code&gt;{local, error_man}&lt;/code&gt; specifies the name. The event manager is then locally registered as &lt;code&gt;error_man&lt;/code&gt;.</source>
          <target state="translated">引数 &lt;code&gt;{local, error_man}&lt;/code&gt; は名前を指定します。その後、イベントマネージャは &lt;code&gt;error_man&lt;/code&gt; としてローカルに登録されます。</target>
        </trans-unit>
        <trans-unit id="0afbf43c606253c8ecf1c39998b54bbb8fa67440" translate="yes" xml:space="preserve">
          <source>The arguments &lt;code&gt;Format&lt;/code&gt; and &lt;code&gt;FormatArgs&lt;/code&gt; in &lt;code&gt;ct:log/print/pal&lt;/code&gt; are always passed on to the STDLIB function &lt;code&gt;io:format/3&lt;/code&gt; (For details, see the &lt;code&gt;io&lt;/code&gt; manual page).</source>
          <target state="translated">引数の &lt;code&gt;Format&lt;/code&gt; と &lt;code&gt;FormatArgs&lt;/code&gt; で &lt;code&gt;ct:log/print/pal&lt;/code&gt; 常にSTDLIB関数に渡される &lt;code&gt;io:format/3&lt;/code&gt; （詳細については、 &lt;code&gt;io&lt;/code&gt; のマニュアルページを）。</target>
        </trans-unit>
        <trans-unit id="ad2c02ade68b15ea95b904a33d006adc1b1cf304" translate="yes" xml:space="preserve">
          <source>The arguments &lt;code&gt;Type&lt;/code&gt; and &lt;code&gt;SnmpInfo&lt;/code&gt; relates in the following way:</source>
          <target state="translated">引数 &lt;code&gt;Type&lt;/code&gt; と &lt;code&gt;SnmpInfo&lt;/code&gt; は、次のように関連しています。</target>
        </trans-unit>
        <trans-unit id="6b287b1ceba326e901144e95b8db2f9f2999be1d" translate="yes" xml:space="preserve">
          <source>The arguments are not expanded by the shell before they are supplied to the executable. Most notably this means that file wildcard expansion does not occur. To expand wildcards for the arguments, use &lt;code&gt;filelib:wildcard/1&lt;/code&gt;. Notice that even if the program is a Unix shell script, meaning that the shell ultimately is invoked, wildcard expansion does not occur, and the script is provided with the untouched arguments. On Windows, wildcard expansion is always up to the program itself, therefore this is not an issue.</source>
          <target state="translated">引数は、実行可能ファイルに提供される前にシェルによって展開されません。特に、これはファイルのワイルドカード拡張が発生しないことを意味します。引数のワイルドカードを展開するには、 &lt;code&gt;filelib:wildcard/1&lt;/code&gt; を使用します。プログラムがUnixシェルスクリプトである場合、つまりシェルが最終的に呼び出される場合でも、ワイルドカード展開は行われず、スクリプトにはそのままの引数が提供されることに注意してください。Windowsでは、ワイルドカードの展開は常にプログラム自体にかかっているため、これは問題になりません。</target>
        </trans-unit>
        <trans-unit id="522ee4260f97c142662210e82bcb713e534c2aad" translate="yes" xml:space="preserve">
          <source>The arguments can be divided into &lt;strong&gt;emulator flags&lt;/strong&gt;, &lt;strong&gt;flags&lt;/strong&gt;, and &lt;strong&gt;plain arguments&lt;/strong&gt;:</source>
          <target state="translated">引数は、&lt;strong&gt;エミュレータフラグ&lt;/strong&gt;、&lt;strong&gt;フラグ&lt;/strong&gt;、および&lt;strong&gt;プレーン引数に&lt;/strong&gt;分割でき&lt;strong&gt;ます&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="f6ed9ef38109b234ba45603e287f33458c0a6ac4" translate="yes" xml:space="preserve">
          <source>The arguments can be of different data types. The following order is defined:</source>
          <target state="translated">引数には異なるデータ型を指定することができます。以下の順序で定義されています。</target>
        </trans-unit>
        <trans-unit id="ffa892e870535324db1c0ec38851cc864f132069" translate="yes" xml:space="preserve">
          <source>The arguments:</source>
          <target state="translated">議論しています。</target>
        </trans-unit>
        <trans-unit id="a8a87576167815553ae803598fc43fec00d99fc0" translate="yes" xml:space="preserve">
          <source>The arity (number of arguments) for the current function.</source>
          <target state="translated">現在の関数のアリティ(引数の数)。</target>
        </trans-unit>
        <trans-unit id="f4a92fd68167fdb3dffdde93bfe14f1434196818" translate="yes" xml:space="preserve">
          <source>The arity of the function implementing the fun.</source>
          <target state="translated">fun を実装した関数の arity。</target>
        </trans-unit>
        <trans-unit id="2e0c7ead6f817b15595de5c93baf2426dbf01b86" translate="yes" xml:space="preserve">
          <source>The arity of the function must match the number of arguments, else a compilation error occurs.</source>
          <target state="translated">関数のアリティは引数の数と一致しなければならず、そうでない場合はコンパイルエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="a567fbfc0f0119591979c89645ce71555342bc2e" translate="yes" xml:space="preserve">
          <source>The array length, that is, the function arity. &lt;code&gt;argv[N-1]&lt;/code&gt; thus denotes the Nth argument to the NIF. Notice that the argument &lt;code&gt;argc&lt;/code&gt; allows for the same C function to implement several Erlang functions with different arity (but probably with the same name).</source>
          <target state="translated">配列の長さ、つまり関数アリティ。したがって、 &lt;code&gt;argv[N-1]&lt;/code&gt; はNIFのN番目の引数を示します。引数 &lt;code&gt;argc&lt;/code&gt; を使用すると、同じC関数でアリティが異なる（おそらく同じ名前の）複数のErlang関数を実装できます。</target>
        </trans-unit>
        <trans-unit id="415f03b07c8ba3c8c05edaadd6e77c05a2cd0868" translate="yes" xml:space="preserve">
          <source>The array never shrinks automatically. If an index &lt;code&gt;I&lt;/code&gt; has been used to set an entry successfully, all indices in the range [0,&lt;code&gt;I&lt;/code&gt;] stay accessible unless the array size is explicitly changed by calling &lt;code&gt;&lt;a href=&quot;#resize-2&quot;&gt;resize/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">配列が自動的に縮小することはありません。インデックス &lt;code&gt;I&lt;/code&gt; を使用してエントリを正常に設定した場合、 &lt;code&gt;&lt;a href=&quot;#resize-2&quot;&gt;resize/2&lt;/a&gt;&lt;/code&gt; を呼び出して配列サイズを明示的に変更しない限り、範囲[0、 &lt;code&gt;I&lt;/code&gt; ]のすべてのインデックスにアクセスできます。</target>
        </trans-unit>
        <trans-unit id="41821fc2a208b561d81f20833df1e2cf397cd22d" translate="yes" xml:space="preserve">
          <source>The associated code contains &lt;code&gt;pseudo variables&lt;/code&gt;&lt;code&gt;'$1'&lt;/code&gt;, &lt;code&gt;'$2'&lt;/code&gt;, &lt;code&gt;'$3'&lt;/code&gt;, etc. which refer to (are bound to) the values associated previously by the parser with the symbols of the right hand side of the rule. When these symbols are terminal categories, the values are token tuples of the input string (see above).</source>
          <target state="translated">関連付けられたコードには、パーサーによって以前にルールの右側の記号で関連付けられた値を参照する（バインドされる） &lt;code&gt;pseudo variables&lt;/code&gt; &lt;code&gt;'$1'&lt;/code&gt; 、 &lt;code&gt;'$2'&lt;/code&gt; 、 &lt;code&gt;'$3'&lt;/code&gt; などが含まれています。これらのシンボルが終端カテゴリの場合、値は入力文字列のトークンタプルです（上記を参照）。</target>
        </trans-unit>
        <trans-unit id="3898cfb8a11a62ffe2fdba8be9357512d68bb196" translate="yes" xml:space="preserve">
          <source>The associated code may not only be used to build structures associated with phrases, but may also be used for syntactic and semantic tests, printout actions (for example for tracing), etc. during the parsing process. Since tokens contain positional (line number) information, it is possible to produce error messages which contain line numbers. If there is no associated code after the right hand side of the rule, the value &lt;code&gt;'$undefined'&lt;/code&gt; is associated with the phrase.</source>
          <target state="translated">関連付けられたコードは、フレーズに関連付けられた構造を構築するために使用されるだけでなく、構文解析およびセマンティックテスト、出力処理（トレースなど）などの解析プロセス中に使用される場合もあります。トークンには位置（行番号）情報が含まれているため、行番号を含むエラーメッセージが生成される可能性があります。ルールの右側の後に関連するコードがない場合、値 &lt;code&gt;'$undefined'&lt;/code&gt; がフレーズに関連付けられます。</target>
        </trans-unit>
        <trans-unit id="6b6e33dc105b7762f1d530b48ab29c546fd13258" translate="yes" xml:space="preserve">
          <source>The association cannot be established (&lt;code&gt;connect/*&lt;/code&gt; failure).</source>
          <target state="translated">関連付けを確立できません（ &lt;code&gt;connect/*&lt;/code&gt; 失敗）。</target>
        </trans-unit>
        <trans-unit id="ef9716ac7174f55cae16eacb1845e6a71402ef24" translate="yes" xml:space="preserve">
          <source>The association file &lt;code&gt;EX1-MIB.funcs&lt;/code&gt; for the real implementation looks as follows:</source>
          <target state="translated">実際の実装の関連付けファイル &lt;code&gt;EX1-MIB.funcs&lt;/code&gt; は次のようになります。</target>
        </trans-unit>
        <trans-unit id="81d1ef649b0dc2cac7a3f4619510067970a6fd77" translate="yes" xml:space="preserve">
          <source>The association file, which contains the names of instrumentation functions for the MIB, should have the suffix &lt;code&gt;.funcs&lt;/code&gt;. If the compiler does not find the association file, it gives a warning message and uses default instrumentation functions. (See &lt;code&gt;&lt;a href=&quot;snmp_instr_functions#snmp_3&quot;&gt;Default Instrumentation&lt;/a&gt;&lt;/code&gt; for more details).</source>
          <target state="translated">MIBのインスツルメンテーション関数の名前を含む関連付けファイルには、サフィックス &lt;code&gt;.funcs&lt;/code&gt; が必要です。コンパイラが関連ファイルを見つけられない場合、警告メッセージが表示され、デフォルトの計測機能が使用されます。（詳細については、 &lt;code&gt;&lt;a href=&quot;snmp_instr_functions#snmp_3&quot;&gt;Default Instrumentation&lt;/a&gt;&lt;/code&gt; を参照してください）。</target>
        </trans-unit>
        <trans-unit id="9e61865049f08d1e62a4b88bd1b23185c90eb9da" translate="yes" xml:space="preserve">
          <source>The asymetric encryption algorithm used in the server's private-public host key pair. Examples include the well-known RSA &lt;code&gt;'ssh-rsa'&lt;/code&gt; and elliptic curve &lt;code&gt;'ecdsa-sha2-nistp521'&lt;/code&gt;.</source>
          <target state="translated">サーバーの秘密鍵と公開鍵のペアで使用される非対称暗号化アルゴリズム。例には、よく知られているRSA &lt;code&gt;'ssh-rsa'&lt;/code&gt; と楕円曲線 &lt;code&gt;'ecdsa-sha2-nistp521'&lt;/code&gt; が含まれます。</target>
        </trans-unit>
        <trans-unit id="00b06000d023218a0553695852ada6423beef957" translate="yes" xml:space="preserve">
          <source>The async thread pool size can be set with command-line argument &lt;code&gt;&lt;a href=&quot;erl#async_thread_pool_size&quot;&gt;+A&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;erl&quot;&gt;erl(1)&lt;/a&gt;&lt;/code&gt;. If an async thread pool is unavailable, the call is made synchronously in the thread calling &lt;code&gt;driver_async&lt;/code&gt;. The current number of async threads in the async thread pool can be retrieved through &lt;code&gt;&lt;a href=&quot;#driver_system_info&quot;&gt;driver_system_info&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">非同期スレッドプールサイズは、 &lt;code&gt;&lt;a href=&quot;erl&quot;&gt;erl(1)&lt;/a&gt;&lt;/code&gt; のコマンドライン引数 &lt;code&gt;&lt;a href=&quot;erl#async_thread_pool_size&quot;&gt;+A&lt;/a&gt;&lt;/code&gt; で設定できます。非同期スレッドプールが利用できない場合、呼び出しは &lt;code&gt;driver_async&lt;/code&gt; を呼び出すスレッドで同期的に行われます。非同期スレッドプール内の非同期スレッドの現在の数は、 &lt;code&gt;&lt;a href=&quot;#driver_system_info&quot;&gt;driver_system_info&lt;/a&gt;&lt;/code&gt; を使用して取得できます。</target>
        </trans-unit>
        <trans-unit id="6d949b17e0550064c4ba8e06402f035e12b3129f" translate="yes" xml:space="preserve">
          <source>The asynchronous API for drivers is complicated. First, the work must be prepared. In the example, this is done in &lt;code&gt;output&lt;/code&gt;. We could have used &lt;code&gt;control&lt;/code&gt;, but we want some variation in the examples. In our driver, we allocate a structure that contains anything that is needed for the asynchronous task to do the work. This is done in the main emulator thread. Then the asynchronous function is called from a driver thread, separate from the main emulator thread. Notice that the driver functions are not re-entrant, so they are not to be used. Finally, after the function is completed, the driver callback &lt;code&gt;ready_async&lt;/code&gt; is called from the main emulator thread, this is where we return the result to Erlang. (We cannot return the result from within the asynchronous function, as we cannot call the driver functions.)</source>
          <target state="translated">ドライバーの非同期APIは複雑です。最初に、作業を準備する必要があります。例では、これは &lt;code&gt;output&lt;/code&gt; で行われます。 &lt;code&gt;control&lt;/code&gt; を使用することもできましたが、例にいくつかのバリエーションが必要です。ドライバーでは、非同期タスクが作業を行うために必要なものをすべて含む構造を割り当てます。これはメインエミュレータスレッドで行われます。次に、非同期関数が、メインエミュレータスレッドとは別のドライバスレッドから呼び出されます。ドライバ関数はリエントラントではないため、使用しないでください。最後に、関数が完了した後、ドライバーコールバック &lt;code&gt;ready_async&lt;/code&gt; メインエミュレータスレッドから呼び出され、ここで結果がErlangに返されます。（ドライバー関数を呼び出すことができないため、非同期関数内から結果を返すことはできません。）</target>
        </trans-unit>
        <trans-unit id="fb8f8a1d61eec151d7bbdbad482f3278e892dcab" translate="yes" xml:space="preserve">
          <source>The asynchronous request &lt;code&gt;free(Ch)&lt;/code&gt; is implemented using &lt;code&gt;gen_server:cast/2&lt;/code&gt;:</source>
          <target state="translated">非同期リクエスト &lt;code&gt;free(Ch)&lt;/code&gt; は、 &lt;code&gt;gen_server:cast/2&lt;/code&gt; を使用して実装されます。</target>
        </trans-unit>
        <trans-unit id="13cb8db4869505cfe3b89f4b66cbde4b8e730e2a" translate="yes" xml:space="preserve">
          <source>The asynchronous version of the driver is in the sample files &lt;code&gt;pg_async.c&lt;/code&gt; and &lt;code&gt;pg_asyng.erl&lt;/code&gt;.</source>
          <target state="translated">ドライバーの非同期バージョンは、サンプルファイル &lt;code&gt;pg_async.c&lt;/code&gt; および &lt;code&gt;pg_asyng.erl&lt;/code&gt; にあります。</target>
        </trans-unit>
        <trans-unit id="95ad31c862f53147c29592fd7356527c9ffced30" translate="yes" xml:space="preserve">
          <source>The atom &lt;code&gt;Behaviour&lt;/code&gt; gives the name of the behaviour, which can be a user-defined behaviour or one of the following OTP standard behaviours:</source>
          <target state="translated">アトムの &lt;code&gt;Behaviour&lt;/code&gt; は、ユーザー定義の動作または次のOTP標準動作のいずれかである動作の名前を示します。</target>
        </trans-unit>
        <trans-unit id="8b6c48f50dc1798aeaec7a743fffe7be10b28e3a" translate="yes" xml:space="preserve">
          <source>The atom &lt;code&gt;Name&lt;/code&gt; is the table name. The table name must be provided in all subsequent operations on the table. The name can be used by other processes as well, and many processes can share one table.</source>
          <target state="translated">アトム &lt;code&gt;Name&lt;/code&gt; はテーブル名です。テーブル名は、テーブルに対する後続のすべての操作で指定する必要があります。この名前は他のプロセスでも使用でき、多くのプロセスが1つのテーブルを共有できます。</target>
        </trans-unit>
        <trans-unit id="c510ba5b1215726673e2f72d3059e72c9e136b36" translate="yes" xml:space="preserve">
          <source>The atom &lt;code&gt;activity&lt;/code&gt;</source>
          <target state="translated">アトム &lt;code&gt;activity&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9710032c39f79ee3070e26173f96829389498bd7" translate="yes" xml:space="preserve">
          <source>The atom &lt;code&gt;finished&lt;/code&gt; is sent to &quot;pong&quot; (causing it to terminate as described above) and &quot;ping finished&quot; is written to the output. &quot;Ping&quot; then terminates as it has nothing left to do.</source>
          <target state="translated">&lt;code&gt;finished&lt;/code&gt; アトムは &quot;pong&quot;に送信され（上記のように終了します）、 &quot;ping finished&quot;が出力に書き込まれます。「Ping」は、何もする必要がないため終了します。</target>
        </trans-unit>
        <trans-unit id="d82cb2c455d0963906d4919213af14bc97a0dc7e" translate="yes" xml:space="preserve">
          <source>The atom &lt;code&gt;hibernate&lt;/code&gt; in the action list on the last line when entering the &lt;code&gt;{open,_}&lt;/code&gt; state is the only change. If any event arrives in the &lt;code&gt;{open,_},&lt;/code&gt; state, we do not bother to rehibernate, so the server stays awake after any event.</source>
          <target state="translated">&lt;code&gt;{open,_}&lt;/code&gt; 状態に入るときの最後の行のアクションリストでアトムが &lt;code&gt;hibernate&lt;/code&gt; 状態になっていることが唯一の変更です。 &lt;code&gt;{open,_},&lt;/code&gt; 状態でイベントが到着した場合、わざわざ再休止する必要はないので、サーバーはイベントの後も起きたままになります。</target>
        </trans-unit>
        <trans-unit id="356f9715c2aad0ed355593e69081e1f8b8476d8f" translate="yes" xml:space="preserve">
          <source>The atom &lt;code&gt;pending&lt;/code&gt;, which means that a monitor is to be created whenever a load operation is delayed,</source>
          <target state="translated">アトム &lt;code&gt;pending&lt;/code&gt; 。これは、ロード操作が遅延するたびにモニターが作成されることを意味します。</target>
        </trans-unit>
        <trans-unit id="161e6641a902cec6d4ca9159bb2b569a7ff90c0a" translate="yes" xml:space="preserve">
          <source>The atom &lt;code&gt;pending_driver&lt;/code&gt;, in which a monitor is created whenever the operation is delayed because of open ports to an otherwise unused driver.</source>
          <target state="translated">アトム &lt;code&gt;pending_driver&lt;/code&gt; 。これは、未使用のドライバーへのポートが開いているために操作が遅延するたびにモニターが作成されます。</target>
        </trans-unit>
        <trans-unit id="4d60a51c643f2a02e17349df9085c521ad7bd0aa" translate="yes" xml:space="preserve">
          <source>The atom &lt;code&gt;system&lt;/code&gt;</source>
          <target state="translated">アトム &lt;code&gt;system&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="42969bfd0b03becb2a706b91287d2fd18b7a8038" translate="yes" xml:space="preserve">
          <source>The atom &lt;code&gt;true&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; の原子</target>
        </trans-unit>
        <trans-unit id="f53c920e9113121f0b04e27b3e131485fc54743c" translate="yes" xml:space="preserve">
          <source>The atomicity and the isolation properties of &lt;code&gt;Mnesia&lt;/code&gt; are lost.</source>
          <target state="translated">&lt;code&gt;Mnesia&lt;/code&gt; の原子性と分離特性は失われます。</target>
        </trans-unit>
        <trans-unit id="1f8c1bd67e98ea142e16fbd8328c31a4abe8ce1c" translate="yes" xml:space="preserve">
          <source>The atoms &lt;code&gt;big&lt;/code&gt; and &lt;code&gt;little&lt;/code&gt; denote big- or little-endian encoding.</source>
          <target state="translated">アトム &lt;code&gt;big&lt;/code&gt; と &lt;code&gt;little&lt;/code&gt; は、ビッグエンディアンまたはリトルエンディアンのエンコーディングを示します。</target>
        </trans-unit>
        <trans-unit id="eec0aca30bfb32af191c5b7f63bda050342a54ff" translate="yes" xml:space="preserve">
          <source>The atoms &lt;code&gt;send&lt;/code&gt;, &lt;code&gt;'receive'&lt;/code&gt;, and &lt;code&gt;timeout&lt;/code&gt; for sends and receives (&lt;code&gt;'receive'&lt;/code&gt; when a message is received and &lt;code&gt;timeout&lt;/code&gt; when a receive times out)</source>
          <target state="translated">アトム &lt;code&gt;send&lt;/code&gt; 、 &lt;code&gt;'receive'&lt;/code&gt; 、および送信と受信の &lt;code&gt;timeout&lt;/code&gt; （メッセージが受信されると &lt;code&gt;'receive'&lt;/code&gt; 、受信が &lt;code&gt;timeout&lt;/code&gt; になるとタイムアウト）</target>
        </trans-unit>
        <trans-unit id="d6808e92018a30d64fa086f0dfa84d2f8448d1ef" translate="yes" xml:space="preserve">
          <source>The attribute OID name atoms and their corresponding value types are as follows:</source>
          <target state="translated">属性OID名のアトムとそれに対応する値の型は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="c9f3b18eb4341c86b8c0684826dff3c42219fcc2" translate="yes" xml:space="preserve">
          <source>The author can choose to put many or few tests into each test case. Some things to keep in mind follows:</source>
          <target state="translated">著者は、各テストケースに多くのテストを入れたり、いくつかのテストを入れたりすることができます。心に留めておくべきことは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="badc70f1a60a87b4c3438b8a7de6f4c78b5a65bc" translate="yes" xml:space="preserve">
          <source>The auto save interval. The table is flushed to disk whenever not accessed for this amount of time.</source>
          <target state="translated">自動保存の間隔です。この時間の間アクセスされないと、テーブルはディスクにフラッシュされます。</target>
        </trans-unit>
        <trans-unit id="c039d5fb00e0ef90ed0ae37b0f2d061a360a486a" translate="yes" xml:space="preserve">
          <source>The autostart feature requires more data to be stored on traced nodes. By default, the data is stored automatically to the file named &quot;ttb_autostart.bin&quot; in the currect working directory (cwd) of the traced node. Users can change this behaviour (that is, on diskless nodes) by specifying their own module to handle autostart data storage and retrieval (&lt;code&gt;ttb_autostart_module&lt;/code&gt; environment variable of &lt;code&gt;runtime_tools&lt;/code&gt;). For information about the API, see module &lt;code&gt;&lt;a href=&quot;ttb&quot;&gt;ttb&lt;/a&gt;&lt;/code&gt;. The following example shows the default handler:</source>
          <target state="translated">自動開始機能を使用するには、トレースするノードに格納するデータを増やす必要があります。デフォルトでは、データはトレースされたノードの現在の作業ディレクトリ（cwd）にある「ttb_autostart.bin」という名前のファイルに自動的に保存されます。ユーザーは、自動起動データの格納と取得を処理する独自のモジュール（ &lt;code&gt;runtime_tools&lt;/code&gt; の &lt;code&gt;ttb_autostart_module&lt;/code&gt; 環境変数）を指定することにより、この動作（つまり、ディスクレスノード上）を変更できます。 APIについては、モジュール &lt;code&gt;&lt;a href=&quot;ttb&quot;&gt;ttb&lt;/a&gt;&lt;/code&gt; を参照してください。次の例は、デフォルトのハンドラーを示しています。</target>
        </trans-unit>
        <trans-unit id="ec0674516ee9bb18698545632ddcef7eb77a1e62" translate="yes" xml:space="preserve">
          <source>The available OID names are as follows:</source>
          <target state="translated">利用可能なOID名は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="270053ab9a2cdd71b431ca1b29230d0131168ac8" translate="yes" xml:space="preserve">
          <source>The available configuration options are as follows:</source>
          <target state="translated">利用可能な設定オプションは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="5ffd517ca47007c093bb8a7cefdb756ebfdced63" translate="yes" xml:space="preserve">
          <source>The available configuration properties are as follows:</source>
          <target state="translated">利用可能な設定プロパティは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="0d5fbe85b0c98fe746cb7e16c8187e2dfc18521e" translate="yes" xml:space="preserve">
          <source>The average run-time for the schedulers. This is the average amount of time the schedulers did not sleep.</source>
          <target state="translated">スケジューラの平均実行時間。これは、スケジューラがスリープしなかった平均時間です。</target>
        </trans-unit>
        <trans-unit id="aaf853276797e4d431ffd98c86f3b72f5161ab87" translate="yes" xml:space="preserve">
          <source>The average time spent collecting data in the threads. This should be close to the time which data was collected.</source>
          <target state="translated">スレッド内のデータ収集に要した平均時間。これはデータが収集された時間に近いはずです。</target>
        </trans-unit>
        <trans-unit id="70cab81b62df4bb768ae5b9f87b1769a35f91166" translate="yes" xml:space="preserve">
          <source>The backslash character has many uses. First, if it is followed by a character that is not a number or a letter, it takes away any special meaning that a character can have. This use of backslash as an escape character applies both inside and outside character classes.</source>
          <target state="translated">バックスラッシュには多くの用途があります。第一に、バックスラッシュの後に数字や文字ではない文字が続くと、その文字が持つ特別な意味がなくなってしまいます。このようにエスケープ文字としてのバックスラッシュの使用は、文字クラスの内外を問わず適用されます。</target>
        </trans-unit>
        <trans-unit id="dbe5fe5807b426b9440606cd7c73c539d1bcdeff" translate="yes" xml:space="preserve">
          <source>The backup data is divided into two sections. The first section contains information related to the schema. All schema-related items are tuples where the first field equals the atom schema. The second section is the record section. Schema records cannot be mixed with other records and all schema records must be located first in the backup.</source>
          <target state="translated">バックアップデータは2つのセクションに分かれています。最初のセクションには、スキーマに関連する情報が含まれています。スキーマに関連するすべての項目は、最初のフィールドがアトムスキーマに等しいタプルである。2つ目のセクションはレコードセクションです。スキーマレコードは他のレコードと混合することはできず、すべてのスキーマレコードはバックアップで最初に配置されなければなりません。</target>
        </trans-unit>
        <trans-unit id="5cb61dbbe8949ce8224db389cdf36c3f301c26b1" translate="yes" xml:space="preserve">
          <source>The base AVPs are defined in the common dictionary provided by diameter. There are common dictionaries for both RFC 3588 and RFC 6733 since the latter made changes to both syntax and semantics.</source>
          <target state="translated">ベースとなるAVPは、diameterによって提供される共通辞書で定義される。RFC 3588とRFC 6733の両方に共通の辞書がありますが、後者はシンタックスとセマンティクスの両方に変更が加えられているためです。</target>
        </trans-unit>
        <trans-unit id="37b6dd9b192c11e194c06eb99987679081a97762" translate="yes" xml:space="preserve">
          <source>The base name of the compiled file</source>
          <target state="translated">コンパイルされたファイルのベース名</target>
        </trans-unit>
        <trans-unit id="13db919a8612a7a4080781ff054af866565ed391" translate="yes" xml:space="preserve">
          <source>The base two logarithm of the window size (the size of the history buffer). It is to be in the range 8 through 15. Larger values result in better compression at the expense of memory usage. Defaults to 15 if &lt;code&gt;&lt;a href=&quot;#deflateInit-2&quot;&gt;deflateInit/2&lt;/a&gt;&lt;/code&gt; is used. A negative &lt;code&gt;WindowBits&lt;/code&gt; value suppresses the zlib header (and checksum) from the stream. Notice that the zlib source mentions this only as a undocumented feature.</source>
          <target state="translated">ウィンドウサイズ（履歴バッファーのサイズ）の2を底とする対数。8〜15の範囲で指定します。値が大きいほど、メモリの使用量を犠牲にして圧縮率が向上します。 &lt;code&gt;&lt;a href=&quot;#deflateInit-2&quot;&gt;deflateInit/2&lt;/a&gt;&lt;/code&gt; が使用されている場合、デフォルトは15 です。負の &lt;code&gt;WindowBits&lt;/code&gt; 値は、ストリームからのzlibヘッダー（およびチェックサム）を抑制します。zlibソースがこれを文書化されていない機能としてのみ言及していることに注意してください。</target>
        </trans-unit>
        <trans-unit id="8818564f19c5c56bd354986044623c1ba1d3d72f" translate="yes" xml:space="preserve">
          <source>The basic concept is that of a &lt;strong&gt;MIB view&lt;/strong&gt;. An MIB view is a subset of all the objects implemented by an agent. A manager has access to a certain MIB view, depending on which security parameters are used, in which context the request is made, and which type of request is made.</source>
          <target state="translated">基本的な概念は、&lt;strong&gt;MIBビューの&lt;/strong&gt;概念です。MIBビューは、エージェントによって実装されるすべてのオブジェクトのサブセットです。マネージャは、使用されるセキュリティパラメータ、要求が行われるコンテキスト、要求のタイプに応じて、特定のMIBビューにアクセスできます。</target>
        </trans-unit>
        <trans-unit id="4956ca9b4e8f3cd207abf9624e243d3cdb794f4d" translate="yes" xml:space="preserve">
          <source>The basic idea of syntax highlighting is to make the structure of a program clearer. For example, the highlighting will make it easier to spot simple bugs. Have not you ever written a variable in lower-case only? With syntax highlighting a variable will colored while atoms will be shown with the normal text color.</source>
          <target state="translated">シンタックスハイライトの基本的な考え方は、プログラムの構造をより明確にすることです。例えば、ハイライト表示をすることで、簡単なバグを発見しやすくなります。小文字のみで変数を書いたことはありませんか?シンタックスハイライトを使うと、変数には色がつきますが、アトムは通常のテキスト色で表示されます。</target>
        </trans-unit>
        <trans-unit id="5ad538ab434ab340ba09c1c90fc3a4a6dea30af6" translate="yes" xml:space="preserve">
          <source>The basic idea with exclusive decode is to specify which parts of the message you want to exclude from being decoded. These parts remain encoded and are returned in the value structure as binaries. They can be decoded in turn by passing them to a certain &lt;code&gt;decode_part/2&lt;/code&gt; function. The performance gain is high for large messages. You can do an exclusive decode and later one or more decodes of the parts, or a second complete decode instead of two or more complete decodes.</source>
          <target state="translated">排他的デコードの基本的な考え方は、メッセージのどの部分をデコードから除外するかを指定することです。これらの部分はエンコードされたままで、バイナリとして値の構造に返されます。それらは、特定の &lt;code&gt;decode_part/2&lt;/code&gt; 関数に渡すことで順番にデコードできます。大きなメッセージの場合、パフォーマンスが向上します。排他的なデコードを行い、後でパーツの1つ以上のデコードを行うか、2つ以上の完全なデコードの代わりに2番目の完全なデコードを行うことができます。</target>
        </trans-unit>
        <trans-unit id="d34b055b96b341faab090f12091572854579bc39" translate="yes" xml:space="preserve">
          <source>The basic ideas from the original protocol still hold. The I/O server and client communicate with one single, rather simplistic protocol and no server state is ever present in the client. Any I/O server can be used together with any client code, and the client code does not need to be aware of the I/O device that the I/O server communicates with.</source>
          <target state="translated">オリジナルのプロトコルからの基本的な考え方は今でも保持されています。I/Oサーバとクライアントは1つのシンプルなプロトコルで通信し、クライアントにはサーバの状態は存在しません。任意のI/Oサーバは任意のクライアントコードと一緒に使用することができ、クライアントコードはI/Oサーバが通信するI/Oデバイスを認識する必要はありません。</target>
        </trans-unit>
        <trans-unit id="06f35fc40ac6c0c6f620803908f2d0ce6893c711" translate="yes" xml:space="preserve">
          <source>The basic message file</source>
          <target state="translated">基本メッセージファイル</target>
        </trans-unit>
        <trans-unit id="7b96cdbd69bdcaed6a11b07691044f3fc504705b" translate="yes" xml:space="preserve">
          <source>The behavior if a file specified in &lt;code&gt;sys.config&lt;/code&gt; does not exist, or is erroneous, is backwards compatible. Starting the runtime system will fail. Installing a new release version will not fail, but an error message is returned and the erroneous file is ignored.</source>
          <target state="translated">&lt;code&gt;sys.config&lt;/code&gt; で指定されたファイルが存在しないか、誤っている場合の動作には、下位互換性があります。ランタイムシステムの起動は失敗します。新しいリリースバージョンのインストールは失敗しませんが、エラーメッセージが返され、エラーのあるファイルは無視されます。</target>
        </trans-unit>
        <trans-unit id="a86acb8a0f20fdc979242a6b86b6e670d328548d" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if any process performs a write operation on the table while traversing the table with the function &lt;code&gt;&lt;a href=&quot;mnesia#dirty_next-2&quot;&gt;dirty_next/2&lt;/a&gt;&lt;/code&gt; This is because &lt;code&gt;write&lt;/code&gt; operations on a &lt;code&gt;Mnesia&lt;/code&gt; table can lead to internal reorganizations of the table itself. This is an implementation detail, but remember that the dirty functions are low-level functions.</source>
          <target state="translated">関数 &lt;code&gt;&lt;a href=&quot;mnesia#dirty_next-2&quot;&gt;dirty_next/2&lt;/a&gt;&lt;/code&gt; を使用してテーブルをトラバースしているときにプロセスがテーブルに対して書き込み操作を実行した場合の動作は未定義です。これは、 &lt;code&gt;Mnesia&lt;/code&gt; テーブルに対する &lt;code&gt;write&lt;/code&gt; 操作がテーブル自体の内部再編成につながる可能性があるためです。これは実装の詳細ですが、ダーティ関数は低レベル関数であることを覚えておいてください。</target>
        </trans-unit>
        <trans-unit id="1a796a85b7d7280f632e4dcbf6b4a44abe35956e" translate="yes" xml:space="preserve">
          <source>The behavior of (*PRUNE:NAME) is the not the same as (*MARK:NAME)(*PRUNE). It is like (*MARK:NAME) in that the name is remembered for passing back to the caller. However, (*SKIP:NAME) searches only for names set with (*MARK).</source>
          <target state="translated">(*PRUNE:NAME)の動作は、(*MARK:NAME)(*PRUNE)と同じではありません。(*MARK:NAME)のように、呼び出し元に渡すために名前を記憶するという点では(*MARK:NAME)と同じです。ただし、(*SKIP:NAME)は(*MARK)で設定された名前のみを検索します。</target>
        </trans-unit>
        <trans-unit id="47227c0747ba0b82f4e36ef4aee5b965307890ad" translate="yes" xml:space="preserve">
          <source>The behavior of (*THEN:NAME) is the not the same as (*MARK:NAME)(*THEN). It is like (*MARK:NAME) in that the name is remembered for passing back to the caller. However, (*SKIP:NAME) searches only for names set with (*MARK).</source>
          <target state="translated">(*THEN:NAME)の動作は、(*MARK:NAME)(*THEN)と同じではありません。(*MARK:NAME)のように、呼び出し元に渡すために名前を記憶するという点では(*MARK:NAME)と同じです。ただし、(*SKIP:NAME)は(*MARK)で設定された名前のみを検索します。</target>
        </trans-unit>
        <trans-unit id="e44b071bcc39a063eb56d16dfbf4c6bb36987d8b" translate="yes" xml:space="preserve">
          <source>The behavior of a socket with this option set to &lt;code&gt;true&lt;/code&gt; is the only portable one. The original idea when IPv6 was new of using IPv6 for all traffic is now not recommended by FreeBSD (you can use &lt;code&gt;{ipv6_v6only,false}&lt;/code&gt; to override the recommended system default value), forbidden by OpenBSD (the supported GENERIC kernel), and impossible on Windows (which has separate IPv4 and IPv6 protocol stacks). Most Linux distros still have a system default value of &lt;code&gt;false&lt;/code&gt;. This policy shift among operating systems to separate IPv6 from IPv4 traffic has evolved, as it gradually proved hard and complicated to get a dual stack implementation correct and secure.</source>
          <target state="translated">このオプションを &lt;code&gt;true&lt;/code&gt; に設定したソケットの動作は、唯一の移植可能なものです。 IPv6がすべてのトラフィックにIPv6を使用するという新機能であった当初のアイデアは、FreeBSDでは推奨されておらず（ &lt;code&gt;{ipv6_v6only,false}&lt;/code&gt; を使用して推奨システムのデフォルト値を上書きできます）、OpenBSD（サポートされているGENERICカーネル）で禁止されており、 Windows（個別のIPv4およびIPv6プロトコルスタックを持っています）。ほとんどのLinuxディストリビューションでは、システムのデフォルト値は &lt;code&gt;false&lt;/code&gt; のままです。 IPv6トラフィックをIPv4トラフィックから分離するためのオペレーティングシステム間のこのポリシーシフトは進化し、デュアルスタック実装を正確かつ安全にすることは徐々に難しく複雑になってきました。</target>
        </trans-unit>
        <trans-unit id="1a4c4b510c91839af2b2d840f0dd22a548ca7548" translate="yes" xml:space="preserve">
          <source>The behavior of dot regarding newlines can be changed. If option &lt;code&gt;dotall&lt;/code&gt; is set, a dot matches any character, without exception. If the two-character sequence CRLF is present in the subject string, it takes two dots to match it.</source>
          <target state="translated">改行に関するドットの動作を変更できます。オプション &lt;code&gt;dotall&lt;/code&gt; が設定されている場合、ドットは例外なくすべての文字に一致します。 2文字のシーケンスCRLFが件名の文字列に存在する場合、それに一致するために2つのドットが必要です。</target>
        </trans-unit>
        <trans-unit id="7965ee081ee817356aeac4f791276c29588e7325" translate="yes" xml:space="preserve">
          <source>The behavior of shell escape can be changed by the STDLIB application variable &lt;code&gt;shell_esc&lt;/code&gt;. The value of the variable can be either &lt;code&gt;jcl&lt;/code&gt; (&lt;code&gt;erl -stdlib shell_esc jcl&lt;/code&gt;) or &lt;code&gt;abort&lt;/code&gt; (&lt;code&gt;erl -stdlib shell_esc abort&lt;/code&gt;). The first option sets &lt;code&gt;^G&lt;/code&gt; to activate &lt;code&gt;JCL&lt;/code&gt; mode (which is also default behavior). The latter sets &lt;code&gt;^G&lt;/code&gt; to terminate the current shell and start a new one. &lt;code&gt;JCL&lt;/code&gt; mode cannot be invoked when &lt;code&gt;shell_esc&lt;/code&gt; is set to &lt;code&gt;abort&lt;/code&gt;.</source>
          <target state="translated">シェルエスケープの動作は、STDLIBアプリケーション変数 &lt;code&gt;shell_esc&lt;/code&gt; によって変更できます。変数の値は、 &lt;code&gt;jcl&lt;/code&gt; （ &lt;code&gt;erl -stdlib shell_esc jcl&lt;/code&gt; ）または &lt;code&gt;abort&lt;/code&gt; （ &lt;code&gt;erl -stdlib shell_esc abort&lt;/code&gt; ）のいずれかです。最初のオプションは、 &lt;code&gt;^G&lt;/code&gt; を設定して &lt;code&gt;JCL&lt;/code&gt; モードをアクティブにします（これもデフォルトの動作です）。後者は、現在のシェルを終了して新しいシェルを開始するように &lt;code&gt;^G&lt;/code&gt; を設定します。 &lt;code&gt;shell_esc&lt;/code&gt; が &lt;code&gt;abort&lt;/code&gt; に設定されている場合、 &lt;code&gt;JCL&lt;/code&gt; モードを呼び出すことはできません。</target>
        </trans-unit>
        <trans-unit id="9f28c17be27978977c1d4772358e7a511e0dfa71" translate="yes" xml:space="preserve">
          <source>The behavior of these verbs in repeated groups, assertions, and in subpatterns called as subroutines (whether or not recursively) is described below.</source>
          <target state="translated">これらの動詞の繰り返し群、アサーション、サブルーチンと呼ばれるサブパターン(再帰的か否か)での動作については、以下に説明する。</target>
        </trans-unit>
        <trans-unit id="b5f409290159e0122d24e0b32bc792ec356f3f9c" translate="yes" xml:space="preserve">
          <source>The behavior of this function changed radically in &lt;code&gt;Common Test&lt;/code&gt; 1.6.2. To keep some backwards compatability, it is still possible to do:</source>
          <target state="translated">この関数の動作は、 &lt;code&gt;Common Test&lt;/code&gt; 1.6.2で大幅に変更されました。下位互換性を維持するために、次のことを行うことも可能です。</target>
        </trans-unit>
        <trans-unit id="3cecdaf7589f62bdef0c740b1516c756288d9c79" translate="yes" xml:space="preserve">
          <source>The behavior of this function is undefined if the table is written on while being traversed. The function &lt;code&gt;&lt;a href=&quot;mnesia#read_lock_table-1&quot;&gt;mnesia:read_lock_table(Tab)&lt;/a&gt;&lt;/code&gt; can be used to ensure that no transaction-protected writes are performed during the iteration.</source>
          <target state="translated">トラバース中にテーブルが書き込まれた場合、この関数の動作は未定義です。関数 &lt;code&gt;&lt;a href=&quot;mnesia#read_lock_table-1&quot;&gt;mnesia:read_lock_table(Tab)&lt;/a&gt;&lt;/code&gt; を使用して、トランザクション保護された書き込みが反復中に実行されないようにすることができます。</target>
        </trans-unit>
        <trans-unit id="0ad444f7fffcddf3e1072340ed21b0cb1ac9f4b6" translate="yes" xml:space="preserve">
          <source>The behaviour engine holds the state machine state, server data, timer references, a queue of posponed messages and other metadata. It receives all process messages, handles the system messages, and calls the callback module with machine specific events.</source>
          <target state="translated">ビヘイビアエンジンは、ステートマシンの状態、サーバーデータ、タイマー参照、保留されたメッセージのキュー、その他のメタデータを保持します。すべてのプロセスメッセージを受信し、システムメッセージを処理し、マシン固有のイベントでコールバックモジュールを呼び出します。</target>
        </trans-unit>
        <trans-unit id="0880fce4c0b15834624e11a3dadca1d45ea29226" translate="yes" xml:space="preserve">
          <source>The behaviour module is part of Erlang/OTP. To implement a process such as a supervisor, the user only has to implement the callback module which is to export a pre-defined set of functions, the &lt;strong&gt;callback functions&lt;/strong&gt;.</source>
          <target state="translated">動作モジュールはErlang / OTPの一部です。スーパーバイザなどのプロセスを実装するには、事前定義された関数のセットである&lt;strong&gt;コールバック関数&lt;/strong&gt;をエクスポートするためのコールバックモジュールを実装するだけです。</target>
        </trans-unit>
        <trans-unit id="59e8c63ca2b59778b1c251bfe4d9af4a1c121cce" translate="yes" xml:space="preserve">
          <source>The benefit of this is that Megaco handles the starting, holding and the supervision of the driver and port.</source>
          <target state="translated">そのメリットは、Megacoが発進、保持、ドライバーとポートの監督を行うことです。</target>
        </trans-unit>
        <trans-unit id="1929daa6d9f07ef87baa0d2108c05731636b180d" translate="yes" xml:space="preserve">
          <source>The best place is in the &lt;code&gt;sys.config&lt;/code&gt; system configuration file of the release.</source>
          <target state="translated">最適な場所は、リリースの &lt;code&gt;sys.config&lt;/code&gt; システム構成ファイルです。</target>
        </trans-unit>
        <trans-unit id="d72c83f4147d145bc84c3d37b05a70b520d273ab" translate="yes" xml:space="preserve">
          <source>The binaries do not contain whole bytes (bit strings).</source>
          <target state="translated">バイナリには全バイト(ビット文字列)は含まれていません。</target>
        </trans-unit>
        <trans-unit id="2c99eedcea168087b25493bcc8656037a8c03177" translate="yes" xml:space="preserve">
          <source>The binary boot script file &lt;code&gt;Name.boot&lt;/code&gt; is generated from the boot script file &lt;code&gt;Name.script&lt;/code&gt;, using the function &lt;code&gt;systools:script2boot(File)&lt;/code&gt;.</source>
          <target state="translated">バイナリブートスクリプトファイル &lt;code&gt;Name.boot&lt;/code&gt; は、関数 &lt;code&gt;systools:script2boot(File)&lt;/code&gt; を使用して、ブートスクリプトファイル &lt;code&gt;Name.script&lt;/code&gt; から生成されます。</target>
        </trans-unit>
        <trans-unit id="c63a3b170852a27feb1e79f6999b69d62a7625a7" translate="yes" xml:space="preserve">
          <source>The binary boot script renamed to &lt;code&gt;start.boot&lt;/code&gt;</source>
          <target state="translated">バイナリブートスクリプトの名前が &lt;code&gt;start.boot&lt;/code&gt; に変更されました</target>
        </trans-unit>
        <trans-unit id="fdaeab197086e91b2d818626cc54633ed2fa6700" translate="yes" xml:space="preserve">
          <source>The binary executable file must be owned by root, have &lt;code&gt;rwsr-xr-x&lt;/code&gt; file privileges, in particular the &lt;code&gt;setuid&lt;/code&gt; bit of the user must be set.</source>
          <target state="translated">バイナリ実行可能ファイルはrootが所有し、 &lt;code&gt;rwsr-xr-x&lt;/code&gt; ファイル特権を持っている必要があります。特に、ユーザーの &lt;code&gt;setuid&lt;/code&gt; ビットを設定する必要があります。</target>
        </trans-unit>
        <trans-unit id="00fa7003833fa581d83179258571e8a367f39ad2" translate="yes" xml:space="preserve">
          <source>The binary object can be referenced by any number of ProcBins from any number of processes. The object contains a reference counter to keep track of the number of references, so that it can be removed when the last reference disappears.</source>
          <target state="translated">バイナリオブジェクトは、任意の数のプロセスから任意の数のProcBinsで参照することができます。このオブジェクトには、参照数を追跡するための参照カウンタが含まれており、最後の参照が消えたときに削除できるようになっています。</target>
        </trans-unit>
        <trans-unit id="127151f66b51ac3efe997eb464906c3d0948c0d1" translate="yes" xml:space="preserve">
          <source>The binary object itself, stored outside all process heaps</source>
          <target state="translated">すべてのプロセスヒープの外側に格納されているバイナリオブジェクト自体</target>
        </trans-unit>
        <trans-unit id="4cf0fde8a2120eccfe9fdc8a249b8de5265ff4ee" translate="yes" xml:space="preserve">
          <source>The binary output file produced by the compiler is read by the agent at MIB load time (see the figure &lt;code&gt;&lt;a href=&quot;#image-2&quot;&gt;Starting the Agent&lt;/a&gt;&lt;/code&gt;). The instrumentation is ordinary Erlang code which is loaded explicitly or automatically the first time it is called.</source>
          <target state="translated">コンパイラーによって生成されたバイナリー出力ファイルは、MIBロード時にエージェントによって読み取られます（図 &lt;code&gt;&lt;a href=&quot;#image-2&quot;&gt;Starting the Agent&lt;/a&gt;&lt;/code&gt; 参照）。インストルメンテーションは通常のErlangコードであり、最初に呼び出されたときに明示的または自動的にロードされます。</target>
        </trans-unit>
        <trans-unit id="d082c75a002a09432e39d447b940479e08b9f5e4" translate="yes" xml:space="preserve">
          <source>The bit syntax contains types for handling binary data in the three main encodings. The types are named &lt;code&gt;utf8&lt;/code&gt;, &lt;code&gt;utf16&lt;/code&gt;, and &lt;code&gt;utf32&lt;/code&gt;. The &lt;code&gt;utf16&lt;/code&gt; and &lt;code&gt;utf32&lt;/code&gt; types can be in a big-endian or a little-endian variant:</source>
          <target state="translated">ビット構文には、3つの主要なエンコーディングでバイナリデータを処理するための型が含まれています。タイプの名前は &lt;code&gt;utf8&lt;/code&gt; 、 &lt;code&gt;utf16&lt;/code&gt; 、および &lt;code&gt;utf32&lt;/code&gt; です。 &lt;code&gt;utf16&lt;/code&gt; および &lt;code&gt;utf32&lt;/code&gt; のタイプはビッグエンディアンかリトルエンディアンバリアントで使用できます</target>
        </trans-unit>
        <trans-unit id="7305cb0adee2541b623171c05bf3f3d1ecacd9f6" translate="yes" xml:space="preserve">
          <source>The body of the fun is used to construct the resulting value. When selecting from tables, one usually construct a suiting term here, using ordinary Erlang term construction, like tuple parentheses, list brackets, and variables matched out in the head, possibly with the occasional constant. Whatever expressions are allowed in guards are also allowed here, but no special functions exist except &lt;code&gt;object&lt;/code&gt; and &lt;code&gt;bindings&lt;/code&gt; (see further down), which returns the whole matched object and all known variable bindings, respectively.</source>
          <target state="translated">funの本体は、結果の値を構成するために使用されます。テーブルから選択する場合、タプル括弧、リストブラケット、頭の中で一致する可能性のある変数などの通常のErlang用語構成を使用して、適切な用語を通常ここで作成します。ガードで許可されている式はすべてここでも許可されますが、一致したオブジェクト全体とすべての既知の変数バインディングをそれぞれ返す &lt;code&gt;object&lt;/code&gt; と &lt;code&gt;bindings&lt;/code&gt; （以下を参照）以外に特別な関数はありません。</target>
        </trans-unit>
        <trans-unit id="d4ca0de7223fe258efb581336c1e0197d5d0edd2" translate="yes" xml:space="preserve">
          <source>The boot script included in a release package must be generated from the same &lt;code&gt;.rel&lt;/code&gt; file as the release package itself.</source>
          <target state="translated">リリースパッケージに含まれるブートスクリプトは、リリースパッケージ自体と同じ &lt;code&gt;.rel&lt;/code&gt; ファイルから生成する必要があります。</target>
        </trans-unit>
        <trans-unit id="ddcf162c693f295280c787fbd8290adee7c45ca3" translate="yes" xml:space="preserve">
          <source>The boot script is stored in a file with extension &lt;code&gt;.script&lt;/code&gt;. The file has the following syntax:</source>
          <target state="translated">ブートスクリプトは、拡張子が &lt;code&gt;.script&lt;/code&gt; のファイルに保存されます。ファイルの構文は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="41a09207a22769c0574e34261e0d72dca94a1cd1" translate="yes" xml:space="preserve">
          <source>The branches of an &lt;code&gt;if&lt;/code&gt;-expression are scanned sequentially until a guard sequence &lt;code&gt;GuardSeq&lt;/code&gt; that evaluates to true is found. Then the corresponding &lt;code&gt;Body&lt;/code&gt; (sequence of expressions separated by ',') is evaluated.</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; 式の分岐は、trueと評価されるガードシーケンス &lt;code&gt;GuardSeq&lt;/code&gt; が見つかるまで順次スキャンされます。次に、対応する &lt;code&gt;Body&lt;/code&gt; （「、」で区切られた式のシーケンス）が評価されます。</target>
        </trans-unit>
        <trans-unit id="c635f7fb465fc59e43a777e3d06741481d050b03" translate="yes" xml:space="preserve">
          <source>The browser must run as a separate OS process, otherwise VTS hangs.</source>
          <target state="translated">ブラウザは別のOSプロセスとして実行する必要があり、そうでない場合はVTSがハングアップします。</target>
        </trans-unit>
        <trans-unit id="1acf68389c692a738d63487b4a06a4e7162935c1" translate="yes" xml:space="preserve">
          <source>The buffer pointed to by &lt;code&gt;v&lt;/code&gt; must be large enough to hold the return data, that is, it must be a pointer to one of &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, &lt;code&gt;char*&lt;/code&gt;, or &lt;code&gt;void*&lt;/code&gt;, respectively.</source>
          <target state="translated">&lt;code&gt;v&lt;/code&gt; が指すバッファーは、戻りデータを保持するのに十分な大きさである必要があります。つまり、それぞれ、 &lt;code&gt;int&lt;/code&gt; 、 &lt;code&gt;double&lt;/code&gt; 、 &lt;code&gt;char*&lt;/code&gt; 、または &lt;code&gt;void*&lt;/code&gt; いずれかへのポインターでなければなりません。</target>
        </trans-unit>
        <trans-unit id="eaa6a3f621852e6e7b5c05f1f4dfe807f43eee5b" translate="yes" xml:space="preserve">
          <source>The build system, including cross compilation configuration variables used, may be subject to non backward compatible changes without prior notice. Current cross build system has been tested when cross compiling some Linux/GNU systems, but has only been partly tested for more esoteric platforms. The VxWorks example file is highly dependent on our environment and is here more or less only for internal use.</source>
          <target state="translated">使用されているクロスコンパイルの設定変数を含むビルドシステムは、事前の予告なしに下位互換性のない変更を受ける可能性があります。現在のクロスビルドシステムは、いくつかのLinux/GNUシステムをクロスコンパイルする際にテストされていますが、より難解なプラットフォームについては部分的にしかテストされていません。VxWorksのサンプルファイルは、我々の環境に大きく依存しており、ここでは多かれ少なかれ内部での使用のみを目的としています。</target>
        </trans-unit>
        <trans-unit id="6fef17f4398287d703d6c8738ea77d284a4abce3" translate="yes" xml:space="preserve">
          <source>The builtin random number generator algorithms are not cryptographically strong. If a cryptographically strong random number generator is needed, use something like &lt;code&gt;crypto:rand_seed/0&lt;/code&gt;.</source>
          <target state="translated">組み込みの乱数ジェネレータアルゴリズムは、暗号的に強力ではありません。暗号学的に強力な乱数ジェネレータが必要な場合は、 &lt;code&gt;crypto:rand_seed/0&lt;/code&gt; などを使用します。</target>
        </trans-unit>
        <trans-unit id="067acc920ec0fee7fa628aac8051ca95ed671e0c" translate="yes" xml:space="preserve">
          <source>The busy message queue feature can be disabled either by setting the &lt;code&gt;ERL_DRV_FLAG_NO_BUSY_MSGQ&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;driver_entry#driver_flags&quot;&gt;driver flag&lt;/a&gt;&lt;/code&gt; in the &lt;code&gt;&lt;a href=&quot;driver_entry&quot;&gt;driver_entry&lt;/a&gt;&lt;/code&gt; used by the driver, or by calling this function with &lt;code&gt;ERL_DRV_BUSY_MSGQ_DISABLED&lt;/code&gt; as a limit (either low or high). When this feature has been disabled, it cannot be enabled again. When reading the limits, both are &lt;code&gt;ERL_DRV_BUSY_MSGQ_DISABLED&lt;/code&gt; if this feature has been disabled.</source>
          <target state="translated">使用中のメッセージキュー機能は、ドライバーが使用する &lt;code&gt;&lt;a href=&quot;driver_entry&quot;&gt;driver_entry&lt;/a&gt;&lt;/code&gt; で &lt;code&gt;ERL_DRV_FLAG_NO_BUSY_MSGQ&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;driver_entry#driver_flags&quot;&gt;driver flag&lt;/a&gt;&lt;/code&gt; 設定するか、 &lt;code&gt;ERL_DRV_BUSY_MSGQ_DISABLED&lt;/code&gt; を制限としてこの関数を呼び出す（低または高）ことによって無効にできます。この機能を無効にすると、再度有効にすることはできません。制限を読み取るとき、この機能が無効になっていると、両方が &lt;code&gt;ERL_DRV_BUSY_MSGQ_DISABLED&lt;/code&gt; になります。</target>
        </trans-unit>
        <trans-unit id="33650cf8255f90c21ac81005064a8fbf5483e732" translate="yes" xml:space="preserve">
          <source>The button takes you to the code coverage overview page. If you have successfully performed a detailed coverage analysis, links to each individual module coverage page are found here.</source>
          <target state="translated">このボタンをクリックすると、コードカバレッジの概要ページに移動します。詳細なカバレッジ分析を正常に実行した場合、各モジュールのカバレッジページへのリンクはここにあります。</target>
        </trans-unit>
        <trans-unit id="709ea736382b67af3f9c144683016c97550b6e99" translate="yes" xml:space="preserve">
          <source>The bytes are decoded to a code point in the invalid Unicode range.</source>
          <target state="translated">バイトは無効な Unicode 範囲のコードポイントにデコードされます。</target>
        </trans-unit>
        <trans-unit id="276396b4a984d3ef578929de68a65d7f15a4afbf" translate="yes" xml:space="preserve">
          <source>The bytes are decoded to a too large number.</source>
          <target state="translated">バイト数が大きすぎるほどデコードされています。</target>
        </trans-unit>
        <trans-unit id="953ab7ba3d595c2a841438d3ab4f4c182fb2eff6" translate="yes" xml:space="preserve">
          <source>The cache size can be changed from its default value using the &lt;code&gt;crypto app's&lt;/code&gt; configuration parameter &lt;code&gt;rand_cache_size&lt;/code&gt;.</source>
          <target state="translated">キャッシュサイズは、 &lt;code&gt;crypto app's&lt;/code&gt; 設定パラメーター &lt;code&gt;rand_cache_size&lt;/code&gt; を使用してデフォルト値から変更できます。</target>
        </trans-unit>
        <trans-unit id="2e019f9fcd17a687470aea637478863f5e134cb3" translate="yes" xml:space="preserve">
          <source>The call &lt;code&gt;module_info(Key)&lt;/code&gt;, where &lt;code&gt;Key&lt;/code&gt; is an atom, returns a single piece of information about the module.</source>
          <target state="translated">&lt;code&gt;Key&lt;/code&gt; がアトムである &lt;code&gt;module_info(Key)&lt;/code&gt; の呼び出しは、モジュールに関する単一の情報を返します。</target>
        </trans-unit>
        <trans-unit id="a72f41bd0ef1a660b71b19854f4a2f611d367c22" translate="yes" xml:space="preserve">
          <source>The call can also fail, for example, if the &lt;code&gt;gen_statem&lt;/code&gt; dies before or during this function call.</source>
          <target state="translated">たとえば、この関数呼び出しの前または最中に &lt;code&gt;gen_statem&lt;/code&gt; が停止した場合も、呼び出しが失敗する可能性があります。</target>
        </trans-unit>
        <trans-unit id="8367b12b1eaff6fc40fd96b320d7987c710ba242" translate="yes" xml:space="preserve">
          <source>The call can fail for many reasons, including time-out and the called &lt;code&gt;gen_server&lt;/code&gt; process dying before or during the call.</source>
          <target state="translated">タイムアウトや、呼び出された &lt;code&gt;gen_server&lt;/code&gt; プロセスが呼び出し前または呼び出し中に終了するなど、さまざまな理由で呼び出しが失敗する可能性があります。</target>
        </trans-unit>
        <trans-unit id="4739e34ca18c32d95d687955ecad4a46982e910c" translate="yes" xml:space="preserve">
          <source>The call counters for all matching functions that has got call count breakpoints are paused at their current count.</source>
          <target state="translated">呼び出しカウントのブレークポイントを持つすべてのマッチする関数の呼び出しカウントは、現在のカウントで一時停止されます。</target>
        </trans-unit>
        <trans-unit id="52c5d88794b3b9c10b033bc03376b7dc1bc55692" translate="yes" xml:space="preserve">
          <source>The call counters for all matching functions that has got call count breakpoints are set to zero and running.</source>
          <target state="translated">コールカウントのブレークポイントを持っているすべてのマッチする関数のコールカウンタをゼロに設定して実行します。</target>
        </trans-unit>
        <trans-unit id="fcd429bca91d28345133d5ddfc12f2039568c7e0" translate="yes" xml:space="preserve">
          <source>The call fails with a &lt;code&gt;{badmap,Map}&lt;/code&gt; exception if &lt;code&gt;Map1&lt;/code&gt; is not a map, or with a &lt;code&gt;{badkey,Key}&lt;/code&gt; exception if no value is associated with &lt;code&gt;Key&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Map1&lt;/code&gt; がマップでない場合は &lt;code&gt;{badmap,Map}&lt;/code&gt; 例外で失敗し、値が &lt;code&gt;Key&lt;/code&gt; に関連付けられていない場合は &lt;code&gt;{badkey,Key}&lt;/code&gt; 例外で失敗します。</target>
        </trans-unit>
        <trans-unit id="a765e0cc7b8afeedc4b406e029455c41a2e05717" translate="yes" xml:space="preserve">
          <source>The call fails with a &lt;code&gt;{badmap,Map}&lt;/code&gt; exception if &lt;code&gt;Map1&lt;/code&gt; is not a map.</source>
          <target state="translated">&lt;code&gt;Map1&lt;/code&gt; がマップでない場合 &lt;code&gt;{badmap,Map}&lt;/code&gt; 呼び出しは{badmap、Map}例外で失敗します。</target>
        </trans-unit>
        <trans-unit id="3bcc437b0d2af2e5401d95afab2b22b04d0cd309" translate="yes" xml:space="preserve">
          <source>The call fails with a &lt;code&gt;{badmap,Map}&lt;/code&gt; exception if &lt;code&gt;Map1&lt;/code&gt; or &lt;code&gt;Map2&lt;/code&gt; is not a map.</source>
          <target state="translated">&lt;code&gt;Map1&lt;/code&gt; または &lt;code&gt;Map2&lt;/code&gt; がマップでない場合 &lt;code&gt;{badmap,Map}&lt;/code&gt; 呼び出しは{badmap、Map}例外で失敗します。</target>
        </trans-unit>
        <trans-unit id="e5f8317a62b38be81b80524eaf41aa4ccce539a0" translate="yes" xml:space="preserve">
          <source>The call fails with a &lt;code&gt;{badmap,Map}&lt;/code&gt; exception if &lt;code&gt;Map&lt;/code&gt; is not a map, or with a &lt;code&gt;{badkey,Key}&lt;/code&gt; exception if no value is associated with &lt;code&gt;Key&lt;/code&gt;.</source>
          <target state="translated">呼び出しが失敗すると &lt;code&gt;{badmap,Map}&lt;/code&gt; 場合、例外 &lt;code&gt;Map&lt;/code&gt; マップ、またはではない &lt;code&gt;{badkey,Key}&lt;/code&gt; 例外値が関連付けられていない場合は &lt;code&gt;Key&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7b3d448e3253ce8fb6ba525c95cf4c520a4dd69a" translate="yes" xml:space="preserve">
          <source>The call fails with a &lt;code&gt;{badmap,Map}&lt;/code&gt; exception if &lt;code&gt;Map&lt;/code&gt; is not a map.</source>
          <target state="translated">&lt;code&gt;Map&lt;/code&gt; がマップでない場合 &lt;code&gt;{badmap,Map}&lt;/code&gt; 呼び出しは{badmap、Map}例外で失敗します。</target>
        </trans-unit>
        <trans-unit id="16f4ecacaaaef2b7ebc1761887fc6a38ffe0b906" translate="yes" xml:space="preserve">
          <source>The call fails with a &lt;code&gt;{badmap,Map}&lt;/code&gt; exception if &lt;code&gt;MapOrIter&lt;/code&gt; is not a map or valid iterator, or with &lt;code&gt;badarg&lt;/code&gt; if &lt;code&gt;Fun&lt;/code&gt; is not a function of arity 2.</source>
          <target state="translated">呼び出しが失敗すると &lt;code&gt;{badmap,Map}&lt;/code&gt; 場合は例外 &lt;code&gt;MapOrIter&lt;/code&gt; はマップまたは有効なイテレータではないか、と &lt;code&gt;badarg&lt;/code&gt; あれば &lt;code&gt;Fun&lt;/code&gt; アリティ2の機能ではありません。</target>
        </trans-unit>
        <trans-unit id="12f759a8b6547e05c46e411430a759d92783001f" translate="yes" xml:space="preserve">
          <source>The call fails with a &lt;code&gt;{badmap,Map}&lt;/code&gt; exception if &lt;code&gt;MapOrIter&lt;/code&gt; is not a map or valid iterator, or with &lt;code&gt;badarg&lt;/code&gt; if &lt;code&gt;Fun&lt;/code&gt; is not a function of arity 3.</source>
          <target state="translated">呼び出しが失敗すると &lt;code&gt;{badmap,Map}&lt;/code&gt; 場合は例外 &lt;code&gt;MapOrIter&lt;/code&gt; はマップまたは有効なイテレータではないか、と &lt;code&gt;badarg&lt;/code&gt; あれば &lt;code&gt;Fun&lt;/code&gt; アリティ3の機能ではありません。</target>
        </trans-unit>
        <trans-unit id="ac940292242acb2f76654b1a0d7f61a1dafc1f65" translate="yes" xml:space="preserve">
          <source>The call fails with a &lt;code&gt;{badmap,Map}&lt;/code&gt; exception if &lt;code&gt;MapOrIter&lt;/code&gt; is not a map or valid iterator, or with &lt;code&gt;badarg&lt;/code&gt; if &lt;code&gt;Pred&lt;/code&gt; is not a function of arity 2.</source>
          <target state="translated">呼び出しが失敗すると &lt;code&gt;{badmap,Map}&lt;/code&gt; 場合、例外 &lt;code&gt;MapOrIter&lt;/code&gt; は地図または有効なイテレータ、またはでない &lt;code&gt;badarg&lt;/code&gt; 場合 &lt;code&gt;Pred&lt;/code&gt; アリティ2の関数ではありません。</target>
        </trans-unit>
        <trans-unit id="2892cf3454075f0053d7bd91a8d8a1dd21669320" translate="yes" xml:space="preserve">
          <source>The call format may be different if a customized prologue file has been included when generating the parser instead of the default file &lt;code&gt;lib/parsetools/include/yeccpre.hrl&lt;/code&gt;.</source>
          <target state="translated">デフォルトのファイル &lt;code&gt;lib/parsetools/include/yeccpre.hrl&lt;/code&gt; の代わりにパーサーの生成時にカスタマイズされたプロローグファイルが含まれている場合、呼び出し形式は異なる場合があります。</target>
        </trans-unit>
        <trans-unit id="2e8198892cee32a7b8526bf6bc65cdd83e83fc69" translate="yes" xml:space="preserve">
          <source>The call gives the following result, as the first explicitly captured subpattern is &quot;(abcd)&quot;, matching &quot;abcd&quot; in the subject, at (zero-based) position 3, of length 4:</source>
          <target state="translated">この呼び出しは、最初に明示的に捕捉されたサブパターンが&quot;(abcd)&quot;であり、(ゼロベースの)位置3にある長さ4のサブパターン &quot;abcd &quot;と一致しているため、以下のような結果が得られます。</target>
        </trans-unit>
        <trans-unit id="daf666a091f35efff4124fee9f5b0c58cdf83623" translate="yes" xml:space="preserve">
          <source>The call is wrapped in a case statement and will be evaluated only if &lt;code&gt;Level&lt;/code&gt; is equal to or below the configured log level.</source>
          <target state="translated">呼び出しはcaseステートメントでラップされ、 &lt;code&gt;Level&lt;/code&gt; が構成されたログレベル以下の場合にのみ評価されます。</target>
        </trans-unit>
        <trans-unit id="de78c6fd6e7546e57186f359788dd6c58cc04ff8" translate="yes" xml:space="preserve">
          <source>The call of this function will trigger the callback function UserMod:handle_connect/2 to be invoked. See the megaco_user module for more info about the callback arguments.</source>
          <target state="translated">この関数を呼び出すと、コールバック関数 UserMod:handle_connect/2 が呼び出されます。コールバック引数の詳細については megaco_user モジュールを参照してください。</target>
        </trans-unit>
        <trans-unit id="f6eff7cd52eb9afdfc9d628f7416b2b3d981918c" translate="yes" xml:space="preserve">
          <source>The call to &lt;code&gt;io:format/2&lt;/code&gt; will never be executed, but a return address will still be pushed to the stack each time &lt;code&gt;loop/0&lt;/code&gt; is called recursively. The correct tail-recursive version of the function looks as follows:</source>
          <target state="translated">&lt;code&gt;io:format/2&lt;/code&gt; の呼び出しは実行されませんが、 &lt;code&gt;loop/0&lt;/code&gt; が再帰的に呼び出されるたびに、戻りアドレスがスタックにプッシュされます。関数の正しい末尾再帰バージョンは次のようになります。</target>
        </trans-unit>
        <trans-unit id="69e4234e48da562de4b3fe66e96e15cc38ad9a57" translate="yes" xml:space="preserve">
          <source>The call to &lt;code&gt;load_nif/2&lt;/code&gt; must be made &lt;strong&gt;directly&lt;/strong&gt; from the Erlang code of the module that the NIF library belongs to. It returns either &lt;code&gt;ok&lt;/code&gt;, or &lt;code&gt;{error,{Reason,Text}}&lt;/code&gt; if loading fails. &lt;code&gt;Reason&lt;/code&gt; is one of the following atoms while &lt;code&gt;Text&lt;/code&gt; is a human readable string that can give more information about the failure:</source>
          <target state="translated">&lt;code&gt;load_nif/2&lt;/code&gt; の呼び出しは、NIFライブラリが属するモジュールのErlangコードから&lt;strong&gt;直接行う&lt;/strong&gt;必要があります。読み込みに失敗した場合は、 &lt;code&gt;ok&lt;/code&gt; または &lt;code&gt;{error,{Reason,Text}}&lt;/code&gt; 返します。 &lt;code&gt;Reason&lt;/code&gt; は次のアトムの1つですが、 &lt;code&gt;Text&lt;/code&gt; は人間が読める文字列であり、失敗に関する詳細情報を提供できます。</target>
        </trans-unit>
        <trans-unit id="65c74848bb8184c1160ce5aeb1b1f12389a01cd3" translate="yes" xml:space="preserve">
          <source>The call to &lt;code&gt;load_nif/2&lt;/code&gt; was made from the old code of a module that has been upgraded; this is not allowed.</source>
          <target state="translated">&lt;code&gt;load_nif/2&lt;/code&gt; の呼び出しは、アップグレードされたモジュールの古いコードから行われました。これは許可されていません。</target>
        </trans-unit>
        <trans-unit id="9645f8ce41967acca4649554ceab30271d3386df" translate="yes" xml:space="preserve">
          <source>The call to &lt;code&gt;return_trace&lt;/code&gt; results in a trace message when the function returns. It applies only to the specific function call triggering the match specification (and matching the head/guards of the match specification). This is by far the most common call in the body of a &lt;code&gt;dbg&lt;/code&gt; match specification.</source>
          <target state="translated">&lt;code&gt;return_trace&lt;/code&gt; を呼び出すと、関数が戻るときにトレースメッセージが表示されます。これは、一致指定をトリガーする（および一致指定のヘッド/ガードを一致させる）特定の関数呼び出しにのみ適用されます。これは、 &lt;code&gt;dbg&lt;/code&gt; の一致仕様の本文で最も一般的な呼び出しです。</target>
        </trans-unit>
        <trans-unit id="92d19c83ca0b80ba803b67a868b3108e7fb7711b" translate="yes" xml:space="preserve">
          <source>The call to the analyze function must be as follows:</source>
          <target state="translated">analyze関数の呼び出しは以下のようにしなければなりません。</target>
        </trans-unit>
        <trans-unit id="55e6d7779dabe02d283cfb249b485592e929b71e" translate="yes" xml:space="preserve">
          <source>The call will fail with a &lt;code&gt;{badmap,Map}&lt;/code&gt; exception if &lt;code&gt;Map1&lt;/code&gt; is not a map.</source>
          <target state="translated">&lt;code&gt;Map1&lt;/code&gt; がマップでない場合 &lt;code&gt;{badmap,Map}&lt;/code&gt; 呼び出しは{badmap、Map}例外で失敗します。</target>
        </trans-unit>
        <trans-unit id="fa1f952e3b1c0797c615bedda4b65ed54a10a69e" translate="yes" xml:space="preserve">
          <source>The call will return &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt; depending on the check. The caller do not need to handle the matching rules in the rfc. The matching will proceed as:</source>
          <target state="translated">呼び出しは、チェックに応じて &lt;code&gt;true&lt;/code&gt; または &lt;code&gt;false&lt;/code&gt; を返します。呼び出し元は、rfcで一致するルールを処理する必要はありません。マッチングは次のように進行します。</target>
        </trans-unit>
        <trans-unit id="104de9fe47518d4f0de85d87c6a5c1db2f88d084" translate="yes" xml:space="preserve">
          <source>The call:</source>
          <target state="translated">呼び出しだ</target>
        </trans-unit>
        <trans-unit id="1514747db293879c8ce291ed88a8dae74c64014f" translate="yes" xml:space="preserve">
          <source>The callback function UserMod:handle_trans_reply/4 is invoked when the reply arrives, when the request timer eventually times out or when the outstanding requests are explicitly cancelled. See the megaco_user module for more info about the callback arguments.</source>
          <target state="translated">コールバック関数 UserMod:handle_trans_reply/4 は、返信が到着したとき、リクエストタイマーがタイムアウトしたとき、または未解決のリクエストが明示的にキャンセルされたときに呼び出されます。コールバック引数の詳細については megaco_user モジュールを参照してください。</target>
        </trans-unit>
        <trans-unit id="e40447571e80d72283361f5ca0d8dcdb93fefaa2" translate="yes" xml:space="preserve">
          <source>The callback function handling the &lt;code&gt;stop&lt;/code&gt; request returns a tuple &lt;code&gt;{stop,normal,State1}&lt;/code&gt;, where &lt;code&gt;normal&lt;/code&gt; specifies that it is a normal termination and &lt;code&gt;State1&lt;/code&gt; is a new value for the state of the &lt;code&gt;gen_server&lt;/code&gt;. This causes the &lt;code&gt;gen_server&lt;/code&gt; to call &lt;code&gt;terminate(normal, State1)&lt;/code&gt; and then it terminates gracefully.</source>
          <target state="translated">処理コールバック機能 &lt;code&gt;stop&lt;/code&gt; 要求がタプル返し &lt;code&gt;{stop,normal,State1}&lt;/code&gt; 、 &lt;code&gt;normal&lt;/code&gt; 指定は、それが正常終了であることをと &lt;code&gt;State1&lt;/code&gt; 状態の新しい値である &lt;code&gt;gen_server&lt;/code&gt; 。これにより、 &lt;code&gt;gen_server&lt;/code&gt; は &lt;code&gt;terminate(normal, State1)&lt;/code&gt; を呼び出し、その後正常に終了します。</target>
        </trans-unit>
        <trans-unit id="728b1d3be49a797310af6aa94681789dfdda4be1" translate="yes" xml:space="preserve">
          <source>The callback function is expected to clean up its used resources after the aborted file transfer, such as closing open file descriptors and so on. The function is not invoked if any of the other callback functions returns an error, as it is expected that they already have cleaned up the necessary resources. However, it is invoked if the functions fail (crash).</source>
          <target state="translated">コールバック関数は、中断されたファイル転送の後に、開いているファイルディスクリプタを閉じるなど、使用したリソースをクリーンアップすることが期待されています。他のコールバック関数がエラーを返しても、必要なリソースは既にクリーンアップされていると予想されるため、この関数は呼び出されません。しかし、関数が失敗した (クラッシュした)場合には呼び出されます。</target>
        </trans-unit>
        <trans-unit id="109919e956ac7fc9c9c7ca8c3328e95855910a87" translate="yes" xml:space="preserve">
          <source>The callback function is expected to close the file when the last file chunk is encountered. When an error is encountered, the callback function is expected to clean up after the aborted file transfer, such as closing open file descriptors, and so on. In both cases there will be no more calls to any of the callback functions.</source>
          <target state="translated">コールバック関数は、最後のファイルチャンクに遭遇したときにファイルを閉じることが期待されます。エラーが発生した場合は、コールバック関数は、開いているファイルディスクリプタを閉じるなど、ファイル転送が中断した後のクリーンアップを行うことが期待されます。どちらの場合も、コールバック関数を呼び出すことはありません。</target>
        </trans-unit>
        <trans-unit id="84bacd9fc6215821a0c57cf0a99b64819b895b8b" translate="yes" xml:space="preserve">
          <source>The callback function is to be defined as follows:</source>
          <target state="translated">コールバック関数は以下のように定義する。</target>
        </trans-unit>
        <trans-unit id="898a8e55f83f4732a3d9a1c55861f5556e256a82" translate="yes" xml:space="preserve">
          <source>The callback function itself did the updates.</source>
          <target state="translated">コールバック関数自体が更新を行っていました。</target>
        </trans-unit>
        <trans-unit id="1d90b6e19e5f31bc52641082a2d815396c2a8af1" translate="yes" xml:space="preserve">
          <source>The callback function to use. &lt;code&gt;Module&lt;/code&gt; and &lt;code&gt;Function&lt;/code&gt; are atoms and &lt;code&gt;Args&lt;/code&gt; is a list of terms. When an OS message &lt;code&gt;Msg&lt;/code&gt; is received, this function is called as &lt;code&gt;apply(Module, Function, [Msg | Args])&lt;/code&gt;.</source>
          <target state="translated">使用するコールバック関数。 &lt;code&gt;Module&lt;/code&gt; と &lt;code&gt;Function&lt;/code&gt; はアトムで、 &lt;code&gt;Args&lt;/code&gt; は用語のリストです。OSメッセージ &lt;code&gt;Msg&lt;/code&gt; を受信すると、この関数は &lt;code&gt;apply(Module, Function, [Msg | Args])&lt;/code&gt; として呼び出されます。</target>
        </trans-unit>
        <trans-unit id="bf66fa0dd7df5d0912660af5ccc84e8028f914a6" translate="yes" xml:space="preserve">
          <source>The callback function works as described in &lt;code&gt;os_sup(3)&lt;/code&gt;.</source>
          <target state="translated">コールバック関数は、 &lt;code&gt;os_sup(3)&lt;/code&gt; で説明されているように機能します。</target>
        </trans-unit>
        <trans-unit id="1ea45999ad4acd01ff35ccee071d905b456a15b2" translate="yes" xml:space="preserve">
          <source>The callback functions cannot be used to allow or disallow execution of functions called from compiled code (only functions called from expressions entered at the shell prompt).</source>
          <target state="translated">コールバック関数を使用して、コンパイルされたコードから呼び出された関数の実行を許可したり、許可しなかったりすることはできません (シェルプロンプトで入力された式から呼び出された関数のみ)。</target>
        </trans-unit>
        <trans-unit id="96dd8e426598dea1368d28980aebceed3f1b20a0" translate="yes" xml:space="preserve">
          <source>The callback functions of the module can be specified either directly by the exported function &lt;code&gt;behaviour_info/1&lt;/code&gt;:</source>
          <target state="translated">モジュールのコールバック関数は、エクスポートされた関数 &lt;code&gt;behaviour_info/1&lt;/code&gt; によって直接指定できます。</target>
        </trans-unit>
        <trans-unit id="54dd23c9ceb4245139e54c85cd25b72ecec0fba9" translate="yes" xml:space="preserve">
          <source>The callback functions to be implemented by the test suite are all listed in module &lt;code&gt;&lt;a href=&quot;common_test&quot;&gt;common_test&lt;/a&gt;&lt;/code&gt;. They are also described in more detail later in this User's Guide.</source>
          <target state="translated">テストスイートによって実装されるコールバック関数は、すべて &lt;code&gt;&lt;a href=&quot;common_test&quot;&gt;common_test&lt;/a&gt;&lt;/code&gt; モジュールにリストされています。これらについても、このユーザーズガイドで後ほど詳しく説明します。</target>
        </trans-unit>
        <trans-unit id="85791b6dc548416b6612b724000cfadda018f22a" translate="yes" xml:space="preserve">
          <source>The callback interface is based on that the user sends a fun with the correct signature to the parser.</source>
          <target state="translated">コールバックインターフェースは、ユーザーがパーサに正しいシグネチャを持つ fun を送信することに基づいています。</target>
        </trans-unit>
        <trans-unit id="59e965f4c45d1fd48637f0634a7fe7cb62c0c3bd" translate="yes" xml:space="preserve">
          <source>The callback interface of the transport module contains several functions. Some of which are mandatory while others are only optional:</source>
          <target state="translated">トランスポートモジュールのコールバックインターフェースはいくつかの関数を含んでいます。いくつかの関数は必須ですが、他の関数はオプションです。</target>
        </trans-unit>
        <trans-unit id="cd251fb009bc0977864cd404e86e72a74db2ce5c" translate="yes" xml:space="preserve">
          <source>The callback is made by a middleman process, hence the file transfer is not affected by the code in the progress callback function. If the callback crashes, this is detected by the FTP connection process, which then prints an info-report and goes on as if the progress option was set to &lt;code&gt;ignore&lt;/code&gt;.</source>
          <target state="translated">コールバックは仲介者プロセスによって行われるため、ファイル転送は進行状況コールバック関数のコードの影響を受けません。コールバックがクラッシュした場合、これはFTP接続プロセスによって検出され、情報レポートが出力され、progressオプションが &lt;code&gt;ignore&lt;/code&gt; に設定されているかのように続行されます。</target>
        </trans-unit>
        <trans-unit id="e8e4051d9662c60ffac0c38b92a0a52ef07de6ce" translate="yes" xml:space="preserve">
          <source>The callback mode &lt;code&gt;handle_event_function&lt;/code&gt; enables using a non-atom state as described in section &lt;code&gt;&lt;a href=&quot;#Callback%20Modes&quot;&gt;Callback Modes&lt;/a&gt;&lt;/code&gt;, for example, a complex state term like a tuple.</source>
          <target state="translated">コールバックモードの &lt;code&gt;handle_event_function&lt;/code&gt; を使用すると、セクション &lt;code&gt;&lt;a href=&quot;#Callback%20Modes&quot;&gt;Callback Modes&lt;/a&gt;&lt;/code&gt; で説明されているように、非アトムの状態を使用できます。たとえば、タプルのような複雑な状態の用語を使用できます。</target>
        </trans-unit>
        <trans-unit id="b9074f752748f19027b380bf6c6083917557b4d1" translate="yes" xml:space="preserve">
          <source>The callback mode is selected at server start and may be changed with a code upgrade/downgrade.</source>
          <target state="translated">コールバックモードはサーバの起動時に選択され、コードのアップグレード/ダウングレードで変更することができます。</target>
        </trans-unit>
        <trans-unit id="a1b667b206213a5b84a8db86f75c2c72599f104c" translate="yes" xml:space="preserve">
          <source>The callback mode is selected by implementing a mandatory callback function &lt;code&gt;Module:callback_mode()&lt;/code&gt; that returns one of the callback modes.</source>
          <target state="translated">コールバックモードは、コールバックモードの1つを返す必須のコールバック関数 &lt;code&gt;Module:callback_mode()&lt;/code&gt; を実装することによって選択されます。</target>
        </trans-unit>
        <trans-unit id="ead6e2ff311fd428d1dc6968b3919ecff631ec58" translate="yes" xml:space="preserve">
          <source>The callback model(s) for &lt;code&gt;gen_statem&lt;/code&gt; differs from the one for &lt;code&gt;&lt;a href=&quot;gen_fsm&quot;&gt;gen_fsm&lt;/a&gt;&lt;/code&gt;, but it is still fairly easy to &lt;code&gt;&lt;a href=&quot;gen_fsm#Migration%20to%20gen_statem&quot;&gt;rewrite from&lt;/a&gt;&lt;/code&gt;&lt;code&gt;gen_fsm&lt;/code&gt; to &lt;code&gt;gen_statem&lt;/code&gt;.</source>
          <target state="translated">コールバックのためのモデル（S） &lt;code&gt;gen_statem&lt;/code&gt; のためのものと異なって &lt;code&gt;&lt;a href=&quot;gen_fsm&quot;&gt;gen_fsm&lt;/a&gt;&lt;/code&gt; が、それはかなり簡単にはまだある &lt;code&gt;&lt;a href=&quot;gen_fsm#Migration%20to%20gen_statem&quot;&gt;rewrite from&lt;/a&gt;&lt;/code&gt; &lt;code&gt;gen_fsm&lt;/code&gt; する &lt;code&gt;gen_statem&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7fd40cbe96a6a7878da940a8badb97c6c9caeb25" translate="yes" xml:space="preserve">
          <source>The callback module contains functions that implement the state machine. When an event occurs, the &lt;code&gt;gen_statem&lt;/code&gt; behaviour engine calls a function in the callback module with the event, current state and server data. This function performs the actions for this event, and returns the new state and server data and also actions to be performed by the behaviour engine.</source>
          <target state="translated">コールバックモジュールには、ステートマシンを実装する関数が含まれています。イベントが発生すると、 &lt;code&gt;gen_statem&lt;/code&gt; 動作エンジンは、イベント、現在の状態、およびサーバーデータを使用して、コールバックモジュールの関数を呼び出します。この関数は、このイベントのアクションを実行し、新しい状態とサーバーデータ、および動作エンジンによって実行されるアクションを返します。</target>
        </trans-unit>
        <trans-unit id="abbecd682f4918a42592a94b71742e36915e1bab" translate="yes" xml:space="preserve">
          <source>The callback module does not have to access real &lt;code&gt;Mnesia&lt;/code&gt; tables, it is free to do whatever it wants as long as the callback interface is fulfilled.</source>
          <target state="translated">コールバックモジュールは、実際の &lt;code&gt;Mnesia&lt;/code&gt; テーブルにアクセスする必要はありません。コールバックインターフェースが満たされている限り、自由に好きなことを実行できます。</target>
        </trans-unit>
        <trans-unit id="8eb2d562d838a71a4ba446f4da81f7701d757f5f" translate="yes" xml:space="preserve">
          <source>The callback module for a supervisor starting the server from &lt;code&gt;&lt;a href=&quot;gen_server_concepts#ex&quot;&gt;gen_server Behaviour&lt;/a&gt;&lt;/code&gt; can look as follows:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;gen_server_concepts#ex&quot;&gt;gen_server Behaviour&lt;/a&gt;&lt;/code&gt; からサーバーを起動するスーパーバイザのコールバックモジュールは、次のようになります。</target>
        </trans-unit>
        <trans-unit id="517a681e26aeb83ed7549fbd52cdab0059ff31b1" translate="yes" xml:space="preserve">
          <source>The callback module for the event handler writing error messages to a file can look as follows:</source>
          <target state="translated">エラーメッセージをファイルに書き込むイベントハンドラのコールバックモジュールは以下のようになります。</target>
        </trans-unit>
        <trans-unit id="c7722a0fd22c0aced7aea92994c66dc97a4d0fdd" translate="yes" xml:space="preserve">
          <source>The callback module for the event handler writing error messages to the terminal can look as follows:</source>
          <target state="translated">端末にエラーメッセージを書き込むイベントハンドラのコールバックモジュールは以下のようになります。</target>
        </trans-unit>
        <trans-unit id="344a5e28ddcbac85a390899bb7eafc0bb7e415bf" translate="yes" xml:space="preserve">
          <source>The callback module implementing the handler is responsible for checking the correctness of configuration strings.</source>
          <target state="translated">ハンドラを実装したコールバックモジュールは、設定文字列が正しいかどうかをチェックします。</target>
        </trans-unit>
        <trans-unit id="0b0838bae2efd3e8ec52bba36939ac5379dcb0f2" translate="yes" xml:space="preserve">
          <source>The callback module must implement the &lt;code&gt;tftp&lt;/code&gt; behavior, see &lt;code&gt;&lt;a href=&quot;#tftp_callback&quot;&gt;CALLBACK FUNCTIONS&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">コールバックモジュールは、 &lt;code&gt;tftp&lt;/code&gt; 動作を実装する必要があります。コールバック &lt;code&gt;&lt;a href=&quot;#tftp_callback&quot;&gt;CALLBACK FUNCTIONS&lt;/a&gt;&lt;/code&gt; 参照してください。</target>
        </trans-unit>
        <trans-unit id="7c16c7638772ec54a79c0e6462748feea41441fe" translate="yes" xml:space="preserve">
          <source>The callback module of the socket.</source>
          <target state="translated">ソケットのコールバックモジュール。</target>
        </trans-unit>
        <trans-unit id="8b2bd7c81f3fa7abf6044482ee91de57b2f57d61" translate="yes" xml:space="preserve">
          <source>The callback will be removed if the system reboots.</source>
          <target state="translated">システムが再起動した場合、コールバックは削除されます。</target>
        </trans-unit>
        <trans-unit id="55cc105f61cd981bcf32511925e36d658bc51fff" translate="yes" xml:space="preserve">
          <source>The called hook function is to return a (possibly deep) list of characters. Function &lt;code&gt;&lt;a href=&quot;#expr-4&quot;&gt;expr/4&lt;/a&gt;&lt;/code&gt; is useful in a hook.</source>
          <target state="translated">呼び出されたフック関数は、文字の（おそらく深い）リストを返すことです。関数 &lt;code&gt;&lt;a href=&quot;#expr-4&quot;&gt;expr/4&lt;/a&gt;&lt;/code&gt; はフックで役立ちます。</target>
        </trans-unit>
        <trans-unit id="dd19dd71cdd2bc7e1309239a2dc9ab10df17269d" translate="yes" xml:space="preserve">
          <source>The caller (of the discovery function) will make the needed updates later.</source>
          <target state="translated">(ディスカバリー関数の)呼び出し元は、後で必要な更新を行います。</target>
        </trans-unit>
        <trans-unit id="9ead89ef805808ff104ff5c388ca47931019854a" translate="yes" xml:space="preserve">
          <source>The caller can use own extraction and matching rules. This is done with the two options &lt;code&gt;fqdn_fun&lt;/code&gt; and &lt;code&gt;match_fun&lt;/code&gt;.</source>
          <target state="translated">呼び出し元は、独自の抽出およびマッチングルールを使用できます。これは、 &lt;code&gt;fqdn_fun&lt;/code&gt; と &lt;code&gt;match_fun&lt;/code&gt; の 2つのオプションで行われます。</target>
        </trans-unit>
        <trans-unit id="a7fc9c78e44578fd025d978ee708e79b0fa261e4" translate="yes" xml:space="preserve">
          <source>The caller is now displayed in the &quot;additional message&quot; part of the trace output, and the following is displayed after a while:</source>
          <target state="translated">トレース出力の「追加メッセージ」の部分に発信者が表示されるようになり、しばらくすると以下のように表示されるようになりました。</target>
        </trans-unit>
        <trans-unit id="c55c238696091394e0bd56b82b698a5c47bb3d12" translate="yes" xml:space="preserve">
          <source>The caller of &lt;code&gt;&lt;a href=&quot;#run-3&quot;&gt;run/3&lt;/a&gt;&lt;/code&gt; can set a limit on the number of times the internal match() function is called and on the maximum depth of recursive calls. These facilities are provided to catch runaway matches that are provoked by patterns with huge matching trees (a typical example is a pattern with nested unlimited repeats) and to avoid running out of system stack by too much recursion. When one of these limits is reached, &lt;code&gt;pcre_exec()&lt;/code&gt; gives an error return. The limits can also be set by items at the start of the pattern of the following forms:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#run-3&quot;&gt;run/3&lt;/a&gt;&lt;/code&gt; の呼び出し元は、内部のmatch（）関数が呼び出される回数と再帰呼び出しの最大深度に制限を設定できます。これらの機能は、巨大な一致ツリーのパターン（典型的な例はネストされた無制限の繰り返しのパターン）によって引き起こされる暴走マッチをキャッチし、あまりにも多くの再帰によってシステムスタックが不足するのを防ぐために提供されます。これらの制限の1つに達すると、 &lt;code&gt;pcre_exec()&lt;/code&gt; はエラーを返します。制限は、次のフォームのパターンの開始時にアイテムによって設定することもできます。</target>
        </trans-unit>
        <trans-unit id="f03c64f9f710de5955e68843c690db2e8c0fc8ca" translate="yes" xml:space="preserve">
          <source>The caller of &lt;code&gt;driver_create_port&lt;/code&gt; is allowed to manipulate the newly created port when &lt;code&gt;driver_create_port&lt;/code&gt; has returned. When &lt;code&gt;&lt;a href=&quot;#smp_support&quot;&gt;port level locking&lt;/a&gt;&lt;/code&gt; is used, the creating port is only allowed to manipulate the newly created port until the current driver callback, which was called by the emulator, returns.</source>
          <target state="translated">&lt;code&gt;driver_create_port&lt;/code&gt; が返された場合、 &lt;code&gt;driver_create_port&lt;/code&gt; の呼び出し元は、新しく作成されたポートを操作できます。場合 &lt;code&gt;&lt;a href=&quot;#smp_support&quot;&gt;port level locking&lt;/a&gt;&lt;/code&gt; 使用され、作成ポートのみエミュレータ、戻りによって呼び出された電流ドライバコールバックするまで、新しく作成されたポートを操作することができます。</target>
        </trans-unit>
        <trans-unit id="621fc2d91134d4db21b3517ae8ac3625fde2ce09" translate="yes" xml:space="preserve">
          <source>The caller of this function is a representative for &lt;code&gt;net_kernel&lt;/code&gt; (this may or may not be the process registered as &lt;code&gt;net_kernel&lt;/code&gt;) and is in this document identified as &lt;code&gt;Kernel&lt;/code&gt;.</source>
          <target state="translated">この関数の呼び出し元は &lt;code&gt;net_kernel&lt;/code&gt; の代表であり（これは &lt;code&gt;net_kernel&lt;/code&gt; として登録されたプロセスである場合とそうでない場合があります）、このドキュメントでは &lt;code&gt;Kernel&lt;/code&gt; として識別されています。</target>
        </trans-unit>
        <trans-unit id="80825902e9ea39352717e07e7e143bd52944e894" translate="yes" xml:space="preserve">
          <source>The caller of this function is a representative for &lt;code&gt;net_kernel&lt;/code&gt; (this may or may not be the process registered as &lt;code&gt;net_kernel&lt;/code&gt;) and is in this document identified as &lt;code&gt;Kernel&lt;/code&gt;. When a connection has been accepted by the acceptor process, it needs to inform &lt;code&gt;Kernel&lt;/code&gt; about the accepted connection. This is done by passing a message on the form:</source>
          <target state="translated">この関数の呼び出し元は &lt;code&gt;net_kernel&lt;/code&gt; の代表であり（これは &lt;code&gt;net_kernel&lt;/code&gt; として登録されたプロセスである場合とそうでない場合があります）、このドキュメントでは &lt;code&gt;Kernel&lt;/code&gt; として識別されています。アクセプタープロセスによって接続が受け入れられると、受け入れられた接続について &lt;code&gt;Kernel&lt;/code&gt; に通知する必要があります。これは、フォームにメッセージを渡すことによって行われます。</target>
        </trans-unit>
        <trans-unit id="17dc5e2470f7e3eb401d50cfc358de49382160b2" translate="yes" xml:space="preserve">
          <source>The calling NIF must use the return value of &lt;code&gt;enif_schedule_nif&lt;/code&gt; as its own return value.</source>
          <target state="translated">呼び出し側NIFは、 &lt;code&gt;enif_schedule_nif&lt;/code&gt; の戻り値を独自の戻り値として使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="b39ce61a3bf5f9ff14b9a7cd2356d7e2ed9376ab" translate="yes" xml:space="preserve">
          <source>The calling process is not suspended if the port is busy, instead the port command is aborted and &lt;code&gt;false&lt;/code&gt; is returned.</source>
          <target state="translated">ポートがビジーの場合、呼び出しプロセスは中断されず、代わりにポートコマンドが中止され、 &lt;code&gt;false&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="629c5b3b630ae0172907db307b7e38fd8b753106" translate="yes" xml:space="preserve">
          <source>The calling process is not suspended if the port is busy, instead the port command is forced through. The call fails with a &lt;code&gt;notsup&lt;/code&gt; exception if the driver of the port does not support this. For more information, see driver flag &lt;code&gt;&lt;a href=&quot;driver_entry#driver_flags&quot;&gt;![CDATA[ERL_DRV_FLAG_SOFT_BUSY]]&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">ポートがビジーの場合、呼び出しプロセスは中断されず、代わりにポートコマンドが強制的に実行されます。ポートのドライバーがこれをサポートしていない場合、呼び出しは &lt;code&gt;notsup&lt;/code&gt; 例外で失敗します。詳細については、ドライバーフラグ &lt;code&gt;&lt;a href=&quot;driver_entry#driver_flags&quot;&gt;![CDATA[ERL_DRV_FLAG_SOFT_BUSY]]&lt;/a&gt;&lt;/code&gt; 参照してください。</target>
        </trans-unit>
        <trans-unit id="7a1251fc069f821f07a282196dbe91995966e598" translate="yes" xml:space="preserve">
          <source>The calling process subscribes or unsubscribes to node status change messages. A &lt;code&gt;nodeup&lt;/code&gt; message is delivered to all subscribing processes when a new node is connected, and a &lt;code&gt;nodedown&lt;/code&gt; message is delivered when a node is disconnected.</source>
          <target state="translated">呼び出しプロセスは、ノードステータス変更メッセージをサブスクライブまたはサブスクライブ解除します。 &lt;code&gt;nodeup&lt;/code&gt; のメッセージは、新しいノードが接続されている場合、すべてのサブスクライブプロセスに配信され、そして &lt;code&gt;nodedown&lt;/code&gt; ノードが切断されたときにメッセージが配信されます。</target>
        </trans-unit>
        <trans-unit id="3fd0eba81e7afeb40af7403b8df7ac0d5fe56351" translate="yes" xml:space="preserve">
          <source>The capabilities advertised by a node must match its configured applications. In particular, &lt;code&gt;application&lt;/code&gt; configuration must be matched by corresponding &lt;code&gt;&lt;a href=&quot;#capability&quot;&gt;capability()&lt;/a&gt;&lt;/code&gt; configuration, of *-Application-Id AVPs in particular.</source>
          <target state="translated">ノードによってアドバタイズされる機能は、構成されたアプリケーションと一致する必要があります。特に、 &lt;code&gt;application&lt;/code&gt; 構成は、特に* -Application-Id AVPの対応する &lt;code&gt;&lt;a href=&quot;#capability&quot;&gt;capability()&lt;/a&gt;&lt;/code&gt; 構成と一致する必要があります。</target>
        </trans-unit>
        <trans-unit id="9f7b2ec0f22afdbc01fa422caed0e98c532f9b08" translate="yes" xml:space="preserve">
          <source>The capabilities advertised by a node must match its configured applications. In particular, setting &lt;code&gt;applications&lt;/code&gt; on a transport typically implies having to set matching *-Application-Id AVPs in a &lt;code&gt;&lt;a href=&quot;#capabilities&quot;&gt;capabilities()&lt;/a&gt;&lt;/code&gt; tuple.</source>
          <target state="translated">ノードによってアドバタイズされる機能は、構成されたアプリケーションと一致する必要があります。特に、トランスポートで &lt;code&gt;applications&lt;/code&gt; を設定するには、通常、 &lt;code&gt;&lt;a href=&quot;#capabilities&quot;&gt;capabilities()&lt;/a&gt;&lt;/code&gt; タプルに一致する* -Application-Id AVPを設定する必要があります。</target>
        </trans-unit>
        <trans-unit id="172ff57f871dcdd5d0b54942cc29dbee89bb8d9d" translate="yes" xml:space="preserve">
          <source>The capture tuple is built up as follows:</source>
          <target state="translated">キャプチャタプルは以下のように構築されます。</target>
        </trans-unit>
        <trans-unit id="734624d49a0e505e194d0a3e203f3707e0a9ce89" translate="yes" xml:space="preserve">
          <source>The case of a truncated UTF is handled specially, see the paragraph about incomplete binaries below.</source>
          <target state="translated">UTFが切り捨てられている場合は特別に扱われます。</target>
        </trans-unit>
        <trans-unit id="bf787b1c131df12f5b5608740bbea97ec8c5c67e" translate="yes" xml:space="preserve">
          <source>The cases are executed in a sequence as described in section &lt;code&gt;&lt;a href=&quot;dependencies_chapter#sequences&quot;&gt;Sequences&lt;/a&gt;&lt;/code&gt; in section Dependencies Between Test Cases and Suites.</source>
          <target state="translated">テストケースとスイート間の依存関係のセクションの &lt;code&gt;&lt;a href=&quot;dependencies_chapter#sequences&quot;&gt;Sequences&lt;/a&gt;&lt;/code&gt; で説明されているように、ケースはシーケンスで実行されます。</target>
        </trans-unit>
        <trans-unit id="a67cf4e28458acef6485593f3479b26ebbee2e4f" translate="yes" xml:space="preserve">
          <source>The cases in the group are executed in random order.</source>
          <target state="translated">グループ内のケースは、ランダムな順序で実行されます。</target>
        </trans-unit>
        <trans-unit id="79326758fa4216db5c43f358f0c9d48cf3066915" translate="yes" xml:space="preserve">
          <source>The center area of the main window contains the information tabs. Each tab displays information about a specific item or a list of items. Select a tab by clicking the tab title.</source>
          <target state="translated">メインウィンドウの中央領域には、情報タブがあります。各タブには、特定のアイテムまたはアイテムのリストに関する情報が表示されます。タブのタイトルをクリックしてタブを選択します。</target>
        </trans-unit>
        <trans-unit id="4592ee81cac18e24ff040ed72913569d66a68da6" translate="yes" xml:space="preserve">
          <source>The certificates attributes are valid.</source>
          <target state="translated">証明書の属性は有効です。</target>
        </trans-unit>
        <trans-unit id="a7eaa8135e803f2fb327a77633a52bb48c129b5b" translate="yes" xml:space="preserve">
          <source>The chain consisted only of one self-signed certificate.</source>
          <target state="translated">このチェーンは、自己署名された証明書1枚のみで構成されていた。</target>
        </trans-unit>
        <trans-unit id="0e0a9851e387d6b9bd8489d5d8385b78fdd1efbf" translate="yes" xml:space="preserve">
          <source>The change is permanent, as long as the log is not deleted. That means, the log size is remembered across reboots.</source>
          <target state="translated">この変更は、ログが削除されない限り、永続的に行われます。つまり、ログのサイズは再起動時にも記憶されます。</target>
        </trans-unit>
        <trans-unit id="209a620344bc5ac686ada38b14f368934eb2469b" translate="yes" xml:space="preserve">
          <source>The change will take effect after the next disk space check and is non-persist. That is, in case of a process restart, this value is forgotten and the default value will be used. See &lt;code&gt;&lt;a href=&quot;#config&quot;&gt;Configuration&lt;/a&gt;&lt;/code&gt; above.</source>
          <target state="translated">変更は次のディスク容量チェック後に有効になり、永続的ではありません。つまり、プロセスの再起動の場合、この値は忘れられ、デフォルト値が使用されます。上記の &lt;code&gt;&lt;a href=&quot;#config&quot;&gt;Configuration&lt;/a&gt;&lt;/code&gt; 参照してください。</target>
        </trans-unit>
        <trans-unit id="7324d42150f9730491b8b6dcf07acbe2a4287488" translate="yes" xml:space="preserve">
          <source>The change will take effect after the next memory check and is non-persistent. That is, in case of a process restart, this value is forgotten and the default value will be used. See &lt;code&gt;&lt;a href=&quot;#config&quot;&gt;Configuration&lt;/a&gt;&lt;/code&gt; above.</source>
          <target state="translated">変更は次のメモリチェック後に有効になり、永続的ではありません。つまり、プロセスの再起動の場合、この値は忘れられ、デフォルト値が使用されます。上記の &lt;code&gt;&lt;a href=&quot;#config&quot;&gt;Configuration&lt;/a&gt;&lt;/code&gt; 参照してください。</target>
        </trans-unit>
        <trans-unit id="8308604a253081056bdf717b82fcf33a719c92f1" translate="yes" xml:space="preserve">
          <source>The change will take effect during the next disk space check and is non-persist. That is, in case of a process restart, this value is forgotten and the default value will be used. See &lt;code&gt;&lt;a href=&quot;#config&quot;&gt;Configuration&lt;/a&gt;&lt;/code&gt; above.</source>
          <target state="translated">変更は次のディスク容量チェック中に有効になり、永続的ではありません。つまり、プロセスの再起動の場合、この値は忘れられ、デフォルト値が使用されます。上記の &lt;code&gt;&lt;a href=&quot;#config&quot;&gt;Configuration&lt;/a&gt;&lt;/code&gt; 参照してください。</target>
        </trans-unit>
        <trans-unit id="d9ee001de4f9c2acc5f959f9da7fbe9021fe19db" translate="yes" xml:space="preserve">
          <source>The change will take effect during the next periodic memory check and is non-persistent. That is, in case of a process restart, this value is forgotten and the default value will be used. See &lt;code&gt;&lt;a href=&quot;#config&quot;&gt;Configuration&lt;/a&gt;&lt;/code&gt; above.</source>
          <target state="translated">変更は、次の定期的なメモリチェック中に有効になり、永続的ではありません。つまり、プロセスの再起動の場合、この値は忘れられ、デフォルト値が使用されます。上記の &lt;code&gt;&lt;a href=&quot;#config&quot;&gt;Configuration&lt;/a&gt;&lt;/code&gt; 参照してください。</target>
        </trans-unit>
        <trans-unit id="48592559cdd27064407e93ea03790b5d39d21da9" translate="yes" xml:space="preserve">
          <source>The change will take effect for the next memory check and is non-persistent. That is, in the case of a process restart, this value is forgotten and the default value will be used. See &lt;code&gt;&lt;a href=&quot;#config&quot;&gt;Configuration&lt;/a&gt;&lt;/code&gt; above.</source>
          <target state="translated">変更は次のメモリチェックで有効になり、永続的ではありません。つまり、プロセスの再起動の場合、この値は忘れられ、デフォルト値が使用されます。上記の &lt;code&gt;&lt;a href=&quot;#config&quot;&gt;Configuration&lt;/a&gt;&lt;/code&gt; 参照してください。</target>
        </trans-unit>
        <trans-unit id="8a55eac8fba728a49ba83a1ba16426f587e19122" translate="yes" xml:space="preserve">
          <source>The changes do not affect existing child processes. For example, changing the start function only specifies how the child process is to be restarted, if needed later on.</source>
          <target state="translated">変更は既存の子プロセスには影響しません。例えば、開始関数を変更することで、後で必要になった場合に子プロセスをどのように再起動するかを指定するだけです。</target>
        </trans-unit>
        <trans-unit id="17ef826dd60e0b23be9ebb72e959e4616f5a6f10" translate="yes" xml:space="preserve">
          <source>The channel behavior sends a close message to the other side, if such a message has not already been sent. Then it terminates the channel with reason &lt;code&gt;normal&lt;/code&gt;.</source>
          <target state="translated">そのようなメッセージがまだ送信されていない場合、チャネルの動作により、反対側にクローズメッセージが送信されます。次に、理由 &lt;code&gt;normal&lt;/code&gt; でチャネルを終了します。</target>
        </trans-unit>
        <trans-unit id="2d0641d9544e5c0fe01329a75590e893fef99690" translate="yes" xml:space="preserve">
          <source>The chapter &lt;strong&gt;Advanced Agent Topics&lt;/strong&gt; describes the more advanced agent related features of the SNMP development tool. The following topics are covered:</source>
          <target state="translated">&lt;strong&gt;高度なエージェントのトピック&lt;/strong&gt;の章では、SNMP開発ツールのより高度なエージェント関連の機能について説明しています。次のトピックについて説明します。</target>
        </trans-unit>
        <trans-unit id="2e272ab9ddbed68131c16ba5014e291dc03d4f2d" translate="yes" xml:space="preserve">
          <source>The chapter &lt;strong&gt;Audit Trail Log&lt;/strong&gt; describes the audit trail logging.</source>
          <target state="translated">&lt;strong&gt;監査証跡ログ&lt;/strong&gt;の章では、監査証跡のロギングについて説明しています。</target>
        </trans-unit>
        <trans-unit id="3f08decf0e83874ab43a9d84e18e36f372618712" translate="yes" xml:space="preserve">
          <source>The chapter &lt;strong&gt;Running the application&lt;/strong&gt; describes how the application is configured and started. The topics include:</source>
          <target state="translated">「&lt;strong&gt;アプリケーションの実行」&lt;/strong&gt;の章では、アプリケーションの構成方法と起動方法について説明しています。トピックは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="72b08f124553e2dc5540039b611421ca2a1cb7f5" translate="yes" xml:space="preserve">
          <source>The chapter &lt;strong&gt;The MIB Compiler&lt;/strong&gt; describes the MIB compiler and contains the following topics:</source>
          <target state="translated">&lt;strong&gt;MIBコンパイラ&lt;/strong&gt;の章では&lt;strong&gt;、MIBコンパイラ&lt;/strong&gt;について説明します。内容は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="ddb91809478ddb72a376ffa2ae9889076265397b" translate="yes" xml:space="preserve">
          <source>The character &lt;code&gt;C&lt;/code&gt; determines the type of control sequence to be used. It is the only required field. All of &lt;code&gt;F&lt;/code&gt;, &lt;code&gt;P&lt;/code&gt;, &lt;code&gt;Pad&lt;/code&gt;, and &lt;code&gt;Mod&lt;/code&gt; are optional. For example, to use a &lt;code&gt;#&lt;/code&gt; for &lt;code&gt;Pad&lt;/code&gt; but use the default values for &lt;code&gt;F&lt;/code&gt; and &lt;code&gt;P&lt;/code&gt;, you can write &lt;code&gt;~..#C&lt;/code&gt;.</source>
          <target state="translated">文字 &lt;code&gt;C&lt;/code&gt; は、使用する制御シーケンスのタイプを決定します。これは唯一の必須フィールドです。すべての &lt;code&gt;F&lt;/code&gt; 、 &lt;code&gt;P&lt;/code&gt; 、 &lt;code&gt;Pad&lt;/code&gt; 、および &lt;code&gt;Mod&lt;/code&gt; オプションです。たとえば、 &lt;code&gt;#&lt;/code&gt; を &lt;code&gt;Pad&lt;/code&gt; 使用し、デフォルト値を &lt;code&gt;F&lt;/code&gt; および &lt;code&gt;P&lt;/code&gt; に使用するには、 &lt;code&gt;~..#C&lt;/code&gt; 記述できます。</target>
        </trans-unit>
        <trans-unit id="d64a4036522ec8f78050362f7b7c36c9cac056c3" translate="yes" xml:space="preserve">
          <source>The character encoding used in strings and atoms. The only supported encoding is &lt;code&gt;ERL_NIF_LATIN1&lt;/code&gt; for ISO Latin-1 (8-bit ASCII).</source>
          <target state="translated">文字列とアトムで使用される文字エンコーディング。サポートされるエンコーディングは、ISO Latin-1（8ビットASCII）の &lt;code&gt;ERL_NIF_LATIN1&lt;/code&gt; のみです。</target>
        </trans-unit>
        <trans-unit id="9d193b1def3415cd7c10a5af19c4d201098e3350" translate="yes" xml:space="preserve">
          <source>The character encodings used for atoms. &lt;code&gt;ERLANG_ASCII&lt;/code&gt; represents 7-bit ASCII. Latin-1 and UTF-8 are different extensions of 7-bit ASCII. All 7-bit ASCII characters are valid Latin-1 and UTF-8 characters. ASCII and Latin-1 both represent each character by one byte. An UTF-8 character can consist of 1-4 bytes. Notice that these constants are bit-flags and can be combined with bitwise OR.</source>
          <target state="translated">アトムに使用される文字エンコーディング。 &lt;code&gt;ERLANG_ASCII&lt;/code&gt; は7ビットASCIIを表します。Latin-1とUTF-8は、7ビットASCIIの異なる拡張です。すべての7ビットASCII文字は、有効なLatin-1およびUTF-8文字です。ASCIIとLatin-1はどちらも、各文字を1バイトで表します。UTF-8文字は1〜4バイトで構成できます。これらの定数はビットフラグであり、ビット単位のORと組み合わせることができることに注意してください。</target>
        </trans-unit>
        <trans-unit id="5bce2007ce7233de084f6c74cc17834bdadef1f7" translate="yes" xml:space="preserve">
          <source>The character escape sequences \d, \D, \h, \H, \p, \P, \s, \S, \v, \V, \w, and \W can appear in a character class, and add the characters that they match to the class. For example, [\dABCDEF] matches any hexadecimal digit. In UTF modes, option &lt;code&gt;ucp&lt;/code&gt; affects the meanings of \d, \s, \w and their uppercase partners, just as it does when they appear outside a character class, as described in section &lt;code&gt;&lt;a href=&quot;#generic_character_types&quot;&gt;Generic Character Types&lt;/a&gt;&lt;/code&gt; earlier. The escape sequence \b has a different meaning inside a character class; it matches the backspace character. The sequences \B, \N, \R, and \X are not special inside a character class. Like any other unrecognized escape sequences, they are treated as the literal characters &quot;B&quot;, &quot;N&quot;, &quot;R&quot;, and &quot;X&quot;.</source>
          <target state="translated">文字エスケープシーケンス\ d、\ D、\ h、\ H、\ p、\ P、\ s、\ S、\ v、\ V、\ w、および\ Wは、文字クラスに出現し、クラスに一致する文字。たとえば、[\ dABCDEF]は任意の16進数と一致します。前述の &lt;code&gt;&lt;a href=&quot;#generic_character_types&quot;&gt;Generic Character Types&lt;/a&gt;&lt;/code&gt; 説明したように、UTFモードでは、オプション &lt;code&gt;ucp&lt;/code&gt; は、\ d、\ s、\ wおよびそれらの大文字のパートナーの意味に影響します。エスケープシーケンス\ bは、文字クラス内では別の意味を持っています。バックスペース文字と一致します。シーケンス\ B、\ N、\ R、および\ Xは、文字クラス内では特別ではありません。他の認識されないエスケープシーケンスと同様に、それらはリテラル文字「B」、「N」、「R」、および「X」として扱われます。</target>
        </trans-unit>
        <trans-unit id="89f86657075f7d2532ecb276650adc58a9119d7f" translate="yes" xml:space="preserve">
          <source>The character used as time designator, that is, the date and time separator. The default is &lt;code&gt;$T&lt;/code&gt;.</source>
          <target state="translated">時間指定子として使用される文字、つまり日付と時刻の区切り記号。デフォルトは &lt;code&gt;$T&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="b7d9d6c64abc51b03bd1675467e660789635b1bd" translate="yes" xml:space="preserve">
          <source>The characters in the line terminated by a line feed (or end of file). If the I/O device supports Unicode, the data can represent codepoints &amp;gt; 255 (the &lt;code&gt;latin1&lt;/code&gt; range). If the I/O server is set to deliver binaries, they are encoded in UTF-8 (regardless of if the I/O device supports Unicode).</source>
          <target state="translated">改行（またはファイルの終わり）で終了する行の文字。I / OデバイスがUnicodeをサポートしている場合、データは255より大きいコードポイント（ &lt;code&gt;latin1&lt;/code&gt; 範囲）を表すことができます。I / Oサーバーがバイナリを配信するように設定されている場合、それらはUTF-8でエンコードされます（I / OデバイスがUnicodeをサポートしているかどうかは関係ありません）。</target>
        </trans-unit>
        <trans-unit id="56bc68334532732a987644276bf7e27ba2ed6340" translate="yes" xml:space="preserve">
          <source>The characters in the name (if specified as a list) can only be &amp;gt; 255 if the Erlang virtual machine is started in Unicode filename translation mode. Otherwise the name of the executable is limited to the ISO Latin-1 character set.</source>
          <target state="translated">名前の文字（リストとして指定されている場合）は、Erlang仮想マシンがUnicodeファイル名変換モードで起動されている場合にのみ255を超えることができます。それ以外の場合、実行可能ファイルの名前はISO Latin-1文字セットに制限されます。</target>
        </trans-unit>
        <trans-unit id="4c340bb094927d6516a270b8c7260c59f1b0e9ac" translate="yes" xml:space="preserve">
          <source>The check for calls to undefined functions is an example of a predefined analysis, probably the most useful one. Other examples are the analyses that find unused local functions, or functions that call some given functions. See the &lt;code&gt;&lt;a href=&quot;xref#analyze&quot;&gt;analyze/2,3&lt;/a&gt;&lt;/code&gt; functions for a complete list of predefined analyses.</source>
          <target state="translated">未定義の関数の呼び出しのチェックは、定義済みの分析の例であり、おそらく最も有用なものです。他の例としては、未使用のローカル関数、または特定の関数を呼び出す関数を見つける分析があります。事前定義された分析の完全なリストについては、 &lt;code&gt;&lt;a href=&quot;xref#analyze&quot;&gt;analyze/2,3&lt;/a&gt;&lt;/code&gt; 関数を参照してください。</target>
        </trans-unit>
        <trans-unit id="b5e1916c5d50a9c907628d5b592b7e3e35726d5e" translate="yes" xml:space="preserve">
          <source>The checkpoint is automatically deactivated when some of the tables involved have no retainer attached to them. This can occur when nodes go down or when a replica is deleted. Checkpoints are also deactivated with this function. &lt;code&gt;Name&lt;/code&gt; is the name of an active checkpoint.</source>
          <target state="translated">関連する一部のテーブルにリテーナがアタッチされていない場合、チェックポイントは自動的に無効になります。これは、ノードがダウンしたとき、またはレプリカが削除されたときに発生する可能性があります。この機能では、チェックポイントも無効になります。 &lt;code&gt;Name&lt;/code&gt; は、アクティブなチェックポイントの名前です。</target>
        </trans-unit>
        <trans-unit id="d9393d9861ac13bac497a84046277f971838af74" translate="yes" xml:space="preserve">
          <source>The checks performed before the boot script is generated can be extended with some cross reference checks by specifying option &lt;code&gt;exref&lt;/code&gt;. These checks are performed with the Xref tool. All applications, or the applications specified with &lt;code&gt;{exref,[App]}&lt;/code&gt;, are checked by Xref and warnings are issued for calls to undefined functions.</source>
          <target state="translated">ブートスクリプトが生成される前に実行されるチェックは、オプション &lt;code&gt;exref&lt;/code&gt; を指定することにより、いくつかの相互参照チェックで拡張できます。これらのチェックは、外部参照ツールを使用して実行されます。すべてのアプリケーション、または &lt;code&gt;{exref,[App]}&lt;/code&gt; で指定されたアプリケーションは、Xrefによってチェックされ、未定義の関数の呼び出しに対して警告が発行されます。</target>
        </trans-unit>
        <trans-unit id="b71574456dfb07437b35ad062527dd44aa7aea5a" translate="yes" xml:space="preserve">
          <source>The child specification for a stopped child process is deleted with the following call:</source>
          <target state="translated">停止している子プロセスの子指定は、以下の呼び出しで削除されます。</target>
        </trans-unit>
        <trans-unit id="67c92024750696ea3d3e50b512e7251afc6c23fc" translate="yes" xml:space="preserve">
          <source>The children of a supervisor are defined as a list of &lt;strong&gt;child specifications&lt;/strong&gt;. When the supervisor is started, the child processes are started in order from left to right according to this list. When the supervisor terminates, it first terminates its child processes in reversed start order, from right to left.</source>
          <target state="translated">スーパーバイザの子は、&lt;strong&gt;子仕様の&lt;/strong&gt;リストとして定義されます。スーパーバイザを起動すると、このリストに従って左から右に子プロセスが起動します。スーパーバイザが終了すると、最初に子プロセスを右から左に逆の開始順序で終了します。</target>
        </trans-unit>
        <trans-unit id="814de93894ad7aadf116db8d46dcb0a1a2f6a6fc" translate="yes" xml:space="preserve">
          <source>The choice of configuration alters the location and load order of the tables. The alternatives are as follows:</source>
          <target state="translated">構成の選択により、テーブルの位置とロード順序が変更されます。選択肢は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="92e209681f18120979ec8cf62515a80ebbdd5369" translate="yes" xml:space="preserve">
          <source>The chunk size used by the Erlang fallback to send data. If using the fallback, set this to a value that comfortably fits in the systems memory. Default is 20 MB.</source>
          <target state="translated">Erlangのフォールバックがデータを送るときに使うチャンクサイズ。フォールバックを使う場合は、システムメモリに収まる値に設定してください。デフォルトは20MBです。</target>
        </trans-unit>
        <trans-unit id="b290d8f7cbf9ebc957458f968fe0fad53d55bb94" translate="yes" xml:space="preserve">
          <source>The circumflex and dollar metacharacters are zero-width assertions. That is, they test for a particular condition to be true without consuming any characters from the subject string.</source>
          <target state="translated">円周率メタキャラクタとドルメタキャラクタは、ゼロ幅のアサーションです。つまり、これらの文字列は、対象となる文字列の文字を消費することなく、特定の条件が真であるかどうかをテストします。</target>
        </trans-unit>
        <trans-unit id="5669e2ea35917008527e37b5ca4d88fc5112fe65" translate="yes" xml:space="preserve">
          <source>The classic edit-compile-bugfix cycle for Erlang is to edit the source file in an editor, save it to a file and switch to an Erlang shell. In the shell the compilation command is given. Should the compilation fail you have to bring out the editor and locate the correct line.</source>
          <target state="translated">Erlangの古典的なedit-compile-bugfixサイクルは、エディタでソースファイルを編集し、ファイルに保存してからErlangシェルに切り替えるというものです。シェルではコンパイルコマンドが与えられます。もしコンパイルに失敗したら、エディタを起動して正しい行を見つけなければなりません。</target>
        </trans-unit>
        <trans-unit id="b037a6b9c798a6a67eb72fefb14eec4bbb6f1f1d" translate="yes" xml:space="preserve">
          <source>The client automatically retrieves the information from the new URI and returns that as the result, instead of a 30X-result code.</source>
          <target state="translated">クライアントは自動的に新しいURIから情報を取得し、30Xの結果コードの代わりにそれを結果として返します。</target>
        </trans-unit>
        <trans-unit id="1fbe84685ac1a559531b7c36291fb36841fab94a" translate="yes" xml:space="preserve">
          <source>The client can be stopped using &lt;code&gt;inets:stop(httpc, Pid)&lt;/code&gt; or &lt;code&gt;inets:stop(httpc, Profile)&lt;/code&gt;.</source>
          <target state="translated">クライアントは、 &lt;code&gt;inets:stop(httpc, Pid)&lt;/code&gt; または &lt;code&gt;inets:stop(httpc, Profile)&lt;/code&gt; を使用して停止できます。</target>
        </trans-unit>
        <trans-unit id="569ccd940c4f6a817b12bba1b1067ae1a9656ffb" translate="yes" xml:space="preserve">
          <source>The client can choose to accept some path evaluation errors, for example, a web browser can ask the user whether to accept an unknown CA root certificate. The server, if it requests a certificate, does however not accept any path validation errors. It is configurable if the server is to accept or reject an &quot;empty&quot; certificate as response to a certificate request.</source>
          <target state="translated">クライアントはいくつかのパス評価エラーを受け入れるかどうかを選択することができます。例えば、Web ブラウザはユーザに未知の CA ルート証明書を受け入れるかどうかを尋ねることができます。サーバは、証明書を要求した場合、パスの検証エラーは受け付けません。サーバが証明書要求に対する応答として「空の」証明書を受け入れるか否かを設定できます。</target>
        </trans-unit>
        <trans-unit id="c1b412fb6f7f703ee2ef8dff66ba99951cf7089b" translate="yes" xml:space="preserve">
          <source>The client is any Erlang process wishing to read or write data from/to the I/O device.</source>
          <target state="translated">クライアントはI/Oデバイスからデータを読み書きしたいErlangプロセスです。</target>
        </trans-unit>
        <trans-unit id="c1f2e8007b5292b585147076187f8ae466cd3c94" translate="yes" xml:space="preserve">
          <source>The client processes has done some illegal operation.</source>
          <target state="translated">クライアントプロセスが不正な操作を行った。</target>
        </trans-unit>
        <trans-unit id="9a26517024410b148cd294e33b877a64e550bcc2" translate="yes" xml:space="preserve">
          <source>The client remote username (&lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc931.txt&quot;&gt;RFC 931&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">クライアントのリモートユーザー名（ &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc931.txt&quot;&gt;RFC 931&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="41327174b5c9bc729859a7f6bf3b5c175db7b9d0" translate="yes" xml:space="preserve">
          <source>The client sends an &lt;code&gt;io_request&lt;/code&gt; tuple to the I/O server and the server eventually sends a corresponding &lt;code&gt;io_reply&lt;/code&gt; tuple.</source>
          <target state="translated">クライアントは &lt;code&gt;io_request&lt;/code&gt; タプルをI / Oサーバーに送信し、サーバーは最終的に対応する &lt;code&gt;io_reply&lt;/code&gt; タプルを送信します。</target>
        </trans-unit>
        <trans-unit id="0f8f061d93662344f07374622d9a9f5570dc6915" translate="yes" xml:space="preserve">
          <source>The client sends the message to the server by:</source>
          <target state="translated">でクライアントがサーバーに送信します。</target>
        </trans-unit>
        <trans-unit id="072bdecf1b9485830f32e0b9aaa2f2cd201b4643" translate="yes" xml:space="preserve">
          <source>The client supports IPv6 as long as the underlying mechanisms also do so.</source>
          <target state="translated">クライアントは、基礎となるメカニズムもそうである限り、IPv6をサポートしています。</target>
        </trans-unit>
        <trans-unit id="5795d28810329b4419d272a646663a21aa527543" translate="yes" xml:space="preserve">
          <source>The client-server model is characterized by a central server and an arbitrary number of clients. The client-server model is used for resource management operations, where several different clients want to share a common resource. The server is responsible for managing this resource.</source>
          <target state="translated">クライアント・サーバ・モデルは、中央サーバと任意の数のクライアントによって特徴づけられます。クライアント-サーバモデルは、複数の異なるクライアントが共通のリソースを共有したい場合のリソース管理操作に使用されます。サーバはこのリソースを管理する責任があります。</target>
        </trans-unit>
        <trans-unit id="b8d268ee82b336a5c95688dda8482335e48cf69d" translate="yes" xml:space="preserve">
          <source>The clients ip address.</source>
          <target state="translated">クライアントのIPアドレス。</target>
        </trans-unit>
        <trans-unit id="a98219544eb3eff51a663b1a744e3bf13062abc6" translate="yes" xml:space="preserve">
          <source>The clock starts ticking when the request is sent.</source>
          <target state="translated">リクエストが送信されると時計が刻み始めます。</target>
        </trans-unit>
        <trans-unit id="be435ecc0cf1fa1a9c98c5cd0695f7dfa36eec57" translate="yes" xml:space="preserve">
          <source>The clone of the SSL application must enable the use of the SSL code in such an early bootstage as needed to set up the distribution. However, this makes it impossible to soft upgrade the SSL application.</source>
          <target state="translated">SSLアプリケーションのクローンは、配布物をセットアップするために必要なような初期のブートステージでSSLコードの使用を可能にしなければなりません。しかし、これはSSLアプリケーションをソフトアップグレードすることを不可能にします。</target>
        </trans-unit>
        <trans-unit id="d756129312a76f266001381d64eeed8865f4919a" translate="yes" xml:space="preserve">
          <source>The code for a module can exist in two variants in a system: &lt;strong&gt;current code&lt;/strong&gt; and &lt;strong&gt;old code&lt;/strong&gt;. When a module is loaded into the system for the first time, the module code becomes 'current' and the global &lt;strong&gt;export table&lt;/strong&gt; is updated with references to all functions exported from the module.</source>
          <target state="translated">モジュールのコードは、システムの2つのバリアント（&lt;strong&gt;現在のコード&lt;/strong&gt;と&lt;strong&gt;古いコード）で&lt;/strong&gt;存在でき&lt;strong&gt;ます&lt;/strong&gt;。モジュールが初めてシステムにロードされると、モジュールコードは「現在」になり、グローバル&lt;strong&gt;エクスポートテーブル&lt;/strong&gt;はモジュールからエクスポートされたすべての関数への参照で更新されます。</target>
        </trans-unit>
        <trans-unit id="e2397fc7367abe891aaddea1acfb84a0e33bbb71" translate="yes" xml:space="preserve">
          <source>The code for the server can be rewritten into a generic part &lt;code&gt;server.erl&lt;/code&gt;:</source>
          <target state="translated">サーバーのコードは、一般的な部分 &lt;code&gt;server.erl&lt;/code&gt; に書き直すことができます。</target>
        </trans-unit>
        <trans-unit id="8e4cf743be10d1f78796a8520fbbc62b88613fb4" translate="yes" xml:space="preserve">
          <source>The code in &lt;code&gt;error_handler&lt;/code&gt; is complex. Do not change it without fully understanding the interaction between the error handler, the &lt;code&gt;init&lt;/code&gt; process of the code server, and the I/O mechanism of the code.</source>
          <target state="translated">&lt;code&gt;error_handler&lt;/code&gt; のコードは複雑です。エラーハンドラー、コードサーバーの &lt;code&gt;init&lt;/code&gt; プロセス、およびコードのI / Oメカニズム間の相互作用を完全に理解していない場合は、変更しないでください。</target>
        </trans-unit>
        <trans-unit id="90cb7656e2a78a30cae10868a6acccf8aa88d091" translate="yes" xml:space="preserve">
          <source>The code in &lt;code&gt;server&lt;/code&gt; can be reused to build many different servers.</source>
          <target state="translated">&lt;code&gt;server&lt;/code&gt; のコードを再利用して、さまざまなサーバーを構築できます。</target>
        </trans-unit>
        <trans-unit id="04225ffb5d1e2cd3c54d5a022ccc010d6c271db5" translate="yes" xml:space="preserve">
          <source>The code is available in &lt;code&gt;pg_sync.c&lt;/code&gt; in the &lt;code&gt;sample&lt;/code&gt; directory of &lt;code&gt;erts&lt;/code&gt;.</source>
          <target state="translated">コードは &lt;code&gt;pg_sync.c&lt;/code&gt; の &lt;code&gt;sample&lt;/code&gt; ディレクトリの &lt;code&gt;erts&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="c9264957f8945993653ce298e5c1234e15d08f23" translate="yes" xml:space="preserve">
          <source>The code is explained in the next sections.</source>
          <target state="translated">コードについては、次項で説明します。</target>
        </trans-unit>
        <trans-unit id="0e3333c77c7ae219d3009900b602e3b49e21c916" translate="yes" xml:space="preserve">
          <source>The code is straightforward: all communication between Erlang and the driver is done with &lt;code&gt;port_control/3&lt;/code&gt;, and the driver returns data back using the &lt;code&gt;rbuf&lt;/code&gt;.</source>
          <target state="translated">コードは簡単である：アーランとドライバとの間のすべての通信を用いて行われる &lt;code&gt;port_control/3&lt;/code&gt; 、及びドライバ戻りデータが使用してバック &lt;code&gt;rbuf&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f043529a1b5d337526e7bf30093ae19b9989356b" translate="yes" xml:space="preserve">
          <source>The code must return:</source>
          <target state="translated">コードを返さなければなりません。</target>
        </trans-unit>
        <trans-unit id="507745f725c946f3bb38fa59ee9580fa6d304cd3" translate="yes" xml:space="preserve">
          <source>The code of a module can exist in two variants in a system: &lt;strong&gt;current&lt;/strong&gt; and &lt;strong&gt;old&lt;/strong&gt;. When a module is loaded into the system for the first time, the code becomes 'current'. If then a new instance of the module is loaded, the code of the previous instance becomes 'old' and the new instance becomes 'current'.</source>
          <target state="translated">モジュールのコードは、システムの2つのバリアント（&lt;strong&gt;current&lt;/strong&gt;と&lt;strong&gt;old）&lt;/strong&gt;で存在できます。モジュールがシステムに初めてロードされると、コードは「最新」になります。その後、モジュールの新しいインスタンスが読み込まれると、前のインスタンスのコードは「古い」ものになり、新しいインスタンスは「現在の」ものになります。</target>
        </trans-unit>
        <trans-unit id="922b2eb4a931c1204aa3e51a063d0b9c833303d1" translate="yes" xml:space="preserve">
          <source>The code path can be extended by using the command-line flags &lt;code&gt;-pa Directories&lt;/code&gt; and &lt;code&gt;-pz Directories&lt;/code&gt;. These add &lt;code&gt;Directories&lt;/code&gt; to the head or the end of the code path, respectively. Example:</source>
          <target state="translated">コードパスは、コマンドラインフラグ &lt;code&gt;-pa Directories&lt;/code&gt; および &lt;code&gt;-pz Directories&lt;/code&gt; を使用して拡張できます。これらは、コードパスの先頭または末尾にそれぞれ &lt;code&gt;Directories&lt;/code&gt; を追加します。例：</target>
        </trans-unit>
        <trans-unit id="e7f2de033652fb4852b04d98599da41645cd5418" translate="yes" xml:space="preserve">
          <source>The code server loads code according to a code loading strategy, which is either &lt;strong&gt;interactive&lt;/strong&gt; (default) or &lt;strong&gt;embedded&lt;/strong&gt;. In interactive mode, code is searched for in a &lt;strong&gt;code path&lt;/strong&gt; and loaded when first referenced. In embedded mode, code is loaded at start-up according to a &lt;strong&gt;boot script&lt;/strong&gt;. This is described in &lt;code&gt;System Principles&lt;/code&gt;.</source>
          <target state="translated">コードサーバーは、&lt;strong&gt;インタラクティブ&lt;/strong&gt;（デフォルト）または&lt;strong&gt;埋め込みの&lt;/strong&gt;いずれかのコードロード戦略に従ってコードをロードします。インタラクティブモードでは、コードは&lt;strong&gt;コードパス&lt;/strong&gt;で検索され、最初に参照されたときに読み込まれます。組み込みモードでは、&lt;strong&gt;起動スクリプト&lt;/strong&gt;に従って起動時にコードが読み込まれ&lt;strong&gt;ます&lt;/strong&gt;。これについては、 &lt;code&gt;System Principles&lt;/code&gt; 説明しています。</target>
        </trans-unit>
        <trans-unit id="8c79fc2d0738d58b971f65c1fecd5a663cbf7ff9" translate="yes" xml:space="preserve">
          <source>The code server module &lt;code&gt;code&lt;/code&gt; contains a number of functions for modifying and checking the search path, see the &lt;code&gt;code(3)&lt;/code&gt; manual page in Kernel.</source>
          <target state="translated">コードサーバーモジュールの &lt;code&gt;code&lt;/code&gt; は、検索パスを変更および確認するための多数の関数が含まれています。カーネルの &lt;code&gt;code(3)&lt;/code&gt; マニュアルページを参照してください。</target>
        </trans-unit>
        <trans-unit id="33c6dc6ea8623b6f6923c8e2b31c4332f8ba122e" translate="yes" xml:space="preserve">
          <source>The code server uses &lt;code&gt;code:lib_dir(kernel)&lt;/code&gt; to find the directory of the current (latest) version of Kernel, and then the subdirectory &lt;code&gt;include&lt;/code&gt; is searched for the file &lt;code&gt;file.hrl&lt;/code&gt;.</source>
          <target state="translated">コードサーバーは &lt;code&gt;code:lib_dir(kernel)&lt;/code&gt; を使用して、カーネルの現在の（最新）バージョンのディレクトリを検索し、サブディレクトリ &lt;code&gt;include&lt;/code&gt; で &lt;code&gt;file.hrl&lt;/code&gt; ファイルを検索します。</target>
        </trans-unit>
        <trans-unit id="705518a26a45215c147f7cfa28bbb3c76f850d6e" translate="yes" xml:space="preserve">
          <source>The code server uses module &lt;code&gt;erl_prim_loader&lt;/code&gt; in ERTS (possibly through &lt;code&gt;erl_boot_server&lt;/code&gt;) to read code files from archives. However, the functions in &lt;code&gt;erl_prim_loader&lt;/code&gt; can also be used by other applications to read files from archives. For example, the call &lt;code&gt;erl_prim_loader:list_dir( &quot;/otp/root/lib/mnesia-4.4.7.ez/mnesia-4.4.7/examples/bench)&quot;&lt;/code&gt; would list the contents of a directory inside an archive. See &lt;code&gt;erl_prim_loader(3)&lt;/code&gt;.</source>
          <target state="translated">コードサーバーは、ERTSのモジュール &lt;code&gt;erl_prim_loader&lt;/code&gt; （おそらく &lt;code&gt;erl_boot_server&lt;/code&gt; を介して）を使用して、アーカイブからコードファイルを読み取ります。ただし、 &lt;code&gt;erl_prim_loader&lt;/code&gt; の関数は、アーカイブからファイルを読み取るために他のアプリケーションでも使用できます。たとえば、 &lt;code&gt;erl_prim_loader:list_dir( &quot;/otp/root/lib/mnesia-4.4.7.ez/mnesia-4.4.7/examples/bench)&quot;&lt;/code&gt; を呼び出すと、アーカイブ内のディレクトリの内容がリストされます。 &lt;code&gt;erl_prim_loader(3)&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="b81d555b71a144677a82f4345434092ac25f42ef" translate="yes" xml:space="preserve">
          <source>The code that creates a process that runs this tracer function and sets that process as the system tracer can look like this:</source>
          <target state="translated">このトレーサ関数を実行するプロセスを作成し、そのプロセスをシステムトレーサとして設定するコードは次のようになります。</target>
        </trans-unit>
        <trans-unit id="01443bf8a10ddd3106bef27d3577d522575836f5" translate="yes" xml:space="preserve">
          <source>The code that executes inside the activity can consist of a series of table manipulation functions, which are performed in an &lt;code&gt;AccessContext&lt;/code&gt;. Currently, the following access contexts are supported:</source>
          <target state="translated">アクティビティ内で実行されるコードは、 &lt;code&gt;AccessContext&lt;/code&gt; で実行される一連のテーブル操作関数で構成できます。現在、次のアクセスコンテキストがサポートされています。</target>
        </trans-unit>
        <trans-unit id="84b1eccbd4506c4d8f052231d9e0606cf91a8b80" translate="yes" xml:space="preserve">
          <source>The code that executes inside the transaction can consist of a series of table manipulation functions. If something goes wrong inside the transaction as a result of a user error or a certain table not being available, the entire transaction is terminated and the function &lt;code&gt;transaction/1&lt;/code&gt; returns the tuple &lt;code&gt;{aborted, Reason}&lt;/code&gt;.</source>
          <target state="translated">トランザクション内で実行されるコードは、一連のテーブル操作関数で構成できます。ユーザーエラーまたは特定のテーブルが利用できないためにトランザクション内で問題が発生した場合、トランザクション全体が終了し、関数 &lt;code&gt;transaction/1&lt;/code&gt; はタプル &lt;code&gt;{aborted, Reason}&lt;/code&gt; 返します。</target>
        </trans-unit>
        <trans-unit id="a0cdd80f24fdd34e8443becb251df980268f8ee4" translate="yes" xml:space="preserve">
          <source>The code uses the &lt;code&gt;OTP_RELEASE&lt;/code&gt; macro to conditionally select code depending on release.</source>
          <target state="translated">コードは &lt;code&gt;OTP_RELEASE&lt;/code&gt; マクロを使用して、リリースに応じて条件付きでコードを選択します。</target>
        </trans-unit>
        <trans-unit id="0b9b7b5c18b986e4dcb6724716523fe3e0859402" translate="yes" xml:space="preserve">
          <source>The codec name is the name of the codec with which all messages in the &lt;code&gt;message_list()&lt;/code&gt; has been encoded.</source>
          <target state="translated">コーデック名は、 &lt;code&gt;message_list()&lt;/code&gt; 内のすべてのメッセージがエンコードされたコーデックの名前です。</target>
        </trans-unit>
        <trans-unit id="95a66f00b0729fc83f03c227254f16b97fe36011" translate="yes" xml:space="preserve">
          <source>The codes are named as &lt;code&gt;SSH_FX_*&lt;/code&gt; which are transformed into lowercase of the star-part. E.g. the error code &lt;code&gt;SSH_FX_NO_SUCH_FILE&lt;/code&gt; will cause the &lt;code&gt;reason()&lt;/code&gt; to be &lt;code&gt;no_such_file&lt;/code&gt;.</source>
          <target state="translated">コードの名前は &lt;code&gt;SSH_FX_*&lt;/code&gt; で、星型部分の小文字に変換されます。たとえば、エラーコード &lt;code&gt;SSH_FX_NO_SUCH_FILE&lt;/code&gt; を使用すると、 &lt;code&gt;reason()&lt;/code&gt; が &lt;code&gt;no_such_file&lt;/code&gt; になります。</target>
        </trans-unit>
        <trans-unit id="17206be2c27dcf13c38e698754daddf2e853496a" translate="yes" xml:space="preserve">
          <source>The collector collects trace events and keeps them ordered by their timestamp. The timestamp may either reflect the time when the actual trace data was generated (trace_ts) or when the trace data was transformed into an event record (event_ts). If the time stamp is missing in the trace data (missing timestamp option to erlang:trace/4) the trace_ts will be set to the event_ts.</source>
          <target state="translated">コレクターはトレースイベントを収集し、それらをタイムスタンプで順番に保持します。タイムスタンプは実際のトレースデータが生成された時刻(trace_ts)か、トレースデータがイベントレコードに変換された時刻(event_ts)を反映しています。もしトレースデータにタイムスタンプがない場合(erlang:trace/4のmissing timestampオプション)、trace_tsはevent_tsに設定されます。</target>
        </trans-unit>
        <trans-unit id="351503ceae71d258dda945d06961ceabf3006742" translate="yes" xml:space="preserve">
          <source>The collector has a built-in dictionary service. Any term may be stored as value in the dictionary and bound to a unique key. When new values are inserted with an existing key, the new values will overwrite the existing ones. Processes may subscribe on dictionary updates by using {subscriber, pid()} as dictionary key. All dictionary updates will be propagated to the subscriber processes matching the pattern {{subscriber, '_'}, '_'} where the first '_' is interpreted as a pid().</source>
          <target state="translated">コレクターには組み込みの辞書サービスがあります。任意の用語を辞書に値として格納し、一意のキーにバインドすることができます。既存のキーに新しい値が挿入されると、新しい値は既存の値を上書きします。プロセスは、{subscriber,pid()}を辞書キーとして使用することで、辞書の更新をサブスクライブすることができます。すべての辞書更新は、パターン{{{subscriber,'_'},'_'},'_'}にマッチするサブスクライバプロセスに伝搬されます。</target>
        </trans-unit>
        <trans-unit id="aa24630865ec2d27852697992e86dceb8f652e0b" translate="yes" xml:space="preserve">
          <source>The column where the token begins.</source>
          <target state="translated">トークンが始まる列。</target>
        </trans-unit>
        <trans-unit id="630fd19e25bb44d0c633fc41e9f2c893976f1cf6" translate="yes" xml:space="preserve">
          <source>The columns are: CNT - the number of times the function has been called, ACC - the time spent in the function including called functions, and OWN - the time spent in the function not including called functions.</source>
          <target state="translated">列は以下の通りです。CNT-関数が呼び出された回数、ACC-呼び出された関数を含む関数内で費やした時間、OWN-呼び出された関数を含まない関数内で費やした時間です。</target>
        </trans-unit>
        <trans-unit id="dba186e396734b41173da2352f4bdf8aa2299d12" translate="yes" xml:space="preserve">
          <source>The combined size of message buffers associated with the process.</source>
          <target state="translated">プロセスに関連付けられたメッセージバッファの合計サイズ。</target>
        </trans-unit>
        <trans-unit id="cd9eaf4fbf041c4980649b3adc6f08d99e41387b" translate="yes" xml:space="preserve">
          <source>The command for starting the emulator. Defaults to &lt;code&gt;erl&lt;/code&gt; in the same directory as the &lt;code&gt;erlc&lt;/code&gt; program itself, or, if it does not exist, &lt;code&gt;erl&lt;/code&gt; in any of the directories specified in environment variable &lt;code&gt;PATH&lt;/code&gt;.</source>
          <target state="translated">エミュレータを起動するためのコマンド。デフォルトでは、 &lt;code&gt;erlc&lt;/code&gt; プログラム自体と同じディレクトリー内の &lt;code&gt;erl&lt;/code&gt; 、または存在しない場合は、環境変数 &lt;code&gt;PATH&lt;/code&gt; で指定されたディレクトリーのいずれかで &lt;code&gt;erl&lt;/code&gt; になります。</target>
        </trans-unit>
        <trans-unit id="bb6501b3dc9f9f189fcbf95012d0127834e2f9cf" translate="yes" xml:space="preserve">
          <source>The command routine takes three parameters; the handle returned for the port by &lt;code&gt;uds_start&lt;/code&gt;, which is a pointer to the internal port structure, the data buffer, and the length of the data buffer. The buffer is the data sent from Erlang (a list of bytes) converted to an C array (of bytes).</source>
          <target state="translated">コマンドルーチンは3つのパラメータを取ります。 &lt;code&gt;uds_start&lt;/code&gt; によってポートに返されるハンドル。これは、内部ポート構造、データバッファー、およびデータバッファーの長さへのポインターです。バッファは、Erlang（バイトのリスト）から送信されたデータを、C配列（バイト）に変換したものです。</target>
        </trans-unit>
        <trans-unit id="aefc7b65db056c9f7f1b6802b3b0d8045a51356b" translate="yes" xml:space="preserve">
          <source>The command-line argument for specifying the SSL/TLS options is named &lt;code&gt;-ssl_dist_opt&lt;/code&gt; and is to be followed by pairs of SSL options and their values. Argument &lt;code&gt;-ssl_dist_opt&lt;/code&gt; can be repeated any number of times.</source>
          <target state="translated">SSL / TLSオプションを指定するためのコマンドライン引数は &lt;code&gt;-ssl_dist_opt&lt;/code&gt; という名前で、その後にSSLオプションとその値のペアが続きます。引数 &lt;code&gt;-ssl_dist_opt&lt;/code&gt; は何度でも繰り返すことができます。</target>
        </trans-unit>
        <trans-unit id="ef15ee0f0b965418b78c604ce208be1ebb9ac987" translate="yes" xml:space="preserve">
          <source>The command-line flag &lt;code&gt;-init_debug&lt;/code&gt; makes the &lt;code&gt;init&lt;/code&gt; process write some debug information while interpreting the boot script:</source>
          <target state="translated">コマンドラインフラグ &lt;code&gt;-init_debug&lt;/code&gt; は、ブートスクリプトの解釈中に &lt;code&gt;init&lt;/code&gt; プロセスにデバッグ情報を書き込みます。</target>
        </trans-unit>
        <trans-unit id="06c50b8e09545158899f6b79057dc3ebb405cca8" translate="yes" xml:space="preserve">
          <source>The comment for &lt;code&gt;driver_output_binary&lt;/code&gt; also applies for &lt;code&gt;driver_outputv&lt;/code&gt;.</source>
          <target state="translated">コメント &lt;code&gt;driver_output_binary&lt;/code&gt; はまたのために適用され &lt;code&gt;driver_outputv&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1280084aa272a9d5d8e48fb9a3f8a4bc2a35a205" translate="yes" xml:space="preserve">
          <source>The comment for the file in the zip archive</source>
          <target state="translated">zipアーカイブ内のファイルのコメント</target>
        </trans-unit>
        <trans-unit id="576cdebf96e8a6e4c9f5687b31e5fae369f7ae54" translate="yes" xml:space="preserve">
          <source>The common I/O protocol has been present in OTP since the beginning, but has been undocumented and has also evolved over the years. In an addendum to Robert Virding's rationale, the original I/O protocol is described. This section describes the current I/O protocol.</source>
          <target state="translated">共通の I/O プロトコルは OTP に最初から存在していましたが、文書化されておらず、長年にわたって進化してきました。Robert Virdingの理論的根拠の補遺では、オリジナルのI/Oプロトコルが記述されています。ここでは、現在のI/Oプロトコルについて説明します。</target>
        </trans-unit>
        <trans-unit id="615ef8c10dad53dc0e37ab3cc2865c03f16fe578" translate="yes" xml:space="preserve">
          <source>The communication protocol between sub-agents is the normal message passing which is used in distributed Erlang systems. This implies that sub-agent communication is very efficient compared to SMUX, DPI, AgentX, and similar protocols.</source>
          <target state="translated">サブエージェント間の通信プロトコルは、分散Erlangシステムで使われている通常のメッセージパッシングです。このことは、SMUX,DPI,AgentXなどに比べて、サブエージェント間の通信が非常に効率的であることを意味します。</target>
        </trans-unit>
        <trans-unit id="95e038ffe06742bd9a3eacaa7f1ab1768afde277" translate="yes" xml:space="preserve">
          <source>The community information should be stored in a file called &lt;code&gt;community.conf&lt;/code&gt;. It must be present if the agent is configured for SNMPv1 or SNMPv2c.</source>
          <target state="translated">コミュニティ情報は、 &lt;code&gt;community.conf&lt;/code&gt; というファイルに保存する必要があります。エージェントがSNMPv1またはSNMPv2c用に構成されている場合は、存在する必要があります。</target>
        </trans-unit>
        <trans-unit id="ae1b5318f7be646ee745ed8d6cfbf8aaace9d57c" translate="yes" xml:space="preserve">
          <source>The compilation option &lt;code&gt;debug_info&lt;/code&gt; can be specified to the compiler to have the abstract code stored in the &lt;code&gt;abstract_code&lt;/code&gt; chunk in the Beam file (for debugging purposes).</source>
          <target state="translated">コンパイラーにコンパイルオプション &lt;code&gt;debug_info&lt;/code&gt; を指定して、（デバッグ目的で）Beamファイルの &lt;code&gt;abstract_code&lt;/code&gt; チャンクに抽象コードを保存できます。</target>
        </trans-unit>
        <trans-unit id="992839cad735d18aaa4ef05287e210db80780266" translate="yes" xml:space="preserve">
          <source>The compile time of the emulator running the originating node</source>
          <target state="translated">元のノードを実行しているエミュレータのコンパイル時間</target>
        </trans-unit>
        <trans-unit id="77923285d15f6d1638ca1085b0ea9ec5d8971d25" translate="yes" xml:space="preserve">
          <source>The compiled files of the imported MIBs must be present in the current directory, or a directory in the current path. The path is supplied with the &lt;code&gt;{i, Path}&lt;/code&gt; option, for example:</source>
          <target state="translated">インポートされたMIBのコンパイル済みファイルは、現在のディレクトリ、または現在のパスのディレクトリに存在する必要があります。パスは &lt;code&gt;{i, Path}&lt;/code&gt; オプションで提供されます。次に例を示します。</target>
        </trans-unit>
        <trans-unit id="6fb2caaa7af06a5fa0ebe6a620c35148002139db" translate="yes" xml:space="preserve">
          <source>The compiler also understands that assigning to '_' means that the value will not used. Therefore, the code in the following example will also be optimized:</source>
          <target state="translated">コンパイラは、'_' に代入することは値が使用されないことを意味することも理解しています。そのため、次の例のコードも最適化されます。</target>
        </trans-unit>
        <trans-unit id="a0aa4f7feea676dc9f8b66e36fffc1af3c1c40f5" translate="yes" xml:space="preserve">
          <source>The compiler and other compile-time functions can also be started from the Erlang shell. Here follows a brief description of the primary functions. For a complete description of each function, see module &lt;code&gt;asn1ct&lt;/code&gt; in the &lt;code&gt;&lt;a href=&quot;asn1ct&quot;&gt;ASN.1 Reference Manual&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">コンパイラーおよびその他のコンパイル時関数は、Erlangシェルからも開始できます。ここでは、主な機能について簡単に説明します。各関数の詳細については、 &lt;code&gt;&lt;a href=&quot;asn1ct&quot;&gt;ASN.1 Reference Manual&lt;/a&gt;&lt;/code&gt; モジュール &lt;code&gt;asn1ct&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="dd83f86086df5c8234f8a9ae71fc626e0a86c59a" translate="yes" xml:space="preserve">
          <source>The compiler automatically inserts the two special, exported functions into each module:</source>
          <target state="translated">コンパイラは、エクスポートされた2つの特別な関数を各モジュールに自動的に挿入します。</target>
        </trans-unit>
        <trans-unit id="0aa023f79e7e9fc3b1f355a1f8fb5632ee1a7886" translate="yes" xml:space="preserve">
          <source>The compiler can also be accessed from the OS prompt, see the &lt;code&gt;erl(1)&lt;/code&gt; manual page in ERTS.</source>
          <target state="translated">コンパイラはOSプロンプトからもアクセスできます。ERTSの &lt;code&gt;erl(1)&lt;/code&gt; マニュアルページを参照してください。</target>
        </trans-unit>
        <trans-unit id="dcd47ca4ce5f90e9af16a0a668c0506b2926c5f4" translate="yes" xml:space="preserve">
          <source>The compiler can also inline various list manipulation functions from the module &lt;code&gt;list&lt;/code&gt; in STDLIB.</source>
          <target state="translated">コンパイラは、STDLIBのモジュール &lt;code&gt;list&lt;/code&gt; からさまざまなリスト操作関数をインライン化することもできます。</target>
        </trans-unit>
        <trans-unit id="246aeec2b67ad60a1d79d7bfcb202381eb810d23" translate="yes" xml:space="preserve">
          <source>The compiler can do function inlining within an Erlang module. Inlining means that a call to a function is replaced with the function body with the arguments replaced with the actual values. The semantics are preserved, except if exceptions are generated in the inlined code. Exceptions are reported as occurring in the function the body was inlined into. Also, &lt;code&gt;function_clause&lt;/code&gt; exceptions are converted to similar &lt;code&gt;case_clause&lt;/code&gt; exceptions.</source>
          <target state="translated">コンパイラーは、Erlangモジュール内で関数のインライン展開を行うことができます。インライン化とは、関数の呼び出しが、引数が実際の値に置き換えられた関数本体に置き換えられることを意味します。インライン化されたコードで例外が生成される場合を除き、セマンティクスは保持されます。例外は、本体がインライン化された関数で発生したものとして報告されます。また、 &lt;code&gt;function_clause&lt;/code&gt; 例外は、同様の &lt;code&gt;case_clause&lt;/code&gt; 例外に変換されます。</target>
        </trans-unit>
        <trans-unit id="ba61e82e2483a5192ba41d5a737c2246810798a9" translate="yes" xml:space="preserve">
          <source>The compiler can only do this optimization if it knows that the match context will not be shared. If it would be shared, the functional properties (also called referential transparency) of Erlang would break.</source>
          <target state="translated">コンパイラはマッチコンテキストが共有されないことを知っている場合にのみ、この最適化を行うことができます。もし共有されてしまうと、Erlangの機能特性(参照透過とも呼ばれます)が壊れてしまいます。</target>
        </trans-unit>
        <trans-unit id="df9982300695d7d925cce5cf1cdd61f21ef202d8" translate="yes" xml:space="preserve">
          <source>The compiler does not warn for expressions that it does not attempt to optimize. For example, the compiler tries to evaluate &lt;code&gt;1/0&lt;/code&gt;, detects that it will cause an exception, and emits a warning. However, the compiler is silent about the similar expression, &lt;code&gt;X/0&lt;/code&gt;, because of the variable in it. Thus, the compiler does not even try to evaluate and therefore it emits no warnings.</source>
          <target state="translated">コンパイラーは、最適化を試みない式について警告しません。たとえば、コンパイラは &lt;code&gt;1/0&lt;/code&gt; を評価しようとし、それが例外を引き起こすことを検出して警告を発します。ただし、コンパイラーは、その中に変数があるため、同様の式 &lt;code&gt;X/0&lt;/code&gt; については何も表示しません。したがって、コンパイラは評価を試みないため、警告を発行しません。</target>
        </trans-unit>
        <trans-unit id="326ce5bdd2edeffbb0eff29680c2a35b2a0c7613" translate="yes" xml:space="preserve">
          <source>The compiler figures out if a variable is unused. The same code is generated for each of the following functions:</source>
          <target state="translated">コンパイラは、変数が使用されていないかどうかを判断します。以下の各関数についても同じコードが生成されます。</target>
        </trans-unit>
        <trans-unit id="736c83a9c909e8b6995b93aa5a592a8cfd21644b" translate="yes" xml:space="preserve">
          <source>The compiler generates a &lt;code&gt;decode_part/2&lt;/code&gt; function when exclusive decode is chosen. This function decodes the parts that were left undecoded during the exclusive decode.</source>
          <target state="translated">排他的なデコードが選択されている場合、コンパイラーは &lt;code&gt;decode_part/2&lt;/code&gt; 関数を生成します。この関数は、排他的デコード中にデコードされなかった部分をデコードします。</target>
        </trans-unit>
        <trans-unit id="e4f37f01f0c640d21fe0c086a15f5624a101666e" translate="yes" xml:space="preserve">
          <source>The compiler generates the following files:</source>
          <target state="translated">コンパイラは以下のファイルを生成します。</target>
        </trans-unit>
        <trans-unit id="8ae89eb6c8e241efda8fbeedb553bd086502de6d" translate="yes" xml:space="preserve">
          <source>The compiler handles the &lt;code&gt;IMPORT&lt;/code&gt; statement. It is important to import the compiled file and not the ASN.1 (source) file. A MIB must be recompiled to make changes visible to other MIBs importing it.</source>
          <target state="translated">コンパイラーは &lt;code&gt;IMPORT&lt;/code&gt; ステートメントを処理します。ASN.1（ソース）ファイルではなく、コンパイルされたファイルをインポートすることが重要です。変更をインポートする他のMIBに変更を表示するには、MIBを再コンパイルする必要があります。</target>
        </trans-unit>
        <trans-unit id="ef890ca9c7e8253725d98c0071846009690a22a4" translate="yes" xml:space="preserve">
          <source>The compiler internally rewrites the latter code into the former.</source>
          <target state="translated">コンパイラは後者のコードを内部的に前者に書き換えます。</target>
        </trans-unit>
        <trans-unit id="1f2b065f3c16869915d5310d49119f53343cacb9" translate="yes" xml:space="preserve">
          <source>The compiler is located in the module &lt;code&gt;compile&lt;/code&gt; (see the &lt;code&gt;compile(3)&lt;/code&gt; manual page in Compiler).</source>
          <target state="translated">コンパイラはモジュール &lt;code&gt;compile&lt;/code&gt; にあります（コンパイラの &lt;code&gt;compile(3)&lt;/code&gt; マニュアルページを参照してください）。</target>
        </trans-unit>
        <trans-unit id="a6b51b2ed2bc7f46e25bc64dda5c32ec191ce10a" translate="yes" xml:space="preserve">
          <source>The compiler is started by &lt;code&gt;asn1ct:compile/1&lt;/code&gt; with default options, or &lt;code&gt;asn1ct:compile/2&lt;/code&gt; if explicit options are given.</source>
          <target state="translated">コンパイラーは、デフォルトのオプションを指定して &lt;code&gt;asn1ct:compile/1&lt;/code&gt; によって開始されます。明示的なオプションが指定されている場合は、 &lt;code&gt;asn1ct:compile/2&lt;/code&gt; によって開始されます。</target>
        </trans-unit>
        <trans-unit id="7898d48c7095ef7080834ae1df25bb02756bfa73" translate="yes" xml:space="preserve">
          <source>The compiler parses the SMI file and associates each table or variable with an instrumentation function (see the figure &lt;code&gt;&lt;a href=&quot;#image-1&quot;&gt;MIB Compiler Principles&lt;/a&gt;&lt;/code&gt;). The actual instrumentation functions are not needed at MIB compile time, only their names.</source>
          <target state="translated">コンパイラーはSMIファイルを解析し、各テーブルまたは変数を計測機能に関連付けます（図「 &lt;code&gt;&lt;a href=&quot;#image-1&quot;&gt;MIB Compiler Principles&lt;/a&gt;&lt;/code&gt; 」を参照）。実際の計測機能は、MIBコンパイル時には必要ありません。名前のみが必要です。</target>
        </trans-unit>
        <trans-unit id="29ced82347a929ec3d64773bda03ab575e2ebdf7" translate="yes" xml:space="preserve">
          <source>The compiler removes building of sub binaries in the second and third clauses, and it adds an instruction to the first clause that converts &lt;code&gt;Buffer&lt;/code&gt; from a match context to a sub binary (or do nothing if &lt;code&gt;Buffer&lt;/code&gt; is a binary already).</source>
          <target state="translated">コンパイラーは、2番目と3番目の節のサブバイナリーのビルドを削除し、最初の節に命令を追加して、 &lt;code&gt;Buffer&lt;/code&gt; を一致コンテキストからサブバイナリーに変換します（または、 &lt;code&gt;Buffer&lt;/code&gt; がすでにバイナリーの場合は何もしません）。</target>
        </trans-unit>
        <trans-unit id="3e19fdc6630343c3d28603ee64052ea9f7070d01" translate="yes" xml:space="preserve">
          <source>The compiler returns the object code in a binary instead of creating an object file. If successful, the compiler returns &lt;code&gt;{ok,ModuleName,Binary}&lt;/code&gt;.</source>
          <target state="translated">コンパイラは、オブジェクトファイルを作成する代わりに、バイナリでオブジェクトコードを返します。成功した場合、コンパイラーは &lt;code&gt;{ok,ModuleName,Binary}&lt;/code&gt; 返します。</target>
        </trans-unit>
        <trans-unit id="6c32c93e25c9ed677dd8b2dc76e27b04c3f91ef2" translate="yes" xml:space="preserve">
          <source>The compiler tries to avoid generating code that creates a sub binary, only to shortly afterwards create a new match context and discard the sub binary. Instead of creating a sub binary, the match context is kept.</source>
          <target state="translated">コンパイラは、サブバイナリを作成するコードを生成しても、その後すぐに新しいマッチ コンテキストが作成され、サブバイナリが破棄されることを避けようとします。サブバイナリを作成する代わりに、マッチ コンテキストが保持されます。</target>
        </trans-unit>
        <trans-unit id="93271cc943214ad52c731246bc1c6f5f502dc5df" translate="yes" xml:space="preserve">
          <source>The compiler understands the module attribute &lt;code&gt;-behaviour(Behaviour)&lt;/code&gt; and issues warnings about missing callback functions, for example:</source>
          <target state="translated">コンパイラーは、モジュール属性 &lt;code&gt;-behaviour(Behaviour)&lt;/code&gt; を理解し、欠落しているコールバック関数に関する警告を発行します。次に例を示します。</target>
        </trans-unit>
        <trans-unit id="b4e5de69deb63fd9f8e518572799240cd4dbb515" translate="yes" xml:space="preserve">
          <source>The compiler will compress the generated object code, which can be useful for embedded systems.</source>
          <target state="translated">コンパイラは生成されたオブジェクトコードを圧縮してくれるので、組み込みシステムに便利です。</target>
        </trans-unit>
        <trans-unit id="9f6ca4a1bcb2bb18eb6fa6ea91946375fe8b63fd" translate="yes" xml:space="preserve">
          <source>The compiler will emit informational warnings about binary matching optimizations (both successful and unsuccessful). For more information, see the section about &lt;code&gt;bin_opt_info&lt;/code&gt; in the Efficiency Guide.</source>
          <target state="translated">コンパイラーは、バイナリー・マッチングの最適化（成功したものと失敗したものの両方）に関する情報警告を発行します。詳細については、効率ガイドの &lt;code&gt;bin_opt_info&lt;/code&gt; に関するセクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="272c69253881a0e58a00b19dd140c32886a5264d" translate="yes" xml:space="preserve">
          <source>The compiler will generate code similar to this:</source>
          <target state="translated">コンパイラはこのようなコードを生成します。</target>
        </trans-unit>
        <trans-unit id="f22d63ebef153d116952bd4b9cdc3d70b1deac48" translate="yes" xml:space="preserve">
          <source>The complete build environment is required while running &lt;code&gt;otp_patch_apply&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;otp_patch_apply&lt;/code&gt; を実行するには、完全なビルド環境が必要です。</target>
        </trans-unit>
        <trans-unit id="991eb99483640f8d2cb258dac8893f15f032e622" translate="yes" xml:space="preserve">
          <source>The complete content of the history buffer can be written to a configuration file by calling &lt;code&gt;ttb:write_config(ConfigFile,all)&lt;/code&gt;. Selected entries from the history can be written by calling &lt;code&gt;ttb:write_config(ConfigFile,NumList)&lt;/code&gt;, where &lt;code&gt;NumList&lt;/code&gt; is a list of integers pointing out the history entries to write. Moreover, the history buffer is always dumped to &lt;code&gt;ttb_last_config&lt;/code&gt; when &lt;code&gt;ttb:stop/0,1&lt;/code&gt; is called.</source>
          <target state="translated">&lt;code&gt;ttb:write_config(ConfigFile,all)&lt;/code&gt; 呼び出すことにより、履歴バッファの完全な内容を構成ファイルに書き込むことができます。履歴から選択したエントリを呼び出すことによって記述することができ &lt;code&gt;ttb:write_config(ConfigFile,NumList)&lt;/code&gt; 、 &lt;code&gt;NumList&lt;/code&gt; が書き込みに履歴エントリを指摘整数のリストです。さらに、 &lt;code&gt;ttb:stop/0,1&lt;/code&gt; が呼び出されると、履歴バッファーは常に &lt;code&gt;ttb_last_config&lt;/code&gt; にダンプされます。</target>
        </trans-unit>
        <trans-unit id="06275c17581f810fa4579c2f0ccfc4b29d12ac2f" translate="yes" xml:space="preserve">
          <source>The complete matching pattern always gives the first return value in the list and the remaining subpatterns are added in the order they occurred in the regular expression.</source>
          <target state="translated">完全一致パターンは常にリストの最初の戻り値を与え、残りのサブパターンは正規表現で発生した順に追加されます。</target>
        </trans-unit>
        <trans-unit id="3a13431e36ebb44eb9fa84700a106f85f4b1ac47" translate="yes" xml:space="preserve">
          <source>The complete path to the Erlang emulator. Never use the &lt;code&gt;werl&lt;/code&gt; program for this. Defaults to the &lt;code&gt;erl.exe&lt;/code&gt; in the same directory as &lt;code&gt;erlsrv.exe&lt;/code&gt;. When release handling is used, this is to be set to a program similar to &lt;code&gt;start_erl.exe&lt;/code&gt;.</source>
          <target state="translated">Erlangエミュレーターへの完全パス。これには &lt;code&gt;werl&lt;/code&gt; プログラムを使用しないでください。デフォルトでは、 &lt;code&gt;erl.exe&lt;/code&gt; と同じディレクトリにある &lt;code&gt;erlsrv.exe&lt;/code&gt; です。リリース処理を使用する場合、これは &lt;code&gt;start_erl.exe&lt;/code&gt; のようなプログラムに設定されます。</target>
        </trans-unit>
        <trans-unit id="4b9e994208ced53dcfba8c8850e25b0dd795cc2c" translate="yes" xml:space="preserve">
          <source>The complete specification for the bit syntax appears in the &lt;code&gt;Reference Manual&lt;/code&gt;.</source>
          <target state="translated">ビット構文の完全な仕様は、 &lt;code&gt;Reference Manual&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="4b9f520763856efe6e5a044f5a2e1ee496c05b06" translate="yes" xml:space="preserve">
          <source>The complexity of &lt;code&gt;A -- B&lt;/code&gt; is proportional to &lt;code&gt;length(A)*length(B)&lt;/code&gt;. That is, it becomes very slow if both &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; are long lists.</source>
          <target state="translated">&lt;code&gt;A -- B&lt;/code&gt; の複雑さは、 &lt;code&gt;length(A)*length(B)&lt;/code&gt; に比例します。つまり、 &lt;code&gt;A&lt;/code&gt; と &lt;code&gt;B&lt;/code&gt; の両方が長いリストである場合、非常に遅くなります。</target>
        </trans-unit>
        <trans-unit id="fab2bbfeb9763c6bdcd0f510a645aceccf277fc7" translate="yes" xml:space="preserve">
          <source>The complexity of &lt;code&gt;lists:subtract(A, B)&lt;/code&gt; is proportional to &lt;code&gt;length(A)*length(B)&lt;/code&gt;, meaning that it is very slow if both &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; are long lists. (If both lists are long, it is a much better choice to use ordered lists and &lt;code&gt;&lt;a href=&quot;ordsets#subtract-2&quot;&gt;ordsets:subtract/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;lists:subtract(A, B)&lt;/code&gt; の複雑さ：subtract（A、B）は &lt;code&gt;length(A)*length(B)&lt;/code&gt; に比例します。つまり、 &lt;code&gt;A&lt;/code&gt; と &lt;code&gt;B&lt;/code&gt; の両方が長いリストである場合は非常に遅くなります。 （両方のリストが長い場合は、順序付きリストと &lt;code&gt;&lt;a href=&quot;ordsets#subtract-2&quot;&gt;ordsets:subtract/2&lt;/a&gt;&lt;/code&gt; を使用する方がはるかに良い選択です。</target>
        </trans-unit>
        <trans-unit id="6fc7384b856b0bd8d7f49596a4fe364f88395e2b" translate="yes" xml:space="preserve">
          <source>The complexity on set operations is bounded by either &lt;strong&gt;O(|S|)&lt;/strong&gt; or &lt;strong&gt;O(|T| * log(|S|))&lt;/strong&gt;, where S is the largest given set, depending on which is fastest for any particular function call. For operating on sets of almost equal size, this implementation is about 3 times slower than using ordered-list sets directly. For sets of very different sizes, however, this solution can be arbitrarily much faster; in practical cases, often 10-100 times. This implementation is particularly suited for accumulating elements a few at a time, building up a large set (&amp;gt; 100-200 elements), and repeatedly testing for membership in the current set.</source>
          <target state="translated">セット演算の複雑さは、&lt;strong&gt;O（| S |）&lt;/strong&gt;または&lt;strong&gt;O（| T | * log（| S |））の&lt;/strong&gt;いずれかによって制限されます。Sは、特定の関数呼び出しでどちらが最も速いかに応じて、与えられた最大のセットです。ほぼ同じサイズのセットを操作する場合、この実装は、順序付きリストセットを直接使用する場合よりも約3倍遅くなります。ただし、非常に異なるサイズのセットの場合、このソリューションは任意ではるかに高速になる可能性があります。実際のケースでは、多くの場合10〜100回です。この実装は、一度にいくつかの要素を蓄積し、大きなセット（&amp;gt; 100-200要素）を構築し、現在のセットのメンバーシップを繰り返しテストする場合に特に適しています。</target>
        </trans-unit>
        <trans-unit id="1f0db048fd959939f98a5ab5ffcb76b17f2161e3" translate="yes" xml:space="preserve">
          <source>The component &lt;code&gt;b&lt;/code&gt; is treated as an original component when encoding a message. In this case, as it is not an optional element, it must be encoded.</source>
          <target state="translated">コンポーネント &lt;code&gt;b&lt;/code&gt; は、メッセージをエンコードするときに元のコンポーネントとして扱われます。この場合、これはオプションの要素ではないため、エンコードする必要があります。</target>
        </trans-unit>
        <trans-unit id="95df5a7aa19b0879416444bcc5ff1ff82e16895f" translate="yes" xml:space="preserve">
          <source>The compressed term format is as follows:</source>
          <target state="translated">圧縮項の形式は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="3b034a8ca7cf564d2716f7d145e9bf7ce76cd7cc" translate="yes" xml:space="preserve">
          <source>The compression algorithm none (= no compression) is removed so compression is enforced</source>
          <target state="translated">圧縮アルゴリズム none(=圧縮なし)が削除されているため、圧縮が強制されています。</target>
        </trans-unit>
        <trans-unit id="20f5418f59d5bf2e56046767d3d15b2e506ac3c4" translate="yes" xml:space="preserve">
          <source>The compressor and decompressor must use the same dictionary (see &lt;code&gt;&lt;a href=&quot;#inflateSetDictionary-2&quot;&gt;inflateSetDictionary/2&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">コンプレッサーと &lt;code&gt;&lt;a href=&quot;#inflateSetDictionary-2&quot;&gt;inflateSetDictionary/2&lt;/a&gt;&lt;/code&gt; は同じ辞書を使用する必要があります（inflateSetDictionary / 2を参照）。</target>
        </trans-unit>
        <trans-unit id="0c9ba98b827fef9b660205799a125d38d037fa2c" translate="yes" xml:space="preserve">
          <source>The concept implicates that the probability to get exactly zero is extremely low; so low that this function is in fact guaranteed to never return zero. The smallest number that it might return is &lt;code&gt;DBL_MIN&lt;/code&gt;, which is 2.0^(-1022).</source>
          <target state="translated">この概念は、正確にゼロになる確率が非常に低いことを意味しています。非常に低いため、この関数は実際にはゼロを返さないことが保証されています。返される可能性のある最小の数値は &lt;code&gt;DBL_MIN&lt;/code&gt; で、2.0 ^（-1022）です。</target>
        </trans-unit>
        <trans-unit id="943911384cb6e7518951f5974b91a80146819bfa" translate="yes" xml:space="preserve">
          <source>The concept of &quot;raw filenames&quot; can be used to handle wrongly encoded filenames if one enables Unicode filename translation (&lt;code&gt;+fnu&lt;/code&gt;) on platforms where this is not the default.</source>
          <target state="translated">これがデフォルトではないプラットフォームでUnicodeファイル名変換（ &lt;code&gt;+fnu&lt;/code&gt; ）を有効にすると、「未加工ファイル名」の概念を使用して、誤ってエンコードされたファイル名を処理できます。</target>
        </trans-unit>
        <trans-unit id="a5e9df0f0bca9d8678a66d1bcb07dea7aeeb1bd0" translate="yes" xml:space="preserve">
          <source>The concept of subtyping can be applied to integers and to other ASN.1 types. The details of subtyping are not explained here; for more information, see X.680. Various syntaxes are allowed when defining a type as an integer:</source>
          <target state="translated">サブ型付けの概念は,整数や他のASN.1型にも適用できる。サブ型付けの詳細はここでは説明しません。整数として型を定義する際には、様々な構文が許可されています。</target>
        </trans-unit>
        <trans-unit id="9ea91819bf64e3ece43df4e073d660a0ac1fb62c" translate="yes" xml:space="preserve">
          <source>The conceptual repository for management information is called the Management Information Base (MIB). It does not hold any data, merely a definition of what data can be accessed. A definition of an MIB is a description of a collection of managed objects.</source>
          <target state="translated">経営情報の概念的なリポジトリは、MIB(Management Information Base)と呼ばれています。MIBはデータを保持しているわけではなく、どのようなデータにアクセスできるかを定義しているに過ぎない。MIBの定義は、管理されているオブジェクトの集合体の記述である。</target>
        </trans-unit>
        <trans-unit id="1f0f7f9a82dfed01500e86c2a2936e52983cbea0" translate="yes" xml:space="preserve">
          <source>The condition is a positive lookahead assertion that matches an optional sequence of non-letters followed by a letter. That is, it tests for the presence of at least one letter in the subject. If a letter is found, the subject is matched against the first alternative, otherwise it is matched against the second. This pattern matches strings in one of the two forms dd-aaa-dd or dd-dd-dd, where aaa are letters and dd are digits.</source>
          <target state="translated">条件は、文字の後に文字が続く非文字の任意のシーケンスにマッチする正のルックヘッドアサーションである。つまり、件名に少なくとも 1 つの文字が含まれているかどうかをテストします。文字が見つかった場合、サブジェクトは最初の代替案にマッチし、そうでない場合は 2 番目の代替案にマッチします。このパターンは、dd-aaa-a-dd または dd-dd-dd の 2 つの形式のいずれかの文字列にマッチします (aaa は文字、dd は桁です)。</target>
        </trans-unit>
        <trans-unit id="2bb2d4ddfb9fd4340f3bf62302b4368f672d1819" translate="yes" xml:space="preserve">
          <source>The condition is specified by the user as a module name &lt;code&gt;CModule&lt;/code&gt; and a function name &lt;code&gt;CFunction&lt;/code&gt;. When a process reaches the breakpoint, &lt;code&gt;CModule:CFunction(Bindings)&lt;/code&gt; is evaluated. If and only if this function call returns &lt;code&gt;true&lt;/code&gt;, the process stops. If the function call returns &lt;code&gt;false&lt;/code&gt;, the breakpoint is silently ignored.</source>
          <target state="translated">条件は、ユーザーがモジュール名 &lt;code&gt;CModule&lt;/code&gt; および関数名 &lt;code&gt;CFunction&lt;/code&gt; として指定します。プロセスがブレークポイントに到達すると、 &lt;code&gt;CModule:CFunction(Bindings)&lt;/code&gt; が評価されます。この関数呼び出しが &lt;code&gt;true&lt;/code&gt; を返す場合のみ、プロセスは停止します。関数呼び出しが &lt;code&gt;false&lt;/code&gt; を返した場合、ブレークポイントは通知なく無視されます。</target>
        </trans-unit>
        <trans-unit id="f7986bbea85397da9d57d44bc07228d7fb46c1a2" translate="yes" xml:space="preserve">
          <source>The conditional test is performed by calling &lt;code&gt;Module:Name(Bindings)&lt;/code&gt;, where &lt;code&gt;Bindings&lt;/code&gt; is the current variable bindings. The function must return &lt;code&gt;true&lt;/code&gt; (break) or &lt;code&gt;false&lt;/code&gt; (do not break). To retrieve the value of a variable &lt;code&gt;Var&lt;/code&gt;, use &lt;code&gt;&lt;a href=&quot;int#get_binding-2&quot;&gt;int:get_binding(Var, Bindings)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">条件付きテストは、 &lt;code&gt;Module:Name(Bindings)&lt;/code&gt; を呼び出すことによって実行されます。ここで、 &lt;code&gt;Bindings&lt;/code&gt; は現在の変数バインディングです。関数は &lt;code&gt;true&lt;/code&gt; （ブレーク）または &lt;code&gt;false&lt;/code&gt; （ブレークしない）を返す必要があります。変数の値を取得するには &lt;code&gt;Var&lt;/code&gt; 、使用 &lt;code&gt;&lt;a href=&quot;int#get_binding-2&quot;&gt;int:get_binding(Var, Bindings)&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8e22cdbb695181f6db56e9e8f9255cb87d1e5c71" translate="yes" xml:space="preserve">
          <source>The conditions for the range request are not fulfilled. The response must not be treated as a range request, instead it must be treated as an ordinary get request.</source>
          <target state="translated">範囲リクエストの条件が満たされていません。レスポンスは範囲リクエストとして扱われてはならず、代わりに通常の get リクエストとして扱われなければなりません。</target>
        </trans-unit>
        <trans-unit id="1c7d9b54f9813dcda9a518f9cbb3355ce28a2103" translate="yes" xml:space="preserve">
          <source>The config file directives stored as key-value tuples in an ETS table. Depicted &lt;code&gt;config_db()&lt;/code&gt; in function type declarations.</source>
          <target state="translated">ETSテーブルにKey-Valueタプルとして保存された設定ファイルディレクティブ。図示 &lt;code&gt;config_db()&lt;/code&gt; 関数の型宣言です。</target>
        </trans-unit>
        <trans-unit id="1c180f4dced667f5747360888d336f97b780f3ef" translate="yes" xml:space="preserve">
          <source>The configuration can be changed during runtime. This is done with the functions &lt;code&gt;&lt;a href=&quot;megaco#update_user_info&quot;&gt;megaco:update_user_info&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;megaco#update_conn_info&quot;&gt;megaco:update_conn_info&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">構成は実行時に変更できます。これは、関数 &lt;code&gt;&lt;a href=&quot;megaco#update_user_info&quot;&gt;megaco:update_user_info&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;megaco#update_conn_info&quot;&gt;megaco:update_conn_info&lt;/a&gt;&lt;/code&gt; を使用して行われます。</target>
        </trans-unit>
        <trans-unit id="6c0742cfd72a2d898508fa85616b5365c6647a68" translate="yes" xml:space="preserve">
          <source>The configuration created by &lt;code&gt;erts_alloc_config&lt;/code&gt; may perform bad, ever horrible, for runtime scenarios that are very different from the ones saved when creating the configuration. You are, therefore, advised to rerun &lt;code&gt;erts_alloc_config&lt;/code&gt; if the applications run when the configuration was made are changed, or if the load on the applications have changed since the configuration was made. You are also advised to rerun &lt;code&gt;erts_alloc_config&lt;/code&gt; if the Erlang runtime system used is changed.</source>
          <target state="translated">&lt;code&gt;erts_alloc_config&lt;/code&gt; によって作成された構成は、構成の作成時に保存されたものとは非常に異なるランタイムシナリオで、パフォーマンスが低下し、恐ろしいものになる可能性があります。したがって、構成が行われたときにアプリケーションが実行された場合、または構成が行われてからアプリケーションの負荷が変更された場合は、 &lt;code&gt;erts_alloc_config&lt;/code&gt; を再実行することをお勧めします。また、使用するErlangランタイムシステムが変更された場合は、 &lt;code&gt;erts_alloc_config&lt;/code&gt; を再実行することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="85fc09c0359e30e0ac0453b4dd29606f3be0cecc" translate="yes" xml:space="preserve">
          <source>The configuration file is to be called &lt;code&gt;Name.config&lt;/code&gt;, where &lt;code&gt;Name&lt;/code&gt; is any name.</source>
          <target state="translated">構成ファイルは &lt;code&gt;Name.config&lt;/code&gt; と呼ばれます。ここで、 &lt;code&gt;Name&lt;/code&gt; は任意の名前です。</target>
        </trans-unit>
        <trans-unit id="2e343dc41431506d1bab7a8f1ff51c6eab8fb28a" translate="yes" xml:space="preserve">
          <source>The configuration file must be as for &lt;code&gt;&lt;a href=&quot;#put-3&quot;&gt;ct_ftp:put/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">構成ファイルは、 &lt;code&gt;&lt;a href=&quot;#put-3&quot;&gt;ct_ftp:put/3&lt;/a&gt;&lt;/code&gt; と同じである必要があります。</target>
        </trans-unit>
        <trans-unit id="dea2779e1cbd9f4e936b9d22bec123fd3a929a25" translate="yes" xml:space="preserve">
          <source>The configuration file read is: &lt;code&gt;community.conf&lt;/code&gt;.</source>
          <target state="translated">読み込まれる設定ファイルは &lt;code&gt;community.conf&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="7c155b3574ab962c920c1adb90ff1fbf8e4d0be7" translate="yes" xml:space="preserve">
          <source>The configuration file read is: &lt;code&gt;context.conf&lt;/code&gt;.</source>
          <target state="translated">読み込まれる設定ファイルは &lt;code&gt;context.conf&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="f94cc61e31a7b0de35c335106254d680dc12d2e8" translate="yes" xml:space="preserve">
          <source>The configuration file read is: &lt;code&gt;notify.conf&lt;/code&gt;.</source>
          <target state="translated">読み込まれる設定ファイルは &lt;code&gt;notify.conf&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="8a287de08efb6a6960170e4a56df71f4fd0b681e" translate="yes" xml:space="preserve">
          <source>The configuration file read is: &lt;code&gt;standard.conf&lt;/code&gt;.</source>
          <target state="translated">読み込まれる設定ファイルは &lt;code&gt;standard.conf&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="edf952b8d588b0a93a4ac1f9d47f9ec65e928fc4" translate="yes" xml:space="preserve">
          <source>The configuration file read is: &lt;code&gt;usm.conf&lt;/code&gt;.</source>
          <target state="translated">読み込まれる設定ファイルは、 &lt;code&gt;usm.conf&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="2ac382ba3d28511c043e21b8f905a371edc5d62a" translate="yes" xml:space="preserve">
          <source>The configuration file read is: &lt;code&gt;vacm.conf&lt;/code&gt;.</source>
          <target state="translated">読み込まれる設定ファイルは &lt;code&gt;vacm.conf&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="b3706f3f0276351526850c287f3491578e144daa" translate="yes" xml:space="preserve">
          <source>The configuration files are described in the SNMP User's Manual.</source>
          <target state="translated">設定ファイルは、SNMP ユーザーズマニュアルに記載されています。</target>
        </trans-unit>
        <trans-unit id="d6aaee960bcbac0afc5716e7f7102e83e8360020" translate="yes" xml:space="preserve">
          <source>The configuration files is to have &lt;code&gt;rw-r--r--&lt;/code&gt; file privileges and be owned by root.</source>
          <target state="translated">構成ファイルは、 &lt;code&gt;rw-r--r--&lt;/code&gt; ファイル特権を持ち、rootによって所有されます。</target>
        </trans-unit>
        <trans-unit id="7d385331a206f67eef31fa2a51c3328ec0a6039b" translate="yes" xml:space="preserve">
          <source>The configuration files read are: &lt;code&gt;target_addr.conf&lt;/code&gt; and &lt;code&gt;target_params.conf&lt;/code&gt;.</source>
          <target state="translated">読み込まれる設定ファイルは、 &lt;code&gt;target_addr.conf&lt;/code&gt; および &lt;code&gt;target_params.conf&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="042a7891933367b39b8962f8cd2c79595dff050a" translate="yes" xml:space="preserve">
          <source>The configuration for a handler is a map with the following keys:</source>
          <target state="translated">ハンドラの設定は、以下のキーを持つマップです。</target>
        </trans-unit>
        <trans-unit id="8c1a1fcfff199b6a1287871c07c285d5f0e37425" translate="yes" xml:space="preserve">
          <source>The configuration for the built-in handlers is described in the &lt;code&gt;&lt;a href=&quot;logger_std_h&quot;&gt;logger_std_h(3)&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;logger_disk_log_h&quot;&gt;logger_disk_log_h(3)&lt;/a&gt;&lt;/code&gt; manual pages.</source>
          <target state="translated">組み込みハンドラの設定については、 &lt;code&gt;&lt;a href=&quot;logger_std_h&quot;&gt;logger_std_h(3)&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;logger_disk_log_h&quot;&gt;logger_disk_log_h(3)&lt;/a&gt;&lt;/code&gt; のマニュアルページで説明しています。</target>
        </trans-unit>
        <trans-unit id="3bec465458a3428115fd8e864e0c74437e5202fb" translate="yes" xml:space="preserve">
          <source>The configuration functions &lt;code&gt;init_per_suite&lt;/code&gt; and &lt;code&gt;end_per_suite&lt;/code&gt; execute, like test cases, on dedicated Erlang processes.</source>
          <target state="translated">構成関数 &lt;code&gt;init_per_suite&lt;/code&gt; と &lt;code&gt;end_per_suite&lt;/code&gt; は、専用のErlangプロセスでテストケースのように実行されます。</target>
        </trans-unit>
        <trans-unit id="ca028bc56c7a5d8a6feb5fb00bb7ad713784158b" translate="yes" xml:space="preserve">
          <source>The configuration functions are optional. The following example is a test suite without configuration functions, including one simple test case, to check that module &lt;code&gt;mymod&lt;/code&gt; exists (that is, can be successfully loaded by the code server):</source>
          <target state="translated">設定機能はオプションです。次の例は、モジュール &lt;code&gt;mymod&lt;/code&gt; が存在する（つまり、コードサーバーによって正常にロードできる）ことを確認するための、1つの単純なテストケースを含む、構成関数のないテストスイートです。</target>
        </trans-unit>
        <trans-unit id="b7ecabb96142aae8632b3c398a0652fea4462151" translate="yes" xml:space="preserve">
          <source>The configuration is created based on information about a number of runtime scenarios. It is obviously impossible to foresee every runtime scenario that can occur. The important scenarios are those that cause maximum or minimum load on specific memory allocators. Load in this context is total size of memory blocks allocated.</source>
          <target state="translated">設定は、多くのランタイムシナリオに関する情報に基づいて作成されます。発生しうるすべてのランタイムシナリオを予測することは明らかに不可能です。重要なシナリオは、特定のメモリアロケータに最大または最小の負荷がかかるシナリオです。ここでいう負荷とは、割り当てられたメモリブロックの総サイズのことです。</target>
        </trans-unit>
        <trans-unit id="a090830d0bfa6e8b71055c052afa6781c7336637" translate="yes" xml:space="preserve">
          <source>The configuration of a &lt;code&gt;Mnesia&lt;/code&gt; system is described in a schema. The schema is a special table that includes information such as the table names and the storage type of each table (that is, whether a table is to be stored in RAM, on disc, or on both, as well as its location).</source>
          <target state="translated">&lt;code&gt;Mnesia&lt;/code&gt; システムの構成はスキーマに記述されています。スキーマは、テーブル名や各テーブルのストレージタイプ（つまり、テーブルをRAMに保存するか、ディスクに保存するか、またはその両方に保存するか、およびその場所）などの情報を含む特別なテーブルです。</target>
        </trans-unit>
        <trans-unit id="50fec7a20842abcc0261e4b0c9e02b04cf3308e0" translate="yes" xml:space="preserve">
          <source>The configuration of the server is provided as an Erlang property list. For backwards compatibility, a configuration file using apache-style configuration directives is supported.</source>
          <target state="translated">サーバの設定はErlangのプロパティリストとして提供されます。後方互換性のために、apacheスタイルの設定ディレクティブを使った設定ファイルがサポートされています。</target>
        </trans-unit>
        <trans-unit id="42a81cb11873a89bc4dc7fee0b14edc95426ecba" translate="yes" xml:space="preserve">
          <source>The configuration option &lt;code&gt;filter_default&lt;/code&gt; specifies the behaviour if all filter functions return &lt;code&gt;ignore&lt;/code&gt;, or if no filters exist. &lt;code&gt;filter_default&lt;/code&gt; is by default set to &lt;code&gt;log&lt;/code&gt;, meaning that if all existing filters ignore a log event, Logger forwards the event to the handler callback. If &lt;code&gt;filter_default&lt;/code&gt; is set to &lt;code&gt;stop&lt;/code&gt;, Logger discards such events.</source>
          <target state="translated">設定オプション &lt;code&gt;filter_default&lt;/code&gt; は、すべてのフィルター関数が &lt;code&gt;ignore&lt;/code&gt; を返す場合、またはフィルターが存在しない場合の動作を指定します。 &lt;code&gt;filter_default&lt;/code&gt; はデフォルトで &lt;code&gt;log&lt;/code&gt; に設定されています。つまり、既存のすべてのフィルターがログイベントを無視した場合、Loggerはイベントをハンドラーコールバックに転送します。 &lt;code&gt;filter_default&lt;/code&gt; が &lt;code&gt;stop&lt;/code&gt; に設定されている場合、ロガーはそのようなイベントを破棄します。</target>
        </trans-unit>
        <trans-unit id="7cbcc3590c5b004952bd57c5ea409bb2cbc75510" translate="yes" xml:space="preserve">
          <source>The configuration parameter does not exist.</source>
          <target state="translated">構成パラメータが存在しません。</target>
        </trans-unit>
        <trans-unit id="81a4addb98ae9327dd483e9ad9426add086cb215" translate="yes" xml:space="preserve">
          <source>The configuration produced by &lt;code&gt;erts_alloc_config&lt;/code&gt; may need to be manually adjusted as already stated. Do not modify the file produced by &lt;code&gt;erts_alloc_config&lt;/code&gt;; instead, put your modifications in another file and load this file after the file produced by &lt;code&gt;erts_alloc_config&lt;/code&gt;. That is, put the &lt;code&gt;-args_file FileName&lt;/code&gt; argument that reads your modification file later on the command-line than the &lt;code&gt;-args_file FileName&lt;/code&gt; argument that reads the configuration file produced by &lt;code&gt;erts_alloc_config&lt;/code&gt;. If a memory allocation parameter appear multiple times, the last version of will be used, i.e., you can override parameters in the configuration file produced by &lt;code&gt;erts_alloc_config&lt;/code&gt;. Doing it this way simplifies things when you want to rerun &lt;code&gt;erts_alloc_config&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;erts_alloc_config&lt;/code&gt; によって生成された構成は、すでに述べたように手動で調整する必要がある場合があります。 &lt;code&gt;erts_alloc_config&lt;/code&gt; によって生成されたファイルを変更しないでください。代わりに、変更を別のファイルに入れ、 &lt;code&gt;erts_alloc_config&lt;/code&gt; によって生成されたファイルの後にこのファイルをロードします。つまり、入れ &lt;code&gt;-args_file FileName&lt;/code&gt; よりもコマンドラインで後で修正ファイルを読み込み、引数 &lt;code&gt;-args_file FileName&lt;/code&gt; によって生成設定ファイル読み込み引数 &lt;code&gt;erts_alloc_config&lt;/code&gt; を。メモリ割り当てパラメータが複数回出現する場合、最後のバージョンが使用されます。つまり、 &lt;code&gt;erts_alloc_config&lt;/code&gt; によって生成された構成ファイルのパラメータを上書きできます。この方法で行うと、 &lt;code&gt;erts_alloc_config&lt;/code&gt; を再実行したい場合に作業が簡単になります。</target>
        </trans-unit>
        <trans-unit id="213a1cc6b8684b6f32c379587c37729fd6c0d583" translate="yes" xml:space="preserve">
          <source>The configuration string for this driver can be &lt;code&gt;config_server&lt;/code&gt;, if the &lt;code&gt;config_server.erl&lt;/code&gt; module that follows is compiled and exists in the code path during test execution:</source>
          <target state="translated">次の &lt;code&gt;config_server.erl&lt;/code&gt; モジュールがコンパイルされ、テスト実行中にコードパスに存在する場合、このドライバーの構成文字列は &lt;code&gt;config_server&lt;/code&gt; にすることができます。</target>
        </trans-unit>
        <trans-unit id="d419157999767488a1c56645c3a2365b2bbbcd93" translate="yes" xml:space="preserve">
          <source>The configuration term for &lt;code&gt;logger_formatter&lt;/code&gt; is a &lt;code&gt;map&lt;/code&gt;, and the following keys can be set as configuration parameters:</source>
          <target state="translated">&lt;code&gt;logger_formatter&lt;/code&gt; の構成用語は &lt;code&gt;map&lt;/code&gt; であり、以下のキーを構成パラメーターとして設定できます。</target>
        </trans-unit>
        <trans-unit id="712ad0cc82e1a88f726b7f711e243ab197e28193" translate="yes" xml:space="preserve">
          <source>The configure script allows you to customize a number of parameters; type &lt;code&gt;./configure --help&lt;/code&gt; or &lt;code&gt;./configure --help=recursive&lt;/code&gt; for details. &lt;code&gt;./configure --help=recursive&lt;/code&gt; will give help for all &lt;code&gt;configure&lt;/code&gt; scripts in all applications.</source>
          <target state="translated">configureスクリプトを使用すると、いくつかのパラメータをカスタマイズできます。入力 &lt;code&gt;./configure --help&lt;/code&gt; か &lt;code&gt;./configure --help=recursive&lt;/code&gt; 詳細については。 &lt;code&gt;./configure --help=recursive&lt;/code&gt; は、すべてのアプリケーションのすべての &lt;code&gt;configure&lt;/code&gt; スクリプトのヘルプを提供します。</target>
        </trans-unit>
        <trans-unit id="f871702162e9fe05aae1c9e32504517869931c15" translate="yes" xml:space="preserve">
          <source>The configure script is created by the GNU autoconf utility, which checks for system specific features and then creates a number of makefiles.</source>
          <target state="translated">configure スクリプトは GNU autoconf ユーティリティによって作成され、 システム固有の機能をチェックして、いくつかの makefile を作成します。</target>
        </trans-unit>
        <trans-unit id="7d4bba926aeb3883bfbd6d00a31923bc874078ac" translate="yes" xml:space="preserve">
          <source>The configure should be skipped and all tests should hopefully pass. For more details about how to use ts run &lt;code&gt;erl -s ts help -s init stop&lt;/code&gt;</source>
          <target state="translated">構成はスキップする必要があり、すべてのテストがうまくいけば成功するはずです。tsの使用方法の詳細については、 &lt;code&gt;erl -s ts help -s init stop&lt;/code&gt; を実行してください。</target>
        </trans-unit>
        <trans-unit id="3f6521bf4e434f67b356b39a99c1ade02b2e892c" translate="yes" xml:space="preserve">
          <source>The connect is done in two steps: first an internal &lt;code&gt;connection setup&lt;/code&gt; and then by calling the user &lt;code&gt;&lt;a href=&quot;megaco_user#connect&quot;&gt;handle_connect&lt;/a&gt;&lt;/code&gt; callback function. The first step could result in an error with &lt;code&gt;Reason = connect_reason()&lt;/code&gt; and the second an error with &lt;code&gt;Reason = handle_connect_reason()&lt;/code&gt;:</source>
          <target state="translated">接続は2つのステップで行われます。最初に内部 &lt;code&gt;connection setup&lt;/code&gt; 、次にユーザーの &lt;code&gt;&lt;a href=&quot;megaco_user#connect&quot;&gt;handle_connect&lt;/a&gt;&lt;/code&gt; コールバック関数を呼び出します。最初のステップでは、 &lt;code&gt;Reason = connect_reason()&lt;/code&gt; のエラーが発生し、2番目のステップでは、 &lt;code&gt;Reason = handle_connect_reason()&lt;/code&gt; エラーが発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="371ea327d46ab20111d8dd7bba591b3794f31f48" translate="yes" xml:space="preserve">
          <source>The connection attempt can be traced by setting a trace level by either using &lt;code&gt;ei_set_tracelevel&lt;/code&gt; or by setting environment variable &lt;code&gt;EI_TRACELEVEL&lt;/code&gt;. The trace levels have the following messages:</source>
          <target state="translated">接続の試行は、 &lt;code&gt;ei_set_tracelevel&lt;/code&gt; を使用するか、環境変数 &lt;code&gt;EI_TRACELEVEL&lt;/code&gt; を設定することにより、トレースレベルを設定することで追跡できます。トレースレベルには次のメッセージがあります。</target>
        </trans-unit>
        <trans-unit id="cef16d7f5ec818bdeac2287eb2c52b738775d9e3" translate="yes" xml:space="preserve">
          <source>The connection created to the EPMD must be kept as long as the node is a distributed node. When the connection is closed, the node is automatically unregistered from the EPMD.</source>
          <target state="translated">EPMDに作成した接続は、そのノードが分散ノードである限り維持する必要があります。接続を閉じると、そのノードは自動的にEPMDから登録解除されます。</target>
        </trans-unit>
        <trans-unit id="5cbfa81fe3ccd8a5c63ea407c66f04845f8cea33" translate="yes" xml:space="preserve">
          <source>The connection is already encrypted. The connection is not affected.</source>
          <target state="translated">接続はすでに暗号化されています。接続に影響はありません。</target>
        </trans-unit>
        <trans-unit id="759c06525846f46120048a080c3029be1ff31bcc" translate="yes" xml:space="preserve">
          <source>The connection is associated with the process that created it and can only be accessed through it. The reason for this is to preserve the semantics of result sets and transactions when select_count/[2,3] is called or auto_commit is turned off. Attempts to use the connection from another process will fail. This will not effect the connection. On the other hand, if the client process dies the connection will be terminated.</source>
          <target state="translated">接続は、それを作成したプロセスに関連付けられており、それを介してのみアクセスすることができます。これは、select_count/[2,3]が呼び出されたとき、またはauto_commitがオフになっているときに、結果セットとトランザクションのセマンティクスを保持するためです。他のプロセスからの接続を使用しようとすると失敗します。これは接続には影響しません。一方、クライアントプロセスが終了した場合、接続は終了します。</target>
        </trans-unit>
        <trans-unit id="6bd0a40ef6e388c1101ec314a27b945374892947" translate="yes" xml:space="preserve">
          <source>The connection is disallowed for some (unspecified) security reason.</source>
          <target state="translated">この接続は、何らかの(不特定の)セキュリティ上の理由で拒否されています。</target>
        </trans-unit>
        <trans-unit id="f988842124188a5fc24f10cf75663bb95aaa98aa" translate="yes" xml:space="preserve">
          <source>The connection setup failed (after &lt;code&gt;nodeup&lt;/code&gt; messages were sent).</source>
          <target state="translated">接続のセットアップが失敗しました（ &lt;code&gt;nodeup&lt;/code&gt; メッセージが送信された後）。</target>
        </trans-unit>
        <trans-unit id="2c2c09cbaff852e46a92c401a3052832960adf16" translate="yes" xml:space="preserve">
          <source>The connection state.</source>
          <target state="translated">接続状態です。</target>
        </trans-unit>
        <trans-unit id="21a557db3cf2f1855e12dfec5d40959655ffd926" translate="yes" xml:space="preserve">
          <source>The connection string is to be a connection string for postgres.</source>
          <target state="translated">接続文字列はpostgres用の接続文字列になります。</target>
        </trans-unit>
        <trans-unit id="577ebba31469c1b19a854e051f7d7bcd77b95482" translate="yes" xml:space="preserve">
          <source>The connection was closed.</source>
          <target state="translated">接続は終了していました。</target>
        </trans-unit>
        <trans-unit id="f85b0a947aa3ee4eeec0e9164d045d949bc237ff" translate="yes" xml:space="preserve">
          <source>The connection was disconnected (forced from the current node).</source>
          <target state="translated">接続が切断されました(現在のノードから強制的に)。</target>
        </trans-unit>
        <trans-unit id="faa62673d542db68465d9b4076b4c1a13a9c2ef7" translate="yes" xml:space="preserve">
          <source>The consistency property ensures that a transaction always leaves the DBMS in a consistent state. For example, &lt;code&gt;Mnesia&lt;/code&gt; ensures that no inconsistencies occur if Erlang, &lt;code&gt;Mnesia&lt;/code&gt;, or the computer crashes while a write operation is in progress.</source>
          <target state="translated">一貫性プロパティは、トランザクションが常にDBMSを一貫した状態にしておくことを保証します。たとえば、 &lt;code&gt;Mnesia&lt;/code&gt; は、Erlang、 &lt;code&gt;Mnesia&lt;/code&gt; 、または書き込み操作の進行中にコンピューターがクラッシュした場合に矛盾が発生しないようにします。</target>
        </trans-unit>
        <trans-unit id="1ddfddbb8f225dd73ee75750b50447169433b54f" translate="yes" xml:space="preserve">
          <source>The constant &lt;code&gt;?STD_VERBOSITY&lt;/code&gt; has value 50 (see &lt;code&gt;ct.hrl&lt;/code&gt;). At this level, all standard I/O gets printed. If a lower verbosity level is set, standard I/O printouts are ignored. Verbosity level 0 effectively turns all logging off (except from printouts made by &lt;code&gt;Common Test&lt;/code&gt; itself).</source>
          <target state="translated">定数 &lt;code&gt;?STD_VERBOSITY&lt;/code&gt; の値は50です（ &lt;code&gt;ct.hrl&lt;/code&gt; を参照）。このレベルでは、すべての標準I / Oが出力されます。冗長レベルを低く設定すると、標準のI / O印刷出力は無視されます。冗長性レベル0は、すべてのロギングを事実上オフにします（ &lt;code&gt;Common Test&lt;/code&gt; 自体によって行われた印刷出力を除く）。</target>
        </trans-unit>
        <trans-unit id="41f1224d66b802b926b2e31ecb1f284682edfb00" translate="yes" xml:space="preserve">
          <source>The construction &lt;code&gt;??Arg&lt;/code&gt;, where &lt;code&gt;Arg&lt;/code&gt; is a macro argument, is expanded to a string containing the tokens of the argument. This is similar to the &lt;code&gt;#arg&lt;/code&gt; stringifying construction in C.</source>
          <target state="translated">構文 &lt;code&gt;??Arg&lt;/code&gt; （ &lt;code&gt;Arg&lt;/code&gt; はマクロ引数）は、引数のトークンを含む文字列に展開されます。これは、Cの &lt;code&gt;#arg&lt;/code&gt; 文字列構成に似ています。</target>
        </trans-unit>
        <trans-unit id="e122203f3d8b9817a2ea30ffb99c064337701c17" translate="yes" xml:space="preserve">
          <source>The content and meaning of these messages do not need to be interpreted by the process. Instead the following function is to be called:</source>
          <target state="translated">これらのメッセージの内容と意味は、プロセスによって解釈される必要はありません。その代わりに、以下の関数を呼び出す必要があります。</target>
        </trans-unit>
        <trans-unit id="968fd451ababe1d06f33d9607e5b522cbdd869a3" translate="yes" xml:space="preserve">
          <source>The content of these variables are added to the end of the command line for &lt;code&gt;erl&lt;/code&gt;.</source>
          <target state="translated">これらの変数の内容は、 &lt;code&gt;erl&lt;/code&gt; のコマンドラインの最後に追加されます。</target>
        </trans-unit>
        <trans-unit id="16b69fb0bdc6287d140f1bf18649d3746425bdf1" translate="yes" xml:space="preserve">
          <source>The content of this variable is added to the beginning of the command line for &lt;code&gt;erl&lt;/code&gt;.</source>
          <target state="translated">この変数の内容は、 &lt;code&gt;erl&lt;/code&gt; のコマンドラインの先頭に追加されます。</target>
        </trans-unit>
        <trans-unit id="9a245ccccd6f901e15ebc8675d831502211bf76e" translate="yes" xml:space="preserve">
          <source>The content-length of the document transferred.</source>
          <target state="translated">転送された文書の内容の長さ。</target>
        </trans-unit>
        <trans-unit id="a88162e7d9c808763714e1548a612b2fffddbc1c" translate="yes" xml:space="preserve">
          <source>The contents can be any term but in order to simplify post processing of the traced events, a plain list of {Key, Value} tuples is preferred.</source>
          <target state="translated">内容はどのような項でも構いませんが、トレースされたイベントの後処理を簡単にするために、{Key,Value}タプルの単純なリストが好まれます。</target>
        </trans-unit>
        <trans-unit id="40ce0e904e227f1f1d80e3e97a8e2fc6da1aa9d8" translate="yes" xml:space="preserve">
          <source>The contents of a &lt;code&gt;Mnesia&lt;/code&gt; table are read into the registry.</source>
          <target state="translated">&lt;code&gt;Mnesia&lt;/code&gt; テーブルの内容がレジストリに読み込まれます。</target>
        </trans-unit>
        <trans-unit id="63f1bf049157e992729a0f1938f590c49c434454" translate="yes" xml:space="preserve">
          <source>The contents of a lookbehind assertion are restricted such that all the strings it matches must have a fixed length. However, if there are many top-level alternatives, they do not all have to have the same fixed length. Thus, the following is permitted:</source>
          <target state="translated">lookbehind アサーションの内容は、マッチするすべての文字列が固定長でなければならないように制限されています。しかし、多くのトップレベルの代替案がある場合、それらはすべて同じ固定長である必要はありません。したがって、以下のようなことが許されています。</target>
        </trans-unit>
        <trans-unit id="b15d542467bd5d0c49c3d5fddfb0a1dc700a2884" translate="yes" xml:space="preserve">
          <source>The contents of a minimal &lt;code&gt;.app&lt;/code&gt; file &lt;code&gt;ch_app.app&lt;/code&gt; for a supervision tree application like &lt;code&gt;ch_app&lt;/code&gt; looks as follows:</source>
          <target state="translated">最小限の内容 &lt;code&gt;.app&lt;/code&gt; ファイル &lt;code&gt;ch_app.app&lt;/code&gt; のような監督の木のアプリケーションのための &lt;code&gt;ch_app&lt;/code&gt; のルックスは、次のように：</target>
        </trans-unit>
        <trans-unit id="639b540a4a0d636d1f2615d8325b2b0b321bfb43" translate="yes" xml:space="preserve">
          <source>The contents of a minimal &lt;code&gt;.app&lt;/code&gt; file for a library application &lt;code&gt;libapp&lt;/code&gt; looks as follows:</source>
          <target state="translated">ライブラリアプリケーション &lt;code&gt;libapp&lt;/code&gt; の最小の &lt;code&gt;.app&lt;/code&gt; ファイルの内容は次のようになります。</target>
        </trans-unit>
        <trans-unit id="7d3ce5ee568b5e2c08421124a730a9db183b8eb2" translate="yes" xml:space="preserve">
          <source>The contents of a registry can be backed up to &lt;code&gt;Mnesia&lt;/code&gt; on a &quot;nearby&quot; Erlang node. You must provide an open connection to the Erlang node (see &lt;code&gt;&lt;a href=&quot;erl_connect&quot;&gt;erl_connect&lt;/a&gt;&lt;/code&gt;). Also, &lt;code&gt;Mnesia&lt;/code&gt; 3.0 or later must be running on the Erlang node before the backup is initiated:</source>
          <target state="translated">レジストリの内容は、「近くの」Erlangノードの &lt;code&gt;Mnesia&lt;/code&gt; にバックアップできます。Erlangノードへのオープン接続を提供する必要があります（ &lt;code&gt;&lt;a href=&quot;erl_connect&quot;&gt;erl_connect&lt;/a&gt;&lt;/code&gt; を参照）。また、バックアップが開始される前に、 &lt;code&gt;Mnesia&lt;/code&gt; 3.0以降がErlangノードで実行されている必要があります。</target>
        </trans-unit>
        <trans-unit id="3123b00654d44c25109223170c4027e9b8ae5329" translate="yes" xml:space="preserve">
          <source>The contents of the &lt;code&gt;iovec&lt;/code&gt; is valid until the called nif function returns. If the &lt;code&gt;iovec&lt;/code&gt; should be valid after the nif call returns, it is possible to call this function with a &lt;code&gt;NULL&lt;/code&gt; environment. If no environment is given the &lt;code&gt;iovec&lt;/code&gt; owns the data in the vector and it has to be explicitly freed using &lt;code&gt;&lt;a href=&quot;#enif_free_iovec&quot;&gt;enif_free_iovec&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;iovec&lt;/code&gt; の内容は、呼び出されたnif関数が戻るまで有効です。場合 &lt;code&gt;iovec&lt;/code&gt; NIF呼び出しが戻ると、有効である必要があり、この関数を呼び出すことが可能である &lt;code&gt;NULL&lt;/code&gt; の環境。環境が指定されていない場合、 &lt;code&gt;iovec&lt;/code&gt; はベクター内のデータを所有し、 &lt;code&gt;&lt;a href=&quot;#enif_free_iovec&quot;&gt;enif_free_iovec&lt;/a&gt;&lt;/code&gt; を使用して明示的に解放する必要があります。</target>
        </trans-unit>
        <trans-unit id="da4fbdeab301fdc5a2057978a62de987cbe0d76f" translate="yes" xml:space="preserve">
          <source>The contents of the configuration file can either be fetched from the history or specified directly as a list of &lt;code&gt;{Mod,Func,Args}&lt;/code&gt;.</source>
          <target state="translated">設定ファイルの内容は、履歴から取得するか、または &lt;code&gt;{Mod,Func,Args}&lt;/code&gt; リストとして直接指定できます。</target>
        </trans-unit>
        <trans-unit id="1edda41fc99de03ce1cd51669b6fb86e783cb0c4" translate="yes" xml:space="preserve">
          <source>The contents of the source file is displayed in the &lt;code&gt;&lt;a href=&quot;#view&quot;&gt;View Module window&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">ソースファイルの内容が &lt;code&gt;&lt;a href=&quot;#view&quot;&gt;View Module window&lt;/a&gt;&lt;/code&gt; の表示]ウィンドウに表示されます。</target>
        </trans-unit>
        <trans-unit id="7b8b2dc86a62154fcfa0997ece50bee44a97b77c" translate="yes" xml:space="preserve">
          <source>The context information should be stored in a file called &lt;code&gt;context.conf&lt;/code&gt;. The default context &lt;code&gt;&quot;&quot;&lt;/code&gt; need not be present.</source>
          <target state="translated">コンテキスト情報は、 &lt;code&gt;context.conf&lt;/code&gt; というファイルに保存する必要があります。デフォルトのコンテキスト &lt;code&gt;&quot;&quot;&lt;/code&gt; が存在する必要はありません。</target>
        </trans-unit>
        <trans-unit id="b66a3e2b8c6b44620e15f4c494d018a17436828d" translate="yes" xml:space="preserve">
          <source>The continuation of the first call to the re-entrant input functions must be &lt;code&gt;[]&lt;/code&gt;. For a complete description of how the re-entrant input scheme works, see Armstrong, Virding and Williams: 'Concurrent Programming in Erlang', Chapter 13.</source>
          <target state="translated">再入可能入力関数への最初の呼び出しの継続は、 &lt;code&gt;[]&lt;/code&gt; でなければなりません。再入可能な入力スキームの動作の詳細については、アームストロング、バーディング、ウィリアムズ：「Erlangでの並行プログラミング」、第13章を参照してください。</target>
        </trans-unit>
        <trans-unit id="bd08931a87a0bff5df1d5b202657eaee82a9ec50" translate="yes" xml:space="preserve">
          <source>The continuation pointer, that is, the return address for the current call. Usually useless for other than runtime system developers. This can be followed by the function into which the CP points, which is the function calling the current function.</source>
          <target state="translated">継続ポインタ、つまり現在の呼び出しの戻りアドレス。通常、ランタイムシステムの開発者以外には役に立たない。これはCPが指す関数、つまり現在の関数を呼び出す関数の後に続く。</target>
        </trans-unit>
        <trans-unit id="ea909336d43c335fbcba40445c38198c897e80b9" translate="yes" xml:space="preserve">
          <source>The contracts specified with &lt;code&gt;-callback&lt;/code&gt; attributes in behaviour modules can be further refined by adding &lt;code&gt;-spec&lt;/code&gt; attributes in callback modules. This can be useful as &lt;code&gt;-callback&lt;/code&gt; contracts are usually generic. The same callback module with contracts for the callbacks:</source>
          <target state="translated">動作モジュールで &lt;code&gt;-callback&lt;/code&gt; 属性を使用して指定された &lt;code&gt;-spec&lt;/code&gt; は、コールバックモジュールで-spec属性を追加することでさらに詳細化できます。 &lt;code&gt;-callback&lt;/code&gt; コントラクトは通常ジェネリックなので、これは便利です。コールバックのコントラクトを持つ同じコールバックモジュール：</target>
        </trans-unit>
        <trans-unit id="3e6798c48093d78537c9e8593283bd4708fcad75" translate="yes" xml:space="preserve">
          <source>The control codes that we have defined are as follows:</source>
          <target state="translated">定義した制御コードは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="7099cc27d42d7b0589281942854b91087bea547b" translate="yes" xml:space="preserve">
          <source>The control interface gets a buffer to return its value in, but is free to allocate its own buffer if the provided one is too small. The &lt;code&gt;uds_control&lt;/code&gt; code is as follows:</source>
          <target state="translated">制御インターフェースは、その値を戻すためのバッファーを取得しますが、提供されたバッファーが小さすぎる場合は、独自のバッファーを自由に割り当てることができます。 &lt;code&gt;uds_control&lt;/code&gt; のコードは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="8a434b940ea607f47b9b9c9664fa9c1e4002f5da" translate="yes" xml:space="preserve">
          <source>The convention is that all modules implementing some web server functionality has the name &lt;code&gt;mod_*&lt;/code&gt;. When configuring the web server, an appropriate selection of these modules is to be present in the module directive. Notice that there are some interaction dependencies to take into account, so the order of the modules cannot be random.</source>
          <target state="translated">慣例では、一部のWebサーバー機能を実装するすべてのモジュールの名前は &lt;code&gt;mod_*&lt;/code&gt; です。Webサーバーを構成するとき、これらのモジュールの適切な選択がモジュールディレクティブに存在します。考慮すべき相互作用の依存関係があるため、モジュールの順序をランダムにすることはできません。</target>
        </trans-unit>
        <trans-unit id="dcdf44cdd25837172eef411728f5162a4d169998" translate="yes" xml:space="preserve">
          <source>The cookie can also be specified as a list with a single atom element.</source>
          <target state="translated">クッキーは、単一のアトム要素を持つリストとして指定することもできます。</target>
        </trans-unit>
        <trans-unit id="a59a7d0400e25bda45d94942c1696b67b821c833" translate="yes" xml:space="preserve">
          <source>The cookie on the client node is set to &lt;code&gt;Cookie&lt;/code&gt; for this &lt;code&gt;rpc&lt;/code&gt; operation (used to match the server node cookie).</source>
          <target state="translated">クライアントノードの &lt;code&gt;Cookie&lt;/code&gt; は、この &lt;code&gt;rpc&lt;/code&gt; 操作のCookieに設定されます（サーバーノードのCookieと一致させるために使用されます）。</target>
        </trans-unit>
        <trans-unit id="6205a4b626543ee584a8b3de17a0bb2edfe3da9f" translate="yes" xml:space="preserve">
          <source>The cookies are never sent in cleartext and the handshake procedure expects the client (called &lt;code&gt;A&lt;/code&gt;) to be the first one to prove that it can generate a sufficient digest. The digest is generated with the MD5 message digest algorithm and the challenges are expected to be random numbers.</source>
          <target state="translated">Cookieがクリアテキストで送信されることはなく、ハンドシェイク手順では、クライアント（ &lt;code&gt;A&lt;/code&gt; と呼ばれます）が十分なダイジェストを生成できることを証明する最初のクライアントであると想定しています。ダイジェストはMD5メッセージダイジェストアルゴリズムで生成され、チャレンジは乱数であると予想されます。</target>
        </trans-unit>
        <trans-unit id="2ecaa6909338c5156841fd64226c00c498a1c90e" translate="yes" xml:space="preserve">
          <source>The cookies are text strings that can be viewed as passwords.</source>
          <target state="translated">クッキーはパスワードとして閲覧できるテキスト文字列です。</target>
        </trans-unit>
        <trans-unit id="1a8ed05dd2354fe2176cfcf5ee50be7c3c648bcb" translate="yes" xml:space="preserve">
          <source>The core applications ERTS, Kernel, STDLIB, and SASL never allow real soft upgrade, but require the Erlang emulator to be restarted. This is indicated to the &lt;code&gt;release_handler&lt;/code&gt; by the upgrade instruction &lt;code&gt;restart_new_emulator&lt;/code&gt;. This instruction is always the very first instruction executed, and it restarts the emulator with the new versions of the above mentioned core applications and the old versions of all other applications. When the node is back up, all other upgrade instructions are executed, making sure each application is finally running its new version.</source>
          <target state="translated">コアアプリケーションERTS、カーネル、STDLIB、およびSASLでは、実際のソフトアップグレードはできませんが、Erlangエミュレーターを再起動する必要があります。これは、アップグレード命令 &lt;code&gt;release_handler&lt;/code&gt; によってrelease_handlerに示され &lt;code&gt;restart_new_emulator&lt;/code&gt; 。この命令は常に最初に実行される命令であり、前述のコアアプリケーションの新しいバージョンと他のすべてのアプリケーションの古いバージョンでエミュレータを再起動します。ノードがバックアップされると、他のすべてのアップグレード手順が実行され、各アプリケーションが最終的に新しいバージョンを実行していることを確認します。</target>
        </trans-unit>
        <trans-unit id="0fa547ec967437cac7e726eba19268112eb4cac1" translate="yes" xml:space="preserve">
          <source>The correct way to write this example is as follows:</source>
          <target state="translated">この例の正しい書き方は以下のようになります。</target>
        </trans-unit>
        <trans-unit id="ff048cb1599c9ae21644f42bc221284ba85f60d6" translate="yes" xml:space="preserve">
          <source>The correctness of each application is checked as follows:</source>
          <target state="translated">各アプリケーションの正しさは、以下のようにチェックされます。</target>
        </trans-unit>
        <trans-unit id="551bede0ac40e7793c4662c9c5f268e49a7cfe5a" translate="yes" xml:space="preserve">
          <source>The correctness of time values.</source>
          <target state="translated">時間値の正しさ。</target>
        </trans-unit>
        <trans-unit id="b2a787c3a6b18144a9dd01cea8e8539d0c49480c" translate="yes" xml:space="preserve">
          <source>The corresponding Erlang assignments:</source>
          <target state="translated">対応するErlangの割り当て。</target>
        </trans-unit>
        <trans-unit id="f464085c70da2d1c15ec4fc3d649680a6fc01752" translate="yes" xml:space="preserve">
          <source>The corresponding Mnesia table is specified as follows:</source>
          <target state="translated">対応するムネシアテーブルは以下のように指定されています。</target>
        </trans-unit>
        <trans-unit id="355cfe7dcddd0f236158f7c90d39becfb4d1ea88" translate="yes" xml:space="preserve">
          <source>The corresponding SNMP table would have three columns: &lt;code&gt;department&lt;/code&gt;, &lt;code&gt;name&lt;/code&gt;, and &lt;code&gt;telno&lt;/code&gt;.</source>
          <target state="translated">対応するSNMPテーブルには、 &lt;code&gt;department&lt;/code&gt; 、 &lt;code&gt;name&lt;/code&gt; 、および &lt;code&gt;telno&lt;/code&gt; の 3つの列があります。</target>
        </trans-unit>
        <trans-unit id="4ba81bc06294c512d15b4e936f20c56b7b7af738" translate="yes" xml:space="preserve">
          <source>The corresponding library callback was unsuccessful.</source>
          <target state="translated">対応するライブラリ・コールバックは失敗しました。</target>
        </trans-unit>
        <trans-unit id="3ed401667a17ba645dc4af42fafc330362e9b09e" translate="yes" xml:space="preserve">
          <source>The corresponding process or port is traced. The process or port may be a remote process or port (on another Erlang node). The node must be in the list of traced nodes (see &lt;code&gt;&lt;a href=&quot;#n-1&quot;&gt;n/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#tracer-3&quot;&gt;tracer/3&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">対応するプロセスまたはポートがトレースされます。プロセスまたはポートは、リモートプロセスまたはポート（別のErlangノード上）である場合があります。ノードは、トレースされるノードのリストに含まれている必要があります（ &lt;code&gt;&lt;a href=&quot;#n-1&quot;&gt;n/1&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;#tracer-3&quot;&gt;tracer/3&lt;/a&gt;&lt;/code&gt; を参照）。</target>
        </trans-unit>
        <trans-unit id="7fb4487b624fe2c0e433c8d91bb58ba0e2b99b60" translate="yes" xml:space="preserve">
          <source>The corresponding table is &lt;code&gt;snmpCommunityTable&lt;/code&gt; in the SNMP-COMMUNITY-MIB.</source>
          <target state="translated">対応するテーブルは、SNMP-COMMUNITY-MIBの &lt;code&gt;snmpCommunityTable&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="536e0673fdce81c6dcbd3b335e2956e57d01fa8e" translate="yes" xml:space="preserve">
          <source>The corresponding table is &lt;code&gt;snmpNotifyTable&lt;/code&gt; in the SNMP-NOTIFICATION-MIB.</source>
          <target state="translated">対応するテーブルは、SNMP-NOTIFICATION-MIBの &lt;code&gt;snmpNotifyTable&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="6418aba8dde22da1e13b2bb9b3980fe5619feec0" translate="yes" xml:space="preserve">
          <source>The corresponding table is &lt;code&gt;snmpTargetParamsTable&lt;/code&gt; in the SNMP-TARGET-MIB.</source>
          <target state="translated">対応するテーブルは、SNMP-TARGET-MIBの &lt;code&gt;snmpTargetParamsTable&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="ffadaae2726db08a3b84abd6faf037b185f11f98" translate="yes" xml:space="preserve">
          <source>The corresponding table is &lt;code&gt;usmUserTable&lt;/code&gt; in the SNMP-USER-BASED-SM-MIB.</source>
          <target state="translated">対応するテーブルは、SNMP-USER-BASED-SM-MIBの &lt;code&gt;usmUserTable&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="7dfdea70a637914fff122f7c22e23e4ca4a56c8f" translate="yes" xml:space="preserve">
          <source>The corresponding tables are &lt;code&gt;snmpTargetAddrTable&lt;/code&gt; in the SNMP-TARGET-MIB and &lt;code&gt;snmpTargetAddrExtTable&lt;/code&gt; in the SNMP-COMMUNITY-MIB.</source>
          <target state="translated">対応テーブルは、 &lt;code&gt;snmpTargetAddrTable&lt;/code&gt; SNMP-TARGET-MIBとに &lt;code&gt;snmpTargetAddrExtTable&lt;/code&gt; SNMPコミュニティ-MIBです。</target>
        </trans-unit>
        <trans-unit id="12ecd355d2a9f8a115a05cf588ffb85e072514b8" translate="yes" xml:space="preserve">
          <source>The corresponding tables are &lt;code&gt;vacmSecurityToGroupTable&lt;/code&gt;, &lt;code&gt;vacmAccessTable&lt;/code&gt; and &lt;code&gt;vacmViewTreeFamilyTable&lt;/code&gt; in the SNMP-VIEW-BASED-ACM-MIB.</source>
          <target state="translated">対応するテーブルは、SNMP-VIEW-BASED-ACM-MIBの &lt;code&gt;vacmSecurityToGroupTable&lt;/code&gt; 、 &lt;code&gt;vacmAccessTable&lt;/code&gt; 、および &lt;code&gt;vacmViewTreeFamilyTable&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="09299475ac2ec70dc802979c73301c27a76fa68a" translate="yes" xml:space="preserve">
          <source>The corresponding values were as follows:</source>
          <target state="translated">対応する値は以下の通りであった。</target>
        </trans-unit>
        <trans-unit id="270bee1ebec250d3d9f95f9db65ee55f7e7e584a" translate="yes" xml:space="preserve">
          <source>The cost is substantial: every returned answer is stored in an ETS table. Before returning an answer, it is looked up in the ETS table to check if it has already been returned. Without the &lt;code&gt;unique&lt;/code&gt; option, all answers to &lt;code&gt;QH1&lt;/code&gt; would be returned followed by all answers to &lt;code&gt;QH2&lt;/code&gt;. The &lt;code&gt;unique&lt;/code&gt; option keeps the order between the remaining answers.</source>
          <target state="translated">コストはかなり高くなります。返されるすべての回答はETSテーブルに格納されます。回答を返す前に、それがETSテーブルで検索され、すでに返されているかどうかが確認されます。 &lt;code&gt;unique&lt;/code&gt; オプションがない場合、 &lt;code&gt;QH1&lt;/code&gt; に対するすべての回答が返され、その後に &lt;code&gt;QH2&lt;/code&gt; に対するすべての回答が返されます。 &lt;code&gt;unique&lt;/code&gt; オプションが残りの回答間の順序を保持します。</target>
        </trans-unit>
        <trans-unit id="949377933f7f31ae27260e61d2614522203d38cb" translate="yes" xml:space="preserve">
          <source>The counter is per listening port. Thus, if two daemons are started, one with &lt;code&gt;{max_sessions,N}&lt;/code&gt; and the other with &lt;code&gt;{max_sessions,M}&lt;/code&gt;, in total &lt;code&gt;N+M&lt;/code&gt; connections are accepted for the whole &lt;code&gt;ssh&lt;/code&gt; application.</source>
          <target state="translated">カウンタはリスニングポートごとです。したがって、 &lt;code&gt;{max_sessions,N}&lt;/code&gt; を使用するデーモンと &lt;code&gt;{max_sessions,M}&lt;/code&gt; を使用するデーモンの2つのデーモンが開始されると、 &lt;code&gt;ssh&lt;/code&gt; アプリケーション全体で合計 &lt;code&gt;N+M&lt;/code&gt; の接続が受け入れられます。</target>
        </trans-unit>
        <trans-unit id="672049e9dcd3a0014488ab809e18dd017dc67fc3" translate="yes" xml:space="preserve">
          <source>The crash report contains the previously stored information, such as ancestors and initial function, the termination reason, and information about other processes that terminate as a result of this process terminating.</source>
          <target state="translated">クラッシュレポートには、先祖や初期機能、終了理由、このプロセスが終了した結果終了した他のプロセスの情報など、以前に保存されていた情報が含まれています。</target>
        </trans-unit>
        <trans-unit id="e9528cde8205383b9d47742f84a963524c2a4c48" translate="yes" xml:space="preserve">
          <source>The crashed node is distributed but has no references to other nodes.</source>
          <target state="translated">クラッシュしたノードは分散されていますが、他のノードへの参照はありません。</target>
        </trans-unit>
        <trans-unit id="7beaf4ed3a100b4464262b486f549894f0ca1c0e" translate="yes" xml:space="preserve">
          <source>The crashed node is not distributed.</source>
          <target state="translated">クラッシュしたノードは分散されていません。</target>
        </trans-unit>
        <trans-unit id="ce14bb9518e3053298709463f31e4be173e33cd1" translate="yes" xml:space="preserve">
          <source>The created digraph has the same type as &lt;code&gt;Digraph&lt;/code&gt;. All vertices and edges have the default &lt;code&gt;&lt;a href=&quot;#label&quot;&gt;label&lt;/a&gt;&lt;/code&gt;&lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">作成された &lt;code&gt;Digraph&lt;/code&gt; は、Digraphと同じタイプです。すべての頂点とエッジにはデフォルトの &lt;code&gt;&lt;a href=&quot;#label&quot;&gt;label&lt;/a&gt;&lt;/code&gt; &lt;code&gt;[]&lt;/code&gt; があります。</target>
        </trans-unit>
        <trans-unit id="9c87493c7d1e0ec2480a156b7c0c0a9bef2ce5f3" translate="yes" xml:space="preserve">
          <source>The created process should provide callbacks and other information needed for the handshake in a &lt;code&gt;&lt;a href=&quot;#hs_data_record&quot;&gt;#hs_data{}&lt;/a&gt;&lt;/code&gt; record and call &lt;code&gt;dist_util:handshake_other_started(HsData)&lt;/code&gt; with this record.</source>
          <target state="translated">作成されたプロセスは、 &lt;code&gt;&lt;a href=&quot;#hs_data_record&quot;&gt;#hs_data{}&lt;/a&gt;&lt;/code&gt; レコードでハンドシェイクに必要なコールバックとその他の情報を提供し、このレコードで &lt;code&gt;dist_util:handshake_other_started(HsData)&lt;/code&gt; を呼び出す必要があります。</target>
        </trans-unit>
        <trans-unit id="e43aa2bf5d37514d385457e53e7dee018f509f4d" translate="yes" xml:space="preserve">
          <source>The created process should provide callbacks and other information needed for the handshake in a &lt;code&gt;&lt;a href=&quot;#hs_data_record&quot;&gt;#hs_data{}&lt;/a&gt;&lt;/code&gt; record and call &lt;code&gt;dist_util:handshake_we_started(HsData)&lt;/code&gt; with this record.</source>
          <target state="translated">作成されたプロセスは、 &lt;code&gt;&lt;a href=&quot;#hs_data_record&quot;&gt;#hs_data{}&lt;/a&gt;&lt;/code&gt; レコードでハンドシェイクに必要なコールバックとその他の情報を提供し、このレコードで &lt;code&gt;dist_util:handshake_we_started(HsData)&lt;/code&gt; を呼び出す必要があります。</target>
        </trans-unit>
        <trans-unit id="c10988c8597611573efffc7c6d796d8de4ec9158" translate="yes" xml:space="preserve">
          <source>The created supervisor process calls &lt;code&gt;Module:init/1&lt;/code&gt; to find out about restart strategy, maximum restart intensity, and child processes. To ensure a synchronized startup procedure, &lt;code&gt;start_link/2,3&lt;/code&gt; does not return until &lt;code&gt;Module:init/1&lt;/code&gt; has returned and all child processes have been started.</source>
          <target state="translated">作成されたスーパーバイザプロセスは、 &lt;code&gt;Module:init/1&lt;/code&gt; を呼び出して、再起動戦略、最大再起動の強度、および子プロセスについて調べます。起動手順の同期を確実にするために、 &lt;code&gt;start_link/2,3&lt;/code&gt; は、 &lt;code&gt;Module:init/1&lt;/code&gt; が返されてすべての子プロセスが開始されるまで戻りません。</target>
        </trans-unit>
        <trans-unit id="39edf1d66d588998727b714263ec502579dd9e7b" translate="yes" xml:space="preserve">
          <source>The created thread terminates either when &lt;code&gt;func&lt;/code&gt; returns or if &lt;code&gt;&lt;a href=&quot;#erl_drv_thread_exit&quot;&gt;erl_drv_thread_exit&lt;/a&gt;&lt;/code&gt; is called by the thread. The exit value of the thread is either returned from &lt;code&gt;func&lt;/code&gt; or passed as argument to &lt;code&gt;&lt;a href=&quot;#erl_drv_thread_exit&quot;&gt;erl_drv_thread_exit&lt;/a&gt;&lt;/code&gt;. The driver creating the thread is responsible for joining the thread, through &lt;code&gt;&lt;a href=&quot;#erl_drv_thread_join&quot;&gt;erl_drv_thread_join&lt;/a&gt;&lt;/code&gt;, before the driver is unloaded. &quot;Detached&quot; threads cannot be created, that is, threads that do not need to be joined.</source>
          <target state="translated">作成されたスレッドは、 &lt;code&gt;func&lt;/code&gt; が戻るか、 &lt;code&gt;&lt;a href=&quot;#erl_drv_thread_exit&quot;&gt;erl_drv_thread_exit&lt;/a&gt;&lt;/code&gt; がスレッドによって呼び出されると終了します。スレッドの終了値は、 &lt;code&gt;func&lt;/code&gt; から返されるか、引数として &lt;code&gt;&lt;a href=&quot;#erl_drv_thread_exit&quot;&gt;erl_drv_thread_exit&lt;/a&gt;&lt;/code&gt; に渡されます。スレッドを作成するドライバーは、ドライバーがアンロードされる前に、 &lt;code&gt;&lt;a href=&quot;#erl_drv_thread_join&quot;&gt;erl_drv_thread_join&lt;/a&gt;&lt;/code&gt; を介してスレッドに参加する必要があります。「切り離された」スレッドは作成できません。つまり、結合する必要がないスレッドです。</target>
        </trans-unit>
        <trans-unit id="2caf2e3a9d3cd22055ea221541023c0a7f9e5f06" translate="yes" xml:space="preserve">
          <source>The creation number for a listen socket, which is calculated as (the value found in the lock-file + 1) rem 4. This creation value is also written back into the lock file, so that the next invocation of the emulator finds our value in the file.</source>
          <target state="translated">リッスンソケットの作成番号は、(ロックファイルの値+1)rem 4 で計算されます。この作成値はロックファイルにも書き戻され、エミュレータの次の呼び出しでファイル内の値が見つかるようになっています。</target>
        </trans-unit>
        <trans-unit id="adcdb05ae9295c817de82d7381820b023af67f91" translate="yes" xml:space="preserve">
          <source>The creation number in pid &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">pid &lt;code&gt;t&lt;/code&gt; の作成番号。</target>
        </trans-unit>
        <trans-unit id="83f64ba9b5d10763eb9a59dc112c16b79857dd73" translate="yes" xml:space="preserve">
          <source>The creation number in port &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">ポート &lt;code&gt;t&lt;/code&gt; の作成番号。</target>
        </trans-unit>
        <trans-unit id="50c7d8a3f3ea2d88f57c174b641c9f8441bf8c61" translate="yes" xml:space="preserve">
          <source>The creation number in ref &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">ref &lt;code&gt;t&lt;/code&gt; の作成番号。</target>
        </trans-unit>
        <trans-unit id="1597c6b33ee04607a4ecaec944fa0178d3d2dc29" translate="yes" xml:space="preserve">
          <source>The creation of the specification for a target system is performed in two steps. In the first step a complete specification is generated. It will likely contain much more files than you are interested in in your customized target system. In the second step the specification will be filtered according to your filters. There you have the ability to specify filters per application as well as system wide filters. You can also select a &lt;code&gt;profile&lt;/code&gt; for your system. Depending on the &lt;code&gt;profile&lt;/code&gt;, different default filters will be used. There are three different profiles to choose from: &lt;code&gt;development&lt;/code&gt;, &lt;code&gt;embedded&lt;/code&gt; and &lt;code&gt;standalone&lt;/code&gt;. &lt;code&gt;development&lt;/code&gt; is default. The parameters that are affected by the &lt;code&gt;profile&lt;/code&gt; are: &lt;code&gt;incl_sys_filters&lt;/code&gt;, &lt;code&gt;excl_sys_filters&lt;/code&gt;, &lt;code&gt;incl_app_filters&lt;/code&gt; and &lt;code&gt;excl_app_filters&lt;/code&gt;.</source>
          <target state="translated">ターゲットシステムの仕様の作成は、2つのステップで実行されます。最初のステップで、完全な仕様が生成されます。カスタマイズしたターゲットシステムに必要なファイルよりもはるかに多くのファイルが含まれている可能性があります。 2番目のステップでは、フィルターに従って仕様がフィルターされます。そこでは、アプリケーションごとのフィルターやシステム全体のフィルターを指定することができます。システムの &lt;code&gt;profile&lt;/code&gt; を選択することもできます。 &lt;code&gt;profile&lt;/code&gt; に応じて、異なるデフォルトのフィルターが使用されます。 3つの異なるプロファイルから選択できます： &lt;code&gt;development&lt;/code&gt; 、 &lt;code&gt;embedded&lt;/code&gt; 、 &lt;code&gt;standalone&lt;/code&gt; 。 &lt;code&gt;development&lt;/code&gt; はデフォルトです。の影響を受けるパラメータ &lt;code&gt;profile&lt;/code&gt; は、 &lt;code&gt;incl_sys_filters&lt;/code&gt; 、 &lt;code&gt;excl_sys_filters&lt;/code&gt; 、 &lt;code&gt;incl_app_filters&lt;/code&gt; および &lt;code&gt;excl_app_filters&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="e0455f1d04df5058ea9aa40b1a076812ef2243c2" translate="yes" xml:space="preserve">
          <source>The creation time for the dump</source>
          <target state="translated">ダンプの作成時間</target>
        </trans-unit>
        <trans-unit id="65280108d9a3568933bcafdbf482cccdf0bd7634" translate="yes" xml:space="preserve">
          <source>The cross cover mechanism allows cover analysis of modules across multiple tests. It is useful if some code, for example, a library module, is used by many different tests and the accumulated cover result is desirable.</source>
          <target state="translated">クロスカバー機構は、複数のテストにまたがるモジュールのカバー解析を可能にします。これは、いくつかのコード、例えばライブラリモジュールが多くの異なるテストで使用され、蓄積されたカバー結果が望ましい場合に便利です。</target>
        </trans-unit>
        <trans-unit id="b20f15741df0176d3ffd68b64d6a68cc69323d01" translate="yes" xml:space="preserve">
          <source>The crypto application supports using OpenSSL in FIPS mode. In this scenario only the validated algorithms provided by the Object Module are accessible, other algorithms usually available in OpenSSL (like md5) or implemented in the Erlang code (like SRP) are disabled.</source>
          <target state="translated">暗号アプリケーションはFIPSモードでのOpenSSLの使用をサポートしています。このシナリオでは、オブジェクトモジュールで提供されている有効なアルゴリズムのみがアクセス可能で、その他のアルゴリズムは通常OpenSSLで利用可能なもの(md5など)やErlangコードで実装されているもの(SRPなど)は無効になっています。</target>
        </trans-unit>
        <trans-unit id="67aa64b8718cdca92f0e4f9624ec881b790bb44a" translate="yes" xml:space="preserve">
          <source>The cryptolib OTP is linked with, usally the one the OS uses, probably OpenSSL,</source>
          <target state="translated">cryptolibのOTPは、通常はOSが使用しているもの、おそらくOpenSSLとリンクしています。</target>
        </trans-unit>
        <trans-unit id="0f0da38521cbe8e331fa3581916f1bfca4dc26d7" translate="yes" xml:space="preserve">
          <source>The current behavior can be viewed as two combined operations: asynchronously send a &quot;demonitor signal&quot; to the monitored entity and ignore any future results of the monitor.</source>
          <target state="translated">現在の動作は、2つの操作を組み合わせたものと見ることができます:非同期的に監視対象のエンティティに「デモニター・シグナル」を送信し、監視対象の将来の結果を無視します。</target>
        </trans-unit>
        <trans-unit id="3c2e4d473b72e94c41373ad9e09ba22c294ebb64" translate="yes" xml:space="preserve">
          <source>The current behavior can be viewed as two combined operations: asynchronously send an &quot;unlink signal&quot; to the linked entity and ignore any future results of the link.</source>
          <target state="translated">現在の動作は、2つの操作を組み合わせたものと見ることができます。非同期的にリンクされたエンティティに「リンク解除シグナル」を送信し、リンクの将来の結果を無視するというものです。</target>
        </trans-unit>
        <trans-unit id="d5b1d2a40e48d00196c6b21b7ac5dc93cf3228c9" translate="yes" xml:space="preserve">
          <source>The current function of the process. These fields do not always exist.</source>
          <target state="translated">プロセスの現在の機能。これらのフィールドは常に存在するとは限りません。</target>
        </trans-unit>
        <trans-unit id="976f361d5fa6f84f4966eb0b28babd0491898a1f" translate="yes" xml:space="preserve">
          <source>The current implementation assumes the requests to the same host, port combination will use the same socket options.</source>
          <target state="translated">現在の実装では、同じホスト、ポートの組み合わせへのリクエストは同じソケットオプションを使用することを前提としています。</target>
        </trans-unit>
        <trans-unit id="01444d008abb77ac03ebfb5697a017f621eb7172" translate="yes" xml:space="preserve">
          <source>The current implementation of &lt;code&gt;erts_alloc_config&lt;/code&gt; concentrate on configuration of multi-block carriers. Information gathered when a runtime scenario is saved is mainly current and maximum use of multi-block carriers. If a parameter that change the use of multi-block carriers is changed, a previously generated configuration is invalid and &lt;code&gt;erts_alloc_config&lt;/code&gt; needs to be run again. It is mainly the single block carrier threshold that effects the use of multi-block carriers, but other single-block carrier parameters might as well. If another value of a single block carrier parameter than the default is desired, use the desired value when running &lt;code&gt;erts_alloc_config&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;erts_alloc_config&lt;/code&gt; の現在の実装は、マルチブロックキャリアの構成に集中しています。ランタイムシナリオが保存されるときに収集される情報は、主にマルチブロックキャリアの現在の最大使用量です。マルチブロックキャリアの使用を変更するパラメーターが変更された場合、以前に生成された構成は無効であり、 &lt;code&gt;erts_alloc_config&lt;/code&gt; を再度実行する必要があります。マルチブロックキャリアの使用に影響を与えるのは、主にシングルブロックキャリアのしきい値ですが、他のシングルブロックキャリアパラメータも同様に影響する可能性があります。デフォルト以外の単一ブロックキャリアパラメーターの別の値が必要な場合は、 &lt;code&gt;erts_alloc_config&lt;/code&gt; を実行するときに必要な値を使用してください。</target>
        </trans-unit>
        <trans-unit id="b881e02c8b7eb97ec891648e528239530b927d31" translate="yes" xml:space="preserve">
          <source>The current implementation of Erlang does not care if the connection to the EPMD is broken.</source>
          <target state="translated">現在のErlangの実装ではEPMDへの接続が切れても気にしません。</target>
        </trans-unit>
        <trans-unit id="906db1d57b72f269a5be2b6efa0e34d3a4f40e71" translate="yes" xml:space="preserve">
          <source>The current implementation spawns a port programm written in C that utilizes the actual ODBC driver. There is a default timeout of 5000 msec for this port programm to connect to the Erlang ODBC application. This timeout can be changed by setting an application specific environment variable 'port_timeout' with the number of milliseconds for the ODBC application. E.g.: [{odbc, [{port_timeout, 60000}]}] to set it to 60 seconds.</source>
          <target state="translated">現在の実装では、実際のODBCドライバを利用したCで書かれたポートプログラムを生成しています。このポートプログラムがErlang ODBCアプリケーションに接続するためのデフォルトのタイムアウトは5000ミリ秒です。このタイムアウトはアプリケーション固有の環境変数'port_timeout'にODBCアプリケーションのミリ秒数を設定することで変更できます。例えば以下のようになります。[{odbc,[{port_timeout,60000}]}]で60秒に設定します。</target>
        </trans-unit>
        <trans-unit id="4d365424f69367126413adcf57829b464b5f9add" translate="yes" xml:space="preserve">
          <source>The current instruction pointer. This is only of interest for runtime system developers. The function into which the program counter points is the current function of the process.</source>
          <target state="translated">現在の命令ポインタ。これは、ランタイムシステムの開発者にとってのみ関心のあることです。プログラムカウンタが指す関数は、プロセスの現在の関数です。</target>
        </trans-unit>
        <trans-unit id="0ee5778fbc1ab8fe240410952dd5b9eaf045d059" translate="yes" xml:space="preserve">
          <source>The current line number.</source>
          <target state="translated">現在の行番号です。</target>
        </trans-unit>
        <trans-unit id="67653b4ba83e7d00b28af91f8d3fe0dae7dfae29" translate="yes" xml:space="preserve">
          <source>The current local working directory (compare &lt;code&gt;lpwd/1&lt;/code&gt;) is set to the value reported by &lt;code&gt;file:get_cwd/1&lt;/code&gt;, the wanted local directory.</source>
          <target state="translated">現在のローカル作業ディレクトリ（ &lt;code&gt;lpwd/1&lt;/code&gt; と比較）は、必要なローカルディレクトリである &lt;code&gt;file:get_cwd/1&lt;/code&gt; によって報告される値に設定されます。</target>
        </trans-unit>
        <trans-unit id="0bd1444e43ba871d9585120022333d4590131f8a" translate="yes" xml:space="preserve">
          <source>The current options are:</source>
          <target state="translated">現在の選択肢は</target>
        </trans-unit>
        <trans-unit id="51b93308e4fc131191ae4908faed86620396f4d9" translate="yes" xml:space="preserve">
          <source>The current position of the file is undefined after the operation.</source>
          <target state="translated">操作後のファイルの現在位置は未定義です。</target>
        </trans-unit>
        <trans-unit id="a23e8329113f0ad4178af5cd91d27561b0a29cbd" translate="yes" xml:space="preserve">
          <source>The current reference count after the decrement has been performed is returned.</source>
          <target state="translated">デクリメントが行われた後の現在の参照カウントを返します。</target>
        </trans-unit>
        <trans-unit id="24502690d2f3bb086d825806372b93e14c48a509" translate="yes" xml:space="preserve">
          <source>The current reference count after the increment has been performed is returned.</source>
          <target state="translated">インクリメントが実行された後の現在の参照カウントを返します。</target>
        </trans-unit>
        <trans-unit id="9fd7feb388311de9e1a9de0daaa94dc63a945932" translate="yes" xml:space="preserve">
          <source>The current status of the &lt;code&gt;init&lt;/code&gt; process can be inspected. During system startup (initialization), &lt;code&gt;InternalStatus&lt;/code&gt; is &lt;code&gt;starting&lt;/code&gt;, and &lt;code&gt;ProvidedStatus&lt;/code&gt; indicates how far the boot script has been interpreted. Each &lt;code&gt;{progress, Info}&lt;/code&gt; term interpreted in the boot script affects &lt;code&gt;ProvidedStatus&lt;/code&gt;, that is, &lt;code&gt;ProvidedStatus&lt;/code&gt; gets the value of &lt;code&gt;Info&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;init&lt;/code&gt; プロセスの現在のステータスを検査できます。システムの起動（初期化）中、 &lt;code&gt;InternalStatus&lt;/code&gt; は &lt;code&gt;starting&lt;/code&gt; であり、 &lt;code&gt;ProvidedStatus&lt;/code&gt; はブートスクリプトがどこまで解釈されたかを示します。ブートスクリプトで解釈される各 &lt;code&gt;{progress, Info}&lt;/code&gt; 用語は &lt;code&gt;ProvidedStatus&lt;/code&gt; に影響します。つまり、 &lt;code&gt;ProvidedStatus&lt;/code&gt; は &lt;code&gt;Info&lt;/code&gt; の値を取得します。</target>
        </trans-unit>
        <trans-unit id="b80e18839956d4be32e5bd88643c826f791ac807" translate="yes" xml:space="preserve">
          <source>The current status, one of the following:</source>
          <target state="translated">現在の状態、以下のいずれかです。</target>
        </trans-unit>
        <trans-unit id="c7113183a7426c44fe409b00b899d8a41fc5814b" translate="yes" xml:space="preserve">
          <source>The current system access to the file.</source>
          <target state="translated">ファイルへの現在のシステムアクセス。</target>
        </trans-unit>
        <trans-unit id="8ada96b90a0d9236a710ef755016c1b7cca9e74d" translate="yes" xml:space="preserve">
          <source>The current token of a process is set in one of the following two ways:</source>
          <target state="translated">プロセスのカレントトークンは、以下の2つの方法のいずれかで設定されます。</target>
        </trans-unit>
        <trans-unit id="283b878d1d463389e9688a4d3aa6791beee18572" translate="yes" xml:space="preserve">
          <source>The current type/state of the port, which can be one of the values declared above.</source>
          <target state="translated">ポートの現在のタイプ/状態で、上記で宣言された値のいずれかになります。</target>
        </trans-unit>
        <trans-unit id="d59825d9fb6ddec0b7e1b9ca60e8a4611098dbe2" translate="yes" xml:space="preserve">
          <source>The current version of &lt;code&gt;Mnesia&lt;/code&gt; does not require that the name of the table is the same as the record name, see &lt;code&gt;&lt;a href=&quot;mnesia_chap4#recordnames_tablenames&quot;&gt;Record Names versus Table Names.&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Mnesia&lt;/code&gt; の現在のバージョンでは、テーブルの名前がレコード名と同じである必要はありません &lt;code&gt;&lt;a href=&quot;mnesia_chap4#recordnames_tablenames&quot;&gt;Record Names versus Table Names.&lt;/a&gt;&lt;/code&gt; 参照してください。。</target>
        </trans-unit>
        <trans-unit id="8c67d44d5188c140bb3bee7f987dfb33d7ef9f83" translate="yes" xml:space="preserve">
          <source>The current working directory</source>
          <target state="translated">現在の作業ディレクトリ</target>
        </trans-unit>
        <trans-unit id="61d4a882ed6c30c03ae65ca2d8cd5ad27f2a5741" translate="yes" xml:space="preserve">
          <source>The current working directory, &lt;code&gt;&quot;.&quot;&lt;/code&gt;, is not included in the code path when running the compiler. This to avoid loading Beam files from the current working directory that could potentially be in conflict with the compiler or the Erlang/OTP system used by the compiler.</source>
          <target state="translated">現在の作業ディレクトリ &lt;code&gt;&quot;.&quot;&lt;/code&gt; 、コンパイラの実行時にコードパスに含まれません。これは、コンパイラーまたはコンパイラーが使用するErlang / OTPシステムと競合する可能性がある現在の作業ディレクトリーからBeamファイルをロードすることを回避するためです。</target>
        </trans-unit>
        <trans-unit id="2fa5b9ac3977e02e3cf7d97b73ce85358c04959d" translate="yes" xml:space="preserve">
          <source>The currently executing process (that is, the sender) is not alive.</source>
          <target state="translated">現在実行中のプロセス(つまり送信者)が生きていない。</target>
        </trans-unit>
        <trans-unit id="953e09eadeb4be83fa11df49bf70c92f526cc8f1" translate="yes" xml:space="preserve">
          <source>The daemon is started automatically by command &lt;code&gt;&lt;a href=&quot;erl&quot;&gt;erl(1)&lt;/a&gt;&lt;/code&gt; if the node is to be distributed and no running instance is present. If automatically launched environment variables must be used to change the behavior of the daemon; see section &lt;code&gt;&lt;a href=&quot;#environment_variables&quot;&gt;Environment Variables&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">ノードが分散され、実行中のインスタンスが存在しない場合、デーモンはコマンド &lt;code&gt;&lt;a href=&quot;erl&quot;&gt;erl(1)&lt;/a&gt;&lt;/code&gt; によって自動的に開始されます。デーモンの動作を変更するには、自動的に起動する環境変数を使用する必要がある場合。セクション &lt;code&gt;&lt;a href=&quot;#environment_variables&quot;&gt;Environment Variables&lt;/a&gt;&lt;/code&gt; 参照してください。</target>
        </trans-unit>
        <trans-unit id="0d21e1220084b94119a9a3ad063df2a21e482723" translate="yes" xml:space="preserve">
          <source>The data bytes of the AVP.</source>
          <target state="translated">AVPのデータバイト。</target>
        </trans-unit>
        <trans-unit id="f18388ef7ec4c10925540637ae1909f34a929370" translate="yes" xml:space="preserve">
          <source>The data contains errors.</source>
          <target state="translated">データにはエラーが含まれています。</target>
        </trans-unit>
        <trans-unit id="078b2a841f3b60a68b21c7cb12cdb8e09a9dd362" translate="yes" xml:space="preserve">
          <source>The data delivery order can be relaxed by disabling features that require strict ordering. This is done by passing the &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#dflags&quot;&gt;distribution flags&lt;/a&gt;&lt;/code&gt; returned by &lt;code&gt;dist_util:strict_order_flags/0&lt;/code&gt; in the &lt;code&gt;&lt;a href=&quot;alt_dist#hs_data_reject_flags&quot;&gt;reject_flags&lt;/a&gt;&lt;/code&gt; field of the &lt;code&gt;&lt;a href=&quot;#hs_data_record&quot;&gt;#hs_data{}&lt;/a&gt;&lt;/code&gt; record used when setting up the connection. When relaxed ordering is used, only the order of signals with the same sender/receiver pair has to be preserved. However, note that disabling the features that require strict ordering may have a negative impact on performance, throughput, and/or latency.</source>
          <target state="translated">厳密な順序付けが必要な機能を無効にすることで、データ配信の順序を緩和できます。これは、通過させることによって行われ &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#dflags&quot;&gt;distribution flags&lt;/a&gt;&lt;/code&gt; によって返さ &lt;code&gt;dist_util:strict_order_flags/0&lt;/code&gt; に &lt;code&gt;&lt;a href=&quot;alt_dist#hs_data_reject_flags&quot;&gt;reject_flags&lt;/a&gt;&lt;/code&gt; のフィールド &lt;code&gt;&lt;a href=&quot;#hs_data_record&quot;&gt;#hs_data{}&lt;/a&gt;&lt;/code&gt; コネクションを設定する際にレコードが使用しました。緩やかな順序付けを使用する場合、同じ送信側/受信側のペアを持つ信号の順序のみを保持する必要があります。ただし、厳密な順序付けを必要とする機能を無効にすると、パフォーマンス、スループット、および/または待機時間に悪影響が出る可能性があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="f7a26a04ef322bb19505a5c1dc8d45f5e01e5f3f" translate="yes" xml:space="preserve">
          <source>The data formats defined in sections 4.2 (&quot;Basic AVP Data Formats&quot;) and 4.3 (&quot;Derived AVP Data Formats&quot;) of RFC 6733 are encoded as values of the types defined here. Values are passed to &lt;code&gt;&lt;a href=&quot;diameter#call-4&quot;&gt;diameter:call/4&lt;/a&gt;&lt;/code&gt; in a request record when sending a request, returned in a resulting answer record and passed to a &lt;code&gt;handle_request/3&lt;/code&gt; callback upon reception of an incoming request.</source>
          <target state="translated">RFC 6733のセクション4.2（「基本AVPデータ形式」）および4.3（「派生AVPデータ形式」）で定義されたデータ形式は、ここで定義されたタイプの値としてエンコードされます。値は、リクエストを送信するときにリクエストレコードの &lt;code&gt;&lt;a href=&quot;diameter#call-4&quot;&gt;diameter:call/4&lt;/a&gt;&lt;/code&gt; に渡され、結果のアンサーレコードで返され、着信リクエストの受信時に &lt;code&gt;handle_request/3&lt;/code&gt; コールバックに渡されます。</target>
        </trans-unit>
        <trans-unit id="fdf833224017bb981586f311e5704bede95ecd92" translate="yes" xml:space="preserve">
          <source>The data in the boot script, fetched from the new application resource file &lt;code&gt;App.app&lt;/code&gt;</source>
          <target state="translated">新しいアプリケーションリソースファイル &lt;code&gt;App.app&lt;/code&gt; からフェッチされたブートスクリプト内のデータ</target>
        </trans-unit>
        <trans-unit id="bf8c73b58d26cdb1cd37eb82749dddb7b4d25b8e" translate="yes" xml:space="preserve">
          <source>The data in the header is sent as a list and the binary as an Erlang binary in the tail of the list.</source>
          <target state="translated">ヘッダのデータはリストとして送られ、リストの末尾にはErlangのバイナリとして送られます。</target>
        </trans-unit>
        <trans-unit id="9e8a427227bcde27fb34708c1f8037df0476db96" translate="yes" xml:space="preserve">
          <source>The data is queued in the port owner process' message queue. Notice that this does not yield to the emulator (as the driver and the emulator run in the same thread).</source>
          <target state="translated">データはポートオーナープロセスのメッセージキューにキューイングされます。これはエミュレータには影響しないことに注意してください (ドライバとエミュレータは同じスレッドで動作しているため)。</target>
        </trans-unit>
        <trans-unit id="5209f4c8cd33cb9b06c7cafb6cfe1d7ba8e19dd5" translate="yes" xml:space="preserve">
          <source>The data is thus at &lt;code&gt;buf[*index]&lt;/code&gt; when an &lt;code&gt;ei&lt;/code&gt; function is called.</source>
          <target state="translated">したがって、データは、 &lt;code&gt;ei&lt;/code&gt; 関数が呼び出されたときに &lt;code&gt;buf[*index]&lt;/code&gt; にあります。</target>
        </trans-unit>
        <trans-unit id="2a0aaa71e50e0fe09624f658b5194caa4fc82ffa" translate="yes" xml:space="preserve">
          <source>The data model employed by &lt;code&gt;Mnesia&lt;/code&gt; is an extended relational data model. Data is organized as a set of tables and relations between different data records can be modeled as more tables describing the relationships. Each table contains instances of Erlang records. The records are represented as Erlang tuples.</source>
          <target state="translated">&lt;code&gt;Mnesia&lt;/code&gt; で採用されているデータモデルは、拡張リレーショナルデータモデルです。データは一連のテーブルとして編成され、異なるデータレコード間の関係は、関係を説明するより多くのテーブルとしてモデル化できます。各テーブルには、Erlangレコードのインスタンスが含まれています。レコードはErlangタプルとして表されます。</target>
        </trans-unit>
        <trans-unit id="bcffc5bb38e63b17337f4be90db30aa76b246a80" translate="yes" xml:space="preserve">
          <source>The data produced by the lock counters will give an estimate on how well the runtime system will behave from a parallelizable view point for the scenarios tested. This tool was mainly developed to help Erlang runtime developers iron out potential and generic bottlenecks.</source>
          <target state="translated">ロックカウンターによって生成されたデータは、テストされたシナリオに対してランタイムシステムが並列化可能な観点からどの程度の動作をするかを推定してくれます。このツールは主にErlangランタイム開発者が潜在的なボトルネックや一般的なボトルネックを解決するために開発されました。</target>
        </trans-unit>
        <trans-unit id="2d27f50b0cd05524a7fd478c731d913e31e93736" translate="yes" xml:space="preserve">
          <source>The data representing a queue as used by this module is to be regarded as opaque by other modules. Any code assuming knowledge of the format is running on thin ice.</source>
          <target state="translated">このモジュールで使用されるキューを表すデータは、他のモジュールでは不透明とみなされます。フォーマットの知識を前提としたコードは、薄氷の上を走っています。</target>
        </trans-unit>
        <trans-unit id="966785b6ae629e19c8bed0b0d3e6ef6f991ec06e" translate="yes" xml:space="preserve">
          <source>The data that comes with &lt;code&gt;Reason&lt;/code&gt; follows the same format as &lt;code&gt;&lt;a href=&quot;event_handler_chapter#failreason&quot;&gt;FailReason&lt;/a&gt;&lt;/code&gt; in event &lt;code&gt;&lt;a href=&quot;event_handler_chapter#tc_done&quot;&gt;tc_done&lt;/a&gt;&lt;/code&gt;. For details, see section &lt;code&gt;&lt;a href=&quot;event_handler_chapter#events&quot;&gt;Event Handling&lt;/a&gt;&lt;/code&gt; in the User's Guide.</source>
          <target state="translated">&lt;code&gt;Reason&lt;/code&gt; に付属するデータは、イベント &lt;code&gt;&lt;a href=&quot;event_handler_chapter#tc_done&quot;&gt;tc_done&lt;/a&gt;&lt;/code&gt; の &lt;code&gt;&lt;a href=&quot;event_handler_chapter#failreason&quot;&gt;FailReason&lt;/a&gt;&lt;/code&gt; と同じ形式に従います。詳細については、ユーザーガイドの「 &lt;code&gt;&lt;a href=&quot;event_handler_chapter#events&quot;&gt;Event Handling&lt;/a&gt;&lt;/code&gt; 」を参照してください。</target>
        </trans-unit>
        <trans-unit id="bb604c10fe966845cdde71367a93dbf6cc929795" translate="yes" xml:space="preserve">
          <source>The data that comes with &lt;code&gt;Reason&lt;/code&gt; follows the same format as events &lt;code&gt;&lt;a href=&quot;event_handler_chapter#tc_auto_skip&quot;&gt;tc_auto_skip&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;event_handler_chapter#tc_user_skip&quot;&gt;tc_user_skip&lt;/a&gt;&lt;/code&gt; For details, see section &lt;code&gt;&lt;a href=&quot;event_handler_chapter#events&quot;&gt;Event Handling&lt;/a&gt;&lt;/code&gt; in the User's Guide.</source>
          <target state="translated">&lt;code&gt;Reason&lt;/code&gt; に付属するデータは、イベント &lt;code&gt;&lt;a href=&quot;event_handler_chapter#tc_auto_skip&quot;&gt;tc_auto_skip&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;event_handler_chapter#tc_user_skip&quot;&gt;tc_user_skip&lt;/a&gt;&lt;/code&gt; と同じ形式に従います。詳細については、ユーザーズガイドの「 &lt;code&gt;&lt;a href=&quot;event_handler_chapter#events&quot;&gt;Event Handling&lt;/a&gt;&lt;/code&gt; 」を参照してください。</target>
        </trans-unit>
        <trans-unit id="3ae9537a2b782dfe6dcee8743658b21ed9b0301d" translate="yes" xml:space="preserve">
          <source>The data type &lt;code&gt;'AttributeTypeAndValue'&lt;/code&gt;, is represented as the following erlang record:</source>
          <target state="translated">データ型 &lt;code&gt;'AttributeTypeAndValue'&lt;/code&gt; は、次のアーランレコードとして表されます。</target>
        </trans-unit>
        <trans-unit id="feae33cf3d811c301bdaf1550728e179af863677" translate="yes" xml:space="preserve">
          <source>The data types &lt;code&gt;'Validity'&lt;/code&gt;, &lt;code&gt;'SubjectPublicKeyInfo'&lt;/code&gt;, and &lt;code&gt;'SubjectPublicKeyInfoAlgorithm'&lt;/code&gt; are represented as the following Erlang records:</source>
          <target state="translated">データ型 &lt;code&gt;'Validity'&lt;/code&gt; 、 &lt;code&gt;'SubjectPublicKeyInfo'&lt;/code&gt; 、および &lt;code&gt;'SubjectPublicKeyInfoAlgorithm'&lt;/code&gt; は、次のErlangレコードとして表されます。</target>
        </trans-unit>
        <trans-unit id="93bf041facbb4e82a9e8c285ac8447b2c8201746" translate="yes" xml:space="preserve">
          <source>The database can also become inconsistent if configuration parameter &lt;code&gt;max_wait_for_decision&lt;/code&gt; is used or if &lt;code&gt;mnesia:force_load_table/1&lt;/code&gt; is used.</source>
          <target state="translated">構成パラメーター &lt;code&gt;max_wait_for_decision&lt;/code&gt; が使用されている場合、または &lt;code&gt;mnesia:force_load_table/1&lt;/code&gt; が使用されている場合も、データベースが不整合になる可能性があります。</target>
        </trans-unit>
        <trans-unit id="264b842db8bf0ed81b261f12d4ee28f9ed7af246" translate="yes" xml:space="preserve">
          <source>The database can be reconfigured, and tables can be moved between nodes. These operations do not affect the user programs.</source>
          <target state="translated">データベースを再構成したり、ノード間でテーブルを移動したりすることができます。これらの操作は、ユーザプログラムには影響しません。</target>
        </trans-unit>
        <trans-unit id="7c3e27d69c9e2bbfe084964b4ba1a3ee0b761dd5" translate="yes" xml:space="preserve">
          <source>The database model is as follows:</source>
          <target state="translated">データベースのモデルは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="4b5b0c5d2b259e474f8fd1130e7a9869d03ac6fb" translate="yes" xml:space="preserve">
          <source>The date and time when the process was started.</source>
          <target state="translated">処理を開始した日時です。</target>
        </trans-unit>
        <trans-unit id="fe8362a1d9af54200a42df54d2c52d6145175ad5" translate="yes" xml:space="preserve">
          <source>The debug enabled runtime system features lock violation checking, assert checking and various sanity checks to help a developer ensure correctness. Some of these features can be enabled on a normal beam using appropriate configure options.</source>
          <target state="translated">デバッグが可能なランタイムシステムは、ロック違反チェック、アサートチェック、様々な正しさチェックを特徴としており、開発者が正しさを保証するのに役立ちます。これらの機能のいくつかは、適切なconfigureオプションを使用して通常のビームで有効にすることができます。</target>
        </trans-unit>
        <trans-unit id="c6dd12423efe39c011d13a41f3ecdda00e9c96f5" translate="yes" xml:space="preserve">
          <source>The debug information can also be removed from BEAM files using &lt;code&gt;&lt;a href=&quot;#strip-1&quot;&gt;strip/1&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#strip_files-1&quot;&gt;strip_files/1&lt;/a&gt;&lt;/code&gt;, and/or &lt;code&gt;&lt;a href=&quot;#strip_release-1&quot;&gt;strip_release/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">デバッグ情報は、 &lt;code&gt;&lt;a href=&quot;#strip-1&quot;&gt;strip/1&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;#strip_files-1&quot;&gt;strip_files/1&lt;/a&gt;&lt;/code&gt; 、および/または &lt;code&gt;&lt;a href=&quot;#strip_release-1&quot;&gt;strip_release/1&lt;/a&gt;&lt;/code&gt; を使用して、BEAMファイルから削除することもできます。</target>
        </trans-unit>
        <trans-unit id="9fcf3b68d8f8e511e6ff9331d892546d1029cbf5" translate="yes" xml:space="preserve">
          <source>The debug information can be encrypted to keep the source code secret, but still be able to use tools such as Debugger or Xref.</source>
          <target state="translated">デバッグ情報を暗号化してソースコードを秘密にしつつも、DebuggerやXrefなどのツールを利用できるようにすることができます。</target>
        </trans-unit>
        <trans-unit id="7fcc7761d46f20ec162261ce0e8d0b6a28d90fe6" translate="yes" xml:space="preserve">
          <source>The debug level of &lt;code&gt;Mnesia&lt;/code&gt; is set by calling the function &lt;code&gt;&lt;a href=&quot;mnesia#set_debug_level-1&quot;&gt;mnesia:set_debug_level(Level)&lt;/a&gt;&lt;/code&gt;, where &lt;code&gt;Level&lt;/code&gt;is one of the following:</source>
          <target state="translated">&lt;code&gt;Mnesia&lt;/code&gt; のデバッグレベルは、関数 &lt;code&gt;&lt;a href=&quot;mnesia#set_debug_level-1&quot;&gt;mnesia:set_debug_level(Level)&lt;/a&gt;&lt;/code&gt; を呼び出すことによって設定されます。ここで、 &lt;code&gt;Level&lt;/code&gt; は次のいずれかです。</target>
        </trans-unit>
        <trans-unit id="8f1bdc53b01108885cce2234b4e2d9b39baa8b28" translate="yes" xml:space="preserve">
          <source>The debug level of &lt;code&gt;Mnesia&lt;/code&gt; itself is also an application parameter, making it possible to start an Erlang system to turn on &lt;code&gt;Mnesia&lt;/code&gt; debug in the initial startup phase by using the following code:</source>
          <target state="translated">&lt;code&gt;Mnesia&lt;/code&gt; 自体のデバッグレベルもアプリケーションパラメータであり、次のコードを使用して、初期起動フェーズでErlangシステムを起動して &lt;code&gt;Mnesia&lt;/code&gt; デバッグをオンにすることができます。</target>
        </trans-unit>
        <trans-unit id="15f3b5f9fa804bcf46e507eb72dd7777e9dc6ab9" translate="yes" xml:space="preserve">
          <source>The decode and encode functions use a buffer and an index into the buffer, which points at the point where to encode and decode. The index is updated to point right after the term encoded/decoded. No checking is done whether the term fits in the buffer or not. If encoding goes outside the buffer, the program can crash.</source>
          <target state="translated">デコードおよびエンコード関数は、バッファとバッファへのインデックスを使用します。インデックスは、エンコード/デコードされたタームの直後を指すように更新されます。条件がバッファに収まるかどうかのチェックは行われません。もしエンコードがバッファの外に出てしまうと、プログラムはクラッシュする可能性があります。</target>
        </trans-unit>
        <trans-unit id="bb7a0f41f8f9cd301571e70dc3544c6857e6778d" translate="yes" xml:space="preserve">
          <source>The decode functions return a record as result when decoding a &lt;code&gt;SEQUENCE&lt;/code&gt; or a &lt;code&gt;SET&lt;/code&gt;.</source>
          <target state="translated">デコード関数は、 &lt;code&gt;SEQUENCE&lt;/code&gt; または &lt;code&gt;SET&lt;/code&gt; をデコードすると、結果としてレコードを返します。</target>
        </trans-unit>
        <trans-unit id="cef0dcfb934889d6cf431e5ebf6fd74edf18c281" translate="yes" xml:space="preserve">
          <source>The decoded value of an AVP. Will be &lt;code&gt;undefined&lt;/code&gt; on decode if the data bytes could not be decoded, the AVP is unknown, or if the &lt;code&gt;&lt;a href=&quot;diameter#decode_format&quot;&gt;decode format&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;none&lt;/code&gt;. The type of a decoded value is as document in &lt;code&gt;&lt;a href=&quot;diameter_dict#DATA_TYPES&quot;&gt;diameter_dict(4)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">AVPのデコードされた値。データバイトをデコードできなかった場合、AVPが不明の場合、または &lt;code&gt;&lt;a href=&quot;diameter#decode_format&quot;&gt;decode format&lt;/a&gt;&lt;/code&gt; が &lt;code&gt;none&lt;/code&gt; の場合は、デコード時に &lt;code&gt;undefined&lt;/code&gt; になります。デコードされた値のタイプは、 &lt;code&gt;&lt;a href=&quot;diameter_dict#DATA_TYPES&quot;&gt;diameter_dict(4)&lt;/a&gt;&lt;/code&gt; のドキュメントのとおりです。</target>
        </trans-unit>
        <trans-unit id="9dd25b2c0dae34a4ccb0be97da547058ad3ae8fb" translate="yes" xml:space="preserve">
          <source>The decoder returns an atom if the value corresponds to a symbol in the &lt;code&gt;Named Number List&lt;/code&gt;.</source>
          <target state="translated">値が &lt;code&gt;Named Number List&lt;/code&gt; シンボルに対応する場合、デコーダーはアトムを返します。</target>
        </trans-unit>
        <trans-unit id="c388aad8aed6c9f2fdd03a9ff95a76e605fea9f6" translate="yes" xml:space="preserve">
          <source>The default &quot;space&quot; characters are HT (9), LF (10), VT (11), FF (12), CR (13), and space (32). If locale-specific matching is taking place, the list of space characters may be different; there may be fewer or more of them. &quot;Space&quot; used to be different to \s, which did not include VT, for Perl compatibility. However, Perl changed at release 5.18, and PCRE followed at release 8.34. &quot;Space&quot; and \s now match the same set of characters.</source>
          <target state="translated">デフォルトの「スペース」文字は、HT (9)、LF (10)、VT (11)、FF (12)、CR (13)、およびスペース (32)です。ロケール固有のマッチングが行われている場合、スペース文字のリストは異なるかもしれません。&quot;Space&quot; は、Perl との互換性のために、VT を含まない \s とは異なっていました。しかし、Perlはリリース5.18で変更され、PCREはリリース8.34でそれに続きました。&quot;Space」と「\s」は、同じ文字セットに一致するようになりました。</target>
        </trans-unit>
        <trans-unit id="c59d65c8568f18df7ae19973d7555f547a715db3" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;Collector Filter&lt;/code&gt; converts the raw Erlang trace data format into &lt;code&gt;Event Records&lt;/code&gt;. If you want to perform this differently you can of course write your own &lt;code&gt;Collector Filter&lt;/code&gt; from scratch. But it may probably save you some efforts if you first apply the default filter in &lt;code&gt;et_selector:parse_event/2&lt;/code&gt; before you apply your own conversions of its output.</source>
          <target state="translated">デフォルトの &lt;code&gt;Collector Filter&lt;/code&gt; は、生のErlangトレースデータ形式を &lt;code&gt;Event Records&lt;/code&gt; 変換します。これを別の方法で実行したい場合は、もちろん独自の &lt;code&gt;Collector Filter&lt;/code&gt; を最初から作成できます。しかし、出力の独自の変換を適用する前に &lt;code&gt;et_selector:parse_event/2&lt;/code&gt; でデフォルトのフィルターを最初に適用すると、おそらくいくつかの労力を節約できます。</target>
        </trans-unit>
        <trans-unit id="c57652a6dee935467cebeeed4f3fb7d6f7116fee" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;Size&lt;/code&gt; depends on the type. For integer it is 8. For float it is 64. For binary it is all of the binary. In matching, this default value is only valid for the last element. All other binary elements in matching must have a size specification.</source>
          <target state="translated">デフォルトの &lt;code&gt;Size&lt;/code&gt; はタイプによって異なります。整数の場合は8です。浮動小数点の場合は64です。バイナリの場合はすべてのバイナリです。マッチングでは、このデフォルト値は最後の要素に対してのみ有効です。マッチングの他のすべてのバイナリエレメントには、サイズ指定が必要です。</target>
        </trans-unit>
        <trans-unit id="4f1c0b4c022d0f07743e56c51911904bc53375f9" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;message_queue_data&lt;/code&gt; process flag is determined by command-line argument &lt;code&gt;&lt;a href=&quot;erl#+hmqd&quot;&gt;+hmqd&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;erl(1)&lt;/code&gt;.</source>
          <target state="translated">デフォルトの &lt;code&gt;message_queue_data&lt;/code&gt; プロセスフラグは、 &lt;code&gt;erl(1)&lt;/code&gt; のコマンドライン引数 &lt;code&gt;&lt;a href=&quot;erl#+hmqd&quot;&gt;+hmqd&lt;/a&gt;&lt;/code&gt; によって決定されます。</target>
        </trans-unit>
        <trans-unit id="572022a6b410479721a7992c7362b7aaff7907d4" translate="yes" xml:space="preserve">
          <source>The default Erlang evaluator is used and the result is returned to the client.</source>
          <target state="translated">デフォルトのErlangの評価器が使われ、結果がクライアントに返されます。</target>
        </trans-unit>
        <trans-unit id="88fd0465cd657366b4590ae0f113c518fee5324c" translate="yes" xml:space="preserve">
          <source>The default Unicode encoding in Erlang is in binaries UTF-8, which is also the format in which built-in functions and libraries in OTP expect to find binary Unicode data. In lists, Unicode data is encoded as integers, each integer representing one character and encoded simply as the Unicode code point for the character.</source>
          <target state="translated">ErlangのデフォルトのUnicodeエンコーディングはバイナリのUTF-8で、これはOTPの組み込み関数やライブラリがバイナリのUnicodeデータを見つけることを期待するフォーマットでもあります。リストでは、Unicodeデータは整数でエンコードされ、それぞれの整数が1文字を表し、その文字のUnicodeコードポイントとして単純にエンコードされます。</target>
        </trans-unit>
        <trans-unit id="49cebb251d6b0aa1500584bc73027335bd0baea3" translate="yes" xml:space="preserve">
          <source>The default algorithm is &lt;code&gt;exrop&lt;/code&gt; (Xoroshiro116+). If a specific algorithm is required, ensure to always use &lt;code&gt;&lt;a href=&quot;#seed-1&quot;&gt;seed/1&lt;/a&gt;&lt;/code&gt; to initialize the state.</source>
          <target state="translated">デフォルトのアルゴリズムは &lt;code&gt;exrop&lt;/code&gt; （Xoroshiro116 +）です。特定のアルゴリズムが必要な場合は、常に &lt;code&gt;&lt;a href=&quot;#seed-1&quot;&gt;seed/1&lt;/a&gt;&lt;/code&gt; を使用して状態を初期化してください。</target>
        </trans-unit>
        <trans-unit id="3eb49c55e11d37a2c7f97be97bd91839e01e102b" translate="yes" xml:space="preserve">
          <source>The default behaviour in the two other cases (that is, abnormal exit) above is to:</source>
          <target state="translated">上記の他の2つのケース(つまり異常終了)でのデフォルトの動作は</target>
        </trans-unit>
        <trans-unit id="9aad933f8a23be0b8f60b2f0009c014495bcab97" translate="yes" xml:space="preserve">
          <source>The default behaviour is ignore the message. To get a printout for each message with &lt;code&gt;AlwaysDisplay = true&lt;/code&gt;, use for example &lt;code&gt;{ssh_msg_debug_fun, fun(_,true,M,_)-&amp;gt; io:format(&quot;DEBUG: ~p~n&quot;, [M]) end}&lt;/code&gt;</source>
          <target state="translated">デフォルトの動作はメッセージを無視することです。 &lt;code&gt;AlwaysDisplay = true&lt;/code&gt; で各メッセージのプリントアウトを取得するには、たとえば &lt;code&gt;{ssh_msg_debug_fun, fun(_,true,M,_)-&amp;gt; io:format(&quot;DEBUG: ~p~n&quot;, [M]) end}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9cc443fe9633fb1a0335c43045efe1e002d6805e" translate="yes" xml:space="preserve">
          <source>The default behaviour is to create a file named &lt;code&gt;TAGS&lt;/code&gt; in the current directory.</source>
          <target state="translated">デフォルトの動作では、 &lt;code&gt;TAGS&lt;/code&gt; という名前のファイルが現在のディレクトリに作成されます。</target>
        </trans-unit>
        <trans-unit id="26ca635941f675c5f6767b6598533eaee0bb0c9a" translate="yes" xml:space="preserve">
          <source>The default behaviour of a process that receives a normal exit is to ignore the signal.</source>
          <target state="translated">正常終了を受信したプロセスのデフォルトの動作は、シグナルを無視することです。</target>
        </trans-unit>
        <trans-unit id="47755f34cfe7e278db6d7efc977a211082ce5135" translate="yes" xml:space="preserve">
          <source>The default behaviour when a process receives an exit signal with an exit reason other than &lt;code&gt;normal&lt;/code&gt;, is to terminate and in turn emit exit signals with the same exit reason to its linked processes. An exit signal with reason &lt;code&gt;normal&lt;/code&gt; is ignored.</source>
          <target state="translated">プロセスが &lt;code&gt;normal&lt;/code&gt; 以外の終了理由で終了シグナルを受け取ったときのデフォルトの動作は、終了して、リンクされたプロセスに同じ終了理由で終了シグナルを発行することです。 &lt;code&gt;normal&lt;/code&gt; 理由での終了信号は無視されます。</target>
        </trans-unit>
        <trans-unit id="9d70ec5c7098a4e4d6ce579440d90f6d0f1a9b44" translate="yes" xml:space="preserve">
          <source>The default boot file is &lt;code&gt;$OTP_ROOT/bin/start&lt;/code&gt;, but in this case we need to specify a boot file from our target structure, typically &lt;code&gt;&amp;lt;target-dir&amp;gt;/releases/&amp;lt;vsn&amp;gt;/&amp;lt;RelName&amp;gt;&lt;/code&gt;. This is done with the &lt;code&gt;-boot&lt;/code&gt; command line option to &lt;code&gt;erl&lt;/code&gt;</source>
          <target state="translated">デフォルトのブートファイルは &lt;code&gt;$OTP_ROOT/bin/start&lt;/code&gt; ですが、この場合、ターゲット構造（通常は &lt;code&gt;&amp;lt;target-dir&amp;gt;/releases/&amp;lt;vsn&amp;gt;/&amp;lt;RelName&amp;gt;&lt;/code&gt; )からブートファイルを指定する必要があります。これは、 &lt;code&gt;erl&lt;/code&gt; の &lt;code&gt;-boot&lt;/code&gt; コマンドラインオプションで実行されます。</target>
        </trans-unit>
        <trans-unit id="8deb6cfc40b154f0f3bc4c292fe3c4c01bead83c" translate="yes" xml:space="preserve">
          <source>The default callback module &lt;code&gt;&lt;a href=&quot;ct_slave&quot;&gt;ct_slave&lt;/a&gt;&lt;/code&gt;, has the following features:</source>
          <target state="translated">デフォルトのコールバックモジュール &lt;code&gt;&lt;a href=&quot;ct_slave&quot;&gt;ct_slave&lt;/a&gt;&lt;/code&gt; には、次の機能があります。</target>
        </trans-unit>
        <trans-unit id="1389307405e87741972dcfbd8f36d70ed4c7e741" translate="yes" xml:space="preserve">
          <source>The default discovery handler will require additional actions by the caller and the discovery will not work if the security-level is higher then &lt;code&gt;noAuthNoPriv&lt;/code&gt;.</source>
          <target state="translated">デフォルトの検出ハンドラは呼び出し側による追加のアクションを必要とし、セキュリティレベルが &lt;code&gt;noAuthNoPriv&lt;/code&gt; よりも高い場合、検出は機能しません。</target>
        </trans-unit>
        <trans-unit id="d22df62b6d0da804bdfcd33682ee76feb0f23fda" translate="yes" xml:space="preserve">
          <source>The default encoding for Erlang source files is changed from Latin-1 to UTF-8 since Erlang/OTP 17.0.</source>
          <target state="translated">Erlang/OTP 17.0からErlangソースファイルのデフォルトエンコーディングがLatin-1からUTF-8に変更されました。</target>
        </trans-unit>
        <trans-unit id="b3e3252c03a4fb54a27bf1c1fdc312100673449d" translate="yes" xml:space="preserve">
          <source>The default encoding of the I/O-server for &lt;code&gt;standard_io&lt;/code&gt; is &lt;code&gt;latin1&lt;/code&gt;, as the script runs in a non-interactive terminal (see section &lt;code&gt;Summary of Options&lt;/code&gt;) in the STDLIB User's Guide.</source>
          <target state="translated">STDLIBユーザーガイドの非対話型ターミナル（セクション &lt;code&gt;Summary of Options&lt;/code&gt; 参照）でスクリプトが実行されるため、 &lt;code&gt;standard_io&lt;/code&gt; のI / Oサーバーのデフォルトのエンコーディングは &lt;code&gt;latin1&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="5fc4ad3abb12599963d8f41201b9099f8a6fadc8" translate="yes" xml:space="preserve">
          <source>The default encoding. Bytes supplied to the file, that is, &lt;code&gt;&lt;a href=&quot;#write-2&quot;&gt;write/2&lt;/a&gt;&lt;/code&gt; are written &quot;as is&quot; on the file. Likewise, bytes read from the file, that is, &lt;code&gt;&lt;a href=&quot;#read-2&quot;&gt;read/2&lt;/a&gt;&lt;/code&gt; are returned &quot;as is&quot;. If module &lt;code&gt;io(3)&lt;/code&gt; is used for writing, the file can only cope with Unicode characters up to code point 255 (the ISO Latin-1 range).</source>
          <target state="translated">デフォルトのエンコーディング。ファイルに提供されたバイト、つまり &lt;code&gt;&lt;a href=&quot;#write-2&quot;&gt;write/2&lt;/a&gt;&lt;/code&gt; は「現状のまま」ファイルに書き込まれます。同様に、ファイルから読み取られたバイト、つまり &lt;code&gt;&lt;a href=&quot;#read-2&quot;&gt;read/2&lt;/a&gt;&lt;/code&gt; は「そのまま」返されます。モジュール &lt;code&gt;io(3)&lt;/code&gt; が書き込みに使用される場合、ファイルはコードポイント255（ISO Latin-1の範囲）までのUnicode文字のみを処理できます。</target>
        </trans-unit>
        <trans-unit id="d6c8c72f780ad73f25b213fdc25585528f17513b" translate="yes" xml:space="preserve">
          <source>The default endianness is &lt;code&gt;big&lt;/code&gt;.</source>
          <target state="translated">デフォルトのエンディアンは &lt;code&gt;big&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="d83550f92d20198e2acab3ad30ef01b3a3ff2580" translate="yes" xml:space="preserve">
          <source>The default fallback behaviour. Template funs should end with:</source>
          <target state="translated">デフォルトのフォールバック動作。テンプレートファンはこれで終わるべきです。</target>
        </trans-unit>
        <trans-unit id="c9d9ffa8dde369b6838c3b5a3754294ebeb88aaa" translate="yes" xml:space="preserve">
          <source>The default functions and &lt;code&gt;snmp_generic&lt;/code&gt; cannot handle an object of type &lt;code&gt;NetworkAddress&lt;/code&gt; as INDEX (SNMPv1 only!). Use &lt;code&gt;IpAddress&lt;/code&gt; instead.</source>
          <target state="translated">デフォルトの関数と &lt;code&gt;snmp_generic&lt;/code&gt; は、 &lt;code&gt;NetworkAddress&lt;/code&gt; タイプのオブジェクトをINDEXとして処理できません（SNMPv1のみ！）。代わりに &lt;code&gt;IpAddress&lt;/code&gt; を使用してください。</target>
        </trans-unit>
        <trans-unit id="4cd3d1fa535e347fbd4b38228c48e00bf23af7b2" translate="yes" xml:space="preserve">
          <source>The default functions and &lt;code&gt;snmp_generic&lt;/code&gt; do not check the range of each OCTET in textual conventions derived from OCTET STRING, e.g. &lt;code&gt;DisplayString&lt;/code&gt; and &lt;code&gt;DateAndTime&lt;/code&gt;. This must be checked in an overloaded &lt;code&gt;is_set_ok&lt;/code&gt; function.</source>
          <target state="translated">デフォルトの関数と &lt;code&gt;snmp_generic&lt;/code&gt; は、OCTET STRINGから派生したテキストの表記法、たとえば &lt;code&gt;DisplayString&lt;/code&gt; や &lt;code&gt;DateAndTime&lt;/code&gt; などの各OCTETの範囲をチェックしません。これは、オーバーロードされた &lt;code&gt;is_set_ok&lt;/code&gt; 関数でチェックする必要があります。</target>
        </trans-unit>
        <trans-unit id="93ec2b0bf3246052db6872a9a89f490a6940711d" translate="yes" xml:space="preserve">
          <source>The default handlers, &lt;code&gt;&lt;a href=&quot;logger_std_h&quot;&gt;logger_std_h&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;logger_disk_log_h&quot;&gt;logger_disk_log_h&lt;/a&gt;&lt;/code&gt;, feature an overload protection mechanism, which makes it possible for the handlers to survive, and stay responsive, during periods of high load (when huge numbers of incoming log requests must be handled). The mechanism works as follows:</source>
          <target state="translated">デフォルトのハンドラー &lt;code&gt;&lt;a href=&quot;logger_std_h&quot;&gt;logger_std_h&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;logger_disk_log_h&quot;&gt;logger_disk_log_h&lt;/a&gt;&lt;/code&gt; は、過負荷保護メカニズムを備えています。これにより、高負荷の期間（大量の受信ログ要求を処理する必要がある場合）でもハンドラーが存続し、応答性を維持できるようになります。このメカニズムは次のように機能します。</target>
        </trans-unit>
        <trans-unit id="fef3702dc90f570ebd9028951e47041a3eec62af" translate="yes" xml:space="preserve">
          <source>The default initial heap size of 233 words is quite conservative to support Erlang systems with hundreds of thousands or even millions of processes. The garbage collector grows and shrinks the heap as needed.</source>
          <target state="translated">デフォルトの初期ヒープサイズは233ワードで、何十万、何百万ものプロセスを持つErlangシステムをサポートするためにはかなり保守的です。ガベージコレクタは必要に応じてヒープを成長させたり縮小させたりします。</target>
        </trans-unit>
        <trans-unit id="028f1e913dc597e5f47465aa0038982d46d84b7c" translate="yes" xml:space="preserve">
          <source>The default instrumentation allows the application on the manager side to be developed and tested simultaneously with the agent. As soon as the ASN.1 file is completed, let the MIB compiler generate a default implementation and develop the management application from this.</source>
          <target state="translated">デフォルトのインプリメンテーションにより、マネージャ側のアプリケーションをエージェントと同時に開発してテストすることができます。ASN.1ファイルが完成したらすぐに、MIBコンパイラにデフォルトの実装を生成させて、これを元に管理アプリケーションを開発します。</target>
        </trans-unit>
        <trans-unit id="2bcdc2b092cf0144876d346105d3638a289ddc47" translate="yes" xml:space="preserve">
          <source>The default instrumentation functions are defined in the module &lt;code&gt;snmp_generic&lt;/code&gt;. Refer to the Reference Manual, section SNMP, module &lt;code&gt;snmp_generic&lt;/code&gt; for details.</source>
          <target state="translated">デフォルトの計測機能は、モジュール &lt;code&gt;snmp_generic&lt;/code&gt; で定義されています。詳細については、リファレンスマニュアルのセクションSNMP、モジュール &lt;code&gt;snmp_generic&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="a4f9d2c2e9dd957fcc3258b4a7c7be3758f84afc" translate="yes" xml:space="preserve">
          <source>The default is 30 seconds.</source>
          <target state="translated">デフォルトは30秒です。</target>
        </trans-unit>
        <trans-unit id="697dc028cf7853b692477e62b3b0ccd825e45fa0" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;integer&lt;/code&gt;. &lt;code&gt;bytes&lt;/code&gt; is a shorthand for &lt;code&gt;binary&lt;/code&gt; and &lt;code&gt;bits&lt;/code&gt; is a shorthand for &lt;code&gt;bitstring&lt;/code&gt;. See below for more information about the &lt;code&gt;utf&lt;/code&gt; types.</source>
          <target state="translated">デフォルトは &lt;code&gt;integer&lt;/code&gt; です。 &lt;code&gt;bytes&lt;/code&gt; は &lt;code&gt;binary&lt;/code&gt; の省略形で、 &lt;code&gt;bits&lt;/code&gt; は &lt;code&gt;bitstring&lt;/code&gt; の省略形です。 &lt;code&gt;utf&lt;/code&gt; タイプの詳細については、以下を参照してください。</target>
        </trans-unit>
        <trans-unit id="6f0b6dd22860df8373214ee0633cf82a9776e5cd" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;true&lt;/code&gt; for &lt;code&gt;binary_alloc&lt;/code&gt; and &lt;code&gt;driver_alloc&lt;/code&gt;, and &lt;code&gt;false&lt;/code&gt; for the other allocator types.</source>
          <target state="translated">デフォルトは &lt;code&gt;true&lt;/code&gt; のため &lt;code&gt;binary_alloc&lt;/code&gt; と &lt;code&gt;driver_alloc&lt;/code&gt; 、および &lt;code&gt;false&lt;/code&gt; 他のアロケータタイプについて。</target>
        </trans-unit>
        <trans-unit id="f6c6037b1efc7d6b42e5368b46d0f3b99b3ee991" translate="yes" xml:space="preserve">
          <source>The default is to return a sequence of QLCs in a block, but if option &lt;code&gt;{flat,&amp;nbsp;false}&lt;/code&gt; is specified, one single QLC is returned.</source>
          <target state="translated">デフォルトでは、ブロック内の一連のQLCが返されますが、オプション &lt;code&gt;{flat,&amp;nbsp;false}&lt;/code&gt; が指定されている場合、単一のQLCが返されます。</target>
        </trans-unit>
        <trans-unit id="b873bd22585e6e628d3df8c1732fa1e4731a1722" translate="yes" xml:space="preserve">
          <source>The default is to return a string, but if option &lt;code&gt;{format,&amp;nbsp;abstract_code}&lt;/code&gt; is specified, abstract code is returned instead. In the abstract code, port identifiers, references, and pids are represented by strings.</source>
          <target state="translated">デフォルトでは文字列を返しますが、オプション &lt;code&gt;{format,&amp;nbsp;abstract_code}&lt;/code&gt; が指定されている場合は、代わりに抽象コードが返されます。抽象コードでは、ポート識別子、参照、およびPIDは文字列で表されます。</target>
        </trans-unit>
        <trans-unit id="6b16165d91c06ae4aeb2706afc9b7a0ac50cd9da" translate="yes" xml:space="preserve">
          <source>The default is to return all elements in lists, but if option &lt;code&gt;{n_elements,&amp;nbsp;NElements}&lt;/code&gt; is specified, only a limited number of elements are returned.</source>
          <target state="translated">デフォルトではリスト内のすべての要素が返されますが、オプション &lt;code&gt;{n_elements,&amp;nbsp;NElements}&lt;/code&gt; が指定されている場合、限られた数の要素のみが返されます。</target>
        </trans-unit>
        <trans-unit id="cc7b0f890d901ebd92c482f0beb121398b160a73" translate="yes" xml:space="preserve">
          <source>The default is to show all parts of objects and match specifications, but if option &lt;code&gt;{depth,&amp;nbsp;Depth}&lt;/code&gt; is specified, parts of terms below a certain depth are replaced by &lt;code&gt;'...'&lt;/code&gt;.</source>
          <target state="translated">デフォルトでは、オブジェクトのすべての部分が表示 &lt;code&gt;{depth,&amp;nbsp;Depth}&lt;/code&gt; 仕様が一致しますが、オプション{depth、Depth}が指定されている場合、特定の深さより下の用語の部分は &lt;code&gt;'...'&lt;/code&gt; に置き換えられます。</target>
        </trans-unit>
        <trans-unit id="d031478aad7c792d83bd41e0b1d60d3346429273" translate="yes" xml:space="preserve">
          <source>The default is to sort terms in ascending order, but that can be changed by value &lt;code&gt;descending&lt;/code&gt; or by specifying an ordering function &lt;code&gt;Fun&lt;/code&gt;. An ordering function is antisymmetric, transitive, and total. &lt;code&gt;Fun(A,&amp;nbsp;B)&lt;/code&gt; is to return &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;A&lt;/code&gt; comes before &lt;code&gt;B&lt;/code&gt; in the ordering, otherwise &lt;code&gt;false&lt;/code&gt;. An example of a typical ordering function is less than or equal to, &lt;code&gt;=&amp;lt;/2&lt;/code&gt;. Using an ordering function slows down the sort considerably. Functions &lt;code&gt;keysort&lt;/code&gt;, &lt;code&gt;keymerge&lt;/code&gt; and &lt;code&gt;keycheck&lt;/code&gt; do not accept ordering functions.</source>
          <target state="translated">デフォルトでは、用語は昇順でソートされますが、値の &lt;code&gt;descending&lt;/code&gt; または順序付け関数 &lt;code&gt;Fun&lt;/code&gt; を指定することで変更できます。順序付け関数は、反対称、推移的、合計です。 &lt;code&gt;Fun(A,&amp;nbsp;B)&lt;/code&gt; は、順序付けで &lt;code&gt;A&lt;/code&gt; が &lt;code&gt;B&lt;/code&gt; の前に &lt;code&gt;true&lt;/code&gt; 場合はtrueを返し、そうでない場合は &lt;code&gt;false&lt;/code&gt; を返します。典型的な順序付け関数の例は、 &lt;code&gt;=&amp;lt;/2&lt;/code&gt; 以下です。順序付け関数を使用すると、ソートが大幅に遅くなります。関数 &lt;code&gt;keysort&lt;/code&gt; 、 &lt;code&gt;keymerge&lt;/code&gt; 、および &lt;code&gt;keycheck&lt;/code&gt; は、順序付け関数を受け入れません。</target>
        </trans-unit>
        <trans-unit id="388c1ebba36e81e6d83c9829202075488730e57f" translate="yes" xml:space="preserve">
          <source>The default list is fetched from the &lt;code&gt;public_key&lt;/code&gt; application.</source>
          <target state="translated">デフォルトのリストは &lt;code&gt;public_key&lt;/code&gt; アプリケーションからフェッチされます。</target>
        </trans-unit>
        <trans-unit id="6b3871f80aaa305c511a84fd9b3f91462dfdba6b" translate="yes" xml:space="preserve">
          <source>The default logging behavior of &lt;code&gt;ct_telnet&lt;/code&gt; is to print information about performed operations, commands, and their corresponding results to the test case HTML log. The following is not printed to the HTML log: text strings sent from the Telnet server that are not explicitly received by a &lt;code&gt;ct_telnet&lt;/code&gt; function, such as &lt;code&gt;expect/3&lt;/code&gt;. However, &lt;code&gt;ct_telnet&lt;/code&gt; can be configured to use a special purpose event handler, implemented in &lt;code&gt;ct_conn_log_h&lt;/code&gt;, for logging &lt;strong&gt;all&lt;/strong&gt; Telnet traffic. To use this handler, install a &lt;code&gt;Common Test&lt;/code&gt; hook named &lt;code&gt;cth_conn_log&lt;/code&gt;. Example (using the test suite information function):</source>
          <target state="translated">&lt;code&gt;ct_telnet&lt;/code&gt; のデフォルトのロギング動作は、実行された操作、コマンド、および対応する結果に関する情報をテストケースのHTMLログに出力することです。次のものはHTMLログに出力されません &lt;code&gt;ct_telnet&lt;/code&gt; サーバーから送信され、 &lt;code&gt;expect/3&lt;/code&gt; などのct_telnet関数によって明示的に受信されないテキスト文字列。ただし、 &lt;code&gt;ct_telnet&lt;/code&gt; は、&lt;strong&gt;すべての&lt;/strong&gt; Telnetトラフィックをログに記録&lt;strong&gt;する&lt;/strong&gt;ために、 &lt;code&gt;ct_conn_log_h&lt;/code&gt; に実装された特別な目的のイベントハンドラーを使用するように構成できます。このハンドラーを使用するには、 &lt;code&gt;cth_conn_log&lt;/code&gt; という名前の &lt;code&gt;Common Test&lt;/code&gt; フックをインストールします。例（テストスイート情報関数を使用）：&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2de8d81b3d3a2e14473bb755a7b9ea4746cd308a" translate="yes" xml:space="preserve">
          <source>The default matching handles dns_id and uri_id. In an uri_id the value is tested for equality with a value from the &lt;code&gt;Subject Alternate Name&lt;/code&gt;. If som other kind of matching is needed, use the &lt;code&gt;match_fun&lt;/code&gt; option.</source>
          <target state="translated">デフォルトのマッチングでは、dns_idとuri_idを処理します。uri_idでは、値は &lt;code&gt;Subject Alternate Name&lt;/code&gt; 値と等しいかどうかがテストされます。他の種類のマッチングが必要な場合は、 &lt;code&gt;match_fun&lt;/code&gt; オプションを使用します。</target>
        </trans-unit>
        <trans-unit id="84111fd78857c9aae8ea5220ba7612eb708e45fa" translate="yes" xml:space="preserve">
          <source>The default matching transformes the ascii values in strings to lowercase before comparing. The &lt;code&gt;match_fun&lt;/code&gt; is however called without any transfomation applied to the strings. The reason is to enable the user to do unforseen handling of the strings where the original format is needed.</source>
          <target state="translated">デフォルトのマッチングでは、比較する前に文字列のASCII値を小文字に変換します。 &lt;code&gt;match_fun&lt;/code&gt; は、しかし、文字列に適用される任意のtransfomationなしで呼ばれています。その理由は、元のフォーマットが必要な場合に、ユーザーが予期しない文字列の処理を行えるようにするためです。</target>
        </trans-unit>
        <trans-unit id="aa2a84cd90225c7ed3bdea62cdca292d4a45b475" translate="yes" xml:space="preserve">
          <source>The default mode depends on the operating system. Windows and MacOS X enforce consistent filename encoding and therefore the VM uses &lt;code&gt;utf8&lt;/code&gt; mode.</source>
          <target state="translated">デフォルトのモードはオペレーティングシステムによって異なります。WindowsおよびMacOS Xは一貫したファイル名エンコーディングを適用するため、VMは &lt;code&gt;utf8&lt;/code&gt; モードを使用します。</target>
        </trans-unit>
        <trans-unit id="953f88f92bc1b24efaf4cf45547f40d0e648b131" translate="yes" xml:space="preserve">
          <source>The default object arity is smaller than &lt;code&gt;&amp;lt;keypos&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">デフォルトのオブジェクトアリティは &lt;code&gt;&amp;lt;keypos&amp;gt;&lt;/code&gt; より小さいです。</target>
        </trans-unit>
        <trans-unit id="4de77215568172d7d29aabd76eae88688d23f0d0" translate="yes" xml:space="preserve">
          <source>The default options of the &lt;code&gt;erlsrv&lt;/code&gt; program are not sufficient for release handling. The machine started by &lt;code&gt;erlsrv&lt;/code&gt; is be specified as the &lt;code&gt;start_erl&lt;/code&gt; program and the arguments are to contain &lt;code&gt;++&lt;/code&gt; followed by the desired options.</source>
          <target state="translated">&lt;code&gt;erlsrv&lt;/code&gt; プログラムのデフォルトオプションは、リリースの処理には不十分です。 &lt;code&gt;erlsrv&lt;/code&gt; によって開始されたマシンは &lt;code&gt;start_erl&lt;/code&gt; プログラムとして指定され、引数には &lt;code&gt;++&lt;/code&gt; とその後に必要なオプションが含まれます。</target>
        </trans-unit>
        <trans-unit id="fb1094b520cae2a88d55d90efc05453766135ad7" translate="yes" xml:space="preserve">
          <source>The default set of groups is listed in &lt;code&gt;lib/public_key/priv/moduli&lt;/code&gt;. This file may be regenerated like this:</source>
          <target state="translated">グループのデフォルトのセットは、 &lt;code&gt;lib/public_key/priv/moduli&lt;/code&gt; にリストされています。このファイルは次のように再生成されます：</target>
        </trans-unit>
        <trans-unit id="8c212e9694a3fd892d150f01a66f923860ff2fc9" translate="yes" xml:space="preserve">
          <source>The default shell prompt function displays the name of the node (if the node can be part of a distributed system) and the current command number. The user can customize the prompt function by calling &lt;code&gt;&lt;a href=&quot;#prompt_func-1&quot;&gt;prompt_func/1&lt;/a&gt;&lt;/code&gt; or by setting application configuration parameter &lt;code&gt;shell_prompt_func&lt;/code&gt; for the STDLIB application.</source>
          <target state="translated">デフォルトのシェルプロンプト機能は、ノードの名前（ノードが分散システムの一部である場合）と現在のコマンド番号を表示します。ユーザーは、 &lt;code&gt;&lt;a href=&quot;#prompt_func-1&quot;&gt;prompt_func/1&lt;/a&gt;&lt;/code&gt; を呼び出すか、STDLIBアプリケーションのアプリケーション構成パラメーター &lt;code&gt;shell_prompt_func&lt;/code&gt; を設定して、プロンプト機能をカスタマイズできます。</target>
        </trans-unit>
        <trans-unit id="00b63ca80d11da692b5651bc33e43d076e3793c3" translate="yes" xml:space="preserve">
          <source>The default signedness is &lt;code&gt;unsigned&lt;/code&gt;.</source>
          <target state="translated">デフォルトの &lt;code&gt;unsigned&lt;/code&gt; はunsignedです。</target>
        </trans-unit>
        <trans-unit id="ff776579e06c4767b62b9f485e782cd999a09f7a" translate="yes" xml:space="preserve">
          <source>The default simple handler is called &lt;code&gt;alarm_handler&lt;/code&gt; and it can be exchanged by calling &lt;code&gt;gen_event:swap_handler/3&lt;/code&gt; as &lt;code&gt;gen_event:swap_handler(alarm_handler, {alarm_handler, swap}, {NewHandler, Args})&lt;/code&gt;. &lt;code&gt;NewHandler:init({Args, {alarm_handler, Alarms}})&lt;/code&gt; is called. For more details, see &lt;code&gt;gen_event(3)&lt;/code&gt; in STDLIB.</source>
          <target state="translated">デフォルトの単純なハンドラーは &lt;code&gt;alarm_handler&lt;/code&gt; と呼ばれ、 &lt;code&gt;gen_event:swap_handler/3&lt;/code&gt; を &lt;code&gt;gen_event:swap_handler(alarm_handler, {alarm_handler, swap}, {NewHandler, Args})&lt;/code&gt; として呼び出すことで交換できます。 &lt;code&gt;NewHandler:init({Args, {alarm_handler, Alarms}})&lt;/code&gt; が呼び出されます。詳細については、 &lt;code&gt;gen_event(3)&lt;/code&gt; 参照してください。</target>
        </trans-unit>
        <trans-unit id="edd4ef6f5a1e3a142885438b41744f5b5b26e5b7" translate="yes" xml:space="preserve">
          <source>The default socket options are &lt;code&gt;[{mode,list},{packet, 0},{header, 0},{active, true}]&lt;/code&gt;.</source>
          <target state="translated">デフォルトのソケットオプションは &lt;code&gt;[{mode,list},{packet, 0},{header, 0},{active, true}]&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="7b0a75358d0df669ac13a835e5ee193bd00512b1" translate="yes" xml:space="preserve">
          <source>The default standard handler, &lt;code&gt;&lt;a href=&quot;logger_std_h&quot;&gt;logger_std_h&lt;/a&gt;&lt;/code&gt;, can be replaced by a disk_log handler at startup of the Kernel application. See an example of this below.</source>
          <target state="translated">デフォルトの標準ハンドラー &lt;code&gt;&lt;a href=&quot;logger_std_h&quot;&gt;logger_std_h&lt;/a&gt;&lt;/code&gt; は、カーネルアプリケーションの起動時にdisk_logハンドラーに置き換えることができます。以下の例をご覧ください。</target>
        </trans-unit>
        <trans-unit id="56e59dc663ec3168b6b7eec38a9c17da04f70aec" translate="yes" xml:space="preserve">
          <source>The default start option &lt;code&gt;{dir,Cwd}&lt;/code&gt; (to run all suites in the current working directory) is used if the function is called with an empty list of options.</source>
          <target state="translated">オプションの空のリストを指定して関数が呼び出された場合、デフォルトの開始オプション &lt;code&gt;{dir,Cwd}&lt;/code&gt; （現在の作業ディレクトリ内のすべてのスイートを実行する）が使用されます。</target>
        </trans-unit>
        <trans-unit id="8472d25153570bd73936053aa35b2f0053ff73f8" translate="yes" xml:space="preserve">
          <source>The default time limit for a test case is 30 minutes, unless a &lt;code&gt;timetrap&lt;/code&gt; is specified either by the suite-, group-, or test case information function. The timetrap time-out value defined by &lt;code&gt;suite/0&lt;/code&gt; is the value that is used for each test case in the suite (and for the configuration functions &lt;code&gt;init_per_suite/1&lt;/code&gt;, &lt;code&gt;end_per_suite/1&lt;/code&gt;, &lt;code&gt;init_per_group/2&lt;/code&gt;, and &lt;code&gt;end_per_group/2&lt;/code&gt;). A timetrap value defined by &lt;code&gt;group(GroupName)&lt;/code&gt; overrides one defined by &lt;code&gt;suite()&lt;/code&gt; and is used for each test case in group &lt;code&gt;GroupName&lt;/code&gt;, and any of its subgroups. If a timetrap value is defined by &lt;code&gt;group/1&lt;/code&gt; for a subgroup, it overrides that of its higher level groups. Timetrap values set by individual test cases (by the test case information function) override both group- and suite- level timetraps.</source>
          <target state="translated">スイート、グループ、またはテストケース情報関数で &lt;code&gt;timetrap&lt;/code&gt; が指定されていない限り、テストケースのデフォルトの制限時間は30分です。 &lt;code&gt;suite/0&lt;/code&gt; によって定義されたタイムトラップタイムアウト値は、スイート内の各テストケース（および構成関数 &lt;code&gt;init_per_suite/1&lt;/code&gt; 、 &lt;code&gt;end_per_suite/1&lt;/code&gt; 、 &lt;code&gt;init_per_group/2&lt;/code&gt; 、および &lt;code&gt;end_per_group/2&lt;/code&gt; ）に使用される値です。 &lt;code&gt;group(GroupName)&lt;/code&gt; で定義されたタイムトラップ値は &lt;code&gt;suite()&lt;/code&gt; で定義された値をオーバーライドし、グループ &lt;code&gt;GroupName&lt;/code&gt; とそのサブグループの各テストケースで使用されます。タイムトラップ値が &lt;code&gt;group/1&lt;/code&gt; によって定義されている場合サブグループの場合は、上位レベルのグループを上書きします。（テストケース情報関数によって）個々のテストケースによって設定されたタイムトラップ値は、グループレベルとスイートレベルの両方のタイムトラップをオーバーライドします。</target>
        </trans-unit>
        <trans-unit id="b52b358a5f5402f0ac26ce2f8003f427f7c57d17" translate="yes" xml:space="preserve">
          <source>The default time-out is 5000 ms, unless otherwise specified. &lt;code&gt;timeout&lt;/code&gt; defines the time to wait for the process to respond to a request. If the process does not respond, the function evaluates &lt;code&gt;exit({timeout, {M, F, A}})&lt;/code&gt;.</source>
          <target state="translated">特に指定がない限り、デフォルトのタイムアウトは5000ミリ秒です。 &lt;code&gt;timeout&lt;/code&gt; は、プロセスがリクエストに応答するのを待つ時間を定義します。プロセスが応答しない場合、関数は &lt;code&gt;exit({timeout, {M, F, A}})&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="51ff8e06cc37d3f5fbc8359b214e014cbb5552d4" translate="yes" xml:space="preserve">
          <source>The default timeout is infinity</source>
          <target state="translated">デフォルトのタイムアウトは無限大です。</target>
        </trans-unit>
        <trans-unit id="517719740380d1d0fe303f5c01cd73d6a4f1b6a9" translate="yes" xml:space="preserve">
          <source>The default type (and currently the only type) of crypto algorithm is &lt;code&gt;des3_cbc&lt;/code&gt;, three rounds of DES. The key string is scrambled using &lt;code&gt;erlang:md5/1&lt;/code&gt; to generate the keys used for &lt;code&gt;des3_cbc&lt;/code&gt;.</source>
          <target state="translated">暗号アルゴリズムのデフォルトのタイプ（現在のところ唯一のタイプ）は、DESの3ラウンドである &lt;code&gt;des3_cbc&lt;/code&gt; です。キー文字列は、 &lt;code&gt;erlang:md5/1&lt;/code&gt; を使用して &lt;code&gt;des3_cbc&lt;/code&gt; され、des3_cbcに使用されるキーを生成します。</target>
        </trans-unit>
        <trans-unit id="545949e03721db9053ce25eb33d2946d85caf9f1" translate="yes" xml:space="preserve">
          <source>The default type for a segment is integer. The default type does not depend on the value, even if the value is a literal. For example, the default type in &lt;code id=&quot;Defaults&quot;&gt;&amp;lt;&amp;lt;3.14&amp;gt;&amp;gt;&lt;/code&gt; is integer, not float.</source>
          <target state="translated">セグメントのデフォルトのタイプは整数です。値がリテラルであっても、デフォルトのタイプは値に依存しません。たとえば、 &lt;code id=&quot;Defaults&quot;&gt;&amp;lt;&amp;lt;3.14&amp;gt;&amp;gt;&lt;/code&gt; デフォルトの型は浮動小数点数ではなく整数です。</target>
        </trans-unit>
        <trans-unit id="9c04943ccaa1784066dde4b82fadc56a0e22b6e6" translate="yes" xml:space="preserve">
          <source>The default unit depends on the the type. For &lt;code&gt;integer&lt;/code&gt;, &lt;code&gt;float&lt;/code&gt;, and &lt;code&gt;bitstring&lt;/code&gt; it is 1. For binary it is 8.</source>
          <target state="translated">デフォルトの単位はタイプによって異なります。ための &lt;code&gt;integer&lt;/code&gt; 、 &lt;code&gt;float&lt;/code&gt; 、及び &lt;code&gt;bitstring&lt;/code&gt; それは8であるバイナリのための1です。</target>
        </trans-unit>
        <trans-unit id="55a938cf0dbdbfb06f3894ab3968c86b760e35c4" translate="yes" xml:space="preserve">
          <source>The default value for &lt;code&gt;Timeout&lt;/code&gt; is &lt;code&gt;infinity&lt;/code&gt;. If &lt;code&gt;Timeout&lt;/code&gt; is specified and no connection is accepted within the given time, &lt;code&gt;{error, timeout}&lt;/code&gt; is returned.</source>
          <target state="translated">&lt;code&gt;Timeout&lt;/code&gt; のデフォルト値は &lt;code&gt;infinity&lt;/code&gt; です。 &lt;code&gt;Timeout&lt;/code&gt; が指定され、指定された時間内に接続が受け入れられない場合、 &lt;code&gt;{error, timeout}&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="06729acf2bd67efa6a3b5f8c86f4f2fa259ed112" translate="yes" xml:space="preserve">
          <source>The default value for &lt;code&gt;Type&lt;/code&gt; is &lt;code&gt;normal&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Type&lt;/code&gt; のデフォルト値は &lt;code&gt;normal&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="79b49abd7127b03f5d3f046367a7810a9be6e9ef" translate="yes" xml:space="preserve">
          <source>The default value for both the limits is 10,000,000 in the Erlang VM. Notice that the recursion limit does not affect the stack depth of the VM, as PCRE for Erlang is compiled in such a way that the match function never does recursion on the C stack.</source>
          <target state="translated">両方の制限のデフォルト値はErlang VMでは10,000,000,000です。PCRE for Erlangはマッチ関数がCスタック上で再帰しないようにコンパイルされているので、再帰制限はVMのスタック深度に影響しないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="2a019fd353ccc57a4984f8ab73e895be35e2ceca" translate="yes" xml:space="preserve">
          <source>The default value for the &lt;code&gt;template&lt;/code&gt; configuration parameter depends on the value of the &lt;code&gt;single_line&lt;/code&gt; and &lt;code&gt;legacy_header&lt;/code&gt; configuration parameters as follows.</source>
          <target state="translated">&lt;code&gt;template&lt;/code&gt; 構成パラメーターのデフォルト値は、 &lt;code&gt;single_line&lt;/code&gt; および &lt;code&gt;legacy_header&lt;/code&gt; 構成パラメーターの値によって次のように異なります。</target>
        </trans-unit>
        <trans-unit id="0bf6d99215a41e23b30022357e71e9041cbda827" translate="yes" xml:space="preserve">
          <source>The default value is &lt;code&gt;0&lt;/code&gt;, which means that there is no upper limit. If supplied, the number of filenames returned to the SFTP client per &lt;code&gt;READDIR&lt;/code&gt; request is limited to at most the given value.</source>
          <target state="translated">デフォルト値は &lt;code&gt;0&lt;/code&gt; です。これは、上限がないことを意味します。指定した場合、 &lt;code&gt;READDIR&lt;/code&gt; 要求ごとにSFTPクライアントに返されるファイル名の数は、最大で指定された値に制限されます。</target>
        </trans-unit>
        <trans-unit id="8eb871dd540b5e77da06600e181f72827240ed7e" translate="yes" xml:space="preserve">
          <source>The default value is &lt;code&gt;262144&lt;/code&gt;</source>
          <target state="translated">デフォルト値は &lt;code&gt;262144&lt;/code&gt; です</target>
        </trans-unit>
        <trans-unit id="9199a189c47e6bb7d92e1a9dbf9ee3c0844e971b" translate="yes" xml:space="preserve">
          <source>The default value is &lt;code&gt;{0,infinity}&lt;/code&gt;.</source>
          <target state="translated">デフォルト値は &lt;code&gt;{0,infinity}&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="e4282a5ade1b153ec0ef3ef75770c03f967209ae" translate="yes" xml:space="preserve">
          <source>The default value is as required by RFC 3539: changing it results in non-standard behaviour that should only be used to simulate misbehaving nodes during test.</source>
          <target state="translated">デフォルト値はRFC 3539で要求されている通りです。この値を変更すると、標準外の動作になります。</target>
        </trans-unit>
        <trans-unit id="18ca71fb6a22d28ebdfdacf9ed5fe354e1ec6ffe" translate="yes" xml:space="preserve">
          <source>The default value is the &lt;code&gt;public_key&lt;/code&gt; entry in the list returned by &lt;code&gt;&lt;a href=&quot;#default_algorithms-0&quot;&gt;ssh:default_algorithms/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">デフォルト値は、 &lt;code&gt;&lt;a href=&quot;#default_algorithms-0&quot;&gt;ssh:default_algorithms/0&lt;/a&gt;&lt;/code&gt; によって返されるリストの &lt;code&gt;public_key&lt;/code&gt; エントリです。</target>
        </trans-unit>
        <trans-unit id="2af35d2902848146372b486ac1179095a26eda1a" translate="yes" xml:space="preserve">
          <source>The default value is used as the value of uninitialized entries, and cannot be changed once the array has been created.</source>
          <target state="translated">デフォルト値は、初期化されていないエントリの値として使用され、配列が作成されると変更することはできません。</target>
        </trans-unit>
        <trans-unit id="b459379a9db26d1ded876c98cb594522408f4fb6" translate="yes" xml:space="preserve">
          <source>The default value is: &lt;code&gt;{auth_method_kb_interactive_data, {&quot;SSH server&quot;, &quot;Enter password for \&quot;&quot;++User++&quot;\&quot;&quot;, &quot;password: &quot;, false}&amp;gt;&lt;/code&gt;</source>
          <target state="translated">デフォルト値は次のとおりです： &lt;code&gt;{auth_method_kb_interactive_data, {&quot;SSH server&quot;, &quot;Enter password for \&quot;&quot;++User++&quot;\&quot;&quot;, &quot;password: &quot;, false}&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="243fb9da1068fdc22926720a51604f4646125511" translate="yes" xml:space="preserve">
          <source>The default value of this option is &lt;code&gt;{ssh_file, []}&lt;/code&gt;.</source>
          <target state="translated">このオプションのデフォルト値は &lt;code&gt;{ssh_file, []}&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="3d73b09c02067144770d80033f5560b2a2552422" translate="yes" xml:space="preserve">
          <source>The default value reflects the fact that a transport module for a stream-oriented transport like TCP may not be able to recover from a message length error since such a transport must use the Message Length header to divide the incoming byte stream into individual Diameter messages. An invalid length leaves it with no reliable way to rediscover message boundaries, which may result in the failure of subsequent messages. See &lt;code&gt;&lt;a href=&quot;diameter_tcp&quot;&gt;diameter_tcp(3)&lt;/a&gt;&lt;/code&gt; for the behaviour of that module.</source>
          <target state="translated">デフォルト値は、TCPなどのストリーム指向トランスポートのトランスポートモジュールがメッセージ長エラーを回復できない場合があるという事実を反映しています。このようなトランスポートは、メッセージ長ヘッダーを使用して着信バイトストリームを個々のDiameterメッセージに分割する必要があるためです。長さが無効であると、メッセージの境界を再検出する信頼できる方法がなくなり、後続のメッセージが失敗する可能性があります。そのモジュールの動作については、 &lt;code&gt;&lt;a href=&quot;diameter_tcp&quot;&gt;diameter_tcp(3)&lt;/a&gt;&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="296cd192efc745b8c34964c030037a92790a5853" translate="yes" xml:space="preserve">
          <source>The default value used is normally &lt;code&gt;65536&lt;/code&gt;. However, if the runtime system is able to determine maximum amount of file descriptors that it is allowed to open and this value is larger than &lt;code&gt;65536&lt;/code&gt;, the chosen value will increased to a value larger or equal to the maximum amount of file descriptors that can be opened.</source>
          <target state="translated">使用されるデフォルト値は通常 &lt;code&gt;65536&lt;/code&gt; です。ただし、ランタイムシステムが開くことを許可されているファイル記述子の最大量を判別でき、この値が &lt;code&gt;65536&lt;/code&gt; より大きい場合、選択した値は、ファイル記述子の最大量以上の値に増加します。開いた。</target>
        </trans-unit>
        <trans-unit id="5e3d6bd0706de8063989ab67ca84fec01864e172" translate="yes" xml:space="preserve">
          <source>The default values are 1 restart per 5 seconds. This was chosen to be safe for most systems, even with deep supervision hierarchies, but you will probably want to tune the settings for your particular use case.</source>
          <target state="translated">デフォルト値は5秒に1回の再起動です。これは、深い監視階層を使用している場合でも、ほとんどのシステムで安全に使用できるように選択されていますが、特定のユースケースに合わせて設定を調整したいと思うでしょう。</target>
        </trans-unit>
        <trans-unit id="a4e004a8abd563009ef32e5cba1400cabe8dffcb" translate="yes" xml:space="preserve">
          <source>The default values for options specified to &lt;code&gt;connect&lt;/code&gt; can be affected by the Kernel configuration parameter &lt;code&gt;inet_default_connect_options&lt;/code&gt;. For details, see &lt;code&gt;&lt;a href=&quot;inet&quot;&gt;inet(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;connect&lt;/code&gt; 指定されたオプションのデフォルト値は、カーネル構成パラメーター &lt;code&gt;inet_default_connect_options&lt;/code&gt; の影響を受ける可能性があります。詳細については、 &lt;code&gt;&lt;a href=&quot;inet&quot;&gt;inet(3)&lt;/a&gt;&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="40a15125494e475b38c160cdf12b36e7e3d1c3f9" translate="yes" xml:space="preserve">
          <source>The default values for options specified to &lt;code&gt;listen&lt;/code&gt; can be affected by the Kernel configuration parameter &lt;code&gt;inet_default_listen_options&lt;/code&gt;. For details, see &lt;code&gt;&lt;a href=&quot;inet&quot;&gt;inet(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">オプションのデフォルト値は、指定し &lt;code&gt;listen&lt;/code&gt; カーネル設定パラメータによって影響を受ける可能性が &lt;code&gt;inet_default_listen_options&lt;/code&gt; 。詳細については、 &lt;code&gt;&lt;a href=&quot;inet&quot;&gt;inet(3)&lt;/a&gt;&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="50fa0bf131c13c670fdcc5fdce169d626f359cef" translate="yes" xml:space="preserve">
          <source>The default values for the &lt;code&gt;originating&lt;/code&gt; discovery options are:</source>
          <target state="translated">&lt;code&gt;originating&lt;/code&gt; 検出オプションのデフォルト値は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="9cb324b22317eaf8bd729f045fc4512eed8d2afc" translate="yes" xml:space="preserve">
          <source>The default values for the &lt;code&gt;terminating&lt;/code&gt; discovery options are:</source>
          <target state="translated">&lt;code&gt;terminating&lt;/code&gt; 検出オプションのデフォルト値は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="8b5bd661368c7d8e299861344ca3c98352edac6c" translate="yes" xml:space="preserve">
          <source>The default values of the send options are obtained by &lt;code&gt;megaco:conn_info(ConnHandle, Item)&lt;/code&gt;. But the send options above, may explicitly be overridden.</source>
          <target state="translated">送信オプションのデフォルト値は、 &lt;code&gt;megaco:conn_info(ConnHandle, Item)&lt;/code&gt; によって取得されます。ただし、上記の送信オプションは、明示的にオーバーライドされる場合があります。</target>
        </trans-unit>
        <trans-unit id="b0aa1b655582755f5f4811f0eab7ca8a5d9f4319" translate="yes" xml:space="preserve">
          <source>The default values of the send options are obtained by megaco:conn_info(ConnHandle, Item). But the send options above, may explicitly be overridden.</source>
          <target state="translated">送信オプションのデフォルト値は megaco:conn_info(ConnHandle,Item)で取得します。しかし、上記の送信オプションは、明示的にオーバーライドすることができます。</target>
        </trans-unit>
        <trans-unit id="2ebf5b11205a5dd9778e91c6bfcc585a8fc51478" translate="yes" xml:space="preserve">
          <source>The default verbosity is &lt;code&gt;1&lt;/code&gt;. Verbosity &lt;code&gt;0&lt;/code&gt; can also be selected by option &lt;code&gt;nowarn_format&lt;/code&gt;.</source>
          <target state="translated">デフォルトの詳細度は &lt;code&gt;1&lt;/code&gt; です。詳細度 &lt;code&gt;0&lt;/code&gt; は、オプション &lt;code&gt;nowarn_format&lt;/code&gt; でも選択できます。</target>
        </trans-unit>
        <trans-unit id="d8f7ea1b49fdcb48ab2c2517d37ecba5139e4ff8" translate="yes" xml:space="preserve">
          <source>The default when a connection is established between two nodes, is to immediately connect all other visible nodes as well. This way, there is always a fully connected network. If there are nodes with different cookies, this method can be inappropriate and the command-line flag &lt;code&gt;-connect_all false&lt;/code&gt; must be set, see the &lt;code&gt;erl(1)&lt;/code&gt; manual page in ERTS.</source>
          <target state="translated">2つのノード間で接続が確立されたときのデフォルトでは、他のすべての可視ノードもすぐに接続されます。このように、常に完全に接続されたネットワークがあります。異なるCookieを持つノードがある場合、このメソッドは不適切な場合があり、コマンドラインフラグ &lt;code&gt;-connect_all false&lt;/code&gt; を設定する必要があります。ERTSの &lt;code&gt;erl(1)&lt;/code&gt; マニュアルページを参照してください。</target>
        </trans-unit>
        <trans-unit id="3cf210e7ecc7b461b7955d0d98ee29107a5a6b0b" translate="yes" xml:space="preserve">
          <source>The default. Only characters in the ISO Latin-1 range can be considered printable. This means that a character with a code point &amp;gt; 255 is never considered printable and that lists containing such characters are displayed as lists of integers rather than text strings by tools.</source>
          <target state="translated">デフォルト。ISO Latin-1範囲の文字のみが印刷可能と見なされます。つまり、コードポイントが255を超える文字は印刷可能とは見なされず、そのような文字を含むリストは、ツールによってテキスト文字列ではなく整数のリストとして表示されます。</target>
        </trans-unit>
        <trans-unit id="11fa3688f9aa1dc5e88e515adb5d88b7a205fe35" translate="yes" xml:space="preserve">
          <source>The definition of &lt;code&gt;ErlMessage&lt;/code&gt; has changed since earlier versions of &lt;code&gt;Erl_Interface&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ErlMessage&lt;/code&gt; の定義は、以前のバージョンの &lt;code&gt;Erl_Interface&lt;/code&gt; 以降変更されています。</target>
        </trans-unit>
        <trans-unit id="6fdae1ac6fb499a05429a1e07e8362960f5b8b56" translate="yes" xml:space="preserve">
          <source>The definition of a busy scheduler is when it is not idle and is not scheduling (selecting) a process or port, that is:</source>
          <target state="translated">ビジースケジューラの定義は、アイドル状態ではなく、プロセスやポートをスケジューリング(選択)していない状態、つまりビジー状態になっているときです。</target>
        </trans-unit>
        <trans-unit id="82ba3b05846ab652707aa41300a0f8920d31d2e5" translate="yes" xml:space="preserve">
          <source>The degree to which the service allows multiple transport connections to the same peer, as identified by its Origin-Host at capabilities exchange.</source>
          <target state="translated">サービスが同一ピアへの複数のトランスポート接続を許可する程度(能力交換時にOrigin-Hostによって識別される)。</target>
        </trans-unit>
        <trans-unit id="995215813ca9fa0e2bcd7a40357169c4691820c6" translate="yes" xml:space="preserve">
          <source>The delivery of trace messages (generated by &lt;code&gt;&lt;a href=&quot;#trace-3&quot;&gt;erlang:trace/3&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;seq_trace(3)&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;#system_profile-2&quot;&gt;erlang:system_profile/2&lt;/a&gt;&lt;/code&gt;) is dislocated on the time-line compared to other events in the system. If you know that &lt;code&gt;Tracee&lt;/code&gt; has passed some specific point in its execution, and you want to know when at least all trace messages corresponding to events up to this point have reached the tracer, use &lt;code&gt;erlang:trace_delivered(Tracee)&lt;/code&gt;.</source>
          <target state="translated">トレースメッセージ（ &lt;code&gt;&lt;a href=&quot;#trace-3&quot;&gt;erlang:trace/3&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;seq_trace(3)&lt;/code&gt; 、または &lt;code&gt;&lt;a href=&quot;#system_profile-2&quot;&gt;erlang:system_profile/2&lt;/a&gt;&lt;/code&gt; によって生成される）の配信は、システム内の他のイベントと比較して、タイムライン上で位置がずれています。 &lt;code&gt;Tracee&lt;/code&gt; が実行の特定のポイントを通過したことがわかっていて、少なくともこのポイントまでのイベントに対応するすべてのトレースメッセージがトレーサーに到達したことを知りたい場合は、 &lt;code&gt;erlang:trace_delivered(Tracee)&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="ef74e5139b7ce6e4f98a4baef24c6182968b430c" translate="yes" xml:space="preserve">
          <source>The dependecies are created as a side effect to the normal compilation process. This means that the object file will also be produced. This option override the &lt;code&gt;makedep&lt;/code&gt; option.</source>
          <target state="translated">依存関係は、通常のコンパイルプロセスの副作用として作成されます。つまり、オブジェクトファイルも作成されます。このオプションは &lt;code&gt;makedep&lt;/code&gt; オプションをオーバーライドします。</target>
        </trans-unit>
        <trans-unit id="d1ab3d1ea275bdf26541729c8fac923c58fe1c95" translate="yes" xml:space="preserve">
          <source>The dependency graph windows are launched from the file menu in the system window. The graph depicts all included and derived applications/modules and their dependencies.</source>
          <target state="translated">依存関係グラフウィンドウは、システムウィンドウのファイルメニューから起動します。グラフには、すべての含まれるアプリケーションと派生アプリケーション/モジュール、およびそれらの依存関係が表示されます。</target>
        </trans-unit>
        <trans-unit id="2a97d6fbaa7c8cc7934aab7b5d9a9bb87b6b518f" translate="yes" xml:space="preserve">
          <source>The described durability feature does not entirely apply to situations where &lt;code&gt;Mnesia&lt;/code&gt; is configured as a &quot;pure&quot; primary memory database.</source>
          <target state="translated">説明されている耐久性機能は、 &lt;code&gt;Mnesia&lt;/code&gt; が「純粋な」プライマリメモリデータベースとして構成されている状況に完全には適用されません。</target>
        </trans-unit>
        <trans-unit id="c5fd3c33ad96d6f9da0b92a6b9de73850c0f031c" translate="yes" xml:space="preserve">
          <source>The described syntax can also be used in test specifications to change group properties at the time of execution, without having to edit the test suite. For more information, see section &lt;code&gt;&lt;a href=&quot;run_test_chapter#test_specifications&quot;&gt;Test Specifications&lt;/a&gt;&lt;/code&gt; in section Running Tests and Analyzing Results.</source>
          <target state="translated">説明した構文をテスト仕様で使用して、テストスイートを編集することなく、実行時にグループプロパティを変更することもできます。詳細については、「 &lt;code&gt;&lt;a href=&quot;run_test_chapter#test_specifications&quot;&gt;Test Specifications&lt;/a&gt;&lt;/code&gt; 実行と結果の分析」のセクションの「テスト仕様」を参照してください。</target>
        </trans-unit>
        <trans-unit id="086c0b30f28f757ab34cbfdd1e7d1db76083baee" translate="yes" xml:space="preserve">
          <source>The description is based on &lt;code&gt;&lt;a href=&quot;http://www.erlang.org/eeps/eep-0008.html&quot;&gt;EEP8 - Types and function specifications&lt;/a&gt;&lt;/code&gt;, which is not to be further updated.</source>
          <target state="translated">この説明は、 &lt;code&gt;&lt;a href=&quot;http://www.erlang.org/eeps/eep-0008.html&quot;&gt;EEP8 - Types and function specifications&lt;/a&gt;&lt;/code&gt; に基づいており、今後更新される予定はありません。</target>
        </trans-unit>
        <trans-unit id="b29537c79e1bc001111fcb298cafeaf2c947455f" translate="yes" xml:space="preserve">
          <source>The descriptions of the options uses the &lt;code&gt;Erlang Type Language&lt;/code&gt; with explaining text.</source>
          <target state="translated">オプションの説明では、 &lt;code&gt;Erlang Type Language&lt;/code&gt; と説明テキストを使用しています。</target>
        </trans-unit>
        <trans-unit id="45a17206933877eeb5bf9c5379a4ed51695a5147" translate="yes" xml:space="preserve">
          <source>The destination of these log events was configured by &lt;code&gt;SASL configuration parameters&lt;/code&gt;.</source>
          <target state="translated">これらのログイベントの宛先は、 &lt;code&gt;SASL configuration parameters&lt;/code&gt; によって構成されました。</target>
        </trans-unit>
        <trans-unit id="1700577536e62effc25b554cb01dfedd3d5fe8bb" translate="yes" xml:space="preserve">
          <source>The details of finding other nodes (that is, talking to &lt;code&gt;epmd&lt;/code&gt; or something similar)</source>
          <target state="translated">他のノードを見つける詳細（つまり、 &lt;code&gt;epmd&lt;/code&gt; または類似のノードと通信する）</target>
        </trans-unit>
        <trans-unit id="8904690d17dfc4476f5a61b68a154f7e139b04e4" translate="yes" xml:space="preserve">
          <source>The development package of OpenSSL including the header files are needed as well as the binary command program &lt;code&gt;openssl&lt;/code&gt;. At least version 0.9.8 of OpenSSL is required. Read more and download from &lt;code&gt;&lt;a href=&quot;http://www.openssl.org&quot;&gt;http://www.openssl.org&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">ヘッダーファイルを含むOpenSSLの開発パッケージと、バイナリコマンドプログラム &lt;code&gt;openssl&lt;/code&gt; が必要です。OpenSSLのバージョン0.9.8以降が必要です。詳細については、 &lt;code&gt;&lt;a href=&quot;http://www.openssl.org&quot;&gt;http://www.openssl.org&lt;/a&gt;&lt;/code&gt; //www.openssl.orgからダウンロードしてください。</target>
        </trans-unit>
        <trans-unit id="7d180f092b7b3bd940337d54bfa93d4b66eb9f08" translate="yes" xml:space="preserve">
          <source>The diameter application includes five dictionary modules corresponding to applications defined in section 2.4 of RFC 6733: &lt;code&gt;diameter_gen_base_rfc3588&lt;/code&gt; and &lt;code&gt;diameter_gen_base_rfc6733&lt;/code&gt; for the Diameter Common Messages application with application identifier 0, &lt;code&gt;diameter_gen_accounting&lt;/code&gt; (for RFC 3588) and &lt;code&gt;diameter_gen_acct_rfc6733&lt;/code&gt; for the Diameter Base Accounting application with application identifier 3 and &lt;code&gt;diameter_gen_relay&lt;/code&gt; the Relay application with application identifier 0xFFFFFFFF.</source>
          <target state="translated">Diameterアプリケーションには、RFC 6733のセクション2.4で定義されたアプリケーションに対応する5つのディクショナリモジュールが含まれています。Diameter 共通メッセージアプリケーションの &lt;code&gt;diameter_gen_base_rfc3588&lt;/code&gt; と &lt;code&gt;diameter_gen_base_rfc6733&lt;/code&gt; 、アプリケーション識別子0、 &lt;code&gt;diameter_gen_accounting&lt;/code&gt; （RFC 3588の場合）、および &lt;code&gt;diameter_gen_acct_rfc6733&lt;/code&gt; Base AccountingアプリケーションのDiameter Base Accountingアプリケーションの場合、diameter_gen_acct_rfc6733そして、 &lt;code&gt;diameter_gen_relay&lt;/code&gt; アプリケーション識別子が0xFFFFFFFFのリレーアプリケーション。</target>
        </trans-unit>
        <trans-unit id="55ad411fdd3feccef9ab5e2a70e1c6ecf0dda6f6" translate="yes" xml:space="preserve">
          <source>The diameter application is an implementation of the Diameter protocol as defined by RFC 6733. It supports arbitrary Diameter applications by way of a &lt;strong&gt;dictionary&lt;/strong&gt; interface that allows messages and AVPs to be defined and input into diameter as configuration. It has support for all roles defined in the RFC: client, server and agent. This chapter provides a short overview of the application.</source>
          <target state="translated">Diameterアプリケーションは、RFC 6733で定義されているDiameterプロトコルの実装です。メッセージとAVPを定義し、diameterに構成として入力できるようにする&lt;strong&gt;ディクショナリ&lt;/strong&gt;インターフェイスを介して、任意のDiameterアプリケーションをサポートします。RFCで定義されているすべてのロール（クライアント、サーバー、エージェント）をサポートしています。この章では、アプリケーションの簡単な概要を説明します。</target>
        </trans-unit>
        <trans-unit id="b44b3ae3e6de975127d9868877e61eebf74c5fa6" translate="yes" xml:space="preserve">
          <source>The diameter application must be started before calling most functions in this module.</source>
          <target state="translated">このモジュールのほとんどの関数を呼び出す前に、直径アプリケーションを開始する必要があります。</target>
        </trans-unit>
        <trans-unit id="5970544b2f23768c3400e92a3796dc5f84073d7d" translate="yes" xml:space="preserve">
          <source>The diameter application must be started before starting a service. In a production system this is typically accomplished by a boot file, not by calling &lt;code&gt;start/0&lt;/code&gt; explicitly.</source>
          <target state="translated">サービスを開始する前に、直径アプリケーションを開始する必要があります。本番システムでは、これは通常、 &lt;code&gt;start/0&lt;/code&gt; を明示的に呼び出すのではなく、ブートファイルによって行われます。</target>
        </trans-unit>
        <trans-unit id="8d87148c3c9af3d9845486aa30c973c1b2043ba3" translate="yes" xml:space="preserve">
          <source>The diameter application takes responsibility for exchanging CER/CEA with the peer. Upon successful completion of capabilities exchange the service calls each relevant application module's &lt;code&gt;peer_up/3&lt;/code&gt; callback after which the caller can exchange Diameter messages with the peer over the transport. In addition to CER/CEA, the service takes responsibility for the handling of DWR/DWA and required by RFC 3539, as well as for DPR/DPA.</source>
          <target state="translated">直径アプリケーションは、ピアとのCER / CEAの交換を担当します。機能交換が正常に完了すると、サービスは関連する各アプリケーションモジュールの &lt;code&gt;peer_up/3&lt;/code&gt; コールバックを呼び出します。その後、発信者はトランスポートを介してピアとDiameterメッセージを交換できます。 CER / CEAに加えて、サービスはDWR / DWAの処理およびRFC 3539で必要とされるDPR / DPAの処理を担当します。</target>
        </trans-unit>
        <trans-unit id="fb2713bf78bad945032228e7d72a8fff3c2317e0" translate="yes" xml:space="preserve">
          <source>The diameter user does not need to call functions here explicitly when sending and receiving messages using &lt;code&gt;&lt;a href=&quot;diameter#call-4&quot;&gt;diameter:call/4&lt;/a&gt;&lt;/code&gt; and the callback interface documented in &lt;code&gt;diameter_app(3)&lt;/code&gt;: diameter itself provides encode/decode as a consequence of configuration passed to &lt;code&gt;&lt;a href=&quot;diameter#start_service-2&quot;&gt;diameter:start_service/2&lt;/a&gt;&lt;/code&gt;, and the results may differ from those returned by the functions documented here, depending on configuration.</source>
          <target state="translated">直径ユーザーは、 &lt;code&gt;&lt;a href=&quot;diameter#call-4&quot;&gt;diameter:call/4&lt;/a&gt;&lt;/code&gt; を使用してメッセージを送受信する場合、ここで関数を明示的に呼び出す必要はありません。また、 &lt;code&gt;diameter_app(3)&lt;/code&gt; に記載されているコールバックインターフェイス：直径自体は、 &lt;code&gt;&lt;a href=&quot;diameter#start_service-2&quot;&gt;diameter:start_service/2&lt;/a&gt;&lt;/code&gt; 渡される構成の結果としてエンコード/デコードを提供します。2。結果は、構成によっては、ここで説明する関数によって返される結果と異なる場合があります。</target>
        </trans-unit>
        <trans-unit id="2251e3cdeb76f922995ac0b63ebf88f13a0667db" translate="yes" xml:space="preserve">
          <source>The diameterc utility is used to compile a diameter &lt;code&gt;&lt;a href=&quot;diameter_dict&quot;&gt;dictionary file&lt;/a&gt;&lt;/code&gt; into Erlang source. The resulting source implements the interface diameter required to encode and decode the dictionary's messages and AVPs.</source>
          <target state="translated">diametercユーティリティは、Erlangソースに直径 &lt;code&gt;&lt;a href=&quot;diameter_dict&quot;&gt;dictionary file&lt;/a&gt;&lt;/code&gt; をコンパイルするために使用されます。結果のソースは、ディクショナリのメッセージとAVPのエンコードとデコードに必要なインターフェイスの直径を実装します。</target>
        </trans-unit>
        <trans-unit id="a8b611f53150beb161ae68d1baa02e238a69d7fe" translate="yes" xml:space="preserve">
          <source>The dictionary chosen by the compressor can be determined from the Adler value returned or thrown by the call to the inflate function. The compressor and decompressor must use the same dictionary (See &lt;code&gt;&lt;a href=&quot;#deflateSetDictionary-2&quot;&gt;deflateSetDictionary/2&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">コンプレッサーによって選択されたディクショナリは、inflate関数の呼び出しによって返された、またはスローされたアドラー値から決定できます。コンプレッサーと &lt;code&gt;&lt;a href=&quot;#deflateSetDictionary-2&quot;&gt;deflateSetDictionary/2&lt;/a&gt;&lt;/code&gt; は同じ辞書を使用する必要があります（deflateSetDictionary / 2を参照）。</target>
        </trans-unit>
        <trans-unit id="dc7c7b0117c79bf085087df0d9077cbcde71b86c" translate="yes" xml:space="preserve">
          <source>The dictionary interface documented in &lt;code&gt;&lt;a href=&quot;diameter_dict&quot;&gt;diameter_dict(4)&lt;/a&gt;&lt;/code&gt; provides extensibility, allowing the user to defined new AVPs, commands, and applications. Ready dictionaries are provided for the RFC 6733 common message, base accounting, and relay applications, as well as for RFC 7683, Diameter Overload Indicator Conveyance.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;diameter_dict&quot;&gt;diameter_dict(4)&lt;/a&gt;&lt;/code&gt; で説明されているディクショナリインターフェイスは拡張性を提供し、ユーザーが新しいAVP、コマンド、およびアプリケーションを定義できるようにします。RFC 6733共通メッセージ、基本アカウンティング、リレーアプリケーション、およびRFC 7683、Diameter Overload Indicator Conveyanceの準備が整った辞書が提供されています。</target>
        </trans-unit>
        <trans-unit id="569d4e7fc1379c78daae74de968aa2107c8de266" translate="yes" xml:space="preserve">
          <source>The difference between &lt;code&gt;set&lt;/code&gt;, &lt;code&gt;bag&lt;/code&gt;, and &lt;code&gt;duplicate_bag&lt;/code&gt; on one hand, and &lt;code&gt;ordered_set&lt;/code&gt; on the other, regarding the fact that &lt;code&gt;ordered_set&lt;/code&gt; view keys as equal when they &lt;strong&gt;compare equal&lt;/strong&gt; whereas the other table types regard them equal only when they &lt;strong&gt;match&lt;/strong&gt;, holds for &lt;code&gt;lookup_element/3&lt;/code&gt;.</source>
          <target state="translated">差 &lt;code&gt;set&lt;/code&gt; 、 &lt;code&gt;bag&lt;/code&gt; 、および &lt;code&gt;duplicate_bag&lt;/code&gt; 一方で、および &lt;code&gt;ordered_set&lt;/code&gt; という事実に関する他に、 &lt;code&gt;ordered_set&lt;/code&gt; の等しいとしてビューキーはそれらが&lt;strong&gt;等しいと&lt;/strong&gt;他のテーブルタイプは、彼らはときにそれらのみ等しいとみなす一方&lt;strong&gt;一致は&lt;/strong&gt;、当てはまる &lt;code&gt;lookup_element/3&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="623ffdc435a2f724f0836bec7cc8ec30bc41c15a" translate="yes" xml:space="preserve">
          <source>The difference between lists as semantic objects (built up of individual &quot;cons&quot; and &quot;nil&quot; terms) and the various syntactic forms for denoting lists may be bewildering at first. This module provides functions both for exact control of the syntactic representation as well as for the simple composition and deconstruction in terms of cons and head/tail operations.</source>
          <target state="translated">意味オブジェクトとしてのリスト (個々の &quot;cons &quot;と &quot;nil &quot;の項で構成されている)と、リストを表現するための様々な構文形式の違いは、最初は戸惑うかもしれません。このモジュールは、統語表現を正確に制御するための機能と、 cons と head/tail 演算による単純な構成と分解のための機能の両方を提供します。</target>
        </trans-unit>
        <trans-unit id="da1728bb07e837f250209bb055d7409170953dd6" translate="yes" xml:space="preserve">
          <source>The difference between the &lt;code&gt;config&lt;/code&gt; terms above is that with &lt;code&gt;ConfigDir&lt;/code&gt;, &lt;code&gt;ConfigBaseNames&lt;/code&gt; is a list of base names, that is, without directory paths. &lt;code&gt;ConfigFiles&lt;/code&gt; must be full names, including paths. For example, the following two terms have the same meaning:</source>
          <target state="translated">差 &lt;code&gt;config&lt;/code&gt; 用語は、上記とすることである &lt;code&gt;ConfigDir&lt;/code&gt; 、 &lt;code&gt;ConfigBaseNames&lt;/code&gt; は、ディレクトリ・パスなしで、ある基地名のリストです。 &lt;code&gt;ConfigFiles&lt;/code&gt; は、パスを含む完全な名前にする必要があります。たとえば、次の2つの用語は同じ意味です。</target>
        </trans-unit>
        <trans-unit id="4f869b97b89ad5b7b934ce2b75aa574db5f22948" translate="yes" xml:space="preserve">
          <source>The difference between the two functions is in how they get the modules to check. &lt;code&gt;versions1&lt;/code&gt; uses the app-file and &lt;code&gt;versions2&lt;/code&gt; uses the function &lt;code&gt;application:get_key&lt;/code&gt;.</source>
          <target state="translated">2つの関数の違いは、モジュールがチェックする方法にあります。 &lt;code&gt;versions1&lt;/code&gt; はapp-fileを使用し、 &lt;code&gt;versions2&lt;/code&gt; は &lt;code&gt;application:get_key&lt;/code&gt; 関数を使用します。</target>
        </trans-unit>
        <trans-unit id="633f35639fdb5cc1cb10fd8f4689bf3336703581" translate="yes" xml:space="preserve">
          <source>The difference between these functions is the order the table is accessed for &lt;code&gt;ordered_set&lt;/code&gt; tables. For other table types the functions are equivalent.</source>
          <target state="translated">これらの関数の違いは、 &lt;code&gt;ordered_set&lt;/code&gt; テーブルでテーブルにアクセスする順序です。他のテーブルタイプの場合、関数は同等です。</target>
        </trans-unit>
        <trans-unit id="293fb4be14373398bacd278126f271ff3f4aab95" translate="yes" xml:space="preserve">
          <source>The difference between using the macros and the exported functions is that macros add location (originator) information to the metadata, and performs lazy evaluation by wrapping the logger call in a case statement, so it is only evaluated if the log level of the event passes the primary log level check.</source>
          <target state="translated">マクロを使う場合とエクスポートされた関数を使う場合の違いは、マクロはメタデータに位置情報(発信元)を追加し、ロガーコールをcase文でラップして遅延評価を行うため、イベントのログレベルがプライマリログレベルチェックを通過した場合にのみ評価されます。</target>
        </trans-unit>
        <trans-unit id="9bd33d3347fbec04e6dd5bced0f65f041be1e03c" translate="yes" xml:space="preserve">
          <source>The difference here is that a check is made for two keys in each map argument. The other keys are ignored.</source>
          <target state="translated">ここでの違いは、各マップの引数で2つのキーに対してチェックが行われていることです。他のキーは無視されます。</target>
        </trans-unit>
        <trans-unit id="57afc2a6da2d7ad1a93ff6f446c9b773c487ccf9" translate="yes" xml:space="preserve">
          <source>The difference is the same as between &lt;code&gt;=:=&lt;/code&gt; and &lt;code&gt;==&lt;/code&gt;.</source>
          <target state="translated">違いは、 &lt;code&gt;=:=&lt;/code&gt; と &lt;code&gt;==&lt;/code&gt; の場合と同じです。</target>
        </trans-unit>
        <trans-unit id="37953effd4c1eb8de7eafd4f2558c81bd077904b" translate="yes" xml:space="preserve">
          <source>The different amounts of memory that are summed are &lt;strong&gt;not&lt;/strong&gt; gathered atomically, which introduces an error in the result.</source>
          <target state="translated">合計される異なる量のメモリはアトミックに収集され&lt;strong&gt;ない&lt;/strong&gt;ため、結果にエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="63548572b896ecd0cf28068a1070f068efa94f1e" translate="yes" xml:space="preserve">
          <source>The different applications use different strategies for loading the MIBs into the agent. Some MIB implementations are code-only, while others need a server. One way, used by the code-only MIB implementations, is for the user to call a function such as &lt;code&gt;otp_mib:load(Agent)&lt;/code&gt; to load the MIB, and &lt;code&gt;otp_mib:unload(Agent)&lt;/code&gt; to unload the MIB. See the manual page for each application for a description of how to load each MIB.</source>
          <target state="translated">異なるアプリケーションは、MIBをエージェントにロードするための異なる戦略を使用します。一部のMIB実装はコードのみですが、MIB実装にはサーバーが必要です。コードのみのMIB実装で使用される1つの方法は、ユーザーが &lt;code&gt;otp_mib:load(Agent)&lt;/code&gt; などの関数を呼び出してMIBをロードし、 &lt;code&gt;otp_mib:unload(Agent)&lt;/code&gt; を呼び出してMIBをアンロードすることです。各MIBをロードする方法の説明については、各アプリケーションのマニュアルページを参照してください。</target>
        </trans-unit>
        <trans-unit id="b79b82512ebbf07ebe9d9f10fb15d9e8e743cedd" translate="yes" xml:space="preserve">
          <source>The different options that can be given to &lt;code&gt;&lt;a href=&quot;#print-2&quot;&gt;print/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#print-2&quot;&gt;print/2&lt;/a&gt;&lt;/code&gt; に指定できるさまざまなオプション。</target>
        </trans-unit>
        <trans-unit id="c7a06445034a6453f0f6ebe99a200207183eacb6" translate="yes" xml:space="preserve">
          <source>The different queries are described in section &lt;code&gt;&lt;a href=&quot;#interactive_flags&quot;&gt;Interactive options&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">さまざまなクエリについては、 &lt;code&gt;&lt;a href=&quot;#interactive_flags&quot;&gt;Interactive options&lt;/a&gt;&lt;/code&gt; セクションで説明しています。</target>
        </trans-unit>
        <trans-unit id="8fc4891f4df1692cd0b3f6e8badc0320a795dc5b" translate="yes" xml:space="preserve">
          <source>The different states that a thread can be in. See &lt;code&gt;erlang:statistics(microstate_accounting)&lt;/code&gt; for details.</source>
          <target state="translated">スレッドが &lt;code&gt;erlang:statistics(microstate_accounting)&lt;/code&gt; 得るさまざまな状態。詳細については、erlang：statistics（microstate_accounting）を参照してください。</target>
        </trans-unit>
        <trans-unit id="59070d2c07904f6e20fde995a37ca6d79f115caa" translate="yes" xml:space="preserve">
          <source>The different trace tags that the tracer is called with. Each trace tag is described in detail in &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">トレーサーが呼び出されるさまざまなトレースタグ。各トレースタグについては、 &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; で詳しく説明しています。</target>
        </trans-unit>
        <trans-unit id="26366e48ea2a96c9fc5d9a43d23aaffa5017f9cd" translate="yes" xml:space="preserve">
          <source>The different types are as follows:</source>
          <target state="translated">種類は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="33105c1c6606db02bff579f3c5759de25bdebf48" translate="yes" xml:space="preserve">
          <source>The different types of schedulers handle specific types of jobs. Every job is assigned to a specific scheduler type. Jobs can migrate between different schedulers of the same type, but never between schedulers of different types. This fact has to be taken under consideration when evaluating the result returned.</source>
          <target state="translated">異なるタイプのスケジューラは、特定のタイプのジョブを処理します。すべてのジョブは特定のスケジューラタイプに割り当てられます。ジョブは同じタイプの異なるスケジューラ間では移行できますが、異なるタイプのスケジューラ間では移行できません。返された結果を評価する際には、この事実を考慮しなければなりません。</target>
        </trans-unit>
        <trans-unit id="1be30a2a4e12fc360bee8dc49ed629e5a73999d2" translate="yes" xml:space="preserve">
          <source>The different values have the following relation to each other. Values beginning with an uppercase letter is not part of the result.</source>
          <target state="translated">異なる値は互いに以下のような関係を持っています。大文字で始まる値は結果に含まれません。</target>
        </trans-unit>
        <trans-unit id="27f3bb8909ba5f23310f5128f455bc5958825585" translate="yes" xml:space="preserve">
          <source>The digraph can be read and modified by the creating process only.</source>
          <target state="translated">ディグラフは、作成処理のみで読み込んで修正することができます。</target>
        </trans-unit>
        <trans-unit id="5490f515ffc9d05efae42bd4eb4b5cd4c506605c" translate="yes" xml:space="preserve">
          <source>The digraph is to be kept &lt;code&gt;&lt;a href=&quot;#acyclic_digraph&quot;&gt;acyclic&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">有向グラフは &lt;code&gt;&lt;a href=&quot;#acyclic_digraph&quot;&gt;acyclic&lt;/a&gt;&lt;/code&gt; に保たれるべきです。</target>
        </trans-unit>
        <trans-unit id="08c044f6070f82e882ec6b0eabc539f770d3dd32" translate="yes" xml:space="preserve">
          <source>The directive &lt;code&gt;-error(Term)&lt;/code&gt; causes a compilation error.</source>
          <target state="translated">ディレクティブ &lt;code&gt;-error(Term)&lt;/code&gt; はコンパイルエラーを引き起こします。</target>
        </trans-unit>
        <trans-unit id="b3797b9e1d8ee2883c9f63d0a42a95ca4d06540e" translate="yes" xml:space="preserve">
          <source>The directive &lt;code&gt;-warning(Term)&lt;/code&gt; causes a compilation warning.</source>
          <target state="translated">ディレクティブ &lt;code&gt;-warning(Term)&lt;/code&gt; はコンパイル警告を引き起こします。</target>
        </trans-unit>
        <trans-unit id="58617ed5f0889f1d1f3277ea479ef4c02a22c0a7" translate="yes" xml:space="preserve">
          <source>The directories given by the &lt;code&gt;include&lt;/code&gt; option</source>
          <target state="translated">&lt;code&gt;include&lt;/code&gt; オプションで指定されたディレクトリ</target>
        </trans-unit>
        <trans-unit id="1f52da4640ac6f1c489638d9eafbfb94f7337064" translate="yes" xml:space="preserve">
          <source>The directories specified using option &lt;code&gt;-I&lt;/code&gt;; the directory specified last is searched first</source>
          <target state="translated">オプション &lt;code&gt;-I&lt;/code&gt; を使用して指定されたディレクトリ。最後に指定されたディレクトリが最初に検索されます</target>
        </trans-unit>
        <trans-unit id="071745beb88d646a425661fabb7b2b140020baaf" translate="yes" xml:space="preserve">
          <source>The directories specified using option &lt;code&gt;i&lt;/code&gt;; the directory specified last is searched first</source>
          <target state="translated">オプション &lt;code&gt;i&lt;/code&gt; を使用して指定されたディレクトリ。最後に指定されたディレクトリが最初に検索されます</target>
        </trans-unit>
        <trans-unit id="be6fba73ebc340991bdfb6820c1ebc97ba0e0651" translate="yes" xml:space="preserve">
          <source>The directory &lt;code&gt;Path&lt;/code&gt;does not exist.</source>
          <target state="translated">ディレクトリ &lt;code&gt;Path&lt;/code&gt; が存在しません。</target>
        </trans-unit>
        <trans-unit id="7bccd89dc32dbb0c503ff0753756340f2c3e005e" translate="yes" xml:space="preserve">
          <source>The directory could be changed with the option &lt;code&gt;&lt;a href=&quot;#type-user_dir_common_option&quot;&gt;user_dir&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">ディレクトリはオプション &lt;code&gt;&lt;a href=&quot;#type-user_dir_common_option&quot;&gt;user_dir&lt;/a&gt;&lt;/code&gt; で変更できます。</target>
        </trans-unit>
        <trans-unit id="acc2f12b5fc8219c0bfb75133fa338329e4cc3b0" translate="yes" xml:space="preserve">
          <source>The directory does not exist.</source>
          <target state="translated">ディレクトリが存在しません。</target>
        </trans-unit>
        <trans-unit id="117b6acef024fb182d6e7698c7419f59fe7b75af" translate="yes" xml:space="preserve">
          <source>The directory for (1) back-up copy and (2) Erlang-specific configuration file for &lt;code&gt;syslogd&lt;/code&gt;</source>
          <target state="translated">（1）バックアップコピーと（2） &lt;code&gt;syslogd&lt;/code&gt; の Erlang固有の構成ファイルのディレクトリ</target>
        </trans-unit>
        <trans-unit id="339f3fbc63ee87a760e5d5881f1be19ceac96fd2" translate="yes" xml:space="preserve">
          <source>The directory is not empty.</source>
          <target state="translated">ディレクトリが空ではありません。</target>
        </trans-unit>
        <trans-unit id="7febdc58b57a39ad1e446e02f6b42469827aa2db" translate="yes" xml:space="preserve">
          <source>The directory listing also contains one &lt;code&gt;.DAT&lt;/code&gt; file, which contains the schema itself, contained in the &lt;code&gt;schema.DAT&lt;/code&gt; file. The &lt;code&gt;DAT&lt;/code&gt; files are indexed files, and it is efficient to insert and search for records in these files with a specific key. The &lt;code&gt;.DAT&lt;/code&gt; files are used for the schema and for &lt;code&gt;disc_only_copies&lt;/code&gt; tables. The &lt;code&gt;Mnesia&lt;/code&gt; data files are currently implemented in the standard library module &lt;code&gt;dets&lt;/code&gt; in &lt;code&gt;STDLIB&lt;/code&gt;.</source>
          <target state="translated">ディレクトリリストには、1つの &lt;code&gt;.DAT&lt;/code&gt; ファイルも含まれて &lt;code&gt;schema.DAT&lt;/code&gt; ます。このファイルには、schema.DATファイルに含まれるスキーマ自体が含まれています。 &lt;code&gt;DAT&lt;/code&gt; のファイルは、インデックス付きファイルであり、挿入して、特定のキーを使用して、これらのファイル内のレコードを検索するために効率的です。 &lt;code&gt;.DAT&lt;/code&gt; のファイルは、スキーマのためなどに使用されている &lt;code&gt;disc_only_copies&lt;/code&gt; のテーブル。 &lt;code&gt;Mnesia&lt;/code&gt; のデータファイルは、現在の標準ライブラリのモジュールに実装されている &lt;code&gt;dets&lt;/code&gt; で &lt;code&gt;STDLIB&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ffc8511921c9959d184fd92a30bcce8e510e914f" translate="yes" xml:space="preserve">
          <source>The directory structure for the code installed by the release handler from a release package is as follows:</source>
          <target state="translated">リリースパッケージからリリースハンドラがインストールしたコードのディレクトリ構造は以下のようになります。</target>
        </trans-unit>
        <trans-unit id="a42562d2ee99aac69e248e9c1d20b489a29d934f" translate="yes" xml:space="preserve">
          <source>The directory to read the application from. This parameter can be used to point out a specific location to fetch the application from. This is useful for instance if the parent directory for some reason is no good as a library directory on system level.</source>
          <target state="translated">アプリケーションを読み込むディレクトリ。このパラメータを使用して、アプリケーションをフェッチする特定の場所を指定することができます。これは、例えば親ディレクトリが何らかの理由でシステムレベルでライブラリディレクトリとして使えない場合に便利です。</target>
        </trans-unit>
        <trans-unit id="d7bfc486e65b60f6f17e8c030cc98aaf1f5887ba" translate="yes" xml:space="preserve">
          <source>The directory where temporary files are put can be chosen explicitly. The default, implied by value &lt;code&gt;&quot;&quot;&lt;/code&gt;, is to put temporary files on the same directory as the sorted output file. If output is a function (see below), the directory returned by &lt;code&gt;file:get_cwd()&lt;/code&gt; is used instead. The names of temporary files are derived from the Erlang nodename (&lt;code&gt;node()&lt;/code&gt;), the process identifier of the current Erlang emulator (&lt;code&gt;os:getpid()&lt;/code&gt;), and a unique integer (&lt;code&gt;erlang:unique_integer([positive])&lt;/code&gt;). A typical name is &lt;code&gt;fs_mynode@myhost_1763_4711.17&lt;/code&gt;, where &lt;code&gt;17&lt;/code&gt; is a sequence number. Existing files are overwritten. Temporary files are deleted unless some uncaught &lt;code&gt;EXIT&lt;/code&gt; signal occurs.</source>
          <target state="translated">一時ファイルを置くディレクトリは明示的に選択できます。値 &lt;code&gt;&quot;&quot;&lt;/code&gt; で暗黙的に示されるデフォルトでは、ソートされた出力ファイルと同じディレクトリに一時ファイルが置かれます。出力が関数（以下を参照）の場合、代わりに &lt;code&gt;file:get_cwd()&lt;/code&gt; によって返されたディレクトリが使用されます。一時ファイルの名前は、Erlangノード名（ &lt;code&gt;node()&lt;/code&gt; ）、現在のErlangエミュレーターのプロセス識別子（ &lt;code&gt;os:getpid()&lt;/code&gt; ）、および一意の整数（ &lt;code&gt;erlang:unique_integer([positive])&lt;/code&gt; ）から取得されます。一般的な名前は &lt;code&gt;fs_mynode@myhost_1763_4711.17&lt;/code&gt; で、 &lt;code&gt;17&lt;/code&gt; はシーケンス番号です。既存のファイルは上書きされます。キャッチされていない &lt;code&gt;EXIT&lt;/code&gt; がない限り、一時ファイルは削除されます 信号が発生します。</target>
        </trans-unit>
        <trans-unit id="26b2546fb62728f487df23d7a64fc6038e2f04cd" translate="yes" xml:space="preserve">
          <source>The directory where the compiler is to place the output files. Defaults to the current working directory.</source>
          <target state="translated">コンパイラが出力ファイルを配置するディレクトリです。デフォルトは現在の作業ディレクトリです。</target>
        </trans-unit>
        <trans-unit id="23d4b2c59c247070b6160ec438b2f4a12342bdf0" translate="yes" xml:space="preserve">
          <source>The directory where the configuration files are found is given as a parameter to the agent.</source>
          <target state="translated">設定ファイルが置かれているディレクトリは、エージェントへのパラメータとして与えられます。</target>
        </trans-unit>
        <trans-unit id="f35f2fdf2411bb1709c721e727448cb07cb8e62e" translate="yes" xml:space="preserve">
          <source>The directory where the configuration files are found is given as a parameter to the manager.</source>
          <target state="translated">設定ファイルが置かれているディレクトリは、マネージャへのパラメータとして与えられます。</target>
        </trans-unit>
        <trans-unit id="57ac9409f64c817119b2a62c56ec2039ee44af45" translate="yes" xml:space="preserve">
          <source>The directory where the module is being compiled</source>
          <target state="translated">モジュールがコンパイルされているディレクトリ</target>
        </trans-unit>
        <trans-unit id="a823ed8e05f4f19f697c128e1d3b1f2bf689cda5" translate="yes" xml:space="preserve">
          <source>The disconnect may either be made explicitly by a call to megaco:disconnect/2 or implicitly when the control process of the connection dies.</source>
          <target state="translated">切断は、megaco:disconnect/2への呼び出しによって明示的に行われるか、接続の制御プロセスが終了したときに暗黙的に行われるかのいずれかである。</target>
        </trans-unit>
        <trans-unit id="4ffbc4f5819bc4c210bf785d2c507c9b376119c7" translate="yes" xml:space="preserve">
          <source>The discovery module may implement the following callback:</source>
          <target state="translated">ディスカバリーモジュールは、以下のコールバックを実装してもよい。</target>
        </trans-unit>
        <trans-unit id="84d184d395f04b053ca8e8de39c92096a4dfaac1" translate="yes" xml:space="preserve">
          <source>The discovery module needs to implement the same API as the regular &lt;code&gt;EPMD module&lt;/code&gt;. However, instead of communicating with EPMD you can connect to any service to find out connection details of other nodes. A discovery module is enabled by setting &lt;code&gt;-epmd_module&lt;/code&gt; when starting erlang. The discovery module must implement the following callbacks:</source>
          <target state="translated">検出モジュールは、通常の &lt;code&gt;EPMD module&lt;/code&gt; と同じAPIを実装する必要があります。ただし、EPMDと通信する代わりに、任意のサービスに接続して、他のノードの接続の詳細を確認できます。erlangの起動時に &lt;code&gt;-epmd_module&lt;/code&gt; を設定すると、検出モジュールが有効になります。検出モジュールは、次のコールバックを実装する必要があります。</target>
        </trans-unit>
        <trans-unit id="99d7db3ae01fbb644d3dec6e8da4ab75b95c8848" translate="yes" xml:space="preserve">
          <source>The disk log process is not terminated as long as there are owners or users of the log. All owners must close the log, possibly by terminating. Also, any other process, not only the processes that have opened the log anonymously, can decrement the &lt;code&gt;users&lt;/code&gt; counter by closing the log. Attempts to close a log by a process that is not an owner are ignored if there are no users.</source>
          <target state="translated">ログの所有者またはユーザーがいる限り、ディスクログプロセスは終了しません。すべての所有者は、おそらく終了することにより、ログを閉じる必要があります。また、ログを匿名で開いたプロセスだけでなく、他のプロセスでも、ログを閉じることによって &lt;code&gt;users&lt;/code&gt; カウンターを減らすことができます。所有者ではないプロセスがログを閉じようとしても、ユーザーがいない場合は無視されます。</target>
        </trans-unit>
        <trans-unit id="170e47f1105c3410c9337c315483a1099114bce2" translate="yes" xml:space="preserve">
          <source>The disk space required by Solaris can be minimized by using the Core User support installation. It requires about 80 MB of disk space. This installs only the minimum software required to boot and run Solaris. The disk space can be further reduced by deleting unnecessary individual files. However, unless disk space is a critical resource the effort required and the risks involved cannot be justified.</source>
          <target state="translated">Core Userサポートインストールを使用することで、Solarisで必要なディスク容量を最小限に抑えることができます。約 80 MB のディスク容量が必要です。これは、Solaris の起動と実行に必要な最小限のソフトウェアのみをインストールします。不要な個々のファイルを削除することで、ディスク容量をさらに減らすことができます。しかし、ディスク容量が重要なリソースでない限り、必要な労力とリスクを正当化することはできません。</target>
        </trans-unit>
        <trans-unit id="5252445bcfdf0c4e9a0db2f6abd1c5ab396bbcae" translate="yes" xml:space="preserve">
          <source>The distribution does this implicitly when sending messages across node boundaries.</source>
          <target state="translated">ディストリビューションは、ノードの境界を越えてメッセージを送信するときに暗黙のうちにこれを行います。</target>
        </trans-unit>
        <trans-unit id="54a389857119d0e949a971f667eeb2bc4135d70c" translate="yes" xml:space="preserve">
          <source>The distribution header format is as follows:</source>
          <target state="translated">ディストリビューションヘッダーのフォーマットは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="7207d53f2df6dd951040b5a96c6e6f572abc8fba" translate="yes" xml:space="preserve">
          <source>The distribution header only contains an atom cache reference section, but can in the future contain more information. The distribution header precedes one or more Erlang terms on the external format. For more information, see the documentation of the &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#connected_nodes&quot;&gt;protocol between connected nodes&lt;/a&gt;&lt;/code&gt; in the &lt;code&gt;&lt;a href=&quot;erl_dist_protocol&quot;&gt;distribution protocol&lt;/a&gt;&lt;/code&gt; documentation.</source>
          <target state="translated">配布ヘッダーには、Atomキャッシュ参照セクションのみが含まれますが、将来的にはより多くの情報が含まれる可能性があります。配布ヘッダーは、外部形式の1つ以上のErlang用語の前にあります。詳細については、 &lt;code&gt;&lt;a href=&quot;erl_dist_protocol&quot;&gt;distribution protocol&lt;/a&gt;&lt;/code&gt; ドキュメントの &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#connected_nodes&quot;&gt;protocol between connected nodes&lt;/a&gt;&lt;/code&gt; のプロトコルのドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="c2379df6378023fbabe88db9769e48826a29d56a" translate="yes" xml:space="preserve">
          <source>The distribution mechanism is implemented using TCP/IP sockets. How to implement an alternative carrier is described in the &lt;code&gt;ERTS User's Guide&lt;/code&gt;.</source>
          <target state="translated">配布メカニズムは、TCP / IPソケットを使用して実装されます。代替キャリアの実装方法は、 &lt;code&gt;ERTS User's Guide&lt;/code&gt; 記載されています。</target>
        </trans-unit>
        <trans-unit id="62295fb74df53713cac7805be082a69085ad9fa7" translate="yes" xml:space="preserve">
          <source>The distribution mechanism is not backward compatible by default. This flag sets the emulator in compatibility mode with an earlier Erlang/OTP release &lt;code&gt;ReleaseNumber&lt;/code&gt;. The release number must be in the range &lt;code&gt;&amp;lt;current release&amp;gt;-2..&amp;lt;current release&amp;gt;&lt;/code&gt;. This limits the emulator, making it possible for it to communicate with Erlang nodes (as well as C- and Java nodes) running that earlier release.</source>
          <target state="translated">配布メカニズムは、デフォルトでは下位互換性がありません。このフラグは、エミュレータを以前のErlang / OTPリリース &lt;code&gt;ReleaseNumber&lt;/code&gt; との互換モードに設定します。リリース番号は、 &lt;code&gt;&amp;lt;current release&amp;gt;-2..&amp;lt;current release&amp;gt;&lt;/code&gt; の範囲でなければなりません。これによりエミュレーターが制限され、その以前のリリースを実行しているErlangノード（およびCおよびJavaノード）と通信できるようになります。</target>
        </trans-unit>
        <trans-unit id="9cd5b036f8947d038790d0e5bd184b32b79cd32e" translate="yes" xml:space="preserve">
          <source>The distribution module expose an API that &lt;code&gt;net_kernel&lt;/code&gt; call in order to manage connections to other nodes. The module name should have the suffix &lt;code&gt;_dist&lt;/code&gt;.</source>
          <target state="translated">配布モジュールは、他のノードへの接続を管理するために &lt;code&gt;net_kernel&lt;/code&gt; が呼び出すAPIを公開します。モジュール名には、サフィックス &lt;code&gt;_dist&lt;/code&gt; が必要です。</target>
        </trans-unit>
        <trans-unit id="9731f94ba0606fc85b916d2adf784a2aceb2f3dc" translate="yes" xml:space="preserve">
          <source>The distribution module for SSL/TLS is named &lt;code&gt;inet_tls_dist&lt;/code&gt; and is specified on the command line with option &lt;code&gt;-proto_dist&lt;/code&gt;. The argument to &lt;code&gt;-proto_dist&lt;/code&gt; is to be the module name without suffix &lt;code&gt;_dist&lt;/code&gt;. So, this distribution module is specified with &lt;code&gt;-proto_dist inet_tls&lt;/code&gt; on the command line.</source>
          <target state="translated">SSL / TLSの配布モジュールは &lt;code&gt;inet_tls_dist&lt;/code&gt; という名前で、コマンドラインでオプション &lt;code&gt;-proto_dist&lt;/code&gt; を使用して指定されます。 &lt;code&gt;-proto_dist&lt;/code&gt; の引数は、サフィックス &lt;code&gt;_dist&lt;/code&gt; のないモジュール名です。したがって、この配布モジュールは、コマンドラインで &lt;code&gt;-proto_dist inet_tls&lt;/code&gt; を使用して指定します。</target>
        </trans-unit>
        <trans-unit id="6aeea032ca4cef8b317244fbb44d9a32ae5f5898" translate="yes" xml:space="preserve">
          <source>The distribution protocol can be divided into four parts:</source>
          <target state="translated">ディストリビューションプロトコルは、4つの部分に分けることができます。</target>
        </trans-unit>
        <trans-unit id="ff1a3d4e65478d9f5f71da059cfc38ed2c96b5ba" translate="yes" xml:space="preserve">
          <source>The distribution starts at boot if all the above is specified and an &lt;code&gt;-sname &amp;lt;name&amp;gt;&lt;/code&gt; flag is present at the command line.</source>
          <target state="translated">上記のすべてが指定され、コマンドラインに &lt;code&gt;-sname &amp;lt;name&amp;gt;&lt;/code&gt; フラグが存在する場合、配布はブート時に開始されます。</target>
        </trans-unit>
        <trans-unit id="1b01c03572e2e4aaafce0356c4411e135ed1f526" translate="yes" xml:space="preserve">
          <source>The document returned by &lt;code&gt;xmerl_scan:string/[1,2]&lt;/code&gt; and &lt;code&gt;xmerl_scan:file/[1,2]&lt;/code&gt;. The type of the returned record depends on the value of the document option passed to the function.</source>
          <target state="translated">&lt;code&gt;xmerl_scan:string/[1,2]&lt;/code&gt; および &lt;code&gt;xmerl_scan:file/[1,2]&lt;/code&gt; によって返されるドキュメント。返されるレコードのタイプは、関数に渡されるドキュメントオプションの値によって異なります。</target>
        </trans-unit>
        <trans-unit id="00d8e9f113e0a458f5df4e4708996df9d6090e13" translate="yes" xml:space="preserve">
          <source>The documentation can be installed either using the &lt;code&gt;install-docs&lt;/code&gt; target, or using the &lt;code&gt;release_docs&lt;/code&gt; target.</source>
          <target state="translated">ドキュメントは、 &lt;code&gt;install-docs&lt;/code&gt; ターゲットまたは &lt;code&gt;release_docs&lt;/code&gt; ターゲットを使用してインストールできます。</target>
        </trans-unit>
        <trans-unit id="5149c903e3309937ac98a7bf77705046a7abe19b" translate="yes" xml:space="preserve">
          <source>The dollar character is an assertion that is true only if the current matching point is at the end of the subject string, or immediately before a newline at the end of the string (by default). Notice however that it does not match the newline. Dollar needs not to be the last character of the pattern if some alternatives are involved, but it is to be the last item in any branch in which it appears. Dollar has no special meaning in a character class.</source>
          <target state="translated">ドル文字は、現在の一致点が文字列の末尾か、文字列の末尾の改行の直前にある場合にのみ真となるアサーションです (デフォルトでは)。ただし、改行とは一致しないことに注意してください。Dollar は、いくつかの選択肢がある場合は、パターンの最後の文字である必要はありませんが、それが現れるどの分岐でも最後の項目になる必要があります。Dollar は、文字クラスでは特別な意味を持ちません。</target>
        </trans-unit>
        <trans-unit id="0fbbfd153dd0451d5221908c40847d88ba4f1d83" translate="yes" xml:space="preserve">
          <source>The domain of a family is called the &lt;strong&gt;index set&lt;/strong&gt;, and the range is called the &lt;strong&gt;indexed set&lt;/strong&gt;.</source>
          <target state="translated">ファミリーのドメインは&lt;strong&gt;インデックスセット&lt;/strong&gt;と呼ばれ、範囲は&lt;strong&gt;インデックスセット&lt;/strong&gt;と呼ば&lt;strong&gt;れます&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="5952578f1a7b818cc8da70c30b5eb53cf1931cf6" translate="yes" xml:space="preserve">
          <source>The dot metacharacter</source>
          <target state="translated">ドットのメタキャラ</target>
        </trans-unit>
        <trans-unit id="0c39bb4aef52ace658cb63c48687e207b1ca1ec6" translate="yes" xml:space="preserve">
          <source>The downgrade script can then be evaluated using &lt;code&gt;&lt;a href=&quot;#eval_appup_script-4&quot;&gt;eval_appup_script/4&lt;/a&gt;&lt;/code&gt;. It is recommended to use &lt;code&gt;&lt;a href=&quot;#downgrade_app-2&quot;&gt;downgrade_app/2,3&lt;/a&gt;&lt;/code&gt; instead, but this function (&lt;code&gt;downgrade_script&lt;/code&gt;) is useful to inspect the contents of the script.</source>
          <target state="translated">ダウングレードスクリプトは、 &lt;code&gt;&lt;a href=&quot;#eval_appup_script-4&quot;&gt;eval_appup_script/4&lt;/a&gt;&lt;/code&gt; を使用して評価できます。代わりに &lt;code&gt;&lt;a href=&quot;#downgrade_app-2&quot;&gt;downgrade_app/2,3&lt;/a&gt;&lt;/code&gt; を使用することをお勧めしますが、この関数（ &lt;code&gt;downgrade_script&lt;/code&gt; ）はスクリプトの内容を検査するのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="1a9b899e09f583022f6155a633fa34d496d384c3" translate="yes" xml:space="preserve">
          <source>The downside of an enforced transaction recovery decision is that the decision can be incorrect, because of insufficient information about the recovery decisions from the other nodes. This can result in an inconsistent database where &lt;code&gt;Mnesia&lt;/code&gt; has committed the transaction on some nodes but terminated it on others.</source>
          <target state="translated">強制されたトランザクション回復決定の欠点は、他のノードからの回復決定に関する情報が不十分なため、決定が不正確になる可能性があることです。これにより、 &lt;code&gt;Mnesia&lt;/code&gt; が一部のノードでトランザクションをコミットし、他のノードでトランザクションを終了した場合に、データベースの不整合が発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="4bcc2bcf2d8764baa874ccaf0e26026a8ea86d10" translate="yes" xml:space="preserve">
          <source>The drive does not exist.</source>
          <target state="translated">ドライブは存在しません。</target>
        </trans-unit>
        <trans-unit id="a20548a0f73bb216b4b211c372344d02764897f0" translate="yes" xml:space="preserve">
          <source>The driver &lt;code&gt;Name&lt;/code&gt; is not present in the system.</source>
          <target state="translated">ドライバ &lt;code&gt;Name&lt;/code&gt; がシステムに存在しません。</target>
        </trans-unit>
        <trans-unit id="822e4982aaf8b56398bd1a181c2b6889e1c63b93" translate="yes" xml:space="preserve">
          <source>The driver &lt;code&gt;Name&lt;/code&gt; is present in the system, but there is no &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; of it in this process.</source>
          <target state="translated">ドライバー &lt;code&gt;Name&lt;/code&gt; はシステムに存在し &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; が、このプロセスではそのユーザーは存在しません。</target>
        </trans-unit>
        <trans-unit id="1b210ce4bf131d4b12dbe57304824a0514f38f51" translate="yes" xml:space="preserve">
          <source>The driver binary has a field, &lt;code&gt;orig_bytes&lt;/code&gt;, which marks the start of the data in the binary.</source>
          <target state="translated">ドライバのバイナリには、バイナリのデータの開始を示すフィールド &lt;code&gt;orig_bytes&lt;/code&gt; があります。</target>
        </trans-unit>
        <trans-unit id="790a2c01c39cd01e89b6ba7ec3e95447572133e7" translate="yes" xml:space="preserve">
          <source>The driver callback functions are called synchronously from the Erlang emulator. If they take too long before completing, they can cause time-outs in the emulator. Use the queue or asynchronous calls if necessary, as the emulator must be responsive.</source>
          <target state="translated">ドライバのコールバック関数はErlangエミュレータから同期的に呼び出されます。コールバック関数が完了するまでに時間がかかりすぎると、エミュレータがタイムアウトしてしまうことがあります。エミュレータが反応しなければならないので、必要に応じてキューや非同期呼び出しを使ってください。</target>
        </trans-unit>
        <trans-unit id="157c45a036de0fa3ddd4ea0c8781ead7513f314e" translate="yes" xml:space="preserve">
          <source>The driver calls back to the emulator, using the API functions declared in &lt;code&gt;erl_driver.h&lt;/code&gt;. They are used for outputting data from the driver, using timers, and so on.</source>
          <target state="translated">ドライバーは、 &lt;code&gt;erl_driver.h&lt;/code&gt; で宣言されたAPI関数を使用して、エミュレーターにコールバックします。ドライバーからのデータの出力、タイマーの使用などに使用されます。</target>
        </trans-unit>
        <trans-unit id="bc789bf203b3722793ad6336ed379ee48dc982f5" translate="yes" xml:space="preserve">
          <source>The driver can exit and signal errors up to Erlang. This is only for severe errors, when the driver cannot possibly keep open.</source>
          <target state="translated">ドライバはErlangまでのエラーを終了してシグナルを送ることができます。これは深刻なエラーが発生した場合、ドライバが開いたままにしておくことができない場合に限ります。</target>
        </trans-unit>
        <trans-unit id="6e77324ef81504134fd1f1323beb52a29f3e3f65" translate="yes" xml:space="preserve">
          <source>The driver can only be unloaded when there are no open ports using it and no more &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; require it to be loaded.</source>
          <target state="translated">ドライバーをアンロードできるのは、それを使用している開いているポートがなく、 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; がそれをロードする必要がない場合のみです。</target>
        </trans-unit>
        <trans-unit id="02d2238ddb29e9e347e288bd01312cba05b7f070" translate="yes" xml:space="preserve">
          <source>The driver data types and the functions available to the driver writer are defined in header file &lt;code&gt;erl_driver.h&lt;/code&gt; seated in Erlang's include directory. See the &lt;code&gt;erl_driver&lt;/code&gt; documentation for details of which functions are available.</source>
          <target state="translated">ドライバーのデータ型とドライバーライターが使用できる関数は、Erlangのインクルードディレクトリにあるヘッダーファイル &lt;code&gt;erl_driver.h&lt;/code&gt; で定義されています。使用可能な関数の詳細については、 &lt;code&gt;erl_driver&lt;/code&gt; のドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="85f6b3a5e6e8b698b73cc7423736b57c1fc18515" translate="yes" xml:space="preserve">
          <source>The driver entry contains the functions that will be called by the emulator. In this example, only &lt;code&gt;start&lt;/code&gt;, &lt;code&gt;stop&lt;/code&gt;, and &lt;code&gt;control&lt;/code&gt; are provided:</source>
          <target state="translated">ドライバーエントリには、エミュレーターによって呼び出される関数が含まれています。この例では、 &lt;code&gt;start&lt;/code&gt; 、 &lt;code&gt;stop&lt;/code&gt; 、および &lt;code&gt;control&lt;/code&gt; のみが提供されています。</target>
        </trans-unit>
        <trans-unit id="fbb368d133889289794fdcfad4ea08d3c6807b8d" translate="yes" xml:space="preserve">
          <source>The driver has made itself permanent, in which case it can no longer be manipulated by this interface (much like a statically linked-in driver).</source>
          <target state="translated">ドライバはそれ自体を恒久化していますが、その場合、このインターフェイスではもはや操作できません (静的にリンクされたドライバによく似ています)。</target>
        </trans-unit>
        <trans-unit id="66000da869d699cedf77816fe5c89cc8b497a778" translate="yes" xml:space="preserve">
          <source>The driver has requested itself to be permanent, making it behave like an Erlang linked-in driver and can no longer be manipulated with this API.</source>
          <target state="translated">ドライバは、Erlangのリンクインドライバのように動作し、このAPIではもう操作できないようにするために、それ自身を永続的なものにするように要求しました。</target>
        </trans-unit>
        <trans-unit id="fb99a228136eba922ef8092328ac0928261c0a09" translate="yes" xml:space="preserve">
          <source>The driver implements a control interface, which is a synchronous interface called when Erlang calls &lt;code&gt;&lt;a href=&quot;erlang#port_control-3&quot;&gt;erlang:port_control/3&lt;/a&gt;&lt;/code&gt;. Only this interface can control the driver when it is in &lt;code&gt;data&lt;/code&gt; mode. It can be called with the following opcodes:</source>
          <target state="translated">ドライバーは、Erlangが &lt;code&gt;&lt;a href=&quot;erlang#port_control-3&quot;&gt;erlang:port_control/3&lt;/a&gt;&lt;/code&gt; を呼び出すときに呼び出される同期インターフェースである制御インターフェースを実装します。 &lt;code&gt;data&lt;/code&gt; モードの場合、このインターフェイスのみがドライバーを制御できます。次のオペコードで呼び出すことができます：</target>
        </trans-unit>
        <trans-unit id="eb42a7455c90c66663b33eefe7d7a842a5468cbc" translate="yes" xml:space="preserve">
          <source>The driver initialization routine is (usually) declared with a macro to make the driver easier to port between different operating systems (and flavors of systems). This is the only routine that must have a well-defined name. All other callbacks are reached through the driver structure. The macro to use is named &lt;code&gt;DRIVER_INIT&lt;/code&gt; and takes the driver name as parameter:</source>
          <target state="translated">ドライバーの初期化ルーチンは（通常）マクロで宣言されており、ドライバーを異なるオペレーティングシステム（およびシステムの種類）間で簡単に移植できます。これは、明確に定義された名前を持つ必要がある唯一のルーチンです。他のすべてのコールバックには、ドライバー構造を介して到達します。使用するマクロは &lt;code&gt;DRIVER_INIT&lt;/code&gt; という名前で、パラメーターとしてドライバー名を受け取ります。</target>
        </trans-unit>
        <trans-unit id="df5c267a32b3ddcfaa0938eb24b89bd6abfd4b02" translate="yes" xml:space="preserve">
          <source>The driver is already loaded with other &lt;code&gt;DriverOptionList&lt;/code&gt; or a different &lt;strong&gt;literal&lt;/strong&gt;&lt;code&gt;Path&lt;/code&gt; argument.</source>
          <target state="translated">ドライバーは既に他の &lt;code&gt;DriverOptionList&lt;/code&gt; または別の&lt;strong&gt;リテラル&lt;/strong&gt; &lt;code&gt;Path&lt;/code&gt; 引数で読み込まれています。</target>
        </trans-unit>
        <trans-unit id="123d2435bbdf7446863fb98cf76173c154e93eaf" translate="yes" xml:space="preserve">
          <source>The driver is loaded by other &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; when option &lt;code&gt;{reload, pending_driver}&lt;/code&gt; was specified.</source>
          <target state="translated">オプション &lt;code&gt;{reload, pending_driver}&lt;/code&gt; が指定された場合、ドライバーは他の &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; によってロードされます。</target>
        </trans-unit>
        <trans-unit id="de8f98e94d0922e6ef27e0959b36602f7f443810" translate="yes" xml:space="preserve">
          <source>The driver is loaded with &lt;code&gt;erl_ddll:load_driver/2&lt;/code&gt;. If this is successful, or if it is already loaded, it is opened. This will call the &lt;code&gt;start&lt;/code&gt; function in the driver.</source>
          <target state="translated">ドライバーは &lt;code&gt;erl_ddll:load_driver/2&lt;/code&gt; でロードされます。これが成功した場合、または既にロードされている場合は、開かれます。これにより、ドライバーの &lt;code&gt;start&lt;/code&gt; 関数が呼び出されます。</target>
        </trans-unit>
        <trans-unit id="0ebdfd6fd6dc142da610d573bd0e04e4e99b405d" translate="yes" xml:space="preserve">
          <source>The driver is only unloaded as a result of calling &lt;code&gt;erl_ddll:unload_driver/1&lt;/code&gt;, or when the emulator halts.</source>
          <target state="translated">ドライバーは、 &lt;code&gt;erl_ddll:unload_driver/1&lt;/code&gt; を呼び出した結果として、またはエミュレーターが停止したときにのみアンロードされます。</target>
        </trans-unit>
        <trans-unit id="aa4be31a9519f969227f921236d7d6aa51f75a8a" translate="yes" xml:space="preserve">
          <source>The driver is synchronous, it uses the synchronous calls of the client library. This is only for simplicity, but not good, as it halts the emulator while waiting for the database. This is improved below with an asynchronous sample driver.</source>
          <target state="translated">ドライバは同期型で、クライアントライブラリの同期呼び出しを利用しています。これは単純化のためだけのものですが、データベースを待っている間にエミュレータを停止させてしまうので良くありません。これを非同期のサンプルドライバで以下に改善します。</target>
        </trans-unit>
        <trans-unit id="d2846f7d13f5d6eeed6af66056f38ff13c49aabc" translate="yes" xml:space="preserve">
          <source>The driver is to be compiled and linked to a shared library (DLL on Windows). With gcc, this is done with link flags &lt;code&gt;-shared&lt;/code&gt; and &lt;code&gt;-fpic&lt;/code&gt;. As we use the &lt;code&gt;ei&lt;/code&gt; library, we should include it too. There are several versions of &lt;code&gt;ei&lt;/code&gt;, compiled for debug or non-debug and multi-threaded or single-threaded. In the makefile for the samples, the &lt;code&gt;obj&lt;/code&gt; directory is used for the &lt;code&gt;ei&lt;/code&gt; library, meaning that we use the non-debug, single-threaded version.</source>
          <target state="translated">ドライバーはコンパイルされ、共有ライブラリー（WindowsではDLL）にリンクされます。 gccでは、これはリンクフラグ &lt;code&gt;-shared&lt;/code&gt; および &lt;code&gt;-fpic&lt;/code&gt; で行われます。 &lt;code&gt;ei&lt;/code&gt; ライブラリを使用するので、これも含める必要があります。 &lt;code&gt;ei&lt;/code&gt; にはいくつかのバージョンがあり、デバッグまたは非デバッグ用にコンパイルされており、マルチスレッドまたはシングルスレッド用です。サンプルのメイクファイルでは、 &lt;code&gt;obj&lt;/code&gt; ライブラリーが &lt;code&gt;ei&lt;/code&gt; ライブラリーに使用されています。つまり、非デバッグのシングルスレッドバージョンを使用しています。</target>
        </trans-unit>
        <trans-unit id="8352df0d68d66243c84331cdb4bc76e073f0f8fd" translate="yes" xml:space="preserve">
          <source>The driver is to be provided as a dynamically linked library in an object code format specific for the platform in use, that is, &lt;code&gt;.so&lt;/code&gt; files on most Unix systems and &lt;code&gt;.ddl&lt;/code&gt; files on Windows. An Erlang linked-in driver must provide specific interfaces to the emulator, so this module is not designed for loading arbitrary dynamic libraries. For more information about Erlang drivers, see &lt;code&gt;erts:erl_driver&lt;/code&gt; .</source>
          <target state="translated">ドライバーは、使用中のプラットフォームに固有のオブジェクトコード形式で動的にリンクされたライブラリとして提供されます。 &lt;code&gt;.ddl&lt;/code&gt; 、ほとんどのUnixシステムでは &lt;code&gt;.so&lt;/code&gt; ファイル、Windowsでは.ddlファイルです。Erlangリンクインドライバーはエミュレーターに特定のインターフェイスを提供する必要があるため、このモジュールは任意の動的ライブラリーをロードするようには設計されていません。Erlangドライバーの詳細については、 &lt;code&gt;erts:erl_driver&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="11f7d0670a21cf6663ffe1e7be79926c35deca09" translate="yes" xml:space="preserve">
          <source>The driver is to fail only when in severe error situations, when the driver cannot possibly keep open, for example, buffer allocation gets out of memory. For normal errors it is more appropriate to send error codes with &lt;code&gt;&lt;a href=&quot;#driver_output&quot;&gt;driver_output&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">ドライバーは、重大なエラー状況で、ドライバーがオープンを維持できない可能性がある場合（例えば、バッファー割り当てがメモリー不足になる場合）にのみ失敗します。通常のエラーの場合、 &lt;code&gt;&lt;a href=&quot;#driver_output&quot;&gt;driver_output&lt;/a&gt;&lt;/code&gt; でエラーコードを送信する方が適切です。</target>
        </trans-unit>
        <trans-unit id="fc198aad17d226134b089c46b5d58abebda6515e" translate="yes" xml:space="preserve">
          <source>The driver name. It must correspond to the atom used in &lt;code&gt;&lt;a href=&quot;erlang#open_port-2&quot;&gt;erlang:open_port/2&lt;/a&gt;&lt;/code&gt;, and the name of the driver library file (without the extension).</source>
          <target state="translated">ドライバー名。これは、 &lt;code&gt;&lt;a href=&quot;erlang#open_port-2&quot;&gt;erlang:open_port/2&lt;/a&gt;&lt;/code&gt; で使用されるアトム、およびドライバーライブラリファイルの名前（拡張子なし）に対応している必要があります。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
