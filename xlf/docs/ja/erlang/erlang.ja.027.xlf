<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="erlang">
    <body>
      <group id="erlang">
        <trans-unit id="d362d3cf60cb0af09ab64c13d49db2cee633e8f5" translate="yes" xml:space="preserve">
          <source>If the request is successfully encoded and sent but the service in question is stopped before an answer is received then a &lt;code&gt;handle_error/4&lt;/code&gt; callback takes place with &lt;code&gt;Reason = cancel&lt;/code&gt;.</source>
          <target state="translated">リクエストが正常にエンコードされて送信されたが、問題のサービスが応答が受信される前に停止された場合、 &lt;code&gt;Reason = cancel&lt;/code&gt; して &lt;code&gt;handle_error/4&lt;/code&gt; コールバックが実行されます。</target>
        </trans-unit>
        <trans-unit id="61d25df3bedf5d0be2cd7d314bbaa9b30da48753" translate="yes" xml:space="preserve">
          <source>If the request reached the peer, was handled and the response reached the requesting node the &lt;code&gt;&lt;a href=&quot;#type-req_status&quot;&gt;req_status()&lt;/a&gt;&lt;/code&gt; is the status reported from the peer.</source>
          <target state="translated">要求がピアに到達し、処理され、応答が要求ノードに到達した場合、 &lt;code&gt;&lt;a href=&quot;#type-req_status&quot;&gt;req_status()&lt;/a&gt;&lt;/code&gt; はピアから報告されたステータスです。</target>
        </trans-unit>
        <trans-unit id="9756cb158d71aee0a6ade83d17f9f5f0e83f232d" translate="yes" xml:space="preserve">
          <source>If the requested data is available, the subentry is associated with &lt;code&gt;Name&lt;/code&gt; so that the value of the element can be read with &lt;code&gt;&lt;a href=&quot;#get_config-1&quot;&gt;ct:get_config/1,2&lt;/a&gt;&lt;/code&gt; provided &lt;code&gt;Name&lt;/code&gt; is used instead of the whole &lt;code&gt;Required&lt;/code&gt; term.</source>
          <target state="translated">要求されたデータが利用可能である場合、サブエントリが関連付けられている &lt;code&gt;Name&lt;/code&gt; の要素の値を用いて読み取ることができるように &lt;code&gt;&lt;a href=&quot;#get_config-1&quot;&gt;ct:get_config/1,2&lt;/a&gt;&lt;/code&gt; 提供 &lt;code&gt;Name&lt;/code&gt; 代わりに全体で使用される &lt;code&gt;Required&lt;/code&gt; 用語。</target>
        </trans-unit>
        <trans-unit id="5e0bd29420b56350fa2aea428f5bb429a285d8aa" translate="yes" xml:space="preserve">
          <source>If the restricted shell is activated by setting the STDLIB variable during emulator startup, and the callback module cannot be loaded, a default restricted shell allowing only the commands &lt;code&gt;q()&lt;/code&gt; and &lt;code&gt;init:stop()&lt;/code&gt; is used as fallback.</source>
          <target state="translated">エミュレータの起動時にSTDLIB変数を設定して制限付きシェルをアクティブにし、コールバックモジュールをロードできない場合は、コマンド &lt;code&gt;q()&lt;/code&gt; および &lt;code&gt;init:stop()&lt;/code&gt; のみを許可するデフォルトの制限付きシェルがフォールバックとして使用されます。</target>
        </trans-unit>
        <trans-unit id="724b8206454c6a949fb926da63637eb525b4710d" translate="yes" xml:space="preserve">
          <source>If the restricted shell is activated using &lt;code&gt;&lt;a href=&quot;#start_restricted-1&quot;&gt; start_restricted/1&lt;/a&gt;&lt;/code&gt; and the callback module cannot be loaded, an error report is sent to the error logger and the call returns &lt;code&gt;{error,Reason}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#start_restricted-1&quot;&gt; start_restricted/1&lt;/a&gt;&lt;/code&gt; を使用して制限付きシェルがアクティブ化され、コールバックモジュールをロードできない場合、エラーレポートがエラーロガーに送信され、呼び出しは &lt;code&gt;{error,Reason}&lt;/code&gt; 返します。</target>
        </trans-unit>
        <trans-unit id="ffe48dc12c1fe598f1a22c84e21f70cadbb61864" translate="yes" xml:space="preserve">
          <source>If the restricted shell is activated using &lt;code&gt;&lt;a href=&quot;#start_restricted-1&quot;&gt;start_restricted/1&lt;/a&gt;&lt;/code&gt; and the callback module cannot be loaded, an error report is sent to the error logger and the call returns &lt;code&gt;{error,Reason}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#start_restricted-1&quot;&gt;start_restricted/1&lt;/a&gt;&lt;/code&gt; を使用して制限付きシェルがアクティブ化され、コールバックモジュールをロードできない場合、エラーレポートがエラーロガーに送信され、呼び出しは &lt;code&gt;{error,Reason}&lt;/code&gt; 返します。</target>
        </trans-unit>
        <trans-unit id="d723ff157f68fb866c4e720b4a0eacba9b30b870" translate="yes" xml:space="preserve">
          <source>If the result of the list comprehension will &lt;strong&gt;obviously&lt;/strong&gt; not be used, a list will not be constructed. For example, in this code:</source>
          <target state="translated">リスト内包の結果が&lt;strong&gt;明らか&lt;/strong&gt;に使用されない場合、リストは構成されません。たとえば、次のコードでは：</target>
        </trans-unit>
        <trans-unit id="ef688930e9bc0a09ddfd80d412acb665d77d541c" translate="yes" xml:space="preserve">
          <source>If the runtime system is in &lt;code&gt;&lt;a href=&quot;time_correction#Multi_Time_Warp_Mode&quot;&gt;multi time warp mode&lt;/a&gt;&lt;/code&gt;, the time offset is changed when the runtime system detects that the &lt;code&gt;&lt;a href=&quot;time_correction#OS_System_Time&quot;&gt;OS system time&lt;/a&gt;&lt;/code&gt; has changed. The runtime system does, however, not detect this immediately when it occurs. A task checking the time offset is scheduled to execute at least once a minute, so under normal operation this is to be detected within a minute, but during heavy load it can take longer time.</source>
          <target state="translated">ランタイムシステムが &lt;code&gt;&lt;a href=&quot;time_correction#Multi_Time_Warp_Mode&quot;&gt;multi time warp mode&lt;/a&gt;&lt;/code&gt; 場合、ランタイムシステムが &lt;code&gt;&lt;a href=&quot;time_correction#OS_System_Time&quot;&gt;OS system time&lt;/a&gt;&lt;/code&gt; が変更されたことを検出すると、タイムオフセットが変更されます。ただし、ランタイムシステムは、これが発生してもすぐには検出しません。時間オフセットをチェックするタスクは少なくとも1分に1回実行されるようにスケジュールされているため、通常の操作ではこれは1分以内に検出されますが、負荷が高い場合はさらに時間がかかる可能性があります。</target>
        </trans-unit>
        <trans-unit id="9ee5563a77256009bf8489bde46cade77b9f2b67" translate="yes" xml:space="preserve">
          <source>If the runtime system is in &lt;code&gt;&lt;a href=&quot;time_correction#Multi_Time_Warp_Mode&quot;&gt;multi-time warp mode&lt;/a&gt;&lt;/code&gt;, the time offset is changed when the runtime system detects that the &lt;code&gt;&lt;a href=&quot;time_correction#OS_System_Time&quot;&gt;OS system time&lt;/a&gt;&lt;/code&gt; has changed. The runtime system will, however, not detect this immediately when it occurs. A task checking the time offset is scheduled to execute at least once a minute; so, under normal operation this is to be detected within a minute, but during heavy load it can take longer time.</source>
          <target state="translated">ランタイムシステムが &lt;code&gt;&lt;a href=&quot;time_correction#Multi_Time_Warp_Mode&quot;&gt;multi-time warp mode&lt;/a&gt;&lt;/code&gt; 場合、ランタイムシステムが &lt;code&gt;&lt;a href=&quot;time_correction#OS_System_Time&quot;&gt;OS system time&lt;/a&gt;&lt;/code&gt; が変更されたことを検出すると、タイムオフセットが変更されます。ただし、ランタイムシステムは、これが発生してもすぐには検出しません。時間オフセットをチェックするタスクは、少なくとも1分に1回実行されるようにスケジュールされています。そのため、通常の操作ではこれは1分以内に検出されますが、負荷が高い場合は時間がかかることがあります。</target>
        </trans-unit>
        <trans-unit id="842b5ecda8b77bc83a3f2909c3c676e780a3ce01" translate="yes" xml:space="preserve">
          <source>If the same option is set at two different levels, the one at the highest level is used.</source>
          <target state="translated">同じオプションが2つの異なるレベルで設定されている場合は、最も高いレベルのものが使用されます。</target>
        </trans-unit>
        <trans-unit id="554e754ec098db2cf4c76a2930674bed5aa17796" translate="yes" xml:space="preserve">
          <source>If the scheme &lt;code&gt;https&lt;/code&gt; is used, the &lt;code&gt;SSL&lt;/code&gt; application must be started. When &lt;code&gt;https&lt;/code&gt; links need to go through a proxy, the CONNECT method extension to HTTP-1.1 is used to establish a tunnel and then the connection is upgraded to TLS. However, &quot;TLS upgrade&quot; according to &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc2817.txt&quot;&gt;RFC 2817&lt;/a&gt;&lt;/code&gt;is not supported.</source>
          <target state="translated">スキーム &lt;code&gt;https&lt;/code&gt; を使用する場合は、 &lt;code&gt;SSL&lt;/code&gt; アプリケーションを開始する必要があります。 &lt;code&gt;https&lt;/code&gt; リンクがプロキシを経由する必要がある場合、HTTP-1.1へのCONNECTメソッド拡張を使用してトンネルを確立し、接続をTLSにアップグレードします。ただし、 &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc2817.txt&quot;&gt;RFC 2817&lt;/a&gt;&lt;/code&gt; による「TLSアップグレード」はサポートされていません。</target>
        </trans-unit>
        <trans-unit id="5c3e2a035a8c91596ec4431ba0d0a851882160c2" translate="yes" xml:space="preserve">
          <source>If the second operand for &lt;code&gt;is_number/2&lt;/code&gt; is a literal, it will be moved to X register 1023. Then &lt;code&gt;is_number/2&lt;/code&gt; will test whether the value stored in X register 1023 is a number.</source>
          <target state="translated">&lt;code&gt;is_number/2&lt;/code&gt; の第2オペランドがリテラルの場合、Xレジスタ1023に移動されます。次に、 &lt;code&gt;is_number/2&lt;/code&gt; は、Xレジスタ1023に格納されている値が数値であるかどうかをテストします。</target>
        </trans-unit>
        <trans-unit id="35c6f2a7a376dda13bb7ffd101ed27e0bb2c89e4" translate="yes" xml:space="preserve">
          <source>If the selected cipher needs to have the input data partioned into blocks of a certain size, the &lt;code&gt;init_fun()&lt;/code&gt; should return the second form of return value with the &lt;code&gt;chunk_size()&lt;/code&gt; set to the block size. If the &lt;code&gt;chunk_size()&lt;/code&gt; is &lt;code&gt;undefined&lt;/code&gt;, the size of the &lt;code&gt;PlainBin&lt;/code&gt;s varies, because this is intended for stream crypto, whereas a fixed &lt;code&gt;chunk_size()&lt;/code&gt; is intended for block crypto. A &lt;code&gt;chunk_size()&lt;/code&gt; can be changed in the return from the &lt;code&gt;crypto_fun()&lt;/code&gt;. The value can be changed between &lt;code&gt;pos_integer()&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">選択された暗号ニーズが一定のサイズのブロックに分配し、入力データを持っている場合、 &lt;code&gt;init_fun()&lt;/code&gt; と戻り値の第2の形態を返すべき &lt;code&gt;chunk_size()&lt;/code&gt; ブロックサイズに設定。 &lt;code&gt;PlainBin&lt;/code&gt; &lt;code&gt;chunk_size()&lt;/code&gt; が &lt;code&gt;undefined&lt;/code&gt; 場合、PlainBinのサイズは異なります。これはストリーム暗号化を対象としているのに対し、固定 &lt;code&gt;chunk_size()&lt;/code&gt; はブロック暗号化を対象としているためです。 &lt;code&gt;chunk_size()&lt;/code&gt; からの戻りで変更することができる &lt;code&gt;crypto_fun()&lt;/code&gt; 。値は &lt;code&gt;pos_integer()&lt;/code&gt; と &lt;code&gt;undefined&lt;/code&gt; の間で変更できます。</target>
        </trans-unit>
        <trans-unit id="f8d199b5f396cd79b8cc290ec04cb85c9575f0f8" translate="yes" xml:space="preserve">
          <source>If the sender would have to be suspended to do the send, &lt;code&gt;nosuspend&lt;/code&gt; is returned instead.</source>
          <target state="translated">送信を行うために送信者を一時停止する必要がある場合は、代わりに &lt;code&gt;nosuspend&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="603b5cbedb1c18808b9a489511a61b63ed3b0c0b" translate="yes" xml:space="preserve">
          <source>If the server changes callback module using any of the actions &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;change_callback_module&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;push_callback_module&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;pop_callback_module&lt;/a&gt;&lt;/code&gt;, be aware that it is always the current callback module that will get this callback call. That the current callback module handles the current state and data update should be no surprise, but it must be able to handle even parts of the state and data that it is not familiar with, somehow.</source>
          <target state="translated">サーバーがアクション &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;change_callback_module&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;push_callback_module&lt;/a&gt;&lt;/code&gt; 、または &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;pop_callback_module&lt;/a&gt;&lt;/code&gt; のいずれかを使用してコールバックモジュールを変更する場合、このコールバック呼び出しを取得するのは常に現在のコールバックモジュールであることに注意してください。現在のコールバックモジュールが現在の状態とデータの更新を処理することは驚くべきことではありませんが、何らかの形で、状態とデータのなじみのない部分も処理できる必要があります。</target>
        </trans-unit>
        <trans-unit id="7e6d3e8ae70c643b6deb59daac018ce037067a9f" translate="yes" xml:space="preserve">
          <source>If the server is not specified in a configuration file, use &lt;code&gt;&lt;a href=&quot;#connect-1&quot;&gt;connect/1&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">サーバーが構成ファイルで指定されていない場合は、代わりに &lt;code&gt;&lt;a href=&quot;#connect-1&quot;&gt;connect/1&lt;/a&gt;&lt;/code&gt; を使用してください。</target>
        </trans-unit>
        <trans-unit id="d8838b36f111de63a4782ef1a364bbbead7e4773" translate="yes" xml:space="preserve">
          <source>If the server is not specified in a configuration file, use &lt;code&gt;&lt;a href=&quot;#open-1&quot;&gt;open/1&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">サーバーが設定ファイルで指定されていない場合は、代わりに &lt;code&gt;&lt;a href=&quot;#open-1&quot;&gt;open/1&lt;/a&gt;&lt;/code&gt; を使用してください。</target>
        </trans-unit>
        <trans-unit id="70355032eca4c9d76df601e10da3a7d335f3ed0d" translate="yes" xml:space="preserve">
          <source>If the server options are specified in a configuration file, or if a named client is needed for logging purposes (see section &lt;code&gt;&lt;a href=&quot;#Logging&quot;&gt;Logging&lt;/a&gt;&lt;/code&gt; in this module), use &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">サーバーオプションが設定ファイルで指定されている場合、または名前付きクライアントがロギング目的で必要な場合（このモジュールでの &lt;code&gt;&lt;a href=&quot;#Logging&quot;&gt;Logging&lt;/a&gt;&lt;/code&gt; を参照）、代わりに &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt; を使用してください。</target>
        </trans-unit>
        <trans-unit id="57f23c3daad60ed51515d51367aea45626c02cd9" translate="yes" xml:space="preserve">
          <source>If the server options are specified in a configuration file, use &lt;code&gt;&lt;a href=&quot;#connect-2&quot;&gt;connect/2&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">サーバーオプションが構成ファイルで指定されている場合は、代わりに &lt;code&gt;&lt;a href=&quot;#connect-2&quot;&gt;connect/2&lt;/a&gt;&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="2dcdba9665f7f05be3244027d112ec31bf32434c" translate="yes" xml:space="preserve">
          <source>If the server receives a SNI (Server Name Indication) from the client matching a host listed in the &lt;code&gt;sni_hosts&lt;/code&gt; option, the specific options for that host will override previously specified options. The option &lt;code&gt;sni_fun&lt;/code&gt;, and &lt;code&gt;sni_hosts&lt;/code&gt; are mutually exclusive.</source>
          <target state="translated">サーバーが、 &lt;code&gt;sni_hosts&lt;/code&gt; オプションにリストされているホストと一致するクライアントからSNI（サーバー名表示）を受信した場合、そのホストの特定のオプションは、以前に指定されたオプションをオーバーライドします。オプション &lt;code&gt;sni_fun&lt;/code&gt; および &lt;code&gt;sni_hosts&lt;/code&gt; は相互に排他的です。</target>
        </trans-unit>
        <trans-unit id="6872d76e7fd0c2b2043184ce306dcf6a44377861" translate="yes" xml:space="preserve">
          <source>If the server receives a SNI (Server Name Indication) from the client, the given function will be called to retrieve &lt;code&gt;&lt;a href=&quot;#type-server_option&quot;&gt;[server_option()] &lt;/a&gt;&lt;/code&gt; for the indicated server. These options will be merged into predefined &lt;code&gt;&lt;a href=&quot;#type-server_option&quot;&gt;[server_option()] &lt;/a&gt;&lt;/code&gt; list. The function should be defined as: fun(ServerName :: string()) -&amp;gt; &lt;code&gt;&lt;a href=&quot;#type-server_option&quot;&gt;[server_option()] &lt;/a&gt;&lt;/code&gt; and can be specified as a fun or as named &lt;code&gt;fun module:function/1&lt;/code&gt; The option &lt;code&gt;sni_fun&lt;/code&gt;, and &lt;code&gt;sni_hosts&lt;/code&gt; are mutually exclusive.</source>
          <target state="translated">サーバーがクライアントからSNI（Server Name Indication）を受信すると、指定された関数が呼び出され、指定されたサーバーの &lt;code&gt;&lt;a href=&quot;#type-server_option&quot;&gt;[server_option()] &lt;/a&gt;&lt;/code&gt; が取得されます。これらのオプションは、事前定義された &lt;code&gt;&lt;a href=&quot;#type-server_option&quot;&gt;[server_option()] &lt;/a&gt;&lt;/code&gt; リストにマージされます。関数は次のように定義する必要があります：fun（ServerName :: string（））-&amp;gt; &lt;code&gt;&lt;a href=&quot;#type-server_option&quot;&gt;[server_option()] &lt;/a&gt;&lt;/code&gt; そしてfunまたは名前付き &lt;code&gt;fun module:function/1&lt;/code&gt; として指定できますmodule：function / 1オプション &lt;code&gt;sni_fun&lt;/code&gt; と &lt;code&gt;sni_hosts&lt;/code&gt; は相互に排他的です。</target>
        </trans-unit>
        <trans-unit id="f88346e63ca31b635eaa59afabe4ac1246f3dd96" translate="yes" xml:space="preserve">
          <source>If the server receives a SNI (Server Name Indication) from the client, the given function will be called to retrieve &lt;code&gt;[ssl_option()]&lt;/code&gt; for the indicated server. These options will be merged into predefined &lt;code&gt;[ssl_option()]&lt;/code&gt;. The function should be defined as: &lt;code&gt;fun(ServerName :: string()) -&amp;gt; [ssl_option()]&lt;/code&gt; and can be specified as a fun or as named &lt;code&gt;fun module:function/1&lt;/code&gt; The option &lt;code&gt;sni_fun&lt;/code&gt;, and &lt;code&gt;sni_hosts&lt;/code&gt; are mutually exclusive.</source>
          <target state="translated">サーバーがクライアントからSNI（サーバー名表示）を受信すると、指定されたサーバーの &lt;code&gt;[ssl_option()]&lt;/code&gt; を取得するために、指定された関数が呼び出されます。これらのオプションは、事前定義された &lt;code&gt;[ssl_option()]&lt;/code&gt; にマージされます。関数は、 &lt;code&gt;fun(ServerName :: string()) -&amp;gt; [ssl_option()]&lt;/code&gt; として定義する必要があり、funまたは名前付きの &lt;code&gt;fun module:function/1&lt;/code&gt; として指定できますmodule：function / 1オプション &lt;code&gt;sni_fun&lt;/code&gt; および &lt;code&gt;sni_hosts&lt;/code&gt; は相互に排他的です。</target>
        </trans-unit>
        <trans-unit id="37d0a58e6098abfba1624874ecb647d5100c0c46" translate="yes" xml:space="preserve">
          <source>If the size of the files is decreased, the change immediately affects the current log. It does not change the size of log files already full until the next time they are used.</source>
          <target state="translated">ファイルのサイズが減少した場合、変更は現在のログに直ちに影響します。すでにいっぱいになっているログファイルのサイズは、次に使用するまで変更されません。</target>
        </trans-unit>
        <trans-unit id="48531719e2548f233ac5471f827038efdab7d452" translate="yes" xml:space="preserve">
          <source>If the size of the live data in the process is less than the minimum heap size, the first garbage collection occurring after the process is awakened ensures that the heap size is changed to a size not smaller than the minimum heap size.</source>
          <target state="translated">プロセス内のライブデータのサイズが最小ヒープサイズよりも小さい場合、プロセスが目覚めた後に発生する最初のガベージコレクションは、ヒープサイズが最小ヒープサイズよりも小さくないサイズに変更されることを確実にします。</target>
        </trans-unit>
        <trans-unit id="55a92bc9b80ccffb05ef0f4d2b0d2c00367ee298" translate="yes" xml:space="preserve">
          <source>If the skipped test case belongs to a test case group, the first argument is a tuple &lt;code&gt;{FuncName,GroupName}&lt;/code&gt;, otherwise only the function name.</source>
          <target state="translated">スキップされたテストケースがテストケースグループに属している場合、最初の引数はタプル &lt;code&gt;{FuncName,GroupName}&lt;/code&gt; です。それ以外の場合は、関数名のみです。</target>
        </trans-unit>
        <trans-unit id="a70f753063df0478c5593d2eec5283aea16d43ef" translate="yes" xml:space="preserve">
          <source>If the snmp agent is configured as a distributed Erlang application, it will during takeover try to load the same MIBs that were loaded at the old node. It uses the same filenames as the old node. If the MIBs are not located in the same paths at the different nodes, the MIBs must be loaded explicitly after takeover.</source>
          <target state="translated">snmpエージェントが分散Erlangアプリケーションとして設定されている場合、テイクオーバー時に古いノードでロードされたのと同じMIBをロードしようとします。古いノードと同じファイル名を使います。もしMIBが異なるノードの同じパスにない場合は、テイクオーバー後にMIBを明示的にロードしなければなりません。</target>
        </trans-unit>
        <trans-unit id="512aa9feb42b459cd059aa3fe2168a1e5258567a" translate="yes" xml:space="preserve">
          <source>If the socket is a listen socket, we use a separate (regular) file for two purposes:</source>
          <target state="translated">ソケットがリスンソケットの場合、2つの目的のために別の(通常の)ファイルを使用します。</target>
        </trans-unit>
        <trans-unit id="fc7067034e5330d9330814dab9d3d85a46c9af7c" translate="yes" xml:space="preserve">
          <source>If the socket is closed, the following message is delivered:</source>
          <target state="translated">ソケットが閉じている場合は、以下のメッセージが配信されます。</target>
        </trans-unit>
        <trans-unit id="4128dcf4e6f00732687760eccb66b0c9d45f8d7a" translate="yes" xml:space="preserve">
          <source>If the socket is in &lt;code&gt;&lt;a href=&quot;#option-active&quot;&gt;active&lt;/a&gt;&lt;/code&gt; mode data received data is delivered to the controlling process as messages:</source>
          <target state="translated">ソケットが &lt;code&gt;&lt;a href=&quot;#option-active&quot;&gt;active&lt;/a&gt;&lt;/code&gt; モードの場合、受信したデータはメッセージとして制御プロセスに配信されます。</target>
        </trans-unit>
        <trans-unit id="c4248f996c2d366444661dd551e1e934e80a81f5" translate="yes" xml:space="preserve">
          <source>If the socket is in &lt;code&gt;&lt;a href=&quot;#option-active&quot;&gt;passive&lt;/a&gt;&lt;/code&gt; mode data can be received through the &lt;code&gt;&lt;a href=&quot;#recv-1&quot;&gt;recv/1,2&lt;/a&gt;&lt;/code&gt; calls.</source>
          <target state="translated">ソケットが &lt;code&gt;&lt;a href=&quot;#option-active&quot;&gt;passive&lt;/a&gt;&lt;/code&gt; モードの場合、データは &lt;code&gt;&lt;a href=&quot;#recv-1&quot;&gt;recv/1,2&lt;/a&gt;&lt;/code&gt; 呼び出しを介して受信できます。</target>
        </trans-unit>
        <trans-unit id="c734cf077ea6e84216c28020bf0dfe0c224786a4" translate="yes" xml:space="preserve">
          <source>If the socket is in &lt;code&gt;{active, N}&lt;/code&gt; mode (see &lt;code&gt;&lt;a href=&quot;inet#setopts-2&quot;&gt;inet:setopts/2&lt;/a&gt;&lt;/code&gt; for details) and its message counter drops to &lt;code&gt;0&lt;/code&gt;, the following message is delivered to indicate that the socket has transitioned to passive (&lt;code&gt;{active, false}&lt;/code&gt;) mode:</source>
          <target state="translated">ソケットが &lt;code&gt;{active, N}&lt;/code&gt; モード（詳細は &lt;code&gt;&lt;a href=&quot;inet#setopts-2&quot;&gt;inet:setopts/2&lt;/a&gt;&lt;/code&gt; を参照）であり、そのメッセージカウンターが &lt;code&gt;0&lt;/code&gt; に下がると、ソケットがパッシブに移行したことを示す次のメッセージが配信されます（ &lt;code&gt;{active, false}&lt;/code&gt; ）モード：</target>
        </trans-unit>
        <trans-unit id="bb22ea2f6ffe71f664a8e18b7f47a0d62e0aa24d" translate="yes" xml:space="preserve">
          <source>If the socket is in a busy state, the socket is set in a not busy state when the amount of data queued internally by the ERTS socket implementation falls below this limit. Defaults to 4 kB.</source>
          <target state="translated">ソケットがビジー状態の場合、ERTSソケット実装が内部でキューイングしているデータ量がこの制限値を下回ると、ソケットはビジー状態ではない状態に設定される。デフォルトは4kBです。</target>
        </trans-unit>
        <trans-unit id="0860cb89a1cd48e8809f57a8b0f0cb44187efe24" translate="yes" xml:space="preserve">
          <source>If the socket is not in an active mode, data can be retrieved through the &lt;code&gt;&lt;a href=&quot;#recv-2&quot;&gt;recv/2,3&lt;/a&gt;&lt;/code&gt; calls. Notice that arriving UDP packets that are longer than the receive buffer option specifies can be truncated without warning.</source>
          <target state="translated">ソケットがアクティブモードでない場合は、 &lt;code&gt;&lt;a href=&quot;#recv-2&quot;&gt;recv/2,3&lt;/a&gt;&lt;/code&gt; 呼び出しを通じてデータを取得できます。受信バッファオプションが指定するよりも長い到着UDPパケットは警告なしに切り捨てられる可能性があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="479b7a4579a072626569e57eba743d1c2936d55c" translate="yes" xml:space="preserve">
          <source>If the socket is set in active mode, this function will transfer any messages in the mailbox of the caller to the new controlling process. If any other process is interacting with the socket while the transfer is happening, the transfer may not work correctly and messages may remain in the caller's mailbox. For instance changing the sockets active mode before the transfer is complete may cause this.</source>
          <target state="translated">ソケットがアクティブモードに設定されている場合、この関数は呼び出し元のメールボックス内のメッセージを新しい制御プロセスに転送します。転送中に他のプロセスがソケットを操作していた場合、転送が正常に行われず、呼び出し元のメールボックスにメッセージが残る可能性があります。例えば、転送が完了する前にソケットのアクティブモードを変更すると、このような問題が発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="886690ee1274e874585cd62a60964392f36c218d" translate="yes" xml:space="preserve">
          <source>If the socket is set in active mode, this function will transfer any messages in the mailbox of the caller to the new controlling process. If any other process is interacting with the socket while the transfer is happening, the transfer may not work correctly and messages may remain in the caller's mailbox. For instance changing the sockets active mode before the transfere is complete may cause this.</source>
          <target state="translated">ソケットがアクティブモードに設定されている場合、この関数は呼び出し元のメールボックス内のメッセージを新しい制御プロセスに転送します。転送中に他のプロセスがソケットを操作していた場合、転送が正常に行われず、呼び出し元のメールボックスにメッセージが残る可能性があります。例えば、転送が完了する前にソケットのアクティブモードを変更すると、このような問題が発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="2ef7d7003c6284dd13030d6ae0c0a5544dc8ae67" translate="yes" xml:space="preserve">
          <source>If the socket message queue is in a busy state, the socket message queue is set in a not busy state when the amount of data queued in the message queue falls below this limit. Notice that this limit only concerns data that has not yet reached the ERTS internal socket implementation. Defaults to 4 kB.</source>
          <target state="translated">ソケットメッセージキューがビジー状態の場合、メッセージキューのデータ量がこの制限値以下になると、ソケットメッセージキューはビジー状態ではない状態に設定される。この制限は、ERTSの内部ソケット実装にまだ到達していないデータにのみ関係することに注意してください。デフォルトは4キロバイトです。</target>
        </trans-unit>
        <trans-unit id="0489cec8cde9abcfab25b3cd056616ee2153c497" translate="yes" xml:space="preserve">
          <source>If the source file and/or the output file cannot be opened using &lt;code&gt;file:open/2&lt;/code&gt;, the function returns &lt;code&gt;{error,{file,File,Reason}}&lt;/code&gt; where &lt;code&gt;File&lt;/code&gt; is the file name and &lt;code&gt;Reason&lt;/code&gt; is the error reason.</source>
          <target state="translated">&lt;code&gt;file:open/2&lt;/code&gt; を使用してソースファイルや出力ファイルを開くことができない場合、関数は &lt;code&gt;{error,{file,File,Reason}}&lt;/code&gt; 返します。ここで、 &lt;code&gt;File&lt;/code&gt; はファイル名、 &lt;code&gt;Reason&lt;/code&gt; はエラーの理由です。</target>
        </trans-unit>
        <trans-unit id="8e799a198169d10fe4c08d9a95c18d2093196332" translate="yes" xml:space="preserve">
          <source>If the spawn operation succeeds, a new process is created on the node identified by &lt;code&gt;Node&lt;/code&gt;. When a spawn operation succeeds, the caller will by default be sent a message on the form &lt;code&gt;{ReplyTag, ReqId, ok, Pid}&lt;/code&gt; where &lt;code&gt;Pid&lt;/code&gt; is the process identifier of the newly created process. Such a message is referred to as a</source>
          <target state="translated">スポーン操作が成功すると、 &lt;code&gt;Node&lt;/code&gt; で識別されるノードに新しいプロセスが作成されます。スポーン操作が成功すると、呼び出し元にはデフォルトで &lt;code&gt;{ReplyTag, ReqId, ok, Pid}&lt;/code&gt; の形式でメッセージが送信されます。ここで、 &lt;code&gt;Pid&lt;/code&gt; は新しく作成されたプロセスのプロセス識別子です。このようなメッセージは、</target>
        </trans-unit>
        <trans-unit id="d585722d9492cc72567d38442d77e34fd8ab9264" translate="yes" xml:space="preserve">
          <source>If the special process is set to trap exits and if the parent process terminates, the expected behavior is to terminate with the same reason:</source>
          <target state="translated">特殊プロセスがトラップ終了するように設定されていて、親プロセスが終了した場合、期待される動作は、同じ理由で終了することです。</target>
        </trans-unit>
        <trans-unit id="7455375f6d9089c7881123f4a8458dbe542389f7" translate="yes" xml:space="preserve">
          <source>If the specified &lt;code&gt;SessionId&lt;/code&gt; is equal to the current session Id, an error is returned.</source>
          <target state="translated">指定された &lt;code&gt;SessionId&lt;/code&gt; が現在のセッションIDと等しい場合、エラーが返されます。</target>
        </trans-unit>
        <trans-unit id="d619307390edd39ec2b02ca669e7b364961dec45" translate="yes" xml:space="preserve">
          <source>If the specified allocator types are not enabled, the call will fail with &lt;code&gt;{error, not_enabled}&lt;/code&gt;.</source>
          <target state="translated">指定されたアロケータタイプが有効でない場合、呼び出しは &lt;code&gt;{error, not_enabled}&lt;/code&gt; 失敗します。</target>
        </trans-unit>
        <trans-unit id="45c304ea9f8890bedad2957ce64c3d9052640688" translate="yes" xml:space="preserve">
          <source>If the specified application is not loaded, or if the process executing the call does not belong to any application, the function returns &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">指定されたアプリケーションがロードされていない場合、または呼び出しを実行しているプロセスがどのアプリケーションにも属していない場合、関数は &lt;code&gt;[]&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="661935b4fcb704bdedb21cd7cd8d1037467c6a3a" translate="yes" xml:space="preserve">
          <source>If the specified application is not loaded, the function returns &lt;code&gt;undefined&lt;/code&gt;. If the process executing the call does not belong to any application, the function returns &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">指定されたアプリケーションがロードされていない場合、関数は &lt;code&gt;undefined&lt;/code&gt; を返します。呼び出しを実行するプロセスがどのアプリケーションにも属していない場合、関数は &lt;code&gt;[]&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="3ee2eec511fb223edba405cd2c1e33b5dd8cf299" translate="yes" xml:space="preserve">
          <source>If the specified event handler is not installed, the function returns &lt;code&gt;{error,bad_module}&lt;/code&gt;. If the callback function fails with &lt;code&gt;Reason&lt;/code&gt; or returns an unexpected value &lt;code&gt;Term&lt;/code&gt;, this function returns &lt;code&gt;{error,{'EXIT',Reason}}&lt;/code&gt; or &lt;code&gt;{error,Term}&lt;/code&gt;, respectively. If the event manager dies before or during the request this function returns &lt;code&gt;{error,{Reason, EventMgrRef}}&lt;/code&gt;.</source>
          <target state="translated">指定されたイベントハンドラーがインストールされていない場合、関数は &lt;code&gt;{error,bad_module}&lt;/code&gt; 返します。コールバック関数が &lt;code&gt;Reason&lt;/code&gt; で失敗するか、予期しない値 &lt;code&gt;Term&lt;/code&gt; を返す場合、この関数はそれぞれ &lt;code&gt;{error,{'EXIT',Reason}}&lt;/code&gt; または &lt;code&gt;{error,Term}&lt;/code&gt; 返します。リクエストの前またはリクエスト中にイベントマネージャーが停止した場合、この関数は &lt;code&gt;{error,{Reason, EventMgrRef}}&lt;/code&gt; 返します。</target>
        </trans-unit>
        <trans-unit id="a926434bb6d9a3523835439ccc5767bd6572dff3" translate="yes" xml:space="preserve">
          <source>If the specified process does not belong to any application, or if the specified process or module does not exist, the function returns &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">指定されたプロセスがどのアプリケーションにも属していない場合、または指定されたプロセスまたはモジュールが存在しない場合、関数は &lt;code&gt;undefined&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="2b16c97bb4dc09a19744a2eb9750dd2d9bb5ce54" translate="yes" xml:space="preserve">
          <source>If the startup procedure fails, the function &lt;code&gt;&lt;a href=&quot;mnesia#start-0&quot;&gt;mnesia:start()&lt;/a&gt;&lt;/code&gt; returns the cryptic tuple &lt;code&gt;{error,{shutdown, {mnesia_sup,start_link,[normal,[]]}}}&lt;/code&gt;. To get more information about the start failure, use command-line arguments &lt;code&gt;-boot start_sasl&lt;/code&gt; as argument to the &lt;code&gt;erl&lt;/code&gt; script.</source>
          <target state="translated">起動手順が失敗した場合、関数 &lt;code&gt;&lt;a href=&quot;mnesia#start-0&quot;&gt;mnesia:start()&lt;/a&gt;&lt;/code&gt; は暗号のタプル &lt;code&gt;{error,{shutdown, {mnesia_sup,start_link,[normal,[]]}}}&lt;/code&gt; 返します。起動の失敗に関する詳細情報を取得するには、 &lt;code&gt;erl&lt;/code&gt; スクリプトの引数としてコマンドライン引数 &lt;code&gt;-boot start_sasl&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="0cbaf50d401e5c21095fb8f1fd28f9a45786128e" translate="yes" xml:space="preserve">
          <source>If the state changes, the queue of incoming events is reset to start with the oldest postponed.</source>
          <target state="translated">状態が変化した場合、着信イベントのキューはリセットされ、最も古く延期されたものから開始されます。</target>
        </trans-unit>
        <trans-unit id="c8895677551ffa4a3c90ee4e7e492bffa6d9c323" translate="yes" xml:space="preserve">
          <source>If the status was &lt;code&gt;ok&lt;/code&gt; or &lt;code&gt;ok_simultaneous&lt;/code&gt;, the handshake continues with &lt;code&gt;B&lt;/code&gt; sending &lt;code&gt;A&lt;/code&gt; another message, the challenge. The challenge contains the same type of information as the &quot;name&quot; message initially sent from &lt;code&gt;A&lt;/code&gt; to &lt;code&gt;B&lt;/code&gt;, plus a 32-bit challenge. The challenge message can have two different formats:</source>
          <target state="translated">状態だった場合は &lt;code&gt;ok&lt;/code&gt; または &lt;code&gt;ok_simultaneous&lt;/code&gt; 、握手をし続けて &lt;code&gt;B&lt;/code&gt; が送る別のメッセージ、挑戦を。チャレンジには、最初に &lt;code&gt;A&lt;/code&gt; から &lt;code&gt;B&lt;/code&gt; に送信された「名前」メッセージと同じタイプの情報に加えて、32ビットのチャレンジが含まれています。チャレンジメッセージには、次の2つの異なる形式があります。 &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="36cb412738e6e082151303db455deefb75f1506a" translate="yes" xml:space="preserve">
          <source>If the status was &lt;code&gt;ok&lt;/code&gt; or &lt;code&gt;ok_simultaneous&lt;/code&gt;, the handshake continues with &lt;code&gt;B&lt;/code&gt; sending &lt;code&gt;A&lt;/code&gt; another message, the challenge. The challenge contains the same type of information as the &quot;name&quot; message initially sent from &lt;code&gt;A&lt;/code&gt; to &lt;code&gt;B&lt;/code&gt;, plus a 32-bit challenge:</source>
          <target state="translated">ステータスが &lt;code&gt;ok&lt;/code&gt; または &lt;code&gt;ok_simultaneous&lt;/code&gt; の場合、ハンドシェイクは &lt;code&gt;B&lt;/code&gt; が &lt;code&gt;A&lt;/code&gt; に別のメッセージであるチャレンジを送信して続行します。チャレンジには、最初に &lt;code&gt;A&lt;/code&gt; から &lt;code&gt;B&lt;/code&gt; に送信された「名前」メッセージと同じタイプの情報と、32ビットのチャレンジが含まれています。</target>
        </trans-unit>
        <trans-unit id="beeeb7c98813879b37a7bf671f3521d70f7d4fcc" translate="yes" xml:space="preserve">
          <source>If the storage type of the schema is &lt;code&gt;ram_copies&lt;/code&gt;, that is, a disc-less node, &lt;code&gt;Mnesia&lt;/code&gt; does not use the disc on that particular node. The disc use is enabled by changing the storage type of table &lt;code&gt;schema&lt;/code&gt; to &lt;code&gt;disc_copies&lt;/code&gt;.</source>
          <target state="translated">スキーマのストレージタイプが &lt;code&gt;ram_copies&lt;/code&gt; 、つまりディスクのないノードの場合、 &lt;code&gt;Mnesia&lt;/code&gt; はその特定のノードでディスクを使用しません。ディスクの使用は、テーブル &lt;code&gt;schema&lt;/code&gt; ストレージタイプを &lt;code&gt;disc_copies&lt;/code&gt; に変更することで有効になります。</target>
        </trans-unit>
        <trans-unit id="72c9602796f4ff2e2861a3fe314dbf863ef6f3fa" translate="yes" xml:space="preserve">
          <source>If the structured type has a component with an embedded &lt;code&gt;SEQUENCE OF&lt;/code&gt;/&lt;code&gt;SET OF&lt;/code&gt; which embedded type in turn is a &lt;code&gt;SEQUENCE&lt;/code&gt;/&lt;code&gt;SET&lt;/code&gt;, it gives a record with the &lt;code&gt;SEQUENCE OF&lt;/code&gt;/&lt;code&gt;SET OF&lt;/code&gt; addition as in the following example:</source>
          <target state="translated">構造化タイプに &lt;code&gt;SEQUENCE OF&lt;/code&gt; / &lt;code&gt;SET OF&lt;/code&gt; が埋め込まれたコンポーネントがあり、その埋め込みタイプが &lt;code&gt;SEQUENCE&lt;/code&gt; / &lt;code&gt;SET&lt;/code&gt; である場合、次の例のように、 &lt;code&gt;SEQUENCE OF&lt;/code&gt; / &lt;code&gt;SET OF&lt;/code&gt; オプションが追加されたレコードが得られます。</target>
        </trans-unit>
        <trans-unit id="3f062c1144e1678c566106b319cf580ce31c88b8" translate="yes" xml:space="preserve">
          <source>If the style sheet is installed as in this example, the categories are private to the suite in question. They can be used by all test cases in the suite, but cannot be used by other suites. A suite private style sheet, if specified, is used in favor of a global style sheet (one specified with flag &lt;code&gt;-stylesheet&lt;/code&gt;). A stylesheet tuple (as returned by &lt;code&gt;suite/0&lt;/code&gt; above) can also be returned from a test case information function. In this case the categories specified in the style sheet can only be used in that particular test case. A test case private style sheet is used in favor of a suite or global level style sheet.</source>
          <target state="translated">この例のようにスタイルシートがインストールされている場合、カテゴリは問題のスイートにプライベートです。これらは、スイート内のすべてのテストケースで使用できますが、他のスイートでは使用できません。スイートプライベートスタイルシートが指定されている場合は、グローバルスタイルシート（フラグ &lt;code&gt;-stylesheet&lt;/code&gt; で指定されたもの）が優先されます。スタイルシートタプル（上記の &lt;code&gt;suite/0&lt;/code&gt; によって返される）は、テストケース情報関数から返すこともできます。この場合、スタイルシートで指定されたカテゴリは、その特定のテストケースでのみ使用できます。スイートまたはグローバルレベルのスタイルシートを優先して、テストケースのプライベートスタイルシートが使用されます。</target>
        </trans-unit>
        <trans-unit id="5ef2b08f553195b967c4c1ec0d687b8410583635" translate="yes" xml:space="preserve">
          <source>If the subject is &quot;aaaac...&quot;, after the first match attempt fails (starting at the first character in the string), the starting point skips on to start the next attempt at &quot;c&quot;. Notice that a possessive quantifier does not have the same effect as this example; although it would suppress backtracking during the first match attempt, the second attempt would start at the second character instead of skipping on to &quot;c&quot;.</source>
          <target state="translated">主語が &quot;aaaac...&quot; の場合、最初のマッチ試行が失敗した後 (文字列の最初の文字から開始)、開始点はスキップして次の試行を &quot;c&quot; から開始します。所有的量詞は、この例と同じ効果を持たないことに注意してください。最初のマッチ試行中にバックトラッキングを抑制しますが、2回目の試行では &quot;c &quot;にスキップするのではなく、2文字目から始まります。</target>
        </trans-unit>
        <trans-unit id="325365b23f57e117a3a5f1be4ba75e874fad7352" translate="yes" xml:space="preserve">
          <source>If the subject is &quot;abac&quot;, Perl matches, but PCRE fails because the (*COMMIT) in the second repeat of the group acts.</source>
          <target state="translated">主語が &quot;abac &quot;の場合、Perlはマッチしますが、グループの2回目のリピートにある(*COMMIT)が作用するため、PCREは失敗します。</target>
        </trans-unit>
        <trans-unit id="2a1b1d46006ae1cc02a5125b44f3a589d400f8b8" translate="yes" xml:space="preserve">
          <source>If the subject is &quot;ba&quot;, this pattern does not match. As .*? is ungreedy, it initially matches zero characters. The condition (?=a) then fails, the character &quot;b&quot; is matched, but &quot;c&quot; is not. At this point, matching does not backtrack to .*? as can perhaps be expected from the presence of the | character. The conditional subpattern is part of the single alternative that comprises the whole pattern, and so the match fails. (If there was a backtrack into .*?, allowing it to match &quot;b&quot;, the match would succeed.)</source>
          <target state="translated">主語が「バ」の場合、このパターンはマッチしません。.*?はgreedyではないので、最初は0文字にマッチします。その後、条件 (?=a)は失敗し、文字 &quot;b&quot; は一致しますが、&quot;c&quot; は一致しません。この時点では、おそらく「|」文字の存在から予想されるように、マッチングは.*? 条件付きサブパターンは、パターン全体を構成する単一の選択肢の一部であるため、マッチングは失敗します。(もし、.*?へのバックトラックがあり、それが &quot;b &quot;にマッチするようになっていれば、マッチは成功します)。</target>
        </trans-unit>
        <trans-unit id="61ab084c99ad2f6aacca28fcd587b3400e6c929a" translate="yes" xml:space="preserve">
          <source>If the subject is &quot;xyz123abc123&quot;, the match point is the fourth character. Therefore, such a pattern is not implicitly anchored.</source>
          <target state="translated">主語が「xyz123abc123」であれば、一致点は4文字目である。したがって、このようなパターンは暗黙のうちにアンカリングされません。</target>
        </trans-unit>
        <trans-unit id="f58702e52fe311a5928a0c529284a25593f9a63b" translate="yes" xml:space="preserve">
          <source>If the subsystems option is not present, the value of &lt;code&gt;ssh_sftpd:subsystem_spec([])&lt;/code&gt; is used. This enables the sftp subsystem by default. The option can be set to the empty list if you do not want the daemon to run any subsystems.</source>
          <target state="translated">サブシステムオプションが存在しない場合、 &lt;code&gt;ssh_sftpd:subsystem_spec([])&lt;/code&gt; の値が使用されます。これにより、デフォルトでsftpサブシステムが有効になります。デーモンがサブシステムを実行しないようにする場合は、オプションを空のリストに設定できます。</target>
        </trans-unit>
        <trans-unit id="56f01b4c736d33d8a8e4b807a7321e237504b729" translate="yes" xml:space="preserve">
          <source>If the supervisor and its child processes are successfully created (that is, if all child process start functions return &lt;code&gt;{ok,Child}&lt;/code&gt;, &lt;code&gt;{ok,Child,Info}&lt;/code&gt;, or &lt;code&gt;ignore&lt;/code&gt;), the function returns &lt;code&gt;{ok,Pid}&lt;/code&gt;, where &lt;code&gt;Pid&lt;/code&gt; is the pid of the supervisor.</source>
          <target state="translated">スーパーバイザとその子プロセスが正常に作成された場合（つまり、すべての子プロセスの開始関数が &lt;code&gt;{ok,Child}&lt;/code&gt; 、 &lt;code&gt;{ok,Child,Info}&lt;/code&gt; 、または &lt;code&gt;ignore&lt;/code&gt; を返した場合）、関数は &lt;code&gt;{ok,Pid}&lt;/code&gt; 返します。ここで、 &lt;code&gt;Pid&lt;/code&gt; スーパーバイザーのPIDです。</target>
        </trans-unit>
        <trans-unit id="ce27df4e7a72330922127644fc5b4154720386f2" translate="yes" xml:space="preserve">
          <source>If the supervisor bridge and the subsystem are successfully started, the function returns &lt;code&gt;{ok,Pid}&lt;/code&gt;, where &lt;code&gt;Pid&lt;/code&gt; is is the pid of the supervisor bridge.</source>
          <target state="translated">スーパーバイザブリッジとサブシステムが正常に起動すると、関数は &lt;code&gt;{ok,Pid}&lt;/code&gt; 返します。ここで、 &lt;code&gt;Pid&lt;/code&gt; はスーパーバイザブリッジのpidです。</target>
        </trans-unit>
        <trans-unit id="ee5bca92e596da338cae7a1a6835c08aaca7ab2c" translate="yes" xml:space="preserve">
          <source>If the supervisor is &lt;code&gt;simple_one_for_one&lt;/code&gt;, &lt;code&gt;Id&lt;/code&gt; must be the &lt;code&gt;pid()&lt;/code&gt; of the child process. If the specified process is alive, but is not a child of the specified supervisor, the function returns &lt;code&gt;{error,not_found}&lt;/code&gt;. If the child specification identifier is specified instead of a &lt;code&gt;pid()&lt;/code&gt;, the function returns &lt;code&gt;{error,simple_one_for_one}&lt;/code&gt;.</source>
          <target state="translated">スーパーバイザが &lt;code&gt;simple_one_for_one&lt;/code&gt; の場合、 &lt;code&gt;Id&lt;/code&gt; は子プロセスの &lt;code&gt;pid()&lt;/code&gt; である必要があります。指定されたプロセスは &lt;code&gt;{error,not_found}&lt;/code&gt; であるが、指定されたスーパーバイザの子ではない場合、関数は{error、not_found}を返します。 &lt;code&gt;pid()&lt;/code&gt; の代わりに子仕様識別子が指定されている場合、関数は &lt;code&gt;{error,simple_one_for_one}&lt;/code&gt; 返します。</target>
        </trans-unit>
        <trans-unit id="fde2c4d92373b2df91d47d89bec456be3c098325" translate="yes" xml:space="preserve">
          <source>If the supervisor is not &lt;code&gt;simple_one_for_one&lt;/code&gt;, &lt;code&gt;Id&lt;/code&gt; must be the child specification identifier. The process, if any, is terminated and, unless it is a temporary child, the child specification is kept by the supervisor. The child process can later be restarted by the supervisor. The child process can also be restarted explicitly by calling &lt;code&gt;&lt;a href=&quot;#restart_child-2&quot;&gt;restart_child/2&lt;/a&gt;&lt;/code&gt;. Use &lt;code&gt;&lt;a href=&quot;#delete_child-2&quot;&gt;delete_child/2&lt;/a&gt;&lt;/code&gt; to remove the child specification.</source>
          <target state="translated">スーパーバイザが &lt;code&gt;simple_one_for_one&lt;/code&gt; でない場合、 &lt;code&gt;Id&lt;/code&gt; は子仕様識別子である必要があります。プロセスがあれば終了し、一時的な子でない限り、子の仕様はスーパーバイザによって保持されます。子プロセスは、スーパーバイザが後で再起動できます。子プロセスは、 &lt;code&gt;&lt;a href=&quot;#restart_child-2&quot;&gt;restart_child/2&lt;/a&gt;&lt;/code&gt; を呼び出すことによって明示的に再起動することもできます。子仕様を削除するには、 &lt;code&gt;&lt;a href=&quot;#delete_child-2&quot;&gt;delete_child/2&lt;/a&gt;&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="22f9e859ab134b7ee555cf61c0b88a7c31c26892" translate="yes" xml:space="preserve">
          <source>If the supervisor is not running, the function fails with the reason &lt;code&gt;badarg&lt;/code&gt;.</source>
          <target state="translated">スーパーバイザが実行されていない場合、関数は &lt;code&gt;badarg&lt;/code&gt; という理由で失敗します。</target>
        </trans-unit>
        <trans-unit id="5f1a06a02433874f4dbf2fb6692571bffc468e3a" translate="yes" xml:space="preserve">
          <source>If the suspend count on the process identified by &lt;code&gt;Suspendee&lt;/code&gt; is increased, &lt;code&gt;true&lt;/code&gt; is returned, otherwise &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Suspendee&lt;/code&gt; によって識別されたプロセスの中断カウントが増加した &lt;code&gt;true&lt;/code&gt; はtrueが返され、それ以外の場合は &lt;code&gt;false&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="2d5607c3dc66f8ee4fed4118cbb2c89a903f53e7" translate="yes" xml:space="preserve">
          <source>If the syntax for a recursive subpattern call (either by number or by name) is used outside the parentheses to which it refers, it operates like a subroutine in a programming language. The called subpattern can be defined before or after the reference. A numbered reference can be absolute or relative, as in the following examples:</source>
          <target state="translated">再帰的なサブパターン呼び出しのための構文(番号または名前による)が、それが参照する括弧の外で使われる場合、それはプログラミング言語のサブルーチンのように動作します。呼び出されるサブパターンは、参照の前にも後にも定義することができます。番号付きの参照は、以下の例のように、絶対的なものでも相対的なものでもよい。</target>
        </trans-unit>
        <trans-unit id="2c95678de3724de5573a03d131e0386d7f73cde7" translate="yes" xml:space="preserve">
          <source>If the system consists of several Erlang nodes, each node can use its own version of the release. The release handler is a locally registered process and must be called at each node where an upgrade or downgrade is required. A release handling instruction, &lt;code&gt;sync_nodes&lt;/code&gt;, can be used to synchronize the release handler processes at a number of nodes, see the &lt;code&gt;appup(4)&lt;/code&gt; manual page in SASL.</source>
          <target state="translated">システムが複数のErlangノードで構成されている場合、各ノードは独自のバージョンのリリースを使用できます。リリースハンドラーはローカルに登録されたプロセスであり、アップグレードまたはダウングレードが必要な各ノードで呼び出す必要があります。リリース処理命令 &lt;code&gt;sync_nodes&lt;/code&gt; を使用して、いくつかのノードでリリースハンドラプロセスを同期できます &lt;code&gt;appup(4)&lt;/code&gt; マニュアルページを参照してください。</target>
        </trans-unit>
        <trans-unit id="5a9dfa8802f7c28fb7268599a87d430596fb7e4c" translate="yes" xml:space="preserve">
          <source>If the system is halted by the BIF &lt;code&gt;erlang:halt/1&lt;/code&gt;, the slogan is the string parameter passed to the BIF, otherwise it is a description generated by the emulator or the (Erlang) kernel. Normally the message is enough to understand the problem, but some messages are described here. Notice that the suggested reasons for the crash are &lt;strong&gt;only suggestions&lt;/strong&gt;. The exact reasons for the errors can vary depending on the local applications and the underlying operating system.</source>
          <target state="translated">システムがBIF &lt;code&gt;erlang:halt/1&lt;/code&gt; によって停止されている場合、スローガンはBIFに渡される文字列パラメーターです。それ以外の場合は、エミュレーターまたは（Erlang）カーネルによって生成される説明です。通常、メッセージは問題を理解するのに十分ですが、いくつかのメッセージがここで説明されています。提案されたクラッシュの理由は&lt;strong&gt;単なる提案&lt;/strong&gt;であることに注意してください。エラーの正確な理由は、ローカルアプリケーションと基になるオペレーティングシステムによって異なります。</target>
        </trans-unit>
        <trans-unit id="6a757ef96ac1cd490bb1c008318b2e3635c8724c" translate="yes" xml:space="preserve">
          <source>If the system is to be rebooted because of missing heartbeats, or a terminated Erlang runtime system, environment variable &lt;code&gt;HEART_COMMAND&lt;/code&gt; must be set before the system is started. If this variable is not set, a warning text is printed but the system does not reboot.</source>
          <target state="translated">ハートビートがないためにシステムを再起動する場合、またはErlangランタイムシステムが終了した場合は、システムを起動する前に環境変数 &lt;code&gt;HEART_COMMAND&lt;/code&gt; を設定する必要があります。この変数が設定されていない場合、警告テキストが出力されますが、システムは再起動しません。</target>
        </trans-unit>
        <trans-unit id="7201254cce87e2757d3c2088109f6b9433e91391" translate="yes" xml:space="preserve">
          <source>If the system upgrade fails, &lt;code&gt;Mnesia&lt;/code&gt; must be restarted on all &lt;code&gt;db_nodes&lt;/code&gt; to restore the old database. The fallback is automatically deinstalled after a successful startup. The function &lt;code&gt;&lt;a href=&quot;mnesia#uninstall_fallback-0&quot;&gt;mnesia:uninstall_fallback()&lt;/a&gt;&lt;/code&gt; can also be used to deinstall the fallback after a successful system upgrade. Again, this is a distributed operation that is either performed on all &lt;code&gt;db_nodes&lt;/code&gt; or none. Both the installation and deinstallation of fallbacks require Erlang to be operational on all &lt;code&gt;db_nodes&lt;/code&gt;, but it does not matter if &lt;code&gt;Mnesia&lt;/code&gt; is running or not.</source>
          <target state="translated">システムのアップグレードに失敗した場合は、 &lt;code&gt;Mnesia&lt;/code&gt; はすべてに再起動する必要があります &lt;code&gt;db_nodes&lt;/code&gt; 古いデータベースを復元します。フォールバックは、正常に起動すると自動的に削除されます。関数 &lt;code&gt;&lt;a href=&quot;mnesia#uninstall_fallback-0&quot;&gt;mnesia:uninstall_fallback()&lt;/a&gt;&lt;/code&gt; を使用して、システムのアップグレードが成功した後にフォールバックを削除することもできます。繰り返しますが、これはすべての &lt;code&gt;db_nodes&lt;/code&gt; 実行されるか、まったく実行されない分散操作です。フォールバックのインストールと削除の両方で、Erlangがすべての &lt;code&gt;db_nodes&lt;/code&gt; で動作可能である必要がありますが、 &lt;code&gt;Mnesia&lt;/code&gt; が実行されているかどうかは関係ありません。</target>
        </trans-unit>
        <trans-unit id="820e07b72de8d7275e79b190e2ecc622e6ffa577" translate="yes" xml:space="preserve">
          <source>If the system uses release handling, this is to be set to a program similar to &lt;code&gt;start_erl.exe&lt;/code&gt;.</source>
          <target state="translated">システムがリリース処理を使用する場合、これは &lt;code&gt;start_erl.exe&lt;/code&gt; のようなプログラムに設定されます。</target>
        </trans-unit>
        <trans-unit id="b0d7a8bf37699409a1736ff33b25beed75456c38" translate="yes" xml:space="preserve">
          <source>If the table has been fixed using &lt;code&gt;&lt;a href=&quot;#safe_fixtable-2&quot;&gt;safe_fixtable/2&lt;/a&gt;&lt;/code&gt;, the call returns a tuple where &lt;code&gt;FixationTime&lt;/code&gt; is the time when the table was first fixed by a process, which either is or is not one of the processes it is fixed by now.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#safe_fixtable-2&quot;&gt;safe_fixtable/2&lt;/a&gt;&lt;/code&gt; を使用してテーブルが修正されている場合、呼び出しはタプルを返します。ここで、 &lt;code&gt;FixationTime&lt;/code&gt; は、テーブルがプロセスによって最初に修正された時刻であり、現在までに修正されているプロセスの1つであるかどうかを示します。</target>
        </trans-unit>
        <trans-unit id="28d80bca5a16b32c018007fa19be0d36c5975d0c" translate="yes" xml:space="preserve">
          <source>If the table identifier is invalid.</source>
          <target state="translated">テーブル識別子が無効な場合。</target>
        </trans-unit>
        <trans-unit id="510048f902d277dbbdb552040e33a360934aad3f" translate="yes" xml:space="preserve">
          <source>If the table is a hash table, that is, if it is not an &lt;code&gt;ordered_set&lt;/code&gt;.</source>
          <target state="translated">テーブルがハッシュテーブルの場合、つまり、 &lt;code&gt;ordered_set&lt;/code&gt; でない場合。</target>
        </trans-unit>
        <trans-unit id="8586c3c8b193a91489791658c1ee464303da1bd1" translate="yes" xml:space="preserve">
          <source>If the table is a hash table. Contains statistics about the table, such as the maximum, minimum, and average chain length. Having a maximum much larger than the average, and a standard deviation much larger than the expected standard deviation is a sign that the hashing of the terms behaves badly for some reason.</source>
          <target state="translated">テーブルがハッシュテーブルの場合。最大値、最小値、平均チェーン長などのテーブルに関する統計情報が含まれます。最大値が平均よりもはるかに大きく、標準偏差が期待される標準偏差よりもはるかに大きいということは、何らかの理由で項のハッシュ処理がうまくいかないことを示しています。</target>
        </trans-unit>
        <trans-unit id="fcb4375c9095616a2c1fcb3c7937a674a11eced4" translate="yes" xml:space="preserve">
          <source>If the table is an &lt;code&gt;ordered_set&lt;/code&gt;. (The number of elements is the same as the number of objects in the table.)</source>
          <target state="translated">テーブルが &lt;code&gt;ordered_set&lt;/code&gt; の場合。（要素の数は、テーブル内のオブジェクトの数と同じです。）</target>
        </trans-unit>
        <trans-unit id="fe825b9dd24dc79930168b7d8e9410fc4ed428ff" translate="yes" xml:space="preserve">
          <source>If the table is deleted, the &lt;code&gt;tid()&lt;/code&gt; will be invalid even if another named table is created with the same name.</source>
          <target state="translated">テーブルが削除された場合、同じ名前で別の名前付きテーブルが作成されても、 &lt;code&gt;tid()&lt;/code&gt; は無効になります。</target>
        </trans-unit>
        <trans-unit id="8e50f5b3f9353a3565bdface1fd102e6a022cef3" translate="yes" xml:space="preserve">
          <source>If the table is empty, &lt;code&gt;'$end_of_table'&lt;/code&gt; is returned.</source>
          <target state="translated">テーブルが空の場合、 &lt;code&gt;'$end_of_table'&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="060a5cb7c2a9190e262dad862fd197847d59b457" translate="yes" xml:space="preserve">
          <source>If the table is fixed using &lt;code&gt; ets:safe_fixtable/2&lt;/code&gt; or some internal mechanism.</source>
          <target state="translated">&lt;code&gt; ets:safe_fixtable/2&lt;/code&gt; または何らかの内部メカニズムを使用してテーブルが修正されている場合。</target>
        </trans-unit>
        <trans-unit id="2f3fb17408533c8e1e68861ca6b015faef26d511" translate="yes" xml:space="preserve">
          <source>If the table is fixed using &lt;code&gt;&lt;a href=&quot;#safe_fixtable-2&quot;&gt; safe_fixtable/2&lt;/a&gt;&lt;/code&gt;, the call returns a tuple where &lt;code&gt;FixationTime&lt;/code&gt; is the last time when the table changed from unfixed to fixed.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#safe_fixtable-2&quot;&gt; safe_fixtable/2&lt;/a&gt;&lt;/code&gt; を使用してテーブルが修正された場合、呼び出しはタプルを返します。ここで、 &lt;code&gt;FixationTime&lt;/code&gt; は、テーブルがunfixedからfixedに変更された最後の時間です。</target>
        </trans-unit>
        <trans-unit id="a3adb98d90a256345bb402384863d0ffa16d7d03" translate="yes" xml:space="preserve">
          <source>If the table is fixed using &lt;code&gt;ets:safe_fixtable/2&lt;/code&gt; or some internal mechanism.</source>
          <target state="translated">テーブルが &lt;code&gt;ets:safe_fixtable/2&lt;/code&gt; または何らかの内部メカニズムを使用して修正されている場合。</target>
        </trans-unit>
        <trans-unit id="ab8f1f3f8186f2a911707d67d645de8494934784" translate="yes" xml:space="preserve">
          <source>If the table is not fixed at all, the call returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">テーブルがまったく修正されていない場合、呼び出しは &lt;code&gt;false&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="a5a1ad070d201f061059ad07a51c09a4b677d0c7" translate="yes" xml:space="preserve">
          <source>If the table never has been fixed, the call returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">テーブルが修正されていない場合、呼び出しは &lt;code&gt;false&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="1106f60b23247fd532e1f3435b3e146b85e02356" translate="yes" xml:space="preserve">
          <source>If the table type is &lt;code&gt;ordered_set&lt;/code&gt; and the key of the inserted object &lt;strong&gt;compares equal&lt;/strong&gt; to the key of any object in the table, the old object is replaced.</source>
          <target state="translated">テーブルタイプが &lt;code&gt;ordered_set&lt;/code&gt; であり、挿入されたオブジェクトのキーがテーブル内のオブジェクトのキー&lt;strong&gt;と等しい場合&lt;/strong&gt;、古いオブジェクトが置き換えられます。</target>
        </trans-unit>
        <trans-unit id="4533fa2ede8fbfe73be80457c07b8f040691fe23" translate="yes" xml:space="preserve">
          <source>If the table type is &lt;code&gt;set&lt;/code&gt; and more than one object exists with a given key, one of the objects is chosen. This is not necessarily the last object with the given key in the sequence of objects returned by the input functions. Avoid duplicate keys, otherwise the file becomes unnecessarily fragmented. This holds also for duplicated objects stored in tables of type &lt;code&gt;bag&lt;/code&gt;.</source>
          <target state="translated">テーブルタイプが &lt;code&gt;set&lt;/code&gt; て、指定されたキーを持つ複数のオブジェクトが存在する場合、オブジェクトの1つが選択されます。これは必ずしも、入力関数によって返されたオブジェクトのシーケンスで指定されたキーを持つ最後のオブジェクトであるとは限りません。キーの重複を避けます。そうしないと、ファイルが不必要に断片化されます。これは、 &lt;code&gt;bag&lt;/code&gt; タイプのテーブルに格納されている複製オブジェクトにも当てはまります。</target>
        </trans-unit>
        <trans-unit id="56d2753779e61ff48cb39b5aa4b2593e74eb1601" translate="yes" xml:space="preserve">
          <source>If the table type is &lt;code&gt;set&lt;/code&gt; and more than one object exists with a given key, one of the objects is chosen. This is not necessarily the last object with the given key in the sequence of objects returned by the input functions. This holds also for duplicated objects stored in tables of type &lt;code&gt;bag&lt;/code&gt;.</source>
          <target state="translated">テーブルタイプが &lt;code&gt;set&lt;/code&gt; て、指定されたキーを持つ複数のオブジェクトが存在する場合、オブジェクトの1つが選択されます。これは必ずしも、入力関数によって返されたオブジェクトのシーケンスで指定されたキーを持つ最後のオブジェクトであるとは限りません。これは、 &lt;code&gt;bag&lt;/code&gt; タイプのテーブルに格納されている複製オブジェクトにも当てはまります。</target>
        </trans-unit>
        <trans-unit id="cae4c49d2565269908072cf718d1492a11aec56f" translate="yes" xml:space="preserve">
          <source>If the table type is &lt;code&gt;set&lt;/code&gt; and the key of the inserted objects &lt;strong&gt;matches&lt;/strong&gt; the key of any object in the table, the old object is replaced.</source>
          <target state="translated">テーブルタイプが &lt;code&gt;set&lt;/code&gt; ていて、挿入されたオブジェクトのキーがテーブル内のオブジェクトのキーと&lt;strong&gt;一致&lt;/strong&gt;する場合、古いオブジェクトが置き換えられます。</target>
        </trans-unit>
        <trans-unit id="a9fdebabfb947c83919e8f9a54708d4bc09db924" translate="yes" xml:space="preserve">
          <source>If the table type is &lt;code&gt;set&lt;/code&gt;, the function returns either the empty list or a list with one object, as there cannot be more than one object with a given key. If the table type is &lt;code&gt;bag&lt;/code&gt; or &lt;code&gt;duplicate_bag&lt;/code&gt;, the function returns a list of arbitrary length.</source>
          <target state="translated">テーブルタイプが &lt;code&gt;set&lt;/code&gt; 場合、指定されたキーを持つオブジェクトは複数存在できないため、関数は空のリストまたは1つのオブジェクトを含むリストを返します。テーブルタイプが &lt;code&gt;bag&lt;/code&gt; または &lt;code&gt;duplicate_bag&lt;/code&gt; の場合、関数は任意の長さのリストを返します。</target>
        </trans-unit>
        <trans-unit id="52326346a5221b9ea31e1cab3b15e1198497f8cc" translate="yes" xml:space="preserve">
          <source>If the table uses &lt;code&gt;==/2&lt;/code&gt; when comparing keys for equality, the &lt;code&gt;qlc&lt;/code&gt; module looks up the constant regardless of which operator is used in the QLC. However, &lt;code&gt;==/2&lt;/code&gt; is to be preferred:</source>
          <target state="translated">キーが等しいか &lt;code&gt;qlc&lt;/code&gt; 比較するときにテーブルが &lt;code&gt;==/2&lt;/code&gt; を使用する場合、qlcモジュールはQLCで使用されている演算子に関係なく定数を検索します。ただし、 &lt;code&gt;==/2&lt;/code&gt; が推奨されます。</target>
        </trans-unit>
        <trans-unit id="c174173c48e462e86139389a0e63bdc440243b08" translate="yes" xml:space="preserve">
          <source>If the table was compressed.</source>
          <target state="translated">テーブルが圧縮されていた場合</target>
        </trans-unit>
        <trans-unit id="c18aa6aeb37dae91506c755f84a591f149b7a42e" translate="yes" xml:space="preserve">
          <source>If the target host is a &quot;special&quot; node, the FTP address must be specified in the configuration file as follows:</source>
          <target state="translated">対象のホストが「特殊」ノードの場合は、設定ファイルに以下のようにFTPアドレスを指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="ba53604fe2dbaeba0c697aca59ebed25bdd01e29" translate="yes" xml:space="preserve">
          <source>If the target host is something else, for example, a UNIX host, the configuration file must also include the username and password (both strings):</source>
          <target state="translated">ターゲットホストが他のもの、例えばUNIXホストの場合、設定ファイルにはユーザ名とパスワード(両方の文字列)も含まれていなければなりません。</target>
        </trans-unit>
        <trans-unit id="df661b54e46a56f3d279f98bcc4be4b32bc0814f" translate="yes" xml:space="preserve">
          <source>If the test case function crashes or exits purposely, it is considered &lt;strong&gt;failed&lt;/strong&gt;. If it returns a value (no matter what value), it is considered successful. An exception to this rule is the return value &lt;code&gt;{skip,Reason}&lt;/code&gt;. If this tuple is returned, the test case is considered skipped and is logged as such.</source>
          <target state="translated">テストケース関数が意図的にクラッシュまたは終了した場合、&lt;strong&gt;失敗し&lt;/strong&gt;たと見なされます。値が返された場合（どのような値でも）、成功したと見なされます。このルールの例外は、戻り値 &lt;code&gt;{skip,Reason}&lt;/code&gt; です。このタプルが返された場合、テストケースはスキップされたと見なされ、ログに記録されます。</target>
        </trans-unit>
        <trans-unit id="4997e9150d0cf8e0e80015106a039f2b0f15d2c2" translate="yes" xml:space="preserve">
          <source>If the test case returns the tuple &lt;code&gt;{comment,Comment}&lt;/code&gt;, the case is considered successful and &lt;code&gt;Comment&lt;/code&gt; is printed in the overview log file. This is equal to calling &lt;code&gt;&lt;a href=&quot;ct#comment-1&quot;&gt;ct:comment(Comment)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">テストケースがタプル &lt;code&gt;{comment,Comment}&lt;/code&gt; 返す場合、ケースは成功と見なされ、 &lt;code&gt;Comment&lt;/code&gt; が概要ログファイルに出力されます。これは、 &lt;code&gt;&lt;a href=&quot;ct#comment-1&quot;&gt;ct:comment(Comment)&lt;/a&gt;&lt;/code&gt; を呼び出すことと同じです。</target>
        </trans-unit>
        <trans-unit id="60f08b0f13ca3dba151d2fa93224be6770ab9243" translate="yes" xml:space="preserve">
          <source>If the test is started with option &lt;code&gt;create_priv_dir&lt;/code&gt; set to &lt;code&gt;manual_per_tc&lt;/code&gt;, in order for the test case to use the private directory, it must first create it by calling this function.</source>
          <target state="translated">オプション &lt;code&gt;create_priv_dir&lt;/code&gt; を &lt;code&gt;manual_per_tc&lt;/code&gt; に設定してテストを開始した場合、テストケースでプライベートディレクトリを使用するには、まずこの関数を呼び出してテストケースを作成する必要があります。</target>
        </trans-unit>
        <trans-unit id="ff477a5e0193222aeda2ed720ed9cd26684dd49a" translate="yes" xml:space="preserve">
          <source>If the test session is instead started with a call to &lt;code&gt;ct_master:run(TestSpecName, [ct_node@host_z], [ct_node@host_x])&lt;/code&gt;, the result is that test &lt;code&gt;t1&lt;/code&gt; does not run on &lt;code&gt;ct_node@host_x&lt;/code&gt; (or any other node) while test &lt;code&gt;t3&lt;/code&gt; runs on both &lt;code&gt;ct_node@host_y&lt;/code&gt; and &lt;code&gt;ct_node@host_z&lt;/code&gt;.</source>
          <target state="translated">代わりに &lt;code&gt;ct_master:run(TestSpecName, [ct_node@host_z], [ct_node@host_x])&lt;/code&gt; 呼び出してテストセッションを開始した場合、結果として、テスト &lt;code&gt;t1&lt;/code&gt; は &lt;code&gt;ct_node@host_x&lt;/code&gt; （または他のノード）では実行されません。テスト &lt;code&gt;t3&lt;/code&gt; は &lt;code&gt;ct_node@host_y&lt;/code&gt; と &lt;code&gt;ct_node@host_z&lt;/code&gt; 両方で実行されます。</target>
        </trans-unit>
        <trans-unit id="66bd8e7ff485cff1898efb9a85ff8aa7af9d4928" translate="yes" xml:space="preserve">
          <source>If the text between the parentheses consists of a sequence of digits, the condition is true if a capturing subpattern of that number has previously matched. If more than one capturing subpattern with the same number exists (see section &lt;code&gt;&lt;a href=&quot;#sect12&quot;&gt; Duplicate Subpattern Numbers&lt;/a&gt;&lt;/code&gt; earlier), the condition is true if any of them have matched. An alternative notation is to precede the digits with a plus or minus sign. In this case, the subpattern number is relative rather than absolute. The most recently opened parentheses can be referenced by (?(-1), the next most recent by (?(-2), and so on. Inside loops, it can also make sense to refer to subsequent groups. The next parentheses to be opened can be referenced as (?(+1), and so on. (The value zero in any of these forms is not used; it provokes a compile-time error.)</source>
          <target state="translated">括弧内のテキストが一連の数字で構成されている場合、その番号のキャプチャー・サブパターンが以前に一致していれば、条件は真です。同じ番号のキャプチャサブパターンが複数存在する場合（前述の「 &lt;code&gt;&lt;a href=&quot;#sect12&quot;&gt; Duplicate Subpattern Numbers&lt;/a&gt;&lt;/code&gt; 」のセクションを参照）、それらのいずれかが一致すれば条件は真になります。別の表記法は、数字の前にプラス記号またはマイナス記号を付けることです。この場合、サブパターン番号は絶対ではなく相対です。最後に開いた括弧は（？（-1）で参照でき、次に新しい括弧は（？（-2））で参照できます。ループ内では、後続のグループを参照することも意味があります。次の括弧は開くことは、（？（+ 1）などとして参照できます。（これらの形式のいずれの値ゼロも使用されません。コンパイル時エラーが発生します。）</target>
        </trans-unit>
        <trans-unit id="a10a6be714753d43b2d04e3f31a9e74da2fca330" translate="yes" xml:space="preserve">
          <source>If the text between the parentheses consists of a sequence of digits, the condition is true if a capturing subpattern of that number has previously matched. If more than one capturing subpattern with the same number exists (see section &lt;code&gt;&lt;a href=&quot;#sect12&quot;&gt;Duplicate Subpattern Numbers&lt;/a&gt;&lt;/code&gt; earlier), the condition is true if any of them have matched. An alternative notation is to precede the digits with a plus or minus sign. In this case, the subpattern number is relative rather than absolute. The most recently opened parentheses can be referenced by (?(-1), the next most recent by (?(-2), and so on. Inside loops, it can also make sense to refer to subsequent groups. The next parentheses to be opened can be referenced as (?(+1), and so on. (The value zero in any of these forms is not used; it provokes a compile-time error.)</source>
          <target state="translated">括弧内のテキストが一連の数字で構成されている場合、その番号のキャプチャサブパターンが以前に一致していれば、条件は真です。同じ番号のキャプチャサブパターンが複数存在する場合（前述の「 &lt;code&gt;&lt;a href=&quot;#sect12&quot;&gt;Duplicate Subpattern Numbers&lt;/a&gt;&lt;/code&gt; 」を参照）、それらのいずれかが一致した場合、条件は真です。別の表記法では、数字の前にプラス記号またはマイナス記号を付けます。この場合、サブパターン番号は絶対ではなく相対です。最近開いた括弧は（？（-1）で参照でき、次の最新の括弧は（？（-2）で参照できます。以下同様です。ループ内では、後続のグループを参照することも意味があります。次の括弧（？（+ 1）などのように開くことができます（これらのフォームの値0は使用されません。コンパイル時にエラーが発生します）。</target>
        </trans-unit>
        <trans-unit id="6ca3d61691a2fc7b57ea4b8b07508db553495848" translate="yes" xml:space="preserve">
          <source>If the timer is of type &lt;code&gt;#megaco_incr_timer{}&lt;/code&gt;, then for each intermediate timout, the reply will be resent (this is valid until the ack is received or the timer expires).</source>
          <target state="translated">タイマーのタイプが &lt;code&gt;#megaco_incr_timer{}&lt;/code&gt; 場合、中間タイムアウトごとに応答が再送信されます（これは、ACKが受信されるか、タイマーが期限切れになるまで有効です）。</target>
        </trans-unit>
        <trans-unit id="0e94483da50a1b3ed8b94f80ddcd411d6145f16b" translate="yes" xml:space="preserve">
          <source>If the trace tuple has five elements, the fifth element will be sent as the &lt;code&gt;extra&lt;/code&gt; value in the &lt;code&gt;Opts&lt;/code&gt; maps.</source>
          <target state="translated">トレースタプルに5つの要素がある場合、5番目の要素が &lt;code&gt;Opts&lt;/code&gt; マップの &lt;code&gt;extra&lt;/code&gt; 値として送信されます。</target>
        </trans-unit>
        <trans-unit id="1ce02e8f59bcb0c0b8b781eb7d69a7e655a35279" translate="yes" xml:space="preserve">
          <source>If the traced node is diskless, &lt;code&gt;ttb&lt;/code&gt; must be started from a trace control node with disk access, and option &lt;code&gt;file&lt;/code&gt; must be specified to function &lt;code&gt;tracer/2&lt;/code&gt; with value &lt;code&gt;{local, File}&lt;/code&gt;, for example:</source>
          <target state="translated">トレースされたノードがディスクレスの場合、 &lt;code&gt;ttb&lt;/code&gt; はディスクにアクセスできるトレースコントロールノードから &lt;code&gt;file&lt;/code&gt; 必要があり、オプションファイルを指定して、値 &lt;code&gt;{local, File}&lt;/code&gt; で &lt;code&gt;tracer/2&lt;/code&gt; を機能させる必要があります。次に例を示します。</target>
        </trans-unit>
        <trans-unit id="83ebb917b401f97bb196808428e528b58ff6d85f" translate="yes" xml:space="preserve">
          <source>If the tracing process/port dies or the tracer module returns &lt;code&gt;remove&lt;/code&gt;, the flags are silently removed.</source>
          <target state="translated">トレースプロセス/ポートが停止するか、トレーサモジュールが &lt;code&gt;remove&lt;/code&gt; を返す場合、フラグは警告なしに削除されます。</target>
        </trans-unit>
        <trans-unit id="73568089bc427934a8063420408d7fe082af563e" translate="yes" xml:space="preserve">
          <source>If the tracing should continue after the function returns, for example if it is a start function that spawns processes to be profiled, you can use &lt;code&gt;fprof:apply(M, F, Args, [continue | OtherOpts])&lt;/code&gt;. The tracing has to be stopped at a suitable later time using &lt;code&gt;fprof:trace(stop)&lt;/code&gt;.</source>
          <target state="translated">関数が戻った後にトレースを続行する必要がある場合、たとえば、プロファイルされるプロセスを生成する開始関数である場合は、 &lt;code&gt;fprof:apply(M, F, Args, [continue | OtherOpts])&lt;/code&gt; を使用できます。 &lt;code&gt;fprof:trace(stop)&lt;/code&gt; を使用して、後で適切なタイミングでトレースを停止する必要があります。</target>
        </trans-unit>
        <trans-unit id="1df5baebd9c38dac3e2f05812c6dc531db1c4b38" translate="yes" xml:space="preserve">
          <source>If the transport connection with the peer goes down after the request has been sent but before an answer has been received then an attempt is made to resend the request to an alternate peer. If no such peer is available, or if the subsequent &lt;code&gt;pick_peer/4&lt;/code&gt; callback rejects the candidates, then a &lt;code&gt;handle_error/4&lt;/code&gt; callback takes place with &lt;code&gt;Reason = failover&lt;/code&gt;. If a peer is selected then a &lt;code&gt;prepare_retransmit/3&lt;/code&gt; callback takes place, after which the semantics are the same as following an initial &lt;code&gt;prepare_request/3&lt;/code&gt; callback.</source>
          <target state="translated">要求が送信された後、応答が受信される前に、ピアとのトランスポート接続がダウンした場合、要求が代替ピアに再送信されます。そのようなピアが利用できない場合、または後続の &lt;code&gt;pick_peer/4&lt;/code&gt; コールバックが候補を拒否する場合、 &lt;code&gt;handle_error/4&lt;/code&gt; コールバックは &lt;code&gt;Reason = failover&lt;/code&gt; 行われます。ピアが選択されると、 &lt;code&gt;prepare_retransmit/3&lt;/code&gt; コールバックが &lt;code&gt;prepare_request/3&lt;/code&gt; ます。その後、セマンティクスは、最初のprepare_request / 3コールバックと同じです。</target>
        </trans-unit>
        <trans-unit id="94a9657c264118b8bd17be6e7ec65d9a46f4bb3e" translate="yes" xml:space="preserve">
          <source>If the upgrade or downgrade fails, the application can end up in an inconsistent state.</source>
          <target state="translated">アップグレードやダウングレードに失敗すると、アプリケーションが矛盾した状態になってしまう可能性があります。</target>
        </trans-unit>
        <trans-unit id="dcf53bce4100d9193f2229bae322274401770092" translate="yes" xml:space="preserve">
          <source>If the user for some reason wants to pass the trace token to a port, this must be done manually in the code of the port controlling process. The port controlling processes have to check the appropriate sequential trace settings (as obtained from &lt;code&gt;seq_trace:get_token/1&lt;/code&gt;) and include trace information in the message data sent to their respective ports.</source>
          <target state="translated">ユーザーが何らかの理由でトレーストークンをポートに渡したい場合は、ポート制御プロセスのコードで手動で行う必要があります。プロセスを制御するポートは、適切な順次トレース設定（ &lt;code&gt;seq_trace:get_token/1&lt;/code&gt; から取得）をチェックし、それぞれのポートに送信されるメッセージデータにトレース情報を含める必要があります。</target>
        </trans-unit>
        <trans-unit id="7e2e034ddd571c04bf0e9592e1523dc28c51cfbb" translate="yes" xml:space="preserve">
          <source>If the user has configured transports &lt;strong&gt;with&lt;/strong&gt; options then those will take precedence over these options. See &lt;code&gt;&lt;a href=&quot;snmp_agent_config_files#agent_information&quot;&gt;agent information&lt;/a&gt;&lt;/code&gt; for more info.</source>
          <target state="translated">ユーザーがオプションを使用してトランスポート&lt;strong&gt;を&lt;/strong&gt;構成している場合、それらはこれらのオプションよりも優先されます。詳細については、 &lt;code&gt;&lt;a href=&quot;snmp_agent_config_files#agent_information&quot;&gt;agent information&lt;/a&gt;&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="99b23a58d8baa9de2a26d48114ccdc0aba9a7898" translate="yes" xml:space="preserve">
          <source>If the user specifies a whole directory of test suites for the test, the execution order of the suites depends on how the files are listed by the operating system, which varies between systems.</source>
          <target state="translated">ユーザがテスト用のテストスイートのディレクトリ全体を指定した場合、スイートの実行順序は、オペレーティングシステムがどのようにファイルをリストアップするかに依存しますが、これはシステム間で異なります。</target>
        </trans-unit>
        <trans-unit id="ec74a0aa34a3fff9b86b849a4c4f4303fc09ca09" translate="yes" xml:space="preserve">
          <source>If the user wants to run all test suites for a test object (or an OTP application) by specifying only the top directory (for example, with start flag/option &lt;code&gt;dir&lt;/code&gt;), &lt;code&gt;Common Test&lt;/code&gt; primarily looks for test suite modules in a subdirectory named &lt;code&gt;test&lt;/code&gt;. If this subdirectory does not exist, the specified top directory is assumed to be the test directory, and test suites are read from there instead.</source>
          <target state="translated">ユーザは、（例えば、開始フラグ/オプションでのみトップディレクトリを指定することにより、テストオブジェクト（またはOTPアプリケーション）のために、すべてのテストスイートを実行したい場合は &lt;code&gt;dir&lt;/code&gt; ）、 &lt;code&gt;Common Test&lt;/code&gt; 、主に名前のサブディレクトリにテストスイートのモジュールを探します &lt;code&gt;test&lt;/code&gt; 。このサブディレクトリが存在しない場合、指定されたトップディレクトリがテストディレクトリであると想定され、代わりにそこからテストスイートが読み取られます。</target>
        </trans-unit>
        <trans-unit id="effd9156da460f544cefc46b3b70768d9f3c1b10" translate="yes" xml:space="preserve">
          <source>If the user wants to update the record, it is more efficient to use &lt;code&gt;write/sticky_write&lt;/code&gt; as the &lt;code&gt;LockKind&lt;/code&gt;. If majority checking is active on the table, it is checked as soon as a write lock is attempted. This can be used to end quickly if the majority condition is not met.</source>
          <target state="translated">ユーザーがレコードを更新したい場合は、 &lt;code&gt;write/sticky_write&lt;/code&gt; としてwrite / sticky_writeを使用する方が効率的 &lt;code&gt;LockKind&lt;/code&gt; 。テーブルで多数決チェックがアクティブな場合、書き込みロックが試行されるとすぐにチェックされます。多数決条件が満たされない場合、これを使用してすばやく終了できます。</target>
        </trans-unit>
        <trans-unit id="2a0e7330d21e34b34dfa69e0d3eeb795d5ed2f32" translate="yes" xml:space="preserve">
          <source>If the user wants to view load values as percentage of machine capacity, then this way of measuring presents a problem, because the load values are not restricted to a fixed interval. In this case, the following simple mathematical transformation can produce the load value as a percentage:</source>
          <target state="translated">ユーザーが負荷値を機械容量に対するパーセンテージとして表示したい場合、負荷値が固定間隔に制限されていないため、この測定方法では問題が発生します。この場合、以下の簡単な数学的変換により、負荷値をパーセンテージで表示することができます。</target>
        </trans-unit>
        <trans-unit id="02fc968f89b25d7af28da18289c9216741ffd871" translate="yes" xml:space="preserve">
          <source>If the user's DSA, RSA or ECDSA key is protected by a passphrase, it can be supplied with thoose options.</source>
          <target state="translated">ユーザの DSA、RSA、または ECDSA 鍵がパスフレーズで保護されている場合、これらのオプションを提供することができます。</target>
        </trans-unit>
        <trans-unit id="753352e4298655af61f31e670724bf4c6d758094" translate="yes" xml:space="preserve">
          <source>If the value &lt;code&gt;Value&lt;/code&gt; is equal to the value previously stored for the key, &lt;code&gt;put/2&lt;/code&gt; will do nothing and return quickly.</source>
          <target state="translated">値 &lt;code&gt;Value&lt;/code&gt; が以前にキーに保存された値と等しい場合、 &lt;code&gt;put/2&lt;/code&gt; は何もせず、すぐに戻ります。</target>
        </trans-unit>
        <trans-unit id="3cf4ed00376d14751e45211a8a3a5480eebc775a" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;false&lt;/code&gt; (passive mode), the process must explicitly receive incoming data by calling &lt;code&gt;&lt;a href=&quot;gen_tcp#recv-2&quot;&gt;gen_tcp:recv/2,3&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;gen_udp#recv-2&quot;&gt;gen_udp:recv/2,3&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;gen_sctp#recv-1&quot;&gt;gen_sctp:recv/1,2&lt;/a&gt;&lt;/code&gt; (depending on the type of socket).</source>
          <target state="translated">値が &lt;code&gt;false&lt;/code&gt; （パッシブモード）の場合、プロセスは &lt;code&gt;&lt;a href=&quot;gen_tcp#recv-2&quot;&gt;gen_tcp:recv/2,3&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;gen_udp#recv-2&quot;&gt;gen_udp:recv/2,3&lt;/a&gt;&lt;/code&gt; 、または &lt;code&gt;&lt;a href=&quot;gen_sctp#recv-1&quot;&gt;gen_sctp:recv/1,2&lt;/a&gt;&lt;/code&gt; （ソケットのタイプに応じて）を呼び出して、着信データを明示的に受信する必要があります）。</target>
        </trans-unit>
        <trans-unit id="f8c0f324daf0fe9bcb732c8ba7fcf4c76dd808ad" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;false&lt;/code&gt;, Igor will read source files without passing them through the Erlang preprocessor (&lt;code&gt;epp&lt;/code&gt;), in order to avoid expansion of preprocessor directives such as &lt;code&gt;-include(...).&lt;/code&gt;, &lt;code&gt;-define(...).&lt;/code&gt; and &lt;code&gt;-ifdef(...)&lt;/code&gt;, and macro calls such as &lt;code&gt;?LINE&lt;/code&gt; and &lt;code&gt;?MY_MACRO(x, y)&lt;/code&gt;. The default value is &lt;code&gt;false&lt;/code&gt;, i.e., preprocessing is not done. (See the module &lt;code&gt;epp_dodger&lt;/code&gt; for details.)</source>
          <target state="translated">値が &lt;code&gt;false&lt;/code&gt; の場合、Igorは、 &lt;code&gt;-include(...).&lt;/code&gt; などのプリプロセッサーディレクティブの拡張を回避するために、Erlangプリプロセッサー（ &lt;code&gt;epp&lt;/code&gt; ）を介さずにソースファイルを読み取ります。、 &lt;code&gt;-define(...).&lt;/code&gt; および &lt;code&gt;-ifdef(...)&lt;/code&gt; 、および &lt;code&gt;?LINE&lt;/code&gt; や &lt;code&gt;?MY_MACRO(x, y)&lt;/code&gt; などのマクロ呼び出し。デフォルト値は &lt;code&gt;false&lt;/code&gt; です。つまり、前処理は行われません。 （詳細については、モジュール &lt;code&gt;epp_dodger&lt;/code&gt; を参照してください。）</target>
        </trans-unit>
        <trans-unit id="c37d2b8a16c01a498b8f51d057c13420aaeecac6" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;once&lt;/code&gt; (&lt;code&gt;{active, once}&lt;/code&gt;), &lt;strong&gt;one&lt;/strong&gt; data message from the socket is sent to the process. To receive one more message, &lt;code&gt;setopts/2&lt;/code&gt; must be called again with option &lt;code&gt;{active, once}&lt;/code&gt;.</source>
          <target state="translated">値が &lt;code&gt;once&lt;/code&gt; （ &lt;code&gt;{active, once}&lt;/code&gt; ）の場合、ソケットからの&lt;strong&gt;1つの&lt;/strong&gt;データメッセージがプロセスに送信されます。さらに1つのメッセージを受信するには、オプション &lt;code&gt;{active, once}&lt;/code&gt; &lt;code&gt;setopts/2&lt;/code&gt; 再度呼び出す必要があります。</target>
        </trans-unit>
        <trans-unit id="0edabfc9ae44692cbce9f0269af3098b558ce7c2" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, all &lt;code&gt;-import(...)&lt;/code&gt; declarations in the original code will be expanded in the result; otherwise, as much as possible of the original import declarations will be preserved. The default value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">値が &lt;code&gt;true&lt;/code&gt; の場合、元のコードのすべての &lt;code&gt;-import(...)&lt;/code&gt; 宣言が結果で展開されます。それ以外の場合は、元のインポート宣言が可能な限り保持されます。デフォルト値は &lt;code&gt;false&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="3ec9a61337586e188fec4ae4002aa86a696c3f2b" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, all import statements will be removed and calls to imported functions will be expanded to explicit remote calls. The default value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">値が &lt;code&gt;true&lt;/code&gt; の場合、すべてのインポート文が削除され、インポートされた関数の呼び出しが明示的なリモート呼び出しに拡張されます。デフォルト値は &lt;code&gt;false&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="1b8cea8ff6b46a563bc83a9fce55c5e6cf84c9e7" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, all information messages and warning messages will be suppressed. The default value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">値が &lt;code&gt;true&lt;/code&gt; の場合、すべての情報メッセージと警告メッセージが抑制されます。デフォルト値は &lt;code&gt;false&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="3bccb9c8103eb8444c9724207cd93db68090eda5" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, all matches &quot;&lt;code&gt;{V1, ..., Vn} = E&lt;/code&gt;&quot; where &lt;code&gt;E&lt;/code&gt; is a case-, if- or receive-expression whose branches all return n-tuples (or explicitly throw exceptions) will be rewritten to bind and export the variables &lt;code&gt;V1&lt;/code&gt;, ..., &lt;code&gt;Vn&lt;/code&gt; directly. The default value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">値が &lt;code&gt;true&lt;/code&gt; の場合、すべてが「 &lt;code&gt;{V1, ..., Vn} = E&lt;/code&gt; 」に一致します。ここで、 &lt;code&gt;E&lt;/code&gt; はcase-、if-、またはreceive-expressionであり、そのブランチはすべてnタプルを返す（または明示的に例外をスローする）と書き直されます変数 &lt;code&gt;V1&lt;/code&gt; 、...、 &lt;code&gt;Vn&lt;/code&gt; を直接バインドしてエクスポートします。デフォルト値は &lt;code&gt;false&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="e252402ddfc7629809ad75d385749bf1c28429eb" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, all options that affect how the code is modified are set to &quot;no changes&quot;. For example, to only update guard tests, and nothing else, use the options &lt;code&gt;[new_guard_tests, idem]&lt;/code&gt;. (Recall that options closer to the beginning of the list have higher precedence.)</source>
          <target state="translated">値が &lt;code&gt;true&lt;/code&gt; の場合、コードの変更方法に影響するすべてのオプションが「変更なし」に設定されます。たとえば、ガードテストのみを更新するには、オプション &lt;code&gt;[new_guard_tests, idem]&lt;/code&gt; 使用します。（リストの先頭に近いオプションほど優先順位が高いことを思い出してください。）</target>
        </trans-unit>
        <trans-unit id="661aadd35dfccaaf93a78302865c3cfe6ab3529d" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, calls to &lt;code&gt;lists:map/2&lt;/code&gt; and &lt;code&gt;lists:filter/2&lt;/code&gt; will be rewritten using list comprehensions. The default value is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">値が &lt;code&gt;true&lt;/code&gt; の場合、 &lt;code&gt;lists:map/2&lt;/code&gt; および &lt;code&gt;lists:filter/2&lt;/code&gt; の呼び出しは、リスト内包表記を使用して書き換えられます。デフォルト値は &lt;code&gt;true&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="db560d66c74e2b5edc2b415e1318b63374234171" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, existing files will be renamed before new files are opened for writing. The new names are formed by appending the string given by the &lt;code&gt;backup_suffix&lt;/code&gt; option to the original name. The default value is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">値が &lt;code&gt;true&lt;/code&gt; の場合、新しいファイルが書き込み用に開かれる前に、既存のファイルの名前が変更されます。新しい名前は、 &lt;code&gt;backup_suffix&lt;/code&gt; オプションで指定された文字列を元の名前に追加することによって形成されます。デフォルト値は &lt;code&gt;true&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="f45a2885644fae2f95e314f116a38cf230d32c75" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, guard tests will be changed to use the old names instead of the new ones, e.g. &quot;&lt;code&gt;integer(X)&lt;/code&gt;&quot; instead of &quot;&lt;code&gt;is_integer(X)&lt;/code&gt;&quot;. The default value is &lt;code&gt;false&lt;/code&gt;. This option overrides the &lt;code&gt;new_guard_tests&lt;/code&gt; option.</source>
          <target state="translated">値がある場合は &lt;code&gt;true&lt;/code&gt; 、ガードのテストではなく、新しいものの古い名前を使用するように変更され、例えば「 &lt;code&gt;integer(X)&lt;/code&gt; 」ではなく「の &lt;code&gt;is_integer(X)&lt;/code&gt; 」。デフォルト値は &lt;code&gt;false&lt;/code&gt; です。このオプションは、 &lt;code&gt;new_guard_tests&lt;/code&gt; オプションをオーバーライドします。</target>
        </trans-unit>
        <trans-unit id="fd7cd8fb5c207c507a51e1775733171389edb7af" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, guard tests will be updated to use the new names, e.g. &quot;&lt;code&gt;is_integer(X)&lt;/code&gt;&quot; instead of &quot;&lt;code&gt;integer(X)&lt;/code&gt;&quot;. The default value is &lt;code&gt;true&lt;/code&gt;. See also &lt;code&gt;old_guard_tests&lt;/code&gt;.</source>
          <target state="translated">値が &lt;code&gt;true&lt;/code&gt; の場合、ガードテストは新しい名前を使用するように更新されます。たとえば、「 &lt;code&gt;is_integer(X)&lt;/code&gt; 」ではなく「is_integer &lt;code&gt;integer(X)&lt;/code&gt; 」です。デフォルト値は &lt;code&gt;true&lt;/code&gt; です。 &lt;code&gt;old_guard_tests&lt;/code&gt; も参照してください。</target>
        </trans-unit>
        <trans-unit id="c3065ef5e6ab38f54db2ee2363766ab33259e9b9" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, instead of the file being written to disk it will be printed to stdout. The default value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">値が &lt;code&gt;true&lt;/code&gt; の場合、ディスクに書き込まれるファイルの代わりに、標準出力に出力されます。デフォルト値は &lt;code&gt;false&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="54052ea83b3ce0b0af928cdbcc55b6fae8e4433d" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, no banner comment will be added at the top of the resulting module, even if the target module does not have the same name as any of the input modules. Instead, Igor will try to preserve the look of the module whose code is at the top of the output. The default value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">値が &lt;code&gt;true&lt;/code&gt; の場合、ターゲットモジュールがどの入力モジュールとも同じ名前でなくても、結果のモジュールの上部にバナーコメントは追加されません。代わりに、IGORは、コードが出力の上部にあるモジュールの外観を保持しようとします。デフォルト値は &lt;code&gt;false&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="7f87660fc4a181394247f96baa377c54c6755f37" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, no files will be modified. The default value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">値が &lt;code&gt;true&lt;/code&gt; の場合、ファイルは変更されません。デフォルト値は &lt;code&gt;false&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="df3ab32bc54bd17610cc1947d346139f4464db6e" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, no files will be modified; this is typically most useful if the &lt;code&gt;verbose&lt;/code&gt; flag is enabled, to generate reports about the program files without affecting them. The default value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">値が &lt;code&gt;true&lt;/code&gt; の場合、ファイルは変更されません。これは通常、 &lt;code&gt;verbose&lt;/code&gt; フラグが有効になっている場合に最も役立ち、プログラムファイルに影響を与えずにレポートを生成します。デフォルト値は &lt;code&gt;false&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="c857b2ddea91c4f1382dc10632fa790ebcc157d4" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, no header comments will be added to the resulting module at the beginning of each section of code that originates from a particular input module. The default value is &lt;code&gt;false&lt;/code&gt;, which means that section headers are normally added whenever more than two or more modules are merged.</source>
          <target state="translated">値が &lt;code&gt;true&lt;/code&gt; の場合、特定の入力モジュールに由来するコードの各セクションの先頭で、結果のモジュールにヘッダーコメントは追加されません。デフォルト値は &lt;code&gt;false&lt;/code&gt; です。これは、2つ以上のモジュールがマージされるたびにセクションヘッダーが通常追加されることを意味します。</target>
        </trans-unit>
        <trans-unit id="f7502caa9d0a180e8b6ee5deb22eb2a7558a013b" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, preprocessing will be done when reading the source code. See &lt;code&gt;merge_files/4&lt;/code&gt; for details.</source>
          <target state="translated">値が &lt;code&gt;true&lt;/code&gt; の場合、ソースコードを読み取るときに前処理が行われます。詳細については、 &lt;code&gt;merge_files/4&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="3ba203d3ce53c0ee7058adbf1504acdd24b9e757" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, progress messages will be output while the program is running, unless the &lt;code&gt;quiet&lt;/code&gt; option is &lt;code&gt;true&lt;/code&gt;. The default value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">値が &lt;code&gt;true&lt;/code&gt; の場合、 &lt;code&gt;quiet&lt;/code&gt; オプションが &lt;code&gt;true&lt;/code&gt; でない限り、プログラムの実行中に進捗メッセージが出力されます。デフォルト値は &lt;code&gt;false&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="915746ee8197f7425e23cffea24b153e1f1e18c8" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, progress messages will be output while the program is running, unless the &lt;code&gt;quiet&lt;/code&gt; option is &lt;code&gt;true&lt;/code&gt;. The default value when calling &lt;code&gt;&lt;a href=&quot;#dir-2&quot;&gt;dir/2&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">値が &lt;code&gt;true&lt;/code&gt; の場合、 &lt;code&gt;quiet&lt;/code&gt; オプションが &lt;code&gt;true&lt;/code&gt; でない限り、プログラムの実行中に進捗メッセージが出力されます。 &lt;code&gt;&lt;a href=&quot;#dir-2&quot;&gt;dir/2&lt;/a&gt;&lt;/code&gt; を呼び出すときのデフォルト値は &lt;code&gt;true&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="b91774a83e666475650d9139217c76fff02c41ca" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, progress messages will be output while the program is running; the default value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">値が &lt;code&gt;true&lt;/code&gt; の場合、プログラムの実行中に進捗メッセージが出力されます。デフォルト値は &lt;code&gt;false&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="87c71038a7138f9d28b15166013d2ec5e72ecbcc" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, source code comments in the original files will be preserved in the output. The default value is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">値が &lt;code&gt;true&lt;/code&gt; の場合、元のファイルのソースコードコメントは出力に保持されます。デフォルト値は &lt;code&gt;true&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="40369b32150fd62bc05caf551bc811ec5c61e8d3" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, stub module files will be automatically generated for all exported modules that do not have the same name as the target module. The default value is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">値が &lt;code&gt;true&lt;/code&gt; の場合、ターゲットモジュールと同じ名前ではないすべてのエクスポートされたモジュールに対してスタブモジュールファイルが自動的に生成されます。デフォルト値は &lt;code&gt;true&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="1b9de1f4216e6f225a7647de788bed6302d6db97" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, subdirectories will be visited recursively. The default value is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">値が &lt;code&gt;true&lt;/code&gt; の場合、サブディレクトリは再帰的にアクセスされます。デフォルト値は &lt;code&gt;true&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="8586c382194eee0170ba6e0221153350f302413e" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, symbolic directory links will be followed. The default value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">値が &lt;code&gt;true&lt;/code&gt; の場合、シンボリックディレクトリリンクをたどります。デフォルト値は &lt;code&gt;false&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="3143c0f4c2f0487a47c16bc04f718d7c6ca270ba" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, the resulting code will be processed using the &lt;code&gt;erl_tidy&lt;/code&gt; module, which removes unused functions and does general code cleanup. (See &lt;code&gt;erl_tidy:module/2&lt;/code&gt; for additional options.) The default value is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">値が &lt;code&gt;true&lt;/code&gt; の場合、結果のコードは &lt;code&gt;erl_tidy&lt;/code&gt; モジュールを使用して処理されます。これにより、未使用の関数が削除され、一般的なコードのクリーンアップが行われます。（追加オプションについては、 &lt;code&gt;erl_tidy:module/2&lt;/code&gt; を参照してください。）デフォルト値は &lt;code&gt;true&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="2d698e4a7611a1338e29756a796838536c672223" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, this is equivalent to listing all of the input modules in the &lt;code&gt;export&lt;/code&gt; option. The default value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">値が &lt;code&gt;true&lt;/code&gt; の場合、これは、 &lt;code&gt;export&lt;/code&gt; オプションですべての入力モジュールをリストすることと同じです。デフォルト値は &lt;code&gt;false&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="365ed702372c3b3974abae9c5b1bac335c2e40e6" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, unused functions will not be removed from the code. The default value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">値が &lt;code&gt;true&lt;/code&gt; の場合、未使用の関数はコードから削除されません。デフォルト値は &lt;code&gt;false&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="c43f17f91393f09fcaccf937fae28a97b0723f0d" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, which is the default, everything received from the socket is sent as messages to the receiving process.</source>
          <target state="translated">値が &lt;code&gt;true&lt;/code&gt; （デフォルト）の場合、ソケットから受信したすべてがメッセージとして受信プロセスに送信されます。</target>
        </trans-unit>
        <trans-unit id="8c39732459bb5c7d2ede3da9e66866784c1270ea" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;yes&lt;/code&gt;, all file attributes &lt;code&gt;-file(...)&lt;/code&gt; in the input sources will be preserved in the resulting code. If the value is &lt;code&gt;comment&lt;/code&gt;, they will be turned into comments, but remain in their original positions in the code relative to the other source code forms. If the value is &lt;code&gt;no&lt;/code&gt;, all file attributes will be removed from the code, unless they have attached comments, in which case they will be handled as in the &lt;code&gt;comment&lt;/code&gt; case. The default value is &lt;code&gt;no&lt;/code&gt;.</source>
          <target state="translated">値が &lt;code&gt;yes&lt;/code&gt; の場合、入力ソースのすべてのファイル属性 &lt;code&gt;-file(...)&lt;/code&gt; が結果のコードに保持されます。値が &lt;code&gt;comment&lt;/code&gt; の場合、コメントに変換されますが、他のソースコードフォームに対してコード内の元の位置に残ります。値が &lt;code&gt;no&lt;/code&gt; の場合、コメントが添付されていない限り、すべてのファイル属性がコードから削除されます。この場合、 &lt;code&gt;comment&lt;/code&gt; 場合と同様に処理されます。デフォルト値は &lt;code&gt;no&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="adbcfdf4ba5a2347d9fb627ce201117dc5c0ef19" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;yes&lt;/code&gt;, comments will be inserted where important changes have been made in the code. If the value is &lt;code&gt;always&lt;/code&gt;, &lt;strong&gt;all&lt;/strong&gt; changes to the code will be commented. If the value is &lt;code&gt;no&lt;/code&gt;, changes will be made without comments. The default value is &lt;code&gt;yes&lt;/code&gt;.</source>
          <target state="translated">値が &lt;code&gt;yes&lt;/code&gt; の場合、コードで重要な変更が行われた場所にコメントが挿入されます。値がある場合は &lt;code&gt;always&lt;/code&gt; 、&lt;strong&gt;すべて&lt;/strong&gt;のコードへの変更はコメントされます。値が &lt;code&gt;no&lt;/code&gt; の場合、コメントなしで変更が行われます。デフォルト値は &lt;code&gt;yes&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="1f6e4b8b19f612e8db0497538210759f4a802a7a" translate="yes" xml:space="preserve">
          <source>If the value is an integer &lt;code&gt;N&lt;/code&gt; in the range -32768 to 32767 (inclusive), the value is added to the socket's count of data messages sent to the controlling process. A socket's default message count is &lt;code&gt;0&lt;/code&gt;. If a negative value is specified, and its magnitude is equal to or greater than the socket's current message count, the socket's message count is set to &lt;code&gt;0&lt;/code&gt;. Once the socket's message count reaches &lt;code&gt;0&lt;/code&gt;, either because of sending received data messages to the process or by being explicitly set, the process is then notified by a special message, specific to the type of socket, that the socket has entered passive mode. Once the socket enters passive mode, to receive more messages &lt;code&gt;setopts/2&lt;/code&gt; must be called again to set the socket back into an active mode.</source>
          <target state="translated">値が-32768〜32767の範囲の整数 &lt;code&gt;N&lt;/code&gt; である場合、値は、制御プロセスに送信されたデータメッセージのソケットの数に追加されます。ソケットのデフォルトのメッセージ数は &lt;code&gt;0&lt;/code&gt; です。負の値が指定され、その大きさがソケットの現在のメッセージ数以上の場合、ソケットのメッセージ数は &lt;code&gt;0&lt;/code&gt; に設定されます。受信したデータメッセージをプロセスに送信するため、または明示的に設定することによって、ソケットのメッセージカウントが &lt;code&gt;0&lt;/code&gt; に達すると、ソケットのタイプに固有の特別なメッセージによって、ソケットがパッシブモードになったことがプロセスに通知されます。ソケットがパッシブモードに入ると、より多くのメッセージを受信するために &lt;code&gt;setopts/2&lt;/code&gt; ソケットをアクティブモードに戻すには、再度呼び出す必要があります。</target>
        </trans-unit>
        <trans-unit id="1d64e50bdb357fa38cbabe7df4a1ba284de8e2a3" translate="yes" xml:space="preserve">
          <source>If the value is incomplete, which for example can be the case for the &lt;code&gt;config&lt;/code&gt; key, it is up to the handler implementation how the unspecified parts are set. For all handlers in the Kernel application, unspecified data for the &lt;code&gt;config&lt;/code&gt; key is not changed. To reset unspecified data to default values, use &lt;code&gt;&lt;a href=&quot;#set_handler_config-3&quot;&gt; set_handler_config/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">値は、例えばのためのケースであることができる、不完全な場合は &lt;code&gt;config&lt;/code&gt; キー、それが指定されていない部品が設定されているか、ハンドラの実装までです。カーネルアプリケーション内のすべてのハンドラの場合は、未指定のためのデータ &lt;code&gt;config&lt;/code&gt; キーは変更されません。未指定のデータをデフォルト値にリセットするには、 &lt;code&gt;&lt;a href=&quot;#set_handler_config-3&quot;&gt; set_handler_config/3&lt;/a&gt;&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="5530eeda0dbd39b2cfac3192200b6c910a3a3fc5" translate="yes" xml:space="preserve">
          <source>If the value is incomplete, which for example can be the case for the &lt;code&gt;config&lt;/code&gt; key, it is up to the handler implementation how the unspecified parts are set. For all handlers in the Kernel application, unspecified data for the &lt;code&gt;config&lt;/code&gt; key is set to default values. To update only specified data, and keep the existing configuration for the rest, use &lt;code&gt;&lt;a href=&quot;#update_handler_config-3&quot;&gt; update_handler_config/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">値は、例えばのためのケースであることができる、不完全な場合は &lt;code&gt;config&lt;/code&gt; キー、それが指定されていない部品が設定されているか、ハンドラの実装までです。カーネルアプリケーション内のすべてのハンドラの場合は、未指定のためのデータ &lt;code&gt;config&lt;/code&gt; キーがデフォルト値に設定されています。指定されたデータのみを更新し、残りの既存の構成を保持するには、 &lt;code&gt;&lt;a href=&quot;#update_handler_config-3&quot;&gt; update_handler_config/3&lt;/a&gt;&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="f27ae6e2444bd7a3381110a92ec6a09bd736a61c" translate="yes" xml:space="preserve">
          <source>If the value is unreached, the socket closes for that connection.</source>
          <target state="translated">値に到達していない場合は、その接続に対してソケットを閉じます。</target>
        </trans-unit>
        <trans-unit id="f1873f4ce26bcbe85d55d9e02a463ab1ca24901c" translate="yes" xml:space="preserve">
          <source>If the value of option &lt;code&gt;keep_labels&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, which is the default, the &lt;code&gt;&lt;a href=&quot;#label&quot;&gt;labels&lt;/a&gt;&lt;/code&gt; of vertices and edges of &lt;code&gt;Digraph&lt;/code&gt; are used for the subgraph as well. If the value is &lt;code&gt;false&lt;/code&gt;, default label &lt;code&gt;[]&lt;/code&gt; is used for the vertices and edges of the subgroup.</source>
          <target state="translated">オプション &lt;code&gt;keep_labels&lt;/code&gt; の値が &lt;code&gt;true&lt;/code&gt; （デフォルト）の場合、頂点の &lt;code&gt;&lt;a href=&quot;#label&quot;&gt;labels&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;Digraph&lt;/code&gt; エッジがサブグラフにも使用されます。値が &lt;code&gt;false&lt;/code&gt; の場合、サブグループの頂点とエッジにはデフォルトのラベル &lt;code&gt;[]&lt;/code&gt; が使用されます。</target>
        </trans-unit>
        <trans-unit id="4ff461d2c9c387ebf9328f2e5d5e82024d6aaa59" translate="yes" xml:space="preserve">
          <source>If the value of option &lt;code&gt;type&lt;/code&gt; is &lt;code&gt;inherit&lt;/code&gt;, which is the default, the type of &lt;code&gt;Digraph&lt;/code&gt; is used for the subgraph as well. Otherwise the option value of &lt;code&gt;type&lt;/code&gt; is used as argument to &lt;code&gt;&lt;a href=&quot;digraph#new-1&quot;&gt;digraph:new/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">オプションの値ならば &lt;code&gt;type&lt;/code&gt; ある &lt;code&gt;inherit&lt;/code&gt; デフォルトである、のタイプの &lt;code&gt;Digraph&lt;/code&gt; 、同様部分グラフに使用されます。それ以外の場合、 &lt;code&gt;type&lt;/code&gt; のオプション値は &lt;code&gt;&lt;a href=&quot;digraph#new-1&quot;&gt;digraph:new/1&lt;/a&gt;&lt;/code&gt; の引数として使用されます。</target>
        </trans-unit>
        <trans-unit id="bcc67adc4c7849178ee3be6d998ddde43abc28f4" translate="yes" xml:space="preserve">
          <source>If the value of option &lt;code&gt;type&lt;/code&gt; is &lt;code&gt;inherit&lt;/code&gt;, which is the default, the type of &lt;code&gt;Digraph&lt;/code&gt; is used for the subgraph as well. Otherwise the option value of &lt;code&gt;type&lt;/code&gt; is used as argument to &lt;code&gt;digraph:new/1&lt;/code&gt;.</source>
          <target state="translated">オプションの値ならば &lt;code&gt;type&lt;/code&gt; ある &lt;code&gt;inherit&lt;/code&gt; デフォルトである、のタイプの &lt;code&gt;Digraph&lt;/code&gt; 、同様部分グラフに使用されます。それ以外の場合、 &lt;code&gt;type&lt;/code&gt; のオプション値は &lt;code&gt;digraph:new/1&lt;/code&gt; の引数として使用されます。</target>
        </trans-unit>
        <trans-unit id="ba47bdc09cc087bab1feb6d4f337fa682850229e" translate="yes" xml:space="preserve">
          <source>If the values listed in &lt;code&gt;os_mon.app&lt;/code&gt; do not suit your needs, do &lt;strong&gt;not&lt;/strong&gt; edit that file. Instead &lt;strong&gt;override&lt;/strong&gt; the values in a &lt;strong&gt;system configuration file&lt;/strong&gt;, the full pathname of which is given on the command line to &lt;code&gt;erl&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;os_mon.app&lt;/code&gt; にリストされている値がニーズに合わない場合は、そのファイルを編集し&lt;strong&gt;ないで&lt;/strong&gt;ください。代わりに、&lt;strong&gt;システム構成ファイルの&lt;/strong&gt;値を&lt;strong&gt;オーバーライド&lt;/strong&gt;します。そのフルパス名は、コマンドラインで &lt;code&gt;erl&lt;/code&gt; に指定されます。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="637ddb8332f78117eadb8a8c376db3cd6652f59a" translate="yes" xml:space="preserve">
          <source>If the variable &lt;code&gt;V&lt;/code&gt; is unbound, it becomes bound to the value associated with the key &lt;code&gt;K&lt;/code&gt;, which must exist in the map &lt;code&gt;M&lt;/code&gt;. If the variable &lt;code&gt;V&lt;/code&gt; is bound, it must match the value associated with &lt;code&gt;K&lt;/code&gt; in &lt;code&gt;M&lt;/code&gt;.</source>
          <target state="translated">変数 &lt;code&gt;V&lt;/code&gt; がバインドされていない場合は、キー &lt;code&gt;K&lt;/code&gt; 関連付けられている値にバインドされます。これは、マップ &lt;code&gt;M&lt;/code&gt; に存在する必要があります。変数 &lt;code&gt;V&lt;/code&gt; がバインドされている場合、それは &lt;code&gt;M&lt;/code&gt; の &lt;code&gt;K&lt;/code&gt; に関連付けられた値と一致する必要があります。</target>
        </trans-unit>
        <trans-unit id="e06ed1ef13287cb442c8f8b9883fc1684b5a4b49" translate="yes" xml:space="preserve">
          <source>If the variable is set to &lt;code&gt;0&lt;/code&gt; seconds, the runtime system does not even attempt to write the crash dump file. It only terminates. This is the default if option &lt;code&gt;-heart&lt;/code&gt; is passed to &lt;code&gt;erl&lt;/code&gt; and &lt;code&gt;ERL_CRASH_DUMP_SECONDS&lt;/code&gt; is not set.</source>
          <target state="translated">変数が &lt;code&gt;0&lt;/code&gt; 秒に設定されている場合、ランタイムシステムはクラッシュダンプファイルへの書き込みを試みません。終了するだけです。オプションの場合、これがデフォルトです &lt;code&gt;-heart&lt;/code&gt; がに渡され &lt;code&gt;erl&lt;/code&gt; と &lt;code&gt;ERL_CRASH_DUMP_SECONDS&lt;/code&gt; が設定されていません。</target>
        </trans-unit>
        <trans-unit id="259fac0804e610fe7290a6be7722e9d68bc70fed" translate="yes" xml:space="preserve">
          <source>If the variable is set to a positive value &lt;code&gt;S&lt;/code&gt;, wait for &lt;code&gt;S&lt;/code&gt; seconds to complete the crash dump file and then terminates the runtime system with a &lt;code&gt;SIGALRM&lt;/code&gt; signal.</source>
          <target state="translated">変数が正の値 &lt;code&gt;S&lt;/code&gt; に設定されている場合、 &lt;code&gt;S&lt;/code&gt; 秒間待機してクラッシュダンプファイルを完了し、ランタイムシステムを &lt;code&gt;SIGALRM&lt;/code&gt; シグナルで終了します。</target>
        </trans-unit>
        <trans-unit id="f5ca06888e679b9ce4fb0be32462ee441fe3c9ca" translate="yes" xml:space="preserve">
          <source>If the verify callback fun always returns &lt;code&gt;{valid, UserState}&lt;/code&gt;, the TLS/DTLS handshake does not terminate regarding verification failures and the connection is established.</source>
          <target state="translated">検証コールバックfunが常に &lt;code&gt;{valid, UserState}&lt;/code&gt; 返す場合、検証の失敗に関してTLS / DTLSハンドシェイクは終了せず、接続が確立されます。</target>
        </trans-unit>
        <trans-unit id="719c8b9484d3005b5e9e676b6c959670afe78ad3" translate="yes" xml:space="preserve">
          <source>If the verify callback fun returns &lt;code&gt;{fail, Reason}&lt;/code&gt;, the verification process is immediately stopped, an alert is sent to the peer, and the TLS/DTLS handshake terminates.</source>
          <target state="translated">検証コールバックfunが &lt;code&gt;{fail, Reason}&lt;/code&gt; 返す場合、検証プロセスは直ちに停止され、アラートがピアに送信され、TLS / DTLSハンドシェイクが終了します。</target>
        </trans-unit>
        <trans-unit id="cde2fb6c16d058822f25ed6337c5a200ce4ffc36" translate="yes" xml:space="preserve">
          <source>If the verify callback fun returns &lt;code&gt;{fail, Reason}&lt;/code&gt;, the verification process is immediately stopped. If the verify callback fun returns &lt;code&gt;{valid, UserState}&lt;/code&gt;, the verification process is continued. This can be used to accept specific path validation errors, such as &lt;code&gt;selfsigned_peer&lt;/code&gt;, as well as verifying application-specific extensions. If called with an extension unknown to the user application, the return value &lt;code&gt;{unknown, UserState}&lt;/code&gt; is to be used.</source>
          <target state="translated">検証コールバックfunが &lt;code&gt;{fail, Reason}&lt;/code&gt; 返した場合、検証プロセスはすぐに停止されます。検証コールバックfunが &lt;code&gt;{valid, UserState}&lt;/code&gt; 返した場合、検証プロセスが続行されます。これは、 &lt;code&gt;selfsigned_peer&lt;/code&gt; などの特定のパス検証エラーを受け入れるため、およびアプリケーション固有の拡張機能を検証するために使用できます。ユーザーアプリケーションに不明な拡張子で呼び出された場合、戻り値 &lt;code&gt;{unknown, UserState}&lt;/code&gt; が使用されます。</target>
        </trans-unit>
        <trans-unit id="7ce417b1938b35d2181946cc1bbef96b4151dd19" translate="yes" xml:space="preserve">
          <source>If the verify callback fun returns &lt;code&gt;{valid, UserState}&lt;/code&gt;, the verification process continues.</source>
          <target state="translated">検証コールバックfunが &lt;code&gt;{valid, UserState}&lt;/code&gt; 返した場合、検証プロセスが続行されます。</target>
        </trans-unit>
        <trans-unit id="0df79b705a85e7a2500ba7951bd6d85a1ee9ec5b" translate="yes" xml:space="preserve">
          <source>If the version read from the &lt;code&gt;OTP_VERSION&lt;/code&gt; file in a development system has a &lt;code&gt;**&lt;/code&gt; suffix, the system has been patched using the &lt;code&gt;&lt;a href=&quot;../installation_guide/otp-patch-apply&quot;&gt;otp_patch_apply&lt;/a&gt;&lt;/code&gt; tool. In this case, the system consists of application versions from multiple OTP versions. The version preceding the &lt;code&gt;**&lt;/code&gt; suffix corresponds to the OTP version of the base system that has been patched. Notice that if a development system is updated by other means than &lt;code&gt;otp_patch_apply&lt;/code&gt;, the file &lt;code&gt;OTP_VERSION&lt;/code&gt; can identify an incorrect OTP version.</source>
          <target state="translated">開発システムの &lt;code&gt;OTP_VERSION&lt;/code&gt; ファイルから読み取られたバージョンに &lt;code&gt;**&lt;/code&gt; サフィックスが付いている場合、システムには &lt;code&gt;&lt;a href=&quot;../installation_guide/otp-patch-apply&quot;&gt;otp_patch_apply&lt;/a&gt;&lt;/code&gt; ツールを使用してパッチが適用されています。この場合、システムは複数のOTPバージョンのアプリケーションバージョンで構成されます。 &lt;code&gt;**&lt;/code&gt; サフィックスの前のバージョンは、パッチが適用された基本システムのOTPバージョンに対応しています。 &lt;code&gt;otp_patch_apply&lt;/code&gt; 以外の方法で開発システムが更新された場合、OTP_VERSIONファイルが誤ったOTPバージョンを識別できることに &lt;code&gt;OTP_VERSION&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e21657b92f7a7a61994f9d4f2c34a81fd507ae44" translate="yes" xml:space="preserve">
          <source>If the version read from the &lt;code&gt;OTP_VERSION&lt;/code&gt; file in a development system has a &lt;code&gt;**&lt;/code&gt; suffix, the system has been patched using the &lt;code&gt;otp_patch_apply&lt;/code&gt; tool. In this case, the system consists of application versions from multiple OTP versions. The version preceding the &lt;code&gt;**&lt;/code&gt; suffix corresponds to the OTP version of the base system that has been patched. Notice that if a development system is updated by other means than &lt;code&gt;otp_patch_apply&lt;/code&gt;, the file &lt;code&gt;OTP_VERSION&lt;/code&gt; can identify an incorrect OTP version.</source>
          <target state="translated">開発システムの &lt;code&gt;OTP_VERSION&lt;/code&gt; ファイルから読み取られたバージョンに &lt;code&gt;**&lt;/code&gt; サフィックスが付いている場合、システムは &lt;code&gt;otp_patch_apply&lt;/code&gt; ツールを使用してパッチが適用されています。この場合、システムは複数のOTPバージョンのアプリケーションバージョンで構成されます。 &lt;code&gt;**&lt;/code&gt; サフィックスの前のバージョンは、パッチが適用されたベースシステムのOTPバージョンに対応します。開発システムが &lt;code&gt;otp_patch_apply&lt;/code&gt; 以外の方法で更新された場合、ファイル &lt;code&gt;OTP_VERSION&lt;/code&gt; が誤ったOTPバージョンを識別できることに注意してください。</target>
        </trans-unit>
        <trans-unit id="f230a4391a7ac08d14e4fb4510c5ba298ff9d5d7" translate="yes" xml:space="preserve">
          <source>If the wrap log is not full because all files are not yet used, &lt;code&gt;{error, end_of_log}&lt;/code&gt; is returned if trying to step outside the log.</source>
          <target state="translated">すべてのファイルがまだ使用されていないため &lt;code&gt;{error, end_of_log}&lt;/code&gt; ない場合、ログの外に出ようとすると、{error、end_of_log}が返されます。</target>
        </trans-unit>
        <trans-unit id="f46b1e432470475ec50697579521d2c2bae67ee6" translate="yes" xml:space="preserve">
          <source>If then a new instance of the module is loaded (for example, because of error correction), the code of the previous instance becomes 'old', and all export entries referring to the previous instance are removed. After that, the new instance is loaded as for the first time, and becomes 'current'.</source>
          <target state="translated">その後、モジュールの新しいインスタンスがロードされると(例えば、エラー修正のために)、前のインスタンスのコードは「古い」になり、前のインスタンスを参照しているすべてのエクスポートエントリが削除されます。その後、新しいインスタンスは初めてロードされ、'current' になります。</target>
        </trans-unit>
        <trans-unit id="a1c29be5cd8e91fa1db97518d47656645435250e" translate="yes" xml:space="preserve">
          <source>If there already exists a child specification with the specified identifier, &lt;code&gt;ChildSpec&lt;/code&gt; is discarded, and the function returns &lt;code&gt;{error,already_present}&lt;/code&gt; or &lt;code&gt;{error,{already_started,Child}}&lt;/code&gt;, depending on if the corresponding child process is running or not.</source>
          <target state="translated">指定された識別子を &lt;code&gt;ChildSpec&lt;/code&gt; 仕様がすでに存在する場合、ChildSpecは破棄され、対応する子プロセスが実行されているかどうかに応じて、関数は &lt;code&gt;{error,already_present}&lt;/code&gt; または &lt;code&gt;{error,{already_started,Child}}&lt;/code&gt; 返します。</target>
        </trans-unit>
        <trans-unit id="29f67842a562c035ba90f5d1c233372af3669459" translate="yes" xml:space="preserve">
          <source>If there already exists a process with the specified &lt;code&gt;SupBridgeName&lt;/code&gt;, the function returns &lt;code&gt;{error,{already_started,Pid}}&lt;/code&gt;, where &lt;code&gt;Pid&lt;/code&gt; is the pid of that process.</source>
          <target state="translated">指定された &lt;code&gt;SupBridgeName&lt;/code&gt; を持つプロセスがすでに存在する場合、関数は &lt;code&gt;{error,{already_started,Pid}}&lt;/code&gt; 返します。ここで、 &lt;code&gt;Pid&lt;/code&gt; はそのプロセスのpidです。</target>
        </trans-unit>
        <trans-unit id="b068d3b22b44bd5f6e7c211c147d05d61566b01d" translate="yes" xml:space="preserve">
          <source>If there already exists a process with the specified &lt;code&gt;SupName&lt;/code&gt;, the function returns &lt;code&gt;{error,{already_started,Pid}}&lt;/code&gt;, where &lt;code&gt;Pid&lt;/code&gt; is the pid of that process.</source>
          <target state="translated">指定された &lt;code&gt;SupName&lt;/code&gt; を持つプロセスがすでに存在する場合、関数は &lt;code&gt;{error,{already_started,Pid}}&lt;/code&gt; 返します。ここで、 &lt;code&gt;Pid&lt;/code&gt; はそのプロセスのpidです。</target>
        </trans-unit>
        <trans-unit id="b8fb3b2e8b37c9a0306fd62b9b9f0fc3fa52b199" translate="yes" xml:space="preserve">
          <source>If there already is current code for the module, that code will remain current and can be called until the &lt;code&gt;on_load&lt;/code&gt; function has returned. If the &lt;code&gt;on_load&lt;/code&gt; function fails, the current code (if any) will remain current. If there is no current code for a module, any process that makes an external call to the module before the &lt;code&gt;on_load&lt;/code&gt; function has finished will be suspended until the &lt;code&gt;on_load&lt;/code&gt; function have finished.</source>
          <target state="translated">モジュールの現在のコードがすでに存在する場合、そのコードは現在のままであり、 &lt;code&gt;on_load&lt;/code&gt; 関数が戻るまで呼び出すことができます。場合 &lt;code&gt;on_load&lt;/code&gt; の機能に障害が発生し、現在のコードは、（もしあれば）現在のままになります。モジュールには、現在のコードが存在しない場合は、前のモジュールへの外部呼び出しを行う任意のプロセス &lt;code&gt;on_load&lt;/code&gt; まで機能が終了したが中断されます &lt;code&gt;on_load&lt;/code&gt; の機能が完成しています。</target>
        </trans-unit>
        <trans-unit id="e6ff40b943ba1d358ca3fc56a993cb85906a59fb" translate="yes" xml:space="preserve">
          <source>If there are enqueued events the &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;&lt;strong&gt;state callback&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; for the possibly new state is called with the oldest enqueued event, and we start again from the top of this sequence.</source>
          <target state="translated">キューに入れられたイベントがある場合、新しい可能性のある &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;&lt;strong&gt;state callback&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; が最も古いキューに入れられたイベントで呼び出され、このシーケンスの先頭から再開します。</target>
        </trans-unit>
        <trans-unit id="828714b66dcf56b96deedb054ba47d438cc6af67" translate="yes" xml:space="preserve">
          <source>If there are enqueued events the &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; for the possibly new state is called with the oldest enqueued event, and we start again from the top of this list.</source>
          <target state="translated">キューに入れられたイベントがある場合、おそらく新しい状態の &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; が最も古いキューに入れられたイベントで呼び出され、このリストの先頭から再び開始します。</target>
        </trans-unit>
        <trans-unit id="e9b0222c78d7e23a53bc0a01971716c3d93b0537" translate="yes" xml:space="preserve">
          <source>If there are enqueued events to process when hibrnation is requested, this is optimized by not hibernating but instead calling &lt;code&gt; erlang:garbage_collect/0 &lt;/code&gt; to simulate that the &lt;code&gt;gen_statem&lt;/code&gt; entered hibernation and immediately got awakened by an enqueued event.</source>
          <target state="translated">休止状態が要求されたときに処理するキューに入れられたイベントがある場合、これは休止状態ではなく、代わりに &lt;code&gt; erlang:garbage_collect/0 &lt;/code&gt; を呼び出して、 &lt;code&gt;gen_statem&lt;/code&gt; が休止状態に入り、すぐにキューに入れられたイベントによって起こされることをシミュレートすることによって最適化されます。</target>
        </trans-unit>
        <trans-unit id="44555dd341d5b0e52ff1661ee5eda131159416ee" translate="yes" xml:space="preserve">
          <source>If there are enqueued events to process when hibrnation is requested, this is optimized by not hibernating but instead calling &lt;code&gt;erlang:garbage_collect/0&lt;/code&gt; to simulate that the &lt;code&gt;gen_statem&lt;/code&gt; entered hibernation and immediately got awakened by an enqueued event.</source>
          <target state="translated">ハイバネーションが要求されたときに処理するキューに入れられたイベントがある場合、休止状態ではなく &lt;code&gt;erlang:garbage_collect/0&lt;/code&gt; を呼び出すことでこれが最適化され、 &lt;code&gt;gen_statem&lt;/code&gt; がハイバネーションに入り、キューに入れられたイベントによってすぐに起動します。</target>
        </trans-unit>
        <trans-unit id="8322fe14ba9a9426d69e7f2423c508cc09e9ca48" translate="yes" xml:space="preserve">
          <source>If there are more than one modify_algorithms options, the result is undefined.</source>
          <target state="translated">複数の modify_algorithms オプションがある場合、結果は未定義です。</target>
        </trans-unit>
        <trans-unit id="3690ce212d6493d7841d406b4cec0802d81f2e96" translate="yes" xml:space="preserve">
          <source>If there are no more associations in the iterator, &lt;code&gt;none&lt;/code&gt; is returned.</source>
          <target state="translated">イテレータに関連付けがなくなると、 &lt;code&gt;none&lt;/code&gt; も返されません。</target>
        </trans-unit>
        <trans-unit id="e9815b352e2d989c9ac48ca673c35c72745e841d" translate="yes" xml:space="preserve">
          <source>If there are no records in the table, this function returns the atom &lt;code&gt;'$end_of_table'&lt;/code&gt;. It is not recommended to use this atom as the key for any user records.</source>
          <target state="translated">テーブルにレコードがない場合、この関数はアトム &lt;code&gt;'$end_of_table'&lt;/code&gt; 返します。このアトムをユーザーレコードのキーとして使用することはお勧めしません。</target>
        </trans-unit>
        <trans-unit id="45cad60d0486a292ed0c0af70654056064441d58" translate="yes" xml:space="preserve">
          <source>If there are no records in the table, this function returns the atom &lt;code&gt;'$end_of_table'&lt;/code&gt;. It is therefore highly undesirable, but not disallowed, to use this atom as the key for any user records.</source>
          <target state="translated">テーブルにレコードがない場合、この関数はアトム &lt;code&gt;'$end_of_table'&lt;/code&gt; 返します。したがって、このアトムをユーザーレコードのキーとして使用することは非常に望ましくありませんが、禁止されていません。</target>
        </trans-unit>
        <trans-unit id="8503df3ac3ca7273d732e58802cad2a3a0dfc645" translate="yes" xml:space="preserve">
          <source>If there are no suitable peers, or if &lt;code&gt;pick_peer/4&lt;/code&gt; rejects them by returning &lt;code&gt;false&lt;/code&gt;, then &lt;code&gt;{error,no_connection}&lt;/code&gt; is returned. Otherwise &lt;code&gt;pick_peer/4&lt;/code&gt; is followed by a &lt;code&gt;prepare_request/3&lt;/code&gt; callback, the message is encoded and then sent.</source>
          <target state="translated">適切なピアがない場合、または &lt;code&gt;pick_peer/4&lt;/code&gt; が &lt;code&gt;false&lt;/code&gt; を返すことでそれらを拒否した場合は、 &lt;code&gt;{error,no_connection}&lt;/code&gt; が返されます。それ以外の場合、 &lt;code&gt;pick_peer/4&lt;/code&gt; の後に &lt;code&gt;prepare_request/3&lt;/code&gt; コールバックが続き、メッセージはエンコードされてから送信されます。</target>
        </trans-unit>
        <trans-unit id="17bbd36158389d16f581ae00cabe7d0d4b0d0c37" translate="yes" xml:space="preserve">
          <source>If there are open NETCONF sessions on the connection, these will be brutally aborted. To avoid this, close each session with &lt;code&gt;&lt;a href=&quot;#close_session-1&quot;&gt;close_session/1,2&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">接続で開いているNETCONFセッションがある場合、これらは残酷に中止されます。これを回避するには、各セッションを &lt;code&gt;&lt;a href=&quot;#close_session-1&quot;&gt;close_session/1,2&lt;/a&gt;&lt;/code&gt; で閉じます。</target>
        </trans-unit>
        <trans-unit id="744bfeb045fa800e48c24a368ddf960ab780e491" translate="yes" xml:space="preserve">
          <source>If there are other &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; of the driver, the reference counts of the driver is merely decreased, so that the caller is no longer considered a &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; of the driver. For use scenarios, see the &lt;code&gt;&lt;a href=&quot;#scenarios&quot;&gt;description&lt;/a&gt;&lt;/code&gt; in the beginning of this module.</source>
          <target state="translated">ドライバーの他の &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; がいる場合、ドライバーの参照カウントは減少するだけなので、呼び出し元はドライバーの &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; とは見なされなくなります。使用シナリオ &lt;code&gt;&lt;a href=&quot;#scenarios&quot;&gt;description&lt;/a&gt;&lt;/code&gt; は、このモジュールの冒頭の説明を参照してください。</target>
        </trans-unit>
        <trans-unit id="ad1eb612ef6dd4e45361d0987788045dfb4b5f75" translate="yes" xml:space="preserve">
          <source>If there are other &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; of the driver, the reference counts of the driver is merely decreased, so that the caller is no longer considered a &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt;. For use scenarios, see the &lt;code&gt;&lt;a href=&quot;#scenarios&quot;&gt;description&lt;/a&gt;&lt;/code&gt; in the beginning of this module.</source>
          <target state="translated">ドライバーの他の &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; がいる場合、ドライバーの参照カウントは単に減少するだけなので、呼び出し元は &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; とは見なされなくなります。使用シナリオ &lt;code&gt;&lt;a href=&quot;#scenarios&quot;&gt;description&lt;/a&gt;&lt;/code&gt; は、このモジュールの冒頭の説明を参照してください。</target>
        </trans-unit>
        <trans-unit id="3a3b63451c0aef92b5965292576792be22d886c0" translate="yes" xml:space="preserve">
          <source>If there are other &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; of this driver, the function returns &lt;code&gt;{error, pending_process}&lt;/code&gt;, but if there are no other users, the function call hangs until all open ports are closed.</source>
          <target state="translated">このドライバーの他の &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; がいる場合、関数は &lt;code&gt;{error, pending_process}&lt;/code&gt; 返しますが、他のユーザーがいない場合、開いているすべてのポートが閉じるまで、関数呼び出しはハングします。</target>
        </trans-unit>
        <trans-unit id="ddfc5d95528ec782f6cb446ae853ade32ce2c1f9" translate="yes" xml:space="preserve">
          <source>If there are two active table replicas, all information is still available if one replica fails. This can be an important property in many applications. Furthermore, if a table replica exists at two specific nodes, applications that execute at either of these nodes can read data from the table without accessing the network. Network operations are considerably slower and consume more resources than local operations.</source>
          <target state="translated">アクティブなテーブルレプリカが2つある場合、1つのレプリカが失敗してもすべての情報が利用可能です。これは多くのアプリケーションで重要な特性となります。さらに、テーブルレプリカが2つの特定のノードに存在する場合、これらのノードのいずれかで実行するアプリケーションは、ネットワークにアクセスせずにテーブルからデータを読み取ることができます。ネットワーク操作は、ローカル操作よりもかなり遅く、より多くのリソースを消費します。</target>
        </trans-unit>
        <trans-unit id="4c985df66903880210d4fc66a0001c590df114fc" translate="yes" xml:space="preserve">
          <source>If there existed a previous persistent term associated with key &lt;code&gt;Key&lt;/code&gt;, a global GC has been initiated when &lt;code&gt;erase/1&lt;/code&gt; returns. See &lt;code&gt;&lt;a href=&quot;#description&quot;&gt;Description&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">キー &lt;code&gt;Key&lt;/code&gt; に関連付けられた以前の永続的な用語が存在した場合、 &lt;code&gt;erase/1&lt;/code&gt; が戻ったときにグローバルGCが開始されています。 &lt;code&gt;&lt;a href=&quot;#description&quot;&gt;Description&lt;/a&gt;&lt;/code&gt; 参照してください。</target>
        </trans-unit>
        <trans-unit id="370b7e007fd730b4b67804cb8f3411b765c85a30" translate="yes" xml:space="preserve">
          <source>If there existed a previous persistent term associated with key &lt;code&gt;Key&lt;/code&gt;, a global GC has been initiated when &lt;code&gt;put/2&lt;/code&gt; returns. See &lt;code&gt;&lt;a href=&quot;#description&quot;&gt;Description&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">キー &lt;code&gt;Key&lt;/code&gt; に関連付けられた以前の永続的な用語が存在した場合、 &lt;code&gt;put/2&lt;/code&gt; が戻ったときにグローバルGCが開始されています。 &lt;code&gt;&lt;a href=&quot;#description&quot;&gt;Description&lt;/a&gt;&lt;/code&gt; 参照してください。</target>
        </trans-unit>
        <trans-unit id="02a74b61b8a7a65ef993947d91f15d8fda49a9eb" translate="yes" xml:space="preserve">
          <source>If there has not been any exceptions in a process, the stacktrace is &lt;code&gt;[]&lt;/code&gt;. After a code change for the process, the stacktrace can also be reset to &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">プロセスに例外がなかった場合、スタックトレースは &lt;code&gt;[]&lt;/code&gt; です。プロセスのコードを変更した後、スタックトレースを &lt;code&gt;[]&lt;/code&gt; にリセットすることもできます。</target>
        </trans-unit>
        <trans-unit id="231307e5b86795ba02c3c7007a265d1b3815a9d6" translate="yes" xml:space="preserve">
          <source>If there is NO &lt;code&gt;Subject Alternate Name&lt;/code&gt; field, the &lt;code&gt;Subject&lt;/code&gt; field will be checked. All &lt;code&gt;CN&lt;/code&gt; names will be compared to all hostnames</source>
          <target state="translated">NOがない場合は &lt;code&gt;Subject Alternate Name&lt;/code&gt; フィールドには、 &lt;code&gt;Subject&lt;/code&gt; フィールドがチェックされます。すべての &lt;code&gt;CN&lt;/code&gt; 名がすべてのホスト名と比較されます</target>
        </trans-unit>
        <trans-unit id="68e6d1b8204d4e4cbe66b0a3f70bd3fdbea57001" translate="yes" xml:space="preserve">
          <source>If there is a &lt;code&gt;Subject Alternate Name&lt;/code&gt; field, the &lt;code&gt;{uri_id,string()}&lt;/code&gt; in the function call will be compared to any &lt;code&gt;{uniformResourceIdentifier,string()}&lt;/code&gt; in the Certificate field. If the two &lt;code&gt;strings()&lt;/code&gt; are equal (case insensitive), there is a match. The same applies for any &lt;code&gt;{dns_id,string()}&lt;/code&gt; in the call which is compared with all &lt;code&gt;{dNSName,string()}&lt;/code&gt; in the Certificate field.</source>
          <target state="translated">存在する場合に &lt;code&gt;Subject Alternate Name&lt;/code&gt; フィールド、 &lt;code&gt;{uri_id,string()}&lt;/code&gt; 関数呼び出しで任意に比較される &lt;code&gt;{uniformResourceIdentifier,string()}&lt;/code&gt; 証明書のフィールドです。2つの &lt;code&gt;strings()&lt;/code&gt; が等しい場合（大文字と小文字は区別されません）、一致があります。同じことが、任意に適用 &lt;code&gt;{dns_id,string()}&lt;/code&gt; すべてと比較されるコールに &lt;code&gt;{dNSName,string()}&lt;/code&gt; 証明書のフィールドです。</target>
        </trans-unit>
        <trans-unit id="7f945a017af252bdab418ccd24ce5005c146d8f7" translate="yes" xml:space="preserve">
          <source>If there is a &lt;code&gt;Value&lt;/code&gt; in &lt;code&gt;List&lt;/code&gt; such that &lt;code&gt;Pred(Value)&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;, returns &lt;code&gt;{value, Value}&lt;/code&gt; for the first such &lt;code&gt;Value&lt;/code&gt;, otherwise returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">存在する場合に &lt;code&gt;Value&lt;/code&gt; に &lt;code&gt;List&lt;/code&gt; するよう &lt;code&gt;Pred(Value)&lt;/code&gt; を返し &lt;code&gt;true&lt;/code&gt; 、戻り &lt;code&gt;{value, Value}&lt;/code&gt; 最初のそのようなための &lt;code&gt;Value&lt;/code&gt; 、それ以外の場合は返し &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8f55a97af173d19104e4db4d68ae43bf0a349635" translate="yes" xml:space="preserve">
          <source>If there is a garbage collection before the result is stored, the stack will move and if the &lt;code&gt;d&lt;/code&gt; operand refered to a Y register, the pointer will no longer be valid. (Y registers are stored on the stack.)</source>
          <target state="translated">結果が格納される前にガベージコレクションがある場合、スタックは移動し、 &lt;code&gt;d&lt;/code&gt; オペランドがYレジスタを参照している場合、ポインタは無効になります。（Yレジスタはスタックに格納されます。）</target>
        </trans-unit>
        <trans-unit id="d37a03a5a10dfe3b584b5087ad2e3ee6b552e40a" translate="yes" xml:space="preserve">
          <source>If there is a matching failure to the right, backtracking onto (*PRUNE) causes it to be triggered, and its action is taken. There can never be a backtrack onto (*COMMIT).</source>
          <target state="translated">右側にマッチング失敗がある場合、(*PRUNE)にバックトラックすると、それがトリガーされ、そのアクションが実行されます。(*COMMIT)へのバックトラックはありえません。</target>
        </trans-unit>
        <trans-unit id="772eaa5a9bb7c808e1d1ad944ded54de87cfcbf6" translate="yes" xml:space="preserve">
          <source>If there is a syntax error somewhere in the text (like the missing semicolon in the second clause above) this allows Merl to generate an error message pointing to the exact line in your source code. (Just remember to comma-separate the strings in the list, otherwise Erlang will concatenate the string fragments as if they were a single string.)</source>
          <target state="translated">もしテキストのどこかに構文エラーがあった場合(上の2つ目の節のセミコロンの欠落など)、Merlはあなたのソースコードの正確な行を示すエラーメッセージを生成します。(リストの中の文字列はカンマで区切ることを忘れないでください。そうしないとErlangは文字列の断片をあたかも一つの文字列であるかのように連結してしまいます)</target>
        </trans-unit>
        <trans-unit id="eb988198b3b89a8ead41c2c06ba00583a45e57ec" translate="yes" xml:space="preserve">
          <source>If there is an &lt;code&gt;&lt;a href=&quot;ssh#type-preferred_algorithms_common_option&quot;&gt;preferred_algorithms&lt;/a&gt;&lt;/code&gt; option on some level the whole set is replaced by that in that option and &lt;strong&gt;all modify_algorithms are applied&lt;/strong&gt; in level ordering.</source>
          <target state="translated">あるレベルに &lt;code&gt;&lt;a href=&quot;ssh#type-preferred_algorithms_common_option&quot;&gt;preferred_algorithms&lt;/a&gt;&lt;/code&gt; オプションがある場合、セット全体がそのオプションのオプションに置き換えられ、&lt;strong&gt;すべてのmodify_algorithmsが&lt;/strong&gt;レベルの順序で&lt;strong&gt;適用さ&lt;/strong&gt;れます。</target>
        </trans-unit>
        <trans-unit id="f8de65cd10bf00bba2999acc7df58c16d7692021" translate="yes" xml:space="preserve">
          <source>If there is data buffered in the socket port, the attempt to shutdown the socket is postponed until that data is written to the kernel socket send buffer. If any errors are encountered, the socket is closed and &lt;code&gt;{error, closed}&lt;/code&gt; is returned on the next &lt;code&gt;&lt;a href=&quot;#recv-2&quot;&gt;recv/2&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#send-2&quot;&gt;send/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">ソケットポートにバッファリングされているデータがある場合、そのデータがカーネルソケット送信バッファに書き込まれるまで、ソケットをシャットダウンする試みは延期されます。エラーが発生した場合、ソケットは閉じられ、次の &lt;code&gt;&lt;a href=&quot;#recv-2&quot;&gt;recv/2&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;#send-2&quot;&gt;send/2&lt;/a&gt;&lt;/code&gt; で &lt;code&gt;{error, closed}&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="ab5c589483e29b598b39704e5336b70db6c69642" translate="yes" xml:space="preserve">
          <source>If there is more than one subpattern with the same name, the earliest one is used.</source>
          <target state="translated">同じ名前のサブパターンが複数ある場合は、最も古いものを使用します。</target>
        </trans-unit>
        <trans-unit id="bbc551c6c725ba0dac8c61943a105b6a103c7e97" translate="yes" xml:space="preserve">
          <source>If there is no matching message in the mailbox, the timeout occurs immediately.</source>
          <target state="translated">メールボックスに一致するメッセージがない場合は、直ちにタイムアウトとなります。</target>
        </trans-unit>
        <trans-unit id="cc738995866b9be8195d9f8399cccd32d281ee8b" translate="yes" xml:space="preserve">
          <source>If there is no matching pattern with a true guard sequence, a &lt;code&gt;case_clause&lt;/code&gt; run-time error occurs.</source>
          <target state="translated">真のガードシーケンスと一致するパターンがない場合、 &lt;code&gt;case_clause&lt;/code&gt; ランタイムエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="f5a0ffa17cfe9167811739038f7d8ac026fb1794" translate="yes" xml:space="preserve">
          <source>If there is no public key of a specified type available, the corresponding entry is ignored. Note that the available set is dependent on the underlying cryptolib and current user's public keys.</source>
          <target state="translated">指定された型の公開鍵が利用できない場合、対応するエントリは無視されます。利用可能なセットは、基礎となるcryptolibと現在のユーザの公開鍵に依存することに注意してください。</target>
        </trans-unit>
        <trans-unit id="2104c47ce32bc96eff6c32dbc5479f514ba24093" translate="yes" xml:space="preserve">
          <source>If there is not enough space available on the heap to satisfy the &lt;code&gt;test_heap&lt;/code&gt; instructions request for memory, then a garbage collection is initiated. It may happen immediately in the &lt;code&gt;test_heap&lt;/code&gt; instruction, or it can be delayed until a later time depending on what state the process is in. If the garbage collection is delayed, any memory needed will be allocated in heap fragments. Heap fragments are extra memory blocks that are a part of the young heap, but are not allocated in the contigious area where terms normally reside. See &lt;code&gt;&lt;a href=&quot;#The-young-heap&quot;&gt;The young heap&lt;/a&gt;&lt;/code&gt; for more details.</source>
          <target state="translated">ヒープ上にメモリに対する &lt;code&gt;test_heap&lt;/code&gt; 命令の要求を満たすのに十分なスペースがない場合、ガベージコレクションが開始されます。これは、 &lt;code&gt;test_heap&lt;/code&gt; 命令ですぐに発生する場合もあれば、プロセスの状態に応じて後で遅延する場合もあります。ガベージコレクションが遅延すると、必要なメモリがヒープフラグメントに割り当てられます。ヒープフラグメントは、若いヒープの一部である追加のメモリブロックですが、用語が通常存在する隣接領域には割り当てられません。詳細については &lt;code&gt;&lt;a href=&quot;#The-young-heap&quot;&gt;The young heap&lt;/a&gt;&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="8c43ed956f51818838543c55451a2fcd8d8fee88" translate="yes" xml:space="preserve">
          <source>If there was a supervised connection between &lt;code&gt;Handler1&lt;/code&gt; and a process &lt;code&gt;Pid&lt;/code&gt;, there is a supervised connection between &lt;code&gt;Handler2&lt;/code&gt; and &lt;code&gt;Pid&lt;/code&gt; instead.</source>
          <target state="translated">&lt;code&gt;Handler1&lt;/code&gt; とプロセス &lt;code&gt;Pid&lt;/code&gt; の間に監視された接続があった場合、代わりに &lt;code&gt;Handler2&lt;/code&gt; と &lt;code&gt;Pid&lt;/code&gt; の間に監視された接続があります。</target>
        </trans-unit>
        <trans-unit id="3c67211fc881043f6c0597b9ecfceb976f47baf4" translate="yes" xml:space="preserve">
          <source>If there was some bug in &lt;code&gt;lists:reverse/1&lt;/code&gt; that made it return something other than &lt;code&gt;[2,1]&lt;/code&gt; when it got &lt;code&gt;[1,2]&lt;/code&gt; as input, then the last test above would throw a &lt;code&gt;badmatch&lt;/code&gt; error. The first two (we assume they do not get a &lt;code&gt;badmatch&lt;/code&gt;) would simply return &lt;code&gt;[]&lt;/code&gt; and &lt;code&gt;[1]&lt;/code&gt;, respectively, so both succeed. (Note that EUnit is not psychic: if you write a test that returns a value, even if it is the wrong value, EUnit will consider it a success. You must make sure that the test is written so that it causes a crash if the result is not what it should be.)</source>
          <target state="translated">&lt;code&gt;[1,2]&lt;/code&gt; を入力として &lt;code&gt;badmatch&lt;/code&gt; ときに、 &lt;code&gt;lists:reverse/1&lt;/code&gt; が &lt;code&gt;[2,1]&lt;/code&gt; 以外の何かを返すバグがあった場合、上記の最後のテストでbadmatchエラーがスローされました。最初の2つ（ &lt;code&gt;badmatch&lt;/code&gt; を取得しないと想定）は、それぞれ &lt;code&gt;[]&lt;/code&gt; と &lt;code&gt;[1]&lt;/code&gt; を返すだけなので、どちらも成功します。 （EUnitは精神的なものではないことに注意してください。値を返すテストを作成した場合、たとえそれが間違った値であっても、EUnitはそれを成功と見なします。テストが書かれていることを確認する必要があります。結果は本来あるべきものではありません。）</target>
        </trans-unit>
        <trans-unit id="ac4dc8c4f9cc87ef06af906dc31bb54276084fd9" translate="yes" xml:space="preserve">
          <source>If these requirements are not fulfilled, the system may behave very bad.</source>
          <target state="translated">これらの要件が満たされていないと、システムの動作が非常に悪くなる可能性があります。</target>
        </trans-unit>
        <trans-unit id="b741a6b0067d17a99e20727d386f0f44e405815c" translate="yes" xml:space="preserve">
          <source>If these return values are used from a &lt;strong&gt;state enter call&lt;/strong&gt; the &lt;code&gt;OldState&lt;/code&gt; does not change, but if used from an event handling &lt;strong&gt;state callback&lt;/strong&gt; the new &lt;strong&gt;state enter call's&lt;/strong&gt;&lt;code&gt;OldState&lt;/code&gt; will be the current state.</source>
          <target state="translated">これらの戻り値が&lt;strong&gt;状態入力呼び出し&lt;/strong&gt;から使用される場合、 &lt;code&gt;OldState&lt;/code&gt; は変更されませんが、イベント処理&lt;strong&gt;状態コールバック&lt;/strong&gt;から使用される場合、新しい&lt;strong&gt;状態入力呼び出しの&lt;/strong&gt; &lt;code&gt;OldState&lt;/code&gt; が現在の状態になります。</target>
        </trans-unit>
        <trans-unit id="5e69ed9e46453ec19298157c854f6a3eaec0abc5" translate="yes" xml:space="preserve">
          <source>If this attribute is not specified, the version defaults to the MD5 checksum of the module.</source>
          <target state="translated">この属性が指定されていない場合、バージョンはモジュールの MD5 チェックサムをデフォルトとします。</target>
        </trans-unit>
        <trans-unit id="aa0c65a5a17658e764f89aa9eb9e0a1ff2afe4bb" translate="yes" xml:space="preserve">
          <source>If this callback is exported but fails, to hide possibly sensitive data, the default function will instead return &lt;code&gt;{State,Info}&lt;/code&gt;, where &lt;code&gt;Info&lt;/code&gt; says nothing but the fact that &lt;code&gt;format_status/2&lt;/code&gt; has crashed.</source>
          <target state="translated">このコールバックは、エクスポートが、おそらく機密データを非表示にするには、失敗した場合、デフォルトの機能が代わりに返されます &lt;code&gt;{State,Info}&lt;/code&gt; 、どこ &lt;code&gt;Info&lt;/code&gt; 何もなく、事実言わない &lt;code&gt;format_status/2&lt;/code&gt; がクラッシュしたが。</target>
        </trans-unit>
        <trans-unit id="714e5e0a8e521c47efda0340fa656dbd50e5c01b" translate="yes" xml:space="preserve">
          <source>If this configuration parameter is set, it replaces both the default report callback, and any report callback found in metadata. That is, all reports are converted by this configured function.</source>
          <target state="translated">この構成パラメータが設定されている場合、デフォルトのレポート・コールバックとメタデータ内の任意のレポート・コールバックの両方が置き換えられます。つまり、すべてのレポートはこの設定された関数によって変換されます。</target>
        </trans-unit>
        <trans-unit id="1be583879f0eb7412bbdfda911217bb43a748c07" translate="yes" xml:space="preserve">
          <source>If this does not work on your system, the documentation is included as HTML in the Erlang/OTP release. You can also read the documentation as HTML or download it as PDF from either of the sites www.erlang.se (commercial Erlang) or www.erlang.org (open source). For example, for Erlang/OTP release R9B:</source>
          <target state="translated">もしこれがあなたのシステムで動作しない場合、Erlang/OTPリリースにはドキュメントがHTMLとして含まれています。ドキュメントをHTMLで読んだり、www.erlang.se (商用Erlang)やwww.erlang.org (オープンソース)のサイトからPDFでダウンロードすることもできます。例えば、Erlang/OTPリリースR9Bの場合。</target>
        </trans-unit>
        <trans-unit id="a3eb530f2543acfe6aa144c1bf97c7dbef8076b8" translate="yes" xml:space="preserve">
          <source>If this feature is used while no such &lt;code&gt;TimeoutType&lt;/code&gt; is running then a time-out event is immediately delivered as when starting a &lt;code&gt;&lt;a href=&quot;#Time-Out%20Zero&quot;&gt;Time-Out Zero&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">このような &lt;code&gt;TimeoutType&lt;/code&gt; が実行されていないときにこの機能を使用すると、 &lt;code&gt;&lt;a href=&quot;#Time-Out%20Zero&quot;&gt;Time-Out Zero&lt;/a&gt;&lt;/code&gt; OutZeroを開始したときと同じようにタイムアウトイベントがすぐに配信されます。</target>
        </trans-unit>
        <trans-unit id="a7ae399292df5e1214de0f1c430950be7c775936" translate="yes" xml:space="preserve">
          <source>If this flag is present, &lt;code&gt;global&lt;/code&gt; does not maintain a fully connected network of distributed Erlang nodes, and then global name registration cannot be used; see &lt;code&gt;global(3)&lt;/code&gt;.</source>
          <target state="translated">このフラグが存在する場合、 &lt;code&gt;global&lt;/code&gt; は分散型Erlangノードの完全に接続されたネットワークを維持しないため、グローバル名の登録は使用できません。 &lt;code&gt;global(3)&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="f07b81995e2058716b31282ea839a19974f67348" translate="yes" xml:space="preserve">
          <source>If this flag is set, &lt;code&gt;{error, Errors, Warnings}&lt;/code&gt; is returned when there are errors. Default is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">このフラグが設定されている場合 &lt;code&gt;{error, Errors, Warnings}&lt;/code&gt; と{error、Errors、Warnings}が返されます。デフォルトは &lt;code&gt;false&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="5398762fceee6e07d9e93fb018e02eda7d682593" translate="yes" xml:space="preserve">
          <source>If this flag is set, &lt;code&gt;{error,ErrorList,WarningList}&lt;/code&gt; is returned when there are errors.</source>
          <target state="translated">このフラグが設定されている場合、 &lt;code&gt;{error,ErrorList,WarningList}&lt;/code&gt; と{error、ErrorList、WarningList}が返されます。</target>
        </trans-unit>
        <trans-unit id="6be13d0e071b42b8d41878615f2879c487393169" translate="yes" xml:space="preserve">
          <source>If this flag is set, an extra field containing &lt;code&gt;Warnings&lt;/code&gt; is added to the tuple returned upon success. Default is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">このフラグが設定されている場合、成功時に返されるタプルに &lt;code&gt;Warnings&lt;/code&gt; を含む追加のフィールドが追加されます。デフォルトは &lt;code&gt;false&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="3313bf48f0cdfa74884b1da2da53a7543532d3d4" translate="yes" xml:space="preserve">
          <source>If this flag is set, an extra field, containing &lt;code&gt;WarningList&lt;/code&gt;, is added to the tuples returned on success.</source>
          <target state="translated">このフラグが設定されている場合、成功時に返されるタプルに、 &lt;code&gt;WarningList&lt;/code&gt; を含む追加のフィールドが追加されます。</target>
        </trans-unit>
        <trans-unit id="a4261f0fa61ea721311b8153168daa7bcae82ceb" translate="yes" xml:space="preserve">
          <source>If this function gets invoked or not is controlled by the reply from the preceding call to handle_trans_request/3. The handle_trans_request/3 function may decide to process the action requests itself or to delegate the processing to this function.</source>
          <target state="translated">この関数が呼び出されるかどうかは、前のhandle_trans_request/3の呼び出しからの応答によって制御されます。handle_trans_request/3 関数は、アクションリクエストを自分自身で処理するか、 この関数に処理を委ねるかを決定することができます。</target>
        </trans-unit>
        <trans-unit id="759c6aff89e36cb13b1929cdb56543f2723e5912" translate="yes" xml:space="preserve">
          <source>If this function gets invoked or not, is controlled by the reply from the preceding call to handle_trans_request/3. The handle_trans_request/3 function may decide to return {handle_ack, ack_data()} or {handle_sloppy_ack, ack_data()} meaning that you need an immediate acknowledgement of the reply and that this function should be invoked to handle the acknowledgement.</source>
          <target state="translated">この関数が呼び出されるかどうかは、前の関数 handle_trans_request/3 の呼び出しからの応答によって制御されます。handle_trans_request/3 関数は {handle_ack,ack_data()}または {handle_sloppy_ack,ack_data()}を返すかどうかを決定するかもしれません。</target>
        </trans-unit>
        <trans-unit id="2db2202db664ddf13d01713aaa8bc9ba006f0ed4" translate="yes" xml:space="preserve">
          <source>If this function is called, it can only be called once and must be called before any other functions in the &lt;code&gt;ei&lt;/code&gt; library are called.</source>
          <target state="translated">この関数が呼び出された場合、この関数は1回しか &lt;code&gt;ei&lt;/code&gt; ず、eiライブラリ内の他の関数が呼び出される前に呼び出す必要があります。</target>
        </trans-unit>
        <trans-unit id="63459ad5b8a5024794d9f8294a76e897d53d7890" translate="yes" xml:space="preserve">
          <source>If this function is called, it may only be called once directly after the call to function &lt;code&gt;&lt;a href=&quot;#erl_init&quot;&gt;erl_init()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">この関数が呼び出された場合、関数 &lt;code&gt;&lt;a href=&quot;#erl_init&quot;&gt;erl_init()&lt;/a&gt;&lt;/code&gt; の呼び出しの直後に一度だけ呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="cdd06471c1b7c9a2e79736c5c3baade29102ed76" translate="yes" xml:space="preserve">
          <source>If this function is called, it will be called again, either with &lt;code&gt;undo&lt;/code&gt; or with &lt;code&gt;set&lt;/code&gt; as first argument.</source>
          <target state="translated">この関数が呼び出されると、 &lt;code&gt;undo&lt;/code&gt; または最初の引数として &lt;code&gt;set&lt;/code&gt; を使用して、再度呼び出されます。</target>
        </trans-unit>
        <trans-unit id="57d5ad72a18485e89bafa2b5eeeeaab800a1356c" translate="yes" xml:space="preserve">
          <source>If this function is not called, the start function returns an error tuple (if a link and/or a time-out is used) or hang otherwise.</source>
          <target state="translated">この関数が呼ばれなかった場合、開始関数はエラータプル(リンクやタイムアウトが使用されている場合)を返すか、そうでなければハングを返します。</target>
        </trans-unit>
        <trans-unit id="8c7cb778dcaeb301678f8381c719400450da4a70" translate="yes" xml:space="preserve">
          <source>If this function returns with a next state that does not match equal (&lt;code&gt;=/=&lt;/code&gt;) to the current state, all postponed events are retried in the next state.</source>
          <target state="translated">この関数が現在の状態と等しい（ &lt;code&gt;=/=&lt;/code&gt; ）と一致しない次の状態で戻る場合、延期されたすべてのイベントが次の状態で再試行されます。</target>
        </trans-unit>
        <trans-unit id="3a0ed99dde48840d29c014e939552bc11b14d1d1" translate="yes" xml:space="preserve">
          <source>If this function's body does not return an inline constant value the callback module is doing something strange.</source>
          <target state="translated">この関数のボディがインライン定数値を返さない場合は、コールバックモジュールが何か変なことをしている可能性があります。</target>
        </trans-unit>
        <trans-unit id="33d0e448805fb8a37d99a0aff84679f18601e686" translate="yes" xml:space="preserve">
          <source>If this is a &lt;strong&gt;state change&lt;/strong&gt;, the queue of incoming events is reset to start with the oldest postponed.</source>
          <target state="translated">これが&lt;strong&gt;状態の変化&lt;/strong&gt;である場合、着信イベントのキューは、最も古い延期で開始するようにリセットされます。</target>
        </trans-unit>
        <trans-unit id="82460753c54ada648d7c9b05b35bd78eae8d83fe" translate="yes" xml:space="preserve">
          <source>If this is a problem; to generate a boolean use something like this:</source>
          <target state="translated">これが問題であれば、ブーリアンを生成するには、以下のようなものを使用します。</target>
        </trans-unit>
        <trans-unit id="c64d2ab7023f50eed11754a4818012e0a3833abd" translate="yes" xml:space="preserve">
          <source>If this is a problem; to generate a boolean with these algorithms use something like this:</source>
          <target state="translated">問題がある場合は、これらのアルゴリズムでブール値を生成するには、以下のようなものを使用します。</target>
        </trans-unit>
        <trans-unit id="3ac87d883ad765b014bd68fa86e8b2ac8f132c75" translate="yes" xml:space="preserve">
          <source>If this macro is defined, it overrides the NOASSERT macro, forcing the assert macros to always be enabled regardless of other settings.</source>
          <target state="translated">このマクロが定義されている場合、NOASSERT マクロを上書きし、他の設定に関係なく常に assert マクロを有効にします。</target>
        </trans-unit>
        <trans-unit id="ef12b2a17adab036f91ae1c37a457dabe1673cb6" translate="yes" xml:space="preserve">
          <source>If this macro is defined, it overrides the NODEBUG macro, forcing the debugging macros to be enabled.</source>
          <target state="translated">このマクロが定義されている場合、NODEBUG マクロをオーバーライドし、デバッグマクロを強制的に有効にします。</target>
        </trans-unit>
        <trans-unit id="f89fd4ecae86929dc6deae32a5e245a30ab74c60" translate="yes" xml:space="preserve">
          <source>If this macro is defined, the assert macros will have no effect, when testing is also disabled. See &lt;code&gt;&lt;a href=&quot;#Assert_macros&quot;&gt;Assert macros&lt;/a&gt;&lt;/code&gt;. When testing is enabled, the assert macros are always enabled automatically and cannot be disabled.</source>
          <target state="translated">このマクロが定義されている場合、テストも無効になっていると、assertマクロは効果がありません。 &lt;code&gt;&lt;a href=&quot;#Assert_macros&quot;&gt;Assert macros&lt;/a&gt;&lt;/code&gt; 参照してください。テストを有効にすると、assertマクロは常に自動的に有効になり、無効にすることはできません。</target>
        </trans-unit>
        <trans-unit id="79358b57c58e42b823acfaf278614ec9c7ce54cc" translate="yes" xml:space="preserve">
          <source>If this macro is defined, the automatic exporting or stripping of test functions will be disabled.</source>
          <target state="translated">このマクロが定義されている場合、テスト関数の自動エクスポートまたはストリッピングは無効になります。</target>
        </trans-unit>
        <trans-unit id="6681ab5371316488374f8d3a60e956558c52d69e" translate="yes" xml:space="preserve">
          <source>If this macro is defined, the debugging macros will have no effect. See &lt;code&gt;&lt;a href=&quot;#Debugging_macros&quot;&gt;Debugging macros&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;NODEBUG&lt;/code&gt; also implies &lt;code&gt;NOASSERT&lt;/code&gt;, unless testing is enabled.</source>
          <target state="translated">このマクロが定義されている場合、デバッグマクロは無効になります。 &lt;code&gt;&lt;a href=&quot;#Debugging_macros&quot;&gt;Debugging macros&lt;/a&gt;&lt;/code&gt; 参照してください。 &lt;code&gt;NODEBUG&lt;/code&gt; はまた意味 &lt;code&gt;NOASSERT&lt;/code&gt; をテストが有効になっている場合を除き、。</target>
        </trans-unit>
        <trans-unit id="781581d91da20944d9d397cd0ddb27951b613d6e" translate="yes" xml:space="preserve">
          <source>If this option is present, the table data is stored in a more compact format to consume less memory. However, it will make table operations slower. Especially operations that need to inspect entire objects, such as &lt;code&gt;match&lt;/code&gt; and &lt;code&gt;select&lt;/code&gt;, get much slower. The key element is not compressed.</source>
          <target state="translated">このオプションが存在する場合、テーブルデータは、より少ないメモリを消費するために、よりコンパクトな形式で保存されます。ただし、テーブル操作が遅くなります。特に、 &lt;code&gt;match&lt;/code&gt; や &lt;code&gt;select&lt;/code&gt; など、オブジェクト全体を検査する必要がある操作は、非常に遅くなります。キー要素は圧縮されていません。</target>
        </trans-unit>
        <trans-unit id="39baea08169404ce3fe44fe53586745d1c2f63db" translate="yes" xml:space="preserve">
          <source>If this option is present, the table is registered under its &lt;code&gt;Name&lt;/code&gt; which can then be used instead of the table identifier in subsequent operations.</source>
          <target state="translated">このオプションが存在する場合、テーブルはその &lt;code&gt;Name&lt;/code&gt; で登録され、その後の操作でテーブル識別子の代わりに使用できます。</target>
        </trans-unit>
        <trans-unit id="ee4b6929098a40cbdbaf168a7fca6dd6bafa6ed5" translate="yes" xml:space="preserve">
          <source>If this option is set, most white space characters in the pattern are totally ignored except when escaped or inside a character class. However, white space is not allowed within sequences such as &lt;code&gt;(?&amp;gt;&lt;/code&gt; that introduce various parenthesized subpatterns, nor within a numerical quantifier such as &lt;code&gt;{1,3}&lt;/code&gt;. However, ignorable white space is permitted between an item and a following quantifier and between a quantifier and a following + that indicates possessiveness.</source>
          <target state="translated">このオプションが設定されている場合、パターン内のほとんどの空白文字は、エスケープされている場合または文字クラス内にある場合を除いて、完全に無視されます。ただし、かっこで囲んだサブパターンを導入する &lt;code&gt;(?&amp;gt;&lt;/code&gt; などのシーケンス内や、 &lt;code&gt;{1,3}&lt;/code&gt; などの数値数量詞内では空白を使用できません。ただし、アイテムと後続の数量詞の間、および量指定子とそれに続く+は所有性を示します。</target>
        </trans-unit>
        <trans-unit id="fdc99f2839fcd867c278ae874f9e2a13c5e1d784" translate="yes" xml:space="preserve">
          <source>If this option is written in the source code, as a &lt;code&gt;-compile&lt;/code&gt; directive, the syntax &lt;code&gt;F/A&lt;/code&gt; can be used instead of &lt;code&gt;{F,A}&lt;/code&gt;, for example:</source>
          <target state="translated">このオプションがソースコードで &lt;code&gt;-compile&lt;/code&gt; ディレクティブとして記述されている場合、構文 &lt;code&gt;F/A&lt;/code&gt; を &lt;code&gt;{F,A}&lt;/code&gt; 代わりに使用できます。次に例を示します。</target>
        </trans-unit>
        <trans-unit id="bd13526ac2fef0e27a961572d9dc8a9a077d1b66" translate="yes" xml:space="preserve">
          <source>If this parameter is not specified, it defaults to &lt;code&gt;/etc/hosts&lt;/code&gt; unless environment variable &lt;code&gt;ERL_INET_ETC_DIR&lt;/code&gt; is set, which defines the directory for this file to some maybe other than &lt;code&gt;/etc&lt;/code&gt;.</source>
          <target state="translated">このパラメーターが指定されて &lt;code&gt;/etc/hosts&lt;/code&gt; ない場合、このファイルのディレクトリーを &lt;code&gt;/etc&lt;/code&gt; 以外に定義する環境変数 &lt;code&gt;ERL_INET_ETC_DIR&lt;/code&gt; が設定されていない限り、デフォルトで/ etc / hostsになります。</target>
        </trans-unit>
        <trans-unit id="fe1c08841ffeb7fe23cca25114d889442e8c01cb" translate="yes" xml:space="preserve">
          <source>If this parameter is not specified, it defaults to &lt;code&gt;/etc/resolv.conf&lt;/code&gt; unless environment variable &lt;code&gt;ERL_INET_ETC_DIR&lt;/code&gt; is set, which defines the directory for this file to some maybe other than &lt;code&gt;/etc&lt;/code&gt;.</source>
          <target state="translated">このパラメーターが指定されていない場合、このファイルのディレクトリーを &lt;code&gt;/etc&lt;/code&gt; 以外に定義する環境変数 &lt;code&gt;ERL_INET_ETC_DIR&lt;/code&gt; が設定されていない限り、デフォルトで &lt;code&gt;/etc/resolv.conf&lt;/code&gt; になります。</target>
        </trans-unit>
        <trans-unit id="45ec4c57907492a2ec83d9fdbff265e2b0072af9" translate="yes" xml:space="preserve">
          <source>If this pattern is embedded in a larger one, a relative reference can be used:</source>
          <target state="translated">このパターンがより大きなものに埋め込まれている場合は、相対参照を使用することができます。</target>
        </trans-unit>
        <trans-unit id="e8050ea746b1df5e9d9c36102bf42da460ef8d08" translate="yes" xml:space="preserve">
          <source>If this property is defined, &lt;code&gt;Inets&lt;/code&gt; expects to find all other properties defined in this file, which uses Apache-like syntax. The file must include all properties listed under mandatory properties. The Apache-like syntax is the property, written as one word where each new word begins with a capital, followed by a white-space, followed by the value, followed by a new line.</source>
          <target state="translated">このプロパティが定義されている場合、 &lt;code&gt;Inets&lt;/code&gt; は、Apacheに似た構文を使用する、このファイルで定義されている他のすべてのプロパティを見つけることを期待しています。ファイルには、必須プロパティの下にリストされているすべてのプロパティを含める必要があります。Apacheに似た構文はプロパティであり、新しい単語がそれぞれ大文字で始まり、空白、値、改行の順に続く1つの単語として記述されます。</target>
        </trans-unit>
        <trans-unit id="09a2a375a69f2029267ac74ac850aabd642821a4" translate="yes" xml:space="preserve">
          <source>If this property is defined, &lt;code&gt;Inets&lt;/code&gt; expects to find all other properties defined in this file. The file must include all properties listed under mandatory properties.</source>
          <target state="translated">このプロパティが定義されている場合、 &lt;code&gt;Inets&lt;/code&gt; はこのファイルで定義されている他のすべてのプロパティを見つけることを期待しています。ファイルには、必須プロパティの下にリストされているすべてのプロパティを含める必要があります。</target>
        </trans-unit>
        <trans-unit id="fd3402a2f2f441f42f83cdd07b86e7ab04f0ace1" translate="yes" xml:space="preserve">
          <source>If this situation is not acceptable, this function can be used to override the strategy of the Mnesia table load algorithm. This can lead to a situation where some transaction effects are lost with an inconsistent database as result, but for some applications high availability is more important than consistent data.</source>
          <target state="translated">この状況が受け入れられない場合、この関数を使用してMnesiaテーブルロードアルゴリズムの戦略を上書きすることができます。これは、結果として一貫性のないデータベースでいくつかのトランザクション効果が失われる状況をもたらす可能性がありますが、一部のアプリケーションでは一貫性のあるデータよりも高可用性の方が重要です。</target>
        </trans-unit>
        <trans-unit id="059c4f891420c8ec95d1abb34b55edc8941662f6" translate="yes" xml:space="preserve">
          <source>If this value is false, then when loading a mib each mib- entry is checked prior to installation of the mib. The purpose of the check is to prevent that the same symbolic mibentry name is used for different oid's.</source>
          <target state="translated">この値が false の場合、mib をロードする際に、mib のインストール前に各 mib-エントリがチェックされます。このチェックの目的は、同じシンボリックな mibentry 名が異なる oid に使われることを防ぐことです。</target>
        </trans-unit>
        <trans-unit id="d5be0ef33ffc0742762d89cfb5dcdc57978e4cec" translate="yes" xml:space="preserve">
          <source>If this value is false, then when loading a mib each trap is checked prior to installation of the mib. The purpose of the check is to prevent that the same symbolic trap name is used for different trap's.</source>
          <target state="translated">この値が false の場合、mib をロードする際に、mib のインストール前に各トラップがチェックされます。このチェックの目的は、同じシンボリックトラップ名が異なるトラップに使用されることを防ぐためです。</target>
        </trans-unit>
        <trans-unit id="d93bdc2ebb6849c84f900f395d346a1101af31f5" translate="yes" xml:space="preserve">
          <source>If this was part of a larger pattern, you would not want to recurse the entire pattern, so instead you can use:</source>
          <target state="translated">これがより大きなパターンの一部であった場合は、パターン全体を再解析したくないので、代わりに使用することができます。</target>
        </trans-unit>
        <trans-unit id="739efd088e9bee0d304554cfa5fdd5c4e61ba305" translate="yes" xml:space="preserve">
          <source>If time correction is disabled, Erlang monotonic time can warp forwards or stop, or even freeze for extended periods of time. There are then no guarantees that the frequency of the Erlang monotonic clock is accurate or stable.</source>
          <target state="translated">時刻補正が無効になっている場合、Erlangのモノトニックタイムは前にワープしたり停止したり、長時間フリーズしたりすることがあります。この場合、Erlangのモノトニッククロックの周波数が正確で安定しているという保証はありません。</target>
        </trans-unit>
        <trans-unit id="ffd673f8288d651f4732e547bc38b22a211807fc" translate="yes" xml:space="preserve">
          <source>If time correction is disabled, Erlang monotonic time leaps forward if OS system time leaps forward. If OS system time leaps backwards, Erlang monotonic time stops briefly, but it does not freeze for extended periods of time. This as the time offset is changed to align Erlang system time with OS system time.</source>
          <target state="translated">時刻補正が無効になっている場合、OSシステムの時間が前に進むとErlangのモノトニックタイムが前に進みます。OSシステムの時間が後退すると、Erlangのモノトニックタイムは一時的に止まりますが、長時間フリーズすることはありません。これは時間オフセットが変更され、Erlangシステムの時間をOSシステムの時間に合わせるようになったためです。</target>
        </trans-unit>
        <trans-unit id="e95c3e3e415f307880ab62a824dbb61d407166b0" translate="yes" xml:space="preserve">
          <source>If time correction is disabled, changes in OS system time affects the monotonic clock the same way as when the &lt;code&gt;&lt;a href=&quot;#No_Time_Warp_Mode&quot;&gt;no time warp mode&lt;/a&gt;&lt;/code&gt; is used.</source>
          <target state="translated">時間修正が無効になっている場合、OSシステム時間の変更は &lt;code&gt;&lt;a href=&quot;#No_Time_Warp_Mode&quot;&gt;no time warp mode&lt;/a&gt;&lt;/code&gt; が使用されている場合と同じように単調クロックに影響します。</target>
        </trans-unit>
        <trans-unit id="d01b0a13b53f09d09cc8091e67871a996e4027e2" translate="yes" xml:space="preserve">
          <source>If time correction is enabled, adjustments to the Erlang monotonic clock are made to keep its frequency as correct as possible. However, &lt;strong&gt;no&lt;/strong&gt; adjustments are made trying to align Erlang system time and OS system time. That is, during the preliminary phase Erlang system time and OS system time can diverge from each other, and no attempt is made to prevent this.</source>
          <target state="translated">時刻修正が有効になっている場合、Erlang単調クロックの調整は、その周波数を可能な限り正確に保つために行われます。ただし、Erlangのシステム時刻とOSのシステム時刻を合わせるための調整は行われ&lt;strong&gt;ません&lt;/strong&gt;。つまり、準備段階では、Erlangのシステム時刻とOSのシステム時刻が互いに異なる可能性があり、これを防止する試みは行われていません。</target>
        </trans-unit>
        <trans-unit id="d5d7906513f874fdde48593a22b63bd033c683a3" translate="yes" xml:space="preserve">
          <source>If time correction is enabled, the Erlang runtime system makes use of both &lt;code&gt;&lt;a href=&quot;#OS_System_Time&quot;&gt;OS system time&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#OS_Monotonic_Time&quot;&gt;OS monotonic time&lt;/a&gt;&lt;/code&gt;, to adjust the frequency of the Erlang monotonic clock. Time correction ensures that &lt;code&gt;&lt;a href=&quot;#Erlang_Monotonic_Time&quot;&gt;Erlang monotonic time&lt;/a&gt;&lt;/code&gt; does not warp and that the frequency is relatively accurate. The type of frequency adjustments depends on the time warp mode used. Section &lt;code&gt;&lt;a href=&quot;#Time_Warp_Modes&quot;&gt;Time Warp Modes&lt;/a&gt;&lt;/code&gt; provides more details.</source>
          <target state="translated">時間修正が有効になっている場合、Erlangランタイムシステムは &lt;code&gt;&lt;a href=&quot;#OS_System_Time&quot;&gt;OS system time&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;#OS_Monotonic_Time&quot;&gt;OS monotonic time&lt;/a&gt;&lt;/code&gt; の両方を使用して、Erlang単調クロックの周波数を調整します。時間補正により、 &lt;code&gt;&lt;a href=&quot;#Erlang_Monotonic_Time&quot;&gt;Erlang monotonic time&lt;/a&gt;&lt;/code&gt; 、周波数が比較的正確になります。周波数調整のタイプは、使用するタイムワープモードによって異なります。詳細については、セクション &lt;code&gt;&lt;a href=&quot;#Time_Warp_Modes&quot;&gt;Time Warp Modes&lt;/a&gt;&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="86c57207a0af2011d419b53ca97897d73a612495" translate="yes" xml:space="preserve">
          <source>If time correction is not enabled, Erlang monotonic time freezes when OS system time leaps backwards. The freeze of monotonic time continues until OS system time catches up. The freeze can continue for a long time. When OS system time leaps forwards, Erlang monotonic time also leaps forward.</source>
          <target state="translated">時刻補正が有効になっていない場合、OSシステムの時間が逆に跳ね上がるとErlangのモノトニックタイムがフリーズします。モノトニックタイムのフリーズはOSシステムの時間が追いつくまで続きます。フリーズは長い間続く可能性があります。OSシステムの時間が前方に跳ね上がると、Erlangのモノトニックタイムも前方に跳ね上がります。</target>
        </trans-unit>
        <trans-unit id="ef091f899ba472aeda63ed1965cfed9d0bedc0a4" translate="yes" xml:space="preserve">
          <source>If trace mode is turned on this tells the ODBC driver to write a trace log to the file SQL.LOG that is placed in the current directory of the erlang emulator. This information may be useful if you suspect there might be a bug in the erlang ODBC application, and it might be relevant for you to send this file to our support. Otherwise you will probably not have much use of this.</source>
          <target state="translated">トレースモードがオンになっている場合、ODBCドライバにトレースログをSQL.LOGというファイルに書き込むように指示し、それをerlangエミュレータのカレントディレクトリに置きます。この情報はerlang ODBCアプリケーションにバグがあるかもしれないと思ったときに役立つかもしれません。そうでなければ、これを使うことはあまりないでしょう。</target>
        </trans-unit>
        <trans-unit id="06cb7989133609c0050ffc5dbb44bd39095de5a4" translate="yes" xml:space="preserve">
          <source>If tracing could be enabled for &lt;code&gt;P&lt;/code&gt; and all processes in &lt;code&gt;Rootset&lt;/code&gt;, the function returns &lt;code&gt;{ok,Value}&lt;/code&gt; when &lt;code&gt;Fun()&lt;/code&gt;/&lt;code&gt;apply&lt;/code&gt; returns with the value &lt;code&gt;Value&lt;/code&gt;, or &lt;code&gt;{error,Reason}&lt;/code&gt; if &lt;code&gt;Fun()&lt;/code&gt;/&lt;code&gt;apply&lt;/code&gt; fails with exit reason &lt;code&gt;Reason&lt;/code&gt;. Otherwise it returns &lt;code&gt;{error, Reason}&lt;/code&gt; immediately.</source>
          <target state="translated">&lt;code&gt;P&lt;/code&gt; および &lt;code&gt;Rootset&lt;/code&gt; のすべてのプロセスでトレースを有効にできる場合、関数は &lt;code&gt;Fun()&lt;/code&gt; / &lt;code&gt;apply&lt;/code&gt; が値 &lt;code&gt;Value&lt;/code&gt; で戻るときに &lt;code&gt;{ok,Value}&lt;/code&gt; 返し、 &lt;code&gt;Fun()&lt;/code&gt; / &lt;code&gt;apply&lt;/code&gt; が終了理由 &lt;code&gt;Reason&lt;/code&gt; で失敗した場合は &lt;code&gt;{error,Reason}&lt;/code&gt; 返します。。それ以外の場合は &lt;code&gt;{error, Reason}&lt;/code&gt; すぐに{error、Reason}を返します。</target>
        </trans-unit>
        <trans-unit id="171abc361e25e3e1820951c40db50f386bc4e18d" translate="yes" xml:space="preserve">
          <source>If true, use the server's preference for ECC curve selection. If false (the default), use the client's preference.</source>
          <target state="translated">true の場合、ECC カーブの選択にはサーバーの環境設定を使用します。false (デフォルト)の場合は、クライアントの環境設定を使用します。</target>
        </trans-unit>
        <trans-unit id="f6448c429179ffe9a0559b10e022f36f7d57c48b" translate="yes" xml:space="preserve">
          <source>If true, use the server's preference for cipher selection. If false (the default), use the client's preference.</source>
          <target state="translated">true の場合、暗号の選択にサーバの設定を使用します。false (デフォルト)の場合は、クライアントの設定を使用します。</target>
        </trans-unit>
        <trans-unit id="93560debed8026dcf2a2983b09444126fc93994e" translate="yes" xml:space="preserve">
          <source>If two &lt;code&gt;Dates&lt;/code&gt; are specified, reports that occurred between those dates are returned.</source>
          <target state="translated">2つの &lt;code&gt;Dates&lt;/code&gt; が指定されている場合、それらの日付の間に発生したレポートが返されます。</target>
        </trans-unit>
        <trans-unit id="33b891be28a40228827989eecbc682bd1e8b9bf9" translate="yes" xml:space="preserve">
          <source>If two matching keys are declared, the latter key takes precedence.</source>
          <target state="translated">2つの一致するキーが宣言されている場合、後者のキーが優先されます。</target>
        </trans-unit>
        <trans-unit id="67258d8af06879035a6caf89796f47f253a79805" translate="yes" xml:space="preserve">
          <source>If two processes open the same table by giving the same name and arguments, the table has two users. If one user closes the table, it remains open until the second user closes it.</source>
          <target state="translated">2つのプロセスが同じ名前と引数を与えて同じテーブルを開く場合、そのテーブルには2人のユーザがいます。1人のユーザがテーブルを閉じると、2人目のユーザが閉じるまでテーブルは開いたままになります。</target>
        </trans-unit>
        <trans-unit id="2c7260077a6430e57fb912e3299409f44a7a3f23" translate="yes" xml:space="preserve">
          <source>If two processes perform &lt;code&gt;mnesia:dirty_update_counter/3&lt;/code&gt; simultaneously, both updates take effect without the risk of losing one of the updates. The new value &lt;code&gt;NewVal&lt;/code&gt; of the counter is returned.</source>
          <target state="translated">2つのプロセスが &lt;code&gt;mnesia:dirty_update_counter/3&lt;/code&gt; を同時に実行する場合、両方の更新が有効になり、一方の更新が失われるリスクはありません。カウンターの新しい値 &lt;code&gt;NewVal&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="b5c7e523459e9f766dca300b6ab1c5e2e9c17d90" translate="yes" xml:space="preserve">
          <source>If used on the top level in a guard, it tests whether the argument is a floating point number; for clarity, use &lt;code&gt;&lt;a href=&quot;#is_float-1&quot;&gt;is_float/1&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">ガードの最上位で使用する場合、引数が浮動小数点数かどうかをテストします。明確にするために、代わりに &lt;code&gt;&lt;a href=&quot;#is_float-1&quot;&gt;is_float/1&lt;/a&gt;&lt;/code&gt; を使用してください。</target>
        </trans-unit>
        <trans-unit id="c1158bf11097606b6592798bf3682a97d2961056" translate="yes" xml:space="preserve">
          <source>If verification is turned on and the file was written with option &lt;code&gt;{extended_info, [md5sum]}&lt;/code&gt;, reading the file is slower and consumes radically more CPU time than otherwise.</source>
          <target state="translated">検証がオンになっていて、ファイルがオプション &lt;code&gt;{extended_info, [md5sum]}&lt;/code&gt; で書き込まれた場合、ファイルの読み取りは遅くなり、それ以外の場合よりも大幅に多くのCPU時間を消費します。</target>
        </trans-unit>
        <trans-unit id="79df61d77a356cef20daff35817557c31ea1feae" translate="yes" xml:space="preserve">
          <source>If warnings are turned on (option &lt;code&gt;report_warnings&lt;/code&gt; described earlier), the following options control what type of warnings that are generated.  Except from &lt;code id=&quot;erl_lint_options&quot;&gt;{warn_format,Verbosity}&lt;/code&gt;, the following options have two forms:</source>
          <target state="translated">警告がオンになっている場合（前述のオプション &lt;code&gt;report_warnings&lt;/code&gt; ）、次のオプションは、生成される警告のタイプを制御します。 &lt;code id=&quot;erl_lint_options&quot;&gt;{warn_format,Verbosity}&lt;/code&gt; 除いて、次のオプションには2つの形式があります。</target>
        </trans-unit>
        <trans-unit id="46f6514af342c03660ff3a127d8c0abce6e94d29" translate="yes" xml:space="preserve">
          <source>If we are connected (and if the connection handle is not &lt;code&gt;NULL&lt;/code&gt;), we log out from the database. We need to check if we should encode an &lt;code&gt;'ok'&lt;/code&gt;, as we can get here from function &lt;code&gt;stop&lt;/code&gt;, which does not return data to the emulator:</source>
          <target state="translated">接続されている場合（および接続ハンドルが &lt;code&gt;NULL&lt;/code&gt; でない場合）、データベースからログアウトします。 &lt;code&gt;'ok'&lt;/code&gt; エンコードする必要があるかどうかを確認する必要があります。これは、データをエミュレータに返さないfunction &lt;code&gt;stop&lt;/code&gt; から取得できるためです。</target>
        </trans-unit>
        <trans-unit id="3e3531248524d3e767663c5b51a2a6884e4678a8" translate="yes" xml:space="preserve">
          <source>If we are not at security-level &lt;code&gt;noAuthNoPriv&lt;/code&gt;, this could be complicated, since the agent will then continue with stage 2, before which the usm-related updates must be done.</source>
          <target state="translated">セキュリティレベルが &lt;code&gt;noAuthNoPriv&lt;/code&gt; でない場合、エージェントはステージ2に進み、その前にusm関連の更新を行う必要があるため、これは複雑になる可能性があります。</target>
        </trans-unit>
        <trans-unit id="5d4840bdbaaa7e01cbfc9ee43e1a031173374de2" translate="yes" xml:space="preserve">
          <source>If we are not connecting, we wait for results from a &lt;code&gt;PQsendQuery&lt;/code&gt;, so we get the result and return it. The encoding is done with the same functions as in the earlier example.</source>
          <target state="translated">接続していない場合は、 &lt;code&gt;PQsendQuery&lt;/code&gt; からの結果を待ち、結果を取得して返します。エンコードは、前の例と同じ関数で行われます。</target>
        </trans-unit>
        <trans-unit id="337a2fc4e3a2d30ff212f197ed2e62e6a68516c6" translate="yes" xml:space="preserve">
          <source>If we are sure that this kind of situation cannot ensue, we may specify the involved modules as &quot;safe&quot;, and all calls between them will become local. Note that if the target module itself is specified as safe, &quot;remote&quot; calls to itself will be turned into local calls. This would destroy the code replacement properties of e.g. a typical server loop.</source>
          <target state="translated">このような状況が起こりえないと確信している場合には、関係するモジュールを &quot;safe &quot;と指定して、その間のすべての呼び出しをローカルにすることができます。ターゲットモジュール自体が安全と指定されている場合、それ自身への「リモート」コールはローカルコールに変わることに注意してください。これは、例えば典型的なサーバループのようなコード置換の特性を破壊することになります。</target>
        </trans-unit>
        <trans-unit id="7b66416ada226ef11ca8c9b5f2f89c92815edf3c" translate="yes" xml:space="preserve">
          <source>If we disregard the contended cases, we will inevitably get a higher latency when scheduling signals for execution at a later time than by executing the signal immediately. In order to preserve the low latency we now first check if this is a contended case or not. If it is, we schedule the signal for later execution; otherwise, we execute the signal immediately. It is a contended case if other signals already are scheduled on the port, or if we fail to acquire the port lock. That is we will not block waiting for the lock.</source>
          <target state="translated">競合するケースを無視すると、シグナルの実行をスケジューリングする際に、シグナルをすぐに実行するよりも後のタイミングで実行する方が必然的に高いレイテンシを得ることになります。低レイテンシを維持するために、まず、これが競合ケースであるかどうかをチェックします。もしそうであれば、後で実行するようにスケジューリングし、そうでなければすぐに実行します。他のシグナルが既にポート上でスケジュールされている場合や、ポートロックの取得に失敗した場合は競合状態となります。つまり、ロックを待っている間はブロックしません。</target>
        </trans-unit>
        <trans-unit id="d97b9f19e72ab9cc61b4cedbac5bd537174daa35" translate="yes" xml:space="preserve">
          <source>If we disregard the locking issues, the original solution is very appealing. The mapping from process identifier to index into the array is very fast, and this property is something we would like to keep. The vast majority of operations on these tables are lookups so optimizing for lookups is what we want to do.</source>
          <target state="translated">ロックの問題を無視すれば、オリジナルの解決策は非常に魅力的です。プロセス識別子から配列へのインデックスへのマッピングは非常に高速で、このプロパティは残しておきたいものです。これらのテーブルに対する操作の大部分はルックアップなので、ルックアップのために最適化することが私たちのやりたいことです。</target>
        </trans-unit>
        <trans-unit id="ea9c359ef122e371e6ca40c1302512863ec587e1" translate="yes" xml:space="preserve">
          <source>If we have a result from a connect, indicated by having data in the &lt;code&gt;x&lt;/code&gt; buffer, we no longer need to select on output (&lt;code&gt;ready_output&lt;/code&gt;), so we remove this by calling &lt;code&gt;driver_select&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; バッファーにデータがあることで示される接続の結果がある場合は、出力（ &lt;code&gt;ready_output&lt;/code&gt; ）で選択する必要がないため、 &lt;code&gt;driver_select&lt;/code&gt; を呼び出してこれを削除します。</target>
        </trans-unit>
        <trans-unit id="b39cddb5344c13a7bcee4c7a5972425c4aa9fc95" translate="yes" xml:space="preserve">
          <source>If we have forgotten the &lt;code&gt;$REFRESH_GEN_DEST()&lt;/code&gt; there would be a message similar to this:</source>
          <target state="translated">&lt;code&gt;$REFRESH_GEN_DEST()&lt;/code&gt; を忘れた場合は、次のようなメッセージが表示されます。</target>
        </trans-unit>
        <trans-unit id="dce67181f9dec94f63a49d2d4f68889369954004" translate="yes" xml:space="preserve">
          <source>If we now add the filter to the running &lt;code&gt;Collector&lt;/code&gt;:</source>
          <target state="translated">実行中の &lt;code&gt;Collector&lt;/code&gt; フィルターを追加すると、次のようになります。</target>
        </trans-unit>
        <trans-unit id="f3ffad68dd3aaa3ee27c0008bb99580f0a57f8f2" translate="yes" xml:space="preserve">
          <source>If we now send a message from the shell on the node &lt;code&gt;ant@stack&lt;/code&gt;, where all sends from the shell are traced:</source>
          <target state="translated">ノード &lt;code&gt;ant@stack&lt;/code&gt; シェルからメッセージを送信すると、シェルからのすべての送信がトレースされます。</target>
        </trans-unit>
        <trans-unit id="43717b37beb4229f520c407e6567fb6706951645" translate="yes" xml:space="preserve">
          <source>If we only want debug messages from a specific process it is possible to do this with a filter like this:</source>
          <target state="translated">特定のプロセスからのデバッグメッセージのみを取得したい場合は、以下のようなフィルタを使用することができます。</target>
        </trans-unit>
        <trans-unit id="6bcc29b0b458c2d8c07af3ed4af13280313ed829" translate="yes" xml:space="preserve">
          <source>If we only want to match operands of a certain type, we can use a type constraint. A type constraint consists of one or more lowercase letters, each specifying a type. For example:</source>
          <target state="translated">このような場合には、「型制約」を使用することができます。型制約は、1つ以上の小文字で構成され、それぞれが型を指定します。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="fd0ecc6f7afe07e419db3c1ee4dc39311f3c9091" translate="yes" xml:space="preserve">
          <source>If we remove the &lt;code&gt;-no_next&lt;/code&gt; directive, the code would look like this:</source>
          <target state="translated">&lt;code&gt;-no_next&lt;/code&gt; ディレクティブを削除すると、コードは次のようになります。</target>
        </trans-unit>
        <trans-unit id="71461022e8b1964785f01d0fea411534999fdbfe" translate="yes" xml:space="preserve">
          <source>If we run it like this: &lt;code&gt;motorcycles2html:process_to_file('result_xs.html', 'motorcycles2.xml').&lt;/code&gt; The result will be &lt;code&gt;result_xs.html&lt;/code&gt;. When the input file is of the same structure as the previous &quot;motorcycles&quot; XML files but it has a little more 'bike' elements and the 'manufacturer' elements are not in order.</source>
          <target state="translated">このように実行すると、 &lt;code&gt;motorcycles2html:process_to_file('result_xs.html', 'motorcycles2.xml').&lt;/code&gt; 結果は &lt;code&gt;result_xs.html&lt;/code&gt; になります。入力ファイルが以前の「モーターサイクル」XMLファイルと同じ構造であるが、「bike」要素がもう少しあり、「manufacturer」要素が順番になっていない場合。</target>
        </trans-unit>
        <trans-unit id="245971475847fb8e843dded9b9424bc7fe234a7a" translate="yes" xml:space="preserve">
          <source>If we would have had a huge amount of unique identifiers available, it would have tempting to drop or modify this ordering property as described above. The ordering property could for example be based on the scheduler performing the spawn operation. It would have been possible to reserve large ranges of identifiers exclusive for each scheduler thread which could be used minimizing the need for communication when allocating identifiers. The amount of identifiers we got to work with today is, however, not even close to be enough for such an approach.</source>
          <target state="translated">膨大な量のユニークな識別子が利用できるようになっていたら、上で説明したように、この順序付けプロパティを削除したり、変更したりしたくなったでしょう。この順序付けプロパティは、例えば、スポーン操作を行うスケジューラに基づいて設定することができます。そうすれば、各スケジューラのスレッド専用の大きな範囲の識別子を予約することができ、 識別子を割り当てる際の通信の必要性を最小限に抑えることができます。しかし、現在のところ、このような方法では十分な量の識別子を確保することはできません。</target>
        </trans-unit>
        <trans-unit id="8b8886cb75b357ed32d80a6eee9f949abb29be57" translate="yes" xml:space="preserve">
          <source>If x &lt;code&gt;F&lt;/code&gt; y and y &lt;code&gt;F&lt;/code&gt; x, then x = y (&lt;code&gt;F&lt;/code&gt; is antisymmetric).</source>
          <target state="translated">x &lt;code&gt;F&lt;/code&gt; yおよびy &lt;code&gt;F&lt;/code&gt; xの場合、x = y（ &lt;code&gt;F&lt;/code&gt; は非対称）です。</target>
        </trans-unit>
        <trans-unit id="6b92816031334184272820ee86857aab64402f87" translate="yes" xml:space="preserve">
          <source>If x &lt;code&gt;F&lt;/code&gt; y and y &lt;code&gt;F&lt;/code&gt; z, then x &lt;code&gt;F&lt;/code&gt; z (&lt;code&gt;F&lt;/code&gt; is transitive).</source>
          <target state="translated">x &lt;code&gt;F&lt;/code&gt; yおよびy &lt;code&gt;F&lt;/code&gt; zの場合、x &lt;code&gt;F&lt;/code&gt; z（ &lt;code&gt;F&lt;/code&gt; は推移的）。</target>
        </trans-unit>
        <trans-unit id="efd0edc2f934fb0989fdc0ef3a93bc0dc5861448" translate="yes" xml:space="preserve">
          <source>If x is a family from I to X, then x[i] denotes the value of the function at index i. The notation &quot;a family in X&quot; is used for such a family.</source>
          <target state="translated">x が I から X までのファミリーである場合、x[i]はインデックス i における関数の値を表します。</target>
        </trans-unit>
        <trans-unit id="0460fccf75563cd103af603f5ff0df7bee5d29db" translate="yes" xml:space="preserve">
          <source>If x is a family of subsets of X, the union of the range of x is called the &lt;strong&gt;union of the family&lt;/strong&gt; x.</source>
          <target state="translated">xはXの部分集合の族である場合は、xの範囲の労働組合は、呼び出された&lt;strong&gt;家族の労働組合&lt;/strong&gt;のx。</target>
        </trans-unit>
        <trans-unit id="7f8b7662a485e830efd5dc24b42b4f66a23c755f" translate="yes" xml:space="preserve">
          <source>If x is non-empty (the index set is non-empty), the &lt;strong&gt;intersection of the family&lt;/strong&gt; x is the intersection of the range of x.</source>
          <target state="translated">xが空でない（インデックスセットが空でない）場合&lt;strong&gt;、ファミリー&lt;/strong&gt; xの共通部分はxの範囲の共通部分です。</target>
        </trans-unit>
        <trans-unit id="a742ef9245b7658b6ec0801964c4c0ea9a5eb508" translate="yes" xml:space="preserve">
          <source>If you &lt;strong&gt;must&lt;/strong&gt; return all data stored in the Ets table, you can use &lt;code&gt;ets:tab2list/1&lt;/code&gt;. However, usually you are only interested in a subset of the information in which case &lt;code&gt;ets:tab2list/1&lt;/code&gt; is expensive. If you only want to extract one field from each record, for example, the age of every person, then:</source>
          <target state="translated">Etsテーブルに保存されているすべてのデータを返す&lt;strong&gt;必要がある&lt;/strong&gt;場合は、 &lt;code&gt;ets:tab2list/1&lt;/code&gt; を使用できます。ただし、通常、関心があるのは情報のサブセットのみです。この場合、 &lt;code&gt;ets:tab2list/1&lt;/code&gt; は高価です。たとえば、各人の年齢など、各レコードから1つのフィールドのみを抽出する場合は、次のようにします。</target>
        </trans-unit>
        <trans-unit id="6695ce447118dd0e7ea4d4f74aa540c19c250112" translate="yes" xml:space="preserve">
          <source>If you are building Erlang/OTP from git you will need to run &lt;code&gt;./otp_build autoconf&lt;/code&gt; to generate the configure scripts.</source>
          <target state="translated">gitからErlang / OTPをビルドしている場合は、。/ &lt;code&gt;./otp_build autoconf&lt;/code&gt; を実行して設定スクリプトを生成する必要があります。</target>
        </trans-unit>
        <trans-unit id="da52602929c7fc0635b8326b6c38bbbd66979f5f" translate="yes" xml:space="preserve">
          <source>If you are building a 64 bit version of Erlang, you should set up PATHs etc a little differently. We have two templates to make things work in both Cygwin and MSYS but needs editing to work with MSYS2 (see the comments in the script). The following one is for 32 bits:</source>
          <target state="translated">もしあなたが64ビット版のErlangを作っているなら、PATHなどの設定が少し違うはずです。CygwinとMSYSの両方で動作させるためのテンプレートが2つありますが、MSYS2で動作させるためには編集が必要です(スクリプトのコメントを参照してください)。次のものは32ビット用です。</target>
        </trans-unit>
        <trans-unit id="28fd7cee740e8f1e008d545c9af326623f6f2da9" translate="yes" xml:space="preserve">
          <source>If you are building a 64 bit version, you supply &lt;code&gt;otp_build&lt;/code&gt; with an architecture parameter:</source>
          <target state="translated">64ビットバージョンをビルドする場合は、アーキテクチャパラメータを &lt;code&gt;otp_build&lt;/code&gt; に指定します。</target>
        </trans-unit>
        <trans-unit id="11d01d76312a6e1beca90d30f576e8ba920e3045" translate="yes" xml:space="preserve">
          <source>If you are building in &lt;code&gt;git&lt;/code&gt; you first need to generate the &lt;code&gt;configure&lt;/code&gt; scripts:</source>
          <target state="translated">&lt;code&gt;git&lt;/code&gt; でビルドする場合は、最初に &lt;code&gt;configure&lt;/code&gt; スクリプトを生成する必要があります。</target>
        </trans-unit>
        <trans-unit id="08ca29e8fc627bd8865e44b098a309f0c218de8e" translate="yes" xml:space="preserve">
          <source>If you are building in Git, you want to read the &lt;code&gt;&lt;a href=&quot;install#How-to-Build-and-Install-ErlangOTP&quot;&gt;Building in Git&lt;/a&gt;&lt;/code&gt; section of &lt;code&gt;&lt;a href=&quot;install&quot;&gt;$ERL_TOP/HOWTO/INSTALL.md&lt;/a&gt;&lt;/code&gt; before proceeding.</source>
          <target state="translated">Gitでビルドしている場合は、先に進む前に &lt;code&gt;&lt;a href=&quot;install&quot;&gt;$ERL_TOP/HOWTO/INSTALL.md&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;install#How-to-Build-and-Install-ErlangOTP&quot;&gt;Building in Git&lt;/a&gt;&lt;/code&gt; 」セクションをお読みください。</target>
        </trans-unit>
        <trans-unit id="059356cb46cb61018f3078a8c089ba933432567b" translate="yes" xml:space="preserve">
          <source>If you are distributing the source code for your application for other people to compile and run, you probably want to ensure that the code compiles even if EUnit is not available. Like the example in the previous section, you can put the following lines in a common header file:</source>
          <target state="translated">自分のアプリケーションのソースコードを他の人がコンパイルして実行できるように配布している場合、EUnit が利用できなくてもコードがコンパイルできるようにしたいと思うでしょう。前節の例のように、共通のヘッダファイルに以下の行を入れます。</target>
        </trans-unit>
        <trans-unit id="3f548e035d4acfc541b42547c9972c54765ffd2c" translate="yes" xml:space="preserve">
          <source>If you are executing in a mode where time offset can change, and you want to get the actual Erlang system time when the event occurred, you can save the time offset as a third element in the tuple (the least significant element when comparing three-tuples).</source>
          <target state="translated">時間オフセットが変化するモードで実行していて、イベントが発生したときの実際のErlangシステムの時刻を取得したい場合、時間オフセットをタプルの3番目の要素(3つのタプルを比較するときに最も重要でない要素)として保存することができます。</target>
        </trans-unit>
        <trans-unit id="65eab1decf1d5f02b76e57b9a0f013425229d73c" translate="yes" xml:space="preserve">
          <source>If you are going to build a 64bit Windows version, you should make sure to get MinGW's 64bit gcc installed with Cygwin. It's in one of the development packages.</source>
          <target state="translated">64bit Windows版をビルドする場合は、CygwinでMinGWの64bit gccをインストールするようにしましょう。開発パッケージの一つに入っています。</target>
        </trans-unit>
        <trans-unit id="e873962d506d0453e258cd67b870cfcf9fdf56aa" translate="yes" xml:space="preserve">
          <source>If you are interested in Erlang system time at the time when the event occurred, you can also save the time offset before or after saving the events using &lt;code&gt;&lt;a href=&quot;erlang#time_offset-0&quot;&gt; erlang:time_offset/0&lt;/a&gt;&lt;/code&gt;. Erlang monotonic time added with the time offset corresponds to Erlang system time.</source>
          <target state="translated">イベントが発生したときのErlangシステム時刻に関心がある場合は、 &lt;code&gt;&lt;a href=&quot;erlang#time_offset-0&quot;&gt; erlang:time_offset/0&lt;/a&gt;&lt;/code&gt; を使用して、イベントを保存する前後の時間オフセットを保存することもできます。時間オフセットを追加したErlang単調時間は、Erlangシステム時間に対応します。</target>
        </trans-unit>
        <trans-unit id="abcce25aa490a7895d515f9ea238920455b90682" translate="yes" xml:space="preserve">
          <source>If you are interested in Erlang system time at the time when the event occurred, you can also save the time offset before or after saving the events using &lt;code&gt;&lt;a href=&quot;erlang#time_offset-0&quot;&gt;erlang:time_offset/0&lt;/a&gt;&lt;/code&gt;. Erlang monotonic time added with the time offset corresponds to Erlang system time.</source>
          <target state="translated">イベントが発生したときのErlangシステム時刻に関心がある場合は、 &lt;code&gt;&lt;a href=&quot;erlang#time_offset-0&quot;&gt;erlang:time_offset/0&lt;/a&gt;&lt;/code&gt; を使用して、イベントを保存する前または後に時間オフセットを保存することもできます。時間オフセットが追加されたアーラン単調時間は、アーランシステム時間に対応します。</target>
        </trans-unit>
        <trans-unit id="2501e29b8883667aa63c6065f64ad533173ff055" translate="yes" xml:space="preserve">
          <source>If you are new to &lt;code&gt;gen_statem&lt;/code&gt; and want an overview of concepts and operation the section &lt;code&gt; gen_statem&amp;nbsp;Behaviour &lt;/code&gt; located in the User's Guide &lt;code&gt; OTP Design Principles &lt;/code&gt; is recommended to read before this reference manual, possibly after the Description section you are reading here.</source>
          <target state="translated">&lt;code&gt;gen_statem&lt;/code&gt; を初めて使用し、概念と操作の概要が必要な場合は、このリファレンスマニュアルの前、おそらくここで読んでいる説明セクションの後に、ユーザーガイド &lt;code&gt; OTP Design Principles &lt;/code&gt; ある &lt;code&gt; gen_statem&amp;nbsp;Behaviour &lt;/code&gt; 動作のセクションを読むことをお勧めします。</target>
        </trans-unit>
        <trans-unit id="6ec4906363d7f3a0f656197645460eb641bfd86b" translate="yes" xml:space="preserve">
          <source>If you are not familiar with Cygwin, MSYS, MSYS2 or a Unix environment, you&amp;rsquo;ll probably need to read up a bit on how that works. There are plenty of documentation about this online.</source>
          <target state="translated">Cygwin、MSYS、MSYS2、またはUnix環境に慣れていない場合は、おそらくそれがどのように機能するかを少し読む必要があるでしょう。これに関するオンラインのドキュメントはたくさんあります。</target>
        </trans-unit>
        <trans-unit id="79e81e9c6f10164072a2c4df28a3214be53b197f" translate="yes" xml:space="preserve">
          <source>If you are not sure that OS system time is correct, set it to a time that is guaranteed to be earlier than actual POSIX time before starting the Erlang runtime system, just to be safe.</source>
          <target state="translated">OSシステムの時刻が正しいかどうかわからない場合は、Erlangランタイムシステムを起動する前に、実際のPOSIX時刻よりも早くなることが保証されている時刻に設定してください。</target>
        </trans-unit>
        <trans-unit id="139e4db82ce537b7ca402bb5648cb80768493b2d" translate="yes" xml:space="preserve">
          <source>If you are only interested in the age of all persons named &quot;Bryan&quot;, then:</source>
          <target state="translated">もしあなたが「ブライアン」という名前の人の年齢だけに興味があるのであれば</target>
        </trans-unit>
        <trans-unit id="a4b3fb25184745a8c5de1f41ef693f7c3d65a1fb" translate="yes" xml:space="preserve">
          <source>If you are running on a platform supporting HiPE and if you have not disabled HiPE, you can compile a module into native code like this from the Erlang shell:</source>
          <target state="translated">HiPEをサポートしているプラットフォーム上で実行していて、HiPEを無効にしていない場合は、Erlangシェルからこのようなネイティブコードにモジュールをコンパイルすることができます。</target>
        </trans-unit>
        <trans-unit id="12bada1e7a2afb8d739c0b1c4888bc6d1de99967" translate="yes" xml:space="preserve">
          <source>If you are testing a distributed Erlang application, it is likely that code you want included in the code coverage analysis gets executed on another Erlang node than the one &lt;code&gt;Common Test&lt;/code&gt; is running on. If so, you must specify these other nodes in the cover specification file or add them dynamically to the code coverage set of nodes. For details on the latter, see module &lt;code&gt;&lt;a href=&quot;ct_cover&quot;&gt;ct_cover&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">分散Erlangアプリケーションをテストしている場合、コードカバレッジ分析に含めるコードが、 &lt;code&gt;Common Test&lt;/code&gt; が実行されているものとは別のErlangノードで実行される可能性があります。その場合、カバー仕様ファイルでこれらの他のノードを指定するか、ノードのコードカバレッジセットに動的に追加する必要があります。後者の詳細については、モジュール &lt;code&gt;&lt;a href=&quot;ct_cover&quot;&gt;ct_cover&lt;/a&gt;&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="c864b6e67ea1285ed3a001c19cfbf05fe7b8b75d" translate="yes" xml:space="preserve">
          <source>If you are unsure whether you have freed the terms properly, you can use the following function to see the status of the fixed term allocator:</source>
          <target state="translated">きちんとタームを解放したかどうかわからない場合は、以下の関数を使って固定タームアロケーションの状態を確認することができます。</target>
        </trans-unit>
        <trans-unit id="785964c082f500e973ee23af1227a47d2e13719e" translate="yes" xml:space="preserve">
          <source>If you can edit and recompile the source code, it is convenient to insert &lt;code&gt;fprof:trace(start)&lt;/code&gt; and &lt;code&gt;fprof:trace(stop)&lt;/code&gt; before and after the code to be profiled. All spawned processes are also traced. If you want some other filename than the default try &lt;code&gt;fprof:trace(start, &quot;my_fprof.trace&quot;)&lt;/code&gt;.</source>
          <target state="translated">ソースコードを編集して再コンパイルできる場合は、プロファイルするコードの前後に &lt;code&gt;fprof:trace(start)&lt;/code&gt; および &lt;code&gt;fprof:trace(stop)&lt;/code&gt; を挿入すると便利です。生成されたすべてのプロセスもトレースされます。デフォルト以外のファイル名が必要な場合は、 &lt;code&gt;fprof:trace(start, &quot;my_fprof.trace&quot;)&lt;/code&gt; 試してください。</target>
        </trans-unit>
        <trans-unit id="b5adefb435e12cfcf7b44d388cd53353f9f445a0" translate="yes" xml:space="preserve">
          <source>If you combine catching exceptions from this function with &lt;code&gt;{dirty_timeout,T}&lt;/code&gt; to avoid that the calling process dies when the call times out, you will have to be prepared to handle a late reply. Note that there is an odd chance to get a late reply even with &lt;code&gt;{dirty_timeout,infinity}&lt;/code&gt; or &lt;code&gt;infinity&lt;/code&gt; for example in the event of network problems. So why not just let the calling process die by not catching the exception?</source>
          <target state="translated">この関数からのキャッチ例外を &lt;code&gt;{dirty_timeout,T}&lt;/code&gt; と組み合わせて、呼び出しがタイムアウトしたときに呼び出しプロセスが停止しないようにするには、遅延応答を処理する準備をする必要があります。ネットワークの問題が発生した場合などに、 &lt;code&gt;{dirty_timeout,infinity}&lt;/code&gt; または &lt;code&gt;infinity&lt;/code&gt; を使用しても応答が遅れる可能性があります。では、なぜ例外をキャッチしないことで呼び出しプロセスを死なせないのですか？</target>
        </trans-unit>
        <trans-unit id="926494dd9305a4cb191069b2570f8e16c82b75b1" translate="yes" xml:space="preserve">
          <source>If you compare with the code you will see there also that &lt;code&gt;foo:create_file_slow/3&lt;/code&gt; was called only from &lt;code&gt;foo:create_file_slow/2&lt;/code&gt; and itself, and called only &lt;code&gt;file:write/2&lt;/code&gt;, note the number of calls to &lt;code&gt;file:write/2&lt;/code&gt;. But here we see that &lt;code&gt;suspend&lt;/code&gt; was called a few times. This is a pseudo function that indicates that the process was suspended while executing in &lt;code&gt;foo:create_file_slow/3&lt;/code&gt;, and since there is no &lt;code&gt;receive&lt;/code&gt; or &lt;code&gt;erlang:yield/0&lt;/code&gt; in the code, it must be Erlang scheduling suspensions, or the trace file driver compensating for large file write operations (these are regarded as a schedule out followed by a schedule in to the same process).</source>
          <target state="translated">あなたは、コードと比較した場合、あなたはすることもありでしょう &lt;code&gt;foo:create_file_slow/3&lt;/code&gt; からのみ呼び出された &lt;code&gt;foo:create_file_slow/2&lt;/code&gt; と自体、およびのみと呼ばれる &lt;code&gt;file:write/2&lt;/code&gt; 、への呼び出しの数に注意 &lt;code&gt;file:write/2&lt;/code&gt; 。しかし、ここでは、 &lt;code&gt;suspend&lt;/code&gt; が数回呼び出されたことがわかります。これは、 &lt;code&gt;foo:create_file_slow/3&lt;/code&gt; での実行中にプロセスが中断されたことを示す疑似関数であり、コードに &lt;code&gt;receive&lt;/code&gt; または &lt;code&gt;erlang:yield/0&lt;/code&gt; がないため、Erlangスケジューリングの中断、またはトレースファイルドライバーの補正が必要です大きなファイルの書き込み操作の場合（これらは、同じプロセスへのスケジュールが続くスケジュールアウトと見なされます）。</target>
        </trans-unit>
        <trans-unit id="4da979d104276d1b284d0d0ed5628a6c4ba8264c" translate="yes" xml:space="preserve">
          <source>If you compile with the following, the result is one merged module &lt;code&gt;MyModule.erl&lt;/code&gt; with the generated code from the three ASN.1 specs:</source>
          <target state="translated">以下を使用してコンパイルした場合、結果は、3つのASN.1仕様から生成されたコードを &lt;code&gt;MyModule.erl&lt;/code&gt; 1つのマージモジュールMyModule.erlになります。</target>
        </trans-unit>
        <trans-unit id="229f423b538bb335420959949ffa6439771ff69b" translate="yes" xml:space="preserve">
          <source>If you compose your own &lt;code&gt;cipher_suites()&lt;/code&gt; make sure they are filtered for cryptolib support &lt;code&gt;&lt;a href=&quot;#filter_cipher_suites-2&quot;&gt; ssl:filter_cipher_suites/2 &lt;/a&gt;&lt;/code&gt; Additionaly the functions &lt;code&gt;&lt;a href=&quot;#append_cipher_suites-2&quot;&gt; ssl:append_cipher_suites/2 &lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#prepend_cipher_suites-2&quot;&gt; ssl:prepend_cipher_suites/2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#suite_to_str-1&quot;&gt;ssl:suite_to_str/1&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#str_to_suite-1&quot;&gt;ssl:str_to_suite/1&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#suite_to_openssl_str-1&quot;&gt;ssl:suite_to_openssl_str/1&lt;/a&gt;&lt;/code&gt; also exist to help creating customized cipher suite lists.</source>
          <target state="translated">あなたがあなた自身の作曲した場合 &lt;code&gt;cipher_suites()&lt;/code&gt; 確認して、彼らはcryptolib支援のためにフィルタリングされ &lt;code&gt;&lt;a href=&quot;#filter_cipher_suites-2&quot;&gt; ssl:filter_cipher_suites/2 &lt;/a&gt;&lt;/code&gt; Additionaly機能 &lt;code&gt;&lt;a href=&quot;#append_cipher_suites-2&quot;&gt; ssl:append_cipher_suites/2 &lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;#prepend_cipher_suites-2&quot;&gt; ssl:prepend_cipher_suites/2&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;#suite_to_str-1&quot;&gt;ssl:suite_to_str/1&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;#str_to_suite-1&quot;&gt;ssl:str_to_suite/1&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;#suite_to_openssl_str-1&quot;&gt;ssl:suite_to_openssl_str/1&lt;/a&gt;&lt;/code&gt; は、カスタマイズされた暗号スイートリストの作成を支援するためにも存在します。</target>
        </trans-unit>
        <trans-unit id="2523acc9d9b699bb6e45fe3319252f79d5b73690" translate="yes" xml:space="preserve">
          <source>If you decide not to run the test case after all, return &lt;code&gt;{skip, Reason}&lt;/code&gt;. &lt;code&gt;Reason&lt;/code&gt; is then printed in field &lt;code&gt;Comment&lt;/code&gt; on the HTML result page.</source>
          <target state="translated">結局、テストケースを実行しないことにした場合は、 &lt;code&gt;{skip, Reason}&lt;/code&gt; 返します。 &lt;code&gt;Reason&lt;/code&gt; は、HTML結果ページの[ &lt;code&gt;Comment&lt;/code&gt; フィールドに出力されます。</target>
        </trans-unit>
        <trans-unit id="34553151842c57d51c700a2176df03643a8e288f" translate="yes" xml:space="preserve">
          <source>If you decide not to run the test case after all, return &lt;code&gt;{skip,Reason}&lt;/code&gt;. &lt;code&gt;Reason&lt;/code&gt; is then printed in field &lt;code&gt;Comment&lt;/code&gt; on the HTML result page.</source>
          <target state="translated">結局、テストケースを実行しないことにした場合は、 &lt;code&gt;{skip,Reason}&lt;/code&gt; 返します。 &lt;code&gt;Reason&lt;/code&gt; は、HTML結果ページのフィールド &lt;code&gt;Comment&lt;/code&gt; に印刷されます。</target>
        </trans-unit>
        <trans-unit id="cc41ca02f8abc69bcba03c2039a4711eec766fcf" translate="yes" xml:space="preserve">
          <source>If you desire to also use some other general cover configuration together with this option you should insert the AppName in between the option and its value creating a three tuple.</source>
          <target state="translated">こ のオプ シ ョ ン と と も に他の一般的なカバ ー設定を使いたい場合は、 AppName をオプシ ョ ン と その値の間に挿入して 3 つのタプルを作成する必要があ り ます。</target>
        </trans-unit>
        <trans-unit id="32b5510ec0b67d605ceab6963978d04cd1ab40d6" translate="yes" xml:space="preserve">
          <source>If you develop linked-in drivers (shared library) you need to link using &lt;code&gt;gcc&lt;/code&gt; and the flags &lt;code&gt;-bundle -flat_namespace -undefined suppress&lt;/code&gt;. You also include &lt;code&gt;-fno-common&lt;/code&gt; in &lt;code&gt;CFLAGS&lt;/code&gt; when compiling. Use &lt;code&gt;.so&lt;/code&gt; as the library suffix.</source>
          <target state="translated">リンクされたドライバー（共有ライブラリ）を開発する場合は、 &lt;code&gt;gcc&lt;/code&gt; とフラグ &lt;code&gt;-bundle -flat_namespace -undefined suppress&lt;/code&gt; を使用してリンクする必要があります。また、コンパイル時に &lt;code&gt;CFLAGS&lt;/code&gt; に &lt;code&gt;-fno-common&lt;/code&gt; を含めます。ライブラリのサフィックスとして &lt;code&gt;.so&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="9af22866bc3303d3e5e15bb7da268298a32e5b69" translate="yes" xml:space="preserve">
          <source>If you do not have a complete binary of the file content, you can instead chunk through the file and check part by part. The return-tuple &lt;code&gt;{incomplete,Decoded,Rest}&lt;/code&gt; from function &lt;code&gt;unicode:characters_to_binary/1,2,3&lt;/code&gt; comes in handy. The incomplete rest from one chunk of data read from the file is prepended to the next chunk and we therefore avoid the problem of character boundaries when reading chunks of bytes in UTF-8 encoding:</source>
          <target state="translated">ファイルコンテンツの完全なバイナリがない場合は、代わりにファイルをチャンクし、部分ごとにチェックできます。関数 &lt;code&gt;unicode:characters_to_binary/1,2,3&lt;/code&gt; からの戻りタプル &lt;code&gt;{incomplete,Decoded,Rest}&lt;/code&gt; が便利です。ファイルから読み取られたデータのチャンクの不完全な残りは、次のチャンクの前に追加されるため、UTF-8エンコーディングでバイトのチャンクを読み取るときの文字境界の問題を回避します。</target>
        </trans-unit>
        <trans-unit id="d69c0d8ff5a49420e5ccb90500698b1a5b852393" translate="yes" xml:space="preserve">
          <source>If you do not need the statistical quality of this function, there are faster algorithms in the &lt;code&gt;rand&lt;/code&gt; module.</source>
          <target state="translated">この関数の統計的品質が必要ない場合は、 &lt;code&gt;rand&lt;/code&gt; モジュールに高速なアルゴリズムがあります。</target>
        </trans-unit>
        <trans-unit id="ec8d18a133f467591527f3dafe062626f3a3e3a8" translate="yes" xml:space="preserve">
          <source>If you do not need to reallocate or keep the data alive across NIF calls, consider using &lt;code&gt;&lt;a href=&quot;#enif_make_new_binary&quot;&gt; enif_make_new_binary&lt;/a&gt;&lt;/code&gt; instead as it will allocate small binaries on the process heap when possible.</source>
          <target state="translated">NIF呼び出し間でデータを再割り当てしたり、データを存続させたりする必要がない場合は、 &lt;code&gt;&lt;a href=&quot;#enif_make_new_binary&quot;&gt; enif_make_new_binary&lt;/a&gt;&lt;/code&gt; プロセスヒープに小さなバイナリを割り当てるため、代わりにenif_make_new_binaryの使用を検討してください。</target>
        </trans-unit>
        <trans-unit id="45fdd3948b5b8d018a253264434e3fdb3b1f2c9e" translate="yes" xml:space="preserve">
          <source>If you do not need to reallocate or keep the data alive across NIF calls, consider using &lt;code&gt;&lt;a href=&quot;#enif_make_new_binary&quot;&gt;enif_make_new_binary&lt;/a&gt;&lt;/code&gt; instead as it will allocate small binaries on the process heap when possible.</source>
          <target state="translated">データを再割り当てしたり、NIF呼び出し全体でデータを保持したりする必要がない場合は、代わりに &lt;code&gt;&lt;a href=&quot;#enif_make_new_binary&quot;&gt;enif_make_new_binary&lt;/a&gt;&lt;/code&gt; を使用することを検討してください。可能な場合、プロセスヒープに小さなバイナリが割り当てられます。</target>
        </trans-unit>
        <trans-unit id="0d84e01d642f906e2813071c9f195dfd3ff33506" translate="yes" xml:space="preserve">
          <source>If you do ordinary &lt;code&gt;send&lt;/code&gt; or &lt;code&gt;receive&lt;/code&gt; trace on the system, you will only see ordinary message passing, not the other information transfers listed above.</source>
          <target state="translated">システムで通常の &lt;code&gt;send&lt;/code&gt; または &lt;code&gt;receive&lt;/code&gt; トレースを実行すると、通常のメッセージパッシングのみが表示され、上記の他の情報転送は表示されません。</target>
        </trans-unit>
        <trans-unit id="5226c0c04d7fd8e63c97c31f497edc30ae0498fc" translate="yes" xml:space="preserve">
          <source>If you don't use X-windows, you might want to setup the Windows console window by selecting properties in the console system menu (upper left corner of the window, the Cygwin icon in the title bar). Especially setting a larger screen buffer size (lines) is useful as it gets you a scrollbar so you can see whatever error messages that might appear.</source>
          <target state="translated">X-windows を使っていない場合は、コンソールシステムメニューのプロパティ(ウィンドウの左上隅、タイトルバーの Cygwin アイコン)を選択して、Windows コンソールウィンドウを設定するとよいでしょう。特に、画面のバッファサイズ(行数)を大きく設定すると、スクロールバーが表示されるので、表示される可能性のあるエラーメッセージを見ることができるので便利です。</target>
        </trans-unit>
        <trans-unit id="c1c77e78076b1c45254b83e1685877227a58e370" translate="yes" xml:space="preserve">
          <source>If you explicitly want to set the program name in the argument vector, option &lt;code&gt;arg0&lt;/code&gt; can be used.</source>
          <target state="translated">引数ベクトルにプログラム名を明示的に設定したい場合は、オプション &lt;code&gt;arg0&lt;/code&gt; を使用できます。</target>
        </trans-unit>
        <trans-unit id="f75fbec32c4686a4e8aec99dc351f8983616950b" translate="yes" xml:space="preserve">
          <source>If you fail to clear thread-specific data in an emulator thread before letting it out of your control, you might never be able to clear this data with later unexpected errors in other parts of the system as a result.</source>
          <target state="translated">エミュレータのスレッドでスレッド固有のデータをクリアしてから制御不能にしてしまうと、後になってシステムの他の部分で予期せぬエラーが発生して、このデータをクリアできなくなってしまうかもしれません。</target>
        </trans-unit>
        <trans-unit id="09268e829b124cfcf4bd5de6e9875906ac8513d6" translate="yes" xml:space="preserve">
          <source>If you feel comfortable with the environment and build system, and have all the necessary tools, you have a great opportunity to make the Erlang/OTP distribution for Windows better. Please submit any suggestions to our &lt;code&gt;&lt;a href=&quot;http://bugs.erlang.org&quot;&gt;JIRA&lt;/a&gt;&lt;/code&gt; and patches to our &lt;code&gt;&lt;a href=&quot;https://github.com/erlang/otp&quot;&gt;git project&lt;/a&gt;&lt;/code&gt; to let them find their way into the next version of Erlang. If making changes to the build system (like makefiles etc) please bear in mind that the same makefiles are used on Unix/VxWorks, so that your changes don't break other platforms. That of course goes for C-code too; system specific code resides in the &lt;code&gt;$ERL_TOP/erts/emulator/sys/win32&lt;/code&gt; and &lt;code&gt;$ERL_TOP/erts/etc/win32&lt;/code&gt; directories mostly. The &lt;code&gt;$ERL_TOP/erts/emulator/beam&lt;/code&gt; directory is for common code.</source>
          <target state="translated">環境とビルドシステムに慣れ、必要なツールがすべて揃っていれば、Windows用のErlang / OTPディストリビューションをより良いものにするチャンスがあります。 &lt;code&gt;&lt;a href=&quot;http://bugs.erlang.org&quot;&gt;JIRA&lt;/a&gt;&lt;/code&gt; への提案と &lt;code&gt;&lt;a href=&quot;https://github.com/erlang/otp&quot;&gt;git project&lt;/a&gt;&lt;/code&gt; へのパッチを提出して、Erlangの次のバージョンへの道を見つけてください。ビルドシステムに変更を加える場合（makefileなど）、同じmakefileがUnix / VxWorksで使用されているため、変更によって他のプラットフォームが壊れることはありません。もちろん、Cコードも同様です。システム固有のコードは、主に &lt;code&gt;$ERL_TOP/erts/emulator/sys/win32&lt;/code&gt; および &lt;code&gt;$ERL_TOP/erts/etc/win32&lt;/code&gt; ディレクトリにあります。 &lt;code&gt;$ERL_TOP/erts/emulator/beam&lt;/code&gt; ディレクトリには、共通のコードです。</target>
        </trans-unit>
        <trans-unit id="c1e46734643c479e7f6063eb73e949cb06d69d85" translate="yes" xml:space="preserve">
          <source>If you find that some common Logger usage is missing from this guide, please open a pull request on github with the suggested addition</source>
          <target state="translated">このガイドにない一般的なロガーの使用法を見つけた場合は、github でプルリクエストを開いて、提案された追加事項を追加してください。</target>
        </trans-unit>
        <trans-unit id="6c7e44c265926484064ef3996081db76eb5b3893" translate="yes" xml:space="preserve">
          <source>If you frequently do a lookup on a field that is not the key of the table, you lose performance using &quot;mnesia:select/match_object&quot; as this function traverses the whole table. You can create a secondary index instead and use &quot;mnesia:index_read&quot; to get faster access, however this requires more memory.</source>
          <target state="translated">テーブルのキーではないフィールドを頻繁に検索する場合、この関数はテーブル全体を横断するので、&quot;mnesia:select/match_object &quot;を使用するとパフォーマンスが低下します。代わりにセカンダリインデックスを作成し、&quot;mnesia:index_read &quot;を使用して高速なアクセスを得ることができますが、これはより多くのメモリを必要とします。</target>
        </trans-unit>
        <trans-unit id="d250cbc8ce8f103748e70e8012ae4812e69e6b6e" translate="yes" xml:space="preserve">
          <source>If you got a public key &lt;code&gt;PubKey&lt;/code&gt; and a related list of attributes &lt;code&gt;Attributes&lt;/code&gt; as returned by &lt;code&gt;ssh_decode/2&lt;/code&gt;, you can create a new SSH file, for example:</source>
          <target state="translated">公開鍵 &lt;code&gt;PubKey&lt;/code&gt; と、 &lt;code&gt;ssh_decode/2&lt;/code&gt; によって返された属性 &lt;code&gt;Attributes&lt;/code&gt; の関連リストを取得した場合、次のように新しいSSHファイルを作成できます。</target>
        </trans-unit>
        <trans-unit id="d64558ffe085d81fb4c2a7370d51643970e9b47a" translate="yes" xml:space="preserve">
          <source>If you hack the emulator, you can build the emulator executable by standing in &lt;code&gt;$ERL_TOP/erts/emulator&lt;/code&gt; and do a simple</source>
          <target state="translated">エミュレーターをハックする場合は、 &lt;code&gt;$ERL_TOP/erts/emulator&lt;/code&gt; 立ってエミュレーターの実行可能ファイルをビルドし、簡単な操作を実行できます。</target>
        </trans-unit>
        <trans-unit id="57dee92dc02000c0c82e5fb9e2da62997a25dbd7" translate="yes" xml:space="preserve">
          <source>If you have Xcode 4.3, or later, you will also need to download &quot;Command Line Tools&quot; via the Downloads preference pane in Xcode.</source>
          <target state="translated">Xcode 4.3以降をお持ちの場合は、Xcodeのダウンロード環境設定ペインから &quot;Command Line Tools &quot;をダウンロードする必要があります。</target>
        </trans-unit>
        <trans-unit id="709a85ba273f4493deb19337d8dab86c17b51b44" translate="yes" xml:space="preserve">
          <source>If you have a list of lists &lt;code&gt;L = [&quot;I&quot;,&quot;like&quot;,&quot;Erlang&quot;]&lt;/code&gt;, then you can sum the lengths of all the strings in &lt;code&gt;L&lt;/code&gt; as follows:</source>
          <target state="translated">リストのリスト &lt;code&gt;L = [&quot;I&quot;,&quot;like&quot;,&quot;Erlang&quot;]&lt;/code&gt; 場合、次のように &lt;code&gt;L&lt;/code&gt; のすべての文字列の長さを合計できます。</target>
        </trans-unit>
        <trans-unit id="06562602ec1a77035c75bd6f06f61c39f1543c77" translate="yes" xml:space="preserve">
          <source>If you have added the declaration &lt;code&gt;-include_lib(&quot;eunit/include/eunit.hrl&quot;)&lt;/code&gt; to your module, as described above, you only need to compile the module, and run the automatically exported function &lt;code&gt;test()&lt;/code&gt;. For example, if your module was named &lt;code&gt;m&lt;/code&gt;, then calling &lt;code&gt;m:test()&lt;/code&gt; will run EUnit on all the tests defined in the module. You do not need to write &lt;code&gt;-export&lt;/code&gt; declarations for the test functions. This is all done by magic.</source>
          <target state="translated">上記のように宣言 &lt;code&gt;-include_lib(&quot;eunit/include/eunit.hrl&quot;)&lt;/code&gt; をモジュールに追加した場合は、モジュールをコンパイルして、自動的にエクスポートされた関数 &lt;code&gt;test()&lt;/code&gt; を実行するだけで済みます。たとえば、モジュールの名前が &lt;code&gt;m&lt;/code&gt; の場合、 &lt;code&gt;m:test()&lt;/code&gt; を呼び出すと、モジュールで定義されているすべてのテストでEUnitが実行されます。テスト関数の &lt;code&gt;-export&lt;/code&gt; 宣言を記述する必要はありません。これはすべて魔法によって行われます。</target>
        </trans-unit>
        <trans-unit id="144f513a5aa39876b81ef2c80a71c2be4b26f4ef" translate="yes" xml:space="preserve">
          <source>If you have installed Erlang/OTP using the &lt;code&gt;install&lt;/code&gt; target, install the documentation using the &lt;code&gt;install-docs&lt;/code&gt; target. Install locations determined by &lt;code&gt;configure&lt;/code&gt; will be used. &lt;code&gt;$DESTDIR&lt;/code&gt; can be used the same way as when doing &lt;code&gt;make install&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;install&lt;/code&gt; ターゲットを使用してErlang / OTPをインストールした場合は、 &lt;code&gt;install-docs&lt;/code&gt; ターゲットを使用してドキュメントをインストールします。 &lt;code&gt;configure&lt;/code&gt; によって決定されたインストール場所が使用されます。 &lt;code&gt;$DESTDIR&lt;/code&gt; は、 &lt;code&gt;make install&lt;/code&gt; を実行するときと同じ方法で使用できます。</target>
        </trans-unit>
        <trans-unit id="f15d88801e622a2cdd2d2c7fe2a4a670f216ed9a" translate="yes" xml:space="preserve">
          <source>If you have installed Erlang/OTP using the &lt;code&gt;release&lt;/code&gt; target, install the documentation using the &lt;code&gt;release_docs&lt;/code&gt; target. You typically want to use the same &lt;code&gt;RELEASE_ROOT&lt;/code&gt; as when invoking &lt;code&gt;make release&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;release&lt;/code&gt; ターゲットを使用してErlang / OTPをインストールした場合は、 &lt;code&gt;release_docs&lt;/code&gt; ターゲットを使用してドキュメントをインストールします。通常、 &lt;code&gt;make release&lt;/code&gt; を呼び出すときと同じ &lt;code&gt;RELEASE_ROOT&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="56c20a2d676e8cfb31affcccb02e9255a03aa95c" translate="yes" xml:space="preserve">
          <source>If you have installed documentation in the OTP installation, also build the documentation:</source>
          <target state="translated">OTPインストールでドキュメントをインストールしている場合は、ドキュメントもビルドしてください。</target>
        </trans-unit>
        <trans-unit id="e2d1684e846a6a2121920a90b95e7857c8b4feb5" translate="yes" xml:space="preserve">
          <source>If you have just built Erlang/OTP in the current source tree, you have already ran &lt;code&gt;configure&lt;/code&gt; and do not need to do this again; otherwise, run &lt;code&gt;configure&lt;/code&gt;.</source>
          <target state="translated">現在のソースツリーでErlang / OTPをビルドしたばかりの場合は、すでに &lt;code&gt;configure&lt;/code&gt; を実行しているので、これを再度行う必要はありません。それ以外の場合は、 &lt;code&gt;configure&lt;/code&gt; を実行します。</target>
        </trans-unit>
        <trans-unit id="636ce5c9d1bb03f9748b5bbe5ec2f545e4d839b3" translate="yes" xml:space="preserve">
          <source>If you have many servers in one node and they have some state(s) in their lifetime in which the servers can be expected to idle for a while, and the amount of heap memory all these servers need is a problem, then the memory footprint of a server can be mimimized by hibernating it through &lt;code&gt;proc_lib:hibernate/3&lt;/code&gt;.</source>
          <target state="translated">1つのノードに多数のサーバーがあり、それらの存続期間にサーバーがしばらくアイドル状態になることが予想されるいくつかの状態があり、これらすべてのサーバーに必要なヒープメモリの量が問題である場合、メモリフットプリントサーバーのは、 &lt;code&gt;proc_lib:hibernate/3&lt;/code&gt; を介して休止状態にすることで最小化できます。</target>
        </trans-unit>
        <trans-unit id="9cf69c3d3514b68c365fa229d8d36e057061c7ae" translate="yes" xml:space="preserve">
          <source>If you have one function that does the task that you want to profile, and the function returns when the profiling should stop, it is convenient to use &lt;code&gt;fprof:apply(Module, Function, Args)&lt;/code&gt; and related for the tracing step.</source>
          <target state="translated">プロファイリングするタスクを実行する関数が1つあり、プロファイリングを停止する必要があるときに関数が戻る場合は、 &lt;code&gt;fprof:apply(Module, Function, Args)&lt;/code&gt; および関連するトレースステップを使用すると便利です。</target>
        </trans-unit>
        <trans-unit id="4add882c433457afa2edf542bb650cc29a895ccb" translate="yes" xml:space="preserve">
          <source>If you have public-key data and want to create a PEM file this can be done by calling functions &lt;code&gt;public_key:pem_entry_encode/2&lt;/code&gt; and &lt;code&gt;pem_encode/1&lt;/code&gt; and saving the result to a file. For example, assume that you have &lt;code&gt;PubKey = 'RSAPublicKey'{}&lt;/code&gt;. Then you can create a PEM-&quot;RSA PUBLIC KEY&quot; file (ASN.1 type &lt;code&gt;'RSAPublicKey'&lt;/code&gt;) or a PEM-&quot;PUBLIC KEY&quot; file (&lt;code&gt;'SubjectPublicKeyInfo'&lt;/code&gt; ASN.1 type).</source>
          <target state="translated">公開鍵データがあり、PEMファイルを作成したい場合は、関数 &lt;code&gt;public_key:pem_entry_encode/2&lt;/code&gt; および &lt;code&gt;pem_encode/1&lt;/code&gt; を呼び出し、結果をファイルに保存することでこれを行うことができます。たとえば、 &lt;code&gt;PubKey = 'RSAPublicKey'{}&lt;/code&gt; ます。次に、PEM- &quot;RSA PUBLIC KEY&quot;ファイル（ASN.1タイプ &lt;code&gt;'RSAPublicKey'&lt;/code&gt; ）またはPEM- &quot;PUBLIC KEY&quot;ファイル（ &lt;code&gt;'SubjectPublicKeyInfo'&lt;/code&gt; ASN.1タイプ）を作成できます。</target>
        </trans-unit>
        <trans-unit id="bff364d7b744c7c80f16da3e2585cd7454157cd3" translate="yes" xml:space="preserve">
          <source>If you have system configuration data that is neither file-location-dependent nor site-dependent, it can be convenient to create &lt;code&gt;sys.config&lt;/code&gt; early, so it becomes part of the target system tar file created by &lt;code&gt;target_system:create/1&lt;/code&gt;. In fact, if you in the current directory create not only the file &lt;code&gt;mysystem.rel&lt;/code&gt;, but also file &lt;code&gt;sys.config&lt;/code&gt;, the latter file is tacitly put in the appropriate directory.</source>
          <target state="translated">ファイルの場所やサイトに依存しないシステム構成データがある場合は、 &lt;code&gt;sys.config&lt;/code&gt; を早期に作成しておくと便利です。そのため、このデータは、 &lt;code&gt;target_system:create/1&lt;/code&gt; によって作成されるターゲットシステムのtarファイルの一部になります。あなたは現在のディレクトリ内のファイルだけでなく、作成した場合、実際には、 &lt;code&gt;mysystem.rel&lt;/code&gt; 、だけでなく、ファイル &lt;code&gt;sys.config&lt;/code&gt; を、後者のファイルは、暗黙のうち、適切なディレクトリに置かれています。</target>
        </trans-unit>
        <trans-unit id="dd12871aeecfcf251ad76c0f1867361b2f02e152" translate="yes" xml:space="preserve">
          <source>If you have your cross compilation configuration in a file, pass it using the &lt;code&gt;--xcomp-conf=&amp;lt;FILE&amp;gt;&lt;/code&gt; command line argument. If not, pass &lt;code&gt;--host=&amp;lt;HOST&amp;gt;&lt;/code&gt;, &lt;code&gt;--build=&amp;lt;BUILD&amp;gt;&lt;/code&gt;, and the configuration variables using a &lt;code&gt;&amp;lt;VARIABLE&amp;gt;=&amp;lt;VALUE&amp;gt;&lt;/code&gt; syntax on the command line (same as in (3)). Note that &lt;code&gt;&amp;lt;HOST&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;BUILD&amp;gt;&lt;/code&gt; have to be passed one way or the other; either by using &lt;code&gt;erl_xcomp_host=&amp;lt;HOST&amp;gt;&lt;/code&gt; and &lt;code&gt;erl_xcomp_build=&amp;lt;BUILD&amp;gt;&lt;/code&gt; in the configuration file, or by using the &lt;code&gt;--host=&amp;lt;HOST&amp;gt;&lt;/code&gt;, and &lt;code&gt;--build=&amp;lt;BUILD&amp;gt;&lt;/code&gt; command line arguments.</source>
          <target state="translated">ファイルにクロスコンパイル設定がある場合は、 &lt;code&gt;--xcomp-conf=&amp;lt;FILE&amp;gt;&lt;/code&gt; コマンドライン引数を使用して渡します。そうでない場合は、-- &lt;code&gt;--host=&amp;lt;HOST&amp;gt;&lt;/code&gt; 、-- &lt;code&gt;--build=&amp;lt;BUILD&amp;gt;&lt;/code&gt; 、およびコマンドラインで &lt;code&gt;&amp;lt;VARIABLE&amp;gt;=&amp;lt;VALUE&amp;gt;&lt;/code&gt; 構文を使用して構成変数を渡します（（3）と同じ）。 &lt;code&gt;&amp;lt;HOST&amp;gt;&lt;/code&gt; と &lt;code&gt;&amp;lt;BUILD&amp;gt;&lt;/code&gt; はどちらか一方に渡す必要があることに注意してください。構成ファイルで &lt;code&gt;erl_xcomp_host=&amp;lt;HOST&amp;gt;&lt;/code&gt; および &lt;code&gt;erl_xcomp_build=&amp;lt;BUILD&amp;gt;&lt;/code&gt; を使用するか、-- host &lt;code&gt;--host=&amp;lt;HOST&amp;gt;&lt;/code&gt; および &lt;code&gt;--build=&amp;lt;BUILD&amp;gt;&lt;/code&gt; コマンドライン引数を使用します。</target>
        </trans-unit>
        <trans-unit id="496f196f55a6fe378376abb5b448050f783c1628" translate="yes" xml:space="preserve">
          <source>If you in &lt;code&gt;gen_statem&lt;/code&gt;, for example, postpone an event in one state and then call another &lt;strong&gt;state callback&lt;/strong&gt; of yours, you have not done a &lt;strong&gt;state change&lt;/strong&gt; and hence the postponed event is not retried, which is logical but can be confusing.</source>
          <target state="translated">あなたがでた場合は &lt;code&gt;gen_statem&lt;/code&gt; 、例えば、一つの状態でイベントを延期して、別の呼び出し&lt;strong&gt;状態コールバック&lt;/strong&gt;あなたのを、あなたは行っていない&lt;strong&gt;状態変化を&lt;/strong&gt;、ひいては延期イベントが論理的であるが、混乱することができ、再試行されていません。</target>
        </trans-unit>
        <trans-unit id="a130450837fa7de4006e06dfdf6e7651f3519c93" translate="yes" xml:space="preserve">
          <source>If you in &lt;code&gt;gen_statem&lt;/code&gt;, for example, postpone an event in one state and then call another state callback of yours, you have not changed states and hence the postponed event is not retried, which is logical but can be confusing.</source>
          <target state="translated">あなたがでた場合は &lt;code&gt;gen_statem&lt;/code&gt; 、例えば、あなたの別の状態コールバックを一つの状態でイベントを延期してから呼び出して、あなたは状態を変更していないので、延期イベントが論理的であるが、混乱することができ、再試行されていません。</target>
        </trans-unit>
        <trans-unit id="0b9dac884f6e658e0d27a929573db5f362853b18" translate="yes" xml:space="preserve">
          <source>If you instead receives the XML doc as a string you can parse it by &lt;code&gt;xmerl_scan:string/1&lt;/code&gt;. Both file/2 and string/2 exists where the second argument is a list of options to the parser, see the &lt;code&gt;&lt;a href=&quot;xmerl_scan&quot;&gt;reference manual&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">代わりにXMLドキュメントを文字列として受け取った場合は、 &lt;code&gt;xmerl_scan:string/1&lt;/code&gt; で解析できます。file / 2とstring / 2の両方が存在し、2番目の引数はパーサーのオプションのリストです。 &lt;code&gt;&lt;a href=&quot;xmerl_scan&quot;&gt;reference manual&lt;/a&gt;&lt;/code&gt; 参照してください。</target>
        </trans-unit>
        <trans-unit id="3677b7b2be331958bb1cd558066c15e2ccbebc50" translate="yes" xml:space="preserve">
          <source>If you know that the binaries you return are always small, you are advised to use driver API calls that do not require a pre-allocated binary, for example, &lt;code&gt;driver_output()&lt;/code&gt; or &lt;code&gt;erl_drv_output_term()&lt;/code&gt;, using the &lt;code&gt;ERL_DRV_BUF2BINARY&lt;/code&gt; format, to allow the runtime to construct a heap binary.</source>
          <target state="translated">返されるバイナリが常に小さいことがわかっている場合は、 &lt;code&gt;ERL_DRV_BUF2BINARY&lt;/code&gt; 形式を使用して、事前に割り当てられたバイナリを必要としないドライバAPI呼び出し &lt;code&gt;driver_output()&lt;/code&gt; または &lt;code&gt;erl_drv_output_term()&lt;/code&gt; など）を使用してランタイムを許可することをお勧めしますヒープバイナリを構築します。</target>
        </trans-unit>
        <trans-unit id="ec9a6635ce4a0b540125a17cac3147d60753ebe4" translate="yes" xml:space="preserve">
          <source>If you know the location of the &lt;code&gt;escript&lt;/code&gt; executable, the first line can directly give the path to &lt;code&gt;escript&lt;/code&gt;, for example:</source>
          <target state="translated">&lt;code&gt;escript&lt;/code&gt; 実行可能ファイルの場所がわかっている場合は、最初の行で &lt;code&gt;escript&lt;/code&gt; へのパスを直接指定できます。次に例を示します。</target>
        </trans-unit>
        <trans-unit id="b659d556ba001a4273a3f6f58c5f3fae0a2ecf0c" translate="yes" xml:space="preserve">
          <source>If you leave a mutex locked in an emulator thread when you let the thread out of your control, you will &lt;strong&gt;very likely&lt;/strong&gt; deadlock the whole emulator.</source>
          <target state="translated">スレッドを制御不能にしたときに、ミューテックスをエミュレータスレッドにロックしたままにすると、エミュレータ全体&lt;strong&gt;が&lt;/strong&gt;デッドロックする&lt;strong&gt;可能性&lt;/strong&gt;が&lt;strong&gt;高くなり&lt;/strong&gt;ます。</target>
        </trans-unit>
        <trans-unit id="1b0a6367d887c72eef350e1e461ed2440088fd89" translate="yes" xml:space="preserve">
          <source>If you leave an rwlock locked in an emulator thread when you let the thread out of your control, you will &lt;strong&gt;very likely&lt;/strong&gt; deadlock the whole emulator.</source>
          <target state="translated">スレッドを制御不能にしたときにエミュレータースレッドでrwlockをロックしたままにすると、エミュレーター全体&lt;strong&gt;が&lt;/strong&gt;デッドロックする&lt;strong&gt;可能性&lt;/strong&gt;が&lt;strong&gt;高くなり&lt;/strong&gt;ます。</target>
        </trans-unit>
        <trans-unit id="2051d057687b13e60280ea15afa70933db6bc2e6" translate="yes" xml:space="preserve">
          <source>If you must remain compatible with the USTAR tar format, you must ensure file paths being stored are less than 255 bytes in total, with a maximum filename component length of 100 bytes. USTAR uses a header field (prefix) in addition to the name field, and splits file paths longer than 100 bytes into two parts. This split is done on a directory boundary, and is done in such a way to make the best use of the space available in those two fields, but in practice this will often mean that you have less than 255 bytes for a path. &lt;code&gt;erl_tar&lt;/code&gt; will automatically upgrade the format to PAX to handle longer filenames, so this is only an issue if you need to extract the archive with an older implementation of &lt;code&gt;erl_tar&lt;/code&gt; or &lt;code&gt;tar&lt;/code&gt; which does not support PAX. In this case, the PAX headers will be extracted as regular files, and you will need to apply them manually.</source>
          <target state="translated">USTAR tar形式との互換性を維持する必要がある場合は、保存されるファイルパスが合計で255バイト未満、ファイル名コンポーネントの最大長が100バイトであることを確認する必要があります。 USTARは、名前フィールドに加えてヘッダーフィールド（プレフィックス）を使用し、100バイトを超えるファイルパスを2つの部分に分割します。この分割は、ディレクトリ境界で行われ、これら2つのフィールドで利用可能なスペースを最大限に活用する方法で行われますが、実際には、パスの255バイトよりも少ないことを意味します。 &lt;code&gt;erl_tar&lt;/code&gt; はフォーマットをPAXに自動的にアップグレードしてより長いファイル名を処理するため、これは、 &lt;code&gt;erl_tar&lt;/code&gt; または &lt;code&gt;tar&lt;/code&gt; の古い実装でアーカイブを抽出する必要がある場合にのみ問題になります。PAXをサポートしていません。この場合、PAXヘッダーは通常のファイルとして抽出されるため、手動で適用する必要があります。</target>
        </trans-unit>
        <trans-unit id="25dcb500f427185c223988b86fbacdec9413c19c" translate="yes" xml:space="preserve">
          <source>If you need all information stored in the Ets table about persons named &quot;Bryan&quot;, then:</source>
          <target state="translated">ブライアン」という名前の人物について、Etsテーブルに保存されているすべての情報が必要な場合は、次のようにします。</target>
        </trans-unit>
        <trans-unit id="f37451567abb8a5fc173c77a71ec77e3d5bec387" translate="yes" xml:space="preserve">
          <source>If you need cryptographically strong random numbers use &lt;code&gt;&lt;a href=&quot;#rand_seed_alg_s-1&quot;&gt;rand_seed_alg_s/1&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;Alg =:= crypto&lt;/code&gt; or &lt;code&gt;Alg =:= crypto_cache&lt;/code&gt;.</source>
          <target state="translated">暗号的に強い乱数が必要な場合は、 &lt;code&gt;&lt;a href=&quot;#rand_seed_alg_s-1&quot;&gt;rand_seed_alg_s/1&lt;/a&gt;&lt;/code&gt; を &lt;code&gt;Alg =:= crypto&lt;/code&gt; または &lt;code&gt;Alg =:= crypto_cache&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="0103403298226ace2d2d7dda7dc0c9b1cec0d2bd" translate="yes" xml:space="preserve">
          <source>If you need to access a relational database such as &lt;code&gt;sqlserver&lt;/code&gt;, &lt;code&gt;mysql&lt;/code&gt;, &lt;code&gt;postgres&lt;/code&gt;, &lt;code&gt;oracle&lt;/code&gt;, &lt;code&gt;cybase&lt;/code&gt; etc. from your erlang application using the Erlang ODBC interface is a good way to go about it.</source>
          <target state="translated">&lt;code&gt;sqlserver&lt;/code&gt; 、 &lt;code&gt;mysql&lt;/code&gt; 、 &lt;code&gt;postgres&lt;/code&gt; 、 &lt;code&gt;oracle&lt;/code&gt; 、 &lt;code&gt;cybase&lt;/code&gt; などのリレーショナルデータベースにアクセスする必要がある場合は、Erlang ODBCインターフェースを使用してerlangアプリケーションからアクセスするのが良い方法です。</target>
        </trans-unit>
        <trans-unit id="062952594b89959967de93ea3f7d77ceb7f51d4f" translate="yes" xml:space="preserve">
          <source>If you need to be able to repeat the sequence use this function.</source>
          <target state="translated">シーケンスの繰り返しが必要な場合は、この関数を使用してください。</target>
        </trans-unit>
        <trans-unit id="e9153977b046897dff8af7e0a644f81df1265049" translate="yes" xml:space="preserve">
          <source>If you need to cancel a timer because of some other event, you can use &lt;code&gt;erlang:cancel_timer(Tref)&lt;/code&gt;. Note that a time-out message cannot arrive after this, unless you have postponed it before (see the next section), so ensure that you do not accidentally postpone such messages. Also note that a time-out message may have arrived just before you cancelling it, so you may have to read out such a message from the process mailbox depending on the return value from &lt;code&gt;erlang:cancel_timer(Tref)&lt;/code&gt;.</source>
          <target state="translated">他のイベントのためにタイマーをキャンセルする必要がある場合は、 &lt;code&gt;erlang:cancel_timer(Tref)&lt;/code&gt; を使用できます。タイムアウトメッセージは、前に延期していない限り（次のセクションを参照）、到着しないので注意してください。誤ってそのようなメッセージを延期しないようにしてください。また、キャンセルする直前にタイムアウトメッセージが到着した可能性があるため、 &lt;code&gt;erlang:cancel_timer(Tref)&lt;/code&gt; からの戻り値によっては、このようなメッセージをプロセスメールボックスから読み取る必要がある場合があります。</target>
        </trans-unit>
        <trans-unit id="c795f2c3cb53282059f2c8f8a7e14a7e129d266c" translate="yes" xml:space="preserve">
          <source>If you need to cancel a timer because of some other event, you can use &lt;code&gt;erlang:cancel_timer(Tref)&lt;/code&gt;. Note that no time-out message will arrive after this (because the timer has been explicitly canceled), unless you have already postponed one earlier (see the next section), so ensure that you do not accidentally postpone such messages. Also note that a time-out message may arrive during a &lt;strong&gt;state callback&lt;/strong&gt; that is cancelling the timer, so you may have to read out such a message from the process mailbox, depending on the return value from &lt;code&gt;erlang:cancel_timer(Tref)&lt;/code&gt;.</source>
          <target state="translated">他のイベントのためにタイマーをキャンセルする必要がある場合は、 &lt;code&gt;erlang:cancel_timer(Tref)&lt;/code&gt; を使用できます。以前に延期していない限り（タイマーが明示的にキャンセルされているため）、この後はタイムアウトメッセージが届かないことに注意してください（次のセクションを参照）。そのようなメッセージを誤って延期しないように注意してください。また、タイマーをキャンセルしている&lt;strong&gt;状態コールバック&lt;/strong&gt;中にタイムアウトメッセージが到着する可能性があるため、 &lt;code&gt;erlang:cancel_timer(Tref)&lt;/code&gt; からの戻り値によっては、プロセスメールボックスからそのようなメッセージを読み取る必要がある場合があることにも注意してください。</target>
        </trans-unit>
        <trans-unit id="f62eb303efefa39c68fc73abc117f5184daeab26" translate="yes" xml:space="preserve">
          <source>If you need to define a new function that does garbage collection, you should give it the prefix &lt;code&gt;erts_gc_&lt;/code&gt;. If that is not possible you should update the regular expression so that it will match your new function.</source>
          <target state="translated">ガベージコレクションを行う新しい関数を定義する必要がある場合は、プレフィックス &lt;code&gt;erts_gc_&lt;/code&gt; を付ける必要があります。それが不可能な場合は、新しい関数と一致するように正規表現を更新する必要があります。</target>
        </trans-unit>
        <trans-unit id="05af26e95eb9bb5371b21575710d131d97fecf50" translate="yes" xml:space="preserve">
          <source>If you need to perform configuration operations to run your test, you can implement configuration functions in your suite. The result from a configuration function is configuration data, or &lt;code&gt;Config&lt;/code&gt;. This is a list of key-value tuples that get passed from the configuration function to the test cases (possibly through configuration functions on &quot;lower level&quot;). The data flow looks as follows:</source>
          <target state="translated">テストを実行するために構成操作を実行する必要がある場合は、スイートに構成関数を実装できます。構成関数の結果は、構成データ、つまり &lt;code&gt;Config&lt;/code&gt; です。これは、構成関数からテストケースに（おそらく「下位レベル」の構成関数を介して）渡されるKey-Valueタプルのリストです。データフローは次のようになります。</target>
        </trans-unit>
        <trans-unit id="1580293999144403cc43337470ad032b5154d650" translate="yes" xml:space="preserve">
          <source>If you need to use Erlang code that is not &lt;code&gt;&lt;a href=&quot;#Time_Warp_Safe_Code&quot;&gt;time warp safe&lt;/a&gt;&lt;/code&gt;, and you need to start the Erlang runtime system before OS system time has been corrected, you may want to use the single time warp mode.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#Time_Warp_Safe_Code&quot;&gt;time warp safe&lt;/a&gt;&lt;/code&gt; ではないErlangコードを使用する必要があり、OSシステム時刻が修正される前にErlangランタイムシステムを起動する必要がある場合は、シングルタイムワープモードを使用できます。</target>
        </trans-unit>
        <trans-unit id="0e3af53f2c07526824c69b1abdb7517239318228" translate="yes" xml:space="preserve">
          <source>If you need to use thread-specific data in an emulator thread, only have the thread-specific data set while the thread is under your control, and clear the thread-specific data before you let the thread out of your control.</source>
          <target state="translated">エミュレータのスレッドでスレッド固有のデータを使用する必要がある場合は、スレッドが自分の制御下にある間だけスレッド固有のデータセットを持ち、スレッドを自分の制御外に出す前にスレッド固有のデータをクリアしてください。</target>
        </trans-unit>
        <trans-unit id="4f32b6b35644f5b16edce6c4d78753a25d38ebfb" translate="yes" xml:space="preserve">
          <source>If you need to verify the bootstrap beam files match the provided source files, use &lt;code&gt;./otp_build update_primary&lt;/code&gt; to create a new commit that contains differences, if any exist.</source>
          <target state="translated">ブートストラップビームファイルが提供されたソースファイルと一致することを確認する必要がある場合は、。 &lt;code&gt;./otp_build update_primary&lt;/code&gt; を使用して、相違がある場合はそれを含む新しいコミットを作成します。</target>
        </trans-unit>
        <trans-unit id="a564a81cdbcd1f7df3fcca09ff995949d4ddcb79" translate="yes" xml:space="preserve">
          <source>If you or your system has special requirements please read the &lt;code&gt;Makefile&lt;/code&gt; for additional configuration information.</source>
          <target state="translated">あなたまたはあなたのシステムに特別な要件がある場合は、追加の構成情報について &lt;code&gt;Makefile&lt;/code&gt; を読んでください。</target>
        </trans-unit>
        <trans-unit id="c9741cf8a267768b2bd92351adecbc979f0aa0dd" translate="yes" xml:space="preserve">
          <source>If you plan to change code without restarting your system, you must use an external fun (&lt;code&gt;fun Module:Function/Arity&lt;/code&gt;) as function &lt;code&gt;Resolve&lt;/code&gt;. If you use a local fun, you can never replace the code for the module that the fun belongs to.</source>
          <target state="translated">システムを再起動せずにコードを変更する場合は、関数 &lt;code&gt;Resolve&lt;/code&gt; として外部fun（ &lt;code&gt;fun Module:Function/Arity&lt;/code&gt; ）を使用する必要があります。ローカルのfunを使用する場合、funが属するモジュールのコードを置き換えることはできません。</target>
        </trans-unit>
        <trans-unit id="3d19108a84a5eb3bb48cef4ccb2f6536e5feabf9" translate="yes" xml:space="preserve">
          <source>If you read back the option value using &lt;code&gt;&lt;a href=&quot;#getopts-2&quot;&gt;getopts/2&lt;/a&gt;&lt;/code&gt; and get no value, the option does not exist in the host operating system. The behavior of both an IPv6 and an IPv4 socket listening on the same port, and for an IPv6 socket getting IPv4 traffic is then no longer predictable.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#getopts-2&quot;&gt;getopts/2&lt;/a&gt;&lt;/code&gt; を使用してオプション値を読み戻しても値がない場合、そのオプションはホストオペレーティングシステムに存在しません。同じポートでリッスンするIPv6ソケットとIPv4ソケットの両方の動作、およびIPv6ソケットの場合、IPv4トラフィックを取得することは、もはや予測できなくなります。</target>
        </trans-unit>
        <trans-unit id="85b82b7060fb8d9f6ed2cb286e33072d08347f0f" translate="yes" xml:space="preserve">
          <source>If you really, really want to, you may call it &quot;Inga&quot;.</source>
          <target state="translated">どうしても、どうしてもというなら、「インガ」と呼んでもいいかもしれません。</target>
        </trans-unit>
        <trans-unit id="0ad8b8f8006dc094fc060a805431e5051049c527" translate="yes" xml:space="preserve">
          <source>If you set the &lt;code&gt;call&lt;/code&gt; trace flag, you also have to set a &lt;strong&gt;trace pattern&lt;/strong&gt; for the functions you want to trace:</source>
          <target state="translated">&lt;code&gt;call&lt;/code&gt; トレースフラグを設定する場合は、&lt;strong&gt;トレース&lt;/strong&gt;する関数の&lt;strong&gt;トレースパターン&lt;/strong&gt;も設定する必要があります。</target>
        </trans-unit>
        <trans-unit id="593fb6e309e5d0f221339df106e191b090ca84ba" translate="yes" xml:space="preserve">
          <source>If you simply want to format a paragraph of plain text, you probably want to use the &lt;code&gt;&lt;a href=&quot;#text_par-2&quot;&gt;text_par/2&lt;/a&gt;&lt;/code&gt; function, as in the following example:</source>
          <target state="translated">プレーンテキストの段落をフォーマットするだけの場合は、おそらく次の例のように、 &lt;code&gt;&lt;a href=&quot;#text_par-2&quot;&gt;text_par/2&lt;/a&gt;&lt;/code&gt; 関数を使用します。</target>
        </trans-unit>
        <trans-unit id="da6562fe0a7c0b54c043b4d0278072613df57ef3" translate="yes" xml:space="preserve">
          <source>If you start this program with &lt;code&gt;code_lock:start([17])&lt;/code&gt; you can unlock with &lt;code&gt;code_lock:down(17), code_lock:up(17).&lt;/code&gt;</source>
          <target state="translated">このプログラムを &lt;code&gt;code_lock:start([17])&lt;/code&gt; で起動すると、 &lt;code&gt;code_lock:down(17), code_lock:up(17).&lt;/code&gt; ロックを解除できます。</target>
        </trans-unit>
        <trans-unit id="cace6db1c9825fe249b9c220bf578982c6ffbbda" translate="yes" xml:space="preserve">
          <source>If you successfully parse the XML file with the validation on as in: &lt;code&gt;xmerl_scan:file('motorcycles.xml',[{validation,true}])&lt;/code&gt; you know that the XML document is valid and has the structure according to the DTD.</source>
          <target state="translated">&lt;code&gt;xmerl_scan:file('motorcycles.xml',[{validation,true}])&lt;/code&gt; の検証でXMLファイルを正常に解析できた場合、XMLドキュメントが有効であり、DTDに準拠した構造を持っていることがわかります。</target>
        </trans-unit>
        <trans-unit id="d59053b915a39ff162dae55e7504e339f09a4e42" translate="yes" xml:space="preserve">
          <source>If you try to do the same again with another city, an error is returned:</source>
          <target state="translated">別の都市で再度同じことをしようとすると、エラーが返されます。</target>
        </trans-unit>
        <trans-unit id="a798d01202205d436563f3b0bd17d64f51325641" translate="yes" xml:space="preserve">
          <source>If you try to store an object in the registry and there is an existing object with the same key, the new value replaces the old one. This is done regardless of whether the new object and the old one have the same type, so you can, for example, replace a string with an integer. If the existing value is a string or binary, it is freed before the new value is assigned.</source>
          <target state="translated">オブジェクトをレジストリに保存しようとしたときに、同じキーを持つ既存のオブジェクトが存在する場合、新しい値が古いものに置き換わります。これは、新しいオブジェクトと古いオブジェクトの型が同じであるかどうかに関係なく行われるので、例えば文字列を整数に置き換えることができます。既存の値が文字列またはバイナリの場合は、新しい値が代入される前に解放されます。</target>
        </trans-unit>
        <trans-unit id="515a151c90cdd13d9e4906d959838a101ec214d6" translate="yes" xml:space="preserve">
          <source>If you use &lt;code&gt;erl_connect_init()&lt;/code&gt;, your node will have a short name, that is, it will not be fully qualified. If you need to use fully qualified (long) names, use &lt;code&gt;erl_connect_xinit()&lt;/code&gt; instead.</source>
          <target state="translated">&lt;code&gt;erl_connect_init()&lt;/code&gt; を使用する場合、ノードには短い名前が付けられます。つまり、完全修飾されません。完全修飾（長い）名を使用する必要がある場合は、代わりに &lt;code&gt;erl_connect_xinit()&lt;/code&gt; を使用してください。</target>
        </trans-unit>
        <trans-unit id="0d834de6c7b4bcac9902d0548059107a16f86a8b" translate="yes" xml:space="preserve">
          <source>If you use &lt;code&gt;systools&lt;/code&gt;, the Erlang/OTP tools for packaging code (see &lt;code&gt;&lt;a href=&quot;release_structure&quot;&gt;Releases&lt;/a&gt;&lt;/code&gt;), the code for each application is placed in a separate directory following a pre-defined &lt;code&gt;&lt;a href=&quot;#app_dir&quot;&gt;directory structure&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">あなたが使用している場合 &lt;code&gt;systools&lt;/code&gt; （参照コードを包装するため、アーラン/ OTPツールを &lt;code&gt;&lt;a href=&quot;release_structure&quot;&gt;Releases&lt;/a&gt;&lt;/code&gt; ）、各アプリケーションのコードは、事前定義された以下の別のディレクトリに置かれている &lt;code&gt;&lt;a href=&quot;#app_dir&quot;&gt;directory structure&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8dfdc592f173581c774f93af24400d86f856a5e1" translate="yes" xml:space="preserve">
          <source>If you use an old apace-like configuration file.</source>
          <target state="translated">古いアパスのような設定ファイルを使用している場合。</target>
        </trans-unit>
        <trans-unit id="16a79b696fe4d902f78f4a9ec278a5c8cacbb001" translate="yes" xml:space="preserve">
          <source>If you use multiple CTHs, the first part of the return tuple is used as input for the next CTH. So in the previous example the next CTH can get &lt;code&gt;{fail,Reason}&lt;/code&gt; as the second parameter. If you have many CTHs interacting, do not let each CTH return &lt;code&gt;fail&lt;/code&gt; or &lt;code&gt;skip&lt;/code&gt;. Instead, return that an action is to be taken through the &lt;code&gt;Config&lt;/code&gt; list and implement a CTH that, at the end, takes the correct action.</source>
          <target state="translated">複数のCTHを使用する場合、戻りタプルの最初の部分は次のCTHの入力として使用されます。したがって、前の例では、次のCTH は2番目のパラメーターとして &lt;code&gt;{fail,Reason}&lt;/code&gt; を取得できます。多くのCTHが相互作用している場合は、各CTHリターンが &lt;code&gt;fail&lt;/code&gt; たり &lt;code&gt;skip&lt;/code&gt; したりしないでください。代わりに、 &lt;code&gt;Config&lt;/code&gt; リストを介してアクションが実行されることを返し、最後に正しいアクションを実行するCTHを実装します。</target>
        </trans-unit>
        <trans-unit id="930cef54ac87bd2c1ca6f2387bf6edcd93ce9313" translate="yes" xml:space="preserve">
          <source>If you use the &lt;code&gt;Erl_Interface&lt;/code&gt; functions in a threaded application based on POSIX threads or Solaris threads, then &lt;code&gt;Erl_Interface&lt;/code&gt; needs access to some of the synchronization facilities in your threads package. You must specify extra compiler flags to indicate which of the packages you use. Define &lt;code&gt;_REENTRANT&lt;/code&gt; and either &lt;code&gt;STHREADS&lt;/code&gt; or &lt;code&gt;PTHREADS&lt;/code&gt;. The default is to use POSIX threads if &lt;code&gt;_REENTRANT&lt;/code&gt; is specified.</source>
          <target state="translated">POSIXスレッドまたはSolarisスレッドに基づくスレッド化されたアプリケーションで &lt;code&gt;Erl_Interface&lt;/code&gt; 関数を使用する場合、 &lt;code&gt;Erl_Interface&lt;/code&gt; はスレッドパッケージ内のいくつかの同期機能にアクセスする必要があります。使用するパッケージを示すために、追加のコンパイラフラグを指定する必要があります。 &lt;code&gt;_REENTRANT&lt;/code&gt; および &lt;code&gt;STHREADS&lt;/code&gt; または &lt;code&gt;PTHREADS&lt;/code&gt; を定義します。 &lt;code&gt;_REENTRANT&lt;/code&gt; が指定されている場合、デフォルトではPOSIXスレッドが使用されます。</target>
        </trans-unit>
        <trans-unit id="918394c05671a0235e153985bd2840211574395e" translate="yes" xml:space="preserve">
          <source>If you use the &lt;code&gt;ct_run&lt;/code&gt; program, you can start the Erlang shell and &lt;code&gt;Common Test&lt;/code&gt; in one go by using the flag &lt;code&gt;-shell&lt;/code&gt; and, optionally, flag &lt;code&gt;-config&lt;/code&gt; and/or &lt;code&gt;-userconfig&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ct_run&lt;/code&gt; プログラムを使用する場合、フラグ &lt;code&gt;-shell&lt;/code&gt; およびオプションでフラグ &lt;code&gt;-config&lt;/code&gt; および/または &lt;code&gt;-userconfig&lt;/code&gt; を使用して、Erlangシェルと &lt;code&gt;Common Test&lt;/code&gt; を一度に開始できます。</target>
        </trans-unit>
        <trans-unit id="3feb64f146fe919b2a69ce546c85439b7b8b28d7" translate="yes" xml:space="preserve">
          <source>If you want an Erlang node to have a remote job active from the start (rather than the default local job), start Erlang with flag &lt;code&gt;-remsh&lt;/code&gt;, for example, &lt;code&gt;erl -remsh other_node@other_host&lt;/code&gt;</source>
          <target state="translated">Erlangノードで（デフォルトのローカルジョブではなく）最初からリモートジョブをアクティブにする場合は、フラグ &lt;code&gt;-remsh&lt;/code&gt; を使用してErlangを開始します（例： &lt;code&gt;erl -remsh other_node@other_host&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2153b220590bbe864e1f5e224d987fcb64330153" translate="yes" xml:space="preserve">
          <source>If you want an Erlang node to have a remote job active from the start (rather than the default local job), start Erlang with flag &lt;code&gt;-remsh&lt;/code&gt;, for example, &lt;code&gt;erl -sname this_node -remsh other_node@other_host&lt;/code&gt;</source>
          <target state="translated">Erlangノードに最初から（デフォルトのローカルジョブではなく）リモートジョブをアクティブにしたい場合は、フラグ &lt;code&gt;-remsh&lt;/code&gt; を使用して Erlangを開始します。例： &lt;code&gt;erl -sname this_node -remsh other_node@other_host&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="50de302c93e8bacbc69e071b7eec983f033e6a07" translate="yes" xml:space="preserve">
          <source>If you want the ability to distinguish between results, you may want to consider using the &lt;code&gt;&lt;a href=&quot;erpc#call-4&quot;&gt;erpc:call()&lt;/a&gt;&lt;/code&gt; function from the &lt;code&gt;erpc&lt;/code&gt; module instead.</source>
          <target state="translated">結果を区別する機能が必要な場合は、代わりに &lt;code&gt;erpc&lt;/code&gt; モジュールの &lt;code&gt;&lt;a href=&quot;erpc#call-4&quot;&gt;erpc:call()&lt;/a&gt;&lt;/code&gt; 関数の使用を検討することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="00e8ce10cfe9321c8cbd6786fc123b13ea0a780a" translate="yes" xml:space="preserve">
          <source>If you want the ability to distinguish between results, you may want to consider using the &lt;code&gt;&lt;a href=&quot;erpc#multicall-4&quot;&gt;erpc:multicall()&lt;/a&gt;&lt;/code&gt; function from the &lt;code&gt;erpc&lt;/code&gt; module instead.</source>
          <target state="translated">結果を区別する機能が必要な場合は、代わりに &lt;code&gt;erpc&lt;/code&gt; モジュールの &lt;code&gt;&lt;a href=&quot;erpc#multicall-4&quot;&gt;erpc:multicall()&lt;/a&gt;&lt;/code&gt; 関数の使用を検討することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="88f9444d15f637070cc1c5665eb79410298eb57c" translate="yes" xml:space="preserve">
          <source>If you want the ability to distinguish between results, you may want to consider using the &lt;code&gt;&lt;a href=&quot;erpc#send_request-4&quot;&gt;erpc:send_request()&lt;/a&gt;&lt;/code&gt; function from the &lt;code&gt;erpc&lt;/code&gt; module instead. This also gives you the ability retrieve the results in other useful ways.</source>
          <target state="translated">結果を区別する機能が必要な場合は、代わりに &lt;code&gt;erpc&lt;/code&gt; モジュールの &lt;code&gt;&lt;a href=&quot;erpc#send_request-4&quot;&gt;erpc:send_request()&lt;/a&gt;&lt;/code&gt; 関数の使用を検討することをお勧めします。これにより、他の便利な方法で結果を取得することもできます。</target>
        </trans-unit>
        <trans-unit id="a4038140d6bff952f2f9f5f48acf2d27c3f6092b" translate="yes" xml:space="preserve">
          <source>If you want the connection to be associated with &lt;code&gt;Handle&lt;/code&gt; only (if you, for example, need to open multiple connections to a host), use &lt;code&gt;Key&lt;/code&gt;, the configuration variable name, to specify the target. Notice that a connection without an associated target name can only be closed with the &lt;code&gt;Handle&lt;/code&gt; value.</source>
          <target state="translated">接続を &lt;code&gt;Handle&lt;/code&gt; のみに関連付ける場合（たとえば、ホストへの複数の接続を開く必要がある場合）は、構成変数名である &lt;code&gt;Key&lt;/code&gt; を使用してターゲットを指定します。ターゲット名が関連付けられていない接続は、 &lt;code&gt;Handle&lt;/code&gt; 値でのみ閉じることができることに注意してください。</target>
        </trans-unit>
        <trans-unit id="9c1ebb966c6523b3c1b7beffcce3bfa9b40caeb1" translate="yes" xml:space="preserve">
          <source>If you want the same format as returned by &lt;code&gt;erlang:now/0&lt;/code&gt;, use &lt;code&gt;&lt;a href=&quot;erlang#timestamp-0&quot;&gt; erlang:timestamp/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;erlang:now/0&lt;/code&gt; によって返されるものと同じ形式が必要な場合は、 &lt;code&gt;&lt;a href=&quot;erlang#timestamp-0&quot;&gt; erlang:timestamp/0&lt;/a&gt;&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="92c8c9a37ae2934ad0217ae03b7ce8edb49f913c" translate="yes" xml:space="preserve">
          <source>If you want the same format as returned by &lt;code&gt;erlang:now/0&lt;/code&gt;, use &lt;code&gt;&lt;a href=&quot;erlang#timestamp-0&quot;&gt;erlang:timestamp/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;erlang:now/0&lt;/code&gt; によって返されるものと同じフォーマットが必要な場合は、 &lt;code&gt;&lt;a href=&quot;erlang#timestamp-0&quot;&gt;erlang:timestamp/0&lt;/a&gt;&lt;/code&gt; を使用してください。</target>
        </trans-unit>
        <trans-unit id="340edf748ea085618e9e02efc24d38acd583eead" translate="yes" xml:space="preserve">
          <source>If you want to add the information about a black Harley Davidsson 1200 cc Sportster motorcycle from 2003 that is in shape as new in the motorcycles.xml document you can put the data in a simple-form data structure like:</source>
          <target state="translated">motorcycles.xmlドキュメントに、2003年製の黒いハーレー・デービッドソン1200ccスポーツスターバイクの情報を新品同様の形で追加したい場合は、以下のようなシンプルな形式のデータ構造にデータを配置することができます。</target>
        </trans-unit>
        <trans-unit id="76e13e233caef4d78d7dc7bb7c518cb87cbe184c" translate="yes" xml:space="preserve">
          <source>If you want to apply patches of multiple OTP applications that resides in different OTP versions, you have to apply these patches in multiple steps. It is only possible to apply multiple OTP applications from the same OTP version at once.</source>
          <target state="translated">異なるOTPバージョンに存在する複数のOTPアプリケーションのパッチを適用したい場合、これらのパッチを複数のステップで適用する必要があります。同じOTPバージョンの複数のOTPアプリケーションを一度に適用することができるのは</target>
        </trans-unit>
        <trans-unit id="42438cc3a906ec708300aa20929e7d2e6e66a173" translate="yes" xml:space="preserve">
          <source>If you want to build the &lt;code&gt;wx&lt;/code&gt; application, you will need to get wxWidgets-3.0 (&lt;code&gt;wxWidgets-3.0.3.tar.bz2&lt;/code&gt; from &lt;code&gt;&lt;a href=&quot;https://github.com/wxWidgets/wxWidgets/releases/download/v3.0.3/wxWidgets-3.0.3.tar.bz2&quot;&gt;https://github.com/wxWidgets/wxWidgets/releases/download/v3.0.3/wxWidgets-3.0.3.tar.bz2&lt;/a&gt;&lt;/code&gt;) or get it from github with bug fixes:</source>
          <target state="translated">&lt;code&gt;wx&lt;/code&gt; アプリケーションをビルドする場合は、wxWidgets-3.0（ &lt;code&gt;&lt;a href=&quot;https://github.com/wxWidgets/wxWidgets/releases/download/v3.0.3/wxWidgets-3.0.3.tar.bz2&quot;&gt;https://github.com/wxWidgets/wxWidgets/releases/download/v3.0.3/wxWidgets-3.0.3.tar.bz2&lt;/a&gt;&lt;/code&gt; から &lt;code&gt;wxWidgets-3.0.3.tar.bz2&lt;/code&gt; を入手する必要があります。 3.0.3.tar.bz2）またはgithubからバグを修正して入手：</target>
        </trans-unit>
        <trans-unit id="60d473a6aa433acfb9c1c6ca737fe13eaf0848c9" translate="yes" xml:space="preserve">
          <source>If you want to build using a compatible Erlang/OTP system in the &lt;code&gt;$PATH&lt;/code&gt;, jump to (3).</source>
          <target state="translated">&lt;code&gt;$PATH&lt;/code&gt; で互換性のあるErlang / OTPシステムを使用してビルドする場合は、（3）にジャンプします。</target>
        </trans-unit>
        <trans-unit id="eb5df9d9054fc0c4d2d1fdf02282b9d140be554d" translate="yes" xml:space="preserve">
          <source>If you want to change the file name of the implicit -file() attributes inserted during preprocessing, you can do with &lt;code&gt;{source_name, SourceName}&lt;/code&gt;. If unset it will default to the name of the opened file.</source>
          <target state="translated">前処理中に挿入された暗黙の-file（）属性のファイル名を変更する場合は、 &lt;code&gt;{source_name, SourceName}&lt;/code&gt; を使用できます。設定を解除すると、デフォルトで開いているファイルの名前になります。</target>
        </trans-unit>
        <trans-unit id="c541b95485f056deb59b7660fe1bc3263ea0c2c7" translate="yes" xml:space="preserve">
          <source>If you want to copy a library (an application) newly built, to a release area, you do like with the emulator:</source>
          <target state="translated">新しくビルドしたライブラリ(アプリケーション)をリリースエリアにコピーしたい場合は、エミュレータと同様に行います。</target>
        </trans-unit>
        <trans-unit id="478802cbe47a5a6b031caf1a058324304adf72a9" translate="yes" xml:space="preserve">
          <source>If you want to do structured logging, but still want to have some control of how the final log message is formatted you can give a &lt;code&gt;report_cb&lt;/code&gt; as part of the metadata with your log event.</source>
          <target state="translated">構造化ロギングを実行したいが、最終的なログメッセージのフォーマット方法をある程度制御したい場合は、ログイベントのメタデータの一部として &lt;code&gt;report_cb&lt;/code&gt; を指定できます。</target>
        </trans-unit>
        <trans-unit id="af39ab464f4c4ad6184b7312f8ff3491ab00be0a" translate="yes" xml:space="preserve">
          <source>If you want to force a matching failure at some point in a pattern, the most convenient way to do it is with (?!), as an empty string always matches. So, an assertion that requires there is not to be an empty string must always fail. The backtracking control verb (*FAIL) or (*F) is a synonym for (?!).</source>
          <target state="translated">パターンのどこかの時点でマッチングの失敗を強制したい場合、空の文字列は常にマッチングするので、それを行う最も便利な方法は (?!)です。つまり、空文字列が存在しないことを要求するアサーションは常に失敗しなければなりません。バックトラッキング制御動詞(*fail)や(*f)は、(?!)の同義語です。</target>
        </trans-unit>
        <trans-unit id="b53c1301abde2142a7a519277a4e352002bba7dc" translate="yes" xml:space="preserve">
          <source>If you want to ignore a particular event in the current state and handle it in a future state, you can postpone the event. A postponed event is retried after a &lt;strong&gt;state change&lt;/strong&gt;, that is, &lt;code&gt;OldState =/= NewState&lt;/code&gt;.</source>
          <target state="translated">現在の状態で特定のイベントを無視し、将来の状態でそれを処理する場合は、イベントを延期できます。延期されたイベントは、&lt;strong&gt;状態の変更&lt;/strong&gt;後、つまり &lt;code&gt;OldState =/= NewState&lt;/code&gt; 後に再試行されます。</target>
        </trans-unit>
        <trans-unit id="1d95e36a6d42c79b8d9f3cbb7ca6b72d1dfb12b0" translate="yes" xml:space="preserve">
          <source>If you want to ignore a particular event in the current state and handle it in a future state, you can postpone the event. A postponed event is retried after the state has changed, that is, &lt;code&gt;OldState =/= NewState&lt;/code&gt;.</source>
          <target state="translated">現在の状態の特定のイベントを無視し、将来の状態で処理する場合は、イベントを延期できます。状態が変更された後、延期されたイベントが再試行されます。つまり、 &lt;code&gt;OldState =/= NewState&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="9b637ab1ccef72c8ef19f9dd28f47f58deee1a99" translate="yes" xml:space="preserve">
          <source>If you want to limit the size of the trace logs, you can use wrap logs. This works almost like a circular buffer. You can specify the maximum number of binary logs and the maximum size of each log. &lt;code&gt;ttb&lt;/code&gt; then creates a new binary log each time a log reaches the maximum size. When the maximum number of logs are reached, the oldest log is deleted before a new one is created.</source>
          <target state="translated">トレースログのサイズを制限する場合は、ラップログを使用できます。これは、循環バッファのように機能します。バイナリログの最大数と各ログの最大サイズを指定できます。 &lt;code&gt;ttb&lt;/code&gt; は、ログが最大サイズに達するたびに新しいバイナリログを作成します。ログの最大数に達すると、新しいログが作成される前に最も古いログが削除されます。</target>
        </trans-unit>
        <trans-unit id="3ba20665ef257abe2a78ab66aec5b8422b06c770" translate="yes" xml:space="preserve">
          <source>If you want to match typical palindromic phrases, the pattern must ignore all non-word characters, which can be done as follows:</source>
          <target state="translated">典型的な回文フレーズにマッチさせたい場合は、パターンはすべての単語以外の文字を無視しなければならないので、以下のようにすることができます。</target>
        </trans-unit>
        <trans-unit id="ecc0e9164bc34f28d81e7ffb4afcab4e5c0c14b8" translate="yes" xml:space="preserve">
          <source>If you want to only print run-time per thread type you can do:</source>
          <target state="translated">スレッドタイプごとのランタイムのみを表示したい場合は、以下のようにします。</target>
        </trans-unit>
        <trans-unit id="be41c980691226fb7b2d6a9c0782adc2d56de58a" translate="yes" xml:space="preserve">
          <source>If you want to output the content of an XML element or an attribute you will get the value as a string by the &lt;code&gt;value_of&lt;/code&gt; function:</source>
          <target state="translated">XML要素または属性のコンテンツを出力する場合は、 &lt;code&gt;value_of&lt;/code&gt; 関数によって値を文字列として取得します。</target>
        </trans-unit>
        <trans-unit id="e7aef053601a6ea882918cfebb175091d4d52943" translate="yes" xml:space="preserve">
          <source>If you want to parse the XML file motorcycles.xml you run it in the Erlang shell like:</source>
          <target state="translated">XMLファイルのmotorcycles.xmlをパースしたい場合は、Erlangシェルで以下のように実行します。</target>
        </trans-unit>
        <trans-unit id="6e509b56bd064c6196e8412d4a6710ea854feb39" translate="yes" xml:space="preserve">
          <source>If you want to pass a binary and do not already have the content of the binary in an &lt;code&gt;ErlDrvBinary&lt;/code&gt;, you can benefit from using &lt;code&gt;ERL_DRV_BUF2BINARY&lt;/code&gt; instead of creating an &lt;code&gt;ErlDrvBinary&lt;/code&gt; through &lt;code&gt;&lt;a href=&quot;#driver_alloc_binary&quot;&gt; driver_alloc_binary&lt;/a&gt;&lt;/code&gt; and then pass the binary through &lt;code&gt;ERL_DRV_BINARY&lt;/code&gt;. The runtime system often allocates binaries smarter if &lt;code&gt;ERL_DRV_BUF2BINARY&lt;/code&gt; is used. However, if the content of the binary to pass already resides in an &lt;code&gt;ErlDrvBinary&lt;/code&gt;, it is normally better to pass the binary using &lt;code&gt;ERL_DRV_BINARY&lt;/code&gt; and the &lt;code&gt;ErlDrvBinary&lt;/code&gt; in question.</source>
          <target state="translated">あなたがバイナリを渡したいとすでにバイナリの内容がない場合は &lt;code&gt;ErlDrvBinary&lt;/code&gt; を、あなたが使用して恩恵を受けることができ &lt;code&gt;ERL_DRV_BUF2BINARY&lt;/code&gt; を代わりに作成 &lt;code&gt;ErlDrvBinary&lt;/code&gt; を通過 &lt;code&gt;&lt;a href=&quot;#driver_alloc_binary&quot;&gt; driver_alloc_binary&lt;/a&gt;&lt;/code&gt; 、その後を通じてバイナリを渡す &lt;code&gt;ERL_DRV_BINARY&lt;/code&gt; 。 &lt;code&gt;ERL_DRV_BUF2BINARY&lt;/code&gt; が使用されている場合、ランタイムシステムはバイナリをよりスマートに割り当てることがよくあります。ただし、渡すバイナリのコンテンツがすでに &lt;code&gt;ErlDrvBinary&lt;/code&gt; にある場合は、通常、 &lt;code&gt;ErlDrvBinary&lt;/code&gt; と問題のErlDrvBinaryを使用してバイナリを渡すことを &lt;code&gt;ERL_DRV_BINARY&lt;/code&gt; 勧めします。</target>
        </trans-unit>
        <trans-unit id="c0f0b294d62ab97983874294bfe640932bf22f5a" translate="yes" xml:space="preserve">
          <source>If you want to pass a binary and do not already have the content of the binary in an &lt;code&gt;ErlDrvBinary&lt;/code&gt;, you can benefit from using &lt;code&gt;ERL_DRV_BUF2BINARY&lt;/code&gt; instead of creating an &lt;code&gt;ErlDrvBinary&lt;/code&gt; through &lt;code&gt;&lt;a href=&quot;#driver_alloc_binary&quot;&gt;driver_alloc_binary&lt;/a&gt;&lt;/code&gt; and then pass the binary through &lt;code&gt;ERL_DRV_BINARY&lt;/code&gt;. The runtime system often allocates binaries smarter if &lt;code&gt;ERL_DRV_BUF2BINARY&lt;/code&gt; is used. However, if the content of the binary to pass already resides in an &lt;code&gt;ErlDrvBinary&lt;/code&gt;, it is normally better to pass the binary using &lt;code&gt;ERL_DRV_BINARY&lt;/code&gt; and the &lt;code&gt;ErlDrvBinary&lt;/code&gt; in question.</source>
          <target state="translated">あなたがバイナリを渡したいとすでにバイナリの内容がない場合は &lt;code&gt;ErlDrvBinary&lt;/code&gt; を、あなたが使用して恩恵を受けることができ &lt;code&gt;ERL_DRV_BUF2BINARY&lt;/code&gt; を代わりに作成 &lt;code&gt;ErlDrvBinary&lt;/code&gt; を通過 &lt;code&gt;&lt;a href=&quot;#driver_alloc_binary&quot;&gt;driver_alloc_binary&lt;/a&gt;&lt;/code&gt; 、その後を通じてバイナリを渡す &lt;code&gt;ERL_DRV_BINARY&lt;/code&gt; 。 &lt;code&gt;ERL_DRV_BUF2BINARY&lt;/code&gt; が使用されている場合、ランタイムシステムは多くの場合、バイナリをよりスマートに割り当てます。ただし、渡すバイナリのコンテンツがすでに &lt;code&gt;ErlDrvBinary&lt;/code&gt; にある場合は、通常、 &lt;code&gt;ErlDrvBinary&lt;/code&gt; と問題のErlDrvBinaryを使用してバイナリを渡すことを &lt;code&gt;ERL_DRV_BINARY&lt;/code&gt; 勧めします。</target>
        </trans-unit>
        <trans-unit id="480d25bad4b8ee292973eb9f4a96b57aec47c435" translate="yes" xml:space="preserve">
          <source>If you want to separate your test code from your normal code (at least for testing the exported functions), you can simply write the test functions in a module named &lt;code&gt;m_tests&lt;/code&gt; (note: not &lt;code&gt;m_test&lt;/code&gt;), if your module is named &lt;code&gt;m&lt;/code&gt;. Then, whenever you ask EUnit to test the module &lt;code&gt;m&lt;/code&gt;, it will also look for the module &lt;code&gt;m_tests&lt;/code&gt; and run those tests as well. See &lt;code&gt;ModuleName&lt;/code&gt; in the section &lt;code&gt;&lt;a href=&quot;#Primitives&quot;&gt;Primitives&lt;/a&gt;&lt;/code&gt; for details.</source>
          <target state="translated">テストコードを通常のコードから分離したい場合（少なくともエクスポートされた関数をテストする場合）、モジュールの名前が &lt;code&gt;m&lt;/code&gt; の場合、テスト関数を &lt;code&gt;m_tests&lt;/code&gt; （注： &lt;code&gt;m_test&lt;/code&gt; ではない）という名前のモジュールに書き込むだけです。その後、EUnitにモジュール &lt;code&gt;m&lt;/code&gt; をテストするように依頼すると、モジュール &lt;code&gt;m_tests&lt;/code&gt; も検索され、それらのテストも実行されます。詳細については、セクション &lt;code&gt;&lt;a href=&quot;#Primitives&quot;&gt;Primitives&lt;/a&gt;&lt;/code&gt; &lt;code&gt;ModuleName&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="7febab41e67d722699474affa70aca83861a7f64" translate="yes" xml:space="preserve">
          <source>If you want to tailor your Erlang/OTP build and installation, please read on for detailed information about the individual steps.</source>
          <target state="translated">Erlang/OTPのビルドとインストールをカスタマイズしたい場合は、それぞれのステップについての詳細な情報を読んでください。</target>
        </trans-unit>
        <trans-unit id="5c51074011b9826995f35f468d11eff897ad5c37" translate="yes" xml:space="preserve">
          <source>If you want to trace function calls (that is, if you have trace flag &lt;code&gt;call&lt;/code&gt; set on any process), you must also set trace patterns on the required function(s) with &lt;code&gt;&lt;a href=&quot;ttb#-0&quot;&gt;ttb:tp/2,3,4&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;ttb#-0&quot;&gt;ttb:tpl/2,3,4&lt;/a&gt;&lt;/code&gt;. A function is only traced if it has a trace pattern. The trace pattern specifies how to trace the function by using match specifications. Match specifications are described in the &lt;code&gt;ERTS User's Guide&lt;/code&gt;.</source>
          <target state="translated">関数呼び出しをトレースする場合（つまり、プロセスにトレースフラグ &lt;code&gt;call&lt;/code&gt; 設定されている場合）、 &lt;code&gt;&lt;a href=&quot;ttb#-0&quot;&gt;ttb:tp/2,3,4&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;ttb#-0&quot;&gt;ttb:tpl/2,3,4&lt;/a&gt;&lt;/code&gt; して、必要な関数にトレースパターンを設定する必要があります。 / 2,3,4。関数は、トレースパターンがある場合にのみトレースされます。トレースパターンは、一致指定を使用して関数をトレースする方法を指定します。一致の仕様については、 &lt;code&gt;ERTS User's Guide&lt;/code&gt; 記載されています。</target>
        </trans-unit>
        <trans-unit id="c40a044ef678327852ece515ee5ae9954050c2e8" translate="yes" xml:space="preserve">
          <source>If you want to trace function calls (that is, if you have trace flag &lt;code&gt;call&lt;/code&gt; set on any process), you must also set trace patterns on the required function(s) with &lt;code&gt;&lt;a href=&quot;ttb#tp-2&quot;&gt;ttb:tp/2,3,4&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;ttb#tpl-2&quot;&gt;ttb:tpl/2,3,4&lt;/a&gt;&lt;/code&gt;. A function is only traced if it has a trace pattern. The trace pattern specifies how to trace the function by using match specifications. Match specifications are described in the &lt;code&gt;ERTS User's Guide&lt;/code&gt;.</source>
          <target state="translated">関数呼び出しをトレースする場合（つまり、いずれかのプロセスにトレースフラグ &lt;code&gt;call&lt;/code&gt; 設定している場合）、 &lt;code&gt;&lt;a href=&quot;ttb#tp-2&quot;&gt;ttb:tp/2,3,4&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;ttb#tpl-2&quot;&gt;ttb:tpl/2,3,4&lt;/a&gt;&lt;/code&gt; して必要な関数にトレースパターンを設定する必要もあります。 / 2,3,4。関数は、トレースパターンがある場合にのみトレースされます。トレースパターンは、一致仕様を使用して関数をトレースする方法を指定します。一致仕様は、 &lt;code&gt;ERTS User's Guide&lt;/code&gt; 記載されています。</target>
        </trans-unit>
        <trans-unit id="4204e5cb6bf67f77002e41cae41377b945558f43" translate="yes" xml:space="preserve">
          <source>If you want your systems logs to be printed to a file instead, you must configure the default handler to do so. The simplest way is to include the following in your &lt;code&gt;&lt;a href=&quot;config&quot;&gt;sys.config&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">代わりに、システムログをファイルに出力する場合は、デフォルトのハンドラーを構成してそのようにする必要があります。最も簡単な方法は、以下を &lt;code&gt;&lt;a href=&quot;config&quot;&gt;sys.config&lt;/a&gt;&lt;/code&gt; に含めることです。</target>
        </trans-unit>
        <trans-unit id="bc1242f30c23d446d1188a6ac120aa5dbc4659e1" translate="yes" xml:space="preserve">
          <source>If you wish to exit the interactive mode (for example, to start an automated test run with &lt;code&gt;&lt;a href=&quot;ct#run_test-1&quot;&gt;ct:run_test/1&lt;/a&gt;&lt;/code&gt;), call function &lt;code&gt;&lt;a href=&quot;ct#stop_interactive-0&quot;&gt;ct:stop_interactive/0&lt;/a&gt;&lt;/code&gt;. This shuts down the running &lt;code&gt;ct&lt;/code&gt; application. Associations between configuration names and data created with &lt;code&gt;require&lt;/code&gt; are consequently deleted. Function &lt;code&gt;&lt;a href=&quot;ct#start_interactive-0&quot;&gt;ct:start_interactive/0&lt;/a&gt;&lt;/code&gt; takes you back into interactive mode, but the previous state is not restored.</source>
          <target state="translated">対話モードを終了する場合（たとえば、 &lt;code&gt;&lt;a href=&quot;ct#run_test-1&quot;&gt;ct:run_test/1&lt;/a&gt;&lt;/code&gt; を使用して自動テスト実行を開始する場合）、関数 &lt;code&gt;&lt;a href=&quot;ct#stop_interactive-0&quot;&gt;ct:stop_interactive/0&lt;/a&gt;&lt;/code&gt; を呼び出します。これにより、実行中の &lt;code&gt;ct&lt;/code&gt; アプリケーションがシャットダウンします。したがって、構成名と &lt;code&gt;require&lt;/code&gt; で作成されたデータとの関連付けは削除されます。関数 &lt;code&gt;&lt;a href=&quot;ct#start_interactive-0&quot;&gt;ct:start_interactive/0&lt;/a&gt;&lt;/code&gt; はインタラクティブモードに戻りますが、以前の状態は復元されません。</target>
        </trans-unit>
        <trans-unit id="e10f84ca92ffa048cba38c4e906ca1f626ae3a34" translate="yes" xml:space="preserve">
          <source>If you wish to store an arbitrary pointer in the registry, specify a &lt;code&gt;size&lt;/code&gt; of &lt;code&gt;0&lt;/code&gt;. In this case, the object itself is not transferred by an &lt;code&gt;ei_reg_dump()&lt;/code&gt; operation, only the pointer value.</source>
          <target state="translated">あなたは、レジストリ内の任意のポインタを保存したい場合は、指定した &lt;code&gt;size&lt;/code&gt; の &lt;code&gt;0&lt;/code&gt; を。この場合、オブジェクト自体は &lt;code&gt;ei_reg_dump()&lt;/code&gt; 操作では転送されず、ポインター値のみが転送されます。</target>
        </trans-unit>
        <trans-unit id="ebce7ca5b1598f3fc834609ac79ed9ef57b76a9b" translate="yes" xml:space="preserve">
          <source>If you're unable to produce back-ticks on your keyboard, you can use the ksh variant:</source>
          <target state="translated">キーボードでバックスティックが出せない場合は、kshバリアントを使うといいでしょう。</target>
        </trans-unit>
        <trans-unit id="898016192f939b5abb6e665e68d4a556cad78625" translate="yes" xml:space="preserve">
          <source>If you're using MinGW's MSYS instead, you need to change the &lt;code&gt;C_DRV&lt;/code&gt; setting, which would read:</source>
          <target state="translated">代わりにMinGWのMSYSを使用している場合は、 &lt;code&gt;C_DRV&lt;/code&gt; 設定を変更する必要があります。</target>
        </trans-unit>
        <trans-unit id="b80191fd2f2a93c0231ee04e580f333dbbc4b2c1" translate="yes" xml:space="preserve">
          <source>If you've upgraded the source with a patch you may need to clean up from previous builds before the new build. Make sure to read the &lt;code&gt;&lt;a href=&quot;#Advanced-configuration-and-build-of-ErlangOTP_Building_Prebuilt-Source-Release&quot;&gt;Pre-built Source Release&lt;/a&gt;&lt;/code&gt; section below before doing a &lt;code&gt;make clean&lt;/code&gt;.</source>
          <target state="translated">パッチでソースをアップグレードした場合、新しいビルドの前に以前のビルドからクリーンアップする必要があるかもしれません。 &lt;code&gt;make clean&lt;/code&gt; を実行する前に、以下の &lt;code&gt;&lt;a href=&quot;#Advanced-configuration-and-build-of-ErlangOTP_Building_Prebuilt-Source-Release&quot;&gt;Pre-built Source Release&lt;/a&gt;&lt;/code&gt; セクションを必ずお読みください。</target>
        </trans-unit>
        <trans-unit id="94d3d2824c70cd2f197cb4a4e891f6adbf0d6555" translate="yes" xml:space="preserve">
          <source>If your application has multiple levels of supervision, then do not simply set the restart intensities to the same values on all levels. Keep in mind that the total number of restarts (before the top level supervisor gives up and terminates the application) will be the product of the intensity values of all the supervisors above the failing child process.</source>
          <target state="translated">アプリケーションに複数のレベルの監督者がいる場合、単純にすべてのレベルで再起動の強度を同じ値に設定しないでください。再起動の合計数(トップレベルの監督者があきらめてアプリケーションを終了するまでの)は、失敗した子プロセスの上にいるすべての監督者の強度値の積になることを覚えておいてください。</target>
        </trans-unit>
        <trans-unit id="8bdaa0464a895b83db580413a1dfb239d0cea7a3" translate="yes" xml:space="preserve">
          <source>If your driver supports scrollable cursors you have a little more freedom, and can do things like this.</source>
          <target state="translated">ドライバがスクロール可能なカーソルをサポートしている場合は、もう少し自由度が高くなり、次のようなことができます。</target>
        </trans-unit>
        <trans-unit id="d4baf8bf70284fc593a0f0c3da52f4c0847c8447" translate="yes" xml:space="preserve">
          <source>If your process logic is convenient to describe as a state machine, and you want any of these &lt;code&gt;gen_statem&lt;/code&gt; key features:</source>
          <target state="translated">プロセスロジックがステートマシンとして説明するのに便利で、これらの &lt;code&gt;gen_statem&lt;/code&gt; の主要機能のいずれかが必要な場合：</target>
        </trans-unit>
        <trans-unit id="3a769c81046d5475e30518ad57d42d8c20c63372" translate="yes" xml:space="preserve">
          <source>If your test code writes to the standard output, you may be surprised to see that the text does not appear on the console when the tests are running. This is because EUnit captures all standard output from test functions (this also includes setup and cleanup functions, but not generator functions), so that it can be included in the test report if errors occur. To bypass EUnit and print text directly to the console while testing, you can write to the &lt;code&gt;user&lt;/code&gt; output stream, as in &lt;code&gt;io:format(user, &quot;~w&quot;, [Term])&lt;/code&gt;. The recommended way of doing this is to use the EUnit &lt;code&gt;&lt;a href=&quot;#Debugging_macros&quot;&gt;Debugging macros&lt;/a&gt;&lt;/code&gt;, which make it much simpler.</source>
          <target state="translated">テストコードが標準出力に書き込む場合、テストの実行時にコンソールにテキストが表示されないことに驚くかもしれません。これは、EUnitがテスト関数からすべての標準出力をキャプチャするためです（これには、セットアップ関数とクリーンアップ関数も含まれますが、ジェネレーター関数は含まれません）。これにより、エラーが発生した場合にテストレポートに含めることができます。テスト中にEUnitをバイパスしてテキストをコンソールに直接出力するには、 &lt;code&gt;io:format(user, &quot;~w&quot;, [Term])&lt;/code&gt; 〜w &quot;、[Term]）のように、 &lt;code&gt;user&lt;/code&gt; 出力ストリームに書き込みます。これを行うための推奨される方法は、EUnit &lt;code&gt;&lt;a href=&quot;#Debugging_macros&quot;&gt;Debugging macros&lt;/a&gt;&lt;/code&gt; を使用することです。</target>
        </trans-unit>
        <trans-unit id="7e46e774253b8a01c9e57b4a236314fe7c6f0933" translate="yes" xml:space="preserve">
          <source>If, for example, only information originating from the UNIX kernel is to be supervised, the line is to begin with &lt;code&gt;kern.LEVEL&lt;/code&gt;. For the possible values of &lt;code&gt;LEVEL&lt;/code&gt;, see &lt;code&gt;syslog.conf(5)&lt;/code&gt;.</source>
          <target state="translated">たとえば、UNIXカーネルからの情報のみを監視する場合、行は &lt;code&gt;kern.LEVEL&lt;/code&gt; で始まります。 &lt;code&gt;LEVEL&lt;/code&gt; の可能な値については、 &lt;code&gt;syslog.conf(5)&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="d5e15af770ad74c816f0b9bed18089dc4b7b6949" translate="yes" xml:space="preserve">
          <source>If, however, the more brutal variant is preferred, the the release upgrade file can be handwritten using only the single upgrade instruction &lt;code&gt;restart_emulator&lt;/code&gt;. This instruction, in contrast to &lt;code&gt;restart_new_emulator&lt;/code&gt;, causes the emulator to restart with the new versions of &lt;strong&gt;all&lt;/strong&gt; applications.</source>
          <target state="translated">ただし、より残忍なバリエーションが望ましい場合、リリースアップグレードファイルは、単一のアップグレード命令 &lt;code&gt;restart_emulator&lt;/code&gt; のみを使用して手書きできます。この命令は、 &lt;code&gt;restart_new_emulator&lt;/code&gt; とは対照的に、&lt;strong&gt;すべての&lt;/strong&gt;アプリケーションの新しいバージョンでエミュレータを再起動します。</target>
        </trans-unit>
        <trans-unit id="8767a6609841ad161f8c8ba70fce614ffbb6d735" translate="yes" xml:space="preserve">
          <source>If, however, the profiling time is short, and the host machine OS does not support high resolution cpu time measurements, some few OS schedulings may show up as ridiculously long execution times for functions doing practically nothing. An example of a function more or less just composing a tuple in about 100 times the normal execution time has been seen, and when the tracing was repeated, the execution time became normal.</source>
          <target state="translated">しかし、プロファイリング時間が短く、ホストマシンのOSが高解像度のCPU時間測定をサポートしていない場合、いくつかのOSのスケジューリングでは、実質的に何もしていない関数の実行時間がとんでもなく長くなることがあります。多かれ少なかれタプルを合成するだけの関数が、通常の実行時間の100倍程度の時間で実行され、トレースを繰り返すと実行時間が正常になった例が見られます。</target>
        </trans-unit>
        <trans-unit id="59b8380df4e4f344feb44d33018af07ce17468c9" translate="yes" xml:space="preserve">
          <source>Ifopts :: &lt;code&gt;&lt;a href=&quot;#type-getifaddrs_ifopts&quot;&gt;getifaddrs_ifopts()&lt;/a&gt;&lt;/code&gt;}]} |</source>
          <target state="translated">Ifopts :: &lt;code&gt;&lt;a href=&quot;#type-getifaddrs_ifopts&quot;&gt;getifaddrs_ifopts()&lt;/a&gt;&lt;/code&gt;}]} |</target>
        </trans-unit>
        <trans-unit id="28ab139e8caa6336e1a75280870aaa88d194b8f0" translate="yes" xml:space="preserve">
          <source>Ignores the next term.</source>
          <target state="translated">次期は無視。</target>
        </trans-unit>
        <trans-unit id="556c1293becdd2112a2dbef3ccdc8818c38e5526" translate="yes" xml:space="preserve">
          <source>Igor will look for terms &lt;code&gt;{igor, List}&lt;/code&gt; in the compile options, where &lt;code&gt;List&lt;/code&gt; is a list of Igor-specific options, as follows:</source>
          <target state="translated">Igorは、コンパイルオプションで用語 &lt;code&gt;{igor, List}&lt;/code&gt; を検索します。ここで、 &lt;code&gt;List&lt;/code&gt; は次のようにIgor固有のオプションのリストです。</target>
        </trans-unit>
        <trans-unit id="12b0ac37014df125334c7cd0aa5d1e3fd4b2112b" translate="yes" xml:space="preserve">
          <source>Igor: the Module Merger and Renamer.</source>
          <target state="translated">イゴール:モジュールの合併とリナマー。</target>
        </trans-unit>
        <trans-unit id="434e93d1be37385e2cb586a90949b6d54ba9fb45" translate="yes" xml:space="preserve">
          <source>Illegal record use</source>
          <target state="translated">違法な記録の使用</target>
        </trans-unit>
        <trans-unit id="3e2e754eaf99ea7ee3f9e02b703f2ea22dce19f1" translate="yes" xml:space="preserve">
          <source>Imagine two nodes, &lt;code&gt;A&lt;/code&gt; that initiates the handshake and &lt;code&gt;B&lt;/code&gt; that accepts the connection.</source>
          <target state="translated">2つのノードを想像してください &lt;code&gt;A&lt;/code&gt; はハンドシェイクを開始し、 &lt;code&gt;B&lt;/code&gt; は接続を受け入れます。</target>
        </trans-unit>
        <trans-unit id="8170de3694759bfa15c0e42d75a0e2dbd2eae04c" translate="yes" xml:space="preserve">
          <source>Immediately after &lt;code&gt;{addr,_}&lt;/code&gt; follows &lt;code&gt;{netmask,_}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;{addr,_}&lt;/code&gt; 直後に{ &lt;code&gt;{netmask,_}&lt;/code&gt; 続きます。</target>
        </trans-unit>
        <trans-unit id="e1bf55aaa279dcec7c69afe67e49a23edfac3d7b" translate="yes" xml:space="preserve">
          <source>Immediately closes a socket in one or two directions.</source>
          <target state="translated">ソケットを一方向または二方向に即座に閉じます。</target>
        </trans-unit>
        <trans-unit id="0146e3e7271e73fd4397519ed5ac080aa4266f79" translate="yes" xml:space="preserve">
          <source>Immediately thereafter follows &lt;code&gt;{broadaddr,_}&lt;/code&gt; if flag &lt;code&gt;broadcast&lt;/code&gt; is &lt;strong&gt;not&lt;/strong&gt; set and flag &lt;code&gt;pointtopoint&lt;/code&gt;&lt;strong&gt;is&lt;/strong&gt; set.</source>
          <target state="translated">フラグ &lt;code&gt;broadcast&lt;/code&gt; が設定されて&lt;strong&gt;おらず&lt;/strong&gt;、 &lt;code&gt;pointtopoint&lt;/code&gt; フラグ&lt;strong&gt;が&lt;/strong&gt;設定されている場合 &lt;code&gt;{broadaddr,_}&lt;/code&gt; その直後に{broadaddr、_}が続きます。&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cb29b93b7dda93ac46a90e113b640a73b1abac2b" translate="yes" xml:space="preserve">
          <source>Immediately thereafter may &lt;code&gt;{broadaddr,_}&lt;/code&gt; follow if &lt;code&gt;broadcast&lt;/code&gt; is member of &lt;code&gt;Flags&lt;/code&gt;, or &lt;code&gt;{dstaddr,_}&lt;/code&gt; if &lt;code&gt;pointtopoint&lt;/code&gt; is member of &lt;code&gt;Flags&lt;/code&gt;. Both &lt;code&gt;{dstaddr,_}&lt;/code&gt; and &lt;code&gt;{broadaddr,_}&lt;/code&gt; does not occur for the same &lt;code&gt;{addr,_}&lt;/code&gt;.</source>
          <target state="translated">直後できる &lt;code&gt;{broadaddr,_}&lt;/code&gt; 場合従う &lt;code&gt;broadcast&lt;/code&gt; のメンバーである &lt;code&gt;Flags&lt;/code&gt; 、または &lt;code&gt;{dstaddr,_}&lt;/code&gt; 場合に &lt;code&gt;pointtopoint&lt;/code&gt; のメンバーである &lt;code&gt;Flags&lt;/code&gt; 。両方 &lt;code&gt;{dstaddr,_}&lt;/code&gt; と &lt;code&gt;{broadaddr,_}&lt;/code&gt; 同じのために発生しない &lt;code&gt;{addr,_}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f115c5f2dd3a1366bda08a49baad63fd02afde98" translate="yes" xml:space="preserve">
          <source>Imperial_Aramaic</source>
          <target state="translated">Imperial_Aramaic</target>
        </trans-unit>
        <trans-unit id="bc83afa84755c20a6573a25450865f22d16b7af9" translate="yes" xml:space="preserve">
          <source>Implement a User-Specific Handler</source>
          <target state="translated">ユーザー固有のハンドラを実装する</target>
        </trans-unit>
        <trans-unit id="3848d63613aeeb25bb34384b1787a4b8da6d6ff9" translate="yes" xml:space="preserve">
          <source>Implement an &lt;code&gt;outputv&lt;/code&gt; callback (instead of an &lt;code&gt;output&lt;/code&gt; callback) in the driver. If a driver has an &lt;code&gt;outputv&lt;/code&gt; callback, refc binaries passed in an iolist in the &lt;code&gt;Data&lt;/code&gt; argument for &lt;code&gt;port_command/2&lt;/code&gt; will be passed as references to the driver.</source>
          <target state="translated">ドライバーに（ &lt;code&gt;output&lt;/code&gt; コールバックの代わりに） &lt;code&gt;outputv&lt;/code&gt; コールバックを実装します。ドライバーに &lt;code&gt;outputv&lt;/code&gt; コールバックがある場合、iolistで &lt;code&gt;port_command/2&lt;/code&gt; の &lt;code&gt;Data&lt;/code&gt; 引数に渡されるrefcバイナリーは、ドライバーへの参照として渡されます。</target>
        </trans-unit>
        <trans-unit id="2550fab1130c47b29d0bf324dcd951c87cbd4c20" translate="yes" xml:space="preserve">
          <source>Implement the user(s).</source>
          <target state="translated">ユーザー(複数)を実装する。</target>
        </trans-unit>
        <trans-unit id="48c5877ca241f34b3f104510084da2e3f17d9449" translate="yes" xml:space="preserve">
          <source>Implementation: A balanced binary search tree is used. The time complexity is proportional to log N, where N is the number of free blocks.</source>
          <target state="translated">実装。バランス二値探索木が使用される。時間の複雑さはlog Nに比例し、ここでNはフリーブロックの数である。</target>
        </trans-unit>
        <trans-unit id="986bf772c885393163838b577762f2d1f9c7f455" translate="yes" xml:space="preserve">
          <source>Implementation: A balanced binary search tree is used. The time complexity is proportional to log N, where N is the number of sizes of free blocks.</source>
          <target state="translated">実装。バランス二値探索木が使用される。時間の複雑さはlog Nに比例し、ここでNはフリーブロックのサイズの数である。</target>
        </trans-unit>
        <trans-unit id="bd869e893b5f7a40f0a166908e0bc628120afba1" translate="yes" xml:space="preserve">
          <source>Implementation: Balanced binary search trees are used. The time complexity is proportional to log N, where N is the number of free blocks.</source>
          <target state="translated">実装。バランスのとれたバイナリ探索木が使用される。時間の複雑さはlog Nに比例し、ここでNはフリーブロックの数である。</target>
        </trans-unit>
        <trans-unit id="46bfb88bf9e53e73f8388ee9ed0d26c11b02304f" translate="yes" xml:space="preserve">
          <source>Implementation: Inspect the first block in a free-list. If it satisfies the request, it is used, otherwise a new carrier is created. The implementation has a time complexity that is constant.</source>
          <target state="translated">実装。フリーリストの最初のブロックを検査する。それが要求を満たす場合はそれを使用し、そうでない場合は新しいキャリアが作成されます。実装は一定の時間的複雑さを持っています。</target>
        </trans-unit>
        <trans-unit id="c6a2194bfaf5e060ecf03c5376d35a554cce3c35" translate="yes" xml:space="preserve">
          <source>Implementation: The implementation uses segregated free lists with a maximum block search depth (in each list) to find a good fit fast. When the maximum block search depth is small (by default 3), this implementation has a time complexity that is constant. The maximum block search depth can be configured using parameter &lt;code&gt;&lt;a href=&quot;#M_mbsd&quot;&gt;mbsd&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">実装：実装では、（各リストで）最大のブロック検索深度を持つ分離されたフリーリストを使用して、適切な適合をすばやく見つけます。最大ブロック検索深度が小さい場合（デフォルトでは3）、この実装は一定の時間の複雑さを持っています。最大ブロック検索深度は、パラメーター &lt;code&gt;&lt;a href=&quot;#M_mbsd&quot;&gt;mbsd&lt;/a&gt;&lt;/code&gt; を使用して構成できます。</target>
        </trans-unit>
        <trans-unit id="8aa4a22b5053f3e953012b88774f1658cf1eb84b" translate="yes" xml:space="preserve">
          <source>Implementing a Manager Application.</source>
          <target state="translated">マネージャーアプリケーションの実装</target>
        </trans-unit>
        <trans-unit id="d1d356a99f2a68bb32f56a5afc4fc7243ac4c122" translate="yes" xml:space="preserve">
          <source>Implementing an MIB can be a tedious task. Most probably, there is a need to test the agent before all tables and variables are implemented. In this case, the default instrumentation functions are useful. The toolkit can generate default instrumentation functions for variables as well as for tables. Consequently, a running prototype agent, which can handle &lt;code&gt;set&lt;/code&gt;, &lt;code&gt;get&lt;/code&gt;, &lt;code&gt;get-next&lt;/code&gt; and table operations, is generated without any programming.</source>
          <target state="translated">MIBの実装は、面倒な作業になる場合があります。ほとんどの場合、すべてのテーブルと変数が実装される前にエージェントをテストする必要があります。この場合、デフォルトの計測機能が役立ちます。ツールキットは、変数とテーブルのデフォルトのインストルメンテーション関数を生成できます。その結果、 &lt;code&gt;set&lt;/code&gt; 、 &lt;code&gt;get&lt;/code&gt; 、 &lt;code&gt;get-next&lt;/code&gt; 、およびテーブル操作を処理できる実行中のプロトタイプエージェントが、プログラミングなしで生成されます。</target>
        </trans-unit>
        <trans-unit id="5089bf216d6ab81557737c36828f21a117ecd8d4" translate="yes" xml:space="preserve">
          <source>Implementing support for Unicode character sets is an ongoing process. The Erlang Enhancement Proposal (EEP) 10 outlined the basics of Unicode support and specified a default encoding in binaries that all Unicode-aware modules are to handle in the future.</source>
          <target state="translated">Unicode文字セットのサポートを実装することは現在進行中のプロセスです。Erlang強化提案 (EEP)10はUnicodeサポートの基本を概説し、バイナリにデフォルトのエンコーディングを指定しました。</target>
        </trans-unit>
        <trans-unit id="afb6d8666156732e31fdfd33a4e37fa8e0ff12b1" translate="yes" xml:space="preserve">
          <source>Implementing the MIB</source>
          <target state="translated">MIBの実装</target>
        </trans-unit>
        <trans-unit id="3598443bca8912627263e77be152abb2f8fea1d8" translate="yes" xml:space="preserve">
          <source>Implements &lt;strong&gt;call streams with promises&lt;/strong&gt;, a type of RPC that does not suspend the caller until the result is finished. Instead, a key is returned, which can be used later to collect the value. The key can be viewed as a promise to deliver the answer.</source>
          <target state="translated">結果が完了するまで呼び出し元を中断しないタイプのRPCであるpromiseを使用して&lt;strong&gt;呼び出しストリームを&lt;/strong&gt;実装し&lt;strong&gt;ます&lt;/strong&gt;。代わりに、後で値を収集するために使用できるキーが返されます。キーは、答えを提供する約束と見なすことができます。</target>
        </trans-unit>
        <trans-unit id="701e88bfb66430bf554605afebb5bc817eba6c88" translate="yes" xml:space="preserve">
          <source>Implements an internal CRL (Certificate Revocation List) cache. In addition to implementing the &lt;code&gt;&lt;a href=&quot;ssl_crl_cache_api&quot;&gt; ssl_crl_cache_api&lt;/a&gt;&lt;/code&gt; behaviour the following functions are available.</source>
          <target state="translated">内部CRL（証明書失効リスト）キャッシュを実装します。 &lt;code&gt;&lt;a href=&quot;ssl_crl_cache_api&quot;&gt; ssl_crl_cache_api&lt;/a&gt;&lt;/code&gt; 動作の実装に加えて、次の関数を使用できます。</target>
        </trans-unit>
        <trans-unit id="5852555552878975a45593281d37fefa3026933d" translate="yes" xml:space="preserve">
          <source>Implements an internal CRL (Certificate Revocation List) cache. In addition to implementing the &lt;code&gt;&lt;a href=&quot;ssl_crl_cache_api&quot;&gt;ssl_crl_cache_api&lt;/a&gt;&lt;/code&gt; behaviour the following functions are available.</source>
          <target state="translated">内部CRL（証明書失効リスト）キャッシュを実装します。 &lt;code&gt;&lt;a href=&quot;ssl_crl_cache_api&quot;&gt;ssl_crl_cache_api&lt;/a&gt;&lt;/code&gt; 動作の実装に加えて、次の関数を使用できます。</target>
        </trans-unit>
        <trans-unit id="b29c8d309278d1184cdf0686f160a939ff31d257" translate="yes" xml:space="preserve">
          <source>Implements global (repetitive) search (flag &lt;code&gt;g&lt;/code&gt; in Perl). Each match is returned as a separate &lt;code&gt;list()&lt;/code&gt; containing the specific match and any matching subexpressions (or as specified by option &lt;code&gt;capture&lt;/code&gt;. The &lt;code&gt;Captured&lt;/code&gt; part of the return value is hence a &lt;code&gt;list()&lt;/code&gt; of &lt;code&gt;list()&lt;/code&gt;s when this option is specified.</source>
          <target state="translated">グローバル（反復）検索を実装します（Perlのフラグ &lt;code&gt;g&lt;/code&gt; ）。各一致は、特定の一致と一致する部分式を含む個別の &lt;code&gt;list()&lt;/code&gt; として返されます（またはオプション &lt;code&gt;capture&lt;/code&gt; で指定された &lt;code&gt;list()&lt;/code&gt; です。したがって、このオプションが指定されている場合、戻り値の &lt;code&gt;Captured&lt;/code&gt; 部分はlist（）の &lt;code&gt;list()&lt;/code&gt; になります。</target>
        </trans-unit>
        <trans-unit id="d0d6b7b06bc0717a09a0609e9b93d5b110576e74" translate="yes" xml:space="preserve">
          <source>Implements the transformation at compile time. This function is called by the compiler to do the source code transformation if and when header file &lt;code&gt;ms_transform.hrl&lt;/code&gt; is included in the source code.</source>
          <target state="translated">コンパイル時に変換を実装します。この関数は、ヘッダーファイル &lt;code&gt;ms_transform.hrl&lt;/code&gt; がソースコードに含まれている場合に、ソースコード変換を行うためにコンパイラーによって呼び出されます。</target>
        </trans-unit>
        <trans-unit id="6edd4a0551006932a13f07152c0a0aa13d34aeb3" translate="yes" xml:space="preserve">
          <source>Implements the transformation when the &lt;code&gt;fun2ms/1&lt;/code&gt; functions are called from the shell. In this case, the abstract form is for one single fun (parsed by the Erlang shell). All imported variables are to be in the key-value list passed as &lt;code&gt;BoundEnvironment&lt;/code&gt;. The result is a term, normalized, that is, not in abstract format.</source>
          <target state="translated">&lt;code&gt;fun2ms/1&lt;/code&gt; 関数がシェルから呼び出されたときに変換を実装します。この場合、抽象形式は1つの楽しみ（Erlangシェルによって解析される）のためのものです。インポートされたすべての変数は、 &lt;code&gt;BoundEnvironment&lt;/code&gt; として渡されるキーと値のリストに含まれます。結果は正規化された用語、つまり抽象的な形式ではありません。</target>
        </trans-unit>
        <trans-unit id="5157539667ba028bf842cb4d314ce494573a8908" translate="yes" xml:space="preserve">
          <source>Implicitly when a specific instruction is defined. This is by far the most common way. Whenever a specific instruction is created, &lt;strong&gt;beam_makeops&lt;/strong&gt; automatically creates an internal generic instruction if it does not previously exist.</source>
          <target state="translated">特定の命令が定義されている場合は暗黙的に。これは断然最も一般的な方法です。特定の命令が作成されるたびに、&lt;strong&gt;beam_makeops&lt;/strong&gt;は、以前に存在していなかった場合、内部汎用命令を自動的に作成します。</target>
        </trans-unit>
        <trans-unit id="d6fbc9d2bdd580e18ed0bc5805dc26db323d6f5f" translate="yes" xml:space="preserve">
          <source>Import</source>
          <target state="translated">Import</target>
        </trans-unit>
        <trans-unit id="b7c113ae3f8b579e4a0169b23cb527018f3cd218" translate="yes" xml:space="preserve">
          <source>Import configuration data (similar to &lt;code&gt;ct_run -config/-userconfig&lt;/code&gt;).</source>
          <target state="translated">構成データをインポートします（ &lt;code&gt;ct_run -config/-userconfig&lt;/code&gt; と同様）。</target>
        </trans-unit>
        <trans-unit id="64200c8515980ead3d6f6d1c54b72c0df1647038" translate="yes" xml:space="preserve">
          <source>Imported functions. Can be called the same way as local functions, that is, without any module prefix.</source>
          <target state="translated">インポートされた関数。ローカル関数と同じように呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="e96159a0570df1d76f4d6b6b63ad56985185ffc2" translate="yes" xml:space="preserve">
          <source>Imports coverage data from the file &lt;code&gt;ExportFile&lt;/code&gt; created with &lt;code&gt;cover:export/1,2&lt;/code&gt;. Any analysis performed after this will include the imported data.</source>
          <target state="translated">&lt;code&gt;cover:export/1,2&lt;/code&gt; で作成されたファイル &lt;code&gt;ExportFile&lt;/code&gt; からカバレッジデータをインポートします。この後に実行される分析には、インポートされたデータが含まれます。</target>
        </trans-unit>
        <trans-unit id="6293ff4a8408c9b4904b5c4c8135a7dbb83fe606" translate="yes" xml:space="preserve">
          <source>Improper use can seriously degrade system performance.</source>
          <target state="translated">不適切な使用は、システムの性能を著しく低下させる可能性があります。</target>
        </trans-unit>
        <trans-unit id="68545fd32c1a3f37a53bcab05bb6a3c24b6ca95e" translate="yes" xml:space="preserve">
          <source>In .emacs, the slash character &quot;/&quot; can be used as path separator. But if you decide to use the backslash character &quot;\&quot;, please not that you must use double backslashes, since they are treated as escape characters by Emacs.</source>
          <target state="translated">.emacsでは、スラッシュ文字&quot;/&quot;をパス区切り文字として使うことができます。しかし、バックスラッシュ&quot;\&quot;を使おうと思ったら、バックスラッシュを二重にしてはいけないということではないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="0f7795a31a2f6e68385e615d1e0b39534a4a427f" translate="yes" xml:space="preserve">
          <source>In 1994 the global tagging mode &lt;code&gt;AUTOMATIC TAGS&lt;/code&gt; was introduced. By putting &lt;code&gt;AUTOMATIC TAGS&lt;/code&gt; in the module header, the ASN.1 compiler automatically adds tags when needed. The following is the same specification in &lt;code&gt;AUTOMATIC TAGS&lt;/code&gt; mode:</source>
          <target state="translated">1994年に、グローバルタグ付けモード &lt;code&gt;AUTOMATIC TAGS&lt;/code&gt; が導入されました。モジュールヘッダーに &lt;code&gt;AUTOMATIC TAGS&lt;/code&gt; を配置することにより、ASN.1コンパイラーは必要に応じて自動的にタグを追加します。以下は、 &lt;code&gt;AUTOMATIC TAGS&lt;/code&gt; モードでの同じ仕様です。</target>
        </trans-unit>
        <trans-unit id="b2eae1b23e89f4b197bf1ba45908178d3aa172d8" translate="yes" xml:space="preserve">
          <source>In 8-bit, non-UTF-8 mode, only the characters with code points &amp;lt; 256 are relevant.</source>
          <target state="translated">8ビットの非UTF-8モードでは、コードポイントが256未満の文字のみが関連します。</target>
        </trans-unit>
        <trans-unit id="fcb066c655ce1aa010477f09bef3fac0ead37f56" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;$ERL_TOP&lt;/code&gt;, there is a script called &lt;code&gt;otp_build&lt;/code&gt;. That script handles the hassle of giving all the right parameters to &lt;code&gt;configure&lt;/code&gt;/&lt;code&gt;make&lt;/code&gt; and also helps you set up the correct environment variables to work with the Erlang source under Cygwin/MSYS/MSYS2.</source>
          <target state="translated">では &lt;code&gt;$ERL_TOP&lt;/code&gt; 、というスクリプトがあり &lt;code&gt;otp_build&lt;/code&gt; 。このスクリプトは、 &lt;code&gt;configure&lt;/code&gt; / &lt;code&gt;make&lt;/code&gt; に必要なすべての適切なパラメーターを与える手間を処理し、Cygwin / MSYS / MSYS2でErlangソースを使用するための正しい環境変数を設定するのにも役立ちます。</target>
        </trans-unit>
        <trans-unit id="38e9bf33d69940366928f0c1e758698b02736bd6" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;$ERL_TOP&lt;/code&gt;, there is a script called &lt;code&gt;otp_build&lt;/code&gt;. That script handles the hassle of giving all the right parameters to &lt;code&gt;configure&lt;/code&gt;/&lt;code&gt;make&lt;/code&gt; and also helps you set up the correct environment variables to work with the Erlang source under WSL.</source>
          <target state="translated">では &lt;code&gt;$ERL_TOP&lt;/code&gt; 、というスクリプトがあり &lt;code&gt;otp_build&lt;/code&gt; 。このスクリプトは、 &lt;code&gt;configure&lt;/code&gt; / &lt;code&gt;make&lt;/code&gt; すべての適切なパラメーターを指定する手間を処理し、WSLでErlangソースを操作するための正しい環境変数を設定するのにも役立ちます。</target>
        </trans-unit>
        <trans-unit id="c1e4870154b4a5f3a6bba7d020678f1436a7aad2" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;ID&lt;/code&gt;, only 18 bits are significant; the rest are to be 0. In &lt;code&gt;Creation&lt;/code&gt;, only two bits are significant; the rest are to be 0. See &lt;code&gt;&lt;a href=&quot;#NEW_REFERENCE_EXT&quot;&gt;NEW_REFERENCE_EXT&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ID&lt;/code&gt; 、わずか18ビットが重要です。残りは0であることがある &lt;code&gt;Creation&lt;/code&gt; 、2つだけのビットが重要です。残りは0 &lt;code&gt;&lt;a href=&quot;#NEW_REFERENCE_EXT&quot;&gt;NEW_REFERENCE_EXT&lt;/a&gt;&lt;/code&gt; 参照してください。</target>
        </trans-unit>
        <trans-unit id="d0025e78fbaf5c3757dcab01eedc653609a16493" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;Mnesia&lt;/code&gt;, all records in a table must have the same name. All the records must be instances of the same record type. The record name, however, does not necessarily have to be the same as the table name, although this is the case in most of the examples in this User's Guide. If a table is created without property &lt;code&gt;record_name&lt;/code&gt;, the following code ensures that all records in the tables have the same name as the table:</source>
          <target state="translated">で &lt;code&gt;Mnesia&lt;/code&gt; 、テーブル内のすべてのレコードは、同じ名前を持つ必要があります。すべてのレコードは、同じレコードタイプのインスタンスである必要があります。ただし、レコード名は必ずしもテーブル名と同じである必要はありませんが、これはこのユーザーズガイドのほとんどの例に当てはまります。プロパティ &lt;code&gt;record_name&lt;/code&gt; なしでテーブルが作成された場合、次のコードは、テーブル内のすべてのレコードがテーブルと同じ名前であることを確認します。</target>
        </trans-unit>
        <trans-unit id="770b380d53bce026d82e5f70351df3a234e00dd1" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;Module:Name/Arity&lt;/code&gt;, &lt;code&gt;Module&lt;/code&gt;, and &lt;code&gt;Name&lt;/code&gt; are atoms and &lt;code&gt;Arity&lt;/code&gt; is an integer. Starting from Erlang/OTP R15, &lt;code&gt;Module&lt;/code&gt;, &lt;code&gt;Name&lt;/code&gt;, and &lt;code&gt;Arity&lt;/code&gt; can also be variables. A fun defined in this way refers to the function &lt;code&gt;Name&lt;/code&gt; with arity &lt;code&gt;Arity&lt;/code&gt; in the &lt;strong&gt;latest&lt;/strong&gt; version of module &lt;code&gt;Module&lt;/code&gt;. A fun defined in this way is not dependent on the code for the module in which it is defined.</source>
          <target state="translated">&lt;code&gt;Module:Name/Arity&lt;/code&gt; 、 &lt;code&gt;Module&lt;/code&gt; 、および &lt;code&gt;Name&lt;/code&gt; 原子であり、 &lt;code&gt;Arity&lt;/code&gt; 整数です。 Erlang / OTP R15以降、 &lt;code&gt;Module&lt;/code&gt; 、 &lt;code&gt;Name&lt;/code&gt; 、および &lt;code&gt;Arity&lt;/code&gt; も変数にすることができます。このように定義されたfun は、モジュール &lt;code&gt;Module&lt;/code&gt; の&lt;strong&gt;最新&lt;/strong&gt;バージョンのアリティ &lt;code&gt;Arity&lt;/code&gt; を持つ関数 &lt;code&gt;Name&lt;/code&gt; を参照します。この方法で定義されたfunは、それが定義されているモジュールのコードに依存しません。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e5df66c12eaa68ca0a48283d550d16d991720df0" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;Name/Arity&lt;/code&gt;, &lt;code&gt;Name&lt;/code&gt; is an atom and &lt;code&gt;Arity&lt;/code&gt; is an integer. &lt;code&gt;Name/Arity&lt;/code&gt; must specify an existing local function. The expression is syntactic sugar for:</source>
          <target state="translated">&lt;code&gt;Name/Arity&lt;/code&gt; 、 &lt;code&gt;Name&lt;/code&gt; 原子であり、 &lt;code&gt;Arity&lt;/code&gt; 整数です。 &lt;code&gt;Name/Arity&lt;/code&gt; は、既存のローカル関数を指定する必要があります。式は次の構文糖です。</target>
        </trans-unit>
        <trans-unit id="943fe69f8dfd82f02ed43163f6738a7b0394f445" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;OTP Configuration Parameters&lt;/code&gt;:</source>
          <target state="translated">で &lt;code&gt;OTP Configuration Parameters&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="a472768ac00c2b862480bf36de83581f96978047" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;Type_List&lt;/code&gt; the &quot;path&quot; from the top type to each undecoded subcomponents is described. The top type of the path is an atom, the name of it. The action on each component/type that follows is described by one of &lt;code&gt;{Name,parts}, {Name,undecoded}, {Name,Element_List}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Type_List&lt;/code&gt; 各デコードされていないサブコンポーネントにトップ型から「パス」が記載されています。パスの一番上のタイプは、その名前であるアトムです。続く各コンポーネント/タイプに対するアクションは、 &lt;code&gt;{Name,parts}, {Name,undecoded}, {Name,Element_List}&lt;/code&gt; いずれかによって記述されます。</target>
        </trans-unit>
        <trans-unit id="893648209f7036a7f9ac95fdc3c4a7d64bef1838" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;allocate_heap&lt;/code&gt;, the last operand is the number of live registers. It will only be used if there is not enough heap space and a garbage collection must be performed.</source>
          <target state="translated">で &lt;code&gt;allocate_heap&lt;/code&gt; 、最後のオペランドは、ライブレジスタの数です。十分なヒープスペースがなく、ガベージコレクションを実行する必要がある場合にのみ使用されます。</target>
        </trans-unit>
        <trans-unit id="9c54988a1f913bda4c57ecea3e6f820b07cee1aa" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;attr&lt;/code&gt; the attributes of the object are stored as the logical &lt;strong&gt;OR&lt;/strong&gt; of its type (one of &lt;code&gt;EI_INT&lt;/code&gt;, &lt;code&gt;EI_FLT&lt;/code&gt;, &lt;code&gt;EI_BIN&lt;/code&gt;, and &lt;code&gt;EI_STR&lt;/code&gt;), whether it is marked for deletion (&lt;code&gt;EI_DELET&lt;/code&gt;), and whether it has been modified since the last backup to &lt;code&gt;Mnesia&lt;/code&gt; (&lt;code&gt;EI_DIRTY&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;attr&lt;/code&gt; オブジェクトの属性論理として格納され&lt;strong&gt;OR&lt;/strong&gt;そのタイプ（の一つの &lt;code&gt;EI_INT&lt;/code&gt; 、 &lt;code&gt;EI_FLT&lt;/code&gt; 、 &lt;code&gt;EI_BIN&lt;/code&gt; 、及び &lt;code&gt;EI_STR&lt;/code&gt; それが削除対象としてマークされているか否か）、（ &lt;code&gt;EI_DELET&lt;/code&gt; ）、そしてそれが最後のバックアップ以降に変更されたか否か &lt;code&gt;Mnesia&lt;/code&gt; （ &lt;code&gt;EI_DIRTY&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="9643419e6aee2e17ffb863a8ef01b8323b347a6e" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;ch1.erl&lt;/code&gt; and &lt;code&gt;ch2.erl&lt;/code&gt; above, the implementation of &lt;code&gt;channels/0&lt;/code&gt;, &lt;code&gt;alloc/1&lt;/code&gt;, and &lt;code&gt;free/2&lt;/code&gt; has been intentionally left out, as it is not relevant to the example. For completeness, one way to write these functions are given below. This is an example only, a realistic implementation must be able to handle situations like running out of channels to allocate, and so on.</source>
          <target state="translated">&lt;code&gt;ch1.erl&lt;/code&gt; と &lt;code&gt;ch2.erl&lt;/code&gt; の実装、上記 &lt;code&gt;channels/0&lt;/code&gt; 、 &lt;code&gt;alloc/1&lt;/code&gt; 、及び &lt;code&gt;free/2&lt;/code&gt; 、それが例と関連していないように意図的に除外されています。完全を期すために、これらの関数を記述する1つの方法を以下に示します。これは単なる例であり、現実的な実装では、割り当てるチャネルが不足するなどの状況を処理できなければなりません。</target>
        </trans-unit>
        <trans-unit id="27aabe06bd512676435ef4845535c23e8c05bacb" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;ch1.erl&lt;/code&gt; and &lt;code&gt;ch2.erl&lt;/code&gt; above, the implementation of &lt;code&gt;channels/0&lt;/code&gt;, &lt;code&gt;alloc/1&lt;/code&gt;, and &lt;code&gt;free/2&lt;/code&gt; has been intentionally left out, as it is not relevant to the example. For completeness, one way to write these functions is given below. This is an example only, a realistic implementation must be able to handle situations like running out of channels to allocate, and so on.</source>
          <target state="translated">&lt;code&gt;ch1.erl&lt;/code&gt; と &lt;code&gt;ch2.erl&lt;/code&gt; の実装、上記 &lt;code&gt;channels/0&lt;/code&gt; 、 &lt;code&gt;alloc/1&lt;/code&gt; 、及び &lt;code&gt;free/2&lt;/code&gt; 、それが例と関連していないように意図的に除外されています。完全を期すために、これらの関数を作成する1つの方法を以下に示します。これは単なる例であり、現実的な実装では、割り当てるチャネルが不足するなどの状況を処理できる必要があります。</target>
        </trans-unit>
        <trans-unit id="ab0d5c626ce8dc42f39e1abeabf7105631919c54" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;ei_s_print_term()&lt;/code&gt;, parameter &lt;code&gt;s&lt;/code&gt; is to point to a dynamically (malloc) allocated string of &lt;code&gt;BUFSIZ&lt;/code&gt; bytes or a &lt;code&gt;NULL&lt;/code&gt; pointer. The string can be reallocated (and &lt;code&gt;*s&lt;/code&gt; can be updated) by this function if the result is more than &lt;code&gt;BUFSIZ&lt;/code&gt; characters. The string returned is &lt;code&gt;NULL&lt;/code&gt;-terminated.</source>
          <target state="translated">&lt;code&gt;ei_s_print_term()&lt;/code&gt; は、パラメータ &lt;code&gt;s&lt;/code&gt; 、動的に（malloc関数）に割り当てられた文字列へのポイントである &lt;code&gt;BUFSIZ&lt;/code&gt; バイトまたは &lt;code&gt;NULL&lt;/code&gt; のポインタ。結果が &lt;code&gt;BUFSIZ&lt;/code&gt; 文字を超える場合、この関数によって文字列を再割り当てできます（ &lt;code&gt;*s&lt;/code&gt; を更新できます）。返される文字列は &lt;code&gt;NULL&lt;/code&gt; で終了します。</target>
        </trans-unit>
        <trans-unit id="0a141cc5ac15d20e41285b60b7e1dbadddb212ee" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;file_logger&lt;/code&gt;:</source>
          <target state="translated">では &lt;code&gt;file_logger&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="7fbf17e1fc5bc4462fd00e9068033e131292be59" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;gen_statem&lt;/code&gt; we define a &lt;strong&gt;state change&lt;/strong&gt; as a &lt;strong&gt;state transition&lt;/strong&gt; in which the new state &lt;code&gt;S'&lt;/code&gt; is different from the current state &lt;code&gt;S&lt;/code&gt;, where &quot;different&quot; means Erlang's strict inequality: &lt;code&gt;=/=&lt;/code&gt; also known as &quot;does not match&quot;. &lt;code&gt;gen_statem&lt;/code&gt; does more things during &lt;strong&gt;state changes&lt;/strong&gt; than during other &lt;strong&gt;state transitions&lt;/strong&gt;.</source>
          <target state="translated">で &lt;code&gt;gen_statem&lt;/code&gt; 我々が定義する&lt;strong&gt;状態変化&lt;/strong&gt;など&lt;strong&gt;の状態遷移&lt;/strong&gt;新たな状態ここで &lt;code&gt;S'&lt;/code&gt; 現在の状態と異なる &lt;code&gt;S&lt;/code&gt; を、ここで『異なる』はアーランの厳格な不平等を意味します。 &lt;code&gt;=/=&lt;/code&gt; も『一致しない』として知られています。 &lt;code&gt;gen_statem&lt;/code&gt; は、他の&lt;strong&gt;状態遷移&lt;/strong&gt;中よりも&lt;strong&gt;状態変化&lt;/strong&gt;中により多くのことを行います。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c5dd48fe409f725dfa23be2b6d97df3560da702c" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;is_eq_exact&lt;/code&gt;, the failure address (the first operand) will only be used if the two register operands are not equal.</source>
          <target state="translated">&lt;code&gt;is_eq_exact&lt;/code&gt; 2つのレジスタオペランドが等しくない場合、不良アドレス（最初のオペランド）にのみ使用されます。</target>
        </trans-unit>
        <trans-unit id="c6953b7249dfd9871d1537ea03ef11de631fd526" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;latin1&lt;/code&gt; mode, filenames are bytewise encoded. This allows for list representation of all filenames in the system. However, a a file named &quot;&amp;Ouml;stersund.txt&quot;, appears in &lt;code&gt;file:list_dir/1&lt;/code&gt; either as &quot;&amp;Ouml;stersund.txt&quot; (if the filename was encoded in bytewise ISO Latin-1 by the program creating the file) or more probably as &lt;code&gt;[195,150,115,116,101,114,115,117,110,100]&lt;/code&gt;, which is a list containing UTF-8 bytes (not what you want). If you use Unicode filename translation on such a system, non-UTF-8 filenames are ignored by functions like &lt;code&gt;file:list_dir/1&lt;/code&gt;. They can be retrieved with function &lt;code&gt;file:list_dir_all/1&lt;/code&gt;, but wrongly encoded filenames appear as &quot;raw filenames&quot;.</source>
          <target state="translated">では &lt;code&gt;latin1&lt;/code&gt; のモードで、ファイル名はバイト単位符号化されています。これにより、システム内のすべてのファイル名のリスト表示が可能になります。ただし、「&amp;Ouml;stersund.txt」という名前のファイルは、 &lt;code&gt;file:list_dir/1&lt;/code&gt; に「&amp;Ouml;stersund.txt」（ファイル名がファイルを作成するプログラムによって &lt;code&gt;[195,150,115,116,101,114,115,117,110,100]&lt;/code&gt; ISO Latin-1でエンコードされている場合）、またはおそらく[195,150,115,116,101,114,115,117,110,100として表示されます。 ]は、UTF-8バイトを含むリストです（必要なものではありません）。そのようなシステムでUnicodeファイル名変換を使用する場合、UTF-8以外のファイル名は &lt;code&gt;file:list_dir/1&lt;/code&gt; などの関数によって無視されます。それらはfunction &lt;code&gt;file:list_dir_all/1&lt;/code&gt; で取得できますが、誤ってエンコードされたファイル名は「生のファイル名」として表示されます。</target>
        </trans-unit>
        <trans-unit id="116bd7f6b497e889e6e51bc1f52782d94cab61ab" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;latin1&lt;/code&gt; mode, the Erlang VM does not change the encoding of filenames. In &lt;code&gt;utf8&lt;/code&gt; mode, filenames can contain Unicode characters greater than 255 and the VM converts filenames back and forth to the native filename encoding (usually UTF-8, but UTF-16 on Windows).</source>
          <target state="translated">では &lt;code&gt;latin1&lt;/code&gt; のモードで、ErlangのVMは、ファイル名のエンコーディングを変更しません。では &lt;code&gt;utf8&lt;/code&gt; モードで、ファイル名が255より大きいUnicode文字を含めることができ、VMは、（Windows上で通常はUTF-8が、UTF-16）ネイティブエンコーディングファイル名に前後にファイル名を変換します。</target>
        </trans-unit>
        <trans-unit id="efaf4d06886c110e8f2a1c0d7f556c6c220cdc32" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;list_max/2&lt;/code&gt;, you walk down the list and use &lt;code&gt;Head&lt;/code&gt; instead of &lt;code&gt;Result_so_far&lt;/code&gt; when &lt;code&gt;Head&lt;/code&gt; &amp;gt; &lt;code&gt;Result_so_far&lt;/code&gt;. &lt;code&gt;when&lt;/code&gt; is a special word used before the -&amp;gt; in the function to say that you only use this part of the function if the test that follows is true. A test of this type is called &lt;strong&gt;guard&lt;/strong&gt;. If the guard is false (that is, the guard fails), the next part of the function is tried. In this case, if &lt;code&gt;Head&lt;/code&gt; is not greater than &lt;code&gt;Result_so_far&lt;/code&gt;, then it must be smaller or equal to it. This means that a guard on the next part of the function is not needed.</source>
          <target state="translated">で &lt;code&gt;list_max/2&lt;/code&gt; 、あなたはリストを歩くと使用 &lt;code&gt;Head&lt;/code&gt; 代わりに &lt;code&gt;Result_so_far&lt;/code&gt; &lt;code&gt;Head&lt;/code&gt; &amp;gt; &lt;code&gt;Result_so_far&lt;/code&gt; 。 &lt;code&gt;when&lt;/code&gt; は、関数の-&amp;gt;の前に使用される特別な単語であり、後続のテストが真の場合にのみ関数のこの部分を使用することを示します。このタイプのテストは、&lt;strong&gt;ガード&lt;/strong&gt;と呼ばれます。ガードがfalseの場合（つまり、ガードが失敗した場合）、関数の次の部分が試行されます。この場合、 &lt;code&gt;Head&lt;/code&gt; が &lt;code&gt;Result_so_far&lt;/code&gt; より大きくない場合は、それ以下にする必要があります。これは、関数の次の部分のガードが不要であることを意味します。</target>
        </trans-unit>
        <trans-unit id="5487ffcf59e4dcb4dda76a98d92b6b90dc718bb3" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;macros.tab&lt;/code&gt;, there is a definition of &lt;code&gt;GC_REGEXP&lt;/code&gt;. It will be described in &lt;code&gt;&lt;a href=&quot;#Syntax-of-tab-files_Defining-the-implementation_Macros-in-the-macrostab-file_The-GCREGEXP-definition&quot;&gt;a later section&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">で &lt;code&gt;macros.tab&lt;/code&gt; 、の定義があり &lt;code&gt;GC_REGEXP&lt;/code&gt; 。これについては &lt;code&gt;&lt;a href=&quot;#Syntax-of-tab-files_Defining-the-implementation_Macros-in-the-macrostab-file_The-GCREGEXP-definition&quot;&gt;a later section&lt;/a&gt;&lt;/code&gt; 説明します。</target>
        </trans-unit>
        <trans-unit id="02cb096eaff82424f4a89dbad61cc6a39bc0e575" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;sort&lt;/code&gt; the fun is used:</source>
          <target state="translated">で &lt;code&gt;sort&lt;/code&gt; 楽しみが使用されます。</target>
        </trans-unit>
        <trans-unit id="12c27e7f6632f170be6359162707f4b8a39d1d9c" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;terminal_logger&lt;/code&gt;:</source>
          <target state="translated">では &lt;code&gt;terminal_logger&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="bbd6fe570f64e2ea4d9df82e02a34c966281d919" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;unicode&lt;/code&gt; mode, only ASCII numbers and letters have any special meaning after a backslash. All other characters (in particular, those whose code points are &amp;gt; 127) are treated as literals.</source>
          <target state="translated">では &lt;code&gt;unicode&lt;/code&gt; モードで、ASCIIのみの数字と文字は、バックスラッシュの後に特別な意味を持ちます。他のすべての文字（特に、コードポイントが127より大きい文字）はリテラルとして扱われます。</target>
        </trans-unit>
        <trans-unit id="3192c3cf3b67f79505ca334fb569ea62ed1d48cb" translate="yes" xml:space="preserve">
          <source>In AEAD (Authenticated Encryption with Associated Data) mode, decrypt &lt;code&gt;CipherText&lt;/code&gt;according to &lt;code&gt;Type&lt;/code&gt; block cipher and check the authenticity the &lt;code&gt;PlainText&lt;/code&gt; and &lt;code&gt;AAD&lt;/code&gt; (Associated Authenticated Data) using the &lt;code&gt;CipherTag&lt;/code&gt;. May return &lt;code&gt;error&lt;/code&gt; if the decryption or validation fail's</source>
          <target state="translated">AEAD解読（関連するデータで認証暗号化）モードでは、 &lt;code&gt;CipherText&lt;/code&gt; に記載の &lt;code&gt;Type&lt;/code&gt; ブロック暗号の真偽確認 &lt;code&gt;PlainText&lt;/code&gt; と &lt;code&gt;AAD&lt;/code&gt; 用いて（関連する認証されたデータ） &lt;code&gt;CipherTag&lt;/code&gt; を。復号化または検証が失敗した場合、 &lt;code&gt;error&lt;/code&gt; 返すことがあります</target>
        </trans-unit>
        <trans-unit id="11cacd0985503ba6b7aa7e02c729d4cf5d9ec8c0" translate="yes" xml:space="preserve">
          <source>In AEAD (Authenticated Encryption with Associated Data) mode, encrypt &lt;code&gt;PlainText&lt;/code&gt;according to &lt;code&gt;Type&lt;/code&gt; block cipher and calculate &lt;code&gt;CipherTag&lt;/code&gt; that also authenticates the &lt;code&gt;AAD&lt;/code&gt; (Associated Authenticated Data).</source>
          <target state="translated">AEAD（関連するデータで認証暗号化）モード、暗号で &lt;code&gt;PlainText&lt;/code&gt; に記載の &lt;code&gt;Type&lt;/code&gt; ブロック暗号と計算 &lt;code&gt;CipherTag&lt;/code&gt; をも認証すること &lt;code&gt;AAD&lt;/code&gt; （関連する認証されたデータを）。</target>
        </trans-unit>
        <trans-unit id="c038f0a7011f32aa3c2253ea59f81adb573ae04f" translate="yes" xml:space="preserve">
          <source>In ASN.1 it is also possible to have components that are themselves structured types. For example, it is possible to have the following:</source>
          <target state="translated">ASN.1では、それ自体が構造化型であるコンポーネントを持つことも可能です。例えば、以下のようなものが考えられます。</target>
        </trans-unit>
        <trans-unit id="1fd6892220150bfbf692aea6c817cdbc6b525af4" translate="yes" xml:space="preserve">
          <source>In ASN.1 it is possible to have:</source>
          <target state="translated">ASN.1では持つことができます。</target>
        </trans-unit>
        <trans-unit id="ac981922e3d2be3099b7dd819f976f8cd431aa5c" translate="yes" xml:space="preserve">
          <source>In ASN.1, &lt;code&gt;BIT STRING&lt;/code&gt; definitions can look as follows:</source>
          <target state="translated">ASN.1では、 &lt;code&gt;BIT STRING&lt;/code&gt; 定義は次のようになります。</target>
        </trans-unit>
        <trans-unit id="e4c809e7fa181f22943bb3998e2675cc28fadeb7" translate="yes" xml:space="preserve">
          <source>In Appendix A of the Megaco/H.248 specification (RFC 3525), there are about 30 messages that shows a representative call flow. We have also added a few extra version 1, version 2 and version 3 messages. We have used these messages as basis for our measurements. Our figures have not been weighted in regard to how frequent the different kinds of messages that are sent between the media gateway and its controller.</source>
          <target state="translated">Megaco/H.248仕様(RFC 3525)の付録Aには、代表的な呼の流れを示すメッセージが約30個あります。また、バージョン1、バージョン2、バージョン3のメッセージを追加しました。これらのメッセージを測定の基礎として使用しています。私たちの数値は、メディアゲートウェイとそのコントローラの間で送信される異なる種類のメッセージの頻度に関しては、重み付けされていません。</target>
        </trans-unit>
        <trans-unit id="a6d6cb54546267c7ab63766eec09cee649711a31" translate="yes" xml:space="preserve">
          <source>In Erlang code it can look as follows:</source>
          <target state="translated">Erlangのコードでは以下のようになります。</target>
        </trans-unit>
        <trans-unit id="aba42f54367f97fea68495b7cac79db5d13869f6" translate="yes" xml:space="preserve">
          <source>In Erlang the BIF &lt;code&gt; erlang:term_to_binary/1,2&lt;/code&gt; is used to convert a term into the external format. To convert binary data encoding to a term, the BIF &lt;code&gt; erlang:binary_to_term/1&lt;/code&gt; is used.</source>
          <target state="translated">Erlangでは、BIF &lt;code&gt; erlang:term_to_binary/1,2&lt;/code&gt; を使用して、用語を外部形式に変換します。バイナリデータエンコーディングを用語に変換するには、BIF &lt;code&gt; erlang:binary_to_term/1&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="4e5807093e6d87fdc7a49890d975be36f4a0da6c" translate="yes" xml:space="preserve">
          <source>In Erlang the BIF &lt;code&gt;erlang:term_to_binary/1,2&lt;/code&gt; is used to convert a term into the external format. To convert binary data encoding to a term, the BIF &lt;code&gt;erlang:binary_to_term/1&lt;/code&gt; is used.</source>
          <target state="translated">Erlangでは、BIFの &lt;code&gt;erlang:term_to_binary/1,2&lt;/code&gt; を使用して、用語を外部形式に変換します。バイナリデータエンコーディングを用語に変換するには、BIF &lt;code&gt;erlang:binary_to_term/1&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="cfeed77756208eb4d9dfb0d9a3e58ff900cc5da1" translate="yes" xml:space="preserve">
          <source>In Erlang the following can apply:</source>
          <target state="translated">Erlangでは以下のようになります。</target>
        </trans-unit>
        <trans-unit id="55425998bade0d03c70bf896550329d58b5b495b" translate="yes" xml:space="preserve">
          <source>In Erlang, a Bin is used for constructing binaries and matching binary patterns. A Bin is written with the following syntax:</source>
          <target state="translated">Erlangでは、バイナリを構築したりバイナリパターンをマッチさせたりするためにBinが使われます。Binは次のような構文で書かれています。</target>
        </trans-unit>
        <trans-unit id="27260c403bb29fda2001d4a6be0835230872a64b" translate="yes" xml:space="preserve">
          <source>In Erlang, strings are lists of integers. A string was until Erlang/OTP R13 defined to be encoded in the ISO Latin-1 (ISO 8859-1) character set, which is, code point by code point, a subrange of the Unicode character set.</source>
          <target state="translated">Erlangでは、文字列は整数のリストです。Erlang/OTP R13までは文字列はISO Latin-1 (ISO 8859-1)の文字セットでエンコードされると定義されていました。</target>
        </trans-unit>
        <trans-unit id="000d471cb67467678d1ade49d91a91cbdff773ac" translate="yes" xml:space="preserve">
          <source>In Erlang, the &lt;code&gt;SET&lt;/code&gt; type is used exactly as &lt;code&gt;SEQUENCE&lt;/code&gt;. Notice that if BER or DER encoding rules are used, decoding a &lt;code&gt;SET&lt;/code&gt; is slower than decoding a &lt;code&gt;SEQUENCE&lt;/code&gt; because the components must be sorted.</source>
          <target state="translated">Erlangでは、 &lt;code&gt;SET&lt;/code&gt; タイプは &lt;code&gt;SEQUENCE&lt;/code&gt; とまったく同じように使用されます。BERまたはDERエンコーディングルールを使用する場合、コンポーネントをソートする必要があるため、 &lt;code&gt;SET&lt;/code&gt; のデコードは &lt;code&gt;SEQUENCE&lt;/code&gt; のデコードよりも遅いことに注意してください。</target>
        </trans-unit>
        <trans-unit id="111866cd1ba49a2b43af4850505bc155722873f8" translate="yes" xml:space="preserve">
          <source>In Erlang, the full UTF-16 range is supported when applicable, like in the &lt;code&gt;unicode&lt;/code&gt; module and in the bit syntax.</source>
          <target state="translated">Erlangでは、 &lt;code&gt;unicode&lt;/code&gt; モジュールやビット構文のように、該当する場合は完全なUTF-16範囲がサポートされています。</target>
        </trans-unit>
        <trans-unit id="2a7efb592ded3e962f361d6c4ea93e492befd66f" translate="yes" xml:space="preserve">
          <source>In Erlang, there is no interface to retrieve a mark with &lt;code&gt;&lt;a href=&quot;#run-2&quot;&gt;run/2,3&lt;/a&gt;&lt;/code&gt;, so only the secondary purpose is relevant to the Erlang programmer.</source>
          <target state="translated">Erlangでは、 &lt;code&gt;&lt;a href=&quot;#run-2&quot;&gt;run/2,3&lt;/a&gt;&lt;/code&gt; でマークを取得するためのインターフェースがないため、Erlangプログラマーに関連するのは2次的な目的のみです。</target>
        </trans-unit>
        <trans-unit id="2c60f9a05486134b501e5953f76c349e506d6f0f" translate="yes" xml:space="preserve">
          <source>In Erlang/OTP 17.0, the encoding default for Erlang source files was switched to UTF-8.</source>
          <target state="translated">Erlang/OTP 17.0では、ErlangソースファイルのエンコーディングのデフォルトがUTF-8に変更されました。</target>
        </trans-unit>
        <trans-unit id="6916e39092e66107b55f61baa3016b3f04cf8426" translate="yes" xml:space="preserve">
          <source>In Erlang/OTP 20.0, atoms and function can contain Unicode characters. Module names, application names, and node names are still restricted to the ISO Latin-1 range.</source>
          <target state="translated">Erlang/OTP 20.0では、アトムと関数はUnicode文字を含むことができます。モジュール名、アプリケーション名、ノード名はまだISO Latin-1の範囲に制限されています。</target>
        </trans-unit>
        <trans-unit id="198d0d1078d6039827840866a4f6899fdbe8d43c" translate="yes" xml:space="preserve">
          <source>In Erlang/OTP 21.0, a new API for logging was added. The old &lt;code&gt;error_logger&lt;/code&gt; module can still be used by legacy code, but log events are redirected to the new Logger API. New code should use the Logger API directly.</source>
          <target state="translated">Erlang / OTP 21.0では、ロギング用の新しいAPIが追加されました。古い &lt;code&gt;error_logger&lt;/code&gt; モジュールは引き続きレガシーコードで使用できますが、ログイベントは新しいLogger APIにリダイレクトされます。新しいコードでは、Logger APIを直接使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="e0d8b8d2cdbb6065786dcebb0086f01cf068b155" translate="yes" xml:space="preserve">
          <source>In Erlang/OTP R16B the syntax of Erlang tokens was extended to handle Unicode. The support was limited to string literals and comments. More about the usage of Unicode in Erlang source files can be found in &lt;code&gt;STDLIB's User's Guide&lt;/code&gt;.</source>
          <target state="translated">Erlang / OTP R16Bでは、Erlangトークンの構文がUnicodeを処理するように拡張されました。サポートは文字列リテラルとコメントに限定されていました。ErlangソースファイルでのUnicodeの使用の詳細については、 &lt;code&gt;STDLIB's User's Guide&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="24ca06e1e4890e17adbf7557eee37d1f56256f49" translate="yes" xml:space="preserve">
          <source>In Erlang/OTP R5B and later versions of OTP, the &lt;code&gt;include&lt;/code&gt; and &lt;code&gt;lib&lt;/code&gt; directories are situated under &lt;code&gt;OTPROOT/lib/erl_interface-VSN&lt;/code&gt;, where &lt;code&gt;OTPROOT&lt;/code&gt; is the root directory of the OTP installation (&lt;code&gt;/usr/local/otp&lt;/code&gt; in the recent example) and &lt;code&gt;VSN&lt;/code&gt; is the version of the Erl_Interface application (3.2.1 in the recent example).</source>
          <target state="translated">Erlang / OTP R5B以降のバージョンのOTPでは、 &lt;code&gt;include&lt;/code&gt; および &lt;code&gt;lib&lt;/code&gt; ディレクトリは &lt;code&gt;OTPROOT/lib/erl_interface-VSN&lt;/code&gt; の下にあります。ここで、 &lt;code&gt;OTPROOT&lt;/code&gt; はOTPインストールのルートディレクトリです（最近の例では &lt;code&gt;/usr/local/otp&lt;/code&gt; ）。 &lt;code&gt;VSN&lt;/code&gt; はErl_Interfaceアプリケーションのバージョンです（最近の例では3.2.1）。</target>
        </trans-unit>
        <trans-unit id="36bdb9cf8a7d0b24c3ea497881807594aa4ad9c3" translate="yes" xml:space="preserve">
          <source>In Erlang/OTP R5B and later versions of OTP, the &lt;code&gt;include&lt;/code&gt; and &lt;code&gt;lib&lt;/code&gt; directories are situated under &lt;code&gt;OTPROOT/lib/erl_interface-VSN&lt;/code&gt;, where &lt;code&gt;OTPROOT&lt;/code&gt; is the root directory of the OTP installation (&lt;code&gt;/usr/local/otp&lt;/code&gt; in the recent example) and &lt;code&gt;VSN&lt;/code&gt; is the version of the Erl_interface application (3.2.1 in the recent example).</source>
          <target state="translated">Erlang / OTP R5B以降のバージョンのOTPでは、 &lt;code&gt;include&lt;/code&gt; および &lt;code&gt;lib&lt;/code&gt; ディレクトリは &lt;code&gt;OTPROOT/lib/erl_interface-VSN&lt;/code&gt; の下にあります。ここで、 &lt;code&gt;OTPROOT&lt;/code&gt; はOTPインストールのルートディレクトリです（最近の例では &lt;code&gt;/usr/local/otp&lt;/code&gt; ）。 &lt;code&gt;VSN&lt;/code&gt; はErl_interfaceアプリケーションのバージョンです（最近の例では3.2.1）。</target>
        </trans-unit>
        <trans-unit id="e2c46173457c64237f426cb5d2c876573b902705" translate="yes" xml:space="preserve">
          <source>In Erlang/OTP R6B, a library similar to Erl_Interface for Java was added called &lt;strong&gt;jinterface&lt;/strong&gt;. It provides a tool for Java programs to communicate with Erlang nodes.</source>
          <target state="translated">Erlang / OTP R6Bでは、JavaのErl_Interfaceに似たライブラリがjinterfaceと呼ばれる&lt;strong&gt;よう&lt;/strong&gt;に追加され&lt;strong&gt;ました&lt;/strong&gt;。JavaプログラムがErlangノードと通信するためのツールを提供します。</target>
        </trans-unit>
        <trans-unit id="1be37b0c5d13632dad76da8a59a995e7c35b67e8" translate="yes" xml:space="preserve">
          <source>In Erlang/OTP SSH</source>
          <target state="translated">Erlang/OTP SSHでは</target>
        </trans-unit>
        <trans-unit id="f9e5f8580820830244cd23f79a16074f3a89cc2a" translate="yes" xml:space="preserve">
          <source>In Erlang/OTP, access to TCP/IP and UDP sockets is provided by the modules &lt;code&gt;gen_tcp&lt;/code&gt; and &lt;code&gt;gen_udp&lt;/code&gt; in Kernel. Both are easy to use and do not require detailed knowledge about the socket concept.</source>
          <target state="translated">Erlang / OTPでは、TCP / IPおよびUDPソケットへのアクセスは、カーネルのモジュール &lt;code&gt;gen_tcp&lt;/code&gt; および &lt;code&gt;gen_udp&lt;/code&gt; によって提供されます。どちらも使いやすく、ソケットの概念に関する詳細な知識は必要ありません。</target>
        </trans-unit>
        <trans-unit id="d098b9b5017423de630d21112a6b6fdc9450e7b2" translate="yes" xml:space="preserve">
          <source>In FIPS mode all non-FIPS compliant algorithms are disabled and raise exception &lt;code&gt;error:notsup&lt;/code&gt;. Check &lt;code&gt;&lt;a href=&quot;#supports-0&quot;&gt;supports&lt;/a&gt;&lt;/code&gt; that in FIPS mode returns the restricted list of available algorithms.</source>
          <target state="translated">FIPSモードでは、FIPSに準拠していないすべてのアルゴリズムが無効になり、例外 &lt;code&gt;error:notsup&lt;/code&gt; 。Check &lt;code&gt;&lt;a href=&quot;#supports-0&quot;&gt;supports&lt;/a&gt;&lt;/code&gt; 、FIPSモードで使用可能なアルゴリズムの制限付きリストを返すことをサポートしています。</target>
        </trans-unit>
        <trans-unit id="a321356801dc3e599cf50b6af4d5dd7265663386" translate="yes" xml:space="preserve">
          <source>In FIPS mode all non-FIPS compliant algorithms are disabled and throw exception &lt;code&gt;not_supported&lt;/code&gt;. Check &lt;code&gt;&lt;a href=&quot;#supports-0&quot;&gt;supports&lt;/a&gt;&lt;/code&gt; that in FIPS mode returns the restricted list of available algorithms.</source>
          <target state="translated">FIPSモードでは、FIPSに準拠していないアルゴリズムはすべて無効になり、例外 &lt;code&gt;not_supported&lt;/code&gt; がスローされます。Check &lt;code&gt;&lt;a href=&quot;#supports-0&quot;&gt;supports&lt;/a&gt;&lt;/code&gt; 、FIPSモードで使用可能なアルゴリズムの制限リストを返すことをサポートしています。</target>
        </trans-unit>
        <trans-unit id="9654a53fa988a8beebddaefffba6dff20182607b" translate="yes" xml:space="preserve">
          <source>In FIPS mode non-validated algorithms are disabled. This may cause some unexpected problems in application relying on crypto.</source>
          <target state="translated">FIPS モードでは、検証されていないアルゴリズムは無効になります。これは、暗号に依存するアプリケーションにおいて予期せぬ問題を引き起こす可能性があります。</target>
        </trans-unit>
        <trans-unit id="cfd282a1087eca416799317762a7b472853e3b7b" translate="yes" xml:space="preserve">
          <source>In German, the letter &quot;&amp;szlig;&quot; (sharp s) is in lower case, but the uppercase equivalent is &quot;SS&quot;.</source>
          <target state="translated">ドイツ語では、文字「&amp;szlig;」（シャープs）は小文字ですが、対応する大文字は「SS」です。</target>
        </trans-unit>
        <trans-unit id="b43a09972d3f89ca539f6f835ed50cfae17cb115" translate="yes" xml:space="preserve">
          <source>In Greek, the letter &quot;&amp;Sigma;&quot; has two different lowercase forms, &quot;&amp;sigmaf;&quot; in word-final position and &quot;&amp;sigma;&quot; elsewhere.</source>
          <target state="translated">ギリシャ語では、文字「&amp;Sigma;」には2つの異なる小文字形式があります。単語の最終位置にある「&amp;sigmaf;」とそれ以外の場所にある「&amp;sigma;」です。</target>
        </trans-unit>
        <trans-unit id="dbc72349c6922ca4db9e6cdf6ae70618450c536a" translate="yes" xml:space="preserve">
          <source>In OTP 19.1 a backwards incompatible change of the return tuple from &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; was made and the mandatory callback function &lt;code&gt;&lt;a href=&quot;#Module:callback_mode-0&quot;&gt; Module:callback_mode/0 &lt;/a&gt;&lt;/code&gt; was introduced.</source>
          <target state="translated">OTP 19.1では、 &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; からの戻りタプルの後方互換性のない変更が行われ、必須のコールバック関数 &lt;code&gt;&lt;a href=&quot;#Module:callback_mode-0&quot;&gt; Module:callback_mode/0 &lt;/a&gt;&lt;/code&gt; が導入されました。</target>
        </trans-unit>
        <trans-unit id="6e33a7d9a961a4a7fa95fde9918750cd7d701cd7" translate="yes" xml:space="preserve">
          <source>In OTP 20 it is desirable to remove all cipher suites that uses rsa kexchange (removed from default in 21)</source>
          <target state="translated">OTP20では、rsa kexchangeを使用する暗号スイートをすべて削除することが望ましい(21ではデフォルトから削除されている)。</target>
        </trans-unit>
        <trans-unit id="7d0e8cf6bf94176944af04a938b90942b47513e4" translate="yes" xml:space="preserve">
          <source>In OTP 20.0 &lt;code&gt;&lt;a href=&quot;#type-generic_timeout&quot;&gt; generic time-outs &lt;/a&gt;&lt;/code&gt; were added.</source>
          <target state="translated">OTP 20.0では、 &lt;code&gt;&lt;a href=&quot;#type-generic_timeout&quot;&gt; generic time-outs &lt;/a&gt;&lt;/code&gt; が追加されました。</target>
        </trans-unit>
        <trans-unit id="10e2f6c474b1b1d220a10a173940715aea514162" translate="yes" xml:space="preserve">
          <source>In OTP 22.1 time-out content &lt;code&gt;&lt;a href=&quot;#type-timeout_update_action&quot;&gt; update &lt;/a&gt;&lt;/code&gt; and explicit time-out &lt;code&gt;&lt;a href=&quot;#type-timeout_cancel_action&quot;&gt; cancel &lt;/a&gt;&lt;/code&gt; were added.</source>
          <target state="translated">OTP 22.1では、タイムアウトコンテンツの &lt;code&gt;&lt;a href=&quot;#type-timeout_update_action&quot;&gt; update &lt;/a&gt;&lt;/code&gt; と明示的なタイムアウト &lt;code&gt;&lt;a href=&quot;#type-timeout_cancel_action&quot;&gt; cancel &lt;/a&gt;&lt;/code&gt; が追加されました。</target>
        </trans-unit>
        <trans-unit id="622615c8bd1e5f7d554b06396b647aa8c7919009" translate="yes" xml:space="preserve">
          <source>In OTP 22.3 the possibility to change the callback module with actions &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;change_callback_module&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;push_callback_module&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;pop_callback_module&lt;/a&gt;&lt;/code&gt;, was added.</source>
          <target state="translated">OTP 22.3では、アクション &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;change_callback_module&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;push_callback_module&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;pop_callback_module&lt;/a&gt;&lt;/code&gt; を使用してコールバックモジュールを変更する可能性が追加されました。</target>
        </trans-unit>
        <trans-unit id="94dd0ef79035e7eb69969f59887721bb5f12a900" translate="yes" xml:space="preserve">
          <source>In OTP 23 distribution flag &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#DFLAG_BIG_CREATION&quot;&gt;DFLAG_BIG_CREATION&lt;/a&gt;&lt;/code&gt; became mandatory. All pids are now encoded using &lt;code&gt;NEW_PID_EXT&lt;/code&gt;, even external pids received as &lt;code&gt;&lt;a href=&quot;#PID_EXT&quot;&gt;PID_EXT&lt;/a&gt;&lt;/code&gt; from older nodes.</source>
          <target state="translated">OTP 23では、配布フラグ &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#DFLAG_BIG_CREATION&quot;&gt;DFLAG_BIG_CREATION&lt;/a&gt;&lt;/code&gt; が必須になりました。すべてのPIDは、現在使用してエンコードされ &lt;code&gt;NEW_PID_EXT&lt;/code&gt; 、として受信しても、外部のPID &lt;code&gt;&lt;a href=&quot;#PID_EXT&quot;&gt;PID_EXT&lt;/a&gt;&lt;/code&gt; 古いノードからを。</target>
        </trans-unit>
        <trans-unit id="86d163fad14d17015b8103733844b0e3f38ec8db" translate="yes" xml:space="preserve">
          <source>In OTP 23 distribution flag &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#DFLAG_BIG_CREATION&quot;&gt;DFLAG_BIG_CREATION&lt;/a&gt;&lt;/code&gt; became mandatory. All ports are now encoded using &lt;code&gt;NEW_PORT_EXT&lt;/code&gt;, even external ports received as &lt;code&gt;&lt;a href=&quot;#PORT_EXT&quot;&gt;PORT_EXT&lt;/a&gt;&lt;/code&gt; from older nodes.</source>
          <target state="translated">OTP 23では、配布フラグ &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#DFLAG_BIG_CREATION&quot;&gt;DFLAG_BIG_CREATION&lt;/a&gt;&lt;/code&gt; が必須になりました。古いノードから &lt;code&gt;&lt;a href=&quot;#PORT_EXT&quot;&gt;PORT_EXT&lt;/a&gt;&lt;/code&gt; として受信した外部ポートも &lt;code&gt;NEW_PORT_EXT&lt;/code&gt; 、すべてのポートがNEW_PORT_EXTを使用してエンコードされるようになりました。</target>
        </trans-unit>
        <trans-unit id="9a5fb5345ccfcb78e9b4e7ee07de85592dd8a9f4" translate="yes" xml:space="preserve">
          <source>In OTP 23 distribution flag &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#DFLAG_BIG_CREATION&quot;&gt;DFLAG_BIG_CREATION&lt;/a&gt;&lt;/code&gt; became mandatory. All references are now encoded using &lt;code&gt;NEWER_REFERENCE_EXT&lt;/code&gt;, even external references received as &lt;code&gt;&lt;a href=&quot;#NEW_REFERENCE_EXT&quot;&gt;NEW_REFERENCE_EXT&lt;/a&gt;&lt;/code&gt; from older nodes.</source>
          <target state="translated">OTP 23では、配布フラグ &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#DFLAG_BIG_CREATION&quot;&gt;DFLAG_BIG_CREATION&lt;/a&gt;&lt;/code&gt; が必須になりました。古いノードから &lt;code&gt;&lt;a href=&quot;#NEW_REFERENCE_EXT&quot;&gt;NEW_REFERENCE_EXT&lt;/a&gt;&lt;/code&gt; として受信した外部参照も &lt;code&gt;NEWER_REFERENCE_EXT&lt;/code&gt; 、すべての参照はNEWER_REFERENCE_EXTを使用してエンコードされるようになりました。</target>
        </trans-unit>
        <trans-unit id="3265c64793aa53ad0a1577895b26f55843cba1fb" translate="yes" xml:space="preserve">
          <source>In OTP R16, modules are loaded without blocking the VM. Erlang processes may continue executing undisturbed in parallel during the entire load operation. The code loading is carried out by a normal Erlang process that is scheduled like all the others. The load operation is completed by making the loaded code visible to all processes in a consistent way with one single atomic instruction. Non-blocking code loading will improve real-time characteristics when modules are loaded/upgraded on a running SMP system.</source>
          <target state="translated">OTP R16では、VMをブロックすることなくモジュールがロードされます。Erlangプロセスはロード操作の間、中断されることなく並列に実行し続けることができます。コードのロードは他のすべてのプロセスと同じようにスケジュールされた通常のErlangプロセスによって行われます。ロード操作は、ロードされたコードを1つのアトミック命令ですべてのプロセスに一貫して見えるようにすることで完了します。ノンブロッキングコードのロードは、実行中のSMPシステム上でモジュールをロード/アップグレードする際のリアルタイム性を向上させます。</target>
        </trans-unit>
        <trans-unit id="12e0125ea56af5dfd2fd2fd039ae24bfa32ef473" translate="yes" xml:space="preserve">
          <source>In OTP R16, the options were simplified. The back end is chosen using one of the options &lt;code&gt;ber&lt;/code&gt;, &lt;code&gt;per&lt;/code&gt;, &lt;code&gt;uper&lt;/code&gt; or &lt;code&gt;jer&lt;/code&gt;. Options &lt;code&gt;optimize&lt;/code&gt;, &lt;code&gt;nif&lt;/code&gt;, and &lt;code&gt;driver&lt;/code&gt; options are no longer necessary (and the ASN.1 compiler generates a warning if they are used). Options &lt;code&gt;ber_bin&lt;/code&gt;, &lt;code&gt;per_bin&lt;/code&gt;, and &lt;code&gt;uper_bin&lt;/code&gt; options still work, but generates a warning.</source>
          <target state="translated">OTP R16では、オプションが簡略化されました。バックエンドは、オプション &lt;code&gt;ber&lt;/code&gt; 、 &lt;code&gt;per&lt;/code&gt; 、 &lt;code&gt;uper&lt;/code&gt; 、または &lt;code&gt;jer&lt;/code&gt; のいずれかを使用して選択されます。オプション &lt;code&gt;optimize&lt;/code&gt; 、 &lt;code&gt;nif&lt;/code&gt; 、および &lt;code&gt;driver&lt;/code&gt; オプションは不要になりました（ASN.1コンパイラーは、それらが使用された場合に警告を生成します）。オプション &lt;code&gt;ber_bin&lt;/code&gt; 、 &lt;code&gt;per_bin&lt;/code&gt; 、および &lt;code&gt;uper_bin&lt;/code&gt; オプションは引き続き機能しますが、警告が生成されます。</target>
        </trans-unit>
        <trans-unit id="6c8d7cdc42675f7eb3ae5329539c1c0357e28904" translate="yes" xml:space="preserve">
          <source>In OTP R16, the options were simplified. The back end is chosen using one of the options &lt;code&gt;ber&lt;/code&gt;, &lt;code&gt;per&lt;/code&gt;, or &lt;code&gt;uper&lt;/code&gt;. Options &lt;code&gt;optimize&lt;/code&gt;, &lt;code&gt;nif&lt;/code&gt;, and &lt;code&gt;driver&lt;/code&gt; options are no longer necessary (and the ASN.1 compiler generates a warning if they are used). Options &lt;code&gt;ber_bin&lt;/code&gt;, &lt;code&gt;per_bin&lt;/code&gt;, and &lt;code&gt;uper_bin&lt;/code&gt; options still work, but generates a warning.</source>
          <target state="translated">OTP R16では、オプションが簡素化されました。バックエンドは、 &lt;code&gt;ber&lt;/code&gt; 、 &lt;code&gt;per&lt;/code&gt; 、 &lt;code&gt;uper&lt;/code&gt; のいずれかのオプションを使用して選択されます。オプション &lt;code&gt;optimize&lt;/code&gt; 、 &lt;code&gt;nif&lt;/code&gt; 、および &lt;code&gt;driver&lt;/code&gt; オプションは不要になりました（使用すると、ASN.1コンパイラーは警告を生成します）。オプション &lt;code&gt;ber_bin&lt;/code&gt; 、 &lt;code&gt;per_bin&lt;/code&gt; 、および &lt;code&gt;uper_bin&lt;/code&gt; オプションは引き続き機能しますが、警告が生成されます。</target>
        </trans-unit>
        <trans-unit id="7beb2f37419ff75d8af6c1507fb66b318ae63c2b" translate="yes" xml:space="preserve">
          <source>In OTP R16, trace breakpoints are set in the code without blocking the VM. Erlang processes may continue executing undisturbed in parallel during the entire operation. The same base technique is used as for code loading. A staging area of breakpoints is prepared and then made active with a single atomic operation.</source>
          <target state="translated">OTP R16では、VMをブロックすることなくコード内にトレースブレークポイントが設定されます。Erlangプロセスは操作の間、中断されることなく並列に実行し続けることができます。基本的なテクニックはコードのロードと同じです。ブレークポイントのステージングエリアが用意され、1つのアトミック操作でアクティブになります。</target>
        </trans-unit>
        <trans-unit id="d070e27ec63b672cbbc0cd22453c8a0bbd814f44" translate="yes" xml:space="preserve">
          <source>In OTP releases before R9C, the abstract code after some more processing was stored in the Beam file. The first element of the tuple would be either &lt;code&gt;abstract_v1&lt;/code&gt; (in OTP R7B) or &lt;code&gt;abstract_v2&lt;/code&gt; (in OTP R8B).</source>
          <target state="translated">R9C以前のOTPリリースでは、さらに処理を行った後の抽象コードがBeamファイルに格納されていました。タプルの最初の要素は、 &lt;code&gt;abstract_v1&lt;/code&gt; （OTP R7Bの場合）または &lt;code&gt;abstract_v2&lt;/code&gt; （OTP R8Bの場合）のいずれかです。</target>
        </trans-unit>
        <trans-unit id="921af396e8f5461445f280e270dd2b5414708d3b" translate="yes" xml:space="preserve">
          <source>In OTP, &lt;strong&gt;application&lt;/strong&gt; denotes a component implementing some specific functionality, that can be started and stopped as a unit, and that can be reused in other systems. This module interacts with &lt;strong&gt;application controller&lt;/strong&gt;, a process started at every Erlang runtime system. This module contains functions for controlling applications (for example, starting and stopping applications), and functions to access information about applications (for example, configuration parameters).</source>
          <target state="translated">OTPでは、&lt;strong&gt;アプリケーションと&lt;/strong&gt;は、特定の機能を実装するコンポーネントを意味し&lt;strong&gt;ます。これ&lt;/strong&gt;は、1つの単位として開始および停止でき、他のシステムで再利用できます。このモジュールは、すべてのErlangランタイムシステムで開始されるプロセスである&lt;strong&gt;アプリケーションコントローラー&lt;/strong&gt;と対話し&lt;strong&gt;ます&lt;/strong&gt;。このモジュールには、アプリケーションを制御するための関数（たとえば、アプリケーションの起動と停止）と、アプリケーションに関する情報にアクセスするための関数（たとえば、構成パラメーター）が含まれています。</target>
        </trans-unit>
        <trans-unit id="eca3632f8a0f156b49e9fa89891e0ee96a189926" translate="yes" xml:space="preserve">
          <source>In OTP, an &lt;strong&gt;event manager&lt;/strong&gt; is a named object to which events can be sent. An &lt;strong&gt;event&lt;/strong&gt; can be, for example, an error, an alarm, or some information that is to be logged.</source>
          <target state="translated">OTPでは、&lt;strong&gt;イベントマネージャ&lt;/strong&gt;はイベントを送信できる名前付きオブジェクトです。&lt;strong&gt;イベントは&lt;/strong&gt;、例えば、エラー、アラーム、またはログに記録されるいくつかの情報とすることができます。</target>
        </trans-unit>
        <trans-unit id="457a0e3d6ddd599be8d5102b7c849920a5dc095d" translate="yes" xml:space="preserve">
          <source>In OTP-21 the default primary log level is &lt;code&gt;notice&lt;/code&gt;. The means that many log messages are by default not printed. This includes the progress reports of supervisors. In order to get progress reports you need to raise the primary log level to &lt;code&gt;info&lt;/code&gt;</source>
          <target state="translated">OTP-21では、デフォルトのプライマリログレベルは &lt;code&gt;notice&lt;/code&gt; です。これは、多くのログメッセージがデフォルトで印刷されないことを意味します。これには、監督者の進捗レポートが含まれます。進捗レポートを取得するには、プライマリログレベルを &lt;code&gt;info&lt;/code&gt; に上げる必要があります</target>
        </trans-unit>
        <trans-unit id="d287ac5001b044c81427ccf014f3ddfd35b4ee5b" translate="yes" xml:space="preserve">
          <source>In OpenSSH</source>
          <target state="translated">OpenSSH で</target>
        </trans-unit>
        <trans-unit id="a90aedd16eab7e90ca5158413abefdf208107564" translate="yes" xml:space="preserve">
          <source>In PCRE, a subpattern can be named in one of three ways: &lt;code&gt;(?&amp;lt;name&amp;gt;...)&lt;/code&gt; or &lt;code&gt;(?'name'...)&lt;/code&gt; as in Perl, or &lt;code&gt;(?P&amp;lt;name&amp;gt;...)&lt;/code&gt; as in Python. References to capturing parentheses from other parts of the pattern, such as back references, recursion, and conditions, can be made by name and by number.</source>
          <target state="translated">：PCREでは、サブパターンは3つの方法のいずれかで名前を付けることができます &lt;code&gt;(?&amp;lt;name&amp;gt;...)&lt;/code&gt; または &lt;code&gt;(?'name'...)&lt;/code&gt; はPerlのように、または &lt;code&gt;(?P&amp;lt;name&amp;gt;...)&lt;/code&gt; のようにPython。後方参照、再帰、条件など、パターンの他の部分から括弧をキャプチャするための参照は、名前と番号で行うことができます。</target>
        </trans-unit>
        <trans-unit id="256aeea3c9968f0c93cc31456d90fd25ae389948" translate="yes" xml:space="preserve">
          <source>In PCRE, it matches &quot;bab&quot;. The first capturing parentheses match &quot;b&quot;, then in the second group, when the back reference \1 fails to match &quot;b&quot;, the second alternative matches &quot;a&quot;, and then recurses. In the recursion, \1 does now match &quot;b&quot; and so the whole match succeeds. In Perl, the pattern fails to match because inside the recursive call \1 cannot access the externally set value.</source>
          <target state="translated">PCREでは、&quot;bab &quot;にマッチします。最初の捕獲括弧は &quot;b &quot;にマッチし、第2のグループでは、後方参照の\1が &quot;b &quot;にマッチしなかった場合、第2の代替案は &quot;a &quot;にマッチし、その後、再帰する。再帰では、\1 が &quot;b&quot; にマッチするようになり、全体のマッチが成功します。Perlでは、再帰呼び出しの中で、\1が外部から設定された値にアクセスできないため、パターンはマッチしません。</target>
        </trans-unit>
        <trans-unit id="1bdbe179924ece7a6399c61e126213e1ec2fdb03" translate="yes" xml:space="preserve">
          <source>In Perl, the sequences \l, \L, \u, and \U are recognized by its string handler and used to modify the case of following characters. PCRE does not support these escape sequences.</source>
          <target state="translated">Perl では、\l,\L,\u,\U は、文字列ハンドラで認識され、以下の文字の大文字小文字を変更するために使用されます。PCRE はこれらのエスケープシーケンスをサポートしていません。</target>
        </trans-unit>
        <trans-unit id="6c9f67deea2c96d4c87a2b517cca3a419aaafb51" translate="yes" xml:space="preserve">
          <source>In R4B and earlier versions of OTP, &lt;code&gt;include&lt;/code&gt; and &lt;code&gt;lib&lt;/code&gt; are situated under &lt;code&gt;OTPROOT/usr&lt;/code&gt;.</source>
          <target state="translated">R4B以前のバージョンのOTPでは、 &lt;code&gt;include&lt;/code&gt; および &lt;code&gt;lib&lt;/code&gt; は &lt;code&gt;OTPROOT/usr&lt;/code&gt; の下にあります。</target>
        </trans-unit>
        <trans-unit id="9a3afab8c285c30f15c650612a9e9a18aec7d293" translate="yes" xml:space="preserve">
          <source>In SNMP, the &lt;code&gt;set&lt;/code&gt; operation is atomic. Either all variables which are specified in a &lt;code&gt;set&lt;/code&gt; operation are changed, or none are changed. Therefore, the &lt;code&gt;set&lt;/code&gt; operation is divided into two phases. In the first phase, the new value of each variable is checked against the definition of the variable in the MIB. The following definitions are checked:</source>
          <target state="translated">SNMPでは、 &lt;code&gt;set&lt;/code&gt; 操作はアトミックです。 &lt;code&gt;set&lt;/code&gt; 演算で指定されたすべての変数が変更されるか、何も変更されません。したがって、 &lt;code&gt;set&lt;/code&gt; 演算は2つのフェーズに分けられます。最初のフェーズでは、各変数の新しい値がMIB内の変数の定義に対してチェックされます。次の定義がチェックされます。</target>
        </trans-unit>
        <trans-unit id="021a1af44ce27aa9f05d1c38410af20ca7b60806" translate="yes" xml:space="preserve">
          <source>In SNMPv1 and SNMPv2c, the community string in the message was used for (at least) three different purposes:</source>
          <target state="translated">SNMPv1およびSNMPv2cでは、メッセージ内のコミュニティ文字列は(少なくとも)3つの異なる目的で使用されていました。</target>
        </trans-unit>
        <trans-unit id="02cb323587a2984dde2a87bd71f9d85e1a736a34" translate="yes" xml:space="preserve">
          <source>In SNMPv3, each of these usage areas has its own unique mechanism. A context is identified by the name of the SNMP entity, &lt;code&gt;contextEngineID&lt;/code&gt;, and the name of the context, &lt;code&gt;contextName&lt;/code&gt;. Each SNMPv3 message contains values for these two parameters.</source>
          <target state="translated">SNMPv3では、これらの使用領域ごとに独自のメカニズムがあります。コンテキストは、SNMPエンティティの名前である &lt;code&gt;contextName&lt;/code&gt; コンテキストの名前である &lt;code&gt;contextEngineID&lt;/code&gt; で識別されます。各SNMPv3メッセージには、これら2つのパラメーターの値が含まれています。</target>
        </trans-unit>
        <trans-unit id="c5e1bb8d75f3351aa564c900b00a6b87a8524ac7" translate="yes" xml:space="preserve">
          <source>In TLS 1.3 the session reuse is replaced by a new session tickets mechanism based on the pre shared key concept. This mechanism also obsoletes the session tickets from RFC5077, not implemented by this application. See also &lt;code&gt;Session Tickets and Session Resumption in TLS-1.3 &lt;/code&gt;</source>
          <target state="translated">TLS 1.3では、セッションの再利用は、事前共有キーの概念に基づく新しいセッションチケットメカニズムに置き換えられています。このメカニズムは、このアプリケーションでは実装されていないRFC5077のセッションチケットも廃止します。 &lt;code&gt;Session Tickets and Session Resumption in TLS-1.3 &lt;/code&gt; も参照してください。</target>
        </trans-unit>
        <trans-unit id="5895f59f593a11e2ddc456b6ee6229093c87afb4" translate="yes" xml:space="preserve">
          <source>In Turkish, both dotted and dotless &quot;i&quot; exist in lower case and upper case forms.</source>
          <target state="translated">トルコ語では、ドット付きの「i」もドットなしの「i」も小文字と大文字で存在します。</target>
        </trans-unit>
        <trans-unit id="878884e2dc7ceb0c8586c874280425307fca0f37" translate="yes" xml:space="preserve">
          <source>In UTF-8 mode, characters with values &amp;gt; 255 (0xffff) can be included in a class as a literal string of data units, or by using the \x{ escaping mechanism.</source>
          <target state="translated">UTF-8モードでは、255より大きい値（0xffff）の文字を、データ単位のリテラル文字列として、または\ x {エスケープメカニズムを使用してクラスに含めることができます。</target>
        </trans-unit>
        <trans-unit id="0723db02fb1375caa6de0f6695a31f67e99a568d" translate="yes" xml:space="preserve">
          <source>In Unicode filename mode, filenames given to BIF &lt;code&gt;open_port/2&lt;/code&gt; with option &lt;code&gt;{spawn_executable,...}&lt;/code&gt; are also interpreted as Unicode. So is the parameter list specified in option &lt;code&gt;args&lt;/code&gt; available when using &lt;code&gt;spawn_executable&lt;/code&gt;. The UTF-8 translation of arguments can be avoided using binaries, see section &lt;code&gt;&lt;a href=&quot;#notes-about-raw-filenames&quot;&gt;Notes About Raw Filenames&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Unicodeファイル名モードでは、オプション &lt;code&gt;{spawn_executable,...}&lt;/code&gt; BIF &lt;code&gt;open_port/2&lt;/code&gt; に指定されたファイル名もUnicodeとして解釈されます。そのため、 &lt;code&gt;spawn_executable&lt;/code&gt; を使用するときに使用できるオプション &lt;code&gt;args&lt;/code&gt; 指定されたパラメーターリストも同様です。バイナリを使用すると、引数のUTF-8変換を回避できます。「 &lt;code&gt;&lt;a href=&quot;#notes-about-raw-filenames&quot;&gt;Notes About Raw Filenames&lt;/a&gt;&lt;/code&gt; 参照してください。</target>
        </trans-unit>
        <trans-unit id="19f2c130abf603c133bbd0f5a1747bb0969bbb8c" translate="yes" xml:space="preserve">
          <source>In Unicode mode, quantifiers apply to characters rather than to individual data units. Thus, for example, \x{100}{2} matches two characters, each of which is represented by a 2-byte sequence in a UTF-8 string. Similarly, \X{3} matches three Unicode extended grapheme clusters, each of which can be many data units long (and they can be of different lengths).</source>
          <target state="translated">Unicode モー ド では、 量詞は個々のデー タ 単位ではな く キ ャ ラ ク タ に適用 さ れます。したがって、たとえば Æx{100}{2}は 2 文字にマッチします。同様に、「\X{3}」は3つのUnicode拡張書記素クラスタにマッチしますが、それぞれのクラスタは何個ものデータ単位の長さになることがあります(長さも様々です)。</target>
        </trans-unit>
        <trans-unit id="a58382bb2f1e4ec5560be47f72bd53dd8fd73e07" translate="yes" xml:space="preserve">
          <source>In Unicode mode, two more characters whose code points are &amp;gt; 255 are added: LS (line separator, U+2028) and PS (paragraph separator, U+2029). Unicode character property support is not needed for these characters to be recognized.</source>
          <target state="translated">Unicodeモードでは、コードポイントが255を超える2つの文字が追加されます：LS（行区切り、U + 2028）とPS（段落区切り、U + 2029）。これらの文字を認識するために、Unicode文字プロパティのサポートは必要ありません。</target>
        </trans-unit>
        <trans-unit id="b9bcf8117b716659d525a533ec0fd6a684678ba1" translate="yes" xml:space="preserve">
          <source>In Windows, all directory separators are forward slashes and the drive letter is in lower case.</source>
          <target state="translated">Windowsでは、ディレクトリの区切り文字はすべてフォワードスラッシュで、ドライブレターは小文字になります。</target>
        </trans-unit>
        <trans-unit id="ad12d1518ecf9a65e8a75f2907c07a876915311c" translate="yes" xml:space="preserve">
          <source>In Windows, all functions return filenames with forward slashes only, even if the arguments contain backslashes. To normalize a filename by removing redundant directory separators, use &lt;code&gt;&lt;a href=&quot;#join-1&quot;&gt;join/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Windowsでは、引数にバックスラッシュが含まれている場合でも、すべての関数がスラッシュのみのファイル名を返します。冗長なディレクトリセパレータを削除してファイル名を正規化するには、 &lt;code&gt;&lt;a href=&quot;#join-1&quot;&gt;join/1&lt;/a&gt;&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="3ef00d820ea8134fdb18c86e4ae50113bc762dcc" translate="yes" xml:space="preserve">
          <source>In a .config file:</source>
          <target state="translated">.configファイルの中で。</target>
        </trans-unit>
        <trans-unit id="fd45d713b47049d2ce36151c1dc290fc396f5a95" translate="yes" xml:space="preserve">
          <source>In a CTH, behavior can be hooked in after the following functions:</source>
          <target state="translated">CTHでは、以下の機能の後に動作をフックインすることができます。</target>
        </trans-unit>
        <trans-unit id="0a4189b805358c6e1539d1f92304f2c6381b6deb" translate="yes" xml:space="preserve">
          <source>In a CTH, the behavior can be hooked in before the following functions:</source>
          <target state="translated">CTHでは、以下の機能の前に動作をフックインすることができます。</target>
        </trans-unit>
        <trans-unit id="effbd836389d7d8b463c9fd530b435aef42b51ae" translate="yes" xml:space="preserve">
          <source>In a KDE environment, select &lt;strong&gt;KDE Control Center (Personal Settings)&lt;/strong&gt; &amp;gt; &lt;strong&gt;Regional and Accessibility&lt;/strong&gt; &amp;gt; &lt;strong&gt;Keyboard Layout&lt;/strong&gt;.</source>
          <target state="translated">KDE環境で、[ &lt;strong&gt;KDEコントロールセンター（個人設定）]&lt;/strong&gt; &amp;gt; [ &lt;strong&gt;地域とユーザー補助]&lt;/strong&gt; &amp;gt; [ &lt;strong&gt;キーボードレイアウト&lt;/strong&gt;&lt;strong&gt;]を&lt;/strong&gt;選択します。</target>
        </trans-unit>
        <trans-unit id="5ff429dd35571b630c89a291b69ebf06abbcfc55" translate="yes" xml:space="preserve">
          <source>In a Supervision Tree</source>
          <target state="translated">監修ツリーの中で</target>
        </trans-unit>
        <trans-unit id="33bc2d5f0d660142d0d63fc0df9ecd908613840a" translate="yes" xml:space="preserve">
          <source>In a UTF mode, PCRE does not allow the \C escape (which matches a single data unit even in a UTF mode) to appear in lookbehind assertions, as it makes it impossible to calculate the length of the lookbehind. The \X and \R escapes, which can match different numbers of data units, are not permitted either.</source>
          <target state="translated">UTFモードでは、PCREはlookbehindの長さを計算することができないため、lookbehindアサーションでは \Cエスケープ(UTFモードでも単一のデータユニットにマッチする)を許可しない。異なる数のデータユニットにマッチすることができる \Xおよび\Rエスケープも許可されていません。</target>
        </trans-unit>
        <trans-unit id="2c87d0f65600acbab54733adb07b3f71b63b4920" translate="yes" xml:space="preserve">
          <source>In a Unix (Bourne) shell, it can look as follows (line breaks are for readability, they are not to be there when typed):</source>
          <target state="translated">Unix (ボーン)シェルでは、以下のようになります (改行は読みやすくするためのもので、タイプしたときには存在しません)。</target>
        </trans-unit>
        <trans-unit id="9d1062a9134da719f643aea0a4d7fbb853ab2580" translate="yes" xml:space="preserve">
          <source>In a black-box testing scenario, &lt;code&gt;Common Test&lt;/code&gt;-based test programs connect to the target system(s) through standard O&amp;amp;M and CLI protocols. &lt;code&gt;Common Test&lt;/code&gt; provides implementations of, and wrapper interfaces to, some of these protocols (most of which exist as standalone components and applications in OTP). The wrappers simplify configuration and add verbosity for logging purposes. &lt;code&gt;Common Test&lt;/code&gt; is continously extended with useful support modules. However, notice that it is a straightforward task to use any Erlang/OTP component for testing purposes with &lt;code&gt;Common Test&lt;/code&gt;, without needing a &lt;code&gt;Common Test&lt;/code&gt; wrapper for it. It is as simple as calling Erlang functions. A number of target-independent interfaces are supported in &lt;code&gt;Common Test&lt;/code&gt;, such as Generic Telnet and FTP. These can be specialized or used directly for controlling instruments, traffic load generators, and so on.</source>
          <target state="translated">ブラックボックステストシナリオでは、 &lt;code&gt;Common Test&lt;/code&gt; ベースのテストプログラムは、標準のO＆MおよびCLIプロトコルを介してターゲットシステムに接続します。 &lt;code&gt;Common Test&lt;/code&gt; は、これらのプロトコルの一部（OTPではスタンドアロンコンポーネントおよびアプリケーションとして存在する）の実装およびそれらへのラッパーインターフェイスを提供します。ラッパーは、構成を簡素化し、ロギングの目的で詳細度を追加します。 &lt;code&gt;Common Test&lt;/code&gt; は、便利なサポートモジュールで継続的に拡張されています。ただし、 &lt;code&gt;Common Test&lt;/code&gt; ラッパーを必要とせずに、 &lt;code&gt;Common Test&lt;/code&gt; でのテスト目的で任意のErlang / OTPコンポーネントを使用することは簡単なタスクであることに注意してください。 Erlang関数を呼び出すのと同じくらい簡単です。多くのターゲットに依存しないインターフェースがサポートされています &lt;code&gt;Common Test&lt;/code&gt; Generic TelnetやFTPなどの一般的なテスト。これらは、計測器、トラフィック負荷ジェネレータなどを制御するために特化するか、直接使用できます。</target>
        </trans-unit>
        <trans-unit id="c1500508d272e3e1ef6dd2792fe28503800aeebb" translate="yes" xml:space="preserve">
          <source>In a callback module:</source>
          <target state="translated">コールバックモジュールで</target>
        </trans-unit>
        <trans-unit id="87ab655f4b96d81d49f137e06e1185ae6b220c3d" translate="yes" xml:space="preserve">
          <source>In a debug-compiled emulator, &lt;code&gt;ASSERT(VALID_INSTR(next_pf));&lt;/code&gt; makes sure that &lt;code&gt;next_pf&lt;/code&gt; is a valid instruction (that is, that it points within the &lt;code&gt;process_main()&lt;/code&gt; function in &lt;code&gt;beam_emu.c&lt;/code&gt;).</source>
          <target state="translated">デバッグコンパイルされたエミュレーターでは、 &lt;code&gt;ASSERT(VALID_INSTR(next_pf));&lt;/code&gt; &lt;code&gt;next_pf&lt;/code&gt; が有効な命令であることを確認します（つまり、 &lt;code&gt;beam_emu.c&lt;/code&gt; の &lt;code&gt;process_main()&lt;/code&gt; 関数内を指していることを確認します）。</target>
        </trans-unit>
        <trans-unit id="f3b8b640abb829ff4cbfb271a5e40f88ec8ec137" translate="yes" xml:space="preserve">
          <source>In a distributed Erlang system, it is sometimes useful to connect to a node without also connecting to all other nodes. An example is some kind of O&amp;amp;M functionality used to inspect the status of a system, without disturbing it. For this purpose, a &lt;strong&gt;hidden node&lt;/strong&gt; can be used.</source>
          <target state="translated">分散Erlangシステムでは、他のすべてのノードに接続せずにノードに接続すると便利な場合があります。例としては、システムの状態を乱さずに検査するために使用される、ある種のO＆M機能があります。この目的のために、&lt;strong&gt;非表示ノード&lt;/strong&gt;を使用できます。</target>
        </trans-unit>
        <trans-unit id="4aec9cfbd2b5a5b825d96878372130aac2263b76" translate="yes" xml:space="preserve">
          <source>In a distributed system with several Erlang nodes, it can be necessary to control applications in a distributed manner. If the node, where a certain application is running, goes down, the application is to be restarted at another node.</source>
          <target state="translated">複数のErlangノードを持つ分散システムでは、分散した方法でアプリケーションを制御する必要があります。あるアプリケーションが動作しているノードがダウンした場合、別のノードでアプリケーションを再起動する必要があります。</target>
        </trans-unit>
        <trans-unit id="23225511bfc3875384d2792bd043f1c701a2c0ca" translate="yes" xml:space="preserve">
          <source>In a future Erlang/OTP release, it might be implemented a way to (optionally) preserve sharing.</source>
          <target state="translated">将来の Erlang/OTP リリースでは、共有を保存する方法が実装されるかもしれません(オプションで)。</target>
        </trans-unit>
        <trans-unit id="4a6305081dfcb5f7cad2ca28aa531435457c8383" translate="yes" xml:space="preserve">
          <source>In a future release, a bad type for argument &lt;code&gt;Dir&lt;/code&gt; will probably generate an exception.</source>
          <target state="translated">将来のリリースでは、引数 &lt;code&gt;Dir&lt;/code&gt; のタイプが正しくないと、例外が発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="1a6542a84ddb6812f9a19d1cc7c1b8efff7c3a54" translate="yes" xml:space="preserve">
          <source>In a future release, a bad type for argument &lt;code&gt;Filename&lt;/code&gt; will probably generate an exception.</source>
          <target state="translated">将来のリリースでは、引数 &lt;code&gt;Filename&lt;/code&gt; のタイプが正しくないと、例外が発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="f07b31928724d837c06543b0d4ac70cbfb01f2cb" translate="yes" xml:space="preserve">
          <source>In a future release, this function may return more values and ranges. To avoid compatibility problems, it is recommended to use function &lt;code&gt;&lt;a href=&quot;io_lib#printable_list-1&quot;&gt; io_lib:printable_list/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">将来のリリースでは、この関数はより多くの値と範囲を返す可能性があります。互換性の問題を回避するために、関数 &lt;code&gt;&lt;a href=&quot;io_lib#printable_list-1&quot;&gt; io_lib:printable_list/1&lt;/a&gt;&lt;/code&gt; を使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="f9e2eab173886fa1c16faadaf18c5a216f901d1c" translate="yes" xml:space="preserve">
          <source>In a future release, this function may return more values and ranges. To avoid compatibility problems, it is recommended to use function &lt;code&gt;&lt;a href=&quot;io_lib#printable_list-1&quot;&gt;io_lib:printable_list/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">将来のリリースでは、この関数はさらに多くの値と範囲を返す可能性があります。互換性の問題を回避するには、関数 &lt;code&gt;&lt;a href=&quot;io_lib#printable_list-1&quot;&gt;io_lib:printable_list/1&lt;/a&gt;&lt;/code&gt; を使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="ab65a5239391014eb913ce30baf2efae7d72ed7b" translate="yes" xml:space="preserve">
          <source>In a larger pattern, keeping track of parenthesis numbers can be tricky. This is made easier by the use of relative references. Instead of (?1) in the pattern above, you can write (?-2) to refer to the second most recently opened parentheses preceding the recursion. That is, a negative number counts capturing parentheses leftwards from the point at which it is encountered.</source>
          <target state="translated">大きなパターンでは、括弧の数字を追跡するのは厄介です。これは相対参照を使用することで簡単になります。上のパターンの(?1)の代わりに、(?-2)と書くことで、再帰の前に開いた2番目に最近開いた括弧を参照することができます。つまり、負の数は、それが遭遇した時点から左に向かって括弧をキャプチャすることをカウントします。</target>
        </trans-unit>
        <trans-unit id="521f7cdd5ab3fc62df36d3dfb682c92be20244f3" translate="yes" xml:space="preserve">
          <source>In a larger system with a user (in this case an MGC) distributed over several Erlang nodes, it looks a little bit different. Here the encoding is performed on the originating Erlang node (1) and the binary is forwarded to the node (2) with the physical network interface. When the potential message reply is received on the interface on node (2), it is decoded there and then different actions will be taken for each transaction in the message. The transaction reply will be forwarded in its decoded form to the originating node (1) while the other types of transactions will be handled locally on node (2).</source>
          <target state="translated">ユーザ(この場合はMGC)が複数のErlangノードに分散している大規模なシステムでは、少し違って見えます。ここではエンコーディングは発信元のErlangノード(1)で行われ、バイナリは物理的なネットワークインターフェースを持つノード(2)に転送されます。潜在的なメッセージの返信がノード(2)のインターフェースで受信されると、そこでデコードされ、メッセージ内の各トランザクションに対して異なるアクションが実行されます。トランザクション返信は、他のタイプのトランザクションがノード(2)上でローカルに処理される間、そのデコードされた形で発信ノード(1)に転送される。</target>
        </trans-unit>
        <trans-unit id="976ebf70f5a3964ad2dc1b919f7c060f1cb37e38" translate="yes" xml:space="preserve">
          <source>In a manner similar to the function &lt;code&gt;mnesia:index_read/3&lt;/code&gt;, any index information can be used when trying to match records. This function takes a pattern that obeys the same rules as the function &lt;code&gt;mnesia:match_object/3&lt;/code&gt;, except that this function requires the following conditions:</source>
          <target state="translated">関数 &lt;code&gt;mnesia:index_read/3&lt;/code&gt; と同様の方法で、レコードを一致させようとするときに、任意のインデックス情報を使用できます。この関数は、関数 &lt;code&gt;mnesia:match_object/3&lt;/code&gt; と同じルールに従うパターンを取りますが、この関数には以下の条件が必要です。</target>
        </trans-unit>
        <trans-unit id="4c4bc3edae976085e9a0d189975eeda0ad921051" translate="yes" xml:space="preserve">
          <source>In a monotonically increasing sequence of values, all values that have a predecessor are either larger than or equal to its predecessor.</source>
          <target state="translated">単調に増加する値の列において、前任者を持つすべての値は、その前任者よりも大きいか、または等しいかのいずれかである。</target>
        </trans-unit>
        <trans-unit id="1ab70776fb35c924c17c1cd7488da7d1d0d285f9" translate="yes" xml:space="preserve">
          <source>In a new version of the release, the application &lt;code&gt;ch_app&lt;/code&gt; is to be included in &lt;code&gt;prim_app&lt;/code&gt;. That is, its topmost supervisor &lt;code&gt;ch_sup&lt;/code&gt; is to be started as a child process to &lt;code&gt;prim_sup&lt;/code&gt;.</source>
          <target state="translated">リリースの新しいバージョンでは、アプリケーション &lt;code&gt;ch_app&lt;/code&gt; がprim_appに含まれ &lt;code&gt;prim_app&lt;/code&gt; 。それは、その最上位のスーパーバイザ、ある &lt;code&gt;ch_sup&lt;/code&gt; は子プロセスとして開始する &lt;code&gt;prim_sup&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="274b316a1d6a226ddaa81a91a28524b871d26fde" translate="yes" xml:space="preserve">
          <source>In a pattern matching, a left-hand side &lt;code&gt;&lt;a href=&quot;expressions#pattern&quot;&gt;pattern&lt;/a&gt;&lt;/code&gt; is matched against a right-hand side &lt;code&gt;&lt;a href=&quot;expressions#term&quot;&gt;term&lt;/a&gt;&lt;/code&gt;. If the matching succeeds, any unbound variables in the pattern become bound. If the matching fails, a run-time error occurs.</source>
          <target state="translated">パターンマッチングでは、左側の &lt;code&gt;&lt;a href=&quot;expressions#pattern&quot;&gt;pattern&lt;/a&gt;&lt;/code&gt; が右側の &lt;code&gt;&lt;a href=&quot;expressions#term&quot;&gt;term&lt;/a&gt;&lt;/code&gt; と照合されます。マッチングが成功すると、パターン内のバインドされていない変数がバインドされます。照合が失敗すると、実行時エラーが発生します。</target>
        </trans-unit>
        <trans-unit id="a946839a1f3091d7ba3fdcd58b538b74992aa355" translate="yes" xml:space="preserve">
          <source>In a strictly monotonically increasing sequence of values, all values that have a predecessor are larger than its predecessor.</source>
          <target state="translated">厳密に単調に増加する値の列では、前任者を持つすべての値がその前任者よりも大きい。</target>
        </trans-unit>
        <trans-unit id="31ff33f4c7a5907d10bf958b213e55ba1dc343c7" translate="yes" xml:space="preserve">
          <source>In a supervision tree, many of the processes have similar structures, they follow similar patterns. For example, the supervisors are similar in structure. The only difference between them is which child processes they supervise. Many of the workers are servers in a server-client relation, finite-state machines, or event handlers such as error loggers.</source>
          <target state="translated">監督ツリーでは、プロセスの多くが似たような構造を持っており、似たようなパターンに従っています。例えば、監督者は構造が似ています。それらの間の唯一の違いは、どの子プロセスを監督するかということです。ワーカーの多くは、サーバ・クライアント関係のサーバ、有限状態マシン、エラーロガーなどのイベントハンドラです。</target>
        </trans-unit>
        <trans-unit id="3efaceff063003bf44950693b3f902b21784c28f" translate="yes" xml:space="preserve">
          <source>In a supervision tree, many of the processes have similar structures, they follow similar patterns. For example, the supervisors are similar in structure. The only difference between them is which child processes they supervise. Many of the workers are servers in a server-client relation, finite-state machines, or event handlers.</source>
          <target state="translated">監督ツリーでは、プロセスの多くが似たような構造を持っており、似たようなパターンに従っています。例えば、監督者は構造が似ています。それらの間の唯一の違いは、どの子プロセスを監督するかということです。ワーカーの多くは、サーバ・クライアント関係のサーバ、有限状態マシン、またはイベントハンドラです。</target>
        </trans-unit>
        <trans-unit id="bd210cc6dd528624657860bc47c1121fbe29a1ff" translate="yes" xml:space="preserve">
          <source>In a system implemented according to the OTP design principles, all processes, except system processes and special processes, reside in one of the behaviours &lt;code&gt;supervisor&lt;/code&gt;, &lt;code&gt;gen_server&lt;/code&gt;, &lt;code&gt;gen_fsm&lt;/code&gt;, &lt;code&gt;gen_statem&lt;/code&gt; or &lt;code&gt;gen_event&lt;/code&gt;. These belong to the STDLIB application and upgrading/downgrading normally requires an emulator restart.</source>
          <target state="translated">システム内のシステムプロセスと特別なプロセス、ビヘイビアの一つに存在する以外は、OTP設計原則、全てのプロセスに従って実施 &lt;code&gt;supervisor&lt;/code&gt; 、 &lt;code&gt;gen_server&lt;/code&gt; 、 &lt;code&gt;gen_fsm&lt;/code&gt; 、 &lt;code&gt;gen_statem&lt;/code&gt; 又は &lt;code&gt;gen_event&lt;/code&gt; 。これらはSTDLIBアプリケーションに属し、アップグレード/ダウングレードは通常エミュレータの再起動が必要です。</target>
        </trans-unit>
        <trans-unit id="554c457d1fb565b9a6393985044814faed4608a5" translate="yes" xml:space="preserve">
          <source>In a system of &lt;code&gt;Mnesia&lt;/code&gt; nodes, every node is aware of the current location of all tables. In this example, data is replicated on both nodes and functions that manipulate the data in the tables can be executed on either of the two nodes. Code that manipulate &lt;code&gt;Mnesia&lt;/code&gt; data behaves identically regardless of where the data resides.</source>
          <target state="translated">&lt;code&gt;Mnesia&lt;/code&gt; ノードのシステムでは、すべてのノードがすべてのテーブルの現在の場所を認識しています。この例では、データは両方のノードで複製され、テーブル内のデータを操作する関数は2つのノードのいずれかで実行できます。 &lt;code&gt;Mnesia&lt;/code&gt; データを操作するコードは、データがどこにあっても同じように動作します。</target>
        </trans-unit>
        <trans-unit id="8b48851f5568a382a621cc92c48317c0fa23d6e3" translate="yes" xml:space="preserve">
          <source>In a system structured according to the OTP design principles, any process would be a child process belonging to a supervisor, see &lt;code&gt;&lt;a href=&quot;#sup_add&quot;&gt;Adding and Deleting Child Processes&lt;/a&gt;&lt;/code&gt; in Changing a Supervisor.</source>
          <target state="translated">OTP設計原則に従って構築されたシステムでは、プロセスはすべてスーパーバイザに属する子プロセスになります。スーパーバイザの変更における &lt;code&gt;&lt;a href=&quot;#sup_add&quot;&gt;Adding and Deleting Child Processes&lt;/a&gt;&lt;/code&gt; 参照してください。</target>
        </trans-unit>
        <trans-unit id="44ba56c896fa716f74253d95bcea0e44a23d8f58" translate="yes" xml:space="preserve">
          <source>In a system that use comparatively few processes, performance &lt;strong&gt;might&lt;/strong&gt; be improved by increasing the minimum heap size using either the &lt;code&gt;+h&lt;/code&gt; option for &lt;code&gt;erl&lt;/code&gt; or on a process-per-process basis using the &lt;code&gt;min_heap_size&lt;/code&gt; option for &lt;code&gt;spawn_opt/4&lt;/code&gt;.</source>
          <target state="translated">比較的少数のプロセスを使用するシステムでは、 &lt;code&gt;erl&lt;/code&gt; に &lt;code&gt;+h&lt;/code&gt; オプションを使用するか、または &lt;code&gt;spawn_opt/4&lt;/code&gt; に &lt;code&gt;min_heap_size&lt;/code&gt; オプションを使用してプロセスごとに最小ヒープサイズを増やすことにより、パフォーマンス&lt;strong&gt;が&lt;/strong&gt;向上する&lt;strong&gt;可能性&lt;/strong&gt;が&lt;strong&gt;あり&lt;/strong&gt;ます。</target>
        </trans-unit>
        <trans-unit id="43f12319f42fd8dda78673d0ca45eab01cc78900" translate="yes" xml:space="preserve">
          <source>In a system with TCP-based distribution, this data is kept in the &lt;strong&gt;Erlang port mapper daemon&lt;/strong&gt; (&lt;code&gt;epmd&lt;/code&gt;), which is contacted when a distributed node starts. The lock file and a convention for the UDS listen socket's name remove the need for &lt;code&gt;epmd&lt;/code&gt; when using this distribution module. UDS is always restricted to one host, why avoiding a port mapper is easy.</source>
          <target state="translated">TCPベースの配布を使用するシステムでは、このデータは、分散ノードの起動時に&lt;strong&gt;接続&lt;/strong&gt;される&lt;strong&gt;Erlangポートマッパーデーモン&lt;/strong&gt;（ &lt;code&gt;epmd&lt;/code&gt; ）に保持されます。ロックファイルとUDSリスンソケットの名前の規則により、この配布モジュールを使用するときに &lt;code&gt;epmd&lt;/code&gt; が不要になります。UDSは常に1つのホストに制限されているため、ポートマッパーを回避するのは簡単です。</target>
        </trans-unit>
        <trans-unit id="5ccaddcd0c823bd477d387b9058aa0fc21906850" translate="yes" xml:space="preserve">
          <source>In a table monitored by SNMP, all elements must be integers, strings, or lists of integers.</source>
          <target state="translated">SNMPで監視されるテーブルでは、すべての要素は整数、文字列、または整数のリストでなければなりません。</target>
        </trans-unit>
        <trans-unit id="f62f7aaa3c520340c959fbaf0d8e529944b88886" translate="yes" xml:space="preserve">
          <source>In a target system, the release upgrade file is to be located in directory &lt;code&gt;$ROOT/releases/Vsn&lt;/code&gt;.</source>
          <target state="translated">ターゲットシステムでは、リリースアップグレードファイルはディレクトリ &lt;code&gt;$ROOT/releases/Vsn&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="6ac283a89487dcb253786b8bd6bb529084d29ffc" translate="yes" xml:space="preserve">
          <source>In a test suite, one must &lt;strong&gt;require&lt;/strong&gt; that a configuration variable (&lt;code&gt;CfgVarName&lt;/code&gt; in the previous definition) exists before attempting to read the associated value in a test case or configuration function.</source>
          <target state="translated">テストスイートでは、関連する値をテストケースまたは構成関数で読み取ろうとする前に、構成変数（前の定義では &lt;code&gt;CfgVarName&lt;/code&gt; ）が存在している&lt;strong&gt;必要&lt;/strong&gt;があります。</target>
        </trans-unit>
        <trans-unit id="4fb9fe0e283f20ff6583d865477e2f5797757ef1" translate="yes" xml:space="preserve">
          <source>In a tuple &lt;code&gt;{stylesheet,CSSFile}&lt;/code&gt;, if &lt;code&gt;CSSFile&lt;/code&gt; is specified with a path, for example, &lt;code&gt;&quot;$TEST/styles/categories.css&quot;&lt;/code&gt;, this full name is used to locate the file. However, if only the file name is specified, for example, &lt;code&gt;categories.css&lt;/code&gt;, the CSS file is assumed to be located in the data directory, &lt;code&gt;data_dir&lt;/code&gt;, of the suite. The latter use is recommended, as it is portable compared to hard coding path names in the suite.</source>
          <target state="translated">タプル &lt;code&gt;{stylesheet,CSSFile}&lt;/code&gt; で、 &lt;code&gt;CSSFile&lt;/code&gt; にパスが指定されている場合（例： &lt;code&gt;&quot;$TEST/styles/categories.css&quot;&lt;/code&gt; 、このフルネームを使用してファイルが検索されます。ただし、ファイル名のみが指定されている場合（例えば、 &lt;code&gt;categories.css&lt;/code&gt; ）、CSSファイルはスイートのデータディレクトリ &lt;code&gt;data_dir&lt;/code&gt; にあると想定されます。後者の使用は、スイートのハードコーディングパス名に比べて移植性があるため推奨されます。</target>
        </trans-unit>
        <trans-unit id="1286250e203085fab759937a2009fa429066e481" translate="yes" xml:space="preserve">
          <source>In absence of spawn operation failures, atomically sets up a link between the calling process and the newly created process. That is, as if the calling process had called &lt;code&gt;&lt;a href=&quot;#link-1&quot;&gt;link(Pid)&lt;/a&gt;&lt;/code&gt; where &lt;code&gt;Pid&lt;/code&gt; is the process identifier of the newly created process.</source>
          <target state="translated">スポーン操作の失敗がない場合、呼び出し元のプロセスと新しく作成されたプロセスの間にアトミックにリンクを設定します。つまり、呼び出し元のプロセスが &lt;code&gt;&lt;a href=&quot;#link-1&quot;&gt;link(Pid)&lt;/a&gt;&lt;/code&gt; を呼び出したかのようになります。ここで、 &lt;code&gt;Pid&lt;/code&gt; は新しく作成されたプロセスのプロセス識別子です。</target>
        </trans-unit>
        <trans-unit id="ea7833417b997c143c87f40d58a519fc4541a0bf" translate="yes" xml:space="preserve">
          <source>In addition to specifying a type letter, the actual value for the type can be specified. For example:</source>
          <target state="translated">型文字の指定に加えて、その型の実際の値を指定することができます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="1c5578dc50a0864bd8d9d5138f6fed8f654dd2af" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;code&gt;{Item,Value}&lt;/code&gt; pairs defined for &lt;code&gt;&lt;a href=&quot;#info-1&quot;&gt;info/1&lt;/a&gt;&lt;/code&gt;, the following items are allowed:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#info-1&quot;&gt;info/1&lt;/a&gt;&lt;/code&gt; に定義された &lt;code&gt;{Item,Value}&lt;/code&gt; ペアに加えて、次のアイテムが許可されます：</target>
        </trans-unit>
        <trans-unit id="1a79ac5033930298cd0d6e70aec5390fc42e348e" translate="yes" xml:space="preserve">
          <source>In addition to the Call Graph there is a graph called the  &lt;strong id=&quot;inter_call_graph&quot;&gt;Inter Call Graph&lt;/strong&gt;. This is a graph of calls (From, To) such that there is a chain of calls from From to To in the Call Graph, and every From and To is an exported function or an unused local function. The vertices are the same as for the Call Graph.</source>
          <target state="translated">コールグラフに加えて、&lt;strong id=&quot;inter_call_graph&quot;&gt;インターコールグラフ&lt;/strong&gt;と呼ばれるグラフがあり ます。これは呼び出し（From、To）のグラフで、コールグラフにはFromからToへの呼び出しのチェーンがあり、すべてのFromおよびToはエクスポートされた関数または未使用のローカル関数です。頂点はコールグラフと同じです。</target>
        </trans-unit>
        <trans-unit id="5ea131aa8ce39e0fad64d7f37053c449509534e3" translate="yes" xml:space="preserve">
          <source>In addition to the algorithms negotiated by the cipher suite used for key exchange, payload encryption, message authentication and pseudo random calculation, the TLS signature algorithm extension &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc5246.txt&quot;&gt;Section 7.4.1.4.1 in RFC 5246&lt;/a&gt;&lt;/code&gt; may be used, from TLS 1.2, to negotiate which signature algorithm to use during the TLS handshake. If no lower TLS versions than 1.2 are supported, the client will send a TLS signature algorithm extension with the algorithms specified by this option. Defaults to</source>
          <target state="translated">鍵交換、ペイロード暗号化、メッセージ認証、および疑似ランダム計算に使用される暗号スイートによってネゴシエートされるアルゴリズムに加えて、 &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc5246.txt&quot;&gt;Section 7.4.1.4.1 in RFC 5246&lt;/a&gt;&lt;/code&gt; TLS署名アルゴリズム拡張を使用して、TLS 1.2から、 TLSハンドシェイク中に使用する署名アルゴリズム。 1.2より前のTLSバージョンがサポートされていない場合、クライアントは、このオプションで指定されたアルゴリズムを使用してTLS署名アルゴリズム拡張を送信します。デフォルトは</target>
        </trans-unit>
        <trans-unit id="8211e020ecaee607aa2a72d41a52382183c4a8b5" translate="yes" xml:space="preserve">
          <source>In addition to the collection algorithm described above, the Erlang garbage collector also provides generational garbage collection. An additional heap, called the old heap, is used where the long lived data is stored. The original heap is called the young heap, or sometimes the allocation heap.</source>
          <target state="translated">上で説明した収集アルゴリズムに加えて、Erlangのガベージコレクタは世代別のガベージコレクションも提供しています。オールドヒープと呼ばれる追加のヒープが使われ、長い間保存されていたデータが保存されます。元のヒープはヤングヒープと呼ばれ、時にはアロケーションヒープと呼ばれることもあります。</target>
        </trans-unit>
        <trans-unit id="cfba226beccd4a1427fc9d1c6106071bf62f4d15" translate="yes" xml:space="preserve">
          <source>In addition to the documentation here Erlang is described in several recent books like:</source>
          <target state="translated">ここでのドキュメントに加えて、Erlangは最近の本でもいくつか説明されています。</target>
        </trans-unit>
        <trans-unit id="88d44d718b6e7d7989a95592c66be31f11e98097" translate="yes" xml:space="preserve">
          <source>In addition to the earlier:</source>
          <target state="translated">先ほどのものに加えて。</target>
        </trans-unit>
        <trans-unit id="890bb829697d00b41e1b4a5c52b5061881f7d784" translate="yes" xml:space="preserve">
          <source>In addition to the mandatory callback function &lt;code&gt;log/2&lt;/code&gt;, a handler module can export the optional callback functions &lt;code&gt;adding_handler/1&lt;/code&gt;, &lt;code&gt;changing_config/2&lt;/code&gt; and &lt;code&gt;removing_handler/1&lt;/code&gt;. See section &lt;code&gt;&lt;a href=&quot;logger#handler_callback_functions&quot;&gt;Handler Callback Functions&lt;/a&gt;&lt;/code&gt; in the logger(3) manual page for more information about these function.</source>
          <target state="translated">必須のコールバック関数に加えて、 &lt;code&gt;log/2&lt;/code&gt; 、ハンドラモジュールは、オプションのコールバック関数をエクスポートすることができ &lt;code&gt;adding_handler/1&lt;/code&gt; 、 &lt;code&gt;changing_config/2&lt;/code&gt; 及び &lt;code&gt;removing_handler/1&lt;/code&gt; 。これらの関数の詳細については、logger（3）マニュアルページの「 &lt;code&gt;&lt;a href=&quot;logger#handler_callback_functions&quot;&gt;Handler Callback Functions&lt;/a&gt;&lt;/code&gt; 」を参照してください。</target>
        </trans-unit>
        <trans-unit id="4485e35d13b31a5f17e0ec8540bc97bc5f63738e" translate="yes" xml:space="preserve">
          <source>In addition to the mandatory callback function &lt;code&gt;log/2&lt;/code&gt;, a handler module can export the optional callback functions &lt;code&gt;adding_handler/1&lt;/code&gt;, &lt;code&gt;changing_config/3&lt;/code&gt;, &lt;code&gt;filter_config/1&lt;/code&gt;, and &lt;code&gt;removing_handler/1&lt;/code&gt;. See section &lt;code&gt;&lt;a href=&quot;logger#handler_callback_functions&quot;&gt;Handler Callback Functions&lt;/a&gt;&lt;/code&gt; in the logger(3) manual page for more information about these function.</source>
          <target state="translated">必須のコールバック関数に加えて、 &lt;code&gt;log/2&lt;/code&gt; 、ハンドラモジュールは、オプションのコールバック関数をエクスポートすることができ &lt;code&gt;adding_handler/1&lt;/code&gt; 、 &lt;code&gt;changing_config/3&lt;/code&gt; 、 &lt;code&gt;filter_config/1&lt;/code&gt; 、及び &lt;code&gt;removing_handler/1&lt;/code&gt; 。これらの関数の詳細については、logger（3）のマニュアルページの「 &lt;code&gt;&lt;a href=&quot;logger#handler_callback_functions&quot;&gt;Handler Callback Functions&lt;/a&gt;&lt;/code&gt; 」のセクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="45082fc3acc3b9bc0e8feada04ef6474816b9ee7" translate="yes" xml:space="preserve">
          <source>In addition to the ordinary functions for receiving and sending files (see &lt;code&gt;recv/2&lt;/code&gt;, &lt;code&gt;recv/3&lt;/code&gt;, &lt;code&gt;send/2&lt;/code&gt;, and &lt;code&gt;send/3&lt;/code&gt;) there are functions for receiving remote files as binaries (see &lt;code&gt;recv_bin/2&lt;/code&gt;) and for sending binaries to be stored as remote files (see &lt;code&gt;send_bin/3&lt;/code&gt;).</source>
          <target state="translated">ファイルを受信および送信するための通常の関数（ &lt;code&gt;recv/2&lt;/code&gt; 、 &lt;code&gt;recv/3&lt;/code&gt; 、 &lt;code&gt;send/2&lt;/code&gt; 、および &lt;code&gt;send/3&lt;/code&gt; を参照）に加えて、リモートファイルをバイナリとして受信する（ &lt;code&gt;recv_bin/2&lt;/code&gt; を参照）ための関数と、バイナリをに送信するための関数があります。リモートファイルとして保存されます（ &lt;code&gt;send_bin/3&lt;/code&gt; を参照）。</target>
        </trans-unit>
        <trans-unit id="af29f18311535fbae0f8e4ae58bbff8300a8115f" translate="yes" xml:space="preserve">
          <source>In addition to the representations described earlier, the following deprecated representations are available if the specification has been compiled with option &lt;code&gt;legacy_erlang_types&lt;/code&gt;:</source>
          <target state="translated">前述の表現に加えて、仕様が &lt;code&gt;legacy_erlang_types&lt;/code&gt; オプションを使用してコンパイルされている場合は、次の非推奨の表現を使用できます。</target>
        </trans-unit>
        <trans-unit id="86f6f7e492ba3b7949f4b38c0a7d47daec6054a6" translate="yes" xml:space="preserve">
          <source>In addition to the representations of forms, the list that represents a module declaration (as returned by functions in &lt;code&gt;epp(3)&lt;/code&gt; and &lt;code&gt;erl_parse(3)&lt;/code&gt;) can contain the following:</source>
          <target state="translated">フォームの表現に加えて、モジュール宣言を表すリスト &lt;code&gt;epp(3)&lt;/code&gt; &lt;code&gt;erl_parse(3)&lt;/code&gt; およびerl_parse（3）の関数によって返される）には、以下を含めることができます。</target>
        </trans-unit>
        <trans-unit id="cd3b0823be609b58f269a346f9f2725dc8f84272" translate="yes" xml:space="preserve">
          <source>In addition to the signature_algorithms extension from TLS 1.2, &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc8446.txt#section-4.2.3&quot;&gt;TLS 1.3 (RFC 5246 Section 4.2.3)&lt;/a&gt;&lt;/code&gt;adds the signature_algorithms_cert extension which enables having special requirements on the signatures used in the certificates that differs from the requirements on digital signatures as a whole. If this is not required this extension is not needed.</source>
          <target state="translated">TLS 1.2のsignature_algorithms拡張機能に加えて、 &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc8446.txt#section-4.2.3&quot;&gt;TLS 1.3 (RFC 5246 Section 4.2.3)&lt;/a&gt;&lt;/code&gt; はsignature_algorithms_cert拡張機能を追加します。これにより、証明書で使用される署名に、デジタル署名全体の要件とは異なる特別な要件を設定できます。これが必要ない場合、この拡張機能は必要ありません。</target>
        </trans-unit>
        <trans-unit id="7ad8f4e74819a6f7578284e9cf32df82a24e4ca4" translate="yes" xml:space="preserve">
          <source>In addition to the standard Unicode properties described earlier, PCRE supports four more that make it possible to convert traditional escape sequences, such as \w and \s to use Unicode properties. PCRE uses these non-standard, non-Perl properties internally when the &lt;code&gt;ucp&lt;/code&gt; option is passed. However, they can also be used explicitly. The properties are as follows:</source>
          <target state="translated">前述の標準的なUnicodeプロパティに加えて、PCREは、\ wや\ sなどの従来のエスケープシーケンスを変換してUnicodeプロパティを使用できるようにする4つをサポートしています。PCREは、 &lt;code&gt;ucp&lt;/code&gt; オプションが渡されたときに、これらの非標準、非Perlプロパティを内部で使用します。ただし、明示的に使用することもできます。プロパティは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="698d80c93fc7667e3d673153ab193877506b308a" translate="yes" xml:space="preserve">
          <source>In addition to the static supervision tree, dynamic child processes can be added to an existing supervisor with the following call:</source>
          <target state="translated">静的な監視ツリーに加えて、動的な子プロセスは、以下の呼び出しで既存のスーパバイザに追加することができます。</target>
        </trans-unit>
        <trans-unit id="58454c75737b607a068b4e77b1a88fd258a15b57" translate="yes" xml:space="preserve">
          <source>In addition to the trace log file(s), a file with extension &lt;code&gt;.ti&lt;/code&gt; is created when Trace Tool Builder is started. This is the trace information file. It is a binary file, which contains the process information, trace flags used, the name of the node to which it belongs, and all information written with function &lt;code&gt;&lt;a href=&quot;ttb#write_trace_info-2&quot;&gt;ttb:write_trace_info/2&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;.ti&lt;/code&gt; files are always fetched with other logs when the trace is stopped.</source>
          <target state="translated">トレースログファイルに加えて、拡張子が &lt;code&gt;.ti&lt;/code&gt; のファイルがTrace Tool Builderの起動時に作成されます。トレース情報ファイルです。これは、プロセス情報、使用されるトレースフラグ、それが属するノードの名前、および関数 &lt;code&gt;&lt;a href=&quot;ttb#write_trace_info-2&quot;&gt;ttb:write_trace_info/2&lt;/a&gt;&lt;/code&gt; で書き込まれたすべての情報を含むバイナリファイルです。トレースが停止すると、 &lt;code&gt;.ti&lt;/code&gt; ファイルは常に他のログとともにフェッチされます。</target>
        </trans-unit>
        <trans-unit id="ead83cfe423b6f87966ff81fd05657fc8c719fd4" translate="yes" xml:space="preserve">
          <source>In addition to these options, &lt;strong&gt;raw&lt;/strong&gt; option specifications can be used. The raw options are specified as a tuple of arity four, beginning with tag &lt;code&gt;raw&lt;/code&gt;, followed by the protocol level, the option number, and the option value specified as a binary. This corresponds to the second, third, and fourth arguments to the &lt;code&gt;setsockopt&lt;/code&gt; call in the C socket API. The option value must be coded in the native endianess of the platform and, if a structure is required, must follow the structure alignment conventions on the specific platform.</source>
          <target state="translated">これらのオプションに加えて、&lt;strong&gt;生の&lt;/strong&gt;オプション仕様を使用できます。rawオプションは、タグ &lt;code&gt;raw&lt;/code&gt; で始まり、プロトコルレベル、オプション番号、およびバイナリとして指定されたオプション値が続くアリティ4のタプルとして指定されます。これは、CソケットAPIの &lt;code&gt;setsockopt&lt;/code&gt; 呼び出しの2番目、3番目、および4番目の引数に対応します。オプション値は、プラットフォームのネイティブエンディアンでコーディングする必要があり、構造が必要な場合は、特定のプラットフォームの構造整列規則に従う必要があります。</target>
        </trans-unit>
        <trans-unit id="ae1cf5f2bfcd3b60ef15c86d1e7f135dfc63d587" translate="yes" xml:space="preserve">
          <source>In addition to these, the following fields are automatically inserted by Logger, values taken from the two first parameters to &lt;code&gt;&lt;a href=&quot;#add_handler-3&quot;&gt;add_handler/3&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">これらに加えて、次のフィールドがLoggerによって自動的に挿入されます。値は、2つの最初のパラメーターから &lt;code&gt;&lt;a href=&quot;#add_handler-3&quot;&gt;add_handler/3&lt;/a&gt;&lt;/code&gt; に取得されます。</target>
        </trans-unit>
        <trans-unit id="e583d04eef0dfd18104660d17dcc9b07446e62d3" translate="yes" xml:space="preserve">
          <source>In addition to this introductory chapter, the &lt;code&gt;Event Tracers&lt;/code&gt; User's Guide contains the following chapters:</source>
          <target state="translated">この紹介の章に加えて、「 &lt;code&gt;Event Tracers&lt;/code&gt; User's Guide」には次の章が含まれています。</target>
        </trans-unit>
        <trans-unit id="fd1509d104b7597ab782042099faae460d5ff6b5" translate="yes" xml:space="preserve">
          <source>In addition to this introductory chapter, the Megaco User's Guide contains the following chapters:</source>
          <target state="translated">この入門編に加えて、Megacoユーザーズガイドには以下の章があります。</target>
        </trans-unit>
        <trans-unit id="5ad3911ee58ff673506ee22db5a2de1ed84850c6" translate="yes" xml:space="preserve">
          <source>In addition to this introductory chapter, the Reltool User's Guide contains the following chapters:</source>
          <target state="translated">この入門編に加えて、Reltool ユーザーズガイドには以下の章があります。</target>
        </trans-unit>
        <trans-unit id="7f5fdf190092c245c6414244e40560909cfcd608" translate="yes" xml:space="preserve">
          <source>In addition to this introductory chapter, the SNMP User's Guide contains the following chapters:</source>
          <target state="translated">この入門編に加えて、SNMP User's Guideには以下の章があります。</target>
        </trans-unit>
        <trans-unit id="fb294dab84ef10ba93b7376a3a5eeb757826cec4" translate="yes" xml:space="preserve">
          <source>In addition, &lt;code&gt;#Record.Name&lt;/code&gt; returns the index in the tuple representation of &lt;code&gt;Name&lt;/code&gt; of the record &lt;code&gt;Record&lt;/code&gt;.</source>
          <target state="translated">さらに、 &lt;code&gt;#Record.Name&lt;/code&gt; はレコード &lt;code&gt;Record&lt;/code&gt; の &lt;code&gt;Name&lt;/code&gt; のタプル表現でインデックスを返します。</target>
        </trans-unit>
        <trans-unit id="eec4f051098dd6dcb667d9032abc1d31d3cca680" translate="yes" xml:space="preserve">
          <source>In addition, EUnit will also look for another module whose name is &lt;code&gt;ModuleName&lt;/code&gt; plus the suffix &lt;code&gt;_tests&lt;/code&gt;, and if it exists, all the tests from that module will also be added. (If &lt;code&gt;ModuleName&lt;/code&gt; already contains the suffix &lt;code&gt;_tests&lt;/code&gt;, this is not done.) E.g., the specification &lt;code&gt;{module, mymodule}&lt;/code&gt; will run all tests in the modules &lt;code&gt;mymodule&lt;/code&gt; and &lt;code&gt;mymodule_tests&lt;/code&gt;. Typically, the &lt;code&gt;_tests&lt;/code&gt; module should only contain test cases that use the public interface of the main module (and no other code).</source>
          <target state="translated">また、EUNITも名前があり、別のモジュールを探します &lt;code&gt;ModuleName&lt;/code&gt; のプラス接尾辞 &lt;code&gt;_tests&lt;/code&gt; 、それが存在する場合、そのモジュールからのすべてのテストも追加されます。（場合 &lt;code&gt;ModuleName&lt;/code&gt; のが既にサフィックス含ま &lt;code&gt;_tests&lt;/code&gt; を、これを行わない。）、例えば、仕様 &lt;code&gt;{module, mymodule}&lt;/code&gt; モジュール内のすべてのテストを実行する &lt;code&gt;mymodule&lt;/code&gt; と &lt;code&gt;mymodule_tests&lt;/code&gt; 。通常、 &lt;code&gt;_tests&lt;/code&gt; モジュールには、メインモジュールのパブリックインターフェイスを使用する（他のコードは使用しない）テストケースのみを含める必要があります。</target>
        </trans-unit>
        <trans-unit id="ec506ee3c0304b67799c67e512b132d1927abb1c" translate="yes" xml:space="preserve">
          <source>In addition, table properties can be set and changed. For details, see &lt;code&gt;&lt;a href=&quot;mnesia_chap3#def_schema&quot;&gt;Define a Schema&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">さらに、テーブルのプロパティを設定および変更できます。詳細については、 &lt;code&gt;&lt;a href=&quot;mnesia_chap3#def_schema&quot;&gt;Define a Schema&lt;/a&gt;&lt;/code&gt; 参照してください。</target>
        </trans-unit>
        <trans-unit id="dfbb12ad016ab1664756254ead2ae4c40b6031b7" translate="yes" xml:space="preserve">
          <source>In addition, the following three built-in types exist and can be thought as defined below, though strictly their &quot;type definition&quot; is not valid syntax according to the type language defined above.</source>
          <target state="translated">また、以下の3つの組み込み型が存在し、以下に定義されているように考えることができますが、厳密にはそれらの「型の定義」は、上記で定義された型言語による有効な構文ではありません。</target>
        </trans-unit>
        <trans-unit id="2ba8529808e3d5d63f2c2cd138891fddd10121b3" translate="yes" xml:space="preserve">
          <source>In addition, the record fields can be further specified when using a record type by adding type information about the field as follows:</source>
          <target state="translated">また、レコード型を使用する際には、以下のようにフィールドの型情報を付加することで、レコード型のフィールドをさらに指定することができます。</target>
        </trans-unit>
        <trans-unit id="0c6af5a9419b35f362c885bc58714fd954a7c605" translate="yes" xml:space="preserve">
          <source>In addition, you'll probably want to familiarize yourself with the &lt;code&gt;dbg&lt;/code&gt; module and possibly &lt;code&gt;seq_trace&lt;/code&gt; module as well.</source>
          <target state="translated">さらに、おそらく &lt;code&gt;dbg&lt;/code&gt; モジュールと、場合によっては &lt;code&gt;seq_trace&lt;/code&gt; モジュールについても理解する必要があります。</target>
        </trans-unit>
        <trans-unit id="fb5db34bbd4674c5c25f061b695fba808bb59735" translate="yes" xml:space="preserve">
          <source>In all functions errors, &lt;code&gt;{'EXIT',{Reason,Backtrace}}&lt;/code&gt;, can be thrown, where &lt;code&gt;Reason&lt;/code&gt; describes the error.</source>
          <target state="translated">すべての関数エラーで、 &lt;code&gt;{'EXIT',{Reason,Backtrace}}&lt;/code&gt; がスローされることがあります。ここで、 &lt;code&gt;Reason&lt;/code&gt; はエラーを説明しています。</target>
        </trans-unit>
        <trans-unit id="fe9689d5a6e2657c5f322d20399fbd839acfe486" translate="yes" xml:space="preserve">
          <source>In all of these cases, &lt;code&gt;ReplyInfo&lt;/code&gt; has the following structure:</source>
          <target state="translated">これらすべてのケースで、 &lt;code&gt;ReplyInfo&lt;/code&gt; は次の構造を持っています。</target>
        </trans-unit>
        <trans-unit id="e5f12a8e126b9f100f177dad18ae6f54278d47be" translate="yes" xml:space="preserve">
          <source>In all other cases.</source>
          <target state="translated">他のすべてのケースで</target>
        </trans-unit>
        <trans-unit id="44ae32a10f43de59e7c1339560b615fa6de7f95e" translate="yes" xml:space="preserve">
          <source>In all other senses, the &lt;code&gt;_tmo&lt;/code&gt; functions inherit all the return values and the semantics from the functions without the &lt;code&gt;_tmo&lt;/code&gt; suffix.</source>
          <target state="translated">他のすべての意味で、 &lt;code&gt;_tmo&lt;/code&gt; 関数は、 &lt;code&gt;_tmo&lt;/code&gt; サフィックスのない関数からすべての戻り値とセマンティクスを継承します。</target>
        </trans-unit>
        <trans-unit id="fd966c15dbde5c1d758c9f9740c69468c511589a" translate="yes" xml:space="preserve">
          <source>In all the above examples, the object must exist and it must be of the right type for the specified operation. If you do not know the type of an object, you can ask:</source>
          <target state="translated">上記のすべての例では、オブジェクトは存在していなければならず、指定された操作に適した型でなければなりません。オブジェクトの型がわからない場合は、問い合わせてみましょう。</target>
        </trans-unit>
        <trans-unit id="9216f7534e9c31fef68910373cd1fdb3e3fbdb95" translate="yes" xml:space="preserve">
          <source>In an OTP source code tree, the OTP version can be read from the text file &lt;code&gt;&amp;lt;OTP source root&amp;gt;/OTP_VERSION&lt;/code&gt;. The absolute path to the file can be constructed by calling &lt;code&gt;filename:join([&lt;/code&gt;&lt;code&gt;code:root_dir()&lt;/code&gt;&lt;code&gt;, &quot;OTP_VERSION&quot;])&lt;/code&gt;.</source>
          <target state="translated">OTPソースコードツリーでは、OTPバージョンはテキストファイル &lt;code&gt;&amp;lt;OTP source root&amp;gt;/OTP_VERSION&lt;/code&gt; から読み取ることができます。ファイルへの絶対パスは、 &lt;code&gt;filename:join([&lt;/code&gt; &lt;code&gt;code:root_dir()&lt;/code&gt; &lt;code&gt;, &quot;OTP_VERSION&quot;])&lt;/code&gt; 呼び出すことで作成できます。</target>
        </trans-unit>
        <trans-unit id="3a595d061787336fdc6e9d2d4c2dc217d3ec6e25" translate="yes" xml:space="preserve">
          <source>In an earlier version of this API, the &lt;code&gt;lookup&lt;/code&gt; function received two arguments, omitting &lt;code&gt;Issuer&lt;/code&gt;. For compatibility, this is still supported: if there is no &lt;code&gt;lookup/3&lt;/code&gt; function in the callback module, &lt;code&gt;lookup/2&lt;/code&gt; is called instead.</source>
          <target state="translated">このAPIの以前のバージョンでは、 &lt;code&gt;lookup&lt;/code&gt; 関数は2つの引数を受け取り、 &lt;code&gt;Issuer&lt;/code&gt; を省略していました。互換性のため、これは引き続きサポートされています。コールバックモジュールに &lt;code&gt;lookup/2&lt;/code&gt; &lt;code&gt;lookup/3&lt;/code&gt; 関数がない場合は、代わりにlookup / 2が呼び出されます。</target>
        </trans-unit>
        <trans-unit id="b323e21a2ec47acd1da236b19d4a2d70f45bb77d" translate="yes" xml:space="preserve">
          <source>In an embedded system, there is usually no interactive shell. However, an operator can attach to the Erlang system by command &lt;code&gt;to_erl&lt;/code&gt;. The operator is then connected to the Erlang shell and can give ordinary Erlang commands. All interaction with the system through this shell is logged in a special directory.</source>
          <target state="translated">組み込みシステムでは、通常、対話型シェルはありません。ただし、オペレーターはコマンド &lt;code&gt;to_erl&lt;/code&gt; で Erlangシステムに接続できます。次に、オペレーターはErlangシェルに接続され、通常のErlangコマンドを実行できます。このシェルを介したシステムとのすべての対話は、特別なディレクトリに記録されます。</target>
        </trans-unit>
        <trans-unit id="6affeed9ea78db2ead1d48cc4e80d6afbfafb4eb" translate="yes" xml:space="preserve">
          <source>In an installed OTP development system, the OTP version can be read from the text file &lt;code&gt;&amp;lt;OTP installation root&amp;gt;/releases/&amp;lt;OTP release number&amp;gt;/OTP_VERSION&lt;/code&gt;. The absolute path to the file can by constructed by calling &lt;code&gt;filename:join([&lt;/code&gt;&lt;code&gt;code:root_dir()&lt;/code&gt;&lt;code&gt;, &quot;releases&quot;,&lt;/code&gt;&lt;code&gt;erlang:system_info(otp_release)&lt;/code&gt;&lt;code&gt;, &quot;OTP_VERSION&quot;]).&lt;/code&gt;</source>
          <target state="translated">インストールされているOTP開発システムでは、OTPバージョンはテキストファイル &lt;code&gt;&amp;lt;OTP installation root&amp;gt;/releases/&amp;lt;OTP release number&amp;gt;/OTP_VERSION&lt;/code&gt; から読み取ることができます。ファイルへの絶対パスは、 &lt;code&gt;filename:join([&lt;/code&gt; &lt;code&gt;code:root_dir()&lt;/code&gt; &lt;code&gt;, &quot;releases&quot;,&lt;/code&gt; &lt;code&gt;erlang:system_info(otp_release)&lt;/code&gt; &lt;code&gt;, &quot;OTP_VERSION&quot;]).&lt;/code&gt; 呼び出して構築できます。</target>
        </trans-unit>
        <trans-unit id="a4061d8e63786063b3eeabb1b52df7fa369545be" translate="yes" xml:space="preserve">
          <source>In an interactive system, the code loader provides demand-driven code loading, but in an embedded system the code loader loads all code immediately. The same version of &lt;code&gt;code&lt;/code&gt; is used in both cases. The code server calls &lt;code&gt;init:get_argument(mode)&lt;/code&gt; to determine if it is to run in demand mode or non-demand driven mode.</source>
          <target state="translated">インタラクティブシステムでは、コードローダーはデマンド駆動型のコードロードを提供しますが、組み込みシステムでは、コードローダーはすべてのコードをすぐにロードします。どちらの場合も、同じバージョンの &lt;code&gt;code&lt;/code&gt; が使用されます。コードサーバーは &lt;code&gt;init:get_argument(mode)&lt;/code&gt; を呼び出して、デマンドモードまたは非デマンドドリブンモードのどちらで実行するかを決定します。</target>
        </trans-unit>
        <trans-unit id="40c287b596d5b896af6235aa0ac1f4766bfd7a16" translate="yes" xml:space="preserve">
          <source>In both cases, the current token is set. In particular, if the token of a received message is empty, the current token of the process is set to empty.</source>
          <target state="translated">いずれの場合も、現在のトークンが設定される。特に、受信したメッセージのトークンが空の場合は、プロセスの現在のトークンが空に設定されます。</target>
        </trans-unit>
        <trans-unit id="6cb81d52aa37dc7833d69efc8ceea8d49076b214" translate="yes" xml:space="preserve">
          <source>In both cases, the first accessible element in the table should be returned. As the key columns are not accessible, this means that the third column is the first row.</source>
          <target state="translated">どちらの場合も、テーブル内で最初にアクセス可能な要素を返す必要があります。キーカラムはアクセスできないので、これは3番目のカラムが最初の行であることを意味します。</target>
        </trans-unit>
        <trans-unit id="c8bcfe99dfb6ce58aa580ed57d8b7b2260bf8c45" translate="yes" xml:space="preserve">
          <source>In both previous examples, &lt;code&gt;seq_trace:reset_trace/0&lt;/code&gt; resets the trace token immediately after the traced function to avoid many trace messages because of the printouts in the Erlang shell.</source>
          <target state="translated">前の両方の例では、 &lt;code&gt;seq_trace:reset_trace/0&lt;/code&gt; は、トレースされた関数の直後にトレーストークンをリセットして、Erlangシェルでの出力による多くのトレースメッセージを回避します。</target>
        </trans-unit>
        <trans-unit id="b04f25164a1486f33a08ec5a081e04f72ebc9e3b" translate="yes" xml:space="preserve">
          <source>In both storages, the documentation is written in the exactly same format: an Erlang term serialized to binary via &lt;code&gt; term_to_binary/1&lt;/code&gt;. The term may be optionally compressed when serialized. It must follow the type specification below:</source>
          <target state="translated">どちらのストレージでも、ドキュメントはまったく同じ形式で記述されています &lt;code&gt; term_to_binary/1&lt;/code&gt; 介してバイナリにシリアル化されたアーラン用語です。この用語は、シリアル化するときにオプションで圧縮できます。以下のタイプ仕様に従う必要があります。</target>
        </trans-unit>
        <trans-unit id="1e9979f7dc9c90d9448aea9a33897846d951ecc0" translate="yes" xml:space="preserve">
          <source>In brief, &lt;code&gt;Common Test&lt;/code&gt; supports:</source>
          <target state="translated">簡単に言えば、 &lt;code&gt;Common Test&lt;/code&gt; は以下をサポートします。</target>
        </trans-unit>
        <trans-unit id="219af38196dae5e5cf8e3928cdad6f56580aeb9d" translate="yes" xml:space="preserve">
          <source>In brief, CTH allows you to do the following:</source>
          <target state="translated">簡単に説明すると、CTHでは以下のようなことができます。</target>
        </trans-unit>
        <trans-unit id="7808f617380ab0dd07679578966aad4ed29b5be3" translate="yes" xml:space="preserve">
          <source>In brief, CTH allows you to:</source>
          <target state="translated">簡単に言うと、CTHを使うことで可能になります。</target>
        </trans-unit>
        <trans-unit id="515fe8110084161af1176bfde998dc3668536ede" translate="yes" xml:space="preserve">
          <source>In brief, a simple test object consists of a single function that takes no arguments (possibly annotated with some additional metadata, i.e., a line number). Evaluation of the function either &lt;strong&gt;succeeds&lt;/strong&gt;, by returning some value (which is ignored), or &lt;strong&gt;fails&lt;/strong&gt;, by throwing an exception.</source>
          <target state="translated">簡単に言うと、単純なテストオブジェクトは、引数を取らない単一の関数で構成されています（おそらく、追加のメタデータ（つまり、行番号）で注釈が付けられています）。関数の評価は、何らかの値（無視されます）を返すことによって&lt;strong&gt;成功する&lt;/strong&gt;か、例外をスローすることによって&lt;strong&gt;失敗&lt;/strong&gt;します。</target>
        </trans-unit>
        <trans-unit id="cf6c31b5ceac197ebb6de3ed74b4d965acf33272" translate="yes" xml:space="preserve">
          <source>In case of a &lt;code&gt;&lt;a href=&quot;#option-pwdfun&quot;&gt;pwdfun&lt;/a&gt;&lt;/code&gt; checking the user, the atom &lt;code&gt;pubkey&lt;/code&gt; is put in the password argument.</source>
          <target state="translated">以下の場合は &lt;code&gt;&lt;a href=&quot;#option-pwdfun&quot;&gt;pwdfun&lt;/a&gt;&lt;/code&gt; ユーザーをチェックし、原子 &lt;code&gt;pubkey&lt;/code&gt; では、パスワード引数に入れています。</target>
        </trans-unit>
        <trans-unit id="200407071e2ee196988d7a1889800e7d1509e085" translate="yes" xml:space="preserve">
          <source>In case of a match operation between a ReferenceID and a CN value from the &lt;code&gt;Subject&lt;/code&gt; field, the first argument to the fun is the extracted hostname from the ReferenceID, and the second argument is the tuple &lt;code&gt;{cn, string()}&lt;/code&gt; taken from the &lt;code&gt;Subject&lt;/code&gt; field. That makes it possible to have separate matching rules for Presented IDs from the &lt;code&gt;Subject&lt;/code&gt; field and from the &lt;code&gt;Subject Alternate Name&lt;/code&gt; field.</source>
          <target state="translated">ReferenceIDと &lt;code&gt;Subject&lt;/code&gt; フィールドのCN値の間の一致操作の場合、funへの最初の引数はReferenceIDから抽出されたホスト名で、2番目の引数は &lt;code&gt;Subject&lt;/code&gt; から取得されたタプル &lt;code&gt;{cn, string()}&lt;/code&gt; フィールド。これにより、[ &lt;code&gt;Subject&lt;/code&gt; フィールドと[ &lt;code&gt;Subject Alternate Name&lt;/code&gt; フィールドから、提示されたIDに個別の一致ルールを設定できます。</target>
        </trans-unit>
        <trans-unit id="14abcc78e4a8808dcb7c6c248f2d73041919e75b" translate="yes" xml:space="preserve">
          <source>In case of a sftp request, an sftp server is started in with the user's rights. So it could read, write or delete files if allowed for that user.</source>
          <target state="translated">sftp リクエストがあった場合、ユーザの権限で sftp サーバが起動されます。そのため、そのユーザに許可されていれば、ファイルの読み取り、書き込み、削除を行うことができます。</target>
        </trans-unit>
        <trans-unit id="d57c67c502f00b82712590fc8169173e11b61f4a" translate="yes" xml:space="preserve">
          <source>In case of an error (for example, &lt;code&gt;addr_unreachable&lt;/code&gt;), field &lt;code&gt;error&lt;/code&gt; provides more diagnostics. In such cases, event &lt;code&gt;#sctp_paddr_change{}&lt;/code&gt; is automatically converted into an &lt;code&gt;error&lt;/code&gt; term returned by &lt;code&gt;&lt;a href=&quot;#recv-1&quot;&gt;recv&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;error&lt;/code&gt; field value can be converted into a string using &lt;code&gt;&lt;a href=&quot;#error_string-1&quot;&gt;error_string/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">エラー（たとえば、 &lt;code&gt;addr_unreachable&lt;/code&gt; ）の場合、フィールド &lt;code&gt;error&lt;/code&gt; はより多くの診断を提供します。そのような場合、イベント &lt;code&gt;#sctp_paddr_change{}&lt;/code&gt; は自動的に &lt;code&gt;&lt;a href=&quot;#recv-1&quot;&gt;recv&lt;/a&gt;&lt;/code&gt; によって返される &lt;code&gt;error&lt;/code&gt; 項に変換されます。 &lt;code&gt;error&lt;/code&gt; フィールド値を使用して文字列に変換することができる &lt;code&gt;&lt;a href=&quot;#error_string-1&quot;&gt;error_string/1&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e587acfb74f322fbcfbbb116173319a489ae29e8" translate="yes" xml:space="preserve">
          <source>In case of an error, all instrumentation functions may return either an SNMPv1 or an SNMPv2 error code. If it returns an SNMPv2 code, it is converted into an SNMPv1 code before it is sent to a SNMPv1 manager. It is recommended to use the SNMPv2 error codes for all instrumentation functions, as these provide more details. See &lt;code&gt;&lt;a href=&quot;snmp_app_a&quot;&gt;Appendix A&lt;/a&gt;&lt;/code&gt; for a description of error code conversions.</source>
          <target state="translated">エラーが発生した場合、すべての計測機能がSNMPv1またはSNMPv2エラーコードを返す場合があります。SNMPv2コードを返す場合は、SNMPv1マネージャに送信される前にSNMPv1コードに変換されます。すべての計測機能にSNMPv2エラーコードを使用することをお勧めします。これにより、詳細が提供されます。エラーコード変換の説明については、 &lt;code&gt;&lt;a href=&quot;snmp_app_a&quot;&gt;Appendix A&lt;/a&gt;&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="53574543ae936142434ad121e0424851d134f56f" translate="yes" xml:space="preserve">
          <source>In case of an sftp request, an sftp server is started with the rights of the user of the Erlang emulator's OS process. So with sftp the authenticated user does not influence the rights.</source>
          <target state="translated">sftpリクエストがあった場合、ErlangエミュレータのOSプロセスのユーザの権限でsftpサーバが起動します。つまり、sftpでは認証されたユーザの権限は影響を受けません。</target>
        </trans-unit>
        <trans-unit id="7ca8c5900d9e5d4e81eb7db9c8c5e95ada47eae8" translate="yes" xml:space="preserve">
          <source>In case of lists there is only percent-encoding. In binaries, however, both binary encoding and percent-encoding shall be considered. &lt;code&gt;transcode/2&lt;/code&gt; provides the means to convert between the supported encodings, it takes a &lt;code&gt;uri_string()&lt;/code&gt; and a list of options specifying inbound and outbound encodings.</source>
          <target state="translated">リストの場合は、パーセントエンコーディングしかありません。ただし、バイナリでは、バイナリエンコーディングとパーセントエンコーディングの両方が考慮されます。 &lt;code&gt;transcode/2&lt;/code&gt; はサポートされているエンコーディング間で変換する手段を提供します。それは &lt;code&gt;uri_string()&lt;/code&gt; とインバウンドとアウトバウンドのエンコーディングを指定するオプションのリストを取ります。</target>
        </trans-unit>
        <trans-unit id="808f4c12856e1f075895b6b1b300374926fab373" translate="yes" xml:space="preserve">
          <source>In case of loading, monitoring can &lt;strong&gt;not&lt;/strong&gt; only get triggered by using option &lt;code&gt;{reload, ReloadOption}&lt;/code&gt;, but also in special cases where the load error is transient. Thus, &lt;code&gt;{monitor, pending_driver}&lt;/code&gt; is to be used under basically &lt;strong&gt;all&lt;/strong&gt; real world circumstances.</source>
          <target state="translated">ローディングの場合には、できモニタリング&lt;strong&gt;しない&lt;/strong&gt;唯一のオプション使用によってトリガー取得 &lt;code&gt;{reload, ReloadOption}&lt;/code&gt; だけでなく、ロードエラーが一時的である特別な場合には、。したがって、 &lt;code&gt;{monitor, pending_driver}&lt;/code&gt; は、基本的に&lt;strong&gt;すべての&lt;/strong&gt;現実の環境で使用されます。</target>
        </trans-unit>
        <trans-unit id="c09622d21ce9a9b2d2c2d392f9cbc9b05b57cfb1" translate="yes" xml:space="preserve">
          <source>In case of the &lt;code&gt;&lt;a href=&quot;#option-pk_check_user&quot;&gt;pk_check_user&lt;/a&gt;&lt;/code&gt; is set, the atom &lt;code&gt;pubkey&lt;/code&gt; is put in the password argument when validating a public key login. The pwdfun is then responsible to check that the user name is valid.</source>
          <target state="translated">以下の場合 &lt;code&gt;&lt;a href=&quot;#option-pk_check_user&quot;&gt;pk_check_user&lt;/a&gt;&lt;/code&gt; が設定されている、原子 &lt;code&gt;pubkey&lt;/code&gt; では、公開鍵ログインを検証するときに、パスワードの引数に入れています。次に、pwdfunは、ユーザー名が有効であることを確認する責任があります。</target>
        </trans-unit>
        <trans-unit id="a2a8bc8abb7f5d55980d9c87519b99d19822bd2d" translate="yes" xml:space="preserve">
          <source>In case of the &lt;code&gt;{direct, exec_fun()}&lt;/code&gt; variant or no exec-option at all, all reads from &lt;code&gt;standard_input&lt;/code&gt; will be from the received data-events of type 0. Those are sent by the client. Similarily all writes to &lt;code&gt;standard_output&lt;/code&gt; will be sent as data-events to the client. An OS shell client like the command 'ssh' will usally use stdin and stdout for the user interface.</source>
          <target state="translated">以下の場合には &lt;code&gt;{direct, exec_fun()}&lt;/code&gt; バリアント又は全くEXEC-オプション、全てから読み取り &lt;code&gt;standard_input&lt;/code&gt; それらがクライアントによって送信されるタイプ0の受信データ・イベントからであろう。同様に、 &lt;code&gt;standard_output&lt;/code&gt; へのすべての書き込みは、データイベントとしてクライアントに送信されます。コマンド「ssh」のようなOSシェルクライアントは、通常、ユーザーインターフェイスにstdinとstdoutを使用します。</target>
        </trans-unit>
        <trans-unit id="977b39c15ba3f7569c95130949a0911293fdf7e5" translate="yes" xml:space="preserve">
          <source>In case where the Presented IDs are fetched from the &lt;code&gt;Subject&lt;/code&gt; certificate field, the names may contain wildcard characters. The function handles this as defined in &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc6125#section-6.4.3&quot;&gt;chapter 6.4.3 in RFC 6125&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">提示されたIDが &lt;code&gt;Subject&lt;/code&gt; 証明書フィールドからフェッチされる場合、名前にワイルドカード文字が含まれている可能性があります。関数は &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc6125#section-6.4.3&quot;&gt;chapter 6.4.3 in RFC 6125&lt;/a&gt;&lt;/code&gt; 定義されているようにこれを処理します。</target>
        </trans-unit>
        <trans-unit id="6c2392e0d50603f0a73106c4fc2922254ed71b25" translate="yes" xml:space="preserve">
          <source>In cases in which there is a choice between string() and binary() types for OctetString() and derived types, the representation is determined by the value of &lt;code&gt;&lt;a href=&quot;diameter#service_opt&quot;&gt;diameter:service_opt()&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;diameter#string_decode&quot;&gt;string_decode&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">OctetString（）のstring（）型とbinary（）型と派生型の間で選択がある場合、表現は、 &lt;code&gt;&lt;a href=&quot;diameter#service_opt&quot;&gt;diameter:service_opt()&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;diameter#string_decode&quot;&gt;string_decode&lt;/a&gt;&lt;/code&gt; の値によって決定されます。</target>
        </trans-unit>
        <trans-unit id="ef42ed541c5fd6f99645f29530b756b01b921460" translate="yes" xml:space="preserve">
          <source>In cases where it is known that the subject string contains no newlines, it is worth setting &lt;code&gt;dotall&lt;/code&gt; to obtain this optimization, or alternatively using ^ to indicate anchoring explicitly.</source>
          <target state="translated">対象の文字列に改行が含まれていないことがわかっている場合は、 &lt;code&gt;dotall&lt;/code&gt; を設定してこの最適化を行うか、^を使用してアンカーを明示的に示すことをお勧めします。</target>
        </trans-unit>
        <trans-unit id="a1b58942bdfb61fbfab275afba5031d1b18f39aa" translate="yes" xml:space="preserve">
          <source>In cases where you want to redirect standard input and/or standard output or use Erlang in a pipeline, &lt;code&gt;werl&lt;/code&gt; is not suitable, and the &lt;code&gt;erl&lt;/code&gt; program is to be used instead.</source>
          <target state="translated">標準入力または標準出力、あるいはその両方をリダイレクトする場合、またはパイプラインでErlangを使用する場合は、 &lt;code&gt;werl&lt;/code&gt; は適切ではなく、代わりに &lt;code&gt;erl&lt;/code&gt; プログラムが使用されます。</target>
        </trans-unit>
        <trans-unit id="43f3712fe1600a053e4d1e45bcba55920060bee0" translate="yes" xml:space="preserve">
          <source>In certain output functions and in the output of return values in the shell, Erlang tries to detect string data in lists and binaries heuristically. Typically you will see heuristic detection in a situation like this:</source>
          <target state="translated">ある種の出力関数やシェルの戻り値の出力では、Erlangはリストやバイナリの中の文字列データをヒューリスティックに検出しようとします。典型的には、以下のような状況でヒューリスティックな検出を見ることができます。</target>
        </trans-unit>
        <trans-unit id="2913f30605a1fdbcd933f0b8e8b6036a00ba77d8" translate="yes" xml:space="preserve">
          <source>In certain situations, especially when the standard output is redirected, access to an I/O server specific for error messages can be convenient. The I/O device &lt;code&gt;standard_error&lt;/code&gt; can be used to direct output to whatever the current operating system considers a suitable I/O device for error output. Example on a Unix-like operating system:</source>
          <target state="translated">特定の状況では、特に標準出力がリダイレクトされる場合、エラーメッセージに固有のI / Oサーバーへのアクセスが便利です。I / Oデバイス &lt;code&gt;standard_error&lt;/code&gt; を使用して、現在のオペレーティングシステムがエラー出力に適したI / Oデバイスと見なしているものに出力を送ることができます。Unixライクなオペレーティングシステムの例：</target>
        </trans-unit>
        <trans-unit id="3962d4a09e381d0a5b5f8e864d0585d6a5883982" translate="yes" xml:space="preserve">
          <source>In combination with &lt;code&gt;{locations, true}&lt;/code&gt; this option prints the lock operations source file and line number entry-points along with statistics for each entry.</source>
          <target state="translated">このオプションは &lt;code&gt;{locations, true}&lt;/code&gt; と組み合わせて、ロック操作のソースファイルと行番号のエントリポイントを各エントリの統計とともに出力します。</target>
        </trans-unit>
        <trans-unit id="d0663aa5a3512196f700ca9db937eddad06a6262" translate="yes" xml:space="preserve">
          <source>In conjunction with option &lt;code&gt;-M&lt;/code&gt; or &lt;code&gt;-MF&lt;/code&gt;, adds a phony target for each dependency.</source>
          <target state="translated">オプション &lt;code&gt;-M&lt;/code&gt; または &lt;code&gt;-MF&lt;/code&gt; と組み合わせて、各依存関係に偽のターゲットを追加します。</target>
        </trans-unit>
        <trans-unit id="71822bd1bd6d5c17ee53e249eaeb9feb7f740847" translate="yes" xml:space="preserve">
          <source>In conjunction with option &lt;code&gt;-M&lt;/code&gt; or &lt;code&gt;-MF&lt;/code&gt;, changes the name of the rule emitted to &lt;code&gt;Target&lt;/code&gt;.</source>
          <target state="translated">オプション &lt;code&gt;-M&lt;/code&gt; または &lt;code&gt;-MF&lt;/code&gt; と組み合わせて、 &lt;code&gt;Target&lt;/code&gt; 発行されたルールの名前を変更します。</target>
        </trans-unit>
        <trans-unit id="799eab09c6f865f28e612e123d49d644e3a08fdd" translate="yes" xml:space="preserve">
          <source>In conjunction with option &lt;code&gt;-M&lt;/code&gt; or &lt;code&gt;-MF&lt;/code&gt;, considers missing headers as generated files and adds them to the dependencies.</source>
          <target state="translated">オプション &lt;code&gt;-M&lt;/code&gt; または &lt;code&gt;-MF&lt;/code&gt; と組み合わせて、欠落しているヘッダーを生成されたファイルと見なし、依存関係に追加します。</target>
        </trans-unit>
        <trans-unit id="d32124678089e39bfca82cfddf077b823139344c" translate="yes" xml:space="preserve">
          <source>In contrast to an RPC, a multicall is an RPC that is sent concurrently from one client to multiple servers. This is useful for collecting information from a set of nodes, or for calling a function on a set of nodes to achieve some side effects. It is semantically the same as iteratively making a series of RPCs on all the nodes, but the multicall is faster, as all the requests are sent at the same time and are collected one by one as they come back.</source>
          <target state="translated">RPCとは対照的に、マルチコールは、1つのクライアントから複数のサーバに同時に送信されるRPCです。これは、あるノードのセットから情報を収集したり、あるノードのセットで関数を呼び出して何らかの副次的効果を達成したりするのに便利です。意味的には、すべてのノードで一連のRPCを反復的に行うのと同じですが、すべてのリクエストが同時に送信され、戻ってきたときに1つずつ収集されるので、マルチコールの方が高速です。</target>
        </trans-unit>
        <trans-unit id="e6c250fb90561ab264baf4cf8dabd48e1c97e8c8" translate="yes" xml:space="preserve">
          <source>In contrast to most of the other callback functions, &lt;code&gt;stop_select&lt;/code&gt; is called independent of any port. No &lt;code&gt;ErlDrvData&lt;/code&gt; argument is passed to the function. No driver lock or port lock is guaranteed to be held. The port that called &lt;code&gt;driver_select&lt;/code&gt; can even be closed at the time &lt;code&gt;stop_select&lt;/code&gt; is called. But it can also be the case that &lt;code&gt;stop_select&lt;/code&gt; is called directly by &lt;code&gt;erl_driver:driver_select&lt;/code&gt;.</source>
          <target state="translated">他のほとんどのコールバック関数とは対照的に、 &lt;code&gt;stop_select&lt;/code&gt; はどのポートからも独立して呼び出されます。 &lt;code&gt;ErlDrvData&lt;/code&gt; 引数は関数に渡されません。ドライバーロックまたはポートロックの保持は保証されていません。 &lt;code&gt;driver_select&lt;/code&gt; を呼び出したポートは、 &lt;code&gt;stop_select&lt;/code&gt; が呼び出されたときに閉じることもできます。しかし、また、ある場合することができ &lt;code&gt;stop_select&lt;/code&gt; がで直接呼び出され &lt;code&gt;erl_driver:driver_select&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="72bf39173d9a61b211eba3bd517308261f47677f" translate="yes" xml:space="preserve">
          <source>In contrast, a subroutine call to a numbered subpattern always refers to the first one in the pattern with the given number. The following pattern matches &quot;abcabc&quot; or &quot;defabc&quot;:</source>
          <target state="translated">対照的に、番号付きのサブパターンへのサブルーチン呼び出しは、常に与えられた番号を持つパターンの最初のものを参照します。次のパターンは「abcabc」または「defabc」と一致します。</target>
        </trans-unit>
        <trans-unit id="2b1893e8c44648aaa4d2220a6408b6c74957584a" translate="yes" xml:space="preserve">
          <source>In crash dumps, the stack, messages, and the process dictionary are omitted.</source>
          <target state="translated">クラッシュダンプでは、スタック、メッセージ、プロセス辞書は省略されます。</target>
        </trans-unit>
        <trans-unit id="f5b30e844f19c774b16c52548000fcb4af87d281" translate="yes" xml:space="preserve">
          <source>In decryption, the &lt;code&gt;&lt;a href=&quot;#type-cryptolib_padding&quot;&gt;cryptolib_padding&lt;/a&gt;&lt;/code&gt; removes such padding, if present. The &lt;code&gt;&lt;a href=&quot;#type-otp_padding&quot;&gt;otp_padding&lt;/a&gt;&lt;/code&gt; is not removed - it has to be done elsewhere.</source>
          <target state="translated">復号化では、 &lt;code&gt;&lt;a href=&quot;#type-cryptolib_padding&quot;&gt;cryptolib_padding&lt;/a&gt;&lt;/code&gt; はそのようなパディングが存在する場合はそれを削除します。 &lt;code&gt;&lt;a href=&quot;#type-otp_padding&quot;&gt;otp_padding&lt;/a&gt;&lt;/code&gt; は削除されません-それは他の場所で行う必要があります。</target>
        </trans-unit>
        <trans-unit id="009dc66d33d0ffea38b40e283770f175ec84745e" translate="yes" xml:space="preserve">
          <source>In dirty context, that is, &lt;code&gt;sync_dirty&lt;/code&gt; or &lt;code&gt;async_dirty&lt;/code&gt;, the modified records are not stored in a local copy; instead, each record is updated separately. This generates much network traffic if the table has a replica on another node and has all the other drawbacks that dirty operations have. Especially for commands &lt;code&gt;&lt;a href=&quot;mnesia#first-1&quot;&gt;mnesia:first/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;mnesia#next-2&quot;&gt;mnesia:next/2&lt;/a&gt;&lt;/code&gt;, the same drawbacks as described previously for &lt;code&gt;&lt;a href=&quot;mnesia#dirty_first-1&quot;&gt;mnesia:dirty_first/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;mnesia#dirty_next-2&quot;&gt;mnesia:dirty_next/2&lt;/a&gt;&lt;/code&gt; applies, that is, no writing to the table is to be done during iteration.</source>
          <target state="translated">ダーティーコンテキスト、つまり &lt;code&gt;sync_dirty&lt;/code&gt; または &lt;code&gt;async_dirty&lt;/code&gt; では、変更されたレコードはローカルコピーに保存されません。代わりに、各レコードは個別に更新されます。これにより、テーブルに別のノードにレプリカがあり、ダーティオペレーションにある他のすべての欠点がある場合、多くのネットワークトラフィックが生成されます。特にコマンド &lt;code&gt;&lt;a href=&quot;mnesia#first-1&quot;&gt;mnesia:first/1&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;mnesia#next-2&quot;&gt;mnesia:next/2&lt;/a&gt;&lt;/code&gt; の場合、以前に &lt;code&gt;&lt;a href=&quot;mnesia#dirty_first-1&quot;&gt;mnesia:dirty_first/1&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;mnesia#dirty_next-2&quot;&gt;mnesia:dirty_next/2&lt;/a&gt;&lt;/code&gt; について説明したのと同じ欠点が適用されます。つまり、反復中にテーブルへの書き込みは行われません。</target>
        </trans-unit>
        <trans-unit id="1a0a0d4d35649ef6ee46c466316008c66431587a" translate="yes" xml:space="preserve">
          <source>In each &lt;code&gt;Viewer&lt;/code&gt; there is only one filter that is active and all trace &lt;code&gt;Events&lt;/code&gt; that the &lt;code&gt;Viewer&lt;/code&gt; gets from the &lt;code&gt;Collector&lt;/code&gt; will pass thru that filter. By writing clever filters it is possible to customize how the &lt;code&gt;Events&lt;/code&gt; looks like in the viewer. The following filter in &lt;code&gt;et/examples/et_demo.erl&lt;/code&gt; replaces the actor names &lt;code&gt;mnesia_tm&lt;/code&gt; and &lt;code&gt;mnesia_locker&lt;/code&gt; and leaves everything else in the record as it was:</source>
          <target state="translated">各 &lt;code&gt;Viewer&lt;/code&gt; にはアクティブなフィルタが1つだけあり、 &lt;code&gt;Viewer&lt;/code&gt; が &lt;code&gt;Collector&lt;/code&gt; から取得するすべてのトレース &lt;code&gt;Events&lt;/code&gt; はそのフィルタを通過します。巧妙なフィルターを作成することで、 &lt;code&gt;Events&lt;/code&gt; がビューアーでどのように表示されるかをカスタマイズできます。 &lt;code&gt;et/examples/et_demo.erl&lt;/code&gt; の次のフィルタは、 &lt;code&gt;mnesia_tm&lt;/code&gt; と &lt;code&gt;mnesia_locker&lt;/code&gt; というアクター名を置き換え、他のすべてをそのままにします。</target>
        </trans-unit>
        <trans-unit id="7207b6cf9942a41d2732aa49d03bc019b9c6508d" translate="yes" xml:space="preserve">
          <source>In each iteration, the first 8 bits in the binary will be skipped, not matched out.</source>
          <target state="translated">各イテレーションでは、バイナリの最初の8ビットはスキップされ、マッチアウトされません。</target>
        </trans-unit>
        <trans-unit id="eb6692c5b77a86308b6ebf869c484cc1ff8e5ede" translate="yes" xml:space="preserve">
          <source>In earlier Erlang/OTP releases, operations on too large binaries in general either fail or give incorrect results. In future releases, other operations that create binaries (such as &lt;code&gt;list_to_binary/1&lt;/code&gt;) will probably also enforce the same limit.</source>
          <target state="translated">以前のErlang / OTPリリースでは、一般的に大きすぎるバイナリでの操作は失敗するか、正しくない結果をもたらします。将来のリリースでは、バイナリを作成する他の操作（ &lt;code&gt;list_to_binary/1&lt;/code&gt; など）でも、おそらく同じ制限が適用されます。</target>
        </trans-unit>
        <trans-unit id="a79ea28e01a94d82c32763fb4b89f0d00a82f9b8" translate="yes" xml:space="preserve">
          <source>In either case, the agent will do nothing, but return the retrieved ManagerEngineID (see &lt;code&gt;&lt;a href=&quot;snmpa#discovery&quot;&gt;discovery&lt;/a&gt;&lt;/code&gt; for more info) and possible continue with stage 2 of the discovery process.</source>
          <target state="translated">どちらの場合も、エージェントは何もしませんが、取得したManagerEngineID（詳細は &lt;code&gt;&lt;a href=&quot;snmpa#discovery&quot;&gt;discovery&lt;/a&gt;&lt;/code&gt; を参照）を返し、ディスカバリープロセスのステージ2を続行できます。</target>
        </trans-unit>
        <trans-unit id="6791868ca84c6905bfaf1ddbc9f4f687833d3165" translate="yes" xml:space="preserve">
          <source>In embedded mode, all code is loaded during system startup according to the boot script. (Code can also be loaded later by explicitly ordering the code server to do so.)</source>
          <target state="translated">組み込みモードでは、すべてのコードはブートスクリプトに従ってシステム起動時にロードされます。(コードサーバに明示的に命令することで、後でコードをロードすることもできます)。</target>
        </trans-unit>
        <trans-unit id="b50f303eb6355438df5780a62638469b2bf7dcf5" translate="yes" xml:space="preserve">
          <source>In embedded mode, first all modules are loaded. Then all &lt;code&gt;on_load&lt;/code&gt; functions are called. The system is terminated unless all of the &lt;code&gt;on_load&lt;/code&gt; functions return &lt;code&gt;ok&lt;/code&gt;.</source>
          <target state="translated">組み込みモードでは、最初にすべてのモジュールがロードされます。次に、すべての &lt;code&gt;on_load&lt;/code&gt; 関数が呼び出されます。すべての &lt;code&gt;on_load&lt;/code&gt; 関数が &lt;code&gt;ok&lt;/code&gt; を返さない限り、システムは終了します。</target>
        </trans-unit>
        <trans-unit id="f2dd392efb3ccbc428fed625f643db9c1a171840" translate="yes" xml:space="preserve">
          <source>In embedded mode, modules are not auto loaded. Trying to use a module that has not been loaded results in an error. This mode is recommended when the boot script loads all modules, as it is typically done in OTP releases. (Code can still be loaded later by explicitly ordering the code server to do so).</source>
          <target state="translated">組み込みモードでは、モジュールは自動ロードされません。ロードされていないモジュールを使おうとするとエラーになります。このモードは、ブートスクリプトがすべてのモジュールをロードするときに推奨されます。(コードサーバに明示的に命令することで、後でコードをロードすることができます)。</target>
        </trans-unit>
        <trans-unit id="a1f53217834ce9f061b0ce0f9fd6ed43fb29178a" translate="yes" xml:space="preserve">
          <source>In embedded systems with a limited amount of RAM and no virtual memory, you might want to preserve memory by setting &lt;code&gt;Number&lt;/code&gt; to zero. (The value can be set globally, see &lt;code&gt;&lt;a href=&quot;#system_flag-2&quot;&gt; erlang:system_flag/2&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">RAMの量が限られていて仮想メモリがない組み込みシステムでは、 &lt;code&gt;Number&lt;/code&gt; をゼロに設定してメモリを保持したい場合があります。（値はグローバルに設定できます &lt;code&gt;&lt;a href=&quot;#system_flag-2&quot;&gt; erlang:system_flag/2&lt;/a&gt;&lt;/code&gt; 参照してください。）</target>
        </trans-unit>
        <trans-unit id="fc60ce46c151028d30005b444c453c26498c7146" translate="yes" xml:space="preserve">
          <source>In embedded systems with a limited amount of RAM and no virtual memory, you might want to preserve memory by setting &lt;code&gt;Number&lt;/code&gt; to zero. (The value can be set globally, see &lt;code&gt;&lt;a href=&quot;#system_flag-2&quot;&gt;erlang:system_flag/2&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">RAMが限られていて仮想メモリがない組み込みシステムでは、 &lt;code&gt;Number&lt;/code&gt; をゼロに設定してメモリを保持したい場合があります。（値はグローバルに設定できます &lt;code&gt;&lt;a href=&quot;#system_flag-2&quot;&gt;erlang:system_flag/2&lt;/a&gt;&lt;/code&gt; 参照してください。）</target>
        </trans-unit>
        <trans-unit id="a83f38724964e749e7fb12c41663c8a1d17b6a70" translate="yes" xml:space="preserve">
          <source>In essence, the function performs the same operation as &lt;code&gt;ei_xreceive_msg&lt;/code&gt;, but instead of using an &lt;code&gt;ei_x_buff&lt;/code&gt;, the function expects a pointer to a character pointer (&lt;code&gt;mbufp&lt;/code&gt;), where the character pointer is to point to a memory area allocated by &lt;code&gt;malloc&lt;/code&gt;. Argument &lt;code&gt;bufsz&lt;/code&gt; is to be a pointer to an integer containing the exact size (in bytes) of the memory area. The function may reallocate the memory area and will in such cases put the new size in &lt;code&gt;*bufsz&lt;/code&gt; and update &lt;code&gt;*mbufp&lt;/code&gt;.</source>
          <target state="translated">本質的には、機能は同じ動作実行 &lt;code&gt;ei_xreceive_msg&lt;/code&gt; を、代わりに使用する &lt;code&gt;ei_x_buff&lt;/code&gt; を、関数は、文字ポインタ（へのポインタ期待 &lt;code&gt;mbufp&lt;/code&gt; 文字ポインタによって割り当てられたメモリ領域へのポイントである）、 &lt;code&gt;malloc&lt;/code&gt; 関数を。引数 &lt;code&gt;bufsz&lt;/code&gt; は、メモリ領域の正確なサイズ（バイト単位）を含む整数へのポインターです。関数はメモリ領域を再割り当てする可能性があり、そのような場合、新しいサイズを &lt;code&gt;*bufsz&lt;/code&gt; に入れ、* mbufpを更新し &lt;code&gt;*mbufp&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0a0eed82352e329b2edf4d4c83a697e586f41d04" translate="yes" xml:space="preserve">
          <source>In every directory under &lt;code&gt;DocumentRoot&lt;/code&gt; or under an &lt;code&gt;Alias&lt;/code&gt; a user can place an access file. An access file is a plain text file that specifies the restrictions to consider before the web server answers to a request. If there are more than one access file in the path to the requested asset, the directives in the access file in the directory nearest the asset is used.</source>
          <target state="translated">&lt;code&gt;DocumentRoot&lt;/code&gt; または &lt;code&gt;Alias&lt;/code&gt; の下のすべてのディレクトリに、ユーザーはアクセスファイルを配置できます。アクセスファイルは、Webサーバーが要求に応答する前に考慮する制限を指定するプレーンテキストファイルです。リクエストされたアセットへのパスに複数のアクセスファイルがある場合、アセットに最も近いディレクトリにあるアクセスファイルのディレクティブが使用されます。</target>
        </trans-unit>
        <trans-unit id="6115207717e886104fd373d8df969be5b6da13f2" translate="yes" xml:space="preserve">
          <source>In fact since random data is cached some numbers may get reproduced if you try, but this is unpredictable.</source>
          <target state="translated">実際にはランダムデータがキャッシュされているので、試してみるといくつかの数字が再現されるかもしれませんが、これは予測できません。</target>
        </trans-unit>
        <trans-unit id="b8c42f9c0fe05f000ea096a90949e9096c2f9d28" translate="yes" xml:space="preserve">
          <source>In fortunate cases, the inconsistency is only visible in tables belonging to a specific application. However, if a schema transaction is inconsistently recovered because of the enforced transaction recovery decision, the effects of the inconsistency can be fatal. However, if the higher priority is availability rather than consistency, it can be worth the risk.</source>
          <target state="translated">幸いなことに、不整合は、特定のアプリケーションに属するテーブルにしか見えない。しかし、強行されたトランザクション回復決定のためにスキーマトランザクションが矛盾して回復された場合、矛盾の影響は致命的なものになる可能性があります。しかし、一貫性よりも可用性の方が優先度が高い場合は、そのリスクに見合うだけの価値があります。</target>
        </trans-unit>
        <trans-unit id="711417732b3b7abd2d21d3e6c58e046cc718902b" translate="yes" xml:space="preserve">
          <source>In general, bugs are only fixed on the latest &lt;code&gt;&lt;a href=&quot;versions#releases_and_patches&quot;&gt;release&lt;/a&gt;&lt;/code&gt;, and new features are introduced in the upcoming release that is under development. However, when we, due to internal reasons, fix bugs on older releases, these will be available and announced as well.</source>
          <target state="translated">一般に、バグは最新 &lt;code&gt;&lt;a href=&quot;versions#releases_and_patches&quot;&gt;release&lt;/a&gt;&lt;/code&gt; でのみ修正され、新機能は開発中の次のリリースで導入されます。ただし、内部的な理由により、以前のリリースのバグを修正した場合、それらも利用可能になり、発表されます。</target>
        </trans-unit>
        <trans-unit id="8591b3b2816e58b50758f8b5b1d4a64b54ea4bb8" translate="yes" xml:space="preserve">
          <source>In general, subpatterns that were not assigned a value in the match are returned as the tuple &lt;code&gt;{-1,0}&lt;/code&gt; when &lt;code&gt;type&lt;/code&gt; is &lt;code&gt;index&lt;/code&gt;. Unassigned subpatterns are returned as the empty binary or list, respectively, for other return types. Consider the following regular expression:</source>
          <target state="translated">一般に、 &lt;code&gt;type&lt;/code&gt; が &lt;code&gt;index&lt;/code&gt; の場合、一致で値が割り当てられなかったサブパターンは、タプル &lt;code&gt;{-1,0}&lt;/code&gt; として返されます。割り当てられていないサブパターンは、他の戻り型の場合、それぞれ空のバイナリまたはリストとして返されます。次の正規表現について考えてみます。</target>
        </trans-unit>
        <trans-unit id="264b6524a328aed18af181468f92444ef5d0e1cd" translate="yes" xml:space="preserve">
          <source>In general, the &lt;code&gt;ei&lt;/code&gt; library is guaranteed to be compatible with other Erlang/OTP components that are 2 major releases older or newer than the &lt;code&gt;ei&lt;/code&gt; library itself.</source>
          <target state="translated">一般に、 &lt;code&gt;ei&lt;/code&gt; ライブラリは、 &lt;code&gt;ei&lt;/code&gt; ライブラリ自体よりも古いまたは新しい2つのメジャーリリースである他のErlang / OTPコンポーネントとの互換性が保証されています。</target>
        </trans-unit>
        <trans-unit id="7b4248b8374fe10eea98b0157468a4afeb3bbaff" translate="yes" xml:space="preserve">
          <source>In general, there are better ways than using time-outs to supervise parts of a distributed Erlang system. Time-outs are usually appropriate to supervise external events, for example, if you have expected a message from some external system within a specified time. For example, a time-out can be used to log a user out of the messenger system if they have not accessed it for, say, ten minutes.</source>
          <target state="translated">一般的に、分散Erlangシステムの一部を監視するためにタイムアウトを使うよりも良い方法があります。例えば、指定した時間内に外部システムからのメッセージを期待している場合などです。例えば、タイムアウトはメッセンジャーシステムに10分間アクセスしていないユーザをログアウトさせるのに使えます。</target>
        </trans-unit>
        <trans-unit id="1f8e5e60557a33a0b1e1b193f222fccaafdbdfe2" translate="yes" xml:space="preserve">
          <source>In general, tuples are used where &quot;records&quot; or &quot;structs&quot; are used in other languages. Also, lists are used when representing things with varying sizes, that is, where linked lists are used in other languages.</source>
          <target state="translated">一般に、他の言語では「レコード」や「構造体」が使われている場合、タプルが使われます。また、大きさの異なるものを表現する場合にはリストが使われ、他の言語ではリンクされたリストが使われています。</target>
        </trans-unit>
        <trans-unit id="1094cd272fde4947e952467ed139509ff51ffbba" translate="yes" xml:space="preserve">
          <source>In general, versions can have more than three parts. The versions are then only partially ordered. Such versions are only used in exceptional cases. When an extra part (out of the normal three parts) is added to a version number, a new branch of versions is made. The new branch has a linear order against the base version. However, versions on different branches have no order, and therefore one can only conclude that they all include what is included in their closest common ancestor. When branching multiple times from the same base version, &lt;code&gt;0&lt;/code&gt; parts are added between the base version and the least significant &lt;code&gt;1&lt;/code&gt; part until a unique version is found. Versions that have an order can be compared as described in the previous paragraph.</source>
          <target state="translated">一般に、バージョンには4つ以上の部分があります。その後、バージョンは部分的にのみ注文されます。このようなバージョンは、例外的な場合にのみ使用されます。 （通常の3つのパーツのうち）追加のパーツがバージョン番号に追加されると、バージョンの新しいブランチが作成されます。新しいブランチは、基本バージョンに対して線形の順序を持​​っています。ただし、異なるブランチのバージョンには順序がないため、最も近い共通の祖先に含まれているものがすべて含まれていると結論付けることができます。同じ基本バージョンから複数回分岐する場合、一意のバージョンが見つかるまで、基本バージョンと最下位 &lt;code&gt;1&lt;/code&gt; パーツの間に &lt;code&gt;0&lt;/code&gt; パーツが追加されます。前の段落で説明したように、順序のあるバージョンを比較できます。</target>
        </trans-unit>
        <trans-unit id="ba987c1f9181380720aed267fac74a6f9ee0f607" translate="yes" xml:space="preserve">
          <source>In general, versions can have more than three parts. The versions are then only partially ordered. Such versions are only used when branching off from another branch. When an extra part (out of the normal three parts) is added to a version number, a new branch of versions is made. The new branch has a linear order against the base version. However, versions on different branches have no order, and therefore one can only conclude that they all include what is included in their closest common ancestor. When branching multiple times from the same base version, &lt;code&gt;0&lt;/code&gt; parts are added between the base version and the least significant &lt;code&gt;1&lt;/code&gt; part until a unique version is found. Versions that have an order can be compared as described in the previous paragraph.</source>
          <target state="translated">一般に、バージョンには3つ以上の部分があります。その後、バージョンは部分的にのみ注文されます。このようなバージョンは、別のブランチから分岐する場合にのみ使用されます。 （通常の3つの部分のうちの）余分な部分がバージョン番号に追加されると、バージョンの新しいブランチが作成されます。新しいブランチは、基本バージョンに対して線形の順序になっています。ただし、異なるブランチのバージョンには順序がないため、すべてに最も近い共通の祖先に含まれているものが含まれていると結論付けることしかできません。同じベースバージョンから複数回分岐する場合、一意のバージョンが見つかるまで、ベースバージョンと最下位の &lt;code&gt;1&lt;/code&gt; パーツの間に &lt;code&gt;0&lt;/code&gt; パーツが追加されます。前の段落で説明したように、順序のあるバージョンを比較できます。</target>
        </trans-unit>
        <trans-unit id="687a73013b2ef41da5625c9f94315c9a3c6f0e31" translate="yes" xml:space="preserve">
          <source>In global trace mode, the collector will automatically start tracing on all connected Erlang nodes. When a node connects, a port tracer will be started on that node and a corresponding trace client on the collector node.</source>
          <target state="translated">グローバルトレースモードでは、コレクタは自動的に接続されたすべての Erlang ノードのトレースを開始します。ノードが接続されると、そのノード上でポートトレーサが開始され、コレクタノード上で対応するトレースクライアントが開始されます。</target>
        </trans-unit>
        <trans-unit id="f00745ad8caa1afca6bdd4f2b710aba925b97dcb" translate="yes" xml:space="preserve">
          <source>In instructions that will not always execute the next instruction. For example:</source>
          <target state="translated">常に次の命令を実行するとは限らない命令では 例えば</target>
        </trans-unit>
        <trans-unit id="581aa3bc4711cf7334b4a74e7f3a343e5b4ccbeb" translate="yes" xml:space="preserve">
          <source>In interactive mode, the code is dynamically loaded when first referenced. When a call to a function in a module is made, and the module is not loaded, the code server searches the code path and loads the module into the system.</source>
          <target state="translated">インタラクティブ・モードでは、最初に参照されたときにコードが動的にロードされます。モジュール内の関数への呼び出しが行われ、モジュールがロードされていない場合、コードサーバはコードパスを検索し、モジュールをシステムにロードします。</target>
        </trans-unit>
        <trans-unit id="e0d2190b345450b7396978e3dbbae9980e03e388" translate="yes" xml:space="preserve">
          <source>In interactive mode, the code server maintains a search path, usually called the &lt;strong&gt;code path&lt;/strong&gt;, consisting of a list of directories, which it searches sequentially when trying to load a module.</source>
          <target state="translated">インタラクティブモードでは、コードサーバーは、ディレクトリのリストで構成される、通常は&lt;strong&gt;コードパス&lt;/strong&gt;と呼ばれる検索パスを維持します。このリストは、モジュールをロードするときに順次検索されます。</target>
        </trans-unit>
        <trans-unit id="1430b49bd146817f97ef7d06df225a493f066b2a" translate="yes" xml:space="preserve">
          <source>In interactive mode, which is default, only some code is loaded during system startup, basically the modules needed by the runtime system. Other code is dynamically loaded when first referenced. When a call to a function in a certain module is made, and the module is not loaded, the code server searches for and tries to load the module.</source>
          <target state="translated">デフォルトの対話型モードでは、システム起動時に一部のコードのみがロードされ、基本的にはランタイムシステムが必要とするモジュールがロードされます。その他のコードは、最初に参照されたときに動的にロードされます。特定のモジュール内の関数への呼び出しが行われ、そのモジュールがロードされない場合、コードサーバはそのモジュールを検索してロードしようとします。</target>
        </trans-unit>
        <trans-unit id="1a03bca7ddee9e30128d1091183803f61a0b8991" translate="yes" xml:space="preserve">
          <source>In its simplest forms, the &lt;code&gt;match_spec&lt;/code&gt; look as follows:</source>
          <target state="translated">最も単純な形式では、 &lt;code&gt;match_spec&lt;/code&gt; は次のようになります。</target>
        </trans-unit>
        <trans-unit id="7ce538d7f4c53ffc660905f0d2354601ebec0177" translate="yes" xml:space="preserve">
          <source>In local mode, code is interpreted only at the current node. In global mode, code is interpreted at all known nodes. Processes at other nodes executing interpreted code are automatically displayed in the Monitor window and can be attached to like any other debugged process.</source>
          <target state="translated">ローカルモードでは、コードは現在のノードでのみ解釈されます。グローバルモードでは、既知のすべてのノードでコードが解釈されます。解釈されたコードを実行している他のノードのプロセスは、自動的に Monitor ウィンドウに表示され、他のデバッグされたプロセスと同様にアタッチすることができます。</target>
        </trans-unit>
        <trans-unit id="67bf06325d8975b88277745da18879c2a83cda5c" translate="yes" xml:space="preserve">
          <source>In low-memory systems (especially without virtual memory), setting the value to &lt;code&gt;0&lt;/code&gt; can help to conserve memory.</source>
          <target state="translated">メモリが少ないシステム（特に仮想メモリがないシステム）では、値を &lt;code&gt;0&lt;/code&gt; に設定するとメモリを節約できます。</target>
        </trans-unit>
        <trans-unit id="aff1ae241ba5a53367c964ba35e7d8b8a0df1b6b" translate="yes" xml:space="preserve">
          <source>In many applications, the overhead of processing a transaction can result in a loss of performance. Dirty operation are short cuts that bypass much of the processing and increase the speed of the transaction.</source>
          <target state="translated">多くのアプリケーションでは、トランザクション処理のオーバーヘッドにより、パフォーマンスが低下することがあります。ダーティオペレーションとは、処理の多くをバイパスしてトランザクションの速度を向上させるショートカットです。</target>
        </trans-unit>
        <trans-unit id="dd0e2f590c5adecb73ed1090aefb1bdd2efeb4bf" translate="yes" xml:space="preserve">
          <source>In many systems, transient states of overloaded queues are normal. Although this function returns &lt;code&gt;false&lt;/code&gt; does not mean that the other node is guaranteed to be non-responsive, it could be a temporary overload. Also, a return value of &lt;code&gt;true&lt;/code&gt; does only mean that the message can be sent on the (TCP) channel without blocking; the message is not guaranteed to arrive at the remote node. For a disconnected non-responsive node, the return value is &lt;code&gt;true&lt;/code&gt; (mimics the behavior of operator &lt;code&gt;!&lt;/code&gt;). The expected behavior and the actions to take when the function returns &lt;code&gt;false&lt;/code&gt; are application- and hardware-specific.</source>
          <target state="translated">多くのシステムでは、過負荷のキューの一時的な状態は正常です。この関数が &lt;code&gt;false&lt;/code&gt; を返すことは、他のノードが応答しないことが保証されていることを意味するものではありませんが、一時的な過負荷である可能性があります。また、 &lt;code&gt;true&lt;/code&gt; の戻り値は、メッセージをブロックせずに（TCP）チャネルで送信できることを意味するだけです。メッセージがリモートノードに到着することは保証されていません。切断された非応答ノードの場合、戻り値は &lt;code&gt;true&lt;/code&gt; です（演算子 &lt;code&gt;!&lt;/code&gt; の動作を模倣しています）。期待される動作と、関数が &lt;code&gt;false&lt;/code&gt; を返したときに実行するアクションは、アプリケーションおよびハードウェアによって異なります。</target>
        </trans-unit>
        <trans-unit id="e52c3f887ab093e6f06a26dfc4388cf3cf2eeed6" translate="yes" xml:space="preserve">
          <source>In matching, this default value is only valid for the last element. All other bit string or binary elements in the matching must have a size specification.</source>
          <target state="translated">マッチングでは、このデフォルト値は最後の要素に対してのみ有効です。マッチングの他のすべてのビット文字列またはバイナリ要素は、サイズ指定が必要です。</target>
        </trans-unit>
        <trans-unit id="0ea9b87be6bd6a217fdf52f85ea3b695fde92834" translate="yes" xml:space="preserve">
          <source>In microseconds</source>
          <target state="translated">マイクロ秒で</target>
        </trans-unit>
        <trans-unit id="74df42bf134f27883f855d9ef2904cba9dbfb304" translate="yes" xml:space="preserve">
          <source>In mode &lt;code&gt;verify_none&lt;/code&gt; the default behavior is to allow all x509-path validation errors. See also option &lt;code&gt;&lt;a href=&quot;#type-custom_verify&quot;&gt;verify_fun&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">モード &lt;code&gt;verify_none&lt;/code&gt; では、デフォルトの動作はすべてのx509パス検証エラーを許可することです。オプション &lt;code&gt;&lt;a href=&quot;#type-custom_verify&quot;&gt;verify_fun&lt;/a&gt;&lt;/code&gt; も参照してください。</target>
        </trans-unit>
        <trans-unit id="e9f9c5ec8a0a2225edde7d56a03b4792532c31fc" translate="yes" xml:space="preserve">
          <source>In mode &lt;code&gt;verify_none&lt;/code&gt; the default behavior is to allow all x509-path validation errors. See also option &lt;code&gt;verify_fun&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;verify_none&lt;/code&gt; モードでは、デフォルトの動作は、すべてのx509パス検証エラーを許可することです。オプション &lt;code&gt;verify_fun&lt;/code&gt; も参照してください。</target>
        </trans-unit>
        <trans-unit id="adc9bd54e329d8564e9dd0fe90f0559b96ad7e59" translate="yes" xml:space="preserve">
          <source>In more technical terms, &lt;code&gt;erlang:hibernate/3&lt;/code&gt; discards the call stack for the process, and then garbage collects the process. After this, all live data is in one continuous heap. The heap is then shrunken to the exact same size as the live data that it holds (even if that size is less than the minimum heap size for the process).</source>
          <target state="translated">より専門的な用語では、 &lt;code&gt;erlang:hibernate/3&lt;/code&gt; はプロセスのコールスタックを破棄し、その後、ガベージコレクションによってプロセスを収集します。この後、すべてのライブデータは1つの連続したヒープに格納されます。ヒープは、保持しているライブデータとまったく同じサイズに縮小されます（そのサイズがプロセスの最小ヒープサイズよりも小さい場合でも）。</target>
        </trans-unit>
        <trans-unit id="7eeb2170c3262e24c6e629309332632b0551f1eb" translate="yes" xml:space="preserve">
          <source>In most API functions where you can use this address family the port number must be &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">このアドレスファミリを使用できるほとんどのAPI関数では、ポート番号は &lt;code&gt;0&lt;/code&gt; でなければなりません。</target>
        </trans-unit>
        <trans-unit id="96533e214a0da4a7dc13f9539128fcec0a90372f" translate="yes" xml:space="preserve">
          <source>In most cases, the &lt;code&gt;RootDir&lt;/code&gt; parameter should be set to the same as the &lt;code&gt;root_dir&lt;/code&gt; configuration parameter used in the call to &lt;code&gt;reltool:get_target_spec/1&lt;/code&gt; (or &lt;code&gt;code:root_dir()&lt;/code&gt; if the configuration parameter is not set). In some cases it might be useful to evaluate the same target specification towards different root directories. This should, however, be used with great care as it requires equivalent file structures under all roots.</source>
          <target state="translated">ほとんどの場合、 &lt;code&gt;RootDir&lt;/code&gt; パラメーターは、 &lt;code&gt;reltool:get_target_spec/1&lt;/code&gt; （または設定パラメーターが設定されていない場合は &lt;code&gt;code:root_dir()&lt;/code&gt; )の呼び出しで使用される &lt;code&gt;root_dir&lt;/code&gt; 設定パラメーターと同じに設定する必要があります。場合によっては、同じターゲット仕様を異なるルートディレクトリに対して評価することが役立つことがあります。ただし、すべてのルートで同等のファイル構造が必要になるため、注意して使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="e5e6c46f0b948281f508f56232b244f2c0be68d3" translate="yes" xml:space="preserve">
          <source>In normal mode keystrokes from the user are collected and interpreted by &lt;code&gt;tty&lt;/code&gt;. Most of the &lt;strong&gt;Emacs&lt;/strong&gt; line-editing commands are supported. The following is a complete list of the supported line-editing commands.</source>
          <target state="translated">通常モードでは、ユーザーからのキーストロークが収集され、 &lt;code&gt;tty&lt;/code&gt; によって解釈されます。ほとんどの&lt;strong&gt;Emacs&lt;/strong&gt;行編集コマンドがサポートされています。以下は、サポートされている行編集コマンドの完全なリストです。</target>
        </trans-unit>
        <trans-unit id="1b91ce563204e764cc3b634a1e770a9c50a8ab66" translate="yes" xml:space="preserve">
          <source>In normal operation, the &lt;code&gt;et:trace_me/4,5&lt;/code&gt; calls are almost for free. When tracing is needed, you can either activate tracing on these functions explicitly. Or you can combine the usage of &lt;code&gt;trace_global&lt;/code&gt; with the usage of &lt;code&gt;trace_pattern&lt;/code&gt;. When set, the &lt;code&gt;trace_pattern&lt;/code&gt; will automatically be activated on all connected nodes.</source>
          <target state="translated">通常の操作では、 &lt;code&gt;et:trace_me/4,5&lt;/code&gt; の呼び出しはほぼ無料です。トレースが必要な場合は、これらの関数のトレースを明示的にアクティブにすることができます。それともの使い方組み合わせることができ &lt;code&gt;trace_global&lt;/code&gt; をの使用に &lt;code&gt;trace_pattern&lt;/code&gt; 。設定すると、接続されているすべてのノードで &lt;code&gt;trace_pattern&lt;/code&gt; が自動的にアクティブになります。</target>
        </trans-unit>
        <trans-unit id="eae1f10c8b9d4c5e175d3fc8937d4ffde9c0f51a" translate="yes" xml:space="preserve">
          <source>In order for an &lt;code&gt;erpc&lt;/code&gt; operation to succeed, the remote node also needs to support &lt;code&gt;erpc&lt;/code&gt;. Typically only ordinary Erlang nodes as of OTP 23 have &lt;code&gt;erpc&lt;/code&gt; support.</source>
          <target state="translated">ためには &lt;code&gt;erpc&lt;/code&gt; 成功するための操作、遠隔ノードもサポートしている必要があり &lt;code&gt;erpc&lt;/code&gt; 。通常、 &lt;code&gt;erpc&lt;/code&gt; 時点で通常のErlangノードのみがerpcをサポートしています。</target>
        </trans-unit>
        <trans-unit id="01f7caa16342ff7be996c443808331cb189b3fd2" translate="yes" xml:space="preserve">
          <source>In order for an implementation to make full use of the enhanced SNMPv2 error codes, it is essential that the instrumentation functions always return SNMPv2 error codes, in case of error. These are translated into the corresponding SNMPv1 error codes by the agent, if necessary.</source>
          <target state="translated">強化されたSNMPv2エラーコードをフルに活用するためには、エラーが発生した場合、計測機能が常にSNMPv2エラーコードを返すことが不可欠です。これらのエラーコードは、必要に応じてエージェントによって対応するSNMPv1エラーコードに変換されます。</target>
        </trans-unit>
        <trans-unit id="91f9f99c50f34dfe6347f220890a64d23f9ce151" translate="yes" xml:space="preserve">
          <source>In order for the Erlang driver thread API to function, thread support must be enabled in the runtime system. An Erlang driver can check if thread support is enabled by use of &lt;code&gt;&lt;a href=&quot;#driver_system_info&quot;&gt; driver_system_info&lt;/a&gt;&lt;/code&gt;. Notice that some functions in the Erlang driver API are thread-safe only when the runtime system has SMP support, also this information can be retrieved through &lt;code&gt;&lt;a href=&quot;#driver_system_info&quot;&gt; driver_system_info&lt;/a&gt;&lt;/code&gt;. Also notice that many functions in the Erlang driver API are &lt;strong&gt;not&lt;/strong&gt; thread-safe, regardless of whether SMP support is enabled or not. If a function is not documented as thread-safe, it is &lt;strong&gt;not&lt;/strong&gt; thread-safe.</source>
          <target state="translated">ErlangドライバースレッドAPIが機能するためには、ランタイムシステムでスレッドサポートを有効にする必要があります。 Erlangドライバーは、 &lt;code&gt;&lt;a href=&quot;#driver_system_info&quot;&gt; driver_system_info&lt;/a&gt;&lt;/code&gt; を使用してスレッドサポートが有効になっているかどうかを確認できます。 ErlangドライバーAPIの一部の関数は、ランタイムシステムがSMPをサポートしている場合にのみスレッドセーフであることに注意して &lt;code&gt;&lt;a href=&quot;#driver_system_info&quot;&gt; driver_system_info&lt;/a&gt;&lt;/code&gt; 。また、この情報はdriver_system_infoから取得できます。また、SMPサポートが有効になっているかどうかに関係なく、ErlangドライバーAPIの多くの関数&lt;strong&gt;は&lt;/strong&gt;スレッドセーフでは&lt;strong&gt;ない&lt;/strong&gt;ことに注意してください。関数がスレッドセーフとして文書化されていない場合、それはスレッドセーフではあり&lt;strong&gt;ません&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="5554904f6399d518ff690b91bb8e000b4bc410eb" translate="yes" xml:space="preserve">
          <source>In order for the Erlang driver thread API to function, thread support must be enabled in the runtime system. An Erlang driver can check if thread support is enabled by use of &lt;code&gt;&lt;a href=&quot;#driver_system_info&quot;&gt;driver_system_info&lt;/a&gt;&lt;/code&gt;. Notice that some functions in the Erlang driver API are thread-safe only when the runtime system has SMP support, also this information can be retrieved through &lt;code&gt;&lt;a href=&quot;#driver_system_info&quot;&gt;driver_system_info&lt;/a&gt;&lt;/code&gt;. Also notice that many functions in the Erlang driver API are &lt;strong&gt;not&lt;/strong&gt; thread-safe, regardless of whether SMP support is enabled or not. If a function is not documented as thread-safe, it is &lt;strong&gt;not&lt;/strong&gt; thread-safe.</source>
          <target state="translated">ErlangドライバーのスレッドAPIを機能させるには、ランタイムシステムでスレッドサポートを有効にする必要があります。 Erlangドライバーは、 &lt;code&gt;&lt;a href=&quot;#driver_system_info&quot;&gt;driver_system_info&lt;/a&gt;&lt;/code&gt; を使用してスレッドサポートが有効になっているかどうかを確認できます。 ErlangドライバーAPIの一部の関数は、ランタイムシステムがSMPをサポートしている場合にのみスレッドセーフになることに注意して &lt;code&gt;&lt;a href=&quot;#driver_system_info&quot;&gt;driver_system_info&lt;/a&gt;&lt;/code&gt; 。また、この情報はdriver_system_infoを介して取得できます。また、SMPサポートが有効になっているかどうかに関係なく、ErlangドライバAPIの多くの関数&lt;strong&gt;は&lt;/strong&gt;スレッドセーフでは&lt;strong&gt;ない&lt;/strong&gt;ことに注意してください。関数がスレッドセーフとして文書化されていない場合、その関数はスレッドセーフではあり&lt;strong&gt;ません&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="652d6f0f7f2fd0f26e6c7835ec2944249c814b15" translate="yes" xml:space="preserve">
          <source>In order for the break/continue functionality to work, &lt;code&gt;Common Test&lt;/code&gt; must release the shell process controlling &lt;code&gt;stdin&lt;/code&gt;. This is done by setting start option &lt;code&gt;release_shell&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt;. For details, see section &lt;code&gt;&lt;a href=&quot;run_test_chapter#erlang_shell_or_program&quot;&gt;Running Tests from the Erlang Shell or from an Erlang Program&lt;/a&gt;&lt;/code&gt; in the User's Guide.</source>
          <target state="translated">ブレーク/継続機能が機能するためには、 &lt;code&gt;Common Test&lt;/code&gt; が &lt;code&gt;stdin&lt;/code&gt; を制御するシェルプロセスを解放する必要があります。これは、起動オプション &lt;code&gt;release_shell&lt;/code&gt; を &lt;code&gt;true&lt;/code&gt; に設定することによって行われます。詳細については、ユーザーガイドの「 &lt;code&gt;&lt;a href=&quot;run_test_chapter#erlang_shell_or_program&quot;&gt;Running Tests from the Erlang Shell or from an Erlang Program&lt;/a&gt;&lt;/code&gt; 」を参照してください。</target>
        </trans-unit>
        <trans-unit id="6e5ab42b46c29034052cc72be40b7ac14c2d1e1e" translate="yes" xml:space="preserve">
          <source>In order for the runtime system to be able to bind schedulers, the CPU topology must be known. If the runtime system fails to detect the CPU topology automatically, it can be defined. For more information on how to define the CPU topology, see command-line flag &lt;code&gt; +sct&lt;/code&gt; in &lt;code&gt;erl(1)&lt;/code&gt;.</source>
          <target state="translated">ランタイムシステムがスケジューラをバインドできるようにするには、CPUトポロジがわかっている必要があります。ランタイムシステムがCPUトポロジを自動的に検出できない場合は、それを定義できます。CPUトポロジを定義する方法の詳細については、 &lt;code&gt;erl(1)&lt;/code&gt; のコマンドラインフラグ &lt;code&gt; +sct&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="78380f5cb098afa599c64e0ffb0ba494ac35ede5" translate="yes" xml:space="preserve">
          <source>In order for the runtime system to be able to bind schedulers, the CPU topology must be known. If the runtime system fails to detect the CPU topology automatically, it can be defined. For more information on how to define the CPU topology, see command-line flag &lt;code&gt;+sct&lt;/code&gt; in &lt;code&gt;erl(1)&lt;/code&gt;.</source>
          <target state="translated">ランタイムシステムがスケジューラをバインドできるようにするには、CPUトポロジがわかっている必要があります。ランタイムシステムがCPUトポロジを自動的に検出できない場合は、それを定義できます。CPUトポロジを定義する方法の詳細については、 &lt;code&gt;erl(1)&lt;/code&gt; のコマンドラインフラグ &lt;code&gt;+sct&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="dca7b006090165b7c3c9be08fcb7f845ac2dfef6" translate="yes" xml:space="preserve">
          <source>In order for this to work properly, the user must ensure that the following two requirements are satisfied:</source>
          <target state="translated">これを正常に動作させるためには、以下の2つの要件を満たしていることを確認する必要があります。</target>
        </trans-unit>
        <trans-unit id="7316234f8d0404e7bccb8d56aec4837d25e8e904" translate="yes" xml:space="preserve">
          <source>In order to allow minimizing the performance loss, the &lt;code&gt;file_check&lt;/code&gt; parameter can be set to a positive integer value, &lt;code&gt;N&lt;/code&gt;. The handler will then skip reading the file information prior to writing, as long as no more than &lt;code&gt;N&lt;/code&gt; milliseconds have passed since it was last read.</source>
          <target state="translated">パフォーマンスの低下を最小限に抑えるために、 &lt;code&gt;file_check&lt;/code&gt; パラメーターを正の整数値 &lt;code&gt;N&lt;/code&gt; に設定できます。ハンドラーは、最後に読み取られてから &lt;code&gt;N&lt;/code&gt; ミリ秒以内が経過している限り、書き込む前にファイル情報の読み取りをスキップします。</target>
        </trans-unit>
        <trans-unit id="cc5fcbbc4da3a883acc2844e1722d4a3096e07d7" translate="yes" xml:space="preserve">
          <source>In order to append this data to the end of the motorcycles.xml document you have to parse the file and add Data to the end of the root element content.</source>
          <target state="translated">このデータをmotorcycles.xmlドキュメントの最後に追加するには、ファイルを解析し、ルート要素のコンテンツの最後にDataを追加する必要があります。</target>
        </trans-unit>
        <trans-unit id="1cc2af703c741622a9752f6130d1aed382c381ac" translate="yes" xml:space="preserve">
          <source>In order to avoid these situations we wanted to be able to do most of the fundamental operations on a process without having to acquire a lock on the process. Some examples of such fundamental operations are, moving a process between run queues, detecting if we need to insert it into a run queue or not, detecting if it is alive or not.</source>
          <target state="translated">このような状況を避けるために、プロセスのロックを取得することなく、プロセスのほとんどの基本的な操作ができるようにしたいと考えました。このような基本的な操作の例としては、プロセスをランキュー間で移動させたり、ランキューにプロセスを挿入する必要があるかどうかを検出したり、プロセスが生きているかどうかを検出したりすることが挙げられます。</target>
        </trans-unit>
        <trans-unit id="9606b78a849c5b14fbde9a528c5423519c626033" translate="yes" xml:space="preserve">
          <source>In order to be able to decide which run queue to use without having to lock any run queues, we moved all fixed balancing information out of the run queues into a global memory block. That is, migration paths and run queue limits. Information that need to be frequently updated, like for example maximum run queue length, were kept in the run queue, but instead of operating on this information under locks we now use atomic memory operations when accessing this information. This made it possible to first determine which run queue to use, without locking any run queues, and when decided, lock the chosen run queue and insert the process.</source>
          <target state="translated">どのランキューをロックすることなく、どのランキューを使用するかを決定できるようにするために、すべての固定バランシング情報をランキューからグローバルメモリブロックに移動しました。つまり、マイグレーションパスとランキューの制限です。例えばランキューの最大長など、頻繁に更新する必要がある情報はランキューに保持されていましたが、ロックの下でこれらの情報を操作する代わりに、これらの情報にアクセスする際にはアトミックなメモリ操作を使用するようになりました。これにより、ランキューをロックすることなく、まずどのランキューを使用するかを決定し、決定したら、選択したランキューをロックしてプロセスを挿入することが可能になりました。</target>
        </trans-unit>
        <trans-unit id="7c4f9a3c32af1c0aebd8c724db9f1fd7c9cd27f7" translate="yes" xml:space="preserve">
          <source>In order to be able to detect when it is safe to deallocate a previously used process structure, reference counting of the structure was used. Also this was problematic, since simultaneous lookups needed to modify the reference counter which also caused contention on the cache line where the reference counter was located. This since all modifications needs to be communicated between all involved processors.</source>
          <target state="translated">以前に使用したプロセス構造体を解放しても安全なときを検出できるようにするために、構造体の参照カウントを使用していました。また、同時に参照カウンタを修正する必要があるため、参照カウンタがあるキャッシュライン上で競合が発生してしまうという問題もありました。これは、すべての変更がすべての関係するプロセッサ間で通信される必要があるためです。</target>
        </trans-unit>
        <trans-unit id="248b6946fb3d78aedfd7eb1945dab3d08fcb73b1" translate="yes" xml:space="preserve">
          <source>In order to be able to determine when all managed threads have reached the states that we are interested in we need to communicate between all involved threads. We of course want to minimize this communication.</source>
          <target state="translated">管理されているすべてのスレッドが興味のある状態に到達したときに判断できるようにするためには、関係するすべてのスレッド間で通信を行う必要があります。もちろん、この通信は最小限に抑えたいものです。</target>
        </trans-unit>
        <trans-unit id="b21c20f0ab3dedd86e0307763e8d967cc669941c" translate="yes" xml:space="preserve">
          <source>In order to be able to remove a carrier from one allocator instance and add it to another we need to be able to move references to the free blocks of the carrier between the allocator instances. The allocator instance specific data structure referring to the free blocks it manages often refers to the same carrier from multiple places. For example, when the address order best-fit strategy is used this data structure is a binary search tree spanning all carriers that the allocator instance manages. Free blocks in one specific carrier can be referred to from potentially every other carrier that is managed, and the amount of such references can be huge. That is, the work of removing the free blocks of such a carrier from the search tree will be huge. One way of solving this could be not to migrate carriers that contain lots of free blocks, but this would prevent us from migrating carriers that potentially need to be migrated in order to solve the problem we set out to solve.</source>
          <target state="translated">あるアロケータインスタンスからキャリアを削除して別のアロケータインスタンスに追加できるようにするには、そのキャリアのフリーブロックへの参照をアロケータインスタンス間で移動できるようにする必要がある。それが管理するフリーブロックを参照するアロケータインスタンス固有のデータ構造は、複数の場所から同じキャリアを参照することが多い。例えば、アドレス順ベストフィット戦略が使用される場合、このデータ構造は、アロケータインスタンスが管理する全てのキャリアにまたがるバイナリ検索ツリーである。ある特定のキャリアのフリーブロックは、潜在的に管理されている他のすべてのキャリアから参照される可能性があり、そのような参照の量は膨大なものになる可能性があります。つまり、そのようなキャリアのフリーブロックを検索ツリーから削除する作業は膨大なものになります。これを解決する一つの方法は、多くの空きブロックを含むキャリアを移行しないことですが、これは私たちが解決しようとした問題を解決するために移行する必要があるキャリアを移行することを妨げることになります。</target>
        </trans-unit>
        <trans-unit id="e98a8e7d2e52da6dad36a29e2bdfa8a3172fe51b" translate="yes" xml:space="preserve">
          <source>In order to compile Erlang code, a small Erlang bootstrap system has to be built, or an Erlang/OTP system of the same release as the one being built has to be provided in the &lt;code&gt;$PATH&lt;/code&gt;. The Erlang/OTP for the target system will be built using this Erlang system, together with the cross compilation tools provided.</source>
          <target state="translated">Erlangコードをコンパイルするには、小さなErlangブートストラップシステムを構築するか、構築中のリリースと同じリリースのErlang / OTPシステムを &lt;code&gt;$PATH&lt;/code&gt; 提供する必要があります。ターゲットシステムのErlang / OTPは、このErlangシステムと、提供されているクロスコンパイルツールを使用して構築されます。</target>
        </trans-unit>
        <trans-unit id="33c36db64d09c1349048183a11365e092986cc43" translate="yes" xml:space="preserve">
          <source>In order to determine when the events has happened we use a global counter that is incremented when all managed threads have called &lt;code&gt;erts_thr_progress_update()&lt;/code&gt; (or &lt;code&gt;erts_thr_progress_leader_update()&lt;/code&gt;). This could naively be implemented using a &quot;thread confirmed&quot; counter. This would however cause an explosion of communication where all involved processors would need to communicate with each other at each update.</source>
          <target state="translated">イベントがいつ発生したかを判断するために、すべての管理対象スレッドが &lt;code&gt;erts_thr_progress_update()&lt;/code&gt; （または &lt;code&gt;erts_thr_progress_leader_update()&lt;/code&gt; ）を呼び出したときにインクリメントされるグローバルカウンターを使用します。これは、「スレッド確認済み」カウンターを使用して単純に実装できます。ただし、これにより通信が爆発的に増加し、関係するすべてのプロセッサが更新のたびに相互に通信する必要があります。</target>
        </trans-unit>
        <trans-unit id="fa8bd01b2e2143b89a5d070a42db3498a1a3a7f5" translate="yes" xml:space="preserve">
          <source>In order to ensure data integrity, mutex'es are taken when needed. So, do not call this function often.</source>
          <target state="translated">データの整合性を確保するために、必要に応じてミューテックスが取られます。そのため、この関数を頻繁に呼び出さないようにしてください。</target>
        </trans-unit>
        <trans-unit id="3bbb01425e78fa9829f765ceacdcbc84ac1251f2" translate="yes" xml:space="preserve">
          <source>In order to fit better into your existing logging infrastructure Logger can format its logging messages any way you want to. Either you can use the built-in formatter, or you can build your own.</source>
          <target state="translated">既存のロギング インフラストラクチャにより良くフィットするために、ロガーはロギング メッセージを任意の方法でフォーマットすることができます。組み込みのフォーマッタを使用することも、独自のフォーマッタを構築することもできます。</target>
        </trans-unit>
        <trans-unit id="15ce32715d8736617da44b2f7221256f14487b54" translate="yes" xml:space="preserve">
          <source>In order to fully understand the internal form you must get hold on a ASN.1 specification for the Megaco/H.248 protocol, and apply the rules above. Please, see the documentation of the ASN.1 compiler in Erlang/OTP for more details of the semantics in mapping between ASN.1 and the corresponding internal form.</source>
          <target state="translated">内部フォームを完全に理解するためには、Megaco/H.248プロトコルのASN.1仕様を手に入れて、上記のルールを適用する必要があります。ASN.1と対応する内部形式のマッピングのセマンティクスの詳細については、Erlang/OTPのASN.1コンパイラのドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="ea6d5c582d5491e2165d48386242957c6fe3d344" translate="yes" xml:space="preserve">
          <source>In order to further simplify the tracing, you can make use of the &lt;code&gt;et:trace_me/4,5&lt;/code&gt; functions. These functions are intended to be invoked from other applications when there are interesting &lt;code&gt;Events&lt;/code&gt;, in your application that needs to be highlighted. The functions are extremely light weight as they do nothing besides returning an atom. These functions are specifically designed to be traced for. As the caller explicitly provides the values for the &lt;code&gt;Event Record&lt;/code&gt; fields, the default &lt;code&gt;Collector Filter&lt;/code&gt; is able to automatically provide a customized &lt;code&gt;Event Record&lt;/code&gt; without any user defined filter functions.</source>
          <target state="translated">トレースをさらに簡略化するために、 &lt;code&gt;et:trace_me/4,5&lt;/code&gt; 関数を使用できます。これらの関数は、アプリケーションで強調表示する必要のある興味深い &lt;code&gt;Events&lt;/code&gt; があるときに、他のアプリケーションから呼び出されることを目的としています。これらの関数は、アトムを返す以外に何もしないため、非常に軽量です。これらの関数は、トレースするように特別に設計されています。呼び出し元が &lt;code&gt;Event Record&lt;/code&gt; フィールドの値を明示的に提供するため、デフォルトの &lt;code&gt;Collector Filter&lt;/code&gt; は、ユーザー定義のフィルター関数なしで、カスタマイズされた &lt;code&gt;Event Record&lt;/code&gt; を自動的に提供できます。</target>
        </trans-unit>
        <trans-unit id="d72fdffcde207532623f4383c3bcc9252d8eb8ee" translate="yes" xml:space="preserve">
          <source>In order to implement delay of thread progress from unmanaged threads we use two reference counters. One being &lt;code&gt;current&lt;/code&gt; and one being &lt;code&gt;waiting&lt;/code&gt;. When an unmanaged thread wants to delay thread progress it increments &lt;code&gt;current&lt;/code&gt; and gets a handle back to the reference counter it incremented. When it later wants to enable continuation of thread progress it uses the handle to decrement the reference counter it previously incremented.</source>
          <target state="translated">アンマネージスレッドからのスレッド進行の遅延を実装するために、2つの参照カウンターを使用します。1つは &lt;code&gt;current&lt;/code&gt; 、もう1つは &lt;code&gt;waiting&lt;/code&gt; です。アンマネージスレッドがスレッドの進行を遅らせたい場合、 &lt;code&gt;current&lt;/code&gt; スレッドをインクリメントし、インクリメントした参照カウンターへのハンドルを取得します。後でスレッドの進行の継続を有効にしたい場合は、ハンドルを使用して、以前にインクリメントした参照カウンターをデクリメントします。</target>
        </trans-unit>
        <trans-unit id="03fc72bd9eea1c19e5c0da63c18725fd1977b35e" translate="yes" xml:space="preserve">
          <source>In order to improve this, state information was re-organized in the port structer, so that we can access it using atomic memory operations. This together with the new port table implementation, enabled us to lookup the port and inspect the state before acquiring the port lock, which in turn made it possible to perform preparations of signal data before acquiring the port lock.</source>
          <target state="translated">これを改善するために、ポート構造体の中で状態情報を再整理し、アトミックメモリ操作でアクセスできるようにしました。これにより、新しいポートテーブルの実装と合わせて、ポートロックを取得する前にポートを検索して状態を調べることができるようになり、ポートロックを取得する前に信号データの準備を行うことができるようになりました。</target>
        </trans-unit>
        <trans-unit id="d79e2feac48e88d730a559bbb82e697ebe900339" translate="yes" xml:space="preserve">
          <source>In order to make Xref easy to use, there are predefined analyses that perform some common tasks. Typically, a module or a release can be checked for calls to undefined functions. For the somewhat more advanced user there is a small, but rather flexible, language that can be used for selecting parts of the analyzed system and for doing some simple graph analyses on selected calls.</source>
          <target state="translated">Xrefを使いやすくするために、いくつかの一般的なタスクを実行する定義済みの解析があります。一般的に、モジュールやリリースは未定義の関数の呼び出しをチェックすることができます。やや上級者向けには、分析されたシステムの一部を選択したり、選択された呼び出しに対して簡単なグラフ分析を行うために使用できる、小さな、しかし柔軟性のある言語があります。</target>
        </trans-unit>
        <trans-unit id="aea5444714eb91d126874c6a93a730087a09d9a5" translate="yes" xml:space="preserve">
          <source>In order to migrate carriers between allocator instances we move them through a pool of carriers. In order for a carrier migration to complete, one scheduler needs to move the carrier into the pool, and another scheduler needs to take the carrier out of the pool.</source>
          <target state="translated">アロケータインスタンス間でキャリアを移行するために、キャリアのプールを介してキャリアを移動します。キャリアの移行を完了させるためには、あるスケジューラがキャリアをプールに移動し、別のスケジューラがキャリアをプールから取り出す必要があります。</target>
        </trans-unit>
        <trans-unit id="28832355c97c24952004ab393607d4cf79bc0d06" translate="yes" xml:space="preserve">
          <source>In order to prepare the MG for the sending of the initial message, hopefully a Service Change Request, the following needs to be done:</source>
          <target state="translated">初期メッセージ(できればサービス変更要求)の送信に備えてMGを準備するためには、以下のことを行う必要があります。</target>
        </trans-unit>
        <trans-unit id="420729e1fc23e88c8dd82e270ff2157af4611c2e" translate="yes" xml:space="preserve">
          <source>In order to prepare the MGC for the reception of the initial message, hopefully a Service Change Request, the following needs to be done:</source>
          <target state="translated">最初のメッセージ(できればサービス変更要求)を受信できるように準備するためには、以下のことを行う必要があります。</target>
        </trans-unit>
        <trans-unit id="45fb88d2abad8087318cf9186878fe028a795bdf" translate="yes" xml:space="preserve">
          <source>In order to prevent multiple schedulers from trying to execute signals to/from the same port simultaneously, we need to be able to ensure that all signals to/from a port are executed in sequence on one scheduler. More or less, the only way to do this is to schedule all types of signals. Signals corresponding to a port can then be executed in sequence by one single scheduler thread. If only one thread tries to execute the port, no contention will appear on the port lock. Besides getting rid of the contention, processes sending signals to the port can also continue execution of their own Erlang code on other schedulers at the same time as the signaling code is executing on another scheduler.</source>
          <target state="translated">複数のスケジューラが同じポートへの/からの信号を同時に実行しようとするのを防ぐためには、ポートへの/からのすべての信号が1つのスケジューラ上で順番に実行されることを確実にする必要があります。多かれ少なかれ、これを実現する唯一の方法は、すべてのタイプのシグナルをスケジューリングすることです。そして、ポートに対応するシグナルは、1つのスケジューラのスレッドで順番に実行することができます。1つのスレッドだけがポートを実行しようとすると、ポートロックに競合は現れません。競合を取り除く以外にも、ポートにシグナルを送っているプロセスは他のスケジューラでシグナリングコードが実行されている間に、自分のErlangコードを他のスケジューラで実行し続けることができます。</target>
        </trans-unit>
        <trans-unit id="403d69677374c07e6c15d9b1403b168e3385a4f8" translate="yes" xml:space="preserve">
          <source>In order to prevent scenarios like this we've implemented support for migration of multi-block carriers between allocator instances.</source>
          <target state="translated">このようなシナリオを防ぐために、アロケータインスタンス間でのマルチブロックキャリアの移行をサポートしています。</target>
        </trans-unit>
        <trans-unit id="07f515d2f2923cfaf0efd016e9309bd6ce7894d3" translate="yes" xml:space="preserve">
          <source>In order to provide a solution for scalable implementations of MG's and MGC's, a user may be distributed over several Erlang nodes. One of the Erlang nodes is connected to the physical network interface, but messages may be sent from other nodes and the replies are automatically forwarded back to the originating node.</source>
          <target state="translated">MGとMGCのスケーラブルな実装のためのソリューションを提供するために、ユーザは複数のErlangノードに分散されているかもしれません。Erlangノードの1つは物理ネットワークインターフェースに接続されていますが、他のノードからメッセージが送信され、返信は自動的に送信元のノードに転送されます。</target>
        </trans-unit>
        <trans-unit id="9b7d500551c4dcb114f3424b88510f43e715d2cf" translate="yes" xml:space="preserve">
          <source>In order to reduce contention due to locking of allocator instances we introduced completely lock free instances tied to each scheduler thread, and an extra locked instance for other threads. The scheduler threads in the system is expected to do the major part of the work. Other threads may still be needed but should not perform any major and/or time critical work. The limited amount of contention that appears on the locked allocator instance can more or less be disregarded.</source>
          <target state="translated">アロケータインスタンスのロックによる競合を減らすために、各スケジューラスレッドに紐づけられた完全にロックされていないインスタンスと、それ以外のスレッドには余分なロックされたインスタンスを導入しました。システム内のスケジューラースレッドは仕事の大部分を行うことが期待されています。他のスレッドはまだ必要とされるかもしれませんが、主要な作業や時間的に重要な作業を行うべきではありません。ロックされたアロケータインスタンス上に現れる限られた量の競合は、多かれ少なかれ無視することができます。</target>
        </trans-unit>
        <trans-unit id="f092b8785b0c724e3673cc03096bbd3fea047bff" translate="yes" xml:space="preserve">
          <source>In order to retrieve keylog information on a TLS 1.3 connection, it must be configured in advance to keep the client_random and various handshake secrets.</source>
          <target state="translated">TLS 1.3 接続のキーログ情報を取得するためには、 client_random と様々なハンドシェイクの秘密を保持するように事前に設定しておく必要があります。</target>
        </trans-unit>
        <trans-unit id="9731fa13e74c2eca121fa5f3f64dcc4b8aa04753" translate="yes" xml:space="preserve">
          <source>In order to see the nitty gritty details of an &lt;code&gt;Event&lt;/code&gt; you may click on the &lt;code&gt;Event&lt;/code&gt; in order to start a &lt;code&gt;Contents Viewer&lt;/code&gt; for that &lt;code&gt;Event&lt;/code&gt;. In the &lt;code&gt;Contents Viewer&lt;/code&gt; there also is a filter menu that enables inspection of the &lt;code&gt;Event&lt;/code&gt; from other views than the one selected in the viewer. A click on the &lt;code&gt;new_tid&lt;/code&gt;&lt;code&gt;Event&lt;/code&gt; will cause a &lt;code&gt;Contents Viewer&lt;/code&gt; window to pop up, showing the &lt;code&gt;Event&lt;/code&gt; in the &lt;code&gt;mgr_actors&lt;/code&gt; view:</source>
          <target state="translated">核心の詳細を参照するために &lt;code&gt;Event&lt;/code&gt; あなたはをクリックして &lt;code&gt;Event&lt;/code&gt; 開始するために &lt;code&gt;Contents Viewer&lt;/code&gt; そのための &lt;code&gt;Event&lt;/code&gt; 。では &lt;code&gt;Contents Viewer&lt;/code&gt; そこも検査可能フィルタ]メニューで &lt;code&gt;Event&lt;/code&gt; ビューアで選択されたもの以外のビューから。 &lt;code&gt;new_tid&lt;/code&gt; &lt;code&gt;Event&lt;/code&gt; をクリックすると、 &lt;code&gt;Contents Viewer&lt;/code&gt; ウィンドウがポップアップし、 &lt;code&gt;mgr_actors&lt;/code&gt; ビューに &lt;code&gt;Event&lt;/code&gt; が表示されます。</target>
        </trans-unit>
        <trans-unit id="dbccfc8cfa22ee2e381053c5b4b92eaa192ba4f4" translate="yes" xml:space="preserve">
          <source>In order to set a different socket path the &lt;code id=&quot;SOCKET_PATH&quot;&gt;socket_path&lt;/code&gt; option can be set.</source>
          <target state="translated">別のソケットパスを設定するために、 &lt;code id=&quot;SOCKET_PATH&quot;&gt;socket_path&lt;/code&gt; オプションを設定できます。</target>
        </trans-unit>
        <trans-unit id="92ff9cab23ed1e1a7df0e6479aae0e38297e97c3" translate="yes" xml:space="preserve">
          <source>In order to solve this, we introduced a new busy feature, namely &quot;busy port queue&quot;. The port has a limit of &lt;code&gt;command&lt;/code&gt; data that is allowed to be enqueued in the task queue. When this limit is reached, the port will automatically enter a busy port queue state. When in this state, senders of &lt;code&gt;command&lt;/code&gt; signals will be suspended, but &lt;code&gt;command&lt;/code&gt; signals will still be delivered to the port unless it is also in a busy port state. This limit is known as the high limit.</source>
          <target state="translated">これを解決するために、新しいビジー機能、つまり「ビジーポートキュー」を導入しました。ポートには、タスクキューにエンキューできる &lt;code&gt;command&lt;/code&gt; データの制限があります。この制限に達すると、ポートは自動的にビジーポートキュー状態になります。この状態の場合、 &lt;code&gt;command&lt;/code&gt; 信号の送信者は一時停止されますが、ポートがビジー状態でない限り、 &lt;code&gt;command&lt;/code&gt; 信号は引き続きポートに配信されます。この制限は上限と呼ばれます。</target>
        </trans-unit>
        <trans-unit id="c0e67fa06e1bd38aa13f81fc5e8041b9e05f7af4" translate="yes" xml:space="preserve">
          <source>In order to test modifications of the process table we ran a couple of benchmarks where lots of processes are spawned and terminated simultaneously, and got a speedup of between 150-200%. Running a similar benchmark but with ports we got a speedup of about 130%.</source>
          <target state="translated">プロセステーブルの変更をテストするために、多くのプロセスを同時に起動して終了させるベンチマークをいくつか実行したところ、150~200%の速度向上が見られました。同様のベンチマークを実行すると、ポートを使用して約130%のスピードアップが得られました。</target>
        </trans-unit>
        <trans-unit id="89bee7955a9d3e10a16eb24de0ff7542bf8f388b" translate="yes" xml:space="preserve">
          <source>In order to use the Tags system a file named &lt;code&gt;TAGS&lt;/code&gt; must be created. The file can be seen as a database over all functions, records, and macros in all files in the project. The &lt;code&gt;TAGS&lt;/code&gt; file can be created using two different methods for Erlang. The first is the standard Emacs utility &quot;etags&quot;, the second is by using the Erlang module &lt;code&gt;tags&lt;/code&gt;.</source>
          <target state="translated">タグシステムを使用するには、 &lt;code&gt;TAGS&lt;/code&gt; という名前のファイルを作成する必要があります。ファイルは、プロジェクト内のすべてのファイルのすべての関数、レコード、およびマクロのデータベースとして見ることができます。 &lt;code&gt;TAGS&lt;/code&gt; のファイルには、Erlangのための2つの異なる方法を使用して作成することができます。1つ目は標準のEmacsユーティリティ「etags」で、2つ目はErlangモジュール &lt;code&gt;tags&lt;/code&gt; を使用する方法です。</target>
        </trans-unit>
        <trans-unit id="87d5585c6ba89972afd1216748dd8d8d098d28d5" translate="yes" xml:space="preserve">
          <source>In our measurements we have seen that there are no significant differences in message sizes between ASN.1 BER and the compact text format. Some care should be taken when using the pretty text style (which is used in all the examples included in the protocol specification and preferred during debugging sessions) since the messages can then be quite large. If the message size really is a serious issue, our per encoder should be used, as the ASN.1 PER format is much more compact than all the other alternatives. Its major drawback is that it is has not been approved as a valid Megaco/H.248 message encoding.</source>
          <target state="translated">我々の測定では、ASN.1 BERとコンパクトテキスト形式の間でメッセージサイズに有意な差はないことがわかりました。メッセージが非常に大きくなる可能性があるので、きれいなテキストスタイル(プロトコル仕様に含まれるすべての例で使用されており、デバッグセッションで好まれています)を使用する際には、いくつかの注意を払う必要があります。メッセージサイズが本当に深刻な問題であれば、ASN.1 PER フォーマットは他のすべての選択肢よりもはるかにコンパクトなので、エンコーダごとのフォーマットを使用するべきです。最大の欠点は、有効な Megaco/H.248 メッセージ・エンコーディングとして承認されていないことです。</target>
        </trans-unit>
        <trans-unit id="65532138e2b3ba308191e4f5508353fb9debf75b" translate="yes" xml:space="preserve">
          <source>In practice, object sets are usually declared to be extensible so that more objects can be added to the set later. Extensibility is indicated as follows:</source>
          <target state="translated">実際には、オブジェクトセットは通常、拡張可能であると宣言されているので、後からより多くのオブジェクトをセットに追加することができます。拡張性は以下のように示されます。</target>
        </trans-unit>
        <trans-unit id="ce95e8a49f6cc63c7488544f7b729b9f298807b1" translate="yes" xml:space="preserve">
          <source>In previous versions of &lt;code&gt;file&lt;/code&gt;, modes were specified as one of the atoms &lt;code&gt;read&lt;/code&gt;, &lt;code&gt;write&lt;/code&gt;, or &lt;code&gt;read_write&lt;/code&gt; instead of a list. This is still allowed for reasons of backwards compatibility, but is not to be used for new code. Also note that &lt;code&gt;read_write&lt;/code&gt; is not allowed in a mode list.</source>
          <target state="translated">以前のバージョンの &lt;code&gt;file&lt;/code&gt; では、モードはリストではなく、アトム &lt;code&gt;read&lt;/code&gt; 、 &lt;code&gt;write&lt;/code&gt; 、または &lt;code&gt;read_write&lt;/code&gt; の 1つとして指定されていました。これは、下位互換性の理由で引き続き許可されていますが、新しいコードには使用できません。また、 &lt;code&gt;read_write&lt;/code&gt; はモードリストでは使用できないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="f79c7cf33fb3cea437947f151dd1585b263646aa" translate="yes" xml:space="preserve">
          <source>In principle, this function calls the &lt;code&gt;process_received_message/4&lt;/code&gt; function via a &lt;code&gt;spawn&lt;/code&gt; to perform the actual processing.</source>
          <target state="translated">原則として、この関数は &lt;code&gt;spawn&lt;/code&gt; を介して &lt;code&gt;process_received_message/4&lt;/code&gt; 関数を呼び出し、実際の処理を実行します。</target>
        </trans-unit>
        <trans-unit id="c1b13e4d52a1141022b35db2e3080247aecc4f96" translate="yes" xml:space="preserve">
          <source>In protocols that support client-initiated renegotiation, the cost of resources of such an operation is higher for the server than the client. This can act as a vector for denial of service attacks. The SSL application already takes measures to counter-act such attempts, but client-initiated renegotiation can be strictly disabled by setting this option to &lt;code&gt;false&lt;/code&gt;. The default value is &lt;code&gt;true&lt;/code&gt;. Note that disabling renegotiation can result in long-lived connections becoming unusable due to limits on the number of messages the underlying cipher suite can encipher.</source>
          <target state="translated">クライアントが開始する再ネゴシエーションをサポートするプロトコルでは、そのような操作のリソースのコストはクライアントよりサーバーの方が高くなります。これは、サービス拒否攻撃のベクターとして機能する可能性があります。SSLアプリケーションはそのような試みに対抗するための対策をすでに講じていますが、このオプションを &lt;code&gt;false&lt;/code&gt; に設定することにより、クライアントが開始した再ネゴシエーションを厳密に無効にすることができます。デフォルト値は &lt;code&gt;true&lt;/code&gt; です。再ネゴシエーションを無効にすると、基盤となる暗号スイートが暗号化できるメッセージの数が制限されるため、長期間の接続が使用できなくなる可能性があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="6c5be2b3b8e809c554958bbec452d00bc9526f02" translate="yes" xml:space="preserve">
          <source>In rare circumstances, this function can fail on Unix. It can occur if read permission does not exist for the parent directories of the current directory.</source>
          <target state="translated">まれな状況では、この関数はUnix上で失敗することがあります。これは、カレントディレクトリの親ディレクトリの読み込み権限が存在しない場合に発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="03d64f33ab45a7b9facd9b7d6fdfa4c86a07dd26" translate="yes" xml:space="preserve">
          <source>In reality, data models are seldom fully normalized. A realistic alternative to a normalized database model would be a data model that is not even in first normal form. &lt;code&gt;Mnesia&lt;/code&gt; is suitable for applications such as telecommunications, because it is easy to organize data in a flexible manner. A &lt;code&gt;Mnesia&lt;/code&gt; database is always organized as a set of tables. Each table is filled with rows, objects, and records. What sets &lt;code&gt;Mnesia&lt;/code&gt; apart is that individual fields in a record can contain any type of compound data structures. An individual field in a record can contain lists, tuples, functions, and even record code.</source>
          <target state="translated">実際には、データモデルが完全に正規化されることはほとんどありません。正規化されたデータベースモデルの現実的な代替案は、第1正規形でさえないデータモデルです。 &lt;code&gt;Mnesia&lt;/code&gt; は、柔軟な方法でデータを整理することが容易であるため、テレコミュニケーションなどのアプリケーションに適しています。 &lt;code&gt;Mnesia&lt;/code&gt; のデータベースは常にテーブルのセットとして編成されています。各テーブルは、行、オブジェクト、およびレコードで埋められます。どのような設定 &lt;code&gt;Mnesia&lt;/code&gt; を離れては、レコードの個々のフィールドは、化合物のデータ構造のいずれかのタイプを含めることができるということです。レコードの個々のフィールドには、リスト、タプル、関数、さらにはレコードコードを含めることができます。</target>
        </trans-unit>
        <trans-unit id="6b66f371cbc8ed94f2c343e8c1182f27560a8689" translate="yes" xml:space="preserve">
          <source>In scenario 1, the test case process terminates normally after &lt;code&gt;case A&lt;/code&gt; has finished executing its test code without detecting any errors. The test case function returns a value and &lt;code&gt;Common Test&lt;/code&gt; logs the test case as successful.</source>
          <target state="translated">シナリオ1では、 &lt;code&gt;case A&lt;/code&gt; がエラーを検出せずにテストコードの実行を終了すると、テストケースプロセスは正常に終了します。テストケース関数は値を返し、 &lt;code&gt;Common Test&lt;/code&gt; はテストケースを成功としてログに記録します。</target>
        </trans-unit>
        <trans-unit id="9c8810dc35fa4f97c050123bbb12b1701dd4c349" translate="yes" xml:space="preserve">
          <source>In scenario 2, an error is detected during test &lt;code&gt;case B&lt;/code&gt; execution. This causes the test &lt;code&gt;case B&lt;/code&gt; function to generate an exception and, as a result, the test case process exits with reason other than normal. &lt;code&gt;Common Test&lt;/code&gt; logs this as an unsuccessful (Failed) test case.</source>
          <target state="translated">シナリオ2では、テスト &lt;code&gt;case B&lt;/code&gt; 実行中にエラーが検出されます。これにより、テスト &lt;code&gt;case B&lt;/code&gt; 関数が例外を生成し、その結果、テストケースプロセスが通常以外の理由で終了します。 &lt;code&gt;Common Test&lt;/code&gt; は、これを失敗した（失敗した）テストケースとして記録します。</target>
        </trans-unit>
        <trans-unit id="2b01a41bac5f590a4587dab197accc292b0c3e3d" translate="yes" xml:space="preserve">
          <source>In section about myths, the following myth was exposed: &lt;code&gt;&lt;a href=&quot;myths#tail_recursive&quot;&gt;Tail-Recursive Functions are Much Faster Than Recursive Functions&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">神話に関するセクションでは、次の神話が公開されました。 &lt;code&gt;&lt;a href=&quot;myths#tail_recursive&quot;&gt;Tail-Recursive Functions are Much Faster Than Recursive Functions&lt;/a&gt;&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="b130fa00d240c9e2022bf6895671a7967856f662" translate="yes" xml:space="preserve">
          <source>In short, the &lt;code&gt;DebugType&lt;/code&gt; is intended for debugging only. Logs during production are better produced with the standard Erlang logging facilities.</source>
          <target state="translated">つまり、 &lt;code&gt;DebugType&lt;/code&gt; はデバッグのみを目的としています。生産中のログは、標準のErlangロギング機能でより適切に作成されます。</target>
        </trans-unit>
        <trans-unit id="fa32d137f104b735ab84633f3591ddf26cbba0ca" translate="yes" xml:space="preserve">
          <source>In short:</source>
          <target state="translated">要するに</target>
        </trans-unit>
        <trans-unit id="71afdcc8f1caaa6350eb14b1d2094d34265774c1" translate="yes" xml:space="preserve">
          <source>In some applications, it can be unacceptable that replies from individual logs are ignored. An alternative in such situations is to use many local disk logs instead of one distributed disk log, and implement the distribution without use of the &lt;code&gt;disk_log&lt;/code&gt; module.</source>
          <target state="translated">一部のアプリケーションでは、個々のログからの応答が無視されることは許容できない場合があります。そのような状況での代替策は、1つの分散ディスクログの代わりに多くのローカルディスクログを使用し、 &lt;code&gt;disk_log&lt;/code&gt; モジュールを使用せずに配布を実装することです。</target>
        </trans-unit>
        <trans-unit id="3864ea2cdbd0987d0b4fb5eb5813e04593cf37fa" translate="yes" xml:space="preserve">
          <source>In some aspects the Erlang MIB compiler does not follow or implement the SMI fully. Here are the differences:</source>
          <target state="translated">Erlang MIBコンパイラはSMIを完全には実装していません。ここに違いがあります。</target>
        </trans-unit>
        <trans-unit id="c9e14d58e80ba98377364e8269565a9b4e7f56ca" translate="yes" xml:space="preserve">
          <source>In some aspects the agent does not implement SNMP fully. Here are the differences:</source>
          <target state="translated">エージェントがSNMPを完全に実装していない面もあります。ここに違いがあります。</target>
        </trans-unit>
        <trans-unit id="397a384c819c2af0e32f82dcacb93ab35d42b161" translate="yes" xml:space="preserve">
          <source>In some cases, the Erlang syntax rules make it impossible to place a metavariable directly where you would like it. For example, you cannot write:</source>
          <target state="translated">いくつかのケースでは、Erlangの構文ルールによってメタ変数を直接好きな場所に置くことができないことがあります。例えば、以下のように書くことはできません。</target>
        </trans-unit>
        <trans-unit id="c076f1de5baca283848280a649a2179b83e38d01" translate="yes" xml:space="preserve">
          <source>In some circumstances, the select/match operations do not need to scan the complete table. For example, if part of the key is bound when searching an &lt;code&gt;ordered_set&lt;/code&gt; table, or if it is a Mnesia table and there is a secondary index on the field that is selected/matched. If the key is fully bound, there is no point in doing a select/match, unless you have a bag table and are only interested in a subset of the elements with the specific key.</source>
          <target state="translated">状況によっては、選択/一致操作でテーブル全体をスキャンする必要はありません。たとえば、 &lt;code&gt;ordered_set&lt;/code&gt; テーブルの検索時にキーの一部がバインドされている場合、またはMnesiaテーブルであり、選択または一致するフィールドにセカンダリインデックスがある場合などです。キーが完全にバインドされている場合、バッグテーブルがあり、特定のキーを持つ要素のサブセットのみに関心がある場合を除いて、選択/一致を実行しても意味がありません。</target>
        </trans-unit>
        <trans-unit id="f29229d853517e42e24b621374f22a9695122f0f" translate="yes" xml:space="preserve">
          <source>In some contexts, only a string or an integer is allowed. For example, the directive &lt;code&gt;-file(Name, Line)&lt;/code&gt; requires that &lt;code&gt;Name&lt;/code&gt; is a string literal and &lt;code&gt;Line&lt;/code&gt; an integer literal:</source>
          <target state="translated">一部のコンテキストでは、文字列または整数のみが許可されています。たとえば、ディレクティブ &lt;code&gt;-file(Name, Line)&lt;/code&gt; では、 &lt;code&gt;Name&lt;/code&gt; が文字列リテラルで、 &lt;code&gt;Line&lt;/code&gt; が整数リテラルである必要があります。</target>
        </trans-unit>
        <trans-unit id="5a6b075e8a7cbcdea6adcceaf8693e0b814b7a53" translate="yes" xml:space="preserve">
          <source>In state &lt;code&gt;locked&lt;/code&gt;, when a button is pressed, it is collected with the last pressed buttons up to the length of the correct code, and compared with the correct code. Depending on the result, the door is either unlocked and the &lt;code&gt;gen_statem&lt;/code&gt; goes to state &lt;code&gt;open&lt;/code&gt;, or the door remains in state &lt;code&gt;locked&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;locked&lt;/code&gt; 状態では、ボタンが押されると、最後に押されたボタンが正しいコードの長さまで収集され、正しいコードと比較されます。結果に応じて、ドアのロックが解除され、 &lt;code&gt;gen_statem&lt;/code&gt; が &lt;code&gt;open&lt;/code&gt; た状態になるか、ドアが &lt;code&gt;locked&lt;/code&gt; れた状態のままになります。</target>
        </trans-unit>
        <trans-unit id="d9b6767bf0caff1be872c1139fc4118f63dc8ef9" translate="yes" xml:space="preserve">
          <source>In state &lt;code&gt;open&lt;/code&gt;, a button event is ignored by staying in the same state. This can also be done by returning &lt;code&gt;{keep_state, Data}&lt;/code&gt; or in this case since &lt;code&gt;Data&lt;/code&gt; unchanged even by returning &lt;code&gt;keep_state_and_data&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;open&lt;/code&gt; 状態では、ボタンイベントは同じ状態に留まることで無視されます。これは &lt;code&gt;{keep_state, Data}&lt;/code&gt; 返すことによっても行うことができます。この場合、 &lt;code&gt;keep_state_and_data&lt;/code&gt; を返しても &lt;code&gt;Data&lt;/code&gt; は変更されないためです。</target>
        </trans-unit>
        <trans-unit id="96ad0dfc8fa4580e2165853ef7429bd0d01832d6" translate="yes" xml:space="preserve">
          <source>In systems which create and delete &lt;strong&gt;many&lt;/strong&gt; sockets dynamically, it (the socket registry) could become a bottleneck. For such systems, there are a couple of ways to control the use of the socket registry.</source>
          <target state="translated">&lt;strong&gt;多くの&lt;/strong&gt;ソケットを動的に作成および削除するシステムでは、それ（ソケットレジストリ）がボトルネックになる可能性があります。このようなシステムの場合、ソケットレジストリの使用を制御する方法がいくつかあります。</target>
        </trans-unit>
        <trans-unit id="1bdfbdd981c77f7212c651d17f2cefab1fd90c79" translate="yes" xml:space="preserve">
          <source>In systems with many processes, computation tasks that run for a short time can be spawned off into a new process with a higher minimum heap size. When the process is done, it sends the result of the computation to another process and terminates. If the minimum heap size is calculated properly, the process might not have to do any garbage collections at all. &lt;strong&gt;This optimization is not to be attempted without proper measurements.&lt;/strong&gt;</source>
          <target state="translated">多くのプロセスがあるシステムでは、短時間実行される計算タスクは、最小ヒープサイズが大きい新しいプロセスに生成されます。プロセスが完了すると、計算結果を別のプロセスに送信して終了します。最小ヒープサイズが適切に計算されている場合、プロセスはガベージコレクションをまったく行う必要がない場合があります。&lt;strong&gt;この最適化は、適切な測定なしに行われるべきではありません。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5746b70053e6262729b091cf67ef85a9f8ac776b" translate="yes" xml:space="preserve">
          <source>In telecommunications applications, there are different needs from the features provided by traditional DBMSs. The applications now implemented in Erlang need a mixture of a broad range of features, which generally are not satisfied by traditional DBMSs. Mnesia is designed with requirements like the following in mind:</source>
          <target state="translated">通信アプリケーションでは、従来のDBMSが提供する機能とは異なるニーズがあります。現在Erlangで実装されているアプリケーションは、一般的に従来のDBMSでは満たされていない幅広い機能を必要としています。Mnesiaは以下のような要件を念頭に置いて設計されています。</target>
        </trans-unit>
        <trans-unit id="63011c7dfba9e10fc95124eaa2d33e3e8a0fca83" translate="yes" xml:space="preserve">
          <source>In the 32-bit implementation of Erlang, 536,870,911 bytes is the largest binary that can be constructed or matched using the bit syntax. In the 64-bit implementation, the maximum size is 2,305,843,009,213,693,951 bytes. If the limit is exceeded, bit syntax construction fails with a &lt;code&gt;system_limit&lt;/code&gt; exception, while any attempt to match a binary that is too large fails. This limit is enforced starting in R11B-4.</source>
          <target state="translated">Erlangの32ビット実装では、536,870,911バイトが、ビット構文を使用して構築または照合できる最大のバイナリです。64ビット実装では、最大サイズは2,305,843,009,213,693,951バイトです。制限を超えた場合、ビット構文の構築は &lt;code&gt;system_limit&lt;/code&gt; 例外で失敗しますが、大きすぎるバイナリを照合しようとすると失敗します。この制限はR11B-4から適用されます。</target>
        </trans-unit>
        <trans-unit id="3b10f4238d4a411f4fac664bc42d174316e288c7" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;MatchBody&lt;/code&gt; and &lt;code&gt;MatchCondition&lt;/code&gt; parts, only variables bound previously can be used.</source>
          <target state="translated">で &lt;code&gt;MatchBody&lt;/code&gt; と &lt;code&gt;MatchCondition&lt;/code&gt; 部品、以前にバインド変数のみを使用することができます。</target>
        </trans-unit>
        <trans-unit id="99f811cb87197b615b54046fe0178bf192579602" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;MatchCondition/MatchBody&lt;/code&gt; parts, no unbound variables are allowed, so &lt;code&gt;'_'&lt;/code&gt; is interpreted as itself (an atom). Variables can only be bound in the &lt;code&gt;MatchHead&lt;/code&gt; part.</source>
          <target state="translated">&lt;code&gt;MatchCondition/MatchBody&lt;/code&gt; の部品、全く結合していない変数がので、許可されない &lt;code&gt;'_'&lt;/code&gt; 自体（原子）として解釈されます。変数は、 &lt;code&gt;MatchHead&lt;/code&gt; パーツでのみバインドできます。</target>
        </trans-unit>
        <trans-unit id="41acf373b0923e27303ed2d9e613e3b6bc78210e" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;MatchCondition/MatchBody&lt;/code&gt; parts, the interpretation is in some ways different. Literals in these parts can either be written &quot;as is&quot;, which works for all literals except tuples, or by using the special form &lt;code&gt;{const, T}&lt;/code&gt;, where &lt;code&gt;T&lt;/code&gt; is any Erlang term.</source>
          <target state="translated">で &lt;code&gt;MatchCondition/MatchBody&lt;/code&gt; の部品、解釈はいくつかの点で異なっています。タプルを除くすべてのリテラルのために働く、これらの部品にリテラル「そのまま」のいずれかで記述することができ、または特別な形用いて &lt;code&gt;{const, T}&lt;/code&gt; 、 &lt;code&gt;T&lt;/code&gt; は任意Erlangの用語であるが。</target>
        </trans-unit>
        <trans-unit id="eb2046d2d5da3268f8e80e9b5760d8733ac6af46" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;MatchHead&lt;/code&gt; part, all literals (except the variables above) are interpreted &quot;as is&quot;.</source>
          <target state="translated">で &lt;code&gt;MatchHead&lt;/code&gt; の「そのまま」の部分（上記の変数を除く）すべてのリテラルは、解釈されます。</target>
        </trans-unit>
        <trans-unit id="62822ca5758004378978f550b70109b8f746b1ba" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;compiler&lt;/code&gt; application, in the file &lt;code&gt;genop.tab&lt;/code&gt;, there is the following line:</source>
          <target state="translated">では &lt;code&gt;compiler&lt;/code&gt; アプリケーション、ファイルに &lt;code&gt;genop.tab&lt;/code&gt; 、次の行があります：</target>
        </trans-unit>
        <trans-unit id="ed8257c1305383c9e32994b91f6e1b51ce6d911e" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;do_perm&lt;/code&gt; we do the work, operating on the structure that was allocated in &lt;code&gt;output&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;do_perm&lt;/code&gt; では、 &lt;code&gt;output&lt;/code&gt; に割り当てられた構造を操作して作業を行います。</target>
        </trans-unit>
        <trans-unit id="6e01e7a071ebc59bede92c3c9744f0cd30d2569a" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;ets:fun2ms/1&lt;/code&gt; example above, it is needed to include &lt;code&gt;ms_transform.hrl&lt;/code&gt; in the source code, as this is what triggers the parse transformation of the &lt;code&gt;ets:fun2ms/1&lt;/code&gt; call to a valid match specification. This also implies that the transformation is done at compile time (except when called from the shell) and therefore takes no resources in runtime. That is, although you use the more intuitive fun syntax, it gets as efficient in runtime as writing match specifications by hand.</source>
          <target state="translated">上記の &lt;code&gt;ets:fun2ms/1&lt;/code&gt; の例では、有効な一致指定への &lt;code&gt;ets:fun2ms/1&lt;/code&gt; 呼び出しの解析変換をトリガーするものであるため、ソースコードに &lt;code&gt;ms_transform.hrl&lt;/code&gt; を含める必要があります。これは、変換がコンパイル時に行われ（シェルから呼び出された場合を除く）、実行時にリソースを消費しないことも意味します。つまり、より直感的な楽しい構文を使用しますが、ランタイムでマッチ仕様を手動で作成するのと同じくらい効率的になります。</target>
        </trans-unit>
        <trans-unit id="11d9a975fdf9d1a5bae2119da6072d890e6e6ea9" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;main&lt;/code&gt; function, the C program is to listen for a message from Erlang and, according to the selected encoding/decoding scheme, use the first byte to determine which function to call and the second byte as argument to the function. The result of calling the function is then to be sent back to Erlang:</source>
          <target state="translated">&lt;code&gt;main&lt;/code&gt; 関数、Cプログラムはアーランからのメッセージをリッスンし、選択された符号化/復号化スキームによれば、関数の引数として呼び出すために機能するかを決定するための最初のバイトと第二のバイトを使用することです。次に、関数を呼び出した結果がErlangに送り返されます。</target>
        </trans-unit>
        <trans-unit id="a69877ecee07d6d60ef5a7f12b95eb172cfc8ddd" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;option&lt;/code&gt; info tuple are only the options included that differs from the default values.</source>
          <target state="translated">で &lt;code&gt;option&lt;/code&gt; 情報タプルのみのオプションは、デフォルト値からその異なって含まれています。</target>
        </trans-unit>
        <trans-unit id="925920f982694555a077da19c74dabd56f931884" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;ready_async&lt;/code&gt; function the output is sent back to the emulator. We use the driver term format instead of &lt;code&gt;ei&lt;/code&gt;. This is the only way to send Erlang terms directly to a driver, without having the Erlang code to call &lt;code&gt;binary_to_term/1&lt;/code&gt;. In the simple example this works well, and we do not need to use &lt;code&gt;ei&lt;/code&gt; to handle the binary term format.</source>
          <target state="translated">で &lt;code&gt;ready_async&lt;/code&gt; 機能出力は、エミュレータに送り返されます。 &lt;code&gt;ei&lt;/code&gt; の代わりにドライバー用語形式を使用します。これは、Erlangコードが &lt;code&gt;binary_to_term/1&lt;/code&gt; を呼び出すことなく、Erlang用語をドライバーに直接送信する唯一の方法です。簡単な例ではこれはうまく機能し、バイナリ用語形式を処理するために &lt;code&gt;ei&lt;/code&gt; を使用する必要はありません。</target>
        </trans-unit>
        <trans-unit id="262d5d76fc96e92282d6cd6556cb095d00a57bcd" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;ssh.app&lt;/code&gt; file, in the &lt;code&gt;env&lt;/code&gt; part</source>
          <target state="translated">では &lt;code&gt;ssh.app&lt;/code&gt; のファイル、内 &lt;code&gt;env&lt;/code&gt; 一部</target>
        </trans-unit>
        <trans-unit id="b368b60ecb50d01986bb37bad72bc40dc4e4d86a" translate="yes" xml:space="preserve">
          <source>In the API of Megaco, a user may explicitly send action requests, but generation of transaction identifiers, the encoding and actual transport of the message to the remote user is handled automatically by the protocol engine according to the actual connection configuration. Megaco messages are not exposed in the API.</source>
          <target state="translated">MegacoのAPIでは、ユーザが明示的にアクションリクエストを送信することができますが、トランザクション識別子の生成やエンコード、リモートユーザへのメッセージの転送は、実際の接続設定に応じてプロトコルエンジンが自動的に処理します。なお、MegacoのメッセージはAPIでは公開されていません。</target>
        </trans-unit>
        <trans-unit id="298b6692a18a71c353c5cf532d8e68a0d659e314" translate="yes" xml:space="preserve">
          <source>In the Erlang Run-time System entities are only run in parallel when there are multiple schedulers. Therefore &lt;code&gt;lcnt&lt;/code&gt; will show more contention points (and thus be more useful) on systems using many schedulers on many cores.</source>
          <target state="translated">Erlangランタイムシステムのエンティティは、複数のスケジューラがある場合にのみ並列で実行されます。したがって、 &lt;code&gt;lcnt&lt;/code&gt; は、多くのコアで多くのスケジューラーを使用するシステムで、より多くの競合ポイントを表示します（したがってより有用です）。</target>
        </trans-unit>
        <trans-unit id="23d80f2c0541f925401a28d1d9dadf53dc345fcf" translate="yes" xml:space="preserve">
          <source>In the Kernel application:</source>
          <target state="translated">カーネルアプリケーションでは</target>
        </trans-unit>
        <trans-unit id="b82356bcf2624a74da6a8c951ecd46a6c4f7a6d9" translate="yes" xml:space="preserve">
          <source>In the Mnesia tables, the two key columns are stored as a tuple with two elements. Therefore, the arity of the table is 3.</source>
          <target state="translated">ムネシアのテーブルでは、2つのキーカラムは2つの要素を持つタプルとして格納されています。したがって、テーブルのアリティは3となります。</target>
        </trans-unit>
        <trans-unit id="ebfbe0fc7007783959fb235364ad702572537213" translate="yes" xml:space="preserve">
          <source>In the POSIX.2 compliant library that was included in 4.4BSD Unix, the ugly syntax [[:&amp;lt;:]] and [[:&amp;gt;:]] is used for matching &quot;start of word&quot; and &quot;end of word&quot;. PCRE treats these items as follows:</source>
          <target state="translated">4.4BSD Unixに含まれていたPOSIX.2準拠のライブラリでは、醜い構文[[：&amp;lt;：]]と[[：&amp;gt;：]]が「単語の始まり」と「単語の終わり」のマッチングに使用されます。PCREはこれらの項目を次のように扱います。</target>
        </trans-unit>
        <trans-unit id="989093a9ff881dd98b2952b19cfa00d3c661d058" translate="yes" xml:space="preserve">
          <source>In the PRF (pseud-random function) to generate keying materials in cipher suites not using PFS.</source>
          <target state="translated">PFSを使用していない暗号スイートの鍵材料を生成するためのPRF(疑似ランダム関数)において</target>
        </trans-unit>
        <trans-unit id="a4c5b7bf87ece22cd2bc2e60bd8ae9d3bd13b0c4" translate="yes" xml:space="preserve">
          <source>In the SSL application, an extra distribution module, &lt;code&gt;inet_tls_dist&lt;/code&gt;, can be used as an alternative. All distribution connections will use TLS and all participating Erlang nodes in a distributed system must use this distribution module.</source>
          <target state="translated">SSLアプリケーションでは、追加の配布モジュール &lt;code&gt;inet_tls_dist&lt;/code&gt; を代替として使用できます。すべての配布接続はTLSを使用し、分散システムに参加するすべてのErlangノードはこの配布モジュールを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="84201f881a1979b920fa1a6166421647fdc90516" translate="yes" xml:space="preserve">
          <source>In the STDLIB application:</source>
          <target state="translated">STDLIBアプリケーションでは</target>
        </trans-unit>
        <trans-unit id="52bac5408693eade80ce363b1a7a4df7f8aaf59f" translate="yes" xml:space="preserve">
          <source>In the above example, &quot;pong&quot; was first created to be able to give the identity of &quot;pong&quot; when &quot;ping&quot; was started. That is, in some way &quot;ping&quot; must be able to know the identity of &quot;pong&quot; to be able to send a message to it. Sometimes processes which need to know each other's identities are started independently of each other. Erlang thus provides a mechanism for processes to be given names so that these names can be used as identities instead of pids. This is done by using the &lt;code&gt;register&lt;/code&gt; BIF:</source>
          <target state="translated">上記の例では、「ping」が開始されたときに「pong」のアイデンティティを提供できるように「pong」が最初に作成されました。つまり、何らかの方法で &quot;ping&quot;は、メッセージを送信できるようにするために &quot;pong&quot;の身元を知っている必要があります。互いのアイデンティティを知る必要があるプロセスは、互いに独立して開始される場合があります。したがって、Erlangはプロセスに名前を付けるためのメカニズムを提供し、これらの名前をPIDの代わりにIDとして使用できるようにします。これは、 &lt;code&gt;register&lt;/code&gt; BIF を使用して行われます。</target>
        </trans-unit>
        <trans-unit id="e32e6dd34c52e0e8f5c4ffcf8e60b4a055b8ae5e" translate="yes" xml:space="preserve">
          <source>In the above example, the small binary &lt;code&gt;B&lt;/code&gt; was copied while the larger binary &lt;code&gt;C&lt;/code&gt; references binary &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">上記の例では、小さいバイナリ &lt;code&gt;B&lt;/code&gt; がコピーされ、大きいバイナリ &lt;code&gt;C&lt;/code&gt; がバイナリ &lt;code&gt;A&lt;/code&gt; を参照しています。</target>
        </trans-unit>
        <trans-unit id="dd30adfebd9b33e07add4e9cc9b71db937dd48cf" translate="yes" xml:space="preserve">
          <source>In the absence of spawn operation failures, atomically sets up a monitor to the newly created process. That is, as if the calling process had called &lt;code&gt;&lt;a href=&quot;#monitor-2&quot;&gt;monitor(process, Pid)&lt;/a&gt;&lt;/code&gt; where &lt;code&gt;Pid&lt;/code&gt; is the process identifier of the newly created process. The &lt;code&gt;ReqId&lt;/code&gt; returned by &lt;code&gt;spawn_request()&lt;/code&gt; is also used as monitor reference as if it was returned from &lt;code&gt;monitor(process, Pid)&lt;/code&gt;.</source>
          <target state="translated">スポーン操作の失敗がない場合、新しく作成されたプロセスにモニターをアトミックにセットアップします。つまり、呼び出し元のプロセスが &lt;code&gt;&lt;a href=&quot;#monitor-2&quot;&gt;monitor(process, Pid)&lt;/a&gt;&lt;/code&gt; 呼び出したかのようになります。ここで、 &lt;code&gt;Pid&lt;/code&gt; は新しく作成されたプロセスのプロセス識別子です。 &lt;code&gt;ReqId&lt;/code&gt; によって返される &lt;code&gt;spawn_request()&lt;/code&gt; それから返されたかのように、モニタの基準として使用される &lt;code&gt;monitor(process, Pid)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="57dd227aa1b46ca58edc64f34bfe2c72905f27d3" translate="yes" xml:space="preserve">
          <source>In the basic scenario, each user loads the driver before starting to use it and unloads the driver when done. The reference counting keeps track of processes and the number of loads by each process. This way the driver is only unloaded when no one wants it (it has no user). The driver also keeps track of ports that are opened to it. This enables delay of unloading until all ports are closed, or killing of all ports that use the driver when it is unloaded.</source>
          <target state="translated">基本シナリオでは、使用開始前に各ユーザがドライバをロードし、終了後にドライバをアンロードします。参照カウントは、プロセスと各プロセスによるロード数を追跡します。このようにして、ドライバは誰も必要としないとき(ユーザがいないとき)にのみアンロードされます。ドライバは、それに対して開かれているポートも追跡します。これにより、すべてのポートが閉じるまでアンロードを遅らせたり、ドライバがアンロードされたときにドライバを使用するすべてのポートを停止させたりすることができます。</target>
        </trans-unit>
        <trans-unit id="df529efdc563ccb1cce8f88844c159e25b52362e" translate="yes" xml:space="preserve">
          <source>In the case above the file is fetched from the same directory as all the other files in the messenger example. (*manual*).</source>
          <target state="translated">上記の場合、メッセンジャーの例では、他のすべてのファイルと同じディレクトリからファイルがフェッチされます。(*manual*)となります。</target>
        </trans-unit>
        <trans-unit id="90e65d7cbc556bc107498d3f0738eba580fff797" translate="yes" xml:space="preserve">
          <source>In the case of an upgrade, &lt;code&gt;OldVsn&lt;/code&gt; is &lt;code&gt;Vsn&lt;/code&gt;, and in the case of a downgrade, &lt;code&gt;OldVsn&lt;/code&gt; is &lt;code&gt;{down,Vsn}&lt;/code&gt;. &lt;code&gt;Vsn&lt;/code&gt; is defined by the &lt;code&gt;vsn&lt;/code&gt; attribute(s) of the old version of the callback module &lt;code&gt;Module&lt;/code&gt;. If no such attribute is defined, the version is the checksum of the BEAM file.</source>
          <target state="translated">アップグレードの場合、 &lt;code&gt;OldVsn&lt;/code&gt; は &lt;code&gt;Vsn&lt;/code&gt; であり、ダウングレードの場合、 &lt;code&gt;OldVsn&lt;/code&gt; は &lt;code&gt;{down,Vsn}&lt;/code&gt; です。 &lt;code&gt;Vsn&lt;/code&gt; は、古いバージョンのコールバックモジュール &lt;code&gt;Module&lt;/code&gt; の &lt;code&gt;vsn&lt;/code&gt; 属性によって定義されます。そのような属性が定義されていない場合、バージョンはBEAMファイルのチェックサムです。</target>
        </trans-unit>
        <trans-unit id="7d0cc696cff1dc6d55003eac20e57212616d1c53" translate="yes" xml:space="preserve">
          <source>In the case of reply, megaco will cancel the reply and information of this will be returned to the user via a call to the callback function &lt;code&gt;&lt;a href=&quot;megaco_user#trans_ack&quot;&gt;handle_trans_ack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">返信の場合、megacoは返信をキャンセルし、この情報はコールバック関数 &lt;code&gt;&lt;a href=&quot;megaco_user#trans_ack&quot;&gt;handle_trans_ack&lt;/a&gt;&lt;/code&gt; の呼び出しを介してユーザーに返されます。</target>
        </trans-unit>
        <trans-unit id="a023129e0eddda980464097d8136ae978852b44a" translate="yes" xml:space="preserve">
          <source>In the case of requests, megaco will cancel the message in much the same way as if &lt;code&gt;megaco:cancel&lt;/code&gt; had been called (after a successfull send). The information will be propagated back to the user differently depending on how the request(s) where issued: For requests issued using &lt;code&gt;&lt;a href=&quot;megaco#call&quot;&gt;megaco:call&lt;/a&gt;&lt;/code&gt;, the info will be delivered in the return value. For requests issued using &lt;code&gt;megaco:cast&lt;/code&gt; the info will be delivered via a call to the callback function &lt;code&gt;&lt;a href=&quot;megaco_user#trans_reply&quot;&gt;handle_trans_reply&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">リクエストの場合、megacoは、 &lt;code&gt;megaco:cancel&lt;/code&gt; が呼び出された場合（送信が成功した後）とほぼ同じ方法でメッセージをキャンセルします。情報は、要求が発行された方法に応じて、異なる方法でユーザーに伝播されます &lt;code&gt;&lt;a href=&quot;megaco#call&quot;&gt;megaco:call&lt;/a&gt;&lt;/code&gt; を使用して発行された要求の場合、情報は戻り値で配信されます。使用して発行された要求について &lt;code&gt;megaco:cast&lt;/code&gt; 情報は、コールバック関数の呼び出しを介して配信されます &lt;code&gt;&lt;a href=&quot;megaco_user#trans_reply&quot;&gt;handle_trans_reply&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="21b9a12bb9f423b38a3470e9cb22b9a9da365cf3" translate="yes" xml:space="preserve">
          <source>In the case when &lt;code&gt;Destination&lt;/code&gt; is &lt;code&gt;File&lt;/code&gt;, the printable megaco trace events will be printed to the file &lt;code&gt;File&lt;/code&gt; using plain &lt;code&gt;io:format/2&lt;/code&gt;.</source>
          <target state="translated">場合には &lt;code&gt;Destination&lt;/code&gt; ある &lt;code&gt;File&lt;/code&gt; 、印刷可能なMEGACOのトレースイベントをファイルに出力されます &lt;code&gt;File&lt;/code&gt; 無地使用して &lt;code&gt;io:format/2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c8cfb3597ea67b1de6cbbe1cc8f574a9fb6b0be7" translate="yes" xml:space="preserve">
          <source>In the case when &lt;code&gt;Destination&lt;/code&gt; is &lt;code&gt;io&lt;/code&gt;, the printable megaco trace events will be printed on stdout using plain &lt;code&gt;io:format/2&lt;/code&gt;.</source>
          <target state="translated">場合とき &lt;code&gt;Destination&lt;/code&gt; である &lt;code&gt;io&lt;/code&gt; 印刷可能なMEGACOトレースイベントが普通使用STDOUTに印刷され、 &lt;code&gt;io:format/2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8b3e58c5c2505dec49b18b9e8525ca602801333f" translate="yes" xml:space="preserve">
          <source>In the case when its not possible to immediately establish a connection, the function will return with the &lt;code&gt;&lt;a href=&quot;#type-select_info&quot;&gt;SelectInfo&lt;/a&gt;&lt;/code&gt;. The caller can then await a select message, &lt;code&gt;{'$socket', Socket, select, Info}&lt;/code&gt; (where &lt;code&gt;Info&lt;/code&gt; is the &lt;code&gt;&lt;a href=&quot;socket#type-select_ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; field from the &lt;code&gt;SelectInfo&lt;/code&gt;, a subsequent call to connect will then establish the connection).</source>
          <target state="translated">すぐに接続を確立できない場合、関数は &lt;code&gt;&lt;a href=&quot;#type-select_info&quot;&gt;SelectInfo&lt;/a&gt;&lt;/code&gt; で戻ります。次に、呼び出し元は選択メッセージ &lt;code&gt;{'$socket', Socket, select, Info}&lt;/code&gt; 待つことができます（ &lt;code&gt;Info&lt;/code&gt; は &lt;code&gt;SelectInfo&lt;/code&gt; からの &lt;code&gt;&lt;a href=&quot;socket#type-select_ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; フィールドであり、その後の接続呼び出しによって接続が確立されます）。</target>
        </trans-unit>
        <trans-unit id="54c8b3e1fd01d3f8565818024d0b3a52c9cf2017" translate="yes" xml:space="preserve">
          <source>In the case when the pdu type is &lt;code&gt;report&lt;/code&gt;, &lt;code&gt;MsgData&lt;/code&gt; is either &lt;code&gt;ok&lt;/code&gt; or &lt;code&gt;{error, ReqId, Reason}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;MsgData&lt;/code&gt; タイプが &lt;code&gt;report&lt;/code&gt; の場合、MsgDataは &lt;code&gt;ok&lt;/code&gt; または &lt;code&gt;{error, ReqId, Reason}&lt;/code&gt; いずれかです。</target>
        </trans-unit>
        <trans-unit id="42c6fc4cd12daba8d11cdd4982445015e66db822" translate="yes" xml:space="preserve">
          <source>In the case when there is no connections waiting, the function will return with the &lt;code&gt;SelectInfo&lt;/code&gt;. The caller can then await a select message, &lt;code&gt;{'$socket', Socket, select, Info}&lt;/code&gt; (where &lt;code&gt;Info&lt;/code&gt; is the &lt;code&gt;&lt;a href=&quot;socket#type-select_ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; field from the &lt;code&gt;SelectInfo&lt;/code&gt;), when a client connects (a subsequent call to accept will then return the socket).</source>
          <target state="translated">待機中の接続がない場合、関数は &lt;code&gt;SelectInfo&lt;/code&gt; で戻ります。呼び出し元は、クライアントが接続したときに、選択メッセージ &lt;code&gt;{'$socket', Socket, select, Info}&lt;/code&gt; （ &lt;code&gt;Info&lt;/code&gt; は &lt;code&gt;SelectInfo&lt;/code&gt; からの &lt;code&gt;&lt;a href=&quot;socket#type-select_ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; フィールド）を待つことができます（その後のacceptの呼び出しはソケットを返します）。</target>
        </trans-unit>
        <trans-unit id="97b308070b86e9f2f5cfb71e46c5c56ad9f43c5a" translate="yes" xml:space="preserve">
          <source>In the case when there is no data waiting, the function will return with the &lt;code&gt;SelectInfo&lt;/code&gt;. The caller can then await a select message, &lt;code&gt;{'$socket', Socket, select, Info}&lt;/code&gt; (where &lt;code&gt;Info&lt;/code&gt; is the &lt;code&gt;&lt;a href=&quot;socket#type-select_ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; field from the &lt;code&gt;SelectInfo&lt;/code&gt;), when data has arrived (a subsequent call to recv will then return the data).</source>
          <target state="translated">待機中のデータがない場合、関数は &lt;code&gt;SelectInfo&lt;/code&gt; で戻ります。呼び出し元は、データが到着すると、選択メッセージ &lt;code&gt;{'$socket', Socket, select, Info}&lt;/code&gt; （ &lt;code&gt;Info&lt;/code&gt; は &lt;code&gt;SelectInfo&lt;/code&gt; からの &lt;code&gt;&lt;a href=&quot;socket#type-select_ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; フィールド）を待つことができます（その後、recvを呼び出すとデータが返されます）。</target>
        </trans-unit>
        <trans-unit id="c310b42286356d0fc14eede396b80bde97e8a3eb" translate="yes" xml:space="preserve">
          <source>In the case when there is no data waiting, the function will return with the &lt;code&gt;SelectInfo&lt;/code&gt;. The caller can then await a select message, &lt;code&gt;{'$socket', Socket, select, Info}&lt;/code&gt; (where &lt;code&gt;Info&lt;/code&gt; is the &lt;code&gt;&lt;a href=&quot;socket#type-select_ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; field from the &lt;code&gt;SelectInfo&lt;/code&gt;), when data has arrived (a subsequent call to recvfrom will then return the data).</source>
          <target state="translated">待機中のデータがない場合、関数は &lt;code&gt;SelectInfo&lt;/code&gt; で戻ります。呼び出し元は、データが到着すると、選択メッセージ &lt;code&gt;{'$socket', Socket, select, Info}&lt;/code&gt; （ &lt;code&gt;Info&lt;/code&gt; は &lt;code&gt;SelectInfo&lt;/code&gt; からの &lt;code&gt;&lt;a href=&quot;socket#type-select_ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; フィールド）を待つことができます（その後、recvfromを呼び出すとデータが返されます）。</target>
        </trans-unit>
        <trans-unit id="79a9e35d675f34065de5084906faf62c1cb4d28b" translate="yes" xml:space="preserve">
          <source>In the case when there is no data waiting, the function will return with the &lt;code&gt;SelectInfo&lt;/code&gt;. The caller can then await a select message, &lt;code&gt;{'$socket', Socket, select, Info}&lt;/code&gt; (where &lt;code&gt;Info&lt;/code&gt; is the &lt;code&gt;&lt;a href=&quot;socket#type-select_ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; field from the &lt;code&gt;SelectInfo&lt;/code&gt;), when data has arrived (a subsequent call to recvmsg will then return the data).</source>
          <target state="translated">待機中のデータがない場合、関数は &lt;code&gt;SelectInfo&lt;/code&gt; で戻ります。呼び出し元は、データが到着すると、選択メッセージ &lt;code&gt;{'$socket', Socket, select, Info}&lt;/code&gt; （ &lt;code&gt;Info&lt;/code&gt; は &lt;code&gt;SelectInfo&lt;/code&gt; からの &lt;code&gt;&lt;a href=&quot;socket#type-select_ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; フィールド）を待つことができます（その後、recvmsgを呼び出すとデータが返されます）。</target>
        </trans-unit>
        <trans-unit id="79128b360c469ba004c95bafdca01e1b34773296" translate="yes" xml:space="preserve">
          <source>In the case when there is no room in the (system-) buffers, the function will return with the &lt;code&gt;SelectInfo&lt;/code&gt;. The caller can then await a select message, &lt;code&gt;{'$socket', Socket, select, Info}&lt;/code&gt; (where &lt;code&gt;Info&lt;/code&gt; is the &lt;code&gt;&lt;a href=&quot;socket#type-select_ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; field from the &lt;code&gt;SelectInfo&lt;/code&gt;), when there is room for more data (a subsequent call to send will then send the data).</source>
          <target state="translated">（システム）バッファに空きがない場合、関数は &lt;code&gt;SelectInfo&lt;/code&gt; で戻ります。呼び出し元は、さらにデータの余地があるときに、選択メッセージ &lt;code&gt;{'$socket', Socket, select, Info}&lt;/code&gt; （ &lt;code&gt;Info&lt;/code&gt; は &lt;code&gt;SelectInfo&lt;/code&gt; からの &lt;code&gt;&lt;a href=&quot;socket#type-select_ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; フィールド）を待つことができます（その後の送信呼び出しは、データ）。</target>
        </trans-unit>
        <trans-unit id="e8a00bf019c9ad7cc3ae0aa6563d03144ab91886" translate="yes" xml:space="preserve">
          <source>In the case when there is no room in the (system-) buffers, the function will return with the &lt;code&gt;SelectInfo&lt;/code&gt;. The caller can then await a select message, &lt;code&gt;{'$socket', Socket, select, Info}&lt;/code&gt; (where &lt;code&gt;Info&lt;/code&gt; is the &lt;code&gt;&lt;a href=&quot;socket#type-select_ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; field from the &lt;code&gt;SelectInfo&lt;/code&gt;), when there is room for more data (a subsequent call to sendmsg will then send the data).</source>
          <target state="translated">（システム）バッファに空きがない場合、関数は &lt;code&gt;SelectInfo&lt;/code&gt; で戻ります。呼び出し元は、さらにデータの余地があるときに、選択メッセージ &lt;code&gt;{'$socket', Socket, select, Info}&lt;/code&gt; （ &lt;code&gt;Info&lt;/code&gt; は &lt;code&gt;SelectInfo&lt;/code&gt; からの &lt;code&gt;&lt;a href=&quot;socket#type-select_ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; フィールド）を待つことができます（その後、sendmsgを呼び出すと、データ）。</target>
        </trans-unit>
        <trans-unit id="67338ab252943970a15e1afbfd3aa9bc7bd17164" translate="yes" xml:space="preserve">
          <source>In the case when there is no room in the (system-) buffers, the function will return with the &lt;code&gt;SelectInfo&lt;/code&gt;. The caller can then await a select message, &lt;code&gt;{'$socket', Socket, select, Info}&lt;/code&gt; (where &lt;code&gt;Info&lt;/code&gt; is the &lt;code&gt;&lt;a href=&quot;socket#type-select_ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; field from the &lt;code&gt;SelectInfo&lt;/code&gt;), when there is room for more data (a subsequent call to sendto will then send the data).</source>
          <target state="translated">（システム）バッファに空きがない場合、関数は &lt;code&gt;SelectInfo&lt;/code&gt; で戻ります。呼び出し元は、さらにデータの余地があるときに、選択メッセージ &lt;code&gt;{'$socket', Socket, select, Info}&lt;/code&gt; （ &lt;code&gt;Info&lt;/code&gt; は &lt;code&gt;SelectInfo&lt;/code&gt; からの &lt;code&gt;&lt;a href=&quot;socket#type-select_ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; フィールド）を待つことができます（その後、sendtoを呼び出すと、データ）。</target>
        </trans-unit>
        <trans-unit id="0ee63650ddd58f0ca509c96964f035623c7960f3" translate="yes" xml:space="preserve">
          <source>In the code fragment in the beginning of this section, appending to &lt;code&gt;Bin&lt;/code&gt; will be cheap, while appending to &lt;code&gt;Bin0&lt;/code&gt; will force the creation of a new binary and copying of the contents of &lt;code&gt;Bin0&lt;/code&gt;.</source>
          <target state="translated">このセクションの最初のコードの断片では、への追加 &lt;code&gt;Bin&lt;/code&gt; に追加しているときは、安くなります &lt;code&gt;Bin0&lt;/code&gt; 新しいバイナリの作成を強制しての内容をコピーします &lt;code&gt;Bin0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="245dbc6eca2c173af60f0ff749e12a7fd20aabc1" translate="yes" xml:space="preserve">
          <source>In the configuration above we first raise the primary log level to max in order for the debug log events to get to the handlers. Then we configure the default handler to only log notice and below events, the default log level for a handler is &lt;code&gt;all&lt;/code&gt;. Then the debug handler is configured with a filter to stop any log message that is not a debug level message.</source>
          <target state="translated">上記の構成では、デバッグログイベントがハンドラーに到達するように、最初にプライマリログレベルを最大に上げます。次に、通知と以下のイベントのみをログに記録するようにデフォルトハンドラーを構成します。ハンドラーのデフォルトのログレベルは、 &lt;code&gt;all&lt;/code&gt; です。次に、デバッグハンドラーは、デバッグレベルのメッセージではないログメッセージを停止するフィルターを使用して構成されます。</target>
        </trans-unit>
        <trans-unit id="70fe2afb28a7f768680b296f55f18eec13083414" translate="yes" xml:space="preserve">
          <source>In the cover specification file you can also specify your required level of the code coverage analysis; &lt;code&gt;details&lt;/code&gt; or &lt;code&gt;overview&lt;/code&gt;. In detailed mode, you get a coverage overview page, showing per module and total coverage percentages. You also get an HTML file printed for each module included in the analysis showing exactly what parts of the code have been executed during the test. In overview mode, only the code coverage overview page is printed.</source>
          <target state="translated">カバー仕様ファイルでは、コードカバレッジ分析の必要なレベルを指定することもできます。 &lt;code&gt;details&lt;/code&gt; または &lt;code&gt;overview&lt;/code&gt; 。詳細モードでは、カバレッジ概要ページが表示され、モジュールごとおよびカバレッジの合計パーセンテージが表示されます。また、分析に含まれる各モジュールのHTMLファイルが印刷され、テスト中にコードのどの部分が実行されたかを正確に示します。概要モードでは、コードカバレッジの概要ページのみが印刷されます。</target>
        </trans-unit>
        <trans-unit id="efa59b939ca7fccac1b4966896f1376a9f0ecc3d" translate="yes" xml:space="preserve">
          <source>In the current &lt;code&gt;Common Test&lt;/code&gt; version, the &lt;code&gt;silent_connections&lt;/code&gt; feature only works for Telnet and SSH connections. Support for other connection types can be added in future &lt;code&gt;Common Test&lt;/code&gt; versions.</source>
          <target state="translated">現在の &lt;code&gt;Common Test&lt;/code&gt; バージョンでは、 &lt;code&gt;silent_connections&lt;/code&gt; 機能はTelnetおよびSSH接続でのみ機能します。他の接続タイプのサポートは、将来の &lt;code&gt;Common Test&lt;/code&gt; バージョンで追加される可能性があります。</target>
        </trans-unit>
        <trans-unit id="3f73dc5c892d68a89b94a3b2e5ccad17a219943e" translate="yes" xml:space="preserve">
          <source>In the current implementation of the Erlang/SCTP binding, this event is internally converted into an &lt;code&gt;error&lt;/code&gt; term returned by &lt;code&gt;&lt;a href=&quot;#recv-1&quot;&gt;recv/*&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Erlang / SCTPバインディングの現在の実装では、このイベントは内部的に &lt;code&gt;&lt;a href=&quot;#recv-1&quot;&gt;recv/*&lt;/a&gt;&lt;/code&gt; によって返される &lt;code&gt;error&lt;/code&gt; 項に変換されます。</target>
        </trans-unit>
        <trans-unit id="15e2dc3213e7a3c0466f5bd2cdaed33bfcb2675a" translate="yes" xml:space="preserve">
          <source>In the current implementation, every object insert and look-up operation results in a copy of the object.</source>
          <target state="translated">現在の実装では、すべてのオブジェクトの挿入とルックアップ操作は、オブジェクトのコピーになります。</target>
        </trans-unit>
        <trans-unit id="791527ae8adb388933b027054a83b83e825d6a65" translate="yes" xml:space="preserve">
          <source>In the current version &lt;code&gt;CurVsn&lt;/code&gt; of a release, the application directory of &lt;code&gt;myapp&lt;/code&gt; is &lt;code&gt;$ROOT/lib/myapp-1.0&lt;/code&gt;. A new version &lt;code&gt;NewVsn&lt;/code&gt; is unpacked outside the release handler and the release handler is informed about this with a call as follows:</source>
          <target state="translated">リリースの現在のバージョンの &lt;code&gt;CurVsn&lt;/code&gt; では、 &lt;code&gt;myapp&lt;/code&gt; のアプリケーションディレクトリは &lt;code&gt;$ROOT/lib/myapp-1.0&lt;/code&gt; です。新しいバージョン &lt;code&gt;NewVsn&lt;/code&gt; はリリースハンドラーの外でアンパックされ、リリースハンドラーはこれを次のように呼び出して通知されます。</target>
        </trans-unit>
        <trans-unit id="126027e83a4fcabb438ac0508be585805261c9aa" translate="yes" xml:space="preserve">
          <source>In the data directory, &lt;code&gt;data_dir&lt;/code&gt;, the test module has its own files needed for the testing. The name of &lt;code&gt;data_dir&lt;/code&gt; is the the name of the test suite followed by &lt;code&gt;&quot;_data&quot;&lt;/code&gt;. For example, &lt;code&gt;&quot;some_path/foo_SUITE.beam&quot;&lt;/code&gt; has the data directory &lt;code&gt;&quot;some_path/foo_SUITE_data/&quot;&lt;/code&gt;. Use this directory for portability, that is, to avoid hardcoding directory names in your suite. As the data directory is stored in the same directory as your test suite, you can rely on its existence at runtime, even if the path to your test suite directory has changed between test suite implementation and execution.</source>
          <target state="translated">データディレクトリ &lt;code&gt;data_dir&lt;/code&gt; には、テストモジュールにテストに必要な独自のファイルがあります。名前 &lt;code&gt;data_dir&lt;/code&gt; 続くテストスイートの名前である &lt;code&gt;&quot;_data&quot;&lt;/code&gt; 。たとえば、 &lt;code&gt;&quot;some_path/foo_SUITE.beam&quot;&lt;/code&gt; にはデータディレクトリ &lt;code&gt;&quot;some_path/foo_SUITE_data/&quot;&lt;/code&gt; ます。移植性のために、つまりスイートでディレクトリ名をハードコーディングすることを避けるために、このディレクトリを使用してください。データディレクトリはテストスイートと同じディレクトリに格納されるため、テストスイートの実装と実行の間でテストスイートディレクトリへのパスが変更された場合でも、実行時にその存在に依存できます。</target>
        </trans-unit>
        <trans-unit id="1c079a4d60468994ef72384e15125e8d93afdf37" translate="yes" xml:space="preserve">
          <source>In the descriptions that follow, the form that is used to change the default value are listed.</source>
          <target state="translated">以降の説明では、デフォルト値を変更する際に使用するフォームを記載しています。</target>
        </trans-unit>
        <trans-unit id="4e06544c66c34c090ef2dd2b38c431c2b495f098" translate="yes" xml:space="preserve">
          <source>In the detailed information window for a node, any existing links and monitors between processes on the originating node and the connected node are displayed. &lt;strong&gt;Extra Info&lt;/strong&gt; can contain debug information (that is, special information written if the emulator is debug-compiled) or error information.</source>
          <target state="translated">ノードの詳細情報ウィンドウには、元のノードと接続されたノードのプロセス間の既存のリンクとモニターが表示されます。&lt;strong&gt;追加情報に&lt;/strong&gt;は、デバッグ情報（つまり、エミュレータがデバッグコンパイルされた場合に書き込まれる特別な情報）またはエラー情報を含めることができます。</target>
        </trans-unit>
        <trans-unit id="8ba5880443f43a3af428d4fbb8404826ac0d26fd" translate="yes" xml:space="preserve">
          <source>In the end, the C compiler will probably optimize this code to the same native code as the first version, but the first version is certainly much easier to read for human readers.</source>
          <target state="translated">結局、Cコンパイラはこのコードを最初のバージョンと同じネイティブコードに最適化するのでしょうが、人間の読者にとっては最初のバージョンの方が読みやすいのは間違いありません。</target>
        </trans-unit>
        <trans-unit id="14e4ef55ecc440a106bcf9a15acab47c72a79a18" translate="yes" xml:space="preserve">
          <source>In the erl command line:</source>
          <target state="translated">erlコマンドラインで</target>
        </trans-unit>
        <trans-unit id="fe10364408e4f6b1e20c24b12efb18fb322cbcc9" translate="yes" xml:space="preserve">
          <source>In the event manager, zero, one, or many &lt;strong&gt;event handlers&lt;/strong&gt; are installed. When the event manager is notified about an event, the event is processed by all the installed event handlers. For example, an event manager for handling errors can by default have a handler installed, which writes error messages to the terminal. If the error messages during a certain period are to be saved to a file as well, the user adds another event handler that does this. When logging to the file is no longer necessary, this event handler is deleted.</source>
          <target state="translated">イベントマネージャには、0個、1個、または多数の&lt;strong&gt;イベントハンドラ&lt;/strong&gt;がインストールされます。イベントマネージャにイベントが通知されると、インストールされているすべてのイベントハンドラによってイベントが処理されます。たとえば、エラーを処理するためのイベントマネージャには、デフォルトでハンドラをインストールして、エラーメッセージを端末に書き込むことができます。特定の期間のエラーメッセージもファイルに保存する場合、ユーザーはこれを行う別のイベントハンドラーを追加します。ファイルへのログ記録が不要になると、このイベントハンドラーは削除されます。</target>
        </trans-unit>
        <trans-unit id="4da5bd1aa9e79875ba613d02238e60ec877667a6" translate="yes" xml:space="preserve">
          <source>In the event manager, zero, one, or many &lt;strong&gt;event handlers&lt;/strong&gt; are installed. When the event manager is notified about an event, the event is processed by all the installed event handlers. For example, an event manager for handling errors can by default have a handler installed, which writes error messages to the terminal. If the error messages during a certain period is to be saved to a file as well, the user adds another event handler that does this. When logging to the file is no longer necessary, this event handler is deleted.</source>
          <target state="translated">イベントマネージャには、0個、1個、または多数の&lt;strong&gt;イベントハンドラ&lt;/strong&gt;がインストールされています。イベントマネージャにイベントが通知されると、インストールされているすべてのイベントハンドラによってイベントが処理されます。たとえば、エラーを処理するためのイベントマネージャには、デフォルトで、エラーメッセージを端末に書き込むハンドラをインストールできます。特定の期間のエラーメッセージもファイルに保存する場合、ユーザーはこれを行う別のイベントハンドラーを追加します。ファイルへのログ記録が不要になると、このイベントハンドラーは削除されます。</target>
        </trans-unit>
        <trans-unit id="8841b315d1e28c3d331ee376f7a7d69baa5c6c9d" translate="yes" xml:space="preserve">
          <source>In the example above the &lt;code&gt; &lt;strong&gt;on_load&lt;/strong&gt;&lt;/code&gt; directive is used get function &lt;code&gt;init&lt;/code&gt; called automatically when the module is loaded. Function &lt;code&gt;init&lt;/code&gt; in turn calls &lt;code&gt;&lt;a href=&quot;erlang#load_nif-2&quot;&gt;erlang:load_nif/2&lt;/a&gt;&lt;/code&gt; which loads the NIF library and replaces the &lt;code&gt;hello&lt;/code&gt; function with its native implementation in C. Once loaded, a NIF library is persistent. It will not be unloaded until the module code version that it belongs to is purged.</source>
          <target state="translated">上記の例では、 &lt;code&gt; &lt;strong&gt;on_load&lt;/strong&gt;&lt;/code&gt; ディレクティブが使用され、モジュールがロードされると自動的に呼び出されるget関数 &lt;code&gt;init&lt;/code&gt; が使用されます。関数 &lt;code&gt;init&lt;/code&gt; は次に &lt;code&gt;&lt;a href=&quot;erlang#load_nif-2&quot;&gt;erlang:load_nif/2&lt;/a&gt;&lt;/code&gt; を呼び出し、NIFライブラリをロードし、 &lt;code&gt;hello&lt;/code&gt; 関数をCのネイティブ実装に置き換えます。ロードされると、NIFライブラリは永続的です。それが属するモジュールコードバージョンがパージされるまで、アンロードされません。 &lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="053d93ad21874bd7646e0f9e5ec91996c0b105b7" translate="yes" xml:space="preserve">
          <source>In the example above, valid &lt;code&gt;keys&lt;/code&gt; could be &lt;code&gt;{&quot;hi&quot;, &quot;mom&quot;}&lt;/code&gt; and &lt;code&gt;{&quot;no&quot;, &quot;thanks&quot;}&lt;/code&gt;, whereas &lt;code&gt;&quot;hi&quot;&lt;/code&gt;, &lt;code&gt;{&quot;hi&quot;, 42}&lt;/code&gt; and &lt;code&gt;{&quot;hello&quot;, &quot;there&quot;}&lt;/code&gt; would be invalid.</source>
          <target state="translated">上記の例では、有効な &lt;code&gt;keys&lt;/code&gt; は &lt;code&gt;{&quot;hi&quot;, &quot;mom&quot;}&lt;/code&gt; および &lt;code&gt;{&quot;no&quot;, &quot;thanks&quot;}&lt;/code&gt; が、 &lt;code&gt;&quot;hi&quot;&lt;/code&gt; 、 &lt;code&gt;{&quot;hi&quot;, 42}&lt;/code&gt; および &lt;code&gt;{&quot;hello&quot;, &quot;there&quot;}&lt;/code&gt; は無効になります。</target>
        </trans-unit>
        <trans-unit id="2fc7b559b47ea8932c9a1025d16c15176231ffae" translate="yes" xml:space="preserve">
          <source>In the example below, lines number 2,4,6,8 and 11 are executable lines:</source>
          <target state="translated">以下の例では、2,4,6,8,11行目が実行可能な行となっています。</target>
        </trans-unit>
        <trans-unit id="194d855c8237df6928638ceec954bb4deb7ecf5b" translate="yes" xml:space="preserve">
          <source>In the example in the previous section, &lt;code&gt;gen_server&lt;/code&gt; is started by calling &lt;code&gt;ch3:start_link()&lt;/code&gt;:</source>
          <target state="translated">前のセクションの例では、 &lt;code&gt;gen_server&lt;/code&gt; は &lt;code&gt;ch3:start_link()&lt;/code&gt; を呼び出すことによって開始されます。</target>
        </trans-unit>
        <trans-unit id="b9a0b9dbd81dc16f4bbd6ea7b8db17b1ce28ef5b" translate="yes" xml:space="preserve">
          <source>In the example in the previous section, &lt;code&gt;gen_statem&lt;/code&gt; is started by calling &lt;code&gt;code_lock:start_link(Code)&lt;/code&gt;:</source>
          <target state="translated">前のセクションの例では、 &lt;code&gt;gen_statem&lt;/code&gt; は &lt;code&gt;code_lock:start_link(Code)&lt;/code&gt; を呼び出すことによって開始されます。</target>
        </trans-unit>
        <trans-unit id="4b4a36b06eda88b8723feb14b4b4c62ed1f4fdaf" translate="yes" xml:space="preserve">
          <source>In the example the Presented IDs are &lt;code&gt;example.com&lt;/code&gt; as well as hostnames matching &lt;code&gt;*.example.com&lt;/code&gt;. For example &lt;code&gt;foo.example.com&lt;/code&gt; and &lt;code&gt;bar.example.com&lt;/code&gt; both matches but not &lt;code&gt;foo.bar.example.com&lt;/code&gt;. The name &lt;code&gt;erlang.org&lt;/code&gt; matches neither since it is not a CN.</source>
          <target state="translated">この例では、提示されたIDは &lt;code&gt;example.com&lt;/code&gt; であり、ホスト名は &lt;code&gt;*.example.com&lt;/code&gt; に一致しています。たとえば、 &lt;code&gt;foo.example.com&lt;/code&gt; と &lt;code&gt;bar.example.com&lt;/code&gt; はどちらも一致しますが、foo.bar.example.comは一致しませ &lt;code&gt;foo.bar.example.com&lt;/code&gt; 。 &lt;code&gt;erlang.org&lt;/code&gt; という名前はCNではないため、どちらにも一致しません。</target>
        </trans-unit>
        <trans-unit id="7bfbaeffabf4dcd6ae7bae0878c51517112f0368" translate="yes" xml:space="preserve">
          <source>In the example, &lt;code&gt;handle_debug&lt;/code&gt; is called for each incoming and outgoing message. The format function &lt;code&gt;Func&lt;/code&gt; is the function &lt;code&gt;ch4:write_debug/3&lt;/code&gt;, which prints the message using &lt;code&gt;io:format/3&lt;/code&gt;.</source>
          <target state="translated">この例では、着信メッセージと発信メッセージごとに &lt;code&gt;handle_debug&lt;/code&gt; が呼び出されます。フォーマット関数 &lt;code&gt;Func&lt;/code&gt; は、関数 &lt;code&gt;ch4:write_debug/3&lt;/code&gt; であり、 &lt;code&gt;io:format/3&lt;/code&gt; を使用してメッセージを出力します。</target>
        </trans-unit>
        <trans-unit id="ac68bd607f8264f012241fcc414c2e661fd6689b" translate="yes" xml:space="preserve">
          <source>In the example, component &lt;code&gt;number&lt;/code&gt; of the first of the encoded elements in the &lt;code&gt;SEQUENCE OF&lt;/code&gt;&lt;code&gt;buttonList&lt;/code&gt; is selected. This applies on the ASN.1 specification in Section &lt;code&gt;&lt;a href=&quot;#Asn1spec&quot;&gt;Writing an Exclusive Decode Instruction&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">この例では、 &lt;code&gt;SEQUENCE OF&lt;/code&gt; &lt;code&gt;buttonList&lt;/code&gt; の最初のエンコードされた要素のコンポーネント &lt;code&gt;number&lt;/code&gt; が選択されています。これは、セクション &lt;code&gt;&lt;a href=&quot;#Asn1spec&quot;&gt;Writing an Exclusive Decode Instruction&lt;/a&gt;&lt;/code&gt; の記述」のASN.1仕様に適用されます。</target>
        </trans-unit>
        <trans-unit id="5530f78486b7d29f24a47eae49f0d8075dda6924" translate="yes" xml:space="preserve">
          <source>In the example, operator &lt;code&gt;==/2&lt;/code&gt; has been handled exactly as &lt;code&gt;=:=/2&lt;/code&gt; would have been handled. However, if it cannot be determined at compile time that some constant is free of integers, and the table uses &lt;code&gt;=:=/2&lt;/code&gt; when comparing keys for equality (see option &lt;code&gt;&lt;a href=&quot;#key_equality&quot;&gt;key_equality&lt;/a&gt;&lt;/code&gt;), then the &lt;code&gt;qlc&lt;/code&gt; module does not try to look up the constant. The reason is that there is in the general case no upper limit on the number of key values that can compare equal to such a constant; every combination of integers and floats must be looked up:</source>
          <target state="translated">この例では、演算子 &lt;code&gt;==/2&lt;/code&gt; は、 &lt;code&gt;=:=/2&lt;/code&gt; と同じように処理されています。ただし、一部の定数に整数がないとコンパイル時に判別できず、テーブルがキーの等価性を比較するときに &lt;code&gt;=:=/2&lt;/code&gt; を使用する場合（オプション &lt;code&gt;&lt;a href=&quot;#key_equality&quot;&gt;key_equality&lt;/a&gt;&lt;/code&gt; を参照）、 &lt;code&gt;qlc&lt;/code&gt; モジュールは定数の検索を試みません。その理由は、一般に、そのような定数と同等に比較できるキー値の数に上限がないためです。整数と浮動小数点数のすべての組み合わせを検索する必要があります。</target>
        </trans-unit>
        <trans-unit id="5d4ade845da9cf61c7c17decc1f4b425ce968a4b" translate="yes" xml:space="preserve">
          <source>In the example, synchronous start is used. The process starts by calling &lt;code&gt;ch4:start_link()&lt;/code&gt;:</source>
          <target state="translated">この例では、同期起動を使用しています。プロセスは &lt;code&gt;ch4:start_link()&lt;/code&gt; を呼び出すことで開始します。</target>
        </trans-unit>
        <trans-unit id="4bd7e62d6b3c0db60fe6d59696b8717a4d0ca575" translate="yes" xml:space="preserve">
          <source>In the example, the plain node name is &lt;code&gt;c1&lt;/code&gt;.</source>
          <target state="translated">この例では、プレーンノード名は &lt;code&gt;c1&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="6c6e7a22eaacfa776abf6442cc14a2f231bbabc9" translate="yes" xml:space="preserve">
          <source>In the example:</source>
          <target state="translated">例の中では</target>
        </trans-unit>
        <trans-unit id="c137f104119ba8c9533a7a6a7d789c35c273096b" translate="yes" xml:space="preserve">
          <source>In the examples, you can see that the default Erlang shell interprets only characters from the ISO Latin1 range as printable and only detects lists or binaries with those &quot;printable&quot; characters as containing string data. The valid UTF-8 binary containing the Russian word &quot;Юникод&quot;, is not printed as a string. When started with all Unicode characters printable (&lt;code&gt;+pc unicode&lt;/code&gt;), the shell outputs anything containing printable Unicode data (in binaries, either UTF-8 or bytewise encoded) as string data.</source>
          <target state="translated">例では、デフォルトのErlangシェルがISO Latin1範囲の文字のみを印刷可能として解釈し、それらの「印刷可能」文字を含むリストまたはバイナリのみを文字列データを含むものとして検出することがわかります。ロシア語の「Юникод」を含む有効なUTF-8バイナリは、文字列として出力されません。印刷可能なすべてのUnicode文字（ &lt;code&gt;+pc unicode&lt;/code&gt; ）で開始すると、シェルは印刷可能なUnicodeデータ（バイナリ、UTF-8またはバイト単位でエンコードされたもの）を含むすべてを文字列データとして出力します。</target>
        </trans-unit>
        <trans-unit id="357a42f4e90c9f66d20838b1568c32edad86596f" translate="yes" xml:space="preserve">
          <source>In the exchange of DH parameters in cipher suites providing non-anonymous PFS (perfect forward secrecy).</source>
          <target state="translated">非匿名のPFS(完全な前方秘匿)を提供する暗号スイートにおけるDHパラメータの交換において。</target>
        </trans-unit>
        <trans-unit id="43ef791e4bc1073452a5e9418b88d2ae576f87d3" translate="yes" xml:space="preserve">
          <source>In the first form of function calls, &lt;code&gt;ExprM:ExprF(Expr1,...,ExprN)&lt;/code&gt;, each of &lt;code&gt;ExprM&lt;/code&gt; and &lt;code&gt;ExprF&lt;/code&gt; must be an atom or an expression that evaluates to an atom. The function is said to be called by using the &lt;strong&gt;fully qualified function name&lt;/strong&gt;. This is often referred to as a &lt;strong&gt;remote&lt;/strong&gt; or &lt;strong&gt;external function call&lt;/strong&gt;.</source>
          <target state="translated">関数呼び出しの最初の形式である &lt;code&gt;ExprM:ExprF(Expr1,...,ExprN)&lt;/code&gt; では、 &lt;code&gt;ExprM&lt;/code&gt; と &lt;code&gt;ExprF&lt;/code&gt; はそれぞれアトムまたはアトムに評価される式でなければなりません。関数は、&lt;strong&gt;完全修飾関数名&lt;/strong&gt;を使用して呼び出されると言われています。これは、しばしば&lt;strong&gt;リモート&lt;/strong&gt;または&lt;strong&gt;外部関数呼び出しと呼ばれます&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="f6d99757df807bd06e120fa43c0767f20375e1c3" translate="yes" xml:space="preserve">
          <source>In the first section (&lt;code&gt;&lt;a href=&quot;#Event-Driven%20State%20Machines&quot;&gt;Event-Driven State Machines&lt;/a&gt;&lt;/code&gt;), actions were mentioned as a part of the general state machine model. These general actions are implemented with the code that &lt;strong&gt;callback module&lt;/strong&gt;&lt;code&gt;gen_statem&lt;/code&gt; executes in an event-handling callback function before returning to the &lt;code&gt;gen_statem&lt;/code&gt; engine.</source>
          <target state="translated">最初のセクション（ &lt;code&gt;&lt;a href=&quot;#Event-Driven%20State%20Machines&quot;&gt;Event-Driven State Machines&lt;/a&gt;&lt;/code&gt; ）では、アクションは一般的なステートマシンモデルの一部として言及されました。これらの一般的なアクションは、&lt;strong&gt;コールバックモジュール&lt;/strong&gt; &lt;code&gt;gen_statem&lt;/code&gt; が &lt;code&gt;gen_statem&lt;/code&gt; エンジンに戻る前にイベント処理コールバック関数で実行するコードで実装され&lt;strong&gt;ます&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="0855a6f8ea31ce47315705d1ba7c199b9582a1fd" translate="yes" xml:space="preserve">
          <source>In the first section &lt;code&gt;&lt;a href=&quot;#Event-Driven%20State%20Machines&quot;&gt;Event-Driven State Machines&lt;/a&gt;&lt;/code&gt; actions were mentioned as a part of the general state machine model. These general actions are implemented with the code that callback module &lt;code&gt;gen_statem&lt;/code&gt; executes in an event-handling callback function before returning to the &lt;code&gt;gen_statem&lt;/code&gt; engine.</source>
          <target state="translated">最初のセクションでは、 &lt;code&gt;&lt;a href=&quot;#Event-Driven%20State%20Machines&quot;&gt;Event-Driven State Machines&lt;/a&gt;&lt;/code&gt; アクションについて、一般的なステートマシンモデルの一部として説明しました。これらの一般的なアクションは、コールバックモジュール &lt;code&gt;gen_statem&lt;/code&gt; が &lt;code&gt;gen_statem&lt;/code&gt; エンジンに戻る前にイベント処理コールバック関数で実行するコードで実装されます。</target>
        </trans-unit>
        <trans-unit id="66f43d3184fba6cdf7fdff11b421851146670c0d" translate="yes" xml:space="preserve">
          <source>In the first word (4 bytes) of &lt;code&gt;ID&lt;/code&gt;, only 18 bits are significant, the rest are to be 0. In &lt;code&gt;Creation&lt;/code&gt;, only two bits are significant, the rest are to be 0.</source>
          <target state="translated">&lt;code&gt;ID&lt;/code&gt; の最初のワード（4バイト）では、18ビットのみが有効で、残りは0です。 &lt;code&gt;Creation&lt;/code&gt; 、2ビットのみが有効で、残りは0です。</target>
        </trans-unit>
        <trans-unit id="5e047fa558c6b3687797900dae4cc1f9d07908ea" translate="yes" xml:space="preserve">
          <source>In the first word (4 bytes) of &lt;code&gt;ID&lt;/code&gt;, only 18 bits are significant, the rest must be 0.</source>
          <target state="translated">&lt;code&gt;ID&lt;/code&gt; の最初のワード（4バイト）では、18ビットのみが重要であり、残りは0でなければなりません。</target>
        </trans-unit>
        <trans-unit id="5a896f5f2e336921d68f534c573e7c4a11187dc7" translate="yes" xml:space="preserve">
          <source>In the following descriptions the use of the word &lt;strong&gt;Point&lt;/strong&gt; means: &quot;Point can be seen as the position of the cursor. More precisely, the point is the position between two characters while the cursor is drawn over the character following the point&quot;.</source>
          <target state="translated">以下の説明では、&lt;strong&gt;ポイント&lt;/strong&gt;という用語の使用は、「ポイントはカーソルの位置と見なすことができます。より正確には、ポイントは、カーソルがポイントに続く文字の上に描画されているときの2つの文字間の位置です。」</target>
        </trans-unit>
        <trans-unit id="58edff9fe9daaff2e76b914cd8a32390c2924ba9" translate="yes" xml:space="preserve">
          <source>In the following descriptions, a &lt;strong&gt;group node&lt;/strong&gt; is a node belonging to the same global group as the local node.</source>
          <target state="translated">以下の説明では、&lt;strong&gt;グループノード&lt;/strong&gt;は、ローカルノードと同じグローバルグループに属するノードです。</target>
        </trans-unit>
        <trans-unit id="e55f234f9ae533df0bfe915b6749a10bc4217ff2" translate="yes" xml:space="preserve">
          <source>In the following descriptions, all functions fail with reason &lt;code&gt;badarg&lt;/code&gt; if &lt;code&gt;heart&lt;/code&gt; is not started.</source>
          <target state="translated">以下の説明では、 &lt;code&gt;heart&lt;/code&gt; が開始されていない場合、すべての関数が &lt;code&gt;badarg&lt;/code&gt; の理由で失敗します。</target>
        </trans-unit>
        <trans-unit id="68f124a8843620b9753fc32d51bbb85f7300a1d2" translate="yes" xml:space="preserve">
          <source>In the following example QLC &lt;code&gt;V2&lt;/code&gt; has been inserted to show the joined generators and the join method chosen. A convention is used for lookup join: the first generator (&lt;code&gt;G2&lt;/code&gt;) is the one traversed, the second (&lt;code&gt;G1&lt;/code&gt;) is the table where constants are looked up.</source>
          <target state="translated">次の例では、QLC &lt;code&gt;V2&lt;/code&gt; が挿入され、結合されたジェネレーターと選択された結合方法が示されています。規則はルックアップ結合に使用されます。最初のジェネレータ（ &lt;code&gt;G2&lt;/code&gt; ）はトラバースされるもので、2番目（ &lt;code&gt;G1&lt;/code&gt; ）は定数がルックアップされるテーブルです。</target>
        </trans-unit>
        <trans-unit id="2d50c8a2eb999244e04ab8a6f262c9e2e6443db3" translate="yes" xml:space="preserve">
          <source>In the following example the cached results of the merge join are traversed for each value of &lt;code&gt;A&lt;/code&gt;. Notice that without option &lt;code&gt;cache&lt;/code&gt; the join would have been carried out three times, once for each value of &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">次の例では、マージ結合のキャッシュされた結果が &lt;code&gt;A&lt;/code&gt; の値ごとにトラバースされます。オプション &lt;code&gt;cache&lt;/code&gt; がない場合、結合は &lt;code&gt;A&lt;/code&gt; の各値に対して1回ずつ、3回実行されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="260a8dfa6e31c2145458e7a7056ce3363d755407" translate="yes" xml:space="preserve">
          <source>In the following example two processes are created and they send messages to each other a number of times.</source>
          <target state="translated">次の例では、2 つのプロセスが作成され、互いに何度もメッセージを送信します。</target>
        </trans-unit>
        <trans-unit id="486ff704c9f58f71f4584cc309e9153505629a15" translate="yes" xml:space="preserve">
          <source>In the following example two simple QLCs are inserted only to hold option &lt;code&gt;{unique,&amp;nbsp;true}&lt;/code&gt;:</source>
          <target state="translated">次の例では &lt;code&gt;{unique,&amp;nbsp;true}&lt;/code&gt; オプション{unique、true}を保持するためだけに2つの単純なQLCが挿入されています。</target>
        </trans-unit>
        <trans-unit id="069932958b3334f12d9e43060017f62f9f5a1fe0" translate="yes" xml:space="preserve">
          <source>In the following example using this program, nodes are started on four different computers. If you do not have that many machines available on your network, you can start several nodes on the same machine.</source>
          <target state="translated">このプログラムを使用した次の例では、4 台の異なるコンピュータでノードが起動されています。ネットワーク上にそれほど多くのマシンがない場合は、同じマシン上で複数のノードを起動することができます。</target>
        </trans-unit>
        <trans-unit id="02724734c231edad2b6c90b6ad85a686c74a1bd4" translate="yes" xml:space="preserve">
          <source>In the following example, &lt;code&gt;Common Test&lt;/code&gt; finds and executes two tests, one for the path from &lt;code&gt;top2&lt;/code&gt; to &lt;code&gt;sub2X2&lt;/code&gt; through &lt;code&gt;sub21&lt;/code&gt;, and one from &lt;code&gt;top2&lt;/code&gt; to &lt;code&gt;sub2X2&lt;/code&gt; through &lt;code&gt;sub22&lt;/code&gt;:</source>
          <target state="translated">次の例では、 &lt;code&gt;Common Test&lt;/code&gt; 検索し実行する二つの試験からのパスのための1つの &lt;code&gt;top2&lt;/code&gt; に &lt;code&gt;sub2X2&lt;/code&gt; スルー &lt;code&gt;sub21&lt;/code&gt; 、およびから1 &lt;code&gt;top2&lt;/code&gt; に &lt;code&gt;sub2X2&lt;/code&gt; スルー &lt;code&gt;sub22&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2f8fe7428e9b6fba7b913b17290b372522a768bd" translate="yes" xml:space="preserve">
          <source>In the following example, &lt;code&gt;{Pid, hello_world}&lt;/code&gt; is sent to a registered process &lt;code&gt;my_server&lt;/code&gt;. The message is encoded by &lt;code&gt;erl_send()&lt;/code&gt;:</source>
          <target state="translated">次の例では、 &lt;code&gt;{Pid, hello_world}&lt;/code&gt; が登録済みのプロセス &lt;code&gt;my_server&lt;/code&gt; に送信されます。メッセージは &lt;code&gt;erl_send()&lt;/code&gt; によってエンコードされます。</target>
        </trans-unit>
        <trans-unit id="0b55abcde93dfcf59993923892aaa3fe74b62110" translate="yes" xml:space="preserve">
          <source>In the following example, &lt;code&gt;{Pid, hello_world}&lt;/code&gt; is sent to a registered process &lt;code&gt;my_server&lt;/code&gt;:</source>
          <target state="translated">次の例では、 &lt;code&gt;{Pid, hello_world}&lt;/code&gt; が登録済みのプロセス &lt;code&gt;my_server&lt;/code&gt; に送信されます。</target>
        </trans-unit>
        <trans-unit id="e87829810ad78056f565335e48937b1227a1b55a" translate="yes" xml:space="preserve">
          <source>In the following example, by specifying the unique path &lt;code&gt;top2 -&amp;gt; sub21 -&amp;gt; sub2X2&lt;/code&gt;, only one test is executed. The second possible path, from &lt;code&gt;top2&lt;/code&gt; to &lt;code&gt;sub2X2&lt;/code&gt; (from the former example) is discarded:</source>
          <target state="translated">次の例では、一意のパス &lt;code&gt;top2 -&amp;gt; sub21 -&amp;gt; sub2X2&lt;/code&gt; 指定することにより、1つのテストのみが実行されます。第二の可能な経路、 &lt;code&gt;top2&lt;/code&gt; に &lt;code&gt;sub2X2&lt;/code&gt; （前者の例から）が廃棄されます。</target>
        </trans-unit>
        <trans-unit id="d0cef84143c9c72b0e2d6136f433352bbf267b98" translate="yes" xml:space="preserve">
          <source>In the following example, function &lt;code&gt;dbg:get_tracer/0&lt;/code&gt; is used as trigger for sequential tracing:</source>
          <target state="translated">次の例では、関数 &lt;code&gt;dbg:get_tracer/0&lt;/code&gt; が順次トレースのトリガーとして使用されています。</target>
        </trans-unit>
        <trans-unit id="e10f21b2e3aef85bbfe3ce9d0d87c1a9e3d0bb5a" translate="yes" xml:space="preserve">
          <source>In the following example, lines 2, 4, 6, 8, and 11 are executable lines:</source>
          <target state="translated">以下の例では、2行目、4行目、6行目、8行目、11行目が実行可能な行となっています。</target>
        </trans-unit>
        <trans-unit id="ec7e7bea0a8acebe642deb025a0a656aa8b0599d" translate="yes" xml:space="preserve">
          <source>In the following example, modules &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;bar&lt;/code&gt; are used:</source>
          <target state="translated">次の例では、モジュール &lt;code&gt;foo&lt;/code&gt; および &lt;code&gt;bar&lt;/code&gt; が使用されています。</target>
        </trans-unit>
        <trans-unit id="b174caeefec04ac55e06d8f3b6476035f46aeb21" translate="yes" xml:space="preserve">
          <source>In the following example, the BIF &lt;code&gt;self()&lt;/code&gt; returns the pid of the calling process:</source>
          <target state="translated">次の例では、BIF &lt;code&gt;self()&lt;/code&gt; は呼び出しプロセスのpidを返します。</target>
        </trans-unit>
        <trans-unit id="5409dc0e8a019858263b90292ca1f90716b01a8e" translate="yes" xml:space="preserve">
          <source>In the following example, the Erlang shell is the client process that receives the channel replies as Erlang messages.</source>
          <target state="translated">次の例では、ErlangシェルがErlangメッセージとしてチャンネルの返信を受け取るクライアントプロセスです。</target>
        </trans-unit>
        <trans-unit id="6ce80e1521f6fcf4a9ffbad8c36f531e99dceb7f" translate="yes" xml:space="preserve">
          <source>In the following example, the Erlang shell is the client process that receives the channel replies.</source>
          <target state="translated">次の例では、Erlangシェルがチャンネルの返信を受け取るクライアントプロセスです。</target>
        </trans-unit>
        <trans-unit id="cfc2a057978208f3e231a6ca3795b61b50bf66e8" translate="yes" xml:space="preserve">
          <source>In the following example, this ASN.1 specification is used:</source>
          <target state="translated">以下の例では、このASN.</target>
        </trans-unit>
        <trans-unit id="f502d38db7db19f5a8116d52d78b40fbb3f26ca6" translate="yes" xml:space="preserve">
          <source>In the following example, two event handlers for the &lt;code&gt;my_SUITE&lt;/code&gt; test are installed:</source>
          <target state="translated">次の例では、 &lt;code&gt;my_SUITE&lt;/code&gt; テスト用の2つのイベントハンドラーがインストールされています。</target>
        </trans-unit>
        <trans-unit id="c99802972b16068431483b2dc762f303df3c8e55" translate="yes" xml:space="preserve">
          <source>In the following example, using the &lt;code&gt;gb_table&lt;/code&gt; module from section &lt;code&gt;&lt;a href=&quot;#implementing_a_qlc_table&quot;&gt;Implementing a QLC Table&lt;/a&gt;&lt;/code&gt;, there are six keys to look up: &lt;code&gt;{1,a}&lt;/code&gt;, &lt;code&gt;{1,b}&lt;/code&gt;, &lt;code&gt;{1,c}&lt;/code&gt;, &lt;code&gt;{2,a}&lt;/code&gt;, &lt;code&gt;{2,b}&lt;/code&gt;, and &lt;code&gt;{2,c}&lt;/code&gt;. The reason is that the two elements of key &lt;code&gt;{X,&amp;nbsp;Y}&lt;/code&gt; are compared separately.</source>
          <target state="translated">次の例では、「 &lt;code&gt;gb_table&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;#implementing_a_qlc_table&quot;&gt;Implementing a QLC Table&lt;/a&gt;&lt;/code&gt; セクションのgb_tableモジュールを使用して、検索するキーが6つあります。 &lt;code&gt;{1,a}&lt;/code&gt; 、 &lt;code&gt;{1,b}&lt;/code&gt; 、 &lt;code&gt;{1,c}&lt;/code&gt; 、 &lt;code&gt;{2,a}&lt;/code&gt; 、 &lt;code&gt;{2,b}&lt;/code&gt; 、および &lt;code&gt;{2,c}&lt;/code&gt; 。その理由は、キー &lt;code&gt;{X,&amp;nbsp;Y}&lt;/code&gt; の2つの要素が別々に比較されるためです。</target>
        </trans-unit>
        <trans-unit id="d124bbc7f859ed1a5ddec67afc96d8bbbbad9429" translate="yes" xml:space="preserve">
          <source>In the following examples we use the XML file &quot;motorcycles.xml&quot; and the corresponding DTD &quot;motorcycles.dtd&quot;. motorcycles.xml looks like:</source>
          <target state="translated">以下の例では、XMLファイル「motorcycles.xml」と対応するDTD「motorcycles.dtd」を使用します。</target>
        </trans-unit>
        <trans-unit id="54c1ac0436f87ef143bfc77676125c65125284d3" translate="yes" xml:space="preserve">
          <source>In the following figure, only the marked element is decoded by &lt;code&gt;selected_decode_Window2&lt;/code&gt;:</source>
          <target state="translated">次の図では、マークされた要素のみが &lt;code&gt;selected_decode_Window2&lt;/code&gt; によってデコードされます。</target>
        </trans-unit>
        <trans-unit id="0c1dae61c9ea7eeeb091e362a88deed9b63e97d4" translate="yes" xml:space="preserve">
          <source>In the following figure, square boxes represents supervisors and circles represent workers:</source>
          <target state="translated">次の図では、四角い箱がスーパーバイザー、円が労働者を表しています。</target>
        </trans-unit>
        <trans-unit id="209a1f0310434ec6333f0a98add95c288369e4f6" translate="yes" xml:space="preserve">
          <source>In the following list, init flags are marked &quot;(init flag)&quot;. Unless otherwise specified, all other flags are user flags, for which the values can be retrieved by calling &lt;code&gt;init:get_argument/1&lt;/code&gt;. Notice that the list of user flags is not exhaustive, there can be more application-specific flags that instead are described in the corresponding application documentation.</source>
          <target state="translated">次のリストでは、initフラグは「（init flag）」とマークされています。特に指定がない限り、他のすべてのフラグはユーザーフラグであり、その値は &lt;code&gt;init:get_argument/1&lt;/code&gt; を呼び出すことで取得できます。ユーザーフラグのリストがすべてではないことに注意してください。代わりに、対応するアプリケーションのドキュメントで説明されているアプリケーション固有のフラグが存在する場合があります。</target>
        </trans-unit>
        <trans-unit id="f8c81236f8fbf95dbe539a4a6fcdb86c4472d944" translate="yes" xml:space="preserve">
          <source>In the following sections, these topics are described:</source>
          <target state="translated">以下では、これらのトピックについて説明する。</target>
        </trans-unit>
        <trans-unit id="43ab0d842bde8340d1582f777849f8b8cfc4d0b4" translate="yes" xml:space="preserve">
          <source>In the following sections, we've described as much as we could about the installation of the tools needed. Once the tools are installed, building is quite easy. We have also tried to make these instructions understandable for people with limited Unix experience. Cygwin/MSYS/MSYS2 is a whole new environment to some Windows users, why careful explanation of environment variables etc seemed to be in place.</source>
          <target state="translated">以下では、必要なツールのインストールについて、できる限り説明してきました。ツールがインストールされれば、ビルドはとても簡単です。また、これらの説明は、Unix の経験が浅い人にも理解できるようにしています。Cygwin/MSYS/MSYS2はWindowsユーザーにとっては全く新しい環境であるため、環境変数などの説明が丁寧に行われているようです。</target>
        </trans-unit>
        <trans-unit id="1fd2193cd39cfac6403a706b39a45fed6722ffda" translate="yes" xml:space="preserve">
          <source>In the following sections, we've described as much as we could about the installation of the tools needed. Once the tools are installed, building is quite easy. We have also tried to make these instructions understandable for people with limited Unix experience. WSL is a whole new environment to some Windows users, why careful explanation of environment variables etc seemed to be in place.</source>
          <target state="translated">以下では、必要なツールのインストールについて、できる限り説明してきました。ツールがインストールされれば、ビルドはとても簡単です。また、これらの説明は、Unix の経験が限られている人にも理解できるようにしています。WindowsユーザにとってWSLは全く新しい環境なので、環境変数などの説明が丁寧に行われているようです。</target>
        </trans-unit>
        <trans-unit id="a18adb25fa4d203ef4dc10b4df54df585b5037d2" translate="yes" xml:space="preserve">
          <source>In the following situations, you can easily avoid calling &lt;code&gt;lists:flatten/1&lt;/code&gt;:</source>
          <target state="translated">次の状況では、 &lt;code&gt;lists:flatten/1&lt;/code&gt; の呼び出しを簡単に回避できます。</target>
        </trans-unit>
        <trans-unit id="95df25c253f6cf034d9de8bd86d0112fd600064e" translate="yes" xml:space="preserve">
          <source>In the following tables of examples, &lt;code&gt;Data&lt;/code&gt; must be an I/O list. An I/O list is a binary or a (possibly deep) list of binaries or integers in the range 0..255:</source>
          <target state="translated">次の例の表では、 &lt;code&gt;Data&lt;/code&gt; はI / Oリストでなければなりません。I / Oリストは、バイナリまたは0〜255の範囲のバイナリまたは整数の（おそらく深い）リストです。</target>
        </trans-unit>
        <trans-unit id="cded6a813afbe8a22f1a0d31c8b7cd61b0e5883b" translate="yes" xml:space="preserve">
          <source>In the following terms that may cause confusion are explained.</source>
          <target state="translated">以下では、混乱を招く可能性のある用語について説明します。</target>
        </trans-unit>
        <trans-unit id="969dff5637554c154992258cc999ceb5dbf066be" translate="yes" xml:space="preserve">
          <source>In the functions defined below, the following types are used:</source>
          <target state="translated">以下に定義する関数では、以下のタイプを使用します。</target>
        </trans-unit>
        <trans-unit id="eb8417214d7ef7c1c16243855a2cbc54cd750318" translate="yes" xml:space="preserve">
          <source>In the future, debug functionality will probably be integrated with the Erlang driver thread API. All functions that create entities take a &lt;code&gt;name&lt;/code&gt; argument. Currently the &lt;code&gt;name&lt;/code&gt; argument is unused, but it will be used when the debug functionality is implemented. If you name all entities created well, the debug functionality will be able to give you better error reports.</source>
          <target state="translated">将来的には、デバッグ機能はおそらくErlangドライバースレッドAPIと統合されるでしょう。エンティティを作成するすべての関数は、 &lt;code&gt;name&lt;/code&gt; 引数を取ります。現在、 &lt;code&gt;name&lt;/code&gt; 引数は使用されていませんが、デバッグ機能が実装されるときに使用されます。作成したすべてのエンティティに適切な名前を付けると、デバッグ機能により、より適切なエラーレポートを提供できるようになります。</target>
        </trans-unit>
        <trans-unit id="60a72bba166a7e938efa7cb1218d2bae46312c9d" translate="yes" xml:space="preserve">
          <source>In the generated boot script all application directories are structured as &lt;code&gt;App-Vsn/ebin&lt;/code&gt;. They are assumed to be located in &lt;code&gt;$ROOT/lib&lt;/code&gt;, where &lt;code&gt;$ROOT&lt;/code&gt; is the root directory of the installed release. If option &lt;code&gt;local&lt;/code&gt; is specified, the actual directories where the applications were found are used instead. This is a useful way to test a generated boot script locally.</source>
          <target state="translated">生成されたブートスクリプトでは、すべてのアプリケーションディレクトリが &lt;code&gt;App-Vsn/ebin&lt;/code&gt; として構造化されています。これらは &lt;code&gt;$ROOT/lib&lt;/code&gt; あると想定されています。 &lt;code&gt;$ROOT&lt;/code&gt; はインストールされたリリースのルートディレクトリです。オプション &lt;code&gt;local&lt;/code&gt; が指定されている場合、アプリケーションが見つかった実際のディレクトリが代わりに使用されます。これは、生成されたブートスクリプトをローカルでテストするのに便利な方法です。</target>
        </trans-unit>
        <trans-unit id="8357564b87a53bc03f3e072c2affa02b3f338254" translate="yes" xml:space="preserve">
          <source>In the last example the module to analyze was given as an argument to &lt;code&gt;m/1&lt;/code&gt;, and the code path was (implicitly) used as &lt;code&gt;&lt;a href=&quot;xref#library_path&quot;&gt;library path&lt;/a&gt;&lt;/code&gt;. In this example an &lt;code&gt;&lt;a href=&quot;xref#xref_server&quot;&gt;xref server&lt;/a&gt;&lt;/code&gt; will be used, which makes it possible to analyze applications and releases, and also to select the library path explicitly.</source>
          <target state="translated">最後の例では、分析するモジュールが &lt;code&gt;m/1&lt;/code&gt; への引数として与えられ、コードパスが（暗黙的に） &lt;code&gt;&lt;a href=&quot;xref#library_path&quot;&gt;library path&lt;/a&gt;&lt;/code&gt; として使用されました。この例では、 &lt;code&gt;&lt;a href=&quot;xref#xref_server&quot;&gt;xref server&lt;/a&gt;&lt;/code&gt; が使用されます。これにより、アプリケーションとリリースを分析し、ライブラリパスを明示的に選択することもできます。</target>
        </trans-unit>
        <trans-unit id="53bf7f90f102c21f6ff33e9b95147ea6befa4500" translate="yes" xml:space="preserve">
          <source>In the last line, notice that the tuple {256,10,-2} is the real number 2.56 in a special notation, which encodes faster than simply stating the number as &lt;code&gt;&quot;2.56&quot;&lt;/code&gt;. The arity three tuple is &lt;code&gt;{Mantissa,Base,Exponent}&lt;/code&gt;, that is, Mantissa * Base^Exponent.</source>
          <target state="translated">最後の行で、タプル{256,10、-2}が特別な表記の実数2.56であることに注意してください。これは、数値を単に &lt;code&gt;&quot;2.56&quot;&lt;/code&gt; と述べるよりも高速にエンコードします。アリティ3のタプルは &lt;code&gt;{Mantissa,Base,Exponent}&lt;/code&gt; 。つまり、Mantissa * Base ^ Exponentです。</target>
        </trans-unit>
        <trans-unit id="f93bba552275aa89bdb5e765c9d14d6ea2d7aaa2" translate="yes" xml:space="preserve">
          <source>In the lists that are divided in two for the two directions (c.f &lt;code&gt;cipher&lt;/code&gt;) it is possible to change both directions at once:</source>
          <target state="translated">2つの方向に2つに分割されているリスト（ &lt;code&gt;cipher&lt;/code&gt; 参照）では、両方の方向を一度に変更できます。</target>
        </trans-unit>
        <trans-unit id="00675dbb48a26b0a91eca4f2bc6b8535be7bd247" translate="yes" xml:space="preserve">
          <source>In the lists that are divided in two for the two directions (c.f &lt;code&gt;cipher&lt;/code&gt;) it is possible to change only one of the directions:</source>
          <target state="translated">2つの方向に2つに分割されたリスト（ &lt;code&gt;cipher&lt;/code&gt; 参照）では、方向の1つのみを変更できます。</target>
        </trans-unit>
        <trans-unit id="9467c0d9e7e0679d7e286a3e84f7825f450479dd" translate="yes" xml:space="preserve">
          <source>In the loop where requests are handled, send time-outs can now be detected:</source>
          <target state="translated">リクエストを処理するループで、送信のタイムアウトを検出できるようになりました。</target>
        </trans-unit>
        <trans-unit id="9da6cdcd2464f9aa69d41b9520dcbcf709d10ca9" translate="yes" xml:space="preserve">
          <source>In the messenger example, no assumptions have been made about what the message being sent is. It can be any valid Erlang term.</source>
          <target state="translated">メッセンジャーの例では、送信されるメッセージが何であるかについては何も仮定していません。これは有効なErlang用語です。</target>
        </trans-unit>
        <trans-unit id="8edc784c5711aef4324569d61cb733c3b77cb091" translate="yes" xml:space="preserve">
          <source>In the modified lock free version of this approach we more or less do it the same way, but with some important modifications trying to avoid unnecessary contention when multiple schedulers create processes simultaneously. Since multiple threads might be trying to search for the next free slot at the same time from the same starting point we want subsequent slots to be located in different cache lines. Multiple schedulers simultaneously writing new pointers into the table are therefore very likely to write into adjacent slots. If adjacent slots are located in the same cache line all modification of this cache line needs to be communicated between all involved processors which will be very expensive and scale very poor. By locating adjacent slots in different cache lines only true conflicts will trigger communication between involved processors, i.e., avoiding false sharing.</source>
          <target state="translated">このアプローチの修正されたロックフリーバージョンでは、ほぼ同じ方法で行いますが、複数のスケジューラが同時にプロセスを作成する際に不必要な競合を避けるためにいくつかの重要な修正を加えています。複数のスレッドが同じ開始点から同時に次の空きスロットを探そうとしているかもしれないので、後続のスロットは別のキャッシュラインにあるようにしたいのです。複数のスケジューラが同時にテーブルに新しいポインタを書き込むと、隣接するスロットに書き込む可能性が高くなります。隣接するスロットが同じキャッシュラインに配置されている場合、このキャッシュラインのすべての変更は、関係するすべてのプロセッサ間で通信する必要があり、非常に高価であり、スケールが非常に悪いです。隣接スロットを異なるキャッシュラインに配置することにより、真の競合のみが関係するプロセッサ間の通信を誘発し、すなわち、偽の共有を回避する。</target>
        </trans-unit>
        <trans-unit id="bb3b53f608800b09e4b113953e980be25982bcf7" translate="yes" xml:space="preserve">
          <source>In the monitor message &lt;code&gt;MonitorRef&lt;/code&gt; and &lt;code&gt;Type&lt;/code&gt; are the same as described earlier, and:</source>
          <target state="translated">モニターメッセージの &lt;code&gt;MonitorRef&lt;/code&gt; と &lt;code&gt;Type&lt;/code&gt; は、前に説明したものと同じです。</target>
        </trans-unit>
        <trans-unit id="6af58c3bd490620b572e86c6ee20f0568469a3cc" translate="yes" xml:space="preserve">
          <source>In the new design the old wheel was dropped and instead replaced by one struct (&lt;code&gt;GenericBp&lt;/code&gt;) to hold the data for all types of breakpoints for each instrumented function. A bit-flag field is used to indicate what different type of break actions that are enabled.</source>
          <target state="translated">新しい設計では、古いホイールが削除され、代わりに1つの構造体（ &lt;code&gt;GenericBp&lt;/code&gt; ）に置き換えられて、インストルメントされた各関数のすべてのタイプのブレークポイントのデータが保持されます。ビットフラグフィールドは、有効になっているさまざまなタイプのブレークアクションを示すために使用されます。</target>
        </trans-unit>
        <trans-unit id="3a775ef8f9dc8be5c9fdaee0cab605f0e25c280e" translate="yes" xml:space="preserve">
          <source>In the next garbage collection, any pointers to the old heap will be ignored and not scanned. This way the garbage collector does not have to scan the long-lived terms.</source>
          <target state="translated">次のガベージコレクションでは、古いヒープへのポインタは無視され、スキャンされません。この方法では、ガベージコレクタは長寿命の用語をスキャンする必要がありません。</target>
        </trans-unit>
        <trans-unit id="f6d0c33ad0d8698789ff1ce734a374e0b8dc46cb" translate="yes" xml:space="preserve">
          <source>In the next word the tagged atom &lt;code&gt;id&lt;/code&gt; is stored.</source>
          <target state="translated">次の単語には、タグ付けされたアトム &lt;code&gt;id&lt;/code&gt; が格納されます。</target>
        </trans-unit>
        <trans-unit id="440342ee163fa2a69d1ae77fbeb319e6027a604d" translate="yes" xml:space="preserve">
          <source>In the normal case, a version is constructed as &lt;code&gt;&amp;lt;Major&amp;gt;.&amp;lt;Minor&amp;gt;.&amp;lt;Patch&amp;gt;&lt;/code&gt;, where &lt;code&gt;&amp;lt;Major&amp;gt;&lt;/code&gt; is the most significant part.</source>
          <target state="translated">通常の場合、バージョンは &lt;code&gt;&amp;lt;Major&amp;gt;.&amp;lt;Minor&amp;gt;.&amp;lt;Patch&amp;gt;&lt;/code&gt; として構築されます。ここで、 &lt;code&gt;&amp;lt;Major&amp;gt;&lt;/code&gt; は最も重要な部分です。</target>
        </trans-unit>
        <trans-unit id="eef10fd45d5bc3efdc8a361eb2983aa877e3b993" translate="yes" xml:space="preserve">
          <source>In the presence of initial values for fields, the type must be declared after the initialization, as follows:</source>
          <target state="translated">フィールドの初期値がある場合は、以下のように初期化後に型を宣言する必要があります。</target>
        </trans-unit>
        <trans-unit id="85f68555c1cd1c300b04b62bde8ff2ba3511a30a" translate="yes" xml:space="preserve">
          <source>In the previous example there is no indication of which protocols are expected. So a client has no indication of whether it is a web server, an ldap server or maybe a sip server it is connected to. There are fields in the certificate that can indicate this. To be more exact, the rfc introduces the usage of the &lt;code&gt;X509v3 Subject Alternative Name&lt;/code&gt; in the &lt;code&gt;X509v3 extensions&lt;/code&gt; field:</source>
          <target state="translated">前の例では、どのプロトコルが予期されるかを示していません。したがって、クライアントには、それがWebサーバーであるか、LDAPサーバーであるか、接続されているsipサーバーであるかが示されていません。これを示すことができる証明書のフィールドがあります。より正確に言うと、rfc は &lt;code&gt;X509v3 extensions&lt;/code&gt; フィールドで &lt;code&gt;X509v3 Subject Alternative Name&lt;/code&gt; の別名の使用を導入しています。</target>
        </trans-unit>
        <trans-unit id="540597900320cac0101d153b777e3c96ce5dbf16" translate="yes" xml:space="preserve">
          <source>In the previous example, &quot;ping&quot; and &quot;pong&quot; were started from the shells of two separate Erlang nodes. &lt;code&gt;spawn&lt;/code&gt; can also be used to start processes in other nodes.</source>
          <target state="translated">前の例では、「ping」と「pong」は2つの別々のErlangノードのシェルから開始されました。 &lt;code&gt;spawn&lt;/code&gt; は、他のノードでプロセスを開始するためにも使用できます。</target>
        </trans-unit>
        <trans-unit id="b18cd2f860e67d545dd4ad1005cc630df953632b" translate="yes" xml:space="preserve">
          <source>In the previous example, if &lt;code&gt;all/0&lt;/code&gt; returns group name references in the order &lt;code&gt;[{group,group1},{group,group3}]&lt;/code&gt;, the order of the configuration functions and test cases becomes the following (notice that &lt;code&gt;init_per_testcase/2&lt;/code&gt; and &lt;code&gt;end_per_testcase/2:&lt;/code&gt; are also always called, but not included in this example for simplification):</source>
          <target state="translated">前の例では、 &lt;code&gt;all/0&lt;/code&gt; が &lt;code&gt;[{group,group1},{group,group3}]&lt;/code&gt; の順序でグループ名参照を返す場合、構成関数とテストケースの順序は次のようになります（ &lt;code&gt;init_per_testcase/2&lt;/code&gt; と &lt;code&gt;end_per_testcase/2:&lt;/code&gt; 常に呼び出されますが、簡略化のためにこの例には含まれていません）：</target>
        </trans-unit>
        <trans-unit id="d05bdeaa2197b362b108ffe823ac50e3ee94a479" translate="yes" xml:space="preserve">
          <source>In the previous example, the supervisor is started by calling &lt;code&gt;ch_sup:start_link()&lt;/code&gt;:</source>
          <target state="translated">上記の例では、スーパーバイザーは &lt;code&gt;ch_sup:start_link()&lt;/code&gt; を呼び出すことによって開始されます。</target>
        </trans-unit>
        <trans-unit id="05d2378639fa9498426915ef27016e468d81ee73" translate="yes" xml:space="preserve">
          <source>In the previous examples, new variable names are used, instead of reusing the old ones: &lt;code&gt;First&lt;/code&gt;, &lt;code&gt;TheRest&lt;/code&gt;, &lt;code&gt;E1&lt;/code&gt;, &lt;code&gt;E2&lt;/code&gt;, &lt;code&gt;R&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;, and &lt;code&gt;C&lt;/code&gt;. The reason for this is that a variable can only be given a value once in its context (scope). More about this later.</source>
          <target state="translated">前の例では、古い変数を再利用する代わりに、新しい変数名 &lt;code&gt;First&lt;/code&gt; 、 &lt;code&gt;TheRest&lt;/code&gt; 、 &lt;code&gt;E1&lt;/code&gt; 、 &lt;code&gt;E2&lt;/code&gt; 、 &lt;code&gt;R&lt;/code&gt; 、 &lt;code&gt;A&lt;/code&gt; 、 &lt;code&gt;B&lt;/code&gt; 、 &lt;code&gt;C&lt;/code&gt; が使用されています。この理由は、変数にはそのコンテキスト（スコープ）で一度しか値を指定できないためです。これについては後で詳しく説明します。</target>
        </trans-unit>
        <trans-unit id="9db752d6e6f2fd68cc464e93f5288f571d158e54" translate="yes" xml:space="preserve">
          <source>In the runtime system with SMP support, drivers are locked either on driver level or port level (driver instance level). By default driver level locking will be used, that is, only one emulator thread will execute code in the driver at a time. If port level locking is used, multiple emulator threads can execute code in the driver at the same time. Only one thread at a time will call driver callbacks corresponding to the same port, though. To enable port level locking, set the &lt;code id=&quot;smp_support&quot;&gt;ERL_DRV_FLAG_USE_PORT_LOCKING&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;driver_entry#driver_flags&quot;&gt;driver flag&lt;/a&gt;&lt;/code&gt; in the &lt;code&gt;&lt;a href=&quot;driver_entry&quot;&gt;driver_entry&lt;/a&gt;&lt;/code&gt; used by the driver. When port level locking is used, the driver writer is responsible for synchronizing all accesses to data shared by the ports (driver instances).</source>
          <target state="translated">SMPをサポートするランタイムシステムでは、ドライバーはドライバーレベルまたはポートレベル（ドライバーインスタンスレベル）でロックされます。デフォルトでは、ドライバレベルのロックが使用されます。つまり、一度に1つのエミュレータスレッドだけがドライバのコードを実行します。ポートレベルのロックが使用されている場合、複数のエミュレータスレッドがドライバのコードを同時に実行できます。ただし、一度に1つのスレッドのみが同じポートに対応するドライバーコールバックを呼び出します。ポートレベルのロックを有効にするために、設定 &lt;code id=&quot;smp_support&quot;&gt;ERL_DRV_FLAG_USE_PORT_LOCKING&lt;/code&gt; の &lt;code&gt;&lt;a href=&quot;driver_entry#driver_flags&quot;&gt;driver flag&lt;/a&gt;&lt;/code&gt; に &lt;code&gt;&lt;a href=&quot;driver_entry&quot;&gt;driver_entry&lt;/a&gt;&lt;/code&gt; ドライバによって使用されます。ポートレベルのロックを使用する場合、ドライバー作成者は、ポート（ドライバーインスタンス）によって共有されるデータへのすべてのアクセスを同期する必要があります。</target>
        </trans-unit>
        <trans-unit id="45c47bc5d9c1563d221339ce4f4f3726200c6a90" translate="yes" xml:space="preserve">
          <source>In the second example we use the default trace handler function. This handler prints to tty by sending IO requests to the &lt;code&gt;user&lt;/code&gt; process. When Erlang is started in oldshell mode, the shell process will have &lt;code&gt;user&lt;/code&gt; as its group leader and so will the tracer process in this example. Since &lt;code&gt;user&lt;/code&gt; calls functions in &lt;code&gt;lists&lt;/code&gt; we end up in a deadlock as soon as the first IO request is sent.</source>
          <target state="translated">2番目の例では、デフォルトのトレースハンドラー関数を使用します。このハンドラは、IO要求を &lt;code&gt;user&lt;/code&gt; プロセスに送信することによってttyに出力します。Erlangがoldshellモードで開始されると、シェルプロセスはグループリーダーとして &lt;code&gt;user&lt;/code&gt; を持ち、この例ではトレーサープロセスもそうです。 &lt;code&gt;user&lt;/code&gt; が &lt;code&gt;lists&lt;/code&gt; 内の関数を呼び出すため、最初のIO要求が送信されるとすぐにデッドロックが発生します。</target>
        </trans-unit>
        <trans-unit id="c04391cfdd5ab08da1a538b9e9e445cf468e3b94" translate="yes" xml:space="preserve">
          <source>In the second form of function calls, &lt;code&gt;ExprF(Expr1,...,ExprN)&lt;/code&gt;, &lt;code&gt;ExprF&lt;/code&gt; must be an atom or evaluate to a fun.</source>
          <target state="translated">関数呼び出しの2番目の形式である &lt;code&gt;ExprF(Expr1,...,ExprN)&lt;/code&gt; では、 &lt;code&gt;ExprF&lt;/code&gt; はアトムであるか、funに評価される必要があります。</target>
        </trans-unit>
        <trans-unit id="739f1313c2f241e229ecba15f499a06fac9e9ec7" translate="yes" xml:space="preserve">
          <source>In the sequence chart, the actors (which symbolically has performed the &lt;code&gt;Event&lt;/code&gt;) are shown as named vertical bars. The order of the actors may be altered by dragging (hold mouse button 1 pressed during the operation) the name tag of an actor and drop it elsewhere:</source>
          <target state="translated">シーケンスチャートでは、アクター（象徴的に &lt;code&gt;Event&lt;/code&gt; を実行した）が名前付きの縦棒として表示されます。アクターの順序は、アクターの名前タグをドラッグ（操作中にマウスボタン1を押したまま）して別の場所にドロップすることで変更できます。</target>
        </trans-unit>
        <trans-unit id="7823fdfa2d6e99d8afc1d184adab525e34685552" translate="yes" xml:space="preserve">
          <source>In the setup of the SSH connection a secret cipher key is generated by co-operation of the client and the server. Keeping this key secret is crucial for keeping the communication secret. As time passes and encrypted messages are exchanged, the probability that a listener could guess that key increases.</source>
          <target state="translated">SSH 接続の設定では、クライアントとサーバが協力して秘密の暗号鍵を生成します。この鍵を秘密にしておくことは、通信の秘密を守るために非常に重要です。時間が経ち、暗号化されたメッセージが交換されるにつれて、リスナーがその鍵を推測できる確率が高くなります。</target>
        </trans-unit>
        <trans-unit id="2624ef8dfa305150cd47498ba182bfff4991d99a" translate="yes" xml:space="preserve">
          <source>In the shell, if using a Unicode input device, or in source code stored in UTF-8, &lt;code&gt;$&lt;/code&gt; can be followed directly by a Unicode character producing an integer. In the following example, the code point of a Cyrillic &lt;code&gt;с&lt;/code&gt; is output:</source>
          <target state="translated">シェルでは、Unicode入力デバイスを使用する場合、またはUTF-8で保存されたソースコードの場合、 &lt;code&gt;$&lt;/code&gt; の後に整数を生成するUnicode文字を直接続けることができます。次の例では、キリル文字 &lt;code&gt;с&lt;/code&gt; のコードポイントが出力されます。</target>
        </trans-unit>
        <trans-unit id="a13f065991e8e14b6a7d0e85181fc27a2c686176" translate="yes" xml:space="preserve">
          <source>In the situation where a node has lost its connections to other nodes in its global group, but has connections to nodes in other global groups, a request from another global group can produce an incorrect or misleading result. For example, the isolated node can have inaccurate information about registered names in its global group.</source>
          <target state="translated">ノードがグローバルグループ内の他のノードとの接続を失ったが、他のグローバルグループ内のノードとの接続を持っているという状況では、他のグローバルグループからのリクエストにより、不正確な結果や誤解を招く結果が生じる可能性があります。例えば、孤立したノードは、そのグローバルグループに登録された名前に関する不正確な情報を持つことができます。</target>
        </trans-unit>
        <trans-unit id="45354ca6d5ea2475e4f281fd6c145d031cdf7187" translate="yes" xml:space="preserve">
          <source>In the supervisor &lt;code&gt;child specification&lt;/code&gt; there is a list of modules which is recommended to contain only the callback module. For a &lt;code&gt;gen_statem&lt;/code&gt; with multiple callback modules there is no real need to list all of them, it may not even be possible since the list could change after code upgrade. If this list would contain only the start callback module, as recommended, what is important is to upgrade &lt;strong&gt;that&lt;/strong&gt; module whenever a &lt;strong&gt;synchronized code replacement&lt;/strong&gt; is done. Then the release handler concludes that an upgrade that upgrades &lt;strong&gt;that&lt;/strong&gt; module needs to suspend, code change, and resume any server whose child specification declares that it is using &lt;strong&gt;that&lt;/strong&gt; module. And again; the &lt;strong&gt;current&lt;/strong&gt; callback module will get the &lt;code&gt;Module:code_change/4&lt;/code&gt; call.</source>
          <target state="translated">スーパーバイザーの &lt;code&gt;child specification&lt;/code&gt; には、コールバックモジュールのみを含めることが推奨されるモジュールのリストがあります。複数のコールバックモジュールを持つ &lt;code&gt;gen_statem&lt;/code&gt; の場合、それらすべてをリストする必要はありません。コードのアップグレード後にリストが変更される可能性があるため、リストが変更されない場合もあります。推奨されているように、このリストに開始コールバックモジュールのみが含まれる場合、重要なのは、&lt;strong&gt;同期されたコード置換&lt;/strong&gt;が行われるたびに&lt;strong&gt;その&lt;/strong&gt;モジュールをアップグレードする&lt;strong&gt;こと&lt;/strong&gt;です。次に、リリースハンドラーは、&lt;strong&gt;その&lt;/strong&gt;モジュールをアップグレードするアップグレードでは、子仕様で&lt;strong&gt;その&lt;/strong&gt;モジュールを使用していると宣言されているサーバーを一時停止、コード変更、および再開する必要があると結論付けます。そしてまた;&lt;strong&gt;現在&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;コールバックモジュールは、 &lt;code&gt;Module:code_change/4&lt;/code&gt; 呼び出しを取得します。</target>
        </trans-unit>
        <trans-unit id="34787be2516bd25bc51ccdee0b0ac4c6d7eba78b" translate="yes" xml:space="preserve">
          <source>In the tail part of the data structure we find a pointer to the last element of the list, or at least something that is near the end of the list. In the uncontended case it will point to the end of the list, but when simultaneous insert operations are performed it will point to something near the end of the list.</source>
          <target state="translated">データ構造の末尾には、リストの最後の要素、あるいは少なくともリストの末尾に近いものへのポインタがあります。不満がない場合はリストの最後を指しますが、同時挿入操作が行われた場合はリストの最後に近いものを指します。</target>
        </trans-unit>
        <trans-unit id="f1acddb6beb61278fbb0d6fbae558f662971ab57" translate="yes" xml:space="preserve">
          <source>In the target directory reads the file &lt;code&gt;releases/start_erl.data&lt;/code&gt; to find the Erlang runtime system version (&quot;5.10.4&quot;).</source>
          <target state="translated">ターゲットディレクトリで、 &lt;code&gt;releases/start_erl.data&lt;/code&gt; ファイルを読み取り、Erlangランタイムシステムのバージョン（ &quot;5.10.4&quot;）を見つけます。</target>
        </trans-unit>
        <trans-unit id="8519783e0474dbe47084ba06a2c57f937aceddd6" translate="yes" xml:space="preserve">
          <source>In the text encoding, implementors have the choice of using a mix of short and long keywords. It is also possible to add white spaces to improve readability. We use the term compact for text messages with the shortest possible keywords and no optional white spaces, and the term pretty for a well indented text format using long keywords and an indentation style like the text examples in the Megaco/H.248 specification).</source>
          <target state="translated">テキストエンコーディングでは、実装者は短いキーワードと長いキーワードを混在させて使用する選択肢があります。また、可読性を向上させるためにホワイトスペースを追加することも可能です。ここでは、可能な限り短いキーワードとオプションの空白を持たないテキストメッセージにはコンパクトという用語を用い、長いキーワードとMegaco/H.248仕様のテキスト例のようなインデントスタイルを用いた、十分にインデントされたテキストフォーマットにはプリティという用語を用いています)。</target>
        </trans-unit>
        <trans-unit id="a5c95ea342ee7c08382d8806e33a6d11792130c7" translate="yes" xml:space="preserve">
          <source>In the traditional transport entries, when the &lt;code&gt;Addr&lt;/code&gt; value does not contain a port number, the value of &lt;code&gt;intAgentUDPPort&lt;/code&gt; is used.</source>
          <target state="translated">従来のトランスポートエントリでは、 &lt;code&gt;Addr&lt;/code&gt; 値にポート番号が含まれていない場合、 &lt;code&gt;intAgentUDPPort&lt;/code&gt; の値が使用されます。</target>
        </trans-unit>
        <trans-unit id="a8436cdbd307ab8656dafbbaa0b4535513613e69" translate="yes" xml:space="preserve">
          <source>In the wake of this the function &lt;code&gt;sys:get_debug/3&lt;/code&gt; that returns data with undocumented and internal format (and therefore is practically useless) has been deprecated, and a new function &lt;code&gt;sys:get_log/1&lt;/code&gt; has been added, that hopefully does what the deprecated function was intended for.</source>
          <target state="translated">これを受けて、文書化されていない内部形式でデータを返す（したがって実際には役に立たない）関数 &lt;code&gt;sys:get_debug/3&lt;/code&gt; が非推奨になり、新しい関数 &lt;code&gt;sys:get_log/1&lt;/code&gt; が追加されました。これにより、非推奨となることが期待されます。機能が意図されていました。</target>
        </trans-unit>
        <trans-unit id="4f97637d135e2db9b66d48ef02e3dc2bf1b27bf1" translate="yes" xml:space="preserve">
          <source>In the xmerl_xs functions you can provide a select(String) call, which is an &lt;code&gt;&lt;a href=&quot;http://www.w3.org/TR/xpath&quot;&gt;XPath&lt;/a&gt;&lt;/code&gt; functionality. For more details see the xmerl_xs &lt;code&gt;tutorial&lt;/code&gt;.</source>
          <target state="translated">xmerl_xs関数では、 &lt;code&gt;&lt;a href=&quot;http://www.w3.org/TR/xpath&quot;&gt;XPath&lt;/a&gt;&lt;/code&gt; 機能であるselect（String）呼び出しを提供できます。詳細については、xmerl_xs &lt;code&gt;tutorial&lt;/code&gt; 参照してください。</target>
        </trans-unit>
        <trans-unit id="1dac4b7f84924719cb25f1773bfbe993e383c0c1" translate="yes" xml:space="preserve">
          <source>In these cases, the ProtocolVersion default version is obtained from the static connection configuration:</source>
          <target state="translated">これらの場合、ProtocolVersionのデフォルトバージョンは、静的接続構成から取得されます。</target>
        </trans-unit>
        <trans-unit id="d38f971f169182ffed875b881c3f302c1291f57c" translate="yes" xml:space="preserve">
          <source>In this agent system, there are two ways to dynamically install management information. The most common way is to load an MIB into an agent. The other way is to use a sub-agent, which is controlled by the application and is able to register and unregister itself. A sub-agent can register itself for managing a sub-tree (not to be mixed up with &lt;code&gt;erlang:register&lt;/code&gt;). The sub-tree is identified by an Object Identifier. When a sub-agent is registered, it receives all requests for this particular sub-tree and it is responsible for answering them. It should also be noted that a sub-agent can be started and stopped at any time.</source>
          <target state="translated">このエージェントシステムでは、管理情報を動的にインストールする方法が2つあります。最も一般的な方法は、MIBをエージェントにロードすることです。もう1つの方法は、アプリケーションによって制御され、それ自体を登録および登録解除できるサブエージェントを使用することです。サブエージェントは、サブツリーを管理するためにそれ自体を登録できます（ &lt;code&gt;erlang:register&lt;/code&gt; と混同しないでください）。サブツリーはオブジェクト識別子によって識別されます。サブエージェントが登録されると、サブエージェントはこの特定のサブツリーに対するすべての要求を受け取り、それらに応答する責任があります。サブエージェントはいつでも開始および停止できることに注意してください。</target>
        </trans-unit>
        <trans-unit id="539e0564531c6d44cbeae350dfc80c3176291ed6" translate="yes" xml:space="preserve">
          <source>In this call, &lt;code&gt;[1, 1]&lt;/code&gt; is the &lt;code&gt;RowIndex&lt;/code&gt;, where key 1 has value 1, and key 2 has value 1, and &lt;code&gt;[3, 5]&lt;/code&gt; is the list of requested columns. The function should now return the lexicographically next elements:</source>
          <target state="translated">この呼び出しでは、 &lt;code&gt;[1, 1]&lt;/code&gt; は &lt;code&gt;RowIndex&lt;/code&gt; です。キー1の値は1で、キー2の値は1で、 &lt;code&gt;[3, 5]&lt;/code&gt; は要求された列のリストです。関数は辞書順で次の要素を返すはずです。</target>
        </trans-unit>
        <trans-unit id="6f444892327372c0083d6cd41d371bb581f5034e" translate="yes" xml:space="preserve">
          <source>In this case it has got a new component &lt;code&gt;b&lt;/code&gt;. Thus, incoming messages that are decoded can have more or fever components than this one.</source>
          <target state="translated">この場合、新しいコンポーネント &lt;code&gt;b&lt;/code&gt; を取得しています。したがって、デコードされる着信メッセージには、これよりも多くの、または発熱するコンポーネントがあります。</target>
        </trans-unit>
        <trans-unit id="81909444a643000153b2965fd71e17cdec12149b" translate="yes" xml:space="preserve">
          <source>In this case the &lt;code&gt;ct_hooks&lt;/code&gt; statement in the test suite can look as follows:</source>
          <target state="translated">この場合、テストスイートの &lt;code&gt;ct_hooks&lt;/code&gt; ステートメントは次のようになります。</target>
        </trans-unit>
        <trans-unit id="4a51ade1b4e89205ca9bc9b111738c60e7a1c022" translate="yes" xml:space="preserve">
          <source>In this case the configuration file must at least contain:</source>
          <target state="translated">この場合、設定ファイルは少なくとも含まれていなければなりません。</target>
        </trans-unit>
        <trans-unit id="1d7088cf673c6d087bf2c25d65e3c008f7960123" translate="yes" xml:space="preserve">
          <source>In this case the filter is applied to every possible pair of answers to &lt;code&gt;QH1&lt;/code&gt; and &lt;code&gt;QH2&lt;/code&gt;, one at a time. If there are M answers to &lt;code&gt;QH1&lt;/code&gt; and N answers to &lt;code&gt;QH2&lt;/code&gt;, the filter is run M*N times.</source>
          <target state="translated">この場合、フィルターは &lt;code&gt;QH1&lt;/code&gt; と &lt;code&gt;QH2&lt;/code&gt; に対する可能なすべての回答のペアに一度に1つずつ適用されます。Mの答えがある場合 &lt;code&gt;QH1&lt;/code&gt; へとNの答え &lt;code&gt;QH2&lt;/code&gt; は、フィルタはM * N回実行されます。</target>
        </trans-unit>
        <trans-unit id="28983b21b0ad9b5b9935ebfc53758651c434ba12" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;CTH&lt;/code&gt; can either be only the module name of the CTH or a tuple with the module name and the initial arguments, and optionally the hook priority of the CTH. For example, one of the following:</source>
          <target state="translated">この場合、 &lt;code&gt;CTH&lt;/code&gt; は、CTHのモジュール名のみ、またはモジュール名と初期引数を持つタプル、およびオプションでCTHのフック優先度のいずれかになります。たとえば、次のいずれかです。</target>
        </trans-unit>
        <trans-unit id="2a423ae0801e37198bf3643c083306bae6ec09bd" translate="yes" xml:space="preserve">
          <source>In this case, Compiler option &lt;code&gt;encrypt_debug_info&lt;/code&gt; can be used, see &lt;code&gt;compile(3)&lt;/code&gt;.</source>
          <target state="translated">この場合、コンパイラオプション &lt;code&gt;encrypt_debug_info&lt;/code&gt; を使用できます。compile &lt;code&gt;compile(3)&lt;/code&gt; 参照してください。</target>
        </trans-unit>
        <trans-unit id="5039f2c8ff05131bbbf56345b582c1ca63c2cd6b" translate="yes" xml:space="preserve">
          <source>In this case, all arguments but the first are ignored and the function simply returns the internal state again. This is enough if the code only has been extended. If instead the internal state is changed (similar to the example in &lt;code&gt;&lt;a href=&quot;#int_state&quot;&gt;Changing Internal State&lt;/a&gt;&lt;/code&gt;), this is done in this function and &lt;code&gt;{ok,Chs2}&lt;/code&gt; returned.</source>
          <target state="translated">この場合、最初の引数以外のすべての引数は無視され、関数は単に内部状態を再び返します。コードのみが拡張されている場合、これで十分です。代わりに、内部状態（の例と同様に変更された場合に &lt;code&gt;&lt;a href=&quot;#int_state&quot;&gt;Changing Internal State&lt;/a&gt;&lt;/code&gt; ）、これは、この機能で行われ、 &lt;code&gt;{ok,Chs2}&lt;/code&gt; 返されます。</target>
        </trans-unit>
        <trans-unit id="f725a21c435f46ea81fa484e58d3d41f8bd72bbc" translate="yes" xml:space="preserve">
          <source>In this case, one or more of &lt;code&gt;Expr1&lt;/code&gt;...&lt;code&gt;ExprK&lt;/code&gt; can be unbound variables.</source>
          <target state="translated">この場合、1つ以上の &lt;code&gt;Expr1&lt;/code&gt; ... &lt;code&gt;ExprK&lt;/code&gt; を非バインド変数にすることができます。</target>
        </trans-unit>
        <trans-unit id="bac5d4d9afdbed7a919ecd5845595a514ce50f9a" translate="yes" xml:space="preserve">
          <source>In this case, simple code replacement is not sufficient. The process must explicitly transform its state using the callback function &lt;code&gt;code_change&lt;/code&gt; before switching to the new version of the callback module. Thus, synchronized code replacement is used.</source>
          <target state="translated">この場合、単純なコード置換では不十分です。プロセスは、コールバックモジュールの新しいバージョンに切り替える前に、コールバック関数 &lt;code&gt;code_change&lt;/code&gt; を使用してその状態を明示的に変換する必要があります。したがって、同期コード置換が使用されます。</target>
        </trans-unit>
        <trans-unit id="4ec09095fe4b3a08fa08b2d3c7632c3ad498721e" translate="yes" xml:space="preserve">
          <source>In this case, simple code replacement is not sufficient. When a new version of a residence module for a special process is loaded, the process must make a fully qualified call to its loop function to switch to the new code. Thus, synchronized code replacement must be used.</source>
          <target state="translated">この場合、単純なコードの置き換えだけでは十分ではありません。特殊なプロセス用の新しいバージョンの居住モジュールがロードされたとき、プロセスは、新しいコードに切り替えるために、そのループ関数に完全修飾された呼び出しを行わなければなりません。したがって、同期化されたコード置換を使用しなければなりません。</target>
        </trans-unit>
        <trans-unit id="bbe74749660d0039c0abd21e49290ce19c250a20" translate="yes" xml:space="preserve">
          <source>In this case, the calling process is the shell, so the following result is received:</source>
          <target state="translated">この場合、呼び出し元のプロセスがシェルなので、以下のような結果になります。</target>
        </trans-unit>
        <trans-unit id="2cd85caaa1a6987f2340faefbd7babc9b4009f1f" translate="yes" xml:space="preserve">
          <source>In this case, the function must be exported from the module in question.</source>
          <target state="translated">この場合、関数は問題のモジュールからエクスポートされなければなりません。</target>
        </trans-unit>
        <trans-unit id="84ecff76d3518039bed69b56be3f5fe9f91bdb0c" translate="yes" xml:space="preserve">
          <source>In this case, the key &lt;code&gt;Key&lt;/code&gt; is returned, which can be used in a subsequent call to &lt;code&gt;&lt;a href=&quot;#yield-1&quot;&gt;yield/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#nb_yield-1&quot;&gt;nb_yield/1,2&lt;/a&gt;&lt;/code&gt; to retrieve the value of evaluating &lt;code&gt;apply(Module, Function, Args)&lt;/code&gt; on node &lt;code&gt;Node&lt;/code&gt;.</source>
          <target state="translated">この場合、キー &lt;code&gt;Key&lt;/code&gt; が返されます。これは、後続の &lt;code&gt;&lt;a href=&quot;#yield-1&quot;&gt;yield/1&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;#nb_yield-1&quot;&gt;nb_yield/1,2&lt;/a&gt;&lt;/code&gt; の呼び出しで使用して、ノード &lt;code&gt;Node&lt;/code&gt; で &lt;code&gt;apply(Module, Function, Args)&lt;/code&gt; を評価する値を取得できます。</target>
        </trans-unit>
        <trans-unit id="2ea0870da5814abd9a73cf1fe490942611b71d5e" translate="yes" xml:space="preserve">
          <source>In this case, the new state is the updated list of available channels &lt;code&gt;Chs2&lt;/code&gt;. The &lt;code&gt;gen_server&lt;/code&gt; is now ready for new requests.</source>
          <target state="translated">この場合、新しい状態は利用可能なチャネル &lt;code&gt;Chs2&lt;/code&gt; の更新されたリストです。これで、 &lt;code&gt;gen_server&lt;/code&gt; は新しい要求を受け入れる準備ができました。</target>
        </trans-unit>
        <trans-unit id="5aee58fc810702815e51808a51b2ab85c081aa01" translate="yes" xml:space="preserve">
          <source>In this case, the release handler framework with automatic packing and unpacking of release packages, automatic path updates, and so on, can be used without having to specify &lt;code&gt;.appup&lt;/code&gt; files.</source>
          <target state="translated">この場合、 &lt;code&gt;.appup&lt;/code&gt; ファイルを指定せずに、リリースパッケージの自動パックおよびアンパック、自動パス更新などを備えたリリースハンドラフレームワークを使用できます。</target>
        </trans-unit>
        <trans-unit id="a0046cd0df3cac4eb3b95dc96fc37ec106f64638" translate="yes" xml:space="preserve">
          <source>In this case, the reply is the allocated channel &lt;code&gt;Ch&lt;/code&gt; and the new state is the set of remaining available channels &lt;code&gt;Chs2&lt;/code&gt;.</source>
          <target state="translated">この場合、応答は割り当てられたチャネル &lt;code&gt;Ch&lt;/code&gt; であり、新しい状態は残りの使用可能なチャネル &lt;code&gt;Chs2&lt;/code&gt; のセットです。</target>
        </trans-unit>
        <trans-unit id="9574675a8f9e5418ebb839c426e998489f14ad76" translate="yes" xml:space="preserve">
          <source>In this case, the supervisor is not registered. Instead its pid must be used. A name can be specified by calling &lt;code&gt;supervisor:start_link({local, Name}, Module, Args)&lt;/code&gt; or &lt;code&gt;supervisor:start_link({global, Name}, Module, Args)&lt;/code&gt;.</source>
          <target state="translated">この場合、監督者は登録されていません。代わりに、そのpidを使用する必要があります。名前は、 &lt;code&gt;supervisor:start_link({local, Name}, Module, Args)&lt;/code&gt; &lt;code&gt;supervisor:start_link({global, Name}, Module, Args)&lt;/code&gt; ）またはsupervisor：start_link（{global、Name}、Module、Args ）を呼び出すことで指定できます。</target>
        </trans-unit>
        <trans-unit id="b6603f0a6951b192542ceb666e2c7f72b121f614" translate="yes" xml:space="preserve">
          <source>In this case, you free the two terms independently. The order in which you free the terms &lt;code&gt;ep&lt;/code&gt; and &lt;code&gt;ep2&lt;/code&gt; is not important, because the &lt;code&gt;Erl_Interface&lt;/code&gt; library uses reference counting to determine when it is safe to remove objects.</source>
          <target state="translated">この場合、2つの用語を個別に解放します。 &lt;code&gt;Erl_Interface&lt;/code&gt; ライブラリは参照カウントを使用してオブジェクトを安全に削除できる時期を判断するため、用語 &lt;code&gt;ep&lt;/code&gt; とep2を &lt;code&gt;ep2&lt;/code&gt; は重要ではありません。</target>
        </trans-unit>
        <trans-unit id="b0020e2468bc67c671f498f4e4e7457122f890ee" translate="yes" xml:space="preserve">
          <source>In this example consider the situation where you want to examine a particular data in the XML file. For instance, you want to check for how long each motorcycle have been recorded.</source>
          <target state="translated">この例では、XMLファイル内の特定のデータを調べたい場合を考えてみましょう。例えば、各バイクがどれくらいの時間記録されているかを調べたいとします。</target>
        </trans-unit>
        <trans-unit id="46a429a85cf2eee81ebe05e357ca0f926abafe9d" translate="yes" xml:space="preserve">
          <source>In this example the Pea application has been changed, and so are the applications ERTS, Kernel, STDLIB and SASL.</source>
          <target state="translated">この例では、Pea アプリケーションが変更され、ERTS、Kernel、STDLIB、SASL アプリケーションも変更されています。</target>
        </trans-unit>
        <trans-unit id="4298d6ba95bb1281780cd67a70e648391534cd1f" translate="yes" xml:space="preserve">
          <source>In this example the numbers are integers and the arguments in the functions in the code &lt;code&gt;N&lt;/code&gt;, &lt;code&gt;X&lt;/code&gt;, and &lt;code&gt;Y&lt;/code&gt; are called variables. Variables must start with a capital letter (see &lt;code&gt;Variables&lt;/code&gt;). Examples of variables are &lt;code&gt;Number&lt;/code&gt;, &lt;code&gt;ShoeSize&lt;/code&gt;, and &lt;code&gt;Age&lt;/code&gt;.</source>
          <target state="translated">この例では、数値は整数であり、コード &lt;code&gt;N&lt;/code&gt; 、 &lt;code&gt;X&lt;/code&gt; 、および &lt;code&gt;Y&lt;/code&gt; の関数の引数は変数と呼ばれます。変数は大文字で始める必要があります（ &lt;code&gt;Variables&lt;/code&gt; 参照）。変数の例は、 &lt;code&gt;Number&lt;/code&gt; 、 &lt;code&gt;ShoeSize&lt;/code&gt; 、および &lt;code&gt;Age&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="00141d9820384d0fe96047499c682c85df54a263" translate="yes" xml:space="preserve">
          <source>In this example we first create a new cons cell with an integer and a tuple with some text. Then a tuple of size three wrapping the other values with an atom tag is created and returned.</source>
          <target state="translated">この例では、まず整数とテキストを含むタプルで新しいconsセルを作成します。そして、他の値をアトムタグで包んだサイズ3のタプルが作成され、返されます。</target>
        </trans-unit>
        <trans-unit id="f86bfad372e7bf0f313f5d6b081512cd31ba5a67" translate="yes" xml:space="preserve">
          <source>In this example you walk through a list &quot;carrying&quot; a value, in this case &lt;code&gt;Result_so_far&lt;/code&gt;. &lt;code&gt;list_max/1&lt;/code&gt; simply assumes that the max value of the list is the head of the list and calls &lt;code&gt;list_max/2&lt;/code&gt; with the rest of the list and the value of the head of the list. In the above this would be &lt;code&gt;list_max([2,3,4,5,7,4,3,2,1],1)&lt;/code&gt;. If you tried to use &lt;code&gt;list_max/1&lt;/code&gt; with an empty list or tried to use it with something that is not a list at all, you would cause an error. Notice that the Erlang philosophy is not to handle errors of this type in the function they occur, but to do so elsewhere. More about this later.</source>
          <target state="translated">この例では、値を保持するリスト（この場合は &lt;code&gt;Result_so_far&lt;/code&gt; )をウォークスルーします。 &lt;code&gt;list_max/1&lt;/code&gt; は、リストの最大値がリストの先頭であると単純に想定し、リストの残りの部分とリストの先頭の値で &lt;code&gt;list_max/2&lt;/code&gt; を呼び出します。上記の場合、これは &lt;code&gt;list_max([2,3,4,5,7,4,3,2,1],1)&lt;/code&gt; ます。あなたが使用しようとした場合 &lt;code&gt;list_max/1&lt;/code&gt; を空のリスト、またはすべてのリストではありません何かでそれを使用しようとしました、あなたは、エラーが発生します。 Erlangの哲学は、発生する関数でこのタイプのエラーを処理することではなく、他の場所で処理することに注意してください。これについては後で詳しく説明します。</target>
        </trans-unit>
        <trans-unit id="56448ac7090741dff16bd4c666efd111e9722e23" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;suite/0&lt;/code&gt; tells &lt;code&gt;Common Test&lt;/code&gt; to suppress printouts from Telnet and SSH connections. This is valid for all test cases. However, &lt;code&gt;my_testcase1/0&lt;/code&gt; specifies that for this test case, only SSH is to be silent. The result is that &lt;code&gt;my_testcase1&lt;/code&gt; gets Telnet information (if any) printed in the log, but not SSH information. &lt;code&gt;my_testcase2&lt;/code&gt; gets no information from either connection printed.</source>
          <target state="translated">この例では、 &lt;code&gt;suite/0&lt;/code&gt; はTelnetおよびSSH接続からの印刷を抑制するように &lt;code&gt;Common Test&lt;/code&gt; に指示しています。これはすべてのテストケースに有効です。ただし、 &lt;code&gt;my_testcase1/0&lt;/code&gt; は、このテストケースではSSHのみがサイレントになることを指定します。その結果、 &lt;code&gt;my_testcase1&lt;/code&gt; はTelnet情報（ある場合）をログに出力しますが、SSH情報は取得しません。 &lt;code&gt;my_testcase2&lt;/code&gt; は、どちらの接続からも情報を取得しません。</target>
        </trans-unit>
        <trans-unit id="f2f906325545f1417f1e6e7ea85883ce6305f126" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;{Pid, Something}&lt;/code&gt; is received.</source>
          <target state="translated">この例では、 &lt;code&gt;{Pid, Something}&lt;/code&gt; が受信されます。</target>
        </trans-unit>
        <trans-unit id="9978d9c124f3a9ceaa1001295460a53442590274" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;{Pid, Something}&lt;/code&gt; is received. The received pid is then used to return &lt;code&gt;{goodbye,Pid}&lt;/code&gt;.</source>
          <target state="translated">この例では、 &lt;code&gt;{Pid, Something}&lt;/code&gt; が受信されます。次に、受け取ったpidを使用して &lt;code&gt;{goodbye,Pid}&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="b8cca447955be1a950232a8170dee175e96b1885" translate="yes" xml:space="preserve">
          <source>In this example, a series of bytes is received from an external source and the bytes are then decoded into a valid Erlang term. This was achieved with the call &lt;code&gt;'People':decode('Person',Bytes)&lt;/code&gt;, which returned an Erlang value of the ASN.1 type &lt;code&gt;Person&lt;/code&gt;. Then an answer was constructed and encoded using &lt;code&gt;'People':encode('Person',Answer)&lt;/code&gt;, which takes an instance of a defined ASN.1 type and transforms it to a binary according to the BER or PER encoding rules.</source>
          <target state="translated">この例では、一連のバイトが外部ソースから受信され、バイトは有効なErlang用語にデコードされます。これは、ASN.1タイプの &lt;code&gt;Person&lt;/code&gt; の Erlang値を返す呼び出し &lt;code&gt;'People':decode('Person',Bytes)&lt;/code&gt; で実現されました。次に、回答が作成され、 &lt;code&gt;'People':encode('Person',Answer)&lt;/code&gt; を使用してエンコードされます。これは、定義されたASN.1タイプのインスタンスを取得し、BERまたはPERエンコーディングルールに従ってバイナリに変換します。</target>
        </trans-unit>
        <trans-unit id="5e2e0fa61e63c35e50233a9616eb00e4ea0cac5e" translate="yes" xml:space="preserve">
          <source>In this example, a tracer module with a NIF back end sends a message for each &lt;code&gt;send&lt;/code&gt; trace tag containing only the sender and receiver. Using this tracer module, a much more lightweight message tracer is used, which only records who sent messages to who.</source>
          <target state="translated">この例では、NIFバックエンドを備えたトレーサーモジュールが、送信者と受信者のみを含む &lt;code&gt;send&lt;/code&gt; トレースタグごとにメッセージを送信します。このトレーサモジュールを使用すると、はるかに軽量なメッセージトレーサが使用され、誰が誰にメッセージを送信したかが記録されます。</target>
        </trans-unit>
        <trans-unit id="6d8dde7ce6106260a6067f905d420de2cd6f2ca5" translate="yes" xml:space="preserve">
          <source>In this example, an Erlang runtime system is started with environment variable &lt;code&gt;DISPLAY&lt;/code&gt; set to &lt;code&gt;gin:0&lt;/code&gt;.</source>
          <target state="translated">この例では、Erlangランタイムシステムは、環境変数 &lt;code&gt;DISPLAY&lt;/code&gt; を &lt;code&gt;gin:0&lt;/code&gt; に設定して起動されます。</target>
        </trans-unit>
        <trans-unit id="c3b7e2dc3ec86592b2c4fe3d4be281594efc1a2e" translate="yes" xml:space="preserve">
          <source>In this example, an attempt was made to output the single character 65 with the aid of the string formatting directive &lt;code&gt;&quot;~s&quot;&lt;/code&gt;.</source>
          <target state="translated">この例では、文字列フォーマットディレクティブ &lt;code&gt;&quot;~s&quot;&lt;/code&gt; 〜s &quot;を使用して、1文字65を出力しようとしました。</target>
        </trans-unit>
        <trans-unit id="43586affa45b8e696e51f04b01e7960b0c11c14b" translate="yes" xml:space="preserve">
          <source>In this example, any user tag set in the calling process will be spread to the I/O-server when the io:format call is done.</source>
          <target state="translated">この例では、呼び出しプロセスで設定されたユーザタグは、io:format呼び出しが完了するとI/O-serverに拡散されます。</target>
        </trans-unit>
        <trans-unit id="66bc53b66445d9e9e48935dda092b0ae0570b399" translate="yes" xml:space="preserve">
          <source>In this example, each runtime system have two schedulers each online, and all schedulers online will run on different cores. If we change to one scheduler online on one runtime system, and three schedulers online on the other, all schedulers online will still run on different cores.</source>
          <target state="translated">この例では、各ランタイムシステムは2つのスケジューラをオンラインにしており、オンラインのスケジューラはすべて異なるコアで実行されます。一方のランタイムシステムで1つのスケジューラをオンラインにし、もう一方のランタイムシステムで3つのスケジューラをオンラインにしても、オンラインのスケジューラはすべて異なるコア上で実行されます。</target>
        </trans-unit>
        <trans-unit id="7ecf9ae27bd24989b3021f8b4c4bfca0ad2ceaf5" translate="yes" xml:space="preserve">
          <source>In this example, function &lt;code&gt;terminate/3&lt;/code&gt; locks the door if it is open, so we do not accidentally leave the door open when the supervision tree terminates:</source>
          <target state="translated">この例では、関数 &lt;code&gt;terminate/3&lt;/code&gt; はドアが開いている場合にドアをロックします。そのため、監視ツリーの終了時にドアを誤って開いたままにしないでください。</target>
        </trans-unit>
        <trans-unit id="960ac5061c7b8584acad2089c9295c51aa2f8869" translate="yes" xml:space="preserve">
          <source>In this example, if the first element had been the key, it is much more efficient to match that key in the &lt;code&gt;MatchHead&lt;/code&gt; part than in the &lt;code&gt;MatchConditions&lt;/code&gt; part. The search space of the tables is restricted with regards to the &lt;code&gt;MatchHead&lt;/code&gt; so that only objects with the matching key are searched.</source>
          <target state="translated">最初の要素が鍵となっていた場合は、この例では、それはで、そのキーと一致するようにはるかに効率的である &lt;code&gt;MatchHead&lt;/code&gt; の中より一部 &lt;code&gt;MatchConditions&lt;/code&gt; 一部を。テーブルの検索スペースは &lt;code&gt;MatchHead&lt;/code&gt; に関して制限されているため、一致するキーを持つオブジェクトのみが検索されます。</target>
        </trans-unit>
        <trans-unit id="434bd6540f3c6df5778ba2e32f9a39db0be5e9d8" translate="yes" xml:space="preserve">
          <source>In this example, instead of ignoring button events while in the &lt;code&gt;open&lt;/code&gt; state, we can postpone them and they are queued and later handled in the &lt;code&gt;locked&lt;/code&gt; state:</source>
          <target state="translated">この例では、 &lt;code&gt;open&lt;/code&gt; 状態のときにボタンイベントを無視する代わりに、ボタンのイベントを延期してキューに入れ、後で &lt;code&gt;locked&lt;/code&gt; 状態で処理することができます。</target>
        </trans-unit>
        <trans-unit id="bf50f8222a786a9423d6bbc25bbbef0a7253d10d" translate="yes" xml:space="preserve">
          <source>In this example, the following actions are performed:</source>
          <target state="translated">この例では、以下の動作を行います。</target>
        </trans-unit>
        <trans-unit id="dfa0e603f6362ff9bd3405f39acb715fb921e826" translate="yes" xml:space="preserve">
          <source>In this example, the same ASN.1 specification as in Section &lt;code&gt;&lt;a href=&quot;#Asn1spec&quot;&gt;Writing an Exclusive Decode Instruction&lt;/a&gt;&lt;/code&gt; is used. The following is a valid selective decode instruction:</source>
          <target state="translated">この例では、セクション &lt;code&gt;&lt;a href=&quot;#Asn1spec&quot;&gt;Writing an Exclusive Decode Instruction&lt;/a&gt;&lt;/code&gt; と同じASN.1仕様が使用されています。以下は、有効な選択的デコード命令です。</target>
        </trans-unit>
        <trans-unit id="e3527cbb7e8c4dd557e4aee1d0751b68ffeeff64" translate="yes" xml:space="preserve">
          <source>In this example, the test terms defined in files &quot;b.spec&quot; and &quot;c.spec&quot; are joined with the terms in source specification &quot;a.spec&quot; (if any). The inclusion of specifications &quot;d.spec&quot; and &quot;e.spec&quot; results in two separate, and independent, test runs (one for each included specification).</source>
          <target state="translated">この例では、ファイル &quot;b.spec &quot;および &quot;c.spec &quot;で定義されたテスト用語は、ソース仕様 &quot;a.spec &quot;の用語と結合されています(もしあれば)。仕様「d.spec」と「e.spec」を含めると、2 つの独立したテスト実行が行われます(含まれる仕様ごとに 1 回ずつ)。</target>
        </trans-unit>
        <trans-unit id="591e558504b589362aa8ec521cf9d41254ba089c" translate="yes" xml:space="preserve">
          <source>In this example, we chose to copy the binary content before inserting it in &lt;code&gt;gb_sets:set()&lt;/code&gt; if it references a binary more than twice the data size we want to keep. Of course, different rules apply when copying to different programs.</source>
          <target state="translated">この例では、保持したいデータサイズの2倍を超えるバイナリを参照する場合、 &lt;code&gt;gb_sets:set()&lt;/code&gt; に挿入する前にバイナリコンテンツをコピーすることを選択しました。もちろん、異なるプログラムにコピーする場合、異なるルールが適用されます。</target>
        </trans-unit>
        <trans-unit id="dc86ae4cb1275e535c2e78420e2da7f468d13800" translate="yes" xml:space="preserve">
          <source>In this example, we in put the 'diffie-hellman-group1-sha1' first and also move the &lt;code&gt;'ecdh-sha2-nistp521'&lt;/code&gt; to the end in the kex list, that is, &lt;code&gt;append&lt;/code&gt; it.</source>
          <target state="translated">この例では、「diffie-hellman-group1-sha1」を最初に配置し、 &lt;code&gt;'ecdh-sha2-nistp521'&lt;/code&gt; をkexリストの末尾に移動、つまり &lt;code&gt;append&lt;/code&gt; します。</target>
        </trans-unit>
        <trans-unit id="0bbaf70ab3110bc7a5e89c28c21c815ba1de5783" translate="yes" xml:space="preserve">
          <source>In this example, we use both options (&lt;code&gt;preferred_algorithms&lt;/code&gt; and &lt;code&gt;modify_algorithms&lt;/code&gt;) and also try to prepend an unsupported algorithm. Any unsupported algorithm is quietly removed.</source>
          <target state="translated">この例では、両方のオプション（ &lt;code&gt;preferred_algorithms&lt;/code&gt; および &lt;code&gt;modify_algorithms&lt;/code&gt; ）を使用し、サポートされていないアルゴリズムを付加することも試みます。サポートされていないアルゴリズムは静かに削除されます。</target>
        </trans-unit>
        <trans-unit id="ee5453691e19483eb4be3db95d70cb64c5c4684a" translate="yes" xml:space="preserve">
          <source>In this examples, the definitions from the following ASN.1 specification are used:</source>
          <target state="translated">本例では、以下のASN.1仕様の定義を使用しています。</target>
        </trans-unit>
        <trans-unit id="3b6a8f84b986da01a683c86c723aa87e5db42995" translate="yes" xml:space="preserve">
          <source>In this following example, the password is &lt;code&gt;&quot;abcd1234&quot;&lt;/code&gt;:</source>
          <target state="translated">次の例では、パスワードは &lt;code&gt;&quot;abcd1234&quot;&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="ef1f632c9246a97f789f4334b5d6c5e381fbdc5d" translate="yes" xml:space="preserve">
          <source>In this mode the following can be done:</source>
          <target state="translated">このモードでは、以下のようなことができます。</target>
        </trans-unit>
        <trans-unit id="994fd4fb79d55c888264214dbe057f79d04e488e" translate="yes" xml:space="preserve">
          <source>In this module, V is allowed to be empty. The so obtained unique digraph is called the &lt;strong id=&quot;empty_digraph&quot;&gt;empty digraph&lt;/strong&gt;. Both vertices and edges are represented by unique Erlang terms.</source>
          <target state="translated">このモジュールでは、Vを空にすることができます。このようにして得られた固有の有向グラフは、&lt;strong id=&quot;empty_digraph&quot;&gt;空の有向グラフ&lt;/strong&gt;と呼ばれます。頂点とエッジの両方が一意のErlang用語で表されます。</target>
        </trans-unit>
        <trans-unit id="712d363aaa0e39c08276d452dd321570bc580bff" translate="yes" xml:space="preserve">
          <source>In this module, the only families that are considered are families of subsets of some set X; in the following, the word &quot;family&quot; is used for such families of subsets.</source>
          <target state="translated">このモジュールでは、考慮されるのはある集合Xの部分集合の家族だけです。</target>
        </trans-unit>
        <trans-unit id="9df8795a77ab5095acba5e23497d16dae8d5c2f4" translate="yes" xml:space="preserve">
          <source>In this particular case we do not need to cancel the time-out since the time-out event is the only possible reason to do a &lt;strong&gt;state change&lt;/strong&gt; from &lt;code&gt;open&lt;/code&gt; to &lt;code&gt;locked&lt;/code&gt;.</source>
          <target state="translated">この特定のケースでは、タイムアウトタイムアウトイベントを行うための唯一の可能な理由であるため、キャンセルする必要はありません&lt;strong&gt;、状態の変化を&lt;/strong&gt;より &lt;code&gt;open&lt;/code&gt; に &lt;code&gt;locked&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e66b7cabeee4a12f3d6c96b7b3841a688c3bd15c" translate="yes" xml:space="preserve">
          <source>In this particular case we do not need to cancel the timeout since the timeout event is the only possible reason to change the state from &lt;code&gt;open&lt;/code&gt; to &lt;code&gt;locked&lt;/code&gt;.</source>
          <target state="translated">この特定のケースでは、タイムアウトイベントが状態を &lt;code&gt;open&lt;/code&gt; から &lt;code&gt;locked&lt;/code&gt; に変更する唯一の理由であるため、タイムアウトをキャンセルする必要はありません。</target>
        </trans-unit>
        <trans-unit id="b6554cfbd72e76e1ac3cdf9960a6f08456669452" translate="yes" xml:space="preserve">
          <source>In this particular case, command &lt;code&gt;i&lt;/code&gt; (&quot;interrupt&quot;) terminates the looping program, and command &lt;code&gt;c&lt;/code&gt; connects to the shell again. As the process was running in the background before we killed it, more printouts occur before message &quot;&lt;code&gt;** exception exit: killed&lt;/code&gt;&quot; is shown.</source>
          <target state="translated">この特定のケースでは、コマンド &lt;code&gt;i&lt;/code&gt; （「割り込み」）はループプログラムを終了し、コマンド &lt;code&gt;c&lt;/code&gt; は再びシェルに接続します。プロセスを強制終了する前にプロセスがバックグラウンドで実行されていたため、メッセージ &quot; &lt;code&gt;** exception exit: killed&lt;/code&gt; &quot;が表示される前に、さらに多くの出力が行われます。</target>
        </trans-unit>
        <trans-unit id="a202e49451669337a36807112b38f9adf4744b69" translate="yes" xml:space="preserve">
          <source>In this scenario the lock that protects ets-table &lt;code&gt;mnesia_transient_decision&lt;/code&gt; has spent most of its waiting for. That is 1.8 seconds in a test that run for 60 seconds. The time is also spread on eight different scheduler threads.</source>
          <target state="translated">このシナリオでは、ets-table &lt;code&gt;mnesia_transient_decision&lt;/code&gt; を保護するロックが待機のほとんどを費やしています。これは、60秒間実行されるテストでは1.8秒です。時間は、8つの異なるスケジューラスレッドにも分散されます。</target>
        </trans-unit>
        <trans-unit id="861466576140ad1635f300aa485a4cde311c192e" translate="yes" xml:space="preserve">
          <source>In this section a &lt;code&gt;Domain&lt;/code&gt; field is the transport domain i.e one of &lt;code&gt;transportDomainUdpIpv4&lt;/code&gt; or &lt;code&gt;transportDomainUdpIpv6&lt;/code&gt;, and an &lt;code&gt;Addr&lt;/code&gt; field is an &lt;code&gt;{&lt;/code&gt;&lt;code&gt;IpAddr&lt;/code&gt;&lt;code&gt;,IpPort}&lt;/code&gt; tuple.</source>
          <target state="translated">このセクションでは、 &lt;code&gt;Domain&lt;/code&gt; フィールドはトランスポートドメイン、つまり、 &lt;code&gt;transportDomainUdpIpv4&lt;/code&gt; または &lt;code&gt;transportDomainUdpIpv6&lt;/code&gt; の 1つであり、 &lt;code&gt;Addr&lt;/code&gt; フィールドは &lt;code&gt;{&lt;/code&gt; &lt;code&gt;IpAddr&lt;/code&gt; &lt;code&gt;,IpPort}&lt;/code&gt; タプルです。</target>
        </trans-unit>
        <trans-unit id="8408871bf44d5f19fd252aea95c29bc2e768f170" translate="yes" xml:space="preserve">
          <source>In this section an &lt;code&gt;Address&lt;/code&gt; field is a &lt;code&gt;{Domain, Addr}&lt;/code&gt; tuple where &lt;code&gt;Domain&lt;/code&gt; is &lt;code&gt;transportDomainUdpIpv4&lt;/code&gt; or &lt;code&gt;transportDomainUdpIpv4&lt;/code&gt;, and &lt;code&gt;Addr&lt;/code&gt; is an &lt;code&gt;{&lt;/code&gt;&lt;code&gt;IpAddr&lt;/code&gt;&lt;code&gt;,IpPort}&lt;/code&gt; tuple.</source>
          <target state="translated">このセクションでは、 &lt;code&gt;Address&lt;/code&gt; フィールドは &lt;code&gt;{Domain, Addr}&lt;/code&gt; タプルであり、 &lt;code&gt;Domain&lt;/code&gt; は &lt;code&gt;transportDomainUdpIpv4&lt;/code&gt; または &lt;code&gt;transportDomainUdpIpv4&lt;/code&gt; で、 &lt;code&gt;Addr&lt;/code&gt; は &lt;code&gt;{&lt;/code&gt; &lt;code&gt;IpAddr&lt;/code&gt; &lt;code&gt;,IpPort}&lt;/code&gt; タプルです。</target>
        </trans-unit>
        <trans-unit id="99f63d92bf0f7c0a3f35d120e4d7baace3952b21" translate="yes" xml:space="preserve">
          <source>In this section, all valid Erlang expressions are listed. When writing Erlang programs, it is also allowed to use macro- and record expressions. However, these expressions are expanded during compilation and are in that sense not true Erlang expressions. Macro- and record expressions are covered in separate sections:</source>
          <target state="translated">このセクションでは、すべての有効なErlang式をリストアップしています。Erlangプログラムを書くとき、マクロやレコード式を使うこともできます。しかし、これらの式はコンパイル時に展開されるので、真のErlang式ではありません。マクロ式とレコード式については別のセクションで説明します。</target>
        </trans-unit>
        <trans-unit id="7b4d3e5b6a78745c8c43082e99a7d0df32dc4509" translate="yes" xml:space="preserve">
          <source>In this section, it is assumed that the username is &lt;code&gt;otpuser&lt;/code&gt; and that the home directory of that user is:</source>
          <target state="translated">このセクションでは、ユーザー名は &lt;code&gt;otpuser&lt;/code&gt; であり、そのユーザーのホームディレクトリは次のとおりであると想定しています。</target>
        </trans-unit>
        <trans-unit id="d8badf52dbf4567555546e910013615a3db3a8dd" translate="yes" xml:space="preserve">
          <source>In this section, the following terminology is used:</source>
          <target state="translated">本項では、以下のような用語を使用しています。</target>
        </trans-unit>
        <trans-unit id="7a8d09dba986cc4a1cce2aa142a6efb735508b29" translate="yes" xml:space="preserve">
          <source>In this simple case, the former expression is probably preferable in terms of readability.</source>
          <target state="translated">この単純なケースでは、読みやすさの点で前者の表現の方が好ましいのではないでしょうか。</target>
        </trans-unit>
        <trans-unit id="26a9a0725bf356efe21e2e59d7c4c0fd0009aece" translate="yes" xml:space="preserve">
          <source>In this way you can connect all processes in a transaction together using links. If one of the processes exits abnormally, all the processes in the transaction are killed. As it is often wanted to create a process and link to it at the same time, there is a special BIF, &lt;code&gt;spawn_link&lt;/code&gt; that does the same as &lt;code&gt;spawn&lt;/code&gt;, but also creates a link to the spawned process.</source>
          <target state="translated">このようにして、リンクを使用してトランザクション内のすべてのプロセスを一緒に接続できます。プロセスの1つが異常終了すると、トランザクション内のすべてのプロセスが強制終了されます。多くの場合、同時にそれまでのプロセスとのリンクを作成するために望まれているとして、そこに特別なBIF、ある &lt;code&gt;spawn_link&lt;/code&gt; と同じこと &lt;code&gt;spawn&lt;/code&gt; 、だけでなく、生成されたプロセスへのリンクを作成します。</target>
        </trans-unit>
        <trans-unit id="04cd30a6181cf29b11e39620fc1e71c03e622ab5" translate="yes" xml:space="preserve">
          <source>In those circumstances, &lt;code&gt;$REFRESH_GEN_DEST()&lt;/code&gt; must be invoked to set up the pointer again. &lt;strong&gt;beam_makeops&lt;/strong&gt; will notice if there is a call to a function that does a garbage collection and &lt;code&gt;$REFRESH_GEN_DEST()&lt;/code&gt; is not called.</source>
          <target state="translated">そのような状況で &lt;code&gt;$REFRESH_GEN_DEST()&lt;/code&gt; 、ポインタを再設定するために$ REFRSH_GEN_DEST（）を呼び出す必要があります。&lt;strong&gt;beam_makeops&lt;/strong&gt;は、ガベージコレクションを実行する関数が呼び出され、 &lt;code&gt;$REFRESH_GEN_DEST()&lt;/code&gt; が呼び出されていない場合に通知します。</target>
        </trans-unit>
        <trans-unit id="12987c6a024d031823b3213c0fb06e759b8cd0bf" translate="yes" xml:space="preserve">
          <source>In those functions the internal crypto state is first created and initialized with the cipher type, the key and possibly other data. Then the single binary is encrypted or decrypted, the crypto state is de-allocated and the result of the crypto operation is returned.</source>
          <target state="translated">これらの関数では、まず内部の暗号化状態が作成され、暗号化タイプ、鍵、その他のデータで初期化される。その後、単一バイナリが暗号化または復号化され、暗号化状態が解除され、暗号化処理の結果が返されます。</target>
        </trans-unit>
        <trans-unit id="101b35ccce64e2d00c7201dde3bdfc7472ddac0c" translate="yes" xml:space="preserve">
          <source>In traditional relational database terminology, this operation is called a selection, followed by a projection.</source>
          <target state="translated">伝統的なリレーショナルデータベースの用語では、この操作は選択と呼ばれ、その後に投影が続きます。</target>
        </trans-unit>
        <trans-unit id="1ec3c1eab704912540b1a90c690dfcb4bdf6cc6e" translate="yes" xml:space="preserve">
          <source>In type &lt;code&gt;StartMessage&lt;/code&gt;, the constraint following field &lt;code&gt;content&lt;/code&gt; tells that in a value of type &lt;code&gt;StartMessage&lt;/code&gt; the value in field &lt;code&gt;content&lt;/code&gt; must come from the same object that is chosen by field &lt;code&gt;msgId&lt;/code&gt;.</source>
          <target state="translated">タイプ &lt;code&gt;StartMessage&lt;/code&gt; では、フィールド &lt;code&gt;content&lt;/code&gt; に続く制約は、タイプ &lt;code&gt;StartMessage&lt;/code&gt; の値では、フィールド &lt;code&gt;content&lt;/code&gt; の値がフィールド &lt;code&gt;msgId&lt;/code&gt; で選択された同じオブジェクトから取得される必要があることを示します。</target>
        </trans-unit>
        <trans-unit id="3258ab5defec1c2d9288e54d368e065797c6dfc5" translate="yes" xml:space="preserve">
          <source>In version 3 of the megaco standard the Segmentation package was introduced. Simply, this package defines a procedure to segment megaco messages (transaction replies) when using a transport that does not automatically do this (e.g. UDP). See also &lt;code&gt;&lt;a href=&quot;megaco_encode#handling_versions&quot;&gt;version3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">megaco標準のバージョン3では、セグメンテーションパッケージが導入されました。簡単に言うと、このパッケージは、これを自動的に行わないトランスポート（UDPなど）を使用するときに、megacoメッセージ（トランザクション応答）をセグメント化する手順を定義します。 &lt;code&gt;&lt;a href=&quot;megaco_encode#handling_versions&quot;&gt;version3&lt;/a&gt;&lt;/code&gt; も参照してください。</target>
        </trans-unit>
        <trans-unit id="63b6f2d5cd37bdba6df81460e958046ee197cfa0" translate="yes" xml:space="preserve">
          <source>In version 3 of the megaco standard, the concept of &lt;code&gt;segmentation package&lt;/code&gt; was introduced. Simply, this package defines a procedure to segment megaco messages (transaction replies) when using a transport that does not automatically do this (e.g. UDP). See also &lt;code&gt;&lt;a href=&quot;megaco_encode#handling_versions&quot;&gt;version3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">megaco標準のバージョン3では、 &lt;code&gt;segmentation package&lt;/code&gt; の概念が導入されました。簡単に言うと、このパッケージは、これを自動的に行わないトランスポート（UDPなど）を使用するときに、megacoメッセージ（トランザクション応答）をセグメント化する手順を定義します。 &lt;code&gt;&lt;a href=&quot;megaco_encode#handling_versions&quot;&gt;version3&lt;/a&gt;&lt;/code&gt; も参照してください。</target>
        </trans-unit>
        <trans-unit id="61a1a66fb7d34cc42d2ce16b8d6f94cde6e973d3" translate="yes" xml:space="preserve">
          <source>In which OTP version was &lt;code&gt;kernel-3.0&lt;/code&gt; introduced?</source>
          <target state="translated">&lt;code&gt;kernel-3.0&lt;/code&gt; はどのOTPバージョンで導入されましたか？</target>
        </trans-unit>
        <trans-unit id="8c5125d1b5f67d94423a5e620a14a0a6f8eab1be" translate="yes" xml:space="preserve">
          <source>In your own trace handler function, call &lt;code&gt;erlang:display/1&lt;/code&gt; instead of an &lt;code&gt;io&lt;/code&gt; function or, if &lt;code&gt;user&lt;/code&gt; is not used as group leader, print to &lt;code&gt;user&lt;/code&gt; instead of the default group leader. Example: &lt;code&gt;io:format(user,Str,Args)&lt;/code&gt;.</source>
          <target state="translated">独自のトレースハンドラー関数で、 &lt;code&gt;io&lt;/code&gt; 関数の代わりに &lt;code&gt;erlang:display/1&lt;/code&gt; を呼び出すか、 &lt;code&gt;user&lt;/code&gt; がグループリーダーとして使用されていない場合は、デフォルトのグループリーダーではなく &lt;code&gt;user&lt;/code&gt; に出力します。例： &lt;code&gt;io:format(user,Str,Args)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bd3623c7af3873c7365b3e9ecec792ba6339bafc" translate="yes" xml:space="preserve">
          <source>Inband-Security-Id AVP</source>
          <target state="translated">インバンドセキュリティアイディーエーブイピー</target>
        </trans-unit>
        <trans-unit id="1fcccda86c3d18620423152a36c25cd6e0ea26b2" translate="yes" xml:space="preserve">
          <source>Inband-Security-Id AVP (code 299)</source>
          <target state="translated">インバンドセキュリティ ID AVP (コード 299)</target>
        </trans-unit>
        <trans-unit id="bc29841cf89dc194cd8a81695be51412c487f1e5" translate="yes" xml:space="preserve">
          <source>Inband-Security-Id defaults to the empty list, which is equivalent to a list containing only 0 (NO_INBAND_SECURITY). If 1 (TLS) is specified then TLS is selected if the CER/CEA received from the peer offers it.</source>
          <target state="translated">これは、0(NO_INBAND_SECURITY)のみを含むリストと同等である。1 (TLS)が指定された場合、ピアから受信した CER/CEA がそれを提供している場合、TLS が選択されます。</target>
        </trans-unit>
        <trans-unit id="68aefeb8f958a940e3df275c2e8ab565491e5d57" translate="yes" xml:space="preserve">
          <source>Inbound binary encoding in binaries</source>
          <target state="translated">バイナリでのインバウンドバイナリエンコーディング</target>
        </trans-unit>
        <trans-unit id="d56147eef88de9f893558ccd93afaeb646d97eb3" translate="yes" xml:space="preserve">
          <source>Inbound percent-encoding in lists and binaries</source>
          <target state="translated">リストとバイナリにおけるインバウンドのパーセンテージエンコーディング</target>
        </trans-unit>
        <trans-unit id="4299e563cfdb9c828cf33fe283405a0895b02723" translate="yes" xml:space="preserve">
          <source>Incidentally, when the test case is corrected a bug in &lt;code&gt;channel&lt;/code&gt; should indeed be discovered.</source>
          <target state="translated">ちなみに、テストケースを修正すると、 &lt;code&gt;channel&lt;/code&gt; バグが実際に発見されます。</target>
        </trans-unit>
        <trans-unit id="8d1177bed65615f7e3e96bb2bc20a45bf85a59a4" translate="yes" xml:space="preserve">
          <source>Include &lt;code&gt;dir&lt;/code&gt; in the path for Erlang. This is useful when analyzing files that have &lt;code&gt;-include_lib()&lt;/code&gt; directives.</source>
          <target state="translated">Erlangのパスに &lt;code&gt;dir&lt;/code&gt; を含めます。これは、 &lt;code&gt;-include_lib()&lt;/code&gt; ディレクティブを持つファイルを分析するときに役立ちます。</target>
        </trans-unit>
        <trans-unit id="cae53151741eb56a1003fee69921d65824bcd040" translate="yes" xml:space="preserve">
          <source>Include Directories and Macro Definitions</source>
          <target state="translated">ディレクトリとマクロ定義を含める</target>
        </trans-unit>
        <trans-unit id="0e9d42f8b8c943f9e74d7049cab7a4c9266e260a" translate="yes" xml:space="preserve">
          <source>Include directories can also be specified in test specifications, see &lt;code&gt;&lt;a href=&quot;#test_specifications&quot;&gt;Test Specifications&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">ディレクトリも参照、テスト仕様書で指定することができます含める &lt;code&gt;&lt;a href=&quot;#test_specifications&quot;&gt;Test Specifications&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dc0da023e49fc7b9722125176291007176551c43" translate="yes" xml:space="preserve">
          <source>Include file</source>
          <target state="translated">インクルードファイル</target>
        </trans-unit>
        <trans-unit id="1be005482133f6ba0ad7a717822aee960ab1bc89" translate="yes" xml:space="preserve">
          <source>Include files are typically used for record and macro definitions that are shared by several modules. It is recommended to use the file name extension &lt;code&gt;.hrl&lt;/code&gt; for include files.</source>
          <target state="translated">インクルードファイルは通常、複数のモジュールで共有されるレコードとマクロの定義に使用されます。インクルードファイルには、ファイル名拡張子 &lt;code&gt;.hrl&lt;/code&gt; を使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="6ec71a4f09bb1029d3d4fb8244b9d00627d2bcc0" translate="yes" xml:space="preserve">
          <source>Include the correct tool's include file</source>
          <target state="translated">正しいツールのインクルードファイルをインクルードする</target>
        </trans-unit>
        <trans-unit id="44d2f9132c06fd784b8209fba5bb20aa3ee8c4fa" translate="yes" xml:space="preserve">
          <source>Include the token text in the token annotation. The text is the part of the input corresponding to the token.</source>
          <target state="translated">トークン注釈にトークンのテキストを含めます。テキストは、トークンに対応する入力の部分です。</target>
        </trans-unit>
        <trans-unit id="1318cfcd94087f09bec8c0a46a0ba00bc818ff6b" translate="yes" xml:space="preserve">
          <source>Include warnings for function calls that ignore a structured return value or do not match against one of many possible return value(s).</source>
          <target state="translated">構造化された戻り値を無視したり、多くの可能性のある戻り値のうちの1つと一致しない関数呼び出しに対する警告を含めました。</target>
        </trans-unit>
        <trans-unit id="b72333c2c10be7a2ac2a052bd2a51691c99a5707" translate="yes" xml:space="preserve">
          <source>Include warnings for function calls that ignore a structured return value or do not match against one of many possible return values. However, no warnings are included if the possible return values are a union of atoms or a union of numbers.</source>
          <target state="translated">構造化された戻り値を無視したり、多くの可能な戻り値のうちの1つと一致しない関数呼び出しに対する警告を含めます。ただし、戻り値の可能性がある値が原子の和または数の和である場合は警告は含まれません。</target>
        </trans-unit>
        <trans-unit id="787b1e3adc3eb7a1d5a6e75a6a8e36064a54f61d" translate="yes" xml:space="preserve">
          <source>Include warnings for functions that only return by an exception.</source>
          <target state="translated">例外によってのみ返される関数の警告を含めます。</target>
        </trans-unit>
        <trans-unit id="c9c702014dc9102936a21eccc903c8d6fd60705b" translate="yes" xml:space="preserve">
          <source>Include warnings for possible race conditions. Notice that the analysis that finds data races performs intra-procedural data flow analysis and can sometimes explode in time. Enable it at your own risk.</source>
          <target state="translated">レースが発生する可能性のある状態に対する警告を含めます。データの競合を検出する解析は、プロセス内でデータフロー解析を実行するため、時間的に爆発することがあることに注意してください。自己責任で有効にしてください。</target>
        </trans-unit>
        <trans-unit id="c2da810ae50606f552a617f96c162b1a8a5cbb8d" translate="yes" xml:space="preserve">
          <source>Included test messages</source>
          <target state="translated">含まれるテストメッセージ</target>
        </trans-unit>
        <trans-unit id="d01cc8205d9d2d88536ce346d12fc476f915ab3e" translate="yes" xml:space="preserve">
          <source>Includes a section containing call statistics for all calls regardless of process, in the analysis.</source>
          <target state="translated">分析には、プロセスに関係なくすべてのコールのコール統計を含むセクションが含まれています。</target>
        </trans-unit>
        <trans-unit id="529e9b923d0287eecd76a416e52d97fdc8ea0d45" translate="yes" xml:space="preserve">
          <source>Includes a time stamp in all trace messages. The time stamp (Ts) has the same form as returned by &lt;code&gt;erlang:now()&lt;/code&gt;.</source>
          <target state="translated">すべてのトレースメッセージにタイムスタンプを含めます。タイムスタンプ（Ts）は &lt;code&gt;erlang:now()&lt;/code&gt; によって返されるものと同じ形式です。</target>
        </trans-unit>
        <trans-unit id="c46ef04f4bea55e14a8a6db20798656add229d29" translate="yes" xml:space="preserve">
          <source>Includes an &lt;code&gt;&lt;a href=&quot;time_correction#Erlang_Monotonic_Time&quot;&gt;Erlang monotonic time&lt;/a&gt;&lt;/code&gt; time stamp in all trace messages. The time stamp (Ts) has the same format and value as produced by &lt;code&gt;&lt;a href=&quot;#monotonic_time-1&quot;&gt; erlang:monotonic_time(nanosecond)&lt;/a&gt;&lt;/code&gt;. This flag overrides flag &lt;code&gt;cpu_timestamp&lt;/code&gt;.</source>
          <target state="translated">含ま &lt;code&gt;&lt;a href=&quot;time_correction#Erlang_Monotonic_Time&quot;&gt;Erlang monotonic time&lt;/a&gt;&lt;/code&gt; すべてのトレース・メッセージにタイムスタンプを。タイムスタンプ（Ts）は、 &lt;code&gt;&lt;a href=&quot;#monotonic_time-1&quot;&gt; erlang:monotonic_time(nanosecond)&lt;/a&gt;&lt;/code&gt; によって生成されるものと同じ形式と値を持ちます。このフラグは、フラグ &lt;code&gt;cpu_timestamp&lt;/code&gt; をオーバーライドします。</target>
        </trans-unit>
        <trans-unit id="21580f3961c21f1aceb751d4061a09b3a76955d6" translate="yes" xml:space="preserve">
          <source>Includes an &lt;code&gt;&lt;a href=&quot;time_correction#Erlang_Monotonic_Time&quot;&gt;Erlang monotonic time&lt;/a&gt;&lt;/code&gt; time stamp in all trace messages. The time stamp (Ts) has the same format and value as produced by &lt;code&gt;&lt;a href=&quot;#monotonic_time-1&quot;&gt;erlang:monotonic_time(nanosecond)&lt;/a&gt;&lt;/code&gt;. This flag overrides flag &lt;code&gt;cpu_timestamp&lt;/code&gt;.</source>
          <target state="translated">含ま &lt;code&gt;&lt;a href=&quot;time_correction#Erlang_Monotonic_Time&quot;&gt;Erlang monotonic time&lt;/a&gt;&lt;/code&gt; すべてのトレース・メッセージにタイムスタンプを。タイムスタンプ（Ts）の形式と値は、 &lt;code&gt;&lt;a href=&quot;#monotonic_time-1&quot;&gt;erlang:monotonic_time(nanosecond)&lt;/a&gt;&lt;/code&gt; によって生成されたものと同じです。このフラグはフラグ &lt;code&gt;cpu_timestamp&lt;/code&gt; をオーバーライドします。</target>
        </trans-unit>
        <trans-unit id="029776045f3168e0cc5e9e683547f1e18a0a84fc" translate="yes" xml:space="preserve">
          <source>Includes an time stamp consisting of &lt;code&gt;&lt;a href=&quot;time_correction#Erlang_Monotonic_Time&quot;&gt;Erlang monotonic time&lt;/a&gt;&lt;/code&gt; and a monotonically increasing integer in all trace messages. The time stamp (Ts) has the same format and value as produced by &lt;code&gt;{&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;#monotonic_time-1&quot;&gt; erlang:monotonic_time(nanosecond)&lt;/a&gt;&lt;/code&gt;&lt;code&gt;,&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;#unique_integer-1&quot;&gt; erlang:unique_integer([monotonic])&lt;/a&gt;&lt;/code&gt;&lt;code&gt;}&lt;/code&gt;. This flag overrides flag &lt;code&gt;cpu_timestamp&lt;/code&gt;.</source>
          <target state="translated">すべてのトレースメッセージに、 &lt;code&gt;&lt;a href=&quot;time_correction#Erlang_Monotonic_Time&quot;&gt;Erlang monotonic time&lt;/a&gt;&lt;/code&gt; と単調に増加する整数で構成されるタイムスタンプが含まれます。タイムスタンプ（Ts）は、 &lt;code&gt;{&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;#monotonic_time-1&quot;&gt; erlang:monotonic_time(nanosecond)&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;#unique_integer-1&quot;&gt; erlang:unique_integer([monotonic])&lt;/a&gt;&lt;/code&gt; ） &lt;code&gt;,&lt;/code&gt; erlang：unique_integer（[monotonic]） &lt;code&gt;}&lt;/code&gt; によって生成されるものと同じ形式と値を持ちます。このフラグは、フラグ &lt;code&gt;cpu_timestamp&lt;/code&gt; をオーバーライドします。</target>
        </trans-unit>
        <trans-unit id="7123f161553e4dd460e1a837d1a70b743db16fa4" translate="yes" xml:space="preserve">
          <source>Includes an time stamp consisting of &lt;code&gt;&lt;a href=&quot;time_correction#Erlang_Monotonic_Time&quot;&gt;Erlang monotonic time&lt;/a&gt;&lt;/code&gt; and a monotonically increasing integer in all trace messages. The time stamp (Ts) has the same format and value as produced by &lt;code&gt;{&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;#monotonic_time-1&quot;&gt;erlang:monotonic_time(nanosecond)&lt;/a&gt;&lt;/code&gt;&lt;code&gt;,&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;#unique_integer-1&quot;&gt;erlang:unique_integer([monotonic])&lt;/a&gt;&lt;/code&gt;&lt;code&gt;}&lt;/code&gt;. This flag overrides flag &lt;code&gt;cpu_timestamp&lt;/code&gt;.</source>
          <target state="translated">すべてのトレースメッセージに、 &lt;code&gt;&lt;a href=&quot;time_correction#Erlang_Monotonic_Time&quot;&gt;Erlang monotonic time&lt;/a&gt;&lt;/code&gt; と単調に増加する整数で構成されるタイムスタンプが含まれます。タイムスタンプ（Ts）の形式と値は、 &lt;code&gt;{&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;#monotonic_time-1&quot;&gt;erlang:monotonic_time(nanosecond)&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;#unique_integer-1&quot;&gt;erlang:unique_integer([monotonic])&lt;/a&gt;&lt;/code&gt; ） &lt;code&gt;,&lt;/code&gt; erlang：unique_integer（[monotonic]） &lt;code&gt;}&lt;/code&gt; によって生成されるものと同じです。このフラグはフラグ &lt;code&gt;cpu_timestamp&lt;/code&gt; をオーバーライドします。</target>
        </trans-unit>
        <trans-unit id="59a53faa5ece992bf6eb22ad8651276afec5c122" translate="yes" xml:space="preserve">
          <source>Includes custom debug information in the form of a &lt;code&gt;Backend&lt;/code&gt; module with custom &lt;code&gt;Data&lt;/code&gt; in the compiled beam module. The given module must implement a &lt;code&gt;debug_info/4&lt;/code&gt; function and is responsible for generating different code representations, as described in the &lt;code&gt;debug_info&lt;/code&gt; under &lt;code&gt;beam_lib(3)&lt;/code&gt;.</source>
          <target state="translated">コンパイルされたビームモジュールにカスタム &lt;code&gt;Data&lt;/code&gt; を含む &lt;code&gt;Backend&lt;/code&gt; モジュールの形式でカスタムデバッグ情報を含めます。指定されたモジュールは &lt;code&gt;debug_info/4&lt;/code&gt; 関数を実装する必要があり、 &lt;code&gt;beam_lib(3)&lt;/code&gt; の &lt;code&gt;debug_info&lt;/code&gt; で説明されているように、さまざまなコード表現を生成する必要があります。</target>
        </trans-unit>
        <trans-unit id="09654fa1bf12f6550a22d7f012f2848d49adaf98" translate="yes" xml:space="preserve">
          <source>Includes debug information in the form of &lt;code&gt; Erlang Abstract Format&lt;/code&gt; in the &lt;code&gt;debug_info&lt;/code&gt; chunk of the compiled beam module. Tools such as Debugger, Xref, and Cover require the debug information to be included.</source>
          <target state="translated">コンパイルされたビームモジュールの &lt;code&gt;debug_info&lt;/code&gt; チャンクにErlangAbstractFormatの &lt;code&gt; Erlang Abstract Format&lt;/code&gt; でデバッグ情報を含めます。Debugger、Xref、Coverなどのツールでは、デバッグ情報を含める必要があります。</target>
        </trans-unit>
        <trans-unit id="b72745ef15f97e2eed8ddb85c88ed3745778131f" translate="yes" xml:space="preserve">
          <source>Includes debug information in the form of &lt;code&gt;Erlang Abstract Format&lt;/code&gt; in the &lt;code&gt;debug_info&lt;/code&gt; chunk of the compiled beam module. Tools such as Debugger, Xref, and Cover require the debug information to be included.</source>
          <target state="translated">コンパイルされたビームモジュールの &lt;code&gt;debug_info&lt;/code&gt; チャンクにデバッグ情報を &lt;code&gt;Erlang Abstract Format&lt;/code&gt; で含めます。Debugger、Xref、Coverなどのツールには、デバッグ情報を含める必要があります。</target>
        </trans-unit>
        <trans-unit id="50ee9bd2b0973e0a8782664b4e20754ea8733fba" translate="yes" xml:space="preserve">
          <source>Includes debug information, but encrypts it so that it cannot be accessed without supplying the key. (To give option &lt;code&gt;debug_info&lt;/code&gt; as well is allowed, but not necessary.) Using this option is a good way to always have the debug information available during testing, yet protecting the source code.</source>
          <target state="translated">デバッグ情報を含みますが、キーを提供しないとアクセスできないように暗号化します。（オプション &lt;code&gt;debug_info&lt;/code&gt; を指定することも可能ですが、必須ではありません。）このオプションを使用すると、テスト中にデバッグ情報を常に利用でき、しかもソースコードは保護されます。</target>
        </trans-unit>
        <trans-unit id="805a2af44ca1e2b71562d035c3b42720d4a88944" translate="yes" xml:space="preserve">
          <source>Includes property &lt;code&gt;{role, client | server}&lt;/code&gt;. Currently this is the only predefined property, there can also be user-defined properties. See also application environment variable &lt;code&gt;session_cb_init_args&lt;/code&gt;.</source>
          <target state="translated">プロパティ &lt;code&gt;{role, client | server}&lt;/code&gt; 。現在、これは唯一の事前定義されたプロパティですが、ユーザー定義のプロパティもあります。アプリケーション環境変数 &lt;code&gt;session_cb_init_args&lt;/code&gt; も参照してください。</target>
        </trans-unit>
        <trans-unit id="3537d431c47b4e76cf518f3b56096886e6209c2b" translate="yes" xml:space="preserve">
          <source>Including Literal Strings</source>
          <target state="translated">文字列を含む</target>
        </trans-unit>
        <trans-unit id="7705cf570e0db2364f0a8b0f968c2b052243e5be" translate="yes" xml:space="preserve">
          <source>Incoming Connections</source>
          <target state="translated">着信接続</target>
        </trans-unit>
        <trans-unit id="cfffe82b107254cee4127c092afe584c0200b55a" translate="yes" xml:space="preserve">
          <source>Incoming Diameter messages are decoded from binary() before being communicated to &lt;code&gt;diameter_app(3)&lt;/code&gt; callbacks. Similarly, outgoing Diameter messages are encoded into binary() before being passed to the appropriate &lt;code&gt;&lt;a href=&quot;diameter_transport&quot;&gt;diameter_transport(3)&lt;/a&gt;&lt;/code&gt; module for transmission. The functions documented here implement the default encode/decode.</source>
          <target state="translated">着信Diameterメッセージは、 &lt;code&gt;diameter_app(3)&lt;/code&gt; コールバックに伝達される前に、binary（）からデコードされます。同様に、発信Diameterメッセージは、送信用の適切な &lt;code&gt;&lt;a href=&quot;diameter_transport&quot;&gt;diameter_transport(3)&lt;/a&gt;&lt;/code&gt; モジュールに渡される前に、binary（）にエンコードされます。ここに記載されている関数は、デフォルトのエンコード/デコードを実装しています。</target>
        </trans-unit>
        <trans-unit id="c632222fe59d6393835f1d6b41daa8dcbb54dc28" translate="yes" xml:space="preserve">
          <source>Incoming messages is delivered by megaco:receive_message/4 and normally decoded successfully. But if the decoding failed this function is called in order to decide if the originator should get a reply message (reply) or if the reply silently should be discarded (no_reply).</source>
          <target state="translated">着信メッセージは megaco:receive_message/4 で配信され、通常は正常にデコードされます。しかし、デコードに失敗した場合、この関数が呼ばれ、発信者が返信メッセージを受け取るべきか (返信)、それとも無言で返信を破棄すべきか (no_reply)を判断するために呼び出されます。</target>
        </trans-unit>
        <trans-unit id="bbb9b00cfc07d6474962cea0fb79594d0c7f33f6" translate="yes" xml:space="preserve">
          <source>Incoming messages is delivered by megaco:receive_message/4 and successfully decoded. Normally a message contains a list of transactions and this function is invoked for each TransactionRequest in the message.</source>
          <target state="translated">受信したメッセージは、megaco:receive_message/4によって配信され、デコードに成功します。通常、メッセージにはトランザクションのリストが含まれており、この関数はメッセージ内の各トランザクションリクエストに対して呼び出されます。</target>
        </trans-unit>
        <trans-unit id="7d2155d7b153e6ddad7244575ab829476e447287" translate="yes" xml:space="preserve">
          <source>Incoming messages is delivered by megaco:receive_message/4 and successfully decoded. Normally a message contains a list of transactions, but it may instead contain an ErrorDescriptor on top level of the message.</source>
          <target state="translated">着信メッセージはmegaco:receive_message/4で配信され、デコードに成功しています。通常、メッセージにはトランザクションのリストが含まれていますが、その代わりにメッセージのトップレベルに ErrorDescriptor が含まれている場合があります。</target>
        </trans-unit>
        <trans-unit id="793c36e1e4e2e9196eba0419d11fe32cd2342b1a" translate="yes" xml:space="preserve">
          <source>Incompatible changes may occur between releases.</source>
          <target state="translated">リリース間で互換性のない変更が発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="f5e211548a14ccbf061765bad659c7e963fece50" translate="yes" xml:space="preserve">
          <source>Inconsistent stream state.</source>
          <target state="translated">流れの状態が一貫していない。</target>
        </trans-unit>
        <trans-unit id="f91465c3f77f3d3269bf0de89bd0e5136eadf0ec" translate="yes" xml:space="preserve">
          <source>Incorrect UTF encoding.</source>
          <target state="translated">UTF エンコーディングが正しくありません。</target>
        </trans-unit>
        <trans-unit id="845a0fc6405933efbba9490c6fc4f32adaee1aa6" translate="yes" xml:space="preserve">
          <source>Incr :: integer()) -&amp;gt;</source>
          <target state="translated">Incr :: integer()) -&amp;gt;</target>
        </trans-unit>
        <trans-unit id="1d24ce4d50ea5331d982cda5d863bb706d720600" translate="yes" xml:space="preserve">
          <source>Increases the suspend count on the process identified by &lt;code&gt;Suspendee&lt;/code&gt; and puts it in the suspended state if it is not already in that state. A suspended process is not scheduled for execution until the process has been resumed.</source>
          <target state="translated">&lt;code&gt;Suspendee&lt;/code&gt; によって識別されたプロセスの中断カウントを増やし、まだその状態になっていない場合は、それを中断状態にします。中断されたプロセスは、プロセスが再開されるまで実行がスケジュールされません。</target>
        </trans-unit>
        <trans-unit id="360be904729f90e5380efbfa1ebc525a6bb6168c" translate="yes" xml:space="preserve">
          <source>Increasingly bad performance of mmap/munmap as the number of mmap'ed areas grow.</source>
          <target state="translated">mmap/munmap のパフォーマンスが、mmap'ed エリアの数が増えるにつれて悪化しています。</target>
        </trans-unit>
        <trans-unit id="c1ce75ee57dec21e5d02eb0055b76a4460422603" translate="yes" xml:space="preserve">
          <source>Incremented when NIF library incompatible changes are made to the Erlang runtime system. Normally it suffices to recompile the NIF library when the &lt;code&gt;ERL_NIF_MAJOR_VERSION&lt;/code&gt; has changed, but it can, under rare circumstances, mean that NIF libraries must be slightly modified. If so, this will of course be documented.</source>
          <target state="translated">ErlangランタイムシステムにNIFライブラリの互換性のない変更が加えられると増加します。通常、 &lt;code&gt;ERL_NIF_MAJOR_VERSION&lt;/code&gt; が変更された場合は、NIFライブラリを再コンパイルするだけで十分ですが、まれに、NIFライブラリを少し変更する必要がある場合があります。もしそうなら、これはもちろん文書化されます。</target>
        </trans-unit>
        <trans-unit id="84678a3e577756daefc285cd45b2bc2e297ad5ec" translate="yes" xml:space="preserve">
          <source>Incremented when new features are added. The runtime system uses the minor version to determine what features to use.</source>
          <target state="translated">新しい機能が追加されたときに増加します。ランタイムシステムは、どの機能を使用するかを決定するためにマイナーバージョンを使用します。</target>
        </trans-unit>
        <trans-unit id="57135dbc3bf5f91f10354efacc0f552c2d6e0f14" translate="yes" xml:space="preserve">
          <source>Increments a variable in the MIB with &lt;code&gt;N&lt;/code&gt;, or one if &lt;code&gt;N&lt;/code&gt; is not specified.</source>
          <target state="translated">MIBの変数を &lt;code&gt;N&lt;/code&gt; でインクリメントします &lt;code&gt;N&lt;/code&gt; が指定されていない場合は1 をインクリメントします。</target>
        </trans-unit>
        <trans-unit id="9c9e63796462f25fa87f2866f5f82ef633d51dee" translate="yes" xml:space="preserve">
          <source>Increments map iterator to point to the next key-value entry.</source>
          <target state="translated">次のキー値エントリを指すようにマップ・イテレータをインクリメントします。</target>
        </trans-unit>
        <trans-unit id="8f239c48f8608dfc7dad0cea2bfd35ef11b36366" translate="yes" xml:space="preserve">
          <source>Increments the reference count of the port data lock passed as argument (&lt;code&gt;pdl&lt;/code&gt;).</source>
          <target state="translated">引数（ &lt;code&gt;pdl&lt;/code&gt; ）として渡されたポートデータロックの参照カウントをインクリメントします。</target>
        </trans-unit>
        <trans-unit id="d877566e1bec90ff2d29720de068fd3d3fddd99b" translate="yes" xml:space="preserve">
          <source>Increments the reference count on &lt;code&gt;bin&lt;/code&gt; and returns the reference count reached after the increment.</source>
          <target state="translated">上のインクリメント参照カウント &lt;code&gt;bin&lt;/code&gt; とリターンは参照カウントがインクリメント後に到達しました。</target>
        </trans-unit>
        <trans-unit id="6885d93d080432a665a8c21adf295eb79d2e88f7" translate="yes" xml:space="preserve">
          <source>Increments the variable associated with a discarded pdu. This function can be used when the net_if process receives a &lt;code&gt;discarded_pdu&lt;/code&gt; message from the agent.</source>
          <target state="translated">破棄されたpduに関連付けられた変数をインクリメントします。この関数は、net_ifプロセスがエージェントから &lt;code&gt;discarded_pdu&lt;/code&gt; たpdu メッセージを受信したときに使用できます。</target>
        </trans-unit>
        <trans-unit id="aacf42132cce6cf5c1608a5d27f90fcbf93ae851" translate="yes" xml:space="preserve">
          <source>Indent</source>
          <target state="translated">Indent</target>
        </trans-unit>
        <trans-unit id="a1dc8ae1f28e23fc7131a69f785c7a7e4f9ac70d" translate="yes" xml:space="preserve">
          <source>Indents a document a number of character positions to the right. Note that &lt;code&gt;N&lt;/code&gt; may be negative, shifting the text to the left, or zero, in which case &lt;code&gt;D&lt;/code&gt; is returned unchanged.</source>
          <target state="translated">文書をいくつかの文字位置で右にインデントします。 &lt;code&gt;N&lt;/code&gt; が負の場合、テキストを左にシフトするかゼロになる場合があることに注意してください。この場合、 &lt;code&gt;D&lt;/code&gt; は変更されずに返されます。</target>
        </trans-unit>
        <trans-unit id="b03e59c23d6f82c97ce8cf0f7790602979c8e4da" translate="yes" xml:space="preserve">
          <source>Indexes do not come for free. They occupy space that is proportional to the table size, and they cause insertions into the table to execute slightly slower.</source>
          <target state="translated">インデックスは無償では提供されません。インデックスはテーブルのサイズに比例したスペースを占有し、テーブルへの挿入の実行が若干遅くなります。</target>
        </trans-unit>
        <trans-unit id="66f3ae8a6cbff45c5e61fef46e620b30441f2993" translate="yes" xml:space="preserve">
          <source>Indexes in a table must be objects, not types (deviates from SMIv1 only).</source>
          <target state="translated">テーブル内のインデックスは、型ではなくオブジェクトでなければなりません(SMIv1のみから逸脱しています)。</target>
        </trans-unit>
        <trans-unit id="41fd24de9543beb15639d7be950596afb05d2918" translate="yes" xml:space="preserve">
          <source>Indexes into atomic arrays are one-based. An atomic array of arity N contains N atomics with index from 1 to N.</source>
          <target state="translated">原子配列へのインデックスは,1を基準とします.アリティ N の原子配列には,1 から N までのインデックスを持つ N 個の原子が含まれます.</target>
        </trans-unit>
        <trans-unit id="d1276b938031e0556a12602f87fa510de52c86d9" translate="yes" xml:space="preserve">
          <source>Indexes into counter arrays are one-based. A counter array of size N contains N counters with index from 1 to N.</source>
          <target state="translated">カウンタ配列へのインデックスは1ベースです。サイズNのカウンタ配列は1からNまでのインデックスを持つN個のカウンタを含みます。</target>
        </trans-unit>
        <trans-unit id="9951861c21df18489a5872209655d6f9039b5e2a" translate="yes" xml:space="preserve">
          <source>Indexing</source>
          <target state="translated">Indexing</target>
        </trans-unit>
        <trans-unit id="617aa3438335193f784faa90321050a9a7e9ecfd" translate="yes" xml:space="preserve">
          <source>Indicate if the elements of the array will be treated as signed or unsigned integers. Default is &lt;code&gt;true&lt;/code&gt; (signed).</source>
          <target state="translated">配列の要素が符号付き整数または符号なし整数として扱われるかどうかを示します。デフォルトは &lt;code&gt;true&lt;/code&gt; （符号付き）です。</target>
        </trans-unit>
        <trans-unit id="295bcf395f6ba1c793b51510dd315c49a1cd7e27" translate="yes" xml:space="preserve">
          <source>Indicates a broken link. &lt;code&gt;msg-&amp;gt;to&lt;/code&gt; and &lt;code&gt;msg-&amp;gt;from&lt;/code&gt; contain the pids of the linked processes.</source>
          <target state="translated">リンク切れを示します。 &lt;code&gt;msg-&amp;gt;to&lt;/code&gt; および &lt;code&gt;msg-&amp;gt;from&lt;/code&gt; には、リンクされたプロセスのPIDが含まれています。</target>
        </trans-unit>
        <trans-unit id="6278f3e704c53d6a2b0b2b9ee6bea9f7e00a82d7" translate="yes" xml:space="preserve">
          <source>Indicates a customized prologue file which the user may want to use instead of the default file &lt;code&gt;lib/parsetools/include/yeccpre.hrl&lt;/code&gt; which is otherwise included at the beginning of the resulting parser file. &lt;strong&gt;N.B.&lt;/strong&gt; The &lt;code&gt;Includefile&lt;/code&gt; is included 'as is' in the parser file, so it must not have a module declaration of its own, and it should not be compiled. It must, however, contain the necessary export declarations. The default is indicated by &lt;code&gt;&quot;&quot;&lt;/code&gt;.</source>
          <target state="translated">結果のパーサーファイルの先頭に含まれるデフォルトファイル &lt;code&gt;lib/parsetools/include/yeccpre.hrl&lt;/code&gt; の代わりに、ユーザーが使用するカスタマイズされたプロローグファイルを示します。&lt;strong&gt;注&lt;/strong&gt;： &lt;code&gt;Includefile&lt;/code&gt; はパーサーファイルに「そのまま」インクルードされるため、独自のモジュール宣言を含めることはできません。また、コンパイルしないでください。ただし、必要な輸出申告が含まれている必要があります。デフォルトは &lt;code&gt;&quot;&quot;&lt;/code&gt; で示されます。</target>
        </trans-unit>
        <trans-unit id="7baca088d4a47e1b532691a75a666d58750c6872" translate="yes" xml:space="preserve">
          <source>Indicates change of the status of the IP address of the peer specified by &lt;code&gt;addr&lt;/code&gt; within association &lt;code&gt;assoc_id&lt;/code&gt;. Possible values of &lt;code&gt;state&lt;/code&gt; (mostly self-explanatory) include:</source>
          <target state="translated">関連 &lt;code&gt;assoc_id&lt;/code&gt; 内の &lt;code&gt;addr&lt;/code&gt; によって指定されたピアのIPアドレスのステータスの変更を示します。 &lt;code&gt;state&lt;/code&gt; 可能な値（主に説明不要）には、次のものがあります。</target>
        </trans-unit>
        <trans-unit id="c1e223ab1bee245ce8340356f73b51f2137316ba" translate="yes" xml:space="preserve">
          <source>Indicates character range</source>
          <target state="translated">文字範囲を示す</target>
        </trans-unit>
        <trans-unit id="ac69dafa8c067eb5122ac56c8384ac8f712d4875" translate="yes" xml:space="preserve">
          <source>Indicates if all application code paths are to be updated (&lt;code&gt;Bool==true&lt;/code&gt;) or if only code paths for modified applications are to be updated (&lt;code&gt;Bool==false&lt;/code&gt;, default). This option has only effect for other application directories than the default &lt;code&gt;$ROOT/lib/App-Vsn&lt;/code&gt;, that is, application directories specified in argument &lt;code&gt;AppDirs&lt;/code&gt; in a call to &lt;code&gt;&lt;a href=&quot;#create_RELEASES-4&quot;&gt;create_RELEASES/4&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#set_unpacked-2&quot;&gt;set_unpacked/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">すべてのアプリケーションコードパスを更新するか（ &lt;code&gt;Bool==true&lt;/code&gt; ）、変更したアプリケーションのコードパスのみを更新するか（ &lt;code&gt;Bool==false&lt;/code&gt; 、デフォルト）を示します。このオプションは、デフォルトの &lt;code&gt;$ROOT/lib/App-Vsn&lt;/code&gt; 以外のアプリケーションディレクトリ、つまり &lt;code&gt;&lt;a href=&quot;#create_RELEASES-4&quot;&gt;create_RELEASES/4&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;#set_unpacked-2&quot;&gt;set_unpacked/2&lt;/a&gt;&lt;/code&gt; の呼び出しで引数 &lt;code&gt;AppDirs&lt;/code&gt; に指定されたアプリケーションディレクトリにのみ影響します。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
